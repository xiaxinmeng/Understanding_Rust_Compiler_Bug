{"sha": "67723321fb917e94acf5844c2524ca3d9655ff7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc3MjMzMjFmYjkxN2U5NGFjZjU4NDRjMjUyNGNhM2Q5NjU1ZmY3Yg==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2020-01-10T13:33:10Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2020-01-10T13:33:10Z"}, "message": "[vect] Keep track of DR_OFFSET advance in dr_vec_info rather than data_reference\n\ngcc/ChangeLog:\n2020-01-10  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref): Use\n\tget_dr_vinfo_offset\n\t* tree-vect-loop.c (update_epilogue_loop_vinfo):  Remove orig_drs_init\n\tparameter and its use to reset DR_OFFSET's.\n\t(vect_transform_loop): Remove orig_drs_init argument.\n\t* tree-vect-loop-manip.c (vect_update_init_of_dr): Update the offset\n\tmember of dr_vec_info rather than the offset of the associated\n\tdata_reference's innermost_loop_behavior.\n\t(vect_update_init_of_dr): Pass dr_vec_info instead of data_reference.\n\t(vect_do_peeling): Remove orig_drs_init parameter and its construction.\n\t* tree-vect-stmts.c (check_scan_store): Replace use of DR_OFFSET with\n\tget_dr_vinfo_offset.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r280107", "tree": {"sha": "0806370357ddf99d3d69bf501bd92a197b18ff8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0806370357ddf99d3d69bf501bd92a197b18ff8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67723321fb917e94acf5844c2524ca3d9655ff7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67723321fb917e94acf5844c2524ca3d9655ff7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67723321fb917e94acf5844c2524ca3d9655ff7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67723321fb917e94acf5844c2524ca3d9655ff7b/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b412bf65c0947d589d0eaf6348f29e24cda01c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b412bf65c0947d589d0eaf6348f29e24cda01c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b412bf65c0947d589d0eaf6348f29e24cda01c9"}], "stats": {"total": 97, "additions": 65, "deletions": 32}, "files": [{"sha": "e8ea7b79f4ac19a08d998fcab20abe12b3a21853", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67723321fb917e94acf5844c2524ca3d9655ff7b", "patch": "@@ -1,3 +1,20 @@\n+2020-01-10  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref): Use\n+\tget_dr_vinfo_offset\n+\t* tree-vect-loop.c (update_epilogue_loop_vinfo):  Remove orig_drs_init\n+\tparameter and its use to reset DR_OFFSET's.\n+\t(vect_transform_loop): Remove orig_drs_init argument.\n+\t* tree-vect-loop-manip.c (vect_update_init_of_dr): Update the offset\n+\tmember of dr_vec_info rather than the offset of the associated\n+\tdata_reference's innermost_loop_behavior.\n+\t(vect_update_init_of_dr): Pass dr_vec_info instead of data_reference.\n+\t(vect_do_peeling): Remove orig_drs_init parameter and its construction.\n+\t* tree-vect-stmts.c (check_scan_store): Replace use of DR_OFFSET with\n+\tget_dr_vinfo_offset.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\n 2020-01-10  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-ssa-store-merging"}, {"sha": "554ef892254c8d8a5ffa6b1e61429cd02f4a3a7f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=67723321fb917e94acf5844c2524ca3d9655ff7b", "patch": "@@ -4597,7 +4597,7 @@ vect_create_addr_base_for_vector_ref (stmt_vec_info stmt_info,\n   innermost_loop_behavior *drb = vect_dr_behavior (dr_info);\n \n   tree data_ref_base = unshare_expr (drb->base_address);\n-  tree base_offset = unshare_expr (drb->offset);\n+  tree base_offset = unshare_expr (get_dr_vinfo_offset (dr_info, true));\n   tree init = unshare_expr (drb->init);\n \n   if (loop_vinfo)"}, {"sha": "52ca4e3e56c494edd3e73c627be4ccec43d79243", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=67723321fb917e94acf5844c2524ca3d9655ff7b", "patch": "@@ -1716,19 +1716,22 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n    iterations before the scalar one (using masking to skip inactive\n    elements).  This function updates the information recorded in DR to\n    account for the difference.  Specifically, it updates the OFFSET\n-   field of DR.  */\n+   field of DR_INFO.  */\n \n static void\n-vect_update_init_of_dr (struct data_reference *dr, tree niters, tree_code code)\n+vect_update_init_of_dr (dr_vec_info *dr_info, tree niters, tree_code code)\n {\n-  tree offset = DR_OFFSET (dr);\n+  struct data_reference *dr = dr_info->dr;\n+  tree offset = dr_info->offset;\n+  if (!offset)\n+    offset = build_zero_cst (sizetype);\n \n   niters = fold_build2 (MULT_EXPR, sizetype,\n \t\t\tfold_convert (sizetype, niters),\n \t\t\tfold_convert (sizetype, DR_STEP (dr)));\n   offset = fold_build2 (code, sizetype,\n \t\t\tfold_convert (sizetype, offset), niters);\n-  DR_OFFSET (dr) = offset;\n+  dr_info->offset = offset;\n }\n \n \n@@ -1758,7 +1761,7 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,\n     {\n       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n       if (!STMT_VINFO_GATHER_SCATTER_P (dr_info->stmt))\n-\tvect_update_init_of_dr (dr, niters, code);\n+\tvect_update_init_of_dr (dr_info, niters, code);\n     }\n }\n \n@@ -2446,7 +2449,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t tree *niters_vector, tree *step_vector,\n \t\t tree *niters_vector_mult_vf_var, int th,\n \t\t bool check_profitability, bool niters_no_overflow,\n-\t\t tree *advance, drs_init_vec &orig_drs_init)\n+\t\t tree *advance)\n {\n   edge e, guard_e;\n   tree type = TREE_TYPE (niters), guard_cond;\n@@ -2694,14 +2697,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  scale_loop_profile (prolog, prob_prolog, bound_prolog);\n \t}\n \n-      /* Save original inits for each data_reference before advancing them with\n-\t NITERS_PROLOG.  */\n-      unsigned int i;\n-      struct data_reference *dr;\n-      vec<data_reference_p> datarefs = loop_vinfo->shared->datarefs;\n-      FOR_EACH_VEC_ELT (datarefs, i, dr)\n-\torig_drs_init.safe_push (std::make_pair (dr, DR_OFFSET (dr)));\n-\n       /* Update init address of DRs.  */\n       vect_update_inits_of_drs (loop_vinfo, niters_prolog, PLUS_EXPR);\n       /* Update niters for vector loop.  */"}, {"sha": "596eafc2d3f056447d2c683241d711bd53601c11", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=67723321fb917e94acf5844c2524ca3d9655ff7b", "patch": "@@ -8333,8 +8333,7 @@ find_in_mapping (tree t, void *context)\n    prologue of the main loop.  */\n \n static void\n-update_epilogue_loop_vinfo (class loop *epilogue, tree advance,\n-\t\t\t    drs_init_vec &orig_drs_init)\n+update_epilogue_loop_vinfo (class loop *epilogue, tree advance)\n {\n   loop_vec_info epilogue_vinfo = loop_vec_info_for_loop (epilogue);\n   auto_vec<gimple *> stmt_worklist;\n@@ -8344,16 +8343,10 @@ update_epilogue_loop_vinfo (class loop *epilogue, tree advance,\n   gphi_iterator epilogue_phi_gsi;\n   stmt_vec_info stmt_vinfo = NULL, related_vinfo;\n   basic_block *epilogue_bbs = get_loop_body (epilogue);\n+  unsigned i;\n \n   LOOP_VINFO_BBS (epilogue_vinfo) = epilogue_bbs;\n \n-  /* Restore original data_reference's offset, before the previous loop and its\n-     prologue.  */\n-  std::pair<data_reference*, tree> *dr_init;\n-  unsigned i;\n-  for (i = 0; orig_drs_init.iterate (i, &dr_init); i++)\n-    DR_OFFSET (dr_init->first) = dr_init->second;\n-\n   /* Advance data_reference's with the number of iterations of the previous\n      loop and its prologue.  */\n   vect_update_inits_of_drs (epilogue_vinfo, advance, PLUS_EXPR);\n@@ -8569,7 +8562,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   epilogue = vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector,\n \t\t\t      &step_vector, &niters_vector_mult_vf, th,\n \t\t\t      check_profitability, niters_no_overflow,\n-\t\t\t      &advance, orig_drs_init);\n+\t\t\t      &advance);\n \n   if (LOOP_VINFO_SCALAR_LOOP (loop_vinfo)\n       && LOOP_VINFO_SCALAR_LOOP_SCALING (loop_vinfo).initialized_p ())\n@@ -8828,7 +8821,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n   if (epilogue)\n     {\n-      update_epilogue_loop_vinfo (epilogue, advance, orig_drs_init);\n+      update_epilogue_loop_vinfo (epilogue, advance);\n \n       epilogue->simduid = loop->simduid;\n       epilogue->force_vectorize = loop->force_vectorize;"}, {"sha": "df2899b476399cccc3c17afc9b016692e28c1632", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=67723321fb917e94acf5844c2524ca3d9655ff7b", "patch": "@@ -6629,7 +6629,7 @@ check_scan_store (stmt_vec_info stmt_info, tree vectype,\n       || loop_vinfo == NULL\n       || LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n       || STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-      || !integer_zerop (DR_OFFSET (dr_info->dr))\n+      || !integer_zerop (get_dr_vinfo_offset (dr_info))\n       || !integer_zerop (DR_INIT (dr_info->dr))\n       || !(ref_type = reference_alias_ptr_type (DR_REF (dr_info->dr)))\n       || !alias_sets_conflict_p (get_alias_set (vectype),\n@@ -7762,18 +7762,20 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       tree running_off;\n       tree stride_base, stride_step, alias_off;\n       tree vec_oprnd;\n+      tree dr_offset;\n       unsigned int g;\n       /* Checked by get_load_store_type.  */\n       unsigned int const_nunits = nunits.to_constant ();\n \n       gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n       gcc_assert (!nested_in_vect_loop_p (loop, stmt_info));\n \n+      dr_offset = get_dr_vinfo_offset (first_dr_info);\n       stride_base\n \t= fold_build_pointer_plus\n \t    (DR_BASE_ADDRESS (first_dr_info->dr),\n \t     size_binop (PLUS_EXPR,\n-\t\t\t convert_to_ptrofftype (DR_OFFSET (first_dr_info->dr)),\n+\t\t\t convert_to_ptrofftype (dr_offset),\n \t\t\t convert_to_ptrofftype (DR_INIT (first_dr_info->dr))));\n       stride_step = fold_convert (sizetype, DR_STEP (first_dr_info->dr));\n \n@@ -8136,7 +8138,7 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t      && !loop_masks\n \t      && TREE_CODE (DR_BASE_ADDRESS (first_dr_info->dr)) == ADDR_EXPR\n \t      && VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (first_dr_info->dr), 0))\n-\t      && integer_zerop (DR_OFFSET (first_dr_info->dr))\n+\t      && integer_zerop (get_dr_vinfo_offset (first_dr_info))\n \t      && integer_zerop (DR_INIT (first_dr_info->dr))\n \t      && alias_sets_conflict_p (get_alias_set (aggr_type),\n \t\t\t\t\tget_alias_set (TREE_TYPE (ref_type))))\n@@ -8830,6 +8832,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       /* Checked by get_load_store_type.  */\n       unsigned int const_nunits = nunits.to_constant ();\n       unsigned HOST_WIDE_INT cst_offset = 0;\n+      tree dr_offset;\n \n       gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n       gcc_assert (!nested_in_vect_loop);\n@@ -8860,11 +8863,12 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  ref_type = reference_alias_ptr_type (DR_REF (dr_info->dr));\n \t}\n \n+      dr_offset = get_dr_vinfo_offset (first_dr_info);\n       stride_base\n \t= fold_build_pointer_plus\n \t    (DR_BASE_ADDRESS (first_dr_info->dr),\n \t     size_binop (PLUS_EXPR,\n-\t\t\t convert_to_ptrofftype (DR_OFFSET (first_dr_info->dr)),\n+\t\t\t convert_to_ptrofftype (dr_offset),\n \t\t\t convert_to_ptrofftype (DR_INIT (first_dr_info->dr))));\n       stride_step = fold_convert (sizetype, DR_STEP (first_dr_info->dr));\n \n@@ -9329,7 +9333,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  if (simd_lane_access_p\n \t      && TREE_CODE (DR_BASE_ADDRESS (first_dr_info->dr)) == ADDR_EXPR\n \t      && VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (first_dr_info->dr), 0))\n-\t      && integer_zerop (DR_OFFSET (first_dr_info->dr))\n+\t      && integer_zerop (get_dr_vinfo_offset (first_dr_info))\n \t      && integer_zerop (DR_INIT (first_dr_info->dr))\n \t      && alias_sets_conflict_p (get_alias_set (aggr_type),\n \t\t\t\t\tget_alias_set (TREE_TYPE (ref_type)))"}, {"sha": "58c12323fc92c2fead0936297607370ea1afb5fd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67723321fb917e94acf5844c2524ca3d9655ff7b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=67723321fb917e94acf5844c2524ca3d9655ff7b", "patch": "@@ -910,6 +910,10 @@ class dr_vec_info {\n   /* If true the alignment of base_decl needs to be increased.  */\n   bool base_misaligned;\n   tree base_decl;\n+\n+  /* Stores current vectorized loop's offset.  To be added to the DR's\n+     offset to calculate current offset of data reference.  */\n+  tree offset;\n };\n \n typedef struct data_reference *dr_p;\n@@ -1485,6 +1489,26 @@ vect_dr_behavior (dr_vec_info *dr_info)\n     return &STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info);\n }\n \n+inline tree\n+get_dr_vinfo_offset (dr_vec_info *dr_info, bool check_outer = false)\n+{\n+  innermost_loop_behavior *base;\n+  if (check_outer)\n+    base = vect_dr_behavior (dr_info);\n+  else\n+    base = &dr_info->dr->innermost;\n+\n+  tree offset = base->offset;\n+\n+  if (!dr_info->offset)\n+    return offset;\n+\n+  offset = fold_convert (sizetype, offset);\n+  return fold_build2 (PLUS_EXPR, TREE_TYPE (dr_info->offset), offset,\n+\t\t      dr_info->offset);\n+}\n+\n+\n /* Return true if the vect cost model is unlimited.  */\n static inline bool\n unlimited_cost_model (loop_p loop)\n@@ -1655,7 +1679,7 @@ class loop *slpeel_tree_duplicate_loop_to_edge_cfg (class loop *,\n class loop *vect_loop_versioning (loop_vec_info);\n extern class loop *vect_do_peeling (loop_vec_info, tree, tree,\n \t\t\t\t    tree *, tree *, tree *, int, bool, bool,\n-\t\t\t\t    tree *, drs_init_vec &);\n+\t\t\t\t    tree *);\n extern void vect_prepare_for_masked_peels (loop_vec_info);\n extern dump_user_location_t find_loop_location (class loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);"}]}