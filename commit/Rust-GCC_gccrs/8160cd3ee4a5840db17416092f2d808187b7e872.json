{"sha": "8160cd3ee4a5840db17416092f2d808187b7e872", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE2MGNkM2VlNGE1ODQwZGIxNzQxNjA5MmYyZDgwODE4N2I3ZTg3Mg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-11-09T16:45:15Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-11-09T16:45:15Z"}, "message": "re PR rtl-optimization/63620 (RELOAD lost SET_GOT dependency on Darwin)\n\n2014-11-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/63620\n\t* lra-constraints.c (substitute_pseudo): Add prefix lra_ to the\n\tname.  Move to lra.c.  Make it external.\n\t(substitute_pseudo_within_insn): Ditto.\n\t(inherit_reload_reg, split_reg, remove_inheritance_pseudos): Use\n\tthe new names.\n\t(undo_optional_reloads): Ditto.\n\t* lra-int.h (lra_dump_bitmap_with_title, lra_substitute_pseudo):\n\tNew prototypes.\n\t(lra_substitute_pseudo_within_insn): Ditto.\n\t* lra-lives.c (bb_killed_pseudos, bb_gen_pseudos): New.\n\t(mark_regno_live): Add parameter.  Update bb_gen_pseudos.\n\t(mark_regno_dead): Add parameter.  Update bb_gen_pseudos and\n\tbb_killed_pseudos.\n\t(struct bb_data, bb_data_t, bb_data): New.\n\t(get_bb_data, get_bb_data_by_index): Ditto.\n\t(all_hard_regs_bitmap): New.\n\t(live_trans_fun, live_con_fun_0, live_con_fun_n, all_blocks): New.\n\t(initiate_live_solver, finish_live_solver): New.\n\t(process_bb_lives): Change return type.  Add code updating local\n\tlive data and removing dead insns.  Pass new argument to\n\tmark_regno_live and mark_regno_dead.  Check changing bb pseudo\n\tlife info.  Return the result.\n\t(lra_create_live_ranges): Add code to do global pseudo live\n\tanalysis.\n\t(lra_live_ranges_init): Call initiate_live_solver.\n\t(lra_live_ranges_finish): Call finish_live_solver.\n\t* lra.c (lra_dump_bitmap_with_title): New.\n\t(lra_substitute_pseudo, lra_substitute_pseudo_within_insn): Move\n\tfrom lra-constraints.c.\n\nFrom-SVN: r217265", "tree": {"sha": "1cde2f4fc77823a9e058d48a80d31252d0b0cc29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cde2f4fc77823a9e058d48a80d31252d0b0cc29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8160cd3ee4a5840db17416092f2d808187b7e872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8160cd3ee4a5840db17416092f2d808187b7e872", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8160cd3ee4a5840db17416092f2d808187b7e872", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8160cd3ee4a5840db17416092f2d808187b7e872/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "205e92689198d4718a07adfb0077821cfa93e761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/205e92689198d4718a07adfb0077821cfa93e761", "html_url": "https://github.com/Rust-GCC/gccrs/commit/205e92689198d4718a07adfb0077821cfa93e761"}], "stats": {"total": 516, "additions": 421, "deletions": 95}, "files": [{"sha": "c2e61a56351a2cd107da498bdc02ef9f960e0351", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8160cd3ee4a5840db17416092f2d808187b7e872", "patch": "@@ -1,3 +1,36 @@\n+2014-11-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/63620\n+\t* lra-constraints.c (substitute_pseudo): Add prefix lra_ to the\n+\tname.  Move to lra.c.  Make it external.\n+\t(substitute_pseudo_within_insn): Ditto.\n+\t(inherit_reload_reg, split_reg, remove_inheritance_pseudos): Use\n+\tthe new names.\n+\t(undo_optional_reloads): Ditto.\n+\t* lra-int.h (lra_dump_bitmap_with_title, lra_substitute_pseudo):\n+\tNew prototypes.\n+\t(lra_substitute_pseudo_within_insn): Ditto.\n+\t* lra-lives.c (bb_killed_pseudos, bb_gen_pseudos): New.\n+\t(mark_regno_live): Add parameter.  Update bb_gen_pseudos.\n+\t(mark_regno_dead): Add parameter.  Update bb_gen_pseudos and\n+\tbb_killed_pseudos.\n+\t(struct bb_data, bb_data_t, bb_data): New.\n+\t(get_bb_data, get_bb_data_by_index): Ditto.\n+\t(all_hard_regs_bitmap): New.\n+\t(live_trans_fun, live_con_fun_0, live_con_fun_n, all_blocks): New.\n+\t(initiate_live_solver, finish_live_solver): New.\n+\t(process_bb_lives): Change return type.  Add code updating local\n+\tlive data and removing dead insns.  Pass new argument to\n+\tmark_regno_live and mark_regno_dead.  Check changing bb pseudo\n+\tlife info.  Return the result.\n+\t(lra_create_live_ranges): Add code to do global pseudo live\n+\tanalysis.\n+\t(lra_live_ranges_init): Call initiate_live_solver.\n+\t(lra_live_ranges_finish): Call finish_live_solver.\n+\t* lra.c (lra_dump_bitmap_with_title): New.\n+\t(lra_substitute_pseudo, lra_substitute_pseudo_within_insn): Move\n+\tfrom lra-constraints.c.\n+\n 2014-11-09  Richard Biener  <rguenther@suse.de>\n \n \t* match.pd: Add patterns convering two conversions in a row"}, {"sha": "73533547942f44ad59d44a21686fabfd6a8dbe46", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 5, "deletions": 66, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=8160cd3ee4a5840db17416092f2d808187b7e872", "patch": "@@ -4366,67 +4366,6 @@ add_next_usage_insn (int regno, rtx insn, int reloads_num)\n     usage_insns[regno].check = 0;\n }\n \n-/* Replace all references to register OLD_REGNO in *LOC with pseudo\n-   register NEW_REG.  Return true if any change was made.  */\n-static bool\n-substitute_pseudo (rtx *loc, int old_regno, rtx new_reg)\n-{\n-  rtx x = *loc;\n-  bool result = false;\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i, j;\n-\n-  if (x == NULL_RTX)\n-    return false;\n-\n-  code = GET_CODE (x);\n-  if (code == REG && (int) REGNO (x) == old_regno)\n-    {\n-      machine_mode mode = GET_MODE (*loc);\n-      machine_mode inner_mode = GET_MODE (new_reg);\n-\n-      if (mode != inner_mode)\n-\t{\n-\t  if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (inner_mode)\n-\t      || ! SCALAR_INT_MODE_P (inner_mode))\n-\t    new_reg = gen_rtx_SUBREG (mode, new_reg, 0);\n-\t  else\n-\t    new_reg = gen_lowpart_SUBREG (mode, new_reg);\n-\t}\n-      *loc = new_reg;\n-      return true;\n-    }\n-\n-  /* Scan all the operand sub-expressions.  */\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (substitute_pseudo (&XEXP (x, i), old_regno, new_reg))\n-\t    result = true;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (substitute_pseudo (&XVECEXP (x, i, j), old_regno, new_reg))\n-\t      result = true;\n-\t}\n-    }\n-  return result;\n-}\n-\n-/* Call substitute_pseudo within an insn.  This won't update the insn ptr,\n-   just the contents of the insn.  */\n-\n-static bool\n-substitute_pseudo_within_insn (rtx_insn *insn, int old_regno, rtx new_reg)\n-{\n-  rtx loc = insn;\n-  return substitute_pseudo (&loc, old_regno, new_reg);\n-}\n-\n /* Return first non-debug insn in list USAGE_INSNS.  */\n static rtx_insn *\n skip_usage_debug_insns (rtx usage_insns)\n@@ -4588,7 +4527,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t}\n       return false;\n     }\n-  substitute_pseudo_within_insn (insn, original_regno, new_reg);\n+  lra_substitute_pseudo_within_insn (insn, original_regno, new_reg);\n   lra_update_insn_regno_info (insn);\n   if (! def_p)\n     /* We now have a new usage insn for original regno.  */\n@@ -4620,7 +4559,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t  lra_assert (DEBUG_INSN_P (usage_insn));\n \t  next_usage_insns = XEXP (next_usage_insns, 1);\n \t}\n-      substitute_pseudo (&usage_insn, original_regno, new_reg);\n+      lra_substitute_pseudo (&usage_insn, original_regno, new_reg);\n       lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));\n       if (lra_dump_file != NULL)\n \t{\n@@ -4884,7 +4823,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n       usage_insn = XEXP (next_usage_insns, 0);\n       lra_assert (DEBUG_INSN_P (usage_insn));\n       next_usage_insns = XEXP (next_usage_insns, 1);\n-      substitute_pseudo (&usage_insn, original_regno, new_reg);\n+      lra_substitute_pseudo (&usage_insn, original_regno, new_reg);\n       lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));\n       if (lra_dump_file != NULL)\n \t{\n@@ -5803,7 +5742,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t\t    {\n \t\t      if (change_p && bitmap_bit_p (remove_pseudos, regno))\n \t\t\t{\n-\t\t\t  substitute_pseudo_within_insn (\n+\t\t\t  lra_substitute_pseudo_within_insn (\n \t\t\t    curr_insn, regno, regno_reg_rtx[restore_regno]);\n \t\t\t  restored_regs_p = true;\n \t\t\t}\n@@ -5927,7 +5866,7 @@ undo_optional_reloads (void)\n \t\t we remove the inheritance pseudo and the optional\n \t\t reload.  */\n \t    }\n-\t  substitute_pseudo_within_insn (\n+\t  lra_substitute_pseudo_within_insn (\n \t    insn, regno,\n \t    regno_reg_rtx[lra_reg_info[regno].restore_regno]);\n \t  lra_update_insn_regno_info (insn);"}, {"sha": "5355ebfa4ec9bf3ecea57d52cdd9fbfa8b2a7b85", "filename": "gcc/lra-int.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=8160cd3ee4a5840db17416092f2d808187b7e872", "patch": "@@ -284,6 +284,7 @@ extern lra_insn_recog_data_t *lra_insn_recog_data;\n \n extern int lra_curr_reload_num;\n \n+extern void lra_dump_bitmap_with_title (const char *, bitmap, int);\n extern void lra_push_insn (rtx_insn *);\n extern void lra_push_insn_by_uid (unsigned int);\n extern void lra_push_insn_and_update_insn_regno_info (rtx_insn *);\n@@ -303,6 +304,9 @@ extern void lra_update_dups (lra_insn_recog_data_t, signed char *);\n extern void lra_process_new_insns (rtx_insn *, rtx_insn *, rtx_insn *,\n \t\t\t\t   const char *);\n \n+extern bool lra_substitute_pseudo (rtx *, int, rtx);\n+extern bool lra_substitute_pseudo_within_insn (rtx_insn *, int, rtx);\n+\n extern lra_insn_recog_data_t lra_set_insn_recog_data (rtx_insn *);\n extern lra_insn_recog_data_t lra_update_insn_recog_data (rtx_insn *);\n extern void lra_set_used_insn_alternative (rtx_insn *, int);"}, {"sha": "0e97cd814299df160ad7d1ba31ffd6b2e5440cce", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 290, "deletions": 29, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=8160cd3ee4a5840db17416092f2d808187b7e872", "patch": "@@ -316,12 +316,15 @@ mark_pseudo_dead (int regno, int point)\n     }\n }\n \n-/* Mark register REGNO (pseudo or hard register) in MODE as live\n-   at program point POINT.\n-   Return TRUE if the liveness tracking sets were modified,\n-   or FALSE if nothing changed.  */\n+/* The corresponding bitmaps of BB currently being processed.  */\n+static bitmap bb_killed_pseudos, bb_gen_pseudos;\n+\n+/* Mark register REGNO (pseudo or hard register) in MODE as live at\n+   program point POINT.  Update BB_GEN_PSEUDOS if LOCAL_SETS_P.\n+   Return TRUE if the liveness tracking sets were modified, or FALSE\n+   if nothing changed.  */\n static bool\n-mark_regno_live (int regno, machine_mode mode, int point)\n+mark_regno_live (int regno, machine_mode mode, int point, bool local_sets_p)\n {\n   int last;\n   bool changed = false;\n@@ -333,20 +336,26 @@ mark_regno_live (int regno, machine_mode mode, int point)\n \t   regno++)\n \tmake_hard_regno_born (regno);\n     }\n-  else if (! sparseset_bit_p (pseudos_live, regno))\n+  else\n     {\n-      mark_pseudo_live (regno, point);\n-      changed = true;\n+      if (! sparseset_bit_p (pseudos_live, regno))\n+\t{\n+\t  mark_pseudo_live (regno, point);\n+\t  changed = true;\n+\t}\n+      if (local_sets_p)\n+\tbitmap_set_bit (bb_gen_pseudos, regno);\n     }\n   return changed;\n }\n \n \n-/* Mark register REGNO in MODE as dead at program point POINT.\n-   Return TRUE if the liveness tracking sets were modified,\n-   or FALSE if nothing changed.  */\n+/* Mark register REGNO in MODE as dead at program point POINT.  Update\n+   BB_GEN_PSEUDOS and BB_KILLED_PSEUDOS if LOCAL_SETS_P.  Return TRUE\n+   if the liveness tracking sets were modified, or FALSE if nothing\n+   changed.  */\n static bool\n-mark_regno_dead (int regno, machine_mode mode, int point)\n+mark_regno_dead (int regno, machine_mode mode, int point, bool local_sets_p)\n {\n   int last;\n   bool changed = false;\n@@ -358,14 +367,154 @@ mark_regno_dead (int regno, machine_mode mode, int point)\n \t   regno++)\n \tmake_hard_regno_dead (regno);\n     }\n-  else if (sparseset_bit_p (pseudos_live, regno))\n+  else\n     {\n-      mark_pseudo_dead (regno, point);\n-      changed = true;\n+      if (sparseset_bit_p (pseudos_live, regno))\n+\t{\n+\t  mark_pseudo_dead (regno, point);\n+\t  changed = true;\n+\t}\n+      if (local_sets_p)\n+\t{\n+\t  bitmap_clear_bit (bb_gen_pseudos, regno);\n+\t  bitmap_set_bit (bb_killed_pseudos, regno);\n+\t}\n     }\n   return changed;\n }\n \n+\f\n+\n+/* This page contains code for making global live analysis of pseudos.\n+   The code works only when pseudo live info is changed on a BB\n+   border.  That might be a consequence of some global transformations\n+   in LRA, e.g. PIC pseudo reuse or rematerialization.  */\n+\n+/* Structure describing local BB data used for pseudo\n+   live-analysis.  */\n+struct bb_data\n+{\n+  /* Basic block about which the below data are.  */\n+  basic_block bb;\n+  bitmap_head killed_pseudos; /* pseudos killed in the BB.  */\n+  bitmap_head gen_pseudos; /* pseudos generated in the BB.  */\n+};\n+\n+/* Array for all BB data.  Indexed by the corresponding BB index.  */\n+typedef struct bb_data *bb_data_t;\n+\n+/* All basic block data are referred through the following array.  */\n+static bb_data_t bb_data;\n+\n+/* Two small functions for access to the bb data.  */\n+static inline bb_data_t\n+get_bb_data (basic_block bb)\n+{\n+  return &bb_data[(bb)->index];\n+}\n+\n+static inline bb_data_t\n+get_bb_data_by_index (int index)\n+{\n+  return &bb_data[index];\n+}\n+\n+/* Bitmap with all hard regs.  */\n+static bitmap_head all_hard_regs_bitmap;\n+\n+/* Bitmap used for holding intermediate bitmap operation results.  */\n+static bitmap_head temp_bitmap;\n+\n+/* The transfer function used by the DF equation solver to propagate\n+   live info through block with BB_INDEX according to the following\n+   equation:\n+\n+     bb.livein = (bb.liveout - bb.kill) OR bb.gen\n+*/\n+static bool\n+live_trans_fun (int bb_index)\n+{\n+  basic_block bb = get_bb_data_by_index (bb_index)->bb;\n+  bitmap bb_liveout = df_get_live_out (bb);\n+  bitmap bb_livein = df_get_live_in (bb);\n+  bb_data_t bb_info = get_bb_data (bb);\n+\n+  bitmap_and_compl (&temp_bitmap, bb_liveout, &all_hard_regs_bitmap);\n+  return bitmap_ior_and_compl (bb_livein, &bb_info->gen_pseudos,\n+\t\t\t       &temp_bitmap, &bb_info->killed_pseudos);\n+}\n+\n+/* The confluence function used by the DF equation solver to set up\n+   live info for a block BB without predecessor.  */\n+static void\n+live_con_fun_0 (basic_block bb)\n+{\n+  bitmap_and_into (df_get_live_out (bb), &all_hard_regs_bitmap);\n+}\n+\n+/* The confluence function used by the DF equation solver to propagate\n+   live info from successor to predecessor on edge E according to the\n+   following equation:\n+\n+      bb.liveout = 0 for entry block | OR (livein of successors)\n+ */\n+static bool\n+live_con_fun_n (edge e)\n+{\n+  basic_block bb = e->src;\n+  basic_block dest = e->dest;\n+  bitmap bb_liveout = df_get_live_out (bb);\n+  bitmap dest_livein = df_get_live_in (dest);\n+  \n+  return bitmap_ior_and_compl_into (bb_liveout,\n+\t\t\t\t    dest_livein, &all_hard_regs_bitmap);\n+}\n+\n+/* Indexes of all function blocks.  */\n+static bitmap_head all_blocks;\n+\n+/* Allocate and initialize data needed for global pseudo live\n+   analysis.  */\n+static void\n+initiate_live_solver (void)\n+{\n+  bitmap_initialize (&temp_bitmap, &reg_obstack);\n+  bitmap_initialize (&all_hard_regs_bitmap, &reg_obstack);\n+  bitmap_set_range (&all_hard_regs_bitmap, 0, FIRST_PSEUDO_REGISTER);\n+  bb_data = XNEWVEC (struct bb_data, last_basic_block_for_fn (cfun));\n+  bitmap_initialize (&all_blocks, &reg_obstack);\n+\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      bb_data_t bb_info = get_bb_data (bb);\n+      bb_info->bb = bb;\n+      bitmap_initialize (&bb_info->killed_pseudos, &reg_obstack);\n+      bitmap_initialize (&bb_info->gen_pseudos, &reg_obstack);\n+      bitmap_set_bit (&all_blocks, bb->index);\n+    }\n+}\n+\n+/* Free all data needed for global pseudo live analysis.  */\n+static void\n+finish_live_solver (void)\n+{\n+  basic_block bb;\n+\n+  bitmap_clear (&all_blocks);\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      bb_data_t bb_info = get_bb_data (bb);\n+      bitmap_clear (&bb_info->killed_pseudos);\n+      bitmap_clear (&bb_info->gen_pseudos);\n+    }\n+  free (bb_data);\n+  bitmap_clear (&all_hard_regs_bitmap);\n+  bitmap_clear (&temp_bitmap);\n+}\n+\n+\f\n+\n /* Insn currently scanned.  */\n static rtx_insn *curr_insn;\n /* The insn data.  */\n@@ -492,15 +641,18 @@ check_pseudos_live_through_calls (int regno)\n    pseudo hard register conflicts, and insn notes.  We do it on\n    backward scan of BB insns.  CURR_POINT is the program point where\n    BB ends.  The function updates this counter and returns in\n-   CURR_POINT the program point where BB starts.  */\n-static void\n+   CURR_POINT the program point where BB starts.  The function also\n+   can delete the dead insns.  It returns true if pseudo live info was\n+   changed at the BB start.  */\n+static bool\n process_bb_lives (basic_block bb, int &curr_point)\n {\n   int i, regno, freq;\n   unsigned int j;\n   bitmap_iterator bi;\n   bitmap reg_live_out;\n   unsigned int px;\n+  rtx_insn *next;\n   rtx link, *link_loc;\n   bool need_curr_point_incr;\n \n@@ -514,6 +666,11 @@ process_bb_lives (basic_block bb, int &curr_point)\n   EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n     mark_pseudo_live (j, curr_point);\n \n+  bb_gen_pseudos = &get_bb_data (bb)->gen_pseudos;\n+  bb_killed_pseudos = &get_bb_data (bb)->killed_pseudos;\n+  bitmap_clear (bb_gen_pseudos);\n+  bitmap_clear (bb_killed_pseudos);\n+\n   freq = REG_FREQ_FROM_BB (bb);\n \n   if (lra_dump_file != NULL)\n@@ -528,7 +685,7 @@ process_bb_lives (basic_block bb, int &curr_point)\n      FOO will remain live until the beginning of the block.  Likewise\n      if FOO is not set at all.\tThis is unnecessarily pessimistic, but\n      it probably doesn't matter much in practice.  */\n-  FOR_BB_INSNS_REVERSE (bb, curr_insn)\n+  FOR_BB_INSNS_REVERSE_SAFE (bb, curr_insn, next)\n     {\n       bool call_p;\n       int dst_regno, src_regno;\n@@ -544,6 +701,51 @@ process_bb_lives (basic_block bb, int &curr_point)\n \tfprintf (lra_dump_file, \"   Insn %u: point = %d\\n\",\n \t\t INSN_UID (curr_insn), curr_point);\n \n+      set = single_set (curr_insn);\n+\n+      if (set != NULL_RTX\n+\t  && REG_P (SET_DEST (set)) && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  bool dead_insn_p = true;\n+\n+\t  for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n+\t    if (reg->type != OP_IN && sparseset_bit_p (pseudos_live, reg->regno))\n+\t      {\n+\t\tdead_insn_p = false;\n+\t\tbreak;\n+\t      }\n+\t  for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n+\t    if (reg->type != OP_IN)\n+\t      {\n+\t\tdead_insn_p = false;\n+\t\tbreak;\n+\t      }\n+\t  if (dead_insn_p && ! volatile_refs_p (PATTERN (curr_insn)))\n+\t    {\n+\t      dst_regno = REGNO (SET_DEST (set));\n+\t      if (lra_dump_file != NULL)\n+\t\tfprintf (lra_dump_file, \"   Deleting dead insn %u\\n\",\n+\t\t\t INSN_UID (curr_insn));\n+\t      lra_set_insn_deleted (curr_insn);\n+\t      if (lra_reg_info[dst_regno].nrefs == 0)\n+\t\t{\n+\t\t  /* There might be some debug insns with the pseudo.  */\n+\t\t  unsigned int uid;\n+\t\t  rtx_insn *insn;\n+\n+\t\t  EXECUTE_IF_SET_IN_BITMAP\n+\t\t    (&lra_reg_info[dst_regno].insn_bitmap, 0, uid, bi)\n+\t\t    {\n+\t\t      insn = lra_insn_recog_data[uid]->insn;\n+\t\t      lra_substitute_pseudo_within_insn (insn, dst_regno,\n+\t\t\t\t\t\t\t SET_SRC (set));\n+\t\t      lra_update_insn_regno_info (insn);\n+\t\t    }\n+\t\t}\n+\t      continue;\n+\t    }\n+\t}\n+\n       /* Update max ref width and hard reg usage.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \tif (reg->regno >= FIRST_PSEUDO_REGISTER\n@@ -555,7 +757,7 @@ process_bb_lives (basic_block bb, int &curr_point)\n \n       call_p = CALL_P (curr_insn);\n       if (complete_info_p\n-\t  && (set = single_set (curr_insn)) != NULL_RTX\n+\t  && set != NULL_RTX\n \t  && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set))\n \t  /* Check that source regno does not conflict with\n \t     destination regno to exclude most impossible\n@@ -612,7 +814,7 @@ process_bb_lives (basic_block bb, int &curr_point)\n \t  {\n \t    need_curr_point_incr |= mark_regno_live (reg->regno,\n \t\t\t\t\t\t     reg->biggest_mode,\n-\t\t\t\t\t\t     curr_point);\n+\t\t\t\t\t\t     curr_point, true);\n \t    check_pseudos_live_through_calls (reg->regno);\n \t  }\n \n@@ -629,7 +831,7 @@ process_bb_lives (basic_block bb, int &curr_point)\n \tif (reg->type == OP_OUT && ! reg->early_clobber && ! reg->subreg_p)\n \t  need_curr_point_incr |= mark_regno_dead (reg->regno,\n \t\t\t\t\t\t   reg->biggest_mode,\n-\t\t\t\t\t\t   curr_point);\n+\t\t\t\t\t\t   curr_point, true);\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && ! reg->early_clobber && ! reg->subreg_p)\n@@ -671,7 +873,7 @@ process_bb_lives (basic_block bb, int &curr_point)\n \t  {\n \t    need_curr_point_incr |= mark_regno_live (reg->regno,\n \t\t\t\t\t\t     reg->biggest_mode,\n-\t\t\t\t\t\t     curr_point);\n+\t\t\t\t\t\t     curr_point, true);\n \t    check_pseudos_live_through_calls (reg->regno);\n \t  }\n \n@@ -691,7 +893,7 @@ process_bb_lives (basic_block bb, int &curr_point)\n \tif (reg->type == OP_OUT && reg->early_clobber && ! reg->subreg_p)\n \t  need_curr_point_incr |= mark_regno_dead (reg->regno,\n \t\t\t\t\t\t   reg->biggest_mode,\n-\t\t\t\t\t\t   curr_point);\n+\t\t\t\t\t\t   curr_point, true);\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && reg->early_clobber && ! reg->subreg_p)\n@@ -764,6 +966,20 @@ process_bb_lives (basic_block bb, int &curr_point)\n \t    make_hard_regno_born (px);\n     }\n \n+  /* Check if bb border live info was changed.  */\n+  unsigned int live_pseudos_num = 0;\n+  bool live_change_p = false;\n+  EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb), FIRST_PSEUDO_REGISTER, j, bi)\n+    {\n+      live_pseudos_num++;\n+      if (! sparseset_bit_p (pseudos_live, j))\n+\t{\n+\t  live_change_p = TRUE;\n+\t  break;\n+\t}\n+    }\n+  live_change_p = live_change_p || sparseset_cardinality (pseudos_live) != live_pseudos_num;\n+\n   /* See if we'll need an increment at the end of this basic block.\n      An increment is needed if the PSEUDOS_LIVE set is not empty,\n      to make sure the finish points are set up correctly.  */\n@@ -779,9 +995,11 @@ process_bb_lives (basic_block bb, int &curr_point)\n       if (sparseset_bit_p (pseudos_live_through_calls, j))\n \tcheck_pseudos_live_through_calls (j);\n     }\n-\n+  \n   if (need_curr_point_incr)\n     next_program_point (curr_point, freq);\n+\n+  return live_change_p;\n }\n \n /* Compress pseudo live ranges by removing program points where\n@@ -947,19 +1165,22 @@ compress_live_ranges (void)\n     }\n }\n \n+\f\n+\n /* The number of the current live range pass.  */\n int lra_live_range_iter;\n \n /* The main entry function creates live ranges only for memory pseudos\n-   (or for all ones if ALL_P), set up CONFLICT_HARD_REGS for\n-   the pseudos.\t */\n+   (or for all ones if ALL_P), set up CONFLICT_HARD_REGS for the\n+   pseudos.  It also does global live analysis only for pseudos and\n+   only if the pseudo live info was changed on a BB border.  */\n void\n lra_create_live_ranges (bool all_p)\n {\n   basic_block bb;\n   int i, hard_regno, max_regno = max_reg_num ();\n   int curr_point;\n-  bool have_referenced_pseudos = false;\n+  bool bb_live_change_p, have_referenced_pseudos = false;\n \n   timevar_push (TV_LRA_CREATE_LIVE_RANGES);\n \n@@ -1023,17 +1244,55 @@ lra_create_live_ranges (bool all_p)\n   int *post_order_rev_cfg = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   int n_blocks_inverted = inverted_post_order_compute (post_order_rev_cfg);\n   lra_assert (n_blocks_inverted == n_basic_blocks_for_fn (cfun));\n+  bb_live_change_p = false;\n   for (i = n_blocks_inverted - 1; i >= 0; --i)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, post_order_rev_cfg[i]);\n       if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb\n \t  == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n-      process_bb_lives (bb, curr_point);\n+      if (process_bb_lives (bb, curr_point))\n+\tbb_live_change_p = true;\n+    }\n+  if (bb_live_change_p)\n+    {\n+      /* We need to clear pseudo live info as some pseudos can\n+\t disappear, e.g. pseudos with used equivalences.  */\n+      FOR_EACH_BB_FN (bb, cfun)\n+\t{\n+\t  bitmap_clear_range (df_get_live_in (bb), FIRST_PSEUDO_REGISTER,\n+\t\t\t      max_regno - FIRST_PSEUDO_REGISTER);\n+\t  bitmap_clear_range (df_get_live_out (bb), FIRST_PSEUDO_REGISTER,\n+\t\t\t      max_regno - FIRST_PSEUDO_REGISTER);\n+\t}\n+      /* As we did not change CFG since LRA start we can use\n+\t DF-infrastructure solver to solve live data flow problem.  */\n+      df_simple_dataflow\n+\t(DF_BACKWARD, NULL, live_con_fun_0, live_con_fun_n,\n+\t live_trans_fun, &all_blocks,\n+\t df_get_postorder (DF_BACKWARD), df_get_n_blocks (DF_BACKWARD));\n+      if (lra_dump_file != NULL)\n+\t{\n+\t  fprintf (lra_dump_file, \"Global pseudo live data have be updated:\\n\");\n+\t  basic_block bb;\n+\t  FOR_EACH_BB_FN (bb, cfun)\n+\t    {\n+\t      bb_data_t bb_info = get_bb_data (bb);\n+\t      bitmap bb_livein = df_get_live_in (bb);\n+\t      bitmap bb_liveout = df_get_live_out (bb);\n+\n+\t      fprintf (lra_dump_file, \"\\nBB %d:\\n\", bb->index);\n+\t      lra_dump_bitmap_with_title (\"  gen:\",\n+\t\t\t\t\t  &bb_info->gen_pseudos, bb->index);\n+\t      lra_dump_bitmap_with_title (\"  killed:\",\n+\t\t\t\t\t  &bb_info->killed_pseudos, bb->index);\n+\t      lra_dump_bitmap_with_title (\"  livein:\", bb_livein, bb->index);\n+\t      lra_dump_bitmap_with_title (\"  liveout:\", bb_liveout, bb->index);\n+\t    }\n+\t}\n     }\n   free (post_order_rev_cfg);\n   lra_live_max_point = curr_point;\n-  gcc_checking_assert (lra_live_max_point > 0);\n   if (lra_dump_file != NULL)\n     print_live_ranges (lra_dump_file);\n   /* Clean up.\t*/\n@@ -1065,11 +1324,13 @@ lra_live_ranges_init (void)\n {\n   live_range_pool = create_alloc_pool (\"live ranges\",\n \t\t\t\t       sizeof (struct lra_live_range), 100);\n+  initiate_live_solver ();\n }\n \n /* Finish live ranges data once per function.  */\n void\n lra_live_ranges_finish (void)\n {\n+  finish_live_solver ();\n   free_alloc_pool (live_range_pool);\n }"}, {"sha": "3ae47e86ba641fe68245ded4b5dbb5fdcf56787e", "filename": "gcc/lra.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8160cd3ee4a5840db17416092f2d808187b7e872/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=8160cd3ee4a5840db17416092f2d808187b7e872", "patch": "@@ -129,6 +129,33 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"lra-int.h\"\n #include \"df.h\"\n \n+/* Dump bitmap SET with TITLE and BB INDEX.  */\n+void\n+lra_dump_bitmap_with_title (const char *title, bitmap set, int index)\n+{\n+  unsigned int i;\n+  int count;\n+  bitmap_iterator bi;\n+  static const int max_nums_on_line = 10;\n+\n+  if (bitmap_empty_p (set))\n+    return;\n+  fprintf (lra_dump_file, \"  %s %d:\", title, index);\n+  fprintf (lra_dump_file, \"\\n\");\n+  count = max_nums_on_line + 1;\n+  EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n+    {\n+      if (count > max_nums_on_line)\n+\t{\n+\t  fprintf (lra_dump_file, \"\\n    \");\n+\t  count = 0;\n+\t}\n+      fprintf (lra_dump_file, \" %4u\", i);\n+      count++;\n+    }\n+  fprintf (lra_dump_file, \"\\n\");\n+}\n+\n /* Hard registers currently not available for allocation.  It can\n    changed after some hard  registers become not eliminable.  */\n HARD_REG_SET lra_no_alloc_regs;\n@@ -1753,6 +1780,68 @@ lra_process_new_insns (rtx_insn *insn, rtx_insn *before, rtx_insn *after,\n \n \f\n \n+/* Replace all references to register OLD_REGNO in *LOC with pseudo\n+   register NEW_REG.  Return true if any change was made.  */\n+bool\n+lra_substitute_pseudo (rtx *loc, int old_regno, rtx new_reg)\n+{\n+  rtx x = *loc;\n+  bool result = false;\n+  enum rtx_code code;\n+  const char *fmt;\n+  int i, j;\n+\n+  if (x == NULL_RTX)\n+    return false;\n+\n+  code = GET_CODE (x);\n+  if (code == REG && (int) REGNO (x) == old_regno)\n+    {\n+      machine_mode mode = GET_MODE (*loc);\n+      machine_mode inner_mode = GET_MODE (new_reg);\n+\n+      if (mode != inner_mode)\n+\t{\n+\t  if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (inner_mode)\n+\t      || ! SCALAR_INT_MODE_P (inner_mode))\n+\t    new_reg = gen_rtx_SUBREG (mode, new_reg, 0);\n+\t  else\n+\t    new_reg = gen_lowpart_SUBREG (mode, new_reg);\n+\t}\n+      *loc = new_reg;\n+      return true;\n+    }\n+\n+  /* Scan all the operand sub-expressions.  */\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (lra_substitute_pseudo (&XEXP (x, i), old_regno, new_reg))\n+\t    result = true;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (lra_substitute_pseudo (&XVECEXP (x, i, j), old_regno, new_reg))\n+\t      result = true;\n+\t}\n+    }\n+  return result;\n+}\n+\n+/* Call lra_substitute_pseudo within an insn.  This won't update the insn ptr,\n+   just the contents of the insn.  */\n+bool\n+lra_substitute_pseudo_within_insn (rtx_insn *insn, int old_regno, rtx new_reg)\n+{\n+  rtx loc = insn;\n+  return lra_substitute_pseudo (&loc, old_regno, new_reg);\n+}\n+\n+\f\n+\n /* This page contains code dealing with scratches (changing them onto\n    pseudos and restoring them from the pseudos).\n "}]}