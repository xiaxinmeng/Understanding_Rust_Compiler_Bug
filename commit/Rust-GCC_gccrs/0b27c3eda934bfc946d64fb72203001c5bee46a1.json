{"sha": "0b27c3eda934bfc946d64fb72203001c5bee46a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIyN2MzZWRhOTM0YmZjOTQ2ZDY0ZmI3MjIwMzAwMWM1YmVlNDZhMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-07-10T07:12:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-07-10T07:12:37Z"}, "message": "re PR c++/86443 (ICEs on #pragma omp distribute parallel for with class iterators)\n\n\tPR c++/86443\n\t* gimplify.c (find_combined_omp_for): Add DATA argument, in addition\n\tto finding the inner OMP_FOR/OMP_SIMD stmt find non-trivial wrappers,\n\tBLOCKs with BLOCK_VARs, OMP_PARALLEL in between, OMP_FOR in between.\n\t(gimplify_omp_for): For composite loops, move outer\n\tOMP_{DISTRIBUTE,TASKLOOP,FOR,PARALLEL} right around innermost\n\tOMP_FOR/OMP_SIMD if there are any non-trivial wrappers.  For class\n\titerators add any needed clauses.  Allow OMP_FOR_ORIG_DECLS to contain\n\tTREE_LIST for both the original class iterator and the \"last\" helper\n\tvar.  Gimplify OMP_FOR_PRE_BODY before the outermost composite\n\tloop, remember has_decl_expr from outer composite loops for the\n\tinnermost OMP_SIMD in TREE_PRIVATE bit on OMP_FOR_INIT.\ngcc/c-family/\n\t* c-omp.c (c_omp_check_loop_iv_r, c_omp_check_loop_iv): Allow declv\n\tto contain TREE_LIST for both the original class iterator and the\n\t\"last\" helper var.\ngcc/cp/\n\t* semantics.c (handle_omp_for_class_iterator): Remove lastp argument,\n\tinstead of setting *lastp turn orig_declv elt into a TREE_LIST.\n\t(finish_omp_for): Adjust handle_omp_for_class_iterator caller.\n\t* pt.c (tsubst_omp_for_iterator): Allow OMP_FOR_ORIG_DECLS to contain\n\tTREE_LIST for both the original class iterator and the \"last\" helper\n\tvar.\nlibgomp/\n\t* testsuite/libgomp.c++/for-15.C: New test.\n\nFrom-SVN: r262534", "tree": {"sha": "f53906c4b6e36f6adb263e98f301f5e3fd465d11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f53906c4b6e36f6adb263e98f301f5e3fd465d11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b27c3eda934bfc946d64fb72203001c5bee46a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b27c3eda934bfc946d64fb72203001c5bee46a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b27c3eda934bfc946d64fb72203001c5bee46a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b27c3eda934bfc946d64fb72203001c5bee46a1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0cb9a9da0a7e257297deb25193cc9f113ee672a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cb9a9da0a7e257297deb25193cc9f113ee672a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0cb9a9da0a7e257297deb25193cc9f113ee672a"}], "stats": {"total": 477, "additions": 447, "deletions": 30}, "files": [{"sha": "3230cf3aa82d4077ca4fcc6e1934865e5c2bacb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -1,3 +1,18 @@\n+2018-07-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/86443\n+\t* gimplify.c (find_combined_omp_for): Add DATA argument, in addition\n+\tto finding the inner OMP_FOR/OMP_SIMD stmt find non-trivial wrappers,\n+\tBLOCKs with BLOCK_VARs, OMP_PARALLEL in between, OMP_FOR in between.\n+\t(gimplify_omp_for): For composite loops, move outer\n+\tOMP_{DISTRIBUTE,TASKLOOP,FOR,PARALLEL} right around innermost\n+\tOMP_FOR/OMP_SIMD if there are any non-trivial wrappers.  For class\n+\titerators add any needed clauses.  Allow OMP_FOR_ORIG_DECLS to contain\n+\tTREE_LIST for both the original class iterator and the \"last\" helper\n+\tvar.  Gimplify OMP_FOR_PRE_BODY before the outermost composite\n+\tloop, remember has_decl_expr from outer composite loops for the\n+\tinnermost OMP_SIMD in TREE_PRIVATE bit on OMP_FOR_INIT.\n+\n 2018-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/77357"}, {"sha": "a459f0613265c20435a3b9fa5a907b16d27d51d1", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -1,3 +1,10 @@\n+2018-07-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/86443\n+\t* c-omp.c (c_omp_check_loop_iv_r, c_omp_check_loop_iv): Allow declv\n+\tto contain TREE_LIST for both the original class iterator and the\n+\t\"last\" helper var.\n+\n 2018-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.c (to_ada_name): Remove index parameter."}, {"sha": "89849379ca7691e91d9ac1ac8cfa2a4672bbea76", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -827,7 +827,9 @@ c_omp_check_loop_iv_r (tree *tp, int *walk_subtrees, void *data)\n     {\n       int i;\n       for (i = 0; i < TREE_VEC_LENGTH (d->declv); i++)\n-\tif (*tp == TREE_VEC_ELT (d->declv, i))\n+\tif (*tp == TREE_VEC_ELT (d->declv, i)\n+\t    || (TREE_CODE (TREE_VEC_ELT (d->declv, i)) == TREE_LIST\n+\t\t&& *tp == TREE_PURPOSE (TREE_VEC_ELT (d->declv, i))))\n \t  {\n \t    location_t loc = d->expr_loc;\n \t    if (loc == UNKNOWN_LOCATION)\n@@ -894,7 +896,9 @@ c_omp_check_loop_iv (tree stmt, tree declv, walk_tree_lh lh)\n \t expression then involves the subtraction and always refers\n \t to the original value.  The C++ FE needs to warn on those\n \t earlier.  */\n-      if (decl == TREE_VEC_ELT (declv, i))\n+      if (decl == TREE_VEC_ELT (declv, i)\n+\t  || (TREE_CODE (TREE_VEC_ELT (declv, i)) == TREE_LIST\n+\t      && decl == TREE_PURPOSE (TREE_VEC_ELT (declv, i))))\n \t{\n \t  data.expr_loc = EXPR_LOCATION (cond);\n \t  data.kind = 1;"}, {"sha": "86d4a349905975de544b1cfbe52bcb9045c48aa8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -1,3 +1,13 @@\n+2018-07-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/86443\n+\t* semantics.c (handle_omp_for_class_iterator): Remove lastp argument,\n+\tinstead of setting *lastp turn orig_declv elt into a TREE_LIST.\n+\t(finish_omp_for): Adjust handle_omp_for_class_iterator caller.\n+\t* pt.c (tsubst_omp_for_iterator): Allow OMP_FOR_ORIG_DECLS to contain\n+\tTREE_LIST for both the original class iterator and the \"last\" helper\n+\tvar.\n+\n 2018-07-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* decl.c (grokdeclarator): Use rich_location::add_range in three"}, {"sha": "eae9e14d37d0bf302d60142025d9d01dbda3c7bd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -16267,7 +16267,12 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree orig_declv,\n   if (orig_declv && OMP_FOR_ORIG_DECLS (t))\n     {\n       tree o = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (t), i);\n-      TREE_VEC_ELT (orig_declv, i) = RECUR (o);\n+      if (TREE_CODE (o) == TREE_LIST)\n+\tTREE_VEC_ELT (orig_declv, i)\n+\t  = tree_cons (RECUR (TREE_PURPOSE (o)),\n+\t\t       RECUR (TREE_VALUE (o)), NULL_TREE);\n+      else\n+\tTREE_VEC_ELT (orig_declv, i) = RECUR (o);\n     }\n \n   decl = TREE_OPERAND (init, 0);"}, {"sha": "ef73d07161fb3ea5e69e91aefb2f25d24f14442f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -7679,7 +7679,7 @@ static bool\n handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t\t\t       tree declv, tree orig_declv, tree initv,\n \t\t\t       tree condv, tree incrv, tree *body,\n-\t\t\t       tree *pre_body, tree &clauses, tree *lastp,\n+\t\t\t       tree *pre_body, tree &clauses,\n \t\t\t       int collapse, int ordered)\n {\n   tree diff, iter_init, iter_incr = NULL, last;\n@@ -7983,7 +7983,8 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n   TREE_VEC_ELT (initv, i) = init;\n   TREE_VEC_ELT (condv, i) = cond;\n   TREE_VEC_ELT (incrv, i) = incr;\n-  *lastp = last;\n+  TREE_VEC_ELT (orig_declv, i)\n+    = tree_cons (TREE_VEC_ELT (orig_declv, i), last, NULL_TREE);\n \n   return false;\n }\n@@ -8002,7 +8003,6 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n {\n   tree omp_for = NULL, orig_incr = NULL;\n   tree decl = NULL, init, cond, incr;\n-  tree last = NULL_TREE;\n   location_t elocus;\n   int i;\n   int collapse = 1;\n@@ -8169,7 +8169,7 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t    }\n \t  if (handle_omp_for_class_iterator (i, locus, code, declv, orig_declv,\n \t\t\t\t\t     initv, condv, incrv, &body,\n-\t\t\t\t\t     &pre_body, clauses, &last,\n+\t\t\t\t\t     &pre_body, clauses,\n \t\t\t\t\t     collapse, ordered))\n \t    return NULL;\n \t  continue;"}, {"sha": "6b76d17dbaf6d32fe07cdef537377fa0e0cc8d0a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 162, "deletions": 23, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -9532,24 +9532,53 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n }\n \n /* Helper function of gimplify_omp_for, find OMP_FOR resp. OMP_SIMD\n-   with non-NULL OMP_FOR_INIT.  */\n+   with non-NULL OMP_FOR_INIT.  Also, fill in pdata array,\n+   pdata[0] non-NULL if there is anything non-trivial in between, pdata[1]\n+   is address of OMP_PARALLEL in between if any, pdata[2] is address of\n+   OMP_FOR in between if any and pdata[3] is address of the inner\n+   OMP_FOR/OMP_SIMD.  */\n \n static tree\n-find_combined_omp_for (tree *tp, int *walk_subtrees, void *)\n+find_combined_omp_for (tree *tp, int *walk_subtrees, void *data)\n {\n+  tree **pdata = (tree **) data;\n   *walk_subtrees = 0;\n   switch (TREE_CODE (*tp))\n     {\n     case OMP_FOR:\n+      if (OMP_FOR_INIT (*tp) != NULL_TREE)\n+\t{\n+\t  pdata[3] = tp;\n+\t  return *tp;\n+\t}\n+      pdata[2] = tp;\n       *walk_subtrees = 1;\n-      /* FALLTHRU */\n+      break;\n     case OMP_SIMD:\n       if (OMP_FOR_INIT (*tp) != NULL_TREE)\n-\treturn *tp;\n+\t{\n+\t  pdata[3] = tp;\n+\t  return *tp;\n+\t}\n       break;\n     case BIND_EXPR:\n+      if (BIND_EXPR_VARS (*tp)\n+\t  || (BIND_EXPR_BLOCK (*tp)\n+\t      && BLOCK_VARS (BIND_EXPR_BLOCK (*tp))))\n+\tpdata[0] = tp;\n+      *walk_subtrees = 1;\n+      break;\n     case STATEMENT_LIST:\n+      if (!tsi_one_before_end_p (tsi_start (*tp)))\n+\tpdata[0] = tp;\n+      *walk_subtrees = 1;\n+      break;\n+    case TRY_FINALLY_EXPR:\n+      pdata[0] = tp;\n+      *walk_subtrees = 1;\n+      break;\n     case OMP_PARALLEL:\n+      pdata[1] = tp;\n       *walk_subtrees = 1;\n       break;\n     default:\n@@ -9574,6 +9603,115 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   orig_for_stmt = for_stmt = *expr_p;\n \n+  if (OMP_FOR_INIT (for_stmt) == NULL_TREE)\n+    {\n+      tree *data[4] = { NULL, NULL, NULL, NULL };\n+      gcc_assert (TREE_CODE (for_stmt) != OACC_LOOP);\n+      inner_for_stmt = walk_tree (&OMP_FOR_BODY (for_stmt),\n+\t\t\t\t  find_combined_omp_for, data, NULL);\n+      if (inner_for_stmt == NULL_TREE)\n+\t{\n+\t  gcc_assert (seen_error ());\n+\t  *expr_p = NULL_TREE;\n+\t  return GS_ERROR;\n+\t}\n+      if (data[2] && OMP_FOR_PRE_BODY (*data[2]))\n+\t{\n+\t  append_to_statement_list_force (OMP_FOR_PRE_BODY (*data[2]),\n+\t\t\t\t\t  &OMP_FOR_PRE_BODY (for_stmt));\n+\t  OMP_FOR_PRE_BODY (*data[2]) = NULL_TREE;\n+\t}\n+      if (OMP_FOR_PRE_BODY (inner_for_stmt))\n+\t{\n+\t  append_to_statement_list_force (OMP_FOR_PRE_BODY (inner_for_stmt),\n+\t\t\t\t\t  &OMP_FOR_PRE_BODY (for_stmt));\n+\t  OMP_FOR_PRE_BODY (inner_for_stmt) = NULL_TREE;\n+\t}\n+\n+      if (data[0])\n+\t{\n+\t  /* We have some statements or variable declarations in between\n+\t     the composite construct directives.  Move them around the\n+\t     inner_for_stmt.  */\n+\t  data[0] = expr_p;\n+\t  for (i = 0; i < 3; i++)\n+\t    if (data[i])\n+\t      {\n+\t\ttree t = *data[i];\n+\t\tif (i < 2 && data[i + 1] == &OMP_BODY (t))\n+\t\t  data[i + 1] = data[i];\n+\t\t*data[i] = OMP_BODY (t);\n+\t\ttree body = build3 (BIND_EXPR, void_type_node, NULL_TREE,\n+\t\t\t\t    NULL_TREE, make_node (BLOCK));\n+\t\tOMP_BODY (t) = body;\n+\t\tappend_to_statement_list_force (inner_for_stmt,\n+\t\t\t\t\t\t&BIND_EXPR_BODY (body));\n+\t\t*data[3] = t;\n+\t\tdata[3] = tsi_stmt_ptr (tsi_start (BIND_EXPR_BODY (body)));\n+\t\tgcc_assert (*data[3] == inner_for_stmt);\n+\t      }\n+\t  return GS_OK;\n+\t}\n+\n+      for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (inner_for_stmt)); i++)\n+\tif (OMP_FOR_ORIG_DECLS (inner_for_stmt)\n+\t    && TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt),\n+\t\t\t\t\ti)) == TREE_LIST)\n+\t  {\n+\t    tree orig = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt), i);\n+\t    /* Class iterators aren't allowed on OMP_SIMD, so the only\n+\t       case we need to solve is distribute parallel for.  */\n+\t    gcc_assert (TREE_CODE (inner_for_stmt) == OMP_FOR\n+\t\t\t&& TREE_CODE (for_stmt) == OMP_DISTRIBUTE\n+\t\t\t&& data[1]);\n+\t    tree orig_decl = TREE_PURPOSE (orig);\n+\t    tree last = TREE_VALUE (orig);\n+\t    tree *pc;\n+\t    for (pc = &OMP_FOR_CLAUSES (inner_for_stmt);\n+\t\t *pc; pc = &OMP_CLAUSE_CHAIN (*pc))\n+\t      if ((OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_PRIVATE\n+\t\t   || OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LASTPRIVATE)\n+\t\t  && OMP_CLAUSE_DECL (*pc) == orig_decl)\n+\t\tbreak;\n+\t    if (*pc == NULL_TREE)\n+\t      ;\n+\t    else if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_PRIVATE)\n+\t      {\n+\t\t/* private clause will appear only on inner_for_stmt.\n+\t\t   Change it into firstprivate, and add private clause\n+\t\t   on for_stmt.  */\n+\t\ttree c = copy_node (*pc);\n+\t\tOMP_CLAUSE_CHAIN (c) = OMP_FOR_CLAUSES (for_stmt);\n+\t\tOMP_FOR_CLAUSES (for_stmt) = c;\n+\t\tOMP_CLAUSE_CODE (*pc) = OMP_CLAUSE_FIRSTPRIVATE;\n+\t\tlang_hooks.decls.omp_finish_clause (*pc, pre_p);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* lastprivate clause will appear on both inner_for_stmt\n+\t\t   and for_stmt.  Add firstprivate clause to\n+\t\t   inner_for_stmt.  */\n+\t\ttree c = build_omp_clause (OMP_CLAUSE_LOCATION (*pc),\n+\t\t\t\t\t   OMP_CLAUSE_FIRSTPRIVATE);\n+\t\tOMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (*pc);\n+\t\tOMP_CLAUSE_CHAIN (c) = *pc;\n+\t\t*pc = c;\n+\t\tlang_hooks.decls.omp_finish_clause (*pc, pre_p);\n+\t      }\n+\t    tree c = build_omp_clause (UNKNOWN_LOCATION,\n+\t\t\t\t       OMP_CLAUSE_FIRSTPRIVATE);\n+\t    OMP_CLAUSE_DECL (c) = last;\n+\t    OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (*data[1]);\n+\t    OMP_PARALLEL_CLAUSES (*data[1]) = c;\n+\t    c = build_omp_clause (UNKNOWN_LOCATION,\n+\t\t\t\t  *pc ? OMP_CLAUSE_SHARED\n+\t\t\t\t      : OMP_CLAUSE_FIRSTPRIVATE);\n+\t    OMP_CLAUSE_DECL (c) = orig_decl;\n+\t    OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (*data[1]);\n+\t    OMP_PARALLEL_CLAUSES (*data[1]) = c;\n+\t  }\n+    }\n+\n   switch (TREE_CODE (for_stmt))\n     {\n     case OMP_FOR:\n@@ -9611,19 +9749,6 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  }\n     }\n \n-  if (OMP_FOR_INIT (for_stmt) == NULL_TREE)\n-    {\n-      gcc_assert (TREE_CODE (for_stmt) != OACC_LOOP);\n-      inner_for_stmt = walk_tree (&OMP_FOR_BODY (for_stmt),\n-\t\t\t\t  find_combined_omp_for, NULL, NULL);\n-      if (inner_for_stmt == NULL_TREE)\n-\t{\n-\t  gcc_assert (seen_error ());\n-\t  *expr_p = NULL_TREE;\n-\t  return GS_ERROR;\n-\t}\n-    }\n-\n   if (TREE_CODE (for_stmt) != OMP_TASKLOOP)\n     gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, ort,\n \t\t\t       TREE_CODE (for_stmt));\n@@ -9633,7 +9758,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   /* Handle OMP_FOR_INIT.  */\n   for_pre_body = NULL;\n-  if (ort == ORT_SIMD && OMP_FOR_PRE_BODY (for_stmt))\n+  if ((ort == ORT_SIMD\n+       || (inner_for_stmt && TREE_CODE (inner_for_stmt) == OMP_SIMD))\n+      && OMP_FOR_PRE_BODY (for_stmt))\n     {\n       has_decl_expr = BITMAP_ALLOC (NULL);\n       if (TREE_CODE (OMP_FOR_PRE_BODY (for_stmt)) == DECL_EXPR\n@@ -9774,8 +9901,12 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       if (is_doacross)\n \t{\n \t  if (TREE_CODE (for_stmt) == OMP_FOR && OMP_FOR_ORIG_DECLS (for_stmt))\n-\t    gimplify_omp_ctxp->loop_iter_var.quick_push\n-\t      (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt), i));\n+\t    {\n+\t      tree orig_decl = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt), i);\n+\t      if (TREE_CODE (orig_decl) == TREE_LIST)\n+\t\torig_decl = TREE_PURPOSE (orig_decl);\n+\t      gimplify_omp_ctxp->loop_iter_var.quick_push (orig_decl);\n+\t    }\n \t  else\n \t    gimplify_omp_ctxp->loop_iter_var.quick_push (decl);\n \t  gimplify_omp_ctxp->loop_iter_var.quick_push (decl);\n@@ -9785,7 +9916,12 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       tree c = NULL_TREE;\n       tree c2 = NULL_TREE;\n       if (orig_for_stmt != for_stmt)\n-\t/* Do this only on innermost construct for combined ones.  */;\n+\t{\n+\t  /* Preserve this information until we gimplify the inner simd.  */\n+\t  if (has_decl_expr\n+\t      && bitmap_bit_p (has_decl_expr, DECL_UID (decl)))\n+\t    TREE_PRIVATE (t) = 1;\n+\t}\n       else if (ort == ORT_SIMD)\n \t{\n \t  splay_tree_node n = splay_tree_lookup (gimplify_omp_ctxp->variables,\n@@ -9800,8 +9936,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t      c = build_omp_clause (input_location, OMP_CLAUSE_LINEAR);\n \t      OMP_CLAUSE_LINEAR_NO_COPYIN (c) = 1;\n \t      unsigned int flags = GOVD_LINEAR | GOVD_EXPLICIT | GOVD_SEEN;\n-\t      if (has_decl_expr\n-\t\t  && bitmap_bit_p (has_decl_expr, DECL_UID (decl)))\n+\t      if ((has_decl_expr\n+\t\t   && bitmap_bit_p (has_decl_expr, DECL_UID (decl)))\n+\t\t  || TREE_PRIVATE (t))\n \t\t{\n \t\t  OMP_CLAUSE_LINEAR_NO_COPYOUT (c) = 1;\n \t\t  flags |= GOVD_LINEAR_LASTPRIVATE_NO_OUTER;\n@@ -9923,6 +10060,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t      bool lastprivate\n \t\t= (!has_decl_expr\n \t\t   || !bitmap_bit_p (has_decl_expr, DECL_UID (decl)));\n+\t      if (TREE_PRIVATE (t))\n+\t\tlastprivate = false;\n \t      struct gimplify_omp_ctx *outer\n \t\t= gimplify_omp_ctxp->outer_context;\n \t      if (outer && lastprivate)"}, {"sha": "1423598d1892a60eadb081a08273de83e2539376", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -1,3 +1,8 @@\n+2018-07-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/86443\n+\t* testsuite/libgomp.c++/for-15.C: New test.\n+\n 2018-06-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/86291"}, {"sha": "5e922acc0fa6df48dacd9c91d8ccacc6b9ab86c7", "filename": "libgomp/testsuite/libgomp.c++/for-15.C", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27c3eda934bfc946d64fb72203001c5bee46a1/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27c3eda934bfc946d64fb72203001c5bee46a1/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-15.C?ref=0b27c3eda934bfc946d64fb72203001c5bee46a1", "patch": "@@ -0,0 +1,232 @@\n+// PR c++/86443\n+// { dg-do run }\n+// { dg-additional-options \"-std=c++17\" }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+#pragma omp declare target\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () {}\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int a[2000];\n+int results[2000];\n+\n+template <typename T>\n+void\n+baz (I<T> &i)\n+{\n+  if (*i < 0 || *i >= 2000)\n+    abort ();\n+  results[*i]++;\n+}\n+\n+void\n+baz (int i)\n+{\n+  if (i < 0 || i >= 2000)\n+    abort ();\n+  results[i]++;\n+}\n+\n+void\n+qux (I<int> &i)\n+{\n+  if (*i != 1931)\n+    abort ();\n+}\n+\n+void\n+f1 (J<int> j)\n+{\n+#pragma omp distribute parallel for default(none)\n+  for (I<int> i = j.begin (); i < j.end (); i += 3)\n+    baz (*i);\n+}\n+\n+void\n+f2 (J<int> j)\n+{\n+  I<int> i;\n+#pragma omp distribute parallel for default(none)\n+  for (i = j.begin (); i < j.end (); ++i)\n+    baz (*i);\n+}\n+\n+template <int N>\n+void\n+f3 (J<int> j)\n+{\n+#pragma omp distribute parallel for default(none)\n+  for (I<int> i = j.begin (); i < j.end (); i += 6)\n+    baz (*i);\n+}\n+\n+template <int N>\n+void\n+f4 (J<int> j)\n+{\n+  I<int> i;\n+#pragma omp distribute parallel for default(none)\n+  for (i = j.begin (); i < j.end (); i += 9)\n+    baz (*i);\n+}\n+\n+template <typename T>\n+void\n+f5 (J<T> j)\n+{\n+#pragma omp distribute parallel for default(none)\n+  for (I<T> i = j.begin (); i < j.end (); i += 4)\n+    baz (*i);\n+}\n+\n+template <typename T>\n+void\n+f6 (J<T> j)\n+{\n+  I<T> i;\n+#pragma omp distribute parallel for default(none)\n+  for (i = j.begin (); i < j.end (); i += 7)\n+    baz (*i);\n+}\n+\n+#pragma omp end declare target\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  int a[2000];\n+  for (int i = 0; i < 2000; i++)\n+    a[i] = i;\n+  #pragma omp target data map (to: a)\n+  {\n+    #pragma omp target teams map (tofrom: results)\n+    {\n+      J<int> j (&a[75], &a[1945]);\n+      f1 (j);\n+    }\n+    check (i >= 75 && i < 1945 && (i - 75) % 3 == 0);\n+    #pragma omp target teams map (tofrom: results)\n+    {\n+      J<int> j (&a[63], &a[1949]);\n+      f2 (j);\n+    }\n+    check (i >= 63 && i < 1949);\n+    #pragma omp target teams map (tofrom: results)\n+    {\n+      J<int> j (&a[58], &a[1979]);\n+      f3 <2> (j);\n+    }\n+    check (i >= 58 && i < 1979 && (i - 58) % 6 == 0);\n+    #pragma omp target teams map (tofrom: results)\n+    {\n+      J<int> j (&a[59], &a[1981]);\n+      f4 <9> (j);\n+    }\n+    check (i >= 59 && i < 1981 && (i - 59) % 9 == 0);\n+    #pragma omp target teams map (tofrom: results)\n+    {\n+      J<int> j (&a[52], &a[1972]);\n+      f5 (j);\n+    }\n+    check (i >= 52 && i < 1972 && (i - 52) % 4 == 0);\n+    #pragma omp target teams map (tofrom: results)\n+    {\n+      J<int> j (&a[31], &a[1827]);\n+      f6 (j);\n+    }\n+    check (i >= 31 && i < 1827 && (i - 31) % 7 == 0);\n+  }\n+}"}]}