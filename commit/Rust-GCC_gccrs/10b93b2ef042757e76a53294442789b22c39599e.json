{"sha": "10b93b2ef042757e76a53294442789b22c39599e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiOTNiMmVmMDQyNzU3ZTc2YTUzMjk0NDQyNzg5YjIyYzM5NTk5ZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2005-09-05T07:47:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:47:56Z"}, "message": "a-tags.adb (IW_Membership): Give support to \"Iface_CW_Typ in T'Class\".\n\n2005-09-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-tags.adb (IW_Membership): Give support to\n\t\"Iface_CW_Typ in T'Class\". For this purpose the functionality of this\n\tsubprogram has been extended to look for the tag in the ancestors tag\n\ttable.\n\tUpdate the structure of the GNAT Dispatch Table to reflect the\n\tadditional two tables used in dispatching selects.\n\tIntroduce appropriate array types and record components in\n\tType_Specific_Data to reflect the two tables.\n\t(Get_Entry_Index, Set_Entry_Index): Retrieve and set the entry index in\n\tthe TSD of a tag, indexed by position.\n\t(Get_Prim_Op_Kind, Set_Prim_Op_Kind): Retrieve and set the primitive\n\toperation kind in the TSD of a tag, indexed by position.\n\n\t* a-tags.ads: Introduce an enumeration type to capture different\n\tprimitive operation kinds. Define a constant reflecting the number of\n\tpredefined primitive operations.\n\t(Get_Entry_Index, Set_Entry_Index): Set and retrieve the entry index\n\tof an entry wrapper.\n\t(Get_Prim_Op_Kind, Set_Prim_Op_Kind): Set and retrieve the kind of\n\tcallable entity of a primitive operation.\n\n\t* exp_ch3.adb (Freeze_Record_Type): Generate the declarations of the\n\tprimitive operations used in dispatching selects for limited\n\tinterfaces, limited tagged, task and protected types what implement a\n\tlimited interface.\n\t(Freeze_Type): Generate the bodies of the primitive operations used in\n\tdispatching selects for limited tagged, task and protected types that\n\timplement a limited interface. Generate statements to populate the two\n\tauxiliary tables used for dispatching in select statements.\n\t(Freeze_Record_Type): Add call to initialize the dispatch table entries\n\tassociated with predefined interface primitive operations.\n\t(Build_Dcheck_Function): Change Set_Subtype_Mark to\n\tSet_Result_Definition.\n\t(Build_Variant_Record_Equality): Change Subtype_Mark to\n\tResult_Definition.\n\t(Freeze_Enumeration_Type): Change Subtype_Mark to Result_Definition.\n\t(Predef_Spec_Or_Body): Change Subtype_Mark to Result_Definition.\n\t(Build_Assignment): Simplify the code that adds the run-time-check.\n\t(Expand_N_Object_Declaration): Code cleanup.\n\n\t* exp_ch7.adb (Make_Clean): Select the appropriate type for locking\n\tentries when there is a protected type that implements a limited\n\tinterface.\n\n\t* exp_ch9.adb: Add package Select_Expansion_Utilities that contains\n\tcommon routines used in expansion of dispatching selects.\n\t(Add_Private_Declarations): Select the appropriate protection type when\n\tthere is a protected type that implements a limited interface.\n\t(Build_Parameter_Block): Generate a wrapped parameter block.\n\t(Build_Protected_Subprogram_Body): Select the appropriate type for\n\tlocking entries when there is a protected type that implements a\n\tlimited interface.\n\t(Build_Wrapper_Spec): Set the flag and wrapped entity for procedures\n\tclassified as entry wrappers.\n\t(Expand_N_Asynchronous_Select): Add support for expansion of dispatching\n\tasynchronous selects.\n\t(Expand_N_Conditional_Entry_Call): Add support for expansion of\n\tdispatching conditional selects.\n\t(Expand_N_Protected_Type_Declaration): Select the appropriate type for\n\tprotection when there is a protected type that implements limited\n\tinterfaces.\n\t(Expand_N_Timed_Entry_Call): Add support for expansion of dispatching\n\ttimed selects.\n\t(Extract_Dispatching_Call): Extract the entity of the name of a\n\tdispatching call, the object parameter, actual parameters and\n\tcorresponding formals.\n\t(Make_Initialize_Protection): Correct logic of protection initialization\n\twhen there is a protected type that implements a limited interface.\n\t(Parameter_Block_Pack): Populate a wrapped parameter block with the\n\tvalues of actual parameters.\n\t(Parameter_Block_Unpack): Retrieve the values from a wrapped parameter\n\tblock and assign them to the original actual parameters.\n\n\t* exp_ch9.ads (Subprogram_Protection_Mode): New type.\n\t(Build_Protected_Sub_Specification): Change the type and name of the\n\tlast formal to account for the increased variety of protection modes.\n\n\t* einfo.ads, einfo.adb (Was_Hidden): New attribute. Present in all\n\tentities. Used to save the value of the Is_Hidden attribute when the\n\tlimited-view is installed.\n\t(Is_Primitive_Wrapper, Set_Is_Primitive_Wrapper): Retrieve and change\n\tthe attribute of procedures classified as entry wrappers.\n\t(Wrapped_Entity, Set_Wrapped_Entity): Retrieve and change the wrapped\n\tentity of a primitive wrapper.\n\t(Write_Entity_Flags): Output the name and value of the\n\tIs_Primitive_Wrapper attribute.\n\t(Write_Field27_Name): Output the name and entity of the field Wrapped_\n\tEntity.\n\t(Underlying_Type): If we have an incomplete entity that comes from\n\tthe limited view then we return the Underlying_Type of its non-limited\n\tview if it is already available.\n\t(Abstract_Interface_Alias): Flag applies to all subrogram kinds,\n\tincluding operators.\n\t(Write_Field26_Name): Add entry for Overridden_Operation\n\t(Overridden_Operation): New attribute of functions and procedures.\n\n\t* exp_disp.ads, exp_disp.adb (Default_Prim_Op_Position): Return a\n\tpredefined position in the dispatch table for the primitive operations\n\tused in dispatching selects.\n\t(Init_Predefined_Interface_Primitives): Remove the hardcoded number of\n\tpredefined primitive operations and replace it with\n\tDefault_Prim_Op_Count.\n\t(Make_Disp_Asynchronous_Select_Spec, Make_Disp_Conditional_Select_Spec,\n\tMake_Disp_Get_Prim_Op_Kind_Spec, Make_Disp_Timed_Select_Spec): Update\n\tthe names of the generated primitive operations used in dispatching\n\tselects.\n\t(Init_Predefined_Interface_Primitives): No need to inherit primitives in\n\tcase of abstract interface types. They will be inherit by the objects\n\timplementing the interface.\n\t(Make_DT): There is no need to inherit the dispatch table of the\n\tancestor interface for the elaboration of abstract interface types.\n\tThe dispatch table will be inherited by the object implementing the\n\tinterface.\n\t(Copy_Secondary_DTs): Add documentation.\n\t(Validate_Position): Improve this static check in case of\n\taliased subprograms because aliased subprograms must have\n\tthe same position.\n\t(Init_Predefined_Interface_Primitives): New subprogram that initializes\n\tthe entries associated with predefined primitives of all the secondary\n\tdispatch tables.\n\t(Build_Anonymous_Access_Type): Removed.\n\t(Expand_Interface_Actuals): With the previous cleanup there is no need\n\tto build an anonymous access type. This allows further cleanup in the\n\tcode generated by the expander.\n\t(Expand_Interface_Conversion): If the actual is an access type then\n\tbuild an internal function to handle the displacement. If the actual\n\tis null this function returns null because no displacement is\n\trequired; otherwise performs a type conversion that will be\n\texpanded in the code that returns the value of the displaced actual.\n\t(Expand_Interface_Actuals): Avoid the generation of unnecessary type\n\tconversions that have no effect in the generated code because no\n\tdisplacement is required. Code cleanup; use local variables to\n\tavoid repeated calls to the subprogram directly_designated_type().\n\n\t* exp_util.ads, exp_util.adb (Is_Predefined_Dispatching_Operation):\n\tClassify the primitive operations used in dispatching selects as\n\tpredefined.\n\t(Implements_Limited_Interface): Determine whether some type either\n\tdirectly implements a limited interface or extends a type that\n\timplements a limited interface.\n\t(Build_Task_Image_Function): Change Subtype_Mark to Result_Definition.\n\t(Expand_Subtype_From_Expr): Do not build actual subtype if the\n\texpression is limited.\n\t(Find_Interface_Tag): Add code to handle class-wide types and\n\tentities from the limited-view.\n\n\t* rtsfind.ads: Add entries in RE_Id and RE_Unit_Table for\n\tGet_Entry_Index, Get_Prim_Op_Kind, POK_Function, POK_Procedure,\n\tPOK_Protected_Entry, POK_Protected_Function, POK_Protected_Procedure,\n\tPOK_Task_Entry, POK_Task_Procedure, Prim_Op_Kind, Set_Entry_Index,\n\tSet_Prim_Op_Kind.\n\n\t* sem_ch9.adb (Analyze_Triggering_Alternative): Check for legal type\n\tof procedure name or prefix that appears as a trigger in a triggering\n\talternative.\n\n\t* uintp.ads: Introduce constants Uint_11 and Uint_13.\n\nFrom-SVN: r103850", "tree": {"sha": "e32d801f0e7b786b2b1bdd51d22ac759a1fcb9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e32d801f0e7b786b2b1bdd51d22ac759a1fcb9fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b93b2ef042757e76a53294442789b22c39599e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b93b2ef042757e76a53294442789b22c39599e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b93b2ef042757e76a53294442789b22c39599e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b93b2ef042757e76a53294442789b22c39599e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "630d30e96d138be05bea2e2769026ef819fb417d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630d30e96d138be05bea2e2769026ef819fb417d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630d30e96d138be05bea2e2769026ef819fb417d"}], "stats": {"total": 5265, "additions": 4417, "deletions": 848}, "files": [{"sha": "4a21e15c693a31ed4219b3eddd1c43d1e7f3d571", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 104, "deletions": 29, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -65,27 +65,44 @@ package body Ada.Tags is\n --                                          |      tags         |\n --                                          +-------------------+\n --                                          | table of          |\n---                                          |   interface       |\n+--                                          :   interface       :\n --                                          |      tags         |\n+--                                          +-------------------+\n+--                                          | table of          |\n+--                                          :   primitive op    :\n+--                                          |     kinds         |\n+--                                          +-------------------+\n+--                                          | table of          |\n+--                                          :   entry           :\n+--                                          |     indices       |\n --                                          +-------------------+\n \n    subtype Cstring is String (Positive);\n    type Cstring_Ptr is access all Cstring;\n \n+   --  We suppress index checks because the declared size in the record below\n+   --  is a dummy size of one (see below).\n+\n    type Tag_Table is array (Natural range <>) of Tag;\n    pragma Suppress_Initialization (Tag_Table);\n    pragma Suppress (Index_Check, On => Tag_Table);\n-   --  We suppress index checks because the declared size in the record below\n-   --  is a dummy size of one (see below).\n+\n+   type Prim_Op_Kind_Table is array (Natural range <>) of Prim_Op_Kind;\n+   pragma Suppress_Initialization (Prim_Op_Kind_Table);\n+   pragma Suppress (Index_Check, On => Prim_Op_Kind_Table);\n+\n+   type Entry_Index_Table is array (Natural range <>) of Positive;\n+   pragma Suppress_Initialization (Entry_Index_Table);\n+   pragma Suppress (Index_Check, On => Entry_Index_Table);\n \n    type Type_Specific_Data is record\n-      Idepth            : Natural;\n+      Idepth : Natural;\n       --  Inheritance Depth Level: Used to implement the membership test\n       --  associated with single inheritance of tagged types in constant-time.\n       --  In addition it also indicates the size of the first table stored in\n       --  the Tags_Table component (see comment below).\n \n-      Access_Level      : Natural;\n+      Access_Level : Natural;\n       --  Accessibility level required to give support to Ada 2005 nested type\n       --  extensions. This feature allows safe nested type extensions by\n       --  shifting the accessibility checks to certain operations, rather than\n@@ -94,20 +111,20 @@ package body Ada.Tags is\n       --  function return, and class-wide stream I/O, the danger of objects\n       --  outliving their type declaration can be eliminated (Ada 2005: AI-344)\n \n-      Expanded_Name     : Cstring_Ptr;\n-      External_Tag      : Cstring_Ptr;\n-      HT_Link           : Tag;\n+      Expanded_Name : Cstring_Ptr;\n+      External_Tag  : Cstring_Ptr;\n+      HT_Link       : Tag;\n       --  Components used to give support to the Ada.Tags subprograms described\n       --  in ARM 3.9\n \n       Remotely_Callable : Boolean;\n       --  Used to check ARM E.4 (18)\n \n-      RC_Offset         : SSE.Storage_Offset;\n+      RC_Offset : SSE.Storage_Offset;\n       --  Controller Offset: Used to give support to tagged controlled objects\n       --  (see Get_Deep_Controller at s-finimp)\n \n-      Num_Interfaces    : Natural;\n+      Num_Interfaces : Natural;\n       --  Number of abstract interface types implemented by the tagged type.\n       --  The value Idepth+Num_Interfaces indicates the end of the second table\n       --  stored in the Tags_Table component. It is used to implement the\n@@ -121,6 +138,16 @@ package body Ada.Tags is\n       --  purpose we are using the same mechanism as for the Prims_Ptr array in\n       --  the Dispatch_Table record. See comments below on Prims_Ptr for\n       --  further details.\n+\n+      POK_Table       : Prim_Op_Kind_Table (1 .. 1);\n+      Ent_Index_Table : Entry_Index_Table  (1 .. 1);\n+      --  Two auxiliary tables used for dispatching in asynchronous,\n+      --  conditional and timed selects. Their size depends on the number\n+      --  of primitive operations. Indexing in these two tables is performed\n+      --  by subtracting the number of predefined primitive operations from\n+      --  the given index value. POK_Table contains the callable entity kinds\n+      --  of all non-predefined primitive operations. Ent_Index_Table contains\n+      --  the entry index of primitive entry wrappers.\n    end record;\n \n    type Dispatch_Table is record\n@@ -175,7 +202,7 @@ package body Ada.Tags is\n    type Storage_Offset_Ptr is access System.Storage_Elements.Storage_Offset;\n \n    function To_Storage_Offset_Ptr is\n-      new Unchecked_Conversion (System.Address, Storage_Offset_Ptr);\n+     new Unchecked_Conversion (System.Address, Storage_Offset_Ptr);\n \n    -----------------------\n    -- Local Subprograms --\n@@ -242,15 +269,12 @@ package body Ada.Tags is\n          Str1 : constant Cstring_Ptr := To_Cstring_Ptr (A);\n          Str2 : constant Cstring_Ptr := To_Cstring_Ptr (B);\n          J    : Integer := 1;\n-\n       begin\n          loop\n             if Str1 (J) /= Str2 (J) then\n                return False;\n-\n             elsif Str1 (J) = ASCII.NUL then\n                return True;\n-\n             else\n                J := J + 1;\n             end if;\n@@ -330,22 +354,27 @@ package body Ada.Tags is\n    --  that are contained in the dispatch table referenced by Obj'Tag.\n \n    function IW_Membership\n-     (This      : System.Address;\n-      Iface_Tag : Tag) return Boolean\n+     (This : System.Address;\n+      T    : Tag) return Boolean\n    is\n-      T        : constant Tag := To_Tag_Ptr (This).all;\n-      Obj_Base : constant System.Address := This - Offset_To_Top (T);\n-      T_Base   : constant Tag := To_Tag_Ptr (Obj_Base).all;\n+      Curr_DT  : constant Tag := To_Tag_Ptr (This).all;\n+      Obj_Base : constant System.Address := This - Offset_To_Top (Curr_DT);\n+      Obj_DT   : constant Tag := To_Tag_Ptr (Obj_Base).all;\n \n-      Obj_TSD  : constant Type_Specific_Data_Ptr := TSD (T_Base);\n-      Last_Id  : constant Natural := Obj_TSD.Idepth + Obj_TSD.Num_Interfaces;\n-      Id       : Natural;\n+      Obj_TSD : constant Type_Specific_Data_Ptr := TSD (Obj_DT);\n+      Last_Id : constant Natural := Obj_TSD.Idepth + Obj_TSD.Num_Interfaces;\n+      Id      : Natural;\n \n    begin\n       if Obj_TSD.Num_Interfaces > 0 then\n-         Id := Obj_TSD.Idepth + 1;\n+\n+         --  Traverse the ancestor tags table plus the interface tags table.\n+         --  The former part is required to give support to:\n+         --     Iface_CW in Typ'Class\n+\n+         Id := 0;\n          loop\n-            if Obj_TSD.Tags_Table (Id) = Iface_Tag then\n+            if Obj_TSD.Tags_Table (Id) = T then\n                return True;\n             end if;\n \n@@ -413,6 +442,17 @@ package body Ada.Tags is\n       return TSD (T).Access_Level;\n    end Get_Access_Level;\n \n+   ---------------------\n+   -- Get_Entry_Index --\n+   ---------------------\n+\n+   function Get_Entry_Index\n+     (T        : Tag;\n+      Position : Positive) return Positive is\n+   begin\n+      return TSD (T).Ent_Index_Table (Position - Default_Prim_Op_Count);\n+   end Get_Entry_Index;\n+\n    ----------------------\n    -- Get_External_Tag --\n    ----------------------\n@@ -433,6 +473,17 @@ package body Ada.Tags is\n       return T.Prims_Ptr (Position);\n    end Get_Prim_Op_Address;\n \n+   ----------------------\n+   -- Get_Prim_Op_Kind --\n+   ----------------------\n+\n+   function Get_Prim_Op_Kind\n+     (T        : Tag;\n+      Position : Positive) return Prim_Op_Kind is\n+   begin\n+      return TSD (T).POK_Table (Position - Default_Prim_Op_Count);\n+   end Get_Prim_Op_Kind;\n+\n    -------------------\n    -- Get_RC_Offset --\n    -------------------\n@@ -485,9 +536,9 @@ package body Ada.Tags is\n          --  of the parent\n \n          New_TSD_Ptr.Tags_Table\n-           (1 .. New_TSD_Ptr.Idepth + New_TSD_Ptr.Num_Interfaces)\n-           := Old_TSD_Ptr.Tags_Table\n-                (0 .. Old_TSD_Ptr.Idepth + Old_TSD_Ptr.Num_Interfaces);\n+           (1 .. New_TSD_Ptr.Idepth + New_TSD_Ptr.Num_Interfaces) :=\n+             Old_TSD_Ptr.Tags_Table\n+               (0 .. Old_TSD_Ptr.Idepth + Old_TSD_Ptr.Num_Interfaces);\n       else\n          New_TSD_Ptr.Idepth         := 0;\n          New_TSD_Ptr.Num_Interfaces := 0;\n@@ -588,8 +639,8 @@ package body Ada.Tags is\n       --  The tag of the parent type through the dispatch table\n \n       F : constant Acc_Size := To_Acc_Size (Parent_Tag.Prims_Ptr (1));\n-      --  Access to the _size primitive of the parent. We assume that\n-      --  it is always in the first slot of the dispatch table\n+      --  Access to the _size primitive of the parent. We assume that it is\n+      --  always in the first slot of the dispatch table\n \n    begin\n       --  Here we compute the size of the _parent field of the object\n@@ -672,6 +723,18 @@ package body Ada.Tags is\n       TSD (T).Access_Level := Value;\n    end Set_Access_Level;\n \n+   ---------------------\n+   -- Set_Entry_Index --\n+   ---------------------\n+\n+   procedure Set_Entry_Index\n+     (T        : Tag;\n+      Position : Positive;\n+      Value    : Positive) is\n+   begin\n+      TSD (T).Ent_Index_Table (Position - Default_Prim_Op_Count) := Value;\n+   end Set_Entry_Index;\n+\n    -----------------------\n    -- Set_Expanded_Name --\n    -----------------------\n@@ -718,6 +781,18 @@ package body Ada.Tags is\n       T.Prims_Ptr (Position) := Value;\n    end Set_Prim_Op_Address;\n \n+   ----------------------\n+   -- Set_Prim_Op_Kind --\n+   ----------------------\n+\n+   procedure Set_Prim_Op_Kind\n+     (T        : Tag;\n+      Position : Positive;\n+      Value    : Prim_Op_Kind) is\n+   begin\n+      TSD (T).POK_Table (Position - Default_Prim_Op_Count) := Value;\n+   end Set_Prim_Op_Kind;\n+\n    -------------------\n    -- Set_RC_Offset --\n    -------------------"}, {"sha": "34d7d63b09750c24321aa7bab059101b91173d00", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -40,11 +40,8 @@ with System.Storage_Elements;\n with Unchecked_Conversion;\n \n package Ada.Tags is\n-pragma Preelaborate_05 (Tags);\n---  In accordance with Ada 2005 AI-362\n-\n-   pragma Elaborate_Body;\n-   --  We need a dummy body to solve bootstrap path issues (why ???)\n+   pragma Preelaborate_05;\n+   --  In accordance with Ada 2005 AI-362\n \n    type Tag is private;\n \n@@ -101,33 +98,78 @@ private\n    type Type_Specific_Data;\n    type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n \n+   --  Primitive operation kinds. These values differentiate the kinds of\n+   --  callable entities stored in the dispatch table. Certain kinds may\n+   --  not be used, but are added for completeness.\n+\n+   type Prim_Op_Kind is\n+     (POK_Function,\n+      POK_Procedure,\n+      POK_Protected_Entry,\n+      POK_Protected_Function,\n+      POK_Protected_Procedure,\n+      POK_Task_Entry,\n+      POK_Task_Procedure);\n+\n+   --  Number of predefined primitive operations added by the Expander\n+   --  for a tagged type. It is utilized for indexing in the two auxiliary\n+   --  tables used for dispatching asynchronous, conditional and timed\n+   --  selects. In order to be space efficien, indexing is performed by\n+   --  subtracting this constant value from the provided position in the\n+   --  auxiliary tables.\n+   --  This value is mirrored from Exp_Disp.ads.\n+\n+   Default_Prim_Op_Count : constant Positive := 14;\n+\n    package SSE renames System.Storage_Elements;\n \n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean;\n    --  Given the tag of an object and the tag associated to a type, return\n    --  true if Obj is in Typ'Class.\n \n    function IW_Membership\n-     (This      : System.Address;\n-      Iface_Tag : Tag) return Boolean;\n-   --  Ada 2005 (AI-251): Given the tag of an object and the tag associated\n-   --  with an interface, return true if Obj is in Iface'Class.\n+     (This : System.Address;\n+      T    : Tag) return Boolean;\n+   --  Ada 2005 (AI-251): General routine that checks if a given object\n+   --  implements a tagged type. Its common usage is to check if Obj is in\n+   --  Iface'Class, but it is also used to check if a class-wide interface\n+   --  implements a given type (Iface_CW_Typ in T'Class). For example:\n+   --\n+   --      type I is interface;\n+   --      type T is tagged ...\n+   --\n+   --      function Test (O : in I'Class) is\n+   --      begin\n+   --         return O in T'Class.\n+   --      end Test;\n \n    function Get_Access_Level (T : Tag) return Natural;\n    --  Given the tag associated with a type, returns the accessibility level\n    --  of the type.\n \n+   function Get_Entry_Index\n+     (T        : Tag;\n+      Position : Positive) return Positive;\n+   --  Return a primitive operation's entry index (if entry) given a dispatch\n+   --  table T and a position of a primitive operation in T.\n+\n    function Get_External_Tag (T : Tag) return System.Address;\n    --  Retrieve the address of a null terminated string containing\n    --  the external name\n \n    function Get_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive) return System.Address;\n-   --  Given a pointer to a dispatch Table (T) and a position in the DT\n+   --  Given a pointer to a dispatch table (T) and a position in the DT\n    --  this function returns the address of the virtual function stored\n    --  in it (used for dispatching calls)\n \n+   function Get_Prim_Op_Kind\n+     (T        : Tag;\n+      Position : Positive) return Prim_Op_Kind;\n+   --  Return a primitive operation's kind given a dispatch table T and a\n+   --  position of a primitive operation in T.\n+\n    function Get_RC_Offset (T : Tag) return SSE.Storage_Offset;\n    --  Return the Offset of the implicit record controller when the object\n    --  has controlled components. O otherwise.\n@@ -173,6 +215,13 @@ private\n    --  Insert the Tag and its associated external_tag in a table for the\n    --  sake of Internal_Tag\n \n+   procedure Set_Entry_Index\n+     (T        : Tag;\n+      Position : Positive;\n+      Value    : Positive);\n+   --  Set the entry index of a primitive operation in T's TSD table indexed\n+   --  by Position.\n+\n    procedure Set_Offset_To_Top\n      (T     : Tag;\n       Value : System.Storage_Elements.Storage_Offset);\n@@ -185,25 +234,32 @@ private\n      (T        : Tag;\n       Position : Positive;\n       Value    : System.Address);\n-   --  Given a pointer to a dispatch Table (T) and a position in the\n-   --  dispatch Table put the address of the virtual function in it\n-   --  (used for overriding)\n+   --  Given a pointer to a dispatch Table (T) and a position in the dispatch\n+   --  Table put the address of the virtual function in it (used for\n+   --  overriding).\n+\n+   procedure Set_Prim_Op_Kind\n+     (T        : Tag;\n+      Position : Positive;\n+      Value    : Prim_Op_Kind);\n+   --  Set the kind of a primitive operation in T's TSD table indexed by\n+   --  Position.\n \n    procedure Set_TSD (T : Tag; Value : System.Address);\n    --  Given a pointer T to a dispatch Table, stores the address of the record\n-   --  containing the Type Specific Data generated by GNAT\n+   --  containing the Type Specific Data generated by GNAT.\n \n    procedure Set_Access_Level (T : Tag; Value : Natural);\n    --  Sets the accessibility level of the tagged type associated with T\n    --  in its TSD.\n \n    procedure Set_Expanded_Name (T : Tag; Value : System.Address);\n    --  Set the address of the string containing the expanded name\n-   --  in the Dispatch table\n+   --  in the Dispatch table.\n \n    procedure Set_External_Tag (T : Tag; Value : System.Address);\n    --  Set the address of the string containing the external tag\n-   --  in the Dispatch table\n+   --  in the Dispatch table.\n \n    procedure Set_RC_Offset (T : Tag; Value : SSE.Storage_Offset);\n    --  Sets the Offset of the implicit record controller when the object"}, {"sha": "db446143abb7880c7096537d6fabb748e2e388bb", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -215,9 +215,9 @@ package body Einfo is\n \n    --    Abstract_Interface_Alias        Node25\n \n-   --    (unused)                        Node26\n+   --    Overridden_Operation            Node26\n \n-   --    (unused)                        Node27\n+   --    Wrapped_Entity                  Node27\n \n    ---------------------------------------------\n    -- Usage of Flags in Defining Entity Nodes --\n@@ -442,9 +442,9 @@ package body Einfo is\n    --    Has_Specified_Stream_Read      Flag192\n    --    Has_Specified_Stream_Write     Flag193\n    --    Is_Local_Anonymous_Access      Flag194\n+   --    Is_Primitive_Wrapper           Flag195\n+   --    Was_Hidden                     Flag196\n \n-   --    (unused)                       Flag195\n-   --    (unused)                       Flag196\n    --    (unused)                       Flag197\n    --    (unused)                       Flag198\n    --    (unused)                       Flag199\n@@ -512,8 +512,7 @@ package body Einfo is\n \n    function Abstract_Interface_Alias (Id : E) return E is\n    begin\n-      pragma Assert\n-        (Ekind (Id) = E_Procedure or Ekind (Id) = E_Function);\n+      pragma Assert (Is_Subprogram (Id));\n       return Node25 (Id);\n    end Abstract_Interface_Alias;\n \n@@ -1734,6 +1733,12 @@ package body Einfo is\n       return Flag59 (Id);\n    end Is_Preelaborated;\n \n+   function Is_Primitive_Wrapper (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure);\n+      return Flag195 (Id);\n+   end Is_Primitive_Wrapper;\n+\n    function Is_Private_Composite (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -2038,6 +2043,11 @@ package body Einfo is\n       return Node22 (Id);\n    end Original_Record_Component;\n \n+   function Overridden_Operation (Id : E) return E is\n+   begin\n+      return Node26 (Id);\n+   end Overridden_Operation;\n+\n    function Packed_Array_Type (Id : E) return E is\n    begin\n       pragma Assert (Is_Array_Type (Id));\n@@ -2325,6 +2335,18 @@ package body Einfo is\n       return Flag96 (Id);\n    end Warnings_Off;\n \n+   function Wrapped_Entity (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure\n+                       and then Is_Primitive_Wrapper (Id));\n+      return Node27 (Id);\n+   end Wrapped_Entity;\n+\n+   function Was_Hidden (Id : E) return B is\n+   begin\n+      return Flag196 (Id);\n+   end Was_Hidden;\n+\n    ------------------------------\n    -- Classification Functions --\n    ------------------------------\n@@ -3799,6 +3821,12 @@ package body Einfo is\n       Set_Flag59 (Id, V);\n    end Set_Is_Preelaborated;\n \n+   procedure Set_Is_Primitive_Wrapper (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure);\n+      Set_Flag195 (Id, V);\n+   end Set_Is_Primitive_Wrapper;\n+\n    procedure Set_Is_Private_Composite (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -4107,6 +4135,11 @@ package body Einfo is\n       Set_Node22 (Id, V);\n    end Set_Original_Record_Component;\n \n+   procedure Set_Overridden_Operation (Id : E; V : E) is\n+   begin\n+      Set_Node26 (Id, V);\n+   end Set_Overridden_Operation;\n+\n    procedure Set_Packed_Array_Type (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Array_Type (Id));\n@@ -4400,6 +4433,18 @@ package body Einfo is\n       Set_Flag96 (Id, V);\n    end Set_Warnings_Off;\n \n+   procedure Set_Was_Hidden (Id : E; V : B := True) is\n+   begin\n+      Set_Flag196 (Id, V);\n+   end Set_Was_Hidden;\n+\n+   procedure Set_Wrapped_Entity (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure\n+                       and then Is_Primitive_Wrapper (Id));\n+      Set_Node27 (Id, V);\n+   end Set_Wrapped_Entity;\n+\n    -----------------------------------\n    -- Field Initialization Routines --\n    -----------------------------------\n@@ -6328,6 +6373,15 @@ package body Einfo is\n                return Underlying_Type (Full_View (Id));\n             end if;\n \n+         --  If we have an incomplete entity that comes from the limited\n+         --  view then we return the Underlying_Type of its non-limited\n+         --  view.\n+\n+         elsif From_With_Type (Id)\n+           and then Present (Non_Limited_View (Id))\n+         then\n+            return Underlying_Type (Non_Limited_View (Id));\n+\n          --  Otherwise check for the case where we have a derived type or\n          --  subtype, and if so get the Underlying_Type of the parent type.\n \n@@ -6538,6 +6592,7 @@ package body Einfo is\n       W (\"Is_Packed_Array_Type\",          Flag138 (Id));\n       W (\"Is_Potentially_Use_Visible\",    Flag9   (Id));\n       W (\"Is_Preelaborated\",              Flag59  (Id));\n+      W (\"Is_Primitive_Wrapper\",          Flag195 (Id));\n       W (\"Is_Private_Composite\",          Flag107 (Id));\n       W (\"Is_Private_Descendant\",         Flag53  (Id));\n       W (\"Is_Public\",                     Flag10  (Id));\n@@ -6589,6 +6644,7 @@ package body Einfo is\n       W (\"Uses_Sec_Stack\",                Flag95  (Id));\n       W (\"Vax_Float\",                     Flag151 (Id));\n       W (\"Warnings_Off\",                  Flag96  (Id));\n+      W (\"Was_Hidden\",                    Flag196 (Id));\n    end Write_Entity_Flags;\n \n    -----------------------\n@@ -7504,6 +7560,10 @@ package body Einfo is\n    procedure Write_Field26_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Procedure                                |\n+              E_Function                                 =>\n+            Write_Str (\"Overridden_Operation\");\n+\n          when others                                     =>\n             Write_Str (\"Field26??\");\n       end case;\n@@ -7516,6 +7576,9 @@ package body Einfo is\n    procedure Write_Field27_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Procedure                                =>\n+            Write_Str (\"Wrapped_Entity\");\n+\n          when others                                     =>\n             Write_Str (\"Field27??\");\n       end case;"}, {"sha": "189a9ecfffe78c28e44c9bd4e96e26d5bbe590e0", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -183,7 +183,7 @@ package Einfo is\n --       dynamic bounds, it is assumed that the value can range down or up\n --       to the corresponding bound of the ancestor\n \n---    The RM defined attribute Size corresponds to the Value_Size attribute.\n+--    The RM defined attribute Size corresponds to the Value_Size attribute\n \n --    The Size attribute may be defined for a first-named subtype. This sets\n --    the Value_Size of the first-named subtype to the given value, and the\n@@ -2243,6 +2243,11 @@ package Einfo is\n --       flag is set does not necesarily mean that no elaboration code is\n --       generated for the package.\n \n+--    Is_Primitive_Wrapper (Flag195)\n+--       Present in E_Procedures. Primitive wrappers are Expander-generated\n+--       procedures that wrap entries of protected or task types implementing\n+--       a limited interface.\n+\n --    Is_Private_Composite (Flag107)\n --       Present in composite types that have a private component. Used to\n --       enforce the rule that operations on the composite type that depend\n@@ -2769,6 +2774,10 @@ package Einfo is\n --       In subtypes (tagged and untagged):\n --         Points to the component in the base type.\n \n+--    Overridden_Operation (Node26)\n+--       Present in subprograms. For overriding operations, points to the\n+--       user-defined parent subprogram that is being overridden.\n+\n --    Packed_Array_Type (Node23)\n --       Present in array types and subtypes, including the string literal\n --       subtype case, if the corresponding type is packed (either bit packed\n@@ -3220,6 +3229,14 @@ package Einfo is\n --       is used to suppress warnings for a given entity. It is also used by\n --       the compiler in some situations to kill spurious warnings.\n \n+--    Was_Hidden (Flag196)\n+--       Present in all entities. Used to save the value of the Is_Hidden\n+--       attribute when the limited-view is installed (Ada 2005: AI-217).\n+\n+--    Wrapped_Entity (Node27)\n+--       Present in an E_Procedure classified as a Is_Primitive_Wrapper. Set\n+--       to the entity that is being wrapped.\n+\n    ------------------\n    -- Access Kinds --\n    ------------------\n@@ -3488,7 +3505,7 @@ package Einfo is\n       --  A record type, created by a record type declaration\n \n       E_Record_Subtype,\n-      --  A record subtype, created by a record subtype declaration.\n+      --  A record subtype, created by a record subtype declaration\n \n       E_Record_Type_With_Private,\n       --  Used for types defined by a private extension declaration, and\n@@ -3499,7 +3516,7 @@ package Einfo is\n       --  a private type.\n \n       E_Record_Subtype_With_Private,\n-      --  A subtype of a type defined by a private extension declaration.\n+      --  A subtype of a type defined by a private extension declaration\n \n       E_Private_Type,\n       --  A private type, created by a private type declaration\n@@ -4033,6 +4050,7 @@ package Einfo is\n    --    Is_Packed_Array_Type          (Flag138)\n    --    Is_Potentially_Use_Visible    (Flag9)\n    --    Is_Preelaborated              (Flag59)\n+   --    Is_Primitive_Wrapper          (Flag195)\n    --    Is_Public                     (Flag10)\n    --    Is_Pure                       (Flag44)\n    --    Is_Remote_Call_Interface      (Flag62)\n@@ -4050,6 +4068,7 @@ package Einfo is\n    --    Referenced_As_LHS             (Flag36)\n    --    Suppress_Elaboration_Warnings (Flag148)\n    --    Suppress_Style_Checks         (Flag165)\n+   --    Was_Hidden                    (Flag196)\n \n    --    Declaration_Node              (synth)\n    --    Enclosing_Dynamic_Scope       (synth)\n@@ -4401,6 +4420,7 @@ package Einfo is\n    --    Privals_Chain                 (Elist23)  (for a protected function)\n    --    Obsolescent_Warning           (Node24)\n    --    Abstract_Interface_Alias      (Node25)\n+   --    Overridden_Operation          (Node26)\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Elaboration_Entity_Required   (Flag174)\n    --    Function_Returns_With_DSP     (Flag169)\n@@ -4648,6 +4668,9 @@ package Einfo is\n    --    Privals_Chain                 (Elist23)  (for a protected procedure)\n    --    Obsolescent_Warning           (Node24)\n    --    Abstract_Interface_Alias      (Node25)\n+   --    Overridden_Operation          (Node26)\n+   --    Wrapped_Entity                (Node27)   (non-generic case only)\n+\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Elaboration_Entity_Required   (Flag174)\n    --    Function_Returns_With_DSP     (Flag169)  (always False for procedure)\n@@ -4673,6 +4696,8 @@ package Einfo is\n    --    Is_Machine_Code_Subprogram    (Flag137)  (non-generic case only)\n    --    Is_Null_Init_Proc             (Flag178)\n    --    Is_Overriding_Operation       (Flag39)   (non-generic case only)\n+   --    Is_Primitive_Wrapper          (Flag195)  (non-generic case only)\n+\n    --    Is_Private_Descendant         (Flag53)\n    --    Is_Pure                       (Flag44)\n    --    Is_Thread_Body                (Flag77)   (non-generic case only)\n@@ -5299,6 +5324,8 @@ package Einfo is\n    function Is_Packed_Array_Type               (Id : E) return B;\n    function Is_Potentially_Use_Visible         (Id : E) return B;\n    function Is_Preelaborated                   (Id : E) return B;\n+   function Is_Primitive_Wrapper               (Id : E) return B;\n+\n    function Is_Private_Composite               (Id : E) return B;\n    function Is_Private_Descendant              (Id : E) return B;\n    function Is_Public                          (Id : E) return B;\n@@ -5351,6 +5378,7 @@ package Einfo is\n    function Original_Access_Type               (Id : E) return E;\n    function Original_Array_Type                (Id : E) return E;\n    function Original_Record_Component          (Id : E) return E;\n+   function Overridden_Operation               (Id : E) return E;\n    function Packed_Array_Type                  (Id : E) return E;\n    function Parent_Subtype                     (Id : E) return E;\n    function Primitive_Operations               (Id : E) return L;\n@@ -5402,6 +5430,8 @@ package Einfo is\n    function Uses_Sec_Stack                     (Id : E) return B;\n    function Vax_Float                          (Id : E) return B;\n    function Warnings_Off                       (Id : E) return B;\n+   function Was_Hidden                         (Id : E) return B;\n+   function Wrapped_Entity                     (Id : E) return E;\n \n    -------------------------------\n    -- Classification Attributes --\n@@ -5792,6 +5822,8 @@ package Einfo is\n    procedure Set_Is_Packed_Array_Type          (Id : E; V : B := True);\n    procedure Set_Is_Potentially_Use_Visible    (Id : E; V : B := True);\n    procedure Set_Is_Preelaborated              (Id : E; V : B := True);\n+   procedure Set_Is_Primitive_Wrapper          (Id : E; V : B := True);\n+\n    procedure Set_Is_Private_Composite          (Id : E; V : B := True);\n    procedure Set_Is_Private_Descendant         (Id : E; V : B := True);\n    procedure Set_Is_Public                     (Id : E; V : B := True);\n@@ -5843,6 +5875,7 @@ package Einfo is\n    procedure Set_Original_Access_Type          (Id : E; V : E);\n    procedure Set_Original_Array_Type           (Id : E; V : E);\n    procedure Set_Original_Record_Component     (Id : E; V : E);\n+   procedure Set_Overridden_Operation          (Id : E; V : E);\n    procedure Set_Packed_Array_Type             (Id : E; V : E);\n    procedure Set_Parent_Subtype                (Id : E; V : E);\n    procedure Set_Primitive_Operations          (Id : E; V : L);\n@@ -5894,6 +5927,8 @@ package Einfo is\n    procedure Set_Uses_Sec_Stack                (Id : E; V : B := True);\n    procedure Set_Vax_Float                     (Id : E; V : B := True);\n    procedure Set_Warnings_Off                  (Id : E; V : B := True);\n+   procedure Set_Was_Hidden                    (Id : E; V : B := True);\n+   procedure Set_Wrapped_Entity                (Id : E; V : E);\n \n    -----------------------------------\n    -- Field Initialization Routines --\n@@ -6360,6 +6395,8 @@ package Einfo is\n    pragma Inline (Is_Packed_Array_Type);\n    pragma Inline (Is_Potentially_Use_Visible);\n    pragma Inline (Is_Preelaborated);\n+   pragma Inline (Is_Primitive_Wrapper);\n+\n    pragma Inline (Is_Private_Composite);\n    pragma Inline (Is_Private_Descendant);\n    pragma Inline (Is_Private_Type);\n@@ -6421,6 +6458,7 @@ package Einfo is\n    pragma Inline (Original_Access_Type);\n    pragma Inline (Original_Array_Type);\n    pragma Inline (Original_Record_Component);\n+   pragma Inline (Overridden_Operation);\n    pragma Inline (Packed_Array_Type);\n    pragma Inline (Parameter_Mode);\n    pragma Inline (Parent_Subtype);\n@@ -6473,6 +6511,8 @@ package Einfo is\n    pragma Inline (Uses_Sec_Stack);\n    pragma Inline (Vax_Float);\n    pragma Inline (Warnings_Off);\n+   pragma Inline (Was_Hidden);\n+   pragma Inline (Wrapped_Entity);\n \n    pragma Inline (Init_Alignment);\n    pragma Inline (Init_Component_Bit_Offset);\n@@ -6692,6 +6732,8 @@ package Einfo is\n    pragma Inline (Set_Is_Packed_Array_Type);\n    pragma Inline (Set_Is_Potentially_Use_Visible);\n    pragma Inline (Set_Is_Preelaborated);\n+   pragma Inline (Set_Is_Primitive_Wrapper);\n+\n    pragma Inline (Set_Is_Private_Composite);\n    pragma Inline (Set_Is_Private_Descendant);\n    pragma Inline (Set_Is_Public);\n@@ -6743,6 +6785,7 @@ package Einfo is\n    pragma Inline (Set_Original_Access_Type);\n    pragma Inline (Set_Original_Array_Type);\n    pragma Inline (Set_Original_Record_Component);\n+   pragma Inline (Set_Overridden_Operation);\n    pragma Inline (Set_Packed_Array_Type);\n    pragma Inline (Set_Parent_Subtype);\n    pragma Inline (Set_Primitive_Operations);\n@@ -6794,6 +6837,8 @@ package Einfo is\n    pragma Inline (Set_Uses_Sec_Stack);\n    pragma Inline (Set_Vax_Float);\n    pragma Inline (Set_Warnings_Off);\n+   pragma Inline (Set_Was_Hidden);\n+   pragma Inline (Set_Wrapped_Entity);\n \n    --  END XEINFO INLINES\n "}, {"sha": "4b829214bf759884803553efb9ae29232a616159", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 119, "deletions": 29, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -27,7 +27,6 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n-with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch4;  use Exp_Ch4;\n@@ -867,8 +866,8 @@ package body Exp_Ch3 is\n          Parameter_List := Build_Discriminant_Formals (Rec_Id, False);\n \n          Set_Parameter_Specifications (Spec_Node, Parameter_List);\n-         Set_Subtype_Mark (Spec_Node,\n-                           New_Reference_To (Standard_Boolean,  Loc));\n+         Set_Result_Definition (Spec_Node,\n+                                New_Reference_To (Standard_Boolean,  Loc));\n          Set_Specification (Body_Node, Spec_Node);\n          Set_Declarations (Body_Node, New_List);\n \n@@ -1482,16 +1481,21 @@ package body Exp_Ch3 is\n                 Attribute_Name => Name_Unrestricted_Access);\n          end if;\n \n-         --  Ada 2005 (AI-231): Generate conversion to the null-excluding\n-         --  type to force the corresponding run-time check.\n+         --  Ada 2005 (AI-231): Add the run-time check if required\n \n          if Ada_Version >= Ada_05\n-           and then Can_Never_Be_Null (Etype (Id))  -- Lhs\n-           and then Present (Etype (Exp))\n-           and then not Can_Never_Be_Null (Etype (Exp))\n+           and then Can_Never_Be_Null (Etype (Id))            -- Lhs\n          then\n-            Rewrite (Exp, Convert_To (Etype (Id), Relocate_Node (Exp)));\n-            Analyze_And_Resolve (Exp, Etype (Id));\n+            if Nkind (Exp) = N_Null then\n+               return New_List (\n+                 Make_Raise_Constraint_Error (Sloc (Exp),\n+                   Reason => CE_Null_Not_Allowed));\n+\n+            elsif Present (Etype (Exp))\n+              and then not Can_Never_Be_Null (Etype (Exp))\n+            then\n+               Install_Null_Excluding_Check (Exp);\n+            end if;\n          end if;\n \n          --  Take a copy of Exp to ensure that later copies of this\n@@ -3017,7 +3021,7 @@ package body Exp_Ch3 is\n             Make_Function_Specification (Loc,\n               Defining_Unit_Name       => F,\n               Parameter_Specifications => Pspecs,\n-              Subtype_Mark => New_Reference_To (Standard_Boolean, Loc)),\n+              Result_Definition => New_Reference_To (Standard_Boolean, Loc)),\n           Declarations               => New_List,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n@@ -3698,19 +3702,6 @@ package body Exp_Ch3 is\n \n             elsif Is_Access_Type (Typ) then\n \n-               --  Ada 2005 (AI-231): Generate conversion to the null-excluding\n-               --  type to force the corresponding run-time check\n-\n-               if Ada_Version >= Ada_05\n-                 and then (Can_Never_Be_Null (Def_Id)\n-                             or else Can_Never_Be_Null (Typ))\n-               then\n-                  Rewrite\n-                    (Expr_Q,\n-                     Convert_To (Etype (Def_Id), Relocate_Node (Expr_Q)));\n-                  Analyze_And_Resolve (Expr_Q, Etype (Def_Id));\n-               end if;\n-\n                --  For access types set the Is_Known_Non_Null flag if the\n                --  initializing value is known to be non-null. We can also set\n                --  Can_Never_Be_Null if this is a constant.\n@@ -4362,7 +4353,7 @@ package body Exp_Ch3 is\n                     Make_Defining_Identifier (Loc, Name_uF),\n                   Parameter_Type => New_Reference_To (Standard_Boolean, Loc))),\n \n-              Subtype_Mark => New_Reference_To (Standard_Integer, Loc)),\n+              Result_Definition => New_Reference_To (Standard_Integer, Loc)),\n \n             Declarations => Empty_List,\n \n@@ -4392,10 +4383,10 @@ package body Exp_Ch3 is\n    ------------------------\n \n    procedure Freeze_Record_Type (N : Node_Id) is\n-      Def_Id      : constant Node_Id := Entity (N);\n       Comp        : Entity_Id;\n-      Type_Decl   : constant Node_Id := Parent (Def_Id);\n+      Def_Id      : constant Node_Id := Entity (N);\n       Predef_List : List_Id;\n+      Type_Decl   : constant Node_Id := Parent (Def_Id);\n \n       Renamed_Eq  : Node_Id := Empty;\n       --  Could use some comments ???\n@@ -4534,6 +4525,7 @@ package body Exp_Ch3 is\n             Make_Predefined_Primitive_Specs\n               (Def_Id, Predef_List, Renamed_Eq);\n             Insert_List_Before_And_Analyze (N, Predef_List);\n+\n             Set_Is_Frozen (Def_Id, True);\n             Set_All_DT_Position (Def_Id);\n \n@@ -4623,6 +4615,8 @@ package body Exp_Ch3 is\n \n             Append_Freeze_Actions\n               (Def_Id, Predefined_Primitive_Freeze (Def_Id));\n+            Append_Freeze_Actions\n+              (Def_Id, Init_Predefined_Interface_Primitives (Def_Id));\n          end if;\n \n       --  In the non-tagged case, an equality function is provided only for\n@@ -4696,8 +4690,20 @@ package body Exp_Ch3 is\n       if Is_Tagged_Type (Def_Id) then\n          Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n          Append_Freeze_Actions (Def_Id, Predef_List);\n-      end if;\n \n+         --  Populate the two auxiliary tables used for dispatching\n+         --  asynchronous, conditional and timed selects for tagged\n+         --  types that implement a limited interface.\n+\n+         if Ada_Version >= Ada_05\n+           and then not Is_Interface  (Def_Id)\n+           and then not Is_Abstract   (Def_Id)\n+           and then not Is_Controlled (Def_Id)\n+           and then Implements_Limited_Interface (Def_Id)\n+         then\n+            Append_Freeze_Actions (Def_Id, Make_Disp_Select_Tables (Def_Id));\n+         end if;\n+      end if;\n    end Freeze_Record_Type;\n \n    ------------------------------\n@@ -5887,6 +5893,67 @@ package body Exp_Ch3 is\n                Parameter_Type      => New_Reference_To (Tag_Typ, Loc)))));\n       end if;\n \n+      --  Generate the declarations for the following primitive operations:\n+      --    disp_asynchronous_select\n+      --    disp_conditional_select\n+      --    disp_get_prim_op_kind\n+      --    disp_timed_select\n+      --  for limited interfaces and tagged types that implement a limited\n+      --  interface.\n+\n+      if Ada_Version >= Ada_05\n+        and then\n+            ((Is_Interface (Tag_Typ)\n+                and then Is_Limited_Record (Tag_Typ))\n+          or else\n+             (not Is_Abstract (Tag_Typ)\n+                and then not Is_Controlled (Tag_Typ)\n+                and then Implements_Limited_Interface (Tag_Typ)))\n+      then\n+         if Is_Interface (Tag_Typ) then\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Asynchronous_Select_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Conditional_Select_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Get_Prim_Op_Kind_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Timed_Select_Spec (Tag_Typ)));\n+\n+         else\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Asynchronous_Select_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Conditional_Select_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Get_Prim_Op_Kind_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Timed_Select_Spec (Tag_Typ)));\n+         end if;\n+      end if;\n+\n       --  Specs for finalization actions that may be required in case a\n       --  future extension contain a controlled element. We generate those\n       --  only for root tagged types where they will get dummy bodies or\n@@ -6059,7 +6126,7 @@ package body Exp_Ch3 is\n            Make_Function_Specification (Loc,\n              Defining_Unit_Name       => Id,\n              Parameter_Specifications => Profile,\n-             Subtype_Mark             =>\n+             Result_Definition        =>\n                New_Reference_To (Ret_Type, Loc));\n       end if;\n \n@@ -6242,6 +6309,29 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n+      --  Generate the bodies for the following primitive operations:\n+      --    disp_asynchronous_select\n+      --    disp_conditional_select\n+      --    disp_get_prim_op_kind\n+      --    disp_timed_select\n+      --  for tagged types that implement a limited interface.\n+\n+      if Ada_Version >= Ada_05\n+        and then not Is_Interface  (Tag_Typ)\n+        and then not Is_Abstract   (Tag_Typ)\n+        and then not Is_Controlled (Tag_Typ)\n+        and then Implements_Limited_Interface (Tag_Typ)\n+      then\n+         Append_To (Res,\n+           Make_Disp_Asynchronous_Select_Body (Tag_Typ));\n+         Append_To (Res,\n+           Make_Disp_Conditional_Select_Body  (Tag_Typ));\n+         Append_To (Res,\n+           Make_Disp_Get_Prim_Op_Kind_Body    (Tag_Typ));\n+         Append_To (Res,\n+           Make_Disp_Timed_Select_Body        (Tag_Typ));\n+      end if;\n+\n       if not Is_Limited_Type (Tag_Typ) then\n \n          --  Body for equality"}, {"sha": "f7d01197b7c43d0820899fe73fec6ecf55c19156", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -1560,19 +1560,6 @@ package body Exp_Ch7 is\n       end if;\n \n       Set_Elaboration_Flag (N, Corresponding_Spec (N));\n-\n-      --  Generate a subprogram descriptor for the elaboration routine of\n-      --  a package body if the package body has no pending instantiations\n-      --  and it has generated at least one exception handler\n-\n-      if Present (Handler_Records (Body_Entity (Ent)))\n-        and then Is_Compilation_Unit (Ent)\n-        and then not Delay_Subprogram_Descriptors (Body_Entity (Ent))\n-      then\n-         Generate_Subprogram_Descriptor_For_Package\n-           (N, Body_Entity (Ent));\n-      end if;\n-\n       Set_In_Package_Body (Ent, False);\n \n       --  Set to encode entity names in package body before gigi is called\n@@ -2220,6 +2207,8 @@ package body Exp_Ch7 is\n               or else Has_Interrupt_Handler (Pid)\n               or else (Has_Attach_Handler (Pid)\n                          and then not Restricted_Profile)\n+              or else (Ada_Version >= Ada_05\n+                         and then Present (Interface_List (Parent (Pid))))\n             then\n                if Abort_Allowed\n                  or else Restriction_Active (No_Entry_Queue) = False"}, {"sha": "6911d862a594941acf8daec5204b19d79c9054cb", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2078, "deletions": 455, "changes": 2533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=10b93b2ef042757e76a53294442789b22c39599e"}, {"sha": "044f56d4543336be2819f88d72e747bcf3159f48", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,6 +30,13 @@ with Types; use Types;\n \n package Exp_Ch9 is\n \n+   type Subprogram_Protection_Mode is\n+     (Dispatching_Mode,\n+      Protected_Mode,\n+      Unprotected_Mode);\n+   --  This type is used to distinguish the different protection modes of a\n+   --  protected subprogram.\n+\n    procedure Add_Discriminal_Declarations\n      (Decls : List_Id;\n       Typ   : Entity_Id;\n@@ -102,10 +109,9 @@ package Exp_Ch9 is\n    --  declarative part.\n \n    function Build_Protected_Sub_Specification\n-     (N           : Node_Id;\n-      Prottyp     : Entity_Id;\n-      Unprotected : Boolean := False)\n-      return        Node_Id;\n+     (N       : Node_Id;\n+      Prottyp : Entity_Id;\n+      Mode    : Subprogram_Protection_Mode) return Node_Id;\n    --  Build specification for protected subprogram. This is called when\n    --  expanding a protected type, and also when expanding the declaration for\n    --  an Access_To_Protected_Subprogram type. In the latter case, Prottyp is\n@@ -214,7 +220,7 @@ package Exp_Ch9 is\n    --  routine to make sure Complete_Master is called on exit).\n \n    procedure Expand_Access_Protected_Subprogram_Type (N : Node_Id);\n-   --  Build Equivalent_Type for an Access_to_protected_Subprogram.\n+   --  Build Equivalent_Type for an Access_to_protected_Subprogram\n \n    procedure Expand_Accept_Declarations (N : Node_Id; Ent : Entity_Id);\n    --  Expand declarations required for accept statement. See bodies of"}, {"sha": "524d6deaf1992c033cb3ed9556702568747dba6d", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1662, "deletions": 218, "changes": 1880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -49,29 +49,288 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n-with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n \n package body Exp_Disp is\n \n+   --------------------------------\n+   -- Select_Expansion_Utilities --\n+   --------------------------------\n+\n+   --  The following package contains helper routines used in the expansion of\n+   --  dispatching asynchronous, conditional and timed selects.\n+\n+   package Select_Expansion_Utilities is\n+      procedure Build_B\n+        (Loc    : Source_Ptr;\n+         Params : List_Id);\n+      --  Generate:\n+      --    B : out Communication_Block\n+\n+      procedure Build_C\n+        (Loc    : Source_Ptr;\n+         Params : List_Id);\n+      --  Generate:\n+      --    C : out Prim_Op_Kind\n+\n+      procedure Build_Common_Dispatching_Select_Statements\n+        (Loc   : Source_Ptr;\n+         Typ   : Entity_Id;\n+         Stmts : List_Id);\n+      --  Ada 2005 (AI-345): Generate statements that are common between\n+      --  asynchronous, conditional and timed select expansion.\n+\n+      procedure Build_F\n+        (Loc    : Source_Ptr;\n+         Params : List_Id);\n+      --  Generate:\n+      --    F : out Boolean\n+\n+      procedure Build_P\n+        (Loc    : Source_Ptr;\n+         Params : List_Id);\n+      --  Generate:\n+      --    P : Address\n+\n+      procedure Build_S\n+        (Loc    : Source_Ptr;\n+         Params : List_Id);\n+      --  Generate:\n+      --    S : Integer\n+\n+      procedure Build_T\n+        (Loc    : Source_Ptr;\n+         Typ    : Entity_Id;\n+         Params : List_Id);\n+      --  Generate:\n+      --    T : in out Typ\n+   end Select_Expansion_Utilities;\n+\n+   package body Select_Expansion_Utilities is\n+\n+      -------------\n+      -- Build_B --\n+      -------------\n+\n+      procedure Build_B\n+        (Loc    : Source_Ptr;\n+         Params : List_Id)\n+      is\n+      begin\n+         Append_To (Params,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uB),\n+             Parameter_Type =>\n+               New_Reference_To (RTE (RE_Communication_Block), Loc),\n+             Out_Present => True));\n+      end Build_B;\n+\n+      -------------\n+      -- Build_C --\n+      -------------\n+\n+      procedure Build_C\n+        (Loc    : Source_Ptr;\n+         Params : List_Id)\n+      is\n+      begin\n+         Append_To (Params,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uC),\n+             Parameter_Type =>\n+               New_Reference_To (RTE (RE_Prim_Op_Kind), Loc),\n+             Out_Present => True));\n+      end Build_C;\n+\n+      ------------------------------------------------\n+      -- Build_Common_Dispatching_Select_Statements --\n+      ------------------------------------------------\n+\n+      procedure Build_Common_Dispatching_Select_Statements\n+        (Loc   : Source_Ptr;\n+         Typ   : Entity_Id;\n+         Stmts : List_Id)\n+      is\n+         DT_Ptr     : Entity_Id;\n+         DT_Ptr_Typ : Entity_Id := Typ;\n+\n+      begin\n+         --  Typ may be a derived type, climb the derivation chain in order to\n+         --  find the root.\n+\n+         while Present (Parent_Subtype (DT_Ptr_Typ)) loop\n+            DT_Ptr_Typ := Parent_Subtype (DT_Ptr_Typ);\n+         end loop;\n+\n+         DT_Ptr := Node (First_Elmt (Access_Disp_Table (DT_Ptr_Typ)));\n+\n+         --  Generate:\n+         --    C := get_prim_op_kind (tag! (<type>VP), S);\n+\n+         --  where C is the out parameter capturing the call kind and S is the\n+         --  dispatch table slot number.\n+\n+         Append_To (Stmts,\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               Make_Identifier (Loc, Name_uC),\n+             Expression =>\n+               Make_DT_Access_Action (Typ,\n+                 Action =>\n+                   Get_Prim_Op_Kind,\n+                 Args =>\n+                   New_List (\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (DT_Ptr, Loc)),\n+                     Make_Identifier (Loc, Name_uS)))));\n+\n+         --  Generate:\n+         --    if C = POK_Procedure\n+         --      or else C = POK_Protected_Procedure\n+         --      or else C = POK_Task_Procedure;\n+         --    then\n+         --       F := True;\n+         --       return;\n+\n+         --  where F is the out parameter capturing the status of a potential\n+         --  entry call.\n+\n+         Append_To (Stmts,\n+           Make_If_Statement (Loc,\n+\n+             Condition =>\n+               Make_Or_Else (Loc,\n+                 Left_Opnd =>\n+                   Make_Op_Eq (Loc,\n+                     Left_Opnd =>\n+                       Make_Identifier (Loc, Name_uC),\n+                     Right_Opnd =>\n+                       New_Reference_To (RTE (RE_POK_Procedure), Loc)),\n+                 Right_Opnd =>\n+                   Make_Or_Else (Loc,\n+                     Left_Opnd =>\n+                       Make_Op_Eq (Loc,\n+                         Left_Opnd =>\n+                           Make_Identifier (Loc, Name_uC),\n+                         Right_Opnd =>\n+                           New_Reference_To (RTE (\n+                             RE_POK_Protected_Procedure), Loc)),\n+                     Right_Opnd =>\n+                       Make_Op_Eq (Loc,\n+                         Left_Opnd =>\n+                           Make_Identifier (Loc, Name_uC),\n+                         Right_Opnd =>\n+                           New_Reference_To (RTE (\n+                             RE_POK_Task_Procedure), Loc)))),\n+\n+             Then_Statements =>\n+               New_List (\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => Make_Identifier (Loc, Name_uF),\n+                   Expression => New_Reference_To (Standard_True, Loc)),\n+\n+                 Make_Return_Statement (Loc))));\n+      end Build_Common_Dispatching_Select_Statements;\n+\n+      -------------\n+      -- Build_F --\n+      -------------\n+\n+      procedure Build_F\n+        (Loc    : Source_Ptr;\n+         Params : List_Id)\n+      is\n+      begin\n+         Append_To (Params,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uF),\n+             Parameter_Type =>\n+               New_Reference_To (Standard_Boolean, Loc),\n+             Out_Present => True));\n+      end Build_F;\n+\n+      -------------\n+      -- Build_P --\n+      -------------\n+\n+      procedure Build_P\n+        (Loc    : Source_Ptr;\n+         Params : List_Id)\n+      is\n+      begin\n+         Append_To (Params,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uP),\n+             Parameter_Type =>\n+               New_Reference_To (RTE (RE_Address), Loc)));\n+      end Build_P;\n+\n+      -------------\n+      -- Build_S --\n+      -------------\n+\n+      procedure Build_S\n+        (Loc    : Source_Ptr;\n+         Params : List_Id)\n+      is\n+      begin\n+         Append_To (Params,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uS),\n+             Parameter_Type =>\n+               New_Reference_To (Standard_Integer, Loc)));\n+      end Build_S;\n+\n+      -------------\n+      -- Build_T --\n+      -------------\n+\n+      procedure Build_T\n+        (Loc    : Source_Ptr;\n+         Typ    : Entity_Id;\n+         Params : List_Id)\n+      is\n+      begin\n+         Append_To (Params,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uT),\n+             Parameter_Type =>\n+               New_Reference_To (Typ, Loc),\n+             In_Present  => True,\n+             Out_Present => True));\n+      end Build_T;\n+   end Select_Expansion_Utilities;\n+\n+   package SEU renames Select_Expansion_Utilities;\n+\n    Ada_Actions : constant array (DT_Access_Action) of RE_Id :=\n       (CW_Membership           => RE_CW_Membership,\n        IW_Membership           => RE_IW_Membership,\n        DT_Entry_Size           => RE_DT_Entry_Size,\n        DT_Prologue_Size        => RE_DT_Prologue_Size,\n        Get_Access_Level        => RE_Get_Access_Level,\n+       Get_Entry_Index         => RE_Get_Entry_Index,\n        Get_External_Tag        => RE_Get_External_Tag,\n        Get_Prim_Op_Address     => RE_Get_Prim_Op_Address,\n+       Get_Prim_Op_Kind        => RE_Get_Prim_Op_Kind,\n        Get_RC_Offset           => RE_Get_RC_Offset,\n        Get_Remotely_Callable   => RE_Get_Remotely_Callable,\n        Inherit_DT              => RE_Inherit_DT,\n        Inherit_TSD             => RE_Inherit_TSD,\n        Register_Interface_Tag  => RE_Register_Interface_Tag,\n        Register_Tag            => RE_Register_Tag,\n        Set_Access_Level        => RE_Set_Access_Level,\n+       Set_Entry_Index         => RE_Set_Entry_Index,\n        Set_Expanded_Name       => RE_Set_Expanded_Name,\n        Set_External_Tag        => RE_Set_External_Tag,\n        Set_Prim_Op_Address     => RE_Set_Prim_Op_Address,\n+       Set_Prim_Op_Kind        => RE_Set_Prim_Op_Kind,\n        Set_RC_Offset           => RE_Set_RC_Offset,\n        Set_Remotely_Callable   => RE_Set_Remotely_Callable,\n        Set_TSD                 => RE_Set_TSD,\n@@ -84,18 +343,22 @@ package body Exp_Disp is\n        DT_Entry_Size           => False,\n        DT_Prologue_Size        => False,\n        Get_Access_Level        => False,\n+       Get_Entry_Index         => False,\n        Get_External_Tag        => False,\n        Get_Prim_Op_Address     => False,\n+       Get_Prim_Op_Kind        => False,\n        Get_Remotely_Callable   => False,\n        Get_RC_Offset           => False,\n        Inherit_DT              => True,\n        Inherit_TSD             => True,\n        Register_Interface_Tag  => True,\n        Register_Tag            => True,\n        Set_Access_Level        => True,\n+       Set_Entry_Index         => True,\n        Set_Expanded_Name       => True,\n        Set_External_Tag        => True,\n        Set_Prim_Op_Address     => True,\n+       Set_Prim_Op_Kind        => True,\n        Set_RC_Offset           => True,\n        Set_Remotely_Callable   => True,\n        Set_TSD                 => True,\n@@ -108,30 +371,28 @@ package body Exp_Disp is\n        DT_Entry_Size           => 0,\n        DT_Prologue_Size        => 0,\n        Get_Access_Level        => 1,\n+       Get_Entry_Index         => 2,\n        Get_External_Tag        => 1,\n        Get_Prim_Op_Address     => 2,\n+       Get_Prim_Op_Kind        => 2,\n        Get_RC_Offset           => 1,\n        Get_Remotely_Callable   => 1,\n        Inherit_DT              => 3,\n        Inherit_TSD             => 2,\n        Register_Interface_Tag  => 2,\n        Register_Tag            => 1,\n        Set_Access_Level        => 2,\n+       Set_Entry_Index         => 3,\n        Set_Expanded_Name       => 2,\n        Set_External_Tag        => 2,\n        Set_Prim_Op_Address     => 3,\n+       Set_Prim_Op_Kind        => 3,\n        Set_RC_Offset           => 2,\n        Set_Remotely_Callable   => 2,\n        Set_TSD                 => 2,\n        TSD_Entry_Size          => 0,\n        TSD_Prologue_Size       => 0);\n \n-   function Build_Anonymous_Access_Type\n-     (Directly_Designated_Type : Entity_Id;\n-      Related_Nod              : Node_Id) return Entity_Id;\n-   --  Returns a decorated entity corresponding with an anonymous access type.\n-   --  Used to generate unchecked type conversion of an address.\n-\n    procedure Collect_All_Interfaces (T : Entity_Id);\n    --  Ada 2005 (AI-251): Collect the whole list of interfaces that are\n    --  directly or indirectly implemented by T. Used to compute the size\n@@ -145,29 +406,12 @@ package body Exp_Disp is\n    --  Check if the type has a private view or if the public view appears\n    --  in the visible part of a package spec.\n \n-   ----------------------------------\n-   --  Build_Anonymous_Access_Type --\n-   ----------------------------------\n-\n-   function Build_Anonymous_Access_Type\n-     (Directly_Designated_Type : Entity_Id;\n-      Related_Nod              : Node_Id) return Entity_Id\n-   is\n-      New_E : Entity_Id;\n-\n-   begin\n-      New_E := Create_Itype (Ekind       => E_Anonymous_Access_Type,\n-                             Related_Nod => Related_Nod,\n-                             Scope_Id    => Current_Scope);\n-\n-      Set_Etype                    (New_E, New_E);\n-      Init_Size_Align              (New_E);\n-      Init_Size                    (New_E, System_Address_Size);\n-      Set_Directly_Designated_Type (New_E, Directly_Designated_Type);\n-      Set_Is_First_Subtype         (New_E);\n-\n-      return New_E;\n-   end Build_Anonymous_Access_Type;\n+   function Prim_Op_Kind\n+     (Prim : Entity_Id;\n+      Typ  : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Determine the primitive operation kind of Prim\n+   --  according to its type Typ. Return a reference to an RTE Prim_Op_Kind\n+   --  enumeration value.\n \n    ----------------------------\n    -- Collect_All_Interfaces --\n@@ -187,9 +431,10 @@ package body Exp_Disp is\n       -------------------\n \n       procedure Add_Interface (Iface : Entity_Id) is\n-         Elmt  : Elmt_Id := First_Elmt (Abstract_Interfaces (T));\n+         Elmt : Elmt_Id;\n \n       begin\n+         Elmt := First_Elmt (Abstract_Interfaces (T));\n          while Present (Elmt) and then Node (Elmt) /= Iface loop\n             Next_Elmt (Elmt);\n          end loop;\n@@ -238,9 +483,7 @@ package body Exp_Disp is\n \n          if Is_Non_Empty_List (Interface_List (Nod)) then\n             Id := First (Interface_List (Nod));\n-\n             while Present (Id) loop\n-\n                Iface := Etype (Id);\n \n                if Is_Interface (Iface) then\n@@ -309,6 +552,18 @@ package body Exp_Disp is\n       elsif TSS_Name = TSS_Deep_Finalize then\n          return Uint_10;\n \n+      elsif Chars (E) = Name_uDisp_Asynchronous_Select then\n+         return Uint_11;\n+\n+      elsif Chars (E) = Name_uDisp_Conditional_Select then\n+         return Uint_12;\n+\n+      elsif Chars (E) = Name_uDisp_Get_Prim_Op_Kind then\n+         return Uint_13;\n+\n+      elsif Chars (E) = Name_uDisp_Timed_Select then\n+         return Uint_14;\n+\n       else\n          raise Program_Error;\n       end if;\n@@ -373,9 +628,10 @@ package body Exp_Disp is\n \n          else\n             declare\n-               Formal : Entity_Id := First_Formal (Subp);\n+               Formal : Entity_Id;\n \n             begin\n+               Formal := First_Formal (Subp);\n                while Present (Formal) loop\n                   if Is_Controlling_Formal (Formal) then\n                      if Is_Access_Type (Etype (Formal)) then\n@@ -441,6 +697,10 @@ package body Exp_Disp is\n \n       Typ := Root_Type (CW_Typ);\n \n+      if Ekind (Typ) = E_Incomplete_Type then\n+         Typ := Non_Limited_View (Typ);\n+      end if;\n+\n       if not Is_Limited_Type (Typ) then\n          Eq_Prim_Op := Find_Prim_Op (Typ, Name_Op_Eq);\n       end if;\n@@ -744,41 +1004,144 @@ package body Exp_Disp is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Operand     : constant Node_Id    := Expression (N);\n       Operand_Typ : Entity_Id           := Etype (Operand);\n-      Target_Type : Entity_Id           := Etype (N);\n+      Iface_Typ   : Entity_Id           := Etype (N);\n       Iface_Tag   : Entity_Id;\n+      Fent        : Entity_Id;\n+      Func        : Node_Id;\n+      P           : Node_Id;\n+      Null_Op_Nod : Node_Id;\n \n    begin\n       pragma Assert (Nkind (Operand) /= N_Attribute_Reference);\n \n-      --  Ada 2005 (AI-345): Set Operand_Typ and Handle task interfaces\n+      --  Ada 2005 (AI-345): Handle task interfaces\n \n       if Ekind (Operand_Typ) = E_Task_Type\n         or else Ekind (Operand_Typ) = E_Protected_Type\n       then\n          Operand_Typ := Corresponding_Record_Type (Operand_Typ);\n       end if;\n \n-      if Is_Access_Type (Target_Type) then\n-         Target_Type := Etype (Directly_Designated_Type (Target_Type));\n+      --  Handle access types to interfaces\n \n-      elsif Is_Class_Wide_Type (Target_Type) then\n-         Target_Type := Etype (Target_Type);\n+      if Is_Access_Type (Iface_Typ) then\n+         Iface_Typ := Etype (Directly_Designated_Type (Iface_Typ));\n       end if;\n \n-      pragma Assert (not Is_Class_Wide_Type (Target_Type)\n-        and then Is_Interface (Target_Type));\n+      --  Handle class-wide interface types. This conversion can appear\n+      --  explicitly in the source code. Example: I'Class (Obj)\n \n-      Iface_Tag := Find_Interface_Tag (Operand_Typ, Target_Type);\n+      if Is_Class_Wide_Type (Iface_Typ) then\n+         Iface_Typ := Etype (Iface_Typ);\n+      end if;\n+\n+      pragma Assert (not Is_Class_Wide_Type (Iface_Typ)\n+        and then Is_Interface (Iface_Typ));\n \n+      Iface_Tag := Find_Interface_Tag (Operand_Typ, Iface_Typ);\n       pragma Assert (Iface_Tag /= Empty);\n \n-      Rewrite (N,\n-        Unchecked_Convert_To (Etype (N),\n-          Make_Attribute_Reference (Loc,\n-            Prefix => Make_Selected_Component (Loc,\n-                        Prefix => Relocate_Node (Expression (N)),\n-                        Selector_Name => New_Occurrence_Of (Iface_Tag, Loc)),\n-            Attribute_Name => Name_Address)));\n+      --  Keep separate access types to interfaces because one internal\n+      --  function is used to handle the null value (see following comment)\n+\n+      if not Is_Access_Type (Etype (N)) then\n+         Rewrite (N,\n+           Unchecked_Convert_To (Etype (N),\n+             Make_Selected_Component (Loc,\n+               Prefix => Relocate_Node (Expression (N)),\n+               Selector_Name =>\n+                 New_Occurrence_Of (Iface_Tag, Loc))));\n+\n+      else\n+         --  Build internal function to handle the case in which the\n+         --  actual is null. If the actual is null returns null because\n+         --  no displacement is required; otherwise performs a type\n+         --  conversion that will be expanded in the code that returns\n+         --  the value of the displaced actual. That is:\n+\n+         --     function Func (O : Operand_Typ) return Iface_Typ is\n+         --     begin\n+         --        if O = null then\n+         --           return null;\n+         --        else\n+         --           return Iface_Typ!(O);\n+         --        end if;\n+         --     end Func;\n+\n+         Fent :=\n+           Make_Defining_Identifier (Loc, New_Internal_Name ('F'));\n+\n+         --  Decorate the \"null\" in the if-statement condition\n+\n+         Null_Op_Nod := Make_Null (Loc);\n+         Set_Etype (Null_Op_Nod, Etype (Operand));\n+         Set_Analyzed (Null_Op_Nod);\n+\n+         Func :=\n+           Make_Subprogram_Body (Loc,\n+             Specification =>\n+               Make_Function_Specification (Loc,\n+                 Defining_Unit_Name       => Fent,\n+\n+                 Parameter_Specifications => New_List (\n+                   Make_Parameter_Specification (Loc,\n+                     Defining_Identifier =>\n+                       Make_Defining_Identifier (Loc, Name_uO),\n+                     Parameter_Type =>\n+                       New_Reference_To (Etype (Operand), Loc))),\n+                 Result_Definition =>\n+                   New_Reference_To (Etype (N), Loc)),\n+\n+             Declarations => Empty_List,\n+\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Make_If_Statement (Loc,\n+                     Condition       =>\n+                       Make_Op_Eq (Loc,\n+                          Left_Opnd  => Make_Identifier (Loc, Name_uO),\n+                          Right_Opnd => Null_Op_Nod),\n+                     Then_Statements => New_List (\n+                       Make_Return_Statement (Loc,\n+                         Make_Null (Loc))),\n+                     Else_Statements => New_List (\n+                       Make_Return_Statement (Loc,\n+                         Unchecked_Convert_To (Etype (N),\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix =>\n+                                Make_Selected_Component (Loc,\n+                                  Prefix => Relocate_Node (Expression (N)),\n+                                  Selector_Name =>\n+                                    New_Occurrence_Of (Iface_Tag, Loc)),\n+                              Attribute_Name => Name_Address))))))));\n+\n+         --  Insert the new declaration in the nearest enclosing scope\n+         --  that has declarations.\n+\n+         P := N;\n+         while not Has_Declarations (Parent (P)) loop\n+            P := Parent (P);\n+         end loop;\n+\n+         if Is_List_Member (P) then\n+            Insert_Before (P, Func);\n+\n+         elsif Nkind (Parent (P)) = N_Package_Specification then\n+            Append_To (Visible_Declarations (Parent (P)), Func);\n+\n+         else\n+            Append_To (Declarations (Parent (P)), Func);\n+         end if;\n+\n+         Analyze (Func);\n+\n+         Rewrite (N,\n+           Make_Function_Call (Loc,\n+             Name => New_Reference_To (Fent, Loc),\n+             Parameter_Associations => New_List (\n+               Relocate_Node (Expression (N)))));\n+      end if;\n \n       Analyze (N);\n    end Expand_Interface_Conversion;\n@@ -790,12 +1153,16 @@ package body Exp_Disp is\n    procedure Expand_Interface_Actuals (Call_Node : Node_Id) is\n       Loc        : constant Source_Ptr := Sloc (Call_Node);\n       Actual     : Node_Id;\n+      Actual_Dup : Node_Id;\n       Actual_Typ : Entity_Id;\n+      Anon       : Entity_Id;\n       Conversion : Node_Id;\n       Formal     : Entity_Id;\n       Formal_Typ : Entity_Id;\n       Subp       : Entity_Id;\n       Nam        : Name_Id;\n+      Formal_DDT : Entity_Id;\n+      Actual_DDT : Entity_Id;\n \n    begin\n       --  This subprogram is called directly from the semantics, so we need a\n@@ -818,75 +1185,156 @@ package body Exp_Disp is\n \n       Formal := First_Formal (Subp);\n       Actual := First_Actual (Call_Node);\n-\n       while Present (Formal) loop\n \n-         pragma Assert (Ekind (Etype (Etype (Formal)))\n-                        /= E_Record_Type_With_Private);\n-\n          --  Ada 2005 (AI-251): Conversion to interface to force \"this\"\n-         --  displacement\n+         --  displacement.\n \n          Formal_Typ := Etype (Etype (Formal));\n+\n+         if Ekind (Formal_Typ) = E_Record_Type_With_Private then\n+            Formal_Typ := Full_View (Formal_Typ);\n+         end if;\n+\n+         if Is_Access_Type (Formal_Typ) then\n+            Formal_DDT := Directly_Designated_Type (Formal_Typ);\n+         end if;\n+\n          Actual_Typ := Etype (Actual);\n \n+         if Is_Access_Type (Actual_Typ) then\n+            Actual_DDT := Directly_Designated_Type (Actual_Typ);\n+         end if;\n+\n          if Is_Interface (Formal_Typ) then\n \n-            Conversion := Convert_To (Formal_Typ, New_Copy_Tree (Actual));\n-            Rewrite             (Actual, Conversion);\n-            Analyze_And_Resolve (Actual, Formal_Typ);\n+            --  No need to displace the pointer if the type of the actual\n+            --  is class-wide of the formal-type interface; in this case the\n+            --  displacement of the pointer was already done at the point of\n+            --  the call to the enclosing subprogram. This case corresponds\n+            --  with the call to P (Obj) in the following example:\n \n-            Rewrite (Actual,\n-              Make_Explicit_Dereference (Loc,\n-                Unchecked_Convert_To\n-                  (Build_Anonymous_Access_Type (Formal_Typ, Call_Node),\n-                   Relocate_Node (Expression (Actual)))));\n+            --     type I is interface;\n+            --     procedure P (X : I) is abstract;\n+\n+            --     procedure General_Op (Obj : I'Class) is\n+            --     begin\n+            --        P (Obj);\n+            --     end General_Op;\n+\n+            if Is_Class_Wide_Type (Actual_Typ)\n+              and then Etype (Actual_Typ) = Formal_Typ\n+            then\n+               null;\n+\n+            --  No need to displace the pointer if the type of the actual is a\n+            --  derivation of the formal-type interface because in this case\n+            --  the interface primitives are located in the primary dispatch\n+            --  table.\n \n-            Analyze_And_Resolve (Actual, Formal_Typ);\n+            elsif Is_Ancestor (Formal_Typ, Actual_Typ) then\n+               null;\n+\n+            else\n+               Conversion := Convert_To (Formal_Typ, Relocate_Node (Actual));\n+               Rewrite             (Actual, Conversion);\n+               Analyze_And_Resolve (Actual, Formal_Typ);\n+            end if;\n \n          --  Anonymous access type\n \n          elsif Is_Access_Type (Formal_Typ)\n-           and then Is_Interface (Etype\n-                                  (Directly_Designated_Type\n-                                   (Formal_Typ)))\n+           and then Is_Interface (Etype (Formal_DDT))\n            and then Interface_Present_In_Ancestor\n-                      (Typ   => Etype (Directly_Designated_Type\n-                                        (Actual_Typ)),\n-                       Iface => Etype (Directly_Designated_Type\n-                                        (Formal_Typ)))\n+                      (Typ   => Actual_DDT,\n+                       Iface => Etype (Formal_DDT))\n          then\n-\n             if Nkind (Actual) = N_Attribute_Reference\n               and then\n                (Attribute_Name (Actual) = Name_Access\n                  or else Attribute_Name (Actual) = Name_Unchecked_Access)\n             then\n                Nam := Attribute_Name (Actual);\n \n-               Conversion :=\n-                 Convert_To\n-                   (Etype (Directly_Designated_Type (Formal_Typ)),\n-                    Prefix (Actual));\n+               Conversion := Convert_To (Etype (Formal_DDT), Prefix (Actual));\n \n                Rewrite (Actual, Conversion);\n-\n-               Analyze_And_Resolve (Actual,\n-                 Etype (Directly_Designated_Type (Formal_Typ)));\n+               Analyze_And_Resolve (Actual, Etype (Formal_DDT));\n \n                Rewrite (Actual,\n                  Unchecked_Convert_To (Formal_Typ,\n                    Make_Attribute_Reference (Loc,\n-                     Prefix =>\n-                       Relocate_Node (Prefix (Expression (Actual))),\n+                     Prefix => Relocate_Node (Actual),\n                      Attribute_Name => Nam)));\n \n                Analyze_And_Resolve (Actual, Formal_Typ);\n \n+            --  No need to displace the pointer if the actual is a class-wide\n+            --  type of the formal-type interface because in this case the\n+            --  displacement of the pointer was already done at the point of\n+            --  the call to the enclosing subprogram (this case is similar\n+            --  to the example described above for the non access-type case)\n+\n+            elsif Is_Class_Wide_Type (Actual_DDT)\n+              and then Etype (Actual_DDT) = Formal_DDT\n+            then\n+               null;\n+\n+            --  No need to displace the pointer if the type of the actual is a\n+            --  derivation of the interface (because in this case the interface\n+            --  primitives are located in the primary dispatch table)\n+\n+            elsif Is_Ancestor (Formal_DDT, Actual_DDT) then\n+               null;\n+\n             else\n-               Conversion :=\n-                 Convert_To (Formal_Typ, New_Copy_Tree (Actual));\n-               Rewrite             (Actual, Conversion);\n+               Actual_Dup := Relocate_Node (Actual);\n+\n+               if From_With_Type (Actual_Typ) then\n+\n+                  --  If the type of the actual parameter comes from a limited\n+                  --  with-clause and the non-limited view is already available\n+                  --  we replace the anonymous access type by a duplicate decla\n+                  --  ration whose designated type is the non-limited view\n+\n+                  if Ekind (Actual_DDT) = E_Incomplete_Type\n+                    and then Present (Non_Limited_View (Actual_DDT))\n+                  then\n+                     Anon := New_Copy (Actual_Typ);\n+\n+                     if Is_Itype (Anon) then\n+                        Set_Scope (Anon, Current_Scope);\n+                     end if;\n+\n+                     Set_Directly_Designated_Type (Anon,\n+                       Non_Limited_View (Actual_DDT));\n+                     Set_Etype (Actual_Dup, Anon);\n+\n+                  elsif Is_Class_Wide_Type (Actual_DDT)\n+                    and then Ekind (Etype (Actual_DDT)) = E_Incomplete_Type\n+                    and then Present (Non_Limited_View (Etype (Actual_DDT)))\n+                  then\n+                     Anon := New_Copy (Actual_Typ);\n+\n+                     if Is_Itype (Anon) then\n+                        Set_Scope (Anon, Current_Scope);\n+                     end if;\n+\n+                     Set_Directly_Designated_Type (Anon,\n+                       New_Copy (Actual_DDT));\n+                     Set_Class_Wide_Type (Directly_Designated_Type (Anon),\n+                       New_Copy (Class_Wide_Type (Actual_DDT)));\n+                     Set_Etype (Directly_Designated_Type (Anon),\n+                       Non_Limited_View (Etype (Actual_DDT)));\n+                     Set_Etype (\n+                       Class_Wide_Type (Directly_Designated_Type (Anon)),\n+                       Non_Limited_View (Etype (Actual_DDT)));\n+                     Set_Etype (Actual_Dup, Anon);\n+                  end if;\n+               end if;\n+\n+               Conversion := Convert_To (Formal_Typ, Actual_Dup);\n+               Rewrite (Actual, Conversion);\n                Analyze_And_Resolve (Actual, Formal_Typ);\n             end if;\n          end if;\n@@ -904,40 +1352,38 @@ package body Exp_Disp is\n      (N           : Node_Id;\n       Thunk_Alias : Entity_Id;\n       Thunk_Id    : Entity_Id;\n-      Iface_Tag   : Entity_Id) return Node_Id\n+      Thunk_Tag   : Entity_Id) return Node_Id\n    is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Actuals     : constant List_Id    := New_List;\n       Decl        : constant List_Id    := New_List;\n       Formals     : constant List_Id    := New_List;\n-      Thunk_Tag   : constant Node_Id    := Iface_Tag;\n       Target      : Entity_Id;\n       New_Code    : Node_Id;\n       Formal      : Node_Id;\n       New_Formal  : Node_Id;\n       Decl_1      : Node_Id;\n       Decl_2      : Node_Id;\n-      Subtyp_Mark : Node_Id;\n+      E           : Entity_Id;\n \n    begin\n-\n       --  Traverse the list of alias to find the final target\n \n       Target := Thunk_Alias;\n-\n       while Present (Alias (Target)) loop\n          Target := Alias (Target);\n       end loop;\n \n       --  Duplicate the formals\n \n-      Formal := First_Formal (Thunk_Alias);\n-\n+      Formal := First_Formal (Target);\n+      E      := First_Formal (N);\n       while Present (Formal) loop\n          New_Formal := Copy_Separate_Tree (Parent (Formal));\n \n-         --  Handle the case in which the subprogram covering\n-         --  the interface has been inherited:\n+         --  Propagate the parameter type to the copy. This is required to\n+         --  properly handle the case in which the subprogram covering the\n+         --  interface has been inherited:\n \n          --  Example:\n          --     type I is interface;\n@@ -948,20 +1394,17 @@ package body Exp_Disp is\n \n          --     type DT is new T and I with ...\n \n-         if Is_Controlling_Formal (Formal) then\n-            Set_Parameter_Type (New_Formal,\n-              New_Reference_To (Etype (First_Entity (N)), Loc));\n-         end if;\n-\n+         Set_Parameter_Type (New_Formal, New_Reference_To (Etype (E), Loc));\n          Append_To (Formals, New_Formal);\n+\n          Next_Formal (Formal);\n+         Next_Formal (E);\n       end loop;\n \n-      if Ekind (First_Formal (Thunk_Alias)) = E_In_Parameter\n-        and then Ekind (Etype (First_Formal (Thunk_Alias)))\n+      if Ekind (First_Formal (Target)) = E_In_Parameter\n+        and then Ekind (Etype (First_Formal (Target)))\n                   = E_Anonymous_Access_Type\n       then\n-\n          --  Generate:\n \n          --     type T is access all <<type of the first formal>>\n@@ -983,8 +1426,7 @@ package body Exp_Disp is\n                  Subtype_Indication     =>\n                    New_Reference_To\n                      (Directly_Designated_Type\n-                        (Etype (First_Formal (Thunk_Alias))), Loc)\n-                         ));\n+                        (Etype (First_Formal (Target))), Loc)));\n \n          Decl_1 :=\n            Make_Object_Declaration (Loc,\n@@ -1095,7 +1537,7 @@ package body Exp_Disp is\n          Next (Formal);\n       end loop;\n \n-      if Ekind (Thunk_Alias) = E_Procedure then\n+      if Ekind (Target) = E_Procedure then\n          New_Code :=\n            Make_Subprogram_Body (Loc,\n               Specification =>\n@@ -1110,31 +1552,16 @@ package body Exp_Disp is\n                        Name => New_Occurrence_Of (Target, Loc),\n                        Parameter_Associations => Actuals))));\n \n-      else pragma Assert (Ekind (Thunk_Alias) = E_Function);\n-\n-         if not Present (Alias (Thunk_Alias)) then\n-            Subtyp_Mark := Subtype_Mark (Parent (Thunk_Alias));\n-         else\n-            --  The last element in the alias list has the correct subtype_mark\n-            --  of the function result\n-\n-            declare\n-               E : Entity_Id := Alias (Thunk_Alias);\n-            begin\n-               while Present (Alias (E)) loop\n-                  E := Alias (E);\n-               end loop;\n-               Subtyp_Mark := Subtype_Mark (Parent (E));\n-            end;\n-         end if;\n+      else pragma Assert (Ekind (Target) = E_Function);\n \n          New_Code :=\n            Make_Subprogram_Body (Loc,\n               Specification =>\n                 Make_Function_Specification (Loc,\n                   Defining_Unit_Name       => Thunk_Id,\n                   Parameter_Specifications => Formals,\n-                  Subtype_Mark => New_Copy (Subtyp_Mark)),\n+                  Result_Definition =>\n+                    New_Copy (Result_Definition (Parent (Target)))),\n               Declarations => Decl,\n               Handled_Statement_Sequence =>\n                 Make_Handled_Sequence_Of_Statements (Loc,\n@@ -1234,6 +1661,49 @@ package body Exp_Disp is\n              Selector_Name => Make_Identifier (Loc, Name_uTag))));\n    end Get_Remotely_Callable;\n \n+   ------------------------------------------\n+   -- Init_Predefined_Interface_Primitives --\n+   ------------------------------------------\n+\n+   function Init_Predefined_Interface_Primitives\n+     (Typ : Entity_Id) return List_Id\n+   is\n+      Loc    : constant Source_Ptr := Sloc (Typ);\n+      DT_Ptr : constant Node_Id :=\n+                 Node (First_Elmt (Access_Disp_Table (Typ)));\n+      Result : constant List_Id := New_List;\n+      AI     : Elmt_Id;\n+\n+   begin\n+      --  No need to inherit primitives if it an abstract interface type\n+\n+      if Is_Interface (Typ) then\n+         return Result;\n+      end if;\n+\n+      AI := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+      while Present (AI) loop\n+         --  All the secondary tables inherit the dispatch table entries\n+         --  associated with predefined primitives.\n+\n+         --  Generate:\n+         --    Inherit_DT (T'Tag, Iface'Tag, Default_Prim_Op_Count);\n+\n+         Append_To (Result,\n+           Make_DT_Access_Action (Typ,\n+             Action => Inherit_DT,\n+             Args   => New_List (\n+               Node1 => New_Reference_To (DT_Ptr, Loc),\n+               Node2 => Unchecked_Convert_To (RTE (RE_Tag),\n+                          New_Reference_To (Node (AI), Loc)),\n+               Node3 => Make_Integer_Literal (Loc, Default_Prim_Op_Count))));\n+\n+         Next_Elmt (AI);\n+      end loop;\n+\n+      return Result;\n+   end Init_Predefined_Interface_Primitives;\n+\n    -------------\n    -- Make_DT --\n    -------------\n@@ -1283,8 +1753,7 @@ package body Exp_Disp is\n       --  Calculate the number of entries required in the table of interfaces\n \n       Num_Ifaces := 0;\n-      AI         := First_Elmt (Abstract_Interfaces (Typ_Copy));\n-\n+      AI := First_Elmt (Abstract_Interfaces (Typ_Copy));\n       while Present (AI) loop\n          Num_Ifaces := Num_Ifaces + 1;\n          Next_Elmt (AI);\n@@ -1300,7 +1769,6 @@ package body Exp_Disp is\n \n       begin\n          I_Depth := 0;\n-\n          loop\n             P := Etype (Parent_Type);\n \n@@ -1315,9 +1783,25 @@ package body Exp_Disp is\n          end loop;\n       end;\n \n-      TSD_Num_Entries := I_Depth + Num_Ifaces + 1;\n       Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n \n+      --  Ada 2005 (AI-345): The size of the TSD is increased to accomodate\n+      --  the two tables used for dispatching in asynchronous, conditional\n+      --  and timed selects. The tables are solely generated for limited\n+      --  types that implement a limited interface.\n+\n+      if Ada_Version >= Ada_05\n+        and then not Is_Interface  (Typ)\n+        and then not Is_Abstract   (Typ)\n+        and then not Is_Controlled (Typ)\n+        and then Implements_Limited_Interface (Typ)\n+      then\n+         TSD_Num_Entries := I_Depth + Num_Ifaces + 1 +\n+                              2 * (Nb_Prim - Default_Prim_Op_Count);\n+      else\n+         TSD_Num_Entries := I_Depth + Num_Ifaces + 1;\n+      end if;\n+\n       --  ----------------------------------------------------------------\n       --  Dispatch table and related entities are allocated statically\n \n@@ -1400,7 +1884,7 @@ package body Exp_Disp is\n \n       --  Generate code to define the boolean that controls registration, in\n       --  order to avoid multiple registrations for tagged types defined in\n-      --  multiple-called scopes\n+      --  multiple-called scopes.\n \n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n@@ -1418,7 +1902,7 @@ package body Exp_Disp is\n \n       --  Generate code to create the storage for the type specific data object\n       --  with enough space to store the tags of the ancestors plus the tags\n-      --  of all the implemented interfaces (as described in a-tags.adb)\n+      --  of all the implemented interfaces (as described in a-tags.adb).\n       --\n       --   TSD: Storage_Array\n       --     (1..TSD_Prologue_Size+TSD_Num_Entries*TSD_Entry_Size);\n@@ -1532,83 +2016,94 @@ package body Exp_Disp is\n              (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc);\n       end if;\n \n-      --  Generate: Inherit_DT (parent'tag, DT_Ptr, nb_prim of parent);\n-\n-      Append_To (Elab_Code,\n-        Make_DT_Access_Action (Typ,\n-          Action => Inherit_DT,\n-          Args   => New_List (\n-            Node1 => Old_Tag1,\n-            Node2 => New_Reference_To (DT_Ptr, Loc),\n-            Node3 => Make_Integer_Literal (Loc,\n-                       DT_Entry_Count (First_Tag_Component (Etype (Typ)))))));\n+      if Typ /= Etype (Typ)\n+        and then not Is_Interface (Typ)\n+        and then not Is_Interface (Etype (Typ))\n+      then\n+         --  Generate: Inherit_DT (parent'tag, DT_Ptr, nb_prim of parent);\n \n-      --  Inherit the secondary dispatch tables of the ancestor\n+         Append_To (Elab_Code,\n+           Make_DT_Access_Action (Typ,\n+             Action => Inherit_DT,\n+             Args   => New_List (\n+               Node1 => Old_Tag1,\n+               Node2 => New_Reference_To (DT_Ptr, Loc),\n+               Node3 =>\n+                 Make_Integer_Literal (Loc,\n+                   DT_Entry_Count (First_Tag_Component (Etype (Typ)))))));\n \n-      if not Is_CPP_Class (Etype (Typ)) then\n-         declare\n-            Sec_DT_Ancestor : Elmt_Id :=\n-              Next_Elmt (First_Elmt (Access_Disp_Table (Etype (Typ))));\n-            Sec_DT_Typ      : Elmt_Id :=\n-              Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+         --  Inherit the secondary dispatch tables of the ancestor\n \n-            procedure Copy_Secondary_DTs (Typ : Entity_Id);\n-            --  ??? comment required\n+         if not Is_CPP_Class (Etype (Typ)) then\n+            declare\n+               Sec_DT_Ancestor : Elmt_Id :=\n+                                   Next_Elmt\n+                                     (First_Elmt\n+                                        (Access_Disp_Table (Etype (Typ))));\n+               Sec_DT_Typ      : Elmt_Id :=\n+                                   Next_Elmt\n+                                     (First_Elmt\n+                                        (Access_Disp_Table (Typ)));\n+\n+               procedure Copy_Secondary_DTs (Typ : Entity_Id);\n+               --  Local procedure required to climb through the ancestors and\n+               --  copy the contents of all their secondary dispatch tables.\n+\n+               ------------------------\n+               -- Copy_Secondary_DTs --\n+               ------------------------\n+\n+               procedure Copy_Secondary_DTs (Typ : Entity_Id) is\n+                  E : Entity_Id;\n \n-            ------------------------\n-            -- Copy_Secondary_DTs --\n-            ------------------------\n+               begin\n+                  if Etype (Typ) /= Typ then\n+                     Copy_Secondary_DTs (Etype (Typ));\n+                  end if;\n \n-            procedure Copy_Secondary_DTs (Typ : Entity_Id) is\n-               E : Entity_Id;\n+                  if Present (Abstract_Interfaces (Typ))\n+                    and then not Is_Empty_Elmt_List\n+                                   (Abstract_Interfaces (Typ))\n+                  then\n+                     E := First_Entity (Typ);\n+                     while Present (E)\n+                       and then Present (Node (Sec_DT_Ancestor))\n+                     loop\n+                        if Is_Tag (E) and then Chars (E) /= Name_uTag then\n+                           Append_To (Elab_Code,\n+                             Make_DT_Access_Action (Typ,\n+                               Action => Inherit_DT,\n+                               Args   => New_List (\n+                                 Node1 => Unchecked_Convert_To\n+                                            (RTE (RE_Tag),\n+                                             New_Reference_To\n+                                               (Node (Sec_DT_Ancestor), Loc)),\n+                                 Node2 => Unchecked_Convert_To\n+                                            (RTE (RE_Tag),\n+                                             New_Reference_To\n+                                               (Node (Sec_DT_Typ), Loc)),\n+                                 Node3 => Make_Integer_Literal (Loc,\n+                                            DT_Entry_Count (E)))));\n+\n+                           Next_Elmt (Sec_DT_Ancestor);\n+                           Next_Elmt (Sec_DT_Typ);\n+                        end if;\n+\n+                        Next_Entity (E);\n+                     end loop;\n+                  end if;\n+               end Copy_Secondary_DTs;\n \n             begin\n-               if Etype (Typ) /= Typ then\n-                  Copy_Secondary_DTs (Etype (Typ));\n+               if Present (Node (Sec_DT_Ancestor)) then\n+                  Copy_Secondary_DTs (Typ);\n                end if;\n-\n-               if Present (Abstract_Interfaces (Typ))\n-                 and then not Is_Empty_Elmt_List\n-                                (Abstract_Interfaces (Typ))\n-               then\n-                  E := First_Entity (Typ);\n-\n-                  while Present (E)\n-                    and then Present (Node (Sec_DT_Ancestor))\n-                  loop\n-                     if Is_Tag (E) and then Chars (E) /= Name_uTag then\n-                        Append_To (Elab_Code,\n-                          Make_DT_Access_Action (Typ,\n-                            Action => Inherit_DT,\n-                            Args   => New_List (\n-                              Node1 => Unchecked_Convert_To\n-                                         (RTE (RE_Tag),\n-                                          New_Reference_To\n-                                            (Node (Sec_DT_Ancestor), Loc)),\n-                              Node2 => Unchecked_Convert_To\n-                                         (RTE (RE_Tag),\n-                                          New_Reference_To\n-                                            (Node (Sec_DT_Typ), Loc)),\n-                              Node3 => Make_Integer_Literal (Loc,\n-                                         DT_Entry_Count (E)))));\n-\n-                        Next_Elmt (Sec_DT_Ancestor);\n-                        Next_Elmt (Sec_DT_Typ);\n-                     end if;\n-\n-                     Next_Entity (E);\n-                  end loop;\n-               end if;\n-            end Copy_Secondary_DTs;\n-\n-         begin\n-            if Present (Node (Sec_DT_Ancestor)) then\n-               Copy_Secondary_DTs (Typ);\n-            end if;\n-         end;\n+            end;\n+         end if;\n       end if;\n \n-      --  Generate: Inherit_TSD (parent'tag, DT_Ptr);\n+      --  Generate:\n+      --    Inherit_TSD (parent'tag, DT_Ptr);\n \n       Append_To (Elab_Code,\n         Make_DT_Access_Action (Typ,\n@@ -1962,6 +2457,832 @@ package body Exp_Disp is\n       end if;\n    end Make_DT_Access_Action;\n \n+   ----------------------------------------\n+   -- Make_Disp_Asynchronous_Select_Body --\n+   ----------------------------------------\n+\n+   function Make_Disp_Asynchronous_Select_Body\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Conc_Typ   : Entity_Id           := Empty;\n+      Decls      : constant List_Id    := New_List;\n+      DT_Ptr     : Entity_Id;\n+      DT_Ptr_Typ : Entity_Id;\n+      Loc        : constant Source_Ptr := Sloc (Typ);\n+      Stmts      : constant List_Id    := New_List;\n+\n+   begin\n+      if Is_Concurrent_Record_Type (Typ) then\n+         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n+      end if;\n+\n+      --  Typ may be a derived type, climb the derivation chain in order to\n+      --  find the root.\n+\n+      DT_Ptr_Typ := Typ;\n+      while Present (Parent_Subtype (DT_Ptr_Typ)) loop\n+         DT_Ptr_Typ := Parent_Subtype (DT_Ptr_Typ);\n+      end loop;\n+\n+      DT_Ptr := Node (First_Elmt (Access_Disp_Table (DT_Ptr_Typ)));\n+\n+      if Present (Conc_Typ) then\n+\n+         --  Generate:\n+         --    I : Integer := get_entry_index (tag! (<type>VP), S);\n+\n+         --  where I will be used to capture the entry index of the primitive\n+         --  wrapper at position S.\n+\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uI),\n+             Object_Definition =>\n+               New_Reference_To (Standard_Integer, Loc),\n+             Expression =>\n+               Make_DT_Access_Action (Typ,\n+                 Action =>\n+                   Get_Entry_Index,\n+                 Args =>\n+                   New_List (\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (DT_Ptr, Loc)),\n+                     Make_Identifier (Loc, Name_uS)))));\n+\n+         if Ekind (Conc_Typ) = E_Protected_Type then\n+\n+            --  Generate:\n+            --    Protected_Entry_Call (\n+            --      T._object'access,\n+            --      protected_entry_index! (I),\n+            --      P,\n+            --      Asynchronous_Call,\n+            --      B);\n+\n+            --  where T is the protected object, I is the entry index, P are\n+            --  the wrapped parameters and B is the name of the communication\n+            --  block.\n+\n+            Append_To (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Protected_Entry_Call), Loc),\n+                Parameter_Associations =>\n+                  New_List (\n+\n+                    Make_Attribute_Reference (Loc,        -- T._object'access\n+                      Attribute_Name =>\n+                        Name_Unchecked_Access,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix =>\n+                            Make_Identifier (Loc, Name_uT),\n+                          Selector_Name =>\n+                            Make_Identifier (Loc, Name_uObject))),\n+\n+                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                      Subtype_Mark =>\n+                        New_Reference_To (RTE (RE_Protected_Entry_Index), Loc),\n+                      Expression =>\n+                        Make_Identifier (Loc, Name_uI)),\n+\n+                    Make_Identifier (Loc, Name_uP),       --  parameter block\n+                    New_Reference_To (                    --  Asynchronous_Call\n+                      RTE (RE_Asynchronous_Call), Loc),\n+                    Make_Identifier (Loc, Name_uB))));    --  comm block\n+         else\n+            pragma Assert (Ekind (Conc_Typ) = E_Task_Type);\n+\n+            --  Generate:\n+            --    Protected_Entry_Call (\n+            --      T._task_id,\n+            --      task_entry_index! (I),\n+            --      P,\n+            --      Conditional_Call,\n+            --      F);\n+\n+            --  where T is the task object, I is the entry index, P are the\n+            --  wrapped parameters and F is the status flag.\n+\n+            Append_To (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Task_Entry_Call), Loc),\n+                Parameter_Associations =>\n+                  New_List (\n+\n+                    Make_Selected_Component (Loc,         -- T._task_id\n+                      Prefix =>\n+                        Make_Identifier (Loc, Name_uT),\n+                      Selector_Name =>\n+                        Make_Identifier (Loc, Name_uTask_Id)),\n+\n+                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                      Subtype_Mark =>\n+                        New_Reference_To (RTE (RE_Task_Entry_Index), Loc),\n+                      Expression =>\n+                        Make_Identifier (Loc, Name_uI)),\n+\n+                    Make_Identifier (Loc, Name_uP),       --  parameter block\n+                    New_Reference_To (                    --  Asynchronous_Call\n+                      RTE (RE_Asynchronous_Call), Loc),\n+                    Make_Identifier (Loc, Name_uF))));    --  status flag\n+         end if;\n+\n+      --  Null implementation for limited tagged types\n+\n+      else\n+         Append_To (Stmts,\n+           Make_Null_Statement (Loc));\n+      end if;\n+\n+      return\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Make_Disp_Asynchronous_Select_Spec (Typ),\n+          Declarations =>\n+            Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n+   end Make_Disp_Asynchronous_Select_Body;\n+\n+   ----------------------------------------\n+   -- Make_Disp_Asynchronous_Select_Spec --\n+   ----------------------------------------\n+\n+   function Make_Disp_Asynchronous_Select_Spec\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc    : constant Source_Ptr := Sloc (Typ);\n+      Params : constant List_Id    := New_List;\n+\n+   begin\n+      --  \"T\" - Object parameter\n+      --  \"S\" - Primitive operation slot\n+      --  \"P\" - Wrapped parameters\n+      --  \"B\" - Communication block\n+      --  \"F\" - Status flag\n+\n+      SEU.Build_T (Loc, Typ, Params);\n+      SEU.Build_S (Loc, Params);\n+      SEU.Build_P (Loc, Params);\n+      SEU.Build_B (Loc, Params);\n+      SEU.Build_F (Loc, Params);\n+\n+      return\n+         Make_Procedure_Specification (Loc,\n+           Defining_Unit_Name =>\n+             Make_Defining_Identifier (Loc, Name_uDisp_Asynchronous_Select),\n+           Parameter_Specifications =>\n+             Params);\n+   end Make_Disp_Asynchronous_Select_Spec;\n+\n+   ---------------------------------------\n+   -- Make_Disp_Conditional_Select_Body --\n+   ---------------------------------------\n+\n+   function Make_Disp_Conditional_Select_Body\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Blk_Nam    : Entity_Id;\n+      Conc_Typ   : Entity_Id         := Empty;\n+      Decls      : constant List_Id  := New_List;\n+      DT_Ptr     : Entity_Id;\n+      DT_Ptr_Typ : Entity_Id;\n+      Loc        : constant Source_Ptr := Sloc (Typ);\n+      Stmts      : constant List_Id  := New_List;\n+\n+   begin\n+      if Is_Concurrent_Record_Type (Typ) then\n+         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n+      end if;\n+\n+      --  Typ may be a derived type, climb the derivation chain in order to\n+      --  find the root.\n+\n+      DT_Ptr_Typ := Typ;\n+      while Present (Parent_Subtype (DT_Ptr_Typ)) loop\n+         DT_Ptr_Typ := Parent_Subtype (DT_Ptr_Typ);\n+      end loop;\n+\n+      DT_Ptr := Node (First_Elmt (Access_Disp_Table (DT_Ptr_Typ)));\n+\n+      if Present (Conc_Typ) then\n+         --  Generate:\n+         --    I : Integer;\n+\n+         --  where I will be used to capture the entry index of the primitive\n+         --  wrapper at position S.\n+\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uI),\n+             Object_Definition =>\n+               New_Reference_To (Standard_Integer, Loc)));\n+      end if;\n+\n+      --  Generate:\n+      --    C := get_prim_op_kind (tag! (<type>VP), S);\n+\n+      --    if C = POK_Procedure\n+      --      or else C = POK_Protected_Procedure\n+      --      or else C = POK_Task_Procedure;\n+      --    then\n+      --       F := True;\n+      --       return;\n+      --    end if;\n+\n+      SEU.Build_Common_Dispatching_Select_Statements (Loc, Typ, Stmts);\n+\n+      if Present (Conc_Typ) then\n+\n+         --  Generate:\n+         --    Bnn : Communication_Block;\n+\n+         --  where Bnn is the name of the communication block used in\n+         --  the call to Protected_Entry_Call.\n+\n+         Blk_Nam := Make_Defining_Identifier (Loc, New_Internal_Name ('B'));\n+\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Blk_Nam,\n+             Object_Definition =>\n+               New_Reference_To (RTE (RE_Communication_Block), Loc)));\n+\n+         --  Generate:\n+         --    I := get_entry_index (tag! (<type>VP), S);\n+\n+         --  where I is the entry index and S is the dispatch table slot.\n+\n+         Append_To (Stmts,\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               Make_Identifier (Loc, Name_uI),\n+             Expression =>\n+               Make_DT_Access_Action (Typ,\n+                 Action =>\n+                   Get_Entry_Index,\n+                 Args =>\n+                   New_List (\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (DT_Ptr, Loc)),\n+                     Make_Identifier (Loc, Name_uS)))));\n+\n+         if Ekind (Conc_Typ) = E_Protected_Type then\n+\n+            --  Generate:\n+            --    Protected_Entry_Call (\n+            --      T._object'access,\n+            --      protected_entry_index! (I),\n+            --      P,\n+            --      Conditional_Call,\n+            --      Bnn);\n+\n+            --  where T is the protected object, I is the entry index, P are\n+            --  the wrapped parameters and Bnn is the name of the communication\n+            --  block.\n+\n+            Append_To (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Protected_Entry_Call), Loc),\n+                Parameter_Associations =>\n+                  New_List (\n+\n+                    Make_Attribute_Reference (Loc,        -- T._object'access\n+                      Attribute_Name =>\n+                        Name_Unchecked_Access,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix =>\n+                            Make_Identifier (Loc, Name_uT),\n+                          Selector_Name =>\n+                            Make_Identifier (Loc, Name_uObject))),\n+\n+                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                      Subtype_Mark =>\n+                        New_Reference_To (RTE (RE_Protected_Entry_Index), Loc),\n+                      Expression =>\n+                        Make_Identifier (Loc, Name_uI)),\n+\n+                    Make_Identifier (Loc, Name_uP),       --  parameter block\n+                    New_Reference_To (                    --  Conditional_Call\n+                      RTE (RE_Conditional_Call), Loc),\n+                    New_Reference_To (                    --  Bnn\n+                      Blk_Nam, Loc))));\n+\n+            --  Generate:\n+            --    F := not Cancelled (Bnn);\n+\n+            --  where F is the success flag. The status of Cancelled is negated\n+            --  in order to match the behaviour of the version for task types.\n+\n+            Append_To (Stmts,\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n+                  Make_Identifier (Loc, Name_uF),\n+                Expression =>\n+                  Make_Op_Not (Loc,\n+                    Right_Opnd =>\n+                      Make_Function_Call (Loc,\n+                        Name =>\n+                          New_Reference_To (RTE (RE_Cancelled), Loc),\n+                        Parameter_Associations =>\n+                          New_List (\n+                            New_Reference_To (Blk_Nam, Loc))))));\n+         else\n+            pragma Assert (Ekind (Conc_Typ) = E_Task_Type);\n+\n+            --  Generate:\n+            --    Protected_Entry_Call (\n+            --      T._task_id,\n+            --      task_entry_index! (I),\n+            --      P,\n+            --      Conditional_Call,\n+            --      F);\n+\n+            --  where T is the task object, I is the entry index, P are the\n+            --  wrapped parameters and F is the status flag.\n+\n+            Append_To (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Task_Entry_Call), Loc),\n+                Parameter_Associations =>\n+                  New_List (\n+\n+                    Make_Selected_Component (Loc,         -- T._task_id\n+                      Prefix =>\n+                        Make_Identifier (Loc, Name_uT),\n+                      Selector_Name =>\n+                        Make_Identifier (Loc, Name_uTask_Id)),\n+\n+                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                      Subtype_Mark =>\n+                        New_Reference_To (RTE (RE_Task_Entry_Index), Loc),\n+                      Expression =>\n+                        Make_Identifier (Loc, Name_uI)),\n+\n+                    Make_Identifier (Loc, Name_uP),       --  parameter block\n+                    New_Reference_To (                    --  Conditional_Call\n+                      RTE (RE_Conditional_Call), Loc),\n+                    Make_Identifier (Loc, Name_uF))));    --  status flag\n+         end if;\n+\n+      --  Null implementation for limited tagged types\n+\n+      else\n+         Append_To (Stmts,\n+           Make_Null_Statement (Loc));\n+      end if;\n+\n+      return\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Make_Disp_Conditional_Select_Spec (Typ),\n+          Declarations =>\n+            Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n+   end Make_Disp_Conditional_Select_Body;\n+\n+   ---------------------------------------\n+   -- Make_Disp_Conditional_Select_Spec --\n+   ---------------------------------------\n+\n+   function Make_Disp_Conditional_Select_Spec\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc    : constant Source_Ptr := Sloc (Typ);\n+      Params : constant List_Id    := New_List;\n+\n+   begin\n+      --  \"T\" - Object parameter\n+      --  \"S\" - Primitive operation slot\n+      --  \"P\" - Wrapped parameters\n+      --  \"C\" - Call kind\n+      --  \"F\" - Status flag\n+\n+      SEU.Build_T (Loc, Typ, Params);\n+      SEU.Build_S (Loc, Params);\n+      SEU.Build_P (Loc, Params);\n+      SEU.Build_C (Loc, Params);\n+      SEU.Build_F (Loc, Params);\n+\n+      return\n+        Make_Procedure_Specification (Loc,\n+          Defining_Unit_Name =>\n+            Make_Defining_Identifier (Loc, Name_uDisp_Conditional_Select),\n+          Parameter_Specifications =>\n+            Params);\n+   end Make_Disp_Conditional_Select_Spec;\n+\n+   -------------------------------------\n+   -- Make_Disp_Get_Prim_Op_Kind_Body --\n+   -------------------------------------\n+\n+   function Make_Disp_Get_Prim_Op_Kind_Body\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc        : constant Source_Ptr := Sloc (Typ);\n+      DT_Ptr     : Entity_Id;\n+      DT_Ptr_Typ : Entity_Id;\n+\n+   begin\n+      --  Typ may be a derived type, climb the derivation chain in order to\n+      --  find the root.\n+\n+      DT_Ptr_Typ := Typ;\n+      while Present (Parent_Subtype (DT_Ptr_Typ)) loop\n+         DT_Ptr_Typ := Parent_Subtype (DT_Ptr_Typ);\n+      end loop;\n+\n+      DT_Ptr := Node (First_Elmt (Access_Disp_Table (DT_Ptr_Typ)));\n+\n+      --  Generate:\n+      --    C := get_prim_op_kind (tag! (<type>VP), S);\n+\n+      --  where C is the out parameter capturing the call kind and S is the\n+      --  dispatch table slot number.\n+\n+      return\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Make_Disp_Get_Prim_Op_Kind_Spec (Typ),\n+          Declarations =>\n+            No_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              New_List (\n+                Make_Assignment_Statement (Loc,\n+                  Name =>\n+                    Make_Identifier (Loc, Name_uC),\n+                  Expression =>\n+                    Make_DT_Access_Action (Typ,\n+                      Action =>\n+                        Get_Prim_Op_Kind,\n+                      Args =>\n+                        New_List (\n+                          Unchecked_Convert_To (RTE (RE_Tag),\n+                            New_Reference_To (DT_Ptr, Loc)),\n+                            Make_Identifier (Loc, Name_uS)))))));\n+   end Make_Disp_Get_Prim_Op_Kind_Body;\n+\n+   -------------------------------------\n+   -- Make_Disp_Get_Prim_Op_Kind_Spec --\n+   -------------------------------------\n+\n+   function Make_Disp_Get_Prim_Op_Kind_Spec\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc    : constant Source_Ptr := Sloc (Typ);\n+      Params : constant List_Id    := New_List;\n+\n+   begin\n+      --  \"T\" - Object parameter\n+      --  \"S\" - Primitive operation slot\n+      --  \"C\" - Call kind\n+\n+      SEU.Build_T (Loc, Typ, Params);\n+      SEU.Build_S (Loc, Params);\n+      SEU.Build_C (Loc, Params);\n+\n+      return\n+        Make_Procedure_Specification (Loc,\n+           Defining_Unit_Name =>\n+             Make_Defining_Identifier (Loc, Name_uDisp_Get_Prim_Op_Kind),\n+           Parameter_Specifications =>\n+             Params);\n+   end Make_Disp_Get_Prim_Op_Kind_Spec;\n+\n+   -----------------------------\n+   -- Make_Disp_Select_Tables --\n+   -----------------------------\n+\n+   function Make_Disp_Select_Tables\n+     (Typ : Entity_Id) return List_Id\n+   is\n+      Assignments : constant List_Id    := New_List;\n+      DT_Ptr      : Entity_Id;\n+      DT_Ptr_Typ  : Entity_Id;\n+      Index       : Uint                := Uint_1;\n+      Loc         : constant Source_Ptr := Sloc (Typ);\n+      Prim        : Entity_Id;\n+      Prim_Als    : Entity_Id;\n+      Prim_Elmt   : Elmt_Id;\n+      Prim_Pos    : Uint;\n+\n+   begin\n+      pragma Assert (Present (Primitive_Operations (Typ)));\n+\n+      --  Typ may be a derived type, climb the derivation chain in order to\n+      --  find the root.\n+\n+      DT_Ptr_Typ := Typ;\n+      while Present (Parent_Subtype (DT_Ptr_Typ)) loop\n+         DT_Ptr_Typ := Parent_Subtype (DT_Ptr_Typ);\n+      end loop;\n+\n+      DT_Ptr := Node (First_Elmt (Access_Disp_Table (DT_Ptr_Typ)));\n+\n+      Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+      while Present (Prim_Elmt) loop\n+         Prim := Node (Prim_Elmt);\n+\n+         --  Retrieve the root of the alias chain\n+\n+         if Present (Alias (Prim)) then\n+            Prim_Als := Prim;\n+            while Present (Alias (Prim_Als)) loop\n+               Prim_Als := Alias (Prim_Als);\n+            end loop;\n+         else\n+            Prim_Als := Empty;\n+         end if;\n+\n+         --  We either have a procedure or a wrapper. Set the primitive\n+         --  operation kind for both cases and set the entry index for\n+         --  wrappers.\n+\n+         if Ekind (Prim) = E_Procedure\n+           and then Present (Prim_Als)\n+           and then Is_Primitive_Wrapper (Prim_Als)\n+         then\n+            Prim_Pos := DT_Position (Prim);\n+\n+            --  Generate:\n+            --    set_prim_op_kind (<tag>, <position>, <kind>);\n+\n+            Append_To (Assignments,\n+              Make_DT_Access_Action (Typ,\n+                Action =>\n+                  Set_Prim_Op_Kind,\n+                Args =>\n+                  New_List (\n+                    Unchecked_Convert_To (RTE (RE_Tag),\n+                      New_Reference_To (DT_Ptr, Loc)),\n+                    Make_Integer_Literal (Loc, Prim_Pos),\n+                    Prim_Op_Kind (Prim, Typ))));\n+\n+            --  The wrapped entity of the alias is an entry\n+\n+            if Ekind (Wrapped_Entity (Prim_Als)) = E_Entry then\n+               --  Generate:\n+               --    set_entry_index (<tag>, <position>, <index>);\n+\n+               Append_To (Assignments,\n+                 Make_DT_Access_Action (Typ,\n+                   Action =>\n+                     Set_Entry_Index,\n+                   Args =>\n+                     New_List (\n+                       Unchecked_Convert_To (RTE (RE_Tag),\n+                         New_Reference_To (DT_Ptr, Loc)),\n+                       Make_Integer_Literal (Loc, Prim_Pos),\n+                       Make_Integer_Literal (Loc, Index))));\n+\n+               Index := Index + 1;\n+            end if;\n+         end if;\n+\n+         Next_Elmt (Prim_Elmt);\n+      end loop;\n+\n+      return Assignments;\n+   end Make_Disp_Select_Tables;\n+\n+   ---------------------------------\n+   -- Make_Disp_Timed_Select_Body --\n+   ---------------------------------\n+\n+   function Make_Disp_Timed_Select_Body\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc        : constant Source_Ptr   := Sloc (Typ);\n+      Conc_Typ   : Entity_Id             := Empty;\n+      Decls      : constant List_Id      := New_List;\n+      DT_Ptr     : Entity_Id;\n+      DT_Ptr_Typ : Entity_Id;\n+      Stmts      : constant List_Id      := New_List;\n+\n+   begin\n+      if Is_Concurrent_Record_Type (Typ) then\n+         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n+      end if;\n+\n+      --  Typ may be a derived type, climb the derivation chain in order to\n+      --  find the root.\n+\n+      DT_Ptr_Typ := Typ;\n+      while Present (Parent_Subtype (DT_Ptr_Typ)) loop\n+         DT_Ptr_Typ := Parent_Subtype (DT_Ptr_Typ);\n+      end loop;\n+\n+      DT_Ptr := Node (First_Elmt (Access_Disp_Table (DT_Ptr_Typ)));\n+\n+      if Present (Conc_Typ) then\n+\n+         --  Generate:\n+         --    I : Integer;\n+\n+         --  where I will be used to capture the entry index of the primitive\n+         --  wrapper at position S.\n+\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uI),\n+             Object_Definition =>\n+               New_Reference_To (Standard_Integer, Loc)));\n+      end if;\n+\n+      --  Generate:\n+      --    C := get_prim_op_kind (tag! (<type>VP), S);\n+\n+      --    if C = POK_Procedure\n+      --      or else C = POK_Protected_Procedure\n+      --      or else C = POK_Task_Procedure;\n+      --    then\n+      --       F := True;\n+      --       return;\n+      --    end if;\n+\n+      SEU.Build_Common_Dispatching_Select_Statements (Loc, Typ, Stmts);\n+\n+      if Present (Conc_Typ) then\n+\n+         --  Generate:\n+         --    I := get_entry_index (tag! (<type>VP), S);\n+\n+         --  where I is the entry index and S is the dispatch table slot.\n+\n+         Append_To (Stmts,\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               Make_Identifier (Loc, Name_uI),\n+             Expression =>\n+               Make_DT_Access_Action (Typ,\n+                 Action =>\n+                   Get_Entry_Index,\n+                 Args =>\n+                   New_List (\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (DT_Ptr, Loc)),\n+                     Make_Identifier (Loc, Name_uS)))));\n+\n+         if Ekind (Conc_Typ) = E_Protected_Type then\n+\n+            --  Generate:\n+            --    Timed_Protected_Entry_Call (\n+            --      T._object'access,\n+            --      protected_entry_index! (I),\n+            --      P,\n+            --      D,\n+            --      M,\n+            --      F);\n+\n+            --  where T is the protected object, I is the entry index, P are\n+            --  the wrapped parameters, D is the delay amount, M is the delay\n+            --  mode and F is the status flag.\n+\n+            Append_To (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Timed_Protected_Entry_Call), Loc),\n+                Parameter_Associations =>\n+                  New_List (\n+\n+                    Make_Attribute_Reference (Loc,        -- T._object'access\n+                      Attribute_Name =>\n+                        Name_Unchecked_Access,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix =>\n+                            Make_Identifier (Loc, Name_uT),\n+                          Selector_Name =>\n+                            Make_Identifier (Loc, Name_uObject))),\n+\n+                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                      Subtype_Mark =>\n+                        New_Reference_To (RTE (RE_Protected_Entry_Index), Loc),\n+                      Expression =>\n+                        Make_Identifier (Loc, Name_uI)),\n+\n+                    Make_Identifier (Loc, Name_uP),       --  parameter block\n+                    Make_Identifier (Loc, Name_uD),       --  delay\n+                    Make_Identifier (Loc, Name_uM),       --  delay mode\n+                    Make_Identifier (Loc, Name_uF))));    --  status flag\n+\n+         else\n+            pragma Assert (Ekind (Conc_Typ) = E_Task_Type);\n+\n+            --  Generate:\n+            --    Timed_Task_Entry_Call (\n+            --      T._task_id,\n+            --      task_entry_index! (I),\n+            --      P,\n+            --      D,\n+            --      M,\n+            --      F);\n+\n+            --  where T is the task object, I is the entry index, P are the\n+            --  wrapped parameters, D is the delay amount, M is the delay\n+            --  mode and F is the status flag.\n+\n+            Append_To (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Timed_Task_Entry_Call), Loc),\n+                Parameter_Associations =>\n+                  New_List (\n+\n+                    Make_Selected_Component (Loc,         --  T._task_id\n+                      Prefix =>\n+                        Make_Identifier (Loc, Name_uT),\n+                      Selector_Name =>\n+                        Make_Identifier (Loc, Name_uTask_Id)),\n+\n+                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                      Subtype_Mark =>\n+                        New_Reference_To (RTE (RE_Task_Entry_Index), Loc),\n+                      Expression =>\n+                        Make_Identifier (Loc, Name_uI)),\n+\n+                    Make_Identifier (Loc, Name_uP),       --  parameter block\n+                    Make_Identifier (Loc, Name_uD),       --  delay\n+                    Make_Identifier (Loc, Name_uM),       --  delay mode\n+                    Make_Identifier (Loc, Name_uF))));    --  status flag\n+         end if;\n+\n+      --  Null implementation for limited tagged types\n+\n+      else\n+         Append_To (Stmts,\n+           Make_Null_Statement (Loc));\n+      end if;\n+\n+      return\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Make_Disp_Timed_Select_Spec (Typ),\n+          Declarations =>\n+            Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n+   end Make_Disp_Timed_Select_Body;\n+\n+   ---------------------------------\n+   -- Make_Disp_Timed_Select_Spec --\n+   ---------------------------------\n+\n+   function Make_Disp_Timed_Select_Spec\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc    : constant Source_Ptr := Sloc (Typ);\n+      Params : constant List_Id    := New_List;\n+\n+   begin\n+      --  \"T\" - Object parameter\n+      --  \"S\" - Primitive operation slot\n+      --  \"P\" - Wrapped parameters\n+      --  \"D\" - Delay\n+      --  \"M\" - Delay Mode\n+      --  \"C\" - Call kind\n+      --  \"F\" - Status flag\n+\n+      SEU.Build_T (Loc, Typ, Params);\n+      SEU.Build_S (Loc, Params);\n+      SEU.Build_P (Loc, Params);\n+\n+      Append_To (Params,\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc, Name_uD),\n+          Parameter_Type =>\n+            New_Reference_To (Standard_Duration, Loc)));\n+\n+      Append_To (Params,\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc, Name_uM),\n+          Parameter_Type =>\n+            New_Reference_To (Standard_Integer, Loc)));\n+\n+      SEU.Build_C (Loc, Params);\n+      SEU.Build_F (Loc, Params);\n+\n+      return\n+        Make_Procedure_Specification (Loc,\n+          Defining_Unit_Name =>\n+            Make_Defining_Identifier (Loc, Name_uDisp_Timed_Select),\n+          Parameter_Specifications =>\n+            Params);\n+   end Make_Disp_Timed_Select_Spec;\n+\n    -----------------------------------\n    -- Original_View_In_Visible_Part --\n    -----------------------------------\n@@ -1989,6 +3310,86 @@ package body Exp_Disp is\n         Visible_Declarations (Specification (Unit_Declaration_Node (Scop)));\n    end Original_View_In_Visible_Part;\n \n+   ------------------\n+   -- Prim_Op_Kind --\n+   ------------------\n+\n+   function Prim_Op_Kind\n+     (Prim : Entity_Id;\n+      Typ  : Entity_Id) return Node_Id\n+   is\n+      Full_Typ : Entity_Id := Typ;\n+      Loc      : constant Source_Ptr := Sloc (Prim);\n+      Prim_Op  : Entity_Id := Prim;\n+\n+   begin\n+      --  Retrieve the original primitive operation\n+\n+      while Present (Alias (Prim_Op)) loop\n+         Prim_Op := Alias (Prim_Op);\n+      end loop;\n+\n+      if Ekind (Typ) = E_Record_Type\n+        and then Present (Corresponding_Concurrent_Type (Typ))\n+      then\n+         Full_Typ := Corresponding_Concurrent_Type (Typ);\n+      end if;\n+\n+      if Ekind (Prim_Op) = E_Function then\n+\n+         --  Protected function\n+\n+         if Ekind (Full_Typ) = E_Protected_Type then\n+            return New_Reference_To (RTE (RE_POK_Protected_Function), Loc);\n+\n+         --  Regular function\n+\n+         else\n+            return New_Reference_To (RTE (RE_POK_Function), Loc);\n+         end if;\n+\n+      else\n+         pragma Assert (Ekind (Prim_Op) = E_Procedure);\n+\n+         if Ekind (Full_Typ) = E_Protected_Type then\n+\n+            --  Protected entry\n+\n+            if Is_Primitive_Wrapper (Prim_Op)\n+              and then Ekind (Wrapped_Entity (Prim_Op)) = E_Entry\n+            then\n+               return New_Reference_To (RTE (RE_POK_Protected_Entry), Loc);\n+\n+            --  Protected procedure\n+\n+            else\n+               return New_Reference_To (RTE (RE_POK_Protected_Procedure), Loc);\n+            end if;\n+\n+         elsif Ekind (Full_Typ) = E_Task_Type then\n+\n+            --  Task entry\n+\n+            if Is_Primitive_Wrapper (Prim_Op)\n+              and then Ekind (Wrapped_Entity (Prim_Op)) = E_Entry\n+            then\n+               return New_Reference_To (RTE (RE_POK_Task_Entry), Loc);\n+\n+            --  Task \"procedure\". These are the internally Expander-generated\n+            --  procedures (task body for instance).\n+\n+            else\n+               return New_Reference_To (RTE (RE_POK_Task_Procedure), Loc);\n+            end if;\n+\n+         --  Regular procedure\n+\n+         else\n+            return New_Reference_To (RTE (RE_POK_Procedure), Loc);\n+         end if;\n+      end if;\n+   end Prim_Op_Kind;\n+\n    -------------------------\n    -- Set_All_DT_Position --\n    -------------------------\n@@ -2020,6 +3421,7 @@ package body Exp_Disp is\n \n       procedure Validate_Position (Prim : Entity_Id) is\n          Prim_Elmt : Elmt_Id;\n+\n       begin\n          Prim_Elmt :=  First_Elmt (Primitive_Operations (Typ));\n          while Present (Prim_Elmt)\n@@ -2043,7 +3445,40 @@ package body Exp_Disp is\n                null;\n \n             elsif DT_Position (Node (Prim_Elmt)) = DT_Position (Prim) then\n-               raise Program_Error;\n+\n+               --  Handle aliased subprograms\n+\n+               declare\n+                  Op_1 : Entity_Id;\n+                  Op_2 : Entity_Id;\n+\n+               begin\n+                  Op_1 := Node (Prim_Elmt);\n+                  loop\n+                     if Present (Overridden_Operation (Op_1)) then\n+                        Op_1 := Overridden_Operation (Op_1);\n+                     elsif Present (Alias (Op_1)) then\n+                        Op_1 := Alias (Op_1);\n+                     else\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  Op_2 := Prim;\n+                  loop\n+                     if Present (Overridden_Operation (Op_2)) then\n+                        Op_2 := Overridden_Operation (Op_2);\n+                     elsif Present (Alias (Op_2)) then\n+                        Op_2 := Alias (Op_2);\n+                     else\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  if Op_1 /= Op_2 then\n+                     raise Program_Error;\n+                  end if;\n+               end;\n             end if;\n \n             Next_Elmt (Prim_Elmt);\n@@ -2096,9 +3531,10 @@ package body Exp_Disp is\n                --  Get the slot from the parent subprogram if any\n \n                declare\n-                  H : Entity_Id := Homonym (Prim);\n+                  H : Entity_Id;\n \n                begin\n+                  H := Homonym (Prim);\n                   while Present (H) loop\n                      if Present (DTC_Entity (H))\n                        and then Root_Type (Scope (DTC_Entity (H))) = Root_Typ\n@@ -2129,7 +3565,7 @@ package body Exp_Disp is\n          --  Check that the declared size of the Vtable is bigger or equal\n          --  than the number of primitive operations (if bigger it means that\n          --  some of the c++ virtual functions were not imported, that is\n-         --  allowed)\n+         --  allowed).\n \n          if DT_Entry_Count (The_Tag) = No_Uint\n            or else not Is_CPP_Class (Typ)\n@@ -2142,7 +3578,7 @@ package body Exp_Disp is\n          end if;\n \n          --  Check that Positions are not duplicate nor outside the range of\n-         --  the Vtable\n+         --  the Vtable.\n \n          declare\n             Size : constant Int := UI_To_Int (DT_Entry_Count (The_Tag));\n@@ -2175,13 +3611,19 @@ package body Exp_Disp is\n             end loop;\n          end;\n \n+         --  Generate listing showing the contents of the dispatch tables\n+\n+         if Debug_Flag_ZZ then\n+            Write_DT (Typ);\n+         end if;\n+\n       --  For regular Ada tagged types, just set the DT_Position for\n       --  each primitive operation. Perform some sanity checks to avoid\n       --  to build completely inconsistant dispatch tables.\n \n       --  Note that the _Size primitive is always set at position 1 in order\n       --  to comply with the needs of Ada.Tags.Parent_Size (see documentation\n-      --  in a-tags.ad?)\n+      --  in Ada.Tags).\n \n       else\n          --  First stage: Set the DTC entity of all the primitive operations\n@@ -2190,7 +3632,6 @@ package body Exp_Disp is\n \n          Prim_Elmt  := First_Prim;\n          Count_Prim := 0;\n-\n          while Present (Prim_Elmt) loop\n             Count_Prim := Count_Prim + 1;\n             Prim       := Node (Prim_Elmt);\n@@ -2218,16 +3659,17 @@ package body Exp_Disp is\n          end loop;\n \n          declare\n-            Fixed_Prim : array (Int range 0 .. 10 + Parent_EC + Count_Prim)\n-                            of Boolean := (others => False);\n-            E          : Entity_Id;\n+            Fixed_Prim : array (Int range 0 .. Default_Prim_Op_Count +\n+                                  Parent_EC + Count_Prim)\n+                           of Boolean := (others => False);\n+\n+            E : Entity_Id;\n \n          begin\n             --  Second stage: Register fixed entries\n \n-            Nb_Prim   := 10;\n+            Nb_Prim   := Default_Prim_Op_Count;\n             Prim_Elmt := First_Prim;\n-\n             while Present (Prim_Elmt) loop\n                Prim := Node (Prim_Elmt);\n \n@@ -2287,12 +3729,10 @@ package body Exp_Disp is\n                   --  traversing the chain. This is required to properly\n                   --  handling renamed primitives\n \n-                  if Present (Alias (E)) then\n-                     while Present (Alias (E)) loop\n-                        E   := Alias (E);\n-                        Fixed_Prim (UI_To_Int (DT_Position (E))) := True;\n-                     end loop;\n-                  end if;\n+                  while Present (Alias (E)) loop\n+                     E   := Alias (E);\n+                     Fixed_Prim (UI_To_Int (DT_Position (E))) := True;\n+                  end loop;\n                end if;\n \n                Next_Elmt (Prim_Elmt);\n@@ -2369,12 +3809,20 @@ package body Exp_Disp is\n             Next_Elmt (Prim_Elmt);\n          end loop;\n \n+         --  Generate listing showing the contents of the dispatch tables.\n+         --  This action is done before some further static checks because\n+         --  in case of critical errors caused by a wrong dispatch table\n+         --  we need to see the contents of such table.\n+\n+         if Debug_Flag_ZZ then\n+            Write_DT (Typ);\n+         end if;\n+\n          --  Final stage: Ensure that the table is correct plus some further\n          --  verifications concerning the primitives.\n \n          Prim_Elmt := First_Prim;\n          DT_Length := 0;\n-\n          while Present (Prim_Elmt) loop\n             Prim := Node (Prim_Elmt);\n \n@@ -2473,10 +3921,6 @@ package body Exp_Disp is\n             null;\n          end if;\n       end if;\n-\n-      if Debug_Flag_ZZ then\n-         Write_DT (Typ);\n-      end if;\n    end Set_All_DT_Position;\n \n    -----------------------------\n@@ -2546,7 +3990,7 @@ package body Exp_Disp is\n       if not (Typ in First_Node_Id .. Last_Node_Id)\n         or else not Is_Tagged_Type (Typ)\n       then\n-         Write_Str (\"wrong usage: write_dt must be used with tagged types\");\n+         Write_Str (\"wrong usage: Write_DT must be used with tagged types\");\n          Write_Eol;\n          return;\n       end if;"}, {"sha": "469ea79caf84d982f9cb5eb91f186698a927c3a9", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 97, "deletions": 29, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -30,30 +30,69 @@\n with Types; use Types;\n package Exp_Disp is\n \n+   --  Number of predefined primitive operations added by the Expander\n+   --  for a tagged type. If more predefined primitive operations are\n+   --  added, the following items must be changed:\n+\n+   --    Ada.Tags.Defailt_Prim_Op_Count    - indirect use\n+   --    Exp_Disp.Default_Prim_Op_Position - indirect use\n+   --    Exp_Disp.Set_All_DT_Position      - direct   use\n+\n+   Default_Prim_Op_Count : constant Int := 14;\n+\n    type DT_Access_Action is\n       (CW_Membership,\n        IW_Membership,\n        DT_Entry_Size,\n        DT_Prologue_Size,\n        Get_Access_Level,\n+       Get_Entry_Index,\n        Get_External_Tag,\n        Get_Prim_Op_Address,\n+       Get_Prim_Op_Kind,\n        Get_RC_Offset,\n        Get_Remotely_Callable,\n        Inherit_DT,\n        Inherit_TSD,\n        Register_Interface_Tag,\n        Register_Tag,\n        Set_Access_Level,\n+       Set_Entry_Index,\n        Set_Expanded_Name,\n        Set_External_Tag,\n        Set_Prim_Op_Address,\n+       Set_Prim_Op_Kind,\n        Set_RC_Offset,\n        Set_Remotely_Callable,\n        Set_TSD,\n        TSD_Entry_Size,\n        TSD_Prologue_Size);\n \n+   procedure Expand_Dispatching_Call (Call_Node : Node_Id);\n+   --  Expand the call to the operation through the dispatch table and perform\n+   --  the required tag checks when appropriate. For CPP types the call is\n+   --  done through the Vtable (tag checks are not relevant)\n+\n+   procedure Expand_Interface_Actuals    (Call_Node : Node_Id);\n+   --  Ada 2005 (AI-251): Displace all the actuals corresponding to class-wide\n+   --  interfaces to reference the interface tag of the actual object\n+\n+   procedure Expand_Interface_Conversion (N : Node_Id);\n+   --  Ada 2005 (AI-251): N is a type-conversion node. Reference the base of\n+   --  the object to give access to the interface tag associated with the\n+   --  secondary dispatch table\n+\n+   function Expand_Interface_Thunk\n+     (N           : Node_Id;\n+      Thunk_Alias : Node_Id;\n+      Thunk_Id    : Entity_Id;\n+      Thunk_Tag   : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n+   --  generate additional subprograms (thunks) to have a layout compatible\n+   --  with the C++ ABI. The thunk modifies the value of the first actual of\n+   --  the call (that is, the pointer to the object) before transferring\n+   --  control to the target function.\n+\n    function Fill_DT_Entry\n      (Loc          : Source_Ptr;\n       Prim         : Entity_Id) return Node_Id;\n@@ -69,6 +108,15 @@ package Exp_Disp is\n    --  the secondary dispatch table of Prim's controlling type with Thunk_Id's\n    --  address.\n \n+   function Get_Remotely_Callable (Obj : Node_Id) return Node_Id;\n+   --  Return an expression that holds True if the object can be transmitted\n+   --  onto another partition according to E.4 (18)\n+\n+   function Init_Predefined_Interface_Primitives\n+     (Typ : Entity_Id) return List_Id;\n+   --  Ada 2005 (AI-251): Initialize the entries associated with predefined\n+   --  primitives in all the secondary dispatch tables of Typ.\n+\n    procedure Make_Abstract_Interface_DT\n      (AI_Tag          : Entity_Id;\n       Acc_Disp_Tables : in out Elist_Id;\n@@ -90,45 +138,65 @@ package Exp_Disp is\n    --  Expand the declarations for the Dispatch Table (or the Vtable in\n    --  the case of type whose ancestor is a CPP_Class)\n \n+   function Make_Disp_Asynchronous_Select_Body\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n+   --  Typ used for dispatching in asynchronous selects.\n+\n+   function Make_Disp_Asynchronous_Select_Spec\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the specification of the primitive operation\n+   --  of type Typ used for dispatching in asynchronous selects.\n+\n+   function Make_Disp_Conditional_Select_Body\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n+   --  Typ used for dispatching in conditional selects.\n+\n+   function Make_Disp_Conditional_Select_Spec\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the specification of the primitive operation\n+   --  of type Typ used for dispatching in conditional selects.\n+\n+   function Make_Disp_Get_Prim_Op_Kind_Body\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n+   --  Typ used for retrieving the callable entity kind during dispatching in\n+   --  asynchronous selects.\n+\n+   function Make_Disp_Get_Prim_Op_Kind_Spec\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the specification of the primitive operation\n+   --  of the type Typ use for retrieving the callable entity kind during\n+   --  dispatching in asynchronous selects.\n+\n+   function Make_Disp_Select_Tables\n+     (Typ : Entity_Id) return List_Id;\n+   --  Ada 2005 (AI-345): Populate the two auxiliary tables in the TSD of Typ\n+   --  used for dispatching in asynchronous, conditional and timed selects.\n+   --  Generate code to set the primitive operation kinds and entry indices\n+   --  of primitive operations and primitive wrappers.\n+\n+   function Make_Disp_Timed_Select_Body\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n+   --  Typ used for dispatching in timed selects.\n+\n+   function Make_Disp_Timed_Select_Spec\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the specification of the primitive operation\n+   --  of type Typ used for dispatching in timed selects.\n+\n    procedure Set_All_DT_Position (Typ : Entity_Id);\n    --  Set the DT_Position field for each primitive operation. In the CPP\n    --  Class case check that no pragma CPP_Virtual is missing and that the\n    --  DT_Position are coherent\n \n-   procedure Expand_Dispatching_Call (Call_Node : Node_Id);\n-   --  Expand the call to the operation through the dispatch table and perform\n-   --  the required tag checks when appropriate. For CPP types the call is\n-   --  done through the Vtable (tag checks are not relevant)\n-\n-   procedure Expand_Interface_Actuals    (Call_Node : Node_Id);\n-   --  Ada 2005 (AI-251): Displace all the actuals corresponding to class-wide\n-   --  interfaces to reference the interface tag of the actual object\n-\n-   procedure Expand_Interface_Conversion (N : Node_Id);\n-   --  Ada 2005 (AI-251): N is a type-conversion node. Reference the base of\n-   --  the object to give access to the interface tag associated with the\n-   --  secondary dispatch table\n-\n-   function Expand_Interface_Thunk\n-     (N           : Node_Id;\n-      Thunk_Alias : Node_Id;\n-      Thunk_Id    : Entity_Id;\n-      Iface_Tag   : Entity_Id) return Node_Id;\n-   --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n-   --  generate additional subprograms (thunks) to have a layout compatible\n-   --  with the C++ ABI. The thunk modifies the value of the first actual of\n-   --  the call (that is, the pointer to the object) before transferring\n-   --  control to the target function.\n-\n    procedure Set_Default_Constructor (Typ : Entity_Id);\n    --  Typ is a CPP_Class type. Create the Init procedure of that type to\n    --  be the default constructor (i.e. the function returning this type,\n    --  having a pragma CPP_Constructor and no parameter)\n \n-   function Get_Remotely_Callable (Obj : Node_Id) return Node_Id;\n-   --  Return an expression that holds True if the object can be transmitted\n-   --  onto another partition according to E.4 (18)\n-\n    procedure Write_DT (Typ : Entity_Id);\n    pragma Export (Ada, Write_DT);\n    --  Debugging procedure (to be called within gdb)"}, {"sha": "ebef01d303bd694cccf63a1813f1e711bad74dd8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 87, "deletions": 9, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -31,8 +31,6 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch7;  use Exp_Ch7;\n-with Exp_Ch11; use Exp_Ch11;\n-with Exp_Tss;  use Exp_Tss;\n with Hostparm; use Hostparm;\n with Inline;   use Inline;\n with Itypes;   use Itypes;\n@@ -49,7 +47,6 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n@@ -685,7 +682,7 @@ package body Exp_Util is\n       Spec := Make_Function_Specification (Loc,\n         Defining_Unit_Name =>\n           Make_Defining_Identifier (Loc, New_Internal_Name ('F')),\n-        Subtype_Mark => New_Occurrence_Of (Standard_String, Loc));\n+        Result_Definition => New_Occurrence_Of (Standard_String, Loc));\n \n       --  Calls to 'Image use the secondary stack, which must be cleaned\n       --  up after the task name is built.\n@@ -1278,6 +1275,13 @@ package body Exp_Util is\n       then\n          null;\n \n+      --  Nothing to be done if the type of the expression is limited, because\n+      --  in this case the expression cannot be copied, and its use can only\n+      --  be by reference and there is no need for the actual subtype.\n+\n+      elsif Is_Limited_Type (Exp_Typ) then\n+         null;\n+\n       else\n          Remove_Side_Effects (Exp);\n          Rewrite (Subtype_Indic,\n@@ -1409,7 +1413,7 @@ package body Exp_Util is\n            and then Present (Abstract_Interfaces (Typ))\n            and then not (Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n          then\n-            --  Skip the tag associated with the primary table.\n+            --  Skip the tag associated with the primary table\n \n             pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n             AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n@@ -1449,12 +1453,21 @@ package body Exp_Util is\n \n       --  Handle task and protected types implementing interfaces\n \n-      if Ekind (Typ) = E_Protected_Type\n-        or else Ekind (Typ) = E_Task_Type\n-      then\n+      if Is_Concurrent_Type (Typ) then\n          Typ := Corresponding_Record_Type (Typ);\n       end if;\n \n+      if Is_Class_Wide_Type (Typ) then\n+         Typ := Etype (Typ);\n+      end if;\n+\n+      --  Handle entities from the limited view\n+\n+      if Ekind (Typ) = E_Incomplete_Type then\n+         pragma Assert (Present (Non_Limited_View (Typ)));\n+         Typ := Non_Limited_View (Typ);\n+      end if;\n+\n       Find_Tag (Typ);\n       pragma Assert (Found);\n       return AI_Tag;\n@@ -1729,6 +1742,68 @@ package body Exp_Util is\n       return Count;\n    end Homonym_Number;\n \n+   ----------------------------------\n+   -- Implements_Limited_Interface --\n+   ----------------------------------\n+\n+   function Implements_Limited_Interface (Typ : Entity_Id) return Boolean is\n+      function Contains_Limited_Interface\n+        (Ifaces : Elist_Id) return Boolean;\n+      --  Given a list of interfaces, determine whether one of them is limited\n+\n+      --------------------------------\n+      -- Contains_Limited_Interface --\n+      --------------------------------\n+\n+      function Contains_Limited_Interface\n+        (Ifaces : Elist_Id) return Boolean\n+      is\n+         Iface_Elmt : Elmt_Id;\n+\n+      begin\n+         if not Present (Ifaces) then\n+            return False;\n+         end if;\n+\n+         Iface_Elmt := First_Elmt (Ifaces);\n+\n+         while Present (Iface_Elmt) loop\n+            if Is_Limited_Record (Node (Iface_Elmt)) then\n+               return True;\n+            end if;\n+\n+            Iface_Elmt := Next_Elmt (Iface_Elmt);\n+         end loop;\n+\n+         return False;\n+      end Contains_Limited_Interface;\n+\n+   --  Start of processing for Implements_Limited_Interface\n+\n+   begin\n+      --  Typ is a derived type and may implement a limited interface\n+      --  through its parent subtype. Check the parent subtype as well\n+      --  as any interfaces explicitly implemented at this level.\n+\n+      if Ekind (Typ) = E_Record_Type\n+        and then Present (Parent_Subtype (Typ))\n+      then\n+         return Contains_Limited_Interface (Abstract_Interfaces (Typ))\n+           or else Implements_Limited_Interface (Parent_Subtype (Typ));\n+\n+      --  Typ is an abstract type derived from some interface\n+\n+      elsif Is_Abstract (Typ) then\n+         return Is_Interface (Etype (Typ))\n+           and then Is_Limited_Record (Etype (Typ));\n+\n+      --  Typ may directly implement some interface\n+\n+      else\n+         return Contains_Limited_Interface (Abstract_Interfaces (Typ));\n+      end if;\n+   end Implements_Limited_Interface;\n+\n    ------------------------------\n    -- In_Unconditional_Context --\n    ------------------------------\n@@ -2515,6 +2590,10 @@ package body Exp_Util is\n            or else Chars (E) = Name_uAssign\n            or else TSS_Name  = TSS_Deep_Adjust\n            or else TSS_Name  = TSS_Deep_Finalize\n+           or else Chars (E) = Name_uDisp_Asynchronous_Select\n+           or else Chars (E) = Name_uDisp_Conditional_Select\n+           or else Chars (E) = Name_uDisp_Get_Prim_Op_Kind\n+           or else Chars (E) = Name_uDisp_Timed_Select\n          then\n             return True;\n          end if;\n@@ -2919,7 +2998,6 @@ package body Exp_Util is\n    procedure Kill_Dead_Code (N : Node_Id) is\n    begin\n       if Present (N) then\n-         Remove_Handler_Entries (N);\n          Remove_Warning_Messages (N);\n \n          --  Recurse into block statements and bodies to process declarations"}, {"sha": "a63cc71c09b61bb40307eb793d4b8de33b2ea9e1", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -410,6 +410,12 @@ package Exp_Util is\n    --  chain, counting only entries in the curren scope. If an entity is not\n    --  overloaded, the returned number will be one.\n \n+   function Implements_Limited_Interface (Typ : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-345): Determine whether Typ implements some limited\n+   --  interface. The interface may be of limited, protected, synchronized\n+   --  or taks kind. Typ may also be derived from a type that implements a\n+   --  limited interface.\n+\n    function Inside_Init_Proc return Boolean;\n    --  Returns True if current scope is within an init proc\n "}, {"sha": "07adc39757a53a7f5a2acd608e37025b3f12c405", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -108,7 +108,7 @@ package Rtsfind is\n       --  package see declarations in the runtime entity table below.\n \n       RTU_Null,\n-      --  Used as a null entry. Will cause an error if referenced.\n+      --  Used as a null entry. Will cause an error if referenced\n \n       --  Children of Ada\n \n@@ -199,7 +199,6 @@ package Rtsfind is\n       System_Compare_Array_Unsigned_64,\n       System_Compare_Array_Unsigned_8,\n       System_Exception_Table,\n-      System_Exceptions,\n       System_Exn_Int,\n       System_Exn_LLF,\n       System_Exn_LLI,\n@@ -492,21 +491,33 @@ package Rtsfind is\n      RE_DT_Prologue_Size,                -- Ada.Tags\n      RE_External_Tag,                    -- Ada.Tags\n      RE_Get_Access_Level,                -- Ada.Tags\n+     RE_Get_Entry_Index,                 -- Ada.Tags\n      RE_Get_External_Tag,                -- Ada.Tags\n      RE_Get_Prim_Op_Address,             -- Ada.Tags\n+     RE_Get_Prim_Op_Kind,                -- Ada.Tags\n      RE_Get_RC_Offset,                   -- Ada.Tags\n      RE_Get_Remotely_Callable,           -- Ada.Tags\n      RE_Inherit_DT,                      -- Ada.Tags\n      RE_Inherit_TSD,                     -- Ada.Tags\n      RE_Internal_Tag,                    -- Ada.Tags\n      RE_Is_Descendant_At_Same_Level,     -- Ada.Tags\n+     RE_POK_Function,                    -- Ada.Tags\n+     RE_POK_Procedure,                   -- Ada.Tags\n+     RE_POK_Protected_Entry,             -- Ada.Tags\n+     RE_POK_Protected_Function,          -- Ada.Tags\n+     RE_POK_Protected_Procedure,         -- Ada.Tags\n+     RE_POK_Task_Entry,                  -- Ada.Tags\n+     RE_POK_Task_Procedure,              -- Ada.Tags\n+     RE_Prim_Op_Kind,                    -- Ada.Tags\n      RE_Register_Interface_Tag,          -- Ada.Tags\n      RE_Register_Tag,                    -- Ada.Tags\n      RE_Set_Access_Level,                -- Ada.Tags\n+     RE_Set_Entry_Index,                 -- Ada.Tags\n      RE_Set_Expanded_Name,               -- Ada.Tags\n      RE_Set_External_Tag,                -- Ada.Tags\n      RE_Set_Offset_To_Top,               -- Ada.Tags\n      RE_Set_Prim_Op_Address,             -- Ada.Tags\n+     RE_Set_Prim_Op_Kind,                -- Ada.Tags\n      RE_Set_RC_Offset,                   -- Ada.Tags\n      RE_Set_Remotely_Callable,           -- Ada.Tags\n      RE_Set_TSD,                         -- Ada.Tags\n@@ -639,20 +650,6 @@ package Rtsfind is\n \n      RE_Register_Exception,              -- System.Exception_Table\n \n-     RE_All_Others_Id,                   -- System.Exceptions\n-     RE_Handler_Record,                  -- System.Exceptions\n-     RE_Handler_Record_Ptr,              -- System.Exceptions\n-     RE_Others_Id,                       -- System.Exceptions\n-     RE_Subprogram_Descriptor,           -- System.Exceptions\n-     RE_Subprogram_Descriptor_0,         -- System.Exceptions\n-     RE_Subprogram_Descriptor_1,         -- System.Exceptions\n-     RE_Subprogram_Descriptor_2,         -- System.Exceptions\n-     RE_Subprogram_Descriptor_3,         -- System.Exceptions\n-     RE_Subprogram_Descriptor_List,      -- System.Exceptions\n-     RE_Subprogram_Descriptor_Ptr,       -- System.Exceptions\n-     RE_Subprogram_Descriptors_Record,   -- System.Exceptions\n-     RE_Subprogram_Descriptors_Ptr,      -- System.Exceptions\n-\n      RE_Exn_Integer,                     -- System.Exn_Int\n \n      RE_Exn_Long_Long_Float,             -- System.Exn_LLF\n@@ -1421,6 +1418,10 @@ package Rtsfind is\n      RE_Lt_F,                            -- System.Vax_Float_Operations\n      RE_Lt_G,                            -- System.Vax_Float_Operations\n \n+     RE_Valid_D,                         -- System.Vax_Float_Operations\n+     RE_Valid_F,                         -- System.Vax_Float_Operations\n+     RE_Valid_G,                         -- System.Vax_Float_Operations\n+\n      RE_Version_String,                  -- System.Version_Control\n      RE_Get_Version_String,              -- System.Version_Control\n \n@@ -1599,21 +1600,33 @@ package Rtsfind is\n      RE_DT_Prologue_Size                 => Ada_Tags,\n      RE_External_Tag                     => Ada_Tags,\n      RE_Get_Access_Level                 => Ada_Tags,\n+     RE_Get_Entry_Index                  => Ada_Tags,\n      RE_Get_External_Tag                 => Ada_Tags,\n      RE_Get_Prim_Op_Address              => Ada_Tags,\n+     RE_Get_Prim_Op_Kind                 => Ada_Tags,\n      RE_Get_RC_Offset                    => Ada_Tags,\n      RE_Get_Remotely_Callable            => Ada_Tags,\n      RE_Inherit_DT                       => Ada_Tags,\n      RE_Inherit_TSD                      => Ada_Tags,\n      RE_Internal_Tag                     => Ada_Tags,\n      RE_Is_Descendant_At_Same_Level      => Ada_Tags,\n+     RE_POK_Function                     => Ada_Tags,\n+     RE_POK_Procedure                    => Ada_Tags,\n+     RE_POK_Protected_Entry              => Ada_Tags,\n+     RE_POK_Protected_Function           => Ada_Tags,\n+     RE_POK_Protected_Procedure          => Ada_Tags,\n+     RE_POK_Task_Entry                   => Ada_Tags,\n+     RE_POK_Task_Procedure               => Ada_Tags,\n+     RE_Prim_Op_Kind                     => Ada_Tags,\n      RE_Register_Interface_Tag           => Ada_Tags,\n      RE_Register_Tag                     => Ada_Tags,\n      RE_Set_Access_Level                 => Ada_Tags,\n+     RE_Set_Entry_Index                  => Ada_Tags,\n      RE_Set_Expanded_Name                => Ada_Tags,\n      RE_Set_External_Tag                 => Ada_Tags,\n      RE_Set_Offset_To_Top                => Ada_Tags,\n      RE_Set_Prim_Op_Address              => Ada_Tags,\n+     RE_Set_Prim_Op_Kind                 => Ada_Tags,\n      RE_Set_RC_Offset                    => Ada_Tags,\n      RE_Set_Remotely_Callable            => Ada_Tags,\n      RE_Set_TSD                          => Ada_Tags,\n@@ -1744,20 +1757,6 @@ package Rtsfind is\n \n      RE_Register_Exception               => System_Exception_Table,\n \n-     RE_All_Others_Id                    => System_Exceptions,\n-     RE_Handler_Record                   => System_Exceptions,\n-     RE_Handler_Record_Ptr               => System_Exceptions,\n-     RE_Others_Id                        => System_Exceptions,\n-     RE_Subprogram_Descriptor            => System_Exceptions,\n-     RE_Subprogram_Descriptor_0          => System_Exceptions,\n-     RE_Subprogram_Descriptor_1          => System_Exceptions,\n-     RE_Subprogram_Descriptor_2          => System_Exceptions,\n-     RE_Subprogram_Descriptor_3          => System_Exceptions,\n-     RE_Subprogram_Descriptor_List       => System_Exceptions,\n-     RE_Subprogram_Descriptor_Ptr        => System_Exceptions,\n-     RE_Subprogram_Descriptors_Record    => System_Exceptions,\n-     RE_Subprogram_Descriptors_Ptr       => System_Exceptions,\n-\n      RE_Exn_Integer                      => System_Exn_Int,\n \n      RE_Exn_Long_Long_Float              => System_Exn_LLF,\n@@ -2525,6 +2524,10 @@ package Rtsfind is\n      RE_Lt_F                             => System_Vax_Float_Operations,\n      RE_Lt_G                             => System_Vax_Float_Operations,\n \n+     RE_Valid_D                          => System_Vax_Float_Operations,\n+     RE_Valid_F                          => System_Vax_Float_Operations,\n+     RE_Valid_G                          => System_Vax_Float_Operations,\n+\n      RE_Version_String                   => System_Version_Control,\n      RE_Get_Version_String               => System_Version_Control,\n \n@@ -2805,7 +2808,7 @@ package Rtsfind is\n    --  not mean that an attempt to load it subsequently would fail.\n \n    procedure Set_RTU_Loaded (N : Node_Id);\n-   --  Register the predefined unit N as already loaded.\n+   --  Register the predefined unit N as already loaded\n \n    procedure Text_IO_Kludge (Nam : Node_Id);\n    --  In Ada 83, and hence for compatibility in Ada 9X, package Text_IO has"}, {"sha": "190706c4e11537976ffcc5fa0237d648889341bd", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -1924,8 +1924,25 @@ package body Sem_Ch9 is\n         and then Nkind (Trigger) /= N_Delay_Relative_Statement\n         and then Nkind (Trigger) /= N_Entry_Call_Statement\n       then\n-         Error_Msg_N\n-          (\"triggering statement must be delay or entry call\", Trigger);\n+         if Ada_Version < Ada_05 then\n+            Error_Msg_N\n+             (\"triggering statement must be delay or entry call\", Trigger);\n+\n+         --  Ada 2005 (AI-345): If a procedure_call_statement is used\n+         --  for a procedure_or_entry_call, the procedure_name or pro-\n+         --  cedure_prefix of the procedure_call_statement shall denote\n+         --  an entry renamed by a procedure, or (a view of) a primitive\n+         --  subprogram of a limited interface whose first parameter is\n+         --  a controlling parameter.\n+\n+         elsif Nkind (Trigger) = N_Procedure_Call_Statement\n+           and then not Is_Renamed_Entry (Entity (Name (Trigger)))\n+           and then not Is_Controlling_Limited_Procedure\n+                          (Entity (Name (Trigger)))\n+         then\n+            Error_Msg_N (\"triggering statement must be delay, procedure \" &\n+                         \"or entry call\", Trigger);\n+         end if;\n       end if;\n \n       if Is_Non_Empty_List (Statements (N)) then\n@@ -2211,8 +2228,8 @@ package body Sem_Ch9 is\n                     and then Matches_Prefixed_View_Profile (Ifaces,\n                                Parameter_Specifications (Spec),\n                                Parameter_Specifications (Parent (Hom)))\n-                    and then Etype (Subtype_Mark (Spec)) =\n-                             Etype (Subtype_Mark (Parent (Hom)))\n+                    and then Etype (Result_Definition (Spec)) =\n+                             Etype (Result_Definition (Parent (Hom)))\n                   then\n                      Overrides := True;\n                      exit;"}, {"sha": "5a340b39968fa4b2493915e2671ad5370f6e5ae2", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b93b2ef042757e76a53294442789b22c39599e/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=10b93b2ef042757e76a53294442789b22c39599e", "patch": "@@ -64,7 +64,10 @@ package Uintp is\n    Uint_8   : constant Uint;\n    Uint_9   : constant Uint;\n    Uint_10  : constant Uint;\n+   Uint_11  : constant Uint;\n    Uint_12  : constant Uint;\n+   Uint_13  : constant Uint;\n+   Uint_14  : constant Uint;\n    Uint_15  : constant Uint;\n    Uint_16  : constant Uint;\n    Uint_24  : constant Uint;\n@@ -430,7 +433,10 @@ private\n    Uint_8   : constant Uint := Uint (Uint_Direct_Bias + 8);\n    Uint_9   : constant Uint := Uint (Uint_Direct_Bias + 9);\n    Uint_10  : constant Uint := Uint (Uint_Direct_Bias + 10);\n+   Uint_11  : constant Uint := Uint (Uint_Direct_Bias + 11);\n    Uint_12  : constant Uint := Uint (Uint_Direct_Bias + 12);\n+   Uint_13  : constant Uint := Uint (Uint_Direct_Bias + 13);\n+   Uint_14  : constant Uint := Uint (Uint_Direct_Bias + 14);\n    Uint_15  : constant Uint := Uint (Uint_Direct_Bias + 15);\n    Uint_16  : constant Uint := Uint (Uint_Direct_Bias + 16);\n    Uint_24  : constant Uint := Uint (Uint_Direct_Bias + 24);"}]}