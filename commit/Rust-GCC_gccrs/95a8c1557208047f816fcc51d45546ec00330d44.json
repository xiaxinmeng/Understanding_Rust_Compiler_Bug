{"sha": "95a8c1557208047f816fcc51d45546ec00330d44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVhOGMxNTU3MjA4MDQ3ZjgxNmZjYzUxZDQ1NTQ2ZWMwMDMzMGQ0NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-07-22T00:33:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-07-22T00:33:46Z"}, "message": "re PR tree-optimization/22504 (benchmark - galgel fails at runtime with miscompare output)\n\n        PR tree-opt/22504\n        * tree-complex.c (complex_ssa_name_components): New.\n        (cvc_lookup): Allow entry not found.\n        (create_components): Remove.\n        (create_one_component_var, get_component_var): New.\n        (get_component_ssa_name, set_component_ssa_name): New.\n        (extract_component): Use get_component_ssa_name.\n        (update_complex_components): Use set_component_ssa_name.\n        (update_complex_components_on_edge): Likewise.\n        (update_phi_components): Create new PHI nodes directly, instead\n        of adding insns to edges.\n        (tree_lower_complex): Allocate and free complex_variable_components\n        and complex_ssa_name_components here.\n\nFrom-SVN: r102260", "tree": {"sha": "3f46072ade0726fb9ddcd16e81401641ff9ea1c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f46072ade0726fb9ddcd16e81401641ff9ea1c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95a8c1557208047f816fcc51d45546ec00330d44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a8c1557208047f816fcc51d45546ec00330d44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95a8c1557208047f816fcc51d45546ec00330d44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a8c1557208047f816fcc51d45546ec00330d44/comments", "author": null, "committer": null, "parents": [{"sha": "f3cd1ce2f2ab74141ff54ba29d7c433bc76265a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3cd1ce2f2ab74141ff54ba29d7c433bc76265a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3cd1ce2f2ab74141ff54ba29d7c433bc76265a0"}], "stats": {"total": 349, "additions": 223, "deletions": 126}, "files": [{"sha": "0db59f138ef0a60801a270087e33934123e2c6ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a8c1557208047f816fcc51d45546ec00330d44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a8c1557208047f816fcc51d45546ec00330d44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95a8c1557208047f816fcc51d45546ec00330d44", "patch": "@@ -1,3 +1,19 @@\n+2005-07-21  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/22504\n+\t* tree-complex.c (complex_ssa_name_components): New.\n+\t(cvc_lookup): Allow entry not found.\n+\t(create_components): Remove.\n+\t(create_one_component_var, get_component_var): New.\n+\t(get_component_ssa_name, set_component_ssa_name): New.\n+\t(extract_component): Use get_component_ssa_name.\n+\t(update_complex_components): Use set_component_ssa_name.\n+\t(update_complex_components_on_edge): Likewise.\n+\t(update_phi_components): Create new PHI nodes directly, instead\n+\tof adding insns to edges.\n+\t(tree_lower_complex): Allocate and free complex_variable_components\n+\tand complex_ssa_name_components here.\n+\n 2005-07-20  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \t* alias.c (nonoverlapping_component_refs_p): Use TYPE_MAIN_VARIANT,"}, {"sha": "63295fe40164c3d77defe66c8983496e327a46af", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 207, "deletions": 126, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a8c1557208047f816fcc51d45546ec00330d44/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a8c1557208047f816fcc51d45546ec00330d44/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=95a8c1557208047f816fcc51d45546ec00330d44", "patch": "@@ -56,6 +56,9 @@ static VEC(complex_lattice_t, heap) *complex_lattice_values;\n    the hashtable.  */\n static htab_t complex_variable_components;\n \n+/* For each complex SSA_NAME, a pair of ssa names for the components.  */\n+static VEC(tree, heap) *complex_ssa_name_components;\n+\n /* Lookup UID in the complex_variable_components hashtable and return the\n    associated tree.  */\n static tree \n@@ -64,8 +67,7 @@ cvc_lookup (unsigned int uid)\n   struct int_tree_map *h, in;\n   in.uid = uid;\n   h = htab_find_with_hash (complex_variable_components, &in, uid);\n-  gcc_assert (h);\n-  return h->to;\n+  return h ? h->to : NULL;\n }\n  \n /* Insert the pair UID, TO into the complex_variable_components hashtable.  */\n@@ -81,10 +83,9 @@ cvc_insert (unsigned int uid, tree to)\n   h->to = to;\n   loc = htab_find_slot_with_hash (complex_variable_components, h,\n \t\t\t\t  uid, INSERT);\n-  *(struct int_tree_map **)  loc = h;\n+  *(struct int_tree_map **) loc = h;\n }\n \n-\n /* Return true if T is not a zero constant.  In the case of real values,\n    we're only interested in +0.0.  */\n \n@@ -378,72 +379,165 @@ complex_visit_phi (tree phi)\n   return new_l == VARYING ? SSA_PROP_VARYING : SSA_PROP_INTERESTING;\n }\n \n-/* For each referenced complex gimple register, set up a pair of registers\n-   to hold the components of the complex value.  */\n+/* Create one backing variable for a complex component of ORIG.  */\n \n-static void\n-create_components (void)\n+static tree\n+create_one_component_var (tree type, tree orig, const char *prefix,\n+\t\t\t  const char *suffix, enum tree_code code)\n {\n-  size_t n;\n-  tree var;\n-  safe_referenced_var_iterator rvi;\n-  VEC (tree, heap) *refvars;\n+  tree r = create_tmp_var (type, prefix);\n+  add_referenced_tmp_var (r);\n \n-  n = num_referenced_vars;\n-  if (n == 0)\n-    return;\n+  DECL_SOURCE_LOCATION (r) = DECL_SOURCE_LOCATION (orig);\n+  DECL_ARTIFICIAL (r) = 1;\n \n-  complex_variable_components = htab_create (10,  int_tree_map_hash,\n-\t\t\t\t\t     int_tree_map_eq, free);\n+  if (DECL_NAME (orig) && !DECL_IGNORED_P (orig))\n+    {\n+      const char *name = IDENTIFIER_POINTER (DECL_NAME (orig));\n+      tree inner_type;\n+\n+      DECL_NAME (r) = get_identifier (ACONCAT ((name, suffix, NULL)));\n \n-  FOR_EACH_REFERENCED_VAR_SAFE (var, refvars, rvi)\n+      inner_type = TREE_TYPE (TREE_TYPE (orig));\n+      SET_DECL_DEBUG_EXPR (r, build1 (code, type, orig));\n+      DECL_DEBUG_EXPR_IS_FROM (r) = 1;\n+      DECL_IGNORED_P (r) = 0;\n+      TREE_NO_WARNING (r) = TREE_NO_WARNING (orig);\n+    }\n+  else\n     {\n-      tree r = NULL, i = NULL;\n+      DECL_IGNORED_P (r) = 1;\n+      TREE_NO_WARNING (r) = 1;\n+    }\n \n-      if (var != NULL\n-\t  && TREE_CODE (TREE_TYPE (var)) == COMPLEX_TYPE\n-\t  && is_gimple_reg (var))\n-\t{\n-\t  tree inner_type = TREE_TYPE (TREE_TYPE (var));\n+  return r;\n+}\n \n-\t  r = make_rename_temp (inner_type, \"CR\");\n-\t  i = make_rename_temp (inner_type, \"CI\");\n-\t  DECL_SOURCE_LOCATION (r) = DECL_SOURCE_LOCATION (var);\n-\t  DECL_SOURCE_LOCATION (i) = DECL_SOURCE_LOCATION (var);\n-\t  DECL_ARTIFICIAL (r) = 1;\n-\t  DECL_ARTIFICIAL (i) = 1;\n+/* Retrieve a value for a complex component of VAR.  */\n \n-\t  if (DECL_NAME (var) && !DECL_IGNORED_P (var))\n-\t    {\n-\t      const char *name = IDENTIFIER_POINTER (DECL_NAME (var));\n+static tree\n+get_component_var (tree var, bool imag_p)\n+{\n+  size_t decl_index = DECL_UID (var) * 2 + imag_p;\n+  tree ret = cvc_lookup (decl_index);\n+\n+  if (ret == NULL)\n+    {\n+      ret = create_one_component_var (TREE_TYPE (TREE_TYPE (var)), var,\n+\t\t\t\t      imag_p ? \"CI\" : \"CR\",\n+\t\t\t\t      imag_p ? \"$imag\" : \"$real\",\n+\t\t\t\t      imag_p ? IMAGPART_EXPR : REALPART_EXPR);\n+      cvc_insert (decl_index, ret);\n+    }\n+\n+  return ret;\n+}\n \n-\t      DECL_NAME (r) = get_identifier (ACONCAT ((name, \"$real\", NULL)));\n-\t      DECL_NAME (i) = get_identifier (ACONCAT ((name, \"$imag\", NULL)));\n+/* Retrieve a value for a complex component of SSA_NAME.  */\n \n-\t      SET_DECL_DEBUG_EXPR (r, build1 (REALPART_EXPR, inner_type, var));\n-\t      SET_DECL_DEBUG_EXPR (i, build1 (IMAGPART_EXPR, inner_type, var));\n-\t      DECL_DEBUG_EXPR_IS_FROM (r) = 1;\n-\t      DECL_DEBUG_EXPR_IS_FROM (i) = 1;\n+static tree\n+get_component_ssa_name (tree ssa_name, bool imag_p)\n+{\n+  complex_lattice_t lattice = find_lattice_value (ssa_name);\n+  size_t ssa_name_index;\n+  tree ret;\n \n-\t      DECL_IGNORED_P (r) = 0;\n-\t      DECL_IGNORED_P (i) = 0;\n+  if (lattice == (imag_p ? ONLY_REAL : ONLY_IMAG))\n+    {\n+      tree inner_type = TREE_TYPE (TREE_TYPE (ssa_name));\n+      if (SCALAR_FLOAT_TYPE_P (inner_type))\n+\treturn build_real (inner_type, dconst0);\n+      else\n+\treturn build_int_cst (inner_type, 0);\n+    }\n \n-\t      TREE_NO_WARNING (r) = TREE_NO_WARNING (var);\n-\t      TREE_NO_WARNING (i) = TREE_NO_WARNING (var);\n-\t    }\n-\t  else\n-\t    {\n-\t      DECL_IGNORED_P (r) = 1;\n-\t      DECL_IGNORED_P (i) = 1;\n-\t      TREE_NO_WARNING (r) = 1;\n-\t      TREE_NO_WARNING (i) = 1;\n-\t    }\n+  ssa_name_index = SSA_NAME_VERSION (ssa_name) * 2 + imag_p;\n+  ret = VEC_index (tree, complex_ssa_name_components, ssa_name_index);\n+  if (ret == NULL)\n+    {\n+      ret = get_component_var (SSA_NAME_VAR (ssa_name), imag_p);\n+      ret = make_ssa_name (ret, NULL);\n+\n+      /* Copy some properties from the original.  In particular, whether it\n+\t is used in an abnormal phi, and whether it's uninitialized.  */\n+      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ret)\n+\t= SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssa_name);\n+      if (TREE_CODE (SSA_NAME_VAR (ssa_name)) == VAR_DECL\n+\t  && IS_EMPTY_STMT (SSA_NAME_DEF_STMT (ssa_name)))\n+\t{\n+\t  SSA_NAME_DEF_STMT (ret) = SSA_NAME_DEF_STMT (ssa_name);\n+\t  set_default_def (SSA_NAME_VAR (ret), ret);\n \t}\n \n-      cvc_insert (2 * DECL_UID (var), r);\n-      cvc_insert (2 * DECL_UID (var) + 1, i);\n+      VEC_replace (tree, complex_ssa_name_components, ssa_name_index, ret);\n     }\n-  VEC_free (tree, heap, refvars);\n+\n+  return ret;\n+}\n+\n+/* Set a value for a complex component of SSA_NAME, return a STMT_LIST of\n+   stuff that needs doing.  */\n+\n+static tree\n+set_component_ssa_name (tree ssa_name, bool imag_p, tree value)\n+{\n+  complex_lattice_t lattice = find_lattice_value (ssa_name);\n+  size_t ssa_name_index;\n+  tree comp, list, last;\n+\n+  /* We know the value must be zero, else there's a bug in our lattice\n+     analysis.  But the value may well be a variable known to contain\n+     zero.  We should be safe ignoring it.  */\n+  if (lattice == (imag_p ? ONLY_REAL : ONLY_IMAG))\n+    return NULL;\n+\n+  /* If we've already assigned an SSA_NAME to this component, then this\n+     means that our walk of the basic blocks found a use before the set.\n+     This is fine.  Now we should create an initialization for the value\n+     we created earlier.  */\n+  ssa_name_index = SSA_NAME_VERSION (ssa_name) * 2 + imag_p;\n+  comp = VEC_index (tree, complex_ssa_name_components, ssa_name_index);\n+  if (comp)\n+    ;\n+\n+  /* If we've nothing assigned, and the value we're given is already stable,\n+     then install that as the value for this SSA_NAME.  This pre-emptively\n+     copy-propagates the value, which avoids unnecessary memory allocation.  */\n+  else if (is_gimple_min_invariant (value))\n+    {\n+      VEC_replace (tree, complex_ssa_name_components, ssa_name_index, value);\n+      return NULL;\n+    }\n+  else if (TREE_CODE (value) == SSA_NAME\n+\t   && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssa_name))\n+    {\n+      /* Replace an anonymous base value with the variable from cvc_lookup.\n+\t This should result in better debug info.  */\n+      if (DECL_IGNORED_P (SSA_NAME_VAR (value))\n+\t  && !DECL_IGNORED_P (SSA_NAME_VAR (ssa_name)))\n+\t{\n+\t  comp = get_component_var (SSA_NAME_VAR (ssa_name), imag_p);\n+\t  SSA_NAME_VAR (value) = comp;\n+\t}\n+\n+      VEC_replace (tree, complex_ssa_name_components, ssa_name_index, value);\n+      return NULL;\n+    }\n+\n+  /* Finally, we need to stabilize the result by installing the value into\n+     a new ssa name.  */\n+  else\n+    comp = get_component_ssa_name (ssa_name, imag_p);\n+  \n+  /* Do all the work to assign VALUE to COMP.  */\n+  value = force_gimple_operand (value, &list, false, NULL);\n+  last = build2 (MODIFY_EXPR, TREE_TYPE (comp), comp, value);\n+  append_to_statement_list (last, &list);\n+\n+  gcc_assert (SSA_NAME_DEF_STMT (comp) == NULL);\n+  SSA_NAME_DEF_STMT (comp) = last;\n+\n+  return list;\n }\n \n /* Extract the real or imaginary part of a complex variable or constant.\n@@ -480,24 +574,7 @@ extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p,\n       }\n \n     case SSA_NAME:\n-      {\n-\ttree def = SSA_NAME_DEF_STMT (t);\n-\n-\tif (TREE_CODE (def) == MODIFY_EXPR)\n-\t  {\n-\t    def = TREE_OPERAND (def, 1);\n-\t    if (TREE_CODE (def) == COMPLEX_CST)\n-\t      return imagpart_p ? TREE_IMAGPART (def) : TREE_REALPART (def);\n-\t    if (TREE_CODE (def) == COMPLEX_EXPR)\n-\t      {\n-\t\tdef = TREE_OPERAND (def, imagpart_p);\n-\t\tif (TREE_CONSTANT (def))\n-\t\t  return def;\n-\t      }\n-\t  }\n-\n-\treturn cvc_lookup (DECL_UID (SSA_NAME_VAR (t)) * 2 + imagpart_p);\n-      }\n+      return get_component_ssa_name (t, imagpart_p);\n \n     default:\n       gcc_unreachable ();\n@@ -509,45 +586,30 @@ extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p,\n static void\n update_complex_components (block_stmt_iterator *bsi, tree stmt, tree r, tree i)\n {\n-  unsigned int uid = DECL_UID (SSA_NAME_VAR (TREE_OPERAND (stmt, 0)));\n-  tree v, x;\n-\n-  v = cvc_lookup (2*uid);\n-  x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, r);\n-  SET_EXPR_LOCUS (x, EXPR_LOCUS (stmt));\n-  TREE_BLOCK (x) = TREE_BLOCK (stmt);\n-  bsi_insert_after (bsi, x, BSI_NEW_STMT);\n-\n-  v = cvc_lookup (2*uid + 1);\n-  x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, i);\n-  SET_EXPR_LOCUS (x, EXPR_LOCUS (stmt));\n-  TREE_BLOCK (x) = TREE_BLOCK (stmt);\n-  bsi_insert_after (bsi, x, BSI_NEW_STMT);\n+  tree lhs = TREE_OPERAND (stmt, 0);\n+  tree list;\n+\n+  list = set_component_ssa_name (lhs, false, r);\n+  if (list)\n+    bsi_insert_after (bsi, list, BSI_CONTINUE_LINKING);\n+\n+  list = set_component_ssa_name (lhs, true, i);\n+  if (list)\n+    bsi_insert_after (bsi, list, BSI_CONTINUE_LINKING);\n }\n \n static void\n-update_complex_components_on_edge (edge e, tree stmt, tree lhs, tree r, tree i)\n+update_complex_components_on_edge (edge e, tree lhs, tree r, tree i)\n {\n-  unsigned int uid = DECL_UID (SSA_NAME_VAR (lhs));\n-  tree v, x;\n+  tree list;\n \n-  v = cvc_lookup (2*uid);\n-  x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, r);\n-  if (stmt)\n-    {\n-      SET_EXPR_LOCUS (x, EXPR_LOCUS (stmt));\n-      TREE_BLOCK (x) = TREE_BLOCK (stmt);\n-    }\n-  bsi_insert_on_edge (e, x);\n+  list = set_component_ssa_name (lhs, false, r);\n+  if (list)\n+    bsi_insert_on_edge (e, list);\n \n-  v = cvc_lookup (2*uid + 1);\n-  x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, i);\n-  if (stmt)\n-    {\n-      SET_EXPR_LOCUS (x, EXPR_LOCUS (stmt));\n-      TREE_BLOCK (x) = TREE_BLOCK (stmt);\n-    }\n-  bsi_insert_on_edge (e, x);\n+  list = set_component_ssa_name (lhs, true, i);\n+  if (list)\n+    bsi_insert_on_edge (e, list);\n }\n \n /* Update an assignment to a complex variable in place.  */\n@@ -591,7 +653,7 @@ update_parameter_components (void)\n \n       r = build1 (REALPART_EXPR, type, ssa_name);\n       i = build1 (IMAGPART_EXPR, type, ssa_name);\n-      update_complex_components_on_edge (entry_edge, NULL, ssa_name, r, i);\n+      update_complex_components_on_edge (entry_edge, ssa_name, r, i);\n     }\n }\n \n@@ -606,24 +668,36 @@ update_phi_components (basic_block bb)\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     if (is_complex_reg (PHI_RESULT (phi)))\n       {\n+\ttree lr, li, pr = NULL, pi = NULL;\n \tunsigned int i, n;\n-\ttree lhs = PHI_RESULT (phi);\n \n+\tlr = get_component_ssa_name (PHI_RESULT (phi), false);\n+\tif (TREE_CODE (lr) == SSA_NAME)\n+\t  {\n+\t    pr = create_phi_node (lr, bb);\n+\t    SSA_NAME_DEF_STMT (lr) = pr;\n+\t  }\n+\n+\tli = get_component_ssa_name (PHI_RESULT (phi), true);\n+\tif (TREE_CODE (li) == SSA_NAME)\n+\t  {\n+\t    pi = create_phi_node (li, bb);\n+\t    SSA_NAME_DEF_STMT (li) = pi;\n+\t  }\n+\t\n \tfor (i = 0, n = PHI_NUM_ARGS (phi); i < n; ++i)\n \t  {\n-\t    edge e = PHI_ARG_EDGE (phi, i);\n-\t    tree arg = PHI_ARG_DEF (phi, i);\n-\t    tree r, i;\n-\n-\t    /* Avoid no-op assignments.  This also prevents insertting stmts\n-\t       onto abnormal edges, assuming the PHI isn't already broken.  */\n-\t    if (TREE_CODE (arg) == SSA_NAME\n-\t\t&& SSA_NAME_VAR (arg) == SSA_NAME_VAR (lhs))\n-\t      continue;\n-\n-\t    r = extract_component (NULL, arg, 0, false);\n-\t    i = extract_component (NULL, arg, 1, false);\n-\t    update_complex_components_on_edge (e, NULL, lhs, r, i);\n+\t    tree comp, arg = PHI_ARG_DEF (phi, i);\n+\t    if (pr)\n+\t      {\n+\t\tcomp = extract_component (NULL, arg, false, false);\n+\t\tSET_PHI_ARG_DEF (pr, i, comp);\n+\t      }\n+\t    if (pi)\n+\t      {\n+\t\tcomp = extract_component (NULL, arg, true, false);\n+\t\tSET_PHI_ARG_DEF (pi, i, comp);\n+\t      }\n \t  }\n       }\n }\n@@ -671,7 +745,7 @@ expand_complex_move (block_stmt_iterator *bsi, tree stmt, tree type,\n \n \t  r = build1 (REALPART_EXPR, inner_type, lhs);\n \t  i = build1 (IMAGPART_EXPR, inner_type, lhs);\n-\t  update_complex_components_on_edge (e, stmt, lhs, r, i);\n+\t  update_complex_components_on_edge (e, lhs, r, i);\n \t}\n       else if (TREE_CODE (rhs) == CALL_EXPR || TREE_SIDE_EFFECTS (rhs))\n \t{\n@@ -1419,13 +1493,21 @@ tree_lower_complex (void)\n \t\t complex_lattice_values, num_ssa_names);\n   memset (VEC_address (complex_lattice_t, complex_lattice_values), 0,\n \t  num_ssa_names * sizeof(complex_lattice_t));\n-  init_parameter_lattice_values ();\n \n+  init_parameter_lattice_values ();\n   ssa_propagate (complex_visit_stmt, complex_visit_phi);\n \n-  create_components ();\n+  complex_variable_components = htab_create (10,  int_tree_map_hash,\n+\t\t\t\t\t     int_tree_map_eq, free);\n+\n+  complex_ssa_name_components = VEC_alloc (tree, heap, 2*num_ssa_names);\n+  VEC_safe_grow (tree, heap, complex_ssa_name_components, 2*num_ssa_names);\n+  memset (VEC_address (tree, complex_ssa_name_components), 0,\n+\t  2 * num_ssa_names * sizeof(tree));\n+\n   update_parameter_components ();\n \n+  /* ??? Ideally we'd traverse the blocks in breadth-first order.  */\n   old_last_basic_block = last_basic_block;\n   FOR_EACH_BB (bb)\n     {\n@@ -1438,9 +1520,8 @@ tree_lower_complex (void)\n \n   bsi_commit_edge_inserts ();\n \n-  if (complex_variable_components)\n-    htab_delete (complex_variable_components);\n-\n+  htab_delete (complex_variable_components);\n+  VEC_free (tree, heap, complex_ssa_name_components);\n   VEC_free (complex_lattice_t, heap, complex_lattice_values);\n }\n "}]}