{"sha": "a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZlYWNiZjEwNTU1MjBlOTY4ZDFhMjVmNmQzMGQ2ZmY0YjY2MjcyZA==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-05-17T12:29:42Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-05-17T12:30:20Z"}, "message": "arm: Auto-vectorization for MVE: vcmp\n\nSince MVE has a different set of vector comparison operators from\nNeon, we have to update the expansion to take into account the new\nones, for instance 'NE' for which MVE does not require to use 'EQ'\nwith the inverted condition.\n\nConversely, Neon supports comparisons with #0, MVE does not.\n\nFor:\ntypedef long int vs32 __attribute__((vector_size(16)));\nvs32 cmp_eq_vs32_reg (vs32 a, vs32 b) { return a == b; }\n\nwe now generate:\ncmp_eq_vs32_reg:\n\tvldr.64 d4, .L123       @ 8     [c=8 l=4]  *mve_movv4si/8\n\tvldr.64 d5, .L123+8\n\tvldr.64 d6, .L123+16    @ 9     [c=8 l=4]  *mve_movv4si/8\n\tvldr.64 d7, .L123+24\n\tvcmp.i32  eq, q0, q1    @ 7     [c=16 l=4]  mve_vcmpeqq_v4si\n\tvpsel q0, q3, q2        @ 15    [c=8 l=4]  mve_vpselq_sv4si\n\tbx      lr      @ 26    [c=8 l=4]  *thumb2_return\n.L124:\n\t.align  3\n.L123:\n\t.word   0\n\t.word   0\n\t.word   0\n\t.word   0\n\t.word   1\n\t.word   1\n\t.word   1\n\t.word   1\n\nFor some reason emit_move_insn (zero, CONST0_RTX (cmp_mode)) produces\na pair of vldr instead of vmov.i32, qX, #0\n\n2021-05-17  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\t* config/arm/arm-protos.h (arm_expand_vector_compare): Update\n\tprototype.\n\t* config/arm/arm.c (arm_expand_vector_compare): Add support for\n\tMVE.\n\t(arm_expand_vcond): Likewise.\n\t* config/arm/iterators.md (supf): Remove VCMPNEQ_S, VCMPEQQ_S,\n\tVCMPEQQ_N_S, VCMPNEQ_N_S.\n\t(VCMPNEQ, VCMPEQQ, VCMPEQQ_N, VCMPNEQ_N): Remove.\n\t* config/arm/mve.md (@mve_vcmp<mve_cmp_op>q_<mode>): Add '@' prefix.\n\t(@mve_vcmp<mve_cmp_op>q_f<mode>): Likewise.\n\t(@mve_vcmp<mve_cmp_op>q_n_f<mode>): Likewise.\n\t(@mve_vpselq_<supf><mode>): Likewise.\n\t(@mve_vpselq_f<mode>\"): Likewise.\n\t* config/arm/neon.md (vec_cmp<mode><v_cmp_result): Enable for MVE\n\tand move to vec-common.md.\n\t(vec_cmpu<mode><mode>): Likewise.\n\t(vcond<mode><mode>): Likewise.\n\t(vcond<V_cvtto><mode>): Likewise.\n\t(vcondu<mode><v_cmp_result>): Likewise.\n\t(vcond_mask_<mode><v_cmp_result>): Likewise.\n\t* config/arm/unspecs.md (VCMPNEQ_U, VCMPNEQ_S, VCMPEQQ_S)\n\t(VCMPEQQ_N_S, VCMPNEQ_N_S, VCMPEQQ_U, CMPEQQ_N_U, VCMPNEQ_N_U)\n\t(VCMPGEQ_N_S, VCMPGEQ_S, VCMPGTQ_N_S, VCMPGTQ_S, VCMPLEQ_N_S)\n\t(VCMPLEQ_S, VCMPLTQ_N_S, VCMPLTQ_S, VCMPCSQ_N_U, VCMPCSQ_U)\n\t(VCMPHIQ_N_U, VCMPHIQ_U): Remove.\n\t* config/arm/vec-common.md (vec_cmp<mode><v_cmp_result): Moved\n\tfrom neon.md.\n\t(vec_cmpu<mode><mode>): Likewise.\n\t(vcond<mode><mode>): Likewise.\n\t(vcond<V_cvtto><mode>): Likewise.\n\t(vcondu<mode><v_cmp_result>): Likewise.\n\t(vcond_mask_<mode><v_cmp_result>): Likewise. Added unsafe math\n\tcondition.\n\n\tgcc/testsuite\n\t* gcc.target/arm/simd/mve-compare-1.c: New test with GCC vectors.\n\t* gcc.target/arm/simd/mve-compare-2.c: New test with GCC vectors.\n\t* gcc.target/arm/simd/mve-compare-scalar-1.c: New test with GCC\n\tvectors.\n\t* gcc.target/arm/simd/mve-vcmp-f32.c: New test for\n\tauto-vectorization.\n\t* gcc.target/arm/simd/mve-vcmp.c: New test for auto-vectorization.", "tree": {"sha": "8722d4dbe99fdb161c30bbd13d8a0c481157fd15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8722d4dbe99fdb161c30bbd13d8a0c481157fd15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/comments", "author": null, "committer": null, "parents": [{"sha": "45063c0506a00f2673049d46f12a6061dca4692f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45063c0506a00f2673049d46f12a6061dca4692f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45063c0506a00f2673049d46f12a6061dca4692f"}], "stats": {"total": 714, "additions": 548, "deletions": 166}, "files": [{"sha": "ffccaa77377ecce82994c75e9f3aaf462c64451f", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -373,7 +373,7 @@ extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,\n extern bool arm_fusion_enabled_p (tune_params::fuse_ops);\n extern bool arm_valid_symbolic_address_p (rtx);\n extern bool arm_validize_comparison (rtx *, rtx *, rtx *);\n-extern bool arm_expand_vector_compare (rtx, rtx_code, rtx, rtx, bool);\n+extern bool arm_expand_vector_compare (rtx, rtx_code, rtx, rtx, bool, bool);\n #endif /* RTX_CODE */\n \n extern bool arm_gen_setmem (rtx *);"}, {"sha": "eee3671848fc4e72fed893e91848ca602d56b7a4", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 165, "deletions": 46, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -30959,83 +30959,168 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n    and return true if TARGET contains the inverse.  If !CAN_INVERT,\n    always store the result in TARGET, never its inverse.\n \n+   If VCOND_MVE, do not emit the vpsel instruction here, let arm_expand_vcond do\n+   it with the right destination type to avoid emiting two vpsel, one here and\n+   one in arm_expand_vcond.\n+\n    Note that the handling of floating-point comparisons is not\n    IEEE compliant.  */\n \n bool\n arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n-\t\t\t   bool can_invert)\n+\t\t\t   bool can_invert, bool vcond_mve)\n {\n   machine_mode cmp_result_mode = GET_MODE (target);\n   machine_mode cmp_mode = GET_MODE (op0);\n \n   bool inverted;\n-  switch (code)\n-    {\n-    /* For these we need to compute the inverse of the requested\n-       comparison.  */\n-    case UNORDERED:\n-    case UNLT:\n-    case UNLE:\n-    case UNGT:\n-    case UNGE:\n-    case UNEQ:\n-    case NE:\n-      code = reverse_condition_maybe_unordered (code);\n-      if (!can_invert)\n-\t{\n-\t  /* Recursively emit the inverted comparison into a temporary\n-\t     and then store its inverse in TARGET.  This avoids reusing\n-\t     TARGET (which for integer NE could be one of the inputs).  */\n-\t  rtx tmp = gen_reg_rtx (cmp_result_mode);\n-\t  if (arm_expand_vector_compare (tmp, code, op0, op1, true))\n-\t    gcc_unreachable ();\n-\t  emit_insn (gen_rtx_SET (target, gen_rtx_NOT (cmp_result_mode, tmp)));\n-\t  return false;\n-\t}\n-      inverted = true;\n-      break;\n \n-    default:\n+  /* MVE supports more comparisons than Neon.  */\n+  if (TARGET_HAVE_MVE)\n       inverted = false;\n-      break;\n-    }\n+  else\n+    switch (code)\n+      {\n+\t/* For these we need to compute the inverse of the requested\n+\t   comparison.  */\n+      case UNORDERED:\n+      case UNLT:\n+      case UNLE:\n+      case UNGT:\n+      case UNGE:\n+      case UNEQ:\n+      case NE:\n+\tcode = reverse_condition_maybe_unordered (code);\n+\tif (!can_invert)\n+\t  {\n+\t    /* Recursively emit the inverted comparison into a temporary\n+\t       and then store its inverse in TARGET.  This avoids reusing\n+\t       TARGET (which for integer NE could be one of the inputs).  */\n+\t    rtx tmp = gen_reg_rtx (cmp_result_mode);\n+\t    if (arm_expand_vector_compare (tmp, code, op0, op1, true, vcond_mve))\n+\t      gcc_unreachable ();\n+\t    emit_insn (gen_rtx_SET (target, gen_rtx_NOT (cmp_result_mode, tmp)));\n+\t    return false;\n+\t  }\n+\tinverted = true;\n+\tbreak;\n+\n+      default:\n+\tinverted = false;\n+\tbreak;\n+      }\n \n   switch (code)\n     {\n-    /* These are natively supported for zero comparisons, but otherwise\n-       require the operands to be swapped.  */\n+    /* These are natively supported by Neon for zero comparisons, but otherwise\n+       require the operands to be swapped. For MVE, we can only compare\n+       registers.  */\n     case LE:\n     case LT:\n-      if (op1 != CONST0_RTX (cmp_mode))\n-\t{\n-\t  code = swap_condition (code);\n-\t  std::swap (op0, op1);\n-\t}\n+      if (!TARGET_HAVE_MVE)\n+\tif (op1 != CONST0_RTX (cmp_mode))\n+\t  {\n+\t    code = swap_condition (code);\n+\t    std::swap (op0, op1);\n+\t  }\n       /* Fall through.  */\n \n-    /* These are natively supported for both register and zero operands.  */\n+    /* These are natively supported by Neon for both register and zero\n+       operands. MVE supports registers only.  */\n     case EQ:\n     case GE:\n     case GT:\n-      emit_insn (gen_neon_vc (code, cmp_mode, target, op0, op1));\n+    case NE:\n+      if (TARGET_HAVE_MVE)\n+\t{\n+\t  rtx vpr_p0;\n+\t  if (vcond_mve)\n+\t    vpr_p0 = target;\n+\t  else\n+\t    vpr_p0 = gen_reg_rtx (HImode);\n+\n+\t  switch (GET_MODE_CLASS (cmp_mode))\n+\t    {\n+\t    case MODE_VECTOR_INT:\n+\t      emit_insn (gen_mve_vcmpq (code, cmp_mode, vpr_p0, op0, force_reg (cmp_mode, op1)));\n+\t      break;\n+\t    case MODE_VECTOR_FLOAT:\n+\t      if (TARGET_HAVE_MVE_FLOAT)\n+\t\temit_insn (gen_mve_vcmpq_f (code, cmp_mode, vpr_p0, op0, force_reg (cmp_mode, op1)));\n+\t      else\n+\t\tgcc_unreachable ();\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\t  /* If we are not expanding a vcond, build the result here.  */\n+\t  if (!vcond_mve)\n+\t    {\n+\t      rtx zero = gen_reg_rtx (cmp_result_mode);\n+\t      rtx one = gen_reg_rtx (cmp_result_mode);\n+\t      emit_move_insn (zero, CONST0_RTX (cmp_result_mode));\n+\t      emit_move_insn (one, CONST1_RTX (cmp_result_mode));\n+\t      emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_result_mode, target, one, zero, vpr_p0));\n+\t    }\n+\t}\n+      else\n+\temit_insn (gen_neon_vc (code, cmp_mode, target, op0, op1));\n       return inverted;\n \n     /* These are natively supported for register operands only.\n        Comparisons with zero aren't useful and should be folded\n        or canonicalized by target-independent code.  */\n     case GEU:\n     case GTU:\n-      emit_insn (gen_neon_vc (code, cmp_mode, target,\n-\t\t\t      op0, force_reg (cmp_mode, op1)));\n+      if (TARGET_HAVE_MVE)\n+\t{\n+\t  rtx vpr_p0;\n+\t  if (vcond_mve)\n+\t    vpr_p0 = target;\n+\t  else\n+\t    vpr_p0 = gen_reg_rtx (HImode);\n+\n+\t  emit_insn (gen_mve_vcmpq (code, cmp_mode, vpr_p0, op0, force_reg (cmp_mode, op1)));\n+\t  if (!vcond_mve)\n+\t    {\n+\t      rtx zero = gen_reg_rtx (cmp_result_mode);\n+\t      rtx one = gen_reg_rtx (cmp_result_mode);\n+\t      emit_move_insn (zero, CONST0_RTX (cmp_result_mode));\n+\t      emit_move_insn (one, CONST1_RTX (cmp_result_mode));\n+\t      emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_result_mode, target, one, zero, vpr_p0));\n+\t    }\n+\t}\n+      else\n+\temit_insn (gen_neon_vc (code, cmp_mode, target,\n+\t\t\t\top0, force_reg (cmp_mode, op1)));\n       return inverted;\n \n     /* These require the operands to be swapped and likewise do not\n        support comparisons with zero.  */\n     case LEU:\n     case LTU:\n-      emit_insn (gen_neon_vc (swap_condition (code), cmp_mode,\n-\t\t\t      target, force_reg (cmp_mode, op1), op0));\n+      if (TARGET_HAVE_MVE)\n+\t{\n+\t  rtx vpr_p0;\n+\t  if (vcond_mve)\n+\t    vpr_p0 = target;\n+\t  else\n+\t    vpr_p0 = gen_reg_rtx (HImode);\n+\n+\t  emit_insn (gen_mve_vcmpq (swap_condition (code), cmp_mode, vpr_p0, force_reg (cmp_mode, op1), op0));\n+\t  if (!vcond_mve)\n+\t    {\n+\t      rtx zero = gen_reg_rtx (cmp_result_mode);\n+\t      rtx one = gen_reg_rtx (cmp_result_mode);\n+\t      emit_move_insn (zero, CONST0_RTX (cmp_result_mode));\n+\t      emit_move_insn (one, CONST1_RTX (cmp_result_mode));\n+\t      emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_result_mode, target, one, zero, vpr_p0));\n+\t    }\n+\t}\n+      else\n+\temit_insn (gen_neon_vc (swap_condition (code), cmp_mode,\n+\t\t\t\ttarget, force_reg (cmp_mode, op1), op0));\n       return inverted;\n \n     /* These need a combination of two comparisons.  */\n@@ -31047,8 +31132,8 @@ arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n \trtx gt_res = gen_reg_rtx (cmp_result_mode);\n \trtx alt_res = gen_reg_rtx (cmp_result_mode);\n \trtx_code alt_code = (code == LTGT ? LT : LE);\n-\tif (arm_expand_vector_compare (gt_res, GT, op0, op1, true)\n-\t    || arm_expand_vector_compare (alt_res, alt_code, op0, op1, true))\n+\tif (arm_expand_vector_compare (gt_res, GT, op0, op1, true, vcond_mve)\n+\t    || arm_expand_vector_compare (alt_res, alt_code, op0, op1, true, vcond_mve))\n \t  gcc_unreachable ();\n \temit_insn (gen_rtx_SET (target, gen_rtx_IOR (cmp_result_mode,\n \t\t\t\t\t\t     gt_res, alt_res)));\n@@ -31066,13 +31151,47 @@ arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n void\n arm_expand_vcond (rtx *operands, machine_mode cmp_result_mode)\n {\n-  rtx mask = gen_reg_rtx (cmp_result_mode);\n+  /* When expanding for MVE, we do not want to emit a (useless) vpsel in\n+     arm_expand_vector_compare, and another one here.  */\n+  bool vcond_mve=false;\n+  rtx mask;\n+\n+  if (TARGET_HAVE_MVE)\n+    {\n+      vcond_mve=true;\n+      mask = gen_reg_rtx (HImode);\n+    }\n+  else\n+    mask = gen_reg_rtx (cmp_result_mode);\n+\n   bool inverted = arm_expand_vector_compare (mask, GET_CODE (operands[3]),\n-\t\t\t\t\t     operands[4], operands[5], true);\n+\t\t\t\t\t     operands[4], operands[5], true, vcond_mve);\n   if (inverted)\n     std::swap (operands[1], operands[2]);\n+  if (TARGET_NEON)\n   emit_insn (gen_neon_vbsl (GET_MODE (operands[0]), operands[0],\n \t\t\t    mask, operands[1], operands[2]));\n+  else\n+    {\n+      machine_mode cmp_mode = GET_MODE (operands[4]);\n+      rtx vpr_p0 = mask;\n+      rtx zero = gen_reg_rtx (cmp_mode);\n+      rtx one = gen_reg_rtx (cmp_mode);\n+      emit_move_insn (zero, CONST0_RTX (cmp_mode));\n+      emit_move_insn (one, CONST1_RTX (cmp_mode));\n+      switch (GET_MODE_CLASS (cmp_mode))\n+\t{\n+\tcase MODE_VECTOR_INT:\n+\t  emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_result_mode, operands[0], one, zero, vpr_p0));\n+\t  break;\n+\tcase MODE_VECTOR_FLOAT:\n+\t  if (TARGET_HAVE_MVE_FLOAT)\n+\t    emit_insn (gen_mve_vpselq_f (cmp_mode, operands[0], one, zero, vpr_p0));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n }\n \f\n #define MAX_VECT_LEN 16"}, {"sha": "a128465feeabd0b05ef65021b20f093f2185b299", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -1288,12 +1288,11 @@\n \t\t       (VCREATEQ_U \"u\") (VCREATEQ_S \"s\") (VSHRQ_N_S \"s\")\n \t\t       (VSHRQ_N_U \"u\") (VCVTQ_N_FROM_F_S \"s\") (VSHLQ_U \"u\")\n \t\t       (VCVTQ_N_FROM_F_U \"u\") (VADDLVQ_P_S \"s\") (VSHLQ_S \"s\")\n-\t\t       (VADDLVQ_P_U \"u\") (VCMPNEQ_S \"s\")\n+\t\t       (VADDLVQ_P_U \"u\")\n \t\t       (VABDQ_M_S \"s\") (VABDQ_M_U \"u\") (VABDQ_S \"s\")\n \t\t       (VABDQ_U \"u\") (VADDQ_N_S \"s\") (VADDQ_N_U \"u\")\n \t\t       (VADDVQ_P_S \"s\")\t(VADDVQ_P_U \"u\") (VBRSRQ_N_S \"s\")\n-\t\t       (VBRSRQ_N_U \"u\") (VCMPEQQ_S \"s\")\n-\t\t       (VCMPEQQ_N_S \"s\") (VCMPNEQ_N_S \"s\")\n+\t\t       (VBRSRQ_N_U \"u\")\n \t\t       (VHADDQ_N_S \"s\") (VHADDQ_N_U \"u\") (VHADDQ_S \"s\")\n \t\t       (VHADDQ_U \"u\") (VHSUBQ_N_S \"s\")\t(VHSUBQ_N_U \"u\")\n \t\t       (VHSUBQ_S \"s\") (VMAXQ_S \"s\") (VMAXQ_U \"u\") (VHSUBQ_U \"u\")\n@@ -1549,16 +1548,12 @@\n (define_int_iterator VSHRQ_N [VSHRQ_N_S VSHRQ_N_U])\n (define_int_iterator VCVTQ_N_FROM_F [VCVTQ_N_FROM_F_S VCVTQ_N_FROM_F_U])\n (define_int_iterator VADDLVQ_P [VADDLVQ_P_S VADDLVQ_P_U])\n-(define_int_iterator VCMPNEQ [VCMPNEQ_S])\n (define_int_iterator VSHLQ [VSHLQ_S VSHLQ_U])\n (define_int_iterator VABDQ [VABDQ_S VABDQ_U])\n (define_int_iterator VADDQ_N [VADDQ_N_S VADDQ_N_U])\n (define_int_iterator VADDVAQ [VADDVAQ_S VADDVAQ_U])\n (define_int_iterator VADDVQ_P [VADDVQ_P_U VADDVQ_P_S])\n (define_int_iterator VBRSRQ_N [VBRSRQ_N_U VBRSRQ_N_S])\n-(define_int_iterator VCMPEQQ [VCMPEQQ_S])\n-(define_int_iterator VCMPEQQ_N [VCMPEQQ_N_S])\n-(define_int_iterator VCMPNEQ_N [VCMPNEQ_N_S])\n (define_int_iterator VHADDQ [VHADDQ_S VHADDQ_U])\n (define_int_iterator VHADDQ_N [VHADDQ_N_U VHADDQ_N_S])\n (define_int_iterator VHSUBQ [VHSUBQ_S VHSUBQ_U])"}, {"sha": "133ebe93cf3f60168e5dbc9866a0114110b41444", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -813,7 +813,7 @@\n ;;\n ;; [vcmpneq_, vcmpcsq_, vcmpeqq_, vcmpgeq_, vcmpgtq_, vcmphiq_, vcmpleq_, vcmpltq_])\n ;;\n-(define_insn \"mve_vcmp<mve_cmp_op>q_<mode>\"\n+(define_insn \"@mve_vcmp<mve_cmp_op>q_<mode>\"\n   [\n    (set (match_operand:HI 0 \"vpr_register_operand\" \"=Up\")\n \t(MVE_COMPARISONS:HI (match_operand:MVE_2 1 \"s_register_operand\" \"w\")\n@@ -1903,7 +1903,7 @@\n ;;\n ;; [vcmpeqq_f, vcmpgeq_f, vcmpgtq_f, vcmpleq_f, vcmpltq_f, vcmpneq_f])\n ;;\n-(define_insn \"mve_vcmp<mve_cmp_op>q_f<mode>\"\n+(define_insn \"@mve_vcmp<mve_cmp_op>q_f<mode>\"\n   [\n    (set (match_operand:HI 0 \"vpr_register_operand\" \"=Up\")\n \t(MVE_FP_COMPARISONS:HI (match_operand:MVE_0 1 \"s_register_operand\" \"w\")\n@@ -1917,7 +1917,7 @@\n ;;\n ;; [vcmpeqq_n_f, vcmpgeq_n_f, vcmpgtq_n_f, vcmpleq_n_f, vcmpltq_n_f, vcmpneq_n_f])\n ;;\n-(define_insn \"mve_vcmp<mve_cmp_op>q_n_f<mode>\"\n+(define_insn \"@mve_vcmp<mve_cmp_op>q_n_f<mode>\"\n   [\n    (set (match_operand:HI 0 \"vpr_register_operand\" \"=Up\")\n \t(MVE_FP_COMPARISONS:HI (match_operand:MVE_0 1 \"s_register_operand\" \"w\")\n@@ -3282,7 +3282,7 @@\n ;;\n ;; [vpselq_u, vpselq_s])\n ;;\n-(define_insn \"mve_vpselq_<supf><mode>\"\n+(define_insn \"@mve_vpselq_<supf><mode>\"\n   [\n    (set (match_operand:MVE_1 0 \"s_register_operand\" \"=w\")\n \t(unspec:MVE_1 [(match_operand:MVE_1 1 \"s_register_operand\" \"w\")\n@@ -4377,7 +4377,7 @@\n ;;\n ;; [vpselq_f])\n ;;\n-(define_insn \"mve_vpselq_f<mode>\"\n+(define_insn \"@mve_vpselq_f<mode>\"\n   [\n    (set (match_operand:MVE_0 0 \"s_register_operand\" \"=w\")\n \t(unspec:MVE_0 [(match_operand:MVE_0 1 \"s_register_operand\" \"w\")"}, {"sha": "cc82d068a1c699d5571ddcb02d4499d51596a243", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -1416,93 +1416,6 @@\n   [(set_attr \"type\" \"neon_qsub<q>\")]\n )\n \n-(define_expand \"vec_cmp<mode><v_cmp_result>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\")\n-\t(match_operator:<V_cmp_result> 1 \"comparison_operator\"\n-\t  [(match_operand:VDQW 2 \"s_register_operand\")\n-\t   (match_operand:VDQW 3 \"reg_or_zero_operand\")]))]\n-  \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n-{\n-  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n-\t\t\t     operands[2], operands[3], false);\n-  DONE;\n-})\n-\n-(define_expand \"vec_cmpu<mode><mode>\"\n-  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n-\t(match_operator:VDQIW 1 \"comparison_operator\"\n-\t  [(match_operand:VDQIW 2 \"s_register_operand\")\n-\t   (match_operand:VDQIW 3 \"reg_or_zero_operand\")]))]\n-  \"TARGET_NEON\"\n-{\n-  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n-\t\t\t     operands[2], operands[3], false);\n-  DONE;\n-})\n-\n-;; Conditional instructions.  These are comparisons with conditional moves for\n-;; vectors.  They perform the assignment:\n-;;   \n-;;     Vop0 = (Vop4 <op3> Vop5) ? Vop1 : Vop2;\n-;;\n-;; where op3 is <, <=, ==, !=, >= or >.  Operations are performed\n-;; element-wise.\n-\n-(define_expand \"vcond<mode><mode>\"\n-  [(set (match_operand:VDQW 0 \"s_register_operand\")\n-\t(if_then_else:VDQW\n-\t  (match_operator 3 \"comparison_operator\"\n-\t    [(match_operand:VDQW 4 \"s_register_operand\")\n-\t     (match_operand:VDQW 5 \"reg_or_zero_operand\")])\n-\t  (match_operand:VDQW 1 \"s_register_operand\")\n-\t  (match_operand:VDQW 2 \"s_register_operand\")))]\n-  \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n-{\n-  arm_expand_vcond (operands, <V_cmp_result>mode);\n-  DONE;\n-})\n-\n-(define_expand \"vcond<V_cvtto><mode>\"\n-  [(set (match_operand:<V_CVTTO> 0 \"s_register_operand\")\n-\t(if_then_else:<V_CVTTO>\n-\t  (match_operator 3 \"comparison_operator\"\n-\t    [(match_operand:V32 4 \"s_register_operand\")\n-\t     (match_operand:V32 5 \"reg_or_zero_operand\")])\n-\t  (match_operand:<V_CVTTO> 1 \"s_register_operand\")\n-\t  (match_operand:<V_CVTTO> 2 \"s_register_operand\")))]\n-  \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n-{\n-  arm_expand_vcond (operands, <V_cmp_result>mode);\n-  DONE;\n-})\n-\n-(define_expand \"vcondu<mode><v_cmp_result>\"\n-  [(set (match_operand:VDQW 0 \"s_register_operand\")\n-\t(if_then_else:VDQW\n-\t  (match_operator 3 \"arm_comparison_operator\"\n-\t    [(match_operand:<V_cmp_result> 4 \"s_register_operand\")\n-\t     (match_operand:<V_cmp_result> 5 \"reg_or_zero_operand\")])\n-\t  (match_operand:VDQW 1 \"s_register_operand\")\n-\t  (match_operand:VDQW 2 \"s_register_operand\")))]\n-  \"TARGET_NEON\"\n-{\n-  arm_expand_vcond (operands, <V_cmp_result>mode);\n-  DONE;\n-})\n-\n-(define_expand \"vcond_mask_<mode><v_cmp_result>\"\n-  [(set (match_operand:VDQW 0 \"s_register_operand\")\n-\t(if_then_else:VDQW\n-\t  (match_operand:<V_cmp_result> 3 \"s_register_operand\")\n-\t  (match_operand:VDQW 1 \"s_register_operand\")\n-\t  (match_operand:VDQW 2 \"s_register_operand\")))]\n-  \"TARGET_NEON\"\n-{\n-  emit_insn (gen_neon_vbsl<mode> (operands[0], operands[3], operands[1],\n-\t\t\t\t  operands[2]));\n-  DONE;\n-})\n-\n ;; Patterns for builtins.\n \n ; good for plain vadd, vaddq."}, {"sha": "0778db1bf4f830f0fc8d9ef61bef4c57830ced98", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -596,18 +596,13 @@\n   VCVTQ_N_FROM_F_U\n   VADDLVQ_P_S\n   VADDLVQ_P_U\n-  VCMPNEQ_U\n-  VCMPNEQ_S\n   VSHLQ_S\n   VSHLQ_U\n   VABDQ_S\n   VADDQ_N_S\n   VADDVAQ_S\n   VADDVQ_P_S\n   VBRSRQ_N_S\n-  VCMPEQQ_S\n-  VCMPEQQ_N_S\n-  VCMPNEQ_N_S\n   VHADDQ_S\n   VHADDQ_N_S\n   VHSUBQ_S\n@@ -645,9 +640,6 @@\n   VADDVAQ_U\n   VADDVQ_P_U\n   VBRSRQ_N_U\n-  VCMPEQQ_U\n-  VCMPEQQ_N_U\n-  VCMPNEQ_N_U\n   VHADDQ_U\n   VHADDQ_N_U\n   VHSUBQ_U\n@@ -680,14 +672,6 @@\n   VSHLQ_R_U\n   VSUBQ_U\n   VSUBQ_N_U\n-  VCMPGEQ_N_S\n-  VCMPGEQ_S\n-  VCMPGTQ_N_S\n-  VCMPGTQ_S\n-  VCMPLEQ_N_S\n-  VCMPLEQ_S\n-  VCMPLTQ_N_S\n-  VCMPLTQ_S\n   VHCADDQ_ROT270_S\n   VHCADDQ_ROT90_S\n   VMAXAQ_S\n@@ -702,10 +686,6 @@\n   VQRDMULHQ_N_S\n   VQRDMULHQ_S\n   VQSHLUQ_N_S\n-  VCMPCSQ_N_U\n-  VCMPCSQ_U\n-  VCMPHIQ_N_U\n-  VCMPHIQ_U\n   VABDQ_M_S\n   VABDQ_M_U\n   VABDQ_F"}, {"sha": "448731f7be9f74f900e6fbf8bdd229f19a1e439b", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -362,3 +362,111 @@\n       DONE;\n     }\n })\n+\n+(define_expand \"vec_cmp<mode><v_cmp_result>\"\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\")\n+\t(match_operator:<V_cmp_result> 1 \"comparison_operator\"\n+\t  [(match_operand:VDQW 2 \"s_register_operand\")\n+\t   (match_operand:VDQW 3 \"reg_or_zero_operand\")]))]\n+  \"ARM_HAVE_<MODE>_ARITH\n+   && !TARGET_REALLY_IWMMXT\n+   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n+\t\t\t     operands[2], operands[3], false, false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpu<mode><mode>\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n+\t(match_operator:VDQIW 1 \"comparison_operator\"\n+\t  [(match_operand:VDQIW 2 \"s_register_operand\")\n+\t   (match_operand:VDQIW 3 \"reg_or_zero_operand\")]))]\n+  \"ARM_HAVE_<MODE>_ARITH\n+   && !TARGET_REALLY_IWMMXT\"\n+{\n+  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n+\t\t\t     operands[2], operands[3], false, false);\n+  DONE;\n+})\n+\n+;; Conditional instructions.  These are comparisons with conditional moves for\n+;; vectors.  They perform the assignment:\n+;;\n+;;     Vop0 = (Vop4 <op3> Vop5) ? Vop1 : Vop2;\n+;;\n+;; where op3 is <, <=, ==, !=, >= or >.  Operations are performed\n+;; element-wise.\n+\n+(define_expand \"vcond<mode><mode>\"\n+  [(set (match_operand:VDQW 0 \"s_register_operand\")\n+\t(if_then_else:VDQW\n+\t  (match_operator 3 \"comparison_operator\"\n+\t    [(match_operand:VDQW 4 \"s_register_operand\")\n+\t     (match_operand:VDQW 5 \"reg_or_zero_operand\")])\n+\t  (match_operand:VDQW 1 \"s_register_operand\")\n+\t  (match_operand:VDQW 2 \"s_register_operand\")))]\n+  \"ARM_HAVE_<MODE>_ARITH\n+   && !TARGET_REALLY_IWMMXT\n+   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  arm_expand_vcond (operands, <V_cmp_result>mode);\n+  DONE;\n+})\n+\n+(define_expand \"vcond<V_cvtto><mode>\"\n+  [(set (match_operand:<V_CVTTO> 0 \"s_register_operand\")\n+\t(if_then_else:<V_CVTTO>\n+\t  (match_operator 3 \"comparison_operator\"\n+\t    [(match_operand:V32 4 \"s_register_operand\")\n+\t     (match_operand:V32 5 \"reg_or_zero_operand\")])\n+\t  (match_operand:<V_CVTTO> 1 \"s_register_operand\")\n+\t  (match_operand:<V_CVTTO> 2 \"s_register_operand\")))]\n+  \"ARM_HAVE_<MODE>_ARITH\n+   && !TARGET_REALLY_IWMMXT\n+   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  arm_expand_vcond (operands, <V_cmp_result>mode);\n+  DONE;\n+})\n+\n+(define_expand \"vcondu<mode><v_cmp_result>\"\n+  [(set (match_operand:VDQW 0 \"s_register_operand\")\n+\t(if_then_else:VDQW\n+\t  (match_operator 3 \"arm_comparison_operator\"\n+\t    [(match_operand:<V_cmp_result> 4 \"s_register_operand\")\n+\t     (match_operand:<V_cmp_result> 5 \"reg_or_zero_operand\")])\n+\t  (match_operand:VDQW 1 \"s_register_operand\")\n+\t  (match_operand:VDQW 2 \"s_register_operand\")))]\n+  \"ARM_HAVE_<MODE>_ARITH\n+   && !TARGET_REALLY_IWMMXT\"\n+{\n+  arm_expand_vcond (operands, <V_cmp_result>mode);\n+  DONE;\n+})\n+\n+(define_expand \"vcond_mask_<mode><v_cmp_result>\"\n+  [(set (match_operand:VDQW 0 \"s_register_operand\")\n+        (if_then_else:VDQW\n+          (match_operand:<V_cmp_result> 3 \"s_register_operand\")\n+          (match_operand:VDQW 1 \"s_register_operand\")\n+          (match_operand:VDQW 2 \"s_register_operand\")))]\n+  \"ARM_HAVE_<MODE>_ARITH\n+   && !TARGET_REALLY_IWMMXT\n+   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  if (TARGET_NEON)\n+    {\n+      emit_insn (gen_neon_vbsl (<MODE>mode, operands[0], operands[3],\n+                                operands[1], operands[2]));\n+    }\n+  else if (TARGET_HAVE_MVE)\n+    {\n+      emit_insn (gen_mve_vpselq (VPSELQ_S, <MODE>mode, operands[0],\n+                                 operands[1], operands[2], operands[3]));\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  DONE;\n+})"}, {"sha": "029c931f47fba83cef4d81d6feffd1cdb5d2d9bd", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-compare-1.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-1.c?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+/* Integer tests.  */\n+\n+#define COMPARE_REG(NAME, OP, TYPE) \\\n+  TYPE \\\n+  cmp_##NAME##_##TYPE##_reg (TYPE a, TYPE b) \\\n+  { \\\n+    return a OP b; \\\n+  }\n+\n+#define COMPARE_REG_AND_ZERO(NAME, OP, TYPE) \\\n+  COMPARE_REG (NAME, OP, TYPE) \\\n+  \\\n+  TYPE \\\n+  cmp_##NAME##_##TYPE##_zero (TYPE a) \\\n+  { \\\n+    return a OP (TYPE) {}; \\\n+  }\n+\n+#define COMPARE_TYPE(TYPE, COMPARE_ORDERED) \\\n+  COMPARE_REG_AND_ZERO (eq, ==, TYPE) \\\n+  COMPARE_REG_AND_ZERO (ne, !=, TYPE) \\\n+  COMPARE_ORDERED (lt, <, TYPE) \\\n+  COMPARE_ORDERED (le, <=, TYPE) \\\n+  COMPARE_ORDERED (gt, >, TYPE) \\\n+  COMPARE_ORDERED (ge, >=, TYPE)\n+\n+#define TEST_TYPE(NAME, ELEM, COMPARE_ORDERED, SIZE)  \\\n+  typedef ELEM NAME##SIZE __attribute__((vector_size(SIZE))); \\\n+  COMPARE_TYPE (NAME##SIZE, COMPARE_ORDERED)\n+\n+/* 64-bits vectors, not vectorized.  */\n+TEST_TYPE (vs8, __INT8_TYPE__, COMPARE_REG_AND_ZERO, 8)\n+TEST_TYPE (vu8, __UINT8_TYPE__, COMPARE_REG, 8)\n+TEST_TYPE (vs16, __INT16_TYPE__, COMPARE_REG_AND_ZERO, 8)\n+TEST_TYPE (vu16, __UINT16_TYPE__, COMPARE_REG, 8)\n+TEST_TYPE (vs32, __INT32_TYPE__, COMPARE_REG_AND_ZERO, 8)\n+TEST_TYPE (vu32, __UINT32_TYPE__, COMPARE_REG, 8)\n+\n+/* 128-bits vectors.  */\n+TEST_TYPE (vs8, __INT8_TYPE__, COMPARE_REG_AND_ZERO, 16)\n+TEST_TYPE (vu8, __UINT8_TYPE__, COMPARE_REG, 16)\n+TEST_TYPE (vs16, __INT16_TYPE__, COMPARE_REG_AND_ZERO, 16)\n+TEST_TYPE (vu16, __UINT16_TYPE__, COMPARE_REG, 16)\n+TEST_TYPE (vs32, __INT32_TYPE__, COMPARE_REG_AND_ZERO, 16)\n+TEST_TYPE (vu32, __UINT32_TYPE__, COMPARE_REG, 16)\n+\n+/* { 8 bits } x { eq, ne, lt, le, gt, ge, hi, cs }.\n+/* { dg-final { scan-assembler-times {\\tvcmp.i8  eq, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.i8  ne, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s8  lt, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s8  le, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s8  gt, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s8  ge, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u8  hi, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u8  cs, q[0-9]+, q[0-9]+\\n} 2 } } */\n+\n+/* { 16 bits } x { eq, ne, lt, le, gt, ge, hi, cs }.\n+/* { dg-final { scan-assembler-times {\\tvcmp.i16  eq, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.i16  ne, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s16  lt, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s16  le, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s16  gt, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s16  ge, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u16  hi, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u16  cs, q[0-9]+, q[0-9]+\\n} 2 } } */\n+\n+/* { 32 bits } x { eq, ne, lt, le, gt, ge, hi, cs }.\n+/* { dg-final { scan-assembler-times {\\tvcmp.i32  eq, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.i32  ne, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s32  lt, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s32  le, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s32  gt, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s32  ge, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u32  hi, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u32  cs, q[0-9]+, q[0-9]+\\n} 2 } } */"}, {"sha": "8515195ec87e2666399caba97e7d0fc73decaa1f", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-compare-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-2.c?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+/* { dg-additional-options \"-O3 -funsafe-math-optimizations\" } */\n+\n+/* float 32 tests.  */\n+\n+#ifndef ELEM_TYPE\n+#define ELEM_TYPE float\n+#endif\n+#ifndef INT_ELEM_TYPE\n+#define INT_ELEM_TYPE __INT32_TYPE__\n+#endif\n+\n+#define COMPARE(NAME, OP)\t\t\t\\\n+  int_vec\t\t\t\t\t\\\n+  cmp_##NAME##_reg (vec a, vec b)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return a OP b;\t\t\t\t\\\n+  }\n+\n+typedef INT_ELEM_TYPE int_vec __attribute__((vector_size(16)));\n+typedef ELEM_TYPE vec __attribute__((vector_size(16)));\n+\n+COMPARE (eq, ==)\n+COMPARE (ne, !=)\n+COMPARE (lt, <)\n+COMPARE (le, <=)\n+COMPARE (gt, >)\n+COMPARE (ge, >=)\n+\n+/* eq, ne, lt, le, gt, ge.\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\teq, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tne, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tlt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tle, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tgt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tge, q[0-9]+, q[0-9]+\\n} 1 } } */"}, {"sha": "77749723693e3de44def4d93de90ab860fdac9fe", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-compare-scalar-1.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-scalar-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-scalar-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-compare-scalar-1.c?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#define COMPARE_REG(NAME, OP, TYPE, SCALAR)\t  \\\n+  TYPE\t\t\t\t\t\t  \\\n+  cmp_##NAME##_##TYPE##_scalar (TYPE a, SCALAR b) \\\n+  {\t\t\t\t\t\t  \\\n+    return a OP b;\t\t\t\t  \\\n+  }\n+\n+#define COMPARE_TYPE(SCALAR, TYPE)\t\t\t\t\\\n+  COMPARE_REG (eq, ==, TYPE, SCALAR)\t\t\t\t\\\n+  COMPARE_REG (ne, !=, TYPE, SCALAR)\t\t\t\t\\\n+  COMPARE_REG (lt, <, TYPE, SCALAR)\t\t\t\t\\\n+  COMPARE_REG (le, <=, TYPE, SCALAR)\t\t\t\t\\\n+  COMPARE_REG (gt, >, TYPE, SCALAR)\t\t\t\t\\\n+  COMPARE_REG (ge, >=, TYPE, SCALAR)\n+\n+#define TEST_TYPE(NAME, ELEM, SIZE)\t\t\t      \\\n+  typedef ELEM NAME##SIZE __attribute__((vector_size(SIZE))); \\\n+  COMPARE_TYPE (ELEM, NAME##SIZE)\n+\n+/* 64-bits vectors, not vectorized.  */\n+TEST_TYPE (vs8, __INT8_TYPE__, 8)\n+TEST_TYPE (vu8, __UINT8_TYPE__, 8)\n+TEST_TYPE (vs16, __INT16_TYPE__, 8)\n+TEST_TYPE (vu16, __UINT16_TYPE__, 8)\n+TEST_TYPE (vs32, __INT32_TYPE__, 8)\n+TEST_TYPE (vu32, __UINT32_TYPE__, 8)\n+\n+/* 128-bits vectors.  */\n+TEST_TYPE (vs8, __INT8_TYPE__, 16)\n+TEST_TYPE (vu8, __UINT8_TYPE__, 16)\n+TEST_TYPE (vs16, __INT16_TYPE__, 16)\n+TEST_TYPE (vu16, __UINT16_TYPE__, 16)\n+TEST_TYPE (vs32, __INT32_TYPE__, 16)\n+TEST_TYPE (vu32, __UINT32_TYPE__, 16)\n+\n+/* { 8 bits } x { eq, ne, lt, le, gt, ge, hi, cs }.\n+/* { dg-final { scan-assembler-times {\\tvcmp.i8  eq, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.i8  ne, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s8  lt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s8  le, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s8  gt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s8  ge, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u8  hi, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u8  cs, q[0-9]+, q[0-9]+\\n} 2 } } */\n+\n+/* { 16 bits } x { eq, ne, lt, le, gt, ge, hi, cs }.\n+/* { dg-final { scan-assembler-times {\\tvcmp.i16  eq, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.i16  ne, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s16  lt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s16  le, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s16  gt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s16  ge, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u16  hi, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u16  cs, q[0-9]+, q[0-9]+\\n} 2 } } */\n+\n+/* { 32 bits } x { eq, ne, lt, le, gt, ge, hi, cs }.\n+/* { dg-final { scan-assembler-times {\\tvcmp.i32  eq, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.i32  ne, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s32  lt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s32  le, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s32  gt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s32  ge, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u32  hi, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u32  cs, q[0-9]+, q[0-9]+\\n} 2 } } */"}, {"sha": "4ed449e7d524fc21995ec4cd0aefeec344a18a3a", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vcmp-f32.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vcmp-f32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vcmp-f32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vcmp-f32.c?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+/* { dg-additional-options \"-O3 -funsafe-math-optimizations\" } */\n+\n+#include <stdint.h>\n+\n+#define NB 4\n+\n+#define FUNC(OP, NAME)\t\t\t\t\t\t\t\\\n+  void test_ ## NAME ##_f (float * __restrict__ dest, float *a, float *b) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i<NB; i++) {\t\t\t\t\t\t\\\n+      dest[i] = a[i] OP b[i];\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FUNC(==, vcmpeq)\n+FUNC(!=, vcmpne)\n+FUNC(<, vcmplt)\n+FUNC(<=, vcmple)\n+FUNC(>, vcmpgt)\n+FUNC(>=, vcmpge)\n+\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\teq, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tne, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tlt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tle, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tgt, q[0-9]+, q[0-9]+\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.f32\\tge, q[0-9]+, q[0-9]+\\n} 1 } } */"}, {"sha": "8da15e762eb5e3a9226e426e349df6cf58f3ffca", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vcmp.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6eacbf1055520e968d1a25f6d30d6ff4b66272d/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vcmp.c?ref=a6eacbf1055520e968d1a25f6d30d6ff4b66272d", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+#define FUNC(SIGN, TYPE, BITS, NB, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS ## x ## NB (TYPE##BITS##_t * __restrict__ dest, TYPE##BITS##_t *a, TYPE##BITS##_t *b) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i<NB; i++) {\t\t\t\t\t\t\\\n+      dest[i] = a[i] OP b[i];\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define ALL_FUNCS(OP, NAME) \\\n+  FUNC(s, int, 32, 2, OP, NAME)\t\t\t\\\n+  FUNC(u, uint, 32, 2, OP, NAME)\t\t\\\n+  FUNC(s, int, 16, 4, OP, NAME)\t\t\t\\\n+  FUNC(u, uint, 16, 4, OP, NAME)\t\t\\\n+  FUNC(s, int, 8, 8, OP, NAME)\t\t\t\\\n+  FUNC(u, uint, 8, 8, OP, NAME)\t\t\t\\\n+  FUNC(s, int, 32, 4, OP, NAME)\t\t\t\\\n+  FUNC(u, uint, 32, 4, OP, NAME)\t\t\\\n+  FUNC(s, int, 16, 8, OP, NAME)\t\t\t\\\n+  FUNC(u, uint, 16, 8, OP, NAME)\t\t\\\n+  FUNC(s, int, 8, 16, OP, NAME)\t\t\t\\\n+  FUNC(u, uint, 8, 16, OP, NAME)\n+\n+ALL_FUNCS(==, vcmpeq)\n+ALL_FUNCS(!=, vcmpne)\n+ALL_FUNCS(<, vcmplt)\n+ALL_FUNCS(<=, vcmple)\n+ALL_FUNCS(>, vcmpgt)\n+ALL_FUNCS(>=, vcmpge)\n+\n+/* MVE has only 128-bit vectors, so we can vectorize only half of the\n+   functions above.  */\n+/* { dg-final { scan-assembler-times {\\tvcmp.i[0-9]+  eq, q[0-9]+, q[0-9]+\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.i[0-9]+  ne, q[0-9]+, q[0-9]+\\n} 6 } } */\n+\n+/* lt, le, gt, ge apply to signed types, cs and hi to unsigned types.  */\n+/* lt and le with unsigned types are replaced with the opposite condition, hence\n+   the double number of matches for cs and hi.  */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s[0-9]+  lt, q[0-9]+, q[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s[0-9]+  le, q[0-9]+, q[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s[0-9]+  gt, q[0-9]+, q[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.s[0-9]+  ge, q[0-9]+, q[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u[0-9]+  cs, q[0-9]+, q[0-9]+\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tvcmp.u[0-9]+  hi, q[0-9]+, q[0-9]+\\n} 6 } } */"}]}