{"sha": "44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRmYWNkYjc5ZjJkOTZlYThmNWY5M2NmZDQ0MGIzZDAzNTFkOWJkYg==", "commit": {"author": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2020-04-09T20:55:44Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2020-04-09T21:47:02Z"}, "message": "PR fortran/87923 -- fix ICE when resolving I/O tags and simplify io.c\n\n2020-04-06  Fritz Reese  <foreese@gcc.gnu.org>\n\nThis patch reorganizes I/O checking code. Checks which were done in the\nmatching phase which do not affect the match result are moved to the\nresolution phase. Checks which were duplicated in both the matching phase\nand resolution phase have been reduced to one check in the resolution phase.\n\nAnother section of code which used a global async_io_dt flag to check for\nand assign the asynchronous attribute to variables used in asynchronous I/O\nhas been simplified.\n\nFurthermore, this patch improves error reporting and expands test coverage\nof I/O tags:\n\n - \"TAG must be an initialization expression\" reported by io.c\n   (check_io_constraints) is replaced with an error from expr.c\n   (gfc_reduce_init_expr) indicating _why_ the expression is not a valid\n   initialization expression.\n\n - Several distinct error messages regarding the check for scalar\n   + character + default kind have been unified to one message reported by\n   resolve_tag or check_*_constraints.\n\ngcc/fortran/ChangeLog:\n\n2020-04-09  Fritz Reese  <foreese@gcc.gnu.org>\n\n\tPR fortran/87923\n\t* gfortran.h (gfc_resolve_open, gfc_resolve_close): Add\n\tlocus parameter.\n\t(gfc_resolve_dt): Add code parameter.\n\t* io.c (async_io_dt, check_char_variable, is_char_type): Removed.\n\t(resolve_tag_format): Add locus to error message regarding\n\tzero-sized array in FORMAT tag.\n\t(check_open_constraints, check_close_constraints): New functions\n\tcalled at resolution time.\n\t(gfc_match_open, gfc_match_close, match_io): Move checks which don't\n\taffect the match result to new functions check_open_constraints,\n\tcheck_close_constraints, check_io_constraints.\n\t(gfc_resolve_open, gfc_resolve_close): Call new functions\n\tcheck_open_constraints, check_close_constraints after all tags have\n\tbeen independently resolved.  Remove duplicate constraints which are\n\talready verified by resolve_tag. Explicitly pass locus to all error\n\treports.\n\t(compare_to_allowed_values): Add locus parameter and provide\n\texplicit locus all error reports.\n\t(match_open_element, match_close_element, match_file_element,\n\tmatch_dt_element, match_inquire_element): Remove redundant special\n\tcases for ASYNCHRONOUS and IOMSG tags.\n\t(gfc_resolve_dt): Remove redundant special case for format\n\texpression.  Call check_io_constraints, forwarding an I/O list as\n\tthe io_code parameter if present.\n\t(check_io_constraints): Change return type to bool. Pass explicit\n\tlocus to error reports. Move generic checks after tag-specific\n\tchecks, since errors are no longer buffered.  Move simplification of\n\tformat string to match_io.  Remove redundant checks which are\n\tverified by resolve_tag.  Remove usage of async_io_dt flag and\n\texplicitly mark symbols used in asynchronous I/O with the\n\tasynchronous attribute.\n\t* resolve.c (resolve_transfer, resolve_fl_namelist): Remove checks\n\tfor async_io_dt flag. This is now done in io.c\n\t(check_io_constraints).\n\t(gfc_resolve_code): Pass code locus to gfc_resolve_open,\n\tgfc_resolve_close, gfc_resolve_dt.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-09  Fritz Reese  <foreese@gcc.gnu.org>\n\n\tPR fortran/87923\n\t* gfortran.dg/f2003_io_8.f03: Fix expected error messages.\n\t* gfortran.dg/io_constraints_8.f90: Likewise.\n\t* gfortran.dg/iomsg_2.f90: Likewise.\n\t* gfortran.dg/pr66725.f90: Likewise.\n\t* gfortran.dg/pr88205.f90: Likewise.\n\t* gfortran.dg/write_check4.f90: Likewise.\n\t* gfortran.dg/asynchronous_5.f03: New test.\n\t* gfortran.dg/io_constraints_15.f90: Likewise.\n\t* gfortran.dg/io_constraints_16.f90: Likewise.\n\t* gfortran.dg/io_constraints_17.f90: Likewise.\n\t* gfortran.dg/io_constraints_18.f90: Likewise.\n\t* gfortran.dg/io_tags_1.f90: Likewise.\n\t* gfortran.dg/io_tags_10.f90: Likewise.\n\t* gfortran.dg/io_tags_2.f90: Likewise.\n\t* gfortran.dg/io_tags_3.f90: Likewise.\n\t* gfortran.dg/io_tags_4.f90: Likewise.\n\t* gfortran.dg/io_tags_5.f90: Likewise.\n\t* gfortran.dg/io_tags_6.f90: Likewise.\n\t* gfortran.dg/io_tags_7.f90: Likewise.\n\t* gfortran.dg/io_tags_8.f90: Likewise.\n\t* gfortran.dg/io_tags_9.f90: Likewise.\n\t* gfortran.dg/write_check5.f90: Likewise.", "tree": {"sha": "27be7a4c1f6093912451d70d672030ea28722f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27be7a4c1f6093912451d70d672030ea28722f00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/comments", "author": null, "committer": null, "parents": [{"sha": "ef529765234bea7893bd56f3ab3a2da7695f6b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef529765234bea7893bd56f3ab3a2da7695f6b21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef529765234bea7893bd56f3ab3a2da7695f6b21"}], "stats": {"total": 1663, "additions": 1124, "deletions": 539}, "files": [{"sha": "e2ebb96d7992509969742db7e73e79827e4dc708", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -1,3 +1,43 @@\n+2020-04-09  Fritz Reese  <foreese@gcc.gnu.org>\n+\n+\tPR fortran/87923\n+\t* gfortran.h (gfc_resolve_open, gfc_resolve_close): Add\n+\tlocus parameter.\n+\t(gfc_resolve_dt): Add code parameter.\n+\t* io.c (async_io_dt, check_char_variable, is_char_type): Removed.\n+\t(resolve_tag_format): Add locus to error message regarding\n+\tzero-sized array in FORMAT tag.\n+\t(check_open_constraints, check_close_constraints): New functions\n+\tcalled at resolution time.\n+\t(gfc_match_open, gfc_match_close, match_io): Move checks which don't\n+\taffect the match result to new functions check_open_constraints,\n+\tcheck_close_constraints, check_io_constraints.\n+\t(gfc_resolve_open, gfc_resolve_close): Call new functions\n+\tcheck_open_constraints, check_close_constraints after all tags have\n+\tbeen independently resolved.  Remove duplicate constraints which are\n+\talready verified by resolve_tag.  Explicitly pass locus to all error\n+\treports.\n+\t(compare_to_allowed_values): Add locus parameter and provide\n+\texplicit locus all error reports.\n+\t(match_open_element, match_close_element, match_file_element,\n+\tmatch_dt_element, match_inquire_element): Remove redundant special\n+\tcases for ASYNCHRONOUS and IOMSG tags.\n+\t(gfc_resolve_dt): Remove redundant special case for format\n+\texpression.  Call check_io_constraints, forwarding an I/O list as\n+\tthe io_code parameter if present.\n+\t(check_io_constraints): Change return type to bool.  Pass explicit\n+\tlocus to error reports.  Move generic checks after tag-specific\n+\tchecks, since errors are no longer buffered.  Move simplification of\n+\tformat string to match_io.  Remove redundant checks which are\n+\tverified by resolve_tag.  Remove usage of async_io_dt flag and\n+\texplicitly mark symbols used in asynchronous I/O with the\n+\tasynchronous attribute.\n+\t* resolve.c (resolve_transfer, resolve_fl_namelist): Remove checks\n+\tfor async_io_dt flag.  This is now done in io.c.\n+\t(check_io_constraints).\n+\t(gfc_resolve_code): Pass code locus to gfc_resolve_open,\n+\tgfc_resolve_close, gfc_resolve_dt.\n+\n 2020-04-07  Fritz Reese  <foreese@gcc.gnu.org>\n \t    Steven G. Kargl  <kargl@gcc.gnu.org>\n "}, {"sha": "0d77386ddae07581b85e3b9c5dd9f4aaed245d99", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -3476,18 +3476,17 @@ bool gfc_compare_actual_formal (gfc_actual_arglist **, gfc_formal_arglist *,\n extern gfc_st_label format_asterisk;\n \n void gfc_free_open (gfc_open *);\n-bool gfc_resolve_open (gfc_open *);\n+bool gfc_resolve_open (gfc_open *, locus *);\n void gfc_free_close (gfc_close *);\n-bool gfc_resolve_close (gfc_close *);\n+bool gfc_resolve_close (gfc_close *, locus *);\n void gfc_free_filepos (gfc_filepos *);\n bool gfc_resolve_filepos (gfc_filepos *, locus *);\n void gfc_free_inquire (gfc_inquire *);\n bool gfc_resolve_inquire (gfc_inquire *);\n void gfc_free_dt (gfc_dt *);\n-bool gfc_resolve_dt (gfc_dt *, locus *);\n+bool gfc_resolve_dt (gfc_code *, gfc_dt *, locus *);\n void gfc_free_wait (gfc_wait *);\n bool gfc_resolve_wait (gfc_wait *);\n-extern bool async_io_dt;\n \n /* module.c */\n void gfc_module_init_2 (void);"}, {"sha": "e066666e01d14d2c4ad4a6f5afed1ee10b9172f8", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 380, "deletions": 478, "changes": 858, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -112,10 +112,6 @@ static gfc_dt *current_dt;\n \n #define RESOLVE_TAG(x, y) if (!resolve_tag (x, y)) return false;\n \n-/* Are we currently processing an asynchronous I/O statement? */\n-\n-bool async_io_dt;\n-\n /**************** Fortran 95 FORMAT parser  *****************/\n \n /* FORMAT tokens returned by format_lex().  */\n@@ -1427,36 +1423,6 @@ gfc_match_format (void)\n }\n \n \n-/* Check for a CHARACTER variable.  The check for scalar is done in\n-   resolve_tag.  */\n-\n-static bool\n-check_char_variable (gfc_expr *e)\n-{\n-  if (e->expr_type != EXPR_VARIABLE || e->ts.type != BT_CHARACTER)\n-    {\n-      gfc_error(\"IOMSG must be a scalar-default-char-variable at %L\", &e->where);\n-      return false;\n-    }\n-  return true;\n-}\n-\n-\n-static bool\n-is_char_type (const char *name, gfc_expr *e)\n-{\n-  gfc_resolve_expr (e);\n-\n-  if (e->ts.type != BT_CHARACTER)\n-    {\n-      gfc_error (\"%s requires a scalar-default-char-expr at %L\",\n-\t\t   name, &e->where);\n-      return false;\n-    }\n-  return true;\n-}\n-\n-\n /* Match an expression I/O tag of some sort.  */\n \n static match\n@@ -1725,7 +1691,8 @@ resolve_tag_format (gfc_expr *e)\n \n \t  if (e->value.constructor == NULL)\n \t   {\n-\t     gfc_error (\"FORMAT tag at %C cannot be a zero-sized array\");\n+\t     gfc_error (\"FORMAT tag at %L cannot be a zero-sized array\",\n+\t\t\t&e->where);\n \t     return false;\n \t   }\n \n@@ -1919,16 +1886,12 @@ match_open_element (gfc_open *open)\n   match m;\n \n   m = match_etag (&tag_e_async, &open->asynchronous);\n-  if (m == MATCH_YES && !is_char_type (\"ASYNCHRONOUS\", open->asynchronous))\n-    return MATCH_ERROR;\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_unit, &open->unit);\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_iomsg, &open->iomsg);\n-  if (m == MATCH_YES && !check_char_variable (open->iomsg))\n-    return MATCH_ERROR;\n   if (m != MATCH_NO)\n     return m;\n   m = match_out_tag (&tag_iostat, &open->iostat);\n@@ -2041,12 +2004,22 @@ gfc_free_open (gfc_open *open)\n }\n \n \n+static int\n+compare_to_allowed_values (const char *specifier, const char *allowed[],\n+\t\t\t   const char *allowed_f2003[],\n+\t\t\t   const char *allowed_gnu[], gfc_char_t *value,\n+\t\t\t   const char *statement, bool warn, locus *where,\n+\t\t\t   int *num = NULL);\n+\n+\n+static bool\n+check_open_constraints (gfc_open *open, locus *where);\n+\n /* Resolve everything in a gfc_open structure.  */\n \n bool\n-gfc_resolve_open (gfc_open *open)\n+gfc_resolve_open (gfc_open *open, locus *where)\n {\n-\n   RESOLVE_TAG (&tag_unit, open->unit);\n   RESOLVE_TAG (&tag_iomsg, open->iomsg);\n   RESOLVE_TAG (&tag_iostat, open->iostat);\n@@ -2073,27 +2046,21 @@ gfc_resolve_open (gfc_open *open)\n   if (!gfc_reference_st_label (open->err, ST_LABEL_TARGET))\n     return false;\n \n-  return true;\n+  return check_open_constraints (open, where);\n }\n \n \n /* Check if a given value for a SPECIFIER is either in the list of values\n    allowed in F95 or F2003, issuing an error message and returning a zero\n    value if it is not allowed.  */\n \n-static int\n-compare_to_allowed_values (const char *specifier, const char *allowed[],\n-\t\t\t   const char *allowed_f2003[], \n-\t\t\t   const char *allowed_gnu[], gfc_char_t *value,\n-\t\t\t   const char *statement, bool warn,\n-\t\t\t   int *num = NULL);\n-\n \n static int\n compare_to_allowed_values (const char *specifier, const char *allowed[],\n-\t\t\t   const char *allowed_f2003[], \n+\t\t\t   const char *allowed_f2003[],\n \t\t\t   const char *allowed_gnu[], gfc_char_t *value,\n-\t\t\t   const char *statement, bool warn, int *num)\n+\t\t\t   const char *statement, bool warn, locus *where,\n+\t\t\t   int *num)\n {\n   int i;\n   unsigned int len;\n@@ -2116,6 +2083,9 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n       return 1;\n       }\n \n+  if (!where)\n+    where = &gfc_current_locus;\n+\n   for (i = 0; allowed_f2003 && allowed_f2003[i]; i++)\n     if (len == strlen (allowed_f2003[i])\n \t&& gfc_wide_strncasecmp (value, allowed_f2003[i],\n@@ -2125,17 +2095,17 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \n \tif (n == WARNING || (warn && n == ERROR))\n \t  {\n-\t    gfc_warning (0, \"Fortran 2003: %s specifier in %s statement at %C \"\n-\t\t\t \"has value %qs\", specifier, statement,\n+\t    gfc_warning (0, \"Fortran 2003: %s specifier in %s statement at %L \"\n+\t\t\t \"has value %qs\", specifier, statement, where,\n \t\t\t allowed_f2003[i]);\n \t    return 1;\n \t  }\n \telse\n \t  if (n == ERROR)\n \t    {\n \t      gfc_notify_std (GFC_STD_F2003, \"%s specifier in \"\n-\t\t\t      \"%s statement at %C has value %qs\", specifier,\n-\t\t\t      statement, allowed_f2003[i]);\n+\t\t\t      \"%s statement at %L has value %qs\", specifier,\n+\t\t\t      statement, where, allowed_f2003[i]);\n \t      return 0;\n \t    }\n \n@@ -2152,17 +2122,17 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \n \tif (n == WARNING || (warn && n == ERROR))\n \t  {\n-\t    gfc_warning (0, \"Extension: %s specifier in %s statement at %C \"\n-\t\t\t \"has value %qs\", specifier, statement,\n+\t    gfc_warning (0, \"Extension: %s specifier in %s statement at %L \"\n+\t\t\t \"has value %qs\", specifier, statement, where,\n \t\t\t allowed_gnu[i]);\n \t    return 1;\n \t  }\n \telse\n \t  if (n == ERROR)\n \t    {\n \t      gfc_notify_std (GFC_STD_GNU, \"%s specifier in \"\n-\t\t\t      \"%s statement at %C has value %qs\", specifier,\n-\t\t\t      statement, allowed_gnu[i]);\n+\t\t\t      \"%s statement at %L has value %qs\", specifier,\n+\t\t\t      statement, where, allowed_gnu[i]);\n \t      return 0;\n \t    }\n \n@@ -2174,74 +2144,42 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n     {\n       char *s = gfc_widechar_to_char (value, -1);\n       gfc_warning (0,\n-\t\t   \"%s specifier in %s statement at %C has invalid value %qs\",\n-\t\t   specifier, statement, s);\n+\t\t   \"%s specifier in %s statement at %L has invalid value %qs\",\n+\t\t   specifier, statement, where, s);\n       free (s);\n       return 1;\n     }\n   else\n     {\n       char *s = gfc_widechar_to_char (value, -1);\n-      gfc_error (\"%s specifier in %s statement at %C has invalid value %qs\",\n-\t\t specifier, statement, s);\n+      gfc_error (\"%s specifier in %s statement at %L has invalid value %qs\",\n+\t\t specifier, statement, where, s);\n       free (s);\n       return 0;\n     }\n }\n \n \n-/* Match an OPEN statement.  */\n+/* Check constraints on the OPEN statement.\n+   Similar to check_io_constraints for data transfer statements.\n+   At this point all tags have already been resolved via resolve_tag, which,\n+   among other things, verifies that BT_CHARACTER tags are of default kind.  */\n \n-match\n-gfc_match_open (void)\n+static bool\n+check_open_constraints (gfc_open *open, locus *where)\n {\n-  gfc_open *open;\n-  match m;\n-  bool warn;\n-\n-  m = gfc_match_char ('(');\n-  if (m == MATCH_NO)\n-    return m;\n-\n-  open = XCNEW (gfc_open);\n-\n-  m = match_open_element (open);\n-\n-  if (m == MATCH_ERROR)\n-    goto cleanup;\n-  if (m == MATCH_NO)\n-    {\n-      m = gfc_match_expr (&open->unit);\n-      if (m == MATCH_ERROR)\n-\tgoto cleanup;\n-    }\n-\n-  for (;;)\n-    {\n-      if (gfc_match_char (')') == MATCH_YES)\n-\tbreak;\n-      if (gfc_match_char (',') != MATCH_YES)\n-\tgoto syntax;\n-\n-      m = match_open_element (open);\n-      if (m == MATCH_ERROR)\n-\tgoto cleanup;\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-    }\n-\n-  if (gfc_match_eos () == MATCH_NO)\n-    goto syntax;\n-\n-  if (gfc_pure (NULL))\n-    {\n-      gfc_error (\"OPEN statement not allowed in PURE procedure at %C\");\n-      goto cleanup;\n-    }\n-\n-  gfc_unset_implicit_pure (NULL);\n+#define warn_or_error(...) \\\n+{ \\\n+  if (warn) \\\n+    gfc_warning (0, __VA_ARGS__); \\\n+  else \\\n+    { \\\n+      gfc_error (__VA_ARGS__); \\\n+      return false; \\\n+    } \\\n+}\n \n-  warn = (open->err || open->iostat) ? true : false;\n+  bool warn = (open->err || open->iostat) ? true : false;\n \n   /* Checks on the ACCESS specifier.  */\n   if (open->access && open->access->expr_type == EXPR_CONSTANT)\n@@ -2250,14 +2188,11 @@ gfc_match_open (void)\n       static const char *access_f2003[] = { \"STREAM\", NULL };\n       static const char *access_gnu[] = { \"APPEND\", NULL };\n \n-      if (!is_char_type (\"ACCESS\", open->access))\n-\tgoto cleanup;\n-\n       if (!compare_to_allowed_values (\"ACCESS\", access_f95, access_f2003,\n \t\t\t\t      access_gnu,\n \t\t\t\t      open->access->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n-\tgoto cleanup;\n+\t\t\t\t      \"OPEN\", warn, &open->access->where))\n+\treturn false;\n     }\n \n   /* Checks on the ACTION specifier.  */\n@@ -2266,21 +2201,20 @@ gfc_match_open (void)\n       gfc_char_t *str = open->action->value.character.string;\n       static const char *action[] = { \"READ\", \"WRITE\", \"READWRITE\", NULL };\n \n-      if (!is_char_type (\"ACTION\", open->action))\n-\tgoto cleanup;\n-\n       if (!compare_to_allowed_values (\"ACTION\", action, NULL, NULL,\n-\t\t\t\t      str, \"OPEN\", warn))\n-\tgoto cleanup;\n+\t\t\t\t      str, \"OPEN\", warn, &open->action->where))\n+\treturn false;\n \n       /* With READONLY, only allow ACTION='READ'.  */\n       if (open->readonly && (gfc_wide_strlen (str) != 4\n \t\t\t     || gfc_wide_strncasecmp (str, \"READ\", 4) != 0))\n \t{\n-\t  gfc_error (\"ACTION type conflicts with READONLY specifier at %C\");\n-\t  goto cleanup;\n+\t  gfc_error (\"ACTION type conflicts with READONLY specifier at %L\",\n+\t\t     &open->action->where);\n+\t  return false;\n \t}\n     }\n+\n   /* If we see READONLY and no ACTION, set ACTION='READ'.  */\n   else if (open->readonly && open->action == NULL)\n     {\n@@ -2291,94 +2225,65 @@ gfc_match_open (void)\n   /* Checks on the ASYNCHRONOUS specifier.  */\n   if (open->asynchronous)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\tgoto cleanup;\n-\n-      if (!is_char_type (\"ASYNCHRONOUS\", open->asynchronous))\n-\tgoto cleanup;\n-\n-      if (open->asynchronous->ts.kind != 1)\n-\t{\n-\t  gfc_error (\"ASYNCHRONOUS= specifier at %L must be of default \"\n-\t\t     \"CHARACTER kind\", &open->asynchronous->where);\n-\t  return MATCH_ERROR;\n-\t}\n-\n-      if (open->asynchronous->expr_type == EXPR_ARRAY\n-\t  || open->asynchronous->expr_type == EXPR_STRUCTURE)\n-\t{\n-\t  gfc_error (\"ASYNCHRONOUS= specifier at %L must be scalar\",\n-\t\t     &open->asynchronous->where);\n-\t  return MATCH_ERROR;\n-\t}\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\",\n+\t\t\t   &open->asynchronous->where))\n+\treturn false;\n \n       if (open->asynchronous->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * asynchronous[] = { \"YES\", \"NO\", NULL };\n \n \t  if (!compare_to_allowed_values (\"ASYNCHRONOUS\", asynchronous,\n \t\t\tNULL, NULL, open->asynchronous->value.character.string,\n-\t\t\t\"OPEN\", warn))\n-\t    goto cleanup;\n+\t\t\t\"OPEN\", warn, &open->asynchronous->where))\n+\t    return false;\n \t}\n     }\n \n   /* Checks on the BLANK specifier.  */\n   if (open->blank)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"BLANK= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\tgoto cleanup;\n-\n-      if (!is_char_type (\"BLANK\", open->blank))\n-\tgoto cleanup;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"BLANK= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &open->blank->where))\n+\treturn false;\n \n       if (open->blank->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char *blank[] = { \"ZERO\", \"NULL\", NULL };\n \n \t  if (!compare_to_allowed_values (\"BLANK\", blank, NULL, NULL,\n \t\t\t\t\t  open->blank->value.character.string,\n-\t\t\t\t\t  \"OPEN\", warn))\n-\t    goto cleanup;\n+\t\t\t\t\t  \"OPEN\", warn, &open->blank->where))\n+\t    return false;\n \t}\n     }\n \n   /* Checks on the CARRIAGECONTROL specifier.  */\n-  if (open->cc)\n+  if (open->cc && open->cc->expr_type == EXPR_CONSTANT)\n     {\n-      if (!is_char_type (\"CARRIAGECONTROL\", open->cc))\n-\tgoto cleanup;\n-\n-      if (open->cc->expr_type == EXPR_CONSTANT)\n-\t{\n-\t  static const char *cc[] = { \"LIST\", \"FORTRAN\", \"NONE\", NULL };\n-\t  if (!compare_to_allowed_values (\"CARRIAGECONTROL\", cc, NULL, NULL,\n-\t\t\t\t\t  open->cc->value.character.string,\n-\t\t\t\t\t  \"OPEN\", warn))\n-\t    goto cleanup;\n-\t}\n+      static const char *cc[] = { \"LIST\", \"FORTRAN\", \"NONE\", NULL };\n+      if (!compare_to_allowed_values (\"CARRIAGECONTROL\", cc, NULL, NULL,\n+\t\t\t\t      open->cc->value.character.string,\n+\t\t\t\t      \"OPEN\", warn, &open->cc->where))\n+\treturn false;\n     }\n \n   /* Checks on the DECIMAL specifier.  */\n   if (open->decimal)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\tgoto cleanup;\n-\n-      if (!is_char_type (\"DECIMAL\", open->decimal))\n-\tgoto cleanup;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &open->decimal->where))\n+\treturn false;\n \n       if (open->decimal->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * decimal[] = { \"COMMA\", \"POINT\", NULL };\n \n \t  if (!compare_to_allowed_values (\"DECIMAL\", decimal, NULL, NULL,\n \t\t\t\t\t  open->decimal->value.character.string,\n-\t\t\t\t\t  \"OPEN\", warn))\n-\t    goto cleanup;\n+\t\t\t\t\t  \"OPEN\", warn, &open->decimal->where))\n+\t    return false;\n \t}\n     }\n \n@@ -2389,34 +2294,28 @@ gfc_match_open (void)\n \t{\n \t  static const char *delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };\n \n-\t  if (!is_char_type (\"DELIM\", open->delim))\n-\t    goto cleanup;\n-\n \t  if (!compare_to_allowed_values (\"DELIM\", delim, NULL, NULL,\n \t\t\t\t\t  open->delim->value.character.string,\n-\t\t\t\t\t  \"OPEN\", warn))\n-\t  goto cleanup;\n+\t\t\t\t\t  \"OPEN\", warn, &open->delim->where))\n+\t    return false;\n \t}\n     }\n \n   /* Checks on the ENCODING specifier.  */\n   if (open->encoding)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"ENCODING= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\tgoto cleanup;\n-\n-      if (!is_char_type (\"ENCODING\", open->encoding))\n-\tgoto cleanup;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ENCODING= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &open->encoding->where))\n+\treturn false;\n \n       if (open->encoding->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * encoding[] = { \"DEFAULT\", \"UTF-8\", NULL };\n \n \t  if (!compare_to_allowed_values (\"ENCODING\", encoding, NULL, NULL,\n \t\t\t\t\t  open->encoding->value.character.string,\n-\t\t\t\t\t  \"OPEN\", warn))\n-\t  goto cleanup;\n+\t\t\t\t\t  \"OPEN\", warn, &open->encoding->where))\n+\t    return false;\n \t}\n     }\n \n@@ -2425,52 +2324,40 @@ gfc_match_open (void)\n     {\n       static const char *form[] = { \"FORMATTED\", \"UNFORMATTED\", NULL };\n \n-      if (!is_char_type (\"FORM\", open->form))\n-\tgoto cleanup;\n-\n       if (!compare_to_allowed_values (\"FORM\", form, NULL, NULL,\n \t\t\t\t      open->form->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n-\tgoto cleanup;\n+\t\t\t\t      \"OPEN\", warn, &open->form->where))\n+\treturn false;\n     }\n \n   /* Checks on the PAD specifier.  */\n   if (open->pad && open->pad->expr_type == EXPR_CONSTANT)\n     {\n       static const char *pad[] = { \"YES\", \"NO\", NULL };\n \n-      if (!is_char_type (\"PAD\", open->pad))\n-\tgoto cleanup;\n-\n       if (!compare_to_allowed_values (\"PAD\", pad, NULL, NULL,\n \t\t\t\t      open->pad->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n-\tgoto cleanup;\n+\t\t\t\t      \"OPEN\", warn, &open->pad->where))\n+\treturn false;\n     }\n \n   /* Checks on the POSITION specifier.  */\n   if (open->position && open->position->expr_type == EXPR_CONSTANT)\n     {\n       static const char *position[] = { \"ASIS\", \"REWIND\", \"APPEND\", NULL };\n \n-      if (!is_char_type (\"POSITION\", open->position))\n-\tgoto cleanup;\n-\n       if (!compare_to_allowed_values (\"POSITION\", position, NULL, NULL,\n \t\t\t\t      open->position->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n-\tgoto cleanup;\n+\t\t\t\t      \"OPEN\", warn, &open->position->where))\n+\treturn false;\n     }\n \n   /* Checks on the ROUND specifier.  */\n   if (open->round)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"ROUND= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-      goto cleanup;\n-\n-      if (!is_char_type (\"ROUND\", open->round))\n-\tgoto cleanup;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ROUND= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &open->round->where))\n+\treturn false;\n \n       if (open->round->expr_type == EXPR_CONSTANT)\n \t{\n@@ -2480,36 +2367,27 @@ gfc_match_open (void)\n \n \t  if (!compare_to_allowed_values (\"ROUND\", round, NULL, NULL,\n \t\t\t\t\t  open->round->value.character.string,\n-\t\t\t\t\t  \"OPEN\", warn))\n-\t  goto cleanup;\n+\t\t\t\t\t  \"OPEN\", warn, &open->round->where))\n+\t    return false;\n \t}\n     }\n \n   /* Checks on the SHARE specifier.  */\n-  if (open->share)\n+  if (open->share && open->share->expr_type == EXPR_CONSTANT)\n     {\n-      if (!is_char_type (\"SHARE\", open->share))\n-\tgoto cleanup;\n-\n-      if (open->share->expr_type == EXPR_CONSTANT)\n-\t{\n-\t  static const char *share[] = { \"DENYNONE\", \"DENYRW\", NULL };\n-\t  if (!compare_to_allowed_values (\"SHARE\", share, NULL, NULL,\n-\t\t\t\t\t  open->share->value.character.string,\n-\t\t\t\t\t  \"OPEN\", warn))\n-\t    goto cleanup;\n-\t}\n+      static const char *share[] = { \"DENYNONE\", \"DENYRW\", NULL };\n+      if (!compare_to_allowed_values (\"SHARE\", share, NULL, NULL,\n+\t\t\t\t      open->share->value.character.string,\n+\t\t\t\t      \"OPEN\", warn, &open->share->where))\n+\treturn false;\n     }\n \n   /* Checks on the SIGN specifier.  */\n-  if (open->sign) \n+  if (open->sign)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"SIGN= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\tgoto cleanup;\n-\n-      if (!is_char_type (\"SIGN\", open->sign))\n-\tgoto cleanup;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"SIGN= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &open->sign->where))\n+\treturn false;\n \n       if (open->sign->expr_type == EXPR_CONSTANT)\n \t{\n@@ -2518,28 +2396,18 @@ gfc_match_open (void)\n \n \t  if (!compare_to_allowed_values (\"SIGN\", sign, NULL, NULL,\n \t\t\t\t\t  open->sign->value.character.string,\n-\t\t\t\t\t  \"OPEN\", warn))\n-\t  goto cleanup;\n+\t\t\t\t\t  \"OPEN\", warn, &open->sign->where))\n+\t    return false;\n \t}\n     }\n \n-#define warn_or_error(...) \\\n-{ \\\n-  if (warn) \\\n-    gfc_warning (0, __VA_ARGS__); \\\n-  else \\\n-    { \\\n-      gfc_error (__VA_ARGS__); \\\n-      goto cleanup; \\\n-    } \\\n-}\n-\n   /* Checks on the RECL specifier.  */\n   if (open->recl && open->recl->expr_type == EXPR_CONSTANT\n       && open->recl->ts.type == BT_INTEGER\n       && mpz_sgn (open->recl->value.integer) != 1)\n     {\n-      warn_or_error (\"RECL in OPEN statement at %C must be positive\");\n+      warn_or_error (\"RECL in OPEN statement at %L must be positive\",\n+\t\t     &open->recl->where);\n     }\n \n   /* Checks on the STATUS specifier.  */\n@@ -2548,13 +2416,10 @@ gfc_match_open (void)\n       static const char *status[] = { \"OLD\", \"NEW\", \"SCRATCH\",\n \t\"REPLACE\", \"UNKNOWN\", NULL };\n \n-      if (!is_char_type (\"STATUS\", open->status))\n-\tgoto cleanup;\n-\n       if (!compare_to_allowed_values (\"STATUS\", status, NULL, NULL,\n \t\t\t\t      open->status->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n-\tgoto cleanup;\n+\t\t\t\t      \"OPEN\", warn, &open->status->where))\n+\treturn false;\n \n       /* F2003, 9.4.5: If the STATUS= specifier has the value NEW or REPLACE,\n \t the FILE= specifier shall appear.  */\n@@ -2566,8 +2431,9 @@ gfc_match_open (void)\n \t{\n \t  char *s = gfc_widechar_to_char (open->status->value.character.string,\n \t\t\t\t\t  -1);\n-\t  warn_or_error (\"The STATUS specified in OPEN statement at %C is \"\n-\t\t\t \"%qs and no FILE specifier is present\", s);\n+\t  warn_or_error (\"The STATUS specified in OPEN statement at %L is \"\n+\t\t\t \"%qs and no FILE specifier is present\",\n+\t\t\t &open->status->where, s);\n \t  free (s);\n \t}\n \n@@ -2576,9 +2442,9 @@ gfc_match_open (void)\n       if (gfc_wide_strncasecmp (open->status->value.character.string,\n \t\t\t\t\"scratch\", 7) == 0 && open->file)\n \t{\n-\t  warn_or_error (\"The STATUS specified in OPEN statement at %C \"\n+\t  warn_or_error (\"The STATUS specified in OPEN statement at %L \"\n \t\t\t \"cannot have the value SCRATCH if a FILE specifier \"\n-\t\t\t \"is present\");\n+\t\t\t \"is present\", &open->status->where);\n \t}\n     }\n \n@@ -2587,8 +2453,9 @@ gfc_match_open (void)\n     {\n       if (open->unit)\n \t{\n-\t  gfc_error (\"UNIT specifier not allowed with NEWUNIT at %C\");\n-\t  goto cleanup;\n+\t  gfc_error (\"UNIT specifier not allowed with NEWUNIT at %L\",\n+\t\t     &open->newunit->where);\n+\t  return false;\n \t}\n \n       if (!open->file &&\n@@ -2598,14 +2465,15 @@ gfc_match_open (void)\n \t\t\t\t      \"scratch\", 7) != 0)))\n \t{\n \t     gfc_error (\"NEWUNIT specifier must have FILE= \"\n-\t\t\t\"or STATUS='scratch' at %C\");\n-\t     goto cleanup;\n+\t\t\t\"or STATUS='scratch' at %L\", &open->newunit->where);\n+\t     return false;\n \t}\n     }\n   else if (!open->unit)\n     {\n-      gfc_error (\"OPEN statement at %C must have UNIT or NEWUNIT specified\");\n-      goto cleanup;\n+      gfc_error (\"OPEN statement at %L must have UNIT or NEWUNIT specified\",\n+\t\t where);\n+      return false;\n     }\n \n   /* Things that are not allowed for unformatted I/O.  */\n@@ -2615,20 +2483,39 @@ gfc_match_open (void)\n       && gfc_wide_strncasecmp (open->form->value.character.string,\n \t\t\t       \"unformatted\", 11) == 0)\n     {\n-      const char *spec = (open->delim ? \"DELIM \"\n-\t\t\t\t      : (open->pad ? \"PAD \" : open->blank\n-\t\t\t\t\t\t\t    ? \"BLANK \" : \"\"));\n+      locus *loc;\n+      const char *spec;\n+      if (open->delim)\n+\t{\n+\t  loc = &open->delim->where;\n+\t  spec = \"DELIM \";\n+\t}\n+      else if (open->pad)\n+\t{\n+\t  loc = &open->pad->where;\n+\t  spec = \"PAD \";\n+\t}\n+      else if (open->blank)\n+\t{\n+\t  loc = &open->blank->where;\n+\t  spec = \"BLANK \";\n+\t}\n+      else\n+\t{\n+\t  loc = where;\n+\t  spec = \"\";\n+\t}\n \n-      warn_or_error (\"%s specifier at %C not allowed in OPEN statement for \"\n-\t\t     \"unformatted I/O\", spec);\n+      warn_or_error (\"%s specifier at %L not allowed in OPEN statement for \"\n+\t\t     \"unformatted I/O\", spec, loc);\n     }\n \n   if (open->recl && open->access && open->access->expr_type == EXPR_CONSTANT\n       && gfc_wide_strncasecmp (open->access->value.character.string,\n \t\t\t       \"stream\", 6) == 0)\n     {\n-      warn_or_error (\"RECL specifier not allowed in OPEN statement at %C for \"\n-\t\t     \"stream I/O\");\n+      warn_or_error (\"RECL specifier not allowed in OPEN statement at %L for \"\n+\t\t     \"stream I/O\", &open->recl->where);\n     }\n \n   if (open->position\n@@ -2640,11 +2527,64 @@ gfc_match_open (void)\n \t   || gfc_wide_strncasecmp (open->access->value.character.string,\n \t\t\t\t    \"append\", 6) == 0))\n     {\n-      warn_or_error (\"POSITION specifier in OPEN statement at %C only allowed \"\n-\t\t     \"for stream or sequential ACCESS\");\n+      warn_or_error (\"POSITION specifier in OPEN statement at %L only allowed \"\n+\t\t     \"for stream or sequential ACCESS\", &open->position->where);\n     }\n \n+  return true;\n #undef warn_or_error\n+}\n+\n+\n+/* Match an OPEN statement.  */\n+\n+match\n+gfc_match_open (void)\n+{\n+  gfc_open *open;\n+  match m;\n+\n+  m = gfc_match_char ('(');\n+  if (m == MATCH_NO)\n+    return m;\n+\n+  open = XCNEW (gfc_open);\n+\n+  m = match_open_element (open);\n+\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+  if (m == MATCH_NO)\n+    {\n+      m = gfc_match_expr (&open->unit);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+    }\n+\n+  for (;;)\n+    {\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+\n+      m = match_open_element (open);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+    }\n+\n+  if (gfc_match_eos () == MATCH_NO)\n+    goto syntax;\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error (\"OPEN statement not allowed in PURE procedure at %C\");\n+      goto cleanup;\n+    }\n+\n+  gfc_unset_implicit_pure (NULL);\n \n   new_st.op = EXEC_OPEN;\n   new_st.ext.open = open;\n@@ -2689,8 +2629,6 @@ match_close_element (gfc_close *close)\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_iomsg, &close->iomsg);\n-  if (m == MATCH_YES && !check_char_variable (close->iomsg))\n-    return MATCH_ERROR;\n   if (m != MATCH_NO)\n     return m;\n   m = match_out_tag (&tag_iostat, &close->iostat);\n@@ -2711,7 +2649,6 @@ gfc_match_close (void)\n {\n   gfc_close *close;\n   match m;\n-  bool warn;\n \n   m = gfc_match_char ('(');\n   if (m == MATCH_NO)\n@@ -2757,22 +2694,6 @@ gfc_match_close (void)\n \n   gfc_unset_implicit_pure (NULL);\n \n-  warn = (close->iostat || close->err) ? true : false;\n-\n-  /* Checks on the STATUS specifier.  */\n-  if (close->status && close->status->expr_type == EXPR_CONSTANT)\n-    {\n-      static const char *status[] = { \"KEEP\", \"DELETE\", NULL };\n-\n-      if (!is_char_type (\"STATUS\", close->status))\n-\tgoto cleanup;\n-\n-      if (!compare_to_allowed_values (\"STATUS\", status, NULL, NULL,\n-\t\t\t\t      close->status->value.character.string,\n-\t\t\t\t      \"CLOSE\", warn))\n-\tgoto cleanup;\n-    }\n-\n   new_st.op = EXEC_CLOSE;\n   new_st.ext.close = close;\n   return MATCH_YES;\n@@ -2786,34 +2707,14 @@ gfc_match_close (void)\n }\n \n \n-/* Resolve everything in a gfc_close structure.  */\n-\n-bool\n-gfc_resolve_close (gfc_close *close)\n+static bool\n+check_close_constraints (gfc_close *close, locus *where)\n {\n-  RESOLVE_TAG (&tag_unit, close->unit);\n-  RESOLVE_TAG (&tag_iomsg, close->iomsg);\n-  RESOLVE_TAG (&tag_iostat, close->iostat);\n-  RESOLVE_TAG (&tag_status, close->status);\n-\n-  if (!gfc_reference_st_label (close->err, ST_LABEL_TARGET))\n-    return false;\n+  bool warn = (close->iostat || close->err) ? true : false;\n \n   if (close->unit == NULL)\n     {\n-      /* Find a locus from one of the arguments to close, when UNIT is\n-\t not specified.  */\n-      locus loc = gfc_current_locus;\n-      if (close->status)\n-\tloc = close->status->where;\n-      else if (close->iostat)\n-\tloc = close->iostat->where;\n-      else if (close->iomsg)\n-\tloc = close->iomsg->where;\n-      else if (close->err)\n-\tloc = close->err->where;\n-\n-      gfc_error (\"CLOSE statement at %L requires a UNIT number\", &loc);\n+      gfc_error (\"CLOSE statement at %L requires a UNIT number\", where);\n       return false;\n     }\n \n@@ -2825,9 +2726,36 @@ gfc_resolve_close (gfc_close *close)\n \t\t &close->unit->where);\n     }\n \n+  /* Checks on the STATUS specifier.  */\n+  if (close->status && close->status->expr_type == EXPR_CONSTANT)\n+    {\n+      static const char *status[] = { \"KEEP\", \"DELETE\", NULL };\n+\n+      if (!compare_to_allowed_values (\"STATUS\", status, NULL, NULL,\n+\t\t\t\t      close->status->value.character.string,\n+\t\t\t\t      \"CLOSE\", warn, &close->status->where))\n+\treturn false;\n+    }\n+\n   return true;\n }\n \n+/* Resolve everything in a gfc_close structure.  */\n+\n+bool\n+gfc_resolve_close (gfc_close *close, locus *where)\n+{\n+  RESOLVE_TAG (&tag_unit, close->unit);\n+  RESOLVE_TAG (&tag_iomsg, close->iomsg);\n+  RESOLVE_TAG (&tag_iostat, close->iostat);\n+  RESOLVE_TAG (&tag_status, close->status);\n+\n+  if (!gfc_reference_st_label (close->err, ST_LABEL_TARGET))\n+    return false;\n+\n+  return check_close_constraints (close, where);\n+}\n+\n \n /* Free a gfc_filepos structure.  */\n \n@@ -2852,8 +2780,6 @@ match_file_element (gfc_filepos *fp)\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_iomsg, &fp->iomsg);\n-  if (m == MATCH_YES && !check_char_variable (fp->iomsg))\n-    return MATCH_ERROR;\n   if (m != MATCH_NO)\n     return m;\n   m = match_out_tag (&tag_iostat, &fp->iostat);\n@@ -3227,8 +3153,6 @@ match_dt_element (io_kind k, gfc_dt *dt)\n     }\n \n   m = match_etag (&tag_e_async, &dt->asynchronous);\n-  if (m == MATCH_YES && !is_char_type (\"ASYNCHRONOUS\", dt->asynchronous))\n-    return MATCH_ERROR;\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_e_blank, &dt->blank);\n@@ -3259,8 +3183,6 @@ match_dt_element (io_kind k, gfc_dt *dt)\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_iomsg, &dt->iomsg);\n-  if (m == MATCH_YES && !check_char_variable (dt->iomsg))\n-    return MATCH_ERROR;\n   if (m != MATCH_NO)\n     return m;\n \n@@ -3330,28 +3252,26 @@ gfc_free_dt (gfc_dt *dt)\n }\n \n \n+static const char *\n+io_kind_name (io_kind k);\n+\n+static bool\n+check_io_constraints (io_kind k, gfc_dt *dt, gfc_code *io_code,\n+\t\t      locus *spec_end);\n+\n /* Resolve everything in a gfc_dt structure.  */\n \n bool\n-gfc_resolve_dt (gfc_dt *dt, locus *loc)\n+gfc_resolve_dt (gfc_code *dt_code, gfc_dt *dt, locus *loc)\n {\n   gfc_expr *e;\n   io_kind k;\n-  locus tmp;\n \n   /* This is set in any case.  */\n   gcc_assert (dt->dt_io_kind);\n   k = dt->dt_io_kind->value.iokind;\n \n-  tmp = gfc_current_locus;\n-  gfc_current_locus = *loc;\n-  if (!resolve_tag (&tag_format, dt->format_expr))\n-    {\n-      gfc_current_locus = tmp;\n-      return false;\n-    }\n-  gfc_current_locus = tmp;\n-\n+  RESOLVE_TAG (&tag_format, dt->format_expr);\n   RESOLVE_TAG (&tag_rec, dt->rec);\n   RESOLVE_TAG (&tag_spos, dt->pos);\n   RESOLVE_TAG (&tag_advance, dt->advance);\n@@ -3367,6 +3287,18 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n   RESOLVE_TAG (&tag_e_decimal, dt->decimal);\n   RESOLVE_TAG (&tag_e_async, dt->asynchronous);\n \n+  /* Check I/O constraints.\n+     To validate NAMELIST we need to check if we were also given an I/O list,\n+     which is stored in code->block->next with op EXEC_TRANSFER.\n+     Note that the I/O list was already resolved from resolve_transfer.  */\n+  gfc_code *io_code = NULL;\n+  if (dt_code && dt_code->block && dt_code->block->next\n+      && dt_code->block->next->op == EXEC_TRANSFER)\n+    io_code = dt_code->block->next;\n+\n+  if (!check_io_constraints (k, dt, io_code, loc))\n+    return false;\n+\n   e = dt->io_unit;\n   if (e == NULL)\n     {\n@@ -3821,11 +3753,13 @@ terminate_io (gfc_code *io_code)\n \n \n /* Check the constraints for a data transfer statement.  The majority of the\n-   constraints appearing in 9.4 of the standard appear here.  Some are handled\n-   in resolve_tag and others in gfc_resolve_dt.  Also set the async_io_dt flag\n-   and, if necessary, the asynchronous flag on the SIZE argument.  */\n+   constraints appearing in 9.4 of the standard appear here.\n \n-static match\n+   Tag expressions are already resolved by resolve_tag, which includes\n+   verifying the type, that they are scalar, and verifying that BT_CHARACTER\n+   tags are of default kind.  */\n+\n+static bool\n check_io_constraints (io_kind k, gfc_dt *dt, gfc_code *io_code,\n \t\t      locus *spec_end)\n {\n@@ -3835,11 +3769,10 @@ if (condition) \\\n     if ((arg)->lb != NULL)\\\n       gfc_error ((msg), (arg));\\\n     else\\\n-      gfc_error ((msg), &gfc_current_locus);\\\n-    m = MATCH_ERROR;\\\n+      gfc_error ((msg), spec_end);\\\n+    return false;\\\n   }\n \n-  match m;\n   gfc_expr *expr;\n   gfc_symbol *sym = NULL;\n   bool warn, unformatted;\n@@ -3848,8 +3781,6 @@ if (condition) \\\n   unformatted = dt->format_expr == NULL && dt->format_label == NULL\n \t\t&& dt->namelist == NULL;\n \n-  m = MATCH_YES;\n-\n   expr = dt->io_unit;\n   if (expr && expr->expr_type == EXPR_VARIABLE\n       && expr->ts.type == BT_CHARACTER)\n@@ -3867,7 +3798,7 @@ if (condition) \\\n       io_constraint (dt->rec != NULL,\n \t\t     \"REC tag at %L is incompatible with internal file\",\n \t\t     &dt->rec->where);\n-    \n+\n       io_constraint (dt->pos != NULL,\n \t\t     \"POS tag at %L is incompatible with internal file\",\n \t\t     &dt->pos->where);\n@@ -3884,7 +3815,7 @@ if (condition) \\\n \t{\n \t  if (!gfc_notify_std (GFC_STD_F2003, \"Internal file at %L with \"\n \t\t\t       \"namelist\", &expr->where))\n-\t    m = MATCH_ERROR;\n+\t    return false;\n \t}\n \n       io_constraint (dt->advance != NULL,\n@@ -3897,87 +3828,57 @@ if (condition) \\\n \n       if (gfc_pure (NULL) && (k == M_READ || k == M_WRITE))\n \t{\n-\t  gfc_error (\"IO UNIT in %s statement at %C must be \"\n+\t  gfc_error (\"IO UNIT in %s statement at %L must be \"\n \t\t     \"an internal file in a PURE procedure\",\n-\t\t     io_kind_name (k));\n-\t  return MATCH_ERROR;\n+\t\t     io_kind_name (k), &expr->where);\n+\t  return false;\n \t}\n-\t  \n+\n       if (k == M_READ || k == M_WRITE)\n \tgfc_unset_implicit_pure (NULL);\n     }\n \n-  if (k != M_READ)\n-    {\n-      io_constraint (dt->end, \"END tag not allowed with output at %L\",\n-\t\t     &dt->end_where);\n-\n-      io_constraint (dt->eor, \"EOR tag not allowed with output at %L\",\n-\t\t     &dt->eor_where);\n-\n-      io_constraint (dt->blank, \"BLANK= specifier not allowed with output at %L\",\n-\t\t     &dt->blank->where);\n-\n-      io_constraint (dt->pad, \"PAD= specifier not allowed with output at %L\",\n-\t\t     &dt->pad->where);\n-\n-      io_constraint (dt->size, \"SIZE= specifier not allowed with output at %L\",\n-\t\t     &dt->size->where);\n-    }\n-  else\n-    {\n-      io_constraint (dt->size && dt->advance == NULL,\n-\t\t     \"SIZE tag at %L requires an ADVANCE tag\",\n-\t\t     &dt->size->where);\n-\n-      io_constraint (dt->eor && dt->advance == NULL,\n-\t\t     \"EOR tag at %L requires an ADVANCE tag\",\n-\t\t     &dt->eor_where);\n-    }\n-\n-  if (dt->asynchronous) \n+  if (dt->asynchronous)\n     {\n       int num;\n       static const char * asynchronous[] = { \"YES\", \"NO\", NULL };\n \n+      /* Note: gfc_reduce_init_expr reports an error if not init-expr.  */\n       if (!gfc_reduce_init_expr (dt->asynchronous))\n-\t{\n-\t  gfc_error (\"ASYNCHRONOUS= specifier at %L must be an initialization \"\n-\t\t     \"expression\", &dt->asynchronous->where);\n-\t  return MATCH_ERROR;\n-\t}\n-\n-      if (!is_char_type (\"ASYNCHRONOUS\", dt->asynchronous))\n-\treturn MATCH_ERROR;\n-\n-      if (dt->asynchronous->ts.kind != 1)\n-\t{\n-\t  gfc_error (\"ASYNCHRONOUS= specifier at %L must be of default \"\n-\t\t     \"CHARACTER kind\", &dt->asynchronous->where);\n-\t  return MATCH_ERROR;\n-\t}\n-\n-      if (dt->asynchronous->expr_type == EXPR_ARRAY\n-\t  || dt->asynchronous->expr_type == EXPR_STRUCTURE)\n-\t{\n-\t  gfc_error (\"ASYNCHRONOUS= specifier at %L must be scalar\",\n-\t\t     &dt->asynchronous->where);\n-\t  return MATCH_ERROR;\n-\t}\n+\treturn false;\n \n       if (!compare_to_allowed_values\n \t\t(\"ASYNCHRONOUS\", asynchronous, NULL, NULL,\n \t\t dt->asynchronous->value.character.string,\n-\t\t io_kind_name (k), warn, &num))\n-\treturn MATCH_ERROR;\n+\t\t io_kind_name (k), warn, &dt->asynchronous->where, &num))\n+\treturn false;\n \n-      /* Best to put this here because the yes/no info is still around.  */\n-      async_io_dt = num == 0;\n-      if (async_io_dt && dt->size)\n-\tdt->size->symtree->n.sym->attr.asynchronous = 1;\n+      /* For \"YES\", mark related symbols as asynchronous.  */\n+      if (num == 0)\n+\t{\n+\t  /* SIZE variable.  */\n+\t  if (dt->size)\n+\t    dt->size->symtree->n.sym->attr.asynchronous = 1;\n+\n+\t  /* Variables in a NAMELIST.  */\n+\t  if (dt->namelist)\n+\t    for (gfc_namelist *nl = dt->namelist->namelist; nl; nl = nl->next)\n+\t      nl->sym->attr.asynchronous = 1;\n+\n+\t  /* Variables in an I/O list.  */\n+\t  for (gfc_code *xfer = io_code; xfer && xfer->op == EXEC_TRANSFER;\n+\t       xfer = xfer->next)\n+\t    {\n+\t      gfc_expr *expr = xfer->expr1;\n+\t      while (expr != NULL && expr->expr_type == EXPR_OP\n+\t\t     && expr->value.op.op == INTRINSIC_PARENTHESES)\n+\t\texpr = expr->value.op.op1;\n+\n+\t      if (expr && expr->expr_type == EXPR_VARIABLE)\n+\t\texpr->symtree->n.sym->attr.asynchronous = 1;\n+\t    }\n+\t}\n     }\n-  else\n-    async_io_dt = false;\n \n   if (dt->id)\n     {\n@@ -3993,36 +3894,31 @@ if (condition) \\\n \n   if (dt->decimal)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\treturn MATCH_ERROR;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &dt->decimal->where))\n+\treturn false;\n \n       if (dt->decimal->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * decimal[] = { \"COMMA\", \"POINT\", NULL };\n \n-      if (!is_char_type (\"DECIMAL\", dt->decimal))\n-\treturn MATCH_ERROR;\n-\n \t  if (!compare_to_allowed_values (\"DECIMAL\", decimal, NULL, NULL,\n \t\t\t\t\t  dt->decimal->value.character.string,\n-\t\t\t\t\t  io_kind_name (k), warn))\n-\t    return MATCH_ERROR;\n+\t\t\t\t\t  io_kind_name (k), warn,\n+\t\t\t\t\t  &dt->decimal->where))\n+\t    return false;\n \n \t  io_constraint (unformatted,\n \t\t\t \"the DECIMAL= specifier at %L must be with an \"\n \t\t\t \"explicit format expression\", &dt->decimal->where);\n \t}\n     }\n-  \n+\n   if (dt->blank)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"BLANK= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\treturn MATCH_ERROR;\n-\n-      if (!is_char_type (\"BLANK\", dt->blank))\n-\treturn MATCH_ERROR;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"BLANK= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &dt->blank->where))\n+\treturn false;\n \n       if (dt->blank->expr_type == EXPR_CONSTANT)\n \t{\n@@ -4031,8 +3927,9 @@ if (condition) \\\n \n \t  if (!compare_to_allowed_values (\"BLANK\", blank, NULL, NULL,\n \t\t\t\t\t  dt->blank->value.character.string,\n-\t\t\t\t\t  io_kind_name (k), warn))\n-\t    return MATCH_ERROR;\n+\t\t\t\t\t  io_kind_name (k), warn,\n+\t\t\t\t\t  &dt->blank->where))\n+\t    return false;\n \n \t  io_constraint (unformatted,\n \t\t\t \"the BLANK= specifier at %L must be with an \"\n@@ -4042,21 +3939,19 @@ if (condition) \\\n \n   if (dt->pad)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"PAD= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\treturn MATCH_ERROR;\n-\n-      if (!is_char_type (\"PAD\", dt->pad))\n-\treturn MATCH_ERROR;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"PAD= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &dt->pad->where))\n+\treturn false;\n \n       if (dt->pad->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * pad[] = { \"YES\", \"NO\", NULL };\n \n \t  if (!compare_to_allowed_values (\"PAD\", pad, NULL, NULL,\n \t\t\t\t\t  dt->pad->value.character.string,\n-\t\t\t\t\t  io_kind_name (k), warn))\n-\t    return MATCH_ERROR;\n+\t\t\t\t\t  io_kind_name (k), warn,\n+\t\t\t\t\t  &dt->pad->where))\n+\t    return false;\n \n \t  io_constraint (unformatted,\n \t\t\t \"the PAD= specifier at %L must be with an \"\n@@ -4066,12 +3961,9 @@ if (condition) \\\n \n   if (dt->round)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"ROUND= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\treturn MATCH_ERROR;\n-\n-      if (!is_char_type (\"ROUND\", dt->round))\n-\treturn MATCH_ERROR;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ROUND= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &dt->round->where))\n+\treturn false;\n \n       if (dt->round->expr_type == EXPR_CONSTANT)\n \t{\n@@ -4081,20 +3973,18 @@ if (condition) \\\n \n \t  if (!compare_to_allowed_values (\"ROUND\", round, NULL, NULL,\n \t\t\t\t\t  dt->round->value.character.string,\n-\t\t\t\t\t  io_kind_name (k), warn))\n-\t    return MATCH_ERROR;\n+\t\t\t\t\t  io_kind_name (k), warn,\n+\t\t\t\t\t  &dt->round->where))\n+\t    return false;\n \t}\n     }\n-  \n+\n   if (dt->sign)\n     {\n       /* When implemented, change the following to use gfc_notify_std F2003.\n-      if (gfc_notify_std (GFC_STD_F2003, \"SIGN= at %C \"\n-\t  \"not allowed in Fortran 95\") == false)\n-\treturn MATCH_ERROR;  */\n-\n-      if (!is_char_type (\"SIGN\", dt->sign))\n-\treturn MATCH_ERROR;\n+      if (gfc_notify_std (GFC_STD_F2003, \"SIGN= at %L \"\n+\t  \"not allowed in Fortran 95\", &dt->sign->where) == false)\n+\treturn false;  */\n \n       if (dt->sign->expr_type == EXPR_CONSTANT)\n \t{\n@@ -4103,8 +3993,8 @@ if (condition) \\\n \n \t  if (!compare_to_allowed_values (\"SIGN\", sign, NULL, NULL,\n \t\t\t\t      dt->sign->value.character.string,\n-\t\t\t\t      io_kind_name (k), warn))\n-\t    return MATCH_ERROR;\n+\t\t\t\t      io_kind_name (k), warn, &dt->sign->where))\n+\t    return false;\n \n \t  io_constraint (unformatted,\n \t\t\t \"SIGN= specifier at %L must be with an \"\n@@ -4118,26 +4008,24 @@ if (condition) \\\n \n   if (dt->delim)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"DELIM= at %C \"\n-\t\t\t   \"not allowed in Fortran 95\"))\n-\treturn MATCH_ERROR;\n-\n-      if (!is_char_type (\"DELIM\", dt->delim))\n-\treturn MATCH_ERROR;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"DELIM= at %L \"\n+\t\t\t   \"not allowed in Fortran 95\", &dt->delim->where))\n+\treturn false;\n \n       if (dt->delim->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char *delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };\n \n \t  if (!compare_to_allowed_values (\"DELIM\", delim, NULL, NULL,\n \t\t\t\t\t  dt->delim->value.character.string,\n-\t\t\t\t\t  io_kind_name (k), warn))\n-\t    return MATCH_ERROR;\n+\t\t\t\t\t  io_kind_name (k), warn,\n+\t\t\t\t\t  &dt->delim->where))\n+\t    return false;\n \n \t  io_constraint (k == M_READ,\n \t\t\t \"DELIM= specifier at %L not allowed in a \"\n \t\t\t \"READ statement\", &dt->delim->where);\n-      \n+\n \t  io_constraint (dt->format_label != &format_asterisk\n \t\t\t && dt->namelist == NULL,\n \t\t\t \"DELIM= specifier at %L must have FMT=*\",\n@@ -4148,7 +4036,7 @@ if (condition) \\\n \t\t\t \"NML= specifier\", &dt->delim->where);\n \t}\n     }\n-  \n+\n   if (dt->namelist)\n     {\n       io_constraint (io_code && dt->namelist,\n@@ -4225,17 +4113,41 @@ if (condition) \\\n \n       io_constraint (dt->eor && not_no && k == M_READ,\n \t\t     \"EOR tag at %L requires an ADVANCE = %<NO%>\",\n-\t\t     &dt->eor_where);      \n+\t\t     &dt->eor_where);\n     }\n \n-  expr = dt->format_expr;\n-  if (!gfc_simplify_expr (expr, 0)\n-      || !check_format_string (expr, k == M_READ))\n-    return MATCH_ERROR;\n+  if (k != M_READ)\n+    {\n+      io_constraint (dt->end, \"END tag not allowed with output at %L\",\n+\t\t     &dt->end_where);\n \n-  return m;\n-}\n+      io_constraint (dt->eor, \"EOR tag not allowed with output at %L\",\n+\t\t     &dt->eor_where);\n+\n+      io_constraint (dt->blank,\n+\t\t     \"BLANK= specifier not allowed with output at %L\",\n+\t\t     &dt->blank->where);\n+\n+      io_constraint (dt->pad, \"PAD= specifier not allowed with output at %L\",\n+\t\t     &dt->pad->where);\n+\n+      io_constraint (dt->size, \"SIZE= specifier not allowed with output at %L\",\n+\t\t     &dt->size->where);\n+    }\n+  else\n+    {\n+      io_constraint (dt->size && dt->advance == NULL,\n+\t\t     \"SIZE tag at %L requires an ADVANCE tag\",\n+\t\t     &dt->size->where);\n+\n+      io_constraint (dt->eor && dt->advance == NULL,\n+\t\t     \"EOR tag at %L requires an ADVANCE tag\",\n+\t\t     &dt->eor_where);\n+    }\n+\n+  return true;\n #undef io_constraint\n+}\n \n \n /* Match a READ, WRITE or PRINT statement.  */\n@@ -4248,7 +4160,7 @@ match_io (io_kind k)\n   gfc_symbol *sym;\n   int comma_flag;\n   locus where;\n-  locus spec_end, control;\n+  locus control;\n   gfc_dt *dt;\n   match m;\n \n@@ -4451,9 +4363,6 @@ match_io (io_kind k)\n \n get_io_list:\n \n-  /* Used in check_io_constraints, where no locus is available.  */\n-  spec_end = gfc_current_locus;\n-\n   /* Save the IO kind for later use.  */\n   dt->dt_io_kind = gfc_get_iokind_expr (&gfc_current_locus, k);\n \n@@ -4485,12 +4394,11 @@ match_io (io_kind k)\n   if (flag_dec_format_defaults)\n     dt->dec_ext = 1;\n \n-  /* A full IO statement has been matched.  Check the constraints.  spec_end is\n-     supplied for cases where no locus is supplied.  */\n-  m = check_io_constraints (k, dt, io_code, &spec_end);\n-\n-  if (m == MATCH_ERROR)\n-    goto cleanup;\n+  /* Check the format string now.  */\n+  if (dt->format_expr\n+      && (!gfc_simplify_expr (dt->format_expr, 0)\n+\t  || !check_format_string (dt->format_expr, k == M_READ)))\n+    return MATCH_ERROR;\n \n   new_st.op = (k == M_READ) ? EXEC_READ : EXEC_WRITE;\n   new_st.ext.dt = dt;\n@@ -4610,8 +4518,6 @@ match_inquire_element (gfc_inquire *inquire)\n   RETM m = match_etag (&tag_file, &inquire->file);\n   RETM m = match_ltag (&tag_err, &inquire->err);\n   RETM m = match_etag (&tag_iomsg, &inquire->iomsg);\n-  if (m == MATCH_YES && !check_char_variable (inquire->iomsg))\n-    return MATCH_ERROR;\n   RETM m = match_out_tag (&tag_iostat, &inquire->iostat);\n   RETM m = match_vtag (&tag_exist, &inquire->exist);\n   RETM m = match_vtag (&tag_opened, &inquire->opened);\n@@ -4633,8 +4539,6 @@ match_inquire_element (gfc_inquire *inquire)\n   RETM m = match_vtag (&tag_write, &inquire->write);\n   RETM m = match_vtag (&tag_readwrite, &inquire->readwrite);\n   RETM m = match_vtag (&tag_s_async, &inquire->asynchronous);\n-  if (m == MATCH_YES && !is_char_type (\"ASYNCHRONOUS\", inquire->asynchronous))\n-    return MATCH_ERROR;\n   RETM m = match_vtag (&tag_s_delim, &inquire->delim);\n   RETM m = match_vtag (&tag_s_decimal, &inquire->decimal);\n   RETM m = match_out_tag (&tag_size, &inquire->size);\n@@ -4914,8 +4818,6 @@ match_wait_element (gfc_wait *wait)\n   RETM m = match_ltag (&tag_end, &wait->end);\n   RETM m = match_ltag (&tag_eor, &wait->eor);\n   RETM m = match_etag (&tag_iomsg, &wait->iomsg);\n-  if (m == MATCH_YES && !check_char_variable (wait->iomsg))\n-    return MATCH_ERROR;\n   RETM m = match_out_tag (&tag_iostat, &wait->iostat);\n   RETM m = match_etag (&tag_id, &wait->id);\n   RETM return MATCH_NO;"}, {"sha": "ccd2a5e3b7d0fe16984d7fc3a0a66ca44c3fefb2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -9941,9 +9941,6 @@ resolve_transfer (gfc_code *code)\n \t\t \"an assumed-size array\", &code->loc);\n       return;\n     }\n-\n-  if (async_io_dt && exp->expr_type == EXPR_VARIABLE)\n-    exp->symtree->n.sym->attr.asynchronous = 1;\n }\n \n \n@@ -12003,14 +12000,14 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_OPEN:\n-\t  if (!gfc_resolve_open (code->ext.open))\n+\t  if (!gfc_resolve_open (code->ext.open, &code->loc))\n \t    break;\n \n \t  resolve_branch (code->ext.open->err, code);\n \t  break;\n \n \tcase EXEC_CLOSE:\n-\t  if (!gfc_resolve_close (code->ext.close))\n+\t  if (!gfc_resolve_close (code->ext.close, &code->loc))\n \t    break;\n \n \t  resolve_branch (code->ext.close->err, code);\n@@ -12052,7 +12049,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \tcase EXEC_READ:\n \tcase EXEC_WRITE:\n-\t  if (!gfc_resolve_dt (code->ext.dt, &code->loc))\n+\t  if (!gfc_resolve_dt (code, code->ext.dt, &code->loc))\n \t    break;\n \n \t  resolve_branch (code->ext.dt->err, code);\n@@ -15009,11 +15006,6 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t}\n     }\n \n-  if (async_io_dt)\n-    {\n-      for (nl = sym->namelist; nl; nl = nl->next)\n-\tnl->sym->attr.asynchronous = 1;\n-    }\n   return true;\n }\n "}, {"sha": "d8fa35aca9c25eb15ef21bfee20af0edb79ca5b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -1,3 +1,29 @@\n+2020-04-09  Fritz Reese  <foreese@gcc.gnu.org>\n+\n+\tPR fortran/87923\n+\t* gfortran.dg/f2003_io_8.f03: Fix expected error messages.\n+\t* gfortran.dg/io_constraints_8.f90: Likewise.\n+\t* gfortran.dg/iomsg_2.f90: Likewise.\n+\t* gfortran.dg/pr66725.f90: Likewise.\n+\t* gfortran.dg/pr88205.f90: Likewise.\n+\t* gfortran.dg/write_check4.f90: Likewise.\n+\t* gfortran.dg/asynchronous_5.f03: New test.\n+\t* gfortran.dg/io_constraints_15.f90: Likewise.\n+\t* gfortran.dg/io_constraints_16.f90: Likewise.\n+\t* gfortran.dg/io_constraints_17.f90: Likewise.\n+\t* gfortran.dg/io_constraints_18.f90: Likewise.\n+\t* gfortran.dg/io_tags_1.f90: Likewise.\n+\t* gfortran.dg/io_tags_10.f90: Likewise.\n+\t* gfortran.dg/io_tags_2.f90: Likewise.\n+\t* gfortran.dg/io_tags_3.f90: Likewise.\n+\t* gfortran.dg/io_tags_4.f90: Likewise.\n+\t* gfortran.dg/io_tags_5.f90: Likewise.\n+\t* gfortran.dg/io_tags_6.f90: Likewise.\n+\t* gfortran.dg/io_tags_7.f90: Likewise.\n+\t* gfortran.dg/io_tags_8.f90: Likewise.\n+\t* gfortran.dg/io_tags_9.f90: Likewise.\n+\t* gfortran.dg/write_check5.f90: Likewise.\n+\n 2020-04-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/aarch64/sve/acle/general/attributes_1.c: New test."}, {"sha": "fcd281d5001b5d60e2f8819e0c69c475cfb939c4", "filename": "gcc/testsuite/gfortran.dg/asynchronous_5.f03", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_5.f03?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! Covers code introduced by the fix to PR fortran/87923.\n+! The idea is that the variables in a namelist or I/O list used for\n+! asynchronous I/O will be marked with the asynchronous attribute.\n+!\n+! At this time, \"asynchronous\" is treated as \"volatile\" (see trans-decl.c).\n+! Thus, every variable referenced in an \"asynchronous=yes\" I/O list\n+! should obtain the \"volatile\" specifier in its declaration.\n+!\n+\n+type t\n+  character(4) :: comp_async\n+end type\n+\n+character(2) :: ccvar_async\n+type(t) :: dvar_async\n+integer :: ivar_async\n+real :: rvar_async\n+logical :: lvar_async\n+type(t), dimension(2) :: darrvar_async\n+integer :: ivar_noasync\n+\n+namelist /names/ ivar_async, rvar_async, lvar_async\n+\n+open(1, asynchronous=\"yes\")\n+write(1, asynchronous=\"yes\") dvar_async, ccvar_async\n+write(1, asynchronous=\"yes\") dvar_async%comp_async, darrvar_async\n+read(1, asynchronous=\"yes\", nml=names)\n+\n+open(2, asynchronous=\"no\")\n+read(2, asynchronous=\"no\") ivar_noasync\n+\n+end\n+\n+! { dg-final { scan-tree-dump-times \"volatile.*?ccvar_async\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"volatile.*?dvar_async\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"volatile.*?ivar_async\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"volatile.*?rvar_async\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"volatile.*?lvar_async\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"volatile.*?darrvar_async\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-not \"volatile.*?ivar_noasync\" \"original\" } }"}, {"sha": "5604e0413e29d8313cb98dbad008cfc5541b4da3", "filename": "gcc/testsuite/gfortran.dg/f2003_io_8.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_8.f03?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -9,5 +9,5 @@\n open(10, file='mydata_f2003_io_8', asynchronous=\"yes\", blank=\"null\")\n write(10,'(10f8.3)', asynchronous='no', decimal=\"comma\", id=j) a ! { dg-error \"must be with ASYNCHRONOUS=\" }\n read(10,'(10f8.3)', id=j, decimal=\"comma\", blank=\"zero\") b ! { dg-error \"must be with ASYNCHRONOUS=\" }\n-read(10,'(10f8.3)', asynchronous=msg, decimal=\"comma\", blank=\"zero\") b ! { dg-error \"must be an initialization expression\" }\n+read(10,'(10f8.3)', asynchronous=msg, decimal=\"comma\", blank=\"zero\") b ! { dg-error \"does not reduce to a constant expression\" }\n end"}, {"sha": "47a5bf6923fb43f78d7cf600da14da8b16afa9c6", "filename": "gcc/testsuite/gfortran.dg/io_constraints_15.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_15.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+!\n+! PR fortran/87923\n+!\n+program p\n+   open (1, blank=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   open (2, decimal=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   open (3, encoding=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   open (4, round=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   open (5, sign=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+end"}, {"sha": "dcbbbae17c07da0b6858279fdcbe44c16db2388f", "filename": "gcc/testsuite/gfortran.dg/io_constraints_16.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_16.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+!\n+! PR fortran/87923\n+!\n+program p\n+   read (1, blank=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   read (1, delim=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   read (1, pad=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   read (1, round=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   read (1, sign=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+end"}, {"sha": "5864351debc205561330ca35bf4c761aa5fa4622", "filename": "gcc/testsuite/gfortran.dg/io_constraints_17.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_17.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+!\n+! PR fortran/87923\n+!\n+program p\n+   write (1, blank=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   write (1, delim=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   write (1, pad=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   write (1, round=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   write (1, sign=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+end"}, {"sha": "1694871c5f6c545aaa095920419ad9b9abd76e18", "filename": "gcc/testsuite/gfortran.dg/io_constraints_18.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_18.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,9 @@\n+! { dg-options \"-fdec\" }\n+! { dg-do compile }\n+!\n+! PR fortran/87923\n+!\n+program p\n+   open (1, carriagecontrol=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+   open (2, share=char(1000,4)) ! { dg-error \"must be a character string of default kind\" }\n+end"}, {"sha": "e3272e4a3883c1fd6bb142f93563e8906f3f064c", "filename": "gcc/testsuite/gfortran.dg/io_constraints_8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_8.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -14,7 +14,7 @@\n \n OPEN(99, access=4_'direct')     ! { dg-error \"must be a character string of default kind\" }\n OPEN(99, action=4_'read')       ! { dg-error \"must be a character string of default kind\" }\n-OPEN(99, asynchronous=4_'no')   ! { dg-error \"must be of default CHARACTER kind\" }\n+OPEN(99, asynchronous=4_'no')   ! { dg-error \"must be a character string of default kind\" }\n OPEN(99, blank=4_'null')        ! { dg-error \"must be a character string of default kind\" }\n OPEN(99, decimal=4_'comma')     ! { dg-error \"must be a character string of default kind\" }\n OPEN(99, delim=4_'quote')       ! { dg-error \"must be a character string of default kind\" }"}, {"sha": "2ada161310c25fcec88a7df7d7c94ec28a483053", "filename": "gcc/testsuite/gfortran.dg/io_tags_1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_1.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+\n+backspace (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+backspace (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+backspace (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+backspace (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+backspace (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+backspace (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+backspace (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+backspace (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+backspace (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+backspace (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+backspace (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+backspace (1, iomsg=['no']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+end"}, {"sha": "377ac6166807b7aee71c10435b61a49305ded151", "filename": "gcc/testsuite/gfortran.dg/io_tags_10.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_10.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+write (1, blank='') ! { dg-error \"BLANK specifier in WRITE statement at ... has invalid value\" }\n+\n+write (1, asynchronous=1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+write (1, asynchronous=1e1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+write (1, asynchronous=1d1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+write (1, asynchronous=.false.) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+write (1, asynchronous='') ! { dg-error \"ASYNCHRONOUS specifier in WRITE statement at ... has invalid value\" }\n+write (1, asynchronous='no')\n+write (1, asynchronous=null()) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+write (1, asynchronous=(1)) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+write (1, asynchronous=(1., 0.)) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+write (1, asynchronous=[1]) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+write (1, asynchronous=['']) ! { dg-error \"ASYNCHRONOUS tag at ... must be scalar\" }\n+\n+write (1, blank=1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+write (1, blank=1e1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+write (1, blank=1d1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+write (1, blank=.false.) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+write (1, blank='no') ! { dg-error \"BLANK specifier in WRITE statement at ... has invalid value\" }\n+write (1, blank=null()) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+write (1, blank=(1)) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+write (1, blank=(1., 0.)) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+write (1, blank=[1]) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+write (1, blank=['']) ! { dg-error \"BLANK tag at ... must be scalar\" }\n+\n+write (1, delim=1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+write (1, delim=1e1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+write (1, delim=1d1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+write (1, delim=.false.) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+write (1, delim='') ! { dg-error \"DELIM specifier in WRITE statement at ... has invalid value\" }\n+write (1, delim='no') ! { dg-error \"DELIM specifier in WRITE statement at ... has invalid value\" }\n+write (1, delim=null()) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+write (1, delim=(1)) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+write (1, delim=(1., 0.)) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+write (1, delim=[1]) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+write (1, delim=['']) ! { dg-error \"DELIM tag at ... must be scalar\" }\n+\n+write (1, decimal=1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+write (1, decimal=1e1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+write (1, decimal=1d1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+write (1, decimal=.false.) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+write (1, decimal='') ! { dg-error \"DECIMAL specifier in WRITE statement at ... has invalid value\" }\n+write (1, decimal='no') ! { dg-error \"DECIMAL specifier in WRITE statement at ... has invalid value\" }\n+write (1, decimal=null()) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+write (1, decimal=(1)) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+write (1, decimal=(1., 0.)) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+write (1, decimal=[1]) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+write (1, decimal=['']) ! { dg-error \"DECIMAL tag at ... must be scalar\" }\n+\n+write (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+write (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+write (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+write (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+write (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+write (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+write (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+write (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+write (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+write (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+write (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+\n+write (1, pad=1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+write (1, pad=1e1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+write (1, pad=1d1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+write (1, pad=.false.) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+write (1, pad='') ! { dg-error \"PAD specifier in WRITE statement at ... has invalid value\" }\n+write (1, pad='no') ! { dg-error \"the PAD= specifier at ... must be with an explicit format expression\" }\n+write (1, pad=null()) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+write (1, pad=(1)) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+write (1, pad=(1., 0.)) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+write (1, pad=[1]) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+write (1, pad=['']) ! { dg-error \"PAD tag at ... must be scalar\" }\n+\n+write (1, round=1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+write (1, round=1e1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+write (1, round=1d1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+write (1, round=.false.) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+write (1, round='') ! { dg-error \"ROUND specifier in WRITE statement at ... has invalid value\" }\n+write (1, round='no') ! { dg-error \"ROUND specifier in WRITE statement at ... has invalid value\" }\n+write (1, round=null()) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+write (1, round=(1)) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+write (1, round=(1., 0.)) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+write (1, round=[1]) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+write (1, round=['']) ! { dg-error \"ROUND tag at ... must be scalar\" }\n+\n+write (1, sign=1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+write (1, sign=1e1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+write (1, sign=1d1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+write (1, sign=.false.) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+write (1, sign='') ! { dg-error \"SIGN specifier in WRITE statement at ... has invalid value\" }\n+write (1, sign='no') ! { dg-error \"SIGN specifier in WRITE statement at ... has invalid value\" }\n+write (1, sign=null()) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+write (1, sign=(1)) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+write (1, sign=(1., 0.)) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+write (1, sign=[1]) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+write (1, sign=['']) ! { dg-error \"SIGN tag at ... must be scalar\" }\n+\n+end"}, {"sha": "3eb11376fb4c557ef2678828cb5ac66324f801ce", "filename": "gcc/testsuite/gfortran.dg/io_tags_2.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_2.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+close (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+close (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+close (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+close (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+close (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+close (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+close (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+close (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+close (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+close (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+close (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+close (1, iomsg=['no']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+\n+close (1, status=1) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+close (1, status=1e1) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+close (1, status=1d1) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+close (1, status=.false.) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+close (1, status='') ! { dg-error \"STATUS specifier in CLOSE statement at ... has invalid value\" }\n+close (1, status='no') ! { dg-error \"STATUS specifier in CLOSE statement at ... has invalid value\" }\n+close (1, status=null()) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+close (1, status=(1)) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+close (1, status=(1., 0.)) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+close (1, status=[1]) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+close (1, status=['']) ! { dg-error \"STATUS tag at ... must be scalar\" }\n+end"}, {"sha": "198342b06728a706963b1fd0c62cde8ef35ba7f3", "filename": "gcc/testsuite/gfortran.dg/io_tags_3.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_3.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+endfile (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+endfile (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+endfile (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+endfile (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+endfile (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+endfile (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+endfile (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+endfile (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+endfile (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+endfile (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+endfile (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+end"}, {"sha": "9396ef443a07e31b947c5cf4ac7022f97ad0b5da", "filename": "gcc/testsuite/gfortran.dg/io_tags_4.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_4.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+flush (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+flush (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+flush (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+flush (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+flush (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+flush (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+flush (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+flush (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+flush (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+flush (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+flush (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+end"}, {"sha": "a6026619dba8899fc53a5e63b32f317991983775", "filename": "gcc/testsuite/gfortran.dg/io_tags_5.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_5.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+inquire (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+inquire (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+inquire (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+inquire (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+inquire (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+inquire (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+inquire (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+inquire (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+inquire (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+inquire (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+inquire (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+end"}, {"sha": "a8cc38300b661bbf4bfdbe9f6224ee36e5205643", "filename": "gcc/testsuite/gfortran.dg/io_tags_6.f90", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_6.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,175 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+open (1, access=1) ! { dg-error \"ACCESS tag at ... must be of type CHARACTER\" }\n+open (1, access=1e1) ! { dg-error \"ACCESS tag at ... must be of type CHARACTER\" }\n+open (1, access=1d1) ! { dg-error \"ACCESS tag at ... must be of type CHARACTER\" }\n+open (1, access=.false.) ! { dg-error \"ACCESS tag at ... must be of type CHARACTER\" }\n+open (1, access='') ! { dg-error \"ACCESS specifier in OPEN statement at ... has invalid value\" }\n+open (1, access='no') ! { dg-error \"ACCESS specifier in OPEN statement at ... has invalid value\" }\n+open (1, access=null()) ! { dg-error \"ACCESS tag at ... must be of type CHARACTER\" }\n+open (1, access=(1)) ! { dg-error \"ACCESS tag at ... must be of type CHARACTER\" }\n+open (1, access=(1., 0.)) ! { dg-error \"ACCESS tag at ... must be of type CHARACTER\" }\n+open (1, access=[1]) ! { dg-error \"ACCESS tag at ... must be of type CHARACTER\" }\n+open (1, access=['']) ! { dg-error \"ACCESS tag at ... must be scalar\" }\n+\n+open (1, action=1) ! { dg-error \"ACTION tag at ... must be of type CHARACTER\" }\n+open (1, action=1e1) ! { dg-error \"ACTION tag at ... must be of type CHARACTER\" }\n+open (1, action=1d1) ! { dg-error \"ACTION tag at ... must be of type CHARACTER\" }\n+open (1, action=.false.) ! { dg-error \"ACTION tag at ... must be of type CHARACTER\" }\n+open (1, action='') ! { dg-error \"ACTION specifier in OPEN statement at ... has invalid value\" }\n+open (1, action='no') ! { dg-error \"ACTION specifier in OPEN statement at ... has invalid value\" }\n+open (1, action=null()) ! { dg-error \"ACTION tag at ... must be of type CHARACTER\" }\n+open (1, action=(1)) ! { dg-error \"ACTION tag at ... must be of type CHARACTER\" }\n+open (1, action=(1., 0.)) ! { dg-error \"ACTION tag at ... must be of type CHARACTER\" }\n+open (1, action=[1]) ! { dg-error \"ACTION tag at ... must be of type CHARACTER\" }\n+open (1, action=['']) ! { dg-error \"ACTION tag at ... must be scalar\" }\n+\n+open (1, asynchronous=1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+open (1, asynchronous=1e1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+open (1, asynchronous=1d1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+open (1, asynchronous=.false.) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+open (1, asynchronous='') ! { dg-error \"ASYNCHRONOUS specifier in OPEN statement at ... has invalid value\" }\n+open (1, asynchronous='no')\n+open (1, asynchronous=null()) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+open (1, asynchronous=(1)) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+open (1, asynchronous=(1., 0.)) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+open (1, asynchronous=[1]) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+open (1, asynchronous=['']) ! { dg-error \"ASYNCHRONOUS tag at ... must be scalar\" }\n+\n+open (1, blank=1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+open (1, blank=1e1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+open (1, blank=1d1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+open (1, blank=.false.) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+open (1, blank='') ! { dg-error \"BLANK specifier in OPEN statement at ... has invalid value\" }\n+open (1, blank='no') ! { dg-error \"BLANK specifier in OPEN statement at ... has invalid value\" }\n+open (1, blank=null()) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+open (1, blank=(1)) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+open (1, blank=(1., 0.)) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+open (1, blank=[1]) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+open (1, blank=['']) ! { dg-error \"BLANK tag at ... must be scalar\" }\n+\n+open (1, delim=1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+open (1, delim=1e1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+open (1, delim=1d1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+open (1, delim=.false.) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+open (1, delim='') ! { dg-error \"DELIM specifier in OPEN statement at ... has invalid value\" }\n+open (1, delim='no') ! { dg-error \"DELIM specifier in OPEN statement at ... has invalid value\" }\n+open (1, delim=null()) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+open (1, delim=(1)) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+open (1, delim=(1., 0.)) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+open (1, delim=[1]) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+open (1, delim=['']) ! { dg-error \"DELIM tag at ... must be scalar\" }\n+\n+open (1, decimal=1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+open (1, decimal=1e1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+open (1, decimal=1d1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+open (1, decimal=.false.) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+open (1, decimal='') ! { dg-error \"DECIMAL specifier in OPEN statement at ... has invalid value\" }\n+open (1, decimal='no') ! { dg-error \"DECIMAL specifier in OPEN statement at ... has invalid value\" }\n+open (1, decimal=null()) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+open (1, decimal=(1)) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+open (1, decimal=(1., 0.)) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+open (1, decimal=[1]) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+open (1, decimal=['']) ! { dg-error \"DECIMAL tag at ... must be scalar\" }\n+\n+open (1, encoding=1) ! { dg-error \"ENCODING tag at ... must be of type CHARACTER\" }\n+open (1, encoding=1e1) ! { dg-error \"ENCODING tag at ... must be of type CHARACTER\" }\n+open (1, encoding=1d1) ! { dg-error \"ENCODING tag at ... must be of type CHARACTER\" }\n+open (1, encoding=.false.) ! { dg-error \"ENCODING tag at ... must be of type CHARACTER\" }\n+open (1, encoding='') ! { dg-error \"ENCODING specifier in OPEN statement at ... has invalid value\" }\n+open (1, encoding='no') ! { dg-error \"ENCODING specifier in OPEN statement at ... has invalid value\" }\n+open (1, encoding=null()) ! { dg-error \"ENCODING tag at ... must be of type CHARACTER\" }\n+open (1, encoding=(1)) ! { dg-error \"ENCODING tag at ... must be of type CHARACTER\" }\n+open (1, encoding=(1., 0.)) ! { dg-error \"ENCODING tag at ... must be of type CHARACTER\" }\n+open (1, encoding=[1]) ! { dg-error \"ENCODING tag at ... must be of type CHARACTER\" }\n+open (1, encoding=['']) ! { dg-error \"ENCODING tag at ... must be scalar\" }\n+\n+open (1, form=1) ! { dg-error \"FORM tag at ... must be of type CHARACTER\" }\n+open (1, form=1e1) ! { dg-error \"FORM tag at ... must be of type CHARACTER\" }\n+open (1, form=1d1) ! { dg-error \"FORM tag at ... must be of type CHARACTER\" }\n+open (1, form=.false.) ! { dg-error \"FORM tag at ... must be of type CHARACTER\" }\n+open (1, form='') ! { dg-error \"FORM specifier in OPEN statement at ... has invalid value\" }\n+open (1, form='no') ! { dg-error \"FORM specifier in OPEN statement at ... has invalid value\" }\n+open (1, form=null()) ! { dg-error \"FORM tag at ... must be of type CHARACTER\" }\n+open (1, form=(1)) ! { dg-error \"FORM tag at ... must be of type CHARACTER\" }\n+open (1, form=(1., 0.)) ! { dg-error \"FORM tag at ... must be of type CHARACTER\" }\n+open (1, form=[1]) ! { dg-error \"FORM tag at ... must be of type CHARACTER\" }\n+open (1, form=['']) ! { dg-error \"FORM tag at ... must be scalar\" }\n+\n+open (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+open (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+open (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+open (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+open (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+open (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+open (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+open (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+open (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+open (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+open (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+\n+open (1, pad=1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+open (1, pad=1e1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+open (1, pad=1d1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+open (1, pad=.false.) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+open (1, pad='') ! { dg-error \"PAD specifier in OPEN statement at ... has invalid value\" }\n+open (1, pad='no')\n+open (1, pad=null()) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+open (1, pad=(1)) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+open (1, pad=(1., 0.)) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+open (1, pad=[1]) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+open (1, pad=['']) ! { dg-error \"PAD tag at ... must be scalar\" }\n+\n+open (1, position=1) ! { dg-error \"POSITION tag at ... must be of type CHARACTER\" }\n+open (1, position=1e1) ! { dg-error \"POSITION tag at ... must be of type CHARACTER\" }\n+open (1, position=1d1) ! { dg-error \"POSITION tag at ... must be of type CHARACTER\" }\n+open (1, position=.false.) ! { dg-error \"POSITION tag at ... must be of type CHARACTER\" }\n+open (1, position='') ! { dg-error \"POSITION specifier in OPEN statement at ... has invalid value\" }\n+open (1, position='no') ! { dg-error \"POSITION specifier in OPEN statement at ... has invalid value\" }\n+open (1, position=null()) ! { dg-error \"POSITION tag at ... must be of type CHARACTER\" }\n+open (1, position=(1)) ! { dg-error \"POSITION tag at ... must be of type CHARACTER\" }\n+open (1, position=(1., 0.)) ! { dg-error \"POSITION tag at ... must be of type CHARACTER\" }\n+open (1, position=[1]) ! { dg-error \"POSITION tag at ... must be of type CHARACTER\" }\n+open (1, position=['']) ! { dg-error \"POSITION tag at ... must be scalar\" }\n+\n+open (1, round=1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+open (1, round=1e1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+open (1, round=1d1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+open (1, round=.false.) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+open (1, round='') ! { dg-error \"ROUND specifier in OPEN statement at ... has invalid value\" }\n+open (1, round='no') ! { dg-error \"ROUND specifier in OPEN statement at ... has invalid value\" }\n+open (1, round=null()) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+open (1, round=(1)) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+open (1, round=(1., 0.)) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+open (1, round=[1]) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+open (1, round=['']) ! { dg-error \"ROUND tag at ... must be scalar\" }\n+\n+open (1, sign=1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+open (1, sign=1e1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+open (1, sign=1d1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+open (1, sign=.false.) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+open (1, sign='') ! { dg-error \"SIGN specifier in OPEN statement at ... has invalid value\" }\n+open (1, sign='no') ! { dg-error \"SIGN specifier in OPEN statement at ... has invalid value\" }\n+open (1, sign=null()) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+open (1, sign=(1)) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+open (1, sign=(1., 0.)) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+open (1, sign=[1]) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+open (1, sign=['']) ! { dg-error \"SIGN tag at ... must be scalar\" }\n+\n+open (1, status=1) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+open (1, status=1e1) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+open (1, status=1d1) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+open (1, status=.false.) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+open (1, status='') ! { dg-error \"STATUS specifier in OPEN statement at ... has invalid value\" }\n+open (1, status='no') ! { dg-error \"STATUS specifier in OPEN statement at ... has invalid value\" }\n+open (1, status=null()) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+open (1, status=(1)) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+open (1, status=(1., 0.)) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+open (1, status=[1]) ! { dg-error \"STATUS tag at ... must be of type CHARACTER\" }\n+open (1, status=['']) ! { dg-error \"STATUS tag at ... must be scalar\" }\n+\n+\n+end"}, {"sha": "12e3189ec10fdab2b5f0f9f6c433d7accea1772f", "filename": "gcc/testsuite/gfortran.dg/io_tags_7.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_7.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+read (1, asynchronous=1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+read (1, asynchronous=1e1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+read (1, asynchronous=1d1) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+read (1, asynchronous=.false.) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+read (1, asynchronous='') ! { dg-error \"ASYNCHRONOUS specifier in READ statement at ... has invalid value\" }\n+read (1, asynchronous='no')\n+read (1, asynchronous=null()) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+read (1, asynchronous=(1)) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+read (1, asynchronous=(1., 0.)) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+read (1, asynchronous=[1]) ! { dg-error \"ASYNCHRONOUS tag at ... must be of type CHARACTER\" }\n+read (1, asynchronous=['']) ! { dg-error \"ASYNCHRONOUS tag at ... must be scalar\" }\n+\n+read (1, blank=1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+read (1, blank=1e1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+read (1, blank=1d1) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+read (1, blank=.false.) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+read (1, blank='') ! { dg-error \"BLANK specifier in READ statement at ... has invalid value\" }\n+read (1, blank='no') ! { dg-error \"BLANK specifier in READ statement at ... has invalid value\" }\n+read (1, blank=null()) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+read (1, blank=(1)) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+read (1, blank=(1., 0.)) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+read (1, blank=[1]) ! { dg-error \"BLANK tag at ... must be of type CHARACTER\" }\n+read (1, blank=['']) ! { dg-error \"BLANK tag at ... must be scalar\" }\n+\n+read (1, delim=1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+read (1, delim=1e1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+read (1, delim=1d1) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+read (1, delim=.false.) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+read (1, delim='') ! { dg-error \"DELIM specifier in READ statement at ... has invalid value\" }\n+read (1, delim='no') ! { dg-error \"DELIM specifier in READ statement at ... has invalid value\" }\n+read (1, delim=null()) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+read (1, delim=(1)) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+read (1, delim=(1., 0.)) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+read (1, delim=[1]) ! { dg-error \"DELIM tag at ... must be of type CHARACTER\" }\n+read (1, delim=['']) ! { dg-error \"DELIM tag at ... must be scalar\" }\n+\n+read (1, decimal=1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+read (1, decimal=1e1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+read (1, decimal=1d1) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+read (1, decimal=.false.) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+read (1, decimal='') ! { dg-error \"DECIMAL specifier in READ statement at ... has invalid value\" }\n+read (1, decimal='no') ! { dg-error \"DECIMAL specifier in READ statement at ... has invalid value\" }\n+read (1, decimal=null()) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+read (1, decimal=(1)) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+read (1, decimal=(1., 0.)) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+read (1, decimal=[1]) ! { dg-error \"DECIMAL tag at ... must be of type CHARACTER\" }\n+read (1, decimal=['']) ! { dg-error \"DECIMAL tag at ... must be scalar\" }\n+\n+read (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+read (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+read (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+read (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+read (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+read (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+read (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+read (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+read (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+read (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+read (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+\n+read (1, pad=1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+read (1, pad=1e1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+read (1, pad=1d1) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+read (1, pad=.false.) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+read (1, pad='') ! { dg-error \"PAD specifier in READ statement at ... has invalid value\" }\n+read (1, pad='no') ! { dg-error \"the PAD= specifier at ... must be with an explicit format expression\" }\n+read (1, pad=null()) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+read (1, pad=(1)) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+read (1, pad=(1., 0.)) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+read (1, pad=[1]) ! { dg-error \"PAD tag at ... must be of type CHARACTER\" }\n+read (1, pad=['']) ! { dg-error \"PAD tag at ... must be scalar\" }\n+\n+read (1, round=1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+read (1, round=1e1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+read (1, round=1d1) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+read (1, round=.false.) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+read (1, round='') ! { dg-error \"ROUND specifier in READ statement at ... has invalid value\" }\n+read (1, round='no') ! { dg-error \"ROUND specifier in READ statement at ... has invalid value\" }\n+read (1, round=null()) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+read (1, round=(1)) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+read (1, round=(1., 0.)) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+read (1, round=[1]) ! { dg-error \"ROUND tag at ... must be of type CHARACTER\" }\n+read (1, round=['']) ! { dg-error \"ROUND tag at ... must be scalar\" }\n+\n+read (1, sign=1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+read (1, sign=1e1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+read (1, sign=1d1) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+read (1, sign=.false.) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+read (1, sign='') ! { dg-error \"SIGN specifier in READ statement at ... has invalid value\" }\n+read (1, sign='no') ! { dg-error \"SIGN specifier in READ statement at ... has invalid value\" }\n+read (1, sign=null()) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+read (1, sign=(1)) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+read (1, sign=(1., 0.)) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+read (1, sign=[1]) ! { dg-error \"SIGN tag at ... must be of type CHARACTER\" }\n+read (1, sign=['']) ! { dg-error \"SIGN tag at ... must be scalar\" }\n+\n+\n+end"}, {"sha": "f37210ef5ccd5efb0545111da32fc6d3d5c59fb1", "filename": "gcc/testsuite/gfortran.dg/io_tags_8.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_8.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+rewind (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+rewind (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+rewind (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+rewind (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+rewind (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+rewind (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+rewind (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+rewind (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+rewind (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+rewind (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+rewind (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+\n+end"}, {"sha": "55f9545f51d2b4ca0ca2c443fb98a960a134bdb8", "filename": "gcc/testsuite/gfortran.dg/io_tags_9.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_tags_9.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! Based on PR fortran/66724, also covers fortran/66725 and fortran/87923.\n+!\n+\n+wait (1, iomsg=1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+wait (1, iomsg=1e1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+wait (1, iomsg=1d1) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+wait (1, iomsg=.false.) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+wait (1, iomsg='') ! { dg-error \"Non-variable expression\" }\n+wait (1, iomsg='no') ! { dg-error \"Non-variable expression\" }\n+wait (1, iomsg=null()) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+wait (1, iomsg=(1)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+wait (1, iomsg=(1., 0.)) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+wait (1, iomsg=[1]) ! { dg-error \"IOMSG tag at ... must be of type CHARACTER\" }\n+wait (1, iomsg=['']) ! { dg-error \"IOMSG tag at ... must be scalar\" }\n+\n+end"}, {"sha": "5023692daefa530e9218315c2a46bbe33c71d906", "filename": "gcc/testsuite/gfortran.dg/iomsg_2.f90", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fiomsg_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fiomsg_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiomsg_2.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -2,30 +2,30 @@\n subroutine foo1\n    implicit none\n    integer i\n-   open(1, iomsg=666)      ! { dg-error \"IOMSG must be\" }\n-   open(1, iomsg='sgk')    ! { dg-error \"IOMSG must be\" }\n-   open(1, iomsg=i)        ! { dg-error \"IOMSG must be\" }\n-   close(1, iomsg=666)     ! { dg-error \"IOMSG must be\" }\n-   close(1, iomsg='sgk')   ! { dg-error \"IOMSG must be\" }\n-   close(1, iomsg=i)       ! { dg-error \"IOMSG must be\" }\n+   open(1, iomsg=666)      ! { dg-error \"must be of type CHARACTER\" }\n+   open(1, iomsg='sgk')    ! { dg-error \"Non-variable expression\" }\n+   open(1, iomsg=i)        ! { dg-error \"must be of type CHARACTER\" }\n+   close(1, iomsg=666)     ! { dg-error \"must be of type CHARACTER\" }\n+   close(1, iomsg='sgk')   ! { dg-error \"Non-variable expression\" }\n+   close(1, iomsg=i)       ! { dg-error \"must be of type CHARACTER\" }\n end subroutine foo1\n \n subroutine foo\n    implicit none\n    integer i\n    real :: x = 1\n-   write(1, *, iomsg='sgk') x   ! { dg-error \"IOMSG must be\" }\n-   write(1, *, iomsg=i)     x   ! { dg-error \"IOMSG must be\" }\n-   read(1,  *, iomsg='sgk') x   ! { dg-error \"IOMSG must be\" }\n-   read(1,  *, iomsg=i)     x   ! { dg-error \"IOMSG must be\" }\n-   flush(1,    iomsg='sgk')     ! { dg-error \"IOMSG must be\" }\n-   flush(1,    iomsg=i)         ! { dg-error \"IOMSG must be\" }\n-   rewind(1,   iomsg='sgk')     ! { dg-error \"IOMSG must be\" }\n-   rewind(1,   iomsg=i)         ! { dg-error \"IOMSG must be\" }\n-   backspace(1,iomsg='sgk')     ! { dg-error \"IOMSG must be\" }\n-   backspace(1,iomsg=i)         ! { dg-error \"IOMSG must be\" }\n-   wait(1,     iomsg='sgk')     ! { dg-error \"IOMSG must be\" }\n-   wait(1,     iomsg=i)         ! { dg-error \"IOMSG must be\" }\n+   write(1, *, iomsg='sgk') x   ! { dg-error \"Non-variable expression\" }\n+   write(1, *, iomsg=i)     x   ! { dg-error \"must be of type CHARACTER\" }\n+   read(1,  *, iomsg='sgk') x   ! { dg-error \"Non-variable expression\" }\n+   read(1,  *, iomsg=i)     x   ! { dg-error \"must be of type CHARACTER\" }\n+   flush(1,    iomsg='sgk')     ! { dg-error \"Non-variable expression\" }\n+   flush(1,    iomsg=i)         ! { dg-error \"must be of type CHARACTER\" }\n+   rewind(1,   iomsg='sgk')     ! { dg-error \"Non-variable expression\" }\n+   rewind(1,   iomsg=i)         ! { dg-error \"must be of type CHARACTER\" }\n+   backspace(1,iomsg='sgk')     ! { dg-error \"Non-variable expression\" }\n+   backspace(1,iomsg=i)         ! { dg-error \"must be of type CHARACTER\" }\n+   wait(1,     iomsg='sgk')     ! { dg-error \"Non-variable expression\" }\n+   wait(1,     iomsg=i)         ! { dg-error \"must be of type CHARACTER\" }\n end subroutine foo\n \n subroutine bar"}, {"sha": "d845646cf793746c7a73c622abac9478b029e132", "filename": "gcc/testsuite/gfortran.dg/pr66725.f90", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66725.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66725.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66725.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -3,29 +3,29 @@\n !\n program foo\n \n-   open(unit=1,access = 999)        ! { dg-error \"ACCESS requires\" }\n-   open(unit=1,action = 999)        ! { dg-error \"ACTION requires\" }\n-   open(unit=1,asynchronous = 999)  ! { dg-error \"ASYNCHRONOUS requires\" }\n-   open(unit=1,blank = 999)         ! { dg-error \"BLANK requires\" }\n-   open(unit=1,decimal = 999)       ! { dg-error \"DECIMAL requires\" }\n-   open(unit=1,delim = 999)         ! { dg-error \"DELIM requires\" }\n-   open(unit=1,encoding = 999)      ! { dg-error \"ENCODING requires\" }\n-   open(unit=1,form = 999)          ! { dg-error \"FORM requires\" }\n-   open(unit=1,pad = 999)           ! { dg-error \"PAD requires\" }\n-   open(unit=1,position = 999)      ! { dg-error \"POSITION requires\" }\n-   open(unit=1,round = 999)         ! { dg-error \"ROUND requires\" }\n-   open(unit=1,sign = 999)          ! { dg-error \"SIGN requires\" }\n-   open(unit=1,status = 999)        ! { dg-error \"STATUS requires\" }\n+   open(unit=1,access = 999)        ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,action = 999)        ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,asynchronous = 999)  ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,blank = 999)         ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,decimal = 999)       ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,delim = 999)         ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,encoding = 999)      ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,form = 999)          ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,pad = 999)           ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,position = 999)      ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,round = 999)         ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,sign = 999)          ! { dg-error \"must be of type CHARACTER\" }\n+   open(unit=1,status = 999)        ! { dg-error \"must be of type CHARACTER\" }\n \n-   close(unit=1, status=999)        ! { dg-error \"STATUS requires\" }\n+   close(unit=1, status=999)        ! { dg-error \"must be of type CHARACTER\" }\n \n-   write (unit=1, asynchronous=257) ! { dg-error \"ASYNCHRONOUS requires\" }\n-   write (unit=1, delim=257)        ! { dg-error \"DELIM requires\" }\n-   write (unit=1, decimal=257)      ! { dg-error \"DECIMAL requires\" }\n-   write (unit=1, round=257)        ! { dg-error \"ROUND requires\" }\n-   write (unit=1, sign=257)         ! { dg-error \"SIGN requires\" }\n+   write (unit=1, asynchronous=257) ! { dg-error \"must be of type CHARACTER\" }\n+   write (unit=1, delim=257)        ! { dg-error \"must be of type CHARACTER\" }\n+   write (unit=1, decimal=257)      ! { dg-error \"must be of type CHARACTER\" }\n+   write (unit=1, round=257)        ! { dg-error \"must be of type CHARACTER\" }\n+   write (unit=1, sign=257)         ! { dg-error \"must be of type CHARACTER\" }\n \n-   write (unit=1, blank=257)        ! { dg-error \"BLANK requires\" }\n-   write (unit=1, pad=257)          ! { dg-error \"PAD requires\" }\n+   write (unit=1, blank=257)        ! { dg-error \"must be of type CHARACTER\" }\n+   write (unit=1, pad=257)          ! { dg-error \"must be of type CHARACTER\" }\n \n end program foo"}, {"sha": "419bad3715695ca1fee3dd358cf82251e93d3360", "filename": "gcc/testsuite/gfortran.dg/pr88205.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr88205.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr88205.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr88205.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -2,13 +2,13 @@\n ! PR fortran/88205\n subroutine s1\n    real, parameter :: status = 0\n-   open (newunit=n, status=status)        ! { dg-error \"STATUS requires\" }\n+   open (newunit=n, status=status)        ! { dg-error \"must be of type CHARACTER\" }\n end\n subroutine s2\n    complex, parameter :: status = 0\n-   open (newunit=n, status=status)        ! { dg-error \"STATUS requires\" }\n+   open (newunit=n, status=status)        ! { dg-error \"must be of type CHARACTER\" }\n end\n program p\n   logical, parameter :: status = .false.\n-  open (newunit=a, status=status)         ! { dg-error \"STATUS requires\" }\n+  open (newunit=a, status=status)         ! { dg-error \"must be of type CHARACTER\" }\n end"}, {"sha": "107baca2c31904857cb99f15ed860759482e1c6a", "filename": "gcc/testsuite/gfortran.dg/write_check4.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check4.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -11,7 +11,7 @@\n   no = \"no\"\n   open (unit=10, asynchronous = no)              ! Ok, it isn't a transfer stmt\n   write(*,*, asynchronous=\"Y\"//\"E\"//trim(\"S  \")) ! Ok, it is an init expr\n-  write(*,*, asynchronous=no)  ! { dg-error \"must be an initialization expression\" } \n+  write(*,*, asynchronous=no)  ! { dg-error \"does not reduce to a constant expression\" }\n   read (*,*, asynchronous=\"Y\"//\"e\"//trim(\"S  \"))\n-  read (*,*, asynchronous=no)  ! { dg-error \"must be an initialization expression\" }\n+  read (*,*, asynchronous=no)  ! { dg-error \"does not reduce to a constant expression\" }\n end"}, {"sha": "296c51a1962de2f4371cfc3d478e15c035a815d8", "filename": "gcc/testsuite/gfortran.dg/write_check5.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check5.f90?ref=44facdb79f2d96ea8f5f93cfd440b3d0351d9bdb", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+!\n+! The asynchronous specifier for a data transfer statement shall be\n+! an initialization expression\n+!\n+\n+module write_check5\n+contains\n+\n+function no()\n+  implicit none\n+  character(3) :: no\n+  no = \"yes\"\n+endfunction\n+\n+end module\n+\n+use write_check5\n+implicit none\n+\n+open (unit=10, asynchronous=no())              ! Ok, it isn't a transfer stmt\n+write(*,*, asynchronous=no())  ! { dg-error \"must be an intrinsic function\" }\n+read (*,*, asynchronous=no())  ! { dg-error \"must be an intrinsic function\" }\n+end"}]}