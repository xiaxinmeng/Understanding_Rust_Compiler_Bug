{"sha": "08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhiN2ZmMWUxZGRhMGJiMzU3NDFhZDgxNTZiZjMxYmE1MTUxZGRlYQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-04-28T04:44:09Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-04-28T04:44:09Z"}, "message": "always define HAVE_simple_return and HAVE_return\n\ngcc/ChangeLog:\n\n2015-04-27  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* bb-reorder.c (HAVE_return): Don't check if its undefined.\n\t* defaults.h (gen_simple_return): New function.\n\t(gen_simple_return): Likewise.\n\t(HAVE_return): Add default definition to false.\n\t(HAVE_simple_return): Likewise.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Remove checks if\n\tHAVE_return and HAVE_simple_return are defined.\n\t* function.c (gen_return_pattern): Likewise.\n\t(convert_jumps_to_returns): Likewise.\n\t(thread_prologue_and_epilogue_insns): Likewise.\n\t* reorg.c (find_end_label): Likewise.\n\t(dbr_schedule): Likewise.\n\t* shrink-wrap.c: Likewise.\n\t* shrink-wrap.h: Likewise.\n\nFrom-SVN: r222505", "tree": {"sha": "996ea71baffdec033124a780519ec47ed3bb21cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/996ea71baffdec033124a780519ec47ed3bb21cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/comments", "author": null, "committer": null, "parents": [{"sha": "a3699d669abd4543fdc3c4607e2d0550e67e52ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3699d669abd4543fdc3c4607e2d0550e67e52ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3699d669abd4543fdc3c4607e2d0550e67e52ba"}], "stats": {"total": 133, "additions": 58, "deletions": 75}, "files": [{"sha": "578b95ad10fce139e0839f1954f70477a759ea51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "patch": "@@ -1,3 +1,20 @@\n+2015-04-27  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* bb-reorder.c (HAVE_return): Don't check if its undefined.\n+\t* defaults.h (gen_simple_return): New function.\n+\t(gen_simple_return): Likewise.\n+\t(HAVE_return): Add default definition to false.\n+\t(HAVE_simple_return): Likewise.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Remove checks if\n+\tHAVE_return and HAVE_simple_return are defined.\n+\t* function.c (gen_return_pattern): Likewise.\n+\t(convert_jumps_to_returns): Likewise.\n+\t(thread_prologue_and_epilogue_insns): Likewise.\n+\t* reorg.c (find_end_label): Likewise.\n+\t(dbr_schedule): Likewise.\n+\t* shrink-wrap.c: Likewise.\n+\t* shrink-wrap.h: Likewise.\n+\n 2015-04-27  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* defaults.h (EPILOGUE_USES): Add default definition of false."}, {"sha": "c1347121f512c7b43b482b51fb9b338de1664770", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "patch": "@@ -142,15 +142,6 @@\n    the object file there will be an extra round.  */\n #define N_ROUNDS 5\n \n-/* Stubs in case we don't have a return insn.\n-   We have to check at run time too, not only compile time.  */\n-\n-#ifndef HAVE_return\n-#define HAVE_return 0\n-#define gen_return() NULL_RTX\n-#endif\n-\n-\n struct target_bb_reorder default_target_bb_reorder;\n #if SWITCHABLE_TARGET\n struct target_bb_reorder *this_target_bb_reorder = &default_target_bb_reorder;"}, {"sha": "702750252fad906ec23e07d978115543b2701ef5", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "patch": "@@ -1705,21 +1705,19 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n     {\n       if (jump_label == ret_rtx)\n \t{\n-#ifdef HAVE_return\n+\t  if (!HAVE_return)\n+\t    gcc_unreachable ();\n+\n \t  emit_jump_insn_after_setloc (gen_return (), BB_END (jump_block), loc);\n-#else\n-\t  gcc_unreachable ();\n-#endif\n \t}\n       else\n \t{\n \t  gcc_assert (jump_label == simple_return_rtx);\n-#ifdef HAVE_simple_return\n+\t  if (!HAVE_simple_return)\n+\t    gcc_unreachable ();\n+\n \t  emit_jump_insn_after_setloc (gen_simple_return (),\n \t\t\t\t       BB_END (jump_block), loc);\n-#else\n-\t  gcc_unreachable ();\n-#endif\n \t}\n       set_return_jump_label (BB_END (jump_block));\n     }"}, {"sha": "d3da328ee47ab5ac380d88327e6ccd62ed0acc3e", "filename": "gcc/defaults.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "patch": "@@ -1398,6 +1398,26 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_SUPPORTS_WIDE_INT 0\n #endif\n \n+#ifndef HAVE_simple_return\n+#define HAVE_simple_return 0\n+static inline rtx\n+gen_simple_return ()\n+{\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+#endif\n+\n+#ifndef HAVE_return\n+#define HAVE_return 0\n+static inline rtx\n+gen_return ()\n+{\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+#endif\n+\n #endif /* GCC_INSN_FLAGS_H  */\n \n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "561a1c5087fa4a27cd042d15775ac4242b76bfcc", "filename": "gcc/function.c", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "patch": "@@ -5649,7 +5649,6 @@ prologue_epilogue_contains (const_rtx insn)\n   return 0;\n }\n \n-#ifdef HAVE_return\n /* Insert use of return register before the end of BB.  */\n \n static void\n@@ -5674,12 +5673,10 @@ emit_use_return_register_into_block (basic_block bb)\n static rtx\n gen_return_pattern (bool simple_p)\n {\n-#ifdef HAVE_simple_return\n+  if (!HAVE_simple_return)\n+    gcc_assert (!simple_p);\n+\n   return simple_p ? gen_simple_return () : gen_return ();\n-#else\n-  gcc_assert (!simple_p);\n-  return gen_return ();\n-#endif\n }\n \n /* Insert an appropriate return pattern at the end of block BB.  This\n@@ -5697,7 +5694,6 @@ emit_return_into_block (bool simple_p, basic_block bb)\n   gcc_assert (ANY_RETURN_P (pat));\n   JUMP_LABEL (jump) = pat;\n }\n-#endif\n \n /* Set JUMP_LABEL for a return insn.  */\n \n@@ -5713,7 +5709,6 @@ set_return_jump_label (rtx returnjump)\n     JUMP_LABEL (returnjump) = ret_rtx;\n }\n \n-#if defined (HAVE_return) || defined (HAVE_simple_return)\n /* Return true if there are any active insns between HEAD and TAIL.  */\n bool\n active_insn_between (rtx_insn *head, rtx_insn *tail)\n@@ -5788,15 +5783,13 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \t    dest = ret_rtx;\n \t  if (!redirect_jump (jump, dest, 0))\n \t    {\n-#ifdef HAVE_simple_return\n-\t      if (simple_p)\n+\t      if (HAVE_simple_return && simple_p)\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Failed to redirect bb %d branch.\\n\", bb->index);\n \t\t  unconverted.safe_push (e);\n \t\t}\n-#endif\n \t      continue;\n \t    }\n \n@@ -5811,15 +5804,13 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \t}\n       else\n \t{\n-#ifdef HAVE_simple_return\n-\t  if (simple_p)\n+\t  if (HAVE_simple_return && simple_p)\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"Failed to redirect bb %d branch.\\n\", bb->index);\n \t      unconverted.safe_push (e);\n \t    }\n-#endif\n \t  continue;\n \t}\n \n@@ -5847,7 +5838,6 @@ emit_return_for_exit (edge exit_fallthru_edge, bool simple_p)\n   exit_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n   return last_bb;\n }\n-#endif\n \n \n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n@@ -5902,10 +5892,8 @@ void\n thread_prologue_and_epilogue_insns (void)\n {\n   bool inserted;\n-#ifdef HAVE_simple_return\n   vec<edge> unconverted_simple_returns = vNULL;\n   bitmap_head bb_flags;\n-#endif\n   rtx_insn *returnjump;\n   rtx_insn *epilogue_end ATTRIBUTE_UNUSED;\n   rtx_insn *prologue_seq ATTRIBUTE_UNUSED, *split_prologue_seq ATTRIBUTE_UNUSED;\n@@ -5976,15 +5964,13 @@ thread_prologue_and_epilogue_insns (void)\n     }\n #endif\n \n-#ifdef HAVE_simple_return\n   bitmap_initialize (&bb_flags, &bitmap_default_obstack);\n \n   /* Try to perform a kind of shrink-wrapping, making sure the\n      prologue/epilogue is emitted only around those parts of the\n      function that require it.  */\n \n   try_shrink_wrapping (&entry_edge, orig_entry_edge, &bb_flags, prologue_seq);\n-#endif\n \n   if (split_prologue_seq != NULL_RTX)\n     {\n@@ -6009,14 +5995,11 @@ thread_prologue_and_epilogue_insns (void)\n \n   exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \n-#ifdef HAVE_simple_return\n-  if (entry_edge != orig_entry_edge)\n+  if (HAVE_simple_return && entry_edge != orig_entry_edge)\n     exit_fallthru_edge\n \t= get_unconverted_simple_return (exit_fallthru_edge, bb_flags,\n \t\t\t\t\t &unconverted_simple_returns,\n \t\t\t\t\t &returnjump);\n-#endif\n-#ifdef HAVE_return\n   if (HAVE_return)\n     {\n       if (exit_fallthru_edge == NULL)\n@@ -6035,17 +6018,16 @@ thread_prologue_and_epilogue_insns (void)\n \t    {\n \t      last_bb = emit_return_for_exit (exit_fallthru_edge, false);\n \t      epilogue_end = returnjump = BB_END (last_bb);\n-#ifdef HAVE_simple_return\n+\n \t      /* Emitting the return may add a basic block.\n \t\t Fix bb_flags for the added block.  */\n-\t      if (last_bb != exit_fallthru_edge->src)\n+\t      if (HAVE_simple_return && last_bb != exit_fallthru_edge->src)\n \t\tbitmap_set_bit (&bb_flags, last_bb->index);\n-#endif\n+\n \t      goto epilogue_done;\n \t    }\n \t}\n     }\n-#endif\n \n   /* A small fib -- epilogue is not yet completed, but we wish to re-use\n      this marker for the splits of EH_RETURN patterns, and nothing else\n@@ -6157,10 +6139,9 @@ thread_prologue_and_epilogue_insns (void)\n \t}\n     }\n \n-#ifdef HAVE_simple_return\n-  convert_to_simple_return (entry_edge, orig_entry_edge, bb_flags, returnjump,\n-\t\t\t    unconverted_simple_returns);\n-#endif\n+  if (HAVE_simple_return)\n+    convert_to_simple_return (entry_edge, orig_entry_edge, bb_flags,\n+\t\t\t      returnjump, unconverted_simple_returns);\n \n #ifdef HAVE_sibcall_epilogue\n   /* Emit sibling epilogues before any sibling call sites.  */\n@@ -6174,11 +6155,8 @@ thread_prologue_and_epilogue_insns (void)\n \n       if (!CALL_P (insn)\n \t  || ! SIBLING_CALL_P (insn)\n-#ifdef HAVE_simple_return\n-\t  || (entry_edge != orig_entry_edge\n-\t      && !bitmap_bit_p (&bb_flags, bb->index))\n-#endif\n-\t  )\n+\t  || (HAVE_simple_return && (entry_edge != orig_entry_edge\n+\t\t\t\t     && !bitmap_bit_p (&bb_flags, bb->index))))\n \t{\n \t  ei_next (&ei);\n \t  continue;\n@@ -6225,9 +6203,7 @@ thread_prologue_and_epilogue_insns (void)\n     }\n #endif\n \n-#ifdef HAVE_simple_return\n   bitmap_clear (&bb_flags);\n-#endif\n \n   /* Threading the prologue and epilogue changes the artificial refs\n      in the entry and exit blocks.  */"}, {"sha": "a44d4a394b06fd0df1f1b02c08f4147bbd27c45c", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "patch": "@@ -485,11 +485,7 @@ find_end_label (rtx kind)\n       else\n \t{\n #ifdef HAVE_epilogue\n-\t  if (HAVE_epilogue\n-#ifdef HAVE_return\n-\t      && ! HAVE_return\n-#endif\n-\t      )\n+\t  if (HAVE_epilogue && ! HAVE_return)\n \t    /* The RETURN insn has its delay slot filled so we cannot\n \t       emit the label just before it.  Since we already have\n \t       an epilogue and cannot emit a new RETURN, we cannot\n@@ -500,7 +496,6 @@ find_end_label (rtx kind)\n \t  /* Otherwise, make a new label and emit a RETURN and BARRIER,\n \t     if needed.  */\n \t  emit_label (label);\n-#ifdef HAVE_return\n \t  if (HAVE_return)\n \t    {\n \t      /* The return we make may have delay slots too.  */\n@@ -511,7 +506,6 @@ find_end_label (rtx kind)\n \t      if (num_delay_slots (insn) > 0)\n \t\tobstack_ptr_grow (&unfilled_slots_obstack, insn);\n \t    }\n-#endif\n \t}\n       *plabel = label;\n     }\n@@ -3825,12 +3819,8 @@ dbr_schedule (rtx_insn *first)\n     delete_related_insns (function_simple_return_label);\n \n   need_return_insns = false;\n-#ifdef HAVE_return\n   need_return_insns |= HAVE_return && function_return_label != 0;\n-#endif\n-#ifdef HAVE_simple_return\n   need_return_insns |= HAVE_simple_return && function_simple_return_label != 0;\n-#endif\n   if (need_return_insns)\n     make_return_insns (first);\n "}, {"sha": "6c59da95133c66553d983a612251d75590f4eeb3", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "patch": "@@ -80,7 +80,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"regcprop.h\"\n #include \"rtl-iter.h\"\n \n-#ifdef HAVE_simple_return\n \n /* Return true if INSN requires the stack frame to be set up.\n    PROLOGUE_USED contains the hard registers used in the function\n@@ -1043,5 +1042,3 @@ convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n \t  }\n     }\n }\n-\n-#endif"}, {"sha": "8c9582d597b193527431c8583291d1fedb4aad4a", "filename": "gcc/shrink-wrap.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fshrink-wrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7ff1e1dda0bb35741ad8156bf31ba5151ddea/gcc%2Fshrink-wrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.h?ref=08b7ff1e1dda0bb35741ad8156bf31ba5151ddea", "patch": "@@ -23,9 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"vec.h\"\n #include \"machmode.h\"\n-\n-#ifdef HAVE_simple_return\n-\n #include \"function.h\"\n \n /* In shrink-wrap.c.  */\n@@ -43,9 +40,6 @@ extern void convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n \t\t\t\t      rtx_insn *returnjump,\n \t\t\t\t      vec<edge> unconverted_simple_returns);\n #define SHRINK_WRAPPING_ENABLED (flag_shrink_wrap && HAVE_simple_return)\n-#else\n-#define SHRINK_WRAPPING_ENABLED false\n-#endif\n \n #endif  /* GCC_SHRINK_WRAP_H  */\n "}]}