{"sha": "a39108dea1d091545982fefa88ce3be31b9eedf2", "node_id": "C_kwDOANBUbNoAKGEzOTEwOGRlYTFkMDkxNTQ1OTgyZmVmYTg4Y2UzYmUzMWI5ZWVkZjI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-08-05T10:09:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-05T10:09:20Z"}, "message": "Merge #1431\n\n1431: Incremental refactor for better coercion site support r=philberty a=philberty\n\nThis is the major refactor to get our coercion site code closer to Rustc.\r\nIt introduced several new pieces most notably a refactor to the autoderef\r\ncycle so this can be reused in method resolution and in coercion sites which\r\nallows us to handle deref coercions. It will eventually allow us to get rid\r\nof our bad implementation in rust-tyty-coercion.h which is just messy now.\r\n\r\nFixes #1198 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "a6eee23553f90586ccc439bc35c44f3ecb3ee8ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6eee23553f90586ccc439bc35c44f3ecb3ee8ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a39108dea1d091545982fefa88ce3be31b9eedf2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi7OxQCRBK7hj4Ov3rIwAAVOEIAG1hJCdf05GyILb5c8Flsyw4\n+7G5ke+VCJ2vqE43A+eiXoBt19XzGLyTtpIsKXMCAJWVIGMF0MA5r20bf+fUEK8V\n0uUpLgC/sDNDcUgZDrTDhVCByO1hV5gtQHuUwZGlWJrsAskgEDE0u3jaC9xjpHra\npXpcqXrz3xcVbPyoWqMvd7r31aUre6mpPT6kIs3/pp58OBSQ5oyeSK2mwOMq06ax\nI6dT5W//nHCzlJBG05b2UjzvxzrV9gaIfAHoWQbX5rZtdt75YQH34Y+DWCU6QUhw\n0shGSqVubhdMI8xqTrveiYtCHlNvr7kuQvXGHPOAe58J/aiZUz60YEReTKo5hiQ=\n=tjjK\n-----END PGP SIGNATURE-----\n", "payload": "tree a6eee23553f90586ccc439bc35c44f3ecb3ee8ac\nparent e77bc10ba13af4e193bbda5f43006d11d9bccb45\nparent 5d17a8b6b2c086d4df516de06ddacdf88728f6ba\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1659694160 +0000\ncommitter GitHub <noreply@github.com> 1659694160 +0000\n\nMerge #1431\n\n1431: Incremental refactor for better coercion site support r=philberty a=philberty\n\nThis is the major refactor to get our coercion site code closer to Rustc.\r\nIt introduced several new pieces most notably a refactor to the autoderef\r\ncycle so this can be reused in method resolution and in coercion sites which\r\nallows us to handle deref coercions. It will eventually allow us to get rid\r\nof our bad implementation in rust-tyty-coercion.h which is just messy now.\r\n\r\nFixes #1198 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39108dea1d091545982fefa88ce3be31b9eedf2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a39108dea1d091545982fefa88ce3be31b9eedf2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39108dea1d091545982fefa88ce3be31b9eedf2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e77bc10ba13af4e193bbda5f43006d11d9bccb45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e77bc10ba13af4e193bbda5f43006d11d9bccb45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e77bc10ba13af4e193bbda5f43006d11d9bccb45"}, {"sha": "5d17a8b6b2c086d4df516de06ddacdf88728f6ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d17a8b6b2c086d4df516de06ddacdf88728f6ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d17a8b6b2c086d4df516de06ddacdf88728f6ba"}], "stats": {"total": 1889, "additions": 1122, "deletions": 767}, "files": [{"sha": "886bafbe1e0d17033f00ff51e9f61a0a5cedb758", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -106,6 +106,7 @@ GRS_OBJS = \\\n     rust/rust-pub-restricted-visitor.o \\\n     rust/rust-privacy-reporter.o \\\n     rust/rust-tyty.o \\\n+    rust/rust-tyty-call.o \\\n     rust/rust-tyctx.o \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\\n@@ -117,6 +118,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-pattern.o \\\n     rust/rust-hir-type-check-expr.o \\\n     rust/rust-hir-dot-operator.o \\\n+    rust/rust-coercion.o \\\n     rust/rust-hir-type-check-base.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\"}, {"sha": "a640a48d7d85ca0aef43f99e9062066ff13e5260", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -411,16 +411,24 @@ HIRCompileBase::mark_addressable (tree exp, Location locus)\n }\n \n tree\n-HIRCompileBase::address_expression (tree expr, tree ptrtype, Location location)\n+HIRCompileBase::address_expression (tree expr, Location location)\n {\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n   if (!mark_addressable (expr, location))\n     return error_mark_node;\n \n-  return build_fold_addr_expr_with_type_loc (location.gcc_location (), expr,\n-\t\t\t\t\t     ptrtype);\n+  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n+}\n+\n+tree\n+HIRCompileBase::indirect_expression (tree expr, Location locus)\n+{\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n+  return build_fold_indirect_ref_loc (locus.gcc_location (), expr);\n }\n \n std::vector<Bvariable *>"}, {"sha": "5a0ac8fe7137947ac24f0c0dff5c5defd49684de", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -40,9 +40,12 @@ class HIRCompileBase\n protected:\n   Context *get_context () { return ctx; }\n \n-  tree coercion_site (tree rvalue, const TyTy::BaseType *actual,\n+  tree coercion_site (HirId id, tree rvalue, const TyTy::BaseType *actual,\n \t\t      const TyTy::BaseType *expected, Location lvalue_locus,\n \t\t      Location rvalue_locus);\n+  tree coercion_site1 (tree rvalue, const TyTy::BaseType *actual,\n+\t\t       const TyTy::BaseType *expected, Location lvalue_locus,\n+\t\t       Location rvalue_locus);\n \n   tree coerce_to_dyn_object (tree compiled_ref, const TyTy::BaseType *actual,\n \t\t\t     const TyTy::BaseType *expected,\n@@ -101,7 +104,9 @@ class HIRCompileBase\n \n   static void setup_abi_options (tree fndecl, ABI abi);\n \n-  static tree address_expression (tree expr, tree ptrtype, Location locus);\n+  static tree address_expression (tree expr, Location locus);\n+\n+  static tree indirect_expression (tree expr, Location locus);\n \n   static bool mark_addressable (tree, Location);\n "}, {"sha": "38d10d2d41c1c0619f3c32963e64a74abcd7a78d", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 26, "deletions": 77, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -134,8 +134,7 @@ CompileExpr::visit (HIR::BorrowExpr &expr)\n \t\t\t\t       &tyty))\n     return;\n \n-  tree ptrtype = TyTyResolveCompile::compile (ctx, tyty);\n-  translated = address_expression (main_expr, ptrtype, expr.get_locus ());\n+  translated = address_expression (main_expr, expr.get_locus ());\n }\n \n void\n@@ -175,10 +174,7 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n       return;\n     }\n \n-  bool known_valid = true;\n-  translated\n-    = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n-\t\t\t\t\t\tknown_valid, expr.get_locus ());\n+  translated = indirect_expression (main_expr, expr.get_locus ());\n }\n \n // Helper for sort_tuple_patterns.\n@@ -857,8 +853,9 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t  Location lvalue_locus\n \t    = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n \t  Location rvalue_locus = argument->get_locus ();\n-\t  rvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n-\t\t\t\t  rvalue_locus);\n+\t  rvalue\n+\t    = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t     actual, expected, lvalue_locus, rvalue_locus);\n \n \t  // add it to the list\n \t  arguments.push_back (rvalue);\n@@ -955,8 +952,8 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       Location lvalue_locus\n \t= ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n       Location rvalue_locus = argument->get_locus ();\n-      rvalue\n-\t= coercion_site (rvalue, actual, expected, lvalue_locus, rvalue_locus);\n+      rvalue = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t      actual, expected, lvalue_locus, rvalue_locus);\n \n       // add it to the list\n       args.push_back (rvalue);\n@@ -1039,9 +1036,11 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n     }\n \n   // lookup the autoderef mappings\n+  HirId autoderef_mappings_id\n+    = expr.get_receiver ()->get_mappings ().get_hirid ();\n   std::vector<Resolver::Adjustment> *adjustments = nullptr;\n-  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n-    expr.get_mappings ().get_hirid (), &adjustments);\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t\t\t     &adjustments);\n   rust_assert (ok);\n \n   // apply adjustments for the fn call\n@@ -1071,8 +1070,8 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       Location lvalue_locus\n \t= ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n       Location rvalue_locus = argument->get_locus ();\n-      rvalue\n-\t= coercion_site (rvalue, actual, expected, lvalue_locus, rvalue_locus);\n+      rvalue = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t      actual, expected, lvalue_locus, rvalue_locus);\n \n       // add it to the list\n       args.push_back (rvalue);\n@@ -1111,15 +1110,7 @@ CompileExpr::get_fn_addr_from_dyn (const TyTy::DynamicObjectType *dyn,\n   // get any indirection sorted out\n   if (receiver->get_kind () == TyTy::TypeKind::REF)\n     {\n-      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n-      auto indirect_ty = r->get_base ();\n-      tree indrect_compiled_tyty\n-\t= TyTyResolveCompile::compile (ctx, indirect_ty);\n-\n-      tree indirect\n-\t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n-\t\t\t\t\t\t    receiver_ref, true,\n-\t\t\t\t\t\t    expr_locus);\n+      tree indirect = indirect_expression (receiver_ref, expr_locus);\n       receiver_ref = indirect;\n     }\n \n@@ -1149,17 +1140,8 @@ CompileExpr::get_receiver_from_dyn (const TyTy::DynamicObjectType *dyn,\n {\n   // get any indirection sorted out\n   if (receiver->get_kind () == TyTy::TypeKind::REF)\n-\n     {\n-      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n-      auto indirect_ty = r->get_base ();\n-      tree indrect_compiled_tyty\n-\t= TyTyResolveCompile::compile (ctx, indirect_ty);\n-\n-      tree indirect\n-\t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n-\t\t\t\t\t\t    receiver_ref, true,\n-\t\t\t\t\t\t    expr_locus);\n+      tree indirect = indirect_expression (receiver_ref, expr_locus);\n       receiver_ref = indirect;\n     }\n \n@@ -1179,8 +1161,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n   tree fn = NULL_TREE;\n   if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n     {\n-      return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t\t expr_locus);\n+      return address_expression (fn, expr_locus);\n     }\n \n   // Now we can try and resolve the address since this might be a forward\n@@ -1307,7 +1288,7 @@ CompileExpr::resolve_operator_overload (\n   // lookup the autoderef mappings\n   std::vector<Resolver::Adjustment> *adjustments = nullptr;\n   ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n-    expr.get_mappings ().get_hirid (), &adjustments);\n+    expr.get_lvalue_mappings ().get_hirid (), &adjustments);\n   rust_assert (ok);\n \n   // apply adjustments for the fn call\n@@ -1440,8 +1421,7 @@ CompileExpr::compile_string_literal (const HIR::LiteralExpr &expr,\n \n   auto base = ctx->get_backend ()->string_constant_expression (\n     literal_value.as_string ());\n-  tree data = address_expression (base, build_pointer_type (TREE_TYPE (base)),\n-\t\t\t\t  expr.get_locus ());\n+  tree data = address_expression (base, expr.get_locus ());\n \n   TyTy::BaseType *usize = nullptr;\n   bool ok = ctx->get_tyctx ()->lookup_builtin (\"usize\", &usize);\n@@ -1487,8 +1467,7 @@ CompileExpr::compile_byte_string_literal (const HIR::LiteralExpr &expr,\n \t\t\t\t\t\t\t vals,\n \t\t\t\t\t\t\t expr.get_locus ());\n \n-  return address_expression (constructed, build_pointer_type (array_type),\n-\t\t\t     expr.get_locus ());\n+  return address_expression (constructed, expr.get_locus ());\n }\n \n tree\n@@ -1734,10 +1713,7 @@ HIRCompileBase::resolve_adjustements (\n \t  case Resolver::Adjustment::AdjustmentType::MUT_REF: {\n \t    if (!SLICE_TYPE_P (TREE_TYPE (e)))\n \t      {\n-\t\ttree ptrtype\n-\t\t  = TyTyResolveCompile::compile (ctx,\n-\t\t\t\t\t\t adjustment.get_expected ());\n-\t\te = address_expression (e, ptrtype, locus);\n+\t\te = address_expression (e, locus);\n \t      }\n \t  }\n \t  break;\n@@ -1785,10 +1761,7 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \t\t      != Resolver::Adjustment::AdjustmentType::ERROR;\n   if (needs_borrow)\n     {\n-      adjusted_argument\n-\t= address_expression (expression,\n-\t\t\t      build_reference_type (TREE_TYPE (expression)),\n-\t\t\t      locus);\n+      adjusted_argument = address_expression (expression, locus);\n     }\n \n   // make the call\n@@ -1800,12 +1773,7 @@ tree\n HIRCompileBase::resolve_indirection_adjustment (\n   Resolver::Adjustment &adjustment, tree expression, Location locus)\n {\n-  tree expected_type\n-    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\n-  return ctx->get_backend ()->indirect_expression (expected_type, expression,\n-\t\t\t\t\t\t   true, /* known_valid*/\n-\t\t\t\t\t\t   locus);\n+  return indirect_expression (expression, locus);\n }\n \n tree\n@@ -1824,9 +1792,7 @@ HIRCompileBase::resolve_unsized_adjustment (Resolver::Adjustment &adjustment,\n     = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \n   // make a constructor for this\n-  tree data\n-    = address_expression (expression,\n-\t\t\t  build_reference_type (TREE_TYPE (expression)), locus);\n+  tree data = address_expression (expression, locus);\n \n   // fetch the size from the domain\n   tree domain = TYPE_DOMAIN (expr_type);\n@@ -1919,8 +1885,7 @@ CompileExpr::visit (HIR::IdentifierExpr &expr)\n   else if (ctx->lookup_function_decl (ref, &fn))\n     {\n       TREE_USED (fn) = 1;\n-      translated = address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t\t       expr.get_locus ());\n+      translated = address_expression (fn, expr.get_locus ());\n     }\n   else if (ctx->lookup_var_decl (ref, &var))\n     {\n@@ -2091,20 +2056,10 @@ CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n \t  return;\n \t}\n \n-      // lookup the expected type for this expression\n-      TyTy::BaseType *tyty = nullptr;\n-      bool ok\n-\t= ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t  &tyty);\n-      rust_assert (ok);\n-      tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n-\n       // rust deref always returns a reference from this overload then we can\n       // actually do the indirection\n       translated\n-\t= ctx->get_backend ()->indirect_expression (expected_type,\n-\t\t\t\t\t\t    operator_overload_call,\n-\t\t\t\t\t\t    true, expr.get_locus ());\n+\t= indirect_expression (operator_overload_call, expr.get_locus ());\n       return;\n     }\n \n@@ -2118,14 +2073,8 @@ CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n   // do we need to add an indirect reference\n   if (array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n     {\n-      TyTy::ReferenceType *r\n-\t= static_cast<TyTy::ReferenceType *> (array_expr_ty);\n-      TyTy::BaseType *tuple_type = r->get_base ();\n-      tree array_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n-\n       array_reference\n-\t= ctx->get_backend ()->indirect_expression (array_tyty, array_reference,\n-\t\t\t\t\t\t    true, expr.get_locus ());\n+\t= indirect_expression (array_reference, expr.get_locus ());\n     }\n \n   translated"}, {"sha": "9b8976de18a4d45310e10d301624ac412ebd8500", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -53,14 +53,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n     // do we need to add an indirect reference\n     if (tuple_expr_ty->get_kind () == TyTy::TypeKind::REF)\n       {\n-\tTyTy::ReferenceType *r\n-\t  = static_cast<TyTy::ReferenceType *> (tuple_expr_ty);\n-\tTyTy::BaseType *tuple_type = r->get_base ();\n-\ttree tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n-\n-\ttree indirect\n-\t  = ctx->get_backend ()->indirect_expression (tuple_tyty, receiver_ref,\n-\t\t\t\t\t\t      true, expr.get_locus ());\n+\ttree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n \treceiver_ref = indirect;\n       }\n \n@@ -184,9 +177,9 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n       expr.get_rhs ()->get_mappings ().get_hirid (), &actual);\n     rust_assert (ok);\n \n-    rvalue\n-      = coercion_site (rvalue, actual, expected, expr.get_lhs ()->get_locus (),\n-\t\t       expr.get_rhs ()->get_locus ());\n+    rvalue = coercion_site (expr.get_mappings ().get_hirid (), rvalue, actual,\n+\t\t\t    expected, expr.get_lhs ()->get_locus (),\n+\t\t\t    expr.get_rhs ()->get_locus ());\n \n     tree assignment\n       = ctx->get_backend ()->assignment_statement (lvalue, rvalue,\n@@ -442,8 +435,9 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \n \tif (ok)\n \t  {\n-\t    rvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n-\t\t\t\t    rvalue_locus);\n+\t    rvalue\n+\t      = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t       actual, expected, lvalue_locus, rvalue_locus);\n \t  }\n \n \t// add it to the list\n@@ -476,7 +470,8 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \t    // compile/torture/struct_base_init_1.rs\n \t    if (ok)\n \t      {\n-\t\trvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n+\t\trvalue = coercion_site (argument->get_mappings ().get_hirid (),\n+\t\t\t\t\trvalue, actual, expected, lvalue_locus,\n \t\t\t\t\trvalue_locus);\n \t      }\n \n@@ -552,10 +547,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \t\t\t\t\t &field_index);\n \trust_assert (ok);\n \n-\ttree adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n-\ttree indirect\n-\t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n-\t\t\t\t\t\t      true, expr.get_locus ());\n+\ttree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n \treceiver_ref = indirect;\n       }\n "}, {"sha": "45a507e03be654e848b3b5639d86b99aa6613982", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -110,10 +110,7 @@ class CompileExternItem : public HIRCompileBase,\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n-\treference\n-\t  = address_expression (lookup, build_pointer_type (TREE_TYPE (lookup)),\n-\t\t\t\tref_locus);\n-\n+\treference = address_expression (lookup, ref_locus);\n \treturn;\n       }\n \n@@ -155,9 +152,7 @@ class CompileExternItem : public HIRCompileBase,\n \n     ctx->insert_function_decl (fntype, fndecl);\n \n-    reference\n-      = address_expression (fndecl, build_pointer_type (TREE_TYPE (fndecl)),\n-\t\t\t    ref_locus);\n+    reference = address_expression (fndecl, ref_locus);\n   }\n \n private:"}, {"sha": "d0f70a702282dbf03cec1ba312166e5e1521a5d5", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -67,10 +67,8 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n \t    {\n \t      ctx->insert_function_decl (fntype, lookup);\n \t    }\n-\t  reference\n-\t    = address_expression (lookup,\n-\t\t\t\t  build_pointer_type (TREE_TYPE (lookup)),\n-\t\t\t\t  ref_locus);\n+\n+\t  reference = address_expression (lookup, ref_locus);\n \t  return;\n \t}\n     }\n@@ -96,9 +94,7 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n \t\t\tfunc.get_outer_attrs (), func.get_locus (),\n \t\t\tfunc.get_block_expr ().get (), canonical_path, fntype,\n \t\t\tfunction.has_return_type ());\n-  reference\n-    = address_expression (fndecl, build_pointer_type (TREE_TYPE (fndecl)),\n-\t\t\t  ref_locus);\n+  reference = address_expression (fndecl, ref_locus);\n }\n \n } // namespace Compile"}, {"sha": "ceba51c2d27f5bd3a57b3a7acd9b1621cae88354", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -144,10 +144,7 @@ CompileItem::visit (HIR::Function &function)\n \t      ctx->insert_function_decl (fntype, lookup);\n \t    }\n \n-\t  reference\n-\t    = address_expression (lookup,\n-\t\t\t\t  build_pointer_type (TREE_TYPE (lookup)),\n-\t\t\t\t  ref_locus);\n+\t  reference = address_expression (lookup, ref_locus);\n \t  return;\n \t}\n     }\n@@ -171,9 +168,7 @@ CompileItem::visit (HIR::Function &function)\n \t\t\tfunction.get_outer_attrs (), function.get_locus (),\n \t\t\tfunction.get_definition ().get (), canonical_path,\n \t\t\tfntype, function.has_function_return_type ());\n-  reference\n-    = address_expression (fndecl, build_pointer_type (TREE_TYPE (fndecl)),\n-\t\t\t  ref_locus);\n+  reference = address_expression (fndecl, ref_locus);\n }\n \n void"}, {"sha": "8c1b7ef1f2b8d118c5aac49d74e26126698d2d73", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -129,16 +129,14 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n \t  TREE_USED (fn) = 1;\n-\t  return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t\t     expr_locus);\n+\t  return address_expression (fn, expr_locus);\n \t}\n       else if (fntype->get_abi () == ABI::INTRINSIC)\n \t{\n \t  Intrinsics compile (ctx);\n \t  fn = compile.compile (fntype);\n \t  TREE_USED (fn) = 1;\n-\t  return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t\t     expr_locus);\n+\t  return address_expression (fn, expr_locus);\n \t}\n     }\n "}, {"sha": "9bb4b7b07d2b16417e4ca6bf19db984491816c0c", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -87,7 +87,8 @@ class CompileStmt : public HIRCompileBase, public HIR::HIRStmtVisitor\n     Location lvalue_locus = stmt.get_pattern ()->get_locus ();\n     Location rvalue_locus = stmt.get_init_expr ()->get_locus ();\n     TyTy::BaseType *expected = ty;\n-    init = coercion_site (init, actual, expected, lvalue_locus, rvalue_locus);\n+    init = coercion_site (stmt.get_mappings ().get_hirid (), init, actual,\n+\t\t\t  expected, lvalue_locus, rvalue_locus);\n \n     auto fnctx = ctx->peek_fn ();\n     if (ty->is_unit ())"}, {"sha": "8a614f200a65118312dea6a20428c1ccb9daf134", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -198,9 +198,25 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n // Shared methods in compilation\n \n tree\n-HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n+HIRCompileBase::coercion_site (HirId id, tree rvalue,\n+\t\t\t       const TyTy::BaseType *rval,\n \t\t\t       const TyTy::BaseType *lval,\n \t\t\t       Location lvalue_locus, Location rvalue_locus)\n+{\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_autoderef_mappings (id, &adjustments);\n+  if (ok)\n+    {\n+      rvalue = resolve_adjustements (*adjustments, rvalue, rvalue_locus);\n+    }\n+\n+  return coercion_site1 (rvalue, rval, lval, lvalue_locus, rvalue_locus);\n+}\n+\n+tree\n+HIRCompileBase::coercion_site1 (tree rvalue, const TyTy::BaseType *rval,\n+\t\t\t\tconst TyTy::BaseType *lval,\n+\t\t\t\tLocation lvalue_locus, Location rvalue_locus)\n {\n   if (rvalue == error_mark_node)\n     return error_mark_node;\n@@ -225,20 +241,14 @@ HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n       const TyTy::ReferenceType *act\n \t= static_cast<const TyTy::ReferenceType *> (actual);\n \n-      tree expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n-      tree deref_rvalue\n-\t= ctx->get_backend ()->indirect_expression (expected_type, rvalue,\n-\t\t\t\t\t\t    false /*known_valid*/,\n-\t\t\t\t\t\t    rvalue_locus);\n+      tree deref_rvalue = indirect_expression (rvalue, rvalue_locus);\n       tree coerced\n-\t= coercion_site (deref_rvalue, act->get_base (), exp->get_base (),\n-\t\t\t lvalue_locus, rvalue_locus);\n+\t= coercion_site1 (deref_rvalue, act->get_base (), exp->get_base (),\n+\t\t\t  lvalue_locus, rvalue_locus);\n       if (exp->is_dyn_object () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n \treturn coerced;\n \n-      return address_expression (coerced,\n-\t\t\t\t build_reference_type (TREE_TYPE (coerced)),\n-\t\t\t\t rvalue_locus);\n+      return address_expression (coerced, rvalue_locus);\n     }\n   else if (expected->get_kind () == TyTy::TypeKind::POINTER)\n     {\n@@ -258,37 +268,31 @@ HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n \t= static_cast<const TyTy::ReferenceType *> (expected);\n \n       TyTy::BaseType *actual_base = nullptr;\n-      tree expected_type = error_mark_node;\n       if (actual->get_kind () == TyTy::TypeKind::REF)\n \t{\n \t  const TyTy::ReferenceType *act\n \t    = static_cast<const TyTy::ReferenceType *> (actual);\n \n \t  actual_base = act->get_base ();\n-\t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n \t}\n       else if (actual->get_kind () == TyTy::TypeKind::POINTER)\n \t{\n \t  const TyTy::PointerType *act\n \t    = static_cast<const TyTy::PointerType *> (actual);\n \n \t  actual_base = act->get_base ();\n-\t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n \t}\n       rust_assert (actual_base != nullptr);\n \n-      tree deref_rvalue\n-\t= ctx->get_backend ()->indirect_expression (expected_type, rvalue,\n-\t\t\t\t\t\t    false /*known_valid*/,\n-\t\t\t\t\t\t    rvalue_locus);\n-      tree coerced = coercion_site (deref_rvalue, actual_base, exp->get_base (),\n-\t\t\t\t    lvalue_locus, rvalue_locus);\n+      tree deref_rvalue = indirect_expression (rvalue, rvalue_locus);\n+      tree coerced\n+\t= coercion_site1 (deref_rvalue, actual_base, exp->get_base (),\n+\t\t\t  lvalue_locus, rvalue_locus);\n+\n       if (exp->is_dyn_object () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n \treturn coerced;\n \n-      return address_expression (coerced,\n-\t\t\t\t build_pointer_type (TREE_TYPE (coerced)),\n-\t\t\t\t rvalue_locus);\n+      return address_expression (coerced, rvalue_locus);\n     }\n   else if (expected->get_kind () == TyTy::TypeKind::ARRAY)\n     {\n@@ -350,10 +354,7 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n \n   tree address_of_compiled_ref = null_pointer_node;\n   if (!actual->is_unit ())\n-    address_of_compiled_ref\n-      = address_expression (compiled_ref,\n-\t\t\t    build_pointer_type (TREE_TYPE (compiled_ref)),\n-\t\t\t    locus);\n+    address_of_compiled_ref = address_expression (compiled_ref, locus);\n \n   std::vector<tree> vtable_ctor_elems;\n   std::vector<unsigned long> vtable_ctor_idx;"}, {"sha": "7cb86a69b2c3f88a9a3cb835fdce9b2329cbbb43", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -4120,31 +4120,47 @@ class OperatorExprMeta\n {\n public:\n   OperatorExprMeta (HIR::CompoundAssignmentExpr &expr)\n-    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+    : node_mappings (expr.get_mappings ()),\n+      lvalue_mappings (expr.get_expr ()->get_mappings ()),\n+      locus (expr.get_locus ())\n   {}\n \n   OperatorExprMeta (HIR::ArithmeticOrLogicalExpr &expr)\n-    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+    : node_mappings (expr.get_mappings ()),\n+      lvalue_mappings (expr.get_expr ()->get_mappings ()),\n+      locus (expr.get_locus ())\n   {}\n \n   OperatorExprMeta (HIR::NegationExpr &expr)\n-    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+    : node_mappings (expr.get_mappings ()),\n+      lvalue_mappings (expr.get_expr ()->get_mappings ()),\n+      locus (expr.get_locus ())\n   {}\n \n   OperatorExprMeta (HIR::DereferenceExpr &expr)\n-    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+    : node_mappings (expr.get_mappings ()),\n+      lvalue_mappings (expr.get_expr ()->get_mappings ()),\n+      locus (expr.get_locus ())\n   {}\n \n   OperatorExprMeta (HIR::ArrayIndexExpr &expr)\n-    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+    : node_mappings (expr.get_mappings ()),\n+      lvalue_mappings (expr.get_array_expr ()->get_mappings ()),\n+      locus (expr.get_locus ())\n   {}\n \n   const Analysis::NodeMapping &get_mappings () const { return node_mappings; }\n \n+  const Analysis::NodeMapping &get_lvalue_mappings () const\n+  {\n+    return lvalue_mappings;\n+  }\n+\n   Location get_locus () const { return locus; }\n \n private:\n   const Analysis::NodeMapping node_mappings;\n+  const Analysis::NodeMapping lvalue_mappings;\n   Location locus;\n };\n "}, {"sha": "f7c0b0833708cf9b9f6e2cb27cb4f8aba9072f63", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -178,14 +178,6 @@ class Backend\n   // Create a reference to a variable.\n   virtual tree var_expression (Bvariable *var, Location) = 0;\n \n-  // Create an expression that indirects through the pointer expression EXPR\n-  // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n-  // is known to point to a valid memory location.  BTYPE is the expected type\n-  // of the indirected EXPR.\n-  virtual tree indirect_expression (tree btype, tree expr, bool known_valid,\n-\t\t\t\t    Location)\n-    = 0;\n-\n   // Return an expression for the multi-precision integer VAL in BTYPE.\n   virtual tree integer_constant_expression (tree btype, mpz_t val) = 0;\n "}, {"sha": "27196e88593f281b984e4964b17c28f2490cb15b", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -201,8 +201,6 @@ class Gcc_backend : public Backend\n \n   tree var_expression (Bvariable *var, Location);\n \n-  tree indirect_expression (tree, tree expr, bool known_valid, Location);\n-\n   tree integer_constant_expression (tree type, mpz_t val);\n \n   tree float_constant_expression (tree type, mpfr_t val);\n@@ -1053,28 +1051,6 @@ Gcc_backend::var_expression (Bvariable *var, Location location)\n   return var->get_tree (location);\n }\n \n-// An expression that indirectly references an expression.\n-\n-tree\n-Gcc_backend::indirect_expression (tree type_tree, tree expr_tree,\n-\t\t\t\t  bool known_valid, Location location)\n-{\n-  if (expr_tree == error_mark_node || type_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  // If the type of EXPR is a recursive pointer type, then we\n-  // need to insert a cast before indirecting.\n-  tree target_type_tree = TREE_TYPE (TREE_TYPE (expr_tree));\n-  if (VOID_TYPE_P (target_type_tree))\n-    expr_tree = fold_convert_loc (location.gcc_location (),\n-\t\t\t\t  build_pointer_type (type_tree), expr_tree);\n-\n-  tree ret = build_fold_indirect_ref_loc (location.gcc_location (), expr_tree);\n-  if (known_valid)\n-    TREE_THIS_NOTRAP (ret) = 1;\n-  return ret;\n-}\n-\n // Return a typed value as a constant integer.\n \n tree"}, {"sha": "0025e7ef80dde72e6b5d25d657a5b5f611ed1a49", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -268,5 +268,129 @@ resolve_operator_overload_fn (\n   return true;\n }\n \n+AutoderefCycle::AutoderefCycle (bool autoderef_flag)\n+  : autoderef_flag (autoderef_flag)\n+{}\n+\n+AutoderefCycle::~AutoderefCycle () {}\n+\n+void\n+AutoderefCycle::try_hook (const TyTy::BaseType &)\n+{}\n+\n+bool\n+AutoderefCycle::cycle (const TyTy::BaseType *receiver)\n+{\n+  const TyTy::BaseType *r = receiver;\n+  while (true)\n+    {\n+      if (try_autoderefed (r))\n+\treturn true;\n+\n+      // 4. deref to to 1, if cannot deref then quit\n+      if (autoderef_flag)\n+\treturn false;\n+\n+      // try unsize\n+      Adjustment unsize = Adjuster::try_unsize_type (r);\n+      if (!unsize.is_error ())\n+\t{\n+\t  adjustments.push_back (unsize);\n+\t  auto unsize_r = unsize.get_expected ();\n+\n+\t  if (try_autoderefed (unsize_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      Adjustment deref\n+\t= Adjuster::try_deref_type (r, Analysis::RustLangItem::ItemType::DEREF);\n+      if (!deref.is_error ())\n+\t{\n+\t  auto deref_r = deref.get_expected ();\n+\t  adjustments.push_back (deref);\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      Adjustment deref_mut = Adjuster::try_deref_type (\n+\tr, Analysis::RustLangItem::ItemType::DEREF_MUT);\n+      if (!deref_mut.is_error ())\n+\t{\n+\t  auto deref_r = deref_mut.get_expected ();\n+\t  adjustments.push_back (deref_mut);\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      if (!deref_mut.is_error ())\n+\t{\n+\t  auto deref_r = deref_mut.get_expected ();\n+\t  adjustments.push_back (deref_mut);\n+\t  Adjustment raw_deref = Adjuster::try_raw_deref_type (deref_r);\n+\t  adjustments.push_back (raw_deref);\n+\t  deref_r = raw_deref.get_expected ();\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      if (!deref.is_error ())\n+\t{\n+\t  r = deref.get_expected ();\n+\t  adjustments.push_back (deref);\n+\t}\n+      Adjustment raw_deref = Adjuster::try_raw_deref_type (r);\n+      if (raw_deref.is_error ())\n+\treturn false;\n+\n+      r = raw_deref.get_expected ();\n+      adjustments.push_back (raw_deref);\n+    }\n+  return false;\n+}\n+\n+bool\n+AutoderefCycle::try_autoderefed (const TyTy::BaseType *r)\n+{\n+  try_hook (*r);\n+\n+  // 1. try raw\n+  if (select (*r))\n+    return true;\n+\n+  // 2. try ref\n+  TyTy::ReferenceType *r1\n+    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t       Mutability::Imm);\n+  adjustments.push_back (Adjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n+  if (select (*r1))\n+    return true;\n+\n+  adjustments.pop_back ();\n+\n+  // 3. try mut ref\n+  TyTy::ReferenceType *r2\n+    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t       Mutability::Mut);\n+  adjustments.push_back (Adjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n+  if (select (*r2))\n+    return true;\n+\n+  adjustments.pop_back ();\n+\n+  return false;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "220b6f450919e78827843d541fcb5e792a9d573b", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -144,6 +144,27 @@ class Adjuster\n   const TyTy::BaseType *base;\n };\n \n+class AutoderefCycle\n+{\n+protected:\n+  AutoderefCycle (bool autoderef_flag);\n+\n+  virtual ~AutoderefCycle ();\n+\n+  virtual bool select (const TyTy::BaseType &autoderefed) = 0;\n+\n+  // optional: this is a chance to hook in to grab predicate items on the raw\n+  // type\n+  virtual void try_hook (const TyTy::BaseType &);\n+\n+  virtual bool cycle (const TyTy::BaseType *receiver);\n+\n+  bool try_autoderefed (const TyTy::BaseType *r);\n+\n+  bool autoderef_flag;\n+  std::vector<Adjustment> adjustments;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "e6e82c3f73456ed921a87f66a7b941ad9c50fa0f", "filename": "gcc/rust/typecheck/rust-coercion.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -0,0 +1,92 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-coercion.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+AutoderefTypeCoercion::CoercionResult\n+AutoderefTypeCoercion::Coerce (const TyTy::BaseType *receiver,\n+\t\t\t       const TyTy::BaseType *expected, Location locus)\n+{\n+  AutoderefTypeCoercion resolver (expected, locus);\n+  bool ok = resolver.cycle (receiver);\n+  return ok ? resolver.try_result : CoercionResult::get_error ();\n+}\n+\n+AutoderefTypeCoercion::AutoderefTypeCoercion (const TyTy::BaseType *expected,\n+\t\t\t\t\t      Location locus)\n+  : AutoderefCycle (false), mappings (Analysis::Mappings::get ()),\n+    context (TypeCheckContext::get ()), expected (expected), locus (locus),\n+    try_result (CoercionResult::get_error ())\n+{}\n+\n+bool\n+AutoderefTypeCoercion::cycle (const TyTy::BaseType *receiver)\n+{\n+  // FIXME this is not finished and might be super simplified\n+  // see:\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/coercion.rs\n+\n+  if (receiver->get_kind () == TyTy::TypeKind::REF\n+      && expected->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      // if we expect to get a mutable pointer we can't get that from an\n+      // immutable one so we have to be careful\n+\n+      const auto &receiver_ref\n+\t= static_cast<const TyTy::ReferenceType &> (*receiver);\n+      const auto &expected_ref\n+\t= static_cast<const TyTy::ReferenceType &> (*expected);\n+\n+      // we can allow for mutability changes here by casting down from\n+      // mutability eg:  mut vs const, we cant take a mutable reference from a\n+      // const eg:  const vs mut we can take a const reference from a mutable\n+      // one\n+\n+      bool mutability_ok\n+\t= !expected_ref.is_mutable ()\n+\t  || (expected_ref.is_mutable () == receiver_ref.is_mutable ());\n+      if (!mutability_ok)\n+\t{\n+\t  RichLocation r (locus);\n+\t  r.add_range (mappings->lookup_location (receiver_ref.get_ref ()));\n+\t  r.add_range (mappings->lookup_location (expected_ref.get_ref ()));\n+\t  rust_error_at (r, \"mismatched mutability\");\n+\n+\t  return false;\n+\t}\n+    }\n+\n+  return AutoderefCycle::cycle (receiver);\n+}\n+\n+bool\n+AutoderefTypeCoercion::select (const TyTy::BaseType &autoderefed)\n+{\n+  if (autoderefed.can_eq (expected, false))\n+    {\n+      try_result = CoercionResult{adjustments, autoderefed.clone ()};\n+      return true;\n+    }\n+  return false;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "c3d5d028e64ebecb8e95ad731992bf19c1299f66", "filename": "gcc/rust/typecheck/rust-coercion.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COERCION\n+#define RUST_COERCION\n+\n+#include \"rust-autoderef.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class AutoderefTypeCoercion : protected AutoderefCycle\n+{\n+public:\n+  struct CoercionResult\n+  {\n+    std::vector<Adjustment> adjustments;\n+    TyTy::BaseType *tyty;\n+\n+    bool is_error ()\n+    {\n+      return tyty == nullptr || tyty->get_kind () == TyTy::TypeKind::ERROR;\n+    }\n+\n+    static CoercionResult get_error () { return CoercionResult{{}, nullptr}; }\n+  };\n+\n+  static CoercionResult Coerce (const TyTy::BaseType *receiver,\n+\t\t\t\tconst TyTy::BaseType *expected, Location locus);\n+\n+protected:\n+  AutoderefTypeCoercion (const TyTy::BaseType *expected, Location locus);\n+\n+  bool cycle (const TyTy::BaseType *receiver) override;\n+\n+  bool select (const TyTy::BaseType &autoderefed) override;\n+\n+private:\n+  // context info\n+  Analysis::Mappings *mappings;\n+  TypeCheckContext *context;\n+\n+  // search\n+  const TyTy::BaseType *expected;\n+  Location locus;\n+\n+  // mutable fields\n+  CoercionResult try_result;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_COERCION"}, {"sha": "d45f09034781f3b7c18696f0c621b1a059e4c1a7", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "modified", "additions": 32, "deletions": 145, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -23,151 +23,32 @@\n namespace Rust {\n namespace Resolver {\n \n+MethodResolver::MethodResolver (bool autoderef_flag,\n+\t\t\t\tconst HIR::PathIdentSegment &segment_name)\n+  : AutoderefCycle (autoderef_flag), mappings (Analysis::Mappings::get ()),\n+    context (TypeCheckContext::get ()), segment_name (segment_name),\n+    try_result (MethodCandidate::get_error ())\n+{}\n+\n MethodCandidate\n MethodResolver::Probe (const TyTy::BaseType *receiver,\n \t\t       const HIR::PathIdentSegment &segment_name,\n \t\t       bool autoderef_flag)\n {\n-  const TyTy::BaseType *r = receiver;\n-  std::vector<Adjustment> adjustments;\n-  while (true)\n-    {\n-      auto res = Try (r, segment_name, adjustments);\n-      if (!res.is_error ())\n-\treturn res;\n-\n-      // 4. deref to to 1, if cannot deref then quit\n-      if (autoderef_flag)\n-\treturn MethodCandidate::get_error ();\n-\n-      // try unsize\n-      Adjustment unsize = Adjuster::try_unsize_type (r);\n-      if (!unsize.is_error ())\n-\t{\n-\t  adjustments.push_back (unsize);\n-\t  auto unsize_r = unsize.get_expected ();\n-\t  auto res = Try (unsize_r, segment_name, adjustments);\n-\t  if (!res.is_error ())\n-\t    {\n-\t      return res;\n-\t    }\n-\n-\t  adjustments.pop_back ();\n-\t}\n-\n-      Adjustment deref\n-\t= Adjuster::try_deref_type (r, Analysis::RustLangItem::ItemType::DEREF);\n-      if (!deref.is_error ())\n-\t{\n-\t  auto deref_r = deref.get_expected ();\n-\t  adjustments.push_back (deref);\n-\t  auto res = Try (deref_r, segment_name, adjustments);\n-\t  if (!res.is_error ())\n-\t    {\n-\t      return res;\n-\t    }\n-\n-\t  adjustments.pop_back ();\n-\t}\n-\n-      Adjustment deref_mut = Adjuster::try_deref_type (\n-\tr, Analysis::RustLangItem::ItemType::DEREF_MUT);\n-      if (!deref_mut.is_error ())\n-\t{\n-\t  auto deref_r = deref_mut.get_expected ();\n-\t  adjustments.push_back (deref_mut);\n-\t  auto res = Try (deref_r, segment_name, adjustments);\n-\t  if (!res.is_error ())\n-\t    {\n-\t      return res;\n-\t    }\n-\n-\t  adjustments.pop_back ();\n-\t}\n-\n-      if (!deref_mut.is_error ())\n-\t{\n-\t  auto deref_r = deref_mut.get_expected ();\n-\t  adjustments.push_back (deref_mut);\n-\t  Adjustment raw_deref = Adjuster::try_raw_deref_type (deref_r);\n-\t  adjustments.push_back (raw_deref);\n-\t  deref_r = raw_deref.get_expected ();\n-\n-\t  auto res = Try (deref_r, segment_name, adjustments);\n-\t  if (!res.is_error ())\n-\t    {\n-\t      return res;\n-\t    }\n-\n-\t  adjustments.pop_back ();\n-\t  adjustments.pop_back ();\n-\t}\n-\n-      if (!deref.is_error ())\n-\t{\n-\t  r = deref.get_expected ();\n-\t  adjustments.push_back (deref);\n-\t}\n-      Adjustment raw_deref = Adjuster::try_raw_deref_type (r);\n-      if (raw_deref.is_error ())\n-\treturn MethodCandidate::get_error ();\n-\n-      r = raw_deref.get_expected ();\n-      adjustments.push_back (raw_deref);\n-    }\n-  return MethodCandidate::get_error ();\n+  MethodResolver resolver (autoderef_flag, segment_name);\n+  bool ok = resolver.cycle (receiver);\n+  return ok ? resolver.try_result : MethodCandidate::get_error ();\n }\n \n-MethodCandidate\n-MethodResolver::Try (const TyTy::BaseType *r,\n-\t\t     const HIR::PathIdentSegment &segment_name,\n-\t\t     std::vector<Adjustment> &adjustments)\n+void\n+MethodResolver::try_hook (const TyTy::BaseType &r)\n {\n-  PathProbeCandidate c = PathProbeCandidate::get_error ();\n-  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds\n-    = r->get_specified_bounds ();\n-  const std::vector<MethodResolver::predicate_candidate> predicate_items\n-    = get_predicate_items (segment_name, *r, specified_bounds);\n-\n-  // 1. try raw\n-  MethodResolver raw (*r, segment_name, predicate_items);\n-  c = raw.select ();\n-  if (!c.is_error ())\n-    {\n-      return MethodCandidate{c, adjustments};\n-    }\n-\n-  // 2. try ref\n-  TyTy::ReferenceType *r1\n-    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n-\t\t\t       Mutability::Imm);\n-  MethodResolver imm_ref (*r1, segment_name, predicate_items);\n-  c = imm_ref.select ();\n-  if (!c.is_error ())\n-    {\n-      adjustments.push_back (\n-\tAdjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n-      return MethodCandidate{c, adjustments};\n-    }\n-\n-  // 3. try mut ref\n-  TyTy::ReferenceType *r2\n-    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n-\t\t\t       Mutability::Mut);\n-  MethodResolver mut_ref (*r2, segment_name, predicate_items);\n-  c = mut_ref.select ();\n-  if (!c.is_error ())\n-    {\n-      adjustments.push_back (\n-\tAdjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n-      return MethodCandidate{c, adjustments};\n-    }\n-\n-  return MethodCandidate::get_error ();\n+  const auto &specified_bounds = r.get_specified_bounds ();\n+  predicate_items = get_predicate_items (segment_name, r, specified_bounds);\n }\n \n-PathProbeCandidate\n-MethodResolver::select ()\n+bool\n+MethodResolver::select (const TyTy::BaseType &receiver)\n {\n   struct impl_item_candidate\n   {\n@@ -300,9 +181,11 @@ MethodResolver::select ()\n \t{\n \t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n \t\t\t\t\t\t  impl_item.impl_block};\n-\t  return PathProbeCandidate (\n-\t    PathProbeCandidate::CandidateType::IMPL_FUNC, fn,\n-\t    impl_item.item->get_locus (), c);\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n+\t\t\t\tfn, impl_item.item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n \t}\n     }\n \n@@ -317,9 +200,11 @@ MethodResolver::select ()\n \t  PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n \t\t\t\t\t\t   trait_item.item_ref,\n \t\t\t\t\t\t   nullptr};\n-\t  return PathProbeCandidate (\n-\t    PathProbeCandidate::CandidateType::TRAIT_FUNC, fn,\n-\t    trait_item.item->get_locus (), c);\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n+\t\t\t\tfn, trait_item.item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n \t}\n     }\n \n@@ -338,13 +223,15 @@ MethodResolver::select ()\n \n \t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n \t\t\t\t\t\t   nullptr};\n-\t  return PathProbeCandidate (\n-\t    PathProbeCandidate::CandidateType::TRAIT_FUNC, fn->clone (),\n-\t    trait_item->get_locus (), c);\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n+\t\t\t\tfn->clone (), trait_item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n \t}\n     }\n \n-  return PathProbeCandidate::get_error ();\n+  return false;\n }\n \n std::vector<MethodResolver::predicate_candidate>"}, {"sha": "750601a2d9e6a583786eabfc75b6e7581a3efa36", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -37,43 +37,42 @@ struct MethodCandidate\n   bool is_error () const { return candidate.is_error (); }\n };\n \n-class MethodResolver : public TypeCheckBase\n+class MethodResolver : protected AutoderefCycle\n {\n-protected:\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  static MethodCandidate Probe (const TyTy::BaseType *receiver,\n-\t\t\t\tconst HIR::PathIdentSegment &segment_name,\n-\t\t\t\tbool autoderef_flag = false);\n-\n-protected:\n   struct predicate_candidate\n   {\n     TyTy::TypeBoundPredicateItem lookup;\n     TyTy::FnType *fntype;\n   };\n \n-  static MethodCandidate Try (const TyTy::BaseType *r,\n-\t\t\t      const HIR::PathIdentSegment &segment_name,\n-\t\t\t      std::vector<Adjustment> &adjustments);\n+  static MethodCandidate Probe (const TyTy::BaseType *receiver,\n+\t\t\t\tconst HIR::PathIdentSegment &segment_name,\n+\t\t\t\tbool autoderef_flag = false);\n \n   static std::vector<predicate_candidate> get_predicate_items (\n     const HIR::PathIdentSegment &segment_name, const TyTy::BaseType &receiver,\n     const std::vector<TyTy::TypeBoundPredicate> &specified_bounds);\n \n-  PathProbeCandidate select ();\n+protected:\n+  MethodResolver (bool autoderef_flag,\n+\t\t  const HIR::PathIdentSegment &segment_name);\n \n-  MethodResolver (\n-    const TyTy::BaseType &receiver, const HIR::PathIdentSegment &segment_name,\n-    const std::vector<MethodResolver::predicate_candidate> &predicate_items)\n-    : receiver (receiver), segment_name (segment_name),\n-      predicate_items (predicate_items)\n-  {}\n+  void try_hook (const TyTy::BaseType &r) override;\n \n-  const TyTy::BaseType &receiver;\n+  bool select (const TyTy::BaseType &receiver) override;\n+\n+private:\n+  // context info\n+  Analysis::Mappings *mappings;\n+  TypeCheckContext *context;\n+\n+  // search\n   const HIR::PathIdentSegment &segment_name;\n-  const std::vector<MethodResolver::predicate_candidate> &predicate_items;\n+  std::vector<MethodResolver::predicate_candidate> predicate_items;\n+\n+  // mutable fields\n+  MethodCandidate try_result;\n };\n \n } // namespace Resolver"}, {"sha": "c50199847b7e8dccfcb1f9711ad08fd295069fc3", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-hir-type-check-base.h\"\n+#include \"rust-coercion.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -327,5 +328,26 @@ TypeCheckBase::parse_repr_options (const AST::AttrVec &attrs, Location locus)\n   return repr;\n }\n \n+TyTy::BaseType *\n+TypeCheckBase::coercion_site (HirId id, TyTy::BaseType *expected,\n+\t\t\t      TyTy::BaseType *expr, Location locus)\n+{\n+  auto context = TypeCheckContext::get ();\n+  if (expected->get_kind () == TyTy::TypeKind::ERROR\n+      || expr->get_kind () == TyTy::TypeKind::ERROR)\n+    return expr;\n+\n+  // can we autoderef it?\n+  auto result = AutoderefTypeCoercion::Coerce (expr, expected, locus);\n+  if (!result.is_error ())\n+    {\n+      // save any adjustments\n+      context->insert_autoderef_mappings (id, std::move (result.adjustments));\n+      return expected->coerce (result.tyty);\n+    }\n+\n+  return expected->coerce (expr);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "4078697c927872ac4b7a6e6b772d568d5b40948a", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -39,6 +39,9 @@ class TypeCheckBase : public HIR::HIRFullVisitorBase\n \n   virtual ~TypeCheckBase () {}\n \n+  static TyTy::BaseType *coercion_site (HirId id, TyTy::BaseType *lhs,\n+\t\t\t\t\tTyTy::BaseType *rhs, Location locus);\n+\n protected:\n   TypeCheckBase ()\n     : mappings (Analysis::Mappings::get ()), resolver (Resolver::get ()),"}, {"sha": "9c31284060e6063be93ca19008a8e90f63faab00", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 156, "deletions": 1, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -295,6 +295,161 @@ TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n   infered = array_type->get_element_type ()->clone ();\n }\n \n+void\n+TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n+{\n+  auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n+  if (receiver_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_receiver ()->get_locus (),\n+\t\t     \"failed to resolve receiver in MethodCallExpr\");\n+      return;\n+    }\n+\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n+\n+  auto candidate\n+    = MethodResolver::Probe (receiver_tyty,\n+\t\t\t     expr.get_method_name ().get_segment ());\n+  if (candidate.is_error ())\n+    {\n+      rust_error_at (\n+\texpr.get_method_name ().get_locus (),\n+\t\"failed to resolve method for %<%s%>\",\n+\texpr.get_method_name ().get_segment ().as_string ().c_str ());\n+      return;\n+    }\n+\n+  // Get the adjusted self\n+  Adjuster adj (receiver_tyty);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // store the adjustments for code-generation to know what to do which must be\n+  // stored onto the receiver to so as we don't trigger duplicate deref mappings\n+  // ICE when an argument is a method call\n+  HirId autoderef_mappings_id\n+    = expr.get_receiver ()->get_mappings ().get_hirid ();\n+  context->insert_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t      std::move (candidate.adjustments));\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      RichLocation r (expr.get_method_name ().get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated impl item is not a method\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  if (!fn->is_method ())\n+    {\n+      RichLocation r (expr.get_method_name ().get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated function is not a method\");\n+      return;\n+    }\n+\n+  auto root = receiver_tyty->get_root ();\n+  if (root->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+      if (adt->has_substitutions () && fn->needs_substitution ())\n+\t{\n+\t  // consider the case where we have:\n+\t  //\n+\t  // struct Foo<X,Y>(X,Y);\n+\t  //\n+\t  // impl<T> Foo<T, i32> {\n+\t  //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t  // }\n+\t  //\n+\t  // In this case we end up with an fn type of:\n+\t  //\n+\t  // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t  //\n+\t  // This means the instance or self we are calling this method for\n+\t  // will be substituted such that we can get the inherited type\n+\t  // arguments but then need to use the turbo fish if available or\n+\t  // infer the remaining arguments. Luckily rust does not allow for\n+\t  // default types GenericParams on impl blocks since these must\n+\t  // always be at the end of the list\n+\n+\t  auto s = fn->get_self_type ()->get_root ();\n+\t  rust_assert (s->can_eq (adt, false));\n+\t  rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t  const TyTy::ADTType *self_adt\n+\t    = static_cast<const TyTy::ADTType *> (s);\n+\n+\t  // we need to grab the Self substitutions as the inherit type\n+\t  // parameters for this\n+\t  if (self_adt->needs_substitution ())\n+\t    {\n+\t      rust_assert (adt->was_substituted ());\n+\n+\t      TyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (adt);\n+\n+\t      TyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t= self_adt->solve_mappings_from_receiver_for_self (\n+\t\t  used_args_in_prev_segment);\n+\n+\t      // there may or may not be inherited type arguments\n+\t      if (!inherit_type_args.is_error ())\n+\t\t{\n+\t\t  // need to apply the inherited type arguments to the\n+\t\t  // function\n+\t\t  lookup = fn->handle_substitions (inherit_type_args);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // apply any remaining generic arguments\n+  if (expr.get_method_name ().has_generic_args ())\n+    {\n+      HIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+      lookup\n+\t= SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n+\t\t\t\t&args);\n+      if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+  else if (lookup->needs_generic_substitutions ())\n+    {\n+      lookup = SubstMapper::InferSubst (lookup,\n+\t\t\t\t\texpr.get_method_name ().get_locus ());\n+    }\n+\n+  TyTy::BaseType *function_ret_tyty\n+    = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self, context);\n+  if (function_ret_tyty == nullptr\n+      || function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup type to MethodCallExpr\");\n+      return;\n+    }\n+\n+  // store the expected fntype\n+  context->insert_type (expr.get_method_name ().get_mappings (), lookup);\n+\n+  // set up the resolved name on the path\n+  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t  resolved_node_id);\n+\n+  // return the result of the function back\n+  infered = function_ret_tyty;\n+}\n+\n bool\n TypeCheckExpr::resolve_operator_overload (\n   Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,\n@@ -365,7 +520,7 @@ TypeCheckExpr::resolve_operator_overload (\n     }\n \n   // store the adjustments for code-generation to know what to do\n-  context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+  context->insert_autoderef_mappings (expr.get_lvalue_mappings ().get_hirid (),\n \t\t\t\t      std::move (candidate.adjustments));\n \n   // now its just like a method-call-expr"}, {"sha": "de542ca70e886c76de709b771e04a12210ec1dae", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 3, "deletions": 152, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -220,157 +220,7 @@ class TypeCheckExpr : public TypeCheckBase\n       = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n   }\n \n-  void visit (HIR::MethodCallExpr &expr) override\n-  {\n-    auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n-    if (receiver_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (expr.get_receiver ()->get_locus (),\n-\t\t       \"failed to resolve receiver in MethodCallExpr\");\n-\treturn;\n-      }\n-\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n-\n-    auto candidate\n-      = MethodResolver::Probe (receiver_tyty,\n-\t\t\t       expr.get_method_name ().get_segment ());\n-    if (candidate.is_error ())\n-      {\n-\trust_error_at (\n-\t  expr.get_method_name ().get_locus (),\n-\t  \"failed to resolve method for %<%s%>\",\n-\t  expr.get_method_name ().get_segment ().as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // Get the adjusted self\n-    Adjuster adj (receiver_tyty);\n-    TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n-\n-    // store the adjustments for code-generation to know what to do\n-    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\tstd::move (candidate.adjustments));\n-\n-    PathProbeCandidate &resolved_candidate = candidate.candidate;\n-    TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n-    NodeId resolved_node_id\n-      = resolved_candidate.is_impl_candidate ()\n-\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n-\t      .get_nodeid ()\n-\t  : resolved_candidate.item.trait.item_ref->get_mappings ()\n-\t      .get_nodeid ();\n-\n-    if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_candidate.locus);\n-\trust_error_at (r, \"associated impl item is not a method\");\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *lookup = lookup_tyty;\n-    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-    if (!fn->is_method ())\n-      {\n-\tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_candidate.locus);\n-\trust_error_at (r, \"associated function is not a method\");\n-\treturn;\n-      }\n-\n-    auto root = receiver_tyty->get_root ();\n-    if (root->get_kind () == TyTy::TypeKind::ADT)\n-      {\n-\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n-\tif (adt->has_substitutions () && fn->needs_substitution ())\n-\t  {\n-\t    // consider the case where we have:\n-\t    //\n-\t    // struct Foo<X,Y>(X,Y);\n-\t    //\n-\t    // impl<T> Foo<T, i32> {\n-\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n-\t    // }\n-\t    //\n-\t    // In this case we end up with an fn type of:\n-\t    //\n-\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n-\t    //\n-\t    // This means the instance or self we are calling this method for\n-\t    // will be substituted such that we can get the inherited type\n-\t    // arguments but then need to use the turbo fish if available or\n-\t    // infer the remaining arguments. Luckily rust does not allow for\n-\t    // default types GenericParams on impl blocks since these must\n-\t    // always be at the end of the list\n-\n-\t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false));\n-\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n-\t    const TyTy::ADTType *self_adt\n-\t      = static_cast<const TyTy::ADTType *> (s);\n-\n-\t    // we need to grab the Self substitutions as the inherit type\n-\t    // parameters for this\n-\t    if (self_adt->needs_substitution ())\n-\t      {\n-\t\trust_assert (adt->was_substituted ());\n-\n-\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n-\t\t  = GetUsedSubstArgs::From (adt);\n-\n-\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n-\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n-\t\t    used_args_in_prev_segment);\n-\n-\t\t// there may or may not be inherited type arguments\n-\t\tif (!inherit_type_args.is_error ())\n-\t\t  {\n-\t\t    // need to apply the inherited type arguments to the\n-\t\t    // function\n-\t\t    lookup = fn->handle_substitions (inherit_type_args);\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n-    // apply any remaining generic arguments\n-    if (expr.get_method_name ().has_generic_args ())\n-      {\n-\tHIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-\tlookup\n-\t  = SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n-\t\t\t\t  &args);\n-\tif (lookup->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n-    else if (lookup->needs_generic_substitutions ())\n-      {\n-\tlookup = SubstMapper::InferSubst (lookup,\n-\t\t\t\t\t  expr.get_method_name ().get_locus ());\n-      }\n-\n-    TyTy::BaseType *function_ret_tyty\n-      = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self,\n-\t\t\t\t\t   context);\n-    if (function_ret_tyty == nullptr\n-\t|| function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to lookup type to MethodCallExpr\");\n-\treturn;\n-      }\n-\n-    // store the expected fntype\n-    context->insert_type (expr.get_method_name ().get_mappings (), lookup);\n-\n-    // set up the resolved name on the path\n-    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t    resolved_node_id);\n-\n-    // return the result of the function back\n-    infered = function_ret_tyty;\n-  }\n+  void visit (HIR::MethodCallExpr &expr) override;\n \n   void visit (HIR::AssignmentExpr &expr) override\n   {\n@@ -380,7 +230,8 @@ class TypeCheckExpr : public TypeCheckBase\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n-    lhs->coerce (rhs);\n+    coercion_site (expr.get_mappings ().get_hirid (), lhs, rhs,\n+\t\t   expr.get_locus ());\n   }\n \n   void visit (HIR::CompoundAssignmentExpr &expr) override"}, {"sha": "f8bf6e083dd45071e8f0a56be8ff5c5877612316", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -99,7 +99,8 @@ class TypeCheckStmt : public TypeCheckBase\n     if (specified_ty != nullptr && init_expr_ty != nullptr)\n       {\n \t// FIXME use this result and look at the regressions\n-\tspecified_ty->coerce (init_expr_ty);\n+\tcoercion_site (stmt.get_mappings ().get_hirid (), specified_ty,\n+\t\t       init_expr_ty, stmt.get_locus ());\n \tcontext->insert_type (stmt_pattern.get_pattern_mappings (),\n \t\t\t      specified_ty);\n       }"}, {"sha": "5b522772a3e119fe22b48515ec8f4e5e23ec97b6", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct.cc", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -42,8 +42,8 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n     {\n       TyTy::BaseType *base_resolved\n \t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n-      struct_def\n-\t= (TyTy::ADTType *) struct_path_resolved->coerce (base_resolved);\n+      struct_def = static_cast<TyTy::ADTType *> (\n+\tstruct_path_resolved->coerce (base_resolved));\n       if (struct_def == nullptr)\n \t{\n \t  rust_fatal_error (struct_expr.struct_base->base_struct->get_locus (),\n@@ -221,7 +221,9 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n     }\n \n   TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value ());\n-  resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n+  resolved_field_value_expr\n+    = coercion_site (field.get_mappings ().get_hirid (),\n+\t\t     field_type->get_field_type (), value, field.get_locus ());\n   if (resolved_field_value_expr != nullptr)\n     {\n       fields_assigned.insert (field.field_name);\n@@ -250,7 +252,9 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n     }\n \n   TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value ());\n-  resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n+  resolved_field_value_expr\n+    = coercion_site (field.get_mappings ().get_hirid (),\n+\t\t     field_type->get_field_type (), value, field.get_locus ());\n   if (resolved_field_value_expr != nullptr)\n     {\n       fields_assigned.insert (field_name);\n@@ -284,7 +288,9 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n \t\t\t    field.get_locus ());\n   TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr);\n \n-  resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n+  resolved_field_value_expr\n+    = coercion_site (field.get_mappings ().get_hirid (),\n+\t\t     field_type->get_field_type (), value, field.get_locus ());\n   if (resolved_field_value_expr != nullptr)\n \n     {"}, {"sha": "b810bd88512008101e5f53d414adf43c6c3cb43f", "filename": "gcc/rust/typecheck/rust-tyty-call.cc", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -0,0 +1,269 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tyty-call.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+void\n+TypeCheckCallExpr::visit (ADTType &type)\n+{\n+  rust_assert (!variant.is_error ());\n+  if (variant.get_variant_type () != TyTy::VariantDef::VariantType::TUPLE)\n+    {\n+      rust_error_at (\n+\tcall.get_locus (),\n+\t\"expected function, tuple struct or tuple variant, found struct %<%s%>\",\n+\ttype.get_name ().c_str ());\n+      return;\n+    }\n+\n+  if (call.num_params () != variant.num_fields ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) variant.num_fields ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      StructFieldType *field = variant.get_field_at_index (i);\n+      BaseType *field_tyty = field->get_field_type ();\n+\n+      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (arg->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"failed to resolve argument type\");\n+\t  return;\n+\t}\n+\n+      auto res = Resolver::TypeCheckBase::coercion_site (\n+\targument->get_mappings ().get_hirid (), field_tyty, arg,\n+\targument->get_locus ());\n+      if (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  return;\n+\t}\n+\n+      delete res;\n+      i++;\n+    }\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.clone ();\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnType &type)\n+{\n+  type.monomorphize ();\n+  if (call.num_params () != type.num_params ())\n+    {\n+      if (type.is_varadic ())\n+\t{\n+\t  if (call.num_params () < type.num_params ())\n+\t    {\n+\t      rust_error_at (call.get_locus (),\n+\t\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t\t     (unsigned long) call.num_params (),\n+\t\t\t     (unsigned long) type.num_params ());\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rust_error_at (call.get_locus (),\n+\t\t\t \"unexpected number of arguments %lu expected %lu\",\n+\t\t\t (unsigned long) call.num_params (),\n+\t\t\t (unsigned long) type.num_params ());\n+\t  return;\n+\t}\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      // it might be a varadic function\n+      if (i < type.num_params ())\n+\t{\n+\t  auto fnparam = type.param_at (i);\n+\t  auto resolved_argument_type = Resolver::TypeCheckBase::coercion_site (\n+\t    argument->get_mappings ().get_hirid (), fnparam.second,\n+\t    argument_expr_tyty, argument->get_locus ());\n+\t  if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t    {\n+\t      rust_error_at (argument->get_locus (),\n+\t\t\t     \"Type Resolution failure on parameter\");\n+\t      return;\n+\t    }\n+\t}\n+\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n+\n+      i++;\n+    }\n+\n+  if (i < call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  type.monomorphize ();\n+  resolved = type.get_return_type ()->clone ();\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnPtr &type)\n+{\n+  if (call.num_params () != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      auto resolved_argument_type = Resolver::TypeCheckBase::coercion_site (\n+\targument->get_mappings ().get_hirid (), fnparam, argument_expr_tyty,\n+\targument->get_locus ());\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n+\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n+\n+      i++;\n+    }\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.get_return_type ()->monomorphized_clone ();\n+}\n+\n+// method call checker\n+\n+void\n+TypeCheckMethodCallExpr::visit (FnType &type)\n+{\n+  type.get_self_type ()->unify (adjusted_self);\n+\n+  // +1 for the receiver self\n+  size_t num_args_to_call = call.num_params () + 1;\n+  if (num_args_to_call != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 1;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      auto resolved_argument_type = Resolver::TypeCheckBase::coercion_site (\n+\targument->get_mappings ().get_hirid (), fnparam.second,\n+\targument_expr_tyty, argument->get_locus ());\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n+\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n+\n+      i++;\n+    }\n+\n+  if (i != num_args_to_call)\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  type.monomorphize ();\n+\n+  resolved = type.get_return_type ()->monomorphized_clone ();\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "07d1dea7464ff1081a31420d12ab6826daad36b3", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 100, "deletions": 6, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -36,12 +36,7 @@ class BaseCmp : public TyConstVisitor\n     if (other->get_kind () == TypeKind::PARAM)\n       {\n \tconst ParamType *p = static_cast<const ParamType *> (other);\n-\tif (p->can_resolve ())\n-\t  {\n-\t    const BaseType *resolved = p->resolve ();\n-\t    resolved->accept_vis (*this);\n-\t    return ok;\n-\t  }\n+\tother = p->resolve ();\n       }\n     if (other->get_kind () == TypeKind::PLACEHOLDER)\n       {\n@@ -861,6 +856,17 @@ class ClosureCmp : public BaseCmp\n     : BaseCmp (base, emit_errors), base (base)\n   {}\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ClosureType *base;\n@@ -889,6 +895,17 @@ class ArrayCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ArrayType *base;\n@@ -917,6 +934,17 @@ class SliceCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const SliceType *base;\n@@ -1074,6 +1102,17 @@ class ADTCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ADTType *base;\n@@ -1111,6 +1150,17 @@ class TupleCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const TupleType *base;\n@@ -1209,6 +1259,17 @@ class ReferenceCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ReferenceType *base;\n@@ -1246,6 +1307,17 @@ class PointerCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const PointerType *base;\n@@ -1344,6 +1416,17 @@ class StrCmp : public BaseCmp\n \n   void visit (const StrType &type) override { ok = true; }\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const StrType *base;\n@@ -1360,6 +1443,17 @@ class NeverCmp : public BaseCmp\n \n   void visit (const NeverType &type) override { ok = true; }\n \n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const NeverType *base;"}, {"sha": "daedfc3012c9842aae2b71e425bf1ecadf1cf140", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 0, "deletions": 238, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -3205,243 +3205,5 @@ DynamicObjectType::get_object_items () const\n   return items;\n }\n \n-// rust-tyty-call.h\n-\n-void\n-TypeCheckCallExpr::visit (ADTType &type)\n-{\n-  rust_assert (!variant.is_error ());\n-  if (variant.get_variant_type () != TyTy::VariantDef::VariantType::TUPLE)\n-    {\n-      rust_error_at (\n-\tcall.get_locus (),\n-\t\"expected function, tuple struct or tuple variant, found struct %<%s%>\",\n-\ttype.get_name ().c_str ());\n-      return;\n-    }\n-\n-  if (call.num_params () != variant.num_fields ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) call.num_params (),\n-\t\t     (unsigned long) variant.num_fields ());\n-      return;\n-    }\n-\n-  size_t i = 0;\n-  for (auto &argument : call.get_arguments ())\n-    {\n-      StructFieldType *field = variant.get_field_at_index (i);\n-      BaseType *field_tyty = field->get_field_type ();\n-\n-      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (arg->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"failed to resolve argument type\");\n-\t  return;\n-\t}\n-\n-      auto res = field_tyty->coerce (arg);\n-      if (res->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  return;\n-\t}\n-\n-      delete res;\n-      i++;\n-    }\n-\n-  if (i != call.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n-    }\n-\n-  resolved = type.clone ();\n-}\n-\n-void\n-TypeCheckCallExpr::visit (FnType &type)\n-{\n-  type.monomorphize ();\n-  if (call.num_params () != type.num_params ())\n-    {\n-      if (type.is_varadic ())\n-\t{\n-\t  if (call.num_params () < type.num_params ())\n-\t    {\n-\t      rust_error_at (call.get_locus (),\n-\t\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t\t     (unsigned long) call.num_params (),\n-\t\t\t     (unsigned long) type.num_params ());\n-\t      return;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  rust_error_at (call.get_locus (),\n-\t\t\t \"unexpected number of arguments %lu expected %lu\",\n-\t\t\t (unsigned long) call.num_params (),\n-\t\t\t (unsigned long) type.num_params ());\n-\t  return;\n-\t}\n-    }\n-\n-  size_t i = 0;\n-  for (auto &argument : call.get_arguments ())\n-    {\n-      auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (\n-\t    argument->get_locus (),\n-\t    \"failed to resolve type for argument expr in CallExpr\");\n-\t  return;\n-\t}\n-\n-      // it might be a varadic function\n-      if (i < type.num_params ())\n-\t{\n-\t  auto fnparam = type.param_at (i);\n-\t  auto resolved_argument_type\n-\t    = fnparam.second->coerce (argument_expr_tyty);\n-\t  if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n-\t    {\n-\t      rust_error_at (argument->get_locus (),\n-\t\t\t     \"Type Resolution failure on parameter\");\n-\t      return;\n-\t    }\n-\t}\n-\n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n-      i++;\n-    }\n-\n-  if (i < call.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n-    }\n-\n-  type.monomorphize ();\n-  resolved = type.get_return_type ()->clone ();\n-}\n-\n-void\n-TypeCheckCallExpr::visit (FnPtr &type)\n-{\n-  if (call.num_params () != type.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) call.num_params (),\n-\t\t     (unsigned long) type.num_params ());\n-      return;\n-    }\n-\n-  size_t i = 0;\n-  for (auto &argument : call.get_arguments ())\n-    {\n-      auto fnparam = type.param_at (i);\n-      auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (\n-\t    argument->get_locus (),\n-\t    \"failed to resolve type for argument expr in CallExpr\");\n-\t  return;\n-\t}\n-\n-      auto resolved_argument_type = fnparam->coerce (argument_expr_tyty);\n-      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"Type Resolution failure on parameter\");\n-\t  return;\n-\t}\n-\n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n-      i++;\n-    }\n-\n-  if (i != call.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n-    }\n-\n-  resolved = type.get_return_type ()->monomorphized_clone ();\n-}\n-\n-// method call checker\n-\n-void\n-TypeCheckMethodCallExpr::visit (FnType &type)\n-{\n-  type.get_self_type ()->unify (adjusted_self);\n-\n-  // +1 for the receiver self\n-  size_t num_args_to_call = call.num_params () + 1;\n-  if (num_args_to_call != type.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) call.num_params (),\n-\t\t     (unsigned long) type.num_params ());\n-      return;\n-    }\n-\n-  size_t i = 1;\n-  for (auto &argument : call.get_arguments ())\n-    {\n-      auto fnparam = type.param_at (i);\n-      auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (\n-\t    argument->get_locus (),\n-\t    \"failed to resolve type for argument expr in CallExpr\");\n-\t  return;\n-\t}\n-\n-      auto resolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n-      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"Type Resolution failure on parameter\");\n-\t  return;\n-\t}\n-\n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n-      i++;\n-    }\n-\n-  if (i != num_args_to_call)\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n-    }\n-\n-  type.monomorphize ();\n-\n-  resolved = type.get_return_type ()->monomorphized_clone ();\n-}\n-\n } // namespace TyTy\n } // namespace Rust"}, {"sha": "8af13586a373ac9a6d7ef3df5e24850385dd2a65", "filename": "gcc/testsuite/rust/compile/generics4.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics4.rs?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -3,10 +3,9 @@ struct GenericStruct<T>(T, usize);\n fn main() {\n     let a2;\n     a2 = GenericStruct::<i8, i32>(1, 456); // { dg-error \"generic item takes at most 1 type arguments but 2 were supplied\" }\n-    // { dg-error {failed to type resolve expression} \"\" { target *-*-* } .-1 }\n-    // { dg-error {Failed to resolve expression of function call} \"\" { target *-*-* } .-2 }\n-    // { duplicate _dg-error {failed to type resolve expression} \"\" { target *-*-* } .-3 }\n-    // { dg-error {expected \\[T\\?\\] got \\[<tyty::error>\\]} \"\" { target *-*-* } .-4 }\n+                                           // { dg-error {failed to type resolve expression} \"\" { target *-*-* } .-1 }\n+                                           // { dg-error {Failed to resolve expression of function call} \"\" { target *-*-* } .-2 }\n+                                           // { duplicate _dg-error {failed to type resolve expression} \"\" { target *-*-* } .-3 }\n \n     let b2: i32 = a2.0;\n     // { dg-error {Expected Tuple or ADT got: T\\?} \"\" { target *-*-* } .-1 }"}, {"sha": "ff791533754b3a216da6fcda85b397795dc57610", "filename": "gcc/testsuite/rust/compile/reference1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fcompile%2Freference1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fcompile%2Freference1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Freference1.rs?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let a = &123;\n     let b: &mut i32 = a;\n-    // { dg-error \"expected .&mut i32. got .& i32.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"mismatched mutability\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"expected .&mut i32. got .& i32.\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "77410e932daa8bb577f2d7c3e28c2fb4b0dcafac", "filename": "gcc/testsuite/rust/compile/shadow1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fshadow1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fshadow1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fshadow1.rs?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -3,6 +3,5 @@ fn main() {\n     let mut x;\n     x = true;\n     x = x + 2; // { dg-error \"cannot apply this operator to types bool and <integer>\"  }\n-    // { dg-error {failed to type resolve expression} \"\" { target *-*-* } .-1 }\n-    // { dg-error {expected \\[bool\\] got \\[<tyty::error>\\]} \"\" { target *-*-* } .-2 }\n+               // { dg-error {failed to type resolve expression} \"\" { target *-*-* } .-1 }\n }"}, {"sha": "ad85ed97ecbc85fa805e7068e24c7d86e13fa3f5", "filename": "gcc/testsuite/rust/compile/type-bindings1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftype-bindings1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftype-bindings1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftype-bindings1.rs?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -7,5 +7,4 @@ fn main() {\n     // { dg-error {failed to type resolve expression} \"\" { target *-*-* } .-2 }\n     // { dg-error {Failed to resolve expression of function call} \"\" { target *-*-* } .-3 }\n     // { duplicate _dg-error {failed to type resolve expression} \"\" { target *-*-* } .-4 }\n-    // { dg-error {expected \\[T\\?\\] got \\[<tyty::error>\\]} \"\" { target *-*-* } .-5 }\n }"}, {"sha": "fce44ad19940958c931c05e273c307bd6a255c81", "filename": "gcc/testsuite/rust/execute/torture/issue-1198.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1198.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39108dea1d091545982fefa88ce3be31b9eedf2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1198.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1198.rs?ref=a39108dea1d091545982fefa88ce3be31b9eedf2", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-output \"foo_deref\\nimm_deref\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"imm_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+impl<T> Deref for &mut T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"mut_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+struct Foo<T>(T);\n+impl<T> Deref for Foo<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        unsafe {\n+            let a = \"foo_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        &self.0\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let foo: Foo<i32> = Foo(123);\n+    let bar: &i32 = &foo;\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, *bar);\n+    }\n+\n+    0\n+}"}]}