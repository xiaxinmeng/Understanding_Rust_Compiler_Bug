{"sha": "034dabc92e9c18e2c2eac71396ed3aea79a81df5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM0ZGFiYzkyZTljMThlMmMyZWFjNzEzOTZlZDNhZWE3OWE4MWRmNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-02-24T21:08:55Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-02-24T21:08:55Z"}, "message": "(add_label_notes): Don't add notes for references to dispatch tables because jump doesn't.\n\n(add_label_notes): Don't add notes for references to\ndispatch tables because jump doesn't.\n(find_and_verify_loops): Invalidate loops that contain labels\nwhose address has been taken.\n\nFrom-SVN: r3523", "tree": {"sha": "d5e33058c427412aea89ec981fc26d45021d8cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5e33058c427412aea89ec981fc26d45021d8cf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/034dabc92e9c18e2c2eac71396ed3aea79a81df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/034dabc92e9c18e2c2eac71396ed3aea79a81df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/034dabc92e9c18e2c2eac71396ed3aea79a81df5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/034dabc92e9c18e2c2eac71396ed3aea79a81df5/comments", "author": null, "committer": null, "parents": [{"sha": "b24f97e8f26e4fd27d586f3a26a3acd67649a864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24f97e8f26e4fd27d586f3a26a3acd67649a864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b24f97e8f26e4fd27d586f3a26a3acd67649a864"}], "stats": {"total": 60, "additions": 52, "deletions": 8}, "files": [{"sha": "03458ee59598eb9af69e1a46047fae3adfb03622", "filename": "gcc/loop.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/034dabc92e9c18e2c2eac71396ed3aea79a81df5/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/034dabc92e9c18e2c2eac71396ed3aea79a81df5/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=034dabc92e9c18e2c2eac71396ed3aea79a81df5", "patch": "@@ -1476,10 +1476,21 @@ add_label_notes (x, insns)\n \n   if (code == LABEL_REF && !LABEL_REF_NONLOCAL_P (x))\n     {\n-      for (insn = insns; insn; insn = NEXT_INSN (insn))\n-\tif (reg_mentioned_p (XEXP (x, 0), insn))\n-\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL, XEXP (x, 0),\n-\t\t\t\t      REG_NOTES (insn));\n+      rtx next = next_real_insn (XEXP (x, 0));\n+\n+      /* Don't record labels that refer to dispatch tables.\n+\t This is not necessary, since the tablejump references the same label.\n+\t And if we did record them, flow.c would make worse code.  */\n+      if (next == 0\n+\t  || ! (GET_CODE (next) == JUMP_INSN\n+\t\t&& (GET_CODE (PATTERN (next)) == ADDR_VEC\n+\t\t    || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC)))\n+\t{\n+\t  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+\t    if (reg_mentioned_p (XEXP (x, 0), insn))\n+\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL, XEXP (x, 0),\n+\t\t\t\t\t  REG_NOTES (insn));\n+\t}\n       return;\n     }\n \n@@ -2167,7 +2178,7 @@ static void\n find_and_verify_loops (f)\n      rtx f;\n {\n-  rtx insn;\n+  rtx insn, label;\n   int current_loop = -1;\n   int next_loop = -1;\n   int loop;\n@@ -2222,8 +2233,24 @@ find_and_verify_loops (f)\n       uid_loop_num[INSN_UID (insn)] = current_loop;\n     }\n \n-  /* Now scan all JUMP_INSN's in the function.  If any branches into a loop\n-     that it is not contained within, that loop is marked invalid.\n+  /* Any loop containing a label used in an initializer must be invalidated,\n+     because it can be jumped into from anywhere.  */\n+\n+  for (label = forced_labels; label; label = XEXP (label, 1))\n+    {\n+      int loop_num;\n+\n+      for (loop_num = uid_loop_num[INSN_UID (XEXP (label, 0))];\n+\t   loop_num != -1;\n+\t   loop_num = loop_outer_loop[loop_num])\n+\tloop_invalid[loop_num] = 1;\n+    }\n+\n+  /* Now scan all insn's in the function.  If any JUMP_INSN branches into a\n+     loop that it is not contained within, that loop is marked invalid.\n+     If any INSN or CALL_INSN uses a label's address, then the loop containing\n+     that label is marked invalid, because it could be jumped into from\n+     anywhere.\n \n      Also look for blocks of code ending in an unconditional branch that\n      exits the loop.  If such a block is surrounded by a conditional \n@@ -2233,10 +2260,27 @@ find_and_verify_loops (f)\n      possible second cse pass.  */\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == JUMP_INSN)\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n       {\n \tint this_loop_num = uid_loop_num[INSN_UID (insn)];\n \n+\tif (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+\t  {\n+\t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n+\t    if (note)\n+\t      {\n+\t\tint loop_num;\n+\n+\t\tfor (loop_num = uid_loop_num[INSN_UID (XEXP (note, 0))];\n+\t\t     loop_num != -1;\n+\t\t     loop_num = loop_outer_loop[loop_num])\n+\t\t  loop_invalid[loop_num] = 1;\n+\t      }\n+\t  }\n+\n+\tif (GET_CODE (insn) != JUMP_INSN)\n+\t  continue;\n+\n \tmark_loop_jump (PATTERN (insn), this_loop_num);\n \n \t/* See if this is an unconditional branch outside the loop.  */"}]}