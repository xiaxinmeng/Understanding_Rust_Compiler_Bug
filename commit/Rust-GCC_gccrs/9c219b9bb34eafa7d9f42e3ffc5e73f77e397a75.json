{"sha": "9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWMyMTliOWJiMzRlYWZhN2Q5ZjQyZTNmZmM1ZTczZjc3ZTM5N2E3NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-08-24T09:41:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-08-24T09:41:17Z"}, "message": "expr.c (get_inner_reference): Do computation of bitoffset from offset in a way we can detect overflow reliably.\n\n2007-08-23  Richard Guenther  <rguenther@suse.de>\n\n\t* expr.c (get_inner_reference): Do computation of bitoffset\n\tfrom offset in a way we can detect overflow reliably.\n\nFrom-SVN: r127762", "tree": {"sha": "075bb7598ac3d2840c86bc617c31db2cf5b37ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/075bb7598ac3d2840c86bc617c31db2cf5b37ec2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1651030c4233d2bc976a89a5ac746969de805162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1651030c4233d2bc976a89a5ac746969de805162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1651030c4233d2bc976a89a5ac746969de805162"}], "stats": {"total": 37, "additions": 25, "deletions": 12}, "files": [{"sha": "adca8881442c2c763dcdd25dba6e1a4b83ddc8af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75", "patch": "@@ -1,3 +1,8 @@\n+2007-08-24  Richard Guenther  <rguenther@suse.de>\n+\n+\t* expr.c (get_inner_reference): Do computation of bitoffset\n+\tfrom offset in a way we can detect overflow reliably.\n+\n 2007-08-24  Jie Zhang  <jie.zhang@analog.com>\n \n \t* crtstuff.c (USE_PT_GNU_EH_FRAME): Don't define for uClibc."}, {"sha": "a3b8132709f1f47dbf73c567c42ba11fcd49fd98", "filename": "gcc/expr.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9c219b9bb34eafa7d9f42e3ffc5e73f77e397a75", "patch": "@@ -5782,7 +5782,6 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   enum machine_mode mode = VOIDmode;\n   tree offset = size_zero_node;\n   tree bit_offset = bitsize_zero_node;\n-  tree tem;\n \n   /* First get the mode, signedness, and size.  We do this from just the\n      outermost expression.  */\n@@ -5825,6 +5824,8 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t*pbitsize = tree_low_cst (size_tree, 1);\n     }\n \n+  *pmode = mode;\n+\n   /* Compute cumulative bit-offset for nested component-refs and array-refs,\n      and find the ultimate containing object.  */\n   while (1)\n@@ -5909,18 +5910,25 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n  done:\n \n   /* If OFFSET is constant, see if we can return the whole thing as a\n-     constant bit position.  Otherwise, split it up.  */\n-  if (host_integerp (offset, 0)\n-      && 0 != (tem = size_binop (MULT_EXPR,\n-\t\t\t\t fold_convert (bitsizetype, offset),\n-\t\t\t\t bitsize_unit_node))\n-      && 0 != (tem = size_binop (PLUS_EXPR, tem, bit_offset))\n-      && host_integerp (tem, 0))\n-    *pbitpos = tree_low_cst (tem, 0), *poffset = 0;\n-  else\n-    *pbitpos = tree_low_cst (bit_offset, 0), *poffset = offset;\n+     constant bit position.  Make sure to handle overflow during\n+     this conversion.  */\n+  if (host_integerp (offset, 0))\n+    {\n+      double_int tem = double_int_mul (tree_to_double_int (offset),\n+\t\t\t\t       uhwi_to_double_int (BITS_PER_UNIT));\n+      tem = double_int_add (tem, tree_to_double_int (bit_offset));\n+      if (double_int_fits_in_shwi_p (tem))\n+\t{\n+\t  *pbitpos = double_int_to_shwi (tem);\n+\t  *poffset = NULL_TREE;\n+\t  return exp;\n+\t}\n+    }\n+\n+  /* Otherwise, split it up.  */\n+  *pbitpos = tree_low_cst (bit_offset, 0);\n+  *poffset = offset;\n \n-  *pmode = mode;\n   return exp;\n }\n "}]}