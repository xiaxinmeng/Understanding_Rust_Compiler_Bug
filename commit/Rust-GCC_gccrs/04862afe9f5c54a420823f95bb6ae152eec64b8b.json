{"sha": "04862afe9f5c54a420823f95bb6ae152eec64b8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ4NjJhZmU5ZjVjNTRhNDIwODIzZjk1YmI2YWUxNTJlZWM2NGI4Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-04-08T18:36:25Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-04-08T18:36:25Z"}, "message": "libgo: update to Go 1.12.2\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/170706\n\nFrom-SVN: r270214", "tree": {"sha": "7b77ac8c94329f12ebde6ac6c869b0af05a92f85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b77ac8c94329f12ebde6ac6c869b0af05a92f85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04862afe9f5c54a420823f95bb6ae152eec64b8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04862afe9f5c54a420823f95bb6ae152eec64b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04862afe9f5c54a420823f95bb6ae152eec64b8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04862afe9f5c54a420823f95bb6ae152eec64b8b/comments", "author": null, "committer": null, "parents": [{"sha": "8108dfde82ad6ec43613107b2c156999e6a5cbe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8108dfde82ad6ec43613107b2c156999e6a5cbe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8108dfde82ad6ec43613107b2c156999e6a5cbe7"}], "stats": {"total": 344, "additions": 270, "deletions": 74}, "files": [{"sha": "1e4da036b8f331f8e01f56c1def8e0840cda9db8", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -1,4 +1,4 @@\n-392e9b3da473070f24dbe6c12c282a0e06e73b54\n+a69f7c05f1880bb90544fb0c3577109cb1d7f3ab\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "37b7480a6716bf92b1efef8db95304e1c997a034", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -1,4 +1,4 @@\n-0380c9ad38843d523d9c9804fe300cb7edd7cd3c\n+ac02fdec7cd16ea8d3de1fc33def9cfabec5170d\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "b9c64397147ebc5dfbbde432a6bb43f9e7448f8b", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -1 +1 @@\n-go1.12.1\n+go1.12.2"}, {"sha": "5e511dbdbd3623392a81ea87d0e7ca6dae3d278c", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -1184,6 +1184,36 @@ var cgoSyscallExclude = map[string]bool{\n \n var foldPath = make(map[string]string)\n \n+// DefaultExecName returns the default executable name\n+// for a package with the import path importPath.\n+//\n+// The default executable name is the last element of the import path.\n+// In module-aware mode, an additional rule is used. If the last element\n+// is a vN path element specifying the major version, then the second last\n+// element of the import path is used instead.\n+func DefaultExecName(importPath string) string {\n+\t_, elem := pathpkg.Split(importPath)\n+\tif cfg.ModulesEnabled {\n+\t\t// If this is example.com/mycmd/v2, it's more useful to install it as mycmd than as v2.\n+\t\t// See golang.org/issue/24667.\n+\t\tisVersion := func(v string) bool {\n+\t\t\tif len(v) < 2 || v[0] != 'v' || v[1] < '1' || '9' < v[1] {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tfor i := 2; i < len(v); i++ {\n+\t\t\t\tif c := v[i]; c < '0' || '9' < c {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\t\tif isVersion(elem) {\n+\t\t\t_, elem = pathpkg.Split(pathpkg.Dir(importPath))\n+\t\t}\n+\t}\n+\treturn elem\n+}\n+\n // load populates p using information from bp, err, which should\n // be the result of calling build.Context.Import.\n func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n@@ -1226,7 +1256,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t}\n \t\t_, elem := filepath.Split(p.Dir)\n \t\tif cfg.ModulesEnabled {\n-\t\t\t// NOTE(rsc): Using p.ImportPath instead of p.Dir\n+\t\t\t// NOTE(rsc,dmitshur): Using p.ImportPath instead of p.Dir\n \t\t\t// makes sure we install a package in the root of a\n \t\t\t// cached module directory as that package name\n \t\t\t// not name@v1.2.3.\n@@ -1235,26 +1265,9 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t\t// even for non-module-enabled code,\n \t\t\t// but I'm not brave enough to change the\n \t\t\t// non-module behavior this late in the\n-\t\t\t// release cycle. Maybe for Go 1.12.\n+\t\t\t// release cycle. Can be done for Go 1.13.\n \t\t\t// See golang.org/issue/26869.\n-\t\t\t_, elem = pathpkg.Split(p.ImportPath)\n-\n-\t\t\t// If this is example.com/mycmd/v2, it's more useful to install it as mycmd than as v2.\n-\t\t\t// See golang.org/issue/24667.\n-\t\t\tisVersion := func(v string) bool {\n-\t\t\t\tif len(v) < 2 || v[0] != 'v' || v[1] < '1' || '9' < v[1] {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tfor i := 2; i < len(v); i++ {\n-\t\t\t\t\tif c := v[i]; c < '0' || '9' < c {\n-\t\t\t\t\t\treturn false\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t\tif isVersion(elem) {\n-\t\t\t\t_, elem = pathpkg.Split(pathpkg.Dir(p.ImportPath))\n-\t\t\t}\n+\t\t\telem = DefaultExecName(p.ImportPath)\n \t\t}\n \t\tfull := cfg.BuildContext.GOOS + \"_\" + cfg.BuildContext.GOARCH + \"/\" + elem\n \t\tif cfg.BuildContext.GOOS != base.ToolGOOS || cfg.BuildContext.GOARCH != base.ToolGOARCH {"}, {"sha": "7385c4e5030ec1b35ffc4603c7507d96701c49f2", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -268,17 +268,8 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \tpmain.Imports = pmain.Imports[:w]\n \tpmain.Internal.RawImports = str.StringList(pmain.Imports)\n \n-\tif ptest != p {\n-\t\t// We have made modifications to the package p being tested\n-\t\t// and are rebuilding p (as ptest).\n-\t\t// Arrange to rebuild all packages q such that\n-\t\t// the test depends on q and q depends on p.\n-\t\t// This makes sure that q sees the modifications to p.\n-\t\t// Strictly speaking, the rebuild is only necessary if the\n-\t\t// modifications to p change its export metadata, but\n-\t\t// determining that is a bit tricky, so we rebuild always.\n-\t\trecompileForTest(pmain, p, ptest, pxtest)\n-\t}\n+\t// Replace pmain's transitive dependencies with test copies, as necessary.\n+\trecompileForTest(pmain, p, ptest, pxtest)\n \n \t// Should we apply coverage analysis locally,\n \t// only for this package and only for this test?\n@@ -325,6 +316,14 @@ Search:\n \treturn stk\n }\n \n+// recompileForTest copies and replaces certain packages in pmain's dependency\n+// graph. This is necessary for two reasons. First, if ptest is different than\n+// preal, packages that import the package under test should get ptest instead\n+// of preal. This is particularly important if pxtest depends on functionality\n+// exposed in test sources in ptest. Second, if there is a main package\n+// (other than pmain) anywhere, we need to clear p.Internal.BuildInfo in\n+// the test copy to prevent link conflicts. This may happen if both -coverpkg\n+// and the command line patterns include multiple main packages.\n func recompileForTest(pmain, preal, ptest, pxtest *Package) {\n \t// The \"test copy\" of preal is ptest.\n \t// For each package that depends on preal, make a \"test copy\"\n@@ -367,7 +366,7 @@ func recompileForTest(pmain, preal, ptest, pxtest *Package) {\n \n \t\t// Don't compile build info from a main package. This can happen\n \t\t// if -coverpkg patterns include main packages, since those packages\n-\t\t// are imported by pmain.\n+\t\t// are imported by pmain. See golang.org/issue/30907.\n \t\tif p.Internal.BuildInfo != \"\" && p != pmain {\n \t\t\tsplit()\n \t\t}"}, {"sha": "b72eace55ab13646d53dbce64e8af2726ccc4400", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -805,7 +805,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \tif p.ImportPath == \"command-line-arguments\" {\n \t\telem = p.Name\n \t} else {\n-\t\t_, elem = path.Split(p.ImportPath)\n+\t\telem = load.DefaultExecName(p.ImportPath)\n \t}\n \ttestBinary := elem + \".test\"\n "}, {"sha": "ed66df22c33b4714b1251ebfcca9c0ded7453a29", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"go/build\"\n \t\"os\"\n \t\"os/exec\"\n-\t\"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n@@ -285,7 +284,7 @@ func runBuild(cmd *base.Command, args []string) {\n \tpkgs := load.PackagesForBuild(args)\n \n \tif len(pkgs) == 1 && pkgs[0].Name == \"main\" && cfg.BuildO == \"\" {\n-\t\t_, cfg.BuildO = path.Split(pkgs[0].ImportPath)\n+\t\tcfg.BuildO = load.DefaultExecName(pkgs[0].ImportPath)\n \t\tcfg.BuildO += cfg.ExeSuffix\n \t}\n \n@@ -518,7 +517,7 @@ func InstallPackages(patterns []string, pkgs []*load.Package) {\n \tif len(patterns) == 0 && len(pkgs) == 1 && pkgs[0].Name == \"main\" {\n \t\t// Compute file 'go build' would have created.\n \t\t// If it exists and is an executable file, remove it.\n-\t\t_, targ := filepath.Split(pkgs[0].ImportPath)\n+\t\ttarg := load.DefaultExecName(pkgs[0].ImportPath)\n \t\ttarg += cfg.ExeSuffix\n \t\tif filepath.Join(pkgs[0].Dir, targ) != pkgs[0].Target { // maybe $GOBIN is the current directory\n \t\t\tfi, err := os.Stat(targ)"}, {"sha": "530272466141ce980c4795dd85d0cb4c72d0abd7", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -214,6 +214,7 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \tif p.Internal.CoverMode != \"\" {\n \t\tfmt.Fprintf(h, \"cover %q %q\\n\", p.Internal.CoverMode, b.toolID(\"cover\"))\n \t}\n+\tfmt.Fprintf(h, \"modinfo %q\\n\", p.Internal.BuildInfo)\n \n \t// Configuration specific to compiler toolchain.\n \tswitch cfg.BuildToolchainName {"}, {"sha": "3acd6379311f643194e45a712464b4af4aed5fa6", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_fortune_v2_v2.0.0.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v2_v2.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v2_v2.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v2_v2.0.0.txt?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -13,3 +13,9 @@ import \"rsc.io/quote\"\n func main() {\n \tprintln(quote.Hello())\n }\n+-- fortune_test.go --\n+package main\n+\n+import \"testing\"\n+\n+func TestFortuneV2(t *testing.T) {}"}, {"sha": "ab7cd66949db0fbb60ddd3084c6d11e8082d2593", "filename": "libgo/go/cmd/go/testdata/script/cover_pkgall_multiple_mains.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_multiple_mains.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_multiple_mains.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_multiple_mains.txt?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -0,0 +1,43 @@\n+# This test checks that multiple main packages can be tested\n+# with -coverpkg=all without duplicate symbol errors.\n+# Verifies golang.org/issue/30374.\n+\n+env GO111MODULE=on\n+\n+[short] skip\n+\n+go test -coverpkg=all ./...\n+\n+-- go.mod --\n+module example.com/cov\n+\n+-- mainonly/mainonly.go --\n+package main\n+\n+func main() {}\n+\n+-- mainwithtest/mainwithtest.go --\n+package main\n+\n+func main() {}\n+\n+func Foo() {}\n+\n+-- mainwithtest/mainwithtest_test.go --\n+package main\n+\n+import \"testing\"\n+\n+func TestFoo(t *testing.T) {\n+  Foo()\n+}\n+\n+-- xtest/x.go --\n+package x\n+\n+-- xtest/x_test.go --\n+package x_test\n+\n+import \"testing\"\n+\n+func TestX(t *testing.T) {}"}, {"sha": "f860b82c97489e4e30c8cb3e28ae20f9ca8aed4f", "filename": "libgo/go/internal/poll/fd_windows.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_windows.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -660,6 +660,10 @@ func (fd *FD) Write(buf []byte) (int, error) {\n \t\treturn 0, err\n \t}\n \tdefer fd.writeUnlock()\n+\tif fd.isFile || fd.isDir || fd.isConsole {\n+\t\tfd.l.Lock()\n+\t\tdefer fd.l.Unlock()\n+\t}\n \n \tntotal := 0\n \tfor len(buf) > 0 {\n@@ -670,8 +674,6 @@ func (fd *FD) Write(buf []byte) (int, error) {\n \t\tvar n int\n \t\tvar err error\n \t\tif fd.isFile || fd.isDir || fd.isConsole {\n-\t\t\tfd.l.Lock()\n-\t\t\tdefer fd.l.Unlock()\n \t\t\tif fd.isConsole {\n \t\t\t\tn, err = fd.writeConsole(b)\n \t\t\t} else {"}, {"sha": "4b165d65a6aff44f352d9852bd64dd69421fd2b2", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -389,6 +389,11 @@ func (p *ReverseProxy) copyResponse(dst io.Writer, src io.Reader, flushInterval\n \t\t\t\tlatency: flushInterval,\n \t\t\t}\n \t\t\tdefer mlw.stop()\n+\n+\t\t\t// set up initial timer so headers get flushed even if body writes are delayed\n+\t\t\tmlw.flushPending = true\n+\t\t\tmlw.t = time.AfterFunc(flushInterval, mlw.delayedFlush)\n+\n \t\t\tdst = mlw\n \t\t}\n \t}"}, {"sha": "367ba73ae2497919748186a3ec886a0f17b8eef7", "filename": "libgo/go/net/http/httputil/reverseproxy_test.go", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -9,6 +9,7 @@ package httputil\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n@@ -317,6 +318,47 @@ func TestReverseProxyFlushInterval(t *testing.T) {\n \t}\n }\n \n+func TestReverseProxyFlushIntervalHeaders(t *testing.T) {\n+\tconst expected = \"hi\"\n+\tstopCh := make(chan struct{})\n+\tbackend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Add(\"MyHeader\", expected)\n+\t\tw.WriteHeader(200)\n+\t\tw.(http.Flusher).Flush()\n+\t\t<-stopCh\n+\t}))\n+\tdefer backend.Close()\n+\tdefer close(stopCh)\n+\n+\tbackendURL, err := url.Parse(backend.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tproxyHandler := NewSingleHostReverseProxy(backendURL)\n+\tproxyHandler.FlushInterval = time.Microsecond\n+\n+\tfrontend := httptest.NewServer(proxyHandler)\n+\tdefer frontend.Close()\n+\n+\treq, _ := http.NewRequest(\"GET\", frontend.URL, nil)\n+\treq.Close = true\n+\n+\tctx, cancel := context.WithTimeout(req.Context(), 10*time.Second)\n+\tdefer cancel()\n+\treq = req.WithContext(ctx)\n+\n+\tres, err := frontend.Client().Do(req)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get: %v\", err)\n+\t}\n+\tdefer res.Body.Close()\n+\n+\tif res.Header.Get(\"MyHeader\") != expected {\n+\t\tt.Errorf(\"got header %q; expected %q\", res.Header.Get(\"MyHeader\"), expected)\n+\t}\n+}\n+\n func TestReverseProxyCancelation(t *testing.T) {\n \tconst backendResponse = \"I am the backend\"\n "}, {"sha": "08e8d013855f4f9123544508be2fe2042a1cadf3", "filename": "libgo/go/net/lookup.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fnet%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fnet%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -262,8 +262,9 @@ func (r *Resolver) lookupIPAddr(ctx context.Context, network, host string) ([]IP\n \t// only the values in context. See Issue 28600.\n \tlookupGroupCtx, lookupGroupCancel := context.WithCancel(withUnexpiredValuesPreserved(ctx))\n \n+\tlookupKey := network + \"\\000\" + host\n \tdnsWaitGroup.Add(1)\n-\tch, called := r.getLookupGroup().DoChan(host, func() (interface{}, error) {\n+\tch, called := r.getLookupGroup().DoChan(lookupKey, func() (interface{}, error) {\n \t\tdefer dnsWaitGroup.Done()\n \t\treturn testHookLookupIP(lookupGroupCtx, resolverFunc, network, host)\n \t})\n@@ -280,7 +281,7 @@ func (r *Resolver) lookupIPAddr(ctx context.Context, network, host string) ([]IP\n \t\t// let the lookup continue uncanceled, and let later\n \t\t// lookups with the same key share the result.\n \t\t// See issues 8602, 20703, 22724.\n-\t\tif r.getLookupGroup().ForgetUnshared(host) {\n+\t\tif r.getLookupGroup().ForgetUnshared(lookupKey) {\n \t\t\tlookupGroupCancel()\n \t\t} else {\n \t\t\tgo func() {"}, {"sha": "28a895e15d13c03cf11d0cfd335f6ad5f8ef8546", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -16,6 +16,7 @@ import (\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n+\t\"sync/atomic\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -253,14 +254,11 @@ func TestLookupGmailTXT(t *testing.T) {\n \t}\n }\n \n-var lookupGooglePublicDNSAddrTests = []struct {\n-\taddr, name string\n-}{\n-\t{\"8.8.8.8\", \".google.com.\"},\n-\t{\"8.8.4.4\", \".google.com.\"},\n-\n-\t{\"2001:4860:4860::8888\", \".google.com.\"},\n-\t{\"2001:4860:4860::8844\", \".google.com.\"},\n+var lookupGooglePublicDNSAddrTests = []string{\n+\t\"8.8.8.8\",\n+\t\"8.8.4.4\",\n+\t\"2001:4860:4860::8888\",\n+\t\"2001:4860:4860::8844\",\n }\n \n func TestLookupGooglePublicDNSAddr(t *testing.T) {\n@@ -272,17 +270,17 @@ func TestLookupGooglePublicDNSAddr(t *testing.T) {\n \n \tdefer dnsWaitGroup.Wait()\n \n-\tfor _, tt := range lookupGooglePublicDNSAddrTests {\n-\t\tnames, err := LookupAddr(tt.addr)\n+\tfor _, ip := range lookupGooglePublicDNSAddrTests {\n+\t\tnames, err := LookupAddr(ip)\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t\tif len(names) == 0 {\n \t\t\tt.Error(\"got no record\")\n \t\t}\n \t\tfor _, name := range names {\n-\t\t\tif !strings.HasSuffix(name, tt.name) {\n-\t\t\t\tt.Errorf(\"got %s; want a record containing %s\", name, tt.name)\n+\t\t\tif !strings.HasSuffix(name, \".google.com.\") && !strings.HasSuffix(name, \".google.\") {\n+\t\t\t\tt.Errorf(\"got %q; want a record ending in .google.com. or .google.\", name)\n \t\t\t}\n \t\t}\n \t}\n@@ -658,8 +656,8 @@ func testDots(t *testing.T, mode string) {\n \t\tt.Errorf(\"LookupAddr(8.8.8.8): %v (mode=%v)\", err, mode)\n \t} else {\n \t\tfor _, name := range names {\n-\t\t\tif !strings.HasSuffix(name, \".google.com.\") {\n-\t\t\t\tt.Errorf(\"LookupAddr(8.8.8.8) = %v, want names ending in .google.com. with trailing dot (mode=%v)\", names, mode)\n+\t\t\tif !strings.HasSuffix(name, \".google.com.\") && !strings.HasSuffix(name, \".google.\") {\n+\t\t\t\tt.Errorf(\"LookupAddr(8.8.8.8) = %v, want names ending in .google.com or .google with trailing dot (mode=%v)\", names, mode)\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n@@ -1096,6 +1094,69 @@ func TestLookupIPAddrPreservesContextValues(t *testing.T) {\n \t}\n }\n \n+// Issue 30521: The lookup group should call the resolver for each network.\n+func TestLookupIPAddrConcurrentCallsForNetworks(t *testing.T) {\n+\torigTestHookLookupIP := testHookLookupIP\n+\tdefer func() { testHookLookupIP = origTestHookLookupIP }()\n+\n+\tqueries := [][]string{\n+\t\t{\"udp\", \"golang.org\"},\n+\t\t{\"udp4\", \"golang.org\"},\n+\t\t{\"udp6\", \"golang.org\"},\n+\t\t{\"udp\", \"golang.org\"},\n+\t\t{\"udp\", \"golang.org\"},\n+\t}\n+\tresults := map[[2]string][]IPAddr{\n+\t\t{\"udp\", \"golang.org\"}: {\n+\t\t\t{IP: IPv4(127, 0, 0, 1)},\n+\t\t\t{IP: IPv6loopback},\n+\t\t},\n+\t\t{\"udp4\", \"golang.org\"}: {\n+\t\t\t{IP: IPv4(127, 0, 0, 1)},\n+\t\t},\n+\t\t{\"udp6\", \"golang.org\"}: {\n+\t\t\t{IP: IPv6loopback},\n+\t\t},\n+\t}\n+\tcalls := int32(0)\n+\twaitCh := make(chan struct{})\n+\ttestHookLookupIP = func(ctx context.Context, fn func(context.Context, string, string) ([]IPAddr, error), network, host string) ([]IPAddr, error) {\n+\t\t// We'll block until this is called one time for each different\n+\t\t// expected result. This will ensure that the lookup group would wait\n+\t\t// for the existing call if it was to be reused.\n+\t\tif atomic.AddInt32(&calls, 1) == int32(len(results)) {\n+\t\t\tclose(waitCh)\n+\t\t}\n+\t\tselect {\n+\t\tcase <-waitCh:\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil, ctx.Err()\n+\t\t}\n+\t\treturn results[[2]string{network, host}], nil\n+\t}\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n+\tdefer cancel()\n+\twg := sync.WaitGroup{}\n+\tfor _, q := range queries {\n+\t\tnetwork := q[0]\n+\t\thost := q[1]\n+\t\twg.Add(1)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tgotIPs, err := DefaultResolver.lookupIPAddr(ctx, network, host)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"lookupIPAddr(%v, %v): unexpected error: %v\", network, host, err)\n+\t\t\t}\n+\t\t\twantIPs := results[[2]string{network, host}]\n+\t\t\tif !reflect.DeepEqual(gotIPs, wantIPs) {\n+\t\t\t\tt.Errorf(\"lookupIPAddr(%v, %v): mismatched IPAddr results\\n\\tGot: %v\\n\\tWant: %v\", network, host, gotIPs, wantIPs)\n+\t\t\t}\n+\t\t}()\n+\t}\n+\twg.Wait()\n+}\n+\n func TestWithUnexpiredValuesPreserved(t *testing.T) {\n \tctx, cancel := context.WithCancel(context.Background())\n "}, {"sha": "ba43ea352547b9e4018df73c55b2b8d9a6f9bc90", "filename": "libgo/go/os/path.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fos%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fos%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -62,6 +62,7 @@ func MkdirAll(path string, perm FileMode) error {\n // It removes everything it can but returns the first error\n // it encounters. If the path does not exist, RemoveAll\n // returns nil (no error).\n+// If there is an error, it will be of type *PathError.\n func RemoveAll(path string) error {\n \treturn removeAll(path)\n }"}, {"sha": "4864989fb5b5f70c1f5ebbd36dda3d18b31e5a3b", "filename": "libgo/go/os/path_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fos%2Fpath_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fos%2Fpath_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath_unix.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -51,7 +51,7 @@ func splitPath(path string) (string, string) {\n \t// Remove leading directory path\n \tfor i--; i >= 0; i-- {\n \t\tif path[i] == '/' {\n-\t\t\tdirname = path[:i+1]\n+\t\t\tdirname = path[:i]\n \t\t\tbasename = path[i+1:]\n \t\t\tbreak\n \t\t}"}, {"sha": "6fdd7e828d6b8d7859c7a6bbef8549fc7b31b861", "filename": "libgo/go/os/removeall_at.go", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fos%2Fremoveall_at.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fos%2Fremoveall_at.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fremoveall_at.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -46,13 +46,20 @@ func removeAll(path string) error {\n \t}\n \tdefer parent.Close()\n \n-\treturn removeAllFrom(parent, base)\n+\tif err := removeAllFrom(parent, base); err != nil {\n+\t\tif pathErr, ok := err.(*PathError); ok {\n+\t\t\tpathErr.Path = parentDir + string(PathSeparator) + pathErr.Path\n+\t\t\terr = pathErr\n+\t\t}\n+\t\treturn err\n+\t}\n+\treturn nil\n }\n \n-func removeAllFrom(parent *File, path string) error {\n+func removeAllFrom(parent *File, base string) error {\n \tparentFd := int(parent.Fd())\n \t// Simple case: if Unlink (aka remove) works, we're done.\n-\terr := unix.Unlinkat(parentFd, path, 0)\n+\terr := unix.Unlinkat(parentFd, base, 0)\n \tif err == nil || IsNotExist(err) {\n \t\treturn nil\n \t}\n@@ -64,21 +71,21 @@ func removeAllFrom(parent *File, path string) error {\n \t// whose contents need to be removed.\n \t// Otherwise just return the error.\n \tif err != syscall.EISDIR && err != syscall.EPERM && err != syscall.EACCES {\n-\t\treturn err\n+\t\treturn &PathError{\"unlinkat\", base, err}\n \t}\n \n \t// Is this a directory we need to recurse into?\n \tvar statInfo syscall.Stat_t\n-\tstatErr := unix.Fstatat(parentFd, path, &statInfo, unix.AT_SYMLINK_NOFOLLOW)\n+\tstatErr := unix.Fstatat(parentFd, base, &statInfo, unix.AT_SYMLINK_NOFOLLOW)\n \tif statErr != nil {\n \t\tif IsNotExist(statErr) {\n \t\t\treturn nil\n \t\t}\n-\t\treturn statErr\n+\t\treturn &PathError{\"fstatat\", base, statErr}\n \t}\n \tif statInfo.Mode&syscall.S_IFMT != syscall.S_IFDIR {\n-\t\t// Not a directory; return the error from the Remove.\n-\t\treturn err\n+\t\t// Not a directory; return the error from the unix.Unlinkat.\n+\t\treturn &PathError{\"unlinkat\", base, err}\n \t}\n \n \t// Remove the directory's entries.\n@@ -87,12 +94,12 @@ func removeAllFrom(parent *File, path string) error {\n \t\tconst request = 1024\n \n \t\t// Open the directory to recurse into\n-\t\tfile, err := openFdAt(parentFd, path)\n+\t\tfile, err := openFdAt(parentFd, base)\n \t\tif err != nil {\n \t\t\tif IsNotExist(err) {\n \t\t\t\treturn nil\n \t\t\t}\n-\t\t\trecurseErr = err\n+\t\t\trecurseErr = &PathError{\"openfdat\", base, err}\n \t\t\tbreak\n \t\t}\n \n@@ -103,12 +110,15 @@ func removeAllFrom(parent *File, path string) error {\n \t\t\tif IsNotExist(readErr) {\n \t\t\t\treturn nil\n \t\t\t}\n-\t\t\treturn readErr\n+\t\t\treturn &PathError{\"readdirnames\", base, readErr}\n \t\t}\n \n \t\tfor _, name := range names {\n \t\t\terr := removeAllFrom(file, name)\n \t\t\tif err != nil {\n+\t\t\t\tif pathErr, ok := err.(*PathError); ok {\n+\t\t\t\t\tpathErr.Path = base + string(PathSeparator) + pathErr.Path\n+\t\t\t\t}\n \t\t\t\trecurseErr = err\n \t\t\t}\n \t\t}\n@@ -127,15 +137,15 @@ func removeAllFrom(parent *File, path string) error {\n \t}\n \n \t// Remove the directory itself.\n-\tunlinkError := unix.Unlinkat(parentFd, path, unix.AT_REMOVEDIR)\n+\tunlinkError := unix.Unlinkat(parentFd, base, unix.AT_REMOVEDIR)\n \tif unlinkError == nil || IsNotExist(unlinkError) {\n \t\treturn nil\n \t}\n \n \tif recurseErr != nil {\n \t\treturn recurseErr\n \t}\n-\treturn unlinkError\n+\treturn &PathError{\"unlinkat\", base, unlinkError}\n }\n \n // openFdAt opens path relative to the directory in fd.\n@@ -157,7 +167,7 @@ func openFdAt(dirfd int, name string) (*File, error) {\n \t\t\tcontinue\n \t\t}\n \n-\t\treturn nil, &PathError{\"openat\", name, e}\n+\t\treturn nil, e\n \t}\n \n \tif !supportsCloseOnExec {"}, {"sha": "945a38e8e06df37e1dc3bb5071fc75a071e2a6ac", "filename": "libgo/go/os/removeall_test.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fos%2Fremoveall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fos%2Fremoveall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fremoveall_test.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -294,7 +294,7 @@ func TestRemoveReadOnlyDir(t *testing.T) {\n }\n \n // Issue #29983.\n-func TestRemoveAllButReadOnly(t *testing.T) {\n+func TestRemoveAllButReadOnlyAndPathError(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"nacl\", \"js\", \"windows\":\n \t\tt.Skipf(\"skipping test on %s\", runtime.GOOS)\n@@ -355,10 +355,21 @@ func TestRemoveAllButReadOnly(t *testing.T) {\n \t\tdefer Chmod(d, 0777)\n \t}\n \n-\tif err := RemoveAll(tempDir); err == nil {\n+\terr = RemoveAll(tempDir)\n+\tif err == nil {\n \t\tt.Fatal(\"RemoveAll succeeded unexpectedly\")\n \t}\n \n+\t// The error should be of type *PathError.\n+\t// see issue 30491 for details.\n+\tif pathErr, ok := err.(*PathError); ok {\n+\t\tif g, w := pathErr.Path, filepath.Join(tempDir, \"b\", \"y\"); g != w {\n+\t\t\tt.Errorf(\"got %q, expected pathErr.path %q\", g, w)\n+\t\t}\n+\t} else {\n+\t\tt.Errorf(\"got %T, expected *os.PathError\", err)\n+\t}\n+\n \tfor _, dir := range dirs {\n \t\t_, err := Stat(filepath.Join(tempDir, dir))\n \t\tif inReadonly(dir) {"}, {"sha": "08d6a34f50c669a3ce4e13307a09915ab21eed84", "filename": "libgo/go/runtime/runtime-lldb_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fruntime%2Fruntime-lldb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fruntime%2Fruntime-lldb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime-lldb_test.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -139,6 +139,7 @@ func TestLldbPython(t *testing.T) {\n \tif final := os.Getenv(\"GOROOT_FINAL\"); final != \"\" && runtime.GOROOT() != final {\n \t\tt.Skip(\"gdb test can fail with GOROOT_FINAL pending\")\n \t}\n+\ttestenv.SkipFlaky(t, 31188)\n \n \tcheckLldbPython(t)\n "}, {"sha": "db80d98a084d019832c52cce5a77126663951ecc", "filename": "libgo/go/syscall/security_windows.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04862afe9f5c54a420823f95bb6ae152eec64b8b/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go?ref=04862afe9f5c54a420823f95bb6ae152eec64b8b", "patch": "@@ -290,6 +290,7 @@ type Tokenprimarygroup struct {\n //sys\tOpenProcessToken(h Handle, access uint32, token *Token) (err error) = advapi32.OpenProcessToken\n //sys\tGetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) = advapi32.GetTokenInformation\n //sys\tGetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) = userenv.GetUserProfileDirectoryW\n+//sys\tgetSystemDirectory(dir *uint16, dirLen uint32) (len uint32, err error) = kernel32.GetSystemDirectoryW\n \n // An access token contains the security information for a logon session.\n // The system creates an access token when a user logs on, and every"}]}