{"sha": "7999d7b4e6f6a225d8afddd54fd499ec6448a0cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk5OWQ3YjRlNmY2YTIyNWQ4YWZkZGQ1NGZkNDk5ZWM2NDQ4YTBjZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2012-10-27T12:07:26Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2012-10-27T12:07:26Z"}, "message": "trans.c (gfc_allocate_allocatable): Revert accidental commit.\n\n2012-10-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* trans.c (gfc_allocate_allocatable):  Revert accidental\n\tcommit.\n\nFrom-SVN: r192875", "tree": {"sha": "40066fef0f04e105095f8eaf3a5e7f55fa88fbc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40066fef0f04e105095f8eaf3a5e7f55fa88fbc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd/comments", "author": null, "committer": null, "parents": [{"sha": "38d233a928cf70b351c67987280c0c3169cf0241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d233a928cf70b351c67987280c0c3169cf0241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38d233a928cf70b351c67987280c0c3169cf0241"}], "stats": {"total": 33, "additions": 17, "deletions": 16}, "files": [{"sha": "25e5f0b2716d0971cec49c55924ef774a7c16ae3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7999d7b4e6f6a225d8afddd54fd499ec6448a0cd", "patch": "@@ -1,3 +1,8 @@\n+2012-10-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* trans.c (gfc_allocate_allocatable):  Revert accidental\n+\tcommit.\n+\n 2012-10-24  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/55037"}, {"sha": "6365213b8f063682ef51e479d4a62ca3ac8b07b7", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999d7b4e6f6a225d8afddd54fd499ec6448a0cd/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=7999d7b4e6f6a225d8afddd54fd499ec6448a0cd", "patch": "@@ -814,23 +814,26 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n }\n \n \n-/* Free a given variable.  If it is NULL, free takes care of this\n-   automatically.  */\n+/* Free a given variable, if it's not NULL.  */\n tree\n gfc_call_free (tree var)\n {\n   stmtblock_t block;\n-  tree call;\n+  tree tmp, cond, call;\n \n   if (TREE_TYPE (var) != TREE_TYPE (pvoid_type_node))\n     var = fold_convert (pvoid_type_node, var);\n \n   gfc_start_block (&block);\n   var = gfc_evaluate_now (var, &block);\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, var,\n+\t\t\t  build_int_cst (pvoid_type_node, 0));\n   call = build_call_expr_loc (input_location,\n \t\t\t      builtin_decl_explicit (BUILT_IN_FREE),\n \t\t\t      1, var);\n-  gfc_add_expr_to_block (&block, call);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, call,\n+\t\t\t build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n }\n@@ -858,10 +861,11 @@ gfc_call_free (tree var)\n \t}\n     }\n \n-   In this front-end version, status doesn't have to be GFC_INTEGER_4.  If\n-   CAN_FAIL is true, no status variable is passed and we are not dealing with\n-   a coarray, we will simply call free().  This is used for unconditional\n-   deallocation generated by the front-end at end of each procedure.\n+   In this front-end version, status doesn't have to be GFC_INTEGER_4.\n+   Moreover, if CAN_FAIL is true, then we will not emit a runtime error,\n+   even when no status variable is passed to us (this is used for\n+   unconditional deallocation generated by the front-end at end of\n+   each procedure).\n    \n    If a runtime-message is possible, `expr' must point to the original\n    expression being deallocated for its locus and variable name.\n@@ -886,14 +890,6 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n       STRIP_NOPS (pointer);\n     }\n \n-  else if (can_fail && status == NULL_TREE)\n-    {\n-      tmp = build_call_expr_loc (input_location,\n-\t\t\t\t builtin_decl_explicit (BUILT_IN_FREE), 1,\n-\t\t\t\t fold_convert (pvoid_type_node, pointer));\n-      return tmp;\n-    }\n-\n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n \t\t\t  build_int_cst (TREE_TYPE (pointer), 0));\n "}]}