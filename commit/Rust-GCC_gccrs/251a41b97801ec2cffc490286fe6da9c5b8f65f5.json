{"sha": "251a41b97801ec2cffc490286fe6da9c5b8f65f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUxYTQxYjk3ODAxZWMyY2ZmYzQ5MDI4NmZlNmRhOWM1YjhmNjVmNQ==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-05-16T17:45:35Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-05-16T17:45:35Z"}, "message": "cfgrtl.c (verify_hot_cold_block_grouping): Return err.\n\n2013-05-16  Teresa Johnson  <tejohnson@google.com>\n\n\t* cfgrtl.c (verify_hot_cold_block_grouping): Return err.\n\t(rtl_verify_edges): New function.\n\t(rtl_verify_bb_insns): Ditto.\n\t(rtl_verify_bb_pointers): Ditto.\n\t(rtl_verify_bb_insn_chain): Ditto.\n\t(rtl_verify_fallthru): Ditto.\n\t(rtl_verify_bb_layout): Ditto.\n\t(rtl_verify_flow_info_1): Outline checks into new functions.\n\t(rtl_verify_flow_info): Ditto.\n\nFrom-SVN: r198982", "tree": {"sha": "f0c1349aadf4c40ba99f1c9ae57557bd37a90a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0c1349aadf4c40ba99f1c9ae57557bd37a90a0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/251a41b97801ec2cffc490286fe6da9c5b8f65f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/251a41b97801ec2cffc490286fe6da9c5b8f65f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/251a41b97801ec2cffc490286fe6da9c5b8f65f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/251a41b97801ec2cffc490286fe6da9c5b8f65f5/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e5b06335f9f6536c7e889a2b6209f3698f3c2ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5b06335f9f6536c7e889a2b6209f3698f3c2ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e5b06335f9f6536c7e889a2b6209f3698f3c2ee"}], "stats": {"total": 322, "additions": 209, "deletions": 113}, "files": [{"sha": "574694ce28dc49a95e1c53fb0152d845550edda5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/251a41b97801ec2cffc490286fe6da9c5b8f65f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/251a41b97801ec2cffc490286fe6da9c5b8f65f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=251a41b97801ec2cffc490286fe6da9c5b8f65f5", "patch": "@@ -1,3 +1,15 @@\n+2013-05-16  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* cfgrtl.c (verify_hot_cold_block_grouping): Return err.\n+\t(rtl_verify_edges): New function.\n+\t(rtl_verify_bb_insns): Ditto.\n+\t(rtl_verify_bb_pointers): Ditto.\n+\t(rtl_verify_bb_insn_chain): Ditto.\n+\t(rtl_verify_fallthru): Ditto.\n+\t(rtl_verify_bb_layout): Ditto.\n+\t(rtl_verify_flow_info_1): Outline checks into new functions.\n+\t(rtl_verify_flow_info): Ditto.\n+\n 2013-05-16  Steve Ellcey  <sellcey@imgtec.com>\n \n \t* cfghooks.c (copy_bbs): Add update_dominance argument."}, {"sha": "0ea297e4c60b17a8dd9695b40429f0f2bee6a572", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 197, "deletions": 113, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/251a41b97801ec2cffc490286fe6da9c5b8f65f5/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/251a41b97801ec2cffc490286fe6da9c5b8f65f5/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=251a41b97801ec2cffc490286fe6da9c5b8f65f5", "patch": "@@ -2063,7 +2063,7 @@ get_last_bb_insn (basic_block bb)\n    between hot/cold partitions. This condition will not be true until\n    after reorder_basic_blocks is called.  */\n \n-static void\n+static int\n verify_hot_cold_block_grouping (void)\n {\n   basic_block bb;\n@@ -2072,7 +2072,7 @@ verify_hot_cold_block_grouping (void)\n   int current_partition = BB_UNPARTITIONED;\n \n   if (!crtl->bb_reorder_complete)\n-    return;\n+    return err;\n \n   FOR_EACH_BB (bb)\n     {\n@@ -2094,81 +2094,28 @@ verify_hot_cold_block_grouping (void)\n       current_partition = BB_PARTITION (bb);\n     }\n \n-  gcc_assert(!err);\n+  return err;\n }\n \f\n-/* Verify the CFG and RTL consistency common for both underlying RTL and\n-   cfglayout RTL.\n \n-   Currently it does following checks:\n-\n-   - overlapping of basic blocks\n-   - insns with wrong BLOCK_FOR_INSN pointers\n-   - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)\n-   - tails of basic blocks (ensure that boundary is necessary)\n-   - scans body of the basic block for JUMP_INSN, CODE_LABEL\n-     and NOTE_INSN_BASIC_BLOCK\n-   - verify that no fall_thru edge crosses hot/cold partition boundaries\n-   - verify that there are no pending RTL branch predictions\n-   - verify that there is a single hot/cold partition boundary after bbro\n-\n-   In future it can be extended check a lot of other stuff as well\n-   (reachability of basic blocks, life information, etc. etc.).  */\n+/* Perform several checks on the edges out of each block, such as\n+   the consistency of the branch probabilities, the correctness\n+   of hot/cold partition crossing edges, and the number of expected\n+   successor edges.  */\n \n static int\n-rtl_verify_flow_info_1 (void)\n+rtl_verify_edges (void)\n {\n-  rtx x;\n   int err = 0;\n   basic_block bb;\n \n-  /* Check the general integrity of the basic blocks.  */\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      rtx insn;\n-\n-      if (!(bb->flags & BB_RTL))\n-\t{\n-\t  error (\"BB_RTL flag not set for block %d\", bb->index);\n-\t  err = 1;\n-\t}\n-\n-      FOR_BB_INSNS (bb, insn)\n-\tif (BLOCK_FOR_INSN (insn) != bb)\n-\t  {\n-\t    error (\"insn %d basic block pointer is %d, should be %d\",\n-\t\t   INSN_UID (insn),\n-\t\t   BLOCK_FOR_INSN (insn) ? BLOCK_FOR_INSN (insn)->index : 0,\n-\t\t   bb->index);\n-\t    err = 1;\n-\t  }\n-\n-      for (insn = BB_HEADER (bb); insn; insn = NEXT_INSN (insn))\n-\tif (!BARRIER_P (insn)\n-\t    && BLOCK_FOR_INSN (insn) != NULL)\n-\t  {\n-\t    error (\"insn %d in header of bb %d has non-NULL basic block\",\n-\t\t   INSN_UID (insn), bb->index);\n-\t    err = 1;\n-\t  }\n-      for (insn = BB_FOOTER (bb); insn; insn = NEXT_INSN (insn))\n-\tif (!BARRIER_P (insn)\n-\t    && BLOCK_FOR_INSN (insn) != NULL)\n-\t  {\n-\t    error (\"insn %d in footer of bb %d has non-NULL basic block\",\n-\t\t   INSN_UID (insn), bb->index);\n-\t    err = 1;\n-\t  }\n-    }\n-\n-  /* Now check the basic blocks (boundaries etc.) */\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       int n_fallthru = 0, n_branch = 0, n_abnormal_call = 0, n_sibcall = 0;\n       int n_eh = 0, n_abnormal = 0;\n       edge e, fallthru = NULL;\n-      rtx note;\n       edge_iterator ei;\n+      rtx note;\n \n       if (JUMP_P (BB_END (bb))\n \t  && (note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX))\n@@ -2183,6 +2130,7 @@ rtl_verify_flow_info_1 (void)\n \t      err = 1;\n \t    }\n \t}\n+\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  bool is_crossing;\n@@ -2296,26 +2244,26 @@ rtl_verify_flow_info_1 (void)\n \t  error (\"abnormal edges for no purpose in bb %i\", bb->index);\n \t  err = 1;\n \t}\n+    }\n \n-      for (x = BB_HEAD (bb); x != NEXT_INSN (BB_END (bb)); x = NEXT_INSN (x))\n-\t/* We may have a barrier inside a basic block before dead code\n-\t   elimination.  There is no BLOCK_FOR_INSN field in a barrier.  */\n-\tif (!BARRIER_P (x) && BLOCK_FOR_INSN (x) != bb)\n-\t  {\n-\t    debug_rtx (x);\n-\t    if (! BLOCK_FOR_INSN (x))\n-\t      error\n-\t\t(\"insn %d inside basic block %d but block_for_insn is NULL\",\n-\t\t INSN_UID (x), bb->index);\n-\t    else\n-\t      error\n-\t\t(\"insn %d inside basic block %d but block_for_insn is %i\",\n-\t\t INSN_UID (x), bb->index, BLOCK_FOR_INSN (x)->index);\n+  /* Clean up.  */\n+  return err;\n+}\n \n-\t    err = 1;\n-\t  }\n+/* Checks on the instructions within blocks. Currently checks that each\n+   block starts with a basic block note, and that basic block notes and\n+   control flow jumps are not found in the middle of the block.  */\n \n-      /* OK pointers are correct.  Now check the header of basic\n+static int\n+rtl_verify_bb_insns (void)\n+{\n+  rtx x;\n+  int err = 0;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      /* Now check the header of basic\n \t block.  It ought to contain optional CODE_LABEL followed\n \t by NOTE_BASIC_BLOCK.  */\n       x = BB_HEAD (bb);\n@@ -2362,7 +2310,57 @@ rtl_verify_flow_info_1 (void)\n \t  }\n     }\n \n-  verify_hot_cold_block_grouping();\n+  /* Clean up.  */\n+  return err;\n+}\n+\n+/* Verify that block pointers for instructions in basic blocks, headers and\n+   footers are set appropriately.  */\n+\n+static int\n+rtl_verify_bb_pointers (void)\n+{\n+  int err = 0;\n+  basic_block bb;\n+\n+  /* Check the general integrity of the basic blocks.  */\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      rtx insn;\n+\n+      if (!(bb->flags & BB_RTL))\n+\t{\n+\t  error (\"BB_RTL flag not set for block %d\", bb->index);\n+\t  err = 1;\n+\t}\n+\n+      FOR_BB_INSNS (bb, insn)\n+\tif (BLOCK_FOR_INSN (insn) != bb)\n+\t  {\n+\t    error (\"insn %d basic block pointer is %d, should be %d\",\n+\t\t   INSN_UID (insn),\n+\t\t   BLOCK_FOR_INSN (insn) ? BLOCK_FOR_INSN (insn)->index : 0,\n+\t\t   bb->index);\n+\t    err = 1;\n+\t  }\n+\n+      for (insn = BB_HEADER (bb); insn; insn = NEXT_INSN (insn))\n+\tif (!BARRIER_P (insn)\n+\t    && BLOCK_FOR_INSN (insn) != NULL)\n+\t  {\n+\t    error (\"insn %d in header of bb %d has non-NULL basic block\",\n+\t\t   INSN_UID (insn), bb->index);\n+\t    err = 1;\n+\t  }\n+      for (insn = BB_FOOTER (bb); insn; insn = NEXT_INSN (insn))\n+\tif (!BARRIER_P (insn)\n+\t    && BLOCK_FOR_INSN (insn) != NULL)\n+\t  {\n+\t    error (\"insn %d in footer of bb %d has non-NULL basic block\",\n+\t\t   INSN_UID (insn), bb->index);\n+\t    err = 1;\n+\t  }\n+    }\n \n   /* Clean up.  */\n   return err;\n@@ -2372,31 +2370,54 @@ rtl_verify_flow_info_1 (void)\n    cfglayout RTL.\n \n    Currently it does following checks:\n-   - all checks of rtl_verify_flow_info_1\n-   - test head/end pointers\n-   - check that all insns are in the basic blocks\n-     (except the switch handling code, barriers and notes)\n-   - check that all returns are followed by barriers\n-   - check that all fallthru edge points to the adjacent blocks.  */\n+\n+   - overlapping of basic blocks\n+   - insns with wrong BLOCK_FOR_INSN pointers\n+   - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)\n+   - tails of basic blocks (ensure that boundary is necessary)\n+   - scans body of the basic block for JUMP_INSN, CODE_LABEL\n+     and NOTE_INSN_BASIC_BLOCK\n+   - verify that no fall_thru edge crosses hot/cold partition boundaries\n+   - verify that there are no pending RTL branch predictions\n+   - verify that there is a single hot/cold partition boundary after bbro\n+\n+   In future it can be extended check a lot of other stuff as well\n+   (reachability of basic blocks, life information, etc. etc.).  */\n \n static int\n-rtl_verify_flow_info (void)\n+rtl_verify_flow_info_1 (void)\n+{\n+  int err = 0;\n+\n+  err |= rtl_verify_bb_pointers ();\n+\n+  err |= rtl_verify_bb_insns ();\n+\n+  err |= rtl_verify_edges ();\n+\n+  err |= verify_hot_cold_block_grouping();\n+\n+  return err;\n+}\n+\n+/* Walk the instruction chain and verify that bb head/end pointers\n+  are correct, and that instructions are in exactly one bb and have\n+  correct block pointers.  */\n+\n+static int\n+rtl_verify_bb_insn_chain (void)\n {\n   basic_block bb;\n-  int err = rtl_verify_flow_info_1 ();\n+  int err = 0;\n   rtx x;\n   rtx last_head = get_last_insn ();\n   basic_block *bb_info;\n-  int num_bb_notes;\n-  const rtx rtx_first = get_insns ();\n-  basic_block last_bb_seen = ENTRY_BLOCK_PTR, curr_bb = NULL;\n   const int max_uid = get_max_uid ();\n \n   bb_info = XCNEWVEC (basic_block, max_uid);\n \n   FOR_EACH_BB_REVERSE (bb)\n     {\n-      edge e;\n       rtx head = BB_HEAD (bb);\n       rtx end = BB_END (bb);\n \n@@ -2406,14 +2427,14 @@ rtl_verify_flow_info (void)\n \t  if (x == end)\n \t    break;\n \n-\t  /* And that the code outside of basic blocks has NULL bb field.  */\n-\tif (!BARRIER_P (x)\n-\t    && BLOCK_FOR_INSN (x) != NULL)\n-\t  {\n-\t    error (\"insn %d outside of basic blocks has non-NULL bb field\",\n-\t\t   INSN_UID (x));\n-\t    err = 1;\n-\t  }\n+            /* And that the code outside of basic blocks has NULL bb field.  */\n+          if (!BARRIER_P (x)\n+              && BLOCK_FOR_INSN (x) != NULL)\n+            {\n+              error (\"insn %d outside of basic blocks has non-NULL bb field\",\n+                     INSN_UID (x));\n+              err = 1;\n+            }\n \t}\n \n       if (!x)\n@@ -2449,6 +2470,37 @@ rtl_verify_flow_info (void)\n \t}\n \n       last_head = PREV_INSN (x);\n+    }\n+\n+  for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n+    {\n+      /* Check that the code before the first basic block has NULL\n+\t bb field.  */\n+      if (!BARRIER_P (x)\n+\t  && BLOCK_FOR_INSN (x) != NULL)\n+\t{\n+\t  error (\"insn %d outside of basic blocks has non-NULL bb field\",\n+\t\t INSN_UID (x));\n+\t  err = 1;\n+\t}\n+    }\n+  free (bb_info);\n+\n+  return err;\n+}\n+\n+/* Verify that fallthru edges point to adjacent blocks in layout order and\n+   that barriers exist after non-fallthru blocks.  */\n+\n+static int\n+rtl_verify_fallthru (void)\n+{\n+  basic_block bb;\n+  int err = 0;\n+\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      edge e;\n \n       e = find_fallthru_edge (bb->succs);\n       if (!e)\n@@ -2493,19 +2545,22 @@ rtl_verify_flow_info (void)\n \t}\n     }\n \n-  for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n-    {\n-      /* Check that the code before the first basic block has NULL\n-\t bb field.  */\n-      if (!BARRIER_P (x)\n-\t  && BLOCK_FOR_INSN (x) != NULL)\n-\t{\n-\t  error (\"insn %d outside of basic blocks has non-NULL bb field\",\n-\t\t INSN_UID (x));\n-\t  err = 1;\n-\t}\n-    }\n-  free (bb_info);\n+   return err;\n+}\n+\n+/* Verify that blocks are laid out in consecutive order. While walking the\n+   instructions, verify that all expected instructions are inside the basic\n+   blocks, and that all returns are followed by barriers.  */\n+\n+static int\n+rtl_verify_bb_layout (void)\n+{\n+  basic_block bb;\n+  int err = 0;\n+  rtx x;\n+  int num_bb_notes;\n+  const rtx rtx_first = get_insns ();\n+  basic_block last_bb_seen = ENTRY_BLOCK_PTR, curr_bb = NULL;\n \n   num_bb_notes = 0;\n   last_bb_seen = ENTRY_BLOCK_PTR;\n@@ -2549,6 +2604,7 @@ rtl_verify_flow_info (void)\n \t  && returnjump_p (x) && ! condjump_p (x)\n \t  && ! (next_nonnote_insn (x) && BARRIER_P (next_nonnote_insn (x))))\n \t    fatal_insn (\"return not followed by barrier\", x);\n+\n       if (curr_bb && x == BB_END (curr_bb))\n \tcurr_bb = NULL;\n     }\n@@ -2560,6 +2616,34 @@ rtl_verify_flow_info (void)\n \n    return err;\n }\n+\n+/* Verify the CFG and RTL consistency common for both underlying RTL and\n+   cfglayout RTL, plus consistency checks specific to linearized RTL mode.\n+\n+   Currently it does following checks:\n+   - all checks of rtl_verify_flow_info_1\n+   - test head/end pointers\n+   - check that blocks are laid out in consecutive order\n+   - check that all insns are in the basic blocks\n+     (except the switch handling code, barriers and notes)\n+   - check that all returns are followed by barriers\n+   - check that all fallthru edge points to the adjacent blocks.  */\n+\n+static int\n+rtl_verify_flow_info (void)\n+{\n+  int err = 0;\n+\n+  err |= rtl_verify_flow_info_1 ();\n+\n+  err |= rtl_verify_bb_insn_chain ();\n+\n+  err |= rtl_verify_fallthru ();\n+\n+  err |= rtl_verify_bb_layout ();\n+\n+  return err;\n+}\n \f\n /* Assume that the preceding pass has possibly eliminated jump instructions\n    or converted the unconditional jumps.  Eliminate the edges from CFG."}]}