{"sha": "e285df089bcad4a781df123e7d85c351710a73c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4NWRmMDg5YmNhZDRhNzgxZGYxMjNlN2Q4NWMzNTE3MTBhNzNjNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-12T12:45:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-12T12:45:26Z"}, "message": "df-core.c (df_clear_bb_info): New function.\n\n\t* df-core.c (df_clear_bb_info): New function.\n\t(df_set_blocks): bb_info is always allocated.\n\t(df_get_bb_info): Use block_info_elt_size.\n\t(df_set_bb_info): Likewise.\n\t(df_compact_blocks): Update for new block_info.\n\t(grow_bb_info): New function.\n\t* df-problems.c (df_grow_bb_info): Move to df-core.c\n\t(df_rd_set_bb_info): Remove.\n\t(df_rd_free_bb_info): Do not free block pool.\n\t(df_rd_alloc): Do not create pool, use check for\n\tobstack presence instead of NULL pointer for new blocks.\n\t(df_rd_free): DO not free alloc pool; clear block_info.\n\t(problem_RD): Add size of block info structure.\n\t(df_lr_set_bb_info): Remove.\n\t(df_lr_free_bb_info): Do not free block pool.\n\t(df_lr_alloc): Do not create pool, use check for\n\tobstack presence instead of NULL pointer for new blocks.\n\t(df_lr_free): DO not free alloc pool; clear block_info.\n\t(problem_LR): Add size of block info structure.\n\t(df_live_set_bb_info): Remove.\n\t(df_live_free_bb_info): Do not free block pool.\n\t(df_live_alloc): Do not create pool, use check for\n\tobstack presence instead of NULL pointer for new blocks.\n\t(df_live_free): DO not free alloc pool; clear block_info.\n\t(problem_LIVE): Add size of block info structure.\n\t(problem_CHAIN): Add size of block info structure.\n\t(df_byte_lr_set_bb_info): Remove.\n\t(df_byte_lr_free_bb_info): Do not free block pool.\n\t(df_byte_lr_alloc): Do not create pool, use check for\n\tobstack presence instead of NULL pointer for new blocks.\n\t(df_byte_lr_free): DO not free alloc pool; clear block_info.\n\t(problem_BYTE_LR): Add size of block info structure.\n\t(problem_NOTE): Add size of block info structure.\n\t(df_byte_MD_set_bb_info): Remove.\n\t(df_byte_MD_free_bb_info): Do not free block pool.\n\t(df_byte_MD_alloc): Do not create pool, use check for\n\tobstack presence instead of NULL pointer for new blocks.\n\t(df_byte_MD_free): DO not free alloc pool; clear block_info.\n\t(problem_BD): Add size of block info structure.\n\t* df-scan.c (df_scan_free_internal): Free block pool.\n\t(df_scan_set_bb_info): Remove.\n\t(df_scan_free_bb_info): Check for artificial_defs instead\n\tof bb_info being non-NULL.\n\t(df_scan_alloc): DO not create df_scan_block pool.\n\t(problem_SCAN): Set size of block info.\n\t(df_bb_refs_record): Do not allocate bb_info.\n\t* df.h (df_problem): Add block_info_elt_size.\n\t(struct dataflow): Change block_info to void *.\n\t(df_scan_get_bb_info, df_rd_get_bb_info, df_lr_get_bb_info,\n\tdf_md_get_bb_info, df_live_get_bb_info, df_byte_lr_get_bb_info): Return\n\tin-line structures.\n\nFrom-SVN: r160660", "tree": {"sha": "8174ebfcbd7b40190073b7254d5a66e0387c7b54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8174ebfcbd7b40190073b7254d5a66e0387c7b54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e285df089bcad4a781df123e7d85c351710a73c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e285df089bcad4a781df123e7d85c351710a73c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e285df089bcad4a781df123e7d85c351710a73c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e285df089bcad4a781df123e7d85c351710a73c5/comments", "author": null, "committer": null, "parents": [{"sha": "02d635a2f81e72f3ce3302abd54a2daf7941ae24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d635a2f81e72f3ce3302abd54a2daf7941ae24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02d635a2f81e72f3ce3302abd54a2daf7941ae24"}], "stats": {"total": 355, "additions": 159, "deletions": 196}, "files": [{"sha": "5557e3b12dffd8576424ff8d0876429376258651", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e285df089bcad4a781df123e7d85c351710a73c5", "patch": "@@ -1,3 +1,57 @@\n+2010-06-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* df-core.c (df_clear_bb_info): New function.\n+\t(df_set_blocks): bb_info is always allocated.\n+\t(df_get_bb_info): Use block_info_elt_size.\n+\t(df_set_bb_info): Likewise.\n+\t(df_compact_blocks): Update for new block_info.\n+\t(grow_bb_info): New function.\n+\t* df-problems.c (df_grow_bb_info): Move to df-core.c\n+\t(df_rd_set_bb_info): Remove.\n+\t(df_rd_free_bb_info): Do not free block pool.\n+\t(df_rd_alloc): Do not create pool, use check for\n+\tobstack presence instead of NULL pointer for new blocks.\n+\t(df_rd_free): DO not free alloc pool; clear block_info.\n+\t(problem_RD): Add size of block info structure.\n+\t(df_lr_set_bb_info): Remove.\n+\t(df_lr_free_bb_info): Do not free block pool.\n+\t(df_lr_alloc): Do not create pool, use check for\n+\tobstack presence instead of NULL pointer for new blocks.\n+\t(df_lr_free): DO not free alloc pool; clear block_info.\n+\t(problem_LR): Add size of block info structure.\n+\t(df_live_set_bb_info): Remove.\n+\t(df_live_free_bb_info): Do not free block pool.\n+\t(df_live_alloc): Do not create pool, use check for\n+\tobstack presence instead of NULL pointer for new blocks.\n+\t(df_live_free): DO not free alloc pool; clear block_info.\n+\t(problem_LIVE): Add size of block info structure.\n+\t(problem_CHAIN): Add size of block info structure.\n+\t(df_byte_lr_set_bb_info): Remove.\n+\t(df_byte_lr_free_bb_info): Do not free block pool.\n+\t(df_byte_lr_alloc): Do not create pool, use check for\n+\tobstack presence instead of NULL pointer for new blocks.\n+\t(df_byte_lr_free): DO not free alloc pool; clear block_info.\n+\t(problem_BYTE_LR): Add size of block info structure.\n+\t(problem_NOTE): Add size of block info structure.\n+\t(df_byte_MD_set_bb_info): Remove.\n+\t(df_byte_MD_free_bb_info): Do not free block pool.\n+\t(df_byte_MD_alloc): Do not create pool, use check for\n+\tobstack presence instead of NULL pointer for new blocks.\n+\t(df_byte_MD_free): DO not free alloc pool; clear block_info.\n+\t(problem_BD): Add size of block info structure.\n+\t* df-scan.c (df_scan_free_internal): Free block pool.\n+\t(df_scan_set_bb_info): Remove.\n+\t(df_scan_free_bb_info): Check for artificial_defs instead\n+\tof bb_info being non-NULL.\n+\t(df_scan_alloc): DO not create df_scan_block pool.\n+\t(problem_SCAN): Set size of block info.\n+\t(df_bb_refs_record): Do not allocate bb_info.\n+\t* df.h (df_problem): Add block_info_elt_size.\n+\t(struct dataflow): Change block_info to void *.\n+\t(df_scan_get_bb_info, df_rd_get_bb_info, df_lr_get_bb_info,\n+\tdf_md_get_bb_info, df_live_get_bb_info, df_byte_lr_get_bb_info): Return\n+\tin-line structures.\n+\n 2010-06-12  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimize/44485"}, {"sha": "ec1641cada3ec77492557600dc21778cd1eec8c9", "filename": "gcc/df-core.c", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=e285df089bcad4a781df123e7d85c351710a73c5", "patch": "@@ -399,6 +399,7 @@ are write-only operations.\n \n static void *df_get_bb_info (struct dataflow *, unsigned int);\n static void df_set_bb_info (struct dataflow *, unsigned int, void *);\n+static void df_clear_bb_info (struct dataflow *, unsigned int);\n #ifdef DF_DEBUG_CFG\n static void df_set_clean_cfg (void);\n #endif\n@@ -523,11 +524,8 @@ df_set_blocks (bitmap blocks)\n \t\t      if (bb)\n \t\t\t{\n \t\t\t  void *bb_info = df_get_bb_info (dflow, bb_index);\n-\t\t\t  if (bb_info)\n-\t\t\t    {\n-\t\t\t      dflow->problem->free_bb_fun (bb, bb_info);\n-\t\t\t      df_set_bb_info (dflow, bb_index, NULL);\n-\t\t\t    }\n+\t\t\t  dflow->problem->free_bb_fun (bb, bb_info);\n+\t\t\t  df_clear_bb_info (dflow, bb_index);\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -1294,7 +1292,8 @@ df_get_bb_info (struct dataflow *dflow, unsigned int index)\n     return NULL;\n   if (index >= dflow->block_info_size)\n     return NULL;\n-  return (struct df_scan_bb_info *) dflow->block_info[index];\n+  return (void *)((char *)dflow->block_info\n+\t\t  + index * dflow->problem->block_info_elt_size);\n }\n \n \n@@ -1305,7 +1304,22 @@ df_set_bb_info (struct dataflow *dflow, unsigned int index,\n \t\tvoid *bb_info)\n {\n   gcc_assert (dflow->block_info);\n-  dflow->block_info[index] = bb_info;\n+  memcpy ((char *)dflow->block_info\n+\t  + index * dflow->problem->block_info_elt_size,\n+\t  bb_info, dflow->problem->block_info_elt_size);\n+}\n+\n+\n+/* Clear basic block info.  */\n+\n+static void\n+df_clear_bb_info (struct dataflow *dflow, unsigned int index)\n+{\n+  gcc_assert (dflow->block_info);\n+  gcc_assert (dflow->block_info_size > index);\n+  memset ((char *)dflow->block_info\n+\t  + index * dflow->problem->block_info_elt_size,\n+\t  0, dflow->problem->block_info_elt_size);\n }\n \n \n@@ -1378,6 +1392,29 @@ df_set_bb_dirty_nonlr (basic_block bb)\n     }\n }\n \n+/* Grow the bb_info array.  */\n+\n+void\n+df_grow_bb_info (struct dataflow *dflow)\n+{\n+  unsigned int new_size = last_basic_block + 1;\n+  if (dflow->block_info_size < new_size)\n+    {\n+      new_size += new_size / 4;\n+      dflow->block_info\n+         = (void *)XRESIZEVEC (char, (char *)dflow->block_info,\n+\t\t\t       new_size\n+\t\t\t       * dflow->problem->block_info_elt_size);\n+      memset ((char *)dflow->block_info\n+\t      + dflow->block_info_size\n+\t      * dflow->problem->block_info_elt_size,\n+\t      0,\n+\t      (new_size - dflow->block_info_size)\n+\t      * dflow->problem->block_info_elt_size);\n+      dflow->block_info_size = new_size;\n+    }\n+}\n+\n \n /* Clear the dirty bits.  This is called from places that delete\n    blocks.  */\n@@ -1392,6 +1429,7 @@ df_clear_bb_dirty (basic_block bb)\n \tbitmap_clear_bit (dflow->out_of_date_transfer_functions, bb->index);\n     }\n }\n+\n /* Called from the rtl_compact_blocks to reorganize the problems basic\n    block info.  */\n \n@@ -1400,10 +1438,8 @@ df_compact_blocks (void)\n {\n   int i, p;\n   basic_block bb;\n-  void **problem_temps;\n-  int size = last_basic_block * sizeof (void *);\n+  void *problem_temps;\n   bitmap_head tmp;\n-  problem_temps = XNEWVAR (void *, size);\n \n   bitmap_initialize (&tmp, &df_bitmap_obstack);\n   for (p = 0; p < df->num_problems_defined; p++)\n@@ -1433,6 +1469,8 @@ df_compact_blocks (void)\n       /* Now shuffle the block info for the problem.  */\n       if (dflow->problem->free_bb_fun)\n \t{\n+\t  int size = last_basic_block * dflow->problem->block_info_elt_size;\n+\t  problem_temps = XNEWVAR (char, size);\n \t  df_grow_bb_info (dflow);\n \t  memcpy (problem_temps, dflow->block_info, size);\n \n@@ -1442,22 +1480,15 @@ df_compact_blocks (void)\n \t  i = NUM_FIXED_BLOCKS;\n \t  FOR_EACH_BB (bb)\n \t    {\n-\t      df_set_bb_info (dflow, i, problem_temps[bb->index]);\n-\t      problem_temps[bb->index] = NULL;\n+\t      df_set_bb_info (dflow, i,\n+\t\t\t      (char *)problem_temps\n+\t\t\t      + bb->index * dflow->problem->block_info_elt_size);\n \t      i++;\n \t    }\n-\t  memset (dflow->block_info + i, 0,\n-\t\t  (last_basic_block - i) *sizeof (void *));\n-\n-\t  /* Free any block infos that were not copied (and NULLed).\n-\t     These are from orphaned blocks.  */\n-\t  for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n-\t    {\n-\t      basic_block bb = BASIC_BLOCK (i);\n-\t      if (problem_temps[i] && bb)\n-\t\tdflow->problem->free_bb_fun\n-\t\t  (bb, problem_temps[i]);\n-\t    }\n+\t  memset ((char *)dflow->block_info\n+\t\t  + i * dflow->problem->block_info_elt_size, 0,\n+\t\t  (last_basic_block - i)\n+\t\t  * dflow->problem->block_info_elt_size);\n \t}\n     }\n \n@@ -1482,8 +1513,6 @@ df_compact_blocks (void)\n \n   bitmap_clear (&tmp);\n \n-  free (problem_temps);\n-\n   i = NUM_FIXED_BLOCKS;\n   FOR_EACH_BB (bb)\n     {\n@@ -1525,7 +1554,6 @@ df_bb_replace (int old_index, basic_block new_block)\n       if (dflow->block_info)\n \t{\n \t  df_grow_bb_info (dflow);\n-\t  gcc_assert (df_get_bb_info (dflow, old_index) == NULL);\n \t  df_set_bb_info (dflow, old_index,\n \t\t\t  df_get_bb_info (dflow, new_block_index));\n \t}\n@@ -1561,7 +1589,7 @@ df_bb_delete (int bb_index)\n \t  if (bb_info)\n \t    {\n \t      dflow->problem->free_bb_fun (bb, bb_info);\n-\t      df_set_bb_info (dflow, bb_index, NULL);\n+\t      df_clear_bb_info (dflow, bb_index);\n \t    }\n \t}\n     }"}, {"sha": "f9d5f6bd8488165fa16c816e8d8170687359cd6f", "filename": "gcc/df-problems.c", "status": "modified", "additions": 27, "deletions": 119, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=e285df089bcad4a781df123e7d85c351710a73c5", "patch": "@@ -100,22 +100,6 @@ df_get_live_in (basic_block bb)\n /* Generic versions to get the void* version of the block info.  Only\n    used inside the problem instance vectors.  */\n \n-/* Grow the bb_info array.  */\n-\n-void\n-df_grow_bb_info (struct dataflow *dflow)\n-{\n-  unsigned int new_size = last_basic_block + 1;\n-  if (dflow->block_info_size < new_size)\n-    {\n-      new_size += new_size / 4;\n-      dflow->block_info = XRESIZEVEC (void *, dflow->block_info, new_size);\n-      memset (dflow->block_info + dflow->block_info_size, 0,\n-\t      (new_size - dflow->block_info_size) *sizeof (void *));\n-      dflow->block_info_size = new_size;\n-    }\n-}\n-\n /* Dump a def-use or use-def chain for REF to FILE.  */\n \n void\n@@ -202,17 +186,6 @@ struct df_rd_problem_data\n   bitmap_obstack rd_bitmaps;\n };\n \n-/* Set basic block info.  */\n-\n-static void\n-df_rd_set_bb_info (unsigned int index,\n-\t\t   struct df_rd_bb_info *bb_info)\n-{\n-  gcc_assert (df_rd);\n-  gcc_assert (index < df_rd->block_info_size);\n-  df_rd->block_info[index] = bb_info;\n-}\n-\n \n /* Free basic block info.  */\n \n@@ -228,7 +201,6 @@ df_rd_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n       bitmap_clear (&bb_info->gen);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n-      pool_free (df_rd->block_pool, bb_info);\n     }\n }\n \n@@ -243,10 +215,6 @@ df_rd_alloc (bitmap all_blocks)\n   bitmap_iterator bi;\n   struct df_rd_problem_data *problem_data;\n \n-  if (!df_rd->block_pool)\n-    df_rd->block_pool = create_alloc_pool (\"df_rd_block pool\",\n-\t\t\t\t\t   sizeof (struct df_rd_bb_info), 50);\n-\n   if (df_rd->problem_data)\n     {\n       problem_data = (struct df_rd_problem_data *) df_rd->problem_data;\n@@ -274,16 +242,16 @@ df_rd_alloc (bitmap all_blocks)\n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n-      if (bb_info)\n+      \n+      /* When bitmaps are already initialized, just clear them.  */\n+      if (bb_info->kill.obstack)\n \t{\n \t  bitmap_clear (&bb_info->kill);\n \t  bitmap_clear (&bb_info->sparse_kill);\n \t  bitmap_clear (&bb_info->gen);\n \t}\n       else\n \t{\n-\t  bb_info = (struct df_rd_bb_info *) pool_alloc (df_rd->block_pool);\n-\t  df_rd_set_bb_info (bb_index, bb_info);\n \t  bitmap_initialize (&bb_info->kill, &problem_data->rd_bitmaps);\n \t  bitmap_initialize (&bb_info->sparse_kill, &problem_data->rd_bitmaps);\n \t  bitmap_initialize (&bb_info->gen, &problem_data->rd_bitmaps);\n@@ -607,11 +575,11 @@ df_rd_free (void)\n \n   if (problem_data)\n     {\n-      free_alloc_pool (df_rd->block_pool);\n       bitmap_obstack_release (&problem_data->rd_bitmaps);\n \n       df_rd->block_info_size = 0;\n       free (df_rd->block_info);\n+      df_rd->block_info = NULL;\n       free (df_rd->problem_data);\n     }\n   free (df_rd);\n@@ -703,6 +671,7 @@ static struct df_problem problem_RD =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n+  sizeof (struct df_rd_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_RD,                   /* Timing variable.  */\n   true                        /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -738,19 +707,6 @@ struct df_lr_problem_data\n   bitmap_obstack lr_bitmaps;\n };\n \n-\n-/* Set basic block info.  */\n-\n-static void\n-df_lr_set_bb_info (unsigned int index,\n-\t\t   struct df_lr_bb_info *bb_info)\n-{\n-  gcc_assert (df_lr);\n-  gcc_assert (index < df_lr->block_info_size);\n-  df_lr->block_info[index] = bb_info;\n-}\n-\n-\n /* Free basic block info.  */\n \n static void\n@@ -764,7 +720,6 @@ df_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n       bitmap_clear (&bb_info->def);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n-      pool_free (df_lr->block_pool, bb_info);\n     }\n }\n \n@@ -779,10 +734,6 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   bitmap_iterator bi;\n   struct df_lr_problem_data *problem_data;\n \n-  if (!df_lr->block_pool)\n-    df_lr->block_pool = create_alloc_pool (\"df_lr_block pool\",\n-\t\t\t\t\t   sizeof (struct df_lr_bb_info), 50);\n-\n   df_grow_bb_info (df_lr);\n   if (df_lr->problem_data)\n     problem_data = (struct df_lr_problem_data *) df_lr->problem_data;\n@@ -799,15 +750,15 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   EXECUTE_IF_SET_IN_BITMAP (df_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n       struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n-      if (bb_info)\n+      \n+      /* When bitmaps are already initialized, just clear them.  */\n+      if (bb_info->use.obstack)\n \t{\n \t  bitmap_clear (&bb_info->def);\n \t  bitmap_clear (&bb_info->use);\n \t}\n       else\n \t{\n-\t  bb_info = (struct df_lr_bb_info *) pool_alloc (df_lr->block_pool);\n-\t  df_lr_set_bb_info (bb_index, bb_info);\n \t  bitmap_initialize (&bb_info->use, &problem_data->lr_bitmaps);\n \t  bitmap_initialize (&bb_info->def, &problem_data->lr_bitmaps);\n \t  bitmap_initialize (&bb_info->in, &problem_data->lr_bitmaps);\n@@ -1091,10 +1042,10 @@ df_lr_free (void)\n     = (struct df_lr_problem_data *) df_lr->problem_data;\n   if (df_lr->block_info)\n     {\n-      free_alloc_pool (df_lr->block_pool);\n \n       df_lr->block_info_size = 0;\n       free (df_lr->block_info);\n+      df_lr->block_info = NULL;\n       bitmap_obstack_release (&problem_data->lr_bitmaps);\n       free (df_lr->problem_data);\n       df_lr->problem_data = NULL;\n@@ -1253,6 +1204,7 @@ static struct df_problem problem_LR =\n   df_lr_verify_solution_start,/* Incremental solution verify start.  */\n   df_lr_verify_solution_end,  /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n+  sizeof (struct df_lr_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_LR,                   /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -1370,17 +1322,6 @@ struct df_live_problem_data\n    combined lr and live analysis.  */\n static bitmap_head df_live_scratch;\n \n-/* Set basic block info.  */\n-\n-static void\n-df_live_set_bb_info (unsigned int index,\n-\t\t   struct df_live_bb_info *bb_info)\n-{\n-  gcc_assert (df_live);\n-  gcc_assert (index < df_live->block_info_size);\n-  df_live->block_info[index] = bb_info;\n-}\n-\n \n /* Free basic block info.  */\n \n@@ -1395,7 +1336,6 @@ df_live_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n       bitmap_clear (&bb_info->kill);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n-      pool_free (df_live->block_pool, bb_info);\n     }\n }\n \n@@ -1410,9 +1350,6 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   bitmap_iterator bi;\n   struct df_live_problem_data *problem_data;\n \n-  if (!df_live->block_pool)\n-    df_live->block_pool = create_alloc_pool (\"df_live_block pool\",\n-\t\t\t\t\t   sizeof (struct df_live_bb_info), 100);\n   if (df_live->problem_data)\n     problem_data = (struct df_live_problem_data *) df_live->problem_data;\n   else\n@@ -1431,15 +1368,15 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   EXECUTE_IF_SET_IN_BITMAP (df_live->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n       struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n-      if (bb_info)\n+      \n+      /* When bitmaps are already initialized, just clear them.  */\n+      if (bb_info->kill.obstack)\n \t{\n \t  bitmap_clear (&bb_info->kill);\n \t  bitmap_clear (&bb_info->gen);\n \t}\n       else\n \t{\n-\t  bb_info = (struct df_live_bb_info *) pool_alloc (df_live->block_pool);\n-\t  df_live_set_bb_info (bb_index, bb_info);\n \t  bitmap_initialize (&bb_info->kill, &problem_data->live_bitmaps);\n \t  bitmap_initialize (&bb_info->gen, &problem_data->live_bitmaps);\n \t  bitmap_initialize (&bb_info->in, &problem_data->live_bitmaps);\n@@ -1639,9 +1576,9 @@ df_live_free (void)\n     = (struct df_live_problem_data *) df_live->problem_data;\n   if (df_live->block_info)\n     {\n-      free_alloc_pool (df_live->block_pool);\n       df_live->block_info_size = 0;\n       free (df_live->block_info);\n+      df_live->block_info = NULL;\n       bitmap_clear (&df_live_scratch);\n       bitmap_obstack_release (&problem_data->live_bitmaps);\n       free (problem_data);\n@@ -1796,6 +1733,7 @@ static struct df_problem problem_LIVE =\n   df_live_verify_solution_start,/* Incremental solution verify start.  */\n   df_live_verify_solution_end,  /* Incremental solution verify end.  */\n   &problem_LR,                  /* Dependent problem.  */\n+  sizeof (struct df_live_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_LIVE,                   /* Timing variable.  */\n   false                         /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -2322,6 +2260,7 @@ static struct df_problem problem_CHAIN =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   &problem_RD,                /* Dependent problem.  */\n+  sizeof (struct df_scan_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_CHAIN,                /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -2414,18 +2353,6 @@ df_byte_lr_get_regno_len (unsigned int regno)\n }\n \n \n-/* Set basic block info.  */\n-\n-static void\n-df_byte_lr_set_bb_info (unsigned int index,\n-\t\t\tstruct df_byte_lr_bb_info *bb_info)\n-{\n-  gcc_assert (df_byte_lr);\n-  gcc_assert (index < df_byte_lr->block_info_size);\n-  df_byte_lr->block_info[index] = bb_info;\n-}\n-\n-\n /* Free basic block info.  */\n \n static void\n@@ -2439,7 +2366,6 @@ df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n       bitmap_clear (&bb_info->def);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n-      pool_free (df_byte_lr->block_pool, bb_info);\n     }\n }\n \n@@ -2502,10 +2428,6 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n   df_byte_lr->problem_data = problem_data;\n \n-  if (!df_byte_lr->block_pool)\n-    df_byte_lr->block_pool = create_alloc_pool (\"df_byte_lr_block pool\",\n-\t\t\t\t\t   sizeof (struct df_byte_lr_bb_info), 50);\n-\n   df_grow_bb_info (df_byte_lr);\n \n   /* Create the mapping from regnos to slots. This does not change\n@@ -2566,15 +2488,15 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   EXECUTE_IF_SET_IN_BITMAP (df_byte_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n       struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n-      if (bb_info)\n+      \n+      /* When bitmaps are already initialized, just clear them.  */\n+      if (bb_info->use.obstack)\n \t{\n \t  bitmap_clear (&bb_info->def);\n \t  bitmap_clear (&bb_info->use);\n \t}\n       else\n \t{\n-\t  bb_info = (struct df_byte_lr_bb_info *) pool_alloc (df_byte_lr->block_pool);\n-\t  df_byte_lr_set_bb_info (bb_index, bb_info);\n \t  bitmap_initialize (&bb_info->use, &problem_data->byte_lr_bitmaps);\n \t  bitmap_initialize (&bb_info->def, &problem_data->byte_lr_bitmaps);\n \t  bitmap_initialize (&bb_info->in, &problem_data->byte_lr_bitmaps);\n@@ -2834,9 +2756,9 @@ df_byte_lr_free (void)\n \n   if (df_byte_lr->block_info)\n     {\n-      free_alloc_pool (df_byte_lr->block_pool);\n       df_byte_lr->block_info_size = 0;\n       free (df_byte_lr->block_info);\n+      df_byte_lr->block_info = NULL;\n     }\n \n   BITMAP_FREE (df_byte_lr->out_of_date_transfer_functions);\n@@ -2903,7 +2825,8 @@ static struct df_problem problem_BYTE_LR =\n   df_byte_lr_bottom_dump,          /* Debugging end block.  */\n   NULL,                            /* Incremental solution verify start.  */\n   NULL,                            /* Incremental solution verify end.  */\n-  NULL,                            /* Dependent problem.  */\n+  NULL,                       /* Dependent problem.  */\n+  sizeof (struct df_byte_lr_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_BYTE_LR,                   /* Timing variable.  */\n   false                            /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -3874,6 +3797,7 @@ static struct df_problem problem_NOTE =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   &problem_LR,                /* Dependent problem.  */\n+  sizeof (struct df_scan_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_NOTE,                 /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -4213,17 +4137,6 @@ struct df_md_problem_data\n    only for live registers.  */\n static bitmap_head df_md_scratch;\n \n-/* Set basic block info.  */\n-\n-static void\n-df_md_set_bb_info (unsigned int index,\n-                   struct df_md_bb_info *bb_info)\n-{\n-  gcc_assert (df_md);\n-  gcc_assert (index < df_md->block_info_size);\n-  df_md->block_info[index] = bb_info;\n-}\n-\n \n static void\n df_md_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n@@ -4237,7 +4150,6 @@ df_md_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n       bitmap_clear (&bb_info->init);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n-      pool_free (df_md->block_pool, bb_info);\n     }\n }\n \n@@ -4252,10 +4164,6 @@ df_md_alloc (bitmap all_blocks)\n   bitmap_iterator bi;\n   struct df_md_problem_data *problem_data;\n \n-  if (!df_md->block_pool)\n-    df_md->block_pool = create_alloc_pool (\"df_md_block pool\",\n-                                           sizeof (struct df_md_bb_info), 50);\n-\n   df_grow_bb_info (df_md);\n   if (df_md->problem_data)\n     problem_data = (struct df_md_problem_data *) df_md->problem_data;\n@@ -4270,7 +4178,8 @@ df_md_alloc (bitmap all_blocks)\n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n-      if (bb_info)\n+      /* When bitmaps are already initialized, just clear them.  */\n+      if (bb_info->init.obstack)\n         {\n           bitmap_clear (&bb_info->init);\n           bitmap_clear (&bb_info->gen);\n@@ -4280,8 +4189,6 @@ df_md_alloc (bitmap all_blocks)\n         }\n       else\n         {\n-          bb_info = (struct df_md_bb_info *) pool_alloc (df_md->block_pool);\n-          df_md_set_bb_info (bb_index, bb_info);\n \t  bitmap_initialize (&bb_info->init, &problem_data->md_bitmaps);\n \t  bitmap_initialize (&bb_info->gen, &problem_data->md_bitmaps);\n \t  bitmap_initialize (&bb_info->kill, &problem_data->md_bitmaps);\n@@ -4543,12 +4450,12 @@ df_md_free (void)\n     = (struct df_md_problem_data *) df_md->problem_data;\n \n   bitmap_obstack_release (&problem_data->md_bitmaps);\n-  free_alloc_pool (df_md->block_pool);\n   free (problem_data);\n   df_md->problem_data = NULL;\n \n   df_md->block_info_size = 0;\n   free (df_md->block_info);\n+  df_md->block_info = NULL;\n   free (df_md);\n }\n \n@@ -4607,6 +4514,7 @@ static struct df_problem problem_MD =\n   NULL,\t\t\t      /* Incremental solution verify start.  */\n   NULL,\t\t\t      /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n+  sizeof (struct df_md_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_MD,                   /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };"}, {"sha": "902afdae4979984df112369c1e2f2a04e92259cf", "filename": "gcc/df-scan.c", "status": "modified", "additions": 14, "deletions": 42, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=e285df089bcad4a781df123e7d85c351710a73c5", "patch": "@@ -266,7 +266,6 @@ df_scan_free_internal (void)\n   bitmap_clear (&df->insns_to_rescan);\n   bitmap_clear (&df->insns_to_notes_rescan);\n \n-  free_alloc_pool (df_scan->block_pool);\n   free_alloc_pool (problem_data->ref_base_pool);\n   free_alloc_pool (problem_data->ref_artificial_pool);\n   free_alloc_pool (problem_data->ref_regular_pool);\n@@ -280,25 +279,16 @@ df_scan_free_internal (void)\n }\n \n \n-/* Set basic block info.  */\n-\n-static void\n-df_scan_set_bb_info (unsigned int index,\n-\t\t     struct df_scan_bb_info *bb_info)\n-{\n-  df_grow_bb_info (df_scan);\n-  df_scan->block_info[index] = (void *) bb_info;\n-}\n-\n-\n /* Free basic block info.  */\n \n static void\n df_scan_free_bb_info (basic_block bb, void *vbb_info)\n {\n   struct df_scan_bb_info *bb_info = (struct df_scan_bb_info *) vbb_info;\n   unsigned int bb_index = bb->index;\n-  if (bb_info)\n+\n+  /* See if bb_info is initialized.  */\n+  if (bb_info->artificial_defs)\n     {\n       rtx insn;\n       FOR_BB_INSNS (bb, insn)\n@@ -312,13 +302,15 @@ df_scan_free_bb_info (basic_block bb, void *vbb_info)\n \tbb_info = df_scan_get_bb_info (bb_index);\n \n       /* Get rid of any artificial uses or defs.  */\n-      df_ref_chain_delete_du_chain (bb_info->artificial_defs);\n-      df_ref_chain_delete_du_chain (bb_info->artificial_uses);\n-      df_ref_chain_delete (bb_info->artificial_defs);\n-      df_ref_chain_delete (bb_info->artificial_uses);\n-      bb_info->artificial_defs = NULL;\n-      bb_info->artificial_uses = NULL;\n-      pool_free (df_scan->block_pool, bb_info);\n+      if (bb_info->artificial_defs)\n+\t{\n+\t  df_ref_chain_delete_du_chain (bb_info->artificial_defs);\n+\t  df_ref_chain_delete_du_chain (bb_info->artificial_uses);\n+\t  df_ref_chain_delete (bb_info->artificial_defs);\n+\t  df_ref_chain_delete (bb_info->artificial_uses);\n+\t  bb_info->artificial_defs = NULL;\n+\t  bb_info->artificial_uses = NULL;\n+\t}\n     }\n }\n \n@@ -339,11 +331,6 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   if (df_scan->problem_data)\n     df_scan_free_internal ();\n \n-  df_scan->block_pool\n-    = create_alloc_pool (\"df_scan_block pool\",\n-\t\t\t sizeof (struct df_scan_bb_info),\n-\t\t\t block_size);\n-\n   problem_data = XNEW (struct df_scan_problem_data);\n   df_scan->problem_data = problem_data;\n   df_scan->computed = true;\n@@ -383,11 +370,6 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n     {\n       unsigned int bb_index = bb->index;\n       struct df_scan_bb_info *bb_info = df_scan_get_bb_info (bb_index);\n-      if (!bb_info)\n-\t{\n-\t  bb_info = (struct df_scan_bb_info *) pool_alloc (df_scan->block_pool);\n-\t  df_scan_set_bb_info (bb_index, bb_info);\n-\t}\n       bb_info->artificial_defs = NULL;\n       bb_info->artificial_uses = NULL;\n     }\n@@ -539,6 +521,7 @@ static struct df_problem problem_SCAN =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n+  sizeof (struct df_scan_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_SCAN,                 /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -3698,23 +3681,12 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n   basic_block bb = BASIC_BLOCK (bb_index);\n   rtx insn;\n   int luid = 0;\n-  struct df_scan_bb_info *bb_info;\n   struct df_collection_rec collection_rec;\n \n   if (!df)\n     return;\n \n-  bb_info = df_scan_get_bb_info (bb_index);\n-\n-  /* Need to make sure that there is a record in the basic block info. */\n-  if (!bb_info)\n-    {\n-      bb_info = (struct df_scan_bb_info *) pool_alloc (df_scan->block_pool);\n-      df_scan_set_bb_info (bb_index, bb_info);\n-      bb_info->artificial_defs = NULL;\n-      bb_info->artificial_uses = NULL;\n-    }\n-\n+  df_grow_bb_info (df_scan);\n   collection_rec.def_vec = VEC_alloc (df_ref, stack, 128);\n   collection_rec.use_vec = VEC_alloc (df_ref, stack, 32);\n   collection_rec.eq_use_vec = VEC_alloc (df_ref, stack, 32);"}, {"sha": "060b52f607665ec9fce7b1651f900247bb7403e2", "filename": "gcc/df.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e285df089bcad4a781df123e7d85c351710a73c5/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=e285df089bcad4a781df123e7d85c351710a73c5", "patch": "@@ -277,6 +277,7 @@ struct df_problem {\n   df_verify_solution_start verify_start_fun;\n   df_verify_solution_end verify_end_fun;\n   struct df_problem *dependent_problem;\n+  unsigned int block_info_elt_size;\n \n   /* The timevar id associated with this pass.  */\n   timevar_id_t tv_id;\n@@ -294,7 +295,7 @@ struct dataflow\n \n   /* Array indexed by bb->index, that contains basic block problem and\n      solution specific information.  */\n-  void **block_info;\n+  void *block_info;\n   unsigned int block_info_size;\n \n   /* The pool to allocate the block_info from. */\n@@ -1037,7 +1038,7 @@ static inline struct df_scan_bb_info *\n df_scan_get_bb_info (unsigned int index)\n {\n   if (index < df_scan->block_info_size)\n-    return (struct df_scan_bb_info *) df_scan->block_info[index];\n+    return &((struct df_scan_bb_info *) df_scan->block_info)[index];\n   else\n     return NULL;\n }\n@@ -1046,7 +1047,7 @@ static inline struct df_rd_bb_info *\n df_rd_get_bb_info (unsigned int index)\n {\n   if (index < df_rd->block_info_size)\n-    return (struct df_rd_bb_info *) df_rd->block_info[index];\n+    return &((struct df_rd_bb_info *) df_rd->block_info)[index];\n   else\n     return NULL;\n }\n@@ -1055,7 +1056,7 @@ static inline struct df_lr_bb_info *\n df_lr_get_bb_info (unsigned int index)\n {\n   if (index < df_lr->block_info_size)\n-    return (struct df_lr_bb_info *) df_lr->block_info[index];\n+    return &((struct df_lr_bb_info *) df_lr->block_info)[index];\n   else\n     return NULL;\n }\n@@ -1064,7 +1065,7 @@ static inline struct df_md_bb_info *\n df_md_get_bb_info (unsigned int index)\n {\n   if (index < df_md->block_info_size)\n-    return (struct df_md_bb_info *) df_md->block_info[index];\n+    return &((struct df_md_bb_info *) df_md->block_info)[index];\n   else\n     return NULL;\n }\n@@ -1073,7 +1074,7 @@ static inline struct df_live_bb_info *\n df_live_get_bb_info (unsigned int index)\n {\n   if (index < df_live->block_info_size)\n-    return (struct df_live_bb_info *) df_live->block_info[index];\n+    return &((struct df_live_bb_info *) df_live->block_info)[index];\n   else\n     return NULL;\n }\n@@ -1082,7 +1083,7 @@ static inline struct df_byte_lr_bb_info *\n df_byte_lr_get_bb_info (unsigned int index)\n {\n   if (index < df_byte_lr->block_info_size)\n-    return (struct df_byte_lr_bb_info *) df_byte_lr->block_info[index];\n+    return &((struct df_byte_lr_bb_info *) df_byte_lr->block_info)[index];\n   else\n     return NULL;\n }"}]}