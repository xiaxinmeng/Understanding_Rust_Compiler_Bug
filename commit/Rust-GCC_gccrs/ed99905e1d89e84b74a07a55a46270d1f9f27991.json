{"sha": "ed99905e1d89e84b74a07a55a46270d1f9f27991", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ5OTkwNWUxZDg5ZTg0Yjc0YTA3YTU1YTQ2MjcwZDFmOWYyNzk5MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-22T14:28:57Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-22T14:28:57Z"}, "message": "runtime: adjust tests for gofrontend\n    \n    - don't run tests that depend on SetCgoTraceback\n    - don't expect a '(' after the function name in a traceback\n    - change the expected name of nested functions in a traceback\n    \n    These tests are not currently run, but they will be soon.\n    \n    Reviewed-on: https://go-review.googlesource.com/46453\n\nFrom-SVN: r249557", "tree": {"sha": "0d1aa2fdcb45caeb36ca00e366f40ccb5d360b24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d1aa2fdcb45caeb36ca00e366f40ccb5d360b24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed99905e1d89e84b74a07a55a46270d1f9f27991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed99905e1d89e84b74a07a55a46270d1f9f27991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed99905e1d89e84b74a07a55a46270d1f9f27991", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed99905e1d89e84b74a07a55a46270d1f9f27991/comments", "author": null, "committer": null, "parents": [{"sha": "2a208bc2570b07b64deb1d549332e5d981c867bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a208bc2570b07b64deb1d549332e5d981c867bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a208bc2570b07b64deb1d549332e5d981c867bc"}], "stats": {"total": 34, "additions": 30, "deletions": 4}, "files": [{"sha": "cb9022431e196ba83df30ac5b76bdf5fb17cf873", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed99905e1d89e84b74a07a55a46270d1f9f27991/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed99905e1d89e84b74a07a55a46270d1f9f27991/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=ed99905e1d89e84b74a07a55a46270d1f9f27991", "patch": "@@ -1,4 +1,4 @@\n-e017833e4ce4a3bc3ba02eac4351b15c86157ec0\n+a81079a81b63714221674f07d13bedc768092f27\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b338df985d334fa2d6eb3928355d3030a1a72196", "filename": "libgo/go/runtime/crash_cgo_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed99905e1d89e84b74a07a55a46270d1f9f27991/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed99905e1d89e84b74a07a55a46270d1f9f27991/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go?ref=ed99905e1d89e84b74a07a55a46270d1f9f27991", "patch": "@@ -251,6 +251,9 @@ func TestCgoCrashTraceback(t *testing.T) {\n \tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n \t\tt.Skipf(\"not yet supported on %s/%s\", runtime.GOOS, runtime.GOARCH)\n \t}\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo does not have SetCgoTraceback\")\n+\t}\n \tgot := runTestProg(t, \"testprogcgo\", \"CrashTraceback\")\n \tfor i := 1; i <= 3; i++ {\n \t\tif !strings.Contains(got, fmt.Sprintf(\"cgo symbolizer:%d\", i)) {\n@@ -261,6 +264,9 @@ func TestCgoCrashTraceback(t *testing.T) {\n \n func TestCgoTracebackContext(t *testing.T) {\n \tt.Parallel()\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo does not have SetCgoTraceback\")\n+\t}\n \tgot := runTestProg(t, \"testprogcgo\", \"TracebackContext\")\n \twant := \"OK\\n\"\n \tif got != want {\n@@ -273,6 +279,9 @@ func testCgoPprof(t *testing.T, buildArg, runArg string) {\n \tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n \t\tt.Skipf(\"not yet supported on %s/%s\", runtime.GOOS, runtime.GOARCH)\n \t}\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo does not have SetCgoTraceback\")\n+\t}\n \ttestenv.MustHaveGoRun(t)\n \n \texe, err := buildTestProg(t, \"testprogcgo\", buildArg)\n@@ -332,6 +341,9 @@ func TestRaceProf(t *testing.T) {\n \tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n \t\tt.Skipf(\"not yet supported on %s/%s\", runtime.GOOS, runtime.GOARCH)\n \t}\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo does not have SetCgoTraceback\")\n+\t}\n \n \ttestenv.MustHaveGoRun(t)\n "}, {"sha": "4ba9d444b9c18e190041ff57268eacd5412d995c", "filename": "libgo/go/runtime/crash_test.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed99905e1d89e84b74a07a55a46270d1f9f27991/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed99905e1d89e84b74a07a55a46270d1f9f27991/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_test.go?ref=ed99905e1d89e84b74a07a55a46270d1f9f27991", "patch": "@@ -225,6 +225,9 @@ func TestGoexitDeadlock(t *testing.T) {\n }\n \n func TestStackOverflow(t *testing.T) {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo does not do stack overflow checking\")\n+\t}\n \toutput := runTestProg(t, \"testprog\", \"StackOverflow\")\n \twant := \"runtime: goroutine stack exceeds 1474560-byte limit\\nfatal error: stack overflow\"\n \tif !strings.HasPrefix(output, want) {\n@@ -302,7 +305,7 @@ func TestNoHelperGoroutines(t *testing.T) {\n \n func TestBreakpoint(t *testing.T) {\n \toutput := runTestProg(t, \"testprog\", \"Breakpoint\")\n-\twant := \"runtime.Breakpoint()\"\n+\twant := \"runtime.Breakpoint\"\n \tif !strings.Contains(output, want) {\n \t\tt.Fatalf(\"output:\\n%s\\n\\nwant output containing: %s\", output, want)\n \t}\n@@ -419,8 +422,16 @@ func TestPanicTraceback(t *testing.T) {\n \n \t// Check functions in the traceback.\n \tfns := []string{\"main.pt1.func1\", \"panic\", \"main.pt2.func1\", \"panic\", \"main.pt2\", \"main.pt1\"}\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tfns = []string{\"main.$nested\", \"panic\", \"main.$nested\", \"panic\", \"main.pt2\", \"main.pt1\"}\n+\t}\n \tfor _, fn := range fns {\n-\t\tre := regexp.MustCompile(`(?m)^` + regexp.QuoteMeta(fn) + `\\(.*\\n`)\n+\t\tvar re *regexp.Regexp\n+\t\tif runtime.Compiler != \"gccgo\" {\n+\t\t\tre = regexp.MustCompile(`(?m)^` + regexp.QuoteMeta(fn) + `\\(.*\\n`)\n+\t\t} else {\n+\t\t\tre = regexp.MustCompile(`(?m)^` + regexp.QuoteMeta(fn) + `.*\\n`)\n+\t\t}\n \t\tidx := re.FindStringIndex(output)\n \t\tif idx == nil {\n \t\t\tt.Fatalf(\"expected %q function in traceback:\\n%s\", fn, output)\n@@ -454,6 +465,9 @@ func TestPanicLoop(t *testing.T) {\n \n func TestMemPprof(t *testing.T) {\n \ttestenv.MustHaveGoRun(t)\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo may not have the pprof tool\")\n+\t}\n \n \texe, err := buildTestProg(t, \"testprog\")\n \tif err != nil {"}, {"sha": "7a29c1eba7945c215d4db5fa16207bfb58be6e7c", "filename": "libgo/go/runtime/crash_unix_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed99905e1d89e84b74a07a55a46270d1f9f27991/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed99905e1d89e84b74a07a55a46270d1f9f27991/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go?ref=ed99905e1d89e84b74a07a55a46270d1f9f27991", "patch": "@@ -105,7 +105,7 @@ func TestCrashDumpsAllThreads(t *testing.T) {\n \t// Before https://golang.org/cl/2811 running threads would say\n \t// \"goroutine running on other thread; stack unavailable\".\n \tout = outbuf.Bytes()\n-\tn := bytes.Count(out, []byte(\"main.loop(\"))\n+\tn := bytes.Count(out, []byte(\"main.loop\"))\n \tif n != 4 {\n \t\tt.Errorf(\"found %d instances of main.loop; expected 4\", n)\n \t\tt.Logf(\"%s\", out)"}]}