{"sha": "c7ad039d8d75666f4f188a913033da36206503b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhZDAzOWQ4ZDc1NjY2ZjRmMTg4YTkxMzAzM2RhMzYyMDY1MDNiOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:13:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:13:29Z"}, "message": "[35/77] Add uses of as_a <scalar_int_mode>\n\nThis patch adds asserting as_a <scalar_int_mode> conversions\nto contexts in which the input is known to be a scalar integer mode.\n\nIn expand_divmod, op1 is always a scalar_int_mode if\nop1_is_constant (but might not be otherwise).\n\nIn expand_binop, the patch reverses a < comparison in order to\navoid splitting a long line.\n\ngcc/\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* cfgexpand.c (convert_debug_memory_address): Use\n\tas_a <scalar_int_mode>.\n\t* combine.c (expand_compound_operation): Likewise.\n\t(make_extraction): Likewise.\n\t(change_zero_ext): Likewise.\n\t(simplify_comparison): Likewise.\n\t* cse.c (cse_insn): Likewise.\n\t* dwarf2out.c (minmax_loc_descriptor): Likewise.\n\t(mem_loc_descriptor): Likewise.\n\t(loc_descriptor): Likewise.\n\t* expmed.c (init_expmed_one_mode): Likewise.\n\t(synth_mult): Likewise.\n\t(emit_store_flag_1): Likewise.\n\t(expand_divmod): Likewise.  Use HWI_COMPUTABLE_MODE_P instead\n\tof a comparison with size.\n\t* expr.c (expand_assignment): Use as_a <scalar_int_mode>.\n\t(reduce_to_bit_field_precision): Likewise.\n\t* function.c (expand_function_end): Likewise.\n\t* internal-fn.c (expand_arith_overflow_result_store): Likewise.\n\t* loop-doloop.c (doloop_modify): Likewise.\n\t* optabs.c (expand_binop): Likewise.\n\t(expand_unop): Likewise.\n\t(expand_copysign_absneg): Likewise.\n\t(prepare_cmp_insn): Likewise.\n\t(maybe_legitimize_operand): Likewise.\n\t* recog.c (const_scalar_int_operand): Likewise.\n\t* rtlanal.c (get_address_mode): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\t(simplify_cond_clz_ctz): Likewise.\n\t* tree-nested.c (get_nl_goto_field): Likewise.\n\t* tree.c (build_vector_type_for_mode): Likewise.\n\t* var-tracking.c (use_narrower_mode): Likewise.\n\ngcc/c-family/\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* c-common.c (c_common_type_for_mode): Use as_a <scalar_int_mode>.\n\ngcc/lto/\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* lto-lang.c (lto_type_for_mode): Use as_a <scalar_int_mode>.\n\nFrom-SVN: r251487", "tree": {"sha": "39a850b1263916714cd0fc62162dc9adaf993d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39a850b1263916714cd0fc62162dc9adaf993d73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7ad039d8d75666f4f188a913033da36206503b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ad039d8d75666f4f188a913033da36206503b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7ad039d8d75666f4f188a913033da36206503b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ad039d8d75666f4f188a913033da36206503b8/comments", "author": null, "committer": null, "parents": [{"sha": "7a504f3390ecfe3457d37b9d716262a14d5d1938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a504f3390ecfe3457d37b9d716262a14d5d1938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a504f3390ecfe3457d37b9d716262a14d5d1938"}], "stats": {"total": 572, "additions": 308, "deletions": 264}, "files": [{"sha": "9754a66c4b9f06cc2b28002a900d6282203f8bb3", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -2242,15 +2242,15 @@ c_common_type_for_mode (machine_mode mode, int unsignedp)\n   if (mode == TYPE_MODE (void_type_node))\n     return void_type_node;\n \n-  if (mode == TYPE_MODE (build_pointer_type (char_type_node)))\n-    return (unsignedp\n-\t    ? make_unsigned_type (GET_MODE_PRECISION (mode))\n-\t    : make_signed_type (GET_MODE_PRECISION (mode)));\n-\n-  if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n-    return (unsignedp\n-\t    ? make_unsigned_type (GET_MODE_PRECISION (mode))\n-\t    : make_signed_type (GET_MODE_PRECISION (mode)));\n+  if (mode == TYPE_MODE (build_pointer_type (char_type_node))\n+      || mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n+    {\n+      unsigned int precision\n+\t= GET_MODE_PRECISION (as_a <scalar_int_mode> (mode));\n+      return (unsignedp\n+\t      ? make_unsigned_type (precision)\n+\t      : make_signed_type (precision));\n+    }\n \n   if (COMPLEX_MODE_P (mode))\n     {"}, {"sha": "34350de2e829a246e72b5f7c21ef1850ad1dae67", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -3965,12 +3965,10 @@ static rtx\n convert_debug_memory_address (machine_mode mode, rtx x,\n \t\t\t      addr_space_t as)\n {\n-  machine_mode xmode = GET_MODE (x);\n-\n #ifndef POINTERS_EXTEND_UNSIGNED\n   gcc_assert (mode == Pmode\n \t      || mode == targetm.addr_space.address_mode (as));\n-  gcc_assert (xmode == mode || xmode == VOIDmode);\n+  gcc_assert (GET_MODE (x) == mode || GET_MODE (x) == VOIDmode);\n #else\n   rtx temp;\n \n@@ -3979,6 +3977,8 @@ convert_debug_memory_address (machine_mode mode, rtx x,\n   if (GET_MODE (x) == mode || GET_MODE (x) == VOIDmode)\n     return x;\n \n+  /* X must have some form of address mode already.  */\n+  scalar_int_mode xmode = as_a <scalar_int_mode> (GET_MODE (x));\n   if (GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (xmode))\n     x = lowpart_subreg (mode, x, xmode);\n   else if (POINTERS_EXTEND_UNSIGNED > 0)"}, {"sha": "930c0e5d277a33561cd5059e4611234e15d66faf", "filename": "gcc/combine.c", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -7143,16 +7143,19 @@ expand_compound_operation (rtx x)\n     default:\n       return x;\n     }\n+\n+  /* We've rejected non-scalar operations by now.  */\n+  scalar_int_mode mode = as_a <scalar_int_mode> (GET_MODE (x));\n+\n   /* Convert sign extension to zero extension, if we know that the high\n      bit is not set, as this is easier to optimize.  It will be converted\n      back to cheaper alternative in make_extraction.  */\n   if (GET_CODE (x) == SIGN_EXTEND\n-      && HWI_COMPUTABLE_MODE_P (GET_MODE (x))\n+      && HWI_COMPUTABLE_MODE_P (mode)\n       && ((nonzero_bits (XEXP (x, 0), inner_mode)\n \t   & ~(((unsigned HOST_WIDE_INT) GET_MODE_MASK (inner_mode)) >> 1))\n \t  == 0))\n     {\n-      machine_mode mode = GET_MODE (x);\n       rtx temp = gen_rtx_ZERO_EXTEND (mode, XEXP (x, 0));\n       rtx temp2 = expand_compound_operation (temp);\n \n@@ -7174,35 +7177,35 @@ expand_compound_operation (rtx x)\n \t know that the last value didn't have any inappropriate bits\n \t set.  */\n       if (GET_CODE (XEXP (x, 0)) == TRUNCATE\n-\t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == GET_MODE (x)\n-\t  && HWI_COMPUTABLE_MODE_P (GET_MODE (x))\n-\t  && (nonzero_bits (XEXP (XEXP (x, 0), 0), GET_MODE (x))\n+\t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == mode\n+\t  && HWI_COMPUTABLE_MODE_P (mode)\n+\t  && (nonzero_bits (XEXP (XEXP (x, 0), 0), mode)\n \t      & ~GET_MODE_MASK (inner_mode)) == 0)\n \treturn XEXP (XEXP (x, 0), 0);\n \n       /* Likewise for (zero_extend:DI (subreg:SI foo:DI 0)).  */\n       if (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t  && GET_MODE (SUBREG_REG (XEXP (x, 0))) == GET_MODE (x)\n+\t  && GET_MODE (SUBREG_REG (XEXP (x, 0))) == mode\n \t  && subreg_lowpart_p (XEXP (x, 0))\n-\t  && HWI_COMPUTABLE_MODE_P (GET_MODE (x))\n-\t  && (nonzero_bits (SUBREG_REG (XEXP (x, 0)), GET_MODE (x))\n+\t  && HWI_COMPUTABLE_MODE_P (mode)\n+\t  && (nonzero_bits (SUBREG_REG (XEXP (x, 0)), mode)\n \t      & ~GET_MODE_MASK (inner_mode)) == 0)\n \treturn SUBREG_REG (XEXP (x, 0));\n \n       /* (zero_extend:DI (truncate:SI foo:DI)) is just foo:DI when foo\n \t is a comparison and STORE_FLAG_VALUE permits.  This is like\n-\t the first case, but it works even when GET_MODE (x) is larger\n+\t the first case, but it works even when MODE is larger\n \t than HOST_WIDE_INT.  */\n       if (GET_CODE (XEXP (x, 0)) == TRUNCATE\n-\t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == GET_MODE (x)\n+\t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == mode\n \t  && COMPARISON_P (XEXP (XEXP (x, 0), 0))\n \t  && GET_MODE_PRECISION (inner_mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (STORE_FLAG_VALUE & ~GET_MODE_MASK (inner_mode)) == 0)\n \treturn XEXP (XEXP (x, 0), 0);\n \n       /* Likewise for (zero_extend:DI (subreg:SI foo:DI 0)).  */\n       if (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t  && GET_MODE (SUBREG_REG (XEXP (x, 0))) == GET_MODE (x)\n+\t  && GET_MODE (SUBREG_REG (XEXP (x, 0))) == mode\n \t  && subreg_lowpart_p (XEXP (x, 0))\n \t  && COMPARISON_P (SUBREG_REG (XEXP (x, 0)))\n \t  && GET_MODE_PRECISION (inner_mode) <= HOST_BITS_PER_WIDE_INT\n@@ -7226,10 +7229,9 @@ expand_compound_operation (rtx x)\n      extraction.  Then the constant of 31 would be substituted in\n      to produce such a position.  */\n \n-  modewidth = GET_MODE_PRECISION (GET_MODE (x));\n+  modewidth = GET_MODE_PRECISION (mode);\n   if (modewidth >= pos + len)\n     {\n-      machine_mode mode = GET_MODE (x);\n       tem = gen_lowpart (mode, XEXP (x, 0));\n       if (!tem || GET_CODE (tem) == CLOBBER)\n \treturn x;\n@@ -7239,10 +7241,10 @@ expand_compound_operation (rtx x)\n \t\t\t\t  mode, tem, modewidth - len);\n     }\n   else if (unsignedp && len < HOST_BITS_PER_WIDE_INT)\n-    tem = simplify_and_const_int (NULL_RTX, GET_MODE (x),\n+    tem = simplify_and_const_int (NULL_RTX, mode,\n \t\t\t\t  simplify_shift_const (NULL_RTX, LSHIFTRT,\n-\t\t\t\t\t\t\tGET_MODE (x),\n-\t\t\t\t\t\t\tXEXP (x, 0), pos),\n+\t\t\t\t\t\t\tmode, XEXP (x, 0),\n+\t\t\t\t\t\t\tpos),\n \t\t\t\t  (HOST_WIDE_INT_1U << len) - 1);\n   else\n     /* Any other cases we can't handle.  */\n@@ -7732,9 +7734,13 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n     }\n \n   /* Adjust mode of POS_RTX, if needed.  If we want a wider mode, we\n-     have to zero extend.  Otherwise, we can just use a SUBREG.  */\n+     have to zero extend.  Otherwise, we can just use a SUBREG.\n+\n+     We dealt with constant rtxes earlier, so pos_rtx cannot\n+     have VOIDmode at this point.  */\n   if (pos_rtx != 0\n-      && GET_MODE_SIZE (pos_mode) > GET_MODE_SIZE (GET_MODE (pos_rtx)))\n+      && (GET_MODE_SIZE (pos_mode)\n+\t  > GET_MODE_SIZE (as_a <scalar_int_mode> (GET_MODE (pos_rtx)))))\n     {\n       rtx temp = simplify_gen_unary (ZERO_EXTEND, pos_mode, pos_rtx,\n \t\t\t\t     GET_MODE (pos_rtx));\n@@ -11336,7 +11342,8 @@ change_zero_ext (rtx pat)\n \t       && !paradoxical_subreg_p (XEXP (x, 0))\n \t       && subreg_lowpart_p (XEXP (x, 0)))\n \t{\n-\t  size = GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)));\n+\t  inner_mode = as_a <scalar_int_mode> (GET_MODE (XEXP (x, 0)));\n+\t  size = GET_MODE_PRECISION (inner_mode);\n \t  x = SUBREG_REG (XEXP (x, 0));\n \t  if (GET_MODE (x) != mode)\n \t    x = gen_lowpart_SUBREG (mode, x);\n@@ -11346,7 +11353,8 @@ change_zero_ext (rtx pat)\n \t       && HARD_REGISTER_P (XEXP (x, 0))\n \t       && can_change_dest_mode (XEXP (x, 0), 0, mode))\n \t{\n-\t  size = GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)));\n+\t  inner_mode = as_a <scalar_int_mode> (GET_MODE (XEXP (x, 0)));\n+\t  size = GET_MODE_PRECISION (inner_mode);\n \t  x = gen_rtx_REG (mode, REGNO (XEXP (x, 0)));\n \t}\n       else\n@@ -11764,8 +11772,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n   rtx op1 = *pop1;\n   rtx tem, tem1;\n   int i;\n-  scalar_int_mode mode, inner_mode;\n-  machine_mode tmode;\n+  scalar_int_mode mode, inner_mode, tmode;\n+  opt_scalar_int_mode tmode_iter;\n \n   /* Try a few ways of applying the same transformation to both operands.  */\n   while (1)\n@@ -11873,7 +11881,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    }\n \n \t  else if (c0 == c1)\n-\t    FOR_EACH_MODE_UNTIL (tmode, GET_MODE (op0))\n+\t    FOR_EACH_MODE_UNTIL (tmode,\n+\t\t\t\t as_a <scalar_int_mode> (GET_MODE (op0)))\n \t      if ((unsigned HOST_WIDE_INT) c0 == GET_MODE_MASK (tmode))\n \t\t{\n \t\t  op0 = gen_lowpart_or_truncate (tmode, inner_op0);\n@@ -12739,8 +12748,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n   if (is_int_mode (GET_MODE (op0), &mode)\n       && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n       && ! have_insn_for (COMPARE, mode))\n-    FOR_EACH_WIDER_MODE (tmode, mode)\n+    FOR_EACH_WIDER_MODE (tmode_iter, mode)\n       {\n+\ttmode = tmode_iter.require ();\n \tif (!HWI_COMPUTABLE_MODE_P (tmode))\n \t  break;\n \tif (have_insn_for (COMPARE, tmode))"}, {"sha": "d8d730be6b984dafb0caf64f04ca09072e9f86b0", "filename": "gcc/cse.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -4552,14 +4552,17 @@ cse_insn (rtx_insn *insn)\n \t       && CONST_INT_P (XEXP (SET_DEST (sets[0].rtl), 2)))\n \t{\n \t  rtx dest_reg = XEXP (SET_DEST (sets[0].rtl), 0);\n+\t  /* This is the mode of XEXP (tem, 0) as well.  */\n+\t  scalar_int_mode dest_mode\n+\t    = as_a <scalar_int_mode> (GET_MODE (dest_reg));\n \t  rtx width = XEXP (SET_DEST (sets[0].rtl), 1);\n \t  rtx pos = XEXP (SET_DEST (sets[0].rtl), 2);\n \t  HOST_WIDE_INT val = INTVAL (XEXP (tem, 0));\n \t  HOST_WIDE_INT mask;\n \t  unsigned int shift;\n \t  if (BITS_BIG_ENDIAN)\n-\t    shift = GET_MODE_PRECISION (GET_MODE (dest_reg))\n-\t      - INTVAL (pos) - INTVAL (width);\n+\t    shift = (GET_MODE_PRECISION (dest_mode)\n+\t\t     - INTVAL (pos) - INTVAL (width));\n \t  else\n \t    shift = INTVAL (pos);\n \t  if (INTVAL (width) == HOST_BITS_PER_WIDE_INT)\n@@ -5231,8 +5234,11 @@ cse_insn (rtx_insn *insn)\n \t\t  HOST_WIDE_INT val = INTVAL (dest_cst);\n \t\t  HOST_WIDE_INT mask;\n \t\t  unsigned int shift;\n+\t\t  /* This is the mode of DEST_CST as well.  */\n+\t\t  scalar_int_mode dest_mode\n+\t\t    = as_a <scalar_int_mode> (GET_MODE (dest_reg));\n \t\t  if (BITS_BIG_ENDIAN)\n-\t\t    shift = GET_MODE_PRECISION (GET_MODE (dest_reg))\n+\t\t    shift = GET_MODE_PRECISION (dest_mode)\n \t\t\t    - INTVAL (pos) - INTVAL (width);\n \t\t  else\n \t\t    shift = INTVAL (pos);\n@@ -5242,7 +5248,7 @@ cse_insn (rtx_insn *insn)\n \t\t    mask = (HOST_WIDE_INT_1 << INTVAL (width)) - 1;\n \t\t  val &= ~(mask << shift);\n \t\t  val |= (INTVAL (trial) & mask) << shift;\n-\t\t  val = trunc_int_for_mode (val, GET_MODE (dest_reg));\n+\t\t  val = trunc_int_for_mode (val, dest_mode);\n \t\t  validate_unshare_change (insn, &SET_DEST (sets[i].rtl),\n \t\t\t\t\t   dest_reg, 1);\n \t\t  validate_unshare_change (insn, &SET_SRC (sets[i].rtl),"}, {"sha": "ed0824ee1980107df459240b634021a03f4753c9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -14164,15 +14164,17 @@ minmax_loc_descriptor (rtx rtl, machine_mode mode,\n   add_loc_descr (&op1, new_loc_descr (DW_OP_over, 0, 0));\n   if (GET_CODE (rtl) == UMIN || GET_CODE (rtl) == UMAX)\n     {\n-      if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n+      /* Checked by the caller.  */\n+      int_mode = as_a <scalar_int_mode> (mode);\n+      if (GET_MODE_SIZE (int_mode) < DWARF2_ADDR_SIZE)\n \t{\n-\t  HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n+\t  HOST_WIDE_INT mask = GET_MODE_MASK (int_mode);\n \t  add_loc_descr (&op0, int_loc_descriptor (mask));\n \t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n \t  add_loc_descr (&op1, int_loc_descriptor (mask));\n \t  add_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n \t}\n-      else if (GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE)\n+      else if (GET_MODE_SIZE (int_mode) == DWARF2_ADDR_SIZE)\n \t{\n \t  HOST_WIDE_INT bias = 1;\n \t  bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n@@ -15058,7 +15060,8 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t    break;\n \n \t  if (CONST_INT_P (XEXP (rtl, 1))\n-\t      && GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE)\n+\t      && (GET_MODE_SIZE (as_a <scalar_int_mode> (mode))\n+\t\t  <= DWARF2_ADDR_SIZE))\n \t    loc_descr_plus_const (&mem_loc_result, INTVAL (XEXP (rtl, 1)));\n \t  else\n \t    {\n@@ -15841,8 +15844,11 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \n     case CONST_INT:\n       if (mode != VOIDmode && mode != BLKmode)\n-\tloc_result = address_of_int_loc_descriptor (GET_MODE_SIZE (mode),\n-\t\t\t\t\t\t    INTVAL (rtl));\n+\t{\n+\t  int_mode = as_a <scalar_int_mode> (mode);\n+\t  loc_result = address_of_int_loc_descriptor (GET_MODE_SIZE (int_mode),\n+\t\t\t\t\t\t      INTVAL (rtl));\n+\t}\n       break;\n \n     case CONST_DOUBLE:\n@@ -15887,11 +15893,12 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \n       if (mode != VOIDmode && (dwarf_version >= 4 || !dwarf_strict))\n \t{\n+\t  int_mode = as_a <scalar_int_mode> (mode);\n \t  loc_result = new_loc_descr (DW_OP_implicit_value,\n-\t\t\t\t      GET_MODE_SIZE (mode), 0);\n+\t\t\t\t      GET_MODE_SIZE (int_mode), 0);\n \t  loc_result->dw_loc_oprnd2.val_class = dw_val_class_wide_int;\n \t  loc_result->dw_loc_oprnd2.v.val_wide = ggc_alloc<wide_int> ();\n-\t  *loc_result->dw_loc_oprnd2.v.val_wide = rtx_mode_t (rtl, mode);\n+\t  *loc_result->dw_loc_oprnd2.v.val_wide = rtx_mode_t (rtl, int_mode);\n \t}\n       break;\n "}, {"sha": "80df42f2ae39a1972e005c2f83e4c542fca2ec93", "filename": "gcc/expmed.c", "status": "modified", "additions": 143, "deletions": 140, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -207,7 +207,8 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n     {\n       for (mode_from = MIN_MODE_INT; mode_from <= MAX_MODE_INT;\n \t   mode_from = (machine_mode)(mode_from + 1))\n-\tinit_expmed_one_conv (all, int_mode_to, mode_from, speed);\n+\tinit_expmed_one_conv (all, int_mode_to,\n+\t\t\t      as_a <scalar_int_mode> (mode_from), speed);\n \n       scalar_int_mode wider_mode;\n       if (GET_MODE_CLASS (int_mode_to) == MODE_INT\n@@ -2578,7 +2579,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   bool cache_hit = false;\n   enum alg_code cache_alg = alg_zero;\n   bool speed = optimize_insn_for_speed_p ();\n-  machine_mode imode;\n+  scalar_int_mode imode;\n   struct alg_hash_entry *entry_ptr;\n \n   /* Indicate that no algorithm is yet found.  If no algorithm\n@@ -2591,7 +2592,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n     return;\n \n   /* Be prepared for vector modes.  */\n-  imode = GET_MODE_INNER (mode);\n+  imode = as_a <scalar_int_mode> (GET_MODE_INNER (mode));\n \n   maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (imode));\n \n@@ -4035,7 +4036,6 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n   rtx tquotient;\n   rtx quotient = 0, remainder = 0;\n   rtx_insn *last;\n-  int size;\n   rtx_insn *insn;\n   optab optab1, optab2;\n   int op1_is_constant, op1_is_pow2 = 0;\n@@ -4157,7 +4157,6 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n   else\n     tquotient = gen_reg_rtx (compute_mode);\n \n-  size = GET_MODE_BITSIZE (compute_mode);\n #if 0\n   /* It should be possible to restrict the precision to GET_MODE_BITSIZE\n      (mode), and thereby get better code when OP1 is a constant.  Do that\n@@ -4230,12 +4229,14 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n       case TRUNC_DIV_EXPR:\n \tif (op1_is_constant)\n \t  {\n+\t    scalar_int_mode int_mode = as_a <scalar_int_mode> (compute_mode);\n+\t    int size = GET_MODE_BITSIZE (int_mode);\n \t    if (unsignedp)\n \t      {\n \t\tunsigned HOST_WIDE_INT mh, ml;\n \t\tint pre_shift, post_shift;\n \t\tint dummy;\n-\t\twide_int wd = rtx_mode_t (op1, compute_mode);\n+\t\twide_int wd = rtx_mode_t (op1, int_mode);\n \t\tunsigned HOST_WIDE_INT d = wd.to_uhwi ();\n \n \t\tif (wi::popcount (wd) == 1)\n@@ -4246,14 +4247,14 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\tunsigned HOST_WIDE_INT mask\n \t\t\t  = (HOST_WIDE_INT_1U << pre_shift) - 1;\n \t\t\tremainder\n-\t\t\t  = expand_binop (compute_mode, and_optab, op0,\n-\t\t\t\t\t  gen_int_mode (mask, compute_mode),\n+\t\t\t  = expand_binop (int_mode, and_optab, op0,\n+\t\t\t\t\t  gen_int_mode (mask, int_mode),\n \t\t\t\t\t  remainder, 1,\n \t\t\t\t\t  OPTAB_LIB_WIDEN);\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n-\t\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t    quotient = expand_shift (RSHIFT_EXPR, int_mode, op0,\n \t\t\t\t\t     pre_shift, tquotient, 1);\n \t\t  }\n \t\telse if (size <= HOST_BITS_PER_WIDE_INT)\n@@ -4263,7 +4264,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t/* Most significant bit of divisor is set; emit an scc\n \t\t\t   insn.  */\n \t\t\tquotient = emit_store_flag_force (tquotient, GEU, op0, op1,\n-\t\t\t\t\t\t\t  compute_mode, 1, 1);\n+\t\t\t\t\t\t\t  int_mode, 1, 1);\n \t\t      }\n \t\t    else\n \t\t      {\n@@ -4295,25 +4296,24 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t      goto fail1;\n \n \t\t\t    extra_cost\n-\t\t\t      = (shift_cost (speed, compute_mode, post_shift - 1)\n-\t\t\t\t + shift_cost (speed, compute_mode, 1)\n-\t\t\t\t + 2 * add_cost (speed, compute_mode));\n+\t\t\t      = (shift_cost (speed, int_mode, post_shift - 1)\n+\t\t\t\t + shift_cost (speed, int_mode, 1)\n+\t\t\t\t + 2 * add_cost (speed, int_mode));\n \t\t\t    t1 = expmed_mult_highpart\n-\t\t\t      (compute_mode, op0,\n-\t\t\t       gen_int_mode (ml, compute_mode),\n+\t\t\t      (int_mode, op0, gen_int_mode (ml, int_mode),\n \t\t\t       NULL_RTX, 1, max_cost - extra_cost);\n \t\t\t    if (t1 == 0)\n \t\t\t      goto fail1;\n-\t\t\t    t2 = force_operand (gen_rtx_MINUS (compute_mode,\n+\t\t\t    t2 = force_operand (gen_rtx_MINUS (int_mode,\n \t\t\t\t\t\t\t       op0, t1),\n \t\t\t\t\t\tNULL_RTX);\n-\t\t\t    t3 = expand_shift (RSHIFT_EXPR, compute_mode,\n+\t\t\t    t3 = expand_shift (RSHIFT_EXPR, int_mode,\n \t\t\t\t\t       t2, 1, NULL_RTX, 1);\n-\t\t\t    t4 = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\t\t    t4 = force_operand (gen_rtx_PLUS (int_mode,\n \t\t\t\t\t\t\t      t1, t3),\n \t\t\t\t\t\tNULL_RTX);\n \t\t\t    quotient = expand_shift\n-\t\t\t      (RSHIFT_EXPR, compute_mode, t4,\n+\t\t\t      (RSHIFT_EXPR, int_mode, t4,\n \t\t\t       post_shift - 1, tquotient, 1);\n \t\t\t  }\n \t\t\telse\n@@ -4325,19 +4325,19 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t      goto fail1;\n \n \t\t\t    t1 = expand_shift\n-\t\t\t      (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t      (RSHIFT_EXPR, int_mode, op0,\n \t\t\t       pre_shift, NULL_RTX, 1);\n \t\t\t    extra_cost\n-\t\t\t      = (shift_cost (speed, compute_mode, pre_shift)\n-\t\t\t\t + shift_cost (speed, compute_mode, post_shift));\n+\t\t\t      = (shift_cost (speed, int_mode, pre_shift)\n+\t\t\t\t + shift_cost (speed, int_mode, post_shift));\n \t\t\t    t2 = expmed_mult_highpart\n-\t\t\t      (compute_mode, t1,\n-\t\t\t       gen_int_mode (ml, compute_mode),\n+\t\t\t      (int_mode, t1,\n+\t\t\t       gen_int_mode (ml, int_mode),\n \t\t\t       NULL_RTX, 1, max_cost - extra_cost);\n \t\t\t    if (t2 == 0)\n \t\t\t      goto fail1;\n \t\t\t    quotient = expand_shift\n-\t\t\t      (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t      (RSHIFT_EXPR, int_mode, t2,\n \t\t\t       post_shift, tquotient, 1);\n \t\t\t  }\n \t\t      }\n@@ -4348,7 +4348,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\tinsn = get_last_insn ();\n \t\tif (insn != last)\n \t\t  set_dst_reg_note (insn, REG_EQUAL,\n-\t\t\t\t    gen_rtx_UDIV (compute_mode, op0, op1),\n+\t\t\t\t    gen_rtx_UDIV (int_mode, op0, op1),\n \t\t\t\t    quotient);\n \t      }\n \t    else\t\t/* TRUNC_DIV, signed */\n@@ -4370,36 +4370,35 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\tif (rem_flag && d < 0)\n \t\t  {\n \t\t    d = abs_d;\n-\t\t    op1 = gen_int_mode (abs_d, compute_mode);\n+\t\t    op1 = gen_int_mode (abs_d, int_mode);\n \t\t  }\n \n \t\tif (d == 1)\n \t\t  quotient = op0;\n \t\telse if (d == -1)\n-\t\t  quotient = expand_unop (compute_mode, neg_optab, op0,\n+\t\t  quotient = expand_unop (int_mode, neg_optab, op0,\n \t\t\t\t\t  tquotient, 0);\n \t\telse if (size <= HOST_BITS_PER_WIDE_INT\n \t\t\t && abs_d == HOST_WIDE_INT_1U << (size - 1))\n \t\t  {\n \t\t    /* This case is not handled correctly below.  */\n \t\t    quotient = emit_store_flag (tquotient, EQ, op0, op1,\n-\t\t\t\t\t\tcompute_mode, 1, 1);\n+\t\t\t\t\t\tint_mode, 1, 1);\n \t\t    if (quotient == 0)\n \t\t      goto fail1;\n \t\t  }\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (d)\n \t\t\t && (size <= HOST_BITS_PER_WIDE_INT || d >= 0)\n \t\t\t && (rem_flag\n-\t\t\t     ? smod_pow2_cheap (speed, compute_mode)\n-\t\t\t     : sdiv_pow2_cheap (speed, compute_mode))\n+\t\t\t     ? smod_pow2_cheap (speed, int_mode)\n+\t\t\t     : sdiv_pow2_cheap (speed, int_mode))\n \t\t\t /* We assume that cheap metric is true if the\n \t\t\t    optab has an expander for this mode.  */\n \t\t\t && ((optab_handler ((rem_flag ? smod_optab\n \t\t\t\t\t      : sdiv_optab),\n-\t\t\t\t\t     compute_mode)\n+\t\t\t\t\t     int_mode)\n \t\t\t      != CODE_FOR_nothing)\n-\t\t\t     || (optab_handler (sdivmod_optab,\n-\t\t\t\t\t\tcompute_mode)\n+\t\t\t     || (optab_handler (sdivmod_optab, int_mode)\n \t\t\t\t != CODE_FOR_nothing)))\n \t\t  ;\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d)\n@@ -4408,23 +4407,23 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t  {\n \t\t    if (rem_flag)\n \t\t      {\n-\t\t\tremainder = expand_smod_pow2 (compute_mode, op0, d);\n+\t\t\tremainder = expand_smod_pow2 (int_mode, op0, d);\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n \n-\t\t    if (sdiv_pow2_cheap (speed, compute_mode)\n-\t\t\t&& ((optab_handler (sdiv_optab, compute_mode)\n+\t\t    if (sdiv_pow2_cheap (speed, int_mode)\n+\t\t\t&& ((optab_handler (sdiv_optab, int_mode)\n \t\t\t     != CODE_FOR_nothing)\n-\t\t\t    || (optab_handler (sdivmod_optab, compute_mode)\n+\t\t\t    || (optab_handler (sdivmod_optab, int_mode)\n \t\t\t\t!= CODE_FOR_nothing)))\n \t\t      quotient = expand_divmod (0, TRUNC_DIV_EXPR,\n-\t\t\t\t\t\tcompute_mode, op0,\n+\t\t\t\t\t\tint_mode, op0,\n \t\t\t\t\t\tgen_int_mode (abs_d,\n-\t\t\t\t\t\t\t      compute_mode),\n+\t\t\t\t\t\t\t      int_mode),\n \t\t\t\t\t\tNULL_RTX, 0);\n \t\t    else\n-\t\t      quotient = expand_sdiv_pow2 (compute_mode, op0, abs_d);\n+\t\t      quotient = expand_sdiv_pow2 (int_mode, op0, abs_d);\n \n \t\t    /* We have computed OP0 / abs(OP1).  If OP1 is negative,\n \t\t       negate the quotient.  */\n@@ -4435,13 +4434,13 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t    && abs_d < (HOST_WIDE_INT_1U\n \t\t\t\t\t<< (HOST_BITS_PER_WIDE_INT - 1)))\n \t\t\t  set_dst_reg_note (insn, REG_EQUAL,\n-\t\t\t\t\t    gen_rtx_DIV (compute_mode, op0,\n+\t\t\t\t\t    gen_rtx_DIV (int_mode, op0,\n \t\t\t\t\t\t\t gen_int_mode\n \t\t\t\t\t\t\t   (abs_d,\n-\t\t\t\t\t\t\t    compute_mode)),\n+\t\t\t\t\t\t\t    int_mode)),\n \t\t\t\t\t    quotient);\n \n-\t\t\tquotient = expand_unop (compute_mode, neg_optab,\n+\t\t\tquotient = expand_unop (int_mode, neg_optab,\n \t\t\t\t\t\tquotient, quotient, 0);\n \t\t      }\n \t\t  }\n@@ -4457,29 +4456,27 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t    || size - 1 >= BITS_PER_WORD)\n \t\t\t  goto fail1;\n \n-\t\t\textra_cost = (shift_cost (speed, compute_mode, post_shift)\n-\t\t\t\t      + shift_cost (speed, compute_mode, size - 1)\n-\t\t\t\t      + add_cost (speed, compute_mode));\n+\t\t\textra_cost = (shift_cost (speed, int_mode, post_shift)\n+\t\t\t\t      + shift_cost (speed, int_mode, size - 1)\n+\t\t\t\t      + add_cost (speed, int_mode));\n \t\t\tt1 = expmed_mult_highpart\n-\t\t\t  (compute_mode, op0, gen_int_mode (ml, compute_mode),\n+\t\t\t  (int_mode, op0, gen_int_mode (ml, int_mode),\n \t\t\t   NULL_RTX, 0, max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n \t\t\tt2 = expand_shift\n-\t\t\t  (RSHIFT_EXPR, compute_mode, t1,\n+\t\t\t  (RSHIFT_EXPR, int_mode, t1,\n \t\t\t   post_shift, NULL_RTX, 0);\n \t\t\tt3 = expand_shift\n-\t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t  (RSHIFT_EXPR, int_mode, op0,\n \t\t\t   size - 1, NULL_RTX, 0);\n \t\t\tif (d < 0)\n \t\t\t  quotient\n-\t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n-\t\t\t\t\t\t\t    t3, t2),\n+\t\t\t    = force_operand (gen_rtx_MINUS (int_mode, t3, t2),\n \t\t\t\t\t     tquotient);\n \t\t\telse\n \t\t\t  quotient\n-\t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n-\t\t\t\t\t\t\t    t2, t3),\n+\t\t\t    = force_operand (gen_rtx_MINUS (int_mode, t2, t3),\n \t\t\t\t\t     tquotient);\n \t\t      }\n \t\t    else\n@@ -4491,33 +4488,30 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t  goto fail1;\n \n \t\t\tml |= HOST_WIDE_INT_M1U << (size - 1);\n-\t\t\tmlr = gen_int_mode (ml, compute_mode);\n-\t\t\textra_cost = (shift_cost (speed, compute_mode, post_shift)\n-\t\t\t\t      + shift_cost (speed, compute_mode, size - 1)\n-\t\t\t\t      + 2 * add_cost (speed, compute_mode));\n-\t\t\tt1 = expmed_mult_highpart (compute_mode, op0, mlr,\n+\t\t\tmlr = gen_int_mode (ml, int_mode);\n+\t\t\textra_cost = (shift_cost (speed, int_mode, post_shift)\n+\t\t\t\t      + shift_cost (speed, int_mode, size - 1)\n+\t\t\t\t      + 2 * add_cost (speed, int_mode));\n+\t\t\tt1 = expmed_mult_highpart (int_mode, op0, mlr,\n \t\t\t\t\t\t   NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n-\t\t\tt2 = force_operand (gen_rtx_PLUS (compute_mode,\n-\t\t\t\t\t\t\t  t1, op0),\n+\t\t\tt2 = force_operand (gen_rtx_PLUS (int_mode, t1, op0),\n \t\t\t\t\t    NULL_RTX);\n \t\t\tt3 = expand_shift\n-\t\t\t  (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t  (RSHIFT_EXPR, int_mode, t2,\n \t\t\t   post_shift, NULL_RTX, 0);\n \t\t\tt4 = expand_shift\n-\t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t  (RSHIFT_EXPR, int_mode, op0,\n \t\t\t   size - 1, NULL_RTX, 0);\n \t\t\tif (d < 0)\n \t\t\t  quotient\n-\t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n-\t\t\t\t\t\t\t    t4, t3),\n+\t\t\t    = force_operand (gen_rtx_MINUS (int_mode, t4, t3),\n \t\t\t\t\t     tquotient);\n \t\t\telse\n \t\t\t  quotient\n-\t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n-\t\t\t\t\t\t\t    t3, t4),\n+\t\t\t    = force_operand (gen_rtx_MINUS (int_mode, t3, t4),\n \t\t\t\t\t     tquotient);\n \t\t      }\n \t\t  }\n@@ -4527,7 +4521,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\tinsn = get_last_insn ();\n \t\tif (insn != last)\n \t\t  set_dst_reg_note (insn, REG_EQUAL,\n-\t\t\t\t    gen_rtx_DIV (compute_mode, op0, op1),\n+\t\t\t\t    gen_rtx_DIV (int_mode, op0, op1),\n \t\t\t\t    quotient);\n \t      }\n \t    break;\n@@ -4539,8 +4533,10 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n       case FLOOR_DIV_EXPR:\n       case FLOOR_MOD_EXPR:\n       /* We will come here only for signed operations.  */\n-\tif (op1_is_constant && size <= HOST_BITS_PER_WIDE_INT)\n+\tif (op1_is_constant && HWI_COMPUTABLE_MODE_P (compute_mode))\n \t  {\n+\t    scalar_int_mode int_mode = as_a <scalar_int_mode> (compute_mode);\n+\t    int size = GET_MODE_BITSIZE (int_mode);\n \t    unsigned HOST_WIDE_INT mh, ml;\n \t    int pre_shift, lgup, post_shift;\n \t    HOST_WIDE_INT d = INTVAL (op1);\n@@ -4557,14 +4553,14 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\tunsigned HOST_WIDE_INT mask\n \t\t\t  = (HOST_WIDE_INT_1U << pre_shift) - 1;\n \t\t\tremainder = expand_binop\n-\t\t\t  (compute_mode, and_optab, op0,\n-\t\t\t   gen_int_mode (mask, compute_mode),\n+\t\t\t  (int_mode, and_optab, op0,\n+\t\t\t   gen_int_mode (mask, int_mode),\n \t\t\t   remainder, 0, OPTAB_LIB_WIDEN);\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n \t\t    quotient = expand_shift\n-\t\t      (RSHIFT_EXPR, compute_mode, op0,\n+\t\t      (RSHIFT_EXPR, int_mode, op0,\n \t\t       pre_shift, tquotient, 0);\n \t\t  }\n \t\telse\n@@ -4579,22 +4575,22 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t&& size - 1 < BITS_PER_WORD)\n \t\t      {\n \t\t\tt1 = expand_shift\n-\t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t  (RSHIFT_EXPR, int_mode, op0,\n \t\t\t   size - 1, NULL_RTX, 0);\n-\t\t\tt2 = expand_binop (compute_mode, xor_optab, op0, t1,\n+\t\t\tt2 = expand_binop (int_mode, xor_optab, op0, t1,\n \t\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n-\t\t\textra_cost = (shift_cost (speed, compute_mode, post_shift)\n-\t\t\t\t      + shift_cost (speed, compute_mode, size - 1)\n-\t\t\t\t      + 2 * add_cost (speed, compute_mode));\n+\t\t\textra_cost = (shift_cost (speed, int_mode, post_shift)\n+\t\t\t\t      + shift_cost (speed, int_mode, size - 1)\n+\t\t\t\t      + 2 * add_cost (speed, int_mode));\n \t\t\tt3 = expmed_mult_highpart\n-\t\t\t  (compute_mode, t2, gen_int_mode (ml, compute_mode),\n+\t\t\t  (int_mode, t2, gen_int_mode (ml, int_mode),\n \t\t\t   NULL_RTX, 1, max_cost - extra_cost);\n \t\t\tif (t3 != 0)\n \t\t\t  {\n \t\t\t    t4 = expand_shift\n-\t\t\t      (RSHIFT_EXPR, compute_mode, t3,\n+\t\t\t      (RSHIFT_EXPR, int_mode, t3,\n \t\t\t       post_shift, NULL_RTX, 1);\n-\t\t\t    quotient = expand_binop (compute_mode, xor_optab,\n+\t\t\t    quotient = expand_binop (int_mode, xor_optab,\n \t\t\t\t\t\t     t4, t1, tquotient, 0,\n \t\t\t\t\t\t     OPTAB_WIDEN);\n \t\t\t  }\n@@ -4604,23 +4600,22 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t    else\n \t      {\n \t\trtx nsign, t1, t2, t3, t4;\n-\t\tt1 = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\tt1 = force_operand (gen_rtx_PLUS (int_mode,\n \t\t\t\t\t\t  op0, constm1_rtx), NULL_RTX);\n-\t\tt2 = expand_binop (compute_mode, ior_optab, op0, t1, NULL_RTX,\n+\t\tt2 = expand_binop (int_mode, ior_optab, op0, t1, NULL_RTX,\n \t\t\t\t   0, OPTAB_WIDEN);\n-\t\tnsign = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n+\t\tnsign = expand_shift (RSHIFT_EXPR, int_mode, t2,\n \t\t\t\t      size - 1, NULL_RTX, 0);\n-\t\tt3 = force_operand (gen_rtx_MINUS (compute_mode, t1, nsign),\n+\t\tt3 = force_operand (gen_rtx_MINUS (int_mode, t1, nsign),\n \t\t\t\t    NULL_RTX);\n-\t\tt4 = expand_divmod (0, TRUNC_DIV_EXPR, compute_mode, t3, op1,\n+\t\tt4 = expand_divmod (0, TRUNC_DIV_EXPR, int_mode, t3, op1,\n \t\t\t\t    NULL_RTX, 0);\n \t\tif (t4)\n \t\t  {\n \t\t    rtx t5;\n-\t\t    t5 = expand_unop (compute_mode, one_cmpl_optab, nsign,\n+\t\t    t5 = expand_unop (int_mode, one_cmpl_optab, nsign,\n \t\t\t\t      NULL_RTX, 0);\n-\t\t    quotient = force_operand (gen_rtx_PLUS (compute_mode,\n-\t\t\t\t\t\t\t    t4, t5),\n+\t\t    quotient = force_operand (gen_rtx_PLUS (int_mode, t4, t5),\n \t\t\t\t\t      tquotient);\n \t\t  }\n \t      }\n@@ -4720,31 +4715,31 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t  {\n \t    if (op1_is_constant\n \t\t&& EXACT_POWER_OF_2_OR_ZERO_P (INTVAL (op1))\n-\t\t&& (size <= HOST_BITS_PER_WIDE_INT\n+\t\t&& (HWI_COMPUTABLE_MODE_P (compute_mode)\n \t\t    || INTVAL (op1) >= 0))\n \t      {\n+\t\tscalar_int_mode int_mode\n+\t\t  = as_a <scalar_int_mode> (compute_mode);\n \t\trtx t1, t2, t3;\n \t\tunsigned HOST_WIDE_INT d = INTVAL (op1);\n-\t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\tt1 = expand_shift (RSHIFT_EXPR, int_mode, op0,\n \t\t\t\t   floor_log2 (d), tquotient, 1);\n-\t\tt2 = expand_binop (compute_mode, and_optab, op0,\n-\t\t\t\t   gen_int_mode (d - 1, compute_mode),\n+\t\tt2 = expand_binop (int_mode, and_optab, op0,\n+\t\t\t\t   gen_int_mode (d - 1, int_mode),\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\t\tt3 = gen_reg_rtx (compute_mode);\n-\t\tt3 = emit_store_flag (t3, NE, t2, const0_rtx,\n-\t\t\t\t      compute_mode, 1, 1);\n+\t\tt3 = gen_reg_rtx (int_mode);\n+\t\tt3 = emit_store_flag (t3, NE, t2, const0_rtx, int_mode, 1, 1);\n \t\tif (t3 == 0)\n \t\t  {\n \t\t    rtx_code_label *lab;\n \t\t    lab = gen_label_rtx ();\n-\t\t    do_cmp_and_jump (t2, const0_rtx, EQ, compute_mode, lab);\n+\t\t    do_cmp_and_jump (t2, const0_rtx, EQ, int_mode, lab);\n \t\t    expand_inc (t1, const1_rtx);\n \t\t    emit_label (lab);\n \t\t    quotient = t1;\n \t\t  }\n \t\telse\n-\t\t  quotient = force_operand (gen_rtx_PLUS (compute_mode,\n-\t\t\t\t\t\t\t  t1, t3),\n+\t\t  quotient = force_operand (gen_rtx_PLUS (int_mode, t1, t3),\n \t\t\t\t\t    tquotient);\n \t\tbreak;\n \t      }\n@@ -4934,25 +4929,26 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \tbreak;\n \n       case EXACT_DIV_EXPR:\n-\tif (op1_is_constant && size <= HOST_BITS_PER_WIDE_INT)\n+\tif (op1_is_constant && HWI_COMPUTABLE_MODE_P (compute_mode))\n \t  {\n+\t    scalar_int_mode int_mode = as_a <scalar_int_mode> (compute_mode);\n+\t    int size = GET_MODE_BITSIZE (int_mode);\n \t    HOST_WIDE_INT d = INTVAL (op1);\n \t    unsigned HOST_WIDE_INT ml;\n \t    int pre_shift;\n \t    rtx t1;\n \n \t    pre_shift = ctz_or_zero (d);\n \t    ml = invert_mod2n (d >> pre_shift, size);\n-\t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t    t1 = expand_shift (RSHIFT_EXPR, int_mode, op0,\n \t\t\t       pre_shift, NULL_RTX, unsignedp);\n-\t    quotient = expand_mult (compute_mode, t1,\n-\t\t\t\t    gen_int_mode (ml, compute_mode),\n+\t    quotient = expand_mult (int_mode, t1, gen_int_mode (ml, int_mode),\n \t\t\t\t    NULL_RTX, 1);\n \n \t    insn = get_last_insn ();\n \t    set_dst_reg_note (insn, REG_EQUAL,\n \t\t\t      gen_rtx_fmt_ee (unsignedp ? UDIV : DIV,\n-\t\t\t\t\t      compute_mode, op0, op1),\n+\t\t\t\t\t      int_mode, op0, op1),\n \t\t\t      quotient);\n \t  }\n \tbreak;\n@@ -4961,60 +4957,63 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n       case ROUND_MOD_EXPR:\n \tif (unsignedp)\n \t  {\n+\t    scalar_int_mode int_mode = as_a <scalar_int_mode> (compute_mode);\n \t    rtx tem;\n \t    rtx_code_label *label;\n \t    label = gen_label_rtx ();\n-\t    quotient = gen_reg_rtx (compute_mode);\n-\t    remainder = gen_reg_rtx (compute_mode);\n+\t    quotient = gen_reg_rtx (int_mode);\n+\t    remainder = gen_reg_rtx (int_mode);\n \t    if (expand_twoval_binop (udivmod_optab, op0, op1, quotient, remainder, 1) == 0)\n \t      {\n \t\trtx tem;\n-\t\tquotient = expand_binop (compute_mode, udiv_optab, op0, op1,\n+\t\tquotient = expand_binop (int_mode, udiv_optab, op0, op1,\n \t\t\t\t\t quotient, 1, OPTAB_LIB_WIDEN);\n-\t\ttem = expand_mult (compute_mode, quotient, op1, NULL_RTX, 1);\n-\t\tremainder = expand_binop (compute_mode, sub_optab, op0, tem,\n+\t\ttem = expand_mult (int_mode, quotient, op1, NULL_RTX, 1);\n+\t\tremainder = expand_binop (int_mode, sub_optab, op0, tem,\n \t\t\t\t\t  remainder, 1, OPTAB_LIB_WIDEN);\n \t      }\n-\t    tem = plus_constant (compute_mode, op1, -1);\n-\t    tem = expand_shift (RSHIFT_EXPR, compute_mode, tem, 1, NULL_RTX, 1);\n-\t    do_cmp_and_jump (remainder, tem, LEU, compute_mode, label);\n+\t    tem = plus_constant (int_mode, op1, -1);\n+\t    tem = expand_shift (RSHIFT_EXPR, int_mode, tem, 1, NULL_RTX, 1);\n+\t    do_cmp_and_jump (remainder, tem, LEU, int_mode, label);\n \t    expand_inc (quotient, const1_rtx);\n \t    expand_dec (remainder, op1);\n \t    emit_label (label);\n \t  }\n \telse\n \t  {\n+\t    scalar_int_mode int_mode = as_a <scalar_int_mode> (compute_mode);\n+\t    int size = GET_MODE_BITSIZE (int_mode);\n \t    rtx abs_rem, abs_op1, tem, mask;\n \t    rtx_code_label *label;\n \t    label = gen_label_rtx ();\n-\t    quotient = gen_reg_rtx (compute_mode);\n-\t    remainder = gen_reg_rtx (compute_mode);\n+\t    quotient = gen_reg_rtx (int_mode);\n+\t    remainder = gen_reg_rtx (int_mode);\n \t    if (expand_twoval_binop (sdivmod_optab, op0, op1, quotient, remainder, 0) == 0)\n \t      {\n \t\trtx tem;\n-\t\tquotient = expand_binop (compute_mode, sdiv_optab, op0, op1,\n+\t\tquotient = expand_binop (int_mode, sdiv_optab, op0, op1,\n \t\t\t\t\t quotient, 0, OPTAB_LIB_WIDEN);\n-\t\ttem = expand_mult (compute_mode, quotient, op1, NULL_RTX, 0);\n-\t\tremainder = expand_binop (compute_mode, sub_optab, op0, tem,\n+\t\ttem = expand_mult (int_mode, quotient, op1, NULL_RTX, 0);\n+\t\tremainder = expand_binop (int_mode, sub_optab, op0, tem,\n \t\t\t\t\t  remainder, 0, OPTAB_LIB_WIDEN);\n \t      }\n-\t    abs_rem = expand_abs (compute_mode, remainder, NULL_RTX, 1, 0);\n-\t    abs_op1 = expand_abs (compute_mode, op1, NULL_RTX, 1, 0);\n-\t    tem = expand_shift (LSHIFT_EXPR, compute_mode, abs_rem,\n+\t    abs_rem = expand_abs (int_mode, remainder, NULL_RTX, 1, 0);\n+\t    abs_op1 = expand_abs (int_mode, op1, NULL_RTX, 1, 0);\n+\t    tem = expand_shift (LSHIFT_EXPR, int_mode, abs_rem,\n \t\t\t\t1, NULL_RTX, 1);\n-\t    do_cmp_and_jump (tem, abs_op1, LTU, compute_mode, label);\n-\t    tem = expand_binop (compute_mode, xor_optab, op0, op1,\n+\t    do_cmp_and_jump (tem, abs_op1, LTU, int_mode, label);\n+\t    tem = expand_binop (int_mode, xor_optab, op0, op1,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n-\t    mask = expand_shift (RSHIFT_EXPR, compute_mode, tem,\n+\t    mask = expand_shift (RSHIFT_EXPR, int_mode, tem,\n \t\t\t\t size - 1, NULL_RTX, 0);\n-\t    tem = expand_binop (compute_mode, xor_optab, mask, const1_rtx,\n+\t    tem = expand_binop (int_mode, xor_optab, mask, const1_rtx,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n-\t    tem = expand_binop (compute_mode, sub_optab, tem, mask,\n+\t    tem = expand_binop (int_mode, sub_optab, tem, mask,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \t    expand_inc (quotient, tem);\n-\t    tem = expand_binop (compute_mode, xor_optab, mask, op1,\n+\t    tem = expand_binop (int_mode, xor_optab, mask, op1,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n-\t    tem = expand_binop (compute_mode, sub_optab, tem, mask,\n+\t    tem = expand_binop (int_mode, sub_optab, tem, mask,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \t    expand_dec (remainder, tem);\n \t    emit_label (label);\n@@ -5508,38 +5507,42 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       && (normalizep || STORE_FLAG_VALUE == 1\n \t  || val_signbit_p (int_mode, STORE_FLAG_VALUE)))\n     {\n+      scalar_int_mode int_target_mode;\n       subtarget = target;\n \n       if (!target)\n-\ttarget_mode = int_mode;\n-\n-      /* If the result is to be wider than OP0, it is best to convert it\n-\t first.  If it is to be narrower, it is *incorrect* to convert it\n-\t first.  */\n-      else if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (int_mode))\n+\tint_target_mode = int_mode;\n+      else\n \t{\n-\t  op0 = convert_modes (target_mode, int_mode, op0, 0);\n-\t  mode = target_mode;\n+\t  /* If the result is to be wider than OP0, it is best to convert it\n+\t     first.  If it is to be narrower, it is *incorrect* to convert it\n+\t     first.  */\n+\t  int_target_mode = as_a <scalar_int_mode> (target_mode);\n+\t  if (GET_MODE_SIZE (int_target_mode) > GET_MODE_SIZE (int_mode))\n+\t    {\n+\t      op0 = convert_modes (int_target_mode, int_mode, op0, 0);\n+\t      int_mode = int_target_mode;\n+\t    }\n \t}\n \n-      if (target_mode != mode)\n+      if (int_target_mode != int_mode)\n \tsubtarget = 0;\n \n       if (code == GE)\n-\top0 = expand_unop (mode, one_cmpl_optab, op0,\n+\top0 = expand_unop (int_mode, one_cmpl_optab, op0,\n \t\t\t   ((STORE_FLAG_VALUE == 1 || normalizep)\n \t\t\t    ? 0 : subtarget), 0);\n \n       if (STORE_FLAG_VALUE == 1 || normalizep)\n \t/* If we are supposed to produce a 0/1 value, we want to do\n \t   a logical shift from the sign bit to the low-order bit; for\n \t   a -1/0 value, we do an arithmetic shift.  */\n-\top0 = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t    GET_MODE_BITSIZE (mode) - 1,\n+\top0 = expand_shift (RSHIFT_EXPR, int_mode, op0,\n+\t\t\t    GET_MODE_BITSIZE (int_mode) - 1,\n \t\t\t    subtarget, normalizep != -1);\n \n-      if (mode != target_mode)\n-\top0 = convert_modes (target_mode, mode, op0, 0);\n+      if (int_mode != int_target_mode)\n+\top0 = convert_modes (int_target_mode, int_mode, op0, 0);\n \n       return op0;\n     }"}, {"sha": "4299df23e14f90338b4d8009abf8b8535d4a73c5", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -5243,8 +5243,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t{\n \t  if (POINTER_TYPE_P (TREE_TYPE (to)))\n \t    value = convert_memory_address_addr_space\n-\t\t      (GET_MODE (to_rtx), value,\n-\t\t       TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (to))));\n+\t      (as_a <scalar_int_mode> (GET_MODE (to_rtx)), value,\n+\t       TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (to))));\n \n \t  emit_move_insn (to_rtx, value);\n \t}\n@@ -11144,7 +11144,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n }\n \f\n /* Subroutine of above: reduce EXP to the precision of TYPE (in the\n-   signedness of TYPE), possibly returning the result in TARGET.  */\n+   signedness of TYPE), possibly returning the result in TARGET.\n+   TYPE is known to be a partial integer type.  */\n static rtx\n reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n {\n@@ -11160,18 +11161,17 @@ reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n     }\n   else if (TYPE_UNSIGNED (type))\n     {\n-      machine_mode mode = GET_MODE (exp);\n+      scalar_int_mode mode = as_a <scalar_int_mode> (GET_MODE (exp));\n       rtx mask = immed_wide_int_const\n \t(wi::mask (prec, false, GET_MODE_PRECISION (mode)), mode);\n       return expand_and (mode, exp, mask, target);\n     }\n   else\n     {\n-      int count = GET_MODE_PRECISION (GET_MODE (exp)) - prec;\n-      exp = expand_shift (LSHIFT_EXPR, GET_MODE (exp),\n-\t\t\t  exp, count, target, 0);\n-      return expand_shift (RSHIFT_EXPR, GET_MODE (exp),\n-\t\t\t   exp, count, target, 0);\n+      scalar_int_mode mode = as_a <scalar_int_mode> (GET_MODE (exp));\n+      int count = GET_MODE_PRECISION (mode) - prec;\n+      exp = expand_shift (LSHIFT_EXPR, mode, exp, count, target, 0);\n+      return expand_shift (RSHIFT_EXPR, mode, exp, count, target, 0);\n     }\n }\n \f"}, {"sha": "8e8291edc55d50d0a203115db35b4cdd4afad6e4", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -5589,8 +5589,8 @@ expand_function_end (void)\n       REG_FUNCTION_VALUE_P (outgoing) = 1;\n \n       /* The address may be ptr_mode and OUTGOING may be Pmode.  */\n-      value_address = convert_memory_address (GET_MODE (outgoing),\n-\t\t\t\t\t      value_address);\n+      scalar_int_mode mode = as_a <scalar_int_mode> (GET_MODE (outgoing));\n+      value_address = convert_memory_address (mode, value_address);\n \n       emit_move_insn (outgoing, value_address);\n "}, {"sha": "f8a02f309fc4d8aa17bd3fce2e6b3610ca3cdf8b", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -570,7 +570,8 @@ static void\n expand_arith_overflow_result_store (tree lhs, rtx target,\n \t\t\t\t    machine_mode mode, rtx res)\n {\n-  machine_mode tgtmode = GET_MODE_INNER (GET_MODE (target));\n+  scalar_int_mode tgtmode\n+    = as_a <scalar_int_mode> (GET_MODE_INNER (GET_MODE (target)));\n   rtx lres = res;\n   if (tgtmode != mode)\n     {"}, {"sha": "d1004a2dc5eb73bc9cb7e39c0cfc4f9efb5075ca", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -440,7 +440,8 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n   counter_reg = XEXP (condition, 0);\n   if (GET_CODE (counter_reg) == PLUS)\n     counter_reg = XEXP (counter_reg, 0);\n-  mode = GET_MODE (counter_reg);\n+  /* These patterns must operate on integer counters.  */\n+  mode = as_a <scalar_int_mode> (GET_MODE (counter_reg));\n \n   increment_count = false;\n   switch (GET_CODE (condition))"}, {"sha": "eaf793383f7718f7ac5178f5ad09735ecb6da60d", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -941,15 +941,15 @@ lto_type_for_mode (machine_mode mode, int unsigned_p)\n   if (mode == TYPE_MODE (void_type_node))\n     return void_type_node;\n \n-  if (mode == TYPE_MODE (build_pointer_type (char_type_node)))\n-    return (unsigned_p\n-\t    ? make_unsigned_type (GET_MODE_PRECISION (mode))\n-\t    : make_signed_type (GET_MODE_PRECISION (mode)));\n-\n-  if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n-    return (unsigned_p\n-\t    ? make_unsigned_type (GET_MODE_PRECISION (mode))\n-\t    : make_signed_type (GET_MODE_PRECISION (mode)));\n+  if (mode == TYPE_MODE (build_pointer_type (char_type_node))\n+      || mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n+    {\n+      unsigned int precision\n+\t= GET_MODE_PRECISION (as_a <scalar_int_mode> (mode));\n+      return (unsigned_p\n+\t      ? make_unsigned_type (precision)\n+\t      : make_signed_type (precision));\n+    }\n \n   if (COMPLEX_MODE_P (mode))\n     {"}, {"sha": "c54a56197e2463ebc2295f0948fc458a34ba1112", "filename": "gcc/optabs.c", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -1232,8 +1232,8 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t     it back to the proper size to fit in the broadcast vector.  */\n \t  machine_mode inner_mode = GET_MODE_INNER (mode);\n \t  if (!CONST_INT_P (op1)\n-\t      && (GET_MODE_BITSIZE (inner_mode)\n-\t\t  < GET_MODE_BITSIZE (GET_MODE (op1))))\n+\t      && (GET_MODE_BITSIZE (as_a <scalar_int_mode> (GET_MODE (op1)))\n+\t\t  > GET_MODE_BITSIZE (inner_mode)))\n \t    op1 = force_reg (inner_mode,\n \t\t\t     simplify_gen_unary (TRUNCATE, inner_mode, op1,\n \t\t\t\t\t\t GET_MODE (op1)));\n@@ -1378,11 +1378,13 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && optab_handler (lshr_optab, word_mode) != CODE_FOR_nothing)\n     {\n       unsigned HOST_WIDE_INT shift_mask, double_shift_mask;\n-      machine_mode op1_mode;\n+      scalar_int_mode op1_mode;\n \n       double_shift_mask = targetm.shift_truncation_mask (int_mode);\n       shift_mask = targetm.shift_truncation_mask (word_mode);\n-      op1_mode = GET_MODE (op1) != VOIDmode ? GET_MODE (op1) : word_mode;\n+      op1_mode = (GET_MODE (op1) != VOIDmode\n+\t\t  ? as_a <scalar_int_mode> (GET_MODE (op1))\n+\t\t  : word_mode);\n \n       /* Apply the truncation to constant shifts.  */\n       if (double_shift_mask > 0 && CONST_INT_P (op1))\n@@ -3011,24 +3013,32 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t\t result.  Similarly for clrsb.  */\n \t      if ((unoptab == clz_optab || unoptab == clrsb_optab)\n \t\t  && temp != 0)\n-\t\ttemp = expand_binop\n-\t\t  (wider_mode, sub_optab, temp,\n-\t\t   gen_int_mode (GET_MODE_PRECISION (wider_mode)\n-\t\t\t\t - GET_MODE_PRECISION (mode),\n-\t\t\t\t wider_mode),\n-\t\t   target, true, OPTAB_DIRECT);\n+\t\t{\n+\t\t  scalar_int_mode wider_int_mode\n+\t\t    = as_a <scalar_int_mode> (wider_mode);\n+\t\t  int_mode = as_a <scalar_int_mode> (mode);\n+\t\t  temp = expand_binop\n+\t\t    (wider_mode, sub_optab, temp,\n+\t\t     gen_int_mode (GET_MODE_PRECISION (wider_int_mode)\n+\t\t\t\t   - GET_MODE_PRECISION (int_mode),\n+\t\t\t\t   wider_int_mode),\n+\t\t     target, true, OPTAB_DIRECT);\n+\t\t}\n \n \t      /* Likewise for bswap.  */\n \t      if (unoptab == bswap_optab && temp != 0)\n \t\t{\n-\t\t  gcc_assert (GET_MODE_PRECISION (wider_mode)\n-\t\t\t      == GET_MODE_BITSIZE (wider_mode)\n-\t\t\t      && GET_MODE_PRECISION (mode)\n-\t\t\t\t == GET_MODE_BITSIZE (mode));\n-\n-\t\t  temp = expand_shift (RSHIFT_EXPR, wider_mode, temp,\n-\t\t\t\t       GET_MODE_BITSIZE (wider_mode)\n-\t\t\t\t       - GET_MODE_BITSIZE (mode),\n+\t\t  scalar_int_mode wider_int_mode\n+\t\t    = as_a <scalar_int_mode> (wider_mode);\n+\t\t  int_mode = as_a <scalar_int_mode> (mode);\n+\t\t  gcc_assert (GET_MODE_PRECISION (wider_int_mode)\n+\t\t\t      == GET_MODE_BITSIZE (wider_int_mode)\n+\t\t\t      && GET_MODE_PRECISION (int_mode)\n+\t\t\t\t == GET_MODE_BITSIZE (int_mode));\n+\n+\t\t  temp = expand_shift (RSHIFT_EXPR, wider_int_mode, temp,\n+\t\t\t\t       GET_MODE_BITSIZE (wider_int_mode)\n+\t\t\t\t       - GET_MODE_BITSIZE (int_mode),\n \t\t\t\t       NULL_RTX, true);\n \t\t}\n \n@@ -3256,7 +3266,7 @@ static rtx\n expand_copysign_absneg (scalar_float_mode mode, rtx op0, rtx op1, rtx target,\n \t\t        int bitpos, bool op0_is_abs)\n {\n-  machine_mode imode;\n+  scalar_int_mode imode;\n   enum insn_code icode;\n   rtx sign;\n   rtx_code_label *label;\n@@ -3269,7 +3279,7 @@ expand_copysign_absneg (scalar_float_mode mode, rtx op0, rtx op1, rtx target,\n   icode = optab_handler (signbit_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      imode = insn_data[(int) icode].operand[0].mode;\n+      imode = as_a <scalar_int_mode> (insn_data[(int) icode].operand[0].mode);\n       sign = gen_reg_rtx (imode);\n       emit_unop_insn (icode, sign, op1, UNKNOWN);\n     }\n@@ -3801,10 +3811,10 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \t    continue;\n \n \t  /* Must make sure the size fits the insn's mode.  */\n-\t  if ((CONST_INT_P (size)\n-\t       && INTVAL (size) >= (1 << GET_MODE_BITSIZE (cmp_mode)))\n-\t      || (GET_MODE_BITSIZE (GET_MODE (size))\n-\t\t  > GET_MODE_BITSIZE (cmp_mode)))\n+\t  if (CONST_INT_P (size)\n+\t      ? INTVAL (size) >= (1 << GET_MODE_BITSIZE (cmp_mode))\n+\t      : (GET_MODE_BITSIZE (as_a <scalar_int_mode> (GET_MODE (size)))\n+\t\t > GET_MODE_BITSIZE (cmp_mode)))\n \t    continue;\n \n \t  result_mode = insn_data[cmp_code].operand[0].mode;\n@@ -6979,8 +6989,8 @@ maybe_legitimize_operand (enum insn_code icode, unsigned int opno,\n       goto input;\n \n     case EXPAND_ADDRESS:\n-      gcc_assert (mode != VOIDmode);\n-      op->value = convert_memory_address (mode, op->value);\n+      op->value = convert_memory_address (as_a <scalar_int_mode> (mode),\n+\t\t\t\t\t  op->value);\n       goto input;\n \n     case EXPAND_INTEGER:"}, {"sha": "0f9d240931c4faccca4d06526496fbd9dd256e4b", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -1189,8 +1189,9 @@ const_scalar_int_operand (rtx op, machine_mode mode)\n \n   if (mode != VOIDmode)\n     {\n-      int prec = GET_MODE_PRECISION (mode);\n-      int bitsize = GET_MODE_BITSIZE (mode);\n+      scalar_int_mode int_mode = as_a <scalar_int_mode> (mode);\n+      int prec = GET_MODE_PRECISION (int_mode);\n+      int bitsize = GET_MODE_BITSIZE (int_mode);\n \n       if (CONST_WIDE_INT_NUNITS (op) * HOST_BITS_PER_WIDE_INT > bitsize)\n \treturn 0;"}, {"sha": "dfb17486a4782ee838ad7ede8f98ea9838cd7cb5", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -5799,7 +5799,7 @@ get_address_mode (rtx mem)\n   gcc_assert (MEM_P (mem));\n   mode = GET_MODE (XEXP (mem, 0));\n   if (mode != VOIDmode)\n-    return mode;\n+    return as_a <scalar_int_mode> (mode);\n   return targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n }\n \f"}, {"sha": "3c81cb8733b410a1ec1ef90d44a402734dfafb63", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -926,7 +926,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n {\n   enum rtx_code reversed;\n   rtx temp;\n-  scalar_int_mode inner, int_mode, op0_mode;\n+  scalar_int_mode inner, int_mode, op_mode, op0_mode;\n \n   switch (code)\n     {\n@@ -1162,26 +1162,27 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t  && XEXP (op, 1) == const0_rtx\n \t  && is_a <scalar_int_mode> (GET_MODE (XEXP (op, 0)), &inner))\n \t{\n+\t  int_mode = as_a <scalar_int_mode> (mode);\n \t  int isize = GET_MODE_PRECISION (inner);\n \t  if (STORE_FLAG_VALUE == 1)\n \t    {\n \t      temp = simplify_gen_binary (ASHIFTRT, inner, XEXP (op, 0),\n \t\t\t\t\t  GEN_INT (isize - 1));\n-\t      if (mode == inner)\n+\t      if (int_mode == inner)\n \t\treturn temp;\n-\t      if (GET_MODE_PRECISION (mode) > isize)\n-\t\treturn simplify_gen_unary (SIGN_EXTEND, mode, temp, inner);\n-\t      return simplify_gen_unary (TRUNCATE, mode, temp, inner);\n+\t      if (GET_MODE_PRECISION (int_mode) > isize)\n+\t\treturn simplify_gen_unary (SIGN_EXTEND, int_mode, temp, inner);\n+\t      return simplify_gen_unary (TRUNCATE, int_mode, temp, inner);\n \t    }\n \t  else if (STORE_FLAG_VALUE == -1)\n \t    {\n \t      temp = simplify_gen_binary (LSHIFTRT, inner, XEXP (op, 0),\n \t\t\t\t\t  GEN_INT (isize - 1));\n-\t      if (mode == inner)\n+\t      if (int_mode == inner)\n \t\treturn temp;\n-\t      if (GET_MODE_PRECISION (mode) > isize)\n-\t\treturn simplify_gen_unary (ZERO_EXTEND, mode, temp, inner);\n-\t      return simplify_gen_unary (TRUNCATE, mode, temp, inner);\n+\t      if (GET_MODE_PRECISION (int_mode) > isize)\n+\t\treturn simplify_gen_unary (ZERO_EXTEND, int_mode, temp, inner);\n+\t      return simplify_gen_unary (TRUNCATE, int_mode, temp, inner);\n \t    }\n \t}\n       break;\n@@ -1501,12 +1502,13 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t  && is_a <scalar_int_mode> (mode, &int_mode)\n \t  && CONST_INT_P (XEXP (op, 1))\n \t  && XEXP (XEXP (op, 0), 1) == XEXP (op, 1)\n-\t  && GET_MODE_BITSIZE (GET_MODE (op)) > INTVAL (XEXP (op, 1)))\n+\t  && (op_mode = as_a <scalar_int_mode> (GET_MODE (op)),\n+\t      GET_MODE_BITSIZE (op_mode) > INTVAL (XEXP (op, 1))))\n \t{\n \t  scalar_int_mode tmode;\n \t  gcc_assert (GET_MODE_BITSIZE (int_mode)\n-\t\t      > GET_MODE_BITSIZE (GET_MODE (op)));\n-\t  if (int_mode_for_size (GET_MODE_BITSIZE (GET_MODE (op))\n+\t\t      > GET_MODE_BITSIZE (op_mode));\n+\t  if (int_mode_for_size (GET_MODE_BITSIZE (op_mode)\n \t\t\t\t - INTVAL (XEXP (op, 1)), 1).exists (&tmode))\n \t    {\n \t      rtx inner =\n@@ -1618,10 +1620,11 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t  && is_a <scalar_int_mode> (mode, &int_mode)\n \t  && CONST_INT_P (XEXP (op, 1))\n \t  && XEXP (XEXP (op, 0), 1) == XEXP (op, 1)\n-\t  && GET_MODE_PRECISION (GET_MODE (op)) > INTVAL (XEXP (op, 1)))\n+\t  && (op_mode = as_a <scalar_int_mode> (GET_MODE (op)),\n+\t      GET_MODE_PRECISION (op_mode) > INTVAL (XEXP (op, 1))))\n \t{\n \t  scalar_int_mode tmode;\n-\t  if (int_mode_for_size (GET_MODE_PRECISION (GET_MODE (op))\n+\t  if (int_mode_for_size (GET_MODE_PRECISION (op_mode)\n \t\t\t\t - INTVAL (XEXP (op, 1)), 1).exists (&tmode))\n \t    {\n \t      rtx inner =\n@@ -5395,10 +5398,10 @@ simplify_cond_clz_ctz (rtx x, rtx_code cmp_code, rtx true_val, rtx false_val)\n     return NULL_RTX;\n \n   HOST_WIDE_INT op_val;\n-  if (((op_code == CLZ\n-\t&& CLZ_DEFINED_VALUE_AT_ZERO (GET_MODE (on_nonzero), op_val))\n-      || (op_code == CTZ\n-\t  && CTZ_DEFINED_VALUE_AT_ZERO (GET_MODE (on_nonzero), op_val)))\n+  scalar_int_mode mode ATTRIBUTE_UNUSED\n+    = as_a <scalar_int_mode> (GET_MODE (XEXP (on_nonzero, 0)));\n+  if (((op_code == CLZ && CLZ_DEFINED_VALUE_AT_ZERO (mode, op_val))\n+       || (op_code == CTZ && CTZ_DEFINED_VALUE_AT_ZERO (mode, op_val)))\n       && op_val == INTVAL (on_zero))\n     return on_nonzero;\n "}, {"sha": "7f26e61acc7b20bbc2c23070476d0e4cbe5ce59a", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -625,7 +625,9 @@ get_nl_goto_field (struct nesting_info *info)\n       else\n \ttype = lang_hooks.types.type_for_mode (Pmode, 1);\n \n-      size = GET_MODE_SIZE (STACK_SAVEAREA_MODE (SAVE_NONLOCAL));\n+      scalar_int_mode mode\n+\t= as_a <scalar_int_mode> (STACK_SAVEAREA_MODE (SAVE_NONLOCAL));\n+      size = GET_MODE_SIZE (mode);\n       size = size / GET_MODE_SIZE (Pmode);\n       size = size + 1;\n "}, {"sha": "92a32c82a0033b2a4b92dd876669d037d35f5dd4", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -10201,6 +10201,7 @@ tree\n build_vector_type_for_mode (tree innertype, machine_mode mode)\n {\n   int nunits;\n+  unsigned int bitsize;\n \n   switch (GET_MODE_CLASS (mode))\n     {\n@@ -10215,11 +10216,9 @@ build_vector_type_for_mode (tree innertype, machine_mode mode)\n \n     case MODE_INT:\n       /* Check that there are no leftover bits.  */\n-      gcc_assert (GET_MODE_BITSIZE (mode)\n-\t\t  % TREE_INT_CST_LOW (TYPE_SIZE (innertype)) == 0);\n-\n-      nunits = GET_MODE_BITSIZE (mode)\n-\t       / TREE_INT_CST_LOW (TYPE_SIZE (innertype));\n+      bitsize = GET_MODE_BITSIZE (as_a <scalar_int_mode> (mode));\n+      gcc_assert (bitsize % TREE_INT_CST_LOW (TYPE_SIZE (innertype)) == 0);\n+      nunits = bitsize / TREE_INT_CST_LOW (TYPE_SIZE (innertype));\n       break;\n \n     default:"}, {"sha": "9909c4ce0bd6e0c505f3e9e89c1e3906fe019155", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ad039d8d75666f4f188a913033da36206503b8/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c7ad039d8d75666f4f188a913033da36206503b8", "patch": "@@ -991,7 +991,8 @@ use_narrower_mode (rtx x, machine_mode mode, machine_mode wmode)\n       /* Ensure shift amount is not wider than mode.  */\n       if (GET_MODE (op1) == VOIDmode)\n \top1 = lowpart_subreg (mode, op1, wmode);\n-      else if (GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (GET_MODE (op1)))\n+      else if (GET_MODE_PRECISION (mode)\n+\t       < GET_MODE_PRECISION (as_a <scalar_int_mode> (GET_MODE (op1))))\n \top1 = lowpart_subreg (mode, op1, GET_MODE (op1));\n       return simplify_gen_binary (ASHIFT, mode, op0, op1);\n     default:"}]}