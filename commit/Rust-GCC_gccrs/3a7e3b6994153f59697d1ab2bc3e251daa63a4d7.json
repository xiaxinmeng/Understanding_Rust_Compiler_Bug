{"sha": "3a7e3b6994153f59697d1ab2bc3e251daa63a4d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E3ZTNiNjk5NDE1M2Y1OTY5N2QxYWIyYmMzZTI1MWRhYTYzYTRkNw==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-05-10T18:26:51Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-05-10T18:26:51Z"}, "message": "re PR fortran/27470 (wrong memory allocator for derived types)\n\n2005-05-10  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/27470\n\t* trans-array.c(gfc_array_allocate):  If ref->next exists\n\tthat is if there is a statement like ALLOCATE(foo%bar(2)),\n\tF95 rules require that bar should be a pointer.\n\n2005-05-10  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/27470\n\t* gfortran.dg/multiple_allocation_2.f90:  New test case.\n\nFrom-SVN: r113680", "tree": {"sha": "33ede0b0a98f6e88dc6d67b29051b2c929405f93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33ede0b0a98f6e88dc6d67b29051b2c929405f93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/comments", "author": null, "committer": null, "parents": [{"sha": "0e2df6898a99a0a0f08ae8439e738049f8134293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e2df6898a99a0a0f08ae8439e738049f8134293", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e2df6898a99a0a0f08ae8439e738049f8134293"}], "stats": {"total": 44, "additions": 43, "deletions": 1}, "files": [{"sha": "9fbde4d3b2249263fa6e62113d2970a73492916f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3a7e3b6994153f59697d1ab2bc3e251daa63a4d7", "patch": "@@ -1,3 +1,10 @@\n+2005-05-10  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/27470\n+\t* trans-array.c(gfc_array_allocate):  If ref->next exists\n+\tthat is if there is a statement like ALLOCATE(foo%bar(2)),\n+\tF95 rules require that bar should be a pointer.\n+\n 2006-05-10  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/20460"}, {"sha": "7e9d5a65ef0503f80e30c13d1f2f2b311c5728ee", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=3a7e3b6994153f59697d1ab2bc3e251daa63a4d7", "patch": "@@ -3068,9 +3068,20 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   gfc_expr **upper;\n   gfc_ref *ref;\n   int allocatable_array;\n+  int must_be_pointer;\n \n   ref = expr->ref;\n \n+  /* In Fortran 95, components can only contain pointers, so that,\n+     in ALLOCATE (foo%bar(2)), bar must be a pointer component.\n+     We test this by checking for ref->next.\n+     An implementation of TR 15581 would need to change this.  */\n+\n+  if (ref)\n+    must_be_pointer = ref->next != NULL;\n+  else\n+    must_be_pointer = 0;\n+  \n   /* Find the last reference in the chain.  */\n   while (ref && ref->next != NULL)\n     {\n@@ -3113,7 +3124,10 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   tmp = gfc_conv_descriptor_data_addr (se->expr);\n   pointer = gfc_evaluate_now (tmp, &se->pre);\n \n-  allocatable_array = expr->symtree->n.sym->attr.allocatable;\n+  if (must_be_pointer)\n+    allocatable_array = 0;\n+  else\n+    allocatable_array = expr->symtree->n.sym->attr.allocatable;\n \n   if (TYPE_PRECISION (gfc_array_index_type) == 32)\n     {"}, {"sha": "872070dccdf3854e3be20ef60545e0ebc138d13d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a7e3b6994153f59697d1ab2bc3e251daa63a4d7", "patch": "@@ -1,3 +1,8 @@\n+2005-05-10  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/27470\n+\t* gfortran.dg/multiple_allocation_2.f90:  New test case.\n+\n 2006-05-10  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* gcc.target/arm/pr27387.C: Fix a comment typo."}, {"sha": "617405be110e0e640d6b831a86443a2225c85fc0", "filename": "gcc/testsuite/gfortran.dg/multiple_allocation_2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a7e3b6994153f59697d1ab2bc3e251daa63a4d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_2.f90?ref=3a7e3b6994153f59697d1ab2bc3e251daa63a4d7", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! PR 27470: This used fail because of confusion between\n+!           mol (allocatable) and mol(1)%array(:) (pointer).\n+!           Derived from a test case by FX Coudert.\n+PROGRAM MAIN\n+  TYPE foo\n+    INTEGER, DIMENSION(:), POINTER :: array\n+  END TYPE foo\n+\n+  type(foo),allocatable,dimension(:) :: mol\n+\n+  ALLOCATE (mol(1))\n+  ALLOCATE (mol(1)%array(5))\n+  ALLOCATE (mol(1)%array(5))\n+\n+  END"}]}