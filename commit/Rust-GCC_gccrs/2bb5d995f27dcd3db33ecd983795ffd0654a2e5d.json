{"sha": "2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJiNWQ5OTVmMjdkY2QzZGIzM2VjZDk4Mzc5NWZmZDA2NTRhMmU1ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-07-10T07:16:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-07-10T07:16:23Z"}, "message": "init.c (build_new_1): Bail early if the call to new fails.\n\n        * init.c (build_new_1): Bail early if the call to new fails.\n\n        * decl.c (compute_array_index_type): Check specifically for\n        an INTEGER_CST, not just TREE_CONSTANT.\n\n        * decl.c (duplicate_decls): Don't call duplicate_decls on\n        the DECL_TEMPLATE_RESULT.\n        (decls_match): Return 0 if the DECL_TEMPLATE_RESULTs have different\n        codes.\n\n        * error.c (dump_template_bindings): Don't crash if we had an\n        invalid argument list.\n\n        * typeck.c (c_expand_start_case): Do narrowing here.\n        * semantics.c (finish_switch_cond): Not here.\n\n        * parse.y (asm_clobbers): Do string concatenation.\n\nFrom-SVN: r34938", "tree": {"sha": "8c219d55310b63ccdd999bc2385bfe4a962d9e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c219d55310b63ccdd999bc2385bfe4a962d9e9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/comments", "author": null, "committer": null, "parents": [{"sha": "089acd579b8079afb590c101117ea76be13c7093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089acd579b8079afb590c101117ea76be13c7093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/089acd579b8079afb590c101117ea76be13c7093"}], "stats": {"total": 3328, "additions": 1703, "deletions": 1625}, "files": [{"sha": "4d4c218d4b5ee4f70d07df023f6a18e93bc80cd0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "patch": "@@ -1,3 +1,25 @@\n+2000-07-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* init.c (build_new_1): Bail early if the call to new fails.\n+\n+\t* decl.c (compute_array_index_type): Check specifically for \n+\tan INTEGER_CST, not just TREE_CONSTANT.\n+\n+\t* decl.c (duplicate_decls): Don't call duplicate_decls on \n+\tthe DECL_TEMPLATE_RESULT.\n+\t(decls_match): Return 0 if the DECL_TEMPLATE_RESULTs have different\n+\tcodes.\n+\n+\t* error.c (dump_template_bindings): Don't crash if we had an\n+\tinvalid argument list.\n+\n+\t* typeck.c (c_expand_start_case): Do narrowing here.\n+\t* semantics.c (finish_switch_cond): Not here.\n+\n+2000-07-09  Hidvegi Zoli  <hzoli@austin.ibm.com>\n+\n+\t* parse.y (asm_clobbers): Do string concatenation.\n+\n 2000-07-09  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (pushtag): Don't put local classes in template functions\n@@ -1114,6 +1136,43 @@ Mon Jun  5 06:48:55 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(tinfo_base_init):  Likewise.  Mangle typeinfo string name with\n \tmangle_typeinfo_string_for_type.\n \t\n+2000-06-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (TMPL_ARGS_LEVEL): Clarify comment.\n+\t(INNERMOST_TEMPLATE_ARGS): New macro.\n+\t(innermost_args): Remove.\n+\t(get_innermost_template_args): New function.\n+\t* decl2.c (arg_assoc_class): Use INNERMOST_TEMPLATE_ARGS.\n+\t* error.c (dump_function_decl): Be caution when using\n+\tmost_general_template.\n+\t* method.c (build_template_parm_names):  Use\n+\tINNERMOST_TEMPLATE_ARGS.\n+\t* pt.c (add_to_template_args): Tidy comment\n+\t(get_innermost_template_args): New function.\n+\t(check_explicit_specialization): Clear DECL_INITIAL for a new\n+\tspecialization.\n+\t(process_partial_specialization): Use INNERMOST_TEMPLATE_ARGS.\n+\tTidy.\n+\t(push_template_decl): Always register specializations of the most\n+\tgeneral template.\n+\t(convert_template_argument): Use INNERMOST_TEMPLATE_ARGS.\n+\t(coerce_template_parms): Likewise.\n+\t(lookup_template_class): Likewise.\n+\t(innermost_args): Remove.\n+\t(tsubst_decl): Use INNERMOST_TEMPLATE_ARGS.\n+\t(tsubst_decl): Handle tricky specializations.  Use\n+\tget_innermost_template_args.\n+\t(instantiate_template): Simplify handling of partial\n+\tinstantiations.\n+\t(get_class_bindings): Use INNERMOST_TEMPLATE_ARGS.\n+\t(most_general_template): Reimplement, in a more straightforward\n+\tmanner.\n+\t(regenerate_decl_from_template): Tweak formatting.  Use\n+\tTMPL_ARGS_DEPTH for clarity.\n+\t(set_mangled_name_for_template_decl): Use INNERMOST_ARGS.\n+\t\n+\t* dump.c (dequeue_and_dump): Dump information about thunks.\n+\n 2000-06-01  Richard Henderson  <rth@cygnus.com>\n \n \t* decl.c (init_decl_processing): Set lang_get_alias_set first thing."}, {"sha": "b09dab3d95e269441d4e57a758b5d696ef7ad27b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "patch": "@@ -3050,6 +3050,10 @@ decls_match (newdecl, olddecl)\n \t\t\t\tDECL_TEMPLATE_PARMS (olddecl)))\n \treturn 0;\n \n+      if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl))\n+\t  != TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)))\n+\treturn 0;\n+\n       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n \ttypes_match = 1;\n       else\n@@ -3499,9 +3503,6 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n-      if (! duplicate_decls (DECL_TEMPLATE_RESULT (newdecl),\n-\t\t\t     DECL_TEMPLATE_RESULT (olddecl)))\n-\tcp_error (\"invalid redeclaration of %D\", newdecl);\n       TREE_TYPE (olddecl) = TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl));\n       DECL_TEMPLATE_SPECIALIZATIONS (olddecl)\n \t= chainon (DECL_TEMPLATE_SPECIALIZATIONS (olddecl),\n@@ -9341,7 +9342,7 @@ compute_array_index_type (name, size)\n     }\n \n   /* Normally, the array-bound will be a constant.  */\n-  if (TREE_CONSTANT (size))\n+  if (TREE_CODE (size) == INTEGER_CST)\n     {\n       /* Check to see if the array bound overflowed.  Make that an\n \t error, no matter how generous we're being.  */\n@@ -9372,6 +9373,15 @@ compute_array_index_type (name, size)\n \t    cp_pedwarn (\"ISO C++ forbids zero-size array\");\n \t}\n     }\n+  else if (TREE_CONSTANT (size))\n+    {\n+      /* `(int) &fn' is not a valid array bound.  */\n+      if (name)\n+\tcp_error (\"size of array `%D' is not an integral constant-expression\",\n+\t\t  name);\n+      else\n+\tcp_error (\"size of array is not an integral constant-expression\");\n+    }\n \n   /* Compute the index of the largest element in the array.  It is\n      one less than the number of elements in the array.  */"}, {"sha": "74a798b28d094c716885f43b35583cfee5371b36", "filename": "gcc/cp/error.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "patch": "@@ -305,7 +305,15 @@ dump_template_bindings (parms, args)\n \n       for (i = 0; i < TREE_VEC_LENGTH (p); ++i)\n \t{\n-\t  tree arg = TMPL_ARG (args, lvl, arg_idx);\n+\t  tree arg = NULL_TREE;\n+\n+\t  /* Don't crash if we had an invalid argument list.  */\n+\t  if (TMPL_ARGS_DEPTH (args) >= lvl)\n+\t    {\n+\t      tree lvl_args = TMPL_ARGS_LEVEL (args, lvl);\n+\t      if (NUM_TMPL_ARGS (lvl_args) > arg_idx)\n+\t\targ = TREE_VEC_ELT (lvl_args, arg_idx);\n+\t    }\n \n \t  if (need_comma)\n \t    OB_PUTS (\", \");"}, {"sha": "d995e060efc52bbe8d9f1bf804373c05f4ee2aa9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "patch": "@@ -2356,6 +2356,9 @@ build_new_1 (exp)\n       rval = cp_convert (build_pointer_type (true_type), rval);\n     }\n \n+  if (rval == error_mark_node)\n+    return error_mark_node;\n+\n   /*        unless an allocation function is declared with an empty  excep-\n      tion-specification  (_except.spec_),  throw(), it indicates failure to\n      allocate storage by throwing a bad_alloc exception  (clause  _except_,"}, {"sha": "c0a984474ee98b5ce7d9844eef6b280a2bcd3d39", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 1599, "deletions": 1601, "changes": 3200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=2bb5d995f27dcd3db33ecd983795ffd0654a2e5d"}, {"sha": "fde3807f12b1133149595b5043c784a6e9136f04", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "patch": "@@ -3536,10 +3536,10 @@ asm_operand:\n \t;\n \n asm_clobbers:\n-\t  STRING\n-\t\t{ $$ = tree_cons (NULL_TREE, $$, NULL_TREE); }\n-\t| asm_clobbers ',' STRING\n-\t\t{ $$ = tree_cons (NULL_TREE, $3, $$); }\n+\t  string\n+\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($1), NULL_TREE);}\n+\t| asm_clobbers ',' string\n+\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($3), $1); }\n \t;\n \n /* This is what appears inside the parens in a function declarator."}, {"sha": "ec5153fbc3b78c8472521f835c8710ee80823387", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "patch": "@@ -564,21 +564,8 @@ finish_switch_cond (cond, switch_stmt)\n \t}\n       if (cond != error_mark_node)\n \t{\n-\t  tree idx;\n-\t  tree type;\n-\t  \n \t  cond = default_conversion (cond);\n-\t  type = TREE_TYPE (cond);\n-\t  idx = get_unwidened (cond, 0);\n-\t  /* We can't strip a conversion from a signed type to an unsigned,\n-\t     because if we did, int_fits_type_p would do the wrong thing\n-\t     when checking case values for being in range,\n-\t     and it's too hard to do the right thing.  */\n-\t  if (TREE_UNSIGNED (TREE_TYPE (cond)) \n-\t      == TREE_UNSIGNED (TREE_TYPE (idx)))\n-\t    cond = idx;\n-\t  \n-\t  cond = fold (build1 (CLEANUP_POINT_EXPR, type, cond));\n+\t  cond = fold (build1 (CLEANUP_POINT_EXPR, TREE_TYPE (cond), cond));\n \t}\n     }\n   FINISH_COND (cond, switch_stmt, SWITCH_COND (switch_stmt));"}, {"sha": "a12ebe9aac00d04df9c3abe89704cc6c6355ef76", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb5d995f27dcd3db33ecd983795ffd0654a2e5d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2bb5d995f27dcd3db33ecd983795ffd0654a2e5d", "patch": "@@ -6905,7 +6905,20 @@ tree\n c_expand_start_case (exp)\n      tree exp;\n {\n-  expand_start_case (1, exp, TREE_TYPE (exp), \"switch statement\");\n+  tree type;\n+  tree index;\n+\n+  type = TREE_TYPE (exp);\n+  index = get_unwidened (exp, NULL_TREE);\n+  /* We can't strip a conversion from a signed type to an unsigned,\n+     because if we did, int_fits_type_p would do the wrong thing\n+     when checking case values for being in range,\n+     and it's too hard to do the right thing.  */\n+  if (TREE_UNSIGNED (TREE_TYPE (exp))\n+      == TREE_UNSIGNED (TREE_TYPE (index)))\n+    exp = index;\n+\n+  expand_start_case (1, exp, type, \"switch statement\");\n \n   return exp;\n }"}]}