{"sha": "c7e1befad2b375b2245dca11329df92b600ef3ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdlMWJlZmFkMmIzNzViMjI0NWRjYTExMzI5ZGY5MmI2MDBlZjNlZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-06-28T18:26:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-06-28T18:26:12Z"}, "message": "ipa-devirt.c (set_type_binfo): New function.\n\n\t* ipa-devirt.c (set_type_binfo): New function.\n\t(add_type_duplicate): Use it.\n\t(get_odr_type): Sanity check that binfos points to main variants.\n\t(get_class_context): Be sure the context's outer_type is main variant.\n\t(contains_type_p): Walk main variant.\n\t(get_polymorphic_call_info_for_decl): Set outer_type to be main variant.\n\t(get_polymorphic_call_info): Likewise.\n\t(possible_polymorphic_call_targets): Sanity check that we operate on main\n\tvariant.\n\nFrom-SVN: r212107", "tree": {"sha": "cc45d33f98617ef4730134a0e803d45a3e94ce98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc45d33f98617ef4730134a0e803d45a3e94ce98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7e1befad2b375b2245dca11329df92b600ef3ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e1befad2b375b2245dca11329df92b600ef3ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e1befad2b375b2245dca11329df92b600ef3ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e1befad2b375b2245dca11329df92b600ef3ed/comments", "author": null, "committer": null, "parents": [{"sha": "7ae2e72c93c2c5dfca4ecc64fcda12a558b4332c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ae2e72c93c2c5dfca4ecc64fcda12a558b4332c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ae2e72c93c2c5dfca4ecc64fcda12a558b4332c"}], "stats": {"total": 58, "additions": 48, "deletions": 10}, "files": [{"sha": "f5d9983d1d11e562d672bcd703d85aaaffe721d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e1befad2b375b2245dca11329df92b600ef3ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e1befad2b375b2245dca11329df92b600ef3ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7e1befad2b375b2245dca11329df92b600ef3ed", "patch": "@@ -1,3 +1,15 @@\n+2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (set_type_binfo): New function.\n+\t(add_type_duplicate): Use it.\n+\t(get_odr_type): Sanity check that binfos points to main variants.\n+\t(get_class_context): Be sure the context's outer_type is main variant.\n+\t(contains_type_p): Walk main variant.\n+\t(get_polymorphic_call_info_for_decl): Set outer_type to be main variant.\n+\t(get_polymorphic_call_info): Likewise.\n+\t(possible_polymorphic_call_targets): Sanity check that we operate on main\n+\tvariant.\n+\n 2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* stor-layout.c (finish_builtin_struct): Copy fields into"}, {"sha": "d893ff5bec4915333296c5709e1d33e5aedc17b5", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e1befad2b375b2245dca11329df92b600ef3ed/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e1befad2b375b2245dca11329df92b600ef3ed/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=c7e1befad2b375b2245dca11329df92b600ef3ed", "patch": "@@ -334,6 +334,17 @@ static odr_hash_type *odr_hash;\n static GTY(()) vec <odr_type, va_gc> *odr_types_ptr;\n #define odr_types (*odr_types_ptr)\n \n+/* Set TYPE_BINFO of TYPE and its variants to BINFO.  */\n+void\n+set_type_binfo (tree type, tree binfo)\n+{\n+  for (; type; type = TYPE_NEXT_VARIANT (type))\n+    if (COMPLETE_TYPE_P (type))\n+      TYPE_BINFO (type) = binfo;\n+    else\n+      gcc_assert (!TYPE_BINFO (type));\n+}\n+\n /* TYPE is equivalent to VAL by ODR, but its tree representation differs\n    from VAL->type.  This may happen in LTO where tree merging did not merge\n    all variants of the same type.  It may or may not mean the ODR violation.\n@@ -446,16 +457,17 @@ add_type_duplicate (odr_type val, tree type)\n \t    {\n \t      unsigned int i;\n \n-\t      TYPE_BINFO (val->type) = TYPE_BINFO (type);\n+\t      set_type_binfo (val->type, TYPE_BINFO (type));\n \t      for (i = 0; i < val->types->length (); i++)\n \t\t{\n \t\t  if (TYPE_BINFO ((*val->types)[i])\n \t\t      == master_binfo)\n-\t\t    TYPE_BINFO ((*val->types)[i]) = TYPE_BINFO (type);\n+\t\t    set_type_binfo ((*val->types)[i], TYPE_BINFO (type));\n \t\t}\n+\t      BINFO_TYPE (TYPE_BINFO (type)) = val->type;\n \t    }\n \t  else\n-\t    TYPE_BINFO (type) = master_binfo;\n+\t    set_type_binfo (type, master_binfo);\n \t}\n     }\n }\n@@ -495,6 +507,7 @@ get_odr_type (tree type, bool insert)\n \n       val = ggc_cleared_alloc<odr_type_d> ();\n       val->type = type;\n+      gcc_assert (BINFO_TYPE (TYPE_BINFO (val->type)) = type);\n       val->bases = vNULL;\n       val->derived_types = vNULL;\n       val->anonymous_namespace = type_in_anonymous_namespace_p (type);\n@@ -1102,7 +1115,7 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t  if (!fld)\n \t    goto give_up;\n \n-\t  type = TREE_TYPE (fld);\n+\t  type = TYPE_MAIN_VARIANT (TREE_TYPE (fld));\n \t  offset -= pos;\n \t  /* DECL_ARTIFICIAL represents a basetype.  */\n \t  if (!DECL_ARTIFICIAL (fld))\n@@ -1116,7 +1129,7 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t}\n       else if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n-\t  tree subtype = TREE_TYPE (type);\n+\t  tree subtype = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n \n \t  /* Give up if we don't know array size.  */\n \t  if (!tree_fits_shwi_p (TYPE_SIZE (subtype))\n@@ -1159,7 +1172,8 @@ static bool\n contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n \t\t tree otr_type)\n {\n-  ipa_polymorphic_call_context context = {offset, outer_type,\n+  ipa_polymorphic_call_context context = {offset,\n+\t\t\t\t\t  TYPE_MAIN_VARIANT (outer_type),\n \t\t\t\t\t  false, true};\n   return get_class_context (&context, otr_type);\n }\n@@ -1272,7 +1286,7 @@ get_polymorphic_call_info_for_decl (ipa_polymorphic_call_context *context,\n {\n   gcc_assert (DECL_P (base));\n \n-  context->outer_type = TREE_TYPE (base);\n+  context->outer_type = TYPE_MAIN_VARIANT (TREE_TYPE (base));\n   context->offset = offset;\n   /* Make very conservative assumption that all objects\n      may be in construction. \n@@ -1329,7 +1343,7 @@ get_polymorphic_call_info (tree fndecl,\n   *otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (ref));\n \n   /* Set up basic info in case we find nothing interesting in the analysis.  */\n-  context->outer_type = *otr_type;\n+  context->outer_type = TYPE_MAIN_VARIANT (*otr_type);\n   context->offset = 0;\n   base_pointer = OBJ_TYPE_REF_OBJECT (ref);\n   context->maybe_derived_type = true;\n@@ -1415,7 +1429,8 @@ get_polymorphic_call_info (tree fndecl,\n       if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE\n \t  && SSA_NAME_VAR (base_pointer) == DECL_ARGUMENTS (fndecl))\n \t{\n-\t  context->outer_type = TREE_TYPE (TREE_TYPE (base_pointer));\n+\t  context->outer_type\n+\t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n \t  gcc_assert (TREE_CODE (context->outer_type) == RECORD_TYPE);\n \n \t  /* Dynamic casting has possibly upcasted the type\n@@ -1450,7 +1465,8 @@ get_polymorphic_call_info (tree fndecl,\n \t object.  */\n       if (DECL_BY_REFERENCE (SSA_NAME_VAR (base_pointer)))\n \t{\n-\t  context->outer_type = TREE_TYPE (TREE_TYPE (base_pointer));\n+\t  context->outer_type\n+\t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n \t  gcc_assert (!POINTER_TYPE_P (context->outer_type));\n \t  /* Only type inconsistent programs can have otr_type that is\n \t     not part of outer type.  */\n@@ -1599,6 +1615,8 @@ possible_polymorphic_call_targets (tree otr_type,\n   bool can_refer;\n   bool skipped = false;\n \n+  otr_type = TYPE_MAIN_VARIANT (otr_type);\n+\n   /* If ODR is not initialized, return empty incomplete list.  */\n   if (!odr_hash)\n     {\n@@ -1625,6 +1643,10 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   type = get_odr_type (otr_type, true);\n \n+  /* Recording type variants would wast results cache.  */\n+  gcc_assert (!context.outer_type\n+\t      || TYPE_MAIN_VARIANT (context.outer_type) == context.outer_type);\n+\n   /* Lookup the outer class type we want to walk.  */\n   if (context.outer_type\n       && !get_class_context (&context, otr_type))\n@@ -1638,6 +1660,10 @@ possible_polymorphic_call_targets (tree otr_type,\n       return nodes;\n     }\n \n+  /* Check that get_class_context kept the main variant.  */\n+  gcc_assert (!context.outer_type\n+\t      || TYPE_MAIN_VARIANT (context.outer_type) == context.outer_type);\n+\n   /* We canonicalize our query, so we do not need extra hashtable entries.  */\n \n   /* Without outer type, we have no use for offset.  Just do the"}]}