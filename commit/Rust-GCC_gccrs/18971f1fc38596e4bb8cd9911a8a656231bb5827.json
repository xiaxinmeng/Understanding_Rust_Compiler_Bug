{"sha": "18971f1fc38596e4bb8cd9911a8a656231bb5827", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg5NzFmMWZjMzg1OTZlNGJiOGNkOTkxMWE4YTY1NjIzMWJiNTgyNw==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-10-08T03:41:14Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-10-08T03:41:14Z"}, "message": "regex_executor.h: Add _TodoList class.\n\n2013-10-08  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex_executor.h: Add _TodoList class.\n\t* include/bits/regex_executor.tcc (_BFSExecutor<>::_M_main): Add\n\t_M_match_stack and _M_stack to make everything faster. Break if\n\t_M_stack is empty, to reduce unnecessary idling.\n\t* testsuite/performance/28_regex/split.cc: New.\n\nFrom-SVN: r203261", "tree": {"sha": "c51d1ef785747b8da48cb36306e3aa117ac49f71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c51d1ef785747b8da48cb36306e3aa117ac49f71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18971f1fc38596e4bb8cd9911a8a656231bb5827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18971f1fc38596e4bb8cd9911a8a656231bb5827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18971f1fc38596e4bb8cd9911a8a656231bb5827", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18971f1fc38596e4bb8cd9911a8a656231bb5827/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59a2a4e2de85a70c00fadea0ed9b608f1c90ae37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a2a4e2de85a70c00fadea0ed9b608f1c90ae37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a2a4e2de85a70c00fadea0ed9b608f1c90ae37"}], "stats": {"total": 317, "additions": 234, "deletions": 83}, "files": [{"sha": "4d6906d5ef4f6b2fcd61194ebbd31e87f21b7dfc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18971f1fc38596e4bb8cd9911a8a656231bb5827/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18971f1fc38596e4bb8cd9911a8a656231bb5827/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=18971f1fc38596e4bb8cd9911a8a656231bb5827", "patch": "@@ -1,3 +1,11 @@\n+2013-10-08  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex_executor.h: Add _TodoList class.\n+\t* include/bits/regex_executor.tcc (_BFSExecutor<>::_M_main): Add\n+\t_M_match_stack and _M_stack to make everything faster. Break if\n+\t_M_stack is empty, to reduce unnecessary idling.\n+\t* testsuite/performance/28_regex/split.cc: New.\n+\n 2013-10-06  Tim Shen  <timshen91@gmail.com>\n \n \t* include/bits/regex.h: (regex_token_iterator<>::regex_token_iterator):"}, {"sha": "462643779f2e650eee039b23d442a03dbd6cfbe7", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18971f1fc38596e4bb8cd9911a8a656231bb5827/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18971f1fc38596e4bb8cd9911a8a656231bb5827/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=18971f1fc38596e4bb8cd9911a8a656231bb5827", "patch": "@@ -102,22 +102,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       bool\n-      _M_search()\n-      {\n-\tif (_M_flags & regex_constants::match_continuous)\n-\t  return _M_search_from_first();\n-\tauto __cur = _M_begin;\n-\tdo\n-\t  {\n-\t    _M_match_mode = false;\n-\t    _M_init(__cur);\n-\t    if (_M_main())\n-\t      return true;\n-\t  }\n-\t// Continue when __cur == _M_end\n-\twhile (__cur++ != _M_end);\n-\treturn false;\n-      }\n+      _M_search();\n \n       bool\n       _M_is_word(_CharT __ch) const\n@@ -346,6 +331,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n       typedef std::unique_ptr<_ResultsEntry>               _ResultsPtr;\n \n+      class _TodoList\n+      {\n+      public:\n+\texplicit\n+\t_TodoList(size_t __sz)\n+\t: _M_states(), _M_exists(__sz, false)\n+\t{ }\n+\n+\tvoid _M_push(_StateIdT __u)\n+\t{\n+\t  _GLIBCXX_DEBUG_ASSERT(__u < _M_exists.size());\n+\t  if (!_M_exists[__u])\n+\t    {\n+\t      _M_exists[__u] = true;\n+\t      _M_states.push_back(__u);\n+\t    }\n+\t}\n+\n+\t_StateIdT _M_pop()\n+\t{\n+\t  auto __ret = _M_states.back();\n+\t  _M_states.pop_back();\n+\t  _M_exists[__ret] = false;\n+\t  return __ret;\n+\t}\n+\n+\tbool _M_empty() const\n+\t{ return _M_states.empty(); }\n+\n+\tvoid _M_clear()\n+\t{\n+\t  _M_states.clear();\n+\t  _M_exists.assign(_M_exists.size(), false);\n+\t}\n+\n+      private:\n+\tstd::vector<_StateIdT>         _M_states;\n+\tstd::vector<bool>              _M_exists;\n+      };\n+\n     public:\n       _BFSExecutor(_BiIter         __begin,\n \t\t   _BiIter         __end,\n@@ -355,21 +380,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _BaseT(__begin, __end, __results, __re, __flags),\n       _M_nfa(*std::static_pointer_cast<_NFA<_CharT, _TraitsT>>\n \t     (__re._M_automaton)),\n+      _M_match_stack(_M_nfa.size()),\n+      _M_stack(_M_nfa.size()),\n       _M_start_state(_M_nfa._M_start())\n       { }\n \n     private:\n       void\n       _M_init(_BiIter __cur)\n       {\n-\t_GLIBCXX_DEBUG_ASSERT(this->_M_start_state != _S_invalid_state_id);\n \tthis->_M_current = __cur;\n \t_M_covered.clear();\n \t_ResultsVec& __res(this->_M_results);\n \t_M_covered[this->_M_start_state] =\n \t  _ResultsPtr(new _ResultsEntry(__res.size(),\n \t\t\t\t\t_M_nfa._M_quant_count));\n-\t_M_e_closure();\n+\t_M_stack._M_push(this->_M_start_state);\n       }\n \n       void\n@@ -398,11 +424,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t\t\tthis->_M_flags));\n       }\n \n+      const _NFAT&                     _M_nfa;\n       std::map<_StateIdT, _ResultsPtr> _M_covered;\n+      _TodoList                        _M_match_stack;\n+      _TodoList                        _M_stack;\n+      _StateIdT                        _M_start_state;\n       // To record global optimal solution.\n       _ResultsPtr                      _M_cur_results;\n-      const _NFAT&                     _M_nfa;\n-      _StateIdT                        _M_start_state;\n     };\n \n  //@} regex-detail"}, {"sha": "59b082e2ac3be1f89c5dde02a558a149ed55bf53", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18971f1fc38596e4bb8cd9911a8a656231bb5827/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18971f1fc38596e4bb8cd9911a8a656231bb5827/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=18971f1fc38596e4bb8cd9911a8a656231bb5827", "patch": "@@ -34,14 +34,31 @@ namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    bool _Executor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_search()\n+    {\n+      if (_M_flags & regex_constants::match_continuous)\n+\treturn _M_search_from_first();\n+      auto __cur = _M_begin;\n+      do\n+\t{\n+\t  _M_match_mode = false;\n+\t  _M_init(__cur);\n+\t  if (_M_main())\n+\t    return true;\n+\t}\n+      // Continue when __cur == _M_end\n+      while (__cur++ != _M_end);\n+      return false;\n+    }\n+\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n     bool _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_dfs(_StateIdT __i)\n     {\n-      if (__i == _S_invalid_state_id)\n-\t// This is not that certain. Need deeper investigate.\n-\treturn false;\n       auto& __current = this->_M_current;\n       const auto& __state = _M_nfa[__i];\n       bool __ret = false;\n@@ -161,6 +178,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_main()\n     {\n+      _M_e_closure();\n       bool __ret = false;\n       if (!this->_M_match_mode\n \t  && !(this->_M_flags & regex_constants::match_not_null))\n@@ -169,6 +187,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  _M_move();\n \t  ++this->_M_current;\n+\t  if (_M_stack._M_empty())\n+\t    break;\n \t  _M_e_closure();\n \t  if (!this->_M_match_mode)\n \t    // To keep regex_search greedy, no \"return true\" here.\n@@ -178,6 +198,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__ret = _M_includes_some();\n       if (__ret)\n \tthis->_M_set_results(_M_cur_results->_M_get());\n+      _M_match_stack._M_clear();\n+      _GLIBCXX_DEBUG_ASSERT(_M_stack._M_empty());\n       return __ret;\n     }\n \n@@ -186,42 +208,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_e_closure()\n     {\n-      std::queue<_StateIdT> __q;\n-      std::vector<bool> __in_q(_M_nfa.size(), false);\n       auto& __current = this->_M_current;\n \n-      for (auto& __it : _M_covered)\n-\t{\n-\t  __in_q[__it.first] = true;\n-\t  __q.push(__it.first);\n-\t}\n-      while (!__q.empty())\n+      while (!_M_stack._M_empty())\n \t{\n-\t  auto __u = __q.front();\n-\t  __q.pop();\n-\t  __in_q[__u] = false;\n+\t  auto __u = _M_stack._M_pop();\n+\t  _GLIBCXX_DEBUG_ASSERT(_M_covered.count(__u));\n \t  const auto& __state = _M_nfa[__u];\n \n \t  // Can be implemented using method, but there will be too many\n \t  // arguments. I would use macro function before C++11, but lambda is\n \t  // a better choice, since hopefully compiler can inline it.\n-\t  auto __add_visited_state = [&](_StateIdT __v)\n+\t  auto __add_visited_state = [=](_StateIdT __v)\n \t  {\n-\t    if (__v == _S_invalid_state_id)\n-\t      return;\n-\t    if (_M_covered.count(__u) != 0\n-\t\t&& (_M_covered.count(__v) == 0\n-\t\t    || *_M_covered[__u] < *_M_covered[__v]))\n+\t    if (_M_covered.count(__v) == 0)\n \t      {\n \t\t_M_covered[__v] =\n \t\t  _ResultsPtr(new _ResultsEntry(*_M_covered[__u]));\n+\t\t_M_stack._M_push(__v);\n+\t\treturn;\n+\t      }\n+\t    auto& __cu = _M_covered[__u];\n+\t    auto& __cv = _M_covered[__v];\n+\t    if (*__cu < *__cv)\n+\t      {\n+\t\t__cv = _ResultsPtr(new _ResultsEntry(*__cu));\n \t\t// if a state is updated, it's outgoing neighbors should be\n \t\t// reconsidered too. Push them to the queue.\n-\t\tif (!__in_q[__v])\n-\t\t  {\n-\t\t    __in_q[__v] = true;\n-\t\t    __q.push(__v);\n-\t\t  }\n+\t\t_M_stack._M_push(__v);\n \t      }\n \t  };\n \n@@ -233,13 +247,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      case _S_opcode_alternative:\n \t\t{\n \t\t  __add_visited_state(__state._M_next);\n-\t\t  auto __back =\n-\t\t    _M_covered[__u]->_M_quant_keys[__state._M_quant_index];\n-\t\t  _M_covered[__u]->_M_inc(__state._M_quant_index,\n-\t\t\t\t\t  __state._M_neg);\n+\t\t  auto& __cu = *_M_covered[__u];\n+\t\t  auto __back = __cu._M_quant_keys[__state._M_quant_index];\n+\t\t  __cu._M_inc(__state._M_quant_index, __state._M_neg);\n \t\t  __add_visited_state(__state._M_alt);\n-\t\t  _M_covered[__u]->_M_quant_keys[__state._M_quant_index]\n-\t\t    = __back;\n+\t\t  __cu._M_quant_keys[__state._M_quant_index] = __back;\n \t\t}\n \t\tbreak;\n \t      case _S_opcode_subexpr_begin:\n@@ -281,6 +293,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  __add_visited_state(__state._M_next);\n \t\tbreak;\n \t      case _S_opcode_match:\n+\t\t_M_match_stack._M_push(__u);\n \t\tbreak;\n \t      case _S_opcode_accept:\n \t\tbreak;\n@@ -296,15 +309,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_move()\n     {\n       decltype(_M_covered) __next;\n-      for (auto& __it : _M_covered)\n+      while (!_M_match_stack._M_empty())\n \t{\n-\t  const auto& __state = _M_nfa[__it.first];\n-\t  if (__state._M_opcode == _S_opcode_match\n-\t      && __state._M_matches(*this->_M_current))\n-\t    if (__state._M_next != _S_invalid_state_id)\n-\t      if (__next.count(__state._M_next) == 0\n-\t\t  || *__it.second < *__next[__state._M_next])\n-\t\t__next[__state._M_next] = move(__it.second);\n+\t  auto __u = _M_match_stack._M_pop();\n+\t  const auto& __state = _M_nfa[__u];\n+\t  auto& __cu = _M_covered[__u];\n+\t  if (__state._M_matches(*this->_M_current)\n+\t      && (__next.count(__state._M_next) == 0\n+\t\t  || *__cu < *__next[__state._M_next]))\n+\t    {\n+\t      __next[__state._M_next] = std::move(__cu);\n+\t      _M_stack._M_push(__state._M_next);\n+\t    }\n \t}\n       _M_covered = move(__next);\n     }\n@@ -314,31 +330,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_includes_some()\n     {\n-      auto& __s = _M_nfa._M_final_states();\n-      auto& __t = _M_covered;\n       bool __succ = false;\n-      if (__s.size() > 0 && __t.size() > 0)\n-\t{\n-\t  auto __first = __s.begin();\n-\t  auto __second = __t.begin();\n-\t  while (__first != __s.end() && __second != __t.end())\n-\t    {\n-\t      if (*__first < __second->first)\n-\t\t++__first;\n-\t      else if (*__first > __second->first)\n-\t\t++__second;\n-\t      else\n-\t\t{\n-\t\t  if (_M_cur_results == nullptr\n-\t\t      || *__second->second < *_M_cur_results)\n-\t\t    _M_cur_results =\n-\t\t      _ResultsPtr(new _ResultsEntry(*__second->second));\n-\t\t  __succ = true;\n-\t\t  ++__first;\n-\t\t  ++__second;\n-\t\t}\n-\t    }\n-\t}\n+      for (auto __u : _M_nfa._M_final_states())\n+\tif (_M_covered.count(__u))\n+\t  {\n+\t    __succ = true;\n+\t    auto& __cu = _M_covered[__u];\n+\t    if (_M_cur_results == nullptr || *__cu < *_M_cur_results)\n+\t      _M_cur_results = _ResultsPtr(new _ResultsEntry(*__cu));\n+\t  }\n       return __succ;\n     }\n "}, {"sha": "5b972e43696dd75a36c55a145e34f8d630f446ec", "filename": "libstdc++-v3/testsuite/performance/28_regex/split.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18971f1fc38596e4bb8cd9911a8a656231bb5827/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18971f1fc38596e4bb8cd9911a8a656231bb5827/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.cc?ref=18971f1fc38596e4bb8cd9911a8a656231bb5827", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 2013-10-08  Tim Shen  <timshen91@gmail.com>\n+\n+#include <testsuite_performance.h>\n+#include <regex>\n+\n+using namespace __gnu_test;\n+using namespace std;\n+\n+void split(string s)\n+{\n+    regex re(\"\\\\s+\");\n+    for (auto it = sregex_token_iterator(s.begin(), s.end(), re, -1);\n+\t it != sregex_token_iterator();\n+\t ++it)\n+      {\n+      }\n+}\n+\n+int main()\n+{\n+  string source = \"\\\n+// Copyright (C) 2013 Free Software Foundation, Inc.\\n\\\n+//\\n\\\n+// This file is part of the GNU ISO C++ Library.  This library is free\\n\\\n+// software; you can redistribute it and/or modify it under the\\n\\\n+// terms of the GNU General Public License as published by the\\n\\\n+// Free Software Foundation; either version 3, or (at your option)\\n\\\n+// any later version.\\n\\\n+\\n\\\n+// This library is distributed in the hope that it will be useful,\\n\\\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\\\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\\\n+// GNU General Public License for more details.\\n\\\n+\\n\\\n+// You should have received a copy of the GNU General Public License along\\n\\\n+// with this library; see the file COPYING3.  If not see\\n\\\n+// <http://www.gnu.org/licenses/>.\\n\\\n+\\n\\\n+// 2013-10-08  Tim Shen  <timshen91@gmail.com>\\n\\\n+\\n\\\n+#include <testsuite_performance.h>\\n\\\n+#include <regex>\\n\\\n+\\n\\\n+using namespace __gnu_test;\\n\\\n+using namespace std;\\n\\\n+\\n\\\n+void split(string s)\\n\\\n+{\\n\\\n+    regex re(\\\"\\\\s+\\\");\\n\\\n+    for (auto it = sregex_token_iterator(s.begin(), s.end(), re, -1);\\n\\\n+\t it != sregex_token_iterator();\\n\\\n+\t ++it)\\n\\\n+      {\\n\\\n+      }\\n\\\n+}\\n\\\n+\\n\\\n+int main()\\n\\\n+{\\n\\\n+  string source = \\\"\\\";\\n\\\n+  time_counter time;\\n\\\n+  resource_counter resource;\\n\\\n+\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+\\n\\\n+  start_counters(time, resource);\\n\\\n+  split(source);\\n\\\n+  stop_counters(time, resource);\\n\\\n+  report_performance(__FILE__, \\\"\\\", time, resource);\\n\\\n+\\n\\\n+  return 0;\\n\\\n+}\\n\";\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+\n+  start_counters(time, resource);\n+  split(source);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"\", time, resource);\n+\n+  return 0;\n+}"}]}