{"sha": "b8fd7909c04a29e82fb3ebace161801f949ad4f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhmZDc5MDljMDRhMjllODJmYjNlYmFjZTE2MTgwMWY5NDlhZDRmNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-10-04T19:17:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-10-04T19:17:19Z"}, "message": "Implement N4514, C++ Extensions for Transactional Memory.\n\ngcc/\n\t* builtins.def (BUILT_IN_ABORT): Add transaction_pure attribute.\ngcc/c-family/\n\t* c-common.c (c_common_reswords): Add C++ TM TS keywords.\n\t(c_common_attribute_table): Add transaction_safe_dynamic.\n\ttransaction_safe now affects type identity.\n\t(handle_tm_attribute): Handle transaction_safe_dynamic.\n\t* c-common.h (enum rid): Add RID_ATOMIC_NOEXCEPT,\n\tRID_ATOMIC_CANCEL, RID_SYNCHRONIZED.\n\t(OBJC_IS_CXX_KEYWORD): Add RID_SYNCHRONIZED.\n\t(D_TRANSMEM): New.\n\t* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_transactional_memory.\n\t* c-pretty-print.c (pp_c_attributes_display): Don't print\n\ttransaction_safe in C++.\ngcc/c/\n\t* c-parser.c (c_lex_one_token): Handle @synchronized.\n\t* c-decl.c (match_builtin_function_types): A declaration of a built-in\n\tcan change whether the function is transaction_safe.\ngcc/cp/\n\t* cp-tree.h (struct cp_declarator): Add tx_qualifier field.\n\t(BCS_NORMAL, BCS_TRANSACTION): New enumerators.\n\t* lex.c (init_reswords): Limit TM kewords to -fgnu-tm.\n\t* parser.c (cp_lexer_get_preprocessor_token): Fix @synchronized.\n\t(make_call_declarator): Take tx_qualifier.\n\t(cp_parser_tx_qualifier_opt): New.\n\t(cp_parser_lambda_declarator_opt): Use it.\n\t(cp_parser_direct_declarator): Likewise.\n\t(cp_parser_statement): Handle atomic_noexcept, atomic_cancel.\n\t(cp_parser_compound_statement): Change in_try parameter to bcs_flags.\n\t(cp_parser_std_attribute): Map optimize_for_synchronized to\n\ttransaction_callable.\n\t(cp_parser_transaction): Take the token.  Handle atomic_noexcept.\n\t* lambda.c (maybe_add_lambda_conv_op): Handle transaction-safety.\n\t* call.c (enum conversion_kind): Add ck_tsafe.\n\t(standard_conversion): Handle transaction-safety conversion.\n\t(convert_like_real, resolve_address_of_overloaded_function): Likewise.\n\t(check_methods): Diagnose transaction_safe_dynamic on non-virtual\n\tfunction.\n\t(look_for_tm_attr_overrides): Don't inherit transaction_safe_dynamic.\n\t* cvt.c (tx_safe_fn_type_p, tx_unsafe_fn_variant)\n\t(can_convert_tx_safety): New.\n\t* typeck.c (composite_pointer_type): Handle transaction-safety.\n\t* name-lookup.h (enum scope_kind): Add sk_transaction.\n\t* name-lookup.c (begin_scope): Handle it.\n\t* semantics.c (begin_compound_stmt): Pass it.\n\t* decl.c (check_previous_goto_1): Check it.\n\t(struct named_label_entry): Add in_transaction_scope.\n\t(poplevel_named_label_1): Set it.\n\t(check_goto): Check it.\n\t(duplicate_decls): A specialization can be transaction_safe\n\tindependently of its template.\n\t(grokdeclarator): Handle tx-qualifier.\n\t* rtti.c (ptr_initializer): Handle transaction-safe.\n\t* search.c (check_final_overrider): Check transaction_safe_dynamic.\n\tDon't check transaction_safe.\n\t* mangle.c (write_function_type): Mangle transaction_safe here.\n\t(write_CV_qualifiers_for_type): Not here.\n\t(write_type): Preserve transaction_safe when stripping attributes.\n\t* error.c (dump_type_suffix): Print transaction_safe.\nlibiberty/\n\t* cp-demangle.c (d_cv_qualifiers): Dx means transaction_safe.\n\t(cplus_demangle_type): Let d_cv_qualifiers handle it.\n\t(d_dump, d_make_comp, has_return_type, d_encoding)\n\t(d_count_templates_scopes, d_print_comp_inner)\n\t(d_print_mod_list, d_print_mod, d_print_function_type)\n\t(is_ctor_or_dtor): Handle DEMANGLE_COMPONENT_TRANSACTION_SAFE.\n\nFrom-SVN: r228462", "tree": {"sha": "b68c53c0fcfa672f4c0e3577083662356ee4953d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b68c53c0fcfa672f4c0e3577083662356ee4953d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8fd7909c04a29e82fb3ebace161801f949ad4f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8fd7909c04a29e82fb3ebace161801f949ad4f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8fd7909c04a29e82fb3ebace161801f949ad4f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8fd7909c04a29e82fb3ebace161801f949ad4f5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd841941ec9b1864216573f4426e694f806dd4bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd841941ec9b1864216573f4426e694f806dd4bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd841941ec9b1864216573f4426e694f806dd4bf"}], "stats": {"total": 889, "additions": 833, "deletions": 56}, "files": [{"sha": "0d740a24901d1a3ef9b182735bb0052e6d693073", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1,3 +1,7 @@\n+2015-10-04  Jason Merrill  <jason@redhat.com>\n+\n+\t* builtins.def (BUILT_IN_ABORT): Add transaction_pure attribute.\n+\n 2015-10-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_nsaved_regs): Use GENERAL_REGNO_P to"}, {"sha": "2cb82510bc5da016e14eeabf72f203612d1ecd37", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -729,7 +729,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_UMULL_OVERFLOW, \"umull_overflow\", BT_FN_BOOL_UL\n DEF_GCC_BUILTIN        (BUILT_IN_UMULLL_OVERFLOW, \"umulll_overflow\", BT_FN_BOOL_ULONGLONG_ULONGLONG_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n \n /* Category: miscellaneous builtins.  */\n-DEF_LIB_BUILTIN        (BUILT_IN_ABORT, \"abort\", BT_FN_VOID, ATTR_NORETURN_NOTHROW_LEAF_LIST)\n+DEF_LIB_BUILTIN        (BUILT_IN_ABORT, \"abort\", BT_FN_VOID, ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n DEF_LIB_BUILTIN        (BUILT_IN_ABS, \"abs\", BT_FN_INT_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_AGGREGATE_INCOMING_ADDRESS, \"aggregate_incoming_address\", BT_FN_PTR_VAR, ATTR_LEAF_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ALLOCA, \"alloca\", BT_FN_PTR_SIZE, ATTR_MALLOC_NOTHROW_LEAF_LIST)"}, {"sha": "c75d489509731773eff49f58d0a949d8889d8d73", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1,3 +1,18 @@\n+2015-10-04  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement N4514, C++ Extensions for Transactional Memory.\n+\t* c-common.c (c_common_reswords): Add C++ TM TS keywords.\n+\t(c_common_attribute_table): Add transaction_safe_dynamic.\n+\ttransaction_safe now affects type identity.\n+\t(handle_tm_attribute): Handle transaction_safe_dynamic.\n+\t* c-common.h (enum rid): Add RID_ATOMIC_NOEXCEPT,\n+\tRID_ATOMIC_CANCEL, RID_SYNCHRONIZED.\n+\t(OBJC_IS_CXX_KEYWORD): Add RID_SYNCHRONIZED.\n+\t(D_TRANSMEM): New.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_transactional_memory.\n+\t* c-pretty-print.c (pp_c_attributes_display): Don't print\n+\ttransaction_safe in C++.\n+\n 2015-10-02  Marek Polacek  <polacek@redhat.com>\n \n \t* c.opt (Wduplicated-cond): Don't enable by -Wall anymore."}, {"sha": "4b64a448a88cf32af5950081b6233de57d243fe4", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -594,6 +594,12 @@ const struct c_common_resword c_common_reswords[] =\n   { \"wchar_t\",\t\tRID_WCHAR,\tD_CXXONLY },\n   { \"while\",\t\tRID_WHILE,\t0 },\n \n+  /* C++ transactional memory.  */\n+  { \"synchronized\",\tRID_SYNCHRONIZED, D_CXX_OBJC | D_TRANSMEM },\n+  { \"atomic_noexcept\",\tRID_ATOMIC_NOEXCEPT, D_CXXONLY | D_TRANSMEM },\n+  { \"atomic_cancel\",\tRID_ATOMIC_CANCEL, D_CXXONLY | D_TRANSMEM },\n+  { \"atomic_commit\",\tRID_TRANSACTION_ATOMIC, D_CXXONLY | D_TRANSMEM },\n+\n   /* Concepts-related keywords */\n   { \"concept\",\t\tRID_CONCEPT,\tD_CXX_CONCEPTS_FLAGS | D_CXXWARN },\n   { \"requires\", \tRID_REQUIRES,\tD_CXX_CONCEPTS_FLAGS | D_CXXWARN },\n@@ -609,7 +615,6 @@ const struct c_common_resword c_common_reswords[] =\n   { \"protocol\",\t\tRID_AT_PROTOCOL,\tD_OBJC },\n   { \"selector\",\t\tRID_AT_SELECTOR,\tD_OBJC },\n   { \"finally\",\t\tRID_AT_FINALLY,\t\tD_OBJC },\n-  { \"synchronized\",\tRID_AT_SYNCHRONIZED,\tD_OBJC },\n   { \"optional\",\t\tRID_AT_OPTIONAL,\tD_OBJC },\n   { \"required\",\t\tRID_AT_REQUIRED,\tD_OBJC },\n   { \"property\",\t\tRID_AT_PROPERTY,\tD_OBJC },\n@@ -728,8 +733,10 @@ const struct attribute_spec c_common_attribute_table[] =\n   { \"transaction_callable\",   0, 0, false, true,  false,\n \t\t\t      handle_tm_attribute, false },\n   { \"transaction_unsafe\",     0, 0, false, true,  false,\n-\t\t\t      handle_tm_attribute, false },\n+\t\t\t      handle_tm_attribute, true },\n   { \"transaction_safe\",       0, 0, false, true,  false,\n+\t\t\t      handle_tm_attribute, true },\n+  { \"transaction_safe_dynamic\", 0, 0, true, false,  false,\n \t\t\t      handle_tm_attribute, false },\n   { \"transaction_may_cancel_outer\", 0, 0, false, true, false,\n \t\t\t      handle_tm_attribute, false },\n@@ -9136,6 +9143,23 @@ handle_tm_attribute (tree *node, tree name, tree args,\n       }\n       break;\n \n+    case FUNCTION_DECL:\n+      {\n+\t/* transaction_safe_dynamic goes on the FUNCTION_DECL, but we also\n+\t   want to set transaction_safe on the type.  */\n+\tgcc_assert (is_attribute_p (\"transaction_safe_dynamic\", name));\n+\tif (!TYPE_P (DECL_CONTEXT (*node)))\n+\t  error_at (DECL_SOURCE_LOCATION (*node),\n+\t\t    \"%<transaction_safe_dynamic%> may only be specified for \"\n+\t\t    \"a virtual function\");\n+\t*no_add_attrs = false;\n+\tdecl_attributes (&TREE_TYPE (*node),\n+\t\t\t build_tree_list (get_identifier (\"transaction_safe\"),\n+\t\t\t\t\t  NULL_TREE),\n+\t\t\t 0);\n+\tbreak;\n+      }\n+\n     case POINTER_TYPE:\n       {\n \tenum tree_code subcode = TREE_CODE (TREE_TYPE (*node));"}, {"sha": "d5fb4998268a3ad79d0d406fe9624f042eed69d7", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -154,6 +154,9 @@ enum rid\n   /* C++ concepts */\n   RID_CONCEPT, RID_REQUIRES,\n \n+  /* C++ transactional memory.  */\n+  RID_ATOMIC_NOEXCEPT, RID_ATOMIC_CANCEL, RID_SYNCHRONIZED,\n+\n   /* Cilk Plus keywords.  */\n   RID_CILK_SPAWN, RID_CILK_SYNC, RID_CILK_FOR,\n   \n@@ -246,7 +249,7 @@ enum rid\n    is found elsewhere, it follows the rules of the C/C++ language.\n  */\n #define OBJC_IS_CXX_KEYWORD(rid) \\\n-  (rid == RID_CLASS\t\t\t\t\t\t\t\\\n+  (rid == RID_CLASS || rid == RID_SYNCHRONIZED\t\t\t\\\n    || rid == RID_PUBLIC || rid == RID_PROTECTED || rid == RID_PRIVATE\t\\\n    || rid == RID_TRY || rid == RID_THROW || rid == RID_CATCH)\n \n@@ -391,6 +394,7 @@ extern machine_mode c_default_pointer_mode;\n #define D_CXX_OBJC\t0x100\t/* In Objective C, and C++, but not C.  */\n #define D_CXXWARN\t0x200\t/* In C warn with -Wcxx-compat.  */\n #define D_CXX_CONCEPTS  0x400   /* In C++, only with concepts. */\n+#define D_TRANSMEM\t0X800   /* C++ transactional memory TS.  */\n \n #define D_CXX_CONCEPTS_FLAGS D_CXXONLY | D_CXX_CONCEPTS\n "}, {"sha": "e109e820eeaf4870a3f9dfd059ead8aa13676b2a", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -877,6 +877,10 @@ c_cpp_builtins (cpp_reader *pfile)\n \t/* Use a value smaller than the 201507 specified in\n \t   the TS, since we don't yet support extended auto.  */\n \tcpp_define (pfile, \"__cpp_concepts=201500\");\n+      if (flag_tm)\n+\t/* Use a value smaller than the 201505 specified in\n+\t   the TS, since we don't yet support atomic_cancel.  */\n+\tcpp_define (pfile, \"__cpp_transactional_memory=210500\");\n       if (flag_sized_deallocation)\n \tcpp_define (pfile, \"__cpp_sized_deallocation=201309\");\n     }"}, {"sha": "c61c41f1810dc0d1e283fa65d56ff9b6ce02ed2a", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -802,6 +802,10 @@ pp_c_attributes_display (c_pretty_printer *pp, tree a)\n       as = lookup_attribute_spec (TREE_PURPOSE (a));\n       if (!as || as->affects_type_identity == false)\n         continue;\n+      if (c_dialect_cxx ()\n+\t  && !strcmp (\"transaction_safe\", as->name))\n+\t/* In C++ transaction_safe is printed at the end of the declarator.  */\n+\tcontinue;\n       if (is_first)\n        {\n          pp_c_ws_string (pp, \"__attribute__\");"}, {"sha": "e0f169dc1d5da8e9cb6bdd7384ac004d5dfec4b1", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1,3 +1,9 @@\n+2015-10-04  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-parser.c (c_lex_one_token): Handle @synchronized.\n+\t* c-decl.c (match_builtin_function_types): A declaration of a built-in\n+\tcan change whether the function is transaction_safe.\n+\n 2015-10-02  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/67730"}, {"sha": "ce8406a13e47070579a5cc6ac3925ccad689cb96", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1659,7 +1659,19 @@ match_builtin_function_types (tree newtype, tree oldtype)\n     }\n \n   trytype = build_function_type (newrettype, tryargs);\n-  return build_type_attribute_variant (trytype, TYPE_ATTRIBUTES (oldtype));\n+\n+  /* Allow declaration to change transaction_safe attribute.  */\n+  tree oldattrs = TYPE_ATTRIBUTES (oldtype);\n+  tree oldtsafe = lookup_attribute (\"transaction_safe\", oldattrs);\n+  tree newattrs = TYPE_ATTRIBUTES (newtype);\n+  tree newtsafe = lookup_attribute (\"transaction_safe\", newattrs);\n+  if (oldtsafe && !newtsafe)\n+    oldattrs = remove_attribute (\"transaction_safe\", oldattrs);\n+  else if (newtsafe && !oldtsafe)\n+    oldattrs = tree_cons (get_identifier (\"transaction_safe\"),\n+\t\t\t  NULL_TREE, oldattrs);\n+\n+  return build_type_attribute_variant (trytype, oldattrs);\n }\n \n /* Subroutine of diagnose_mismatched_decls.  Check for function type"}, {"sha": "0df7d7bb01e21d81e6e537498be1509ee9906251", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -390,6 +390,7 @@ c_lex_one_token (c_parser *parser, c_token *token)\n \tcase RID_THROW:     token->keyword = RID_AT_THROW; break;\n \tcase RID_TRY:       token->keyword = RID_AT_TRY; break;\n \tcase RID_CATCH:     token->keyword = RID_AT_CATCH; break;\n+\tcase RID_SYNCHRONIZED: token->keyword = RID_AT_SYNCHRONIZED; break;\n \tdefault:            token->keyword = C_RID_CODE (token->value);\n \t}\n       break;"}, {"sha": "bc169b82bd0626b09cd22ee476b797f5fa210dbc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1,3 +1,47 @@\n+2015-10-04  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement N4514, C++ Extensions for Transactional Memory.\n+\t* cp-tree.h (struct cp_declarator): Add tx_qualifier field.\n+\t(BCS_NORMAL, BCS_TRANSACTION): New enumerators.\n+\t* lex.c (init_reswords): Limit TM kewords to -fgnu-tm.\n+\t* parser.c (cp_lexer_get_preprocessor_token): Fix @synchronized.\n+\t(make_call_declarator): Take tx_qualifier.\n+\t(cp_parser_tx_qualifier_opt): New.\n+\t(cp_parser_lambda_declarator_opt): Use it.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t(cp_parser_statement): Handle atomic_noexcept, atomic_cancel.\n+\t(cp_parser_compound_statement): Change in_try parameter to bcs_flags.\n+\t(cp_parser_std_attribute): Map optimize_for_synchronized to\n+\ttransaction_callable.\n+\t(cp_parser_transaction): Take the token.  Handle atomic_noexcept.\n+\t* lambda.c (maybe_add_lambda_conv_op): Handle transaction-safety.\n+\t* call.c (enum conversion_kind): Add ck_tsafe.\n+\t(standard_conversion): Handle transaction-safety conversion.\n+\t(convert_like_real, resolve_address_of_overloaded_function): Likewise.\n+\t(check_methods): Diagnose transaction_safe_dynamic on non-virtual\n+\tfunction.\n+\t(look_for_tm_attr_overrides): Don't inherit transaction_safe_dynamic.\n+\t* cvt.c (tx_safe_fn_type_p, tx_unsafe_fn_variant)\n+\t(can_convert_tx_safety): New.\n+\t* typeck.c (composite_pointer_type): Handle transaction-safety.\n+\t* name-lookup.h (enum scope_kind): Add sk_transaction.\n+\t* name-lookup.c (begin_scope): Handle it.\n+\t* semantics.c (begin_compound_stmt): Pass it.\n+\t* decl.c (check_previous_goto_1): Check it.\n+\t(struct named_label_entry): Add in_transaction_scope.\n+\t(poplevel_named_label_1): Set it.\n+\t(check_goto): Check it.\n+\t(duplicate_decls): A specialization can be transaction_safe\n+\tindependently of its template.\n+\t(grokdeclarator): Handle tx-qualifier.\n+\t* rtti.c (ptr_initializer): Handle transaction-safe.\n+\t* search.c (check_final_overrider): Check transaction_safe_dynamic.\n+\tDon't check transaction_safe.\n+\t* mangle.c (write_function_type): Mangle transaction_safe here.\n+\t(write_CV_qualifiers_for_type): Not here.\n+\t(write_type): Preserve transaction_safe when stripping attributes.\n+\t* error.c (dump_type_suffix): Print transaction_safe.\n+\n 2015-10-02  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/64249"}, {"sha": "050d04574834e69c2193442e943ef2cddb7a1100", "filename": "gcc/cp/call.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n enum conversion_kind {\n   ck_identity,\n   ck_lvalue,\n+  ck_tsafe,\n   ck_qual,\n   ck_std,\n   ck_ptr,\n@@ -1265,6 +1266,17 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t  conv = build_conv (ck_ptr, from, conv);\n \t  conv->base_p = true;\n \t}\n+      else if (tx_safe_fn_type_p (TREE_TYPE (from)))\n+\t{\n+\t  /* A prvalue of type \"pointer to transaction_safe function\" can be\n+\t     converted to a prvalue of type \"pointer to function\". */\n+\t  tree unsafe = tx_unsafe_fn_variant (TREE_TYPE (from));\n+\t  if (same_type_p (unsafe, TREE_TYPE (to)))\n+\t    {\n+\t      from = build_pointer_type (unsafe);\n+\t      conv = build_conv (ck_tsafe, from, conv);\n+\t    }\n+\t}\n \n       if (tcode == POINTER_TYPE)\n \t{\n@@ -6638,6 +6650,11 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n     case ck_lvalue:\n       return decay_conversion (expr, complain);\n \n+    case ck_tsafe:\n+      /* ??? Should the address of a transaction-safe pointer point to the TM\n+\t clone, and this conversion look up the primary function?  */\n+      return build_nop (totype, expr);\n+\n     case ck_qual:\n       /* Warn about deprecated conversion if appropriate.  */\n       string_conv_p (totype, expr, 1);"}, {"sha": "ef537be5c30e8654326e38b84888fc6c94168a06", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -4570,6 +4570,11 @@ check_methods (tree t)\n \t grok_special_member_properties.  */\n       if (DECL_DESTRUCTOR_P (x) && user_provided_p (x))\n \tTYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = 1;\n+      if (!DECL_VIRTUAL_P (x)\n+\t  && lookup_attribute (\"transaction_safe_dynamic\", DECL_ATTRIBUTES (x)))\n+\terror_at (DECL_SOURCE_LOCATION (x),\n+\t\t  \"%<transaction_safe_dynamic%> may only be specified for \"\n+\t\t  \"a virtual function\");\n     }\n }\n \n@@ -4932,8 +4937,14 @@ look_for_tm_attr_overrides (tree type, tree fndecl)\n \n       o = look_for_overrides_here (basetype, fndecl);\n       if (o)\n-\tfound |= tm_attr_to_mask (find_tm_attribute\n-\t\t\t\t  (TYPE_ATTRIBUTES (TREE_TYPE (o))));\n+\t{\n+\t  if (lookup_attribute (\"transaction_safe_dynamic\",\n+\t\t\t\tDECL_ATTRIBUTES (o)))\n+\t    /* transaction_safe_dynamic is not inherited.  */;\n+\t  else\n+\t    found |= tm_attr_to_mask (find_tm_attribute\n+\t\t\t\t      (TYPE_ATTRIBUTES (TREE_TYPE (o))));\n+\t}\n       else\n \tfound |= look_for_tm_attr_overrides (basetype, fndecl);\n     }\n@@ -7608,7 +7619,9 @@ resolve_address_of_overloaded_function (tree target_type,\n \t    continue;\n \n \t  /* See if there's a match.  */\n-\t  if (same_type_p (target_fn_type, static_fn_type (fn)))\n+\t  tree fntype = static_fn_type (fn);\n+\t  if (same_type_p (target_fn_type, fntype)\n+\t      || can_convert_tx_safety (target_fn_type, fntype))\n \t    matches = tree_cons (fn, NULL_TREE, matches);\n \t}\n     }\n@@ -7686,7 +7699,9 @@ resolve_address_of_overloaded_function (tree target_type,\n \t    }\n \n \t  /* See if there's a match.  */\n-\t  if (same_type_p (target_fn_type, static_fn_type (instantiation)))\n+\t  tree fntype = static_fn_type (instantiation);\n+\t  if (same_type_p (target_fn_type, fntype)\n+\t      || can_convert_tx_safety (target_fn_type, fntype))\n \t    matches = tree_cons (instantiation, fn, matches);\n \t}\n "}, {"sha": "5acb065aba0169d62e2ceb08c3d7af993519b99b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -5317,6 +5317,8 @@ struct cp_declarator {\n       cp_virt_specifiers virt_specifiers;\n       /* The ref-qualifier for the function.  */\n       cp_ref_qualifier ref_qualifier;\n+      /* The transaction-safety qualifier for the function.  */\n+      tree tx_qualifier;\n       /* The exception-specification for the function.  */\n       tree exception_specification;\n       /* The late-specified return type, if any.  */\n@@ -5604,6 +5606,9 @@ extern tree convert_force\t\t\t(tree, tree, int,\n extern tree build_expr_type_conversion\t\t(int, tree, bool);\n extern tree type_promotes_to\t\t\t(tree);\n extern tree perform_qualification_conversions\t(tree, tree);\n+extern bool tx_safe_fn_type_p\t\t\t(tree);\n+extern tree tx_unsafe_fn_variant\t\t(tree);\n+extern bool can_convert_tx_safety\t\t(tree, tree);\n \n /* in name-lookup.c */\n extern tree pushdecl\t\t\t\t(tree);\n@@ -6218,9 +6223,11 @@ extern void finish_cleanup\t\t\t(tree, tree);\n extern bool is_this_parameter                   (tree);\n \n enum {\n+  BCS_NORMAL = 0,\n   BCS_NO_SCOPE = 1,\n   BCS_TRY_BLOCK = 2,\n-  BCS_FN_BODY = 4\n+  BCS_FN_BODY = 4,\n+  BCS_TRANSACTION = 8\n };\n extern tree begin_compound_stmt\t\t\t(unsigned int);\n "}, {"sha": "b61588021a346eef0aac3c8ceaa11df7da043cbd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1790,3 +1790,36 @@ perform_qualification_conversions (tree type, tree expr)\n   else\n     return error_mark_node;\n }\n+\n+/* True iff T is a transaction-safe function type.  */\n+\n+bool\n+tx_safe_fn_type_p (tree t)\n+{\n+  if (TREE_CODE (t) != FUNCTION_TYPE\n+      && TREE_CODE (t) != METHOD_TYPE)\n+    return false;\n+  return !!lookup_attribute (\"transaction_safe\", TYPE_ATTRIBUTES (t));\n+}\n+\n+/* Return the transaction-unsafe variant of transaction-safe function type\n+   T.  */\n+\n+tree\n+tx_unsafe_fn_variant (tree t)\n+{\n+  gcc_assert (tx_safe_fn_type_p (t));\n+  tree attrs = remove_attribute (\"transaction_safe\",\n+\t\t\t\t TYPE_ATTRIBUTES (t));\n+  return cp_build_type_attribute_variant (t, attrs);\n+}\n+\n+/* Return true iff FROM can convert to TO by a transaction-safety\n+   conversion.  */\n+\n+bool\n+can_convert_tx_safety (tree to, tree from)\n+{\n+  return (flag_tm && tx_safe_fn_type_p (from)\n+\t  && same_type_p (to, tx_unsafe_fn_variant (from)));\n+}"}, {"sha": "eff52819acaef34cfe1c775df972b630362be0ae", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -230,6 +230,7 @@ struct GTY((for_user)) named_label_entry {\n   bool in_try_scope;\n   bool in_catch_scope;\n   bool in_omp_scope;\n+  bool in_transaction_scope;\n };\n \n #define named_labels cp_function_chain->x_named_labels\n@@ -498,6 +499,9 @@ poplevel_named_label_1 (named_label_entry **slot, cp_binding_level *bl)\n \tcase sk_omp:\n \t  ent->in_omp_scope = true;\n \t  break;\n+\tcase sk_transaction:\n+\t  ent->in_transaction_scope = true;\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n@@ -2049,6 +2053,17 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t    }\n \t}\n \n+      /* An explicit specialization of a function template or of a member\n+\t function of a class template can be declared transaction_safe\n+\t independently of whether the corresponding template entity is declared\n+\t transaction_safe. */\n+      if (flag_tm && TREE_CODE (newdecl) == FUNCTION_DECL\n+\t  && DECL_TEMPLATE_INSTANTIATION (olddecl)\n+\t  && DECL_TEMPLATE_SPECIALIZATION (newdecl)\n+\t  && tx_safe_fn_type_p (newtype)\n+\t  && !tx_safe_fn_type_p (TREE_TYPE (newdecl)))\n+\tnewtype = tx_unsafe_fn_variant (newtype);\n+\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n \n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n@@ -2975,7 +2990,7 @@ check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,\n {\n   cp_binding_level *b;\n   bool identified = false, complained = false;\n-  bool saw_eh = false, saw_omp = false;\n+  bool saw_eh = false, saw_omp = false, saw_tm = false;\n \n   if (exited_omp)\n     {\n@@ -3043,6 +3058,18 @@ check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,\n \t    inform (input_location, \"  enters OpenMP structured block\");\n \t  saw_omp = true;\n \t}\n+      if (b->kind == sk_transaction && !saw_tm)\n+\t{\n+\t  if (!identified)\n+\t    {\n+\t      complained = identify_goto (decl, locus);\n+\t      identified = true;\n+\t    }\n+\t  if (complained)\n+\t    inform (input_location,\n+\t\t    \"  enters synchronized or atomic statement\");\n+\t  saw_tm = true;\n+\t}\n     }\n \n   return !identified;\n@@ -3109,7 +3136,7 @@ check_goto (tree decl)\n       return;\n     }\n \n-  if (ent->in_try_scope || ent->in_catch_scope\n+  if (ent->in_try_scope || ent->in_catch_scope || ent->in_transaction_scope\n       || ent->in_omp_scope || !vec_safe_is_empty (ent->bad_decls))\n     {\n       complained = permerror (DECL_SOURCE_LOCATION (decl),\n@@ -3148,6 +3175,8 @@ check_goto (tree decl)\n \tinform (input_location, \"  enters try block\");\n       else if (ent->in_catch_scope && !saw_catch)\n \tinform (input_location, \"  enters catch block\");\n+      else if (ent->in_transaction_scope)\n+\tinform (input_location, \"  enters synchronized or atomic statement\");\n     }\n \n   if (ent->in_omp_scope)\n@@ -9976,6 +10005,8 @@ grokdeclarator (const cp_declarator *declarator,\n             virt_specifiers = declarator->u.function.virt_specifiers;\n \t    /* And ref-qualifier, too */\n \t    rqual = declarator->u.function.ref_qualifier;\n+\t    /* And tx-qualifier.  */\n+\t    tree tx_qual = declarator->u.function.tx_qualifier;\n \t    /* Pick up the exception specifications.  */\n \t    raises = declarator->u.function.exception_specification;\n \t    /* If the exception-specification is ill-formed, let's pretend\n@@ -10153,13 +10184,24 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \n \t    type = build_function_type (type, arg_types);\n-\t    if (declarator->std_attributes)\n+\n+\t    tree attrs = declarator->std_attributes;\n+\t    if (tx_qual)\n+\t      {\n+\t\ttree att = build_tree_list (tx_qual, NULL_TREE);\n+\t\t/* transaction_safe applies to the type, but\n+\t\t   transaction_safe_dynamic applies to the function.  */\n+\t\tif (is_attribute_p (\"transaction_safe\", tx_qual))\n+\t\t  attrs = chainon (attrs, att);\n+\t\telse\n+\t\t  returned_attrs = chainon (returned_attrs, att);\n+\t      }\n+\t    if (attrs)\n \t      /* [dcl.fct]/2:\n \n \t\t The optional attribute-specifier-seq appertains to\n \t\t the function type.  */\n-\t      decl_attributes (&type, declarator->std_attributes,\n-\t\t\t       0);\n+\t      decl_attributes (&type, attrs, 0);\n \t  }\n \t  break;\n "}, {"sha": "17870b5f1c382aafa078c6982e2a27dda868f9a9", "filename": "gcc/cp/error.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -868,6 +868,8 @@ dump_type_suffix (cxx_pretty_printer *pp, tree t, int flags)\n \t\t\t      TREE_CODE (t) == FUNCTION_TYPE\n \t\t\t      && (flags & TFF_POINTER));\n \tdump_ref_qualifier (pp, t, flags);\n+\tif (tx_safe_fn_type_p (t))\n+\t  pp_cxx_ws_string (pp, \"transaction_safe\");\n \tdump_exception_spec (pp, TYPE_RAISES_EXCEPTIONS (t), flags);\n \tdump_type_suffix (pp, TREE_TYPE (t), flags);\n \tbreak;\n@@ -1570,6 +1572,12 @@ dump_function_decl (cxx_pretty_printer *pp, tree t, int flags)\n \t  dump_ref_qualifier (pp, fntype, flags);\n \t}\n \n+      if (tx_safe_fn_type_p (fntype))\n+\t{\n+\t  pp->padding = pp_before;\n+\t  pp_cxx_ws_string (pp, \"transaction_safe\");\n+\t}\n+\n       if (flags & TFF_EXCEPTION_SPECIFICATION)\n \t{\n \t  pp->padding = pp_before;"}, {"sha": "ceab646957436ff1786da53e70500e4c907f5d99", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -895,7 +895,8 @@ maybe_add_lambda_conv_op (tree type)\n \n   vec<tree, va_gc> *direct_argvec = 0;\n   tree decltype_call = 0, call = 0;\n-  tree fn_result = TREE_TYPE (TREE_TYPE (callop));\n+  tree optype = TREE_TYPE (callop);\n+  tree fn_result = TREE_TYPE (optype);\n \n   if (generic_lambda_p)\n     {\n@@ -993,6 +994,8 @@ maybe_add_lambda_conv_op (tree type)\n   CALL_FROM_THUNK_P (call) = 1;\n \n   tree stattype = build_function_type (fn_result, FUNCTION_ARG_CHAIN (callop));\n+  stattype = (cp_build_type_attribute_variant\n+\t      (stattype, TYPE_ATTRIBUTES (optype)));\n \n   /* First build up the conversion op.  */\n "}, {"sha": "6acf47e631e3799f20cfeefad2ac4a3f4ded3f4f", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -176,6 +176,8 @@ init_reswords (void)\n     mask |= D_CXX11;\n   if (!flag_concepts)\n     mask |= D_CXX_CONCEPTS;\n+  if (!flag_tm)\n+    mask |= D_TRANSMEM;\n   if (flag_no_asm)\n     mask |= D_ASM | D_EXT;\n   if (flag_no_gnu_keywords)"}, {"sha": "faeea1415281129f49d7f635c4c468495da5e117", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1911,7 +1911,13 @@ write_type (tree type)\n     {\n       tree t = TYPE_MAIN_VARIANT (type);\n       if (TYPE_ATTRIBUTES (t) && !OVERLOAD_TYPE_P (t))\n-\tt = cp_build_type_attribute_variant (t, NULL_TREE);\n+\t{\n+\t  tree attrs = NULL_TREE;\n+\t  if (tx_safe_fn_type_p (type))\n+\t    attrs = tree_cons (get_identifier (\"transaction_safe\"),\n+\t\t\t       NULL_TREE, attrs);\n+\t  t = cp_build_type_attribute_variant (t, attrs);\n+\t}\n       gcc_assert (t != type);\n       if (TREE_CODE (t) == FUNCTION_TYPE\n \t  || TREE_CODE (t) == METHOD_TYPE)\n@@ -2209,6 +2215,7 @@ write_CV_qualifiers_for_type (const tree type)\n \t  tree name = get_attribute_name (a);\n \t  const attribute_spec *as = lookup_attribute_spec (name);\n \t  if (as && as->affects_type_identity\n+\t      && !is_attribute_p (\"transaction_safe\", name)\n \t      && !is_attribute_p (\"abi_tag\", name))\n \t    vec.safe_push (a);\n \t}\n@@ -2470,6 +2477,9 @@ write_function_type (const tree type)\n       write_CV_qualifiers_for_type (this_type);\n     }\n \n+  if (tx_safe_fn_type_p (type))\n+    write_string (\"Dx\");\n+\n   write_char ('F');\n   /* We don't track whether or not a type is `extern \"C\"'.  Note that\n      you can have an `extern \"C\"' function that does not have"}, {"sha": "b5030120d6d66a2cb45665d8f7285230c79ed933", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1591,6 +1591,7 @@ begin_scope (scope_kind kind, tree entity)\n     case sk_class:\n     case sk_scoped_enum:\n     case sk_function_parms:\n+    case sk_transaction:\n     case sk_omp:\n       scope->keep = keep_next_level_flag;\n       break;"}, {"sha": "d430edb73b74d4fa98266c0058feca1b5dcc05ac", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -121,6 +121,7 @@ enum scope_kind {\n \t\t\tspecialization.  Since, by definition, an\n \t\t\texplicit specialization is introduced by\n \t\t\t\"template <>\", this scope is always empty.  */\n+  sk_transaction,    /* A synchronized or atomic statement.  */\n   sk_omp\t     /* An OpenMP structured block.  */\n };\n "}, {"sha": "ffed595ac0e01f46b4a39450867e2e6f972fe10d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 94, "deletions": 29, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -829,6 +829,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n \tcase RID_THROW:     token->keyword = RID_AT_THROW; break;\n \tcase RID_TRY:       token->keyword = RID_AT_TRY; break;\n \tcase RID_CATCH:     token->keyword = RID_AT_CATCH; break;\n+\tcase RID_SYNCHRONIZED: token->keyword = RID_AT_SYNCHRONIZED; break;\n \tdefault:            token->keyword = C_RID_CODE (token->u.value);\n \t}\n     }\n@@ -1343,7 +1344,7 @@ clear_decl_specs (cp_decl_specifier_seq *decl_specs)\n    VAR_DECLs or FUNCTION_DECLs) should do that directly.  */\n \n static cp_declarator *make_call_declarator\n-  (cp_declarator *, tree, cp_cv_quals, cp_virt_specifiers, cp_ref_qualifier, tree, tree, tree);\n+  (cp_declarator *, tree, cp_cv_quals, cp_virt_specifiers, cp_ref_qualifier, tree, tree, tree, tree);\n static cp_declarator *make_array_declarator\n   (cp_declarator *, tree);\n static cp_declarator *make_pointer_declarator\n@@ -1521,6 +1522,7 @@ make_call_declarator (cp_declarator *target,\n \t\t      cp_cv_quals cv_qualifiers,\n \t\t      cp_virt_specifiers virt_specifiers,\n \t\t      cp_ref_qualifier ref_qualifier,\n+\t\t      tree tx_qualifier,\n \t\t      tree exception_specification,\n \t\t      tree late_return_type,\n \t\t      tree requires_clause)\n@@ -1533,6 +1535,7 @@ make_call_declarator (cp_declarator *target,\n   declarator->u.function.qualifiers = cv_qualifiers;\n   declarator->u.function.virt_specifiers = virt_specifiers;\n   declarator->u.function.ref_qualifier = ref_qualifier;\n+  declarator->u.function.tx_qualifier = tx_qualifier;\n   declarator->u.function.exception_specification = exception_specification;\n   declarator->u.function.late_return_type = late_return_type;\n   declarator->u.function.requires_clause = requires_clause;\n@@ -2029,7 +2032,7 @@ static void cp_parser_label_for_labeled_statement\n static tree cp_parser_expression_statement\n   (cp_parser *, tree);\n static tree cp_parser_compound_statement\n-  (cp_parser *, tree, bool, bool);\n+  (cp_parser *, tree, int, bool);\n static void cp_parser_statement_seq_opt\n   (cp_parser *, tree);\n static tree cp_parser_selection_statement\n@@ -2139,6 +2142,8 @@ static cp_virt_specifiers cp_parser_virt_specifier_seq_opt\n   (cp_parser *);\n static cp_ref_qualifier cp_parser_ref_qualifier_opt\n   (cp_parser *);\n+static tree cp_parser_tx_qualifier_opt\n+  (cp_parser *);\n static tree cp_parser_late_return_type_opt\n   (cp_parser *, cp_declarator *, tree &, cp_cv_quals);\n static tree cp_parser_declarator_id\n@@ -2346,7 +2351,7 @@ static tree cp_parser_nested_requirement\n /* Transactional Memory Extensions */\n \n static tree cp_parser_transaction\n-  (cp_parser *, enum rid);\n+  (cp_parser *, cp_token *);\n static tree cp_parser_transaction_expression\n   (cp_parser *, enum rid);\n static bool cp_parser_function_transaction\n@@ -4262,7 +4267,7 @@ cp_parser_statement_expr (cp_parser *parser)\n   /* Start the statement-expression.  */\n   tree expr = begin_stmt_expr ();\n   /* Parse the compound-statement.  */\n-  cp_parser_compound_statement (parser, expr, false, false);\n+  cp_parser_compound_statement (parser, expr, BCS_NORMAL, false);\n   /* Finish up.  */\n   expr = finish_stmt_expr (expr, false);\n   /* Consume the ')'.  */\n@@ -9630,6 +9635,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n   tree attributes = NULL_TREE;\n   tree exception_spec = NULL_TREE;\n   tree template_param_list = NULL_TREE;\n+  tree tx_qual = NULL_TREE;\n \n   /* The template-parameter-list is optional, but must begin with\n      an opening angle if present.  */\n@@ -9680,6 +9686,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n           LAMBDA_EXPR_MUTABLE_P (lambda_expr) = 1;\n         }\n \n+      tx_qual = cp_parser_tx_qualifier_opt (parser);\n+\n       /* Parse optional exception specification.  */\n       exception_spec = cp_parser_exception_specification_opt (parser);\n \n@@ -9727,6 +9735,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     declarator = make_call_declarator (declarator, param_list, quals,\n \t\t\t\t       VIRT_SPEC_UNSPECIFIED,\n                                        REF_QUAL_NONE,\n+\t\t\t\t       tx_qual,\n \t\t\t\t       exception_spec,\n                                        /*late_return_type=*/NULL_TREE,\n                                        /*requires_clause*/NULL_TREE);\n@@ -10043,7 +10052,10 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t  \n \tcase RID_TRANSACTION_ATOMIC:\n \tcase RID_TRANSACTION_RELAXED:\n-\t  statement = cp_parser_transaction (parser, keyword);\n+\tcase RID_SYNCHRONIZED:\n+\tcase RID_ATOMIC_NOEXCEPT:\n+\tcase RID_ATOMIC_CANCEL:\n+\t  statement = cp_parser_transaction (parser, token);\n \t  break;\n \tcase RID_TRANSACTION_CANCEL:\n \t  statement = cp_parser_transaction_cancel (parser);\n@@ -10072,7 +10084,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n     }\n   /* Anything that starts with a `{' must be a compound-statement.  */\n   else if (token->type == CPP_OPEN_BRACE)\n-    statement = cp_parser_compound_statement (parser, NULL, false, false);\n+    statement = cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);\n   /* CPP_PRAGMA is a #pragma inside a function body, which constitutes\n      a statement all its own.  */\n   else if (token->type == CPP_PRAGMA)\n@@ -10327,7 +10339,7 @@ cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n \n static tree\n cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n-\t\t\t      bool in_try, bool function_body)\n+\t\t\t      int bcs_flags, bool function_body)\n {\n   tree compound_stmt;\n \n@@ -10339,7 +10351,7 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n     pedwarn (input_location, OPT_Wpedantic,\n \t     \"compound-statement in constexpr function\");\n   /* Begin the compound-statement.  */\n-  compound_stmt = begin_compound_stmt (in_try ? BCS_TRY_BLOCK : 0);\n+  compound_stmt = begin_compound_stmt (bcs_flags);\n   /* If the next keyword is `__label__' we have a label declaration.  */\n   while (cp_lexer_next_token_is_keyword (parser->lexer, RID_LABEL))\n     cp_parser_label_declaration (parser);\n@@ -11500,7 +11512,7 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p,\n     }\n   /* if a compound is opened, we simply parse the statement directly.  */\n   else if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n-    statement = cp_parser_compound_statement (parser, NULL, false, false);\n+    statement = cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);\n   /* If the token is not a `{', then we must take special action.  */\n   else\n     {\n@@ -18451,6 +18463,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n \t\t  /* Parse the ref-qualifier. */\n \t\t  ref_qual = cp_parser_ref_qualifier_opt (parser);\n+\t\t  /* Parse the tx-qualifier.  */\n+\t\t  tree tx_qual = cp_parser_tx_qualifier_opt (parser);\n \t\t  /* And the exception-specification.  */\n \t\t  exception_specification\n \t\t    = cp_parser_exception_specification_opt (parser);\n@@ -18489,6 +18503,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t\t     cv_quals,\n \t\t\t\t\t\t     virt_specifiers,\n \t\t\t\t\t\t     ref_qual,\n+\t\t\t\t\t\t     tx_qual,\n \t\t\t\t\t\t     exception_specification,\n \t\t\t\t\t\t     late_return,\n \t\t\t\t\t\t     requires_clause);\n@@ -19101,6 +19116,41 @@ cp_parser_ref_qualifier_opt (cp_parser* parser)\n   return ref_qual;\n }\n \n+/* Parse an optional tx-qualifier.\n+\n+   tx-qualifier:\n+     transaction_safe\n+     transaction_safe_dynamic  */\n+\n+static tree\n+cp_parser_tx_qualifier_opt (cp_parser *parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type == CPP_NAME)\n+    {\n+      tree name = token->u.value;\n+      const char *p = IDENTIFIER_POINTER (name);\n+      const int len = strlen (\"transaction_safe\");\n+      if (!strncmp (p, \"transaction_safe\", len))\n+\t{\n+\t  p += len;\n+\t  if (*p == '\\0'\n+\t      || !strcmp (p, \"_dynamic\"))\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      if (!flag_tm)\n+\t\t{\n+\t\t  error (\"%E requires %<-fgnu-tm%>\", name);\n+\t\t  return NULL_TREE;\n+\t\t}\n+\t      else\n+\t\treturn name;\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Parse an (optional) virt-specifier-seq.\n \n    virt-specifier-seq:\n@@ -20109,7 +20159,9 @@ cp_parser_default_argument (cp_parser *parser, bool template_parm_p)\n static void\n cp_parser_function_body (cp_parser *parser, bool in_function_try_block)\n {\n-  cp_parser_compound_statement (parser, NULL, in_function_try_block, true);\n+  cp_parser_compound_statement (parser, NULL, (in_function_try_block\n+\t\t\t\t\t       ? BCS_TRY_BLOCK : BCS_NORMAL),\n+\t\t\t\ttrue);\n }\n \n /* Parse a ctor-initializer-opt followed by a function-body.  Return\n@@ -22598,7 +22650,7 @@ cp_parser_try_block (cp_parser* parser)\n     error (\"%<try%> in %<constexpr%> function\");\n \n   try_block = begin_try_block ();\n-  cp_parser_compound_statement (parser, NULL, true, false);\n+  cp_parser_compound_statement (parser, NULL, BCS_TRY_BLOCK, false);\n   finish_try_block (try_block);\n   cp_parser_handler_seq (parser);\n   finish_handler_sequence (try_block);\n@@ -22675,7 +22727,7 @@ cp_parser_handler (cp_parser* parser)\n   declaration = cp_parser_exception_declaration (parser);\n   finish_handler_parms (declaration, handler);\n   cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-  cp_parser_compound_statement (parser, NULL, false, false);\n+  cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);\n   finish_handler (handler);\n }\n \n@@ -23354,6 +23406,14 @@ cp_parser_std_attribute (cp_parser *parser)\n \t\t     \" use %<gnu::deprecated%>\");\n \t  TREE_PURPOSE (TREE_PURPOSE (attribute)) = get_identifier (\"gnu\");\n \t}\n+      /* Transactional Memory TS optimize_for_synchronized attribute is\n+\t equivalent to GNU transaction_callable.  */\n+      else if (is_attribute_p (\"optimize_for_synchronized\", attr_id))\n+\tTREE_PURPOSE (attribute)\n+\t  = get_identifier (\"transaction_callable\");\n+      /* Transactional Memory attributes are GNU attributes.  */\n+      else if (tm_attr_to_mask (attr_id))\n+\tTREE_PURPOSE (attribute) = attr_id;\n     }\n \n   /* Now parse the optional argument clause of the attribute.  */\n@@ -28391,7 +28451,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n   /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST\n      node, lest it get absorbed into the surrounding block.  */\n   stmt = push_stmt_list ();\n-  cp_parser_compound_statement (parser, NULL, false, false);\n+  cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);\n   objc_begin_try_stmt (location, pop_stmt_list (stmt));\n \n   while (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_CATCH))\n@@ -28447,7 +28507,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n \t     forget about the closing parenthesis and keep going.  */\n \t}\n       objc_begin_catch_clause (parameter_declaration);\n-      cp_parser_compound_statement (parser, NULL, false, false);\n+      cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);\n       objc_finish_catch_clause ();\n     }\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_FINALLY))\n@@ -28457,7 +28517,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n       /* NB: The @finally block needs to be wrapped in its own STATEMENT_LIST\n \t node, lest it get absorbed into the surrounding block.  */\n       stmt = push_stmt_list ();\n-      cp_parser_compound_statement (parser, NULL, false, false);\n+      cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);\n       objc_build_finally_clause (location, pop_stmt_list (stmt));\n     }\n \n@@ -28488,7 +28548,7 @@ cp_parser_objc_synchronized_statement (cp_parser *parser)\n   /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n      node, lest it get absorbed into the surrounding block.  */\n   stmt = push_stmt_list ();\n-  cp_parser_compound_statement (parser, NULL, false, false);\n+  cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);\n \n   return objc_build_synchronized (location, lock, pop_stmt_list (stmt));\n }\n@@ -33964,8 +34024,8 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n \tattribute\n \t[ [ identifier ] ]\n \n-   ??? Simplify this when C++0x bracket attributes are\n-   implemented properly.  */\n+   We use this instead of cp_parser_attributes_opt for transactions to avoid\n+   the pedwarn in C++98 mode.  */\n \n static tree\n cp_parser_txn_attribute_opt (cp_parser *parser)\n@@ -34012,21 +34072,17 @@ cp_parser_txn_attribute_opt (cp_parser *parser)\n */\n \n static tree\n-cp_parser_transaction (cp_parser *parser, enum rid keyword)\n+cp_parser_transaction (cp_parser *parser, cp_token *token)\n {\n   unsigned char old_in = parser->in_transaction;\n   unsigned char this_in = 1, new_in;\n-  cp_token *token;\n+  enum rid keyword = token->keyword;\n   tree stmt, attrs, noex;\n \n-  gcc_assert (keyword == RID_TRANSACTION_ATOMIC\n-      || keyword == RID_TRANSACTION_RELAXED);\n-  token = cp_parser_require_keyword (parser, keyword,\n-      (keyword == RID_TRANSACTION_ATOMIC ? RT_TRANSACTION_ATOMIC\n-\t  : RT_TRANSACTION_RELAXED));\n-  gcc_assert (token != NULL);\n+  cp_lexer_consume_token (parser->lexer);\n \n-  if (keyword == RID_TRANSACTION_RELAXED)\n+  if (keyword == RID_TRANSACTION_RELAXED\n+      || keyword == RID_SYNCHRONIZED)\n     this_in |= TM_STMT_ATTR_RELAXED;\n   else\n     {\n@@ -34036,15 +34092,24 @@ cp_parser_transaction (cp_parser *parser, enum rid keyword)\n     }\n \n   /* Parse a noexcept specification.  */\n-  noex = cp_parser_noexcept_specification_opt (parser, true, NULL, true);\n+  if (keyword == RID_ATOMIC_NOEXCEPT)\n+    noex = boolean_true_node;\n+  else if (keyword == RID_ATOMIC_CANCEL)\n+    {\n+      /* cancel-and-throw is unimplemented.  */\n+      sorry (\"atomic_cancel\");\n+      noex = NULL_TREE;\n+    }\n+  else\n+    noex = cp_parser_noexcept_specification_opt (parser, true, NULL, true);\n \n   /* Keep track if we're in the lexical scope of an outer transaction.  */\n   new_in = this_in | (old_in & TM_STMT_ATTR_OUTER);\n \n   stmt = begin_transaction_stmt (token->location, NULL, this_in);\n \n   parser->in_transaction = new_in;\n-  cp_parser_compound_statement (parser, NULL, false, false);\n+  cp_parser_compound_statement (parser, NULL, BCS_TRANSACTION, false);\n   parser->in_transaction = old_in;\n \n   finish_transaction_stmt (stmt, NULL, this_in, noex);"}, {"sha": "85be2b29d1567a7cf5e6f342f9b251a182564abb", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -983,6 +983,11 @@ ptr_initializer (tinfo_s *ti, tree target)\n \n   if (incomplete)\n     flags |= 8;\n+  if (tx_safe_fn_type_p (to))\n+    {\n+      flags |= 0x20;\n+      to = tx_unsafe_fn_variant (to);\n+    }\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, flags));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,"}, {"sha": "508e66c43bb37d0f40e0c7f5903dce94e37d6077", "filename": "gcc/cp/search.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -2014,15 +2014,33 @@ check_final_overrider (tree overrider, tree basefn)\n       return 0;\n     }\n \n-  /* Check for conflicting type attributes.  */\n-  if (!comp_type_attributes (over_type, base_type))\n+  /* Check for conflicting type attributes.  But leave transaction_safe for\n+     set_one_vmethod_tm_attributes.  */\n+  if (!comp_type_attributes (over_type, base_type)\n+      && !tx_safe_fn_type_p (base_type)\n+      && !tx_safe_fn_type_p (over_type))\n     {\n       error (\"conflicting type attributes specified for %q+#D\", overrider);\n       error (\"  overriding %q+#D\", basefn);\n       DECL_INVALID_OVERRIDER_P (overrider) = 1;\n       return 0;\n     }\n \n+  /* A function declared transaction_safe_dynamic that overrides a function\n+     declared transaction_safe (but not transaction_safe_dynamic) is\n+     ill-formed.  */\n+  if (tx_safe_fn_type_p (base_type)\n+      && lookup_attribute (\"transaction_safe_dynamic\",\n+\t\t\t   DECL_ATTRIBUTES (overrider))\n+      && !lookup_attribute (\"transaction_safe_dynamic\",\n+\t\t\t    DECL_ATTRIBUTES (basefn)))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (overrider),\n+\t\t\"%qD declared %<transaction_safe_dynamic%>\", overrider);\n+      inform (DECL_SOURCE_LOCATION (basefn),\n+\t      \"overriding %qD declared %<transaction_safe%>\", basefn);\n+    }\n+\n   if (DECL_DELETED_FN (basefn) != DECL_DELETED_FN (overrider))\n     {\n       if (DECL_DELETED_FN (overrider))"}, {"sha": "ea403987b235f8d0666d53c24b5a016622507ae6", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1355,7 +1355,14 @@ begin_compound_stmt (unsigned int flags)\n       keep_next_level (false);\n     }\n   else\n-    r = do_pushlevel (flags & BCS_TRY_BLOCK ? sk_try : sk_block);\n+    {\n+      scope_kind sk = sk_block;\n+      if (flags & BCS_TRY_BLOCK)\n+\tsk = sk_try;\n+      else if (flags & BCS_TRANSACTION)\n+\tsk = sk_transaction;\n+      r = do_pushlevel (sk);\n+    }\n \n   /* When processing a template, we need to remember where the braces were,\n      so that we can set up identical scopes when instantiating the template"}, {"sha": "9e6f9494e6fb8d2e3d2b41c36934502cbfa4e69c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -715,6 +715,22 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n           return error_mark_node;\n         }\n     }\n+  else if (TYPE_PTR_P (t1) && TYPE_PTR_P (t2)\n+\t   && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (t1))\n+\t   && TREE_CODE (TREE_TYPE (t2)) == TREE_CODE (TREE_TYPE (t1)))\n+    {\n+      /* ...if T1 is \"pointer to transaction_safe function\" and T2 is \"pointer\n+\t to function\", where the function types are otherwise the same, T2, and\n+\t vice versa.... */\n+      tree f1 = TREE_TYPE (t1);\n+      tree f2 = TREE_TYPE (t2);\n+      bool safe1 = tx_safe_fn_type_p (f1);\n+      bool safe2 = tx_safe_fn_type_p (f2);\n+      if (safe1 && !safe2)\n+\tt1 = build_pointer_type (tx_unsafe_fn_variant (f1));\n+      else if (safe2 && !safe1)\n+\tt2 = build_pointer_type (tx_unsafe_fn_variant (f2));\n+    }\n \n   return composite_pointer_type_r (t1, t2, operation, complain);\n }"}, {"sha": "6e823176128aa58822d60d0dfca7027f8e25a0cd", "filename": "gcc/testsuite/g++.dg/tm/composite1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fcomposite1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fcomposite1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fcomposite1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,14 @@\n+// Test for composite pointer type.\n+// { dg-options -fgnu-tm }\n+\n+void f(bool b)\n+{\n+  void (*p)() transaction_safe = 0;\n+  void (*g)() = 0;\n+\n+  g = b ? p : g;\t\t// OK\n+  p = b ? p : g;\t\t// { dg-error \"\" }\n+\n+  p == g;\n+  p != g;\n+}"}, {"sha": "a6f495674321fa99da343f1ba81c8f262f7b9108", "filename": "gcc/testsuite/g++.dg/tm/dynamic1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fdynamic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fdynamic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fdynamic1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,13 @@\n+// Test that transaction_safe_dynamic can only be used on virtual functions.\n+// { dg-options \"-fgnu-tm -std=c++14\" }\n+\n+void f() transaction_safe_dynamic; // { dg-error \"virtual\" }\n+auto a = []() transaction_safe_dynamic {}; // { dg-error \"virtual\" }\n+struct A {\n+  void f() transaction_safe_dynamic; // { dg-error \"virtual\" }\n+  virtual void g();\n+};\n+\n+struct B: A {\n+  void g() transaction_safe_dynamic;\n+};"}, {"sha": "3003b62ca0a40778bf25f3edccbf803b01dd2296", "filename": "gcc/testsuite/g++.dg/tm/dynamic2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fdynamic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fdynamic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fdynamic2.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-fgnu-tm -std=c++14 -O2\" }\n+\n+void unsafe();\n+struct A {\n+  virtual void f() transaction_safe_dynamic;\n+};\n+struct B:A {\n+  void f() { unsafe(); }\n+};\n+\n+void f() transaction_safe {\n+  B b;\n+  A& ar = b;\n+  // This is undefined behavior, we want to give an error with\n+  // devirtualization.\n+  ar.f();\t\t\t// { dg-error \"unsafe\" }\n+}"}, {"sha": "156121142e782a8c8635e35529372be9f04761bf", "filename": "gcc/testsuite/g++.dg/tm/eh1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,10 @@\n+// A handler can involve a transaction-safety conversion.\n+// { dg-do run }\n+// { dg-options \"-fgnu-tm\" }\n+\n+void g() transaction_safe {}\n+int main()\n+{\n+  try { throw g; }\n+  catch (void (*p)()) { }\n+}"}, {"sha": "307a63924c33b0c7fdb257b2e9f82ed0a5f21f6e", "filename": "gcc/testsuite/g++.dg/tm/eh2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh2.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,14 @@\n+// A handler cannot do the reverse of a transaction-safety conversion.\n+// { dg-do run }\n+// { dg-options \"-fgnu-tm\" }\n+\n+extern \"C\" void abort();\n+\n+void g() {}\n+\n+int main()\n+{\n+  try { throw g; }\n+  catch (void (*p)() transaction_safe) { abort(); }\n+  catch (...) { }\n+}"}, {"sha": "68275e99706d5d0add7fce575fdbb1b9449f55ab", "filename": "gcc/testsuite/g++.dg/tm/eh4.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Feh4.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,21 @@\n+// Test that throwing out of an atomic_commit block commits the transaction.\n+\n+// { dg-do run }\n+// { dg-options \"-fgnu-tm\" }\n+\n+int main()\n+{\n+  static int i;\n+  bool caught = false;\n+  try {\n+    atomic_commit {\n+      i = 12;\n+      throw 42;\n+      i = 24;\n+    }\n+  } catch (int x) {\n+    caught = (x == 42);\n+  }\n+  if (!caught || i != 12)\n+    __builtin_abort();\n+}"}, {"sha": "b8480a1089212cef34ba0f8c7a280dafea4d4298", "filename": "gcc/testsuite/g++.dg/tm/inherit1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Finherit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Finherit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Finherit1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,11 @@\n+// Testcase from TM TS\n+// { dg-options \"-std=c++14 -fgnu-tm\" }\n+\n+struct B {\n+  virtual void f() transaction_safe;\n+};\n+\n+struct D3 : B\n+{\n+  void f() transaction_safe_dynamic override; // { dg-error \"\" \"B::f() is transaction_safe\" }\n+};"}, {"sha": "3b696a9ffb686e41090a1dc7178cebd5a0c4c1c8", "filename": "gcc/testsuite/g++.dg/tm/inherit2.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Finherit2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Finherit2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Finherit2.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,33 @@\n+// Testcase from TM TS\n+// { dg-options \"-std=c++14 -fgnu-tm\" }\n+\n+#include <iostream>\n+\n+struct B {\n+  virtual void f() transaction_safe;\n+  virtual ~B() transaction_safe_dynamic;\n+};\n+// pre-existing code\n+struct D1 : B\n+{\n+  void f() override { } // ok\n+  ~D1() override { } // ok\n+};\n+struct D2 : B\n+{\n+  void f() override { std::cout << \"D2::f\" << std::endl; } // { dg-error \"\" \"transaction-safe f has transaction-unsafe definition\" }\n+  ~D2() override { std::cout << \"~D2\" << std::endl; } // ok\n+};\n+int main()\n+{\n+  D2 * d2 = new D2;\n+  B * b2 = d2;\n+  atomic_commit {\n+    B b; // ok\n+    D1 d1; // ok\n+    B& b1 = d1;\n+    D2 x; // { dg-error \"\" \"destructor of D2 is not transaction-safe\" }\n+    b1.f(); // ok, calls D1::f()\n+    delete b2; // undefined behavior: calls unsafe destructor of D2\n+  }\n+}"}, {"sha": "003eed034c919a387128d21b76f1113f831d7fbd", "filename": "gcc/testsuite/g++.dg/tm/jump1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fjump1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fjump1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fjump1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,23 @@\n+// A goto or switch statement shall not be used to transfer control into a\n+// synchronized or atomic block.\n+// { dg-options \"-fgnu-tm\" }\n+\n+void f()\n+{\n+  static int i;\n+  synchronized {\n+    ++i;\n+  inside:\t\t\t// { dg-message \"\" }\n+    ++i;\n+  }\n+  goto inside;\t\t\t// { dg-message \"\" }\n+\n+  switch (i)\n+    {\n+      synchronized {\n+\t++i;\n+      case 42:\t\t\t// { dg-error \"\" }\n+\t++i;\n+      }\n+    }\n+}"}, {"sha": "3537e0fe9923651e9931a2e51b732169120bc4d4", "filename": "gcc/testsuite/g++.dg/tm/keyword1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fkeyword1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fkeyword1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fkeyword1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,9 @@\n+// Test that these aren't keywords without -fgnu-tm.\n+\n+int main()\n+{\n+  synchronized { }\t\t// { dg-error \"not declared\" }\n+  atomic_noexcept { }\t\t// { dg-error \"not declared\" }\n+  atomic_cancel { }\t\t// { dg-error \"not declared\" }\n+  atomic_commit { }\t\t// { dg-error \"not declared\" }\n+}"}, {"sha": "d0cffbff22fba0d9baa3f51a9ffdb65452837bee", "filename": "gcc/testsuite/g++.dg/tm/lambda1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Flambda1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Flambda1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Flambda1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,10 @@\n+// Test for lambda conversion.\n+// { dg-options \"-fgnu-tm -std=c++14\" }\n+\n+void f(bool b)\n+{\n+  void (*p)() transaction_safe;\n+\n+  p = []() transaction_safe {};\n+  p = []{};\t\t\t// { dg-error \"transaction_safe\" }\n+}"}, {"sha": "82e509e3658175cef9efc3b2f0b557d3e8817397", "filename": "gcc/testsuite/g++.dg/tm/lambda2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Flambda2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Flambda2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Flambda2.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,9 @@\n+// Test for lambda call.\n+// { dg-options \"-fgnu-tm -std=c++14\" }\n+\n+void unsafe ();\n+void f() transaction_safe\n+{\n+  []{}(); \t\t\t// OK, implicitly transaction-safe.\n+  []{unsafe();}();\t\t// { dg-error \"unsafe\" }\n+}"}, {"sha": "dcf388839b1d0fde5904dcdd84adce69cd90e33e", "filename": "gcc/testsuite/g++.dg/tm/macro1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fmacro1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fmacro1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fmacro1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -fgnu-tm }\n+\n+#ifndef __cpp_transactional_memory\n+#error __cpp_transactional_memory not defined\n+#endif"}, {"sha": "f081f8e0289a7a5a63aaa40212ecc8d879aab29c", "filename": "gcc/testsuite/g++.dg/tm/mangle1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fmangle1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fmangle1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fmangle1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,18 @@\n+// Test for transaction_safe mangling.\n+// { dg-options -fgnu-tm }\n+\n+// { dg-final { scan-assembler \"_Z1fPDxFvvE\" } }\n+void f(void (*)() transaction_safe) {}\n+\n+// { dg-final { scan-assembler \"_Z1fPDxFvvEPFvvE\" } }\n+void f(void (*)() transaction_safe, void (*)()) {}\n+\n+// { dg-final { scan-assembler \"_Z1fPDxFvvES0_\" } }\n+void f(void (*)() transaction_safe, void (*)() transaction_safe) {}\n+\n+// { dg-final { scan-assembler \"_Z1f1AIKDxFvvEE\" } }\n+template <class T> struct A { };\n+void f(A<void () const transaction_safe>) { }\n+\n+// { dg-final { scan-assembler \"_Z1fM1AIiEKDxFvvE\" } }\n+void f(void (A<int>::*)() const transaction_safe) { }"}, {"sha": "bfa675c987fb9ee08933242c3fab237e79f35c82", "filename": "gcc/testsuite/g++.dg/tm/noexcept-7.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-7.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,7 @@\n+// FIXME the TS says atomic_noexcept calls abort, not terminate.\n+// { dg-options \"-fgnu-tm\" }\n+\n+void f()\n+{\n+  atomic_noexcept { throw; }\t// { dg-warning \"terminate\" }\n+}"}, {"sha": "71ecab9ff1516fc2565e8c0d110beb28ff02ff8e", "filename": "gcc/testsuite/g++.dg/tm/overload1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Foverload1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Foverload1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Foverload1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,6 @@\n+// Function declarations that differ only in the presence or absence of a\n+// tx-qualifier cannot be overloaded.\n+// { dg-options \"-fgnu-tm\" }\n+\n+void f();\t\t\t// { dg-message \"\" }\n+void f() transaction_safe;\t// { dg-error \"\" }"}, {"sha": "3510779644edf3181cfdd37e56ad7e1470527aaf", "filename": "gcc/testsuite/g++.dg/tm/overload2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Foverload2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Foverload2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Foverload2.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,9 @@\n+// 13.4p1: A function with type F is selected for the function type FT of the\n+// target type required in the context if F (after possibly applying the\n+// transaction-safety conversion (4.14 [conv.tx])) is identical to FT.\n+// { dg-options \"-fgnu-tm\" }\n+\n+void f() transaction_safe;\n+void f(int);\n+\n+void (*p)() = f;"}, {"sha": "d7c1de0ae520a14936f6b740f209eec1d70bad7e", "filename": "gcc/testsuite/g++.dg/tm/pretty-print1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpretty-print1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpretty-print1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpretty-print1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,6 @@\n+// Test for pretty-printing in diagnostics.\n+// { dg-options \"-fgnu-tm\" }\n+\n+void f();\n+void (*p)() transaction_safe = f; // { dg-error \"void \\\\(\\\\*\\\\)\\\\(\\\\) transaction_safe\" }\n+"}, {"sha": "31606c57a7ee3ffb2015685615944aac7b7785d2", "filename": "gcc/testsuite/g++.dg/tm/static_cast1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fstatic_cast1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fstatic_cast1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fstatic_cast1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,9 @@\n+// The inverse of a transaction-safety conversion cannot be performed with\n+// static_cast.\n+// { dg-options \"-fgnu-tm\" }\n+\n+typedef void (*TS)() transaction_safe;\n+void f()\n+{\n+  static_cast<TS>(f); // { dg-error \"static_cast\" }\n+}"}, {"sha": "a567b2cc3e26441f0e3fa20f084ea7e321f1caa4", "filename": "gcc/testsuite/g++.dg/tm/sync1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fsync1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fsync1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fsync1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,15 @@\n+// Testcase from TM TS.\n+// { dg-options -fgnu-tm }\n+\n+extern \"C\" int printf (const char *, ...);\n+\n+int f()\n+{\n+  static int i = 0;\n+  synchronized {\n+    printf(\"before %d\\n\", i);\n+    ++i;\n+    printf(\"after %d\\n\", i);\n+    return i;\n+  }\n+}"}, {"sha": "f13c9c55e90dff2ccf7d88e3bce50f9a0abbc820", "filename": "gcc/testsuite/g++.dg/tm/sync2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fsync2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fsync2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fsync2.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fgnu-tm -fdump-tree-optimized-asmname\" }\n+\n+struct Tsafe\n+{\n+  void f() transaction_safe;\n+};\n+\n+void Tsafe::f() { }\n+\n+struct Tcall\n+{\n+  [[optimize_for_synchronized]] void f();\n+};\n+\n+void Tcall::f() { }\n+\n+// { dg-final { scan-tree-dump-times \"_ZN5Tsafe1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZN5Tcall1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZGTtN5Tsafe1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZGTtN5Tcall1fEv\" 1 \"optimized\" } }"}, {"sha": "356d2a89b9b3478a80e53ae434bc4b938cbc4752", "filename": "gcc/testsuite/g++.dg/tm/template-3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-3.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-fgnu-tm\" }\n+\n+void fn(int) transaction_safe;\n+void fn(double);\n+\n+template <class T> void f(T t) transaction_safe\n+{\n+  fn(t);\t\t\t// { dg-error \"double\" }\n+}\n+\n+void g()\n+{\n+  f(42); // OK\n+  f(3.14);\n+}"}, {"sha": "dd257111bda77563126850badc7fc8dd851a1ec0", "filename": "gcc/testsuite/g++.dg/tm/template-4.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-4.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,13 @@\n+// Test for transaction-safety conversion in deduction.\n+// { dg-options \"-fgnu-tm\" }\n+\n+void fn(int) transaction_safe;\n+void fn();\n+\n+template <class T> void f(void(*)(T));\n+template <class T> void f2(void(*)(T) transaction_safe);\n+\n+void g()\n+{\n+  f(fn);\n+}"}, {"sha": "6501ed1a073d19a94ed35cc9754d0a3b3950ab2a", "filename": "gcc/testsuite/g++.dg/tm/template-5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-5.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,12 @@\n+// Test for deduction based on transaction_safe.\n+// { dg-options \"-fgnu-tm -std=c++11\" }\n+\n+void f() transaction_safe;\n+void g();\n+\n+template <class T> struct A;\n+template <class R, class...Ps>\n+struct A<R (Ps...) transaction_safe> { };\n+\n+A<decltype(f)> a;\n+A<decltype(g)> b;\t\t// { dg-error \"incomplete\" }"}, {"sha": "91dd7b110ecf8c98da2d9a3c792508ce502b77e0", "filename": "gcc/testsuite/g++.dg/tm/unsafe1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Funsafe1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Funsafe1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Funsafe1.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,15 @@\n+// Transaction-unsafe testcase from TM TS.\n+// { dg-options -fgnu-tm }\n+\n+struct S {\n+  virtual ~S();\n+};\n+int f() transaction_safe {\n+  S s;\t\t     // { dg-error \"unsafe\" \"invocation of unsafe destructor\" }\n+}\n+\n+int g(int x) { // is transaction-safe\n+  if (x <= 0)\n+    return 0;\n+  return x + g(x-1);\n+}"}, {"sha": "1b81b3100577ea027371d7c363f8685af2416667", "filename": "gcc/testsuite/g++.dg/tm/unsafe2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Funsafe2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Funsafe2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Funsafe2.C?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -0,0 +1,13 @@\n+// Transaction-unsafe testcase from TM TS.\n+// { dg-options -fgnu-tm }\n+\n+template<class T>\n+void f(T) transaction_safe;\n+template<>\n+void f(bool); // not transaction-safe\n+\n+int g() transaction_safe\n+{\n+  f(42);\t\t\t// OK\n+  f(true);\t\t\t// { dg-error \"unsafe\" }\n+}"}, {"sha": "229fbc3f633eb6b4fd45b2ddb8b0fdc700367ec9", "filename": "gcc/testsuite/lib/g++.exp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -141,6 +141,10 @@ proc g++_link_flags { paths } {\n       if [file exists \"${gccpath}/librx/librx.a\"] {\n           append flags \"-L${gccpath}/librx \"\n       }\n+      if [file exists \"${gccpath}/libitm/libitm.spec\"] {\n+\t  append flags \"-B${gccpath}/libitm/ -L${gccpath}/libitm/.libs\"\n+\t  append ld_library_path \":${gccpath}/libitm/.libs\"\n+      }\n       append ld_library_path [gcc-set-multilib-library-path $GXX_UNDER_TEST]\n     } else {\n       global tool_root_dir"}, {"sha": "af318495f0f1f091d45c06dfef218dfbd98343f8", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -5017,6 +5017,8 @@ comp_type_attributes (const_tree type1, const_tree type2)\n       if (!a)\n         return 1;\n     }\n+  if (lookup_attribute (\"transaction_safe\", CONST_CAST_TREE (a)))\n+    return 0;\n   /* As some type combinations - like default calling-convention - might\n      be compatible, we have to call the target hook to get the final result.  */\n   return targetm.comp_type_attributes (type1, type2);"}, {"sha": "4c803f4b4e3f04045083d6d4659fb01939992df5", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -592,6 +592,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define COMPLETE_OR_UNBOUND_ARRAY_TYPE_P(NODE) \\\n   (COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : (NODE)))\n \n+#define FUNC_OR_METHOD_TYPE_P(NODE) \\\n+  (TREE_CODE (NODE) == FUNCTION_TYPE || TREE_CODE (NODE) == METHOD_TYPE)\n+\n /* Define many boolean fields that all tree nodes have.  */\n \n /* In VAR_DECL, PARM_DECL and RESULT_DECL nodes, nonzero means address"}, {"sha": "f4c41218e7fea0bdaf05c9b5747a3f6172698e23", "filename": "include/demangle.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -442,6 +442,8 @@ enum demangle_component_type\n   DEMANGLE_COMPONENT_PACK_EXPANSION,\n   /* A name with an ABI tag.  */\n   DEMANGLE_COMPONENT_TAGGED_NAME,\n+  /* A transaction-safe function type.  */\n+  DEMANGLE_COMPONENT_TRANSACTION_SAFE,\n   /* A cloned function.  */\n   DEMANGLE_COMPONENT_CLONE\n };"}, {"sha": "1cd2aea1f97762f0b047c09c6d9c9dc37a518f81", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -1,3 +1,12 @@\n+2015-09-30  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_cv_qualifiers): Dx means transaction_safe.\n+\t(cplus_demangle_type): Let d_cv_qualifiers handle it.\n+\t(d_dump, d_make_comp, has_return_type, d_encoding)\n+\t(d_count_templates_scopes, d_print_comp_inner)\n+\t(d_print_mod_list, d_print_mod, d_print_function_type)\n+\t(is_ctor_or_dtor): Handle DEMANGLE_COMPONENT_TRANSACTION_SAFE.\n+\n 2015-08-15  Ian Lance Taylor  <iant@google.com>\n \n \t* cp-demangle.c (d_abi_tags): Preserve di->last_name across any"}, {"sha": "ff608a36d670d73a9f1bf681dd20d1b1f2767006", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -686,6 +686,9 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n       printf (\"rvalue reference this\\n\");\n       break;\n+    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n+      printf (\"transaction_safe this\\n\");\n+      break;\n     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n       printf (\"vendor type qualifier\\n\");\n       break;\n@@ -970,6 +973,7 @@ d_make_comp (struct d_info *di, enum demangle_component_type type,\n     case DEMANGLE_COMPONENT_RESTRICT_THIS:\n     case DEMANGLE_COMPONENT_VOLATILE_THIS:\n     case DEMANGLE_COMPONENT_CONST_THIS:\n+    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n     case DEMANGLE_COMPONENT_REFERENCE_THIS:\n     case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n     case DEMANGLE_COMPONENT_ARGLIST:\n@@ -1212,6 +1216,7 @@ has_return_type (struct demangle_component *dc)\n     case DEMANGLE_COMPONENT_CONST_THIS:\n     case DEMANGLE_COMPONENT_REFERENCE_THIS:\n     case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n+    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n       return has_return_type (d_left (dc));\n     }\n }\n@@ -1268,6 +1273,7 @@ d_encoding (struct d_info *di, int top_level)\n \t  while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n \t\t || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n \t\t || dc->type == DEMANGLE_COMPONENT_CONST_THIS\n+\t\t || dc->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n \t\t || dc->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n \t\t || dc->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n \t    dc = d_left (dc);\n@@ -1284,6 +1290,7 @@ d_encoding (struct d_info *di, int top_level)\n \t      while (dcr->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n \t\t     || dcr->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n \t\t     || dcr->type == DEMANGLE_COMPONENT_CONST_THIS\n+\t\t     || dcr->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n \t\t     || dcr->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n \t\t     || dcr->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n \t\tdcr = d_left (dcr);\n@@ -2281,7 +2288,8 @@ cplus_demangle_type (struct d_info *di)\n      names.  */\n \n   peek = d_peek_char (di);\n-  if (peek == 'r' || peek == 'V' || peek == 'K')\n+  if (peek == 'r' || peek == 'V' || peek == 'K'\n+      || (peek == 'D' && d_peek_next_char (di) == 'x'))\n     {\n       struct demangle_component **pret;\n \n@@ -2592,7 +2600,7 @@ cplus_demangle_type (struct d_info *di)\n   return ret;\n }\n \n-/* <CV-qualifiers> ::= [r] [V] [K]  */\n+/* <CV-qualifiers> ::= [r] [V] [K] [Dx] */\n \n static struct demangle_component **\n d_cv_qualifiers (struct d_info *di,\n@@ -2603,7 +2611,8 @@ d_cv_qualifiers (struct d_info *di,\n \n   pstart = pret;\n   peek = d_peek_char (di);\n-  while (peek == 'r' || peek == 'V' || peek == 'K')\n+  while (peek == 'r' || peek == 'V' || peek == 'K'\n+\t || (peek == 'D' && d_peek_next_char (di) == 'x'))\n     {\n       enum demangle_component_type t;\n \n@@ -2622,13 +2631,19 @@ d_cv_qualifiers (struct d_info *di,\n \t       : DEMANGLE_COMPONENT_VOLATILE);\n \t  di->expansion += sizeof \"volatile\";\n \t}\n-      else\n+      else if (peek == 'K')\n \t{\n \t  t = (member_fn\n \t       ? DEMANGLE_COMPONENT_CONST_THIS\n \t       : DEMANGLE_COMPONENT_CONST);\n \t  di->expansion += sizeof \"const\";\n \t}\n+      else\n+\t{\n+\t  t = DEMANGLE_COMPONENT_TRANSACTION_SAFE;\n+\t  di->expansion += sizeof \"transaction_safe\";\n+\t  d_advance (di, 1);\n+\t}\n \n       *pret = d_make_comp (di, t, NULL, NULL);\n       if (*pret == NULL)\n@@ -2694,7 +2709,7 @@ d_ref_qualifier (struct d_info *di, struct demangle_component *sub)\n   return ret;\n }\n \n-/* <function-type> ::= F [Y] <bare-function-type> [<ref-qualifier>] E  */\n+/* <function-type> ::= F [Y] <bare-function-type> [<ref-qualifier>] [T] E  */\n \n static struct demangle_component *\n d_function_type (struct d_info *di)\n@@ -3899,6 +3914,7 @@ d_count_templates_scopes (int *num_templates, int *num_scopes,\n     case DEMANGLE_COMPONENT_CONST_THIS:\n     case DEMANGLE_COMPONENT_REFERENCE_THIS:\n     case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n+    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n     case DEMANGLE_COMPONENT_POINTER:\n     case DEMANGLE_COMPONENT_COMPLEX:\n@@ -4420,6 +4436,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t\t&& typed_name->type != DEMANGLE_COMPONENT_VOLATILE_THIS\n \t\t&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS\n \t\t&& typed_name->type != DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n+\t\t&& typed_name->type != DEMANGLE_COMPONENT_TRANSACTION_SAFE\n \t\t&& typed_name->type != DEMANGLE_COMPONENT_REFERENCE_THIS)\n \t      break;\n \n@@ -4461,6 +4478,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t\t   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n \t\t   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS\n \t\t   || local_name->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n+\t\t   || local_name->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n \t\t   || (local_name->type\n \t\t       == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))\n \t      {\n@@ -4796,6 +4814,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n     case DEMANGLE_COMPONENT_POINTER:\n     case DEMANGLE_COMPONENT_COMPLEX:\n     case DEMANGLE_COMPONENT_IMAGINARY:\n+    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n     modifier:\n       {\n \t/* We keep a list of modifiers on the stack.  */\n@@ -5484,6 +5503,7 @@ d_print_mod_list (struct d_print_info *dpi, int options,\n \t      || mods->mod->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n \t      || mods->mod->type == DEMANGLE_COMPONENT_CONST_THIS\n \t      || mods->mod->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n+\t      || mods->mod->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n \t      || (mods->mod->type\n \t\t  == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))))\n     {\n@@ -5542,6 +5562,7 @@ d_print_mod_list (struct d_print_info *dpi, int options,\n \t     || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n \t     || dc->type == DEMANGLE_COMPONENT_CONST_THIS\n \t     || dc->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n+\t     || dc->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n \t     || dc->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n \tdc = d_left (dc);\n \n@@ -5578,6 +5599,9 @@ d_print_mod (struct d_print_info *dpi, int options,\n     case DEMANGLE_COMPONENT_CONST_THIS:\n       d_append_string (dpi, \" const\");\n       return;\n+    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n+      d_append_string (dpi, \" transaction_safe\");\n+      return;\n     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n       d_append_char (dpi, ' ');\n       d_print_comp (dpi, options, d_right (mod));\n@@ -5668,6 +5692,7 @@ d_print_function_type (struct d_print_info *dpi, int options,\n \tcase DEMANGLE_COMPONENT_CONST_THIS:\n \tcase DEMANGLE_COMPONENT_REFERENCE_THIS:\n \tcase DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n+\tcase DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n \t  break;\n \tdefault:\n \t  break;\n@@ -6200,6 +6225,7 @@ is_ctor_or_dtor (const char *mangled,\n \t  case DEMANGLE_COMPONENT_CONST_THIS:\n \t  case DEMANGLE_COMPONENT_REFERENCE_THIS:\n \t  case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n+\t  case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n \t  default:\n \t    dc = NULL;\n \t    break;"}, {"sha": "041b113d63fe98ae35ec7c41ea7b76be140e04ba", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -4395,3 +4395,6 @@ void IndirectExternCall<void ( regparm<3> stdcall*)(int, int), int>(void ( regpa\n _ZNSt8ios_base7failureB5cxx11C1EPKcRKSt10error_code\n std::ios_base::failure[abi:cxx11]::failure(char const*, std::error_code const&)\n std::ios_base::failure[abi:cxx11]::failure\n+--format=gnu-v3\n+_Z1fPDxFvvES0_\n+f(void (*)() transaction_safe, void (*)() transaction_safe)"}, {"sha": "08eb7bcce5f33a32ef9f9572e650822140545465", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -281,7 +281,8 @@ namespace __cxxabiv1\n \t__volatile_mask = 0x2,\n \t__restrict_mask = 0x4,\n \t__incomplete_mask = 0x8,\n-\t__incomplete_class_mask = 0x10\n+\t__incomplete_class_mask = 0x10,\n+\t__transaction_safe_mask = 0x20\n       };\n \n   protected:"}, {"sha": "0e9652932c01aa0b59490852d13e01840eed1a64", "filename": "libstdc++-v3/libsupc++/pbase_type_info.cc", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fd7909c04a29e82fb3ebace161801f949ad4f5/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc?ref=b8fd7909c04a29e82fb3ebace161801f949ad4f5", "patch": "@@ -50,8 +50,19 @@ __do_catch (const type_info *thr_type,\n   \n   const __pbase_type_info *thrown_type =\n     static_cast <const __pbase_type_info *> (thr_type);\n+\n+  unsigned tflags = thrown_type->__flags;\n+\n+  bool throw_tx = (tflags & __transaction_safe_mask);\n+  bool catch_tx = (__flags & __transaction_safe_mask);\n+  if (throw_tx && !catch_tx)\n+    /* Catch can perform a transaction-safety conversion.  */\n+    tflags &= ~__transaction_safe_mask;\n+  if (catch_tx && !throw_tx)\n+    /* But not the reverse.  */\n+    return false;\n   \n-  if (thrown_type->__flags & ~__flags)\n+  if (tflags & ~__flags)\n     // We're less qualified.\n     return false;\n   "}]}