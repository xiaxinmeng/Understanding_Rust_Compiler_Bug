{"sha": "d07d21777f637293ebf91bff6377f2621a1e7a0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA3ZDIxNzc3ZjYzNzI5M2ViZjkxYmZmNjM3N2YyNjIxYTFlN2EwYw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-05-04T20:57:08Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-05-04T20:57:08Z"}, "message": "shrink-wrap: Remove complicated simple_return manipulations\n\nNow that cfgcleanup knows how to optimize with return statements, the\nepilogue insertion code doesn't have to deal with it itself anymore.\n\n\n\t* function.c (emit_use_return_register_into_block): Delete.\n\t(gen_return_pattern): Delete.\n\t(emit_return_into_block): Delete.\n\t(active_insn_between): Delete.\n\t(convert_jumps_to_returns): Delete.\n\t(emit_return_for_exit): Delete.\n\t(thread_prologue_and_epilogue_insns): Delete all code dealing with\n\tsimple_return for shrink-wrapped blocks.\n\t* shrink-wrap.c (try_shrink_wrapping): Insert simple_return at the\n\tend of blocks that need one.\n\t(get_unconverted_simple_return): Delete.\n\t(convert_to_simple_return): Delete.\n\t* shrink-wrap.c (get_unconverted_simple_return): Delete declaration.\n\t(convert_to_simple_return): Ditto.\n\nFrom-SVN: r235905", "tree": {"sha": "53ca7afba7ccf5fb7e23ff3ec271f118e9df2844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53ca7afba7ccf5fb7e23ff3ec271f118e9df2844"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d07d21777f637293ebf91bff6377f2621a1e7a0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d07d21777f637293ebf91bff6377f2621a1e7a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d07d21777f637293ebf91bff6377f2621a1e7a0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d07d21777f637293ebf91bff6377f2621a1e7a0c/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45676a7c8a09579a591fb8d20db90df92a1713b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45676a7c8a09579a591fb8d20db90df92a1713b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45676a7c8a09579a591fb8d20db90df92a1713b3"}], "stats": {"total": 407, "additions": 33, "deletions": 374}, "files": [{"sha": "45e90874387adc60448f10b89db09d17f39b4c14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d07d21777f637293ebf91bff6377f2621a1e7a0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d07d21777f637293ebf91bff6377f2621a1e7a0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d07d21777f637293ebf91bff6377f2621a1e7a0c", "patch": "@@ -1,3 +1,20 @@\n+2016-05-04  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* function.c (emit_use_return_register_into_block): Delete.\n+\t(gen_return_pattern): Delete.\n+\t(emit_return_into_block): Delete.\n+\t(active_insn_between): Delete.\n+\t(convert_jumps_to_returns): Delete.\n+\t(emit_return_for_exit): Delete.\n+\t(thread_prologue_and_epilogue_insns): Delete all code dealing with\n+\tsimple_return for shrink-wrapped blocks.\n+\t* shrink-wrap.c (try_shrink_wrapping): Insert simple_return at the\n+\tend of blocks that need one.\n+\t(get_unconverted_simple_return): Delete.\n+\t(convert_to_simple_return): Delete.\n+\t* shrink-wrap.c (get_unconverted_simple_return): Delete declaration.\n+\t(convert_to_simple_return): Ditto.\n+\n 2016-05-04  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* cfgcleanup.c (bb_is_just_return): New function."}, {"sha": "70584b95586597e1ec6d1aec2ac902860d7e16e5", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 211, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d07d21777f637293ebf91bff6377f2621a1e7a0c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d07d21777f637293ebf91bff6377f2621a1e7a0c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d07d21777f637293ebf91bff6377f2621a1e7a0c", "patch": "@@ -5753,49 +5753,6 @@ prologue_epilogue_contains (const_rtx insn)\n   return 0;\n }\n \n-/* Insert use of return register before the end of BB.  */\n-\n-static void\n-emit_use_return_register_into_block (basic_block bb)\n-{\n-  start_sequence ();\n-  use_return_register ();\n-  rtx_insn *seq = get_insns ();\n-  end_sequence ();\n-  rtx_insn *insn = BB_END (bb);\n-  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n-    insn = prev_cc0_setter (insn);\n-\n-  emit_insn_before (seq, insn);\n-}\n-\n-\n-/* Create a return pattern, either simple_return or return, depending on\n-   simple_p.  */\n-\n-static rtx_insn *\n-gen_return_pattern (bool simple_p)\n-{\n-  return (simple_p\n-\t  ? targetm.gen_simple_return ()\n-\t  : targetm.gen_return ());\n-}\n-\n-/* Insert an appropriate return pattern at the end of block BB.  This\n-   also means updating block_for_insn appropriately.  SIMPLE_P is\n-   the same as in gen_return_pattern and passed to it.  */\n-\n-void\n-emit_return_into_block (bool simple_p, basic_block bb)\n-{\n-  rtx_jump_insn *jump = emit_jump_insn_after (gen_return_pattern (simple_p),\n-\t\t\t\t\t      BB_END (bb));\n-  rtx pat = PATTERN (jump);\n-  if (GET_CODE (pat) == PARALLEL)\n-    pat = XVECEXP (pat, 0, 0);\n-  gcc_assert (ANY_RETURN_P (pat));\n-  JUMP_LABEL (jump) = pat;\n-}\n \n /* Set JUMP_LABEL for a return insn.  */\n \n@@ -5811,135 +5768,6 @@ set_return_jump_label (rtx_insn *returnjump)\n     JUMP_LABEL (returnjump) = ret_rtx;\n }\n \n-/* Return true if there are any active insns between HEAD and TAIL.  */\n-bool\n-active_insn_between (rtx_insn *head, rtx_insn *tail)\n-{\n-  while (tail)\n-    {\n-      if (active_insn_p (tail))\n-\treturn true;\n-      if (tail == head)\n-\treturn false;\n-      tail = PREV_INSN (tail);\n-    }\n-  return false;\n-}\n-\n-/* LAST_BB is a block that exits, and empty of active instructions.\n-   Examine its predecessors for jumps that can be converted to\n-   (conditional) returns.  */\n-vec<edge>\n-convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n-\t\t\t  vec<edge> unconverted ATTRIBUTE_UNUSED)\n-{\n-  int i;\n-  basic_block bb;\n-  edge_iterator ei;\n-  edge e;\n-  auto_vec<basic_block> src_bbs (EDGE_COUNT (last_bb->preds));\n-\n-  FOR_EACH_EDGE (e, ei, last_bb->preds)\n-    if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-      src_bbs.quick_push (e->src);\n-\n-  rtx_insn *label = BB_HEAD (last_bb);\n-\n-  FOR_EACH_VEC_ELT (src_bbs, i, bb)\n-    {\n-      rtx_insn *jump = BB_END (bb);\n-\n-      if (!JUMP_P (jump) || JUMP_LABEL (jump) != label)\n-\tcontinue;\n-\n-      e = find_edge (bb, last_bb);\n-\n-      /* If we have an unconditional jump, we can replace that\n-\t with a simple return instruction.  */\n-      if (simplejump_p (jump))\n-\t{\n-\t  /* The use of the return register might be present in the exit\n-\t     fallthru block.  Either:\n-\t     - removing the use is safe, and we should remove the use in\n-\t     the exit fallthru block, or\n-\t     - removing the use is not safe, and we should add it here.\n-\t     For now, we conservatively choose the latter.  Either of the\n-\t     2 helps in crossjumping.  */\n-\t  emit_use_return_register_into_block (bb);\n-\n-\t  emit_return_into_block (simple_p, bb);\n-\t  delete_insn (jump);\n-\t}\n-\n-      /* If we have a conditional jump branching to the last\n-\t block, we can try to replace that with a conditional\n-\t return instruction.  */\n-      else if (condjump_p (jump))\n-\t{\n-\t  rtx dest;\n-\n-\t  if (simple_p)\n-\t    dest = simple_return_rtx;\n-\t  else\n-\t    dest = ret_rtx;\n-\t  if (!redirect_jump (as_a <rtx_jump_insn *> (jump), dest, 0))\n-\t    {\n-\t      if (targetm.have_simple_return () && simple_p)\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"Failed to redirect bb %d branch.\\n\", bb->index);\n-\t\t  unconverted.safe_push (e);\n-\t\t}\n-\t      continue;\n-\t    }\n-\n-\t  /* See comment in simplejump_p case above.  */\n-\t  emit_use_return_register_into_block (bb);\n-\n-\t  /* If this block has only one successor, it both jumps\n-\t     and falls through to the fallthru block, so we can't\n-\t     delete the edge.  */\n-\t  if (single_succ_p (bb))\n-\t    continue;\n-\t}\n-      else\n-\t{\n-\t  if (targetm.have_simple_return () && simple_p)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Failed to redirect bb %d branch.\\n\", bb->index);\n-\t      unconverted.safe_push (e);\n-\t    }\n-\t  continue;\n-\t}\n-\n-      /* Fix up the CFG for the successful change we just made.  */\n-      redirect_edge_succ (e, EXIT_BLOCK_PTR_FOR_FN (cfun));\n-      e->flags &= ~EDGE_CROSSING;\n-    }\n-  src_bbs.release ();\n-  return unconverted;\n-}\n-\n-/* Emit a return insn for the exit fallthru block.  */\n-basic_block\n-emit_return_for_exit (edge exit_fallthru_edge, bool simple_p)\n-{\n-  basic_block last_bb = exit_fallthru_edge->src;\n-\n-  if (JUMP_P (BB_END (last_bb)))\n-    {\n-      last_bb = split_edge (exit_fallthru_edge);\n-      exit_fallthru_edge = single_succ_edge (last_bb);\n-    }\n-  emit_barrier_after (BB_END (last_bb));\n-  emit_return_into_block (simple_p, last_bb);\n-  exit_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n-  return last_bb;\n-}\n-\n \n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n    this into place with notes indicating where the prologue ends and where\n@@ -5993,7 +5821,6 @@ void\n thread_prologue_and_epilogue_insns (void)\n {\n   bool inserted;\n-  vec<edge> unconverted_simple_returns = vNULL;\n   bitmap_head bb_flags;\n   rtx_insn *returnjump;\n   rtx_insn *epilogue_end ATTRIBUTE_UNUSED;\n@@ -6088,40 +5915,8 @@ thread_prologue_and_epilogue_insns (void)\n \n   exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \n-  if (targetm.have_simple_return () && entry_edge != orig_entry_edge)\n-    exit_fallthru_edge\n-\t= get_unconverted_simple_return (exit_fallthru_edge, bb_flags,\n-\t\t\t\t\t &unconverted_simple_returns,\n-\t\t\t\t\t &returnjump);\n-  if (targetm.have_return ())\n-    {\n-      if (exit_fallthru_edge == NULL)\n-\tgoto epilogue_done;\n-\n-      if (optimize)\n-\t{\n-\t  basic_block last_bb = exit_fallthru_edge->src;\n-\n-\t  if (LABEL_P (BB_HEAD (last_bb))\n-\t      && !active_insn_between (BB_HEAD (last_bb), BB_END (last_bb)))\n-\t    convert_jumps_to_returns (last_bb, false, vNULL);\n-\n-\t  if (EDGE_COUNT (last_bb->preds) != 0\n-\t      && single_succ_p (last_bb))\n-\t    {\n-\t      last_bb = emit_return_for_exit (exit_fallthru_edge, false);\n-\t      epilogue_end = returnjump = BB_END (last_bb);\n-\n-\t      /* Emitting the return may add a basic block.\n-\t\t Fix bb_flags for the added block.  */\n-\t      if (targetm.have_simple_return ()\n-\t\t  && last_bb != exit_fallthru_edge->src)\n-\t\tbitmap_set_bit (&bb_flags, last_bb->index);\n-\n-\t      goto epilogue_done;\n-\t    }\n-\t}\n-    }\n+  if (targetm.have_return () && exit_fallthru_edge == NULL)\n+    goto epilogue_done;\n \n   /* A small fib -- epilogue is not yet completed, but we wish to re-use\n      this marker for the splits of EH_RETURN patterns, and nothing else\n@@ -6229,10 +6024,6 @@ thread_prologue_and_epilogue_insns (void)\n \t}\n     }\n \n-  if (targetm.have_simple_return ())\n-    convert_to_simple_return (entry_edge, orig_entry_edge, bb_flags,\n-\t\t\t      returnjump, unconverted_simple_returns);\n-\n   /* Emit sibling epilogues before any sibling call sites.  */\n   for (ei = ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); (e =\n \t\t\t\t\t\t\t     ei_safe_edge (ei));"}, {"sha": "0ba1fedf161f92312a62e8e0ad114b68042e87b8", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 14, "deletions": 157, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d07d21777f637293ebf91bff6377f2621a1e7a0c/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d07d21777f637293ebf91bff6377f2621a1e7a0c/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=d07d21777f637293ebf91bff6377f2621a1e7a0c", "patch": "@@ -946,10 +946,9 @@ try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n \tredirect_edge_and_branch_force (e, (basic_block) e->dest->aux);\n       }\n \n-  /* Change all the exits that should get a simple_return to FAKE.\n-     They will be converted later.  */\n+  /* Make a simple_return for those exits that run without prologue.  */\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_REVERSE_FN (bb, cfun)\n     if (!bitmap_bit_p (bb_with, bb->index))\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n@@ -958,7 +957,18 @@ try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n \n \t    e->flags &= ~EDGE_FALLTHRU;\n \t    if (!(e->flags & EDGE_SIBCALL))\n-\t      e->flags |= EDGE_FAKE;\n+\t      {\n+\t\trtx_insn *ret = targetm.gen_simple_return ();\n+\t\trtx_insn *end = BB_END (e->src);\n+\t\trtx_jump_insn *start = emit_jump_insn_after (ret, end);\n+\t\tJUMP_LABEL (start) = simple_return_rtx;\n+\t\te->flags &= ~EDGE_FAKE;\n+\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Made simple_return with UID %d in bb %d\\n\",\n+\t\t\t   INSN_UID (start), e->src->index);\n+\t      }\n \n \t    emit_barrier_after_bb (e->src);\n \t  }\n@@ -996,156 +1006,3 @@ try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n \n   free_dominance_info (CDI_DOMINATORS);\n }\n-\n-/* If we're allowed to generate a simple return instruction, then by\n-   definition we don't need a full epilogue.  If the last basic\n-   block before the exit block does not contain active instructions,\n-   examine its predecessors and try to emit (conditional) return\n-   instructions.  */\n-\n-edge\n-get_unconverted_simple_return (edge exit_fallthru_edge, bitmap_head bb_flags,\n-\t\t\t       vec<edge> *unconverted_simple_returns,\n-\t\t\t       rtx_insn **returnjump)\n-{\n-  if (optimize)\n-    {\n-      unsigned i, last;\n-\n-      /* convert_jumps_to_returns may add to preds of the exit block\n-         (but won't remove).  Stop at end of current preds.  */\n-      last = EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n-      for (i = 0; i < last; i++)\n-\t{\n-\t  edge e = EDGE_I (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds, i);\n-\t  if (LABEL_P (BB_HEAD (e->src))\n-\t      && !bitmap_bit_p (&bb_flags, e->src->index)\n-\t      && !active_insn_between (BB_HEAD (e->src), BB_END (e->src)))\n-\t    *unconverted_simple_returns\n-\t\t  = convert_jumps_to_returns (e->src, true,\n-\t\t\t\t\t      *unconverted_simple_returns);\n-\t}\n-    }\n-\n-  if (exit_fallthru_edge != NULL\n-      && EDGE_COUNT (exit_fallthru_edge->src->preds) != 0\n-      && !bitmap_bit_p (&bb_flags, exit_fallthru_edge->src->index))\n-    {\n-      basic_block last_bb;\n-\n-      last_bb = emit_return_for_exit (exit_fallthru_edge, true);\n-      *returnjump = BB_END (last_bb);\n-      exit_fallthru_edge = NULL;\n-    }\n-  return exit_fallthru_edge;\n-}\n-\n-/* If there were branches to an empty LAST_BB which we tried to\n-   convert to conditional simple_returns, but couldn't for some\n-   reason, create a block to hold a simple_return insn and redirect\n-   those remaining edges.  */\n-\n-void\n-convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n-\t\t\t  bitmap_head bb_flags, rtx_insn *returnjump,\n-\t\t\t  vec<edge> unconverted_simple_returns)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  if (!unconverted_simple_returns.is_empty ())\n-    {\n-      basic_block simple_return_block_hot = NULL;\n-      basic_block simple_return_block_cold = NULL;\n-      edge pending_edge_hot = NULL;\n-      edge pending_edge_cold = NULL;\n-      basic_block exit_pred;\n-      int i;\n-\n-      gcc_assert (entry_edge != orig_entry_edge);\n-\n-      /* See if we can reuse the last insn that was emitted for the\n-\t epilogue.  */\n-      if (returnjump != NULL_RTX\n-\t  && JUMP_LABEL (returnjump) == simple_return_rtx)\n-\t{\n-\t  e = split_block (BLOCK_FOR_INSN (returnjump), PREV_INSN (returnjump));\n-\t  if (BB_PARTITION (e->src) == BB_HOT_PARTITION)\n-\t    simple_return_block_hot = e->dest;\n-\t  else\n-\t    simple_return_block_cold = e->dest;\n-\t}\n-\n-      /* Also check returns we might need to add to tail blocks.  */\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n-\tif (EDGE_COUNT (e->src->preds) != 0\n-\t    && (e->flags & EDGE_FAKE) != 0\n-\t    && !bitmap_bit_p (&bb_flags, e->src->index))\n-\t  {\n-\t    if (BB_PARTITION (e->src) == BB_HOT_PARTITION)\n-\t      pending_edge_hot = e;\n-\t    else\n-\t      pending_edge_cold = e;\n-\t  }\n-\n-      /* Save a pointer to the exit's predecessor BB for use in\n-         inserting new BBs at the end of the function.  Do this\n-         after the call to split_block above which may split\n-         the original exit pred.  */\n-      exit_pred = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n-\n-      FOR_EACH_VEC_ELT (unconverted_simple_returns, i, e)\n-\t{\n-\t  basic_block *pdest_bb;\n-\t  edge pending;\n-\n-\t  if (BB_PARTITION (e->src) == BB_HOT_PARTITION)\n-\t    {\n-\t      pdest_bb = &simple_return_block_hot;\n-\t      pending = pending_edge_hot;\n-\t    }\n-\t  else\n-\t    {\n-\t      pdest_bb = &simple_return_block_cold;\n-\t      pending = pending_edge_cold;\n-\t    }\n-\n-\t  if (*pdest_bb == NULL && pending != NULL)\n-\t    {\n-\t      emit_return_into_block (true, pending->src);\n-\t      pending->flags &= ~(EDGE_FALLTHRU | EDGE_FAKE);\n-\t      *pdest_bb = pending->src;\n-\t    }\n-\t  else if (*pdest_bb == NULL)\n-\t    {\n-\t      basic_block bb;\n-\n-\t      bb = create_basic_block (NULL, NULL, exit_pred);\n-\t      BB_COPY_PARTITION (bb, e->src);\n-\t      rtx_insn *ret = targetm.gen_simple_return ();\n-\t      rtx_jump_insn *start = emit_jump_insn_after (ret, BB_END (bb));\n-\t      JUMP_LABEL (start) = simple_return_rtx;\n-\t      emit_barrier_after (start);\n-\n-\t      *pdest_bb = bb;\n-\t      make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-\t    }\n-\t  redirect_edge_and_branch_force (e, *pdest_bb);\n-\t}\n-      unconverted_simple_returns.release ();\n-    }\n-\n-  if (entry_edge != orig_entry_edge)\n-    {\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n-\tif (EDGE_COUNT (e->src->preds) != 0\n-\t    && (e->flags & EDGE_FAKE) != 0\n-\t    && !bitmap_bit_p (&bb_flags, e->src->index))\n-\t  {\n-\t    e = fix_fake_fallthrough_edge (e);\n-\n-\t    emit_return_into_block (true, e->src);\n-\t    e->flags &= ~(EDGE_FALLTHRU | EDGE_FAKE);\n-\t  }\n-    }\n-}"}, {"sha": "4d821d7349961edcb50700e5cdc9f391dcccfa48", "filename": "gcc/shrink-wrap.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d07d21777f637293ebf91bff6377f2621a1e7a0c/gcc%2Fshrink-wrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d07d21777f637293ebf91bff6377f2621a1e7a0c/gcc%2Fshrink-wrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.h?ref=d07d21777f637293ebf91bff6377f2621a1e7a0c", "patch": "@@ -26,12 +26,6 @@ along with GCC; see the file COPYING3.  If not see\n extern bool requires_stack_frame_p (rtx_insn *, HARD_REG_SET, HARD_REG_SET);\n extern void try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_flags,\n \t\t\t\t rtx_insn *prologue_seq);\n-extern edge get_unconverted_simple_return (edge, bitmap_head,\n-\t\t\t\t\t   vec<edge> *, rtx_insn **);\n-extern void convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n-\t\t\t\t      bitmap_head bb_flags,\n-\t\t\t\t      rtx_insn *returnjump,\n-\t\t\t\t      vec<edge> unconverted_simple_returns);\n #define SHRINK_WRAPPING_ENABLED \\\n   (flag_shrink_wrap && targetm.have_simple_return ())\n "}]}