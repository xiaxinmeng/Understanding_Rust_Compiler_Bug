{"sha": "531547e90e1394313f68e2c44624638f79317137", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMxNTQ3ZTkwZTEzOTQzMTNmNjhlMmM0NDYyNDYzOGY3OTMxNzEzNw==", "commit": {"author": {"name": "Fariborz Jahanian", "email": "fjahanian@apple.com", "date": "2003-11-20T22:42:01Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2003-11-20T22:42:01Z"}, "message": "calls.c (expand_call): Allocate new temp in pass1.\n\n2003-11-20  Fariborz Jahanian  <fjahanian@apple.com>\n            David Edelsohn  <edelsohn@gnu.org>\n\n        * calls.c (expand_call): Allocate new temp in pass1.\n        (store_one_arg): If PARALLEL, calculate excess using mode size of\n        rtvec elt.\n        * expr.c (emit_push_insn): If PARALLEL, calculate offset using\n        mode size of rtvec elt.\n        * function.c (assign_parms): Use parm in register, if available.\n\nCo-Authored-By: David Edelsohn <edelsohn@gnu.org>\n\nFrom-SVN: r73775", "tree": {"sha": "06a9206319b71ba393811bbdb094a8c0bfcf8cd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06a9206319b71ba393811bbdb094a8c0bfcf8cd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/531547e90e1394313f68e2c44624638f79317137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531547e90e1394313f68e2c44624638f79317137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/531547e90e1394313f68e2c44624638f79317137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531547e90e1394313f68e2c44624638f79317137/comments", "author": null, "committer": null, "parents": [{"sha": "4be58168d32c1230d713573765a30026738e94f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4be58168d32c1230d713573765a30026738e94f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4be58168d32c1230d713573765a30026738e94f6"}], "stats": {"total": 66, "additions": 58, "deletions": 8}, "files": [{"sha": "dbcdf3e26cc269b60734633e17018d2164877181", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531547e90e1394313f68e2c44624638f79317137/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531547e90e1394313f68e2c44624638f79317137/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=531547e90e1394313f68e2c44624638f79317137", "patch": "@@ -1,3 +1,13 @@\n+2003-11-20  Fariborz Jahanian  <fjahanian@apple.com>\n+\t    David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* calls.c (expand_call): Allocate new temp in pass1.\n+\t(store_one_arg): If PARALLEL, calculate excess using mode size of\n+\trtvec elt. \n+\t* expr.c (emit_push_insn): If PARALLEL, calculate offset using\n+\tmode size of rtvec elt.\n+\t* function.c (assign_parms): Use parm in register, if available.\n+\n 2003-11-20  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/lib1funcs.asm (MOVP): Remove."}, {"sha": "79d9b9c445253e862f2e362b58d02222af13efce", "filename": "gcc/calls.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531547e90e1394313f68e2c44624638f79317137/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531547e90e1394313f68e2c44624638f79317137/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=531547e90e1394313f68e2c44624638f79317137", "patch": "@@ -2152,6 +2152,7 @@ expand_call (tree exp, rtx target, int ignore)\n #endif\n \n   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n+  rtx temp_target = 0;\n   char *initial_stack_usage_map = stack_usage_map;\n \n   int old_stack_allocated;\n@@ -3266,14 +3267,19 @@ expand_call (tree exp, rtx target, int ignore)\n \t The Irix 6 ABI has examples of this.  */\n       else if (GET_CODE (valreg) == PARALLEL)\n \t{\n-\t  if (target == 0)\n+\t  /* Second condition is added because \"target\" is freed at the\n+\t     the end of \"pass0\" for -O2 when call is made to\n+\t     expand_end_target_temps ().  Its \"in_use\" flag has been set\n+\t     to false, so allocate a new temp.  */\n+\t  if (target == 0 || (pass == 1 && target == temp_target))\n \t    {\n \t      /* This will only be assigned once, so it can be readonly.  */\n \t      tree nt = build_qualified_type (TREE_TYPE (exp),\n \t\t\t\t\t      (TYPE_QUALS (TREE_TYPE (exp))\n \t\t\t\t\t       | TYPE_QUAL_CONST));\n \n \t      target = assign_temp (nt, 0, 1, 1);\n+\t      temp_target = target;\n \t      preserve_temp_slots (target);\n \t    }\n \n@@ -4615,9 +4621,18 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t{\n \t  /* PUSH_ROUNDING has no effect on us, because\n \t     emit_push_insn for BLKmode is careful to avoid it.  */\n-\t  excess = (arg->locate.size.constant\n-\t\t    - int_size_in_bytes (TREE_TYPE (pval))\n-\t\t    + partial * UNITS_PER_WORD);\n+\t  if (reg && GET_CODE (reg) == PARALLEL)\n+\t  {\n+\t    /* Use the size of the elt to compute excess.  */\n+\t    rtx elt = XEXP (XVECEXP (reg, 0, 0), 0);\n+\t    excess = (arg->locate.size.constant\n+\t\t      - int_size_in_bytes (TREE_TYPE (pval))\n+\t\t      + partial * GET_MODE_SIZE (GET_MODE (elt)));\n+\t  } \n+\t  else\n+\t    excess = (arg->locate.size.constant\n+\t\t      - int_size_in_bytes (TREE_TYPE (pval))\n+\t\t      + partial * UNITS_PER_WORD);\n \t  size_rtx = expand_expr (size_in_bytes (TREE_TYPE (pval)),\n \t\t\t\t  NULL_RTX, TYPE_MODE (sizetype), 0);\n \t}"}, {"sha": "ac0249f38816f1af808dc698bf68cac624deea37", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531547e90e1394313f68e2c44624638f79317137/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531547e90e1394313f68e2c44624638f79317137/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=531547e90e1394313f68e2c44624638f79317137", "patch": "@@ -3474,9 +3474,19 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \n       rtx temp;\n       int used = partial * UNITS_PER_WORD;\n-      int offset = used % (PARM_BOUNDARY / BITS_PER_UNIT);\n+      int offset;\n       int skip;\n \n+      if (reg && GET_CODE (reg) == PARALLEL)\n+\t{\n+\t  /* Use the size of the elt to compute offset.  */\n+\t  rtx elt = XEXP (XVECEXP (reg, 0, 0), 0);\n+\t  used = partial * GET_MODE_SIZE (GET_MODE (elt));\n+\t  offset = used % (PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n+      else\n+\toffset = used % (PARM_BOUNDARY / BITS_PER_UNIT);\n+\n       if (size == 0)\n \tabort ();\n "}, {"sha": "7bd31906a54bed1d9db61b8ebb8c16f581343136", "filename": "gcc/function.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531547e90e1394313f68e2c44624638f79317137/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531547e90e1394313f68e2c44624638f79317137/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=531547e90e1394313f68e2c44624638f79317137", "patch": "@@ -4704,6 +4704,15 @@ assign_parms (tree fndecl)\n \n \t Set DECL_RTL to that place.  */\n \n+      if (GET_CODE (entry_parm) == PARALLEL && nominal_mode != BLKmode)\n+\t{\n+\t  /* Objects the size of a register can be combined in registers */\n+\t  rtx parmreg = gen_reg_rtx (nominal_mode);\n+\t  emit_group_store (parmreg, entry_parm, TREE_TYPE (parm),\n+\t\t\t    int_size_in_bytes (TREE_TYPE (parm)));\n+\t  SET_DECL_RTL (parm, parmreg);\n+\t}\n+\n       if (nominal_mode == BLKmode\n #ifdef BLOCK_REG_PADDING\n \t  || (locate.where_pad == (BYTES_BIG_ENDIAN ? upward : downward)\n@@ -4727,15 +4736,18 @@ assign_parms (tree fndecl)\n \t\t assign_stack_local if space was not allocated in the argument\n \t\t list.  If it was, this will not work if PARM_BOUNDARY is not\n \t\t a multiple of BITS_PER_WORD.  It isn't clear how to fix this\n-\t\t if it becomes a problem.  */\n+\t\t if it becomes a problem.  Exception is when BLKmode arrives\n+\t\t with arguments not conforming to word_mode.  */\n \n \t      if (stack_parm == 0)\n \t\t{\n \t\t  stack_parm = assign_stack_local (BLKmode, size_stored, 0);\n \t\t  PUT_MODE (stack_parm, GET_MODE (entry_parm));\n \t\t  set_mem_attributes (stack_parm, parm, 1);\n \t\t}\n-\n+\t      else if (GET_CODE (entry_parm) == PARALLEL \n+\t\t       && GET_MODE(entry_parm) == BLKmode)\n+\t\t;\n \t      else if (PARM_BOUNDARY % BITS_PER_WORD != 0)\n \t\tabort ();\n \n@@ -4798,7 +4810,10 @@ assign_parms (tree fndecl)\n \t\tmove_block_from_reg (REGNO (entry_parm), mem,\n \t\t\t\t     size_stored / UNITS_PER_WORD);\n \t    }\n-\t  SET_DECL_RTL (parm, stack_parm);\n+\t  /* If parm is already bound to register pair, don't change \n+\t     this binding. */\n+\t  if (! DECL_RTL_SET_P (parm))\n+\t    SET_DECL_RTL (parm, stack_parm);\n \t}\n       else if (! ((! optimize\n \t\t   && ! DECL_REGISTER (parm))"}]}