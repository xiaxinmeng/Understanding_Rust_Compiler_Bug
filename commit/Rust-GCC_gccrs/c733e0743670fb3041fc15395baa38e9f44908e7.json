{"sha": "c733e0743670fb3041fc15395baa38e9f44908e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzczM2UwNzQzNjcwZmIzMDQxZmMxNTM5NWJhYTM4ZTlmNDQ5MDhlNw==", "commit": {"author": {"name": "Timothy Moore", "email": "moore@gnu.org", "date": "1992-03-31T19:58:13Z"}, "committer": {"name": "Timothy Moore", "email": "moore@gnu.org", "date": "1992-03-31T19:58:13Z"}, "message": "Initial revision\n\nFrom-SVN: r648", "tree": {"sha": "3eafbdf04dfe7050b907fafb6bd83eb3d7922508", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eafbdf04dfe7050b907fafb6bd83eb3d7922508"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c733e0743670fb3041fc15395baa38e9f44908e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c733e0743670fb3041fc15395baa38e9f44908e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c733e0743670fb3041fc15395baa38e9f44908e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c733e0743670fb3041fc15395baa38e9f44908e7/comments", "author": null, "committer": null, "parents": [{"sha": "3def670650273da78bc7d72d292acfe5a9e1adcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3def670650273da78bc7d72d292acfe5a9e1adcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3def670650273da78bc7d72d292acfe5a9e1adcf"}], "stats": {"total": 2121, "additions": 2121, "deletions": 0}, "files": [{"sha": "e013306544302b1a05f47dc76e7b6b4a18d6a29c", "filename": "gcc/config/pa/pa.md", "status": "added", "additions": 2121, "deletions": 0, "changes": 2121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c733e0743670fb3041fc15395baa38e9f44908e7/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c733e0743670fb3041fc15395baa38e9f44908e7/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=c733e0743670fb3041fc15395baa38e9f44908e7", "patch": "@@ -0,0 +1,2121 @@\n+;;- Machine description for HP PA-RISC architecture for GNU C compiler\n+;;   Copyright (C) 1992 Free Software Foundation, Inc.\n+;;   Contributed by the Center for Software Science at the University\n+;;   of Utah. \n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+;; This gcc Version 2 machine description is inspired by sparc.md and\n+;; mips.md.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; Insn type.  Used to default other attribute values.\n+\n+;; type \"unary\" insns have one input operand (1) and one output operand (0)\n+;; type \"binary\" insns have two input operands (1,2) and one output (0)\n+\n+(define_attr \"type\"\n+  \"move,unary,binary,compare,load,store,branch,cbranch,call,dyncall,address,fpload,fpstore,fpalu,fpcc,fpmul,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,misc,milli\"\n+  (const_string \"binary\"))\n+\n+;; Set true if insn uses call-clobbered intermediate register.\n+(define_attr \"use_clobbered\" \"false,true\"\n+  (if_then_else (and (eq_attr \"type\" \"address\")\n+\t\t     (match_operand 0 \"clobbered_register\" \"\"))\n+\t \t(const_string \"true\")\n+\t\t(const_string \"false\")))\n+\n+;; Length (in # of insns).\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"load,fpload\")\n+\t (if_then_else (match_operand 1 \"symbolic_memory_operand\" \"\")\n+\t\t       (const_int 2) (const_int 1))\n+\n+\t (eq_attr \"type\" \"store,fpstore\")\n+\t (if_then_else (match_operand 0 \"symbolic_memory_operand\" \"\")\n+\t\t       (const_int 2) (const_int 1))\n+\n+\t (eq_attr \"type\" \"address\") (const_int 2)\n+\n+\t (eq_attr \"type\" \"binary\")\n+\t (if_then_else (match_operand 2 \"arith_operand\" \"\")\n+\t\t       (const_int 1) (const_int 3))\n+\n+\t (eq_attr \"type\" \"move,unary\")\n+\t (if_then_else (match_operand 1 \"arith_operand\" \"\")\n+\t\t       (const_int 1) (const_int 2))]\n+\n+\t(const_int 1)))\n+\n+(define_asm_attributes\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"type\" \"multi\")])\n+\n+;; Attributes for instruction and branch scheduling\n+\n+(define_attr \"in_call_delay\" \"false,true\"\n+  (cond [(eq_attr \"type\" \"branch,cbranch,call,dyncall,multi,milli\")\n+\t (const_string \"false\")\n+\t \n+\t (eq_attr \"type\" \"load,fpload,store,fpstore\")\n+\t (if_then_else (eq_attr \"length\" \"1\")\n+\t\t       (const_string \"true\")\n+\t\t       (const_string \"false\"))\n+\t \n+\t (eq_attr \"type\" \"address\")\n+\t (if_then_else (eq_attr \"use_clobbered\" \"false\")\n+\t\t       (const_string \"true\")\n+\t\t       (const_string \"false\"))]\n+\t\n+\t(if_then_else (eq_attr \"length\" \"1\")\n+\t\t      (const_string \"true\")\n+\t\t      (const_string \"false\"))))\n+\n+(define_attr \"in_milli_delay\" \"false,true\"\n+  (cond [(eq_attr \"length\" \"!1\")\n+\t (const_string \"false\")\n+\n+\t (eq_attr \"type\" \"branch,cbranch,call,dyncall,milli\")\n+\t (const_string \"false\")\n+\n+\t (ne (symbol_ref \"use_milli_regs (insn)\") (const_int 0))\n+\t (const_string \"false\")]\n+\t(const_string \"true\")))\n+\n+(define_delay (eq_attr \"type\" \"call\")\n+  [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n+\n+(define_attr \"in_branch_delay\" \"false,true\"\n+  (if_then_else (and (eq_attr \"type\" \"!branch,cbranch,call,multi,milli\")\n+\t\t     (eq_attr \"length\" \"1\"))\n+\t\t(const_string \"true\")\n+\t\t(const_string \"false\")))\n+\n+(define_delay (eq_attr \"type\" \"branch\")\n+  [(eq_attr \"in_branch_delay\" \"true\")\n+   (eq_attr \"in_branch_delay\" \"true\") (nil)])\n+\n+(define_delay (eq_attr \"type\" \"cbranch\")\n+  [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n+\n+(define_delay (eq_attr \"type\" \"milli\")\n+  [(eq_attr \"in_milli_delay\" \"true\") (nil) (nil)])\n+\n+;; Function units of the HPPA. The following data is for the \"Snake\"\n+;; (Mustang CPU + Timex FPU) because that's what I have the docs for.\n+;; Scheduling instructions for PA-83 machines according to the Snake\n+;; constraints shouldn't hurt.\n+\n+;; (define_function_unit {name} {num-units} {n-users} {test}\n+;;                       {ready-delay} {busy-delay} [{conflict-list}])\n+\n+;; The integer ALU.\n+;; (Noted only for documentation; units that take one cycle do not need to\n+;; be specified.)\n+\n+;; (define_function_unit \"alu\" 1 0\n+;;  (eq_attr \"type\" \"unary,binary,move,address\") 1 0)\n+\n+\n+;; Memory. Disregarding Cache misses, the Mustang memory times are:\n+;; load: 1\n+;; store, fpstore: 3, no D-cache operations should be scheduled.\n+;; fpload: 3 (really 2 for flops, but I don't think we can specify that).\n+\n+(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 1 0)\n+(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"store,fpstore\") 3 0)\n+(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"fpload\") 3 0)\n+\n+;; The Timex has two floating-point units: ALU, and MUL/DIV/SQRT unit.\n+;; Timings:\n+;; Instruction\tTime\tUnit\tMinimum Distance (unit contention)\n+;; fcpy\t\t3\tALU\t2\n+;; fabs\t\t3\tALU\t2\n+;; fadd\t\t3\tALU\t2\n+;; fsub\t\t3\tALU\t2\n+;; fcmp\t\t3\tALU\t2\n+;; fcnv\t\t3\tALU\t2\n+;; fmpyadd\t3\tALU,MPY\t2\n+;; fmpysub\t3\tALU,MPY 2\n+;; fmpycfxt\t3\tALU,MPY 2\n+;; fmpy\t\t3\tMPY\t2\n+;; fmpyi\t3\tMPY\t2\n+;; fdiv,sgl\t10\tMPY\t10\n+;; fdiv,dbl\t12\tMPY\t12\n+;; fsqrt,sgl\t14\tMPY\t14\n+;; fsqrt,dbl\t18\tMPY\t18\n+\n+(define_function_unit \"fp_alu\" 1 0 (eq_attr \"type\" \"fpalu\") 3 2)\n+(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpmul\") 3 2)\n+(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpdivsgl\") 10 10)\n+(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpdivdbl\") 12 12)\n+(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpsqrtsgl\") 14 14)\n+(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpsqrtdbl\") 18 18)\n+\f\n+;; Compare instructions.\n+;; This controls RTL generation and register allocation.\n+\n+;; We generate RTL for comparisons and branches by having the cmpxx \n+;; patterns store away the operands.  Then, the scc and bcc patterns\n+;; emit RTL for both the compare and the branch.\n+;;\n+\n+(define_expand \"cmpsi\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (match_operand:SI 0 \"reg_or_0_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"arith5_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+ hppa_compare_op0 = operands[0];\n+ hppa_compare_op1 = operands[1];\n+ hppa_branch_type = CMP_SI;\n+ DONE;\n+}\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (reg:CCFP 0)\n+\t(compare:CCFP (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t      (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  hppa_compare_op0 = operands[0];\n+  hppa_compare_op1 = operands[1];\n+  hppa_branch_type = CMP_SF;\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpdf\"\n+  [(set (reg:CCFP 0)\n+      (compare:CCFP (match_operand:DF 0 \"register_operand\" \"\")\n+                    (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  hppa_compare_op0 = operands[0];\n+  hppa_compare_op1 = operands[1];\n+  hppa_branch_type = CMP_DF;\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+ [(set (reg:CCFP 0)\n+       (match_operator:CCFP 2 \"comparison_operator\"\n+\t\t\t    [(match_operand:SF 0 \"register_operand\" \"fxy\")\n+\t\t\t     (match_operand:SF 1 \"register_operand\" \"fxy\")]))]\n+ \"\"\n+ \"fcmp,sgl,%Y2 %0,%1\"\n+ [(set_attr \"type\" \"fpcc\")])\n+\n+(define_insn \"\"\n+ [(set (reg:CCFP 0)\n+       (match_operator:CCFP 2 \"comparison_operator\"\n+\t\t\t    [(match_operand:DF 0 \"register_operand\" \"fxy\")\n+\t\t\t     (match_operand:DF 1 \"register_operand\" \"fxy\")]))]\n+ \"\"\n+ \"fcmp,dbl,%Y2 %0,%1\"\n+ [(set_attr \"type\" \"fpcc\")])\n+\n+;; scc insns.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:CCFP 1 \"comparison_operator\" [(reg:CCFP 0)\n+\t\t\t\t\t\t      (const_int 0)]))]\n+  \"\"\n+  \"copy 0,%0\\;ftest\\;ldi 1,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(eq:CC (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (EQ, hppa_compare_op0, hppa_compare_op1));\n+      emit_insn (gen_scond_fp (EQ, operands[0]));\n+      DONE;\n+    }\n+  /* set up operands from compare.  */\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+  /* fall through and generate default code */\n+}\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ne:CC (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (NE, hppa_compare_op0, hppa_compare_op1));\n+      emit_insn (gen_scond_fp (NE, operands[0]));\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lt:CC (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (LT, hppa_compare_op0, hppa_compare_op1));\n+      emit_insn (gen_scond_fp (LT, operands[0]));\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(gt:CC (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (GT, hppa_compare_op0, hppa_compare_op1));\n+      emit_insn (gen_scond_fp (GT, operands[0]));\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(le:CC (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (LE, hppa_compare_op0, hppa_compare_op1));\n+      emit_insn (gen_scond_fp (LE, operands[0]));\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ge:CC (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (GE, hppa_compare_op0, hppa_compare_op1));\n+      emit_insn (gen_scond_fp (GE, operands[0]));\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ltu:CC (match_dup 1)\n+\t        (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(gtu:CC (match_dup 1)\n+\t        (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(leu:CC (match_dup 1)\n+\t        (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(geu:CC (match_dup 1)\n+\t        (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+;; Instruction canonicalization puts immediate operands second, which\n+;; is the reverse of what we want.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:CC 3 \"comparison_operator\"\n+\t\t\t   [(match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t\t    (match_operand:SI 2  \"arith11_operand\" \"r,I\")]))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"comclr,%N3 %1,%2,%0\\;ldi 1,%0\\\";\n+  else\n+    {\n+      if (!(GET_CODE (operands[3]) == EQ || GET_CODE (operands[3]) == NE))\n+\tPUT_CODE (operands[3], reverse_relop (GET_CODE (operands[3])));\n+      output_asm_insn (\\\"comiclr,%N3 %2,%1,%0\\;ldi 1,%0\\\", operands);\n+      return \\\"\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; Conditionals\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (EQ, hppa_compare_op0, hppa_compare_op1));\n+      emit_bcond_fp (NE, operands[0]);\n+      DONE;\n+    }\n+  /* set up operands from compare.  */\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+  /* fall through and generate default code */\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (NE, hppa_compare_op0, hppa_compare_op1));\n+      emit_bcond_fp (NE, operands[0]);\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (GT, hppa_compare_op0, hppa_compare_op1));\n+      emit_bcond_fp (NE, operands[0]);\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (LT, hppa_compare_op0, hppa_compare_op1));\n+      emit_bcond_fp (NE, operands[0]);\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (GE, hppa_compare_op0, hppa_compare_op1));\n+      emit_bcond_fp (NE, operands[0]);\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    {\n+      emit_insn (gen_cmp_fp (LE, hppa_compare_op0, hppa_compare_op1));\n+      emit_bcond_fp (NE, operands[0]);\n+      DONE;\n+    }\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+  operands[1] = hppa_compare_op0;\n+  operands[2] = hppa_compare_op1;\n+}\")\n+\n+;; Match the branch patterns.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"comparison_operator\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t\t  (match_operand:SI 2 \"arith5_operand\" \"r,L\")])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return (get_attr_length (insn) == 1\n+\t    ? \\\"comb,%C3 %1,%2,%0%#\\\" : \\\"comclr,%N3 %1,%2,0\\;bl %0,0%#\\\");\n+    {\n+      enum rtx_code comp_code = GET_CODE (operands[3]);\n+      if (!(comp_code == EQ || comp_code == NE))\n+\tPUT_CODE (operands[3], reverse_relop (comp_code));\n+      if (get_attr_length (insn) == 1)\n+\toutput_asm_insn (\\\"comib,%C3 %2,%1,%0%#\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"comiclr,%N3 %2,%1,0\\;bl %0,0%#\\\", operands);\n+      return \\\"\\\";\n+    }\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\") (if_then_else (lt (abs (minus (match_dup 0)\n+\t\t\t\t\t\t    (plus (pc) (const_int 2))))\n+\t\t\t\t\t(const_int 1023))\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (const_int 2)))])\n+\n+;; Match the negated branch.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"comparison_operator\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t\t  (match_operand:SI 2 \"arith5_operand\" \"r,L\")])\n+\t (pc)\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return (get_attr_length (insn) == 1\n+\t    ? \\\"comb,%N3 %1,%2,%0%#\\\" : \\\"comclr,%C3 %1,%2,0\\;bl %0,0%#\\\");\n+    {\n+      enum rtx_code comp_code = GET_CODE (operands[3]);\n+      if (!(comp_code == EQ || comp_code == NE))\n+\tPUT_CODE (operands[3], reverse_relop (comp_code));\n+      if (get_attr_length (insn) == 1)\n+\toutput_asm_insn (\\\"comib,%N3 %2,%1,%0%#\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"comiclr,%C3 %2,%1,0%#\\;bl %0,0%#\\\", operands);\n+      return \\\"\\\";\n+    }\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\") (if_then_else (lt (abs (minus (match_dup 0)\n+\t\t\t\t\t\t    (plus (pc) (const_int 2))))\n+\t\t\t\t\t(const_int 1023))\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (const_int 2)))])\n+\n+;; Floating point branches\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (ne (reg:CCFP 0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"ftest\\;bl%* %0,0\"\n+  [(set_attr \"type\" \"cbranch\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (ne (reg:CCFP 0) (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"ftest\\;add,tr 0,0,0\\;bl%* %0,0\"\n+  [(set_attr \"type\" \"cbranch\")\n+   (set_attr \"length\" \"3\")])\n+\n+;; Move instructions\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SImode))\n+    DONE;\n+}\")\n+\n+;; Moves to and from the shift register.\n+\n+(define_insn \"\"\n+  [(set (reg:SI 112)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"mtsar %0\"\n+  [(set_attr \"type\" \"move\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(reg:SI 112))]\n+  \"\"\n+  \"mfctl 11,%0\"\n+  [(set_attr \"type\" \"move\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\"\n+\t\t\t  \"=r,r,Q,!r,!*f*x*y,!*f*x*y\")\n+\t(match_operand:SI 1 \"move_operand\" \"rM,Q,rM,!*f*x*y,!r,!*f*x*y\"))]\n+  \"\"\n+  \"@\n+   copy %r1,%0\n+   ldw%M1 %1,%0\n+   stw%M0 %r1,%0\n+   fstws %1,-16(30)\\;ldw -16(30),%0\n+   stw %1,-16(30)\\;fldws -16(30),%0\n+   fcpy,sgl %1,%0\"\n+  [(set_attr \"type\" \"move,load,store,move,move,fpalu\")\n+   (set_attr \"length\" \"1,1,1,2,2,1\")])\n+\n+;; For pic\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"pic_operand\" \"i\"))\n+   (clobber (match_scratch:SI 2 \"=a\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx label_rtx = gen_label_rtx ();\n+  rtx xoperands[3];\n+  extern FILE *asm_out_file;\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[1];\n+  xoperands[2] = label_rtx;\n+  output_asm_insn (\\\"bl .+8,%0\\;addil L'%1-%2,%0\\\", xoperands);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (label_rtx));\n+  output_asm_insn (\\\"ldo R'%1(1),%0\\\", xoperands);\n+  return \\\"\\\";\n+  }\n+\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"n\"))]\n+  \"(GET_CODE (operands[1]) == CONST_INT) &&\n+   (INT_14_BITS (operands[1]) || !(INTVAL (operands[1]) & 0x7ff))\"\n+  \"*\n+{\n+  if (INT_14_BITS (operands[1]))\n+    return \\\"ldo %1(0),%0\\\";\n+  else\n+    return \\\"ldil L'%1,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (high:SI (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"addil L'%G2,%1\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand 1 \"\" \"\")))]\n+  \"check_pic (1)\"\n+  \"ldil L'%G1,%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(high:HI (match_operand 1 \"\" \"\")))]\n+  \"check_pic (1)\"\n+  \"ldil L'%G1,%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"in\")))]\n+  \"\"\n+  \"ldo R'%G2(%1),%0\"\n+  ;; Need to set length for this arith insn because operand2\n+  ;; is not an \"arith_operand\".\n+  [(set_attr \"length\" \"1\")])\n+\n+;;; Experimental\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"fp_reg_operand\" \"*f*x*y\")\n+\t(match_operand:SI 1 \"short_memory_operand\" \"T\"))]\n+  \"\"\n+  \"fldws%F1 %1,%0\"\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"short_memory_operand\" \"T\")\n+\t(match_operand:SI 1 \"fp_reg_operand\" \"*f*x*y\"))]\n+  \"\"\n+  \"fstws%F0 %1,%0\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, HImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q\")\n+\t(match_operand:HI 1 \"move_operand\" \"rM,Q,rM\"))]\n+  \"\"\n+  \"@\n+   copy %r1,%0\n+   ldh%M1 %1,%0\n+   sth%M0 %r1,%0\"\n+  [(set_attr \"type\" \"move,load,store\")\n+   (set_attr \"length\" \"1,1,1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"immediate_operand\" \"n\"))]\n+  \"(GET_CODE (operands[1]) == CONST_INT) &&\n+   (INT_14_BITS (operands[1]) || !(INTVAL (operands[1]) & 0x7ff))\"\n+  \"*\n+{\n+  if (INT_14_BITS (operands[1]))\n+    return \\\"ldo %1(0),%0\\\";\n+  else\n+    return \\\"ldil L'%1,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand 2 \"immediate_operand\" \"in\")))]\n+  \"\"\n+  \"ldo R'%G2(%1),%0\"\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, QImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q\")\n+\t(match_operand:QI 1 \"move_operand\" \"rM,Q,rM\"))]\n+  \"\"\n+  \"@\n+   copy %r1,%0\n+   ldb%M1 %1,%0\n+   stb%M0 %r1,%0\"\n+  [(set_attr \"type\" \"move,load,store\")\n+   (set_attr \"length\" \"1,1,1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(match_operand:QI 1 \"immediate_operand\" \"J\"))]\n+  \"\"\n+  \"ldo %1(0),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(subreg:QI (lo_sum:SI (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand 2 \"immediate_operand\" \"in\")) 0))]\n+  \"\"\n+  \"ldo R'%G2(%1),%0\"\n+  [(set_attr \"length\" \"1\")])\n+\n+;; The definition of this insn does not really explain what it does,\n+;; but it should suffice\n+;; that anything generated as this insn will be recognized as one\n+;; and that it will not successfully combine with anything.\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n+\t      (clobber (match_dup 0))\n+\t      (clobber (match_dup 1))\n+\t      (clobber (match_scratch:SI 4 \"\"))\n+\t      (clobber (match_scratch:SI 5 \"\"))\n+\t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  /* If the blocks are not word-aligned and rather big (>16 items),\n+     or the size is indeterminate, don't inline the copy code.  A\n+     procedure call is better since it can check the alignment at\n+     runtime and make the optimal decisions.  */\n+     if (INTVAL (operands[3]) != 4\n+\t && (GET_CODE (operands[2]) != CONST_INT\n+\t     || (INTVAL (operands[2]) / INTVAL (operands[3]) > 16)))\n+       FAIL;\n+\n+  operands[0] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n+  operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n+  operands[2] = force_not_mem (operands[2]);\n+}\")\n+\n+;; The operand constraints are written like this to support both compile-time\n+;; and run-time determined byte count.  If the count is run-time determined,\n+;; the register with the byte count is clobbered by the copying code, and\n+;; therefore it is forced to operand 2.  If the count is compile-time\n+;; determined, we need two scratch registers for the unrolled code.\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r,r\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r,r\")))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))\n+   (clobber (match_scratch:SI 2 \"=r,r\"))\t\t ;loop cnt/item tmp\n+   (clobber (match_scratch:SI 3 \"=r,r\"))\t\t ;item tmp\n+   (use (match_operand:SI 4 \"arith_operand\" \"J,2\"))\t ;byte count\n+   (use (match_operand:SI 5 \"const_int_operand\" \"n,n\"))] ;alignment\n+  \"\"\n+  \"* return output_block_move (operands, !which_alternative);\"\n+  [(set_attr \"type\" \"multi\")])\n+\f\n+;; Floating point move insns\n+\n+;; This pattern forces (set (reg:DF ...) (const_double ...))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general movdf pattern.\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=?r,r,f\")\n+\t(match_operand:DF 1 \"\" \"?E,G,m\"))]\n+  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return output_move_double (operands);\n+    case 1:\n+      return \\\"copy 0,%0\\;copy 0,%R0\\\";\n+    case 2:\n+      return output_fp_move_double (operands);\n+    }\n+}\"\n+  [(set_attr \"type\" \"load,move,fpload\")\n+   (set_attr \"length\" \"3,2,3\")])\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DFmode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n+\t\t\t  \"=fxy,r,Q,Q,fxy,&r,?fxy,?r\")\n+\t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\"\n+\t\t\t  \"fxy,r,fxy,r,Q,Q,r,fxy\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\"\n+  [(set_attr \"type\" \"fpalu,move,fpstore,store,fpload,load,multi,multi\")\n+   (set_attr \"length\" \"1,2,1,2,1,2,3,3\")])\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n+\t\t\t  \"=r,Q,&r,&r,*f*x*y,*f*x*y,*f*x*y,r,Q\")\n+\t(match_operand:DI 1 \"general_operand\"\n+\t\t\t  \"r,r,Q,i,r,*f*x*y,Q,*f*x*y,*f*x*y\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\"\n+  [(set_attr \"type\" \"move,store,load,misc,multi,fpalu,fpload,multi,fpstore\")\n+   (set_attr \"length\" \"2,3,3,3,3,2,3,3,3\")])\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SFmode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\"\n+\t\t\t  \"=fxy,r,r,fxy,fxy,r,Q,Q\")\n+\t(match_operand:SF 1 \"reg_or_nonsymb_mem_operand\"\n+\t\t\t  \"fxy,r,!fxy,!r,Q,Q,fxy,r\"))]\n+  \"\"\n+  \"@\n+   fcpy %1,%0\n+   copy %1,%0\n+   fstws %1,-16(0,30)\\;ldw -16(0,30),%0\n+   stw %r1,-16(0,30)\\;fldws -16(0,30),%0\n+   fldws%F1 %1,%0\n+   ldw%M1 %1,%0\n+   fstws%F0 %r1,%0\n+   stw%M0 %r1,%0\"\n+  [(set_attr \"type\" \"fpalu,move,multi,multi,fpload,load,fpstore,store\")\n+   (set_attr \"length\" \"1,1,2,2,1,1,1,1\")])\n+\n+\f\n+;;- zero extension instructions\n+\n+;; Note that the one starting from HImode comes before those for QImode\n+;; so that a constant operand will match HImode, not QImode.\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operand1) == MEM\n+      && symbolic_operand (XEXP (operand1, 0), Pmode))\n+    {\n+      rtx temp = copy_to_mode_reg (Pmode, gen_rtx (HIGH, Pmode,\n+\t\t\t\t\t\t   XEXP (operand1, 0)));\n+      operands[1] = gen_rtx (MEM, HImode,\n+\t\t\t     gen_rtx (LO_SUM, Pmode,\n+\t\t\t\t      temp, XEXP (operand1, 0)));\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"reg_or_nonsymb_mem_operand\" \"r,Q\")))]\n+  \"\"\n+  \"@\n+   extru %1,31,16,%0\n+   ldh%M1 %1,%0\"\n+  [(set_attr \"type\" \"unary,load\")])\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operand1) == MEM\n+      && symbolic_operand (XEXP (operand1, 0), Pmode))\n+    {\n+      rtx temp = copy_to_mode_reg (Pmode, gen_rtx (HIGH, Pmode,\n+\t\t\t\t\t\t   XEXP (operand1, 0)));\n+      operands[1] = gen_rtx (MEM, QImode,\n+\t\t\t     gen_rtx (LO_SUM, Pmode,\n+\t\t\t\t      temp, XEXP (operand1, 0)));\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"reg_or_nonsymb_mem_operand\" \"r,Q\")))]\n+  \"\"\n+  \"@\n+   extru %1,31,8,%0\n+   ldb%M1 %1,%0\"\n+  [(set_attr \"type\" \"unary,load\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operand1) == MEM\n+      && symbolic_operand (XEXP (operand1, 0), Pmode))\n+    {\n+      rtx temp = copy_to_mode_reg (Pmode, gen_rtx (HIGH, Pmode,\n+\t\t\t\t\t\t   XEXP (operand1, 0)));\n+      operand1 = gen_rtx (MEM, QImode,\n+\t\t\t  gen_rtx (LO_SUM, Pmode,\n+\t\t\t\t   temp, XEXP (operand1, 0)));\n+      emit_insn (gen_rtx (SET, VOIDmode, operand0,\n+\t\t\t  gen_rtx (ZERO_EXTEND, SImode, operand1)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"reg_or_nonsymb_mem_operand\" \"r,Q\")))]\n+  \"\"\n+  \"@\n+   extru %1,31,8,%0\n+   ldb%M1 %1,%0\"\n+  [(set_attr \"type\" \"unary,load\")\n+   (set_attr \"length\" \"1\")])\n+\f\n+;;- sign extension instructions\n+;; Note that the one starting from HImode comes before those for QImode\n+;; so that a constant operand will match HImode, not QImode.\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"extrs %1,31,16,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"extrs %1,31,8,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"extrs %1,31,8,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\f\n+;; Conversions between float and double.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fxy\")\n+\t(float_extend:DF\n+\t (match_operand:SF 1 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fcnvff,sgl,dbl %1,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fxy\")\n+\t(float_truncate:SF\n+\t (match_operand:DF 1 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fcnvff,dbl,sgl %1,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+;; Conversion between fixed point and floating point.\n+;; Note that among the fix-to-float insns\n+;; the ones that start with SImode come first.\n+;; That is so that an operand that is a CONST_INT\n+;; (and therefore lacks a specific machine mode).\n+;; will be recognized as SImode (which is always valid)\n+;; rather than as QImode or HImode.\n+\n+;; This pattern forces (set (reg:SF ...) (float:SF (const_int ...)))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general floatsisf2 pattern.\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fxy\")\n+\t(float:SF (match_operand:SI 1 \"const_int_operand\" \"m\")))]\n+  \"\"\n+  \"* return output_floatsisf2 (operands);\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fxy\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"fxyr\")))]\n+  \"\"\n+  \"* return output_floatsisf2 (operands);\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"3\")])\n+\n+;; This pattern forces (set (reg:DF ...) (float:DF (const_int ...)))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general floatsidf2 pattern.\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fxy\")\n+\t(float:DF (match_operand:SI 1 \"const_int_operand\" \"m\")))]\n+  \"\"\n+  \"* return output_floatsidf2 (operands);\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fxy\")\n+\t(float:DF (match_operand:SI 1 \"register_operand\" \"fxyr\")))]\n+  \"\"\n+  \"* return output_floatsidf2 (operands);\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"3\")])\n+\n+;; Convert a float to an actual integer.\n+;; Truncation is performed as part of the conversion.\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,fxy\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"fxy,fxy\"))))\n+   (clobber (match_scratch:SI 2 \"=&fxy,X\"))]\n+  \"\"\n+  \"@\n+   fcnvfxt,sgl,sgl %1,%2\\;fstws %2,-16(30)\\;ldw -16(30),%0\n+   fcnvfxt,sgl,sgl %1,%0\"\n+  [(set_attr \"type\" \"fpalu,fpalu\")\n+   (set_attr \"length\" \"3,1\")])\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,fxy\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"fxy,fxy\"))))\n+   (clobber (match_scratch:SI 2 \"=&fxy,X\"))]\n+  \"\"\n+  \"@\n+   fcnvfxt,dbl,sgl %1,%2\\;fstws %2,-16(30)\\;ldw -16(30),%0\n+   fcnvfxt,dbl,sgl %1,%0\"\n+  [(set_attr \"type\" \"fpalu,fpalu\")\n+   (set_attr \"length\" \"3,1\")])\n+\n+\f\n+;;- arithmetic instructions\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"add %R1,%R2,%R0\\;addc %1,%2,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"r,J\")))]\n+  \"\"\n+  \"@\n+   add %1,%2,%0\n+   ldo %2(%1),%0\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub %R1,%R2,%R0\\;subb %1,%2,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;(define_insn \"subsi3\"\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+;\t(minus:SI (match_operand:SI 1 \"arith11_operand\" \"r,I,r\")\n+;\t\t  (match_operand:SI 2 \"arith_operand\" \"r,r,J\")))]\n+;  \"\"\n+;  \"@\n+;   sub %1,%2,%0\n+;   subi %1,%2,%0\n+;   ldo %n2(%1),%0\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"arith11_operand\" \"r,I\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r,r\")))]\n+  \"\"\n+  \"@\n+   sub %1,%2,%0\n+   subi %1,%2,%0\")\n+\n+;; The mulsi3 insns set up registers for the millicode call.\n+\n+(define_expand \"mulsi3\"\n+  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+   (parallel [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n+\t      (clobber (match_scratch:SI 3 \"\"))\n+\t      (clobber (reg:SI 26))\n+\t      (clobber (reg:SI 25))\n+\t      (clobber (reg:SI 31))])\n+   (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n+   (clobber (match_scratch:SI 0 \"=a\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  \"* return output_mul_insn (0);\"\n+  [(set_attr \"type\" \"milli\")])\n+\n+;;; Division and mod.\n+\n+(define_expand \"divsi3\"\n+  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+   (parallel [(set (reg:SI 29) (div:SI (reg:SI 26) (reg:SI 25)))\n+\t      (clobber (match_scratch:SI 3 \"\"))\n+\t      (clobber (reg:SI 26))\n+\t      (clobber (reg:SI 25))\n+\t      (clobber (reg:SI 31))])\n+   (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n+  \"\"\n+  \"\n+{\n+  if (!(GET_CODE (operands[2]) == CONST_INT && emit_hpdiv_const(operands, 0)))\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 26), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 25), operands[2]);\n+      emit\n+\t(gen_rtx\n+\t (PARALLEL, VOIDmode,\n+\t  gen_rtvec (5, gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 29),\n+\t\t\t\t gen_rtx (DIV, SImode,\n+\t\t\t\t\t  gen_rtx (REG, SImode, 26),\n+\t\t\t\t\t  gen_rtx (REG, SImode, 25))),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n+      emit_move_insn (operands[0], gen_rtx (REG, SImode, 29));\n+    }\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 29)\n+    (div:SI (reg:SI 26) (match_operand:SI 0 \"div_operand\" \"\")))\n+   (clobber (match_scratch:SI 1 \"=a\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 31))]\n+ \"\"\n+ \"*\n+ return output_div_insn (operands, 0);\"\n+ [(set_attr \"type\" \"milli\")])\n+\n+(define_expand \"udivsi3\"\n+  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+   (parallel [(set (reg:SI 29) (udiv:SI (reg:SI 26) (reg:SI 25)))\n+\t      (clobber (match_scratch:SI 3 \"\"))\n+\t      (clobber (reg:SI 26))\n+\t      (clobber (reg:SI 25))\n+\t      (clobber (reg:SI 31))])\n+   (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n+  \"\"\n+  \"\n+{\n+  if (!(GET_CODE (operands[2]) == CONST_INT && emit_hpdiv_const(operands, 1)))\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 26), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 25), operands[2]);\n+      emit\n+\t(gen_rtx\n+\t (PARALLEL, VOIDmode,\n+\t  gen_rtvec (5, gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 29),\n+\t\t\t\t gen_rtx (UDIV, SImode,\n+\t\t\t\t\t  gen_rtx (REG, SImode, 26),\n+\t\t\t\t\t  gen_rtx (REG, SImode, 25))),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n+      emit_move_insn (operands[0], gen_rtx (REG, SImode, 29));\n+    }\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 29)\n+    (udiv:SI (reg:SI 26) (match_operand:SI 0 \"div_operand\" \"\")))\n+   (clobber (match_scratch:SI 1 \"=a\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 31))]\n+ \"\"\n+ \"*\n+ return output_div_insn (operands, 1);\"\n+ [(set_attr \"type\" \"milli\")])\n+\n+(define_expand \"modsi3\"\n+  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+   (parallel [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n+\t      (clobber (match_scratch:SI 3 \"\"))\n+\t      (clobber (reg:SI 26))\n+\t      (clobber (reg:SI 25))\n+\t      (clobber (reg:SI 31))])\n+   (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n+  \"\"\n+  \"\n+{\n+  emit_move_insn (gen_rtx (REG, SImode, 26), operands[1]);\n+  emit_move_insn (gen_rtx (REG, SImode, 25), operands[2]);\n+  emit\n+    (gen_rtx\n+     (PARALLEL, VOIDmode,\n+      gen_rtvec (5, gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 29),\n+\t\t\t     gen_rtx (MOD, SImode,\n+\t\t\t\t      gen_rtx (REG, SImode, 26),\n+\t\t\t\t      gen_rtx (REG, SImode, 25))),\n+\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)),\n+\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n+\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n+\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n+  emit_move_insn (operands[0], gen_rtx (REG, SImode, 29));\n+  DONE;\n+}\")\n+ \n+(define_insn \"\"\n+  [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n+   (clobber (match_scratch:SI 0 \"=a\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  \"*\n+  return output_mod_insn (0);\"\n+  [(set_attr \"type\" \"milli\")])\n+\n+(define_expand \"umodsi3\"\n+  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+   (parallel [(set (reg:SI 29) (umod:SI (reg:SI 26) (reg:SI 25)))\n+\t      (clobber (match_scratch:SI 3 \"\"))\n+\t      (clobber (reg:SI 26))\n+\t      (clobber (reg:SI 25))\n+\t      (clobber (reg:SI 31))])\n+   (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n+  \"\"\n+  \"\n+{\n+  emit_move_insn (gen_rtx (REG, SImode, 26), operands[1]);\n+  emit_move_insn (gen_rtx (REG, SImode, 25), operands[2]);\n+  emit\n+    (gen_rtx\n+     (PARALLEL, VOIDmode,\n+      gen_rtvec (5, gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 29),\n+\t\t\t     gen_rtx (UMOD, SImode,\n+\t\t\t\t      gen_rtx (REG, SImode, 26),\n+\t\t\t\t      gen_rtx (REG, SImode, 25))),\n+\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)),\n+\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n+\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n+\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n+  emit_move_insn (operands[0], gen_rtx (REG, SImode, 29));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 29) (umod:SI (reg:SI 26) (reg:SI 25)))\n+   (clobber (match_scratch:SI 0 \"=a\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  \"*\n+  return output_mod_insn (1);\"\n+  [(set_attr \"type\" \"milli\")])\n+\n+;;- and instructions\n+;; We define DImode `and` so with DImode `not` we can get\n+;; DImode `andn`.  Other combinations are possible.\n+\n+(define_expand \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! register_operand (operands[1], DImode)\n+      || ! register_operand (operands[2], DImode))\n+    /* Let GCC break this into word-at-a-time operations.  */\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and %1,%2,%0\\;and %R1,%R2,%R0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t(not:DI (match_operand:DI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"andcm %2,%1,%0\\;andcm %R2,%R1,%R0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(not:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"andcm %1,%2,%0\")\n+\n+\n+(define_expand \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! register_operand (operands[1], DImode)\n+      || ! register_operand (operands[2], DImode))\n+    /* Let GCC break this into word-at-a-time operations.  */\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"or %1,%2,%0\\;or %R1,%R2,%R0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"or %1,%2,%0\")\n+\n+(define_expand \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! register_operand (operands[1], DImode)\n+      || ! register_operand (operands[2], DImode))\n+    /* Let GCC break this into word-at-a-time operations.  */\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor %1,%2,%0\\;xor %R1,%R2,%R0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor %r1,%2,%0\")\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub 0,%R1,%R0\\;subb 0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"@\n+   sub 0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_expand \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! register_operand (operands[1], DImode))\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"r\")))]\n+  \"\"\n+  \"uaddcm 0,%1,%0\\;uaddcm 0,%R1,%R0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"uaddcm 0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\f\n+;; Floating point arithmetic instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fxy\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"fxy\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fadd,dbl %1,%2,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fxy\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"fxy\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fadd,sgl %1,%2,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fxy\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"fxy\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fsub,dbl %1,%2,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fxy\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"fxy\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fsub,sgl %1,%2,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fxy\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"fxy\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fmpy,dbl %1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fxy\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"fxy\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fmpy,sgl %1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fxy\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"fxy\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fdiv,dbl %1,%2,%0\"\n+  [(set_attr \"type\" \"fpdivdbl\")])\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fxy\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"fxy\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fdiv,sgl %1,%2,%0\"\n+  [(set_attr \"type\" \"fpdivsgl\")])\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fxy\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fsub,dbl 0,%1,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fxy\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fsub,sgl 0, %1,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fxy\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fabs,dbl %0,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fxy\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fabs,sgl %1,%0\"\n+  [(set_attr \"type\" \"fpalu\")])\n+\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fxy\")\n+\t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"fxy\")))]\n+  \"\"\n+  \"fsqrt,dbl %1,%0\"\n+  [(set_attr \"type\" \"fpsqrtdbl\")])\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsqrt,sgl %1,%0\"\n+  [(set_attr \"type\" \"fpsqrtsgl\")])\n+\f\n+;;- Shift instructions\n+\n+;; Optimized special case of shifting.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 24)))]\n+  \"\"\n+  \"ldb%M1 %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 2))\n+\t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sh1add %2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 4))\n+\t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sh2add %2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 8))\n+\t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sh3add %2,%1,%0\")\n+\n+(define_insn \"sar_sub\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(if_then_else (gtu:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 1 \"int11_operand\" \"I\"))\n+\t\t      (const_int 0)\n+\t\t      (minus:SI (match_dup 1) (match_dup 2))))]\n+  \"\"\n+  \"subi,>>= %1,%2,%0\\;copy 0,%0\"\n+  [(set_attr \"length\" \"2\" )])\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"arith5_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      emit_insn (gen_sar_sub (temp,\n+\t\t\t      gen_rtx (CONST_INT, VOIDmode, 31),\n+\t\t\t      operands[2]));\n+      emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 112), temp));\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  operands[0],\n+\t\t\t  gen_rtx (ASHIFT, SImode,\n+\t\t\t\t   operands[1],\n+\t\t\t\t   gen_rtx (MINUS, SImode,\n+\t\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, 31),\n+\t\t\t\t\t    gen_rtx (REG, SImode, 112)))));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"int5_operand\" \"L\")))]\n+ \"\"\n+ \"*\n+{\n+  rtx xoperands[4];\n+  xoperands[0] = operands[0];  xoperands[1] = operands[1];\n+  xoperands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  31 - INTVAL (operands[2]));\n+  xoperands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  32 - INTVAL (operands[2]));\n+  output_asm_insn (\\\"zdep %1,%2,%3,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (minus:SI (const_int 31)\n+\t\t\t    (reg:SI 112))))]\n+ \"\"\n+ \"zvdep %1,32,%0\")\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"arith5_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      emit_insn (gen_sar_sub (temp,\n+\t\t\t      gen_rtx (CONST_INT, VOIDmode, 31),\n+\t\t\t      operands[2]));\n+      emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 112), temp));\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  operands[0],\n+\t\t\t  gen_rtx (ASHIFTRT, SImode,\n+\t\t\t\t   operands[1],\n+\t\t\t\t   gen_rtx (MINUS, SImode,\n+\t\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, 31),\n+\t\t\t\t\t    gen_rtx (REG, SImode, 112)))));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"int5_operand\" \"L\")))]\n+ \"\"\n+ \"*\n+{\n+  rtx xoperands[4];\n+  xoperands[0] = operands[0];  xoperands[1] = operands[1];\n+  xoperands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  31 - INTVAL (operands[2]));\n+  xoperands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  32 - INTVAL (operands[2]));\n+  output_asm_insn (\\\"extrs %1,%2,%3,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\")\n+\n+\n+(define_insn \"\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (minus:SI (const_int 31)\n+\t\t\t    (reg:SI 112))))]\n+ \"\"\n+ \"vextrs %1,32,%0\")\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"arith5_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      emit_insn (gen_sar_sub (temp,\n+\t\t\t      gen_rtx (CONST_INT, VOIDmode, 31),\n+\t\t\t      operands[2]));\n+      emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 112), temp));\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  operands[0],\n+\t\t\t  gen_rtx (LSHIFTRT, SImode,\n+\t\t\t\t   operands[1],\n+\t\t\t\t   gen_rtx (MINUS, SImode,\n+\t\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, 31),\n+\t\t\t\t\t    gen_rtx (REG, SImode, 112)))));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"uint5_operand\" \"K\")))]\n+ \"\"\n+ \"*\n+{\n+  rtx xoperands[4];\n+  xoperands[0] = operands[0];  xoperands[1] = operands[1];\n+  xoperands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  31 - INTVAL (operands[2]));\n+  xoperands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  32 - INTVAL (operands[2]));\n+  output_asm_insn (\\\"extru %1,%2,%3,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (minus:SI (const_int 31)\n+\t\t\t    (reg:SI 112))))]\n+ \"\"\n+ \"vextru %1,32,%0\")\n+\f\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"bl%* %l0,0\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"casesi\"\n+  [(set (pc)\n+\t(if_then_else (leu (minus:SI\n+\t\t\t    (match_operand:SI 0 \"general_operand\" \"r\")\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"rI\"))\n+\t\t\t   (match_operand:SI 2 \"general_operand\" \"rI\"))\n+\t\t      (plus:SI (mem:SI (plus:SI (pc)\n+\t\t\t\t\t\t(minus:SI (match_dup 0)\n+\t\t\t\t\t\t\t  (match_dup 1))))\n+\t\t\t       (label_ref (match_operand 3 \"\" \"\")))\n+\t\t      (pc)))\n+   (use (label_ref (match_operand 4 \"\" \"\")))\n+   (clobber (match_scratch:SI 5 \"=r\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t INTVAL (operands[1]) + INTVAL (operands[2]));\n+\t  if (!INT_11_BITS (operands[2]))\n+\t    {\n+\t      output_asm_insn (\\\"ldo %2(0),%5\\\", operands);\n+\t      operands[2] = operands[5];\n+\t    }\n+\t}\n+      else\n+\toutput_asm_insn (\\\"ldo %1(%2),%2\\\", operands);\n+      output_asm_insn (\\\"addi,< %n1,%0,0\\\", operands);\n+    }\n+  else\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  output_asm_insn (\\\"ldo %2(%1),%5\\\", operands);\n+\t  operands[2] = operands[5];\n+\t}\n+      output_asm_insn (\\\"sub,< %0,%1,0\\\", operands);\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    output_asm_insn (\\\"addi,<= %n2,%0,0\\\", operands);\n+  else\n+    output_asm_insn (\\\"sub,<= %0,%2,0\\\", operands);\n+  output_asm_insn (\\\"b,n %l4\\\", operands);\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    output_asm_insn (\\\"ldo %n1(%0),%5\\\", operands);\n+  else output_asm_insn (\\\"sub %0,%1,%5\\\", operands);\n+  return \\\"blr %5,0\\;nop\\\";\n+}\"\n+[(set_attr \"length\" \"7\")])\n+  \n+;; Need nops for the calls because execution is supposed to continue\n+;; past; we don't want to nullify an instruction that we need.\n+;;- jump to subroutine\n+\n+(define_expand \"call\"\n+ [(parallel [(call (match_operand:SI 0 \"\" \"\")\n+\t\t   (match_operand 1 \"\" \"\"))\n+\t     (clobber (reg:SI 31))\n+\t     (clobber (reg:SI 2))])]\n+ \"\"\n+ \"\n+{\n+  operands[0] = gen_rtx (MEM, SImode, XEXP (operands[0], 0));\n+}\")\n+\n+(define_insn \"\"\n+ [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"r,S\"))\n+\t(match_operand 1 \"\" \"i,i\"))\n+  (clobber (reg:SI 31))\n+  (clobber (reg:SI 2))]\n+ \"\"\n+ \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"copy %0,22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,31\\;copy 31,2\\\";\n+  else\n+    {\n+      output_arg_descriptor (insn);\n+      return \\\"bl %0,2%#\\\";\n+    }\n+}\"\n+ [(set_attr \"type\" \"dyncall,call\")\n+  (set_attr \"length\" \"3,1\")])\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand:SI 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:SI 31))\n+\t      (clobber (reg:SI 2))])]\n+  ;;- Don't use operand 1 for most machines.\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx (MEM, SImode, XEXP (operands[1], 0));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=rfx,rfx\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand_address\" \"r,S\"))\n+\t      (match_operand 2 \"\" \"i,i\")))\n+   (clobber (reg:SI 31))\n+   (clobber (reg:SI 2))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"copy %1,22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,31\\;copy 31,2\\\";\n+  else\n+    {\n+      output_arg_descriptor (insn);\n+      return \\\"bl %1,2\\;nop\\\";\n+    }\n+}\"\n+ [(set_attr \"type\" \"dyncall\")\n+  (set_attr \"length\" \"3,2\")])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+;;; Hope this is only within a function...\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+ \"bv 0(%0)%#\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n+  \"\"\n+  \"extru %1,%3+%2-1,%2,%0\")\n+\n+(define_insn \"extv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n+  \"\"\n+  \"extrs %1,%3+%2-1,%2,%0\")\n+\n+(define_insn \"insv\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t\t (match_operand:SI 1 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\"))\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"dep %3,%2+%1-1,%1,%0\")\n+\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}