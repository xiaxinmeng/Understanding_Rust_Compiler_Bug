{"sha": "b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFkNWVlZThjMTNhOTUyZjhjM2Y0NmYxYWJiZThkYThjMTIwNDBhOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-19T09:56:07Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-19T09:56:07Z"}, "message": "postreload.c (reload_combine_closest_single_use): Ignore the number of uses for DEBUG_INSNs.\n\n\t* postreload.c (reload_combine_closest_single_use): Ignore the\n\tnumber of uses for DEBUG_INSNs.\n\t(fixup_debug_insns): New static function.\n\t(reload_combine_recognize_const_pattern): Use it.  Don't let the\n\tmain loop be affected by DEBUG_INSNs.\n\tReally disallow moving adds past a jump insn.\n\t(reload_combine_recognize_pattern): Don't update use_ruid here.\n\t(reload_combine_note_use): Do it here.\n\t(reload_combine): Use control_flow_insn_p rather than JUMP_P.\n\nFrom-SVN: r162301", "tree": {"sha": "1ba7091a4ae2a6a6d6dd2e50926a0b1cf6012b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ba7091a4ae2a6a6d6dd2e50926a0b1cf6012b36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8/comments", "author": null, "committer": null, "parents": [{"sha": "0be955e73751c1ffc6468d6a9679201103a21718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be955e73751c1ffc6468d6a9679201103a21718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be955e73751c1ffc6468d6a9679201103a21718"}], "stats": {"total": 83, "additions": 71, "deletions": 12}, "files": [{"sha": "bac660be902489c0573a384f5f96b83501b6255e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8", "patch": "@@ -1,3 +1,15 @@\n+2010-07-19  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* postreload.c (reload_combine_closest_single_use): Ignore the\n+\tnumber of uses for DEBUG_INSNs.\n+\t(fixup_debug_insns): New static function.\n+\t(reload_combine_recognize_const_pattern): Use it.  Don't let the\n+\tmain loop be affected by DEBUG_INSNs.\n+\tReally disallow moving adds past a jump insn.\n+\t(reload_combine_recognize_pattern): Don't update use_ruid here.\n+\t(reload_combine_note_use): Do it here.\n+\t(reload_combine): Use control_flow_insn_p rather than JUMP_P.\n+\n 2010-07-19  Bingfeng Mei  <bmei@broadcom.com>\n \t* ddg.c (create_ddg): Exclude nodes of debug_insn in counting nodes\n         of a loop."}, {"sha": "9a05cbc729fe4bc3c12771126863b774325993d7", "filename": "gcc/postreload.c", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=b1d5eee8c13a952f8c3f46f1abbe8da8c12040a8", "patch": "@@ -816,7 +816,8 @@ reload_combine_purge_reg_uses_after_ruid (unsigned regno, int ruid)\n \n /* Find the use of REGNO with the ruid that is highest among those\n    lower than RUID_LIMIT, and return it if it is the only use of this\n-   reg in the insn.  Return NULL otherwise.  */\n+   reg in the insn (or if the insn is a debug insn).  Return NULL\n+   otherwise.  */\n \n static struct reg_use *\n reload_combine_closest_single_use (unsigned regno, int ruid_limit)\n@@ -830,22 +831,61 @@ reload_combine_closest_single_use (unsigned regno, int ruid_limit)\n   retval = NULL;\n   for (i = use_idx; i < RELOAD_COMBINE_MAX_USES; i++)\n     {\n-      int this_ruid = reg_state[regno].reg_use[i].ruid;\n+      struct reg_use *use = reg_state[regno].reg_use + i; \n+      int this_ruid = use->ruid;\n       if (this_ruid >= ruid_limit)\n \tcontinue;\n       if (this_ruid > best_ruid)\n \t{\n \t  best_ruid = this_ruid;\n \t  retval = reg_state[regno].reg_use + i;\n \t}\n-      else if (this_ruid == best_ruid)\n+      else if (this_ruid == best_ruid && !DEBUG_INSN_P (use->insn))\n \tretval = NULL;\n     }\n   if (last_label_ruid >= best_ruid)\n     return NULL;\n   return retval;\n }\n \n+/* After we've moved an add insn, fix up any debug insns that occur between\n+   the old location of the add and the new location.  REGNO is the destination\n+   register of the add insn; REG is the corresponding RTX.  REPLACEMENT is\n+   the SET_SRC of the add.  MIN_RUID specifies the ruid of the insn after\n+   which we've placed the add, we ignore any debug insns after it.  */\n+\n+static void\n+fixup_debug_insns (unsigned regno, rtx reg, rtx replacement, int min_ruid)\n+{\n+  struct reg_use *use;\n+  int from = reload_combine_ruid;\n+  for (;;)\n+    {\n+      rtx t;\n+      rtx use_insn = NULL_RTX;\n+      if (from < min_ruid)\n+\tbreak;\n+      use = reload_combine_closest_single_use (regno, from);\n+      if (use)\n+\t{\n+\t  from = use->ruid;\n+\t  use_insn = use->insn;\n+\t}\n+      else\n+\tbreak;\n+      \n+      if (NONDEBUG_INSN_P (use->insn))\n+\tcontinue;\n+      t = INSN_VAR_LOCATION_LOC (use_insn);\n+      t = simplify_replace_rtx (t, reg, copy_rtx (replacement));\n+      validate_change (use->insn,\n+\t\t       &INSN_VAR_LOCATION_LOC (use->insn), t, 0);\n+      reload_combine_purge_insn_uses (use_insn);\n+      reload_combine_note_use (&PATTERN (use_insn), use_insn,\n+\t\t\t       use->ruid, NULL_RTX);\n+    }\n+}\n+\n /* Called by reload_combine when scanning INSN.  This function tries to detect\n    patterns where a constant is added to a register, and the result is used\n    in an address.\n@@ -913,6 +953,10 @@ reload_combine_recognize_const_pattern (rtx insn)\n \t/* Start the search for the next use from here.  */\n \tfrom_ruid = use->ruid;\n \n+      /* We'll fix up DEBUG_INSNs after we're done.  */\n+      if (use && DEBUG_INSN_P (use->insn))\n+\tcontinue;\n+\n       if (use && GET_MODE (*use->usep) == Pmode)\n \t{\n \t  rtx use_insn = use->insn;\n@@ -921,7 +965,7 @@ reload_combine_recognize_const_pattern (rtx insn)\n \t  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn));\n \n \t  /* Avoid moving the add insn past a jump.  */\n-\t  if (must_move_add && use_ruid < last_jump_ruid)\n+\t  if (must_move_add && use_ruid <= last_jump_ruid)\n \t    break;\n \n \t  /* If the add clobbers another hard reg in parallel, don't move\n@@ -1019,6 +1063,8 @@ reload_combine_recognize_const_pattern (rtx insn)\n     /* Process the add normally.  */\n     return false;\n \n+  fixup_debug_insns (regno, reg, src, add_moved_after_ruid);\n+  \n   reorder_insns (insn, insn, add_moved_after_insn);\n   reload_combine_purge_reg_uses_after_ruid (regno, add_moved_after_ruid);\n   reload_combine_split_ruids (add_moved_after_ruid - 1);\n@@ -1155,11 +1201,6 @@ reload_combine_recognize_pattern (rtx insn)\n \t\t   reg_state[regno].reg_use[i].ruid,\n \t\t   reg_state[regno].reg_use[i].containing_mem);\n \n-\t      if (reg_state[REGNO (base)].use_ruid\n-\t\t  > reg_state[regno].use_ruid)\n-\t\treg_state[REGNO (base)].use_ruid\n-\t\t  = reg_state[regno].use_ruid;\n-\n \t      /* Delete the reg-reg addition.  */\n \t      delete_insn (insn);\n \n@@ -1277,7 +1318,7 @@ reload_combine (void)\n \n       reload_combine_ruid++;\n \n-      if (JUMP_P (insn))\n+      if (control_flow_insn_p (insn))\n \tlast_jump_ruid = reload_combine_ruid;\n \n       if (reload_combine_recognize_const_pattern (insn)\n@@ -1495,8 +1536,14 @@ reload_combine_note_use (rtx *xp, rtx insn, int ruid, rtx containing_mem)\n \t    reg_state[regno].all_offsets_match = true;\n \t    reg_state[regno].use_ruid = ruid;\n \t  }\n-\telse if (! rtx_equal_p (offset, reg_state[regno].offset))\n-\t  reg_state[regno].all_offsets_match = false;\n+\telse\n+\t  {\n+\t    if (reg_state[regno].use_ruid > ruid)\n+\t      reg_state[regno].use_ruid = ruid;\n+\n+\t    if (! rtx_equal_p (offset, reg_state[regno].offset))\n+\t      reg_state[regno].all_offsets_match = false;\n+\t  }\n \n \treg_state[regno].reg_use[use_index].insn = insn;\n \treg_state[regno].reg_use[use_index].ruid = ruid;"}]}