{"sha": "4838c5ee553f062d75d0a6288a025e98600de97c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzOGM1ZWU1NTNmMDYyZDc1ZDBhNjI4OGEwMjVlOTg2MDBkZTk3Yw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-10-05T04:20:27Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-10-05T04:20:27Z"}, "message": "Makefile.in (c-decl.o): Depend on tree-inline.h.\n\n* Makefile.in (c-decl.o): Depend on tree-inline.h.\n(c-lang.o): Likewise, as well as insn-config.h and integrate.h.\n* c-decl.c: Include tree-inline.h.\n(c_expand_body): Call optimize_inline_calls. Determine whether\na function is inlinable upfront, and only clear\nDECL_SAVED_TREE, DECL_INITIAL and DECL_ARGUMENTS if it isn't.\n* c-lang.c: Include tree-inline.h, insn-config.h and integrate.h.\n(c_disregard_inline_limits): New function.\n(inline_forbidden_p, c_cannot_inline_tree_fn): Likewise.\n(c_post_options): Enable tree inlining if inlining is enabled.\nDon't inline trees when instrumenting functions.\n(c_init): Initialize lang_disregard_inline_limits and\nlang_cannot_inline_tree_fn.\n* tree-inline.c (initialize_inlined_parameters): Handle calls\nwith fewer arguments than declared parameters, and fewer\nparameters than passed arguments.  Don't assume value is a\nDECL.\n(declare_return_variable): Convert return value back to the\noriginal type, if it was promoted.\n(tree_inlinable_function_p): New function.\n(inlinable_function_p): Don't look at DECL_INLINE if we're\ninlining all functions.  Make it work with a NULL id.\nRe-check DECL_UNINLINABLE after language-specific checks.\n(varargs_function_p): Move back to cp/tree.c.\n* tree-inline.h (tree_inlinable_function_p): Declare it.\n(varargs_function_p): Removed declaration.\n* integrate.h (function_attribute_inlinable_p): Declare it.\n* integrate.c (function_attribute_inlinable_p): Export it.\n(save_for_inline): Don't bother to prepare argvec when not\ninlining.\n* cse.c (check_for_label_ref): Don't check deleted labels.\n\nFrom-SVN: r46025", "tree": {"sha": "8ce05ef7518fd1359d3ae5d044511179f1ea1c8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ce05ef7518fd1359d3ae5d044511179f1ea1c8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4838c5ee553f062d75d0a6288a025e98600de97c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4838c5ee553f062d75d0a6288a025e98600de97c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4838c5ee553f062d75d0a6288a025e98600de97c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4838c5ee553f062d75d0a6288a025e98600de97c/comments", "author": null, "committer": null, "parents": [{"sha": "8d5463d486fe257414a840e204531a8e4405a9a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d5463d486fe257414a840e204531a8e4405a9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d5463d486fe257414a840e204531a8e4405a9a6"}], "stats": {"total": 352, "additions": 311, "deletions": 41}, "files": [{"sha": "f8436b7930771ef79d4e7b6cb370702092cd977d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4838c5ee553f062d75d0a6288a025e98600de97c", "patch": "@@ -1,5 +1,37 @@\n 2001-10-05  Alexandre Oliva  <aoliva@redhat.com>\n \n+\t* Makefile.in (c-decl.o): Depend on tree-inline.h.\n+\t(c-lang.o): Likewise, as well as insn-config.h and integrate.h.\n+\t* c-decl.c: Include tree-inline.h.\n+\t(c_expand_body): Call optimize_inline_calls. Determine whether\n+\ta function is inlinable upfront, and only clear\n+\tDECL_SAVED_TREE, DECL_INITIAL and DECL_ARGUMENTS if it isn't.\n+\t* c-lang.c: Include tree-inline.h, insn-config.h and integrate.h.\n+\t(c_disregard_inline_limits): New function.\n+\t(inline_forbidden_p, c_cannot_inline_tree_fn): Likewise.\n+\t(c_post_options): Enable tree inlining if inlining is enabled.\n+\tDon't inline trees when instrumenting functions.\n+\t(c_init): Initialize lang_disregard_inline_limits and\n+\tlang_cannot_inline_tree_fn.\n+\t* tree-inline.c (initialize_inlined_parameters): Handle calls\n+\twith fewer arguments than declared parameters, and fewer\n+\tparameters than passed arguments.  Don't assume value is a\n+\tDECL.\n+\t(declare_return_variable): Convert return value back to the\n+\toriginal type, if it was promoted.\n+\t(tree_inlinable_function_p): New function.\n+\t(inlinable_function_p): Don't look at DECL_INLINE if we're\n+\tinlining all functions.  Make it work with a NULL id.\n+\tRe-check DECL_UNINLINABLE after language-specific checks.\n+\t(varargs_function_p): Move back to cp/tree.c.\n+\t* tree-inline.h (tree_inlinable_function_p): Declare it.\n+\t(varargs_function_p): Removed declaration.\n+\t* integrate.h (function_attribute_inlinable_p): Declare it.\n+\t* integrate.c (function_attribute_inlinable_p): Export it.\n+\t(save_for_inline): Don't bother to prepare argvec when not\n+\tinlining.\n+\t* cse.c (check_for_label_ref): Don't check deleted labels.\n+\n \t* Makefile.in (tree-inline.o): Depend on newly-included headers.\n \t* tree-inline.c: Include headers needed for the functions moved in.\n \t(struct inline_data, INSNS_PER_STMT): Moved from cp/optimize.c."}, {"sha": "3199e2af7e894ff2d2e657701af99cc127ae9352", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4838c5ee553f062d75d0a6288a025e98600de97c", "patch": "@@ -1168,12 +1168,12 @@ $(srcdir)/c-parse.y: c-parse.in\n \n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) $(C_TREE_H) \\\n     $(GGC_H) $(TARGET_H) c-lex.h flags.h function.h output.h $(EXPR_H) \\\n-    debug.h toplev.h intl.h $(TM_P_H)\n+    debug.h toplev.h intl.h $(TM_P_H) tree-inline.h\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     $(GGC_H)  c-lex.h toplev.h diagnostic.h output.h function.h \\\n-    $(RTL_H) $(EXPR_H)\n+    $(RTL_H) $(EXPR_H) tree-inline.h insn-config.h integrate.h\n c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) c-lex.h \\\n     debug.h $(C_TREE_H) \\\n     c-pragma.h input.h intl.h flags.h toplev.h output.h \\"}, {"sha": "10e4270aceb7faf7fc606343043c4ebf18f9e291", "filename": "gcc/c-decl.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=4838c5ee553f062d75d0a6288a025e98600de97c", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"system.h\"\n #include \"intl.h\"\n #include \"tree.h\"\n+#include \"tree-inline.h\"\n #include \"rtl.h\"\n #include \"flags.h\"\n #include \"function.h\"\n@@ -6707,11 +6708,24 @@ c_expand_body (fndecl, nested_p)\n      tree fndecl;\n      int nested_p;\n {\n+  int uninlinable = 1;\n+\n   /* There's no reason to do any of the work here if we're only doing\n      semantic analysis; this code just generates RTL.  */\n   if (flag_syntax_only)\n     return;\n \n+  if (flag_inline_trees)\n+    {\n+      /* First, cache whether the current function is inlinable.  Some\n+         predicates depend on cfun and current_function_decl to\n+         function completely.  */\n+      uninlinable = ! tree_inlinable_function_p (fndecl);\n+      \n+      /* Then, inline any functions called in it.  */\n+      optimize_inline_calls (fndecl);\n+    }\n+\n   if (nested_p)\n     {\n       /* Make sure that we will evaluate variable-sized types involved\n@@ -6751,8 +6765,11 @@ c_expand_body (fndecl, nested_p)\n \n   /* Generate the RTL for this function.  */\n   expand_stmt (DECL_SAVED_TREE (fndecl));\n-  /* Allow the body of the function to be garbage collected.  */\n-  DECL_SAVED_TREE (fndecl) = NULL_TREE;\n+  if (uninlinable)\n+    {\n+      /* Allow the body of the function to be garbage collected.  */\n+      DECL_SAVED_TREE (fndecl) = NULL_TREE;\n+    }\n \n   /* We hard-wired immediate_size_expand to zero above.\n      expand_function_end will decrement this variable.  So, we set the\n@@ -6813,7 +6830,8 @@ c_expand_body (fndecl, nested_p)\n \t}\n     }\n \n-  if (DECL_SAVED_INSNS (fndecl) == 0 && ! nested_p)\n+  if (DECL_SAVED_INSNS (fndecl) == 0 && ! nested_p\n+      && ! flag_inline_trees)\n     {\n       /* Stop pointing to the local nodes about to be freed.\n \t But DECL_INITIAL must remain nonzero so we know this"}, {"sha": "7e7ebb74eed4dddff6b0db7d90b2694d60af0e99", "filename": "gcc/c-lang.c", "status": "modified", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=4838c5ee553f062d75d0a6288a025e98600de97c", "patch": "@@ -23,6 +23,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n+#include \"tree-inline.h\"\n #include \"function.h\"\n #include \"input.h\"\n #include \"toplev.h\"\n@@ -35,12 +36,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-tree.h\"\n #include \"c-lex.h\"\n #include \"cpplib.h\"\n+#include \"insn-config.h\"\n+#include \"integrate.h\"\n \n static int c_tree_printer PARAMS ((output_buffer *));\n static int c_missing_noreturn_ok_p PARAMS ((tree));\n static void c_init PARAMS ((void));\n static void c_init_options PARAMS ((void));\n static void c_post_options PARAMS ((void));\n+static int c_disregard_inline_limits PARAMS ((tree));\n+static int c_cannot_inline_tree_fn PARAMS ((tree *));\n \n /* Each front end provides its own.  */\n struct lang_hooks lang_hooks = {c_init,\n@@ -54,6 +59,22 @@ static void\n c_post_options ()\n {\n   cpp_post_options (parse_in);\n+\n+  /* Use tree inlining if possible.  Function instrumentation is only\n+     done in the RTL level, so we disable tree inlining.  */\n+  if (! flag_instrument_function_entry_exit)\n+    {\n+      if (!flag_no_inline)\n+\t{\n+\t  flag_inline_trees = 1;\n+\t  flag_no_inline = 1;\n+\t}\n+      if (flag_inline_functions)\n+\t{\n+\t  flag_inline_trees = 2;\n+\t  flag_inline_functions = 0;\n+\t}\n+    }\n }\n \n static void\n@@ -91,6 +112,8 @@ c_init ()\n   diagnostic_format_decoder (global_dc) = &c_tree_printer;\n   lang_expand_decl_stmt = &c_expand_decl_stmt;\n   lang_missing_noreturn_ok_p = &c_missing_noreturn_ok_p;\n+  lang_disregard_inline_limits = &c_disregard_inline_limits;\n+  lang_cannot_inline_tree_fn = &c_cannot_inline_tree_fn;\n \n   c_parse_init ();\n }\n@@ -308,3 +331,155 @@ c_missing_noreturn_ok_p (decl)\n      ok for the `main' function in hosted implementations.  */\n   return flag_hosted && MAIN_NAME_P (DECL_ASSEMBLER_NAME (decl));\n }\n+\n+/* We want to inline `extern inline' functions even if this would\n+   violate inlining limits.  Some glibc and linux constructs depend on\n+   such functions always being inlined when optimizing.  */\n+\n+static int\n+c_disregard_inline_limits (fn)\n+     tree fn;\n+{\n+  return DECL_INLINE (fn) && DECL_EXTERNAL (fn);\n+}\n+\n+static tree inline_forbidden_p PARAMS ((tree *, int *, void *));\n+\n+static tree\n+inline_forbidden_p (nodep, walk_subtrees, fn)\n+     tree *nodep;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *fn;\n+{\n+  tree node = *nodep;\n+  tree t;\n+\n+  switch (TREE_CODE (node))\n+    {\n+    case CALL_EXPR:\n+      t = get_callee_fndecl (node);\n+\n+      if (! t)\n+\tbreak;\n+\n+      /* We cannot inline functions that call setjmp.  */\n+      if (setjmp_call_p (t))\n+\treturn node;\n+\n+      switch (DECL_FUNCTION_CODE (t))\n+\t{\n+\t  /* We cannot inline functions that take a variable number of\n+\t     arguments.  */\n+\tcase BUILT_IN_VARARGS_START:\n+\tcase BUILT_IN_STDARG_START:\n+#if 0\n+\t  /* Functions that need information about the address of the\n+             caller can't (shouldn't?) be inlined.  */\n+\tcase BUILT_IN_RETURN_ADDRESS:\n+#endif\n+\t  return node;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      break;\n+\n+    case DECL_STMT:\n+      /* We cannot inline functions that contain other functions.  */\n+      if (TREE_CODE (TREE_OPERAND (node, 0)) == FUNCTION_DECL\n+\t  && DECL_INITIAL (TREE_OPERAND (node, 0)))\n+\treturn node;\n+      break;\n+\n+    case GOTO_STMT:\n+    case GOTO_EXPR:\n+      t = TREE_OPERAND (node, 0);\n+\n+      /* We will not inline a function which uses computed goto.  The\n+\t addresses of its local labels, which may be tucked into\n+\t global storage, are of course not constant across\n+\t instantiations, which causes unexpected behaviour.  */\n+      if (TREE_CODE (t) != LABEL_DECL)\n+\treturn node;\n+\n+      /* We cannot inline a nested function that jumps to a nonlocal\n+         label.  */\n+      if (TREE_CODE (t) == LABEL_DECL\n+\t  && DECL_CONTEXT (t) && DECL_CONTEXT (t) != fn)\n+\treturn node;\n+\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+static int\n+c_cannot_inline_tree_fn (fnp)\n+     tree *fnp;\n+{\n+  tree fn = *fnp;\n+  tree t;\n+\n+  if (! function_attribute_inlinable_p (fn))\n+    {\n+      DECL_UNINLINABLE (fn) = 1;\n+      return 1;\n+    }\n+\n+  /* If a function has pending sizes, we must not defer its\n+     compilation, and we can't inline it as a tree.  */\n+  if (fn == current_function_decl)\n+    {\n+      t = get_pending_sizes ();\n+      put_pending_sizes (t);\n+\n+      if (t)\n+\t{\n+\t  DECL_UNINLINABLE (fn) = 1;\n+\t  return 1;\n+\t}\n+    }\n+\n+  if (DECL_CONTEXT (fn))\n+    {\n+      /* If a nested function has pending sizes, we may have already\n+         saved them.  */\n+      if (DECL_LANG_SPECIFIC (fn)->pending_sizes)\n+\t{\n+\t  DECL_UNINLINABLE (fn) = 1;\n+\t  return 1;\n+\t}\n+    }\n+  else\n+    {\n+      /* We rely on the fact that this function is called upfront,\n+\t just before we start expanding a function.  If FN is active\n+\t (i.e., it's the current_function_decl or a parent thereof),\n+\t we have to walk FN's saved tree.  Otherwise, we can safely\n+\t assume we have done it before and, if we didn't mark it as\n+\t uninlinable (in which case we wouldn't have been called), it\n+\t is inlinable.  Unfortunately, this strategy doesn't work for\n+\t nested functions, because they're only expanded as part of\n+\t their enclosing functions, so the inlinability test comes in\n+\t late.  */\n+      t = current_function_decl;\n+\n+      while (t && t != fn)\n+\tt = DECL_CONTEXT (t);\n+      if (! t)\n+\treturn 0;\n+    }\n+    \n+  if (walk_tree (&DECL_SAVED_TREE (fn), inline_forbidden_p, fn, NULL))\n+    {\n+      DECL_UNINLINABLE (fn) = 1;\n+      return 1;\n+    }\n+\n+  return 0;\n+}"}, {"sha": "895a5620bbb8895e8f1bfe6f73e7d50757f2d8e3", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4838c5ee553f062d75d0a6288a025e98600de97c", "patch": "@@ -7376,6 +7376,7 @@ check_for_label_ref (rtl, data)\n      LABEL_REF for a CODE_LABEL that isn't in the insn chain, don't do this\n      since no REG_LABEL will be added.  */\n   return (GET_CODE (*rtl) == LABEL_REF\n+\t  && LABEL_P (XEXP (*rtl, 0))\n \t  && INSN_UID (XEXP (*rtl, 0)) != 0\n \t  && ! find_reg_note (insn, REG_LABEL, XEXP (*rtl, 0)));\n }"}, {"sha": "ddd1ce248f6d3d9f47cce6af0a8303cc4bff484b", "filename": "gcc/integrate.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=4838c5ee553f062d75d0a6288a025e98600de97c", "patch": "@@ -440,8 +440,8 @@ save_for_inline (fndecl)\n      Also set up ARG_VECTOR, which holds the unmodified DECL_RTX values\n      for the parms, prior to elimination of virtual registers.\n      These values are needed for substituting parms properly.  */\n-\n-  parmdecl_map = (tree *) xmalloc (max_parm_reg * sizeof (tree));\n+  if (! flag_no_inline)\n+    parmdecl_map = (tree *) xmalloc (max_parm_reg * sizeof (tree));\n \n   /* Make and emit a return-label if we have not already done so.  */\n \n@@ -451,7 +451,10 @@ save_for_inline (fndecl)\n       emit_label (return_label);\n     }\n \n-  argvec = initialize_for_inline (fndecl);\n+  if (! flag_no_inline)\n+    argvec = initialize_for_inline (fndecl);\n+  else\n+    argvec = NULL;\n \n   /* Delete basic block notes created by early run of find_basic_block.\n      The notes would be later used by find_basic_blocks to reuse the memory\n@@ -468,27 +471,31 @@ save_for_inline (fndecl)\n   if (GET_CODE (insn) != NOTE)\n     abort ();\n \n-  /* Get the insn which signals the end of parameter setup code.  */\n-  first_nonparm_insn = get_first_nonparm_insn ();\n-\n-  /* Now just scan the chain of insns to see what happens to our\n-     PARM_DECLs.  If a PARM_DECL is used but never modified, we\n-     can substitute its rtl directly when expanding inline (and\n-     perform constant folding when its incoming value is constant).\n-     Otherwise, we have to copy its value into a new register and track\n-     the new register's life.  */\n-  in_nonparm_insns = 0;\n-  save_parm_insns (insn, first_nonparm_insn);\n-\n-  cfun->inl_max_label_num = max_label_num ();\n-  cfun->inl_last_parm_insn = cfun->x_last_parm_insn;\n-  cfun->original_arg_vector = argvec;\n+  if (! flag_no_inline)\n+    {\n+      /* Get the insn which signals the end of parameter setup code.  */\n+      first_nonparm_insn = get_first_nonparm_insn ();\n+\n+      /* Now just scan the chain of insns to see what happens to our\n+\t PARM_DECLs.  If a PARM_DECL is used but never modified, we\n+\t can substitute its rtl directly when expanding inline (and\n+\t perform constant folding when its incoming value is\n+\t constant).  Otherwise, we have to copy its value into a new\n+\t register and track the new register's life.  */\n+      in_nonparm_insns = 0;\n+      save_parm_insns (insn, first_nonparm_insn);\n+\n+      cfun->inl_max_label_num = max_label_num ();\n+      cfun->inl_last_parm_insn = cfun->x_last_parm_insn;\n+      cfun->original_arg_vector = argvec;\n+    }\n   cfun->original_decl_initial = DECL_INITIAL (fndecl);\n   cfun->no_debugging_symbols = (write_symbols == NO_DEBUG);\n   DECL_SAVED_INSNS (fndecl) = cfun;\n \n   /* Clean up.  */\n-  free (parmdecl_map);\n+  if (! flag_no_inline)\n+    free (parmdecl_map);\n }\n \n /* Scan the chain of insns to see what happens to our PARM_DECLs.  If a"}, {"sha": "310ff8802c6f716017ef39e7b66dfa463376a448", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=4838c5ee553f062d75d0a6288a025e98600de97c", "patch": "@@ -483,23 +483,25 @@ initialize_inlined_parameters (id, args, fn)\n \n   /* Loop through the parameter declarations, replacing each with an\n      equivalent VAR_DECL, appropriately initialized.  */\n-  for (p = parms, a = args; p; a = TREE_CHAIN (a), p = TREE_CHAIN (p))\n+  for (p = parms, a = args; p;\n+       a = a ? TREE_CHAIN (a) : a, p = TREE_CHAIN (p))\n     {\n       tree init_stmt;\n       tree var;\n       tree value;\n \n       /* Find the initializer.  */\n-      value = TREE_VALUE (a);\n+      value = a ? TREE_VALUE (a) : NULL_TREE;\n+\n       /* If the parameter is never assigned to, we may not need to\n \t create a new variable here at all.  Instead, we may be able\n \t to just use the argument value.  */\n       if (TREE_READONLY (p)\n \t  && !TREE_ADDRESSABLE (p)\n-\t  && !TREE_SIDE_EFFECTS (value))\n+\t  && value && !TREE_SIDE_EFFECTS (value))\n \t{\n \t  /* Simplify the value, if possible.  */\n-\t  value = fold (decl_constant_value (value));\n+\t  value = fold (DECL_P (value) ? decl_constant_value (value) : value);\n \n \t  /* We can't risk substituting complex expressions.  They\n \t     might contain variables that will be assigned to later.\n@@ -567,6 +569,23 @@ initialize_inlined_parameters (id, args, fn)\n \t}\n     }\n \n+  /* Evaluate trailing arguments.  */\n+  for (; a; a = TREE_CHAIN (a))\n+    {\n+      tree init_stmt;\n+      tree value;\n+\n+      /* Find the initializer.  */\n+      value = a ? TREE_VALUE (a) : NULL_TREE;\n+\n+      if (! value || ! TREE_SIDE_EFFECTS (value))\n+\tcontinue;\n+\n+      init_stmt = build_stmt (EXPR_STMT, value);\n+      TREE_CHAIN (init_stmt) = init_stmts;\n+      init_stmts = init_stmt;\n+    }\n+\n   /* The initialization statements have been built up in reverse\n      order.  Straighten them out now.  */\n   return nreverse (init_stmts);\n@@ -606,9 +625,15 @@ declare_return_variable (id, use_stmt)\n \t\t     (splay_tree_key) result,\n \t\t     (splay_tree_value) var);\n \n-  /* Build the USE_STMT.  */\n-  *use_stmt = build_stmt (EXPR_STMT, var);\n-\n+  /* Build the USE_STMT.  If the return type of the function was\n+     promoted, convert it back to the expected type.  */\n+  if (TREE_TYPE (var) == TREE_TYPE (TREE_TYPE (fn)))\n+    *use_stmt = build_stmt (EXPR_STMT, var);\n+  else\n+    *use_stmt = build_stmt (EXPR_STMT,\n+\t\t\t    build1 (NOP_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t\t    var));\n+      \n   /* Build the declaration statement if FN does not return an\n      aggregate.  */\n   if (need_return_decl)\n@@ -619,7 +644,18 @@ declare_return_variable (id, use_stmt)\n     return NULL_TREE;\n }\n \n-/* Returns non-zero if FN is a function that can be inlined.  */\n+/* Returns non-zero if a function can be inlined as a tree.  */\n+\n+int\n+tree_inlinable_function_p (fn)\n+     tree fn;\n+{\n+  return inlinable_function_p (fn, NULL);\n+}\n+\n+/* Returns non-zero if FN is a function that can be inlined into the\n+   inlining context ID_.  If ID_ is NULL, check whether the function\n+   can be inlined at all.  */\n \n static int\n inlinable_function_p (fn, id)\n@@ -637,11 +673,11 @@ inlinable_function_p (fn, id)\n   inlinable = 0;\n \n   /* If we're not inlining things, then nothing is inlinable.  */\n-  if (!flag_inline_trees)\n+  if (! flag_inline_trees)\n     ;\n-  /* If the function was not declared `inline', then we don't inline\n-     it.  */\n-  else if (!DECL_INLINE (fn))\n+  /* If we're not inlining all functions and the function was not\n+     declared `inline', we don't inline it.  */\n+  else if (flag_inline_trees < 2 && ! DECL_INLINE (fn))\n     ;\n   /* We can't inline functions that are too big.  Only allow a single\n      function to eat up half of our budget.  Make special allowance\n@@ -657,14 +693,14 @@ inlinable_function_p (fn, id)\n     inlinable = 1;\n \n   /* Squirrel away the result so that we don't have to check again.  */\n-  DECL_UNINLINABLE (fn) = !inlinable;\n+  DECL_UNINLINABLE (fn) = ! inlinable;\n \n   /* Even if this function is not itself too big to inline, it might\n      be that we've done so much inlining already that we don't want to\n      risk too much inlining any more and thus halve the acceptable\n      size.  */\n   if (! LANG_DISREGARD_INLINE_LIMITS (fn)\n-      && ((DECL_NUM_STMTS (fn) + id->inlined_stmts) * INSNS_PER_STMT\n+      && ((DECL_NUM_STMTS (fn) + (id ? id->inlined_stmts : 0)) * INSNS_PER_STMT\n \t  > MAX_INLINE_INSNS)\n       && DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 4)\n     inlinable = 0;\n@@ -674,7 +710,7 @@ inlinable_function_p (fn, id)\n   \n   /* If we don't have the function body available, we can't inline\n      it.  */\n-  if (!DECL_SAVED_TREE (fn))\n+  if (! DECL_SAVED_TREE (fn))\n     inlinable = 0;\n \n   /* Check again, language hooks may have modified it.  */\n@@ -683,15 +719,15 @@ inlinable_function_p (fn, id)\n \n   /* Don't do recursive inlining, either.  We don't record this in\n      DECL_UNINLINABLE; we may be able to inline this function later.  */\n-  if (inlinable)\n+  if (id)\n     {\n       size_t i;\n \n       for (i = 0; i < VARRAY_ACTIVE_SIZE (id->fns); ++i)\n \tif (VARRAY_TREE (id->fns, i) == fn)\n \t  return 0;\n \n-      if (inlinable && DECL_INLINED_FNS (fn))\n+      if (DECL_INLINED_FNS (fn))\n \t{\n \t  int j;\n \t  tree inlined_fns = DECL_INLINED_FNS (fn);"}, {"sha": "0f36148ab0bce32bc11c7083933d2b0b044053bf", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4838c5ee553f062d75d0a6288a025e98600de97c/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=4838c5ee553f062d75d0a6288a025e98600de97c", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n /* Function prototypes.  */\n \n void optimize_inline_calls PARAMS ((tree));\n+int tree_inlinable_function_p PARAMS ((tree));\n tree walk_tree PARAMS ((tree*, walk_tree_fn, void*, void*));\n tree walk_tree_without_duplicates PARAMS ((tree*, walk_tree_fn, void*));\n tree copy_tree_r PARAMS ((tree*, int*, void*));"}]}