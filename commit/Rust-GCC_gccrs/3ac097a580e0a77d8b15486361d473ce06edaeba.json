{"sha": "3ac097a580e0a77d8b15486361d473ce06edaeba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjMDk3YTU4MGUwYTc3ZDhiMTU0ODYzNjFkNDczY2UwNmVkYWViYQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2010-08-06T05:24:11Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2010-08-06T05:24:11Z"}, "message": "Enable build with microsoft compiler\n\nFrom-SVN: r162935", "tree": {"sha": "b3a7fdfbc35f7a3ff57eb7a4acc65d966fcb0eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3a7fdfbc35f7a3ff57eb7a4acc65d966fcb0eab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac097a580e0a77d8b15486361d473ce06edaeba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac097a580e0a77d8b15486361d473ce06edaeba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac097a580e0a77d8b15486361d473ce06edaeba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac097a580e0a77d8b15486361d473ce06edaeba/comments", "author": null, "committer": null, "parents": [{"sha": "fc28e435cfc4e6a0e34e1c351be49cb9921c3eac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc28e435cfc4e6a0e34e1c351be49cb9921c3eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc28e435cfc4e6a0e34e1c351be49cb9921c3eac"}], "stats": {"total": 716, "additions": 457, "deletions": 259}, "files": [{"sha": "9a0cb3cf92f776777ed1b81a765161ab1d141bbc", "filename": "libffi/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=3ac097a580e0a77d8b15486361d473ce06edaeba", "patch": "@@ -49,6 +49,29 @@\n \t* src/arm/sysv.S (__ARM_ARCH__): Define for processor\n \t__ARM_ARCH_7EM__.\n \n+2010-01-15  Anthony Green  <green@redhat.com>\n+\n+\t* README: Add notes on building with Microsoft Visual C++.\n+\n+2010-01-15  Daniel Witte  <dwitte@mozilla.com>\n+\n+\t* msvcc.sh: New file.\n+\n+\t* src/x86/win32.S: Port assembly routines to MSVC and #ifdef.\n+\t* src/x86/ffi.c: Tweak function declaration and remove excess\n+\tparens.\n+\t* include/ffi.h.in: Add __declspec(align(8)) to typedef struct\n+\tffi_closure.\n+\n+\t* src/x86/ffi.c: Merge ffi_call_SYSV and ffi_call_STDCALL into new\n+\tfunction ffi_call_win32 on X86_WIN32.\n+\t* src/x86/win32.S (ffi_call_SYSV): Rename to ffi_call_win32.\n+\t(ffi_call_STDCALL): Remove.\n+\n+\t* src/prep_cif.c (ffi_prep_cif): Move stack space allocation code\n+\tto ffi_prep_cif_machdep for x86.\n+\t* src/x86/ffi.c (ffi_prep_cif_machdep): To here.\n+\n 2010-01-15  Oliver Kiddle  <okiddle@yahoo.co.uk>\n \n \t* src/x86/ffitarget.h (ffi_abi): Check for __i386 and __amd64 for"}, {"sha": "285cc69a3f3ad3437b7b1790c25e698c2ed4990e", "filename": "libffi/README", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=3ac097a580e0a77d8b15486361d473ce06edaeba", "patch": "@@ -110,6 +110,14 @@ will add some extra code which will suppress certain warnings when you\n are using Purify with libffi. Only use this switch when using \n Purify, as it will slow down the library.\n \n+It's also possible to build libffi on Windows platforms with\n+Microsoft's Visual C++ compiler.  In this case, use the msvcc.sh\n+wrapper script during configuration like so:\n+\n+path/to/configure --enable-shared --enable-static \\\n+\tCC=path/to/msvcc.sh LD=link \\\n+\tCPP=\\\"cl -nologo -EP\\\"\n+\n Configure has many other options. Use \"configure --help\" to see them all.\n \n Once configure has finished, type \"make\". Note that you must be using\n@@ -126,6 +134,12 @@ History\n \n See the ChangeLog files for details.\n \n+3.0.10 ???-??-??\n+\tFix the N64 build on mips-sgi-irix6.5.\n+\tTestsuite fixes for Tru64 Unix.\n+\tEnable builds with Microsoft's compiler.\n+\tEnable x86 builds with Sun's compiler.\n+\n 3.0.9 Dec-31-09\n         Add AVR32 and win64 ports.  Add ARM softfp support.\n \tMany fixes for AIX, Solaris, HP-UX, *BSD."}, {"sha": "df7d2cd78b44ea06c5818403d2a52f048368451b", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=3ac097a580e0a77d8b15486361d473ce06edaeba", "patch": "@@ -251,6 +251,9 @@ size_t ffi_java_raw_size (ffi_cif *cif);\n \n #if FFI_CLOSURES\n \n+#ifdef _MSC_VER\n+__declspec(align(8))\n+#endif\n typedef struct {\n   char tramp[FFI_TRAMPOLINE_SIZE];\n   ffi_cif   *cif;"}, {"sha": "c1c3b9a6c864c6c5534723b839431354c95304ef", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=3ac097a580e0a77d8b15486361d473ce06edaeba", "patch": "@@ -109,15 +109,12 @@ ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n   /* Perform a sanity check on the return type */\n   FFI_ASSERT_VALID_TYPE(cif->rtype);\n \n-  /* x86-64 and s390 stack space allocation is handled in prep_machdep.  */\n-#if !defined M68K && !defined __x86_64__ && !defined S390 && !defined PA\n+  /* x86, x86-64 and s390 stack space allocation is handled in prep_machdep. */\n+#if !defined M68K && !defined __i386__ && !defined __x86_64__ && !defined S390 && !defined PA\n   /* Make space for the return structure pointer */\n   if (cif->rtype->type == FFI_TYPE_STRUCT\n #ifdef SPARC\n       && (cif->abi != FFI_V9 || cif->rtype->size > 32)\n-#endif\n-#ifdef X86_DARWIN\n-      && (cif->rtype->size > 8)\n #endif\n      )\n     bytes = STACK_ARG_SIZE(sizeof(void*));\n@@ -134,7 +131,7 @@ ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n \t check after the initialization.  */\n       FFI_ASSERT_VALID_TYPE(*ptr);\n \n-#if !defined __x86_64__ && !defined S390 && !defined PA\n+#if !defined __i386__ && !defined __x86_64__ && !defined S390 && !defined PA\n #ifdef SPARC\n       if (((*ptr)->type == FFI_TYPE_STRUCT\n \t   && ((*ptr)->size > 16 || cif->abi != FFI_V9))"}, {"sha": "d99528b11c7e60c2919d7a5c33897ebda3c03f8e", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 45, "deletions": 62, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=3ac097a580e0a77d8b15486361d473ce06edaeba", "patch": "@@ -148,13 +148,13 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n /* Perform machine dependent cif processing */\n ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n {\n+  unsigned int i;\n+  ffi_type **ptr;\n+\n   /* Set the return type flag */\n   switch (cif->rtype->type)\n     {\n     case FFI_TYPE_VOID:\n-#ifdef X86\n-    case FFI_TYPE_STRUCT:\n-#endif\n #if defined(X86) || defined (X86_WIN32) || defined(X86_FREEBSD) || defined(X86_DARWIN) || defined(X86_WIN64)\n     case FFI_TYPE_UINT8:\n     case FFI_TYPE_UINT16:\n@@ -165,7 +165,6 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     case FFI_TYPE_UINT32:\n     case FFI_TYPE_SINT32:\n #endif\n-\n     case FFI_TYPE_SINT64:\n     case FFI_TYPE_FLOAT:\n     case FFI_TYPE_DOUBLE:\n@@ -184,8 +183,8 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       cif->flags = FFI_TYPE_SINT64;\n       break;\n \n-#ifndef X86\n     case FFI_TYPE_STRUCT:\n+#ifndef X86\n       if (cif->rtype->size == 1)\n         {\n           cif->flags = FFI_TYPE_SMALL_STRUCT_1B; /* same as char size */\n@@ -207,15 +206,13 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n           cif->flags = FFI_TYPE_SINT64; /* same as int64 type */\n         }\n       else\n+#endif\n         {\n           cif->flags = FFI_TYPE_STRUCT;\n-#ifdef X86_WIN64\n           // allocate space for return value pointer\n           cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);\n-#endif\n         }\n       break;\n-#endif\n \n     default:\n #ifdef X86_WIN64\n@@ -229,41 +226,36 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       break;\n     }\n \n-#ifdef X86_DARWIN\n-  cif->bytes = (cif->bytes + 15) & ~0xF;\n-#endif\n+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n+    {\n+      if (((*ptr)->alignment - 1) & cif->bytes)\n+        cif->bytes = ALIGN(cif->bytes, (*ptr)->alignment);\n+      cif->bytes += ALIGN((*ptr)->size, FFI_SIZEOF_ARG);\n+    }\n \n #ifdef X86_WIN64\n-  {\n-    unsigned int i;\n-    ffi_type **ptr;\n-\n-    for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n-      {\n-        if (((*ptr)->alignment - 1) & cif->bytes)\n-          cif->bytes = ALIGN(cif->bytes, (*ptr)->alignment);\n-        cif->bytes += ALIGN((*ptr)->size, FFI_SIZEOF_ARG);\n-      }\n-  }\n   // ensure space for storing four registers\n   cif->bytes += 4 * sizeof(ffi_arg);\n #endif\n \n+#ifdef X86_DARWIN\n+  cif->bytes = (cif->bytes + 15) & ~0xF;\n+#endif\n+\n   return FFI_OK;\n }\n \n-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n-                          unsigned, unsigned, unsigned *, void (*fn)(void));\n-\n-#ifdef X86_WIN32\n-extern void ffi_call_STDCALL(void (*)(char *, extended_cif *), extended_cif *,\n-                          unsigned, unsigned, unsigned *, void (*fn)(void));\n-\n-#endif /* X86_WIN32 */\n #ifdef X86_WIN64\n extern int\n ffi_call_win64(void (*)(char *, extended_cif *), extended_cif *,\n                unsigned, unsigned, unsigned *, void (*fn)(void));\n+#elif defined(X86_WIN32)\n+extern void\n+ffi_call_win32(void (*)(char *, extended_cif *), extended_cif *,\n+               unsigned, unsigned, unsigned *, void (*fn)(void));\n+#else\n+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n+                          unsigned, unsigned, unsigned *, void (*fn)(void));\n #endif\n \n void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n@@ -321,18 +313,18 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n                        cif->flags, ecif.rvalue, fn);\n       }\n       break;\n+#elif defined(X86_WIN32)\n+    case FFI_SYSV:\n+    case FFI_STDCALL:\n+      ffi_call_win32(ffi_prep_args, &ecif, cif->bytes, cif->flags,\n+                     ecif.rvalue, fn);\n+      break;\n #else\n     case FFI_SYSV:\n       ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,\n                     fn);\n       break;\n-#ifdef X86_WIN32\n-    case FFI_STDCALL:\n-      ffi_call_STDCALL(ffi_prep_args, &ecif, cif->bytes, cif->flags,\n-                       ecif.rvalue, fn);\n-      break;\n-#endif /* X86_WIN32 */\n-#endif /* X86_WIN64 */\n+#endif\n     default:\n       FFI_ASSERT(0);\n       break;\n@@ -342,6 +334,8 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n \n /** private members **/\n \n+/* The following __attribute__((regparm(1))) decorations will have no effect\n+   on MSVC - standard cdecl convention applies. */\n static void ffi_prep_incoming_args_SYSV (char *stack, void **ret,\n                                          void** args, ffi_cif* cif);\n void FFI_HIDDEN ffi_closure_SYSV (ffi_closure *)\n@@ -390,11 +384,8 @@ ffi_closure_win64_inner (ffi_closure *closure, void *args) {\n }\n \n #else\n-unsigned int FFI_HIDDEN\n-ffi_closure_SYSV_inner (closure, respp, args)\n-     ffi_closure *closure;\n-     void **respp;\n-     void *args;\n+unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))\n+ffi_closure_SYSV_inner (ffi_closure *closure, void **respp, void *args)\n {\n   /* our various things...  */\n   ffi_cif       *cif;\n@@ -505,18 +496,18 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n /* How to make a trampoline.  Derived from gcc/config/i386/i386.c. */\n \n #define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX) \\\n-({ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n+{ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n    unsigned int  __fun = (unsigned int)(FUN); \\\n    unsigned int  __ctx = (unsigned int)(CTX); \\\n    unsigned int  __dis = __fun - (__ctx + 10);  \\\n    *(unsigned char*) &__tramp[0] = 0xb8; \\\n    *(unsigned int*)  &__tramp[1] = __ctx; /* movl __ctx, %eax */ \\\n    *(unsigned char *)  &__tramp[5] = 0xe9; \\\n    *(unsigned int*)  &__tramp[6] = __dis; /* jmp __fun  */ \\\n- })\n+ }\n \n #define FFI_INIT_TRAMPOLINE_STDCALL(TRAMP,FUN,CTX,SIZE)  \\\n-({ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n+{ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n    unsigned int  __fun = (unsigned int)(FUN); \\\n    unsigned int  __ctx = (unsigned int)(CTX); \\\n    unsigned int  __dis = __fun - (__ctx + 10); \\\n@@ -527,7 +518,7 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n    *(unsigned int*)  &__tramp[6] = __dis; /* call __fun  */ \\\n    *(unsigned char *)  &__tramp[10] = 0xc2; \\\n    *(unsigned short*)  &__tramp[11] = __size; /* ret __size  */ \\\n- })\n+ }\n \n /* the cif must already be prep'ed */\n \n@@ -627,16 +618,6 @@ ffi_prep_args_raw(char *stack, extended_cif *ecif)\n  * libffi-1.20, this is not the case.)\n  */\n \n-extern void\n-ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *, unsigned, \n-              unsigned, unsigned *, void (*fn)(void));\n-\n-#ifdef X86_WIN32\n-extern void\n-ffi_call_STDCALL(void (*)(char *, extended_cif *), extended_cif *, unsigned,\n-                 unsigned, unsigned *, void (*fn)(void));\n-#endif /* X86_WIN32 */\n-\n void\n ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n {\n@@ -660,16 +641,18 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n   \n   switch (cif->abi) \n     {\n+#ifdef X86_WIN32\n+    case FFI_SYSV:\n+    case FFI_STDCALL:\n+      ffi_call_win32(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n+                     ecif.rvalue, fn);\n+      break;\n+#else\n     case FFI_SYSV:\n       ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n                     ecif.rvalue, fn);\n       break;\n-#ifdef X86_WIN32\n-    case FFI_STDCALL:\n-      ffi_call_STDCALL(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n-                       ecif.rvalue, fn);\n-      break;\n-#endif /* X86_WIN32 */\n+#endif\n     default:\n       FFI_ASSERT(0);\n       break;"}, {"sha": "ac1ed6f942ab7a5a667bbab5bc9e3c0a176135d6", "filename": "libffi/src/x86/win32.S", "status": "modified", "additions": 369, "deletions": 191, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2Fsrc%2Fx86%2Fwin32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac097a580e0a77d8b15486361d473ce06edaeba/libffi%2Fsrc%2Fx86%2Fwin32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin32.S?ref=3ac097a580e0a77d8b15486361d473ce06edaeba", "patch": "@@ -2,6 +2,7 @@\n    win32.S - Copyright (c) 1996, 1998, 2001, 2002, 2009  Red Hat, Inc.\n \t     Copyright (c) 2001  John Beniton\n \t     Copyright (c) 2002  Ranjit Mathew\n+\t     Copyright (c) 2009  Daniel Witte\n \t\t\t\n  \n    X86 Foreign Function Interface\n@@ -31,14 +32,371 @@\n #define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n- \n+\n+#ifdef _MSC_VER\n+\n+.386\n+.MODEL FLAT, C\n+\n+EXTRN ffi_closure_SYSV_inner:NEAR\n+\n+_TEXT SEGMENT\n+\n+ffi_call_win32 PROC NEAR,\n+    ffi_prep_args : NEAR PTR DWORD,\n+    ecif          : NEAR PTR DWORD,\n+    cif_bytes     : DWORD,\n+    cif_flags     : DWORD,\n+    rvalue        : NEAR PTR DWORD,\n+    fn            : NEAR PTR DWORD\n+\n+        ;; Make room for all of the new args.\n+        mov  ecx, cif_bytes\n+        sub  esp, ecx\n+\n+        mov  eax, esp\n+\n+        ;; Place all of the ffi_prep_args in position\n+        push ecif\n+        push eax\n+        call ffi_prep_args\n+\n+        ;; Return stack to previous state and call the function\n+        add  esp, 8\n+\n+        call fn\n+\n+        ;; cdecl:   we restore esp in the epilogue, so there's no need to\n+        ;;          remove the space we pushed for the args.\n+        ;; stdcall: the callee has already cleaned the stack.\n+\n+        ;; Load ecx with the return type code\n+        mov  ecx, cif_flags\n+\n+        ;; If the return value pointer is NULL, assume no return value.\n+        cmp  rvalue, 0\n+        jne  ca_jumptable\n+\n+        ;; Even if there is no space for the return value, we are\n+        ;; obliged to handle floating-point values.\n+        cmp  ecx, FFI_TYPE_FLOAT\n+        jne  ca_epilogue\n+        fstp st(0)\n+\n+        jmp  ca_epilogue\n+\n+ca_jumptable:\n+        jmp  [ca_jumpdata + 4 * ecx]\n+ca_jumpdata:\n+        ;; Do not insert anything here between label and jump table.\n+        dd offset ca_epilogue       ;; FFI_TYPE_VOID\n+        dd offset ca_retint         ;; FFI_TYPE_INT\n+        dd offset ca_retfloat       ;; FFI_TYPE_FLOAT\n+        dd offset ca_retdouble      ;; FFI_TYPE_DOUBLE\n+        dd offset ca_retlongdouble  ;; FFI_TYPE_LONGDOUBLE\n+        dd offset ca_retint8        ;; FFI_TYPE_UINT8\n+        dd offset ca_retint8        ;; FFI_TYPE_SINT8\n+        dd offset ca_retint16       ;; FFI_TYPE_UINT16\n+        dd offset ca_retint16       ;; FFI_TYPE_SINT16\n+        dd offset ca_retint         ;; FFI_TYPE_UINT32\n+        dd offset ca_retint         ;; FFI_TYPE_SINT32\n+        dd offset ca_retint64       ;; FFI_TYPE_UINT64\n+        dd offset ca_retint64       ;; FFI_TYPE_SINT64\n+        dd offset ca_epilogue       ;; FFI_TYPE_STRUCT\n+        dd offset ca_retint         ;; FFI_TYPE_POINTER\n+        dd offset ca_retint8        ;; FFI_TYPE_SMALL_STRUCT_1B\n+        dd offset ca_retint16       ;; FFI_TYPE_SMALL_STRUCT_2B\n+        dd offset ca_retint         ;; FFI_TYPE_SMALL_STRUCT_4B\n+\n+ca_retint8:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        mov   [ecx + 0], al\n+        jmp   ca_epilogue\n+\n+ca_retint16:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        mov   [ecx + 0], ax\n+        jmp   ca_epilogue\n+\n+ca_retint:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        mov   [ecx + 0], eax\n+        jmp   ca_epilogue\n+\n+ca_retint64:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        mov   [ecx + 0], eax\n+        mov   [ecx + 4], edx\n+        jmp   ca_epilogue\n+\n+ca_retfloat:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        fstp  DWORD PTR [ecx]\n+        jmp   ca_epilogue\n+\n+ca_retdouble:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        fstp  QWORD PTR [ecx]\n+        jmp   ca_epilogue\n+\n+ca_retlongdouble:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        fstp  TBYTE PTR [ecx]\n+        jmp   ca_epilogue\n+\n+ca_epilogue:\n+        ;; Epilogue code is autogenerated.\n+        ret\n+ffi_call_win32 ENDP\n+\n+ffi_closure_SYSV PROC NEAR FORCEFRAME\n+    ;; the ffi_closure ctx is passed in eax by the trampoline.\n+\n+        sub  esp, 40\n+        lea  edx, [ebp - 24]\n+        mov  [ebp - 12], edx         ;; resp\n+        lea  edx, [ebp + 8]\n+        mov  [esp + 8], edx          ;; args\n+        lea  edx, [ebp - 12]\n+        mov  [esp + 4], edx          ;; &resp\n+        mov  [esp], eax              ;; closure\n+        call ffi_closure_SYSV_inner\n+        mov  ecx, [ebp - 12]\n+\n+cs_jumptable:\n+        jmp  [cs_jumpdata + 4 * eax]\n+cs_jumpdata:\n+        ;; Do not insert anything here between the label and jump table.\n+        dd offset cs_epilogue       ;; FFI_TYPE_VOID\n+        dd offset cs_retint         ;; FFI_TYPE_INT\n+        dd offset cs_retfloat       ;; FFI_TYPE_FLOAT\n+        dd offset cs_retdouble      ;; FFI_TYPE_DOUBLE\n+        dd offset cs_retlongdouble  ;; FFI_TYPE_LONGDOUBLE\n+        dd offset cs_retint8        ;; FFI_TYPE_UINT8\n+        dd offset cs_retint8        ;; FFI_TYPE_SINT8\n+        dd offset cs_retint16       ;; FFI_TYPE_UINT16\n+        dd offset cs_retint16       ;; FFI_TYPE_SINT16\n+        dd offset cs_retint         ;; FFI_TYPE_UINT32\n+        dd offset cs_retint         ;; FFI_TYPE_SINT32\n+        dd offset cs_retint64       ;; FFI_TYPE_UINT64\n+        dd offset cs_retint64       ;; FFI_TYPE_SINT64\n+        dd offset cs_retstruct      ;; FFI_TYPE_STRUCT\n+        dd offset cs_retint         ;; FFI_TYPE_POINTER\n+        dd offset cs_retint8        ;; FFI_TYPE_SMALL_STRUCT_1B\n+        dd offset cs_retint16       ;; FFI_TYPE_SMALL_STRUCT_2B\n+        dd offset cs_retint         ;; FFI_TYPE_SMALL_STRUCT_4B\n+\n+cs_retint8:\n+        mov   al, [ecx]\n+        jmp   cs_epilogue\n+\n+cs_retint16:\n+        mov   ax, [ecx]\n+        jmp   cs_epilogue\n+\n+cs_retint:\n+        mov   eax, [ecx]\n+        jmp   cs_epilogue\n+\n+cs_retint64:\n+        mov   eax, [ecx + 0]\n+        mov   edx, [ecx + 4]\n+        jmp   cs_epilogue\n+\n+cs_retfloat:\n+        fld   DWORD PTR [ecx]\n+        jmp   cs_epilogue\n+\n+cs_retdouble:\n+        fld   QWORD PTR [ecx]\n+        jmp   cs_epilogue\n+\n+cs_retlongdouble:\n+        fld   TBYTE PTR [ecx]\n+        jmp   cs_epilogue\n+\n+cs_retstruct:\n+        ;; Caller expects us to pop struct return value pointer hidden arg.\n+        ;; Epilogue code is autogenerated.\n+        ret\t4\n+\n+cs_epilogue:\n+        ;; Epilogue code is autogenerated.\n+        ret\n+ffi_closure_SYSV ENDP\n+\n+#if !FFI_NO_RAW_API\n+\n+#define RAW_CLOSURE_CIF_OFFSET ((FFI_TRAMPOLINE_SIZE + 3) AND NOT 3)\n+#define RAW_CLOSURE_FUN_OFFSET (RAW_CLOSURE_CIF_OFFSET + 4)\n+#define RAW_CLOSURE_USER_DATA_OFFSET (RAW_CLOSURE_FUN_OFFSET + 4)\n+#define CIF_FLAGS_OFFSET 20\n+\n+ffi_closure_raw_SYSV PROC NEAR USES esi\n+    ;; the ffi_closure ctx is passed in eax by the trampoline.\n+\n+        sub  esp, 40\n+        mov  esi, [eax + RAW_CLOSURE_CIF_OFFSET]        ;; closure->cif\n+        mov  edx, [eax + RAW_CLOSURE_USER_DATA_OFFSET]  ;; closure->user_data\n+        mov  [esp + 12], edx                            ;; user_data\n+        lea  edx, [ebp + 8]\n+        mov  [esp + 8], edx                             ;; raw_args\n+        lea  edx, [ebp - 24]\n+        mov  [esp + 4], edx                             ;; &res\n+        mov  [esp], esi                                 ;; cif\n+        call DWORD PTR [eax + RAW_CLOSURE_FUN_OFFSET]   ;; closure->fun\n+        mov  eax, [esi + CIF_FLAGS_OFFSET]              ;; cif->flags\n+        lea  ecx, [ebp - 24]\n+\n+cr_jumptable:\n+        jmp  [cr_jumpdata + 4 * eax]\n+cr_jumpdata:\n+        ;; Do not insert anything here between the label and jump table.\n+        dd offset cr_epilogue       ;; FFI_TYPE_VOID\n+        dd offset cr_retint         ;; FFI_TYPE_INT\n+        dd offset cr_retfloat       ;; FFI_TYPE_FLOAT\n+        dd offset cr_retdouble      ;; FFI_TYPE_DOUBLE\n+        dd offset cr_retlongdouble  ;; FFI_TYPE_LONGDOUBLE\n+        dd offset cr_retint8        ;; FFI_TYPE_UINT8\n+        dd offset cr_retint8        ;; FFI_TYPE_SINT8\n+        dd offset cr_retint16       ;; FFI_TYPE_UINT16\n+        dd offset cr_retint16       ;; FFI_TYPE_SINT16\n+        dd offset cr_retint         ;; FFI_TYPE_UINT32\n+        dd offset cr_retint         ;; FFI_TYPE_SINT32\n+        dd offset cr_retint64       ;; FFI_TYPE_UINT64\n+        dd offset cr_retint64       ;; FFI_TYPE_SINT64\n+        dd offset cr_epilogue       ;; FFI_TYPE_STRUCT\n+        dd offset cr_retint         ;; FFI_TYPE_POINTER\n+        dd offset cr_retint8        ;; FFI_TYPE_SMALL_STRUCT_1B\n+        dd offset cr_retint16       ;; FFI_TYPE_SMALL_STRUCT_2B\n+        dd offset cr_retint         ;; FFI_TYPE_SMALL_STRUCT_4B\n+\n+cr_retint8:\n+        mov   al, [ecx]\n+        jmp   cr_epilogue\n+\n+cr_retint16:\n+        mov   ax, [ecx]\n+        jmp   cr_epilogue\n+\n+cr_retint:\n+        mov   eax, [ecx]\n+        jmp   cr_epilogue\n+\n+cr_retint64:\n+        mov   eax, [ecx + 0]\n+        mov   edx, [ecx + 4]\n+        jmp   cr_epilogue\n+\n+cr_retfloat:\n+        fld   DWORD PTR [ecx]\n+        jmp   cr_epilogue\n+\n+cr_retdouble:\n+        fld   QWORD PTR [ecx]\n+        jmp   cr_epilogue\n+\n+cr_retlongdouble:\n+        fld   TBYTE PTR [ecx]\n+        jmp   cr_epilogue\n+\n+cr_epilogue:\n+        ;; Epilogue code is autogenerated.\n+        ret\n+ffi_closure_raw_SYSV ENDP\n+\n+#endif /* !FFI_NO_RAW_API */\n+\n+ffi_closure_STDCALL PROC NEAR FORCEFRAME\n+    ;; the ffi_closure ctx is passed in eax by the trampoline.\n+\n+        sub  esp, 40\n+        lea  edx, [ebp - 24]\n+        mov  [ebp - 12], edx         ;; resp\n+        lea  edx, [ebp + 12]         ;; account for stub return address on stack\n+        mov  [esp + 8], edx          ;; args\n+        lea  edx, [ebp - 12]\n+        mov  [esp + 4], edx          ;; &resp\n+        mov  [esp], eax              ;; closure\n+        call ffi_closure_SYSV_inner\n+        mov  ecx, [ebp - 12]\n+\n+cd_jumptable:\n+        jmp  [cd_jumpdata + 4 * eax]\n+cd_jumpdata:\n+        ;; Do not insert anything here between the label and jump table.\n+        dd offset cd_epilogue       ;; FFI_TYPE_VOID\n+        dd offset cd_retint         ;; FFI_TYPE_INT\n+        dd offset cd_retfloat       ;; FFI_TYPE_FLOAT\n+        dd offset cd_retdouble      ;; FFI_TYPE_DOUBLE\n+        dd offset cd_retlongdouble  ;; FFI_TYPE_LONGDOUBLE\n+        dd offset cd_retint8        ;; FFI_TYPE_UINT8\n+        dd offset cd_retint8        ;; FFI_TYPE_SINT8\n+        dd offset cd_retint16       ;; FFI_TYPE_UINT16\n+        dd offset cd_retint16       ;; FFI_TYPE_SINT16\n+        dd offset cd_retint         ;; FFI_TYPE_UINT32\n+        dd offset cd_retint         ;; FFI_TYPE_SINT32\n+        dd offset cd_retint64       ;; FFI_TYPE_UINT64\n+        dd offset cd_retint64       ;; FFI_TYPE_SINT64\n+        dd offset cd_epilogue       ;; FFI_TYPE_STRUCT\n+        dd offset cd_retint         ;; FFI_TYPE_POINTER\n+        dd offset cd_retint8        ;; FFI_TYPE_SMALL_STRUCT_1B\n+        dd offset cd_retint16       ;; FFI_TYPE_SMALL_STRUCT_2B\n+        dd offset cd_retint         ;; FFI_TYPE_SMALL_STRUCT_4B\n+\n+cd_retint8:\n+        mov   al, [ecx]\n+        jmp   cd_epilogue\n+\n+cd_retint16:\n+        mov   ax, [ecx]\n+        jmp   cd_epilogue\n+\n+cd_retint:\n+        mov   eax, [ecx]\n+        jmp   cd_epilogue\n+\n+cd_retint64:\n+        mov   eax, [ecx + 0]\n+        mov   edx, [ecx + 4]\n+        jmp   cd_epilogue\n+\n+cd_retfloat:\n+        fld   DWORD PTR [ecx]\n+        jmp   cd_epilogue\n+\n+cd_retdouble:\n+        fld   QWORD PTR [ecx]\n+        jmp   cd_epilogue\n+\n+cd_retlongdouble:\n+        fld   TBYTE PTR [ecx]\n+        jmp   cd_epilogue\n+\n+cd_epilogue:\n+        ;; Epilogue code is autogenerated.\n+        ret\n+ffi_closure_STDCALL ENDP\n+\n+_TEXT ENDS\n+END\n+\n+#else\n+\n \t.text\n  \n         # This assumes we are using gas.\n         .balign 16\n-\t.globl\t_ffi_call_SYSV\n-\t.def\t_ffi_call_SYSV;\t.scl\t2;\t.type\t32;\t.endef\n-_ffi_call_SYSV:\n+\t.globl\t_ffi_call_win32\n+\t.def\t_ffi_call_win32;\t.scl\t2;\t.type\t32;\t.endef\n+_ffi_call_win32:\n .LFB1:\n         pushl %ebp\n .LCFI0:\n@@ -61,8 +419,10 @@ _ffi_call_SYSV:\n         # FIXME: Align the stack to a 128-bit boundary to avoid\n         # potential performance hits.\n \n-\tcall  *28(%ebp)\n+        call  *28(%ebp)\n  \n+        # stdcall functions pop arguments off the stack themselves\n+\n         # Load %ecx with the return type code\n         movl  20(%ebp),%ecx\n  \n@@ -181,162 +541,9 @@ _ffi_call_SYSV:\n         movl %ebp,%esp\n         popl %ebp\n         ret\n-.ffi_call_SYSV_end:\n+.ffi_call_win32_end:\n .LFE1:\n \n-        # This assumes we are using gas.\n-        .balign 16\n-\t.globl\t_ffi_call_STDCALL\n-\t.def\t_ffi_call_STDCALL;\t.scl\t2;\t.type\t32;\t.endef\n-_ffi_call_STDCALL:\n-.LFB2:\n-        pushl %ebp\n-.LCFI2:\n-        movl  %esp,%ebp\n-.LCFI3:\n-        # Make room for all of the new args.\n-        movl  16(%ebp),%ecx \n-        subl  %ecx,%esp\n-\n-        movl  %esp,%eax\n-\n-        # Place all of the ffi_prep_args in position\n-        pushl 12(%ebp)\n-        pushl %eax\n-        call  *8(%ebp)\n-\n-        # Return stack to previous state and call the function\n-        addl  $8,%esp\n-\n-        # FIXME: Align the stack to a 128-bit boundary to avoid\n-        # potential performance hits.\n-\n-        call  *28(%ebp)\n-\n-        # stdcall functions pop arguments off the stack themselves\n-\n-        # Load %ecx with the return type code\n-        movl  20(%ebp),%ecx\n-\n-        # If the return value pointer is NULL, assume no return value.\n-        cmpl  $0,24(%ebp)\n-        jne   0f\n-\n-        # Even if there is no space for the return value, we are\n-        # obliged to handle floating-point values.\n-        cmpl  $FFI_TYPE_FLOAT,%ecx\n-        jne   .Lsc_noretval\n-        fstp  %st(0)\n-\n-        jmp   .Lsc_epilogue\n-\n-0:\n-\tcall\t1f\n-\t# Do not insert anything here between the call and the jump table.\n-.Lsc_store_table:\n-\t.long\t.Lsc_noretval\t\t/* FFI_TYPE_VOID */\n-\t.long\t.Lsc_retint\t\t/* FFI_TYPE_INT */\n-\t.long\t.Lsc_retfloat\t\t/* FFI_TYPE_FLOAT */\n-\t.long\t.Lsc_retdouble\t\t/* FFI_TYPE_DOUBLE */\n-\t.long\t.Lsc_retlongdouble\t/* FFI_TYPE_LONGDOUBLE */\n-\t.long\t.Lsc_retuint8\t\t/* FFI_TYPE_UINT8 */\n-\t.long\t.Lsc_retsint8\t\t/* FFI_TYPE_SINT8 */\n-\t.long\t.Lsc_retuint16\t\t/* FFI_TYPE_UINT16 */\n-\t.long\t.Lsc_retsint16\t\t/* FFI_TYPE_SINT16 */\n-\t.long\t.Lsc_retint\t\t/* FFI_TYPE_UINT32 */\n-\t.long\t.Lsc_retint\t\t/* FFI_TYPE_SINT32 */\n-\t.long\t.Lsc_retint64\t\t/* FFI_TYPE_UINT64 */\n-\t.long\t.Lsc_retint64\t\t/* FFI_TYPE_SINT64 */\n-\t.long\t.Lsc_retstruct\t\t/* FFI_TYPE_STRUCT */\n-\t.long\t.Lsc_retint\t\t/* FFI_TYPE_POINTER */\n-\t.long\t.Lsc_retstruct1b\t/* FFI_TYPE_SMALL_STRUCT_1B */\n-\t.long\t.Lsc_retstruct2b\t/* FFI_TYPE_SMALL_STRUCT_2B */\n-\t.long\t.Lsc_retstruct4b\t/* FFI_TYPE_SMALL_STRUCT_4B */\n-\n-1:\n-\tadd\t%ecx, %ecx\n-\tadd\t%ecx, %ecx\n-\tadd\t(%esp),%ecx\n-\tadd\t$4, %esp\n-\tjmp\t*(%ecx)\n-\n-\t/* Sign/zero extend as appropriate.  */\n-.Lsc_retsint8:\n-\tmovsbl\t%al, %eax\n-\tjmp\t.Lsc_retint\n-\n-.Lsc_retsint16:\n-\tmovswl\t%ax, %eax\n-\tjmp\t.Lsc_retint\n-\n-.Lsc_retuint8:\n-\tmovzbl\t%al, %eax\n-\tjmp\t.Lsc_retint\n-\n-.Lsc_retuint16:\n-\tmovzwl\t%ax, %eax\n-\tjmp\t.Lsc_retint\n-\n-.Lsc_retint:\n-        # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n-        movl  %eax,0(%ecx)\n-        jmp   .Lsc_epilogue\n-\n-.Lsc_retfloat:\n-         # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n-        fstps (%ecx)\n-        jmp   .Lsc_epilogue\n-\n-.Lsc_retdouble:\n-        # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n-        fstpl (%ecx)\n-        jmp   .Lsc_epilogue\n-\n-.Lsc_retlongdouble:\n-        # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n-        fstpt (%ecx)\n-        jmp   .Lsc_epilogue\n-\n-.Lsc_retint64:\n-        # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n-        movl  %eax,0(%ecx)\n-        movl  %edx,4(%ecx)\n-\tjmp   .Lsc_epilogue\n-\n-.Lsc_retstruct1b:\n-        # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n-        movb  %al,0(%ecx)\n-        jmp   .Lsc_epilogue\n-\n-.Lsc_retstruct2b:\n-        # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n-        movw  %ax,0(%ecx)\n-        jmp   .Lsc_epilogue\n-\n-.Lsc_retstruct4b:\n-        # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n-        movl  %eax,0(%ecx)\n-        jmp   .Lsc_epilogue\n-\n-.Lsc_retstruct:\n-        # Nothing to do!\n-\n-.Lsc_noretval:\n-.Lsc_epilogue:\n-        movl %ebp,%esp\n-        popl %ebp\n-        ret\n-.ffi_call_STDCALL_end:\n-.LFE2:\n-\n         # This assumes we are using gas.\n         .balign 16\n \t.globl\t_ffi_closure_SYSV\n@@ -742,38 +949,6 @@ _ffi_closure_STDCALL:\n .LEFDE1:\n \n \n-.LSFDE2:\n-\t.long\t.LEFDE2-.LASFDE2\t/* FDE Length */\n-.LASFDE2:\n-\t.long\t.LASFDE2-.Lframe1\t/* FDE CIE offset */\n-#if defined __PIC__ && defined HAVE_AS_X86_PCREL\n-\t.long\t.LFB2-.\t/* FDE initial location */\n-#else\n-\t.long\t.LFB2\n-#endif\n-\t.long\t.LFE2-.LFB2\t/* FDE address range */\n-#ifdef __PIC__\n-\t.byte\t0x0\t/* .uleb128 0x0; Augmentation size */\n-#endif\n-\t/* DW_CFA_xxx CFI instructions go here.  */\n-\n-\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI2-.LFB2\n-\t.byte\t0xe\t/* DW_CFA_def_cfa_offset CFA = r4 + 8 = 8(%esp) */\n-\t.byte\t0x8\t/* .uleb128 0x8 */\n-\t.byte\t0x85\t/* DW_CFA_offset, column 0x5 %ebp at CFA + 2 * -4 */\n-\t.byte\t0x2\t/* .uleb128 0x2 */\n-\n-\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI3-.LCFI2\n-\t.byte\t0xd\t/* DW_CFA_def_cfa_register CFA = r5 = %ebp */\n-\t.byte\t0x5\t/* .uleb128 0x5 */\n-\n-\t/* End of DW_CFA_xxx CFI instructions.  */\n-\t.align 4\n-.LEFDE2:\n-\n-\n .LSFDE3:\n \t.long\t.LEFDE3-.LASFDE3\t/* FDE Length */\n .LASFDE3:\n@@ -875,3 +1050,6 @@ _ffi_closure_STDCALL:\n \t/* End of DW_CFA_xxx CFI instructions.  */\n \t.align 4\n .LEFDE5:\n+\n+#endif /* !_MSC_VER */\n+"}]}