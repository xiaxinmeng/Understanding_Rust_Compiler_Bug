{"sha": "67f279dfebbb2690ebf57246e27794e6b18fdae9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmMjc5ZGZlYmJiMjY5MGViZjU3MjQ2ZTI3Nzk0ZTZiMThmZGFlOQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-10-30T09:20:47Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-10-30T09:20:47Z"}, "message": "Reader.java: Merge docs from classpath.\n\n\t* java/io/Reader.java: Merge docs from classpath.\n\t(skip): Synchronize on `lock'.\n\t* java/io/FileReader.java: Import correct implementation from\n\tclasspath.\n\t* java/io/StringReader.java: Merge docs from classpath.\n\t(ready): Throw IOException if stream is closed.\n\nFrom-SVN: r37143", "tree": {"sha": "09e926cc492d72e2c29199d598d208b1b42f6456", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09e926cc492d72e2c29199d598d208b1b42f6456"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67f279dfebbb2690ebf57246e27794e6b18fdae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f279dfebbb2690ebf57246e27794e6b18fdae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f279dfebbb2690ebf57246e27794e6b18fdae9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f279dfebbb2690ebf57246e27794e6b18fdae9/comments", "author": null, "committer": null, "parents": [{"sha": "b1628585d32f0b437830e47bac983e753de6d047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1628585d32f0b437830e47bac983e753de6d047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1628585d32f0b437830e47bac983e753de6d047"}], "stats": {"total": 348, "additions": 299, "deletions": 49}, "files": [{"sha": "a1b3d5c944b370e6baa04f24ed2d27a211dfa7ff", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f279dfebbb2690ebf57246e27794e6b18fdae9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f279dfebbb2690ebf57246e27794e6b18fdae9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=67f279dfebbb2690ebf57246e27794e6b18fdae9", "patch": "@@ -2,6 +2,13 @@\n \n \t* java/util/BitSet.java: Updated @specnote.\n \n+\t* java/io/Reader.java: Merge docs from classpath.\n+\t(skip): Synchronize on `lock'.\n+\t* java/io/FileReader.java: Import correct implementation from \n+\tclasspath.\n+\t* java/io/StringReader.java: Merge docs from classpath.\n+\t(ready): Throw IOException if stream is closed.\n+\n 2000-10-29  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/util/AbstractCollection.java (addAll): Use size() instead of"}, {"sha": "0dbcd0e07c73719afd53e6af287a8e95a7175ede", "filename": "libjava/java/io/FileReader.java", "status": "modified", "additions": 64, "deletions": 17, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f279dfebbb2690ebf57246e27794e6b18fdae9/libjava%2Fjava%2Fio%2FFileReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f279dfebbb2690ebf57246e27794e6b18fdae9/libjava%2Fjava%2Fio%2FFileReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileReader.java?ref=67f279dfebbb2690ebf57246e27794e6b18fdae9", "patch": "@@ -1,35 +1,82 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* FileReader.java -- Convenience class for reading characters from a file\n+   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.io;\n \n /**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date April 22, 1998.  \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition.\n- * Status:  Believed complete and correct.\n+ * This class provides a convenient way to set up a <code>Reader</code>\n+ * to read from a file.  It opens the specified file for reading and creates\n+ * the <code>InputStreamReader</code> to read from the \n+ * resulting <code>FileInputStream</code>.  This class can only be used\n+ * to read from files using the default character encoding.  Use\n+ * <code>InputStreamReader</code> directly to use a non-default encoding.\n+ *\n+ * @version 0.0\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  */\n-\n public class FileReader extends InputStreamReader\n {\n-  public FileReader(String filename) throws IOException\n-  {\n-    super(new FileInputStream(filename));\n-  }\n-\n-  public FileReader(File file) throws IOException\n+  /**\n+   * This method initializes a <code>FileReader</code> instance to read from\n+   * the specified <code>File</code> object.\n+   *\n+   * @param file The <code>File</code> object representing the file to read from\n+   *\n+   * @exception FileNotFoundException If the file is not found or some other \n+   *            error occurs\n+   */\n+  public FileReader(File file) throws FileNotFoundException\n   {\n     super(new FileInputStream(file));\n   }\n \n+  /**\n+   * This method initializes a <code>FileReader</code> instance to read from\n+   * this specified <code>FileDescriptor</code> object.\n+   *\n+   * @param fd The <code>FileDescriptor</code> to read from.\n+   */\n   public FileReader(FileDescriptor fd)\n   {\n     super(new FileInputStream(fd));\n   }\n+\n+  /**\n+   * This method initializes a <code>FileReader</code> instance to read from\n+   * the specified named file.\n+   *\n+   * @param name The name of the file to read from\n+   *\n+   * @exception FileNotFoundException If the file is not found or some other \n+   *            error occurs\n+   */\n+  public FileReader(String name) throws FileNotFoundException\n+  {\n+    super(new FileInputStream(name));\n+  }\n }"}, {"sha": "e8329d604fddb12063aecd9772d76b1bd71ad57a", "filename": "libjava/java/io/Reader.java", "status": "modified", "additions": 171, "deletions": 17, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f279dfebbb2690ebf57246e27794e6b18fdae9/libjava%2Fjava%2Fio%2FReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f279dfebbb2690ebf57246e27794e6b18fdae9/libjava%2Fjava%2Fio%2FReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FReader.java?ref=67f279dfebbb2690ebf57246e27794e6b18fdae9", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -7,81 +7,235 @@\n details.  */\n  \n package java.io;\n-\n-/**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date April 21, 1998.  \n- */\n+ \n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n \n+/**\n+ * This abstract class forms the base of the hierarchy of classes that read\n+ * input as a stream of characters.  It provides a common set of methods for\n+ * reading characters from streams.  Subclasses implement and extend these\n+ * methods to read characters from a particular input source such as a file\n+ * or network connection.\n+ *\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 21, 1998.  \n+ * @author Aaron M. Renn (arenn@urbanophile.com) \n+ */\n public abstract class Reader\n {\n+  /**\n+   * This is the <code>Object</code> used for synchronizing critical code\n+   * sections.  Subclasses should use this variable instead of a \n+   * synchronized method or an explicit synchronization on <code>this</code>\n+   */\n   protected Object lock;\n-\n+  \n+  /**\n+    * Unitializes a <code>Reader</code> that will use the object\n+    * itself for synchronization of critical code sections.\n+    */\n   protected Reader()\n   {\n     this.lock = this;\n   }\n \n+  /**\n+    * Initializes a <code>Reader</code> that will use the specified\n+    * <code>Object</code> for synchronization of critical code sections.\n+    *\n+    * @param lock The <code>Object</code> to use for synchronization\n+    */\n   protected Reader(Object lock)\n   {\n     this.lock = lock;\n   }\n \n-  abstract public int read(char buf[], int offset, int count)\n+  /**\n+   * Read chars from a stream and stores them into a caller\n+   * supplied buffer.  It starts storing the data at index <code>offset</code> \n+   * into the buffer and attempts to read <code>len</code> chars.  This method \n+   * can return before reading the number of chars requested.  The actual \n+   * number of chars read is returned as an int.  A -1 is returned to indicate \n+   * the end of the stream.\n+   * <p>\n+   * This method will block until some data can be read.\n+   * <p>\n+   * This method operates by calling the single char <code>read()</code> method\n+   * in a loop until the desired number of chars are read.  The read loop\n+   * stops short if the end of the stream is encountered or if an IOException\n+   * is encountered on any read operation except the first.  If the first\n+   * attempt to read a chars fails, the IOException is allowed to propagate\n+   * upward.  And subsequent IOException is caught and treated identically\n+   * to an end of stream condition.  Subclasses can (and should if possible)\n+   * override this method to provide a more efficient implementation.\n+   *\n+   * @param buf The array into which the chars read should be stored\n+   * @param offset The offset into the array to start storing chars\n+   * @param len The requested number of chars to read\n+   *\n+   * @return The actual number of chars read, or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public abstract int read(char buf[], int offset, int count)\n     throws IOException;\n-\n+    \n+  /**\n+   * Reads chars from a stream and stores them into a caller\n+   * supplied buffer.  This method attempts to completely fill the buffer,\n+   * but can return before doing so.  The actual number of chars read is\n+   * returned as an int.  A -1 is returned to indicate the end of the stream.\n+   * <p>\n+   * This method will block until some data can be read.\n+   * <p>\n+   * This method operates by calling an overloaded read method like so:\n+   * <code>read(buf, 0, buf.length)</code>\n+   *\n+   * @param buf The buffer into which the chars read will be stored.\n+   *\n+   * @return The number of chars read or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public int read(char buf[]) throws IOException\n   {\n     return read(buf, 0, buf.length);\n   }\n \n+  /**\n+   * Reads an char from the input stream and returns it\n+   * as an int in the range of 0-65535.  This method also will return -1 if\n+   * the end of the stream has been reached.\n+   * <p>\n+   * This method will block until the char can be read.\n+   *\n+   * @return The char read or -1 if end of stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int read() throws IOException\n   {\n     char[] buf = new char[1];\n     int count = read(buf, 0, 1);\n     return count > 0 ? buf[0] : -1;\n   }\n \n-  abstract public void close() throws IOException;\n+  /**\n+   * Closes the stream.  Any futher attempts to read from the\n+   * stream may generate an <code>IOException</code>.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public abstract void close() throws IOException;\n \n+  /**\n+   * Returns a boolean that indicates whether the mark/reset\n+   * methods are supported in this class.  Those methods can be used to\n+   * remember a specific point in the stream and reset the stream to that\n+   * point.\n+   * <p>\n+   * This method always returns <code>false</code> in this class, but\n+   * subclasses can override this method to return <code>true</code> if they \n+   * support mark/reset functionality.\n+   *\n+   * @return <code>true</code> if mark/reset functionality is supported, \n+   *         <code>false</code> otherwise\n+   *\n+   */\n   public boolean markSupported()\n   {\n     return false;\n   }\n \n+  /**\n+    * Marks a position in the input to which the stream can be\n+    * \"reset\" by calling the <code>reset()</code> method.  The parameter\n+    * <code>readlimit</code> is the number of chars that can be read from the \n+    * stream after setting the mark before the mark becomes invalid.  For\n+    * example, if <code>mark()</code> is called with a read limit of 10, then \n+    * when 11 chars of data are read from the stream before the \n+    * <code>reset()</code> method is called, then the mark is invalid and the \n+    * stream object instance is not required to remember the mark.\n+    *\n+    * @param readlimit The number of chars that can be read before the mark \n+    *        becomes invalid\n+    *\n+    * @exception IOException If an error occurs such as mark not being \n+    *            supported for this class\n+    */\n   public void mark(int readLimit) throws IOException\n   {\n     throw new IOException(\"mark not supported\");\n   }\n \n+  /**\n+    * Resets a stream to the point where the <code>mark()</code> \n+    * method was called.  Any chars that were read after the mark point was \n+    * set will be re-read during subsequent reads.\n+    * <p>\n+    * This method always throws an IOException in this class, but subclasses\n+    * can override this method if they provide mark/reset functionality.\n+    *\n+    * @exception IOException Always thrown for this class\n+    */\n   public void reset() throws IOException\n   {\n     throw new IOException(\"reset not supported\");\n   }\n \n+  /**\n+    * Determines whether or not this stream is ready to be\n+    * read.  If it returns <code>false</code> the stream may block if a\n+    * read is attempted, but it is not guaranteed to do so.\n+    * <p>\n+    * This method always returns <code>false</code> in this class\n+    *\n+    * @return <code>true</code> if the stream is ready to be read, <code>false</code> otherwise.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public boolean ready() throws IOException\n   {\n     return false;\n   }\n \n+  /**\n+    * Skips the specified number of chars in the stream.  It\n+    * returns the actual number of chars skipped, which may be less than the\n+    * requested amount.\n+    * <p>\n+    * This method reads and discards chars into a 256 char array until the\n+    * specified number of chars were skipped or until either the end of stream\n+    * is reached or a read attempt returns a short count.  Subclasses can\n+    * override this method to provide a more efficient implementation where\n+    * one exists.\n+    *\n+    * @param num_chars The requested number of chars to skip\n+    *\n+    * @return The actual number of chars skipped.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public long skip(long count) throws IOException\n   {\n     if (count <= 0)\n       return 0;\n     int bsize = count > 1024 ? 1024 : (int) count;\n     char[] buffer = new char[bsize];\n     long todo = count;\n-    while (todo > 0)\n-      {\n-\tint skipped = read(buffer, 0, bsize > todo ? (int) todo : bsize);\n-\tif (skipped <= 0)\n-\t  break;\n-\ttodo -= skipped;\n-      }\n+    synchronized (lock)\n+    {\n+      while (todo > 0)\n+\t{\n+\t  int skipped = read(buffer, 0, bsize > todo ? (int) todo : bsize);\n+\t  if (skipped <= 0)\n+\t    break;\n+\t  todo -= skipped;\n+\t}\n+    }\n     return count - todo;\n   }\n }"}, {"sha": "66d37325a4ca124ba3675bdcd10c568d01be9570", "filename": "libjava/java/io/StringReader.java", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f279dfebbb2690ebf57246e27794e6b18fdae9/libjava%2Fjava%2Fio%2FStringReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f279dfebbb2690ebf57246e27794e6b18fdae9/libjava%2Fjava%2Fio%2FStringReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStringReader.java?ref=67f279dfebbb2690ebf57246e27794e6b18fdae9", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -8,16 +8,26 @@\n  \n package java.io;\n \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 19, 1998.  \n- */\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct\n  */\n- \n+\n+/**\n+ * This class permits a <code>String</code> to be read as a character \n+ * input stream.\n+ * <p>\n+ * The mark/reset functionality in this class behaves differently than\n+ * normal.  If no mark has been set, then calling the <code>reset()</code>\n+ * method rewinds the read pointer to the beginning of the <code>String</code>.\n+ *\n+ * @version 0.0\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 19, 1998.  \n+ */\n public class StringReader extends Reader\n {\n   /* A String provided by the creator of the stream. */\n@@ -32,6 +42,13 @@ public class StringReader extends Reader\n   /* The index in buf one greater than the last valid character. */\n   private int count;\n \n+  /**\n+   * Create a new <code>StringReader</code> that will read chars from the \n+   * passed in <code>String</code>.  This stream will read from the beginning to the \n+   * end of the <code>String</code>.\n+   *\n+   * @param s The <code>String</code> this stream will read from.\n+   */\n   public StringReader(String buffer)\n   {\n     super();\n@@ -54,7 +71,7 @@ public void mark(int readAheadLimit) throws IOException\n     synchronized (lock)\n     {\n       if (buf == null)\n-        throw new IOException();\n+        throw new IOException(\"Stream closed\");\n \n       // readAheadLimit is ignored per Java Class Lib. book, p. 1692.\n       markedPos = pos;\n@@ -71,7 +88,7 @@ public int read() throws IOException\n     synchronized (lock)\n     {\n       if (buf == null)\n-        throw new IOException();\n+        throw new IOException(\"Stream closed\");\n \n       if (pos < count)\n         return ((int) buf.charAt(pos++)) & 0xFFFF;\n@@ -84,7 +101,7 @@ public int read(char[] b, int off, int len) throws IOException\n     synchronized (lock)\n     {\n       if (buf == null)\n-        throw new IOException();\n+        throw new IOException(\"Stream closed\");\n \n       /* Don't need to check pos value, arraycopy will check it. */\n       if (off < 0 || len < 0 || off + len > b.length)\n@@ -101,31 +118,56 @@ public int read(char[] b, int off, int len) throws IOException\n     }\n   }\n \n-  public boolean ready() // TODO12: throws IOException\n+  /**\n+   * This method determines if the stream is ready to be read.  This class\n+   * is always ready to read and so always returns <code>true</code>, unless\n+   * close() has previously been called in which case an IOException is\n+   * thrown.\n+   *\n+   * @return <code>true</code> to indicate that this object is ready to be read.\n+   * @exception IOException If the stream is closed.\n+   */\n+  public boolean ready() throws IOException\n   {\n-    // TODO12: The JCL specifically says this returns true even if the\n-    // reader has been closed, whereas the online 1.2 doc specifically\n-    // says to throw an IOException if closed.\n+    if (buf == null)\n+      throw new IOException(\"Stream closed\");\n+\n     return true;\n   }\n \n+  /**\n+   * Sets the read position in the stream to the previously\n+   * marked position or to 0 (i.e., the beginning of the stream) if the mark\n+   * has not already been set.\n+   */\n   public void reset() throws IOException\n   {\n     synchronized (lock)\n     {\n       if (buf == null)\n-        throw new IOException();\n+        throw new IOException(\"Stream closed\");\n \n       pos = markedPos;\n     }\n   }\n \n+  /**\n+    * This method attempts to skip the requested number of chars in the\n+    * input stream.  It does this by advancing the <code>pos</code> value by \n+    * the specified number of chars.  It this would exceed the length of the\n+    * buffer, then only enough chars are skipped to position the stream at\n+    * the end of the buffer.  The actual number of chars skipped is returned.\n+    *\n+    * @param num_chars The requested number of chars to skip\n+    *\n+    * @return The actual number of chars skipped.\n+    */\n   public long skip(long n) throws IOException\n   {\n     synchronized (lock)\n     {\n       if (buf == null)\n-        throw new IOException();\n+        throw new IOException(\"Stream closed\");\n \n       // Even though the var numChars is a long, in reality it can never\n       // be larger than an int since the result of subtracting 2 positive"}]}