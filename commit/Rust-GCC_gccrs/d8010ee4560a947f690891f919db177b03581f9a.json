{"sha": "d8010ee4560a947f690891f919db177b03581f9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwMTBlZTQ1NjBhOTQ3ZjY5MDg5MWY5MTlkYjE3N2IwMzU4MWY5YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-11-08T15:28:20Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-11-08T15:28:20Z"}, "message": "dump_printf: add \"%C\" for dumping cgraph_node *\n\nThis patch implements support for %C in dump_printf for dumping\ncgraph_node *.\n(I would have preferred to have a code for printing symtab_node *\nand both subclasses, but there doesn't seem to be a good way for\n-Wformat to handle inheritance, so, failing that, I went with\nthis approach).\n\ngcc/c-family/ChangeLog:\n\t* c-format.c (local_cgraph_node_ptr_node): New variable.\n\t(gcc_dump_printf_char_table): Add entry for %C.\n\t(get_pointer_to_named_type): New function, taken from the handling\n\tcode for \"gimple *\" from...\n\t(init_dynamic_diag_info): ...here.  Add handling for\n\t\"cgraph_node *\".\n\t* c-format.h (T_CGRAPH_NODE): New.\n\ngcc/ChangeLog:\n\t* dump-context.h (ASSERT_IS_CGRAPH_NODE): New macro.\n\t* dumpfile.c (make_item_for_dump_cgraph_node): Move to before...\n\t(dump_pretty_printer::decode_format): Implement \"%C\" for\n\tcgraph_node *.\n\t(selftest::test_capture_of_dump_calls): Rename \"where\" to\n\t\"stmt_loc\".  Convert test_decl to a function decl and set its\n\tlocation.  Add a symbol_table_test RAII instance and a\n\tcgraph_node, using it to test \"%C\" and dump_symtab_node.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/format/gcc_diag-10.c (cgraph_node): New typedef.\n\t(test_dump): Add testing of %C.\n\nFrom-SVN: r265918", "tree": {"sha": "c6bb3ddeba0c95c166a971951e837fb414559832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6bb3ddeba0c95c166a971951e837fb414559832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8010ee4560a947f690891f919db177b03581f9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8010ee4560a947f690891f919db177b03581f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8010ee4560a947f690891f919db177b03581f9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8010ee4560a947f690891f919db177b03581f9a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66"}], "stats": {"total": 211, "additions": 161, "deletions": 50}, "files": [{"sha": "0ebab865cee11b47f7440623d1eb1390be26730c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8010ee4560a947f690891f919db177b03581f9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8010ee4560a947f690891f919db177b03581f9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8010ee4560a947f690891f919db177b03581f9a", "patch": "@@ -1,3 +1,14 @@\n+2018-11-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dump-context.h (ASSERT_IS_CGRAPH_NODE): New macro.\n+\t* dumpfile.c (make_item_for_dump_cgraph_node): Move to before...\n+\t(dump_pretty_printer::decode_format): Implement \"%C\" for\n+\tcgraph_node *.\n+\t(selftest::test_capture_of_dump_calls): Rename \"where\" to\n+\t\"stmt_loc\".  Convert test_decl to a function decl and set its\n+\tlocation.  Add a symbol_table_test RAII instance and a\n+\tcgraph_node, using it to test \"%C\" and dump_symtab_node.\n+\n 2018-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/87916"}, {"sha": "11978713ee26ecb1a87d73feff2c4a27f3149552", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d8010ee4560a947f690891f919db177b03581f9a", "patch": "@@ -1,3 +1,13 @@\n+2018-11-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-format.c (local_cgraph_node_ptr_node): New variable.\n+\t(gcc_dump_printf_char_table): Add entry for %C.\n+\t(get_pointer_to_named_type): New function, taken from the handling\n+\tcode for \"gimple *\" from...\n+\t(init_dynamic_diag_info): ...here.  Add handling for\n+\t\"cgraph_node *\".\n+\t* c-format.h (T_CGRAPH_NODE): New.\n+\n 2018-10-19  Jason Merrill  <jason@redhat.com>\n \n \t* c-cppbuiltin.c (c_cpp_builtins): Add"}, {"sha": "c8ae6c40275bad3ce2fbccb30850cf8333a47bae", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=d8010ee4560a947f690891f919db177b03581f9a", "patch": "@@ -60,6 +60,7 @@ struct function_format_info\n /* Initialized in init_dynamic_diag_info.  */\n static GTY(()) tree local_tree_type_node;\n static GTY(()) tree local_gimple_ptr_node;\n+static GTY(()) tree local_cgraph_node_ptr_node;\n static GTY(()) tree locus;\n \n static bool decode_format_attr (tree, function_format_info *, int);\n@@ -803,6 +804,9 @@ static const format_char_info gcc_dump_printf_char_table[] =\n   /* E and G require a \"gimple *\" argument at runtime.  */\n   { \"EG\",   1, STD_C89, { T89_G,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\", \"\\\"\",   NULL },\n \n+  /* C requires a \"cgraph_node *\" argument at runtime.  */\n+  { \"C\",   1, STD_C89, { T_CGRAPH_NODE,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\", \"\\\"\",   NULL },\n+\n   /* T requires a \"tree\" at runtime.  */\n   { \"T\",   1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\", \"\\\"\",   NULL },\n \n@@ -3882,6 +3886,33 @@ init_dynamic_gfc_info (void)\n     }\n }\n \n+/* Lookup the type named NAME and return a pointer-to-NAME type if found.\n+   Otherwise, return void_type_node if NAME has not been used yet, or NULL_TREE if\n+   NAME is not a type (issuing an error).  */\n+\n+static tree\n+get_pointer_to_named_type (const char *name)\n+{\n+  tree result;\n+  if ((result = maybe_get_identifier (name)))\n+    {\n+      result = identifier_global_value (result);\n+      if (result)\n+\t{\n+\t  if (TREE_CODE (result) != TYPE_DECL)\n+\t    {\n+\t      error (\"%qs is not defined as a type\", name);\n+\t      result = NULL_TREE;\n+\t    }\n+\t  else\n+\t    result = TREE_TYPE (result);\n+\t}\n+    }\n+  else\n+    result = void_type_node;\n+  return result;\n+}\n+\n /* Determine the types of \"tree\" and \"location_t\" in the code being\n    compiled for use in GCC's diagnostic custom format attributes.  You\n    must have set dynamic_format_types before calling this function.  */\n@@ -3935,25 +3966,12 @@ init_dynamic_diag_info (void)\n   /* Similar to the above but for gimple*.  */\n   if (!local_gimple_ptr_node\n       || local_gimple_ptr_node == void_type_node)\n-    {\n-      if ((local_gimple_ptr_node = maybe_get_identifier (\"gimple\")))\n-\t{\n-\t  local_gimple_ptr_node\n-\t    = identifier_global_value (local_gimple_ptr_node);\n-\t  if (local_gimple_ptr_node)\n-\t    {\n-\t      if (TREE_CODE (local_gimple_ptr_node) != TYPE_DECL)\n-\t\t{\n-\t\t  error (\"%<gimple%> is not defined as a type\");\n-\t\t  local_gimple_ptr_node = 0;\n-\t\t}\n-\t      else\n-\t\tlocal_gimple_ptr_node = TREE_TYPE (local_gimple_ptr_node);\n-\t    }\n-\t}\n-      else\n-\tlocal_gimple_ptr_node = void_type_node;\n-    }\n+    local_gimple_ptr_node = get_pointer_to_named_type (\"gimple\");\n+\n+  /* Similar to the above but for cgraph_node*.  */\n+  if (!local_cgraph_node_ptr_node\n+      || local_cgraph_node_ptr_node == void_type_node)\n+    local_cgraph_node_ptr_node = get_pointer_to_named_type (\"cgraph_node\");\n \n   static tree hwi;\n "}, {"sha": "eabb4f02f1512b0bdebb7f26d71a0a759fcd36b4", "filename": "gcc/c-family/c-format.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fc-family%2Fc-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fc-family%2Fc-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.h?ref=d8010ee4560a947f690891f919db177b03581f9a", "patch": "@@ -299,6 +299,7 @@ struct format_kind_info\n #define T99_UC\t{ STD_C99, NULL, T_UC }\n #define T_V\t&void_type_node\n #define T89_G   { STD_C89, NULL, &local_gimple_ptr_node }\n+#define T_CGRAPH_NODE   { STD_C89, NULL, &local_cgraph_node_ptr_node }\n #define T89_T   { STD_C89, NULL, &local_tree_type_node }\n #define T89_V\t{ STD_C89, NULL, T_V }\n #define T_W\t&wchar_type_node"}, {"sha": "ace139cdc09c10ce523356813abeac11f072521e", "filename": "gcc/dump-context.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fdump-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fdump-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdump-context.h?ref=d8010ee4560a947f690891f919db177b03581f9a", "patch": "@@ -251,6 +251,14 @@ verify_item (const location &loc,\n \t\t (EXPECTED_LOCATION), (EXPECTED_TEXT));\t    \\\n   SELFTEST_END_STMT\n \n+/* Verify that ITEM is a symtab node, with the expected values.  */\n+\n+#define ASSERT_IS_SYMTAB_NODE(ITEM, EXPECTED_LOCATION, EXPECTED_TEXT) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n+    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_SYMTAB_NODE, \\\n+\t\t (EXPECTED_LOCATION), (EXPECTED_TEXT));\t    \\\n+  SELFTEST_END_STMT\n+\n } // namespace selftest\n \n #endif /* CHECKING_P */"}, {"sha": "09c24905f52a76afee56d50dc63a1e8c22ae51c4", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 86, "deletions": 29, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=d8010ee4560a947f690891f919db177b03581f9a", "patch": "@@ -748,6 +748,18 @@ dump_context::dump_generic_expr_loc (dump_flags_t dump_kind,\n   dump_generic_expr (dump_kind, extra_dump_flags, t);\n }\n \n+/* Make an item for the given dump call.  */\n+\n+static optinfo_item *\n+make_item_for_dump_symtab_node (symtab_node *node)\n+{\n+  location_t loc = DECL_SOURCE_LOCATION (node->decl);\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_SYMTAB_NODE, loc,\n+\t\t\txstrdup (node->dump_name ()));\n+  return item;\n+}\n+\n /* dump_pretty_printer's ctor.  */\n \n dump_pretty_printer::dump_pretty_printer (dump_context *context,\n@@ -881,14 +893,18 @@ dump_pretty_printer::format_decoder_cb (pretty_printer *pp, text_info *text,\n    Supported format codes (in addition to the standard pretty_printer ones)\n    are:\n \n+   %C: cgraph_node *:\n+       Equivalent to: dump_symtab_node (MSG_*, node)\n    %E: gimple *:\n        Equivalent to: dump_gimple_expr (MSG_*, TDF_SLIM, stmt, 0)\n    %G: gimple *:\n        Equivalent to: dump_gimple_stmt (MSG_*, TDF_SLIM, stmt, 0)\n    %T: tree:\n        Equivalent to: dump_generic_expr (MSG_*, arg, TDF_SLIM).\n \n-   FIXME: add symtab_node?\n+   TODO: add a format code that can handle (symtab_node*) *and* both\n+   subclasses (presumably means teaching -Wformat about non-virtual\n+   subclasses).\n \n    These format codes build optinfo_item instances, thus capturing metadata\n    about the arguments being dumped, as well as the textual output.  */\n@@ -901,6 +917,16 @@ dump_pretty_printer::decode_format (text_info *text, const char *spec,\n      for later use (to capture metadata, rather than plain text).  */\n   switch (*spec)\n     {\n+    case 'C':\n+      {\n+\tcgraph_node *node = va_arg (*text->args_ptr, cgraph_node *);\n+\n+\t/* Make an item for the node, and stash it.  */\n+\toptinfo_item *item = make_item_for_dump_symtab_node (node);\n+\tstash_item (buffer_ptr, item);\n+\treturn true;\n+      }\n+\n     case 'E':\n       {\n \tgimple *stmt = va_arg (*text->args_ptr, gimple *);\n@@ -1023,18 +1049,6 @@ dump_context::dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n     delete item;\n }\n \n-/* Make an item for the given dump call.  */\n-\n-static optinfo_item *\n-make_item_for_dump_symtab_node (symtab_node *node)\n-{\n-  location_t loc = DECL_SOURCE_LOCATION (node->decl);\n-  optinfo_item *item\n-    = new optinfo_item (OPTINFO_ITEM_KIND_SYMTAB_NODE, loc,\n-\t\t\txstrdup (node->dump_name ()));\n-  return item;\n-}\n-\n /* Output the name of NODE on appropriate dump streams.  */\n \n void\n@@ -2067,18 +2081,26 @@ test_capture_of_dump_calls (const line_table_case &case_)\n   linemap_add (line_table, LC_ENTER, false, \"test.txt\", 0);\n   linemap_line_start (line_table, 5, 100);\n   linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n-  location_t where = linemap_position_for_column (line_table, 10);\n-  if (where > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+  location_t decl_loc = linemap_position_for_column (line_table, 8);\n+  location_t stmt_loc = linemap_position_for_column (line_table, 10);\n+  if (stmt_loc > LINE_MAP_MAX_LOCATION_WITH_COLS)\n     return;\n \n-  dump_location_t loc = dump_location_t::from_location_t (where);\n+  dump_location_t loc = dump_location_t::from_location_t (stmt_loc);\n \n   gimple *stmt = gimple_build_return (NULL);\n-  gimple_set_location (stmt, where);\n+  gimple_set_location (stmt, stmt_loc);\n \n-  tree test_decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+  tree test_decl = build_decl (decl_loc, FUNCTION_DECL,\n \t\t\t       get_identifier (\"test_decl\"),\n-\t\t\t       integer_type_node);\n+\t\t\t       build_function_type_list (void_type_node,\n+\t\t\t\t\t\t\t NULL_TREE));\n+\n+  symbol_table_test tmp_symtab;\n+\n+  cgraph_node *node = cgraph_node::get_create (test_decl);\n+  gcc_assert (node);\n+\n   /* Run all tests twice, with and then without optinfo enabled, to ensure\n      that immediate destinations vs optinfo-based destinations both\n      work, independently of each other, with no leaks.  */\n@@ -2135,7 +2157,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n \t    ASSERT_EQ (info->num_items (), 2);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"gimple: \");\n-\t    ASSERT_IS_GIMPLE (info->get_item (1), where, \"return;\");\n+\t    ASSERT_IS_GIMPLE (info->get_item (1), stmt_loc, \"return;\");\n \t  }\n       }\n \n@@ -2153,7 +2175,25 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n \t    ASSERT_EQ (info->num_items (), 2);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"gimple: \");\n-\t    ASSERT_IS_GIMPLE (info->get_item (1), where, \"return;\\n\");\n+\t    ASSERT_IS_GIMPLE (info->get_item (1), stmt_loc, \"return;\\n\");\n+\t  }\n+      }\n+\n+      /* Test of dump_printf with %C.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, true,\n+\t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n+\tdump_printf (MSG_NOTE, \"node: %C\", node);\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"node: test_decl/0\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 2);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"node: \");\n+\t    ASSERT_IS_SYMTAB_NODE (info->get_item (1), decl_loc, \"test_decl/0\");\n \t  }\n       }\n \n@@ -2184,8 +2224,8 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_IS_TEXT (info->get_item (2), \" and \");\n \t    ASSERT_IS_TREE (info->get_item (3), UNKNOWN_LOCATION, \"test_decl\");\n \t    ASSERT_IS_TEXT (info->get_item (4), \" 42 consecutive \");\n-\t    ASSERT_IS_GIMPLE (info->get_item (5), where, \"return;\");\n-\t    ASSERT_IS_GIMPLE (info->get_item (6), where, \"return;\");\n+\t    ASSERT_IS_GIMPLE (info->get_item (5), stmt_loc, \"return;\");\n+\t    ASSERT_IS_GIMPLE (info->get_item (6), stmt_loc, \"return;\");\n \t    ASSERT_IS_TEXT (info->get_item (7), \" after\\n\");\n \t  }\n       }\n@@ -2202,7 +2242,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t  {\n \t    optinfo *info = tmp.get_pending_optinfo ();\n \t    ASSERT_TRUE (info != NULL);\n-\t    ASSERT_EQ (info->get_location_t (), where);\n+\t    ASSERT_EQ (info->get_location_t (), stmt_loc);\n \t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n \t    ASSERT_EQ (info->num_items (), 2);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"test of tree: \");\n@@ -2221,7 +2261,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t  {\n \t    optinfo *info = tmp.get_pending_optinfo ();\n \t    ASSERT_TRUE (info != NULL);\n-\t    ASSERT_EQ (info->get_location_t (), where);\n+\t    ASSERT_EQ (info->get_location_t (), stmt_loc);\n \t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n \t    ASSERT_EQ (info->num_items (), 1);\n \t    ASSERT_IS_TREE (info->get_item (0), UNKNOWN_LOCATION, \"1\");\n@@ -2242,7 +2282,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      optinfo *info = tmp.get_pending_optinfo ();\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n-\t      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\\n\");\n+\t      ASSERT_IS_GIMPLE (info->get_item (0), stmt_loc, \"return;\\n\");\n \t    }\n \t}\n \n@@ -2258,7 +2298,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      optinfo *info = tmp.get_pending_optinfo ();\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n-\t      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\\n\");\n+\t      ASSERT_IS_GIMPLE (info->get_item (0), stmt_loc, \"return;\\n\");\n \t    }\n \t}\n \n@@ -2274,7 +2314,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      optinfo *info = tmp.get_pending_optinfo ();\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n-\t      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\");\n+\t      ASSERT_IS_GIMPLE (info->get_item (0), stmt_loc, \"return;\");\n \t    }\n \t}\n \n@@ -2290,11 +2330,28 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      optinfo *info = tmp.get_pending_optinfo ();\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n-\t      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\");\n+\t      ASSERT_IS_GIMPLE (info->get_item (0), stmt_loc, \"return;\");\n \t    }\n \t}\n       }\n \n+      /* symtab_node.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, true,\n+\t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n+\tdump_symtab_node (MSG_NOTE, node);\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"test_decl/0\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 1);\n+\t    ASSERT_IS_SYMTAB_NODE (info->get_item (0), decl_loc, \"test_decl/0\");\n+\t  }\n+      }\n+\n       /* poly_int.  */\n       {\n \ttemp_dump_context tmp (with_optinfo, true,"}, {"sha": "1799cb58ffb8db364daa13b45df7df31da28a819", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d8010ee4560a947f690891f919db177b03581f9a", "patch": "@@ -1,3 +1,8 @@\n+2018-11-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/format/gcc_diag-10.c (cgraph_node): New typedef.\n+\t(test_dump): Add testing of %C.\n+\n 2018-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* g++.dg/other/pr87916.C: New test."}, {"sha": "97a1993dc8fad453944cc92c75f11bfa74590952", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-10.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8010ee4560a947f690891f919db177b03581f9a/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c?ref=d8010ee4560a947f690891f919db177b03581f9a", "patch": "@@ -20,7 +20,7 @@ typedef union tree_node *tree;\n typedef struct gimple gimple;\n \n /* Likewise for gimple.  */\n-typedef struct gimple gimple;\n+typedef struct cgraph_node cgraph_node;\n \n #define FORMAT(kind) __attribute__ ((format (__gcc_## kind ##__, 1, 2)))\n \n@@ -162,7 +162,7 @@ void test_cxxdiag (tree t, gimple *gc)\n   cxxdiag (\"%<%X%>\", t);\n }\n \n-void test_dump (tree t, gimple *stmt)\n+void test_dump (tree t, gimple *stmt, cgraph_node *node)\n {\n   dump (\"%<\");   /* { dg-warning \"unterminated quoting directive\" } */\n   dump (\"%>\");   /* { dg-warning \"unmatched quoting directive \" } */\n@@ -182,4 +182,5 @@ void test_dump (tree t, gimple *stmt)\n   dump (\"%E\", stmt);\n   dump (\"%T\", t);\n   dump (\"%G\", stmt);\n+  dump (\"%C\", node);\n }"}]}