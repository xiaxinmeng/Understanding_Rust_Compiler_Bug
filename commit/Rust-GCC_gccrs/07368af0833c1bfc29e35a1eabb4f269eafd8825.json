{"sha": "07368af0833c1bfc29e35a1eabb4f269eafd8825", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDczNjhhZjA4MzNjMWJmYzI5ZTM1YTFlYWJiNGYyNjllYWZkODgyNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-08-30T22:10:55Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-08-30T22:10:55Z"}, "message": "re PR fortran/31879 (ICE with function having array of character variables argument)\n\n2007-08-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31879\n\tPR fortran/31197\n\tPR fortran/31258\n\tPR fortran/32703\n\t* gfortran.h : Add prototype for gfc_resolve_substring_charlen.\n\t* resolve.c (gfc_resolve_substring_charlen): New function.\n\t(resolve_ref): Call gfc_resolve_substring_charlen.\n\t(gfc_resolve_character_operator): New function.\n\t(gfc_resolve_expr): Call the new functions in cases where the\n\tcharacter length is missing.\n\t* iresolve.c (cshift, eoshift, merge, pack, reshape, spread,\n\ttranspose, unpack): Call gfc_resolve_substring_charlen for\n\tsource expressions that are character and have a reference.\n\t* trans.h (gfc_trans_init_string_length) Change name to\n\tgfc_conv_string_length; modify references in trans-expr.c,\n\ttrans-array.c and trans-decl.c.\n\t* trans-expr.c (gfc_trans_string_length): Handle case of no\n\tbackend_decl.\n\t(gfc_conv_aliased_arg): Remove code for treating substrings\n\tand replace with call to gfc_trans_string_length.\n\t* trans-array.c (gfc_conv_expr_descriptor): Remove code for\n\ttreating strings and call gfc_trans_string_length instead.\n\n2007-08-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31879\n\t* gfortran.dg/char_length_7.f90: New test.\n\t* gfortran.dg/char_length_9.f90: New test.\n\t* gfortran.dg/char_assign_1.f90: Add extra warning.\n\n\tPR fortran/31197\n\tPR fortran/31258\n\t* gfortran.dg/char_length_8.f90: New test.\n\nFrom-SVN: r127939", "tree": {"sha": "4d0ce764a2da2a85fc1156dfef15707121d08af7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d0ce764a2da2a85fc1156dfef15707121d08af7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07368af0833c1bfc29e35a1eabb4f269eafd8825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07368af0833c1bfc29e35a1eabb4f269eafd8825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07368af0833c1bfc29e35a1eabb4f269eafd8825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07368af0833c1bfc29e35a1eabb4f269eafd8825/comments", "author": null, "committer": null, "parents": [{"sha": "54b0bc0008d05bb93fd3b1608c616299724fc942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54b0bc0008d05bb93fd3b1608c616299724fc942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54b0bc0008d05bb93fd3b1608c616299724fc942"}], "stats": {"total": 476, "additions": 364, "deletions": 112}, "files": [{"sha": "ecbb76776fd6f2acbcd4974fbfaa37ff314f12c1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -1,3 +1,28 @@\n+2007-08-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31879\n+\tPR fortran/31197\n+\tPR fortran/31258\n+\tPR fortran/32703\n+\t* gfortran.h : Add prototype for gfc_resolve_substring_charlen.\n+\t* resolve.c (gfc_resolve_substring_charlen): New function.\n+\t(resolve_ref): Call gfc_resolve_substring_charlen.\n+\t(gfc_resolve_character_operator): New function.\n+\t(gfc_resolve_expr): Call the new functions in cases where the\n+\tcharacter length is missing.\n+\t* iresolve.c (cshift, eoshift, merge, pack, reshape, spread,\n+\ttranspose, unpack): Call gfc_resolve_substring_charlen for\n+\tsource expressions that are character and have a reference.\n+\t* trans.h (gfc_trans_init_string_length) Change name to\n+\tgfc_conv_string_length; modify references in trans-expr.c,\n+\ttrans-array.c and trans-decl.c.\n+\t* trans-expr.c (gfc_trans_string_length): Handle case of no\n+\tbackend_decl.\n+\t(gfc_conv_aliased_arg): Remove code for treating substrings\n+\tand replace with call to gfc_trans_string_length.\n+\t* trans-array.c (gfc_conv_expr_descriptor): Remove code for\n+\ttreating strings and call gfc_trans_string_length instead.\n+\n 2007-08-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/33228"}, {"sha": "5c8c56dd6adbaf146b70b8408f1afc9c7078c9db", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -2267,6 +2267,7 @@ try gfc_resolve_iterator (gfc_iterator *, bool);\n try gfc_resolve_index (gfc_expr *, int);\n try gfc_resolve_dim_arg (gfc_expr *);\n int gfc_is_formal_arg (void);\n+void gfc_resolve_substring_charlen (gfc_expr *);\n match gfc_iso_c_sub_interface(gfc_code *, gfc_symbol *);\n \n "}, {"sha": "38da76be71aed0daf4e036f5dd85f67b1a16b375", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -534,6 +534,9 @@ gfc_resolve_cshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n {\n   int n;\n \n+  if (array->ts.type == BT_CHARACTER && array->ref)\n+    gfc_resolve_substring_charlen (array);\n+\n   f->ts = array->ts;\n   f->rank = array->rank;\n   f->shape = gfc_copy_shape (array->shape, array->rank);\n@@ -654,6 +657,9 @@ gfc_resolve_eoshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n {\n   int n;\n \n+  if (array->ts.type == BT_CHARACTER && array->ref)\n+    gfc_resolve_substring_charlen (array);\n+\n   f->ts = array->ts;\n   f->rank = array->rank;\n   f->shape = gfc_copy_shape (array->shape, array->rank);\n@@ -1382,6 +1388,12 @@ gfc_resolve_merge (gfc_expr *f, gfc_expr *tsource,\n \t\t   gfc_expr *fsource ATTRIBUTE_UNUSED,\n \t\t   gfc_expr *mask ATTRIBUTE_UNUSED)\n {\n+  if (tsource->ts.type == BT_CHARACTER && tsource->ref)\n+    gfc_resolve_substring_charlen (tsource);\n+\n+  if (fsource->ts.type == BT_CHARACTER && fsource->ref)\n+    gfc_resolve_substring_charlen (fsource);\n+\n   if (tsource->ts.type == BT_CHARACTER)\n     check_charlen_present (tsource);\n \n@@ -1590,6 +1602,9 @@ void\n gfc_resolve_pack (gfc_expr *f, gfc_expr *array, gfc_expr *mask,\n \t\t  gfc_expr *vector ATTRIBUTE_UNUSED)\n {\n+  if (array->ts.type == BT_CHARACTER && array->ref)\n+    gfc_resolve_substring_charlen (array);\n+\n   f->ts = array->ts;\n   f->rank = 1;\n \n@@ -1693,6 +1708,9 @@ gfc_resolve_reshape (gfc_expr *f, gfc_expr *source, gfc_expr *shape,\n   int kind;\n   int i;\n \n+  if (source->ts.type == BT_CHARACTER && source->ref)\n+    gfc_resolve_substring_charlen (source);\n+\n   f->ts = source->ts;\n \n   gfc_array_size (shape, &rank);\n@@ -1984,6 +2002,9 @@ void\n gfc_resolve_spread (gfc_expr *f, gfc_expr *source, gfc_expr *dim,\n \t\t    gfc_expr *ncopies)\n {\n+  if (source->ts.type == BT_CHARACTER && source->ref)\n+    gfc_resolve_substring_charlen (source);\n+\n   if (source->ts.type == BT_CHARACTER)\n     check_charlen_present (source);\n \n@@ -2258,6 +2279,10 @@ gfc_resolve_transfer (gfc_expr *f, gfc_expr *source ATTRIBUTE_UNUSED,\n void\n gfc_resolve_transpose (gfc_expr *f, gfc_expr *matrix)\n {\n+\n+  if (matrix->ts.type == BT_CHARACTER && matrix->ref)\n+    gfc_resolve_substring_charlen (matrix);\n+\n   f->ts = matrix->ts;\n   f->rank = 2;\n   if (matrix->shape)\n@@ -2384,6 +2409,9 @@ void\n gfc_resolve_unpack (gfc_expr *f, gfc_expr *vector, gfc_expr *mask,\n \t\t    gfc_expr *field ATTRIBUTE_UNUSED)\n {\n+  if (vector->ts.type == BT_CHARACTER && vector->ref)\n+    gfc_resolve_substring_charlen (vector);\n+\n   f->ts = vector->ts;\n   f->rank = mask->rank;\n   resolve_mask_arg (mask);"}, {"sha": "424acfc68298d94123817de426c98672109c8063", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -3535,6 +3535,70 @@ resolve_substring (gfc_ref *ref)\n }\n \n \n+/* This function supplies missing substring charlens.  */\n+\n+void\n+gfc_resolve_substring_charlen (gfc_expr *e)\n+{\n+  gfc_ref *char_ref;\n+  gfc_expr *start, *end;\n+\n+  for (char_ref = e->ref; char_ref; char_ref = char_ref->next)\n+    if (char_ref->type == REF_SUBSTRING)\n+      break;\n+\n+  if (!char_ref)\n+    return;\n+\n+  gcc_assert (char_ref->next == NULL);\n+\n+  if (e->ts.cl)\n+    {\n+      if (e->ts.cl->length)\n+\tgfc_free_expr (e->ts.cl->length);\n+      else if (e->expr_type == EXPR_VARIABLE\n+\t\t && e->symtree->n.sym->attr.dummy)\n+\treturn;\n+    }\n+\n+  e->ts.type = BT_CHARACTER;\n+  e->ts.kind = gfc_default_character_kind;\n+\n+  if (!e->ts.cl)\n+    {\n+      e->ts.cl = gfc_get_charlen ();\n+      e->ts.cl->next = gfc_current_ns->cl_list;\n+      gfc_current_ns->cl_list = e->ts.cl;\n+    }\n+\n+  if (char_ref->u.ss.start)\n+    start = gfc_copy_expr (char_ref->u.ss.start);\n+  else\n+    start = gfc_int_expr (1);\n+\n+  if (char_ref->u.ss.end)\n+    end = gfc_copy_expr (char_ref->u.ss.end);\n+  else if (e->expr_type == EXPR_VARIABLE)\n+    end = gfc_copy_expr (e->symtree->n.sym->ts.cl->length);\n+  else\n+    end = NULL;\n+\n+  if (!start || !end)\n+    return;\n+\n+  /* Length = (end - start +1).  */\n+  e->ts.cl->length = gfc_subtract (end, start);\n+  e->ts.cl->length = gfc_add (e->ts.cl->length, gfc_int_expr (1));\n+\n+  e->ts.cl->length->ts.type = BT_INTEGER;\n+  e->ts.cl->length->ts.kind = gfc_charlen_int_kind;;\n+\n+  /* Make sure that the length is simplified.  */\n+  gfc_simplify_expr (e->ts.cl->length, 1);\n+  gfc_resolve_expr (e->ts.cl->length);\n+}\n+\n+\n /* Resolve subtype references.  */\n \n static try\n@@ -3908,6 +3972,78 @@ check_host_association (gfc_expr *e)\n }\n \n \n+static void\n+gfc_resolve_character_operator (gfc_expr *e)\n+{\n+  gfc_expr *op1 = e->value.op.op1;\n+  gfc_expr *op2 = e->value.op.op2;\n+  gfc_expr *e1 = NULL;\n+  gfc_expr *e2 = NULL;\n+\n+  gcc_assert (e->value.op.operator == INTRINSIC_CONCAT);\n+\n+  if (op1->ts.cl && op1->ts.cl->length)\n+    e1 = gfc_copy_expr (op1->ts.cl->length);\n+  else if (op1->expr_type == EXPR_CONSTANT)\n+    e1 = gfc_int_expr (op1->value.character.length);\n+\n+  if (op2->ts.cl && op2->ts.cl->length)\n+    e2 = gfc_copy_expr (op2->ts.cl->length);\n+  else if (op2->expr_type == EXPR_CONSTANT)\n+    e2 = gfc_int_expr (op2->value.character.length);\n+\n+  e->ts.cl = gfc_get_charlen ();\n+  e->ts.cl->next = gfc_current_ns->cl_list;\n+  gfc_current_ns->cl_list = e->ts.cl;\n+\n+  if (!e1 || !e2)\n+    return;\n+\n+  e->ts.cl->length = gfc_add (e1, e2);\n+  e->ts.cl->length->ts.type = BT_INTEGER;\n+  e->ts.cl->length->ts.kind = gfc_charlen_int_kind;;\n+  gfc_simplify_expr (e->ts.cl->length, 0);\n+  gfc_resolve_expr (e->ts.cl->length);\n+\n+  return;\n+}\n+\n+\n+/*  Ensure that an character expression has a charlen and, if possible, a\n+    length expression.  */\n+\n+static void\n+fixup_charlen (gfc_expr *e)\n+{\n+  /* The cases fall through so that changes in expression type and the need\n+     for multiple fixes are picked up.  In all circumstances, a charlen should\n+     be available for the middle end to hang a backend_decl on.  */\n+  switch (e->expr_type)\n+    {\n+    case EXPR_OP:\n+      gfc_resolve_character_operator (e);\n+\n+    case EXPR_ARRAY:\n+      if (e->expr_type == EXPR_ARRAY)\n+\tgfc_resolve_character_array_constructor (e);\n+\n+    case EXPR_SUBSTRING:\n+      if (!e->ts.cl && e->ref)\n+\tgfc_resolve_substring_charlen (e);\n+\n+    default:\n+      if (!e->ts.cl)\n+\t{\n+\t  e->ts.cl = gfc_get_charlen ();\n+\t  e->ts.cl->next = gfc_current_ns->cl_list;\n+\t  gfc_current_ns->cl_list = e->ts.cl;\n+\t}\n+\n+      break;\n+    }\n+}\n+\n+\n /* Resolve an expression.  That is, make sure that types of operands agree\n    with their operators, intrinsic operators are converted to function calls\n    for overloaded types and unresolved function references are resolved.  */\n@@ -3937,6 +4073,11 @@ gfc_resolve_expr (gfc_expr *e)\n \t  if (t == SUCCESS)\n \t    expression_rank (e);\n \t}\n+\n+      if (e->ts.type == BT_CHARACTER && e->ts.cl == NULL && e->ref\n+\t    && e->ref->type != REF_SUBSTRING)\n+\tgfc_resolve_substring_charlen (e);\n+\n       break;\n \n     case EXPR_SUBSTRING:\n@@ -3985,6 +4126,9 @@ gfc_resolve_expr (gfc_expr *e)\n       gfc_internal_error (\"gfc_resolve_expr(): Bad expression type\");\n     }\n \n+  if (e->ts.type == BT_CHARACTER && t == SUCCESS && !e->ts.cl)\n+    fixup_charlen (e);\n+\n   return t;\n }\n "}, {"sha": "69be8efb2f30a2613500012435428ba502bfac9a", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 16, "deletions": 72, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -1375,7 +1375,7 @@ get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n   if (*len && INTEGER_CST_P (*len))\n     return;\n \n-  if (!e->ref && e->ts.cl->length\n+  if (!e->ref && e->ts.cl && e->ts.cl->length\n \t&& e->ts.cl->length->expr_type == EXPR_CONSTANT)\n     {\n       /* This is easy.  */\n@@ -1639,17 +1639,6 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n       if (!ss->string_length)\n \tgfc_todo_error (\"complex character array constructors\");\n \n-      /* It is surprising but still possible to wind up with expressions that\n-\t lack a character length.\n-\t TODO Find the offending part of the front end and cure this properly.\n-\t Concatenation involving arrays is the main culprit.  */\n-      if (!ss->expr->ts.cl)\n-\t{\n-\t  ss->expr->ts.cl = gfc_get_charlen ();\n-\t  ss->expr->ts.cl->next = gfc_current_ns->cl_list;\n-\t  gfc_current_ns->cl_list = ss->expr->ts.cl->next;\n-\t}\n-\n       ss->expr->ts.cl->backend_decl = ss->string_length;\n \n       type = gfc_get_character_type_len (ss->expr->ts.kind, ss->string_length);\n@@ -3909,7 +3898,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   if (sym->ts.type == BT_CHARACTER\n       && onstack && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n     {\n-      gfc_trans_init_string_length (sym->ts.cl, &block);\n+      gfc_conv_string_length (sym->ts.cl, &block);\n \n       gfc_trans_vla_type_sizes (sym, &block);\n \n@@ -3933,7 +3922,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n-    gfc_trans_init_string_length (sym->ts.cl, &block);\n+    gfc_conv_string_length (sym->ts.cl, &block);\n \n   size = gfc_trans_array_bounds (type, sym, &offset, &block);\n \n@@ -3999,7 +3988,7 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n \n   if (sym->ts.type == BT_CHARACTER\n       && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n-    gfc_trans_init_string_length (sym->ts.cl, &block);\n+    gfc_conv_string_length (sym->ts.cl, &block);\n \n   /* Evaluate the bounds of the array.  */\n   gfc_trans_array_bounds (type, sym, &offset, &block);\n@@ -4091,7 +4080,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n   if (sym->ts.type == BT_CHARACTER\n       && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n-    gfc_trans_init_string_length (sym->ts.cl, &block);\n+    gfc_conv_string_length (sym->ts.cl, &block);\n \n   checkparm = (sym->as->type == AS_EXPLICIT && flag_bounds_check);\n \n@@ -4530,63 +4519,18 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       loop.temp_ss = gfc_get_ss ();\n       loop.temp_ss->type = GFC_SS_TEMP;\n       loop.temp_ss->next = gfc_ss_terminator;\n+\n+      if (expr->ts.type == BT_CHARACTER && !expr->ts.cl->backend_decl)\n+\tgfc_conv_string_length (expr->ts.cl, &se->pre);\n+\n+      loop.temp_ss->data.temp.type = gfc_typenode_for_spec (&expr->ts);\n+\n       if (expr->ts.type == BT_CHARACTER)\n-\t{\n-\t  if (expr->ts.cl == NULL)\n-\t    {\n-\t      /* This had better be a substring reference!  */\n-\t      gfc_ref *char_ref = expr->ref;\n-\t      for (; char_ref; char_ref = char_ref->next)\n-\t\tif (char_ref->type == REF_SUBSTRING)\n-\t\t  {\n-\t\t    mpz_t char_len;\n-\t\t    expr->ts.cl = gfc_get_charlen ();\n-\t\t    expr->ts.cl->next = char_ref->u.ss.length->next;\n-\t\t    char_ref->u.ss.length->next = expr->ts.cl;\n-\n-\t\t    mpz_init_set_ui (char_len, 1);\n-\t\t    mpz_add (char_len, char_len,\n-\t\t\t     char_ref->u.ss.end->value.integer);\n-\t\t    mpz_sub (char_len, char_len,\n-\t\t\t     char_ref->u.ss.start->value.integer);\n-\t\t    expr->ts.cl->backend_decl\n-\t\t\t= gfc_conv_mpz_to_tree (char_len,\n-\t\t\t\t\tgfc_default_character_kind);\n-\t\t    /* Cast is necessary for *-charlen refs.  */\n-\t\t    expr->ts.cl->backend_decl\n-\t\t\t= convert (gfc_charlen_type_node,\n-\t\t\t\t   expr->ts.cl->backend_decl);\n-\t\t    mpz_clear (char_len);\n-\t\t      break;\n-\t\t  }\n-\t      gcc_assert (char_ref != NULL);\n-\t      loop.temp_ss->data.temp.type\n-\t\t= gfc_typenode_for_spec (&expr->ts);\n-\t      loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n-\t    }\n-\t  else if (expr->ts.cl->length\n-\t\t     && expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n-\t    {\n-\t      gfc_conv_const_charlen (expr->ts.cl);\n-\t      loop.temp_ss->data.temp.type\n-\t\t= gfc_typenode_for_spec (&expr->ts);\n-\t      loop.temp_ss->string_length\n-\t\t= TYPE_SIZE_UNIT (loop.temp_ss->data.temp.type);\n-\t    }\n-\t  else\n-\t    {\n-\t      loop.temp_ss->data.temp.type\n-\t\t= gfc_typenode_for_spec (&expr->ts);\n-\t      loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n-\t    }\n-\t  se->string_length = loop.temp_ss->string_length;\n-\t}\n+\tloop.temp_ss->string_length = expr->ts.cl->backend_decl;\n       else\n-\t{\n-\t  loop.temp_ss->data.temp.type\n-\t    = gfc_typenode_for_spec (&expr->ts);\n-\t  loop.temp_ss->string_length = NULL;\n-\t}\n+\tloop.temp_ss->string_length = NULL;\n+\n+      se->string_length = loop.temp_ss->string_length;\n       loop.temp_ss->data.temp.dimen = loop.dimen;\n       gfc_add_ss_to_loop (&loop, loop.temp_ss);\n     }\n@@ -5318,7 +5262,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n     {\n-      gfc_trans_init_string_length (sym->ts.cl, &fnblock);\n+      gfc_conv_string_length (sym->ts.cl, &fnblock);\n       gfc_trans_vla_type_sizes (sym, &fnblock);\n     }\n "}, {"sha": "109a18707b4c4945a99c8e03ff824370dc1c8acd", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -2374,7 +2374,7 @@ gfc_trans_dummy_character (gfc_symbol *sym, gfc_charlen *cl, tree fnbody)\n   gfc_start_block (&body);\n \n   /* Evaluate the string length expression.  */\n-  gfc_trans_init_string_length (cl, &body);\n+  gfc_conv_string_length (cl, &body);\n \n   gfc_trans_vla_type_sizes (sym, &body);\n \n@@ -2398,7 +2398,7 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n   gfc_start_block (&body);\n \n   /* Evaluate the string length expression.  */\n-  gfc_trans_init_string_length (sym->ts.cl, &body);\n+  gfc_conv_string_length (sym->ts.cl, &body);\n \n   gfc_trans_vla_type_sizes (sym, &body);\n "}, {"sha": "99f180a1771b289fb21bb7f833de4bcc9fc22c21", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -220,19 +220,20 @@ gfc_get_expr_charlen (gfc_expr *e)\n    value.  */\n \n void\n-gfc_trans_init_string_length (gfc_charlen * cl, stmtblock_t * pblock)\n+gfc_conv_string_length (gfc_charlen * cl, stmtblock_t * pblock)\n {\n   gfc_se se;\n-  tree tmp;\n \n   gfc_init_se (&se, NULL);\n   gfc_conv_expr_type (&se, cl->length, gfc_charlen_type_node);\n   se.expr = fold_build2 (MAX_EXPR, gfc_charlen_type_node, se.expr,\n \t\t\t build_int_cst (gfc_charlen_type_node, 0));\n   gfc_add_block_to_block (pblock, &se.pre);\n \n-  tmp = cl->backend_decl;\n-  gfc_add_modify_expr (pblock, tmp, se.expr);\n+  if (cl->backend_decl)\n+    gfc_add_modify_expr (pblock, cl->backend_decl, se.expr);\n+  else\n+    cl->backend_decl = gfc_evaluate_now (se.expr, pblock);\n }\n \n \n@@ -1823,6 +1824,9 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n   gfc_conv_ss_startstride (&loop);\n \n   /* Build an ss for the temporary.  */\n+  if (expr->ts.type == BT_CHARACTER && !expr->ts.cl->backend_decl)\n+    gfc_conv_string_length (expr->ts.cl, &parmse->pre);\n+\n   base_type = gfc_typenode_for_spec (&expr->ts);\n   if (GFC_ARRAY_TYPE_P (base_type)\n \t\t|| GFC_DESCRIPTOR_TYPE_P (base_type))\n@@ -1833,39 +1837,11 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n   loop.temp_ss->data.temp.type = base_type;\n \n   if (expr->ts.type == BT_CHARACTER)\n-    {\n-      gfc_ref *char_ref = expr->ref;\n-\n-      for (; char_ref; char_ref = char_ref->next)\n-\tif (char_ref->type == REF_SUBSTRING)\n-\t  {\n-\t    gfc_se tmp_se;\n-\n-\t    expr->ts.cl = gfc_get_charlen ();\n-\t    expr->ts.cl->next = char_ref->u.ss.length->next;\n-\t    char_ref->u.ss.length->next = expr->ts.cl;\n-\n-\t    gfc_init_se (&tmp_se, NULL);\n-\t    gfc_conv_expr_type (&tmp_se, char_ref->u.ss.end,\n-\t\t\t\tgfc_array_index_type);\n-\t    tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t       tmp_se.expr, gfc_index_one_node);\n-\t    tmp = gfc_evaluate_now (tmp, &parmse->pre);\n-\t    gfc_init_se (&tmp_se, NULL);\n-\t    gfc_conv_expr_type (&tmp_se, char_ref->u.ss.start,\n-\t\t\t\tgfc_array_index_type);\n-\t    tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t       tmp, tmp_se.expr);\n-\t    tmp = fold_convert (gfc_charlen_type_node, tmp);\n-\t    expr->ts.cl->backend_decl = tmp;\n-\n-\t    break;\n-\t  }\n-      loop.temp_ss->data.temp.type\n-\t\t= gfc_typenode_for_spec (&expr->ts);\n-      loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n-    }\n+    loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n+  else\n+    loop.temp_ss->string_length = NULL;\n \n+  parmse->string_length = loop.temp_ss->string_length;\n   loop.temp_ss->data.temp.dimen = loop.dimen;\n   loop.temp_ss->next = gfc_ss_terminator;\n "}, {"sha": "389d0378ff057059028eda2ad3b6c24848918e84", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -340,7 +340,7 @@ tree gfc_conv_string_tmp (gfc_se *, tree, tree);\n /* Get the string length variable belonging to an expression.  */\n tree gfc_get_expr_charlen (gfc_expr *);\n /* Initialize a string length variable.  */\n-void gfc_trans_init_string_length (gfc_charlen *, stmtblock_t *);\n+void gfc_conv_string_length (gfc_charlen *, stmtblock_t *);\n /* Ensure type sizes can be gimplified.  */\n void gfc_trans_vla_type_sizes (gfc_symbol *, stmtblock_t *);\n "}, {"sha": "cb25b9615f70532cd1760ccb8a8f00b683b5bc0a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -1,3 +1,14 @@\n+2007-08-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31879\n+\t* gfortran.dg/char_length_7.f90: New test.\n+\t* gfortran.dg/char_length_9.f90: New test.\n+\t* gfortran.dg/char_assign_1.f90: Add extra warning.\n+\n+\tPR fortran/31197\n+\tPR fortran/31258\n+\t* gfortran.dg/char_length_8.f90: New test.\n+\n 2007-08-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* gcc.target/powerpc/ppu-intrinsics.c: New testcase."}, {"sha": "0d31cee7a1531aca0f524e3b930b33b1b3481de1", "filename": "gcc/testsuite/gfortran.dg/char_assign_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_assign_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_assign_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_assign_1.f90?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -11,7 +11,7 @@\n character(len=3), dimension(5) :: q\n \n y(:)%c = \"abcdef\" ! { dg-warning \"in assignment \\\\(5/6\\\\)\" }\n-p(1) = y(1)%c(3:)\n+p(1) = y(1)%c(3:) ! { dg-warning \"in assignment \\\\(2/3\\\\)\" }\n if (p(1).ne.\"cd\") call abort()\n \n p(1) = y(1)%c  ! { dg-warning \"in assignment \\\\(2/5\\\\)\" }"}, {"sha": "221c84090f83219066a76bf955543883eece372c", "filename": "gcc/testsuite/gfortran.dg/char_length_7.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_7.f90?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+! Test the fix for PR31879 in which the concatenation operators below\n+! would cause ICEs because the character lengths were never resolved.\n+!\n+! Contributed by Vivek Rao <vivekrao4@yahoo.com> \n+!\n+module str_mod\n+  character(3) :: mz(2) = (/\"fgh\",\"ijk\"/)\n+contains\n+  function ccopy(yy) result(xy)\n+    character (len=*), intent(in) :: yy(:)\n+    character (len=5) :: xy(size(yy))\n+    xy = yy\n+  end function ccopy\n+end module str_mod\n+!\n+program xx\n+  use str_mod, only: ccopy, mz\n+  implicit none\n+  character(2) :: z = \"zz\"\n+  character(3) :: zz(2) = (/\"abc\",\"cde\"/)\n+  character(2) :: ans(2)\n+  integer :: i = 2, j = 3\n+  if (any(ccopy(\"_&_\"//(/\"A\",\"B\"/)//\"?\") .ne. (/\"_&_A?\",\"_&_B?\"/))) call abort ()\n+  if (any(ccopy(z//zz) .ne. (/\"zzabc\",\"zzcde\"/))) call abort ()\n+  if (any(ccopy(z//zz(:)(1:2)) .ne. (/\"zzab \",\"zzcd \"/))) call abort ()\n+  if (any(ccopy(z//mz(:)(2:3)) .ne. (/\"zzgh \",\"zzjk \"/))) call abort ()\n+\n+! This was another bug, uncovered when the PR was fixed.\n+  if (any(ccopy(z//mz(:)(i:j)) .ne. (/\"zzgh \",\"zzjk \"/))) call abort ()\n+end program xx\n+! { dg-final { cleanup-modules \"str_mod\" } }"}, {"sha": "dd91de3145f5abd3b66066b3b5365d6c5fa77c99", "filename": "gcc/testsuite/gfortran.dg/char_length_8.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_8.f90?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+! Test the fix for PR31197 and PR31258 in which the substrings below\n+! would cause ICEs because the character lengths were never resolved.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk> \n+!            and Thomas Koenig <tkoenig@gcc.gnu.org>\n+!\n+  CHARACTER(LEN=3), DIMENSION(10) :: Z\n+  CHARACTER(LEN=3), DIMENSION(3,3) :: W\n+  integer :: ctr = 0\n+  call test_reshape\n+  call test_eoshift\n+  call test_cshift\n+  call test_spread\n+  call test_transpose\n+  call test_pack\n+  call test_unpack\n+  call test_pr31197\n+  if (ctr .ne. 8) call abort\n+contains\n+  subroutine test_reshape \n+    Z(:)=\"123\"\n+    if (any (RESHAPE(Z(:)(2:2),(/5,2/)) .ne. \"2\")) call abort \n+    ctr = ctr + 1\n+  end subroutine\n+  subroutine test_eoshift \n+    CHARACTER(LEN=1), DIMENSION(10) :: chk\n+    chk(1:8) = \"5\"\n+    chk(9:10) = \" \"\n+    Z(:)=\"456\"\n+    if (any (EOSHIFT(Z(:)(2:2),2) .ne. chk)) call abort \n+    ctr = ctr + 1\n+  END subroutine\n+  subroutine test_cshift \n+    Z(:)=\"901\"\n+    if (any (CSHIFT(Z(:)(2:2),2) .ne. \"0\")) call abort \n+    ctr = ctr + 1\n+  end subroutine\n+  subroutine test_spread \n+    Z(:)=\"789\"\n+    if (any (SPREAD(Z(:)(2:2),dim=1,ncopies=2) .ne. \"8\")) call abort \n+    ctr = ctr + 1\n+  end subroutine\n+  subroutine test_transpose \n+    W(:, :)=\"abc\"\n+    if (any (TRANSPOSE(W(:,:)(1:2)) .ne. \"ab\")) call abort \n+    ctr = ctr + 1\n+  end subroutine\n+  subroutine test_pack \n+    W(:, :)=\"def\"\n+    if (any (pack(W(:,:)(2:3),mask=.true.) .ne. \"ef\")) call abort \n+    ctr = ctr + 1\n+  end subroutine\n+  subroutine test_unpack \n+    logical, dimension(5,2) :: mask\n+    Z(:)=\"hij\"\n+    mask = .true.\n+    if (any (unpack(Z(:)(2:2),mask,' ') .ne. \"i\")) call abort \n+    ctr = ctr + 1\n+  end subroutine\n+  subroutine test_pr31197\n+    TYPE data\n+      CHARACTER(LEN=3) :: A = \"xyz\"\n+    END TYPE\n+    TYPE(data), DIMENSION(10), TARGET :: T\n+    if (any (TRANSPOSE(RESHAPE(T(:)%A(2:2),(/5,2/))) .ne. \"y\")) call abort \n+    ctr = ctr + 1\n+  end subroutine\n+END"}, {"sha": "dbec68cd8c3916d6230c6e34a7a4b5806c931f57", "filename": "gcc/testsuite/gfortran.dg/char_length_9.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07368af0833c1bfc29e35a1eabb4f269eafd8825/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_9.f90?ref=07368af0833c1bfc29e35a1eabb4f269eafd8825", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+! Test the fix for a regression caused by the first fix of PR31879.\n+! Reported by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+MODULE input_val_types\n+  IMPLICIT NONE\n+  INTEGER, PARAMETER :: default_string_length=80\n+  TYPE val_type\n+    CHARACTER(len=default_string_length), DIMENSION(:), POINTER :: c_val\n+  END TYPE val_type\n+CONTAINS\n+  SUBROUTINE val_get (val, c_val)\n+    TYPE(val_type), POINTER                  :: val\n+    CHARACTER(LEN=*), INTENT(out)            :: c_val\n+    INTEGER                                  :: i, l_out\n+    i=1\n+    c_val((i-1)*default_string_length+1:MIN (l_out, i*default_string_length)) = &\n+               val%c_val(i)(1:MIN (80, l_out-(i-1)*default_string_length))\n+  END SUBROUTINE val_get\n+END MODULE input_val_types\n+\n+! { dg-final { cleanup-modules \"input_val_types\" } }"}]}