{"sha": "f357808bc7f02b8254ab1c4fdce84925a150b458", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1NzgwOGJjN2YwMmI4MjU0YWIxYzRmZGNlODQ5MjVhMTUwYjQ1OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-12T00:42:12Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-12T00:42:12Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r728", "tree": {"sha": "db2b6a0e28f3ba2b8b303b4e319f8ae4503e0b5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2b6a0e28f3ba2b8b303b4e319f8ae4503e0b5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f357808bc7f02b8254ab1c4fdce84925a150b458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f357808bc7f02b8254ab1c4fdce84925a150b458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f357808bc7f02b8254ab1c4fdce84925a150b458", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f357808bc7f02b8254ab1c4fdce84925a150b458/comments", "author": null, "committer": null, "parents": [{"sha": "916f14f12b114faba1d7fe94076bae5ff6be1d71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916f14f12b114faba1d7fe94076bae5ff6be1d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916f14f12b114faba1d7fe94076bae5ff6be1d71"}], "stats": {"total": 165, "additions": 118, "deletions": 47}, "files": [{"sha": "6a56c93b6c92cc9c5e2fc3ef09b40113a821122c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f357808bc7f02b8254ab1c4fdce84925a150b458/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f357808bc7f02b8254ab1c4fdce84925a150b458/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f357808bc7f02b8254ab1c4fdce84925a150b458", "patch": "@@ -1080,11 +1080,15 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n \t\t\t\t  gen_rtx (CONST_INT, VOIDmode, \\\n \t\t\t\t\t\t      high_int << 16)), 0),\\\n \t\t     gen_rtx (CONST_INT, VOIDmode, low_int));\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG \\\n \t   && GET_CODE (XEXP (X, 1)) != CONST_INT) \t\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t     force_reg (SImode, force_operand (XEXP (X, 1), 0))); \\\n+      goto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n@@ -1814,6 +1818,7 @@ bss_section ()\t\t\t\t\t\t\\\n #define PREDICATE_CODES \\\n   {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"u_short_cint_operand\", {CONST_INT}},\t\t\t\\\n+  {\"non_short_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"gen_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"cc_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"reg_or_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n@@ -1825,8 +1830,11 @@ bss_section ()\t\t\t\t\t\t\\\n   {\"fp_reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\\\n   {\"mem_or_easy_const_operand\", {SUBREG, MEM, CONST_DOUBLE}},\t\\\n   {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"non_and_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"non_logical_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\\\n   {\"input_operand\", {SUBREG, MEM, REG, CONST_INT}},\t\t\\"}, {"sha": "ee49f299f290da379e4874fecb77acbb7b617d6f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 108, "deletions": 45, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f357808bc7f02b8254ab1c4fdce84925a150b458/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f357808bc7f02b8254ab1c4fdce84925a150b458/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f357808bc7f02b8254ab1c4fdce84925a150b458", "patch": "@@ -165,7 +165,7 @@\n   [(set_attr \"type\" \"compare\")])\n \f\n ;; Fixed-point arithmetic insns.\n-(define_insn \"\"\n+(define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r,r\")\n \t(plus:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r,b\")\n \t\t (match_operand:SI 2 \"add_operand\" \"rI,J\")))]\n@@ -195,28 +195,27 @@\n   \"a%I2. %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n    \n-(define_expand \"addsi3\"\n+;; Split an add that we can't do in one insn into two insns, each of which\n+;; does one 16-bit part.  This is used by combine.  Note that the low-order\n+;; add should be last in case the result gets used in an address.\n+\n+(define_split\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n-\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"\")))]\n+\t\t (match_operand:SI 2 \"non_add_cint_operand\" \"\")))]\n   \"\"\n-  \"\n+  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]\n+\"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (unsigned) (INTVAL (operands[2]) + 0x8000) >= 0x10000\n-      && (INTVAL (operands[2]) & 0xffff) != 0)\n-    {\n-      int low = INTVAL (operands[2]) & 0xffff;\n-      int high = (unsigned) INTVAL (operands[2]) >> 16;\n+  int low = INTVAL (operands[2]) & 0xffff;\n+  int high = (unsigned) INTVAL (operands[2]) >> 16;\n \n-      if (low & 0x8000)\n-\thigh++, low |= 0xffff0000;\n+  if (low & 0x8000)\n+    high++, low |= 0xffff0000;\n \n-      emit_insn (gen_addsi3 (operands[0], operands[1],\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode, high << 16)));\n-      operands[1] = operands[0];\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode, low);\n-    }\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode, high << 16);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, low);\n }\")\n \n (define_insn \"one_cmplsi2\"\n@@ -657,7 +656,47 @@\n    rlinm. %0,%1,0,%m2,%M2\"\n   [(set_attr \"type\" \"compare,compare,compare,delayed_compare\")]) \n \n-(define_insn \"\"\n+;; Take a AND with a constant that cannot be done in a single insn and try to\n+;; split it into two insns.  This does not verify that the insns are valid\n+;; since this need not be done as combine will do it.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n+\t\t(match_operand:SI 2 \"non_and_cint_operand\" \"\")))]\n+  \"\"\n+  [(set (match_dup 0) (and:SI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (and:SI (match_dup 0) (match_dup 4)))]\n+  \"\n+{\n+  int maskval = INTVAL (operands[2]);\n+  int i, transitions, last_bit_value;\n+  int orig = maskval, first_c = maskval, second_c;\n+\n+  /* We know that MASKVAL must have more than 2 bit-transitions.  Start at\n+     the low-order bit and count for the third transition.  When we get there,\n+     make a first mask that has everything to the left of that position\n+     a one.  Then make the second mask to turn off whatever else is needed.  */\n+\n+  for (i = 1, transitions = 0, last_bit_value = maskval & 1; i < 32; i++)\n+    {\n+      if (((maskval >>= 1) & 1) != last_bit_value)\n+\tlast_bit_value ^= 1, transitions++;\n+\n+      if (transitions > 2)\n+\t{\n+\t  first_c |= (~0) << i;\n+\t  break;\n+\t}\n+    }\n+\n+  second_c = orig | ~ first_c;\n+\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode, first_c);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, second_c);\n+}\")\n+\n+(define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r,r,r\")\n \t\t(match_operand:SI 2 \"logical_operand\" \"r,K,J\")))]\n@@ -688,26 +727,24 @@\n   \"or. %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_expand \"iorsi3\"\n+;; Split an IOR that we can't do in one insn into two insns, each of which\n+;; does one 16-bit part.  This is used by combine.\n+\n+(define_split\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"\")))]\n+\t\t(match_operand:SI 2 \"non_logical_cint_operand\" \"\")))]\n   \"\"\n-  \"\n+  [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (ior:SI (match_dup 0) (match_dup 4)))]\n+\"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && ! logical_operand (operands[2], SImode))\n-    {\n-      emit_insn (gen_iorsi3 (operands[0], operands[1],\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t      INTVAL (operands[2]) & 0xffff0000)));\n-      operands[1] = operands[0];\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     INTVAL (operands[2]) & 0xffff);\n-    }\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t INTVAL (operands[2]) & 0xffff0000);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r,r,r\")\n \t(xor:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r,r,r\")\n \t\t(match_operand:SI 2 \"logical_operand\" \"r,K,J\")))]\n@@ -738,23 +775,21 @@\n   \"xor. %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_expand \"xorsi3\"\n+;; Split an XOR that we can't do in one insn into two insns, each of which\n+;; does one 16-bit part.  This is used by combine.\n+\n+(define_split\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"\")))]\n+\t\t(match_operand:SI 2 \"non_logical_cint_operand\" \"\")))]\n   \"\"\n-  \"\n+  [(set (match_dup 0) (xor:SI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 4)))]\n+\"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && ! logical_operand (operands[2], SImode))\n-    {\n-      emit_insn (gen_xorsi3 (operands[0], operands[1],\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t      INTVAL (operands[2]) & 0xffff0000)));\n-      operands[1] = operands[0];\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     INTVAL (operands[2]) & 0xffff);\n-    }\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t INTVAL (operands[2]) & 0xffff0000);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n }\")\n \n (define_insn \"\"\n@@ -3223,6 +3258,34 @@\n   \"cmp%I2 %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n+;; If we are comparing a register for equality with a large constant,\n+;; we can do this with an XOR followed by a compare.  But we need a scratch\n+;; register for the result of the XOR.\n+\n+(define_split\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"\")\n+\t(compare:CC (match_operand:SI 1 \"gen_reg_operand\" \"\")\n+\t\t    (match_operand:SI 2 \"non_short_cint_operand\" \"\")))\n+   (clobber (match_operand:SI 3 \"gen_reg_operand\" \"\"))]\n+  \"find_single_use (operands[0], insn, 0)\n+   && (GET_CODE (*find_single_use (operands[0], insn, 0)) == EQ\n+       || GET_CODE (*find_single_use (operands[0], insn, 0)) == NE)\"\n+  [(set (match_dup 3) (xor:SI (match_dup 1) (match_dup 4)))\n+   (set (match_dup 0) (compare:CC (match_dup 3) (match_dup 5)))]\n+  \"\n+{\n+  /* Get the constant we are comparing against, C,  and see what it looks like\n+     sign-extended to 16 bits.  Then see what constant could be XOR'ed\n+     with C to get the sign-extended value.  */\n+\n+  int c = INTVAL (operands[2]);\n+  int sextc = (c << 16) >> 16;\n+  int xorv = c ^ sextc;\n+\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, xorv);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, sextc);\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:CCUNS 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CCUNS (match_operand:SI 1 \"gen_reg_operand\" \"r\")"}]}