{"sha": "57fa080bf6c0ae01bf1643a87e72ca636bde0454", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdmYTA4MGJmNmMwYWUwMWJmMTY0M2E4N2U3MmNhNjM2YmRlMDQ1NA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-02-27T10:20:36Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-02-27T10:20:36Z"}, "message": "re PR tree-optimization/77536 (Vectorizer not maintaining relationship of relative block frequencies in absence of real profile data)\n\n\tPR tree-optimization/77536\n\t* tree-ssa-loop-manip.c (niter_for_unrolled_loop): New function.\n\t(tree_transform_and_unroll_loop): Use above function to compute the\n\testimated niter of unrolled loop and use it when scaling profile.\n\tAlso use count info rather than frequency if it's non-zero.\n\t* tree-ssa-loop-manip.h niter_for_unrolled_loop(): New declaration.\n\t* tree-vect-loop.c (scale_profile_for_vect_loop): New function.\n\t(vect_transform_loop): Call above function.\n\n\tgcc/testsuite\n\t* gcc.dg/vect/pr79347.c: Revise testing string.\n\nFrom-SVN: r245754", "tree": {"sha": "f43af4a14ba4560b5196a61c743280e98d08cc5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f43af4a14ba4560b5196a61c743280e98d08cc5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57fa080bf6c0ae01bf1643a87e72ca636bde0454", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57fa080bf6c0ae01bf1643a87e72ca636bde0454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57fa080bf6c0ae01bf1643a87e72ca636bde0454", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57fa080bf6c0ae01bf1643a87e72ca636bde0454/comments", "author": null, "committer": null, "parents": [{"sha": "68b948d3ba7cee54ba9f03a5b04f505f9c7538ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b948d3ba7cee54ba9f03a5b04f505f9c7538ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68b948d3ba7cee54ba9f03a5b04f505f9c7538ff"}], "stats": {"total": 144, "additions": 112, "deletions": 32}, "files": [{"sha": "fd390978e134954da24c15899ed89797f380779d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57fa080bf6c0ae01bf1643a87e72ca636bde0454", "patch": "@@ -1,3 +1,14 @@\n+2017-02-27  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/77536\n+\t* tree-ssa-loop-manip.c (niter_for_unrolled_loop): New function.\n+\t(tree_transform_and_unroll_loop): Use above function to compute the\n+\testimated niter of unrolled loop and use it when scaling profile.\n+\tAlso use count info rather than frequency if it's non-zero.\n+\t* tree-ssa-loop-manip.h niter_for_unrolled_loop(): New declaration.\n+\t* tree-vect-loop.c (scale_profile_for_vect_loop): New function.\n+\t(vect_transform_loop): Call above function.\n+\n 2017-02-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/45397"}, {"sha": "ac001523f324cb6e188adc9795d6ccb212877d09", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=57fa080bf6c0ae01bf1643a87e72ca636bde0454", "patch": "@@ -1,3 +1,8 @@\n+2017-02-27  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/77536\n+\t* gcc.dg/vect/pr79347.c: Revise testing string.\n+\n 2017-02-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/45397"}, {"sha": "6825420ec8d040d597ba1976002d9f8b74ea0d6a", "filename": "gcc/testsuite/gcc.dg/vect/pr79347.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79347.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79347.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79347.c?ref=57fa080bf6c0ae01bf1643a87e72ca636bde0454", "patch": "@@ -10,4 +10,4 @@ void n(void)\n     a[i]++;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Invalid sum of \" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not \"Invalid sum of \" \"vect\" } } */"}, {"sha": "22c832ae1e1bb3a681bfaffbfcaecd30aadba994", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=57fa080bf6c0ae01bf1643a87e72ca636bde0454", "patch": "@@ -1093,6 +1093,33 @@ scale_dominated_blocks_in_loop (struct loop *loop, basic_block bb,\n     }\n }\n \n+/* Return estimated niter for LOOP after unrolling by FACTOR times.  */\n+\n+gcov_type\n+niter_for_unrolled_loop (struct loop *loop, unsigned factor)\n+{\n+  gcc_assert (factor != 0);\n+  bool profile_p = false;\n+  gcov_type est_niter = expected_loop_iterations_unbounded (loop, &profile_p);\n+  gcov_type new_est_niter = est_niter / factor;\n+\n+  /* Without profile feedback, loops for which we do not know a better estimate\n+     are assumed to roll 10 times.  When we unroll such loop, it appears to\n+     roll too little, and it may even seem to be cold.  To avoid this, we\n+     ensure that the created loop appears to roll at least 5 times (but at\n+     most as many times as before unrolling).  Don't do adjustment if profile\n+     feedback is present.  */\n+  if (new_est_niter < 5 && !profile_p)\n+    {\n+      if (est_niter < 5)\n+\tnew_est_niter = est_niter;\n+      else\n+\tnew_est_niter = 5;\n+    }\n+\n+  return new_est_niter;\n+}\n+\n /* Unroll LOOP FACTOR times.  DESC describes number of iterations of LOOP.\n    EXIT is the exit of the loop to that DESC corresponds.\n \n@@ -1170,12 +1197,12 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   gimple_stmt_iterator bsi;\n   use_operand_p op;\n   bool ok;\n-  unsigned est_niter, prob_entry, scale_unrolled, scale_rest, freq_e, freq_h;\n-  unsigned new_est_niter, i, prob;\n+  unsigned i, prob, prob_entry, scale_unrolled, scale_rest;\n+  gcov_type freq_e, freq_h;\n+  gcov_type new_est_niter = niter_for_unrolled_loop (loop, factor);\n   unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n   auto_vec<edge> to_remove;\n \n-  est_niter = expected_loop_iterations (loop);\n   determine_exit_conditions (loop, desc, factor,\n \t\t\t     &enter_main_cond, &exit_base, &exit_step,\n \t\t\t     &exit_cmp, &exit_bound);\n@@ -1207,22 +1234,6 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   gcc_assert (new_loop != NULL);\n   update_ssa (TODO_update_ssa);\n \n-  /* Determine the probability of the exit edge of the unrolled loop.  */\n-  new_est_niter = est_niter / factor;\n-\n-  /* Without profile feedback, loops for that we do not know a better estimate\n-     are assumed to roll 10 times.  When we unroll such loop, it appears to\n-     roll too little, and it may even seem to be cold.  To avoid this, we\n-     ensure that the created loop appears to roll at least 5 times (but at\n-     most as many times as before unrolling).  */\n-  if (new_est_niter < 5)\n-    {\n-      if (est_niter < 5)\n-\tnew_est_niter = est_niter;\n-      else\n-\tnew_est_niter = 5;\n-    }\n-\n   /* Prepare the cfg and update the phi nodes.  Move the loop exit to the\n      loop latch (and make its condition dummy, for the moment).  */\n   rest = loop_preheader_edge (new_loop)->src;\n@@ -1326,10 +1337,25 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   /* Ensure that the frequencies in the loop match the new estimated\n      number of iterations, and change the probability of the new\n      exit edge.  */\n-  freq_h = loop->header->frequency;\n-  freq_e = EDGE_FREQUENCY (loop_preheader_edge (loop));\n+\n+  freq_h = loop->header->count;\n+  freq_e = (loop_preheader_edge (loop))->count;\n+  /* Use frequency only if counts are zero.  */\n+  if (freq_h == 0 && freq_e == 0)\n+    {\n+      freq_h = loop->header->frequency;\n+      freq_e = EDGE_FREQUENCY (loop_preheader_edge (loop));\n+    }\n   if (freq_h != 0)\n-    scale_loop_frequencies (loop, freq_e * (new_est_niter + 1), freq_h);\n+    {\n+      gcov_type scale;\n+      /* Avoid dropping loop body profile counter to 0 because of zero count\n+\t in loop's preheader.  */\n+      freq_e = MAX (freq_e, 1);\n+      /* This should not overflow.  */\n+      scale = GCOV_COMPUTE_SCALE (freq_e * (new_est_niter + 1), freq_h);\n+      scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n+    }\n \n   exit_bb = single_pred (loop->latch);\n   new_exit = find_edge (exit_bb, rest);"}, {"sha": "a139050aed0425e4906bcd84883d9f24844e1301", "filename": "gcc/tree-ssa-loop-manip.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftree-ssa-loop-manip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftree-ssa-loop-manip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.h?ref=57fa080bf6c0ae01bf1643a87e72ca636bde0454", "patch": "@@ -48,6 +48,7 @@ extern bool gimple_duplicate_loop_to_header_edge (struct loop *, edge,\n \t\t\t\t\t\t  int);\n extern bool can_unroll_loop_p (struct loop *loop, unsigned factor,\n \t\t\t       struct tree_niter_desc *niter);\n+extern gcov_type niter_for_unrolled_loop (struct loop *, unsigned);\n extern void tree_transform_and_unroll_loop (struct loop *, unsigned,\n \t\t\t\t\t    edge, struct tree_niter_desc *,\n \t\t\t\t\t    transform_callback, void *);"}, {"sha": "6bbf8162a863bc1e7e28e58ceec3cd41727e9b9c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fa080bf6c0ae01bf1643a87e72ca636bde0454/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=57fa080bf6c0ae01bf1643a87e72ca636bde0454", "patch": "@@ -6718,6 +6718,50 @@ loop_niters_no_overflow (loop_vec_info loop_vinfo)\n   return false;\n }\n \n+/* Scale profiling counters by estimation for LOOP which is vectorized\n+   by factor VF.  */\n+\n+static void\n+scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n+{\n+  edge preheader = loop_preheader_edge (loop);\n+  /* Reduce loop iterations by the vectorization factor.  */\n+  gcov_type new_est_niter = niter_for_unrolled_loop (loop, vf);\n+  gcov_type freq_h = loop->header->count, freq_e = preheader->count;\n+\n+  /* Use frequency only if counts are zero.  */\n+  if (freq_h == 0 && freq_e == 0)\n+    {\n+      freq_h = loop->header->frequency;\n+      freq_e = EDGE_FREQUENCY (preheader);\n+    }\n+  if (freq_h != 0)\n+    {\n+      gcov_type scale;\n+\n+      /* Avoid dropping loop body profile counter to 0 because of zero count\n+\t in loop's preheader.  */\n+      freq_e = MAX (freq_e, 1);\n+      /* This should not overflow.  */\n+      scale = GCOV_COMPUTE_SCALE (freq_e * (new_est_niter + 1), freq_h);\n+      scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n+    }\n+\n+  basic_block exit_bb = single_pred (loop->latch);\n+  edge exit_e = single_exit (loop);\n+  exit_e->count = loop_preheader_edge (loop)->count;\n+  exit_e->probability = REG_BR_PROB_BASE / (new_est_niter + 1);\n+\n+  edge exit_l = single_pred_edge (loop->latch);\n+  int prob = exit_l->probability;\n+  exit_l->probability = REG_BR_PROB_BASE - exit_e->probability;\n+  exit_l->count = exit_bb->count - exit_e->count;\n+  if (exit_l->count < 0)\n+    exit_l->count = 0;\n+  if (prob > 0)\n+    scale_bbs_frequencies_int (&loop->latch, 1, exit_l->probability, prob);\n+}\n+\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -6743,16 +6787,10 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   bool transform_pattern_stmt = false;\n   bool check_profitability = false;\n   int th;\n-  /* Record number of iterations before we started tampering with the profile. */\n-  gcov_type expected_iterations = expected_loop_iterations_unbounded (loop);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"=== vec_transform_loop ===\\n\");\n \n-  /* If profile is inprecise, we have chance to fix it up.  */\n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n-    expected_iterations = LOOP_VINFO_INT_NITERS (loop_vinfo);\n-\n   /* Use the more conservative vectorization threshold.  If the number\n      of iterations is constant assume the cost check has been performed\n      by our caller.  If the threshold makes all loops profitable that\n@@ -7068,9 +7106,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n   slpeel_make_loop_iterate_ntimes (loop, niters_vector);\n \n-  /* Reduce loop iterations by the vectorization factor.  */\n-  scale_loop_profile (loop, GCOV_COMPUTE_SCALE (1, vf),\n-\t\t      expected_iterations / vf);\n+  scale_profile_for_vect_loop (loop, vf);\n+\n   /* The minimum number of iterations performed by the epilogue.  This\n      is 1 when peeling for gaps because we always need a final scalar\n      iteration.  */"}]}