{"sha": "eb6bb559981118ed95c4340fa32baf346a89b53e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2YmI1NTk5ODExMThlZDk1YzQzNDBmYTMyYmFmMzQ2YTg5YjUzZQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-06-15T15:56:02Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-06-15T15:56:02Z"}, "message": "avr.c (avr_default_expand_builtin): New function.\n\n\t* config/avr/avr.c (avr_default_expand_builtin): New function.\n\t(avr_expand_builtin): Use it.\n\t(avr_expand_unop_builtin): Remove.\n\t(avr_expand_binop_builtin): Remove.\n\t(avr_expand_triop_builtin): Remove.\n\nFrom-SVN: r188670", "tree": {"sha": "8b3689be333feeb214860e30c6e932683f8201b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b3689be333feeb214860e30c6e932683f8201b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb6bb559981118ed95c4340fa32baf346a89b53e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6bb559981118ed95c4340fa32baf346a89b53e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6bb559981118ed95c4340fa32baf346a89b53e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6bb559981118ed95c4340fa32baf346a89b53e/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8395d62c12586d9f50dd3486e7fe269b54927c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8395d62c12586d9f50dd3486e7fe269b54927c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8395d62c12586d9f50dd3486e7fe269b54927c2"}], "stats": {"total": 212, "additions": 53, "deletions": 159}, "files": [{"sha": "07598f2da9d5da2e6e199ae960054f5dd83172d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6bb559981118ed95c4340fa32baf346a89b53e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6bb559981118ed95c4340fa32baf346a89b53e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb6bb559981118ed95c4340fa32baf346a89b53e", "patch": "@@ -1,3 +1,11 @@\n+2012-06-15  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr.c (avr_default_expand_builtin): New function.\n+\t(avr_expand_builtin): Use it.\n+\t(avr_expand_unop_builtin): Remove.\n+\t(avr_expand_binop_builtin): Remove.\n+\t(avr_expand_triop_builtin): Remove.\n+\n 2012-06-15  Michael Matz  <matz@suse.de>\n \n \tPR middle-end/38474"}, {"sha": "70384c4ce295ff328b8cea97e0bda478ac059a42", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 45, "deletions": 159, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6bb559981118ed95c4340fa32baf346a89b53e/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6bb559981118ed95c4340fa32baf346a89b53e/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=eb6bb559981118ed95c4340fa32baf346a89b53e", "patch": "@@ -10329,8 +10329,8 @@ avr_init_builtin_int24 (void)\n   tree int24_type  = make_signed_type (GET_MODE_BITSIZE (PSImode));\n   tree uint24_type = make_unsigned_type (GET_MODE_BITSIZE (PSImode));\n \n-  (*lang_hooks.types.register_builtin_type) (int24_type, \"__int24\");\n-  (*lang_hooks.types.register_builtin_type) (uint24_type, \"__uint24\");\n+  lang_hooks.types.register_builtin_type (int24_type, \"__int24\");\n+  lang_hooks.types.register_builtin_type (uint24_type, \"__uint24\");\n }\n \n \n@@ -10397,170 +10397,64 @@ avr_init_builtins (void)\n }\n \n \n-/* Subroutine of avr_expand_builtin to take care of unop insns.  */\n+/* Subroutine of avr_expand_builtin to expand vanilla builtins\n+   with non-void result and 1 ... 3 arguments.  */\n \n static rtx\n-avr_expand_unop_builtin (enum insn_code icode, tree exp,\n-                         rtx target)\n+avr_default_expand_builtin (enum insn_code icode, tree exp, rtx target)\n {\n-  rtx pat;\n-  tree arg0 = CALL_EXPR_ARG (exp, 0);\n-  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-  enum machine_mode op0mode = GET_MODE (op0);\n+  rtx pat, xop[3];\n+  int n, n_args = call_expr_nargs (exp);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n \n-  if (! target\n+  gcc_assert (n_args >= 1 && n_args <= 3);\n+              \n+  if (target == NULL_RTX\n       || GET_MODE (target) != tmode\n-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+      || !insn_data[icode].operand[0].predicate (target, tmode))\n     {\n       target = gen_reg_rtx (tmode);\n     }\n \n-  if (op0mode == SImode && mode0 == HImode)\n+  for (n = 0; n < n_args; n++)\n     {\n-      op0mode = HImode;\n-      op0 = gen_lowpart (HImode, op0);\n-    }\n-  \n-  gcc_assert (op0mode == mode0 || op0mode == VOIDmode);\n+      tree arg = CALL_EXPR_ARG (exp, n);\n+      rtx op = expand_expr (arg, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      enum machine_mode opmode = GET_MODE (op);\n+      enum machine_mode mode = insn_data[icode].operand[n+1].mode;\n \n-  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n+      if ((opmode == SImode || opmode == VOIDmode) && mode == HImode)\n+        {\n+          opmode = HImode;\n+          op = gen_lowpart (HImode, op);\n+        }\n \n-  pat = GEN_FCN (icode) (target, op0);\n-  if (! pat)\n-    return 0;\n-  \n-  emit_insn (pat);\n+      /* In case the insn wants input operands in modes different from\n+         the result, abort.  */\n   \n-  return target;\n-}\n-\n+      gcc_assert (opmode == mode || opmode == VOIDmode);\n \n-/* Subroutine of avr_expand_builtin to take care of binop insns.  */\n-\n-static rtx\n-avr_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n-{\n-  rtx pat;\n-  tree arg0 = CALL_EXPR_ARG (exp, 0);\n-  tree arg1 = CALL_EXPR_ARG (exp, 1);\n-  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-  enum machine_mode op0mode = GET_MODE (op0);\n-  enum machine_mode op1mode = GET_MODE (op1);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+      if (!insn_data[icode].operand[n+1].predicate (op, mode))\n+        op = copy_to_mode_reg (mode, op);\n \n-  if (! target\n-      || GET_MODE (target) != tmode\n-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-    {\n-      target = gen_reg_rtx (tmode);\n+      xop[n] = op;\n     }\n \n-  if ((op0mode == SImode || op0mode == VOIDmode) && mode0 == HImode)\n+  switch (n_args)\n     {\n-      op0mode = HImode;\n-      op0 = gen_lowpart (HImode, op0);\n-    }\n-  \n-  if ((op1mode == SImode || op1mode == VOIDmode) && mode1 == HImode)\n-    {\n-      op1mode = HImode;\n-      op1 = gen_lowpart (HImode, op1);\n-    }\n-  \n-  /* In case the insn wants input operands in modes different from\n-     the result, abort.  */\n-  \n-  gcc_assert ((op0mode == mode0 || op0mode == VOIDmode)\n-              && (op1mode == mode1 || op1mode == VOIDmode));\n-\n-  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n-  \n-  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-    op1 = copy_to_mode_reg (mode1, op1);\n+    case 1: pat = GEN_FCN (icode) (target, xop[0]); break;\n+    case 2: pat = GEN_FCN (icode) (target, xop[0], xop[1]); break;\n+    case 3: pat = GEN_FCN (icode) (target, xop[0], xop[1], xop[2]); break;\n \n-  pat = GEN_FCN (icode) (target, op0, op1);\n-  \n-  if (! pat)\n-    return 0;\n-\n-  emit_insn (pat);\n-  return target;\n-}\n-\n-/* Subroutine of avr_expand_builtin to take care of 3-operand insns.  */\n-\n-static rtx\n-avr_expand_triop_builtin (enum insn_code icode, tree exp, rtx target)\n-{\n-  rtx pat;\n-  tree arg0 = CALL_EXPR_ARG (exp, 0);\n-  tree arg1 = CALL_EXPR_ARG (exp, 1);\n-  tree arg2 = CALL_EXPR_ARG (exp, 2);\n-  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-  rtx op2 = expand_expr (arg2, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-  enum machine_mode op0mode = GET_MODE (op0);\n-  enum machine_mode op1mode = GET_MODE (op1);\n-  enum machine_mode op2mode = GET_MODE (op2);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n-  enum machine_mode mode2 = insn_data[icode].operand[3].mode;\n-\n-  if (! target\n-      || GET_MODE (target) != tmode\n-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-    {\n-      target = gen_reg_rtx (tmode);\n-    }\n-\n-  if ((op0mode == SImode || op0mode == VOIDmode) && mode0 == HImode)\n-    {\n-      op0mode = HImode;\n-      op0 = gen_lowpart (HImode, op0);\n-    }\n-  \n-  if ((op1mode == SImode || op1mode == VOIDmode) && mode1 == HImode)\n-    {\n-      op1mode = HImode;\n-      op1 = gen_lowpart (HImode, op1);\n-    }\n-  \n-  if ((op2mode == SImode || op2mode == VOIDmode) && mode2 == HImode)\n-    {\n-      op2mode = HImode;\n-      op2 = gen_lowpart (HImode, op2);\n+    default:\n+      gcc_unreachable();\n     }\n   \n-  /* In case the insn wants input operands in modes different from\n-     the result, abort.  */\n-  \n-  gcc_assert ((op0mode == mode0 || op0mode == VOIDmode)\n-              && (op1mode == mode1 || op1mode == VOIDmode)\n-              && (op2mode == mode2 || op2mode == VOIDmode));\n-\n-  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n-  \n-  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-    op1 = copy_to_mode_reg (mode1, op1);\n-\n-  if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n-    op2 = copy_to_mode_reg (mode2, op2);\n-\n-  pat = GEN_FCN (icode) (target, op0, op1, op2);\n-  \n-  if (! pat)\n-    return 0;\n+  if (pat == NULL_RTX)\n+    return NULL_RTX;\n \n   emit_insn (pat);\n+\n   return target;\n }\n \n@@ -10579,7 +10473,7 @@ avr_expand_builtin (tree exp, rtx target,\n                     int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n-  const char* bname = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+  const char *bname = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n   unsigned int id = DECL_FUNCTION_CODE (fndecl);\n   const struct avr_builtin_description *d = &avr_bdesc[id];\n   tree arg0;\n@@ -10603,7 +10497,7 @@ avr_expand_builtin (tree exp, rtx target,\n         else\n           avr_expand_delay_cycles (op0);\n \n-        return 0;\n+        return NULL_RTX;\n       }\n \n     case AVR_BUILTIN_INSERT_BITS:\n@@ -10621,24 +10515,16 @@ avr_expand_builtin (tree exp, rtx target,\n     }\n \n   /* No special treatment needed: vanilla expand.  */\n-  \n-  switch (d->n_args)\n+\n+  gcc_assert (d->n_args == call_expr_nargs (exp));\n+\n+  if (d->n_args == 0)\n     {\n-    case 0:\n       emit_insn ((GEN_FCN (d->icode)) (target));\n-      return 0;\n-      \n-    case 1:\n-      return avr_expand_unop_builtin (d->icode, exp, target);\n-      \n-    case 2:\n-      return avr_expand_binop_builtin (d->icode, exp, target);\n-      \n-    case 3:\n-      return avr_expand_triop_builtin (d->icode, exp, target);\n+      return NULL_RTX;\n     }\n-  \n-  gcc_unreachable ();\n+\n+  return avr_default_expand_builtin (d->icode, exp, target);\n }\n \n "}]}