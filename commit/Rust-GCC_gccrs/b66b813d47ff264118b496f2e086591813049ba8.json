{"sha": "b66b813d47ff264118b496f2e086591813049ba8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2YjgxM2Q0N2ZmMjY0MTE4YjQ5NmYyZTA4NjU5MTgxMzA0OWJhOA==", "commit": {"author": {"name": "Andrew Pinski", "email": "andrew_pinski@playstation.sony.com", "date": "2006-12-01T02:38:47Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2006-12-01T02:38:47Z"}, "message": "spu.c (spu_builtin_range): Move from spu-c.c\n\n2006-11-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * config/spu/spu.c (spu_builtin_range): Move from spu-c.c\n        (TARGET_RESOLVE_OVERLOADED_BUILTIN): Delete.\n        (spu_cpu_cpp_builtins): Remove.\n        (spu_override_options): Don't set warn_main.\n        (spu_force_reg): Move from spu-c.c.\n        (spu_check_builtin_parm): Likewise.\n        (expand_builtin_args): Likewise.\n        (spu_expand_builtin_1): Likewise.\n        (spu_expand_builtin): Likewise.\n        * config/spu/spu.h (REGISTER_TARGET_PRAGMAS): Define, set\n        warn_main and targetm.resolve_overloaded_builtin.\n        * config/spu/spu-c.c (spu_builtin_range): Remove.\n        (spu_check_builtin_parm): Remove.\n        (expand_builtin_args): Remove.\n        (spu_expand_builtin_1): Remove.\n        (spu_expand_builtin): Remove.\n        (spu_cpu_cpp_builtins): Moved from spu.c\n        (spu_force_reg): Remove.\n\nFrom-SVN: r119397", "tree": {"sha": "889e37877b45963f8f463bbc84dc45b268651cc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/889e37877b45963f8f463bbc84dc45b268651cc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b66b813d47ff264118b496f2e086591813049ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66b813d47ff264118b496f2e086591813049ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b66b813d47ff264118b496f2e086591813049ba8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66b813d47ff264118b496f2e086591813049ba8/comments", "author": null, "committer": null, "parents": [{"sha": "8521c41417b57bf46fc57efccf3befaf6fc0a712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8521c41417b57bf46fc57efccf3befaf6fc0a712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8521c41417b57bf46fc57efccf3befaf6fc0a712"}], "stats": {"total": 619, "additions": 318, "deletions": 301}, "files": [{"sha": "4995449c4fcbf1a007b575622aab150f9136fa81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66b813d47ff264118b496f2e086591813049ba8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66b813d47ff264118b496f2e086591813049ba8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b66b813d47ff264118b496f2e086591813049ba8", "patch": "@@ -1,3 +1,24 @@\n+2006-11-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/spu/spu.c (spu_builtin_range): Move from spu-c.c\n+\t(TARGET_RESOLVE_OVERLOADED_BUILTIN): Delete.\n+\t(spu_cpu_cpp_builtins): Remove.\n+\t(spu_override_options): Don't set warn_main.\n+\t(spu_force_reg): Move from spu-c.c.\n+\t(spu_check_builtin_parm): Likewise.\n+\t(expand_builtin_args): Likewise.\n+\t(spu_expand_builtin_1): Likewise.\n+\t(spu_expand_builtin): Likewise.\n+\t* config/spu/spu.h (REGISTER_TARGET_PRAGMAS): Define, set\n+\twarn_main and targetm.resolve_overloaded_builtin.\n+\t* config/spu/spu-c.c (spu_builtin_range): Remove.\n+\t(spu_check_builtin_parm): Remove.\n+\t(expand_builtin_args): Remove.\n+\t(spu_expand_builtin_1): Remove.\n+\t(spu_expand_builtin): Remove.\n+\t(spu_cpu_cpp_builtins): Moved from spu.c\n+\t(spu_force_reg): Remove.\n+\n 2006-12-01  Joseph Myers  <joseph@codesourcery.com>\n             David Edelsohn  <edelsohn@gnu.org>\n "}, {"sha": "b975e83b3cb848688394c06fd485d42e4757e5a4", "filename": "gcc/config/spu/spu-c.c", "status": "modified", "additions": 6, "deletions": 285, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66b813d47ff264118b496f2e086591813049ba8/gcc%2Fconfig%2Fspu%2Fspu-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66b813d47ff264118b496f2e086591813049ba8/gcc%2Fconfig%2Fspu%2Fspu-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-c.c?ref=b66b813d47ff264118b496f2e086591813049ba8", "patch": "@@ -34,35 +34,6 @@\n #include \"recog.h\"\n #include \"optabs.h\"\n #include \"spu-builtins.h\"\n-\n-static rtx spu_expand_builtin_1 (struct spu_builtin_description *d,\n-\t\t\t\t tree arglist, rtx target);\n-static void spu_check_builtin_parm (struct spu_builtin_description *, rtx,\n-\t\t\t\t    int);\n-static void expand_builtin_args (struct spu_builtin_description *, tree, rtx,\n-\t\t\t\t rtx[]);\n-static rtx spu_force_reg (enum machine_mode mode, rtx op);\n-\n-/* Builtin types, data and prototypes. */\n-struct spu_builtin_range\n-{\n-  int low, high;\n-};\n-\n-static struct spu_builtin_range spu_builtin_range[] = {\n-  {-0x40ll, 0x7fll},\t\t/* SPU_BTI_7     */\n-  {-0x40ll, 0x3fll},\t\t/* SPU_BTI_S7    */\n-  {0ll, 0x7fll},\t\t/* SPU_BTI_U7    */\n-  {-0x200ll, 0x1ffll},\t\t/* SPU_BTI_S10   */\n-  {-0x2000ll, 0x1fffll},\t/* SPU_BTI_S10_4 */\n-  {0ll, 0x3fffll},\t\t/* SPU_BTI_U14   */\n-  {-0x8000ll, 0xffffll},\t/* SPU_BTI_16    */\n-  {-0x8000ll, 0x7fffll},\t/* SPU_BTI_S16   */\n-  {-0x20000ll, 0x1ffffll},\t/* SPU_BTI_S16_2 */\n-  {0ll, 0xffffll},\t\t/* SPU_BTI_U16   */\n-  {0ll, 0x3ffffll},\t\t/* SPU_BTI_U16_2 */\n-  {0ll, 0x3ffffll},\t\t/* SPU_BTI_U18   */\n-};\n \f\n \n /* Helper for spu_resolve_overloaded_builtin.  */\n@@ -181,263 +152,13 @@ spu_resolve_overloaded_builtin (tree fndecl, tree fnargs)\n   return spu_build_overload_builtin (match, fnargs);\n }\n \n-static void\n-spu_check_builtin_parm (struct spu_builtin_description *d, rtx op, int p)\n-{\n-  HOST_WIDE_INT v = 0;\n-  int lsbits;\n-  /* Check the range of immediate operands. */\n-  if (p >= SPU_BTI_7 && p <= SPU_BTI_U18)\n-    {\n-      int range = p - SPU_BTI_7;\n-      if (!CONSTANT_P (op)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && (INTVAL (op) < spu_builtin_range[range].low\n-\t\t  || INTVAL (op) > spu_builtin_range[range].high)))\n-\terror (\"%s expects an integer literal in the range [%d, %d].\",\n-\t       d->name,\n-\t       spu_builtin_range[range].low, spu_builtin_range[range].high);\n-\n-      if (GET_CODE (op) == CONST\n-\t  && (GET_CODE (XEXP (op, 0)) == PLUS\n-\t      || GET_CODE (XEXP (op, 0)) == MINUS))\n-\t{\n-\t  v = INTVAL (XEXP (XEXP (op, 0), 1));\n-\t  op = XEXP (XEXP (op, 0), 0);\n-\t}\n-      else if (GET_CODE (op) == CONST_INT)\n-\tv = INTVAL (op);\n-\n-      switch (p)\n-\t{\n-\tcase SPU_BTI_S10_4:\n-\t  lsbits = 4;\n-\t  break;\n-\tcase SPU_BTI_U16_2:\n-\t  /* This is only used in lqa, and stqa.  Even though the insns\n-\t     encode 16 bits of the address (all but the 2 least\n-\t     significant), only 14 bits are used because it is masked to\n-\t     be 16 byte aligned. */\n-\t  lsbits = 4;\n-\t  break;\n-\tcase SPU_BTI_S16_2:\n-\t  /* This is used for lqr and stqr. */\n-\t  lsbits = 2;\n-\t  break;\n-\tdefault:\n-\t  lsbits = 0;\n-\t}\n-\n-      if (GET_CODE (op) == LABEL_REF\n-\t  || (GET_CODE (op) == SYMBOL_REF\n-\t      && SYMBOL_REF_FUNCTION_P (op))\n-\t  || (INTVAL (op) & ((1 << lsbits) - 1)) != 0)\n-\twarning (0, \"%d least significant bits of %s are ignored.\", lsbits,\n-\t\t d->name);\n-    }\n-}\n-\n-static void\n-expand_builtin_args (struct spu_builtin_description *d, tree arglist,\n-\t\t     rtx target, rtx ops[])\n-{\n-  enum insn_code icode = d->icode;\n-  int i = 0;\n-\n-  /* Expand the arguments into rtl. */\n-\n-  if (d->parm[0] != SPU_BTI_VOID)\n-    ops[i++] = target;\n-\n-  for (; i < insn_data[icode].n_operands; i++)\n-    {\n-      tree arg = TREE_VALUE (arglist);\n-      if (arg == 0)\n-\tabort ();\n-      ops[i] = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n-      arglist = TREE_CHAIN (arglist);\n-    }\n-}\n-\n-static rtx\n-spu_expand_builtin_1 (struct spu_builtin_description *d,\n-\t\t      tree arglist, rtx target)\n-{\n-  rtx pat;\n-  rtx ops[8];\n-  enum insn_code icode = d->icode;\n-  enum machine_mode mode, tmode;\n-  int i, p;\n-  tree return_type;\n-\n-  /* Set up ops[] with values from arglist. */\n-  expand_builtin_args (d, arglist, target, ops);\n-\n-  /* Handle the target operand which must be operand 0. */\n-  i = 0;\n-  if (d->parm[0] != SPU_BTI_VOID)\n-    {\n-\n-      /* We prefer the mode specified for the match_operand otherwise\n-         use the mode from the builtin function prototype. */\n-      tmode = insn_data[d->icode].operand[0].mode;\n-      if (tmode == VOIDmode)\n-\ttmode = TYPE_MODE (spu_builtin_types[d->parm[0]]);\n-\n-      /* Try to use target because not using it can lead to extra copies\n-         and when we are using all of the registers extra copies leads\n-         to extra spills.  */\n-      if (target && GET_CODE (target) == REG && GET_MODE (target) == tmode)\n-\tops[0] = target;\n-      else\n-\ttarget = ops[0] = gen_reg_rtx (tmode);\n-\n-      if (!(*insn_data[icode].operand[0].predicate) (ops[0], tmode))\n-\tabort ();\n-\n-      i++;\n-    }\n-\n-  /* Ignore align_hint, but still expand it's args in case they have\n-     side effects. */\n-  if (icode == CODE_FOR_spu_align_hint)\n-    return 0;\n-\n-  /* Handle the rest of the operands. */\n-  for (p = 1; i < insn_data[icode].n_operands; i++, p++)\n-    {\n-      if (insn_data[d->icode].operand[i].mode != VOIDmode)\n-\tmode = insn_data[d->icode].operand[i].mode;\n-      else\n-\tmode = TYPE_MODE (spu_builtin_types[d->parm[i]]);\n-\n-      /* mode can be VOIDmode here for labels */\n-\n-      /* For specific intrinsics with an immediate operand, e.g.,\n-         si_ai(), we sometimes need to convert the scalar argument to a\n-         vector argument by splatting the scalar. */\n-      if (VECTOR_MODE_P (mode)\n-\t  && (GET_CODE (ops[i]) == CONST_INT\n-\t      || GET_MODE_CLASS (GET_MODE (ops[i])) == MODE_INT\n-\t      || GET_MODE_CLASS (GET_MODE (ops[i])) == MODE_FLOAT))\n-\t{\n-\t  if (GET_CODE (ops[i]) == CONST_INT)\n-\t    ops[i] = spu_const (mode, INTVAL (ops[i]));\n-\t  else\n-\t    {\n-\t      rtx reg = gen_reg_rtx (mode);\n-\t      enum machine_mode imode = GET_MODE_INNER (mode);\n-\t      if (!spu_nonmem_operand (ops[i], GET_MODE (ops[i])))\n-\t\tops[i] = force_reg (GET_MODE (ops[i]), ops[i]);\n-\t      if (imode != GET_MODE (ops[i]))\n-\t\tops[i] = convert_to_mode (imode, ops[i],\n-\t\t\t\t\t  TYPE_UNSIGNED (spu_builtin_types\n-\t\t\t\t\t\t\t [d->parm[i]]));\n-\t      emit_insn (gen_spu_splats (reg, ops[i]));\n-\t      ops[i] = reg;\n-\t    }\n-\t}\n-\n-      if (!(*insn_data[icode].operand[i].predicate) (ops[i], mode))\n-\tops[i] = spu_force_reg (mode, ops[i]);\n-\n-      spu_check_builtin_parm (d, ops[i], d->parm[p]);\n-    }\n-\n-  switch (insn_data[icode].n_operands)\n-    {\n-    case 0:\n-      pat = GEN_FCN (icode) (0);\n-      break;\n-    case 1:\n-      pat = GEN_FCN (icode) (ops[0]);\n-      break;\n-    case 2:\n-      pat = GEN_FCN (icode) (ops[0], ops[1]);\n-      break;\n-    case 3:\n-      pat = GEN_FCN (icode) (ops[0], ops[1], ops[2]);\n-      break;\n-    case 4:\n-      pat = GEN_FCN (icode) (ops[0], ops[1], ops[2], ops[3]);\n-      break;\n-    case 5:\n-      pat = GEN_FCN (icode) (ops[0], ops[1], ops[2], ops[3], ops[4]);\n-      break;\n-    case 6:\n-      pat = GEN_FCN (icode) (ops[0], ops[1], ops[2], ops[3], ops[4], ops[5]);\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n-  if (!pat)\n-    abort ();\n-\n-  if (d->type == B_CALL || d->type == B_BISLED)\n-    emit_call_insn (pat);\n-  else if (d->type == B_JUMP)\n-    {\n-      emit_jump_insn (pat);\n-      emit_barrier ();\n-    }\n-  else\n-    emit_insn (pat);\n-\n-  return_type = spu_builtin_types[d->parm[0]];\n-  if (d->parm[0] != SPU_BTI_VOID\n-      && GET_MODE (target) != TYPE_MODE (return_type))\n-    {\n-      /* target is the return value.  It should always be the mode of\n-         the builtin function prototype. */\n-      target = spu_force_reg (TYPE_MODE (return_type), target);\n-    }\n \n-  return target;\n-}\n-\n-rtx\n-spu_expand_builtin (tree exp,\n-\t\t    rtx target,\n-\t\t    rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t    int ignore ATTRIBUTE_UNUSED)\n+void\n+spu_cpu_cpp_builtins (struct cpp_reader *pfile)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  unsigned int fcode = DECL_FUNCTION_CODE (fndecl) - END_BUILTINS;\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  struct spu_builtin_description *d;\n-\n-  if (fcode < NUM_SPU_BUILTINS)\n-    {\n-      d = &spu_builtins[fcode];\n-\n-      return spu_expand_builtin_1 (d, arglist, target);\n-    }\n-  abort ();\n+  builtin_define_std (\"__SPU__\");\n+  cpp_assert (pfile, \"cpu=spu\");\n+  cpp_assert (pfile, \"machine=spu\");\n+  builtin_define_std (\"__vector=__attribute__((__spu_vector__))\");\n }\n \n-static rtx\n-spu_force_reg (enum machine_mode mode, rtx op)\n-{\n-  rtx x, r;\n-  if (GET_MODE (op) == VOIDmode || GET_MODE (op) == BLKmode)\n-    {\n-      if ((SCALAR_INT_MODE_P (mode) && GET_CODE (op) == CONST_INT)\n-\t  || GET_MODE (op) == BLKmode)\n-\treturn force_reg (mode, convert_to_mode (mode, op, 0));\n-      abort ();\n-    }\n-\n-  r = force_reg (GET_MODE (op), op);\n-  if (GET_MODE_SIZE (GET_MODE (op)) == GET_MODE_SIZE (mode))\n-    {\n-      x = simplify_gen_subreg (mode, r, GET_MODE (op), 0);\n-      if (x)\n-\treturn x;\n-    }\n-\n-  x = gen_reg_rtx (mode);\n-  emit_insn (gen_spu_convert (x, r));\n-  return x;\n-}"}, {"sha": "a1158e763bacf68a549879455057ac6ab061148e", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 285, "deletions": 16, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66b813d47ff264118b496f2e086591813049ba8/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66b813d47ff264118b496f2e086591813049ba8/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=b66b813d47ff264118b496f2e086591813049ba8", "patch": "@@ -54,6 +54,28 @@\n #include \"tree-gimple.h\"\n #include \"tm-constrs.h\"\n #include \"spu-builtins.h\"\n+\n+/* Builtin types, data and prototypes. */\n+struct spu_builtin_range\n+{\n+  int low, high;\n+};\n+\n+static struct spu_builtin_range spu_builtin_range[] = {\n+  {-0x40ll, 0x7fll},\t\t/* SPU_BTI_7     */\n+  {-0x40ll, 0x3fll},\t\t/* SPU_BTI_S7    */\n+  {0ll, 0x7fll},\t\t/* SPU_BTI_U7    */\n+  {-0x200ll, 0x1ffll},\t\t/* SPU_BTI_S10   */\n+  {-0x2000ll, 0x1fffll},\t/* SPU_BTI_S10_4 */\n+  {0ll, 0x3fffll},\t\t/* SPU_BTI_U14   */\n+  {-0x8000ll, 0xffffll},\t/* SPU_BTI_16    */\n+  {-0x8000ll, 0x7fffll},\t/* SPU_BTI_S16   */\n+  {-0x20000ll, 0x1ffffll},\t/* SPU_BTI_S16_2 */\n+  {0ll, 0xffffll},\t\t/* SPU_BTI_U16   */\n+  {0ll, 0x3ffffll},\t\t/* SPU_BTI_U16_2 */\n+  {0ll, 0x3ffffll},\t\t/* SPU_BTI_U18   */\n+};\n+\n \f\n /*  Target specific attribute specifications.  */\n char regs_ever_allocated[FIRST_PSEUDO_REGISTER];\n@@ -133,9 +155,6 @@ tree spu_builtin_types[SPU_BTI_MAX];\n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS spu_init_builtins\n \n-#undef TARGET_RESOLVE_OVERLOADED_BUILTIN\n-#define TARGET_RESOLVE_OVERLOADED_BUILTIN  spu_resolve_overloaded_builtin\n-\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN spu_expand_builtin\n \n@@ -213,16 +232,6 @@ const struct attribute_spec spu_attribute_table[];\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n-void\n-spu_cpu_cpp_builtins (struct cpp_reader *pfile)\n-{\n-  extern void builtin_define_std (const char *);\n-  builtin_define_std (\"__SPU__\");\n-  cpp_assert (pfile, \"cpu=spu\");\n-  cpp_assert (pfile, \"machine=spu\");\n-  builtin_define_std (\"__vector=__attribute__((__spu_vector__))\");\n-}\n-\n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro\n    OVERRIDE_OPTIONS to take account of this. This macro, if defined, is\n@@ -231,9 +240,6 @@ void\n spu_override_options (void)\n {\n \n-  /* Don't give warnings about the main() function. */\n-  warn_main = 0;\n-\n   /* Override some of the default param values.  With so many registers\n      larger values are better for these params.  */\n   if (MAX_UNROLLED_INSNS == 100)\n@@ -4467,3 +4473,266 @@ spu_expand_vector_init (rtx target, rtx vals)\n \t}\n     }\n }\n+\n+static rtx\n+spu_force_reg (enum machine_mode mode, rtx op)\n+{\n+  rtx x, r;\n+  if (GET_MODE (op) == VOIDmode || GET_MODE (op) == BLKmode)\n+    {\n+      if ((SCALAR_INT_MODE_P (mode) && GET_CODE (op) == CONST_INT)\n+\t  || GET_MODE (op) == BLKmode)\n+\treturn force_reg (mode, convert_to_mode (mode, op, 0));\n+      abort ();\n+    }\n+\n+  r = force_reg (GET_MODE (op), op);\n+  if (GET_MODE_SIZE (GET_MODE (op)) == GET_MODE_SIZE (mode))\n+    {\n+      x = simplify_gen_subreg (mode, r, GET_MODE (op), 0);\n+      if (x)\n+\treturn x;\n+    }\n+\n+  x = gen_reg_rtx (mode);\n+  emit_insn (gen_spu_convert (x, r));\n+  return x;\n+}\n+\n+static void\n+spu_check_builtin_parm (struct spu_builtin_description *d, rtx op, int p)\n+{\n+  HOST_WIDE_INT v = 0;\n+  int lsbits;\n+  /* Check the range of immediate operands. */\n+  if (p >= SPU_BTI_7 && p <= SPU_BTI_U18)\n+    {\n+      int range = p - SPU_BTI_7;\n+      if (!CONSTANT_P (op)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (INTVAL (op) < spu_builtin_range[range].low\n+\t\t  || INTVAL (op) > spu_builtin_range[range].high)))\n+\terror (\"%s expects an integer literal in the range [%d, %d].\",\n+\t       d->name,\n+\t       spu_builtin_range[range].low, spu_builtin_range[range].high);\n+\n+      if (GET_CODE (op) == CONST\n+\t  && (GET_CODE (XEXP (op, 0)) == PLUS\n+\t      || GET_CODE (XEXP (op, 0)) == MINUS))\n+\t{\n+\t  v = INTVAL (XEXP (XEXP (op, 0), 1));\n+\t  op = XEXP (XEXP (op, 0), 0);\n+\t}\n+      else if (GET_CODE (op) == CONST_INT)\n+\tv = INTVAL (op);\n+\n+      switch (p)\n+\t{\n+\tcase SPU_BTI_S10_4:\n+\t  lsbits = 4;\n+\t  break;\n+\tcase SPU_BTI_U16_2:\n+\t  /* This is only used in lqa, and stqa.  Even though the insns\n+\t     encode 16 bits of the address (all but the 2 least\n+\t     significant), only 14 bits are used because it is masked to\n+\t     be 16 byte aligned. */\n+\t  lsbits = 4;\n+\t  break;\n+\tcase SPU_BTI_S16_2:\n+\t  /* This is used for lqr and stqr. */\n+\t  lsbits = 2;\n+\t  break;\n+\tdefault:\n+\t  lsbits = 0;\n+\t}\n+\n+      if (GET_CODE (op) == LABEL_REF\n+\t  || (GET_CODE (op) == SYMBOL_REF\n+\t      && SYMBOL_REF_FUNCTION_P (op))\n+\t  || (INTVAL (op) & ((1 << lsbits) - 1)) != 0)\n+\twarning (0, \"%d least significant bits of %s are ignored.\", lsbits,\n+\t\t d->name);\n+    }\n+}\n+\n+\n+static void\n+expand_builtin_args (struct spu_builtin_description *d, tree arglist,\n+\t\t     rtx target, rtx ops[])\n+{\n+  enum insn_code icode = d->icode;\n+  int i = 0;\n+\n+  /* Expand the arguments into rtl. */\n+\n+  if (d->parm[0] != SPU_BTI_VOID)\n+    ops[i++] = target;\n+\n+  for (; i < insn_data[icode].n_operands; i++)\n+    {\n+      tree arg = TREE_VALUE (arglist);\n+      if (arg == 0)\n+\tabort ();\n+      ops[i] = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n+      arglist = TREE_CHAIN (arglist);\n+    }\n+}\n+\n+static rtx\n+spu_expand_builtin_1 (struct spu_builtin_description *d,\n+\t\t      tree arglist, rtx target)\n+{\n+  rtx pat;\n+  rtx ops[8];\n+  enum insn_code icode = d->icode;\n+  enum machine_mode mode, tmode;\n+  int i, p;\n+  tree return_type;\n+\n+  /* Set up ops[] with values from arglist. */\n+  expand_builtin_args (d, arglist, target, ops);\n+\n+  /* Handle the target operand which must be operand 0. */\n+  i = 0;\n+  if (d->parm[0] != SPU_BTI_VOID)\n+    {\n+\n+      /* We prefer the mode specified for the match_operand otherwise\n+         use the mode from the builtin function prototype. */\n+      tmode = insn_data[d->icode].operand[0].mode;\n+      if (tmode == VOIDmode)\n+\ttmode = TYPE_MODE (spu_builtin_types[d->parm[0]]);\n+\n+      /* Try to use target because not using it can lead to extra copies\n+         and when we are using all of the registers extra copies leads\n+         to extra spills.  */\n+      if (target && GET_CODE (target) == REG && GET_MODE (target) == tmode)\n+\tops[0] = target;\n+      else\n+\ttarget = ops[0] = gen_reg_rtx (tmode);\n+\n+      if (!(*insn_data[icode].operand[0].predicate) (ops[0], tmode))\n+\tabort ();\n+\n+      i++;\n+    }\n+\n+  /* Ignore align_hint, but still expand it's args in case they have\n+     side effects. */\n+  if (icode == CODE_FOR_spu_align_hint)\n+    return 0;\n+\n+  /* Handle the rest of the operands. */\n+  for (p = 1; i < insn_data[icode].n_operands; i++, p++)\n+    {\n+      if (insn_data[d->icode].operand[i].mode != VOIDmode)\n+\tmode = insn_data[d->icode].operand[i].mode;\n+      else\n+\tmode = TYPE_MODE (spu_builtin_types[d->parm[i]]);\n+\n+      /* mode can be VOIDmode here for labels */\n+\n+      /* For specific intrinsics with an immediate operand, e.g.,\n+         si_ai(), we sometimes need to convert the scalar argument to a\n+         vector argument by splatting the scalar. */\n+      if (VECTOR_MODE_P (mode)\n+\t  && (GET_CODE (ops[i]) == CONST_INT\n+\t      || GET_MODE_CLASS (GET_MODE (ops[i])) == MODE_INT\n+\t      || GET_MODE_CLASS (GET_MODE (ops[i])) == MODE_FLOAT))\n+\t{\n+\t  if (GET_CODE (ops[i]) == CONST_INT)\n+\t    ops[i] = spu_const (mode, INTVAL (ops[i]));\n+\t  else\n+\t    {\n+\t      rtx reg = gen_reg_rtx (mode);\n+\t      enum machine_mode imode = GET_MODE_INNER (mode);\n+\t      if (!spu_nonmem_operand (ops[i], GET_MODE (ops[i])))\n+\t\tops[i] = force_reg (GET_MODE (ops[i]), ops[i]);\n+\t      if (imode != GET_MODE (ops[i]))\n+\t\tops[i] = convert_to_mode (imode, ops[i],\n+\t\t\t\t\t  TYPE_UNSIGNED (spu_builtin_types\n+\t\t\t\t\t\t\t [d->parm[i]]));\n+\t      emit_insn (gen_spu_splats (reg, ops[i]));\n+\t      ops[i] = reg;\n+\t    }\n+\t}\n+\n+      if (!(*insn_data[icode].operand[i].predicate) (ops[i], mode))\n+\tops[i] = spu_force_reg (mode, ops[i]);\n+\n+      spu_check_builtin_parm (d, ops[i], d->parm[p]);\n+    }\n+\n+  switch (insn_data[icode].n_operands)\n+    {\n+    case 0:\n+      pat = GEN_FCN (icode) (0);\n+      break;\n+    case 1:\n+      pat = GEN_FCN (icode) (ops[0]);\n+      break;\n+    case 2:\n+      pat = GEN_FCN (icode) (ops[0], ops[1]);\n+      break;\n+    case 3:\n+      pat = GEN_FCN (icode) (ops[0], ops[1], ops[2]);\n+      break;\n+    case 4:\n+      pat = GEN_FCN (icode) (ops[0], ops[1], ops[2], ops[3]);\n+      break;\n+    case 5:\n+      pat = GEN_FCN (icode) (ops[0], ops[1], ops[2], ops[3], ops[4]);\n+      break;\n+    case 6:\n+      pat = GEN_FCN (icode) (ops[0], ops[1], ops[2], ops[3], ops[4], ops[5]);\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  if (!pat)\n+    abort ();\n+\n+  if (d->type == B_CALL || d->type == B_BISLED)\n+    emit_call_insn (pat);\n+  else if (d->type == B_JUMP)\n+    {\n+      emit_jump_insn (pat);\n+      emit_barrier ();\n+    }\n+  else\n+    emit_insn (pat);\n+\n+  return_type = spu_builtin_types[d->parm[0]];\n+  if (d->parm[0] != SPU_BTI_VOID\n+      && GET_MODE (target) != TYPE_MODE (return_type))\n+    {\n+      /* target is the return value.  It should always be the mode of\n+         the builtin function prototype. */\n+      target = spu_force_reg (TYPE_MODE (return_type), target);\n+    }\n+\n+  return target;\n+}\n+\n+rtx\n+spu_expand_builtin (tree exp,\n+\t\t    rtx target,\n+\t\t    rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    int ignore ATTRIBUTE_UNUSED)\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl) - END_BUILTINS;\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  struct spu_builtin_description *d;\n+\n+  if (fcode < NUM_SPU_BUILTINS)\n+    {\n+      d = &spu_builtins[fcode];\n+\n+      return spu_expand_builtin_1 (d, arglist, target);\n+    }\n+  abort ();\n+}\n+"}, {"sha": "b56ff1486e6c660d7a1ac01624a6fa8fbf535767", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66b813d47ff264118b496f2e086591813049ba8/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66b813d47ff264118b496f2e086591813049ba8/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=b66b813d47ff264118b496f2e086591813049ba8", "patch": "@@ -238,6 +238,12 @@ enum reg_class {\n         ((GET_MODE_SIZE (FROM) > 4 || GET_MODE_SIZE (TO) > 4) \\\n \t && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n \n+#define REGISTER_TARGET_PRAGMAS() do {\t\t\t\t\t\\\n+targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n+  /* Don't give warnings about the main() function. */\t\t\t\\\n+warn_main = 0;\t\t\t\t\t\t\t\t\\\n+}while (0);\n+\n \f\n /* Frame Layout */\n "}]}