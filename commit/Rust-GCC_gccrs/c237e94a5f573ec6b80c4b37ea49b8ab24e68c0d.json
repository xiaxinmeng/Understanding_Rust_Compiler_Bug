{"sha": "c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIzN2U5NGE1ZjU3M2VjNmI4MGM0YjM3ZWE0OWI4YWIyNGU2OGMwZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-18T20:25:54Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-18T20:25:54Z"}, "message": "haifa-sched.c: Convert to target hooks.\n\n\t* haifa-sched.c: Convert to target hooks.  Macros replaced\n\tare ISSUE_RATE, ADJUST_COST, ADJUST_PRIORITY, MD_SCHED_INIT,\n\tMD_SCHED_REORDER, MD_SCHED_REORDER2, MD_SCHED_VARIABLE_ISSUE,\n\tMD_SCHED_FINISH, and HAVE_cycle_display.\n\t* target-def.h (TARGET_SCHED_ADJUST_COST,\n\tTARGET_SCHED_ADJUST_PRIORITY, TARGET_SCHED_ISSUE_RATE,\n\tTARGET_SCHED_VARIABLE_ISSUE, TARGET_SCHED_INIT,\n\tTARGET_SCHED_FINISH, TARGET_SCHED_REORDER,\n\tTARGET_SCHED_REORDER2, TARGET_SCHED_CYCLE_DISPLAY):\n\tNew hook #defines to be overridden.\n\t(TARGET_SCHED): Bring them all together.\n\t(TARGET_INITIALIZER): Update.\n\t* target.h: Don't forward declare struct rtx_def.  Use 'rtx'\n\tinstead of 'struct rtx_def *' throughout.\n\t(struct sched): New set of hooks for the scheduler.\n\t* Makefile.in (haifa-sched.o): Depend on target.h.\n\t* doc/tm.texi: Document the new scheduler hooks, together in\n\ttheir own section, instead of scattered around.\n\tFix a bunch of underfull/overfull hboxes.\n\n\t* a29k.h, alpha.h, arm.h, c4x.h, convex.h, d30v.h, i386.h,\n\tia64.h, m32r.h, m88k.h, mips.h, pa.h, rs6000.h, s390.h, sh.h,\n\tsparc.h: Don't define any of the old scheduler macros.\n\n\t* a29k.c, alpha.c, arm.c, c4x.c, convex.c, d30v.c, i386.c,\n\tia64.c, m32r.c, m88k.c, mips.c, pa.c, rs6000.c, s390.c, sh.c,\n\tsparc.c: Create hook functions from code extracted from\n\tcorresponding target header, or make existing hooks static, as\n\tappropriate.  Set the appropriate entries in targetm.\n\n\t* alpha-protos.h, arm-protos.h, c4x-protos.h, d30v-protos.h,\n\ti386-protos.h, ia64-protos.h, m32r-protos.h, pa-protos.h,\n\trs6000-protos.h, s390-protos.h, sparc-protos.h:\n\tRemove prototypes for functions which are now static.\n\n\t* d30v.h, d30v.c, m32r.h, m32r.c: Remove #ifdef HAIFA and\n\trelated gunk; the Haifa scheduler is now the only choice.\n\nFrom-SVN: r45009", "tree": {"sha": "aaae6cbc02ac7bffabdd0d787362314965ff9d55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaae6cbc02ac7bffabdd0d787362314965ff9d55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/comments", "author": null, "committer": null, "parents": [{"sha": "ef89d648b84b126fe6c15be5b09105bf705aa60a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef89d648b84b126fe6c15be5b09105bf705aa60a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef89d648b84b126fe6c15be5b09105bf705aa60a"}], "stats": {"total": 1446, "additions": 782, "deletions": 664}, "files": [{"sha": "a5253e5392685c355e263ea6380d28ee4b52a6f5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -1527,7 +1527,7 @@ regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) insn-config.h \\\n    $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h\n haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n-   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H)\n+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)\n sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h cselib.h $(PARAMS_H) $(TM_P_H)"}, {"sha": "730ff55e7bb63a4eaabcfc48ad147ab4e88f98e3", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -49,6 +49,7 @@ static void check_epilogue_internal_label PARAMS ((FILE *));\n static void output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void a29k_asm_named_section PARAMS ((const char *, unsigned int));\n+static int a29k_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \n #define min(A,B)\t((A) < (B) ? (A) : (B))\n \n@@ -100,6 +101,8 @@ int a29k_compare_fp_p;\n #define TARGET_ASM_FUNCTION_PROLOGUE output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE output_function_epilogue\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST a29k_adjust_cost\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -1578,3 +1581,21 @@ a29k_asm_named_section (name, flags)\n   /* ??? Is it really correct to mark all sections as \"bss\"?  */\n   fprintf (asm_out_file, \"\\t.sect %s, bss\\n\\t.use %s\\n\", name, name);\n }\n+\n+/* Return a new value for COST based on the relationship between INSN\n+   that is dependent on DEP_INSN through the dependence LINK.  The\n+   default is to make no adjustment to COST.\n+\n+   On the a29k, ignore the cost of anti- and output-dependencies.  */\n+static int\n+a29k_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     rtx link;\n+     rtx dep_insn ATTRIBUTE_UNUSED;\n+     int cost;\n+{\n+  if (REG_NOTE_KIND (link) != 0)\n+    return 0;\t/* Anti or output dependence.  */\n+\n+  return cost;\n+}"}, {"sha": "4a63731e84dc51aceee99f511a82271d35c85eac", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -679,15 +679,6 @@ enum reg_class { NO_REGS, LR0_REGS, GENERAL_REGS, BP_REGS, FC_REGS, CR_REGS,\n    most expensive register-register copy.  */\n \n #define MEMORY_MOVE_COST(MODE,CLASS,IN) 6\n-\n-/* A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  On the a29k, ignore the cost of anti- and\n-   output-dependencies.  */\n-#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n-  if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n-    (COST) = 0; /* Anti or output dependence.  */\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "511bfb64d002cd3f022f5ba6df2d7b189cbbecb5", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -99,7 +99,6 @@ extern void alpha_expand_unaligned_store PARAMS ((rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t\t HOST_WIDE_INT));\n extern int alpha_expand_block_move PARAMS ((rtx []));\n extern int alpha_expand_block_clear PARAMS ((rtx []));\n-extern int alpha_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern rtx alpha_return_addr PARAMS ((int, rtx));\n extern rtx alpha_gp_save_rtx PARAMS ((void));\n extern void print_operand PARAMS ((FILE *, rtx, int));"}, {"sha": "999d0509485c8bb40d02bf8ffc10682b8ac5d1c4", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -136,6 +136,12 @@ static rtx alpha_emit_xfloating_compare\n   PARAMS ((enum rtx_code, rtx, rtx));\n static void alpha_output_function_end_prologue\n   PARAMS ((FILE *));\n+static int alpha_adjust_cost\n+  PARAMS ((rtx, rtx, rtx, int));\n+static int alpha_issue_rate\n+  PARAMS ((void));\n+static int alpha_variable_issue\n+  PARAMS ((FILE *, int, rtx, int));\n \n /* Get the number of args of a function in one of two ways.  */\n #if TARGET_ABI_OPEN_VMS\n@@ -163,6 +169,13 @@ static void vms_asm_out_destructor PARAMS ((rtx, int));\n #undef TARGET_ASM_FUNCTION_END_PROLOGUE\n #define TARGET_ASM_FUNCTION_END_PROLOGUE alpha_output_function_end_prologue\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST alpha_adjust_cost\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE alpha_issue_rate\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE alpha_variable_issue\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Parse target option strings. */\n@@ -3542,7 +3555,7 @@ alpha_expand_block_clear (operands)\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n-int\n+static int\n alpha_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;\n      rtx link;\n@@ -3686,6 +3699,27 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n   /* Otherwise, return the default cost. */\n   return cost;\n }\n+\n+/* Function to initialize the issue rate used by the scheduler.  */\n+static int\n+alpha_issue_rate ()\n+{\n+  return (alpha_cpu == PROCESSOR_EV4 ? 2 : 4);\n+}\n+\n+static int\n+alpha_variable_issue (dump, verbose, insn, cim)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int verbose ATTRIBUTE_UNUSED;\n+     rtx insn;\n+     int cim;\n+{\n+    if (recog_memoized (insn) < 0 || get_attr_type (insn) == TYPE_MULTI)\n+      return 0;\n+\n+    return cim - 1;\n+}\n+\n \f\n /* Functions to save and restore alpha_return_addr_rtx.  */\n "}, {"sha": "c1ffe4a4f2b6119720def25114eb39f73caba6af", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -870,11 +870,6 @@ extern int alpha_memory_latency;\n \n /* Provide the cost of a branch.  Exact meaning under development.  */\n #define BRANCH_COST 5\n-\n-/* Adjust the cost of dependencies.  */\n-\n-#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n-  (COST) = alpha_adjust_cost (INSN, LINK, DEP, COST)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1724,15 +1719,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    few bits. */\n #define SHIFT_COUNT_TRUNCATED 1\n \n-/* The EV4 is dual issue; EV5/EV6 are quad issue.  */\n-#define ISSUE_RATE  (alpha_cpu == PROCESSOR_EV4 ? 2 : 4)\n-\n-/* Describe the fact that MULTI instructions are multiple instructions\n-   and so to assume they don't pair with anything.  */\n-#define MD_SCHED_VARIABLE_ISSUE(DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE) \\\n-  if (recog_memoized (INSN) < 0 || get_attr_type (INSN) == TYPE_MULTI)\t   \\\n-     (CAN_ISSUE_MORE) = 0\n-\n /* Compute the cost of computing a constant rtl expression RTX\n    whose rtx-code is CODE.  The body of this macro is a portion\n    of a switch statement.  If the code is computed here,"}, {"sha": "2c3f8318ea15fd4fb04cdeb4cbc0bbe07355bfe0", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -49,7 +49,6 @@ extern RTX_CODE arm_canonicalize_comparison PARAMS ((RTX_CODE, rtx *));\n extern int    legitimate_pic_operand_p\tPARAMS ((rtx));\n extern rtx    legitimize_pic_address\tPARAMS ((rtx, enum machine_mode, rtx));\n extern int    arm_rtx_costs\t\tPARAMS ((rtx, RTX_CODE, RTX_CODE));\n-extern int    arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n extern int    const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n extern int    neg_const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n "}, {"sha": "825a46516d90039aba66ec732398f9d78df221df", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -117,6 +117,8 @@ static int\t arm_comp_type_attributes\tPARAMS ((tree, tree));\n static void\t arm_set_default_type_attributes\tPARAMS ((tree));\n static void\t arm_elf_asm_named_section\tPARAMS ((const char *,\n \t\t\t\t\t\t\t unsigned int));\n+static int\t arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n+\n #undef Hint\n #undef Mmode\n #undef Ulong\n@@ -157,6 +159,9 @@ static void\t arm_elf_asm_named_section\tPARAMS ((const char *,\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN arm_expand_builtin\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST arm_adjust_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -2744,7 +2749,7 @@ arm_rtx_costs (x, code, outer)\n     }\n }\n \n-int\n+static int\n arm_adjust_cost (insn, link, dep, cost)\n      rtx insn;\n      rtx link;"}, {"sha": "784f28fac3967b8baa4dad769a8262834768bb88", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -2446,11 +2446,6 @@ typedef struct\n    conditional instructions */\n #define BRANCH_COST \\\n   (TARGET_ARM ? 4 : (optimize > 1 ? 1 : 0))\n-\n-/* A C statement to update the variable COST based on the relationship\n-   between INSN that is dependent on DEP through dependence LINK.  */\n-#define ADJUST_COST(INSN, LINK, DEP, COST) \\\n-  (COST) = arm_adjust_cost (INSN, LINK, DEP, COST)\n \f\n /* Position Independent Code.  */\n /* We decide which register to use based on the compilation options and"}, {"sha": "3fd1e5652eb7586069d8df80efe1c445957131d8", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -1842,23 +1842,7 @@ do {\t\t\t\t\t\t\t\t\t    \\\n #define NO_RECURSIVE_FUNCTION_CSE\n /* Define this macro if it is as good or better for a function to call\n    itself with an explicit address than to call an address kept in a\n-   register.\n-\n-   `ADJUST_COST (INSN, LINK, DEP_INSN, COST)'\n-   A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  This can be used for example to specify to\n-   the scheduler that an output- or anti-dependence does not incur\n-   the same cost as a data-dependence.\n-\n-   `ADJUST_PRIORITY (INSN)'\n-   A C statement (sans semicolon) to update the integer scheduling\n-   priority `INSN_PRIORITY(INSN)'.  Reduce the priority to execute\n-   the INSN earlier, increase the priority to execute INSN later.\n-   Do not define this macro if you do not need to adjust the\n-   scheduling priorities of insns.  */\n-\n+   register.  */\n \n #define TEXT_SECTION_ASM_OP \"\\t.text\"\n /* A C expression whose value is a string containing the assembler"}, {"sha": "1a3ebcfcd440a4ae802fc1ab3b82fedeb3dde678", "filename": "gcc/config/c4x/c4x-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -107,8 +107,6 @@ extern int c4x_label_conflict PARAMS ((rtx, rtx, rtx));\n \n extern int c4x_address_conflict PARAMS ((rtx, rtx, int, int));\n \n-extern int c4x_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-\n extern void c4x_process_after_reload PARAMS ((rtx));\n \n extern void c4x_rptb_insert PARAMS ((rtx insn));"}, {"sha": "2e7917745c806330e354d99dff2e46d5713000e5", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -194,6 +194,7 @@ static int c4x_label_ref_used_p PARAMS ((rtx, rtx));\n static int c4x_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n static void c4x_insert_attributes PARAMS ((tree, tree *));\n static void c4x_asm_named_section PARAMS ((const char *, unsigned int));\n+static int c4x_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_TYPE_ATTRIBUTE\n@@ -208,6 +209,9 @@ static void c4x_asm_named_section PARAMS ((const char *, unsigned int));\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN c4x_expand_builtin\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST c4x_adjust_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Called to register all of our global variables with the garbage\n@@ -4907,8 +4911,7 @@ c4x_check_laj_p (insn)\n #define\tSETLDA_USE_COST\t2\n #define\tREAD_USE_COST\t2\n \n-\n-int\n+static int\n c4x_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;\n      rtx link;"}, {"sha": "cdc39db30c33362d9f1b5e2954dbadce3b115ba9", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -1953,11 +1953,6 @@ if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\\n \n #define BRANCH_COST\t\t\t8\n \n-/* Adjust the cost of dependencies.  */\n-\n-#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n-  (COST) = c4x_adjust_cost (INSN, LINK, DEP, COST)\n-\n #define\tWORD_REGISTER_OPERATIONS\n \n /* Dividing the Output into Sections.  */"}, {"sha": "6f965a2809dd82bd19d515bc7662467fe5af5e02", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -66,12 +66,15 @@ static rtx convert_arg_pushes ();\n static void expand_movstr_call PARAMS ((rtx *));\n static void convex_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void convex_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+static int convex_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE convex_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE convex_output_function_epilogue\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST convex_adjust_cost\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -111,6 +114,43 @@ convex_output_function_epilogue (file, size)\n   fprintf (file, \"\\tds.h 0\\n\");\n }\n \n+/* Adjust the cost of dependences. */\n+static int\n+convex_adjust_cost (insn, link, dep, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep;\n+     int cost;\n+{\n+  /* Antidependencies don't block issue. */\n+  if (REG_NOTE_KIND (link) != 0)\n+    cost = 0;\n+  /* C38 situations where delay depends on context */\n+  else if (TARGET_C38\n+\t   && GET_CODE (PATTERN (insn)) == SET\n+\t   && GET_CODE (PATTERN (dep)) == SET)\n+    {\n+      enum attr_type insn_type = get_attr_type (insn);\n+      enum attr_type dep_type = get_attr_type (dep);\n+      /* index register must be ready one cycle early */\n+      if (insn_type == TYPE_MLDW || insn_type == TYPE_MLDL\n+          || (insn_type == TYPE_MST\n+\t      && reg_mentioned_p (SET_DEST (PATTERN (dep)),\n+\t\t\t\t  SET_SRC (PATTERN (insn)))))\n+\tcost += 1;\n+      /* alu forwarding off alu takes two */\n+      if (dep_type == TYPE_ALU\n+\t  && insn_type != TYPE_ALU\n+\t  && ! (insn_type == TYPE_MST\n+\t\t&& SET_DEST (PATTERN (dep)) == SET_SRC (PATTERN (insn))))\n+\tcost += 1;\n+    }\n+\n+  return cost;\n+}\n+\n+\n+\n /* Here from OVERRIDE_OPTIONS at startup.  Initialize constant tables. */\n \n void"}, {"sha": "8d11c63618b23317cb034d1fe15c25e1c36082ea", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -1115,35 +1115,6 @@ enum reg_class {\n \n #define BRANCH_COST 0\n \n-/* Adjust the cost of dependences. */\n-\n-#define ADJUST_COST(INSN,LINK,DEP,COST) \t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  /* Antidependencies don't block issue. */\t\t\t\t\\\n-  if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n-    (COST) = 0;\t\t\t\t\t\t\t\t\\\n-  /* C38 situations where delay depends on context */\t\t\t\\\n-  else if (TARGET_C38\t\t\t\t\t\t\t\\\n-\t   && GET_CODE (PATTERN (INSN)) == SET\t\t\t\t\\\n-\t   && GET_CODE (PATTERN (DEP)) == SET)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum attr_type insn_type = get_attr_type (INSN);\t\t\t\\\n-      enum attr_type dep_type = get_attr_type (DEP);\t\t\t\\\n-      /* index register must be ready one cycle early */\t\t\\\n-      if (insn_type == TYPE_MLDW || insn_type == TYPE_MLDL\t\t\\\n-          || (insn_type == TYPE_MST\t\t\t\t\t\\\n-\t      && reg_mentioned_p (SET_DEST (PATTERN (DEP)),\t\t\\\n-\t\t\t\t  SET_SRC (PATTERN (INSN)))))\t\t\\\n-\t(COST) += 1;\t\t\t\t\t\t\t\\\n-      /* alu forwarding off alu takes two */\t\t\t\t\\\n-      if (dep_type == TYPE_ALU\t\t\t\t\t\t\\\n-\t  && insn_type != TYPE_ALU\t\t\t\t\t\\\n-\t  && ! (insn_type == TYPE_MST\t\t\t\t\t\\\n-\t\t&& SET_DEST (PATTERN (DEP)) == SET_SRC (PATTERN (INSN)))) \\\n-\t(COST) += 1;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n /* Convex uses VAX or IEEE floats.\n    Follow the host format. */\n #define TARGET_FLOAT_FORMAT HOST_FLOAT_FORMAT"}, {"sha": "0dfa8f1d141c15180483b75d972adab612b415f1", "filename": "gcc/config/d30v/d30v-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -129,7 +129,6 @@ extern rtx d30v_emit_comparison\t\tPARAMS ((int, rtx, rtx, rtx));\n extern char *d30v_move_2words\t\tPARAMS ((rtx *, rtx));\n extern int d30v_emit_cond_move\t\tPARAMS ((rtx, rtx, rtx, rtx));\n extern void d30v_machine_dependent_reorg PARAMS ((rtx));\n-extern int d30v_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n extern rtx d30v_return_addr\t\tPARAMS ((void));\n #endif\n extern void d30v_init_expanders\t\tPARAMS ((void));"}, {"sha": "2af7b26c27170d0c5a951f926335c5081b6d2110", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -51,6 +51,8 @@ static void d30v_mark_machine_status PARAMS ((struct function *));\n static void d30v_free_machine_status PARAMS ((struct function *));\n static void d30v_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void d30v_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+static int d30v_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+static int d30v_issue_rate PARAMS ((void));\n \n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  */\n@@ -86,6 +88,10 @@ enum reg_class reg_class_from_letter[256];\n #define TARGET_ASM_FUNCTION_PROLOGUE d30v_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE d30v_output_function_epilogue\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST d30v_adjust_cost\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE d30v_issue_rate\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -3490,7 +3496,7 @@ d30v_machine_dependent_reorg (insn)\n /* For the d30v, try to insure that the source operands for a load/store are\n    set 2 cycles before the memory reference.  */\n \n-int\n+static int\n d30v_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;\n      rtx link ATTRIBUTE_UNUSED;\n@@ -3511,13 +3517,22 @@ d30v_adjust_cost (insn, link, dep_insn, cost)\n \t  || (GET_CODE (mem = SET_DEST (set_insn)) == MEM\n \t      && reg_mentioned_p (reg, XEXP (mem, 0))))\n \t{\n-\t  return cost + ((HAIFA_P) ? 2 : 4);\n+\t  return cost + 2;\n \t}\n     }\n \n   return cost;\n }\n \n+/* Function which returns the number of insns that can be\n+   scheduled in the same machine cycle.  This must be constant\n+   over an entire compilation.  The default is 1.  */\n+static int\n+d30v_issue_rate ()\n+{\n+  return 2;\n+}\n+\n \f\n /* Routine to allocate, mark and free a per-function,\n    machine specific structure.  */"}, {"sha": "82598fd659b97285046e91253e5e8c4ea7f89590", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -3630,29 +3630,6 @@ extern const char *d30v_branch_cost_string;\n    with an explicit address than to call an address kept in a register.  */\n /* #define NO_RECURSIVE_FUNCTION_CSE */\n \n-/* A C statement (sans semicolon) to update the integer variable COST based on\n-   the relationship between INSN that is dependent on DEP_INSN through the\n-   dependence LINK.  The default is to make no adjustment to COST.  This can be\n-   used for example to specify to the scheduler that an output- or\n-   anti-dependence does not incur the same cost as a data-dependence.  */\n-\n-#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n-  (COST) = d30v_adjust_cost (INSN, LINK, DEP_INSN, COST)\n-\n-/* A C statement (sans semicolon) to update the integer scheduling\n-   priority `INSN_PRIORITY(INSN)'.  Reduce the priority to execute\n-   the INSN earlier, increase the priority to execute INSN later.\n-   Do not define this macro if you do not need to adjust the\n-   scheduling priorities of insns.  */\n-/* #define ADJUST_PRIORITY (INSN) */\n-\n-/* Macro to determine whether the Haifa scheduler is used.  */\n-#ifdef HAIFA\n-#define HAIFA_P 1\n-#else\n-#define HAIFA_P 0\n-#endif\n-\n \f\n /* Dividing the output into sections.  */\n \n@@ -5764,7 +5741,4 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n extern int d30v_cond_exec;\n extern const char *d30v_cond_exec_string;\n \n-/* Indicate how many instructions can be issued at the same time.  */\n-#define ISSUE_RATE 2\n-\n #endif /* GCC_D30V_H */"}, {"sha": "b97d82f1609111d5a98715d81510655ec1fd3c08", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -131,11 +131,6 @@ extern rtx assign_386_stack_local PARAMS ((enum machine_mode, int));\n extern int ix86_attr_length_immediate_default PARAMS ((rtx, int));\n extern int ix86_attr_length_address_default PARAMS ((rtx));\n \n-extern int ix86_issue_rate PARAMS ((void));\n-extern int ix86_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-extern void ix86_sched_init PARAMS ((FILE *, int));\n-extern int ix86_sched_reorder PARAMS ((FILE *, int, rtx *, int, int));\n-extern int ix86_variable_issue PARAMS ((FILE *, int, rtx, int));\n extern enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n \n extern int x86_64_sign_extended_value PARAMS ((rtx));"}, {"sha": "51d32f6ae514ca74e7c7563ec2b8f2edc1d411bb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -574,6 +574,11 @@ static HOST_WIDE_INT ix86_GOT_alias_set PARAMS ((void));\n static void ix86_adjust_counter PARAMS ((rtx, HOST_WIDE_INT));\n static rtx ix86_expand_aligntest PARAMS ((rtx, int));\n static void ix86_expand_strlensi_unroll_1 PARAMS ((rtx, rtx));\n+static int ix86_issue_rate PARAMS ((void));\n+static int ix86_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+static void ix86_sched_init PARAMS ((FILE *, int, int));\n+static int ix86_sched_reorder PARAMS ((FILE *, int, rtx *, int *, int));\n+static int ix86_variable_issue PARAMS ((FILE *, int, rtx, int));\n \n struct ix86_address\n {\n@@ -649,6 +654,17 @@ static void sco_asm_out_constructor PARAMS ((rtx, int));\n #undef TARGET_ASM_CLOSE_PAREN\n #define TARGET_ASM_CLOSE_PAREN \"\"\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST ix86_adjust_cost\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE ix86_issue_rate\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE ix86_variable_issue\n+#undef TARGET_SCHED_INIT\n+#define TARGET_SCHED_INIT ix86_sched_init\n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER ix86_sched_reorder\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -8373,7 +8389,7 @@ ix86_attr_length_address_default (insn)\n \f\n /* Return the maximum number of instructions a cpu can issue.  */\n \n-int\n+static int\n ix86_issue_rate ()\n {\n   switch (ix86_cpu)\n@@ -8479,7 +8495,7 @@ ix86_agi_dependant (insn, dep_insn, insn_type)\n   return modified_in_p (addr, dep_insn);\n }\n \n-int\n+static int\n ix86_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn, link, dep_insn;\n      int cost;\n@@ -8707,10 +8723,11 @@ ix86_dump_ppro_packet (dump)\n \n /* We're beginning a new block.  Initialize data structures as necessary.  */\n \n-void\n-ix86_sched_init (dump, sched_verbose)\n+static void\n+ix86_sched_init (dump, sched_verbose, veclen)\n      FILE *dump ATTRIBUTE_UNUSED;\n      int sched_verbose ATTRIBUTE_UNUSED;\n+     int veclen ATTRIBUTE_UNUSED;\n {\n   memset (&ix86_sched_data, 0, sizeof (ix86_sched_data));\n }\n@@ -8941,14 +8958,15 @@ ix86_sched_reorder_ppro (ready, e_ready)\n \n /* We are about to being issuing insns for this clock cycle.\n    Override the default sort algorithm to better slot instructions.  */\n-int\n-ix86_sched_reorder (dump, sched_verbose, ready, n_ready, clock_var)\n+static int\n+ix86_sched_reorder (dump, sched_verbose, ready, n_readyp, clock_var)\n      FILE *dump ATTRIBUTE_UNUSED;\n      int sched_verbose ATTRIBUTE_UNUSED;\n      rtx *ready;\n-     int n_ready;\n+     int *n_readyp;\n      int clock_var ATTRIBUTE_UNUSED;\n {\n+  int n_ready = *n_readyp;\n   rtx *e_ready = ready + n_ready - 1;\n \n   if (n_ready < 2)\n@@ -8975,7 +8993,7 @@ ix86_sched_reorder (dump, sched_verbose, ready, n_ready, clock_var)\n /* We are about to issue INSN.  Return the number of insns left on the\n    ready queue that can be issued this cycle.  */\n \n-int\n+static int\n ix86_variable_issue (dump, sched_verbose, insn, can_issue_more)\n      FILE *dump;\n      int sched_verbose;"}, {"sha": "bc5fd0875c434ecc02c5e9582db869c11f0c699d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -2638,29 +2638,6 @@ while (0)\n    register.  */\n \n #define NO_RECURSIVE_FUNCTION_CSE\n-\n-/* A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  This can be used for example to specify to\n-   the scheduler that an output- or anti-dependence does not incur\n-   the same cost as a data-dependence.  */\n-\n-#define ADJUST_COST(insn,link,dep_insn,cost) \\\n-  (cost) = ix86_adjust_cost(insn, link, dep_insn, cost)\n-\n-#define ISSUE_RATE \\\n-  ix86_issue_rate ()\n-\n-#define MD_SCHED_INIT(DUMP, SCHED_VERBOSE, MAX_READY) \\\n-  ix86_sched_init (DUMP, SCHED_VERBOSE)\n-\n-#define MD_SCHED_REORDER(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\\n-  (CIM) = ix86_sched_reorder (DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK)\n-\n-#define MD_SCHED_VARIABLE_ISSUE(DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE) \\\n-  ((CAN_ISSUE_MORE) =\t\t\t\t\t\t\t   \\\n-   ix86_variable_issue (DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE))\n \f\n /* Add any extra modes needed to represent the condition code.\n "}, {"sha": "e9c2c5cc94675890822361069e898b2639b7e110", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -91,13 +91,6 @@ extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,\n extern void ia64_reorg PARAMS((rtx));\n extern void process_for_unwind_directive PARAMS ((FILE *, rtx));\n extern const char *get_bundle_name PARAMS ((int));\n-extern int ia64_issue_rate PARAMS ((void));\n-extern int ia64_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-extern void ia64_sched_init PARAMS ((FILE *, int, int));\n-extern void ia64_sched_finish PARAMS ((FILE *, int));\n-extern int ia64_sched_reorder PARAMS ((FILE *, int, rtx *, int *, int, int));\n-extern int ia64_sched_reorder2 PARAMS ((FILE *, int, rtx *, int *, int));\n-extern int ia64_variable_issue PARAMS ((FILE *, int, rtx, int));\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "360e2b32fab81f05172d00325053c8a437448939", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -141,6 +141,18 @@ static int ia64_valid_type_attribute PARAMS((tree, tree, tree, tree));\n static void ia64_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ia64_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ia64_output_function_end_prologue PARAMS ((FILE *));\n+\n+static int ia64_issue_rate PARAMS ((void));\n+static int ia64_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+static void ia64_sched_init PARAMS ((FILE *, int, int));\n+static void ia64_sched_finish PARAMS ((FILE *, int));\n+static int ia64_internal_sched_reorder PARAMS ((FILE *, int, rtx *,\n+\t\t\t\t\t\tint *, int, int));\n+static int ia64_sched_reorder PARAMS ((FILE *, int, rtx *, int *, int));\n+static int ia64_sched_reorder2 PARAMS ((FILE *, int, rtx *, int *, int));\n+static int ia64_variable_issue PARAMS ((FILE *, int, rtx, int));\n+static rtx ia64_cycle_display PARAMS ((int, rtx));\n+\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_TYPE_ATTRIBUTE\n@@ -159,6 +171,23 @@ static void ia64_output_function_end_prologue PARAMS ((FILE *));\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE ia64_output_function_epilogue\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST ia64_adjust_cost\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE ia64_issue_rate\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE ia64_variable_issue\n+#undef TARGET_SCHED_INIT\n+#define TARGET_SCHED_INIT ia64_sched_init\n+#undef TARGET_SCHED_FINISH\n+#define TARGET_SCHED_FINISH ia64_sched_finish\n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER ia64_sched_reorder\n+#undef TARGET_SCHED_REORDER2\n+#define TARGET_SCHED_REORDER2 ia64_sched_reorder2\n+#undef TARGET_SCHED_CYCLE_DISPLAY\n+#define TARGET_SCHED_CYCLE_DISPLAY ia64_cycle_display\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -5064,7 +5093,7 @@ itanium_split_issue (p, begin)\n \n /* Return the maximum number of instructions a cpu can issue.  */\n \n-int\n+static int\n ia64_issue_rate ()\n {\n   return 6;\n@@ -5087,7 +5116,7 @@ ia64_single_set (insn)\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n-int\n+static int\n ia64_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn, link, dep_insn;\n      int cost;\n@@ -5465,7 +5494,7 @@ rotate_two_bundles (dump)\n \n /* We're beginning a new block.  Initialize data structures as necessary.  */\n \n-void\n+static void\n ia64_sched_init (dump, sched_verbose, max_ready)\n      FILE *dump ATTRIBUTE_UNUSED;\n      int sched_verbose ATTRIBUTE_UNUSED;\n@@ -5987,8 +6016,8 @@ nop_cycles_until (clock_var, dump)\n /* We are about to being issuing insns for this clock cycle.\n    Override the default sort algorithm to better slot instructions.  */\n \n-int\n-ia64_sched_reorder (dump, sched_verbose, ready, pn_ready,\n+static int\n+ia64_internal_sched_reorder (dump, sched_verbose, ready, pn_ready,\n \t\t    reorder_type, clock_var)\n      FILE *dump ATTRIBUTE_UNUSED;\n      int sched_verbose ATTRIBUTE_UNUSED;\n@@ -6139,10 +6168,22 @@ ia64_sched_reorder (dump, sched_verbose, ready, pn_ready,\n \t\t\t  ready, e_ready, reorder_type == 1);\n }\n \n+static int\n+ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, clock_var)\n+     FILE *dump;\n+     int sched_verbose;\n+     rtx *ready;\n+     int *pn_ready;\n+     int clock_var;\n+{\n+  return ia64_internal_sched_reorder (dump, sched_verbose, ready,\n+\t\t\t\t      pn_ready, 0, clock_var);\n+}\n+\n /* Like ia64_sched_reorder, but called after issuing each insn.\n    Override the default sort algorithm to better slot instructions.  */\n \n-int\n+static int\n ia64_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n      FILE *dump ATTRIBUTE_UNUSED;\n      int sched_verbose ATTRIBUTE_UNUSED;\n@@ -6232,8 +6273,9 @@ ia64_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n \n   if (*pn_ready > 0)\n     {\n-      int more = ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, 1,\n-\t\t\t\t     clock_var);\n+      int more = ia64_internal_sched_reorder (dump, sched_verbose,\n+\t\t\t\t\t      ready, pn_ready, 1,\n+\t\t\t\t\t      clock_var);\n       if (more)\n \treturn more;\n       /* Did we schedule a stop?  If so, finish this cycle.  */\n@@ -6253,7 +6295,7 @@ ia64_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n /* We are about to issue INSN.  Return the number of insns left on the\n    ready queue that can be issued this cycle.  */\n \n-int\n+static int\n ia64_variable_issue (dump, sched_verbose, insn, can_issue_more)\n      FILE *dump;\n      int sched_verbose;\n@@ -6315,7 +6357,7 @@ ia64_variable_issue (dump, sched_verbose, insn, can_issue_more)\n \n /* Free data allocated by ia64_sched_init.  */\n \n-void\n+static void\n ia64_sched_finish (dump, sched_verbose)\n      FILE *dump;\n      int sched_verbose;\n@@ -6326,6 +6368,14 @@ ia64_sched_finish (dump, sched_verbose)\n   free (sched_types);\n   free (sched_ready);\n }\n+\n+static rtx\n+ia64_cycle_display (clock, last)\n+     int clock;\n+     rtx last;\n+{\n+  return emit_insn_after (gen_cycle_display (GEN_INT (clock)), last);\n+}\n \f\n /* Emit pseudo-ops for the assembler to describe predicate relations.\n    At present this assumes that we only consider predicate pairs to"}, {"sha": "d1a1feded618afb1ebd85083eb69e28c757bc556", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -2755,40 +2755,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* ??? Investigate.  */\n #define MAX_CONDITIONAL_EXECUTE 12\n \n-/* A C statement (sans semicolon) to update the integer scheduling\n-   priority `INSN_PRIORITY(INSN)'.  */\n-\n-/* ??? Investigate.  */\n-/* #define ADJUST_PRIORITY (INSN) */\n-\n-/* A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  This can be used for example to specify to\n-   the scheduler that an output- or anti-dependence does not incur\n-   the same cost as a data-dependence.  */\n-\n-#define ADJUST_COST(insn,link,dep_insn,cost) \\\n-  (cost) = ia64_adjust_cost(insn, link, dep_insn, cost)\n-\n-#define ISSUE_RATE ia64_issue_rate ()\n-\n-#define MD_SCHED_INIT(DUMP, SCHED_VERBOSE, MAX_READY) \\\n-  ia64_sched_init (DUMP, SCHED_VERBOSE, MAX_READY)\n-\n-#define MD_SCHED_REORDER(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\\n-  (CIM) = ia64_sched_reorder (DUMP, SCHED_VERBOSE, READY, &N_READY, 0, CLOCK)\n-\n-#define MD_SCHED_REORDER2(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\\n-  (CIM) = ia64_sched_reorder2 (DUMP, SCHED_VERBOSE, READY, &N_READY, CLOCK)\n-\n-#define MD_SCHED_FINISH(DUMP, SCHED_VERBOSE) \\\n-  ia64_sched_finish (DUMP, SCHED_VERBOSE)\n-\n-#define MD_SCHED_VARIABLE_ISSUE(DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE) \\\n-  ((CAN_ISSUE_MORE)\t\t\t\t\t\t\t   \\\n-   = ia64_variable_issue (DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE))\n-\n extern int ia64_final_schedule;\n \n #define IA64_UNWIND_INFO\t1"}, {"sha": "fd930403847912007663fc38d089ab29a3564297", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -31,7 +31,6 @@ extern int    m32r_first_insn_address\t\tPARAMS ((void));\n extern void   m32r_expand_prologue\t\tPARAMS ((void));\n extern void   m32r_finalize_pic\t\t\tPARAMS ((void));\n extern void   m32r_asm_file_start\t\tPARAMS ((FILE *));\n-extern void   m32r_sched_init \t\t\tPARAMS ((FILE *, int));\n extern int    direct_return \t\t\tPARAMS ((void));\n #ifdef TREE_CODE\n extern void   m32r_select_section\t\tPARAMS ((tree, int));\n@@ -60,10 +59,6 @@ extern void   m32r_expand_block_move \t\tPARAMS ((rtx *));\n extern void   m32r_print_operand\t\tPARAMS ((FILE *, rtx, int));\n extern void   m32r_print_operand_address\tPARAMS ((FILE *, rtx));\n extern int    m32r_address_cost \t\tPARAMS ((rtx));\n-extern int    m32r_adjust_cost \t\t\tPARAMS ((rtx, rtx, rtx, int));\n-extern int    m32r_adjust_priority \t\tPARAMS ((rtx, int));\n-extern void   m32r_sched_reorder \t\tPARAMS ((FILE *, int, rtx *, int));\n-extern int    m32r_sched_variable_issue \tPARAMS ((FILE *, int, rtx, int));\n extern int    m32r_not_same_reg \t\tPARAMS ((rtx, rtx));\n \n #ifdef HAVE_MACHINE_MODES"}, {"sha": "a9ca24fd224e4ac56c715259b1cdc04b14c77246", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -56,7 +56,7 @@ const char * m32r_sdata_string = M32R_SDATA_DEFAULT;\n enum m32r_sdata m32r_sdata;\n \n /* Scheduler support */\n-int m32r_sched_odd_word_p;\n+static int m32r_sched_odd_word_p;\n \n /* Forward declaration.  */\n static void  init_reg_tables\t\t\tPARAMS ((void));\n@@ -66,6 +66,14 @@ static int   m32r_valid_decl_attribute\t\tPARAMS ((tree, tree,\n \t\t\t\t\t\t\t tree, tree));\n static void  m32r_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void  m32r_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+\n+static int    m32r_adjust_cost \t   PARAMS ((rtx, rtx, rtx, int));\n+static int    m32r_adjust_priority PARAMS ((rtx, int));\n+static void   m32r_sched_init\t   PARAMS ((FILE *, int));\n+static int    m32r_sched_reorder   PARAMS ((FILE *, int, rtx *, int *, int));\n+static int    m32r_variable_issue  PARAMS ((FILE *, int, rtx, int));\n+static int    m32r_issue_rate\t   PARAMS ((void));\n+\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_DECL_ATTRIBUTE\n@@ -76,6 +84,19 @@ static void  m32r_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE m32r_output_function_epilogue\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST m32r_adjust_cost\n+#undef TARGET_SCHED_ADJUST_PRIORITY\n+#define TARGET_SCHED_ADJUST_PRIORITY m32r_adjust_priority\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE m32r_issue_rate\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE m32r_variable_issue\n+#undef TARGET_SCHED_INIT\n+#define TARGET_SCHED_INIT m32r_sched_init\n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER m32r_sched_reorder\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Called by OVERRIDE_OPTIONS to initialize various things.  */\n@@ -1471,7 +1492,7 @@ m32r_va_arg (valist, type)\n   return addr_rtx;\n }\n \f\n-int\n+static int\n m32r_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn ATTRIBUTE_UNUSED;\n      rtx link ATTRIBUTE_UNUSED;\n@@ -1497,7 +1518,7 @@ m32r_is_insn (insn)\n /* Increase the priority of long instructions so that the\n    short instructions are scheduled ahead of the long ones.  */\n \n-int\n+static int\n m32r_adjust_priority (insn, priority)\n      rtx insn;\n      int priority;\n@@ -1512,7 +1533,7 @@ m32r_adjust_priority (insn, priority)\n \f\n /* Initialize for scheduling a group of instructions.  */\n \n-void\n+static void\n m32r_sched_init (stream, verbose)\n      FILE * stream ATTRIBUTE_UNUSED;\n      int verbose ATTRIBUTE_UNUSED;\n@@ -1523,15 +1544,18 @@ m32r_sched_init (stream, verbose)\n \f\n /* Reorder the schedulers priority list if needed */\n \n-void\n-m32r_sched_reorder (stream, verbose, ready, n_ready)\n+static int\n+m32r_sched_reorder (stream, verbose, ready, n_readyp, clock)\n      FILE * stream;\n      int verbose;\n      rtx * ready;\n-     int n_ready;\n+     int *n_readyp;\n+     int clock ATTRIBUTE_UNUSED;\n {\n+  int n_ready = *n_readyp;\n+\n   if (TARGET_DEBUG)\n-    return;\n+    return m32r_issue_rate ();\n \n   if (verbose <= 7)\n     stream = (FILE *)0;\n@@ -1605,11 +1629,8 @@ m32r_sched_reorder (stream, verbose, ready, n_ready)\n       memcpy (ready, new_head, sizeof (rtx) * n_ready);\n       if (stream)\n \t{\n-#ifdef HAIFA\n-\t  fprintf (stream, \";;\\t\\t::: New ready list:               \");\n-\t  debug_ready_list (ready, n_ready);\n-#else\n \t  int i;\n+\t  fprintf (stream, \";;\\t\\t::: New ready list:               \");\n \t  for (i = 0; i < n_ready; i++)\n \t    {\n \t      rtx insn = ready[i];\n@@ -1627,17 +1648,27 @@ m32r_sched_reorder (stream, verbose, ready, n_ready)\n \t    }\n \n \t  fprintf (stream, \"\\n\");\n-#endif\n \t}\n     }\n+  return m32r_issue_rate ();\n+}\n+\n+/* Indicate how many instructions can be issued at the same time.\n+   This is sort of a lie.  The m32r can issue only 1 long insn at\n+   once, but it can issue 2 short insns.  The default therefore is\n+   set at 2, but this can be overridden by the command line option\n+   -missue-rate=1 */\n+static int\n+m32r_issue_rate ()\n+{\n+  return ((TARGET_LOW_ISSUE_RATE) ? 1 : 2);\n }\n \n-\f\n /* If we have a machine that can issue a variable # of instructions\n    per cycle, indicate how many more instructions can be issued\n    after the current one.  */\n-int\n-m32r_sched_variable_issue (stream, verbose, insn, how_many)\n+static int\n+m32r_variable_issue (stream, verbose, insn, how_many)\n      FILE * stream;\n      int verbose;\n      rtx insn;"}, {"sha": "5ef9951cd6b8a18fea9c5e2af491f89f5c10990f", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 4, "deletions": 57, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -154,8 +154,8 @@ extern int target_flags;\n #define TARGET_ALIGN_LOOPS \t(target_flags & TARGET_ALIGN_LOOPS_MASK)\n \n /* Change issue rate.  */\n-#define TARGET_ISSUE_RATE_MASK\t(1 << 3)\n-#define TARGET_ISSUE_RATE\t(target_flags & TARGET_ISSUE_RATE_MASK)\n+#define TARGET_LOW_ISSUE_RATE_MASK\t(1 << 3)\n+#define TARGET_LOW_ISSUE_RATE\t(target_flags & TARGET_LOW_ISSUE_RATE_MASK)\n \n /* Change branch cost */\n #define TARGET_BRANCH_COST_MASK\t(1 << 4)\n@@ -187,9 +187,9 @@ extern int target_flags;\n     { \"align-loops\",\t\tTARGET_ALIGN_LOOPS_MASK, \t\t\\\n \tN_(\"Align all loops to 32 byte boundary\") },\t\t\t\\\n     { \"no-align-loops\",\t\t-TARGET_ALIGN_LOOPS_MASK, \"\" },\t\t\\\n-    { \"issue-rate=1\",\t\tTARGET_ISSUE_RATE_MASK, \t\t\\\n+    { \"issue-rate=1\",\t\tTARGET_LOW_ISSUE_RATE_MASK, \t\t\\\n \tN_(\"Only issue one instruction per cycle\") },\t\t\t\\\n-    { \"issue-rate=2\",\t\t-TARGET_ISSUE_RATE_MASK, \"\" },\t\t\\\n+    { \"issue-rate=2\",\t\t-TARGET_LOW_ISSUE_RATE_MASK, \"\" },\t\\\n     { \"branch-cost=1\",\t\tTARGET_BRANCH_COST_MASK, \t\t\\\n \tN_(\"Prefer branches over conditional execution\") },\t\t\\\n     { \"branch-cost=2\",\t\t-TARGET_BRANCH_COST_MASK, \"\" },\t\t\\\n@@ -1473,59 +1473,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    register.  */\n #define NO_RECURSIVE_FUNCTION_CSE\n \n-/* A C statement (sans semicolon) to update the integer variable COST based on\n-   the relationship between INSN that is dependent on DEP_INSN through the\n-   dependence LINK.  The default is to make no adjustment to COST.  This can be\n-   used for example to specify to the scheduler that an output- or\n-   anti-dependence does not incur the same cost as a data-dependence.  */\n-\n-#define ADJUST_COST(INSN,LINK,DEP_INSN,COST) \\\n-  (COST) = m32r_adjust_cost (INSN, LINK, DEP_INSN, COST)\n-\n-/* A C statement (sans semicolon) to update the integer scheduling\n-   priority `INSN_PRIORITY(INSN)'.  Reduce the priority to execute\n-   the INSN earlier, increase the priority to execute INSN later.\n-   Do not define this macro if you do not need to adjust the\n-   scheduling priorities of insns.  */\n-#define ADJUST_PRIORITY(INSN) \\\n-  INSN_PRIORITY (INSN) = m32r_adjust_priority (INSN, INSN_PRIORITY (INSN))\n-\n-/* Macro to determine whether the Haifa scheduler is used.  */\n-#ifdef HAIFA\n-#define HAIFA_P 1\n-#else\n-#define HAIFA_P 0\n-#endif\n-\n-/* Indicate how many instructions can be issued at the same time.\n-   This is sort of a lie.  The m32r can issue only 1 long insn at\n-   once, but it can issue 2 short insns.  The default therefore is\n-   set at 2, but this can be overridden by the command line option\n-   -missue-rate=1 */\n-#define ISSUE_RATE ((TARGET_ISSUE_RATE) ? 1 : 2)\n-\n-/* If we have a machine that can issue a variable # of instructions\n-   per cycle, indicate how many more instructions can be issued\n-   after the current one.  */\n-#define MD_SCHED_VARIABLE_ISSUE(STREAM, VERBOSE, INSN, HOW_MANY)\t\\\n-(HOW_MANY) = m32r_sched_variable_issue (STREAM, VERBOSE, INSN, HOW_MANY)\n-\n-/* Whether we are on an odd word boundary while scheduling.  */\n-extern int m32r_sched_odd_word_p;\n-\n-/* Hook to run before scheduling a block of insns.  */\n-#define MD_SCHED_INIT(STREAM, VERBOSE, MAX_READY) \\\n-  m32r_sched_init (STREAM, VERBOSE)\n-\n-/* Hook to reorder the list of ready instructions.  */\n-#define MD_SCHED_REORDER(STREAM, VERBOSE, READY, N_READY, CLOCK, CIM) \t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      m32r_sched_reorder (STREAM, VERBOSE, READY, N_READY);\t\t\\\n-      CIM = issue_rate;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n /* When the `length' insn attribute is used, this macro specifies the\n    value to be assigned to the address of the first insn in a\n    function.  If not specified, 0 is used.  */"}, {"sha": "34ca9140e3b07ce909b9817040da82476cf3546d", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -72,6 +72,8 @@ static void m88k_output_function_begin_epilogue PARAMS ((FILE *));\n static void m88k_svr3_asm_out_constructor PARAMS ((rtx, int));\n static void m88k_svr3_asm_out_destructor PARAMS ((rtx, int));\n #endif\n+\n+static int m88k_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n@@ -83,6 +85,9 @@ static void m88k_svr3_asm_out_destructor PARAMS ((rtx, int));\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE m88k_output_function_epilogue\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST m88k_adjust_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Determine what instructions are needed to manufacture the integer VALUE\n@@ -3316,3 +3321,30 @@ m88k_svr3_asm_out_destructor (symbol, priority)\n     assemble_integer (constm1_rtx, UNITS_PER_WORD, BITS_PER_WORD, 1);\n }\n #endif\n+\n+/* Adjust the cost of INSN based on the relationship between INSN that\n+   is dependent on DEP_INSN through the dependence LINK.  The default\n+   is to make no adjustment to COST.\n+\n+   On the m88k, ignore the cost of anti- and output-dependencies.  On\n+   the m88100, a store can issue two cycles before the value (not the\n+   address) has finished computing.  */\n+\n+static int\n+m88k_adjust_cost (insn, link, dep, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep;\n+     int cost;\n+{\n+  if (REG_NOTE_KIND (link) != 0)\n+    return 0;  /* Anti or output dependence.  */\n+\n+  if (! TARGET_88100\n+      && recog_memoized (insn) >= 0\n+      && get_attr_type (insn) == TYPE_STORE\n+      && SET_SRC (PATTERN (insn)) == SET_DEST (PATTERN (dep)))\n+    return cost - 4;  /* 88110 store reservation station.  */\n+\n+  return cost;\n+}"}, {"sha": "c30c81891f4d260bceed31df9522efbf4414e725", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -1638,23 +1638,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n /* Provide the cost of a branch.  Exact meaning under development.  */\n #define BRANCH_COST (TARGET_88100 ? 1 : 2)\n \n-/* A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  On the m88k, ignore the cost of anti- and\n-   output-dependencies.  On the m88100, a store can issue two cycles\n-   before the value (not the address) has finished computing.  */\n-#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n-      (COST) = 0; /* Anti or output dependence.  */\t\t\t\\\n-    else if (! TARGET_88100\t\t\t\t\t\t\\\n-\t     && recog_memoized (INSN) >= 0\t\t\t\t\\\n-\t     && get_attr_type (INSN) == TYPE_STORE\t\t\t\\\n-\t     && SET_SRC (PATTERN (INSN)) == SET_DEST (PATTERN (DEP_INSN))) \\\n-      (COST) -= 4; /* 88110 store reservation station.  */\t\t\\\n-  } while (0)\n-\n /* Do not break .stabs pseudos into continuations.  */\n #define DBX_CONTIN_LENGTH 0\n \f"}, {"sha": "268c7f47a1389a59c1f836870a13f4fbe885d92a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -126,6 +126,7 @@ static int iris_section_align_entry_eq\t\tPARAMS ((const PTR, const PTR));\n static hashval_t iris_section_align_entry_hash\tPARAMS ((const PTR));\n static int iris6_section_align_1\t\tPARAMS ((void **, void *));\n #endif\n+static int mips_adjust_cost\t\t\tPARAMS ((rtx, rtx, rtx, int));\n \n /* Global variables for machine-dependent things.  */\n \n@@ -455,6 +456,9 @@ enum reg_class mips_char_to_class[256] =\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE mips_output_function_epilogue\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST mips_adjust_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return truth value of whether OP can be used as an operands\n@@ -9743,6 +9747,23 @@ mips_parse_cpu (cpu_string)\n   return cpu;\n }\n \n+/* Adjust the cost of INSN based on the relationship between INSN that\n+   is dependent on DEP_INSN through the dependence LINK.  The default\n+   is to make no adjustment to COST.\n+\n+   On the MIPS, ignore the cost of anti- and output-dependencies.  */\n+static int\n+mips_adjust_cost (insn, link, dep, cost)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     rtx link;\n+     rtx dep ATTRIBUTE_UNUSED;\n+     int cost;\n+{\n+  if (REG_NOTE_KIND (link) != 0)\n+    return 0;\t/* Anti or output dependence.  */\n+  return cost;\n+}\n+\n /* Cover function for UNIQUE_SECTION.  */\n \n void\n@@ -9815,6 +9836,7 @@ mips_unique_section (decl, reloc)\n \n   DECL_SECTION_NAME (decl) = build_string (len, string);\n }\n+\n \f\n #ifdef TARGET_IRIX6\n /* Output assembly to switch to section NAME with attribute FLAGS.  */"}, {"sha": "e09fb121e431d55f205b8225702fd4cb41abcf15", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -3688,16 +3688,6 @@ while (0)\n     && (TUNE_MIPS4000 || TUNE_MIPS6000))\t\\\n    ? 2 : 1)\n \n-/* A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  On the MIPS, ignore the cost of anti- and\n-   output-dependencies.  */\n-\n-#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n-  if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n-    (COST) = 0; /* Anti or output dependence.  */\n-\n /* If defined, modifies the length assigned to instruction INSN as a\n    function of the context in which it is used.  LENGTH is an lvalue\n    that contains the initially computed length of the insn and should"}, {"sha": "03d4ee23d3caa1e2540a75612a17af289eb18786", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -66,7 +66,6 @@ extern int arith11_operand PARAMS ((rtx, enum machine_mode));\n extern int symbolic_expression_p PARAMS ((rtx));\n extern int hppa_address_cost PARAMS ((rtx));\n extern int symbolic_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int pa_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern int pa_adjust_insn_length PARAMS ((rtx, int));\n extern int int11_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_or_cint_move_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "85183ffc0b02d753e249354c6ab7eec20b3f7006", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -69,6 +69,9 @@ static rtx store_reg PARAMS ((int, int, int));\n static rtx load_reg PARAMS ((int, int, int));\n static rtx set_reg_plus_d PARAMS ((int, int, int));\n static void pa_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+static int pa_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+static int pa_adjust_priority PARAMS ((rtx, int));\n+static int pa_issue_rate PARAMS ((void));\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -115,6 +118,13 @@ int n_deferred_plabels = 0;\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE pa_output_function_epilogue\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST pa_adjust_cost\n+#undef TARGET_SCHED_ADJUST_PRIORITY\n+#define TARGET_SCHED_ADJUST_PRIORITY pa_adjust_priority\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE pa_issue_rate\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n@@ -3591,7 +3601,7 @@ gen_cmp_fp (code, operand0, operand1)\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n-int\n+static int\n pa_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;\n      rtx link;\n@@ -3829,6 +3839,60 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n     abort ();\n }\n \n+/* Adjust scheduling priorities.  We use this to try and keep addil\n+   and the next use of %r1 close together.  */\n+static int\n+pa_adjust_priority (insn, priority)\n+     rtx insn;\n+     int priority;\n+{\n+  rtx set = single_set (insn);\n+  rtx src, dest;\n+  if (set)\n+    {\n+      src = SET_SRC (set);\n+      dest = SET_DEST (set);\n+      if (GET_CODE (src) == LO_SUM\n+\t  && symbolic_operand (XEXP (src, 1), VOIDmode)\n+\t  && ! read_only_operand (XEXP (src, 1), VOIDmode))\n+\tpriority >>= 3;\n+\n+      else if (GET_CODE (src) == MEM\n+\t       && GET_CODE (XEXP (src, 0)) == LO_SUM\n+\t       && symbolic_operand (XEXP (XEXP (src, 0), 1), VOIDmode)\n+\t       && ! read_only_operand (XEXP (XEXP (src, 0), 1), VOIDmode))\n+\tpriority >>= 1;\n+\n+      else if (GET_CODE (dest) == MEM\n+\t       && GET_CODE (XEXP (dest, 0)) == LO_SUM\n+\t       && symbolic_operand (XEXP (XEXP (dest, 0), 1), VOIDmode)\n+\t       && ! read_only_operand (XEXP (XEXP (dest, 0), 1), VOIDmode))\n+\tpriority >>= 3;\n+    }\n+  return priority;\n+}\n+\n+/* The 700 can only issue a single insn at a time.\n+   The 7XXX processors can issue two insns at a time.\n+   The 8000 can issue 4 insns at a time.  */\n+static int\n+pa_issue_rate ()\n+{\n+  switch (pa_cpu)\n+    {\n+    case PROCESSOR_700:\t\treturn 1;\n+    case PROCESSOR_7100:\treturn 2;\n+    case PROCESSOR_7100LC:\treturn 2;\n+    case PROCESSOR_7200:\treturn 2;\n+    case PROCESSOR_8000:\treturn 4;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+\n+\n /* Return any length adjustment needed by INSN which already has its length\n    computed as LENGTH.   Return zero if no adjustment is necessary.\n "}, {"sha": "a6580b8ea06f795340d733c152d7c2fee52980da", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -50,17 +50,6 @@ extern enum processor_type pa_cpu;\n \n #define pa_cpu_attr ((enum attr_cpu)pa_cpu)\n \n-/* The 700 can only issue a single insn at a time.\n-   The 7XXX processors can issue two insns at a time.\n-   The 8000 can issue 4 insns at a time.  */\n-#define ISSUE_RATE \\\n-  (pa_cpu == PROCESSOR_700 ? 1 \\\n-   : pa_cpu == PROCESSOR_7100 ? 2 \\\n-   : pa_cpu == PROCESSOR_7100LC ? 2 \\\n-   : pa_cpu == PROCESSOR_7200 ? 2 \\\n-   : pa_cpu == PROCESSOR_8000 ? 4 \\\n-   : 2)\n-\n /* Which architecture to generate code for.  */\n \n enum architecture_type\n@@ -1651,38 +1640,6 @@ while (0)\n /* Adjust the cost of branches.  */\n #define BRANCH_COST (pa_cpu == PROCESSOR_8000 ? 2 : 1)\n \n-/* Adjust the cost of dependencies.  */\n-\n-#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n-  (COST) = pa_adjust_cost (INSN, LINK, DEP, COST)\n-\n-/* Adjust scheduling priorities.  We use this to try and keep addil\n-   and the next use of %r1 close together.  */\n-#define ADJUST_PRIORITY(PREV) \\\n-  {\t\t\t\t\t\t\t\t\\\n-    rtx set = single_set (PREV);\t\t\t\t\\\n-    rtx src, dest;\t\t\t\t\t\t\\\n-    if (set)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-        src = SET_SRC (set);\t\t\t\t\t\\\n-\tdest = SET_DEST (set);\t\t\t\t\t\\\n-\tif (GET_CODE (src) == LO_SUM\t\t\t\t\\\n-\t    && symbolic_operand (XEXP (src, 1), VOIDmode)\t\\\n-\t    && ! read_only_operand (XEXP (src, 1), VOIDmode))   \\\n-\t  INSN_PRIORITY (PREV) >>= 3;\t\t\t\t\\\n-        else if (GET_CODE (src) == MEM\t\t\t\t\\\n-\t\t && GET_CODE (XEXP (src, 0)) == LO_SUM\t\t\\\n-\t\t && symbolic_operand (XEXP (XEXP (src, 0), 1), VOIDmode)\\\n-\t\t && ! read_only_operand (XEXP (XEXP (src, 0), 1), VOIDmode))\\\n-\t  INSN_PRIORITY (PREV) >>= 1;\t\t\t\t\\\n-\telse if (GET_CODE (dest) == MEM\t\t\t\t\\\n-\t\t && GET_CODE (XEXP (dest, 0)) == LO_SUM\t\t\\\n-\t\t && symbolic_operand (XEXP (XEXP (dest, 0), 1), VOIDmode)\\\n-\t\t && ! read_only_operand (XEXP (XEXP (dest, 0), 1), VOIDmode))\\\n-\t  INSN_PRIORITY (PREV) >>= 3;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  }\n-\n /* Handling the special cases is going to get too complicated for a macro,\n    just call `pa_adjust_insn_length' to do the real work.  */\n #define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\\"}, {"sha": "13a2f3d9704049e6c2ca2f7f2c576d7665f9ad77", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -103,8 +103,6 @@ extern rtx rs6000_emit_set_const PARAMS ((rtx, enum machine_mode, rtx, int));\n extern int rs6000_emit_cmove PARAMS ((rtx, rtx, rtx, rtx));\n extern void rs6000_emit_minmax PARAMS ((rtx, enum rtx_code, rtx, rtx));\n extern void output_toc PARAMS ((FILE *, rtx, int, enum machine_mode));\n-extern int rs6000_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-extern int rs6000_adjust_priority PARAMS ((rtx, int));\n extern void rs6000_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern struct rtx_def *rs6000_longcall_ref PARAMS ((rtx));\n extern void rs6000_fatal_bad_address PARAMS ((rtx));\n@@ -157,7 +155,6 @@ extern void rs6000_file_start PARAMS ((FILE *, const char *));\n extern struct rtx_def *rs6000_float_const PARAMS ((const char *,\n \t\t\t\t\t\t   enum machine_mode));\n extern int direct_return PARAMS ((void));\n-extern int get_issue_rate PARAMS ((void));\n extern union tree_node *rs6000_build_va_list PARAMS ((void));\n extern int first_reg_to_save PARAMS ((void));\n extern int first_fp_reg_to_save PARAMS ((void));"}, {"sha": "4bfb6738a1e3de545d93da86e71e3b04b491aeee", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -141,6 +141,10 @@ static void rs6000_elf_asm_out_destructor PARAMS ((rtx, int));\n #ifdef OBJECT_FORMAT_COFF\n static void xcoff_asm_named_section PARAMS ((const char *, unsigned int));\n #endif\n+static int rs6000_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+static int rs6000_adjust_priority PARAMS ((rtx, int));\n+static int rs6000_issue_rate PARAMS ((void));\n+\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -193,6 +197,13 @@ static char alt_reg_names[][8] =\n #define TARGET_SECTION_TYPE_FLAGS  rs6000_elf_section_type_flags\n #endif\n \n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE rs6000_issue_rate\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST rs6000_adjust_cost\n+#undef TARGET_SCHED_ADJUST_PRIORITY\n+#define TARGET_SCHED_ADJUST_PRIORITY rs6000_adjust_priority\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Override command line options.  Mostly we process the processor\n@@ -7874,7 +7885,7 @@ output_function_profiler (file, labelno)\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n-int\n+static int\n rs6000_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;\n      rtx link;\n@@ -7910,7 +7921,7 @@ rs6000_adjust_cost (insn, link, dep_insn, cost)\n    increase the priority to execute INSN later.  Do not define this macro if\n    you do not need to adjust the scheduling priorities of insns.  */\n \n-int\n+static int\n rs6000_adjust_priority (insn, priority)\n      rtx insn ATTRIBUTE_UNUSED;\n      int priority;\n@@ -7949,7 +7960,8 @@ rs6000_adjust_priority (insn, priority)\n }\n \n /* Return how many instructions the machine can issue per cycle */\n-int get_issue_rate()\n+static int\n+rs6000_issue_rate ()\n {\n   switch (rs6000_cpu_attr) {\n   case CPU_RIOS1:  /* ? */"}, {"sha": "bc3f7889c7c178d0da04ff50206aa566de12a4c8", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -812,24 +812,6 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n \n #define BRANCH_COST 3\n \n-/* A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  On the RS/6000, ignore the cost of anti- and\n-   output-dependencies.  In fact, output dependencies on the CR do have\n-   a cost, but it is probably not worthwhile to track it.  */\n-\n-#define ADJUST_COST(INSN, LINK, DEP_INSN, COST)\t\t\t\t\\\n-  (COST) = rs6000_adjust_cost (INSN,LINK,DEP_INSN,COST)\n-\n-/* A C statement (sans semicolon) to update the integer scheduling priority\n-   INSN_PRIORITY (INSN).  Reduce the priority to execute the INSN earlier,\n-   increase the priority to execute INSN later.  Do not define this macro if\n-   you do not need to adjust the scheduling priorities of insns.  */\n-\n-#define ADJUST_PRIORITY(INSN)\t\t\t\t\t\t\\\n-  INSN_PRIORITY (INSN) = rs6000_adjust_priority (INSN, INSN_PRIORITY (INSN))\n-\n /* Define this macro to change register usage conditional on target flags.\n    Set MQ register fixed (already call_used) if not POWER architecture\n    (RIOS1, RIOS2, RSC, and PPC601) so that it will not be allocated.\n@@ -2632,10 +2614,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* #define  MACHINE_no_sched_speculative */\n /* #define  MACHINE_no_sched_speculative_load */\n \n-/* indicate that issue rate is defined for this machine\n-   (no need to use the default) */\n-#define ISSUE_RATE get_issue_rate ()\n-\n /* General flags.  */\n extern int flag_pic;\n extern int optimize;"}, {"sha": "7f168437ea4bcd2c9acd7dd6cc4ca3bc33643b06", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -53,7 +53,6 @@ extern void emit_pic_move PARAMS ((rtx *, enum machine_mode));\n extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern int s390_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern int s390_stop_dump_lit_p PARAMS ((rtx));\n extern void s390_dump_literal_pool PARAMS ((rtx, rtx));\n extern void s390_trampoline_template PARAMS ((FILE *));"}, {"sha": "425c98e1781bb2bea7f6b3724dcac5bbf17ee08d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"debug.h\"\n \n \n+static int s390_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \n #undef  TARGET_ASM_FUNCTION_PROLOGUE \n #define TARGET_ASM_FUNCTION_PROLOGUE s390_function_prologue\n@@ -58,6 +59,9 @@ Boston, MA 02111-1307, USA.  */\n #undef  TARGET_ASM_CLOSE_PAREN\n #define TARGET_ASM_CLOSE_PAREN \"\"\n \n+#undef  TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST s390_adjust_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n extern int reload_completed;\n@@ -1585,7 +1589,7 @@ addr_generation_dependency_p (dep_rtx, insn)\n    register of a memory reference, at least 4 cycles need to pass\n    between setting and using the register to avoid pipeline stalls.  */\n \n-int\n+static int\n s390_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;\n      rtx link;"}, {"sha": "ba737f226dbd215d3ab35c58ac1ed4da25e224f7", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -1743,17 +1743,6 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n   {\"tmxx_operand\", { CONST_INT, MEM }},\n \n \n-/* A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  This can be used for example to specify to\n-   the scheduler that an output- or anti-dependence does not incur\n-   the same cost as a data-dependence.  */\n-\n-#define ADJUST_COST(insn, link, dep_insn, cost) \\\n-  (cost) = s390_adjust_cost (insn, link, dep_insn, cost)\n-\n-\n /* Constant Pool for all symbols operands which are changed with\n    force_const_mem during insn generation (expand_insn).  */\n "}, {"sha": "b07979d81b363c7c9b85ee6a7f18ddd9087c7da6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -158,6 +158,7 @@ static int sh_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n static void sh_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void sh_insert_attributes PARAMS ((tree, tree *));\n static void sh_asm_named_section PARAMS ((const char *, unsigned int));\n+static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_DECL_ATTRIBUTE\n@@ -169,6 +170,9 @@ static void sh_asm_named_section PARAMS ((const char *, unsigned int));\n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES sh_insert_attributes\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST sh_adjust_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -5566,3 +5570,61 @@ sh_asm_named_section (name, flags)\n   /* ??? Perhaps we should be using default_coff_asm_named_section.  */\n   fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n }\n+\n+/* A C statement (sans semicolon) to update the integer variable COST\n+   based on the relationship between INSN that is dependent on\n+   DEP_INSN through the dependence LINK.  The default is to make no\n+   adjustment to COST.  This can be used for example to specify to\n+   the scheduler that an output- or anti-dependence does not incur\n+   the same cost as a data-dependence.  */\n+static int\n+sh_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep_insn;\n+     int cost;\n+{\n+  rtx reg;\n+\n+  if (GET_CODE(insn) == CALL_INSN)\n+    {\n+      /* The only input for a call that is timing-critical is the\n+\t function's address.  */\n+      rtx call = PATTERN (insn);\n+\n+      if (GET_CODE (call) == PARALLEL)\n+\tcall = XVECEXP (call, 0 ,0);\n+      if (GET_CODE (call) == SET)\n+\tcall = SET_SRC (call);\n+      if (GET_CODE (call) == CALL && GET_CODE (XEXP (call, 0)) == MEM\n+\t  && ! reg_set_p (XEXP (XEXP (call, 0), 0), dep_insn))\n+\tcost = 0;\n+    }\n+  /* All sfunc calls are parallels with at least four components.\n+     Exploit this to avoid unnecessary calls to sfunc_uses_reg.  */\n+  else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t   && XVECLEN (PATTERN (insn), 0) >= 4\n+\t   && (reg = sfunc_uses_reg (insn)))\n+    {\n+      /* Likewise, the most timing critical input for an sfuncs call\n+\t is the function address.  However, sfuncs typically start\n+\t using their arguments pretty quickly.\n+\t Assume a four cycle delay before they are needed.  */\n+      if (! reg_set_p (reg, dep_insn))\n+\tcost -= TARGET_SUPERSCALAR ? 40 : 4;\n+    }\n+  /* Adjust load_si / pcload_si type insns latency.  Use the known\n+     nominal latency and form of the insn to speed up the check.  */\n+  else if (cost == 3\n+\t   && GET_CODE (PATTERN (dep_insn)) == SET\n+\t   /* Latency for dmpy type insns is also 3, so check the that\n+\t      it's actually a move insn.  */\n+\t   && general_movsrc_operand (SET_SRC (PATTERN (dep_insn)), SImode))\n+    cost = 2;\n+  else if (cost == 30\n+\t   && GET_CODE (PATTERN (dep_insn)) == SET\n+\t   && GET_MODE (SET_SRC (PATTERN (dep_insn))) == SImode)\n+    cost = 20;\n+\n+  return cost;\n+}"}, {"sha": "b22684c361b81c4b8be4ceba06251e5581c1cf54", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -2321,58 +2321,6 @@ extern struct rtx_def *fpscr_rtx;\n    clear if this would give better code.  If implemented, should check for\n    compatibility problems.  */\n \n-/* A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  This can be used for example to specify to\n-   the scheduler that an output- or anti-dependence does not incur\n-   the same cost as a data-dependence.  */\n-\n-#define ADJUST_COST(insn,link,dep_insn,cost)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  rtx reg;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE(insn) == CALL_INSN)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* The only input for a call that is timing-critical is the\t\\\n-\t function's address.  */\t\t\t\t\t\\\n-      rtx call = PATTERN (insn);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (call) == PARALLEL)\t\t\t\t\t\\\n-\tcall = XVECEXP (call, 0 ,0);\t\t\t\t\t\\\n-      if (GET_CODE (call) == SET)\t\t\t\t\t\\\n-\tcall = SET_SRC (call);\t\t\t\t\t\t\\\n-      if (GET_CODE (call) == CALL && GET_CODE (XEXP (call, 0)) == MEM\t\\\n-\t  && ! reg_set_p (XEXP (XEXP (call, 0), 0), dep_insn))\t\t\\\n-\t(cost) = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  /* All sfunc calls are parallels with at least four components.\t\\\n-     Exploit this to avoid unnecessary calls to sfunc_uses_reg.  */\t\\\n-  else if (GET_CODE (PATTERN (insn)) == PARALLEL\t\t\t\\\n-\t   && XVECLEN (PATTERN (insn), 0) >= 4\t\t\t\t\\\n-\t   && (reg = sfunc_uses_reg (insn)))\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* Likewise, the most timing critical input for an sfuncs call\t\\\n-\t is the function address.  However, sfuncs typically start\t\\\n-\t using their arguments pretty quickly.\t\t\t\t\\\n-\t Assume a four cycle delay before they are needed.  */\t\t\\\n-      if (! reg_set_p (reg, dep_insn))\t\t\t\t\t\\\n-\tcost -= TARGET_SUPERSCALAR ? 40 : 4;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  /* Adjust load_si / pcload_si type insns latency.  Use the known\t\\\n-     nominal latency and form of the insn to speed up the check.  */\t\\\n-  else if (cost == 3\t\t\t\t\t\t\t\\\n-\t   && GET_CODE (PATTERN (dep_insn)) == SET\t\t\t\\\n-\t   /* Latency for dmpy type insns is also 3, so check the that\t\\\n-\t      it's actually a move insn.  */\t\t\t\t\\\n-\t   && general_movsrc_operand (SET_SRC (PATTERN (dep_insn)), SImode))\\\n-    cost = 2;\t\t\t\t\t\t\t\t\\\n-  else if (cost == 30\t\t\t\t\t\t\t\\\n-\t   && GET_CODE (PATTERN (dep_insn)) == SET\t\t\t\\\n-\t   && GET_MODE (SET_SRC (PATTERN (dep_insn))) == SImode)\t\\\n-    cost = 20;\t\t\t\t\t\t\t\t\\\n-} while (0)\t\t\t\t\t\t\t\t\\\n-\n #define SH_DYNAMIC_SHIFT_COST \\\n   (TARGET_HARD_SH4 ? 1 : TARGET_SH3 ? (TARGET_SMALLCODE ? 1 : 2) : 20)\n "}, {"sha": "fe658296fb56c37ee19874685f601daf2deaea2e", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -50,14 +50,12 @@ extern enum direction function_arg_padding PARAMS ((enum machine_mode, tree));\n #endif /* ARGS_SIZE_RTX */\n #endif /* TREE_CODE */\n \n-extern void ultrasparc_sched_init PARAMS ((FILE *, int));\n extern void load_pic_register PARAMS ((void));\n extern void order_regs_for_local_alloc PARAMS ((void));\n extern int compute_frame_size PARAMS ((int, int));\n extern int check_pic PARAMS ((int));\n extern int short_branch PARAMS ((int, int));\n extern int sparc_flat_epilogue_delay_slots PARAMS ((void));\n-extern int sparc_issue_rate PARAMS ((void));\n extern unsigned long sparc_flat_compute_frame_size PARAMS ((int));\n extern void sparc_function_profiler PARAMS ((FILE *, int));\n extern void sparc_function_block_profiler PARAMS ((FILE *, int));\n@@ -81,8 +79,6 @@ extern int gen_v9_scc PARAMS ((enum rtx_code, rtx *));\n extern void sparc_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern void sparc64_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n-extern void ultrasparc_sched_reorder PARAMS ((FILE *, int, rtx *, int));\n-extern int ultrasparc_variable_issue PARAMS ((rtx));\n extern void sparc_defer_case_vector PARAMS ((rtx, rtx, int));\n extern void sparc_emit_set_const32 PARAMS ((rtx, rtx));\n extern void sparc_emit_set_const64 PARAMS ((rtx, rtx));\n@@ -115,7 +111,6 @@ extern int reg_unused_after PARAMS ((rtx, rtx));\n extern int register_ok_for_ldd PARAMS ((rtx));\n extern int registers_ok_for_ldd_peep PARAMS ((rtx, rtx));\n extern int sparc_flat_eligible_for_epilogue_delay PARAMS ((rtx, int));\n-extern int sparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern int v9_regcmp_p PARAMS ((enum rtx_code));\n extern char *sparc_v8plus_shift PARAMS ((rtx *, rtx, const char *));\n /* Function used for V8+ code generation.  Returns 1 if the high"}, {"sha": "216fc602272e29667cce1967169f6e06f538bc81", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -168,6 +168,16 @@ static void sparc_nonflat_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT,\n static void sparc_nonflat_function_prologue PARAMS ((FILE *, HOST_WIDE_INT,\n \t\t\t\t\t\t     int));\n static void sparc_elf_asm_named_section PARAMS ((const char *, unsigned int));\n+\n+static void ultrasparc_sched_reorder PARAMS ((FILE *, int, rtx *, int));\n+static int ultrasparc_variable_issue PARAMS ((rtx));\n+static void ultrasparc_sched_init PARAMS ((void));\n+\n+static int sparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+static int sparc_issue_rate PARAMS ((void));\n+static int sparc_variable_issue PARAMS ((FILE *, int, rtx, int));\n+static void sparc_sched_init PARAMS ((FILE *, int, int));\n+static int sparc_sched_reorder PARAMS ((FILE *, int, rtx *, int *, int));\n \f\n /* Option handling.  */\n \n@@ -196,6 +206,17 @@ enum processor_type sparc_cpu;\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE sparc_output_function_epilogue\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST sparc_adjust_cost\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE sparc_issue_rate\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE sparc_variable_issue\n+#undef TARGET_SCHED_INIT\n+#define TARGET_SCHED_INIT sparc_sched_init\n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER sparc_sched_reorder\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Validate and override various options, and do some machine dependent\n@@ -7299,7 +7320,7 @@ ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n #undef SLOW_FP\n }\n \n-int\n+static int\n sparc_adjust_cost(insn, link, dep, cost)\n      rtx insn;\n      rtx link;\n@@ -7680,21 +7701,29 @@ ultra_flush_pipeline ()\n }\n \n /* Init our data structures for this current block.  */\n-void\n-ultrasparc_sched_init (dump, sched_verbose)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n+static void\n+ultrasparc_sched_init ()\n {\n   memset ((char *) ultra_pipe_hist, 0, sizeof ultra_pipe_hist);\n   ultra_cur_hist = 0;\n   ultra_cycles_elapsed = 0;\n   ultra_pipe.free_slot_mask = 0xf;\n }\n \n+static void\n+sparc_sched_init (dump, sched_verbose, max_ready)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int sched_verbose ATTRIBUTE_UNUSED;\n+     int max_ready ATTRIBUTE_UNUSED;\n+{\n+  if (sparc_cpu == PROCESSOR_ULTRASPARC)\n+    ultrasparc_sched_init ();\n+}\n+  \n /* INSN has been scheduled, update pipeline commit state\n    and return how many instructions are still to be\n    scheduled in this group.  */\n-int\n+static int\n ultrasparc_variable_issue (insn)\n      rtx insn;\n {\n@@ -7718,6 +7747,19 @@ ultrasparc_variable_issue (insn)\n   return left_to_fire;\n }\n \n+static int\n+sparc_variable_issue (dump, sched_verbose, insn, cim)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int sched_verbose ATTRIBUTE_UNUSED;\n+     rtx insn;\n+     int cim;\n+{\n+  if (sparc_cpu == PROCESSOR_ULTRASPARC)\n+    return ultrasparc_variable_issue (INSN);\n+  else\n+    return cim - 1;\n+}\n+\n /* In actual_hazard_this_instance, we may have yanked some\n    instructions from the ready list due to conflict cost\n    adjustments.  If so, and such an insn was in our pipeline\n@@ -7767,7 +7809,7 @@ ultra_rescan_pipeline_state (ready, n_ready)\n     }\n }\n \n-void\n+static void\n ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n      FILE *dump;\n      int sched_verbose;\n@@ -8053,7 +8095,20 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n     }\n }\n \n-int                                                           \n+static int\n+sparc_sched_reorder (dump, sched_verbose, ready, n_readyp, clock)\n+     FILE *dump;\n+     int sched_verbose;\n+     rtx *ready;\n+     int *n_readyp;\n+     int clock;\n+{\n+  if (sparc_cpu == PROCESSOR_ULTRASPARC)\n+    ultrasparc_sched_reorder (dump, sched_verbose, ready, *n_readyp);\n+  return sparc_issue_rate ();\n+}\n+\n+static int                                                           \n sparc_issue_rate ()\n {\n   switch (sparc_cpu)"}, {"sha": "0e9e5151fe9aa64fb81622d3986b517827f889ea", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -2865,31 +2865,6 @@ do {                                                                    \\\n   case FIX:\t\t\t\t\t\t\\\n     return 19;\n \n-#define ISSUE_RATE  sparc_issue_rate()\n-\n-/* Adjust the cost of dependencies.  */\n-#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n-  (COST) = sparc_adjust_cost(INSN, LINK, DEP, COST)\n-\n-#define MD_SCHED_INIT(DUMP, SCHED_VERBOSE, MAX_READY)\t\t\t\\\n-  if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\t\\\n-    ultrasparc_sched_init (DUMP, SCHED_VERBOSE)\n-\n-#define MD_SCHED_REORDER(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\t\\\n-    ultrasparc_sched_reorder (DUMP, SCHED_VERBOSE, READY, N_READY);\t\\\n-  CIM = issue_rate;\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define MD_SCHED_VARIABLE_ISSUE(DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\t\\\n-    (CAN_ISSUE_MORE) = ultrasparc_variable_issue (INSN);\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    (CAN_ISSUE_MORE)--;\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* Conditional branches with empty delay slots have a length of two.  */\n #define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "8f567dbda8f3a94d707fd924d1407dedd4f1ed3a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 145, "deletions": 123, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -41,6 +41,7 @@ through the macros defined in the @file{.h} file.\n * Addressing Modes::    Defining addressing modes valid for memory operands.\n * Condition Code::      Defining how insns update the condition code.\n * Costs::               Defining relative costs of different operations.\n+* Scheduling::          Adjusting the behavior of the instruction scheduler.\n * Sections::            Dividing storage into text, data, and other sections.\n * PIC::\t\t\tMacros for position independent code.\n * Assembler Format::    Defining how to write insns and pseudo-ops to output.\n@@ -465,8 +466,8 @@ standard choice of @file{/usr/local/include} as the default prefix to\n try when searching for local header files.  @code{LOCAL_INCLUDE_DIR}\n comes before @code{SYSTEM_INCLUDE_DIR} in the search order.\n \n-Cross compilers do not use this macro and do not search either\n-@file{/usr/local/include} or its replacement.\n+Cross compilers do not search either @file{/usr/local/include} or its\n+replacement.\n \n @findex MODIFY_TARGET_NAME\n @item MODIFY_TARGET_NAME\n@@ -1735,19 +1736,18 @@ preserve the entire contents of a register across a call.\n @item CONDITIONAL_REGISTER_USAGE\n Zero or more C statements that may conditionally modify five variables\n @code{fixed_regs}, @code{call_used_regs}, @code{global_regs},\n-(these three are of type @code{char []}), @code{reg_names} (of type\n-@code{const char * []}) and @code{reg_class_contents} (of type\n-@code{HARD_REG_SET}).\n-Before the macro is called @code{fixed_regs}, @code{call_used_regs}\n-@code{reg_class_contents} and @code{reg_names} have been initialized\n+@code{reg_names}, and @code{reg_class_contents}, to take into account\n+any dependence of these register sets on target flags.  The first three\n+of these are of type @code{char []} (interpreted as Boolean vectors).\n+@code{global_regs} is a @code{const char *[]}, and\n+@code{reg_class_contents} is a @code{HARD_REG_SET}.  Before the macro is\n+called, @code{fixed_regs}, @code{call_used_regs},\n+@code{reg_class_contents}, and @code{reg_names} have been initialized\n from @code{FIXED_REGISTERS}, @code{CALL_USED_REGISTERS},\n-@code{REG_CLASS_CONTENTS} and @code{REGISTER_NAMES}, respectively,\n+@code{REG_CLASS_CONTENTS}, and @code{REGISTER_NAMES}, respectively.\n @code{global_regs} has been cleared, and any @option{-ffixed-@var{reg}},\n-@option{-fcall-used-@var{reg}} and @option{-fcall-saved-@var{reg}} command\n-options have been applied.\n-\n-This is necessary in case the fixed or call-clobbered registers depend\n-on target flags.\n+@option{-fcall-used-@var{reg}} and @option{-fcall-saved-@var{reg}}\n+command options have been applied.\n \n You need not define this macro if it has no work to do.\n \n@@ -2025,11 +2025,11 @@ this.\n \n @findex current_function_is_leaf\n @findex current_function_uses_only_leaf_regs\n-Normally, @code{TARGET_ASM_FUNCTION_PROLOGUE} and\n-@code{TARGET_ASM_FUNCTION_EPILOGUE} must treat leaf functions specially.\n-They can test the C variable @code{current_function_is_leaf} which is\n-nonzero for leaf functions.  @code{current_function_is_leaf} is set\n-prior to local register allocation and is valid for the remaining\n+@code{TARGET_ASM_FUNCTION_PROLOGUE} and\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} must usually treat leaf functions\n+specially.  They can test the C variable @code{current_function_is_leaf}\n+which is nonzero for leaf functions.  @code{current_function_is_leaf} is\n+set prior to local register allocation and is valid for the remaining\n compiler passes.  They can also test the C variable\n @code{current_function_uses_only_leaf_regs} which is nonzero for leaf\n functions which only use leaf registers.\n@@ -2528,8 +2528,7 @@ This describes the stack layout and calling conventions.\n * Caller Saves::\n * Function Entry::\n * Profiling::\n-* Inlining::\n-* Tail Calling::\n+* Inlining and Tail Calls::\n @end menu\n \n @node Frame Layout\n@@ -4205,27 +4204,22 @@ profiling when the frame pointer is omitted.\n \n @end table\n \n-@node Inlining\n-@subsection Permitting inlining of functions with attributes\n+@node Inlining and Tail Calls\n+@subsection Permitting inlining and tail calls\n @cindex inlining\n \n-By default if a function has a target specific attribute attached to it,\n-it will not be inlined.  This behaviour can be overridden if the target\n-defines the @samp{FUNCTION_ATTRIBUTE_INLINABLE_P} macro.  This macro\n-takes one argument, a @samp{DECL} describing the function.  It should\n-return non-zero if the function can be inlined, otherwise it should\n-return 0.\n-\n-@node Tail Calling\n-@subsection Permitting tail calls to functions\n-@cindex tail calls\n-@cindex sibling calls\n-\n @table @code\n+@findex FUNCTION_ATTRIBUTE_INLINABLE_P\n+@item FUNCTION_ATTRIBUTE_INLINABLE_P (@var{decl})\n+A C expression that evaluates to true if it is ok to inline @var{decl}\n+into the current function, despite its having target-specific\n+attributes.  By default, if a function has a target specific attribute\n+attached to it, it will not be inlined.\n+\n @findex FUNCTION_OK_FOR_SIBCALL\n @item FUNCTION_OK_FOR_SIBCALL (@var{decl})\n A C expression that evaluates to true if it is ok to perform a sibling\n-call to @var{decl}.\n+call to @var{decl} from the current function.\n \n It is not uncommon for limitations of calling conventions to prevent\n tail calls to functions outside the current unit of translation, or\n@@ -5441,25 +5435,108 @@ function address than to call an address kept in a register.\n Define this macro if it is as good or better for a function to call\n itself with an explicit address than to call an address kept in a\n register.\n-\n-@findex ADJUST_COST\n-@item ADJUST_COST (@var{insn}, @var{link}, @var{dep_insn}, @var{cost})\n-A C statement (sans semicolon) to update the integer variable @var{cost}\n-based on the relationship between @var{insn} that is dependent on\n-@var{dep_insn} through the dependence @var{link}.  The default is to\n-make no adjustment to @var{cost}.  This can be used for example to\n-specify to the scheduler that an output- or anti-dependence does not\n-incur the same cost as a data-dependence.\n-\n-@findex ADJUST_PRIORITY\n-@item ADJUST_PRIORITY (@var{insn})\n-A C statement (sans semicolon) to update the integer scheduling\n-priority @code{INSN_PRIORITY(@var{insn})}.  Reduce the priority\n-to execute the @var{insn} earlier, increase the priority to execute\n-@var{insn} later.    Do not define this macro if you do not need to\n-adjust the scheduling priorities of insns.\n @end table\n \n+@node Scheduling\n+@section Adjusting the Instruction Scheduler\n+\n+The instruction scheduler may need a fair amount of machine-specific\n+adjustment in order to produce good code.  GCC provides several target\n+hooks for this purpose.  It is usually enough to define just a few of\n+them: try the first ones in this list first.\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_ISSUE_RATE (void)\n+This hook returns the maximum number of instructions that can ever issue\n+at the same time on the target machine.  The default is one.  This value\n+must be constant over the entire compilation.  If you need it to vary\n+depending on what the instructions are, you must use\n+@samp{TARGET_SCHED_VARIABLE_ISSUE}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_VARIABLE_ISSUE (FILE *@var{file}, int @var{verbose}, rtx @var{insn}, int @var{more})\n+This hook is executed by the scheduler after it has scheduled an insn\n+from the ready list.  It should return the number of insns which can\n+still be issued in the current cycle.  Normally this is\n+@samp{@w{@var{more} - 1}}.  You should define this hook if some insns\n+take more machine resources than others, so that fewer insns can follow\n+them in the same cycle.  @var{file} is either a null pointer, or a stdio\n+stream to write any debug output to.  @var{verbose} is the verbose level\n+provided by @option{-fsched-verbose-@var{n}}.  @var{insn} is the\n+instruction that was scheduled.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_ADJUST_COST (rtx @var{insn}, rtx @var{link}, rtx @var{dep_insn}, int @var{cost})\n+This function corrects the value of @var{cost} based on the relationship\n+between @var{insn} and @var{dep_insn} through the dependence @var{link}.\n+It should return the new value.  The default is to make no adjustment to\n+@var{cost}.  This can be used for example to specify to the scheduler\n+that an output- or anti-dependence does not incur the same cost as a\n+data-dependence.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_ADJUST_PRIORITY (rtx @var{insn}, int @var{priority})\n+This hook adjusts the integer scheduling priority @var{priority} of\n+@var{insn}.  It should return the new priority.  Reduce the priority to\n+execute @var{insn} earlier, increase the priority to execute @var{insn}\n+later.  Do not define this hook if you do not need to adjust the\n+scheduling priorities of insns.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_REORDER (FILE *@var{file}, int @var{verbose}, rtx *@var{ready}, int *@var{n_readyp}, int @var{clock})\n+This hook is executed by the scheduler after it has scheduled the ready\n+list, to allow the machine description to reorder it (for example to\n+combine two small instructions together on @samp{VLIW} machines).\n+@var{file} is either a null pointer, or a stdio stream to write any\n+debug output to.  @var{verbose} is the verbose level provided by\n+@option{-fsched-verbose-@var{n}}.  @var{ready} is a pointer to the ready\n+list of instructions that are ready to be scheduled.  @var{n_readyp} is\n+a pointer to the number of elements in the ready list.  The scheduler\n+reads the ready list in reverse order, starting with\n+@var{ready}[@var{*n_readyp}-1] and going to @var{ready}[0].  @var{clock}\n+is the timer tick of the scheduler.  You may modify the ready list and\n+the number of ready insns.  The return value is the number of insns that\n+can issue this cycle; normally this is just @code{issue_rate}.  See also\n+@samp{TARGET_SCHED_REORDER2}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_REORDER2 (FILE *@var{file}, int @var{verbose}, rtx *@var{ready}, int *@var{n_ready}, @var{clock})\n+Like @samp{TARGET_SCHED_REORDER}, but called at a different time.  That\n+function is called whenever the scheduler starts a new cycle.  This one\n+is called once per iteration over a cycle, immediately after\n+@samp{TARGET_SCHED_VARIABLE_ISSUE}; it can reorder the ready list and\n+return the number of insns to be scheduled in the same cycle.  Defining\n+this hook can be useful if there are frequent situations where\n+scheduling one insn causes other insns to become ready in the same\n+cycle.  These other insns can then be taken into account properly.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_INIT (FILE *@var{file}, int @var{verbose}, int @var{max_ready})\n+This hook is executed by the scheduler at the beginning of each block of\n+instructions that are to be scheduled.  @var{file} is either a null\n+pointer, or a stdio stream to write any debug output to.  @var{verbose}\n+is the verbose level provided by @option{-fsched-verbose-@var{n}}.\n+@var{max_ready} is the maximum number of insns in the current scheduling\n+region that can be live at the same time.  This can be used to allocate\n+scratch space if it is needed, e.g. by @samp{TARGET_SCHED_REORDER}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_FINISH (FILE *@var{file}, int @var{verbose})\n+This hook is executed by the scheduler at the end of each block of\n+instructions that are to be scheduled.  It can be used to perform\n+cleanup of any actions done by the other scheduling hooks.  @var{file}\n+is either a null pointer, or a stdio stream to write any debug output\n+to.  @var{verbose} is the verbose level provided by\n+@option{-fsched-verbose-@var{n}}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_SCHED_CYCLE_DISPLAY (int @var{clock}, rtx @var{last})\n+This hook is called in verbose mode only, at the beginning of each pass\n+over a basic block.  It should insert an insn into the chain after\n+@var{last}, which has no effect, but records the value @var{clock} in\n+RTL dumps and assembly output.  Define this hook only if you need this\n+level of detail about what the scheduler is doing.\n+@end deftypefn\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between\n@@ -6932,12 +7009,17 @@ numeric index of the assembler language dialect to use, with zero as the\n first variant.\n \n If this macro is defined, you may use constructs of the form\n-@samp{@{option0|option1|option2@dots{}@}} in the output\n-templates of patterns (@pxref{Output Template}) or in the first argument\n-of @code{asm_fprintf}.  This construct outputs @samp{option0},\n-@samp{option1} or @samp{option2}, etc., if the value of\n-@code{ASSEMBLER_DIALECT} is zero, one or two, etc.  Any special\n-characters within these strings retain their usual meaning.\n+@smallexample\n+@samp{@{option0|option1|option2@dots{}@}} \n+@end smallexample\n+@noindent\n+in the output templates of patterns (@pxref{Output Template}) or in the\n+first argument of @code{asm_fprintf}.  This construct outputs\n+@samp{option0}, @samp{option1}, @samp{option2}, etc., if the value of\n+@code{ASSEMBLER_DIALECT} is zero, one, two, etc.  Any special characters\n+within these strings retain their usual meaning.  If there are fewer\n+alternatives within the braces than the value of\n+@code{ASSEMBLER_DIALECT}, the construct outputs nothing.\n \n If you do not define this macro, the characters @samp{@{}, @samp{|} and\n @samp{@}} do not have any special meaning when used in templates or\n@@ -8312,8 +8394,8 @@ The primary reason to define this macro is to provide compatibility with\n other compilers for the same target.  In general, we discourage\n definition of target-specific pragmas for GCC@.\n \n-If the pragma can be implemented by attributes then the macro\n-@samp{INSERT_ATTRIBUTES} might be a useful one to define as well.\n+If the pragma can be implemented by attributes then you should consider\n+defining @samp{INSERT_ATTRIBUTES} as well.\n \n Preprocessor macros that appear on pragma lines are not expanded.  All\n @samp{#pragma} directives that do not match any registered pragma are\n@@ -8561,68 +8643,6 @@ symbols must be explicitly imported from shared libraries (DLLs).\n A C statement that adds to @var{clobbers} @code{STRING_CST} trees for\n any hard regs the port wishes to automatically clobber for all asms.\n \n-@findex ISSUE_RATE\n-@item ISSUE_RATE\n-A C expression that returns how many instructions can be issued at the\n-same time if the machine is a superscalar machine.\n-\n-@findex MD_SCHED_INIT\n-@item MD_SCHED_INIT (@var{file}, @var{verbose}, @var{max_ready})\n-A C statement which is executed by the scheduler at the\n-beginning of each block of instructions that are to be scheduled.\n-@var{file} is either a null pointer, or a stdio stream to write any\n-debug output to.  @var{verbose} is the verbose level provided by\n-@option{-fsched-verbose-@var{n}}.  @var{max_ready} is the maximum number\n-of insns in the current scheduling region that can be live at the same\n-time.  This can be used to allocate scratch space if it is needed.\n-\n-@findex MD_SCHED_FINISH\n-@item MD_SCHED_FINISH (@var{file}, @var{verbose})\n-A C statement which is executed by the scheduler at the end of each block\n-of instructions that are to be scheduled.  It can be used to perform\n-cleanup of any actions done by the other scheduling macros.\n-@var{file} is either a null pointer, or a stdio stream to write any\n-debug output to.  @var{verbose} is the verbose level provided by\n-@option{-fsched-verbose-@var{n}}.\n-\n-@findex MD_SCHED_REORDER\n-@item MD_SCHED_REORDER (@var{file}, @var{verbose}, @var{ready}, @var{n_ready}, @var{clock}, @var{can_issue_more})\n-A C statement which is executed by the scheduler after it\n-has scheduled the ready list to allow the machine description to reorder\n-it (for example to combine two small instructions together on\n-@samp{VLIW} machines).  @var{file} is either a null pointer, or a stdio\n-stream to write any debug output to.  @var{verbose} is the verbose level\n-provided by @option{-fsched-verbose-@var{n}}.  @var{ready} is a pointer to\n-the ready list of instructions that are ready to be scheduled.\n-@var{n_ready} is the number of elements in the ready list.  The\n-scheduler reads the ready list in reverse order, starting with\n-@var{ready}[@var{n_ready}-1] and going to @var{ready}[0].  @var{clock}\n-is the timer tick of the scheduler.  @var{can_issue_more} is an output\n-parameter that is set to the number of insns that can issue this clock;\n-normally this is just @code{issue_rate}.  See also @samp{MD_SCHED_REORDER2}.\n-\n-@findex MD_SCHED_REORDER2\n-@item MD_SCHED_REORDER2 (@var{file}, @var{verbose}, @var{ready}, @var{n_ready}, @var{clock}, @var{can_issue_more})\n-Like @samp{MD_SCHED_REORDER}, but called at a different time.  While the\n-@samp{MD_SCHED_REORDER} macro is called whenever the scheduler starts a\n-new cycle, this macro is used immediately after @samp{MD_SCHED_VARIABLE_ISSUE}\n-is called; it can reorder the ready list and set @var{can_issue_more} to\n-determine whether there are more insns to be scheduled in the same cycle.\n-Defining this macro can be useful if there are frequent situations where\n-scheduling one insn causes other insns to become ready in the same cycle,\n-these other insns can then be taken into account properly.\n-\n-@findex MD_SCHED_VARIABLE_ISSUE\n-@item MD_SCHED_VARIABLE_ISSUE (@var{file}, @var{verbose}, @var{insn}, @var{more})\n-A C statement which is executed by the scheduler after it\n-has scheduled an insn from the ready list.  @var{file} is either a null\n-pointer, or a stdio stream to write any debug output to.  @var{verbose}\n-is the verbose level provided by @option{-fsched-verbose-@var{n}}.\n-@var{insn} is the instruction that was scheduled.  @var{more} is the\n-number of instructions that can be issued in the current cycle.  The\n-@samp{MD_SCHED_VARIABLE_ISSUE} macro is responsible for updating the\n-value of @var{more} (typically by @samp{@var{more}--}).\n-\n @findex MAX_INTEGER_COMPUTATION_MODE\n @item MAX_INTEGER_COMPUTATION_MODE\n Define this to the largest integer machine mode which can be used for\n@@ -8688,6 +8708,7 @@ converting code to conditional execution in the basic blocks\n A C expression to cancel any machine dependent modifications in\n converting code to conditional execution in the basic blocks\n @code{TEST_BB}, @code{THEN_BB}, @code{ELSE_BB}, and @code{JOIN_BB}.\n+@end table\n \n @deftypefn {Target Hook} void TARGET_INIT_BUILTINS ()\n Define this hook if you have any machine-specific built-in functions\n@@ -8702,7 +8723,7 @@ instructions or prefetch instructions).\n To create a built-in function, call the function @code{builtin_function}\n which is defined by the language front end.  You can use any type nodes set\n up by @code{build_common_tree_nodes} and @code{build_common_tree_nodes_2};\n-only language front ends that use these two functions will use\n+only language front ends that use those two functions will call\n @samp{TARGET_INIT_BUILTINS}.\n @end deftypefn\n \n@@ -8718,6 +8739,7 @@ ignored.  This function should return the result of the call to the\n built-in function.\n @end deftypefn\n \n+@table @code\n @findex MD_CAN_REDIRECT_BRANCH\n @item MD_CAN_REDIRECT_BRANCH(@var{branch1}, @var{branch2})\n "}, {"sha": "9e32034cf487d225bb00508a80f26a2869b0d34d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -148,6 +148,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"sched-int.h\"\n+#include \"target.h\"\n \n #ifdef INSN_SCHEDULING\n \n@@ -157,10 +158,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static int issue_rate;\n \n-#ifndef ISSUE_RATE\n-#define ISSUE_RATE 1\n-#endif\n-\n /* sched-verbose controls the amount of debugging output the\n    scheduler prints.  It is controlled by -fsched-verbose=N:\n    N>0 and no -DSR : the output is directed to stderr.\n@@ -693,12 +690,10 @@ insn_cost (insn, link, used)\n \n   if (LINK_COST_FREE (link))\n     cost = 0;\n-#ifdef ADJUST_COST\n-  else if (!LINK_COST_ZERO (link))\n+  else if (!LINK_COST_ZERO (link) && targetm.sched.adjust_cost)\n     {\n-      int ncost = cost;\n+      int ncost = (*targetm.sched.adjust_cost) (used, link, insn, cost);\n \n-      ADJUST_COST (used, link, insn, ncost);\n       if (ncost < 1)\n \t{\n \t  LINK_COST_FREE (link) = 1;\n@@ -708,7 +703,7 @@ insn_cost (insn, link, used)\n \tLINK_COST_ZERO (link) = 1;\n       cost = ncost;\n     }\n-#endif\n+\n   return cost;\n }\n \n@@ -952,7 +947,7 @@ ready_sort (ready)\n \n HAIFA_INLINE static void\n adjust_priority (prev)\n-     rtx prev ATTRIBUTE_UNUSED;\n+     rtx prev;\n {\n   /* ??? There used to be code here to try and estimate how an insn\n      affected register lifetimes, but it did it by looking at REG_DEAD\n@@ -961,9 +956,9 @@ adjust_priority (prev)\n \n      Revisit when we have a machine model to work with and not before.  */\n \n-#ifdef ADJUST_PRIORITY\n-  ADJUST_PRIORITY (prev);\n-#endif\n+  if (targetm.sched.adjust_priority)\n+    INSN_PRIORITY (prev) =\n+      (*targetm.sched.adjust_priority) (prev, INSN_PRIORITY (prev));\n }\n \n /* Clock at which the previous instruction was issued.  */\n@@ -1668,16 +1663,15 @@ schedule_block (b, rgn_n_insns)\n   clear_units ();\n \n   /* Allocate the ready list.  */\n-  ready.veclen = rgn_n_insns + 1 + ISSUE_RATE;\n+  ready.veclen = rgn_n_insns + 1 + issue_rate;\n   ready.first = ready.veclen - 1;\n   ready.vec = (rtx *) xmalloc (ready.veclen * sizeof (rtx));\n   ready.n_ready = 0;\n \n   (*current_sched_info->init_ready_list) (&ready);\n \n-#ifdef MD_SCHED_INIT\n-  MD_SCHED_INIT (sched_dump, sched_verbose, ready.veclen);\n-#endif\n+  if (targetm.sched.md_init)\n+    (*targetm.sched.md_init) (sched_dump, sched_verbose, ready.veclen);\n \n   /* No insns scheduled in this block yet.  */\n   last_scheduled_insn = 0;\n@@ -1706,10 +1700,8 @@ schedule_block (b, rgn_n_insns)\n          list.  */\n       queue_to_ready (&ready);\n \n-#ifdef HAVE_cycle_display\n-      if (HAVE_cycle_display)\n-\tlast = emit_insn_after (gen_cycle_display (GEN_INT (clock_var)), last);\n-#endif\n+      if (sched_verbose && targetm.sched.cycle_display)\n+\tlast = (*targetm.sched.cycle_display) (clock_var, last);\n \n       if (ready.n_ready == 0)\n \tabort ();\n@@ -1725,12 +1717,13 @@ schedule_block (b, rgn_n_insns)\n \n       /* Allow the target to reorder the list, typically for\n \t better instruction bundling.  */\n-#ifdef MD_SCHED_REORDER\n-      MD_SCHED_REORDER (sched_dump, sched_verbose, ready_lastpos (&ready),\n-\t\t\tready.n_ready, clock_var, can_issue_more);\n-#else\n-      can_issue_more = issue_rate;\n-#endif\n+      if (targetm.sched.reorder)\n+\tcan_issue_more =\n+\t  (*targetm.sched.reorder) (sched_dump, sched_verbose,\n+\t\t\t\t    ready_lastpos (&ready),\n+\t\t\t\t    &ready.n_ready, clock_var);\n+      else\n+\tcan_issue_more = issue_rate;\n \n       if (sched_verbose)\n \t{\n@@ -1759,35 +1752,36 @@ schedule_block (b, rgn_n_insns)\n \t  last_scheduled_insn = insn;\n \t  last = move_insn (insn, last);\n \n-#ifdef MD_SCHED_VARIABLE_ISSUE\n-\t  MD_SCHED_VARIABLE_ISSUE (sched_dump, sched_verbose, insn,\n-\t\t\t\t   can_issue_more);\n-#else\n-\t  can_issue_more--;\n-#endif\n+\t  if (targetm.sched.variable_issue)\n+\t    can_issue_more =\n+\t      (*targetm.sched.variable_issue) (sched_dump, sched_verbose,\n+\t\t\t\t\t       insn, can_issue_more);\n+\t  else\n+\t    can_issue_more--;\n \n \t  schedule_insn (insn, &ready, clock_var);\n \n \tnext:\n-\t  ;\n-#ifdef MD_SCHED_REORDER2\n-\t  /* Sort the ready list based on priority.  */\n-\t  if (ready.n_ready > 0)\n-\t    ready_sort (&ready);\n-\t  MD_SCHED_REORDER2 (sched_dump, sched_verbose,\n-\t\t\t     ready.n_ready ? ready_lastpos (&ready) : NULL,\n-\t\t\t     ready.n_ready, clock_var, can_issue_more);\n-#endif\n+\t  if (targetm.sched.reorder2)\n+\t    {\n+\t      /* Sort the ready list based on priority.  */\n+\t      if (ready.n_ready > 0)\n+\t\tready_sort (&ready);\n+\t      can_issue_more =\n+\t\t(*targetm.sched.reorder2) (sched_dump,sched_verbose,\n+\t\t\t\t\t   ready.n_ready\n+\t\t\t\t\t   ? ready_lastpos (&ready) : NULL,\n+\t\t\t\t\t   &ready.n_ready, clock_var);\n+\t    }\n \t}\n \n       /* Debug info.  */\n       if (sched_verbose)\n \tvisualize_scheduled_insns (clock_var);\n     }\n \n-#ifdef MD_SCHED_FINISH\n-  MD_SCHED_FINISH (sched_dump, sched_verbose);\n-#endif\n+  if (targetm.sched.md_finish)\n+    (*targetm.sched.md_finish) (sched_dump, sched_verbose);\n \n   /* Debug info.  */\n   if (sched_verbose)\n@@ -1896,7 +1890,10 @@ sched_init (dump_file)\n \t\t? stderr : dump_file);\n \n   /* Initialize issue_rate.  */\n-  issue_rate = ISSUE_RATE;\n+  if (targetm.sched.issue_rate)\n+    issue_rate = (*targetm.sched.issue_rate) ();\n+  else\n+    issue_rate = 1;\n \n   /* We use LUID 0 for the fake insn (UID 0) which holds dependencies for\n      pseudos which do not cross calls.  */"}, {"sha": "3282b3ca24959fc55d3f94dcce1b146a2f75c50a", "filename": "gcc/target-def.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -82,6 +82,28 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \t\t\tTARGET_ASM_CONSTRUCTOR,\t\t\t\\\n \t\t\tTARGET_ASM_DESTRUCTOR}\n \n+/* Scheduler hooks.  All of these default to null pointers, which\n+   haifa-sched.c looks for and handles.  */\n+#define TARGET_SCHED_ADJUST_COST 0\n+#define TARGET_SCHED_ADJUST_PRIORITY 0\n+#define TARGET_SCHED_ISSUE_RATE 0\n+#define TARGET_SCHED_VARIABLE_ISSUE 0\n+#define TARGET_SCHED_INIT 0\n+#define TARGET_SCHED_FINISH 0\n+#define TARGET_SCHED_REORDER 0\n+#define TARGET_SCHED_REORDER2 0\n+#define TARGET_SCHED_CYCLE_DISPLAY 0\n+\n+#define TARGET_SCHED\t{TARGET_SCHED_ADJUST_COST,\t\\\n+\t\t\t TARGET_SCHED_ADJUST_PRIORITY,\t\\\n+\t\t\t TARGET_SCHED_ISSUE_RATE,\t\\\n+\t\t\t TARGET_SCHED_VARIABLE_ISSUE,\t\\\n+\t\t\t TARGET_SCHED_INIT,\t\t\\\n+\t\t\t TARGET_SCHED_FINISH,\t\t\\\n+\t\t\t TARGET_SCHED_REORDER,\t\t\\\n+\t\t\t TARGET_SCHED_REORDER2,\t\t\\\n+\t\t\t TARGET_SCHED_CYCLE_DISPLAY}\n+\n /* All in tree.c.  */\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes\n #define TARGET_MERGE_TYPE_ATTRIBUTES merge_type_attributes\n@@ -104,6 +126,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\\n   TARGET_ASM_OUT,\t\t\t\t\\\n+  TARGET_SCHED,\t\t\t\t\t\\\n   TARGET_MERGE_DECL_ATTRIBUTES,\t\t\t\\\n   TARGET_MERGE_TYPE_ATTRIBUTES,\t\t\t\\\n   TARGET_VALID_DECL_ATTRIBUTE,\t\t\t\\"}, {"sha": "8d73f496ba0d4a58a2512918c0d7f355a48869b3", "filename": "gcc/target.h", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=c237e94a5f573ec6b80c4b37ea49b8ab24e68c0d", "patch": "@@ -44,9 +44,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    to gradually reduce the amount of conditional compilation that is\n    scattered throughout GCC.  */\n \n-/* Forward declaration for the benefit of prototypes.  */\n-struct rtx_def;\n-\n struct gcc_target\n {\n   /* Functions that output assembler for the target.  */\n@@ -72,12 +69,52 @@ struct gcc_target\n     void (* named_section) PARAMS ((const char *, unsigned int));\n \n     /* Output a constructor for a symbol with a given priority.  */\n-    void (* constructor) PARAMS ((struct rtx_def *, int));\n+    void (* constructor) PARAMS ((rtx, int));\n \n     /* Output a destructor for a symbol with a given priority.  */\n-    void (* destructor) PARAMS ((struct rtx_def *, int));\n+    void (* destructor) PARAMS ((rtx, int));\n   } asm_out;\n \n+  /* Functions relating to instruction scheduling.  */\n+  struct sched\n+  {\n+    /* Given the current cost, COST, of an insn, INSN, calculate and\n+       return a new cost based on its relationship to DEP_INSN through\n+       the dependence LINK.  The default is to make no adjustment.  */\n+    int (* adjust_cost) PARAMS ((rtx insn, rtx link, rtx def_insn, int cost));\n+\n+    /* Adjust the priority of an insn as you see fit.  Returns the new\n+       priority.  */\n+    int (* adjust_priority) PARAMS ((rtx, int));\n+\n+    /* Function which returns the maximum number of insns that can be\n+       scheduled in the same machine cycle.  This must be constant\n+       over an entire compilation.  The default is 1.  */\n+    int (* issue_rate) PARAMS ((void));\n+\n+    /* Calculate how much this insn affects how many more insns we\n+       can emit this cycle.  Default is they all cost the same.  */\n+    int (* variable_issue) PARAMS ((FILE *, int, rtx, int));\n+    \n+    /* Initialize machine-dependent scheduling code.  */\n+    void (* md_init) PARAMS ((FILE *, int, int));\n+\n+    /* Finalize machine-dependent scheduling code.  */\n+    void (* md_finish) PARAMS ((FILE *, int));\n+\n+    /* Reorder insns in a machine-dependent fashion, in two different\n+       places.  Default does nothing.  */\n+    int (* reorder)  PARAMS ((FILE *, int, rtx *, int *, int));\n+    int (* reorder2) PARAMS ((FILE *, int, rtx *, int *, int));\n+\n+    /* cycle_display is a pointer to a function which can emit\n+       data into the assembly stream about the current cycle.\n+       Arguments are CLOCK, the data to emit, and LAST, the last\n+       insn in the new chain we're building.  Returns a new LAST.\n+       The default is to do nothing.  */\n+    rtx (* cycle_display) PARAMS ((int clock, rtx last));\n+  } sched;\n+\n   /* Given two decls, merge their attributes and return the result.  */\n   tree (* merge_decl_attributes) PARAMS ((tree, tree));\n \n@@ -111,11 +148,8 @@ struct gcc_target\n   void (* init_builtins) PARAMS ((void));\n \n   /* Expand a target-specific builtin.  */\n-  struct rtx_def * (* expand_builtin) PARAMS ((tree exp,\n-\t\t\t\t\t       struct rtx_def *target,\n-\t\t\t\t\t       struct rtx_def *subtarget,\n-\t\t\t\t\t       enum machine_mode mode,\n-\t\t\t\t\t       int ignore));\n+  rtx (* expand_builtin) PARAMS ((tree exp, rtx target, rtx subtarget,\n+\t\t\t\t  enum machine_mode mode, int ignore));\n \n   /* Given a decl, a section name, and whether the decl initializer\n      has relocs, choose attributes for the section.  */"}]}