{"sha": "4323afa019227dbcb4b310233c2b6d05ac5152ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyM2FmYTAxOTIyN2RiY2I0YjMxMDIzM2MyYjZkMDVhYzUxNTJlZg==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2013-03-15T04:31:43Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2013-03-15T04:31:43Z"}, "message": "Document HLE / RTM intrinsics\n\nThe TSX HLE/RTM intrinsics were missing documentation. Add this to the\nmanual.\n\ngcc/:\n2013-03-14  Andi Kleen  <ak@linux.intel.com>\n\n\tPR target/56619\n\t* doc/extend.texi: Document __ATOMIC_HLE_ACQUIRE,\n\t__ATOMIC_HLE_RELEASE. Document __builtin_ia32 TSX intrincs.\n\tDocument _x* TSX intrinsics.\n\nFrom-SVN: r196671", "tree": {"sha": "9b2aa589fa9c6d10c83842007fd6f9e590edb841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b2aa589fa9c6d10c83842007fd6f9e590edb841"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4323afa019227dbcb4b310233c2b6d05ac5152ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4323afa019227dbcb4b310233c2b6d05ac5152ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4323afa019227dbcb4b310233c2b6d05ac5152ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4323afa019227dbcb4b310233c2b6d05ac5152ef/comments", "author": null, "committer": null, "parents": [{"sha": "afe1b4a290ffc564cff7ed6ff7d6cda8ccde641a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe1b4a290ffc564cff7ed6ff7d6cda8ccde641a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe1b4a290ffc564cff7ed6ff7d6cda8ccde641a"}], "stats": {"total": 122, "additions": 122, "deletions": 0}, "files": [{"sha": "e94d20db947cb80955256093a4a15505b16e8199", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4323afa019227dbcb4b310233c2b6d05ac5152ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4323afa019227dbcb4b310233c2b6d05ac5152ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4323afa019227dbcb4b310233c2b6d05ac5152ef", "patch": "@@ -1,3 +1,10 @@\n+2013-03-14  Andi Kleen  <ak@linux.intel.com>\n+\n+\tPR target/56619\n+\t* doc/extend.texi: Document __ATOMIC_HLE_ACQUIRE,\n+\t__ATOMIC_HLE_RELEASE. Document __builtin_ia32 TSX intrincs.\n+\tDocument _x* TSX intrinsics.\n+\n 2013-03-14  Edgar E. Iglesias <edgar.iglesias@xilinx.com>\n \t    David Holsgrove <david.holsgrove@xilinx.com>\n "}, {"sha": "627bf696d44819ad822c1ec9bd9c7af074eade07", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4323afa019227dbcb4b310233c2b6d05ac5152ef/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4323afa019227dbcb4b310233c2b6d05ac5152ef/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=4323afa019227dbcb4b310233c2b6d05ac5152ef", "patch": "@@ -79,6 +79,7 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Offsetof::            Special syntax for implementing @code{offsetof}.\n * __sync Builtins::     Legacy built-in functions for atomic memory access.\n * __atomic Builtins::   Atomic built-in functions with memory model.\n+* x86 specific memory model extensions for transactional memory:: x86 memory models.\n * Object Size Checking:: Built-in functions for limited buffer overflow\n                         checking.\n * Other Builtins::      Other built-in functions.\n@@ -7474,6 +7475,37 @@ alignment.  A value of 0 indicates typical alignment should be used.  The\n compiler may also ignore this parameter.\n @end deftypefn\n \n+@node x86 specific memory model extensions for transactional memory\n+@section x86 specific memory model extensions for transactional memory\n+\n+The i386 architecture supports additional memory ordering flags\n+to mark lock critical sections for hardware lock elision. \n+These must be specified in addition to an existing memory model to \n+atomic intrinsics.\n+\n+@table @code\n+@item __ATOMIC_HLE_ACQUIRE\n+Start lock elision on a lock variable.\n+Memory model must be @code{__ATOMIC_ACQUIRE} or stronger.\n+@item __ATOMIC_HLE_RELEASE\n+End lock elision on a lock variable.\n+Memory model must be @code{__ATOMIC_RELEASE} or stronger.\n+@end table\n+\n+When a lock acquire fails it's required for good performance to abort\n+the transaction quickly. This can be done with a @code{_mm_pause}\n+\n+@smallexample\n+#include <immintrin.h> // For _mm_pause\n+\n+/* Acquire lock with lock elision */\n+while (__atomic_exchange_n(&lockvar, 1, __ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE))\n+    _mm_pause(); /* Abort failed transaction */\n+...\n+/* Free lock with lock elision */\n+__atomic_clear(&lockvar, __ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);\n+@end smallexample\n+\n @node Object Size Checking\n @section Object Size Checking Built-in Functions\n @findex __builtin_object_size\n@@ -8745,6 +8777,7 @@ instructions, but allow the compiler to schedule those calls.\n * Blackfin Built-in Functions::\n * FR-V Built-in Functions::\n * X86 Built-in Functions::\n+* X86 transactional memory intrinsics::\n * MIPS DSP Built-in Functions::\n * MIPS Paired-Single Support::\n * MIPS Loongson Built-in Functions::\n@@ -10925,6 +10958,88 @@ v2sf __builtin_ia32_pswapdsf (v2sf)\n v2si __builtin_ia32_pswapdsi (v2si)\n @end smallexample\n \n+The following built-in functions are available when @option{-mrtm} is used\n+They are used for restricted transactional memory. These are the internal\n+low level functions. Normally the functions in \n+@ref{X86 transactional memory intrinsics} should be used instead.\n+\n+@smallexample\n+int __builtin_ia32_xbegin ()\n+void __builtin_ia32_xend ()\n+void __builtin_ia32_xabort (status)\n+int __builtin_ia32_xtest ()\n+@end smallexample\n+\n+@node X86 transactional memory intrinsics\n+@subsection X86 transaction memory intrinsics\n+\n+Hardware transactional memory intrinsics for i386. These allow to use\n+memory transactions with RTM (Restricted Transactional Memory).\n+For using HLE (Hardware Lock Elision) see @ref{x86 specific memory model extensions for transactional memory} instead.\n+This support is enabled with the @option{-mrtm} option.\n+\n+A memory transaction commits all changes to memory in an atomic way,\n+as visible to other threads. If the transaction fails it is rolled back\n+and all side effects discarded.\n+\n+Generally there is no guarantee that a memory transaction ever suceeds\n+and suitable fallback code always needs to be supplied.\n+\n+@deftypefn {RTM Function} {unsigned} _xbegin ()\n+Start a RTM (Restricted Transactional Memory) transaction. \n+Returns _XBEGIN_STARTED when the transaction\n+started successfully (note this is not 0, so the constant has to be \n+explicitely tested). When the transaction aborts all side effects\n+are undone and an abort code is returned. There is no guarantee\n+any transaction ever succeeds, so there always needs to be a valid\n+tested fallback path.\n+@end deftypefn\n+\n+@smallexample\n+#include <immintrin.h>\n+\n+if ((status = _xbegin ()) == _XBEGIN_STARTED) @{\n+    ... transaction code...\n+    _xend ();\n+@} else @{\n+    ... non transactional fallback path...\n+@}\n+@end smallexample\n+\n+Valid abort status bits (when the value is not @code{_XBEGIN_STARTED}) are:\n+\n+@table @code\n+@item _XABORT_EXPLICIT\n+Transaction explicitely aborted with @code{_xabort}. The parameter passed\n+to @code{_xabort} is available with @code{_XABORT_CODE(status)}\n+@item _XABORT_RETRY\n+Transaction retry is possible.\n+@item _XABORT_CONFLICT\n+Transaction abort due to a memory conflict with another thread\n+@item _XABORT_CAPACITY\n+Transaction abort due to the transaction using too much memory\n+@item _XABORT_DEBUG\n+Transaction abort due to a debug trap\n+@item _XABORT_NESTED\n+Transaction abort in a inner nested transaction\n+@end table\n+\n+@deftypefn {RTM Function} {void} _xend ()\n+Commit the current transaction. When no transaction is active this will\n+fault. All memory side effects of the transactions will become visible\n+to other threads in an atomic matter.\n+@end deftypefn\n+\n+@deftypefn {RTM Function} {int} _xtest ()\n+Return a value not zero when a transaction is currently active, otherwise 0.\n+@end deftypefn\n+\n+@deftypefn {RTM Function} {void} _xabort (status)\n+Abort the current transaction. When no transaction is active this is a no-op.\n+status must be a 8bit constant, that is included in the status code returned\n+by @code{_xbegin}\n+@end deftypefn\n+\n @node MIPS DSP Built-in Functions\n @subsection MIPS DSP Built-in Functions\n "}]}