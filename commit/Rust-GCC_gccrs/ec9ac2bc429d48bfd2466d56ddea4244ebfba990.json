{"sha": "ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM5YWMyYmM0MjlkNDhiZmQyNDY2ZDU2ZGRlYTQyNDRlYmZiYTk5MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-04-24T00:05:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-04-24T00:05:57Z"}, "message": "Revert:\n\n\t2007-04-23  Jan Hubicka  <jh@suse.cz>\n\t* function.c (init_function_start): Don't init line number info.\n\t(expand_function_end): Update.\n\t(reset_block_changes, record_block_change, finalize_block_changes,\n\tcheck_block_change, free_block_changes): Kill.\n\t* function.h (reset_block_changes, record_block_change,\n\tfinalize_block_changes, check_block_change, free_block_changes): Remove\n\tprototypes.\n\t(struct function): Remove ib_boundaries_block.\n\t* emit-rtl.c (make_insn_raw, make_jump_insn_raw, make_call_insn_raw):\n\tUse curr_insn_locator to initialize locator.\n\t(emit_line_note): Remove.\n\t* cfgexpand.c (expand_gimple_cond_expr): Update.\n\t(construct_exit_block): Likewise.\n\t(tree_expand_cfg): Initialize/finalize locators.\n\t* expr.c (expand_expr_real): Update.\n\t* cfglayout.c (line_locators_locs, line_locators_lines,\n\tfile_locators_locs, file_locators_files): Remove.\n\t(set_block_levels): Move to cfgexpand.c.\n\t(insn_locators_initialize): Remove.\n\t(pass_insn_locators_initialize): Remove.\n\t(locations_locators_locs, locations_locators_vals): New static vars.\n\t(curr_location, last_location, curr_block, last_block, curr_rtl_loc):\n\tLikewise.\n\t(insn_locators_alloc, insn_locators_finalize,\n\tset_curr_insn_source_location, set_curr_insn_block, curr_insn_locator):\n\tNew functions.\n\t(locator_location): New.\n\t(locator_line, locator_file): Rewrite.\n\t* rtl.h (emit_line_note): Kill.\n\t(insn_locators_alloc, insn_locators_finalize,\n\tset_curr_insn_source_location, set_curr_insn_block, curr_insn_locator):\n\tDeclare.\n\t* tree-inline.c (initialize_cfun): Do not initialize\n\tib_boundaries_block.\n\t* passes.c (pass_insn_locators_initialize): Remove.\n\nFrom-SVN: r124094", "tree": {"sha": "19aa53b591348882b9111f4982435cf750d2b3f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19aa53b591348882b9111f4982435cf750d2b3f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/comments", "author": null, "committer": null, "parents": [{"sha": "edc5f63bf6f3be7c7288a1692734f08c88cc13b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc5f63bf6f3be7c7288a1692734f08c88cc13b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edc5f63bf6f3be7c7288a1692734f08c88cc13b8"}], "stats": {"total": 470, "additions": 316, "deletions": 154}, "files": [{"sha": "5825eccde0326f843cf1f0bb557a42878daf7e3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -1,3 +1,44 @@\n+2007-04-24  Jan Hubicka  <j@suse.cz>\n+\n+\tRevert:\n+\n+\t2007-04-23  Jan Hubicka  <jh@suse.cz>\n+\t* function.c (init_function_start): Don't init line number info.\n+\t(expand_function_end): Update.\n+\t(reset_block_changes, record_block_change, finalize_block_changes,\n+\tcheck_block_change, free_block_changes): Kill.\n+\t* function.h (reset_block_changes, record_block_change,\n+\tfinalize_block_changes, check_block_change, free_block_changes): Remove\n+\tprototypes.\n+\t(struct function): Remove ib_boundaries_block.\n+\t* emit-rtl.c (make_insn_raw, make_jump_insn_raw, make_call_insn_raw):\n+\tUse curr_insn_locator to initialize locator.\n+\t(emit_line_note): Remove.\n+\t* cfgexpand.c (expand_gimple_cond_expr): Update.\n+\t(construct_exit_block): Likewise.\n+\t(tree_expand_cfg): Initialize/finalize locators.\n+\t* expr.c (expand_expr_real): Update.\n+\t* cfglayout.c (line_locators_locs, line_locators_lines,\n+\tfile_locators_locs, file_locators_files): Remove.\n+\t(set_block_levels): Move to cfgexpand.c.\n+\t(insn_locators_initialize): Remove.\n+\t(pass_insn_locators_initialize): Remove.\n+\t(locations_locators_locs, locations_locators_vals): New static vars.\n+\t(curr_location, last_location, curr_block, last_block, curr_rtl_loc):\n+\tLikewise.\n+\t(insn_locators_alloc, insn_locators_finalize,\n+\tset_curr_insn_source_location, set_curr_insn_block, curr_insn_locator):\n+\tNew functions.\n+\t(locator_location): New.\n+\t(locator_line, locator_file): Rewrite.\n+\t* rtl.h (emit_line_note): Kill.\n+\t(insn_locators_alloc, insn_locators_finalize,\n+\tset_curr_insn_source_location, set_curr_insn_block, curr_insn_locator):\n+\tDeclare.\n+\t* tree-inline.c (initialize_cfun): Do not initialize\n+\tib_boundaries_block.\n+\t* passes.c (pass_insn_locators_initialize): Remove.\n+\n 2007-04-24  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* doc/invoke.texi: Removed leading '-' from option index entries."}, {"sha": "ab2b9d36af2f7d1442891a2182aa5c75ed94adc2", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -1265,8 +1265,8 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n   extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n   if (EXPR_LOCUS (stmt))\n     {\n-      set_curr_insn_source_location (*(EXPR_LOCUS (stmt)));\n-      set_curr_insn_block (TREE_BLOCK (stmt));\n+      emit_line_note (*(EXPR_LOCUS (stmt)));\n+      record_block_change (TREE_BLOCK (stmt));\n     }\n \n   /* These flags have no purpose in RTL land.  */\n@@ -1281,7 +1281,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n       add_reg_br_prob_note (last, true_edge->probability);\n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n       if (EXPR_LOCUS (then_exp))\n-\tset_curr_insn_source_location (*(EXPR_LOCUS (then_exp)));\n+\temit_line_note (*(EXPR_LOCUS (then_exp)));\n       return NULL;\n     }\n   if (TREE_CODE (else_exp) == GOTO_EXPR && IS_EMPTY_STMT (then_exp))\n@@ -1290,7 +1290,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n       add_reg_br_prob_note (last, false_edge->probability);\n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n       if (EXPR_LOCUS (else_exp))\n-\tset_curr_insn_source_location (*(EXPR_LOCUS (else_exp)));\n+\temit_line_note (*(EXPR_LOCUS (else_exp)));\n       return NULL;\n     }\n   gcc_assert (TREE_CODE (then_exp) == GOTO_EXPR\n@@ -1322,7 +1322,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n   maybe_dump_rtl_for_tree_stmt (stmt, last2);\n \n   if (EXPR_LOCUS (else_exp))\n-    set_curr_insn_source_location (*(EXPR_LOCUS (else_exp)));\n+    emit_line_note (*(EXPR_LOCUS (else_exp)));\n \n   return new_bb;\n }\n@@ -1613,19 +1613,6 @@ construct_init_block (void)\n   return init_block;\n }\n \n-/* For each lexical block, set BLOCK_NUMBER to the depth at which it is\n-   found in the block tree.  */\n-\n-static void\n-set_block_levels (tree block, int level)\n-{\n-  while (block)\n-    {\n-      BLOCK_NUMBER (block) = level;\n-      set_block_levels (BLOCK_SUBBLOCKS (block), level + 1);\n-      block = BLOCK_CHAIN (block);\n-    }\n-}\n \n /* Create a block containing landing pads and similar stuff.  */\n \n@@ -1650,7 +1637,7 @@ construct_exit_block (void)\n     input_location = cfun->function_end_locus;\n \n   /* The following insns belong to the top scope.  */\n-  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n+  record_block_change (DECL_INITIAL (current_function_decl));\n \n   /* Generate rtl for function exit.  */\n   expand_function_end ();\n@@ -1778,16 +1765,8 @@ tree_expand_cfg (void)\n   /* Some backends want to know that we are expanding to RTL.  */\n   currently_expanding_to_rtl = 1;\n \n-  insn_locators_alloc ();\n-  if (!DECL_BUILT_IN (current_function_decl))\n-    set_curr_insn_source_location (DECL_SOURCE_LOCATION (current_function_decl));\n-  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n-  prologue_locator = curr_insn_locator ();\n-\n-  /* Make sure first insn is a note even if we don't want linenums.\n-     This makes sure the first insn will never be deleted.\n-     Also, final expects a note to appear there.  */\n-  emit_note (NOTE_INSN_DELETED);\n+  /* Prepare the rtl middle end to start recording block changes.  */\n+  reset_block_changes ();\n \n   /* Mark arrays indexed with non-constant indices with TREE_ADDRESSABLE.  */\n   discover_nonconstant_array_refs ();\n@@ -1834,8 +1813,6 @@ tree_expand_cfg (void)\n     bb = expand_gimple_basic_block (bb);\n \n   construct_exit_block ();\n-  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n-  insn_locators_finalize ();\n \n   /* We're done expanding trees to RTL.  */\n   currently_expanding_to_rtl = 0;\n@@ -1866,6 +1843,8 @@ tree_expand_cfg (void)\n      more CONCATs anywhere.  */\n   generating_concat_p = 0;\n \n+  finalize_block_changes ();\n+\n   if (dump_file)\n     {\n       fprintf (dump_file,\n@@ -1896,9 +1875,6 @@ tree_expand_cfg (void)\n   return_label = NULL;\n   naked_return_label = NULL;\n   free_histograms ();\n-  /* Tag the blocks with a depth number so that change_scope can find\n-     the common parent easily.  */\n-  set_block_levels (DECL_INITIAL (cfun->decl), 0);\n   return 0;\n }\n "}, {"sha": "01784319c192d65fd71b57f654ff1f1e1c4adbd9", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 142, "deletions": 107, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -48,6 +48,7 @@ static void record_effective_endpoints (void);\n static rtx label_for_bb (basic_block);\n static void fixup_reorder_chain (void);\n \n+static void set_block_levels (tree, int);\n static void change_scope (rtx, tree, tree);\n \n void verify_insn_chain (void);\n@@ -231,106 +232,121 @@ record_effective_endpoints (void)\n    than the following one.  Similarly for the other properties.  */\n static VEC(int,heap) *block_locators_locs;\n static GTY(()) VEC(tree,gc) *block_locators_blocks;\n-static VEC(int,heap) *locations_locators_locs;\n-DEF_VEC_O(location_t);\n-DEF_VEC_ALLOC_O(location_t,heap);\n-static VEC(location_t,heap) *locations_locators_vals;\n+static VEC(int,heap) *line_locators_locs;\n+static VEC(int,heap) *line_locators_lines;\n+static VEC(int,heap) *file_locators_locs;\n+static GTY(()) varray_type file_locators_files;\n int prologue_locator;\n int epilogue_locator;\n \n-/* Hold current location information and last location information, so the\n-   datastructures are built lazilly only when some instructions in given\n-   place are needed.  */\n-location_t curr_location, last_location;\n-static tree curr_block, last_block;\n-static int curr_rtl_loc = -1;\n+/* During the RTL expansion the lexical blocks and line numbers are\n+   represented via INSN_NOTEs.  Replace them by representation using\n+   INSN_LOCATORs.  */\n \n-/* Allocate insn locator datastructure.  */\n-void\n-insn_locators_alloc (void)\n+unsigned int\n+insn_locators_initialize (void)\n {\n+  tree block = NULL;\n+  tree last_block = NULL;\n+  rtx insn, next;\n+  int loc = 0;\n+  int line_number = 0, last_line_number = 0;\n+  const char *file_name = NULL, *last_file_name = NULL;\n+\n   prologue_locator = epilogue_locator = 0;\n \n   block_locators_locs = VEC_alloc (int, heap, 32);\n   block_locators_blocks = VEC_alloc (tree, gc, 32);\n-  locations_locators_locs = VEC_alloc (int, heap, 32);\n-  locations_locators_vals = VEC_alloc (location_t, heap, 32);\n-\n-#ifdef USE_MAPPED_LOCATION\n-  last_location = -1;\n-  curr_location = -1;\n-#else\n-  last_location.line = -1;\n-  curr_location.line = -1;\n-#endif\n-  curr_block = NULL;\n-  last_block = NULL;\n-  curr_rtl_loc = 0;\n-}\n+  line_locators_locs = VEC_alloc (int, heap, 32);\n+  line_locators_lines = VEC_alloc (int, heap, 32);\n+  file_locators_locs = VEC_alloc (int, heap, 32);\n+  VARRAY_CHAR_PTR_INIT (file_locators_files, 32, \"file_locators_files\");\n \n-/* At the end of emit stage, clear current location.  */\n-void\n-insn_locators_finalize (void)\n-{\n-  if (curr_rtl_loc >= 0)\n-    epilogue_locator = curr_insn_locator ();\n-  curr_rtl_loc = -1;\n-}\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      int active = 0;\n \n-/* Set current location.  */\n-void\n-set_curr_insn_source_location (location_t location)\n-{\n-  gcc_assert (curr_rtl_loc >= 0);\n-#ifdef USE_MAPPED_LOCATION\n-  if (location == last_location)\n-    return;\n-#else\n-  if (location.file && last_location.file\n-      && !strcmp (location.file, last_location.file)\n-      && location.line == last_location.line)\n-    return;\n-#endif\n-  curr_location = location;\n-}\n+      next = NEXT_INSN (insn);\n \n-/* Set current scope block. */\n-void\n-set_curr_insn_block (tree b)\n-{\n-  gcc_assert (curr_rtl_loc >= 0);\n-  if (b)\n-    curr_block = b;\n-}\n+      if (NOTE_P (insn))\n+\t{\n+\t  gcc_assert (NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_BEG\n+\t\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_END);\n+\t  if (NOTE_LINE_NUMBER (insn) > 0)\n+\t    {\n+\t      expanded_location xloc;\n+\t      NOTE_EXPANDED_LOCATION (xloc, insn);\n+\t      line_number = xloc.line;\n+\t      file_name = xloc.file;\n+\t      delete_insn (insn);\n+\t    }\n+\t}\n+      else\n+\tactive = (active_insn_p (insn)\n+\t\t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC);\n \n-/* Return current insn locator.  */\n-int\n-curr_insn_locator (void)\n-{\n-  if (curr_rtl_loc == -1)\n-    return 0;\n-  if (last_block != curr_block)\n-    {\n-      curr_rtl_loc++;\n-      VEC_safe_push (int, heap, block_locators_locs, curr_rtl_loc);\n-      VEC_safe_push (tree, gc, block_locators_blocks, curr_block);\n-      last_block = curr_block;\n-    }\n-#ifdef USE_MAPPED_LOCATION\n-  if (last_location != curr_location)\n-#else\n-  if (last_location.file != curr_location.file\n-      || last_location.line != curr_location.line)\n-#endif\n-    {\n-      curr_rtl_loc++;\n-      VEC_safe_push (int, heap, locations_locators_locs, curr_rtl_loc);\n-      VEC_safe_push (location_t, heap, locations_locators_vals, &curr_location);\n-      last_location = curr_location;\n+      check_block_change (insn, &block);\n+\n+      if (active\n+\t  || !next\n+\t  || (!prologue_locator && file_name))\n+\t{\n+\t  if (last_block != block)\n+\t    {\n+\t      loc++;\n+\t      VEC_safe_push (int, heap, block_locators_locs, loc);\n+\t      VEC_safe_push (tree, gc, block_locators_blocks, block);\n+\t      last_block = block;\n+\t    }\n+\t  if (last_line_number != line_number)\n+\t    {\n+\t      loc++;\n+\t      VEC_safe_push (int, heap, line_locators_locs, loc);\n+\t      VEC_safe_push (int, heap, line_locators_lines, line_number);\n+\t      last_line_number = line_number;\n+\t    }\n+\t  if (last_file_name != file_name)\n+\t    {\n+\t      loc++;\n+\t      VEC_safe_push (int, heap, file_locators_locs, loc);\n+\t      VARRAY_PUSH_CHAR_PTR (file_locators_files, (char *) file_name);\n+\t      last_file_name = file_name;\n+\t    }\n+\t  if (!prologue_locator && file_name)\n+\t    prologue_locator = loc;\n+\t  if (!next)\n+\t    epilogue_locator = loc;\n+\t  if (active)\n+\t    INSN_LOCATOR (insn) = loc;\n+\t}\n     }\n-  return curr_rtl_loc;\n+\n+  /* Tag the blocks with a depth number so that change_scope can find\n+     the common parent easily.  */\n+  set_block_levels (DECL_INITIAL (cfun->decl), 0);\n+\n+  free_block_changes ();\n+  return 0;\n }\n \n+struct tree_opt_pass pass_insn_locators_initialize =\n+{\n+  \"locators\",                           /* name */\n+  NULL,                                 /* gate */\n+  insn_locators_initialize,             /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n static unsigned int\n into_cfg_layout_mode (void)\n {\n@@ -385,6 +401,20 @@ struct tree_opt_pass pass_outof_cfg_layout_mode =\n   TODO_dump_func,                       /* todo_flags_finish */\n   0                                     /* letter */\n };\n+\n+/* For each lexical block, set BLOCK_NUMBER to the depth at which it is\n+   found in the block tree.  */\n+\n+static void\n+set_block_levels (tree block, int level)\n+{\n+  while (block)\n+    {\n+      BLOCK_NUMBER (block) = level;\n+      set_block_levels (BLOCK_SUBBLOCKS (block), level + 1);\n+      block = BLOCK_CHAIN (block);\n+    }\n+}\n \f\n /* Return sope resulting from combination of S1 and S2.  */\n static tree\n@@ -484,16 +514,18 @@ insn_scope (rtx insn)\n }\n \n /* Return line number of the statement specified by the locator.  */\n-static location_t\n-locator_location (int loc)\n+int\n+locator_line (int loc)\n {\n-  int max = VEC_length (int, locations_locators_locs);\n+  int max = VEC_length (int, line_locators_locs);\n   int min = 0;\n \n+  if (!max || !loc)\n+    return 0;\n   while (1)\n     {\n       int pos = (min + max) / 2;\n-      int tmp = VEC_index (int, locations_locators_locs, pos);\n+      int tmp = VEC_index (int, line_locators_locs, pos);\n \n       if (tmp <= loc && min != pos)\n \tmin = pos;\n@@ -505,19 +537,7 @@ locator_location (int loc)\n \t  break;\n \t}\n     }\n-  return *VEC_index (location_t, locations_locators_vals, min);\n-}\n-\n-/* Return source line of the statement that produced this insn.  */\n-int\n-locator_line (int loc)\n-{\n-  expanded_location xloc;\n-  if (!loc)\n-    return 0;\n-  else\n-    xloc = expand_location (locator_location (loc));\n-  return xloc.line;\n+  return VEC_index (int, line_locators_lines, min);\n }\n \n /* Return line number of the statement that produced this insn.  */\n@@ -531,12 +551,27 @@ insn_line (rtx insn)\n const char *\n locator_file (int loc)\n {\n-  expanded_location xloc;\n-  if (!loc)\n-    return 0;\n-  else\n-    xloc = expand_location (locator_location (loc));\n-  return xloc.file;\n+  int max = VEC_length (int, file_locators_locs);\n+  int min = 0;\n+\n+  if (!max || !loc)\n+    return NULL;\n+  while (1)\n+    {\n+      int pos = (min + max) / 2;\n+      int tmp = VEC_index (int, file_locators_locs, pos);\n+\n+      if (tmp <= loc && min != pos)\n+\tmin = pos;\n+      else if (tmp > loc && max != pos)\n+\tmax = pos;\n+      else\n+\t{\n+\t  min = pos;\n+\t  break;\n+\t}\n+    }\n+   return VARRAY_CHAR_PTR (file_locators_files, min);\n }\n \n /* Return source file of the statement that produced this insn.  */"}, {"sha": "16fa6c5ed7c69a9e9afe3e35f000a22b11a6acfb", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -3336,7 +3336,7 @@ make_insn_raw (rtx pattern)\n   INSN_CODE (insn) = -1;\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n-  INSN_LOCATOR (insn) = curr_insn_locator ();\n+  INSN_LOCATOR (insn) = 0;\n   BLOCK_FOR_INSN (insn) = NULL;\n \n #ifdef ENABLE_RTL_CHECKING\n@@ -3369,7 +3369,7 @@ make_jump_insn_raw (rtx pattern)\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n   JUMP_LABEL (insn) = NULL;\n-  INSN_LOCATOR (insn) = curr_insn_locator ();\n+  INSN_LOCATOR (insn) = 0;\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -3390,7 +3390,7 @@ make_call_insn_raw (rtx pattern)\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n   CALL_INSN_FUNCTION_USAGE (insn) = NULL;\n-  INSN_LOCATOR (insn) = curr_insn_locator ();\n+  INSN_LOCATOR (insn) = 0;\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -4460,6 +4460,42 @@ emit_barrier (void)\n   return barrier;\n }\n \n+/* Make line numbering NOTE insn for LOCATION add it to the end\n+   of the doubly-linked list, but only if line-numbers are desired for\n+   debugging info and it doesn't match the previous one.  */\n+\n+rtx\n+emit_line_note (location_t location)\n+{\n+  rtx note;\n+  \n+#ifdef USE_MAPPED_LOCATION\n+  if (location == last_location)\n+    return NULL_RTX;\n+#else\n+  if (location.file && last_location.file\n+      && !strcmp (location.file, last_location.file)\n+      && location.line == last_location.line)\n+    return NULL_RTX;\n+#endif\n+  last_location = location;\n+  \n+  if (no_line_numbers)\n+    {\n+      cur_insn_uid++;\n+      return NULL_RTX;\n+    }\n+\n+#ifdef USE_MAPPED_LOCATION\n+  note = emit_note ((int) location);\n+#else\n+  note = emit_note (location.line);\n+  NOTE_SOURCE_FILE (note) = location.file;\n+#endif\n+  \n+  return note;\n+}\n+\n /* Emit a copy of note ORIG.  */\n \n rtx"}, {"sha": "e239f4c69b54a511e815c15a14617054422c2d6a", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -6777,14 +6777,14 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n      information.  It would be better of the diagnostic routines\n      used the file/line information embedded in the tree nodes rather\n      than globals.  */\n-  if (cfun && EXPR_HAS_LOCATION (exp))\n+  if (cfun && cfun->ib_boundaries_block && EXPR_HAS_LOCATION (exp))\n     {\n       location_t saved_location = input_location;\n       input_location = EXPR_LOCATION (exp);\n-      set_curr_insn_source_location (input_location);\n+      emit_line_note (input_location);\n \n       /* Record where the insns produced belong.  */\n-      set_curr_insn_block (TREE_BLOCK (exp));\n+      record_block_change (TREE_BLOCK (exp));\n \n       ret = expand_expr_real_1 (exp, target, tmode, modifier, alt_rtl);\n "}, {"sha": "f0a2dd613927519dfa14a79bdfea7f47ce9044f8", "filename": "gcc/function.c", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -3843,6 +3843,18 @@ init_function_start (tree subr)\n {\n   prepare_function_start (subr);\n \n+  /* Prevent ever trying to delete the first instruction of a\n+     function.  Also tell final how to output a linenum before the\n+     function prologue.  Note linenums could be missing, e.g. when\n+     compiling a Java .class file.  */\n+  if (! DECL_IS_BUILTIN (subr))\n+    emit_line_note (DECL_SOURCE_LOCATION (subr));\n+\n+  /* Make sure first insn is a note even if we don't want linenums.\n+     This makes sure the first insn will never be deleted.\n+     Also, final expects a note to appear there.  */\n+  emit_note (NOTE_INSN_DELETED);\n+\n   /* Warn if this value is an aggregate type,\n      regardless of which calling convention we are using for it.  */\n   if (AGGREGATE_TYPE_P (TREE_TYPE (DECL_RESULT (subr))))\n@@ -4293,7 +4305,7 @@ expand_function_end (void)\n   /* Output a linenumber for the end of the function.\n      SDB depends on this.  */\n   force_next_line_note ();\n-  set_curr_insn_source_location (input_location);\n+  emit_line_note (input_location);\n \n   /* Before the return label (if any), clobber the return\n      registers so that they are not propagated live to the rest of\n@@ -5336,6 +5348,62 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n #endif /* HAVE_prologue or HAVE_epilogue */\n }\n \n+/* Resets insn_block_boundaries array.  */\n+\n+void\n+reset_block_changes (void)\n+{\n+  cfun->ib_boundaries_block = VEC_alloc (tree, gc, 100);\n+  VEC_quick_push (tree, cfun->ib_boundaries_block, NULL_TREE);\n+}\n+\n+/* Record the boundary for BLOCK.  */\n+void\n+record_block_change (tree block)\n+{\n+  int i, n;\n+  tree last_block;\n+\n+  if (!block)\n+    return;\n+\n+  if(!cfun->ib_boundaries_block)\n+    return;\n+\n+  last_block = VEC_pop (tree, cfun->ib_boundaries_block);\n+  n = get_max_uid ();\n+  for (i = VEC_length (tree, cfun->ib_boundaries_block); i < n; i++)\n+    VEC_safe_push (tree, gc, cfun->ib_boundaries_block, last_block);\n+\n+  VEC_safe_push (tree, gc, cfun->ib_boundaries_block, block);\n+}\n+\n+/* Finishes record of boundaries.  */\n+void\n+finalize_block_changes (void)\n+{\n+  record_block_change (DECL_INITIAL (current_function_decl));\n+}\n+\n+/* For INSN return the BLOCK it belongs to.  */ \n+void\n+check_block_change (rtx insn, tree *block)\n+{\n+  unsigned uid = INSN_UID (insn);\n+\n+  if (uid >= VEC_length (tree, cfun->ib_boundaries_block))\n+    return;\n+\n+  *block = VEC_index (tree, cfun->ib_boundaries_block, uid);\n+}\n+\n+/* Releases the ib_boundaries_block records.  */\n+void\n+free_block_changes (void)\n+{\n+  VEC_free (tree, gc, cfun->ib_boundaries_block);\n+}\n+\n /* Returns the name of the current function.  */\n const char *\n current_function_name (void)"}, {"sha": "f176d85398fe412166e2aeda4a58a10363e6232c", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -347,6 +347,9 @@ struct function GTY(())\n   /* Line number of the end of the function.  */\n   location_t function_end_locus;\n \n+  /* Array mapping insn uids to blocks.  */\n+  VEC(tree,gc) *ib_boundaries_block;\n+\n   /* The variables unexpanded so far.  */\n   tree unexpanded_var_list;\n \n@@ -549,6 +552,11 @@ extern void number_blocks (tree);\n \n extern void clear_block_marks (tree);\n extern tree blocks_nreverse (tree);\n+extern void reset_block_changes (void);\n+extern void record_block_change (tree);\n+extern void finalize_block_changes (void);\n+extern void check_block_change (rtx, tree *);\n+extern void free_block_changes (void);\n \n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;"}, {"sha": "11b11981fdd868baba7b10ca47ded050da93fa98", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -654,6 +654,7 @@ init_optimization_passes (void)\n       struct tree_opt_pass **p = &pass_rest_of_compilation.sub;\n       NEXT_PASS (pass_init_function);\n       NEXT_PASS (pass_jump);\n+      NEXT_PASS (pass_insn_locators_initialize);\n       NEXT_PASS (pass_rtl_eh);\n       NEXT_PASS (pass_initial_value_sets);\n       NEXT_PASS (pass_unshare_all_rtl);"}, {"sha": "81ed8bc8659af40461ec0c0888805253067a0d04", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -1562,6 +1562,7 @@ extern rtx emit_label (rtx);\n extern rtx emit_barrier (void);\n extern rtx emit_note (int);\n extern rtx emit_note_copy (rtx);\n+extern rtx emit_line_note (location_t);\n extern rtx make_insn_raw (rtx);\n extern rtx make_jump_insn_raw (rtx);\n extern void add_function_usage_to (rtx, rtx);\n@@ -2297,10 +2298,4 @@ extern const struct rtl_hooks general_rtl_hooks;\n /* Keep this for the nonce.  */\n #define gen_lowpart rtl_hooks.gen_lowpart\n \n-extern void insn_locators_alloc (void);\n-extern void insn_locators_finalize (void);\n-extern void set_curr_insn_source_location (location_t);\n-extern void set_curr_insn_block (tree);\n-extern int curr_insn_locator (void);\n-\n #endif /* ! GCC_RTL_H */"}, {"sha": "ff76b7557c1a291075d36b93ba00ad98619f4fa3", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -1117,6 +1117,7 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n   new_cfun->unexpanded_var_list = NULL;\n   new_cfun->cfg = NULL;\n   new_cfun->decl = new_fndecl /*= copy_node (callee_fndecl)*/;\n+  new_cfun->ib_boundaries_block = NULL;\n   DECL_STRUCT_FUNCTION (new_fndecl) = new_cfun;\n   push_cfun (new_cfun);\n   init_empty_tree_cfg ();"}, {"sha": "1b92f8c98072ea91c1d0e4d2980515cfc420c616", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ac2bc429d48bfd2466d56ddea4244ebfba990/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=ec9ac2bc429d48bfd2466d56ddea4244ebfba990", "patch": "@@ -329,6 +329,7 @@ extern struct tree_opt_pass pass_fixup_cfg;\n \n extern struct tree_opt_pass pass_init_function;\n extern struct tree_opt_pass pass_jump;\n+extern struct tree_opt_pass pass_insn_locators_initialize;\n extern struct tree_opt_pass pass_rtl_eh;\n extern struct tree_opt_pass pass_initial_value_sets;\n extern struct tree_opt_pass pass_unshare_all_rtl;"}]}