{"sha": "6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY4NWFiNjJiNzAwODlkNjU2ODkwMmU2ZDc0YzM3ZThiYmNjOGU0Mw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2007-03-17T19:58:37Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-03-17T19:58:37Z"}, "message": "re PR fortran/31120 ([4.1/4.2 only] ICE with integer_exponentiation_1.f90 and -ffast-math)\n\n\tPR fortran/31120\n\n\t* trans-expr.c (gfc_conv_powi): Make n argument unsigned hwi.\n\t(gfc_conv_cst_int_power): Handle integer exponent with care,\n\tsince it might be too large for us.\n\n\t* gfortran.dg/integer_exponentiation_2.f90: New test.\n\nFrom-SVN: r123028", "tree": {"sha": "70262ee6ede8e9e7eaef7f06b5639f584fb7b386", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70262ee6ede8e9e7eaef7f06b5639f584fb7b386"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8af9c34fded5ce25e60c939de31b5e1fb27c056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8af9c34fded5ce25e60c939de31b5e1fb27c056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8af9c34fded5ce25e60c939de31b5e1fb27c056"}], "stats": {"total": 286, "additions": 281, "deletions": 5}, "files": [{"sha": "76305392a7e41e4dc5e6e68d804a169ef0fb9c0f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "patch": "@@ -1,3 +1,10 @@\n+2007-03-17  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/31120\n+\t* trans-expr.c (gfc_conv_powi): Make n argument unsigned hwi.\n+\t(gfc_conv_cst_int_power): Handle integer exponent with care,\n+\tsince it might be too large for us.\n+\n 2007-03-17  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/31184"}, {"sha": "c6448ec73833320783cc87de9c65a9a21e8996fa", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "patch": "@@ -634,7 +634,7 @@ static const unsigned char powi_table[POWI_TABLE_SIZE] =\n /* Recursive function to expand the power operator. The temporary \n    values are put in tmpvar. The function returns tmpvar[1] ** n.  */\n static tree\n-gfc_conv_powi (gfc_se * se, int n, tree * tmpvar)\n+gfc_conv_powi (gfc_se * se, unsigned HOST_WIDE_INT n, tree * tmpvar)\n {\n   tree op0;\n   tree op1;\n@@ -681,15 +681,25 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   tree tmp;\n   tree type;\n   tree vartmp[POWI_TABLE_SIZE];\n-  int n;\n+  HOST_WIDE_INT m;\n+  unsigned HOST_WIDE_INT n;\n   int sgn;\n \n+  /* If exponent is too large, we won't expand it anyway, so don't bother\n+     with large integer values.  */\n+  if (!double_int_fits_in_shwi_p (TREE_INT_CST (rhs)))\n+    return 0;\n+\n+  m = double_int_to_shwi (TREE_INT_CST (rhs));\n+  /* There's no ABS for HOST_WIDE_INT, so here we go. It also takes care\n+     of the asymmetric range of the integer type.  */\n+  n = (unsigned HOST_WIDE_INT) (m < 0 ? -m : m);\n+  \n   type = TREE_TYPE (lhs);\n-  n = abs (TREE_INT_CST_LOW (rhs));\n   sgn = tree_int_cst_sgn (rhs);\n \n-  if (((FLOAT_TYPE_P (type) && !flag_unsafe_math_optimizations) || optimize_size)\n-      && (n > 2 || n < -1))\n+  if (((FLOAT_TYPE_P (type) && !flag_unsafe_math_optimizations)\n+       || optimize_size) && (m > 2 || m < -1))\n     return 0;\n \n   /* rhs == 0  */\n@@ -698,6 +708,7 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n       se->expr = gfc_build_const (type, integer_one_node);\n       return 1;\n     }\n+\n   /* If rhs < 0 and lhs is an integer, the result is -1, 0 or 1.  */\n   if ((sgn == -1) && (TREE_CODE (type) == INTEGER_TYPE))\n     {"}, {"sha": "51282fab131dae44205da4b418ebf8a0071582f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "patch": "@@ -1,3 +1,8 @@\n+2007-03-17  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/31120\n+\t* gfortran.dg/integer_exponentiation_2.f90: New test.\n+\n 2007-03-17  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR tree-optimization/31041"}, {"sha": "4701cea7927159ab026e0b1abdb2b131702cdaae", "filename": "gcc/testsuite/gfortran.dg/integer_exponentiation_2.f90", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f85ab62b70089d6568902e6d74c37e8bbcc8e43/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_2.f90?ref=6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "patch": "@@ -0,0 +1,253 @@\n+! { dg-do run }\n+! { dg-options \"\" }\n+! Test various exponentations\n+! initially designed for patch to PR31120\n+\n+program test\n+  call run_me (1.0, 1, (1.0,0.0))\n+  call run_me (-1.1, -1, (0.0,-1.0))\n+  call run_me (42.0, 12, (1.0,7.0))\n+end program test\n+\n+! This subroutine is for runtime tests\n+subroutine run_me(a, i, z)\n+  implicit none\n+\n+  real, intent(in) :: a\n+  integer, intent(in) :: i\n+  complex, intent(in) :: z\n+\n+  call check_equal_i (i**0, 1)\n+  call check_equal_i (i**1, i)\n+  call check_equal_i (i**2, i*i)\n+  call check_equal_i (i**3, i*(i**2))\n+\n+  call check_equal_i (int(i**0_8,kind=4), 1)\n+  call check_equal_i (int(i**1_8,kind=4), i)\n+  call check_equal_i (int(i**2_8,kind=4), i*i)\n+  call check_equal_i (int(i**3_8,kind=4), i*i*i)\n+\n+  call check_equal_r (a**0.0, 1.0)\n+  call check_equal_r (a**1.0, a)\n+  call check_equal_r (a**2.0, a*a)\n+  call check_equal_r (a**3.0, a*(a**2))\n+  call check_equal_r (a**-1.0, 1/a)\n+  call check_equal_r (a**-2.0, (1/a)*(1/a))\n+\n+  call check_equal_r (a**0, 1.0)\n+  call check_equal_r (a**1, a)\n+  call check_equal_r (a**2, a*a)\n+  call check_equal_r (a**3, a*(a**2))\n+  call check_equal_r (a**-1, 1/a)\n+  call check_equal_r (a**-2, (1/a)*(1/a))\n+\n+  call check_equal_r (a**0_8, 1.0)\n+  call check_equal_r (a**1_8, a)\n+  call check_equal_r (a**2_8, a*a)\n+  call check_equal_r (a**3_8, a*(a**2))\n+  call check_equal_r (a**-1_8, 1/a)\n+  call check_equal_r (a**-2_8, (1/a)*(1/a))\n+\n+  call check_equal_c (z**0.0, (1.0,0.0))\n+  call check_equal_c (z**1.0, z)\n+  call check_equal_c (z**2.0, z*z)\n+  call check_equal_c (z**3.0, z*(z**2))\n+  call check_equal_c (z**-1.0, 1/z)\n+  call check_equal_c (z**-2.0, (1/z)*(1/z))\n+\n+  call check_equal_c (z**(0.0,0.0), (1.0,0.0))\n+  call check_equal_c (z**(1.0,0.0), z)\n+  call check_equal_c (z**(2.0,0.0), z*z)\n+  call check_equal_c (z**(3.0,0.0), z*(z**2))\n+  call check_equal_c (z**(-1.0,0.0), 1/z)\n+  call check_equal_c (z**(-2.0,0.0), (1/z)*(1/z))\n+\n+  call check_equal_c (z**0, (1.0,0.0))\n+  call check_equal_c (z**1, z)\n+  call check_equal_c (z**2, z*z)\n+  call check_equal_c (z**3, z*(z**2))\n+  call check_equal_c (z**-1, 1/z)\n+  call check_equal_c (z**-2, (1/z)*(1/z))\n+\n+  call check_equal_c (z**0_8, (1.0,0.0))\n+  call check_equal_c (z**1_8, z)\n+  call check_equal_c (z**2_8, z*z)\n+  call check_equal_c (z**3_8, z*(z**2))\n+  call check_equal_c (z**-1_8, 1/z)\n+  call check_equal_c (z**-2_8, (1/z)*(1/z))\n+\n+\n+contains\n+\n+  subroutine check_equal_r (a, b)\n+    real, intent(in) :: a, b\n+    if (abs(a - b) > 1.e-5 * abs(b)) call abort\n+  end subroutine check_equal_r\n+\n+  subroutine check_equal_c (a, b)\n+    complex, intent(in) :: a, b\n+    if (abs(a - b) > 1.e-5 * abs(b)) call abort\n+  end subroutine check_equal_c\n+\n+  subroutine check_equal_i (a, b)\n+    integer, intent(in) :: a, b\n+    if (a /= b) call abort\n+  end subroutine check_equal_i\n+\n+end subroutine run_me\n+\n+! subroutine foo is used for compilation test only\n+subroutine foo(a)\n+  implicit none\n+\n+  real, intent(in) :: a\n+  integer :: i\n+  complex :: z\n+\n+  ! Integer\n+  call gee_i(i**0_1)\n+  call gee_i(i**1_1)\n+  call gee_i(i**2_1)\n+  call gee_i(i**3_1)\n+  call gee_i(i**-1_1)\n+  call gee_i(i**-2_1)\n+  call gee_i(i**-3_1)\n+  call gee_i(i**huge(0_1))\n+  call gee_i(i**-huge(0_1))\n+  call gee_i(i**(-huge(0_1)-1_1))\n+\n+  call gee_i(i**0_2)\n+  call gee_i(i**1_2)\n+  call gee_i(i**2_2)\n+  call gee_i(i**3_2)\n+  call gee_i(i**-1_2)\n+  call gee_i(i**-2_2)\n+  call gee_i(i**-3_2)\n+  call gee_i(i**huge(0_2))\n+  call gee_i(i**-huge(0_2))\n+  call gee_i(i**(-huge(0_2)-1_2))\n+\n+  call gee_i(i**0_4)\n+  call gee_i(i**1_4)\n+  call gee_i(i**2_4)\n+  call gee_i(i**3_4)\n+  call gee_i(i**-1_4)\n+  call gee_i(i**-2_4)\n+  call gee_i(i**-3_4)\n+  call gee_i(i**huge(0_4))\n+  call gee_i(i**-huge(0_4))\n+  call gee_i(i**(-huge(0_4)-1_4))\n+\n+  call gee_i(i**0_8)\n+  call gee_i(i**1_8)\n+  call gee_i(i**2_8)\n+  call gee_i(i**3_8)\n+  call gee_i(i**-1_8)\n+  call gee_i(i**-2_8)\n+  call gee_i(i**-3_8)\n+  call gee_i(i**huge(0_8))\n+  call gee_i(i**-huge(0_8))\n+  call gee_i(i**(-huge(0_8)-1_8))\n+\n+  ! Real\n+  call gee_r(a**0_1)\n+  call gee_r(a**1_1)\n+  call gee_r(a**2_1)\n+  call gee_r(a**3_1)\n+  call gee_r(a**-1_1)\n+  call gee_r(a**-2_1)\n+  call gee_r(a**-3_1)\n+  call gee_r(a**huge(0_1))\n+  call gee_r(a**-huge(0_1))\n+  call gee_r(a**(-huge(0_1)-1_1))\n+\n+  call gee_r(a**0_2)\n+  call gee_r(a**1_2)\n+  call gee_r(a**2_2)\n+  call gee_r(a**3_2)\n+  call gee_r(a**-1_2)\n+  call gee_r(a**-2_2)\n+  call gee_r(a**-3_2)\n+  call gee_r(a**huge(0_2))\n+  call gee_r(a**-huge(0_2))\n+  call gee_r(a**(-huge(0_2)-1_2))\n+\n+  call gee_r(a**0_4)\n+  call gee_r(a**1_4)\n+  call gee_r(a**2_4)\n+  call gee_r(a**3_4)\n+  call gee_r(a**-1_4)\n+  call gee_r(a**-2_4)\n+  call gee_r(a**-3_4)\n+  call gee_r(a**huge(0_4))\n+  call gee_r(a**-huge(0_4))\n+  call gee_r(a**(-huge(0_4)-1_4))\n+\n+  call gee_r(a**0_8)\n+  call gee_r(a**1_8)\n+  call gee_r(a**2_8)\n+  call gee_r(a**3_8)\n+  call gee_r(a**-1_8)\n+  call gee_r(a**-2_8)\n+  call gee_r(a**-3_8)\n+  call gee_r(a**huge(0_8))\n+  call gee_r(a**-huge(0_8))\n+  call gee_r(a**(-huge(0_8)-1_8))\n+\n+  ! Complex\n+  call gee_z(z**0_1)\n+  call gee_z(z**1_1)\n+  call gee_z(z**2_1)\n+  call gee_z(z**3_1)\n+  call gee_z(z**-1_1)\n+  call gee_z(z**-2_1)\n+  call gee_z(z**-3_1)\n+  call gee_z(z**huge(0_1))\n+  call gee_z(z**-huge(0_1))\n+  call gee_z(z**(-huge(0_1)-1_1))\n+\n+  call gee_z(z**0_2)\n+  call gee_z(z**1_2)\n+  call gee_z(z**2_2)\n+  call gee_z(z**3_2)\n+  call gee_z(z**-1_2)\n+  call gee_z(z**-2_2)\n+  call gee_z(z**-3_2)\n+  call gee_z(z**huge(0_2))\n+  call gee_z(z**-huge(0_2))\n+  call gee_z(z**(-huge(0_2)-1_2))\n+\n+  call gee_z(z**0_4)\n+  call gee_z(z**1_4)\n+  call gee_z(z**2_4)\n+  call gee_z(z**3_4)\n+  call gee_z(z**-1_4)\n+  call gee_z(z**-2_4)\n+  call gee_z(z**-3_4)\n+  call gee_z(z**huge(0_4))\n+  call gee_z(z**-huge(0_4))\n+  call gee_z(z**(-huge(0_4)-1_4))\n+\n+  call gee_z(z**0_8)\n+  call gee_z(z**1_8)\n+  call gee_z(z**2_8)\n+  call gee_z(z**3_8)\n+  call gee_z(z**-1_8)\n+  call gee_z(z**-2_8)\n+  call gee_z(z**-3_8)\n+  call gee_z(z**huge(0_8))\n+  call gee_z(z**-huge(0_8))\n+  call gee_z(z**(-huge(0_8)-1_8))\n+end subroutine foo\n+\n+subroutine gee_i(i)\n+  integer :: i\n+end subroutine gee_i\n+\n+subroutine gee_r(r)\n+  real :: r\n+end subroutine gee_r\n+\n+subroutine gee_z(c)\n+  complex :: c\n+end subroutine gee_z"}]}