{"sha": "0ac11108c422b8daeb62e22c5f04beeb299055dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFjMTExMDhjNDIyYjhkYWViNjJlMjJjNWYwNGJlZWIyOTkwNTVkYw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2006-06-04T19:50:48Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2006-06-04T19:50:48Z"}, "message": "stor-layout.c (start_record_layout): Initialize remaining_in_alignment.\n\n2006-06-04 Eric Christopher <echristo@apple.com>\n\n        * stor-layout.c (start_record_layout): Initialize remaining_in_alignment.\n        (debug_rli): Output value for remaining_in_alignment.\n        (update_alignment_for_field): Unconditionalize\n        ms_bitfield_layout_p code. Handle non-bitfield fields. Remove\n        extra alignment code.\n        (place_field): Don't realign if ms_bitfield_layout_p. Unconditionalize\n        ms_bitfield_layout_p code. Rewrite handling of structure fields.\n        * tree.h (record_layout_info_s): Remove prev_packed.\n        * doc/extend.texi (ms_struct): Add documentation of format.\n\n2006-06-04 Eric Christopher <echristo@apple.com>\n\n        * gcc.dg/attr-ms_struct-1.c: New.\n\nFrom-SVN: r114364", "tree": {"sha": "3fd047caf9009cd8c192b73bf3d4074d81de31ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fd047caf9009cd8c192b73bf3d4074d81de31ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ac11108c422b8daeb62e22c5f04beeb299055dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac11108c422b8daeb62e22c5f04beeb299055dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ac11108c422b8daeb62e22c5f04beeb299055dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac11108c422b8daeb62e22c5f04beeb299055dc/comments", "author": null, "committer": null, "parents": [{"sha": "a0c04f8e495477e0bf1c0d8d87f1a32985003533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0c04f8e495477e0bf1c0d8d87f1a32985003533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0c04f8e495477e0bf1c0d8d87f1a32985003533"}], "stats": {"total": 627, "additions": 426, "deletions": 201}, "files": [{"sha": "96f9cea273901aae8200e286ec571888124bcf83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ac11108c422b8daeb62e22c5f04beeb299055dc", "patch": "@@ -1,3 +1,15 @@\n+2006-06-04 Eric Christopher <echristo@apple.com>\n+\n+\t* stor-layout.c (start_record_layout): Initialize remaining_in_alignment.\n+\t(debug_rli): Output value for remaining_in_alignment.\n+\t(update_alignment_for_field): Unconditionalize\n+\tms_bitfield_layout_p code. Handle non-bitfield fields. Remove\n+\textra alignment code.\n+\t(place_field): Don't realign if ms_bitfield_layout_p. Unconditionalize\n+\tms_bitfield_layout_p code. Rewrite handling of structure fields.\n+\t* tree.h (record_layout_info_s): Remove prev_packed.\n+\t* doc/extend.texi (ms_struct): Add documentation of format.\n+\n 2006-06-04  Mark Shinwell  <shinwell@codesourcery.com>\n \n \t* tree.h: Declare folding_initializer.\n@@ -384,7 +396,7 @@\n \n \tPR c++/20103\n \t* gimplify.c (gimplify_decl_expr): Do not call gimple_add_tmp_var\n-\tfor anonymous variables explicitly declared by front ends. \n+\tfor anonymous variables explicitly declared by front ends.\n \n 2006-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n@@ -442,11 +454,11 @@\n \t* df-core.c: Added to header comments.\n \t* df.h (df_ru_bb_info, df_rd_bb_info, df_lr_bb_info,\n \tdf_ur_bb_info, df_urec_bb_info): Added comments.\n-\t* df-problems (df_ref_bitmap, ru, rd, lr, ur, \n+\t* df-problems (df_ref_bitmap, ru, rd, lr, ur,\n \turec, ri problems): Fixed header comments.\n-\t(df_ru_transfer_function): Fixed in-out set dyslexia when copying \n+\t(df_ru_transfer_function): Fixed in-out set dyslexia when copying\n \tcode from df_rd_transfer_function.\n-\t\n+\n 2006-05-23  Richard Sandiford  <richard@codesourcery.com>\n \n \t* libgcc2.c (LIBGCC2_MAX_UNITS_PER_WORD): New macro.\n@@ -470,7 +482,7 @@\n 2006-05-23  Andrew MacLeod  <amacleod@redhat.com>\n \n \tPR c++/26757\n-\t* tree-ssa-loop-im.c (determine_invariantness_stmt): Use \n+\t* tree-ssa-loop-im.c (determine_invariantness_stmt): Use\n \tadd_referenced_var instead of add_referenced_tmp_var.\n \t* tree-complex.c (create_one_component_var): Use add_referenced_var.\n \t* tree-ssa-loop-manip.c (create_iv, tree_unroll_loop): Use\n@@ -494,23 +506,23 @@\n \tisn't already in the hash table.\n \t(add_referenced_tmp_var): Remove.\n \t(find_new_referenced_vars_1): Use add_referenced_var.\n-\t* tree-ssa-pre.c (create_expression_by_pieces, \n+\t* tree-ssa-pre.c (create_expression_by_pieces,\n \tinsert_into_preds_of_block, insert_extra_phis, realify_fake_stores):\n \tUse add_referenced_var.\n \t* tree-vect-patterns.c (vect_pattern_recog_1): Use add_referenced_var.\n \t* lambda-code.c (lbv_to_gcc_expression, lle_to_gcc_expression,\n-\tlambda_loopnest_to_gcc_loopnest, perfect_nestify): Use \n+\tlambda_loopnest_to_gcc_loopnest, perfect_nestify): Use\n \tadd_referenced_var.\n \t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref,\n \tvect_create_data_ref_ptr, vect_create_destination_var,\n-\tvect_init_vector, vect_build_loop_niters, \n+\tvect_init_vector, vect_build_loop_niters,\n \tvect_generate_tmps_on_preheader, vect_update_ivs_after_vectorizer,\n \tvect_gen_niters_for_prolog_loop, vect_create_cond_for_align_checks):\n \tUse add_referenced_var.\n \t* tree-outof-ssa.c (create_temp): Use add_referenced_var.\n \t* tree-flow.h (add_referenced_tmp_var): Remove prototype\n \t(add_referenced_var): Add prototype.\n-\t* tree-ssa-structalias.c (get_constraint_for, \n+\t* tree-ssa-structalias.c (get_constraint_for,\n \tintra_create_variable_infos): Use add_referenced_var.\n \n 2006-05-23  Alexandre Oliva  <aoliva@redhat.com>\n@@ -542,9 +554,9 @@\n \tto gen set.\n \t(df_ru_bb_local_compute): Reversed statements and removed bogus\n \tcomment explaining why they should be in wrong order.\n-\t(df_ru_dump, df_rd_dump): Enhanced debug info.     \n+\t(df_ru_dump, df_rd_dump): Enhanced debug info.\n \t* modulo-sched.c (sms_schedule, tree_opt_pass pass_sms): Enhanced\n-\tdebug info.       \n+\tdebug info.\n \t* ddg.c (add_deps_for_def): Converted use of reaching defs to\n \treaching uses and fixed space problem.\n \n@@ -585,11 +597,11 @@\n \n \t* config/avr/avr.c (avr_mcu_types): Add support for attiny261,\n \tattiny461, attiny861, attiny25, attiny45, attiny85, attiny24,\n-\tattiny44, attiny84, at90pwm2, at90pwm3, atmega165p, atmega169p, \n-\tatmega164p, atmega324p, atmega644p, atmega644, atmega329, \n-\tatmega3290, atmega649, atmega6490, atmega406, atmega640, \n-\tatmega1280, atmega1281, at90can32, at90can64, at90usb646, \n-\tat90usb647, at90usb1286 and at90usb1287 devices.  \n+\tattiny44, attiny84, at90pwm2, at90pwm3, atmega165p, atmega169p,\n+\tatmega164p, atmega324p, atmega644p, atmega644, atmega329,\n+\tatmega3290, atmega649, atmega6490, atmega406, atmega640,\n+\tatmega1280, atmega1281, at90can32, at90can64, at90usb646,\n+\tat90usb647, at90usb1286 and at90usb1287 devices.\n \t* config/avr/avr.h (LINK_SPEC, CRT_BINUTILS_SPECS): (Ditto.).\n \t* config/avr/t-avr (MULTILIB_MATCHES): (Ditto.).\n \n@@ -715,7 +727,7 @@\n \t(df_ref_record_1): Changed DF_REF_CLOBBER into DF_REF_MUST_CLOBBER\n \tand set DF_REF_PARTIAL.\n \t(df_defs_record): Changed DF_REF_CLOBBER into DF_REF_MUST_CLOBBER.\n-\t(df_uses_record): Added DF_REF_PARTIAL for subreg. \n+\t(df_uses_record): Added DF_REF_PARTIAL for subreg.\n \t(df_scan_add_problem): Added flags parameter.\n \t(df_ref_create_structure): Changed switching structure.\n \t(df_bb_refs_record): Fixed case where duplicate artificial refs\n@@ -726,8 +738,8 @@\n \t(df_record_exit_block_uses, df_insn_refs_record): Changed location of flags.\n \t(df_set_state): Removed function.\n \t(df_grow_reg_info, df_reg_chain_unlink, df_ref_remove,\n-\tdf_insn_create_insn_record, df_insn_refs_delete, \n-\tdf_ref_create_structure): Formatting changes.  \n+\tdf_insn_create_insn_record, df_insn_refs_delete,\n+\tdf_ref_create_structure): Formatting changes.\n \t* df-core.c (df_mvs_dump, df_set_flags, df_clear_flags,\n \tdf_delete_basic_block): New function.\n \t(df_init): Changed location of flags.\n@@ -741,7 +753,7 @@\n \t(df_prune_to_subcfg): Made public.\n \t(df_analyze_problem): Added blocks_to_init parameter and made\n \tpublic.\n-\t(df_ref_record, df_bb_refs_record, df_mark_reg, \n+\t(df_ref_record, df_bb_refs_record, df_mark_reg,\n \t df_record_exit_block_uses): Whitespace changes.\n \t(df_dump): Whitespace changes.\n \t* df.h: Some reordering to remove forward references.\n@@ -834,7 +846,7 @@\n \t* dwarf2out.c (dwarf2_name): Use the dwarf_name\tlanguage hook.\n \t* ada/misc.c (gnat_dwarf_name): New function.\n \t(LANG_HOOKS_DWARF_NAME): Define to gnat_dwarf_name.\n-\t\n+\n 2006-05-19  Richard Sandiford  <richard@codesourcery.com>\n \n \t* libgcc2.c (MIN_UNITS_PER_WORD): Move default definition from"}, {"sha": "47b1fcef3a4d086635d744a521697197c5a7a324", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 116, "deletions": 5, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0ac11108c422b8daeb62e22c5f04beeb299055dc", "patch": "@@ -33,7 +33,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Conditionals::        Omitting the middle operand of a @samp{?:} expression.\n * Long Long::\t\tDouble-word integers---@code{long long int}.\n * Complex::             Data types for complex numbers.\n-* Decimal Float::\tDecimal Floating Point. \n+* Decimal Float::\tDecimal Floating Point.\n * Hex Floats::          Hexadecimal floating-point constants.\n * Zero Length::         Zero-length arrays.\n * Variable Length::     Arrays whose length is computed at run time.\n@@ -3189,7 +3189,7 @@ attribute can also be applied to global C++ objects that are initialized\n by a constructor.  In this case, the static initialization and destruction\n code for the object is emitted in each translation defining the object,\n but the calls to the constructor and destructor are protected by a\n-link-once guard variable. \n+link-once guard variable.\n \n The @code{selectany} attribute is only available on Microsoft Windows\n targets.  You can use @code{__declspec (selectany)} as a synonym for\n@@ -3246,6 +3246,117 @@ either format.\n \n Currently @option{-m[no-]ms-bitfields} is provided for the Microsoft Windows X86\n compilers to match the native Microsoft compiler.\n+\n+The Microsoft structure layout algorithm is fairly simple with the exception\n+of the bitfield packing:\n+\n+The padding and alignment of members of structures and whether a bit field\n+can straddle a storage-unit boundary\n+\n+@enumerate\n+@item Structure members are stored sequentially in the order in which they are\n+declared: the first member has the lowest memory address and the last member\n+the highest.\n+\n+@item Every data object has an alignment-requirement. The alignment-requirement\n+for all data except structures, unions, and arrays is either the size of the\n+object or the current packing size (specified with either the aligned attribute\n+or the pack pragma), whichever is less. For structures,  unions, and arrays,\n+the alignment-requirement is the largest alignment-requirement of its members.\n+Every object is allocated an offset so that:\n+\n+offset %  alignment-requirement == 0\n+\n+@item Adjacent bit fields are packed into the same 1-, 2-, or 4-byte allocation\n+unit if the integral types are the same size and if the next bit field fits\n+into the current allocation unit without crossing the boundary imposed by the\n+common alignment requirements of the bit fields.\n+@end enumerate\n+\n+Handling of zero-length bitfields:\n+\n+MSVC interprets zero-length bitfields in the following ways:\n+\n+@enumerate\n+@item If a zero-length bitfield is inserted between two bitfields that would\n+normally be coalesced, the bitfields will not be coalesced.\n+\n+For example:\n+\n+@smallexample\n+struct\n+ @{\n+   unsigned long bf_1 : 12;\n+   unsigned long : 0;\n+   unsigned long bf_2 : 12;\n+ @} t1;\n+@end smallexample\n+\n+The size of @code{t1} would be 8 bytes with the zero-length bitfield.  If the\n+zero-length bitfield were removed, @code{t1}'s size would be 4 bytes.\n+\n+@item If a zero-length bitfield is inserted after a bitfield, @code{foo}, and the\n+alignment of the zero-length bitfield is greater than the member that follows it,\n+@code{bar}, @code{bar} will be aligned as the type of the zero-length bitfield.\n+\n+For example:\n+\n+@smallexample\n+struct\n+ @{\n+   char foo : 4;\n+   short : 0;\n+   char bar;\n+ @} t2;\n+\n+struct\n+ @{\n+   char foo : 4;\n+   short : 0;\n+   double bar;\n+ @} t3;\n+@end smallexample\n+\n+For @code{t2}, @code{bar} will be placed at offset 2, rather than offset 1.\n+Accordingly, the size of @code{t2} will be 4.  For @code{t3}, the zero-length\n+bitfield will not affect the alignment of @code{bar} or, as a result, the size\n+of the structure.\n+\n+Taking this into account, it is important to note the following:\n+\n+@enumerate\n+@item If a zero-length bitfield follows a normal bitfield, the type of the\n+zero-length bitfield may affect the alignment of the structure as whole. For\n+example, @code{t2} has a size of 4 bytes, since the zero-length bitfield follows a\n+normal bitfield, and is of type short.\n+\n+@item Even if a zero-length bitfield is not followed by a normal bitfield, it may\n+still affect the alignment of the structure:\n+\n+@smallexample\n+struct\n+ @{\n+   char foo : 6;\n+   long : 0;\n+ @} t4;\n+@end smallexample\n+\n+Here, @code{t4} will take up 4 bytes.\n+@end enumerate\n+\n+@item Zero-length bitfields following non-bitfield members are ignored:\n+\n+@smallexample\n+struct\n+ @{\n+   char foo;\n+   long : 0;\n+   char bar;\n+ @} t5;\n+@end smallexample\n+\n+Here, @code{t5} will take up 2 bytes.\n+@end enumerate\n @end table\n \n @subsection Xstormy16 Variable Attributes\n@@ -4820,7 +4931,7 @@ These builtins perform an atomic compare and swap.  That is, if the current\n value of @code{*@var{ptr}} is @var{oldval}, then write @var{newval} into\n @code{*@var{ptr}}.\n \n-The ``bool'' version returns true if the comparison is successful and \n+The ``bool'' version returns true if the comparison is successful and\n @var{newval} was written.  The ``val'' version returns the contents\n of @code{*@var{ptr}} before the operation.\n \n@@ -4844,7 +4955,7 @@ is implementation defined.\n This builtin is not a full barrier, but rather an @dfn{acquire barrier}.\n This means that references after the builtin cannot move to (or be\n speculated to) before the builtin, but previous memory stores may not\n-be globally visible yet, and previous memory loads may not yet be \n+be globally visible yet, and previous memory loads may not yet be\n satisfied.\n \n @item void __sync_lock_release (@var{type} *ptr, ...)\n@@ -9573,7 +9684,7 @@ aliases.\n @cindex pragma, weak\n This pragma declares @var{symbol} to be weak, as if the declaration\n had the attribute of the same name.  The pragma may appear before\n-or after the declaration of @var{symbol}, but must appear before \n+or after the declaration of @var{symbol}, but must appear before\n either its first use or its definition.  It is not an error for\n @var{symbol} to never be defined at all.\n "}, {"sha": "c58237f66e6345dc52d8290c26fe8653ca294702", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 68, "deletions": 131, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0ac11108c422b8daeb62e22c5f04beeb299055dc", "patch": "@@ -300,10 +300,10 @@ layout_decl (tree decl, unsigned int known_align)\n \n   if (code == CONST_DECL)\n     return;\n-  \n+\n   gcc_assert (code == VAR_DECL || code == PARM_DECL || code == RESULT_DECL\n \t      || code == TYPE_DECL ||code == FIELD_DECL);\n-  \n+\n   rtl = DECL_RTL_IF_SET (decl);\n \n   if (type == error_mark_node)\n@@ -538,6 +538,7 @@ start_record_layout (tree t)\n   rli->prev_field = 0;\n   rli->pending_statics = 0;\n   rli->packed_maybe_necessary = 0;\n+  rli->remaining_in_alignment = 0;\n \n   return rli;\n }\n@@ -549,7 +550,7 @@ tree\n bit_from_pos (tree offset, tree bitpos)\n {\n   return size_binop (PLUS_EXPR, bitpos,\n-\t\t     size_binop (MULT_EXPR, \n+\t\t     size_binop (MULT_EXPR,\n \t\t\t\t fold_convert (bitsizetype, offset),\n \t\t\t\t bitsize_unit_node));\n }\n@@ -590,7 +591,7 @@ normalize_offset (tree *poffset, tree *pbitpos, unsigned int off_align)\n \n       *poffset\n \t= size_binop (PLUS_EXPR, *poffset,\n-\t\t      size_binop (MULT_EXPR, \n+\t\t      size_binop (MULT_EXPR,\n \t\t\t\t  fold_convert (sizetype, extra_aligns),\n \t\t\t\t  size_int (off_align / BITS_PER_UNIT)));\n \n@@ -611,6 +612,11 @@ debug_rli (record_layout_info rli)\n   fprintf (stderr, \"\\naligns: rec = %u, unpack = %u, off = %u\\n\",\n \t   rli->record_align, rli->unpacked_align,\n \t   rli->offset_align);\n+\n+  /* The ms_struct code is the only that uses this.  */\n+  if (targetm.ms_bitfield_layout_p (rli->t))\n+    fprintf (stderr, \"remaning in alignment = %u\\n\", rli->remaining_in_alignment);\n+\n   if (rli->packed_maybe_necessary)\n     fprintf (stderr, \"packed may be necessary\\n\");\n \n@@ -679,38 +685,27 @@ update_alignment_for_field (record_layout_info rli, tree field,\n   /* Record must have at least as much alignment as any field.\n      Otherwise, the alignment of the field within the record is\n      meaningless.  */\n-  if (is_bitfield && targetm.ms_bitfield_layout_p (rli->t))\n+  if (targetm.ms_bitfield_layout_p (rli->t))\n     {\n       /* Here, the alignment of the underlying type of a bitfield can\n \t affect the alignment of a record; even a zero-sized field\n \t can do this.  The alignment should be to the alignment of\n \t the type, except that for zero-size bitfields this only\n \t applies if there was an immediately prior, nonzero-size\n \t bitfield.  (That's the way it is, experimentally.) */\n-      if (! integer_zerop (DECL_SIZE (field))\n-\t  ? ! DECL_PACKED (field)\n-\t  : (rli->prev_field\n-\t     && DECL_BIT_FIELD_TYPE (rli->prev_field)\n-\t     && ! integer_zerop (DECL_SIZE (rli->prev_field))))\n+      if (!is_bitfield\n+\t  || (!integer_zerop (DECL_SIZE (field))\n+\t      ? !DECL_PACKED (field)\n+\t      : (rli->prev_field\n+\t\t && DECL_BIT_FIELD_TYPE (rli->prev_field)\n+\t\t && ! integer_zerop (DECL_SIZE (rli->prev_field)))))\n \t{\n \t  unsigned int type_align = TYPE_ALIGN (type);\n \t  type_align = MAX (type_align, desired_align);\n \t  if (maximum_field_alignment != 0)\n \t    type_align = MIN (type_align, maximum_field_alignment);\n \t  rli->record_align = MAX (rli->record_align, type_align);\n \t  rli->unpacked_align = MAX (rli->unpacked_align, TYPE_ALIGN (type));\n-\t  /* If we start a new run, make sure we start it properly aligned.  */\n-\t  if ((!rli->prev_field\n-\t       || integer_zerop (DECL_SIZE (field))\n-\t       || integer_zerop (DECL_SIZE (rli->prev_field))\n-\t       || !host_integerp (DECL_SIZE (rli->prev_field), 0)\n-\t       || !host_integerp (TYPE_SIZE (type), 0)\n-\t       || !simple_cst_equal (TYPE_SIZE (type),\n-\t\t\t\t     TYPE_SIZE (TREE_TYPE (rli->prev_field)))\n-\t       || (rli->remaining_in_alignment\n-\t\t   < tree_low_cst (DECL_SIZE (field), 0)))\n-\t      && desired_align < type_align)\n-\t    desired_align = type_align;\n \t}\n     }\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n@@ -779,7 +774,7 @@ place_union_field (record_layout_info rli, tree field)\n   DECL_FIELD_BIT_OFFSET (field) = bitsize_zero_node;\n   SET_DECL_OFFSET_ALIGN (field, BIGGEST_ALIGNMENT);\n \n-  /* If this is an ERROR_MARK return *after* having set the \n+  /* If this is an ERROR_MARK return *after* having set the\n      field at the start of the union. This helps when parsing\n      invalid fields. */\n   if (TREE_CODE (TREE_TYPE (field)) == ERROR_MARK)\n@@ -857,7 +852,7 @@ place_field (record_layout_info rli, tree field)\n       return;\n     }\n \n-  else if (TREE_CODE (type) == ERROR_MARK) \n+  else if (TREE_CODE (type) == ERROR_MARK)\n     {\n       /* Place this field at the current allocation position, so we\n \t maintain monotonicity.  */\n@@ -904,8 +899,10 @@ place_field (record_layout_info rli, tree field)\n     }\n \n   /* Does this field automatically have alignment it needs by virtue\n-     of the fields that precede it and the record's own alignment?  */\n-  if (known_align < desired_align)\n+     of the fields that precede it and the record's own alignment?\n+     We already align ms_struct fields, so don't re-align them.  */\n+  if (known_align < desired_align\n+      && !targetm.ms_bitfield_layout_p (rli->t))\n     {\n       /* No, we need to skip space before this field.\n \t Bump the cumulative size to multiple of field alignment.  */\n@@ -1022,17 +1019,12 @@ place_field (record_layout_info rli, tree field)\n      Note: for compatibility, we use the type size, not the type alignment\n      to determine alignment, since that matches the documentation */\n \n-  if (targetm.ms_bitfield_layout_p (rli->t)\n-       && ((DECL_BIT_FIELD_TYPE (field) && ! DECL_PACKED (field))\n-\t  || (rli->prev_field && ! DECL_PACKED (rli->prev_field))))\n+  if (targetm.ms_bitfield_layout_p (rli->t))\n     {\n-      /* At this point, either the prior or current are bitfields,\n-\t (possibly both), and we're dealing with MS packing.  */\n       tree prev_saved = rli->prev_field;\n \n-      /* Is the prior field a bitfield?  If so, handle \"runs\" of same\n-\t type size fields.  */\n-      if (rli->prev_field /* necessarily a bitfield if it exists.  */)\n+      /* This is a bitfield if it exists.  */\n+      if (rli->prev_field)\n \t{\n \t  /* If both are bitfields, nonzero, and the same size, this is\n \t     the middle of a run.  Zero declared size fields are special\n@@ -1051,34 +1043,22 @@ place_field (record_layout_info rli, tree field)\n \t      /* We're in the middle of a run of equal type size fields; make\n \t\t sure we realign if we run out of bits.  (Not decl size,\n \t\t type size!) */\n-\t      HOST_WIDE_INT bitsize = tree_low_cst (DECL_SIZE (field), 0);\n+\t      HOST_WIDE_INT bitsize = tree_low_cst (DECL_SIZE (field), 1);\n \n \t      if (rli->remaining_in_alignment < bitsize)\n \t\t{\n-\t\t  /* If PREV_FIELD is packed, and we haven't lumped\n-\t\t     non-packed bitfields with it, treat this as if PREV_FIELD\n-\t\t     was not a bitfield.  This avoids anomalies where a packed\n-\t\t     bitfield with long long base type can take up more\n-\t\t     space than a same-size bitfield with base type short.  */\n-\t\t  if (rli->prev_packed)\n-\t\t    rli->prev_field = prev_saved = NULL;\n-\t\t  else\n-\t\t    {\n-\t\t      /* out of bits; bump up to next 'word'.  */\n-\t\t      rli->offset = DECL_FIELD_OFFSET (rli->prev_field);\n-\t\t      rli->bitpos\n-\t\t\t= size_binop (PLUS_EXPR, TYPE_SIZE (type),\n-\t\t\t\t      DECL_FIELD_BIT_OFFSET (rli->prev_field));\n-\t\t      rli->prev_field = field;\n-\t\t      rli->remaining_in_alignment\n-\t\t\t= tree_low_cst (TYPE_SIZE (type), 0) - bitsize;\n-\t\t    }\n+\t\t  /* out of bits; bump up to next 'word'.  */\n+\t\t  rli->offset = DECL_FIELD_OFFSET (rli->prev_field);\n+\t\t  rli->bitpos\n+\t\t    = size_binop (PLUS_EXPR, TYPE_SIZE (type),\n+\t\t\t\t  DECL_FIELD_BIT_OFFSET (rli->prev_field));\n+\t\t  rli->prev_field = field;\n+\t\t  rli->remaining_in_alignment\n+\t\t    = tree_low_cst (TYPE_SIZE (type), 1);\n \t\t}\n-\t      else\n-\t\trli->remaining_in_alignment -= bitsize;\n+\n+\t      rli->remaining_in_alignment -= bitsize;\n \t    }\n-\t  else if (rli->prev_packed)\n-\t    rli->prev_field = prev_saved = NULL;\n \t  else\n \t    {\n \t      /* End of a run: if leaving a run of bitfields of the same type\n@@ -1090,18 +1070,12 @@ place_field (record_layout_info rli, tree field)\n \t\t Note: since the beginning of the field was aligned then\n \t\t of course the end will be too.  No round needed.  */\n \n-\t      if (!integer_zerop (DECL_SIZE (rli->prev_field)))\n+\t      if (!integer_zerop (DECL_SIZE (rli->prev_field))\n+\t\t  && rli->remaining_in_alignment)\n \t\t{\n-\t\t  tree type_size = TYPE_SIZE (TREE_TYPE (rli->prev_field));\n-\n-\t\t  /* If the desired alignment is greater or equal to TYPE_SIZE,\n-\t\t     we have already adjusted rli->bitpos / rli->offset above.\n-\t\t   */\n-\t\t  if ((unsigned HOST_WIDE_INT) tree_low_cst (type_size, 0)\n-\t\t      > desired_align)\n-\t\t    rli->bitpos\n-\t\t      = size_binop (PLUS_EXPR, type_size,\n-\t\t\t\t    DECL_FIELD_BIT_OFFSET (rli->prev_field));\n+\t\t  rli->bitpos\n+\t\t    = size_binop (PLUS_EXPR, rli->bitpos,\n+\t\t\t\t  bitsize_int (rli->remaining_in_alignment));\n \t\t}\n \t      else\n \t\t/* We \"use up\" size zero fields; the code below should behave\n@@ -1115,7 +1089,6 @@ place_field (record_layout_info rli, tree field)\n \t\trli->prev_field = NULL;\n \t    }\n \n-\t  rli->prev_packed = 0;\n \t  normalize_rli (rli);\n         }\n \n@@ -1148,21 +1121,11 @@ place_field (record_layout_info rli, tree field)\n \t      && host_integerp (TYPE_SIZE (TREE_TYPE (field)), 0)\n \t      && host_integerp (DECL_SIZE (field), 0))\n \t    rli->remaining_in_alignment\n-\t      = tree_low_cst (TYPE_SIZE (TREE_TYPE(field)), 0)\n-\t\t- tree_low_cst (DECL_SIZE (field), 0);\n+\t      = tree_low_cst (TYPE_SIZE (TREE_TYPE(field)), 1)\n+\t\t- tree_low_cst (DECL_SIZE (field), 1);\n \n \t  /* Now align (conventionally) for the new type.  */\n-\t  if (!DECL_PACKED(field))\n-\t    type_align = MAX(TYPE_ALIGN (type), type_align);\n-\n-\t  if (prev_saved\n-\t      && DECL_BIT_FIELD_TYPE (prev_saved)\n-\t      /* If the previous bit-field is zero-sized, we've already\n-\t\t accounted for its alignment needs (or ignored it, if\n-\t\t appropriate) while placing it.  */\n-\t      && ! integer_zerop (DECL_SIZE (prev_saved)))\n-\t    type_align = MAX (type_align,\n-\t\t\t      TYPE_ALIGN (TREE_TYPE (prev_saved)));\n+\t  type_align = TYPE_ALIGN (TREE_TYPE (field));\n \n \t  if (maximum_field_alignment != 0)\n \t    type_align = MIN (type_align, maximum_field_alignment);\n@@ -1202,49 +1165,8 @@ place_field (record_layout_info rli, tree field)\n   if (known_align != actual_align)\n     layout_decl (field, actual_align);\n \n-  if (DECL_BIT_FIELD_TYPE (field))\n-    {\n-      unsigned int type_align = TYPE_ALIGN (type);\n-      unsigned int mfa = maximum_field_alignment;\n-\n-      if (integer_zerop (DECL_SIZE (field)))\n-        mfa = initial_max_fld_align * BITS_PER_UNIT;\n-\n-      /* Only the MS bitfields use this.  We used to also put any kind of\n-\t packed bit fields into prev_field, but that makes no sense, because\n-\t an 8 bit packed bit field shouldn't impose more restriction on\n-\t following fields than a char field, and the alignment requirements\n-\t are also not fulfilled.\n-\t There is no sane value to set rli->remaining_in_alignment to when\n-\t a packed bitfield in prev_field is unaligned.  */\n-      if (mfa != 0)\n-\ttype_align = MIN (type_align, mfa);\n-      gcc_assert (rli->prev_field\n-\t\t  || actual_align >= type_align || DECL_PACKED (field)\n-\t\t  || integer_zerop (DECL_SIZE (field))\n-\t\t  || !targetm.ms_bitfield_layout_p (rli->t));\n-      if (rli->prev_field == NULL && actual_align >= type_align\n-\t  && !integer_zerop (DECL_SIZE (field)))\n-\t{\n-\t  rli->prev_field = field;\n-\t  /* rli->remaining_in_alignment has not been set if the bitfield\n-\t     has size zero, or if it is a packed bitfield.  */\n-\t  rli->remaining_in_alignment\n-\t    = (tree_low_cst (TYPE_SIZE (TREE_TYPE (field)), 0)\n-\t       - tree_low_cst (DECL_SIZE (field), 0));\n-\t  rli->prev_packed = DECL_PACKED (field);\n-\n-\t}\n-      else if (rli->prev_field && DECL_PACKED (field))\n-\t{\n-\t  HOST_WIDE_INT bitsize = tree_low_cst (DECL_SIZE (field), 0);\n-\n-\t  if (rli->remaining_in_alignment < bitsize)\n-\t    rli->prev_field = NULL;\n-\t  else\n-\t    rli->remaining_in_alignment -= bitsize;\n-\t}\n-    }\n+  if (rli->prev_field == NULL && DECL_BIT_FIELD_TYPE (field))\n+    rli->prev_field = field;\n \n   /* Now add size of this field to the size of the record.  If the size is\n      not constant, treat the field as being a multiple of bytes and just\n@@ -1268,6 +1190,21 @@ place_field (record_layout_info rli, tree field)\n       rli->bitpos = bitsize_zero_node;\n       rli->offset_align = MIN (rli->offset_align, desired_align);\n     }\n+  else if (targetm.ms_bitfield_layout_p (rli->t))\n+    {\n+      rli->bitpos = size_binop (PLUS_EXPR, rli->bitpos, DECL_SIZE (field));\n+\n+      /* If we ended a bitfield before the full length of the type then\n+\t pad the struct out to the full length of the last type.  */\n+      if ((TREE_CHAIN (field) == NULL\n+\t   || TREE_CODE (TREE_CHAIN (field)) != FIELD_DECL)\n+\t  && DECL_BIT_FIELD_TYPE (field)\n+\t  && !integer_zerop (DECL_SIZE (field)))\n+\trli->bitpos = size_binop (PLUS_EXPR, rli->bitpos,\n+\t\t\t\t  bitsize_int (rli->remaining_in_alignment));\n+\n+      normalize_rli (rli);\n+    }\n   else\n     {\n       rli->bitpos = size_binop (PLUS_EXPR, rli->bitpos, DECL_SIZE (field));\n@@ -1796,7 +1733,7 @@ layout_type (tree type)\n \t      length = size_binop (MAX_EXPR, length, size_zero_node);\n \n \t    TYPE_SIZE (type) = size_binop (MULT_EXPR, element_size,\n-\t\t\t\t\t   fold_convert (bitsizetype, \n+\t\t\t\t\t   fold_convert (bitsizetype,\n \t\t\t\t\t\t\t length));\n \n \t    /* If we know the size of the element, calculate the total\n@@ -1994,11 +1931,11 @@ set_sizetype (tree type)\n   TREE_TYPE (TYPE_CACHED_VALUES (t)) = type;\n   TYPE_UID (t) = TYPE_UID (sizetype);\n   TYPE_IS_SIZETYPE (t) = 1;\n-  \n+\n   /* Replace our original stub sizetype.  */\n   memcpy (sizetype, t, tree_size (sizetype));\n   TYPE_MAIN_VARIANT (sizetype) = sizetype;\n-  \n+\n   t = make_node (INTEGER_TYPE);\n   TYPE_NAME (t) = get_identifier (\"bit_size_type\");\n   /* We do want to use bitsizetype's cache, as we will be replacing that\n@@ -2012,7 +1949,7 @@ set_sizetype (tree type)\n   /* Replace our original stub bitsizetype.  */\n   memcpy (bitsizetype, t, tree_size (bitsizetype));\n   TYPE_MAIN_VARIANT (bitsizetype) = bitsizetype;\n-  \n+\n   if (TYPE_UNSIGNED (type))\n     {\n       fixup_unsigned_type (bitsizetype);\n@@ -2158,14 +2095,14 @@ fixup_unsigned_type (tree type)\n    larger than LARGEST_MODE (usually SImode).\n \n    If no mode meets all these conditions, we return VOIDmode.\n-   \n+\n    If VOLATILEP is false and SLOW_BYTE_ACCESS is false, we return the\n    smallest mode meeting these conditions.\n \n    If VOLATILEP is false and SLOW_BYTE_ACCESS is true, we return the\n    largest mode (but a mode no wider than UNITS_PER_WORD) that meets\n    all the conditions.\n-   \n+\n    If VOLATILEP is true the narrow_volatile_bitfields target hook is used to\n    decide which of the above modes should be used.  */\n "}, {"sha": "43d0d6624af2a2bf85f979f68bc26e713ccc62c9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ac11108c422b8daeb62e22c5f04beeb299055dc", "patch": "@@ -1,3 +1,7 @@\n+2006-06-04 Eric Christopher <echristo@apple.com>\n+\n+\t* gcc.dg/attr-ms_struct-1.c: New.\n+\n 2006-06-04  Mark Shinwell  <shinwell@codesourcery.com>\n \n \t* gcc.c-torture/compile/builtin_constant_p.c: New test."}, {"sha": "eafab93637f154aa26ea8f991d5d3f3ff8c11c51", "filename": "gcc/testsuite/gcc.dg/attr-ms_struct-1.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-ms_struct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-ms_struct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-ms_struct-1.c?ref=0ac11108c422b8daeb62e22c5f04beeb299055dc", "patch": "@@ -0,0 +1,164 @@\n+/* Test for MS structure sizes.  */\n+/* { dg-do run { target *-*-interix* *-*-mingw* *-*-cygwin* i?86-*-darwin* } }\n+/* { dg-options \"-std=gnu99\" } */\n+\n+extern void abort ();\n+\n+#define ATTR __attribute__((__ms_struct__))\n+\n+#define size_struct_0 1\n+#define size_struct_1 4\n+#define size_struct_2 24\n+#define size_struct_3 8\n+#define size_struct_4 32\n+#define size_struct_5 12\n+#define size_struct_6 40\n+#define size_struct_7 8\n+#define size_struct_8 20\n+#define size_struct_9 32\n+\n+struct _struct_0\n+{\n+  char member_0;\n+} ATTR;\n+typedef struct _struct_0 struct_0;\n+\n+struct _struct_1\n+{\n+  char member_0;\n+  short member_1:13;\n+} ATTR;\n+typedef struct _struct_1 struct_1;\n+\n+struct _struct_2\n+{\n+  double member_0;\n+  unsigned char member_1:8;\n+  long member_2:32;\n+  unsigned char member_3:5;\n+  short member_4:14;\n+  short member_5:13;\n+  unsigned char:0;\n+} ATTR;\n+typedef struct _struct_2 struct_2;\n+\n+struct _struct_3\n+{\n+  unsigned long member_0:26;\n+  unsigned char member_1:2;\n+\n+} ATTR;\n+typedef struct _struct_3 struct_3;\n+\n+struct _struct_4\n+{\n+  unsigned char member_0:7;\n+  double member_1;\n+  double member_2;\n+  short member_3:5;\n+  char member_4:2;\n+\n+} ATTR;\n+typedef struct _struct_4 struct_4;\n+\n+struct _struct_5\n+{\n+  unsigned short member_0:12;\n+  long member_1:1;\n+  unsigned short member_2:6;\n+\n+} ATTR;\n+typedef struct _struct_5 struct_5;\n+\n+struct _struct_6\n+{\n+  unsigned char member_0:7;\n+  unsigned long member_1:25;\n+  char member_2:1;\n+  double member_3;\n+  short member_4:9;\n+  double member_5;\n+\n+} ATTR;\n+typedef struct _struct_6 struct_6;\n+\n+struct _struct_7\n+{\n+  double member_0;\n+\n+} ATTR;\n+typedef struct _struct_7 struct_7;\n+\n+struct _struct_8\n+{\n+  unsigned char member_0:7;\n+  long member_1:11;\n+  long member_2:5;\n+  long:0;\n+  char member_4:8;\n+  unsigned short member_5:4;\n+  unsigned char member_6:3;\n+  long member_7:23;\n+\n+} ATTR;\n+typedef struct _struct_8 struct_8;\n+\n+struct _struct_9\n+{\n+  double member_0;\n+  unsigned long member_1:6;\n+  long member_2:17;\n+  double member_3;\n+  unsigned long member_4:22;\n+\n+} ATTR;\n+typedef struct _struct_9 struct_9;\n+\n+struct_0 test_struct_0 = { 123 };\n+struct_1 test_struct_1 = { 82, 1081 };\n+struct_2 test_struct_2 = { 20.0, 31, 407760, 1, 14916, 6712 };\n+struct_3 test_struct_3 = { 64616999, 1 };\n+struct_4 test_struct_4 = { 61, 20.0, 20.0, 12, 0 };\n+struct_5 test_struct_5 = { 909, 1, 57 };\n+struct_6 test_struct_6 = { 12, 21355796, 0, 20.0, 467, 20.0 };\n+struct_7 test_struct_7 = { 20.0 };\n+struct_8 test_struct_8 = { 126, 1821, 22, 125, 6, 0, 2432638 };\n+struct_9 test_struct_9 = { 20.0, 3, 23957, 20.0, 1001631 };\n+\n+\n+int\n+main (void)\n+{\n+\n+  if (size_struct_0 != sizeof (struct_0))\n+    abort ();\n+\n+  if (size_struct_1 != sizeof (struct_1))\n+    abort ();\n+\n+  if (size_struct_2 != sizeof (struct_2))\n+    abort ();\n+\n+  if (size_struct_3 != sizeof (struct_3))\n+    abort ();\n+\n+  if (size_struct_4 != sizeof (struct_4))\n+    abort ();\n+\n+  if (size_struct_5 != sizeof (struct_5))\n+    abort ();\n+\n+  if (size_struct_6 != sizeof (struct_6))\n+    abort ();\n+\n+  if (size_struct_7 != sizeof (struct_7))\n+    abort ();\n+\n+  if (size_struct_8 != sizeof (struct_8))\n+    abort ();\n+\n+  if (size_struct_9 != sizeof (struct_9))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "9c1181873f815c6411b68f72c06c5ef6578c1636", "filename": "gcc/tree.h", "status": "modified", "additions": 41, "deletions": 44, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac11108c422b8daeb62e22c5f04beeb299055dc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0ac11108c422b8daeb62e22c5f04beeb299055dc", "patch": "@@ -107,7 +107,7 @@ extern const enum tree_code_class tree_code_type[];\n   (TREE_CODE (CODE) == STRUCT_FIELD_TAG\t\t\\\n    || TREE_CODE (CODE) == NAME_MEMORY_TAG\t\\\n    || TREE_CODE (CODE) == SYMBOL_MEMORY_TAG)\n-        \n+\n \n /* Nonzero if DECL represents a VAR_DECL or FUNCTION_DECL.  */\n \n@@ -293,7 +293,7 @@ enum omp_clause_code\n   /* OpenMP clause: reduction (operator:variable_list).\n      OMP_CLAUSE_REDUCTION_CODE: The tree_code of the operator.\n      Operand 1: OMP_CLAUSE_REDUCTION_INIT: Stmt-list to initialize the var.\n-     Operand 2: OMP_CLAUSE_REDUCTION_MERGE: Stmt-list to merge private var \n+     Operand 2: OMP_CLAUSE_REDUCTION_MERGE: Stmt-list to merge private var\n                 into the shared one.\n      Operand 3: OMP_CLAUSE_REDUCTION_PLACEHOLDER: A dummy VAR_DECL\n                 placeholder used in OMP_CLAUSE_REDUCTION_MERGE.  */\n@@ -773,7 +773,7 @@ enum tree_node_structure_enum {\n     &__t->exp.operands[__i]; }))\n \n extern void tree_contains_struct_check_failed (const tree,\n-\t\t\t\t\t       const enum tree_node_structure_enum,\t\t\t\t     \n+\t\t\t\t\t       const enum tree_node_structure_enum,\n \t\t\t\t\t       const char *, int, const char *)\n   ATTRIBUTE_NORETURN;\n \n@@ -1160,7 +1160,7 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n /* Nonzero in a _DECL if the name is used in its scope.\n    Nonzero in an expr node means inhibit warning if value is unused.\n    In IDENTIFIER_NODEs, this means that some extern decl for this name\n-   was used.  \n+   was used.\n    In a BLOCK, this means that the block contains variables that are used.  */\n #define TREE_USED(NODE) ((NODE)->common.used_flag)\n \n@@ -1730,10 +1730,10 @@ struct tree_ssa_name GTY(())\n \f\n /* In a PHI_NODE node.  */\n \n-/* These 2 macros should be considered off limits for use by developers.  If \n-   you wish to access the use or def fields of a PHI_NODE in the SSA \n-   optimizers, use the accessor macros found in tree-ssa-operands.h.  \n-   These two macros are to be used only by those accessor macros, and other \n+/* These 2 macros should be considered off limits for use by developers.  If\n+   you wish to access the use or def fields of a PHI_NODE in the SSA\n+   optimizers, use the accessor macros found in tree-ssa-operands.h.\n+   These two macros are to be used only by those accessor macros, and other\n    select places where we *absolutely* must take the address of the tree.  */\n \n #define PHI_RESULT_TREE(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.result\n@@ -2310,7 +2310,7 @@ struct tree_decl_minimal GTY(())\n /* When computing aliasing information, we represent the memory pointed-to\n    by pointers with artificial variables called \"memory tags\" (MT).  There\n    are two kinds of tags, namely symbol and name:\n-   \n+\n    Symbol tags (SMT) are used in flow-insensitive alias analysis, they\n    represent all the pointed-to locations and variables pointed-to by\n    the same pointer symbol.  Usually, this set is computed using\n@@ -2347,10 +2347,10 @@ struct tree_memory_tag GTY(())\n struct tree_struct_field_tag GTY(())\n {\n   struct tree_memory_tag common;\n-  \n+\n   /* Parent variable.  */\n   tree parent_var;\n- \n+\n   /* Offset inside structure.  */\n   unsigned HOST_WIDE_INT offset;\n \n@@ -2391,7 +2391,7 @@ struct tree_struct_field_tag GTY(())\n    values for parameters are encoded in the type of the function,\n    not in the PARM_DECL slot.\n    For a FIELD_DECL, this is used for enumeration values and the C\n-   frontend uses it for temporarily storing bitwidth of bitfields. \n+   frontend uses it for temporarily storing bitwidth of bitfields.\n \n    ??? Need to figure out some way to check this isn't a PARM_DECL.  */\n #define DECL_INITIAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.initial)\n@@ -2424,7 +2424,7 @@ struct tree_struct_field_tag GTY(())\n   (DECL_COMMON_CHECK (NODE)->decl_common.debug_expr_is_from)\n \n /* Nonzero for a given ..._DECL node means that the name of this node should\n-   be ignored for symbolic debug purposes.  */ \n+   be ignored for symbolic debug purposes.  */\n #define DECL_IGNORED_P(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.ignored_flag)\n \n /* Nonzero for a given ..._DECL node means that this node represents an\n@@ -2500,7 +2500,7 @@ struct tree_struct_field_tag GTY(())\n    This indicates compiler tools that this decl needs to be preserved.  */\n #define DECL_PRESERVE_P(DECL) \\\n   DECL_COMMON_CHECK (DECL)->decl_common.preserve_flag\n- \n+\n /* For function local variables of COMPLEX type, indicates that the\n    variable is not aliased, and that all modifications to the variable\n    have been adjusted so that they are killing assignments.  Thus the\n@@ -2539,24 +2539,24 @@ struct tree_decl_common GTY(())\n   unsigned lang_flag_5 : 1;\n   unsigned lang_flag_6 : 1;\n   unsigned lang_flag_7 : 1;\n- \n+\n   /* In LABEL_DECL, this is DECL_ERROR_ISSUED.\n      In VAR_DECL and PARM_DECL, this is DECL_REGISTER.  */\n   unsigned decl_flag_0 : 1;\n   /* In FIELD_DECL, this is DECL_PACKED.  */\n   unsigned decl_flag_1 : 1;\n   /* In FIELD_DECL, this is DECL_BIT_FIELD\n-     In VAR_DECL and FUNCTION_DECL, this is DECL_EXTERNAL. \n-     In TYPE_DECL, this is TYPE_DECL_SUPRESS_DEBUG.  */  \n-  unsigned decl_flag_2 : 1;  \n+     In VAR_DECL and FUNCTION_DECL, this is DECL_EXTERNAL.\n+     In TYPE_DECL, this is TYPE_DECL_SUPRESS_DEBUG.  */\n+  unsigned decl_flag_2 : 1;\n   /* In FIELD_DECL, this is DECL_NONADDRESSABLE_P\n      In VAR_DECL and PARM_DECL, this is DECL_HAS_VALUE_EXPR.  */\n-  unsigned decl_flag_3 : 1;  \n-  /* Logically, these two would go in a theoretical base shared by var and \n+  unsigned decl_flag_3 : 1;\n+  /* Logically, these two would go in a theoretical base shared by var and\n      parm decl. */\n   unsigned gimple_reg_flag : 1;\n   unsigned call_clobbered_flag : 1;\n-  \n+\n   union tree_decl_u1 {\n     /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n        DECL_FUNCTION_CODE.  */\n@@ -2576,8 +2576,8 @@ struct tree_decl_common GTY(())\n   tree initial;\n   tree attributes;\n   tree abstract_origin;\n-  \n-  HOST_WIDE_INT pointer_alias_set; \n+\n+  HOST_WIDE_INT pointer_alias_set;\n   /* Points to a structure whose details depend on the language in use.  */\n   struct lang_decl *lang_specific;\n };\n@@ -2592,7 +2592,7 @@ extern void decl_value_expr_insert (tree, tree);\n #define DECL_HAS_VALUE_EXPR_P(NODE) \\\n   (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl_common.decl_flag_3)\n #define DECL_VALUE_EXPR(NODE) \\\n-  (decl_value_expr_lookup (DECL_WRTL_CHECK (NODE))) \n+  (decl_value_expr_lookup (DECL_WRTL_CHECK (NODE)))\n #define SET_DECL_VALUE_EXPR(NODE, VAL)\t\t\t\\\n   (decl_value_expr_insert (DECL_WRTL_CHECK (NODE), VAL))\n \n@@ -2681,12 +2681,12 @@ struct tree_field_decl GTY(())\n {\n   struct tree_decl_common common;\n \n-  tree offset;\t\n-  tree bit_field_type;\t\n+  tree offset;\n+  tree bit_field_type;\n   tree qualifier;\n   tree bit_offset;\n   tree fcontext;\n- \n+\n };\n \n /* A numeric unique identifier for a LABEL_DECL.  The UID allocation is\n@@ -2703,7 +2703,7 @@ struct tree_label_decl GTY(())\n {\n   struct tree_decl_with_rtl common;\n   /* Java's verifier has some need to store information about labels,\n-     and was using fields that no longer exist on labels.  \n+     and was using fields that no longer exist on labels.\n      Once the verifier doesn't need these anymore, they should be removed.  */\n   tree java_field_1;\n   tree java_field_2;\n@@ -2733,7 +2733,7 @@ struct tree_const_decl GTY(())\n struct tree_parm_decl GTY(())\n {\n   struct tree_decl_with_rtl common;\n-  rtx incoming_rtl;  \n+  rtx incoming_rtl;\n };\n \n \n@@ -2793,7 +2793,7 @@ extern void decl_restrict_base_insert (tree, tree);\n    as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n #define DECL_ASSEMBLER_NAME(NODE) decl_assembler_name (NODE)\n \n-/* Return true if NODE is a NODE that can contain a DECL_ASSEMBLER_NAME. \n+/* Return true if NODE is a NODE that can contain a DECL_ASSEMBLER_NAME.\n    This is true of all DECL nodes except FIELD_DECL.  */\n #define HAS_DECL_ASSEMBLER_NAME_P(NODE) \\\n   (CODE_CONTAINS_STRUCT (TREE_CODE (NODE), TS_DECL_WITH_VIS))\n@@ -2843,19 +2843,19 @@ struct tree_decl_with_vis GTY(())\n  struct tree_decl_with_rtl common;\n  tree assembler_name;\n  tree section_name;\n-  \n+\n  /* Belong to VAR_DECL exclusively.  */\n  unsigned defer_output:1;\n  unsigned hard_register:1;\n  unsigned thread_local:1;\n- unsigned common_flag:1; \n+ unsigned common_flag:1;\n  unsigned in_text_section : 1;\n  unsigned gimple_formal_temp : 1;\n- unsigned dllimport_flag : 1; \n+ unsigned dllimport_flag : 1;\n  unsigned based_on_restrict_p : 1;\n  /* Used by C++.  Might become a generic decl flag.  */\n  unsigned shadowed_for_var_p : 1;\n- \n+\n  /* Don't belong to VAR_DECL exclusively.  */\n  unsigned in_system_header_flag : 1;\n  unsigned weak_flag:1;\n@@ -2936,7 +2936,7 @@ struct tree_var_decl GTY(())\n    is the FUNCTION_DECL which this FUNCTION_DECL will replace as a virtual\n    function.  When the class is laid out, this pointer is changed\n    to an INTEGER_CST node which is suitable for use as an index\n-   into the virtual function table.  \n+   into the virtual function table.\n    C++ also uses this field in namespaces, hence the DECL_NON_COMMON_CHECK.  */\n #define DECL_VINDEX(NODE) (DECL_NON_COMMON_CHECK (NODE)->decl_non_common.vindex)\n \n@@ -2947,9 +2947,9 @@ struct tree_decl_non_common GTY(())\n   /* C++ uses this in namespaces.  */\n   tree saved_tree;\n   /* C++ uses this in templates.  */\n-  tree arguments;\t\n+  tree arguments;\n   /* Almost all FE's use this.  */\n-  tree result; \n+  tree result;\n   /* C++ uses this in namespaces.  */\n   tree vindex;\n };\n@@ -3048,7 +3048,7 @@ struct tree_decl_non_common GTY(())\n struct tree_function_decl GTY(())\n {\n   struct tree_decl_non_common common;\n-  \n+\n   unsigned static_ctor_flag : 1;\n   unsigned static_dtor_flag : 1;\n   unsigned uninlinable : 1;\n@@ -3057,7 +3057,7 @@ struct tree_function_decl GTY(())\n   unsigned returns_twice_flag : 1;\n   unsigned malloc_flag : 1;\n   unsigned pure_flag : 1;\n-  \n+\n   unsigned declared_inline_flag : 1;\n   unsigned regdecl_flag : 1;\n   unsigned inline_flag : 1;\n@@ -3177,7 +3177,7 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_value_handle GTY ((tag (\"TS_VALUE_HANDLE\"))) value_handle;\n   struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n   struct tree_memory_tag GTY ((tag (\"TS_MEMORY_TAG\"))) mtag;\n-  struct tree_struct_field_tag GTY ((tag (\"TS_STRUCT_FIELD_TAG\"))) sft; \n+  struct tree_struct_field_tag GTY ((tag (\"TS_STRUCT_FIELD_TAG\"))) sft;\n   struct tree_omp_clause GTY ((tag (\"TS_OMP_CLAUSE\"))) omp_clause;\n };\n \f\n@@ -3533,7 +3533,7 @@ extern tree build_string (int, const char *);\n extern tree build_tree_list_stat (tree, tree MEM_STAT_DECL);\n #define build_tree_list(t,q) build_tree_list_stat(t,q MEM_STAT_INFO)\n extern tree build_decl_stat (enum tree_code, tree, tree MEM_STAT_DECL);\n-extern tree build_fn_decl (const char *, tree); \n+extern tree build_fn_decl (const char *, tree);\n #define build_decl(c,t,q) build_decl_stat (c,t,q MEM_STAT_INFO)\n extern tree build_block (tree, tree, tree, tree);\n #ifndef USE_MAPPED_LOCATION\n@@ -3775,9 +3775,6 @@ typedef struct record_layout_info_s\n   tree pending_statics;\n   /* Bits remaining in the current alignment group */\n   int remaining_in_alignment;\n-  /* True if prev_field was packed and we haven't found any non-packed\n-     fields that we have put in the same alignment group.  */\n-  int prev_packed;\n   /* True if we've seen a packed field that didn't have normal\n      alignment anyway.  */\n   int packed_maybe_necessary;"}]}