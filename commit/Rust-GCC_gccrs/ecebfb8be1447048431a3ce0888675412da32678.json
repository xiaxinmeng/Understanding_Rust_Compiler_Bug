{"sha": "ecebfb8be1447048431a3ce0888675412da32678", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNlYmZiOGJlMTQ0NzA0ODQzMWEzY2UwODg4Njc1NDEyZGEzMjY3OA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2006-06-22T06:04:02Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2006-06-22T06:04:02Z"}, "message": "re PR fortran/26769 (Implement transpose() and reshape() for real instead of using integer)\n\n\tPR libfortran/26769\n\n\t* iresolve.c (gfc_resolve_reshape): Call reshape_r4 and\n\treshape_r8 instead of reshape_4 and reshape_8.\n\t(gfc_resolve_transpose): Likewise for transpose.\n\n\t* Makefile.am: Add r4 and r8 versions of reshape and transpose.\n\t* Makefile.in: Regenerate.\n\t* generated/reshape_r4.c: New file.\n\t* generated/reshape_r8.c: New file.\n\t* generated/transpose_r4.c: New file.\n\t* generated/transpose_r8.c: New file.\n\nFrom-SVN: r114880", "tree": {"sha": "2fe966f72fa77dacad7c5e1315123bea204e15ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fe966f72fa77dacad7c5e1315123bea204e15ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecebfb8be1447048431a3ce0888675412da32678", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecebfb8be1447048431a3ce0888675412da32678", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecebfb8be1447048431a3ce0888675412da32678", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecebfb8be1447048431a3ce0888675412da32678/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ac046f2f1134d069de1f9a98aaeaa8f2f3221a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ac046f2f1134d069de1f9a98aaeaa8f2f3221a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ac046f2f1134d069de1f9a98aaeaa8f2f3221a6"}], "stats": {"total": 782, "additions": 752, "deletions": 30}, "files": [{"sha": "55e66cdfdc88230fd90c5b23ca53ba135e6ae687", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecebfb8be1447048431a3ce0888675412da32678/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecebfb8be1447048431a3ce0888675412da32678/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ecebfb8be1447048431a3ce0888675412da32678", "patch": "@@ -1,3 +1,10 @@\n+2006-06-22  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR libfortran/26769\n+\t* iresolve.c (gfc_resolve_reshape): Call reshape_r4 and\n+\treshape_r8 instead of reshape_4 and reshape_8.\n+\t(gfc_resolve_transpose): Likewise for transpose.\n+\n 2006-06-21  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* trans-expr.c (gfc_conv_missing_dummy, gfc_conv_unary_op,"}, {"sha": "f81488ab1cf05551cb05aecca9bf082999bd37ab", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecebfb8be1447048431a3ce0888675412da32678/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecebfb8be1447048431a3ce0888675412da32678/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=ecebfb8be1447048431a3ce0888675412da32678", "patch": "@@ -1574,14 +1574,10 @@ gfc_resolve_reshape (gfc_expr * f, gfc_expr * source, gfc_expr * shape,\n     case 8:\n     case 10:\n     case 16:\n-      if (source->ts.type == BT_COMPLEX)\n+      if (source->ts.type == BT_COMPLEX || source->ts.type == BT_REAL)\n \tf->value.function.name =\n \t  gfc_get_string (PREFIX(\"reshape_%c%d\"),\n-\t\t\t  gfc_type_letter (BT_COMPLEX), source->ts.kind);\n-      else if (source->ts.type == BT_REAL && (kind == 10 || kind == 16))\n-\tf->value.function.name =\n-\t  gfc_get_string (PREFIX(\"reshape_%c%d\"),\n-\t\t\t  gfc_type_letter (BT_REAL), source->ts.kind);\n+\t\t\t  gfc_type_letter (source->ts.type), source->ts.kind);\n       else\n \tf->value.function.name =\n \t  gfc_get_string (PREFIX(\"reshape_%d\"), source->ts.kind);\n@@ -2025,8 +2021,6 @@ gfc_resolve_transfer (gfc_expr * f, gfc_expr * source ATTRIBUTE_UNUSED,\n void\n gfc_resolve_transpose (gfc_expr * f, gfc_expr * matrix)\n {\n-  int kind;\n-\n   f->ts = matrix->ts;\n   f->rank = 2;\n   if (matrix->shape)\n@@ -2036,40 +2030,28 @@ gfc_resolve_transpose (gfc_expr * f, gfc_expr * matrix)\n       mpz_init_set (f->shape[1], matrix->shape[0]);\n     }\n \n-  kind = matrix->ts.kind;\n-\n-  switch (kind)\n+  switch (matrix->ts.kind)\n     {\n     case 4:\n     case 8:\n     case 10:\n     case 16:\n       switch (matrix->ts.type)\n         {\n+        case BT_REAL:\n         case BT_COMPLEX:\n           f->value.function.name =\n-            gfc_get_string (PREFIX(\"transpose_c%d\"), kind);\n+            gfc_get_string (PREFIX(\"transpose_%c%d\"),\n+\t\t\t    gfc_type_letter (matrix->ts.type),\n+\t\t\t    matrix->ts.kind);\n           break;\n \n-        case BT_REAL:\n-\t  /* There is no kind=10 integer type and on 32-bit targets\n-\t     there is usually no kind=16 integer type.  We need to\n-\t     call the real version.  */\n-\t  if (kind == 10 || kind == 16)\n-\t    {\n-\t      f->value.function.name =\n-\t\tgfc_get_string (PREFIX(\"transpose_r%d\"), kind);\n-\t      break;\n-\t    }\n-\n-\t  /* Fall through */\n-\n         case BT_INTEGER:\n         case BT_LOGICAL:\n \t  /* Use the integer routines for real and logical cases.  This\n \t     assumes they all have the same alignment requirements.  */\n           f->value.function.name =\n-            gfc_get_string (PREFIX(\"transpose_i%d\"), kind);\n+            gfc_get_string (PREFIX(\"transpose_i%d\"), matrix->ts.kind);\n           break;\n \n         default:"}, {"sha": "22989c83f5a52a1196c23c884e2b7e7e0a5fd34b", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=ecebfb8be1447048431a3ce0888675412da32678", "patch": "@@ -312,6 +312,8 @@ i_transpose_c= \\\n generated/transpose_i4.c \\\n generated/transpose_i8.c \\\n generated/transpose_i16.c \\\n+generated/transpose_r4.c \\\n+generated/transpose_r8.c \\\n generated/transpose_r10.c \\\n generated/transpose_r16.c \\\n generated/transpose_c4.c \\\n@@ -328,6 +330,8 @@ i_reshape_c= \\\n generated/reshape_i4.c \\\n generated/reshape_i8.c \\\n generated/reshape_i16.c \\\n+generated/reshape_r4.c \\\n+generated/reshape_r8.c \\\n generated/reshape_r10.c \\\n generated/reshape_r16.c \\\n generated/reshape_c4.c \\"}, {"sha": "f8e0bd3db1b25f6e77a0f396cd3d2f2421608c0d", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=ecebfb8be1447048431a3ce0888675412da32678", "patch": "@@ -122,15 +122,16 @@ am__objects_16 = matmul_i4.lo matmul_i8.lo matmul_i16.lo matmul_r4.lo \\\n \tmatmul_c8.lo matmul_c10.lo matmul_c16.lo\n am__objects_17 = matmul_l4.lo matmul_l8.lo matmul_l16.lo\n am__objects_18 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \\\n-\ttranspose_r10.lo transpose_r16.lo transpose_c4.lo \\\n-\ttranspose_c8.lo transpose_c10.lo transpose_c16.lo\n+\ttranspose_r4.lo transpose_r8.lo transpose_r10.lo \\\n+\ttranspose_r16.lo transpose_c4.lo transpose_c8.lo \\\n+\ttranspose_c10.lo transpose_c16.lo\n am__objects_19 = shape_i4.lo shape_i8.lo shape_i16.lo\n am__objects_20 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo\n am__objects_21 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo\n am__objects_22 = cshift1_4.lo cshift1_8.lo cshift1_16.lo\n am__objects_23 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \\\n-\treshape_r10.lo reshape_r16.lo reshape_c4.lo reshape_c8.lo \\\n-\treshape_c10.lo reshape_c16.lo\n+\treshape_r4.lo reshape_r8.lo reshape_r10.lo reshape_r16.lo \\\n+\treshape_c4.lo reshape_c8.lo reshape_c10.lo reshape_c16.lo\n am__objects_24 = in_pack_i4.lo in_pack_i8.lo in_pack_i16.lo \\\n \tin_pack_c4.lo in_pack_c8.lo in_pack_c10.lo in_pack_c16.lo\n am__objects_25 = in_unpack_i4.lo in_unpack_i8.lo in_unpack_i16.lo \\\n@@ -659,6 +660,8 @@ i_transpose_c = \\\n generated/transpose_i4.c \\\n generated/transpose_i8.c \\\n generated/transpose_i16.c \\\n+generated/transpose_r4.c \\\n+generated/transpose_r8.c \\\n generated/transpose_r10.c \\\n generated/transpose_r16.c \\\n generated/transpose_c4.c \\\n@@ -675,6 +678,8 @@ i_reshape_c = \\\n generated/reshape_i4.c \\\n generated/reshape_i8.c \\\n generated/reshape_i16.c \\\n+generated/reshape_r4.c \\\n+generated/reshape_r8.c \\\n generated/reshape_r10.c \\\n generated/reshape_r16.c \\\n generated/reshape_c4.c \\\n@@ -1933,6 +1938,12 @@ transpose_i8.lo: generated/transpose_i8.c\n transpose_i16.lo: generated/transpose_i16.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transpose_i16.lo `test -f 'generated/transpose_i16.c' || echo '$(srcdir)/'`generated/transpose_i16.c\n \n+transpose_r4.lo: generated/transpose_r4.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transpose_r4.lo `test -f 'generated/transpose_r4.c' || echo '$(srcdir)/'`generated/transpose_r4.c\n+\n+transpose_r8.lo: generated/transpose_r8.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transpose_r8.lo `test -f 'generated/transpose_r8.c' || echo '$(srcdir)/'`generated/transpose_r8.c\n+\n transpose_r10.lo: generated/transpose_r10.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transpose_r10.lo `test -f 'generated/transpose_r10.c' || echo '$(srcdir)/'`generated/transpose_r10.c\n \n@@ -1996,6 +2007,12 @@ reshape_i8.lo: generated/reshape_i8.c\n reshape_i16.lo: generated/reshape_i16.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_i16.lo `test -f 'generated/reshape_i16.c' || echo '$(srcdir)/'`generated/reshape_i16.c\n \n+reshape_r4.lo: generated/reshape_r4.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_r4.lo `test -f 'generated/reshape_r4.c' || echo '$(srcdir)/'`generated/reshape_r4.c\n+\n+reshape_r8.lo: generated/reshape_r8.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_r8.lo `test -f 'generated/reshape_r8.c' || echo '$(srcdir)/'`generated/reshape_r8.c\n+\n reshape_r10.lo: generated/reshape_r10.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_r10.lo `test -f 'generated/reshape_r10.c' || echo '$(srcdir)/'`generated/reshape_r10.c\n "}, {"sha": "acd73a4935a6c5c1b5b21fda8f1210e26da73faf", "filename": "libgfortran/generated/reshape_r4.c", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2Fgenerated%2Freshape_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2Fgenerated%2Freshape_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r4.c?ref=ecebfb8be1447048431a3ce0888675412da32678", "patch": "@@ -0,0 +1,257 @@\n+/* Implementation of the RESHAPE\n+   Copyright 2002, 2006 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+typedef GFC_ARRAY_DESCRIPTOR(1, index_type) shape_type;\n+\n+/* The shape parameter is ignored. We can currently deduce the shape from the\n+   return array.  */\n+\n+extern void reshape_r4 (gfc_array_r4 * const restrict, \n+\tgfc_array_r4 * const restrict, \n+\tshape_type * const restrict,\n+\tgfc_array_r4 * const restrict, \n+\tshape_type * const restrict);\n+export_proto(reshape_r4);\n+\n+void\n+reshape_r4 (gfc_array_r4 * const restrict ret, \n+\tgfc_array_r4 * const restrict source, \n+\tshape_type * const restrict shape,\n+\tgfc_array_r4 * const restrict pad, \n+\tshape_type * const restrict order)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rcount[GFC_MAX_DIMENSIONS];\n+  index_type rextent[GFC_MAX_DIMENSIONS];\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdim;\n+  index_type rsize;\n+  index_type rs;\n+  index_type rex;\n+  GFC_REAL_4 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type scount[GFC_MAX_DIMENSIONS];\n+  index_type sextent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type sdim;\n+  index_type ssize;\n+  const GFC_REAL_4 *sptr;\n+  /* p.* indicates the pad array.  */\n+  index_type pcount[GFC_MAX_DIMENSIONS];\n+  index_type pextent[GFC_MAX_DIMENSIONS];\n+  index_type pstride[GFC_MAX_DIMENSIONS];\n+  index_type pdim;\n+  index_type psize;\n+  const GFC_REAL_4 *pptr;\n+\n+  const GFC_REAL_4 *src;\n+  int n;\n+  int dim;\n+\n+  if (ret->data == NULL)\n+    {\n+      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+      rs = 1;\n+      for (n=0; n < rdim; n++)\n+\t{\n+\t  ret->dim[n].lbound = 0;\n+\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  ret->dim[n].ubound =  rex - 1;\n+\t  ret->dim[n].stride = rs;\n+\t  rs *= rex;\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size ( rs * sizeof (GFC_REAL_4));\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n+    }\n+  else\n+    {\n+      rdim = GFC_DESCRIPTOR_RANK (ret);\n+    }\n+\n+  rsize = 1;\n+  for (n = 0; n < rdim; n++)\n+    {\n+      if (order)\n+        dim = order->data[n * order->dim[0].stride] - 1;\n+      else\n+        dim = n;\n+\n+      rcount[n] = 0;\n+      rstride[n] = ret->dim[dim].stride;\n+      rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+\n+      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+        runtime_error (\"shape and target do not conform\");\n+\n+      if (rsize == rstride[n])\n+        rsize *= rextent[n];\n+      else\n+        rsize = 0;\n+      if (rextent[n] <= 0)\n+        return;\n+    }\n+\n+  sdim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  for (n = 0; n < sdim; n++)\n+    {\n+      scount[n] = 0;\n+      sstride[n] = source->dim[n].stride;\n+      sextent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (sextent[n] <= 0)\n+        abort ();\n+\n+      if (ssize == sstride[n])\n+        ssize *= sextent[n];\n+      else\n+        ssize = 0;\n+    }\n+\n+  if (pad)\n+    {\n+      pdim = GFC_DESCRIPTOR_RANK (pad);\n+      psize = 1;\n+      for (n = 0; n < pdim; n++)\n+        {\n+          pcount[n] = 0;\n+          pstride[n] = pad->dim[n].stride;\n+          pextent[n] = pad->dim[n].ubound + 1 - pad->dim[n].lbound;\n+          if (pextent[n] <= 0)\n+            abort ();\n+          if (psize == pstride[n])\n+            psize *= pextent[n];\n+          else\n+            psize = 0;\n+        }\n+      pptr = pad->data;\n+    }\n+  else\n+    {\n+      pdim = 0;\n+      psize = 1;\n+      pptr = NULL;\n+    }\n+\n+  if (rsize != 0 && ssize != 0 && psize != 0)\n+    {\n+      rsize *= sizeof (GFC_REAL_4);\n+      ssize *= sizeof (GFC_REAL_4);\n+      psize *= sizeof (GFC_REAL_4);\n+      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n+\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      return;\n+    }\n+  rptr = ret->data;\n+  src = sptr = source->data;\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+\n+  while (rptr)\n+    {\n+      /* Select between the source and pad arrays.  */\n+      *rptr = *src;\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      src += sstride0;\n+      rcount[0]++;\n+      scount[0]++;\n+      /* Advance to the next destination element.  */\n+      n = 0;\n+      while (rcount[n] == rextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          rcount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          rptr -= rstride[n] * rextent[n];\n+          n++;\n+          if (n == rdim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              rcount[n]++;\n+              rptr += rstride[n];\n+            }\n+        }\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (scount[n] == sextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          scount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= sstride[n] * sextent[n];\n+          n++;\n+          if (n == sdim)\n+            {\n+              if (sptr && pad)\n+                {\n+                  /* Switch to the pad array.  */\n+                  sptr = NULL;\n+                  sdim = pdim;\n+                  for (dim = 0; dim < pdim; dim++)\n+                    {\n+                      scount[dim] = pcount[dim];\n+                      sextent[dim] = pextent[dim];\n+                      sstride[dim] = pstride[dim];\n+                      sstride0 = sstride[0];\n+                    }\n+                }\n+              /* We now start again from the beginning of the pad array.  */\n+              src = pptr;\n+              break;\n+            }\n+          else\n+            {\n+              scount[n]++;\n+              src += sstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "5f80f4cf67728d0700590e17a8d87a6517b9cfe3", "filename": "libgfortran/generated/reshape_r8.c", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2Fgenerated%2Freshape_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2Fgenerated%2Freshape_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r8.c?ref=ecebfb8be1447048431a3ce0888675412da32678", "patch": "@@ -0,0 +1,257 @@\n+/* Implementation of the RESHAPE\n+   Copyright 2002, 2006 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+typedef GFC_ARRAY_DESCRIPTOR(1, index_type) shape_type;\n+\n+/* The shape parameter is ignored. We can currently deduce the shape from the\n+   return array.  */\n+\n+extern void reshape_r8 (gfc_array_r8 * const restrict, \n+\tgfc_array_r8 * const restrict, \n+\tshape_type * const restrict,\n+\tgfc_array_r8 * const restrict, \n+\tshape_type * const restrict);\n+export_proto(reshape_r8);\n+\n+void\n+reshape_r8 (gfc_array_r8 * const restrict ret, \n+\tgfc_array_r8 * const restrict source, \n+\tshape_type * const restrict shape,\n+\tgfc_array_r8 * const restrict pad, \n+\tshape_type * const restrict order)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rcount[GFC_MAX_DIMENSIONS];\n+  index_type rextent[GFC_MAX_DIMENSIONS];\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdim;\n+  index_type rsize;\n+  index_type rs;\n+  index_type rex;\n+  GFC_REAL_8 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type scount[GFC_MAX_DIMENSIONS];\n+  index_type sextent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type sdim;\n+  index_type ssize;\n+  const GFC_REAL_8 *sptr;\n+  /* p.* indicates the pad array.  */\n+  index_type pcount[GFC_MAX_DIMENSIONS];\n+  index_type pextent[GFC_MAX_DIMENSIONS];\n+  index_type pstride[GFC_MAX_DIMENSIONS];\n+  index_type pdim;\n+  index_type psize;\n+  const GFC_REAL_8 *pptr;\n+\n+  const GFC_REAL_8 *src;\n+  int n;\n+  int dim;\n+\n+  if (ret->data == NULL)\n+    {\n+      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+      rs = 1;\n+      for (n=0; n < rdim; n++)\n+\t{\n+\t  ret->dim[n].lbound = 0;\n+\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  ret->dim[n].ubound =  rex - 1;\n+\t  ret->dim[n].stride = rs;\n+\t  rs *= rex;\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size ( rs * sizeof (GFC_REAL_8));\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n+    }\n+  else\n+    {\n+      rdim = GFC_DESCRIPTOR_RANK (ret);\n+    }\n+\n+  rsize = 1;\n+  for (n = 0; n < rdim; n++)\n+    {\n+      if (order)\n+        dim = order->data[n * order->dim[0].stride] - 1;\n+      else\n+        dim = n;\n+\n+      rcount[n] = 0;\n+      rstride[n] = ret->dim[dim].stride;\n+      rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+\n+      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+        runtime_error (\"shape and target do not conform\");\n+\n+      if (rsize == rstride[n])\n+        rsize *= rextent[n];\n+      else\n+        rsize = 0;\n+      if (rextent[n] <= 0)\n+        return;\n+    }\n+\n+  sdim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  for (n = 0; n < sdim; n++)\n+    {\n+      scount[n] = 0;\n+      sstride[n] = source->dim[n].stride;\n+      sextent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (sextent[n] <= 0)\n+        abort ();\n+\n+      if (ssize == sstride[n])\n+        ssize *= sextent[n];\n+      else\n+        ssize = 0;\n+    }\n+\n+  if (pad)\n+    {\n+      pdim = GFC_DESCRIPTOR_RANK (pad);\n+      psize = 1;\n+      for (n = 0; n < pdim; n++)\n+        {\n+          pcount[n] = 0;\n+          pstride[n] = pad->dim[n].stride;\n+          pextent[n] = pad->dim[n].ubound + 1 - pad->dim[n].lbound;\n+          if (pextent[n] <= 0)\n+            abort ();\n+          if (psize == pstride[n])\n+            psize *= pextent[n];\n+          else\n+            psize = 0;\n+        }\n+      pptr = pad->data;\n+    }\n+  else\n+    {\n+      pdim = 0;\n+      psize = 1;\n+      pptr = NULL;\n+    }\n+\n+  if (rsize != 0 && ssize != 0 && psize != 0)\n+    {\n+      rsize *= sizeof (GFC_REAL_8);\n+      ssize *= sizeof (GFC_REAL_8);\n+      psize *= sizeof (GFC_REAL_8);\n+      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n+\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      return;\n+    }\n+  rptr = ret->data;\n+  src = sptr = source->data;\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+\n+  while (rptr)\n+    {\n+      /* Select between the source and pad arrays.  */\n+      *rptr = *src;\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      src += sstride0;\n+      rcount[0]++;\n+      scount[0]++;\n+      /* Advance to the next destination element.  */\n+      n = 0;\n+      while (rcount[n] == rextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          rcount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          rptr -= rstride[n] * rextent[n];\n+          n++;\n+          if (n == rdim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              rcount[n]++;\n+              rptr += rstride[n];\n+            }\n+        }\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (scount[n] == sextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          scount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= sstride[n] * sextent[n];\n+          n++;\n+          if (n == sdim)\n+            {\n+              if (sptr && pad)\n+                {\n+                  /* Switch to the pad array.  */\n+                  sptr = NULL;\n+                  sdim = pdim;\n+                  for (dim = 0; dim < pdim; dim++)\n+                    {\n+                      scount[dim] = pcount[dim];\n+                      sextent[dim] = pextent[dim];\n+                      sstride[dim] = pstride[dim];\n+                      sstride0 = sstride[0];\n+                    }\n+                }\n+              /* We now start again from the beginning of the pad array.  */\n+              src = pptr;\n+              break;\n+            }\n+          else\n+            {\n+              scount[n]++;\n+              src += sstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "f441f371b6d2ddd5e99a0f5f2fbf1c4cdd268bb5", "filename": "libgfortran/generated/transpose_r4.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2Fgenerated%2Ftranspose_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2Fgenerated%2Ftranspose_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_r4.c?ref=ecebfb8be1447048431a3ce0888675412da32678", "patch": "@@ -0,0 +1,99 @@\n+/* Implementation of the TRANSPOSE intrinsic\n+   Copyright 2003, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Tobias Schl\ufffdter\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+extern void transpose_r4 (gfc_array_r4 * const restrict ret, \n+\tgfc_array_r4 * const restrict source);\n+export_proto(transpose_r4);\n+\n+void\n+transpose_r4 (gfc_array_r4 * const restrict ret, \n+\tgfc_array_r4 * const restrict source)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rxstride, rystride;\n+  GFC_REAL_4 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sxstride, systride;\n+  const GFC_REAL_4 *sptr;\n+\n+  index_type xcount, ycount;\n+  index_type x, y;\n+\n+  assert (GFC_DESCRIPTOR_RANK (source) == 2);\n+\n+  if (ret->data == NULL)\n+    {\n+      assert (GFC_DESCRIPTOR_RANK (ret) == 2);\n+      assert (ret->dtype == source->dtype);\n+\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = source->dim[1].ubound - source->dim[1].lbound;\n+      ret->dim[0].stride = 1;\n+\n+      ret->dim[1].lbound = 0;\n+      ret->dim[1].ubound = source->dim[0].ubound - source->dim[0].lbound;\n+      ret->dim[1].stride = ret->dim[0].ubound+1;\n+\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_4) * size0 ((array_t *) ret));\n+      ret->offset = 0;\n+    }\n+\n+  sxstride = source->dim[0].stride;\n+  systride = source->dim[1].stride;\n+  xcount = source->dim[0].ubound + 1 - source->dim[0].lbound;\n+  ycount = source->dim[1].ubound + 1 - source->dim[1].lbound;\n+\n+  rxstride = ret->dim[0].stride;\n+  rystride = ret->dim[1].stride;\n+\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  for (y=0; y < ycount; y++)\n+    {\n+      for (x=0; x < xcount; x++)\n+        {\n+          *rptr = *sptr;\n+\n+          sptr += sxstride;\n+          rptr += rystride;\n+        }\n+        sptr += systride - (sxstride * xcount);\n+        rptr += rxstride - (rystride * xcount);\n+    }\n+}\n+\n+#endif"}, {"sha": "a97206e9c3760c12301a218f459ac32baf196648", "filename": "libgfortran/generated/transpose_r8.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2Fgenerated%2Ftranspose_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecebfb8be1447048431a3ce0888675412da32678/libgfortran%2Fgenerated%2Ftranspose_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_r8.c?ref=ecebfb8be1447048431a3ce0888675412da32678", "patch": "@@ -0,0 +1,99 @@\n+/* Implementation of the TRANSPOSE intrinsic\n+   Copyright 2003, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Tobias Schl\ufffdter\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+extern void transpose_r8 (gfc_array_r8 * const restrict ret, \n+\tgfc_array_r8 * const restrict source);\n+export_proto(transpose_r8);\n+\n+void\n+transpose_r8 (gfc_array_r8 * const restrict ret, \n+\tgfc_array_r8 * const restrict source)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rxstride, rystride;\n+  GFC_REAL_8 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sxstride, systride;\n+  const GFC_REAL_8 *sptr;\n+\n+  index_type xcount, ycount;\n+  index_type x, y;\n+\n+  assert (GFC_DESCRIPTOR_RANK (source) == 2);\n+\n+  if (ret->data == NULL)\n+    {\n+      assert (GFC_DESCRIPTOR_RANK (ret) == 2);\n+      assert (ret->dtype == source->dtype);\n+\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = source->dim[1].ubound - source->dim[1].lbound;\n+      ret->dim[0].stride = 1;\n+\n+      ret->dim[1].lbound = 0;\n+      ret->dim[1].ubound = source->dim[0].ubound - source->dim[0].lbound;\n+      ret->dim[1].stride = ret->dim[0].ubound+1;\n+\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_8) * size0 ((array_t *) ret));\n+      ret->offset = 0;\n+    }\n+\n+  sxstride = source->dim[0].stride;\n+  systride = source->dim[1].stride;\n+  xcount = source->dim[0].ubound + 1 - source->dim[0].lbound;\n+  ycount = source->dim[1].ubound + 1 - source->dim[1].lbound;\n+\n+  rxstride = ret->dim[0].stride;\n+  rystride = ret->dim[1].stride;\n+\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  for (y=0; y < ycount; y++)\n+    {\n+      for (x=0; x < xcount; x++)\n+        {\n+          *rptr = *sptr;\n+\n+          sptr += sxstride;\n+          rptr += rystride;\n+        }\n+        sptr += systride - (sxstride * xcount);\n+        rptr += rxstride - (rystride * xcount);\n+    }\n+}\n+\n+#endif"}]}