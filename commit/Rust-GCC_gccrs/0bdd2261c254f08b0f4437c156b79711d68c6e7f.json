{"sha": "0bdd2261c254f08b0f4437c156b79711d68c6e7f", "node_id": "C_kwDOANBUbNoAKDBiZGQyMjYxYzI1NGYwOGIwZjQ0MzdjMTU2Yjc5NzExZDY4YzZlN2Y", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-12-16T21:53:31Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-12-20T14:15:23Z"}, "message": "Don't use PHI equivalences in range-on-entry.\n\nIf there is only one argument to a PHI which is defined, an equivalency is\ncreated between the def and the argument.  It is safe to consider the def\nequal to the argument, but it is dangerous to assume the argument is also\nequivalent to the def as there may be branches which change the range on the\npath to the PHI on that argument\n\nThis patch avoid using that relation in range-on-entry calculations.\n\n\tPR tree-optimization/108139\n\tgcc/\n\t* gimple-range-cache.cc (ranger_cache::fill_block_cache): Do not\n\tuse equivalences originating from PHIS.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr108139.c: New.", "tree": {"sha": "44d559b9833295b7b2c2eb709e309644a1f82144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44d559b9833295b7b2c2eb709e309644a1f82144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bdd2261c254f08b0f4437c156b79711d68c6e7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bdd2261c254f08b0f4437c156b79711d68c6e7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bdd2261c254f08b0f4437c156b79711d68c6e7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bdd2261c254f08b0f4437c156b79711d68c6e7f/comments", "author": null, "committer": null, "parents": [{"sha": "05b7cf52e1b640271900894a894da2d27ef90092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b7cf52e1b640271900894a894da2d27ef90092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05b7cf52e1b640271900894a894da2d27ef90092"}], "stats": {"total": 25, "additions": 25, "deletions": 0}, "files": [{"sha": "9848d140242f7137325bbb8df06f78e70b31063e", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdd2261c254f08b0f4437c156b79711d68c6e7f/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdd2261c254f08b0f4437c156b79711d68c6e7f/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=0bdd2261c254f08b0f4437c156b79711d68c6e7f", "patch": "@@ -1235,6 +1235,13 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t      if (!m_gori.has_edge_range_p (equiv_name))\n \t\tcontinue;\n \n+\t      // PR 108139. It is hazardous to assume an equivalence with\n+\t      // a PHI is the same value.  The PHI may be an equivalence\n+\t      // via UNDEFINED arguments which is really a one way equivalence.\n+\t      // PHIDEF == name, but name may not be == PHIDEF.\n+\t      if (is_a<gphi *> (SSA_NAME_DEF_STMT (equiv_name)))\n+\t\tcontinue;\n+\n \t      // Check if the equiv definition dominates this block\n \t      if (equiv_bb == bb ||\n \t\t  (equiv_bb && !dominated_by_p (CDI_DOMINATORS, bb, equiv_bb)))"}, {"sha": "6f224e3ce629562c4d144f341c895ad61d910bb7", "filename": "gcc/testsuite/gcc.dg/pr108139.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdd2261c254f08b0f4437c156b79711d68c6e7f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108139.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdd2261c254f08b0f4437c156b79711d68c6e7f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108139.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108139.c?ref=0bdd2261c254f08b0f4437c156b79711d68c6e7f", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O1 -ftree-vrp -fdump-tree-vrp\" } */\n+\n+int a, b;\n+int main() {\n+  int c;\n+  if (a > 1)\n+    a++;\n+  while (a)\n+    if (c == b)\n+      c = a;\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-not \"Folding predicate\" \"vrp2\" } } */\n+\n+"}]}