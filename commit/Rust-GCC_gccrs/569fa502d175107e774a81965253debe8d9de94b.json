{"sha": "569fa502d175107e774a81965253debe8d9de94b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY5ZmE1MDJkMTc1MTA3ZTc3NGE4MTk2NTI1M2RlYmU4ZDlkZTk0Yg==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2003-10-09T09:08:37Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2003-10-09T09:08:37Z"}, "message": "haifa-sched.c (ok_for_early_schedule): New function.\n\n        * haifa-sched.c (ok_for_early_schedule): New function.\n        (early_queue_to_ready): New function.\n        (schedule_block): Allow early removal of insns from Q.\n        (schedule_insn): Update INSN_TICK in case of premature\n        issue.\n        * common.opt (sched_stalled_insns): New flag.\n        (sched_stalled_insns_dep): New flag.\n        * flags.h: Same above flags.\n        * opts.c: Same as above.\n        * toplev.c: Same as above.\n        * target.h (targetm.sched.is_costly_dependence): New\n        hook.\n        * target-def.h: Same as above.\n        * config/rs6000/rs6000.h: (rs6000_sched_costly_dep):\n        Support new flag -msched-costly-dep.\n        (DEFAULT_SCHED_COSTLY_DEP): Define.\n        * config/rs6000/rs6000.c:\n        (rs6000_is_costly_dependence): New function.\n        (is_load_insn, is_store_insn): New functions.\n        (is_load_insn1, is_store_insn1, is_mem_ref): New\n        functions.\n        * doc/invoke.texi (-fsched-stalled-insns-dep)\n        (-fsched-stalled-insns, -msched-costly-dep): Document\n        options.\n        * doc/tm.texi (is_costly_dependence): Define new\n        scheduler target hook.\n\nFrom-SVN: r72261", "tree": {"sha": "cf4b5b0d6fa071cfa3bd81035f628ab846f4673e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf4b5b0d6fa071cfa3bd81035f628ab846f4673e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/569fa502d175107e774a81965253debe8d9de94b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/569fa502d175107e774a81965253debe8d9de94b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/569fa502d175107e774a81965253debe8d9de94b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/569fa502d175107e774a81965253debe8d9de94b/comments", "author": null, "committer": null, "parents": [{"sha": "2df6848e22f1ea6fd8a43284a85986337de4a425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df6848e22f1ea6fd8a43284a85986337de4a425", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df6848e22f1ea6fd8a43284a85986337de4a425"}], "stats": {"total": 517, "additions": 514, "deletions": 3}, "files": [{"sha": "bfbdbcf9387da4358258fa649e68af76f7cfcd32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -1,3 +1,32 @@\n+2003-10-09  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* haifa-sched.c (ok_for_early_schedule): New function.\n+\t(early_queue_to_ready): New function. \n+\t(schedule_block): Allow early removal of insns from Q.\n+\t(schedule_insn): Update INSN_TICK in case of premature\n+\tissue.\n+\t* common.opt (sched_stalled_insns): New flag.\n+\t(sched_stalled_insns_dep): New flag.\n+\t* flags.h: Same above flags.\n+\t* opts.c: Same as above.\n+\t* toplev.c: Same as above.\n+\t* target.h (targetm.sched.is_costly_dependence): New\n+\thook.\n+\t* target-def.h: Same as above.\n+\t* config/rs6000/rs6000.h: (rs6000_sched_costly_dep):\n+\tSupport new flag -msched-costly-dep.\n+\t(DEFAULT_SCHED_COSTLY_DEP): Define.\n+\t* config/rs6000/rs6000.c: \t\n+\t(rs6000_is_costly_dependence): New function.\n+\t(is_load_insn, is_store_insn): New functions.\n+\t(is_load_insn1, is_store_insn1, is_mem_ref): New \n+\tfunctions.\n+\t* doc/invoke.texi (-fsched-stalled-insns-dep)\n+\t(-fsched-stalled-insns, -msched-costly-dep): Document\n+\toptions.\n+\t* doc/tm.texi (is_costly_dependence): Define new \n+\tscheduler target hook.\n+\n 2003-10-09  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/6392"}, {"sha": "ab1a69dcf4b24bfd789e3bdb9d457026a3bc31d4", "filename": "gcc/common.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -592,6 +592,22 @@ fschedule-insns2\n Common\n Reschedule instructions after register allocation\n \n+fsched-stalled-insns\n+Common\n+Allow premature scheduling of queued insns\n+\n+fsched-stalled-insns=\n+Common RejectNegative Joined UInteger \n+-fsched-stalled-insns=<number>       Set number of queued insns that can be prematurely scheduled\n+\n+fsched-stalled-insns-dep\n+Common\n+Set dependence distance checking in premature scheduling of queued insns\n+\n+fsched-stalled-insns-dep=\n+Common RejectNegative Joined UInteger\n+-fsched-stalled-insns-dep=<number>   Set dependence distance checking in premature scheduling of queued insns\n+\n fshared-data\n Common\n Mark data as shared rather than private"}, {"sha": "669f6ac6f19adb7bc83877f6b9b6168965d75164", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -86,6 +86,10 @@ struct rs6000_cpu_select rs6000_select[3] =\n const char *rs6000_sched_restricted_insns_priority_str;\n int rs6000_sched_restricted_insns_priority;\n \n+/* Support for -msched-costly-dep option.  */\n+const char *rs6000_sched_costly_dep_str;\n+enum rs6000_dependence_cost rs6000_sched_costly_dep;\n+\n /* Size of long double */\n const char *rs6000_long_double_size_string;\n int rs6000_long_double_type_size;\n@@ -278,6 +282,7 @@ static int rs6000_adjust_cost (rtx, rtx, rtx, int);\n static int is_dispatch_slot_restricted (rtx);\n static int rs6000_adjust_priority (rtx, int);\n static int rs6000_issue_rate (void);\n+static bool rs6000_is_costly_dependence (rtx, rtx, rtx, int, int);\n static int rs6000_use_sched_lookahead (void);\n \n static void rs6000_init_builtins (void);\n@@ -469,6 +474,8 @@ static const char alt_reg_names[][8] =\n #define TARGET_SCHED_ADJUST_COST rs6000_adjust_cost\n #undef TARGET_SCHED_ADJUST_PRIORITY\n #define TARGET_SCHED_ADJUST_PRIORITY rs6000_adjust_priority\n+#undef TARGET_SCHED_IS_COSTLY_DEPENDENCE      \n+#define TARGET_SCHED_IS_COSTLY_DEPENDENCE rs6000_is_costly_dependence\n \n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD rs6000_use_sched_lookahead\n@@ -864,6 +871,21 @@ rs6000_override_options (const char *default_cpu)\n     rs6000_sched_restricted_insns_priority =\n       atoi (rs6000_sched_restricted_insns_priority_str);\n \n+  /* Handle -msched-costly-dep option.  */\n+  rs6000_sched_costly_dep = DEFAULT_SCHED_COSTLY_DEP;\n+  if (rs6000_sched_costly_dep_str)\n+    {\n+      if (! strcmp (rs6000_sched_costly_dep_str, \"no\"))  \n+        rs6000_sched_costly_dep = no_dep_costly;\n+      else if (! strcmp (rs6000_sched_costly_dep_str, \"all\"))\n+        rs6000_sched_costly_dep = all_deps_costly;\n+      else if (! strcmp (rs6000_sched_costly_dep_str, \"true_store_to_load\"))\n+        rs6000_sched_costly_dep = true_store_to_load_dep_costly;\n+      else if (! strcmp (rs6000_sched_costly_dep_str, \"store_to_load\"))\n+        rs6000_sched_costly_dep = store_to_load_dep_costly;\n+      else rs6000_sched_costly_dep = atoi (rs6000_sched_costly_dep_str);\n+    }\n+\n #ifdef TARGET_REGNAMES\n   /* If the user desires alternate register names, copy in the\n      alternate names now.  */\n@@ -13383,6 +13405,145 @@ rs6000_use_sched_lookahead (void)\n   return 0;\n }\n \n+/* Determine is PAT refers to memory.  */\n+\n+static bool\n+is_mem_ref (rtx pat)\n+{\n+  const char * fmt;\n+  int i, j;\n+  bool ret = false;\n+\n+  if (GET_CODE (pat) == MEM)\n+    return true;\n+\n+  /* Recursively process the pattern.  */\n+  fmt = GET_RTX_FORMAT (GET_CODE (pat));\n+\n+  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0 && !ret; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tret |= is_mem_ref (XEXP (pat, i));\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n+\t  ret |= is_mem_ref (XVECEXP (pat, i, j));\n+    }\n+\n+  return ret;\n+}\n+\n+/* Determine if PAT is a PATTERN of a load insn.  */\n+ \n+static bool\n+is_load_insn1 (rtx pat)\n+{\n+  if (!pat || pat == NULL_RTX)\n+    return false;\n+\n+  if (GET_CODE (pat) == SET)\n+    return is_mem_ref (SET_SRC (pat));\n+\n+  if (GET_CODE (pat) == PARALLEL)\n+    {\n+      int i;\n+\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\tif (is_load_insn1 (XVECEXP (pat, 0, i)))\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Determine if INSN loads from memory.  */\n+\n+static bool\n+is_load_insn (rtx insn)\n+{\n+  if (!insn || !INSN_P (insn))\n+    return false;\n+\n+  if (GET_CODE (insn) == CALL_INSN)\n+    return false;\n+\n+  return is_load_insn1 (PATTERN (insn));\n+}\n+\n+/* Determine if PAT is a PATTERN of a store insn.  */\n+\n+static bool\n+is_store_insn1 (rtx pat)\n+{\n+  if (!pat || pat == NULL_RTX)\n+    return false;\n+\n+  if (GET_CODE (pat) == SET)\n+    return is_mem_ref (SET_DEST (pat));\n+\n+  if (GET_CODE (pat) == PARALLEL)\n+    {\n+      int i;\n+\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\tif (is_store_insn1 (XVECEXP (pat, 0, i)))\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Determine if INSN stores to memory.  */\n+\n+static bool\n+is_store_insn (rtx insn)\n+{\n+  if (!insn || !INSN_P (insn))\n+    return false;\n+\n+  return is_store_insn1 (PATTERN (insn));\n+}\n+\n+/* Returns whether the dependence between INSN and NEXT is considered\n+   costly by the given target.  */\n+\n+static bool\n+rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost, int distance)\n+{      \n+  /* If the flag is not enbled - no dependence is considered costly;\n+     allow all dependent insns in the same group. \n+     This is the most aggressive option.  */\n+  if (rs6000_sched_costly_dep == no_dep_costly)\n+    return false;\n+\n+  /* If the flag is set to 1 - a dependence is always considered costly; \n+     do not allow dependent instructions in the same group.\n+     This is the most conservative option.  */\n+  if (rs6000_sched_costly_dep == all_deps_costly)\n+    return true;       \n+\n+  if (rs6000_sched_costly_dep == store_to_load_dep_costly \n+      && is_load_insn (next) \n+      && is_store_insn (insn))\n+    /* Prevent load after store in the same group.  */\n+    return true;\n+\n+  if (rs6000_sched_costly_dep == true_store_to_load_dep_costly\n+      && is_load_insn (next) \n+      && is_store_insn (insn)\n+      && (!link || (int) REG_NOTE_KIND (link) == 0))\n+     /* Prevent load after store in the same group if it is a true dependence.  */\n+     return true;\n+    \n+  /* The flag is set to X; dependences with latency >= X are considered costly, \n+     and will not be scheduled in the same group.  */\n+  if (rs6000_sched_costly_dep <= max_dep_latency\n+      && ((cost - distance) >= (int)rs6000_sched_costly_dep))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n \f\n /* Length in units of the trampoline for entering a nested function.  */\n "}, {"sha": "fbdb6a5c06bd355f816c21c364cc0a97552bacbb", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -376,6 +376,16 @@ extern enum processor_type rs6000_cpu;\n    and the old mnemonics are dialect zero.  */\n #define ASSEMBLER_DIALECT (TARGET_NEW_MNEMONICS ? 1 : 0)\n \n+/* Types of costly dependences.  */\n+enum rs6000_dependence_cost\n+ {\n+   max_dep_latency = 1000,\n+   no_dep_costly,\n+   all_deps_costly,\n+   true_store_to_load_dep_costly,\n+   store_to_load_dep_costly\n+ };\n+\n /* This is meant to be overridden in target specific files.  */\n #define\tSUBTARGET_OPTIONS\n \n@@ -402,6 +412,8 @@ extern enum processor_type rs6000_cpu;\n    {\"longcall\", &rs6000_longcall_switch,\t\t\t\t\\\n     N_(\"Avoid all range limits on call instructions\"), 0},\t\t\\\n    {\"no-longcall\", &rs6000_longcall_switch, \"\", 0},\t\t\t\\\n+   {\"sched-costly-dep=\", &rs6000_sched_costly_dep_str,                  \\\n+    N_(\"determine which dependences between insns are considered costly\"), 0}, \\\n    {\"align-\", &rs6000_alignment_string,\t\t\t\t\t\\\n     N_(\"Specify alignment of structure fields default/natural\"), 0},\t\\\n    {\"prioritize-restricted-insns=\", &rs6000_sched_restricted_insns_priority_str, \\\n@@ -461,6 +473,8 @@ extern const char* rs6000_alignment_string;\n extern int rs6000_alignment_flags;\n extern const char *rs6000_sched_restricted_insns_priority_str;\n extern int rs6000_sched_restricted_insns_priority;\n+extern const char *rs6000_sched_costly_dep_str;\n+extern enum rs6000_dependence_cost rs6000_sched_costly_dep;\n \n /* Alignment options for fields in structures for sub-targets following\n    AIX-like ABI.\n@@ -479,6 +493,11 @@ extern int rs6000_sched_restricted_insns_priority;\n #define TARGET_ALIGN_NATURAL 0\n #endif\n \n+/* Set a default value for DEFAULT_SCHED_COSTLY_DEP used by target hook\n+   is_costly_dependence.  */ \n+#define DEFAULT_SCHED_COSTLY_DEP                           \\\n+  (rs6000_cpu == PROCESSOR_POWER4 ? store_to_load_dep_costly : no_dep_costly)\n+\n /* Define if the target has restricted dispatch slot instructions.  */\n #define DEFAULT_RESTRICTED_INSNS_PRIORITY (rs6000_cpu == PROCESSOR_POWER4 ? 1 : 0)\n "}, {"sha": "20ef67f7586dc21fb9eef16366a6fef76b23cd09", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -287,7 +287,9 @@ in the following sections.\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n -frounding-math -fschedule-insns  -fschedule-insns2 @gol\n -fno-sched-interblock  -fno-sched-spec  -fsched-spec-load @gol\n--fsched-spec-load-dangerous  -fsched2-use-superblocks @gol\n+-fsched-spec-load-dangerous  @gol\n+-fsched-stalled-insns=@var{n} -sched-stalled-insns-dep=@var{n} @gol\n+-fsched2-use-superblocks @gol\n -fsched2-use-traces  -fsignaling-nans @gol\n -fsingle-precision-constant  -fssa  -fssa-ccp  -fssa-dce @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n@@ -432,6 +434,7 @@ in the following sections.\n -mtoc  -mno-toc  -mlittle  -mlittle-endian  -mbig  -mbig-endian @gol\n -mdynamic-no-pic @gol\n -mprioritize-restricted-insns=@var{priority} @gol\n+-msched-costly-dep=@var{dependence_type} @gol\n -mcall-sysv  -mcall-netbsd @gol\n -maix-struct-return  -msvr4-struct-return @gol\n -mabi=altivec  -mabi=no-altivec @gol\n@@ -4115,6 +4118,18 @@ Allow speculative motion of more load instructions.  This only makes\n sense when scheduling before register allocation, i.e.@: with\n @option{-fschedule-insns} or at @option{-O2} or higher.\n \n+@item -fsched-stalled-insns=@var{n}\n+@opindex fsched-stalled-insns\n+Define how many insns (if any) can be moved prematurely from the queue\n+of stalled insns into the ready list, during the second scheduling pass.\n+\n+@item -fsched-stalled-insns-dep=@var{n}\n+@opindex fsched-stalled-insns-dep\n+Define how many insn groups (cycles) will be examined for a dependency \n+on a stalled insn that is candidate for premature removal from the queue \n+of stalled insns.  Has an effect only during the second scheduling pass, \n+and only if @option{-fsched-stalled-insns} is used and its value is not zero.\n+\n @item -fsched2-use-superblocks\n @opindex fsched2-use-superblocks\n When scheduling after register allocation, do use superblock scheduling\n@@ -7535,6 +7550,17 @@ pass.  The argument @var{priority} takes the value @var{0/1/2} to assign\n @var{no/highest/second-highest} priority to dispatch slot restricted \n instructions.\n \n+@item -msched-costly-dep=@var{dependence_type}\n+@opindex msched-costly-dep\n+This option controls which dependences are considered costly\n+by the target during instruction scheduling.  The argument\n+@var{dependence_type} takes one of the following values:\n+@var{no}: no dependence is costly, \n+@var{all}: all dependences are costly, \n+@var{true_store_to_load}: a true dependence from store to load is costly,\n+@var{store_to_load}: any dependence from store to load is costly,\n+@var{number}: any dependence which latency >= @var{number} is costly.\n+ \n @item -mcall-sysv\n @opindex mcall-sysv\n On System V.4 and embedded PowerPC systems compile code using calling"}, {"sha": "1645319dff0f707b74785d368033129bed97b887", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -5668,6 +5668,28 @@ zero.  The hook should return @code{NULL} if there are no more nop\n insns with indexes greater than given index.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool IS_COSTLY_DEPENDENCE (rtx @var{insn1}, rtx @var{insn2}, rtx @var{dep_link}, int @var{dep_cost}, int @var{distance})\n+This hook is used to define which dependences are considered costly by\n+the target, so costly that it is not advisable to schedule the insns that \n+are involved in the dependence too close to one another.  The parameters\n+to this hook are as follows:  The second parameter @var{insn2} is dependent \n+upon the first parameter @var{insn1}.  The dependence between @var{insn1} \n+and @var{insn2} is represented by the third parameter @var{dep_link}.  The \n+fourth parameter @var{cost} is the cost of the dependence, and the fifth \n+parameter @var{distance} is the distance in cycles between the two insns. \n+The hook returns @code{true} if considering the distance between the two\n+insns the dependence between them is considered costly by the target,\n+and @code{false} otherwise.\n+\n+Defining this hook can be useful in multiple-issue out-of-order machines,\n+where (a) it's practically hopeless to predict the actual data/resource \n+delays, however: (b) there's a better chance to predict the actual grouping\n+that will be formed, and (c) correctly emulating the grouping can be very \n+important.  In such targets one may want to allow issuing dependent insns\n+closer to one another - i.e, closer than the dependence distance;  however, \n+not in cases of \"costly dependences\", which this hooks allows to define.\n+@end deftypefn\n+\n Macros in the following table are generated by the program\n @file{genattr} and can be useful for writing the hooks.\n "}, {"sha": "f345b49719745af9866db639996780466d897368", "filename": "gcc/flags.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -439,6 +439,20 @@ extern int flag_schedule_speculative;\n extern int flag_schedule_speculative_load;\n extern int flag_schedule_speculative_load_dangerous;\n \n+/* The following flags have an effect during scheduling after register\n+   allocation:   \n+\n+   sched_stalled_insns means that insns can be moved prematurely from the queue\n+   of stalled insns into the ready list.\n+\n+   sched_stalled_insns_dep controls how many recently scheduled cycles will \n+   be examined for a dependency on a stalled insn that is candidate for\n+   premature removal from the queue of stalled insns into the ready list (has \n+   an effect only if the flag 'sched_stalled_insns' is set).  */\n+\n+extern int flag_sched_stalled_insns;\n+extern int flag_sched_stalled_insns_dep;\n+\n /* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple\n    by a cheaper branch, on a count register.  */\n extern int flag_branch_on_count_reg;"}, {"sha": "40a0a76b3f88c1b4550c05796a83540a84eb7839", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 177, "deletions": 1, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -517,6 +517,7 @@ static void ready_sort (struct ready_list *);\n static rtx ready_remove_first (struct ready_list *);\n \n static void queue_to_ready (struct ready_list *);\n+static int early_queue_to_ready (state_t, struct ready_list *);\n \n static void debug_ready_list (struct ready_list *);\n \n@@ -1247,6 +1248,7 @@ schedule_insn (rtx insn, struct ready_list *ready, int clock)\n   rtx link;\n   int advance = 0;\n   int unit = 0;\n+  int premature_issue = 0;\n \n   if (!targetm.sched.use_dfa_pipeline_interface\n       || !(*targetm.sched.use_dfa_pipeline_interface) ())\n@@ -1290,12 +1292,19 @@ schedule_insn (rtx insn, struct ready_list *ready, int clock)\n \treturn 0;\n     }\n \n+  if (INSN_TICK (insn) > clock)\n+    {\n+      /* 'insn' has been prematurely moved from the queue to the\n+\t ready list.  */\n+      premature_issue = INSN_TICK (insn) - clock;\n+    }\n+\n   for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n     {\n       rtx next = XEXP (link, 0);\n       int cost = insn_cost (insn, link, next);\n \n-      INSN_TICK (next) = MAX (INSN_TICK (next), clock + cost);\n+      INSN_TICK (next) = MAX (INSN_TICK (next), clock + cost + premature_issue);\n \n       if ((INSN_DEP_COUNT (next) -= 1) == 0)\n \t{\n@@ -1809,6 +1818,159 @@ queue_to_ready (struct ready_list *ready)\n     }\n }\n \n+/* Used by early_queue_to_ready.  Determines whether it is \"ok\" to\n+   prematurely move INSN from the queue to the ready list.  Currently, \n+   if a target defines the hook 'is_costly_dependence', this function \n+   uses the hook to check whether there exist any dependences which are\n+   considered costly by the target, between INSN and other insns that \n+   have already been scheduled.  Dependences are checked up to Y cycles\n+   back, with default Y=1; The flag -fsched-stalled-insns-dep=Y allows\n+   controlling this value. \n+   (Other considerations could be taken into account instead (or in \n+   addition) depending on user flags and target hooks.  */\n+\n+static bool \n+ok_for_early_queue_removal (rtx insn)\n+{\n+  int n_cycles;\n+  rtx prev_insn = last_scheduled_insn;\n+\n+  if (targetm.sched.is_costly_dependence)\n+    {\n+      for (n_cycles = flag_sched_stalled_insns_dep; n_cycles; n_cycles--)\n+\t{\n+\t  for ( ; prev_insn; prev_insn = PREV_INSN (prev_insn))\n+\t    {\n+\t      rtx dep_link = 0;\n+\t      int dep_cost;\n+\n+\t      if (GET_CODE (prev_insn) != NOTE)\n+\t\t{\n+\t\t  dep_link = find_insn_list (insn, INSN_DEPEND (prev_insn));\n+\t\t  if (dep_link)\n+\t\t    {\n+\t\t      dep_cost = insn_cost (prev_insn, dep_link, insn) ;\n+\t\t      if (targetm.sched.is_costly_dependence (prev_insn, insn, \n+\t\t\t\tdep_link, dep_cost, \n+\t\t\t\tflag_sched_stalled_insns_dep - n_cycles))\n+\t\t\treturn false;\n+\t\t    }\n+\t\t}\n+\n+\t      if (GET_MODE (prev_insn) == TImode) /* end of dispatch group */\n+\t\tbreak;\n+\t    }\n+\n+\t  if (!prev_insn) \n+\t    break;\n+\t  prev_insn = PREV_INSN (prev_insn);     \n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Remove insns from the queue, before they become \"ready\" with respect\n+   to FU latency considerations.   */\n+\n+static int \n+early_queue_to_ready (state_t state, struct ready_list *ready)\n+{\n+  rtx insn;\n+  rtx link;\n+  rtx next_link;\n+  rtx prev_link;\n+  bool move_to_ready;\n+  int cost;\n+  state_t temp_state = alloca (dfa_state_size);\n+  int stalls;\n+  int insns_removed = 0;\n+\n+  /*\n+     Flag '-fsched-stalled-insns=X' determines the aggressiveness of this \n+     function: \n+\n+     X == 0: There is no limit on how many queued insns can be removed          \n+             prematurely.  (flag_sched_stalled_insns = -1).\n+\n+     X >= 1: Only X queued insns can be removed prematurely in each \n+\t     invocation.  (flag_sched_stalled_insns = X).\n+\n+     Otherwise: Early queue removal is disabled.\n+         (flag_sched_stalled_insns = 0)\n+  */\n+\n+  if (! flag_sched_stalled_insns)   \n+    return 0;\n+\n+  for (stalls = 0; stalls <= MAX_INSN_QUEUE_INDEX; stalls++)\n+    {\n+      if ((link = insn_queue[NEXT_Q_AFTER (q_ptr, stalls)]))\n+\t{\n+\t  if (sched_verbose > 6)\n+\t    fprintf (sched_dump, \";; look at index %d + %d\\n\", q_ptr, stalls);\n+\n+\t  prev_link = 0;\n+\t  while (link)\n+\t    {\n+\t      next_link = XEXP (link, 1);\n+\t      insn = XEXP (link, 0);\n+\t      if (insn && sched_verbose > 6)\n+\t\tprint_rtl_single (sched_dump, insn);\n+\n+\t      memcpy (temp_state, state, dfa_state_size);\n+\t      if (recog_memoized (insn) < 0) \n+\t\t/* non-negative to indicate that it's not ready\n+\t\t   to avoid infinite Q->R->Q->R... */\n+\t\tcost = 0;\n+\t      else\n+\t\tcost = state_transition (temp_state, insn);\n+\n+\t      if (sched_verbose >= 6)\n+\t\tfprintf (sched_dump, \"transition cost = %d\\n\", cost);\n+\n+\t      move_to_ready = false;\n+\t      if (cost < 0) \n+\t\t{\n+\t\t  move_to_ready = ok_for_early_queue_removal (insn);\n+\t\t  if (move_to_ready == true)\n+\t\t    {\n+\t\t      /* move from Q to R */\n+\t\t      q_size -= 1;\n+\t\t      ready_add (ready, insn);\n+\n+\t\t      if (prev_link)   \n+\t\t\tXEXP (prev_link, 1) = next_link;\n+\t\t      else\n+\t\t\tinsn_queue[NEXT_Q_AFTER (q_ptr, stalls)] = next_link;\n+\n+\t\t      free_INSN_LIST_node (link);\n+\n+\t\t      if (sched_verbose >= 2)\n+\t\t\tfprintf (sched_dump, \";;\\t\\tEarly Q-->Ready: insn %s\\n\",\n+\t\t\t\t (*current_sched_info->print_insn) (insn, 0));\n+\n+\t\t      insns_removed++;\n+\t\t      if (insns_removed == flag_sched_stalled_insns)\n+\t\t\t/* remove only one insn from Q at a time */\n+\t\t\treturn insns_removed;\n+\t\t    }\n+\t\t}\n+\n+\t      if (move_to_ready == false)\n+\t\tprev_link = link;\n+\n+\t      link = next_link;\n+\t    } /* while link */\n+\t} /* if link */    \n+\n+    } /* for stalls.. */\n+\n+  return insns_removed; \n+}\n+\n+\n /* Print the ready list for debugging purposes.  Callable from debugger.  */\n \n static void\n@@ -2251,6 +2413,20 @@ schedule_block (int b, int rgn_n_insns)\n \t    }\n \t  else\n \t    {\n+\t      if (ready.n_ready == 0 \n+\t\t  && can_issue_more \n+\t\t  && reload_completed) \n+\t\t{\n+\t\t  /* Allow scheduling insns directly from the queue in case\n+\t\t     there's nothing better to do (ready list is empty) but\n+\t\t     there are still vacant dispatch slots in the current cycle.  */\n+\t\t  if (sched_verbose >= 6)\n+\t\t    fprintf(sched_dump,\";;\\t\\tSecond chance\\n\");\n+\t\t  memcpy (temp_state, curr_state, dfa_state_size);\n+\t\t  if (early_queue_to_ready (temp_state, &ready))\n+\t\t    ready_sort (&ready);\n+\t\t}\n+\n \t      if (ready.n_ready == 0 || !can_issue_more\n \t\t  || state_dead_lock_p (curr_state)\n \t\t  || !(*current_sched_info->schedule_more_p) ())"}, {"sha": "dc489e19b31bdc76b03db9fd2e2999cfca2e4a05", "filename": "gcc/opts.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -1264,6 +1264,24 @@ common_handle_option (size_t scode, const char *arg,\n       flag_schedule_insns_after_reload = value;\n       break;\n \n+    case OPT_fsched_stalled_insns:\n+      flag_sched_stalled_insns = value;\n+      break;\n+\n+    case OPT_fsched_stalled_insns_:\n+      flag_sched_stalled_insns = value;\n+      if (flag_sched_stalled_insns == 0)\n+\tflag_sched_stalled_insns = -1;\n+      break;\n+\n+    case OPT_fsched_stalled_insns_dep:\n+      flag_sched_stalled_insns_dep = 1;\n+      break;\n+\n+    case OPT_fsched_stalled_insns_dep_:\n+      flag_sched_stalled_insns_dep = value;\n+      break;\n+\n     case OPT_fshared_data:\n       flag_shared_data = value;\n       break;"}, {"sha": "3f35e2e90d80dc661ce4a3a7d9b6edbea1d410e9", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -230,6 +230,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SCHED_DFA_NEW_CYCLE 0\n #define TARGET_SCHED_INIT_DFA_BUBBLES 0\n #define TARGET_SCHED_DFA_BUBBLE 0\n+#define TARGET_SCHED_IS_COSTLY_DEPENDENCE 0\n \n #define TARGET_SCHED\t\t\t\t\t\t\\\n   {TARGET_SCHED_ADJUST_COST,\t\t\t\t\t\\\n@@ -250,7 +251,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD,\t\\\n    TARGET_SCHED_DFA_NEW_CYCLE,\t\t\t\t\t\\\n    TARGET_SCHED_INIT_DFA_BUBBLES,\t\t\t\t\\\n-   TARGET_SCHED_DFA_BUBBLE}\n+   TARGET_SCHED_DFA_BUBBLE,                                     \\\n+   TARGET_SCHED_IS_COSTLY_DEPENDENCE}\n \n /* In tree.c.  */\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes"}, {"sha": "8d77dfde2d058685e3121764643a414ed34f7aba", "filename": "gcc/target.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -251,6 +251,18 @@ struct gcc_target\n        scheduling.  */\n     void (* init_dfa_bubbles) (void);\n     rtx (* dfa_bubble) (int);\n+    /* The following member value is a pointer to a function called\n+       by the insn scheduler.  It should return true if there exists a\n+       dependence which is considered costly by the target, between \n+       the insn passed as the first parameter, and the insn passed as \n+       the second parameter.  The third parameter is the INSN_DEPEND \n+       link that represents the dependence between the two insns.  The\n+       fourth argument is the cost of the dependence as estimated by\n+       the scheduler.  The last argument is the distance in cycles \n+       between the already scheduled insn (first parameter) and the\n+       the second insn (second parameter).\n+    */\n+    bool (* is_costly_dependence) PARAMS ((rtx, rtx, rtx, int, int));\n   } sched;\n \n   /* Given two decls, merge their attributes and return the result.  */"}, {"sha": "bc96c649879b89d5de23e0e78a62c58aa596258a", "filename": "gcc/toplev.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/569fa502d175107e774a81965253debe8d9de94b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/569fa502d175107e774a81965253debe8d9de94b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=569fa502d175107e774a81965253debe8d9de94b", "patch": "@@ -826,6 +826,20 @@ int flag_schedule_speculative = 1;\n int flag_schedule_speculative_load = 0;\n int flag_schedule_speculative_load_dangerous = 0;\n \n+/* The following flags have an effect during scheduling after register\n+   allocation:\n+\n+   flag_sched_stalled_insns means that insns can be moved prematurely from the queue\n+   of stalled insns into the ready list.\n+  \n+   flag_sched_stalled_insns_dep controls how many insn groups will be examined\n+   for a dependency on a stalled insn that is candidate for premature removal\n+   from the queue of stalled insns into the ready list (has an effect only if\n+   the flag 'sched_stalled_insns' is set).  */ \n+\n+int flag_sched_stalled_insns = 0;\n+int flag_sched_stalled_insns_dep = 1;\n+\n int flag_single_precision_constant;\n \n /* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple\n@@ -1069,6 +1083,8 @@ static const lang_independent_options f_options[] =\n   {\"sched-spec\",&flag_schedule_speculative, 1 },\n   {\"sched-spec-load\",&flag_schedule_speculative_load, 1 },\n   {\"sched-spec-load-dangerous\",&flag_schedule_speculative_load_dangerous, 1 },\n+  {\"sched-stalled-insns\", &flag_sched_stalled_insns, 0 },\n+  {\"sched-stalled-insns-dep\", &flag_sched_stalled_insns_dep, 1 },\n   {\"sched2-use-superblocks\", &flag_sched2_use_superblocks, 1 },\n   {\"sched2-use-traces\", &flag_sched2_use_traces, 1 },\n   {\"branch-count-reg\",&flag_branch_on_count_reg, 1 },"}]}