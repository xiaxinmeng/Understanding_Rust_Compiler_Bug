{"sha": "88ee26514d0e02c39cd37fa568fdfbad6724c57f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhlZTI2NTE0ZDBlMDJjMzljZDM3ZmE1NjhmZGZiYWQ2NzI0YzU3Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-13T10:07:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-13T10:07:59Z"}, "message": "(div_and_round_double): Don't mix HOST_WIDE_INT * and unsigned\nHOST_WIDE_INT * parameters; some compilers complain.\n\nFrom-SVN: r4114", "tree": {"sha": "535439f744a823755e22ea731bca51829372f1a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/535439f744a823755e22ea731bca51829372f1a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88ee26514d0e02c39cd37fa568fdfbad6724c57f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ee26514d0e02c39cd37fa568fdfbad6724c57f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ee26514d0e02c39cd37fa568fdfbad6724c57f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ee26514d0e02c39cd37fa568fdfbad6724c57f/comments", "author": null, "committer": null, "parents": [{"sha": "36be30f1bc093381c0a51d718c2b1ca1a668a9b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36be30f1bc093381c0a51d718c2b1ca1a668a9b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36be30f1bc093381c0a51d718c2b1ca1a668a9b2"}], "stats": {"total": 13, "additions": 7, "deletions": 6}, "files": [{"sha": "02d40275a7009db88042cdfd0b1d7d9c3d61eebb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ee26514d0e02c39cd37fa568fdfbad6724c57f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ee26514d0e02c39cd37fa568fdfbad6724c57f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=88ee26514d0e02c39cd37fa568fdfbad6724c57f", "patch": "@@ -512,9 +512,9 @@ div_and_round_double (code, uns,\n   short den[MAX_SHORTS], quo[MAX_SHORTS];\n   register int i, j, work;\n   register int carry = 0;\n-  unsigned HOST_WIDE_INT lnum = lnum_orig;\n+  HOST_WIDE_INT lnum = lnum_orig;\n   HOST_WIDE_INT hnum = hnum_orig;\n-  unsigned HOST_WIDE_INT lden = lden_orig;\n+  HOST_WIDE_INT lden = lden_orig;\n   HOST_WIDE_INT hden = hden_orig;\n   int overflow = 0;\n \n@@ -541,7 +541,8 @@ div_and_round_double (code, uns,\n   if (hnum == 0 && hden == 0)\n     {\t\t\t\t/* single precision */\n       *hquo = *hrem = 0;\n-      *lquo = lnum / lden;\t/* rounds toward zero since positive args */\n+      /* This unsigned division rounds toward zero.  */\n+      *lquo = lnum / (unsigned HOST_WIDE_INT) lden;\n       goto finish_up;\n     }\n \n@@ -566,14 +567,14 @@ div_and_round_double (code, uns,\n      We also have to require that we don't need more than three bytes\n      to hold CARRY.  If we ever did need four bytes to hold it, we\n      would lose part of it when computing WORK on the next round.  */\n-  if (hden == 0 && ((lden << 8) >> 8) == lden)\n+  if (hden == 0 && (((unsigned HOST_WIDE_INT) lden << 8) >> 8) == lden)\n     {\t\t\t\t/* simpler algorithm */\n       /* hnum != 0 already checked.  */\n       for (i = MAX_SHORTS - 1; i >= 0; i--)\n \t{\n \t  work = num[i] + (carry << 8);\n-\t  quo[i] = work / lden;\n-\t  carry = work % lden;\n+\t  quo[i] = work / (unsigned HOST_WIDE_INT) lden;\n+\t  carry = work % (unsigned HOST_WIDE_INT) lden;\n \t}\n     }\n   else {\t\t\t/* full double precision,"}]}