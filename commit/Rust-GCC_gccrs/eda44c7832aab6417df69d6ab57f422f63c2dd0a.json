{"sha": "eda44c7832aab6417df69d6ab57f422f63c2dd0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRhNDRjNzgzMmFhYjY0MTdkZjY5ZDZhYjU3ZjQyMmY2M2MyZGQwYQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "2000-01-19T20:00:09Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2000-01-19T20:00:09Z"}, "message": "sh.c (prepare_scc_operands): Abort if no compare insn is available.\n\n\t* sh.c (prepare_scc_operands): Abort if no compare insn is available.\n\t(find_barrier, gen_block_redirect, split_branches): Fix indentation.\n\t(calc_live_regs): Likewise.\n\nFrom-SVN: r31507", "tree": {"sha": "7bbad82cf92a6d2363ebd4d5e0035ff61a67da3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bbad82cf92a6d2363ebd4d5e0035ff61a67da3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eda44c7832aab6417df69d6ab57f422f63c2dd0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eda44c7832aab6417df69d6ab57f422f63c2dd0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eda44c7832aab6417df69d6ab57f422f63c2dd0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eda44c7832aab6417df69d6ab57f422f63c2dd0a/comments", "author": null, "committer": null, "parents": [{"sha": "d64264ff53ee4b28550c5cdec50d3949786817a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64264ff53ee4b28550c5cdec50d3949786817a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d64264ff53ee4b28550c5cdec50d3949786817a8"}], "stats": {"total": 110, "additions": 58, "deletions": 52}, "files": [{"sha": "3ccbe76d42af5c5f4ab1ea89d93037c1a59de58f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eda44c7832aab6417df69d6ab57f422f63c2dd0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eda44c7832aab6417df69d6ab57f422f63c2dd0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eda44c7832aab6417df69d6ab57f422f63c2dd0a", "patch": "@@ -1,3 +1,9 @@\n+Wed Jan 19 19:54:38 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* sh.c (prepare_scc_operands): Abort if no compare insn is available.\n+\t(find_barrier, gen_block_redirect, split_branches): Fix indentation.\n+\t(calc_live_regs): Likewise.\n+\n Wed Jan 19 19:12:36 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sh.md (fpu_single, fp_mode): New attributes."}, {"sha": "0478610eaa568aaee0aebca7803b777ca4b3b865", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eda44c7832aab6417df69d6ab57f422f63c2dd0a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eda44c7832aab6417df69d6ab57f422f63c2dd0a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=eda44c7832aab6417df69d6ab57f422f63c2dd0a", "patch": "@@ -501,6 +501,7 @@ prepare_scc_operands (code)\n   /* First need a compare insn.  */\n   switch (code)\n     {\n+    default:\n     case NE:\n       /* It isn't possible to handle this case.  */\n       abort ();\n@@ -516,8 +517,6 @@ prepare_scc_operands (code)\n     case LEU:\n       code = GEU;\n       break;\n-    default:\n-      break;\n     }\n   if (code != oldcode)\n     {\n@@ -2212,23 +2211,23 @@ find_barrier (num_mova, mova, from)\n     }\n \n   if (num_mova)\n-  {\n-    if (leading_mova)\n-      {\n-\t/* Try as we might, the leading mova is out of range.  Change\n-\t   it into a load (which will become a pcload) and retry.  */\n-\tSET_SRC (PATTERN (mova)) = XVECEXP (SET_SRC (PATTERN (mova)), 0, 0);\n-\tINSN_CODE (mova) = -1;\n-        return find_barrier (0, 0, mova);\n-      }\n-    else\n-      {\n-\t/* Insert the constant pool table before the mova instruction,\n-\t   to prevent the mova label reference from going out of range.  */\n-\tfrom = mova;\n-\tgood_barrier = found_barrier = barrier_before_mova;\n-      }\n-  }\n+    {\n+      if (leading_mova)\n+\t{\n+\t  /* Try as we might, the leading mova is out of range.  Change\n+\t     it into a load (which will become a pcload) and retry.  */\n+\t  SET_SRC (PATTERN (mova)) = XVECEXP (SET_SRC (PATTERN (mova)), 0, 0);\n+\t  INSN_CODE (mova) = -1;\n+\t  return find_barrier (0, 0, mova);\n+\t}\n+      else\n+\t{\n+\t  /* Insert the constant pool table before the mova instruction,\n+\t     to prevent the mova label reference from going out of range.  */\n+\t  from = mova;\n+\t  good_barrier = found_barrier = barrier_before_mova;\n+\t}\n+    }\n \n   if (found_barrier)\n     {\n@@ -2530,7 +2529,8 @@ gen_block_redirect (jump, addr, need_block)\n \t      break;\n \t    }\n \t}\n-      for (used = dead = 0, scan = JUMP_LABEL (jump); (scan = NEXT_INSN (scan)); )\n+      for (used = dead = 0, scan = JUMP_LABEL (jump);\n+\t   (scan = NEXT_INSN (scan)); )\n \t{\n \t  enum rtx_code code;\n \n@@ -2549,12 +2549,12 @@ gen_block_redirect (jump, addr, need_block)\n \t\t  break;\n \t\t}\n \t      if (code == JUMP_INSN)\n-\t      {\n-\t\tif (jump_left-- && simplejump_p (scan))\n-\t\t  scan = JUMP_LABEL (scan);\n-\t\telse\n-\t\t  break;\n-\t      }\n+\t\t{\n+\t\t  if (jump_left-- && simplejump_p (scan))\n+\t\t    scan = JUMP_LABEL (scan);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n \t    }\n \t}\n       /* Mask out the stack pointer again, in case it was\n@@ -2624,7 +2624,7 @@ struct far_branch\n   int address;\n };\n \n-static  void gen_far_branch PARAMS ((struct far_branch *));\n+static void gen_far_branch PARAMS ((struct far_branch *));\n enum mdep_reorg_phase_e mdep_reorg_phase;\n void\n gen_far_branch (bp)\n@@ -3326,12 +3326,12 @@ split_branches (first)\n \t\t\tbp->near_label = label;\n \t\t      }\n \t\t    else if (label && ! NEXT_INSN (label))\n-\t\t    {\n-\t\t      if (addr + 2 - bp->address <= CONDJUMP_MAX)\n-\t\t\tbp->insert_place = insn;\n-\t\t      else\n-\t\t\tgen_far_branch (bp);\n-\t\t    }\n+\t\t      {\n+\t\t\tif (addr + 2 - bp->address <= CONDJUMP_MAX)\n+\t\t\t  bp->insert_place = insn;\n+\t\t\telse\n+\t\t\t  gen_far_branch (bp);\n+\t\t      }\n \t\t  }\n \t\tif (! label\n \t\t    || (NEXT_INSN (label) && bp->address - addr < CONDJUMP_MIN))\n@@ -3737,25 +3737,25 @@ calc_live_regs (count_ptr, live_regs_mask2)\n \t    live_regs_mask |= 1 << reg;\n \t  count++;\n \t  if (TARGET_SH4 && TARGET_FMOVD && reg >= FIRST_FP_REG)\n-\t  {\n-\t    if (reg <= LAST_FP_REG)\n-\t      {\n-\t\tif (! TARGET_FPU_SINGLE && ! regs_ever_live[reg ^ 1])\n-\t\t  {\n-\t\t    if (reg >= 32)\n-\t\t      *live_regs_mask2 |= 1 << ((reg ^ 1) - 32);\n-\t\t    else\n-\t\t      live_regs_mask |= 1 << (reg ^ 1);\n-\t\t    count++;\n-\t\t  }\n-\t      }\n-\t    else if (reg <= LAST_XD_REG)\n-\t      {\n-\t\t/* Must switch to double mode to access these registers.  */\n-\t\ttarget_flags &= ~FPU_SINGLE_BIT;\n-\t\tcount++;\n-\t      }\n-\t  }\n+\t    {\n+\t      if (reg <= LAST_FP_REG)\n+\t\t{\n+\t\t  if (! TARGET_FPU_SINGLE && ! regs_ever_live[reg ^ 1])\n+\t\t    {\n+\t\t      if (reg >= 32)\n+\t\t\t*live_regs_mask2 |= 1 << ((reg ^ 1) - 32);\n+\t\t      else\n+\t\t\tlive_regs_mask |= 1 << (reg ^ 1);\n+\t\t      count++;\n+\t\t    }\n+\t\t}\n+\t      else if (reg <= LAST_XD_REG)\n+\t\t{\n+\t\t  /* Must switch to double mode to access these registers.  */\n+\t\t  target_flags &= ~FPU_SINGLE_BIT;\n+\t\t  count++;\n+\t\t}\n+\t    }\n \t}\n     }\n "}]}