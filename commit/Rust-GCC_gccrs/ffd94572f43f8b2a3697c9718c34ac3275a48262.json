{"sha": "ffd94572f43f8b2a3697c9718c34ac3275a48262", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZkOTQ1NzJmNDNmOGIyYTM2OTdjOTcxOGMzNGFjMzI3NWE0ODI2Mg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-07-21T01:54:06Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-07-21T01:54:06Z"}, "message": "Runtime.java: Comment fix.\n\n\t* java/lang/Runtime.java: Comment fix.\n\t* java/lang/ClassLoader.java (isAncestorOf): New method.\n\t(getParent): Uncommented security check.  Use isAncestorOf.\n\t* include/jvm.h (_Jv_CheckAccess): Declare.\n\t* java/lang/reflect/natConstructor.cc (newInstance): Perform\n\taccess check.\n\tInclude IllegalAccessException.h, ArrayIndexOutOfBoundsException.h.\n\t* java/lang/reflect/natArray.cc (newInstance): Pass caller's\n\tclass loader to _Jv_GetArrayClass.\n\tInclude ArrayIndexOutOfBoundsException.h.\n\t* java/lang/reflect/Field.java: Update comment to reflect status.\n\t(equals): Fixed indentation.\n\t* java/lang/Class.h (Class): Declare memberAccessCheck, not\n\tcheckMemberAccess.  Make _Jv_CheckAccess a friend.\n\t* java/lang/Class.java (memberAccessCheck): New method from\n\tClasspath.\n\t(checkMemberAccess): Removed.\n\t(getDeclaredMethod): Use memberAccessCheck.\n\t(getField): Likewise.\n\t(getMethod): Likewise.\n\t* resolve.cc (_Jv_ResolvePoolEntry): Use _Jv_CheckAccess.\n\t(_Jv_SearchMethodInClass): Likewise.\n\t* prims.cc (_Jv_CheckAccess): New function.\n\t* jni.cc (_Jv_JNI_FindClass): Use getClassLoaderInternal.\n\t(_Jv_JNI_GetAnyFieldID): Likewise.\n\t* java/lang/natClass.cc (forName): Use getClassLoaderInternal.\n\t(getClassLoader): Added security check.\n\t(getConstructor): Call memberAccessCheck.\n\t(getDeclaredClasses): Likewise.\n\t(getDeclaredField): Likewise.\n\t(getDeclaredFields): Likewise.\n\t(_getConstructors): Likewise.\n\t(getDeclaredConstructor): Likewise.\n\t(getDeclaredMethods): Likewise.\n\t(getFields): Likewise.\n\t(getMethods): Likewise.\n\t(newInstance): Likewise.\n\t(_Jv_MakeVTable): Put method name in exception.\n\t* java/lang/reflect/natMethod.cc (getType): Use\n\tgetClassLoaderInternal.\n\t(_Jv_GetTypesFromSignature): Likewise.\n\t(invoke): Perform access check.\n\t(_Jv_CallAnyMethodA): Removed old FIXME comments.\n\tInclude ArrayIndexOutOfBoundsException.h.\n\t* java/lang/reflect/natField.cc (getType): Use\n\tgetClassLoaderInternal.\n\t(_Jv_CheckFieldAccessibility): Removed.\n\t(getAddr): Use _Jv_CheckAccess; find caller.\n\tInclude ArrayIndexOutOfBoundsException.h.\n\nFrom-SVN: r69621", "tree": {"sha": "dceb21b9cf452ee4920e5a2a6465e98ae9cd868c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dceb21b9cf452ee4920e5a2a6465e98ae9cd868c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffd94572f43f8b2a3697c9718c34ac3275a48262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd94572f43f8b2a3697c9718c34ac3275a48262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffd94572f43f8b2a3697c9718c34ac3275a48262", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd94572f43f8b2a3697c9718c34ac3275a48262/comments", "author": null, "committer": null, "parents": [{"sha": "3c87bc22a96ca7029326ef7992f03382f0a22353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c87bc22a96ca7029326ef7992f03382f0a22353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c87bc22a96ca7029326ef7992f03382f0a22353"}], "stats": {"total": 438, "additions": 286, "deletions": 152}, "files": [{"sha": "2942cb99d0df3cfa8a2fcd570e60fc59016b6316", "filename": "libjava/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,9 +1,62 @@\n+2003-07-20  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/Runtime.java: Comment fix.\n+\t* java/lang/ClassLoader.java (isAncestorOf): New method.\n+\t(getParent): Uncommented security check.  Use isAncestorOf.\n+\t* include/jvm.h (_Jv_CheckAccess): Declare.\n+\t* java/lang/reflect/natConstructor.cc (newInstance): Perform\n+\taccess check.\n+\tInclude IllegalAccessException.h, ArrayIndexOutOfBoundsException.h.\n+\t* java/lang/reflect/natArray.cc (newInstance): Pass caller's\n+\tclass loader to _Jv_GetArrayClass.\n+\tInclude ArrayIndexOutOfBoundsException.h.\n+\t* java/lang/reflect/Field.java: Update comment to reflect status.\n+\t(equals): Fixed indentation.\n+\t* java/lang/Class.h (Class): Declare memberAccessCheck, not\n+\tcheckMemberAccess.  Make _Jv_CheckAccess a friend.\n+\t* java/lang/Class.java (memberAccessCheck): New method from\n+\tClasspath.\n+\t(checkMemberAccess): Removed.\n+\t(getDeclaredMethod): Use memberAccessCheck.\n+\t(getField): Likewise.\n+\t(getMethod): Likewise.\n+\t* resolve.cc (_Jv_ResolvePoolEntry): Use _Jv_CheckAccess.\n+\t(_Jv_SearchMethodInClass): Likewise.\n+\t* prims.cc (_Jv_CheckAccess): New function.\n+\t* jni.cc (_Jv_JNI_FindClass): Use getClassLoaderInternal.\n+\t(_Jv_JNI_GetAnyFieldID): Likewise.\n+\t* java/lang/natClass.cc (forName): Use getClassLoaderInternal.\n+\t(getClassLoader): Added security check.\n+\t(getConstructor): Call memberAccessCheck.\n+\t(getDeclaredClasses): Likewise.\n+\t(getDeclaredField): Likewise.\n+\t(getDeclaredFields): Likewise.\n+\t(_getConstructors): Likewise.\n+\t(getDeclaredConstructor): Likewise.\n+\t(getDeclaredMethods): Likewise.\n+\t(getFields): Likewise.\n+\t(getMethods): Likewise.\n+\t(newInstance): Likewise.\n+\t(_Jv_MakeVTable): Put method name in exception.\n+\t* java/lang/reflect/natMethod.cc (getType): Use\n+\tgetClassLoaderInternal.\n+\t(_Jv_GetTypesFromSignature): Likewise.\n+\t(invoke): Perform access check.\n+\t(_Jv_CallAnyMethodA): Removed old FIXME comments.\n+\tInclude ArrayIndexOutOfBoundsException.h.\n+\t* java/lang/reflect/natField.cc (getType): Use\n+\tgetClassLoaderInternal.\n+\t(_Jv_CheckFieldAccessibility): Removed.\n+\t(getAddr): Use _Jv_CheckAccess; find caller.\n+\tInclude ArrayIndexOutOfBoundsException.h.\n+\n 2003-07-20  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/URL.java\n \t(URL): Fixed documentation to name an argument correcty, Reformatted\n \tone method declaration.\n \t(getURLStreamHandler): Added documentation from classpath.\n+\n 2003-07-19  Tom Tromey  <tromey@redhat.com>\n \n \t* mauve-libgcj: Don't run CollationElementIterator tests."}, {"sha": "38155d3a3ec5df668869ac4239dd98597cc47cb0", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,6 +1,6 @@\n // jvm.h - Header file for private implementation information. -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -326,6 +326,9 @@ extern void _Jv_GetTypesFromSignature (jmethodID method,\n \t\t\t\t       JArray<jclass> **arg_types_out,\n \t\t\t\t       jclass *return_type_out);\n \n+extern jboolean _Jv_CheckAccess (jclass self_klass, jclass other_klass,\n+\t\t\t\t jint flags);\n+\n extern jobject _Jv_CallAnyMethodA (jobject obj, jclass return_type,\n \t\t\t\t   jmethodID meth, jboolean is_constructor,\n \t\t\t\t   JArray<jclass> *parameter_types,"}, {"sha": "06c9c804d9e6020e96de09221526eac8b5cdb5cc", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -243,7 +243,7 @@ class java::lang::Class : public java::lang::Object\n \n private:   \n \n-  void checkMemberAccess (jint flags);\n+  void memberAccessCheck (jint flags);\n \n   void initializeClass (void);\n \n@@ -328,6 +328,9 @@ class java::lang::Class : public java::lang::Object\n   friend void _Jv_SetVTableEntries (jclass, _Jv_VTable *, jboolean *);\n   friend void _Jv_MakeVTable (jclass);\n \n+  friend jboolean _Jv_CheckAccess (jclass self_klass, jclass other_klass,\n+\t\t\t\t   jint flags);\n+\n   // Return array class corresponding to element type KLASS, creating it if\n   // necessary.\n   inline friend jclass"}, {"sha": "bd776913fdd88dfebdeb1dbc067e228f82041316", "filename": "libjava/java/lang/Class.java", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -72,14 +72,7 @@ private native Method _getDeclaredMethod (String methodName,\n   public Method getDeclaredMethod (String methodName, Class[] parameterTypes)\n     throws NoSuchMethodException, SecurityException\n   {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      {\n-\tsm.checkMemberAccess(this, Member.DECLARED);\n-\tPackage p = getPackage();\n-\tif (p != null)\n-\t  sm.checkPackageAccess(p.getName());\n-      }\n+    memberAccessCheck(Member.DECLARED);\n \n     if (\"<init>\".equals(methodName) || \"<clinit>\".equals(methodName))\n       throw new NoSuchMethodException(methodName);\n@@ -101,9 +94,7 @@ private native Field getField (String fieldName, int hash)\n   public Field getField (String fieldName)\n     throws NoSuchFieldException, SecurityException\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkMemberAccess (this, java.lang.reflect.Member.DECLARED);\n+    memberAccessCheck (Member.PUBLIC);\n     Field fld = getField(fieldName, fieldName.hashCode());\n     if (fld == null)\n       throw new NoSuchFieldException(fieldName);\n@@ -148,14 +139,7 @@ private static final native String getSignature (Class[] parameterTypes,\n   public Method getMethod (String methodName, Class[] parameterTypes)\n     throws NoSuchMethodException, SecurityException\n   {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      {\n-\tsm.checkMemberAccess(this, Member.PUBLIC);\n-\tPackage p = getPackage();\n-\tif (p != null)\n-\t  sm.checkPackageAccess(p.getName());\n-      }\n+    memberAccessCheck(Member.PUBLIC);\n \n     if (\"<init>\".equals(methodName) || \"<clinit>\".equals(methodName))\n       throw new NoSuchMethodException(methodName);\n@@ -334,14 +318,6 @@ private Class ()\n   {\n   }\n \n-  // Do a security check.\n-  private void checkMemberAccess (int flags)\n-  {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkMemberAccess(this, flags);\n-  }\n-\n   // Initialize the class.\n   private native void initializeClass ();\n \n@@ -361,4 +337,20 @@ private static String getPackagePortion(String name)\n       return \"\";\n     return name.substring(0, lastInd);\n   }\n+\n+  /**\n+   * Perform security checks common to all of the methods that\n+   * get members of this Class.\n+   */\n+  private void memberAccessCheck(int which)\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+\tsm.checkMemberAccess(this, which);\n+\tPackage pkg = getPackage();\n+\tif (pkg != null)\n+\t  sm.checkPackageAccess(pkg.getName());\n+      }\n+  }\n }"}, {"sha": "008a19e6603982b7deba379764d1ad30f51eb9e0", "filename": "libjava/java/lang/ClassLoader.java", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -162,12 +162,10 @@ public final ClassLoader getParent ()\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       {\n-\t/* FIXME: security, getClassContext() not implemented.\n \tClass c = VMSecurityManager.getClassContext()[1];\n \tClassLoader cl = c.getClassLoader();\n-\tif (cl != null && cl != this)\n+\tif (cl != null && ! cl.isAncestorOf(this))\n \t  sm.checkPermission(new RuntimePermission(\"getClassLoader\"));\n-\t*/\n       }\n     return parent;\n   }\n@@ -996,4 +994,20 @@ public synchronized void clearAssertionStatus()\n     packageAssertionStatus = new HashMap();\n     classAssertionStatus = new HashMap();\n   }\n+\n+  /**\n+   * Return true if this loader is either the specified class loader\n+   * or an ancestor thereof.\n+   * @param loader the class loader to check\n+   */\n+  final boolean isAncestorOf(ClassLoader loader)\n+  {\n+    while (loader != null)\n+      {\n+\tif (this == loader)\n+\t  return true;\n+\tloader = loader.parent;\n+      }\n+    return false;\n+  }\n }"}, {"sha": "5c6037ed8a7a25e88174218054b1996846bbf901", "filename": "libjava/java/lang/Runtime.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FRuntime.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FRuntime.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FRuntime.java?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,5 +1,5 @@\n /* Runtime.java -- access to the VM process\n-   Copyright (C) 1998, 2002 Free Software Foundation\n+   Copyright (C) 1998, 2002, 2003 Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -65,7 +65,7 @@\n \n   /**\n    * The current security manager. This is located here instead of in\n-   * Runtime, to avoid security problems, as well as bootstrap issues.\n+   * System, to avoid security problems, as well as bootstrap issues.\n    * Make sure to access it in a thread-safe manner; it is package visible\n    * to avoid overhead in java.lang.\n    */"}, {"sha": "4b0858225df33c81ab98a8cea9c3d2ef09c0b89f", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 58, "deletions": 29, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -101,7 +101,7 @@ java::lang::Class::forName (jstring className)\n \t{\n \t  klass = t->classAt (i);\n \t}\n-      loader = klass->getClassLoader();\n+      loader = klass->getClassLoaderInternal();\n     }\n   catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n     {\n@@ -113,13 +113,31 @@ java::lang::Class::forName (jstring className)\n java::lang::ClassLoader *\n java::lang::Class::getClassLoader (void)\n {\n-#if 0\n-  // FIXME: the checks we need to do are more complex.  See the spec.\n-  // Currently we can't implement them.\n   java::lang::SecurityManager *s = java::lang::System::getSecurityManager();\n   if (s != NULL)\n-    s->checkPermission (new RuntimePermission (JvNewStringLatin1 (\"getClassLoader\")));\n-#endif\n+    {\n+      gnu::gcj::runtime::StackTrace *t \n+\t= new gnu::gcj::runtime::StackTrace(4);\n+      Class *caller = NULL;\n+      ClassLoader *caller_loader = NULL;\n+      try\n+\t{\n+\t  for (int i = 1; !caller; i++)\n+\t    {\n+\t      caller = t->classAt (i);\n+\t    }\n+\t  caller_loader = caller->getClassLoaderInternal();\n+\t}\n+      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n+\t{\n+\t}\n+\n+      // If the caller has a non-null class loader, and that loader\n+      // is not this class' loader or an ancestor thereof, then do a\n+      // security check.\n+      if (caller_loader != NULL && ! caller_loader->isAncestorOf(loader))\n+\ts->checkPermission (new RuntimePermission (JvNewStringLatin1 (\"getClassLoader\")));\n+    }\n \n   // The spec requires us to return `null' for primitive classes.  In\n   // other cases we have the option of returning `null' for classes\n@@ -136,13 +154,14 @@ java::lang::Class::getClassLoader (void)\n java::lang::reflect::Constructor *\n java::lang::Class::getConstructor (JArray<jclass> *param_types)\n {\n+  memberAccessCheck(java::lang::reflect::Member::PUBLIC);\n+\n   jstring partial_sig = getSignature (param_types, true);\n   jint hash = partial_sig->hashCode ();\n \n   int i = isPrimitive () ? 0 : method_count;\n   while (--i >= 0)\n     {\n-      // FIXME: access checks.\n       if (_Jv_equalUtf8Consts (methods[i].name, init_name)\n \t  && _Jv_equal (methods[i].signature, partial_sig, hash))\n \t{\n@@ -163,7 +182,7 @@ java::lang::Class::getConstructor (JArray<jclass> *param_types)\n JArray<java::lang::reflect::Constructor *> *\n java::lang::Class::_getConstructors (jboolean declared)\n {\n-  // FIXME: this method needs access checks.\n+  memberAccessCheck(java::lang::reflect::Member::PUBLIC);\n \n   int numConstructors = 0;\n   int max = isPrimitive () ? 0 : method_count;\n@@ -206,13 +225,14 @@ java::lang::Class::_getConstructors (jboolean declared)\n java::lang::reflect::Constructor *\n java::lang::Class::getDeclaredConstructor (JArray<jclass> *param_types)\n {\n+  memberAccessCheck(java::lang::reflect::Member::DECLARED);\n+\n   jstring partial_sig = getSignature (param_types, true);\n   jint hash = partial_sig->hashCode ();\n \n   int i = isPrimitive () ? 0 : method_count;\n   while (--i >= 0)\n     {\n-      // FIXME: access checks.\n       if (_Jv_equalUtf8Consts (methods[i].name, init_name)\n \t  && _Jv_equal (methods[i].signature, partial_sig, hash))\n \t{\n@@ -256,9 +276,7 @@ java::lang::Class::getField (jstring name, jint hash)\n java::lang::reflect::Field *\n java::lang::Class::getDeclaredField (jstring name)\n {\n-  java::lang::SecurityManager *s = java::lang::System::getSecurityManager();\n-  if (s != NULL)\n-    s->checkMemberAccess (this, java::lang::reflect::Member::DECLARED);\n+  memberAccessCheck(java::lang::reflect::Member::DECLARED);\n   int hash = name->hashCode();\n   for (int i = 0;  i < field_count;  i++)\n     {\n@@ -277,9 +295,7 @@ java::lang::Class::getDeclaredField (jstring name)\n JArray<java::lang::reflect::Field *> *\n java::lang::Class::getDeclaredFields (void)\n {\n-  java::lang::SecurityManager *s = java::lang::System::getSecurityManager();\n-  if (s != NULL)\n-    s->checkMemberAccess (this, java::lang::reflect::Member::DECLARED);\n+  memberAccessCheck(java::lang::reflect::Member::DECLARED);\n   JArray<java::lang::reflect::Field *> *result\n     = (JArray<java::lang::reflect::Field *> *)\n     JvNewObjectArray (field_count, &java::lang::reflect::Field::class$, NULL);\n@@ -361,6 +377,8 @@ java::lang::Class::_getDeclaredMethod (jstring name,\n JArray<java::lang::reflect::Method *> *\n java::lang::Class::getDeclaredMethods (void)\n {\n+  memberAccessCheck(java::lang::reflect::Member::DECLARED);\n+\n   int numMethods = 0;\n   int max = isPrimitive () ? 0 : method_count;\n   int i;\n@@ -424,7 +442,7 @@ java::lang::Class::getClasses (void)\n JArray<jclass> *\n java::lang::Class::getDeclaredClasses (void)\n {\n-  checkMemberAccess (java::lang::reflect::Member::DECLARED);\n+  memberAccessCheck (java::lang::reflect::Member::DECLARED);\n   // Until we have inner classes, it always makes sense to return an\n   // empty array.\n   JArray<jclass> *result\n@@ -482,9 +500,7 @@ java::lang::Class::_getFields (JArray<java::lang::reflect::Field *> *result,\n JArray<java::lang::reflect::Field *> *\n java::lang::Class::getFields (void)\n {\n-  // FIXME: security checking.\n-\n-  using namespace java::lang::reflect;\n+  memberAccessCheck(java::lang::reflect::Member::PUBLIC);\n \n   int count = _getFields (NULL, 0);\n \n@@ -518,7 +534,6 @@ java::lang::Class::_getMethod (jstring name, JArray<jclass> *param_types)\n       int i = klass->isPrimitive () ? 0 : klass->method_count;\n       while (--i >= 0)\n \t{\n-\t  // FIXME: access checks.\n \t  if (_Jv_equalUtf8Consts (klass->methods[i].name, utf_name)\n \t      && _Jv_equaln (klass->methods[i].signature, partial_sig, p_len)\n \t      && (klass->methods[i].accflags\n@@ -642,7 +657,7 @@ java::lang::Class::getMethods (void)\n {\n   using namespace java::lang::reflect;\n \n-  // FIXME: security checks.\n+  memberAccessCheck(Member::PUBLIC);\n \n   // This will overestimate the size we need.\n   jint count = _getMethods (NULL, 0);\n@@ -696,12 +711,7 @@ java::lang::Class::isInstance (jobject obj)\n jobject\n java::lang::Class::newInstance (void)\n {\n-  // FIXME: do accessibility checks here.  There currently doesn't\n-  // seem to be any way to do these.\n-  // FIXME: we special-case one check here just to pass a Plum Hall\n-  // test.  Once access checking is implemented, remove this.\n-  if (this == &java::lang::Class::class$)\n-    throw new java::lang::IllegalAccessException;\n+  memberAccessCheck(java::lang::reflect::Member::PUBLIC);\n \n   if (isPrimitive ()\n       || isInterface ()\n@@ -1744,7 +1754,26 @@ _Jv_MakeVTable (jclass klass)\n     {\n       for (int i = 0; i < klass->vtable_method_count; ++i)\n \tif (! flags[i])\n-\t  // FIXME: messsage.\n-\t  throw new java::lang::AbstractMethodError ();\n+\t  {\n+\t    using namespace java::lang;\n+\t    while (klass != NULL)\n+\t      {\n+\t\tfor (int j = 0; j < klass->method_count; ++j)\n+\t\t  {\n+\t\t    if (klass->methods[i].index == i)\n+\t\t      {\n+\t\t\tStringBuffer *buf = new StringBuffer ();\n+\t\t\tbuf->append (_Jv_NewStringUtf8Const (klass->methods[i].name));\n+\t\t\tbuf->append ((jchar) ' ');\n+\t\t\tbuf->append (_Jv_NewStringUtf8Const (klass->methods[i].signature));\n+\t\t\tthrow new AbstractMethodError (buf->toString ());\n+\t\t      }\n+\t\t  }\n+\t\tklass = klass->getSuperclass ();\n+\t      }\n+\t    // Couldn't find the name, which is weird.\n+\t    // But we still must throw the error.\n+\t    throw new AbstractMethodError ();\n+\t  }\n     }\n }"}, {"sha": "b54a103d9bc4956d85978cdb109c375b441956fd", "filename": "libjava/java/lang/reflect/Field.java", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FField.java?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -12,15 +12,6 @@\n  * @author Per Bothner <bothner@cygnus.com>\n  * @date September 1998;  February 1999.\n  */\n-/* Status:  Mostly implemented.\n- * However, access checks are not implemented.  See natField.cc for\n- * _Jv_CheckFieldAccessibility as well as the missing getCaller.\n- * Note that the idea is to have to compiler convert calls to\n- * setXXX(...) and getXXX(...) to setXXX(CALLER, ...) and getXXX(CALLER, ...),\n- * where CALLER is reference to the class that contains the calls to\n- * setXXX or getXXX.  This is easy for the compiler, and replaces\n- * expensive stack and table searching with a constant.\n- */\n \n public final class Field extends AccessibleObject implements Member\n {\n@@ -39,12 +30,12 @@ public final class Field extends AccessibleObject implements Member\n   }\n \n   public boolean equals (Object fld)\n-    {\n-      if (! (fld instanceof Field))\n-\treturn false;\n-      Field f = (Field) fld;\n-      return declaringClass == f.declaringClass && offset == f.offset;\n-    }\n+  {\n+    if (! (fld instanceof Field))\n+      return false;\n+    Field f = (Field) fld;\n+    return declaringClass == f.declaringClass && offset == f.offset;\n+  }\n \n   public Class getDeclaringClass ()\n   {\n@@ -62,11 +53,6 @@ public int hashCode()\n     return (declaringClass.hashCode() ^ offset);\n   }\n \n-  // The idea is that the compiler will magically translate\n-  // fld.getShort(obj) to fld.getShort(THISCLASS, obj).\n-  // This makes checking assessiblity more efficient,\n-  // since we don't have to do any stack-walking.\n-\n   public boolean getBoolean (Object obj)\n     throws IllegalArgumentException, IllegalAccessException\n   {"}, {"sha": "9fa2ef79d3bc73f6cfdd95a2e71a984ccc451dbd", "filename": "libjava/java/lang/reflect/natArray.cc", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,6 +1,6 @@\n // natField.cc - Implementation of java.lang.reflect.Field native methods.\n \n-/* Copyright (C) 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -15,6 +15,7 @@ details.  */\n #include <jvm.h>\n #include <gcj/cni.h>\n #include <java/lang/reflect/Array.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/IllegalArgumentException.h>\n #include <java/lang/Byte.h>\n #include <java/lang/Short.h>\n@@ -38,8 +39,8 @@ java::lang::reflect::Array::newInstance (jclass componentType, jint length)\n       return _Jv_NewPrimArray (componentType, length);\n     }\n   else\n+    // FIXME: class loader?\n     return JvNewObjectArray (length, componentType, NULL);\n-\n }\n \n jobject\n@@ -52,10 +53,26 @@ java::lang::reflect::Array::newInstance (jclass componentType,\n   jint* dims = elements (dimensions);\n   if (ndims == 1)\n     return newInstance (componentType, dims[0]);\n+\n+  gnu::gcj::runtime::StackTrace *t \n+    = new gnu::gcj::runtime::StackTrace(4);\n+  Class *caller = NULL;\n+  ClassLoader *caller_loader = NULL;\n+  try\n+    {\n+      for (int i = 1; !caller; i++)\n+\t{\n+\t  caller = t->classAt (i);\n+\t}\n+      caller_loader = caller->getClassLoaderInternal();\n+    }\n+  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n+    {\n+    }\n+\n   jclass arrayType = componentType;\n-  for (int i = 0;  i < ndims;  i++)  // FIXME 2nd arg should \n-                                     // be \"current\" loader\n-    arrayType = _Jv_GetArrayClass (arrayType, 0);\n+  for (int i = 0;  i < ndims;  i++)\n+    arrayType = _Jv_GetArrayClass (arrayType, caller_loader);\n \n   return _Jv_NewMultiArray (arrayType, ndims, dims);\n }\n@@ -343,8 +360,10 @@ java::lang::reflect::Array::setBoolean (jobject array,\n \n void\n java::lang::reflect::Array::set (jobject array, jint index,\n-\t\t\t\t       jobject value, jclass elType)\n+\t\t\t\t jobject value, jclass elType)\n {\n+  // We don't have to call getElementType here, or check INDEX,\n+  // because it was already done in the Java wrapper.\n   if (! _Jv_IsInstanceOf (value, elType))\n     throw new java::lang::IllegalArgumentException;\n   elements ((jobjectArray) array) [index] = value;"}, {"sha": "466c75441123cebbc5b19dee7865891d61595d2e", "filename": "libjava/java/lang/reflect/natConstructor.cc", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,6 +1,6 @@\n // natConstructor.cc - Native code for Constructor class.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -13,6 +13,8 @@ details.  */\n #include <gcj/cni.h>\n #include <jvm.h>\n \n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/IllegalAccessException.h>\n #include <java/lang/reflect/Constructor.h>\n #include <java/lang/reflect/Method.h>\n #include <java/lang/reflect/InvocationTargetException.h>\n@@ -46,6 +48,24 @@ java::lang::reflect::Constructor::newInstance (jobjectArray args)\n   if (parameter_types == NULL)\n     getType ();\n \n+  gnu::gcj::runtime::StackTrace *t \n+    = new gnu::gcj::runtime::StackTrace(4);\n+  Class *caller = NULL;\n+  try\n+    {\n+      for (int i = 1; !caller; i++)\n+\t{\n+\t  caller = t->classAt (i);\n+\t}\n+    }\n+  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n+    {\n+    }\n+\n+  if (! isAccessible() && ! _Jv_CheckAccess(caller, declaringClass,\n+\t\t\t\t\t    declaringClass->getModifiers()))\n+    throw new java::lang::IllegalAccessException;\n+\n   using namespace java::lang::reflect;\n   if (Modifier::isAbstract (declaringClass->getModifiers()))\n     throw new InstantiationException;"}, {"sha": "5f104a9d99975e27aa21fdbc45b8f2115498a53d", "filename": "libjava/java/lang/reflect/natField.cc", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,6 +1,6 @@\n // natField.cc - Implementation of java.lang.reflect.Field native methods.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -15,6 +15,7 @@ details.  */\n #include <jvm.h>\n #include <java/lang/reflect/Field.h>\n #include <java/lang/reflect/Modifier.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/IllegalArgumentException.h>\n #include <java/lang/IllegalAccessException.h>\n #include <java/lang/NullPointerException.h>\n@@ -46,31 +47,36 @@ java::lang::reflect::Field::getType ()\n {\n   jfieldID fld = _Jv_FromReflectedField (this);\n   JvSynchronize sync (declaringClass);\n-  _Jv_ResolveField (fld, declaringClass->getClassLoader ());\n+  _Jv_ResolveField (fld, declaringClass->getClassLoaderInternal ());\n   return fld->type;\n }\n \n-static void\n-_Jv_CheckFieldAccessibility (jfieldID /*fld*/, jclass /*caller*/)\n-{\n-#if 0\n-  if (caller == NULL)\n-    caller = getCaller();\n-#endif\n-#if 0\n-  _Jv_ushort flags = fld->getModifiers();\n-  check accesss;\n-#endif\n-}\n-\n static void*\n getAddr (java::lang::reflect::Field* field, jclass caller, jobject obj)\n {\n+  // FIXME: we know CALLER is NULL here.  At one point we planned to\n+  // have the compiler insert the caller as a hidden argument in some\n+  // calls.  However, we never implemented that, so we have to find\n+  // the caller by hand instead.\n+  gnu::gcj::runtime::StackTrace *t \n+    = new gnu::gcj::runtime::StackTrace(4);\n+  try\n+    {\n+      for (int i = 1; !caller; i++)\n+\t{\n+\t  caller = t->classAt (i);\n+\t}\n+    }\n+  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n+    {\n+    }\n+\n   jfieldID fld = _Jv_FromReflectedField (field);\n   _Jv_ushort flags = fld->getModifiers();\n-  if (! (flags & java::lang::reflect::Modifier::PUBLIC)\n-      && ! field->isAccessible ())\n-    _Jv_CheckFieldAccessibility (fld, caller);\n+  if (! field->isAccessible ()\n+      && ! _Jv_CheckAccess (caller, field->getDeclaringClass(), flags))\n+    throw new java::lang::IllegalAccessException;\n+\n   if (flags & java::lang::reflect::Modifier::STATIC)\n     {\n       jclass fldClass = field->getDeclaringClass ();"}, {"sha": "7f391f91969b4cf116d54163e2f0a64eae42cb6f", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,6 +1,6 @@\n // natMethod.cc - Native code for Method class.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001 , 2002 Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001 , 2002, 2003 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -30,6 +30,7 @@ details.  */\n #include <java/lang/Double.h>\n #include <java/lang/IllegalArgumentException.h>\n #include <java/lang/NullPointerException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/Class.h>\n #include <gcj/method.h>\n #include <gnu/gcj/RawData.h>\n@@ -142,28 +143,46 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n   if (parameter_types == NULL)\n     getType ();\n \n+  gnu::gcj::runtime::StackTrace *t \n+    = new gnu::gcj::runtime::StackTrace(4);\n+  Class *caller = NULL;\n+  try\n+    {\n+      for (int i = 1; !caller; i++)\n+\t{\n+\t  caller = t->classAt (i);\n+\t}\n+    }\n+  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n+    {\n+    }\n+\n   jmethodID meth = _Jv_FromReflectedMethod (this);\n+  jclass klass;\n   if (! java::lang::reflect::Modifier::isStatic(meth->accflags))\n     {\n-      jclass k = obj ? obj->getClass() : NULL;\n       if (! obj)\n \tthrow new java::lang::NullPointerException;\n-      if (! declaringClass->isAssignableFrom(k))\n+      klass = obj->getClass();\n+      if (! declaringClass->isAssignableFrom(klass))\n \tthrow new java::lang::IllegalArgumentException;\n-      // FIXME: access checks.\n \n       // Find the possibly overloaded method based on the runtime type\n       // of the object.\n-      meth = _Jv_LookupDeclaredMethod (k, meth->name, meth->signature);\n+      meth = _Jv_LookupDeclaredMethod (klass, meth->name, meth->signature);\n     }\n   else\n     {\n       // We have to initialize a static class.  It is safe to do this\n       // here and not in _Jv_CallAnyMethodA because JNI initializes a\n       // class whenever a method lookup is done.\n       _Jv_InitClass (declaringClass);\n+      klass = declaringClass;\n     }\n \n+  if (! isAccessible() && ! _Jv_CheckAccess(caller, klass, meth->accflags))\n+    throw new IllegalArgumentException;\n+\n   return _Jv_CallAnyMethodA (obj, return_type, meth, false,\n \t\t\t     parameter_types, args);\n }\n@@ -207,7 +226,7 @@ java::lang::reflect::Method::getType ()\n   jclass *elts = elements (exception_types);\n   for (int i = 0; i < count; ++i)\n     elts[i] = _Jv_FindClass (method->throws[i],\n-\t\t\t     declaringClass->getClassLoader ());\n+\t\t\t     declaringClass->getClassLoaderInternal ());\n }\n \n void\n@@ -218,7 +237,7 @@ _Jv_GetTypesFromSignature (jmethodID method,\n {\n \n   _Jv_Utf8Const* sig = method->signature;\n-  java::lang::ClassLoader *loader = declaringClass->getClassLoader();\n+  java::lang::ClassLoader *loader = declaringClass->getClassLoaderInternal();\n   char *ptr = sig->data;\n   int numArgs = 0;\n   /* First just count the number of parameters. */\n@@ -344,19 +363,11 @@ _Jv_CallAnyMethodA (jobject obj,\n \n   jclass *paramelts = elements (parameter_types);\n \n-  // FIXME: at some point the compiler is going to add extra arguments\n-  // to some functions.  In particular we are going to do this for\n-  // handling access checks in reflection.  We must add these hidden\n-  // arguments here.\n-\n   // Special case for the `this' argument of a constructor.  Note that\n   // the JDK 1.2 docs specify that the new object must be allocated\n   // before argument conversions are done.\n   if (is_constructor)\n-    {\n-      // FIXME: must special-case String, arrays, maybe others here.\n-      obj = JvAllocObject (return_type);\n-    }\n+    obj = JvAllocObject (return_type);\n \n   const int size_per_arg = sizeof(jvalue);\n   ffi_cif cif;\n@@ -488,8 +499,6 @@ _Jv_CallAnyMethodA (jobject obj,\n \t\t    JArray<jclass> *parameter_types,\n \t\t    jobjectArray args)\n {\n-  // FIXME: access checks.\n-\n   if (parameter_types->length == 0 && args == NULL)\n     {\n       // The JDK accepts this, so we do too."}, {"sha": "eace628acfccec5ea7539d1035477098834bd8be", "filename": "libjava/jni.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -491,7 +491,7 @@ static jclass\n \n       java::lang::ClassLoader *loader = NULL;\n       if (env->klass != NULL)\n-\tloader = env->klass->getClassLoader ();\n+\tloader = env->klass->getClassLoaderInternal ();\n \n       if (loader == NULL)\n \t{\n@@ -1189,7 +1189,7 @@ static jfieldID\n \n       // FIXME: what if field_class == NULL?\n \n-      java::lang::ClassLoader *loader = clazz->getClassLoader ();\n+      java::lang::ClassLoader *loader = clazz->getClassLoaderInternal ();\n       while (clazz != NULL)\n \t{\n \t  // We acquire the class lock so that fields aren't resolved"}, {"sha": "9f8477334da769187fdeed4423f3789f3e26ed6c", "filename": "libjava/prims.cc", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -1,6 +1,6 @@\n // prims.cc - Code for core of runtime environment.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -1137,3 +1137,21 @@ _Jv_remJ (jlong dividend, jlong divisor)\n \n   return dividend % divisor;\n }\n+\n+\f\n+\n+// Return true if SELF_KLASS can access a field or method in\n+// OTHER_KLASS.  The field or method's access flags are specified in\n+// FLAGS.\n+jboolean\n+_Jv_CheckAccess (jclass self_klass, jclass other_klass, jint flags)\n+{\n+  using namespace java::lang::reflect;\n+  return ((self_klass == other_klass)\n+\t  || ((flags & Modifier::PUBLIC) != 0)\n+\t  || (((flags & Modifier::PROTECTED) != 0)\n+\t      && other_klass->isAssignableFrom (self_klass))\n+\t  || (((flags & Modifier::PRIVATE) == 0)\n+\t      && _Jv_ClassNameSamePackage (self_klass->name,\n+\t\t\t\t\t   other_klass->name)));\n+}"}, {"sha": "d79affea9ebc3f8cad80906b785e8019f9d0ed01", "filename": "libjava/resolve.cc", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd94572f43f8b2a3697c9718c34ac3275a48262/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=ffd94572f43f8b2a3697c9718c34ac3275a48262", "patch": "@@ -166,15 +166,7 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \t      if (! _Jv_equalUtf8Consts (field->name, field_name))\n \t\tcontinue;\n \n-\t      // now, check field access. \n-\n-\t      if (   (cls == klass)\n-\t\t  || ((field->flags & Modifier::PUBLIC) != 0)\n-\t\t  || (((field->flags & Modifier::PROTECTED) != 0)\n-\t\t      && cls->isAssignableFrom (klass))\n-\t\t  || (((field->flags & Modifier::PRIVATE) == 0)\n-\t\t      && _Jv_ClassNameSamePackage (cls->name,\n-\t\t\t\t\t\t   klass->name)))\n+\t      if (_Jv_CheckAccess (klass, cls, field->flags))\n \t\t{\n \t\t  /* resove the field using the class' own loader\n \t\t     if necessary */\n@@ -347,20 +339,10 @@ _Jv_SearchMethodInClass (jclass cls, jclass klass,\n \t\t\t\t    method_signature)))\n \tcontinue;\n \n-      if (cls == klass \n-\t  || ((method->accflags & Modifier::PUBLIC) != 0)\n-\t  || (((method->accflags & Modifier::PROTECTED) != 0)\n-\t      && cls->isAssignableFrom (klass))\n-\t  || (((method->accflags & Modifier::PRIVATE) == 0)\n-\t      && _Jv_ClassNameSamePackage (cls->name,\n-\t\t\t\t\t   klass->name)))\n-\t{\n-\t  return method;\n-\t}\n+      if (_Jv_CheckAccess (klass, cls, method->accflags))\n+\treturn method;\n       else\n-\t{\n-\t  throw new java::lang::IllegalAccessError;\n-\t}\n+\tthrow new java::lang::IllegalAccessError;\n     }\n   return 0;\n }"}]}