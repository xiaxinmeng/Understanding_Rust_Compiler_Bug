{"sha": "fc893455a5c2c9238f077412cf5a0bdc29abed34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM4OTM0NTVhNWMyYzkyMzhmMDc3NDEyY2Y1YTBiZGMyOWFiZWQzNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T09:09:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T09:09:53Z"}, "message": "[multiple changes]\n\n2011-08-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* layout.adb (Layout_Type): For composite types, do not set Esize.\n\t* freeze.adb (Set_Small_Size): Remove test on alignment and do not\n\tset Esize.\n\t(Size_Known): Look at the RM size of components instead of the Esize.\n\t(Freeze_Record_Type): Look at the RM size instead of the Esize to\n\tissue warning and activate Implicit_Packing.\n\t(Freeze_Entity): Likewise.  Do not issue a warning for alias/atomic\n\tif the Esize is not known.\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause) <Size>: Set Esize\n\tfor elementary types only.\n\t(Analyze_Record_Representation_Clause): Look at the RM size instead\n\tof the Esize to issue errors.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not set Esize if it\n\tis not known.\n\t<E_Record_Type>: Look at the RM size instead of the Esize.  Remove\n\tobsolete block.  \n\tLook at the RM size instead of the Esize for types if the latter is\n\tnot known.\n\t(gnat_to_gnu_field): Use Known_Esize instead of Known_Static_Esize.\n\n2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_type.adb: proper handling of equality not involving anonymous\n\taccess types.\n\nFrom-SVN: r177339", "tree": {"sha": "2828113a0adb99fba99fd5be023a012fe6df3036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2828113a0adb99fba99fd5be023a012fe6df3036"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc893455a5c2c9238f077412cf5a0bdc29abed34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc893455a5c2c9238f077412cf5a0bdc29abed34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc893455a5c2c9238f077412cf5a0bdc29abed34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc893455a5c2c9238f077412cf5a0bdc29abed34/comments", "author": null, "committer": null, "parents": [{"sha": "b37d5bc62b96ecbd96f409281f8741d40c4d3922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b37d5bc62b96ecbd96f409281f8741d40c4d3922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b37d5bc62b96ecbd96f409281f8741d40c4d3922"}], "stats": {"total": 195, "additions": 101, "deletions": 94}, "files": [{"sha": "019f5a25bc2efcd0ad39aa76a060af542371c250", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fc893455a5c2c9238f077412cf5a0bdc29abed34", "patch": "@@ -1,3 +1,30 @@\n+2011-08-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* layout.adb (Layout_Type): For composite types, do not set Esize.\n+\t* freeze.adb (Set_Small_Size): Remove test on alignment and do not\n+\tset Esize.\n+\t(Size_Known): Look at the RM size of components instead of the Esize.\n+\t(Freeze_Record_Type): Look at the RM size instead of the Esize to\n+\tissue warning and activate Implicit_Packing.\n+\t(Freeze_Entity): Likewise.  Do not issue a warning for alias/atomic\n+\tif the Esize is not known.\n+\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause) <Size>: Set Esize\n+\tfor elementary types only.\n+\t(Analyze_Record_Representation_Clause): Look at the RM size instead\n+\tof the Esize to issue errors.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not set Esize if it\n+\tis not known.\n+\t<E_Record_Type>: Look at the RM size instead of the Esize.  Remove\n+\tobsolete block.  \n+\tLook at the RM size instead of the Esize for types if the latter is\n+\tnot known.\n+\t(gnat_to_gnu_field): Use Known_Esize instead of Known_Static_Esize.\n+\n+2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_type.adb: proper handling of equality not involving anonymous\n+\taccess types.\n+\n 2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch7.adb (Create_Finalizer): Remove local variables Spec_Nod and"}, {"sha": "a31e6476434a7a4117d8f92859a04b81e03dcfc7", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=fc893455a5c2c9238f077412cf5a0bdc29abed34", "patch": "@@ -623,13 +623,6 @@ package body Freeze is\n          if S > 32 then\n             return;\n \n-         --  Don't bother if alignment clause with a value other than 1 is\n-         --  present, because size may be padded up to meet back end alignment\n-         --  requirements, and only the back end knows the rules!\n-\n-         elsif Known_Alignment (T) and then Alignment (T) /= 1 then\n-            return;\n-\n          --  Check for bad size clause given\n \n          elsif Has_Size_Clause (T) then\n@@ -638,21 +631,12 @@ package body Freeze is\n                Error_Msg_NE\n                  (\"size for& too small, minimum allowed is ^\",\n                   Size_Clause (T), T);\n-\n-            elsif Unknown_Esize (T) then\n-               Set_Esize (T, S);\n             end if;\n \n-         --  Set sizes if not set already\n-\n-         else\n-            if Unknown_Esize (T) then\n-               Set_Esize (T, S);\n-            end if;\n+         --  Set size if not set already\n \n-            if Unknown_RM_Size (T) then\n-               Set_RM_Size (T, S);\n-            end if;\n+         elsif Unknown_RM_Size (T) then\n+            Set_RM_Size (T, S);\n          end if;\n       end Set_Small_Size;\n \n@@ -836,7 +820,7 @@ package body Freeze is\n                   if not Is_Constrained (T)\n                     and then\n                       No (Discriminant_Default_Value (First_Discriminant (T)))\n-                    and then Unknown_Esize (T)\n+                    and then Unknown_RM_Size (T)\n                   then\n                      return False;\n                   end if;\n@@ -2251,12 +2235,12 @@ package body Freeze is\n            --  less than the sum of the object sizes (no point in packing if\n            --  this is not the case).\n \n-           and then Esize (Rec) < Scalar_Component_Total_Esize\n+           and then RM_Size (Rec) < Scalar_Component_Total_Esize\n \n            --  And the total RM size cannot be greater than the specified size\n            --  since otherwise packing will not get us where we have to be!\n \n-           and then Esize (Rec) >= Scalar_Component_Total_RM_Size\n+           and then RM_Size (Rec) >= Scalar_Component_Total_RM_Size\n \n            --  Never do implicit packing in CodePeer mode since we don't do\n            --  any packing in this mode, since this generates over-complex\n@@ -3034,12 +3018,12 @@ package body Freeze is\n                   --  action that causes stuff to be inherited).\n \n                   if Present (Size_Clause (E))\n-                    and then Known_Static_Esize (E)\n+                    and then Known_Static_RM_Size (E)\n                     and then not Is_Packed (E)\n                     and then not Has_Pragma_Pack (E)\n                     and then Number_Dimensions (E) = 1\n                     and then not Has_Component_Size_Clause (E)\n-                    and then Known_Static_Esize (Ctyp)\n+                    and then Known_Static_RM_Size (Ctyp)\n                     and then not Is_Limited_Composite (E)\n                     and then not Is_Packed (Root_Type (E))\n                     and then not Has_Component_Size_Clause (Root_Type (E))\n@@ -3412,12 +3396,18 @@ package body Freeze is\n                      --  Start of processing for Alias_Atomic_Check\n \n                      begin\n+\n+                        --  If object size of component type isn't known, we\n+                        --  cannot be sure so we defer to the back end.\n+\n+                        if not Known_Static_Esize (Ctyp) then\n+                           null;\n+\n                         --  Case where component size has no effect. First\n-                        --  check for object size of component type known\n-                        --  and a multiple of the storage unit size.\n+                        --  check for object size of component type multiple\n+                        --  of the storage unit size.\n \n-                        if Known_Static_Esize (Ctyp)\n-                          and then Esize (Ctyp) mod System_Storage_Unit = 0\n+                        elsif Esize (Ctyp) mod System_Storage_Unit = 0\n \n                           --  OK in both packing case and component size case\n                           --  if RM size is known and static and the same as"}, {"sha": "512c05ecb158a833345da1000fe82e9d9166686b", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=fc893455a5c2c9238f077412cf5a0bdc29abed34", "patch": "@@ -406,8 +406,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  if (esize > max_esize)\n \t   esize = max_esize;\n \t}\n-      else\n-\tesize = LONG_LONG_TYPE_SIZE;\n     }\n \n   switch (kind)\n@@ -2773,7 +2771,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      ? -1\n \t      : (Known_Alignment (gnat_entity)\n \t\t || (Strict_Alignment (gnat_entity)\n-\t\t     && Known_Static_Esize (gnat_entity)))\n+\t\t     && Known_RM_Size (gnat_entity)))\n \t\t? -2\n \t\t: 0;\n \tbool has_discr = Has_Discriminants (gnat_entity);\n@@ -2824,8 +2822,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* If both a size and rep clause was specified, put the size in\n \t   the record type now so that it can get the proper mode.  */\n-\tif (has_rep && Known_Esize (gnat_entity))\n-\t  TYPE_SIZE (gnu_type) = UI_To_gnu (Esize (gnat_entity), sizetype);\n+\tif (has_rep && Known_RM_Size (gnat_entity))\n+\t  TYPE_SIZE (gnu_type)\n+\t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n \n \t/* Always set the alignment here so that it can be used to\n \t   set the mode, if it is making the alignment stricter.  If\n@@ -2842,9 +2841,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   type size instead of the RM size (see validate_size).  Cap the\n \t   alignment, lest it causes this type size to become too large.  */\n \telse if (Strict_Alignment (gnat_entity)\n-\t\t && Known_Static_Esize (gnat_entity))\n+\t\t && Known_RM_Size (gnat_entity))\n \t  {\n-\t    unsigned int raw_size = UI_To_Int (Esize (gnat_entity));\n+\t    unsigned int raw_size = UI_To_Int (RM_Size (gnat_entity));\n \t    unsigned int raw_align = raw_size & -raw_size;\n \t    if (raw_align < BIGGEST_ALIGNMENT)\n \t      TYPE_ALIGN (gnu_type) = raw_align;\n@@ -4583,9 +4582,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t confirming or we don't handle it properly (if the low bound is\n \t non-constant).  */\n       if (!gnu_size && kind != E_String_Literal_Subtype)\n-\tgnu_size = validate_size (Esize (gnat_entity), gnu_type, gnat_entity,\n-\t\t\t\t  TYPE_DECL, false,\n-\t\t\t\t  Has_Size_Clause (gnat_entity));\n+\t{\n+\t  Uint gnat_size = Known_Esize (gnat_entity)\n+\t\t\t   ? Esize (gnat_entity) : RM_Size (gnat_entity);\n+\t  gnu_size\n+\t    = validate_size (gnat_size, gnu_type, gnat_entity, TYPE_DECL,\n+\t\t\t     false, Has_Size_Clause (gnat_entity));\n+\t}\n \n       /* If a size was specified, see if we can make a new type of that size\n \t by rearranging the type, for example from a fat to a thin pointer.  */\n@@ -6771,7 +6774,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   /* If a size is specified, use it.  Otherwise, if the record type is packed,\n      use the official RM size.  See \"Handling of Type'Size Values\" in Einfo\n      for further details.  */\n-  if (Known_Static_Esize (gnat_field))\n+  if (Known_Esize (gnat_field))\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n \t\t\t      gnat_field, FIELD_DECL, false, true);\n   else if (packed == 1)"}, {"sha": "bb8aa113211759b21285e5a1959c91134acc8441", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=fc893455a5c2c9238f077412cf5a0bdc29abed34", "patch": "@@ -2574,27 +2574,11 @@ package body Layout is\n             end;\n          end if;\n \n-         --  If RM_Size is known, set Esize if not known\n-\n-         if Known_RM_Size (E) and then Unknown_Esize (E) then\n-\n-            --  If the alignment is known, we bump the Esize up to the next\n-            --  alignment boundary if it is not already on one.\n-\n-            if Known_Alignment (E) then\n-               declare\n-                  A : constant Uint   := Alignment_In_Bits (E);\n-                  S : constant SO_Ref := RM_Size (E);\n-               begin\n-                  Set_Esize (E, (S + A - 1) / A * A);\n-               end;\n-            end if;\n-\n          --  If Esize is set, and RM_Size is not, RM_Size is copied from Esize.\n          --  At least for now this seems reasonable, and is in any case needed\n          --  for compatibility with old versions of gigi.\n \n-         elsif Known_Esize (E) and then Unknown_RM_Size (E) then\n+         if Known_Esize (E) and then Unknown_RM_Size (E) then\n             Set_RM_Size (E, Esize (E));\n          end if;\n "}, {"sha": "c3816cc577a68c58644b9a12ff199c86336932c4", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=fc893455a5c2c9238f077412cf5a0bdc29abed34", "patch": "@@ -2348,11 +2348,15 @@ package body Sem_Ch13 is\n                if Is_Type (U_Ent) then\n                   Set_RM_Size (U_Ent, Size);\n \n-                  --  For scalar types, increase Object_Size to power of 2, but\n-                  --  not less than a storage unit in any case (i.e., normally\n+                  --  For elementary types, increase Object_Size to power of 2,\n+                  --  but not less than a storage unit in any case (normally\n                   --  this means it will be byte addressable).\n \n-                  if Is_Scalar_Type (U_Ent) then\n+                  --  For all other types, nothing else to do, we leave Esize\n+                  --  (object size) unset, the back end will set it from the\n+                  --  size and alignment in an appropriate manner.\n+\n+                  if Is_Elementary_Type (U_Ent) then\n                      if Size <= System_Storage_Unit then\n                         Init_Esize (U_Ent, System_Storage_Unit);\n                      elsif Size <= 16 then\n@@ -2363,15 +2367,9 @@ package body Sem_Ch13 is\n                         Set_Esize  (U_Ent, (Size + 63) / 64 * 64);\n                      end if;\n \n-                  --  For all other types, object size = value size. The\n-                  --  backend will adjust as needed.\n-\n-                  else\n-                     Set_Esize (U_Ent, Size);\n+                     Alignment_Check_For_Esize_Change (U_Ent);\n                   end if;\n \n-                  Alignment_Check_For_Esize_Change (U_Ent);\n-\n                --  For objects, set Esize only\n \n                else\n@@ -3591,7 +3589,7 @@ package body Sem_Ch13 is\n                      Lbit := Lbit + UI_From_Int (SSU) * Posit;\n \n                      if Has_Size_Clause (Rectype)\n-                       and then Esize (Rectype) <= Lbit\n+                       and then RM_Size (Rectype) <= Lbit\n                      then\n                         Error_Msg_N\n                           (\"bit number out of range of specified size\",\n@@ -6008,7 +6006,7 @@ package body Sem_Ch13 is\n             --  Check bit position out of range of specified size\n \n             if Has_Size_Clause (Rectype)\n-              and then Esize (Rectype) <= Lbit\n+              and then RM_Size (Rectype) <= Lbit\n             then\n                Error_Msg_N\n                  (\"bit number out of range of specified size\","}, {"sha": "4e2a0de9ed68850fb71ff3e1c74c20888bb8ac7b", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc893455a5c2c9238f077412cf5a0bdc29abed34/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=fc893455a5c2c9238f077412cf5a0bdc29abed34", "patch": "@@ -1206,6 +1206,10 @@ package body Sem_Type is\n       --  Look for exact type match in an instance, to remove spurious\n       --  ambiguities when two formal types have the same actual.\n \n+      function Operand_Type return Entity_Id;\n+      --  Determine type of operand for an equality operation, to apply\n+      --  Ada2005 rules to equality on anonymous access types.\n+\n       function Standard_Operator return Boolean;\n       --  Check whether subprogram is predefined operator declared in Standard.\n       --  It may given by an operator name, or by an expanded name whose prefix\n@@ -1277,6 +1281,22 @@ package body Sem_Type is\n                and then (T1 = Universal_Real or else T1 = Universal_Integer));\n       end Matches;\n \n+      ------------------\n+      -- Operand_Type --\n+      ------------------\n+\n+      function Operand_Type return Entity_Id is\n+         Opnd : Node_Id;\n+      begin\n+         if Nkind (N) = N_Function_Call then\n+            Opnd := First_Actual (N);\n+         else\n+            Opnd := Left_Opnd (N);\n+         end if;\n+         return Etype (Opnd);\n+\n+      end Operand_Type;\n+\n       ------------------------\n       -- Remove_Conversions --\n       ------------------------\n@@ -1907,35 +1927,20 @@ package body Sem_Type is\n             --  may be an operator or a function call.\n \n             elsif (Chars (Nam1) = Name_Op_Eq\n-                     or else\n-                   Chars (Nam1) = Name_Op_Ne)\n+                  or else\n+                Chars (Nam1) = Name_Op_Ne)\n               and then Ada_Version >= Ada_2005\n               and then Etype (User_Subp) = Standard_Boolean\n-            then\n-               declare\n-                  Opnd : Node_Id;\n-\n-               begin\n-                  if Nkind (N) = N_Function_Call then\n-                     Opnd := First_Actual (N);\n-                  else\n-                     Opnd := Left_Opnd (N);\n-                  end if;\n-\n-                  if Ekind (Etype (Opnd)) = E_Anonymous_Access_Type\n-                    and then\n-                      In_Same_List (Parent (Designated_Type (Etype (Opnd))),\n+              and then Ekind (Operand_Type) = E_Anonymous_Access_Type\n+              and then\n+                In_Same_List (Parent (Designated_Type (Operand_Type)),\n                                     Unit_Declaration_Node (User_Subp))\n-                  then\n-                     if It2.Nam = Predef_Subp then\n-                        return It1;\n-                     else\n-                        return It2;\n-                     end if;\n-                  else\n-                     return Remove_Conversions;\n-                  end if;\n-               end;\n+            then\n+               if It2.Nam = Predef_Subp then\n+                  return It1;\n+               else\n+                  return It2;\n+               end if;\n \n             --  An immediately visible operator hides a use-visible user-\n             --  defined operation. This disambiguation cannot take place"}]}