{"sha": "f08ac361ee42e760b09453404da81d76a62a68b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA4YWMzNjFlZTQyZTc2MGIwOTQ1MzQwNGRhODFkNzZhNjJhNjhiMA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-03-29T01:41:27Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-03-29T01:41:27Z"}, "message": "re PR tree-optimization/25985 (with optimization integer math fails)\n\n\tPR tree-optimization/25985\n\t* tree-ssa-loop-niter.c (number_of_iterations_le,\n\tnumber_of_iterations_ne): Make comments more precise.\n\t(number_of_iterations_cond): Add only_exit argument.  Use the\n\tfact that signed variables do not overflow only when only_exit\n\tis true.\n\t(loop_only_exit_p): New.\n\t(number_of_iterations_exit): Pass result of loop_only_exit_p to\n\tnumber_of_iterations_cond.\n\nFrom-SVN: r112484", "tree": {"sha": "ddd8f490c83229661d06186dfdefb87819a3a9fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddd8f490c83229661d06186dfdefb87819a3a9fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f08ac361ee42e760b09453404da81d76a62a68b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08ac361ee42e760b09453404da81d76a62a68b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f08ac361ee42e760b09453404da81d76a62a68b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08ac361ee42e760b09453404da81d76a62a68b0/comments", "author": null, "committer": null, "parents": [{"sha": "dd79d394de1e40e40a64f6661b50043058c5a45e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd79d394de1e40e40a64f6661b50043058c5a45e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd79d394de1e40e40a64f6661b50043058c5a45e"}], "stats": {"total": 83, "additions": 75, "deletions": 8}, "files": [{"sha": "c9be20c4a451326a5b24b5b040c93a80f9bbc32d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08ac361ee42e760b09453404da81d76a62a68b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08ac361ee42e760b09453404da81d76a62a68b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f08ac361ee42e760b09453404da81d76a62a68b0", "patch": "@@ -1,3 +1,15 @@\n+2006-03-28  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/25985\n+\t* tree-ssa-loop-niter.c (number_of_iterations_le,\n+\tnumber_of_iterations_ne): Make comments more precise.\n+\t(number_of_iterations_cond): Add only_exit argument.  Use the\n+\tfact that signed variables do not overflow only when only_exit\n+\tis true.\n+\t(loop_only_exit_p): New.\n+\t(number_of_iterations_exit): Pass result of loop_only_exit_p to\n+\tnumber_of_iterations_cond.\n+\n 2006-03-28  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/26643"}, {"sha": "f7319b2a425e2a6fac3b59cdeacd7b5ec0e6e4c0", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08ac361ee42e760b09453404da81d76a62a68b0/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08ac361ee42e760b09453404da81d76a62a68b0/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=f08ac361ee42e760b09453404da81d76a62a68b0", "patch": "@@ -129,9 +129,9 @@ inverse (tree x, tree mask)\n /* Determines number of iterations of loop whose ending condition\n    is IV <> FINAL.  TYPE is the type of the iv.  The number of\n    iterations is stored to NITER.  NEVER_INFINITE is true if\n-   we know that the loop cannot be infinite (we derived this\n-   earlier, and possibly set NITER->assumptions to make sure this\n-   is the case.  */\n+   we know that the exit must be taken eventually, i.e., that the IV\n+   ever reaches the value FINAL (we derived this earlier, and possibly set\n+   NITER->assumptions to make sure this is the case).  */\n \n static bool\n number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n@@ -492,9 +492,9 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n /* Determines number of iterations of loop whose ending condition\n    is IV0 <= IV1.  TYPE is the type of the iv.  The number of\n    iterations is stored to NITER.  NEVER_INFINITE is true if\n-   we know that the loop cannot be infinite (we derived this\n+   we know that this condition must eventually become false (we derived this\n    earlier, and possibly set NITER->assumptions to make sure this\n-   is the case.  */\n+   is the case).  */\n \n static bool\n number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n@@ -538,6 +538,11 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n    is IV0, the right-hand side is IV1.  Both induction variables must have\n    type TYPE, which must be an integer or pointer type.  The steps of the\n    ivs must be constants (or NULL_TREE, which is interpreted as constant zero).\n+\n+   ONLY_EXIT is true if we are sure this is the only way the loop could be\n+   exited (including possibly non-returning function calls, exceptions, etc.)\n+   -- in this case we can use the information whether the control induction\n+   variables can overflow or not in a more efficient way.\n    \n    The results (number of iterations and assumptions as described in\n    comments at struct tree_niter_desc in tree-flow.h) are stored to NITER.\n@@ -546,7 +551,8 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n \n static bool\n number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n-\t\t\t   affine_iv *iv1, struct tree_niter_desc *niter)\n+\t\t\t   affine_iv *iv1, struct tree_niter_desc *niter,\n+\t\t\t   bool only_exit)\n {\n   bool never_infinite;\n \n@@ -572,13 +578,30 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n       code = swap_tree_comparison (code);\n     }\n \n+  if (!only_exit)\n+    {\n+      /* If this is not the only possible exit from the loop, the information\n+\t that the induction variables cannot overflow as derived from\n+\t signedness analysis cannot be relied upon.  We use them e.g. in the\n+\t following way:  given loop for (i = 0; i <= n; i++), if i is\n+\t signed, it cannot overflow, thus this loop is equivalent to\n+\t for (i = 0; i < n + 1; i++);  however, if n == MAX, but the loop\n+\t is exited in some other way before i overflows, this transformation\n+\t is incorrect (the new loop exits immediately).  */\n+      iv0->no_overflow = false;\n+      iv1->no_overflow = false;\n+    }\n+\n   if (POINTER_TYPE_P (type))\n     {\n       /* Comparison of pointers is undefined unless both iv0 and iv1 point\n \t to the same object.  If they do, the control variable cannot wrap\n \t (as wrap around the bounds of memory will never return a pointer\n \t that would be guaranteed to point to the same object, even if we\n-\t avoid undefined behavior by casting to size_t and back).  */\n+\t avoid undefined behavior by casting to size_t and back).  The\n+\t restrictions on pointer arithmetics and comparisons of pointers\n+\t ensure that using the no-overflow assumptions is correct in this\n+\t case even if ONLY_EXIT is false.  */\n       iv0->no_overflow = true;\n       iv1->no_overflow = true;\n     }\n@@ -963,6 +986,37 @@ simplify_using_outer_evolutions (struct loop *loop, tree expr)\n   return expr;\n }\n \n+/* Returns true if EXIT is the only possible exit from LOOP.  */\n+\n+static bool\n+loop_only_exit_p (struct loop *loop, edge exit)\n+{\n+  basic_block *body;\n+  block_stmt_iterator bsi;\n+  unsigned i;\n+  tree call;\n+\n+  if (exit != loop->single_exit)\n+    return false;\n+\n+  body = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      for (bsi = bsi_start (body[0]); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  call = get_call_expr_in (bsi_stmt (bsi));\n+\t  if (call && TREE_SIDE_EFFECTS (call))\n+\t    {\n+\t      free (body);\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  free (body);\n+  return true;\n+}\n+\n /* Stores description of number of iterations of LOOP derived from\n    EXIT (an exit edge of the LOOP) in NITER.  Returns true if some\n    useful information could be derived (and fields of NITER has\n@@ -1023,7 +1077,8 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n \n   iv0.base = expand_simple_operations (iv0.base);\n   iv1.base = expand_simple_operations (iv1.base);\n-  if (!number_of_iterations_cond (type, &iv0, code, &iv1, niter))\n+  if (!number_of_iterations_cond (type, &iv0, code, &iv1, niter,\n+\t\t\t\t  loop_only_exit_p (loop, exit)))\n     return false;\n \n   if (optimize >= 3)"}]}