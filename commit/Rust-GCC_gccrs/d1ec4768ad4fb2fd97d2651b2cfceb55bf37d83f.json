{"sha": "d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFlYzQ3NjhhZDRmYjJmZDk3ZDI2NTFiMmNmY2ViNTViZjM3ZDgzZg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-04-25T10:33:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:33:23Z"}, "message": "sem_ch12.adb, [...]: Minor reformatting.\n\n2013-04-25  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch12.adb, sem_util.adb, sem_ch4.adb: Minor reformatting.\n\nFrom-SVN: r198289", "tree": {"sha": "c796434f7cdfadc6f0deb0f5b51cd58fd484c78b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c796434f7cdfadc6f0deb0f5b51cd58fd484c78b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/comments", "author": null, "committer": null, "parents": [{"sha": "5708155960d0abd5f30e12e9477f946c60da43c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5708155960d0abd5f30e12e9477f946c60da43c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5708155960d0abd5f30e12e9477f946c60da43c8"}], "stats": {"total": 170, "additions": 88, "deletions": 82}, "files": [{"sha": "fcd2915fad26488cc7656e1a29b0b0b24fe1c46f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "patch": "@@ -1,3 +1,7 @@\n+2013-04-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch12.adb, sem_util.adb, sem_ch4.adb: Minor reformatting.\n+\n 2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch4.adb (Analyze_Quantified_Expression):"}, {"sha": "98d45f833780feb1419012d71e43fb665eb427db", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "patch": "@@ -5467,13 +5467,13 @@ package body Sem_Ch12 is\n       --  For a formal that is an array type, the component type is often a\n       --  previous formal in the same unit. The privacy status of the component\n       --  type will have been examined earlier in the traversal of the\n-      --  corresponding actuals, and this status should not be modified for the\n-      --  array (sub)type itself. However, if the base type of the array\n+      --  corresponding actuals, and this status should not be modified for\n+      --  the array (sub)type itself. However, if the base type of the array\n       --  (sub)type is private, its full view must be restored in the body to\n       --  be consistent with subsequent index subtypes, etc.\n       --\n-      --  To detect this case we have to rescan the list of formals, which\n-      --  is usually short enough to ignore the resulting inefficiency.\n+      --  To detect this case we have to rescan the list of formals, which is\n+      --  usually short enough to ignore the resulting inefficiency.\n \n       -----------------------------\n       -- Denotes_Previous_Actual --\n@@ -5552,8 +5552,8 @@ package body Sem_Ch12 is\n             if Is_Discrete_Or_Fixed_Point_Type (E) then\n                Set_RM_Size (E, RM_Size (Astype));\n \n-            --  In  nested instances, the base type of an access actual\n-            --  may itself be private, and need to be exchanged.\n+            --  In nested instances, the base type of an access actual may\n+            --  itself be private, and need to be exchanged.\n \n             elsif Is_Access_Type (E)\n               and then Is_Private_Type (Etype (E))\n@@ -5655,9 +5655,9 @@ package body Sem_Ch12 is\n                then\n                   Switch_View (Typ);\n \n-                  --  If the type of the entity is a subtype, it may also\n-                  --  have to be made visible, together with the base type\n-                  --  of its full view, after exchange.\n+                  --  If the type of the entity is a subtype, it may also have\n+                  --  to be made visible, together with the base type of its\n+                  --  full view, after exchange.\n \n                   if Is_Private_Type (Etype (E)) then\n                      Switch_View (Etype (E));\n@@ -5691,8 +5691,8 @@ package body Sem_Ch12 is\n       --  Search generic parent for possible child unit with the given name\n \n       function In_Enclosing_Instance return Boolean;\n-      --  Within an instance of the parent, the child unit may be denoted\n-      --  by a simple name, or an abbreviated expanded name. Examine enclosing\n+      --  Within an instance of the parent, the child unit may be denoted by\n+      --  a simple name, or an abbreviated expanded name. Examine enclosing\n       --  scopes to locate a possible parent instantiation.\n \n       ------------------------\n@@ -5909,10 +5909,10 @@ package body Sem_Ch12 is\n                elsif In_Open_Scopes (Inst_Par) then\n \n                   --  If the parent is already installed, install the actuals\n-                  --  for its formal packages. This is necessary when the\n-                  --  child instance is a child of the parent instance:\n-                  --  in this case, the parent is placed on the scope stack\n-                  --  but the formal packages are not made visible.\n+                  --  for its formal packages. This is necessary when the child\n+                  --  instance is a child of the parent instance: in this case,\n+                  --  the parent is placed on the scope stack but the formal\n+                  --  packages are not made visible.\n \n                   Install_Formal_Packages (Inst_Par);\n                end if;\n@@ -6144,9 +6144,9 @@ package body Sem_Ch12 is\n \n             --  The normal exchange mechanism relies on the setting of a\n             --  flag on the reference in the generic. However, an additional\n-            --  mechanism is needed for types that are not explicitly mentioned\n-            --  in the generic, but may be needed in expanded code in the\n-            --  instance. This includes component types of arrays and\n+            --  mechanism is needed for types that are not explicitly\n+            --  mentioned in the generic, but may be needed in expanded code\n+            --  in the instance. This includes component types of arrays and\n             --  designated types of access types. This processing must also\n             --  include the index types of arrays which we take care of here.\n \n@@ -6328,10 +6328,10 @@ package body Sem_Ch12 is\n       New_N : Node_Id;\n \n       function Copy_Generic_Descendant (D : Union_Id) return Union_Id;\n-      --  Check the given value of one of the Fields referenced by the\n-      --  current node to determine whether to copy it recursively. The\n-      --  field may hold a Node_Id, a List_Id, or an Elist_Id, or a plain\n-      --  value (Sloc, Uint, Char) in which case it need not be copied.\n+      --  Check the given value of one of the Fields referenced by the current\n+      --  node to determine whether to copy it recursively. The field may hold\n+      --  a Node_Id, a List_Id, or an Elist_Id, or a plain value (Sloc, Uint,\n+      --  Char) in which case it need not be copied.\n \n       procedure Copy_Descendants;\n       --  Common utility for various nodes\n@@ -6345,10 +6345,10 @@ package body Sem_Ch12 is\n       --  Apply Copy_Node recursively to the members of a node list\n \n       function In_Defining_Unit_Name (Nam : Node_Id) return Boolean;\n-      --  True if an identifier is part of the defining program unit name\n-      --  of a child unit. The entity of such an identifier must be kept\n-      --  (for ASIS use) even though as the name of an enclosing generic\n-      --   it would otherwise not be preserved in the generic tree.\n+      --  True if an identifier is part of the defining program unit name of\n+      --  a child unit. The entity of such an identifier must be kept (for\n+      --  ASIS use) even though as the name of an enclosing generic it would\n+      --  otherwise not be preserved in the generic tree.\n \n       ----------------------\n       -- Copy_Descendants --\n@@ -6508,19 +6508,20 @@ package body Sem_Ch12 is\n             Set_Associated_Node (N, New_N);\n \n             --  If we are within an instantiation, this is a nested generic\n-            --  that has already been analyzed at the point of definition. We\n-            --  must preserve references that were global to the enclosing\n+            --  that has already been analyzed at the point of definition.\n+            --  We must preserve references that were global to the enclosing\n             --  parent at that point. Other occurrences, whether global or\n             --  local to the current generic, must be resolved anew, so we\n             --  reset the entity in the generic copy. A global reference has a\n             --  smaller depth than the parent, or else the same depth in case\n             --  both are distinct compilation units.\n+\n             --  A child unit is implicitly declared within the enclosing parent\n             --  but is in fact global to it, and must be preserved.\n \n             --  It is also possible for Current_Instantiated_Parent to be\n-            --  defined, and for this not to be a nested generic, namely if the\n-            --  unit is loaded through Rtsfind. In that case, the entity of\n+            --  defined, and for this not to be a nested generic, namely if\n+            --  the unit is loaded through Rtsfind. In that case, the entity of\n             --  New_N is only a link to the associated node, and not a defining\n             --  occurrence.\n \n@@ -6561,11 +6562,11 @@ package body Sem_Ch12 is\n          --  Case of instantiating identifier or some other name or operator\n \n          else\n-            --  If the associated node is still defined, the entity in it is\n-            --  global, and must be copied to the instance. If this copy is\n-            --  being made for a body to inline, it is applied to an\n-            --  instantiated tree, and the entity is already present and must\n-            --  be also preserved.\n+            --  If the associated node is still defined, the entity in it\n+            --  is global, and must be copied to the instance. If this copy\n+            --  is being made for a body to inline, it is applied to an\n+            --  instantiated tree, and the entity is already present and\n+            --  must be also preserved.\n \n             declare\n                Assoc : constant Node_Id := Get_Associated_Node (N);\n@@ -6640,7 +6641,7 @@ package body Sem_Ch12 is\n          --  If we are not instantiating, then this is where we load and\n          --  analyze subunits, i.e. at the point where the stub occurs. A\n          --  more permissive system might defer this analysis to the point\n-         --  of instantiation, but this seems to complicated for now.\n+         --  of instantiation, but this seems too complicated for now.\n \n          if not Instantiating then\n             declare\n@@ -6665,8 +6666,8 @@ package body Sem_Ch12 is\n                Lib.Analysing_Subunit_Of_Main := False;\n \n                --  If the proper body is not found, a warning message will be\n-               --  emitted when analyzing the stub, or later at the point\n-               --  of instantiation. Here we just leave the stub as is.\n+               --  emitted when analyzing the stub, or later at the point of\n+               --  instantiation. Here we just leave the stub as is.\n \n                if Unum = No_Unit then\n                   Subunits_Missing := True;\n@@ -6904,7 +6905,6 @@ package body Sem_Ch12 is\n          begin\n             if Prag_Id = Pragma_Ident or else Prag_Id = Pragma_Comment then\n                New_N := Make_Null_Statement (Sloc (N));\n-\n             else\n                Copy_Descendants;\n             end if;\n@@ -7463,7 +7463,7 @@ package body Sem_Ch12 is\n               Corresponding_Spec (Proper_Body (Unit (Library_Unit (Enc_G))));\n          end if;\n \n-         --  Freeze package that encloses instance, and place node after\n+         --  Freeze package that encloses instance, and place node after the\n          --  package that encloses generic. If enclosing package is already\n          --  frozen we have to assume it is at the proper place. This may be a\n          --  potential ABE that requires dynamic checking. Do not add a freeze\n@@ -7882,9 +7882,9 @@ package body Sem_Ch12 is\n       Par_N : Node_Id;\n \n       function Enclosing_Body (N : Node_Id) return Node_Id;\n-      --  Find enclosing package or subprogram body, if any. Freeze node\n-      --  may be placed at end of current declarative list if previous\n-      --  instance and current one have different enclosing bodies.\n+      --  Find enclosing package or subprogram body, if any. Freeze node may\n+      --  be placed at end of current declarative list if previous instance\n+      --  and current one have different enclosing bodies.\n \n       function Previous_Instance (Gen : Entity_Id) return Entity_Id;\n       --  Find the local instance, if any, that declares the generic that is\n@@ -8393,8 +8393,8 @@ package body Sem_Ch12 is\n       --  Install the scopes of noninstance parent units ending with Par\n \n       procedure Install_Spec (Par : Entity_Id);\n-      --  The child unit is within the declarative part of the parent, so\n-      --  the declarations within the parent are immediately visible.\n+      --  The child unit is within the declarative part of the parent, so the\n+      --  declarations within the parent are immediately visible.\n \n       -------------------------------\n       -- Install_Noninstance_Specs --\n@@ -8421,10 +8421,10 @@ package body Sem_Ch12 is\n \n       begin\n          --  If this parent of the child instance is a top-level unit,\n-         --  then record the unit and its visibility for later resetting\n-         --  in Remove_Parent. We exclude units that are generic instances,\n-         --  as we only want to record this information for the ultimate\n-         --  top-level noninstance parent (is that always correct???).\n+         --  then record the unit and its visibility for later resetting in\n+         --  Remove_Parent. We exclude units that are generic instances, as we\n+         --  only want to record this information for the ultimate top-level\n+         --  noninstance parent (is that always correct???).\n \n          if Scope (Par) = Standard_Standard\n            and then not Is_Generic_Instance (Par)\n@@ -8698,15 +8698,15 @@ package body Sem_Ch12 is\n       procedure Find_Matching_Actual\n        (F    : Node_Id;\n         Act  : in out Entity_Id);\n-      --  We need to associate each formal entity in the formal package\n-      --  with the corresponding entity in the actual package. The actual\n-      --  package has been analyzed and possibly expanded, and as a result\n-      --  there is no one-to-one correspondence between the two lists (for\n-      --  example, the actual may include subtypes, itypes, and inherited\n-      --  primitive operations, interspersed among the renaming declarations\n-      --  for the actuals) . We retrieve the corresponding actual by name\n-      --  because each actual has the same name as the formal, and they do\n-      --  appear in the same order.\n+      --  We need to associate each formal entity in the formal package with\n+      --  the corresponding entity in the actual package. The actual package\n+      --  has been analyzed and possibly expanded, and as a result there is\n+      --  no one-to-one correspondence between the two lists (for example,\n+      --  the actual may include subtypes, itypes, and inherited primitive\n+      --  operations, interspersed among the renaming declarations for the\n+      --  actuals) . We retrieve the corresponding actual by name because each\n+      --  actual has the same name as the formal, and they do appear in the\n+      --  same order.\n \n       function Get_Formal_Entity (N : Node_Id) return Entity_Id;\n       --  Retrieve entity of defining entity of  generic formal parameter.\n@@ -8718,13 +8718,12 @@ package body Sem_Ch12 is\n         (Formal_Node : Node_Id;\n          Formal_Ent  : Entity_Id;\n          Actual_Ent  : Entity_Id);\n-      --  Associates the formal entity with the actual. In the case\n-      --  where Formal_Ent is a formal package, this procedure iterates\n-      --  through all of its formals and enters associations between the\n-      --  actuals occurring in the formal package's corresponding actual\n-      --  package (given by Actual_Ent) and the formal package's formal\n-      --  parameters. This procedure recurses if any of the parameters is\n-      --  itself a package.\n+      --  Associates the formal entity with the actual. In the case where\n+      --  Formal_Ent is a formal package, this procedure iterates through all\n+      --  of its formals and enters associations between the actuals occurring\n+      --  in the formal package's corresponding actual package (given by\n+      --  Actual_Ent) and the formal package's formal parameters. This\n+      --  procedure recurses if any of the parameters is itself a package.\n \n       function Is_Instance_Of\n         (Act_Spec : Entity_Id;\n@@ -9179,12 +9178,12 @@ package body Sem_Ch12 is\n \n       function From_Parent_Scope (Subp : Entity_Id) return Boolean;\n       --  If the generic is a child unit, the parent has been installed on the\n-      --  scope stack, but a default subprogram cannot resolve to something on\n-      --  the parent because that parent is not really part of the visible\n+      --  scope stack, but a default subprogram cannot resolve to something\n+      --  on the parent because that parent is not really part of the visible\n       --  context (it is there to resolve explicit local entities). If the\n-      --  default has resolved in this way, we remove the entity from\n-      --  immediate visibility and analyze the node again to emit an error\n-      --  message or find another visible candidate.\n+      --  default has resolved in this way, we remove the entity from immediate\n+      --  visibility and analyze the node again to emit an error message or\n+      --  find another visible candidate.\n \n       procedure Valid_Actual_Subprogram (Act : Node_Id);\n       --  Perform legality check and raise exception on failure\n@@ -9562,14 +9561,14 @@ package body Sem_Ch12 is\n          end if;\n \n          --  The actual has to be resolved in order to check that it is a\n-         --  variable (due to cases such as F (1), where F returns access to an\n-         --  array, and for overloaded prefixes).\n+         --  variable (due to cases such as F (1), where F returns access to\n+         --  an array, and for overloaded prefixes).\n \n          Ftyp := Get_Instance_Of (Etype (A_Gen_Obj));\n \n-         --  If the type of the formal is not itself a formal, and the\n-         --  current unit is a child unit, the formal type must be declared\n-         --  in a parent, and must be retrieved by visibility.\n+         --  If the type of the formal is not itself a formal, and the current\n+         --  unit is a child unit, the formal type must be declared in a\n+         --  parent, and must be retrieved by visibility.\n \n          if Ftyp = Orig_Ftyp\n            and then Is_Generic_Unit (Scope (Ftyp))"}, {"sha": "e4b5139b76c39f3ca6f2819f7d134b05822ad91f", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "patch": "@@ -3512,6 +3512,7 @@ package body Sem_Ch4 is\n \n       function Referenced (Id : Entity_Id; Expr : Node_Id) return Boolean;\n       --  Determine whether entity Id is referenced within expression Expr\n+      --  This should be moved to sem_util ???\n \n       --------------------\n       -- Is_Empty_Range --\n@@ -3575,6 +3576,10 @@ package body Sem_Ch4 is\n          --  Determine whether node N denotes a reference to Id. If this is the\n          --  case, set global flag Seen to True and stop the traversal.\n \n+         ------------------\n+         -- Is_Reference --\n+         ------------------\n+\n          function Is_Reference (N : Node_Id) return Traverse_Result is\n          begin\n             if Is_Entity_Name (N)\n@@ -3594,7 +3599,6 @@ package body Sem_Ch4 is\n \n       begin\n          Inspect_Expression (Expr);\n-\n          return Seen;\n       end Referenced;\n \n@@ -3662,10 +3666,10 @@ package body Sem_Ch4 is\n       end if;\n \n       --  Diagnose a possible misuse of the \"some\" existential quantifier. When\n-      --  we have a quantified expression of the form\n-      --\n+      --  we have a quantified expression of the form:\n+\n       --    for some X => (if P then Q [else True])\n-      --\n+\n       --  the if expression will not hold and render the quantified expression\n       --  trivially True.\n "}, {"sha": "dfbfa869216e33f0e9b61e43cc7f8b52c7889ad4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "patch": "@@ -2150,9 +2150,8 @@ package body Sem_Util is\n          States : constant Elist_Id := Abstract_States (Pkg);\n \n       begin\n-         --  Check the first available state of the related package. A null\n-         --  abstract state always appears as the sole element of the state\n-         --  list.\n+         --  Check first available state of related package. A null abstract\n+         --  state always appears as the sole element of the state list.\n \n          return\n            Present (States)"}]}