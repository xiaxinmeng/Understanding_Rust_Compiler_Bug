{"sha": "a42a906c420d7bb196cb8541e0ab65264a0b04b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQyYTkwNmM0MjBkN2JiMTk2Y2I4NTQxZTBhYjY1MjY0YTBiMDRiMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-12T23:13:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-12T23:13:29Z"}, "message": "libgo: Update to current master library sources.\n\nFrom-SVN: r194460", "tree": {"sha": "8c441679e35147b1e9bec048f733fc394fb0c161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c441679e35147b1e9bec048f733fc394fb0c161"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a42a906c420d7bb196cb8541e0ab65264a0b04b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42a906c420d7bb196cb8541e0ab65264a0b04b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a42a906c420d7bb196cb8541e0ab65264a0b04b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42a906c420d7bb196cb8541e0ab65264a0b04b0/comments", "author": null, "committer": null, "parents": [{"sha": "bc77608b97abcc4bb3171f08a71e34ae342e9f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc77608b97abcc4bb3171f08a71e34ae342e9f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc77608b97abcc4bb3171f08a71e34ae342e9f8d"}], "stats": {"total": 8155, "additions": 6240, "deletions": 1915}, "files": [{"sha": "deeb596317d39ef6f7acc4665883f11f158e29c8", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -1,4 +1,4 @@\n-a070de932857\n+c031aa767edf\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "fe0f20585fc520127bd7ca473216ccf927accc47", "filename": "libgo/Makefile.am", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -221,6 +221,7 @@ endif\n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n \n toolexeclibgoexp_DATA = \\\n+\texp/cookiejar.gox \\\n \texp/ebnf.gox \\\n \texp/html.gox \\\n \t$(exp_inotify_gox) \\\n@@ -251,6 +252,7 @@ toolexeclibgogo_DATA = \\\n \tgo/ast.gox \\\n \tgo/build.gox \\\n \tgo/doc.gox \\\n+\tgo/format.gox \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n@@ -1194,6 +1196,9 @@ go_encoding_xml_files = \\\n \tgo/encoding/xml/typeinfo.go \\\n \tgo/encoding/xml/xml.go\n \n+go_exp_cookiejar_files = \\\n+\tgo/exp/cookiejar/jar.go \\\n+\tgo/exp/cookiejar/storage.go\n go_exp_ebnf_files = \\\n \tgo/exp/ebnf/ebnf.go \\\n \tgo/exp/ebnf/parser.go\n@@ -1284,6 +1289,8 @@ go_go_doc_files = \\\n \tgo/go/doc/filter.go \\\n \tgo/go/doc/reader.go \\\n \tgo/go/doc/synopsis.go\n+go_go_format_files = \\\n+\tgo/go/format/format.go\n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n \tgo/go/parser/parser.go\n@@ -1384,6 +1391,7 @@ go_math_rand_files = \\\n go_mime_multipart_files = \\\n \tgo/mime/multipart/formdata.go \\\n \tgo/mime/multipart/multipart.go \\\n+\tgo/mime/multipart/quotedprintable.go \\\n \tgo/mime/multipart/writer.go\n \n go_net_http_files = \\\n@@ -1456,6 +1464,7 @@ go_os_signal_files = \\\n \n go_os_user_files = \\\n \tgo/os/user/user.go \\\n+\tgo/os/user/lookup.go \\\n \tgo/os/user/lookup_unix.go\n \n go_path_filepath_files = \\\n@@ -1822,6 +1831,7 @@ libgo_go_objs = \\\n \tencoding/json.lo \\\n \tencoding/pem.lo \\\n \tencoding/xml.lo \\\n+\texp/cookiejar.lo \\\n \texp/ebnf.lo \\\n \texp/html.lo \\\n \texp/html/atom.lo \\\n@@ -1836,6 +1846,7 @@ libgo_go_objs = \\\n \tgo/ast.lo \\\n \tgo/build.lo \\\n \tgo/doc.lo \\\n+\tgo/format.lo \\\n \tgo/parser.lo \\\n \tgo/printer.lo \\\n \tgo/scanner.lo \\\n@@ -2658,6 +2669,15 @@ encoding/xml/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/xml/check\n \n+@go_include@ exp/cookiejar.lo.dep\n+exp/cookiejar.lo.dep: $(go_exp_cookiejar_files)\n+\t$(BUILDDEPS)\n+exp/cookiejar.lo: $(go_exp_cookiejar_files)\n+\t$(BUILDPACKAGE)\n+exp/cookiejar/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/cookiejar/check\n+\n @go_include@ exp/ebnf.lo.dep\n exp/ebnf.lo.dep: $(go_exp_ebnf_files)\n \t$(BUILDDEPS)\n@@ -2802,6 +2822,15 @@ go/doc/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/doc/check\n \n+@go_include@ go/format.lo.dep\n+go/format.lo.dep: $(go_go_format_files)\n+\t$(BUILDDEPS)\n+go/format.lo: $(go_go_format_files)\n+\t$(BUILDPACKAGE)\n+go/format/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/format/check\n+\n @go_include@ go/parser.lo.dep\n go/parser.lo.dep: $(go_go_parser_files)\n \t$(BUILDDEPS)\n@@ -3450,6 +3479,8 @@ encoding/pem.gox: encoding/pem.lo\n encoding/xml.gox: encoding/xml.lo\n \t$(BUILDGOX)\n \n+exp/cookiejar.gox: exp/cookiejar.lo\n+\t$(BUILDGOX)\n exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n exp/html.gox: exp/html.lo\n@@ -3482,6 +3513,8 @@ go/build.gox: go/build.lo\n \t$(BUILDGOX)\n go/doc.gox: go/doc.lo\n \t$(BUILDGOX)\n+go/format.gox: go/format.lo\n+\t$(BUILDGOX)\n go/parser.gox: go/parser.lo\n \t$(BUILDGOX)\n go/printer.gox: go/printer.lo\n@@ -3681,6 +3714,7 @@ TEST_PACKAGES = \\\n \tencoding/json/check \\\n \tencoding/pem/check \\\n \tencoding/xml/check \\\n+\texp/cookiejar/check \\\n \texp/ebnf/check \\\n \texp/html/check \\\n \texp/html/atom/check \\\n@@ -3696,6 +3730,7 @@ TEST_PACKAGES = \\\n \tgo/ast/check \\\n \t$(go_build_check_omitted_since_it_calls_6g) \\\n \tgo/doc/check \\\n+\tgo/format/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\"}, {"sha": "9b8ea1a57e29d6267da158c75505f71aebac0b1d", "filename": "libgo/Makefile.in", "status": "modified", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -153,26 +153,27 @@ am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \tdebug/pe.lo encoding/ascii85.lo encoding/asn1.lo \\\n \tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n \tencoding/csv.lo encoding/gob.lo encoding/hex.lo \\\n-\tencoding/json.lo encoding/pem.lo encoding/xml.lo exp/ebnf.lo \\\n-\texp/html.lo exp/html/atom.lo exp/locale/collate.lo \\\n-\texp/locale/collate/build.lo exp/norm.lo exp/proxy.lo \\\n-\texp/terminal.lo exp/types.lo exp/utf8string.lo \\\n-\thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/parser.lo \\\n-\tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n-\thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n-\tnet/http/fcgi.lo net/http/httptest.lo net/http/httputil.lo \\\n-\tnet/http/pprof.lo image/color.lo image/draw.lo image/gif.lo \\\n-\timage/jpeg.lo image/png.lo index/suffixarray.lo io/ioutil.lo \\\n-\tlog/syslog.lo log/syslog/syslog_c.lo math/big.lo math/cmplx.lo \\\n-\tmath/rand.lo mime/multipart.lo net/http.lo net/mail.lo \\\n-\tnet/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n-\told/netchan.lo old/regexp.lo old/template.lo os/exec.lo \\\n-\t$(am__DEPENDENCIES_1) os/signal.lo os/user.lo path/filepath.lo \\\n-\tregexp/syntax.lo net/rpc/jsonrpc.lo runtime/debug.lo \\\n-\truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n-\ttext/scanner.lo text/tabwriter.lo text/template.lo \\\n-\ttext/template/parse.lo testing/iotest.lo testing/quick.lo \\\n-\tunicode/utf16.lo unicode/utf8.lo\n+\tencoding/json.lo encoding/pem.lo encoding/xml.lo \\\n+\texp/cookiejar.lo exp/ebnf.lo exp/html.lo exp/html/atom.lo \\\n+\texp/locale/collate.lo exp/locale/collate/build.lo exp/norm.lo \\\n+\texp/proxy.lo exp/terminal.lo exp/types.lo exp/utf8string.lo \\\n+\thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/format.lo \\\n+\tgo/parser.lo go/printer.lo go/scanner.lo go/token.lo \\\n+\thash/adler32.lo hash/crc32.lo hash/crc64.lo hash/fnv.lo \\\n+\tnet/http/cgi.lo net/http/fcgi.lo net/http/httptest.lo \\\n+\tnet/http/httputil.lo net/http/pprof.lo image/color.lo \\\n+\timage/draw.lo image/gif.lo image/jpeg.lo image/png.lo \\\n+\tindex/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n+\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n+\tmime/multipart.lo net/http.lo net/mail.lo net/rpc.lo \\\n+\tnet/smtp.lo net/textproto.lo net/url.lo old/netchan.lo \\\n+\told/regexp.lo old/template.lo os/exec.lo $(am__DEPENDENCIES_1) \\\n+\tos/signal.lo os/user.lo path/filepath.lo regexp/syntax.lo \\\n+\tnet/rpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n+\tsync/atomic.lo sync/atomic_c.lo text/scanner.lo \\\n+\ttext/tabwriter.lo text/template.lo text/template/parse.lo \\\n+\ttesting/iotest.lo testing/quick.lo unicode/utf16.lo \\\n+\tunicode/utf8.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \\\n \t../libbacktrace/libbacktrace.la $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n@@ -608,6 +609,7 @@ toolexeclibgoencoding_DATA = \\\n @LIBGO_IS_LINUX_TRUE@exp_inotify_gox = \n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n toolexeclibgoexp_DATA = \\\n+\texp/cookiejar.gox \\\n \texp/ebnf.gox \\\n \texp/html.gox \\\n \t$(exp_inotify_gox) \\\n@@ -634,6 +636,7 @@ toolexeclibgogo_DATA = \\\n \tgo/ast.gox \\\n \tgo/build.gox \\\n \tgo/doc.gox \\\n+\tgo/format.gox \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n@@ -1403,6 +1406,10 @@ go_encoding_xml_files = \\\n \tgo/encoding/xml/typeinfo.go \\\n \tgo/encoding/xml/xml.go\n \n+go_exp_cookiejar_files = \\\n+\tgo/exp/cookiejar/jar.go \\\n+\tgo/exp/cookiejar/storage.go\n+\n go_exp_ebnf_files = \\\n \tgo/exp/ebnf/ebnf.go \\\n \tgo/exp/ebnf/parser.go\n@@ -1506,6 +1513,9 @@ go_go_doc_files = \\\n \tgo/go/doc/reader.go \\\n \tgo/go/doc/synopsis.go\n \n+go_go_format_files = \\\n+\tgo/go/format/format.go\n+\n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n \tgo/go/parser/parser.go\n@@ -1614,6 +1624,7 @@ go_math_rand_files = \\\n go_mime_multipart_files = \\\n \tgo/mime/multipart/formdata.go \\\n \tgo/mime/multipart/multipart.go \\\n+\tgo/mime/multipart/quotedprintable.go \\\n \tgo/mime/multipart/writer.go\n \n go_net_http_files = \\\n@@ -1695,6 +1706,7 @@ go_os_signal_files = \\\n \n go_os_user_files = \\\n \tgo/os/user/user.go \\\n+\tgo/os/user/lookup.go \\\n \tgo/os/user/lookup_unix.go\n \n go_path_filepath_files = \\\n@@ -1948,6 +1960,7 @@ libgo_go_objs = \\\n \tencoding/json.lo \\\n \tencoding/pem.lo \\\n \tencoding/xml.lo \\\n+\texp/cookiejar.lo \\\n \texp/ebnf.lo \\\n \texp/html.lo \\\n \texp/html/atom.lo \\\n@@ -1962,6 +1975,7 @@ libgo_go_objs = \\\n \tgo/ast.lo \\\n \tgo/build.lo \\\n \tgo/doc.lo \\\n+\tgo/format.lo \\\n \tgo/parser.lo \\\n \tgo/printer.lo \\\n \tgo/scanner.lo \\\n@@ -2200,6 +2214,7 @@ TEST_PACKAGES = \\\n \tencoding/json/check \\\n \tencoding/pem/check \\\n \tencoding/xml/check \\\n+\texp/cookiejar/check \\\n \texp/ebnf/check \\\n \texp/html/check \\\n \texp/html/atom/check \\\n@@ -2215,6 +2230,7 @@ TEST_PACKAGES = \\\n \tgo/ast/check \\\n \t$(go_build_check_omitted_since_it_calls_6g) \\\n \tgo/doc/check \\\n+\tgo/format/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n@@ -5096,6 +5112,15 @@ encoding/xml/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/xml/check\n \n+@go_include@ exp/cookiejar.lo.dep\n+exp/cookiejar.lo.dep: $(go_exp_cookiejar_files)\n+\t$(BUILDDEPS)\n+exp/cookiejar.lo: $(go_exp_cookiejar_files)\n+\t$(BUILDPACKAGE)\n+exp/cookiejar/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/cookiejar/check\n+\n @go_include@ exp/ebnf.lo.dep\n exp/ebnf.lo.dep: $(go_exp_ebnf_files)\n \t$(BUILDDEPS)\n@@ -5240,6 +5265,15 @@ go/doc/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/doc/check\n \n+@go_include@ go/format.lo.dep\n+go/format.lo.dep: $(go_go_format_files)\n+\t$(BUILDDEPS)\n+go/format.lo: $(go_go_format_files)\n+\t$(BUILDPACKAGE)\n+go/format/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/format/check\n+\n @go_include@ go/parser.lo.dep\n go/parser.lo.dep: $(go_go_parser_files)\n \t$(BUILDDEPS)\n@@ -5880,6 +5914,8 @@ encoding/pem.gox: encoding/pem.lo\n encoding/xml.gox: encoding/xml.lo\n \t$(BUILDGOX)\n \n+exp/cookiejar.gox: exp/cookiejar.lo\n+\t$(BUILDGOX)\n exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n exp/html.gox: exp/html.lo\n@@ -5912,6 +5948,8 @@ go/build.gox: go/build.lo\n \t$(BUILDGOX)\n go/doc.gox: go/doc.lo\n \t$(BUILDGOX)\n+go/format.gox: go/format.lo\n+\t$(BUILDGOX)\n go/parser.gox: go/parser.lo\n \t$(BUILDGOX)\n go/printer.gox: go/printer.lo"}, {"sha": "4b690192c6813df1f18412afaa7cd9fec1624512", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -64,6 +64,8 @@ func NewReader(rd io.Reader) *Reader {\n \treturn NewReaderSize(rd, defaultBufSize)\n }\n \n+var errNegativeRead = errors.New(\"bufio: reader returned negative count from Read\")\n+\n // fill reads a new chunk into the buffer.\n func (b *Reader) fill() {\n \t// Slide existing data to beginning.\n@@ -75,6 +77,9 @@ func (b *Reader) fill() {\n \n \t// Read new data.\n \tn, e := b.rd.Read(b.buf[b.w:])\n+\tif n < 0 {\n+\t\tpanic(errNegativeRead)\n+\t}\n \tb.w += n\n \tif e != nil {\n \t\tb.err = e\n@@ -282,6 +287,9 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {\n // of the line. The returned buffer is only valid until the next call to\n // ReadLine. ReadLine either returns a non-nil line or it returns an error,\n // never both.\n+//\n+// The text returned from ReadLine does not include the line end (\"\\r\\n\" or \"\\n\").\n+// No indication or error is given if the input ends without a final line end.\n func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) {\n \tline, err = b.ReadSlice('\\n')\n \tif err == ErrBufferFull {"}, {"sha": "564621150ef116e8ceabd45c81b84e35efd3f506", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -939,6 +939,29 @@ func (w *writeCountingDiscard) Write(p []byte) (int, error) {\n \treturn len(p), nil\n }\n \n+type negativeReader int\n+\n+func (r *negativeReader) Read([]byte) (int, error) { return -1, nil }\n+\n+func TestNegativeRead(t *testing.T) {\n+\t// should panic with a description pointing at the reader, not at itself.\n+\t// (should NOT panic with slice index error, for example.)\n+\tb := NewReader(new(negativeReader))\n+\tdefer func() {\n+\t\tswitch err := recover().(type) {\n+\t\tcase nil:\n+\t\t\tt.Fatal(\"read did not panic\")\n+\t\tcase error:\n+\t\t\tif !strings.Contains(err.Error(), \"reader returned negative count from Read\") {\n+\t\t\t\tt.Fatal(\"wrong panic: %v\", err)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tt.Fatalf(\"unexpected panic value: %T(%v)\", err, err)\n+\t\t}\n+\t}()\n+\tb.Read(make([]byte, 100))\n+}\n+\n // An onlyReader only implements io.Reader, no matter what other methods the underlying implementation may have.\n type onlyReader struct {\n \tr io.Reader"}, {"sha": "3ae930384f6b14201b81199bdeba2c9fe3dd4d79", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -360,16 +360,24 @@ func (b *Buffer) UnreadByte() error {\n // ReadBytes returns err != nil if and only if the returned data does not end in\n // delim.\n func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) {\n+\tslice, err := b.readSlice(delim)\n+\t// return a copy of slice. The buffer's backing array may\n+\t// be overwritten by later calls.\n+\tline = append(line, slice...)\n+\treturn\n+}\n+\n+// readSlice is like readBytes but returns a reference to internal buffer data.\n+func (b *Buffer) readSlice(delim byte) (line []byte, err error) {\n \ti := IndexByte(b.buf[b.off:], delim)\n-\tsize := i + 1\n+\tend := b.off + i + 1\n \tif i < 0 {\n-\t\tsize = len(b.buf) - b.off\n+\t\tend = len(b.buf)\n \t\terr = io.EOF\n \t}\n-\tline = make([]byte, size)\n-\tcopy(line, b.buf[b.off:])\n-\tb.off += size\n-\treturn\n+\tline = b.buf[b.off:end]\n+\tb.off = end\n+\treturn line, err\n }\n \n // ReadString reads until the first occurrence of delim in the input,\n@@ -379,8 +387,8 @@ func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) {\n // ReadString returns err != nil if and only if the returned data does not end\n // in delim.\n func (b *Buffer) ReadString(delim byte) (line string, err error) {\n-\tbytes, err := b.ReadBytes(delim)\n-\treturn string(bytes), err\n+\tslice, err := b.readSlice(delim)\n+\treturn string(slice), err\n }\n \n // NewBuffer creates and initializes a new Buffer using buf as its initial"}, {"sha": "c53544a74a06d317757bc9760f989f97d459f5ff", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -375,6 +375,41 @@ func TestReadBytes(t *testing.T) {\n \t}\n }\n \n+func TestReadString(t *testing.T) {\n+\tfor _, test := range readBytesTests {\n+\t\tbuf := NewBufferString(test.buffer)\n+\t\tvar err error\n+\t\tfor _, expected := range test.expected {\n+\t\t\tvar s string\n+\t\t\ts, err = buf.ReadString(test.delim)\n+\t\t\tif s != expected {\n+\t\t\t\tt.Errorf(\"expected %q, got %q\", expected, s)\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif err != test.err {\n+\t\t\tt.Errorf(\"expected error %v, got %v\", test.err, err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkReadString(b *testing.B) {\n+\tconst n = 32 << 10\n+\n+\tdata := make([]byte, n)\n+\tdata[n-1] = 'x'\n+\tb.SetBytes(int64(n))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf := NewBuffer(data)\n+\t\t_, err := buf.ReadString('x')\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t}\n+}\n+\n func TestGrow(t *testing.T) {\n \tx := []byte{'x'}\n \ty := []byte{'y'}"}, {"sha": "77511b94555634d1ab934e3bd692802351eebce1", "filename": "libgo/go/bytes/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbytes%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbytes%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -125,7 +125,7 @@ func (r *Reader) Seek(offset int64, whence int) (int64, error) {\n func (r *Reader) WriteTo(w io.Writer) (n int64, err error) {\n \tr.prevRune = -1\n \tif r.i >= len(r.s) {\n-\t\treturn 0, io.EOF\n+\t\treturn 0, nil\n \t}\n \tb := r.s[r.i:]\n \tm, err := w.Write(b)"}, {"sha": "f0a3e26c4a773380824d357d4028ce018b9724e9", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -8,6 +8,7 @@ import (\n \t. \"bytes\"\n \t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"testing\"\n )\n@@ -88,16 +89,20 @@ func TestReaderAt(t *testing.T) {\n }\n \n func TestReaderWriteTo(t *testing.T) {\n-\tfor i := 3; i < 30; i += 3 {\n-\t\ts := data[:len(data)/i]\n-\t\tr := NewReader(testBytes[:len(testBytes)/i])\n+\tfor i := 0; i < 30; i += 3 {\n+\t\tvar l int\n+\t\tif i > 0 {\n+\t\t\tl = len(data) / i\n+\t\t}\n+\t\ts := data[:l]\n+\t\tr := NewReader(testBytes[:l])\n \t\tvar b Buffer\n \t\tn, err := r.WriteTo(&b)\n \t\tif expect := int64(len(s)); n != expect {\n \t\t\tt.Errorf(\"got %v; want %v\", n, expect)\n \t\t}\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"got error = %v; want nil\", err)\n+\t\t\tt.Errorf(\"for length %d: got error = %v; want nil\", l, err)\n \t\t}\n \t\tif b.String() != s {\n \t\t\tt.Errorf(\"got string %q; want %q\", b.String(), s)\n@@ -107,3 +112,26 @@ func TestReaderWriteTo(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// verify that copying from an empty reader always has the same results,\n+// regardless of the presence of a WriteTo method.\n+func TestReaderCopyNothing(t *testing.T) {\n+\ttype nErr struct {\n+\t\tn   int64\n+\t\terr error\n+\t}\n+\ttype justReader struct {\n+\t\tio.Reader\n+\t}\n+\ttype justWriter struct {\n+\t\tio.Writer\n+\t}\n+\tdiscard := justWriter{ioutil.Discard} // hide ReadFrom\n+\n+\tvar with, withOut nErr\n+\twith.n, with.err = io.Copy(discard, NewReader(nil))\n+\twithOut.n, withOut.err = io.Copy(discard, justReader{NewReader(nil)})\n+\tif with != withOut {\n+\t\tt.Errorf(\"behavior differs: with = %#v; without: %#v\", with, withOut)\n+\t}\n+}"}, {"sha": "70f654a00792a4956e52ba5a5667971120e86466", "filename": "libgo/go/container/heap/example_test.go", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -37,15 +37,10 @@ func (pq PriorityQueue) Swap(i, j int) {\n func (pq *PriorityQueue) Push(x interface{}) {\n \t// Push and Pop use pointer receivers because they modify the slice's length,\n \t// not just its contents.\n-\t// To simplify indexing expressions in these methods, we save a copy of the\n-\t// slice object. We could instead write (*pq)[i].\n-\ta := *pq\n-\tn := len(a)\n-\ta = a[0 : n+1]\n+\tn := len(*pq)\n \titem := x.(*Item)\n \titem.index = n\n-\ta[n] = item\n-\t*pq = a\n+\t*pq = append(*pq, item)\n }\n \n func (pq *PriorityQueue) Pop() interface{} {"}, {"sha": "6d3b3e5b322266bd5bebc90f949c564947ff9fa8", "filename": "libgo/go/container/ring/ring.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -74,7 +74,7 @@ func New(n int) *Ring {\n \treturn r\n }\n \n-// Link connects ring r with with ring s such that r.Next()\n+// Link connects ring r with ring s such that r.Next()\n // becomes s and returns the original value for r.Next().\n // r must not be empty.\n //"}, {"sha": "d8c2be00a26efd0b6472403866d0fa8a272bbc14", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -758,8 +758,28 @@ func (c *Conn) Write(b []byte) (int, error) {\n \t\treturn 0, alertInternalError\n \t}\n \n+\t// SSL 3.0 and TLS 1.0 are susceptible to a chosen-plaintext\n+\t// attack when using block mode ciphers due to predictable IVs.\n+\t// This can be prevented by splitting each Application Data\n+\t// record into two records, effectively randomizing the IV.\n+\t//\n+\t// http://www.openssl.org/~bodo/tls-cbc.txt\n+\t// https://bugzilla.mozilla.org/show_bug.cgi?id=665814\n+\t// http://www.imperialviolet.org/2012/01/15/beastfollowup.html\n+\n+\tvar m int\n+\tif len(b) > 1 && c.vers <= versionTLS10 {\n+\t\tif _, ok := c.out.cipher.(cipher.BlockMode); ok {\n+\t\t\tn, err := c.writeRecord(recordTypeApplicationData, b[:1])\n+\t\t\tif err != nil {\n+\t\t\t\treturn n, c.setError(err)\n+\t\t\t}\n+\t\t\tm, b = 1, b[1:]\n+\t\t}\n+\t}\n+\n \tn, err := c.writeRecord(recordTypeApplicationData, b)\n-\treturn n, c.setError(err)\n+\treturn n + m, c.setError(err)\n }\n \n // Read can be made to time out and return a net.Error with Timeout() == true"}, {"sha": "9673947a409438a46d0eaa7223dc856dbe8c907d", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 133, "deletions": 117, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -245,67 +245,24 @@ var ecdheAESClientScript = [][]byte{\n \t\t0x19, 0x00, 0x0b, 0x00, 0x02, 0x01, 0x00,\n \t},\n \t{\n-\t\t0x16, 0x03, 0x01, 0x00, 0x54, 0x02, 0x00, 0x00,\n-\t\t0x50, 0x03, 0x01, 0x50, 0x77, 0x31, 0xf7, 0x5b,\n-\t\t0xdb, 0x3d, 0x7a, 0x62, 0x76, 0x70, 0x95, 0x33,\n-\t\t0x73, 0x71, 0x13, 0xfe, 0xa3, 0xb1, 0xd8, 0xb3,\n-\t\t0x4d, 0x0d, 0xdc, 0xfe, 0x58, 0x6e, 0x6a, 0x3a,\n-\t\t0xf9, 0xde, 0xdc, 0x20, 0x8e, 0xfa, 0x3d, 0x60,\n-\t\t0xd0, 0xda, 0xa4, 0x0e, 0x36, 0xf0, 0xde, 0xb6,\n-\t\t0x81, 0xb4, 0x80, 0x5e, 0xf9, 0xd2, 0x4c, 0xec,\n-\t\t0xd1, 0x9c, 0x2a, 0x81, 0xc3, 0x36, 0x0b, 0x0f,\n-\t\t0x4a, 0x3d, 0xdf, 0x75, 0xc0, 0x13, 0x00, 0x00,\n-\t\t0x08, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01,\n-\t\t0x02, 0x16, 0x03, 0x01, 0x02, 0x39, 0x0b, 0x00,\n-\t\t0x02, 0x35, 0x00, 0x02, 0x32, 0x00, 0x02, 0x2f,\n-\t\t0x30, 0x82, 0x02, 0x2b, 0x30, 0x82, 0x01, 0xd5,\n-\t\t0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00,\n-\t\t0xb1, 0x35, 0x13, 0x65, 0x11, 0x20, 0xc5, 0x92,\n-\t\t0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,\n-\t\t0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30,\n-\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n-\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n-\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n-\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n-\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n-\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n-\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n-\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n-\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e,\n-\t\t0x17, 0x0d, 0x31, 0x32, 0x30, 0x34, 0x30, 0x36,\n-\t\t0x31, 0x37, 0x31, 0x30, 0x31, 0x33, 0x5a, 0x17,\n-\t\t0x0d, 0x31, 0x35, 0x30, 0x34, 0x30, 0x36, 0x31,\n-\t\t0x37, 0x31, 0x30, 0x31, 0x33, 0x5a, 0x30, 0x45,\n-\t\t0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,\n-\t\t0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30,\n-\t\t0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a,\n-\t\t0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61,\n-\t\t0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03,\n-\t\t0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74,\n-\t\t0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69,\n-\t\t0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74,\n-\t\t0x79, 0x20, 0x4c, 0x74, 0x64, 0x30, 0x5c, 0x30,\n-\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x4b,\n-\t\t0x00, 0x30, 0x48, 0x02, 0x41, 0x00, 0x9f, 0xb3,\n-\t\t0xc3, 0x84, 0x27, 0x95, 0xff, 0x12, 0x31, 0x52,\n-\t\t0x0f, 0x15, 0xef, 0x46, 0x11, 0xc4, 0xad, 0x80,\n-\t\t0xe6, 0x36, 0x5b, 0x0f, 0xdd, 0x80, 0xd7, 0x61,\n-\t\t0x8d, 0xe0, 0xfc, 0x72, 0x45, 0x09, 0x34, 0xfe,\n-\t\t0x55, 0x66, 0x45, 0x43, 0x4c, 0x68, 0x97, 0x6a,\n-\t\t0xfe, 0xa8, 0xa0, 0xa5, 0xdf, 0x5f, 0x78, 0xff,\n-\t\t0xee, 0xd7, 0x64, 0xb8, 0x3f, 0x04, 0xcb, 0x6f,\n-\t\t0xff, 0x2a, 0xfe, 0xfe, 0xb9, 0xed, 0x02, 0x03,\n-\t\t0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7, 0x30, 0x81,\n-\t\t0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,\n-\t\t0x04, 0x16, 0x04, 0x14, 0x78, 0xa6, 0x97, 0x9a,\n-\t\t0x63, 0xb5, 0xc5, 0xa1, 0xa5, 0x33, 0xba, 0x22,\n-\t\t0x7c, 0x23, 0x6e, 0x5b, 0x1b, 0x7a, 0xcc, 0x2b,\n-\t\t0x30, 0x75, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,\n-\t\t0x6e, 0x30, 0x6c, 0x80, 0x14, 0x78, 0xa6, 0x97,\n-\t\t0x9a, 0x63, 0xb5, 0xc5, 0xa1, 0xa5, 0x33, 0xba,\n-\t\t0x22, 0x7c, 0x23, 0x6e, 0x5b, 0x1b, 0x7a, 0xcc,\n-\t\t0x2b, 0xa1, 0x49, 0xa4, 0x47, 0x30, 0x45, 0x31,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x52, 0x02, 0x00, 0x00,\n+\t\t0x4e, 0x03, 0x01, 0x50, 0xad, 0x72, 0xb1, 0x14,\n+\t\t0x45, 0xce, 0x0a, 0x95, 0xf9, 0x63, 0xef, 0xa8,\n+\t\t0xe5, 0x07, 0x34, 0x04, 0xe9, 0x08, 0x0f, 0x38,\n+\t\t0xe4, 0x28, 0x27, 0x91, 0x07, 0x03, 0xe2, 0xfe,\n+\t\t0xe3, 0x25, 0xf7, 0x20, 0x08, 0x42, 0xa2, 0x01,\n+\t\t0x69, 0x53, 0xf0, 0xd9, 0x4c, 0xfa, 0x01, 0xa1,\n+\t\t0xce, 0x4b, 0xf8, 0x28, 0x21, 0xad, 0x06, 0xbe,\n+\t\t0xe0, 0x1b, 0x3b, 0xf7, 0xec, 0xd2, 0x52, 0xae,\n+\t\t0x2a, 0x57, 0xb7, 0xa8, 0xc0, 0x13, 0x00, 0x00,\n+\t\t0x06, 0x00, 0x0b, 0x00, 0x02, 0x01, 0x00, 0x16,\n+\t\t0x03, 0x01, 0x02, 0x39, 0x0b, 0x00, 0x02, 0x35,\n+\t\t0x00, 0x02, 0x32, 0x00, 0x02, 0x2f, 0x30, 0x82,\n+\t\t0x02, 0x2b, 0x30, 0x82, 0x01, 0xd5, 0xa0, 0x03,\n+\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0xb1, 0x35,\n+\t\t0x13, 0x65, 0x11, 0x20, 0xc5, 0x92, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n \t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n \t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n \t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n@@ -314,39 +271,82 @@ var ecdheAESClientScript = [][]byte{\n \t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n \t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n \t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n-\t\t0x20, 0x4c, 0x74, 0x64, 0x82, 0x09, 0x00, 0xb1,\n-\t\t0x35, 0x13, 0x65, 0x11, 0x20, 0xc5, 0x92, 0x30,\n-\t\t0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05,\n-\t\t0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t0x31, 0x32, 0x30, 0x34, 0x30, 0x36, 0x31, 0x37,\n+\t\t0x31, 0x30, 0x31, 0x33, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t0x35, 0x30, 0x34, 0x30, 0x36, 0x31, 0x37, 0x31,\n+\t\t0x30, 0x31, 0x33, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t0x4c, 0x74, 0x64, 0x30, 0x5c, 0x30, 0x0d, 0x06,\n \t\t0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,\n-\t\t0x01, 0x05, 0x05, 0x00, 0x03, 0x41, 0x00, 0x85,\n-\t\t0x36, 0x40, 0x73, 0xc1, 0xbb, 0x1a, 0xda, 0xd4,\n-\t\t0x59, 0x9f, 0x2d, 0xa2, 0x70, 0x31, 0x46, 0x74,\n-\t\t0xec, 0x83, 0x6e, 0xa8, 0xc8, 0x3c, 0x51, 0xaf,\n-\t\t0x39, 0xac, 0xec, 0x40, 0xbc, 0xe8, 0x22, 0x46,\n-\t\t0x1d, 0x99, 0xd6, 0x46, 0x2a, 0x24, 0xd4, 0x8b,\n-\t\t0x05, 0x08, 0x4b, 0xfb, 0x35, 0x11, 0x6e, 0x92,\n-\t\t0xbb, 0x77, 0xba, 0xe4, 0x12, 0xbb, 0xf4, 0xc8,\n-\t\t0x5e, 0x9c, 0x81, 0xa8, 0x97, 0x60, 0x4c, 0x16,\n-\t\t0x03, 0x01, 0x00, 0x8b, 0x0c, 0x00, 0x00, 0x87,\n-\t\t0x03, 0x00, 0x17, 0x41, 0x04, 0xec, 0x06, 0x1f,\n-\t\t0xa0, 0x5e, 0x29, 0x49, 0x71, 0x8b, 0x04, 0x9f,\n-\t\t0x47, 0x87, 0xb1, 0xcb, 0xae, 0x57, 0x8f, 0xd7,\n-\t\t0xf6, 0xf8, 0x59, 0x74, 0x64, 0x5d, 0x3a, 0x08,\n-\t\t0xaf, 0x20, 0xc6, 0xd9, 0xfc, 0x5e, 0x36, 0x8b,\n-\t\t0x62, 0x0e, 0xdb, 0xee, 0xd8, 0xcd, 0xef, 0x25,\n-\t\t0x8a, 0x38, 0x88, 0x2d, 0x5c, 0x71, 0x50, 0x22,\n-\t\t0xda, 0x3f, 0x94, 0x06, 0xc9, 0x68, 0x5b, 0x78,\n-\t\t0x3d, 0x95, 0xca, 0x54, 0x44, 0x00, 0x40, 0x36,\n-\t\t0xcf, 0x10, 0x81, 0xb4, 0x32, 0x45, 0x3c, 0xa5,\n-\t\t0x2d, 0x3e, 0xb0, 0xf8, 0xf4, 0x51, 0xf5, 0x28,\n-\t\t0x09, 0x85, 0x71, 0xa6, 0x79, 0x71, 0x4b, 0x4e,\n-\t\t0xda, 0x32, 0x5a, 0xc7, 0xb3, 0x57, 0xfd, 0xe8,\n-\t\t0x12, 0xab, 0xd8, 0x29, 0xfb, 0x8b, 0x43, 0x8f,\n-\t\t0x7e, 0x27, 0x63, 0x91, 0x84, 0x9c, 0x51, 0x0c,\n-\t\t0x26, 0x7e, 0x36, 0x3b, 0x37, 0x8d, 0x8f, 0x9e,\n-\t\t0xe2, 0x82, 0x62, 0xbb, 0xe5, 0xdf, 0xfc, 0x16,\n-\t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n+\t\t0x01, 0x01, 0x05, 0x00, 0x03, 0x4b, 0x00, 0x30,\n+\t\t0x48, 0x02, 0x41, 0x00, 0x9f, 0xb3, 0xc3, 0x84,\n+\t\t0x27, 0x95, 0xff, 0x12, 0x31, 0x52, 0x0f, 0x15,\n+\t\t0xef, 0x46, 0x11, 0xc4, 0xad, 0x80, 0xe6, 0x36,\n+\t\t0x5b, 0x0f, 0xdd, 0x80, 0xd7, 0x61, 0x8d, 0xe0,\n+\t\t0xfc, 0x72, 0x45, 0x09, 0x34, 0xfe, 0x55, 0x66,\n+\t\t0x45, 0x43, 0x4c, 0x68, 0x97, 0x6a, 0xfe, 0xa8,\n+\t\t0xa0, 0xa5, 0xdf, 0x5f, 0x78, 0xff, 0xee, 0xd7,\n+\t\t0x64, 0xb8, 0x3f, 0x04, 0xcb, 0x6f, 0xff, 0x2a,\n+\t\t0xfe, 0xfe, 0xb9, 0xed, 0x02, 0x03, 0x01, 0x00,\n+\t\t0x01, 0xa3, 0x81, 0xa7, 0x30, 0x81, 0xa4, 0x30,\n+\t\t0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,\n+\t\t0x04, 0x14, 0x78, 0xa6, 0x97, 0x9a, 0x63, 0xb5,\n+\t\t0xc5, 0xa1, 0xa5, 0x33, 0xba, 0x22, 0x7c, 0x23,\n+\t\t0x6e, 0x5b, 0x1b, 0x7a, 0xcc, 0x2b, 0x30, 0x75,\n+\t\t0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x6e, 0x30,\n+\t\t0x6c, 0x80, 0x14, 0x78, 0xa6, 0x97, 0x9a, 0x63,\n+\t\t0xb5, 0xc5, 0xa1, 0xa5, 0x33, 0xba, 0x22, 0x7c,\n+\t\t0x23, 0x6e, 0x5b, 0x1b, 0x7a, 0xcc, 0x2b, 0xa1,\n+\t\t0x49, 0xa4, 0x47, 0x30, 0x45, 0x31, 0x0b, 0x30,\n+\t\t0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,\n+\t\t0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,\n+\t\t0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d,\n+\t\t0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31,\n+\t\t0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a,\n+\t\t0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n+\t\t0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69,\n+\t\t0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c,\n+\t\t0x74, 0x64, 0x82, 0x09, 0x00, 0xb1, 0x35, 0x13,\n+\t\t0x65, 0x11, 0x20, 0xc5, 0x92, 0x30, 0x0c, 0x06,\n+\t\t0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03,\n+\t\t0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a,\n+\t\t0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05,\n+\t\t0x05, 0x00, 0x03, 0x41, 0x00, 0x85, 0x36, 0x40,\n+\t\t0x73, 0xc1, 0xbb, 0x1a, 0xda, 0xd4, 0x59, 0x9f,\n+\t\t0x2d, 0xa2, 0x70, 0x31, 0x46, 0x74, 0xec, 0x83,\n+\t\t0x6e, 0xa8, 0xc8, 0x3c, 0x51, 0xaf, 0x39, 0xac,\n+\t\t0xec, 0x40, 0xbc, 0xe8, 0x22, 0x46, 0x1d, 0x99,\n+\t\t0xd6, 0x46, 0x2a, 0x24, 0xd4, 0x8b, 0x05, 0x08,\n+\t\t0x4b, 0xfb, 0x35, 0x11, 0x6e, 0x92, 0xbb, 0x77,\n+\t\t0xba, 0xe4, 0x12, 0xbb, 0xf4, 0xc8, 0x5e, 0x9c,\n+\t\t0x81, 0xa8, 0x97, 0x60, 0x4c, 0x16, 0x03, 0x01,\n+\t\t0x00, 0x8b, 0x0c, 0x00, 0x00, 0x87, 0x03, 0x00,\n+\t\t0x17, 0x41, 0x04, 0x1c, 0x8f, 0x9c, 0x6d, 0xe7,\n+\t\t0xab, 0x3e, 0xf8, 0x0a, 0x5d, 0xe1, 0x86, 0xb4,\n+\t\t0xe2, 0x8e, 0xb2, 0x1c, 0x3b, 0xd9, 0xb6, 0x08,\n+\t\t0x80, 0x58, 0x21, 0xe9, 0x0e, 0xc6, 0x66, 0x67,\n+\t\t0x97, 0xcb, 0xb9, 0x92, 0x07, 0x00, 0xc4, 0xe5,\n+\t\t0xec, 0x5f, 0xb4, 0xe2, 0x20, 0xa9, 0xc9, 0x62,\n+\t\t0xd0, 0x98, 0xd5, 0xe3, 0x53, 0xff, 0xd0, 0x0a,\n+\t\t0x6e, 0x29, 0x69, 0x39, 0x2a, 0x4b, 0x5c, 0xd8,\n+\t\t0x6c, 0xf5, 0xfe, 0x00, 0x40, 0x35, 0xa7, 0x26,\n+\t\t0x2e, 0xc2, 0x48, 0x93, 0x32, 0xf7, 0x7d, 0x0f,\n+\t\t0x0d, 0x77, 0x56, 0x9a, 0x85, 0x0c, 0xa6, 0x74,\n+\t\t0x06, 0xb8, 0x3d, 0x90, 0x56, 0x12, 0x63, 0xff,\n+\t\t0x00, 0x5e, 0x0f, 0xf7, 0x24, 0xf7, 0xdb, 0x48,\n+\t\t0x71, 0xe9, 0x2e, 0x03, 0xd3, 0xfa, 0x3a, 0xae,\n+\t\t0xa0, 0xc1, 0x77, 0x3c, 0x4c, 0x59, 0xce, 0x33,\n+\t\t0x1a, 0xd2, 0x47, 0x83, 0xfa, 0xea, 0xd8, 0x1e,\n+\t\t0x06, 0xe7, 0x7d, 0xa0, 0x9b, 0x16, 0x03, 0x01,\n+\t\t0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x46, 0x10, 0x00, 0x00,\n@@ -359,34 +359,50 @@ var ecdheAESClientScript = [][]byte{\n \t\t0xe2, 0x32, 0x42, 0xe9, 0x58, 0xb6, 0xd7, 0x49,\n \t\t0xa6, 0xb5, 0x68, 0x1a, 0x41, 0x03, 0x56, 0x6b,\n \t\t0xdc, 0x5a, 0x89, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x30, 0x9a, 0xaa,\n-\t\t0xca, 0x5b, 0x57, 0xae, 0x34, 0x92, 0x80, 0x45,\n-\t\t0x7f, 0xe6, 0xf9, 0x09, 0x19, 0xd0, 0xf0, 0x1e,\n-\t\t0x4b, 0xc3, 0xda, 0x71, 0xce, 0x34, 0x33, 0x56,\n-\t\t0x9f, 0x20, 0x9f, 0xf9, 0xa8, 0x62, 0x6c, 0x38,\n-\t\t0x1b, 0x41, 0xf5, 0x54, 0xf2, 0x79, 0x42, 0x6c,\n-\t\t0xb5, 0x0e, 0xe7, 0xe1, 0xbc, 0x54,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x30, 0xd9, 0xa7,\n+\t\t0x80, 0x56, 0x3f, 0xa3, 0x8f, 0x96, 0x72, 0x4e,\n+\t\t0x4e, 0x6e, 0x23, 0x41, 0x8f, 0xda, 0x91, 0xb2,\n+\t\t0x9e, 0x63, 0x23, 0x82, 0x64, 0xcd, 0x07, 0x24,\n+\t\t0xd3, 0x40, 0x20, 0x22, 0x4c, 0xe3, 0xff, 0x38,\n+\t\t0xbb, 0x43, 0x9d, 0x57, 0x11, 0xd5, 0x46, 0xa5,\n+\t\t0x05, 0x29, 0x92, 0x02, 0xce, 0xdf,\n \t},\n \t{\n \t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x30, 0x62, 0x82, 0x41, 0x75, 0x2b,\n-\t\t0xee, 0x0f, 0xdc, 0x6c, 0x48, 0x5a, 0x63, 0xd6,\n-\t\t0xcb, 0x0a, 0xfd, 0x0a, 0x0e, 0xde, 0x8b, 0x41,\n-\t\t0x19, 0x0c, 0x13, 0x6b, 0x12, 0xd1, 0xc2, 0x53,\n-\t\t0xeb, 0x1e, 0xf3, 0x7a, 0xbf, 0x23, 0xc5, 0xa6,\n-\t\t0x81, 0xa1, 0xdb, 0xab, 0x2f, 0x2c, 0xbc, 0x35,\n-\t\t0x96, 0x72, 0x83,\n+\t\t0x01, 0x00, 0x90, 0xe7, 0xba, 0x0e, 0xb1, 0xda,\n+\t\t0x92, 0xb5, 0x77, 0x56, 0x38, 0xa6, 0x22, 0xc1,\n+\t\t0x72, 0xeb, 0x8a, 0x68, 0x09, 0xb6, 0x74, 0xad,\n+\t\t0xb3, 0x4a, 0xf2, 0xdd, 0x09, 0x9b, 0xc9, 0x4f,\n+\t\t0x84, 0x73, 0x8b, 0xd6, 0x97, 0x50, 0x23, 0x1c,\n+\t\t0xa0, 0xc2, 0x0c, 0x25, 0x18, 0xdd, 0x5e, 0x15,\n+\t\t0x4d, 0xd9, 0xef, 0x4f, 0x6a, 0x43, 0x61, 0x9c,\n+\t\t0x95, 0xde, 0x3c, 0x66, 0xc4, 0xc1, 0x33, 0x56,\n+\t\t0xdd, 0x2f, 0x90, 0xaf, 0x68, 0x5c, 0x9c, 0xa4,\n+\t\t0x90, 0x6d, 0xbf, 0x51, 0x1d, 0x68, 0xcb, 0x81,\n+\t\t0x77, 0x52, 0xa0, 0x93, 0x2a, 0xf8, 0xc7, 0x61,\n+\t\t0x87, 0x76, 0xca, 0x93, 0x9e, 0xd6, 0xee, 0x6f,\n+\t\t0x3f, 0xeb, 0x7d, 0x06, 0xdd, 0x73, 0x4e, 0x27,\n+\t\t0x16, 0x63, 0x92, 0xe4, 0xb2, 0x3f, 0x91, 0x23,\n+\t\t0x21, 0x97, 0x90, 0xce, 0x53, 0xb8, 0xb0, 0x9d,\n+\t\t0xbd, 0xbd, 0x33, 0x84, 0xad, 0x6b, 0x2e, 0x7b,\n+\t\t0xf5, 0xeb, 0x1d, 0x64, 0x37, 0x2e, 0x29, 0x4e,\n+\t\t0xb0, 0x93, 0xdb, 0x92, 0xc7, 0xaa, 0x94, 0xa5,\n+\t\t0x3b, 0x64, 0xd0,\n \t},\n \t{\n-\t\t0x17, 0x03, 0x01, 0x00, 0x20, 0xaf, 0x5d, 0x35,\n-\t\t0x57, 0x10, 0x60, 0xb3, 0x25, 0x7c, 0x26, 0x0f,\n-\t\t0xf3, 0x5e, 0xb3, 0x0d, 0xad, 0x14, 0x53, 0xcc,\n-\t\t0x0c, 0x08, 0xd9, 0xa2, 0x67, 0xab, 0xf4, 0x03,\n-\t\t0x17, 0x20, 0xf1, 0x7e, 0xca, 0x15, 0x03, 0x01,\n-\t\t0x00, 0x20, 0x30, 0xd0, 0xc1, 0xfb, 0x5f, 0xa6,\n-\t\t0x1b, 0xb4, 0x48, 0xc2, 0x0b, 0x98, 0xa8, 0x88,\n-\t\t0x7a, 0xba, 0xdf, 0x36, 0x06, 0xd8, 0xcc, 0xe9,\n-\t\t0x34, 0xdd, 0x64, 0xc8, 0x73, 0xc5, 0xa2, 0x34,\n-\t\t0x64, 0xb7,\n+\t\t0x17, 0x03, 0x01, 0x00, 0x20, 0x11, 0xd8, 0x6b,\n+\t\t0x3c, 0xf6, 0xbe, 0xf4, 0x54, 0x87, 0xec, 0x75,\n+\t\t0x0c, 0x44, 0xdb, 0x92, 0xfc, 0xde, 0x7e, 0x0f,\n+\t\t0x9f, 0x87, 0x87, 0x9c, 0x03, 0xd5, 0x07, 0x84,\n+\t\t0xe0, 0x3a, 0xf8, 0xae, 0x14, 0x17, 0x03, 0x01,\n+\t\t0x00, 0x20, 0xba, 0x54, 0xef, 0x5b, 0xce, 0xfd,\n+\t\t0x47, 0x76, 0x6d, 0xa1, 0x8b, 0xfd, 0x48, 0xde,\n+\t\t0x6e, 0x26, 0xc1, 0x0c, 0x9d, 0x54, 0xbf, 0x98,\n+\t\t0xf6, 0x1c, 0x80, 0xb9, 0xca, 0x93, 0x81, 0x0a,\n+\t\t0x2e, 0x06, 0x15, 0x03, 0x01, 0x00, 0x20, 0x93,\n+\t\t0x3e, 0x38, 0x17, 0xc9, 0x0a, 0xc3, 0xea, 0xd3,\n+\t\t0x92, 0x75, 0xa6, 0x53, 0x37, 0x4d, 0x74, 0x94,\n+\t\t0xbe, 0x01, 0xdc, 0x5c, 0x5a, 0x0f, 0x09, 0xf6,\n+\t\t0x57, 0x33, 0xc3, 0xbc, 0x3f, 0x7a, 0x4d,\n \t},\n }"}, {"sha": "6d2e28b4023c1078c0508820929f3643b9d1715b", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 389, "deletions": 273, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -550,33 +550,99 @@ var rc4ServerScript = [][]byte{\n \n var des3ServerScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x01, 0x00, 0x54, 0x01, 0x00, 0x00,\n-\t\t0x50, 0x03, 0x01, 0x50, 0x77, 0x3d, 0xe3, 0x8e,\n-\t\t0x48, 0xe6, 0xbd, 0x6d, 0x72, 0x8a, 0x1a, 0x11,\n-\t\t0xb0, 0x8a, 0x7e, 0xff, 0x29, 0x07, 0xa8, 0x91,\n-\t\t0xbc, 0xea, 0x1e, 0x3e, 0x62, 0xc9, 0x8e, 0x72,\n-\t\t0x26, 0xd3, 0xca, 0x00, 0x00, 0x28, 0x00, 0x39,\n-\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n-\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n-\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n-\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n-\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n-\t\t0x00,\n+\t\t0x16, 0x03, 0x00, 0x00, 0xc5, 0x01, 0x00, 0x00,\n+\t\t0xc1, 0x03, 0x03, 0x50, 0xae, 0x5d, 0x38, 0xec,\n+\t\t0xaa, 0x2f, 0x41, 0xf9, 0xd2, 0x7b, 0xa1, 0xfd,\n+\t\t0x0f, 0xff, 0x4e, 0x54, 0x0e, 0x15, 0x57, 0xaf,\n+\t\t0x2c, 0x91, 0xb5, 0x35, 0x5b, 0x2e, 0xb0, 0xec,\n+\t\t0x20, 0xe5, 0xd2, 0x00, 0x00, 0x50, 0xc0, 0x09,\n+\t\t0xc0, 0x23, 0xc0, 0x2b, 0xc0, 0x0a, 0xc0, 0x24,\n+\t\t0xc0, 0x2c, 0xc0, 0x08, 0xc0, 0x13, 0xc0, 0x27,\n+\t\t0xc0, 0x2f, 0xc0, 0x14, 0xc0, 0x30, 0xc0, 0x12,\n+\t\t0x00, 0x33, 0x00, 0x67, 0x00, 0x45, 0x00, 0x9e,\n+\t\t0x00, 0x39, 0x00, 0x6b, 0x00, 0x88, 0x00, 0x16,\n+\t\t0x00, 0x32, 0x00, 0x40, 0x00, 0x44, 0x00, 0xa2,\n+\t\t0x00, 0x38, 0x00, 0x6a, 0x00, 0x87, 0x00, 0x13,\n+\t\t0x00, 0x66, 0x00, 0x2f, 0x00, 0x3c, 0x00, 0x41,\n+\t\t0x00, 0x9c, 0x00, 0x35, 0x00, 0x3d, 0x00, 0x84,\n+\t\t0x00, 0x0a, 0x00, 0x05, 0x00, 0x04, 0x01, 0x00,\n+\t\t0x00, 0x48, 0x00, 0x05, 0x00, 0x05, 0x01, 0x00,\n+\t\t0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x01, 0x00,\n+\t\t0x00, 0x23, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0c,\n+\t\t0x00, 0x0a, 0x00, 0x13, 0x00, 0x15, 0x00, 0x17,\n+\t\t0x00, 0x18, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x02,\n+\t\t0x01, 0x00, 0x00, 0x0d, 0x00, 0x1c, 0x00, 0x1a,\n+\t\t0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x05, 0x01,\n+\t\t0x05, 0x03, 0x06, 0x01, 0x06, 0x03, 0x03, 0x01,\n+\t\t0x03, 0x02, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02,\n+\t\t0x02, 0x03,\n \t},\n \t{\n-\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n-\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x30, 0x02, 0x00, 0x00,\n+\t\t0x2c, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x16,\n-\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n-\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n-\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n-\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n-\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n-\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00,\n+\t\t0x04, 0x00, 0x23, 0x00, 0x00, 0x16, 0x03, 0x01,\n+\t\t0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba, 0x00, 0x02,\n+\t\t0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82, 0x02, 0xb0,\n+\t\t0x30, 0x82, 0x02, 0x19, 0xa0, 0x03, 0x02, 0x01,\n+\t\t0x02, 0x02, 0x09, 0x00, 0x85, 0xb0, 0xbb, 0xa4,\n+\t\t0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d, 0x06, 0x09,\n+\t\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n+\t\t0x05, 0x05, 0x00, 0x30, 0x45, 0x31, 0x0b, 0x30,\n+\t\t0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,\n+\t\t0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,\n+\t\t0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d,\n+\t\t0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31,\n+\t\t0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a,\n+\t\t0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n+\t\t0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69,\n+\t\t0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c,\n+\t\t0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x30,\n+\t\t0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30, 0x39,\n+\t\t0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31, 0x31, 0x30,\n+\t\t0x34, 0x32, 0x34, 0x30, 0x39, 0x30, 0x39, 0x33,\n+\t\t0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b, 0x30, 0x09,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41,\n+\t\t0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d, 0x65,\n+\t\t0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31, 0x21,\n+\t\t0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n+\t\t0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65,\n+\t\t0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74,\n+\t\t0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c, 0x74,\n+\t\t0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09,\n+\t\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n+\t\t0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30,\n+\t\t0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xbb, 0x79,\n+\t\t0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf, 0x46, 0x10,\n+\t\t0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b, 0x07, 0x43,\n+\t\t0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a, 0x43, 0x85,\n+\t\t0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65, 0x4c, 0x2c,\n+\t\t0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4, 0x82, 0xe5,\n+\t\t0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62, 0xa5, 0x2c,\n+\t\t0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c, 0x7a, 0x56,\n+\t\t0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58, 0x7b, 0x26,\n+\t\t0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0, 0xc9, 0x21,\n+\t\t0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f, 0x5a, 0xbf,\n+\t\t0xef, 0x42, 0x71, 0x00, 0xfe, 0x18, 0x99, 0x07,\n+\t\t0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1, 0x04, 0x39,\n+\t\t0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9, 0x7c, 0xe3,\n+\t\t0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01, 0xcf, 0xaf,\n+\t\t0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d, 0xdb, 0xdb,\n+\t\t0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79, 0x02, 0x03,\n+\t\t0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7, 0x30, 0x81,\n+\t\t0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,\n+\t\t0x04, 0x16, 0x04, 0x14, 0xb1, 0xad, 0xe2, 0x85,\n+\t\t0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69, 0xce, 0x23,\n+\t\t0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18, 0x88, 0x39,\n+\t\t0x30, 0x75, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,\n+\t\t0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1, 0xad, 0xe2,\n+\t\t0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69, 0xce,\n+\t\t0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18, 0x88,\n+\t\t0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30, 0x45, 0x31,\n \t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n \t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n \t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n@@ -585,163 +651,207 @@ var des3ServerScript = [][]byte{\n \t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n \t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n \t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n-\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n-\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n-\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n-\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n-\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n-\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n-\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n-\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n-\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n-\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n-\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n-\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n-\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n-\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n-\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n-\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n-\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n-\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n-\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n-\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n-\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n-\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n-\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n-\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n-\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n-\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n-\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n-\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n-\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n-\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n-\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n-\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n-\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n-\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n-\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n-\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n-\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n-\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n-\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n-\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n-\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n-\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n-\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n-\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n-\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n-\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n-\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n-\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n-\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n-\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n-\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n-\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n-\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n-\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n-\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n-\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n-\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n-\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n-\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n-\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n-\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n-\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n-\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n-\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n-\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n-\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n-\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n-\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n-\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n-\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n-\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n-\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n-\t\t0x00, 0x00, 0x00,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x82, 0x09, 0x00, 0x85,\n+\t\t0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30,\n+\t\t0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05,\n+\t\t0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,\n+\t\t0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,\n+\t\t0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00,\n+\t\t0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b, 0xb1, 0x59,\n+\t\t0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0, 0x14, 0xd7,\n+\t\t0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5, 0x5a, 0x95,\n+\t\t0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae, 0x12, 0x66,\n+\t\t0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e, 0x60, 0xd3,\n+\t\t0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5, 0x25, 0x13,\n+\t\t0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30, 0x1d, 0xba,\n+\t\t0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7, 0xd7, 0x31,\n+\t\t0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78, 0xea, 0x50,\n+\t\t0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d, 0x5a, 0x5f,\n+\t\t0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75, 0x90, 0x96,\n+\t\t0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd, 0x98, 0x1f,\n+\t\t0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c, 0xa3, 0x1b,\n+\t\t0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57, 0xe9, 0x70,\n+\t\t0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b, 0x26, 0x6e,\n+\t\t0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7, 0xbd, 0xd9,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00,\n+\t\t0x00,\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t0x82, 0x00, 0x80, 0x33, 0x52, 0xe2, 0xd6, 0x79,\n-\t\t0xf8, 0xe6, 0xd4, 0xe2, 0x08, 0xb0, 0x73, 0x36,\n-\t\t0xa7, 0x61, 0x72, 0x19, 0xfb, 0xd1, 0x1f, 0xf5,\n-\t\t0xbc, 0x7c, 0x84, 0xdd, 0xed, 0x99, 0xd7, 0x5e,\n-\t\t0x3d, 0x11, 0xc3, 0x19, 0xb0, 0x7f, 0x10, 0x94,\n-\t\t0x72, 0x64, 0xf3, 0x2c, 0x3f, 0x8d, 0x73, 0x39,\n-\t\t0x9e, 0xca, 0x2e, 0x09, 0xbd, 0xb7, 0x8d, 0x4c,\n-\t\t0x5b, 0x58, 0xff, 0x4f, 0x53, 0xa9, 0xd4, 0x7c,\n-\t\t0x34, 0xe0, 0xaa, 0xa8, 0x14, 0xc0, 0x14, 0x25,\n-\t\t0x0b, 0xaa, 0x55, 0xab, 0x10, 0x34, 0x45, 0x72,\n-\t\t0xe8, 0x26, 0x6f, 0xf5, 0xbb, 0x3a, 0xfa, 0xd8,\n-\t\t0x4f, 0x70, 0xe1, 0xc1, 0xb6, 0x11, 0x1e, 0xd1,\n-\t\t0xe0, 0x0b, 0xa1, 0x3a, 0xdc, 0x94, 0x89, 0x7f,\n-\t\t0x88, 0x5e, 0x5a, 0xf1, 0x0c, 0x98, 0xe2, 0xab,\n-\t\t0x0e, 0x3a, 0xa8, 0x2f, 0xbb, 0xc5, 0x02, 0x07,\n-\t\t0x15, 0x5e, 0x46, 0x82, 0x54, 0x9c, 0x09, 0xea,\n-\t\t0xb9, 0x56, 0xf7, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x28, 0xb9, 0xbf,\n-\t\t0x9a, 0xb8, 0xe4, 0x14, 0x6b, 0xc6, 0xf0, 0x27,\n-\t\t0xb7, 0xdb, 0xb2, 0xbc, 0x16, 0xd1, 0x3c, 0x0b,\n-\t\t0xc1, 0xe6, 0x1c, 0xa1, 0x29, 0xc7, 0x37, 0xe6,\n-\t\t0x56, 0x1d, 0x16, 0xb5, 0xa8, 0x0d, 0x4d, 0xdb,\n-\t\t0x9d, 0xf8, 0xb2, 0x6a, 0x90, 0x96,\n+\t\t0x82, 0x00, 0x80, 0x51, 0x04, 0xf1, 0x7a, 0xbf,\n+\t\t0xe8, 0xa5, 0x86, 0x09, 0xa7, 0xf3, 0xcc, 0x93,\n+\t\t0x00, 0x10, 0x5b, 0xb8, 0xc1, 0x51, 0x0d, 0x5b,\n+\t\t0xcd, 0xed, 0x26, 0x01, 0x69, 0x73, 0xf4, 0x05,\n+\t\t0x8a, 0x6a, 0xc3, 0xb1, 0x9e, 0x84, 0x4e, 0x39,\n+\t\t0xcf, 0x5e, 0x55, 0xa9, 0x70, 0x19, 0x96, 0x91,\n+\t\t0xcd, 0x2c, 0x78, 0x3c, 0xa2, 0x6d, 0xb0, 0x49,\n+\t\t0x86, 0xf6, 0xd1, 0x3a, 0xde, 0x00, 0x4b, 0xa6,\n+\t\t0x25, 0xbf, 0x85, 0x39, 0xce, 0xb1, 0xcf, 0xbc,\n+\t\t0x16, 0xc7, 0x66, 0xac, 0xf8, 0xd2, 0x3b, 0xd1,\n+\t\t0xcc, 0x16, 0xac, 0x63, 0x3c, 0xbe, 0xd9, 0xb6,\n+\t\t0x6a, 0xe4, 0x13, 0x8a, 0xf4, 0x56, 0x2f, 0x92,\n+\t\t0x54, 0xd8, 0xf0, 0x84, 0x01, 0x32, 0x1a, 0xa9,\n+\t\t0x2d, 0xaf, 0x82, 0x0e, 0x00, 0xfa, 0x07, 0x88,\n+\t\t0xd9, 0x87, 0xe7, 0xdc, 0x9e, 0xe9, 0x72, 0x49,\n+\t\t0xb8, 0xfa, 0x8c, 0x7b, 0x07, 0x0b, 0x03, 0x7c,\n+\t\t0x10, 0x8c, 0x8a, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0xa8, 0x61, 0xa4,\n+\t\t0xf4, 0x5f, 0x8a, 0x1f, 0x5c, 0x92, 0x3f, 0x8c,\n+\t\t0xdb, 0xd6, 0x10, 0xcd, 0x9e, 0xe7, 0xf0, 0xc4,\n+\t\t0x3c, 0xb6, 0x1c, 0x9a, 0x56, 0x73, 0x7f, 0xa6,\n+\t\t0x14, 0x24, 0xcb, 0x96, 0x1f, 0xe0, 0xaf, 0xcd,\n+\t\t0x3c, 0x66, 0x43, 0xb7, 0x37, 0x65, 0x34, 0x47,\n+\t\t0xf8, 0x43, 0xf1, 0xcc, 0x15, 0xb8, 0xdc, 0x35,\n+\t\t0xe0, 0xa4, 0x2d, 0x78, 0x94, 0xe0, 0x02, 0xf3,\n+\t\t0x76, 0x46, 0xf7, 0x9b, 0x8d, 0x0d, 0x5d, 0x0b,\n+\t\t0xd3, 0xdd, 0x9a, 0x9e, 0x62, 0x2e, 0xc5, 0x98,\n+\t\t0x75, 0x63, 0x0c, 0xbf, 0x8e, 0x49, 0x33, 0x23,\n+\t\t0x7c, 0x00, 0xcf, 0xfb, 0xcf, 0xba, 0x0f, 0x41,\n+\t\t0x39, 0x89, 0xb9, 0xcc, 0x59, 0xd0, 0x2b, 0xb6,\n+\t\t0xec, 0x04, 0xe2, 0xc0, 0x52, 0xc7, 0xcf, 0x71,\n+\t\t0x47, 0xff, 0x70, 0x7e, 0xa9, 0xbd, 0x1c, 0xdd,\n+\t\t0x17, 0xa5, 0x6c, 0xb7, 0x10, 0x4f, 0x42, 0x18,\n+\t\t0x37, 0x69, 0xa9, 0xd2, 0xb3, 0x18, 0x84, 0x92,\n+\t\t0xa7, 0x47, 0x21, 0xf6, 0x95, 0x63, 0x29, 0xd6,\n+\t\t0xa5, 0xb6, 0xda, 0x65, 0x67, 0x69, 0xc4, 0x26,\n+\t\t0xac, 0x8b, 0x08, 0x58, 0xdd, 0x3c, 0x31, 0x20,\n+\t\t0xd5, 0x0c, 0x88, 0x72, 0x18, 0x16, 0x88, 0x1e,\n+\t\t0x4a, 0x0f, 0xe1, 0xcf, 0x95, 0x24,\n \t},\n \t{\n-\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x28, 0x5d, 0xc9, 0xad, 0xcf, 0xf8,\n-\t\t0x37, 0x05, 0xec, 0x5e, 0xb2, 0x77, 0xb3, 0x1a,\n-\t\t0x91, 0x75, 0x1d, 0x8d, 0xdd, 0x1a, 0xff, 0xb6,\n-\t\t0xca, 0xf7, 0x59, 0x04, 0xb2, 0x11, 0x0a, 0x25,\n-\t\t0x7e, 0xc5, 0x7d, 0xba, 0x8a, 0x50, 0xcc, 0xe9,\n-\t\t0x89, 0xa0, 0x91, 0x17, 0x03, 0x01, 0x00, 0x28,\n-\t\t0x30, 0x68, 0x28, 0x1e, 0x75, 0x82, 0x04, 0xe7,\n-\t\t0xd3, 0x3b, 0xb1, 0x17, 0x32, 0x10, 0x7f, 0xae,\n-\t\t0x77, 0xeb, 0xf1, 0x46, 0xcc, 0xe5, 0xe0, 0xbe,\n-\t\t0x07, 0x37, 0x0d, 0x84, 0x54, 0xa1, 0x88, 0xac,\n-\t\t0xe5, 0x06, 0x7b, 0xee, 0xe6, 0xa1, 0xee, 0xb0,\n-\t\t0x15, 0x03, 0x01, 0x00, 0x18, 0x73, 0xa9, 0xf8,\n-\t\t0x5a, 0xd4, 0xfc, 0xd9, 0xa9, 0x82, 0x97, 0x50,\n-\t\t0x14, 0x76, 0x6c, 0x27, 0x9f, 0xa2, 0xf1, 0x52,\n-\t\t0xa0, 0xe3, 0xbd, 0xcb, 0xd3,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x72, 0x04, 0x00, 0x00,\n+\t\t0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,\n+\t\t0xe8, 0x4b, 0xde, 0xef, 0xba, 0x3e, 0x18, 0x1c,\n+\t\t0x1e, 0x5e, 0xbc, 0x87, 0xf1, 0x87, 0x8d, 0x72,\n+\t\t0xe3, 0xbe, 0x0f, 0xdf, 0xfd, 0xd0, 0xb2, 0x89,\n+\t\t0xf8, 0x05, 0x9a, 0x52, 0x47, 0x77, 0x9e, 0xe8,\n+\t\t0xb1, 0x1d, 0x18, 0xed, 0x6a, 0x4b, 0x63, 0x1d,\n+\t\t0xf1, 0x62, 0xd2, 0x65, 0x21, 0x26, 0x73, 0xd4,\n+\t\t0x35, 0x5b, 0x95, 0x89, 0x12, 0x59, 0x23, 0x8c,\n+\t\t0xc3, 0xfc, 0xf9, 0x4d, 0x21, 0x79, 0xa0, 0xbd,\n+\t\t0xff, 0x33, 0xa2, 0x3d, 0x0b, 0x6f, 0x89, 0xc9,\n+\t\t0x23, 0xe4, 0xe7, 0x9f, 0x1d, 0x98, 0xf6, 0xed,\n+\t\t0x02, 0x8d, 0xac, 0x1a, 0xf9, 0xcb, 0xa5, 0x14,\n+\t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n+\t\t0x00, 0x28, 0x91, 0x56, 0x80, 0xe2, 0x6d, 0x51,\n+\t\t0x88, 0x03, 0xf8, 0x49, 0xe6, 0x6a, 0x5a, 0xfb,\n+\t\t0x2f, 0x0b, 0xb5, 0xa1, 0x0d, 0x63, 0x83, 0xae,\n+\t\t0xb9, 0xbc, 0x05, 0xf0, 0x81, 0x00, 0x61, 0x83,\n+\t\t0x38, 0xda, 0x14, 0xf6, 0xea, 0xd8, 0x78, 0x65,\n+\t\t0xc7, 0x26, 0x17, 0x03, 0x01, 0x00, 0x18, 0x81,\n+\t\t0x30, 0x8b, 0x22, 0x5a, 0xd3, 0x7f, 0xc8, 0xf2,\n+\t\t0x8a, 0x6b, 0xa3, 0xba, 0x4d, 0xe7, 0x6e, 0xd2,\n+\t\t0xfd, 0xbf, 0xf2, 0xc5, 0x28, 0xa0, 0x62, 0x17,\n+\t\t0x03, 0x01, 0x00, 0x28, 0x17, 0x83, 0x3c, 0x78,\n+\t\t0x18, 0xfa, 0x8d, 0x58, 0x5c, 0xaa, 0x05, 0x7d,\n+\t\t0x67, 0x96, 0x11, 0x60, 0x11, 0xc0, 0x1e, 0x0d,\n+\t\t0x6a, 0x6e, 0x5f, 0x1d, 0x98, 0x4b, 0xff, 0x82,\n+\t\t0xee, 0x21, 0x06, 0x29, 0xd3, 0x8b, 0x80, 0x78,\n+\t\t0x39, 0x05, 0x34, 0x9b, 0x15, 0x03, 0x01, 0x00,\n+\t\t0x18, 0xa9, 0x38, 0x18, 0x4f, 0x9d, 0x84, 0x75,\n+\t\t0x88, 0x53, 0xd6, 0x85, 0xc2, 0x15, 0x4b, 0xe3,\n+\t\t0xe3, 0x35, 0x9a, 0x74, 0xc9, 0x3e, 0x13, 0xc1,\n+\t\t0x8c,\n \t},\n }\n \n var aesServerScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x02, 0x00, 0x7f, 0x01, 0x00, 0x00,\n-\t\t0x7b, 0x03, 0x02, 0x4d, 0x08, 0x2d, 0x0b, 0xb3,\n-\t\t0x57, 0x85, 0x71, 0x4b, 0xfb, 0x34, 0xab, 0x16,\n-\t\t0xd4, 0x92, 0x50, 0x81, 0x16, 0x95, 0x11, 0x28,\n-\t\t0x1a, 0xcb, 0xff, 0x09, 0x4d, 0x23, 0xa6, 0xfe,\n-\t\t0x2e, 0xbb, 0x78, 0x00, 0x00, 0x34, 0x00, 0x33,\n-\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n-\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n-\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n-\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n-\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n-\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n-\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x1e, 0x00, 0x09,\n-\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n-\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n-\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74, 0xff,\n-\t\t0x01, 0x00, 0x01, 0x00,\n+\t\t0x16, 0x03, 0x00, 0x00, 0xc5, 0x01, 0x00, 0x00,\n+\t\t0xc1, 0x03, 0x03, 0x50, 0xae, 0x5c, 0xe9, 0x5e,\n+\t\t0x31, 0x93, 0x82, 0xa5, 0x6f, 0x51, 0x82, 0xc8,\n+\t\t0x55, 0x4f, 0x1f, 0x2e, 0x90, 0x98, 0x81, 0x13,\n+\t\t0x27, 0x80, 0x68, 0xb4, 0x2d, 0xba, 0x3a, 0x76,\n+\t\t0xd8, 0xd7, 0x2c, 0x00, 0x00, 0x50, 0xc0, 0x09,\n+\t\t0xc0, 0x23, 0xc0, 0x2b, 0xc0, 0x0a, 0xc0, 0x24,\n+\t\t0xc0, 0x2c, 0xc0, 0x08, 0xc0, 0x13, 0xc0, 0x27,\n+\t\t0xc0, 0x2f, 0xc0, 0x14, 0xc0, 0x30, 0xc0, 0x12,\n+\t\t0x00, 0x33, 0x00, 0x67, 0x00, 0x45, 0x00, 0x9e,\n+\t\t0x00, 0x39, 0x00, 0x6b, 0x00, 0x88, 0x00, 0x16,\n+\t\t0x00, 0x32, 0x00, 0x40, 0x00, 0x44, 0x00, 0xa2,\n+\t\t0x00, 0x38, 0x00, 0x6a, 0x00, 0x87, 0x00, 0x13,\n+\t\t0x00, 0x66, 0x00, 0x2f, 0x00, 0x3c, 0x00, 0x41,\n+\t\t0x00, 0x9c, 0x00, 0x35, 0x00, 0x3d, 0x00, 0x84,\n+\t\t0x00, 0x0a, 0x00, 0x05, 0x00, 0x04, 0x01, 0x00,\n+\t\t0x00, 0x48, 0x00, 0x05, 0x00, 0x05, 0x01, 0x00,\n+\t\t0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x01, 0x00,\n+\t\t0x00, 0x23, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0c,\n+\t\t0x00, 0x0a, 0x00, 0x13, 0x00, 0x15, 0x00, 0x17,\n+\t\t0x00, 0x18, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x02,\n+\t\t0x01, 0x00, 0x00, 0x0d, 0x00, 0x1c, 0x00, 0x1a,\n+\t\t0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x05, 0x01,\n+\t\t0x05, 0x03, 0x06, 0x01, 0x06, 0x03, 0x03, 0x01,\n+\t\t0x03, 0x02, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02,\n+\t\t0x02, 0x03,\n \t},\n-\n \t{\n-\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n-\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x30, 0x02, 0x00, 0x00,\n+\t\t0x2c, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x16,\n-\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n-\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n-\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n-\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n-\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n-\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00,\n+\t\t0x04, 0x00, 0x23, 0x00, 0x00, 0x16, 0x03, 0x01,\n+\t\t0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba, 0x00, 0x02,\n+\t\t0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82, 0x02, 0xb0,\n+\t\t0x30, 0x82, 0x02, 0x19, 0xa0, 0x03, 0x02, 0x01,\n+\t\t0x02, 0x02, 0x09, 0x00, 0x85, 0xb0, 0xbb, 0xa4,\n+\t\t0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d, 0x06, 0x09,\n+\t\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n+\t\t0x05, 0x05, 0x00, 0x30, 0x45, 0x31, 0x0b, 0x30,\n+\t\t0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,\n+\t\t0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,\n+\t\t0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d,\n+\t\t0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31,\n+\t\t0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a,\n+\t\t0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n+\t\t0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69,\n+\t\t0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c,\n+\t\t0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x30,\n+\t\t0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30, 0x39,\n+\t\t0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31, 0x31, 0x30,\n+\t\t0x34, 0x32, 0x34, 0x30, 0x39, 0x30, 0x39, 0x33,\n+\t\t0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b, 0x30, 0x09,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41,\n+\t\t0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d, 0x65,\n+\t\t0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31, 0x21,\n+\t\t0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n+\t\t0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65,\n+\t\t0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74,\n+\t\t0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c, 0x74,\n+\t\t0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09,\n+\t\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n+\t\t0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30,\n+\t\t0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xbb, 0x79,\n+\t\t0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf, 0x46, 0x10,\n+\t\t0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b, 0x07, 0x43,\n+\t\t0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a, 0x43, 0x85,\n+\t\t0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65, 0x4c, 0x2c,\n+\t\t0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4, 0x82, 0xe5,\n+\t\t0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62, 0xa5, 0x2c,\n+\t\t0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c, 0x7a, 0x56,\n+\t\t0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58, 0x7b, 0x26,\n+\t\t0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0, 0xc9, 0x21,\n+\t\t0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f, 0x5a, 0xbf,\n+\t\t0xef, 0x42, 0x71, 0x00, 0xfe, 0x18, 0x99, 0x07,\n+\t\t0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1, 0x04, 0x39,\n+\t\t0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9, 0x7c, 0xe3,\n+\t\t0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01, 0xcf, 0xaf,\n+\t\t0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d, 0xdb, 0xdb,\n+\t\t0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79, 0x02, 0x03,\n+\t\t0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7, 0x30, 0x81,\n+\t\t0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,\n+\t\t0x04, 0x16, 0x04, 0x14, 0xb1, 0xad, 0xe2, 0x85,\n+\t\t0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69, 0xce, 0x23,\n+\t\t0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18, 0x88, 0x39,\n+\t\t0x30, 0x75, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,\n+\t\t0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1, 0xad, 0xe2,\n+\t\t0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69, 0xce,\n+\t\t0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18, 0x88,\n+\t\t0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30, 0x45, 0x31,\n \t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n \t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n \t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n@@ -750,120 +860,126 @@ var aesServerScript = [][]byte{\n \t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n \t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n \t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n-\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n-\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n-\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n-\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n-\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n-\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n-\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n-\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n-\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n-\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n-\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n-\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n-\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n-\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n-\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n-\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n-\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n-\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n-\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n-\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n-\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n-\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n-\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n-\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n-\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n-\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n-\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n-\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n-\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n-\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n-\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n-\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n-\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n-\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n-\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n-\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n-\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n-\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n-\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n-\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n-\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n-\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n-\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n-\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n-\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n-\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n-\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n-\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n-\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n-\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n-\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n-\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n-\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n-\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n-\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n-\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n-\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n-\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n-\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n-\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n-\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n-\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n-\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n-\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n-\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n-\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n-\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n-\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n-\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n-\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n-\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n-\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n-\t\t0x00, 0x00, 0x00,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x82, 0x09, 0x00, 0x85,\n+\t\t0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30,\n+\t\t0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05,\n+\t\t0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,\n+\t\t0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,\n+\t\t0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00,\n+\t\t0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b, 0xb1, 0x59,\n+\t\t0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0, 0x14, 0xd7,\n+\t\t0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5, 0x5a, 0x95,\n+\t\t0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae, 0x12, 0x66,\n+\t\t0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e, 0x60, 0xd3,\n+\t\t0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5, 0x25, 0x13,\n+\t\t0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30, 0x1d, 0xba,\n+\t\t0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7, 0xd7, 0x31,\n+\t\t0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78, 0xea, 0x50,\n+\t\t0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d, 0x5a, 0x5f,\n+\t\t0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75, 0x90, 0x96,\n+\t\t0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd, 0x98, 0x1f,\n+\t\t0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c, 0xa3, 0x1b,\n+\t\t0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57, 0xe9, 0x70,\n+\t\t0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b, 0x26, 0x6e,\n+\t\t0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7, 0xbd, 0xd9,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00,\n+\t\t0x00,\n \t},\n-\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t0x82, 0x00, 0x80, 0x71, 0x9c, 0xe7, 0x23, 0xfc,\n-\t\t0xb9, 0x19, 0x29, 0x82, 0xbf, 0xef, 0x08, 0xf7,\n-\t\t0x99, 0x36, 0xc3, 0x4c, 0x6f, 0x05, 0xd2, 0x8b,\n-\t\t0x62, 0x2b, 0x19, 0x9b, 0x7f, 0xc0, 0xcc, 0x48,\n-\t\t0x30, 0x5f, 0xcd, 0xc3, 0x70, 0x55, 0x53, 0x73,\n-\t\t0xfa, 0x79, 0x74, 0xf3, 0xa3, 0x76, 0x9f, 0xa1,\n-\t\t0x7f, 0x98, 0xc2, 0xc0, 0xe3, 0xc5, 0xa0, 0x31,\n-\t\t0x2f, 0xa6, 0xe8, 0x1e, 0x61, 0x46, 0xb3, 0x9b,\n-\t\t0x4b, 0x16, 0xf1, 0x2d, 0xc7, 0x63, 0x7f, 0x79,\n-\t\t0x22, 0x30, 0xd1, 0xf2, 0xfc, 0x77, 0x98, 0x0a,\n-\t\t0x16, 0x11, 0x63, 0x71, 0x7f, 0x70, 0xef, 0x16,\n-\t\t0xbb, 0x39, 0x87, 0x34, 0xac, 0x49, 0xbd, 0x07,\n-\t\t0x67, 0xcb, 0x9c, 0xcc, 0xde, 0xef, 0xb1, 0xe0,\n-\t\t0xdb, 0x01, 0xb5, 0x35, 0xa9, 0xb3, 0x10, 0x0c,\n-\t\t0x4b, 0xee, 0xb3, 0x4e, 0xfd, 0xbe, 0x15, 0x27,\n-\t\t0xf0, 0x46, 0xb2, 0x38, 0xba, 0x5f, 0xcc, 0x89,\n-\t\t0xec, 0x29, 0x82, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x30, 0x3c, 0xfb,\n-\t\t0xa4, 0x12, 0xcb, 0x00, 0xf9, 0x57, 0x7e, 0x9b,\n-\t\t0xc9, 0xdc, 0x0c, 0xba, 0x9a, 0x81, 0x62, 0xfb,\n-\t\t0x26, 0x13, 0x53, 0xfe, 0xaa, 0xcc, 0x82, 0xbb,\n-\t\t0xb6, 0x67, 0x7f, 0x39, 0xbe, 0x4d, 0xbb, 0xc0,\n-\t\t0x6c, 0x24, 0x31, 0x83, 0xa5, 0x50, 0x3a, 0x75,\n-\t\t0x32, 0x64, 0xb5, 0xdb, 0xbe, 0x0a,\n+\t\t0x82, 0x00, 0x80, 0x51, 0x2e, 0xec, 0x0d, 0x86,\n+\t\t0xf3, 0x9f, 0xf2, 0x77, 0x04, 0x27, 0x2b, 0x0e,\n+\t\t0x9c, 0xab, 0x35, 0x84, 0x65, 0xff, 0x36, 0xef,\n+\t\t0xc0, 0x08, 0xc9, 0x1d, 0x9f, 0x29, 0xae, 0x8d,\n+\t\t0xc5, 0x66, 0x81, 0x31, 0x92, 0x5e, 0x3d, 0xac,\n+\t\t0xaa, 0x37, 0x28, 0x2c, 0x06, 0x91, 0xa6, 0xc2,\n+\t\t0xd0, 0x83, 0x34, 0x24, 0x1c, 0x88, 0xfc, 0x0a,\n+\t\t0xcf, 0xbf, 0xc2, 0x94, 0xe2, 0xed, 0xa7, 0x6a,\n+\t\t0xa8, 0x8d, 0x3d, 0xf7, 0x06, 0x7d, 0x69, 0xf8,\n+\t\t0x0d, 0xb2, 0xf7, 0xe4, 0x45, 0xcb, 0x0a, 0x25,\n+\t\t0xcb, 0xb2, 0x2e, 0x38, 0x9a, 0x84, 0x75, 0xe8,\n+\t\t0xe1, 0x42, 0x39, 0xa2, 0x18, 0x0e, 0x48, 0xca,\n+\t\t0x33, 0x16, 0x4e, 0xf6, 0x2f, 0xec, 0x07, 0xe7,\n+\t\t0x57, 0xe1, 0x20, 0x40, 0x40, 0x6d, 0x4e, 0x29,\n+\t\t0x04, 0x1a, 0x8c, 0x99, 0xfb, 0x19, 0x3c, 0xaa,\n+\t\t0x75, 0x64, 0xd3, 0xa6, 0xe6, 0xed, 0x3f, 0x5a,\n+\t\t0xd2, 0xc9, 0x80, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x01, 0x10, 0xe9, 0x9e,\n+\t\t0x06, 0x92, 0x18, 0xbf, 0x5e, 0xaf, 0x33, 0xc1,\n+\t\t0xbf, 0x0e, 0x12, 0x07, 0x48, 0x4f, 0x6b, 0x6c,\n+\t\t0xf5, 0x23, 0x5e, 0x87, 0xa7, 0xd3, 0x50, 0x79,\n+\t\t0x38, 0xdc, 0xe0, 0x49, 0xd3, 0x81, 0x21, 0x12,\n+\t\t0xd0, 0x3d, 0x9a, 0xfb, 0x83, 0xc1, 0x8b, 0xfc,\n+\t\t0x14, 0xd5, 0xd5, 0xa7, 0xa3, 0x34, 0x14, 0x71,\n+\t\t0xbe, 0xea, 0x37, 0x18, 0x12, 0x7f, 0x41, 0xfb,\n+\t\t0xc5, 0x51, 0x17, 0x9d, 0x96, 0x58, 0x14, 0xfb,\n+\t\t0x4f, 0xd7, 0xd3, 0x15, 0x0f, 0xec, 0x5a, 0x0d,\n+\t\t0x35, 0xbb, 0x3c, 0x81, 0x5b, 0x3f, 0xdf, 0x52,\n+\t\t0xa4, 0x4c, 0xcd, 0x13, 0xe1, 0x10, 0x37, 0x34,\n+\t\t0xbf, 0xb4, 0x80, 0x1e, 0x8d, 0xe2, 0xc3, 0x7a,\n+\t\t0x0f, 0x7b, 0x7d, 0x23, 0xeb, 0xd0, 0x99, 0x69,\n+\t\t0xad, 0x0a, 0x2d, 0xb3, 0x6c, 0xd6, 0x80, 0x11,\n+\t\t0x7f, 0x6c, 0xed, 0x1b, 0xcd, 0x08, 0x22, 0x56,\n+\t\t0x90, 0x0e, 0xa4, 0xc3, 0x29, 0x33, 0x96, 0x30,\n+\t\t0x34, 0x94, 0xa1, 0xeb, 0x9c, 0x1b, 0x5a, 0xd1,\n+\t\t0x03, 0x61, 0xf9, 0xdd, 0xf3, 0x64, 0x8a, 0xfd,\n+\t\t0x5f, 0x44, 0xdb, 0x2e, 0xa7, 0xfd, 0xe1, 0x1a,\n+\t\t0x66, 0xc5, 0x01, 0x9c, 0xc7, 0xd1, 0xc4, 0xd3,\n+\t\t0xea, 0x14, 0x3c, 0xed, 0x74, 0xbb, 0x1b, 0x97,\n+\t\t0x8f, 0xf1, 0x29, 0x39, 0x33, 0x92, 0x93, 0x4e,\n+\t\t0xf5, 0x87, 0x91, 0x61, 0x65, 0x8d, 0x27, 0x8d,\n+\t\t0x76, 0xc1, 0xfa, 0x6a, 0x99, 0x80, 0xb1, 0x9b,\n+\t\t0x29, 0x53, 0xce, 0x3e, 0xb6, 0x9a, 0xce, 0x3c,\n+\t\t0x19, 0x5e, 0x48, 0x83, 0xaa, 0xa7, 0x66, 0x98,\n+\t\t0x59, 0xf4, 0xbb, 0xf2, 0xbc, 0xd9, 0xc5, 0x9a,\n+\t\t0xc8, 0x2c, 0x63, 0x58, 0xd5, 0xd4, 0xbc, 0x03,\n+\t\t0xa9, 0x06, 0xa9, 0x80, 0x0d, 0xb3, 0x46, 0x2d,\n+\t\t0xe3, 0xc6, 0xaf, 0x1a, 0x39, 0x18, 0x7e, 0x1e,\n+\t\t0x83, 0x80, 0x46, 0x11, 0xd2, 0x13, 0x9f, 0xda,\n+\t\t0xfc, 0x2d, 0x42, 0xaa, 0x5a, 0x1d, 0x4c, 0x31,\n+\t\t0xe5, 0x58, 0x78, 0x5e, 0xe2, 0x04, 0xd6, 0x23,\n+\t\t0x7f, 0x3f, 0x06, 0xc0, 0x54, 0xf8,\n \t},\n-\n \t{\n-\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x30, 0x43, 0x24, 0x42, 0x55, 0x08,\n-\t\t0xe4, 0xc2, 0x15, 0xc9, 0xdb, 0x71, 0x69, 0xee,\n-\t\t0x09, 0xc5, 0x1c, 0xfd, 0x46, 0x10, 0xa0, 0x68,\n-\t\t0x21, 0xf2, 0x48, 0xac, 0x6c, 0xc0, 0x2b, 0x62,\n-\t\t0x07, 0x8f, 0x48, 0x33, 0x0a, 0x6b, 0x62, 0x28,\n-\t\t0x2e, 0x2c, 0xad, 0xcb, 0x34, 0x85, 0xca, 0x2e,\n-\t\t0xcd, 0x84, 0xf0,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x72, 0x04, 0x00, 0x00,\n+\t\t0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,\n+\t\t0xe8, 0x4b, 0xfb, 0xef, 0xba, 0xed, 0xc5, 0x36,\n+\t\t0xc8, 0x5a, 0x41, 0x3f, 0x05, 0xfa, 0xfe, 0x48,\n+\t\t0xc3, 0x91, 0x12, 0x8b, 0xe8, 0x32, 0x6a, 0x9f,\n+\t\t0xdc, 0x97, 0xe2, 0x77, 0xb9, 0x96, 0x2d, 0xd4,\n+\t\t0xe5, 0xbd, 0xa1, 0xfd, 0x94, 0xbb, 0x74, 0x63,\n+\t\t0xb1, 0x0c, 0x38, 0xbc, 0x6f, 0x69, 0xaf, 0xa3,\n+\t\t0x46, 0x9c, 0x96, 0x41, 0xde, 0x59, 0x23, 0xff,\n+\t\t0x15, 0x6b, 0x3a, 0xef, 0x91, 0x6d, 0x92, 0x44,\n+\t\t0xdc, 0x72, 0x1f, 0x40, 0x3d, 0xb5, 0x34, 0x8f,\n+\t\t0x2a, 0xac, 0x21, 0x69, 0x05, 0x6f, 0xb2, 0x60,\n+\t\t0x32, 0x5d, 0x3d, 0x97, 0xb4, 0x24, 0x99, 0x14,\n+\t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n+\t\t0x00, 0x30, 0x68, 0x27, 0x97, 0xca, 0x63, 0x09,\n+\t\t0x22, 0xed, 0x0e, 0x61, 0x7c, 0x76, 0x31, 0x9c,\n+\t\t0xbe, 0x27, 0xc9, 0xe6, 0x09, 0xc3, 0xc3, 0xc2,\n+\t\t0xf4, 0xa2, 0x32, 0xba, 0x7c, 0xf2, 0x0f, 0xb8,\n+\t\t0x3d, 0xcb, 0xe2, 0x4c, 0xc0, 0x7d, 0x8e, 0x5b,\n+\t\t0x5a, 0xed, 0x05, 0x5c, 0x15, 0x96, 0x69, 0xc2,\n+\t\t0x6f, 0x5f, 0x17, 0x03, 0x01, 0x00, 0x20, 0x5a,\n+\t\t0xfe, 0x0b, 0xe1, 0x6f, 0xa8, 0x54, 0x19, 0x78,\n+\t\t0xca, 0xba, 0x2e, 0x1e, 0x2e, 0xe1, 0x5d, 0x17,\n+\t\t0xe5, 0x97, 0x05, 0x2c, 0x08, 0x0c, 0xff, 0xa8,\n+\t\t0x59, 0xa9, 0xde, 0x5e, 0x21, 0x34, 0x04, 0x17,\n+\t\t0x03, 0x01, 0x00, 0x30, 0x86, 0xb1, 0x3f, 0x88,\n+\t\t0x43, 0xf0, 0x07, 0xee, 0xa8, 0xf4, 0xbc, 0xe7,\n+\t\t0x5f, 0xc6, 0x8c, 0x86, 0x4c, 0xca, 0x70, 0x88,\n+\t\t0xcc, 0x6a, 0xb4, 0x3d, 0x40, 0xe8, 0x54, 0x89,\n+\t\t0x19, 0x43, 0x1f, 0x76, 0xe2, 0xac, 0xb2, 0x5b,\n+\t\t0x92, 0xf8, 0x57, 0x39, 0x2a, 0xc3, 0x6d, 0x13,\n+\t\t0x45, 0xfa, 0x36, 0x9e, 0x15, 0x03, 0x01, 0x00,\n+\t\t0x20, 0x6d, 0xed, 0x7b, 0x59, 0x28, 0x2a, 0x27,\n+\t\t0x04, 0x15, 0x07, 0x4e, 0xeb, 0x13, 0x00, 0xe3,\n+\t\t0x3a, 0x3f, 0xf8, 0xaa, 0x2b, 0x3b, 0x1a, 0x8c,\n+\t\t0x12, 0xd6, 0x4c, 0xec, 0x2a, 0xaf, 0x33, 0x60,\n+\t\t0xaf,\n \t},\n }\n "}, {"sha": "9230656d6a481d0fdc38d194cd2e959fef69ec9f", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -155,7 +155,7 @@ func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error)\n \t\t\terr = errors.New(\"crypto/tls: failed to parse key PEM data\")\n \t\t\treturn\n \t\t}\n-\t\tif strings.HasSuffix(keyDERBlock.Type, \" PRIVATE KEY\") {\n+\t\tif keyDERBlock.Type == \"PRIVATE KEY\" || strings.HasSuffix(keyDERBlock.Type, \" PRIVATE KEY\") {\n \t\t\tbreak\n \t\t}\n \t}"}, {"sha": "38229014cd662bba804577ed638acd139274999b", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -33,6 +33,19 @@ D2lWusoe2/nEqfDVVWGWlyJ7yOmqaVm/iNUN9B2N2g==\n -----END RSA PRIVATE KEY-----\n `\n \n+// keyPEM is the same as rsaKeyPEM, but declares itself as just\n+// \"PRIVATE KEY\", not \"RSA PRIVATE KEY\".  http://golang.org/issue/4477\n+var keyPEM = `-----BEGIN PRIVATE KEY-----\n+MIIBOwIBAAJBANLJhPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wo\n+k/4xIA+ui35/MmNartNuC+BdZ1tMuVCPFZcCAwEAAQJAEJ2N+zsR0Xn8/Q6twa4G\n+6OB1M1WO+k+ztnX/1SvNeWu8D6GImtupLTYgjZcHufykj09jiHmjHx8u8ZZB/o1N\n+MQIhAPW+eyZo7ay3lMz1V01WVjNKK9QSn1MJlb06h/LuYv9FAiEA25WPedKgVyCW\n+SmUwbPw8fnTcpqDWE3yTO3vKcebqMSsCIBF3UmVue8YU3jybC3NxuXq3wNm34R8T\n+xVLHwDXh/6NJAiEAl2oHGGLz64BuAfjKrqwz7qMYr9HCLIe/YsoWq/olzScCIQDi\n+D2lWusoe2/nEqfDVVWGWlyJ7yOmqaVm/iNUN9B2N2g==\n+-----END PRIVATE KEY-----\n+`\n+\n var ecdsaCertPEM = `-----BEGIN CERTIFICATE-----\n MIIB/jCCAWICCQDscdUxw16XFDAJBgcqhkjOPQQBMEUxCzAJBgNVBAYTAkFVMRMw\n EQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBXaWRnaXRzIFB0\n@@ -62,21 +75,22 @@ kohxS/xfFg/TEwRSSws+roJr4JFKpO2t3/be5OdqmQ==\n \n var keyPairTests = []struct {\n \talgo string\n-\tcert *string\n-\tkey  *string\n+\tcert string\n+\tkey  string\n }{\n-\t{\"ECDSA\", &ecdsaCertPEM, &ecdsaKeyPEM},\n-\t{\"RSA\", &rsaCertPEM, &rsaKeyPEM},\n+\t{\"ECDSA\", ecdsaCertPEM, ecdsaKeyPEM},\n+\t{\"RSA\", rsaCertPEM, rsaKeyPEM},\n+\t{\"RSA-untyped\", rsaCertPEM, keyPEM}, // golang.org/issue/4477\n }\n \n func TestX509KeyPair(t *testing.T) {\n \tvar pem []byte\n \tfor _, test := range keyPairTests {\n-\t\tpem = []byte(*test.cert + *test.key)\n+\t\tpem = []byte(test.cert + test.key)\n \t\tif _, err := X509KeyPair(pem, pem); err != nil {\n \t\t\tt.Errorf(\"Failed to load %s cert followed by %s key: %s\", test.algo, test.algo, err)\n \t\t}\n-\t\tpem = []byte(*test.key + *test.cert)\n+\t\tpem = []byte(test.key + test.cert)\n \t\tif _, err := X509KeyPair(pem, pem); err != nil {\n \t\t\tt.Errorf(\"Failed to load %s key followed by %s cert: %s\", test.algo, test.algo, err)\n \t\t}"}, {"sha": "04d5723c1e27c0d8a0d7eba95b275f258d4fdb1d", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -184,7 +184,7 @@ func Read(r io.Reader, order ByteOrder, data interface{}) error {\n // values, or a pointer to such data.\n // Bytes written to w are encoded using the specified byte order\n // and read from successive fields of the data.\n-// When writing structs, zero values are are written for fields\n+// When writing structs, zero values are written for fields\n // with blank (_) field names.\n func Write(w io.Writer, order ByteOrder, data interface{}) error {\n \t// Fast path for basic types."}, {"sha": "17e485083e9d829b5cb815a3cbe43c11f2ac99c5", "filename": "libgo/go/encoding/csv/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -22,7 +22,7 @@ import (\n //\n // If UseCRLF is true, the Writer ends each record with \\r\\n instead of \\n.\n type Writer struct {\n-\tComma   rune // Field delimiter (set to to ',' by NewWriter)\n+\tComma   rune // Field delimiter (set to ',' by NewWriter)\n \tUseCRLF bool // True to use \\r\\n as the line terminator\n \tw       *bufio.Writer\n }"}, {"sha": "8b6fcfb4c877c50b596e401f39380b8512118864", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -328,7 +328,7 @@ reserved).\n \t01\t// Add 1 to get field number 0: field[1].name\n \t01\t// 1 byte\n \t59\t// structType.field[1].name = \"Y\"\n-\t01\t// Add 1 to get field number 1: field[0].id\n+\t01\t// Add 1 to get field number 1: field[1].id\n \t04\t// struct.Type.field[1].typeId is 2 (signed int).\n \t00\t// End of structType.field[1]; end of structType.field.\n \t00\t// end of wireType.structType structure"}, {"sha": "9a0e51d1fe19bea0193f56bcddb8bc0508f61ce0", "filename": "libgo/go/encoding/gob/timing_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -50,6 +50,7 @@ func BenchmarkEndToEndByteBuffer(b *testing.B) {\n }\n \n func TestCountEncodeMallocs(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tvar buf bytes.Buffer\n \tenc := NewEncoder(&buf)\n \tbench := &Bench{7, 3.2, \"now is the time\", []byte(\"for all good men\")}\n@@ -69,6 +70,7 @@ func TestCountEncodeMallocs(t *testing.T) {\n }\n \n func TestCountDecodeMallocs(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tvar buf bytes.Buffer\n \tenc := NewEncoder(&buf)\n \tbench := &Bench{7, 3.2, \"now is the time\", []byte(\"for all good men\")}"}, {"sha": "17134c5eb4d75f73e6591d43e1a3154588b2e85f", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -45,7 +45,7 @@ const (\n //     - a field with tag \"name,attr\" becomes an attribute with\n //       the given name in the XML element.\n //     - a field with tag \",attr\" becomes an attribute with the\n-//       field name in the in the XML element.\n+//       field name in the XML element.\n //     - a field with tag \",chardata\" is written as character data,\n //       not as an XML element.\n //     - a field with tag \",innerxml\" is written verbatim, not subject"}, {"sha": "2159ec532a29c56957696f736dbc74287080f538", "filename": "libgo/go/exp/cookiejar/jar.go", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fcookiejar%2Fjar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fcookiejar%2Fjar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fcookiejar%2Fjar.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package cookiejar implements an RFC 6265-compliant http.CookieJar.\n+//\n+// TODO: example code to create a memory-backed cookie jar with the default\n+// public suffix list.\n+package cookiejar\n+\n+import (\n+\t\"net/http\"\n+\t\"net/url\"\n+)\n+\n+// PublicSuffixList provides the public suffix of a domain. For example:\n+//      - the public suffix of \"example.com\" is \"com\",\n+//      - the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and\n+//      - the public suffix of \"bar.pvt.k12.wy.us\" is \"pvt.k12.wy.us\".\n+//\n+// Implementations of PublicSuffixList must be safe for concurrent use by\n+// multiple goroutines.\n+//\n+// An implementation that always returns \"\" is valid and may be useful for\n+// testing but it is not secure: it means that the HTTP server for foo.com can\n+// set a cookie for bar.com.\n+type PublicSuffixList interface {\n+\t// PublicSuffix returns the public suffix of domain.\n+\t//\n+\t// TODO: specify which of the caller and callee is responsible for IP\n+\t// addresses, for leading and trailing dots, for case sensitivity, and\n+\t// for IDN/Punycode.\n+\tPublicSuffix(domain string) string\n+\n+\t// String returns a description of the source of this public suffix list.\n+\t// A Jar will store its PublicSuffixList's description in its storage,\n+\t// and update the stored cookies if its list has a different description\n+\t// than the stored list. The description will typically contain something\n+\t// like a time stamp or version number.\n+\tString() string\n+}\n+\n+// Options are the options for creating a new Jar.\n+type Options struct {\n+\t// Storage is the cookie jar storage. It may not be nil.\n+\tStorage Storage\n+\n+\t// PublicSuffixList is the public suffix list that determines whether an\n+\t// HTTP server can set a cookie for a domain. It may not be nil.\n+\tPublicSuffixList PublicSuffixList\n+\n+\t// TODO: ErrorFunc for handling storage errors?\n+}\n+\n+// Jar implements the http.CookieJar interface from the net/http package.\n+type Jar struct {\n+\tstorage Storage\n+\tpsList  PublicSuffixList\n+}\n+\n+// New returns a new cookie jar.\n+func New(o *Options) *Jar {\n+\treturn &Jar{\n+\t\tstorage: o.Storage,\n+\t\tpsList:  o.PublicSuffixList,\n+\t}\n+}\n+\n+// TODO(nigeltao): how do we reject HttpOnly cookies? Do we post-process the\n+// return value from Jar.Cookies?\n+//\n+// HttpOnly cookies are those for regular HTTP(S) requests but should not be\n+// visible from JavaScript. The HttpOnly bit mitigates XSS attacks; it's not\n+// for HTTP vs HTTPS vs FTP transports.\n+\n+// Cookies implements the Cookies method of the http.CookieJar interface.\n+//\n+// It returns an empty slice if the URL's scheme is not HTTP or HTTPS.\n+func (j *Jar) Cookies(u *url.URL) []*http.Cookie {\n+\t// TODO.\n+\treturn nil\n+}\n+\n+// SetCookies implements the SetCookies method of the http.CookieJar interface.\n+//\n+// It does nothing if the URL's scheme is not HTTP or HTTPS.\n+func (j *Jar) SetCookies(u *url.URL, cookies []*http.Cookie) {\n+\t// TODO.\n+}"}, {"sha": "5294f587e4c7d9ebaa4173d3b9d235bba2719d78", "filename": "libgo/go/exp/cookiejar/storage.go", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fcookiejar%2Fstorage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fcookiejar%2Fstorage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fcookiejar%2Fstorage.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cookiejar\n+\n+import (\n+\t\"time\"\n+)\n+\n+// Storage is a Jar's storage. It is a multi-map, mapping keys to one or more\n+// entries. Each entry consists of a subkey, creation time, last access time,\n+// and some arbitrary data.\n+//\n+// The Add and Delete methods have undefined behavior if the key is invalid.\n+// A valid key must use only bytes in the character class [a-z0-9.-] and\n+// must have at least one non-. byte. Note that this excludes any key\n+// containing a capital ASCII letter as well as the empty string.\n+type Storage interface {\n+\t// A client must call Lock before calling other methods and must call\n+\t// Unlock when finished. Between the calls to Lock and Unlock, a client\n+\t// can assume that other clients are not modifying the Storage.\n+\tLock()\n+\tUnlock()\n+\n+\t// Add adds entries to the storage. Each entry's Subkey and Data must\n+\t// both be non-empty.\n+\t//\n+\t// If the Storage already contains an entry with the same key and\n+\t// subkey then the new entry is stored with the creation time of the\n+\t// old entry, and the old entry is deleted.\n+\t//\n+\t// Adding entries may cause other entries to be deleted, to maintain an\n+\t// implementation-specific storage constraint.\n+\tAdd(key string, entries ...Entry) error\n+\n+\t// Delete deletes all entries for the given key.\n+\tDelete(key string) error\n+\n+\t// Entries calls f for each entry stored for that key. If f returns a\n+\t// non-nil error then the iteration stops and Entries returns that\n+\t// error. Iteration is not guaranteed to be in any particular order.\n+\t//\n+\t// If f returns an Update action then that stored entry's LastAccess\n+\t// time will be set to the time that f returned. If f returns a Delete\n+\t// action then that entry will be deleted from the Storage.\n+\t//\n+\t// f may call a Storage's Add and Delete methods; those modifications\n+\t// will not affect the list of entries visited in this call to Entries.\n+\tEntries(key string, f func(entry Entry) (Action, time.Time, error)) error\n+\n+\t// Keys calls f for each key stored. f will not be called on a key with\n+\t// zero entries. If f returns a non-nil error then the iteration stops\n+\t// and Keys returns that error. Iteration is not guaranteed to be in any\n+\t// particular order.\n+\t//\n+\t// f may call a Storage's Add, Delete and Entries methods; those\n+\t// modifications will not affect the list of keys visited in this call\n+\t// to Keys.\n+\tKeys(f func(key string) error) error\n+}\n+\n+// Entry is an entry in a Storage.\n+type Entry struct {\n+\tSubkey     string\n+\tData       string\n+\tCreation   time.Time\n+\tLastAccess time.Time\n+}\n+\n+// Action is an action returned by the function passed to Entries.\n+type Action int\n+\n+const (\n+\t// Pass means to take no further action with an Entry.\n+\tPass Action = iota\n+\t// Update means to update the LastAccess time of an Entry.\n+\tUpdate\n+\t// Delete means to delete an Entry.\n+\tDelete\n+)\n+\n+// ValidStorageKey returns whether the given key is valid for a Storage.\n+func ValidStorageKey(key string) bool {\n+\thasNonDot := false\n+\tfor i := 0; i < len(key); i++ {\n+\t\tswitch c := key[i]; {\n+\t\tcase 'a' <= c && c <= 'z':\n+\t\t\tfallthrough\n+\t\tcase '0' <= c && c <= '9':\n+\t\t\tfallthrough\n+\t\tcase c == '-':\n+\t\t\thasNonDot = true\n+\t\tcase c == '.':\n+\t\t\t// No-op.\n+\t\tdefault:\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn hasNonDot\n+}"}, {"sha": "de6aa2b6a7f1674d5a9bda03160a8059b34be9e2", "filename": "libgo/go/exp/cookiejar/storage_test.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fcookiejar%2Fstorage_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fcookiejar%2Fstorage_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fcookiejar%2Fstorage_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cookiejar\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var validStorageKeyTests = map[string]bool{\n+\t\"\":            false,\n+\t\".\":           false,\n+\t\"..\":          false,\n+\t\"/\":           false,\n+\t\"EXAMPLE.com\": false,\n+\t\"\\n\":          false,\n+\t\"\\r\":          false,\n+\t\"\\r\\n\":        false,\n+\t\"\\x00\":        false,\n+\t\"back\\\\slash\": false,\n+\t\"co:lon\":      false,\n+\t\"com,ma\":      false,\n+\t\"semi;colon\":  false,\n+\t\"sl/ash\":      false,\n+\t\"sp ace\":      false,\n+\t\"under_score\": false,\n+\t\"\u03c0\":           false,\n+\n+\t\"-\":                true,\n+\t\".dot\":             true,\n+\t\".dot.\":            true,\n+\t\".metadata\":        true,\n+\t\".x..y..z...\":      true,\n+\t\"dot.\":             true,\n+\t\"example.com\":      true,\n+\t\"foo\":              true,\n+\t\"hy-phen\":          true,\n+\t\"xn--bcher-kva.ch\": true,\n+}\n+\n+func TestValidStorageKey(t *testing.T) {\n+\tfor key, want := range validStorageKeyTests {\n+\t\tif got := ValidStorageKey(key); got != want {\n+\t\t\tt.Errorf(\"%q: got %v, want %v\", key, got, want)\n+\t\t}\n+\t}\n+}"}, {"sha": "2d58f32883951868ef37a50cf5f4967247f74961", "filename": "libgo/go/exp/gotype/gotype_test.go", "status": "modified", "additions": 178, "deletions": 19, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -5,47 +5,206 @@\n package main\n \n import (\n+\t\"go/build\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n-func runTest(t *testing.T, path, pkg string) {\n+func runTest(t *testing.T, path string) {\n \texitCode = 0\n-\t*pkgName = pkg\n-\t*recursive = false\n \n-\tif pkg == \"\" {\n+\t*recursive = false\n+\tif suffix := \".go\"; strings.HasSuffix(path, suffix) {\n+\t\t// single file\n+\t\tpath = filepath.Join(runtime.GOROOT(), \"src/pkg\", path)\n+\t\tpath, file := filepath.Split(path)\n+\t\t*pkgName = file[:len(file)-len(suffix)]\n \t\tprocessFiles([]string{path}, true)\n \t} else {\n-\t\tprocessDirectory(path)\n+\t\t// package directory\n+\t\t// TODO(gri) gotype should use the build package instead\n+\t\tpkg, err := build.Import(path, \"\", 0)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"build.Import error for path = %s: %s\", path, err)\n+\t\t\treturn\n+\t\t}\n+\t\t// TODO(gri) there ought to be a more direct way using the build package...\n+\t\tfiles := make([]string, len(pkg.GoFiles))\n+\t\tfor i, file := range pkg.GoFiles {\n+\t\t\tfiles[i] = filepath.Join(pkg.Dir, file)\n+\t\t}\n+\t\t*pkgName = pkg.Name\n+\t\tprocessFiles(files, true)\n \t}\n \n \tif exitCode != 0 {\n \t\tt.Errorf(\"processing %s failed: exitCode = %d\", path, exitCode)\n \t}\n }\n \n-var tests = []struct {\n-\tpath string\n-\tpkg  string\n-}{\n+var tests = []string{\n \t// individual files\n-\t{\"testdata/test1.go\", \"\"},\n+\t\"exp/gotype/testdata/test1.go\",\n \n \t// directories\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/ast\"), \"ast\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/build\"), \"build\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/doc\"), \"doc\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/parser\"), \"parser\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/printer\"), \"printer\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/scanner\"), \"scanner\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/token\"), \"token\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/exp/types\"), \"types\"},\n+\t// Note: packages that don't typecheck yet are commented out\n+\t// \"archive/tar\", // investigate\n+\t\"archive/zip\",\n+\n+\t\"bufio\",\n+\t\"bytes\",\n+\n+\t\"compress/bzip2\",\n+\t\"compress/flate\",\n+\t\"compress/gzip\",\n+\t\"compress/lzw\",\n+\t\"compress/zlib\",\n+\n+\t\"container/heap\",\n+\t\"container/list\",\n+\t\"container/ring\",\n+\n+\t\"crypto\",\n+\t\"crypto/aes\",\n+\t\"crypto/cipher\",\n+\t\"crypto/des\",\n+\t\"crypto/dsa\",\n+\t\"crypto/ecdsa\",\n+\t\"crypto/elliptic\",\n+\t\"crypto/hmac\",\n+\t\"crypto/md5\",\n+\t\"crypto/rand\",\n+\t\"crypto/rc4\",\n+\t// \"crypto/rsa\", // investigate (GOARCH=386)\n+\t\"crypto/sha1\",\n+\t\"crypto/sha256\",\n+\t\"crypto/sha512\",\n+\t\"crypto/subtle\",\n+\t\"crypto/tls\",\n+\t// \"crypto/x509\", // investigate\n+\t\"crypto/x509/pkix\",\n+\n+\t\"database/sql\",\n+\t\"database/sql/driver\",\n+\n+\t\"debug/dwarf\",\n+\t\"debug/elf\",\n+\t\"debug/gosym\",\n+\t\"debug/macho\",\n+\t\"debug/pe\",\n+\n+\t\"encoding/ascii85\",\n+\t\"encoding/asn1\",\n+\t\"encoding/base32\",\n+\t\"encoding/base64\",\n+\t// \"encoding/binary\", // complex() doesn't work yet\n+\t\"encoding/csv\",\n+\t// \"encoding/gob\", // complex() doesn't work yet\n+\t\"encoding/hex\",\n+\t\"encoding/json\",\n+\t\"encoding/pem\",\n+\t\"encoding/xml\",\n+\n+\t\"errors\",\n+\t\"expvar\",\n+\t\"flag\",\n+\t\"fmt\",\n+\n+\t\"exp/types\",\n+\t\"exp/gotype\",\n+\n+\t\"go/ast\",\n+\t\"go/build\",\n+\t// \"go/doc\", // variadic parameters don't work yet fully\n+\t\"go/format\",\n+\t\"go/parser\",\n+\t\"go/printer\",\n+\t\"go/scanner\",\n+\t\"go/token\",\n+\n+\t\"hash/adler32\",\n+\t// \"hash/crc32\", // investigate\n+\t\"hash/crc64\",\n+\t\"hash/fnv\",\n+\n+\t\"image\",\n+\t\"image/color\",\n+\t\"image/draw\",\n+\t\"image/gif\",\n+\t\"image/jpeg\",\n+\t\"image/png\",\n+\n+\t\"index/suffixarray\",\n+\n+\t\"io\",\n+\t// \"io/ioutil\", // investigate\n+\n+\t\"log\",\n+\t\"log/syslog\",\n+\n+\t\"math\",\n+\t// \"math/big\", // investigate\n+\t// \"math/cmplx\", // complex doesn't work yet\n+\t\"math/rand\",\n+\n+\t\"mime\",\n+\t\"mime/multipart\",\n+\n+\t// \"net\", // depends on C files\n+\t\"net/http\",\n+\t\"net/http/cgi\",\n+\t// \"net/http/fcgi\", // investigate\n+\t\"net/http/httptest\",\n+\t\"net/http/httputil\",\n+\t// \"net/http/pprof\", // investigate\n+\t\"net/mail\",\n+\t// \"net/rpc\", // investigate\n+\t\"net/rpc/jsonrpc\",\n+\t\"net/smtp\",\n+\t\"net/textproto\",\n+\t\"net/url\",\n+\n+\t// \"path\", // variadic parameters don't work yet fully\n+\t// \"path/filepath\", // investigate\n+\n+\t// \"reflect\", // investigate\n+\n+\t\"regexp\",\n+\t\"regexp/syntax\",\n+\n+\t\"runtime\",\n+\t// \"runtime/cgo\", // import \"C\"\n+\t\"runtime/debug\",\n+\t\"runtime/pprof\",\n+\n+\t\"sort\",\n+\t// \"strconv\", // investigate\n+\t\"strings\",\n+\n+\t// \"sync\", // platform-specific files\n+\t// \"sync/atomic\", // platform-specific files\n+\n+\t// \"syscall\", // platform-specific files\n+\n+\t\"testing\",\n+\t\"testing/iotest\",\n+\t\"testing/quick\",\n+\n+\t\"text/scanner\",\n+\t\"text/tabwriter\",\n+\t// \"text/template\", // variadic parameters don't work yet fully\n+\t// \"text/template/parse\", // variadic parameters don't work yet fully\n+\n+\t// \"time\", // platform-specific files\n+\t\"unicode\",\n+\t\"unicode/utf16\",\n+\t\"unicode/utf8\",\n }\n \n func Test(t *testing.T) {\n \tfor _, test := range tests {\n-\t\trunTest(t, test.path, test.pkg)\n+\t\trunTest(t, test)\n \t}\n }"}, {"sha": "6a6f477e7807a72a6c3b9ed9b9bdcf960c86e0e8", "filename": "libgo/go/exp/gotype/testdata/test1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package p\n+package test1\n \n func _() {\n \t// the scope of a local type declaration starts immediately after the type name"}, {"sha": "8a5c9dc7a86a88ad7ef4bacc3997f68709dc8296", "filename": "libgo/go/exp/locale/collate/collate.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -450,7 +450,7 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []colElem) {\n \t\t}\n \t\t// Derive the quaternary weights from the options and other levels.\n \t\t// Note that we represent maxQuaternary as 0xFF. The first byte of the\n-\t\t// representation of a a primary weight is always smaller than 0xFF,\n+\t\t// representation of a primary weight is always smaller than 0xFF,\n \t\t// so using this single byte value will compare correctly.\n \t\tif Quaternary <= c.Strength && c.Alternate >= AltShifted {\n \t\t\tif c.Alternate == AltShiftTrimmed {"}, {"sha": "af2d0c64d1113326671e1ba004095d9f4e4e46a1", "filename": "libgo/go/exp/types/check.go", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -36,7 +36,7 @@ type checker struct {\n //\n // TODO(gri) This is very similar to the declare function in go/parser; it\n // is only used to associate methods with their respective receiver base types.\n-// In a future version, it might be simpler and cleaner do to all the resolution\n+// In a future version, it might be simpler and cleaner to do all the resolution\n // in the type-checking phase. It would simplify the parser, AST, and also\n // reduce some amount of code duplication.\n //\n@@ -188,14 +188,13 @@ func (check *checker) object(obj *ast.Object, cycleOk bool) {\n \n \tcase ast.Fun:\n \t\tfdecl := obj.Decl.(*ast.FuncDecl)\n-\t\tif fdecl.Recv != nil {\n-\t\t\t// This will ensure that the method base type is\n-\t\t\t// type-checked\n-\t\t\tcheck.collectFields(token.FUNC, fdecl.Recv, true)\n-\t\t}\n+\t\tcheck.collectParams(fdecl.Recv, false) // ensure method base is type-checked\n \t\tftyp := check.typ(fdecl.Type, cycleOk).(*Signature)\n \t\tobj.Type = ftyp\n-\t\tcheck.function(ftyp, fdecl.Body)\n+\t\t// functions implemented elsewhere (say in assembly) have no body\n+\t\tif fdecl.Body != nil {\n+\t\t\tcheck.function(ftyp, fdecl.Body)\n+\t\t}\n \n \tdefault:\n \t\tpanic(\"unreachable\")\n@@ -355,12 +354,19 @@ func check(fset *token.FileSet, pkg *ast.Package, errh func(token.Pos, string),\n \tcheck.mapf = f\n \tcheck.initexprs = make(map[*ast.ValueSpec][]ast.Expr)\n \n-\t// handle bailouts\n+\t// handle panics\n \tdefer func() {\n-\t\tif p := recover(); p != nil {\n-\t\t\t_ = p.(bailout) // re-panic if not a bailout\n+\t\tswitch p := recover().(type) {\n+\t\tcase nil:\n+\t\t\t// normal return - nothing to do\n+\t\tcase bailout:\n+\t\t\t// early exit\n+\t\t\terr = check.firsterr\n+\t\tdefault:\n+\t\t\t// unexpected panic: don't crash clients\n+\t\t\t// panic(p) // enable for debugging\n+\t\t\terr = fmt.Errorf(\"types.check internal error: %v\", p)\n \t\t}\n-\t\terr = check.firsterr\n \t}()\n \n \t// determine missing constant initialization expressions"}, {"sha": "9a80278d23c8e742f6c13fe052c2ef5ec853e4bb", "filename": "libgo/go/exp/types/check_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -49,6 +49,7 @@ var tests = []struct {\n \t{\"decls0\", []string{\"testdata/decls0.src\"}},\n \t{\"decls1\", []string{\"testdata/decls1.src\"}},\n \t{\"decls2\", []string{\"testdata/decls2a.src\", \"testdata/decls2b.src\"}},\n+\t{\"decls3\", []string{\"testdata/decls3.src\"}},\n \t{\"const0\", []string{\"testdata/const0.src\"}},\n \t{\"expr0\", []string{\"testdata/expr0.src\"}},\n \t{\"expr1\", []string{\"testdata/expr1.src\"}},"}, {"sha": "c678e4749b0c9df84e8fb97a0ff43355f36621ed", "filename": "libgo/go/exp/types/const.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -278,7 +278,7 @@ func isRepresentableConst(x interface{}, as BasicKind) bool {\n \t\treturn as == String || as == UntypedString\n \n \tcase nilType:\n-\t\treturn as == UntypedNil\n+\t\treturn as == UntypedNil || as == UnsafePointer\n \n \tdefault:\n \t\tunreachable()"}, {"sha": "e1f627b98f27baaeda54275266ac3fd4c42ecdbb", "filename": "libgo/go/exp/types/expr.go", "status": "modified", "additions": 434, "deletions": 144, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -12,75 +12,131 @@ import (\n \t\"strconv\"\n )\n \n-// TODO(gri)\n+// TODO(gri) Cleanups\n // - don't print error messages referring to invalid types (they are likely spurious errors)\n // - simplify invalid handling: maybe just use Typ[Invalid] as marker, get rid of invalid Mode for values?\n // - rethink error handling: should all callers check if x.mode == valid after making a call?\n+// - at the moment, iota is passed around almost everywhere - in many places we know it cannot be used\n \n-func (check *checker) tag(field *ast.Field) string {\n-\tif t := field.Tag; t != nil {\n-\t\tassert(t.Kind == token.STRING)\n-\t\tif tag, err := strconv.Unquote(t.Value); err == nil {\n-\t\t\treturn tag\n+// TODO(gri) API issues\n+// - clients need access to result type information (tuples)\n+// - clients need access to constant values\n+// - clients need access to built-in type information\n+\n+// TODO(gri) Bugs\n+// - expression hints are (correctly) used untyped for composite literal components, but also\n+//   in possibly overlapping use as hints for shift expressions - investigate\n+\n+func (check *checker) collectParams(list *ast.FieldList, variadicOk bool) (params ObjList, isVariadic bool) {\n+\tif list == nil {\n+\t\treturn\n+\t}\n+\tvar last *ast.Object\n+\tfor i, field := range list.List {\n+\t\tftype := field.Type\n+\t\tif t, _ := ftype.(*ast.Ellipsis); t != nil {\n+\t\t\tftype = t.Elt\n+\t\t\tif variadicOk && i == len(list.List)-1 {\n+\t\t\t\tisVariadic = true\n+\t\t\t} else {\n+\t\t\t\tcheck.invalidAST(field.Pos(), \"... not permitted\")\n+\t\t\t\t// ok to continue\n+\t\t\t}\n+\t\t}\n+\t\t// the parser ensures that f.Tag is nil and we don't\n+\t\t// care if a constructed AST contains a non-nil tag\n+\t\ttyp := check.typ(ftype, true)\n+\t\tif len(field.Names) > 0 {\n+\t\t\t// named parameter\n+\t\t\tfor _, name := range field.Names {\n+\t\t\t\tobj := name.Obj\n+\t\t\t\tobj.Type = typ\n+\t\t\t\tparams = append(params, obj)\n+\t\t\t\tlast = obj\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// anonymous parameter\n+\t\t\tobj := ast.NewObj(ast.Var, \"\")\n+\t\t\tobj.Type = typ\n+\t\t\tparams = append(params, obj)\n+\t\t\tlast = obj\n \t\t}\n-\t\tcheck.invalidAST(t.Pos(), \"incorrect tag syntax: %q\", t.Value)\n \t}\n-\treturn \"\"\n+\t// For a variadic function, change the last parameter's object type\n+\t// from T to []T (this is the type used inside the function), but\n+\t// keep a copy of the object with the original type T in the params\n+\t// list (this is the externally visible type).\n+\tif isVariadic {\n+\t\t// if isVariadic is set, last must exist and len(params) > 0\n+\t\tcopy := *last\n+\t\tlast.Type = &Slice{Elt: last.Type.(Type)}\n+\t\tparams[len(params)-1] = &copy\n+\t}\n+\treturn\n }\n \n-// collectFields collects interface methods (tok = token.INTERFACE), and function arguments/results (tok = token.FUNC).\n-func (check *checker) collectFields(tok token.Token, list *ast.FieldList, cycleOk bool) (fields ObjList, tags []string, isVariadic bool) {\n-\tif list != nil {\n-\t\tfor _, field := range list.List {\n-\t\t\tftype := field.Type\n-\t\t\tif t, ok := ftype.(*ast.Ellipsis); ok {\n-\t\t\t\tftype = t.Elt\n-\t\t\t\tisVariadic = true\n+func (check *checker) collectMethods(list *ast.FieldList) (methods ObjList) {\n+\tif list == nil {\n+\t\treturn\n+\t}\n+\tfor _, f := range list.List {\n+\t\ttyp := check.typ(f.Type, len(f.Names) > 0) // cycles are not ok for embedded interfaces\n+\t\t// the parser ensures that f.Tag is nil and we don't\n+\t\t// care if a constructed AST contains a non-nil tag\n+\t\tif len(f.Names) > 0 {\n+\t\t\t// methods (the parser ensures that there's only one\n+\t\t\t// and we don't care if a constructed AST has more)\n+\t\t\tif _, ok := typ.(*Signature); !ok {\n+\t\t\t\tcheck.invalidAST(f.Type.Pos(), \"%s is not a method signature\", typ)\n+\t\t\t\tcontinue\n \t\t\t}\n-\t\t\ttyp := check.typ(ftype, cycleOk)\n-\t\t\ttag := check.tag(field)\n-\t\t\tif len(field.Names) > 0 {\n-\t\t\t\t// named fields\n-\t\t\t\tfor _, name := range field.Names {\n-\t\t\t\t\tobj := name.Obj\n-\t\t\t\t\tobj.Type = typ\n-\t\t\t\t\tfields = append(fields, obj)\n-\t\t\t\t\tif tok == token.STRUCT {\n-\t\t\t\t\t\ttags = append(tags, tag)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// anonymous field\n-\t\t\t\tswitch tok {\n-\t\t\t\tcase token.FUNC:\n-\t\t\t\t\tobj := ast.NewObj(ast.Var, \"\")\n-\t\t\t\t\tobj.Type = typ\n-\t\t\t\t\tfields = append(fields, obj)\n-\t\t\t\tcase token.INTERFACE:\n-\t\t\t\t\tutyp := underlying(typ)\n-\t\t\t\t\tif typ, ok := utyp.(*Interface); ok {\n-\t\t\t\t\t\t// TODO(gri) This is not good enough. Check for double declarations!\n-\t\t\t\t\t\tfields = append(fields, typ.Methods...)\n-\t\t\t\t\t} else if utyp != Typ[Invalid] {\n-\t\t\t\t\t\t// if utyp is invalid, don't complain (the root cause was reported before)\n-\t\t\t\t\t\tcheck.errorf(ftype.Pos(), \"interface contains embedded non-interface type\")\n-\t\t\t\t\t}\n-\t\t\t\tdefault:\n-\t\t\t\t\tpanic(\"unreachable\")\n-\t\t\t\t}\n+\t\t\tfor _, name := range f.Names {\n+\t\t\t\tobj := name.Obj\n+\t\t\t\tobj.Type = typ\n+\t\t\t\tmethods = append(methods, obj)\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// embedded interface\n+\t\t\tutyp := underlying(typ)\n+\t\t\tif ityp, ok := utyp.(*Interface); ok {\n+\t\t\t\tmethods = append(methods, ityp.Methods...)\n+\t\t\t} else if utyp != Typ[Invalid] {\n+\t\t\t\t// if utyp is invalid, don't complain (the root cause was reported before)\n+\t\t\t\tcheck.errorf(f.Type.Pos(), \"%s is not an interface type\", typ)\n \t\t\t}\n \t\t}\n \t}\n+\t// check for double declarations\n+\tmethods.Sort()\n+\tprev := \"\"\n+\tfor _, obj := range methods {\n+\t\tif obj.Name == prev {\n+\t\t\tcheck.errorf(list.Pos(), \"multiple methods named %s\", prev)\n+\t\t\treturn // keep multiple entries, lookup will only return the first entry\n+\t\t}\n+\t}\n \treturn\n }\n \n-func (check *checker) collectStructFields(list *ast.FieldList, cycleOk bool) (fields []*StructField) {\n+func (check *checker) tag(t *ast.BasicLit) string {\n+\tif t != nil {\n+\t\tif t.Kind == token.STRING {\n+\t\t\tif val, err := strconv.Unquote(t.Value); err == nil {\n+\t\t\t\treturn val\n+\t\t\t}\n+\t\t}\n+\t\tcheck.invalidAST(t.Pos(), \"incorrect tag syntax: %q\", t.Value)\n+\t}\n+\treturn \"\"\n+}\n+\n+func (check *checker) collectFields(list *ast.FieldList, cycleOk bool) (fields []*StructField) {\n \tif list == nil {\n \t\treturn\n \t}\n \tfor _, f := range list.List {\n \t\ttyp := check.typ(f.Type, cycleOk)\n-\t\ttag := check.tag(f)\n+\t\ttag := check.tag(f.Tag)\n \t\tif len(f.Names) > 0 {\n \t\t\t// named fields\n \t\t\tfor _, name := range f.Names {\n@@ -90,9 +146,9 @@ func (check *checker) collectStructFields(list *ast.FieldList, cycleOk bool) (fi\n \t\t\t// anonymous field\n \t\t\tswitch t := deref(typ).(type) {\n \t\t\tcase *Basic:\n-\t\t\t\tfields = append(fields, &StructField{t.Name, t, tag, true})\n+\t\t\t\tfields = append(fields, &StructField{t.Name, typ, tag, true})\n \t\t\tcase *NamedType:\n-\t\t\t\tfields = append(fields, &StructField{t.Obj.Name, t, tag, true})\n+\t\t\t\tfields = append(fields, &StructField{t.Obj.Name, typ, tag, true})\n \t\t\tdefault:\n \t\t\t\tif typ != Typ[Invalid] {\n \t\t\t\t\tcheck.invalidAST(f.Type.Pos(), \"anonymous field type %s must be named\", typ)\n@@ -115,9 +171,6 @@ var unaryOpPredicates = opPredicates{\n func (check *checker) op(m opPredicates, x *operand, op token.Token) bool {\n \tif pred := m[op]; pred != nil {\n \t\tif !pred(x.typ) {\n-\t\t\t// TODO(gri) better error message for <-x where x is a send-only channel\n-\t\t\t//           (<- is defined but not permitted). Special-case here or\n-\t\t\t//           handle higher up.\n \t\t\tcheck.invalidOp(x.pos(), \"operator %s not defined for %s\", op, x)\n \t\t\treturn false\n \t\t}\n@@ -173,7 +226,7 @@ func (check *checker) unary(x *operand, op token.Token) {\n \t\t}\n \t\t// Typed constants must be representable in\n \t\t// their type after each constant operation.\n-\t\tcheck.isRepresentable(x, x.typ.(*Basic))\n+\t\tcheck.isRepresentable(x, underlying(x.typ).(*Basic))\n \t\treturn\n \t}\n \n@@ -424,34 +477,107 @@ func (check *checker) binary(x, y *operand, op token.Token, hint Type) {\n }\n \n // index checks an index expression for validity. If length >= 0, it is the upper\n-// bound for the index. The result is a valid integer constant, or nil.\n+// bound for the index. The result is a valid index >= 0, or a negative value.\n //\n-func (check *checker) index(index ast.Expr, length int64, iota int) interface{} {\n+func (check *checker) index(index ast.Expr, length int64, iota int) int64 {\n \tvar x operand\n \n \tcheck.expr(&x, index, nil, iota)\n \tif !x.isInteger() {\n \t\tcheck.errorf(x.pos(), \"index %s must be integer\", &x)\n-\t\treturn nil\n+\t\treturn -1\n \t}\n \tif x.mode != constant {\n-\t\treturn nil // we cannot check more\n+\t\treturn -1 // we cannot check more\n \t}\n-\t// x.mode == constant and the index value must be >= 0\n-\tif isNegConst(x.val) {\n+\t// The spec doesn't require int64 indices, but perhaps it should.\n+\ti, ok := x.val.(int64)\n+\tif !ok {\n+\t\tcheck.errorf(x.pos(), \"stupid index %s\", &x)\n+\t\treturn -1\n+\t}\n+\tif i < 0 {\n \t\tcheck.errorf(x.pos(), \"index %s must not be negative\", &x)\n-\t\treturn nil\n+\t\treturn -1\n \t}\n-\t// x.val >= 0\n-\tif length >= 0 && compareConst(x.val, length, token.GEQ) {\n+\tif length >= 0 && i >= length {\n \t\tcheck.errorf(x.pos(), \"index %s is out of bounds (>= %d)\", &x, length)\n-\t\treturn nil\n+\t\treturn -1\n+\t}\n+\n+\treturn i\n+}\n+\n+// indexElts checks the elements (elts) of an array or slice composite literal\n+// against the literals element type (typ), and the element indices against\n+// the literal length if known (length >= 0). It returns the length of the\n+// literal (maximum index value + 1).\n+//\n+func (check *checker) indexedElts(elts []ast.Expr, typ Type, length int64, iota int) int64 {\n+\tvisited := make(map[int64]bool, len(elts))\n+\tvar index, max int64\n+\tfor _, e := range elts {\n+\t\t// determine and check index\n+\t\tvalidIndex := false\n+\t\teval := e\n+\t\tif kv, _ := e.(*ast.KeyValueExpr); kv != nil {\n+\t\t\tif i := check.index(kv.Key, length, iota); i >= 0 {\n+\t\t\t\tindex = i\n+\t\t\t\tvalidIndex = true\n+\t\t\t}\n+\t\t\teval = kv.Value\n+\t\t} else if length >= 0 && index >= length {\n+\t\t\tcheck.errorf(e.Pos(), \"index %d is out of bounds (>= %d)\", index, length)\n+\t\t} else {\n+\t\t\tvalidIndex = true\n+\t\t}\n+\n+\t\t// if we have a valid index, check for duplicate entries\n+\t\tif validIndex {\n+\t\t\tif visited[index] {\n+\t\t\t\tcheck.errorf(e.Pos(), \"duplicate index %d in array or slice literal\", index)\n+\t\t\t}\n+\t\t\tvisited[index] = true\n+\t\t}\n+\t\tindex++\n+\t\tif index > max {\n+\t\t\tmax = index\n+\t\t}\n+\n+\t\t// check element against composite literal element type\n+\t\tvar x operand\n+\t\tcheck.expr(&x, eval, typ, iota)\n+\t\tif !x.isAssignable(typ) {\n+\t\t\tcheck.errorf(x.pos(), \"cannot use %s as %s value in array or slice literal\", &x, typ)\n+\t\t}\n+\t}\n+\treturn max\n+}\n+\n+func (check *checker) argument(sig *Signature, i int, arg ast.Expr) {\n+\tvar par *ast.Object\n+\tif n := len(sig.Params); i < n {\n+\t\tpar = sig.Params[i]\n+\t} else if sig.IsVariadic {\n+\t\tpar = sig.Params[n-1]\n+\t} else {\n+\t\tcheck.errorf(arg.Pos(), \"too many arguments\")\n+\t\treturn\n \t}\n \n-\treturn x.val\n+\t// TODO(gri) deal with ... last argument\n+\tvar z, x operand\n+\tz.mode = variable\n+\tz.expr = nil            // TODO(gri) can we do better here?\n+\tz.typ = par.Type.(Type) // TODO(gri) should become something like checkObj(&z, ...) eventually\n+\tcheck.expr(&x, arg, z.typ, -1)\n+\tif x.mode == invalid {\n+\t\treturn // ignore this argument\n+\t}\n+\tcheck.assignOperand(&z, &x)\n }\n \n-func (check *checker) callRecord(x *operand) {\n+func (check *checker) recordType(x *operand) {\n \tif x.mode != invalid {\n \t\tcheck.mapf(x.expr, x.typ)\n \t}\n@@ -470,7 +596,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t}\n \n \tif check.mapf != nil {\n-\t\tdefer check.callRecord(x)\n+\t\tdefer check.recordType(x)\n \t}\n \n \tswitch e := e.(type) {\n@@ -527,7 +653,10 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\tx.typ = obj.Type.(Type)\n \n \tcase *ast.Ellipsis:\n-\t\tunimplemented()\n+\t\t// ellipses are handled explictly where they are legal\n+\t\t// (array composite literals and parameter lists)\n+\t\tcheck.errorf(e.Pos(), \"invalid use of '...'\")\n+\t\tgoto Error\n \n \tcase *ast.BasicLit:\n \t\tx.setConst(e.Kind, e.Value)\n@@ -537,27 +666,146 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t}\n \n \tcase *ast.FuncLit:\n-\t\tx.mode = value\n-\t\tx.typ = check.typ(e.Type, false)\n-\t\t// TODO(gri) handle errors (e.g. x.typ is not a *Signature)\n-\t\tcheck.function(x.typ.(*Signature), e.Body)\n+\t\tif typ, ok := check.typ(e.Type, false).(*Signature); ok {\n+\t\t\tx.mode = value\n+\t\t\tx.typ = typ\n+\t\t\tcheck.function(typ, e.Body)\n+\t\t} else {\n+\t\t\tcheck.invalidAST(e.Pos(), \"invalid function literal %s\", e)\n+\t\t\tgoto Error\n+\t\t}\n \n \tcase *ast.CompositeLit:\n-\t\t// TODO(gri)\n-\t\t//\t- determine element type if nil\n-\t\t//\t- deal with map elements\n-\t\tvar typ Type\n+\t\ttyp := hint\n+\t\topenArray := false\n \t\tif e.Type != nil {\n-\t\t\t// TODO(gri) Fix this - just to get going for now\n-\t\t\ttyp = check.typ(e.Type, false)\n+\t\t\t// [...]T array types may only appear with composite literals.\n+\t\t\t// Check for them here so we don't have to handle ... in general.\n+\t\t\ttyp = nil\n+\t\t\tif atyp, _ := e.Type.(*ast.ArrayType); atyp != nil && atyp.Len != nil {\n+\t\t\t\tif ellip, _ := atyp.Len.(*ast.Ellipsis); ellip != nil && ellip.Elt == nil {\n+\t\t\t\t\t// We have an \"open\" [...]T array type.\n+\t\t\t\t\t// Create a new ArrayType with unknown length (-1)\n+\t\t\t\t\t// and finish setting it up after analyzing the literal.\n+\t\t\t\t\ttyp = &Array{Len: -1, Elt: check.typ(atyp.Elt, cycleOk)}\n+\t\t\t\t\topenArray = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif typ == nil {\n+\t\t\t\ttyp = check.typ(e.Type, false)\n+\t\t\t}\n \t\t}\n-\t\tfor _, e := range e.Elts {\n-\t\t\tvar x operand\n-\t\t\tcheck.expr(&x, e, hint, iota)\n-\t\t\t// TODO(gri) check assignment compatibility to element type\n+\t\tif typ == nil {\n+\t\t\tcheck.errorf(e.Pos(), \"missing type in composite literal\")\n+\t\t\tgoto Error\n+\t\t}\n+\n+\t\tswitch utyp := underlying(deref(typ)).(type) {\n+\t\tcase *Struct:\n+\t\t\tif len(e.Elts) == 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tfields := utyp.Fields\n+\t\t\tif _, ok := e.Elts[0].(*ast.KeyValueExpr); ok {\n+\t\t\t\t// all elements must have keys\n+\t\t\t\tvisited := make([]bool, len(fields))\n+\t\t\t\tfor _, e := range e.Elts {\n+\t\t\t\t\tkv, _ := e.(*ast.KeyValueExpr)\n+\t\t\t\t\tif kv == nil {\n+\t\t\t\t\t\tcheck.errorf(e.Pos(), \"mixture of field:value and value elements in struct literal\")\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tkey, _ := kv.Key.(*ast.Ident)\n+\t\t\t\t\tif key == nil {\n+\t\t\t\t\t\tcheck.errorf(kv.Pos(), \"invalid field name %s in struct literal\", kv.Key)\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\ti := utyp.fieldIndex(key.Name)\n+\t\t\t\t\tif i < 0 {\n+\t\t\t\t\t\tcheck.errorf(kv.Pos(), \"unknown field %s in struct literal\", key.Name)\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\t// 0 <= i < len(fields)\n+\t\t\t\t\tif visited[i] {\n+\t\t\t\t\t\tcheck.errorf(kv.Pos(), \"duplicate field name %s in struct literal\", key.Name)\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tvisited[i] = true\n+\t\t\t\t\tcheck.expr(x, kv.Value, nil, iota)\n+\t\t\t\t\tetyp := fields[i].Type\n+\t\t\t\t\tif !x.isAssignable(etyp) {\n+\t\t\t\t\t\tcheck.errorf(x.pos(), \"cannot use %s as %s value in struct literal\", x, etyp)\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// no element must have a key\n+\t\t\t\tfor i, e := range e.Elts {\n+\t\t\t\t\tif kv, _ := e.(*ast.KeyValueExpr); kv != nil {\n+\t\t\t\t\t\tcheck.errorf(kv.Pos(), \"mixture of field:value and value elements in struct literal\")\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tcheck.expr(x, e, nil, iota)\n+\t\t\t\t\tif i >= len(fields) {\n+\t\t\t\t\t\tcheck.errorf(x.pos(), \"too many values in struct literal\")\n+\t\t\t\t\t\tbreak // cannot continue\n+\t\t\t\t\t}\n+\t\t\t\t\t// i < len(fields)\n+\t\t\t\t\tetyp := fields[i].Type\n+\t\t\t\t\tif !x.isAssignable(etyp) {\n+\t\t\t\t\t\tcheck.errorf(x.pos(), \"cannot use %s as an element of type %s in struct literal\", x, etyp)\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif len(e.Elts) < len(fields) {\n+\t\t\t\t\tcheck.errorf(e.Rbrace, \"too few values in struct literal\")\n+\t\t\t\t\t// ok to continue\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tcase *Array:\n+\t\t\tn := check.indexedElts(e.Elts, utyp.Elt, utyp.Len, iota)\n+\t\t\t// if we have an \"open\" [...]T array, set the length now that we know it\n+\t\t\tif openArray {\n+\t\t\t\tutyp.Len = n\n+\t\t\t}\n+\n+\t\tcase *Slice:\n+\t\t\tcheck.indexedElts(e.Elts, utyp.Elt, -1, iota)\n+\n+\t\tcase *Map:\n+\t\t\tvisited := make(map[interface{}]bool, len(e.Elts))\n+\t\t\tfor _, e := range e.Elts {\n+\t\t\t\tkv, _ := e.(*ast.KeyValueExpr)\n+\t\t\t\tif kv == nil {\n+\t\t\t\t\tcheck.errorf(e.Pos(), \"missing key in map literal\")\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tcheck.expr(x, kv.Key, nil, iota)\n+\t\t\t\tif !x.isAssignable(utyp.Key) {\n+\t\t\t\t\tcheck.errorf(x.pos(), \"cannot use %s as %s key in map literal\", x, utyp.Key)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif x.mode == constant {\n+\t\t\t\t\tif visited[x.val] {\n+\t\t\t\t\t\tcheck.errorf(x.pos(), \"duplicate key %s in map literal\", x.val)\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tvisited[x.val] = true\n+\t\t\t\t}\n+\t\t\t\tcheck.expr(x, kv.Value, utyp.Elt, iota)\n+\t\t\t\tif !x.isAssignable(utyp.Elt) {\n+\t\t\t\t\tcheck.errorf(x.pos(), \"cannot use %s as %s value in map literal\", x, utyp.Elt)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdefault:\n+\t\t\tcheck.errorf(e.Pos(), \"%s is not a valid composite literal type\", typ)\n+\t\t\tgoto Error\n \t\t}\n-\t\t// TODO(gri) this is not correct - leave for now to get going\n-\t\tx.mode = variable\n+\n+\t\tx.mode = variable // TODO(gri) mode is really a value - keep for now to get going\n \t\tx.typ = typ\n \n \tcase *ast.ParenExpr:\n@@ -604,7 +852,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t}\n \t\tmode, typ := lookupField(x.typ, sel)\n \t\tif mode == invalid {\n-\t\t\tcheck.invalidOp(e.Pos(), \"%s has no field or method %s\", x, sel)\n+\t\t\tcheck.invalidOp(e.Pos(), \"%s has no single field or method %s\", x, sel)\n \t\t\tgoto Error\n \t\t}\n \t\tif x.mode == typexpr {\n@@ -617,7 +865,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t// the receiver type becomes the type of the first function\n \t\t\t// argument of the method expression's function type\n \t\t\t// TODO(gri) at the moment, method sets don't correctly track\n-\t\t\t// pointer vs non-pointer receivers -> typechecker is too lenient\n+\t\t\t// pointer vs non-pointer receivers => typechecker is too lenient\n \t\t\targ := ast.NewObj(ast.Var, \"\")\n \t\t\targ.Type = x.typ\n \t\t\tx.mode = value\n@@ -659,15 +907,29 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t}\n \t\t\tx.typ = typ.Elt\n \n+\t\tcase *Pointer:\n+\t\t\tif typ, _ := underlying(typ.Base).(*Array); typ != nil {\n+\t\t\t\tvalid = true\n+\t\t\t\tlength = typ.Len\n+\t\t\t\tx.mode = variable\n+\t\t\t\tx.typ = typ.Elt\n+\t\t\t}\n+\n \t\tcase *Slice:\n \t\t\tvalid = true\n \t\t\tx.mode = variable\n \t\t\tx.typ = typ.Elt\n \n \t\tcase *Map:\n-\t\t\t// TODO(gri) check index type\n+\t\t\tvar key operand\n+\t\t\tcheck.expr(&key, e.Index, nil, iota)\n+\t\t\tif key.mode == invalid || !key.isAssignable(typ.Key) {\n+\t\t\t\tcheck.invalidOp(x.pos(), \"cannot use %s as map index of type %s\", &key, typ.Key)\n+\t\t\t\tgoto Error\n+\t\t\t}\n \t\t\tx.mode = valueok\n \t\t\tx.typ = typ.Elt\n+\t\t\tx.expr = e\n \t\t\treturn\n \t\t}\n \n@@ -698,7 +960,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t\t}\n \t\t\t\t// a sliced string always yields a string value\n \t\t\t\t// of the same type as the original string (not\n-\t\t\t\t// a constant) even if the string and the indexes\n+\t\t\t\t// a constant) even if the string and the indices\n \t\t\t\t// are constant\n \t\t\t\tx.mode = value\n \t\t\t\t// x.typ doesn't change\n@@ -713,6 +975,14 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t}\n \t\t\tx.typ = &Slice{Elt: typ.Elt}\n \n+\t\tcase *Pointer:\n+\t\t\tif typ, _ := underlying(typ.Base).(*Array); typ != nil {\n+\t\t\t\tvalid = true\n+\t\t\t\tlength = typ.Len + 1 // +1 for slice\n+\t\t\t\tx.mode = variable\n+\t\t\t\tx.typ = &Slice{Elt: typ.Elt}\n+\t\t\t}\n+\n \t\tcase *Slice:\n \t\t\tvalid = true\n \t\t\tx.mode = variable\n@@ -724,33 +994,55 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\tgoto Error\n \t\t}\n \n-\t\tvar lo interface{} = zeroConst\n+\t\tlo := int64(0)\n \t\tif e.Low != nil {\n \t\t\tlo = check.index(e.Low, length, iota)\n \t\t}\n \n-\t\tvar hi interface{}\n+\t\thi := int64(-1)\n \t\tif e.High != nil {\n \t\t\thi = check.index(e.High, length, iota)\n \t\t} else if length >= 0 {\n \t\t\thi = length\n \t\t}\n \n-\t\tif lo != nil && hi != nil && compareConst(lo, hi, token.GTR) {\n-\t\t\tcheck.errorf(e.Low.Pos(), \"inverted slice range: %v > %v\", lo, hi)\n+\t\tif lo >= 0 && hi >= 0 && lo > hi {\n+\t\t\tcheck.errorf(e.Low.Pos(), \"inverted slice range: %d > %d\", lo, hi)\n \t\t\t// ok to continue\n \t\t}\n \n \tcase *ast.TypeAssertExpr:\n \t\tcheck.expr(x, e.X, hint, iota)\n-\t\tif _, ok := underlying(x.typ).(*Interface); !ok {\n-\t\t\tcheck.invalidOp(e.X.Pos(), \"non-interface type %s in type assertion\", x.typ)\n+\t\tif x.mode == invalid {\n+\t\t\tgoto Error\n+\t\t}\n+\t\tvar T *Interface\n+\t\tif T, _ = underlying(x.typ).(*Interface); T == nil {\n+\t\t\tcheck.invalidOp(x.pos(), \"%s is not an interface\", x)\n+\t\t\tgoto Error\n+\t\t}\n+\t\t// x.(type) expressions are handled explicitly in type switches\n+\t\tif e.Type == nil {\n+\t\t\tcheck.errorf(e.Pos(), \"use of .(type) outside type switch\")\n+\t\t\tgoto Error\n+\t\t}\n+\t\ttyp := check.typ(e.Type, false)\n+\t\tif typ == Typ[Invalid] {\n+\t\t\tgoto Error\n+\t\t}\n+\t\tif method, wrongType := missingMethod(typ, T); method != nil {\n+\t\t\tvar msg string\n+\t\t\tif wrongType {\n+\t\t\t\tmsg = \"%s cannot have dynamic type %s (wrong type for method %s)\"\n+\t\t\t} else {\n+\t\t\t\tmsg = \"%s cannot have dynamic type %s (missing method %s)\"\n+\t\t\t}\n+\t\t\tcheck.errorf(e.Type.Pos(), msg, x, typ, method.Name)\n \t\t\t// ok to continue\n \t\t}\n-\t\t// TODO(gri) some type asserts are compile-time decidable\n \t\tx.mode = valueok\n \t\tx.expr = e\n-\t\tx.typ = check.typ(e.Type, false)\n+\t\tx.typ = typ\n \n \tcase *ast.CallExpr:\n \t\tcheck.exprOrType(x, e.Fun, nil, iota, false)\n@@ -760,21 +1052,11 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\tcheck.conversion(x, e, x.typ, iota)\n \t\t} else if sig, ok := underlying(x.typ).(*Signature); ok {\n \t\t\t// check parameters\n-\t\t\t// TODO(gri) complete this\n-\t\t\t// - deal with various forms of calls\n-\t\t\t// - handle variadic calls\n-\t\t\tif len(sig.Params) == len(e.Args) {\n-\t\t\t\tvar z, x operand\n-\t\t\t\tz.mode = variable\n-\t\t\t\tfor i, arg := range e.Args {\n-\t\t\t\t\tz.expr = nil                      // TODO(gri) can we do better here?\n-\t\t\t\t\tz.typ = sig.Params[i].Type.(Type) // TODO(gri) should become something like checkObj(&z, ...) eventually\n-\t\t\t\t\tcheck.expr(&x, arg, z.typ, iota)\n-\t\t\t\t\tif x.mode == invalid {\n-\t\t\t\t\t\tgoto Error\n-\t\t\t\t\t}\n-\t\t\t\t\tcheck.assignOperand(&z, &x)\n-\t\t\t\t}\n+\t\t\t// TODO(gri)\n+\t\t\t// - deal with single multi-valued function arguments: f(g())\n+\t\t\t// - variadic functions only partially addressed\n+\t\t\tfor i, arg := range e.Args {\n+\t\t\t\tcheck.argument(sig, i, arg)\n \t\t\t}\n \n \t\t\t// determine result\n@@ -827,32 +1109,26 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\tcheck.binary(x, &y, e.Op, hint)\n \n \tcase *ast.KeyValueExpr:\n-\t\tunimplemented()\n+\t\t// key:value expressions are handled in composite literals\n+\t\tcheck.invalidAST(e.Pos(), \"no key:value expected\")\n+\t\tgoto Error\n \n \tcase *ast.ArrayType:\n \t\tif e.Len != nil {\n-\t\t\tvar n int64 = -1\n-\t\t\tif ellip, ok := e.Len.(*ast.Ellipsis); ok {\n-\t\t\t\t// TODO(gri) need to check somewhere that [...]T types are only used with composite literals\n-\t\t\t\tif ellip.Elt != nil {\n-\t\t\t\t\tcheck.invalidAST(ellip.Pos(), \"ellipsis only expected\")\n-\t\t\t\t\t// ok to continue\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tcheck.expr(x, e.Len, nil, 0)\n-\t\t\t\tif x.mode == invalid {\n-\t\t\t\t\tgoto Error\n-\t\t\t\t}\n-\t\t\t\tif x.mode == constant {\n-\t\t\t\t\tif i, ok := x.val.(int64); ok && i == int64(int(i)) {\n-\t\t\t\t\t\tn = i\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif n < 0 {\n-\t\t\t\t\tcheck.errorf(e.Len.Pos(), \"invalid array bound %s\", e.Len)\n-\t\t\t\t\t// ok to continue\n-\t\t\t\t\tn = 0\n+\t\t\tcheck.expr(x, e.Len, nil, iota)\n+\t\t\tif x.mode == invalid {\n+\t\t\t\tgoto Error\n+\t\t\t}\n+\t\t\tif x.mode != constant {\n+\t\t\t\tif x.mode != invalid {\n+\t\t\t\t\tcheck.errorf(x.pos(), \"array length %s must be constant\", x)\n \t\t\t\t}\n+\t\t\t\tgoto Error\n+\t\t\t}\n+\t\t\tn, ok := x.val.(int64)\n+\t\t\tif !ok || n < 0 {\n+\t\t\t\tcheck.errorf(x.pos(), \"invalid array length %s\", x)\n+\t\t\t\tgoto Error\n \t\t\t}\n \t\t\tx.typ = &Array{Len: n, Elt: check.typ(e.Elt, cycleOk)}\n \t\t} else {\n@@ -862,19 +1138,17 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \n \tcase *ast.StructType:\n \t\tx.mode = typexpr\n-\t\tx.typ = &Struct{Fields: check.collectStructFields(e.Fields, cycleOk)}\n+\t\tx.typ = &Struct{Fields: check.collectFields(e.Fields, cycleOk)}\n \n \tcase *ast.FuncType:\n-\t\tparams, _, isVariadic := check.collectFields(token.FUNC, e.Params, true)\n-\t\tresults, _, _ := check.collectFields(token.FUNC, e.Results, true)\n+\t\tparams, isVariadic := check.collectParams(e.Params, true)\n+\t\tresults, _ := check.collectParams(e.Results, false)\n \t\tx.mode = typexpr\n \t\tx.typ = &Signature{Recv: nil, Params: params, Results: results, IsVariadic: isVariadic}\n \n \tcase *ast.InterfaceType:\n-\t\tmethods, _, _ := check.collectFields(token.INTERFACE, e.Methods, cycleOk)\n-\t\tmethods.Sort()\n \t\tx.mode = typexpr\n-\t\tx.typ = &Interface{Methods: methods}\n+\t\tx.typ = &Interface{Methods: check.collectMethods(e.Methods)}\n \n \tcase *ast.MapType:\n \t\tx.mode = typexpr\n@@ -920,10 +1194,7 @@ func (check *checker) expr(x *operand, e ast.Expr, hint Type, iota int) {\n \t}\n }\n \n-// expr is like rawExpr but reports an error if e doesn't represents a type.\n-// It returns e's type, or Typ[Invalid] if an error occured.\n-//\n-func (check *checker) typ(e ast.Expr, cycleOk bool) Type {\n+func (check *checker) rawTyp(e ast.Expr, cycleOk, nilOk bool) Type {\n \tvar x operand\n \tcheck.rawExpr(&x, e, nil, -1, cycleOk)\n \tswitch x.mode {\n@@ -933,8 +1204,27 @@ func (check *checker) typ(e ast.Expr, cycleOk bool) Type {\n \t\tcheck.errorf(x.pos(), \"%s used as type\", &x)\n \tcase typexpr:\n \t\treturn x.typ\n+\tcase constant:\n+\t\tif nilOk && x.isNil() {\n+\t\t\treturn nil\n+\t\t}\n+\t\tfallthrough\n \tdefault:\n \t\tcheck.errorf(x.pos(), \"%s is not a type\", &x)\n \t}\n \treturn Typ[Invalid]\n }\n+\n+// typOrNil is like rawExpr but reports an error if e doesn't represents a type or the predeclared value nil.\n+// It returns e's type, nil, or Typ[Invalid] if an error occured.\n+//\n+func (check *checker) typOrNil(e ast.Expr, cycleOk bool) Type {\n+\treturn check.rawTyp(e, cycleOk, true)\n+}\n+\n+// typ is like rawExpr but reports an error if e doesn't represents a type.\n+// It returns e's type, or Typ[Invalid] if an error occured.\n+//\n+func (check *checker) typ(e ast.Expr, cycleOk bool) Type {\n+\treturn check.rawTyp(e, cycleOk, false)\n+}"}, {"sha": "1a5e5172a8b1073ccf1d1790347c0710e3e3e19f", "filename": "libgo/go/exp/types/operand.go", "status": "modified", "additions": 97, "deletions": 44, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -119,21 +119,15 @@ func (x *operand) setConst(tok token.Token, lit string) {\n \t}\n }\n \n-// implements reports whether x implements interface T.\n-func (x *operand) implements(T *Interface) bool {\n-\tif x.mode == invalid {\n-\t\treturn true // avoid spurious errors\n-\t}\n-\n-\tunimplemented()\n-\treturn true\n-}\n-\n // isNil reports whether x is the predeclared nil constant.\n func (x *operand) isNil() bool {\n \treturn x.mode == constant && x.val == nilConst\n }\n \n+// TODO(gri) The functions operand.isAssignable, checker.convertUntyped,\n+//           checker.isRepresentable, and checker.assignOperand are\n+//           overlapping in functionality. Need to simplify and clean up.\n+\n // isAssignable reports whether x is assignable to a variable of type T.\n func (x *operand) isAssignable(T Type) bool {\n \tif x.mode == invalid || T == Typ[Invalid] {\n@@ -157,8 +151,10 @@ func (x *operand) isAssignable(T Type) bool {\n \t}\n \n \t// T is an interface type and x implements T\n-\tif Ti, ok := Tu.(*Interface); ok && x.implements(Ti) {\n-\t\treturn true\n+\tif Ti, ok := Tu.(*Interface); ok {\n+\t\tif m, _ := missingMethod(x.typ, Ti); m == nil {\n+\t\t\treturn true\n+\t\t}\n \t}\n \n \t// x is a bidirectional channel value, T is a channel\n@@ -181,8 +177,18 @@ func (x *operand) isAssignable(T Type) bool {\n \t}\n \n \t// x is an untyped constant representable by a value of type T\n-\t// - this is taken care of in the assignment check\n-\t// TODO(gri) double-check - isAssignable is used elsewhere\n+\t// TODO(gri) This is borrowing from checker.convertUntyped and\n+\t//           checker.isRepresentable. Need to clean up.\n+\tif isUntyped(Vu) {\n+\t\tswitch t := Tu.(type) {\n+\t\tcase *Basic:\n+\t\t\treturn x.mode == constant && isRepresentableConst(x.val, t.Kind)\n+\t\tcase *Interface:\n+\t\t\treturn x.isNil() || len(t.Methods) == 0\n+\t\tcase *Pointer, *Signature, *Slice, *Map, *Chan:\n+\t\t\treturn x.isNil()\n+\t\t}\n+\t}\n \n \treturn false\n }\n@@ -199,35 +205,50 @@ type lookupResult struct {\n \ttyp  Type\n }\n \n-// lookupFieldRecursive is similar to FieldByNameFunc in reflect/type.go\n-// TODO(gri): FieldByNameFunc seems more complex - what are we missing?\n-func lookupFieldRecursive(list []*NamedType, name string) (res lookupResult) {\n-\t// visited records the types that have been searched already\n-\tvisited := make(map[Type]bool)\n+type embeddedType struct {\n+\ttyp       *NamedType\n+\tmultiples bool // if set, typ is embedded multiple times at the same level\n+}\n+\n+// lookupFieldBreadthFirst searches all types in list for a single entry (field\n+// or method) of the given name. If such a field is found, the result describes\n+// the field mode and type; otherwise the result mode is invalid.\n+// (This function is similar in structure to FieldByNameFunc in reflect/type.go)\n+//\n+func lookupFieldBreadthFirst(list []embeddedType, name string) (res lookupResult) {\n+\t// visited records the types that have been searched already.\n+\tvisited := make(map[*NamedType]bool)\n \n \t// embedded types of the next lower level\n-\tvar next []*NamedType\n+\tvar next []embeddedType\n \n-\tpotentialMatch := func(mode operandMode, typ Type) bool {\n-\t\tif res.mode != invalid {\n-\t\t\t// name appeared multiple times at this level - annihilate\n+\t// potentialMatch is invoked every time a match is found.\n+\tpotentialMatch := func(multiples bool, mode operandMode, typ Type) bool {\n+\t\tif multiples || res.mode != invalid {\n+\t\t\t// name appeared already at this level - annihilate\n \t\t\tres.mode = invalid\n \t\t\treturn false\n \t\t}\n+\t\t// first appearance of name\n \t\tres.mode = mode\n \t\tres.typ = typ\n \t\treturn true\n \t}\n \n-\t// look for name in all types of this level\n+\t// Search the current level if there is any work to do and collect\n+\t// embedded types of the next lower level in the next list.\n \tfor len(list) > 0 {\n+\t\t// The res.mode indicates whether we have found a match already\n+\t\t// on this level (mode != invalid), or not (mode == invalid).\n \t\tassert(res.mode == invalid)\n-\t\tfor _, typ := range list {\n+\n+\t\t// start with empty next list (don't waste underlying array)\n+\t\tnext = next[:0]\n+\n+\t\t// look for name in all types at this level\n+\t\tfor _, e := range list {\n+\t\t\ttyp := e.typ\n \t\t\tif visited[typ] {\n-\t\t\t\t// We have seen this type before, at a higher level.\n-\t\t\t\t// That higher level shadows the lower level we are\n-\t\t\t\t// at now, and either we would have found or not\n-\t\t\t\t// found the field before. Ignore this type now.\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tvisited[typ] = true\n@@ -236,29 +257,34 @@ func lookupFieldRecursive(list []*NamedType, name string) (res lookupResult) {\n \t\t\tif data := typ.Obj.Data; data != nil {\n \t\t\t\tif obj := data.(*ast.Scope).Lookup(name); obj != nil {\n \t\t\t\t\tassert(obj.Type != nil)\n-\t\t\t\t\tif !potentialMatch(value, obj.Type.(Type)) {\n+\t\t\t\t\tif !potentialMatch(e.multiples, value, obj.Type.(Type)) {\n \t\t\t\t\t\treturn // name collision\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tswitch typ := underlying(typ).(type) {\n \t\t\tcase *Struct:\n-\t\t\t\t// look for a matching fieldm and collect embedded types\n+\t\t\t\t// look for a matching field and collect embedded types\n \t\t\t\tfor _, f := range typ.Fields {\n \t\t\t\t\tif f.Name == name {\n \t\t\t\t\t\tassert(f.Type != nil)\n-\t\t\t\t\t\tif !potentialMatch(variable, f.Type) {\n+\t\t\t\t\t\tif !potentialMatch(e.multiples, variable, f.Type) {\n \t\t\t\t\t\t\treturn // name collision\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t\t// Collect embedded struct fields for searching the next\n-\t\t\t\t\t// lower level, but only if we have not seen a match yet.\n+\t\t\t\t\t// lower level, but only if we have not seen a match yet\n+\t\t\t\t\t// (if we have a match it is either the desired field or\n+\t\t\t\t\t// we have a name collision on the same level; in either\n+\t\t\t\t\t// case we don't need to look further).\n \t\t\t\t\t// Embedded fields are always of the form T or *T where\n-\t\t\t\t\t// T is a named type.\n+\t\t\t\t\t// T is a named type. If typ appeared multiple times at\n+\t\t\t\t\t// this level, f.Type appears multiple times at the next\n+\t\t\t\t\t// level.\n \t\t\t\t\tif f.IsAnonymous && res.mode == invalid {\n-\t\t\t\t\t\tnext = append(next, deref(f.Type).(*NamedType))\n+\t\t\t\t\t\tnext = append(next, embeddedType{deref(f.Type).(*NamedType), e.multiples})\n \t\t\t\t\t}\n \t\t\t\t}\n \n@@ -267,7 +293,7 @@ func lookupFieldRecursive(list []*NamedType, name string) (res lookupResult) {\n \t\t\t\tfor _, obj := range typ.Methods {\n \t\t\t\t\tif obj.Name == name {\n \t\t\t\t\t\tassert(obj.Type != nil)\n-\t\t\t\t\t\tif !potentialMatch(value, obj.Type.(Type)) {\n+\t\t\t\t\t\tif !potentialMatch(e.multiples, value, obj.Type.(Type)) {\n \t\t\t\t\t\t\treturn // name collision\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n@@ -276,17 +302,41 @@ func lookupFieldRecursive(list []*NamedType, name string) (res lookupResult) {\n \t\t}\n \n \t\tif res.mode != invalid {\n-\t\t\t// we found a match on this level\n+\t\t\t// we found a single match on this level\n \t\t\treturn\n \t\t}\n \n-\t\t// search the next level\n-\t\tlist = append(list[:0], next...) // don't waste underlying arrays\n-\t\tnext = next[:0]\n+\t\t// No match and no collision so far.\n+\t\t// Compute the list to search for the next level.\n+\t\tlist = list[:0] // don't waste underlying array\n+\t\tfor _, e := range next {\n+\t\t\t// Instead of adding the same type multiple times, look for\n+\t\t\t// it in the list and mark it as multiple if it was added\n+\t\t\t// before.\n+\t\t\t// We use a sequential search (instead of a map for next)\n+\t\t\t// because the lists tend to be small, can easily be reused,\n+\t\t\t// and explicit search appears to be faster in this case.\n+\t\t\tif alt := findType(list, e.typ); alt != nil {\n+\t\t\t\talt.multiples = true\n+\t\t\t} else {\n+\t\t\t\tlist = append(list, e)\n+\t\t\t}\n+\t\t}\n+\n \t}\n+\n \treturn\n }\n \n+func findType(list []embeddedType, typ *NamedType) *embeddedType {\n+\tfor i := range list {\n+\t\tif p := &list[i]; p.typ == typ {\n+\t\t\treturn p\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n func lookupField(typ Type, name string) (operandMode, Type) {\n \ttyp = deref(typ)\n \n@@ -301,17 +351,20 @@ func lookupField(typ Type, name string) (operandMode, Type) {\n \n \tswitch typ := underlying(typ).(type) {\n \tcase *Struct:\n-\t\tvar list []*NamedType\n+\t\tvar next []embeddedType\n \t\tfor _, f := range typ.Fields {\n \t\t\tif f.Name == name {\n \t\t\t\treturn variable, f.Type\n \t\t\t}\n \t\t\tif f.IsAnonymous {\n-\t\t\t\tlist = append(list, deref(f.Type).(*NamedType))\n+\t\t\t\t// Possible optimization: If the embedded type\n+\t\t\t\t// is a pointer to the current type we could\n+\t\t\t\t// ignore it.\n+\t\t\t\tnext = append(next, embeddedType{typ: deref(f.Type).(*NamedType)})\n \t\t\t}\n \t\t}\n-\t\tif len(list) > 0 {\n-\t\t\tres := lookupFieldRecursive(list, name)\n+\t\tif len(next) > 0 {\n+\t\t\tres := lookupFieldBreadthFirst(next, name)\n \t\t\treturn res.mode, res.typ\n \t\t}\n "}, {"sha": "2c1a99192aa57c1433727de40d00228919404752", "filename": "libgo/go/exp/types/predicates.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -6,6 +6,8 @@\n \n package types\n \n+import \"go/ast\"\n+\n func isNamed(typ Type) bool {\n \tif _, ok := typ.(*Basic); ok {\n \t\treturn ok\n@@ -247,3 +249,34 @@ func defaultType(typ Type) Type {\n \t}\n \treturn typ\n }\n+\n+// missingMethod returns (nil, false) if typ implements T, otherwise\n+// it returns the first missing method required by T and whether it\n+// is missing or simply has the wrong type.\n+//\n+func missingMethod(typ Type, T *Interface) (method *ast.Object, wrongType bool) {\n+\t// TODO(gri): distinguish pointer and non-pointer receivers\n+\t// an interface type implements T if it has no methods with conflicting signatures\n+\t// Note: This is stronger than the current spec. Should the spec require this?\n+\tif ityp, _ := underlying(typ).(*Interface); ityp != nil {\n+\t\tfor _, m := range T.Methods {\n+\t\t\tmode, sig := lookupField(ityp, m.Name) // TODO(gri) no need to go via lookupField\n+\t\t\tif mode != invalid && !isIdentical(sig, m.Type.(Type)) {\n+\t\t\t\treturn m, true\n+\t\t\t}\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\t// a concrete type implements T if it implements all methods of T.\n+\tfor _, m := range T.Methods {\n+\t\tmode, sig := lookupField(typ, m.Name)\n+\t\tif mode == invalid {\n+\t\t\treturn m, false\n+\t\t}\n+\t\tif !isIdentical(sig, m.Type.(Type)) {\n+\t\t\treturn m, true\n+\t\t}\n+\t}\n+\treturn\n+}"}, {"sha": "e2c6448debad896f09252d7ba3bbd457ea3c9e7d", "filename": "libgo/go/exp/types/stmt.go", "status": "modified", "additions": 217, "deletions": 22, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -27,8 +27,8 @@ func (check *checker) assignOperand(z, x *operand) {\n \t}\n }\n \n-// assign1to1 typechecks a single assignment of the form lhs := rhs (if rhs != nil),\n-// or lhs := x (if rhs == nil). If decl is set, the lhs operand must be an identifier.\n+// assign1to1 typechecks a single assignment of the form lhs = rhs (if rhs != nil),\n+// or lhs = x (if rhs == nil). If decl is set, the lhs operand must be an identifier.\n // If its type is not set, it is deduced from the type or value of x. If lhs has a\n // type it is used as a hint when evaluating rhs, if present.\n //\n@@ -226,6 +226,38 @@ func (check *checker) stmtList(list []ast.Stmt) {\n \t}\n }\n \n+func (check *checker) call(call *ast.CallExpr) {\n+\tvar x operand\n+\tcheck.rawExpr(&x, call, nil, -1, false) // don't check if value is used\n+\t// TODO(gri) If a builtin is called, the builtin must be valid in statement context.\n+}\n+\n+func (check *checker) multipleDefaults(list []ast.Stmt) {\n+\tvar first ast.Stmt\n+\tfor _, s := range list {\n+\t\tvar d ast.Stmt\n+\t\tswitch c := s.(type) {\n+\t\tcase *ast.CaseClause:\n+\t\t\tif len(c.List) == 0 {\n+\t\t\t\td = s\n+\t\t\t}\n+\t\tcase *ast.CommClause:\n+\t\t\tif c.Comm == nil {\n+\t\t\t\td = s\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tcheck.invalidAST(s.Pos(), \"case/communication clause expected\")\n+\t\t}\n+\t\tif d != nil {\n+\t\t\tif first != nil {\n+\t\t\t\tcheck.errorf(d.Pos(), \"multiple defaults (first at %s)\", first.Pos())\n+\t\t\t} else {\n+\t\t\t\tfirst = d\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n // stmt typechecks statement s.\n func (check *checker) stmt(s ast.Stmt) {\n \tswitch s := s.(type) {\n@@ -265,7 +297,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t}\n \t\tcheck.rawExpr(&x, s.X, nil, -1, false)\n \t\tif x.mode == typexpr {\n-\t\t\tcheck.errorf(x.pos(), \"%s is not an expression\", x)\n+\t\t\tcheck.errorf(x.pos(), \"%s is not an expression\", &x)\n \t\t}\n \n \tcase *ast.SendStmt:\n@@ -347,10 +379,10 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t}\n \n \tcase *ast.GoStmt:\n-\t\tunimplemented()\n+\t\tcheck.call(s.Call)\n \n \tcase *ast.DeferStmt:\n-\t\tunimplemented()\n+\t\tcheck.call(s.Call)\n \n \tcase *ast.ReturnStmt:\n \t\tsig := check.functypes[len(check.functypes)-1]\n@@ -403,31 +435,122 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\tx.typ = Typ[UntypedBool]\n \t\t\tx.val = true\n \t\t}\n+\n+\t\tcheck.multipleDefaults(s.Body.List)\n \t\tfor _, s := range s.Body.List {\n-\t\t\tif clause, ok := s.(*ast.CaseClause); ok {\n-\t\t\t\tfor _, expr := range clause.List {\n-\t\t\t\t\tvar y operand\n-\t\t\t\t\tcheck.expr(&y, expr, nil, -1)\n-\t\t\t\t\t// TODO(gri) x and y must be comparable\n-\t\t\t\t}\n-\t\t\t\tcheck.stmtList(clause.Body)\n-\t\t\t} else {\n-\t\t\t\tcheck.errorf(s.Pos(), \"invalid AST: case clause expected\")\n+\t\t\tclause, _ := s.(*ast.CaseClause)\n+\t\t\tif clause == nil {\n+\t\t\t\tcontinue // error reported before\n \t\t\t}\n+\t\t\tfor _, expr := range clause.List {\n+\t\t\t\tvar y operand\n+\t\t\t\tcheck.expr(&y, expr, nil, -1)\n+\t\t\t\t// TODO(gri) x and y must be comparable\n+\t\t\t}\n+\t\t\tcheck.stmtList(clause.Body)\n \t\t}\n \n \tcase *ast.TypeSwitchStmt:\n-\t\tunimplemented()\n+\t\tcheck.optionalStmt(s.Init)\n+\n+\t\t// A type switch guard must be of the form:\n+\t\t//\n+\t\t//     TypeSwitchGuard = [ identifier \":=\" ] PrimaryExpr \".\" \"(\" \"type\" \")\" .\n+\t\t//\n+\t\t// The parser is checking syntactic correctness;\n+\t\t// remaining syntactic errors are considered AST errors here.\n+\t\t// TODO(gri) better factoring of error handling (invalid ASTs)\n+\t\t//\n+\t\tvar lhs *ast.Object // lhs identifier object or nil\n+\t\tvar rhs ast.Expr\n+\t\tswitch guard := s.Assign.(type) {\n+\t\tcase *ast.ExprStmt:\n+\t\t\trhs = guard.X\n+\t\tcase *ast.AssignStmt:\n+\t\t\tif len(guard.Lhs) != 1 || guard.Tok != token.DEFINE || len(guard.Rhs) != 1 {\n+\t\t\t\tcheck.invalidAST(s.Pos(), \"incorrect form of type switch guard\")\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tident, _ := guard.Lhs[0].(*ast.Ident)\n+\t\t\tif ident == nil {\n+\t\t\t\tcheck.invalidAST(s.Pos(), \"incorrect form of type switch guard\")\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tlhs = ident.Obj\n+\t\t\trhs = guard.Rhs[0]\n+\t\tdefault:\n+\t\t\tcheck.invalidAST(s.Pos(), \"incorrect form of type switch guard\")\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// rhs must be of the form: expr.(type) and expr must be an interface\n+\t\texpr, _ := rhs.(*ast.TypeAssertExpr)\n+\t\tif expr == nil || expr.Type != nil {\n+\t\t\tcheck.invalidAST(s.Pos(), \"incorrect form of type switch guard\")\n+\t\t\treturn\n+\t\t}\n+\t\tvar x operand\n+\t\tcheck.expr(&x, expr.X, nil, -1)\n+\t\tif x.mode == invalid {\n+\t\t\treturn\n+\t\t}\n+\t\tvar T *Interface\n+\t\tif T, _ = underlying(x.typ).(*Interface); T == nil {\n+\t\t\tcheck.errorf(x.pos(), \"%s is not an interface\", &x)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tcheck.multipleDefaults(s.Body.List)\n+\t\tfor _, s := range s.Body.List {\n+\t\t\tclause, _ := s.(*ast.CaseClause)\n+\t\t\tif clause == nil {\n+\t\t\t\tcontinue // error reported before\n+\t\t\t}\n+\t\t\t// Check each type in this type switch case.\n+\t\t\tvar typ Type\n+\t\t\tfor _, expr := range clause.List {\n+\t\t\t\ttyp = check.typOrNil(expr, false)\n+\t\t\t\tif typ != nil && typ != Typ[Invalid] {\n+\t\t\t\t\tif method, wrongType := missingMethod(typ, T); method != nil {\n+\t\t\t\t\t\tvar msg string\n+\t\t\t\t\t\tif wrongType {\n+\t\t\t\t\t\t\tmsg = \"%s cannot have dynamic type %s (wrong type for method %s)\"\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmsg = \"%s cannot have dynamic type %s (missing method %s)\"\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcheck.errorf(expr.Pos(), msg, &x, typ, method.Name)\n+\t\t\t\t\t\t// ok to continue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// If lhs exists, set its type for each clause.\n+\t\t\tif lhs != nil {\n+\t\t\t\t// In clauses with a case listing exactly one type, the variable has that type;\n+\t\t\t\t// otherwise, the variable has the type of the expression in the TypeSwitchGuard.\n+\t\t\t\tif len(clause.List) != 1 || typ == nil {\n+\t\t\t\t\ttyp = x.typ\n+\t\t\t\t}\n+\t\t\t\tlhs.Type = typ\n+\t\t\t}\n+\t\t\tcheck.stmtList(clause.Body)\n+\t\t}\n+\n+\t\t// There is only one object (lhs) associated with a lhs identifier, but that object\n+\t\t// assumes different types for different clauses. Set it to nil when we are done so\n+\t\t// that the type cannot be used by mistake.\n+\t\tif lhs != nil {\n+\t\t\tlhs.Type = nil\n+\t\t}\n \n \tcase *ast.SelectStmt:\n+\t\tcheck.multipleDefaults(s.Body.List)\n \t\tfor _, s := range s.Body.List {\n-\t\t\tc, ok := s.(*ast.CommClause)\n-\t\t\tif !ok {\n-\t\t\t\tcheck.invalidAST(s.Pos(), \"communication clause expected\")\n-\t\t\t\tcontinue\n+\t\t\tclause, _ := s.(*ast.CommClause)\n+\t\t\tif clause == nil {\n+\t\t\t\tcontinue // error reported before\n \t\t\t}\n-\t\t\tcheck.optionalStmt(c.Comm) // TODO(gri) check correctness of c.Comm (must be Send/RecvStmt)\n-\t\t\tcheck.stmtList(c.Body)\n+\t\t\tcheck.optionalStmt(clause.Comm) // TODO(gri) check correctness of c.Comm (must be Send/RecvStmt)\n+\t\t\tcheck.stmtList(clause.Body)\n \t\t}\n \n \tcase *ast.ForStmt:\n@@ -443,7 +566,79 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\tcheck.stmt(s.Body)\n \n \tcase *ast.RangeStmt:\n-\t\tunimplemented()\n+\t\t// check expression to iterate over\n+\t\tdecl := s.Tok == token.DEFINE\n+\t\tvar x operand\n+\t\tcheck.expr(&x, s.X, nil, -1)\n+\t\tif x.mode == invalid {\n+\t\t\t// if we don't have a declaration, we can still check the loop's body\n+\t\t\tif !decl {\n+\t\t\t\tcheck.stmt(s.Body)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// determine key/value types\n+\t\tvar key, val Type\n+\t\tswitch typ := underlying(x.typ).(type) {\n+\t\tcase *Basic:\n+\t\t\tif isString(typ) {\n+\t\t\t\tkey = Typ[UntypedInt]\n+\t\t\t\tval = Typ[UntypedRune]\n+\t\t\t}\n+\t\tcase *Array:\n+\t\t\tkey = Typ[UntypedInt]\n+\t\t\tval = typ.Elt\n+\t\tcase *Slice:\n+\t\t\tkey = Typ[UntypedInt]\n+\t\t\tval = typ.Elt\n+\t\tcase *Pointer:\n+\t\t\tif typ, _ := underlying(typ.Base).(*Array); typ != nil {\n+\t\t\t\tkey = Typ[UntypedInt]\n+\t\t\t\tval = typ.Elt\n+\t\t\t}\n+\t\tcase *Map:\n+\t\t\tkey = typ.Key\n+\t\t\tval = typ.Elt\n+\t\tcase *Chan:\n+\t\t\tkey = typ.Elt\n+\t\t\tif typ.Dir&ast.RECV == 0 {\n+\t\t\t\tcheck.errorf(x.pos(), \"cannot range over send-only channel %s\", &x)\n+\t\t\t\t// ok to continue\n+\t\t\t}\n+\t\t\tif s.Value != nil {\n+\t\t\t\tcheck.errorf(s.Value.Pos(), \"iteration over %s permits only one iteration variable\", &x)\n+\t\t\t\t// ok to continue\n+\t\t\t}\n+\t\t}\n+\n+\t\tif key == nil {\n+\t\t\tcheck.errorf(x.pos(), \"cannot range over %s\", &x)\n+\t\t\t// if we don't have a declaration, we can still check the loop's body\n+\t\t\tif !decl {\n+\t\t\t\tcheck.stmt(s.Body)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// check assignment to/declaration of iteration variables\n+\t\t// TODO(gri) The error messages/positions are not great here,\n+\t\t//           they refer to the expression in the range clause.\n+\t\t//           Should give better messages w/o too much code\n+\t\t//           duplication (assignment checking).\n+\t\tif s.Key != nil {\n+\t\t\tx.typ = key\n+\t\t\tcheck.assign1to1(s.Key, nil, &x, decl, -1)\n+\t\t} else {\n+\t\t\tcheck.invalidAST(s.Pos(), \"range clause requires index iteration variable\")\n+\t\t\t// ok to continue\n+\t\t}\n+\t\tif s.Value != nil {\n+\t\t\tx.typ = val\n+\t\t\tcheck.assign1to1(s.Value, nil, &x, decl, -1)\n+\t\t}\n+\n+\t\tcheck.stmt(s.Body)\n \n \tdefault:\n \t\tcheck.errorf(s.Pos(), \"invalid statement\")"}, {"sha": "70623c6166fe07d0baa9cf160b8cf60e2a84b989", "filename": "libgo/go/exp/types/testdata/decls0.src", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls0.src?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -40,8 +40,17 @@ type (\n )\n \n \n+// invalid array types\n type (\n-\tp1 pi /* ERROR \"no field or method foo\" */ .foo\n+\tiA0 [... /* ERROR \"invalid use of '...'\" */ ]byte\n+\tiA1 [1 /* ERROR \"invalid array length\" */ <<100]int\n+\tiA2 [- /* ERROR \"invalid array length\" */ 1]complex128\n+\tiA3 [\"foo\" /* ERROR \"invalid array length\" */ ]string\n+)\n+\n+\n+type (\n+\tp1 pi /* ERROR \"no single field or method foo\" */ .foo\n \tp2 unsafe.Pointer\n )\n \n@@ -131,7 +140,7 @@ type (\n \t\tm1(I5)\n \t}\n \tI6 interface {\n-\t\tS0 /* ERROR \"non-interface\" */\n+\t\tS0 /* ERROR \"not an interface\" */\n \t}\n \tI7 interface {\n \t\tI1"}, {"sha": "be927091c1b0842b8600ad5cd05e997cbfe264d2", "filename": "libgo/go/exp/types/testdata/decls1.src", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -73,7 +73,7 @@ var (\n \n // Various more complex expressions\n var (\n-\tu1 = x /* ERROR \"non-interface type\" */ .(int)\n+\tu1 = x /* ERROR \"not an interface\" */ .(int)\n \tu2 = iface.([]int)\n \tu3 = iface.(a /* ERROR \"not a type\" */ )\n \tu4, ok = iface.(int)"}, {"sha": "a5ea4d2b82ee471a5cfb12fe85abecec2e80aadb", "filename": "libgo/go/exp/types/testdata/expr3.src", "status": "modified", "additions": 198, "deletions": 44, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -6,43 +6,43 @@\n \n package expr3\n \n-// TODO(gri) Move the code below into function \"shifts\" once we check\n-//           declarations with initilizations inside functions.\n-var (\n-\ti0 int\n-\tu0 uint\n-)\n-\n-var (\n-\tv0 = 1<<0\n-\tv1 = 1<<i0 /* ERROR \"must be unsigned\" */\n-\tv2 = 1<<u0\n-\tv3 = 1<<\"foo\" /* ERROR \"must be unsigned\" */\n-\tv4 = 1<<- /* ERROR \"stupid shift\" */ 1\n-\tv5 = 1<<1025 /* ERROR \"stupid shift\" */\n-\tv6 = 1 /* ERROR \"overflows\" */ <<100\n-\n-\tv10 uint = 1 << 0\n-\tv11 uint = 1 << u0\n-\tv12 float32 = 1 /* ERROR \"must be integer\" */ << u0\n-)\n-\n-// TODO(gri) enable commented out tests below.\n-\n-// from the spec\n-var (\n-\ts uint = 33\n-\ti = 1<<s           // 1 has type int\n-\tj int32 = 1<<s     // 1 has type int32; j == 0\n-\tk = uint64(1<<s)   // 1 has type uint64; k == 1<<33\n-\tm int = 1.0<<s     // 1.0 has type int\n-//\tn = 1.0<<s != 0    // 1.0 has type int; n == false if ints are 32bits in size\n-\to = 1<<s == 2<<s   // 1 and 2 have type int; o == true if ints are 32bits in size\n-//\tp = 1<<s == 1 /* ERROR \"overflows\" */ <<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int\n-\tu = 1.0 /* ERROR \"must be integer\" */ <<s         // illegal: 1.0 has type float64, cannot shift\n-\tv float32 = 1 /* ERROR \"must be integer\" */ <<s   // illegal: 1 has type float32, cannot shift\n-\tw int64 = 1.0<<33  // 1.0<<33 is a constant shift expression\n-)\n+func shifts1() {\n+\tvar (\n+\t\ti0 int\n+\t\tu0 uint\n+\t)\n+\n+\tvar (\n+\t\tv0 = 1<<0\n+\t\tv1 = 1<<i0 /* ERROR \"must be unsigned\" */\n+\t\tv2 = 1<<u0\n+\t\tv3 = 1<<\"foo\" /* ERROR \"must be unsigned\" */\n+\t\tv4 = 1<<- /* ERROR \"stupid shift\" */ 1\n+\t\tv5 = 1<<1025 /* ERROR \"stupid shift\" */\n+\t\tv6 = 1 /* ERROR \"overflows\" */ <<100\n+\n+\t\tv10 uint = 1 << 0\n+\t\tv11 uint = 1 << u0\n+\t\tv12 float32 = 1 /* ERROR \"must be integer\" */ << u0\n+\t)\n+}\n+\n+func shifts2() {\n+\t// TODO(gri) enable commented out tests below.\n+\tvar (\n+\t\ts uint = 33\n+\t\ti = 1<<s           // 1 has type int\n+\t\tj int32 = 1<<s     // 1 has type int32; j == 0\n+\t\tk = uint64(1<<s)   // 1 has type uint64; k == 1<<33\n+\t\tm int = 1.0<<s     // 1.0 has type int\n+\t//\tn = 1.0<<s != 0    // 1.0 has type int; n == false if ints are 32bits in size\n+\t\to = 1<<s == 2<<s   // 1 and 2 have type int; o == true if ints are 32bits in size\n+\t//\tp = 1<<s == 1 /* ERROR \"overflows\" */ <<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int\n+\t\tu = 1.0 /* ERROR \"must be integer\" */ <<s         // illegal: 1.0 has type float64, cannot shift\n+\t\tv float32 = 1 /* ERROR \"must be integer\" */ <<s   // illegal: 1 has type float32, cannot shift\n+\t\tw int64 = 1.0<<33  // 1.0<<33 is a constant shift expression\n+\t)\n+}\n \n // TODO(gri) The error messages below depond on adjusting the spec\n //           to reflect what gc is doing at the moment (the spec\n@@ -67,11 +67,24 @@ func indexes() {\n \ta1 = a /* ERROR \"cannot assign\" */ [1] \n \t_ = a[9]\n \t_ = a[10 /* ERROR \"index .* out of bounds\" */ ]\n+\t_ = a[1 /* ERROR \"stupid index\" */ <<100]\n \t_ = a[10:]\n \t_ = a[:10]\n \t_ = a[10:10]\n \t_ = a[11 /* ERROR \"index .* out of bounds\" */ :]\n \t_ = a[: 11 /* ERROR \"index .* out of bounds\" */ ]\n+\t_ = a[: 1 /* ERROR \"stupid index\" */ <<100]\n+\n+\tpa := &a\n+\t_ = pa[9]\n+\t_ = pa[10 /* ERROR \"index .* out of bounds\" */ ]\n+\t_ = pa[1 /* ERROR \"stupid index\" */ <<100]\n+\t_ = pa[10:]\n+\t_ = pa[:10]\n+\t_ = pa[10:10]\n+\t_ = pa[11 /* ERROR \"index .* out of bounds\" */ :]\n+\t_ = pa[: 11 /* ERROR \"index .* out of bounds\" */ ]\n+\t_ = pa[: 1 /* ERROR \"stupid index\" */ <<100]\n \n \tvar b [0]int\n \t_ = b[0 /* ERROR \"index .* out of bounds\" */ ]\n@@ -88,11 +101,9 @@ func indexes() {\n \t_ = s[1 : 2]\n \t_ = s[2 /* ERROR \"inverted slice range\" */ : 1]\n \t_ = s[2 :]\n-\t_ = s[: 1<<100]\n-\t_ = s[1<<100 :]\n-\t_ = s[1<<100 : 1<<100]\n-\t_ = s[1 /* ERROR \"inverted slice range\" */ <<100+1 : 1<<100]\n-\t_ = s[1 /* ERROR \"inverted slice range\" */ <<100+1 : 10]\n+\t_ = s[: 1 /* ERROR \"stupid index\" */ <<100]\n+\t_ = s[1 /* ERROR \"stupid index\" */ <<100 :]\n+\t_ = s[1 /* ERROR \"stupid index\" */ <<100 : 1 /* ERROR \"stupid index\" */ <<100]\n \n \tvar t string\n \t_ = t[- /* ERROR \"index .* negative\" */ 1]\n@@ -126,9 +137,152 @@ type T struct {\n func (*T) m() {}\n \n func method_expressions() {\n-\t_ = T /* ERROR \"no field or method\" */ .a\n+\t_ = T /* ERROR \"no single field or method\" */ .a\n \t_ = T /* ERROR \"has no method\" */ .x\n \t_ = T.m\n \tvar f func(*T) = (*T).m\n \tvar g func(*T) = ( /* ERROR \"cannot assign\" */ T).m\n-}\n\\ No newline at end of file\n+}\n+\n+func struct_literals() {\n+\ttype T0 struct {\n+\t\ta, b, c int\n+\t}\n+\n+\ttype T1 struct {\n+\t\tT0\n+\t\ta, b int\n+\t\tu float64\n+\t\ts string\n+\t}\n+\n+\t// keyed elements\n+\t_ = T1{}\n+\t_ = T1{a: 0, 1 /* ERROR \"mixture of .* elements\" */ }\n+\t_ = T1{aa /* ERROR \"unknown field\" */ : 0}\n+\t_ = T1{1 /* ERROR \"invalid field name\" */ : 0}\n+\t_ = T1{a: 0, s: \"foo\", u: 0, a /* ERROR \"duplicate field\" */: 10}\n+\t_ = T1{a: \"foo\" /* ERROR \"cannot use\" */ }\n+\t_ = T1{c /* ERROR \"unknown field\" */ : 0}\n+\t_ = T1{T0: { /* ERROR \"missing type\" */ }}\n+\t_ = T1{T0: T0{}}\n+\t_ = T1{T0 /* ERROR \"invalid field name\" */ .a: 0}\n+\n+\t// unkeyed elements\n+\t_ = T0{1, 2, 3}\n+\t_ = T0{1, b /* ERROR \"mixture\" */ : 2, 3}\n+\t_ = T0{1, 2} /* ERROR \"too few values\" */\n+\t_ = T0{1, 2, 3, 4  /* ERROR \"too many values\" */ }\n+\t_ = T0{1, \"foo\" /* ERROR \"cannot use\" */, 3.4  /* ERROR \"cannot use\" */}\n+}\n+\n+func array_literals() {\n+\ttype A0 [0]int\n+\t_ = A0{}\n+\t_ = A0{0 /* ERROR \"index .* out of bounds\" */}\n+\t_ = A0{0 /* ERROR \"index .* out of bounds\" */ : 0}\n+\n+\ttype A1 [10]int\n+\t_ = A1{}\n+\t_ = A1{0, 1, 2}\n+\t_ = A1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n+\t_ = A1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /* ERROR \"index .* out of bounds\" */ }\n+\t_ = A1{- /* ERROR \"index .* negative\" */ 1: 0}\n+\t_ = A1{8: 8, 9}\n+\t_ = A1{8: 8, 9, 10 /* ERROR \"index .* out of bounds\" */ }\n+\t_ = A1{0, 1, 2, 0 /* ERROR \"duplicate index\" */ : 0, 3: 3, 4}\n+\t_ = A1{5: 5, 6, 7, 3: 3, 4}\n+\t_ = A1{5: 5, 6, 7, 3: 3, 4, 5 /* ERROR \"duplicate index\" */ }\n+\t_ = A1{10 /* ERROR \"index .* out of bounds\" */ : 10, 10 /* ERROR \"index .* out of bounds\" */ : 10}\n+\t_ = A1{5: 5, 6, 7, 3: 3, 1 /* ERROR \"stupid index\" */ <<100: 4, 5 /* ERROR \"duplicate index\" */ }\n+\t_ = A1{5: 5, 6, 7, 4: 4, 1 /* ERROR \"stupid index\" */ <<100: 4}\n+\t_ = A1{2.0}\n+\t_ = A1{2.1 /* ERROR \"cannot use\" */ }\n+\t_ = A1{\"foo\" /* ERROR \"cannot use\" */ }\n+\n+\ta0 := [...]int{}\n+\tassert(len(a0) == 0)\n+\t\n+\ta1 := [...]int{0, 1, 2}\n+\tassert(len(a1) == 3)\n+\tvar a13 [3]int\n+\tvar a14 [4]int\n+\ta13 = a1\n+\ta14 = a1 /* ERROR \"cannot assign\" */\n+\t\n+\ta2 := [...]int{- /* ERROR \"index .* negative\" */ 1: 0}\n+\n+\ta3 := [...]int{0, 1, 2, 0 /* ERROR \"duplicate index\" */ : 0, 3: 3, 4}\n+\tassert(len(a3) == 5) // somewhat arbitrary\n+\n+\ta4 := [...]complex128{0, 1, 2, 1<<10-2: -1i, 1i, 400: 10, 12, 14}\n+\tassert(len(a4) == 1024)\n+\n+\t// from the spec\n+\ttype Point struct { x, y float32 }\n+\t_ = [...]Point{Point{1.5, -3.5}, Point{0, 0}}\n+\t_ = [...]Point{{1.5, -3.5}, {0, 0}}\n+\t_ = [][]int{[]int{1, 2, 3}, []int{4, 5}}\n+\t_ = [][]int{{1, 2, 3}, {4, 5}}\n+\t_ = [...]*Point{&Point{1.5, -3.5}, &Point{0, 0}}\n+\t_ = [...]*Point{{1.5, -3.5}, {0, 0}}\n+}\n+\n+func slice_literals() {\n+\ttype S0 []int\n+\t_ = S0{}\n+\t_ = S0{0, 1, 2}\n+\t_ = S0{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n+\t_ = S0{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n+\t_ = S0{- /* ERROR \"index .* negative\" */ 1: 0}\n+\t_ = S0{8: 8, 9}\n+\t_ = S0{8: 8, 9, 10}\n+\t_ = S0{0, 1, 2, 0 /* ERROR \"duplicate index\" */ : 0, 3: 3, 4}\n+\t_ = S0{5: 5, 6, 7, 3: 3, 4}\n+\t_ = S0{5: 5, 6, 7, 3: 3, 4, 5 /* ERROR \"duplicate index\" */ }\n+\t_ = S0{10: 10, 10 /* ERROR \"duplicate index\" */ : 10}\n+\t_ = S0{5: 5, 6, 7, 3: 3, 1 /* ERROR \"stupid index\" */ <<100: 4, 5 /* ERROR \"duplicate index\" */ }\n+\t_ = S0{5: 5, 6, 7, 4: 4, 1 /* ERROR \"stupid index\" */ <<100: 4}\n+\t_ = S0{2.0}\n+\t_ = S0{2.1 /* ERROR \"cannot use\" */ }\n+\t_ = S0{\"foo\" /* ERROR \"cannot use\" */ }\n+}\n+\n+func map_literals() {\n+\ttype M0 map[string]int\n+\n+\t_ = M0{}\n+\t_ = M0{1 /* ERROR \"missing key\" */ }\n+\t_ = M0{1 /* ERROR \"cannot use .* as string key\" */ : 2}\n+\t_ = M0{\"foo\": \"bar\" /* ERROR \"cannot use .* as int value\" */ }\n+\t_ = M0{\"foo\": 1, \"bar\": 2, \"foo\" /* ERROR \"duplicate key\" */ : 3 }\n+}\n+\n+type I interface {\n+\tm()\n+}\n+\n+type I2 interface {\n+\tm(int)\n+}\n+\n+type T1 struct{}\n+type T2 struct{}\n+\n+func (T2) m(int) {}\n+\n+func type_asserts() {\n+\tvar x int\n+\t_ = x /* ERROR \"not an interface\" */ .(int)\n+\n+\tvar e interface{}\n+\tvar ok bool\n+\tx, ok = e.(int)\n+\n+\tvar t I\n+\t_ = t /* ERROR \"use of .* outside type switch\" */ .(type)\n+\t_ = t.(T)\n+\t_ = t.(T1 /* ERROR \"missing method m\" */ )\n+\t_ = t.(T2 /* ERROR \"wrong type for method m\" */ )\n+\t_ = t.(I2 /* ERROR \"wrong type for method m\" */ )\n+}"}, {"sha": "d3cc3acce4f6bd75bd0863f9d338d688bc5ca9f1", "filename": "libgo/go/exp/types/testdata/stmt0.src", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -71,4 +71,170 @@ func _selects() {\n \t\tx = t\n \tcase <-sc /* ERROR \"cannot receive from send-only channel\" */ :\n \t}\n+\tselect {\n+\tdefault:\n+\tdefault /* ERROR \"multiple defaults\" */ :\n+\t}\n+}\n+\n+func _gos() {\n+\tgo 1 /* ERROR \"expected function/method call\" */\n+\tgo _gos()\n+\tvar c chan int\n+\tgo close(c)\n+\tgo len(c) // TODO(gri) this should not be legal\n+}\n+\n+func _defers() {\n+\tdefer 1 /* ERROR \"expected function/method call\" */\n+\tdefer _defers()\n+\tvar c chan int\n+\tdefer close(c)\n+\tdefer len(c) // TODO(gri) this should not be legal\n+}\n+\n+func _switches() {\n+\tvar x int\n+\n+\tswitch x {\n+\tdefault:\n+\tdefault /* ERROR \"multiple defaults\" */ :\n+\t}\n+\n+\t// TODO(gri) more tests\n+}\n+\n+type I interface {\n+\tm()\n+}\n+\n+type I2 interface {\n+\tm(int)\n+}\n+\n+type T struct{}\n+type T1 struct{}\n+type T2 struct{}\n+\n+func (T) m() {}\n+func (T2) m(int) {}\n+\n+func _typeswitches() {\n+\tvar i int\n+\tvar x interface{}\n+\n+\tswitch x.(type) {}\n+\tswitch (x /* ERROR \"outside type switch\" */ .(type)) {}\n+\n+\tswitch x.(type) {\n+\tdefault:\n+\tdefault /* ERROR \"multiple defaults\" */ :\n+\t}\n+\n+\tswitch x := x.(type) {}\n+\n+\tswitch x := x.(type) {\n+\tcase int:\n+\t\tvar y int = x\n+\t}\n+\n+\tswitch x := i /* ERROR \"not an interface\" */ .(type) {}\n+\n+\tswitch t := x.(type) {\n+\tcase nil:\n+\t\tvar v bool = t /* ERROR \"cannot assign\" */\n+\tcase int:\n+\t\tvar v int = t\n+\tcase float32, complex64:\n+\t\tvar v float32 = t /* ERROR \"cannot assign\" */\n+\tdefault:\n+\t\tvar v float32 = t /* ERROR \"cannot assign\" */\n+\t}\n+\n+\tvar t I\n+\tswitch t.(type) {\n+\tcase T:\n+\tcase T1 /* ERROR \"missing method m\" */ :\n+\tcase T2 /* ERROR \"wrong type for method m\" */ :\n+\tcase I2 /* ERROR \"wrong type for method m\" */ :\n+\t}\n+}\n+\n+func _rangeloops() {\n+\tvar (\n+\t\tx int\n+\t\ta [10]float32\n+\t\tb []string\n+\t\tp *[10]complex128\n+\t\tpp **[10]complex128\n+\t\ts string\n+\t\tm map[int]bool\n+\t\tc chan int\n+\t\tsc chan<- int\n+\t\trc <-chan int\n+\t)\n+\n+\tfor _ = range x /* ERROR \"cannot range over\" */ {}\n+\tfor i := range x /* ERROR \"cannot range over\" */ {}\n+\n+\tfor i := range a {\n+\t\tvar ii int\n+\t\tii = i\n+\t}\n+\tfor i, x := range a {\n+\t\tvar ii int\n+\t\tii = i\n+\t\tvar xx float64\n+\t\txx = x /* ERROR \"cannot assign\" */\n+\t}\n+\tvar ii int\n+\tvar xx float32\n+\tfor ii, xx := range a {}\n+\n+\tfor i := range b {\n+\t\tvar ii int\n+\t\tii = i\n+\t}\n+\tfor i, x := range b {\n+\t\tvar ii int\n+\t\tii = i\n+\t\tvar xx string\n+\t\txx = x\n+\t}\n+\n+\tfor i := range s {\n+\t\tvar ii int\n+\t\tii = i\n+\t}\n+\tfor i, x := range s {\n+\t\tvar ii int\n+\t\tii = i\n+\t\tvar xx rune\n+\t\txx = x\n+\t}\n+\n+\tfor _, x := range p {\n+\t\tvar xx complex128\n+\t\txx = x\n+\t}\n+\n+\tfor _, x := range pp /* ERROR \"cannot range over\" */ {}\n+\n+\tfor k := range m {\n+\t\tvar kk int32\n+\t\tkk = k /* ERROR \"cannot assign\" */\n+\t}\n+\tfor k, v := range m {\n+\t\tvar kk int\n+\t\tkk = k\n+\t\tif v {}\n+\t}\n+\n+\tfor _, _ /* ERROR \"only one iteration variable\" */ = range c {}\n+\tfor e := range c {\n+\t\tvar ee int\n+\t\tee = e\n+\t}\n+\tfor _ = range sc /* ERROR \"cannot range over send-only channel\" */ {}\n+\tfor _ = range rc {}\n }\n\\ No newline at end of file"}, {"sha": "83a08266dd30fad71c3be8edfbdea83e2fa3eeb8", "filename": "libgo/go/exp/types/types.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -126,6 +126,15 @@ type Struct struct {\n \tFields []*StructField\n }\n \n+func (typ *Struct) fieldIndex(name string) int {\n+\tfor i, f := range typ.Fields {\n+\t\tif f.Name == name {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n // A Pointer represents a pointer type *Base.\n type Pointer struct {\n \timplementsType"}, {"sha": "0fbaa3329d44c8175787857573f50a2275436747", "filename": "libgo/go/exp/types/universe.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -116,10 +116,12 @@ func init() {\n \n \t// error type\n \t{\n+\t\tres := ast.NewObj(ast.Var, \"\")\n+\t\tres.Type = Typ[String]\n+\t\terr := ast.NewObj(ast.Fun, \"Error\")\n+\t\terr.Type = &Signature{Results: ObjList{res}}\n \t\tobj := def(ast.Typ, \"error\")\n-\t\t// TODO(gri) set up correct interface type\n-\t\ttyp := &NamedType{Underlying: &Interface{}, Obj: obj}\n-\t\tobj.Type = typ\n+\t\tobj.Type = &NamedType{Underlying: &Interface{Methods: ObjList{err}}, Obj: obj}\n \t}\n \n \t// predeclared constants"}, {"sha": "a0bd4327fb5ebf958ca143b531323c17bdd44e26", "filename": "libgo/go/exp/winfsnotify/winfsnotify_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -9,6 +9,7 @@ package winfsnotify\n import (\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"sync/atomic\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -105,14 +106,14 @@ func TestNotifyClose(t *testing.T) {\n \twatcher, _ := NewWatcher()\n \twatcher.Close()\n \n-\tdone := false\n+\tvar done int32\n \tgo func() {\n \t\twatcher.Close()\n-\t\tdone = true\n+\t\tatomic.StoreInt32(&done, 1)\n \t}()\n \n \ttime.Sleep(50 * time.Millisecond)\n-\tif !done {\n+\tif atomic.LoadInt32(&done) == 0 {\n \t\tt.Fatal(\"double Close() test failed: second Close() call didn't return\")\n \t}\n "}, {"sha": "34061135a11f603171b283bf42a814248766d516", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -583,6 +583,7 @@ var mallocTest = []struct {\n var _ bytes.Buffer\n \n func TestCountMallocs(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tfor _, mt := range mallocTest {\n \t\tconst N = 100\n \t\tmemstats := new(runtime.MemStats)"}, {"sha": "a68a4840f8e9131fd3720bc33e96d6bcc63bec1d", "filename": "libgo/go/go/ast/import.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fast%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fast%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fimport.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -20,7 +20,7 @@ func SortImports(fset *token.FileSet, f *File) {\n \t\t\tbreak\n \t\t}\n \n-\t\tif d.Lparen == token.NoPos {\n+\t\tif !d.Lparen.IsValid() {\n \t\t\t// Not a block: sorted by default.\n \t\t\tcontinue\n \t\t}"}, {"sha": "286296ebc6fc83b3d87fe2b61f6476357eec5ed7", "filename": "libgo/go/go/format/format.go", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,200 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package format implements standard formatting of Go source.\n+package format\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"go/printer\"\n+\t\"go/token\"\n+\t\"io\"\n+\t\"strings\"\n+)\n+\n+var config = printer.Config{Mode: printer.UseSpaces | printer.TabIndent, Tabwidth: 8}\n+\n+// Node formats node in canonical gofmt style and writes the result to dst.\n+//\n+// The node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n+// []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\n+// or ast.Stmt. Node does not modify node. Imports are not sorted for\n+// nodes representing partial source files (i.e., if the node is not an\n+// *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n+//\n+// The function may return early (before the entire result is written)\n+// and return a formatting error, for instance due to an incorrect AST.\n+//\n+func Node(dst io.Writer, fset *token.FileSet, node interface{}) error {\n+\t// Determine if we have a complete source file (file != nil).\n+\tvar file *ast.File\n+\tvar cnode *printer.CommentedNode\n+\tswitch n := node.(type) {\n+\tcase *ast.File:\n+\t\tfile = n\n+\tcase *printer.CommentedNode:\n+\t\tif f, ok := n.Node.(*ast.File); ok {\n+\t\t\tfile = f\n+\t\t\tcnode = n\n+\t\t}\n+\t}\n+\n+\t// Sort imports if necessary.\n+\tif file != nil && hasUnsortedImports(file) {\n+\t\t// Make a copy of the AST because ast.SortImports is destructive.\n+\t\t// TODO(gri) Do this more efficently.\n+\t\tvar buf bytes.Buffer\n+\t\terr := config.Fprint(&buf, fset, file)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfile, err = parser.ParseFile(fset, \"\", buf.Bytes(), parser.ParseComments)\n+\t\tif err != nil {\n+\t\t\t// We should never get here. If we do, provide good diagnostic.\n+\t\t\treturn fmt.Errorf(\"format.Node internal error (%s)\", err)\n+\t\t}\n+\t\tast.SortImports(fset, file)\n+\n+\t\t// Use new file with sorted imports.\n+\t\tnode = file\n+\t\tif cnode != nil {\n+\t\t\tnode = &printer.CommentedNode{Node: file, Comments: cnode.Comments}\n+\t\t}\n+\t}\n+\n+\treturn config.Fprint(dst, fset, node)\n+}\n+\n+// Source formats src in canonical gofmt style and writes the result to dst\n+// or returns an I/O or syntax error. src is expected to be a syntactically\n+// correct Go source file, or a list of Go declarations or statements.\n+//\n+// If src is a partial source file, the leading and trailing space of src\n+// is applied to the result (such that it has the same leading and trailing\n+// space as src), and the formatted src is indented by the same amount as\n+// the first line of src containing code. Imports are not sorted for partial\n+// source files.\n+//\n+func Source(src []byte) ([]byte, error) {\n+\tfset := token.NewFileSet()\n+\tnode, err := parse(fset, src)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\tif file, ok := node.(*ast.File); ok {\n+\t\t// Complete source file.\n+\t\tast.SortImports(fset, file)\n+\t\terr := config.Fprint(&buf, fset, file)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t} else {\n+\t\t// Partial source file.\n+\t\t// Determine and prepend leading space.\n+\t\ti, j := 0, 0\n+\t\tfor j < len(src) && isSpace(src[j]) {\n+\t\t\tif src[j] == '\\n' {\n+\t\t\t\ti = j + 1 // index of last line in leading space\n+\t\t\t}\n+\t\t\tj++\n+\t\t}\n+\t\tbuf.Write(src[:i])\n+\n+\t\t// Determine indentation of first code line.\n+\t\t// Spaces are ignored unless there are no tabs,\n+\t\t// in which case spaces count as one tab.\n+\t\tindent := 0\n+\t\thasSpace := false\n+\t\tfor _, b := range src[i:j] {\n+\t\t\tswitch b {\n+\t\t\tcase ' ':\n+\t\t\t\thasSpace = true\n+\t\t\tcase '\\t':\n+\t\t\t\tindent++\n+\t\t\t}\n+\t\t}\n+\t\tif indent == 0 && hasSpace {\n+\t\t\tindent = 1\n+\t\t}\n+\n+\t\t// Format the source.\n+\t\tcfg := config\n+\t\tcfg.Indent = indent\n+\t\terr := cfg.Fprint(&buf, fset, node)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Determine and append trailing space.\n+\t\ti = len(src)\n+\t\tfor i > 0 && isSpace(src[i-1]) {\n+\t\t\ti--\n+\t\t}\n+\t\tbuf.Write(src[i:])\n+\t}\n+\n+\treturn buf.Bytes(), nil\n+}\n+\n+func hasUnsortedImports(file *ast.File) bool {\n+\tfor _, d := range file.Decls {\n+\t\td, ok := d.(*ast.GenDecl)\n+\t\tif !ok || d.Tok != token.IMPORT {\n+\t\t\t// Not an import declaration, so we're done.\n+\t\t\t// Imports are always first.\n+\t\t\treturn false\n+\t\t}\n+\t\tif d.Lparen.IsValid() {\n+\t\t\t// For now assume all grouped imports are unsorted.\n+\t\t\t// TODO(gri) Should check if they are sorted already.\n+\t\t\treturn true\n+\t\t}\n+\t\t// Ungrouped imports are sorted by default.\n+\t}\n+\treturn false\n+}\n+\n+func isSpace(b byte) bool {\n+\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n+}\n+\n+func parse(fset *token.FileSet, src []byte) (interface{}, error) {\n+\t// Try as a complete source file.\n+\tfile, err := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n+\tif err == nil {\n+\t\treturn file, nil\n+\t}\n+\t// If the source is missing a package clause, try as a source fragment; otherwise fail.\n+\tif !strings.Contains(err.Error(), \"expected 'package'\") {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Try as a declaration list by prepending a package clause in front of src.\n+\t// Use ';' not '\\n' to keep line numbers intact.\n+\tpsrc := append([]byte(\"package p;\"), src...)\n+\tfile, err = parser.ParseFile(fset, \"\", psrc, parser.ParseComments)\n+\tif err == nil {\n+\t\treturn file.Decls, nil\n+\t}\n+\t// If the source is missing a declaration, try as a statement list; otherwise fail.\n+\tif !strings.Contains(err.Error(), \"expected declaration\") {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Try as statement list by wrapping a function around src.\n+\tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '}')\n+\tfile, err = parser.ParseFile(fset, \"\", fsrc, parser.ParseComments)\n+\tif err == nil {\n+\t\treturn file.Decls[0].(*ast.FuncDecl).Body.List, nil\n+\t}\n+\n+\t// Failed, and out of options.\n+\treturn nil, err\n+}"}, {"sha": "7d7940bb517a45559eba6886d851c2f5e04e7078", "filename": "libgo/go/go/format/format_test.go", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package format\n+\n+import (\n+\t\"bytes\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"io/ioutil\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+const testfile = \"format_test.go\"\n+\n+func diff(t *testing.T, dst, src []byte) {\n+\tline := 1\n+\toffs := 0 // line offset\n+\tfor i := 0; i < len(dst) && i < len(src); i++ {\n+\t\td := dst[i]\n+\t\ts := src[i]\n+\t\tif d != s {\n+\t\t\tt.Errorf(\"dst:%d: %s\\n\", line, dst[offs:i+1])\n+\t\t\tt.Errorf(\"src:%d: %s\\n\", line, src[offs:i+1])\n+\t\t\treturn\n+\t\t}\n+\t\tif s == '\\n' {\n+\t\t\tline++\n+\t\t\toffs = i + 1\n+\t\t}\n+\t}\n+\tif len(dst) != len(src) {\n+\t\tt.Errorf(\"len(dst) = %d, len(src) = %d\\nsrc = %q\", len(dst), len(src), src)\n+\t}\n+}\n+\n+func TestNode(t *testing.T) {\n+\tsrc, err := ioutil.ReadFile(testfile)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tfset := token.NewFileSet()\n+\tfile, err := parser.ParseFile(fset, testfile, src, parser.ParseComments)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\n+\tif err = Node(&buf, fset, file); err != nil {\n+\t\tt.Fatal(\"Node failed:\", err)\n+\t}\n+\n+\tdiff(t, buf.Bytes(), src)\n+}\n+\n+func TestSource(t *testing.T) {\n+\tsrc, err := ioutil.ReadFile(testfile)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tres, err := Source(src)\n+\tif err != nil {\n+\t\tt.Fatal(\"Source failed:\", err)\n+\t}\n+\n+\tdiff(t, res, src)\n+}\n+\n+// Test cases that are expected to fail are marked by the prefix \"ERROR\".\n+var tests = []string{\n+\t// declaration lists\n+\t`import \"go/format\"`,\n+\t\"var x int\",\n+\t\"var x int\\n\\ntype T struct{}\",\n+\n+\t// statement lists\n+\t\"x := 0\",\n+\t\"f(a, b, c)\\nvar x int = f(1, 2, 3)\",\n+\n+\t// indentation, leading and trailing space\n+\t\"\\tx := 0\\n\\tgo f()\",\n+\t\"\\tx := 0\\n\\tgo f()\\n\\n\\n\",\n+\t\"\\n\\t\\t\\n\\n\\tx := 0\\n\\tgo f()\\n\\n\\n\",\n+\t\"\\n\\t\\t\\n\\n\\t\\t\\tx := 0\\n\\t\\t\\tgo f()\\n\\n\\n\",\n+\t\"\\n\\t\\t\\n\\n\\t\\t\\tx := 0\\n\\t\\t\\tconst s = `\\nfoo\\n`\\n\\n\\n\", // no indentation inside raw strings\n+\n+\t// erroneous programs\n+\t\"ERRORvar x\",\n+\t\"ERROR1 + 2 +\",\n+\t\"ERRORx :=  0\",\n+}\n+\n+func String(s string) (string, error) {\n+\tres, err := Source([]byte(s))\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn string(res), nil\n+}\n+\n+func TestPartial(t *testing.T) {\n+\tfor _, src := range tests {\n+\t\tif strings.HasPrefix(src, \"ERROR\") {\n+\t\t\t// test expected to fail\n+\t\t\tsrc = src[5:] // remove ERROR prefix\n+\t\t\tres, err := String(src)\n+\t\t\tif err == nil && res == src {\n+\t\t\t\tt.Errorf(\"formatting succeeded but was expected to fail:\\n%q\", src)\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// test expected to succeed\n+\t\t\tres, err := String(src)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"formatting failed (%s):\\n%q\", err, src)\n+\t\t\t} else if res != src {\n+\t\t\t\tt.Errorf(\"formatting incorrect:\\nsource: %q\\nresult: %q\", src, res)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "00757e0d753300944ef057777a751273852c6ee5", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -578,14 +578,15 @@ func (p *parser) parseTypeName() ast.Expr {\n \treturn ident\n }\n \n-func (p *parser) parseArrayType(ellipsisOk bool) ast.Expr {\n+func (p *parser) parseArrayType() ast.Expr {\n \tif p.trace {\n \t\tdefer un(trace(p, \"ArrayType\"))\n \t}\n \n \tlbrack := p.expect(token.LBRACK)\n \tvar len ast.Expr\n-\tif ellipsisOk && p.tok == token.ELLIPSIS {\n+\t// always permit ellipsis for more fault-tolerant parsing\n+\tif p.tok == token.ELLIPSIS {\n \t\tlen = &ast.Ellipsis{Ellipsis: p.pos}\n \t\tp.next()\n \t} else if p.tok != token.RBRACK {\n@@ -697,7 +698,7 @@ func (p *parser) tryVarType(isParam bool) ast.Expr {\n \tif isParam && p.tok == token.ELLIPSIS {\n \t\tpos := p.pos\n \t\tp.next()\n-\t\ttyp := p.tryIdentOrType(isParam) // don't use parseType so we can provide better error message\n+\t\ttyp := p.tryIdentOrType() // don't use parseType so we can provide better error message\n \t\tif typ != nil {\n \t\t\tp.resolve(typ)\n \t\t} else {\n@@ -706,7 +707,7 @@ func (p *parser) tryVarType(isParam bool) ast.Expr {\n \t\t}\n \t\treturn &ast.Ellipsis{Ellipsis: pos, Elt: typ}\n \t}\n-\treturn p.tryIdentOrType(false)\n+\treturn p.tryIdentOrType()\n }\n \n // If the result is an identifier, it is not resolved.\n@@ -943,12 +944,12 @@ func (p *parser) parseChanType() *ast.ChanType {\n }\n \n // If the result is an identifier, it is not resolved.\n-func (p *parser) tryIdentOrType(ellipsisOk bool) ast.Expr {\n+func (p *parser) tryIdentOrType() ast.Expr {\n \tswitch p.tok {\n \tcase token.IDENT:\n \t\treturn p.parseTypeName()\n \tcase token.LBRACK:\n-\t\treturn p.parseArrayType(ellipsisOk)\n+\t\treturn p.parseArrayType()\n \tcase token.STRUCT:\n \t\treturn p.parseStructType()\n \tcase token.MUL:\n@@ -975,7 +976,7 @@ func (p *parser) tryIdentOrType(ellipsisOk bool) ast.Expr {\n }\n \n func (p *parser) tryType() ast.Expr {\n-\ttyp := p.tryIdentOrType(false)\n+\ttyp := p.tryIdentOrType()\n \tif typ != nil {\n \t\tp.resolve(typ)\n \t}\n@@ -1083,7 +1084,7 @@ func (p *parser) parseOperand(lhs bool) ast.Expr {\n \t\treturn p.parseFuncTypeOrLit()\n \t}\n \n-\tif typ := p.tryIdentOrType(true); typ != nil {\n+\tif typ := p.tryIdentOrType(); typ != nil {\n \t\t// could be type for composite literal or conversion\n \t\t_, isIdent := typ.(*ast.Ident)\n \t\tassert(!isIdent, \"type cannot be identifier\")\n@@ -1802,7 +1803,7 @@ func (p *parser) parseSwitchStmt() ast.Stmt {\n \t\t\t\t//\n \t\t\t\t//\tswitch t := 0; t := x.(T) { ... }\n \t\t\t\t//\n-\t\t\t\t// (this code is not valid Go because the first t will\n+\t\t\t\t// (this code is not valid Go because the first t\n \t\t\t\t// cannot be accessed and thus is never used, the extra\n \t\t\t\t// scope is needed for the correct error message).\n \t\t\t\t//"}, {"sha": "cd5b67b82df3e005aaf775e211d13b91732dd5de", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 60, "deletions": 45, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -730,7 +730,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int) {\n \n \tcase *ast.FuncLit:\n \t\tp.expr(x.Type)\n-\t\tp.funcBody(x.Body, p.distance(x.Type.Pos(), p.pos), true)\n+\t\tp.adjBlock(p.distanceFrom(x.Type.Pos()), blank, x.Body)\n \n \tcase *ast.ParenExpr:\n \t\tif _, hasParens := x.X.(*ast.ParenExpr); hasParens {\n@@ -900,7 +900,11 @@ func (p *printer) stmtList(list []ast.Stmt, nindent int, nextIsRBrace bool) {\n \t\tif _, isEmpty := s.(*ast.EmptyStmt); !isEmpty {\n \t\t\t// _indent == 0 only for lists of switch/select case clauses;\n \t\t\t// in those cases each clause is a new section\n-\t\t\tp.linebreak(p.lineFor(s.Pos()), 1, ignore, i == 0 || nindent == 0 || multiLine)\n+\t\t\tif len(p.output) > 0 {\n+\t\t\t\t// only print line break if we are not at the beginning of the output\n+\t\t\t\t// (i.e., we are not printing only a partial program)\n+\t\t\t\tp.linebreak(p.lineFor(s.Pos()), 1, ignore, i == 0 || nindent == 0 || multiLine)\n+\t\t\t}\n \t\t\tp.stmt(s, nextIsRBrace && i == len(list)-1)\n \t\t\tmultiLine = p.isMultiLine(s)\n \t\t\ti++\n@@ -912,11 +916,11 @@ func (p *printer) stmtList(list []ast.Stmt, nindent int, nextIsRBrace bool) {\n }\n \n // block prints an *ast.BlockStmt; it always spans at least two lines.\n-func (p *printer) block(s *ast.BlockStmt, nindent int) {\n-\tp.print(s.Pos(), token.LBRACE)\n-\tp.stmtList(s.List, nindent, true)\n-\tp.linebreak(p.lineFor(s.Rbrace), 1, ignore, true)\n-\tp.print(s.Rbrace, token.RBRACE)\n+func (p *printer) block(b *ast.BlockStmt, nindent int) {\n+\tp.print(b.Lbrace, token.LBRACE)\n+\tp.stmtList(b.List, nindent, true)\n+\tp.linebreak(p.lineFor(b.Rbrace), 1, ignore, true)\n+\tp.print(b.Rbrace, token.RBRACE)\n }\n \n func isTypeName(x ast.Expr) bool {\n@@ -1421,39 +1425,43 @@ func (p *printer) nodeSize(n ast.Node, maxSize int) (size int) {\n \treturn\n }\n \n-func (p *printer) isOneLineFunc(b *ast.BlockStmt, headerSize int) bool {\n+// bodySize is like nodeSize but it is specialized for *ast.BlockStmt's.\n+func (p *printer) bodySize(b *ast.BlockStmt, maxSize int) int {\n \tpos1 := b.Pos()\n \tpos2 := b.Rbrace\n \tif pos1.IsValid() && pos2.IsValid() && p.lineFor(pos1) != p.lineFor(pos2) {\n \t\t// opening and closing brace are on different lines - don't make it a one-liner\n-\t\treturn false\n+\t\treturn maxSize + 1\n \t}\n \tif len(b.List) > 5 || p.commentBefore(p.posFor(pos2)) {\n \t\t// too many statements or there is a comment inside - don't make it a one-liner\n-\t\treturn false\n+\t\treturn maxSize + 1\n \t}\n \t// otherwise, estimate body size\n-\tconst maxSize = 100\n \tbodySize := 0\n \tfor i, s := range b.List {\n \t\tif i > 0 {\n \t\t\tbodySize += 2 // space for a semicolon and blank\n \t\t}\n \t\tbodySize += p.nodeSize(s, maxSize)\n \t}\n-\treturn headerSize+bodySize <= maxSize\n+\treturn bodySize\n }\n \n-func (p *printer) funcBody(b *ast.BlockStmt, headerSize int, isLit bool) {\n+// adjBlock prints an \"adjacent\" block (e.g., a for-loop or function body) following\n+// a header (e.g., a for-loop control clause or function signature) of given headerSize.\n+// If the header's and block's size are \"small enough\" and the block is \"simple enough\",\n+// the block is printed on the current line, without line breaks, spaced from the header\n+// by sep. Otherwise the block's opening \"{\" is printed on the current line, followed by\n+// lines for the block's statements and its closing \"}\".\n+//\n+func (p *printer) adjBlock(headerSize int, sep whiteSpace, b *ast.BlockStmt) {\n \tif b == nil {\n \t\treturn\n \t}\n \n-\tif p.isOneLineFunc(b, headerSize) {\n-\t\tsep := vtab\n-\t\tif isLit {\n-\t\t\tsep = blank\n-\t\t}\n+\tconst maxSize = 100\n+\tif headerSize+p.bodySize(b, maxSize) <= maxSize {\n \t\tp.print(sep, b.Lbrace, token.LBRACE)\n \t\tif len(b.List) > 0 {\n \t\t\tp.print(blank)\n@@ -1469,17 +1477,20 @@ func (p *printer) funcBody(b *ast.BlockStmt, headerSize int, isLit bool) {\n \t\treturn\n \t}\n \n-\tp.print(blank)\n+\tif sep != ignore {\n+\t\tp.print(blank) // always use blank\n+\t}\n \tp.block(b, 1)\n }\n \n-// distance returns the column difference between from and to if both\n-// are on the same line; if they are on different lines (or unknown)\n-// the result is infinity.\n-func (p *printer) distance(from0 token.Pos, to token.Position) int {\n-\tfrom := p.posFor(from0)\n-\tif from.IsValid() && to.IsValid() && from.Line == to.Line {\n-\t\treturn to.Column - from.Column\n+// distanceFrom returns the column difference between from and p.pos (the current\n+// estimated position) if both are on the same line; if they are on different lines\n+// (or unknown) the result is infinity.\n+func (p *printer) distanceFrom(from token.Pos) int {\n+\tif from.IsValid() && p.pos.IsValid() {\n+\t\tif f := p.posFor(from); f.Line == p.pos.Line {\n+\t\t\treturn p.pos.Column - f.Column\n+\t\t}\n \t}\n \treturn infinity\n }\n@@ -1493,7 +1504,7 @@ func (p *printer) funcDecl(d *ast.FuncDecl) {\n \t}\n \tp.expr(d.Name)\n \tp.signature(d.Type.Params, d.Type.Results)\n-\tp.funcBody(d.Body, p.distance(d.Pos(), p.pos), false)\n+\tp.adjBlock(p.distanceFrom(d.Pos()), vtab, d.Body)\n }\n \n func (p *printer) decl(decl ast.Decl) {\n@@ -1523,31 +1534,35 @@ func declToken(decl ast.Decl) (tok token.Token) {\n \treturn\n }\n \n-func (p *printer) file(src *ast.File) {\n-\tp.setComment(src.Doc)\n-\tp.print(src.Pos(), token.PACKAGE, blank)\n-\tp.expr(src.Name)\n-\n-\tif len(src.Decls) > 0 {\n-\t\ttok := token.ILLEGAL\n-\t\tfor _, d := range src.Decls {\n-\t\t\tprev := tok\n-\t\t\ttok = declToken(d)\n-\t\t\t// if the declaration token changed (e.g., from CONST to TYPE)\n-\t\t\t// or the next declaration has documentation associated with it,\n-\t\t\t// print an empty line between top-level declarations\n-\t\t\t// (because p.linebreak is called with the position of d, which\n-\t\t\t// is past any documentation, the minimum requirement is satisfied\n-\t\t\t// even w/o the extra getDoc(d) nil-check - leave it in case the\n-\t\t\t// linebreak logic improves - there's already a TODO).\n+func (p *printer) declList(list []ast.Decl) {\n+\ttok := token.ILLEGAL\n+\tfor _, d := range list {\n+\t\tprev := tok\n+\t\ttok = declToken(d)\n+\t\t// If the declaration token changed (e.g., from CONST to TYPE)\n+\t\t// or the next declaration has documentation associated with it,\n+\t\t// print an empty line between top-level declarations.\n+\t\t// (because p.linebreak is called with the position of d, which\n+\t\t// is past any documentation, the minimum requirement is satisfied\n+\t\t// even w/o the extra getDoc(d) nil-check - leave it in case the\n+\t\t// linebreak logic improves - there's already a TODO).\n+\t\tif len(p.output) > 0 {\n+\t\t\t// only print line break if we are not at the beginning of the output\n+\t\t\t// (i.e., we are not printing only a partial program)\n \t\t\tmin := 1\n \t\t\tif prev != tok || getDoc(d) != nil {\n \t\t\t\tmin = 2\n \t\t\t}\n \t\t\tp.linebreak(p.lineFor(d.Pos()), min, ignore, false)\n-\t\t\tp.decl(d)\n \t\t}\n+\t\tp.decl(d)\n \t}\n+}\n \n+func (p *printer) file(src *ast.File) {\n+\tp.setComment(src.Doc)\n+\tp.print(src.Pos(), token.PACKAGE, blank)\n+\tp.expr(src.Name)\n+\tp.declList(src.Decls)\n \tp.print(newline)\n }"}, {"sha": "5b29affcb7db1aef9dac200d177e6373a11296de", "filename": "libgo/go/go/printer/performance_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -20,7 +20,7 @@ import (\n var testfile *ast.File\n \n func testprint(out io.Writer, file *ast.File) {\n-\tif err := (&Config{TabIndent | UseSpaces, 8}).Fprint(out, fset, file); err != nil {\n+\tif err := (&Config{TabIndent | UseSpaces, 8, 0}).Fprint(out, fset, file); err != nil {\n \t\tlog.Fatalf(\"print error: %s\", err)\n \t}\n }"}, {"sha": "5d75f09167d6d29d0902861de6e1727107710ae8", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -165,15 +165,15 @@ func (p *printer) atLineBegin(pos token.Position) {\n \t// write indentation\n \t// use \"hard\" htabs - indentation columns\n \t// must not be discarded by the tabwriter\n-\tfor i := 0; i < p.indent; i++ {\n+\tn := p.Config.Indent + p.indent // include base indentation\n+\tfor i := 0; i < n; i++ {\n \t\tp.output = append(p.output, '\\t')\n \t}\n \n \t// update positions\n-\ti := p.indent\n-\tp.pos.Offset += i\n-\tp.pos.Column += i\n-\tp.out.Column += i\n+\tp.pos.Offset += n\n+\tp.pos.Column += n\n+\tp.out.Column += n\n }\n \n // writeByte writes ch n times to p.output and updates p.pos.\n@@ -452,7 +452,7 @@ func trimRight(s string) string {\n \n // stripCommonPrefix removes a common prefix from /*-style comment lines (unless no\n // comment line is indented, all but the first line have some form of space prefix).\n-// The prefix is computed using heuristics such that is is likely that the comment\n+// The prefix is computed using heuristics such that is likely that the comment\n // contents are nicely laid out after re-printing each line using the printer's\n // current indentation.\n //\n@@ -1032,16 +1032,27 @@ func (p *printer) printNode(node interface{}) error {\n \tcase ast.Expr:\n \t\tp.expr(n)\n \tcase ast.Stmt:\n-\t\t// A labeled statement will un-indent to position the\n-\t\t// label. Set indent to 1 so we don't get indent \"underflow\".\n-\t\tif _, labeledStmt := n.(*ast.LabeledStmt); labeledStmt {\n+\t\t// A labeled statement will un-indent to position the label.\n+\t\t// Set p.indent to 1 so we don't get indent \"underflow\".\n+\t\tif _, ok := n.(*ast.LabeledStmt); ok {\n \t\t\tp.indent = 1\n \t\t}\n \t\tp.stmt(n, false)\n \tcase ast.Decl:\n \t\tp.decl(n)\n \tcase ast.Spec:\n \t\tp.spec(n, 1, false)\n+\tcase []ast.Stmt:\n+\t\t// A labeled statement will un-indent to position the label.\n+\t\t// Set p.indent to 1 so we don't get indent \"underflow\".\n+\t\tfor _, s := range n {\n+\t\t\tif _, ok := s.(*ast.LabeledStmt); ok {\n+\t\t\t\tp.indent = 1\n+\t\t\t}\n+\t\t}\n+\t\tp.stmtList(n, 0, false)\n+\tcase []ast.Decl:\n+\t\tp.declList(n)\n \tcase *ast.File:\n \t\tp.file(n)\n \tdefault:\n@@ -1174,6 +1185,7 @@ const (\n type Config struct {\n \tMode     Mode // default: 0\n \tTabwidth int  // default: 8\n+\tIndent   int  // default: 0 (all code is indented at least by this much)\n }\n \n // fprint implements Fprint and takes a nodesSizes map for setting up the printer state.\n@@ -1235,8 +1247,8 @@ type CommentedNode struct {\n \n // Fprint \"pretty-prints\" an AST node to output for a given configuration cfg.\n // Position information is interpreted relative to the file set fset.\n-// The node type must be *ast.File, *CommentedNode, or assignment-compatible\n-// to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.\n+// The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt,\n+// or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.\n //\n func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) error {\n \treturn cfg.fprint(output, fset, node, make(map[ast.Node]int))"}, {"sha": "8454ac12b9e7e45afa45d52ef0b25dd782d5d83e", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -434,6 +434,98 @@ func (t *t) foo(a, b, c int) int {\n \t}\n }\n \n+var decls = []string{\n+\t`import \"fmt\"`,\n+\t\"const pi = 3.1415\\nconst e = 2.71828\\n\\nvar x = pi\",\n+\t\"func sum(x, y int) int\\t{ return x + y }\",\n+}\n+\n+func TestDeclLists(t *testing.T) {\n+\tfor _, src := range decls {\n+\t\tfile, err := parser.ParseFile(fset, \"\", \"package p;\"+src, parser.ParseComments)\n+\t\tif err != nil {\n+\t\t\tpanic(err) // error in test\n+\t\t}\n+\n+\t\tvar buf bytes.Buffer\n+\t\terr = Fprint(&buf, fset, file.Decls) // only print declarations\n+\t\tif err != nil {\n+\t\t\tpanic(err) // error in test\n+\t\t}\n+\n+\t\tout := buf.String()\n+\t\tif out != src {\n+\t\t\tt.Errorf(\"\\ngot : %q\\nwant: %q\\n\", out, src)\n+\t\t}\n+\t}\n+}\n+\n+var stmts = []string{\n+\t\"i := 0\",\n+\t\"select {}\\nvar a, b = 1, 2\\nreturn a + b\",\n+\t\"go f()\\ndefer func() {}()\",\n+}\n+\n+func TestStmtLists(t *testing.T) {\n+\tfor _, src := range stmts {\n+\t\tfile, err := parser.ParseFile(fset, \"\", \"package p; func _() {\"+src+\"}\", parser.ParseComments)\n+\t\tif err != nil {\n+\t\t\tpanic(err) // error in test\n+\t\t}\n+\n+\t\tvar buf bytes.Buffer\n+\t\terr = Fprint(&buf, fset, file.Decls[0].(*ast.FuncDecl).Body.List) // only print statements\n+\t\tif err != nil {\n+\t\t\tpanic(err) // error in test\n+\t\t}\n+\n+\t\tout := buf.String()\n+\t\tif out != src {\n+\t\t\tt.Errorf(\"\\ngot : %q\\nwant: %q\\n\", out, src)\n+\t\t}\n+\t}\n+}\n+\n+func TestBaseIndent(t *testing.T) {\n+\t// The testfile must not contain multi-line raw strings since those\n+\t// are not indented (because their values must not change) and make\n+\t// this test fail.\n+\tconst filename = \"printer.go\"\n+\tsrc, err := ioutil.ReadFile(filename)\n+\tif err != nil {\n+\t\tpanic(err) // error in test\n+\t}\n+\n+\tfile, err := parser.ParseFile(fset, filename, src, 0)\n+\tif err != nil {\n+\t\tpanic(err) // error in test\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\tfor indent := 0; indent < 4; indent++ {\n+\t\tbuf.Reset()\n+\t\t(&Config{Tabwidth: tabwidth, Indent: indent}).Fprint(&buf, fset, file)\n+\t\t// all code must be indented by at least 'indent' tabs\n+\t\tlines := bytes.Split(buf.Bytes(), []byte{'\\n'})\n+\t\tfor i, line := range lines {\n+\t\t\tif len(line) == 0 {\n+\t\t\t\tcontinue // empty lines don't have indentation\n+\t\t\t}\n+\t\t\tn := 0\n+\t\t\tfor j, b := range line {\n+\t\t\t\tif b != '\\t' {\n+\t\t\t\t\t// end of indentation\n+\t\t\t\t\tn = j\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif n < indent {\n+\t\t\t\tt.Errorf(\"line %d: got only %d tabs; want at least %d: %q\", i, n, indent, line)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n // TestFuncType tests that an ast.FuncType with a nil Params field\n // can be printed (per go/ast specification). Test case for issue 3870.\n func TestFuncType(t *testing.T) {"}, {"sha": "3b298f95ef1afe111977de90b1d8cdb37290d46e", "filename": "libgo/go/go/printer/testdata/statements.golden", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -241,7 +241,7 @@ func _() {\n \t}\n }\n \n-// Formatting of for-statement headers.\n+// Formatting of for-statement headers for single-line for-loops.\n func _() {\n \tfor {\n \t}\n@@ -279,6 +279,86 @@ func _() {\n \t}\t// no parens printed\n }\n \n+// Formatting of for-statement headers for multi-line for-loops.\n+func _() {\n+\tfor {\n+\t}\n+\tfor expr {\n+\t}\n+\tfor expr {\n+\t}\t// no parens printed\n+\tfor {\n+\t}\t// no semicolons printed\n+\tfor x := expr; ; {\n+\t\tuse(x)\n+\t}\n+\tfor expr {\n+\t}\t// no semicolons printed\n+\tfor expr {\n+\t}\t// no semicolons and parens printed\n+\tfor ; ; expr = false {\n+\t}\n+\tfor x := expr; expr; {\n+\t\tuse(x)\n+\t}\n+\tfor x := expr; ; expr = false {\n+\t\tuse(x)\n+\t}\n+\tfor ; expr; expr = false {\n+\t}\n+\tfor x := expr; expr; expr = false {\n+\t\tuse(x)\n+\t}\n+\tfor x := range []int{} {\n+\t\tuse(x)\n+\t}\n+\tfor x := range []int{} {\n+\t\tuse(x)\n+\t}\t// no parens printed\n+}\n+\n+// Formatting of selected short single- and multi-line statements.\n+func _() {\n+\tif cond {\n+\t}\n+\tif cond {\n+\t}\t// multiple lines\n+\tif cond {\n+\t} else {\n+\t}\t// else clause always requires multiple lines\n+\n+\tfor {\n+\t}\n+\tfor i := 0; i < len(a); 1++ {\n+\t}\n+\tfor i := 0; i < len(a); 1++ {\n+\t\ta[i] = i\n+\t}\n+\tfor i := 0; i < len(a); 1++ {\n+\t\ta[i] = i\n+\t}\t// multiple lines\n+\n+\tfor i := range a {\n+\t}\n+\tfor i := range a {\n+\t\ta[i] = i\n+\t}\n+\tfor i := range a {\n+\t\ta[i] = i\n+\t}\t// multiple lines\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\ta <- <-b\n+\t\t}\n+\t}()\n+\tdefer func() {\n+\t\tif x := recover(); x != nil {\n+\t\t\terr = fmt.Sprintf(\"error: %s\", x.msg)\n+\t\t}\n+\t}()\n+}\n+\n // Don't remove mandatory parentheses around composite literals in control clauses.\n func _() {\n \t// strip parentheses - no composite literals or composite literals don't start with a type name"}, {"sha": "e7fcc0e5409927f48d5b6f4d079cd539bdfd651e", "filename": "libgo/go/go/printer/testdata/statements.input", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -223,7 +223,7 @@ func _() {\n }\n \n \n-// Formatting of for-statement headers.\n+// Formatting of for-statement headers for single-line for-loops.\n func _() {\n \tfor{}\n \tfor expr {}\n@@ -235,14 +235,70 @@ func _() {\n \tfor; ; expr = false {}\n \tfor x :=expr; expr; {use(x)}\n \tfor x := expr;; expr=false {use(x)}\n-\tfor;expr;expr =false {\n-\t}\n+\tfor;expr;expr =false {}\n \tfor x := expr;expr;expr = false { use(x) }\n \tfor x := range []int{} { use(x) }\n \tfor x := range (([]int{})) { use(x) }  // no parens printed\n }\n \n \n+// Formatting of for-statement headers for multi-line for-loops.\n+func _() {\n+\tfor{\n+\t}\n+\tfor expr {\n+\t}\n+\tfor (expr) {\n+\t}  // no parens printed\n+\tfor;;{\n+\t}  // no semicolons printed\n+\tfor x :=expr;; {use( x)\n+\t}\n+\tfor; expr;{\n+\t}  // no semicolons printed\n+\tfor; ((expr));{\n+\t}  // no semicolons and parens printed\n+\tfor; ; expr = false {\n+\t}\n+\tfor x :=expr; expr; {use(x)\n+\t}\n+\tfor x := expr;; expr=false {use(x)\n+\t}\n+\tfor;expr;expr =false {\n+\t}\n+\tfor x := expr;expr;expr = false {\n+\tuse(x)\n+\t}\n+\tfor x := range []int{} {\n+\tuse(x) }\n+\tfor x := range (([]int{})) {\n+\tuse(x) }  // no parens printed\n+}\n+\n+\n+// Formatting of selected short single- and multi-line statements.\n+func _() {\n+\tif cond {}\n+\tif cond {\n+\t} // multiple lines\n+\tif cond {} else {} // else clause always requires multiple lines\n+\n+\tfor {}\n+\tfor i := 0; i < len(a); 1++ {}\n+\tfor i := 0; i < len(a); 1++ { a[i] = i }\n+\tfor i := 0; i < len(a); 1++ { a[i] = i\n+\t} // multiple lines\n+\n+\tfor i := range a {}\n+\tfor i := range a { a[i] = i }\n+\tfor i := range a { a[i] = i\n+\t} // multiple lines\n+\n+\tgo func() { for { a <- <-b } }()\n+\tdefer func() { if x := recover(); x != nil { err = fmt.Sprintf(\"error: %s\", x.msg) } }()\n+}\n+\n+\n // Don't remove mandatory parentheses around composite literals in control clauses.\n func _() {\n \t// strip parentheses - no composite literals or composite literals don't start with a type name"}, {"sha": "a9740931fc2aaee247cb4986dc0bf8ac8dd2057f", "filename": "libgo/go/html/template/js.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -14,7 +14,7 @@ import (\n )\n \n // nextJSCtx returns the context that determines whether a slash after the\n-// given run of tokens tokens starts a regular expression instead of a division\n+// given run of tokens starts a regular expression instead of a division\n // operator: / or /=.\n //\n // This assumes that the token run does not include any string tokens, comment"}, {"sha": "9b731fdc4fa590eddbacf00cc078037870f82d23", "filename": "libgo/go/image/jpeg/huffman.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -163,7 +163,7 @@ func (d *decoder) processDHT(n int) error {\n \n // Returns the next Huffman-coded value from the bit stream, decoded according to h.\n // TODO(nigeltao): This decoding algorithm is simple, but slow. A lookahead table, instead of always\n-// peeling off only 1 bit at at time, ought to be faster.\n+// peeling off only 1 bit at time, ought to be faster.\n func (d *decoder) decodeHuffman(h *huffman) (uint8, error) {\n \tif h.length == 0 {\n \t\treturn 0, FormatError(\"uninitialized Huffman table\")"}, {"sha": "c4ad12ffcd12dd9d641906b4b073c9f6467a3688", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 105, "deletions": 50, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -4,9 +4,9 @@\n \n // +build !windows,!plan9\n \n-// Package syslog provides a simple interface to the system log service. It\n-// can send messages to the syslog daemon using UNIX domain sockets, UDP, or\n-// TCP connections.\n+// Package syslog provides a simple interface to the system log\n+// service. It can send messages to the syslog daemon using UNIX\n+// domain sockets, UDP, or TCP connections.\n package syslog\n \n import (\n@@ -15,11 +15,21 @@ import (\n \t\"log\"\n \t\"net\"\n \t\"os\"\n+\t\"time\"\n )\n \n+// The Priority is a combination of the syslog facility and\n+// severity. For example, LOG_ALERT | LOG_FTP sends an alert severity\n+// message from the FTP facility. The default severity is LOG_EMERG;\n+// the default facility is LOG_KERN.\n type Priority int\n \n+const severityMask = 0x07\n+const facilityMask = 0xf8\n+\n const (\n+\t// Severity.\n+\n \t// From /usr/include/sys/syslog.h.\n \t// These are the same on Linux, BSD, and OS X.\n \tLOG_EMERG Priority = iota\n@@ -32,133 +42,178 @@ const (\n \tLOG_DEBUG\n )\n \n+const (\n+\t// Facility.\n+\n+\t// From /usr/include/sys/syslog.h.\n+\t// These are the same up to LOG_FTP on Linux, BSD, and OS X.\n+\tLOG_KERN Priority = iota << 3\n+\tLOG_USER\n+\tLOG_MAIL\n+\tLOG_DAEMON\n+\tLOG_AUTH\n+\tLOG_SYSLOG\n+\tLOG_LPR\n+\tLOG_NEWS\n+\tLOG_UUCP\n+\tLOG_CRON\n+\tLOG_AUTHPRIV\n+\tLOG_FTP\n+\t_ // unused\n+\t_ // unused\n+\t_ // unused\n+\t_ // unused\n+\tLOG_LOCAL0\n+\tLOG_LOCAL1\n+\tLOG_LOCAL2\n+\tLOG_LOCAL3\n+\tLOG_LOCAL4\n+\tLOG_LOCAL5\n+\tLOG_LOCAL6\n+\tLOG_LOCAL7\n+)\n+\n // A Writer is a connection to a syslog server.\n type Writer struct {\n \tpriority Priority\n-\tprefix   string\n+\ttag      string\n+\thostname string\n \tconn     serverConn\n }\n \n type serverConn interface {\n-\twriteBytes(p Priority, prefix string, b []byte) (int, error)\n-\twriteString(p Priority, prefix string, s string) (int, error)\n+\twriteString(p Priority, hostname, tag, s string) (int, error)\n \tclose() error\n }\n \n type netConn struct {\n \tconn net.Conn\n }\n \n-// New establishes a new connection to the system log daemon.\n-// Each write to the returned writer sends a log message with\n-// the given priority and prefix.\n-func New(priority Priority, prefix string) (w *Writer, err error) {\n-\treturn Dial(\"\", \"\", priority, prefix)\n+// New establishes a new connection to the system log daemon.  Each\n+// write to the returned writer sends a log message with the given\n+// priority and prefix.\n+func New(priority Priority, tag string) (w *Writer, err error) {\n+\treturn Dial(\"\", \"\", priority, tag)\n }\n \n-// Dial establishes a connection to a log daemon by connecting\n-// to address raddr on the network net.\n-// Each write to the returned writer sends a log message with\n-// the given priority and prefix.\n-func Dial(network, raddr string, priority Priority, prefix string) (w *Writer, err error) {\n-\tif prefix == \"\" {\n-\t\tprefix = os.Args[0]\n+// Dial establishes a connection to a log daemon by connecting to\n+// address raddr on the network net.  Each write to the returned\n+// writer sends a log message with the given facility, severity and\n+// tag.\n+func Dial(network, raddr string, priority Priority, tag string) (w *Writer, err error) {\n+\tif priority < 0 || priority > LOG_LOCAL7|LOG_DEBUG {\n+\t\treturn nil, errors.New(\"log/syslog: invalid priority\")\n \t}\n+\n+\tif tag == \"\" {\n+\t\ttag = os.Args[0]\n+\t}\n+\n+\thostname, _ := os.Hostname()\n+\n \tvar conn serverConn\n \tif network == \"\" {\n \t\tconn, err = unixSyslog()\n+\t\tif hostname == \"\" {\n+\t\t\thostname = \"localhost\"\n+\t\t}\n \t} else {\n \t\tvar c net.Conn\n \t\tc, err = net.Dial(network, raddr)\n \t\tconn = netConn{c}\n+\t\tif hostname == \"\" {\n+\t\t\thostname = c.LocalAddr().String()\n+\t\t}\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\treturn &Writer{priority, prefix, conn}, err\n+\n+\treturn &Writer{priority: priority, tag: tag, hostname: hostname, conn: conn}, nil\n }\n \n // Write sends a log message to the syslog daemon.\n func (w *Writer) Write(b []byte) (int, error) {\n-\tif w.priority > LOG_DEBUG || w.priority < LOG_EMERG {\n-\t\treturn 0, errors.New(\"log/syslog: invalid priority\")\n-\t}\n-\treturn w.conn.writeBytes(w.priority, w.prefix, b)\n-}\n-\n-func (w *Writer) writeString(p Priority, s string) (int, error) {\n-\treturn w.conn.writeString(p, w.prefix, s)\n+\treturn w.writeString(w.priority, string(b))\n }\n \n func (w *Writer) Close() error { return w.conn.close() }\n \n-// Emerg logs a message using the LOG_EMERG priority.\n+// Emerg logs a message with severity LOG_EMERG, ignoring the severity\n+// passed to New.\n func (w *Writer) Emerg(m string) (err error) {\n \t_, err = w.writeString(LOG_EMERG, m)\n \treturn err\n }\n \n-// Alert logs a message using the LOG_ALERT priority.\n+// Alert logs a message with severity LOG_ALERT, ignoring the severity\n+// passed to New.\n func (w *Writer) Alert(m string) (err error) {\n \t_, err = w.writeString(LOG_ALERT, m)\n \treturn err\n }\n \n-// Crit logs a message using the LOG_CRIT priority.\n+// Crit logs a message with severity LOG_CRIT, ignoring the severity\n+// passed to New.\n func (w *Writer) Crit(m string) (err error) {\n \t_, err = w.writeString(LOG_CRIT, m)\n \treturn err\n }\n \n-// Err logs a message using the LOG_ERR priority.\n+// Err logs a message with severity LOG_ERR, ignoring the severity\n+// passed to New.\n func (w *Writer) Err(m string) (err error) {\n \t_, err = w.writeString(LOG_ERR, m)\n \treturn err\n }\n \n-// Warning logs a message using the LOG_WARNING priority.\n+// Wanring logs a message with severity LOG_WARNING, ignoring the\n+// severity passed to New.\n func (w *Writer) Warning(m string) (err error) {\n \t_, err = w.writeString(LOG_WARNING, m)\n \treturn err\n }\n \n-// Notice logs a message using the LOG_NOTICE priority.\n+// Notice logs a message with severity LOG_NOTICE, ignoring the\n+// severity passed to New.\n func (w *Writer) Notice(m string) (err error) {\n \t_, err = w.writeString(LOG_NOTICE, m)\n \treturn err\n }\n \n-// Info logs a message using the LOG_INFO priority.\n+// Info logs a message with severity LOG_INFO, ignoring the severity\n+// passed to New.\n func (w *Writer) Info(m string) (err error) {\n \t_, err = w.writeString(LOG_INFO, m)\n \treturn err\n }\n \n-// Debug logs a message using the LOG_DEBUG priority.\n+// Debug logs a message with severity LOG_DEBUG, ignoring the severity\n+// passed to New.\n func (w *Writer) Debug(m string) (err error) {\n \t_, err = w.writeString(LOG_DEBUG, m)\n \treturn err\n }\n \n-func (n netConn) writeBytes(p Priority, prefix string, b []byte) (int, error) {\n-\tnl := \"\"\n-\tif len(b) == 0 || b[len(b)-1] != '\\n' {\n-\t\tnl = \"\\n\"\n-\t}\n-\t_, err := fmt.Fprintf(n.conn, \"<%d>%s: %s%s\", p, prefix, b, nl)\n-\tif err != nil {\n-\t\treturn 0, err\n-\t}\n-\treturn len(b), nil\n+func (w *Writer) writeString(p Priority, s string) (int, error) {\n+\treturn w.conn.writeString((w.priority&facilityMask)|(p&severityMask),\n+\t\tw.hostname, w.tag, s)\n }\n \n-func (n netConn) writeString(p Priority, prefix string, s string) (int, error) {\n+// writeString: generates and writes a syslog formatted string. The\n+// format is as follows: <PRI>1 TIMESTAMP HOSTNAME TAG[PID]: MSG\n+func (n netConn) writeString(p Priority, hostname, tag, msg string) (int, error) {\n \tnl := \"\"\n-\tif len(s) == 0 || s[len(s)-1] != '\\n' {\n+\tif len(msg) == 0 || msg[len(msg)-1] != '\\n' {\n \t\tnl = \"\\n\"\n \t}\n-\t_, err := fmt.Fprintf(n.conn, \"<%d>%s: %s%s\", p, prefix, s, nl)\n-\tif err != nil {\n+\ttimestamp := time.Now().Format(time.RFC3339)\n+\tif _, err := fmt.Fprintf(n.conn, \"<%d>1 %s %s %s[%d]: %s%s\", p, timestamp, hostname,\n+\t\ttag, os.Getpid(), msg, nl); err != nil {\n \t\treturn 0, err\n \t}\n-\treturn len(s), nil\n+\treturn len(msg), nil\n }\n \n func (n netConn) close() error {"}, {"sha": "4c0bf1f4e7cd2752c7155d600e92871aaa9f5b7a", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -7,9 +7,11 @@\n package syslog\n \n import (\n+\t\"fmt\"\n \t\"io\"\n \t\"log\"\n \t\"net\"\n+\t\"os\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -49,10 +51,14 @@ func skipNetTest(t *testing.T) bool {\n }\n \n func TestNew(t *testing.T) {\n+\tif LOG_LOCAL7 != 23<<3 {\n+\t\tt.Fatalf(\"LOG_LOCAL7 has wrong value\")\n+\t}\n \tif skipNetTest(t) {\n \t\treturn\n \t}\n-\ts, err := New(LOG_INFO, \"\")\n+\n+\ts, err := New(LOG_INFO|LOG_USER, \"\")\n \tif err != nil {\n \t\tt.Fatalf(\"New() failed: %s\", err)\n \t}\n@@ -64,7 +70,7 @@ func TestNewLogger(t *testing.T) {\n \tif skipNetTest(t) {\n \t\treturn\n \t}\n-\tf, err := NewLogger(LOG_INFO, 0)\n+\tf, err := NewLogger(LOG_USER|LOG_INFO, 0)\n \tif f == nil {\n \t\tt.Error(err)\n \t}\n@@ -74,7 +80,15 @@ func TestDial(t *testing.T) {\n \tif skipNetTest(t) {\n \t\treturn\n \t}\n-\tl, err := Dial(\"\", \"\", LOG_ERR, \"syslog_test\")\n+\tf, err := Dial(\"\", \"\", (LOG_LOCAL7|LOG_DEBUG)+1, \"syslog_test\")\n+\tif f != nil {\n+\t\tt.Fatalf(\"Should have trapped bad priority\")\n+\t}\n+\tf, err = Dial(\"\", \"\", -1, \"syslog_test\")\n+\tif f != nil {\n+\t\tt.Fatalf(\"Should have trapped bad priority\")\n+\t}\n+\tl, err := Dial(\"\", \"\", LOG_USER|LOG_ERR, \"syslog_test\")\n \tif err != nil {\n \t\tt.Fatalf(\"Dial() failed: %s\", err)\n \t}\n@@ -84,16 +98,23 @@ func TestDial(t *testing.T) {\n func TestUDPDial(t *testing.T) {\n \tdone := make(chan string)\n \tstartServer(done)\n-\tl, err := Dial(\"udp\", serverAddr, LOG_INFO, \"syslog_test\")\n+\tl, err := Dial(\"udp\", serverAddr, LOG_USER|LOG_INFO, \"syslog_test\")\n \tif err != nil {\n \t\tt.Fatalf(\"syslog.Dial() failed: %s\", err)\n \t}\n \tmsg := \"udp test\"\n \tl.Info(msg)\n-\texpected := \"<6>syslog_test: udp test\\n\"\n+\texpected := fmt.Sprintf(\"<%d>1 \", LOG_USER+LOG_INFO) + \"%s %s syslog_test[%d]: udp test\\n\"\n \trcvd := <-done\n-\tif rcvd != expected {\n-\t\tt.Fatalf(\"s.Info() = '%q', but wanted '%q'\", rcvd, expected)\n+\tvar parsedHostname, timestamp string\n+\tvar pid int\n+\tif hostname, err := os.Hostname(); err != nil {\n+\t\tt.Fatalf(\"Error retrieving hostname\")\n+\t} else {\n+\t\tif n, err := fmt.Sscanf(rcvd, expected, &timestamp, &parsedHostname, &pid); n != 3 ||\n+\t\t\terr != nil || hostname != parsedHostname {\n+\t\t\tt.Fatalf(\"s.Info() = '%q', didn't match '%q'\", rcvd, expected)\n+\t\t}\n \t}\n }\n \n@@ -104,26 +125,34 @@ func TestWrite(t *testing.T) {\n \t\tmsg string\n \t\texp string\n \t}{\n-\t\t{LOG_ERR, \"syslog_test\", \"\", \"<3>syslog_test: \\n\"},\n-\t\t{LOG_ERR, \"syslog_test\", \"write test\", \"<3>syslog_test: write test\\n\"},\n+\t\t{LOG_USER | LOG_ERR, \"syslog_test\", \"\", \"%s %s syslog_test[%d]: \\n\"},\n+\t\t{LOG_USER | LOG_ERR, \"syslog_test\", \"write test\", \"%s %s syslog_test[%d]: write test\\n\"},\n \t\t// Write should not add \\n if there already is one\n-\t\t{LOG_ERR, \"syslog_test\", \"write test 2\\n\", \"<3>syslog_test: write test 2\\n\"},\n+\t\t{LOG_USER | LOG_ERR, \"syslog_test\", \"write test 2\\n\", \"%s %s syslog_test[%d]: write test 2\\n\"},\n \t}\n \n-\tfor _, test := range tests {\n-\t\tdone := make(chan string)\n-\t\tstartServer(done)\n-\t\tl, err := Dial(\"udp\", serverAddr, test.pri, test.pre)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"syslog.Dial() failed: %s\", err)\n-\t\t}\n-\t\t_, err = io.WriteString(l, test.msg)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"WriteString() failed: %s\", err)\n-\t\t}\n-\t\trcvd := <-done\n-\t\tif rcvd != test.exp {\n-\t\t\tt.Fatalf(\"s.Info() = '%q', but wanted '%q'\", rcvd, test.exp)\n+\tif hostname, err := os.Hostname(); err != nil {\n+\t\tt.Fatalf(\"Error retrieving hostname\")\n+\t} else {\n+\t\tfor _, test := range tests {\n+\t\t\tdone := make(chan string)\n+\t\t\tstartServer(done)\n+\t\t\tl, err := Dial(\"udp\", serverAddr, test.pri, test.pre)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"syslog.Dial() failed: %s\", err)\n+\t\t\t}\n+\t\t\t_, err = io.WriteString(l, test.msg)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"WriteString() failed: %s\", err)\n+\t\t\t}\n+\t\t\trcvd := <-done\n+\t\t\ttest.exp = fmt.Sprintf(\"<%d>1 \", test.pri) + test.exp\n+\t\t\tvar parsedHostname, timestamp string\n+\t\t\tvar pid int\n+\t\t\tif n, err := fmt.Sscanf(rcvd, test.exp, &timestamp, &parsedHostname, &pid); n != 3 ||\n+\t\t\t\terr != nil || hostname != parsedHostname {\n+\t\t\t\tt.Fatalf(\"s.Info() = '%q', didn't match '%q'\", rcvd, test.exp)\n+\t\t\t}\n \t\t}\n \t}\n }"}, {"sha": "2dd7bf63968976f0c87f16fb2c6092bcf8e8ff67", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -180,6 +180,7 @@ func allocBytes(f func()) uint64 {\n // does not cause deep recursion and in turn allocate too much memory.\n // Test case for issue 3807.\n func TestMulUnbalanced(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tx := rndNat(50000)\n \ty := rndNat(40)\n \tallocSize := allocBytes(func() {"}, {"sha": "77e969b41b0ea7b924308572cf6bc3e5d941bee1", "filename": "libgo/go/mime/multipart/multipart.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -37,6 +37,11 @@ type Part struct {\n \n \tdisposition       string\n \tdispositionParams map[string]string\n+\n+\t// r is either a reader directly reading from mr, or it's a\n+\t// wrapper around such a reader, decoding the\n+\t// Content-Transfer-Encoding\n+\tr io.Reader\n }\n \n // FormName returns the name parameter if p has a Content-Disposition\n@@ -94,6 +99,12 @@ func newPart(mr *Reader) (*Part, error) {\n \tif err := bp.populateHeaders(); err != nil {\n \t\treturn nil, err\n \t}\n+\tbp.r = partReader{bp}\n+\tconst cte = \"Content-Transfer-Encoding\"\n+\tif bp.Header.Get(cte) == \"quoted-printable\" {\n+\t\tbp.Header.Del(cte)\n+\t\tbp.r = newQuotedPrintableReader(bp.r)\n+\t}\n \treturn bp, nil\n }\n \n@@ -109,6 +120,17 @@ func (bp *Part) populateHeaders() error {\n // Read reads the body of a part, after its headers and before the\n // next part (if any) begins.\n func (p *Part) Read(d []byte) (n int, err error) {\n+\treturn p.r.Read(d)\n+}\n+\n+// partReader implements io.Reader by reading raw bytes directly from the\n+// wrapped *Part, without doing any Transfer-Encoding decoding.\n+type partReader struct {\n+\tp *Part\n+}\n+\n+func (pr partReader) Read(d []byte) (n int, err error) {\n+\tp := pr.p\n \tdefer func() {\n \t\tp.bytesRead += n\n \t}()"}, {"sha": "d662e834059d80afee347aa0214889f7a77f16cd", "filename": "libgo/go/mime/multipart/multipart_test.go", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -339,16 +339,40 @@ func TestLineContinuation(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"didn't get a part\")\n \t\t}\n-\t\tn, err := io.Copy(ioutil.Discard, part)\n+\t\tvar buf bytes.Buffer\n+\t\tn, err := io.Copy(&buf, part)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"error reading part: %v\", err)\n+\t\t\tt.Errorf(\"error reading part: %v\\nread so far: %q\", err, buf.String())\n \t\t}\n \t\tif n <= 0 {\n \t\t\tt.Errorf(\"read %d bytes; expected >0\", n)\n \t\t}\n \t}\n }\n \n+func TestQuotedPrintableEncoding(t *testing.T) {\n+\t// From http://golang.org/issue/4411\n+\tbody := \"--0016e68ee29c5d515f04cedf6733\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=text\\r\\nContent-Transfer-Encoding: quoted-printable\\r\\n\\r\\nwords words words words words words words words words words words words wor=\\r\\nds words words words words words words words words words words words words =\\r\\nwords words words words words words words words words words words words wor=\\r\\nds words words words words words words words words words words words words =\\r\\nwords words words words words words words words words\\r\\n--0016e68ee29c5d515f04cedf6733\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=submit\\r\\n\\r\\nSubmit\\r\\n--0016e68ee29c5d515f04cedf6733--\"\n+\tr := NewReader(strings.NewReader(body), \"0016e68ee29c5d515f04cedf6733\")\n+\tpart, err := r.NextPart()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif te, ok := part.Header[\"Content-Transfer-Encoding\"]; ok {\n+\t\tt.Errorf(\"unexpected Content-Transfer-Encoding of %q\", te)\n+\t}\n+\tvar buf bytes.Buffer\n+\t_, err = io.Copy(&buf, part)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tgot := buf.String()\n+\twant := \"words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words\"\n+\tif got != want {\n+\t\tt.Errorf(\"wrong part value:\\n got: %q\\nwant: %q\", got, want)\n+\t}\n+}\n+\n // Test parsing an image attachment from gmail, which previously failed.\n func TestNested(t *testing.T) {\n \t// nested-mime is the body part of a multipart/mixed email"}, {"sha": "0a60a6ed554fbed21f63e1568529cd06e8ab3aaa", "filename": "libgo/go/mime/multipart/quotedprintable.go", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fquotedprintable.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fquotedprintable.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fquotedprintable.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The file define a quoted-printable decoder, as specified in RFC 2045.\n+\n+package multipart\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+)\n+\n+type qpReader struct {\n+\tbr   *bufio.Reader\n+\trerr error  // last read error\n+\tline []byte // to be consumed before more of br\n+}\n+\n+func newQuotedPrintableReader(r io.Reader) io.Reader {\n+\treturn &qpReader{\n+\t\tbr: bufio.NewReader(r),\n+\t}\n+}\n+\n+func fromHex(b byte) (byte, error) {\n+\tswitch {\n+\tcase b >= '0' && b <= '9':\n+\t\treturn b - '0', nil\n+\tcase b >= 'A' && b <= 'F':\n+\t\treturn b - 'A' + 10, nil\n+\t}\n+\treturn 0, fmt.Errorf(\"multipart: invalid quoted-printable hex byte 0x%02x\", b)\n+}\n+\n+func (q *qpReader) readHexByte(v []byte) (b byte, err error) {\n+\tif len(v) < 2 {\n+\t\treturn 0, io.ErrUnexpectedEOF\n+\t}\n+\tvar hb, lb byte\n+\tif hb, err = fromHex(v[0]); err != nil {\n+\t\treturn 0, err\n+\t}\n+\tif lb, err = fromHex(v[1]); err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn hb<<4 | lb, nil\n+}\n+\n+func isQPDiscardWhitespace(r rune) bool {\n+\tswitch r {\n+\tcase '\\n', '\\r', ' ', '\\t':\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (q *qpReader) Read(p []byte) (n int, err error) {\n+\tfor len(p) > 0 {\n+\t\tif len(q.line) == 0 {\n+\t\t\tif q.rerr != nil {\n+\t\t\t\treturn n, q.rerr\n+\t\t\t}\n+\t\t\tq.line, q.rerr = q.br.ReadSlice('\\n')\n+\t\t\tq.line = bytes.TrimRightFunc(q.line, isQPDiscardWhitespace)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif len(q.line) == 1 && q.line[0] == '=' {\n+\t\t\t// Soft newline; skipped.\n+\t\t\tq.line = nil\n+\t\t\tcontinue\n+\t\t}\n+\t\tb := q.line[0]\n+\t\tswitch {\n+\t\tcase b == '=':\n+\t\t\tb, err = q.readHexByte(q.line[1:])\n+\t\t\tif err != nil {\n+\t\t\t\treturn n, err\n+\t\t\t}\n+\t\t\tq.line = q.line[2:] // 2 of the 3; other 1 is done below\n+\t\tcase b != '\\t' && (b < ' ' || b > '~'):\n+\t\t\treturn n, fmt.Errorf(\"multipart: invalid unescaped byte 0x%02x in quoted-printable body\", b)\n+\t\t}\n+\t\tp[0] = b\n+\t\tp = p[1:]\n+\t\tq.line = q.line[1:]\n+\t\tn++\n+\t}\n+\treturn n, nil\n+}"}, {"sha": "796a41f42d2794cb1c569a48ecb02db2895e8584", "filename": "libgo/go/mime/multipart/quotedprintable_test.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fquotedprintable_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fquotedprintable_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fquotedprintable_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package multipart\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestQuotedPrintable(t *testing.T) {\n+\ttests := []struct {\n+\t\tin, want string\n+\t\terr      interface{}\n+\t}{\n+\t\t{in: \"foo bar\", want: \"foo bar\"},\n+\t\t{in: \"foo bar=3D\", want: \"foo bar=\"},\n+\t\t{in: \"foo bar=0\", want: \"foo bar\", err: io.ErrUnexpectedEOF},\n+\t\t{in: \"foo bar=ab\", want: \"foo bar\", err: \"multipart: invalid quoted-printable hex byte 0x61\"},\n+\t\t{in: \"foo bar=0D=0A\", want: \"foo bar\\r\\n\"},\n+\t\t{in: \"foo bar=\\r\\n baz\", want: \"foo bar baz\"},\n+\t\t{in: \"foo=\\nbar\", want: \"foobar\"},\n+\t\t{in: \"foo\\x00bar\", want: \"foo\", err: \"multipart: invalid unescaped byte 0x00 in quoted-printable body\"},\n+\t\t{in: \"foo bar\\xff\", want: \"foo bar\", err: \"multipart: invalid unescaped byte 0xff in quoted-printable body\"},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tvar buf bytes.Buffer\n+\t\t_, err := io.Copy(&buf, newQuotedPrintableReader(strings.NewReader(tt.in)))\n+\t\tif got := buf.String(); got != tt.want {\n+\t\t\tt.Errorf(\"for %q, got %q; want %q\", tt.in, got, tt.want)\n+\t\t}\n+\t\tswitch verr := tt.err.(type) {\n+\t\tcase nil:\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"for %q, got unexpected error: %v\", tt.in, err)\n+\t\t\t}\n+\t\tcase string:\n+\t\t\tif got := fmt.Sprint(err); got != verr {\n+\t\t\t\tt.Errorf(\"for %q, got error %q; want %q\", tt.in, got, verr)\n+\t\t\t}\n+\t\tcase error:\n+\t\t\tif err != verr {\n+\t\t\t\tt.Errorf(\"for %q, got error %q; want %q\", tt.in, err, verr)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+}"}, {"sha": "e13a956afeed0c12a6029520d663eab50f549cf5", "filename": "libgo/go/mime/multipart/writer.go", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fwriter.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -30,11 +30,38 @@ func NewWriter(w io.Writer) *Writer {\n \t}\n }\n \n-// Boundary returns the Writer's randomly selected boundary string.\n+// Boundary returns the Writer's boundary.\n func (w *Writer) Boundary() string {\n \treturn w.boundary\n }\n \n+// SetBoundary overrides the Writer's default randomly-generated\n+// boundary separator with an explicit value.\n+//\n+// SetBoundary must be called before any parts are created, may only\n+// contain certain ASCII characters, and must be 1-69 bytes long.\n+func (w *Writer) SetBoundary(boundary string) error {\n+\tif w.lastpart != nil {\n+\t\treturn errors.New(\"mime: SetBoundary called after write\")\n+\t}\n+\t// rfc2046#section-5.1.1\n+\tif len(boundary) < 1 || len(boundary) > 69 {\n+\t\treturn errors.New(\"mime: invalid boundary length\")\n+\t}\n+\tfor _, b := range boundary {\n+\t\tif 'A' <= b && b <= 'Z' || 'a' <= b && b <= 'z' || '0' <= b && b <= '9' {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch b {\n+\t\tcase '\\'', '(', ')', '+', '_', ',', '-', '.', '/', ':', '=', '?':\n+\t\t\tcontinue\n+\t\t}\n+\t\treturn errors.New(\"mime: invalid boundary character\")\n+\t}\n+\tw.boundary = boundary\n+\treturn nil\n+}\n+\n // FormDataContentType returns the Content-Type for an HTTP\n // multipart/form-data with this Writer's Boundary.\n func (w *Writer) FormDataContentType() string {"}, {"sha": "52d68bcb68c580415affd3d59c1906d80330985a", "filename": "libgo/go/mime/multipart/writer_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fmime%2Fmultipart%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fwriter_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -7,6 +7,7 @@ package multipart\n import (\n \t\"bytes\"\n \t\"io/ioutil\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -76,3 +77,37 @@ func TestWriter(t *testing.T) {\n \t\tt.Fatalf(\"expected end of parts; got %v, %v\", part, err)\n \t}\n }\n+\n+func TestWriterSetBoundary(t *testing.T) {\n+\tvar b bytes.Buffer\n+\tw := NewWriter(&b)\n+\ttests := []struct {\n+\t\tb  string\n+\t\tok bool\n+\t}{\n+\t\t{\"abc\", true},\n+\t\t{\"\", false},\n+\t\t{\"ung\u00fcltig\", false},\n+\t\t{\"!\", false},\n+\t\t{strings.Repeat(\"x\", 69), true},\n+\t\t{strings.Repeat(\"x\", 70), false},\n+\t\t{\"bad!ascii!\", false},\n+\t\t{\"my-separator\", true},\n+\t}\n+\tfor i, tt := range tests {\n+\t\terr := w.SetBoundary(tt.b)\n+\t\tgot := err == nil\n+\t\tif got != tt.ok {\n+\t\t\tt.Errorf(\"%d. boundary %q = %v (%v); want %v\", i, tt.b, got, err, tt.ok)\n+\t\t} else if tt.ok {\n+\t\t\tgot := w.Boundary()\n+\t\t\tif got != tt.b {\n+\t\t\t\tt.Errorf(\"boundary = %q; want %q\", got, tt.b)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tw.Close()\n+\tif got := b.String(); !strings.Contains(got, \"\\r\\n--my-separator--\\r\\n\") {\n+\t\tt.Errorf(\"expected my-separator in output. got: %q\", got)\n+\t}\n+}"}, {"sha": "0c4608462e0e216837131c9e3918c272fdebfeb3", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -15,6 +15,7 @@ func parseDialNetwork(net string) (afnet string, proto int, err error) {\n \t\tswitch net {\n \t\tcase \"tcp\", \"tcp4\", \"tcp6\":\n \t\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\tcase \"ip\", \"ip4\", \"ip6\":\n \t\tcase \"unix\", \"unixgram\", \"unixpacket\":\n \t\tdefault:\n \t\t\treturn \"\", 0, UnknownNetworkError(net)\n@@ -54,12 +55,8 @@ func resolveAfnetAddr(afnet, addr string, deadline time.Time) (Addr, error) {\n \t\treturn nil, nil\n \t}\n \tswitch afnet {\n-\tcase \"tcp\", \"tcp4\", \"tcp6\":\n-\t\treturn resolveTCPAddr(afnet, addr, deadline)\n-\tcase \"udp\", \"udp4\", \"udp6\":\n-\t\treturn resolveUDPAddr(afnet, addr, deadline)\n-\tcase \"ip\", \"ip4\", \"ip6\":\n-\t\treturn resolveIPAddr(afnet, addr, deadline)\n+\tcase \"tcp\", \"tcp4\", \"tcp6\", \"udp\", \"udp4\", \"udp6\", \"ip\", \"ip4\", \"ip6\":\n+\t\treturn resolveInternetAddr(afnet, addr, deadline)\n \tcase \"unix\", \"unixgram\", \"unixpacket\":\n \t\treturn ResolveUnixAddr(afnet, addr)\n \t}\n@@ -218,8 +215,8 @@ func Listen(net, laddr string) (Listener, error) {\n // ListenPacket announces on the local network address laddr.\n // The network string net must be a packet-oriented network:\n // \"udp\", \"udp4\", \"udp6\", \"ip\", \"ip4\", \"ip6\" or \"unixgram\".\n-func ListenPacket(net, addr string) (PacketConn, error) {\n-\tafnet, a, err := resolveNetAddr(\"listen\", net, addr, noDeadline)\n+func ListenPacket(net, laddr string) (PacketConn, error) {\n+\tafnet, a, err := resolveNetAddr(\"listen\", net, laddr, noDeadline)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "8be0335d61ce228bc9384c3fceeab60cc2883a04", "filename": "libgo/go/net/fd_posix_test.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffd_posix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffd_posix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_posix_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux netbsd openbsd windows\n+\n+package net\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+var deadlineSetTimeTests = []struct {\n+\tinput    time.Time\n+\texpected int64\n+}{\n+\t{time.Time{}, 0},\n+\t{time.Date(2009, 11, 10, 23, 00, 00, 00, time.UTC), 1257894000000000000}, // 2009-11-10 23:00:00 +0000 UTC\n+}\n+\n+func TestDeadlineSetTime(t *testing.T) {\n+\tfor _, tt := range deadlineSetTimeTests {\n+\t\tvar d deadline\n+\t\td.setTime(tt.input)\n+\t\tactual := d.value()\n+\t\texpected := int64(0)\n+\t\tif !tt.input.IsZero() {\n+\t\t\texpected = tt.input.UnixNano()\n+\t\t}\n+\t\tif actual != expected {\n+\t\t\tt.Errorf(\"set/value failed: expected %v, actual %v\", expected, actual)\n+\t\t}\n+\t}\n+}\n+\n+var deadlineExpiredTests = []struct {\n+\tdeadline time.Time\n+\texpired  bool\n+}{\n+\t// note, times are relative to the start of the test run, not\n+\t// the start of TestDeadlineExpired\n+\t{time.Now().Add(5 * time.Minute), false},\n+\t{time.Now().Add(-5 * time.Minute), true},\n+\t{time.Time{}, false}, // no deadline set\n+}\n+\n+func TestDeadlineExpired(t *testing.T) {\n+\tfor _, tt := range deadlineExpiredTests {\n+\t\tvar d deadline\n+\t\td.set(tt.deadline.UnixNano())\n+\t\texpired := d.expired()\n+\t\tif expired != tt.expired {\n+\t\t\tt.Errorf(\"expire failed: expected %v, actual %v\", tt.expired, expired)\n+\t\t}\n+\t}\n+}"}, {"sha": "6d8af0ab2e26b6b7abb58462d4733e24b73bb74a", "filename": "libgo/go/net/fd_unix.go", "status": "modified", "additions": 70, "deletions": 75, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -37,11 +37,11 @@ type netFD struct {\n \tladdr       Addr\n \traddr       Addr\n \n-\t// owned by client\n-\trdeadline int64\n-\trio       sync.Mutex\n-\twdeadline int64\n-\twio       sync.Mutex\n+\t// serialize access to Read and Write methods\n+\trio, wio sync.Mutex\n+\n+\t// read and write deadlines\n+\trdeadline, wdeadline deadline\n \n \t// owned by fd wait server\n \tncr, ncw int\n@@ -82,11 +82,11 @@ func (s *pollServer) AddFD(fd *netFD, mode int) error {\n \tkey := intfd << 1\n \tif mode == 'r' {\n \t\tfd.ncr++\n-\t\tt = fd.rdeadline\n+\t\tt = fd.rdeadline.value()\n \t} else {\n \t\tfd.ncw++\n \t\tkey++\n-\t\tt = fd.wdeadline\n+\t\tt = fd.wdeadline.value()\n \t}\n \ts.pending[key] = fd\n \tdoWakeup := false\n@@ -153,12 +153,8 @@ func (s *pollServer) WakeFD(fd *netFD, mode int, err error) {\n \t}\n }\n \n-func (s *pollServer) Now() int64 {\n-\treturn time.Now().UnixNano()\n-}\n-\n func (s *pollServer) CheckDeadlines() {\n-\tnow := s.Now()\n+\tnow := time.Now().UnixNano()\n \t// TODO(rsc): This will need to be handled more efficiently,\n \t// probably with a heap indexed by wakeup time.\n \n@@ -172,21 +168,19 @@ func (s *pollServer) CheckDeadlines() {\n \t\t\tmode = 'w'\n \t\t}\n \t\tif mode == 'r' {\n-\t\t\tt = fd.rdeadline\n+\t\t\tt = fd.rdeadline.value()\n \t\t} else {\n-\t\t\tt = fd.wdeadline\n+\t\t\tt = fd.wdeadline.value()\n \t\t}\n \t\tif t > 0 {\n \t\t\tif t <= now {\n \t\t\t\tdelete(s.pending, key)\n \t\t\t\tif mode == 'r' {\n \t\t\t\t\ts.poll.DelFD(fd.sysfd, mode)\n-\t\t\t\t\tfd.rdeadline = -1\n \t\t\t\t} else {\n \t\t\t\t\ts.poll.DelFD(fd.sysfd, mode)\n-\t\t\t\t\tfd.wdeadline = -1\n \t\t\t\t}\n-\t\t\t\ts.WakeFD(fd, mode, nil)\n+\t\t\t\ts.WakeFD(fd, mode, errTimeout)\n \t\t\t} else if nextDeadline == 0 || t < nextDeadline {\n \t\t\t\tnextDeadline = t\n \t\t\t}\n@@ -200,15 +194,15 @@ func (s *pollServer) Run() {\n \ts.Lock()\n \tdefer s.Unlock()\n \tfor {\n-\t\tvar t = s.deadline\n-\t\tif t > 0 {\n-\t\t\tt = t - s.Now()\n-\t\t\tif t <= 0 {\n+\t\tvar timeout int64 // nsec to wait for or 0 for none\n+\t\tif s.deadline > 0 {\n+\t\t\ttimeout = s.deadline - time.Now().UnixNano()\n+\t\t\tif timeout <= 0 {\n \t\t\t\ts.CheckDeadlines()\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n-\t\tfd, mode, err := s.poll.WaitFD(s, t)\n+\t\tfd, mode, err := s.poll.WaitFD(s, timeout)\n \t\tif err != nil {\n \t\t\tprint(\"pollServer WaitFD: \", err.Error(), \"\\n\")\n \t\t\treturn\n@@ -329,14 +323,10 @@ func (fd *netFD) name() string {\n \n func (fd *netFD) connect(ra syscall.Sockaddr) error {\n \terr := syscall.Connect(fd.sysfd, ra)\n-\thadTimeout := fd.wdeadline > 0\n \tif err == syscall.EINPROGRESS {\n \t\tif err = fd.pollServer.WaitWrite(fd); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif hadTimeout && fd.wdeadline < 0 {\n-\t\t\treturn errTimeout\n-\t\t}\n \t\tvar e int\n \t\te, err = syscall.GetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_ERROR)\n \t\tif err != nil {\n@@ -381,8 +371,8 @@ func (fd *netFD) decref() {\n \n func (fd *netFD) Close() error {\n \tfd.pollServer.Lock() // needed for both fd.incref(true) and pollserver.Evict\n-\tdefer fd.pollServer.Unlock()\n \tif err := fd.incref(true); err != nil {\n+\t\tfd.pollServer.Unlock()\n \t\treturn err\n \t}\n \t// Unblock any I/O.  Once it all unblocks and returns,\n@@ -391,6 +381,7 @@ func (fd *netFD) Close() error {\n \t// fairly quickly, since all the I/O is non-blocking, and any\n \t// attempts to block in the pollserver will return errClosing.\n \tfd.pollServer.Evict(fd)\n+\tfd.pollServer.Unlock()\n \tfd.decref()\n \treturn nil\n }\n@@ -423,20 +414,20 @@ func (fd *netFD) Read(p []byte) (n int, err error) {\n \t}\n \tdefer fd.decref()\n \tfor {\n-\t\tn, err = syscall.Read(int(fd.sysfd), p)\n-\t\tif err == syscall.EAGAIN {\n+\t\tif fd.rdeadline.expired() {\n \t\t\terr = errTimeout\n-\t\t\tif fd.rdeadline >= 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tn, err = syscall.Read(int(fd.sysfd), p)\n+\t\tif err != nil {\n+\t\t\tn = 0\n+\t\t\tif err == syscall.EAGAIN {\n \t\t\t\tif err = fd.pollServer.WaitRead(fd); err == nil {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif err != nil {\n-\t\t\tn = 0\n-\t\t} else if n == 0 && err == nil && fd.sotype != syscall.SOCK_DGRAM {\n-\t\t\terr = io.EOF\n-\t\t}\n+\t\terr = chkReadErr(n, err, fd)\n \t\tbreak\n \t}\n \tif err != nil && err != io.EOF {\n@@ -453,18 +444,20 @@ func (fd *netFD) ReadFrom(p []byte) (n int, sa syscall.Sockaddr, err error) {\n \t}\n \tdefer fd.decref()\n \tfor {\n-\t\tn, sa, err = syscall.Recvfrom(fd.sysfd, p, 0)\n-\t\tif err == syscall.EAGAIN {\n+\t\tif fd.rdeadline.expired() {\n \t\t\terr = errTimeout\n-\t\t\tif fd.rdeadline >= 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tn, sa, err = syscall.Recvfrom(fd.sysfd, p, 0)\n+\t\tif err != nil {\n+\t\t\tn = 0\n+\t\t\tif err == syscall.EAGAIN {\n \t\t\t\tif err = fd.pollServer.WaitRead(fd); err == nil {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif err != nil {\n-\t\t\tn = 0\n-\t\t}\n+\t\terr = chkReadErr(n, err, fd)\n \t\tbreak\n \t}\n \tif err != nil && err != io.EOF {\n@@ -481,41 +474,47 @@ func (fd *netFD) ReadMsg(p []byte, oob []byte) (n, oobn, flags int, sa syscall.S\n \t}\n \tdefer fd.decref()\n \tfor {\n-\t\tn, oobn, flags, sa, err = syscall.Recvmsg(fd.sysfd, p, oob, 0)\n-\t\tif err == syscall.EAGAIN {\n+\t\tif fd.rdeadline.expired() {\n \t\t\terr = errTimeout\n-\t\t\tif fd.rdeadline >= 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tn, oobn, flags, sa, err = syscall.Recvmsg(fd.sysfd, p, oob, 0)\n+\t\tif err != nil {\n+\t\t\t// TODO(dfc) should n and oobn be set to 0\n+\t\t\tif err == syscall.EAGAIN {\n \t\t\t\tif err = fd.pollServer.WaitRead(fd); err == nil {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif err == nil && n == 0 {\n-\t\t\terr = io.EOF\n-\t\t}\n+\t\terr = chkReadErr(n, err, fd)\n \t\tbreak\n \t}\n \tif err != nil && err != io.EOF {\n \t\terr = &OpError{\"read\", fd.net, fd.laddr, err}\n-\t\treturn\n \t}\n \treturn\n }\n \n-func (fd *netFD) Write(p []byte) (int, error) {\n+func chkReadErr(n int, err error, fd *netFD) error {\n+\tif n == 0 && err == nil && fd.sotype != syscall.SOCK_DGRAM && fd.sotype != syscall.SOCK_RAW {\n+\t\treturn io.EOF\n+\t}\n+\treturn err\n+}\n+\n+func (fd *netFD) Write(p []byte) (nn int, err error) {\n \tfd.wio.Lock()\n \tdefer fd.wio.Unlock()\n \tif err := fd.incref(false); err != nil {\n \t\treturn 0, err\n \t}\n \tdefer fd.decref()\n-\tif fd.sysfile == nil {\n-\t\treturn 0, syscall.EINVAL\n-\t}\n-\n-\tvar err error\n-\tnn := 0\n \tfor {\n+\t\tif fd.wdeadline.expired() {\n+\t\t\terr = errTimeout\n+\t\t\tbreak\n+\t\t}\n \t\tvar n int\n \t\tn, err = syscall.Write(int(fd.sysfd), p[nn:])\n \t\tif n > 0 {\n@@ -525,11 +524,8 @@ func (fd *netFD) Write(p []byte) (int, error) {\n \t\t\tbreak\n \t\t}\n \t\tif err == syscall.EAGAIN {\n-\t\t\terr = errTimeout\n-\t\t\tif fd.wdeadline >= 0 {\n-\t\t\t\tif err = fd.pollServer.WaitWrite(fd); err == nil {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\tif err = fd.pollServer.WaitWrite(fd); err == nil {\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \t\tif err != nil {\n@@ -555,13 +551,14 @@ func (fd *netFD) WriteTo(p []byte, sa syscall.Sockaddr) (n int, err error) {\n \t}\n \tdefer fd.decref()\n \tfor {\n+\t\tif fd.wdeadline.expired() {\n+\t\t\terr = errTimeout\n+\t\t\tbreak\n+\t\t}\n \t\terr = syscall.Sendto(fd.sysfd, p, 0, sa)\n \t\tif err == syscall.EAGAIN {\n-\t\t\terr = errTimeout\n-\t\t\tif fd.wdeadline >= 0 {\n-\t\t\t\tif err = fd.pollServer.WaitWrite(fd); err == nil {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\tif err = fd.pollServer.WaitWrite(fd); err == nil {\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \t\tbreak\n@@ -582,13 +579,14 @@ func (fd *netFD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oob\n \t}\n \tdefer fd.decref()\n \tfor {\n+\t\tif fd.wdeadline.expired() {\n+\t\t\terr = errTimeout\n+\t\t\tbreak\n+\t\t}\n \t\terr = syscall.Sendmsg(fd.sysfd, p, oob, sa, 0)\n \t\tif err == syscall.EAGAIN {\n-\t\t\terr = errTimeout\n-\t\t\tif fd.wdeadline >= 0 {\n-\t\t\t\tif err = fd.pollServer.WaitWrite(fd); err == nil {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\tif err = fd.pollServer.WaitWrite(fd); err == nil {\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \t\tbreak\n@@ -619,11 +617,8 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (netfd *netFD, err e\n \t\tif err != nil {\n \t\t\tsyscall.ForkLock.RUnlock()\n \t\t\tif err == syscall.EAGAIN {\n-\t\t\t\terr = errTimeout\n-\t\t\t\tif fd.rdeadline >= 0 {\n-\t\t\t\t\tif err = fd.pollServer.WaitRead(fd); err == nil {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n+\t\t\t\tif err = fd.pollServer.WaitRead(fd); err == nil {\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t} else if err == syscall.ECONNABORTED {\n \t\t\t\t// This means that a socket on the listen queue was closed"}, {"sha": "fd1385ef9342d65e3bbb1a71f04b10614cb636f2", "filename": "libgo/go/net/fd_unix_test.go", "status": "modified", "additions": 56, "deletions": 10, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffd_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffd_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -7,41 +7,42 @@\n package net\n \n import (\n+\t\"io\"\n+\t\"syscall\"\n \t\"testing\"\n )\n \n // Issue 3590. netFd.AddFD should return an error\n // from the underlying pollster rather than panicing.\n func TestAddFDReturnsError(t *testing.T) {\n-\tl, err := Listen(\"tcp\", \"127.0.0.1:0\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer l.Close()\n-\n+\tln := newLocalListener(t).(*TCPListener)\n+\tdefer ln.Close()\n+\tconnected := make(chan bool)\n \tgo func() {\n \t\tfor {\n-\t\t\tc, err := l.Accept()\n+\t\t\tc, err := ln.Accept()\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}\n+\t\t\tconnected <- true\n \t\t\tdefer c.Close()\n \t\t}\n \t}()\n \n-\tc, err := Dial(\"tcp\", l.Addr().String())\n+\tc, err := DialTCP(\"tcp\", nil, ln.Addr().(*TCPAddr))\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n \tdefer c.Close()\n+\t<-connected\n \n \t// replace c's pollServer with a closed version.\n \tps, err := newPollServer()\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n \tps.poll.Close()\n-\tc.(*TCPConn).conn.fd.pollServer = ps\n+\tc.conn.fd.pollServer = ps\n \n \tvar b [1]byte\n \t_, err = c.Read(b[:])\n@@ -56,5 +57,50 @@ func TestAddFDReturnsError(t *testing.T) {\n \t\t\t}\n \t\t}\n \t}\n-\tt.Error(err)\n+\tt.Error(\"unexpected error:\", err)\n+}\n+\n+var chkReadErrTests = []struct {\n+\tn        int\n+\terr      error\n+\tfd       *netFD\n+\texpected error\n+}{\n+\n+\t{100, nil, &netFD{sotype: syscall.SOCK_STREAM}, nil},\n+\t{100, io.EOF, &netFD{sotype: syscall.SOCK_STREAM}, io.EOF},\n+\t{100, errClosing, &netFD{sotype: syscall.SOCK_STREAM}, errClosing},\n+\t{0, nil, &netFD{sotype: syscall.SOCK_STREAM}, io.EOF},\n+\t{0, io.EOF, &netFD{sotype: syscall.SOCK_STREAM}, io.EOF},\n+\t{0, errClosing, &netFD{sotype: syscall.SOCK_STREAM}, errClosing},\n+\n+\t{100, nil, &netFD{sotype: syscall.SOCK_DGRAM}, nil},\n+\t{100, io.EOF, &netFD{sotype: syscall.SOCK_DGRAM}, io.EOF},\n+\t{100, errClosing, &netFD{sotype: syscall.SOCK_DGRAM}, errClosing},\n+\t{0, nil, &netFD{sotype: syscall.SOCK_DGRAM}, nil},\n+\t{0, io.EOF, &netFD{sotype: syscall.SOCK_DGRAM}, io.EOF},\n+\t{0, errClosing, &netFD{sotype: syscall.SOCK_DGRAM}, errClosing},\n+\n+\t{100, nil, &netFD{sotype: syscall.SOCK_SEQPACKET}, nil},\n+\t{100, io.EOF, &netFD{sotype: syscall.SOCK_SEQPACKET}, io.EOF},\n+\t{100, errClosing, &netFD{sotype: syscall.SOCK_SEQPACKET}, errClosing},\n+\t{0, nil, &netFD{sotype: syscall.SOCK_SEQPACKET}, io.EOF},\n+\t{0, io.EOF, &netFD{sotype: syscall.SOCK_SEQPACKET}, io.EOF},\n+\t{0, errClosing, &netFD{sotype: syscall.SOCK_SEQPACKET}, errClosing},\n+\n+\t{100, nil, &netFD{sotype: syscall.SOCK_RAW}, nil},\n+\t{100, io.EOF, &netFD{sotype: syscall.SOCK_RAW}, io.EOF},\n+\t{100, errClosing, &netFD{sotype: syscall.SOCK_RAW}, errClosing},\n+\t{0, nil, &netFD{sotype: syscall.SOCK_RAW}, nil},\n+\t{0, io.EOF, &netFD{sotype: syscall.SOCK_RAW}, io.EOF},\n+\t{0, errClosing, &netFD{sotype: syscall.SOCK_RAW}, errClosing},\n+}\n+\n+func TestChkReadErr(t *testing.T) {\n+\tfor _, tt := range chkReadErrTests {\n+\t\tactual := chkReadErr(tt.n, tt.err, tt.fd)\n+\t\tif actual != tt.expected {\n+\t\t\tt.Errorf(\"chkReadError(%v, %v, %v): expected %v, actual %v\", tt.n, tt.err, tt.fd.sotype, tt.expected, actual)\n+\t\t}\n+\t}\n }"}, {"sha": "18712191fee18b5c03bde470ae374c39283b53d1", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -169,6 +169,15 @@ func (s *ioSrv) ProcessRemoteIO() {\n func (s *ioSrv) ExecIO(oi anOpIface, deadline int64) (int, error) {\n \tvar err error\n \to := oi.Op()\n+\t// Calculate timeout delta.\n+\tvar delta int64\n+\tif deadline != 0 {\n+\t\tdelta = deadline - time.Now().UnixNano()\n+\t\tif delta <= 0 {\n+\t\t\treturn 0, &OpError{oi.Name(), o.fd.net, o.fd.laddr, errTimeout}\n+\t\t}\n+\t}\n+\t// Start IO.\n \tif canCancelIO {\n \t\terr = oi.Submit()\n \t} else {\n@@ -188,12 +197,8 @@ func (s *ioSrv) ExecIO(oi anOpIface, deadline int64) (int, error) {\n \t}\n \t// Setup timer, if deadline is given.\n \tvar timer <-chan time.Time\n-\tif deadline != 0 {\n-\t\tdt := deadline - time.Now().UnixNano()\n-\t\tif dt < 1 {\n-\t\t\tdt = 1\n-\t\t}\n-\t\tt := time.NewTimer(time.Duration(dt) * time.Nanosecond)\n+\tif delta > 0 {\n+\t\tt := time.NewTimer(time.Duration(delta) * time.Nanosecond)\n \t\tdefer t.Stop()\n \t\ttimer = t.C\n \t}\n@@ -280,11 +285,11 @@ type netFD struct {\n \terrnoc      [2]chan error    // read/write submit or cancel operation errors\n \tclosec      chan bool        // used by Close to cancel pending IO\n \n-\t// owned by client\n-\trdeadline int64\n-\trio       sync.Mutex\n-\twdeadline int64\n-\twio       sync.Mutex\n+\t// serialize access to Read and Write methods\n+\trio, wio sync.Mutex\n+\n+\t// read and write deadlines\n+\trdeadline, wdeadline deadline\n }\n \n func allocFD(fd syscall.Handle, family, sotype int, net string) *netFD {\n@@ -295,7 +300,6 @@ func allocFD(fd syscall.Handle, family, sotype int, net string) *netFD {\n \t\tnet:    net,\n \t\tclosec: make(chan bool),\n \t}\n-\truntime.SetFinalizer(netfd, (*netFD).Close)\n \treturn netfd\n }\n \n@@ -314,6 +318,7 @@ func newFD(fd syscall.Handle, family, proto int, net string) (*netFD, error) {\n func (fd *netFD) setAddr(laddr, raddr Addr) {\n \tfd.laddr = laddr\n \tfd.raddr = raddr\n+\truntime.SetFinalizer(fd, (*netFD).closesocket)\n }\n \n func (fd *netFD) connect(ra syscall.Sockaddr) error {\n@@ -393,6 +398,10 @@ func (fd *netFD) CloseWrite() error {\n \treturn fd.shutdown(syscall.SHUT_WR)\n }\n \n+func (fd *netFD) closesocket() error {\n+\treturn closesocket(fd.sysfd)\n+}\n+\n // Read from network.\n \n type readOp struct {\n@@ -417,7 +426,7 @@ func (fd *netFD) Read(buf []byte) (int, error) {\n \tdefer fd.rio.Unlock()\n \tvar o readOp\n \to.Init(fd, buf, 'r')\n-\tn, err := iosrv.ExecIO(&o, fd.rdeadline)\n+\tn, err := iosrv.ExecIO(&o, fd.rdeadline.value())\n \tif err == nil && n == 0 {\n \t\terr = io.EOF\n \t}\n@@ -454,7 +463,7 @@ func (fd *netFD) ReadFrom(buf []byte) (n int, sa syscall.Sockaddr, err error) {\n \tvar o readFromOp\n \to.Init(fd, buf, 'r')\n \to.rsan = int32(unsafe.Sizeof(o.rsa))\n-\tn, err = iosrv.ExecIO(&o, fd.rdeadline)\n+\tn, err = iosrv.ExecIO(&o, fd.rdeadline.value())\n \tif err != nil {\n \t\treturn 0, nil, err\n \t}\n@@ -486,7 +495,7 @@ func (fd *netFD) Write(buf []byte) (int, error) {\n \tdefer fd.wio.Unlock()\n \tvar o writeOp\n \to.Init(fd, buf, 'w')\n-\treturn iosrv.ExecIO(&o, fd.wdeadline)\n+\treturn iosrv.ExecIO(&o, fd.wdeadline.value())\n }\n \n // WriteTo to network.\n@@ -518,7 +527,7 @@ func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (int, error) {\n \tvar o writeToOp\n \to.Init(fd, buf, 'w')\n \to.sa = sa\n-\treturn iosrv.ExecIO(&o, fd.wdeadline)\n+\treturn iosrv.ExecIO(&o, fd.wdeadline.value())\n }\n \n // Accept new network connections.\n@@ -552,22 +561,23 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n \ts, err := syscall.Socket(fd.family, fd.sotype, 0)\n \tif err != nil {\n \t\tsyscall.ForkLock.RUnlock()\n-\t\treturn nil, err\n+\t\treturn nil, &OpError{\"socket\", fd.net, fd.laddr, err}\n \t}\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n \t// Associate our new socket with IOCP.\n \tonceStartServer.Do(startServer)\n \tif _, err := syscall.CreateIoCompletionPort(s, resultsrv.iocp, 0, 0); err != nil {\n+\t\tclosesocket(s)\n \t\treturn nil, &OpError{\"CreateIoCompletionPort\", fd.net, fd.laddr, err}\n \t}\n \n \t// Submit accept request.\n \tvar o acceptOp\n \to.Init(fd, 'r')\n \to.newsock = s\n-\t_, err = iosrv.ExecIO(&o, fd.rdeadline)\n+\t_, err = iosrv.ExecIO(&o, fd.rdeadline.value())\n \tif err != nil {\n \t\tclosesocket(s)\n \t\treturn nil, err\n@@ -577,7 +587,7 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n \terr = syscall.Setsockopt(s, syscall.SOL_SOCKET, syscall.SO_UPDATE_ACCEPT_CONTEXT, (*byte)(unsafe.Pointer(&fd.sysfd)), int32(unsafe.Sizeof(fd.sysfd)))\n \tif err != nil {\n \t\tclosesocket(s)\n-\t\treturn nil, err\n+\t\treturn nil, &OpError{\"Setsockopt\", fd.net, fd.laddr, err}\n \t}\n \n \t// Get local and peer addr out of AcceptEx buffer."}, {"sha": "ae3ac156b9878d02dc23ada735475e07f4a7d67c", "filename": "libgo/go/net/file_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -19,8 +19,8 @@ func FileConn(f *os.File) (c Conn, err error) {\n \n // FileListener returns a copy of the network listener corresponding\n // to the open file f.  It is the caller's responsibility to close l\n-// when finished.  Closing c does not affect l, and closing l does not\n-// affect c.\n+// when finished.  Closing l does not affect f, and closing f does not\n+// affect l.\n func FileListener(f *os.File) (l Listener, err error) {\n \treturn nil, syscall.EPLAN9\n }"}, {"sha": "85b52c9fdbc09a3ba30fce6aeed635199e190889", "filename": "libgo/go/net/http/cgi/host_test.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -405,7 +405,8 @@ func TestDirUnix(t *testing.T) {\n }\n \n func TestDirWindows(t *testing.T) {\n-\tif skipTest(t) || runtime.GOOS != \"windows\" {\n+\tif runtime.GOOS != \"windows\" {\n+\t\tt.Logf(\"Skipping windows specific test.\")\n \t\treturn\n \t}\n \n@@ -415,6 +416,7 @@ func TestDirWindows(t *testing.T) {\n \tvar err error\n \tperl, err = exec.LookPath(\"perl\")\n \tif err != nil {\n+\t\tt.Logf(\"Skipping test: perl not found.\")\n \t\treturn\n \t}\n \tperl, _ = filepath.Abs(perl)\n@@ -457,6 +459,7 @@ func TestEnvOverride(t *testing.T) {\n \tvar err error\n \tperl, err = exec.LookPath(\"perl\")\n \tif err != nil {\n+\t\tt.Logf(\"Skipping test: perl not found.\")\n \t\treturn\n \t}\n \tperl, _ = filepath.Abs(perl)"}, {"sha": "1b25bc29996993cd3f3127ec11173f62c0903db6", "filename": "libgo/go/net/http/cgi/testdata/test.cgi", "status": "modified", "additions": 21, "deletions": 56, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Ftestdata%2Ftest.cgi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Ftestdata%2Ftest.cgi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Ftestdata%2Ftest.cgi?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -10,23 +10,6 @@ use Cwd;\n \n binmode STDOUT;\n \n-sub on_windows {\n-    return $^O eq 'MSWin32' || $^O eq 'msys';\n-}\n-\n-# normalize_windows_path normalizes the various Windows Perl path\n-# formats into Go's format.\n-sub normalize_windows_path {\n-    my $dir = shift;\n-    return $dir unless on_windows();\n-    $dir =~ s!^[a-z]:!uc($&)!e;\n-    if ($dir =~ s!^/([a-zA-Z])/!!) {\n-        $dir = uc($1) . \":\\\\$dir\";\n-    }\n-    $dir =~ s!/!\\\\!g;\n-    return $dir;\n-}\n-\n my $q = MiniCGI->new;\n my $params = $q->Vars;\n \n@@ -35,40 +18,43 @@ if ($params->{\"loc\"}) {\n     exit(0);\n }\n \n-my $NL = \"\\r\\n\";\n-$NL = \"\\n\" if $params->{mode} eq \"NL\";\n-\n-my $p = sub {\n-    print \"$_[0]$NL\";\n-};\n-\n-# With carriage returns\n-$p->(\"Content-Type: text/html\");\n-$p->(\"X-CGI-Pid: $$\");\n-$p->(\"X-Test-Header: X-Test-Value\");\n-$p->(\"\");\n+print \"Content-Type: text/html\\r\\n\";\n+print \"X-CGI-Pid: $$\\r\\n\";\n+print \"X-Test-Header: X-Test-Value\\r\\n\";\n+print \"\\r\\n\";\n \n if ($params->{\"bigresponse\"}) {\n     for (1..1024) {\n-        print \"A\" x 1024, \"\\n\";\n+        print \"A\" x 1024, \"\\r\\n\";\n     }\n     exit 0;\n }\n \n-print \"test=Hello CGI\\n\";\n+print \"test=Hello CGI\\r\\n\";\n \n foreach my $k (sort keys %$params) {\n-    print \"param-$k=$params->{$k}\\n\";\n+    print \"param-$k=$params->{$k}\\r\\n\";\n }\n \n foreach my $k (sort keys %ENV) {\n     my $clean_env = $ENV{$k};\n     $clean_env =~ s/[\\n\\r]//g;\n-    print \"env-$k=$clean_env\\n\";\n+    print \"env-$k=$clean_env\\r\\n\";\n }\n \n-my $dir = normalize_windows_path(getcwd());\n-print \"cwd=$dir\\n\";\n+# NOTE: msys perl returns /c/go/src/... not C:\\go\\....\n+my $dir = getcwd();\n+if ($^O eq 'MSWin32' || $^O eq 'msys') {\n+    if ($dir =~ /^.:/) {\n+        $dir =~ s!/!\\\\!g;\n+    } else {\n+        my $cmd = $ENV{'COMSPEC'} || 'c:\\\\windows\\\\system32\\\\cmd.exe';\n+        $cmd =~ s!\\\\!/!g;\n+        $dir = `$cmd /c cd`;\n+        chomp $dir;\n+    }\n+}\n+print \"cwd=$dir\\r\\n\";\n \n # A minimal version of CGI.pm, for people without the perl-modules\n # package installed.  (CGI.pm used to be part of the Perl core, but\n@@ -102,24 +88,3 @@ sub _urldecode {\n     $v =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack(\"C\", hex($1))/eg;\n     return $v;\n }\n-\n-package Tests;\n-\n-sub test_normalize_windows_paths {\n-    my @tests = (\n-        {in => \"C:\\\\foo\\\\bar\", want => \"C:\\\\foo\\\\bar\"},\n-        {in => \"C:/foo/bar\", want => \"C:\\\\foo\\\\bar\"},\n-        {in => \"c:/foo/bar\", want => \"C:\\\\foo\\\\bar\"},\n-        {in => \"/c/foo/bar\", want => \"C:\\\\foo\\\\bar\"},\n-    );\n-    foreach my $tt (@tests) {\n-        my $got = ::normalize_windows_path($tt->{in});\n-        unless ($got eq $tt->{want}) {\n-            die \"For path $tt->{in}, normalize = $got; want $tt->{want}\\n\";\n-        }\n-    }\n-}\n-\n-BEGIN {\n-    test_normalize_windows_paths() if ::on_windows();\n-}"}, {"sha": "91db017245656824884e4c4eb294913026d80094", "filename": "libgo/go/net/http/chunked.go", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -11,11 +11,9 @@ package http\n \n import (\n \t\"bufio\"\n-\t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"strconv\"\n )\n \n const maxLineLength = 4096 // assumed <= bufio.defaultBufSize\n@@ -45,12 +43,12 @@ type chunkedReader struct {\n \n func (cr *chunkedReader) beginChunk() {\n \t// chunk-size CRLF\n-\tvar line string\n+\tvar line []byte\n \tline, cr.err = readLine(cr.r)\n \tif cr.err != nil {\n \t\treturn\n \t}\n-\tcr.n, cr.err = strconv.ParseUint(line, 16, 64)\n+\tcr.n, cr.err = parseHexUint(line)\n \tif cr.err != nil {\n \t\treturn\n \t}\n@@ -89,7 +87,7 @@ func (cr *chunkedReader) Read(b []uint8) (n int, err error) {\n // Give up if the line exceeds maxLineLength.\n // The returned bytes are a pointer into storage in\n // the bufio, so they are only valid until the next bufio read.\n-func readLineBytes(b *bufio.Reader) (p []byte, err error) {\n+func readLine(b *bufio.Reader) (p []byte, err error) {\n \tif p, err = b.ReadSlice('\\n'); err != nil {\n \t\t// We always know when EOF is coming.\n \t\t// If the caller asked for a line, there should be a line.\n@@ -103,20 +101,18 @@ func readLineBytes(b *bufio.Reader) (p []byte, err error) {\n \tif len(p) >= maxLineLength {\n \t\treturn nil, ErrLineTooLong\n \t}\n-\n-\t// Chop off trailing white space.\n-\tp = bytes.TrimRight(p, \" \\r\\t\\n\")\n-\n-\treturn p, nil\n+\treturn trimTrailingWhitespace(p), nil\n }\n \n-// readLineBytes, but convert the bytes into a string.\n-func readLine(b *bufio.Reader) (s string, err error) {\n-\tp, e := readLineBytes(b)\n-\tif e != nil {\n-\t\treturn \"\", e\n+func trimTrailingWhitespace(b []byte) []byte {\n+\tfor len(b) > 0 && isASCIISpace(b[len(b)-1]) {\n+\t\tb = b[:len(b)-1]\n \t}\n-\treturn string(p), nil\n+\treturn b\n+}\n+\n+func isASCIISpace(b byte) bool {\n+\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n }\n \n // newChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n@@ -167,3 +163,21 @@ func (cw *chunkedWriter) Close() error {\n \t_, err := io.WriteString(cw.Wire, \"0\\r\\n\")\n \treturn err\n }\n+\n+func parseHexUint(v []byte) (n uint64, err error) {\n+\tfor _, b := range v {\n+\t\tn <<= 4\n+\t\tswitch {\n+\t\tcase '0' <= b && b <= '9':\n+\t\t\tb = b - '0'\n+\t\tcase 'a' <= b && b <= 'f':\n+\t\t\tb = b - 'a' + 10\n+\t\tcase 'A' <= b && b <= 'F':\n+\t\t\tb = b - 'A' + 10\n+\t\tdefault:\n+\t\t\treturn 0, errors.New(\"invalid byte in chunk length\")\n+\t\t}\n+\t\tn |= uint64(b)\n+\t}\n+\treturn\n+}"}, {"sha": "0b18c7b55ec23da26dee90affa869da71449dbae", "filename": "libgo/go/net/http/chunked_test.go", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -9,7 +9,10 @@ package http\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n \t\"io/ioutil\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n@@ -37,3 +40,54 @@ func TestChunk(t *testing.T) {\n \t\tt.Errorf(\"chunk reader read %q; want %q\", g, e)\n \t}\n }\n+\n+func TestChunkReaderAllocs(t *testing.T) {\n+\t// temporarily set GOMAXPROCS to 1 as we are testing memory allocations\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n+\tvar buf bytes.Buffer\n+\tw := newChunkedWriter(&buf)\n+\ta, b, c := []byte(\"aaaaaa\"), []byte(\"bbbbbbbbbbbb\"), []byte(\"cccccccccccccccccccccccc\")\n+\tw.Write(a)\n+\tw.Write(b)\n+\tw.Write(c)\n+\tw.Close()\n+\n+\tr := newChunkedReader(&buf)\n+\treadBuf := make([]byte, len(a)+len(b)+len(c)+1)\n+\n+\tvar ms runtime.MemStats\n+\truntime.ReadMemStats(&ms)\n+\tm0 := ms.Mallocs\n+\n+\tn, err := io.ReadFull(r, readBuf)\n+\n+\truntime.ReadMemStats(&ms)\n+\tmallocs := ms.Mallocs - m0\n+\tif mallocs > 1 {\n+\t\tt.Errorf(\"%d mallocs; want <= 1\", mallocs)\n+\t}\n+\n+\tif n != len(readBuf)-1 {\n+\t\tt.Errorf(\"read %d bytes; want %d\", n, len(readBuf)-1)\n+\t}\n+\tif err != io.ErrUnexpectedEOF {\n+\t\tt.Errorf(\"read error = %v; want ErrUnexpectedEOF\", err)\n+\t}\n+}\n+\n+func TestParseHexUint(t *testing.T) {\n+\tfor i := uint64(0); i <= 1234; i++ {\n+\t\tline := []byte(fmt.Sprintf(\"%x\", i))\n+\t\tgot, err := parseHexUint(line)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"on %d: %v\", i, err)\n+\t\t}\n+\t\tif got != i {\n+\t\t\tt.Errorf(\"for input %q = %d; want %d\", line, got, i)\n+\t\t}\n+\t}\n+\t_, err := parseHexUint([]byte(\"bogus\"))\n+\tif err == nil {\n+\t\tt.Error(\"expected error on bogus input\")\n+\t}\n+}"}, {"sha": "f4ba6a9e652ac7d2d611c4c16b8c15f2a811930d", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -527,3 +527,38 @@ func TestClientWithIncorrectTLSServerName(t *testing.T) {\n \t\tt.Errorf(\"wanted error mentioning 127.0.0.1 and badserver; got error: %v\", err)\n \t}\n }\n+\n+// Verify Response.ContentLength is populated. http://golang.org/issue/4126\n+func TestClientHeadContentLength(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tif v := r.FormValue(\"cl\"); v != \"\" {\n+\t\t\tw.Header().Set(\"Content-Length\", v)\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\ttests := []struct {\n+\t\tsuffix string\n+\t\twant   int64\n+\t}{\n+\t\t{\"/?cl=1234\", 1234},\n+\t\t{\"/?cl=0\", 0},\n+\t\t{\"\", -1},\n+\t}\n+\tfor _, tt := range tests {\n+\t\treq, _ := NewRequest(\"HEAD\", ts.URL+tt.suffix, nil)\n+\t\tres, err := DefaultClient.Do(req)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif res.ContentLength != tt.want {\n+\t\t\tt.Errorf(\"Content-Length = %d; want %d\", res.ContentLength, tt.want)\n+\t\t}\n+\t\tbs, err := ioutil.ReadAll(res.Body)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif len(bs) != 0 {\n+\t\t\tt.Errorf(\"Unexpected content: %q\", bs)\n+\t\t}\n+\t}\n+}"}, {"sha": "a7a07852d18b7dac221a694e1be0991292b9f484", "filename": "libgo/go/net/http/export_test.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -7,7 +7,14 @@\n \n package http\n \n-import \"time\"\n+import (\n+\t\"net\"\n+\t\"time\"\n+)\n+\n+func NewLoggingConn(baseName string, c net.Conn) net.Conn {\n+\treturn newLoggingConn(baseName, c)\n+}\n \n func (t *Transport) IdleConnKeysForTesting() (keys []string) {\n \tkeys = make([]string, 0)"}, {"sha": "01bb4dce00002fad0a3426722ff8a4a12dd1d75f", "filename": "libgo/go/net/http/header_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fheader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fheader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fheader_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -188,6 +188,7 @@ type errorfer interface {\n }\n \n func doHeaderWriteSubset(n int, t errorfer) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \th := Header(map[string][]string{\n \t\t\"Content-Length\": {\"123\"},\n \t\t\"Content-Type\":   {\"text/plain\"},\n@@ -204,7 +205,7 @@ func doHeaderWriteSubset(n int, t errorfer) {\n \tvar m1 runtime.MemStats\n \truntime.ReadMemStats(&m1)\n \tif mallocs := m1.Mallocs - m0.Mallocs; n >= 100 && mallocs >= uint64(n) {\n-\t\t// TODO(bradfitz,rsc): once we can sort with allocating,\n+\t\t// TODO(bradfitz,rsc): once we can sort without allocating,\n \t\t// make this an error.  See http://golang.org/issue/3761\n \t\t// t.Errorf(\"did %d mallocs (>= %d iterations); should have avoided mallocs\", mallocs, n)\n \t}"}, {"sha": "fc52c9a2efce7b0d7f46399969b92ddf603d0a56", "filename": "libgo/go/net/http/httptest/server.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -21,7 +21,7 @@ import (\n type Server struct {\n \tURL      string // base URL of form http://ipaddr:port with no trailing slash\n \tListener net.Listener\n-\tTLS      *tls.Config // nil if not using using TLS\n+\tTLS      *tls.Config // nil if not using TLS\n \n \t// Config may be changed after calling NewUnstartedServer and\n \t// before Start or StartTLS.\n@@ -36,13 +36,16 @@ type Server struct {\n // accepted.\n type historyListener struct {\n \tnet.Listener\n-\thistory []net.Conn\n+\tsync.Mutex // protects history\n+\thistory    []net.Conn\n }\n \n func (hs *historyListener) Accept() (c net.Conn, err error) {\n \tc, err = hs.Listener.Accept()\n \tif err == nil {\n+\t\ths.Lock()\n \t\ths.history = append(hs.history, c)\n+\t\ths.Unlock()\n \t}\n \treturn\n }\n@@ -96,7 +99,7 @@ func (s *Server) Start() {\n \tif s.URL != \"\" {\n \t\tpanic(\"Server already started\")\n \t}\n-\ts.Listener = &historyListener{s.Listener, make([]net.Conn, 0)}\n+\ts.Listener = &historyListener{Listener: s.Listener}\n \ts.URL = \"http://\" + s.Listener.Addr().String()\n \ts.wrapHandler()\n \tgo s.Config.Serve(s.Listener)\n@@ -122,7 +125,7 @@ func (s *Server) StartTLS() {\n \t}\n \ttlsListener := tls.NewListener(s.Listener, s.TLS)\n \n-\ts.Listener = &historyListener{tlsListener, make([]net.Conn, 0)}\n+\ts.Listener = &historyListener{Listener: tlsListener}\n \ts.URL = \"https://\" + s.Listener.Addr().String()\n \ts.wrapHandler()\n \tgo s.Config.Serve(s.Listener)\n@@ -152,6 +155,10 @@ func NewTLSServer(handler http.Handler) *Server {\n func (s *Server) Close() {\n \ts.Listener.Close()\n \ts.wg.Wait()\n+\ts.CloseClientConnections()\n+\tif t, ok := http.DefaultTransport.(*http.Transport); ok {\n+\t\tt.CloseIdleConnections()\n+\t}\n }\n \n // CloseClientConnections closes any currently open HTTP connections\n@@ -161,9 +168,11 @@ func (s *Server) CloseClientConnections() {\n \tif !ok {\n \t\treturn\n \t}\n+\thl.Lock()\n \tfor _, conn := range hl.history {\n \t\tconn.Close()\n \t}\n+\thl.Unlock()\n }\n \n // waitGroupHandler wraps a handler, incrementing and decrementing a"}, {"sha": "b66d4095153f91fe18343317ee92f20ead9ff849", "filename": "libgo/go/net/http/httputil/chunked.go", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -13,11 +13,9 @@ package httputil\n \n import (\n \t\"bufio\"\n-\t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"strconv\"\n )\n \n const maxLineLength = 4096 // assumed <= bufio.defaultBufSize\n@@ -47,12 +45,12 @@ type chunkedReader struct {\n \n func (cr *chunkedReader) beginChunk() {\n \t// chunk-size CRLF\n-\tvar line string\n+\tvar line []byte\n \tline, cr.err = readLine(cr.r)\n \tif cr.err != nil {\n \t\treturn\n \t}\n-\tcr.n, cr.err = strconv.ParseUint(line, 16, 64)\n+\tcr.n, cr.err = parseHexUint(line)\n \tif cr.err != nil {\n \t\treturn\n \t}\n@@ -91,7 +89,7 @@ func (cr *chunkedReader) Read(b []uint8) (n int, err error) {\n // Give up if the line exceeds maxLineLength.\n // The returned bytes are a pointer into storage in\n // the bufio, so they are only valid until the next bufio read.\n-func readLineBytes(b *bufio.Reader) (p []byte, err error) {\n+func readLine(b *bufio.Reader) (p []byte, err error) {\n \tif p, err = b.ReadSlice('\\n'); err != nil {\n \t\t// We always know when EOF is coming.\n \t\t// If the caller asked for a line, there should be a line.\n@@ -105,20 +103,18 @@ func readLineBytes(b *bufio.Reader) (p []byte, err error) {\n \tif len(p) >= maxLineLength {\n \t\treturn nil, ErrLineTooLong\n \t}\n-\n-\t// Chop off trailing white space.\n-\tp = bytes.TrimRight(p, \" \\r\\t\\n\")\n-\n-\treturn p, nil\n+\treturn trimTrailingWhitespace(p), nil\n }\n \n-// readLineBytes, but convert the bytes into a string.\n-func readLine(b *bufio.Reader) (s string, err error) {\n-\tp, e := readLineBytes(b)\n-\tif e != nil {\n-\t\treturn \"\", e\n+func trimTrailingWhitespace(b []byte) []byte {\n+\tfor len(b) > 0 && isASCIISpace(b[len(b)-1]) {\n+\t\tb = b[:len(b)-1]\n \t}\n-\treturn string(p), nil\n+\treturn b\n+}\n+\n+func isASCIISpace(b byte) bool {\n+\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n }\n \n // NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n@@ -169,3 +165,21 @@ func (cw *chunkedWriter) Close() error {\n \t_, err := io.WriteString(cw.Wire, \"0\\r\\n\")\n \treturn err\n }\n+\n+func parseHexUint(v []byte) (n uint64, err error) {\n+\tfor _, b := range v {\n+\t\tn <<= 4\n+\t\tswitch {\n+\t\tcase '0' <= b && b <= '9':\n+\t\t\tb = b - '0'\n+\t\tcase 'a' <= b && b <= 'f':\n+\t\t\tb = b - 'a' + 10\n+\t\tcase 'A' <= b && b <= 'F':\n+\t\t\tb = b - 'A' + 10\n+\t\tdefault:\n+\t\t\treturn 0, errors.New(\"invalid byte in chunk length\")\n+\t\t}\n+\t\tn |= uint64(b)\n+\t}\n+\treturn\n+}"}, {"sha": "a06bffad5b30f7032cc7bd24a52ed537dbd40f29", "filename": "libgo/go/net/http/httputil/chunked_test.go", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -11,7 +11,10 @@ package httputil\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n \t\"io/ioutil\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n@@ -39,3 +42,54 @@ func TestChunk(t *testing.T) {\n \t\tt.Errorf(\"chunk reader read %q; want %q\", g, e)\n \t}\n }\n+\n+func TestChunkReaderAllocs(t *testing.T) {\n+\t// temporarily set GOMAXPROCS to 1 as we are testing memory allocations\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n+\tvar buf bytes.Buffer\n+\tw := NewChunkedWriter(&buf)\n+\ta, b, c := []byte(\"aaaaaa\"), []byte(\"bbbbbbbbbbbb\"), []byte(\"cccccccccccccccccccccccc\")\n+\tw.Write(a)\n+\tw.Write(b)\n+\tw.Write(c)\n+\tw.Close()\n+\n+\tr := NewChunkedReader(&buf)\n+\treadBuf := make([]byte, len(a)+len(b)+len(c)+1)\n+\n+\tvar ms runtime.MemStats\n+\truntime.ReadMemStats(&ms)\n+\tm0 := ms.Mallocs\n+\n+\tn, err := io.ReadFull(r, readBuf)\n+\n+\truntime.ReadMemStats(&ms)\n+\tmallocs := ms.Mallocs - m0\n+\tif mallocs > 1 {\n+\t\tt.Errorf(\"%d mallocs; want <= 1\", mallocs)\n+\t}\n+\n+\tif n != len(readBuf)-1 {\n+\t\tt.Errorf(\"read %d bytes; want %d\", n, len(readBuf)-1)\n+\t}\n+\tif err != io.ErrUnexpectedEOF {\n+\t\tt.Errorf(\"read error = %v; want ErrUnexpectedEOF\", err)\n+\t}\n+}\n+\n+func TestParseHexUint(t *testing.T) {\n+\tfor i := uint64(0); i <= 1234; i++ {\n+\t\tline := []byte(fmt.Sprintf(\"%x\", i))\n+\t\tgot, err := parseHexUint(line)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"on %d: %v\", i, err)\n+\t\t}\n+\t\tif got != i {\n+\t\t\tt.Errorf(\"for input %q = %d; want %d\", line, got, i)\n+\t\t}\n+\t}\n+\t_, err := parseHexUint([]byte(\"bogus\"))\n+\tif err == nil {\n+\t\tt.Error(\"expected error on bogus input\")\n+\t}\n+}"}, {"sha": "0b6e6cbab58697eaab8441bb27a5d29735ae919f", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -124,6 +124,7 @@ type Request struct {\n \t// The host on which the URL is sought.\n \t// Per RFC 2616, this is either the value of the Host: header\n \t// or the host name given in the URL itself.\n+\t// It may be of the form \"host:port\".\n \tHost string\n \n \t// Form contains the parsed form data, including both the URL\n@@ -643,16 +644,20 @@ func parsePostForm(r *Request) (vs url.Values, err error) {\n \treturn\n }\n \n-// ParseForm parses the raw query from the URL.\n+// ParseForm parses the raw query from the URL and updates r.Form.\n+//\n+// For POST or PUT requests, it also parses the request body as a form and\n+// put the results into both r.PostForm and r.Form.\n+// POST and PUT body parameters take precedence over URL query string values\n+// in r.Form.\n //\n-// For POST or PUT requests, it also parses the request body as a form.\n-// POST and PUT body parameters take precedence over URL query string values.\n // If the request Body's size has not already been limited by MaxBytesReader,\n // the size is capped at 10MB.\n //\n // ParseMultipartForm calls ParseForm automatically.\n // It is idempotent.\n-func (r *Request) ParseForm() (err error) {\n+func (r *Request) ParseForm() error {\n+\tvar err error\n \tif r.PostForm == nil {\n \t\tif r.Method == \"POST\" || r.Method == \"PUT\" {\n \t\t\tr.PostForm, err = parsePostForm(r)\n@@ -728,6 +733,7 @@ func (r *Request) ParseMultipartForm(maxMemory int64) error {\n // FormValue returns the first value for the named component of the query.\n // POST and PUT body parameters take precedence over URL query string values.\n // FormValue calls ParseMultipartForm and ParseForm if necessary.\n+// To access multiple values of the same key use ParseForm.\n func (r *Request) FormValue(key string) string {\n \tif r.Form == nil {\n \t\tr.ParseMultipartForm(defaultMaxMemory)"}, {"sha": "2f34d124128d47de91cd9f73d2f9fc8782e92c7b", "filename": "libgo/go/net/http/request_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -228,6 +228,16 @@ func TestReadRequestErrors(t *testing.T) {\n \t}\n }\n \n+func TestNewRequestHost(t *testing.T) {\n+\treq, err := NewRequest(\"GET\", \"http://localhost:1234/\", nil)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif req.Host != \"localhost:1234\" {\n+\t\tt.Errorf(\"Host = %q; want localhost:1234\", req.Host)\n+\t}\n+}\n+\n func testMissingFile(t *testing.T, req *Request) {\n \tf, fh, err := req.FormFile(\"missing\")\n \tif f != nil {"}, {"sha": "7901c49f5a50db51866afd31b7f264e8bf02c4bd", "filename": "libgo/go/net/http/response.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -49,7 +49,7 @@ type Response struct {\n \tBody io.ReadCloser\n \n \t// ContentLength records the length of the associated content.  The\n-\t// value -1 indicates that the length is unknown.  Unless RequestMethod\n+\t// value -1 indicates that the length is unknown.  Unless Request.Method\n \t// is \"HEAD\", values >= 0 indicate that the given number of bytes may\n \t// be read from Body.\n \tContentLength int64\n@@ -178,7 +178,7 @@ func (r *Response) ProtoAtLeast(major, minor int) bool {\n //  StatusCode\n //  ProtoMajor\n //  ProtoMinor\n-//  RequestMethod\n+//  Request.Method\n //  TransferEncoding\n //  Trailer\n //  Body"}, {"sha": "f31e5d09fe5d9133edc10d7fe299255bc79319e1", "filename": "libgo/go/net/http/response_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -193,7 +193,7 @@ var respTests = []respTest{\n \t\t\tRequest:       dummyReq(\"HEAD\"),\n \t\t\tHeader:        Header{},\n \t\t\tClose:         true,\n-\t\t\tContentLength: 0,\n+\t\t\tContentLength: -1,\n \t\t},\n \n \t\t\"\","}, {"sha": "8ca227f9dec71cc7e233c1218690638c3f945134", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -1252,6 +1252,42 @@ func TestContentLengthZero(t *testing.T) {\n \t}\n }\n \n+func TestCloseNotifier(t *testing.T) {\n+\tgotReq := make(chan bool, 1)\n+\tsawClose := make(chan bool, 1)\n+\tts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {\n+\t\tgotReq <- true\n+\t\tcc := rw.(CloseNotifier).CloseNotify()\n+\t\t<-cc\n+\t\tsawClose <- true\n+\t}))\n+\tconn, err := net.Dial(\"tcp\", ts.Listener.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatalf(\"error dialing: %v\", err)\n+\t}\n+\tdiec := make(chan bool)\n+\tgo func() {\n+\t\t_, err = fmt.Fprintf(conn, \"GET / HTTP/1.1\\r\\nConnection: keep-alive\\r\\nHost: foo\\r\\n\\r\\n\")\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\t<-diec\n+\t\tconn.Close()\n+\t}()\n+For:\n+\tfor {\n+\t\tselect {\n+\t\tcase <-gotReq:\n+\t\t\tdiec <- true\n+\t\tcase <-sawClose:\n+\t\t\tbreak For\n+\t\tcase <-time.After(5 * time.Second):\n+\t\t\tt.Fatal(\"timeout\")\n+\t\t}\n+\t}\n+\tts.Close()\n+}\n+\n // goTimeout runs f, failing t if f takes more than ns to complete.\n func goTimeout(t *testing.T, d time.Duration, f func()) {\n \tch := make(chan bool, 2)"}, {"sha": "c4ddbec54f1ce86d806f4dcc64d683e96884c9ac", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 183, "deletions": 44, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -11,7 +11,6 @@ package http\n \n import (\n \t\"bufio\"\n-\t\"bytes\"\n \t\"crypto/tls\"\n \t\"errors\"\n \t\"fmt\"\n@@ -21,7 +20,7 @@ import (\n \t\"net\"\n \t\"net/url\"\n \t\"path\"\n-\t\"runtime/debug\"\n+\t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n@@ -94,16 +93,104 @@ type Hijacker interface {\n \tHijack() (net.Conn, *bufio.ReadWriter, error)\n }\n \n+// The CloseNotifier interface is implemented by ResponseWriters which\n+// allow detecting when the underlying connection has gone away.\n+//\n+// This mechanism can be used to cancel long operations on the server\n+// if the client has disconnected before the response is ready.\n+type CloseNotifier interface {\n+\t// CloseNotify returns a channel that receives a single value\n+\t// when the client connection has gone away.\n+\tCloseNotify() <-chan bool\n+}\n+\n // A conn represents the server side of an HTTP connection.\n type conn struct {\n \tremoteAddr string               // network address of remote side\n \tserver     *Server              // the Server on which the connection arrived\n \trwc        net.Conn             // i/o connection\n-\tlr         *io.LimitedReader    // io.LimitReader(rwc)\n-\tbuf        *bufio.ReadWriter    // buffered(lr,rwc), reading from bufio->limitReader->rwc\n-\thijacked   bool                 // connection has been hijacked by handler\n+\tsr         switchReader         // where the LimitReader reads from; usually the rwc\n+\tlr         *io.LimitedReader    // io.LimitReader(sr)\n+\tbuf        *bufio.ReadWriter    // buffered(lr,rwc), reading from bufio->limitReader->sr->rwc\n \ttlsState   *tls.ConnectionState // or nil when not using TLS\n \tbody       []byte\n+\n+\tmu           sync.Mutex // guards the following\n+\tclientGone   bool       // if client has disconnected mid-request\n+\tcloseNotifyc chan bool  // made lazily\n+\thijackedv    bool       // connection has been hijacked by handler\n+}\n+\n+func (c *conn) hijacked() bool {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\treturn c.hijackedv\n+}\n+\n+func (c *conn) hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif c.hijackedv {\n+\t\treturn nil, nil, ErrHijacked\n+\t}\n+\tif c.closeNotifyc != nil {\n+\t\treturn nil, nil, errors.New(\"http: Hijack is incompatible with use of CloseNotifier\")\n+\t}\n+\tc.hijackedv = true\n+\trwc = c.rwc\n+\tbuf = c.buf\n+\tc.rwc = nil\n+\tc.buf = nil\n+\treturn\n+}\n+\n+func (c *conn) closeNotify() <-chan bool {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif c.closeNotifyc == nil {\n+\t\tc.closeNotifyc = make(chan bool)\n+\t\tif c.hijackedv {\n+\t\t\t// to obey the function signature, even though\n+\t\t\t// it'll never receive a value.\n+\t\t\treturn c.closeNotifyc\n+\t\t}\n+\t\tpr, pw := io.Pipe()\n+\n+\t\treadSource := c.sr.r\n+\t\tc.sr.Lock()\n+\t\tc.sr.r = pr\n+\t\tc.sr.Unlock()\n+\t\tgo func() {\n+\t\t\t_, err := io.Copy(pw, readSource)\n+\t\t\tif err == nil {\n+\t\t\t\terr = io.EOF\n+\t\t\t}\n+\t\t\tpw.CloseWithError(err)\n+\t\t\tc.noteClientGone()\n+\t\t}()\n+\t}\n+\treturn c.closeNotifyc\n+}\n+\n+func (c *conn) noteClientGone() {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif c.closeNotifyc != nil && !c.clientGone {\n+\t\tc.closeNotifyc <- true\n+\t}\n+\tc.clientGone = true\n+}\n+\n+type switchReader struct {\n+\tsync.Mutex\n+\tr io.Reader\n+}\n+\n+func (sr *switchReader) Read(p []byte) (n int, err error) {\n+\tsr.Lock()\n+\tr := sr.r\n+\tsr.Unlock()\n+\treturn r.Read(p)\n }\n \n // A response represents the server side of an HTTP response.\n@@ -127,7 +214,7 @@ type response struct {\n \n \t// requestBodyLimitHit is set by requestTooLarge when\n \t// maxBytesReader hits its max size. It is checked in\n-\t// WriteHeader, to make sure we don't consume the the\n+\t// WriteHeader, to make sure we don't consume the\n \t// remaining request body to try to advance to the next HTTP\n \t// request. Instead, when this is set, we stop reading\n \t// subsequent requests on this connection and stop reading\n@@ -171,16 +258,24 @@ func (w *response) ReadFrom(src io.Reader) (n int64, err error) {\n // noLimit is an effective infinite upper bound for io.LimitedReader\n const noLimit int64 = (1 << 63) - 1\n \n+// debugServerConnections controls whether all server connections are wrapped\n+// with a verbose logging wrapper.\n+const debugServerConnections = false\n+\n // Create new connection from rwc.\n func (srv *Server) newConn(rwc net.Conn) (c *conn, err error) {\n \tc = new(conn)\n \tc.remoteAddr = rwc.RemoteAddr().String()\n \tc.server = srv\n \tc.rwc = rwc\n+\tif debugServerConnections {\n+\t\tc.rwc = newLoggingConn(\"server\", c.rwc)\n+\t}\n+\tc.sr = switchReader{r: c.rwc}\n \tc.body = make([]byte, sniffLen)\n-\tc.lr = io.LimitReader(rwc, noLimit).(*io.LimitedReader)\n+\tc.lr = io.LimitReader(&c.sr, noLimit).(*io.LimitedReader)\n \tbr := bufio.NewReader(c.lr)\n-\tbw := bufio.NewWriter(rwc)\n+\tbw := bufio.NewWriter(c.rwc)\n \tc.buf = bufio.NewReadWriter(br, bw)\n \treturn c, nil\n }\n@@ -207,9 +302,9 @@ type expectContinueReader struct {\n \n func (ecr *expectContinueReader) Read(p []byte) (n int, err error) {\n \tif ecr.closed {\n-\t\treturn 0, errors.New(\"http: Read after Close on request Body\")\n+\t\treturn 0, ErrBodyReadAfterClose\n \t}\n-\tif !ecr.resp.wroteContinue && !ecr.resp.conn.hijacked {\n+\tif !ecr.resp.wroteContinue && !ecr.resp.conn.hijacked() {\n \t\tecr.resp.wroteContinue = true\n \t\tio.WriteString(ecr.resp.conn.buf, \"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n \t\tecr.resp.conn.buf.Flush()\n@@ -232,7 +327,7 @@ var errTooLarge = errors.New(\"http: request too large\")\n \n // Read next request from connection.\n func (c *conn) readRequest() (w *response, err error) {\n-\tif c.hijacked {\n+\tif c.hijacked() {\n \t\treturn nil, ErrHijacked\n \t}\n \tc.lr.N = int64(c.server.maxHeaderBytes()) + 4096 /* bufio slop */\n@@ -273,7 +368,7 @@ func (w *response) Header() Header {\n const maxPostHandlerReadBytes = 256 << 10\n \n func (w *response) WriteHeader(code int) {\n-\tif w.conn.hijacked {\n+\tif w.conn.hijacked() {\n \t\tlog.Print(\"http: response.WriteHeader on hijacked connection\")\n \t\treturn\n \t}\n@@ -363,6 +458,8 @@ func (w *response) WriteHeader(code int) {\n \n \tif w.req.Method == \"HEAD\" || code == StatusNotModified {\n \t\t// do nothing\n+\t} else if code == StatusNoContent {\n+\t\tw.header.Del(\"Transfer-Encoding\")\n \t} else if hasCL {\n \t\tw.contentLength = contentLength\n \t\tw.header.Del(\"Transfer-Encoding\")\n@@ -447,7 +544,7 @@ func (w *response) bodyAllowed() bool {\n }\n \n func (w *response) Write(data []byte) (n int, err error) {\n-\tif w.conn.hijacked {\n+\tif w.conn.hijacked() {\n \t\tlog.Print(\"http: response.Write on hijacked connection\")\n \t\treturn 0, ErrHijacked\n \t}\n@@ -496,7 +593,7 @@ func (w *response) Write(data []byte) (n int, err error) {\n \t// then there would be fewer chunk headers.\n \t// On the other hand, it would make hijacking more difficult.\n \tif w.chunking {\n-\t\tfmt.Fprintf(w.conn.buf, \"%x\\r\\n\", len(data)) // TODO(rsc): use strconv not fmt\n+\t\tfmt.Fprintf(w.conn.buf, \"%x\\r\\n\", len(data))\n \t}\n \tn, err = w.conn.buf.Write(data)\n \tif err == nil && w.chunking {\n@@ -517,7 +614,7 @@ func (w *response) finishRequest() {\n \t// HTTP/1.0 clients keep their \"keep-alive\" connections alive, and for\n \t// HTTP/1.1 clients is just as good as the alternative: sending a\n \t// chunked response and immediately sending the zero-length EOF chunk.\n-\tif w.written == 0 && w.header.get(\"Content-Length\") == \"\" {\n+\tif w.written == 0 && w.header.get(\"Content-Length\") == \"\" && w.req.Method != \"HEAD\" {\n \t\tw.header.Set(\"Content-Length\", \"0\")\n \t}\n \t// If this was an HTTP/1.0 request with keep-alive and we sent a\n@@ -610,10 +707,10 @@ func (c *conn) serve() {\n \t\t\treturn\n \t\t}\n \n-\t\tvar buf bytes.Buffer\n-\t\tfmt.Fprintf(&buf, \"http: panic serving %v: %v\\n\", c.remoteAddr, err)\n-\t\tbuf.Write(debug.Stack())\n-\t\tlog.Print(buf.String())\n+\t\tconst size = 4096\n+\t\tbuf := make([]byte, size)\n+\t\tbuf = buf[:runtime.Stack(buf, false)]\n+\t\tlog.Printf(\"http: panic serving %v: %v\\n%s\", c.remoteAddr, err, buf)\n \n \t\tif c.rwc != nil { // may be nil if connection hijacked\n \t\t\tc.rwc.Close()\n@@ -665,21 +762,7 @@ func (c *conn) serve() {\n \t\t\t}\n \t\t\treq.Header.Del(\"Expect\")\n \t\t} else if req.Header.get(\"Expect\") != \"\" {\n-\t\t\t// TODO(bradfitz): let ServeHTTP handlers handle\n-\t\t\t// requests with non-standard expectation[s]? Seems\n-\t\t\t// theoretical at best, and doesn't fit into the\n-\t\t\t// current ServeHTTP model anyway.  We'd need to\n-\t\t\t// make the ResponseWriter an optional\n-\t\t\t// \"ExpectReplier\" interface or something.\n-\t\t\t//\n-\t\t\t// For now we'll just obey RFC 2616 14.20 which says\n-\t\t\t// \"If a server receives a request containing an\n-\t\t\t// Expect field that includes an expectation-\n-\t\t\t// extension that it does not support, it MUST\n-\t\t\t// respond with a 417 (Expectation Failed) status.\"\n-\t\t\tw.Header().Set(\"Connection\", \"close\")\n-\t\t\tw.WriteHeader(StatusExpectationFailed)\n-\t\t\tw.finishRequest()\n+\t\t\tw.sendExpectationFailed()\n \t\t\tbreak\n \t\t}\n \n@@ -694,7 +777,7 @@ func (c *conn) serve() {\n \t\t// [*] Not strictly true: HTTP pipelining.  We could let them all process\n \t\t// in parallel even if their responses need to be serialized.\n \t\thandler.ServeHTTP(w, w.req)\n-\t\tif c.hijacked {\n+\t\tif c.hijacked() {\n \t\t\treturn\n \t\t}\n \t\tw.finishRequest()\n@@ -708,18 +791,32 @@ func (c *conn) serve() {\n \tc.close()\n }\n \n+func (w *response) sendExpectationFailed() {\n+\t// TODO(bradfitz): let ServeHTTP handlers handle\n+\t// requests with non-standard expectation[s]? Seems\n+\t// theoretical at best, and doesn't fit into the\n+\t// current ServeHTTP model anyway.  We'd need to\n+\t// make the ResponseWriter an optional\n+\t// \"ExpectReplier\" interface or something.\n+\t//\n+\t// For now we'll just obey RFC 2616 14.20 which says\n+\t// \"If a server receives a request containing an\n+\t// Expect field that includes an expectation-\n+\t// extension that it does not support, it MUST\n+\t// respond with a 417 (Expectation Failed) status.\"\n+\tw.Header().Set(\"Connection\", \"close\")\n+\tw.WriteHeader(StatusExpectationFailed)\n+\tw.finishRequest()\n+}\n+\n // Hijack implements the Hijacker.Hijack method. Our response is both a ResponseWriter\n // and a Hijacker.\n func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error) {\n-\tif w.conn.hijacked {\n-\t\treturn nil, nil, ErrHijacked\n-\t}\n-\tw.conn.hijacked = true\n-\trwc = w.conn.rwc\n-\tbuf = w.conn.buf\n-\tw.conn.rwc = nil\n-\tw.conn.buf = nil\n-\treturn\n+\treturn w.conn.hijack()\n+}\n+\n+func (w *response) CloseNotify() <-chan bool {\n+\treturn w.conn.closeNotify()\n }\n \n // The HandlerFunc type is an adapter to allow the use of\n@@ -1310,3 +1407,45 @@ func (tw *timeoutWriter) WriteHeader(code int) {\n \ttw.mu.Unlock()\n \ttw.w.WriteHeader(code)\n }\n+\n+// loggingConn is used for debugging.\n+type loggingConn struct {\n+\tname string\n+\tnet.Conn\n+}\n+\n+var (\n+\tuniqNameMu   sync.Mutex\n+\tuniqNameNext = make(map[string]int)\n+)\n+\n+func newLoggingConn(baseName string, c net.Conn) net.Conn {\n+\tuniqNameMu.Lock()\n+\tdefer uniqNameMu.Unlock()\n+\tuniqNameNext[baseName]++\n+\treturn &loggingConn{\n+\t\tname: fmt.Sprintf(\"%s-%d\", baseName, uniqNameNext[baseName]),\n+\t\tConn: c,\n+\t}\n+}\n+\n+func (c *loggingConn) Write(p []byte) (n int, err error) {\n+\tlog.Printf(\"%s.Write(%d) = ....\", c.name, len(p))\n+\tn, err = c.Conn.Write(p)\n+\tlog.Printf(\"%s.Write(%d) = %d, %v\", c.name, len(p), n, err)\n+\treturn\n+}\n+\n+func (c *loggingConn) Read(p []byte) (n int, err error) {\n+\tlog.Printf(\"%s.Read(%d) = ....\", c.name, len(p))\n+\tn, err = c.Conn.Read(p)\n+\tlog.Printf(\"%s.Read(%d) = %d, %v\", c.name, len(p), n, err)\n+\treturn\n+}\n+\n+func (c *loggingConn) Close() (err error) {\n+\tlog.Printf(\"%s.Close() = ...\", c.name)\n+\terr = c.Conn.Close()\n+\tlog.Printf(\"%s.Close() = %v\", c.name, err)\n+\treturn\n+}"}, {"sha": "70ea15b8e4a346c8e255a102b0fb43347e80c104", "filename": "libgo/go/net/http/transfer.go", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -294,10 +294,19 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \t\treturn err\n \t}\n \n-\tt.ContentLength, err = fixLength(isResponse, t.StatusCode, t.RequestMethod, t.Header, t.TransferEncoding)\n+\trealLength, err := fixLength(isResponse, t.StatusCode, t.RequestMethod, t.Header, t.TransferEncoding)\n \tif err != nil {\n \t\treturn err\n \t}\n+\tif isResponse && t.RequestMethod == \"HEAD\" {\n+\t\tif n, err := parseContentLength(t.Header.get(\"Content-Length\")); err != nil {\n+\t\t\treturn err\n+\t\t} else {\n+\t\t\tt.ContentLength = n\n+\t\t}\n+\t} else {\n+\t\tt.ContentLength = realLength\n+\t}\n \n \t// Trailer\n \tt.Trailer, err = fixTrailer(t.Header, t.TransferEncoding)\n@@ -310,7 +319,7 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \t// See RFC2616, section 4.4.\n \tswitch msg.(type) {\n \tcase *Response:\n-\t\tif t.ContentLength == -1 &&\n+\t\tif realLength == -1 &&\n \t\t\t!chunked(t.TransferEncoding) &&\n \t\t\tbodyAllowedForStatus(t.StatusCode) {\n \t\t\t// Unbounded body.\n@@ -323,11 +332,11 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \tswitch {\n \tcase chunked(t.TransferEncoding):\n \t\tt.Body = &body{Reader: newChunkedReader(r), hdr: msg, r: r, closing: t.Close}\n-\tcase t.ContentLength >= 0:\n+\tcase realLength >= 0:\n \t\t// TODO: limit the Content-Length. This is an easy DoS vector.\n-\t\tt.Body = &body{Reader: io.LimitReader(r, t.ContentLength), closing: t.Close}\n+\t\tt.Body = &body{Reader: io.LimitReader(r, realLength), closing: t.Close}\n \tdefault:\n-\t\t// t.ContentLength < 0, i.e. \"Content-Length\" not mentioned in header\n+\t\t// realLength < 0, i.e. \"Content-Length\" not mentioned in header\n \t\tif t.Close {\n \t\t\t// Close semantics (i.e. HTTP/1.0)\n \t\t\tt.Body = &body{Reader: r, closing: t.Close}\n@@ -434,9 +443,9 @@ func fixLength(isResponse bool, status int, requestMethod string, header Header,\n \t// Logic based on Content-Length\n \tcl := strings.TrimSpace(header.get(\"Content-Length\"))\n \tif cl != \"\" {\n-\t\tn, err := strconv.ParseInt(cl, 10, 64)\n-\t\tif err != nil || n < 0 {\n-\t\t\treturn -1, &badStringError{\"bad Content-Length\", cl}\n+\t\tn, err := parseContentLength(cl)\n+\t\tif err != nil {\n+\t\t\treturn -1, err\n \t\t}\n \t\treturn n, nil\n \t} else {\n@@ -525,11 +534,11 @@ type body struct {\n \tres *response // response writer for server requests, else nil\n }\n \n-// ErrBodyReadAfterClose is returned when reading a Request Body after\n-// the body has been closed. This typically happens when the body is\n+// ErrBodyReadAfterClose is returned when reading a Request or Response\n+// Body after the body has been closed. This typically happens when the body is\n // read after an HTTP Handler calls WriteHeader or Write on its\n // ResponseWriter.\n-var ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed request Body\")\n+var ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed Body\")\n \n func (b *body) Read(p []byte) (n int, err error) {\n \tif b.closed {\n@@ -641,3 +650,18 @@ func (b *body) Close() error {\n \t}\n \treturn nil\n }\n+\n+// parseContentLength trims whitespace from s and returns -1 if no value\n+// is set, or the value if it's >= 0.\n+func parseContentLength(cl string) (int64, error) {\n+\tcl = strings.TrimSpace(cl)\n+\tif cl == \"\" {\n+\t\treturn -1, nil\n+\t}\n+\tn, err := strconv.ParseInt(cl, 10, 64)\n+\tif err != nil || n < 0 {\n+\t\treturn 0, &badStringError{\"bad Content-Length\", cl}\n+\t}\n+\treturn n, nil\n+\n+}"}, {"sha": "7b4afeb8efca88dfc7cf4896bdefb64e7340af60", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 58, "deletions": 47, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -24,15 +24,14 @@ import (\n \t\"os\"\n \t\"strings\"\n \t\"sync\"\n-\t\"sync/atomic\"\n \t\"time\"\n )\n \n // DefaultTransport is the default implementation of Transport and is\n-// used by DefaultClient.  It establishes a new network connection for\n-// each call to Do and uses HTTP proxies as directed by the\n-// $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy)\n-// environment variables.\n+// used by DefaultClient. It establishes network connections as needed\n+// and caches them for reuse by subsequent calls. It uses HTTP proxies\n+// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and\n+// $no_proxy) environment variables.\n var DefaultTransport RoundTripper = &Transport{Proxy: ProxyFromEnvironment}\n \n // DefaultMaxIdleConnsPerHost is the default value of Transport's\n@@ -71,7 +70,7 @@ type Transport struct {\n \tDisableCompression bool\n \n \t// MaxIdleConnsPerHost, if non-zero, controls the maximum idle\n-\t// (keep-alive) to keep to keep per-host.  If zero,\n+\t// (keep-alive) to keep per-host.  If zero,\n \t// DefaultMaxIdleConnsPerHost is used.\n \tMaxIdleConnsPerHost int\n }\n@@ -91,7 +90,7 @@ func ProxyFromEnvironment(req *Request) (*url.URL, error) {\n \t\treturn nil, nil\n \t}\n \tproxyURL, err := url.Parse(proxy)\n-\tif err != nil || proxyURL.Scheme == \"\" {\n+\tif err != nil || !strings.HasPrefix(proxyURL.Scheme, \"http\") {\n \t\tif u, err := url.Parse(\"http://\" + proxy); err == nil {\n \t\t\tproxyURL = u\n \t\t\terr = nil\n@@ -605,22 +604,23 @@ func (pc *persistConn) readLoop() {\n \t\t\talive = false\n \t\t}\n \n-\t\t// TODO(bradfitz): this hasBody conflicts with the defition\n-\t\t// above which excludes HEAD requests.  Is this one\n-\t\t// incomplete?\n-\t\thasBody := resp != nil && resp.ContentLength != 0\n+\t\thasBody := resp != nil && rc.req.Method != \"HEAD\" && resp.ContentLength != 0\n \t\tvar waitForBodyRead chan bool\n \t\tif hasBody {\n \t\t\tlastbody = resp.Body\n \t\t\twaitForBodyRead = make(chan bool, 1)\n-\t\t\tresp.Body.(*bodyEOFSignal).fn = func() {\n-\t\t\t\tif alive && !pc.t.putIdleConn(pc) {\n-\t\t\t\t\talive = false\n+\t\t\tresp.Body.(*bodyEOFSignal).fn = func(err error) {\n+\t\t\t\talive1 := alive\n+\t\t\t\tif err != nil {\n+\t\t\t\t\talive1 = false\n \t\t\t\t}\n-\t\t\t\tif !alive || pc.isBroken() {\n+\t\t\t\tif alive1 && !pc.t.putIdleConn(pc) {\n+\t\t\t\t\talive1 = false\n+\t\t\t\t}\n+\t\t\t\tif !alive1 || pc.isBroken() {\n \t\t\t\t\tpc.close()\n \t\t\t\t}\n-\t\t\t\twaitForBodyRead <- true\n+\t\t\t\twaitForBodyRead <- alive1\n \t\t\t}\n \t\t}\n \n@@ -644,7 +644,7 @@ func (pc *persistConn) readLoop() {\n \t\t// Wait for the just-returned response body to be fully consumed\n \t\t// before we race and peek on the underlying bufio reader.\n \t\tif waitForBodyRead != nil {\n-\t\t\t<-waitForBodyRead\n+\t\t\talive = <-waitForBodyRead\n \t\t}\n \n \t\tif !alive {\n@@ -810,50 +810,61 @@ func canonicalAddr(url *url.URL) string {\n }\n \n // bodyEOFSignal wraps a ReadCloser but runs fn (if non-nil) at most\n-// once, right before the final Read() or Close() call returns, but after\n-// EOF has been seen.\n+// once, right before its final (error-producing) Read or Close call\n+// returns.\n type bodyEOFSignal struct {\n-\tbody     io.ReadCloser\n-\tfn       func()\n-\tisClosed uint32 // atomic bool, non-zero if true\n-\tonce     sync.Once\n+\tbody   io.ReadCloser\n+\tmu     sync.Mutex  // guards closed, rerr and fn\n+\tclosed bool        // whether Close has been called\n+\trerr   error       // sticky Read error\n+\tfn     func(error) // error will be nil on Read io.EOF\n }\n \n func (es *bodyEOFSignal) Read(p []byte) (n int, err error) {\n-\tn, err = es.body.Read(p)\n-\tif es.closed() && n > 0 {\n-\t\tpanic(\"http: unexpected bodyEOFSignal Read after Close; see issue 1725\")\n+\tes.mu.Lock()\n+\tclosed, rerr := es.closed, es.rerr\n+\tes.mu.Unlock()\n+\tif closed {\n+\t\treturn 0, errors.New(\"http: read on closed response body\")\n \t}\n-\tif err == io.EOF {\n-\t\tes.condfn()\n+\tif rerr != nil {\n+\t\treturn 0, rerr\n \t}\n-\treturn\n-}\n \n-func (es *bodyEOFSignal) Close() (err error) {\n-\tif !es.setClosed() {\n-\t\t// already closed\n-\t\treturn nil\n-\t}\n-\terr = es.body.Close()\n-\tif err == nil {\n-\t\tes.condfn()\n+\tn, err = es.body.Read(p)\n+\tif err != nil {\n+\t\tes.mu.Lock()\n+\t\tdefer es.mu.Unlock()\n+\t\tif es.rerr == nil {\n+\t\t\tes.rerr = err\n+\t\t}\n+\t\tes.condfn(err)\n \t}\n \treturn\n }\n \n-func (es *bodyEOFSignal) condfn() {\n-\tif es.fn != nil {\n-\t\tes.once.Do(es.fn)\n+func (es *bodyEOFSignal) Close() error {\n+\tes.mu.Lock()\n+\tdefer es.mu.Unlock()\n+\tif es.closed {\n+\t\treturn nil\n \t}\n+\tes.closed = true\n+\terr := es.body.Close()\n+\tes.condfn(err)\n+\treturn err\n }\n \n-func (es *bodyEOFSignal) closed() bool {\n-\treturn atomic.LoadUint32(&es.isClosed) != 0\n-}\n-\n-func (es *bodyEOFSignal) setClosed() bool {\n-\treturn atomic.CompareAndSwapUint32(&es.isClosed, 0, 1)\n+// caller must hold es.mu.\n+func (es *bodyEOFSignal) condfn(err error) {\n+\tif es.fn == nil {\n+\t\treturn\n+\t}\n+\tif err == io.EOF {\n+\t\terr = nil\n+\t}\n+\tes.fn(err)\n+\tes.fn = nil\n }\n \n type readFirstCloseBoth struct {"}, {"sha": "f1d415888ca870e407a9d519b2aa0fab88933c7a", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 136, "deletions": 2, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -281,7 +281,7 @@ func TestTransportMaxPerHostIdleConns(t *testing.T) {\n \tc := &Client{Transport: tr}\n \n \t// Start 3 outstanding requests and wait for the server to get them.\n-\t// Their responses will hang until we we write to resch, though.\n+\t// Their responses will hang until we write to resch, though.\n \tdonech := make(chan bool)\n \tdoReq := func() {\n \t\tresp, err := c.Get(ts.URL)\n@@ -464,7 +464,7 @@ func TestTransportHeadResponses(t *testing.T) {\n \t\tif e, g := \"123\", res.Header.Get(\"Content-Length\"); e != g {\n \t\t\tt.Errorf(\"loop %d: expected Content-Length header of %q, got %q\", i, e, g)\n \t\t}\n-\t\tif e, g := int64(0), res.ContentLength; e != g {\n+\t\tif e, g := int64(123), res.ContentLength; e != g {\n \t\t\tt.Errorf(\"loop %d: expected res.ContentLength of %v, got %v\", i, e, g)\n \t\t}\n \t}\n@@ -857,6 +857,30 @@ func TestIssue3595(t *testing.T) {\n \t}\n }\n \n+// From http://golang.org/issue/4454 ,\n+// \"client fails to handle requests with no body and chunked encoding\"\n+func TestChunkedNoContent(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tw.WriteHeader(StatusNoContent)\n+\t}))\n+\tdefer ts.Close()\n+\n+\tfor _, closeBody := range []bool{true, false} {\n+\t\tc := &Client{Transport: &Transport{}}\n+\t\tconst n = 4\n+\t\tfor i := 1; i <= n; i++ {\n+\t\t\tres, err := c.Get(ts.URL)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"closingBody=%v, req %d/%d: %v\", closeBody, i, n, err)\n+\t\t\t} else {\n+\t\t\t\tif closeBody {\n+\t\t\t\t\tres.Body.Close()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n func TestTransportConcurrency(t *testing.T) {\n \tconst maxProcs = 16\n \tconst numReqs = 500\n@@ -901,6 +925,113 @@ func TestTransportConcurrency(t *testing.T) {\n \twg.Wait()\n }\n \n+func TestIssue4191_InfiniteGetTimeout(t *testing.T) {\n+\tconst debug = false\n+\tmux := NewServeMux()\n+\tmux.HandleFunc(\"/get\", func(w ResponseWriter, r *Request) {\n+\t\tio.Copy(w, neverEnding('a'))\n+\t})\n+\tts := httptest.NewServer(mux)\n+\n+\tclient := &Client{\n+\t\tTransport: &Transport{\n+\t\t\tDial: func(n, addr string) (net.Conn, error) {\n+\t\t\t\tconn, err := net.Dial(n, addr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t\tconn.SetDeadline(time.Now().Add(100 * time.Millisecond))\n+\t\t\t\tif debug {\n+\t\t\t\t\tconn = NewLoggingConn(\"client\", conn)\n+\t\t\t\t}\n+\t\t\t\treturn conn, nil\n+\t\t\t},\n+\t\t\tDisableKeepAlives: true,\n+\t\t},\n+\t}\n+\n+\tnRuns := 5\n+\tif testing.Short() {\n+\t\tnRuns = 1\n+\t}\n+\tfor i := 0; i < nRuns; i++ {\n+\t\tif debug {\n+\t\t\tprintln(\"run\", i+1, \"of\", nRuns)\n+\t\t}\n+\t\tsres, err := client.Get(ts.URL + \"/get\")\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Error issuing GET: %v\", err)\n+\t\t\tbreak\n+\t\t}\n+\t\t_, err = io.Copy(ioutil.Discard, sres.Body)\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"Unexpected successful copy\")\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif debug {\n+\t\tprintln(\"tests complete; waiting for handlers to finish\")\n+\t}\n+\tts.Close()\n+}\n+\n+func TestIssue4191_InfiniteGetToPutTimeout(t *testing.T) {\n+\tconst debug = false\n+\tmux := NewServeMux()\n+\tmux.HandleFunc(\"/get\", func(w ResponseWriter, r *Request) {\n+\t\tio.Copy(w, neverEnding('a'))\n+\t})\n+\tmux.HandleFunc(\"/put\", func(w ResponseWriter, r *Request) {\n+\t\tdefer r.Body.Close()\n+\t\tio.Copy(ioutil.Discard, r.Body)\n+\t})\n+\tts := httptest.NewServer(mux)\n+\n+\tclient := &Client{\n+\t\tTransport: &Transport{\n+\t\t\tDial: func(n, addr string) (net.Conn, error) {\n+\t\t\t\tconn, err := net.Dial(n, addr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t\tconn.SetDeadline(time.Now().Add(100 * time.Millisecond))\n+\t\t\t\tif debug {\n+\t\t\t\t\tconn = NewLoggingConn(\"client\", conn)\n+\t\t\t\t}\n+\t\t\t\treturn conn, nil\n+\t\t\t},\n+\t\t\tDisableKeepAlives: true,\n+\t\t},\n+\t}\n+\n+\tnRuns := 5\n+\tif testing.Short() {\n+\t\tnRuns = 1\n+\t}\n+\tfor i := 0; i < nRuns; i++ {\n+\t\tif debug {\n+\t\t\tprintln(\"run\", i+1, \"of\", nRuns)\n+\t\t}\n+\t\tsres, err := client.Get(ts.URL + \"/get\")\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Error issuing GET: %v\", err)\n+\t\t\tbreak\n+\t\t}\n+\t\treq, _ := NewRequest(\"PUT\", ts.URL+\"/put\", sres.Body)\n+\t\t_, err = client.Do(req)\n+\t\tif err == nil {\n+\t\t\tsres.Body.Close()\n+\t\t\tt.Errorf(\"Unexpected successful PUT\")\n+\t\t\tbreak\n+\t\t}\n+\t\tsres.Body.Close()\n+\t}\n+\tif debug {\n+\t\tprintln(\"tests complete; waiting for handlers to finish\")\n+\t}\n+\tts.Close()\n+}\n+\n type fooProto struct{}\n \n func (fooProto) RoundTrip(req *Request) (*Response, error) {\n@@ -937,6 +1068,9 @@ var proxyFromEnvTests = []struct {\n \twanterr error\n }{\n \t{\"127.0.0.1:8080\", \"http://127.0.0.1:8080\", nil},\n+\t{\"cache.corp.example.com:1234\", \"http://cache.corp.example.com:1234\", nil},\n+\t{\"cache.corp.example.com\", \"http://cache.corp.example.com\", nil},\n+\t{\"https://cache.corp.example.com\", \"https://cache.corp.example.com\", nil},\n \t{\"http://127.0.0.1:8080\", \"http://127.0.0.1:8080\", nil},\n \t{\"https://127.0.0.1:8080\", \"https://127.0.0.1:8080\", nil},\n \t{\"\", \"<nil>\", nil},"}, {"sha": "0aac3d187a1921ea7087ee54df4af63c8c4243db", "filename": "libgo/go/net/ip.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -36,6 +36,7 @@ type IPMask []byte\n type IPNet struct {\n \tIP   IP     // network number\n \tMask IPMask // network mask\n+\tZone string // IPv6 scoped addressing zone\n }\n \n // IPv4 returns the IP address (in 16-byte form) of the\n@@ -645,5 +646,5 @@ func ParseCIDR(s string) (IP, *IPNet, error) {\n \t\treturn nil, nil, &ParseError{\"CIDR address\", s}\n \t}\n \tm := CIDRMask(n, 8*iplen)\n-\treturn ip, &IPNet{ip.Mask(m), m}, nil\n+\treturn ip, &IPNet{IP: ip.Mask(m), Mask: m}, nil\n }"}, {"sha": "8324d2a327c1b22c835f4b73953edd142f199a8e", "filename": "libgo/go/net/ip_test.go", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -114,23 +114,23 @@ var parsecidrtests = []struct {\n \tnet *IPNet\n \terr error\n }{\n-\t{\"135.104.0.0/32\", IPv4(135, 104, 0, 0), &IPNet{IPv4(135, 104, 0, 0), IPv4Mask(255, 255, 255, 255)}, nil},\n-\t{\"0.0.0.0/24\", IPv4(0, 0, 0, 0), &IPNet{IPv4(0, 0, 0, 0), IPv4Mask(255, 255, 255, 0)}, nil},\n-\t{\"135.104.0.0/24\", IPv4(135, 104, 0, 0), &IPNet{IPv4(135, 104, 0, 0), IPv4Mask(255, 255, 255, 0)}, nil},\n-\t{\"135.104.0.1/32\", IPv4(135, 104, 0, 1), &IPNet{IPv4(135, 104, 0, 1), IPv4Mask(255, 255, 255, 255)}, nil},\n-\t{\"135.104.0.1/24\", IPv4(135, 104, 0, 1), &IPNet{IPv4(135, 104, 0, 0), IPv4Mask(255, 255, 255, 0)}, nil},\n-\t{\"::1/128\", ParseIP(\"::1\"), &IPNet{ParseIP(\"::1\"), IPMask(ParseIP(\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\"))}, nil},\n-\t{\"abcd:2345::/127\", ParseIP(\"abcd:2345::\"), &IPNet{ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe\"))}, nil},\n-\t{\"abcd:2345::/65\", ParseIP(\"abcd:2345::\"), &IPNet{ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:ffff:ffff:8000::\"))}, nil},\n-\t{\"abcd:2345::/64\", ParseIP(\"abcd:2345::\"), &IPNet{ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:ffff:ffff::\"))}, nil},\n-\t{\"abcd:2345::/63\", ParseIP(\"abcd:2345::\"), &IPNet{ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:ffff:fffe::\"))}, nil},\n-\t{\"abcd:2345::/33\", ParseIP(\"abcd:2345::\"), &IPNet{ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:8000::\"))}, nil},\n-\t{\"abcd:2345::/32\", ParseIP(\"abcd:2345::\"), &IPNet{ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff::\"))}, nil},\n-\t{\"abcd:2344::/31\", ParseIP(\"abcd:2344::\"), &IPNet{ParseIP(\"abcd:2344::\"), IPMask(ParseIP(\"ffff:fffe::\"))}, nil},\n-\t{\"abcd:2300::/24\", ParseIP(\"abcd:2300::\"), &IPNet{ParseIP(\"abcd:2300::\"), IPMask(ParseIP(\"ffff:ff00::\"))}, nil},\n-\t{\"abcd:2345::/24\", ParseIP(\"abcd:2345::\"), &IPNet{ParseIP(\"abcd:2300::\"), IPMask(ParseIP(\"ffff:ff00::\"))}, nil},\n-\t{\"2001:DB8::/48\", ParseIP(\"2001:DB8::\"), &IPNet{ParseIP(\"2001:DB8::\"), IPMask(ParseIP(\"ffff:ffff:ffff::\"))}, nil},\n-\t{\"2001:DB8::1/48\", ParseIP(\"2001:DB8::1\"), &IPNet{ParseIP(\"2001:DB8::\"), IPMask(ParseIP(\"ffff:ffff:ffff::\"))}, nil},\n+\t{\"135.104.0.0/32\", IPv4(135, 104, 0, 0), &IPNet{IP: IPv4(135, 104, 0, 0), Mask: IPv4Mask(255, 255, 255, 255)}, nil},\n+\t{\"0.0.0.0/24\", IPv4(0, 0, 0, 0), &IPNet{IP: IPv4(0, 0, 0, 0), Mask: IPv4Mask(255, 255, 255, 0)}, nil},\n+\t{\"135.104.0.0/24\", IPv4(135, 104, 0, 0), &IPNet{IP: IPv4(135, 104, 0, 0), Mask: IPv4Mask(255, 255, 255, 0)}, nil},\n+\t{\"135.104.0.1/32\", IPv4(135, 104, 0, 1), &IPNet{IP: IPv4(135, 104, 0, 1), Mask: IPv4Mask(255, 255, 255, 255)}, nil},\n+\t{\"135.104.0.1/24\", IPv4(135, 104, 0, 1), &IPNet{IP: IPv4(135, 104, 0, 0), Mask: IPv4Mask(255, 255, 255, 0)}, nil},\n+\t{\"::1/128\", ParseIP(\"::1\"), &IPNet{IP: ParseIP(\"::1\"), Mask: IPMask(ParseIP(\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\"))}, nil},\n+\t{\"abcd:2345::/127\", ParseIP(\"abcd:2345::\"), &IPNet{IP: ParseIP(\"abcd:2345::\"), Mask: IPMask(ParseIP(\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe\"))}, nil},\n+\t{\"abcd:2345::/65\", ParseIP(\"abcd:2345::\"), &IPNet{IP: ParseIP(\"abcd:2345::\"), Mask: IPMask(ParseIP(\"ffff:ffff:ffff:ffff:8000::\"))}, nil},\n+\t{\"abcd:2345::/64\", ParseIP(\"abcd:2345::\"), &IPNet{IP: ParseIP(\"abcd:2345::\"), Mask: IPMask(ParseIP(\"ffff:ffff:ffff:ffff::\"))}, nil},\n+\t{\"abcd:2345::/63\", ParseIP(\"abcd:2345::\"), &IPNet{IP: ParseIP(\"abcd:2345::\"), Mask: IPMask(ParseIP(\"ffff:ffff:ffff:fffe::\"))}, nil},\n+\t{\"abcd:2345::/33\", ParseIP(\"abcd:2345::\"), &IPNet{IP: ParseIP(\"abcd:2345::\"), Mask: IPMask(ParseIP(\"ffff:ffff:8000::\"))}, nil},\n+\t{\"abcd:2345::/32\", ParseIP(\"abcd:2345::\"), &IPNet{IP: ParseIP(\"abcd:2345::\"), Mask: IPMask(ParseIP(\"ffff:ffff::\"))}, nil},\n+\t{\"abcd:2344::/31\", ParseIP(\"abcd:2344::\"), &IPNet{IP: ParseIP(\"abcd:2344::\"), Mask: IPMask(ParseIP(\"ffff:fffe::\"))}, nil},\n+\t{\"abcd:2300::/24\", ParseIP(\"abcd:2300::\"), &IPNet{IP: ParseIP(\"abcd:2300::\"), Mask: IPMask(ParseIP(\"ffff:ff00::\"))}, nil},\n+\t{\"abcd:2345::/24\", ParseIP(\"abcd:2345::\"), &IPNet{IP: ParseIP(\"abcd:2300::\"), Mask: IPMask(ParseIP(\"ffff:ff00::\"))}, nil},\n+\t{\"2001:DB8::/48\", ParseIP(\"2001:DB8::\"), &IPNet{IP: ParseIP(\"2001:DB8::\"), Mask: IPMask(ParseIP(\"ffff:ffff:ffff::\"))}, nil},\n+\t{\"2001:DB8::1/48\", ParseIP(\"2001:DB8::1\"), &IPNet{IP: ParseIP(\"2001:DB8::\"), Mask: IPMask(ParseIP(\"ffff:ffff:ffff::\"))}, nil},\n \t{\"192.168.1.1/255.255.255.0\", nil, nil, &ParseError{\"CIDR address\", \"192.168.1.1/255.255.255.0\"}},\n \t{\"192.168.1.1/35\", nil, nil, &ParseError{\"CIDR address\", \"192.168.1.1/35\"}},\n \t{\"2001:db8::1/-1\", nil, nil, &ParseError{\"CIDR address\", \"2001:db8::1/-1\"}},\n@@ -154,14 +154,14 @@ var ipnetcontainstests = []struct {\n \tnet *IPNet\n \tok  bool\n }{\n-\t{IPv4(172, 16, 1, 1), &IPNet{IPv4(172, 16, 0, 0), CIDRMask(12, 32)}, true},\n-\t{IPv4(172, 24, 0, 1), &IPNet{IPv4(172, 16, 0, 0), CIDRMask(13, 32)}, false},\n-\t{IPv4(192, 168, 0, 3), &IPNet{IPv4(192, 168, 0, 0), IPv4Mask(0, 0, 255, 252)}, true},\n-\t{IPv4(192, 168, 0, 4), &IPNet{IPv4(192, 168, 0, 0), IPv4Mask(0, 255, 0, 252)}, false},\n-\t{ParseIP(\"2001:db8:1:2::1\"), &IPNet{ParseIP(\"2001:db8:1::\"), CIDRMask(47, 128)}, true},\n-\t{ParseIP(\"2001:db8:1:2::1\"), &IPNet{ParseIP(\"2001:db8:2::\"), CIDRMask(47, 128)}, false},\n-\t{ParseIP(\"2001:db8:1:2::1\"), &IPNet{ParseIP(\"2001:db8:1::\"), IPMask(ParseIP(\"ffff:0:ffff::\"))}, true},\n-\t{ParseIP(\"2001:db8:1:2::1\"), &IPNet{ParseIP(\"2001:db8:1::\"), IPMask(ParseIP(\"0:0:0:ffff::\"))}, false},\n+\t{IPv4(172, 16, 1, 1), &IPNet{IP: IPv4(172, 16, 0, 0), Mask: CIDRMask(12, 32)}, true},\n+\t{IPv4(172, 24, 0, 1), &IPNet{IP: IPv4(172, 16, 0, 0), Mask: CIDRMask(13, 32)}, false},\n+\t{IPv4(192, 168, 0, 3), &IPNet{IP: IPv4(192, 168, 0, 0), Mask: IPv4Mask(0, 0, 255, 252)}, true},\n+\t{IPv4(192, 168, 0, 4), &IPNet{IP: IPv4(192, 168, 0, 0), Mask: IPv4Mask(0, 255, 0, 252)}, false},\n+\t{ParseIP(\"2001:db8:1:2::1\"), &IPNet{IP: ParseIP(\"2001:db8:1::\"), Mask: CIDRMask(47, 128)}, true},\n+\t{ParseIP(\"2001:db8:1:2::1\"), &IPNet{IP: ParseIP(\"2001:db8:2::\"), Mask: CIDRMask(47, 128)}, false},\n+\t{ParseIP(\"2001:db8:1:2::1\"), &IPNet{IP: ParseIP(\"2001:db8:1::\"), Mask: IPMask(ParseIP(\"ffff:0:ffff::\"))}, true},\n+\t{ParseIP(\"2001:db8:1:2::1\"), &IPNet{IP: ParseIP(\"2001:db8:1::\"), Mask: IPMask(ParseIP(\"0:0:0:ffff::\"))}, false},\n }\n \n func TestIPNetContains(t *testing.T) {\n@@ -176,10 +176,10 @@ var ipnetstringtests = []struct {\n \tin  *IPNet\n \tout string\n }{\n-\t{&IPNet{IPv4(192, 168, 1, 0), CIDRMask(26, 32)}, \"192.168.1.0/26\"},\n-\t{&IPNet{IPv4(192, 168, 1, 0), IPv4Mask(255, 0, 255, 0)}, \"192.168.1.0/ff00ff00\"},\n-\t{&IPNet{ParseIP(\"2001:db8::\"), CIDRMask(55, 128)}, \"2001:db8::/55\"},\n-\t{&IPNet{ParseIP(\"2001:db8::\"), IPMask(ParseIP(\"8000:f123:0:cafe::\"))}, \"2001:db8::/8000f1230000cafe0000000000000000\"},\n+\t{&IPNet{IP: IPv4(192, 168, 1, 0), Mask: CIDRMask(26, 32)}, \"192.168.1.0/26\"},\n+\t{&IPNet{IP: IPv4(192, 168, 1, 0), Mask: IPv4Mask(255, 0, 255, 0)}, \"192.168.1.0/ff00ff00\"},\n+\t{&IPNet{IP: ParseIP(\"2001:db8::\"), Mask: CIDRMask(55, 128)}, \"2001:db8::/55\"},\n+\t{&IPNet{IP: ParseIP(\"2001:db8::\"), Mask: IPMask(ParseIP(\"8000:f123:0:cafe::\"))}, \"2001:db8::/8000f1230000cafe0000000000000000\"},\n }\n \n func TestIPNetString(t *testing.T) {\n@@ -233,27 +233,27 @@ var networknumberandmasktests = []struct {\n \tin  IPNet\n \tout IPNet\n }{\n-\t{IPNet{v4addr, v4mask}, IPNet{v4addr, v4mask}},\n-\t{IPNet{v4addr, v4mappedv6mask}, IPNet{v4addr, v4mask}},\n-\t{IPNet{v4mappedv6addr, v4mappedv6mask}, IPNet{v4addr, v4mask}},\n-\t{IPNet{v4mappedv6addr, v6mask}, IPNet{v4addr, v4maskzero}},\n-\t{IPNet{v4addr, v6mask}, IPNet{v4addr, v4maskzero}},\n-\t{IPNet{v6addr, v6mask}, IPNet{v6addr, v6mask}},\n-\t{IPNet{v6addr, v4mappedv6mask}, IPNet{v6addr, v4mappedv6mask}},\n-\t{in: IPNet{v6addr, v4mask}},\n-\t{in: IPNet{v4addr, badmask}},\n-\t{in: IPNet{v4mappedv6addr, badmask}},\n-\t{in: IPNet{v6addr, badmask}},\n-\t{in: IPNet{badaddr, v4mask}},\n-\t{in: IPNet{badaddr, v4mappedv6mask}},\n-\t{in: IPNet{badaddr, v6mask}},\n-\t{in: IPNet{badaddr, badmask}},\n+\t{IPNet{IP: v4addr, Mask: v4mask}, IPNet{IP: v4addr, Mask: v4mask}},\n+\t{IPNet{IP: v4addr, Mask: v4mappedv6mask}, IPNet{IP: v4addr, Mask: v4mask}},\n+\t{IPNet{IP: v4mappedv6addr, Mask: v4mappedv6mask}, IPNet{IP: v4addr, Mask: v4mask}},\n+\t{IPNet{IP: v4mappedv6addr, Mask: v6mask}, IPNet{IP: v4addr, Mask: v4maskzero}},\n+\t{IPNet{IP: v4addr, Mask: v6mask}, IPNet{IP: v4addr, Mask: v4maskzero}},\n+\t{IPNet{IP: v6addr, Mask: v6mask}, IPNet{IP: v6addr, Mask: v6mask}},\n+\t{IPNet{IP: v6addr, Mask: v4mappedv6mask}, IPNet{IP: v6addr, Mask: v4mappedv6mask}},\n+\t{in: IPNet{IP: v6addr, Mask: v4mask}},\n+\t{in: IPNet{IP: v4addr, Mask: badmask}},\n+\t{in: IPNet{IP: v4mappedv6addr, Mask: badmask}},\n+\t{in: IPNet{IP: v6addr, Mask: badmask}},\n+\t{in: IPNet{IP: badaddr, Mask: v4mask}},\n+\t{in: IPNet{IP: badaddr, Mask: v4mappedv6mask}},\n+\t{in: IPNet{IP: badaddr, Mask: v6mask}},\n+\t{in: IPNet{IP: badaddr, Mask: badmask}},\n }\n \n func TestNetworkNumberAndMask(t *testing.T) {\n \tfor _, tt := range networknumberandmasktests {\n \t\tip, m := networkNumberAndMask(&tt.in)\n-\t\tout := &IPNet{ip, m}\n+\t\tout := &IPNet{IP: ip, Mask: m}\n \t\tif !reflect.DeepEqual(&tt.out, out) {\n \t\t\tt.Errorf(\"networkNumberAndMask(%v) = %v; want %v\", tt.in, out, &tt.out)\n \t\t}\n@@ -268,6 +268,7 @@ var splitjointests = []struct {\n \t{\"www.google.com\", \"80\", \"www.google.com:80\"},\n \t{\"127.0.0.1\", \"1234\", \"127.0.0.1:1234\"},\n \t{\"::1\", \"80\", \"[::1]:80\"},\n+\t{\"google.com\", \"https%foo\", \"google.com:https%foo\"}, // Go 1.0 behavior\n }\n \n func TestSplitHostPort(t *testing.T) {"}, {"sha": "f21889fcbeaac96d9e4a7fcad2873254fd8c1a50", "filename": "libgo/go/net/ipraw_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fipraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fipraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipraw_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -9,11 +9,46 @@ package net\n import (\n \t\"bytes\"\n \t\"os\"\n+\t\"reflect\"\n \t\"syscall\"\n \t\"testing\"\n \t\"time\"\n )\n \n+var resolveIPAddrTests = []struct {\n+\tnet     string\n+\tlitAddr string\n+\taddr    *IPAddr\n+\terr     error\n+}{\n+\t{\"ip\", \"127.0.0.1\", &IPAddr{IP: IPv4(127, 0, 0, 1)}, nil},\n+\t{\"ip4\", \"127.0.0.1\", &IPAddr{IP: IPv4(127, 0, 0, 1)}, nil},\n+\t{\"ip4:icmp\", \"127.0.0.1\", &IPAddr{IP: IPv4(127, 0, 0, 1)}, nil},\n+\n+\t{\"ip\", \"::1\", &IPAddr{IP: ParseIP(\"::1\")}, nil},\n+\t{\"ip6\", \"::1\", &IPAddr{IP: ParseIP(\"::1\")}, nil},\n+\t{\"ip6:icmp\", \"::1\", &IPAddr{IP: ParseIP(\"::1\")}, nil},\n+\n+\t{\"\", \"127.0.0.1\", &IPAddr{IP: IPv4(127, 0, 0, 1)}, nil}, // Go 1.0 behavior\n+\t{\"\", \"::1\", &IPAddr{IP: ParseIP(\"::1\")}, nil},           // Go 1.0 behavior\n+\n+\t{\"l2tp\", \"127.0.0.1\", nil, UnknownNetworkError(\"l2tp\")},\n+\t{\"l2tp:gre\", \"127.0.0.1\", nil, UnknownNetworkError(\"l2tp:gre\")},\n+\t{\"tcp\", \"1.2.3.4:123\", nil, UnknownNetworkError(\"tcp\")},\n+}\n+\n+func TestResolveIPAddr(t *testing.T) {\n+\tfor _, tt := range resolveIPAddrTests {\n+\t\taddr, err := ResolveIPAddr(tt.net, tt.litAddr)\n+\t\tif err != tt.err {\n+\t\t\tt.Fatalf(\"ResolveIPAddr(%v, %v) failed: %v\", tt.net, tt.litAddr, err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(addr, tt.addr) {\n+\t\t\tt.Fatalf(\"got %#v; expected %#v\", addr, tt.addr)\n+\t\t}\n+\t}\n+}\n+\n var icmpTests = []struct {\n \tnet   string\n \tladdr string"}, {"sha": "13bfd62404a49a896d7dab9158b90d4a6e88c232", "filename": "libgo/go/net/iprawsock.go", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fiprawsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fiprawsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -2,17 +2,14 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// (Raw) IP sockets\n+// Raw IP sockets\n \n package net\n \n-import (\n-\t\"time\"\n-)\n-\n // IPAddr represents the address of an IP end point.\n type IPAddr struct {\n-\tIP IP\n+\tIP   IP\n+\tZone string // IPv6 scoped addressing zone\n }\n \n // Network returns the address's network name, \"ip\".\n@@ -27,47 +24,23 @@ func (a *IPAddr) String() string {\n \n // ResolveIPAddr parses addr as an IP address and resolves domain\n // names to numeric addresses on the network net, which must be\n-// \"ip\", \"ip4\" or \"ip6\".  A literal IPv6 host address must be\n-// enclosed in square brackets, as in \"[::]\".\n+// \"ip\", \"ip4\" or \"ip6\".\n func ResolveIPAddr(net, addr string) (*IPAddr, error) {\n-\treturn resolveIPAddr(net, addr, noDeadline)\n-}\n-\n-func resolveIPAddr(net, addr string, deadline time.Time) (*IPAddr, error) {\n-\tip, err := hostToIP(net, addr, deadline)\n+\tif net == \"\" { // a hint wildcard for Go 1.0 undocumented behavior\n+\t\tnet = \"ip\"\n+\t}\n+\tafnet, _, err := parseDialNetwork(net)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn &IPAddr{ip}, nil\n-}\n-\n-// Convert \"host\" into IP address.\n-func hostToIP(net, host string, deadline time.Time) (ip IP, err error) {\n-\tvar addr IP\n-\t// Try as an IP address.\n-\taddr = ParseIP(host)\n-\tif addr == nil {\n-\t\tfilter := anyaddr\n-\t\tif net != \"\" && net[len(net)-1] == '4' {\n-\t\t\tfilter = ipv4only\n-\t\t}\n-\t\tif net != \"\" && net[len(net)-1] == '6' {\n-\t\t\tfilter = ipv6only\n-\t\t}\n-\t\t// Not an IP address.  Try as a DNS name.\n-\t\taddrs, err1 := lookupHostDeadline(host, deadline)\n-\t\tif err1 != nil {\n-\t\t\terr = err1\n-\t\t\tgoto Error\n-\t\t}\n-\t\taddr = firstFavoriteAddr(filter, addrs)\n-\t\tif addr == nil {\n-\t\t\t// should not happen\n-\t\t\terr = &AddrError{\"LookupHost returned no suitable address\", addrs[0]}\n-\t\t\tgoto Error\n-\t\t}\n+\tswitch afnet {\n+\tcase \"ip\", \"ip4\", \"ip6\":\n+\tdefault:\n+\t\treturn nil, UnknownNetworkError(net)\n+\t}\n+\ta, err := resolveInternetAddr(afnet, addr, noDeadline)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\treturn addr, nil\n-Error:\n-\treturn nil, err\n+\treturn a.(*IPAddr), nil\n }"}, {"sha": "88e3b2c60b5df4c825fd62079b7aadec8ffad45a", "filename": "libgo/go/net/iprawsock_plan9.go", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -2,83 +2,21 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// (Raw) IP sockets stubs for Plan 9\n+// Raw IP sockets for Plan 9\n \n package net\n \n import (\n-\t\"os\"\n \t\"syscall\"\n \t\"time\"\n )\n \n // IPConn is the implementation of the Conn and PacketConn interfaces\n // for IP network connections.\n-type IPConn bool\n-\n-// Implementation of the Conn interface - see Conn for documentation.\n-\n-// Read implements the Conn Read method.\n-func (c *IPConn) Read(b []byte) (int, error) {\n-\treturn 0, syscall.EPLAN9\n-}\n-\n-// Write implements the Conn Write method.\n-func (c *IPConn) Write(b []byte) (int, error) {\n-\treturn 0, syscall.EPLAN9\n-}\n-\n-// LocalAddr returns the local network address.\n-func (c *IPConn) LocalAddr() Addr {\n-\treturn nil\n-}\n-\n-// RemoteAddr returns the remote network address.\n-func (c *IPConn) RemoteAddr() Addr {\n-\treturn nil\n-}\n-\n-// SetDeadline implements the Conn SetDeadline method.\n-func (c *IPConn) SetDeadline(t time.Time) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// SetReadDeadline implements the Conn SetReadDeadline method.\n-func (c *IPConn) SetReadDeadline(t time.Time) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// SetWriteDeadline implements the Conn SetWriteDeadline method.\n-func (c *IPConn) SetWriteDeadline(t time.Time) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// SetReadBuffer sets the size of the operating system's receive\n-// buffer associated with the connection.\n-func (c *IPConn) SetReadBuffer(bytes int) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// SetWriteBuffer sets the size of the operating system's transmit\n-// buffer associated with the connection.\n-func (c *IPConn) SetWriteBuffer(bytes int) error {\n-\treturn syscall.EPLAN9\n+type IPConn struct {\n+\tconn\n }\n \n-// File returns a copy of the underlying os.File, set to blocking\n-// mode.  It is the caller's responsibility to close f when finished.\n-// Closing c does not affect f, and closing f does not affect c.\n-func (c *IPConn) File() (f *os.File, err error) {\n-\treturn nil, syscall.EPLAN9\n-}\n-\n-// Close closes the IP connection.\n-func (c *IPConn) Close() error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// IP-specific methods.\n-\n // ReadFromIP reads an IP packet from c, copying the payload into b.\n // It returns the number of bytes copied into b and the return address\n // that was on the packet."}, {"sha": "7a8cd4470d613cfba743a3db534e1bdab095990d", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -4,7 +4,7 @@\n \n // +build darwin freebsd linux netbsd openbsd windows\n \n-// (Raw) IP sockets\n+// Raw IP sockets for POSIX\n \n package net\n \n@@ -16,9 +16,9 @@ import (\n func sockaddrToIP(sa syscall.Sockaddr) Addr {\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrInet4:\n-\t\treturn &IPAddr{sa.Addr[0:]}\n+\t\treturn &IPAddr{IP: sa.Addr[0:]}\n \tcase *syscall.SockaddrInet6:\n-\t\treturn &IPAddr{sa.Addr[0:]}\n+\t\treturn &IPAddr{IP: sa.Addr[0:], Zone: zoneToString(int(sa.ZoneId))}\n \t}\n \treturn nil\n }\n@@ -41,7 +41,7 @@ func (a *IPAddr) isWildcard() bool {\n }\n \n func (a *IPAddr) sockaddr(family int) (syscall.Sockaddr, error) {\n-\treturn ipToSockaddr(family, a.IP, 0)\n+\treturn ipToSockaddr(family, a.IP, 0, a.Zone)\n }\n \n func (a *IPAddr) toAddr() sockaddr {\n@@ -59,8 +59,6 @@ type IPConn struct {\n \n func newIPConn(fd *netFD) *IPConn { return &IPConn{conn{fd}} }\n \n-// IP-specific methods.\n-\n // ReadFromIP reads an IP packet from c, copying the payload into b.\n // It returns the number of bytes copied into b and the return address\n // that was on the packet.\n@@ -78,14 +76,14 @@ func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error) {\n \tn, sa, err := c.fd.ReadFrom(b)\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrInet4:\n-\t\taddr = &IPAddr{sa.Addr[0:]}\n+\t\taddr = &IPAddr{IP: sa.Addr[0:]}\n \t\tif len(b) >= IPv4len { // discard ipv4 header\n \t\t\thsize := (int(b[0]) & 0xf) * 4\n \t\t\tcopy(b, b[hsize:])\n \t\t\tn -= hsize\n \t\t}\n \tcase *syscall.SockaddrInet6:\n-\t\taddr = &IPAddr{sa.Addr[0:]}\n+\t\taddr = &IPAddr{IP: sa.Addr[0:], Zone: zoneToString(int(sa.ZoneId))}\n \t}\n \treturn n, addr, err\n }\n@@ -95,8 +93,8 @@ func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) {\n \tif !c.ok() {\n \t\treturn 0, nil, syscall.EINVAL\n \t}\n-\tn, uaddr, err := c.ReadFromIP(b)\n-\treturn n, uaddr.toAddr(), err\n+\tn, addr, err := c.ReadFromIP(b)\n+\treturn n, addr.toAddr(), err\n }\n \n // ReadMsgIP reads a packet from c, copying the payload into b and the\n@@ -111,9 +109,9 @@ func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err\n \tn, oobn, flags, sa, err = c.fd.ReadMsg(b, oob)\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrInet4:\n-\t\taddr = &IPAddr{sa.Addr[0:]}\n+\t\taddr = &IPAddr{IP: sa.Addr[0:]}\n \tcase *syscall.SockaddrInet6:\n-\t\taddr = &IPAddr{sa.Addr[0:]}\n+\t\taddr = &IPAddr{IP: sa.Addr[0:], Zone: zoneToString(int(sa.ZoneId))}\n \t}\n \treturn\n }"}, {"sha": "5636c85b4ffb91ede85f514e76bee76ecb057a47", "filename": "libgo/go/net/ipsock.go", "status": "modified", "additions": 80, "deletions": 35, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fipsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fipsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// IP sockets\n+// Internet protocol family sockets\n \n package net\n \n@@ -72,15 +72,18 @@ func (e InvalidAddrError) Temporary() bool { return false }\n // \"host:port\" or \"[host]:port\" into host and port.\n // The latter form must be used when host contains a colon.\n func SplitHostPort(hostport string) (host, port string, err error) {\n+\thost, port, _, err = splitHostPort(hostport)\n+\treturn\n+}\n+\n+func splitHostPort(hostport string) (host, port, zone string, err error) {\n \t// The port starts after the last colon.\n \ti := last(hostport, ':')\n \tif i < 0 {\n \t\terr = &AddrError{\"missing port in address\", hostport}\n \t\treturn\n \t}\n-\n-\thost, port = hostport[0:i], hostport[i+1:]\n-\n+\thost, port = hostport[:i], hostport[i+1:]\n \t// Can put brackets around host ...\n \tif len(host) > 0 && host[0] == '[' && host[len(host)-1] == ']' {\n \t\thost = host[1 : len(host)-1]\n@@ -104,42 +107,84 @@ func JoinHostPort(host, port string) string {\n \treturn host + \":\" + port\n }\n \n-// Convert \"host:port\" into IP address and port.\n-func hostPortToIP(net, hostport string, deadline time.Time) (ip IP, iport int, err error) {\n-\thost, port, err := SplitHostPort(hostport)\n-\tif err != nil {\n-\t\treturn nil, 0, err\n-\t}\n-\n-\tvar addr IP\n-\tif host != \"\" {\n-\t\t// Try as an IP address.\n-\t\taddr = ParseIP(host)\n-\t\tif addr == nil {\n-\t\t\tvar filter func(IP) IP\n-\t\t\tif net != \"\" && net[len(net)-1] == '4' {\n-\t\t\t\tfilter = ipv4only\n-\t\t\t}\n-\t\t\tif net != \"\" && net[len(net)-1] == '6' {\n-\t\t\t\tfilter = ipv6only\n-\t\t\t}\n-\t\t\t// Not an IP address.  Try as a DNS name.\n-\t\t\taddrs, err := lookupHostDeadline(host, deadline)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, 0, err\n+func resolveInternetAddr(net, addr string, deadline time.Time) (Addr, error) {\n+\tvar (\n+\t\terr              error\n+\t\thost, port, zone string\n+\t\tportnum          int\n+\t)\n+\tswitch net {\n+\tcase \"tcp\", \"tcp4\", \"tcp6\", \"udp\", \"udp4\", \"udp6\":\n+\t\tif addr != \"\" {\n+\t\t\tif host, port, zone, err = splitHostPort(addr); err != nil {\n+\t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\taddr = firstFavoriteAddr(filter, addrs)\n-\t\t\tif addr == nil {\n-\t\t\t\t// should not happen\n-\t\t\t\treturn nil, 0, &AddrError{\"LookupHost returned no suitable address\", addrs[0]}\n+\t\t\tif portnum, err = parsePort(net, port); err != nil {\n+\t\t\t\treturn nil, err\n \t\t\t}\n \t\t}\n+\tcase \"ip\", \"ip4\", \"ip6\":\n+\t\tif addr != \"\" {\n+\t\t\thost = addr\n+\t\t}\n+\tdefault:\n+\t\treturn nil, UnknownNetworkError(net)\n \t}\n-\n-\tp, err := parsePort(net, port)\n+\tinetaddr := func(net string, ip IP, port int, zone string) Addr {\n+\t\tswitch net {\n+\t\tcase \"tcp\", \"tcp4\", \"tcp6\":\n+\t\t\treturn &TCPAddr{IP: ip, Port: port, Zone: zone}\n+\t\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\t\treturn &UDPAddr{IP: ip, Port: port, Zone: zone}\n+\t\tcase \"ip\", \"ip4\", \"ip6\":\n+\t\t\treturn &IPAddr{IP: ip, Zone: zone}\n+\t\t}\n+\t\treturn nil\n+\t}\n+\tif host == \"\" {\n+\t\treturn inetaddr(net, nil, portnum, zone), nil\n+\t}\n+\t// Try as an IP address.\n+\tif ip := ParseIP(host); ip != nil {\n+\t\treturn inetaddr(net, ip, portnum, zone), nil\n+\t}\n+\tvar filter func(IP) IP\n+\tif net != \"\" && net[len(net)-1] == '4' {\n+\t\tfilter = ipv4only\n+\t}\n+\tif net != \"\" && net[len(net)-1] == '6' {\n+\t\tfilter = ipv6only\n+\t}\n+\t// Try as a DNS name.\n+\taddrs, err := lookupHostDeadline(host, deadline)\n \tif err != nil {\n-\t\treturn nil, 0, err\n+\t\treturn nil, err\n+\t}\n+\tip := firstFavoriteAddr(filter, addrs)\n+\tif ip == nil {\n+\t\t// should not happen\n+\t\treturn nil, &AddrError{\"LookupHost returned no suitable address\", addrs[0]}\n \t}\n+\treturn inetaddr(net, ip, portnum, zone), nil\n+}\n \n-\treturn addr, p, nil\n+func zoneToString(zone int) string {\n+\tif zone == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif ifi, err := InterfaceByIndex(zone); err == nil {\n+\t\treturn ifi.Name\n+\t}\n+\treturn itod(uint(zone))\n+}\n+\n+func zoneToInt(zone string) int {\n+\tif zone == \"\" {\n+\t\treturn 0\n+\t}\n+\tif ifi, err := InterfaceByName(zone); err == nil {\n+\t\treturn ifi.Index\n+\t}\n+\tn, _, _ := dtoi(zone, 0)\n+\treturn n\n }"}, {"sha": "eaef768fd01e30dafd7c207fd2686e23a285ff02", "filename": "libgo/go/net/ipsock_plan9.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// IP sockets stubs for Plan 9\n+// Internet protocol family sockets for Plan 9\n \n package net\n \n@@ -59,9 +59,9 @@ func readPlan9Addr(proto, filename string) (addr Addr, err error) {\n \t}\n \tswitch proto {\n \tcase \"tcp\":\n-\t\taddr = &TCPAddr{ip, port}\n+\t\taddr = &TCPAddr{IP: ip, Port: port}\n \tcase \"udp\":\n-\t\taddr = &UDPAddr{ip, port}\n+\t\taddr = &UDPAddr{IP: ip, Port: port}\n \tdefault:\n \t\treturn nil, errors.New(\"unknown protocol \" + proto)\n \t}"}, {"sha": "4c37616ecf861d8f0fd11b008a8c4556d11df570", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -4,6 +4,8 @@\n \n // +build darwin freebsd linux netbsd openbsd windows\n \n+// Internet protocol family sockets for POSIX\n+\n package net\n \n import (\n@@ -155,7 +157,7 @@ Error:\n \treturn nil, &OpError{mode, net, addr, err}\n }\n \n-func ipToSockaddr(family int, ip IP, port int) (syscall.Sockaddr, error) {\n+func ipToSockaddr(family int, ip IP, port int, zone string) (syscall.Sockaddr, error) {\n \tswitch family {\n \tcase syscall.AF_INET:\n \t\tif len(ip) == 0 {\n@@ -164,12 +166,12 @@ func ipToSockaddr(family int, ip IP, port int) (syscall.Sockaddr, error) {\n \t\tif ip = ip.To4(); ip == nil {\n \t\t\treturn nil, InvalidAddrError(\"non-IPv4 address\")\n \t\t}\n-\t\ts := new(syscall.SockaddrInet4)\n+\t\tsa := new(syscall.SockaddrInet4)\n \t\tfor i := 0; i < IPv4len; i++ {\n-\t\t\ts.Addr[i] = ip[i]\n+\t\t\tsa.Addr[i] = ip[i]\n \t\t}\n-\t\ts.Port = port\n-\t\treturn s, nil\n+\t\tsa.Port = port\n+\t\treturn sa, nil\n \tcase syscall.AF_INET6:\n \t\tif len(ip) == 0 {\n \t\t\tip = IPv6zero\n@@ -183,12 +185,13 @@ func ipToSockaddr(family int, ip IP, port int) (syscall.Sockaddr, error) {\n \t\tif ip = ip.To16(); ip == nil {\n \t\t\treturn nil, InvalidAddrError(\"non-IPv6 address\")\n \t\t}\n-\t\ts := new(syscall.SockaddrInet6)\n+\t\tsa := new(syscall.SockaddrInet6)\n \t\tfor i := 0; i < IPv6len; i++ {\n-\t\t\ts.Addr[i] = ip[i]\n+\t\t\tsa.Addr[i] = ip[i]\n \t\t}\n-\t\ts.Port = port\n-\t\treturn s, nil\n+\t\tsa.Port = port\n+\t\tsa.ZoneId = uint32(zoneToInt(zone))\n+\t\treturn sa, nil\n \t}\n \treturn nil, InvalidAddrError(\"unexpected socket family\")\n }"}, {"sha": "bcc13ee8511b013ab28d2b7dd341eddc61cd4be4", "filename": "libgo/go/net/multicast_posix_test.go", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -21,26 +21,26 @@ var multicastListenerTests = []struct {\n }{\n \t// cf. RFC 4727: Experimental Values in IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP Headers\n \n-\t{\"udp\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, FlagUp | FlagLoopback, false},\n-\t{\"udp\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, 0, false},\n-\t{\"udp\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, FlagUp | FlagLoopback, true},\n-\t{\"udp\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, 0, true},\n+\t{\"udp\", &UDPAddr{IP: IPv4(224, 0, 0, 254), Port: 12345}, FlagUp | FlagLoopback, false},\n+\t{\"udp\", &UDPAddr{IP: IPv4(224, 0, 0, 254), Port: 12345}, 0, false},\n+\t{\"udp\", &UDPAddr{IP: ParseIP(\"ff0e::114\"), Port: 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp\", &UDPAddr{IP: ParseIP(\"ff0e::114\"), Port: 12345}, 0, true},\n \n-\t{\"udp4\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, FlagUp | FlagLoopback, false},\n-\t{\"udp4\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, 0, false},\n+\t{\"udp4\", &UDPAddr{IP: IPv4(224, 0, 0, 254), Port: 12345}, FlagUp | FlagLoopback, false},\n+\t{\"udp4\", &UDPAddr{IP: IPv4(224, 0, 0, 254), Port: 12345}, 0, false},\n \n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff01::114\"), 12345}, FlagUp | FlagLoopback, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff01::114\"), 12345}, 0, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff02::114\"), 12345}, FlagUp | FlagLoopback, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff02::114\"), 12345}, 0, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff04::114\"), 12345}, FlagUp | FlagLoopback, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff04::114\"), 12345}, 0, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff05::114\"), 12345}, FlagUp | FlagLoopback, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff05::114\"), 12345}, 0, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff08::114\"), 12345}, FlagUp | FlagLoopback, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff08::114\"), 12345}, 0, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, FlagUp | FlagLoopback, true},\n-\t{\"udp6\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, 0, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff01::114\"), Port: 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff01::114\"), Port: 12345}, 0, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff02::114\"), Port: 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff02::114\"), Port: 12345}, 0, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff04::114\"), Port: 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff04::114\"), Port: 12345}, 0, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff05::114\"), Port: 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff05::114\"), Port: 12345}, 0, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff08::114\"), Port: 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff08::114\"), Port: 12345}, 0, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff0e::114\"), Port: 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{IP: ParseIP(\"ff0e::114\"), Port: 12345}, 0, true},\n }\n \n // TestMulticastListener tests both single and double listen to a test"}, {"sha": "a3d17598205387e622e97b4c2b349705374c10e5", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -44,7 +44,9 @@ package net\n \n import (\n \t\"errors\"\n+\t\"io\"\n \t\"os\"\n+\t\"sync\"\n \t\"syscall\"\n \t\"time\"\n )\n@@ -195,9 +197,13 @@ func (c *conn) SetWriteBuffer(bytes int) error {\n \treturn setWriteBuffer(c.fd, bytes)\n }\n \n-// File returns a copy of the underlying os.File, set to blocking mode.\n+// File sets the underlying os.File to blocking mode and returns a copy.\n // It is the caller's responsibility to close f when finished.\n // Closing c does not affect f, and closing f does not affect c.\n+//\n+// The returned os.File's file descriptor is different from the connection's.\n+// Attempting to change properties of the original using this duplicate\n+// may or may not have the desired effect.\n func (c *conn) File() (f *os.File, err error) { return c.fd.dup() }\n \n // An Error represents a network error.\n@@ -363,3 +369,47 @@ func (e *DNSConfigError) Error() string {\n \n func (e *DNSConfigError) Timeout() bool   { return false }\n func (e *DNSConfigError) Temporary() bool { return false }\n+\n+type writerOnly struct {\n+\tio.Writer\n+}\n+\n+// Fallback implementation of io.ReaderFrom's ReadFrom, when sendfile isn't\n+// applicable.\n+func genericReadFrom(w io.Writer, r io.Reader) (n int64, err error) {\n+\t// Use wrapper to hide existing r.ReadFrom from io.Copy.\n+\treturn io.Copy(writerOnly{w}, r)\n+}\n+\n+// deadline is an atomically-accessed number of nanoseconds since 1970\n+// or 0, if no deadline is set.\n+type deadline struct {\n+\tsync.Mutex\n+\tval int64\n+}\n+\n+func (d *deadline) expired() bool {\n+\tt := d.value()\n+\treturn t > 0 && time.Now().UnixNano() >= t\n+}\n+\n+func (d *deadline) value() (v int64) {\n+\td.Lock()\n+\tv = d.val\n+\td.Unlock()\n+\treturn\n+}\n+\n+func (d *deadline) set(v int64) {\n+\td.Lock()\n+\td.val = v\n+\td.Unlock()\n+}\n+\n+func (d *deadline) setTime(t time.Time) {\n+\tif t.IsZero() {\n+\t\td.set(0)\n+\t} else {\n+\t\td.set(t.UnixNano())\n+\t}\n+}"}, {"sha": "e71b6fb1a43414d871b2d53834cbf0d7bc01276b", "filename": "libgo/go/net/rpc/server.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -112,7 +112,7 @@\n \n \t\t// Asynchronous call\n \t\tquotient := new(Quotient)\n-\t\tdivCall := client.Go(\"Arith.Divide\", args, &quotient, nil)\n+\t\tdivCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n \t\treplyCall := <-divCall.Done\t// will be equal to divCall\n \t\t// check errors, print, etc.\n \n@@ -219,8 +219,8 @@ func isExportedOrBuiltinType(t reflect.Type) bool {\n //\t- exported method\n //\t- two arguments, both pointers to exported structs\n //\t- one return value, of type error\n-// It returns an error if the receiver is not an exported type or has no\n-// suitable methods.\n+// It returns an error if the receiver is not an exported type or has\n+// no methods or unsuitable methods. It also logs the error using package log.\n // The client accesses each method using a string of the form \"Type.Method\",\n // where Type is the receiver's concrete type.\n func (server *Server) Register(rcvr interface{}) error {"}, {"sha": "2c734a479fd63365976cfb4687011635095c33b3", "filename": "libgo/go/net/rpc/server_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -446,6 +446,7 @@ func dialHTTP() (*Client, error) {\n }\n \n func countMallocs(dial func() (*Client, error), t *testing.T) uint64 {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tonce.Do(startServer)\n \tclient, err := dial()\n \tif err != nil {"}, {"sha": "8008bc3b56047d0ef3433bd7a150e4742dda9e3a", "filename": "libgo/go/net/sendfile_freebsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fsendfile_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fsendfile_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_freebsd.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -82,7 +82,7 @@ func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool) {\n \t\tif n == 0 && err1 == nil {\n \t\t\tbreak\n \t\t}\n-\t\tif err1 == syscall.EAGAIN && c.wdeadline >= 0 {\n+\t\tif err1 == syscall.EAGAIN {\n \t\t\tif err1 = c.pollServer.WaitWrite(c); err1 == nil {\n \t\t\t\tcontinue\n \t\t\t}"}, {"sha": "3357e653869a59b4860c101c5b0dd32772912d0a", "filename": "libgo/go/net/sendfile_linux.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_linux.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -58,7 +58,7 @@ func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool) {\n \t\tif n == 0 && err1 == nil {\n \t\t\tbreak\n \t\t}\n-\t\tif err1 == syscall.EAGAIN && c.wdeadline >= 0 {\n+\t\tif err1 == syscall.EAGAIN {\n \t\t\tif err1 = c.pollServer.WaitWrite(c); err1 == nil {\n \t\t\t\tcontinue\n \t\t\t}"}, {"sha": "12015ef0acdf4861d3b7a9da1f40b6bc5005d556", "filename": "libgo/go/net/sock_posix.go", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_posix.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -9,7 +9,6 @@\n package net\n \n import (\n-\t\"io\"\n \t\"syscall\"\n \t\"time\"\n )\n@@ -57,16 +56,13 @@ func socket(net string, f, t, p int, ipv6only bool, ulsa, ursa syscall.Sockaddr,\n \t}\n \n \tif ursa != nil {\n-\t\tif !deadline.IsZero() {\n-\t\t\tfd.wdeadline = deadline.UnixNano()\n-\t\t}\n+\t\tfd.wdeadline.setTime(deadline)\n \t\tif err = fd.connect(ursa); err != nil {\n \t\t\tclosesocket(s)\n-\t\t\tfd.Close()\n \t\t\treturn nil, err\n \t\t}\n \t\tfd.isConnected = true\n-\t\tfd.wdeadline = 0\n+\t\tfd.wdeadline.set(0)\n \t}\n \n \tlsa, _ := syscall.Getsockname(s)\n@@ -76,14 +72,3 @@ func socket(net string, f, t, p int, ipv6only bool, ulsa, ursa syscall.Sockaddr,\n \tfd.setAddr(laddr, raddr)\n \treturn fd, nil\n }\n-\n-type writerOnly struct {\n-\tio.Writer\n-}\n-\n-// Fallback implementation of io.ReaderFrom's ReadFrom, when sendfile isn't\n-// applicable.\n-func genericReadFrom(w io.Writer, r io.Reader) (n int64, err error) {\n-\t// Use wrapper to hide existing r.ReadFrom from io.Copy.\n-\treturn io.Copy(writerOnly{w}, r)\n-}"}, {"sha": "fe371fe0cefc4f300514603b36f5672c8636fff1", "filename": "libgo/go/net/sockopt_posix.go", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fsockopt_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fsockopt_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_posix.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -119,29 +119,22 @@ func setWriteBuffer(fd *netFD, bytes int) error {\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes))\n }\n \n+// TODO(dfc) these unused error returns could be removed\n+\n func setReadDeadline(fd *netFD, t time.Time) error {\n-\tif t.IsZero() {\n-\t\tfd.rdeadline = 0\n-\t} else {\n-\t\tfd.rdeadline = t.UnixNano()\n-\t}\n+\tfd.rdeadline.setTime(t)\n \treturn nil\n }\n \n func setWriteDeadline(fd *netFD, t time.Time) error {\n-\tif t.IsZero() {\n-\t\tfd.wdeadline = 0\n-\t} else {\n-\t\tfd.wdeadline = t.UnixNano()\n-\t}\n+\tfd.wdeadline.setTime(t)\n \treturn nil\n }\n \n func setDeadline(fd *netFD, t time.Time) error {\n-\tif err := setReadDeadline(fd, t); err != nil {\n-\t\treturn err\n-\t}\n-\treturn setWriteDeadline(fd, t)\n+\tsetReadDeadline(fd, t)\n+\tsetWriteDeadline(fd, t)\n+\treturn nil\n }\n \n func setKeepAlive(fd *netFD, keepalive bool) error {"}, {"sha": "bca748827ce1226409289cb7bf3a5be59f3399a4", "filename": "libgo/go/net/tcp_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftcp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftcp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcp_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -5,6 +5,7 @@\n package net\n \n import (\n+\t\"reflect\"\n \t\"runtime\"\n \t\"testing\"\n \t\"time\"\n@@ -117,6 +118,36 @@ func benchmarkTCP(b *testing.B, persistent, timeout bool) {\n \t}\n }\n \n+var resolveTCPAddrTests = []struct {\n+\tnet     string\n+\tlitAddr string\n+\taddr    *TCPAddr\n+\terr     error\n+}{\n+\t{\"tcp\", \"127.0.0.1:0\", &TCPAddr{IP: IPv4(127, 0, 0, 1), Port: 0}, nil},\n+\t{\"tcp4\", \"127.0.0.1:65535\", &TCPAddr{IP: IPv4(127, 0, 0, 1), Port: 65535}, nil},\n+\n+\t{\"tcp\", \"[::1]:1\", &TCPAddr{IP: ParseIP(\"::1\"), Port: 1}, nil},\n+\t{\"tcp6\", \"[::1]:65534\", &TCPAddr{IP: ParseIP(\"::1\"), Port: 65534}, nil},\n+\n+\t{\"\", \"127.0.0.1:0\", &TCPAddr{IP: IPv4(127, 0, 0, 1), Port: 0}, nil}, // Go 1.0 behavior\n+\t{\"\", \"[::1]:0\", &TCPAddr{IP: ParseIP(\"::1\"), Port: 0}, nil},         // Go 1.0 behavior\n+\n+\t{\"http\", \"127.0.0.1:0\", nil, UnknownNetworkError(\"http\")},\n+}\n+\n+func TestResolveTCPAddr(t *testing.T) {\n+\tfor _, tt := range resolveTCPAddrTests {\n+\t\taddr, err := ResolveTCPAddr(tt.net, tt.litAddr)\n+\t\tif err != tt.err {\n+\t\t\tt.Fatalf(\"ResolveTCPAddr(%v, %v) failed: %v\", tt.net, tt.litAddr, err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(addr, tt.addr) {\n+\t\t\tt.Fatalf(\"got %#v; expected %#v\", addr, tt.addr)\n+\t\t}\n+\t}\n+}\n+\n var tcpListenerNameTests = []struct {\n \tnet   string\n \tladdr *TCPAddr"}, {"sha": "d5158b22def5c00e5e199882b1013c213bbf6141", "filename": "libgo/go/net/tcpsock.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftcpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftcpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -6,12 +6,11 @@\n \n package net\n \n-import \"time\"\n-\n // TCPAddr represents the address of a TCP end point.\n type TCPAddr struct {\n \tIP   IP\n \tPort int\n+\tZone string // IPv6 scoped addressing zone\n }\n \n // Network returns the address's network name, \"tcp\".\n@@ -30,13 +29,16 @@ func (a *TCPAddr) String() string {\n // \"tcp4\" or \"tcp6\".  A literal IPv6 host address must be\n // enclosed in square brackets, as in \"[::]:80\".\n func ResolveTCPAddr(net, addr string) (*TCPAddr, error) {\n-\treturn resolveTCPAddr(net, addr, noDeadline)\n-}\n-\n-func resolveTCPAddr(net, addr string, deadline time.Time) (*TCPAddr, error) {\n-\tip, port, err := hostPortToIP(net, addr, deadline)\n+\tswitch net {\n+\tcase \"tcp\", \"tcp4\", \"tcp6\":\n+\tcase \"\": // a hint wildcard for Go 1.0 undocumented behavior\n+\t\tnet = \"tcp\"\n+\tdefault:\n+\t\treturn nil, UnknownNetworkError(net)\n+\t}\n+\ta, err := resolveInternetAddr(net, addr, noDeadline)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn &TCPAddr{ip, port}, nil\n+\treturn a.(*TCPAddr), nil\n }"}, {"sha": "954c99a2d8191347f0adee34d07dd5e8822cdbbf", "filename": "libgo/go/net/tcpsock_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -25,7 +25,7 @@ func newTCPConn(fd *netFD) *TCPConn {\n \n // ReadFrom implements the io.ReaderFrom ReadFrom method.\n func (c *TCPConn) ReadFrom(r io.Reader) (int64, error) {\n-\treturn 0, syscall.EPLAN9\n+\treturn genericReadFrom(c, r)\n }\n \n // CloseRead shuts down the reading side of the TCP connection.\n@@ -78,7 +78,7 @@ func (c *TCPConn) SetNoDelay(noDelay bool) error {\n // DialTCP connects to the remote address raddr on the network net,\n // which must be \"tcp\", \"tcp4\", or \"tcp6\".  If laddr is not nil, it is\n // used as the local address for the connection.\n-func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err error) {\n+func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) {\n \treturn dialTCP(net, laddr, raddr, noDeadline)\n }\n "}, {"sha": "4f9159566f3a4f83785680f01ff8a1a0f16c4e6f", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -23,9 +23,9 @@ import (\n func sockaddrToTCP(sa syscall.Sockaddr) Addr {\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrInet4:\n-\t\treturn &TCPAddr{sa.Addr[0:], sa.Port}\n+\t\treturn &TCPAddr{IP: sa.Addr[0:], Port: sa.Port}\n \tcase *syscall.SockaddrInet6:\n-\t\treturn &TCPAddr{sa.Addr[0:], sa.Port}\n+\t\treturn &TCPAddr{IP: sa.Addr[0:], Port: sa.Port, Zone: zoneToString(int(sa.ZoneId))}\n \tdefault:\n \t\tif sa != nil {\n \t\t\t// Diagnose when we will turn a non-nil sockaddr into a nil.\n@@ -53,7 +53,7 @@ func (a *TCPAddr) isWildcard() bool {\n }\n \n func (a *TCPAddr) sockaddr(family int) (syscall.Sockaddr, error) {\n-\treturn ipToSockaddr(family, a.IP, a.Port)\n+\treturn ipToSockaddr(family, a.IP, a.Port, a.Zone)\n }\n \n func (a *TCPAddr) toAddr() sockaddr {\n@@ -299,7 +299,5 @@ func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error) {\n \t\tclosesocket(fd.sysfd)\n \t\treturn nil, &OpError{\"listen\", net, laddr, err}\n \t}\n-\tl := new(TCPListener)\n-\tl.fd = fd\n-\treturn l, nil\n+\treturn &TCPListener{fd}, nil\n }"}, {"sha": "21223cc74ad6fa477183d1321ecf47bc90113625", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 390, "deletions": 1, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -6,11 +6,169 @@ package net\n \n import (\n \t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n \t\"runtime\"\n \t\"testing\"\n \t\"time\"\n )\n \n+func isTimeout(err error) bool {\n+\te, ok := err.(Error)\n+\treturn ok && e.Timeout()\n+}\n+\n+type copyRes struct {\n+\tn   int64\n+\terr error\n+\td   time.Duration\n+}\n+\n+func TestAcceptTimeout(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\tln := newLocalListener(t).(*TCPListener)\n+\tdefer ln.Close()\n+\tln.SetDeadline(time.Now().Add(-1 * time.Second))\n+\tif _, err := ln.Accept(); !isTimeout(err) {\n+\t\tt.Fatalf(\"Accept: expected err %v, got %v\", errTimeout, err)\n+\t}\n+\tif _, err := ln.Accept(); !isTimeout(err) {\n+\t\tt.Fatalf(\"Accept: expected err %v, got %v\", errTimeout, err)\n+\t}\n+\tln.SetDeadline(time.Now().Add(100 * time.Millisecond))\n+\tif _, err := ln.Accept(); !isTimeout(err) {\n+\t\tt.Fatalf(\"Accept: expected err %v, got %v\", errTimeout, err)\n+\t}\n+\tif _, err := ln.Accept(); !isTimeout(err) {\n+\t\tt.Fatalf(\"Accept: expected err %v, got %v\", errTimeout, err)\n+\t}\n+\tln.SetDeadline(noDeadline)\n+\terrc := make(chan error)\n+\tgo func() {\n+\t\t_, err := ln.Accept()\n+\t\terrc <- err\n+\t}()\n+\ttime.Sleep(100 * time.Millisecond)\n+\tselect {\n+\tcase err := <-errc:\n+\t\tt.Fatalf(\"Expected Accept() to not return, but it returned with %v\\n\", err)\n+\tdefault:\n+\t}\n+\tln.Close()\n+\tif err := <-errc; err.(*OpError).Err != errClosing {\n+\t\tt.Fatalf(\"Accept: expected err %v, got %v\", errClosing, err.(*OpError).Err)\n+\t}\n+}\n+\n+func TestReadTimeout(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\tc, err := DialTCP(\"tcp\", nil, ln.Addr().(*TCPAddr))\n+\tif err != nil {\n+\t\tt.Fatalf(\"Connect: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\tc.SetDeadline(time.Now().Add(time.Hour))\n+\tc.SetReadDeadline(time.Now().Add(-1 * time.Second))\n+\tbuf := make([]byte, 1)\n+\tif _, err = c.Read(buf); !isTimeout(err) {\n+\t\tt.Fatalf(\"Read: expected err %v, got %v\", errTimeout, err)\n+\t}\n+\tif _, err = c.Read(buf); !isTimeout(err) {\n+\t\tt.Fatalf(\"Read: expected err %v, got %v\", errTimeout, err)\n+\t}\n+\tc.SetDeadline(time.Now().Add(100 * time.Millisecond))\n+\tif _, err = c.Read(buf); !isTimeout(err) {\n+\t\tt.Fatalf(\"Read: expected err %v, got %v\", errTimeout, err)\n+\t}\n+\tif _, err = c.Read(buf); !isTimeout(err) {\n+\t\tt.Fatalf(\"Read: expected err %v, got %v\", errTimeout, err)\n+\t}\n+\tc.SetReadDeadline(noDeadline)\n+\tc.SetWriteDeadline(time.Now().Add(-1 * time.Second))\n+\terrc := make(chan error)\n+\tgo func() {\n+\t\t_, err := c.Read(buf)\n+\t\terrc <- err\n+\t}()\n+\ttime.Sleep(100 * time.Millisecond)\n+\tselect {\n+\tcase err := <-errc:\n+\t\tt.Fatalf(\"Expected Read() to not return, but it returned with %v\\n\", err)\n+\tdefault:\n+\t}\n+\tc.Close()\n+\tif err := <-errc; err.(*OpError).Err != errClosing {\n+\t\tt.Fatalf(\"Read: expected err %v, got %v\", errClosing, err.(*OpError).Err)\n+\t}\n+}\n+\n+func TestWriteTimeout(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\tc, err := DialTCP(\"tcp\", nil, ln.Addr().(*TCPAddr))\n+\tif err != nil {\n+\t\tt.Fatalf(\"Connect: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\tc.SetDeadline(time.Now().Add(time.Hour))\n+\tc.SetWriteDeadline(time.Now().Add(-1 * time.Second))\n+\tbuf := make([]byte, 4096)\n+\twriteUntilTimeout := func() {\n+\t\tfor {\n+\t\t\t_, err := c.Write(buf)\n+\t\t\tif err != nil {\n+\t\t\t\tif isTimeout(err) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tt.Fatalf(\"Write: expected err %v, got %v\", errTimeout, err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\twriteUntilTimeout()\n+\tc.SetDeadline(time.Now().Add(10 * time.Millisecond))\n+\twriteUntilTimeout()\n+\twriteUntilTimeout()\n+\tc.SetWriteDeadline(noDeadline)\n+\tc.SetReadDeadline(time.Now().Add(-1 * time.Second))\n+\terrc := make(chan error)\n+\tgo func() {\n+\t\tfor {\n+\t\t\t_, err := c.Write(buf)\n+\t\t\tif err != nil {\n+\t\t\t\terrc <- err\n+\t\t\t}\n+\t\t}\n+\t}()\n+\ttime.Sleep(100 * time.Millisecond)\n+\tselect {\n+\tcase err := <-errc:\n+\t\tt.Fatalf(\"Expected Write() to not return, but it returned with %v\\n\", err)\n+\tdefault:\n+\t}\n+\tc.Close()\n+\tif err := <-errc; err.(*OpError).Err != errClosing {\n+\t\tt.Fatalf(\"Write: expected err %v, got %v\", errClosing, err.(*OpError).Err)\n+\t}\n+}\n+\n func testTimeout(t *testing.T, net, addr string, readFrom bool) {\n \tc, err := Dial(net, addr)\n \tif err != nil {\n@@ -104,7 +262,7 @@ func TestDeadlineReset(t *testing.T) {\n \tdefer ln.Close()\n \ttl := ln.(*TCPListener)\n \ttl.SetDeadline(time.Now().Add(1 * time.Minute))\n-\ttl.SetDeadline(time.Time{}) // reset it\n+\ttl.SetDeadline(noDeadline) // reset it\n \terrc := make(chan error, 1)\n \tgo func() {\n \t\t_, err := ln.Accept()\n@@ -174,6 +332,7 @@ func TestReadWriteDeadline(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"ListenTCP on :0: %v\", err)\n \t}\n+\tdefer ln.Close()\n \n \tlnquit := make(chan bool)\n \n@@ -230,3 +389,233 @@ func TestReadWriteDeadline(t *testing.T) {\n \t<-quit\n \t<-lnquit\n }\n+\n+type neverEnding byte\n+\n+func (b neverEnding) Read(p []byte) (n int, err error) {\n+\tfor i := range p {\n+\t\tp[i] = byte(b)\n+\t}\n+\treturn len(p), nil\n+}\n+\n+func TestVariousDeadlines1Proc(t *testing.T) {\n+\ttestVariousDeadlines(t, 1)\n+}\n+\n+func TestVariousDeadlines4Proc(t *testing.T) {\n+\ttestVariousDeadlines(t, 4)\n+}\n+\n+func testVariousDeadlines(t *testing.T, maxProcs int) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(maxProcs))\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\tacceptc := make(chan error, 1)\n+\n+\t// The server, with no timeouts of its own, sending bytes to clients\n+\t// as fast as it can.\n+\tservec := make(chan copyRes)\n+\tgo func() {\n+\t\tfor {\n+\t\t\tc, err := ln.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\tacceptc <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgo func() {\n+\t\t\t\tt0 := time.Now()\n+\t\t\t\tn, err := io.Copy(c, neverEnding('a'))\n+\t\t\t\td := time.Since(t0)\n+\t\t\t\tc.Close()\n+\t\t\t\tservec <- copyRes{n, err, d}\n+\t\t\t}()\n+\t\t}\n+\t}()\n+\n+\tfor _, timeout := range []time.Duration{\n+\t\t1 * time.Nanosecond,\n+\t\t2 * time.Nanosecond,\n+\t\t5 * time.Nanosecond,\n+\t\t50 * time.Nanosecond,\n+\t\t100 * time.Nanosecond,\n+\t\t200 * time.Nanosecond,\n+\t\t500 * time.Nanosecond,\n+\t\t750 * time.Nanosecond,\n+\t\t1 * time.Microsecond,\n+\t\t5 * time.Microsecond,\n+\t\t25 * time.Microsecond,\n+\t\t250 * time.Microsecond,\n+\t\t500 * time.Microsecond,\n+\t\t1 * time.Millisecond,\n+\t\t5 * time.Millisecond,\n+\t\t100 * time.Millisecond,\n+\t\t250 * time.Millisecond,\n+\t\t500 * time.Millisecond,\n+\t\t1 * time.Second,\n+\t} {\n+\t\tnumRuns := 3\n+\t\tif testing.Short() {\n+\t\t\tnumRuns = 1\n+\t\t\tif timeout > 500*time.Microsecond {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tfor run := 0; run < numRuns; run++ {\n+\t\t\tname := fmt.Sprintf(\"%v run %d/%d\", timeout, run+1, numRuns)\n+\t\t\tt.Log(name)\n+\n+\t\t\tc, err := Dial(\"tcp\", ln.Addr().String())\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"Dial: %v\", err)\n+\t\t\t}\n+\t\t\tclientc := make(chan copyRes)\n+\t\t\tgo func() {\n+\t\t\t\tt0 := time.Now()\n+\t\t\t\tc.SetDeadline(t0.Add(timeout))\n+\t\t\t\tn, err := io.Copy(ioutil.Discard, c)\n+\t\t\t\td := time.Since(t0)\n+\t\t\t\tc.Close()\n+\t\t\t\tclientc <- copyRes{n, err, d}\n+\t\t\t}()\n+\n+\t\t\tconst tooLong = 2000 * time.Millisecond\n+\t\t\tselect {\n+\t\t\tcase res := <-clientc:\n+\t\t\t\tif isTimeout(res.err) {\n+\t\t\t\t\tt.Logf(\"for %v, good client timeout after %v, reading %d bytes\", name, res.d, res.n)\n+\t\t\t\t} else {\n+\t\t\t\t\tt.Fatalf(\"for %v: client Copy = %d, %v (want timeout)\", name, res.n, res.err)\n+\t\t\t\t}\n+\t\t\tcase <-time.After(tooLong):\n+\t\t\t\tt.Fatalf(\"for %v: timeout (%v) waiting for client to timeout (%v) reading\", name, tooLong, timeout)\n+\t\t\t}\n+\n+\t\t\tselect {\n+\t\t\tcase res := <-servec:\n+\t\t\t\tt.Logf(\"for %v: server in %v wrote %d, %v\", name, res.d, res.n, res.err)\n+\t\t\tcase err := <-acceptc:\n+\t\t\t\tt.Fatalf(\"for %v: server Accept = %v\", name, err)\n+\t\t\tcase <-time.After(tooLong):\n+\t\t\t\tt.Fatalf(\"for %v, timeout waiting for server to finish writing\", name)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// TestReadDeadlineDataAvailable tests that read deadlines work, even\n+// if there's data ready to be read.\n+func TestReadDeadlineDataAvailable(t *testing.T) {\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\n+\tservec := make(chan copyRes)\n+\tconst msg = \"data client shouldn't read, even though it it'll be waiting\"\n+\tgo func() {\n+\t\tc, err := ln.Accept()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Accept: %v\", err)\n+\t\t}\n+\t\tdefer c.Close()\n+\t\tn, err := c.Write([]byte(msg))\n+\t\tservec <- copyRes{n: int64(n), err: err}\n+\t}()\n+\n+\tc, err := Dial(\"tcp\", ln.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatalf(\"Dial: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\tif res := <-servec; res.err != nil || res.n != int64(len(msg)) {\n+\t\tt.Fatalf(\"unexpected server Write: n=%d, err=%d; want n=%d, err=nil\", res.n, res.err, len(msg))\n+\t}\n+\tc.SetReadDeadline(time.Now().Add(-5 * time.Second)) // in the psat.\n+\tbuf := make([]byte, len(msg)/2)\n+\tn, err := c.Read(buf)\n+\tif n > 0 || !isTimeout(err) {\n+\t\tt.Fatalf(\"client read = %d (%q) err=%v; want 0, timeout\", n, buf[:n], err)\n+\t}\n+}\n+\n+// TestWriteDeadlineBufferAvailable tests that write deadlines work, even\n+// if there's buffer space available to write.\n+func TestWriteDeadlineBufferAvailable(t *testing.T) {\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\n+\tservec := make(chan copyRes)\n+\tgo func() {\n+\t\tc, err := ln.Accept()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Accept: %v\", err)\n+\t\t}\n+\t\tdefer c.Close()\n+\t\tc.SetWriteDeadline(time.Now().Add(-5 * time.Second)) // in the past\n+\t\tn, err := c.Write([]byte{'x'})\n+\t\tservec <- copyRes{n: int64(n), err: err}\n+\t}()\n+\n+\tc, err := Dial(\"tcp\", ln.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatalf(\"Dial: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\tres := <-servec\n+\tif res.n != 0 {\n+\t\tt.Errorf(\"Write = %d; want 0\", res.n)\n+\t}\n+\tif !isTimeout(res.err) {\n+\t\tt.Errorf(\"Write error = %v; want timeout\", res.err)\n+\t}\n+}\n+\n+// TestProlongTimeout tests concurrent deadline modification.\n+// Known to cause data races in the past.\n+func TestProlongTimeout(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\tconnected := make(chan bool)\n+\tgo func() {\n+\t\ts, err := ln.Accept()\n+\t\tconnected <- true\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"ln.Accept: %v\", err)\n+\t\t}\n+\t\tdefer s.Close()\n+\t\ts.SetDeadline(time.Now().Add(time.Hour))\n+\t\tgo func() {\n+\t\t\tvar buf [4096]byte\n+\t\t\tfor {\n+\t\t\t\t_, err := s.Write(buf[:])\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\ts.SetDeadline(time.Now().Add(time.Hour))\n+\t\t\t}\n+\t\t}()\n+\t\tbuf := make([]byte, 1)\n+\t\tfor {\n+\t\t\t_, err := s.Read(buf)\n+\t\t\tif err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\ts.SetDeadline(time.Now().Add(time.Hour))\n+\t\t}\n+\t}()\n+\tc, err := Dial(\"tcp\", ln.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatalf(\"DialTCP: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\t<-connected\n+\tfor i := 0; i < 1024; i++ {\n+\t\tvar buf [1]byte\n+\t\tc.Write(buf[:])\n+\t}\n+}"}, {"sha": "d3594b40a9e25e720b3c0ded562283ff412aac2c", "filename": "libgo/go/net/udp_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fudp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fudp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudp_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -5,10 +5,41 @@\n package net\n \n import (\n+\t\"reflect\"\n \t\"runtime\"\n \t\"testing\"\n )\n \n+var resolveUDPAddrTests = []struct {\n+\tnet     string\n+\tlitAddr string\n+\taddr    *UDPAddr\n+\terr     error\n+}{\n+\t{\"udp\", \"127.0.0.1:0\", &UDPAddr{IP: IPv4(127, 0, 0, 1), Port: 0}, nil},\n+\t{\"udp4\", \"127.0.0.1:65535\", &UDPAddr{IP: IPv4(127, 0, 0, 1), Port: 65535}, nil},\n+\n+\t{\"udp\", \"[::1]:1\", &UDPAddr{IP: ParseIP(\"::1\"), Port: 1}, nil},\n+\t{\"udp6\", \"[::1]:65534\", &UDPAddr{IP: ParseIP(\"::1\"), Port: 65534}, nil},\n+\n+\t{\"\", \"127.0.0.1:0\", &UDPAddr{IP: IPv4(127, 0, 0, 1), Port: 0}, nil}, // Go 1.0 behavior\n+\t{\"\", \"[::1]:0\", &UDPAddr{IP: ParseIP(\"::1\"), Port: 0}, nil},         // Go 1.0 behavior\n+\n+\t{\"sip\", \"127.0.0.1:0\", nil, UnknownNetworkError(\"sip\")},\n+}\n+\n+func TestResolveUDPAddr(t *testing.T) {\n+\tfor _, tt := range resolveUDPAddrTests {\n+\t\taddr, err := ResolveUDPAddr(tt.net, tt.litAddr)\n+\t\tif err != tt.err {\n+\t\t\tt.Fatalf(\"ResolveUDPAddr(%v, %v) failed: %v\", tt.net, tt.litAddr, err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(addr, tt.addr) {\n+\t\t\tt.Fatalf(\"got %#v; expected %#v\", addr, tt.addr)\n+\t\t}\n+\t}\n+}\n+\n func TestWriteToUDP(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\":"}, {"sha": "6e5e902689b39a41f170c9fcbd2b2b11c40120d5", "filename": "libgo/go/net/udpsock.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fudpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fudpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -6,17 +6,15 @@\n \n package net\n \n-import (\n-\t\"errors\"\n-\t\"time\"\n-)\n+import \"errors\"\n \n var ErrWriteToConnected = errors.New(\"use of WriteTo with pre-connected UDP\")\n \n // UDPAddr represents the address of a UDP end point.\n type UDPAddr struct {\n \tIP   IP\n \tPort int\n+\tZone string // IPv6 scoped addressing zone\n }\n \n // Network returns the address's network name, \"udp\".\n@@ -35,13 +33,16 @@ func (a *UDPAddr) String() string {\n // \"udp4\" or \"udp6\".  A literal IPv6 host address must be\n // enclosed in square brackets, as in \"[::]:80\".\n func ResolveUDPAddr(net, addr string) (*UDPAddr, error) {\n-\treturn resolveUDPAddr(net, addr, noDeadline)\n-}\n-\n-func resolveUDPAddr(net, addr string, deadline time.Time) (*UDPAddr, error) {\n-\tip, port, err := hostPortToIP(net, addr, deadline)\n+\tswitch net {\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\tcase \"\": // a hint wildcard for Go 1.0 undocumented behavior\n+\t\tnet = \"udp\"\n+\tdefault:\n+\t\treturn nil, UnknownNetworkError(net)\n+\t}\n+\ta, err := resolveInternetAddr(net, addr, noDeadline)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn &UDPAddr{ip, port}, nil\n+\treturn a.(*UDPAddr), nil\n }"}, {"sha": "b9ade48bec97065fdb932b8c1f4205dc0023585d", "filename": "libgo/go/net/udpsock_plan9.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -19,8 +19,6 @@ type UDPConn struct {\n \tconn\n }\n \n-// UDP-specific methods.\n-\n // ReadFromUDP reads a UDP packet from c, copying the payload into b.\n // It returns the number of bytes copied into b and the return address\n // that was on the packet.\n@@ -50,11 +48,11 @@ func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n \n \th, buf := unmarshalUDPHeader(buf)\n \tn = copy(b, buf)\n-\treturn n, &UDPAddr{h.raddr, int(h.rport)}, nil\n+\treturn n, &UDPAddr{IP: h.raddr, Port: int(h.rport)}, nil\n }\n \n // ReadFrom implements the PacketConn ReadFrom method.\n-func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n+func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error) {\n \tif !c.ok() {\n \t\treturn 0, nil, syscall.EINVAL\n \t}\n@@ -77,15 +75,16 @@ func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr,\n // Timeout() == true after a fixed time limit; see SetDeadline and\n // SetWriteDeadline.  On packet-oriented connections, write timeouts\n // are rare.\n-func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err error) {\n+func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error) {\n \tif !c.ok() {\n \t\treturn 0, syscall.EINVAL\n \t}\n \tif c.fd.data == nil {\n-\t\tc.fd.data, err = os.OpenFile(c.fd.dir+\"/data\", os.O_RDWR, 0)\n+\t\tf, err := os.OpenFile(c.fd.dir+\"/data\", os.O_RDWR, 0)\n \t\tif err != nil {\n \t\t\treturn 0, err\n \t\t}\n+\t\tc.fd.data = f\n \t}\n \th := new(udpHeader)\n \th.raddr = addr.IP.To16()\n@@ -101,7 +100,7 @@ func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err error) {\n }\n \n // WriteTo implements the PacketConn WriteTo method.\n-func (c *UDPConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n+func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error) {\n \tif !c.ok() {\n \t\treturn 0, syscall.EINVAL\n \t}\n@@ -122,7 +121,7 @@ func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err er\n // DialUDP connects to the remote address raddr on the network net,\n // which must be \"udp\", \"udp4\", or \"udp6\".  If laddr is not nil, it is\n // used as the local address for the connection.\n-func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error) {\n+func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error) {\n \treturn dialUDP(net, laddr, raddr, noDeadline)\n }\n "}, {"sha": "b7de678f928c979b58940edb4e598b8a18d5f7f6", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -4,7 +4,7 @@\n \n // +build darwin freebsd linux netbsd openbsd windows\n \n-// UDP sockets\n+// UDP sockets for POSIX\n \n package net\n \n@@ -16,9 +16,9 @@ import (\n func sockaddrToUDP(sa syscall.Sockaddr) Addr {\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrInet4:\n-\t\treturn &UDPAddr{sa.Addr[0:], sa.Port}\n+\t\treturn &UDPAddr{IP: sa.Addr[0:], Port: sa.Port}\n \tcase *syscall.SockaddrInet6:\n-\t\treturn &UDPAddr{sa.Addr[0:], sa.Port}\n+\t\treturn &UDPAddr{IP: sa.Addr[0:], Port: sa.Port, Zone: zoneToString(int(sa.ZoneId))}\n \t}\n \treturn nil\n }\n@@ -41,7 +41,7 @@ func (a *UDPAddr) isWildcard() bool {\n }\n \n func (a *UDPAddr) sockaddr(family int) (syscall.Sockaddr, error) {\n-\treturn ipToSockaddr(family, a.IP, a.Port)\n+\treturn ipToSockaddr(family, a.IP, a.Port, a.Zone)\n }\n \n func (a *UDPAddr) toAddr() sockaddr {\n@@ -59,8 +59,6 @@ type UDPConn struct {\n \n func newUDPConn(fd *netFD) *UDPConn { return &UDPConn{conn{fd}} }\n \n-// UDP-specific methods.\n-\n // ReadFromUDP reads a UDP packet from c, copying the payload into b.\n // It returns the number of bytes copied into b and the return address\n // that was on the packet.\n@@ -74,9 +72,9 @@ func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n \tn, sa, err := c.fd.ReadFrom(b)\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrInet4:\n-\t\taddr = &UDPAddr{sa.Addr[0:], sa.Port}\n+\t\taddr = &UDPAddr{IP: sa.Addr[0:], Port: sa.Port}\n \tcase *syscall.SockaddrInet6:\n-\t\taddr = &UDPAddr{sa.Addr[0:], sa.Port}\n+\t\taddr = &UDPAddr{IP: sa.Addr[0:], Port: sa.Port, Zone: zoneToString(int(sa.ZoneId))}\n \t}\n \treturn\n }\n@@ -86,8 +84,8 @@ func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error) {\n \tif !c.ok() {\n \t\treturn 0, nil, syscall.EINVAL\n \t}\n-\tn, uaddr, err := c.ReadFromUDP(b)\n-\treturn n, uaddr.toAddr(), err\n+\tn, addr, err := c.ReadFromUDP(b)\n+\treturn n, addr.toAddr(), err\n }\n \n // ReadMsgUDP reads a packet from c, copying the payload into b and\n@@ -103,9 +101,9 @@ func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr,\n \tn, oobn, flags, sa, err = c.fd.ReadMsg(b, oob)\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrInet4:\n-\t\taddr = &UDPAddr{sa.Addr[0:], sa.Port}\n+\t\taddr = &UDPAddr{IP: sa.Addr[0:], Port: sa.Port}\n \tcase *syscall.SockaddrInet6:\n-\t\taddr = &UDPAddr{sa.Addr[0:], sa.Port}\n+\t\taddr = &UDPAddr{IP: sa.Addr[0:], Port: sa.Port, Zone: zoneToString(int(sa.ZoneId))}\n \t}\n \treturn\n }\n@@ -276,15 +274,15 @@ func listenIPv6MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error {\n func joinIPv4GroupUDP(c *UDPConn, ifi *Interface, ip IP) error {\n \terr := joinIPv4Group(c.fd, ifi, ip)\n \tif err != nil {\n-\t\treturn &OpError{\"joinipv4group\", c.fd.net, &IPAddr{ip}, err}\n+\t\treturn &OpError{\"joinipv4group\", c.fd.net, &IPAddr{IP: ip}, err}\n \t}\n \treturn nil\n }\n \n func joinIPv6GroupUDP(c *UDPConn, ifi *Interface, ip IP) error {\n \terr := joinIPv6Group(c.fd, ifi, ip)\n \tif err != nil {\n-\t\treturn &OpError{\"joinipv6group\", c.fd.net, &IPAddr{ip}, err}\n+\t\treturn &OpError{\"joinipv6group\", c.fd.net, &IPAddr{IP: ip}, err}\n \t}\n \treturn nil\n }"}, {"sha": "f7be5d2e9ae0f5c4d45b3138ecaacd9c08d3a2ad", "filename": "libgo/go/net/unixsock_plan9.go", "status": "modified", "additions": 3, "deletions": 62, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -14,67 +14,8 @@ import (\n \n // UnixConn is an implementation of the Conn interface for connections\n // to Unix domain sockets.\n-type UnixConn bool\n-\n-// Implementation of the Conn interface - see Conn for documentation.\n-\n-// Read implements the Conn Read method.\n-func (c *UnixConn) Read(b []byte) (int, error) {\n-\treturn 0, syscall.EPLAN9\n-}\n-\n-// Write implements the Conn Write method.\n-func (c *UnixConn) Write(b []byte) (int, error) {\n-\treturn 0, syscall.EPLAN9\n-}\n-\n-// LocalAddr returns the local network address.\n-func (c *UnixConn) LocalAddr() Addr {\n-\treturn nil\n-}\n-\n-// RemoteAddr returns the remote network address.\n-func (c *UnixConn) RemoteAddr() Addr {\n-\treturn nil\n-}\n-\n-// SetDeadline implements the Conn SetDeadline method.\n-func (c *UnixConn) SetDeadline(t time.Time) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// SetReadDeadline implements the Conn SetReadDeadline method.\n-func (c *UnixConn) SetReadDeadline(t time.Time) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// SetWriteDeadline implements the Conn SetWriteDeadline method.\n-func (c *UnixConn) SetWriteDeadline(t time.Time) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// SetReadBuffer sets the size of the operating system's receive\n-// buffer associated with the connection.\n-func (c *UnixConn) SetReadBuffer(bytes int) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// SetWriteBuffer sets the size of the operating system's transmit\n-// buffer associated with the connection.\n-func (c *UnixConn) SetWriteBuffer(bytes int) error {\n-\treturn syscall.EPLAN9\n-}\n-\n-// File returns a copy of the underlying os.File, set to blocking\n-// mode.  It is the caller's responsibility to close f when finished.\n-// Closing c does not affect f, and closing f does not affect c.\n-func (c *UnixConn) File() (f *os.File, err error) {\n-\treturn nil, syscall.EPLAN9\n-}\n-\n-// Close closes the Unix domain connection.\n-func (c *UnixConn) Close() error {\n-\treturn syscall.EPLAN9\n+type UnixConn struct {\n+\tconn\n }\n \n // ReadFromUnix reads a packet from c, copying the payload into b.  It\n@@ -149,7 +90,7 @@ func dialUnix(net string, laddr, raddr *UnixAddr, deadline time.Time) (*UnixConn\n // UnixListener is a Unix domain socket listener.  Clients should\n // typically use variables of type Listener instead of assuming Unix\n // domain sockets.\n-type UnixListener bool\n+type UnixListener struct{}\n \n // ListenUnix announces on the Unix domain socket laddr and returns a\n // Unix listener.  Net must be \"unix\" (stream sockets)."}, {"sha": "692a7fdc0484702f579f5c1f123705d751633e97", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -224,7 +224,7 @@ type URL struct {\n \tScheme   string\n \tOpaque   string    // encoded opaque data\n \tUser     *Userinfo // username and password information\n-\tHost     string\n+\tHost     string    // host or host:port\n \tPath     string\n \tRawQuery string // encoded query values, without '?'\n \tFragment string // fragment for references, without '#'"}, {"sha": "8195c02a4659e864bde357a746b0ce77849aadd3", "filename": "libgo/go/os/dir_plan9.go", "status": "modified", "additions": 28, "deletions": 231, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fdir_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fdir_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -5,15 +5,11 @@\n package os\n \n import (\n-\t\"errors\"\n \t\"io\"\n \t\"syscall\"\n )\n \n-var errShortStat = errors.New(\"short stat message\")\n-var errBadStat = errors.New(\"bad stat message format\")\n-\n-func (file *File) readdir(n int) (fi []FileInfo, err error) {\n+func (file *File) readdir(n int) ([]FileInfo, error) {\n \t// If this file has no dirinfo, create one.\n \tif file.dirinfo == nil {\n \t\tfile.dirinfo = new(dirInfo)\n@@ -24,44 +20,47 @@ func (file *File) readdir(n int) (fi []FileInfo, err error) {\n \t\tsize = 100\n \t\tn = -1\n \t}\n-\tresult := make([]FileInfo, 0, size) // Empty with room to grow.\n+\tfi := make([]FileInfo, 0, size) // Empty with room to grow.\n \tfor n != 0 {\n-\t\t// Refill the buffer if necessary\n+\t\t// Refill the buffer if necessary.\n \t\tif d.bufp >= d.nbuf {\n-\t\t\td.bufp = 0\n-\t\t\tvar e error\n-\t\t\td.nbuf, e = file.Read(d.buf[:])\n-\t\t\tif e != nil && e != io.EOF {\n-\t\t\t\treturn result, &PathError{\"readdir\", file.name, e}\n-\t\t\t}\n-\t\t\tif e == io.EOF {\n-\t\t\t\tbreak\n+\t\t\tnb, err := file.Read(d.buf[:])\n+\n+\t\t\t// Update the buffer state before checking for errors.\n+\t\t\td.bufp, d.nbuf = 0, nb\n+\n+\t\t\tif err != nil {\n+\t\t\t\tif err == io.EOF {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\treturn fi, &PathError{\"readdir\", file.name, err}\n \t\t\t}\n-\t\t\tif d.nbuf < syscall.STATFIXLEN {\n-\t\t\t\treturn result, &PathError{\"readdir\", file.name, errShortStat}\n+\t\t\tif nb < syscall.STATFIXLEN {\n+\t\t\t\treturn fi, &PathError{\"readdir\", file.name, syscall.ErrShortStat}\n \t\t\t}\n \t\t}\n \n-\t\t// Get a record from buffer\n-\t\tm, _ := gbit16(d.buf[d.bufp:])\n-\t\tm += 2\n+\t\t// Get a record from the buffer.\n+\t\tb := d.buf[d.bufp:]\n+\t\tm := int(uint16(b[0])|uint16(b[1])<<8) + 2\n \t\tif m < syscall.STATFIXLEN {\n-\t\t\treturn result, &PathError{\"readdir\", file.name, errShortStat}\n+\t\t\treturn fi, &PathError{\"readdir\", file.name, syscall.ErrShortStat}\n \t\t}\n-\t\tdir, e := unmarshalDir(d.buf[d.bufp : d.bufp+int(m)])\n-\t\tif e != nil {\n-\t\t\treturn result, &PathError{\"readdir\", file.name, e}\n+\n+\t\tdir, err := syscall.UnmarshalDir(b[:m])\n+\t\tif err != nil {\n+\t\t\treturn fi, &PathError{\"readdir\", file.name, err}\n \t\t}\n-\t\tresult = append(result, fileInfoFromStat(dir))\n+\t\tfi = append(fi, fileInfoFromStat(dir))\n \n-\t\td.bufp += int(m)\n+\t\td.bufp += m\n \t\tn--\n \t}\n \n-\tif n >= 0 && len(result) == 0 {\n-\t\treturn result, io.EOF\n+\tif n >= 0 && len(fi) == 0 {\n+\t\treturn fi, io.EOF\n \t}\n-\treturn result, nil\n+\treturn fi, nil\n }\n \n func (file *File) readdirnames(n int) (names []string, err error) {\n@@ -72,205 +71,3 @@ func (file *File) readdirnames(n int) (names []string, err error) {\n \t}\n \treturn\n }\n-\n-type dir struct {\n-\t// system-modified data\n-\tType uint16 // server type\n-\tDev  uint32 // server subtype\n-\t// file data\n-\tQid    qid    // unique id from server\n-\tMode   uint32 // permissions\n-\tAtime  uint32 // last read time\n-\tMtime  uint32 // last write time\n-\tLength uint64 // file length\n-\tName   string // last element of path\n-\tUid    string // owner name\n-\tGid    string // group name\n-\tMuid   string // last modifier name\n-}\n-\n-type qid struct {\n-\tPath uint64 // the file server's unique identification for the file\n-\tVers uint32 // version number for given Path\n-\tType uint8  // the type of the file (syscall.QTDIR for example)\n-}\n-\n-var nullDir = dir{\n-\t^uint16(0),\n-\t^uint32(0),\n-\tqid{^uint64(0), ^uint32(0), ^uint8(0)},\n-\t^uint32(0),\n-\t^uint32(0),\n-\t^uint32(0),\n-\t^uint64(0),\n-\t\"\",\n-\t\"\",\n-\t\"\",\n-\t\"\",\n-}\n-\n-// Null assigns members of d with special \"don't care\" values indicating\n-// they should not be written by syscall.Wstat.\n-func (d *dir) Null() {\n-\t*d = nullDir\n-}\n-\n-// pdir appends a 9P Stat message based on the contents of Dir d to a byte slice b.\n-func pdir(b []byte, d *dir) []byte {\n-\tn := len(b)\n-\tb = pbit16(b, 0) // length, filled in later\n-\tb = pbit16(b, d.Type)\n-\tb = pbit32(b, d.Dev)\n-\tb = pqid(b, d.Qid)\n-\tb = pbit32(b, d.Mode)\n-\tb = pbit32(b, d.Atime)\n-\tb = pbit32(b, d.Mtime)\n-\tb = pbit64(b, d.Length)\n-\tb = pstring(b, d.Name)\n-\tb = pstring(b, d.Uid)\n-\tb = pstring(b, d.Gid)\n-\tb = pstring(b, d.Muid)\n-\tpbit16(b[0:n], uint16(len(b)-(n+2)))\n-\treturn b\n-}\n-\n-// unmarshalDir reads a 9P Stat message from a 9P protocol message stored in b,\n-// returning the corresponding dir struct.\n-func unmarshalDir(b []byte) (d *dir, err error) {\n-\tn := uint16(0)\n-\tn, b = gbit16(b)\n-\n-\tif int(n) != len(b) {\n-\t\treturn nil, errBadStat\n-\t}\n-\n-\td = new(dir)\n-\td.Type, b = gbit16(b)\n-\td.Dev, b = gbit32(b)\n-\td.Qid, b = gqid(b)\n-\td.Mode, b = gbit32(b)\n-\td.Atime, b = gbit32(b)\n-\td.Mtime, b = gbit32(b)\n-\td.Length, b = gbit64(b)\n-\td.Name, b = gstring(b)\n-\td.Uid, b = gstring(b)\n-\td.Gid, b = gstring(b)\n-\td.Muid, b = gstring(b)\n-\n-\tif len(b) != 0 {\n-\t\treturn nil, errBadStat\n-\t}\n-\n-\treturn d, nil\n-}\n-\n-// gqid reads the qid part of a 9P Stat message from a 9P protocol message stored in b,\n-// returning the corresponding qid struct and the remaining slice of b.\n-func gqid(b []byte) (qid, []byte) {\n-\tvar q qid\n-\tq.Path, b = gbit64(b)\n-\tq.Vers, b = gbit32(b)\n-\tq.Type, b = gbit8(b)\n-\treturn q, b\n-}\n-\n-// pqid appends a qid struct q to a 9P message b.\n-func pqid(b []byte, q qid) []byte {\n-\tb = pbit64(b, q.Path)\n-\tb = pbit32(b, q.Vers)\n-\tb = pbit8(b, q.Type)\n-\treturn b\n-}\n-\n-// gbit8 reads a byte-sized numeric value from a 9P protocol message stored in b,\n-// returning the value and the remaining slice of b.\n-func gbit8(b []byte) (uint8, []byte) {\n-\treturn uint8(b[0]), b[1:]\n-}\n-\n-// gbit16 reads a 16-bit numeric value from a 9P protocol message stored in b,\n-// returning the value and the remaining slice of b.\n-func gbit16(b []byte) (uint16, []byte) {\n-\treturn uint16(b[0]) | uint16(b[1])<<8, b[2:]\n-}\n-\n-// gbit32 reads a 32-bit numeric value from a 9P protocol message stored in b,\n-// returning the value and the remaining slice of b.\n-func gbit32(b []byte) (uint32, []byte) {\n-\treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24, b[4:]\n-}\n-\n-// gbit64 reads a 64-bit numeric value from a 9P protocol message stored in b,\n-// returning the value and the remaining slice of b.\n-func gbit64(b []byte) (uint64, []byte) {\n-\tlo, b := gbit32(b)\n-\thi, b := gbit32(b)\n-\treturn uint64(hi)<<32 | uint64(lo), b\n-}\n-\n-// gstring reads a string from a 9P protocol message stored in b,\n-// returning the value as a Go string and the remaining slice of b.\n-func gstring(b []byte) (string, []byte) {\n-\tn, b := gbit16(b)\n-\treturn string(b[0:n]), b[n:]\n-}\n-\n-// pbit8 appends a byte-sized numeric value x to a 9P message b.\n-func pbit8(b []byte, x uint8) []byte {\n-\tn := len(b)\n-\tif n+1 > cap(b) {\n-\t\tnb := make([]byte, n, 100+2*cap(b))\n-\t\tcopy(nb, b)\n-\t\tb = nb\n-\t}\n-\tb = b[0 : n+1]\n-\tb[n] = x\n-\treturn b\n-}\n-\n-// pbit16 appends a 16-bit numeric value x to a 9P message b.\n-func pbit16(b []byte, x uint16) []byte {\n-\tn := len(b)\n-\tif n+2 > cap(b) {\n-\t\tnb := make([]byte, n, 100+2*cap(b))\n-\t\tcopy(nb, b)\n-\t\tb = nb\n-\t}\n-\tb = b[0 : n+2]\n-\tb[n] = byte(x)\n-\tb[n+1] = byte(x >> 8)\n-\treturn b\n-}\n-\n-// pbit32 appends a 32-bit numeric value x to a 9P message b.\n-func pbit32(b []byte, x uint32) []byte {\n-\tn := len(b)\n-\tif n+4 > cap(b) {\n-\t\tnb := make([]byte, n, 100+2*cap(b))\n-\t\tcopy(nb, b)\n-\t\tb = nb\n-\t}\n-\tb = b[0 : n+4]\n-\tb[n] = byte(x)\n-\tb[n+1] = byte(x >> 8)\n-\tb[n+2] = byte(x >> 16)\n-\tb[n+3] = byte(x >> 24)\n-\treturn b\n-}\n-\n-// pbit64 appends a 64-bit numeric value x to a 9P message b.\n-func pbit64(b []byte, x uint64) []byte {\n-\tb = pbit32(b, uint32(x))\n-\tb = pbit32(b, uint32(x>>32))\n-\treturn b\n-}\n-\n-// pstring appends a Go string s to a 9P message b.\n-func pstring(b []byte, s string) []byte {\n-\tif len(s) >= 1<<16 {\n-\t\tpanic(errors.New(\"string too long\"))\n-\t}\n-\tb = pbit16(b, uint16(len(s)))\n-\tb = append(b, s...)\n-\treturn b\n-}"}, {"sha": "fb2f2347d7d071fb7c99a14198d3b59b8221b5a9", "filename": "libgo/go/os/file_plan9.go", "status": "modified", "additions": 64, "deletions": 28, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -169,13 +169,18 @@ func (f *File) Stat() (fi FileInfo, err error) {\n // It does not change the I/O offset.\n // If there is an error, it will be of type *PathError.\n func (f *File) Truncate(size int64) error {\n-\tvar d dir\n-\td.Null()\n+\tvar d syscall.Dir\n \n-\td.Length = uint64(size)\n+\td.Null()\n+\td.Length = size\n \n-\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); e != nil {\n-\t\treturn &PathError{\"truncate\", f.name, e}\n+\tvar buf [syscall.STATFIXLEN]byte\n+\tn, err := d.Marshal(buf[:])\n+\tif err != nil {\n+\t\treturn &PathError{\"truncate\", f.name, err}\n+\t}\n+\tif err = syscall.Fwstat(f.fd, buf[:n]); err != nil {\n+\t\treturn &PathError{\"truncate\", f.name, err}\n \t}\n \treturn nil\n }\n@@ -185,16 +190,22 @@ const chmodMask = uint32(syscall.DMAPPEND | syscall.DMEXCL | syscall.DMTMP | Mod\n // Chmod changes the mode of the file to mode.\n // If there is an error, it will be of type *PathError.\n func (f *File) Chmod(mode FileMode) error {\n-\tvar d dir\n+\tvar d syscall.Dir\n \n \todir, e := dirstat(f)\n \tif e != nil {\n \t\treturn &PathError{\"chmod\", f.name, e}\n \t}\n \td.Null()\n \td.Mode = odir.Mode&^chmodMask | syscallMode(mode)&chmodMask\n-\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); e != nil {\n-\t\treturn &PathError{\"chmod\", f.name, e}\n+\n+\tvar buf [syscall.STATFIXLEN]byte\n+\tn, err := d.Marshal(buf[:])\n+\tif err != nil {\n+\t\treturn &PathError{\"chmod\", f.name, err}\n+\t}\n+\tif err = syscall.Fwstat(f.fd, buf[:n]); err != nil {\n+\t\treturn &PathError{\"chmod\", f.name, err}\n \t}\n \treturn nil\n }\n@@ -206,12 +217,16 @@ func (f *File) Sync() (err error) {\n \tif f == nil {\n \t\treturn ErrInvalid\n \t}\n-\n-\tvar d dir\n+\tvar d syscall.Dir\n \td.Null()\n \n-\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); e != nil {\n-\t\treturn NewSyscallError(\"fsync\", e)\n+\tvar buf [syscall.STATFIXLEN]byte\n+\tn, err := d.Marshal(buf[:])\n+\tif err != nil {\n+\t\treturn NewSyscallError(\"fsync\", err)\n+\t}\n+\tif err = syscall.Fwstat(f.fd, buf[:n]); err != nil {\n+\t\treturn NewSyscallError(\"fsync\", err)\n \t}\n \treturn nil\n }\n@@ -253,13 +268,18 @@ func (f *File) seek(offset int64, whence int) (ret int64, err error) {\n // If the file is a symbolic link, it changes the size of the link's target.\n // If there is an error, it will be of type *PathError.\n func Truncate(name string, size int64) error {\n-\tvar d dir\n-\td.Null()\n+\tvar d syscall.Dir\n \n-\td.Length = uint64(size)\n+\td.Null()\n+\td.Length = size\n \n-\tif e := syscall.Wstat(name, pdir(nil, &d)); e != nil {\n-\t\treturn &PathError{\"truncate\", name, e}\n+\tvar buf [syscall.STATFIXLEN]byte\n+\tn, err := d.Marshal(buf[:])\n+\tif err != nil {\n+\t\treturn &PathError{\"truncate\", name, err}\n+\t}\n+\tif err = syscall.Wstat(name, buf[:n]); err != nil {\n+\t\treturn &PathError{\"truncate\", name, err}\n \t}\n \treturn nil\n }\n@@ -275,13 +295,18 @@ func Remove(name string) error {\n \n // Rename renames a file.\n func Rename(oldname, newname string) error {\n-\tvar d dir\n-\td.Null()\n+\tvar d syscall.Dir\n \n+\td.Null()\n \td.Name = newname\n \n-\tif e := syscall.Wstat(oldname, pdir(nil, &d)); e != nil {\n-\t\treturn &PathError{\"rename\", oldname, e}\n+\tvar buf [syscall.STATFIXLEN]byte\n+\tn, err := d.Marshal(buf[:])\n+\tif err != nil {\n+\t\treturn &PathError{\"rename\", oldname, err}\n+\t}\n+\tif err = syscall.Wstat(oldname, buf[:n]); err != nil {\n+\t\treturn &PathError{\"rename\", oldname, err}\n \t}\n \treturn nil\n }\n@@ -290,16 +315,22 @@ func Rename(oldname, newname string) error {\n // If the file is a symbolic link, it changes the mode of the link's target.\n // If there is an error, it will be of type *PathError.\n func Chmod(name string, mode FileMode) error {\n-\tvar d dir\n+\tvar d syscall.Dir\n \n \todir, e := dirstat(name)\n \tif e != nil {\n \t\treturn &PathError{\"chmod\", name, e}\n \t}\n \td.Null()\n \td.Mode = odir.Mode&^chmodMask | syscallMode(mode)&chmodMask\n-\tif e := syscall.Wstat(name, pdir(nil, &d)); e != nil {\n-\t\treturn &PathError{\"chmod\", name, e}\n+\n+\tvar buf [syscall.STATFIXLEN]byte\n+\tn, err := d.Marshal(buf[:])\n+\tif err != nil {\n+\t\treturn &PathError{\"chmod\", name, err}\n+\t}\n+\tif err = syscall.Wstat(name, buf[:n]); err != nil {\n+\t\treturn &PathError{\"chmod\", name, err}\n \t}\n \treturn nil\n }\n@@ -311,14 +342,19 @@ func Chmod(name string, mode FileMode) error {\n // less precise time unit.\n // If there is an error, it will be of type *PathError.\n func Chtimes(name string, atime time.Time, mtime time.Time) error {\n-\tvar d dir\n-\td.Null()\n+\tvar d syscall.Dir\n \n+\td.Null()\n \td.Atime = uint32(atime.Unix())\n \td.Mtime = uint32(mtime.Unix())\n \n-\tif e := syscall.Wstat(name, pdir(nil, &d)); e != nil {\n-\t\treturn &PathError{\"chtimes\", name, e}\n+\tvar buf [syscall.STATFIXLEN]byte\n+\tn, err := d.Marshal(buf[:])\n+\tif err != nil {\n+\t\treturn &PathError{\"chtimes\", name, err}\n+\t}\n+\tif err = syscall.Wstat(name, buf[:n]); err != nil {\n+\t\treturn &PathError{\"chtimes\", name, err}\n \t}\n \treturn nil\n }"}, {"sha": "9f0bbdc25cc09864e3d6045e3df5f6b7f9294bb4", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -1093,3 +1093,25 @@ func TestLargeWriteToConsole(t *testing.T) {\n \t\tt.Errorf(\"Write to os.Stderr should return %d; got %d\", len(b), n)\n \t}\n }\n+\n+func TestStatDirModeExec(t *testing.T) {\n+\tconst mode = 0111\n+\n+\tpath, err := ioutil.TempDir(\"\", \"go-build\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create temp directory: %v\", err)\n+\t}\n+\tdefer RemoveAll(path)\n+\n+\tif err := Chmod(path, 0777); err != nil {\n+\t\tt.Fatalf(\"Chmod %q 0777: %v\", path, err)\n+\t}\n+\n+\tdir, err := Stat(path)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stat %q (looking for mode %#o): %s\", path, mode, err)\n+\t}\n+\tif dir.Mode()&mode != mode {\n+\t\tt.Errorf(\"Stat %q: mode %#o want %#o\", path, dir.Mode()&mode, mode)\n+\t}\n+}"}, {"sha": "6822cc019eadb8ea5f2f66a1deb1824209678d15", "filename": "libgo/go/os/stat_plan9.go", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -10,12 +10,12 @@ import (\n )\n \n func sameFile(sys1, sys2 interface{}) bool {\n-\ta := sys1.(*dir)\n-\tb := sys2.(*dir)\n+\ta := sys1.(*syscall.Dir)\n+\tb := sys2.(*syscall.Dir)\n \treturn a.Qid.Path == b.Qid.Path && a.Type == b.Type && a.Dev == b.Dev\n }\n \n-func fileInfoFromStat(d *dir) FileInfo {\n+func fileInfoFromStat(d *syscall.Dir) FileInfo {\n \tfs := &fileStat{\n \t\tname:    d.Name,\n \t\tsize:    int64(d.Length),\n@@ -39,7 +39,7 @@ func fileInfoFromStat(d *dir) FileInfo {\n }\n \n // arg is an open *File or a path string.\n-func dirstat(arg interface{}) (d *dir, err error) {\n+func dirstat(arg interface{}) (*syscall.Dir, error) {\n \tvar name string\n \n \t// This is big enough for most stat messages\n@@ -50,36 +50,40 @@ func dirstat(arg interface{}) (d *dir, err error) {\n \t\tbuf := make([]byte, size)\n \n \t\tvar n int\n+\t\tvar err error\n \t\tswitch a := arg.(type) {\n \t\tcase *File:\n \t\t\tname = a.name\n \t\t\tn, err = syscall.Fstat(a.fd, buf)\n \t\tcase string:\n \t\t\tname = a\n-\t\t\tn, err = syscall.Stat(name, buf)\n+\t\t\tn, err = syscall.Stat(a, buf)\n+\t\tdefault:\n+\t\t\tpanic(\"phase error in dirstat\")\n \t\t}\n \t\tif err != nil {\n \t\t\treturn nil, &PathError{\"stat\", name, err}\n \t\t}\n \t\tif n < syscall.STATFIXLEN {\n-\t\t\treturn nil, &PathError{\"stat\", name, errShortStat}\n+\t\t\treturn nil, &PathError{\"stat\", name, syscall.ErrShortStat}\n \t\t}\n \n \t\t// Pull the real size out of the stat message.\n-\t\ts, _ := gbit16(buf)\n-\t\tsize = int(s)\n+\t\tsize = int(uint16(buf[0]) | uint16(buf[1])<<8)\n \n \t\t// If the stat message is larger than our buffer we will\n \t\t// go around the loop and allocate one that is big enough.\n-\t\tif size <= n {\n-\t\t\td, err = unmarshalDir(buf[:n])\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, &PathError{\"stat\", name, err}\n-\t\t\t}\n-\t\t\treturn\n+\t\tif size > n {\n+\t\t\tcontinue\n \t\t}\n+\n+\t\td, err := syscall.UnmarshalDir(buf[:n])\n+\t\tif err != nil {\n+\t\t\treturn nil, &PathError{\"stat\", name, err}\n+\t\t}\n+\t\treturn d, nil\n \t}\n-\treturn nil, &PathError{\"stat\", name, errBadStat}\n+\treturn nil, &PathError{\"stat\", name, syscall.ErrBadStat}\n }\n \n // Stat returns a FileInfo describing the named file.\n@@ -102,5 +106,5 @@ func Lstat(name string) (fi FileInfo, err error) {\n \n // For testing.\n func atime(fi FileInfo) time.Time {\n-\treturn time.Unix(int64(fi.Sys().(*dir).Atime), 0)\n+\treturn time.Unix(int64(fi.Sys().(*syscall.Dir).Atime), 0)\n }"}, {"sha": "09f00c7bdb4ce534e5167df1c3eb1f446cfd03d8", "filename": "libgo/go/os/user/lookup.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fuser%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fuser%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package user\n+\n+// Current returns the current user.\n+func Current() (*User, error) {\n+\treturn current()\n+}\n+\n+// Lookup looks up a user by username. If the user cannot be found, the\n+// returned error is of type UnknownUserError.\n+func Lookup(username string) (*User, error) {\n+\treturn lookup(username)\n+}\n+\n+// LookupId looks up a user by userid. If the user cannot be found, the\n+// returned error is of type UnknownUserIdError.\n+func LookupId(uid string) (*User, error) {\n+\treturn lookupId(uid)\n+}"}, {"sha": "ad06907b5d57760a5deab8a0944bdc911145be8b", "filename": "libgo/go/os/user/lookup_stubs.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -15,14 +15,14 @@ func init() {\n \timplemented = false\n }\n \n-func Current() (*User, error) {\n+func current() (*User, error) {\n \treturn nil, fmt.Errorf(\"user: Current not implemented on %s/%s\", runtime.GOOS, runtime.GOARCH)\n }\n \n-func Lookup(username string) (*User, error) {\n+func lookup(username string) (*User, error) {\n \treturn nil, fmt.Errorf(\"user: Lookup not implemented on %s/%s\", runtime.GOOS, runtime.GOARCH)\n }\n \n-func LookupId(string) (*User, error) {\n+func lookupId(uid string) (*User, error) {\n \treturn nil, fmt.Errorf(\"user: LookupId not implemented on %s/%s\", runtime.GOOS, runtime.GOARCH)\n }"}, {"sha": "7e67495f1b717cca6e03a64d53e3d51df525ce3e", "filename": "libgo/go/os/user/lookup_unix.go", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -44,28 +44,23 @@ func bytePtrToString(p *byte) string {\n \treturn string(a[:i])\n }\n \n-// Current returns the current user.\n-func Current() (*User, error) {\n-\treturn lookup(syscall.Getuid(), \"\", false)\n+func current() (*User, error) {\n+\treturn lookupUnix(syscall.Getuid(), \"\", false)\n }\n \n-// Lookup looks up a user by username. If the user cannot be found,\n-// the returned error is of type UnknownUserError.\n-func Lookup(username string) (*User, error) {\n-\treturn lookup(-1, username, true)\n+func lookup(username string) (*User, error) {\n+\treturn lookupUnix(-1, username, true)\n }\n \n-// LookupId looks up a user by userid. If the user cannot be found,\n-// the returned error is of type UnknownUserIdError.\n-func LookupId(uid string) (*User, error) {\n+func lookupId(uid string) (*User, error) {\n \ti, e := strconv.Atoi(uid)\n \tif e != nil {\n \t\treturn nil, e\n \t}\n-\treturn lookup(i, \"\", false)\n+\treturn lookupUnix(i, \"\", false)\n }\n \n-func lookup(uid int, username string, lookupByName bool) (*User, error) {\n+func lookupUnix(uid int, username string, lookupByName bool) (*User, error) {\n \tvar pwd syscall.Passwd\n \tvar result *syscall.Passwd\n "}, {"sha": "a0a8a4ec10f3fcf4c1c37b323a83cc45a58eaa43", "filename": "libgo/go/os/user/lookup_windows.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fuser%2Flookup_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fos%2Fuser%2Flookup_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_windows.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -68,8 +68,7 @@ func newUser(usid *syscall.SID, gid, dir string) (*User, error) {\n \treturn u, nil\n }\n \n-// Current returns the current user.\n-func Current() (*User, error) {\n+func current() (*User, error) {\n \tt, e := syscall.OpenCurrentProcessToken()\n \tif e != nil {\n \t\treturn nil, e\n@@ -103,8 +102,7 @@ func newUserFromSid(usid *syscall.SID) (*User, error) {\n \treturn newUser(usid, gid, dir)\n }\n \n-// Lookup looks up a user by username.\n-func Lookup(username string) (*User, error) {\n+func lookup(username string) (*User, error) {\n \tsid, _, t, e := syscall.LookupSID(\"\", username)\n \tif e != nil {\n \t\treturn nil, e\n@@ -115,8 +113,7 @@ func Lookup(username string) (*User, error) {\n \treturn newUserFromSid(sid)\n }\n \n-// LookupId looks up a user by userid.\n-func LookupId(uid string) (*User, error) {\n+func lookupId(uid string) (*User, error) {\n \tsid, e := syscall.StringToSid(uid)\n \tif e != nil {\n \t\treturn nil, e"}, {"sha": "bee4d95bc7ce12d4e4348c45bba38cebac2fd9a0", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -91,6 +91,7 @@ var wincleantests = []PathTest{\n }\n \n func TestClean(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \ttests := cleantests\n \tif runtime.GOOS == \"windows\" {\n \t\tfor i := range tests {\n@@ -902,7 +903,7 @@ func TestDriveLetterInEvalSymlinks(t *testing.T) {\n    differently.\n \n func TestBug3486(t *testing.T) { // http://code.google.com/p/go/issues/detail?id=3486\n-\troot, err := filepath.EvalSymlinks(os.Getenv(\"GOROOT\"))\n+\troot, err := filepath.EvalSymlinks(runtime.GOROOT())\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "926b57355a0936d982351fd9b976e074b745b3b7", "filename": "libgo/go/path/path_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fpath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fpath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -64,6 +64,7 @@ var cleantests = []PathTest{\n }\n \n func TestClean(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tfor _, test := range cleantests {\n \t\tif s := Clean(test.path); s != test.result {\n \t\t\tt.Errorf(\"Clean(%q) = %q, want %q\", test.path, s, test.result)"}, {"sha": "8a3602347fd9402678052326d235b77962e7494a", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -2020,6 +2020,7 @@ func TestAddr(t *testing.T) {\n /* gccgo does do allocations here.\n \n func noAlloc(t *testing.T, n int, f func(int)) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \t// once to prime everything\n \tf(-1)\n \tmemstats := new(runtime.MemStats)\n@@ -2029,12 +2030,9 @@ func noAlloc(t *testing.T, n int, f func(int)) {\n \tfor j := 0; j < n; j++ {\n \t\tf(j)\n \t}\n-\t// A few allocs may happen in the testing package when GOMAXPROCS > 1, so don't\n-\t// require zero mallocs.\n-\t// A new thread, one of which will be created if GOMAXPROCS>1, does 6 allocations.\n \truntime.ReadMemStats(memstats)\n \tmallocs := memstats.Mallocs - oldmallocs\n-\tif mallocs > 10 {\n+\tif mallocs > 0 {\n \t\tt.Fatalf(\"%d mallocs after %d iterations\", mallocs, n)\n \t}\n }"}, {"sha": "9e65870990f6bc8e9fa3eb721a2430fffb9dea04", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -1334,7 +1334,7 @@ func cachePut(k cacheKey, t *rtype) Type {\n \treturn t\n }\n \n-// ChanOf returns the channel type with the given direction and and element type.\n+// ChanOf returns the channel type with the given direction and element type.\n // For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n //\n // The gc runtime imposes a limit of 64 kB on channel element types."}, {"sha": "b7e4f044a57dc2fc2a04a0ad41008336c02e647a", "filename": "libgo/go/regexp/all_test.go", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fall_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -5,6 +5,7 @@\n package regexp_test\n \n import (\n+\t\"reflect\"\n \t. \"regexp\"\n \t\"strings\"\n \t\"testing\"\n@@ -417,6 +418,59 @@ func TestSubexp(t *testing.T) {\n \t}\n }\n \n+var splitTests = []struct {\n+\ts   string\n+\tr   string\n+\tn   int\n+\tout []string\n+}{\n+\t{\"foo:and:bar\", \":\", -1, []string{\"foo\", \"and\", \"bar\"}},\n+\t{\"foo:and:bar\", \":\", 1, []string{\"foo:and:bar\"}},\n+\t{\"foo:and:bar\", \":\", 2, []string{\"foo\", \"and:bar\"}},\n+\t{\"foo:and:bar\", \"foo\", -1, []string{\"\", \":and:bar\"}},\n+\t{\"foo:and:bar\", \"bar\", -1, []string{\"foo:and:\", \"\"}},\n+\t{\"foo:and:bar\", \"baz\", -1, []string{\"foo:and:bar\"}},\n+\t{\"baabaab\", \"a\", -1, []string{\"b\", \"\", \"b\", \"\", \"b\"}},\n+\t{\"baabaab\", \"a*\", -1, []string{\"b\", \"b\", \"b\"}},\n+\t{\"baabaab\", \"ba*\", -1, []string{\"\", \"\", \"\", \"\"}},\n+\t{\"foobar\", \"f*b*\", -1, []string{\"\", \"o\", \"o\", \"a\", \"r\"}},\n+\t{\"foobar\", \"f+.*b+\", -1, []string{\"\", \"ar\"}},\n+\t{\"foobooboar\", \"o{2}\", -1, []string{\"f\", \"b\", \"boar\"}},\n+\t{\"a,b,c,d,e,f\", \",\", 3, []string{\"a\", \"b\", \"c,d,e,f\"}},\n+\t{\"a,b,c,d,e,f\", \",\", 0, nil},\n+\t{\",\", \",\", -1, []string{\"\", \"\"}},\n+\t{\",,,\", \",\", -1, []string{\"\", \"\", \"\", \"\"}},\n+\t{\"\", \",\", -1, []string{\"\"}},\n+\t{\"\", \".*\", -1, []string{\"\"}},\n+\t{\"\", \".+\", -1, []string{\"\"}},\n+\t{\"\", \"\", -1, []string{}},\n+\t{\"foobar\", \"\", -1, []string{\"f\", \"o\", \"o\", \"b\", \"a\", \"r\"}},\n+\t{\"abaabaccadaaae\", \"a*\", 5, []string{\"\", \"b\", \"b\", \"c\", \"cadaaae\"}},\n+\t{\":x:y:z:\", \":\", -1, []string{\"\", \"x\", \"y\", \"z\", \"\"}},\n+}\n+\n+func TestSplit(t *testing.T) {\n+\tfor i, test := range splitTests {\n+\t\tre, err := Compile(test.r)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: %q: compile error: %s\", i, test.r, err.Error())\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tsplit := re.Split(test.s, test.n)\n+\t\tif !reflect.DeepEqual(split, test.out) {\n+\t\t\tt.Errorf(\"#%d: %q: got %q; want %q\", i, test.r, split, test.out)\n+\t\t}\n+\n+\t\tif QuoteMeta(test.r) == test.r {\n+\t\t\tstrsplit := strings.SplitN(test.s, test.r, test.n)\n+\t\t\tif !reflect.DeepEqual(split, strsplit) {\n+\t\t\t\tt.Errorf(\"#%d: Split(%q, %q, %d): regexp vs strings mismatch\\nregexp=%q\\nstrings=%q\", i, test.s, test.r, test.n, split, strsplit)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkLiteral(b *testing.B) {\n \tx := strings.Repeat(\"x\", 50) + \"y\"\n \tb.StopTimer()"}, {"sha": "b0ad9d3400263efefbd2149f4be76842e76249d4", "filename": "libgo/go/regexp/example_test.go", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fregexp%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fregexp%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexample_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -20,3 +20,125 @@ func Example() {\n \t// false\n \t// false\n }\n+\n+func ExampleMatchString() {\n+\tmatched, err := regexp.MatchString(\"foo.*\", \"seafood\")\n+\tfmt.Println(matched, err)\n+\tmatched, err = regexp.MatchString(\"bar.*\", \"seafood\")\n+\tfmt.Println(matched, err)\n+\tmatched, err = regexp.MatchString(\"a(b\", \"seafood\")\n+\tfmt.Println(matched, err)\n+\t// Output:\n+\t// true <nil>\n+\t// false <nil>\n+\t// false error parsing regexp: missing closing ): `a(b`\n+}\n+\n+func ExampleRegexp_FindString() {\n+\tre := regexp.MustCompile(\"fo.?\")\n+\tfmt.Printf(\"%q\\n\", re.FindString(\"seafood\"))\n+\tfmt.Printf(\"%q\\n\", re.FindString(\"meat\"))\n+\t// Output:\n+\t// \"foo\"\n+\t// \"\"\n+}\n+\n+func ExampleRegexp_FindStringIndex() {\n+\tre := regexp.MustCompile(\"ab?\")\n+\tfmt.Println(re.FindStringIndex(\"tablett\"))\n+\tfmt.Println(re.FindStringIndex(\"foo\") == nil)\n+\t// Output:\n+\t// [1 3]\n+\t// true\n+}\n+\n+func ExampleRegexp_FindStringSubmatch() {\n+\tre := regexp.MustCompile(\"a(x*)b(y|z)c\")\n+\tfmt.Printf(\"%q\\n\", re.FindStringSubmatch(\"-axxxbyc-\"))\n+\tfmt.Printf(\"%q\\n\", re.FindStringSubmatch(\"-abzc-\"))\n+\t// Output:\n+\t// [\"axxxbyc\" \"xxx\" \"y\"]\n+\t// [\"abzc\" \"\" \"z\"]\n+}\n+\n+func ExampleRegexp_FindAllString() {\n+\tre := regexp.MustCompile(\"a.\")\n+\tfmt.Println(re.FindAllString(\"paranormal\", -1))\n+\tfmt.Println(re.FindAllString(\"paranormal\", 2))\n+\tfmt.Println(re.FindAllString(\"graal\", -1))\n+\tfmt.Println(re.FindAllString(\"none\", -1))\n+\t// Output:\n+\t// [ar an al]\n+\t// [ar an]\n+\t// [aa]\n+\t// []\n+}\n+\n+func ExampleRegexp_FindAllStringSubmatch() {\n+\tre := regexp.MustCompile(\"a(x*)b\")\n+\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-ab-\", -1))\n+\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-axxb-\", -1))\n+\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-ab-axb-\", -1))\n+\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-axxb-ab-\", -1))\n+\t// Output:\n+\t// [[\"ab\" \"\"]]\n+\t// [[\"axxb\" \"xx\"]]\n+\t// [[\"ab\" \"\"] [\"axb\" \"x\"]]\n+\t// [[\"axxb\" \"xx\"] [\"ab\" \"\"]]\n+}\n+\n+func ExampleRegexp_FindAllStringSubmatchIndex() {\n+\tre := regexp.MustCompile(\"a(x*)b\")\n+\t// Indices:\n+\t//    01234567   012345678\n+\t//    -ab-axb-   -axxb-ab-\n+\tfmt.Println(re.FindAllStringSubmatchIndex(\"-ab-\", -1))\n+\tfmt.Println(re.FindAllStringSubmatchIndex(\"-axxb-\", -1))\n+\tfmt.Println(re.FindAllStringSubmatchIndex(\"-ab-axb-\", -1))\n+\tfmt.Println(re.FindAllStringSubmatchIndex(\"-axxb-ab-\", -1))\n+\tfmt.Println(re.FindAllStringSubmatchIndex(\"-foo-\", -1))\n+\t// Output:\n+\t// [[1 3 2 2]]\n+\t// [[1 5 2 4]]\n+\t// [[1 3 2 2] [4 7 5 6]]\n+\t// [[1 5 2 4] [6 8 7 7]]\n+\t// []\n+}\n+\n+func ExampleRegexp_ReplaceAllLiteralString() {\n+\tre := regexp.MustCompile(\"a(x*)b\")\n+\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"T\"))\n+\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"$1\"))\n+\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"${1}\"))\n+\t// Output:\n+\t// -T-T-\n+\t// -$1-$1-\n+\t// -${1}-${1}-\n+}\n+\n+func ExampleRegexp_ReplaceAllString() {\n+\tre := regexp.MustCompile(\"a(x*)b\")\n+\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"T\"))\n+\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"$1\"))\n+\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"$1W\"))\n+\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"${1}W\"))\n+\t// Output:\n+\t// -T-T-\n+\t// --xx-\n+\t// ---\n+\t// -W-xxW-\n+}\n+\n+func ExampleRegexp_SubexpNames() {\n+\tre := regexp.MustCompile(\"(?P<first>[a-zA-Z]+) (?P<last>[a-zA-Z]+)\")\n+\tfmt.Println(re.MatchString(\"Alan Turing\"))\n+\tfmt.Printf(\"%q\\n\", re.SubexpNames())\n+\treversed := fmt.Sprintf(\"${%s} ${%s}\", re.SubexpNames()[2], re.SubexpNames()[1])\n+\tfmt.Println(reversed)\n+\tfmt.Println(re.ReplaceAllString(\"Alan Turing\", reversed))\n+\t// Output:\n+\t// true\n+\t// [\"\" \"first\" \"last\"]\n+\t// ${last} ${first}\n+\t// Turing Alan\n+}"}, {"sha": "bcf354b44d6b818288aab159eaa81e212a88bb44", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -1048,3 +1048,52 @@ func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int {\n \t}\n \treturn result\n }\n+\n+// Split slices s into substrings separated by the expression and returns a slice of\n+// the substrings between those expression matches.\n+//\n+// The slice returned by this method consists of all the substrings of s\n+// not contained in the slice returned by FindAllString. When called on an expression\n+// that contains no metacharacters, it is equivalent to strings.SplitN.\n+//\n+// Example:\n+//   s := regexp.MustCompile(\"a*\").Split(\"abaabaccadaaae\", 5)\n+//   // s: [\"\", \"b\", \"b\", \"c\", \"cadaaae\"]\n+//\n+// The count determines the number of substrings to return:\n+//   n > 0: at most n substrings; the last substring will be the unsplit remainder.\n+//   n == 0: the result is nil (zero substrings)\n+//   n < 0: all substrings\n+func (re *Regexp) Split(s string, n int) []string {\n+\n+\tif n == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tif len(re.expr) > 0 && len(s) == 0 {\n+\t\treturn []string{\"\"}\n+\t}\n+\n+\tmatches := re.FindAllStringIndex(s, n)\n+\tstrings := make([]string, 0, len(matches))\n+\n+\tbeg := 0\n+\tend := 0\n+\tfor _, match := range matches {\n+\t\tif n > 0 && len(strings) >= n-1 {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tend = match[0]\n+\t\tif match[1] != 0 {\n+\t\t\tstrings = append(strings, s[beg:end])\n+\t\t}\n+\t\tbeg = match[1]\n+\t}\n+\n+\tif end != len(s) {\n+\t\tstrings = append(strings, s[beg:])\n+\t}\n+\n+\treturn strings\n+}"}, {"sha": "bcdde4b6a0b1869a7c492bf24777c9adef5f2300", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -125,6 +125,7 @@ func GoroutineProfile(p []StackRecord) (n int, ok bool)\n // blocking until data is available.  If profiling is turned off and all the profile\n // data accumulated while it was on has been returned, CPUProfile returns nil.\n // The caller must save the returned data before calling CPUProfile again.\n+//\n // Most clients should use the runtime/pprof package or\n // the testing package's -test.cpuprofile flag instead of calling\n // CPUProfile directly.\n@@ -133,6 +134,7 @@ func CPUProfile() []byte\n // SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\n // If hz <= 0, SetCPUProfileRate turns off profiling.\n // If the profiler is on, the rate cannot be changed without first turning it off.\n+//\n // Most clients should use the runtime/pprof package or\n // the testing package's -test.cpuprofile flag instead of calling\n // SetCPUProfileRate directly."}, {"sha": "2a90113a3a9b8ec7b89af5b64e40f6441e02611d", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -59,11 +59,7 @@ func (f *Func) FileLine(pc uintptr) (file string, line int) {\n // implemented in symtab.c\n func funcline_go(*Func, uintptr) (string, int)\n \n-// A gccgo specific hook to use debug info to get file/line info.\n-func RegisterDebugLookup(func(pc uintptr, function *string, file *string, line *int) bool,\n-\tfunc(sym string, val *uintptr) bool)\n-\n-// mid returns the current os thread (m) id.\n+// mid returns the current OS thread (m) id.\n func mid() uint32\n \n // SetFinalizer sets the finalizer associated with x to f."}, {"sha": "283a6812e95f3d270920ff526cfffe45d50ecdd1", "filename": "libgo/go/runtime/gc_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fruntime%2Fgc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fruntime%2Fgc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fgc_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -10,6 +10,7 @@ import (\n )\n \n func TestGcSys(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tmemstats := new(runtime.MemStats)\n \truntime.GC()\n \truntime.ReadMemStats(memstats)"}, {"sha": "bc33e3a6b4b643ebd8dc9fbbeddd17774d4dd869", "filename": "libgo/go/runtime/mallocrep1.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fruntime%2Fmallocrep1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fruntime%2Fmallocrep1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmallocrep1.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -39,6 +39,7 @@ func OkAmount(size, n uintptr) bool {\n }\n \n func AllocAndFree(size, count int) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tif *chatty {\n \t\tfmt.Printf(\"size=%d count=%d ...\\n\", size, count)\n \t}"}, {"sha": "b01aff16ca0018ec83c009544a1707a5891351a0", "filename": "libgo/go/strconv/strconv_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fstrconv%2Fstrconv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fstrconv%2Fstrconv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fstrconv_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -48,6 +48,7 @@ var (\n )\n \n func TestCountMallocs(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n \tfor _, mt := range mallocTest {\n \t\tconst N = 100\n \t\tmemstats := new(runtime.MemStats)"}, {"sha": "11240efc0780f7223d1e88a8b9161fb481b9414e", "filename": "libgo/go/strings/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fstrings%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fstrings%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freader.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -124,7 +124,7 @@ func (r *Reader) Seek(offset int64, whence int) (int64, error) {\n func (r *Reader) WriteTo(w io.Writer) (n int64, err error) {\n \tr.prevRune = -1\n \tif r.i >= len(r.s) {\n-\t\treturn 0, io.EOF\n+\t\treturn 0, nil\n \t}\n \ts := r.s[r.i:]\n \tm, err := io.WriteString(w, s)"}, {"sha": "4fdddcdb58e47719271fc1e23ec4c4468d1eb8d9", "filename": "libgo/go/strings/reader_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fstrings%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fstrings%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freader_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -90,7 +90,7 @@ func TestReaderAt(t *testing.T) {\n \n func TestWriteTo(t *testing.T) {\n \tconst str = \"0123456789\"\n-\tfor i := 0; i < len(str); i++ {\n+\tfor i := 0; i <= len(str); i++ {\n \t\ts := str[i:]\n \t\tr := strings.NewReader(s)\n \t\tvar b bytes.Buffer\n@@ -99,7 +99,7 @@ func TestWriteTo(t *testing.T) {\n \t\t\tt.Errorf(\"got %v; want %v\", n, expect)\n \t\t}\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"got error = %v; want nil\", err)\n+\t\t\tt.Errorf(\"for length %d: got error = %v; want nil\", len(s), err)\n \t\t}\n \t\tif b.String() != s {\n \t\t\tt.Errorf(\"got string %q; want %q\", b.String(), s)"}, {"sha": "eee8be44a3b1ca4378b867fe93dd99d3d9ccf652", "filename": "libgo/go/syscall/dir_plan9.go", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fsyscall%2Fdir_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Fsyscall%2Fdir_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fdir_plan9.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -0,0 +1,205 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Plan 9 directory marshalling. See intro(5).\n+\n+package syscall\n+\n+import \"errors\"\n+\n+var (\n+\tErrShortStat = errors.New(\"stat buffer too short\")\n+\tErrBadStat   = errors.New(\"malformed stat buffer\")\n+)\n+\n+// A Qid represents a 9P server's unique identification for a file.\n+type Qid struct {\n+\tPath uint64 // the file server's unique identification for the file\n+\tVers uint32 // version number for given Path\n+\tType uint8  // the type of the file (syscall.QTDIR for example)\n+}\n+\n+// A Dir contains the metadata for a file.\n+type Dir struct {\n+\t// system-modified data\n+\tType uint16 // server type\n+\tDev  uint32 // server subtype\n+\n+\t// file data\n+\tQid    Qid    // unique id from server\n+\tMode   uint32 // permissions\n+\tAtime  uint32 // last read time\n+\tMtime  uint32 // last write time\n+\tLength int64  // file length\n+\tName   string // last element of path\n+\tUid    string // owner name\n+\tGid    string // group name\n+\tMuid   string // last modifier name\n+}\n+\n+var nullDir = Dir{\n+\tType: ^uint16(0),\n+\tDev:  ^uint32(0),\n+\tQid: Qid{\n+\t\tPath: ^uint64(0),\n+\t\tVers: ^uint32(0),\n+\t\tType: ^uint8(0),\n+\t},\n+\tMode:   ^uint32(0),\n+\tAtime:  ^uint32(0),\n+\tMtime:  ^uint32(0),\n+\tLength: ^int64(0),\n+}\n+\n+// Null assigns special \"don't touch\" values to members of d to\n+// avoid modifiying them during syscall.Wstat.\n+func (d *Dir) Null() { *d = nullDir }\n+\n+// Marshal encodes a 9P stat message corresponding to d into b\n+//\n+// If there isn't enough space in b for a stat message, ErrShortStat is returned.\n+func (d *Dir) Marshal(b []byte) (n int, err error) {\n+\tn = STATFIXLEN + len(d.Name) + len(d.Uid) + len(d.Gid) + len(d.Muid)\n+\tif n > len(b) {\n+\t\treturn n, ErrShortStat\n+\t}\n+\n+\tb = pbit16(b, uint16(n)-2)\n+\tb = pbit16(b, d.Type)\n+\tb = pbit32(b, d.Dev)\n+\tb = pbit64(b, d.Qid.Path)\n+\tb = pbit32(b, d.Qid.Vers)\n+\tb = pbit8(b, d.Qid.Type)\n+\tb = pbit32(b, d.Mode)\n+\tb = pbit32(b, d.Atime)\n+\tb = pbit32(b, d.Mtime)\n+\tb = pbit64(b, uint64(d.Length))\n+\tb = pstring(b, d.Name)\n+\tb = pstring(b, d.Uid)\n+\tb = pstring(b, d.Gid)\n+\tb = pstring(b, d.Muid)\n+\n+\treturn n, nil\n+}\n+\n+// UnmarshalDir decodes a single 9P stat message from b and returns the resulting Dir.\n+//\n+// If b is too small to hold a valid stat message, ErrShortStat is returned.\n+//\n+// If the stat message itself is invalid, ErrBadStat is returned.\n+func UnmarshalDir(b []byte) (*Dir, error) {\n+\tif len(b) < STATFIXLEN {\n+\t\treturn nil, ErrShortStat\n+\t}\n+\tsize, buf := gbit16(b)\n+\tif len(b) != int(size)+2 {\n+\t\treturn nil, ErrBadStat\n+\t}\n+\tb = buf\n+\n+\tvar d Dir\n+\td.Type, b = gbit16(b)\n+\td.Dev, b = gbit32(b)\n+\td.Qid.Path, b = gbit64(b)\n+\td.Qid.Vers, b = gbit32(b)\n+\td.Qid.Type, b = gbit8(b)\n+\td.Mode, b = gbit32(b)\n+\td.Atime, b = gbit32(b)\n+\td.Mtime, b = gbit32(b)\n+\n+\tn, b := gbit64(b)\n+\td.Length = int64(n)\n+\n+\tvar ok bool\n+\tif d.Name, b, ok = gstring(b); !ok {\n+\t\treturn nil, ErrBadStat\n+\t}\n+\tif d.Uid, b, ok = gstring(b); !ok {\n+\t\treturn nil, ErrBadStat\n+\t}\n+\tif d.Gid, b, ok = gstring(b); !ok {\n+\t\treturn nil, ErrBadStat\n+\t}\n+\tif d.Muid, b, ok = gstring(b); !ok {\n+\t\treturn nil, ErrBadStat\n+\t}\n+\n+\treturn &d, nil\n+}\n+\n+// pbit8 copies the 8-bit number v to b and returns the remaining slice of b.\n+func pbit8(b []byte, v uint8) []byte {\n+\tb[0] = byte(v)\n+\treturn b[1:]\n+}\n+\n+// pbit16 copies the 16-bit number v to b in little-endian order and returns the remaining slice of b.\n+func pbit16(b []byte, v uint16) []byte {\n+\tb[0] = byte(v)\n+\tb[1] = byte(v >> 8)\n+\treturn b[2:]\n+}\n+\n+// pbit32 copies the 32-bit number v to b in little-endian order and returns the remaining slice of b.\n+func pbit32(b []byte, v uint32) []byte {\n+\tb[0] = byte(v)\n+\tb[1] = byte(v >> 8)\n+\tb[2] = byte(v >> 16)\n+\tb[3] = byte(v >> 24)\n+\treturn b[4:]\n+}\n+\n+// pbit64 copies the 64-bit number v to b in little-endian order and returns the remaining slice of b.\n+func pbit64(b []byte, v uint64) []byte {\n+\tb[0] = byte(v)\n+\tb[1] = byte(v >> 8)\n+\tb[2] = byte(v >> 16)\n+\tb[3] = byte(v >> 24)\n+\tb[4] = byte(v >> 32)\n+\tb[5] = byte(v >> 40)\n+\tb[6] = byte(v >> 48)\n+\tb[7] = byte(v >> 56)\n+\treturn b[8:]\n+}\n+\n+// pstring copies the string s to b, prepending it with a 16-bit length in little-endian order, and\n+// returning the remaining slice of b..\n+func pstring(b []byte, s string) []byte {\n+\tb = pbit16(b, uint16(len(s)))\n+\tn := copy(b, s)\n+\treturn b[n:]\n+}\n+\n+// gbit8 reads an 8-bit number from b and returns it with the remaining slice of b.\n+func gbit8(b []byte) (uint8, []byte) {\n+\treturn uint8(b[0]), b[1:]\n+}\n+\n+// gbit16 reads a 16-bit number in little-endian order from b and returns it with the remaining slice of b.\n+func gbit16(b []byte) (uint16, []byte) {\n+\treturn uint16(b[0]) | uint16(b[1])<<8, b[2:]\n+}\n+\n+// gbit32 reads a 32-bit number in little-endian order from b and returns it with the remaining slice of b.\n+func gbit32(b []byte) (uint32, []byte) {\n+\treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24, b[4:]\n+}\n+\n+// gbit64 reads a 64-bit number in little-endian order from b and returns it with the remaining slice of b.\n+func gbit64(b []byte) (uint64, []byte) {\n+\tlo := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n+\thi := uint32(b[4]) | uint32(b[5])<<8 | uint32(b[6])<<16 | uint32(b[7])<<24\n+\treturn uint64(lo) | uint64(hi)<<32, b[8:]\n+}\n+\n+// gstring reads a string from b, prefixed with a 16-bit length in little-endian order.\n+// It returns the string with the remaining slice of b and a boolean. If the length is\n+// greater than the number of bytes in b, the boolean will be false.\n+func gstring(b []byte) (string, []byte, bool) {\n+\tn, b := gbit16(b)\n+\tif int(n) > len(b) {\n+\t\treturn \"\", b, false\n+\t}\n+\treturn string(b[:n]), b[n:], true\n+}"}, {"sha": "ea26710d8d2bcd9d6a44add7258dfe692973a514", "filename": "libgo/go/time/example_test.go", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Ftime%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Ftime%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fexample_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -56,3 +56,58 @@ func ExampleDate() {\n \tfmt.Printf(\"Go launched at %s\\n\", t.Local())\n \t// Output: Go launched at 2009-11-10 15:00:00 -0800 PST\n }\n+\n+func ExampleTime_Round() {\n+\tt := time.Date(0, 0, 0, 12, 15, 30, 918273645, time.UTC)\n+\tround := []time.Duration{\n+\t\ttime.Nanosecond,\n+\t\ttime.Microsecond,\n+\t\ttime.Millisecond,\n+\t\ttime.Second,\n+\t\t2 * time.Second,\n+\t\ttime.Minute,\n+\t\t10 * time.Minute,\n+\t\ttime.Hour,\n+\t}\n+\n+\tfor _, d := range round {\n+\t\tfmt.Printf(\"t.Round(%6s) = %s\\n\", d, t.Round(d).Format(\"15:04:05.999999999\"))\n+\t}\n+\t// Output:\n+\t// t.Round(   1ns) = 12:15:30.918273645\n+\t// t.Round(   1us) = 12:15:30.918274\n+\t// t.Round(   1ms) = 12:15:30.918\n+\t// t.Round(    1s) = 12:15:31\n+\t// t.Round(    2s) = 12:15:30\n+\t// t.Round(  1m0s) = 12:16:00\n+\t// t.Round( 10m0s) = 12:20:00\n+\t// t.Round(1h0m0s) = 12:00:00\n+}\n+\n+func ExampleTime_Truncate() {\n+\tt, _ := time.Parse(\"2006 Jan 02 15:04:05\", \"2012 Dec 07 12:15:30.918273645\")\n+\ttrunc := []time.Duration{\n+\t\ttime.Nanosecond,\n+\t\ttime.Microsecond,\n+\t\ttime.Millisecond,\n+\t\ttime.Second,\n+\t\t2 * time.Second,\n+\t\ttime.Minute,\n+\t\t10 * time.Minute,\n+\t\ttime.Hour,\n+\t}\n+\n+\tfor _, d := range trunc {\n+\t\tfmt.Printf(\"t.Truncate(%6s) = %s\\n\", d, t.Truncate(d).Format(\"15:04:05.999999999\"))\n+\t}\n+\n+\t// Output:\n+\t// t.Truncate(   1ns) = 12:15:30.918273645\n+\t// t.Truncate(   1us) = 12:15:30.918273\n+\t// t.Truncate(   1ms) = 12:15:30.918\n+\t// t.Truncate(    1s) = 12:15:30\n+\t// t.Truncate(    2s) = 12:15:30\n+\t// t.Truncate(  1m0s) = 12:15:00\n+\t// t.Truncate( 10m0s) = 12:10:00\n+\t// t.Truncate(1h0m0s) = 12:00:00\n+}"}, {"sha": "190cc37ddbd97397423dba16d5459500d2eed507", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -1033,3 +1033,116 @@ func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) T\n \n \treturn Time{unix + unixToInternal, int32(nsec), loc}\n }\n+\n+// Truncate returns the result of rounding t down to a multiple of d (since the zero time).\n+// If d <= 0, Truncate returns t unchanged.\n+func (t Time) Truncate(d Duration) Time {\n+\tif d <= 0 {\n+\t\treturn t\n+\t}\n+\t_, r := div(t, d)\n+\treturn t.Add(-r)\n+}\n+\n+// Round returns the result of rounding t to the nearest multiple of d (since the zero time).\n+// The rounding behavior for halfway values is to round up.\n+// If d <= 0, Round returns t unchanged.\n+func (t Time) Round(d Duration) Time {\n+\tif d <= 0 {\n+\t\treturn t\n+\t}\n+\t_, r := div(t, d)\n+\tif r+r < d {\n+\t\treturn t.Add(-r)\n+\t}\n+\treturn t.Add(d - r)\n+}\n+\n+// div divides t by d and returns the quotient parity and remainder.\n+// We don't use the quotient parity anymore (round half up instead of round to even)\n+// but it's still here in case we change our minds.\n+func div(t Time, d Duration) (qmod2 int, r Duration) {\n+\tneg := false\n+\tif t.sec < 0 {\n+\t\t// Operate on absolute value.\n+\t\tneg = true\n+\t\tt.sec = -t.sec\n+\t\tt.nsec = -t.nsec\n+\t\tif t.nsec < 0 {\n+\t\t\tt.nsec += 1e9\n+\t\t\tt.sec-- // t.sec >= 1 before the -- so safe\n+\t\t}\n+\t}\n+\n+\tswitch {\n+\t// Special case: 2d divides 1 second.\n+\tcase d < Second && Second%(d+d) == 0:\n+\t\tqmod2 = int(t.nsec/int32(d)) & 1\n+\t\tr = Duration(t.nsec % int32(d))\n+\n+\t// Special case: d is a multiple of 1 second.\n+\tcase d%Second == 0:\n+\t\td1 := int64(d / Second)\n+\t\tqmod2 = int(t.sec/d1) & 1\n+\t\tr = Duration(t.sec%d1)*Second + Duration(t.nsec)\n+\n+\t// General case.\n+\t// This could be faster if more cleverness were applied,\n+\t// but it's really only here to avoid special case restrictions in the API.\n+\t// No one will care about these cases.\n+\tdefault:\n+\t\t// Compute nanoseconds as 128-bit number.\n+\t\tsec := uint64(t.sec)\n+\t\ttmp := (sec >> 32) * 1e9\n+\t\tu1 := tmp >> 32\n+\t\tu0 := tmp << 32\n+\t\ttmp = uint64(sec&0xFFFFFFFF) * 1e9\n+\t\tu0x, u0 := u0, u0+tmp\n+\t\tif u0 < u0x {\n+\t\t\tu1++\n+\t\t}\n+\t\tu0x, u0 = u0, u0+uint64(t.nsec)\n+\t\tif u0 < u0x {\n+\t\t\tu1++\n+\t\t}\n+\n+\t\t// Compute remainder by subtracting r<<k for decreasing k.\n+\t\t// Quotient parity is whether we subtract on last round.\n+\t\td1 := uint64(d)\n+\t\tfor d1>>63 != 1 {\n+\t\t\td1 <<= 1\n+\t\t}\n+\t\td0 := uint64(0)\n+\t\tfor {\n+\t\t\tqmod2 = 0\n+\t\t\tif u1 > d1 || u1 == d1 && u0 >= d0 {\n+\t\t\t\t// subtract\n+\t\t\t\tqmod2 = 1\n+\t\t\t\tu0x, u0 = u0, u0-d0\n+\t\t\t\tif u0 > u0x {\n+\t\t\t\t\tu1--\n+\t\t\t\t}\n+\t\t\t\tu1 -= d1\n+\t\t\t}\n+\t\t\tif d1 == 0 && d0 == uint64(d) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\td0 >>= 1\n+\t\t\td0 |= (d1 & 1) << 63\n+\t\t\td1 >>= 1\n+\t\t}\n+\t\tr = Duration(u0)\n+\t}\n+\n+\tif neg && r != 0 {\n+\t\t// If input was negative and not an exact multiple of d, we computed q, r such that\n+\t\t//\tq*d + r = -t\n+\t\t// But the right answers are given by -(q-1), d-r:\n+\t\t//\tq*d + r = -t\n+\t\t//\t-q*d - r = t\n+\t\t//\t-(q-1)*d + (d - r) = t\n+\t\tqmod2 ^= 1\n+\t\tr = d - r\n+\t}\n+\treturn\n+}"}, {"sha": "1fd575b0956e6f857e0de0b420d082784e6cedd7", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 219, "deletions": 1, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -9,7 +9,9 @@ import (\n \t\"encoding/gob\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"math/big\"\n \t\"math/rand\"\n+\t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n@@ -192,6 +194,184 @@ func TestNanosecondsToUTCAndBack(t *testing.T) {\n \t}\n }\n \n+// The time routines provide no way to get absolute time\n+// (seconds since zero), but we need it to compute the right\n+// answer for bizarre roundings like \"to the nearest 3 ns\".\n+// Compute as t - year1 = (t - 1970) + (1970 - 2001) + (2001 - 1).\n+// t - 1970 is returned by Unix and Nanosecond.\n+// 1970 - 2001 is -(31*365+8)*86400 = -978307200 seconds.\n+// 2001 - 1 is 2000*365.2425*86400 = 63113904000 seconds.\n+const unixToZero = -978307200 + 63113904000\n+\n+// abs returns the absolute time stored in t, as seconds and nanoseconds.\n+func abs(t Time) (sec, nsec int64) {\n+\tunix := t.Unix()\n+\tnano := t.Nanosecond()\n+\treturn unix + unixToZero, int64(nano)\n+}\n+\n+// absString returns abs as a decimal string.\n+func absString(t Time) string {\n+\tsec, nsec := abs(t)\n+\tif sec < 0 {\n+\t\tsec = -sec\n+\t\tnsec = -nsec\n+\t\tif nsec < 0 {\n+\t\t\tnsec += 1e9\n+\t\t\tsec--\n+\t\t}\n+\t\treturn fmt.Sprintf(\"-%d%09d\", sec, nsec)\n+\t}\n+\treturn fmt.Sprintf(\"%d%09d\", sec, nsec)\n+}\n+\n+var truncateRoundTests = []struct {\n+\tt Time\n+\td Duration\n+}{\n+\t{Date(-1, January, 1, 12, 15, 30, 5e8, UTC), 3},\n+\t{Date(-1, January, 1, 12, 15, 31, 5e8, UTC), 3},\n+\t{Date(2012, January, 1, 12, 15, 30, 5e8, UTC), Second},\n+\t{Date(2012, January, 1, 12, 15, 31, 5e8, UTC), Second},\n+}\n+\n+func TestTruncateRound(t *testing.T) {\n+\tvar (\n+\t\tbsec  = new(big.Int)\n+\t\tbnsec = new(big.Int)\n+\t\tbd    = new(big.Int)\n+\t\tbt    = new(big.Int)\n+\t\tbr    = new(big.Int)\n+\t\tbq    = new(big.Int)\n+\t\tb1e9  = new(big.Int)\n+\t)\n+\n+\tb1e9.SetInt64(1e9)\n+\n+\ttestOne := func(ti, tns, di int64) bool {\n+\t\tt0 := Unix(ti, int64(tns)).UTC()\n+\t\td := Duration(di)\n+\t\tif d < 0 {\n+\t\t\td = -d\n+\t\t}\n+\t\tif d <= 0 {\n+\t\t\td = 1\n+\t\t}\n+\n+\t\t// Compute bt = absolute nanoseconds.\n+\t\tsec, nsec := abs(t0)\n+\t\tbsec.SetInt64(sec)\n+\t\tbnsec.SetInt64(nsec)\n+\t\tbt.Mul(bsec, b1e9)\n+\t\tbt.Add(bt, bnsec)\n+\n+\t\t// Compute quotient and remainder mod d.\n+\t\tbd.SetInt64(int64(d))\n+\t\tbq.DivMod(bt, bd, br)\n+\n+\t\t// To truncate, subtract remainder.\n+\t\t// br is < d, so it fits in an int64.\n+\t\tr := br.Int64()\n+\t\tt1 := t0.Add(-Duration(r))\n+\n+\t\t// Check that time.Truncate works.\n+\t\tif trunc := t0.Truncate(d); trunc != t1 {\n+\t\t\tt.Errorf(\"Time.Truncate(%s, %s) = %s, want %s\\n\"+\n+\t\t\t\t\"%v trunc %v =\\n%v want\\n%v\",\n+\t\t\t\tt0.Format(RFC3339Nano), d, trunc, t1.Format(RFC3339Nano),\n+\t\t\t\tabsString(t0), int64(d), absString(trunc), absString(t1))\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// To round, add d back if remainder r > d/2 or r == exactly d/2.\n+\t\t// The commented out code would round half to even instead of up,\n+\t\t// but that makes it time-zone dependent, which is a bit strange.\n+\t\tif r > int64(d)/2 || r+r == int64(d) /*&& bq.Bit(0) == 1*/ {\n+\t\t\tt1 = t1.Add(Duration(d))\n+\t\t}\n+\n+\t\t// Check that time.Round works.\n+\t\tif rnd := t0.Round(d); rnd != t1 {\n+\t\t\tt.Errorf(\"Time.Round(%s, %s) = %s, want %s\\n\"+\n+\t\t\t\t\"%v round %v =\\n%v want\\n%v\",\n+\t\t\t\tt0.Format(RFC3339Nano), d, rnd, t1.Format(RFC3339Nano),\n+\t\t\t\tabsString(t0), int64(d), absString(rnd), absString(t1))\n+\t\t\treturn false\n+\t\t}\n+\t\treturn true\n+\t}\n+\n+\t// manual test cases\n+\tfor _, tt := range truncateRoundTests {\n+\t\ttestOne(tt.t.Unix(), int64(tt.t.Nanosecond()), int64(tt.d))\n+\t}\n+\n+\t// exhaustive near 0\n+\tfor i := 0; i < 100; i++ {\n+\t\tfor j := 1; j < 100; j++ {\n+\t\t\ttestOne(unixToZero, int64(i), int64(j))\n+\t\t\ttestOne(unixToZero, -int64(i), int64(j))\n+\t\t\tif t.Failed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif t.Failed() {\n+\t\treturn\n+\t}\n+\n+\t// randomly generated test cases\n+\tcfg := &quick.Config{MaxCount: 100000}\n+\tif testing.Short() {\n+\t\tcfg.MaxCount = 1000\n+\t}\n+\n+\t// divisors of Second\n+\tf1 := func(ti int64, tns int32, logdi int32) bool {\n+\t\td := Duration(1)\n+\t\ta, b := uint(logdi%9), (logdi>>16)%9\n+\t\td <<= a\n+\t\tfor i := 0; i < int(b); i++ {\n+\t\t\td *= 5\n+\t\t}\n+\t\treturn testOne(ti, int64(tns), int64(d))\n+\t}\n+\tquick.Check(f1, cfg)\n+\n+\t// multiples of Second\n+\tf2 := func(ti int64, tns int32, di int32) bool {\n+\t\td := Duration(di) * Second\n+\t\tif d < 0 {\n+\t\t\td = -d\n+\t\t}\n+\t\treturn testOne(ti, int64(tns), int64(d))\n+\t}\n+\tquick.Check(f2, cfg)\n+\n+\t// halfway cases\n+\tf3 := func(tns, di int64) bool {\n+\t\tdi &= 0xfffffffe\n+\t\tif di == 0 {\n+\t\t\tdi = 2\n+\t\t}\n+\t\ttns -= tns % di\n+\t\tif tns < 0 {\n+\t\t\ttns += di / 2\n+\t\t} else {\n+\t\t\ttns -= di / 2\n+\t\t}\n+\t\treturn testOne(0, tns, di)\n+\t}\n+\tquick.Check(f3, cfg)\n+\n+\t// full generality\n+\tf4 := func(ti int64, tns int32, di int64) bool {\n+\t\treturn testOne(ti, int64(tns), di)\n+\t}\n+\tquick.Check(f4, cfg)\n+}\n+\n type TimeFormatTest struct {\n \ttime           Time\n \tformattedValue string\n@@ -1037,9 +1217,47 @@ func TestParseDurationRoundTrip(t *testing.T) {\n \t}\n }\n \n+var (\n+\tt Time\n+\tu int64\n+)\n+\n+var mallocTest = []struct {\n+\tcount int\n+\tdesc  string\n+\tfn    func()\n+}{\n+\t{0, `time.Now()`, func() { t = Now() }},\n+\t{0, `time.Now().UnixNano()`, func() { u = Now().UnixNano() }},\n+}\n+\n+func TestCountMallocs(t *testing.T) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))\n+\tfor _, mt := range mallocTest {\n+\t\tconst N = 100\n+\t\tmemstats := new(runtime.MemStats)\n+\t\truntime.ReadMemStats(memstats)\n+\t\tmallocs := 0 - memstats.Mallocs\n+\t\tfor i := 0; i < N; i++ {\n+\t\t\tmt.fn()\n+\t\t}\n+\t\truntime.ReadMemStats(memstats)\n+\t\tmallocs += memstats.Mallocs\n+\t\tif mallocs/N > uint64(mt.count) {\n+\t\t\tt.Errorf(\"%s: expected %d mallocs, got %d\", mt.desc, mt.count, mallocs/N)\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkNow(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tNow()\n+\t\tt = Now()\n+\t}\n+}\n+\n+func BenchmarkNowUnixNano(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tu = Now().UnixNano()\n \t}\n }\n "}, {"sha": "ceee42c5d6f5a27e0a5260e61d4051bba0e8d618", "filename": "libgo/runtime/chan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fruntime%2Fchan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fruntime%2Fchan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchan.c?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -197,7 +197,7 @@ runtime_chansend(ChanType *t, Hchan *c, byte *ep, bool *pres, void *pc)\n \truntime_lock(c);\n \t// TODO(dvyukov): add similar instrumentation to select.\n \tif(raceenabled)\n-\t\truntime_racereadpc(c, pc);\n+\t\truntime_racereadpc(c, pc, runtime_chansend);\n \tif(c->closed)\n \t\tgoto closed;\n \n@@ -1271,7 +1271,7 @@ runtime_closechan(Hchan *c)\n \t}\n \n \tif(raceenabled) {\n-\t\truntime_racewritepc(c, runtime_getcallerpc(&c));\n+\t\truntime_racewritepc(c, runtime_getcallerpc(&c), runtime_closechan);\n \t\truntime_racerelease(c);\n \t}\n "}, {"sha": "45f8a56ca7579e6aae0b36cc0acdb112fffd211a", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -949,6 +949,7 @@ runtime_memorydump(void)\n \t\tdumpspan(spanidx);\n \t}\n }\n+\n void\n runtime_gchelper(void)\n {\n@@ -1025,16 +1026,21 @@ cachestats(GCStats *stats)\n \tmstats.stacks_sys = stacks_sys;\n }\n \n+// Structure of arguments passed to function gc().\n+// This allows the arguments to be passed via reflect_call.\n+struct gc_args\n+{\n+\tint32 force;\n+};\n+\n+static void gc(struct gc_args *args);\n+\n void\n runtime_gc(int32 force)\n {\n \tM *m;\n-\tint64 t0, t1, t2, t3;\n-\tuint64 heap0, heap1, obj0, obj1;\n \tconst byte *p;\n-\tGCStats stats;\n-\tM *m1;\n-\tuint32 i;\n+\tstruct gc_args a, *ap;\n \n \t// The atomic operations are not atomic if the uint64s\n \t// are not aligned on uint64 boundaries. This has been\n@@ -1074,12 +1080,37 @@ runtime_gc(int32 force)\n \tif(gcpercent < 0)\n \t\treturn;\n \n+\t// Run gc on a bigger stack to eliminate\n+\t// a potentially large number of calls to runtime_morestack.\n+\t// But not when using gccgo.\n+\ta.force = force;\n+\tap = &a;\n+\tgc(ap);\n+\n+\tif(gctrace > 1 && !force) {\n+\t\ta.force = 1;\n+\t\tgc(&a);\n+\t}\n+}\n+\n+static void\n+gc(struct gc_args *args)\n+{\n+\tM *m;\n+\tint64 t0, t1, t2, t3;\n+\tuint64 heap0, heap1, obj0, obj1;\n+\tGCStats stats;\n+\tM *m1;\n+\tuint32 i;\n+\n \truntime_semacquire(&runtime_worldsema);\n-\tif(!force && mstats.heap_alloc < mstats.next_gc) {\n+\tif(!args->force && mstats.heap_alloc < mstats.next_gc) {\n \t\truntime_semrelease(&runtime_worldsema);\n \t\treturn;\n \t}\n \n+\tm = runtime_m();\n+\n \tt0 = runtime_nanotime();\n \n \tm->gcing = 1;\n@@ -1181,9 +1212,6 @@ runtime_gc(int32 force)\n \t// give the queued finalizers, if any, a chance to run\n \tif(finq != nil)\n \t\truntime_gosched();\n-\n-\tif(gctrace > 1 && !force)\n-\t\truntime_gc(1);\n }\n \n void runtime_ReadMemStats(MStats *)"}, {"sha": "9f3b3ec66088c383d71708685d0d59970191e0e8", "filename": "libgo/runtime/race.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fruntime%2Frace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a906c420d7bb196cb8541e0ab65264a0b04b0/libgo%2Fruntime%2Frace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Frace.h?ref=a42a906c420d7bb196cb8541e0ab65264a0b04b0", "patch": "@@ -20,8 +20,8 @@ void\truntime_racemalloc(void *p, uintptr sz, void *pc);\n void\truntime_racefree(void *p);\n void\truntime_racegostart(int32 goid, void *pc);\n void\truntime_racegoend(int32 goid);\n-void\truntime_racewritepc(void *addr, void *pc);\n-void\truntime_racereadpc(void *addr, void *pc);\n+void\truntime_racewritepc(void *addr, void *callpc, void *pc);\n+void\truntime_racereadpc(void *addr, void *callpc, void *pc);\n void\truntime_racefingo(void);\n void\truntime_raceacquire(void *addr);\n void\truntime_raceacquireg(G *gp, void *addr);"}]}