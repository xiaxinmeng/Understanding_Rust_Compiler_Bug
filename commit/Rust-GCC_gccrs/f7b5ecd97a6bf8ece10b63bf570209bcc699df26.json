{"sha": "f7b5ecd97a6bf8ece10b63bf570209bcc699df26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdiNWVjZDk3YTZiZjhlY2UxMGI2M2JmNTcwMjA5YmNjNjk5ZGYyNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-01-02T19:45:12Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-01-02T19:45:12Z"}, "message": "parser.c (cp_lexer_next_token_is): Declare it inline.\n\n\t* parser.c (cp_lexer_next_token_is): Declare it inline.\n\t(cp_lexer_set_source_position_from_token): Likewise.\n\t(cp_lexer_debugging_p): Likewise.\n\t(cp_parser_parsing_tentatively): Likewise.\n\t(cp_parser_nested_name_specifier_opt): Reduce the number of calls\n\tto the cp_lexer_peek_token.\n\nFrom-SVN: r60797", "tree": {"sha": "5f2d396138f107a646f258c6834d10aa0cb01153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f2d396138f107a646f258c6834d10aa0cb01153"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7b5ecd97a6bf8ece10b63bf570209bcc699df26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b5ecd97a6bf8ece10b63bf570209bcc699df26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7b5ecd97a6bf8ece10b63bf570209bcc699df26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b5ecd97a6bf8ece10b63bf570209bcc699df26/comments", "author": null, "committer": null, "parents": [{"sha": "f349fb24baf3b19478818c4849b7aeeed666ac0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f349fb24baf3b19478818c4849b7aeeed666ac0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f349fb24baf3b19478818c4849b7aeeed666ac0d"}], "stats": {"total": 109, "additions": 57, "deletions": 52}, "files": [{"sha": "c8e80e3744f12395b678d629f7cb4806712d1b65", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b5ecd97a6bf8ece10b63bf570209bcc699df26/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b5ecd97a6bf8ece10b63bf570209bcc699df26/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f7b5ecd97a6bf8ece10b63bf570209bcc699df26", "patch": "@@ -1,5 +1,12 @@\n 2003-01-02  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* parser.c (cp_lexer_next_token_is): Declare it inline.\n+\t(cp_lexer_set_source_position_from_token): Likewise.\n+\t(cp_lexer_debugging_p): Likewise.\n+\t(cp_parser_parsing_tentatively): Likewise.\n+\t(cp_parser_nested_name_specifier_opt): Reduce the number of calls\n+\tto the cp_lexer_peek_token.\n+\t \n \t* parser.c (cp_parser_sizeof_operand): Do not evaluate the\n \texpression.\n "}, {"sha": "f9c690c11c0a7a5189d64c3b98f4c6441c3eb25d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b5ecd97a6bf8ece10b63bf570209bcc699df26/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b5ecd97a6bf8ece10b63bf570209bcc699df26/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f7b5ecd97a6bf8ece10b63bf570209bcc699df26", "patch": "@@ -233,7 +233,7 @@ static cp_token *cp_lexer_peek_token\n   PARAMS ((cp_lexer *));\n static cp_token *cp_lexer_peek_nth_token\n   PARAMS ((cp_lexer *, size_t));\n-static bool cp_lexer_next_token_is\n+static inline bool cp_lexer_next_token_is\n   PARAMS ((cp_lexer *, enum cpp_ttype));\n static bool cp_lexer_next_token_is_not\n   PARAMS ((cp_lexer *, enum cpp_ttype));\n@@ -251,11 +251,11 @@ static void cp_lexer_commit_tokens\n   PARAMS ((cp_lexer *));\n static void cp_lexer_rollback_tokens\n   PARAMS ((cp_lexer *));\n-static void cp_lexer_set_source_position_from_token \n+static inline void cp_lexer_set_source_position_from_token \n   PARAMS ((cp_lexer *, const cp_token *));\n static void cp_lexer_print_token\n   PARAMS ((FILE *, cp_token *));\n-static bool cp_lexer_debugging_p \n+static inline bool cp_lexer_debugging_p \n   PARAMS ((cp_lexer *));\n static void cp_lexer_start_debugging\n   PARAMS ((cp_lexer *)) ATTRIBUTE_UNUSED;\n@@ -368,19 +368,37 @@ cp_lexer_new_from_tokens (cp_token_cache *tokens)\n   return lexer;\n }\n \n-/* Non-zero if we are presently saving tokens.  */\n+/* Returns non-zero if debugging information should be output.  */\n \n-static int\n-cp_lexer_saving_tokens (lexer)\n-     const cp_lexer *lexer;\n+static inline bool\n+cp_lexer_debugging_p (cp_lexer *lexer)\n {\n-  return VARRAY_ACTIVE_SIZE (lexer->saved_tokens) != 0;\n+  return lexer->debugging_p;\n+}\n+\n+/* Set the current source position from the information stored in\n+   TOKEN.  */\n+\n+static inline void\n+cp_lexer_set_source_position_from_token (lexer, token)\n+     cp_lexer *lexer ATTRIBUTE_UNUSED;\n+     const cp_token *token;\n+{\n+  /* Ideally, the source position information would not be a global\n+     variable, but it is.  */\n+\n+  /* Update the line number.  */\n+  if (token->type != CPP_EOF)\n+    {\n+      lineno = token->line_number;\n+      input_filename = token->file_name;\n+    }\n }\n \n /* TOKEN points into the circular token buffer.  Return a pointer to\n    the next token in the buffer.  */\n \n-static cp_token *\n+static inline cp_token *\n cp_lexer_next_token (lexer, token)\n      cp_lexer *lexer;\n      cp_token *token;\n@@ -391,6 +409,15 @@ cp_lexer_next_token (lexer, token)\n   return token;\n }\n \n+/* Non-zero if we are presently saving tokens.  */\n+\n+static int\n+cp_lexer_saving_tokens (lexer)\n+     const cp_lexer *lexer;\n+{\n+  return VARRAY_ACTIVE_SIZE (lexer->saved_tokens) != 0;\n+}\n+\n /* Return a pointer to the token that is N tokens beyond TOKEN in the\n    buffer.  */\n \n@@ -916,25 +943,6 @@ cp_lexer_rollback_tokens (lexer)\n   VARRAY_POP (lexer->saved_tokens);\n }\n \n-/* Set the current source position from the information stored in\n-   TOKEN.  */\n-\n-static void\n-cp_lexer_set_source_position_from_token (lexer, token)\n-     cp_lexer *lexer ATTRIBUTE_UNUSED;\n-     const cp_token *token;\n-{\n-  /* Ideally, the source position information would not be a global\n-     variable, but it is.  */\n-\n-  /* Update the line number.  */\n-  if (token->type != CPP_EOF)\n-    {\n-      lineno = token->line_number;\n-      input_filename = token->file_name;\n-    }\n-}\n-\n /* Print a representation of the TOKEN on the STREAM.  */\n \n static void\n@@ -1007,15 +1015,6 @@ cp_lexer_print_token (stream, token)\n     fprintf (stream, \" %s\", IDENTIFIER_POINTER (token->value));\n }\n \n-/* Returns non-zero if debugging information should be output.  */\n-\n-static bool\n-cp_lexer_debugging_p (lexer)\n-     cp_lexer *lexer;\n-{\n-  return lexer->debugging_p;\n-}\n-\n /* Start emitting debugging information.  */\n \n static void\n@@ -1747,7 +1746,7 @@ static void cp_parser_abort_tentative_parse\n   PARAMS ((cp_parser *));\n static bool cp_parser_parse_definitely\n   PARAMS ((cp_parser *));\n-static bool cp_parser_parsing_tentatively\n+static inline bool cp_parser_parsing_tentatively\n   PARAMS ((cp_parser *));\n static bool cp_parser_committed_to_tentative_parse\n   PARAMS ((cp_parser *));\n@@ -1800,6 +1799,15 @@ static void cp_parser_perform_deferred_access_checks\n static tree cp_parser_scope_through_which_access_occurs\n   (tree, tree, tree);\n \n+/* Returns non-zero if we are parsing tentatively.  */\n+\n+static inline bool\n+cp_parser_parsing_tentatively (parser)\n+     cp_parser *parser;\n+{\n+  return parser->context->next != NULL;\n+}\n+\n /* Returns non-zero if TOKEN is a string literal.  */\n \n static bool\n@@ -3467,18 +3475,17 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       /* Spot cases that cannot be the beginning of a\n \t nested-name-specifier.  On the second and subsequent times\n \t through the loop, we look for the `template' keyword.  */\n-      if (success \n-\t  && cp_lexer_next_token_is_keyword (parser->lexer,\n-\t\t\t\t\t     RID_TEMPLATE))\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (success && token->keyword == RID_TEMPLATE)\n \t;\n       /* A template-id can start a nested-name-specifier.  */\n-      else if (cp_lexer_next_token_is (parser->lexer, CPP_TEMPLATE_ID))\n+      else if (token->type == CPP_TEMPLATE_ID)\n \t;\n       else\n \t{\n \t  /* If the next token is not an identifier, then it is\n \t     definitely not a class-or-namespace-name.  */\n-\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+\t  if (token->type != CPP_NAME)\n \t    break;\n \t  /* If the following token is neither a `<' (to begin a\n \t     template-id), nor a `::', then we are not looking at a\n@@ -14846,15 +14853,6 @@ cp_parser_parse_definitely (parser)\n   return !error_occurred;\n }\n \n-/* Returns non-zero if we are parsing tentatively.  */\n-\n-static bool\n-cp_parser_parsing_tentatively (parser)\n-     cp_parser *parser;\n-{\n-  return parser->context->next != NULL;\n-}\n-\n /* Returns true if we are parsing tentatively -- but have decided that\n    we will stick with this tentative parse, even if errors occur.  */\n "}]}