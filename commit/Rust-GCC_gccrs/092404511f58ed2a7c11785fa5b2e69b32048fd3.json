{"sha": "092404511f58ed2a7c11785fa5b2e69b32048fd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkyNDA0NTExZjU4ZWQyYTdjMTE3ODVmYTViMmU2OWIzMjA0OGZkMw==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2014-11-18T10:26:31Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2014-11-18T10:26:31Z"}, "message": "tree.c (element_mode, [...]): New functions.\n\n2014-11-18  Marc Glisse  <marc.glisse@inria.fr>\n\n\t* tree.c (element_mode, integer_truep): New functions.\n\t* tree.h (element_mode, integer_truep): Declare them.\n\t* fold-const.c (negate_expr_p, fold_negate_expr, combine_comparisons,\n\tfold_cond_expr_with_comparison, fold_real_zero_addition_p,\n\tfold_comparison, fold_ternary_loc, tree_call_nonnegative_warnv_p,\n\tfold_strip_sign_ops): Use element_mode.\n\t(fold_binary_loc): Use element_mode and element_precision.\n\t* match.pd: Use integer_truep, element_mode, element_precision,\n\tVECTOR_TYPE_P and build_one_cst. Extend some transformations to\n\tvectors. Simplify A/-A.\n\nFrom-SVN: r217702", "tree": {"sha": "c1395e2804b0507497743d4f678303c275f80e85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1395e2804b0507497743d4f678303c275f80e85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/092404511f58ed2a7c11785fa5b2e69b32048fd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/092404511f58ed2a7c11785fa5b2e69b32048fd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/092404511f58ed2a7c11785fa5b2e69b32048fd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/092404511f58ed2a7c11785fa5b2e69b32048fd3/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f37760abed226a27061ded75d50be803ef73a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f37760abed226a27061ded75d50be803ef73a96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f37760abed226a27061ded75d50be803ef73a96"}], "stats": {"total": 245, "additions": 145, "deletions": 100}, "files": [{"sha": "78ed17c69e0479914adaad8884d7c7afae893525", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=092404511f58ed2a7c11785fa5b2e69b32048fd3", "patch": "@@ -1,3 +1,16 @@\n+2014-11-18  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* tree.c (element_mode, integer_truep): New functions.\n+\t* tree.h (element_mode, integer_truep): Declare them.\n+\t* fold-const.c (negate_expr_p, fold_negate_expr, combine_comparisons,\n+\tfold_cond_expr_with_comparison, fold_real_zero_addition_p,\n+\tfold_comparison, fold_ternary_loc, tree_call_nonnegative_warnv_p,\n+\tfold_strip_sign_ops): Use element_mode.\n+\t(fold_binary_loc): Use element_mode and element_precision.\n+\t* match.pd: Use integer_truep, element_mode, element_precision,\n+\tVECTOR_TYPE_P and build_one_cst. Extend some transformations to\n+\tvectors. Simplify A/-A.\n+\n 2014-11-18  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.md (unaligned_loaddi): Use std::swap instead of"}, {"sha": "f6fb8af8084d875b108754bba37febb1342bedea", "filename": "gcc/fold-const.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=092404511f58ed2a7c11785fa5b2e69b32048fd3", "patch": "@@ -442,8 +442,8 @@ negate_expr_p (tree t)\n       return negate_expr_p (TREE_OPERAND (t, 0));\n \n     case PLUS_EXPR:\n-      if (HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (type))\n-\t  || HONOR_SIGNED_ZEROS (TYPE_MODE (type)))\n+      if (HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n+\t  || HONOR_SIGNED_ZEROS (element_mode (type)))\n \treturn false;\n       /* -(A + B) -> (-B) - A.  */\n       if (negate_expr_p (TREE_OPERAND (t, 1))\n@@ -455,8 +455,8 @@ negate_expr_p (tree t)\n \n     case MINUS_EXPR:\n       /* We can't turn -(A-B) into B-A when we honor signed zeros.  */\n-      return !HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (type))\n-\t     && !HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n+      return !HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n+\t     && !HONOR_SIGNED_ZEROS (element_mode (type))\n \t     && reorder_operands_p (TREE_OPERAND (t, 0),\n \t\t\t\t    TREE_OPERAND (t, 1));\n \n@@ -467,7 +467,7 @@ negate_expr_p (tree t)\n       /* Fall through.  */\n \n     case RDIV_EXPR:\n-      if (! HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (TREE_TYPE (t))))\n+      if (! HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (TREE_TYPE (t))))\n \treturn negate_expr_p (TREE_OPERAND (t, 1))\n \t       || negate_expr_p (TREE_OPERAND (t, 0));\n       break;\n@@ -617,8 +617,8 @@ fold_negate_expr (location_t loc, tree t)\n       break;\n \n     case PLUS_EXPR:\n-      if (!HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (type))\n-\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (type)))\n+      if (!HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n+\t  && !HONOR_SIGNED_ZEROS (element_mode (type)))\n \t{\n \t  /* -(A + B) -> (-B) - A.  */\n \t  if (negate_expr_p (TREE_OPERAND (t, 1))\n@@ -642,8 +642,8 @@ fold_negate_expr (location_t loc, tree t)\n \n     case MINUS_EXPR:\n       /* - (A - B) -> B - A  */\n-      if (!HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (type))\n-\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n+      if (!HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n+\t  && !HONOR_SIGNED_ZEROS (element_mode (type))\n \t  && reorder_operands_p (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1)))\n \treturn fold_build2_loc (loc, MINUS_EXPR, type,\n \t\t\t    TREE_OPERAND (t, 1), TREE_OPERAND (t, 0));\n@@ -656,7 +656,7 @@ fold_negate_expr (location_t loc, tree t)\n       /* Fall through.  */\n \n     case RDIV_EXPR:\n-      if (! HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (type)))\n+      if (! HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type)))\n \t{\n \t  tem = TREE_OPERAND (t, 1);\n \t  if (negate_expr_p (tem))\n@@ -2315,7 +2315,7 @@ combine_comparisons (location_t loc,\n \t\t     enum tree_code rcode, tree truth_type,\n \t\t     tree ll_arg, tree lr_arg)\n {\n-  bool honor_nans = HONOR_NANS (TYPE_MODE (TREE_TYPE (ll_arg)));\n+  bool honor_nans = HONOR_NANS (element_mode (ll_arg));\n   enum comparison_code lcompcode = comparison_to_compcode (lcode);\n   enum comparison_code rcompcode = comparison_to_compcode (rcode);\n   int compcode;\n@@ -4581,7 +4581,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \n      Note that all these transformations are correct if A is\n      NaN, since the two alternatives (A and -A) are also NaNs.  */\n-  if (!HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n+  if (!HONOR_SIGNED_ZEROS (element_mode (type))\n       && (FLOAT_TYPE_P (TREE_TYPE (arg01))\n \t  ? real_zerop (arg01)\n \t  : integer_zerop (arg01))\n@@ -4639,7 +4639,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n      both transformations are correct when A is NaN: A != 0\n      is then true, and A == 0 is false.  */\n \n-  if (!HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n+  if (!HONOR_SIGNED_ZEROS (element_mode (type))\n       && integer_zerop (arg01) && integer_zerop (arg2))\n     {\n       if (comp_code == NE_EXPR)\n@@ -4674,7 +4674,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n      a number and A is not.  The conditions in the original\n      expressions will be false, so all four give B.  The min()\n      and max() versions would give a NaN instead.  */\n-  if (!HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n+  if (!HONOR_SIGNED_ZEROS (element_mode (type))\n       && operand_equal_for_comparison_p (arg01, arg2, arg00)\n       /* Avoid these transformations if the COND_EXPR may be used\n \t as an lvalue in the C++ front-end.  PR c++/19199.  */\n@@ -4711,7 +4711,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \t     operand which will be used if they are equal first\n \t     so that we can convert this back to the\n \t     corresponding COND_EXPR.  */\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t  if (!HONOR_NANS (element_mode (arg1)))\n \t    {\n \t      comp_op0 = fold_convert_loc (loc, comp_type, comp_op0);\n \t      comp_op1 = fold_convert_loc (loc, comp_type, comp_op1);\n@@ -4727,7 +4727,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \tcase GT_EXPR:\n \tcase UNGE_EXPR:\n \tcase UNGT_EXPR:\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t  if (!HONOR_NANS (element_mode (arg1)))\n \t    {\n \t      comp_op0 = fold_convert_loc (loc, comp_type, comp_op0);\n \t      comp_op1 = fold_convert_loc (loc, comp_type, comp_op1);\n@@ -4740,12 +4740,12 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \t    }\n \t  break;\n \tcase UNEQ_EXPR:\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t  if (!HONOR_NANS (element_mode (arg1)))\n \t    return pedantic_non_lvalue_loc (loc,\n \t\t\t\t\tfold_convert_loc (loc, type, arg2));\n \t  break;\n \tcase LTGT_EXPR:\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t  if (!HONOR_NANS (element_mode (arg1)))\n \t    return pedantic_non_lvalue_loc (loc,\n \t\t\t\t\tfold_convert_loc (loc, type, arg1));\n \t  break;\n@@ -6090,11 +6090,11 @@ fold_real_zero_addition_p (const_tree type, const_tree addend, int negate)\n     return false;\n \n   /* Don't allow the fold with -fsignaling-nans.  */\n-  if (HONOR_SNANS (TYPE_MODE (type)))\n+  if (HONOR_SNANS (element_mode (type)))\n     return false;\n \n   /* Allow the fold if zeros aren't signed, or their sign isn't important.  */\n-  if (!HONOR_SIGNED_ZEROS (TYPE_MODE (type)))\n+  if (!HONOR_SIGNED_ZEROS (element_mode (type)))\n     return true;\n \n   /* In a vector or complex, we would need to check the sign of all zeros.  */\n@@ -6109,7 +6109,7 @@ fold_real_zero_addition_p (const_tree type, const_tree addend, int negate)\n      In this situation, there is only one case we can return true for.\n      X - 0 is the same as X unless rounding towards -infinity is\n      supported.  */\n-  return negate && !HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (type));\n+  return negate && !HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type));\n }\n \n /* Subroutine of fold() that checks comparisons of built-in math\n@@ -9080,22 +9080,22 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t{\n \tcase EQ_EXPR:\n \t  if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t      || ! HONOR_NANS (element_mode (arg0)))\n \t    return constant_boolean_node (1, type);\n \t  break;\n \n \tcase GE_EXPR:\n \tcase LE_EXPR:\n \t  if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t      || ! HONOR_NANS (element_mode (arg0)))\n \t    return constant_boolean_node (1, type);\n \t  return fold_build2_loc (loc, EQ_EXPR, type, arg0, arg1);\n \n \tcase NE_EXPR:\n \t  /* For NE, we can only do this simplification if integer\n \t     or we don't honor IEEE floating point NaNs.  */\n \t  if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      && HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t      && HONOR_NANS (element_mode (arg0)))\n \t    break;\n \t  /* ... fall through ...  */\n \tcase GT_EXPR:\n@@ -9968,8 +9968,8 @@ fold_binary_loc (location_t loc,\n \t  /* Fold __complex__ ( x, 0 ) + __complex__ ( 0, y )\n \t     to __complex__ ( x, y ).  This is not the same for SNaNs or\n \t     if signed zeros are involved.  */\n-\t  if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n-              && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t  if (!HONOR_SNANS (element_mode (arg0))\n+              && !HONOR_SIGNED_ZEROS (element_mode (arg0))\n \t      && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (arg0)))\n \t    {\n \t      tree rtype = TREE_TYPE (TREE_TYPE (arg0));\n@@ -10405,8 +10405,8 @@ fold_binary_loc (location_t loc,\n       /* Fold __complex__ ( x, 0 ) - __complex__ ( 0, y ) to\n \t __complex__ ( x, -y ).  This is not the same for SNaNs or if\n \t signed zeros are involved.  */\n-      if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n-\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0)))\n+      if (!HONOR_SNANS (element_mode (arg0))\n+\t  && !HONOR_SIGNED_ZEROS (element_mode (arg0))\n \t  && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (arg0)))\n         {\n \t  tree rtype = TREE_TYPE (TREE_TYPE (arg0));\n@@ -10609,8 +10609,8 @@ fold_binary_loc (location_t loc,\n \t  /* Fold z * +-I to __complex__ (-+__imag z, +-__real z).\n \t     This is not the same for NaNs or if signed zeros are\n \t     involved.  */\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0)))\n-              && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t  if (!HONOR_NANS (element_mode (arg0))\n+              && !HONOR_SIGNED_ZEROS (element_mode (arg0))\n \t      && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (arg0))\n \t      && TREE_CODE (arg1) == COMPLEX_CST\n \t      && real_zerop (TREE_REALPART (arg1)))\n@@ -10657,7 +10657,7 @@ fold_binary_loc (location_t loc,\n \t\t  /* Optimize sqrt(x)*sqrt(x) as x.  */\n \t\t  if (BUILTIN_SQRT_P (fcode0)\n \t\t      && operand_equal_p (arg00, arg10, 0)\n-\t\t      && ! HONOR_SNANS (TYPE_MODE (type)))\n+\t\t      && ! HONOR_SNANS (element_mode (type)))\n \t\t    return arg00;\n \n \t          /* Optimize root(x)*root(y) as root(x*y).  */\n@@ -11305,7 +11305,7 @@ fold_binary_loc (location_t loc,\n       if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) == NOP_EXPR\n \t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t{\n-\t  prec = TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)));\n+\t  prec = element_precision (TREE_TYPE (TREE_OPERAND (arg0, 0)));\n \n \t  wide_int mask = wide_int::from (arg1, prec, UNSIGNED);\n \t  if (mask == -1)\n@@ -11541,8 +11541,8 @@ fold_binary_loc (location_t loc,\n \t      tree arg00 = CALL_EXPR_ARG (arg0, 0);\n \t      tree arg01 = CALL_EXPR_ARG (arg1, 0);\n \n-\t      if (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00)))\n-\t\t  && ! HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg00)))\n+\t      if (! HONOR_NANS (element_mode (arg00))\n+\t\t  && ! HONOR_INFINITIES (element_mode (arg00))\n \t\t  && operand_equal_p (arg00, arg01, 0))\n \t\t{\n \t\t  tree cosfn = mathfn_built_in (type, BUILT_IN_COS);\n@@ -11561,8 +11561,8 @@ fold_binary_loc (location_t loc,\n \t      tree arg00 = CALL_EXPR_ARG (arg0, 0);\n \t      tree arg01 = CALL_EXPR_ARG (arg1, 0);\n \n-\t      if (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00)))\n-\t\t  && ! HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg00)))\n+\t      if (! HONOR_NANS (element_mode (arg00))\n+\t\t  && ! HONOR_INFINITIES (element_mode (arg00))\n \t\t  && operand_equal_p (arg00, arg01, 0))\n \t\t{\n \t\t  tree cosfn = mathfn_built_in (type, BUILT_IN_COS);\n@@ -12935,7 +12935,7 @@ fold_binary_loc (location_t loc,\n       strict_overflow_p = false;\n       if (code == GE_EXPR\n \t  && (integer_zerop (arg1)\n-\t      || (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t      || (! HONOR_NANS (element_mode (arg0))\n \t\t  && real_zerop (arg1)))\n \t  && tree_expr_nonnegative_warnv_p (arg0, &strict_overflow_p))\n \t{\n@@ -12987,11 +12987,11 @@ fold_binary_loc (location_t loc,\n \t  && TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t  && CONVERT_EXPR_P (arg1)\n \t  && TREE_CODE (TREE_OPERAND (arg1, 0)) == LSHIFT_EXPR\n-\t  && (TYPE_PRECISION (TREE_TYPE (arg1))\n-\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg1, 0))))\n+\t  && (element_precision (TREE_TYPE (arg1))\n+\t      >= element_precision (TREE_TYPE (TREE_OPERAND (arg1, 0))))\n \t  && (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg1, 0)))\n-\t      || (TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t  == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg1, 0)))))\n+\t      || (element_precision (TREE_TYPE (arg1))\n+\t\t  == element_precision (TREE_TYPE (TREE_OPERAND (arg1, 0)))))\n \t  && integer_onep (TREE_OPERAND (TREE_OPERAND (arg1, 0), 0)))\n \t{\n \t  tem = build2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n@@ -13322,7 +13322,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n       if (COMPARISON_CLASS_P (arg0)\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1))\n-\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t  && !HONOR_SIGNED_ZEROS (element_mode (arg1)))\n \t{\n \t  tem = fold_cond_expr_with_comparison (loc, type, arg0, op1, op2);\n \t  if (tem)\n@@ -13333,7 +13333,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t\t     op2,\n \t\t\t\t\t     TREE_OPERAND (arg0, 1))\n-\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op2))))\n+\t  && !HONOR_SIGNED_ZEROS (element_mode (op2)))\n \t{\n \t  location_t loc0 = expr_location_or (arg0, loc);\n \t  tem = fold_invert_truthvalue (loc0, arg0);\n@@ -14834,7 +14834,7 @@ tree_call_nonnegative_warnv_p (tree type, tree fndecl,\n \n \tCASE_FLT_FN (BUILT_IN_SQRT):\n \t/* sqrt(-0.0) is -0.0.  */\n-\tif (!HONOR_SIGNED_ZEROS (TYPE_MODE (type)))\n+\tif (!HONOR_SIGNED_ZEROS (element_mode (type)))\n \t  return true;\n \treturn tree_expr_nonnegative_warnv_p (arg0,\n \t\t\t\t\t      strict_overflow_p);\n@@ -16100,7 +16100,7 @@ fold_strip_sign_ops (tree exp)\n \n     case MULT_EXPR:\n     case RDIV_EXPR:\n-      if (HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (TREE_TYPE (exp))))\n+      if (HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (exp)))\n \treturn NULL_TREE;\n       arg0 = fold_strip_sign_ops (TREE_OPERAND (exp, 0));\n       arg1 = fold_strip_sign_ops (TREE_OPERAND (exp, 1));"}, {"sha": "1f204716d1cda47115eb566bef40ba331fd7633f", "filename": "gcc/match.pd", "status": "modified", "additions": 52, "deletions": 55, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=092404511f58ed2a7c11785fa5b2e69b32048fd3", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Generic tree predicates we inherit.  */\n (define_predicates\n    integer_onep integer_zerop integer_all_onesp integer_minus_onep\n-   integer_each_onep\n+   integer_each_onep integer_truep\n    real_zerop real_onep real_minus_onep\n    CONSTANT_CLASS_P\n    tree_expr_nonnegative_p)\n@@ -73,7 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n    is volatile.  */\n (simplify\n  (minus @0 @0)\n- (if (!FLOAT_TYPE_P (type) || !HONOR_NANS (TYPE_MODE (type)))\n+ (if (!FLOAT_TYPE_P (type) || !HONOR_NANS (element_mode (type)))\n   { build_zero_cst (type); }))\n \n (simplify\n@@ -86,24 +86,24 @@ along with GCC; see the file COPYING3.  If not see\n    negative value by 0 gives -0, not +0.  */\n (simplify\n  (mult @0 real_zerop@1)\n- (if (!HONOR_NANS (TYPE_MODE (type))\n-      && !HONOR_SIGNED_ZEROS (TYPE_MODE (type)))\n+ (if (!HONOR_NANS (element_mode (type))\n+      && !HONOR_SIGNED_ZEROS (element_mode (type)))\n   @1))\n \n /* In IEEE floating point, x*1 is not equivalent to x for snans.\n    Likewise for complex arithmetic with signed zeros.  */\n (simplify\n  (mult @0 real_onep)\n- (if (!HONOR_SNANS (TYPE_MODE (type))\n-      && (!HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n+ (if (!HONOR_SNANS (element_mode (type))\n+      && (!HONOR_SIGNED_ZEROS (element_mode (type))\n           || !COMPLEX_FLOAT_TYPE_P (type)))\n   (non_lvalue @0)))\n \n /* Transform x * -1.0 into -x.  */\n (simplify\n  (mult @0 real_minus_onep)\n-  (if (!HONOR_SNANS (TYPE_MODE (type))\n-       && (!HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n+  (if (!HONOR_SNANS (element_mode (type))\n+       && (!HONOR_SIGNED_ZEROS (element_mode (type))\n            || !COMPLEX_FLOAT_TYPE_P (type)))\n    (negate @0)))\n \n@@ -117,44 +117,46 @@ along with GCC; see the file COPYING3.  If not see\n /* X / -1 is -X.  */\n (for div (trunc_div ceil_div floor_div round_div exact_div)\n  (simplify\n-   (div @0 INTEGER_CST@1)\n-   (if (!TYPE_UNSIGNED (type)\n-        && wi::eq_p (@1, -1))\n+   (div @0 integer_minus_onep@1)\n+   (if (!TYPE_UNSIGNED (type))\n     (negate @0))))\n \n /* For unsigned integral types, FLOOR_DIV_EXPR is the same as\n    TRUNC_DIV_EXPR.  Rewrite into the latter in this case.  */\n (simplify\n  (floor_div @0 @1)\n- (if (INTEGRAL_TYPE_P (type) && TYPE_UNSIGNED (type))\n+ (if ((INTEGRAL_TYPE_P (type) || VECTOR_INTEGER_TYPE_P (type))\n+      && TYPE_UNSIGNED (type))\n   (trunc_div @0 @1)))\n \n /* Optimize A / A to 1.0 if we don't care about\n-   NaNs or Infinities.  Skip the transformation\n-   for non-real operands.  */\n+   NaNs or Infinities.  */\n (simplify\n  (rdiv @0 @0)\n- (if (SCALAR_FLOAT_TYPE_P (type)\n-      && ! HONOR_NANS (TYPE_MODE (type))\n-      && ! HONOR_INFINITIES (TYPE_MODE (type)))\n-  { build_real (type, dconst1); })\n- /* The complex version of the above A / A optimization.  */\n- (if (COMPLEX_FLOAT_TYPE_P (type)\n-      && ! HONOR_NANS (TYPE_MODE (TREE_TYPE (type)))\n-      && ! HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (type))))\n-  { build_complex (type, build_real (TREE_TYPE (type), dconst1),\n-\t\t   build_real (TREE_TYPE (type), dconst0)); }))\n+ (if (FLOAT_TYPE_P (type)\n+      && ! HONOR_NANS (element_mode (type))\n+      && ! HONOR_INFINITIES (element_mode (type)))\n+  { build_one_cst (type); }))\n+\n+/* Optimize -A / A to -1.0 if we don't care about\n+   NaNs or Infinities.  */\n+(simplify\n+ (rdiv:c @0 (negate @0))\n+ (if (FLOAT_TYPE_P (type)\n+      && ! HONOR_NANS (element_mode (type))\n+      && ! HONOR_INFINITIES (element_mode (type)))\n+  { build_minus_one_cst (type); }))\n \n /* In IEEE floating point, x/1 is not equivalent to x for snans.  */\n (simplify\n  (rdiv @0 real_onep)\n- (if (!HONOR_SNANS (TYPE_MODE (type)))\n+ (if (!HONOR_SNANS (element_mode (type)))\n   (non_lvalue @0)))\n \n /* In IEEE floating point, x/-1 is not equivalent to -x for snans.  */\n (simplify\n  (rdiv @0 real_minus_onep)\n- (if (!HONOR_SNANS (TYPE_MODE (type)))\n+ (if (!HONOR_SNANS (element_mode (type)))\n   (negate @0)))\n \n /* If ARG1 is a constant, we can convert this to a multiply by the\n@@ -192,9 +194,8 @@ along with GCC; see the file COPYING3.  If not see\n   { build_zero_cst (type); })\n  /* X % -1 is zero.  */\n  (simplify\n-  (mod @0 INTEGER_CST@1)\n-  (if (!TYPE_UNSIGNED (type)\n-       && wi::eq_p (@1, -1))\n+  (mod @0 integer_minus_onep@1)\n+  (if (!TYPE_UNSIGNED (type))\n    { build_zero_cst (type); })))\n \n /* X % -C is the same as X % C.  */\n@@ -309,14 +310,11 @@ along with GCC; see the file COPYING3.  If not see\n (match (logical_inverted_value @0)\n  (bit_not truth_valued_p@0))\n (match (logical_inverted_value @0)\n- (eq @0 integer_zerop)\n- (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)))))\n+ (eq @0 integer_zerop))\n (match (logical_inverted_value @0)\n- (ne truth_valued_p@0 integer_onep)\n- (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)))))\n+ (ne truth_valued_p@0 integer_truep))\n (match (logical_inverted_value @0)\n- (bit_xor truth_valued_p@0 integer_onep)\n- (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)))))\n+ (bit_xor truth_valued_p@0 integer_truep))\n \n /* X & !X -> 0.  */\n (simplify\n@@ -493,7 +491,7 @@ along with GCC; see the file COPYING3.  If not see\n    (simplify\n     (minus (convert (add @0 @1))\n      (convert @0))\n-    (if (TYPE_PRECISION (type) <= TYPE_PRECISION (TREE_TYPE (@1))\n+    (if (element_precision (type) <= element_precision (TREE_TYPE (@1))\n \t /* For integer types, if A has a smaller type\n \t    than T the result depends on the possible\n \t    overflow in P + A.\n@@ -626,19 +624,19 @@ along with GCC; see the file COPYING3.  If not see\n       int inside_int = INTEGRAL_TYPE_P (inside_type);\n       int inside_ptr = POINTER_TYPE_P (inside_type);\n       int inside_float = FLOAT_TYPE_P (inside_type);\n-      int inside_vec = TREE_CODE (inside_type) == VECTOR_TYPE;\n+      int inside_vec = VECTOR_TYPE_P (inside_type);\n       unsigned int inside_prec = TYPE_PRECISION (inside_type);\n       int inside_unsignedp = TYPE_UNSIGNED (inside_type);\n       int inter_int = INTEGRAL_TYPE_P (inter_type);\n       int inter_ptr = POINTER_TYPE_P (inter_type);\n       int inter_float = FLOAT_TYPE_P (inter_type);\n-      int inter_vec = TREE_CODE (inter_type) == VECTOR_TYPE;\n+      int inter_vec = VECTOR_TYPE_P (inter_type);\n       unsigned int inter_prec = TYPE_PRECISION (inter_type);\n       int inter_unsignedp = TYPE_UNSIGNED (inter_type);\n       int final_int = INTEGRAL_TYPE_P (type);\n       int final_ptr = POINTER_TYPE_P (type);\n       int final_float = FLOAT_TYPE_P (type);\n-      int final_vec = TREE_CODE (type) == VECTOR_TYPE;\n+      int final_vec = VECTOR_TYPE_P (type);\n       unsigned int final_prec = TYPE_PRECISION (type);\n       int final_unsignedp = TYPE_UNSIGNED (type);\n     }\n@@ -666,8 +664,8 @@ along with GCC; see the file COPYING3.  If not see\n \t&& inter_prec >= inside_prec\n \t&& (inter_float || inter_vec\n \t    || inter_unsignedp == inside_unsignedp)\n-\t&& ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n-\t      && TYPE_MODE (type) == TYPE_MODE (inter_type))\n+\t&& ! (final_prec != GET_MODE_PRECISION (element_mode (type))\n+\t      && element_mode (type) == element_mode (inter_type))\n \t&& ! final_ptr\n \t&& (! final_vec || inter_prec == inside_prec))\n     (ocvt @0))\n@@ -845,12 +843,12 @@ along with GCC; see the file COPYING3.  If not see\n  /* A ? B : B -> B.  */\n  (simplify\n   (cnd @0 @1 @1)\n-  @1))\n+  @1)\n \n-/* !A ? B : C -> A ? C : B.  */\n-(simplify\n- (cond (logical_inverted_value truth_valued_p@0) @1 @2)\n- (cond @0 @2 @1))\n+ /* !A ? B : C -> A ? C : B.  */\n+ (simplify\n+  (cnd (logical_inverted_value truth_valued_p@0) @1 @2)\n+  (cnd @0 @2 @1)))\n \n \n /* Simplifications of comparisons.  */\n@@ -876,17 +874,16 @@ along with GCC; see the file COPYING3.  If not see\n       a computed operator in the replacement tree thus we have\n       to play the trick below.  */\n    (with { enum tree_code ic = invert_tree_comparison\n-             (cmp, HONOR_NANS (TYPE_MODE (TREE_TYPE (@0)))); }\n+             (cmp, HONOR_NANS (element_mode (@0))); }\n     (if (ic == icmp)\n      (icmp @0 @1))\n     (if (ic == ncmp)\n      (ncmp @0 @1)))))\n  (simplify\n-  (bit_xor (cmp @0 @1) integer_onep)\n-  (if (INTEGRAL_TYPE_P (type))\n-   (with { enum tree_code ic = invert_tree_comparison\n-             (cmp, HONOR_NANS (TYPE_MODE (TREE_TYPE (@0)))); }\n-    (if (ic == icmp)\n-     (icmp @0 @1))\n-    (if (ic == ncmp)\n-     (ncmp @0 @1))))))\n+  (bit_xor (cmp @0 @1) integer_truep)\n+  (with { enum tree_code ic = invert_tree_comparison\n+            (cmp, HONOR_NANS (element_mode (@0))); }\n+   (if (ic == icmp)\n+    (icmp @0 @1))\n+   (if (ic == ncmp)\n+    (ncmp @0 @1)))))"}, {"sha": "3f801af53441f0cd835cda2da9c85659ac78c88b", "filename": "gcc/tree.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=092404511f58ed2a7c11785fa5b2e69b32048fd3", "patch": "@@ -2275,6 +2275,20 @@ integer_nonzerop (const_tree expr)\n \t\t  || integer_nonzerop (TREE_IMAGPART (expr)))));\n }\n \n+/* Return 1 if EXPR is the integer constant one.  For vector,\n+   return 1 if every piece is the integer constant minus one\n+   (representing the value TRUE).  */\n+\n+int\n+integer_truep (const_tree expr)\n+{\n+  STRIP_NOPS (expr);\n+\n+  if (TREE_CODE (expr) == VECTOR_CST)\n+    return integer_all_onesp (expr);\n+  return integer_onep (expr);\n+}\n+\n /* Return 1 if EXPR is the fixed-point constant zero.  */\n \n int\n@@ -12310,4 +12324,18 @@ get_base_address (tree t)\n   return t;\n }\n \n+/* Return the machine mode of T.  For vectors, returns the mode of the\n+   inner type.  The main use case is to feed the result to HONOR_NANS,\n+   avoiding the BLKmode that a direct TYPE_MODE (T) might return.  */\n+\n+machine_mode\n+element_mode (const_tree t)\n+{\n+  if (!TYPE_P (t))\n+    t = TREE_TYPE (t);\n+  if (VECTOR_TYPE_P (t) || TREE_CODE (t) == COMPLEX_TYPE)\n+    t = TREE_TYPE (t);\n+  return TYPE_MODE (t);\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "ed8fecdd8e7115774720c70c36627b860e365273", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092404511f58ed2a7c11785fa5b2e69b32048fd3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=092404511f58ed2a7c11785fa5b2e69b32048fd3", "patch": "@@ -1564,6 +1564,8 @@ extern void protected_set_expr_location (tree, location_t);\n #define SET_TYPE_MODE(NODE, MODE) \\\n   (TYPE_CHECK (NODE)->type_common.mode = (MODE))\n \n+extern machine_mode element_mode (const_tree t);\n+\n /* The \"canonical\" type for this type node, which is used by frontends to\n    compare the type for equality with another type.  If two types are\n    equal (based on the semantics of the language), then they will have\n@@ -3999,6 +4001,11 @@ extern int integer_pow2p (const_tree);\n \n extern int integer_nonzerop (const_tree);\n \n+/* integer_truep (tree x) is nonzero if X is an integer constant of value 1 or\n+   a vector where each element is an integer constant of value -1.  */\n+\n+extern int integer_truep (const_tree);\n+\n extern bool cst_and_fits_in_hwi (const_tree);\n extern tree num_ending_zeros (const_tree);\n "}]}