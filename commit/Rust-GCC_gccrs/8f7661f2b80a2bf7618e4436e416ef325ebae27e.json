{"sha": "8f7661f2b80a2bf7618e4436e416ef325ebae27e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY3NjYxZjJiODBhMmJmNzYxOGU0NDM2ZTQxNmVmMzI1ZWJhZTI3ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-12-01T13:38:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-12-01T13:38:50Z"}, "message": "i386.md (zero_extend?i?i2): Rewrite to expanders; new patterns rewrite splitters.\n\n\t* i386.md (zero_extend?i?i2): Rewrite to expanders; new patterns\n\trewrite splitters.\n\nFrom-SVN: r30740", "tree": {"sha": "02608155d51aaf8345f295c5879af703653329e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02608155d51aaf8345f295c5879af703653329e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f7661f2b80a2bf7618e4436e416ef325ebae27e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f7661f2b80a2bf7618e4436e416ef325ebae27e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f7661f2b80a2bf7618e4436e416ef325ebae27e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f7661f2b80a2bf7618e4436e416ef325ebae27e/comments", "author": null, "committer": null, "parents": [{"sha": "b5b8a0e7794975bd86d0a30b7ffb28a9d9f2f6c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b8a0e7794975bd86d0a30b7ffb28a9d9f2f6c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5b8a0e7794975bd86d0a30b7ffb28a9d9f2f6c1"}], "stats": {"total": 241, "additions": 124, "deletions": 117}, "files": [{"sha": "8f3c7e17f03b0ea344c5be3e68ea5fe7ed26a6c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f7661f2b80a2bf7618e4436e416ef325ebae27e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f7661f2b80a2bf7618e4436e416ef325ebae27e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f7661f2b80a2bf7618e4436e416ef325ebae27e", "patch": "@@ -1,5 +1,8 @@\n Tue Nov 30 15:20:52 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n+\t* i386.md (zero_extend?i?i2): Rewrite to expanders; new patterns,\n+\trewrite splitters.\n+\n \t* i386.md (neg?f2_if): Split \"r\" and \"f\" to separate alternatives.\n \t(abs?f2_if): Likewise.\n "}, {"sha": "562f08f29df77b1e642462ce1a0343c94d9689fb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 121, "deletions": 117, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f7661f2b80a2bf7618e4436e416ef325ebae27e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f7661f2b80a2bf7618e4436e416ef325ebae27e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=8f7661f2b80a2bf7618e4436e416ef325ebae27e", "patch": "@@ -2167,172 +2167,176 @@\n \f\n ;; Zero extension instructions\n \n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,?r\")\n-     (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,rm\")))\n-   (clobber (reg:CC 17))]\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+     (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n-  \"*\n+  \"\n {\n-  switch (get_attr_type (insn))\n+  if (TARGET_ZERO_EXTEND_WITH_AND && !optimize_size)\n     {\n-    case TYPE_ALU1:\n-      if (!REG_P (operands[1]) || REGNO (operands[0]) != REGNO (operands[1]))\n-\tabort ();\n-      operands[1] = GEN_INT (0xffff);\n-      return \\\"and{l}\\\\t{%1, %0|%0, %1}\\\";\n-    default:\n-      return \\\"movz{wl|x}\\\\t{%1, %0|%0, %1}\\\";\n+      operands[1] = force_reg (HImode, operands[1]);\n+      emit_insn (gen_zero_extendhisi2_and (operands[0], operands[1]));\n+      DONE;\n     }\n-}\"\n-  [(set (attr \"type\")\n-     (if_then_else (and (eq_attr \"alternative\" \"0\")\n-\t\t\t(ne (symbol_ref \"TARGET_ZERO_EXTEND_WITH_AND\")\n-\t\t\t    (const_int 0)))\n-       (const_string \"alu1\")\n-       (const_string \"imovx\")))])\n+}\")\n \n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))\n+(define_insn \"zero_extendhisi2_and\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+     (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"reload_completed\n-   && TARGET_ZERO_EXTEND_WITH_AND\n-   && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(parallel [(set (match_dup 0) (const_int 0))\n-\t      (clobber (reg:CC 17))])\n-   (set (strict_low_part (subreg:HI (match_dup 0) 0)) (match_dup 1))]\n-  \"\")\n+  \"TARGET_ZERO_EXTEND_WITH_AND && !optimize_size\"\n+  \"#\"\n+  [(set_attr \"type\" \"alu1\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"\")))\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"reload_completed\n-   && TARGET_ZERO_EXTEND_WITH_AND\n-   && reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(set (strict_low_part (subreg:HI (match_dup 0) 0)) (match_dup 1))\n-   (parallel [(set (match_dup 0) (and:SI (match_dup 0) (const_int 65535)))\n+  \"reload_completed && TARGET_ZERO_EXTEND_WITH_AND && !optimize_size\"\n+  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (const_int 65535)))\n \t      (clobber (reg:CC 17))])]\n   \"\")\n \n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=q,r,r\")\n-     (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0,qm\")))\n-   (clobber (reg:CC 17))]\n+(define_insn \"*zero_extendhisi2_movzwl\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+     (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"!TARGET_ZERO_EXTEND_WITH_AND || optimize_size\"\n+  \"movz{wl|x}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"imovx\")])\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(parallel\n+    [(set (match_operand:HI 0 \"register_operand\" \"\")\n+       (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n+     (clobber (reg:CC 17))])]\n   \"\"\n-  \"*\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU1:\n-      if (!REG_P (operands[1]) || REGNO (operands[0]) != REGNO (operands[1]))\n-\tabort ();\n-      operands[1] = GEN_INT (0xff);\n-      return \\\"and{l}\\\\t{%1, %k0|%k0, %1}\\\";\n-    default:\n-      return \\\"movz{bw|x}\\\\t{%1, %0|%0, %1}\\\";\n-    }\n-}\"\n-  [(set (attr \"type\")\n-     (cond [(and (eq_attr \"alternative\" \"0\")\n-\t\t (ne (symbol_ref \"TARGET_ZERO_EXTEND_WITH_AND\")\n-\t\t     (const_int 0)))\n-\t      (const_string \"alu1\")\n-\t    (eq_attr \"alternative\" \"1\")\n-\t      (const_string \"alu1\")\n-\t   ]\n-           (const_string \"imovx\")))])\n+  \"\")\n+\n+(define_insn \"*zero_extendqihi2_and\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,?&q\")\n+     (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0,qm\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_ZERO_EXTEND_WITH_AND && !optimize_size\"\n+  \"#\"\n+  [(set_attr \"type\" \"alu1\")])\n+\n+(define_insn \"*zero_extendqihi2_movzbw_and\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+     (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"qm,0\")))\n+   (clobber (reg:CC 17))]\n+  \"!TARGET_ZERO_EXTEND_WITH_AND || optimize_size\"\n+  \"#\"\n+  [(set_attr \"type\" \"imovx,alu1\")])\n \n+(define_insn \"*zero_extendqihi2_movzbw\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+     (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n+  \"!TARGET_ZERO_EXTEND_WITH_AND || optimize_size\"\n+  \"movz{bw|x}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"imovx\")])\n+\n+;; For the movzbw case strip only the clobber\n (define_split\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"reload_completed\n-   && QI_REG_P (operands[0])\n-   && TARGET_ZERO_EXTEND_WITH_AND\n-   && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(parallel [(set (match_dup 0) (const_int 0))\n-\t      (clobber (reg:CC 17))])\n-   (set (strict_low_part (subreg:QI (match_dup 0) 0)) (match_dup 1))]\n-  \"\")\n+  \"reload_completed \n+   && (!TARGET_ZERO_EXTEND_WITH_AND || optimize_size)\n+   && (!REG_P (operands[1]) || QI_REG_P (operands[1]))\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))])\n \n+;; When source and destination does not overlap, clear destination\n+;; first and then do the movb\n (define_split\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"\")))\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC 17))]\n   \"reload_completed\n    && QI_REG_P (operands[0])\n-   && TARGET_ZERO_EXTEND_WITH_AND\n-   && reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(set (strict_low_part (subreg:QI (match_dup 0) 0)) (match_dup 1))\n-   (parallel [(set (match_dup 0) (and:HI (match_dup 0) (const_int 255)))\n-\t      (clobber (reg:CC 17))])]\n-  \"\")\n+   && (TARGET_ZERO_EXTEND_WITH_AND && !optimize_size)\n+   && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n+  [(set (match_dup 0) (const_int 0))\n+   (set (strict_low_part (match_dup 2)) (match_dup 1))]\n+  \"operands[2] = gen_lowpart (QImode, operands[0]);\")\n \n+;; Rest is handled by single and.\n (define_split\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))\n    (clobber (reg:CC 17))]\n   \"reload_completed\n-   && TARGET_ZERO_EXTEND_WITH_AND\n-   && ! reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(set (match_dup 0) (subreg:HI (match_dup 1) 0))\n-   (parallel [(set (match_dup 0) (and:HI (match_dup 0) (const_int 255)))\n+   && true_regnum (operands[0]) == true_regnum (operands[1])\"\n+  [(parallel [(set (match_dup 0) (and:HI (match_dup 0) (const_int 255)))\n \t      (clobber (reg:CC 17))])]\n   \"\")\n \n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=q,r,r\")\n-     (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0,qm\")))\n-   (clobber (reg:CC 17))]\n+(define_expand \"zero_extendqisi2\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+       (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n+     (clobber (reg:CC 17))])]\n   \"\"\n-  \"*\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU1:\n-      if (!REG_P (operands[1]) || REGNO (operands[0]) != REGNO (operands[1]))\n-\tabort ();\n-      operands[1] = GEN_INT (0xff);\n-      return \\\"and{l}\\\\t{%1, %0|%0, %1}\\\";\n-    default:\n-      return \\\"movz{bl|x}\\\\t{%1, %0|%0, %1}\\\";\n-    }\n-}\"\n-  [(set (attr \"type\")\n-     (cond [(and (eq_attr \"alternative\" \"0\")\n-\t\t (ne (symbol_ref \"TARGET_ZERO_EXTEND_WITH_AND\")\n-\t\t     (const_int 0)))\n-\t      (const_string \"alu1\")\n-\t    (eq_attr \"alternative\" \"1\")\n-\t      (const_string \"alu1\")\n-\t   ]\n-           (const_string \"imovx\")))])\n+  \"\")\n+\n+(define_insn \"*zero_extendqisi2_and\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,?&q\")\n+     (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0,qm\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_ZERO_EXTEND_WITH_AND && !optimize_size\"\n+  \"#\"\n+  [(set_attr \"type\" \"alu1\")])\n+\n+(define_insn \"*zero_extendqisi2_movzbw_and\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+     (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"qm,0\")))\n+   (clobber (reg:CC 17))]\n+  \"!TARGET_ZERO_EXTEND_WITH_AND || optimize_size\"\n+  \"#\"\n+  [(set_attr \"type\" \"imovx,alu1\")])\n \n+(define_insn \"*zero_extendqisi2_movzbw\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+     (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n+  \"(!TARGET_ZERO_EXTEND_WITH_AND || optimize_size) && reload_completed\"\n+  \"movz{bl|x}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"imovx\")])\n+\n+;; For the movzbl case strip only the clobber\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"reload_completed \n+   && (!TARGET_ZERO_EXTEND_WITH_AND || optimize_size)\n+   && (!REG_P (operands[1]) || QI_REG_P (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(zero_extend:SI (match_dup 1)))])\n+\n+;; When source and destination does not overlap, clear destination\n+;; first and then do the movb\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC 17))]\n   \"reload_completed\n-   && TARGET_ZERO_EXTEND_WITH_AND\n    && QI_REG_P (operands[0])\n-   && (GET_CODE (operands[1]) == MEM || QI_REG_P (operands[1]))\n+   && (QI_REG_P (operands[1]) || GET_CODE (operands[1]) == MEM)\n+   && (TARGET_ZERO_EXTEND_WITH_AND && !optimize_size)\n    && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(parallel [(set (match_dup 0) (const_int 0))\n-\t      (clobber (reg:CC 17))])\n-   (set (strict_low_part (subreg:QI (match_dup 0) 0)) (match_dup 1))]\n-  \"\")\n+  [(set (match_dup 0) (const_int 0))\n+   (set (strict_low_part (match_dup 2)) (match_dup 1))]\n+  \"operands[2] = gen_lowpart (QImode, operands[0]);\")\n \n+;; Rest is handled by single and.\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))\n    (clobber (reg:CC 17))]\n   \"reload_completed\n-   && TARGET_ZERO_EXTEND_WITH_AND\n-   && ! reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(set (match_dup 0) (subreg:SI (match_dup 1) 0))\n-   (parallel [(set (match_dup 0) (and:SI (match_dup 0) (const_int 255)))\n+   && true_regnum (operands[0]) == true_regnum (operands[1])\"\n+  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (const_int 255)))\n \t      (clobber (reg:CC 17))])]\n   \"\")\n "}]}