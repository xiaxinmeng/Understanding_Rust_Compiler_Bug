{"sha": "520d96c621a6acec3c5c832633a16d80e8be3ef1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwZDk2YzYyMWE2YWNlYzNjNWM4MzI2MzNhMTZkODBlOGJlM2VmMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-08-23T17:10:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-08-23T17:10:52Z"}, "message": "mips.c (mips_setup_incoming_varargs): Handle o32 and o64 as well.\n\n\t* config/mips/mips.c (mips_setup_incoming_varargs): Handle o32 and o64\n\tas well.  Put memory references in the varargs alias set.\n\t(mips_expand_prologue): Remove varargs handling from here.\n\nFrom-SVN: r70738", "tree": {"sha": "a505ea5e70b15c5476985e3ef43db00ba44f70e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a505ea5e70b15c5476985e3ef43db00ba44f70e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/520d96c621a6acec3c5c832633a16d80e8be3ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520d96c621a6acec3c5c832633a16d80e8be3ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520d96c621a6acec3c5c832633a16d80e8be3ef1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520d96c621a6acec3c5c832633a16d80e8be3ef1/comments", "author": null, "committer": null, "parents": [{"sha": "4779869270a94d9d39ae99800d943e1acf1d28fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4779869270a94d9d39ae99800d943e1acf1d28fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4779869270a94d9d39ae99800d943e1acf1d28fd"}], "stats": {"total": 138, "additions": 38, "deletions": 100}, "files": [{"sha": "bf70a0b13808e0abba50fcdba00dcc072d83f070", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520d96c621a6acec3c5c832633a16d80e8be3ef1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520d96c621a6acec3c5c832633a16d80e8be3ef1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=520d96c621a6acec3c5c832633a16d80e8be3ef1", "patch": "@@ -1,3 +1,9 @@\n+2003-08-23  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_setup_incoming_varargs): Handle o32 and o64\n+\tas well.  Put memory references in the varargs alias set.\n+\t(mips_expand_prologue): Remove varargs handling from here.\n+\n 2003-08-23  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (s390_expand_movstr, s390_expand_clrstr,"}, {"sha": "5f882c2680c66ebed30ad4c547c14083b0a6340e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 32, "deletions": 100, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520d96c621a6acec3c5c832633a16d80e8be3ef1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520d96c621a6acec3c5c832633a16d80e8be3ef1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=520d96c621a6acec3c5c832633a16d80e8be3ef1", "patch": "@@ -3823,9 +3823,6 @@ mips_setup_incoming_varargs (const CUMULATIVE_ARGS *cum,\n   CUMULATIVE_ARGS local_cum;\n   int gp_saved, fp_saved;\n \n-  if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n-    return 0;\n-\n   /* The caller has advanced CUM up to, but not beyond, the last named\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n@@ -3846,19 +3843,22 @@ mips_setup_incoming_varargs (const CUMULATIVE_ARGS *cum,\n \t  rtx ptr, mem;\n \n \t  ptr = virtual_incoming_args_rtx;\n-\t  if (mips_abi == ABI_EABI)\n-\t    ptr = plus_constant (ptr, -gp_saved * UNITS_PER_WORD);\n-\t  mem = gen_rtx_MEM (BLKmode, ptr);\n+\t  switch (mips_abi)\n+\t    {\n+\t    case ABI_32:\n+\t    case ABI_O64:\n+\t      ptr = plus_constant (ptr, local_cum.num_gprs * UNITS_PER_WORD);\n+\t      break;\n \n-\t  /* va_arg is an array access in this case, which causes\n-\t     it to get MEM_IN_STRUCT_P set.  We must set it here\n-\t     so that the insn scheduler won't assume that these\n-\t     stores can't possibly overlap with the va_arg loads.  */\n-\t  if (mips_abi != ABI_EABI && BYTES_BIG_ENDIAN)\n-\t    MEM_SET_IN_STRUCT_P (mem, 1);\n+\t    case ABI_EABI:\n+\t      ptr = plus_constant (ptr, -gp_saved * UNITS_PER_WORD);\n+\t      break;\n+\t    }\n+\t  mem = gen_rtx_MEM (BLKmode, ptr);\n+\t  set_mem_alias_set (mem, get_varargs_alias_set ());\n \n-\t  move_block_from_reg (local_cum.num_gprs + GP_ARG_FIRST, mem,\n-\t\t\t       gp_saved);\n+\t  move_block_from_reg (local_cum.num_gprs + GP_ARG_FIRST,\n+\t\t\t       mem, gp_saved);\n \t}\n       if (fp_saved > 0)\n \t{\n@@ -3878,13 +3878,20 @@ mips_setup_incoming_varargs (const CUMULATIVE_ARGS *cum,\n \n \t  for (i = local_cum.num_fprs; i < MAX_ARGS_IN_REGISTERS; i += FP_INC)\n \t    {\n-\t      rtx ptr = plus_constant (virtual_incoming_args_rtx, off);\n-\t      emit_move_insn (gen_rtx_MEM (mode, ptr),\n-\t\t\t      gen_rtx_REG (mode, FP_ARG_FIRST + i));\n+\t      rtx ptr, mem;\n+\n+\t      ptr = plus_constant (virtual_incoming_args_rtx, off);\n+\t      mem = gen_rtx_MEM (mode, ptr);\n+\t      set_mem_alias_set (mem, get_varargs_alias_set ());\n+\t      emit_move_insn (mem, gen_rtx_REG (mode, FP_ARG_FIRST + i));\n \t      off += UNITS_PER_HWFPVALUE;\n \t    }\n \t}\n     }\n+  if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n+    /* No need for pretend arguments: the register parameter area was\n+       allocated by the caller.  */\n+    return 0;\n   return (gp_saved * UNITS_PER_WORD) + (fp_saved * UNITS_PER_FPREG);\n }\n \n@@ -6704,21 +6711,16 @@ mips_gp_insn (rtx dest, rtx src)\n void\n mips_expand_prologue (void)\n {\n-  int regno;\n   HOST_WIDE_INT tsize;\n   rtx tmp_rtx = 0;\n-  int last_arg_is_vararg_marker = 0;\n   tree fndecl = current_function_decl;\n   tree fntype = TREE_TYPE (fndecl);\n   tree fnargs = DECL_ARGUMENTS (fndecl);\n   rtx next_arg_reg;\n   int i;\n-  tree next_arg;\n   tree cur_arg;\n   CUMULATIVE_ARGS args_so_far;\n   rtx reg_18_save = NULL_RTX;\n-  int store_args_on_stack = (mips_abi == ABI_32 || mips_abi == ABI_O64)\n-                            && (! mips_entry || mips_can_use_return_insn ());\n \n   if (cfun->machine->global_pointer > 0)\n     REGNO (pic_offset_table_rtx) = cfun->machine->global_pointer;\n@@ -6736,71 +6738,23 @@ mips_expand_prologue (void)\n       fnargs = function_result_decl;\n     }\n \n-  /* For arguments passed in registers, find the register number\n-     of the first argument in the variable part of the argument list,\n-     otherwise GP_ARG_LAST+1.  Note also if the last argument is\n-     the varargs special argument, and treat it as part of the\n-     variable arguments.\n-\n-     This is only needed if store_args_on_stack is true.  */\n-\n+  /* Go through the function arguments, leaving args_so_far reflecting\n+     the final state.  */\n   INIT_CUMULATIVE_ARGS (args_so_far, fntype, NULL_RTX, current_function_decl);\n-  regno = GP_ARG_FIRST;\n-\n-  for (cur_arg = fnargs; cur_arg != 0; cur_arg = next_arg)\n+  for (cur_arg = fnargs; cur_arg != 0; cur_arg = TREE_CHAIN (cur_arg))\n     {\n-      tree passed_type = DECL_ARG_TYPE (cur_arg);\n-      enum machine_mode passed_mode = TYPE_MODE (passed_type);\n-      rtx entry_parm;\n+      tree passed_type;\n+      enum machine_mode passed_mode;\n \n+      passed_type = DECL_ARG_TYPE (cur_arg);\n       if (TREE_ADDRESSABLE (passed_type))\n \t{\n \t  passed_type = build_pointer_type (passed_type);\n \t  passed_mode = Pmode;\n \t}\n-\n-      entry_parm = FUNCTION_ARG (args_so_far, passed_mode, passed_type, 1);\n-\n-      FUNCTION_ARG_ADVANCE (args_so_far, passed_mode, passed_type, 1);\n-      next_arg = TREE_CHAIN (cur_arg);\n-\n-      if (entry_parm && store_args_on_stack)\n-\t{\n-\t  if (next_arg == 0\n-\t      && DECL_NAME (cur_arg)\n-\t      && ((0 == strcmp (IDENTIFIER_POINTER (DECL_NAME (cur_arg)),\n-\t\t\t\t\"__builtin_va_alist\"))\n-\t\t  || (0 == strcmp (IDENTIFIER_POINTER (DECL_NAME (cur_arg)),\n-\t\t\t\t   \"va_alist\"))))\n-\t    {\n-\t      last_arg_is_vararg_marker = 1;\n-\t      if (GET_CODE (entry_parm) == REG)\n-\t\tregno = REGNO (entry_parm);\n-\t      else\n-\t\tregno = GP_ARG_LAST + 1;\n-\t      break;\n-\t    }\n-\t  else\n-\t    {\n-\t      int words;\n-\n-\t      if (GET_CODE (entry_parm) != REG)\n-\t        abort ();\n-\n-\t      /* passed in a register, so will get homed automatically */\n-\t      if (GET_MODE (entry_parm) == BLKmode)\n-\t\twords = (int_size_in_bytes (passed_type) + 3) / 4;\n-\t      else\n-\t\twords = (GET_MODE_SIZE (GET_MODE (entry_parm)) + 3) / 4;\n-\n-\t      regno = REGNO (entry_parm) + words - 1;\n-\t    }\n-\t}\n       else\n-\t{\n-\t  regno = GP_ARG_LAST+1;\n-\t  break;\n-\t}\n+\tpassed_mode = TYPE_MODE (passed_type);\n+      FUNCTION_ARG_ADVANCE (args_so_far, passed_mode, passed_type, 1);\n     }\n \n   /* In order to pass small structures by value in registers compatibly with\n@@ -6838,28 +6792,6 @@ mips_expand_prologue (void)\n \n   tsize = compute_frame_size (get_frame_size ());\n \n-  /* If this function is a varargs function, store any registers that\n-     would normally hold arguments ($4 - $7) on the stack.  */\n-  if (store_args_on_stack\n-      && ((TYPE_ARG_TYPES (fntype) != 0\n-\t   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n-\t       != void_type_node))\n-\t  || last_arg_is_vararg_marker))\n-    {\n-      int offset = (regno - GP_ARG_FIRST) * UNITS_PER_WORD;\n-      rtx ptr = stack_pointer_rtx;\n-\n-      for (; regno <= GP_ARG_LAST; regno++)\n-\t{\n-\t  if (offset != 0)\n-\t    ptr = gen_rtx (PLUS, Pmode, stack_pointer_rtx, GEN_INT (offset));\n-\t  emit_move_insn (gen_rtx (MEM, gpr_mode, ptr),\n-\t\t\t  gen_rtx (REG, gpr_mode, regno));\n-\n-\t  offset += GET_MODE_SIZE (gpr_mode);\n-\t}\n-    }\n-\n   /* If we are using the entry pseudo instruction, it will\n      automatically subtract 32 from the stack pointer, so we don't\n      need to.  The entry pseudo instruction is emitted by"}]}