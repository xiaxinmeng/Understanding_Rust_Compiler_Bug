{"sha": "13a1ac9f6f700f4e214fcc83b122a4a405c6b13d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNhMWFjOWY2ZjcwMGY0ZTIxNGZjYzgzYjEyMmE0YTQwNWM2YjEzZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-08-03T13:00:47Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-08-03T14:30:36Z"}, "message": "libstdc++: Specialize allocator_traits<pmr::polymorphic_allocator<T>>\n\nThis adds a partial specialization of allocator_traits, similar to what\nwas already done for std::allocator. This means that most uses of\npolymorphic_allocator via the traits can avoid the metaprogramming\noverhead needed to deduce the properties from polymorphic_allocator.\n\nIn addition, I'm changing polymorphic_allocator::delete_object to invoke\nthe destructor (or pseudo-destructor) directly, rather than calling\nallocator_traits::destroy, which calls polymorphic_allocator::destroy\n(which is deprecated). This is observable if a user has specialized\nallocator_traits<polymorphic_allocator<Foo>> and expects to see its\ndestroy member function called. I consider explicit specializations of\nallocator_traits to be wrong-headed, and this use case seems unnecessary\nto support. So delete_object just invokes the destructor directly.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/memory_resource (polymorphic_allocator::delete_object):\n\tCall destructor directly instead of using destroy.\n\t(allocator_traits<polymorphic_allocator<T>>): Define partial\n\tspecialization.", "tree": {"sha": "a09d223b37dea4182bfd8a16f7ec75a639c4553c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a09d223b37dea4182bfd8a16f7ec75a639c4553c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13a1ac9f6f700f4e214fcc83b122a4a405c6b13d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a1ac9f6f700f4e214fcc83b122a4a405c6b13d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a1ac9f6f700f4e214fcc83b122a4a405c6b13d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a1ac9f6f700f4e214fcc83b122a4a405c6b13d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bd87e388724baab9597ef232ea7e855c99eb7d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bd87e388724baab9597ef232ea7e855c99eb7d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bd87e388724baab9597ef232ea7e855c99eb7d7"}], "stats": {"total": 132, "additions": 131, "deletions": 1}, "files": [{"sha": "6bca0afa018074ba747fc0b4eb3699afbc615920", "filename": "libstdc++-v3/include/std/memory_resource", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13a1ac9f6f700f4e214fcc83b122a4a405c6b13d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13a1ac9f6f700f4e214fcc83b122a4a405c6b13d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=13a1ac9f6f700f4e214fcc83b122a4a405c6b13d", "patch": "@@ -232,7 +232,7 @@ namespace pmr\n \tvoid\n \tdelete_object(_Up* __p)\n \t{\n-\t  destroy(__p);\n+\t  __p->~_Up();\n \t  deallocate_object(__p);\n \t}\n #endif // C++2a\n@@ -381,6 +381,136 @@ namespace pmr\n     { return !(__a == __b); }\n #endif\n \n+} // namespace pmr\n+\n+  /// Partial specialization for std::pmr::polymorphic_allocator\n+  template<typename _Tp>\n+    struct allocator_traits<pmr::polymorphic_allocator<_Tp>>\n+    {\n+      /// The allocator type\n+      using allocator_type = pmr::polymorphic_allocator<_Tp>;\n+\n+      /// The allocated type\n+      using value_type = _Tp;\n+\n+      /// The allocator's pointer type.\n+      using pointer = _Tp*;\n+\n+      /// The allocator's const pointer type.\n+      using const_pointer = const _Tp*;\n+\n+      /// The allocator's void pointer type.\n+      using void_pointer = void*;\n+\n+      /// The allocator's const void pointer type.\n+      using const_void_pointer = const void*;\n+\n+      /// The allocator's difference type\n+      using difference_type = std::ptrdiff_t;\n+\n+      /// The allocator's size type\n+      using size_type = std::size_t;\n+\n+      /** @{\n+       * A `polymorphic_allocator` does not propagate when a\n+       * container is copied, moved, or swapped.\n+       */\n+      using propagate_on_container_copy_assignment = false_type;\n+      using propagate_on_container_move_assignment = false_type;\n+      using propagate_on_container_swap = false_type;\n+\n+      static allocator_type\n+      select_on_container_copy_construction(const allocator_type&) noexcept\n+      { return allocator_type(); }\n+      /// @}\n+\n+      /// Whether all instances of the allocator type compare equal.\n+      using is_always_equal = false_type;\n+\n+      template<typename _Up>\n+\tusing rebind_alloc = pmr::polymorphic_allocator<_Up>;\n+\n+      template<typename _Up>\n+\tusing rebind_traits = allocator_traits<pmr::polymorphic_allocator<_Up>>;\n+\n+      /**\n+       *  @brief  Allocate memory.\n+       *  @param  __a  An allocator.\n+       *  @param  __n  The number of objects to allocate space for.\n+       *\n+       *  Calls `a.allocate(n)`.\n+      */\n+      [[nodiscard]] static pointer\n+      allocate(allocator_type& __a, size_type __n)\n+      { return __a.allocate(__n); }\n+\n+      /**\n+       *  @brief  Allocate memory.\n+       *  @param  __a  An allocator.\n+       *  @param  __n  The number of objects to allocate space for.\n+       *  @return Memory of suitable size and alignment for `n` objects\n+       *          of type `value_type`.\n+       *\n+       *  The third parameter is ignored..\n+       *\n+       *  Returns `a.allocate(n)`.\n+      */\n+      [[nodiscard]] static pointer\n+      allocate(allocator_type& __a, size_type __n, const_void_pointer)\n+      { return __a.allocate(__n); }\n+\n+      /**\n+       *  @brief  Deallocate memory.\n+       *  @param  __a  An allocator.\n+       *  @param  __p  Pointer to the memory to deallocate.\n+       *  @param  __n  The number of objects space was allocated for.\n+       *\n+       *  Calls `a.deallocate(p, n)`.\n+      */\n+      static void\n+      deallocate(allocator_type& __a, pointer __p, size_type __n)\n+      { __a.deallocate(__p, __n); }\n+\n+      /**\n+       *  @brief  Construct an object of type `_Up`\n+       *  @param  __a  An allocator.\n+       *  @param  __p  Pointer to memory of suitable size and alignment for\n+       *\t       an object of type `_Up`.\n+       *  @param  __args Constructor arguments.\n+       *\n+       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`\n+       *  in C++11, C++14 and C++17. Changed in C++20 to call\n+       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.\n+      */\n+      template<typename _Up, typename... _Args>\n+\tstatic void\n+\tconstruct(allocator_type& __a, _Up* __p, _Args&&... __args)\n+\t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief  Destroy an object of type `_Up`\n+       *  @param  __a  An allocator.\n+       *  @param  __p  Pointer to the object to destroy\n+       *\n+       *  Calls `p->_Up()`.\n+      */\n+      template<typename _Up>\n+\tstatic _GLIBCXX20_CONSTEXPR void\n+\tdestroy(allocator_type&, _Up* __p)\n+\tnoexcept(is_nothrow_destructible<_Up>::value)\n+\t{ __p->~_Up(); }\n+\n+      /**\n+       *  @brief  The maximum supported allocation size\n+       *  @return `numeric_limits<size_t>::max() / sizeof(value_type)`\n+      */\n+      static _GLIBCXX20_CONSTEXPR size_type\n+      max_size(const allocator_type&) noexcept\n+      { return size_t(-1) / sizeof(value_type); }\n+    };\n+\n+namespace pmr\n+{\n   /// Parameters for tuning a pool resource's behaviour.\n   struct pool_options\n   {"}]}