{"sha": "9d36bd3b1763035447bf201542545e8b5dcf962d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQzNmJkM2IxNzYzMDM1NDQ3YmYyMDE1NDI1NDVlOGI1ZGNmOTYyZA==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2018-08-30T18:17:00Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2018-08-30T18:17:00Z"}, "message": "altivec.md (altivec_eq<mode>): Remove star.\n\n2018-08-30  Aaron Sawdey  <acsawdey@linux.ibm.com>\n\n\t* config/rs6000/altivec.md (altivec_eq<mode>): Remove star.\n\t(altivec_vcmpequ<VI_char>_p): Remove star.\n\t* config/rs6000/rs6000-string.c (do_load_for_compare): Support\n\tvector load modes.\n\t(expand_strncmp_vec_sequence): New function.\n\t(emit_final_str_compare_vec): New function.\n\t(expand_strn_compare): Add support for vector strncmp.\n\t* config/rs6000/rs6000.opt (-mstring-compare-inline-limit): Change\n\tlength specification to bytes.\n\t* config/rs6000/vsx.md (vsx_ld_elemrev_v16qi_internal): Remove star.\n\t(vcmpnezb_p): New pattern.\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Update documentation\n\tfor option -mstring-compare-inline-limit.\n\nFrom-SVN: r263991", "tree": {"sha": "a111c8a34b9ff4190fe80a6d9a1bf4f01d4a8482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a111c8a34b9ff4190fe80a6d9a1bf4f01d4a8482"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d36bd3b1763035447bf201542545e8b5dcf962d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d36bd3b1763035447bf201542545e8b5dcf962d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d36bd3b1763035447bf201542545e8b5dcf962d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d36bd3b1763035447bf201542545e8b5dcf962d/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a73e818148ff2aa784a6691ec2d021ed07787e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a73e818148ff2aa784a6691ec2d021ed07787e48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a73e818148ff2aa784a6691ec2d021ed07787e48"}], "stats": {"total": 446, "additions": 406, "deletions": 40}, "files": [{"sha": "5b49b2ae1c391c629fd1e256b336927fe5d4728e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d36bd3b1763035447bf201542545e8b5dcf962d", "patch": "@@ -1,3 +1,19 @@\n+2018-08-30  Aaron Sawdey  <acsawdey@linux.ibm.com>\n+\n+\t* config/rs6000/altivec.md (altivec_eq<mode>): Remove star.\n+\t(altivec_vcmpequ<VI_char>_p): Remove star.\n+\t* config/rs6000/rs6000-string.c (do_load_for_compare): Support\n+\tvector load modes.\n+\t(expand_strncmp_vec_sequence): New function.\n+\t(emit_final_str_compare_vec): New function.\n+\t(expand_strn_compare): Add support for vector strncmp.\n+\t* config/rs6000/rs6000.opt (-mstring-compare-inline-limit): Change\n+\tlength specification to bytes.\n+\t* config/rs6000/vsx.md (vsx_ld_elemrev_v16qi_internal): Remove star.\n+\t(vcmpnezb_p): New pattern.\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Update documentation\n+\tfor option -mstring-compare-inline-limit.\n+\n 2018-08-30  Thiago Macieira  <thiago.macieira@intel.com>\n \n \t* config/i386/i386.c (PTA_WESTMERE): Remove PTA_AES."}, {"sha": "1ddf58026071baabdc58fcfaf719c04481f7563b", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=9d36bd3b1763035447bf201542545e8b5dcf962d", "patch": "@@ -603,7 +603,7 @@\n   \"vcmpbfp %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n-(define_insn \"*altivec_eq<mode>\"\n+(define_insn \"altivec_eq<mode>\"\n   [(set (match_operand:VI2 0 \"altivec_register_operand\" \"=v\")\n \t(eq:VI2 (match_operand:VI2 1 \"altivec_register_operand\" \"v\")\n \t\t(match_operand:VI2 2 \"altivec_register_operand\" \"v\")))]\n@@ -2304,7 +2304,7 @@\n \n ;; Compare vectors producing a vector result and a predicate, setting CR6 to\n ;; indicate a combined status\n-(define_insn \"*altivec_vcmpequ<VI_char>_p\"\n+(define_insn \"altivec_vcmpequ<VI_char>_p\"\n   [(set (reg:CC CR6_REGNO)\n \t(unspec:CC [(eq:CC (match_operand:VI2 1 \"register_operand\" \"v\")\n \t\t\t   (match_operand:VI2 2 \"register_operand\" \"v\"))]"}, {"sha": "ff0414586d0f44dde146bccf5711f7be87ac4e3b", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 366, "deletions": 30, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=9d36bd3b1763035447bf201542545e8b5dcf962d", "patch": "@@ -157,6 +157,33 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n {\n   switch (GET_MODE (reg))\n     {\n+    case E_V16QImode:\n+      switch (mode)\n+\t{\n+\tcase E_V16QImode:\n+\t  if (!BYTES_BIG_ENDIAN)\n+\t    {\n+\t      if (TARGET_P9_VECTOR)\n+\t\temit_insn (gen_vsx_ld_elemrev_v16qi_internal (reg, mem));\n+\t      else\n+\t\t{\n+\t\t  rtx reg_v2di = simplify_gen_subreg (V2DImode, reg,\n+\t\t\t\t\t\t      V16QImode, 0);\n+\t\t  gcc_assert (MEM_P (mem));\n+\t\t  rtx addr = XEXP (mem, 0);\n+\t\t  rtx mem_v2di = gen_rtx_MEM (V2DImode, addr);\n+\t\t  MEM_COPY_ATTRIBUTES (mem_v2di, mem);\n+\t\t  set_mem_size (mem, GET_MODE_SIZE (V2DImode));\n+\t\t  emit_insn (gen_vsx_ld_elemrev_v2di (reg_v2di, mem_v2di));\n+\t\t}\n+\t    }\n+\t  else\n+\t    emit_insn (gen_vsx_movv2di_64bit (reg, mem));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n     case E_DImode:\n       switch (mode)\n \t{\n@@ -227,6 +254,12 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t  gcc_unreachable ();\n \t}\n       break;\n+\n+    case E_QImode:\n+      gcc_assert (mode == E_QImode);\n+      emit_move_insn (reg, mem);\n+      break;\n+      \n     default:\n       gcc_unreachable ();\n       break;\n@@ -1705,17 +1738,17 @@ expand_strncmp_align_check (rtx strncmp_label, rtx src_addr, HOST_WIDE_INT bytes\n    RESULT_REG is the rtx for the result register.\n    EQUALITY_COMPARE_REST is a flag to indicate we need to make a cleanup call\n    to strcmp/strncmp if we have equality at the end of the inline comparison.\n-   CLEANUP_LABEL is rtx for a label we generate if we need code to clean up\n-   and generate the final comparison result.\n+   P_CLEANUP_LABEL is a pointer to rtx for a label we generate if we need code\n+   to clean up and generate the final comparison result.\n    FINAL_MOVE_LABEL is rtx for a label we can branch to when we can just \n    set the final result.  */\n static void\n-expand_strncmp_gpr_sequence(unsigned HOST_WIDE_INT bytes_to_compare,\n-\t\t\t    unsigned int base_align,\n-\t\t\t    rtx orig_src1, rtx orig_src2,\n-\t\t\t    rtx tmp_reg_src1, rtx tmp_reg_src2, rtx result_reg,\n-\t\t\t    bool equality_compare_rest, rtx &cleanup_label,\n-\t\t\t    rtx final_move_label)\n+expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n+\t\t\t     unsigned int base_align,\n+\t\t\t     rtx orig_src1, rtx orig_src2,\n+\t\t\t     rtx tmp_reg_src1, rtx tmp_reg_src2, rtx result_reg,\n+\t\t\t     bool equality_compare_rest, rtx *p_cleanup_label,\n+\t\t\t     rtx final_move_label)\n {\n   unsigned int word_mode_size = GET_MODE_SIZE (word_mode);\n   machine_mode load_mode;\n@@ -1724,6 +1757,8 @@ expand_strncmp_gpr_sequence(unsigned HOST_WIDE_INT bytes_to_compare,\n   unsigned HOST_WIDE_INT offset = 0;\n   rtx src1_addr = force_reg (Pmode, XEXP (orig_src1, 0));\n   rtx src2_addr = force_reg (Pmode, XEXP (orig_src2, 0));\n+  gcc_assert (p_cleanup_label != NULL);\n+  rtx cleanup_label = *p_cleanup_label;\n \n   while (bytes_to_compare > 0)\n     {\n@@ -1876,6 +1911,178 @@ expand_strncmp_gpr_sequence(unsigned HOST_WIDE_INT bytes_to_compare,\n       bytes_to_compare -= cmp_bytes;\n     }\n \n+  *p_cleanup_label = cleanup_label;\n+  return;\n+}\n+\n+/* Generate the sequence of compares for strcmp/strncmp using vec/vsx \n+   instructions.\n+\n+   BYTES_TO_COMPARE is the number of bytes to be compared.\n+   ORIG_SRC1 is the unmodified rtx for the first string.\n+   ORIG_SRC2 is the unmodified rtx for the second string.\n+   S1ADDR is the register to use for the base address of the first string.\n+   S2ADDR is the register to use for the base address of the second string.\n+   OFF_REG is the register to use for the string offset for loads.\n+   S1DATA is the register for loading the first string.\n+   S2DATA is the register for loading the second string.\n+   VEC_RESULT is the rtx for the vector result indicating the byte difference.\n+   EQUALITY_COMPARE_REST is a flag to indicate we need to make a cleanup call\n+   to strcmp/strncmp if we have equality at the end of the inline comparison.\n+   P_CLEANUP_LABEL is a pointer to rtx for a label we generate if we need code to clean up\n+   and generate the final comparison result.\n+   FINAL_MOVE_LABEL is rtx for a label we can branch to when we can just \n+   set the final result.  */\n+static void\n+expand_strncmp_vec_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n+\t\t\t     rtx orig_src1, rtx orig_src2,\n+\t\t\t     rtx s1addr, rtx s2addr, rtx off_reg,\n+\t\t\t     rtx s1data, rtx s2data,\n+\t\t\t     rtx vec_result, bool equality_compare_rest,\n+\t\t\t     rtx *p_cleanup_label, rtx final_move_label)\n+{\n+  machine_mode load_mode;\n+  unsigned int load_mode_size;\n+  unsigned HOST_WIDE_INT cmp_bytes = 0;\n+  unsigned HOST_WIDE_INT offset = 0;\n+\n+  gcc_assert (p_cleanup_label != NULL);\n+  rtx cleanup_label = *p_cleanup_label;\n+\n+  emit_move_insn (s1addr, force_reg (Pmode, XEXP (orig_src1, 0)));\n+  emit_move_insn (s2addr, force_reg (Pmode, XEXP (orig_src2, 0)));\n+\n+  unsigned int i;\n+  rtx zr[16];\n+  for (i = 0; i < 16; i++)\n+    zr[i] = GEN_INT (0);\n+  rtvec zv = gen_rtvec_v (16, zr);\n+  rtx zero_reg = gen_reg_rtx (V16QImode);\n+  rs6000_expand_vector_init (zero_reg, gen_rtx_PARALLEL (V16QImode, zv));\n+\n+  while (bytes_to_compare > 0)\n+    {\n+      /* VEC/VSX compare sequence for P8:\n+\t check each 16B with:\n+\t lxvd2x 32,28,8\n+\t lxvd2x 33,29,8\n+\t vcmpequb 2,0,1  # compare strings\n+\t vcmpequb 4,0,3  # compare w/ 0\n+\t xxlorc 37,36,34       # first FF byte is either mismatch or end of string\n+\t vcmpequb. 7,5,3  # reg 7 contains 0\n+\t bnl 6,.Lmismatch\n+\n+\t For the P8 LE case, we use lxvd2x and compare full 16 bytes\n+\t but then use use vgbbd and a shift to get two bytes with the\n+\t information we need in the correct order.\n+\n+\t VEC/VSX compare sequence if TARGET_P9_VECTOR:\n+\t lxvb16x/lxvb16x     # load 16B of each string\n+\t vcmpnezb.           # produces difference location or zero byte location\n+\t bne 6,.Lmismatch\n+\n+\t Use the overlapping compare trick for the last block if it is\n+\t less than 16 bytes. \n+      */\n+\n+      load_mode = V16QImode;\n+      load_mode_size = GET_MODE_SIZE (load_mode);\n+      \n+      if (bytes_to_compare >= load_mode_size)\n+\tcmp_bytes = load_mode_size;\n+      else\n+\t{\n+\t  /* Move this load back so it doesn't go past the end.  P8/P9\n+\t     can do this efficiently.  This is never called with less\n+\t     than 16 bytes so we should always be able to do this.  */\n+\t  unsigned int extra_bytes = load_mode_size - bytes_to_compare;\n+\t  cmp_bytes = bytes_to_compare;\n+\t  gcc_assert (offset > extra_bytes);\n+\t  offset -= extra_bytes;\n+\t  cmp_bytes = load_mode_size;\n+\t  bytes_to_compare = cmp_bytes;\n+\t}\n+\n+      /* The offset currently used is always kept in off_reg so that the\n+\t cleanup code on P8 can use it to extract the differing byte.  */\n+      emit_move_insn (off_reg, GEN_INT (offset));\n+\n+      rtx addr1 = gen_rtx_PLUS (Pmode, s1addr, off_reg);\n+      do_load_for_compare_from_addr (load_mode, s1data, addr1, orig_src1);\n+      rtx addr2 = gen_rtx_PLUS (Pmode, s2addr, off_reg);\n+      do_load_for_compare_from_addr (load_mode, s2data, addr2, orig_src2);\n+\n+      /* Cases to handle.  A and B are chunks of the two strings.\n+\t 1: Not end of comparison:\n+\t A != B: branch to cleanup code to compute result.\n+\t A == B: next block\n+\t 2: End of the inline comparison:\n+\t A != B: branch to cleanup code to compute result.\n+\t A == B: call strcmp/strncmp\n+\t 3: compared requested N bytes:\n+\t A == B: branch to result 0.\n+\t A != B: cleanup code to compute result.  */\n+\n+      unsigned HOST_WIDE_INT remain = bytes_to_compare - cmp_bytes;\n+\n+      if (TARGET_P9_VECTOR)\n+\temit_insn (gen_vcmpnezb_p (vec_result, s1data, s2data));\n+      else\n+\t{\n+\t  /* Emit instructions to do comparison and zero check.  */\n+\t  rtx cmp_res = gen_reg_rtx (load_mode);\n+\t  rtx cmp_zero = gen_reg_rtx (load_mode);\n+\t  rtx cmp_combined = gen_reg_rtx (load_mode);\n+\t  emit_insn (gen_altivec_eqv16qi (cmp_res, s1data, s2data));\n+\t  emit_insn (gen_altivec_eqv16qi (cmp_zero, s1data, zero_reg));\n+\t  emit_insn (gen_orcv16qi3 (vec_result, cmp_zero, cmp_res));\n+\t  emit_insn (gen_altivec_vcmpequb_p (cmp_combined, vec_result, zero_reg));\n+\t}\n+\n+      bool branch_to_cleanup = (remain > 0 || equality_compare_rest);\n+      rtx cr6 = gen_rtx_REG (CCmode, CR6_REGNO);\n+      rtx dst_label;\n+      rtx cmp_rtx;\n+      if (branch_to_cleanup)\n+\t{\n+\t  /* Branch to cleanup code, otherwise fall through to do more\n+\t     compares. P8 and P9 use different CR bits because on P8\n+\t     we are looking at the result of a comparsion vs a\n+\t     register of zeroes so the all-true condition means no\n+\t     difference or zero was found. On P9, vcmpnezb sets a byte\n+\t     to 0xff if there is a mismatch or zero, so the all-false\n+\t     condition indicates we found no difference or zero.  */\n+\t  if (!cleanup_label)\n+\t    cleanup_label = gen_label_rtx ();\n+\t  dst_label = cleanup_label;\n+\t  if (TARGET_P9_VECTOR)\n+\t    cmp_rtx = gen_rtx_NE (VOIDmode, cr6, const0_rtx);\n+\t  else\n+\t    cmp_rtx = gen_rtx_GE (VOIDmode, cr6, const0_rtx);\n+\t}\n+      else\n+\t{\n+\t  /* Branch to final return or fall through to cleanup, \n+\t     result is already set to 0.  */\n+\t  dst_label = final_move_label;\n+\t  if (TARGET_P9_VECTOR)\n+\t    cmp_rtx = gen_rtx_EQ (VOIDmode, cr6, const0_rtx);\n+\t  else\n+\t    cmp_rtx = gen_rtx_LT (VOIDmode, cr6, const0_rtx);\n+\t}\n+\n+      rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, dst_label);\n+      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n+\t\t\t\t\t lab_ref, pc_rtx);\n+      rtx j2 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+      JUMP_LABEL (j2) = dst_label;\n+      LABEL_NUSES (dst_label) += 1;\n+\n+      offset += cmp_bytes;\n+      bytes_to_compare -= cmp_bytes;\n+    }\n+  *p_cleanup_label = cleanup_label;\n+  return;\n }\n \n /* Generate the final sequence that identifies the differing\n@@ -1948,6 +2155,96 @@ emit_final_str_compare_gpr (rtx str1, rtx str2, rtx result)\n   return;\n }\n \n+/* Generate the final sequence that identifies the differing\n+   byte and generates the final result, taking into account\n+   zero bytes:\n+\n+   P8:\n+        vgbbd 0,0\n+        vsldoi 0,0,0,9\n+        mfvsrd 9,32\n+        addi 10,9,-1    # count trailing zero bits\n+        andc 9,10,9\n+        popcntd 9,9\n+        lbzx 10,28,9    # use that offset to load differing byte\n+        lbzx 3,29,9\n+        subf 3,3,10     # subtract for final result\n+   \n+   P9:\n+\t vclzlsbb            # counts trailing bytes with lsb=0\n+\t vextublx            # extract differing byte \n+\n+   STR1 is the reg rtx for data from string 1.\n+   STR2 is the reg rtx for data from string 2.\n+   RESULT is the reg rtx for the comparison result.\n+   S1ADDR is the register to use for the base address of the first string.\n+   S2ADDR is the register to use for the base address of the second string.\n+   ORIG_SRC1 is the unmodified rtx for the first string.\n+   ORIG_SRC2 is the unmodified rtx for the second string.\n+   OFF_REG is the register to use for the string offset for loads.\n+   VEC_RESULT is the rtx for the vector result indicating the byte difference.\n+  */\n+\n+static void\n+emit_final_str_compare_vec (rtx str1, rtx str2, rtx result,\n+\t\t\t    rtx s1addr, rtx s2addr,\n+\t\t\t    rtx orig_src1, rtx orig_src2,\n+\t\t\t    rtx off_reg, rtx vec_result)\n+{\n+  if (TARGET_P9_VECTOR)\n+    {\n+      rtx diffix = gen_reg_rtx (SImode);\n+      rtx chr1 = gen_reg_rtx (SImode);\n+      rtx chr2 = gen_reg_rtx (SImode);\n+      rtx chr1_di = simplify_gen_subreg (DImode, chr1, SImode, 0);\n+      rtx chr2_di = simplify_gen_subreg (DImode, chr2, SImode, 0);\n+      emit_insn (gen_vclzlsbb_v16qi (diffix, vec_result));\n+      emit_insn (gen_vextublx (chr1, diffix, str1));\n+      emit_insn (gen_vextublx (chr2, diffix, str2));\n+      do_sub3 (result, chr1_di, chr2_di);\n+    }\n+  else\n+    {\n+      rtx diffix = gen_reg_rtx (DImode);\n+      rtx result_gbbd = gen_reg_rtx (V16QImode);\n+      /* Since each byte of the input is either 00 or FF, the bytes in \n+\t dw0 and dw1 after vgbbd are all identical to each other.  */\n+      emit_insn (gen_p8v_vgbbd (result_gbbd, vec_result));\n+      /* For LE, we shift by 9 and get BA in the low two bytes then CTZ.\n+\t For BE, we shift by 7 and get AB in the high two bytes then CLZ.  */\n+      rtx result_shifted = gen_reg_rtx (V16QImode);\n+      int shift_amt = (BYTES_BIG_ENDIAN) ? 7 : 9;\n+      emit_insn (gen_altivec_vsldoi_v16qi (result_shifted,result_gbbd,result_gbbd, GEN_INT (shift_amt)));\n+\n+      rtx diffix_df = simplify_gen_subreg (DFmode, diffix, DImode, 0);\n+      emit_insn (gen_p8_mfvsrd_3_v16qi (diffix_df, result_shifted));\n+      rtx count = gen_reg_rtx (DImode);\n+\n+      if (BYTES_BIG_ENDIAN)\n+\temit_insn (gen_clzdi2 (count, diffix));\n+      else\n+\temit_insn (gen_ctzdi2 (count, diffix));\n+\n+      /* P8 doesn't have a good solution for extracting one byte from \n+\t a vsx reg like vextublx on P9 so we just compute the offset\n+\t of the differing byte and load it from each string.  */\n+      do_add3 (off_reg, off_reg, count);\n+\n+      rtx chr1 = gen_reg_rtx (QImode);\n+      rtx chr2 = gen_reg_rtx (QImode);\n+      rtx addr1 = gen_rtx_PLUS (Pmode, s1addr, off_reg);\n+      do_load_for_compare_from_addr (QImode, chr1, addr1, orig_src1);\n+      rtx addr2 = gen_rtx_PLUS (Pmode, s2addr, off_reg);\n+      do_load_for_compare_from_addr (QImode, chr2, addr2, orig_src2);\n+      machine_mode rmode = GET_MODE (result);\n+      rtx chr1_rm = simplify_gen_subreg (rmode, chr1, QImode, 0);\n+      rtx chr2_rm = simplify_gen_subreg (rmode, chr2, QImode, 0);\n+      do_sub3 (result, chr1_rm, chr2_rm);\n+    }\n+\n+  return;\n+}\n+\n /* Expand a string compare operation with length, and return\n    true if successful. Return false if we should let the\n    compiler generate normal code, probably a strncmp call.\n@@ -2002,21 +2299,43 @@ expand_strn_compare (rtx operands[], int no_length)\n \n   gcc_assert (GET_MODE (target) == SImode);\n \n-  unsigned int word_mode_size = GET_MODE_SIZE (word_mode);\n+  unsigned int required_align = 8;\n \n   unsigned HOST_WIDE_INT offset = 0;\n   unsigned HOST_WIDE_INT bytes; /* N from the strncmp args if available.  */\n   unsigned HOST_WIDE_INT compare_length; /* How much to compare inline.  */\n+\n   if (no_length)\n-    /* Use this as a standin to determine the mode to use.  */\n-    bytes = rs6000_string_compare_inline_limit * word_mode_size;\n+    bytes = rs6000_string_compare_inline_limit;\n   else\n     bytes = UINTVAL (bytes_rtx);\n \n-  machine_mode load_mode =\n-    select_block_compare_mode (0, bytes, base_align);\n-  unsigned int load_mode_size = GET_MODE_SIZE (load_mode);\n-  compare_length = rs6000_string_compare_inline_limit * load_mode_size;\n+  /* Is it OK to use vec/vsx for this. TARGET_VSX means we have at\n+     least POWER7 but we use TARGET_EFFICIENT_UNALIGNED_VSX which is\n+     at least POWER8.  That way we can rely on overlapping compares to\n+     do the final comparison of less than 16 bytes.  Also I do not want\n+     to deal with making this work for 32 bits.  */\n+  int use_vec = (bytes >= 16 && !TARGET_32BIT && TARGET_EFFICIENT_UNALIGNED_VSX);\n+\n+  if (use_vec)\n+    required_align = 16;\n+\n+  machine_mode load_mode;\n+  rtx tmp_reg_src1, tmp_reg_src2;\n+  if (use_vec)\n+    {\n+      load_mode = V16QImode;\n+      tmp_reg_src1 = gen_reg_rtx (V16QImode);\n+      tmp_reg_src2 = gen_reg_rtx (V16QImode);\n+    }\n+  else\n+    {\n+      load_mode = select_block_compare_mode (0, bytes, base_align);\n+      tmp_reg_src1 = gen_reg_rtx (word_mode);\n+      tmp_reg_src2 = gen_reg_rtx (word_mode);\n+    }\n+\n+  compare_length = rs6000_string_compare_inline_limit;\n \n   /* If we have equality at the end of the last compare and we have not\n      found the end of the string, we need to call strcmp/strncmp to\n@@ -2040,10 +2359,7 @@ expand_strn_compare (rtx operands[], int no_length)\n   rtx final_move_label = gen_label_rtx ();\n   rtx final_label = gen_label_rtx ();\n   rtx begin_compare_label = NULL;\n-  unsigned int required_align = 8;\n-\n-  required_align = 8;\n-\n+  \n   if (base_align < required_align)\n     {\n       /* Generate code that checks distance to 4k boundary for this case.  */\n@@ -2060,7 +2376,7 @@ expand_strn_compare (rtx operands[], int no_length)\n          the subsequent code generation are in agreement so we do not\n          go past the length we tested for a 4k boundary crossing.  */\n       unsigned HOST_WIDE_INT align_test = compare_length;\n-      if (align_test < 8)\n+      if (align_test < required_align)\n         {\n           align_test = HOST_WIDE_INT_1U << ceil_log2 (align_test);\n           base_align = align_test;\n@@ -2102,7 +2418,7 @@ expand_strn_compare (rtx operands[], int no_length)\n       else\n \t{\n \t  /* -m32 -mpowerpc64 results in word_mode being DImode even\n-\t     though otherwise it is 32-bit. The length arg to strncmp\n+\t     though otherwise it is 32-bit.  The length arg to strncmp\n \t     is a size_t which will be the same size as pointers.  */\n \t  rtx len_rtx = gen_reg_rtx (Pmode);\n \t  emit_move_insn (len_rtx, gen_int_mode (bytes, Pmode));\n@@ -2124,17 +2440,32 @@ expand_strn_compare (rtx operands[], int no_length)\n     }\n \n   rtx cleanup_label = NULL;\n-  rtx tmp_reg_src1 = gen_reg_rtx (word_mode);\n-  rtx tmp_reg_src2 = gen_reg_rtx (word_mode);\n+  rtx s1addr = NULL, s2addr = NULL, off_reg = NULL, vec_result = NULL;\n \n   /* Generate a sequence of GPR or VEC/VSX instructions to compare out\n      to the length specified.  */\n-  expand_strncmp_gpr_sequence(compare_length, base_align,\n-\t\t\t      orig_src1, orig_src2,\n-\t\t\t      tmp_reg_src1, tmp_reg_src2,\n-\t\t\t      result_reg,\n-\t\t\t      equality_compare_rest,\n-\t\t\t      cleanup_label, final_move_label);\n+  if (use_vec)\n+    {\n+      s1addr = gen_reg_rtx (Pmode);\n+      s2addr = gen_reg_rtx (Pmode);\n+      off_reg = gen_reg_rtx (Pmode);\n+      vec_result = gen_reg_rtx (load_mode);\n+      emit_move_insn (result_reg, GEN_INT (0));\n+      expand_strncmp_vec_sequence (compare_length,\n+\t\t\t\t   orig_src1, orig_src2,\n+\t\t\t\t   s1addr, s2addr, off_reg,\n+\t\t\t\t   tmp_reg_src1, tmp_reg_src2,\n+\t\t\t\t   vec_result,\n+\t\t\t\t   equality_compare_rest,\n+\t\t\t\t   &cleanup_label, final_move_label);\n+    }\n+  else\n+    expand_strncmp_gpr_sequence (compare_length, base_align,\n+\t\t\t\t orig_src1, orig_src2,\n+\t\t\t\t tmp_reg_src1, tmp_reg_src2,\n+\t\t\t\t result_reg,\n+\t\t\t\t equality_compare_rest,\n+\t\t\t\t &cleanup_label, final_move_label);\n \n   offset = compare_length;\n   \n@@ -2174,7 +2505,12 @@ expand_strn_compare (rtx operands[], int no_length)\n   if (cleanup_label)\n     emit_label (cleanup_label);\n \n-  emit_final_str_compare_gpr (tmp_reg_src1, tmp_reg_src2, result_reg);\n+  if (use_vec)\n+    emit_final_str_compare_vec (tmp_reg_src1, tmp_reg_src2, result_reg,\n+\t\t\t\ts1addr, s2addr, orig_src1, orig_src2,\n+\t\t\t\toff_reg, vec_result);\n+  else\n+    emit_final_str_compare_gpr (tmp_reg_src1, tmp_reg_src2, result_reg);\n \n   emit_label (final_move_label);\n   emit_insn (gen_movsi (target,"}, {"sha": "0abeeafc64699977316c8b7ea324e5dabb8242cf", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=9d36bd3b1763035447bf201542545e8b5dcf962d", "patch": "@@ -334,8 +334,8 @@ Target Report Var(rs6000_block_compare_inline_loop_limit) Init(-1) RejectNegativ\n Max number of bytes to compare with loops.\n \n mstring-compare-inline-limit=\n-Target Report Var(rs6000_string_compare_inline_limit) Init(8) RejectNegative Joined UInteger Save\n-Max number of pairs of load insns for compare.\n+Target Report Var(rs6000_string_compare_inline_limit) Init(64) RejectNegative Joined UInteger Save\n+Max number of bytes to compare.\n \n misel\n Target Report Mask(ISEL) Var(rs6000_isa_flags)"}, {"sha": "89e193a282210b9d54e6904d88c088046e27529f", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=9d36bd3b1763035447bf201542545e8b5dcf962d", "patch": "@@ -1412,7 +1412,7 @@\n     }\n })\n \n-(define_insn \"*vsx_ld_elemrev_v16qi_internal\"\n+(define_insn \"vsx_ld_elemrev_v16qi_internal\"\n   [(set (match_operand:V16QI 0 \"vsx_register_operand\" \"=wa\")\n         (vec_select:V16QI\n           (match_operand:V16QI 1 \"memory_operand\" \"Z\")\n@@ -5051,6 +5051,22 @@\n   \"vcmpnezb %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n+;; Vector Compare Not Equal or Zero Byte predicate or record-form\n+(define_insn \"vcmpnezb_p\"\n+  [(set (reg:CC CR6_REGNO)\n+\t(unspec:CC\n+\t [(match_operand:V16QI 1 \"altivec_register_operand\" \"v\")\n+\t  (match_operand:V16QI 2 \"altivec_register_operand\" \"v\")]\n+\t UNSPEC_VCMPNEZB))\n+   (set (match_operand:V16QI 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:V16QI\n+\t [(match_dup 1)\n+\t  (match_dup 2)]\n+\t UNSPEC_VCMPNEZB))]\n+  \"TARGET_P9_VECTOR\"\n+  \"vcmpnezb. %0,%1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n ;; Vector Compare Not Equal Half Word (specified/not+eq:)\n (define_insn \"vcmpneh\"\n   [(set (match_operand:V8HI 0 \"altivec_register_operand\" \"=v\")"}, {"sha": "637f5ada8f6430a92c56afc0c05d426ac8a45a49", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d36bd3b1763035447bf201542545e8b5dcf962d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9d36bd3b1763035447bf201542545e8b5dcf962d", "patch": "@@ -24556,12 +24556,10 @@ target-specific.\n \n @item -mstring-compare-inline-limit=@var{num}\n @opindex mstring-compare-inline-limit\n-Generate at most @var{num} pairs of load instructions to compare the\n-string inline. If the difference or end of string is not found at the\n+Compare at most @var{num} string bytes with inline code.\n+If the difference or end of string is not found at the\n end of the inline compare a call to @code{strcmp} or @code{strncmp} will\n-take care of the rest of the comparison. The default is 8 pairs of\n-loads, which will compare 64 bytes on a 64-bit target and 32 bytes on a\n-32-bit target.\n+take care of the rest of the comparison. The default is 64 bytes.\n \n @item -G @var{num}\n @opindex G"}]}