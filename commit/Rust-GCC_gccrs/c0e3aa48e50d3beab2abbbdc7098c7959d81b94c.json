{"sha": "c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlM2FhNDhlNTBkM2JlYWIyYWJiYmRjNzA5OGM3OTU5ZDgxYjk0Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-20T11:19:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-20T11:19:47Z"}, "message": "decl.c (elaborate_expression, [...]): Arguments now bool instead of int.\n\n\t* decl.c (elaborate_expression, elaborate_expression_1): Arguments\n\tnow bool instead of int.\n\t(gnat_to_gnu_entity, elaborate_expression_1): New arg to COMPONENT_REF.\n\t* trans.c (gnu_switch_label_stack): New function.\n\t(gnat_to_gnu, N_Object_Renaming_Declaration): Result is what the\n\telaboration of renamed entity returns.\n\t(gnat_to_gnu, case N_Case_Statement): Add branches to end label.\n\t(add_decl_stmt): Don't add TYPE_DECL for UNCONSTRAINED_ARRAY_TYPE.\n\t(gnat_gimplify_stmt): Use alloc_stmt_list, not build_empty_stmt.\n\t(gnat_gimplify_stmt, case DECL_STMT): gimplify DECL_SIZE and\n\tDECL_SIZE_UNIT and simplify variable-sized case.\n\t(gnat_gimplify_type_sizes, gnat_gimplify_one_sizepos): Deleted.\n\tCallers changes to call gimplify_type_sizes and gimplify_one_sizepos.\n\t(gnat_stabilize_reference): Add arg to COMPONENT_REF.\n\t(build_unit_elab): Disable for now.\n\t* utils.c (mark_visited): New function.\n\t(pushdecl): Walk tree to call it for global decl.\n\t(update_pointer_to): Update all variants of pointer and ref types.\n\tAdd arg to COMPONENT_REF.\n\t(convert): Likewise.\n\tMove check for converting between variants lower down.\n\t* utils2.c (build_simple_component_ref): Add arg to COMPONENT_REF.\n\t(build_allocator): Don't force type of MODIFY_EXPR.\n\t(gnat_mark_addressable, case VAR_DECL): Unconditionally call\n\tput_var_into_stack.\n\nFrom-SVN: r83410", "tree": {"sha": "e033adad204593350250cac0b2e5b362bf93de59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e033adad204593350250cac0b2e5b362bf93de59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/comments", "author": null, "committer": null, "parents": [{"sha": "543a0daa84fd7dda27536a892dd88896ba25b1f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543a0daa84fd7dda27536a892dd88896ba25b1f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/543a0daa84fd7dda27536a892dd88896ba25b1f3"}], "stats": {"total": 353, "additions": 170, "deletions": 183}, "files": [{"sha": "d6788f3d3beafdf3ef366f5e49cf9cd624ca0115", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "patch": "@@ -1,3 +1,31 @@\n+2004-06-20  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (elaborate_expression, elaborate_expression_1): Arguments\n+\tnow bool instead of int.\n+\t(gnat_to_gnu_entity, elaborate_expression_1): New arg to COMPONENT_REF.\n+\t* trans.c (gnu_switch_label_stack): New function.\n+\t(gnat_to_gnu, N_Object_Renaming_Declaration): Result is what the\n+\telaboration of renamed entity returns.\n+\t(gnat_to_gnu, case N_Case_Statement): Add branches to end label.\n+\t(add_decl_stmt): Don't add TYPE_DECL for UNCONSTRAINED_ARRAY_TYPE.\n+\t(gnat_gimplify_stmt): Use alloc_stmt_list, not build_empty_stmt.\n+\t(gnat_gimplify_stmt, case DECL_STMT): gimplify DECL_SIZE and\n+\tDECL_SIZE_UNIT and simplify variable-sized case.\n+\t(gnat_gimplify_type_sizes, gnat_gimplify_one_sizepos): Deleted.\n+\tCallers changes to call gimplify_type_sizes and gimplify_one_sizepos.\n+\t(gnat_stabilize_reference): Add arg to COMPONENT_REF.\n+\t(build_unit_elab): Disable for now.\n+\t* utils.c (mark_visited): New function.\n+\t(pushdecl): Walk tree to call it for global decl.\n+\t(update_pointer_to): Update all variants of pointer and ref types.\n+\tAdd arg to COMPONENT_REF.\n+\t(convert): Likewise.\n+\tMove check for converting between variants lower down.\n+\t* utils2.c (build_simple_component_ref): Add arg to COMPONENT_REF.\n+\t(build_allocator): Don't force type of MODIFY_EXPR.\n+\t(gnat_mark_addressable, case VAR_DECL): Unconditionally call\n+\tput_var_into_stack.\n+\n 2004-06-14  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* ada-tree.def (LOOP_STMT, EXIT_STMT): Update documentation."}, {"sha": "25fe2c8dd580e16a1c3b2ffadac955fbc8a36af4", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "patch": "@@ -84,9 +84,10 @@ static void copy_alias_set (tree, tree);\n static tree substitution_list (Entity_Id, Entity_Id, tree, int);\n static int allocatable_size_p (tree, int);\n static struct attrib *build_attr_list (Entity_Id);\n-static tree elaborate_expression (Node_Id, Entity_Id, tree, int, int, int);\n+static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n static int is_variable_size (tree);\n-static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree, int, int);\n+static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree,\n+\t\t\t\t    bool, bool);\n static tree make_packable_type (tree);\n static tree maybe_pad_type (tree, tree, unsigned int, Entity_Id, const char *,\n                             int, int, int);\n@@ -1487,7 +1488,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   fields once we build them.  */\n \ttem = build (COMPONENT_REF, gnu_ptr_template,\n \t\t     build (PLACEHOLDER_EXPR, gnu_fat_type),\n-\t\t     TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)));\n+\t\t     TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)), NULL_TREE);\n \tgnu_template_reference\n \t  = build_unary_op (INDIRECT_REF, gnu_template_type, tem);\n \tTREE_READONLY (gnu_template_reference) = 1;\n@@ -1532,9 +1533,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* We can't use build_component_ref here since the template\n \t       type isn't complete yet.  */\n \t    gnu_min = build (COMPONENT_REF, gnu_ind_subtype,\n-\t\t\t     gnu_template_reference, gnu_min_field);\n+\t\t\t     gnu_template_reference, gnu_min_field, NULL_TREE);\n \t    gnu_max = build (COMPONENT_REF, gnu_ind_subtype,\n-\t\t\t     gnu_template_reference, gnu_max_field);\n+\t\t\t     gnu_template_reference, gnu_max_field, NULL_TREE);\n \t    TREE_READONLY (gnu_min) = TREE_READONLY (gnu_max) = 1;\n \n \t    /* Make a range type with the new ranges, but using\n@@ -2331,7 +2332,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_get_parent = build (COMPONENT_REF, void_type_node,\n \t\t\t\t    build (PLACEHOLDER_EXPR, gnu_type),\n \t\t\t\t    build_decl (FIELD_DECL, NULL_TREE,\n-\t\t\t\t\t\tNULL_TREE));\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t\t\t    NULL_TREE);\n \n \t    if (Has_Discriminants (gnat_entity))\n \t      for (gnat_field = First_Stored_Discriminant (gnat_entity);\n@@ -2345,7 +2347,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t    gnu_get_parent,\n \t\t\t    gnat_to_gnu_entity (Corresponding_Discriminant\n \t\t\t\t\t\t(gnat_field),\n-\t\t\t\t\t\tNULL_TREE, 0)),\n+\t\t\t\t\t\tNULL_TREE, 0),\n+\t\t\t    NULL_TREE),\n \t\t     1);\n \n \t    gnu_parent = gnat_to_gnu_type (Parent_Subtype (gnat_entity));\n@@ -2387,7 +2390,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t     build (COMPONENT_REF, TREE_TYPE (gnu_field),\n \t\t\t\t    build (PLACEHOLDER_EXPR,\n \t\t\t\t\t   DECL_CONTEXT (gnu_field)),\n-\t\t\t\t    gnu_field),\n+\t\t\t\t    gnu_field, NULL_TREE),\n \t\t\t     1);\n \n \t      TREE_CHAIN (gnu_field) = gnu_field_list;\n@@ -4453,12 +4456,9 @@ maybe_variable (tree gnu_operand)\n    purposes even if it isn't needed for code generation.  */\n \n static tree\n-elaborate_expression (Node_Id gnat_expr,\n-                      Entity_Id gnat_entity,\n-                      tree gnu_name,\n-                      int definition,\n-                      int need_value,\n-                      int need_debug)\n+elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity,\n+                      tree gnu_name, bool definition, bool need_value,\n+\t\t      bool need_debug)\n {\n   tree gnu_expr;\n \n@@ -4480,10 +4480,8 @@ elaborate_expression (Node_Id gnat_expr,\n     = elaborate_expression_1 (gnat_expr, gnat_entity, gnat_to_gnu (gnat_expr),\n \t\t\t      gnu_name, definition, need_debug);\n \n-  /* Save the expression in case we try to elaborate this entity again.\n-     Since this is not a DECL, don't check it.  If this is a constant,\n-     don't save it since GNAT_EXPR might be used more than once.  Also,\n-     don't save if it's a discriminant.  */\n+  /* Save the expression in case we try to elaborate this entity again.  Since\n+     this is not a DECL, don't check it.  Don't save if it's a discriminant. */\n   if (! CONTAINS_PLACEHOLDER_P (gnu_expr))\n     save_gnu_tree (gnat_expr, gnu_expr, 1);\n \n@@ -4493,12 +4491,9 @@ elaborate_expression (Node_Id gnat_expr,\n /* Similar, but take a GNU expression.  */\n \n static tree\n-elaborate_expression_1 (Node_Id gnat_expr,\n-                        Entity_Id gnat_entity,\n-                        tree gnu_expr,\n-                        tree gnu_name,\n-                        int definition,\n-                        int need_debug)\n+elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n+                        tree gnu_expr, tree gnu_name, bool definition,\n+                        bool need_debug)\n {\n   tree gnu_decl = 0;\n   /* Strip any conversions to see if the expression is a readonly variable.\n@@ -4517,7 +4512,7 @@ elaborate_expression_1 (Node_Id gnat_expr,\n   if (TREE_CODE (gnu_expr) == FIELD_DECL)\n     gnu_expr = build (COMPONENT_REF, TREE_TYPE (gnu_expr),\n \t\t      build (PLACEHOLDER_EXPR, DECL_CONTEXT (gnu_expr)),\n-\t\t      gnu_expr);\n+\t\t      gnu_expr, NULL_TREE);\n \n   /* If GNU_EXPR is neither a placeholder nor a constant, nor a variable\n      that is a constant, make a variable that is initialized to contain the"}, {"sha": "b6e9abcfcea1782855ffa0b0f7f07c016319631d", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 55, "deletions": 101, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "patch": "@@ -109,6 +109,10 @@ static GTY(()) tree gnu_return_label_stack;\n    TREE_VALUE of each entry is the label of the corresponding LOOP_STMT.  */\n static GTY(()) tree gnu_loop_label_stack;\n \n+/* List of TREE_LIST nodes representing labels for switch statements.\n+   TREE_VALUE of each entry is the label at the end of the switch.  */\n+static GTY(()) tree gnu_switch_label_stack;\n+\n /* List of TREE_LIST nodes containing pending elaborations lists.\n    used to prevent the elaborations being reclaimed by GC.  */\n static GTY(()) tree gnu_pending_elaboration_lists;\n@@ -746,18 +750,21 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Object_Renaming_Declaration:\n       gnat_temp = Defining_Entity (gnat_node);\n-      gnu_result = alloc_stmt_list ();\n \n-      /* Don't do anything if this renaming is handled by the front end.\n-\t or if we are just annotating types and this object has a\n-\t composite or task type, don't elaborate it.  */\n+      /* Don't do anything if this renaming is handled by the front end.  or if\n+\t we are just annotating types and this object has a composite or task\n+\t type, don't elaborate it.  We return the result in case it has any\n+\t SAVE_EXPRs in it that need to be evaluated here.  */\n       if (! Is_Renaming_Of_Object (gnat_temp)\n \t  && ! (type_annotate_only\n \t\t&& (Is_Array_Type (Etype (gnat_temp))\n \t\t    || Is_Record_Type (Etype (gnat_temp))\n \t\t    || Is_Concurrent_Type (Etype (gnat_temp)))))\n-\tgnat_to_gnu_entity (gnat_temp,\n-\t\t\t    gnat_to_gnu (Renamed_Object (gnat_temp)), 1);\n+\tgnu_result\n+\t  = gnat_to_gnu_entity (gnat_temp,\n+\t\t\t\tgnat_to_gnu (Renamed_Object (gnat_temp)), 1);\n+      else\n+\tgnu_result = alloc_stmt_list ();\n       break;\n \n     case N_Implicit_Label_Declaration:\n@@ -2053,6 +2060,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* We build a SWITCH_EXPR that contains the code with interspersed\n \t   CASE_LABEL_EXPRs for each label.  */\n \n+\tpush_stack (&gnu_switch_label_stack, NULL_TREE,\n+\t\t    create_artificial_label ());\n \tstart_stmt_group ();\n \tfor (gnat_when = First_Non_Pragma (Alternatives (gnat_node));\n \t     Present (gnat_when);\n@@ -2121,10 +2130,17 @@ gnat_to_gnu (Node_Id gnat_node)\n \t       we want them to be local to this set of statements instead of\n \t       the block containing the Case statement.  */\n \t    add_stmt (build_stmt_group (Statements (gnat_when), true));\n+\t    add_stmt (build1 (GOTO_EXPR, void_type_node,\n+\t\t\t      TREE_VALUE (gnu_switch_label_stack)));\n+\n \t  }\n \t\n+\t/* Now emit a definition of the label all the cases branched to. */\n+\tadd_stmt (build1 (LABEL_EXPR, void_type_node,\n+\t\t\t  TREE_VALUE (gnu_switch_label_stack)));\n \tgnu_result = build (SWITCH_EXPR, TREE_TYPE (gnu_expr), gnu_expr,\n \t\t\t    end_stmt_group (), NULL_TREE);\n+\tpop_stack (&gnu_switch_label_stack);\n \tbreak;\n       }\n \n@@ -4051,8 +4067,11 @@ add_decl_stmt (tree gnu_decl, Entity_Id gnat_entity)\n {\n   /* If this is a variable that Gigi is to ignore, we may have been given\n      an ERROR_MARK.  So test for it.  We also might have been given a\n-     reference for a renaming.  So only do something for a decl.  */\n-  if (!DECL_P (gnu_decl))\n+     reference for a renaming.  So only do something for a decl.  Also\n+     ignore a TYPE_DECL for an UNCONSTRAINED_ARRAY_TYPE.  */\n+  if (!DECL_P (gnu_decl)\n+      || (TREE_CODE (gnu_decl) == TYPE_DECL\n+\t  && TREE_CODE (TREE_TYPE (gnu_decl)) == UNCONSTRAINED_ARRAY_TYPE))\n     return;\n \n   add_stmt_with_node (build (DECL_STMT, void_type_node, gnu_decl),\n@@ -4254,39 +4273,41 @@ gnat_gimplify_stmt (tree *stmt_p)\n       return GS_OK;\n \n     case USE_STMT:\n-      *stmt_p = build_empty_stmt ();\n+      *stmt_p = alloc_stmt_list ();\n       return GS_ALL_DONE;\n \n     case DECL_STMT:\n       {\n \ttree var = DECL_STMT_VAR (stmt);\n \n \tif (TREE_CODE (var) == TYPE_DECL)\n-\t  *stmt_p = gnat_gimplify_type_sizes (TREE_TYPE (var));\n-\telse if (TREE_CODE (var) == VAR_DECL && !DECL_EXTERNAL (var)\n-\t\t && !TREE_CONSTANT (DECL_SIZE_UNIT (var)))\n+\t  *stmt_p = gimplify_type_sizes (TREE_TYPE (var));\n+\telse if (TREE_CODE (var) == VAR_DECL)\n \t  {\n-\t    tree pt_type = build_pointer_type (TREE_TYPE (var));\n-\t    tree size, pre = NULL_TREE, post = NULL_TREE;\n-\n-\t    /* This is a variable-sized decl.  Simplify its size and mark it\n-\t       for deferred expansion.  Note that mudflap depends on the format\n-\t       of the emitted code: see mx_register_decls.  */\n \t    *stmt_p = NULL_TREE;\n-\t    size = get_initialized_tmp_var (DECL_SIZE_UNIT (var), &pre, &post);\n-\t    DECL_DEFER_OUTPUT (var) = 1;\n-\t    append_to_statement_list (pre, stmt_p);\n-\t    append_to_statement_list\n-\t      (build_function_call_expr\n-\t       (implicit_built_in_decls[BUILT_IN_STACK_ALLOC],\n-\t\ttree_cons (NULL_TREE,\n-\t\t\t   build1 (ADDR_EXPR, pt_type, var),\n-\t\t\t   tree_cons (NULL_TREE, size, NULL_TREE))),\n-\t       stmt_p);\n-\t    append_to_statement_list (post, stmt_p);\n+\t    gimplify_one_sizepos (&DECL_SIZE (var), stmt_p);\n+\t    gimplify_one_sizepos (&DECL_SIZE_UNIT (var), stmt_p);\n+\n+\t    if (!DECL_EXTERNAL (var) && !TREE_CONSTANT (DECL_SIZE_UNIT (var)))\n+\t      {\n+\t\tDECL_DEFER_OUTPUT (var) = 1;\n+\t\tappend_to_statement_list\n+\t\t  (build_function_call_expr\n+\t\t   (implicit_built_in_decls[BUILT_IN_STACK_ALLOC],\n+\t\t    tree_cons (NULL_TREE,\n+\t\t\t       build1 (ADDR_EXPR,\n+\t\t\t\t       build_pointer_type (TREE_TYPE (var)),\n+\t\t\t\t       var),\n+\t\t\t       tree_cons (NULL_TREE, DECL_SIZE_UNIT (var),\n+\t\t\t\t\t  NULL_TREE))),\n+\t\t   stmt_p);\n+\t      }\n+\n+\t    if (*stmt_p == NULL_TREE)\n+\t      *stmt_p = alloc_stmt_list ();\n \t  }\n \telse\n-\t  *stmt_p = build_empty_stmt ();\n+\t  *stmt_p = alloc_stmt_list ();\n \treturn GS_ALL_DONE;\n       }\n \n@@ -4352,76 +4373,6 @@ gnat_gimplify_stmt (tree *stmt_p)\n       abort ();\n     }\n }\n-\n-/* Look through GNU_TYPE for variable-sized objects and gimplify each such\n-   size that we find.  Return a STATEMENT_LIST containing the result.  */\n-\n-static tree\n-gnat_gimplify_type_sizes (tree gnu_type)\n-{\n-  tree gnu_stmts = NULL_TREE;\n-  tree gnu_field;\n-\n-  switch (TREE_CODE (gnu_type))\n-    {\n-    case ERROR_MARK:\n-    case UNCONSTRAINED_ARRAY_TYPE:\n-      return alloc_stmt_list ();\n-\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-    case CHAR_TYPE:\n-    case REAL_TYPE:\n-      gnat_gimplify_one_sizepos (&TYPE_MIN_VALUE (gnu_type), &gnu_stmts);\n-      gnat_gimplify_one_sizepos (&TYPE_MAX_VALUE (gnu_type), &gnu_stmts);\n-      break;\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      for (gnu_field = TYPE_FIELDS (gnu_type); gnu_field;\n-\t   gnu_field = TREE_CHAIN (gnu_field))\n-\tif (TREE_CODE (gnu_field) == FIELD_DECL)\n-\t  gnat_gimplify_one_sizepos (&DECL_FIELD_OFFSET (gnu_field),\n-\t\t\t\t     &gnu_stmts);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  gnat_gimplify_one_sizepos (&TYPE_SIZE (gnu_type), &gnu_stmts);\n-  gnat_gimplify_one_sizepos (&TYPE_SIZE_UNIT (gnu_type), &gnu_stmts);\n-\n-  if (!gnu_stmts)\n-    gnu_stmts = alloc_stmt_list ();\n-\n-  return gnu_stmts;\n-}\n-\n-/* Subroutine of the above to gimplify one size or position, *GNU_EXPR_P.\n-   We add any required statements to GNU_STMT_P.  */\n-\n-static void\n-gnat_gimplify_one_sizepos (tree *gnu_expr_p, tree *gnu_stmt_p)\n-{\n-  tree gnu_pre = NULL_TREE, gnu_post = NULL_TREE;\n-\n-  /* We don't do anything if the value isn't there, is constant, or\n-     contains a PLACEHOLDER_EXPR.  */\n-  if (*gnu_expr_p == NULL_TREE\n-      || TREE_CONSTANT (*gnu_expr_p)\n-      || CONTAINS_PLACEHOLDER_P (*gnu_expr_p))\n-    return;\n-\n-  gimplify_expr (gnu_expr_p, &gnu_pre, &gnu_post, is_gimple_val, fb_rvalue);\n-\n-  if (gnu_pre)\n-    append_to_statement_list (gnu_pre, gnu_stmt_p);\n-  if (gnu_post)\n-    append_to_statement_list (gnu_post, gnu_stmt_p);\n-}\n \f\n /* Generate the RTL for the body of GNU_DECL.  If NESTED_P is nonzero,\n    then we are already in the process of generating RTL for another\n@@ -5472,7 +5423,7 @@ gnat_stabilize_reference (tree ref, int force)\n       result = build (COMPONENT_REF, type,\n \t\t      gnat_stabilize_reference (TREE_OPERAND (ref, 0),\n \t\t\t\t\t\tforce),\n-\t\t      TREE_OPERAND (ref, 1));\n+\t\t      TREE_OPERAND (ref, 1), NULL_TREE);\n       break;\n \n     case BIT_FIELD_REF:\n@@ -5592,6 +5543,9 @@ build_unit_elab (Entity_Id gnat_unit, int body_p, tree gnu_elab_list)\n   rtx insn;\n   int result = 1;\n \n+  /* ??? For now, force nothing to do.  */\n+  gnu_elab_list = 0;\n+\n   /* If we have nothing to do, return.  */\n   if (gnu_elab_list == 0)\n     return 1;"}, {"sha": "7619b4a0e572b6d816251f430b889ddf996344fb", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "patch": "@@ -133,6 +133,7 @@ struct language_function GTY(())\n   int unused;\n };\n \n+static tree mark_visited (tree *, int *, void *);\n static void gnat_define_builtin (const char *, tree, int, const char *, bool);\n static void gnat_install_builtins (void);\n static tree merge_sizes (tree, tree, tree, int, int);\n@@ -338,16 +339,35 @@ block_has_vars ()\n   return BLOCK_VARS (current_binding_level->block) != 0;\n }\n \f\n+/* Utility function to mark nodes with TREE_VISITED.  Called from walk_tree.\n+   We use this to indicate all variable sizes and positions in global types\n+   may not be shared by any subprogram.  */\n+\n+static tree\n+mark_visited (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_VISITED (*tp))\n+    *walk_subtrees = 0;\n+  else\n+    TREE_VISITED (*tp) = 1;\n+\n+  return NULL_TREE;\n+}\n+\f\n /* Records a ..._DECL node DECL as belonging to the current lexical scope.\n    Returns the ..._DECL node. */\n \n tree\n pushdecl (tree decl)\n {\n   /* If at top level, there is no context. But PARM_DECLs always go in the\n-     level of its function. */\n+     level of its function.  Also, at toplevel we must protect all trees\n+     that are part of sizes and positions.  */\n   if (global_bindings_p () && TREE_CODE (decl) != PARM_DECL)\n-    DECL_CONTEXT (decl) = 0;\n+    {\n+      DECL_CONTEXT (decl) = 0;\n+      walk_tree (&decl, mark_visited, NULL, NULL);\n+    }\n   else\n     DECL_CONTEXT (decl) = current_function_decl;\n \n@@ -1261,11 +1281,8 @@ create_index_type (tree min, tree max, tree index)\n    information about this type.  */\n \n tree\n-create_type_decl (tree type_name,\n-                  tree type,\n-                  struct attrib *attr_list,\n-                  int artificial_p,\n-                  int debug_info_p)\n+create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n+\t\t  int artificial_p, int debug_info_p)\n {\n   tree type_decl = build_decl (TYPE_DECL, type_name, type);\n   enum tree_code code = TREE_CODE (type);\n@@ -1929,7 +1946,7 @@ gnat_gimplify_function (tree fndecl)\n      so that items like VLA sizes are expanded properly in the context of the\n      correct function.  */\n   cgn = cgraph_node (fndecl);\n-  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+  for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n     gnat_gimplify_function (cgn->decl);\n }\n \n@@ -2615,6 +2632,7 @@ update_pointer_to (tree old_type, tree new_type)\n {\n   tree ptr = TYPE_POINTER_TO (old_type);\n   tree ref = TYPE_REFERENCE_TO (old_type);\n+  tree ptr1, ref1;\n   tree type;\n \n   /* If this is the main variant, process all the other variants first.  */\n@@ -2662,26 +2680,30 @@ update_pointer_to (tree old_type, tree new_type)\n       TYPE_REFERENCE_TO (new_type) = ref;\n \n       for (; ptr; ptr = TYPE_NEXT_PTR_TO (ptr))\n-\t{\n-\t  TREE_TYPE (ptr) = new_type;\n+\tfor (ptr1 = TYPE_MAIN_VARIANT (ptr); ptr1;\n+\t     ptr1 = TYPE_NEXT_VARIANT (ptr1))\n+\t  {\n+\t    TREE_TYPE (ptr1) = new_type;\n \n-\t  if (TYPE_NAME (ptr) != 0\n-\t      && TREE_CODE (TYPE_NAME (ptr)) == TYPE_DECL\n-\t      && TREE_CODE (new_type) != ENUMERAL_TYPE)\n-\t    rest_of_decl_compilation (TYPE_NAME (ptr), NULL,\n-\t\t\t\t      global_bindings_p (), 0);\n-\t}\n+\t    if (TYPE_NAME (ptr1) != 0\n+\t\t&& TREE_CODE (TYPE_NAME (ptr1)) == TYPE_DECL\n+\t\t&& TREE_CODE (new_type) != ENUMERAL_TYPE)\n+\t      rest_of_decl_compilation (TYPE_NAME (ptr1), NULL,\n+\t\t\t\t\tglobal_bindings_p (), 0);\n+\t  }\n \n       for (; ref; ref = TYPE_NEXT_PTR_TO (ref))\n-\t{\n-\t  TREE_TYPE (ref) = new_type;\n+\tfor (ref1 = TYPE_MAIN_VARIANT (ref); ref1;\n+\t     ref1 = TYPE_NEXT_VARIANT (ref1))\n+\t  {\n+\t    TREE_TYPE (ref1) = new_type;\n \n-\t  if (TYPE_NAME (ref) != 0\n-\t      && TREE_CODE (TYPE_NAME (ref)) == TYPE_DECL\n-\t      && TREE_CODE (new_type) != ENUMERAL_TYPE)\n-\t    rest_of_decl_compilation (TYPE_NAME (ref), NULL,\n-\t\t\t\t      global_bindings_p (), 0);\n-\t}\n+\t    if (TYPE_NAME (ref1) != 0\n+\t\t&& TREE_CODE (TYPE_NAME (ref1)) == TYPE_DECL\n+\t\t&& TREE_CODE (new_type) != ENUMERAL_TYPE)\n+\t      rest_of_decl_compilation (TYPE_NAME (ref1), NULL,\n+\t\t\t\t\tglobal_bindings_p (), 0);\n+\t  }\n     }\n \n   /* Now deal with the unconstrained array case. In this case the \"pointer\"\n@@ -2711,7 +2733,7 @@ update_pointer_to (tree old_type, tree new_type)\n       ptr_temp_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (ptr)));\n       new_ref = build (COMPONENT_REF, ptr_temp_type,\n \t\t       build (PLACEHOLDER_EXPR, ptr),\n-\t\t       TREE_CHAIN (TYPE_FIELDS (ptr)));\n+\t\t       TREE_CHAIN (TYPE_FIELDS (ptr)), NULL_TREE);\n \n       update_pointer_to\n \t(TREE_TYPE (TREE_TYPE (TYPE_FIELDS (ptr))),\n@@ -2854,11 +2876,6 @@ convert (tree type, tree expr)\n   /* If EXPR is already the right type, we are done.  */\n   if (type == etype)\n     return expr;\n-  /* If we're converting between two aggregate types that have the same main\n-     variant, just make a VIEW_CONVER_EXPR.  */\n-  else if (AGGREGATE_TYPE_P (type)\n-\t   && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype))\n-    return build1 (VIEW_CONVERT_EXPR, type, expr);\n \n   /* If the input type has padding, remove it by doing a component reference\n      to the field.  If the output type has padding, make a constructor\n@@ -2995,7 +3012,7 @@ convert (tree type, tree expr)\n \t  && operand_equal_p (TYPE_SIZE (type), TYPE_SIZE (etype), 0)\n \t  && get_alias_set (type) == get_alias_set (etype))\n \treturn build (COMPONENT_REF, type, TREE_OPERAND (expr, 0),\n-\t\t      TREE_OPERAND (expr, 1));\n+\t\t      TREE_OPERAND (expr, 1), NULL_TREE);\n \n       break;\n \n@@ -3043,9 +3060,16 @@ convert (tree type, tree expr)\n   if (TYPE_FAT_POINTER_P (type) && ! TYPE_FAT_POINTER_P (etype))\n     return convert_to_fat_pointer (type, expr);\n \n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype)\n-      || (code == INTEGER_CST && ecode == INTEGER_CST\n-\t  && (type == TREE_TYPE (etype) || etype == TREE_TYPE (type))))\n+  /* If we're converting between two aggregate types that have the same main\n+     variant, just make a VIEW_CONVER_EXPR.  */\n+  else if (AGGREGATE_TYPE_P (type)\n+\t   && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype))\n+    return build1 (VIEW_CONVERT_EXPR, type, expr);\n+\n+  /* In all other cases of related types, make a NOP_EXPR.  */\n+  else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype)\n+\t   || (code == INTEGER_CST && ecode == INTEGER_CST\n+\t       && (type == TREE_TYPE (etype) || etype == TREE_TYPE (type))))\n     return fold (build1 (NOP_EXPR, type, expr));\n \n   switch (code)"}, {"sha": "f1c167f46f39a51ba4fc1c5d13a7f6fb688f8ba1", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e3aa48e50d3beab2abbbdc7098c7959d81b94c/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=c0e3aa48e50d3beab2abbbdc7098c7959d81b94c", "patch": "@@ -1535,10 +1535,8 @@ gnat_build_constructor (tree type, tree list)\n    actual record and know how to look for fields in variant parts.  */\n \n static tree\n-build_simple_component_ref (tree record_variable,\n-                            tree component,\n-                            tree field,\n-                            int no_fold_p)\n+build_simple_component_ref (tree record_variable, tree component,\n+                            tree field, int no_fold_p)\n {\n   tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n   tree ref;\n@@ -1610,7 +1608,8 @@ build_simple_component_ref (tree record_variable,\n \n   /* It would be nice to call \"fold\" here, but that can lose a type\n      we need to tag a PLACEHOLDER_EXPR with, so we can't do it.  */\n-  ref = build (COMPONENT_REF, TREE_TYPE (field), record_variable, field);\n+  ref = build (COMPONENT_REF, TREE_TYPE (field), record_variable, field,\n+\t       NULL_TREE);\n \n   if (TREE_READONLY (record_variable) || TREE_READONLY (field))\n     TREE_READONLY (ref) = 1;\n@@ -1625,10 +1624,8 @@ build_simple_component_ref (tree record_variable,\n    reference could not be found.  */\n \n tree\n-build_component_ref (tree record_variable,\n-                     tree component,\n-                     tree field,\n-                     int no_fold_p)\n+build_component_ref (tree record_variable, tree component,\n+                     tree field, int no_fold_p)\n {\n   tree ref = build_simple_component_ref (record_variable, component, field,\n \t\t\t\t\t no_fold_p);\n@@ -1930,7 +1927,7 @@ build_allocator (tree type,\n       result\n \t= build (COMPOUND_EXPR, TREE_TYPE (result),\n \t\t build_binary_op\n-\t\t (MODIFY_EXPR, TREE_TYPE (TREE_TYPE (result)),\n+\t\t (MODIFY_EXPR, NULL_TREE,\n \t\t  build_unary_op (INDIRECT_REF, TREE_TYPE (TREE_TYPE (result)),\n \t\t\t\t  result),\n \t\t  init),\n@@ -1993,19 +1990,8 @@ gnat_mark_addressable (tree expr_node)\n       case VAR_DECL:\n       case PARM_DECL:\n       case RESULT_DECL:\n-\t/* If we have already made a REG for this decl, we must put it\n-\t   directly into the stack.  Likewise for a MEM whose address is a\n-\t   pseudo.  Otherwise, set a flag to mark us to do it later.  */\n-\tif (DECL_RTL_SET_P (expr_node)\n-\t    && (GET_CODE (DECL_RTL (expr_node)) == REG\n-\t\t|| (GET_CODE (DECL_RTL (expr_node)) == MEM\n-\t\t    && GET_CODE (XEXP (DECL_RTL (expr_node), 0)) == REG\n-\t\t    && (REGNO (XEXP (DECL_RTL (expr_node), 0))\n-\t\t\t> LAST_VIRTUAL_REGISTER))))\n-\t  put_var_into_stack (expr_node, 1);\n-\telse\n-\t  TREE_ADDRESSABLE (expr_node) = 1;\n-\n+\tput_var_into_stack (expr_node, 1);\n+\tTREE_ADDRESSABLE (expr_node) = 1;\n \treturn true;\n \n       case FUNCTION_DECL:"}]}