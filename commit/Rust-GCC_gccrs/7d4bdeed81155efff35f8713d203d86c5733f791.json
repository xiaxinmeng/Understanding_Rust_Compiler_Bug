{"sha": "7d4bdeed81155efff35f8713d203d86c5733f791", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q0YmRlZWQ4MTE1NWVmZmYzNWY4NzEzZDIwM2Q4NmM1NzMzZjc5MQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-03-05T16:38:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-03-05T16:38:54Z"}, "message": "cp-tree.h (ANON_UNION_TYPE_P): Robustify.\n\n\t* cp-tree.h (ANON_UNION_TYPE_P): Robustify.\n\t* decl.c (make_typename_type): Don't issue an error if an\n\timmediate lookup fails; it migt be resolved later.\n\t* friend.c (is_friend): Add comment.\n\t* search.c (breadth_first_search): Add POSTFN and DATA\n\tparameters.  Tidy.  All callers changed.\n\t(lookup_field_queue_p): New function.\n\t(lookup_field_r): Likewise.\n\t(lookup_field_post): Likewise.\n\t(lookup_field): Use them, via breadth_first_search, instead of\n\tduplicating logic.\n\t(compute_access): Robustify.\n\t(lookup_fnfield_info): New structure.\n\nFrom-SVN: r25607", "tree": {"sha": "681411d3b22eb93eb59b011bc9a0b990d7692239", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/681411d3b22eb93eb59b011bc9a0b990d7692239"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d4bdeed81155efff35f8713d203d86c5733f791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4bdeed81155efff35f8713d203d86c5733f791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4bdeed81155efff35f8713d203d86c5733f791", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4bdeed81155efff35f8713d203d86c5733f791/comments", "author": null, "committer": null, "parents": [{"sha": "00512c3a634d9eb316968eeb2dbb5c6fbaf68915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00512c3a634d9eb316968eeb2dbb5c6fbaf68915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00512c3a634d9eb316968eeb2dbb5c6fbaf68915"}], "stats": {"total": 822, "additions": 464, "deletions": 358}, "files": [{"sha": "2a493ddb1d2e08432f679a710610fec36daf08db", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -1,3 +1,19 @@\n+1999-03-05  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (ANON_UNION_TYPE_P): Robustify.\n+\t* decl.c (make_typename_type): Don't issue an error if an\n+\timmediate lookup fails; it migt be resolved later.\n+\t* friend.c (is_friend): Add comment.\n+\t* search.c (breadth_first_search): Add POSTFN and DATA\n+\tparameters.  Tidy.  All callers changed.\n+\t(lookup_field_queue_p): New function.\n+\t(lookup_field_r): Likewise.\n+\t(lookup_field_post): Likewise.\n+\t(lookup_field): Use them, via breadth_first_search, instead of\n+\tduplicating logic.\n+\t(compute_access): Robustify.\n+\t(lookup_fnfield_info): New structure.\n+\t\n 1999-03-05  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (tsubst, case ARRAY_REF): Use tsubst_expr again."}, {"sha": "ab33fad0e9da97625de864ce945c8ca82265552a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -1708,9 +1708,12 @@ extern int flag_new_for_scope;\n \n #define ANON_UNION_P(NODE) (DECL_NAME (NODE) == 0)\n \n-/* Nonzero if TYPE is an anonymous union type.  */\n+/* Nonzero if TYPE is an anonymous union type.  We're careful\n+   accessing TYPE_IDENTIFIER because some built-in types, like\n+   pointer-to-member types, do not have TYPE_NAME.  */\n #define ANON_UNION_TYPE_P(TYPE) \\\n   (TREE_CODE (TYPE) == UNION_TYPE \\\n+   && TYPE_NAME (TYPE) \\\n    && ANON_AGGRNAME_P (TYPE_IDENTIFIER (TYPE)))\n \n #define UNKNOWN_TYPE LANG_TYPE"}, {"sha": "cf7ce61463509e2862d7d3553b720a700267eb7a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -5192,34 +5192,29 @@ make_typename_type (context, name)\n \t  if (IS_AGGR_TYPE (context))\n \t    t = lookup_field (context, name, 0, 0);\n \t  else\n-\t    t = NULL_TREE;\n-\n-\t  if (t == NULL_TREE || TREE_CODE (t) != TEMPLATE_DECL\n-\t      || TREE_CODE (DECL_RESULT (t)) != TYPE_DECL)\n \t    {\n \t      cp_error (\"no class template named `%#T' in `%#T'\",\n \t\t\tname, context);\n \t      return error_mark_node;\n \t    }\n \n-\t  return lookup_template_class (t, TREE_OPERAND (fullname, 1),\n-\t\t\t\t\tNULL_TREE, context, \n-\t\t\t\t\t/*entering_scope=*/0);\n+\t  if (t && DECL_CLASS_TEMPLATE_P (t))\n+\t    return lookup_template_class (t, TREE_OPERAND (fullname, 1),\n+\t\t\t\t\t  NULL_TREE, context, \n+\t\t\t\t\t  /*entering_scope=*/0);\n \t}\n       else\n \t{\n \t  if (IS_AGGR_TYPE (context))\n \t    t = lookup_field (context, name, 0, 1);\n \t  else\n-\t    t = NULL_TREE;\n-\n-\t  if (t == NULL_TREE)\n \t    {\n \t      cp_error (\"no type named `%#T' in `%#T'\", name, context);\n \t      return error_mark_node;\n \t    }\n \n-\t  return TREE_TYPE (t);\n+\t  if (t)\n+\t    return TREE_TYPE (t);\n \t}\n     }\n   "}, {"sha": "8bcdcc40a2eb34b71540af9a29968d8b6688e883", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -32,6 +32,8 @@ static void add_friends PROTO((tree, tree, tree));\n \n /* Friend data structures are described in cp-tree.h.  */\n \n+/* Returns non-zero if SUPPLICANT is a friend of TYPE.  */\n+\n int\n is_friend (type, supplicant)\n      tree type, supplicant;"}, {"sha": "907c9d34c592f0c2ad0a399ca0fe7a862a721a1c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 355, "deletions": 345, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -110,17 +110,21 @@ static void dfs_get_vbase_types PROTO((tree));\n static void dfs_pushdecls PROTO((tree));\n static void dfs_compress_decls PROTO((tree));\n static void dfs_unuse_fields PROTO((tree));\n-static tree add_conversions PROTO((tree));\n+static tree add_conversions PROTO((tree, void *));\n static tree get_virtuals_named_this PROTO((tree));\n-static tree get_virtual_destructor PROTO((tree));\n-static int tree_has_any_destructor_p PROTO((tree));\n+static tree get_virtual_destructor PROTO((tree, void *));\n+static int tree_has_any_destructor_p PROTO((tree, void *));\n static int covariant_return_p PROTO((tree, tree));\n static struct search_level *push_search_level\n \tPROTO((struct stack_level *, struct obstack *));\n static struct search_level *pop_search_level\n \tPROTO((struct stack_level *));\n static tree breadth_first_search\n-\tPROTO((tree, tree (*) (tree), int (*) (tree)));\n+\tPROTO((tree, tree (*) (tree, void *), int (*) (tree, void *),\n+\t       void (*) (tree *, tree *, void *), void *));\n+static int lookup_field_queue_p PROTO((tree, void *));\n+static tree lookup_field_r PROTO((tree, void *));\n+static void lookup_field_post PROTO((tree *, tree *, void *));\n \n static tree vbase_types;\n static tree vbase_decl_ptr_intermediate, vbase_decl_ptr;\n@@ -673,7 +677,7 @@ compute_access (basetype_path, field)\n     {\n       /* Are we (or an enclosing scope) friends with the class that has\n          FIELD? */\n-      if (is_friend (context, previous_scope))\n+      if (TYPE_P (context) && is_friend (context, previous_scope))\n \tPUBLIC_RETURN;\n \n       /* If it's private, it's private, you letch.  */\n@@ -689,6 +693,7 @@ compute_access (basetype_path, field)\n \t{\n \t  if (current_class_type\n \t      && (static_mem || DECL_CONSTRUCTOR_P (field))\n+\t      && TYPE_P (context)\n \t      && ACCESSIBLY_DERIVED_FROM_P (context, current_class_type))\n \t    PUBLIC_RETURN;\n \t  else\n@@ -750,7 +755,7 @@ compute_access (basetype_path, field)\n \n   if (access == access_default_node)\n     {\n-      if (is_friend (context, previous_scope))\n+      if (TYPE_P (context) && is_friend (context, previous_scope))\n \taccess = access_public_node;\n       else if (TREE_PRIVATE (field))\n \taccess = access_private_node;\n@@ -849,6 +854,270 @@ lookup_fnfields_here (type, name)\n   return -1;\n }\n \n+struct lookup_field_info {\n+  /* The name of the field for which we're looking.  */\n+  tree name;\n+  /* If non-NULL, the current result of the lookup.  */\n+  tree rval;\n+  /* The path to RVAL.  */\n+  tree rval_binfo;\n+  /* If non-NULL, a list of the possible candidates.  */\n+  tree ambiguous;\n+  /* The access computed for RVAL.  */\n+  tree access;\n+  /* If non-zero, we must check access.  */\n+  int protect;\n+  /* If non-zero, we are looking for types, not data members.  */\n+  int want_type;\n+  /* If something went wrong, a message indicating what.  */\n+  char *errstr;\n+};\n+\n+/* Returns non-zero if BINFO is not hidden by the value found by the\n+   lookup so far.  If BINFO is hidden, then there's no need to look in\n+   it.  DATA is really a struct lookup_field_info.  Called from\n+   lookup_field via breadth_first_search.  */\n+\n+static int\n+lookup_field_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n+  \n+  return !(lfi->rval_binfo && hides (lfi->rval_binfo, binfo));\n+}\n+\n+/* DATA is really a struct lookup_field_info.  Look for a field with\n+   the name indicated there in BINFO.  If this function returns a\n+   non-NULL value it is the result of the lookup.  Called from\n+   lookup_field via breadth_first_search.  */\n+\n+static tree\n+lookup_field_r (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n+  tree type = BINFO_TYPE (binfo);\n+  tree nval;\n+  int idx;\n+\n+  /* See if the field is present in TYPE.  */\n+  nval = lookup_field_1 (type, lfi->name);\n+  if (!nval)\n+    idx = lookup_fnfields_here (type, lfi->name);\n+\n+  /* If the data member wasn't present, then there's nothing further\n+     to do for this type.  */\n+  if (!nval && idx < 0)\n+    return NULL_TREE;\n+\n+  /* If the lookup already found a match, and the new value doesn't\n+     hide the old one, we might have an ambiguity.  */\n+  if (lfi->rval_binfo && !hides (binfo, lfi->rval_binfo))\n+    {\n+      if (nval && nval == lfi->rval && SHARED_MEMBER_P (nval))\n+\t/* The two things are really the same.  */\n+\t;\n+      else if (hides (lfi->rval_binfo, binfo))\n+\t/* The previous value hides the new one.  */\n+\t;\n+      else\n+\t{\n+\t  /* We have a real ambiguity.  We keep a chain of all the\n+\t     candidates.  */\n+\t  if (!lfi->ambiguous && lfi->rval)\n+\t    /* This is the first time we noticed an ambiguity.  Add\n+\t       what we previously thought was a reasonable candidate\n+\t       to the list.  */\n+\t    lfi->ambiguous = scratch_tree_cons (NULL_TREE, lfi->rval,\n+\t\t\t\t\t\tNULL_TREE);\n+\t  /* If NVAL is NULL here, that means that we found a\n+\t     function, not a data member.  Pick a representative\n+\t     function, from the overload set, for use in error\n+\t     messages. */\n+\t  if (!nval)\n+\t    nval = OVL_CURRENT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC\n+\t\t\t\t\t      (type), idx));\n+\t      \n+\t  /* Add the new value.  */\n+\t  lfi->ambiguous = scratch_tree_cons (NULL_TREE, nval, \n+\t\t\t\t\t      lfi->ambiguous);\n+\t  lfi->errstr = \"request for member `%D' is ambiguous\";\n+\t}\n+    }\n+  else\n+    {\n+      /* The new lookup is the best we've got so far.  Verify that\n+\t it's the kind of thing we're looking for.  */\n+      if (nval)\n+\t{\n+\t  if (lfi->want_type && TREE_CODE (nval) != TYPE_DECL)\n+\t    {\n+\t      nval = purpose_member (lfi->name, CLASSTYPE_TAGS (type));\n+\t      if (nval)\n+\t\tnval = TYPE_MAIN_DECL (TREE_VALUE (nval));\n+\t    }\n+\t  else if (!lfi->want_type && TREE_CODE (nval) == TYPE_DECL\n+\t\t   && lookup_fnfields_here (type, lfi->name) >= 0)\n+\t    /* The type declaration is actually hidden by the\n+\t       function declaration.  */\n+\t    nval = NULL_TREE;\n+\t}\n+\n+      if (nval)\n+\t{\n+\t  /* The lookup found a data member.  */\n+\t  lfi->rval = nval;\n+\t  if (lfi->protect)\n+\t    lfi->access = compute_access (binfo, nval);\n+\t  /* If the thing we're looking for is a virtual base class,\n+\t     then we know we've got what we want at this point;\n+\t     there's no way to get an ambiguity.  */\n+\t  if (VBASE_NAME_P (lfi->name))\n+\t    return nval;\n+\t}\n+      else\n+\t/* The lookup found a function member.  This lookup hides\n+\t   whatever was there before, so even though we're not\n+\t   interested in this value we keep track of the way in\n+\t   which we found the function.  Subsequent lookups\n+\t   shouldn't find a data member if it is hidden by this\n+\t   function member.  */\n+\tlfi->rval = NULL_TREE;\n+\n+      lfi->rval_binfo = binfo;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Check to see if the result of the field lookup (as indicated by\n+   DATA, which is really a struct field_info) has any access other\n+   than that we previously computed.  SEARCH_HEAD and SEARCH_TAIL\n+   bound the path taken to find the result.  Called from lookup_field\n+   via breadth_first_search.  */\n+\n+static void\n+lookup_field_post (search_head, search_tail, data)\n+     tree *search_head;\n+     tree *search_tail;\n+     void *data;\n+{\n+  struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n+  tree rval = lfi->rval;\n+  tree own_access = access_default_node;\n+  tree *tp;\n+\n+  /* If we didn't find anything, or we found ambiguous function\n+     declarations, but no data members, just return.  */\n+  if (!rval)\n+    {\n+      lfi->errstr = 0;\n+      return;\n+    }\n+\n+  /* If we've already hit a snag, we're done.  */\n+  if (lfi->errstr)\n+    return;\n+\n+  /* Check accessibility.  */\n+  if (lfi->protect)\n+    {\n+      /* If is possible for one of the derived types on the path to\n+\t have defined special access for this field.  Look for such\n+\t declarations and report an error if a conflict is found.  */\n+      if (DECL_LANG_SPECIFIC (rval) && DECL_ACCESS (rval))\n+\tfor (tp = search_head; tp < search_tail; ++tp)\n+\t  {\n+\t    tree new_v = NULL_TREE;\n+\t\n+\t    if (lfi->access != access_default_node)\n+\t      new_v = compute_access (*tp, lfi->rval);\n+\t    if (lfi->access != access_default_node && new_v != lfi->access)\n+\t      {\n+\t\tlfi->errstr = \"conflicting access to member `%D'\";\n+\t\tlfi->access = access_default_node;\n+\t\treturn; \n+\t      }\n+\t    own_access = new_v;\n+\t    tp++;\n+\t  }\n+  \n+      /* Check to see that access to the member is allowed.  */\n+      if (own_access == access_private_node)\n+\tlfi->errstr = \"member `%D' declared private\";\n+      else if (own_access == access_protected_node)\n+\tlfi->errstr = \"member `%D' declared protected\";\n+      else if (lfi->access == access_private_node)\n+\tlfi->errstr = TREE_PRIVATE (lfi->rval)\n+\t  ? \"member `%D' is private\"\n+\t  : \"member `%D' is from private base class\";\n+      else if (lfi->access== access_protected_node)\n+\tlfi->errstr = TREE_PROTECTED (rval)\n+\t  ? \"member `%D' is protected\"\n+\t  : \"member `%D' is from protected base class\";\n+    }\n+\n+  /* The implicit typename extension allows us to find type\n+     declarations in dependent base clases.  It also handles\n+     out-of-class definitions where the enclosing class is a\n+     template.  For example:\n+\n+       template <class T> struct S { struct I { void f(); }; };\n+       template <class T> void S<T>::I::f() {}\n+\n+     will come through here to handle `S<T>::I'.  The bottom line is\n+     that while searching for the field, we will have happily\n+     descended into dependent base classes, and we must now figure out\n+     what to do about it.  */\n+\n+  /* If we're not in a template, or the search terminated in the\n+     current class, then there's no problem.  */\n+  if (!processing_template_decl \n+      || currently_open_class (BINFO_TYPE (lfi->rval_binfo)))\n+    return;\n+  \n+  /* We need to return a member template class so we can define partial\n+     specializations.  Is there a better way?  */\n+  if (DECL_CLASS_TEMPLATE_P (rval))\n+    return;\n+\n+  /* Walk the path to the base in which the search finally suceeded,\n+     checking for dependent bases along the way.  */\n+  for (tp = (currently_open_class (BINFO_TYPE (*search_head)))\n+\t ? search_head + 1 : search_head; \n+       tp < search_tail; \n+       ++tp)\n+    {\n+      if (!uses_template_parms (BINFO_TYPE (*tp)))\n+\tcontinue;\n+\n+      if (TREE_CODE (rval) != TYPE_DECL)\n+\t{\n+\t  /* The thing we're looking for isn't a type, so the implicit\n+\t     typename extension doesn't apply, so we just pretend we\n+\t     didn't find anything.  */\n+\t  lfi->rval = NULL_TREE;\n+\t  return;\n+\t}\n+\n+      /* We've passed a dependent base on our way to finding the\n+\t type.  So, create an implicit typename type.  The appropriate\n+         context for the typename is *TP.  But, there's a small catch;\n+         the base classes for a partial instantiation are not correct,\n+\t because we don't tsubst into them when we do the partial\n+\t instantiation.  So, we just use the context of the current\n+\t class type.  */\n+      lfi->rval = TYPE_STUB_DECL (build_typename_type \n+\t\t\t\t  (BINFO_TYPE (*search_head), \n+\t\t\t\t   lfi->name, lfi->name, \n+\t\t\t\t   TREE_TYPE (rval)));\n+      return;\n+    }\n+}\n+\n /* Look for a field named NAME in an inheritance lattice dominated by\n    XBASETYPE.  PROTECT is zero if we can avoid computing access\n    information, otherwise it is 1.  WANT_TYPE is 1 when we should only\n@@ -863,14 +1132,9 @@ lookup_field (xbasetype, name, protect, want_type)\n      register tree xbasetype, name;\n      int protect, want_type;\n {\n-  int head = 0, tail = 0;\n-  tree rval, rval_binfo = NULL_TREE, rval_binfo_h = NULL_TREE;\n-  tree type = NULL_TREE, basetype_chain, basetype_path = NULL_TREE;\n-  tree this_v = access_default_node;\n-  tree entry, binfo, binfo_h;\n-  tree own_access = access_default_node;\n-  int vbase_name_p = VBASE_NAME_P (name);\n-  tree ambiguous = NULL_TREE;\n+  tree rval, rval_binfo = NULL_TREE;\n+  tree type = NULL_TREE, basetype_path = NULL_TREE;\n+  struct lookup_field_info lfi;\n \n   /* rval_binfo is the binfo associated with the found member, note,\n      this can be set with useful information, even when rval is not\n@@ -888,6 +1152,8 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   char *errstr = 0;\n \n+  bzero (&lfi, sizeof (lfi));\n+\n #if 0\n   /* We cannot search for constructor/destructor names like this.  */\n   /* This can't go here, but where should it go?  */\n@@ -927,306 +1193,31 @@ lookup_field (xbasetype, name, protect, want_type)\n   n_calls_lookup_field++;\n #endif /* GATHER_STATISTICS */\n \n-  rval = lookup_field_1 (type, name);\n-\n-  if (rval || lookup_fnfields_here (type, name) >= 0)\n-    {\n-      if (rval)\n-\t{\n-\t  if (want_type)\n-\t    {\n-\t      if (TREE_CODE (rval) != TYPE_DECL)\n-\t\t{\n-\t\t  rval = purpose_member (name, CLASSTYPE_TAGS (type));\n-\t\t  if (rval)\n-\t\t    rval = TYPE_MAIN_DECL (TREE_VALUE (rval));\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TREE_CODE (rval) == TYPE_DECL\n-\t\t  && lookup_fnfields_here (type, name) >= 0)\n-\t\trval = NULL_TREE;\n-\t    }\n-\t}\n-\n-      if (protect && rval)\n-\t{\n-\t  if (TREE_PRIVATE (rval) | TREE_PROTECTED (rval))\n-\t    this_v = compute_access (basetype_path, rval);\n-\t  if (TREE_CODE (rval) == CONST_DECL)\n-\t    {\n-\t      if (this_v == access_private_node)\n-\t\terrstr = \"enum `%D' is a private value of class `%T'\";\n-\t      else if (this_v == access_protected_node)\n-\t\terrstr = \"enum `%D' is a protected value of class `%T'\";\n-\t    }\n-\t  else\n-\t    {\n-\t      if (this_v == access_private_node)\n-\t\terrstr = \"member `%D' is a private member of class `%T'\";\n-\t      else if (this_v == access_protected_node)\n-\t\terrstr = \"member `%D' is a protected member of class `%T'\";\n-\t    }\n-\t}\n-\n-      rval_binfo = basetype_path;\n-      goto out;\n-    }\n-\n-  basetype_chain = build_expr_list (NULL_TREE, basetype_path);\n-\n-  /* The ambiguity check relies upon breadth first searching.  */\n-\n-  search_stack = push_search_level (search_stack, &search_obstack);\n-  binfo = basetype_path;\n-  binfo_h = binfo;\n-\n-  while (1)\n-    {\n-      tree binfos = BINFO_BASETYPES (binfo);\n-      int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-      tree nval;\n-      int idx = -1;\n-\n-      /* Process and/or queue base types.  */\n-      for (i = 0; i < n_baselinks; i++)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t  if (BINFO_FIELDS_MARKED (base_binfo) == 0)\n-\t    {\n-\t      tree btypes;\n-\n-\t      SET_BINFO_FIELDS_MARKED (base_binfo);\n-\t      btypes = scratch_tree_cons (NULL_TREE, base_binfo, basetype_chain);\n-\t      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t\tbtypes = scratch_tree_cons (NULL_TREE,\n-\t\t\t\t    TYPE_BINFO (BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i))),\n-\t\t\t\t    btypes);\n-\t      else\n-\t\tbtypes = scratch_tree_cons (NULL_TREE,\n-\t\t\t\t    TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i),\n-\t\t\t\t    btypes);\n-\t      obstack_ptr_grow (&search_obstack, btypes);\n-\t      tail += 1;\n-\t      if (tail >= search_stack->limit)\n-\t\tmy_friendly_abort (98);\n-\t    }\n-\t}\n-\n-      /* Process head of queue, if one exists.  */\n-      if (head >= tail)\n-\tbreak;\n-\n-      basetype_chain = search_stack->first[head++];\n-      binfo_h = TREE_VALUE (basetype_chain);\n-      basetype_chain = TREE_CHAIN (basetype_chain);\n-      basetype_path = TREE_VALUE (basetype_chain);\n-      if (TREE_CHAIN (basetype_chain))\n-\tmy_friendly_assert\n-\t  ((BINFO_INHERITANCE_CHAIN (basetype_path)\n-\t    == TREE_VALUE (TREE_CHAIN (basetype_chain)))\n-\t   /* We only approximate base info for partial instantiations.  */ \n-\t   || current_template_parms,\n-\t   980827);\n-      else\n-\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n-\t\t\t    == NULL_TREE, 980827);\n-\n-      binfo = basetype_path;\n-      type = BINFO_TYPE (binfo);\n-\n-      /* See if we can find NAME in TYPE.  If RVAL is nonzero,\n-\t and we do find NAME in TYPE, verify that such a second\n-\t sighting is in fact valid.  */\n-\n-      nval = lookup_field_1 (type, name);\n-\n-      if (nval || (idx = lookup_fnfields_here (type, name)) >= 0)\n-\t{\n-\t  if (nval && nval == rval && SHARED_MEMBER_P (nval))\n-\t    {\n-\t      /* This is ok, the member found is the same [class.ambig] */\n-\t    }\n-\t  else if (rval_binfo && hides (rval_binfo_h, binfo_h))\n-\t    {\n-\t      /* This is ok, the member found is in rval_binfo, not\n-\t\t here (binfo).  */\n-\t    }\n-\t  else if (rval_binfo==NULL_TREE || hides (binfo_h, rval_binfo_h))\n-\t    {\n-\t      /* This is ok, the member found is here (binfo), not in\n-\t\t rval_binfo.  */\n-\t      if (nval)\n-\t\t{\n-\t\t  rval = nval;\n-\t\t  if (protect)\n-\t\t    this_v = compute_access (basetype_path, rval);\n-\t\t  /* These may look ambiguous, but they really are not.  */\n-\t\t  if (vbase_name_p)\n-\t\t    break;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Undo finding it before, as something else hides it.  */\n-\t\t  rval = NULL_TREE;\n-\t\t}\n-\t      rval_binfo = binfo;\n-\t      rval_binfo_h = binfo_h;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* This is ambiguous. Remember it. */\n-\t      if (! ambiguous)\n-\t        {\n-\t          errstr = \"request for member `%D' is ambiguous\";\n-\t          protect += 2;\n-\t          if (rval)\n-\t            ambiguous = scratch_tree_cons (NULL_TREE, rval, ambiguous);\n-\t        }\n-\t      if (! nval)\n-\t        {\n-\t          nval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n-\t          nval = OVL_CURRENT (nval);\n-\t        }\n-              ambiguous = scratch_tree_cons (NULL_TREE, nval, ambiguous);\n-\t    }\n-\t}\n-    }\n-  {\n-    tree *tp = search_stack->first;\n-    tree *search_tail = tp + tail;\n-\n-    if (rval_binfo)\n-      {\n-\ttype = BINFO_TYPE (rval_binfo);\n-\n-\tif (rval)\n-\t  {\n-\t    if (want_type)\n-\t      {\n-\t\tif (TREE_CODE (rval) != TYPE_DECL)\n-\t\t  {\n-\t\t    rval = purpose_member (name, CLASSTYPE_TAGS (type));\n-\t\t    if (rval)\n-\t\t      rval = TYPE_MAIN_DECL (TREE_VALUE (rval));\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (TREE_CODE (rval) == TYPE_DECL\n-\t\t    && lookup_fnfields_here (type, name) >= 0)\n-\t\t  rval = NULL_TREE;\n-\t      }\n-\t  }\n-      }\n-\n-    if (rval == NULL_TREE)\n-      errstr = 0;\n-\n-    /* If this FIELD_DECL defines its own access level, deal with that.  */\n-    if (rval && errstr == 0\n-\t&& (protect & 1)\n-\t&& DECL_LANG_SPECIFIC (rval)\n-\t&& DECL_ACCESS (rval))\n-      {\n-\twhile (tp < search_tail)\n-\t  {\n-\t    /* If is possible for one of the derived types on the path to\n-\t       have defined special access for this field.  Look for such\n-\t       declarations and report an error if a conflict is found.  */\n-\t    tree new_v = NULL_TREE;\n-\n-\t    if (this_v != access_default_node)\n-\t      new_v = compute_access (TREE_VALUE (TREE_CHAIN (*tp)), rval);\n-\t    if (this_v != access_default_node && new_v != this_v)\n-\t      {\n-\t\terrstr = \"conflicting access to member `%D'\";\n-\t\tthis_v = access_default_node;\n-\t      }\n-\t    own_access = new_v;\n-\t    CLEAR_BINFO_FIELDS_MARKED (TREE_VALUE (TREE_CHAIN (*tp)));\n-\t    tp += 1;\n-\t  }\n-      }\n-    else\n-      {\n-\twhile (tp < search_tail)\n-\t  {\n-\t    CLEAR_BINFO_FIELDS_MARKED (TREE_VALUE (TREE_CHAIN (*tp)));\n-\t    tp += 1;\n-\t  }\n-      }\n-  }\n-  search_stack = pop_search_level (search_stack);\n-\n-  if (errstr == 0)\n-    {\n-      if (own_access == access_private_node)\n-\terrstr = \"member `%D' declared private\";\n-      else if (own_access == access_protected_node)\n-\terrstr = \"member `%D' declared protected\";\n-      else if (this_v == access_private_node)\n-\terrstr = TREE_PRIVATE (rval)\n-\t  ? \"member `%D' is private\"\n-\t    : \"member `%D' is from private base class\";\n-      else if (this_v == access_protected_node)\n-\terrstr = TREE_PROTECTED (rval)\n-\t  ? \"member `%D' is protected\"\n-\t    : \"member `%D' is from protected base class\";\n-    }\n-\n- out:\n-  if (protect == 2)\n-    {\n-      /* If we are not interested in ambiguities, don't report them,\n-\t just return NULL_TREE.  */\n-      rval = NULL_TREE;\n-      protect = 0;\n-    }\n+  lfi.name = name;\n+  lfi.protect = protect;\n+  lfi.want_type = want_type;\n+  lfi.access = access_default_node;\n+  breadth_first_search (basetype_path, &lookup_field_r, \n+\t\t\t&lookup_field_queue_p, &lookup_field_post, &lfi);\n+  rval = lfi.rval;\n+  rval_binfo = lfi.rval_binfo;\n+  if (rval_binfo)\n+    type = BINFO_TYPE (rval_binfo);\n+  errstr = lfi.errstr;\n+\n+  /* If we are not interested in ambiguities, don't report them;\n+     just return NULL_TREE.  */\n+  if (!protect && lfi.ambiguous)\n+    return NULL_TREE;\n \n   if (errstr && protect)\n     {\n       cp_error (errstr, name, type);\n-      if (ambiguous)\n-        print_candidates (ambiguous);\n+      if (lfi.ambiguous)\n+        print_candidates (lfi.ambiguous);\n       rval = error_mark_node;\n     }\n \n-  /* Do implicit typename stuff.  This code also handles out-of-class\n-     definitions of nested classes whose enclosing class is a\n-     template.  For example:\n-    \n-       template <class T> struct S { struct I { void f(); }; };\n-       template <class T> void S<T>::I::f() {}\n-\n-     will come through here to handle `S<T>::I'.  */\n-  if (rval && processing_template_decl\n-      && ! currently_open_class (BINFO_TYPE (rval_binfo))\n-      && uses_template_parms (type))\n-    {\n-      /* We need to return a member template class so we can define partial\n-\t specializations.  Is there a better way?  */\n-      if (DECL_CLASS_TEMPLATE_P (rval))\n-\treturn rval;\n-\n-      /* Don't return a non-type.  Actually, we ought to return something\n-\t so lookup_name_real can give a warning.  */\n-      if (TREE_CODE (rval) != TYPE_DECL)\n-\treturn NULL_TREE;\n-\n-      binfo = rval_binfo;\n-      for (; ; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n-\tif (BINFO_INHERITANCE_CHAIN (binfo) == NULL_TREE\n-\t    || (BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo))\n-\t\t== current_class_type))\n-\t  break;\n-\n-      entry = build_typename_type (BINFO_TYPE (binfo), name,  name, \n-\t\t\t\t   TREE_TYPE (rval));\n-      return TYPE_STUB_DECL (entry);\n-    }\n-\n   return rval;\n }\n \n@@ -1625,39 +1616,62 @@ lookup_member (xbasetype, name, protect, want_type)\n /* Search a multiple inheritance hierarchy by breadth-first search.\n \n    BINFO is an aggregate type, possibly in a multiple-inheritance hierarchy.\n-   TESTFN is a function, which, if true, means that our condition has been met,\n-   and its return value should be returned.\n+   TESTFN is a function, which, if true, means that our condition has\n+   been met, and its return value should be returned.\n    QFN, if non-NULL, is a predicate dictating whether the type should\n-   even be queued.  */\n+   even be queued.  \n+   POSTFN, if non-NULL, is a function to call before returning.  It is\n+   passed an array whose first element is the most derived type in the\n+   chain, and whose last element is the least derived type. \n+   \n+   All of the functions are also passed the DATA, which they may use\n+   as they see fit.  */\n \n static tree\n-breadth_first_search (binfo, testfn, qfn)\n+breadth_first_search (binfo, testfn, qfn, postfn, data)\n      tree binfo;\n-     tree (*testfn) PROTO((tree));\n-     int (*qfn) PROTO((tree));\n+     tree (*testfn) PROTO((tree, void *));\n+     int (*qfn) PROTO((tree, void *));\n+     void (*postfn) PROTO((tree *, tree *, void *));\n+     void *data;\n {\n   int head = 0, tail = 0;\n   tree rval = NULL_TREE;\n+  tree *tp;\n+  tree *search_tail;\n \n   search_stack = push_search_level (search_stack, &search_obstack);\n \n   SET_BINFO_MARKED (binfo);\n   obstack_ptr_grow (&search_obstack, binfo);\n   ++tail;\n \n-  while (1)\n+  while (head < tail)\n     {\n-      tree binfos = BINFO_BASETYPES (binfo);\n-      int n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+      tree binfos;\n+      int n_baselinks;\n       int i;\n \n-      /* Process and/or queue base types.  */\n+      /* Pull the next type out of the queue.  */\n+      binfo = search_stack->first[head++];\n+\n+      /* If this is the one we're looking for, we're done.  */\n+      rval = (*testfn) (binfo, data);\n+      if (rval)\n+\tbreak;\n+\n+      /* Queue up the base types.  */\n+      binfos = BINFO_BASETYPES (binfo);\n+      n_baselinks = binfos ? TREE_VEC_LENGTH (binfos): 0;\n       for (i = 0; i < n_baselinks; i++)\n \t{\n \t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n+\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t    base_binfo = TYPE_BINFO (BINFO_TYPE (base_binfo));\n+\n \t  if (BINFO_MARKED (base_binfo) == 0\n-\t      && (qfn == 0 || (*qfn) (base_binfo)))\n+\t      && (qfn == 0 || (*qfn) (base_binfo, data)))\n \t    {\n \t      SET_BINFO_MARKED (base_binfo);\n \t      obstack_ptr_grow (&search_obstack, base_binfo);\n@@ -1666,26 +1680,19 @@ breadth_first_search (binfo, testfn, qfn)\n \t\tmy_friendly_abort (100);\n \t    }\n \t}\n-      /* Process head of queue, if one exists.  */\n-      if (head >= tail)\n-\t{\n-\t  rval = 0;\n-\t  break;\n-\t}\n+    }\n \n-      binfo = search_stack->first[head++];\n-      if ((rval = (*testfn) (binfo)))\n-\tbreak;\n+  tp = search_stack->first;\n+  search_tail = tp + tail;\n+  \n+  if (postfn)\n+    (*postfn) (tp, search_tail, data);\n+  \n+  while (tp < search_tail)\n+    {\n+      tree binfo = *tp++;\n+      CLEAR_BINFO_MARKED (binfo);\n     }\n-  {\n-    tree *tp = search_stack->first;\n-    tree *search_tail = tp + tail;\n-    while (tp < search_tail)\n-      {\n-\ttree binfo = *tp++;\n-\tCLEAR_BINFO_MARKED (binfo);\n-      }\n-  }\n \n   search_stack = pop_search_level (search_stack);\n   return rval;\n@@ -1723,8 +1730,9 @@ get_virtuals_named_this (binfo)\n }\n \n static tree\n-get_virtual_destructor (binfo)\n+get_virtual_destructor (binfo, data)\n      tree binfo;\n+     void *data;\n {\n   tree type = BINFO_TYPE (binfo);\n   if (TYPE_HAS_DESTRUCTOR (type)\n@@ -1734,8 +1742,9 @@ get_virtual_destructor (binfo)\n }\n \n static int\n-tree_has_any_destructor_p (binfo)\n+tree_has_any_destructor_p (binfo, data)\n      tree binfo;\n+     void *data;\n {\n   tree type = BINFO_TYPE (binfo);\n   return TYPE_NEEDS_DESTRUCTOR (type);\n@@ -1824,7 +1833,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n     {\n       return breadth_first_search (binfo,\n \t\t\t\t   get_virtual_destructor,\n-\t\t\t\t   tree_has_any_destructor_p);\n+\t\t\t\t   tree_has_any_destructor_p, 0, 0);\n     }\n   else\n     {\n@@ -3310,13 +3319,14 @@ reinit_search_statistics ()\n \n #define scratch_tree_cons expr_tree_cons\n \n-static tree conversions;\n static tree\n-add_conversions (binfo)\n+add_conversions (binfo, data)\n      tree binfo;\n+     void *data;\n {\n   int i;\n   tree method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n+  tree *conversions = (tree *) data;\n \n   for (i = 2; i < TREE_VEC_LENGTH (method_vec); ++i)\n     {\n@@ -3331,7 +3341,7 @@ add_conversions (binfo)\n       /* Make sure we don't already have this conversion.  */\n       if (! IDENTIFIER_MARKED (name))\n \t{\n-\t  conversions = scratch_tree_cons (binfo, tmp, conversions);\n+\t  *conversions = scratch_tree_cons (binfo, tmp, *conversions);\n \t  IDENTIFIER_MARKED (name) = 1;\n \t}\n     }\n@@ -3343,11 +3353,11 @@ lookup_conversions (type)\n      tree type;\n {\n   tree t;\n-\n-  conversions = NULL_TREE;\n+  tree conversions = NULL_TREE;\n \n   if (TYPE_SIZE (type))\n-    breadth_first_search (TYPE_BINFO (type), add_conversions, 0);\n+    breadth_first_search (TYPE_BINFO (type), add_conversions,\n+\t\t\t  0, 0, &conversions);\n \n   for (t = conversions; t; t = TREE_CHAIN (t))\n     IDENTIFIER_MARKED (DECL_NAME (OVL_CURRENT (TREE_VALUE (t)))) = 0;"}, {"sha": "c924adf45d74cec84889118b5ab19ac7470d9257", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash7.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash7.C?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+\n+void f() \n+{\n+  union {\n+  private:\n+    int i;\n+  } u;\n+\n+  u.i = 3; // ERROR - private\n+}"}, {"sha": "8e26057922e396aceb94da58da0923c0c2729254", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename15.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename15.C?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+// Special g++ Options:\n+\n+template <class T, bool B> \n+struct R {\n+  struct X {};\n+};\n+\n+template <class T, bool B = false>\n+struct S : public R <T, B> {\n+};\n+\n+template <class T> void f() \n+{\n+  S<T>::X();\n+}\n+\n+template void f<int>();"}, {"sha": "51a8765e9ac157e9acb23502ac87f4aee08861b1", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename16.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename16.C?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -0,0 +1,31 @@\n+// Build don't run:\n+// Special g++ Options:\n+\n+struct B {\n+  typedef int I;\n+};\n+\n+template <class T>\n+struct D1 : public B {\n+};\n+\n+template <class T>\n+struct D2 : public D1<T> {\n+  I i;\n+};\n+\n+template <>\n+struct D1<int> {\n+  typedef double I;\n+};\n+\n+template <class T>\n+void f(T);\n+template <>\n+void f(double) {}\n+\n+int main()\n+{\n+  D2<int> d2i;\n+  f(d2i.i);\n+}"}, {"sha": "87b0ab3b90511132203bca4d5c5aba7d20125d73", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename17.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename17.C?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -0,0 +1,20 @@\n+// Build don't link:\n+\n+template <class T>\n+struct A\n+{\n+  typedef T A_Type;\n+};\n+\n+\n+template <class U>\n+struct B : public A<U>\n+{\n+  typename B<U>::A_Type Func();\n+};\n+\n+\n+template <class U>\n+typename B<U>::A_Type B<U>::Func()\n+{\n+}"}, {"sha": "55d6430f2efd325a2258deff81183bea4a6e0b8c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4bdeed81155efff35f8713d203d86c5733f791/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename3.C?ref=7d4bdeed81155efff35f8713d203d86c5733f791", "patch": "@@ -16,6 +16,6 @@ struct B : public A<U>\n \n \n template <class U>\n-A<U>::A_Type B<U>::Func()\n+B<U>::A_Type B<U>::Func()\n {\n }"}]}