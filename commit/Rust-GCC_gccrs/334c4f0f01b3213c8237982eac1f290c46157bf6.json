{"sha": "334c4f0f01b3213c8237982eac1f290c46157bf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM0YzRmMGYwMWIzMjEzYzgyMzc5ODJlYWMxZjI5MGM0NjE1N2JmNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-12-11T13:58:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-12-11T13:58:10Z"}, "message": "(emit_library_call...\n\n(emit_library_call, emit_library_call_value): Don't pass an identifier\nnode as function type for library functions, but rather build a\nfunction type that has a return type with the correct mode.\n\nFrom-SVN: r13275", "tree": {"sha": "bac5d29249d939893401159401c82716aef25adb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bac5d29249d939893401159401c82716aef25adb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/334c4f0f01b3213c8237982eac1f290c46157bf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/334c4f0f01b3213c8237982eac1f290c46157bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/334c4f0f01b3213c8237982eac1f290c46157bf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/334c4f0f01b3213c8237982eac1f290c46157bf6/comments", "author": null, "committer": null, "parents": [{"sha": "6d101824da66bef99004fe3e552bae5a57011e30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d101824da66bef99004fe3e552bae5a57011e30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d101824da66bef99004fe3e552bae5a57011e30"}], "stats": {"total": 22, "additions": 16, "deletions": 6}, "files": [{"sha": "580235081120ed03eca998ffb923efa77cc05587", "filename": "gcc/calls.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/334c4f0f01b3213c8237982eac1f290c46157bf6/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/334c4f0f01b3213c8237982eac1f290c46157bf6/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=334c4f0f01b3213c8237982eac1f290c46157bf6", "patch": "@@ -304,9 +304,11 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n    FNDECL is the declaration node of the function.  This is given to the\n    macro RETURN_POPS_ARGS to determine whether this function pops its own args.\n \n-   FUNTYPE is the data type of the function, or, for a library call,\n-   the identifier for the name of the call.  This is given to the\n-   macro RETURN_POPS_ARGS to determine whether this function pops its own args.\n+   FUNTYPE is the data type of the function.  This is given to the macro\n+   RETURN_POPS_ARGS to determine whether this function pops its own args.\n+   We used to allow an identifier for library functions, but that doesn't\n+   work when the return type is an aggregate type and the calling convention\n+   says that the pointer to this aggregate is to be popped by the callee.\n \n    STACK_SIZE is the number of bytes of arguments on the stack,\n    rounded up to STACK_BOUNDARY; zero if the size is variable.\n@@ -2496,9 +2498,15 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n      will set inhibit_defer_pop to that value.  */\n \n+  /* The return type is needed to decide how many bytes the function pops.\n+     Signedness plays no role in that, so for simplicity, we pretend it's\n+     always signed.  We also assume that the list of arguments passed has\n+     no impact, so we pretend it is unknown.  */\n+\n   emit_call_1 (fun, \n                get_identifier (XSTR (orgfun, 0)), \n-               get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n+\t       build_function_type (type_for_mode (outmode, 0), NULL_TREE),\n+               args_size.constant, 0,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n \t       old_inhibit_defer_pop + 1, call_fusage, no_queue);\n@@ -2856,11 +2864,13 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \n   /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n      will set inhibit_defer_pop to that value.  */\n+  /* See the comment in emit_library_call about the function type we build\n+     and pass here.  */\n \n   emit_call_1 (fun, \n                get_identifier (XSTR (orgfun, 0)),\n-               get_identifier (XSTR (orgfun, 0)), args_size.constant,\n-\t       struct_value_size,\n+\t       build_function_type (type_for_mode (outmode, 0), NULL_TREE),\n+               args_size.constant, struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       (outmode != VOIDmode && mem_value == 0\n \t\t? hard_libcall_value (outmode) : NULL_RTX),"}]}