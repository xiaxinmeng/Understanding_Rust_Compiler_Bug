{"sha": "70186b342c44e983d7005488b9427f0d00907ae8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAxODZiMzQyYzQ0ZTk4M2Q3MDA1NDg4Yjk0MjdmMGQwMDkwN2FlOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1999-01-06T23:33:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-06T23:33:29Z"}, "message": "combine.c (num_sign_bit_copies): In NEG...\n\n        * combine.c (num_sign_bit_copies): In NEG, MULT, DIV and MOD cases,\n        when a test can't be performed due to limited width of\n        HOST_BITS_PER_WIDE_INT, use the more conservative approximation.\n        Fix UDIV case for cases where the first operand has the highest bit\n        set.\n\nFrom-SVN: r24547", "tree": {"sha": "1040cfc2130c6988db39bccbc1bcff506275d78c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1040cfc2130c6988db39bccbc1bcff506275d78c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70186b342c44e983d7005488b9427f0d00907ae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70186b342c44e983d7005488b9427f0d00907ae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70186b342c44e983d7005488b9427f0d00907ae8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70186b342c44e983d7005488b9427f0d00907ae8/comments", "author": null, "committer": null, "parents": [{"sha": "548e44b3366c210afee8754753a82a8641118684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548e44b3366c210afee8754753a82a8641118684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/548e44b3366c210afee8754753a82a8641118684"}], "stats": {"total": 54, "additions": 36, "deletions": 18}, "files": [{"sha": "0d190d5036e7971abfc0804a0ec6129ad4ecf154", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70186b342c44e983d7005488b9427f0d00907ae8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70186b342c44e983d7005488b9427f0d00907ae8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70186b342c44e983d7005488b9427f0d00907ae8", "patch": "@@ -1,3 +1,11 @@\n+Thu Jan  7 00:29:25 199  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* combine.c (num_sign_bit_copies): In NEG, MULT, DIV and MOD cases,\n+\twhen a test can't be performed due to limited width of\n+\tHOST_BITS_PER_WIDE_INT, use the more conservative approximation.\n+\tFix UDIV case for cases where the first operand has the highest bit\n+\tset.\n+\n Thu Jan  7 00:01:38 1999  Lutz Vieweg <lkv@mania.robin.de>\n \n \t* pa.h (reg_class): Add FPUPPER_REGS."}, {"sha": "a528a5658afbd91e5a94a2c8972f8a6ee01ef433", "filename": "gcc/combine.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70186b342c44e983d7005488b9427f0d00907ae8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70186b342c44e983d7005488b9427f0d00907ae8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=70186b342c44e983d7005488b9427f0d00907ae8", "patch": "@@ -8020,13 +8020,15 @@ num_sign_bit_copies (x, mode)\n \t is known to be positive, the number of sign bit copies is the\n \t same as that of the input.  Finally, if the input has just one bit\n \t that might be nonzero, all the bits are copies of the sign bit.  */\n+      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      if (bitwidth > HOST_BITS_PER_WIDE_INT)\n+\treturn num0 > 1 ? num0 - 1 : 1;\n+\n       nonzero = nonzero_bits (XEXP (x, 0), mode);\n       if (nonzero == 1)\n \treturn bitwidth;\n \n-      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n       if (num0 > 1\n-\t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && (((HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero))\n \tnum0--;\n \n@@ -8070,19 +8072,27 @@ num_sign_bit_copies (x, mode)\n \n       result = bitwidth - (bitwidth - num0) - (bitwidth - num1);\n       if (result > 0\n-\t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && ((nonzero_bits (XEXP (x, 0), mode)\n-\t       & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n-\t  && ((nonzero_bits (XEXP (x, 1), mode)\n-\t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n+\t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n+\t      || (((nonzero_bits (XEXP (x, 0), mode)\n+\t\t    & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t\t  && ((nonzero_bits (XEXP (x, 1), mode)\n+\t\t       & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))))\n \tresult--;\n \n       return MAX (1, result);\n \n     case UDIV:\n-      /* The result must be <= the first operand.  */\n-      return num_sign_bit_copies (XEXP (x, 0), mode);\n-\n+      /* The result must be <= the first operand.  If the first operand\n+         has the high bit set, we know nothing about the number of sign\n+         bit copies.  */\n+      if (bitwidth > HOST_BITS_PER_WIDE_INT)\n+\treturn 1;\n+      else if ((nonzero_bits (XEXP (x, 0), mode)\n+\t\t& ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\treturn 1;\n+      else\n+\treturn num_sign_bit_copies (XEXP (x, 0), mode);\n+\t\t\t\t    \n     case UMOD:\n       /* The result must be <= the scond operand.  */\n       return num_sign_bit_copies (XEXP (x, 1), mode);\n@@ -8093,20 +8103,20 @@ num_sign_bit_copies (x, mode)\n \t to add 1.  */\n       result = num_sign_bit_copies (XEXP (x, 0), mode);\n       if (result > 1\n-\t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero_bits (XEXP (x, 1), mode)\n-\t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n-\tresult --;\n+\t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n+\t      || (nonzero_bits (XEXP (x, 1), mode)\n+\t\t  & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n+\tresult--;\n \n       return result;\n \n     case MOD:\n       result = num_sign_bit_copies (XEXP (x, 1), mode);\n       if (result > 1\n-\t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero_bits (XEXP (x, 1), mode)\n-\t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n-\tresult --;\n+\t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n+\t      || (nonzero_bits (XEXP (x, 1), mode)\n+\t\t  & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n+\tresult--;\n \n       return result;\n "}]}