{"sha": "e81b856471b18de439f9157932ee8aa0fa190928", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgxYjg1NjQ3MWIxOGRlNDM5ZjkxNTc5MzJlZThhYTBmYTE5MDkyOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-04-16T08:34:30Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-04-16T08:34:30Z"}, "message": "sse.md (V16): New mode iterator.\n\n\t* config/i386/sse.md (V16): New mode iterator.\n\t(VI1, VI8): Ditto.\n\t(AVXMODEQI, AVXMODEDI): Remove.\n\t(sse2, sse3): New mode attribute.\n\t(mov<mode>): Use V16 mode iterator.\n\t(*mov<mode>_internal): Merge with *avx_mov<mode>_internal.\n\t(push<mode>1): Use V16 mode iterator.\n\t(movmisalign<mode>): Ditto.\n\t(<sse>_movu<ssemodesuffix><avxmodesuffix>): Merge from\n\t<sse>_movu<ssemodesuffix> and avx_movu<ssemodesuffix><avxmodesuffix>.\n\t(*<sse>_movu<ssemodesuffix><avxmodesuffix>): Merge from\n\t*<sse>_movu<ssemodesuffix> and *avx_movu<ssemodesuffix><avxmodesuffix>.\n\t(<sse2>_movdqu<avxmodesuffix>): Merge from sse2_movdqu and\n\tavx_movdqu<avxmodesuffix>.\n\t(*<sse2>_movdqu<avxmodesuffix>): Merge from *sse2_movdqu and\n\t*avx_movdqu<avxmodesuffix>.\n\t(<sse3>_lddqu<avxmodesuffix>) Merge from sse3_lddqu and\n\tavx_lddqu<avxmodesuffix>.\n\t(<sse>_movnt<mode>): Merge with avx_movnt<AVXMODEF2P:mode>.\n\t(<sse2>_movnt<mode>): Merge from sse2_movntv2di and\n\tavx_movnt<AVXMODEDI:mode>.\n\t* config/i386/i386.c (ix86_expand_vector_move_misalign): Update for\n\trenamed sse_movups, sse2_movupd and sse2_movdqu patterns.\n\ntestsuite/ChangeLog:\n\n\t* gcc.target/i386/avx256-unaligned-load-1.c: Update scan patterns.\n\t* gcc.target/i386/avx256-unaligned-load-2.c: Ditto.\n\t* gcc.target/i386/avx256-unaligned-load-3.c: Ditto.\n\t* gcc.target/i386/avx256-unaligned-store-1.c: Ditto.\n\t* gcc.target/i386/avx256-unaligned-store-2.c: Ditto.\n\t* gcc.target/i386/avx256-unaligned-store-3.c: Ditto.\n\nFrom-SVN: r172580", "tree": {"sha": "6f5c049832df3c28a43f28b8c73499a92cae6ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f5c049832df3c28a43f28b8c73499a92cae6ec8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e81b856471b18de439f9157932ee8aa0fa190928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81b856471b18de439f9157932ee8aa0fa190928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e81b856471b18de439f9157932ee8aa0fa190928", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81b856471b18de439f9157932ee8aa0fa190928/comments", "author": null, "committer": null, "parents": [{"sha": "271d3f8d24a5b54ce5f1462fa1f6aa48b0d28d89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271d3f8d24a5b54ce5f1462fa1f6aa48b0d28d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271d3f8d24a5b54ce5f1462fa1f6aa48b0d28d89"}], "stats": {"total": 454, "additions": 197, "deletions": 257}, "files": [{"sha": "e3a583af770ec0826ad9e9d52db0aa095da1ddef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -1,3 +1,29 @@\n+2011-04-16  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/sse.md (V16): New mode iterator.\n+\t(VI1, VI8): Ditto.\n+\t(AVXMODEQI, AVXMODEDI): Remove.\n+\t(sse2, sse3): New mode attribute.\n+\t(mov<mode>): Use V16 mode iterator.\n+\t(*mov<mode>_internal): Merge with *avx_mov<mode>_internal.\n+\t(push<mode>1): Use V16 mode iterator.\n+\t(movmisalign<mode>): Ditto.\n+\t(<sse>_movu<ssemodesuffix><avxmodesuffix>): Merge from\n+\t<sse>_movu<ssemodesuffix> and avx_movu<ssemodesuffix><avxmodesuffix>.\n+\t(*<sse>_movu<ssemodesuffix><avxmodesuffix>): Merge from\n+\t*<sse>_movu<ssemodesuffix> and *avx_movu<ssemodesuffix><avxmodesuffix>.\n+\t(<sse2>_movdqu<avxmodesuffix>): Merge from sse2_movdqu and\n+\tavx_movdqu<avxmodesuffix>.\n+\t(*<sse2>_movdqu<avxmodesuffix>): Merge from *sse2_movdqu and\n+\t*avx_movdqu<avxmodesuffix>.\n+\t(<sse3>_lddqu<avxmodesuffix>) Merge from sse3_lddqu and\n+\tavx_lddqu<avxmodesuffix>.\n+\t(<sse>_movnt<mode>): Merge with avx_movnt<AVXMODEF2P:mode>.\n+\t(<sse2>_movnt<mode>): Merge from sse2_movntv2di and\n+\tavx_movnt<AVXMODEDI:mode>.\n+\t* config/i386/i386.c (ix86_expand_vector_move_misalign): Update for\n+\trenamed sse_movups, sse2_movupd and sse2_movdqu patterns.\n+\n 2011-04-16  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR target/48629\n@@ -24,8 +50,8 @@\n \t* gimple.h (enum gf_mask): Add GF_CALL_ALLOCA_FOR_VAR.\n \t(gimple_call_set_alloca_for_var): New inline function.\n \t(gimple_call_alloca_for_var_p): Ditto.\n-\t* gimple.c (gimple_build_call_from_tree): Remember CALL_ALLOCA_FOR_VAR_P\n-\tstate.\n+\t* gimple.c (gimple_build_call_from_tree): Remember\n+\tCALL_ALLOCA_FOR_VAR_P state.\n \t* cfgexpand.c (expand_call_stmt): Restore CALL_ALLOCA_FOR_VAR_P state.\n \n \t* tree-inline.c (inline_forbidden_p_stmt): Don't reject alloca\n@@ -87,7 +113,7 @@\n \t-fsched-pressure.\n \n 2011-04-15  Georg-Johann Lay  <avr@gjlay.de>\n-\t\n+\n \t* config/avr/avr.md (\"rotl<mode>3\",mode=HIDI): Use match_dup\n \tinstead of match_operand for operand 3.\n "}, {"sha": "36320d8434e2e83db948df3869c61905f6bd2c9e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -15769,12 +15769,12 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t\t{\n \t\t  op0 = gen_lowpart (V4SFmode, op0);\n \t\t  op1 = gen_lowpart (V4SFmode, op1);\n-\t\t  emit_insn (gen_avx_movups (op0, op1));\n+\t\t  emit_insn (gen_sse_movups (op0, op1));\n \t\t  return;\n \t\t}\n \t      op0 = gen_lowpart (V16QImode, op0);\n \t      op1 = gen_lowpart (V16QImode, op1);\n-\t      emit_insn (gen_avx_movdqu (op0, op1));\n+\t      emit_insn (gen_sse2_movdqu (op0, op1));\n \t      break;\n \t    case 32:\n \t      op0 = gen_lowpart (V32QImode, op0);\n@@ -15792,7 +15792,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t  switch (mode)\n \t    {\n \t    case V4SFmode:\n-\t      emit_insn (gen_avx_movups (op0, op1));\n+\t      emit_insn (gen_sse_movups (op0, op1));\n \t      break;\n \t    case V8SFmode:\n \t      ix86_avx256_split_vector_move_misalign (op0, op1);\n@@ -15802,10 +15802,10 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t\t{\n \t\t  op0 = gen_lowpart (V4SFmode, op0);\n \t\t  op1 = gen_lowpart (V4SFmode, op1);\n-\t\t  emit_insn (gen_avx_movups (op0, op1));\n+\t\t  emit_insn (gen_sse_movups (op0, op1));\n \t\t  return;\n \t\t}\n-\t      emit_insn (gen_avx_movupd (op0, op1));\n+\t      emit_insn (gen_sse2_movupd (op0, op1));\n \t      break;\n \t    case V4DFmode:\n \t      ix86_avx256_split_vector_move_misalign (op0, op1);"}, {"sha": "40e39725af56d1fe52ddbd1091d6cecb44536be3", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 145, "deletions": 240, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -18,6 +18,15 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;; All vector modes including V1TImode.\n+(define_mode_iterator V16\n+  [(V32QI \"TARGET_AVX\") V16QI\n+   (V16HI \"TARGET_AVX\") V8HI\n+   (V8SI \"TARGET_AVX\") V4SI\n+   (V4DI \"TARGET_AVX\") V2DI\n+   V1TI\n+   (V8SF \"TARGET_AVX\") V4SF\n+   (V4DF \"TARGET_AVX\") V2DF])\n \n ;; All vector float modes\n (define_mode_iterator VF\n@@ -43,6 +52,14 @@\n    (V8SI \"TARGET_AVX\") V4SI\n    (V4DI \"TARGET_AVX\") V2DI])\n \n+;; All QImode vector integer modes\n+(define_mode_iterator VI1\n+  [(V32QI \"TARGET_AVX\") V16QI])\n+\n+;; All DImode vector integer modes\n+(define_mode_iterator VI8\n+  [(V4DI \"TARGET_AVX\") V2DI])\n+\n ;; All 128bit vector integer modes\n (define_mode_iterator VI_128 [V16QI V8HI V4SI V2DI])\n \n@@ -59,22 +76,13 @@\n \n ;; All 16-byte vector modes handled by SSE\n (define_mode_iterator SSEMODE [V16QI V8HI V4SI V2DI V4SF V2DF])\n-(define_mode_iterator SSEMODE16 [V16QI V8HI V4SI V2DI V1TI V4SF V2DF])\n \n ;; All 32-byte vector modes handled by AVX\n (define_mode_iterator AVX256MODE [V32QI V16HI V8SI V4DI V8SF V4DF])\n \n-;; All QI vector modes handled by AVX\n-(define_mode_iterator AVXMODEQI [V32QI V16QI])\n-\n-;; All DI vector modes handled by AVX\n-(define_mode_iterator AVXMODEDI [V4DI V2DI])\n-\n ;; All vector modes handled by AVX\n (define_mode_iterator AVXMODE\n   [V16QI V8HI V4SI V2DI V4SF V2DF V32QI V16HI V8SI V4DI V8SF V4DF])\n-(define_mode_iterator AVXMODE16\n-  [V16QI V8HI V4SI V2DI V1TI V4SF V2DF V32QI V16HI V8SI V4DI V8SF V4DF])\n \n ;; Mix-n-match\n (define_mode_iterator SSEMODE124 [V16QI V8HI V4SI])\n@@ -107,8 +115,8 @@\n ;; Modes handled by storent patterns.\n (define_mode_iterator STORENT_MODE\n   [(SF \"TARGET_SSE4A\") (DF \"TARGET_SSE4A\")\n-   (SI \"TARGET_SSE2\") (V2DI \"TARGET_SSE2\") (V2DF \"TARGET_SSE2\")\n-   (V4SF \"TARGET_SSE\")\n+   (SI \"TARGET_SSE2\") (V2DI \"TARGET_SSE2\")\n+   (V4SF \"TARGET_SSE\") (V2DF \"TARGET_SSE2\")\n    (V4DF \"TARGET_AVX\") (V8SF \"TARGET_AVX\")])\n \n ;; Modes handled by vector extract patterns.\n@@ -124,6 +132,13 @@\n    (V4SF \"sse\") (V2DF \"sse2\")\n    (V8SF \"avx\") (V4DF \"avx\")])\n \n+(define_mode_attr sse2\n+  [(V16QI \"sse2\") (V32QI \"avx\")\n+   (V2DI \"sse2\") (V4DI \"avx\")])\n+\n+(define_mode_attr sse3\n+  [(V16QI \"sse3\") (V32QI \"avx\")])\n+\n (define_mode_attr sse4_1\n   [(V4SF \"sse4_1\") (V2DF \"sse4_1\")\n    (V8SF \"avx\") (V4DF \"avx\")])\n@@ -192,19 +207,22 @@\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n+;; All of these patterns are enabled for SSE1 as well as SSE2.\n+;; This is essential for maintaining stable calling conventions.\n+\n (define_expand \"mov<mode>\"\n-  [(set (match_operand:AVX256MODE 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:AVX256MODE 1 \"nonimmediate_operand\" \"\"))]\n-  \"TARGET_AVX\"\n+  [(set (match_operand:V16 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:V16 1 \"nonimmediate_operand\" \"\"))]\n+  \"TARGET_SSE\"\n {\n   ix86_expand_vector_move (<MODE>mode, operands);\n   DONE;\n })\n \n-(define_insn \"*avx_mov<mode>_internal\"\n-  [(set (match_operand:AVXMODE16 0 \"nonimmediate_operand\" \"=x,x ,m\")\n-\t(match_operand:AVXMODE16 1 \"nonimmediate_or_sse_const_operand\"  \"C ,xm,x\"))]\n-  \"TARGET_AVX\n+(define_insn \"*mov<mode>_internal\"\n+  [(set (match_operand:V16 0 \"nonimmediate_operand\" \"=x,x ,m\")\n+\t(match_operand:V16 1 \"nonimmediate_or_sse_const_operand\"  \"C ,xm,x\"))]\n+  \"TARGET_SSE\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n {\n@@ -218,85 +236,51 @@\n         {\n \tcase MODE_V8SF:\n \tcase MODE_V4SF:\n-\t  if (misaligned_operand (operands[0], <MODE>mode)\n-\t      || misaligned_operand (operands[1], <MODE>mode))\n+\t  if (TARGET_AVX\n+\t      && (misaligned_operand (operands[0], <MODE>mode)\n+\t\t  || misaligned_operand (operands[1], <MODE>mode)))\n \t    return \"vmovups\\t{%1, %0|%0, %1}\";\n \t  else\n-\t    return \"vmovaps\\t{%1, %0|%0, %1}\";\n+\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\n \tcase MODE_V4DF:\n \tcase MODE_V2DF:\n-\t  if (misaligned_operand (operands[0], <MODE>mode)\n-\t      || misaligned_operand (operands[1], <MODE>mode))\n+\t  if (TARGET_AVX\n+\t      && (misaligned_operand (operands[0], <MODE>mode)\n+\t\t  || misaligned_operand (operands[1], <MODE>mode)))\n \t    return \"vmovupd\\t{%1, %0|%0, %1}\";\n \t  else if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"vmovaps\\t{%1, %0|%0, %1}\";\n+\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \t  else\n-\t    return \"vmovapd\\t{%1, %0|%0, %1}\";\n-\tdefault:\n-\t  if (misaligned_operand (operands[0], <MODE>mode)\n-\t      || misaligned_operand (operands[1], <MODE>mode))\n+\t    return \"%vmovapd\\t{%1, %0|%0, %1}\";\n+\n+\tcase MODE_OI:\n+\tcase MODE_TI:\n+\t  if (TARGET_AVX\n+\t      && (misaligned_operand (operands[0], <MODE>mode)\n+\t\t  || misaligned_operand (operands[1], <MODE>mode)))\n \t    return \"vmovdqu\\t{%1, %0|%0, %1}\";\n \t  else if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"vmovaps\\t{%1, %0|%0, %1}\";\n+\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \t  else\n-\t    return \"vmovdqa\\t{%1, %0|%0, %1}\";\n-\t}\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"sselog1,ssemov,ssemov\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<avxvecmode>\")])\n-\n-;; All of these patterns are enabled for SSE1 as well as SSE2.\n-;; This is essential for maintaining stable calling conventions.\n-\n-(define_expand \"mov<mode>\"\n-  [(set (match_operand:SSEMODE16 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SSEMODE16 1 \"nonimmediate_operand\" \"\"))]\n-  \"TARGET_SSE\"\n-{\n-  ix86_expand_vector_move (<MODE>mode, operands);\n-  DONE;\n-})\n+\t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n \n-(define_insn \"*mov<mode>_internal\"\n-  [(set (match_operand:SSEMODE16 0 \"nonimmediate_operand\" \"=x,x ,m\")\n-\t(match_operand:SSEMODE16 1 \"nonimmediate_or_sse_const_operand\"  \"C ,xm,x\"))]\n-  \"TARGET_SSE\n-   && (register_operand (operands[0], <MODE>mode)\n-       || register_operand (operands[1], <MODE>mode))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return standard_sse_constant_opcode (insn, operands[1]);\n-    case 1:\n-    case 2:\n-      switch (get_attr_mode (insn))\n-\t{\n-\tcase MODE_V4SF:\n-\t  return \"movaps\\t{%1, %0|%0, %1}\";\n-\tcase MODE_V2DF:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"movaps\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"movapd\\t{%1, %0|%0, %1}\";\n \tdefault:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"movaps\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"movdqa\\t{%1, %0|%0, %1}\";\n+\t  gcc_unreachable ();\n \t}\n     default:\n       gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"sselog1,ssemov,ssemov\")\n+   (set_attr \"prefix\" \"maybe_vex\")\n    (set (attr \"mode\")\n-\t(cond [(ior (ior (ne (symbol_ref \"optimize_function_for_size_p (cfun)\") (const_int 0))\n-\t\t\t (eq (symbol_ref \"TARGET_SSE2\") (const_int 0)))\n+\t(cond [(ne (symbol_ref \"TARGET_AVX\") (const_int 0))\n+\t         (const_string \"<avxvecmode>\")\n+\t       (ior (ior\n+\t      \t      (ne (symbol_ref \"optimize_function_for_size_p (cfun)\")\n+\t\t      \t  (const_int 0))\n+\t\t      (eq (symbol_ref \"TARGET_SSE2\") (const_int 0)))\n \t\t    (and (eq_attr \"alternative\" \"2\")\n \t\t\t (ne (symbol_ref \"TARGET_SSE_TYPELESS_STORES\")\n \t\t\t     (const_int 0))))\n@@ -308,6 +292,19 @@\n \t      ]\n \t  (const_string \"TI\")))])\n \n+(define_insn \"sse2_movq128\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(vec_concat:V2DI\n+\t  (vec_select:DI\n+\t    (match_operand:V2DI 1 \"nonimmediate_operand\" \"xm\")\n+\t    (parallel [(const_int 0)]))\n+\t  (const_int 0)))]\n+  \"TARGET_SSE2\"\n+  \"%vmovq\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"prefix\" \"maybe_vex\")\n+   (set_attr \"mode\" \"TI\")])\n+\n ;; Move a DI from a 32-bit register pair (e.g. %edx:%eax) to an xmm.\n ;; We'd rather avoid this entirely; if the 32-bit reg pair was loaded\n ;; from memory, we'd prefer to load the memory directly into the %xmm\n@@ -370,185 +367,92 @@\n })\n \n (define_expand \"push<mode>1\"\n-  [(match_operand:AVX256MODE 0 \"register_operand\" \"\")]\n-  \"TARGET_AVX\"\n-{\n-  ix86_expand_push (<MODE>mode, operands[0]);\n-  DONE;\n-})\n-\n-(define_expand \"push<mode>1\"\n-  [(match_operand:SSEMODE16 0 \"register_operand\" \"\")]\n+  [(match_operand:V16 0 \"register_operand\" \"\")]\n   \"TARGET_SSE\"\n {\n   ix86_expand_push (<MODE>mode, operands[0]);\n   DONE;\n })\n \n (define_expand \"movmisalign<mode>\"\n-  [(set (match_operand:AVX256MODE 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:AVX256MODE 1 \"nonimmediate_operand\" \"\"))]\n-  \"TARGET_AVX\"\n-{\n-  ix86_expand_vector_move_misalign (<MODE>mode, operands);\n-  DONE;\n-})\n-\n-(define_expand \"movmisalign<mode>\"\n-  [(set (match_operand:SSEMODE16 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SSEMODE16 1 \"nonimmediate_operand\" \"\"))]\n+  [(set (match_operand:V16 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:V16 1 \"nonimmediate_operand\" \"\"))]\n   \"TARGET_SSE\"\n {\n   ix86_expand_vector_move_misalign (<MODE>mode, operands);\n   DONE;\n })\n \n-(define_expand \"avx_movu<ssemodesuffix><avxmodesuffix>\"\n-  [(set (match_operand:AVXMODEF2P 0 \"nonimmediate_operand\" \"\")\n-\t(unspec:AVXMODEF2P\n-\t  [(match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"\")]\n+(define_expand \"<sse>_movu<ssemodesuffix><avxmodesuffix>\"\n+  [(set (match_operand:VF 0 \"nonimmediate_operand\" \"\")\n+\t(unspec:VF\n+\t  [(match_operand:VF 1 \"nonimmediate_operand\" \"\")]\n \t  UNSPEC_MOVU))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n+  \"\"\n {\n   if (MEM_P (operands[0]) && MEM_P (operands[1]))\n     operands[1] = force_reg (<MODE>mode, operands[1]);\n })\n \n-(define_insn \"*avx_movu<ssemodesuffix><avxmodesuffix>\"\n-  [(set (match_operand:AVXMODEF2P 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(unspec:AVXMODEF2P\n-\t  [(match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"xm,x\")]\n+(define_insn \"*<sse>_movu<ssemodesuffix><avxmodesuffix>\"\n+  [(set (match_operand:VF 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(unspec:VF\n+\t  [(match_operand:VF 1 \"nonimmediate_operand\" \"xm,x\")]\n \t  UNSPEC_MOVU))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"vmovu<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"%vmovu<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"movu\" \"1\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"sse2_movq128\"\n-  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n-\t(vec_concat:V2DI\n-\t  (vec_select:DI\n-\t    (match_operand:V2DI 1 \"nonimmediate_operand\" \"xm\")\n-\t    (parallel [(const_int 0)]))\n-\t  (const_int 0)))]\n-  \"TARGET_SSE2\"\n-  \"%vmovq\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssemov\")\n    (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"mode\" \"TI\")])\n-\n-(define_expand \"<sse>_movu<ssemodesuffix>\"\n-  [(set (match_operand:SSEMODEF2P 0 \"nonimmediate_operand\" \"\")\n-\t(unspec:SSEMODEF2P\n-\t  [(match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"\")]\n-\t  UNSPEC_MOVU))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-{\n-  if (MEM_P (operands[0]) && MEM_P (operands[1]))\n-    operands[1] = force_reg (<MODE>mode, operands[1]);\n-})\n-\n-(define_insn \"*<sse>_movu<ssemodesuffix>\"\n-  [(set (match_operand:SSEMODEF2P 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(unspec:SSEMODEF2P\n-\t  [(match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"xm,x\")]\n-\t  UNSPEC_MOVU))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"movu<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"movu\" \"1\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_expand \"avx_movdqu<avxmodesuffix>\"\n-  [(set (match_operand:AVXMODEQI 0 \"nonimmediate_operand\" \"\")\n-\t(unspec:AVXMODEQI\n-\t  [(match_operand:AVXMODEQI 1 \"nonimmediate_operand\" \"\")]\n-\t  UNSPEC_MOVU))]\n-  \"TARGET_AVX\"\n+(define_expand \"<sse2>_movdqu<avxmodesuffix>\"\n+  [(set (match_operand:VI1 0 \"nonimmediate_operand\" \"\")\n+\t(unspec:VI1 [(match_operand:VI1 1 \"nonimmediate_operand\" \"\")]\n+\t\t    UNSPEC_MOVU))]\n+  \"TARGET_SSE2\"\n {\n   if (MEM_P (operands[0]) && MEM_P (operands[1]))\n     operands[1] = force_reg (<MODE>mode, operands[1]);\n })\n \n-(define_insn \"*avx_movdqu<avxmodesuffix>\"\n-  [(set (match_operand:AVXMODEQI 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(unspec:AVXMODEQI\n-\t  [(match_operand:AVXMODEQI 1 \"nonimmediate_operand\" \"xm,x\")]\n-\t  UNSPEC_MOVU))]\n-  \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"vmovdqu\\t{%1, %0|%0, %1}\"\n+(define_insn \"*<sse2>_movdqu<avxmodesuffix>\"\n+  [(set (match_operand:VI1 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(unspec:VI1 [(match_operand:VI1 1 \"nonimmediate_operand\" \"xm,x\")]\n+\t\t    UNSPEC_MOVU))]\n+  \"TARGET_SSE2 && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"%vmovdqu\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"movu\" \"1\")\n-   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"prefix_data16\")\n+     (if_then_else\n+       (ne (symbol_ref \"TARGET_AVX\") (const_int 0))\n+     (const_string \"*\")\n+     (const_string \"1\")))\n+   (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"mode\" \"<avxvecmode>\")])\n \n-(define_expand \"sse2_movdqu\"\n-  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n-\t(unspec:V16QI [(match_operand:V16QI 1 \"nonimmediate_operand\" \"\")]\n-\t\t      UNSPEC_MOVU))]\n-  \"TARGET_SSE2\"\n-{\n-  if (MEM_P (operands[0]) && MEM_P (operands[1]))\n-    operands[1] = force_reg (V16QImode, operands[1]);\n-})\n-\n-(define_insn \"*sse2_movdqu\"\n-  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(unspec:V16QI [(match_operand:V16QI 1 \"nonimmediate_operand\" \"xm,x\")]\n-\t\t      UNSPEC_MOVU))]\n-  \"TARGET_SSE2 && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"movdqu\\t{%1, %0|%0, %1}\"\n+(define_insn \"<sse3>_lddqu<avxmodesuffix>\"\n+  [(set (match_operand:VI1 0 \"register_operand\" \"=x\")\n+\t(unspec:VI1 [(match_operand:VI1 1 \"memory_operand\" \"m\")]\n+\t\t    UNSPEC_LDDQU))]\n+  \"TARGET_SSE3\"\n+  \"%vlddqu\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"movu\" \"1\")\n-   (set_attr \"prefix_data16\" \"1\")\n-   (set_attr \"mode\" \"TI\")])\n-\n-(define_insn \"avx_movnt<mode>\"\n-  [(set (match_operand:AVXMODEF2P 0 \"memory_operand\" \"=m\")\n-\t(unspec:AVXMODEF2P\n-\t  [(match_operand:AVXMODEF2P 1 \"register_operand\" \"x\")]\n-\t  UNSPEC_MOVNT))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vmovnt<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"<sse>_movnt<mode>\"\n-  [(set (match_operand:SSEMODEF2P 0 \"memory_operand\" \"=m\")\n-\t(unspec:SSEMODEF2P\n-\t  [(match_operand:SSEMODEF2P 1 \"register_operand\" \"x\")]\n-\t  UNSPEC_MOVNT))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"movnt<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"avx_movnt<mode>\"\n-  [(set (match_operand:AVXMODEDI 0 \"memory_operand\" \"=m\")\n-\t(unspec:AVXMODEDI\n-\t  [(match_operand:AVXMODEDI 1 \"register_operand\" \"x\")]\n-\t  UNSPEC_MOVNT))]\n-  \"TARGET_AVX\"\n-  \"vmovntdq\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"prefix_data16\")\n+     (if_then_else\n+       (ne (symbol_ref \"TARGET_AVX\") (const_int 0))\n+     (const_string \"*\")\n+     (const_string \"0\")))\n+   (set (attr \"prefix_rep\")\n+     (if_then_else\n+       (ne (symbol_ref \"TARGET_AVX\") (const_int 0))\n+     (const_string \"*\")\n+     (const_string \"1\")))\n+   (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"mode\" \"<avxvecmode>\")])\n \n-(define_insn \"sse2_movntv2di\"\n-  [(set (match_operand:V2DI 0 \"memory_operand\" \"=m\")\n-\t(unspec:V2DI [(match_operand:V2DI 1 \"register_operand\" \"x\")]\n-\t\t     UNSPEC_MOVNT))]\n-  \"TARGET_SSE2\"\n-  \"movntdq\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"prefix_data16\" \"1\")\n-   (set_attr \"mode\" \"TI\")])\n-\n (define_insn \"sse2_movntsi\"\n   [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n \t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")]\n@@ -559,30 +463,31 @@\n    (set_attr \"prefix_data16\" \"0\")\n    (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"avx_lddqu<avxmodesuffix>\"\n-  [(set (match_operand:AVXMODEQI 0 \"register_operand\" \"=x\")\n-\t(unspec:AVXMODEQI\n-\t  [(match_operand:AVXMODEQI 1 \"memory_operand\" \"m\")]\n-\t  UNSPEC_LDDQU))]\n-  \"TARGET_AVX\"\n-  \"vlddqu\\t{%1, %0|%0, %1}\"\n+(define_insn \"<sse>_movnt<mode>\"\n+  [(set (match_operand:VF 0 \"memory_operand\" \"=m\")\n+\t(unspec:VF [(match_operand:VF 1 \"register_operand\" \"x\")]\n+\t\t   UNSPEC_MOVNT))]\n+  \"TARGET_SSE\"\n+  \"%vmovnt<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"prefix\" \"maybe_vex\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"<sse2>_movnt<mode>\"\n+  [(set (match_operand:VI8 0 \"memory_operand\" \"=m\")\n+\t(unspec:VI8 [(match_operand:VI8 1 \"register_operand\" \"x\")]\n+\t\t    UNSPEC_MOVNT))]\n+  \"TARGET_SSE2\"\n+  \"%vmovntdq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"movu\" \"1\")\n-   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"prefix_data16\")\n+     (if_then_else\n+       (ne (symbol_ref \"TARGET_AVX\") (const_int 0))\n+     (const_string \"*\")\n+     (const_string \"1\")))\n+   (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"mode\" \"<avxvecmode>\")])\n \n-(define_insn \"sse3_lddqu\"\n-  [(set (match_operand:V16QI 0 \"register_operand\" \"=x\")\n-\t(unspec:V16QI [(match_operand:V16QI 1 \"memory_operand\" \"m\")]\n-\t\t      UNSPEC_LDDQU))]\n-  \"TARGET_SSE3\"\n-  \"lddqu\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"movu\" \"1\")\n-   (set_attr \"prefix_data16\" \"0\")\n-   (set_attr \"prefix_rep\" \"1\")\n-   (set_attr \"mode\" \"TI\")])\n-\n ; Expand patterns for non-temporal stores.  At the moment, only those\n ; that directly map to insns are defined; it would be possible to\n ; define patterns for other modes that would expand to several insns."}, {"sha": "97613c6b29b7c82b40d7ee22ee06ba11120a6efb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -1,3 +1,12 @@\n+2011-04-16  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.target/i386/avx256-unaligned-load-1.c: Update scan patterns.\n+\t* gcc.target/i386/avx256-unaligned-load-2.c: Ditto.\n+\t* gcc.target/i386/avx256-unaligned-load-3.c: Ditto.\n+\t* gcc.target/i386/avx256-unaligned-store-1.c: Ditto.\n+\t* gcc.target/i386/avx256-unaligned-store-2.c: Ditto.\n+\t* gcc.target/i386/avx256-unaligned-store-3.c: Ditto.\n+\n 2011-04-15  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/range-for17.C: New.\n@@ -22,14 +31,14 @@\n 2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/naming-4.m: Updated.\n-\t* objc.dg/naming-5.m: Updated.\t\n+\t* objc.dg/naming-5.m: Updated.\n \t* objc.dg/naming-6.m: New.\n-\t* objc.dg/naming-7.m: New.\t\n+\t* objc.dg/naming-7.m: New.\n \t* obj-c++.dg/naming-1.mm: Updated.\n \t* obj-c++.dg/naming-2.mm: Updated.\n \t* obj-c++.dg/naming-3.mm: New.\n \t* obj-c++.dg/naming-4.mm: New.\n-\t\n+\n 2011-04-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/48589"}, {"sha": "c909b9402ccdf77207e2e5ebbf47f89cedbe6cb1", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-1.c?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -15,5 +15,5 @@ avx_test (void)\n }\n \n /* { dg-final { scan-assembler-not \"\\\\*avx_movups256/1\" } } */\n-/* { dg-final { scan-assembler \"\\\\*avx_movups/1\" } } */\n+/* { dg-final { scan-assembler \"\\\\*sse_movups/1\" } } */\n /* { dg-final { scan-assembler \"vinsertf128\" } } */"}, {"sha": "7d188e2b4665322e11d6d53535ddd95bf296c0dd", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-2.c?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -25,5 +25,5 @@ avx_test (void)\n }\n \n /* { dg-final { scan-assembler-not \"\\\\*avx_movdqu256/1\" } } */\n-/* { dg-final { scan-assembler \"\\\\*avx_movdqu/1\" } } */\n+/* { dg-final { scan-assembler \"\\\\*sse2_movdqu/1\" } } */\n /* { dg-final { scan-assembler \"vinsertf128\" } } */"}, {"sha": "670305423fe85e5f27f57b8b7a2ab128fcdeba81", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-3.c?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -15,5 +15,5 @@ avx_test (void)\n }\n \n /* { dg-final { scan-assembler-not \"\\\\*avx_movupd256/1\" } } */\n-/* { dg-final { scan-assembler \"\\\\*avx_movupd/1\" } } */\n+/* { dg-final { scan-assembler \"\\\\*sse2_movupd/1\" } } */\n /* { dg-final { scan-assembler \"vinsertf128\" } } */"}, {"sha": "6af02a2202b6cc12515bd075be3d013105ca331e", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -18,5 +18,5 @@ avx_test (void)\n }\n \n /* { dg-final { scan-assembler-not \"\\\\*avx_movups256/2\" } } */\n-/* { dg-final { scan-assembler \"movups.*\\\\*avx_movv4sf_internal/3\" } } */\n+/* { dg-final { scan-assembler \"vmovups.*\\\\*movv4sf_internal/3\" } } */\n /* { dg-final { scan-assembler \"vextractf128\" } } */"}, {"sha": "d8ae5a9018978c9afcfa0f26743aaa93aa60f90a", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-2.c?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -25,5 +25,5 @@ avx_test (void)\n }\n \n /* { dg-final { scan-assembler-not \"\\\\*avx_movdqu256/2\" } } */\n-/* { dg-final { scan-assembler \"movdqu.*\\\\*avx_movv16qi_internal/3\" } } */\n+/* { dg-final { scan-assembler \"vmovdqu.*\\\\*movv16qi_internal/3\" } } */\n /* { dg-final { scan-assembler \"vextractf128\" } } */"}, {"sha": "65e820444e4255e386e0972f1a30c6a1c3ae496b", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b856471b18de439f9157932ee8aa0fa190928/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c?ref=e81b856471b18de439f9157932ee8aa0fa190928", "patch": "@@ -18,5 +18,5 @@ avx_test (void)\n }\n \n /* { dg-final { scan-assembler-not \"\\\\*avx_movupd256/2\" } } */\n-/* { dg-final { scan-assembler \"movupd.*\\\\*avx_movv2df_internal/3\" } } */\n+/* { dg-final { scan-assembler \"vmovupd.*\\\\*movv2df_internal/3\" } } */\n /* { dg-final { scan-assembler \"vextractf128\" } } */"}]}