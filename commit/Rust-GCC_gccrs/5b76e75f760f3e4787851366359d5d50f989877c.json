{"sha": "5b76e75f760f3e4787851366359d5d50f989877c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3NmU3NWY3NjBmM2U0Nzg3ODUxMzY2MzU5ZDVkNTBmOTg5ODc3Yw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-12-06T17:56:58Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-12-06T17:56:58Z"}, "message": "asm inline\n\nThe Linux kernel people want a feature that makes GCC pretend some\ninline assembler code is tiny (while it would think it is huge), so\nthat such code will be inlined essentially always instead of\nessentially never.\n\nThis patch lets you say \"asm inline\" instead of just \"asm\", with the\nresult that that inline assembler is always counted as minimum cost\nfor inlining.  It implements this for C and C++, making \"inline\"\nanother asm-qualifier (supplementing \"volatile\" and \"goto\").\n\n\n\t* doc/extend.texi (Using Assembly Language with C): Document asm inline.\n\t(Size of an asm): Fix typo.  Document asm inline.\n\t* gimple-pretty-print.c (dump_gimple_asm): Handle asm inline.\n\t* gimple.h (enum gf_mask): Add GF_ASM_INLINE.\n\t(gimple_asm_set_volatile): Fix typo.\n\t(gimple_asm_inline_p): New.\n\t(gimple_asm_set_inline): New.\n\t* gimplify.c (gimplify_asm_expr): Propagate the asm inline flag from\n\ttree to gimple.\n\t* ipa-icf-gimple.c (func_checker::compare_gimple_asm): Compare the\n\tgimple_asm_inline_p flag, too.\n\t* tree-core.h (tree_base): Document that protected_flag is ASM_INLINE_P\n\tin an ASM_EXPR.\n\t* tree-inline.c (estimate_num_insns): If gimple_asm_inline_p return\n\ta minimum size for an asm.\n\t* tree.h (ASM_INLINE_P): New.\n\ngcc/c/\n\t* c-parser.c (c_parser_asm_statement): Detect the inline keyword\n\tafter asm.  Pass a flag for it to build_asm_expr.\n\t* c-tree.h (build_asm_expr): Update declaration.\n\t* c-typeck.c (build_asm_stmt): Add is_inline parameter.  Use it to\n\tset ASM_INLINE_P.\n\ngcc/cp/\n\t* cp-tree.h (finish_asm_stmt): Update declaration.\n\t* parser.c (cp_parser_asm_definition): Detect the inline keyword\n\tafter asm.  Pass a flag for it to finish_asm_stmt.\n\t* pt.c (tsubst_expr): Pass the ASM_INLINE_P flag to finish_asm_stmt.\n\t* semantics.c (finish_asm_stmt): Add inline_p parameter.  Use it to\n\tset ASM_INLINE_P.\n\ngcc/testsuite/\n\t* c-c++-common/torture/asm-inline.c: New testcase.\n\t* gcc.dg/asm-qual-2.c: Test asm inline, too.\n\nFrom-SVN: r266860", "tree": {"sha": "ae4aaa5970fcde870ee822e0cab27211b682ea3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae4aaa5970fcde870ee822e0cab27211b682ea3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b76e75f760f3e4787851366359d5d50f989877c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b76e75f760f3e4787851366359d5d50f989877c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b76e75f760f3e4787851366359d5d50f989877c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b76e75f760f3e4787851366359d5d50f989877c/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30bd42b979140de02d343bb1014e9aece2e683c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30bd42b979140de02d343bb1014e9aece2e683c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30bd42b979140de02d343bb1014e9aece2e683c1"}], "stats": {"total": 230, "additions": 215, "deletions": 15}, "files": [{"sha": "8789afacbaff0a9eb925018dc84b9a4f82a1a7e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -1,3 +1,22 @@\n+2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* doc/extend.texi (Using Assembly Language with C): Document asm inline.\n+\t(Size of an asm): Fix typo.  Document asm inline.\n+\t* gimple-pretty-print.c (dump_gimple_asm): Handle asm inline.\n+\t* gimple.h (enum gf_mask): Add GF_ASM_INLINE.\n+\t(gimple_asm_set_volatile): Fix typo.\n+\t(gimple_asm_inline_p): New.\n+\t(gimple_asm_set_inline): New.\n+\t* gimplify.c (gimplify_asm_expr): Propagate the asm inline flag from\n+\ttree to gimple.\n+\t* ipa-icf-gimple.c (func_checker::compare_gimple_asm): Compare the\n+\tgimple_asm_inline_p flag, too.\n+\t* tree-core.h (tree_base): Document that protected_flag is ASM_INLINE_P\n+\tin an ASM_EXPR.\n+\t* tree-inline.c (estimate_num_insns): If gimple_asm_inline_p return\n+\ta minimum size for an asm.\n+\t* tree.h (ASM_INLINE_P): New.\n+\n 2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR inline-asm/55681"}, {"sha": "69d4929624b9ba7905e73f31b78ad7f20146ce4f", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -1,3 +1,11 @@\n+2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* c-parser.c (c_parser_asm_statement): Detect the inline keyword\n+\tafter asm.  Pass a flag for it to build_asm_expr.\n+\t* c-tree.h (build_asm_expr): Update declaration.\n+\t* c-typeck.c (build_asm_stmt): Add is_inline parameter.  Use it to\n+\tset ASM_INLINE_P.\n+\n 2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR inline-asm/55681"}, {"sha": "3a7fcdce33b59c52568a39ebc18c3a9fdb2502f3", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -6329,11 +6329,12 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n }\n \n /* Parse an asm statement, a GNU extension.  This is a full-blown asm\n-   statement with inputs, outputs, clobbers, and volatile and goto tag\n-   allowed.\n+   statement with inputs, outputs, clobbers, and volatile, inline, and goto\n+   tags allowed.\n \n    asm-qualifier:\n      volatile\n+     inline\n      goto\n \n    asm-qualifier-list:\n@@ -6360,7 +6361,7 @@ static tree\n c_parser_asm_statement (c_parser *parser)\n {\n   tree quals, str, outputs, inputs, clobbers, labels, ret;\n-  bool simple, is_volatile, is_goto;\n+  bool simple, is_volatile, is_inline, is_goto;\n   location_t asm_loc = c_parser_peek_token (parser)->location;\n   int section, nsections;\n \n@@ -6369,6 +6370,7 @@ c_parser_asm_statement (c_parser *parser)\n \n   quals = NULL_TREE;\n   is_volatile = false;\n+  is_inline = false;\n   is_goto = false;\n   for (bool done = false; !done; )\n     switch (c_parser_peek_token (parser)->keyword)\n@@ -6383,6 +6385,16 @@ c_parser_asm_statement (c_parser *parser)\n \telse\n \t  done = true;\n \tbreak;\n+      case RID_INLINE:\n+\tif (!is_inline)\n+\t  {\n+\t    is_inline = true;\n+\t    quals = c_parser_peek_token (parser)->value;\n+\t    c_parser_consume_token (parser);\n+\t  }\n+\telse\n+\t  done = true;\n+\tbreak;\n       case RID_GOTO:\n \tif (!is_goto)\n \t  {\n@@ -6471,7 +6483,8 @@ c_parser_asm_statement (c_parser *parser)\n     c_parser_skip_to_end_of_block_or_statement (parser);\n \n   ret = build_asm_stmt (quals, build_asm_expr (asm_loc, str, outputs, inputs,\n-\t\t\t\t\t       clobbers, labels, simple));\n+\t\t\t\t\t       clobbers, labels, simple,\n+\t\t\t\t\t       is_inline));\n \n  error:\n   parser->lex_untranslated_string = false;"}, {"sha": "f08a8fc8bcc4c8f62fe525151b7768f514aa7a83", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -677,7 +677,8 @@ extern tree build_compound_literal (location_t, tree, tree, bool,\n extern void check_compound_literal_type (location_t, struct c_type_name *);\n extern tree c_start_case (location_t, location_t, tree, bool);\n extern void c_finish_case (tree, tree);\n-extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool);\n+extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool,\n+\t\t\t    bool);\n extern tree build_asm_stmt (tree, tree);\n extern int c_types_compatible_p (tree, tree);\n extern tree c_begin_compound_stmt (bool);"}, {"sha": "1a89727308885c98c13f5d7d9a9da45efc20eee3", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -10327,10 +10327,12 @@ build_asm_stmt (tree cv_qualifier, tree args)\n    some INPUTS, and some CLOBBERS.  The latter three may be NULL.\n    SIMPLE indicates whether there was anything at all after the\n    string in the asm expression -- asm(\"blah\") and asm(\"blah\" : )\n-   are subtly different.  We use a ASM_EXPR node to represent this.  */\n+   are subtly different.  We use a ASM_EXPR node to represent this.\n+   LOC is the location of the asm, and IS_INLINE says whether this\n+   is asm inline.  */\n tree\n build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n-\t\ttree clobbers, tree labels, bool simple)\n+\t\ttree clobbers, tree labels, bool simple, bool is_inline)\n {\n   tree tail;\n   tree args;\n@@ -10448,6 +10450,7 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n      as volatile.  */\n   ASM_INPUT_P (args) = simple;\n   ASM_VOLATILE_P (args) = (noutputs == 0);\n+  ASM_INLINE_P (args) = is_inline;\n \n   return args;\n }"}, {"sha": "89f2d8896abe1c858a867c809b01010a709e3f4b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -1,3 +1,12 @@\n+2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* cp-tree.h (finish_asm_stmt): Update declaration.\n+\t* parser.c (cp_parser_asm_definition): Detect the inline keyword\n+\tafter asm.  Pass a flag for it to finish_asm_stmt.\n+\t* pt.c (tsubst_expr): Pass the ASM_INLINE_P flag to finish_asm_stmt.\n+\t* semantics.c (finish_asm_stmt): Add inline_p parameter.  Use it to\n+\tset ASM_INLINE_P.\n+\n 2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR inline-asm/55681"}, {"sha": "636e53aa3919a73cd27b81339a9b5238850e33e3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -6997,7 +6997,7 @@ extern tree begin_compound_stmt\t\t\t(unsigned int);\n \n extern void finish_compound_stmt\t\t(tree);\n extern tree finish_asm_stmt\t\t\t(int, tree, tree, tree, tree,\n-\t\t\t\t\t\t tree);\n+\t\t\t\t\t\t tree, bool);\n extern tree finish_label_stmt\t\t\t(tree);\n extern void finish_label_decl\t\t\t(tree);\n extern cp_expr finish_parenthesized_expr\t(cp_expr);"}, {"sha": "ceae72a7709e7d0fe8308631a0897b0407caa5b7", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -19592,6 +19592,7 @@ cp_parser_using_directive (cp_parser* parser)\n \n   asm-qualifier:\n     volatile\n+    inline\n     goto\n \n   asm-qualifier-list:\n@@ -19632,6 +19633,7 @@ cp_parser_asm_definition (cp_parser* parser)\n   bool extended_p = false;\n   bool invalid_inputs_p = false;\n   bool invalid_outputs_p = false;\n+  bool inline_p = false;\n   bool goto_p = false;\n   required_token missing = RT_NONE;\n \n@@ -19661,6 +19663,17 @@ cp_parser_asm_definition (cp_parser* parser)\n \t  else\n \t    done = true;\n \t  break;\n+\tcase RID_INLINE:\n+\t  if (!inline_p && parser->in_function_body)\n+\t    {\n+\t      /* Remember that we saw the `inline' keyword.  */\n+\t      inline_p = true;\n+\t      /* Consume the token.  */\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t    }\n+\t  else\n+\t    done = true;\n+\t  break;\n \tcase RID_GOTO:\n \t  if (!goto_p && parser->in_function_body)\n \t    {\n@@ -19802,7 +19815,7 @@ cp_parser_asm_definition (cp_parser* parser)\n       if (parser->in_function_body)\n \t{\n \t  asm_stmt = finish_asm_stmt (volatile_p, string, outputs,\n-\t\t\t\t      inputs, clobbers, labels);\n+\t\t\t\t      inputs, clobbers, labels, inline_p);\n \t  /* If the extended syntax was not used, mark the ASM_EXPR.  */\n \t  if (!extended_p)\n \t    {"}, {"sha": "90fb3aee82d4ad94b1109ad4e2ea4c10fde46241", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -17220,7 +17220,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \ttree labels = tsubst_copy_asm_operands (ASM_LABELS (t), args,\n \t\t\t\t\t\tcomplain, in_decl);\n \ttmp = finish_asm_stmt (ASM_VOLATILE_P (t), string, outputs, inputs,\n-\t\t\t       clobbers, labels);\n+\t\t\t       clobbers, labels, ASM_INLINE_P (t));\n \ttree asm_expr = tmp;\n \tif (TREE_CODE (asm_expr) == CLEANUP_POINT_EXPR)\n \t  asm_expr = TREE_OPERAND (asm_expr, 0);"}, {"sha": "c1240cce1e16a2239381a61e84709327e27d316c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -1482,11 +1482,11 @@ finish_compound_stmt (tree stmt)\n /* Finish an asm-statement, whose components are a STRING, some\n    OUTPUT_OPERANDS, some INPUT_OPERANDS, some CLOBBERS and some\n    LABELS.  Also note whether the asm-statement should be\n-   considered volatile.  */\n+   considered volatile, and whether it is asm inline.  */\n \n tree\n finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n-\t\t tree input_operands, tree clobbers, tree labels)\n+\t\t tree input_operands, tree clobbers, tree labels, bool inline_p)\n {\n   tree r;\n   tree t;\n@@ -1640,6 +1640,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t\t  output_operands, input_operands,\n \t\t  clobbers, labels);\n   ASM_VOLATILE_P (r) = volatile_p || noutputs == 0;\n+  ASM_INLINE_P (r) = inline_p;\n   r = maybe_cleanup_point_expr_void (r);\n   return add_stmt (r);\n }"}, {"sha": "7700ab95160fd2f857b8fe92efff93b1ea8d40a5", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -8460,6 +8460,10 @@ various @option{-std} options, use @code{__asm__} instead of\n @item volatile\n The optional @code{volatile} qualifier has no effect. \n All basic @code{asm} blocks are implicitly volatile.\n+\n+@item inline\n+If you use the @code{inline} qualifier, then for inlining purposes the size\n+of the asm is taken as the smallest size possible (@pxref{Size of an asm}).\n @end table\n \n @subsubheading Parameters\n@@ -8603,6 +8607,10 @@ values to produce output values. However, your @code{asm} statements may\n also produce side effects. If so, you may need to use the @code{volatile} \n qualifier to disable certain optimizations. @xref{Volatile}.\n \n+@item inline\n+If you use the @code{inline} qualifier, then for inlining purposes the size\n+of the asm is taken as the smallest size possible (@pxref{Size of an asm}).\n+\n @item goto\n This qualifier informs the compiler that the @code{asm} statement may \n perform a jump to one of the labels listed in the @var{GotoLabels}.\n@@ -10061,7 +10069,7 @@ does this by counting the number of instructions in the pattern of the\n @code{asm} and multiplying that by the length of the longest\n instruction supported by that processor.  (When working out the number\n of instructions, it assumes that any occurrence of a newline or of\n-whatever statement separator character is supported by the assembler --\n+whatever statement separator character is supported by the assembler ---\n typically @samp{;} --- indicates the end of an instruction.)\n \n Normally, GCC's estimate is adequate to ensure that correct\n@@ -10072,6 +10080,11 @@ space in the object file than is needed for a single instruction.\n If this happens then the assembler may produce a diagnostic saying that\n a label is unreachable.\n \n+@cindex @code{asm inline}\n+This size is also used for inlining decisions.  If you use @code{asm inline}\n+instead of just @code{asm}, then for inlining purposes the size of the asm\n+is taken as the minimum size, ignoring how many instructions GCC thinks it is.\n+\n @node Alternate Keywords\n @section Alternate Keywords\n @cindex alternate keywords"}, {"sha": "51c0fb33f2f94ee6e88ac3a0268794e4fad8ae20", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -2048,6 +2048,8 @@ dump_gimple_asm (pretty_printer *buffer, gasm *gs, int spc, dump_flags_t flags)\n       pp_string (buffer, \"__asm__\");\n       if (gimple_asm_volatile_p (gs))\n \tpp_string (buffer, \" __volatile__\");\n+      if (gimple_asm_inline_p (gs))\n+\tpp_string (buffer, \" __inline__\");\n       if (gimple_asm_nlabels (gs))\n \tpp_string (buffer, \" goto\");\n       pp_string (buffer, \"(\\\"\");"}, {"sha": "37fd5fb9ac3822584b069af5032e91d137317ec0", "filename": "gcc/gimple.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -137,6 +137,7 @@ enum gimple_rhs_class\n enum gf_mask {\n     GF_ASM_INPUT\t\t= 1 << 0,\n     GF_ASM_VOLATILE\t\t= 1 << 1,\n+    GF_ASM_INLINE\t\t= 1 << 2,\n     GF_CALL_FROM_THUNK\t\t= 1 << 0,\n     GF_CALL_RETURN_SLOT_OPT\t= 1 << 1,\n     GF_CALL_TAILCALL\t\t= 1 << 2,\n@@ -3911,7 +3912,7 @@ gimple_asm_string (const gasm *asm_stmt)\n }\n \n \n-/* Return true ASM_STMT ASM_STMT is an asm statement marked volatile.  */\n+/* Return true if ASM_STMT is marked volatile.  */\n \n static inline bool\n gimple_asm_volatile_p (const gasm *asm_stmt)\n@@ -3920,7 +3921,7 @@ gimple_asm_volatile_p (const gasm *asm_stmt)\n }\n \n \n-/* If VOLATLE_P is true, mark asm statement ASM_STMT as volatile.  */\n+/* If VOLATILE_P is true, mark asm statement ASM_STMT as volatile.  */\n \n static inline void\n gimple_asm_set_volatile (gasm *asm_stmt, bool volatile_p)\n@@ -3932,6 +3933,27 @@ gimple_asm_set_volatile (gasm *asm_stmt, bool volatile_p)\n }\n \n \n+/* Return true if ASM_STMT is marked inline.  */\n+\n+static inline bool\n+gimple_asm_inline_p (const gasm *asm_stmt)\n+{\n+  return (asm_stmt->subcode & GF_ASM_INLINE) != 0;\n+}\n+\n+\n+/* If INLINE_P is true, mark asm statement ASM_STMT as inline.  */\n+\n+static inline void\n+gimple_asm_set_inline (gasm *asm_stmt, bool inline_p)\n+{\n+  if (inline_p)\n+    asm_stmt->subcode |= GF_ASM_INLINE;\n+  else\n+    asm_stmt->subcode &= ~GF_ASM_INLINE;\n+}\n+\n+\n /* If INPUT_P is true, mark asm ASM_STMT as an ASM_INPUT.  */\n \n static inline void"}, {"sha": "9022ef8b2ee6575fb011012fa76792f9ebbf0c20", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -6361,6 +6361,7 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \n       gimple_asm_set_volatile (stmt, ASM_VOLATILE_P (expr) || noutputs == 0);\n       gimple_asm_set_input (stmt, ASM_INPUT_P (expr));\n+      gimple_asm_set_inline (stmt, ASM_INLINE_P (expr));\n \n       gimplify_seq_add_stmt (pre_p, stmt);\n     }"}, {"sha": "5361139498889a147f5d85e3e50982be06671609", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -993,6 +993,9 @@ func_checker::compare_gimple_asm (const gasm *g1, const gasm *g2)\n   if (gimple_asm_input_p (g1) != gimple_asm_input_p (g2))\n     return false;\n \n+  if (gimple_asm_inline_p (g1) != gimple_asm_inline_p (g2))\n+    return false;\n+\n   if (gimple_asm_ninputs (g1) != gimple_asm_ninputs (g2))\n     return false;\n "}, {"sha": "f95ef6103d2689f9036e61d8304d47a1cc80a19c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -1,3 +1,8 @@\n+2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* c-c++-common/torture/asm-inline.c: New testcase.\n+\t* gcc.dg/asm-qual-2.c: Test asm inline, too.\n+\n 2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR inline-asm/55681"}, {"sha": "dea89658be443651c9232620b3b10ea3ec794a47", "filename": "gcc/testsuite/c-c++-common/torture/asm-inline.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fasm-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fasm-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fasm-inline.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* -O0 does no inlining, and -O3 does it too aggressively for this test:  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-O3\" } { \"\" } }\n+/* The normal asm is not inlined:  */\n+/* { dg-final { scan-assembler-times \"w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w\" 2 } } */\n+/* But the asm inline is inlined:  */\n+/* { dg-final { scan-assembler-times \"x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x\" 8 } } */\n+\n+static void f(void)\n+{\n+  asm (\"w\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\n\"\n+       \"w\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\");\n+}\n+\n+int f0(void) { f(); return 0; }\n+int f1(void) { f(); return 1; }\n+int f2(void) { f(); return 2; }\n+int f3(void) { f(); return 3; }\n+\n+static void fg(void)\n+{\n+  asm goto(\"w\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\n\"\n+\t   \"w\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\\nw\" :::: q);\n+  q: ;\n+}\n+\n+int fg0(void) { fg(); return 0; }\n+int fg1(void) { fg(); return 1; }\n+int fg2(void) { fg(); return 2; }\n+int fg3(void) { fg(); return 3; }\n+\n+static void g(void)\n+{\n+  asm inline(\"x\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\n\"\n+\t     \"x\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\");\n+}\n+\n+int g0(void) { g(); return 0; }\n+int g1(void) { g(); return 1; }\n+int g2(void) { g(); return 2; }\n+int g3(void) { g(); return 3; }\n+\n+static void gg(void)\n+{\n+  asm inline goto(\"x\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\n\"\n+\t\t  \"x\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\\nx\" :::: q);\n+  q: ;\n+}\n+\n+int gg0(void) { gg(); return 0; }\n+int gg1(void) { gg(); return 1; }\n+int gg2(void) { gg(); return 2; }\n+int gg3(void) { gg(); return 3; }"}, {"sha": "79135c3d2f2f2ebf77bd3a8ddc078a714d708ed8", "filename": "gcc/testsuite/gcc.dg/asm-qual-2.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-qual-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-qual-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-qual-2.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -6,7 +6,18 @@ void\n f (void)\n {\n   asm volatile goto (\"\" :::: lab);\n+  asm volatile inline (\"\" :::);\n+  asm inline volatile (\"\" :::);\n+  asm inline goto (\"\" :::: lab);\n   asm goto volatile (\"\" :::: lab);\n+  asm goto inline (\"\" :::: lab);\n+\n+  asm volatile inline goto (\"\" :::: lab);\n+  asm volatile goto inline (\"\" :::: lab);\n+  asm inline volatile goto (\"\" :::: lab);\n+  asm inline goto volatile (\"\" :::: lab);\n+  asm goto volatile inline (\"\" :::: lab);\n+  asm goto inline volatile (\"\" :::: lab);\n \n   /* Duplicates are not allowed.  */\n   asm goto volatile volatile (\"\" :::: lab);  /* { dg-error \"\" } */\n@@ -16,6 +27,20 @@ f (void)\n   asm goto volatile goto (\"\" :::: lab);  /* { dg-error \"\" } */\n   asm volatile goto goto (\"\" :::: lab);  /* { dg-error \"\" } */\n \n+  asm inline volatile volatile (\"\" :::);  /* { dg-error \"\" } */\n+  asm volatile inline volatile (\"\" :::);  /* { dg-error \"\" } */\n+  asm volatile volatile inline (\"\" :::);  /* { dg-error \"\" } */\n+  asm inline inline volatile (\"\" :::);  /* { dg-error \"\" } */\n+  asm inline volatile inline (\"\" :::);  /* { dg-error \"\" } */\n+  asm volatile inline inline (\"\" :::);  /* { dg-error \"\" } */\n+\n+  asm goto inline inline (\"\" :::: lab);  /* { dg-error \"\" } */\n+  asm inline goto inline (\"\" :::: lab);  /* { dg-error \"\" } */\n+  asm inline inline goto (\"\" :::: lab);  /* { dg-error \"\" } */\n+  asm goto goto inline (\"\" :::: lab);  /* { dg-error \"\" } */\n+  asm goto inline goto (\"\" :::: lab);  /* { dg-error \"\" } */\n+  asm inline goto goto (\"\" :::: lab);  /* { dg-error \"\" } */\n+\n lab:\n   ;\n }"}, {"sha": "e7646afe117aef231f43b06032f31b06ee679b32", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -1193,6 +1193,9 @@ struct GTY(()) tree_base {\n        OMP_CLAUSE_LINEAR_VARIABLE_STRIDE in\n \t   OMP_CLAUSE_LINEAR\n \n+       ASM_INLINE_P in\n+\t   ASM_EXPR\n+\n    side_effects_flag:\n \n        TREE_SIDE_EFFECTS in"}, {"sha": "52f0310021e558813694d6a98ad56663cfb9d563", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -4109,6 +4109,9 @@ estimate_num_insns (gimple *stmt, eni_weights *weights)\n \t   with very long asm statements.  */\n \tif (count > 1000)\n \t  count = 1000;\n+\t/* If this asm is asm inline, count anything as minimum size.  */\n+\tif (gimple_asm_inline_p (as_a <gasm *> (stmt)))\n+\t  count = MIN (1, count);\n \treturn MAX (1, count);\n       }\n "}, {"sha": "761b5083d4d8b02ae6ae779714b7dee298f67892", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b76e75f760f3e4787851366359d5d50f989877c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5b76e75f760f3e4787851366359d5d50f989877c", "patch": "@@ -1245,6 +1245,9 @@ extern tree maybe_wrap_with_location (tree, location_t);\n    ASM_OPERAND with no operands.  */\n #define ASM_INPUT_P(NODE) (ASM_EXPR_CHECK (NODE)->base.static_flag)\n #define ASM_VOLATILE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.public_flag)\n+/* Nonzero if we want to consider this asm as minimum length and cost\n+   for inlining decisions.  */\n+#define ASM_INLINE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.protected_flag)\n \n /* COND_EXPR accessors.  */\n #define COND_EXPR_COND(NODE)\t(TREE_OPERAND (COND_EXPR_CHECK (NODE), 0))"}]}