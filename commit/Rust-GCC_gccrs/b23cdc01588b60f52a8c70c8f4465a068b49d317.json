{"sha": "b23cdc01588b60f52a8c70c8f4465a068b49d317", "node_id": "C_kwDOANBUbNoAKGIyM2NkYzAxNTg4YjYwZjUyYThjNzBjOGY0NDY1YTA2OGI0OWQzMTc", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-07-02T15:41:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-21T15:24:57Z"}, "message": "[Ada] Clean up uses of Esize and RM_Size\n\ngcc/ada/\n\n\t* einfo-utils.adb: Add support (currently disabled) for using\n\t\"initial zero\" instead of \"Uint_0\" to represent \"unknown\".  Call\n\tKnown_ functions, instead of evilly duplicating their code\n\tinline.\n\t* fe.h (No_Uint_To_0): New function to convert No_Uint to\n\tUint_0, in order to preserve existing behavior.\n\t(Copy_Esize, Copy_RM_Size): New imports from Einfo.Utils.\n\t* cstand.adb: Set size fields of Standard_Debug_Renaming_Type\n\tand Standard_Exception_Type.\n\t* checks.adb, exp_attr.adb, exp_ch3.adb, exp_ch5.adb,\n\texp_ch6.adb, exp_pakd.adb, exp_util.adb, freeze.adb, itypes.adb,\n\tlayout.adb, repinfo.adb, sem_attr.adb, sem_ch12.adb,\n\tsem_ch13.adb, sem_ch13.ads, sem_ch3.adb, sem_ch7.adb,\n\tsem_util.adb: Protect calls with Known_..., use Copy_...  Remove\n\tassumption that Uint_0 represents \"unknown\".\n\t* types.ads (Nonzero_Int): New subtype.\n\t* gcc-interface/decl.c, gcc-interface/trans.c: Protect calls\n\twith Known_... and use Copy_...  as appropriate, to avoid\n\tblowing up in unknown cases. Similarly, call No_Uint_To_0 to\n\tpreserve existing behavior.", "tree": {"sha": "6e4640413b49f9c2a3ede3201136938fca7f5db7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e4640413b49f9c2a3ede3201136938fca7f5db7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b23cdc01588b60f52a8c70c8f4465a068b49d317", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b23cdc01588b60f52a8c70c8f4465a068b49d317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b23cdc01588b60f52a8c70c8f4465a068b49d317", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b23cdc01588b60f52a8c70c8f4465a068b49d317/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9068967876383bf0d9280b4f455fd50e7faf152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9068967876383bf0d9280b4f455fd50e7faf152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9068967876383bf0d9280b4f455fd50e7faf152"}], "stats": {"total": 378, "additions": 221, "deletions": 157}, "files": [{"sha": "8f5c0b0b56ad5b39b30b2cf5806c56633502d52a", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -6892,6 +6892,7 @@ package body Checks is\n       elsif Is_Known_Valid (Typ) then\n          if Is_Entity_Name (Expr)\n            and then Ekind (Entity (Expr)) = E_Variable\n+           and then Known_Esize (Entity (Expr))\n            and then Esize (Entity (Expr)) > Esize (Typ)\n          then\n             return False;"}, {"sha": "409944c6bead3f852282e5d06aa5174344295881", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -1159,10 +1159,8 @@ package body CStand is\n       Mutate_Ekind (Standard_Debug_Renaming_Type, E_Signed_Integer_Subtype);\n       Set_Scope (Standard_Debug_Renaming_Type, Standard_Standard);\n       Set_Etype (Standard_Debug_Renaming_Type, Base_Type (Standard_Integer));\n-      pragma Assert\n-        (Field_Is_Initial_Zero (Standard_Debug_Renaming_Type, F_Esize));\n-      pragma Assert\n-        (Field_Is_Initial_Zero (Standard_Debug_Renaming_Type, F_RM_Size));\n+      Set_Esize (Standard_Debug_Renaming_Type, Uint_0);\n+      Set_RM_Size (Standard_Debug_Renaming_Type, Uint_0);\n       Set_Size_Known_At_Compile_Time (Standard_Debug_Renaming_Type);\n       Set_Integer_Bounds (Standard_Debug_Renaming_Type,\n         Typ => Base_Type (Standard_Debug_Renaming_Type),\n@@ -1511,7 +1509,7 @@ package body CStand is\n          Set_Scope       (Standard_Exception_Type, Standard_Standard);\n          Set_Stored_Constraint\n                          (Standard_Exception_Type, No_Elist);\n-         Reinit_Size_Align (Standard_Exception_Type);\n+         Set_RM_Size (Standard_Exception_Type, Uint_0);\n          Set_Size_Known_At_Compile_Time\n                          (Standard_Exception_Type, True);\n "}, {"sha": "15bd9e885b27d8b06bdaa45ca46ed16ab3609b1d", "filename": "gcc/ada/einfo-utils.adb", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -362,10 +362,9 @@ package body Einfo.Utils is\n    -- Type Representation Attribute Fields --\n    ------------------------------------------\n \n-   function Known_Alignment                       (E : Entity_Id) return B is\n-      Result : constant B := not Field_Is_Initial_Zero (E, F_Alignment);\n+   function Known_Alignment (E : Entity_Id) return B is\n    begin\n-      return Result;\n+      return not Field_Is_Initial_Zero (E, F_Alignment);\n    end Known_Alignment;\n \n    procedure Reinit_Alignment (Id : E) is\n@@ -382,96 +381,133 @@ package body Einfo.Utils is\n       end if;\n    end Copy_Alignment;\n \n-   function Known_Component_Bit_Offset            (E : Entity_Id) return B is\n+   function Known_Component_Bit_Offset (E : Entity_Id) return B is\n    begin\n       return Present (Component_Bit_Offset (E));\n    end Known_Component_Bit_Offset;\n \n-   function Known_Static_Component_Bit_Offset     (E : Entity_Id) return B is\n+   function Known_Static_Component_Bit_Offset (E : Entity_Id) return B is\n    begin\n       return Present (Component_Bit_Offset (E))\n         and then Component_Bit_Offset (E) >= Uint_0;\n    end Known_Static_Component_Bit_Offset;\n \n-   function Known_Component_Size                  (E : Entity_Id) return B is\n+   function Known_Component_Size (E : Entity_Id) return B is\n    begin\n       return Component_Size (E) /= Uint_0\n         and then Present (Component_Size (E));\n    end Known_Component_Size;\n \n-   function Known_Static_Component_Size           (E : Entity_Id) return B is\n+   function Known_Static_Component_Size (E : Entity_Id) return B is\n    begin\n       return Component_Size (E) > Uint_0;\n    end Known_Static_Component_Size;\n \n-   function Known_Esize                           (E : Entity_Id) return B is\n+   Use_New_Unknown_Rep : constant Boolean := False;\n+   --  If False, we represent \"unknown\" as Uint_0, which is wrong.\n+   --  We intend to make it True (and remove it), and represent\n+   --  \"unknown\" as Field_Is_Initial_Zero. We also need to change\n+   --  the type of Esize and RM_Size from Uint to Valid_Uint.\n+\n+   function Known_Esize (E : Entity_Id) return B is\n    begin\n-      return Esize (E) /= Uint_0\n-        and then Present (Esize (E));\n+      if Use_New_Unknown_Rep then\n+         return not Field_Is_Initial_Zero (E, F_Esize);\n+      else\n+         return Esize (E) /= Uint_0\n+           and then Present (Esize (E));\n+      end if;\n    end Known_Esize;\n \n-   function Known_Static_Esize                    (E : Entity_Id) return B is\n+   function Known_Static_Esize (E : Entity_Id) return B is\n    begin\n-      return Esize (E) > Uint_0\n+      return Known_Esize (E)\n+        and then Esize (E) >= Uint_0\n         and then not Is_Generic_Type (E);\n    end Known_Static_Esize;\n \n    procedure Reinit_Esize (Id : E) is\n    begin\n-      Set_Esize (Id, Uint_0);\n+      if Use_New_Unknown_Rep then\n+         Reinit_Field_To_Zero (Id, F_Esize);\n+      else\n+         Set_Esize (Id, Uint_0);\n+      end if;\n    end Reinit_Esize;\n \n    procedure Copy_Esize (To, From : E) is\n    begin\n-      raise Program_Error with \"Copy_Esize not yet implemented\";\n+      if Known_Esize (From) then\n+         Set_Esize (To, Esize (From));\n+      else\n+         Reinit_Esize (To);\n+      end if;\n    end Copy_Esize;\n \n-   function Known_Normalized_First_Bit            (E : Entity_Id) return B is\n+   function Known_Normalized_First_Bit (E : Entity_Id) return B is\n    begin\n       return Present (Normalized_First_Bit (E));\n    end Known_Normalized_First_Bit;\n \n-   function Known_Static_Normalized_First_Bit     (E : Entity_Id) return B is\n+   function Known_Static_Normalized_First_Bit (E : Entity_Id) return B is\n    begin\n       return Present (Normalized_First_Bit (E))\n         and then Normalized_First_Bit (E) >= Uint_0;\n    end Known_Static_Normalized_First_Bit;\n \n-   function Known_Normalized_Position             (E : Entity_Id) return B is\n+   function Known_Normalized_Position (E : Entity_Id) return B is\n    begin\n       return Present (Normalized_Position (E));\n    end Known_Normalized_Position;\n \n-   function Known_Static_Normalized_Position      (E : Entity_Id) return B is\n+   function Known_Static_Normalized_Position (E : Entity_Id) return B is\n    begin\n       return Present (Normalized_Position (E))\n         and then Normalized_Position (E) >= Uint_0;\n    end Known_Static_Normalized_Position;\n \n-   function Known_RM_Size                         (E : Entity_Id) return B is\n+   function Known_RM_Size (E : Entity_Id) return B is\n    begin\n-      return Present (RM_Size (E))\n-        and then (RM_Size (E) /= Uint_0\n-                    or else Is_Discrete_Type (E)\n-                    or else Is_Fixed_Point_Type (E));\n+      if Use_New_Unknown_Rep then\n+         return not Field_Is_Initial_Zero (E, F_RM_Size);\n+      else\n+         return Present (RM_Size (E))\n+           and then (RM_Size (E) /= Uint_0\n+                       or else Is_Discrete_Type (E)\n+                       or else Is_Fixed_Point_Type (E));\n+      end if;\n    end Known_RM_Size;\n \n-   function Known_Static_RM_Size                  (E : Entity_Id) return B is\n+   function Known_Static_RM_Size (E : Entity_Id) return B is\n    begin\n-      return (RM_Size (E) > Uint_0\n-                or else Is_Discrete_Type (E)\n-                or else Is_Fixed_Point_Type (E))\n-        and then not Is_Generic_Type (E);\n+      if Use_New_Unknown_Rep then\n+         return Known_RM_Size (E)\n+           and then RM_Size (E) >= Uint_0\n+           and then not Is_Generic_Type (E);\n+      else\n+         return (RM_Size (E) > Uint_0\n+                   or else Is_Discrete_Type (E)\n+                   or else Is_Fixed_Point_Type (E))\n+           and then not Is_Generic_Type (E);\n+      end if;\n    end Known_Static_RM_Size;\n \n    procedure Reinit_RM_Size (Id : E) is\n    begin\n-      Set_RM_Size (Id, Uint_0);\n+      if Use_New_Unknown_Rep then\n+         Reinit_Field_To_Zero (Id, F_RM_Size);\n+      else\n+         Set_RM_Size (Id, Uint_0);\n+      end if;\n    end Reinit_RM_Size;\n \n    procedure Copy_RM_Size (To, From : E) is\n    begin\n-      raise Program_Error with \"Copy_RM_Size not yet implemented\";\n+      if Known_RM_Size (From) then\n+         Set_RM_Size (To, RM_Size (From));\n+      else\n+         Reinit_RM_Size (To);\n+      end if;\n    end Copy_RM_Size;\n \n    -------------------------------\n@@ -503,12 +539,10 @@ package body Einfo.Utils is\n    procedure Init_Size (Id : E; V : Int) is\n    begin\n       pragma Assert (Is_Type (Id));\n-      pragma Assert\n-        (not Known_Esize (Id) or else Esize (Id) = V);\n-      pragma Assert\n-        (No (RM_Size (Id))\n-           or else RM_Size (Id) = Uint_0\n-           or else RM_Size (Id) = V);\n+      pragma Assert (not Known_Esize (Id) or else Esize (Id) = V);\n+      if Use_New_Unknown_Rep then\n+         pragma Assert (not Known_RM_Size (Id) or else RM_Size (Id) = V);\n+      end if;\n       Set_Esize (Id, UI_From_Int (V));\n       Set_RM_Size (Id, UI_From_Int (V));\n    end Init_Size;"}, {"sha": "c962c2a851699b2c887e1d16ead2cba9f2902006", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -7354,7 +7354,7 @@ package body Exp_Attr is\n                if Nkind (P) in N_Has_Entity\n                  and then Present (Entity (P))\n                  and then Is_Object (Entity (P))\n-                 and then Esize (Entity (P)) /= Uint_0\n+                 and then Known_Esize (Entity (P))\n                then\n                   if Esize (Entity (P)) <= System_Max_Integer_Size then\n                      Size := Esize (Entity (P));"}, {"sha": "45d5baf51b4321da05a108dbff360343d6e8689c", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -3421,7 +3421,8 @@ package body Exp_Ch3 is\n \n                   Clean_Task_Names (Typ, Proc_Id);\n \n-               --  Simple initialization\n+               --  Simple initialization. If the Esize is not yet set, we pass\n+               --  Uint_0 as expected by Get_Simple_Init_Val.\n \n                elsif Component_Needs_Simple_Initialization (Typ) then\n                   Actions :=\n@@ -3431,7 +3432,9 @@ package body Exp_Ch3 is\n                          Get_Simple_Init_Val\n                            (Typ  => Typ,\n                             N    => N,\n-                            Size => Esize (Id)));\n+                            Size =>\n+                              (if Known_Esize (Id) then Esize (Id)\n+                               else Uint_0)));\n \n                --  Nothing needed for this case\n \n@@ -6507,7 +6510,8 @@ package body Exp_Ch3 is\n                     Get_Simple_Init_Val\n                       (Typ  => Typ,\n                        N    => Obj_Def,\n-                       Size => Esize (Def_Id)));\n+                       Size => (if Known_Esize (Def_Id) then Esize (Def_Id)\n+                                else Uint_0)));\n \n                   Analyze_And_Resolve\n                     (Expression (N), Typ, Suppress => All_Checks);\n@@ -6534,7 +6538,8 @@ package body Exp_Ch3 is\n               Get_Simple_Init_Val\n                 (Typ  => Typ,\n                  N    => Obj_Def,\n-                 Size => Esize (Def_Id)));\n+                 Size =>\n+                   (if Known_Esize (Def_Id) then Esize (Def_Id) else Uint_0)));\n \n             Analyze_And_Resolve (Expression (N), Typ);\n          end if;"}, {"sha": "9827326f919cd51d65705a914674414ad06d19e8", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -1698,8 +1698,8 @@ package body Exp_Ch5 is\n                             (Etype (Left_Base_Index)))\n                  and then RTE_Available (RE_Fast_Copy_Bitfield)\n                then\n-                  pragma Assert (Esize (L_Type) /= 0);\n-                  pragma Assert (Esize (R_Type) /= 0);\n+                  pragma Assert (Known_Esize (L_Type));\n+                  pragma Assert (Known_Esize (R_Type));\n \n                   return Expand_Assign_Array_Bitfield_Fast (N, Larray, Rarray);\n                end if;"}, {"sha": "50551847629f4a312ed5ed931ce6718cf6cde001", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -4520,6 +4520,8 @@ package body Exp_Ch6 is\n                        or else\n                          (Is_Record_Type (Formal_Typ)\n                            and then Is_Record_Type (Parent_Typ)))\n+                    and then Known_Esize (Formal_Typ)\n+                    and then Known_Esize (Parent_Typ)\n                     and then\n                       (Esize (Formal_Typ) /= Esize (Parent_Typ)\n                         or else Has_Pragma_Pack (Formal_Typ) /="}, {"sha": "9b1181385616e95096dcf82f6e3a06a33d039f77", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -493,7 +493,7 @@ package body Exp_Pakd is\n \n       Ancest   : Entity_Id;\n       PB_Type  : Entity_Id;\n-      PASize   : Uint;\n+      PASize   : Uint := No_Uint;\n       Decl     : Node_Id;\n       PAT      : Entity_Id;\n       Len_Expr : Node_Id;\n@@ -563,12 +563,14 @@ package body Exp_Pakd is\n          --  Do not reset RM_Size if already set, as happens in the case of\n          --  a modular type.\n \n-         if not Known_Esize (PAT) then\n-            Set_Esize (PAT, PASize);\n-         end if;\n+         if Present (PASize) then\n+            if not Known_Esize (PAT) then\n+               Set_Esize (PAT, PASize);\n+            end if;\n \n-         if not Known_RM_Size (PAT) then\n-            Set_RM_Size (PAT, PASize);\n+            if not Known_RM_Size (PAT) then\n+               Set_RM_Size (PAT, PASize);\n+            end if;\n          end if;\n \n          Adjust_Esize_Alignment (PAT);\n@@ -680,7 +682,9 @@ package body Exp_Pakd is\n       --  type, since this size clearly belongs to the packed array type. The\n       --  size of the conceptual unpacked type is always set to unknown.\n \n-      PASize := RM_Size (Typ);\n+      if Known_RM_Size (Typ) then\n+         PASize := RM_Size (Typ);\n+      end if;\n \n       --  Case of an array where at least one index is of an enumeration\n       --  type with a non-standard representation, but the component size\n@@ -943,7 +947,7 @@ package body Exp_Pakd is\n                                    Make_Integer_Literal (Loc, 0),\n                                  High_Bound => Lit))));\n \n-               if PASize = Uint_0 then\n+               if Present (PASize) then\n                   PASize := Len_Bits;\n                end if;\n \n@@ -1973,6 +1977,7 @@ package body Exp_Pakd is\n       Rtyp : Entity_Id;\n       PAT  : Entity_Id;\n       Lit  : Node_Id;\n+      Size : Unat;\n \n    begin\n       Convert_To_Actual_Subtype (Opnd);\n@@ -1994,9 +1999,11 @@ package body Exp_Pakd is\n \n       --  where PAT is the packed array type, Mask is a mask of all 1 bits of\n       --  length equal to the size of this packed type, and Rtyp is the actual\n-      --  actual subtype of the operand.\n+      --  actual subtype of the operand. Preserve old behavior in case size is\n+      --  not set.\n \n-      Lit := Make_Integer_Literal (Loc, 2 ** RM_Size (PAT) - 1);\n+      Size := (if Known_RM_Size (PAT) then RM_Size (PAT) else Uint_0);\n+      Lit := Make_Integer_Literal (Loc, 2 ** Size - 1);\n       Set_Print_In_Hex (Lit);\n \n       if not Is_Array_Type (PAT) then"}, {"sha": "b438d0bee629dc3a399468dd6019e3d4c8fa7f90", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -10994,26 +10994,25 @@ package body Exp_Util is\n    --  At the current time, the only types that we return False for (i.e. where\n    --  we decide we know they cannot generate large temps) are ones where we\n    --  know the size is 256 bits or less at compile time, and we are still not\n-   --  doing a thorough job on arrays and records ???\n+   --  doing a thorough job on arrays and records.\n \n    function May_Generate_Large_Temp (Typ : Entity_Id) return Boolean is\n    begin\n       if not Size_Known_At_Compile_Time (Typ) then\n          return False;\n+      end if;\n \n-      elsif Esize (Typ) /= 0 and then Esize (Typ) <= 256 then\n+      if Known_Esize (Typ) and then Esize (Typ) <= 256 then\n          return False;\n+      end if;\n \n-      elsif Is_Array_Type (Typ)\n+      if Is_Array_Type (Typ)\n         and then Present (Packed_Array_Impl_Type (Typ))\n       then\n          return May_Generate_Large_Temp (Packed_Array_Impl_Type (Typ));\n-\n-      --  We could do more here to find other small types ???\n-\n-      else\n-         return True;\n       end if;\n+\n+      return True;\n    end May_Generate_Large_Temp;\n \n    --------------------------------------------"}, {"sha": "488e81128dfbe1b452351dc03ef70f224a95b52a", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -69,6 +69,15 @@ extern Boolean Debug_Flag_NN;\n \n /* einfo: */\n \n+/* Valid_Uint is used to preserve the old behavior of Esize and\n+   friends, where Uint_0 was the default. All calls to this\n+   are questionable. */\n+INLINE Valid_Uint\n+No_Uint_To_0 (Uint X)\n+{\n+  return X == No_Uint ? Uint_0 : X;\n+}\n+\n #define Set_Alignment\t\t\teinfo__entities__set_alignment\n #define Set_Component_Bit_Offset\teinfo__entities__set_component_bit_offset\n #define Set_Component_Size\t\teinfo__entities__set_component_size\n@@ -618,6 +627,12 @@ B Known_RM_Size                         (Entity_Id E);\n #define Copy_Alignment einfo__utils__copy_alignment\n B Copy_Alignment(Entity_Id To, Entity_Id From);\n \n+#define Copy_Esize einfo__utils__copy_esize\n+B Copy_Esize(Entity_Id To, Entity_Id From);\n+\n+#define Copy_RM_Size einfo__utils__copy_rm_size\n+B Copy_RM_Size(Entity_Id To, Entity_Id From);\n+\n #define Is_Discrete_Or_Fixed_Point_Type einfo__utils__is_discrete_or_fixed_point_type\n B Is_Discrete_Or_Fixed_Point_Type     (E Id);\n "}, {"sha": "c3c4f535d025582198b93ee5584cdd6b0b6e1d0a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -3640,8 +3640,8 @@ package body Freeze is\n                 (No (Ancestor_Subtype (Arr))\n                   or else not Has_Size_Clause (Ancestor_Subtype (Arr)))\n             then\n-               Set_Esize     (Arr, Esize     (Packed_Array_Impl_Type (Arr)));\n-               Set_RM_Size   (Arr, RM_Size   (Packed_Array_Impl_Type (Arr)));\n+               Copy_Esize (To => Arr, From => Packed_Array_Impl_Type (Arr));\n+               Copy_RM_Size (To => Arr, From => Packed_Array_Impl_Type (Arr));\n             end if;\n \n             if not Has_Alignment_Clause (Arr) then\n@@ -4173,6 +4173,7 @@ package body Freeze is\n                --  active.\n \n                if Is_Access_Type (F_Type)\n+                 and then Known_Esize (F_Type)\n                  and then Esize (F_Type) > Ttypes.System_Address_Size\n                  and then (not Unnest_Subprogram_Mode\n                             or else not Is_Access_Subprogram_Type (F_Type))\n@@ -4313,6 +4314,7 @@ package body Freeze is\n                --  Check suspicious return of fat C pointer\n \n                if Is_Access_Type (R_Type)\n+                 and then Known_Esize (R_Type)\n                  and then Esize (R_Type) > Ttypes.System_Address_Size\n                  and then not Has_Warnings_Off (E)\n                  and then not Has_Warnings_Off (R_Type)\n@@ -6249,7 +6251,8 @@ package body Freeze is\n             if Is_Array_Type (E) then\n                declare\n                   Ctyp : constant Entity_Id := Component_Type (E);\n-                  Rsiz : constant Uint      := RM_Size (Ctyp);\n+                  Rsiz : constant Uint :=\n+                    (if Known_RM_Size (Ctyp) then RM_Size (Ctyp) else Uint_0);\n                   SZ   : constant Node_Id   := Size_Clause (E);\n                   Btyp : constant Entity_Id := Base_Type (E);\n \n@@ -6695,7 +6698,7 @@ package body Freeze is\n \n                if Is_Type (Full_View (E)) then\n                   Set_Size_Info (E, Full_View (E));\n-                  Set_RM_Size   (E, RM_Size (Full_View (E)));\n+                  Copy_RM_Size (To => E, From => Full_View (E));\n                end if;\n \n                goto Leave;\n@@ -8579,10 +8582,10 @@ package body Freeze is\n       Orig_Hi : Ureal;\n       --  Save original bounds (for shaving tests)\n \n-      Actual_Size : Nat;\n+      Actual_Size : Int;\n       --  Actual size chosen\n \n-      function Fsize (Lov, Hiv : Ureal) return Nat;\n+      function Fsize (Lov, Hiv : Ureal) return Int;\n       --  Returns size of type with given bounds. Also leaves these\n       --  bounds set as the current bounds of the Typ.\n \n@@ -8596,7 +8599,7 @@ package body Freeze is\n       -- Fsize --\n       -----------\n \n-      function Fsize (Lov, Hiv : Ureal) return Nat is\n+      function Fsize (Lov, Hiv : Ureal) return Int is\n       begin\n          Set_Realval (Lo, Lov);\n          Set_Realval (Hi, Hiv);\n@@ -8642,7 +8645,7 @@ package body Freeze is\n          if Present (Atype) then\n             Set_Esize (Typ, Esize (Atype));\n          else\n-            Set_Esize (Typ, Esize (Btyp));\n+            Copy_Esize (To => Typ, From => Btyp);\n          end if;\n       end if;\n \n@@ -8705,8 +8708,8 @@ package body Freeze is\n             Loval_Excl_EP : Ureal;\n             Hival_Excl_EP : Ureal;\n \n-            Size_Incl_EP  : Nat;\n-            Size_Excl_EP  : Nat;\n+            Size_Incl_EP  : Int;\n+            Size_Excl_EP  : Int;\n \n             Model_Num     : Ureal;\n             First_Subt    : Entity_Id;\n@@ -9141,7 +9144,9 @@ package body Freeze is\n          Minsiz : constant Uint := UI_From_Int (Minimum_Size (Typ));\n \n       begin\n-         if RM_Size (Typ) /= Uint_0 then\n+         if Known_RM_Size (Typ)\n+           and then RM_Size (Typ) /= Uint_0\n+         then\n             if RM_Size (Typ) < Minsiz then\n                Error_Msg_Uint_1 := RM_Size (Typ);\n                Error_Msg_Uint_2 := Minsiz;"}, {"sha": "884d1d8fce305ff6092a3681dd14650b2a9d8d66", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -4303,7 +4303,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    gnu_size\n \t      = validate_size (Esize (gnat_entity), gnu_type, gnat_entity,\n \t\t\t       VAR_DECL, false, false, size_s, type_s);\n-\t  else\n+\n+\t  /* ??? The test on Has_Size_Clause must be removed when \"unknown\" is\n+\t     no longer represented as Uint_0 (i.e. Use_New_Unknown_Rep).  */\n+\t  else if (Known_RM_Size (gnat_entity)\n+\t\t   || Has_Size_Clause (gnat_entity))\n \t    gnu_size\n \t      = validate_size (RM_Size (gnat_entity), gnu_type, gnat_entity,\n \t\t\t       TYPE_DECL, false, Has_Size_Clause (gnat_entity),\n@@ -4386,7 +4390,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n       /* Now set the RM size of the type.  We cannot do it before padding\n \t because we need to accept arbitrary RM sizes on integral types.  */\n-      set_rm_size (RM_Size (gnat_entity), gnu_type, gnat_entity);\n+      if (Known_RM_Size (gnat_entity))\n+\tset_rm_size (RM_Size (gnat_entity), gnu_type, gnat_entity);\n \n       /* Back-annotate the alignment of the type if not already set.  */\n       if (!Known_Alignment (gnat_entity))\n@@ -4417,16 +4422,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       /* Likewise for the size, if any.  */\n       if (!Known_Esize (gnat_entity) && TYPE_SIZE (gnu_type))\n \t{\n-\t  tree gnu_size = TYPE_SIZE (gnu_type);\n+\t  tree size = TYPE_SIZE (gnu_type);\n \n \t  /* If the size is self-referential, annotate the maximum value\n \t     after saturating it, if need be, to avoid a No_Uint value.  */\n-\t  if (CONTAINS_PLACEHOLDER_P (gnu_size))\n+\t  if (CONTAINS_PLACEHOLDER_P (size))\n \t    {\n \t      const unsigned int align\n \t\t= UI_To_Int (Alignment (gnat_entity)) * BITS_PER_UNIT;\n-\t      gnu_size\n-\t\t= maybe_saturate_size (max_size (gnu_size, true), align);\n+\t      size = maybe_saturate_size (max_size (size, true), align);\n \t    }\n \n \t  /* If we are just annotating types and the type is tagged, the tag\n@@ -4464,12 +4468,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t  if (TYPE_FIELDS (gnu_type))\n \t\t    offset\n \t\t      = round_up (offset, DECL_ALIGN (TYPE_FIELDS (gnu_type)));\n-\t\t  gnu_size = size_binop (PLUS_EXPR, gnu_size, offset);\n+\t\t  size = size_binop (PLUS_EXPR, size, offset);\n \t\t}\n \n-\t      gnu_size\n-\t\t= maybe_saturate_size (round_up (gnu_size, align), align);\n-\t      Set_Esize (gnat_entity, annotate_value (gnu_size));\n+\t      size = maybe_saturate_size (round_up (size, align), align);\n+\t      Set_Esize (gnat_entity, annotate_value (size));\n \n \t      /* Tagged types are Strict_Alignment so RM_Size = Esize.  */\n \t      if (!Known_RM_Size (gnat_entity))\n@@ -4478,12 +4481,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t  /* Otherwise no adjustment is needed.  */\n \t  else\n-\t    Set_Esize (gnat_entity, annotate_value (gnu_size));\n+\t    Set_Esize (gnat_entity, No_Uint_To_0 (annotate_value (size)));\n \t}\n \n       /* Likewise for the RM size, if any.  */\n       if (!Known_RM_Size (gnat_entity) && TYPE_SIZE (gnu_type))\n-\tSet_RM_Size (gnat_entity, annotate_value (rm_size (gnu_type)));\n+\tSet_RM_Size (gnat_entity,\n+\t\t     No_Uint_To_0 (annotate_value (rm_size (gnu_type))));\n \n       /* If we are at global level, GCC applied variable_size to the size but\n \t this has done nothing.  So, if it's not constant or self-referential,\n@@ -4758,9 +4762,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       if (!Known_Alignment (gnat_entity))\n \tCopy_Alignment (gnat_entity, gnat_annotate_type);\n       if (!Known_Esize (gnat_entity))\n-\tSet_Esize (gnat_entity, Esize (gnat_annotate_type));\n+\tCopy_Esize (gnat_entity, gnat_annotate_type);\n       if (!Known_RM_Size (gnat_entity))\n-\tSet_RM_Size (gnat_entity, RM_Size (gnat_annotate_type));\n+\tCopy_RM_Size (gnat_entity, gnat_annotate_type);\n     }\n \n   /* If we haven't already, associate the ..._DECL node that we just made with\n@@ -8774,7 +8778,7 @@ annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size, bool by_ref)\n \tsize = TYPE_SIZE (gnu_type);\n \n       if (size)\n-\tSet_Esize (gnat_entity, annotate_value (size));\n+\tSet_Esize (gnat_entity, No_Uint_To_0 (annotate_value (size)));\n     }\n \n   if (!Known_Alignment (gnat_entity))\n@@ -8880,8 +8884,9 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n \t      (gnat_field,\n \t       annotate_value (bit_from_pos (offset, bit_offset)));\n \n-\t    Set_Esize (gnat_field,\n-\t\t       annotate_value (DECL_SIZE (TREE_PURPOSE (t))));\n+\t    Set_Esize\n+\t      (gnat_field,\n+\t       No_Uint_To_0 (annotate_value (DECL_SIZE (TREE_PURPOSE (t)))));\n \t  }\n \telse if (is_extension)\n \t  {"}, {"sha": "d3c421d37406dbb51700747e31b0ecf2353302c7", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -9279,10 +9279,10 @@ process_freeze_entity (Node_Id gnat_node)\n \tCopy_Alignment (gnat_entity, full_view);\n \n       if (!Known_Esize (gnat_entity))\n-\tSet_Esize (gnat_entity, Esize (full_view));\n+\tCopy_Esize (gnat_entity, full_view);\n \n       if (!Known_RM_Size (gnat_entity))\n-\tSet_RM_Size (gnat_entity, RM_Size (full_view));\n+\tCopy_RM_Size (gnat_entity, full_view);\n \n       /* The above call may have defined this entity (the simplest example\n \t of this is when we have a private enumeral type since the bounds"}, {"sha": "ffaa4fe47714c5db714f2566b84ed44201ed26c0", "filename": "gcc/ada/itypes.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fitypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fitypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -29,7 +29,6 @@ with Sinfo;          use Sinfo;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Stand;          use Stand;\n with Targparm;       use Targparm;\n-with Uintp;          use Uintp;\n \n package body Itypes is\n \n@@ -64,7 +63,7 @@ package body Itypes is\n       --  Make sure Esize (Typ) was properly initialized, it should be since\n       --  New_Internal_Entity/New_External_Entity call Reinit_Size_Align.\n \n-      pragma Assert (Esize (Typ) = Uint_0);\n+      pragma Assert (not Known_Esize (Typ));\n \n       Set_Etype (Typ, Any_Type);\n       Set_Is_Itype (Typ);"}, {"sha": "092f2f58cfb41aaabcea2bee9097c7b4ae05a078", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -287,7 +287,7 @@ package body Layout is\n \n          elsif Ekind (E) = E_Access_Subtype then\n             Set_Size_Info (E, Base_Type (E));\n-            Set_RM_Size   (E, RM_Size (Base_Type (E)));\n+            Copy_RM_Size (To => E, From => Base_Type (E));\n \n          --  For other access types, we use either address size, or, if a fat\n          --  pointer is used (pointer-to-unconstrained array case), twice the\n@@ -426,15 +426,15 @@ package body Layout is\n \n             begin\n                if not Known_Esize (E) then\n-                  Set_Esize     (E, Esize     (PAT));\n+                  Copy_Esize (To => E, From => PAT);\n                end if;\n \n                if not Known_RM_Size (E) then\n-                  Set_RM_Size   (E, RM_Size   (PAT));\n+                  Copy_RM_Size (To => E, From => PAT);\n                end if;\n \n-               if not Known_Alignment (E) and then Known_Alignment (PAT) then\n-                  Set_Alignment (E, Alignment (PAT));\n+               if not Known_Alignment (E) then\n+                  Copy_Alignment (To => E, From => PAT);\n                end if;\n             end;\n          end if;"}, {"sha": "58e016165875e882c835bddb9242ea624eb953fb", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -1189,13 +1189,7 @@ package body Repinfo is\n             Write_Str (\" .. \");\n          end if;\n \n-         --  Allowing Uint_0 here is an annoying special case. Really this\n-         --  should be a fine Esize value but currently it means unknown,\n-         --  except that we know after gigi has back annotated that a size\n-         --  of zero is real, since otherwise gigi back annotates using\n-         --  No_Uint as the value to indicate unknown.\n-\n-         if (Esize (Ent) = Uint_0 or else Known_Static_Esize (Ent))\n+         if Known_Static_Esize (Ent)\n            and then Known_Static_Normalized_First_Bit (Ent)\n          then\n             Lbit := Sbit + Esiz - 1;\n@@ -1210,14 +1204,7 @@ package body Repinfo is\n                UI_Write (Lbit, Decimal);\n             end if;\n \n-         --  The test for Esize (Ent) not Uint_0 here is an annoying special\n-         --  case. Officially a value of zero for Esize means unknown, but\n-         --  here we use the fact that we know that gigi annotates Esize with\n-         --  No_Uint, not Uint_0. Really everyone should use No_Uint???\n-\n-         elsif List_Representation_Info < 3\n-           or else (Esize (Ent) /= Uint_0 and then not Known_Esize (Ent))\n-         then\n+         elsif List_Representation_Info < 3 or else not Known_Esize (Ent) then\n             Write_Unknown_Val;\n \n          --  List_Representation >= 3 and Known_Esize (Ent)"}, {"sha": "b44bbe35aff121643d71fc39776d002326cd0cb0", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -8124,13 +8124,13 @@ package body Sem_Attr is\n       end if;\n \n       --  If we are asked to evaluate an attribute where the prefix is a\n-      --  non-frozen generic actual type whose RM_Size is still set to zero,\n+      --  non-frozen generic actual type whose RM_Size has not been set,\n       --  then abandon the effort.\n \n       if Is_Type (P_Entity)\n         and then (not Is_Frozen (P_Entity)\n                    and then Is_Generic_Actual_Type (P_Entity)\n-                   and then RM_Size (P_Entity) = 0)\n+                   and then not Known_RM_Size (P_Entity))\n \n         --  However, the attribute Unconstrained_Array must be evaluated,\n         --  since it is documented to be a static attribute (and can for\n@@ -9881,9 +9881,9 @@ package body Sem_Attr is\n             P_TypeA : constant Entity_Id := Underlying_Type (P_Type);\n \n          begin\n-            if Is_Scalar_Type (P_TypeA)\n-              or else RM_Size (P_TypeA) /= Uint_0\n-            then\n+            pragma Assert\n+              (if Is_Scalar_Type (P_TypeA) then Known_RM_Size (P_TypeA));\n+            if Known_RM_Size (P_TypeA) then\n                --  VADS_Size case\n \n                if Id = Attribute_VADS_Size or else Use_VADS_Size then\n@@ -10159,7 +10159,9 @@ package body Sem_Attr is\n          P_TypeA : constant Entity_Id := Underlying_Type (P_Type);\n \n       begin\n-         if Is_Scalar_Type (P_TypeA) or else RM_Size (P_TypeA) /= Uint_0 then\n+         pragma Assert\n+           (if Is_Scalar_Type (P_TypeA) then Known_RM_Size (P_TypeA));\n+         if Known_RM_Size (P_TypeA) then\n             Fold_Uint (N, RM_Size (P_TypeA), Static);\n          end if;\n       end Value_Size;"}, {"sha": "eca2abf3d939eea3816a5ce56debb0a32c5e9626", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -7112,8 +7112,8 @@ package body Sem_Ch12 is\n                Astype := First_Subtype (E);\n             end if;\n \n-            Set_Size_Info      (E,                (Astype));\n-            Set_RM_Size        (E, RM_Size        (Astype));\n+            Set_Size_Info      (E, (Astype));\n+            Copy_RM_Size       (To => E, From => Astype);\n             Set_First_Rep_Item (E, First_Rep_Item (Astype));\n \n             if Is_Discrete_Or_Fixed_Point_Type (E) then"}, {"sha": "43dd5e1d812fc53ca39464d162450eee36b9d201", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -14010,7 +14010,7 @@ package body Sem_Ch13 is\n \n    function Minimum_Size\n      (T      : Entity_Id;\n-      Biased : Boolean := False) return Nat\n+      Biased : Boolean := False) return Int\n    is\n       Lo     : Uint    := No_Uint;\n       Hi     : Uint    := No_Uint;\n@@ -14024,17 +14024,17 @@ package body Sem_Ch13 is\n       R_Typ  : constant Entity_Id := Root_Type (T);\n \n    begin\n-      --  If bad type, return 0\n+      --  Bad type\n \n       if T = Any_Type then\n-         return 0;\n+         return Unknown_Minimum_Size;\n \n-      --  For generic types, just return zero. There cannot be any legitimate\n-      --  need to know such a size, but this routine may be called with a\n-      --  generic type as part of normal processing.\n+      --  For generic types, just return unknown. There cannot be any\n+      --  legitimate need to know such a size, but this routine may be\n+      --  called with a generic type as part of normal processing.\n \n       elsif Is_Generic_Type (R_Typ) or else R_Typ = Any_Type then\n-         return 0;\n+         return Unknown_Minimum_Size;\n \n          --  Access types (cannot have size smaller than System.Address)\n \n@@ -14057,7 +14057,7 @@ package body Sem_Ch13 is\n          Ancest := T;\n          loop\n             if Ancest = Any_Type or else Etype (Ancest) = Any_Type then\n-               return 0;\n+               return Unknown_Minimum_Size;\n             end if;\n \n             if not LoSet then\n@@ -14082,7 +14082,7 @@ package body Sem_Ch13 is\n                Ancest := Base_Type (T);\n \n                if Is_Generic_Type (Ancest) then\n-                  return 0;\n+                  return Unknown_Minimum_Size;\n                end if;\n             end if;\n          end loop;\n@@ -14103,7 +14103,7 @@ package body Sem_Ch13 is\n          Ancest := T;\n          loop\n             if Ancest = Any_Type or else Etype (Ancest) = Any_Type then\n-               return 0;\n+               return Unknown_Minimum_Size;\n             end if;\n \n             --  Note: In the following two tests for LoSet and HiSet, it may\n@@ -14143,7 +14143,7 @@ package body Sem_Ch13 is\n                Ancest := Base_Type (T);\n \n                if Is_Generic_Type (Ancest) then\n-                  return 0;\n+                  return Unknown_Minimum_Size;\n                end if;\n             end if;\n          end loop;\n@@ -14173,7 +14173,7 @@ package body Sem_Ch13 is\n       --  type case, since that's the odd case that came up. Probably we should\n       --  also do this in the fixed-point case, but doing so causes peculiar\n       --  gigi failures, and it is not worth worrying about this incredibly\n-      --  marginal case (explicit null-range fixed-point type declarations)???\n+      --  marginal case (explicit null-range fixed-point type declarations).\n \n       if Lo > Hi and then Is_Discrete_Type (T) then\n          S := 0;\n@@ -16353,7 +16353,8 @@ package body Sem_Ch13 is\n \n                if Present (ACCR.Y) then\n                   Y_Alignment := Alignment (ACCR.Y);\n-                  Y_Size      := Esize (ACCR.Y);\n+                  Y_Size :=\n+                    (if Known_Esize (ACCR.Y) then Esize (ACCR.Y) else Uint_0);\n                end if;\n \n                if ACCR.Off"}, {"sha": "0d3b04155e6947cabc54666461e353c61d8398d1", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -81,9 +81,11 @@ package Sem_Ch13 is\n    --  the setting of the RM_Size field is not affected. This routine also\n    --  initializes the alignment field to zero.\n \n+   Unknown_Minimum_Size : constant Nonzero_Int := -1;\n+\n    function Minimum_Size\n      (T      : Entity_Id;\n-      Biased : Boolean := False) return Nat;\n+      Biased : Boolean := False) return Int;\n    --  Given an elementary type, determines the minimum number of bits required\n    --  to represent all values of the type. This function may not be called\n    --  with any other types. If the flag Biased is set True, then the minimum\n@@ -96,7 +98,7 @@ package Sem_Ch13 is\n    --  the type is already biased, then Minimum_Size returns the biased size,\n    --  regardless of the setting of Biased. Also, fixed-point types are never\n    --  biased in the current implementation. If the size is not known at\n-   --  compile time, this function returns 0.\n+   --  compile time, this function returns Unknown_Minimum_Size.\n \n    procedure Check_Constant_Address_Clause (Expr : Node_Id; U_Ent : Entity_Id);\n    --  Expr is an expression for an address clause. This procedure checks"}, {"sha": "cc8a9b7b29bab69b53ba62b4ce5928c77ee196b7", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -5508,7 +5508,7 @@ package body Sem_Ch3 is\n                Set_Machine_Radix_10     (Id, Machine_Radix_10   (T));\n                Set_Is_Constrained       (Id, Is_Constrained     (T));\n                Set_Is_Known_Valid       (Id, Is_Known_Valid     (T));\n-               Set_RM_Size              (Id, RM_Size            (T));\n+               Copy_RM_Size             (To => Id, From => T);\n \n             when Enumeration_Kind =>\n                Mutate_Ekind             (Id, E_Enumeration_Subtype);\n@@ -5517,7 +5517,7 @@ package body Sem_Ch3 is\n                Set_Is_Character_Type    (Id, Is_Character_Type  (T));\n                Set_Is_Constrained       (Id, Is_Constrained     (T));\n                Set_Is_Known_Valid       (Id, Is_Known_Valid     (T));\n-               Set_RM_Size              (Id, RM_Size            (T));\n+               Copy_RM_Size             (To => Id, From => T);\n \n             when Ordinary_Fixed_Point_Kind =>\n                Mutate_Ekind          (Id, E_Ordinary_Fixed_Point_Subtype);\n@@ -5526,7 +5526,7 @@ package body Sem_Ch3 is\n                Set_Delta_Value          (Id, Delta_Value        (T));\n                Set_Is_Constrained       (Id, Is_Constrained     (T));\n                Set_Is_Known_Valid       (Id, Is_Known_Valid     (T));\n-               Set_RM_Size              (Id, RM_Size            (T));\n+               Copy_RM_Size             (To => Id, From => T);\n \n             when Float_Kind =>\n                Mutate_Ekind             (Id, E_Floating_Point_Subtype);\n@@ -5542,14 +5542,14 @@ package body Sem_Ch3 is\n                Set_Scalar_Range         (Id, Scalar_Range       (T));\n                Set_Is_Constrained       (Id, Is_Constrained     (T));\n                Set_Is_Known_Valid       (Id, Is_Known_Valid     (T));\n-               Set_RM_Size              (Id, RM_Size            (T));\n+               Copy_RM_Size             (To => Id, From => T);\n \n             when Modular_Integer_Kind =>\n                Mutate_Ekind             (Id, E_Modular_Integer_Subtype);\n                Set_Scalar_Range         (Id, Scalar_Range       (T));\n                Set_Is_Constrained       (Id, Is_Constrained     (T));\n                Set_Is_Known_Valid       (Id, Is_Known_Valid     (T));\n-               Set_RM_Size              (Id, RM_Size            (T));\n+               Copy_RM_Size             (To => Id, From => T);\n \n             when Class_Wide_Kind =>\n                Mutate_Ekind             (Id, E_Class_Wide_Subtype);\n@@ -5576,7 +5576,7 @@ package body Sem_Ch3 is\n                --  the type they rename.\n \n                if Present (Generic_Parent_Type (N)) then\n-                  Set_RM_Size           (Id, RM_Size (T));\n+                  Copy_RM_Size (To => Id, From => T);\n                end if;\n \n                if Ekind (T) = E_Record_Subtype\n@@ -6855,8 +6855,8 @@ package body Sem_Ch3 is\n \n       Set_Is_Constrained     (Derived_Type, Is_Constrained (Subt));\n       Set_Is_Access_Constant (Derived_Type, Is_Access_Constant (Parent_Type));\n-      Set_Size_Info          (Derived_Type,                     Parent_Type);\n-      Set_RM_Size            (Derived_Type, RM_Size            (Parent_Type));\n+      Set_Size_Info          (Derived_Type, Parent_Type);\n+      Copy_RM_Size           (To => Derived_Type, From => Parent_Type);\n       Set_Depends_On_Private (Derived_Type,\n                               Has_Private_Component (Derived_Type));\n       Conditional_Delay      (Derived_Type, Subt);\n@@ -9896,8 +9896,8 @@ package body Sem_Ch3 is\n       Mutate_Ekind               (Derived_Type, Ekind (Parent_Base));\n       Propagate_Concurrent_Flags (Derived_Type,        Parent_Base);\n \n-      Set_Size_Info (Derived_Type,          Parent_Type);\n-      Set_RM_Size   (Derived_Type, RM_Size (Parent_Type));\n+      Set_Size_Info (Derived_Type, Parent_Type);\n+      Copy_RM_Size (To => Derived_Type, From => Parent_Type);\n \n       Set_Is_Controlled_Active\n         (Derived_Type, Is_Controlled_Active (Parent_Type));\n@@ -12768,7 +12768,7 @@ package body Sem_Ch3 is\n       Set_Is_First_Subtype (Full, False);\n       Set_Scope            (Full, Scope (Priv));\n       Set_Size_Info        (Full, Full_Base);\n-      Set_RM_Size          (Full, RM_Size (Full_Base));\n+      Copy_RM_Size         (To => Full, From => Full_Base);\n       Set_Is_Itype         (Full);\n \n       --  A subtype of a private-type-without-discriminants, whose full-view\n@@ -14595,7 +14595,7 @@ package body Sem_Ch3 is\n       end if;\n \n       Set_Size_Info      (Def_Id,                (T));\n-      Set_RM_Size        (Def_Id, RM_Size        (T));\n+      Copy_RM_Size       (To => Def_Id, From => T);\n       Set_First_Rep_Item (Def_Id, First_Rep_Item (T));\n \n       --  If this is a range for a fixed-lower-bound subtype, then set the\n@@ -15399,12 +15399,12 @@ package body Sem_Ch3 is\n \n       Set_Fixed_Range (Implicit_Base, Loc, -Bound_Val, Bound_Val);\n \n-      --  Note: We leave size as zero for now, size will be set at freeze\n+      --  Note: We leave Esize unset for now, size will be set at freeze\n       --  time. We have to do this for ordinary fixed-point, because the size\n       --  depends on the specified small, and we might as well do the same for\n       --  decimal fixed-point.\n \n-      pragma Assert (Esize (Implicit_Base) = Uint_0);\n+      pragma Assert (not Known_Esize (Implicit_Base));\n \n       --  If there are bounds given in the declaration use them as the\n       --  bounds of the first named subtype."}, {"sha": "095bcda08cd347d0aec83c65c4fb28609028fc85", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -2733,7 +2733,7 @@ package body Sem_Ch7 is\n \n       begin\n          Set_Size_Info               (Priv,                             Full);\n-         Set_RM_Size                 (Priv, RM_Size                    (Full));\n+         Copy_RM_Size                (To => Priv, From => Full);\n          Set_Size_Known_At_Compile_Time\n                                      (Priv, Size_Known_At_Compile_Time (Full));\n          Set_Is_Volatile             (Priv, Is_Volatile                (Full));"}, {"sha": "5028c2233a327dfdff8c15728a6eff46fa6cfdc7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -28449,7 +28449,7 @@ package body Sem_Util is\n       --  We copy Esize, but not RM_Size, since in general RM_Size is\n       --  subtype specific and does not get inherited by all subtypes.\n \n-      Set_Esize                     (T1, Esize                     (T2));\n+      Copy_Esize (To => T1, From => T2);\n       Set_Has_Biased_Representation (T1, Has_Biased_Representation (T2));\n \n       if Is_Discrete_Or_Fixed_Point_Type (T1)"}, {"sha": "2caaf508e86fd5430ac0ff950f5b29bf98bbed49", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b23cdc01588b60f52a8c70c8f4465a068b49d317/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=b23cdc01588b60f52a8c70c8f4465a068b49d317", "patch": "@@ -59,6 +59,8 @@ package Types is\n    subtype Pos is Int range 1 .. Int'Last;\n    --  Positive Int values\n \n+   subtype Nonzero_Int is Int with Predicate => Nonzero_Int /= 0;\n+\n    type Word is mod 2 ** 32;\n    --  Unsigned 32-bit integer\n "}]}