{"sha": "5a4e208022e7047af3a15a3dedb715ad801db160", "node_id": "C_kwDOANBUbNoAKDVhNGUyMDgwMjJlNzA0N2FmM2ExNWEzZGVkYjcxNWFkODAxZGIxNjA", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-03-11T14:36:18Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-03-16T16:06:29Z"}, "message": "libstdc++: Ensure that std::from_chars is declared when supported\n\nThis adjusts the declarations in <charconv> to match when the definition\nis present. This solves the issue that std::from_chars is present on\nSolaris 11.3 (using fast_float) but was not declared in the header\n(because the declarations were guarded by _GLIBCXX_HAVE_USELOCALE).\n\nAdditionally, do not define __cpp_lib_to_chars unless both from_chars\nand to_chars are supported (which is only true for IEEE float and\ndouble). We might still provide from_chars (via strtold) but if to_chars\nisn't provided, we shouldn't define the feature test macro.\n\nFinally, this simplifies some of the preprocessor checks in the bodies\nof std::from_chars in src/c++17/floating_from_chars.cc and hoists the\nrepeated code for the strtod version into a new function template.\n\nN.B. the long double overload of std::from_chars will always be defined\nif the float and double overloads are defined. We can always use one of\nstrtold or fast_float's binary64 routines (although the latter might\nproduce errors for some long double values if they are not representable\nas binary64).\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/charconv (__cpp_lib_to_chars): Only define when\n\tboth from_chars and to_chars are supported for floating-point\n\ttypes.\n\t(from_chars, to_chars): Adjust preprocessor conditions guarding\n\tdeclarations.\n\t* include/std/version (__cpp_lib_to_chars): Adjust condition to\n\tmatch <charconv> definition.\n\t* src/c++17/floating_from_chars.cc (from_chars_strtod): New\n\tfunction template.\n\t(from_chars): Simplify preprocessor checks and use\n\tfrom_chars_strtod when appropriate.", "tree": {"sha": "b90f70e422a851cc62500bd4073b7adce848f5b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b90f70e422a851cc62500bd4073b7adce848f5b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a4e208022e7047af3a15a3dedb715ad801db160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4e208022e7047af3a15a3dedb715ad801db160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a4e208022e7047af3a15a3dedb715ad801db160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4e208022e7047af3a15a3dedb715ad801db160/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beb12c62eaec37ed0ee5a251ca0907d965d413b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb12c62eaec37ed0ee5a251ca0907d965d413b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb12c62eaec37ed0ee5a251ca0907d965d413b2"}], "stats": {"total": 131, "additions": 45, "deletions": 86}, "files": [{"sha": "2ce9c7d4cb94a4ba61f6337da8a8d4a03b096d00", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4e208022e7047af3a15a3dedb715ad801db160/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4e208022e7047af3a15a3dedb715ad801db160/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=5a4e208022e7047af3a15a3dedb715ad801db160", "patch": "@@ -43,7 +43,8 @@\n #include <bits/error_constants.h> // for std::errc\n #include <ext/numeric_traits.h>\n \n-#if _GLIBCXX_HAVE_USELOCALE\n+#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64 \\\n+    && __SIZE_WIDTH__ >= 32\n # define __cpp_lib_to_chars 201611L\n #endif\n \n@@ -686,7 +687,7 @@ namespace __detail\n   operator^=(chars_format& __lhs, chars_format __rhs) noexcept\n   { return __lhs = __lhs ^ __rhs; }\n \n-#if _GLIBCXX_HAVE_USELOCALE\n+#if defined __cpp_lib_to_chars || _GLIBCXX_HAVE_USELOCALE\n   from_chars_result\n   from_chars(const char* __first, const char* __last, float& __value,\n \t     chars_format __fmt = chars_format::general) noexcept;\n@@ -700,8 +701,7 @@ namespace __detail\n \t     chars_format __fmt = chars_format::general) noexcept;\n #endif\n \n-#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64 \\\n-    && __SIZE_WIDTH__ >= 32\n+#if defined __cpp_lib_to_chars\n   // Floating-point std::to_chars\n \n   // Overloads for float."}, {"sha": "d730a7ea3c7327aa31369edffe64c5d3841ff422", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4e208022e7047af3a15a3dedb715ad801db160/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4e208022e7047af3a15a3dedb715ad801db160/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=5a4e208022e7047af3a15a3dedb715ad801db160", "patch": "@@ -171,7 +171,8 @@\n #endif\n #define __cpp_lib_shared_ptr_weak_type 201606L\n #define __cpp_lib_string_view 201803L\n-#if _GLIBCXX_HAVE_USELOCALE\n+#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64 \\\n+    && __SIZE_WIDTH__ >= 32\n # define __cpp_lib_to_chars 201611L\n #endif\n #define __cpp_lib_unordered_map_try_emplace 201411L"}, {"sha": "4aa2483bc28b71459c1866a7066cb6b4fb1fea89", "filename": "libstdc++-v3/src/c++17/floating_from_chars.cc", "status": "modified", "additions": 39, "deletions": 81, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4e208022e7047af3a15a3dedb715ad801db160/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4e208022e7047af3a15a3dedb715ad801db160/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc?ref=5a4e208022e7047af3a15a3dedb715ad801db160", "patch": "@@ -65,6 +65,7 @@ extern \"C\" __ieee128 __strtoieee128(const char*, char**);\n     && __SIZE_WIDTH__ >= 32\n # define USE_LIB_FAST_FLOAT 1\n # if __LDBL_MANT_DIG__ == __DBL_MANT_DIG__\n+// No need to use strtold.\n #  undef USE_STRTOD_FOR_FROM_CHARS\n # endif\n #endif\n@@ -420,6 +421,33 @@ namespace\n     return true;\n   }\n #endif\n+\n+  template<typename T>\n+  from_chars_result\n+  from_chars_strtod(const char* first, const char* last, T& value,\n+\t\t    chars_format fmt) noexcept\n+  {\n+    errc ec = errc::invalid_argument;\n+#if _GLIBCXX_USE_CXX11_ABI\n+    buffer_resource mr;\n+    pmr::string buf(&mr);\n+#else\n+    string buf;\n+    if (!reserve_string(buf))\n+      return make_result(first, 0, {}, ec);\n+#endif\n+    size_t len = 0;\n+    __try\n+      {\n+\tif (const char* pat = pattern(first, last, fmt, buf)) [[likely]]\n+\t  len = from_chars_impl(pat, value, ec);\n+      }\n+    __catch (const std::bad_alloc&)\n+      {\n+\tfmt = chars_format{};\n+      }\n+    return make_result(first, len, fmt, ec);\n+  }\n #endif // USE_STRTOD_FOR_FROM_CHARS\n \n #if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n@@ -793,113 +821,55 @@ from_chars_result\n from_chars(const char* first, const char* last, float& value,\n \t   chars_format fmt) noexcept\n {\n-#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n+#if USE_LIB_FAST_FLOAT\n   if (fmt == chars_format::hex)\n     return __floating_from_chars_hex(first, last, value);\n   else\n     {\n-      static_assert(USE_LIB_FAST_FLOAT);\n       return fast_float::from_chars(first, last, value, fmt);\n     }\n #else\n-  errc ec = errc::invalid_argument;\n-#if _GLIBCXX_USE_CXX11_ABI\n-  buffer_resource mr;\n-  pmr::string buf(&mr);\n-#else\n-  string buf;\n-  if (!reserve_string(buf))\n-    return make_result(first, 0, {}, ec);\n-#endif\n-  size_t len = 0;\n-  __try\n-    {\n-      if (const char* pat = pattern(first, last, fmt, buf)) [[likely]]\n-\tlen = from_chars_impl(pat, value, ec);\n-    }\n-  __catch (const std::bad_alloc&)\n-    {\n-      fmt = chars_format{};\n-    }\n-  return make_result(first, len, fmt, ec);\n+  return from_chars_strtod(first, last, value, fmt);\n #endif\n }\n \n from_chars_result\n from_chars(const char* first, const char* last, double& value,\n \t   chars_format fmt) noexcept\n {\n-#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n+#if USE_LIB_FAST_FLOAT\n   if (fmt == chars_format::hex)\n     return __floating_from_chars_hex(first, last, value);\n   else\n     {\n-      static_assert(USE_LIB_FAST_FLOAT);\n       return fast_float::from_chars(first, last, value, fmt);\n     }\n #else\n-  errc ec = errc::invalid_argument;\n-#if _GLIBCXX_USE_CXX11_ABI\n-  buffer_resource mr;\n-  pmr::string buf(&mr);\n-#else\n-  string buf;\n-  if (!reserve_string(buf))\n-    return make_result(first, 0, {}, ec);\n-#endif\n-  size_t len = 0;\n-  __try\n-    {\n-      if (const char* pat = pattern(first, last, fmt, buf)) [[likely]]\n-\tlen = from_chars_impl(pat, value, ec);\n-    }\n-  __catch (const std::bad_alloc&)\n-    {\n-      fmt = chars_format{};\n-    }\n-  return make_result(first, len, fmt, ec);\n+  return from_chars_strtod(first, last, value, fmt);\n #endif\n }\n \n from_chars_result\n from_chars(const char* first, const char* last, long double& value,\n \t   chars_format fmt) noexcept\n {\n-#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64 \\\n-  && ! USE_STRTOD_FOR_FROM_CHARS\n+#if ! USE_STRTOD_FOR_FROM_CHARS\n+  // Either long double is the same as double, or we can't use strtold.\n+  // In the latter case, this might give an incorrect result (e.g. values\n+  // out of range of double give an error, even if they fit in long double).\n   double dbl_value;\n   from_chars_result result;\n   if (fmt == chars_format::hex)\n     result = __floating_from_chars_hex(first, last, dbl_value);\n   else\n     {\n-      static_assert(USE_LIB_FAST_FLOAT);\n       result = fast_float::from_chars(first, last, dbl_value, fmt);\n     }\n   if (result.ec == errc{})\n     value = dbl_value;\n   return result;\n #else\n-  errc ec = errc::invalid_argument;\n-#if _GLIBCXX_USE_CXX11_ABI\n-  buffer_resource mr;\n-  pmr::string buf(&mr);\n-#else\n-  string buf;\n-  if (!reserve_string(buf))\n-    return make_result(first, 0, {}, ec);\n-#endif\n-  size_t len = 0;\n-  __try\n-    {\n-      if (const char* pat = pattern(first, last, fmt, buf)) [[likely]]\n-\tlen = from_chars_impl(pat, value, ec);\n-    }\n-  __catch (const std::bad_alloc&)\n-    {\n-      fmt = chars_format{};\n-    }\n-  return make_result(first, len, fmt, ec);\n+  return from_chars_strtod(first, last, value, fmt);\n #endif\n }\n \n@@ -918,20 +888,8 @@ from_chars_result\n from_chars(const char* first, const char* last, __ieee128& value,\n \t   chars_format fmt) noexcept\n {\n-  buffer_resource mr;\n-  pmr::string buf(&mr);\n-  size_t len = 0;\n-  errc ec = errc::invalid_argument;\n-  __try\n-    {\n-      if (const char* pat = pattern(first, last, fmt, buf)) [[likely]]\n-\tlen = from_chars_impl(pat, value, ec);\n-    }\n-  __catch (const std::bad_alloc&)\n-    {\n-      fmt = chars_format{};\n-    }\n-  return make_result(first, len, fmt, ec);\n+  // fast_float doesn't support IEEE binary128 format, but we can use strtold.\n+  return from_chars_strtod(first, last, value, fmt);\n }\n #endif\n "}]}