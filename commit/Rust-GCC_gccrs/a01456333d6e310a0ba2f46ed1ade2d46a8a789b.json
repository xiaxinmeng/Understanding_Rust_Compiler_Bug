{"sha": "a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxNDU2MzMzZDZlMzEwYTBiYTJmNDZlZDFhZGUyZDQ2YThhNzg5Yg==", "commit": {"author": {"name": "Mircea Namolaru", "email": "namolaru@il.ibm.com", "date": "2006-05-15T10:36:39Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2006-05-15T10:36:39Z"}, "message": "see.c: Code style changes such as redundant paranthesis...\n\n2006-05-15  Mircea Namolaru  <namolaru@il.ibm.com>\n\n        * see.c: Code style changes such as redundant paranthesis,\n        redundant intialization of local variables etc.\n        (see_main): Declared now as static.\n        * doc/invoke.texi: Update that -fsee is not enabled by\n        default at -O3.\n\nFrom-SVN: r113792", "tree": {"sha": "f622d5f9a16ca0ad6bb6de24cf997503331a3488", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f622d5f9a16ca0ad6bb6de24cf997503331a3488"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01456333d6e310a0ba2f46ed1ade2d46a8a789b/comments", "author": null, "committer": null, "parents": [{"sha": "a6fc8e21b21142c6f8215420a0c7ffef533881a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6fc8e21b21142c6f8215420a0c7ffef533881a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6fc8e21b21142c6f8215420a0c7ffef533881a5"}], "stats": {"total": 452, "additions": 226, "deletions": 226}, "files": [{"sha": "89ab05e32c48ed66b188e6b1b6c45ebf9ea44dd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01456333d6e310a0ba2f46ed1ade2d46a8a789b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01456333d6e310a0ba2f46ed1ade2d46a8a789b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "patch": "@@ -1,3 +1,11 @@\n+2006-05-15  Mircea Namolaru  <namolaru@il.ibm.com>\n+\n+        * see.c: Code style changes such as redundant paranthesis,\n+        redundant intialization of local variables etc.\n+        (see_main): Declared now as static.\n+        * doc/invoke.texi: Update that -fsee is not enabled by\n+        default at -O3.\n+\n 2006-05-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* omp-low.c (check_omp_nesting_restrictions): New function."}, {"sha": "df6074c3a09635157ddcf6204eb1b379579b1e10", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01456333d6e310a0ba2f46ed1ade2d46a8a789b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01456333d6e310a0ba2f46ed1ade2d46a8a789b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "patch": "@@ -5012,7 +5012,6 @@ sense when scheduling after register allocation, i.e.@: with\n @opindex fsee\n Eliminates redundant extension instructions and move the non redundant\n ones to optimal placement using LCM.\n-Enabled at level @option{-O3}.\n \n @item -freschedule-modulo-scheduled-loops\n @opindex fscheduling-in-modulo-scheduled-loops"}, {"sha": "f56c27b8b92dd0e0a928213de715c360c509015d", "filename": "gcc/see.c", "status": "modified", "additions": 218, "deletions": 225, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01456333d6e310a0ba2f46ed1ade2d46a8a789b/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01456333d6e310a0ba2f46ed1ade2d46a8a789b/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "patch": "@@ -480,9 +480,6 @@ The implementation consists of four data structures:\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n \n-void\n-see_main (void);\n-\n /* Used to classify defs and uses according to relevancy.  */\n enum entry_type {\n   NOT_RELEVANT,\n@@ -659,7 +656,7 @@ static unsigned int uses_num;\n /* Records the number of definitions at the beginning of the optimization.  */\n static unsigned int defs_num;\n \n-#define ENTRY_EI(ENTRY) ((struct see_entry_extra_info *)(ENTRY)->extra_info)\n+#define ENTRY_EI(ENTRY) ((struct see_entry_extra_info *) (ENTRY)->extra_info)\n \f\n /* Functions implementation.  */\n \n@@ -673,9 +670,7 @@ static unsigned int defs_num;\n static rtx\n see_get_extension_reg (rtx extension, bool return_dest_reg)\n {\n-  rtx set = NULL;\n-  rtx rhs = NULL;\n-  rtx lhs = NULL;\n+  rtx set, rhs, lhs;\n   rtx reg1 = NULL;\n   rtx reg2 = NULL;\n \n@@ -692,7 +687,7 @@ see_get_extension_reg (rtx extension, bool return_dest_reg)\n   else\n     return NULL;\n \n-  if ((GET_CODE (rhs) != SIGN_EXTEND) && (GET_CODE (rhs) != ZERO_EXTEND))\n+  if (GET_CODE (rhs) != SIGN_EXTEND && GET_CODE (rhs) != ZERO_EXTEND)\n     return NULL;\n \n   rhs = XEXP (rhs, 0);\n@@ -719,9 +714,7 @@ see_get_extension_reg (rtx extension, bool return_dest_reg)\n static enum rtx_code\n see_get_extension_data (rtx extension, enum machine_mode *source_mode)\n {\n-  rtx rhs = NULL;\n-  rtx lhs = NULL;\n-  rtx set = NULL;\n+  rtx rhs, lhs, set;\n \n   if (!extension || !INSN_P (extension))\n     return UNKNOWN;\n@@ -737,20 +730,19 @@ see_get_extension_data (rtx extension, enum machine_mode *source_mode)\n   if (!REG_P (lhs) && !SUBREG_REG (lhs))\n     return UNKNOWN;\n \n-  if ((GET_CODE (rhs) != SIGN_EXTEND) && (GET_CODE (rhs) != ZERO_EXTEND))\n+  if (GET_CODE (rhs) != SIGN_EXTEND && GET_CODE (rhs) != ZERO_EXTEND)\n     return UNKNOWN;\n \n   if (!REG_P (XEXP (rhs, 0))\n-      && !((GET_CODE (XEXP (rhs, 0)) == SUBREG)\n-\t   && (REG_P (SUBREG_REG (XEXP (rhs, 0))))))\n+      && !(GET_CODE (XEXP (rhs, 0)) == SUBREG\n+\t   && REG_P (SUBREG_REG (XEXP (rhs, 0)))))\n     return UNKNOWN;\n \n   *source_mode = GET_MODE (XEXP (rhs, 0));\n \n   if (GET_CODE (rhs) == SIGN_EXTEND)\n     return SIGN_EXTEND;\n-  else\n-    return ZERO_EXTEND;\n+  return ZERO_EXTEND;\n }\n \n \n@@ -766,13 +758,12 @@ static rtx\n see_gen_normalized_extension (rtx reg, enum rtx_code extension_code,\n    \t\t\t      enum machine_mode mode)\n {\n-  rtx subreg = NULL;\n+  rtx subreg, insn;\n   rtx extension = NULL;\n-  rtx insn = NULL;\n \n   if (!reg\n       || !REG_P (reg)\n-      || ((extension_code != SIGN_EXTEND) && (extension_code != ZERO_EXTEND)))\n+      || (extension_code != SIGN_EXTEND && extension_code != ZERO_EXTEND))\n     return NULL;\n \n   subreg = gen_lowpart_SUBREG (mode, reg);\n@@ -815,8 +806,7 @@ eq_descriptor_pre_extension (const void *p1, const void *p2)\n   const struct see_pre_extension_expr *extension2 = p2;\n   rtx set1 = single_set (extension1->se_insn);\n   rtx set2 = single_set (extension2->se_insn);\n-  rtx rhs1 = NULL;\n-  rtx rhs2 = NULL;\n+  rtx rhs1, rhs2;\n \n   gcc_assert (set1 && set2);\n   rhs1 = SET_SRC (set1);\n@@ -835,7 +825,7 @@ hash_descriptor_pre_extension (const void *p)\n {\n   const struct see_pre_extension_expr *extension = p;\n   rtx set = single_set (extension->se_insn);\n-  rtx rhs = NULL;\n+  rtx rhs;\n \n   gcc_assert (set);\n   rhs = SET_SRC (set);\n@@ -892,7 +882,7 @@ eq_descriptor_properties (const void *p1, const void *p2)\n   const struct see_register_properties *curr_prop1 = p1;\n   const struct see_register_properties *curr_prop2 = p2;\n \n-  return (curr_prop1->regno == curr_prop2->regno);\n+  return curr_prop1->regno == curr_prop2->regno;\n }\n \n \n@@ -940,8 +930,8 @@ eq_descriptor_extension (const void *p1, const void *p2)\n   const rtx insn = (rtx) p1;\n   const rtx element = (rtx) p2;\n   rtx set1 = single_set (insn);\n+  rtx dest_reg1;\n   rtx set2 = NULL;\n-  rtx dest_reg1 = NULL;\n   rtx dest_reg2 = NULL;\n \n   gcc_assert (set1 && element && (REG_P (element) || INSN_P (element)));\n@@ -956,7 +946,7 @@ eq_descriptor_extension (const void *p1, const void *p2)\n   else\n     dest_reg2 = element;\n \n-  return (REGNO (dest_reg1) == REGNO (dest_reg2));\n+  return REGNO (dest_reg1) == REGNO (dest_reg2);\n }\n \n \n@@ -967,19 +957,16 @@ static hashval_t\n hash_descriptor_extension (const void *p)\n {\n   const rtx r = (rtx) p;\n-  rtx set = NULL;\n-  rtx lhs = NULL;\n+  rtx set, lhs;\n \n   if (r && REG_P (r))\n     return REGNO (r);\n-  else\n-    {\n-      gcc_assert (r && INSN_P (r));\n-      set = single_set (r);\n-      gcc_assert (set);\n-      lhs = SET_DEST (set);\n-      return REGNO (lhs);\n-    }\n+\n+  gcc_assert (r && INSN_P (r));\n+  set = single_set (r);\n+  gcc_assert (set);\n+  lhs = SET_DEST (set);\n+  return REGNO (lhs);\n }\n \n \n@@ -1017,8 +1004,7 @@ see_free_ref_s (splay_tree_value value)\n static struct see_pre_extension_expr *\n see_seek_pre_extension_expr (rtx extension, enum extension_type type)\n {\n-  struct see_pre_extension_expr **slot_pre_exp = NULL;\n-  struct see_pre_extension_expr temp_pre_exp;\n+  struct see_pre_extension_expr **slot_pre_exp, temp_pre_exp;\n   rtx dest_extension_reg = see_get_extension_reg (extension, 1);\n   enum rtx_code extension_code;\n   enum machine_mode source_extension_mode;\n@@ -1065,17 +1051,16 @@ see_seek_pre_extension_expr (rtx extension, enum extension_type type)\n static bool\n see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n {\n-  struct see_entry_extra_info *first_ei = NULL;\n-  struct see_entry_extra_info *second_ei = NULL;\n+  struct see_entry_extra_info *first_ei, *second_ei;\n \n   first = unionfind_root (first);\n   second = unionfind_root (second);\n \n   if (unionfind_union (first, second))\n     return true;\n \n-  first_ei = (struct see_entry_extra_info *)first->extra_info;\n-  second_ei = (struct see_entry_extra_info *)second->extra_info;\n+  first_ei = (struct see_entry_extra_info *) first->extra_info;\n+  second_ei = (struct see_entry_extra_info *) second->extra_info;\n \n   gcc_assert (first_ei && second_ei);\n \n@@ -1087,25 +1072,26 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n   switch (first_ei->relevancy)\n     {\n     case NOT_RELEVANT:\n-      return false;\n+      break;\n     case RELEVANT_USE:\n       switch (second_ei->relevancy)\n \t{\n \tcase RELEVANT_USE:\n-\t  return false;\n+\t  break;\n \tcase EXTENDED_DEF:\n \t  first_ei->relevancy = second_ei->relevancy;\n \t  first_ei->source_mode_signed = second_ei->source_mode_signed;\n \t  first_ei->source_mode_unsigned = second_ei->source_mode_unsigned;\n-\t  return false;\n+\t  break;\n \tcase SIGN_EXTENDED_DEF:\n \tcase ZERO_EXTENDED_DEF:\n \t  first_ei->relevancy = second_ei->relevancy;\n \t  first_ei->source_mode = second_ei->source_mode;\n-\t  return false;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      break;\n     case SIGN_EXTENDED_DEF:\n       switch (second_ei->relevancy)\n \t{\n@@ -1114,13 +1100,13 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t  first_ei->source_mode =\n \t    (first_ei->source_mode > second_ei->source_mode) ?\n \t    first_ei->source_mode : second_ei->source_mode;\n-\t  return false;\n+\t  break;\n \tcase RELEVANT_USE:\n-\t  return false;\n+\t  break;\n \tcase ZERO_EXTENDED_DEF:\n \t  /* Don't mix webs with zero extend and sign extend.  */\n \t  first_ei->relevancy = NOT_RELEVANT;\n-\t  return false;\n+\t  break;\n \tcase EXTENDED_DEF:\n \t  if (second_ei->source_mode_signed == MAX_MACHINE_MODE)\n \t    first_ei->relevancy = NOT_RELEVANT;\n@@ -1129,26 +1115,27 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t    first_ei->source_mode =\n \t      (first_ei->source_mode > second_ei->source_mode_signed) ?\n \t      first_ei->source_mode : second_ei->source_mode_signed;\n-\t  return false;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      break;\n     /* This case is similar to the previous one, with little changes.  */\n     case ZERO_EXTENDED_DEF:\n       switch (second_ei->relevancy)\n \t{\n \tcase SIGN_EXTENDED_DEF:\n \t  /* Don't mix webs with zero extend and sign extend.  */\n \t  first_ei->relevancy = NOT_RELEVANT;\n-\t  return false;\n+\t  break;\n \tcase RELEVANT_USE:\n-\t  return false;\n+\t  break;\n \tcase ZERO_EXTENDED_DEF:\n \t  /* The mode of the root should be the wider one in this case.  */\n \t  first_ei->source_mode =\n \t    (first_ei->source_mode > second_ei->source_mode) ?\n \t    first_ei->source_mode : second_ei->source_mode;\n-\t  return false;\n+\t  break;\n \tcase EXTENDED_DEF:\n \t  if (second_ei->source_mode_unsigned == MAX_MACHINE_MODE)\n \t    first_ei->relevancy = NOT_RELEVANT;\n@@ -1157,13 +1144,14 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t    first_ei->source_mode =\n \t      (first_ei->source_mode > second_ei->source_mode_unsigned) ?\n \t      first_ei->source_mode : second_ei->source_mode_unsigned;\n-\t  return false;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      break;\n     case EXTENDED_DEF:\n-      if ((first_ei->source_mode_signed != MAX_MACHINE_MODE)\n-\t  && (first_ei->source_mode_unsigned != MAX_MACHINE_MODE))\n+      if (first_ei->source_mode_signed != MAX_MACHINE_MODE\n+\t  && first_ei->source_mode_unsigned != MAX_MACHINE_MODE)\n \t{\n \t  switch (second_ei->relevancy)\n \t    {\n@@ -1172,15 +1160,15 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t      first_ei->source_mode =\n \t\t(first_ei->source_mode_signed > second_ei->source_mode) ?\n \t\tfirst_ei->source_mode_signed : second_ei->source_mode;\n-\t      return false;\n+\t      break;\n \t    case RELEVANT_USE:\n-\t      return false;\n+\t      break;\n \t    case ZERO_EXTENDED_DEF:\n \t      first_ei->relevancy = ZERO_EXTENDED_DEF;\n \t      first_ei->source_mode =\n \t\t(first_ei->source_mode_unsigned > second_ei->source_mode) ?\n \t\tfirst_ei->source_mode_unsigned : second_ei->source_mode;\n-\t      return false;\n+\t      break;\n \t    case EXTENDED_DEF:\n \t      if (second_ei->source_mode_unsigned != MAX_MACHINE_MODE)\n \t\tfirst_ei->source_mode_unsigned =\n@@ -1193,7 +1181,7 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t\t  (first_ei->source_mode_signed >\n \t\t  second_ei->source_mode_signed) ?\n \t\t  first_ei->source_mode_signed : second_ei->source_mode_signed;\n- \t      return false;\n+\t      break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -1205,15 +1193,15 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t    {\n \t    case SIGN_EXTENDED_DEF:\n \t      first_ei->relevancy = NOT_RELEVANT;\n-\t      return false;\n+\t      break;\n \t    case RELEVANT_USE:\n-\t      return false;\n+\t      break;\n \t    case ZERO_EXTENDED_DEF:\n \t      first_ei->relevancy = ZERO_EXTENDED_DEF;\n \t      first_ei->source_mode =\n \t\t(first_ei->source_mode_unsigned > second_ei->source_mode) ?\n \t\tfirst_ei->source_mode_unsigned : second_ei->source_mode;\n-\t      return false;\n+\t      break;\n \t    case EXTENDED_DEF:\n \t      if (second_ei->source_mode_unsigned == MAX_MACHINE_MODE)\n \t\tfirst_ei->relevancy = NOT_RELEVANT;\n@@ -1223,7 +1211,7 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t\t  second_ei->source_mode_unsigned) ?\n \t\t  first_ei->source_mode_unsigned :\n \t\t  second_ei->source_mode_unsigned;\n- \t      return false;\n+\t      break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -1239,12 +1227,12 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t      first_ei->source_mode =\n \t\t(first_ei->source_mode_signed > second_ei->source_mode) ?\n \t\tfirst_ei->source_mode_signed : second_ei->source_mode;\n-\t      return false;\n+\t      break;\n \t    case RELEVANT_USE:\n-\t      return false;\n+\t      break;\n \t    case ZERO_EXTENDED_DEF:\n \t      first_ei->relevancy = NOT_RELEVANT;\n-\t      return false;\n+\t      break;\n \t    case EXTENDED_DEF:\n \t      if (second_ei->source_mode_signed == MAX_MACHINE_MODE)\n \t\tfirst_ei->relevancy = NOT_RELEVANT;\n@@ -1253,15 +1241,18 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t\t  (first_ei->source_mode_signed >\n \t\t  second_ei->source_mode_signed) ?\n \t\t  first_ei->source_mode_signed : second_ei->source_mode_signed;\n- \t      return false;\n+\t      break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n \t}\n+      break;\n     default:\n       /* Unknown patern type.  */\n       gcc_unreachable ();\n     }\n+\n+  return false;\n }\n \n \n@@ -1362,9 +1353,10 @@ see_initialize_data_structures (void)\n \n   /*  Allocate the extension hash.  It will hold the extensions that we want\n       to PRE.  */\n-  see_pre_extension_hash =\n-    htab_create (10, hash_descriptor_pre_extension, eq_descriptor_pre_extension,\n-\t\t hash_del_pre_extension);\n+  see_pre_extension_hash = htab_create (10, \n+\t\t\t\t\thash_descriptor_pre_extension, \n+\t\t\t\t\teq_descriptor_pre_extension,\n+\t\t\t\t\thash_del_pre_extension);\n }\n \n \n@@ -1402,7 +1394,7 @@ static bool\n see_want_to_be_merged_with_extension (rtx ref, rtx extension,\n    \t\t\t\t      enum extension_type type)\n {\n-  rtx pat = NULL;\n+  rtx pat;\n   rtx dest_extension_reg = see_get_extension_reg (extension, 1);\n   rtx source_extension_reg = see_get_extension_reg (extension, 0);\n   enum rtx_code code;\n@@ -1418,16 +1410,16 @@ see_want_to_be_merged_with_extension (rtx ref, rtx extension,\n \t{\n \t  rtx sub = XVECEXP (pat, 0, i);\n \n-\t  if ((GET_CODE (sub) == SET)\n-\t\t&& (REG_P (SET_DEST (sub))\n-\t\t    || ((GET_CODE (SET_DEST (sub)) == SUBREG)\n-\t\t\t&& (REG_P (SUBREG_REG (SET_DEST (sub))))))\n-\t\t&& (REG_P (SET_SRC (sub))\n-\t\t    || ((GET_CODE (SET_SRC (sub)) == SUBREG)\n-\t\t\t&& (REG_P (SUBREG_REG (SET_SRC (sub)))))))\n+\t  if (GET_CODE (sub) == SET\n+\t      && (REG_P (SET_DEST (sub))\n+\t\t  || (GET_CODE (SET_DEST (sub)) == SUBREG\n+\t\t      && REG_P (SUBREG_REG (SET_DEST (sub)))))\n+\t      && (REG_P (SET_SRC (sub))\n+\t\t  || (GET_CODE (SET_SRC (sub)) == SUBREG\n+\t\t      && REG_P (SUBREG_REG (SET_SRC (sub))))))\n \t    {\n \t      /* This is a simple move SET.  */\n-\t      if ((type == DEF_EXTENSION)\n+\t      if (type == DEF_EXTENSION\n \t\t  && reg_mentioned_p (source_extension_reg, SET_DEST (sub)))\n \t\treturn false;\n \t    }\n@@ -1450,13 +1442,13 @@ see_want_to_be_merged_with_extension (rtx ref, rtx extension,\n     }\n   else\n     {\n-      if ((code == SET)\n+      if (code == SET\n \t  && (REG_P (SET_DEST (pat))\n-\t      || ((GET_CODE (SET_DEST (pat)) == SUBREG)\n-\t\t  && (REG_P (SUBREG_REG (SET_DEST (pat))))))\n+\t      || (GET_CODE (SET_DEST (pat)) == SUBREG\n+\t\t  && REG_P (SUBREG_REG (SET_DEST (pat)))))\n \t  && (REG_P (SET_SRC (pat))\n-\t      || ((GET_CODE (SET_SRC (pat)) == SUBREG)\n-\t\t  && (REG_P (SUBREG_REG (SET_SRC (pat)))))))\n+\t      || (GET_CODE (SET_SRC (pat)) == SUBREG\n+\t\t  && REG_P (SUBREG_REG (SET_SRC (pat))))))\n \t/* This is a simple move SET.  */\n \treturn false;\n      }\n@@ -1846,12 +1838,11 @@ see_analyze_merged_def_local_prop (void **slot, void *b)\n   rtx def_se = *slot;\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx ref = curr_ref_s->insn;\n-  struct see_pre_extension_expr *extension_expr = NULL;\n+  struct see_pre_extension_expr *extension_expr;\n   int indx;\n   int bb_num = BLOCK_NUM (ref);\n-  htab_t curr_bb_hash = NULL;\n-  struct see_register_properties *curr_prop = NULL;\n-  struct see_register_properties **slot_prop = NULL;\n+  htab_t curr_bb_hash;\n+  struct see_register_properties *curr_prop, **slot_prop;\n   struct see_register_properties temp_prop;\n   rtx dest_extension_reg = see_get_extension_reg (def_se, 1);\n   struct see_occr *curr_occr = NULL;\n@@ -1915,12 +1906,11 @@ see_analyze_unmerged_def_local_prop (void **slot, void *b)\n   rtx def_se = *slot;\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx ref = curr_ref_s->insn;\n-  struct see_pre_extension_expr *extension_expr = NULL;\n+  struct see_pre_extension_expr *extension_expr;\n   int indx;\n   int bb_num = BLOCK_NUM (ref);\n-  htab_t curr_bb_hash = NULL;\n-  struct see_register_properties *curr_prop = NULL;\n-  struct see_register_properties **slot_prop = NULL;\n+  htab_t curr_bb_hash;\n+  struct see_register_properties *curr_prop, **slot_prop;\n   struct see_register_properties temp_prop;\n   rtx dest_extension_reg = see_get_extension_reg (def_se, 1);\n \n@@ -1964,13 +1954,12 @@ see_analyze_use_local_prop (void **slot, void *b)\n   rtx use_se = *slot;\n   rtx ref = curr_ref_s->insn;\n   rtx dest_extension_reg = see_get_extension_reg (use_se, 1);\n-  struct see_pre_extension_expr *extension_expr = NULL;\n-  struct see_register_properties *curr_prop = NULL;\n-  struct see_register_properties **slot_prop = NULL;\n+  struct see_pre_extension_expr *extension_expr;\n+  struct see_register_properties *curr_prop, **slot_prop;\n   struct see_register_properties temp_prop;\n   struct see_occr *curr_occr = NULL;\n   struct see_occr *tmp_occr = NULL;\n-  htab_t curr_bb_hash = NULL;\n+  htab_t curr_bb_hash;\n   int indx;\n   int bb_num = BLOCK_NUM (ref);\n \n@@ -2163,19 +2152,20 @@ see_set_prop_merged_def (void **slot, void *b)\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx insn = curr_ref_s->insn;\n   rtx dest_extension_reg = see_get_extension_reg (def_se, 1);\n-  htab_t curr_bb_hash = NULL;\n+  htab_t curr_bb_hash;\n   struct see_register_properties *curr_prop = NULL;\n-  struct see_register_properties **slot_prop = NULL;\n+  struct see_register_properties **slot_prop;\n   struct see_register_properties temp_prop;\n   int ref_luid = DF_INSN_LUID (df, insn);\n \n   curr_bb_hash = see_bb_hash_ar[BLOCK_NUM (curr_ref_s->insn)];\n   if (!curr_bb_hash)\n     {\n       /* The hash doesn't exist yet.  Create it.  */\n-      curr_bb_hash =\n-\thtab_create (10, hash_descriptor_properties, eq_descriptor_properties,\n-\t\t     hash_del_properties);\n+      curr_bb_hash = htab_create (10, \n+\t\t\t\t  hash_descriptor_properties, \n+\t\t\t\t  eq_descriptor_properties,\n+\t\t\t\t  hash_del_properties);\n       see_bb_hash_ar[BLOCK_NUM (curr_ref_s->insn)] = curr_bb_hash;\n     }\n \n@@ -2185,7 +2175,7 @@ see_set_prop_merged_def (void **slot, void *b)\n     (struct see_register_properties **) htab_find_slot (curr_bb_hash,\n \t\t\t\t\t\t\t&temp_prop, INSERT);\n \n-  if (slot_prop && (*slot_prop != NULL))\n+  if (slot_prop && *slot_prop != NULL)\n     {\n       /* Property already exists.  */\n       curr_prop = *slot_prop;\n@@ -2233,19 +2223,20 @@ see_set_prop_unmerged_def (void **slot, void *b)\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx insn = curr_ref_s->insn;\n   rtx dest_extension_reg = see_get_extension_reg (def_se, 1);\n-  htab_t curr_bb_hash = NULL;\n+  htab_t curr_bb_hash;\n   struct see_register_properties *curr_prop = NULL;\n-  struct see_register_properties **slot_prop = NULL;\n+  struct see_register_properties **slot_prop;\n   struct see_register_properties temp_prop;\n   int ref_luid = DF_INSN_LUID (df, insn);\n \n   curr_bb_hash = see_bb_hash_ar[BLOCK_NUM (curr_ref_s->insn)];\n   if (!curr_bb_hash)\n     {\n       /* The hash doesn't exist yet.  Create it.  */\n-      curr_bb_hash =\n-\thtab_create (10, hash_descriptor_properties, eq_descriptor_properties,\n-\t\t     hash_del_properties);\n+      curr_bb_hash = htab_create (10, \n+\t\t\t\t  hash_descriptor_properties, \n+\t\t\t\t  eq_descriptor_properties,\n+\t\t\t\t  hash_del_properties);\n       see_bb_hash_ar[BLOCK_NUM (curr_ref_s->insn)] = curr_bb_hash;\n     }\n \n@@ -2255,7 +2246,7 @@ see_set_prop_unmerged_def (void **slot, void *b)\n     (struct see_register_properties **) htab_find_slot (curr_bb_hash,\n \t\t\t\t\t\t\t&temp_prop, INSERT);\n \n-  if (slot_prop && (*slot_prop != NULL))\n+  if (slot_prop && *slot_prop != NULL)\n     {\n       /* Property already exists.  */\n       curr_prop = *slot_prop;\n@@ -2305,9 +2296,9 @@ see_set_prop_unmerged_use (void **slot, void *b)\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx insn = curr_ref_s->insn;\n   rtx dest_extension_reg = see_get_extension_reg (use_se, 1);\n-  htab_t curr_bb_hash = NULL;\n+  htab_t curr_bb_hash;\n   struct see_register_properties *curr_prop = NULL;\n-  struct see_register_properties **slot_prop = NULL;\n+  struct see_register_properties **slot_prop;\n   struct see_register_properties temp_prop;\n   bool locally_redundant = false;\n   int ref_luid = DF_INSN_LUID (df, insn);\n@@ -2316,9 +2307,10 @@ see_set_prop_unmerged_use (void **slot, void *b)\n   if (!curr_bb_hash)\n     {\n       /* The hash doesn't exist yet.  Create it.  */\n-      curr_bb_hash =\n-\thtab_create (10, hash_descriptor_properties, eq_descriptor_properties,\n-\t\t     hash_del_properties);\n+      curr_bb_hash = htab_create (10, \n+\t\t\t\t  hash_descriptor_properties, \n+\t\t\t\t  eq_descriptor_properties,\n+\t\t\t\t  hash_del_properties);\n       see_bb_hash_ar[BLOCK_NUM (curr_ref_s->insn)] = curr_bb_hash;\n     }\n \n@@ -2328,27 +2320,27 @@ see_set_prop_unmerged_use (void **slot, void *b)\n     (struct see_register_properties **) htab_find_slot (curr_bb_hash,\n \t\t\t\t\t\t\t&temp_prop, INSERT);\n \n-  if (slot_prop && (*slot_prop != NULL))\n+  if (slot_prop && *slot_prop != NULL)\n     {\n       /* Property already exists.  */\n       curr_prop = *slot_prop;\n       gcc_assert (curr_prop->regno == REGNO (dest_extension_reg));\n \n \n-      if ((curr_prop->last_def < 0) && (curr_prop->first_se_before_any_def < 0))\n+      if (curr_prop->last_def < 0 && curr_prop->first_se_before_any_def < 0)\n \tcurr_prop->first_se_before_any_def = ref_luid;\n-      else if ((curr_prop->last_def < 0)\n-\t       && (curr_prop->first_se_before_any_def >= 0))\n+      else if (curr_prop->last_def < 0\n+\t       && curr_prop->first_se_before_any_def >= 0)\n \t{\n \t  /* In this case the extension is localy redundant.  */\n \t  htab_clear_slot (curr_ref_s->use_se_hash, (PTR *)slot);\n \t  locally_redundant = true;\n \t}\n-      else if ((curr_prop->last_def >= 0)\n-\t       && (curr_prop->first_se_after_last_def < 0))\n+      else if (curr_prop->last_def >= 0\n+\t       && curr_prop->first_se_after_last_def < 0)\n \tcurr_prop->first_se_after_last_def = ref_luid;\n-      else if ((curr_prop->last_def >= 0)\n-\t  && (curr_prop->first_se_after_last_def >= 0))\n+      else if (curr_prop->last_def >= 0\n+\t       && curr_prop->first_se_after_last_def >= 0)\n \t{\n \t  /* In this case the extension is localy redundant.  */\n \t  htab_clear_slot (curr_ref_s->use_se_hash, (PTR *)slot);\n@@ -2449,26 +2441,23 @@ see_def_extension_not_merged (struct see_ref_s *curr_ref_s, rtx def_se)\n   rtx merged_ref_next = (curr_ref_s->merged_insn) ?\n   \t\t\tNEXT_INSN (curr_ref_s->merged_insn): NULL_RTX;\n   rtx ref_copy = copy_rtx (ref);\n-  rtx dest_reg = NULL;\n-  rtx dest_real_reg = NULL;\n   rtx source_extension_reg = see_get_extension_reg (def_se, 0);\n   rtx dest_extension_reg = see_get_extension_reg (def_se, 1);\n-  rtx new_pseudo_reg = NULL;\n-  rtx subreg = NULL;\n   rtx move_insn = NULL;\n-  rtx set = NULL;\n-  rtx rhs = NULL;\n+  rtx set, rhs;\n+  rtx dest_reg, dest_real_reg;\n+  rtx new_pseudo_reg, subreg;\n   enum machine_mode source_extension_mode = GET_MODE (source_extension_reg);\n   enum machine_mode dest_mode;\n \n   set = single_set (def_se);\n   gcc_assert (set);\n   rhs = SET_SRC (set);\n-  gcc_assert ((GET_CODE (rhs) == SIGN_EXTEND)\n-\t      || (GET_CODE (rhs) == ZERO_EXTEND));\n+  gcc_assert (GET_CODE (rhs) == SIGN_EXTEND\n+\t      || GET_CODE (rhs) == ZERO_EXTEND);\n   dest_reg = XEXP (rhs, 0);\n   gcc_assert (REG_P (dest_reg)\n-\t      || ((GET_CODE (dest_reg) == SUBREG)\n+\t      || (GET_CODE (dest_reg) == SUBREG\n \t\t  && REG_P (SUBREG_REG (dest_reg))));\n   dest_real_reg = REG_P (dest_reg) ? dest_reg : SUBREG_REG (dest_reg);\n   dest_mode = GET_MODE (dest_reg);\n@@ -2737,12 +2726,10 @@ see_merge_one_def_extension (void **slot, void *b)\n   rtx new_set = NULL;\n   rtx source_extension_reg = see_get_extension_reg (def_se, 0);\n   rtx dest_extension_reg = see_get_extension_reg (def_se, 1);\n-  rtx move_insn = NULL;\n-  rtx *rtx_slot = NULL;\n-  rtx subreg = NULL;\n+  rtx move_insn, *rtx_slot, subreg;\n   rtx temp_extension = NULL;\n   rtx simplified_temp_extension = NULL;\n-  rtx *pat = NULL;\n+  rtx *pat;\n   enum rtx_code code;\n   enum rtx_code extension_code;\n   enum machine_mode source_extension_mode;\n@@ -2790,15 +2777,15 @@ see_merge_one_def_extension (void **slot, void *b)\n \t{\n \t  rtx *sub = &XVECEXP (*pat, 0, i);\n \n-\t  if ((GET_CODE (*sub) == SET)\n-\t      && (GET_MODE (SET_SRC (*sub)) != VOIDmode)\n-\t      && (GET_MODE (SET_DEST (*sub)) == source_mode)\n+\t  if (GET_CODE (*sub) == SET\n+\t      && GET_MODE (SET_SRC (*sub)) != VOIDmode\n+\t      && GET_MODE (SET_DEST (*sub)) == source_mode\n \t      && ((REG_P (SET_DEST (*sub))\n-\t\t  && (REGNO (SET_DEST (*sub)) == REGNO (source_extension_reg)))\n-\t\t || ((GET_CODE (SET_DEST (*sub)) == SUBREG)\n-\t\t     && (REG_P (SUBREG_REG (SET_DEST (*sub))))\n-\t\t     && (REGNO (SUBREG_REG (SET_DEST (*sub))) ==\n-\t\t\t REGNO (source_extension_reg)))))\n+\t\t   && REGNO (SET_DEST (*sub)) == REGNO (source_extension_reg))\n+\t\t  || (GET_CODE (SET_DEST (*sub)) == SUBREG\n+\t\t      && REG_P (SUBREG_REG (SET_DEST (*sub)))\n+\t\t      && (REGNO (SUBREG_REG (SET_DEST (*sub))) ==\n+\t\t\t  REGNO (source_extension_reg)))))\n \t    {\n \t      rtx orig_src = SET_SRC (*sub);\n \n@@ -2822,13 +2809,13 @@ see_merge_one_def_extension (void **slot, void *b)\n \tif (apply_change_group ())\n \t  merge_success = true;\n     }\n-  else if ((code == SET)\n-\t   && (GET_MODE (SET_SRC (*pat)) != VOIDmode)\n-\t   && (GET_MODE (SET_DEST (*pat)) == source_mode)\n+  else if (code == SET\n+\t   && GET_MODE (SET_SRC (*pat)) != VOIDmode\n+\t   && GET_MODE (SET_DEST (*pat)) == source_mode\n \t   && ((REG_P (SET_DEST (*pat))\n \t\t&& REGNO (SET_DEST (*pat)) == REGNO (source_extension_reg))\n-\t       || ((GET_CODE (SET_DEST (*pat)) == SUBREG)\n-\t\t   && (REG_P (SUBREG_REG (SET_DEST (*pat))))\n+\t       || (GET_CODE (SET_DEST (*pat)) == SUBREG\n+\t\t   && REG_P (SUBREG_REG (SET_DEST (*pat)))\n \t\t   && (REGNO (SUBREG_REG (SET_DEST (*pat))) ==\n \t\t       REGNO (source_extension_reg)))))\n     {\n@@ -2896,9 +2883,10 @@ see_merge_one_def_extension (void **slot, void *b)\n      the merged_def_se_hash.  */\n   htab_clear_slot (curr_ref_s->unmerged_def_se_hash, (PTR *)slot);\n   if (!curr_ref_s->merged_def_se_hash)\n-    curr_ref_s->merged_def_se_hash =\n-      htab_create (10, hash_descriptor_extension, eq_descriptor_extension,\n-\t\t   NULL);\n+    curr_ref_s->merged_def_se_hash = htab_create (10, \n+\t\t\t\t\t\t  hash_descriptor_extension, \n+\t\t\t\t\t\t  eq_descriptor_extension,\n+\t\t\t\t\t\t  NULL);\n   rtx_slot = (rtx *) htab_find_slot (curr_ref_s->merged_def_se_hash,\n   \t\t\t\t     dest_extension_reg, INSERT);\n   gcc_assert (*rtx_slot == NULL);\n@@ -2932,7 +2920,7 @@ see_handle_extensions_for_one_ref (splay_tree_node stn,\n   htab_t use_se_hash = ((struct see_ref_s *) (stn->value))->use_se_hash;\n   htab_t unmerged_def_se_hash =\n     ((struct see_ref_s *) (stn->value))->unmerged_def_se_hash;\n-  htab_t merged_def_se_hash = NULL;\n+  htab_t merged_def_se_hash;\n   rtx ref = ((struct see_ref_s *) (stn->value))->insn;\n \n   if (dump_file)\n@@ -3037,7 +3025,7 @@ static bool\n see_store_reference_and_extension (rtx ref_insn, rtx se_insn,\n \t\t\t\t   enum extension_type type)\n {\n-  rtx *rtx_slot = NULL;\n+  rtx *rtx_slot;\n   int curr_bb_num;\n   splay_tree_node stn = NULL;\n   htab_t se_hash = NULL;\n@@ -3049,7 +3037,7 @@ see_store_reference_and_extension (rtx ref_insn, rtx se_insn,\n     return false;\n \n   curr_bb_num = BLOCK_NUM (ref_insn);\n-  gcc_assert ((curr_bb_num < last_bb) && (curr_bb_num >= 0));\n+  gcc_assert (curr_bb_num < last_bb && curr_bb_num >= 0);\n \n   /* Insert the reference to the splay tree of its basic block.  */\n   if (!see_bb_splay_ar[curr_bb_num])\n@@ -3063,43 +3051,47 @@ see_store_reference_and_extension (rtx ref_insn, rtx se_insn,\n       stn = splay_tree_lookup (see_bb_splay_ar[curr_bb_num],\n \t\t\t       DF_INSN_LUID (df, ref_insn));\n       if (stn)\n-\t{\n-\t  switch (type)\n-\t    {\n-\t    case EXPLICIT_DEF_EXTENSION:\n-\t      se_hash =\n-\t\t((struct see_ref_s *) (stn->value))->unmerged_def_se_hash;\n-\t      if (!se_hash)\n-\t\t{\n-\t    \t  se_hash = htab_create (10, hash_descriptor_extension,\n-\t      \t\t\t     \t eq_descriptor_extension, NULL);\n-\t\t  ((struct see_ref_s *) (stn->value))->unmerged_def_se_hash =\n-\t\t    se_hash;\n-\t\t}\n-\t      break;\n-\t    case IMPLICIT_DEF_EXTENSION:\n-\t      se_hash = ((struct see_ref_s *) (stn->value))->merged_def_se_hash;\n-\t      if (!se_hash)\n-\t\t{\n-\t    \t  se_hash = htab_create (10, hash_descriptor_extension,\n-\t      \t\t\t     \t eq_descriptor_extension, NULL);\n-\t\t  ((struct see_ref_s *) (stn->value))->merged_def_se_hash =\n-\t\t    se_hash;\n-\t\t}\n-\t      break;\n-\t    case USE_EXTENSION:\n-\t      se_hash = ((struct see_ref_s *) (stn->value))->use_se_hash;\n-\t      if (!se_hash)\n-\t\t{\n-\t    \t  se_hash = htab_create (10, hash_descriptor_extension,\n-\t      \t\t\t     \t eq_descriptor_extension, NULL);\n-\t\t  ((struct see_ref_s *) (stn->value))->use_se_hash = se_hash;\n-\t\t}\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n+\tswitch (type)\n+\t  {\n+\t  case EXPLICIT_DEF_EXTENSION:\n+\t    se_hash =\n+\t      ((struct see_ref_s *) (stn->value))->unmerged_def_se_hash;\n+\t    if (!se_hash)\n+\t      {\n+\t\tse_hash = htab_create (10, \n+\t\t\t\t       hash_descriptor_extension,\n+\t\t\t\t       eq_descriptor_extension, \n+\t\t\t\t       NULL);\n+\t\t((struct see_ref_s *) (stn->value))->unmerged_def_se_hash =\n+\t\t  se_hash;\n+\t      }\n+\t    break;\n+\t  case IMPLICIT_DEF_EXTENSION:\n+\t    se_hash = ((struct see_ref_s *) (stn->value))->merged_def_se_hash;\n+\t    if (!se_hash)\n+\t      {\n+\t\tse_hash = htab_create (10, \n+\t\t\t\t       hash_descriptor_extension,\n+\t\t\t\t       eq_descriptor_extension, \n+\t\t\t\t       NULL);\n+\t\t((struct see_ref_s *) (stn->value))->merged_def_se_hash =\n+\t\t  se_hash;\n+\t      }\n+\t    break;\n+\t  case USE_EXTENSION:\n+\t    se_hash = ((struct see_ref_s *) (stn->value))->use_se_hash;\n+\t    if (!se_hash)\n+\t      {\n+\t\tse_hash = htab_create (10, \n+\t\t\t\t       hash_descriptor_extension,\n+\t\t\t\t       eq_descriptor_extension, \n+\t\t\t\t       NULL);\n+\t\t((struct see_ref_s *) (stn->value))->use_se_hash = se_hash;\n+\t      }\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n     }\n \n   /* Initialize a new see_ref_s structure and insert it to the splay\n@@ -3115,25 +3107,28 @@ see_store_reference_and_extension (rtx ref_insn, rtx se_insn,\n       switch (type)\n \t{\n \tcase EXPLICIT_DEF_EXTENSION:\n-\t  ref_s->unmerged_def_se_hash =\n-\t    htab_create (10, hash_descriptor_extension, eq_descriptor_extension,\n-\t  \t\t NULL);\n+\t  ref_s->unmerged_def_se_hash = htab_create (10, \n+\t\t\t\t\t\t     hash_descriptor_extension, \n+\t\t\t\t\t\t     eq_descriptor_extension,\n+\t\t\t\t\t\t     NULL);\n \t  se_hash = ref_s->unmerged_def_se_hash;\n \t  ref_s->merged_def_se_hash = NULL;\n \t  ref_s->use_se_hash = NULL;\n \t  break;\n \tcase IMPLICIT_DEF_EXTENSION:\n-\t  ref_s->merged_def_se_hash =\n-\t    htab_create (10, hash_descriptor_extension, eq_descriptor_extension,\n-\t  \t\t NULL);\n+\t  ref_s->merged_def_se_hash = htab_create (10, \n+\t\t\t\t\t\t   hash_descriptor_extension, \n+\t\t\t\t\t\t   eq_descriptor_extension,\n+\t\t\t\t\t\t   NULL);\n \t  se_hash = ref_s->merged_def_se_hash;\n \t  ref_s->unmerged_def_se_hash = NULL;\n \t  ref_s->use_se_hash = NULL;\n \t  break;\n \tcase USE_EXTENSION:\n-\t  ref_s->use_se_hash =\n-\t    htab_create (10, hash_descriptor_extension, eq_descriptor_extension,\n-\t  \t\t NULL);\n+\t  ref_s->use_se_hash = htab_create (10, \n+\t\t\t\t\t    hash_descriptor_extension, \n+\t\t\t\t\t    eq_descriptor_extension,\n+\t\t\t\t\t    NULL);\n \t  se_hash = ref_s->use_se_hash;\n \t  ref_s->unmerged_def_se_hash = NULL;\n \t  ref_s->merged_def_se_hash = NULL;\n@@ -3197,8 +3192,8 @@ see_handle_relevant_defs (void)\n \n       root_entry = unionfind_root (&def_entry[i]);\n \n-      if ((ENTRY_EI (root_entry)->relevancy != SIGN_EXTENDED_DEF)\n-\t  && (ENTRY_EI (root_entry)->relevancy != ZERO_EXTENDED_DEF))\n+      if (ENTRY_EI (root_entry)->relevancy != SIGN_EXTENDED_DEF\n+\t  && ENTRY_EI (root_entry)->relevancy != ZERO_EXTENDED_DEF)\n \t/* The current web is not relevant.  Continue to the next def.  */\n \tcontinue;\n \n@@ -3213,7 +3208,7 @@ see_handle_relevant_defs (void)\n \t source_mode is narrower then its web's source_mode.\n \t This means that we need to generate the implicit extension explicitly\n \t and store it in the current reference's merged_def_se_hash.  */\n-      if ((ENTRY_EI (&def_entry[i])->local_relevancy == EXTENDED_DEF)\n+      if (ENTRY_EI (&def_entry[i])->local_relevancy == EXTENDED_DEF\n \t  || (ENTRY_EI (&def_entry[i])->local_source_mode <\n \t      ENTRY_EI (root_entry)->source_mode))\n \t{\n@@ -3282,8 +3277,8 @@ see_handle_relevant_uses (void)\n \n       root_entry = unionfind_root (&use_entry[i]);\n \n-      if ((ENTRY_EI (root_entry)->relevancy != SIGN_EXTENDED_DEF)\n-\t  && (ENTRY_EI (root_entry)->relevancy != ZERO_EXTENDED_DEF))\n+      if (ENTRY_EI (root_entry)->relevancy != SIGN_EXTENDED_DEF\n+\t  && ENTRY_EI (root_entry)->relevancy != ZERO_EXTENDED_DEF)\n \t/* The current web is not relevant.  Continue to the next use.  */\n \tcontinue;\n \n@@ -3460,8 +3455,8 @@ see_analyze_one_def (rtx insn, enum machine_mode *source_mode,\n \treturn NOT_RELEVANT;\n \n       /* If we can't use copy_rtx on the reference it can't be a reference.  */\n-      if ((GET_CODE (PATTERN (prev_insn)) == PARALLEL)\n-\t   && (asm_noperands (PATTERN (prev_insn)) >= 0))\n+      if (GET_CODE (PATTERN (prev_insn)) == PARALLEL\n+\t   && asm_noperands (PATTERN (prev_insn)) >= 0)\n \treturn NOT_RELEVANT;\n \n       /* Now, check if this extension is a reference itself.  If so, it is not\n@@ -3503,15 +3498,15 @@ see_analyze_one_def (rtx insn, enum machine_mode *source_mode,\n \n       switch (GET_CODE (rhs))\n \t{\n-\tcase (SIGN_EXTEND):\n+\tcase SIGN_EXTEND:\n \t  *source_mode = GET_MODE (XEXP (rhs, 0));\n \t  *source_mode_unsigned = MAX_MACHINE_MODE;\n \t  return EXTENDED_DEF;\n-\tcase (ZERO_EXTEND):\n+\tcase ZERO_EXTEND:\n \t  *source_mode = MAX_MACHINE_MODE;\n \t  *source_mode_unsigned = GET_MODE (XEXP (rhs, 0));\n \t  return EXTENDED_DEF;\n-\tcase (CONST_INT):\n+\tcase CONST_INT:\n \n \t  val = INTVAL (rhs);\n \n@@ -3521,17 +3516,17 @@ see_analyze_one_def (rtx insn, enum machine_mode *source_mode,\n \t       mode = GET_MODE_WIDER_MODE (mode), i++)\n \t    {\n \t      val2 = trunc_int_for_mode (val, mode);\n-  \t      if ((val2 == val) && (*source_mode == MAX_MACHINE_MODE))\n+  \t      if (val2 == val && *source_mode == MAX_MACHINE_MODE)\n \t\t*source_mode = mode;\n-\t      if ((val == (val & (HOST_WIDE_INT)GET_MODE_MASK (mode)))\n-\t\t  && (*source_mode_unsigned == MAX_MACHINE_MODE))\n+\t      if (val == (val & (HOST_WIDE_INT)GET_MODE_MASK (mode))\n+\t\t  && *source_mode_unsigned == MAX_MACHINE_MODE)\n \t\t*source_mode_unsigned = mode;\n-\t      if ((*source_mode != MAX_MACHINE_MODE)\n-\t\t  && (*source_mode_unsigned !=MAX_MACHINE_MODE))\n+\t      if (*source_mode != MAX_MACHINE_MODE\n+\t\t  && *source_mode_unsigned !=MAX_MACHINE_MODE)\n \t\treturn EXTENDED_DEF;\n \t    }\n-\t  if ((*source_mode != MAX_MACHINE_MODE)\n-\t      || (*source_mode_unsigned !=MAX_MACHINE_MODE))\n+\t  if (*source_mode != MAX_MACHINE_MODE\n+\t      || *source_mode_unsigned !=MAX_MACHINE_MODE)\n \t    return EXTENDED_DEF;\n \t  return NOT_RELEVANT;\n \tdefault:\n@@ -3609,8 +3604,8 @@ see_update_defs_relevancy (void)\n \t\t  break;\n \t\tcase EXTENDED_DEF :\n \t\t  fprintf (dump_file, \"EXTENDED_DEF, \");\n-\t\t  if ((source_mode != MAX_MACHINE_MODE)\n-\t\t      && (source_mode_unsigned != MAX_MACHINE_MODE))\n+\t\t  if (source_mode != MAX_MACHINE_MODE\n+\t\t      && source_mode_unsigned != MAX_MACHINE_MODE)\n \t\t    {\n \t\t      fprintf (dump_file, \"positive const, \");\n \t\t      fprintf (dump_file, \"source_mode_signed = %s, \",\n@@ -3662,10 +3657,8 @@ see_propagate_extensions_to_uses (void)\n      and there is at least one definition that was marked as SIGN_EXTENDED_DEF\n      or ZERO_EXTENDED_DEF.  */\n   for (i = 0; i < uses_num; i++)\n-    {\n-      union_defs (df, DF_USES_GET (df, i), def_entry, use_entry,\n-\t\t  see_update_leader_extra_info);\n-    }\n+    union_defs (df, DF_USES_GET (df, i), def_entry, use_entry,\n+\t\tsee_update_leader_extra_info);\n \n   /* Generate use extensions for references and insert these\n      references to see_bb_splay_ar data structure.    */\n@@ -3681,13 +3674,13 @@ see_propagate_extensions_to_uses (void)\n   if (num_relevant_defs < 0)\n     return false;\n \n-  return ((num_relevant_uses > 0) || (num_relevant_defs > 0));\n+ return num_relevant_uses > 0 || num_relevant_defs > 0;\n }\n \n \n /* Main entry point for the sign extension elimination optimization.  */\n \n-void\n+static void\n see_main (void)\n {\n   bool cont = false;\n@@ -3742,7 +3735,7 @@ see_main (void)\n static bool\n gate_handle_see (void)\n {\n-  return ((optimize > 1) && flag_see);\n+  return optimize > 1 && flag_see;\n }\n \n static unsigned int"}]}