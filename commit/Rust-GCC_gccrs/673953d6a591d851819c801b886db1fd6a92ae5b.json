{"sha": "673953d6a591d851819c801b886db1fd6a92ae5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjczOTUzZDZhNTkxZDg1MTgxOWM4MDFiODg2ZGIxZmQ2YTkyYWU1Yg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2000-12-03T06:34:54Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-12-03T06:34:54Z"}, "message": "Makefile.in: Rebuilt.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (awt_java_source_files): Added new files.\n\t* java/awt/CardLayout.java: New file.\n\t* java/awt/AWTPermission.java: New file.\n\nFrom-SVN: r37965", "tree": {"sha": "ac0ed68c1f1f1e55b9a1fff4c4272564ac145606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac0ed68c1f1f1e55b9a1fff4c4272564ac145606"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/673953d6a591d851819c801b886db1fd6a92ae5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673953d6a591d851819c801b886db1fd6a92ae5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/673953d6a591d851819c801b886db1fd6a92ae5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673953d6a591d851819c801b886db1fd6a92ae5b/comments", "author": null, "committer": null, "parents": [{"sha": "d118937d79ce5f32fcc7b09acb932e559a2c16e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d118937d79ce5f32fcc7b09acb932e559a2c16e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d118937d79ce5f32fcc7b09acb932e559a2c16e9"}], "stats": {"total": 419, "additions": 416, "deletions": 3}, "files": [{"sha": "be5d6c9fc0cefec26e805209d298831231d65017", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=673953d6a591d851819c801b886db1fd6a92ae5b", "patch": "@@ -1,3 +1,10 @@\n+2000-12-02  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (awt_java_source_files): Added new files.\n+\t* java/awt/CardLayout.java: New file.\n+\t* java/awt/AWTPermission.java: New file.\n+\n 2000-12-01  Tom Tromey  <tromey@redhat.com>\n \n \t* java/util/Vector.java (insertElementAt): Unconditionally"}, {"sha": "9d3389e64ad948cb21bfcd6c31c47a0855d5a7be", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=673953d6a591d851819c801b886db1fd6a92ae5b", "patch": "@@ -563,11 +563,13 @@ java/awt/AWTError.java \\\n java/awt/AWTEvent.java \\\n java/awt/AWTEventMulticaster.java \\\n java/awt/AWTException.java \\\n+java/awt/AWTPermission.java \\\n java/awt/ActiveEvent.java \\\n java/awt/Adjustable.java \\\n java/awt/BorderLayout.java \\\n java/awt/Button.java \\\n java/awt/Canvas.java \\\n+java/awt/CardLayout.java \\\n java/awt/Checkbox.java \\\n java/awt/CheckboxGroup.java \\\n java/awt/CheckboxMenuItem.java \\"}, {"sha": "d566cc57abea55be9ed8be047cb5e8e89a75e4a2", "filename": "libjava/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=673953d6a591d851819c801b886db1fd6a92ae5b", "patch": "@@ -334,11 +334,13 @@ java/awt/AWTError.java \\\n java/awt/AWTEvent.java \\\n java/awt/AWTEventMulticaster.java \\\n java/awt/AWTException.java \\\n+java/awt/AWTPermission.java \\\n java/awt/ActiveEvent.java \\\n java/awt/Adjustable.java \\\n java/awt/BorderLayout.java \\\n java/awt/Button.java \\\n java/awt/Canvas.java \\\n+java/awt/CardLayout.java \\\n java/awt/Checkbox.java \\\n java/awt/CheckboxGroup.java \\\n java/awt/CheckboxMenuItem.java \\\n@@ -1310,9 +1312,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/applet/AppletStub.P .deps/java/applet/AudioClip.P \\\n .deps/java/awt/AWTError.P .deps/java/awt/AWTEvent.P \\\n .deps/java/awt/AWTEventMulticaster.P .deps/java/awt/AWTException.P \\\n-.deps/java/awt/ActiveEvent.P .deps/java/awt/Adjustable.P \\\n-.deps/java/awt/BorderLayout.P .deps/java/awt/Button.P \\\n-.deps/java/awt/Canvas.P .deps/java/awt/Checkbox.P \\\n+.deps/java/awt/AWTPermission.P .deps/java/awt/ActiveEvent.P \\\n+.deps/java/awt/Adjustable.P .deps/java/awt/BorderLayout.P \\\n+.deps/java/awt/Button.P .deps/java/awt/Canvas.P \\\n+.deps/java/awt/CardLayout.P .deps/java/awt/Checkbox.P \\\n .deps/java/awt/CheckboxGroup.P .deps/java/awt/CheckboxMenuItem.P \\\n .deps/java/awt/Choice.P .deps/java/awt/Color.P \\\n .deps/java/awt/Component.P .deps/java/awt/ComponentOrientation.P \\"}, {"sha": "b4cf1938fa9c737ffa5e6e0209e3a8a17c262a1e", "filename": "libjava/java/awt/AWTPermission.java", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2Fjava%2Fawt%2FAWTPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2Fjava%2Fawt%2FAWTPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FAWTPermission.java?ref=673953d6a591d851819c801b886db1fd6a92ae5b", "patch": "@@ -0,0 +1,44 @@\n+// AWTPermission.java - AWT permissions\n+\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/**\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @date December 2, 2000\n+ */\n+\n+package java.awt;\n+\n+import java.security.BasicPermission;\n+\n+/**\n+ * This class implements permissions for AWT.  This is a named\n+ * permission.  No actions are defined.\n+ */\n+public final class AWTPermission extends BasicPermission\n+{\n+  /**\n+   * Construct a AWTPermission with the given name.\n+   * @param name The permission name\n+   */\n+  public AWTPermission (String name)\n+  {\n+    super (name);\n+  }\n+\n+  /**\n+   * Construct a AWTPermission with the given name.\n+   * @param name The permission name\n+   * @param actions The actions; this is ignored and should be null.\n+   */\n+  public AWTPermission (String name, String actions)\n+  {\n+    super (name, actions);\n+  }\n+}"}, {"sha": "eaa722b623e22885d11e0ecf99f87e0e3ffef997", "filename": "libjava/java/awt/CardLayout.java", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2Fjava%2Fawt%2FCardLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673953d6a591d851819c801b886db1fd6a92ae5b/libjava%2Fjava%2Fawt%2FCardLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FCardLayout.java?ref=673953d6a591d851819c801b886db1fd6a92ae5b", "patch": "@@ -0,0 +1,357 @@\n+// CardLayout.java - Card-based layout engine\n+\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt;\n+\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.io.Serializable;\n+\n+/** This class implements a card-based layout scheme.  Each included\n+ * component is treated as a card.  Only one card can be shown at a\n+ * time.  This class includes methods for changing which card is\n+ * shown.\n+ *\n+ * @verson 0.0\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @date December 2, 2000\n+ */\n+public class CardLayout implements LayoutManager2, Serializable\n+{\n+  /** Create a new CardLayout object with both gaps zero.  */\n+  public CardLayout ()\n+  {\n+    this (0, 0);\n+  }\n+\n+  /** Create a new CardLayout object with the specified horizontal and\n+   * vertical gaps.\n+   * @param hgap The horizontal gap\n+   * @param vgap The vertical gap\n+   */\n+  public CardLayout (int hgap, int vgap)\n+  {\n+    this.hgap = hgap;\n+    this.vgap = vgap;\n+    this.map = new Hashtable ();\n+  }\n+\n+  /** Add a new component to the layout.  The constraint must be a\n+   * string which is used to name the component.  This string can\n+   * later be used to refer to the particular component.\n+   * @param comp The component to add\n+   * @param constraints The name by which the component can later be called\n+   * @exception IllegalArgumentException If `constraints' is not a string\n+   */\n+  public void addLayoutComponent (Component comp, Object constraints)\n+  {\n+    if (! (constraints instanceof String))\n+      throw new IllegalArgumentException (\"Object \" + constraints\n+\t\t\t\t\t  + \" is not a string\");\n+    map.put (constraints, comp);\n+  }\n+\n+  /** Add a new component to the layout.  The name can be used later\n+   * to refer to the component.\n+   * @param name The name by which the component can later be called\n+   * @param comp The component to add\n+   * @deprecated\n+   */\n+  public void addLayoutComponent (String name, Component comp)\n+  {\n+    addLayoutComponent (comp, name);\n+  }\n+\n+  /** Cause the first component in the container to be displayed.\n+   * @param parent The parent container\n+   */\n+  public void first (Container parent)\n+  {\n+    gotoComponent (parent, FIRST, null);\n+  }\n+\n+  /** Return this layout manager's horizontal gap.  */\n+  public int getHgap ()\n+  {\n+    return hgap;\n+  }\n+\n+  /** Return this layout manager's x alignment.  This method always\n+   * returns Component.CENTER_ALIGNMENT.\n+   * @param parent Container using this layout manager instance\n+   */\n+  public float getLayoutAlignmentX (Container parent)\n+  {\n+    return Component.CENTER_ALIGNMENT;\n+  }\n+\n+  /** Returns this layout manager's y alignment.  This method always\n+   * returns Component.CENTER_ALIGNMENT.\n+   * @param parent Container using this layout manager instance\n+   */\n+  public float getLayoutAlignmentY (Container parent)\n+  {\n+    return Component.CENTER_ALIGNMENT;\n+  }\n+\n+  /** Return this layout manager's vertical gap.  */\n+  public int getVgap ()\n+  {\n+    return vgap;\n+  }\n+\n+  /** Invalidate this layout manager's state.  */\n+  public void invalidateLayout (Container target)\n+  {\n+    // Do nothing.\n+  }\n+\n+  /** Cause the last component in the container to be displayed.\n+   * @param parent The parent container\n+   */\n+  public void last (Container parent)\n+  {\n+    gotoComponent (parent, LAST, null);\n+  }\n+\n+  /** Lay out the container's components based on the current\n+   * settings.\n+   * @param parent The parent container\n+   */\n+  public void layoutContainer (Container parent)\n+  {\n+    // FIXME: can we just use the width and height fields of parent?\n+    // Or will that break with subclassing?\n+    Dimension d = parent.getSize ();\n+\n+    Insets ins = parent.getInsets ();\n+\n+    int num = parent.getComponentCount ();\n+    // This is more efficient than calling getComponents().\n+    Component[] comps = parent.component;\n+    \n+    for (int i = 0; i < num; ++i)\n+      {\n+\tif (comps[i].isVisible ())\n+\t  {\n+\t    // Only resize the one we care about.\n+\t    comps[i].setBounds (hgap + ins.left, vgap + ins.top,\n+\t\t\t\td.width - 2 * hgap - ins.left - ins.right,\n+\t\t\t\td.height - 2 * vgap - ins.top - ins.bottom);\n+\t    break;\n+\t  }\n+      }\n+  }\n+\n+  /** Get the maximum layout size of the container.\n+   * @param target The parent container\n+   */\n+  public Dimension maximumLayoutSize (Container target)\n+  {\n+    // The JCL says that this returns Integer.MAX_VALUE for both\n+    // dimensions.  But that just seems wrong to me.\n+    return getSize (target, MAX);\n+  }\n+\n+  /** Get the minimum layout size of the container.\n+   * @param target The parent container\n+   */\n+  public Dimension minimumLayoutSize (Container target)\n+  {\n+    return getSize (target, MIN);\n+  }\n+\n+  /** Cause the next component in the container to be displayed.\n+   * @param parent The parent container\n+   */\n+  public void next (Container parent)\n+  {\n+    gotoComponent (parent, NEXT, null);\n+  }\n+\n+  /** Get the preferred layout size of the container.\n+   * @param target The parent container\n+   */\n+  public Dimension preferredLayoutSize (Container parent)\n+  {\n+    return getSize (parent, PREF);\n+  }\n+\n+  /** Cause the previous component in the container to be displayed.\n+   * @param parent The parent container\n+   */\n+  public void previous (Container parent)\n+  {\n+    gotoComponent (parent, PREV, null);\n+  }\n+\n+  /** Remove the indicated component from this layout manager.\n+   * @param comp The component to remove\n+   */\n+  public void removeLayoutComponent (Component comp)\n+  {\n+    Enumeration e = map.keys ();\n+    while (e.hasMoreElements ())\n+      {\n+\tObject key = e.nextElement ();\n+\tif (map.get (key) == comp)\n+\t  {\n+\t    map.remove (key);\n+\t    break;\n+\t  }\n+      }\n+  }\n+\n+  /** Set this layout manager's horizontal gap.\n+   * @param hgap The new gap\n+   */\n+  public void setHgap (int hgap)\n+  {\n+    this.hgap = hgap;\n+  }\n+\n+  /** Set this layout manager's vertical gap.\n+   * @param vgap The new gap\n+   */\n+  public void setVgap (int vgap)\n+  {\n+    this.vgap = vgap;\n+  }\n+\n+  /** Cause the named component to be shown.  If the component name is\n+   * unknown, this method does nothing.\n+   * @param parent The parent container\n+   * @param name The name of the component to show\n+   */\n+  public void show (Container parent, String name)\n+  {\n+    Object target = map.get (name);\n+    if (target != null)\n+      gotoComponent (parent, NONE, (Component) target);\n+  }\n+\n+  public String toString ()\n+  {\n+    return getClass ().getName () + \"[\" + hgap + \",\" + vgap + \"]\";\n+  }\n+\n+  // This implements first(), last(), next(), and previous().\n+  private void gotoComponent (Container parent, int what,\n+\t\t\t      Component target)\n+  {\n+    int num = parent.getComponentCount ();\n+    // This is more efficient than calling getComponents().\n+    Component[] comps = parent.component;\n+    int choice = -1;\n+\n+    if (what == FIRST)\n+      choice = 0;\n+    else if (what == LAST)\n+      choice = num;\n+    else if (what >= 0)\n+      choice = what;\n+\n+    for (int i = 0; i < num; ++i)\n+      {\n+\t// If TARGET is set then we are looking for a specific\n+\t// component.\n+\tif (target != null)\n+\t  {\n+\t    if (target == comps[i])\n+\t      choice = i;\n+\t  }\n+\n+\tif (comps[i].isVisible ())\n+\t  {\n+\t    if (what == NEXT)\n+\t      {\n+\t\tchoice = i + 1;\n+\t\tif (choice == num)\n+\t\t  choice = num - 1;\n+\t      }\n+\t    else if (what == PREV)\n+\t      {\n+\t\tchoice = i - 1;\n+\t\tif (choice < 0)\n+\t\t  choice = 0;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Do nothing if we're already looking at the right\n+\t\t// component.\n+\t\tif (choice == i)\n+\t\t  return;\n+\t      }\n+\t    comps[i].setVisible (false);\n+\n+\t    if (choice >= 0)\n+\t      break;\n+\t  }\n+      }\n+\n+    comps[choice].setVisible (true);\n+  }\n+\n+  // Compute the size according to WHAT.\n+  private Dimension getSize (Container parent, int what)\n+  {\n+    int w = 0, h = 0, num = parent.getComponentCount ();\n+    // This is more efficient than calling getComponents().\n+    Component[] comps = parent.component;\n+\n+    for (int i = 0; i < num; ++i)\n+      {\n+\t// FIXME: can we just directly read the fields in Component?\n+\t// Or will that not work with subclassing?\n+\tDimension d;\n+\n+\tif (what == MIN)\n+\t  d = comps[i].getMinimumSize ();\n+\telse if (what == MAX)\n+\t  d = comps[i].getMaximumSize ();\n+\telse\n+\t  d = comps[i].getPreferredSize ();\n+\n+\tw = Math.max (d.width, w);\n+\th = Math.max (d.height, h);\n+      }\n+\n+    Insets i = parent.getInsets ();\n+    w += 2 * hgap + i.right + i.left;\n+    h += 2 * vgap + i.bottom + i.top;\n+\n+    // Handle overflow.\n+    if (w < 0)\n+      w = Integer.MAX_VALUE;\n+    if (h < 0)\n+      h = Integer.MAX_VALUE;\n+\n+    return new Dimension (w, h);\n+  }\n+\n+  // The gaps.\n+  private int hgap;\n+  private int vgap;\n+\n+  // This hashtable maps a name to a component.\n+  private Hashtable map;\n+\n+  // These constants are used by the private gotoComponent method.\n+  private int FIRST = 0;\n+  private int LAST = 1;\n+  private int NEXT = 2;\n+  private int PREV = 3;\n+  private int NONE = 4;\n+\n+  // These constants are used by the private getSize method.\n+  private int MIN = 0;\n+  private int MAX = 1;\n+  private int PREF = 2;\n+}"}]}