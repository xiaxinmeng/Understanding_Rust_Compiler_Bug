{"sha": "7c6d41201350820950728973099f783e1976b444", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M2ZDQxMjAxMzUwODIwOTUwNzI4OTczMDk5Zjc4M2UxOTc2YjQ0NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T17:21:32Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T17:21:32Z"}, "message": "(make_function_rtl, make_decl_rtl): Add a prefix when flag_prefix_function_name_usage is set.\n\n(make_function_rtl, make_decl_rtl): Add a prefix when\nflag_prefix_function_name_usage is set.\n(assemble_name): Strip the CHKR_PREFIX.\n\nFrom-SVN: r14619", "tree": {"sha": "334788f1ec32de344733b6ce1f4e5cfaef76f2e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/334788f1ec32de344733b6ce1f4e5cfaef76f2e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c6d41201350820950728973099f783e1976b444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6d41201350820950728973099f783e1976b444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c6d41201350820950728973099f783e1976b444", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6d41201350820950728973099f783e1976b444/comments", "author": null, "committer": null, "parents": [{"sha": "0844ee7f631c83f11f73aec03977cf6af6c90260", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0844ee7f631c83f11f73aec03977cf6af6c90260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0844ee7f631c83f11f73aec03977cf6af6c90260"}], "stats": {"total": 44, "additions": 44, "deletions": 0}, "files": [{"sha": "c8ece891d241d7c0752e053bbbfbb7da12a206a1", "filename": "gcc/varasm.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6d41201350820950728973099f783e1976b444/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6d41201350820950728973099f783e1976b444/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7c6d41201350820950728973099f783e1976b444", "patch": "@@ -60,6 +60,18 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_STABS_OP \".stabs\"\n #endif\n \n+/* Define the prefix to use when check_memory_usage_flag is enable.  */\n+#ifdef NO_DOLLAR_IN_LABEL\n+#ifdef NO_DOT_IN_LABEL\n+#define CHKR_PREFIX \"chkr_prefix_\"\n+#else /* !NO_DOT_IN_LABEL */\n+#define CHKR_PREFIX \"chkr.\"\n+#endif \n+#else /* !NO_DOLLAR_IN_LABLE */\n+#define CHKR_PREFIX \"chkr$\"\n+#endif\n+#define CHKR_PREFIX_SIZE (sizeof (CHKR_PREFIX) - 1)\n+\n /* This macro gets just the user-specified name\n    out of the string in a SYMBOL_REF.  On most machines,\n    we discard the * if any and that's all.  */\n@@ -472,6 +484,7 @@ make_function_rtl (decl)\n      tree decl;\n {\n   char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  char *new_name = name;\n \n   if (output_bytecode)\n     {\n@@ -495,6 +508,20 @@ make_function_rtl (decl)\n       name = obstack_copy0 (saveable_obstack, label, strlen (label));\n       var_labelno++;\n     }\n+  else\n+    {\n+      /* When -fprefix-function-name is used, every function name is\n+         prefixed.  Even static functions are prefixed because they\n+         could be declared latter.  Note that a nested function name\n+         is not prefixed.  */\n+      if (flag_prefix_function_name)\n+        {\n+          new_name = (char *) alloca (strlen (name) + CHKR_PREFIX_SIZE + 1);\n+          strcpy (new_name, CHKR_PREFIX);\n+          strcpy (new_name + CHKR_PREFIX_SIZE, name);\n+          name = obstack_copy0 (saveable_obstack, new_name, strlen (new_name));\n+        }\n+    }\n \n   if (DECL_RTL (decl) == 0)\n     {\n@@ -760,6 +787,20 @@ make_decl_rtl (decl, asmspec, top_level)\n \t  if (name == 0)\n \t    abort ();\n \n+\t  /* When -fprefix-function-name is used, the functions\n+\t     names are prefixed.  Only nested function names are not\n+\t     prefixed.  */\n+\t  if (flag_prefix_function_name && TREE_CODE (decl) == FUNCTION_DECL)\n+\t    {\n+\t      char *new_name;\n+\t      new_name = (char *) alloca (strlen (name) + CHKR_PREFIX_SIZE \n+\t      \t\t\t\t  + 1);\n+\t      strcpy (new_name, CHKR_PREFIX);\n+\t      strcpy (new_name + CHKR_PREFIX_SIZE, name);\n+\t      name = obstack_copy0 (saveable_obstack,\n+\t      \t\t\t   new_name, strlen (new_name));\n+\t    }\n+\n \t  DECL_RTL (decl) = gen_rtx (MEM, DECL_MODE (decl),\n \t\t\t\t     gen_rtx (SYMBOL_REF, Pmode, name));\n \n@@ -1759,6 +1800,9 @@ assemble_name (file, name)\n   tree id;\n \n   STRIP_NAME_ENCODING (real_name, name);\n+  if (flag_prefix_function_name \n+      && ! bcmp (real_name, CHKR_PREFIX, CHKR_PREFIX_SIZE))\n+    real_name = real_name + CHKR_PREFIX_SIZE;\n \n   id = maybe_get_identifier (real_name);\n   if (id)"}]}