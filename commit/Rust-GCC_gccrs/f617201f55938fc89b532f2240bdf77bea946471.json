{"sha": "f617201f55938fc89b532f2240bdf77bea946471", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxNzIwMWY1NTkzOGZjODliNTMyZjIyNDBiZGY3N2JlYTk0NjQ3MQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2011-03-16T22:03:56Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2011-03-16T22:03:56Z"}, "message": "Make-lang.in (CXX_PARSER_H): New.\n\n\n\t* Make-lang.in (CXX_PARSER_H): New.\n\t(cp/parser.o): Add dependency on CXX_PARSER_H.\n\tAdd dependency on tree-pretty-print.h\n\t(cp/cp-lang.o): Add dependency on CXX_PARSER_H.\n\t* cp-lang.c: Include parser.h.\n\t* parser.c: Include parser.h.\n\t(struct cp_token): Add bitfield purged_p.\n\tUpdate all users.\n\tMove to parser.h.\n\t(CPP_PURGED): Remove.  Update all users.\n\t(struct cp_lexer): Change field buffer to be a VEC of cp_token.\n\tRemove field buffer_length.\n\tUpdate all users.\n\tMove to parser.h.\n\t(struct tree_check): Move to parser.h.\n\t(cp_token_position): Likewise.\n\t(struct cp_token_cache): Likewise.\n\t(CPP_KEYWORD): Likewise.\n\t(CPP_TEMPLATE_ID): Likewise.\n\t(CPP_NESTED_NAME_SPECIFIER): Likewise.\n\t(N_CP_TTYPES): Likewise.\n\t(enum cp_parser_status_kind): Likewise.\n\t(struct cp_parser_context): Likewise.\n\t(struct cp_default_arg_entry_d): Likewise.\n\t(struct cp_unparsed_functions_entry_d): Likewise.\n\t(struct cp_parser): Likewise.\n\t(cp_lexer_dump_tokens): New.\n\t(cp_lexer_debug_tokens): New.\n\t(cp_lexer_finished_p): New.\n\t(cp_lexer_alloc): Factor out of cp_lexer_new_main.\n\t(cp_lexer_new_main): Re-write main lexing loop to push\n\ttokens into the new VEC buffer.\n\t(cp_lexer_print_token): Improve printing of CPP_NUMBER tokens.\n\tDo not abort if the token type is not recognized, just print\n\tits code.\n\t* parser.h: New file.\n\t* config-lang.in (gtfiles): Add cp/parser.h.\n\nFrom-SVN: r171075", "tree": {"sha": "e14a1a1dd4983c6b0a4b06a9cfc043d6dbd4e700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e14a1a1dd4983c6b0a4b06a9cfc043d6dbd4e700"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f617201f55938fc89b532f2240bdf77bea946471", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f617201f55938fc89b532f2240bdf77bea946471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f617201f55938fc89b532f2240bdf77bea946471", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f617201f55938fc89b532f2240bdf77bea946471/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b5cb7d63412fe8599cf9dada904e574d39809f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b5cb7d63412fe8599cf9dada904e574d39809f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b5cb7d63412fe8599cf9dada904e574d39809f9"}], "stats": {"total": 906, "additions": 529, "deletions": 377}, "files": [{"sha": "a2002b1849405e5d2142fc3ff7b9a850eeccd981", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f617201f55938fc89b532f2240bdf77bea946471", "patch": "@@ -1,3 +1,43 @@\n+2011-03-16  Diego Novillo  <dnovillo@google.com>\n+\n+\t* Make-lang.in (CXX_PARSER_H): New.\n+\t(cp/parser.o): Add dependency on CXX_PARSER_H.\n+\tAdd dependency on tree-pretty-print.h\n+\t(cp/cp-lang.o): Add dependency on CXX_PARSER_H.\n+\t* cp-lang.c: Include parser.h.\n+\t* parser.c: Include parser.h.\n+\t(struct cp_token): Add bitfield purged_p.\n+\tUpdate all users.\n+\tMove to parser.h.\n+\t(CPP_PURGED): Remove.  Update all users.\n+\t(struct cp_lexer): Change field buffer to be a VEC of cp_token.\n+\tRemove field buffer_length.\n+\tUpdate all users.\n+\tMove to parser.h.\n+\t(struct tree_check): Move to parser.h.\n+\t(cp_token_position): Likewise.\n+\t(struct cp_token_cache): Likewise.\n+\t(CPP_KEYWORD): Likewise.\n+\t(CPP_TEMPLATE_ID): Likewise.\n+\t(CPP_NESTED_NAME_SPECIFIER): Likewise.\n+\t(N_CP_TTYPES): Likewise.\n+\t(enum cp_parser_status_kind): Likewise.\n+\t(struct cp_parser_context): Likewise.\n+\t(struct cp_default_arg_entry_d): Likewise.\n+\t(struct cp_unparsed_functions_entry_d): Likewise.\n+\t(struct cp_parser): Likewise.\n+\t(cp_lexer_dump_tokens): New.\n+\t(cp_lexer_debug_tokens): New.\n+\t(cp_lexer_finished_p): New.\n+\t(cp_lexer_alloc): Factor out of cp_lexer_new_main.\n+\t(cp_lexer_new_main): Re-write main lexing loop to push\n+\ttokens into the new VEC buffer.\n+\t(cp_lexer_print_token): Improve printing of CPP_NUMBER tokens.\n+\tDo not abort if the token type is not recognized, just print\n+\tits code.\n+\t* parser.h: New file.\n+\t* config-lang.in (gtfiles): Add cp/parser.h.\n+\n 2011-03-16  Jason Merrill  <jason@redhat.com>\n \n \tCore 1148"}, {"sha": "d8bd90549191678df859ff8ff76c040c362f034b", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=f617201f55938fc89b532f2240bdf77bea946471", "patch": "@@ -243,15 +243,15 @@ CXX_TREE_H = $(TREE_H) cp/name-lookup.h cp/cp-tree.h $(C_COMMON_H) \\\n \t$(FUNCTION_H) \\\n \t$(SYSTEM_H) coretypes.h $(CONFIG_H) $(TARGET_H) $(GGC_H) \\\n \t$(srcdir)/../include/hashtab.h\n-\n+CXX_PARSER_H = tree.h c-family/c-pragma.h cp/parser.h\n CXX_PRETTY_PRINT_H = cp/cxx-pretty-print.h $(C_PRETTY_PRINT_H)\n \n cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n   $(C_PRAGMA_H) output.h input.h cp/operators.def $(TM_P_H) \\\n   c-family/c-objc.h\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) debug.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-cp.h gt-cp-cp-lang.h \\\n-  cp/cp-objcp-common.h $(EXPR_H) $(TARGET_H)\n+  cp/cp-objcp-common.h $(EXPR_H) $(TARGET_H) $(CXX_PARSER_H)\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h \\\n   output.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(C_PRAGMA_H) \\\n@@ -316,7 +316,7 @@ cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H) $(CGRAPH_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n   gt-cp-parser.h output.h $(TARGET_H) $(PLUGIN_H) intl.h \\\n-  c-family/c-objc.h\n+  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H)\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) $(C_COMMON_H) \\\n \t$(TM_H) coretypes.h pointer-set.h tree-iterator.h\n "}, {"sha": "13f2e9c82659ebf16666ca45ff1b6ee7b66cec84", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=f617201f55938fc89b532f2240bdf77bea946471", "patch": "@@ -30,4 +30,4 @@ compilers=\"cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3\"\n \n-gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/cp-lang.c\"\n+gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.h \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/cp-lang.c\""}, {"sha": "42fbdff40d45cd8b4365e50e094f28d68352d30d", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=f617201f55938fc89b532f2240bdf77bea946471", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-objcp-common.h\"\n #include \"hashtab.h\"\n #include \"target.h\"\n+#include \"parser.h\"\n \n enum c_language_kind c_language = clk_cxx;\n static void cp_init_ts (void);"}, {"sha": "c7347cfae2c4279ffda4a83a7db58482123d934f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 109, "deletions": 373, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f617201f55938fc89b532f2240bdf77bea946471", "patch": "@@ -37,117 +37,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-common.h\"\n #include \"c-family/c-objc.h\"\n #include \"plugin.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"parser.h\"\n \n \f\n /* The lexer.  */\n \n /* The cp_lexer_* routines mediate between the lexer proper (in libcpp\n    and c-lex.c) and the C++ parser.  */\n \n-/* A token's value and its associated deferred access checks and\n-   qualifying scope.  */\n-\n-struct GTY(()) tree_check {\n-  /* The value associated with the token.  */\n-  tree value;\n-  /* The checks that have been associated with value.  */\n-  VEC (deferred_access_check, gc)* checks;\n-  /* The token's qualifying scope (used when it is a\n-     CPP_NESTED_NAME_SPECIFIER).  */\n-  tree qualifying_scope;\n-};\n-\n-/* A C++ token.  */\n-\n-typedef struct GTY (()) cp_token {\n-  /* The kind of token.  */\n-  ENUM_BITFIELD (cpp_ttype) type : 8;\n-  /* If this token is a keyword, this value indicates which keyword.\n-     Otherwise, this value is RID_MAX.  */\n-  ENUM_BITFIELD (rid) keyword : 8;\n-  /* Token flags.  */\n-  unsigned char flags;\n-  /* Identifier for the pragma.  */\n-  ENUM_BITFIELD (pragma_kind) pragma_kind : 6;\n-  /* True if this token is from a context where it is implicitly extern \"C\" */\n-  BOOL_BITFIELD implicit_extern_c : 1;\n-  /* True for a CPP_NAME token that is not a keyword (i.e., for which\n-     KEYWORD is RID_MAX) iff this name was looked up and found to be\n-     ambiguous.  An error has already been reported.  */\n-  BOOL_BITFIELD ambiguous_p : 1;\n-  /* The location at which this token was found.  */\n-  location_t location;\n-  /* The value associated with this token, if any.  */\n-  union cp_token_value {\n-    /* Used for CPP_NESTED_NAME_SPECIFIER and CPP_TEMPLATE_ID.  */\n-    struct tree_check* GTY((tag (\"1\"))) tree_check_value;\n-    /* Use for all other tokens.  */\n-    tree GTY((tag (\"0\"))) value;\n-  } GTY((desc (\"(%1.type == CPP_TEMPLATE_ID) || (%1.type == CPP_NESTED_NAME_SPECIFIER)\"))) u;\n-} cp_token;\n-\n-/* We use a stack of token pointer for saving token sets.  */\n-typedef struct cp_token *cp_token_position;\n-DEF_VEC_P (cp_token_position);\n-DEF_VEC_ALLOC_P (cp_token_position,heap);\n-\n static cp_token eof_token =\n {\n-  CPP_EOF, RID_MAX, 0, PRAGMA_NONE, false, 0, 0, { NULL }\n+  CPP_EOF, RID_MAX, 0, PRAGMA_NONE, false, false, false, 0, { NULL }\n };\n \n-/* The cp_lexer structure represents the C++ lexer.  It is responsible\n-   for managing the token stream from the preprocessor and supplying\n-   it to the parser.  Tokens are never added to the cp_lexer after\n-   it is created.  */\n-\n-typedef struct GTY (()) cp_lexer {\n-  /* The memory allocated for the buffer.  NULL if this lexer does not\n-     own the token buffer.  */\n-  cp_token * GTY ((length (\"%h.buffer_length\"))) buffer;\n-  /* If the lexer owns the buffer, this is the number of tokens in the\n-     buffer.  */\n-  size_t buffer_length;\n-\n-  /* A pointer just past the last available token.  The tokens\n-     in this lexer are [buffer, last_token).  */\n-  cp_token_position GTY ((skip)) last_token;\n-\n-  /* The next available token.  If NEXT_TOKEN is &eof_token, then there are\n-     no more available tokens.  */\n-  cp_token_position GTY ((skip)) next_token;\n-\n-  /* A stack indicating positions at which cp_lexer_save_tokens was\n-     called.  The top entry is the most recent position at which we\n-     began saving tokens.  If the stack is non-empty, we are saving\n-     tokens.  */\n-  VEC(cp_token_position,heap) *GTY ((skip)) saved_tokens;\n-\n-  /* The next lexer in a linked list of lexers.  */\n-  struct cp_lexer *next;\n-\n-  /* True if we should output debugging information.  */\n-  bool debugging_p;\n-\n-  /* True if we're in the context of parsing a pragma, and should not\n-     increment past the end-of-line marker.  */\n-  bool in_pragma;\n-} cp_lexer;\n-\n-/* cp_token_cache is a range of tokens.  There is no need to represent\n-   allocate heap memory for it, since tokens are never removed from the\n-   lexer's array.  There is also no need for the GC to walk through\n-   a cp_token_cache, since everything in here is referenced through\n-   a lexer.  */\n-\n-typedef struct GTY(()) cp_token_cache {\n-  /* The beginning of the token range.  */\n-  cp_token * GTY((skip)) first;\n-\n-  /* Points immediately after the last token in the range.  */\n-  cp_token * GTY ((skip)) last;\n-} cp_token_cache;\n-\n /* The various kinds of non integral constant we encounter. */\n typedef enum non_integral_constant {\n   NIC_NONE,\n@@ -280,8 +183,6 @@ static void cp_lexer_destroy\n   (cp_lexer *);\n static int cp_lexer_saving_tokens\n   (const cp_lexer *);\n-static cp_token_position cp_lexer_token_position\n-  (cp_lexer *, bool);\n static cp_token *cp_lexer_token_at\n   (cp_lexer *, cp_token_position);\n static void cp_lexer_get_preprocessor_token\n@@ -337,30 +238,6 @@ static void cp_parser_initial_pragma\n #define CP_LEXER_BUFFER_SIZE ((256 * 1024) / sizeof (cp_token))\n #define CP_SAVED_TOKEN_STACK 5\n \n-/* A token type for keywords, as opposed to ordinary identifiers.  */\n-#define CPP_KEYWORD ((enum cpp_ttype) (N_TTYPES + 1))\n-\n-/* A token type for template-ids.  If a template-id is processed while\n-   parsing tentatively, it is replaced with a CPP_TEMPLATE_ID token;\n-   the value of the CPP_TEMPLATE_ID is whatever was returned by\n-   cp_parser_template_id.  */\n-#define CPP_TEMPLATE_ID ((enum cpp_ttype) (CPP_KEYWORD + 1))\n-\n-/* A token type for nested-name-specifiers.  If a\n-   nested-name-specifier is processed while parsing tentatively, it is\n-   replaced with a CPP_NESTED_NAME_SPECIFIER token; the value of the\n-   CPP_NESTED_NAME_SPECIFIER is whatever was returned by\n-   cp_parser_nested_name_specifier_opt.  */\n-#define CPP_NESTED_NAME_SPECIFIER ((enum cpp_ttype) (CPP_TEMPLATE_ID + 1))\n-\n-/* A token type for tokens that are not tokens at all; these are used\n-   to represent slots in the array where there used to be a token\n-   that has now been deleted.  */\n-#define CPP_PURGED ((enum cpp_ttype) (CPP_NESTED_NAME_SPECIFIER + 1))\n-\n-/* The number of token types, including C++-specific ones.  */\n-#define N_CP_TTYPES ((int) (CPP_PURGED + 1))\n-\n /* Variables.  */\n \n #ifdef ENABLE_CHECKING\n@@ -372,23 +249,65 @@ static FILE *cp_lexer_debug_stream;\n    sizeof, typeof, or alignof.  */\n int cp_unevaluated_operand;\n \n-/* Create a new main C++ lexer, the lexer that gets tokens from the\n-   preprocessor.  */\n+#ifdef ENABLE_CHECKING\n+/* Dump up to NUM tokens in BUFFER to FILE.  If NUM is 0, dump all the\n+   tokens.  */\n+\n+void\n+cp_lexer_dump_tokens (FILE *file, VEC(cp_token,gc) *buffer, unsigned num)\n+{\n+  unsigned i;\n+  cp_token *token;\n+\n+  fprintf (file, \"%u tokens\\n\", VEC_length (cp_token, buffer));\n+\n+  if (num == 0)\n+    num = VEC_length (cp_token, buffer);\n+\n+  for (i = 0; VEC_iterate (cp_token, buffer, i, token) && i < num; i++)\n+    {\n+      cp_lexer_print_token (file, token);\n+      switch (token->type)\n+\t{\n+\t  case CPP_SEMICOLON:\n+\t  case CPP_OPEN_BRACE:\n+\t  case CPP_CLOSE_BRACE:\n+\t  case CPP_EOF:\n+\t    fputc ('\\n', file);\n+\t    break;\n+\n+\t  default:\n+\t    fputc (' ', file);\n+\t}\n+    }\n+\n+  if (i == num && i < VEC_length (cp_token, buffer))\n+    {\n+      fprintf (file, \" ... \");\n+      cp_lexer_print_token (file, VEC_index (cp_token, buffer,\n+\t\t\t    VEC_length (cp_token, buffer) - 1));\n+    }\n+\n+  fprintf (file, \"\\n\");\n+}\n+\n+\n+/* Dump all tokens in BUFFER to stderr.  */\n+\n+void\n+cp_lexer_debug_tokens (VEC(cp_token,gc) *buffer)\n+{\n+  cp_lexer_dump_tokens (stderr, buffer, 0);\n+}\n+#endif\n+\n+\n+/* Allocate memory for a new lexer object and return it.  */\n \n static cp_lexer *\n-cp_lexer_new_main (void)\n+cp_lexer_alloc (void)\n {\n-  cp_token first_token;\n   cp_lexer *lexer;\n-  cp_token *pos;\n-  size_t alloc;\n-  size_t space;\n-  cp_token *buffer;\n-\n-  /* It's possible that parsing the first pragma will load a PCH file,\n-     which is a GC collection point.  So we have to do that before\n-     allocating any memory.  */\n-  cp_parser_initial_pragma (&first_token);\n \n   c_common_no_more_pch ();\n \n@@ -403,37 +322,50 @@ cp_lexer_new_main (void)\n \t\t\t\t   CP_SAVED_TOKEN_STACK);\n \n   /* Create the buffer.  */\n-  alloc = CP_LEXER_BUFFER_SIZE;\n-  buffer = ggc_alloc_vec_cp_token (alloc);\n+  lexer->buffer = VEC_alloc (cp_token, gc, CP_LEXER_BUFFER_SIZE);\n+\n+  return lexer;\n+}\n+\n+\n+/* Create a new main C++ lexer, the lexer that gets tokens from the\n+   preprocessor.  */\n+\n+static cp_lexer *\n+cp_lexer_new_main (void)\n+{\n+  cp_lexer *lexer;\n+  cp_token token;\n+\n+  /* It's possible that parsing the first pragma will load a PCH file,\n+     which is a GC collection point.  So we have to do that before\n+     allocating any memory.  */\n+  cp_parser_initial_pragma (&token);\n+\n+  lexer = cp_lexer_alloc ();\n \n   /* Put the first token in the buffer.  */\n-  space = alloc;\n-  pos = buffer;\n-  *pos = first_token;\n+  VEC_quick_push (cp_token, lexer->buffer, &token);\n \n   /* Get the remaining tokens from the preprocessor.  */\n-  while (pos->type != CPP_EOF)\n+  while (token.type != CPP_EOF)\n     {\n-      pos++;\n-      if (!--space)\n-\t{\n-\t  space = alloc;\n-\t  alloc *= 2;\n-\t  buffer = GGC_RESIZEVEC (cp_token, buffer, alloc);\n-\t  pos = buffer + space;\n-\t}\n-      cp_lexer_get_preprocessor_token (lexer, pos);\n+      cp_lexer_get_preprocessor_token (lexer, &token);\n+      VEC_safe_push (cp_token, gc, lexer->buffer, &token);\n     }\n-  lexer->buffer = buffer;\n-  lexer->buffer_length = alloc - space;\n-  lexer->last_token = pos;\n-  lexer->next_token = lexer->buffer_length ? buffer : &eof_token;\n+\n+  lexer->last_token = VEC_address (cp_token, lexer->buffer)\n+                      + VEC_length (cp_token, lexer->buffer)\n+\t\t      - 1;\n+  lexer->next_token = VEC_length (cp_token, lexer->buffer)\n+\t\t      ? VEC_address (cp_token, lexer->buffer)\n+\t\t      : &eof_token;\n \n   /* Subsequent preprocessor diagnostics should use compiler\n      diagnostic functions to get the compiler source location.  */\n   done_lexing = true;\n \n-  gcc_assert (lexer->next_token->type != CPP_PURGED);\n+  gcc_assert (!lexer->next_token->purged_p);\n   return lexer;\n }\n \n@@ -449,7 +381,6 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n \n   /* We do not own the buffer.  */\n   lexer->buffer = NULL;\n-  lexer->buffer_length = 0;\n   lexer->next_token = first == last ? &eof_token : first;\n   lexer->last_token = last;\n \n@@ -461,7 +392,7 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n   lexer->debugging_p = false;\n #endif\n \n-  gcc_assert (lexer->next_token->type != CPP_PURGED);\n+  gcc_assert (!lexer->next_token->purged_p);\n   return lexer;\n }\n \n@@ -470,8 +401,7 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n static void\n cp_lexer_destroy (cp_lexer *lexer)\n {\n-  if (lexer->buffer)\n-    ggc_free (lexer->buffer);\n+  VEC_free (cp_token, gc, lexer->buffer);\n   VEC_free (cp_token_position, heap, lexer->saved_tokens);\n   ggc_free (lexer);\n }\n@@ -549,6 +479,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n \t\t\tlexer == NULL ? 0 : C_LEX_STRING_NO_JOIN);\n   token->keyword = RID_MAX;\n   token->pragma_kind = PRAGMA_NONE;\n+  token->purged_p = false;\n \n   /* On some systems, some header files are surrounded by an\n      implicit extern \"C\" block.  Set a flag in the token if it\n@@ -760,7 +691,7 @@ cp_lexer_peek_nth_token (cp_lexer* lexer, size_t n)\n \t  break;\n \t}\n \n-      if (token->type != CPP_PURGED)\n+      if (!token->purged_p)\n \t--n;\n     }\n \n@@ -794,7 +725,7 @@ cp_lexer_consume_token (cp_lexer* lexer)\n \t}\n \n     }\n-  while (lexer->next_token->type == CPP_PURGED);\n+  while (lexer->next_token->purged_p);\n \n   cp_lexer_set_source_position_from_token (token);\n \n@@ -819,7 +750,7 @@ cp_lexer_purge_token (cp_lexer *lexer)\n   cp_token *tok = lexer->next_token;\n \n   gcc_assert (tok != &eof_token);\n-  tok->type = CPP_PURGED;\n+  tok->purged_p = true;\n   tok->location = UNKNOWN_LOCATION;\n   tok->u.value = NULL_TREE;\n   tok->keyword = RID_MAX;\n@@ -833,7 +764,7 @@ cp_lexer_purge_token (cp_lexer *lexer)\n \t  break;\n \t}\n     }\n-  while (tok->type == CPP_PURGED);\n+  while (tok->purged_p);\n   lexer->next_token = tok;\n }\n \n@@ -853,7 +784,7 @@ cp_lexer_purge_tokens_after (cp_lexer *lexer, cp_token *tok)\n \n   for ( tok += 1; tok != peek; tok += 1)\n     {\n-      tok->type = CPP_PURGED;\n+      tok->purged_p = true;\n       tok->location = UNKNOWN_LOCATION;\n       tok->u.value = NULL_TREE;\n       tok->keyword = RID_MAX;\n@@ -919,14 +850,8 @@ cp_lexer_print_token (FILE * stream, cp_token *token)\n     \"KEYWORD\",\n     \"TEMPLATE_ID\",\n     \"NESTED_NAME_SPECIFIER\",\n-    \"PURGED\"\n   };\n \n-  /* If we have a name for the token, print it out.  Otherwise, we\n-     simply give the numeric code.  */\n-  gcc_assert (token->type < ARRAY_SIZE(token_names));\n-  fputs (token_names[token->type], stream);\n-\n   /* For some tokens, print the associated data.  */\n   switch (token->type)\n     {\n@@ -948,7 +873,17 @@ cp_lexer_print_token (FILE * stream, cp_token *token)\n       fprintf (stream, \" \\\"%s\\\"\", TREE_STRING_POINTER (token->u.value));\n       break;\n \n+    case CPP_NUMBER:\n+      print_generic_expr (stream, token->u.value, 0);\n+      break;\n+\n     default:\n+      /* If we have a name for the token, print it out.  Otherwise, we\n+\t simply give the numeric code.  */\n+      if (token->type < ARRAY_SIZE(token_names))\n+\tfputs (token_names[token->type], stream);\n+      else\n+\tfprintf (stream, \"[%d]\", token->type);\n       break;\n     }\n }\n@@ -1413,19 +1348,6 @@ typedef struct cp_parser_binary_operations_map_node\n   enum cp_parser_prec prec;\n } cp_parser_binary_operations_map_node;\n \n-/* The status of a tentative parse.  */\n-\n-typedef enum cp_parser_status_kind\n-{\n-  /* No errors have occurred.  */\n-  CP_PARSER_STATUS_KIND_NO_ERROR,\n-  /* An error has occurred.  */\n-  CP_PARSER_STATUS_KIND_ERROR,\n-  /* We are committed to this tentative parse, whether or not an error\n-     has occurred.  */\n-  CP_PARSER_STATUS_KIND_COMMITTED\n-} cp_parser_status_kind;\n-\n typedef struct cp_parser_expression_stack_entry\n {\n   /* Left hand side of the binary operation we are currently\n@@ -1446,21 +1368,6 @@ typedef struct cp_parser_expression_stack_entry\n typedef struct cp_parser_expression_stack_entry\n   cp_parser_expression_stack[NUM_PREC_VALUES];\n \n-/* Context that is saved and restored when parsing tentatively.  */\n-typedef struct GTY (()) cp_parser_context {\n-  /* If this is a tentative parsing context, the status of the\n-     tentative parse.  */\n-  enum cp_parser_status_kind status;\n-  /* If non-NULL, we have just seen a `x->' or `x.' expression.  Names\n-     that are looked up in this context must be looked up both in the\n-     scope given by OBJECT_TYPE (the type of `x' or `*x') and also in\n-     the context of the containing expression.  */\n-  tree object_type;\n-\n-  /* The next parsing context in the stack.  */\n-  struct cp_parser_context *next;\n-} cp_parser_context;\n-\n /* Prototypes.  */\n \n /* Constructors and destructors.  */\n@@ -1551,177 +1458,6 @@ cp_parser_context_new (cp_parser_context* next)\n   return context;\n }\n \n-/* An entry in a queue of function arguments that require post-processing.  */\n-\n-typedef struct GTY(()) cp_default_arg_entry_d {\n-  /* The current_class_type when we parsed this arg.  */\n-  tree class_type;\n-\n-  /* The function decl itself.  */\n-  tree decl;\n-} cp_default_arg_entry;\n-\n-DEF_VEC_O(cp_default_arg_entry);\n-DEF_VEC_ALLOC_O(cp_default_arg_entry,gc);\n-\n-/* An entry in a stack for member functions of local classes.  */\n-\n-typedef struct GTY(()) cp_unparsed_functions_entry_d {\n-  /* Functions with default arguments that require post-processing.\n-     Functions appear in this list in declaration order.  */\n-  VEC(cp_default_arg_entry,gc) *funs_with_default_args;\n-\n-  /* Functions with defintions that require post-processing.  Functions\n-     appear in this list in declaration order.  */\n-  VEC(tree,gc) *funs_with_definitions;\n-} cp_unparsed_functions_entry;\n-\n-DEF_VEC_O(cp_unparsed_functions_entry);\n-DEF_VEC_ALLOC_O(cp_unparsed_functions_entry,gc);\n-\n-/* The cp_parser structure represents the C++ parser.  */\n-\n-typedef struct GTY(()) cp_parser {\n-  /* The lexer from which we are obtaining tokens.  */\n-  cp_lexer *lexer;\n-\n-  /* The scope in which names should be looked up.  If NULL_TREE, then\n-     we look up names in the scope that is currently open in the\n-     source program.  If non-NULL, this is either a TYPE or\n-     NAMESPACE_DECL for the scope in which we should look.  It can\n-     also be ERROR_MARK, when we've parsed a bogus scope.\n-\n-     This value is not cleared automatically after a name is looked\n-     up, so we must be careful to clear it before starting a new look\n-     up sequence.  (If it is not cleared, then `X::Y' followed by `Z'\n-     will look up `Z' in the scope of `X', rather than the current\n-     scope.)  Unfortunately, it is difficult to tell when name lookup\n-     is complete, because we sometimes peek at a token, look it up,\n-     and then decide not to consume it.   */\n-  tree scope;\n-\n-  /* OBJECT_SCOPE and QUALIFYING_SCOPE give the scopes in which the\n-     last lookup took place.  OBJECT_SCOPE is used if an expression\n-     like \"x->y\" or \"x.y\" was used; it gives the type of \"*x\" or \"x\",\n-     respectively.  QUALIFYING_SCOPE is used for an expression of the\n-     form \"X::Y\"; it refers to X.  */\n-  tree object_scope;\n-  tree qualifying_scope;\n-\n-  /* A stack of parsing contexts.  All but the bottom entry on the\n-     stack will be tentative contexts.\n-\n-     We parse tentatively in order to determine which construct is in\n-     use in some situations.  For example, in order to determine\n-     whether a statement is an expression-statement or a\n-     declaration-statement we parse it tentatively as a\n-     declaration-statement.  If that fails, we then reparse the same\n-     token stream as an expression-statement.  */\n-  cp_parser_context *context;\n-\n-  /* True if we are parsing GNU C++.  If this flag is not set, then\n-     GNU extensions are not recognized.  */\n-  bool allow_gnu_extensions_p;\n-\n-  /* TRUE if the `>' token should be interpreted as the greater-than\n-     operator.  FALSE if it is the end of a template-id or\n-     template-parameter-list. In C++0x mode, this flag also applies to\n-     `>>' tokens, which are viewed as two consecutive `>' tokens when\n-     this flag is FALSE.  */\n-  bool greater_than_is_operator_p;\n-\n-  /* TRUE if default arguments are allowed within a parameter list\n-     that starts at this point. FALSE if only a gnu extension makes\n-     them permissible.  */\n-  bool default_arg_ok_p;\n-\n-  /* TRUE if we are parsing an integral constant-expression.  See\n-     [expr.const] for a precise definition.  */\n-  bool integral_constant_expression_p;\n-\n-  /* TRUE if we are parsing an integral constant-expression -- but a\n-     non-constant expression should be permitted as well.  This flag\n-     is used when parsing an array bound so that GNU variable-length\n-     arrays are tolerated.  */\n-  bool allow_non_integral_constant_expression_p;\n-\n-  /* TRUE if ALLOW_NON_CONSTANT_EXPRESSION_P is TRUE and something has\n-     been seen that makes the expression non-constant.  */\n-  bool non_integral_constant_expression_p;\n-\n-  /* TRUE if local variable names and `this' are forbidden in the\n-     current context.  */\n-  bool local_variables_forbidden_p;\n-\n-  /* TRUE if the declaration we are parsing is part of a\n-     linkage-specification of the form `extern string-literal\n-     declaration'.  */\n-  bool in_unbraced_linkage_specification_p;\n-\n-  /* TRUE if we are presently parsing a declarator, after the\n-     direct-declarator.  */\n-  bool in_declarator_p;\n-\n-  /* TRUE if we are presently parsing a template-argument-list.  */\n-  bool in_template_argument_list_p;\n-\n-  /* Set to IN_ITERATION_STMT if parsing an iteration-statement,\n-     to IN_OMP_BLOCK if parsing OpenMP structured block and\n-     IN_OMP_FOR if parsing OpenMP loop.  If parsing a switch statement,\n-     this is bitwise ORed with IN_SWITCH_STMT, unless parsing an\n-     iteration-statement, OpenMP block or loop within that switch.  */\n-#define IN_SWITCH_STMT\t\t1\n-#define IN_ITERATION_STMT\t2\n-#define IN_OMP_BLOCK\t\t4\n-#define IN_OMP_FOR\t\t8\n-#define IN_IF_STMT             16\n-  unsigned char in_statement;\n-\n-  /* TRUE if we are presently parsing the body of a switch statement.\n-     Note that this doesn't quite overlap with in_statement above.\n-     The difference relates to giving the right sets of error messages:\n-     \"case not in switch\" vs \"break statement used with OpenMP...\".  */\n-  bool in_switch_statement_p;\n-\n-  /* TRUE if we are parsing a type-id in an expression context.  In\n-     such a situation, both \"type (expr)\" and \"type (type)\" are valid\n-     alternatives.  */\n-  bool in_type_id_in_expr_p;\n-\n-  /* TRUE if we are currently in a header file where declarations are\n-     implicitly extern \"C\".  */\n-  bool implicit_extern_c;\n-\n-  /* TRUE if strings in expressions should be translated to the execution\n-     character set.  */\n-  bool translate_strings_p;\n-\n-  /* TRUE if we are presently parsing the body of a function, but not\n-     a local class.  */\n-  bool in_function_body;\n-\n-  /* TRUE if we can auto-correct a colon to a scope operator.  */\n-  bool colon_corrects_to_scope_p;\n-\n-  /* If non-NULL, then we are parsing a construct where new type\n-     definitions are not permitted.  The string stored here will be\n-     issued as an error message if a type is defined.  */\n-  const char *type_definition_forbidden_message;\n-\n-  /* A stack used for member functions of local classes.  The lists\n-     contained in an individual entry can only be processed once the\n-     outermost class being defined is complete.  */\n-  VEC(cp_unparsed_functions_entry,gc) *unparsed_queues;\n-\n-  /* The number of classes whose definitions are currently in\n-     progress.  */\n-  unsigned num_classes_being_defined;\n-\n-  /* The number of template parameter lists that apply directly to the\n-     current declaration.  */\n-  unsigned num_template_parameter_lists;\n-} cp_parser;\n-\n /* Managing the unparsed function queues.  */\n \n #define unparsed_funs_with_default_args \\"}, {"sha": "31ff0d9f2b979197d4fe7b890874c92f438eadd8", "filename": "gcc/cp/parser.h", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=f617201f55938fc89b532f2240bdf77bea946471", "patch": "@@ -0,0 +1,375 @@\n+/* Data structures and function exported by the C++ Parser.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CP_PARSER_H\n+#define GCC_CP_PARSER_H\n+\n+#include \"tree.h\"\n+#include \"c-family/c-pragma.h\"\n+\n+/* A token type for keywords, as opposed to ordinary identifiers.  */\n+#define CPP_KEYWORD ((enum cpp_ttype) (N_TTYPES + 1))\n+\n+/* A token type for template-ids.  If a template-id is processed while\n+   parsing tentatively, it is replaced with a CPP_TEMPLATE_ID token;\n+   the value of the CPP_TEMPLATE_ID is whatever was returned by\n+   cp_parser_template_id.  */\n+#define CPP_TEMPLATE_ID ((enum cpp_ttype) (CPP_KEYWORD + 1))\n+\n+/* A token type for nested-name-specifiers.  If a\n+   nested-name-specifier is processed while parsing tentatively, it is\n+   replaced with a CPP_NESTED_NAME_SPECIFIER token; the value of the\n+   CPP_NESTED_NAME_SPECIFIER is whatever was returned by\n+   cp_parser_nested_name_specifier_opt.  */\n+#define CPP_NESTED_NAME_SPECIFIER ((enum cpp_ttype) (CPP_TEMPLATE_ID + 1))\n+\n+/* The number of token types, including C++-specific ones.  */\n+#define N_CP_TTYPES ((int) (CPP_NESTED_NAME_SPECIFIER + 1))\n+\n+/* A token's value and its associated deferred access checks and\n+   qualifying scope.  */\n+\n+struct GTY(()) tree_check {\n+  /* The value associated with the token.  */\n+  tree value;\n+  /* The checks that have been associated with value.  */\n+  VEC (deferred_access_check, gc)* checks;\n+  /* The token's qualifying scope (used when it is a\n+     CPP_NESTED_NAME_SPECIFIER).  */\n+  tree qualifying_scope;\n+};\n+\n+/* A C++ token.  */\n+\n+typedef struct GTY (()) cp_token {\n+  /* The kind of token.  */\n+  ENUM_BITFIELD (cpp_ttype) type : 8;\n+  /* If this token is a keyword, this value indicates which keyword.\n+     Otherwise, this value is RID_MAX.  */\n+  ENUM_BITFIELD (rid) keyword : 8;\n+  /* Token flags.  */\n+  unsigned char flags;\n+  /* Identifier for the pragma.  */\n+  ENUM_BITFIELD (pragma_kind) pragma_kind : 6;\n+  /* True if this token is from a context where it is implicitly extern \"C\" */\n+  BOOL_BITFIELD implicit_extern_c : 1;\n+  /* True for a CPP_NAME token that is not a keyword (i.e., for which\n+     KEYWORD is RID_MAX) iff this name was looked up and found to be\n+     ambiguous.  An error has already been reported.  */\n+  BOOL_BITFIELD ambiguous_p : 1;\n+  /* True for a token that has been purged.  If a token is purged,\n+     it is no longer a valid token and it should be considered\n+     deleted.  */\n+  BOOL_BITFIELD purged_p : 1;\n+  /* The location at which this token was found.  */\n+  location_t location;\n+  /* The value associated with this token, if any.  */\n+  union cp_token_value {\n+    /* Used for CPP_NESTED_NAME_SPECIFIER and CPP_TEMPLATE_ID.  */\n+    struct tree_check* GTY((tag (\"1\"))) tree_check_value;\n+    /* Use for all other tokens.  */\n+    tree GTY((tag (\"0\"))) value;\n+  } GTY((desc (\"(%1.type == CPP_TEMPLATE_ID) || (%1.type == CPP_NESTED_NAME_SPECIFIER)\"))) u;\n+} cp_token;\n+\n+DEF_VEC_O (cp_token);\n+DEF_VEC_ALLOC_O (cp_token,gc);\n+DEF_VEC_ALLOC_O (cp_token,heap);\n+\n+/* We use a stack of token pointer for saving token sets.  */\n+typedef struct cp_token *cp_token_position;\n+DEF_VEC_P (cp_token_position);\n+DEF_VEC_ALLOC_P (cp_token_position,heap);\n+\n+/* The cp_lexer structure represents the C++ lexer.  It is responsible\n+   for managing the token stream from the preprocessor and supplying\n+   it to the parser.  Tokens are never added to the cp_lexer after\n+   it is created.  */\n+\n+typedef struct GTY (()) cp_lexer {\n+  /* The memory allocated for the buffer.  NULL if this lexer does not\n+     own the token buffer.  */\n+  VEC(cp_token,gc) *buffer;\n+\n+  /* A pointer just past the last available token.  The tokens\n+     in this lexer are [buffer, last_token).  */\n+  cp_token_position GTY ((skip)) last_token;\n+\n+  /* The next available token.  If NEXT_TOKEN is &eof_token, then there are\n+     no more available tokens.  */\n+  cp_token_position GTY ((skip)) next_token;\n+\n+  /* A stack indicating positions at which cp_lexer_save_tokens was\n+     called.  The top entry is the most recent position at which we\n+     began saving tokens.  If the stack is non-empty, we are saving\n+     tokens.  */\n+  VEC(cp_token_position,heap) *GTY ((skip)) saved_tokens;\n+\n+  /* The next lexer in a linked list of lexers.  */\n+  struct cp_lexer *next;\n+\n+  /* True if we should output debugging information.  */\n+  bool debugging_p;\n+\n+  /* True if we're in the context of parsing a pragma, and should not\n+     increment past the end-of-line marker.  */\n+  bool in_pragma;\n+} cp_lexer;\n+\n+DEF_VEC_O (cp_lexer);\n+DEF_VEC_ALLOC_O (cp_lexer,heap);\n+\n+/* cp_token_cache is a range of tokens.  There is no need to represent\n+   allocate heap memory for it, since tokens are never removed from the\n+   lexer's array.  There is also no need for the GC to walk through\n+   a cp_token_cache, since everything in here is referenced through\n+   a lexer.  */\n+\n+typedef struct GTY(()) cp_token_cache {\n+  /* The beginning of the token range.  */\n+  cp_token * GTY((skip)) first;\n+\n+  /* Points immediately after the last token in the range.  */\n+  cp_token * GTY ((skip)) last;\n+} cp_token_cache;\n+\n+typedef cp_token_cache *cp_token_cache_ptr;\n+DEF_VEC_P (cp_token_cache_ptr);\n+DEF_VEC_ALLOC_P (cp_token_cache_ptr,gc);\n+\n+struct cp_token_ident_d\n+{\n+  unsigned int ident_len;\n+  const char *ident_str;\n+  unsigned int before_len;\n+  const char *before_str;\n+  unsigned int after_len;\n+  const char *after_str;\n+};\n+\n+typedef struct cp_token_ident_d cp_token_ident;\n+\n+/* An entry in a queue of function arguments that require post-processing.  */\n+\n+typedef struct GTY(()) cp_default_arg_entry_d {\n+  /* The current_class_type when we parsed this arg.  */\n+  tree class_type;\n+\n+  /* The function decl itself.  */\n+  tree decl;\n+} cp_default_arg_entry;\n+\n+DEF_VEC_O(cp_default_arg_entry);\n+DEF_VEC_ALLOC_O(cp_default_arg_entry,gc);\n+\n+/* An entry in a stack for member functions of local classes.  */\n+\n+typedef struct GTY(()) cp_unparsed_functions_entry_d {\n+  /* Functions with default arguments that require post-processing.\n+     Functions appear in this list in declaration order.  */\n+  VEC(cp_default_arg_entry,gc) *funs_with_default_args;\n+\n+  /* Functions with defintions that require post-processing.  Functions\n+     appear in this list in declaration order.  */\n+  VEC(tree,gc) *funs_with_definitions;\n+} cp_unparsed_functions_entry;\n+\n+DEF_VEC_O(cp_unparsed_functions_entry);\n+DEF_VEC_ALLOC_O(cp_unparsed_functions_entry,gc);\n+\n+/* The status of a tentative parse.  */\n+\n+typedef enum cp_parser_status_kind\n+{\n+  /* No errors have occurred.  */\n+  CP_PARSER_STATUS_KIND_NO_ERROR,\n+  /* An error has occurred.  */\n+  CP_PARSER_STATUS_KIND_ERROR,\n+  /* We are committed to this tentative parse, whether or not an error\n+     has occurred.  */\n+  CP_PARSER_STATUS_KIND_COMMITTED\n+} cp_parser_status_kind;\n+\n+\n+/* Context that is saved and restored when parsing tentatively.  */\n+typedef struct GTY (()) cp_parser_context {\n+  /* If this is a tentative parsing context, the status of the\n+     tentative parse.  */\n+  enum cp_parser_status_kind status;\n+  /* If non-NULL, we have just seen a `x->' or `x.' expression.  Names\n+     that are looked up in this context must be looked up both in the\n+     scope given by OBJECT_TYPE (the type of `x' or `*x') and also in\n+     the context of the containing expression.  */\n+  tree object_type;\n+\n+  /* The next parsing context in the stack.  */\n+  struct cp_parser_context *next;\n+} cp_parser_context;\n+\n+\n+/* The cp_parser structure represents the C++ parser.  */\n+\n+typedef struct GTY(()) cp_parser {\n+  /* The lexer from which we are obtaining tokens.  */\n+  cp_lexer *lexer;\n+\n+  /* The scope in which names should be looked up.  If NULL_TREE, then\n+     we look up names in the scope that is currently open in the\n+     source program.  If non-NULL, this is either a TYPE or\n+     NAMESPACE_DECL for the scope in which we should look.  It can\n+     also be ERROR_MARK, when we've parsed a bogus scope.\n+\n+     This value is not cleared automatically after a name is looked\n+     up, so we must be careful to clear it before starting a new look\n+     up sequence.  (If it is not cleared, then `X::Y' followed by `Z'\n+     will look up `Z' in the scope of `X', rather than the current\n+     scope.)  Unfortunately, it is difficult to tell when name lookup\n+     is complete, because we sometimes peek at a token, look it up,\n+     and then decide not to consume it.   */\n+  tree scope;\n+\n+  /* OBJECT_SCOPE and QUALIFYING_SCOPE give the scopes in which the\n+     last lookup took place.  OBJECT_SCOPE is used if an expression\n+     like \"x->y\" or \"x.y\" was used; it gives the type of \"*x\" or \"x\",\n+     respectively.  QUALIFYING_SCOPE is used for an expression of the\n+     form \"X::Y\"; it refers to X.  */\n+  tree object_scope;\n+  tree qualifying_scope;\n+\n+  /* A stack of parsing contexts.  All but the bottom entry on the\n+     stack will be tentative contexts.\n+\n+     We parse tentatively in order to determine which construct is in\n+     use in some situations.  For example, in order to determine\n+     whether a statement is an expression-statement or a\n+     declaration-statement we parse it tentatively as a\n+     declaration-statement.  If that fails, we then reparse the same\n+     token stream as an expression-statement.  */\n+  cp_parser_context *context;\n+\n+  /* True if we are parsing GNU C++.  If this flag is not set, then\n+     GNU extensions are not recognized.  */\n+  bool allow_gnu_extensions_p;\n+\n+  /* TRUE if the `>' token should be interpreted as the greater-than\n+     operator.  FALSE if it is the end of a template-id or\n+     template-parameter-list. In C++0x mode, this flag also applies to\n+     `>>' tokens, which are viewed as two consecutive `>' tokens when\n+     this flag is FALSE.  */\n+  bool greater_than_is_operator_p;\n+\n+  /* TRUE if default arguments are allowed within a parameter list\n+     that starts at this point. FALSE if only a gnu extension makes\n+     them permissible.  */\n+  bool default_arg_ok_p;\n+\n+  /* TRUE if we are parsing an integral constant-expression.  See\n+     [expr.const] for a precise definition.  */\n+  bool integral_constant_expression_p;\n+\n+  /* TRUE if we are parsing an integral constant-expression -- but a\n+     non-constant expression should be permitted as well.  This flag\n+     is used when parsing an array bound so that GNU variable-length\n+     arrays are tolerated.  */\n+  bool allow_non_integral_constant_expression_p;\n+\n+  /* TRUE if ALLOW_NON_CONSTANT_EXPRESSION_P is TRUE and something has\n+     been seen that makes the expression non-constant.  */\n+  bool non_integral_constant_expression_p;\n+\n+  /* TRUE if local variable names and `this' are forbidden in the\n+     current context.  */\n+  bool local_variables_forbidden_p;\n+\n+  /* TRUE if the declaration we are parsing is part of a\n+     linkage-specification of the form `extern string-literal\n+     declaration'.  */\n+  bool in_unbraced_linkage_specification_p;\n+\n+  /* TRUE if we are presently parsing a declarator, after the\n+     direct-declarator.  */\n+  bool in_declarator_p;\n+\n+  /* TRUE if we are presently parsing a template-argument-list.  */\n+  bool in_template_argument_list_p;\n+\n+  /* Set to IN_ITERATION_STMT if parsing an iteration-statement,\n+     to IN_OMP_BLOCK if parsing OpenMP structured block and\n+     IN_OMP_FOR if parsing OpenMP loop.  If parsing a switch statement,\n+     this is bitwise ORed with IN_SWITCH_STMT, unless parsing an\n+     iteration-statement, OpenMP block or loop within that switch.  */\n+#define IN_SWITCH_STMT\t\t1\n+#define IN_ITERATION_STMT\t2\n+#define IN_OMP_BLOCK\t\t4\n+#define IN_OMP_FOR\t\t8\n+#define IN_IF_STMT             16\n+  unsigned char in_statement;\n+\n+  /* TRUE if we are presently parsing the body of a switch statement.\n+     Note that this doesn't quite overlap with in_statement above.\n+     The difference relates to giving the right sets of error messages:\n+     \"case not in switch\" vs \"break statement used with OpenMP...\".  */\n+  bool in_switch_statement_p;\n+\n+  /* TRUE if we are parsing a type-id in an expression context.  In\n+     such a situation, both \"type (expr)\" and \"type (type)\" are valid\n+     alternatives.  */\n+  bool in_type_id_in_expr_p;\n+\n+  /* TRUE if we are currently in a header file where declarations are\n+     implicitly extern \"C\".  */\n+  bool implicit_extern_c;\n+\n+  /* TRUE if strings in expressions should be translated to the execution\n+     character set.  */\n+  bool translate_strings_p;\n+\n+  /* TRUE if we are presently parsing the body of a function, but not\n+     a local class.  */\n+  bool in_function_body;\n+\n+  /* TRUE if we can auto-correct a colon to a scope operator.  */\n+  bool colon_corrects_to_scope_p;\n+\n+  /* If non-NULL, then we are parsing a construct where new type\n+     definitions are not permitted.  The string stored here will be\n+     issued as an error message if a type is defined.  */\n+  const char *type_definition_forbidden_message;\n+\n+  /* A stack used for member functions of local classes.  The lists\n+     contained in an individual entry can only be processed once the\n+     outermost class being defined is complete.  */\n+  VEC(cp_unparsed_functions_entry,gc) *unparsed_queues;\n+\n+  /* The number of classes whose definitions are currently in\n+     progress.  */\n+  unsigned num_classes_being_defined;\n+\n+  /* The number of template parameter lists that apply directly to the\n+     current declaration.  */\n+  unsigned num_template_parameter_lists;\n+} cp_parser;\n+\n+/* In parser.c  */\n+#ifdef ENABLE_CHECKING\n+extern void cp_lexer_dump_tokens (FILE *, VEC(cp_token,gc) *, unsigned);\n+extern void cp_lexer_debug_tokens (VEC(cp_token,gc) *);\n+#endif\n+\n+#endif  /* GCC_CP_PARSER_H  */"}]}