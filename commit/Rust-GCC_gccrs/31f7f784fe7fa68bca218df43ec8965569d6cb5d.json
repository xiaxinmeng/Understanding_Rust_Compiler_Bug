{"sha": "31f7f784fe7fa68bca218df43ec8965569d6cb5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFmN2Y3ODRmZTdmYTY4YmNhMjE4ZGY0M2VjODk2NTU2OWQ2Y2I1ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-11-02T01:50:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-11-02T01:50:29Z"}, "message": "Implement P0136R1, Rewording inheriting constructors.\n\ngcc/c-family/\n\t* c.opt (-fnew-inheriting-ctors): New.\n\t* c-opts.c: Default to on for ABI 11+.\ngcc/cp/\n\t* call.c (enum rejection_reason_code): Add rr_inherited_ctor.\n\t(inherited_ctor_rejection): New.\n\t(add_function_candidate): Reject inherited ctors for copying.\n\t(enforce_access): Use strip_inheriting_ctors.\n\t(print_z_candidate): Likewise.  Handle rr_inherited_ctor.\n\t(convert_like_real): Avoid copying inheriting ctor parameters.\n\t(build_over_call): Likewise.  A base ctor inheriting from vbase\n\thas no parms.  Sorry about varargs.\n\t(joust): A local constructor beats inherited with the same convs.\n\t* class.c (add_method): Handle hiding inheriting ctors.\n\t(one_inherited_ctor): Handle new semantics.\n\t(add_implicitly_declared_members): Pass using_decl down.\n\t(build_clone): A base ctor inheriting from vbase has no parms.\n\t* cp-tree.h (DECL_INHERITED_CTOR): Store this instead of the base.\n\t(SET_DECL_INHERITED_CTOR): Likewise.\n\t(DECL_INHERITED_CTOR_BASE): Adjust.\n\t* constexpr.c: Adjust.\n\t* error.c (dump_function_decl): Decorate inheriting ctors.\n\t* init.c (emit_mem_initializers): Suppress access control in\n\tinheriting ctor.\n\t* mangle.c (write_special_name_constructor): Handle new inheriting\n\tctor mangling.\n\t* method.c (strip_inheriting_ctors, inherited_ctor_binfo)\n\t(ctor_omit_inherited_parms, binfo_inherited_from): New.\n\t(synthesized_method_walk): Use binfo_inherited_from.  Suppress\n\taccess control in inheriting ctor.\n\t(deduce_inheriting_ctor): Deleted if ambiguous ctor inheritance.\n\t(maybe_explain_implicit_delete): Explain ambigous ctor inheritance.\n\t(add_one_base_init, do_build_copy_constructor): Adjust.\n\t(locate_fn_flags, explain_implicit_non_constexpr): Adjust.\n\t(implicitly_declare_fn): Adjust.\n\t(get_inherited_ctor): Remove.\n\t* name-lookup.c (do_class_using_decl): Check for indirect ctor\n\tinheritance.\n\t* optimize.c (cdtor_comdat_group): Adjust for new mangling.\n\t(maybe_clone_body): Handle omitted parms in base clone.\n\t(maybe_thunk_body): Don't thunk if base clone omits parms.\n\t* pt.c (tsubst_decl): Adjust.\n\t(instantiate_template_1): Suppress access control in inheriting\n\tctor.\n\t(fn_type_unification): Do deduction with inherited ctor.\n\t* tree.c (special_function_p): Adjust.\ngcc/\n\t* tree-inline.c (copy_tree_body_r): Only copy the taken branch of\n\ta COND_EXPR with constant condition.\nlibiberty/\n\t* cp-demangle.c (d_ctor_dtor_name): Handle inheriting constructor.\n\nFrom-SVN: r241765", "tree": {"sha": "1dffc88ff5b0ae93ef01f8ea3bba2713ee747362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dffc88ff5b0ae93ef01f8ea3bba2713ee747362"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31f7f784fe7fa68bca218df43ec8965569d6cb5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f7f784fe7fa68bca218df43ec8965569d6cb5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31f7f784fe7fa68bca218df43ec8965569d6cb5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f7f784fe7fa68bca218df43ec8965569d6cb5d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "be9f7afb32b8cf2dfb6d08f86804b6eabd30c838", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be9f7afb32b8cf2dfb6d08f86804b6eabd30c838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be9f7afb32b8cf2dfb6d08f86804b6eabd30c838"}], "stats": {"total": 1034, "additions": 937, "deletions": 97}, "files": [{"sha": "3a7b71dea6a6362067028352117f63a342cb67d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1,3 +1,8 @@\n+2016-11-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree-inline.c (copy_tree_body_r): Only copy the taken branch of\n+\ta COND_EXPR with constant condition.\n+\n 2016-11-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (gen_variable_die): Remove again origin_die variable"}, {"sha": "efec6e167380b002f4f792259b3383c430ebe4eb", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1,3 +1,8 @@\n+2016-11-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* c.opt (-fnew-inheriting-ctors): New.\n+\t* c-opts.c: Default to on for ABI 11+.\n+\n 2016-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/77948"}, {"sha": "de260e7dcee8dc91cd251765cc893e764a6295a0", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -902,6 +902,12 @@ c_common_post_options (const char **pfilename)\n   if (flag_abi_version == 0)\n     flag_abi_version = 11;\n \n+  /* By default, enable the new inheriting constructor semantics along with ABI\n+     11.  New and old should coexist fine, but it is a change in what\n+     artificial symbols are generated.  */\n+  if (!global_options_set.x_flag_new_inheriting_ctors)\n+    flag_new_inheriting_ctors = abi_version_at_least (11);\n+\n   if (cxx_dialect >= cxx11)\n     {\n       /* If we're allowing C++0x constructs, don't warn about C++98"}, {"sha": "7d8a7265752b04be4ad4b40d3637f2d394212bc9", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1362,6 +1362,10 @@ fimplicit-templates\n C++ ObjC++ Var(flag_implicit_templates) Init(1)\n Emit implicit instantiations of templates.\n \n+fnew-inheriting-ctors\n+C++ ObjC++ Var(flag_new_inheriting_ctors) Init(1)\n+Implement C++17 inheriting constructor semantics.\n+\n ffriend-injection\n C++ ObjC++ Var(flag_friend_injection)\n Inject friend functions into enclosing namespace."}, {"sha": "097cae660de451de59cc8adc2b5e62d9e242ddba", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -907,7 +907,8 @@ Driver Undocumented\n ;     identity, such as ia32 calling convention attributes (stdcall, etc.)\n ;     Default in G++ 6 (set in c_common_post_options).\n ;\n-; 11: The version of the ABI that corrects mangling of sizeof... expressions.\n+; 11: The version of the ABI that corrects mangling of sizeof... expressions\n+;     and introduces new inheriting constructor handling.\n ;     Default in G++ 7.\n ;\n ; Additional positive integers will be assigned as new versions of"}, {"sha": "5eabdc2c8866593a2ea26cbd89f437630863775d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1,3 +1,49 @@\n+2016-11-01  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0136R1, Rewording inheriting constructors.\n+\t* call.c (enum rejection_reason_code): Add rr_inherited_ctor.\n+\t(inherited_ctor_rejection): New.\n+\t(add_function_candidate): Reject inherited ctors for copying.\n+\t(enforce_access): Use strip_inheriting_ctors.\n+\t(print_z_candidate): Likewise.  Handle rr_inherited_ctor.\n+\t(convert_like_real): Avoid copying inheriting ctor parameters.\n+\t(build_over_call): Likewise.  A base ctor inheriting from vbase\n+\thas no parms.  Sorry about varargs.\n+\t(joust): A local constructor beats inherited with the same convs.\n+\t* class.c (add_method): Handle hiding inheriting ctors.\n+\t(one_inherited_ctor): Handle new semantics.\n+\t(add_implicitly_declared_members): Pass using_decl down.\n+\t(build_clone): A base ctor inheriting from vbase has no parms.\n+\t* cp-tree.h (DECL_INHERITED_CTOR): Store this instead of the base.\n+\t(SET_DECL_INHERITED_CTOR): Likewise.\n+\t(DECL_INHERITED_CTOR_BASE): Adjust.\n+\t* constexpr.c: Adjust.\n+\t* error.c (dump_function_decl): Decorate inheriting ctors.\n+\t* init.c (emit_mem_initializers): Suppress access control in\n+\tinheriting ctor.\n+\t* mangle.c (write_special_name_constructor): Handle new inheriting\n+\tctor mangling.\n+\t* method.c (strip_inheriting_ctors, inherited_ctor_binfo)\n+\t(ctor_omit_inherited_parms, binfo_inherited_from): New.\n+\t(synthesized_method_walk): Use binfo_inherited_from.  Suppress\n+\taccess control in inheriting ctor.\n+\t(deduce_inheriting_ctor): Deleted if ambiguous ctor inheritance.\n+\t(maybe_explain_implicit_delete): Explain ambigous ctor inheritance.\n+\t(add_one_base_init, do_build_copy_constructor): Adjust.\n+\t(locate_fn_flags, explain_implicit_non_constexpr): Adjust.\n+\t(implicitly_declare_fn): Adjust.\n+\t(get_inherited_ctor): Remove.\n+\t* name-lookup.c (do_class_using_decl): Check for indirect ctor\n+\tinheritance.\n+\t* optimize.c (cdtor_comdat_group): Adjust for new mangling.\n+\t(maybe_clone_body): Handle omitted parms in base clone.\n+\t(maybe_thunk_body): Don't thunk if base clone omits parms.\n+\t* pt.c (tsubst_decl): Adjust.\n+\t(instantiate_template_1): Suppress access control in inheriting\n+\tctor.\n+\t(fn_type_unification): Do deduction with inherited ctor.\n+\t* tree.c (special_function_p): Adjust.\n+\n 2016-11-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cp-objcp-common.c (cp_decl_dwarf_attribute): Handle DW_AT_inline."}, {"sha": "27aa7fdd74b36d1482f4a9aea4aea114490063cf", "filename": "gcc/cp/call.c", "status": "modified", "additions": 126, "deletions": 13, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -414,6 +414,7 @@ enum rejection_reason_code {\n   rr_bad_arg_conversion,\n   rr_template_unification,\n   rr_invalid_copy,\n+  rr_inherited_ctor,\n   rr_constraint_failure\n };\n \n@@ -689,6 +690,13 @@ invalid_copy_with_fn_template_rejection (void)\n   return r;\n }\n \n+static struct rejection_reason *\n+inherited_ctor_rejection (void)\n+{\n+  struct rejection_reason *r = alloc_rejection (rr_inherited_ctor);\n+  return r;\n+}\n+\n // Build a constraint failure record, saving information into the\n // template_instantiation field of the rejection. If FN is not a template\n // declaration, the TMPL member is the FN declaration and TARGS is empty.\n@@ -2111,6 +2119,18 @@ add_function_candidate (struct z_candidate **candidates,\n \t\t}\n \t    }\n \n+\t  /* Don't consider inherited constructors for initialization from an\n+\t     expression of the same or derived type.  */\n+\t  /* FIXME extend to operator=.  */\n+\t  if (i == 0 && len == 1\n+\t      && DECL_INHERITED_CTOR (fn)\n+\t      && reference_related_p (ctype, argtype))\n+\t    {\n+\t      viable = 0;\n+\t      reason = inherited_ctor_rejection ();\n+\t      goto out;\n+\t    }\n+\n \t  /* Core issue 899: When [copy-]initializing a temporary to be bound\n \t     to the first parameter of a copy constructor (12.8) called with\n \t     a single argument in the context of direct-initialization,\n@@ -3393,32 +3413,40 @@ print_z_candidate (location_t loc, const char *msgstr,\n   const char *msg = (msgstr == NULL\n \t\t     ? \"\"\n \t\t     : ACONCAT ((msgstr, \" \", NULL)));\n-  location_t cloc = location_of (candidate->fn);\n+  tree fn = candidate->fn;\n+  if (flag_new_inheriting_ctors)\n+    fn = strip_inheriting_ctors (fn);\n+  location_t cloc = location_of (fn);\n \n-  if (identifier_p (candidate->fn))\n+  if (identifier_p (fn))\n     {\n       cloc = loc;\n       if (candidate->num_convs == 3)\n-\tinform (cloc, \"%s%D(%T, %T, %T) <built-in>\", msg, candidate->fn,\n+\tinform (cloc, \"%s%D(%T, %T, %T) <built-in>\", msg, fn,\n \t\tcandidate->convs[0]->type,\n \t\tcandidate->convs[1]->type,\n \t\tcandidate->convs[2]->type);\n       else if (candidate->num_convs == 2)\n-\tinform (cloc, \"%s%D(%T, %T) <built-in>\", msg, candidate->fn,\n+\tinform (cloc, \"%s%D(%T, %T) <built-in>\", msg, fn,\n \t\tcandidate->convs[0]->type,\n \t\tcandidate->convs[1]->type);\n       else\n-\tinform (cloc, \"%s%D(%T) <built-in>\", msg, candidate->fn,\n+\tinform (cloc, \"%s%D(%T) <built-in>\", msg, fn,\n \t\tcandidate->convs[0]->type);\n     }\n-  else if (TYPE_P (candidate->fn))\n-    inform (cloc, \"%s%T <conversion>\", msg, candidate->fn);\n+  else if (TYPE_P (fn))\n+    inform (cloc, \"%s%T <conversion>\", msg, fn);\n   else if (candidate->viable == -1)\n-    inform (cloc, \"%s%#D <near match>\", msg, candidate->fn);\n-  else if (DECL_DELETED_FN (candidate->fn))\n-    inform (cloc, \"%s%#D <deleted>\", msg, candidate->fn);\n+    inform (cloc, \"%s%#D <near match>\", msg, fn);\n+  else if (DECL_DELETED_FN (fn))\n+    inform (cloc, \"%s%#D <deleted>\", msg, fn);\n   else\n-    inform (cloc, \"%s%#D\", msg, candidate->fn);\n+    inform (cloc, \"%s%#D\", msg, fn);\n+  if (fn != candidate->fn)\n+    {\n+      cloc = location_of (candidate->fn);\n+      inform (cloc, \"  inherited here\");\n+    }\n   /* Give the user some information about why this candidate failed.  */\n   if (candidate->reason != NULL)\n     {\n@@ -3483,6 +3511,11 @@ print_z_candidate (location_t loc, const char *msgstr,\n \t    diagnose_constraints (cloc, tmpl, args);\n \t  }\n \t  break;\n+\tcase rr_inherited_ctor:\n+\t  inform (cloc, \"  an inherited constructor is not a candidate for \"\n+\t\t  \"initialization from an expression of the same or derived \"\n+\t\t  \"type\");\n+\t  break;\n \tcase rr_none:\n \tdefault:\n \t  /* This candidate didn't have any issues or we failed to\n@@ -6338,10 +6371,22 @@ enforce_access (tree basetype_path, tree decl, tree diag_decl,\n {\n   gcc_assert (TREE_CODE (basetype_path) == TREE_BINFO);\n \n+  if (flag_new_inheriting_ctors\n+      && DECL_INHERITED_CTOR (decl))\n+    {\n+      /* 7.3.3/18: The additional constructors are accessible if they would be\n+\t accessible when used to construct an object of the corresponding base\n+\t class.  */\n+      decl = strip_inheriting_ctors (decl);\n+      basetype_path = TYPE_BINFO (DECL_CONTEXT (decl));\n+    }\n+\n   if (!accessible_p (basetype_path, decl, true))\n     {\n       if (complain & tf_error)\n \t{\n+\t  if (flag_new_inheriting_ctors)\n+\t    diag_decl = strip_inheriting_ctors (diag_decl);\n \t  if (TREE_PRIVATE (decl))\n \t    {\n \t      error (\"%q#D is private within this context\", diag_decl);\n@@ -6773,6 +6818,15 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \n       if (! MAYBE_CLASS_TYPE_P (totype))\n \treturn expr;\n+\n+      /* Don't introduce copies when passing arguments along to the inherited\n+\t constructor.  */\n+      if (current_function_decl\n+\t  && flag_new_inheriting_ctors\n+\t  && DECL_INHERITED_CTOR (current_function_decl)\n+\t  && TREE_ADDRESSABLE (totype))\n+\treturn expr;\n+\n       /* Fall through.  */\n     case ck_base:\n       if (convs->kind == ck_base && !convs->need_temporary_p)\n@@ -7800,6 +7854,29 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       check_function_arguments (input_location, TREE_TYPE (fn), nargs, fargs);\n     }\n \n+  if (DECL_INHERITED_CTOR (fn))\n+    {\n+      /* Check for passing ellipsis arguments to an inherited constructor.  We\n+\t could handle this by open-coding the inherited constructor rather than\n+\t defining it, but let's not bother now.  */\n+      if (!cp_unevaluated_operand\n+\t  && cand->convs[cand->num_convs-1]->ellipsis_p)\n+\t{\n+\t  if (complain & tf_error)\n+\t    {\n+\t      sorry (\"passing arguments to ellipsis of inherited constructor \"\n+\t\t     \"%qD\", cand->fn);\n+\t      inform (DECL_SOURCE_LOCATION (cand->fn), \"declared here\");\n+\t    }\n+\t  return error_mark_node;\n+\t}\n+\n+      /* A base constructor inheriting from a virtual base doesn't get the\n+\t inherited arguments, just this and __vtt.  */\n+      if (ctor_omit_inherited_parms (fn))\n+\tnargs = 2;\n+    }\n+\n   /* Avoid actually calling copy constructors and copy assignment operators,\n      if possible.  */\n \n@@ -7985,13 +8062,21 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     }\n \n   tree call = build_cxx_call (fn, nargs, argarray, complain|decltype_flag);\n-  if (call != error_mark_node\n-      && cand->flags & LOOKUP_LIST_INIT_CTOR)\n+  if (call == error_mark_node)\n+    return call;\n+  if (cand->flags & LOOKUP_LIST_INIT_CTOR)\n     {\n       tree c = extract_call_expr (call);\n       /* build_new_op_1 will clear this when appropriate.  */\n       CALL_EXPR_ORDERED_ARGS (c) = true;\n     }\n+  if (current_function_decl\n+      && flag_new_inheriting_ctors\n+      && DECL_INHERITED_CTOR (current_function_decl)\n+      && cand->num_convs)\n+    /* Don't introduce copies when passing arguments along to the inherited\n+       constructor.  */\n+    CALL_FROM_THUNK_P (call) = true;\n   return call;\n }\n \n@@ -9539,6 +9624,34 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \treturn winner;\n     }\n \n+  /* or, if not that, F2 is from a using-declaration, F1 is not, and the\n+     conversion sequences are equivalent.\n+     (proposed in http://lists.isocpp.org/core/2016/10/1142.php) */\n+  if (DECL_P (cand1->fn) && DECL_CLASS_SCOPE_P (cand1->fn)\n+      && !DECL_CONV_FN_P (cand1->fn)\n+      && DECL_P (cand2->fn) && DECL_CLASS_SCOPE_P (cand2->fn)\n+      && !DECL_CONV_FN_P (cand2->fn))\n+    {\n+      bool used1 = (DECL_INHERITED_CTOR (cand1->fn)\n+\t\t    || (BINFO_TYPE (cand1->access_path)\n+\t\t\t!= DECL_CONTEXT (cand1->fn)));\n+      bool used2 = (DECL_INHERITED_CTOR (cand2->fn)\n+\t\t    || (BINFO_TYPE (cand2->access_path)\n+\t\t\t!= DECL_CONTEXT (cand2->fn)));\n+      if (int diff = used2 - used1)\n+\t{\n+\t  for (i = 0; i < len; ++i)\n+\t    {\n+\t      conversion *t1 = cand1->convs[i + off1];\n+\t      conversion *t2 = cand2->convs[i + off2];\n+\t      if (!same_type_p (t1->type, t2->type))\n+\t\tbreak;\n+\t    }\n+\t  if (i == len)\n+\t    return diff;\n+\t}\n+    }\n+\n   /* Check whether we can discard a builtin candidate, either because we\n      have two identical ones or matching builtin and non-builtin candidates.\n "}, {"sha": "c6b4ed6af3399602f105c13f4e44c57397c3e5a3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1016,7 +1016,6 @@ add_method (tree type, tree method, tree using_decl)\n   bool complete_p;\n   bool insert_p = false;\n   tree current_fns;\n-  tree fns;\n \n   if (method == error_mark_node)\n     return false;\n@@ -1083,21 +1082,24 @@ add_method (tree type, tree method, tree using_decl)\n   current_fns = insert_p ? NULL_TREE : (*method_vec)[slot];\n \n   /* Check to see if we've already got this method.  */\n-  for (fns = current_fns; fns; fns = OVL_NEXT (fns))\n+  for (tree *p = &current_fns; *p; )\n     {\n+      tree fns = *p;\n       tree fn = OVL_CURRENT (fns);\n       tree fn_type;\n       tree method_type;\n       tree parms1;\n       tree parms2;\n \n       if (TREE_CODE (fn) != TREE_CODE (method))\n-\tcontinue;\n+\tgoto cont;\n \n       /* Two using-declarations can coexist, we'll complain about ambiguity in\n \t overload resolution.  */\n-      if (using_decl && TREE_CODE (fns) == OVERLOAD && OVL_USED (fns))\n-\tcontinue;\n+      if (using_decl && TREE_CODE (fns) == OVERLOAD && OVL_USED (fns)\n+\t  /* Except handle inherited constructors specially.  */\n+\t  && ! DECL_CONSTRUCTOR_P (fn))\n+\tgoto cont;\n \n       /* [over.load] Member function declarations with the\n \t same name and the same parameter types cannot be\n@@ -1131,7 +1133,7 @@ add_method (tree type, tree method, tree using_decl)\n \t      == FUNCTION_REF_QUALIFIED (method_type))\n \t  && (type_memfn_quals (fn_type) != type_memfn_quals (method_type)\n \t      || type_memfn_rqual (fn_type) != type_memfn_rqual (method_type)))\n-\t  continue;\n+\t  goto cont;\n \n       /* For templates, the return type and template parameters\n \t must be identical.  */\n@@ -1140,7 +1142,7 @@ add_method (tree type, tree method, tree using_decl)\n \t\t\t    TREE_TYPE (method_type))\n \t      || !comp_template_parms (DECL_TEMPLATE_PARMS (fn),\n \t\t\t\t       DECL_TEMPLATE_PARMS (method))))\n-\tcontinue;\n+\tgoto cont;\n \n       if (! DECL_STATIC_FUNCTION_P (fn))\n \tparms1 = TREE_CHAIN (parms1);\n@@ -1178,18 +1180,38 @@ add_method (tree type, tree method, tree using_decl)\n \t\t    mangle_decl (method);\n \t\t}\n \t      cgraph_node::record_function_versions (fn, method);\n-\t      continue;\n+\t      goto cont;\n \t    }\n-\t  if (DECL_INHERITED_CTOR_BASE (method))\n+\t  if (DECL_INHERITED_CTOR (method))\n \t    {\n-\t      if (DECL_INHERITED_CTOR_BASE (fn))\n+\t      if (DECL_INHERITED_CTOR (fn))\n \t\t{\n+\t\t  tree basem = DECL_INHERITED_CTOR_BASE (method);\n+\t\t  tree basef = DECL_INHERITED_CTOR_BASE (fn);\n+\t\t  if (flag_new_inheriting_ctors)\n+\t\t    {\n+\t\t      if (basem == basef)\n+\t\t\t{\n+\t\t\t  /* Inheriting the same constructor along different\n+\t\t\t     paths, combine them.  */\n+\t\t\t  SET_DECL_INHERITED_CTOR\n+\t\t\t    (fn, ovl_cons (DECL_INHERITED_CTOR (method),\n+\t\t\t\t\t   DECL_INHERITED_CTOR (fn)));\n+\t\t\t  /* Adjust deletedness and such.  */\n+\t\t\t  deduce_inheriting_ctor (fn);\n+\t\t\t  /* And discard the new one.  */\n+\t\t\t  return false;\n+\t\t\t}\n+\t\t      else\n+\t\t\t/* Inherited ctors can coexist until overload\n+\t\t\t   resolution.  */\n+\t\t\tgoto cont;\n+\t\t    }\n \t\t  error_at (DECL_SOURCE_LOCATION (method),\n-\t\t\t    \"%q#D inherited from %qT\", method,\n-\t\t\t    DECL_INHERITED_CTOR_BASE (method));\n+\t\t\t    \"%q#D\", method);\n \t\t  error_at (DECL_SOURCE_LOCATION (fn),\n \t\t\t    \"conflicts with version inherited from %qT\",\n-\t\t\t    DECL_INHERITED_CTOR_BASE (fn));\n+\t\t\t    basef);\n \t\t}\n \t      /* Otherwise defer to the other function.  */\n \t      return false;\n@@ -1200,6 +1222,13 @@ add_method (tree type, tree method, tree using_decl)\n \t\t/* Defer to the local function.  */\n \t\treturn false;\n \t    }\n+\t  else if (flag_new_inheriting_ctors\n+\t\t   && DECL_INHERITED_CTOR (fn))\n+\t    {\n+\t      /* Hide the inherited constructor.  */\n+\t      *p = OVL_NEXT (fns);\n+\t      continue;\n+\t    }\n \t  else\n \t    {\n \t      error (\"%q+#D cannot be overloaded\", method);\n@@ -1212,6 +1241,12 @@ add_method (tree type, tree method, tree using_decl)\n \t     will crash while processing the definitions.  */\n \t  return false;\n \t}\n+\n+    cont:\n+      if (TREE_CODE (fns) == OVERLOAD)\n+\tp = &OVL_CHAIN (fns);\n+      else\n+\tbreak;\n     }\n \n   /* A class should never have more than one destructor.  */\n@@ -3308,10 +3343,19 @@ one_inheriting_sig (tree t, tree ctor, tree *parms, int nparms)\n    constructor CTOR.  */\n \n static void\n-one_inherited_ctor (tree ctor, tree t)\n+one_inherited_ctor (tree ctor, tree t, tree using_decl)\n {\n   tree parms = FUNCTION_FIRST_USER_PARMTYPE (ctor);\n \n+  if (flag_new_inheriting_ctors)\n+    {\n+      ctor = implicitly_declare_fn (sfk_inheriting_constructor,\n+\t\t\t\t    t, /*const*/false, ctor, parms);\n+      add_method (t, ctor, using_decl);\n+      TYPE_HAS_USER_CONSTRUCTOR (t) = true;\n+      return;\n+    }\n+\n   tree *new_parms = XALLOCAVEC (tree, list_length (parms));\n   int i = 0;\n   for (; parms && parms != void_list_node; parms = TREE_CHAIN (parms))\n@@ -3412,7 +3456,7 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n \t  input_location = DECL_SOURCE_LOCATION (using_decl);\n \t  if (ctor_list)\n \t    for (; ctor_list; ctor_list = OVL_NEXT (ctor_list))\n-\t      one_inherited_ctor (OVL_CURRENT (ctor_list), t);\n+\t      one_inherited_ctor (OVL_CURRENT (ctor_list), t, using_decl);\n \t  *access_decls = TREE_CHAIN (*access_decls);\n \t  input_location = loc;\n \t}\n@@ -4772,6 +4816,11 @@ build_clone (tree fn, tree name)\n \t}\n     }\n \n+  /* A base constructor inheriting from a virtual base doesn't get the\n+     arguments.  */\n+  if (ctor_omit_inherited_parms (fn))\n+    DECL_CHAIN (DECL_CHAIN (DECL_ARGUMENTS (clone))) = NULL_TREE;\n+\n   for (parms = DECL_ARGUMENTS (clone); parms; parms = DECL_CHAIN (parms))\n     {\n       DECL_CONTEXT (parms) = clone;"}, {"sha": "43457d2463fc5c14cab11c56049c419eae39d82c", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -171,13 +171,13 @@ is_valid_constexpr_fn (tree fun, bool complain)\n {\n   bool ret = true;\n \n-  if (DECL_INHERITED_CTOR_BASE (fun)\n+  if (DECL_INHERITED_CTOR (fun)\n       && TREE_CODE (fun) == TEMPLATE_DECL)\n     {\n       ret = false;\n       if (complain)\n \terror (\"inherited constructor %qD is not constexpr\",\n-\t       get_inherited_ctor (fun));\n+\t       DECL_INHERITED_CTOR (fun));\n     }\n   else\n     {"}, {"sha": "d3a5aeb785ba614eaf7fea3d2d00b41aebb71085", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -2730,12 +2730,21 @@ struct GTY(()) lang_decl {\n   (LANG_DECL_FN_CHECK (NODE)->context = (THUNKS))\n \n /* If NODE, a FUNCTION_DECL, is a C++11 inheriting constructor, then this\n-   is the base it inherits from.  */\n-#define DECL_INHERITED_CTOR_BASE(NODE) \\\n-  (DECL_CONSTRUCTOR_P (NODE) ? LANG_DECL_FN_CHECK (NODE)->context : NULL_TREE)\n+   is the constructor it inherits from.  */\n+#define DECL_INHERITED_CTOR(NODE) \\\n+  (DECL_DECLARES_FUNCTION_P (NODE) && DECL_CONSTRUCTOR_P (NODE) \\\n+   ? LANG_DECL_FN_CHECK (NODE)->context : NULL_TREE)\n+\n+/* And this is the base that constructor comes from.  */\n+#define DECL_INHERITED_CTOR_BASE(NODE)\t\t\t\\\n+  (DECL_INHERITED_CTOR (NODE)\t\t\t\t\\\n+   ? DECL_CONTEXT (flag_new_inheriting_ctors\t\t\\\n+\t\t   ? strip_inheriting_ctors (NODE)\t\\\n+\t\t   : DECL_INHERITED_CTOR (NODE))\t\\\n+   : NULL_TREE)\n \n /* Set the inherited base.  */\n-#define SET_DECL_INHERITED_CTOR_BASE(NODE,INH) \\\n+#define SET_DECL_INHERITED_CTOR(NODE,INH) \\\n   (LANG_DECL_FN_CHECK (NODE)->context = (INH))\n \n /* Nonzero if NODE is a thunk, rather than an ordinary function.  */\n@@ -6036,7 +6045,9 @@ extern tree get_copy_ctor\t\t\t(tree, tsubst_flags_t);\n extern tree get_copy_assign\t\t\t(tree);\n extern tree get_default_ctor\t\t\t(tree);\n extern tree get_dtor\t\t\t\t(tree, tsubst_flags_t);\n-extern tree get_inherited_ctor\t\t\t(tree);\n+extern tree strip_inheriting_ctors\t\t(tree);\n+extern tree inherited_ctor_binfo\t\t(tree);\n+extern bool ctor_omit_inherited_parms\t\t(tree);\n extern tree locate_ctor\t\t\t\t(tree);\n extern tree implicitly_declare_fn               (special_function_kind, tree,\n \t\t\t\t\t\t bool, tree, tree);"}, {"sha": "aa92a7e6a6b5784068cd1eb68cd488663016ad72", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1617,6 +1617,13 @@ dump_function_decl (cxx_pretty_printer *pp, tree t, int flags)\n             pp_cxx_requires_clause (pp, reqs);\n \n       dump_substitution (pp, t, template_parms, template_args, flags);\n+\n+      if (tree base = DECL_INHERITED_CTOR_BASE (t))\n+\t{\n+\t  pp_cxx_ws_string (pp, \"[inherited from\");\n+\t  dump_type (pp, base, TFF_PLAIN_IDENTIFIER);\n+\t  pp_character (pp, ']');\n+\t}\n     }\n   else if (template_args)\n     {"}, {"sha": "5eba4c3e18cfd12e7d84ef72c91224d8a5470428", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1117,7 +1117,7 @@ emit_mem_initializers (tree mem_inits)\n     }\n \n   if (DECL_DEFAULTED_FN (current_function_decl)\n-      && ! DECL_INHERITED_CTOR_BASE (current_function_decl))\n+      && ! DECL_INHERITED_CTOR (current_function_decl))\n     flags |= LOOKUP_DEFAULTED;\n \n   /* Sort the mem-initializers into the order in which the\n@@ -1138,6 +1138,13 @@ emit_mem_initializers (tree mem_inits)\n       if (arguments == error_mark_node)\n \tcontinue;\n \n+      /* Suppress access control when calling the inherited ctor.  */\n+      bool inherited_base = (DECL_INHERITED_CTOR (current_function_decl)\n+\t\t\t     && flag_new_inheriting_ctors\n+\t\t\t     && arguments);\n+      if (inherited_base)\n+\tpush_deferring_access_checks (dk_deferred);\n+\n       if (arguments == NULL_TREE)\n \t{\n \t  /* If these initializations are taking place in a copy constructor,\n@@ -1172,6 +1179,9 @@ emit_mem_initializers (tree mem_inits)\n \t/* C++14 DR1658 Means we do not have to construct vbases of\n \t   abstract classes.  */\n \tconstruct_virtual_base (subobject, arguments);\n+\n+      if (inherited_base)\n+\tpop_deferring_access_checks ();\n     }\n   in_base_initializer = 0;\n "}, {"sha": "f3b2fe3ee8de2107081a4783e50e0d53b49734b7", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1786,18 +1786,25 @@ write_identifier (const char *identifier)\n static void\n write_special_name_constructor (const tree ctor)\n {\n+  write_char ('C');\n+  bool new_inh = (flag_new_inheriting_ctors\n+\t\t  && DECL_INHERITED_CTOR (ctor));\n+  if (new_inh)\n+    write_char ('I');\n   if (DECL_BASE_CONSTRUCTOR_P (ctor))\n-    write_string (\"C2\");\n+    write_char ('2');\n   /* This is the old-style \"[unified]\" constructor.\n      In some cases, we may emit this function and call\n      it from the clones in order to share code and save space.  */\n   else if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (ctor))\n-    write_string (\"C4\");\n+    write_char ('4');\n   else\n     {\n       gcc_assert (DECL_COMPLETE_CONSTRUCTOR_P (ctor));\n-      write_string (\"C1\");\n+      write_char ('1');\n     }\n+  if (new_inh)\n+    write_type (DECL_INHERITED_CTOR_BASE (ctor));\n }\n \n /* Handle destructor productions of non-terminal <special-name>."}, {"sha": "73d42b19d55af4aa45f68072eb84a078d2721369", "filename": "gcc/cp/method.c", "status": "modified", "additions": 173, "deletions": 42, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -492,6 +492,118 @@ forward_parm (tree parm)\n   return exp;\n }\n \n+/* Strip all inheriting constructors, if any, to return the original\n+   constructor from a (possibly indirect) base class.  */\n+\n+tree\n+strip_inheriting_ctors (tree fn)\n+{\n+  gcc_assert (flag_new_inheriting_ctors);\n+  while (tree inh = DECL_INHERITED_CTOR (fn))\n+    {\n+      inh = OVL_CURRENT (inh);\n+      fn = inh;\n+    }\n+  return fn;\n+}\n+\n+/* Find the binfo for the base subobject of BINFO being initialized by\n+   inherited constructor FNDECL (a member of a direct base of BINFO).  */\n+\n+static tree inherited_ctor_binfo (tree, tree);\n+static tree\n+inherited_ctor_binfo_1 (tree binfo, tree fndecl)\n+{\n+  tree base = DECL_CONTEXT (fndecl);\n+  tree base_binfo;\n+  for (int i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    if (BINFO_TYPE (base_binfo) == base)\n+      return inherited_ctor_binfo (base_binfo, fndecl);\n+\n+  gcc_unreachable();\n+}\n+\n+/* Find the binfo for the base subobject of BINFO being initialized by\n+   inheriting constructor FNDECL (a member of BINFO), or BINFO if FNDECL is not\n+   an inheriting constructor.  */\n+\n+static tree\n+inherited_ctor_binfo (tree binfo, tree fndecl)\n+{\n+  tree inh = DECL_INHERITED_CTOR (fndecl);\n+  if (!inh)\n+    return binfo;\n+\n+  tree results = NULL_TREE;\n+  for (; inh; inh = OVL_NEXT (inh))\n+    {\n+      tree one = inherited_ctor_binfo_1 (binfo, OVL_CURRENT (inh));\n+      if (!results)\n+\tresults = one;\n+      else if (one != results)\n+\tresults = tree_cons (NULL_TREE, one, results);\n+    }\n+  return results;\n+}\n+\n+/* Find the binfo for the base subobject being initialized by inheriting\n+   constructor FNDECL, or NULL_TREE if FNDECL is not an inheriting\n+   constructor.  */\n+\n+tree\n+inherited_ctor_binfo (tree fndecl)\n+{\n+  if (!DECL_INHERITED_CTOR (fndecl))\n+    return NULL_TREE;\n+  tree binfo = TYPE_BINFO (DECL_CONTEXT (fndecl));\n+  return inherited_ctor_binfo (binfo, fndecl);\n+}\n+\n+/* True if we should omit all user-declared parameters from constructor FN,\n+   because it is a base clone of a ctor inherited from a virtual base.  */\n+\n+bool\n+ctor_omit_inherited_parms (tree fn)\n+{\n+  if (!flag_new_inheriting_ctors)\n+    /* We only optimize away the parameters in the new model.  */\n+    return false;\n+  if (!DECL_BASE_CONSTRUCTOR_P (fn)\n+      || !CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fn)))\n+    return false;\n+  tree binfo = inherited_ctor_binfo (fn);\n+  for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n+    if (BINFO_VIRTUAL_P (binfo))\n+      return true;\n+  return false;\n+}\n+\n+/* True iff constructor(s) INH inherited into BINFO initializes INIT_BINFO.\n+   This can be true for multiple virtual bases as well as one direct\n+   non-virtual base.  */\n+\n+static bool\n+binfo_inherited_from (tree binfo, tree init_binfo, tree inh)\n+{\n+  /* inh is an OVERLOAD if we inherited the same constructor along\n+     multiple paths, check all of them.  */\n+  for (; inh; inh = OVL_NEXT (inh))\n+    {\n+      tree fn = OVL_CURRENT (inh);\n+      tree base = DECL_CONTEXT (fn);\n+      tree base_binfo = NULL_TREE;\n+      for (int i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\tif (BINFO_TYPE (base_binfo) == base)\n+\t  break;\n+      if (base_binfo == init_binfo\n+\t  || (flag_new_inheriting_ctors\n+\t      && binfo_inherited_from (base_binfo, init_binfo,\n+\t\t\t\t       DECL_INHERITED_CTOR (fn))))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Subroutine of do_build_copy_constructor: Add a mem-initializer for BINFO\n    given the parameter or parameters PARM, possibly inherited constructor\n    base INH, or move flag MOVE_P.  */\n@@ -505,7 +617,7 @@ add_one_base_init (tree binfo, tree parm, bool move_p, tree inh,\n     {\n       /* An inheriting constructor only has a mem-initializer for\n \t the base it inherits from.  */\n-      if (BINFO_TYPE (binfo) != inh)\n+      if (!binfo_inherited_from (TYPE_BINFO (current_class_type), binfo, inh))\n \treturn member_init_list;\n \n       tree *p = &init;\n@@ -537,7 +649,7 @@ do_build_copy_constructor (tree fndecl)\n   tree parm = FUNCTION_FIRST_USER_PARM (fndecl);\n   bool move_p = DECL_MOVE_CONSTRUCTOR_P (fndecl);\n   bool trivial = trivial_fn_p (fndecl);\n-  tree inh = DECL_INHERITED_CTOR_BASE (fndecl);\n+  tree inh = DECL_INHERITED_CTOR (fndecl);\n \n   if (!inh)\n     parm = convert_from_reference (parm);\n@@ -901,7 +1013,7 @@ locate_fn_flags (tree type, tree name, tree argtype, int flags,\n     {\n       if (TREE_CODE (argtype) == TREE_LIST)\n \t{\n-\t  for (tree elt = argtype; elt != void_list_node;\n+\t  for (tree elt = argtype; elt && elt != void_list_node;\n \t       elt = TREE_CHAIN (elt))\n \t    {\n \t      tree type = TREE_VALUE (elt);\n@@ -996,25 +1108,6 @@ get_copy_assign (tree type)\n   return fn;\n }\n \n-/* Locate the inherited constructor of constructor CTOR.  */\n-\n-tree\n-get_inherited_ctor (tree ctor)\n-{\n-  gcc_assert (DECL_INHERITED_CTOR_BASE (ctor));\n-\n-  push_deferring_access_checks (dk_no_check);\n-  tree fn = locate_fn_flags (DECL_INHERITED_CTOR_BASE (ctor),\n-\t\t\t     complete_ctor_identifier,\n-\t\t\t     FUNCTION_FIRST_USER_PARMTYPE (ctor),\n-\t\t\t     LOOKUP_NORMAL|LOOKUP_SPECULATIVE,\n-\t\t\t     tf_none);\n-  pop_deferring_access_checks ();\n-  if (fn == error_mark_node)\n-    return NULL_TREE;\n-  return fn;\n-}\n-\n /* walk_tree helper function for is_trivially_xible.  If *TP is a call,\n    return it if it calls something other than a trivial special member\n    function.  */\n@@ -1330,7 +1423,7 @@ static void\n synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t\t\t tree *spec_p, bool *trivial_p, bool *deleted_p,\n \t\t\t bool *constexpr_p, bool diag,\n-\t\t\t tree inherited_base, tree inherited_parms)\n+\t\t\t tree inheriting_ctor, tree inherited_parms)\n {\n   tree binfo, base_binfo, scope, fnname, rval, argtype;\n   bool move_p, copy_arg_p, assign_p, expected_trivial, check_vdtor;\n@@ -1389,7 +1482,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     }\n \n   gcc_assert ((sfk == sfk_inheriting_constructor)\n-\t      == (inherited_base != NULL_TREE));\n+\t      == (inheriting_ctor != NULL_TREE));\n \n   /* If that user-written default constructor would satisfy the\n      requirements of a constexpr constructor (7.1.5), the\n@@ -1465,7 +1558,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   scope = push_scope (ctype);\n \n   flags = LOOKUP_NORMAL|LOOKUP_SPECULATIVE;\n-  if (!inherited_base)\n+  if (!inheriting_ctor)\n     flags |= LOOKUP_DEFAULTED;\n \n   complain = diag ? tf_warning_or_error : tf_none;\n@@ -1485,13 +1578,25 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t/* We'll handle virtual bases below.  */\n \tcontinue;\n \n+      bool inherited_binfo = false;\n+\n       if (copy_arg_p)\n \targtype = build_stub_type (basetype, quals, move_p);\n-      else if (basetype == inherited_base)\n-\targtype = inherited_parms;\n+      else if ((inherited_binfo\n+\t\t= binfo_inherited_from (binfo, base_binfo, inheriting_ctor)))\n+\t{\n+\t  /* Don't check access on the inherited constructor.  */\n+\t  argtype = inherited_parms;\n+\t  if (flag_new_inheriting_ctors)\n+\t    push_deferring_access_checks (dk_deferred);\n+\t}\n       rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n-      if (inherited_base)\n-\targtype = NULL_TREE;\n+      if (inherited_binfo)\n+\t{\n+\t  if (flag_new_inheriting_ctors)\n+\t    pop_deferring_access_checks ();\n+\t  argtype = NULL_TREE;\n+\t}\n \n       process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n \t\t\tconstexpr_p, diag, basetype);\n@@ -1547,9 +1652,24 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       FOR_EACH_VEC_ELT (*vbases, i, base_binfo)\n \t{\n \t  tree basetype = BINFO_TYPE (base_binfo);\n+\t  bool inherited_binfo = false;\n+\n \t  if (copy_arg_p)\n \t    argtype = build_stub_type (basetype, quals, move_p);\n+\t  else if ((inherited_binfo\n+\t\t    = binfo_inherited_from (binfo, base_binfo, inheriting_ctor)))\n+\t    {\n+\t      argtype = inherited_parms;\n+\t      if (flag_new_inheriting_ctors)\n+\t\tpush_deferring_access_checks (dk_deferred);\n+\t    }\n \t  rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n+\t  if (inherited_binfo)\n+\t    {\n+\t      if (flag_new_inheriting_ctors)\n+\t\tpop_deferring_access_checks ();\n+\t      argtype = NULL_TREE;\n+\t    }\n \n \t  process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n \t\t\t    constexpr_p, diag, basetype);\n@@ -1598,7 +1718,7 @@ get_defaulted_eh_spec (tree decl)\n   bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));\n   tree spec = empty_except_spec;\n   synthesized_method_walk (ctype, sfk, const_p, &spec, NULL, NULL,\n-\t\t\t   NULL, false, DECL_INHERITED_CTOR_BASE (decl),\n+\t\t\t   NULL, false, DECL_INHERITED_CTOR (decl),\n \t\t\t   parms);\n   return spec;\n }\n@@ -1657,6 +1777,17 @@ maybe_explain_implicit_delete (tree decl)\n \t\t  decl, ctype);\n \t  informed = true;\n \t}\n+      else if (sfk == sfk_inheriting_constructor)\n+\t{\n+\t  tree binfo = inherited_ctor_binfo (decl);\n+\t  if (TREE_CODE (binfo) != TREE_BINFO)\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION (decl),\n+\t\t      \"%q#D inherits from multiple base subobjects\",\n+\t\t      decl);\n+\t      informed = true;\n+\t    }\n+\t}\n       if (!informed)\n \t{\n \t  tree parms = FUNCTION_FIRST_USER_PARMTYPE (decl);\n@@ -1668,15 +1799,15 @@ maybe_explain_implicit_delete (tree decl)\n \n \t  synthesized_method_walk (ctype, sfk, const_p,\n \t\t\t\t   &raises, NULL, &deleted_p, NULL, false,\n-\t\t\t\t   DECL_INHERITED_CTOR_BASE (decl), parms);\n+\t\t\t\t   DECL_INHERITED_CTOR (decl), parms);\n \t  if (deleted_p)\n \t    {\n \t      inform (DECL_SOURCE_LOCATION (decl),\n \t\t      \"%q#D is implicitly deleted because the default \"\n \t\t      \"definition would be ill-formed:\", decl);\n \t      synthesized_method_walk (ctype, sfk, const_p,\n \t\t\t\t       NULL, NULL, NULL, NULL, true,\n-\t\t\t\t       DECL_INHERITED_CTOR_BASE (decl), parms);\n+\t\t\t\t       DECL_INHERITED_CTOR (decl), parms);\n \t    }\n \t  else if (!comp_except_specs\n \t\t   (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl)),\n@@ -1709,7 +1840,7 @@ explain_implicit_non_constexpr (tree decl)\n   synthesized_method_walk (DECL_CLASS_CONTEXT (decl),\n \t\t\t   special_function_p (decl), const_p,\n \t\t\t   NULL, NULL, NULL, &dummy, true,\n-\t\t\t   DECL_INHERITED_CTOR_BASE (decl),\n+\t\t\t   DECL_INHERITED_CTOR (decl),\n \t\t\t   FUNCTION_FIRST_USER_PARMTYPE (decl));\n }\n \n@@ -1720,14 +1851,17 @@ explain_implicit_non_constexpr (tree decl)\n void\n deduce_inheriting_ctor (tree decl)\n {\n-  gcc_assert (DECL_INHERITED_CTOR_BASE (decl));\n+  gcc_assert (DECL_INHERITED_CTOR (decl));\n   tree spec;\n   bool trivial, constexpr_, deleted;\n   synthesized_method_walk (DECL_CONTEXT (decl), sfk_inheriting_constructor,\n \t\t\t   false, &spec, &trivial, &deleted, &constexpr_,\n \t\t\t   /*diag*/false,\n-\t\t\t   DECL_INHERITED_CTOR_BASE (decl),\n+\t\t\t   DECL_INHERITED_CTOR (decl),\n \t\t\t   FUNCTION_FIRST_USER_PARMTYPE (decl));\n+  if (TREE_CODE (inherited_ctor_binfo (decl)) != TREE_BINFO)\n+    /* Inherited the same constructor from different base subobjects.  */\n+    deleted = true;\n   DECL_DELETED_FN (decl) = deleted;\n   TREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl), spec);\n }\n@@ -1828,9 +1962,6 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       gcc_unreachable ();\n     }\n \n-  tree inherited_base = (inherited_ctor\n-\t\t\t ? DECL_CONTEXT (inherited_ctor)\n-\t\t\t : NULL_TREE);\n   bool trivial_p = false;\n \n   if (inherited_ctor && TREE_CODE (inherited_ctor) == TEMPLATE_DECL)\n@@ -1846,12 +1977,12 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       raises = unevaluated_noexcept_spec ();\n       synthesized_method_walk (type, kind, const_p, NULL, &trivial_p,\n \t\t\t       &deleted_p, &constexpr_p, false,\n-\t\t\t       inherited_base, inherited_parms);\n+\t\t\t       inherited_ctor, inherited_parms);\n     }\n   else\n     synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n \t\t\t     &deleted_p, &constexpr_p, false,\n-\t\t\t     inherited_base, inherited_parms);\n+\t\t\t     inherited_ctor, inherited_parms);\n   /* Don't bother marking a deleted constructor as constexpr.  */\n   if (deleted_p)\n     constexpr_p = false;\n@@ -1902,7 +2033,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n     {\n       tree *p = &DECL_ARGUMENTS (fn);\n       int index = 1;\n-      for (tree parm = inherited_parms; parm != void_list_node;\n+      for (tree parm = inherited_parms; parm && parm != void_list_node;\n \t   parm = TREE_CHAIN (parm))\n \t{\n \t  *p = cp_build_parm_decl (NULL_TREE, TREE_VALUE (parm));\n@@ -1912,7 +2043,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n \t  DECL_CONTEXT (*p) = fn;\n \t  p = &DECL_CHAIN (*p);\n \t}\n-      SET_DECL_INHERITED_CTOR_BASE (fn, inherited_base);\n+      SET_DECL_INHERITED_CTOR (fn, inherited_ctor);\n       DECL_NONCONVERTING_P (fn) = DECL_NONCONVERTING_P (inherited_ctor);\n       /* A constructor so declared has the same access as the corresponding\n \t constructor in X.  */"}, {"sha": "e574c271194add28b85011df627f8617411ea94c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -3421,6 +3421,12 @@ do_class_using_decl (tree scope, tree name)\n \t      return NULL_TREE;\n \t    }\n \t}\n+      else if (name == ctor_identifier\n+\t       && BINFO_INHERITANCE_CHAIN (BINFO_INHERITANCE_CHAIN (binfo)))\n+\t{\n+\t  error (\"cannot inherit constructors from indirect base %qT\", scope);\n+\t  return NULL_TREE;\n+\t}\n       else if (!name_dependent_p)\n \t{\n \t  decl = lookup_member (binfo, name, 0, false, tf_warning_or_error);"}, {"sha": "b926ef7ad6ca76dfe59c22e3f9fc7ace40cd3beb", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -166,7 +166,8 @@ cdtor_comdat_group (tree complete, tree base)\n       {\n \tgcc_assert (!diff_seen\n \t\t    && idx > 0\n-\t\t    && (p[idx - 1] == 'C' || p[idx - 1] == 'D')\n+\t\t    && (p[idx - 1] == 'C' || p[idx - 1] == 'D'\n+\t\t\t|| p[idx - 1] == 'I')\n \t\t    && p[idx] == '1'\n \t\t    && q[idx] == '2');\n \tgrp_name[idx] = '5';\n@@ -259,6 +260,11 @@ maybe_thunk_body (tree fn, bool force)\n      (for non-vague linkage ctors) or the COMDAT group (otherwise).  */\n \n   populate_clone_array (fn, fns);\n+\n+  /* Don't use thunks if the base clone omits inherited parameters.  */\n+  if (ctor_omit_inherited_parms (fns[0]))\n+    return 0;\n+\n   DECL_ABSTRACT_P (fn) = false;\n   if (!DECL_WEAK (fn))\n     {\n@@ -490,7 +496,7 @@ maybe_clone_body (tree fn)\n \tparm = DECL_CHAIN (parm);\n       if (DECL_HAS_VTT_PARM_P (clone))\n \tclone_parm = DECL_CHAIN (clone_parm);\n-      for (; parm;\n+      for (; parm && clone_parm;\n \t   parm = DECL_CHAIN (parm), clone_parm = DECL_CHAIN (clone_parm))\n \t/* Update this parameter.  */\n \tupdate_cloned_parm (parm, clone_parm, first);\n@@ -616,7 +622,8 @@ maybe_clone_body (tree fn)\n               else\n                 {\n                   decl_map->put (parm, clone_parm);\n-                  clone_parm = DECL_CHAIN (clone_parm);\n+\t\t  if (clone_parm)\n+\t\t    clone_parm = DECL_CHAIN (clone_parm);\n                 }\n             }\n "}, {"sha": "e5134487816b976a8cb14c346243d73e493c4ba8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -12056,7 +12056,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    maybe_retrofit_in_chrg (r);\n \t    if (DECL_CONSTRUCTOR_P (r))\n \t      grok_ctor_properties (ctx, r);\n-\t    if (DECL_INHERITED_CTOR_BASE (r))\n+\t    if (DECL_INHERITED_CTOR (r))\n \t      deduce_inheriting_ctor (r);\n \t    /* If this is an instantiation of a member template, clone it.\n \t       If it isn't, that'll be handled by\n@@ -17663,11 +17663,16 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n   DECL_TI_ARGS (fndecl) = targ_ptr;\n \n   /* Now we know the specialization, compute access previously\n-     deferred.  */\n-  push_access_scope (fndecl);\n-  if (!perform_deferred_access_checks (complain))\n-    access_ok = false;\n-  pop_access_scope (fndecl);\n+     deferred.  Do no access control for inheriting constructors,\n+     as we already checked access for the inherited constructor.  */\n+  if (!(flag_new_inheriting_ctors\n+\t&& DECL_INHERITED_CTOR (fndecl)))\n+    {\n+      push_access_scope (fndecl);\n+      if (!perform_deferred_access_checks (complain))\n+\taccess_ok = false;\n+      pop_access_scope (fndecl);\n+    }\n   pop_deferring_access_checks ();\n \n   /* If we've just instantiated the main entry point for a function,\n@@ -17825,6 +17830,11 @@ fn_type_unification (tree fn,\n   static int deduction_depth;\n   struct pending_template *old_last_pend = last_pending_template;\n   struct tinst_level *old_error_tinst = last_error_tinst_level;\n+\n+  tree orig_fn = fn;\n+  if (flag_new_inheriting_ctors)\n+    fn = strip_inheriting_ctors (fn);\n+\n   tree tparms = DECL_INNERMOST_TEMPLATE_PARMS (fn);\n   tree tinst;\n   tree r = error_mark_node;\n@@ -18113,6 +18123,11 @@ fn_type_unification (tree fn,\n \t  }\n     }\n \n+  /* After doing deduction with the inherited constructor, actually return an\n+     instantiation of the inheriting constructor.  */\n+  if (orig_fn != fn)\n+    decl = instantiate_template (orig_fn, targs, complain);\n+\n   r = decl;\n \n  fail:"}, {"sha": "ac15d67eafb27c3f0fed8b5d2228e99ef9a94dcc", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -4282,7 +4282,7 @@ special_function_p (const_tree decl)\n   /* Rather than doing all this stuff with magic names, we should\n      probably have a field of type `special_function_kind' in\n      DECL_LANG_SPECIFIC.  */\n-  if (DECL_INHERITED_CTOR_BASE (decl))\n+  if (DECL_INHERITED_CTOR (decl))\n     return sfk_inheriting_constructor;\n   if (DECL_COPY_CONSTRUCTOR_P (decl))\n     return sfk_copy_constructor;"}, {"sha": "ad9304fdeff0bb30105bfcb7af17c628e18dcf1a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -199,6 +199,7 @@ in the following sections.\n -fno-implicit-templates @gol\n -fno-implicit-inline-templates @gol\n -fno-implement-inlines  -fms-extensions @gol\n+-fnew-inheriting-ctors @gol\n -fno-nonansi-builtins  -fnothrow-opt  -fno-operator-names @gol\n -fno-optional-diags  -fpermissive @gol\n -fno-pretty-templates @gol\n@@ -2220,6 +2221,10 @@ Version 10, which first appeared in G++ 6.1, adds mangling of\n attributes that affect type identity, such as ia32 calling convention\n attributes (e.g. @samp{stdcall}).\n \n+Version 11, which first appeared in G++ 7, corrects the mangling of\n+sizeof... expressions.  It also implies\n+@option{-fnew-inheriting-ctors}.\n+\n See also @option{-Wabi}.\n \n @item -fabi-compat-version=@var{n}\n@@ -2413,6 +2418,13 @@ errors if these functions are not inlined everywhere they are called.\n Disable Wpedantic warnings about constructs used in MFC, such as implicit\n int and getting a pointer to member function via non-standard syntax.\n \n+@item -fnew-inheriting-ctors\n+@opindex fnew-inheriting-ctors\n+Enable the P0136 adjustment to the semantics of C++11 constructor\n+inheritance.  This is part of C++17 but also considered to be a Defect\n+Report against C++11 and C++14.  This flag is enabled by default\n+unless @option{-fabi-version=10} or lower is specified.\n+\n @item -fno-nonansi-builtins\n @opindex fno-nonansi-builtins\n Disable built-in declarations of functions that are not mandated by"}, {"sha": "98691101e860b90d6779cceaeb48ac479b0b9730", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-inhctor1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-inhctor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-inhctor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-inhctor1.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -9,7 +9,7 @@ struct A\n \n struct B : A\n {\n-  using A::A;\t\t\t// { dg-error \"A::i\" }\n+  using A::A;\t\t\t// { dg-prune-output \"A::i\" }\n };\n \n-constexpr B b(0);\t\t// { dg-error \"B::B\" }\n+constexpr B b(0);\t\t// { dg-error \"\" }"}, {"sha": "4fc67a4a56a5be6d2760344458ed23a3ef9fe594", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor11.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1,4 +1,5 @@\n // { dg-do compile { target c++11 } }\n+// { dg-options -fno-new-inheriting-ctors }\n \n struct A\n {"}, {"sha": "61b251eb0ba1531a4fa1ba6b47e78b6d0a1283d5", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor11a.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11a.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+struct A\n+{\n+  A(int, ...);\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+B b1(42);\n+B b2(42, 1.0);\t\t\t// { dg-bogus \"ellipsis\" \"\" { xfail *-*-* } }"}, {"sha": "a0b518c19d34f99fb910684d25410c0eb30ba8ef", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor15.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor15.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -2,6 +2,7 @@\n // constructors was a deliberate choice.\n \n // { dg-do compile { target c++11 } }\n+// { dg-options -fno-new-inheriting-ctors }\n \n struct A { A(int); };\n struct B: public A"}, {"sha": "a9abb8428a1a3ba076434ee54ec901392084eb06", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor15a.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor15a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor15a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor15a.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,14 @@\n+// P0136 caused us to start inheriting base copy constructors.\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+struct A { A(int); };\n+struct B: public A\n+{\n+  using A::A;\n+};\n+\n+A a (42);\n+\n+B b1 (24);\t\t\t// inherited\n+B b2 (a);\t\t\t// also inherited now"}, {"sha": "8cbeed6604792e5176f745f39db83d488c2add27", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor3.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1,4 +1,5 @@\n // { dg-do compile { target c++11 } }\n+// { dg-options -fno-new-inheriting-ctors }\n \n struct B1 {\n   B1(int);"}, {"sha": "c9b4ea114121d6cc0aecaeea67f137b8a9c4f228", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor3a.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3a.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+struct B1 {\n+  B1(int);\n+};\n+struct B2 {\n+  B2(int);\n+};\n+struct D1 : B1, B2 {\n+  using B1::B1;\n+  using B2::B2;\n+};\t\t\t\t// ambiguous\n+struct D2 : B1, B2 {\n+  using B1::B1;\n+  using B2::B2;\n+  D2(int);    // OK: user declaration supersedes both implicit declarations\n+};\n+\n+D2 d2(42);\n+D1 d1(42);\t\t\t// { dg-error \"ambiguous\" }"}, {"sha": "d0038c16a142f6dbb3d7bda2efc3e11def0f32f9", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor5.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -15,7 +15,7 @@ void test() {\n   D1 e;\t\t    // { dg-error \"deleted\" } D1 has no default constructor\n }\n struct D2 : B2 {\n-  using B2::B2;\t    // { dg-error \"no match\" } implicitly declares D2(double)\n+  using B2::B2;\t    // { dg-error \"B1::B1\" }\n   B1 b;\n };\n D2 f(1.0);\t    // { dg-error \"deleted\" } B1 has no default constructor"}, {"sha": "5bfdd499d46cec4bb51b7c25f2c1e8359f8a8700", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor9.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -9,7 +9,7 @@ protected:\n \n struct B: A\n {\n-  using A::A;\t\t\t// { dg-message \"protected\" }\n+  using A::A;\n };\n \n B b(42);\t\t\t// { dg-error \"this context\" }"}, {"sha": "bf9df415c059bf91620a62b910ba3fd80aae55be", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor1.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A { };\n+struct B: A { };\n+struct C: B { using A::A; };\t// { dg-error \"direct\" }"}, {"sha": "02ec58a3e8e0e746a7a5371e705707cf631de6a2", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor22.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor22.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,33 @@\n+// Testcase from P0136\n+// { dg-do compile { target c++11 } }\n+\n+struct B1 {\n+  template <class... Ts>\n+  B1(int, Ts...) { }\n+};\n+\n+struct B2 {\n+  B2(double) { }\n+};\n+\n+int get();\n+\n+struct D1 : B1 {\t\t// { dg-message \"B1::B1\" }\n+  using B1::B1;  // inherits B1(int, ...)\n+  int x;\n+  int y = get();\n+};\n+\n+void test() {\n+  D1 d(2, 3, 4); // OK: B1 is initialized by calling B1(2, 3, 4),\n+  // then d.x is default-initialized (no initialization is performed),\n+  // then d.y is initialized by calling get()\n+  D1 e;          // { dg-error \"\" } D1 has a deleted default constructor\n+}\n+\n+struct D2 : B2 {\n+  using B2::B2;\t\t\t// { dg-message \"B1::B1\" }\n+  B1 b;\n+};\n+\n+D2 f(1.0);       // { dg-error \"\" } B1 has no default constructor"}, {"sha": "0c862f7573f49522ba911d609261030fdd4038e6", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor23.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor23.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,19 @@\n+// Testcase from P0136\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fnew-inheriting-ctors -fdump-tree-gimple\" }\n+\n+struct W { W(int); };\n+struct V: W { using W::W; };\n+struct X : virtual V { using V::V; X() = delete; };\n+struct Y : X { using X::X; };\n+struct Z : Y, virtual V { using Y::Y; };\n+Z z(0); // OK: initialization of Y does not invoke default constructor of X\n+\n+// Check that we're passing this and __vtt along to the Y inheriting\n+// constructor, but not the int parameter.\n+// { dg-final { scan-assembler \"_ZN1YCI21WEi\" } }\n+// { dg-final { scan-tree-dump \"Y::Y ._2, _3.;\" \"gimple\" } }\n+\n+// And that we *are* passing the int along to V::V.\n+// { dg-final { scan-assembler \"_ZN1VCI21WEi\" } }\n+// { dg-final { scan-tree-dump \"V::V .this, _1.;\" \"gimple\" } }"}, {"sha": "21450196da0e87a2232278f7566e5b9ec9d4bef0", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor24.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor24.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,27 @@\n+// Testcase from P0136\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+struct A { A(int); };\n+struct B : A { using A::A; };\n+\n+struct C1 : B { using B::B; };\n+struct C2 : B { using B::B; };\n+\n+struct D1 : C1, C2 {\n+  using C1::C1;\n+  using C2::C2;\n+};\n+\n+struct V1 : virtual B { using B::B; };\n+struct V2 : virtual B { using B::B; };\n+\n+struct D2 : V1, V2 {\n+  using V1::V1;\n+  using V2::V2;\n+};\n+\n+D1 d1(0); // { dg-error \"\" } ambiguous\n+D2 d2(0); // OK: initializes virtual B base class, which initializes the A base\n+          // class then initializes the V1 and V2 base classes as if by a\n+          // defaulted default constructor"}, {"sha": "66cd2dabb0d26ab949ce537a1a20deb8c7cc4e1d", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor25.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor25.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,9 @@\n+// Testcase from P0136\n+// { dg-do compile { target c++11 } }\n+\n+struct M { M(); M(int); };\n+struct N : M { using M::M; };\n+struct O : M {};\n+struct P : N, O { using N::N; using O::O; };\n+P p(0); // OK: use M(0) to initialize N's base class,\n+        // use M() to initialize O's base class"}, {"sha": "28dc33227a88fa40cb87858e3a78f7a685b5f7f9", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor26.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor26.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,17 @@\n+// Testcase from P0136\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+struct A {\n+  template<typename T> A(T, typename T::type = 0);\n+  A(int);\n+};\n+struct B : A {\n+  using A::A;\n+  B(int);\n+};\n+B b(42L); // now calls B(int), used to call B<long>(long),\n+          // which called A(int) due to substitution failure\n+          // in A<long>(long).\n+\n+// { dg-final { scan-assembler \"_ZN1BC1Ei\" } }"}, {"sha": "97f26346b78a80ac157e9d6cdbd31a53698b7a32", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor27.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor27.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  A(int = 0);\n+};\n+\n+struct B: A\n+{\n+  B();\n+  using A::A;\n+};\n+\n+B b1(1);\n+B b;"}, {"sha": "55e1d8c943f976f60eca8fe95e00468dff452ae5", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor28.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor28.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+struct V { V(int); };\n+struct W : virtual V { using V::V; };\n+struct X : virtual W, virtual V { using W::W; };\n+X x(0);"}, {"sha": "97f26346b78a80ac157e9d6cdbd31a53698b7a32", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor29.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor29.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  A(int = 0);\n+};\n+\n+struct B: A\n+{\n+  B();\n+  using A::A;\n+};\n+\n+B b1(1);\n+B b;"}, {"sha": "494dd91bb80cdd4a1018748de977ac907f2055c6", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor30.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor30.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  A(double);\n+};\n+\n+struct B: A\n+{\n+  B(short);\n+  using A::A;\n+};\n+\n+int main()\n+{\n+  B b(1);\t\t\t// { dg-error \"ambiguous\" }\n+}"}, {"sha": "3ce080d115b01ff72e46888db6b1f3ef3aca0f93", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor31.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor31.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct B;\n+struct A\n+{\n+  A(const B&, int = 0);\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+extern B b;\n+B b2{b};"}, {"sha": "7ce85b0af2edcbfa384d2251aeabe94b60791c66", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor32.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor32.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct B;\n+struct A\n+{\n+  A(const B&, int = 0);\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+  B(B&);\n+};\n+\n+extern const B b;\n+B b2{b};\t\t\t// { dg-error \"\" }"}, {"sha": "0e8520745a966b21c8e2364501c25b4fe4fcb2da", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor33.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor33.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do link { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+struct A\n+{\n+  A() { }\n+  A(const A&);\t\t\t// should never be called\n+};\n+\n+struct B\n+{\n+  B(A) { }\n+};\n+\n+struct C: B\n+{\n+  using B::B;\n+};\n+\n+int main()\n+{\n+  C c{A()};\n+}"}, {"sha": "f47b2a4dc2fcc863eb1f708d087ffc38868de077", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor34.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor34.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+class A\n+{\n+  A(int);\n+  friend void f();\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+void f()\n+{\n+  B b(42);\n+}"}, {"sha": "87f4452c666552b13235b5259f2c51a3a40e6dd5", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor35.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor35.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,21 @@\n+// Core 1715\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fno-new-inheriting-ctors }\n+\n+template<class T> struct S {\n+private:\n+  typedef int X;\n+  friend struct B;\n+};\n+\n+struct B {\n+  template<class T> B(T, typename T::X);\n+};\n+\n+struct D: B {\n+  using B::B;\t\t\t// { dg-prune-output \"private\" }\n+};\n+\n+S<int> s;\n+B b(s, 2); // Okay, thanks to friendship.\n+D d(s, 2); // { dg-error \"\" } was an error before P0136"}, {"sha": "47f69de41b8073833e3a00a45a2acb9dab97de63", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor35a.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor35a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor35a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor35a.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,21 @@\n+// Core 1715\n+// { dg-do compile { target c++11 } }\n+// { dg-options -fnew-inheriting-ctors }\n+\n+template<class T> struct S {\n+private:\n+  typedef int X;\n+  friend struct B;\n+};\n+\n+struct B {\n+  template<class T> B(T, typename T::X);\n+};\n+\n+struct D: B {\n+  using B::B;\n+};\n+\n+S<int> s;\n+B b(s, 2); // Okay, thanks to friendship.\n+D d(s, 2); // Now OK as well."}, {"sha": "1ed939d45fd442c8377d47a6c6da3935d03522ef", "filename": "gcc/testsuite/g++.dg/cpp1z/using1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing1.C?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -0,0 +1,23 @@\n+// Test for hiding of used base functions when all the conversion sequences are\n+// equivalent, needed to avoid a regression on inherited default ctors.\n+\n+struct A\n+{\n+  void f(short,int=0);\n+  void g(char,int=0);\n+};\n+\n+struct B:A\n+{\n+  using A::f;\n+  void f(short);\n+  using A::g;\n+  void g(short);\n+};\n+\n+int main()\n+{\n+  B().f(1);\t\t\t// OK, derived f hides base f for single arg\n+  B().f(1,2);\t\t\t// OK, base f can still be called with two args\n+  B().g(1);\t\t\t// { dg-error \"\" } signatures differ, ambiguous\n+}"}, {"sha": "6899d2a8736c443835877e5fed3e30c4a45f971d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1045,6 +1045,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n   copy_body_data *id = (copy_body_data *) data;\n   tree fn = id->src_fn;\n   tree new_block;\n+  bool copied = false;\n \n   /* Begin by recognizing trees that we'll completely rewrite for the\n      inlining context.  Our output for these trees is completely\n@@ -1241,10 +1242,40 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  *walk_subtrees = 0;\n \t  return NULL;\n \t}\n+      else if (TREE_CODE (*tp) == COND_EXPR)\n+\t{\n+\t  tree cond = TREE_OPERAND (*tp, 0);\n+\t  walk_tree (&cond, copy_tree_body_r, data, NULL);\n+\t  tree folded = fold (cond);\n+\t  if (TREE_CODE (folded) == INTEGER_CST)\n+\t    {\n+\t      /* Only copy the taken branch; for a C++ base constructor clone\n+\t\t inherited from a virtual base, copying the other branch leads\n+\t\t to references to parameters that were optimized away.  */\n+\t      tree branch = (integer_nonzerop (folded)\n+\t\t\t     ? TREE_OPERAND (*tp, 1)\n+\t\t\t     : TREE_OPERAND (*tp, 2));\n+\t      tree type = TREE_TYPE (*tp);\n+\t      if (VOID_TYPE_P (type)\n+\t\t  || type == TREE_TYPE (branch))\n+\t\t{\n+\t\t  *tp = branch;\n+\t\t  return copy_tree_body_r (tp, walk_subtrees, data);\n+\t\t}\n+\t    }\n+\t  /* Avoid copying the condition twice.  */\n+\t  copy_tree_r (tp, walk_subtrees, NULL);\n+\t  TREE_OPERAND (*tp, 0) = cond;\n+\t  walk_tree (&TREE_OPERAND (*tp, 1), copy_tree_body_r, data, NULL);\n+\t  walk_tree (&TREE_OPERAND (*tp, 2), copy_tree_body_r, data, NULL);\n+\t  *walk_subtrees = 0;\n+\t  copied = true;\n+\t}\n \n       /* Here is the \"usual case\".  Copy this tree node, and then\n \t tweak some special cases.  */\n-      copy_tree_r (tp, walk_subtrees, NULL);\n+      if (!copied)\n+\tcopy_tree_r (tp, walk_subtrees, NULL);\n \n       /* If EXPR has block defined, map it to newly constructed block.\n          When inlining we want EXPRs without block appear in the block"}, {"sha": "bb4dee41a550ccba9aa447058e2c61b6a20ab4d6", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -1,3 +1,7 @@\n+2016-11-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_ctor_dtor_name): Handle inheriting constructor.\n+\n 2016-10-31  Mark Wielaard  <mjw@redhat.com>\n \n \t* cplus-dem.c (ada_demangle): Initialize demangled to NULL and"}, {"sha": "46382ccee22e2d4c96c92feee50af7c7fcb4b836", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -2168,6 +2168,13 @@ d_ctor_dtor_name (struct d_info *di)\n     case 'C':\n       {\n \tenum gnu_v3_ctor_kinds kind;\n+\tint inheriting = 0;\n+\n+\tif (d_peek_next_char (di) == 'I')\n+\t  {\n+\t    inheriting = 1;\n+\t    d_advance (di, 1);\n+\t  }\n \n \tswitch (d_peek_next_char (di))\n \t  {\n@@ -2189,7 +2196,12 @@ d_ctor_dtor_name (struct d_info *di)\n \t  default:\n \t    return NULL;\n \t  }\n+\n \td_advance (di, 2);\n+\n+\tif (inheriting)\n+\t  cplus_demangle_type (di);\n+\n \treturn d_make_ctor (di, kind, di->last_name);\n       }\n "}, {"sha": "a56776355bfe0cbb53993b6b0e15e8bcfb7a644a", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f7f784fe7fa68bca218df43ec8965569d6cb5d/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f7f784fe7fa68bca218df43ec8965569d6cb5d/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=31f7f784fe7fa68bca218df43ec8965569d6cb5d", "patch": "@@ -4592,3 +4592,7 @@ __t2m05B500000000000000000_\n \n __10%0__S4_0T0T0\n %0<>::%0(%0<>)\n+\n+# Inheriting constructor\n+_ZN1DCI11BEi\n+D::B(int)"}]}