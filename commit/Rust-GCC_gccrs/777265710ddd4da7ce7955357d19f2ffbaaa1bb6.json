{"sha": "777265710ddd4da7ce7955357d19f2ffbaaa1bb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3MjY1NzEwZGRkNGRhN2NlNzk1NTM1N2QxOWYyZmZiYWFhMWJiNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-03T21:40:24Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-03T21:40:24Z"}, "message": "re PR fortran/20779 (ALLOCATEing the STAT variable not detected)\n\n2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20779\n\tPR fortran/20891\n\t* resolve.c (find_sym_in_expr): New function that returns true\n\tif a symbol is found in an expression.\n\t(resolve_allocate_expr): Check whether the STAT variable is\n\titself allocated in the same statement.  Use the call above to\n\tcheck whether any of the allocated arrays are used in array\n\tspecifications in the same statement.\n\n2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20779\n\tPR fortran/20891\n\t* gfortran.dg/alloc_alloc_expr_1.f90: New test.\n\nFrom-SVN: r117415", "tree": {"sha": "170cb5f42ffd2e03a7edfb74364a54ce4ef30ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/170cb5f42ffd2e03a7edfb74364a54ce4ef30ee3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777265710ddd4da7ce7955357d19f2ffbaaa1bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777265710ddd4da7ce7955357d19f2ffbaaa1bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777265710ddd4da7ce7955357d19f2ffbaaa1bb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/comments", "author": null, "committer": null, "parents": [{"sha": "77b558e2d393bac5f180f4bb77f054bf15a1acf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77b558e2d393bac5f180f4bb77f054bf15a1acf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77b558e2d393bac5f180f4bb77f054bf15a1acf8"}], "stats": {"total": 189, "additions": 171, "deletions": 18}, "files": [{"sha": "ea011dca7e4777972a0d291ec9717882ed901476", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=777265710ddd4da7ce7955357d19f2ffbaaa1bb6", "patch": "@@ -1,3 +1,14 @@\n+2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20779\n+\tPR fortran/20891\n+\t* resolve.c (find_sym_in_expr): New function that returns true\n+\tif a symbol is found in an expression.\n+\t(resolve_allocate_expr): Check whether the STAT variable is\n+\titself allocated in the same statement.  Use the call above to\n+\tcheck whether any of the allocated arrays are used in array\n+\tspecifications in the same statement.\n+\n 2006-10-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* arith.c (gfc_check_real_range):  Use correct exponent range for"}, {"sha": "7639eb737e10ba4da5d8321b563637662847dd92", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 125, "deletions": 18, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=777265710ddd4da7ce7955357d19f2ffbaaa1bb6", "patch": "@@ -3319,6 +3319,81 @@ resolve_deallocate_expr (gfc_expr * e)\n   return SUCCESS;\n }\n \n+/* Returns true if the expression e contains a reference the symbol sym.  */\n+static bool\n+find_sym_in_expr (gfc_symbol *sym, gfc_expr *e)\n+{\n+  gfc_actual_arglist *arg;\n+  gfc_ref *ref;\n+  int i;\n+  bool rv = false;\n+\n+  if (e == NULL)\n+    return rv;\n+\n+  switch (e->expr_type)\n+    {\n+    case EXPR_FUNCTION:\n+      for (arg = e->value.function.actual; arg; arg = arg->next)\n+\trv = rv || find_sym_in_expr (sym, arg->expr);\n+      break;\n+\n+    /* If the variable is not the same as the dependent, 'sym', and\n+       it is not marked as being declared and it is in the same\n+       namespace as 'sym', add it to the local declarations.  */\n+    case EXPR_VARIABLE:\n+      if (sym == e->symtree->n.sym)\n+\treturn true;\n+      break;\n+\n+    case EXPR_OP:\n+      rv = rv || find_sym_in_expr (sym, e->value.op.op1);\n+      rv = rv || find_sym_in_expr (sym, e->value.op.op2);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  if (e->ref)\n+    {\n+      for (ref = e->ref; ref; ref = ref->next)\n+\t{\n+\t  switch (ref->type)\n+\t    {\n+\t    case REF_ARRAY:\n+\t      for (i = 0; i < ref->u.ar.dimen; i++)\n+\t\t{\n+\t\t  rv = rv || find_sym_in_expr (sym, ref->u.ar.start[i]);\n+\t\t  rv = rv || find_sym_in_expr (sym, ref->u.ar.end[i]);\n+\t\t  rv = rv || find_sym_in_expr (sym, ref->u.ar.stride[i]);\n+\t\t}\n+\t      break;\n+\n+\t    case REF_SUBSTRING:\n+\t      rv = rv || find_sym_in_expr (sym, ref->u.ss.start);\n+\t      rv = rv || find_sym_in_expr (sym, ref->u.ss.end);\n+\t      break;\n+\n+\t    case REF_COMPONENT:\n+\t      if (ref->u.c.component->ts.type == BT_CHARACTER\n+\t\t    && ref->u.c.component->ts.cl->length->expr_type\n+\t\t\t\t\t\t!= EXPR_CONSTANT)\n+\t\trv = rv || find_sym_in_expr (sym, ref->u.c.component->ts.cl->length);\n+\n+\t      if (ref->u.c.component->as)\n+\t        for (i = 0; i < ref->u.c.component->as->rank; i++)\n+\t\t  {\n+\t\t    rv = rv || find_sym_in_expr (sym, ref->u.c.component->as->lower[i]);\n+\t\t    rv = rv || find_sym_in_expr (sym, ref->u.c.component->as->upper[i]);\n+\t\t  }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return rv;\n+}\n+\n \n /* Given the expression node e for an allocatable/pointer of derived type to be\n    allocated, get the expression node to be initialized afterwards (needed for\n@@ -3363,10 +3438,17 @@ resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n   gfc_array_ref *ar;\n   gfc_code *init_st;\n   gfc_expr *init_e;\n+  gfc_symbol *sym;\n+  gfc_alloc *a;\n \n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n+  if (code->expr && code->expr->expr_type == EXPR_VARIABLE)\n+    sym = code->expr->symtree->n.sym;\n+  else\n+    sym = NULL;\n+\n   /* Make sure the expression is allocatable or a pointer.  If it is\n      pointer, the next-to-last reference must be a pointer.  */\n \n@@ -3387,6 +3469,14 @@ resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n       pointer = e->symtree->n.sym->attr.pointer;\n       dimension = e->symtree->n.sym->attr.dimension;\n \n+      if (sym == e->symtree->n.sym)\n+\t{\n+\t  gfc_error (\"The STAT variable '%s' in an ALLOCATE statement must \"\n+\t\t     \"not be allocated in the same statement at %L\",\n+\t\t      sym->name, &e->where);\n+\t  return FAILURE;\n+\t}\n+\n       for (ref = e->ref; ref; ref2 = ref, ref = ref->next)\n \tswitch (ref->type)\n \t  {\n@@ -3449,34 +3539,51 @@ resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n       return FAILURE;\n     }\n \n-  if (ref2->u.ar.type == AR_ELEMENT)\n-    return SUCCESS;\n-\n   /* Make sure that the array section reference makes sense in the\n     context of an ALLOCATE specification.  */\n \n   ar = &ref2->u.ar;\n \n   for (i = 0; i < ar->dimen; i++)\n-    switch (ar->dimen_type[i])\n-      {\n-      case DIMEN_ELEMENT:\n-\tbreak;\n+    {\n+      if (ref2->u.ar.type == AR_ELEMENT)\n+\tgoto check_symbols;\n \n-      case DIMEN_RANGE:\n-\tif (ar->start[i] != NULL\n-\t    && ar->end[i] != NULL\n-\t    && ar->stride[i] == NULL)\n+      switch (ar->dimen_type[i])\n+\t{\n+\tcase DIMEN_ELEMENT:\n \t  break;\n \n-\t/* Fall Through...  */\n+\tcase DIMEN_RANGE:\n+\t  if (ar->start[i] != NULL\n+\t      && ar->end[i] != NULL\n+\t      && ar->stride[i] == NULL)\n+\t    break;\n \n-      case DIMEN_UNKNOWN:\n-      case DIMEN_VECTOR:\n-\tgfc_error (\"Bad array specification in ALLOCATE statement at %L\",\n-\t\t   &e->where);\n-\treturn FAILURE;\n-      }\n+\t  /* Fall Through...  */\n+\n+\tcase DIMEN_UNKNOWN:\n+\tcase DIMEN_VECTOR:\n+\t  gfc_error (\"Bad array specification in ALLOCATE statement at %L\",\n+\t\t     &e->where);\n+\t  return FAILURE;\n+\t}\n+\n+check_symbols:\n+\n+      for (a = code->ext.alloc_list; a; a = a->next)\n+\t{\n+\t  sym = a->expr->symtree->n.sym;\n+\t  if ((ar->start[i] != NULL && find_sym_in_expr (sym, ar->start[i]))\n+\t\t || (ar->end[i] != NULL && find_sym_in_expr (sym, ar->end[i])))\n+\t    {\n+\t      gfc_error (\"'%s' must not appear an the array specification at \"\n+\t\t\t \"%L in the same ALLOCATE statement where it is \"\n+\t\t\t \"itself allocated\", sym->name, &ar->where);\n+\t      return FAILURE;\n+\t    }\n+\t}\n+    }\n \n   return SUCCESS;\n }"}, {"sha": "ea575ee0d1872c200f74f63cf1d99c2ba1da0aae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=777265710ddd4da7ce7955357d19f2ffbaaa1bb6", "patch": "@@ -1,3 +1,9 @@\n+2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20779\n+\tPR fortran/20891\n+\t* gfortran.dg/alloc_alloc_expr_1.f90: New test.\n+\n 2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29284"}, {"sha": "477643855a2bd8763c1d7f08924c09d6967739f8", "filename": "gcc/testsuite/gfortran.dg/alloc_alloc_expr_1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777265710ddd4da7ce7955357d19f2ffbaaa1bb6/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90?ref=777265710ddd4da7ce7955357d19f2ffbaaa1bb6", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+program fc011\n+! Tests fix for PR20779 and PR20891.\n+! Submitted by Walt Brainerd, The Fortran Company\n+! and by Joost VandeVondele  <jv244@cam.ac.uk> \n+\n+! This program violates requirements of 6.3.1 of the F95 standard.\n+\n+! An allocate-object, or a subobject of an allocate-object, shall not appear\n+! in a bound in the same ALLOCATE statement. The stat-variable shall not appear\n+! in a bound in the same ALLOCATE statement.\n+\n+! The stat-variable shall not be allocated within the ALLOCATE statement in which\n+! it appears; nor shall it depend on the value, bounds, allocation status, or\n+! association status of any allocate-object or subobject of an allocate-object\n+! allocated in the same statement.\n+\n+  integer, pointer :: PTR\n+  integer, allocatable :: ALLOCS(:)\n+\n+  allocate (PTR, stat=PTR) ! { dg-error \"allocated in the same statement\" }\n+\n+  allocate (ALLOCS(10),stat=ALLOCS(1)) ! { dg-error \"allocated in the same statement\" }\n+\n+  ALLOCATE(PTR,ALLOCS(PTR)) ! { dg-error \"same ALLOCATE statement\" }\n+\n+  print *, 'This program has three errors', PTR, ALLOC(1)\n+\n+end program fc011"}]}