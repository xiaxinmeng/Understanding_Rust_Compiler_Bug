{"sha": "04bf686df7a11a874c79c7e3c0001ff3f523109d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRiZjY4NmRmN2ExMWE4NzRjNzljN2UzYzAwMDFmZjNmNTIzMTA5ZA==", "commit": {"author": {"name": "Hartmut Penner", "email": "hpenner@de.ibm.com", "date": "2004-01-20T16:54:34Z"}, "committer": {"name": "Hartmut Penner", "email": "hpenner@gcc.gnu.org", "date": "2004-01-20T16:54:34Z"}, "message": "* gcc.dg/ppc64-abi-2.c: New test.\n\nFrom-SVN: r76212", "tree": {"sha": "38959b03ec8773fd5a7627cb986b448367dae415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38959b03ec8773fd5a7627cb986b448367dae415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04bf686df7a11a874c79c7e3c0001ff3f523109d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04bf686df7a11a874c79c7e3c0001ff3f523109d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04bf686df7a11a874c79c7e3c0001ff3f523109d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04bf686df7a11a874c79c7e3c0001ff3f523109d/comments", "author": null, "committer": null, "parents": [{"sha": "c72d6c267a8f31bf3e4b150b74d9196374d8af16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c72d6c267a8f31bf3e4b150b74d9196374d8af16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c72d6c267a8f31bf3e4b150b74d9196374d8af16"}], "stats": {"total": 409, "additions": 409, "deletions": 0}, "files": [{"sha": "9577cda1a32a43d98e260f2bba4197a81e43a19f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04bf686df7a11a874c79c7e3c0001ff3f523109d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04bf686df7a11a874c79c7e3c0001ff3f523109d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04bf686df7a11a874c79c7e3c0001ff3f523109d", "patch": "@@ -1,3 +1,7 @@\n+2004-01-20  Hartmut Penner  <hpenner@de.ibm.com>\n+\n+\t* gcc.dg/ppc64-abi-2.c: New test.\n+\n 2004-01-18  James A. Morrison  <ja2morri@uwaterloo.ca>\n \n         * lib/treelang.exp: Fill out this file."}, {"sha": "ab0e1a14710c5ac360004ab2a8b614c197453f25", "filename": "gcc/testsuite/gcc.dg/ppc64-abi-2.c", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04bf686df7a11a874c79c7e3c0001ff3f523109d/gcc%2Ftestsuite%2Fgcc.dg%2Fppc64-abi-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04bf686df7a11a874c79c7e3c0001ff3f523109d/gcc%2Ftestsuite%2Fgcc.dg%2Fppc64-abi-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fppc64-abi-2.c?ref=04bf686df7a11a874c79c7e3c0001ff3f523109d", "patch": "@@ -0,0 +1,405 @@\n+/* { dg-do run { target powerpc64-*-linux* } } */\n+/* { dg-options \"-O2 -fprofile -mprofile-kernel -maltivec -mabi=altivec\" } */\n+#include <stdarg.h>\n+#include <signal.h>\n+#include <altivec.h>\n+\n+/* Testcase to check for ABI compliance of parameter passing\n+   for the PowerPC64 ABI.  */\n+\n+void __attribute__((no_instrument_function))\n+sig_ill_handler (int sig)\n+{\n+    exit(0);\n+}\n+\n+extern void abort (void);\n+\n+typedef struct\n+{\n+  unsigned long gprs[8];\n+  double fprs[13];\n+  long pad;\n+  vector int vrs[12];\n+} reg_parms_t;\n+\n+reg_parms_t gparms;\n+\n+/* _mcount call is done on Linux ppc64 early in the prologue.\n+   my_mcount will provide a entry point _mcount,\n+   which will save all register to gparms. \n+   Note that _mcount need to restore lr to original value,\n+   therefor use ctr to return.  \n+*/\n+\n+void __attribute__((no_instrument_function))\n+my_mcount() \n+{\n+  asm volatile (\".type\t_mcount,@function\\n\\t\"\n+\t\t\".globl\t_mcount\\n\\t\"\n+\t\t\"_mcount:\\n\\t\"\n+                \"mflr 0\\n\\t\"\n+                \"mtctr 0\\n\\t\"\n+                \"ld 0,16(1)\\n\\t\"\n+\t\t\"mtlr 0\\n\\t\"\n+\t\t\"ld 11,gparms@got(2)\\n\\t\" \n+\t\t\"std 3,0(11)\\n\\t\"\t\t\n+\t\t\"std 4,8(11)\\n\\t\"\n+\t\t\"std 5,16(11)\\n\\t\"\t\n+\t\t\"std 6,24(11)\\n\\t\"\t\n+\t\t\"std 7,32(11)\\n\\t\"\t\n+\t\t\"std 8,40(11)\\n\\t\"\t\n+\t\t\"std 9,48(11)\\n\\t\"\t\n+\t\t\"std 10,56(11)\\n\\t\"   \n+\t\t\"stfd 1,64(11)\\n\\t\"\t\n+\t\t\"stfd 2,72(11)\\n\\t\"\t\n+\t\t\"stfd 3,80(11)\\n\\t\"\t\n+\t\t\"stfd 4,88(11)\\n\\t\"\t\n+\t\t\"stfd 5,96(11)\\n\\t\"\t\n+\t\t\"stfd 6,104(11)\\n\\t\"\t\n+\t\t\"stfd 7,112(11)\\n\\t\"\t\n+\t\t\"stfd 8,120(11)\\n\\t\"\t\n+\t\t\"stfd 9,128(11)\\n\\t\"\t\n+\t\t\"stfd 10,136(11)\\n\\t\"\t\n+\t\t\"stfd 11,144(11)\\n\\t\"\t\n+\t\t\"stfd 12,152(11)\\n\\t\" \n+\t\t\"stfd 13,160(11)\\n\\t\" \n+\t\t\"li 3,176\\n\\t\"        \n+\t\t\"stvx 2,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\" \n+\t\t\"stvx 3,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 4,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 5,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 6,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 7,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 8,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 9,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 10,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 11,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 12,3,11\\n\\t\"\t\n+\t\t\"addi 3,3,16\\n\\t\"     \n+\t\t\"stvx 13,3,11\\n\\t\"\t\n+\t\t\"ld 3,0(11)\\n\\t\"\n+\t\t\"bctr\");\n+}\n+\n+/* Stackframe structure relevant for parameter passing.  */\n+typedef union\n+{\n+  double d;\n+  unsigned long l;\n+  unsigned int i[2];\n+} parm_t;\n+\n+typedef struct sf\n+{\n+  struct sf *backchain;\n+  long a1;\n+  long a2;\n+  long a3;\n+  long a4;\n+  long a5;\n+  parm_t slot[100];\n+} stack_frame_t;\n+\n+typedef union\n+{\n+  unsigned int i[4];\n+  unsigned long l[2];\n+  vector int v;\n+} vector_int_t;\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   v : vpr 2\n+   i : gpr 7\n+*/\n+void __attribute__ ((noinline))\n+fcvi (char *s, vector int v, int i)\n+{\n+  reg_parms_t lparms = gparms;\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort();\n+\n+  if (!vec_all_eq (v, lparms.vrs[0]))\n+    abort ();\n+\n+  if ((long) i != lparms.gprs[4])\n+    abort();\n+}\n+/* Paramter passing.\n+   s : gpr 3\n+   v : vpr 2\n+   w : vpr 3\n+*/\n+\n+void __attribute__ ((noinline))\n+fcvv (char *s, vector int v, vector int w)\n+{\n+  vector int a, c = {6, 8, 10, 12};\n+  reg_parms_t lparms = gparms;\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort();\n+\n+  if (!vec_all_eq (v, lparms.vrs[0]))\n+    abort ();\n+\n+  if (!vec_all_eq (w, lparms.vrs[1]))\n+    abort ();\n+\n+  a = vec_add (v,w);\n+\n+  if (!vec_all_eq (a, c))\n+    abort ();\n+}\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   i : gpr 4\n+   v : vpr 2\n+   w : vpr 3\n+*/\n+void __attribute__ ((noinline))\n+fcivv (char *s, int i, vector int v, vector int w)\n+{\n+  vector int a, c = {6, 8, 10, 12};\n+  reg_parms_t lparms = gparms;\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort();\n+\n+  if ((long) i != lparms.gprs[1])\n+    abort();\n+\n+  if (!vec_all_eq (v, lparms.vrs[0]))\n+    abort ();\n+\n+  if (!vec_all_eq (w, lparms.vrs[1]))\n+    abort ();\n+\n+  a = vec_add (v,w);\n+  \n+  if (!vec_all_eq (a, c))\n+    abort ();\n+}\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   v : slot 2-3\n+   w : slot 4-5\n+*/\n+\n+void __attribute__ ((noinline))\n+fcevv (char *s, ...)\n+{\n+  vector int a, c = {6, 8, 10, 12};\n+  vector int v,w;\n+  stack_frame_t *sp;\n+  reg_parms_t lparms = gparms;\n+  va_list arg;\n+\n+  va_start (arg, s);\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort();\n+\n+  v = va_arg(arg, vector int);\n+  w = va_arg(arg, vector int);\n+  a = vec_add (v,w);\n+  \n+  if (!vec_all_eq (a, c))\n+    abort ();\n+\n+  /* Go back one frame.  */\n+  sp = __builtin_frame_address(0);\n+  sp = sp->backchain;\n+  \n+  if (sp->slot[2].l != 0x100000002ULL\n+      || sp->slot[4].l != 0x500000006ULL)\n+    abort();\n+}\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   i : gpr 4\n+   j : gpr 5\n+   v : slot 4-5\n+   w : slot 6-7\n+*/\n+void __attribute__ ((noinline))\n+fciievv (char *s, int i, int j, ...)\n+{\n+  vector int a, c = {6, 8, 10, 12};\n+  vector int v,w;\n+  stack_frame_t *sp;\n+  reg_parms_t lparms = gparms;\n+  va_list arg;\n+\n+  va_start (arg, j);\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort();\n+\n+  if ((long) i != lparms.gprs[1])\n+    abort();\n+\n+  if ((long) j != lparms.gprs[2])\n+    abort();\n+  \n+  v = va_arg(arg, vector int);\n+  w = va_arg(arg, vector int);\n+  a = vec_add (v,w);\n+  \n+  if (!vec_all_eq (a, c))\n+    abort ();\n+\n+  sp = __builtin_frame_address(0);\n+  sp = sp->backchain;\n+  \n+  if (sp->slot[4].l != 0x100000002ULL\n+      || sp->slot[6].l != 0x500000006ULL)\n+    abort();\n+}\n+\n+void __attribute__ ((noinline))\n+fcvevv (char *s, vector int x, ...)\n+{\n+  vector int a, c = {7, 10, 13, 16};\n+  vector int v,w;\n+  stack_frame_t *sp;\n+  reg_parms_t lparms = gparms;\n+  va_list arg;\n+\n+  va_start (arg, x);\n+  \n+  v = va_arg(arg, vector int);\n+  w = va_arg(arg, vector int);\n+\n+  a = vec_add (v,w);\n+  a = vec_add (a, x);\n+ \n+  if (!vec_all_eq (a, c))\n+    abort ();\n+\n+  sp = __builtin_frame_address(0);\n+  sp = sp->backchain;\n+  \n+  if (sp->slot[4].l != 0x100000002ULL\n+      || sp->slot[6].l != 0x500000006ULL)\n+    abort();\n+}\n+\n+void fnp_cvvvv();\n+\n+int __attribute__((no_instrument_function, noinline))\n+main1() \n+{   \n+  char *s = \"vv\";\n+  vector int v = {1, 2, 3, 4};\n+  vector int w = {5, 6, 7, 8};\n+ \n+  fcvi (s, v, 2);\n+  fcvv (s, v, w);\n+  fnp_cvvvv (s, v, w, v, w);\n+  fcivv (s, 1, v, w);\n+  fcevv (s, v, w);\n+  fciievv (s, 1, 2, v, w);\n+  fcvevv (s, v, v, w);\n+  return 0;\n+}\n+\n+int __attribute__((no_instrument_function)) \n+main()\n+{\n+  /* Exit on systems without altivec.  */\n+  signal (SIGILL, sig_ill_handler);\n+  /* Altivec instruction, 'vor %v0,%v0,%v0'.  */\n+  asm volatile (\".long 0x10000484\");\n+  signal (SIGILL, SIG_DFL);\n+\n+  return main1 ();\n+}\n+\n+/* Paramter passing.\n+   Function called with no prototype.\n+   s : gpr 3\n+   v : vpr 2 gpr 5-6\n+   w : vpr 3 gpr 7-8\n+   x : vpr 4 gpr 9-10\n+   y : vpr 5 slot 8-9\n+*/\n+void\n+fnp_cvvvv (char *s, vector int v, vector int w,\n+\t   vector int x, vector int y)\n+{\n+  vector int a, c = {12, 16, 20, 24};\n+  reg_parms_t lparms = gparms;\n+  stack_frame_t *sp;\n+  vector_int_t v0, v1, v2, v3;\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort();\n+\n+  if (!vec_all_eq (v, lparms.vrs[0]))\n+    abort ();\n+\n+  if (!vec_all_eq (w, lparms.vrs[1]))\n+    abort ();\n+\n+  if (!vec_all_eq (x, lparms.vrs[2]))\n+    abort ();\n+\n+  if (!vec_all_eq (y, lparms.vrs[3]))\n+    abort ();\n+\n+  a = vec_add (v,w);\n+  a = vec_add (a,x);  \n+  a = vec_add (a,y);  \n+  \n+  if (!vec_all_eq (a, c))\n+    abort ();\n+  \n+  v0.v = lparms.vrs[0];\n+  v1.v = lparms.vrs[1];\n+  v2.v = lparms.vrs[2];\n+  v3.v = lparms.vrs[3];\n+\n+  if (v0.l[0] != lparms.gprs[2])\n+    abort ();\n+\n+  if (v0.l[1] != lparms.gprs[3])\n+    abort ();\n+\n+  if (v1.l[0] != lparms.gprs[4])\n+    abort ();\n+\n+  if (v1.l[1] != lparms.gprs[5])\n+    abort ();\n+\n+  if (v2.l[0] != lparms.gprs[6])\n+    abort ();\n+\n+  if (v2.l[1] != lparms.gprs[7])\n+    abort ();\n+\n+  sp = __builtin_frame_address(0);\n+  sp = sp->backchain;\n+  \n+  if (sp->slot[8].l != v3.l[0])\n+    abort ();\n+\n+  if (sp->slot[9].l != v3.l[1])\n+    abort ();\n+}  \n+  "}]}