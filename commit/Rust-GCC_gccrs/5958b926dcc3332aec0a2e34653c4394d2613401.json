{"sha": "5958b926dcc3332aec0a2e34653c4394d2613401", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk1OGI5MjZkY2MzMzMyYWVjMGEyZTM0NjUzYzQzOTRkMjYxMzQwMQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-06-30T11:01:36Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-06-30T11:10:20Z"}, "message": "Use CHARACTER(kind) string for calculating the type hash.\n\nThis regression came about because of a change in the way\ntypes are displayed in error messages.  The character\nrepresentation is also used to calculate the hashes for\nour types, so this patch restores the old behavior if\nwe are indeed calculating a hash.\n\nThe test case also checks for the specific hash value because\nchanging that would be an ABI change, which we should not\nbe doing unintentionally.\n\ngcc/fortran/ChangeLog:\n\n2020-06-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/95355\n\t* gfortran.h (gfc_typename): Add optional argument for_hash.\n\t* misc.c (gfc_typename): When for_hash is true, just retur\n\t  CHARACTER(kind).\n\t* class.c (gfc_intrinsic_hash_value): Call gfc_typename with\n\t  for_hash = true.", "tree": {"sha": "a883a14d091366ae9442362f8ec6d327b0e469de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a883a14d091366ae9442362f8ec6d327b0e469de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5958b926dcc3332aec0a2e34653c4394d2613401", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5958b926dcc3332aec0a2e34653c4394d2613401", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5958b926dcc3332aec0a2e34653c4394d2613401", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5958b926dcc3332aec0a2e34653c4394d2613401/comments", "author": null, "committer": null, "parents": [{"sha": "8dc933c12f489626339b3ba1a8e2dc23eb4de98e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc933c12f489626339b3ba1a8e2dc23eb4de98e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc933c12f489626339b3ba1a8e2dc23eb4de98e"}], "stats": {"total": 55, "additions": 52, "deletions": 3}, "files": [{"sha": "08705c7e95dba8f2a269b20673049a231dfcf05e", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5958b926dcc3332aec0a2e34653c4394d2613401/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5958b926dcc3332aec0a2e34653c4394d2613401/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=5958b926dcc3332aec0a2e34653c4394d2613401", "patch": "@@ -564,7 +564,7 @@ unsigned int\n gfc_intrinsic_hash_value (gfc_typespec *ts)\n {\n   unsigned int hash = 0;\n-  const char *c = gfc_typename (ts);\n+  const char *c = gfc_typename (ts, true);\n   int i, len;\n \n   len = strlen (c);"}, {"sha": "24c5101c4cb92ffee6749fe4028bc38bfaf64e90", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5958b926dcc3332aec0a2e34653c4394d2613401/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5958b926dcc3332aec0a2e34653c4394d2613401/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5958b926dcc3332aec0a2e34653c4394d2613401", "patch": "@@ -2931,7 +2931,7 @@ void gfc_clear_ts (gfc_typespec *);\n FILE *gfc_open_file (const char *);\n const char *gfc_basic_typename (bt);\n const char *gfc_dummy_typename (gfc_typespec *);\n-const char *gfc_typename (gfc_typespec *);\n+const char *gfc_typename (gfc_typespec *, bool for_hash = false);\n const char *gfc_typename (gfc_expr *);\n const char *gfc_op2string (gfc_intrinsic_op);\n const char *gfc_code2string (const mstring *, int);"}, {"sha": "65bcfa6162f513d4fddc752a6b450df7027f6284", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5958b926dcc3332aec0a2e34653c4394d2613401/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5958b926dcc3332aec0a2e34653c4394d2613401/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=5958b926dcc3332aec0a2e34653c4394d2613401", "patch": "@@ -122,7 +122,7 @@ gfc_basic_typename (bt type)\n    the argument list of a single statement.  */\n \n const char *\n-gfc_typename (gfc_typespec *ts)\n+gfc_typename (gfc_typespec *ts, bool for_hash)\n {\n   static char buffer1[GFC_MAX_SYMBOL_LEN + 7];  /* 7 for \"TYPE()\" + '\\0'.  */\n   static char buffer2[GFC_MAX_SYMBOL_LEN + 7];\n@@ -149,6 +149,12 @@ gfc_typename (gfc_typespec *ts)\n       sprintf (buffer, \"LOGICAL(%d)\", ts->kind);\n       break;\n     case BT_CHARACTER:\n+      if (for_hash)\n+\t{\n+\t  sprintf (buffer, \"CHARACTER(%d)\", ts->kind);\n+\t  break;\n+\t}\n+\n       if (ts->u.cl && ts->u.cl->length)\n \tlength = gfc_mpz_get_hwi (ts->u.cl->length->value.integer);\n       if (ts->kind == gfc_default_character_kind)"}, {"sha": "31203cd18fcb41da92d2d1d46b4f88ce2432c99b", "filename": "gcc/testsuite/gfortran.dg/select_type_49.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5958b926dcc3332aec0a2e34653c4394d2613401/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_49.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5958b926dcc3332aec0a2e34653c4394d2613401/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_49.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_49.f90?ref=5958b926dcc3332aec0a2e34653c4394d2613401", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! PR 95366 - this did not work due the wrong hashes\n+! being generated for CHARACTER variables.\n+MODULE mod1\n+  implicit none\n+  integer :: tst(3)\n+CONTAINS\n+  subroutine showpoly(poly)\n+    CLASS(*), INTENT(IN) :: poly(:)\n+    SELECT TYPE (poly)\n+    TYPE IS(INTEGER)\n+       tst(1) = tst(1) + 1\n+    TYPE IS(character(*))\n+       tst(2) = tst(2) + 1\n+    class default\n+       tst(3) = tst(3) + 1\n+    end select\n+  end subroutine showpoly\n+END MODULE mod1\n+MODULE mod2\n+  implicit none\n+CONTAINS\n+subroutine polytest2()\n+   use mod1\n+   integer :: a(1)\n+   character(len=42) :: c(1)\n+   call showpoly(a)\n+   if (any(tst /= [1,0,0])) stop 1\n+   call showpoly(c)\n+   if (any(tst /= [1,1,0])) stop 2\n+end subroutine polytest2\n+END MODULE mod2\n+PROGRAM testpoly\n+  use mod2\n+  CALL polytest2()\n+END PROGRAM testpoly\n+! The value of the hashes are also checked.  If you get\n+! a failure here, be aware that changing that value is\n+! an ABI change.\n+\n+! { dg-final { scan-tree-dump-times \"== 17759\" 1 \"original\" } }  \n+! { dg-final { scan-tree-dump-times \"== 85893463\" 1 \"original\" } }"}]}