{"sha": "60cabde622dc0b17a53604aadb5788d304a005d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBjYWJkZTYyMmRjMGIxN2E1MzYwNGFhZGI1Nzg4ZDMwNGEwMDVkNQ==", "commit": {"author": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-11-07T23:23:40Z"}, "committer": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-11-07T23:23:40Z"}, "message": "implemented hash table expansion as suggested by rms.\n\nFrom-SVN: r59", "tree": {"sha": "db5b04ec364447c860873097119fc1c819f59617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db5b04ec364447c860873097119fc1c819f59617"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60cabde622dc0b17a53604aadb5788d304a005d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cabde622dc0b17a53604aadb5788d304a005d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60cabde622dc0b17a53604aadb5788d304a005d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cabde622dc0b17a53604aadb5788d304a005d5/comments", "author": null, "committer": null, "parents": [{"sha": "eed5ef66e7953fcf7eb1e63740ed90cb9483624e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed5ef66e7953fcf7eb1e63740ed90cb9483624e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eed5ef66e7953fcf7eb1e63740ed90cb9483624e"}], "stats": {"total": 128, "additions": 97, "deletions": 31}, "files": [{"sha": "260c9d9f042dbd66d1018f12d87213b8e9b9adc6", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 67, "deletions": 17, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cabde622dc0b17a53604aadb5788d304a005d5/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cabde622dc0b17a53604aadb5788d304a005d5/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=60cabde622dc0b17a53604aadb5788d304a005d5", "patch": "@@ -16,10 +16,13 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.c,v 0.1 1991/10/24 00:45:39 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.c,v 0.2 1991/11/07 22:30:54 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/10/24 00:45:39 $\n+  $Date: 1991/11/07 22:30:54 $\n   $Log: hash.c,v $\n+ * Revision 0.2  1991/11/07  22:30:54  dennisg\n+ * added copyleft\n+ *\n  * Revision 0.1  1991/10/24  00:45:39  dennisg\n  * Initial check in.  Preliminary development stage.\n  *\n@@ -33,18 +36,27 @@\n #include  <libc.h>\n #include  <math.h>\n \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* These two macros determine\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhen a hash table is full and\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tby how much it should be \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpanded respectively.\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThese equations are \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpercentages. */\n+#define\tFULLNESS\t\t( 100 / 75 )\n+#define\tEXPANSION\t\t( 135 / 100 )\n \n                                                 /* Local forward decl. */\n   u_int hashValue( Cache_t, void* );\n \n \n-Cache_t hash_new( u_int numberOfBuckets ) {\n+Cache_t hash_new( u_int sizeOfHash ) {\n \n   Cache_t retCache;\n   int     i;\n \n \n-  assert( numberOfBuckets );\n+  assert( sizeOfHash );\n \n                                                 /* Allocate the cache \n                                                   structure.  calloc() insures\n@@ -57,16 +69,16 @@ Cache_t hash_new( u_int numberOfBuckets ) {\n                                                   buckets for the cache.  \n                                                   calloc() initializes all of \n                                                   the pointers to NULL. */\n-  retCache->theNodeTable = calloc( numberOfBuckets, sizeof( CacheNode_t ));\n+  retCache->theNodeTable = calloc( sizeOfHash, sizeof( CacheNode_t ));\n   assert( retCache->theNodeTable );\n   \n-  retCache->numberOfBuckets = numberOfBuckets;\n+  retCache->sizeOfHash = sizeOfHash;\n \n                                                 /* Calculate the number of \n                                                   bits required to represent \n                                                   the hash mask. */\n   retCache->numberOfMaskBits = \n-    ceil( log( retCache->numberOfBuckets ) / log( 2 ));\n+    ceil( log( retCache->sizeOfHash ) / log( 2 ));\n \n                                                 /* Form a bit mask for the \n                                                   hash. */\n@@ -97,9 +109,9 @@ void hash_delete( Cache_t theCache ) {\n }\n \n \n-void hash_add( Cache_t theCache, void* aKey, void* aValue ) {\n+void hash_add( Cache_t* theCache, void* aKey, void* aValue ) {\n \n-  u_int       indx = hashValue( theCache, aKey );\n+  u_int       indx = hashValue( *theCache, aKey );\n   CacheNode_t aCacheNode = calloc( 1, sizeof( CacheNode ));\n \n \n@@ -108,27 +120,61 @@ void hash_add( Cache_t theCache, void* aKey, void* aValue ) {\n                                                 /* Initialize the new node. */\n   aCacheNode->theKey    = aKey;\n   aCacheNode->theValue  = aValue;\n-  aCacheNode->nextNode  = ( *theCache->theNodeTable )[ indx ];\n+  aCacheNode->nextNode  = ( *( **theCache ).theNodeTable )[ indx ];\n   \n                                                 /* Debugging.\n                                                 \n                                                   Check the list for another \n                                                   key. */\n #ifdef DEBUG\n-    { CacheNode_t checkHashNode = ( *theCache->theNodeTable )[ indx ];\n+    { CacheNode_t checkHashNode = ( *( **theCache ).theNodeTable )[ indx ];\n     \n       while( checkHashNode ) {\n     \n         assert( checkHashNode->theKey != aKey );\n         checkHashNode = checkHashNode->nextNode;\n       }\n     }\n+#endif\n \n                                                 /* Install the node as the\n                                                   first element on the list. */\n-  ( *theCache->theNodeTable )[ indx ] = aCacheNode;\n-\n-#endif\n+  ( *( **theCache ).theNodeTable )[ indx ] = aCacheNode;\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Bump the number of entries\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin the cache. */\n+\t++( **theCache ).entriesInHash;\n+\t\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Check the hash table's\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfullness.   We're going\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tto expand if it is above\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe fullness level. */\n+\tif(( **theCache ).entriesInHash * FULLNESS ) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* The hash table has reached\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tits fullness level.  Time to\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpand it. \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tI'm using a slow method \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\there but is built on other\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprimitive functions thereby\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincreasing its \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcorrectness. */\n+\t\tCache_t\t\t\tnewCache = hash_new(( **theCache ).sizeOfHash * EXPANSION );\n+\t\tCacheNode_t\taNode = NULL;\n+\t\t\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Copy the nodes from the\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfirst hash table to the\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew one. */\n+\t\twhile( aNode = hash_next( *theCache, aNode ))\n+\t\t\thash_add( &newCache, aNode->theKey, aNode->theValue );\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Trash the old cache. */\n+\t\thash_delete( *theCache );\n+\t\t\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Return a pointer to the new\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thash table. */\n+\t\t*theCache = newCache;\n+\t}\n }\n \n \n@@ -165,6 +211,10 @@ void hash_remove( Cache_t theCache, void* aKey ) {\n     } while( !removed && aCacheNode );\n     assert( removed );\n   }\n+\t\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Decrement the number of\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentries in the hash table. */\n+\t--theCache->entriesInHash;\n }\n \n \n@@ -220,13 +270,13 @@ CacheNode_t hash_next( Cache_t theCache, CacheNode_t aCacheNode ) {\n                                                 /* If the list isn't exhausted \n                                                   then search the buckets for \n                                                   other nodes. */\n-  if( theCache->lastBucket < theCache->numberOfBuckets ) {\n+  if( theCache->lastBucket < theCache->sizeOfHash ) {\n                                                 /*  Scan the remainder of the \n                                                   buckets looking for an entry\n                                                   at the head of the list.  \n                                                   Return the first item \n                                                   found. */\n-    while( theCache->lastBucket < theCache->numberOfBuckets )\n+    while( theCache->lastBucket < theCache->sizeOfHash )\n       if(( *theCache->theNodeTable )[ theCache->lastBucket ])\n         return ( *theCache->theNodeTable )[ theCache->lastBucket ];\n       else\n@@ -250,6 +300,6 @@ u_int hashValue( Cache_t theCache, void* aKey ) {\n   for( i = 0; i < ( sizeof( aKey ) * 8 ); i += theCache->numberOfMaskBits )\n     hash ^= (( u_int )aKey ) >> i ;\n \n-  return ( hash & theCache->mask ) % theCache->numberOfBuckets;\n+  return ( hash & theCache->mask ) % theCache->sizeOfHash;\n }\n "}, {"sha": "ae87d5b28ec14f305297737daa1fc6e1bfe8f382", "filename": "gcc/objc/hash.h", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cabde622dc0b17a53604aadb5788d304a005d5/gcc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cabde622dc0b17a53604aadb5788d304a005d5/gcc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.h?ref=60cabde622dc0b17a53604aadb5788d304a005d5", "patch": "@@ -21,10 +21,13 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.h,v 0.1 1991/10/24 00:45:39 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.h,v 0.2 1991/11/07 22:30:54 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/10/24 00:45:39 $\n+  $Date: 1991/11/07 22:30:54 $\n   $Log: hash.h,v $\n+ * Revision 0.2  1991/11/07  22:30:54  dennisg\n+ * added copyleft\n+ *\n  * Revision 0.1  1991/10/24  00:45:39  dennisg\n  * Initial check in.  Preliminary development stage.\n  *\n@@ -79,16 +82,25 @@ typedef struct cache {\n    */\n   CacheNode_t (* theNodeTable )[];                /* Pointer to an array of\n                                                     hash nodes. */\n-  u_int       numberOfBuckets,                    /* Number of buckets \n+\t/*\n+\t * Variables used to track the size of the hash\n+\t *\ttable so to determine when to resize it.\n+\t */\n+  u_int       sizeOfHash,                         /* Number of buckets \n                                                     allocated for the hash\n                                                     table (number of array\n                                                     entries allocated for\n-                                                    \"theCache\"). */\n-              mask,                               /* Mask used when computing\n-                                                    a hash value.  The number\n-                                                    of bits set in the mask\n-                                                    is contained in the next\n-                                                    member variable. */\n+                                                    \"theNodeTable\"). */\n+\t\t\t\t\t\t\tentriesInHash;\t\t\t\t\t\t\t\t\t\t\t/* Current number of entries\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin ther hash table. */\n+\t/*\n+\t * Variables used to compute hash\n+\t *\tvalues.\n+\t */\n+  u_int       mask,                               /* The number of bits set \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin the mask that is\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontained in the next \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmember variable. */\n               numberOfMaskBits;                   /* Number of bits used for\n                                                     the mask.  Useful for \n                                                     efficient hash value\n@@ -110,16 +122,20 @@ typedef struct cache {\n                                                   size taken as a parameter. \n                                                     A value of 0 is not \n                                                   allowed. */ \n-Cache_t hash_new( u_int numberOfBuckets );\n+Cache_t hash_new( u_int sizeOfHash );\n                                                 /* Deallocate all of the\n                                                   hash nodes and the cache\n                                                   itself. */\n void hash_delete( Cache_t theCache );\n                                                 /* Add the key/value pair\n-                                                  to the hash table.  assert()\n-                                                  if the key is already in\n-                                                  the hash. */\n-void hash_add( Cache_t theCache, void* aKey, void* aValue );\n+                                                  to the hash table.  If the\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thash table reaches a \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlevel of fullnes then\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit will be resized. \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassert() if the key is \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\talready in the hash. */\n+void hash_add( Cache_t* theCache, void* aKey, void* aValue );\n                                                 /* Remove the key/value pair\n                                                   from the hash table.  \n                                                   assert() if the key isn't "}]}