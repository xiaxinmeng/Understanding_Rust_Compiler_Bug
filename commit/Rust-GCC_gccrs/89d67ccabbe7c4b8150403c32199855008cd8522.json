{"sha": "89d67ccabbe7c4b8150403c32199855008cd8522", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkNjdjY2FiYmU3YzRiODE1MDQwM2MzMjE5OTg1NTAwOGNkODUyMg==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2006-11-08T07:32:44Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2006-11-08T07:32:44Z"}, "message": "[multiple changes]\n\n2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * tree-vect-analyze.c (vect_mark_relevant, vect_stmt_relevant_p): Take\n        enum argument instead of bool.\n        (vect_analyze_operations): Call vectorizable_type_promotion.\n        * tree-vectorizer.h (type_promotion_vec_info_type): New enum\n        stmt_vec_info_type value.\n        (supportable_widening_operation, vectorizable_type_promotion): New\n        function declarations.\n        * tree-vect-transform.c (vect_gen_widened_results_half): New function.\n        (vectorizable_type_promotion): New function.\n        (vect_transform_stmt): Call vectorizable_type_promotion.\n        * tree-vect-analyze.c (supportable_widening_operation): New function.\n        * tree-vect-patterns.c (vect_recog_dot_prod_pattern):\n        Add implementation.\n        * tree-vect-generic.c (expand_vector_operations_1): Consider correct\n        mode.\n\n        * tree.def (VEC_WIDEN_MULT_HI_EXPR, VEC_WIDEN_MULT_LO_EXPR):\n        (VEC_UNPACK_HI_EXPR, VEC_UNPACK_LO_EXPR): New tree-codes.\n        * tree-inline.c (estimate_num_insns_1): Add cases for above new\n        tree-codes.\n        * tree-pretty-print.c (dump_generic_node, op_prio): Likewise.\n        * expr.c (expand_expr_real_1): Likewise.\n        * optabs.c (optab_for_tree_code): Likewise.\n        (init_optabs): Initialize new optabs.\n        * genopinit.c (vec_widen_umult_hi_optab, vec_widen_smult_hi_optab,\n        vec_widen_smult_hi_optab, vec_widen_smult_lo_optab,\n        vec_unpacks_hi_optab, vec_unpacks_lo_optab, vec_unpacku_hi_optab,\n        vec_unpacku_lo_optab): Initialize new optabs.\n        * optabs.h (OTI_vec_widen_umult_hi, OTI_vec_widen_umult_lo):\n        (OTI_vec_widen_smult_h, OTI_vec_widen_smult_lo, OTI_vec_unpacks_hi,\n        OTI_vec_unpacks_lo, OTI_vec_unpacku_hi, OTI_vec_unpacku_lo): New\n        optab indices.\n        (vec_widen_umult_hi_optab, vec_widen_umult_lo_optab):\n        (vec_widen_smult_hi_optab, vec_widen_smult_lo_optab):\n        (vec_unpacks_hi_optab, vec_unpacku_hi_optab, vec_unpacks_lo_optab):\n        (vec_unpacku_lo_optab): New optabs.\n        * doc/md.texi (vec_unpacks_hi, vec_unpacks_lo, vec_unpacku_hi):\n        (vec_unpacku_lo, vec_widen_umult_hi, vec_widen_umult_lo):\n        (vec_widen_smult_hi, vec_widen_smult_lo): New.\n        * doc/c-tree.texi (VEC_LSHIFT_EXPR, VEC_RSHIFT_EXPR):\n        (VEC_WIDEN_MULT_HI_EXPR, VEC_WIDEN_MULT_LO_EXPR, VEC_UNPACK_HI_EXPR):\n        (VEC_UNPACK_LO_EXPR, VEC_PACK_MOD_EXPR, VEC_PACK_SAT_EXPR): New.\n\n        * config/rs6000/altivec.md (UNSPEC_VMULWHUB, UNSPEC_VMULWLUB):\n        (UNSPEC_VMULWHSB, UNSPEC_VMULWLSB, UNSPEC_VMULWHUH, UNSPEC_VMULWLUH):\n        (UNSPEC_VMULWHSH, UNSPEC_VMULWLSH): New.\n        (UNSPEC_VPERMSI, UNSPEC_VPERMHI): New.\n        (vec_vperm_v8hiv4si, vec_vperm_v16qiv8hi): New patterns used to\n        implement the unsigned unpacking patterns.\n        (vec_unpacks_hi_v16qi, vec_unpacks_hi_v8hi, vec_unpacks_lo_v16qi):\n        (vec_unpacks_lo_v8hi): New signed unpacking patterns.\n        (vec_unpacku_hi_v16qi, vec_unpacku_hi_v8hi, vec_unpacku_lo_v16qi):\n        (vec_unpacku_lo_v8hi): New unsigned unpacking patterns.\n        (vec_widen_umult_hi_v16qi, vec_widen_umult_lo_v16qi):\n        (vec_widen_smult_hi_v16qi, vec_widen_smult_lo_v16qi):\n        (vec_widen_umult_hi_v8hi, vec_widen_umult_lo_v8hi):\n        (vec_widen_smult_hi_v8hi, vec_widen_smult_lo_v8hi): New widening\n        multiplication patterns.\n\n        * target.h (builtin_mul_widen_even, builtin_mul_widen_odd): New.\n        * target-def.h (TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN):\n        (TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD): New.\n        * config/rs6000/rs6000.c (rs6000_builtin_mul_widen_even): New.\n        (rs6000_builtin_mul_widen_odd): New.\n        (TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN): Defined.\n        (TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD): Defined.\n        * tree-vectorizer.h (enum vect_relevant): New enum type.\n        (_stmt_vec_info): Field relevant chaned from bool to enum\n        vect_relevant.\n        (STMT_VINFO_RELEVANT_P): Updated.\n        (STMT_VINFO_RELEVANT): New.\n        * tree-vectorizer.c (new_stmt_vec_info): Use STMT_VINFO_RELEVANT\n        instead of STMT_VINFO_RELEVANT_P.\n        * tree-vect-analyze.c (vect_mark_relevant, vect_stmt_relevant_p):\n        Replace calls to STMT_VINFO_RELEVANT_P with STMT_VINFO_RELEVANT,\n        and boolean variable with enum vect_relevant.\n        (vect_mark_stmts_to_be_vectorized): Likewise + update documentation.\n        * doc/tm.texi (TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN): New.\n        (TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD): New.\n\n        2006-11-08  Richard Henderson  <rth@redhat.com>\n\n        * config/i386/sse.md (vec_widen_umult_hi_v8hi,\n        vec_widen_umult_lo_v8hi): New.\n        (vec_widen_smult_hi_v4si, vec_widen_smult_lo_v4si,\n        vec_widen_umult_hi_v4si, vec_widen_umult_lo_v4si): New.\n\n        * config/i386/i386.c (ix86_expand_sse_unpack): New.\n        * config/i386/i386-protos.h (ix86_expand_sse_unpack): New.\n        * config/i386/sse.md (vec_unpacku_hi_v16qi, vec_unpacks_hi_v16qi,\n        vec_unpacku_lo_v16qi, vec_unpacks_lo_v16qi, vec_unpacku_hi_v8hi,\n        vec_unpacks_hi_v8hi, vec_unpacku_lo_v8hi, vec_unpacks_lo_v8hi,\n        vec_unpacku_hi_v4si, vec_unpacks_hi_v4si, vec_unpacku_lo_v4si,\n        vec_unpacks_lo_v4si): New.\n\n        2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * tree-vect-transform.c (vectorizable_type_demotion): New function.\n        (vect_transform_stmt): Add case for type_demotion_vec_info_type.\n        (vect_analyze_operations): Call vectorizable_type_demotion.\n        * tree-vectorizer.h (type_demotion_vec_info_type): New enum\n        stmt_vec_info_type value.\n        (vectorizable_type_demotion): New function declaration.\n        * tree-vect-generic.c (expand_vector_operations_1): Consider correct\n        mode.\n\n        * tree.def (VEC_PACK_MOD_EXPR, VEC_PACK_SAT_EXPR): New tree-codes.\n        * expr.c (expand_expr_real_1): Add case for VEC_PACK_MOD_EXPR and\n        VEC_PACK_SAT_EXPR.\n        * tree-iniline.c (estimate_num_insns_1): Likewise.\n        * tree-pretty-print.c (dump_generic_node, op_prio): Likewise.\n        * optabs.c (optab_for_tree_code): Likewise.\n\n        * optabs.c (expand_binop): In case of vec_pack_*_optabs the mode\n        compared against the predicate of the result is not 'mode' (the input\n        to the function) but a mode with half the size of 'mode'.\n        (init_optab): Initialize new optabs.\n        * optabs.h (OTI_vec_pack_mod, OTI_vec_pack_ssat, OTI_vec_pack_usat):\n        New optab indices.\n        (vec_pack_mod_optab, vec_pack_ssat_optab,  vec_pack_usat_optab): New\n        optabs.\n        * genopinit.c (vec_pack_mod_optab, vec_pack_ssat_optab):\n        (vec_pack_usat_optab): Initialize new optabs.\n        * doc/md.texi (vec_pack_mod, vec_pack_ssat, vec_pack_usat): New.\n        * config/rs6000/altivec.md (vec_pack_mod_v8hi, vec_pack_mod_v4si): New.\n\n        2006-11-08  Richard Henderson  <rth@redehat.com>\n\n        * config/i386/sse.md (vec_pack_mod_v8hi, vec_pack_mod_v4si):\n        (vec_pack_mod_v2di, vec_interleave_highv16qi, vec_interleave_lowv16qi):\n        (vec_interleave_highv8hi, vec_interleave_lowv8hi):\n        (vec_interleave_highv4si, vec_interleave_lowv4si):\n        (vec_interleave_highv2di, vec_interleave_lowv2di): New.\n\n        2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * tree-vect-transform.c (vectorizable_reduction): Support multiple\n        datatypes.\n        (vect_transform_stmt): Removed redundant code.\n\n        2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * tree-vect-transform.c (vectorizable_operation): Support multiple\n        datatypes.\n\n        2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * tree-vect-transform.c (vect_align_data_ref): Removed.\n        (vect_create_data_ref_ptr): Added additional argument - ptr_incr.\n        Updated function documentation. Return the increment stmt in ptr_incr.\n        (bump_vector_ptr): New function.\n        (vect_get_vec_def_for_stmt_copy): New function.\n        (vect_finish_stmt_generation): Create a stmt_info to newly created\n        vector stmts.\n        (vect_setup_realignment): Call vect_create_data_ref_ptr with additional\n        argument.\n        (vectorizable_reduction, vectorizable_assignment): Not supported yet if\n        VF is greater than the number of elements that can fit in one vector\n        word.\n        (vectorizable_operation, vectorizable_condition): Likewise.\n        (vectorizable_store, vectorizable_load): Support the case that the VF\n        is greater than the number of elements that can fit in one vector word.\n        (vect_transform_loop): Don't fail in case of multiple data-types.\n        * tree-vect-analyze.c (vect_determine_vectorization_factor): Don't fail\n        in case of multiple data-types; the smallest type determines the VF.\n        (vect_analyze_data_ref_dependence): Don't record datarefs as same_align\n        if they are of different sizes.\n        (vect_update_misalignment_for_peel): Compare misalignments in terms of\n        number of elements rather than number of bytes.\n        (vect_enhance_data_refs_alignment): Fix/Add dump printouts.\n        (vect_can_advance_ivs_p): Fix a dump printout\n\nFrom-SVN: r118577", "tree": {"sha": "f63ce21ba1bb5e2d1d0cb84948e597d8223aaab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f63ce21ba1bb5e2d1d0cb84948e597d8223aaab5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89d67ccabbe7c4b8150403c32199855008cd8522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d67ccabbe7c4b8150403c32199855008cd8522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d67ccabbe7c4b8150403c32199855008cd8522", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d67ccabbe7c4b8150403c32199855008cd8522/comments", "author": null, "committer": null, "parents": [{"sha": "6300f037d02324e91b3987acbbb16f727dd3c9b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6300f037d02324e91b3987acbbb16f727dd3c9b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6300f037d02324e91b3987acbbb16f727dd3c9b8"}], "stats": {"total": 4923, "additions": 4210, "deletions": 713}, "files": [{"sha": "d215ec51982dcd2dd699752c59cbeec7f3f32e60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -1,3 +1,177 @@\n+2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-analyze.c (vect_mark_relevant, vect_stmt_relevant_p): Take \n+\tenum argument instead of bool.\n+\t(vect_analyze_operations): Call vectorizable_type_promotion.\n+\t* tree-vectorizer.h (type_promotion_vec_info_type): New enum\n+\tstmt_vec_info_type value.\n+\t(supportable_widening_operation, vectorizable_type_promotion): New\n+\tfunction declarations.\n+\t* tree-vect-transform.c (vect_gen_widened_results_half): New function.\n+\t(vectorizable_type_promotion): New function.\n+\t(vect_transform_stmt): Call vectorizable_type_promotion.\n+\t* tree-vect-analyze.c (supportable_widening_operation): New function.\n+\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): \n+\tAdd implementation.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Consider correct\n+\tmode.\n+\t\n+\t* tree.def (VEC_WIDEN_MULT_HI_EXPR, VEC_WIDEN_MULT_LO_EXPR):\n+\t(VEC_UNPACK_HI_EXPR, VEC_UNPACK_LO_EXPR): New tree-codes.\n+\t* tree-inline.c (estimate_num_insns_1): Add cases for above new \n+\ttree-codes.\n+\t* tree-pretty-print.c (dump_generic_node, op_prio): Likewise.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* optabs.c (optab_for_tree_code): Likewise.\n+\t(init_optabs): Initialize new optabs.\n+\t* genopinit.c (vec_widen_umult_hi_optab, vec_widen_smult_hi_optab,\n+\tvec_widen_smult_hi_optab, vec_widen_smult_lo_optab,\n+\tvec_unpacks_hi_optab, vec_unpacks_lo_optab, vec_unpacku_hi_optab,\n+\tvec_unpacku_lo_optab): Initialize new optabs.\n+\t* optabs.h (OTI_vec_widen_umult_hi, OTI_vec_widen_umult_lo):\n+\t(OTI_vec_widen_smult_h, OTI_vec_widen_smult_lo, OTI_vec_unpacks_hi,\n+\tOTI_vec_unpacks_lo, OTI_vec_unpacku_hi, OTI_vec_unpacku_lo): New \n+\toptab indices.\n+\t(vec_widen_umult_hi_optab, vec_widen_umult_lo_optab):\n+\t(vec_widen_smult_hi_optab, vec_widen_smult_lo_optab):\n+\t(vec_unpacks_hi_optab, vec_unpacku_hi_optab, vec_unpacks_lo_optab):\n+\t(vec_unpacku_lo_optab): New optabs.\n+\t* doc/md.texi (vec_unpacks_hi, vec_unpacks_lo, vec_unpacku_hi): \n+\t(vec_unpacku_lo, vec_widen_umult_hi, vec_widen_umult_lo): \n+\t(vec_widen_smult_hi, vec_widen_smult_lo): New.\n+\t* doc/c-tree.texi (VEC_LSHIFT_EXPR, VEC_RSHIFT_EXPR):\n+\t(VEC_WIDEN_MULT_HI_EXPR, VEC_WIDEN_MULT_LO_EXPR, VEC_UNPACK_HI_EXPR):\n+\t(VEC_UNPACK_LO_EXPR, VEC_PACK_MOD_EXPR, VEC_PACK_SAT_EXPR): New.\n+\t \n+\t* config/rs6000/altivec.md (UNSPEC_VMULWHUB, UNSPEC_VMULWLUB):\n+\t(UNSPEC_VMULWHSB, UNSPEC_VMULWLSB, UNSPEC_VMULWHUH, UNSPEC_VMULWLUH):\n+\t(UNSPEC_VMULWHSH, UNSPEC_VMULWLSH): New.\n+\t(UNSPEC_VPERMSI, UNSPEC_VPERMHI): New.\n+\t(vec_vperm_v8hiv4si, vec_vperm_v16qiv8hi): New patterns used to\n+\timplement the unsigned unpacking patterns.\n+\t(vec_unpacks_hi_v16qi, vec_unpacks_hi_v8hi, vec_unpacks_lo_v16qi):\n+\t(vec_unpacks_lo_v8hi): New signed unpacking patterns.\n+\t(vec_unpacku_hi_v16qi, vec_unpacku_hi_v8hi, vec_unpacku_lo_v16qi):\n+\t(vec_unpacku_lo_v8hi): New unsigned unpacking patterns.\n+\t(vec_widen_umult_hi_v16qi, vec_widen_umult_lo_v16qi):\n+\t(vec_widen_smult_hi_v16qi, vec_widen_smult_lo_v16qi): \n+\t(vec_widen_umult_hi_v8hi, vec_widen_umult_lo_v8hi):\n+\t(vec_widen_smult_hi_v8hi, vec_widen_smult_lo_v8hi): New widening\n+\tmultiplication patterns.\n+\n+\t* target.h (builtin_mul_widen_even, builtin_mul_widen_odd): New.\n+\t* target-def.h (TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN):\n+\t(TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD): New.\n+\t* config/rs6000/rs6000.c (rs6000_builtin_mul_widen_even): New.\n+\t(rs6000_builtin_mul_widen_odd): New.\n+\t(TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN): Defined.\n+\t(TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD): Defined.\n+\t* tree-vectorizer.h (enum vect_relevant): New enum type.\n+\t(_stmt_vec_info): Field relevant chaned from bool to enum\n+\tvect_relevant.\n+\t(STMT_VINFO_RELEVANT_P): Updated.\n+\t(STMT_VINFO_RELEVANT): New.\n+\t* tree-vectorizer.c (new_stmt_vec_info): Use STMT_VINFO_RELEVANT\n+\tinstead of STMT_VINFO_RELEVANT_P.\n+\t* tree-vect-analyze.c (vect_mark_relevant, vect_stmt_relevant_p):\n+\tReplace calls to STMT_VINFO_RELEVANT_P with STMT_VINFO_RELEVANT,\n+\tand boolean variable with enum vect_relevant.\n+\t(vect_mark_stmts_to_be_vectorized): Likewise + update documentation.\n+\t* doc/tm.texi (TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN): New.\n+\t(TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD): New.\n+\n+\t2006-11-08  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/sse.md (vec_widen_umult_hi_v8hi,\n+\tvec_widen_umult_lo_v8hi): New.\n+\t(vec_widen_smult_hi_v4si, vec_widen_smult_lo_v4si,\n+\tvec_widen_umult_hi_v4si, vec_widen_umult_lo_v4si): New.\n+\n+\t* config/i386/i386.c (ix86_expand_sse_unpack): New. \n+\t* config/i386/i386-protos.h (ix86_expand_sse_unpack): New. \n+\t* config/i386/sse.md (vec_unpacku_hi_v16qi, vec_unpacks_hi_v16qi,\n+\tvec_unpacku_lo_v16qi, vec_unpacks_lo_v16qi, vec_unpacku_hi_v8hi,\n+\tvec_unpacks_hi_v8hi, vec_unpacku_lo_v8hi, vec_unpacks_lo_v8hi,\n+\tvec_unpacku_hi_v4si, vec_unpacks_hi_v4si, vec_unpacku_lo_v4si,\n+\tvec_unpacks_lo_v4si): New.\n+\n+\t2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-transform.c (vectorizable_type_demotion): New function.\n+\t(vect_transform_stmt): Add case for type_demotion_vec_info_type.\n+\t(vect_analyze_operations): Call vectorizable_type_demotion.\n+\t* tree-vectorizer.h (type_demotion_vec_info_type): New enum \n+\tstmt_vec_info_type value.\n+\t(vectorizable_type_demotion): New function declaration.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Consider correct\n+\tmode.\n+\n+\t* tree.def (VEC_PACK_MOD_EXPR, VEC_PACK_SAT_EXPR): New tree-codes.\n+\t* expr.c (expand_expr_real_1): Add case for VEC_PACK_MOD_EXPR and\n+\tVEC_PACK_SAT_EXPR.\n+\t* tree-iniline.c (estimate_num_insns_1): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node, op_prio): Likewise.\n+\t* optabs.c (optab_for_tree_code): Likewise.\n+\n+\t* optabs.c (expand_binop): In case of vec_pack_*_optabs the mode \n+\tcompared against the predicate of the result is not 'mode' (the input \n+\tto the function) but a mode with half the size of 'mode'.\n+\t(init_optab): Initialize new optabs.\n+\t* optabs.h (OTI_vec_pack_mod, OTI_vec_pack_ssat, OTI_vec_pack_usat):\n+\tNew optab indices.\n+\t(vec_pack_mod_optab, vec_pack_ssat_optab,  vec_pack_usat_optab): New\n+\toptabs.\n+\t* genopinit.c (vec_pack_mod_optab, vec_pack_ssat_optab):\n+\t(vec_pack_usat_optab): Initialize new optabs.\n+\t* doc/md.texi (vec_pack_mod, vec_pack_ssat, vec_pack_usat): New.\n+\t* config/rs6000/altivec.md (vec_pack_mod_v8hi, vec_pack_mod_v4si): New.\n+\n+\t2006-11-08  Richard Henderson  <rth@redehat.com>\n+\n+\t* config/i386/sse.md (vec_pack_mod_v8hi, vec_pack_mod_v4si):\n+\t(vec_pack_mod_v2di, vec_interleave_highv16qi, vec_interleave_lowv16qi):\n+\t(vec_interleave_highv8hi, vec_interleave_lowv8hi):\n+\t(vec_interleave_highv4si, vec_interleave_lowv4si):\n+\t(vec_interleave_highv2di, vec_interleave_lowv2di): New.\n+\n+\t2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-transform.c (vectorizable_reduction): Support multiple \n+\tdatatypes.\n+\t(vect_transform_stmt): Removed redundant code.\n+\n+\t2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-transform.c (vectorizable_operation): Support multiple \n+\tdatatypes.\n+\n+\t2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-transform.c (vect_align_data_ref): Removed.\n+\t(vect_create_data_ref_ptr): Added additional argument - ptr_incr. \n+\tUpdated function documentation. Return the increment stmt in ptr_incr.\n+\t(bump_vector_ptr): New function.\n+\t(vect_get_vec_def_for_stmt_copy): New function.\n+\t(vect_finish_stmt_generation): Create a stmt_info to newly created\n+\tvector stmts.\n+\t(vect_setup_realignment): Call vect_create_data_ref_ptr with additional\n+\targument.\n+\t(vectorizable_reduction, vectorizable_assignment): Not supported yet if\n+\tVF is greater than the number of elements that can fit in one vector\n+\tword.\n+\t(vectorizable_operation, vectorizable_condition): Likewise.\n+\t(vectorizable_store, vectorizable_load): Support the case that the VF\n+\tis greater than the number of elements that can fit in one vector word.\n+\t(vect_transform_loop): Don't fail in case of multiple data-types.\n+\t* tree-vect-analyze.c (vect_determine_vectorization_factor): Don't fail \n+\tin case of multiple data-types; the smallest type determines the VF.\n+\t(vect_analyze_data_ref_dependence): Don't record datarefs as same_align\n+\tif they are of different sizes.\n+\t(vect_update_misalignment_for_peel): Compare misalignments in terms of\n+\tnumber of elements rather than number of bytes.\n+\t(vect_enhance_data_refs_alignment): Fix/Add dump printouts.\n+\t(vect_can_advance_ivs_p): Fix a dump printout\n+\n 2006-11-07  Eric Christopher  <echristo@apple.com>\n \n \t* libgcc2.c (__bswapdi2): Rename from bswapDI2."}, {"sha": "b8d20a337426f23325624ae9d74161b20aacb721", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -105,6 +105,7 @@ extern int ix86_expand_int_movcc (rtx[]);\n extern int ix86_expand_fp_movcc (rtx[]);\n extern bool ix86_expand_fp_vcond (rtx[]);\n extern bool ix86_expand_int_vcond (rtx[]);\n+extern void ix86_expand_sse_unpack (rtx[], bool, bool);\n extern int ix86_expand_int_addcc (rtx[]);\n extern void ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);"}, {"sha": "89f88ed2e5b406c8b6fa22f0518462825513564f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -11733,6 +11733,52 @@ ix86_expand_int_vcond (rtx operands[])\n   return true;\n }\n \n+/* Unpack OP[1] into the next wider integer vector type.  UNSIGNED_P is\n+   true if we should do zero extension, else sign extension.  HIGH_P is\n+   true if we want the N/2 high elements, else the low elements.  */\n+\n+void\n+ix86_expand_sse_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n+{\n+  enum machine_mode imode = GET_MODE (operands[1]);\n+  rtx (*unpack)(rtx, rtx, rtx);\n+  rtx se, dest;\n+\n+  switch (imode)\n+    {\n+    case V16QImode:\n+      if (high_p)\n+        unpack = gen_vec_interleave_highv16qi;\n+      else\n+        unpack = gen_vec_interleave_lowv16qi;\n+      break;\n+    case V8HImode:\n+      if (high_p)\n+        unpack = gen_vec_interleave_highv8hi;\n+      else\n+        unpack = gen_vec_interleave_lowv8hi;\n+      break;\n+    case V4SImode:\n+      if (high_p)\n+        unpack = gen_vec_interleave_highv4si;\n+      else \n+        unpack = gen_vec_interleave_lowv4si;\n+      break;\n+    default:\n+      gcc_unreachable (); \n+    }\n+\n+  dest = gen_lowpart (imode, operands[0]);\n+\n+  if (unsigned_p)\n+    se = force_reg (imode, CONST0_RTX (imode));\n+  else\n+    se = ix86_expand_sse_cmp (gen_reg_rtx (imode), GT, CONST0_RTX (imode),\n+                              operands[1], pc_rtx, pc_rtx);\n+\n+  emit_insn (unpack (dest, operands[1], se));\n+}\n+\n /* Expand conditional increment or decrement using adb/sbb instructions.\n    The default case using setcc followed by the conditional move can be\n    done by generic code.  */\n@@ -14863,7 +14909,7 @@ static const struct builtin_description bdesc_2arg[] =\n   { MASK_MMX, CODE_FOR_sse2_ussubv8hi3, \"__builtin_ia32_psubusw128\", IX86_BUILTIN_PSUBUSW128, 0, 0 },\n \n   { MASK_SSE2, CODE_FOR_mulv8hi3, \"__builtin_ia32_pmullw128\", IX86_BUILTIN_PMULLW128, 0, 0 },\n-  { MASK_SSE2, CODE_FOR_sse2_smulv8hi3_highpart, \"__builtin_ia32_pmulhw128\", IX86_BUILTIN_PMULHW128, 0, 0 },\n+  { MASK_SSE2, CODE_FOR_smulv8hi3_highpart, \"__builtin_ia32_pmulhw128\", IX86_BUILTIN_PMULHW128, 0, 0 },\n \n   { MASK_SSE2, CODE_FOR_andv2di3, \"__builtin_ia32_pand128\", IX86_BUILTIN_PAND128, 0, 0 },\n   { MASK_SSE2, CODE_FOR_sse2_nandv2di3, \"__builtin_ia32_pandn128\", IX86_BUILTIN_PANDN128, 0, 0 },\n@@ -14898,7 +14944,7 @@ static const struct builtin_description bdesc_2arg[] =\n   { MASK_SSE2, CODE_FOR_sse2_packssdw, \"__builtin_ia32_packssdw128\", IX86_BUILTIN_PACKSSDW128, 0, 0 },\n   { MASK_SSE2, CODE_FOR_sse2_packuswb, \"__builtin_ia32_packuswb128\", IX86_BUILTIN_PACKUSWB128, 0, 0 },\n \n-  { MASK_SSE2, CODE_FOR_sse2_umulv8hi3_highpart, \"__builtin_ia32_pmulhuw128\", IX86_BUILTIN_PMULHUW128, 0, 0 },\n+  { MASK_SSE2, CODE_FOR_umulv8hi3_highpart, \"__builtin_ia32_pmulhuw128\", IX86_BUILTIN_PMULHUW128, 0, 0 },\n   { MASK_SSE2, CODE_FOR_sse2_psadbw, 0, IX86_BUILTIN_PSADBW128, 0, 0 },\n \n   { MASK_SSE2, CODE_FOR_sse2_umulsidi3, 0, IX86_BUILTIN_PMULUDQ, 0, 0 },"}, {"sha": "9985b7d479cdc715199a8e06d630221a85842f31", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 473, "deletions": 2, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -2620,7 +2620,20 @@\n   [(set_attr \"type\" \"sseimul\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"sse2_smulv8hi3_highpart\"\n+(define_insn \"smulv8hi3_highpart\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"\")\n+        (truncate:V8HI\n+          (lshiftrt:V8SI \n+            (mult:V8SI \n+              (sign_extend:V8SI\n+                (match_operand:V8HI 1 \"nonimmediate_operand\" \"\"))\n+              (sign_extend:V8SI\n+                (match_operand:V8HI 2 \"nonimmediate_operand\" \"\")))\n+            (const_int 16))))]\n+  \"TARGET_SSE2\"\n+  \"ix86_fixup_binary_operands_no_copy (MULT, V8HImode, operands);\")\n+  \n+(define_insn \"*smulv8hi3_highpart\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n \t(truncate:V8HI\n \t  (lshiftrt:V8SI\n@@ -2635,7 +2648,20 @@\n   [(set_attr \"type\" \"sseimul\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"sse2_umulv8hi3_highpart\"\n+(define_insn \"umulv8hi3_highpart\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"\")\n+        (truncate:V8HI\n+          (lshiftrt:V8SI\n+            (mult:V8SI\n+              (zero_extend:V8SI\n+                (match_operand:V8HI 1 \"nonimmediate_operand\" \"\"))\n+              (zero_extend:V8SI\n+                (match_operand:V8HI 2 \"nonimmediate_operand\" \"\")))\n+            (const_int 16))))]\n+  \"TARGET_SSE2\"\n+  \"ix86_fixup_binary_operands_no_copy (MULT, V8HImode, operands);\")\n+\n+(define_insn \"*umulv8hi3_highpart\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n \t(truncate:V8HI\n \t  (lshiftrt:V8SI\n@@ -2792,6 +2818,122 @@\n   DONE;\n })\n \n+(define_expand \"vec_widen_umult_hi_v8hi\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")\n+   (match_operand:V8HI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, t1, t2, dest;\n+\n+  op1 = operands[1];\n+  op2 = operands[2];\n+  t1 = gen_reg_rtx (V8HImode);\n+  t2 = gen_reg_rtx (V8HImode);\n+  dest = gen_lowpart (V8HImode, operands[0]);\n+\n+  emit_insn (gen_mulv8hi3 (t1, op1, op2));\n+  emit_insn (gen_umulv8hi3_highpart (t2, op1, op2));\n+  emit_insn (gen_vec_interleave_highv8hi (dest, t1, t2));\n+  DONE;\n+})\n+\n+(define_expand \"vec_widen_umult_lo_v8hi\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")\n+   (match_operand:V8HI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, t1, t2, dest;\n+\n+  op1 = operands[1];\n+  op2 = operands[2];\n+  t1 = gen_reg_rtx (V8HImode);\n+  t2 = gen_reg_rtx (V8HImode);\n+  dest = gen_lowpart (V8HImode, operands[0]);\n+\n+  emit_insn (gen_mulv8hi3 (t1, op1, op2));\n+  emit_insn (gen_umulv8hi3_highpart (t2, op1, op2));\n+  emit_insn (gen_vec_interleave_lowv8hi (dest, t1, t2));\n+  DONE;\n+})\n+\n+(define_expand \"vec_widen_smult_hi_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand:V4SI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, t1, t2;\n+\n+  op1 = operands[1];\n+  op2 = operands[2];\n+  t1 = gen_reg_rtx (V4SImode);\n+  t2 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_vec_interleave_highv4si (t1, op1, op1));\n+  emit_insn (gen_vec_interleave_highv4si (t2, op2, op2));\n+  emit_insn (gen_sse2_umulv2siv2di3 (operands[0], t1, t2));\n+  DONE;\n+})\n+\n+(define_expand \"vec_widen_smult_lo_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand:V4SI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, t1, t2;\n+\n+  op1 = operands[1];\n+  op2 = operands[2];\n+  t1 = gen_reg_rtx (V4SImode);\n+  t2 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_vec_interleave_lowv4si (t1, op1, op1));\n+  emit_insn (gen_vec_interleave_lowv4si (t2, op2, op2));\n+  emit_insn (gen_sse2_umulv2siv2di3 (operands[0], t1, t2));\n+  DONE;\n+})\n+\n+(define_expand \"vec_widen_umult_hi_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand:V4SI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, t1, t2;\n+\n+  op1 = operands[1];\n+  op2 = operands[2];\n+  t1 = gen_reg_rtx (V4SImode);\n+  t2 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_vec_interleave_highv4si (t1, op1, op1));\n+  emit_insn (gen_vec_interleave_highv4si (t2, op2, op2));\n+  emit_insn (gen_sse2_umulv2siv2di3 (operands[0], t1, t2));\n+  DONE;\n+})\n+\n+(define_expand \"vec_widen_umult_lo_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand:V4SI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, t1, t2;\n+\n+  op1 = operands[1];\n+  op2 = operands[2];\n+  t1 = gen_reg_rtx (V4SImode);\n+  t2 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_vec_interleave_lowv4si (t1, op1, op1));\n+  emit_insn (gen_vec_interleave_lowv4si (t2, op2, op2));\n+  emit_insn (gen_sse2_umulv2siv2di3 (operands[0], t1, t2));\n+  DONE;\n+})\n+\n (define_expand \"sdot_prodv8hi\"\n   [(match_operand:V4SI 0 \"register_operand\" \"\")\n    (match_operand:V8HI 1 \"nonimmediate_operand\" \"\")\n@@ -3215,6 +3357,227 @@\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n+;; Reduce:\n+;;      op1 = abcdefghijklmnop\n+;;      op2 = qrstuvwxyz012345\n+;;       h1 = aqbrcsdteufvgwhx\n+;;       l1 = iyjzk0l1m2n3o4p5\n+;;       h2 = aiqybjrzcks0dlt1\n+;;       l2 = emu2fnv3gow4hpx5\n+;;       h3 = aeimquy2bfjnrvz3\n+;;       l3 = cgkosw04dhlptx15\n+;;   result = bdfhjlnprtvxz135\n+(define_expand \"vec_pack_mod_v8hi\"\n+  [(match_operand:V16QI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")\n+   (match_operand:V8HI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, h1, l1, h2, l2, h3, l3;\n+                                                                                \n+  op1 = gen_lowpart (V16QImode, operands[1]);\n+  op2 = gen_lowpart (V16QImode, operands[2]);\n+  h1 = gen_reg_rtx (V16QImode);\n+  l1 = gen_reg_rtx (V16QImode);\n+  h2 = gen_reg_rtx (V16QImode);\n+  l2 = gen_reg_rtx (V16QImode);\n+  h3 = gen_reg_rtx (V16QImode);\n+  l3 = gen_reg_rtx (V16QImode);\n+                                                                                \n+  emit_insn (gen_vec_interleave_highv16qi (h1, op1, op2));\n+  emit_insn (gen_vec_interleave_lowv16qi (l1, op1, op2));\n+  emit_insn (gen_vec_interleave_highv16qi (h2, l1, h1));\n+  emit_insn (gen_vec_interleave_lowv16qi (l2, l1, h1));\n+  emit_insn (gen_vec_interleave_highv16qi (h3, l2, h2));\n+  emit_insn (gen_vec_interleave_lowv16qi (l3, l2, h2));\n+  emit_insn (gen_vec_interleave_lowv16qi (operands[0], l3, h3));\n+  DONE;\n+})\n+                                                                                \n+;; Reduce:\n+;;      op1 = abcdefgh\n+;;      op2 = ijklmnop\n+;;       h1 = aibjckdl\n+;;       l1 = emfngohp\n+;;       h2 = aeimbfjn\n+;;       l2 = cgkodhlp\n+;;   result = bdfhjlnp\n+(define_expand \"vec_pack_mod_v4si\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand:V4SI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, h1, l1, h2, l2;\n+                                                                                \n+  op1 = gen_lowpart (V8HImode, operands[1]);\n+  op2 = gen_lowpart (V8HImode, operands[2]);\n+  h1 = gen_reg_rtx (V8HImode);\n+  l1 = gen_reg_rtx (V8HImode);\n+  h2 = gen_reg_rtx (V8HImode);\n+  l2 = gen_reg_rtx (V8HImode);\n+                                                                                \n+  emit_insn (gen_vec_interleave_highv8hi (h1, op1, op2));\n+  emit_insn (gen_vec_interleave_lowv8hi (l1, op1, op2));\n+  emit_insn (gen_vec_interleave_highv8hi (h2, l1, h1));\n+  emit_insn (gen_vec_interleave_lowv8hi (l2, l1, h1));\n+  emit_insn (gen_vec_interleave_lowv8hi (operands[0], l2, h2));\n+  DONE;\n+})\n+                                                                                \n+;; Reduce:\n+;;     op1 = abcd\n+;;     op2 = efgh\n+;;      h1 = aebf\n+;;      l1 = cgdh\n+;;  result = bdfh\n+(define_expand \"vec_pack_mod_v2di\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V2DI 1 \"register_operand\" \"\")\n+   (match_operand:V2DI 2 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx op1, op2, h1, l1;\n+                                                                                \n+  op1 = gen_lowpart (V4SImode, operands[1]);\n+  op2 = gen_lowpart (V4SImode, operands[2]);\n+  h1 = gen_reg_rtx (V4SImode);\n+  l1 = gen_reg_rtx (V4SImode);\n+                                                                                \n+  emit_insn (gen_vec_interleave_highv4si (h1, op1, op2));\n+  emit_insn (gen_vec_interleave_lowv4si (l1, op1, op2));\n+  emit_insn (gen_vec_interleave_lowv4si (operands[0], l1, h1));\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_highv16qi\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=x\")\n+        (vec_select:V16QI\n+          (vec_concat:V32QI\n+            (match_operand:V16QI 1 \"register_operand\" \"0\")\n+            (match_operand:V16QI 2 \"nonimmediate_operand\" \"xm\"))\n+          (parallel [(const_int 8)  (const_int 24)\n+                     (const_int 9)  (const_int 25)\n+                     (const_int 10) (const_int 26)\n+                     (const_int 11) (const_int 27)\n+                     (const_int 12) (const_int 28)\n+                     (const_int 13) (const_int 29)\n+                     (const_int 14) (const_int 30)\n+                     (const_int 15) (const_int 31)])))]\n+  \"TARGET_SSE2\"\n+{\n+  emit_insn (gen_sse2_punpckhbw (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_lowv16qi\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=x\")\n+        (vec_select:V16QI\n+          (vec_concat:V32QI\n+            (match_operand:V16QI 1 \"register_operand\" \"0\")\n+            (match_operand:V16QI 2 \"nonimmediate_operand\" \"xm\"))\n+          (parallel [(const_int 0) (const_int 16)\n+                     (const_int 1) (const_int 17)\n+                     (const_int 2) (const_int 18)\n+                     (const_int 3) (const_int 19)\n+                     (const_int 4) (const_int 20)\n+                     (const_int 5) (const_int 21)\n+                     (const_int 6) (const_int 22)\n+                     (const_int 7) (const_int 23)])))]\n+  \"TARGET_SSE2\"\n+{\n+  emit_insn (gen_sse2_punpcklbw (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_highv8hi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n+        (vec_select:V8HI\n+          (vec_concat:V16HI\n+            (match_operand:V8HI 1 \"register_operand\" \"0\")\n+            (match_operand:V8HI 2 \"nonimmediate_operand\" \"xm\"))\n+          (parallel [(const_int 4) (const_int 12)\n+                     (const_int 5) (const_int 13)\n+                     (const_int 6) (const_int 14)\n+                     (const_int 7) (const_int 15)])))]\n+  \"TARGET_SSE2\"\n+{\n+  emit_insn (gen_sse2_punpckhwd (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_lowv8hi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n+        (vec_select:V8HI\n+          (vec_concat:V16HI\n+            (match_operand:V8HI 1 \"register_operand\" \"0\")\n+            (match_operand:V8HI 2 \"nonimmediate_operand\" \"xm\"))\n+          (parallel [(const_int 0) (const_int 8)\n+                     (const_int 1) (const_int 9)\n+                     (const_int 2) (const_int 10)\n+                     (const_int 3) (const_int 11)])))]\n+  \"TARGET_SSE2\"\n+{\n+  emit_insn (gen_sse2_punpcklwd (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_highv4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+        (vec_select:V4SI\n+          (vec_concat:V8SI\n+            (match_operand:V4SI 1 \"register_operand\" \"0\")\n+            (match_operand:V4SI 2 \"nonimmediate_operand\" \"xm\"))\n+          (parallel [(const_int 2) (const_int 6)\n+                     (const_int 3) (const_int 7)])))]\n+  \"TARGET_SSE2\"\n+{\n+  emit_insn (gen_sse2_punpckhdq (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_lowv4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+        (vec_select:V4SI\n+          (vec_concat:V8SI\n+            (match_operand:V4SI 1 \"register_operand\" \"0\")\n+            (match_operand:V4SI 2 \"nonimmediate_operand\" \"xm\"))\n+          (parallel [(const_int 0) (const_int 4)\n+                     (const_int 1) (const_int 5)])))]\n+  \"TARGET_SSE2\"\n+{\n+  emit_insn (gen_sse2_punpckldq (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_highv2di\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+        (vec_select:V2DI\n+          (vec_concat:V4DI\n+            (match_operand:V2DI 1 \"register_operand\" \"0\")\n+            (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\"))\n+          (parallel [(const_int 1)\n+                     (const_int 3)])))]\n+  \"TARGET_SSE2\"\n+{\n+  emit_insn (gen_sse2_punpckhqdq (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_lowv2di\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+        (vec_select:V2DI\n+          (vec_concat:V4DI\n+            (match_operand:V2DI 1 \"register_operand\" \"0\")\n+            (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\"))\n+          (parallel [(const_int 0)\n+                     (const_int 2)])))]\n+  \"TARGET_SSE2\"\n+{\n+  emit_insn (gen_sse2_punpcklqdq (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n (define_insn \"sse2_packsswb\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=x\")\n \t(vec_concat:V16QI\n@@ -3832,6 +4195,114 @@\n   DONE;\n })\n \n+(define_expand \"vec_unpacku_hi_v16qi\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, true, true);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_hi_v16qi\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, false, true);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_lo_v16qi\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, true, false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_lo_v16qi\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, false, false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_hi_v8hi\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, true, true);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_hi_v8hi\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, false, true);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_lo_v8hi\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, true, false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_lo_v8hi\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, false, false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_hi_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, true, true);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_hi_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, false, true);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_lo_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, true, false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_lo_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_sse_unpack (operands, false, false);\n+  DONE;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Miscellaneous"}, {"sha": "7a78a9405f3aa3bd6a543959c655e94aaa5ed9a4", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -122,6 +122,20 @@\n    (UNSPEC_VCONDU_V4SI  305)\n    (UNSPEC_VCONDU_V8HI  306)\n    (UNSPEC_VCONDU_V16QI 307)\n+   (UNSPEC_VMULWHUB     308)\n+   (UNSPEC_VMULWLUB     309)\n+   (UNSPEC_VMULWHSB     310)\n+   (UNSPEC_VMULWLSB     311)\n+   (UNSPEC_VMULWHUH     312)\n+   (UNSPEC_VMULWLUH     313)\n+   (UNSPEC_VMULWHSH     314)\n+   (UNSPEC_VMULWLSH     315)\n+   (UNSPEC_VUPKHUB      316)\n+   (UNSPEC_VUPKHUH      317)\n+   (UNSPEC_VUPKLUB      318)\n+   (UNSPEC_VUPKLUH      319)\n+   (UNSPEC_VPERMSI\t320)\n+   (UNSPEC_VPERMHI\t321)\n    ])\n \n (define_constants\n@@ -2203,6 +2217,371 @@\n   DONE;\n }\")\n \n+(define_expand \"vec_unpacks_hi_v16qi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n+                     UNSPEC_VUPKHSB))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vupkhsb (operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_unpacks_hi_v8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")]\n+                     UNSPEC_VUPKHSH))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vupkhsh (operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_unpacks_lo_v16qi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n+                     UNSPEC_VUPKLSB))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vupklsb (operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_unpacks_lo_v8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")]\n+                     UNSPEC_VUPKLSH))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vupklsh (operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn \"vperm_v8hiv4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                   (match_operand:V4SI 2 \"register_operand\" \"v\")\n+                   (match_operand:V16QI 3 \"register_operand\" \"v\")]\n+                  UNSPEC_VPERMSI))]\n+  \"TARGET_ALTIVEC\"\n+  \"vperm %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"vperm_v16qiv8hi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n+                   (match_operand:V8HI 2 \"register_operand\" \"v\")\n+                   (match_operand:V16QI 3 \"register_operand\" \"v\")]\n+                  UNSPEC_VPERMHI))]\n+  \"TARGET_ALTIVEC\"\n+  \"vperm %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+\n+(define_expand \"vec_unpacku_hi_v16qi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n+                     UNSPEC_VUPKHUB))]\n+  \"TARGET_ALTIVEC\"      \n+  \"\n+{  \n+  rtx vzero = gen_reg_rtx (V8HImode);\n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+   \n+  emit_insn (gen_altivec_vspltish (vzero, const0_rtx));\n+   \n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 0);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 1);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 2);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 3);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 4);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 5);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 6);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 7);\n+\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vperm_v16qiv8hi (operands[0], operands[1], vzero, mask));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_unpacku_hi_v8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")]\n+                     UNSPEC_VUPKHUH))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx vzero = gen_reg_rtx (V4SImode);\n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+\n+  emit_insn (gen_altivec_vspltisw (vzero, const0_rtx));\n+ \n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 0);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 1);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 2);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 3);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 4);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 5);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 6);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 7);\n+\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vperm_v8hiv4si (operands[0], operands[1], vzero, mask));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_unpacku_lo_v16qi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n+                     UNSPEC_VUPKLUB))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx vzero = gen_reg_rtx (V8HImode);\n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+\n+  emit_insn (gen_altivec_vspltish (vzero, const0_rtx));\n+\n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 8);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 9);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 10);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 11);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 12);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 13);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 14);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 15);\n+\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vperm_v16qiv8hi (operands[0], operands[1], vzero, mask));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_unpacku_lo_v8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")]\n+                     UNSPEC_VUPKLUH))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx vzero = gen_reg_rtx (V4SImode);\n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+\n+  emit_insn (gen_altivec_vspltisw (vzero, const0_rtx));\n+ \n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 8);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 9);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 10);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 11);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 12);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 13);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 14);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 15);\n+\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vperm_v8hiv4si (operands[0], operands[1], vzero, mask));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_widen_umult_hi_v16qi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VMULWHUB))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx ve = gen_reg_rtx (V8HImode);\n+  rtx vo = gen_reg_rtx (V8HImode);\n+  \n+  emit_insn (gen_altivec_vmuleub (ve, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmuloub (vo, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmrghh (operands[0], ve, vo));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_widen_umult_lo_v16qi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VMULWLUB))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx ve = gen_reg_rtx (V8HImode);\n+  rtx vo = gen_reg_rtx (V8HImode);\n+  \n+  emit_insn (gen_altivec_vmuleub (ve, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmuloub (vo, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmrglh (operands[0], ve, vo));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_widen_smult_hi_v16qi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VMULWHSB))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx ve = gen_reg_rtx (V8HImode);\n+  rtx vo = gen_reg_rtx (V8HImode);\n+  \n+  emit_insn (gen_altivec_vmulesb (ve, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmulosb (vo, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmrghh (operands[0], ve, vo));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_widen_smult_lo_v16qi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VMULWLSB))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx ve = gen_reg_rtx (V8HImode);\n+  rtx vo = gen_reg_rtx (V8HImode);\n+  \n+  emit_insn (gen_altivec_vmulesb (ve, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmulosb (vo, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmrglh (operands[0], ve, vo));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_widen_umult_hi_v8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                      (match_operand:V8HI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VMULWHUH))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx ve = gen_reg_rtx (V4SImode);\n+  rtx vo = gen_reg_rtx (V4SImode);\n+  \n+  emit_insn (gen_altivec_vmuleuh (ve, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmulouh (vo, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmrghw (operands[0], ve, vo));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_widen_umult_lo_v8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                      (match_operand:V8HI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VMULWLUH))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx ve = gen_reg_rtx (V4SImode);\n+  rtx vo = gen_reg_rtx (V4SImode);\n+  \n+  emit_insn (gen_altivec_vmuleuh (ve, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmulouh (vo, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmrglw (operands[0], ve, vo));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_widen_smult_hi_v8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                      (match_operand:V8HI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VMULWHSH))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx ve = gen_reg_rtx (V4SImode);\n+  rtx vo = gen_reg_rtx (V4SImode);\n+  \n+  emit_insn (gen_altivec_vmulesh (ve, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmulosh (vo, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmrghw (operands[0], ve, vo));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_widen_smult_lo_v8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                      (match_operand:V8HI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VMULWLSH))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx ve = gen_reg_rtx (V4SImode);\n+  rtx vo = gen_reg_rtx (V4SImode);\n+  \n+  emit_insn (gen_altivec_vmulesh (ve, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmulosh (vo, operands[1], operands[2]));\n+  emit_insn (gen_altivec_vmrglw (operands[0], ve, vo));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_pack_mod_v8hi\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+        (unspec:V16QI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                       (match_operand:V8HI 2 \"register_operand\" \"v\")]\n+                      UNSPEC_VPKUHUM))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vpkuhum (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+                                                                                \n+(define_expand \"vec_pack_mod_v4si\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+                      (match_operand:V4SI 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VPKUWUM))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vpkuwum (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n (define_expand \"negv4sf2\"\n   [(use (match_operand:V4SF 0 \"register_operand\" \"\"))\n    (use (match_operand:V4SF 1 \"register_operand\" \"\"))]"}, {"sha": "eec8a49093a4eccb11da7ba7b0d4756c514386c0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -693,6 +693,8 @@ static int rs6000_sched_reorder (FILE *, int, rtx *, int *, int);\n static int rs6000_sched_reorder2 (FILE *, int, rtx *, int *, int);\n static int rs6000_use_sched_lookahead (void);\n static tree rs6000_builtin_mask_for_load (void);\n+static tree rs6000_builtin_mul_widen_even (tree);\n+static tree rs6000_builtin_mul_widen_odd (tree);\n \n static void def_builtin (int, const char *, tree, int);\n static void rs6000_init_builtins (void);\n@@ -952,6 +954,10 @@ static const char alt_reg_names[][8] =\n \n #undef TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD\n #define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD rs6000_builtin_mask_for_load\n+#undef TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN\n+#define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN rs6000_builtin_mul_widen_even\n+#undef TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD\n+#define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD rs6000_builtin_mul_widen_odd\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS rs6000_init_builtins\n@@ -1631,6 +1637,52 @@ rs6000_builtin_mask_for_load (void)\n     return 0;\n }\n \n+/* Implement targetm.vectorize.builtin_mul_widen_even.  */\n+static tree\n+rs6000_builtin_mul_widen_even (tree type)\n+{\n+  if (!TARGET_ALTIVEC)\n+    return NULL_TREE;\n+\n+  switch (TYPE_MODE (type))\n+    {\n+    case V8HImode:\n+      return TYPE_UNSIGNED (type) ? \n+            rs6000_builtin_decls[ALTIVEC_BUILTIN_VMULEUH] :\n+            rs6000_builtin_decls[ALTIVEC_BUILTIN_VMULESH];\n+\n+    case V16QImode:\n+      return TYPE_UNSIGNED (type) ?\n+            rs6000_builtin_decls[ALTIVEC_BUILTIN_VMULEUB] :\n+            rs6000_builtin_decls[ALTIVEC_BUILTIN_VMULESB];\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Implement targetm.vectorize.builtin_mul_widen_odd.  */\n+static tree\n+rs6000_builtin_mul_widen_odd (tree type)\n+{\n+  if (!TARGET_ALTIVEC)\n+    return NULL_TREE;\n+\n+  switch (TYPE_MODE (type))\n+    {\n+    case V8HImode:\n+      return TYPE_UNSIGNED (type) ?\n+            rs6000_builtin_decls[ALTIVEC_BUILTIN_VMULOUH] :\n+            rs6000_builtin_decls[ALTIVEC_BUILTIN_VMULOSH];\n+\n+    case V16QImode:\n+      return TYPE_UNSIGNED (type) ?\n+            rs6000_builtin_decls[ALTIVEC_BUILTIN_VMULOUB] :\n+            rs6000_builtin_decls[ALTIVEC_BUILTIN_VMULOSB];\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n /* Handle generic options of the form -mfoo=yes/no.\n    NAME is the option name.\n    VALUE is the option value."}, {"sha": "486e71d7779769b8d27af603e33ff9c3c9e0dcab", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -1928,6 +1928,14 @@ This macro returns the attributes on the type @var{type}.\n @tindex OMP_CONTINUE\n @tindex OMP_ATOMIC\n @tindex OMP_CLAUSE\n+@tindex VEC_LSHIFT_EXPR\n+@tindex VEC_RSHIFT_EXPR\n+@tindex VEC_WIDEN_MULT_HI_EXPR\n+@tindex VEC_WIDEN_MULT_LO_EXPR\n+@tindex VEC_UNPACK_HI_EXPR\n+@tindex VEC_UNPACK_LO_EXPR\n+@tindex VEC_PACK_MOD_EXPR\n+@tindex VEC_PACK_SAT_EXPR\n \n The internal representation for expressions is for the most part quite\n straightforward.  However, there are a few facts that one must bear in\n@@ -2735,4 +2743,44 @@ same clause @code{C} need to be represented as multiple @code{C} clauses\n chained together.  This facilitates adding new clauses during\n compilation.\n \n+@item VEC_LSHIFT_EXPR\n+@item VEC_RSHIFT_EXPR\n+These nodes represent whole vector left and right shifts, respectively.  \n+The first operand is the vector to shift; it will always be of vector type.  \n+The second operand is an expression for the number of bits by which to\n+shift.  Note that the result is undefined if the second operand is larger\n+than or equal to the first operand's type size.\n+\n+@item VEC_WIDEN_MULT_HI_EXPR\n+@item VEC_WIDEN_MULT_LO_EXPR\n+These nodes represent widening vector multiplication of the high and low\n+parts of the two input vectors, respectively.  Their operands are vectors \n+that contain the same number of elements (@code{N}) of the same integral type.  \n+The result is a vector that contains half as many elements, of an integral type \n+whose size is twice as wide.  In the case of @code{VEC_WIDEN_MULT_HI_EXPR} the\n+high @code{N/2} elements of the two vector are multiplied to produce the\n+vector of @code{N/2} products. In the case of @code{VEC_WIDEN_MULT_LO_EXPR} the\n+low @code{N/2} elements of the two vector are multiplied to produce the\n+vector of @code{N/2} products.\n+\n+@item VEC_UNPACK_HI_EXPR\n+@item VEC_UNPACK_LO_EXPR\n+These nodes represent unpacking of the high and low parts of the input vector, \n+respectively.  The single operand is a vector that contains @code{N} elements \n+of the same integral type.  The result is a vector that contains half as many \n+elements, of an integral type whose size is twice as wide.  In the case of \n+@code{VEC_UNPACK_HI_EXPR} the high @code{N/2} elements of the vector are \n+extracted and widened (promoted).  In the case of @code{VEC_UNPACK_LO_EXPR} the \n+low @code{N/2} elements of the vector are extracted and widened (promoted).\n+\n+@item VEC_PACK_MOD_EXPR\n+@item VEC_PACK_SAT_EXPR\n+These nodes represent packing of elements of the two input vectors into the\n+output vector, using modulo or saturating arithmetic, respectively.\n+Their operands are vectors that contain the same number of elements \n+of the same integral type.  The result is a vector that contains twice as many \n+elements, of an integral type whose size is half as wide.  In both cases\n+the elements of the two vectors are demoted and merged (concatenated) to form\n+the output vector.\n+\n @end table"}, {"sha": "26be25c1f2dce2dd9e90266ccec2e792320636ba", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -3495,6 +3495,36 @@ Operand 2 is an integer shift amount in bits.\n Operand 0 is where the resulting shifted vector is stored.\n The output and input vectors should have the same modes.\n \n+@cindex @code{vec_pack_mod_@var{m}} instruction pattern\n+@cindex @code{vec_pack_ssat_@var{m}} instruction pattern\n+@cindex @code{vec_pack_usat_@var{m}} instruction pattern\n+@item @samp{vec_pack_mod_@var{m}}, @samp{vec_pack_ssat_@var{m}}, @samp{vec_pack_usat_@var{m}}\n+Narrow (demote) and merge the elements of two vectors.\n+Operands 1 and 2 are vectors of the same mode.\n+Operand 0 is the resulting vector in which the elements of the two input\n+vectors are concatenated after narrowing them down using modulo arithmetic or\n+signed/unsigned saturating arithmetic.\n+\n+@cindex @code{vec_unpacks_hi_@var{m}} instruction pattern\n+@cindex @code{vec_unpacks_lo_@var{m}} instruction pattern\n+@cindex @code{vec_unpacku_hi_@var{m}} instruction pattern\n+@cindex @code{vec_unpacku_lo_@var{m}} instruction pattern\n+@item @samp{vec_unpacks_hi_@var{m}}, @samp{vec_unpacks_lo_@var{m}}, @samp{vec_unpacku_hi_@var{m}}, @samp{vec_unpacku_lo_@var{m}}\n+Extract and widen (promote) the high/low part of a vector of signed/unsigned\n+elements. The input vector (operand 1) has N signed/unsigned elements of size S. \n+Using sign/zero extension widen (promote) the high/low elements of the vector,\n+and place the resulting N/2 values of size 2*S in the output vector (operand 0).\n+\n+@cindex @code{vec_widen_umult_hi_@var{m}} instruction pattern\n+@cindex @code{vec_widen_umult_lo__@var{m}} instruction pattern\n+@cindex @code{vec_widen_smult_hi_@var{m}} instruction pattern\n+@cindex @code{vec_widen_smult_lo_@var{m}} instruction pattern\n+@item @samp{vec_widen_umult_hi_@var{m}}, @samp{vec_widen_umult_lo_@var{m}}, @samp{vec_widen_smult_hi_@var{m}}, @samp{vec_widen_smult_lo_@var{m}}\n+Signed/Unsigned widening multiplication. \n+The two inputs (operands 1 and 2) are vectors with N \n+signed/unsigned elements of size S. Multiply the high/low elements of the two \n+vectors, and put the N/2 products of size 2*S in the output vector (opernad 0). \n+\n @cindex @code{mulhisi3} instruction pattern\n @item @samp{mulhisi3}\n Multiply operands 1 and 2, which have mode @code{HImode}, and store"}, {"sha": "768c7c7540dc1a73d4504090d35b814593f8b7d3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -5284,6 +5284,28 @@ the argument @var{OFF} to @code{REALIGN_LOAD}, in which case the low\n log2(@var{VS})-1 bits of @var{addr} will be considered.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN (tree @var{x})\n+This hook should return the DECL of a function @var{f} that implements\n+widening multiplication of the even elements of two input vectors of type @var{x}.\n+\n+If this hook is defined, the autovectorizer will use it along with the\n+@code{TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD} target hook when vectorizing\n+widening multiplication in cases that the order of the results does not have to be\n+preserved (e.g. used only by a reduction computation). Otherwise, the\n+@code{widen_mult_hi/lo} idioms will be used.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD (tree @var{x})\n+This hook should return the DECL of a function @var{f} that implements\n+widening multiplication of the odd elements of two input vectors of type @var{x}.\n+\n+If this hook is defined, the autovectorizer will use it along with the\n+@code{TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN} target hook when vectorizing\n+widening multiplication in cases that the order of the results does not have to be\n+preserved (e.g. used only by a reduction computation). Otherwise, the\n+@code{widen_mult_hi/lo} idioms will be used.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "f380413760d5f8fb43a86f17a7c187b14dc1ba07", "filename": "gcc/expr.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -8757,6 +8757,37 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn target;\n       }\n \n+    case VEC_UNPACK_HI_EXPR:\n+    case VEC_UNPACK_LO_EXPR:\n+      {\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+\tthis_optab = optab_for_tree_code (code, type);\n+\ttemp = expand_widen_pattern_expr (exp, op0, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t  target, unsignedp);\n+\tgcc_assert (temp);\n+\treturn temp;\n+      }\n+\n+    case VEC_WIDEN_MULT_HI_EXPR:\n+    case VEC_WIDEN_MULT_LO_EXPR:\n+      {\n+\ttree oprnd0 = TREE_OPERAND (exp, 0);\n+\ttree oprnd1 = TREE_OPERAND (exp, 1);\n+\n+\texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, 0);\n+\ttarget = expand_widen_pattern_expr (exp, op0, op1, NULL_RTX,\n+\t\t\t\t\t    target, unsignedp);\n+\tgcc_assert (target);\n+\treturn target;\n+      }\n+\n+    case VEC_PACK_MOD_EXPR:\n+    case VEC_PACK_SAT_EXPR:\n+      {\n+\tmode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\tgoto binop;\n+      }\n+\n     default:\n       return lang_hooks.expand_expr (exp, original_target, tmode,\n \t\t\t\t     modifier, alt_rtl);"}, {"sha": "ceac9fe9507ee292cbe9cc49c8733267553224c9", "filename": "gcc/genopinit.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -214,7 +214,17 @@ static const char * const optabs[] =\n   \"reduc_smin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smin_$a$)\",\n   \"reduc_umin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_umin_$a$)\",\n   \"reduc_splus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_splus_$a$)\" ,\n-  \"reduc_uplus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_uplus_$a$)\" \n+  \"reduc_uplus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_uplus_$a$)\",\n+  \"vec_widen_umult_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_widen_umult_hi_$a$)\",\n+  \"vec_widen_umult_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_widen_umult_lo_$a$)\",\n+  \"vec_widen_smult_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_widen_smult_hi_$a$)\",\n+  \"vec_widen_smult_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_widen_smult_lo_$a$)\",\n+  \"vec_unpacks_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_hi_$a$)\",\n+  \"vec_unpacks_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_lo_$a$)\",\n+  \"vec_unpacku_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_hi_$a$)\",\n+  \"vec_unpacku_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_lo_$a$)\",\n+  \"vec_pack_mod_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_mod_$a$)\",\n+  \"vec_pack_ssat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_ssat_$a$)\",  \"vec_pack_usat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_usat_$a$)\"\n };\n \n static void gen_insn (rtx);"}, {"sha": "a638056d0b11f728400cb7232db9e19afdb52b00", "filename": "gcc/optabs.c", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -315,6 +315,28 @@ optab_for_tree_code (enum tree_code code, tree type)\n     case VEC_RSHIFT_EXPR:\n       return vec_shr_optab;\n \n+    case VEC_WIDEN_MULT_HI_EXPR:\n+      return TYPE_UNSIGNED (type) ? \n+\tvec_widen_umult_hi_optab : vec_widen_smult_hi_optab;\n+\n+    case VEC_WIDEN_MULT_LO_EXPR:\n+      return TYPE_UNSIGNED (type) ? \n+\tvec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n+\n+    case VEC_UNPACK_HI_EXPR:\n+      return TYPE_UNSIGNED (type) ? \n+\tvec_unpacku_hi_optab : vec_unpacks_hi_optab;\n+\n+    case VEC_UNPACK_LO_EXPR:\n+      return TYPE_UNSIGNED (type) ? \n+\tvec_unpacku_lo_optab : vec_unpacks_lo_optab;\n+\n+    case VEC_PACK_MOD_EXPR:\n+      return vec_pack_mod_optab;\n+                                                                                \n+    case VEC_PACK_SAT_EXPR:\n+      return TYPE_UNSIGNED (type) ? vec_pack_usat_optab : vec_pack_ssat_optab;\n+                                                                                \n     default:\n       break;\n     }\n@@ -1276,6 +1298,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       int icode = (int) binoptab->handlers[(int) mode].insn_code;\n       enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+      enum machine_mode tmp_mode;\n       rtx pat;\n       rtx xop0 = op0, xop1 = op1;\n \n@@ -1329,8 +1352,21 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  && mode1 != VOIDmode)\n \txop1 = copy_to_mode_reg (mode1, xop1);\n \n-      if (!insn_data[icode].operand[0].predicate (temp, mode))\n-\ttemp = gen_reg_rtx (mode);\n+      if (binoptab == vec_pack_mod_optab \n+\t  || binoptab == vec_pack_usat_optab\n+          || binoptab == vec_pack_ssat_optab)\n+\t{\n+\t  /* The mode of the result is different then the mode of the\n+\t     arguments.  */\n+\t  tmp_mode = insn_data[icode].operand[0].mode;\n+\t  if (GET_MODE_NUNITS (tmp_mode) != 2 * GET_MODE_NUNITS (mode))\n+\t    return 0;\n+\t}\n+      else\n+        tmp_mode = mode;\n+\n+      if (!insn_data[icode].operand[0].predicate (temp, tmp_mode))\n+\ttemp = gen_reg_rtx (tmp_mode);\n \n       pat = GEN_FCN (icode) (temp, xop0, xop1);\n       if (pat)\n@@ -5354,6 +5390,17 @@ init_optabs (void)\n   vec_shr_optab = init_optab (UNKNOWN);\n   vec_realign_load_optab = init_optab (UNKNOWN);\n   movmisalign_optab = init_optab (UNKNOWN);\n+  vec_widen_umult_hi_optab = init_optab (UNKNOWN);\n+  vec_widen_umult_lo_optab = init_optab (UNKNOWN);\n+  vec_widen_smult_hi_optab = init_optab (UNKNOWN);\n+  vec_widen_smult_lo_optab = init_optab (UNKNOWN);\n+  vec_unpacks_hi_optab = init_optab (UNKNOWN);\n+  vec_unpacks_lo_optab = init_optab (UNKNOWN);\n+  vec_unpacku_hi_optab = init_optab (UNKNOWN);\n+  vec_unpacku_lo_optab = init_optab (UNKNOWN);\n+  vec_pack_mod_optab = init_optab (UNKNOWN);\n+  vec_pack_usat_optab = init_optab (UNKNOWN);\n+  vec_pack_ssat_optab = init_optab (UNKNOWN);\n \n   powi_optab = init_optab (UNKNOWN);\n "}, {"sha": "d197766c772a5f62d071734c8ed021fe7b5f6ba4", "filename": "gcc/optabs.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -260,6 +260,22 @@ enum optab_index\n   OTI_vec_shr,\n   /* Extract specified elements from vectors, for vector load.  */\n   OTI_vec_realign_load,\n+  /* Widening multiplication.  \n+     The high/low part of the resulting vector of products is returned.  */\n+  OTI_vec_widen_umult_hi,\n+  OTI_vec_widen_umult_lo,\n+  OTI_vec_widen_smult_hi,\n+  OTI_vec_widen_smult_lo,\n+  /* Extract and widen the high/low part of a vector of signed/unsigned \n+     elements.  */\n+  OTI_vec_unpacks_hi,\n+  OTI_vec_unpacks_lo,\n+  OTI_vec_unpacku_hi,\n+  OTI_vec_unpacku_lo,\n+  /* Narrow (demote) and merge the elements of two vectors.  */\n+  OTI_vec_pack_mod,\n+  OTI_vec_pack_usat,\n+  OTI_vec_pack_ssat,\n \n   /* Perform a raise to the power of integer.  */\n   OTI_powi,\n@@ -385,7 +401,18 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define vec_shl_optab (optab_table[OTI_vec_shl])\n #define vec_shr_optab (optab_table[OTI_vec_shr])\n #define vec_realign_load_optab (optab_table[OTI_vec_realign_load])\n-\n+#define vec_widen_umult_hi_optab (optab_table[OTI_vec_widen_umult_hi])\n+#define vec_widen_umult_lo_optab (optab_table[OTI_vec_widen_umult_lo])\n+#define vec_widen_smult_hi_optab (optab_table[OTI_vec_widen_smult_hi])\n+#define vec_widen_smult_lo_optab (optab_table[OTI_vec_widen_smult_lo])\n+#define vec_unpacks_hi_optab (optab_table[OTI_vec_unpacks_hi])\n+#define vec_unpacku_hi_optab (optab_table[OTI_vec_unpacku_hi])\n+#define vec_unpacks_lo_optab (optab_table[OTI_vec_unpacks_lo])\n+#define vec_unpacku_lo_optab (optab_table[OTI_vec_unpacku_lo])\n+#define vec_pack_mod_optab (optab_table[OTI_vec_pack_mod])\n+#define vec_pack_ssat_optab (optab_table[OTI_vec_pack_ssat])\n+#define vec_pack_usat_optab (optab_table[OTI_vec_pack_usat])\n+                                                                                \n #define powi_optab (optab_table[OTI_powi])\n \n /* Conversion optabs have their own table and indexes.  */"}, {"sha": "1e158c164f3612c9019ab7abf513dc2e27e5366a", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -332,9 +332,13 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n    TARGET_SCHED_SET_SCHED_FLAGS}\n \n #define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD 0\n+#define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN 0\n+#define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD 0\n \n #define TARGET_VECTORIZE                                                \\\n-  {TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD}\n+  {TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD,\t\t\t\t\\\n+   TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN,                             \\\n+   TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD}\n \n #define TARGET_DEFAULT_TARGET_FLAGS 0\n "}, {"sha": "82eaccdd5515f52f1426d4e74683d73f0a65d562", "filename": "gcc/target.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -369,6 +369,13 @@ struct gcc_target\n        by the vectorizer, and return the decl of the target builtin\n        function.  */\n     tree (* builtin_mask_for_load) (void);\n+\n+    /* Target builtin that implements vector widening multiplication.\n+       builtin_mul_widen_eve computes the element-by-element products \n+       for the even elements, and builtin_mul_widen_odd computes the\n+       element-by-element products for the odd elements.  */\n+    tree (* builtin_mul_widen_even) (tree);\n+    tree (* builtin_mul_widen_odd) (tree);\n   } vectorize;\n \n   /* The initial value of target_flags.  */"}, {"sha": "1a6cf27a3fb10acf222942562e3070bfe0ccf91b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -1,3 +1,67 @@\n+2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-1.c: Loop with multiple types removed (appears in\n+\tvect-9.c).\n+\t* gcc.dg/vect/vect-106.c: Removed (duplicate of vect-9.c).\n+\t* gcc.dg/vect/vect-9.c: Now vectorizable.\n+\t* gcc.dg/vect/vect-reduc-dot-s16a.c: Now vectorizable also on targets\n+\tthat support vect_widen_mult. \n+\t* gcc.dg/vect/vect-reduc-dot-u16.c: Removed (split into two new tests).\n+\t* gcc.dg/vect/vect-reduc-dot-u16a.c: New test (split from \n+\tvect-reduc-dot-u16.c).\n+\t* gcc.dg/vect/vect-reduc-dot-u16b.c: New test (split from \n+\tvect-reduc-dot-u16.c).\n+\t* gcc.dg/vect/vect-reduc-dot-s8.c: Removed (split into three new tests).\n+\t* gcc.dg/vect/vect-reduc-dot-s8a.c: New test (split from\n+\tvect-reduc-dot-s8.c).\n+\t* gcc.dg/vect/vect-reduc-dot-s8b.c: New test (split from\n+\tvect-reduc-dot-s8.c).\n+\t* gcc.dg/vect/vect-reduc-dot-s8c.c: New test (split from\n+\tvect-reduc-dot-s8.c).\n+\t* gcc.dg/vect/vect-reduc-dot-u8.c: Removed (split into two new tests).\n+\t* gcc.dg/vect/vect-reduc-dot-u8a.c: New test (split from\n+\tvect-reduc-dot-u8.c).\n+\t* gcc.dg/vect/vect-reduc-dot-u8b.c: New test (split from\n+\tvect-reduc-dot-u8.c).\n+\t* gcc.dg/vect/vect-widen-mult-sum.c: New test.\n+\t* gcc.dg/vect/vect-multitypes-9.c: New test.\n+\t* gcc.dg/vect/vect-multitypes-10.c: New test.\n+\t* gcc.dg/vect/vect-widen-mult-s16.c: New test.\n+\t* gcc.dg/vect/vect-widen-mult-u16.c: New test.\n+\t* gcc.dg/vect/vect-widen-mult-u8.c: New test.\n+\t* gcc.dg/vect/vect-widen-mult-s8.c: New test.\n+\t* gcc.dg/vect/wrapv-vect-reduc-dot-s8.c: Removed.\n+\t* gcc.dg/vect/wrapv-vect-reduc-dot-s8b.c: New reduced version of\n+\twrapv-vect-reduc-dot-s8.c.\n+\t* lib/target-support.exp (check_effective_target_vect_unpack): New.\n+\t(check_effective_target_vect_widen_sum_hi_to_si): Now also includes\n+\ttargets that support vec_unpack. \n+\t(check_effective_target_vect_widen_sum_qi_to_hi): Likewise.\n+\t(check_effective_target_vect_widen_mult_qi_to_hi): New.\n+\t(check_effective_target_vect_widen_mult_hi_to_si): New.\n+\t(check_effective_target_vect_widen_sum): Removed.\n+\n+\t2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-multitypes-8.c: New test.\n+\t* lib/target-supports.exp (check_effective_target_vect_pack_mod): New.\n+\n+\t2006-11-08 Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-multitypes-7.c: New test.\n+\n+\t2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-multitypes-4.c: New test.\n+\t* gcc.dg/vect/vect-multitypes-5.c: New test.\n+\t* gcc.dg/vect/vect-multitypes-6.c: New test.\n+\n+\t2006-11-08  Dorit Nuzman  <dorit@il.ibm.com>\n+\t\n+\t* gcc.dg/vect/vect-multitypes-1.c: New test.\n+\t* gcc.dg/vect/vect-multitypes-2.c: New test.\n+\t* gcc.dg/vect/vect-multitypes-3.c: New test.\n+\n 2006-11-07  Eric Christopher  <echristo@apple.com>\n \n \t* gcc.target/i386/builtin-bswap-1.c: Rewrite for 64-bit."}, {"sha": "6df6af078f50b633ec58fef8ff6fd44f5c2a87e4", "filename": "gcc/testsuite/gcc.dg/vect/vect-1.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -19,9 +19,6 @@ foo (int n)\n   int ia[N];\n   int ib[N];\n   int ic[N];\n-  short sa[N];\n-  short sb[N];\n-  short sc[N];\n   int i,j;\n   int diff = 0;\n   char cb[N];\n@@ -80,16 +77,6 @@ foo (int n)\n   fbar (a);\n   fbar (d);\n \n-\n-  /* Not vectorizable yet (two types with different nunits in vector).  */\n-  for (i = 0; i < N; i++){\n-    ia[i] = ib[i] + ic[i];\n-    sa[i] = sb[i] + sc[i];\n-  }\n-  ibar (ia);\n-  sbar (sa);\n-\n-\n   /* Not vetorizable yet (too conservative dependence test).  */\n   for (i = 0; i < N; i++){\n     a[i] = b[i] + c[i];"}, {"sha": "43e43a6cd1f2d16569dcfea8d95cd3e7e6e58072", "filename": "gcc/testsuite/gcc.dg/vect/vect-106.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6300f037d02324e91b3987acbbb16f727dd3c9b8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-106.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6300f037d02324e91b3987acbbb16f727dd3c9b8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-106.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-106.c?ref=6300f037d02324e91b3987acbbb16f727dd3c9b8", "patch": "@@ -1,40 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"tree-vect.h\"\n-\n-#define N 16\n-\n-int\n-main1 (void)\n-{\n-  int i;\n-  short sb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n-  int ia[N];\n-\n-  /* Type cast.  */\n-  for (i = 0; i < N; i++)\n-    {\n-      ia[i] = (int) sb[i];\n-    }\n-\n-\n-  /* Check results.  */\n-  for (i = 0; i < N; i++)\n-    {\n-      if (ia[i] != (int) sb[i])\n-\tabort();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{\n-  check_vect ();\n-  return main1 ();\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */ \n-/* { dg-final { cleanup-tree-dump \"vect\" } } */\n-"}, {"sha": "e861a772d5b969f1272f64eaae192eecea7f2124", "filename": "gcc/testsuite/gcc.dg/vect/vect-109.c", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -3,42 +3,75 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 16\n+#define N 32\n \n-int\n-main1 ()\n+short sa[N];\n+short sc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n+\t\t16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+short sb[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n+\t\t16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+int ia[N];\n+int ic[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,\n+\t       0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,\n+\t       0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+int main1 (int n)\n+{\n+  int i;\n+\n+  /* Multiple types with different sizes, used in idependent\n+     copmutations. Vectorizable.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      sa[i+2] = sb[i] + sc[i];\n+      ia[i+1] = ib[i] + ic[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (sa[i+2] != sb[i] + sc[i] || ia[i+1] != ib[i] + ic[i])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main2 (int n)\n {\n   int i;\n-  short sc[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n-  short sb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n-  short sa[N];\n-  int ic[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n-  int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n-  int ia[N];\n-\n-  /* Two types with different nunits in vector.  */\n-  for (i = 0; i < N; i++)\n+\n+  /* Multiple types with different sizes, used in idependent\n+     copmutations. Vectorizable.  */\n+  for (i = 0; i < n; i++)\n     {\n-      ia[i] = ib[i] + ic[i];\n+      ia[i+1] = ib[i] + ic[i];\n       sa[i] = sb[i] + sc[i];\n     }\n \n-  /* Check results.  */\n-  for (i = 0; i < N; i++)\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n     {\n-      if (ia[i] != ib[i] + ic[i] || sa[i] != sb[i] + sc[i])\n-\tabort();\n+      if (sa[i] != sb[i] + sc[i] || ia[i+1] != ib[i] + ic[i])\n+        abort ();\n     }\n \n- return 0;\n+  return 0;\n }\n-     \n+\n+\n int main (void)\n-{    \n+{ \n   check_vect ();\n-  return main1 ();\n+  \n+  main1 (N-2);\n+  main2 (N-1);\n+\n+  return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 2 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "77ff55e064c4ccc4dd19b5c9c7901bf4d1e52a09", "filename": "gcc/testsuite/gcc.dg/vect/vect-9.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-9.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -11,7 +11,7 @@ int main1 ()\n   short sb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n   int ia[N];\n \n-  /* Not vetorizable yet (type cast).  */\n+  /* Requires type promotion (vector unpacking) support.  */\n   for (i = 0; i < N; i++)\n     {\n       ia[i] = (int) sb[i];\n@@ -34,5 +34,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_unpack } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ed463fb39dd046d46dcf36cb8f6abacd1a330b89", "filename": "gcc/testsuite/gcc.dg/vect/vect-96.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -38,7 +38,7 @@ int main (void)\n }\n \n /* The store is unaligned, the load is aligned. For targets that support unaligned\n-   loads, peel to align the store and generated unaligned access for the loads.\n+   loads, peel to align the store and generate an unaligned access for the load.\n    For targets that don't support unaligned loads, version for the store.  */\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "2b8840119526786f0ae0e64516b9ac1a2c7add67", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,87 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+short sa[N];\n+short sb[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n+\t\t16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+int ia[N];\n+int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,\n+\t       0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+/* Current peeling-for-alignment scheme will consider the 'sa[i+7]'\n+   access for peeling, and therefore will examine the option of\n+   using a peeling factor = VF-7%VF. This will result in a peeling factor 1,\n+   which will also align the access to 'ia[i+3]', and the loop could be \n+   vectorized on all targets that support unaligned loads.\n+ */\n+\n+int main1 (int n)\n+{\n+  int i;\n+\n+  /* Multiple types with different sizes, used in idependent\n+     copmutations. Vectorizable.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      sa[i+7] = sb[i];\n+      ia[i+3] = ib[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (sa[i+7] != sb[i] || ia[i+3] != ib[i])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* Current peeling-for-alignment scheme will consider the 'ia[i+3]'\n+   access for peeling, and therefore will examine the option of\n+   using a peeling factor = VF-3%VF. This will result in a peeling factor\n+   5 if VF=8, or 1 if VF=4,2. In either case, this will also align the access \n+   to 'sa[i+3]', and the loop could be vectorized on targets that support \n+   unaligned loads.  */\n+\n+int main2 (int n)\n+{\n+  int i;\n+\n+  /* Multiple types with different sizes, used in independent\n+     copmutations. Vectorizable.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      ia[i+3] = ib[i];\n+      sa[i+3] = sb[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (sa[i+3] != sb[i] || ia[i+3] != ib[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (N-7);\n+  main2 (N-3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "8958467258912c10ad3e178f9710fb7585020678", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-10.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-10.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char uX[N] __attribute__ ((__aligned__(16)));\n+unsigned short uY[N] __attribute__ ((__aligned__(16)));\n+unsigned int uresult[N];\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+signed short Y[N] __attribute__ ((__aligned__(16)));\n+int result[N];\n+\n+/* Unsigned type promotion (hi->si) */\n+int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    uX[i] = 5;\n+    uresult[i] = (unsigned int)uY[i];\n+  }\n+}\n+\n+/* Signed type promotion (hi->si) */\n+int\n+foo2(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    uX[i] = 5;\n+    result[i] = (int)Y[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = 16-i;\n+    uX[i] = 16-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (uresult[i] != (unsigned short)uY[i])\n+      abort ();\n+  }\n+  \n+  foo2 (N);\n+  \n+  for (i=0; i<N; i++) {\n+    if (result[i] != (short)Y[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_unpack } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "4f4ecbc5a4a68cd1e0bf2fbc300037433d6b8ef7", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-2.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+int main1 ()\n+{\n+  int i;\n+  int ia[N];\n+  int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  short sa[N];\n+  short sb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  char ca[N];\n+  char cb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+  /* Multiple types with different sizes, used in independent\n+     cmputations. Vectorizable. All accesses aligned.   */\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i];\n+      sa[i] = sb[i];\n+      ca[i] = cb[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != ib[i] \n+\t  || sa[i] != sb[i] \n+\t  || ca[i] != cb[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "959fa025e3946badf905cd64528372776a857ec0", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-3.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+int ib[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+short sb[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+char cb[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+int main1 (int n, int * __restrict__ pib, \n+\t   short * __restrict__ psb, \n+\t   char * __restrict__ pcb)\n+{\n+  int i;\n+  int ia[N];\n+  short sa[N];\n+  char ca[N];\n+\n+  /* Multiple types with different sizes, used in independent\n+     computations. Vectorizable. The loads are misaligned.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      ia[i] = pib[i];\n+      sa[i] = psb[i];\n+      ca[i] = pcb[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (ia[i] != pib[i] \n+\t  || sa[i] != psb[i] \n+\t  || ca[i] != pcb[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (N, ib, sb, cb);\n+  main1 (N-3, ib, sb, &cb[2]);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" {xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "63f244d06b789966ccdd5e7463f81b8861f95ba0", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+unsigned short sa[N];\n+unsigned short sc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n+\t\t16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+unsigned short sb[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n+\t\t16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+unsigned int ia[N];\n+unsigned int ic[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,\n+\t       0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+unsigned int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,\n+\t       0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+/* Current peeling-for-alignment scheme will consider the 'sa[i+7]'\n+   access for peeling, and therefore will examine the option of\n+   using a peeling factor = VF-7%VF. This will result in a peeling factor 1,\n+   which will also align the access to 'ia[i+3]', and the loop could be\n+   vectorized on all targets that support unaligned loads.\n+ */\n+\n+int main1 (int n)\n+{\n+  int i;\n+\n+  /* Multiple types with different sizes, used in independent\n+     copmutations. Vectorizable.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      sa[i+7] = sb[i] + sc[i];\n+      ia[i+3] = ib[i] + ic[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (sa[i+7] != sb[i] + sc[i] || ia[i+3] != ib[i] + ic[i])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* Current peeling-for-alignment scheme will consider the 'ia[i+3]'\n+   access for peeling, and therefore will examine the option of\n+   using a peeling factor = VF-3%VF. This will result in a peeling factor\n+   5 if VF=8, or 1 if VF=4,2. In either case, this will also align the access \n+   to 'sa[i+3]', and the loop could be vectorized on targets that support \n+   unaligned loads.  */\n+\n+int main2 (int n)\n+{\n+  int i;\n+\n+  /* Multiple types with different sizes, used in independent\n+     copmutations. Vectorizable.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      ia[i+3] = ib[i] + ic[i];\n+      sa[i+3] = sb[i] + sc[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (sa[i+3] != sb[i] + sc[i] || ia[i+3] != ib[i] + ic[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (N-7);\n+  main2 (N-3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 8 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "d6ad34d7468e5cbb0f5907bbec1d684293c71e4e", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-5.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+int main1 ()\n+{\n+  int i;\n+  unsigned int ia[N];\n+  unsigned int ic[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned  int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned short sa[N];\n+  unsigned short sc[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned short sb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned char ca[N];\n+  unsigned char cc[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned char cb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+  /* Multiple types with different sizes, used in independent\n+     computations. Vectorizable. All accesses aligned.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i] + ic[i];\n+      sa[i] = sb[i] + sc[i];\n+      ca[i] = cb[i] + cc[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != ib[i] + ic[i] \n+\t  || sa[i] != sb[i] + sc[i] \n+\t  || ca[i] != cb[i] + cc[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "34c284a2a9b19a44c04e9e82a22424f992c28651", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-6.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+unsigned int ic[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+unsigned int ib[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+unsigned short sc[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+unsigned short sb[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+unsigned char cc[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+unsigned char cb[N] __attribute__ ((__aligned__(16))) = \n+\t{0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+int main1 (int n, \n+\t   unsigned int * __restrict__ pic, unsigned int * __restrict__ pib, \n+\t   unsigned short * __restrict__ psc, unsigned short * __restrict__ psb,\n+\t   unsigned char * __restrict__ pcc, unsigned char * __restrict__ pcb)\n+{\n+  int i;\n+  unsigned int ia[N];\n+  unsigned short sa[N];\n+  unsigned char ca[N];\n+\n+  /* Multiple types with different sizes, used in independent\n+     computations. Vectorizable. The loads are misaligned.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      ia[i] = pib[i] + pic[i];\n+      sa[i] = psb[i] + psc[i];\n+      ca[i] = pcb[i] + pcc[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (ia[i] != pib[i] + pic[i] \n+\t  || sa[i] != psb[i] + psc[i] \n+\t  || ca[i] != pcb[i] + pcc[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (N, ic, ib, sc, sb, cc, cb);\n+  main1 (N-3, ic, ib, &sc[1], sb, cc, &cb[2]);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 6 \"vect\" {xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "8cbb502a3f39643219ed2c32f86b5b24cbec0ecf", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-7.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-7.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+#include <stdio.h>\n+\n+#define N 64\n+\n+#define DOT1 43680\n+#define DOT2 -20832\n+\n+signed short X[N] __attribute__ ((__aligned__(16)));\n+signed short Y[N] __attribute__ ((__aligned__(16)));\n+unsigned char CX[N] __attribute__ ((__aligned__(16)));\n+\n+void\n+foo1(int len) {\n+  int i;\n+  int result1 = 0;\n+  short prod;\n+\n+  for (i=0; i<len; i++) {\n+    result1 += (X[i] * Y[i]);\n+    CX[i] = 5;\n+  }\n+\n+  if (result1 != DOT1)\n+    abort ();\n+}\n+\n+\n+int main (void)\n+{\n+  int i, dot1, dot2;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+    CX[i] = i;\n+  }\n+\n+  foo1 (N);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_hi } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "639415cdff21bfb4186519971a5b1c675ca9e657", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-8.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-8.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char uX[N] __attribute__ ((__aligned__(16)));\n+unsigned char uresultX[N];\n+unsigned int uY[N] __attribute__ ((__aligned__(16)));\n+unsigned short uresultY[N];\n+\n+/* Unsigned type demotion (si->hi) */\n+\n+int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    uresultX[i] = uX[i];\n+    uresultY[i] = (unsigned short)uY[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    uX[i] = 16-i;\n+    uY[i] = 16-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (uresultX[i] != uX[i])\n+      abort ();\n+    if (uresultY[i] != (unsigned short)uY[i])\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_pack_mod } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "82c53e461f3e9ae4295eb05fe6728c241fa9b11e", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-9.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-9.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char uX[N] __attribute__ ((__aligned__(16)));\n+unsigned short uresult[N];\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+short result[N];\n+\n+/* Unsigned type promotion (qi->hi) */\n+int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    uresult[i] = (unsigned short)uX[i];\n+  }\n+}\n+\n+/* Signed type promotion (qi->hi) */\n+int\n+foo2(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    result[i] = (short)X[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = 16-i;\n+    uX[i] = 16-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (uresult[i] != (unsigned short)uX[i])\n+      abort ();\n+  }\n+  \n+  foo2 (N);\n+  \n+  for (i=0; i<N; i++) {\n+    if (result[i] != (short)X[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_unpack } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "4f0c3e999d518602d4535ac76113c39178b05ad2", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s16a.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s16a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s16a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s16a.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -50,5 +50,6 @@ main (void)\n \n /* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_hi } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "31bdb1079fb4539a56a813e30c23e8b992fe6de0", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8a.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8a.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT1 43680\n+\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+signed char Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* char->short->int dot product.\n+   The dot-product pattern should be detected.\n+   Vectorizable on vect_sdot_qi targets (targets that support dot-product of \n+   signed chars).\n+\n+   In the future could also be vectorized as widening-mult + widening-summation,\n+   or with type-conversion support.\n+ */\n+int\n+foo1(int len) {\n+  int i;\n+  int result = 0;\n+  short prod;\n+\n+  for (i=0; i<len; i++) {\n+    prod = X[i] * Y[i];\n+    result += prod;\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  int i, dot1;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot1 = foo1 (N);\n+  if (dot1 != DOT1)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_qi } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_qi_to_hi && vect_widen_sum_hi_to_si } } } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9b22d748e1ac69fb0c89dbd6361665e2fe63b31f", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8b.c", "status": "renamed", "additions": 6, "deletions": 53, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8b.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -5,34 +5,11 @@\n \n #define N 64\n \n-#define DOT1 43680\n #define DOT2 -21856\n-#define DOT3 43680\n \n signed char X[N] __attribute__ ((__aligned__(16)));\n signed char Y[N] __attribute__ ((__aligned__(16)));\n \n-/* char->short->int dot product.\n-   The dot-product pattern should be detected.\n-   Vectorizable on vect_sdot_qi targets (targets that support dot-product of \n-   signed chars).\n-\n-   In the future could also be vectorized as widening-mult + widening-summation,\n-   or with type-conversion support.\n- */\n-int\n-foo1(int len) {\n-  int i;\n-  int result = 0;\n-  short prod;\n-\n-  for (i=0; i<len; i++) {\n-    prod = X[i] * Y[i];\n-    result += prod;\n-  }\n-  return result;\n-}\n-\n /* char->short->short dot product.\n    The dot-product pattern should be detected.\n    The reduction is currently not vectorized becaus of the signed->unsigned->signed\n@@ -45,9 +22,8 @@ foo1(int len) {\n    When the dot-product is detected, the loop should be vectorized on vect_sdot_qi \n    targets (targets that support dot-product of signed char).  \n    This test would currently fail to vectorize on targets that support\n-   dot-product of chars when the accumulator is int.\n-\n-   In the future could also be vectorized as widening-mult + summation,\n+   dot-product of chars into an int accumulator.\n+   Alternatively, the loop could also be vectorized as widening-mult + summation,\n    or with type-conversion support.\n  */\n short\n@@ -61,23 +37,9 @@ foo2(int len) {\n   return result;\n }\n \n-/* char->int->int dot product. \n-   Not detected as a dot-product pattern.\n-   Currently fails to be vectorized due to presence of type conversions. */\n-int\n-foo3(int len) {\n-  int i;\n-  int result = 0;\n-\n-  for (i=0; i<len; i++) {\n-    result += (X[i] * Y[i]);\n-  }\n-  return result;\n-}\n-\n int main (void)\n {\n-  int i, dot1, dot3;\n+  int i;\n   short dot2;\n \n   check_vect ();\n@@ -87,25 +49,16 @@ int main (void)\n     Y[i] = 64-i;\n   }\n \n-  dot1 = foo1 (N);\n-  if (dot1 != DOT1)\n-    abort ();\n-\n   dot2 = foo2 (N);\n   if (dot2 != DOT2)\n     abort ();\n \n-  dot3 = foo3 (N);\n-  if (dot3 != DOT3)\n-    abort ();\n-\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" } } */\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_qi } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n \n /* { dg-final { cleanup-tree-dump \"vect\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8.c"}, {"sha": "bba41dfd80bf63b7df90207299ebe3939b29ead0", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8c.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8c.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT3 43680\n+\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+signed char Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* char->int->int dot product. \n+   Not detected as a dot-product pattern.\n+   Currently fails to be vectorized due to presence of type conversions. */\n+int\n+foo3(int len) {\n+  int i;\n+  int result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  int i, dot3;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot3 = foo3 (N);\n+  if (dot3 != DOT3)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "38753f725d8182380fc9fbda76cb0333a8934b15", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16a.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16a.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT1 43680\n+#define DOT2 43680\n+\n+unsigned short X[N] __attribute__ ((__aligned__(16)));\n+unsigned short Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* short->short->int dot product. \n+   Not detected as a dot-product pattern.\n+   Requires support for non-widneing multiplication and widening-summation.  */\n+unsigned int\n+foo1(int len) {\n+  int i;\n+  unsigned int result = 0;\n+  unsigned short prod;\n+\n+  for (i=0; i<len; i++) {\n+    prod = X[i] * Y[i];\n+    result += prod;\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  unsigned int dot1;\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot1 = foo1 (N);\n+  if (dot1 != DOT1)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_short_mult && vect_widen_sum_hi_to_si } } } } */ \n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7c83108eace460c918a7e93d5027cf846955a196", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16b.c", "status": "renamed", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16b.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -5,28 +5,11 @@\n \n #define N 64\n \n-#define DOT1 43680\n #define DOT2 43680\n \n unsigned short X[N] __attribute__ ((__aligned__(16)));\n unsigned short Y[N] __attribute__ ((__aligned__(16)));\n \n-/* short->short->int dot product. \n-   Not detected as a dot-product pattern.\n-   Not vectorized due to presence of type-conversions. */\n-unsigned int\n-foo1(int len) {\n-  int i;\n-  unsigned int result = 0;\n-  unsigned short prod;\n-\n-  for (i=0; i<len; i++) {\n-    prod = X[i] * Y[i];\n-    result += prod;\n-  }\n-  return result;\n-}\n-\n /* short->int->int dot product. \n    Currently not detected as a dot-product pattern: the multiplication \n    promotes the ushorts to int, and then the product is promoted to unsigned \n@@ -46,7 +29,7 @@ foo2(int len) {\n \n int main (void)\n {\n-  unsigned int dot1, dot2;\n+  unsigned int  dot2;\n   int i;\n \n   check_vect ();\n@@ -56,10 +39,6 @@ int main (void)\n     Y[i] = 64-i;\n   }\n \n-  dot1 = foo1 (N);\n-  if (dot1 != DOT1)\n-    abort ();\n-\n   dot2 = foo2 (N);\n   if (dot2 != DOT2)\n     abort ();\n@@ -69,9 +48,9 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n \n-/* Once the dot-product pattern is detected in the second loop, we expect\n+/* Once the dot-product pattern is detected, we expect\n    that loop to be vectorized on vect_udot_hi targets (targets that support \n-   dot-product of unsigned shorts).  */\n+   dot-product of unsigned shorts) and targets that support widening multiplication.  */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */ \n \n /* { dg-final { cleanup-tree-dump \"vect\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16.c"}, {"sha": "ad68bc752c5f673c6eab31afdf417b801f5e8b0f", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8.c", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6300f037d02324e91b3987acbbb16f727dd3c9b8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6300f037d02324e91b3987acbbb16f727dd3c9b8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8.c?ref=6300f037d02324e91b3987acbbb16f727dd3c9b8", "patch": "@@ -1,101 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"tree-vect.h\"\n-\n-#define N 64\n-\n-#define DOT1 43680\n-#define DOT2 43680\n-#define DOT3 43680\n-\n-unsigned char X[N] __attribute__ ((__aligned__(16)));\n-unsigned char Y[N] __attribute__ ((__aligned__(16)));\n-\n-/* char->short->int dot product. \n-   Detected as a dot-product pattern.\n-   Should be vectorized on targets that support dot-product for unsigned chars.\n-   */\n-unsigned int\n-foo1(int len) {\n-  int i;\n-  unsigned int result = 0;\n-  unsigned short prod;\n-\n-  for (i=0; i<len; i++) {\n-    prod = X[i] * Y[i];\n-    result += prod;\n-  }\n-  return result;\n-}\n-\n-/* char->short->short dot product. \n-   Detected as a dot-product pattern.\n-   Should be vectorized on targets that support dot-product for unsigned chars.\n-   This test currently fails to vectorize on targets that support dot-product \n-   of chars only when the accumulator is int.\n-   */\n-unsigned short\n-foo2(int len) {\n-  int i;\n-  unsigned short result = 0;\n-\n-  for (i=0; i<len; i++) {\n-    result += (unsigned short)(X[i] * Y[i]);\n-  }\n-  return result;\n-}\n-\n-/* char->int->int dot product. \n-   Not detected as a dot-product.\n-   Doesn't get vectorized due to presence of type converisons.  */\n-unsigned int\n-foo3(int len) {\n-  int i;\n-  unsigned int result = 0;\n-\n-  for (i=0; i<len; i++) {\n-    result += (X[i] * Y[i]);\n-  }\n-  return result;\n-}\n-\n-int main (void)\n-{\n-  unsigned int dot1, dot3;\n-  unsigned short dot2;\n-  int i;\n-\n-  check_vect ();\n-\n-  for (i=0; i<N; i++) {\n-    X[i] = i;\n-    Y[i] = 64-i;\n-  }\n-\n-  dot1 = foo1 (N);\n-  if (dot1 != DOT1)\n-    abort ();\n-\n-  dot2 = foo2 (N);\n-  if (dot2 != DOT2)\n-    abort ();\n-\n-  dot3 = foo3 (N);\n-  if (dot3 != DOT3)\n-    abort ();\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 2 \"vect\" } } */\n-\n-/* When the vectorizer is enhanced to vectorize foo2 (accumulation into short) for \n-   targets that support accumulation into int (powerpc, ia64) we'd have:\n-dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_udot_qi } }\n-*/\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_udot_qi } } } */\n-\n-/* { dg-final { cleanup-tree-dump \"vect\" } } */\n-"}, {"sha": "0c5cf78f2f420f877020d802358ef19b123d4ca7", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8a.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8a.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT 43680\n+\n+unsigned char X[N] __attribute__ ((__aligned__(16)));\n+unsigned char Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* char->short->int dot product. \n+   Detected as a dot-product pattern.\n+   Should be vectorized on targets that support dot-product for unsigned chars\n+   (vect_udot_qi),\n+   and on targets that support widening-multiplication and widening-summation\n+   (vect_widen_mult_qi && vec_widen_sum_qi_to_si).\n+   Widening-multiplication can also be supported by type promotion and non-widening \n+   multiplication (vect_unpack && vect_short_mult);\n+   Widening summation can also be supported by type promotion and non-widening \n+   summation (vect_unpack).\n+   */\n+unsigned int\n+foo (int len) {\n+  int i;\n+  unsigned int result = 0;\n+  unsigned short prod;\n+\n+  for (i=0; i<len; i++) {\n+    prod = X[i] * Y[i];\n+    result += prod;\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  unsigned int dot;\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot = foo (N);\n+  if (dot != DOT)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_udot_qi } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_qi_to_hi && vect_widen_sum_qi_to_si } } } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "e3216a0b31916a9cd6955a714a0bdab3ba91867a", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8b.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8b.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT 43680\n+\n+unsigned char X[N] __attribute__ ((__aligned__(16)));\n+unsigned char Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* char->short->short dot product. \n+   Detected as a dot-product pattern.\n+   Should be vectorized on targets that support dot-product for unsigned chars,\n+   but currently this test cannot be vectorized as a dot-product on targets\n+   that support char->short->int dot-product. \n+   Alternatively, this test can be vectorized using vect_widen_mult_qi (or\n+   vect_unpack and non-widening multplication: vect_unpack && vect_short_mult).\n+   */\n+unsigned short\n+foo (int len) {\n+  int i;\n+  unsigned short result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (unsigned short)(X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  unsigned short dot;\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot = foo (N);\n+  if (dot != DOT)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" } } */\n+\n+/* When the vectorizer is enhanced to vectorize accumulation into short for \n+   targets that support accumulation into int (powerpc, ia64) we'd have:\n+dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_udot_qi || vect_widen_mult_qi_to_hi } }\n+*/\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" {target vect_widen_mult_qi_to_hi} } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "23baa20bdedd410fde107a6811497cdc65734f62", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-s16.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-s16.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+short X[N] __attribute__ ((__aligned__(16)));\n+short Y[N] __attribute__ ((__aligned__(16)));\n+int result[N];\n+\n+/* short->int widening-mult */\n+int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    result[i] = X[i] * Y[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "626b22f0565fc9ceb4cb99ecfae5b7bb919039ec", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-s8.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-s8.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+signed char Y[N] __attribute__ ((__aligned__(16)));\n+short result[N];\n+\n+/* char->short widening-mult */\n+int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    result[i] = X[i] * Y[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "668b20c478b2a44c51a0894add58b40d3f07af6d", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-sum.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+#define SUM 0 \n+ \n+/* Require widening-mult or data-unpacking (for the type promotion).  */\n+int\n+main1 (short *in, int off, short scale, int n)\n+{\n+ int i;\n+ int sum = 0;\n+\n+ for (i = 0; i < n; i++) {\n+   sum += ((int) in[i] * (int) in[i+off]) >> scale;\n+ }\n+\n+ return sum;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  int sum;\n+  short X[N];\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = 16-i; \n+  }\n+\n+  sum = main1 (X, 1, 16, N-1);\n+  \n+  if (sum != SUM)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3531d20f2472a97c2f002f2e0be3a4d040ed1f03", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u16.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned short X[N] __attribute__ ((__aligned__(16)));\n+unsigned short Y[N] __attribute__ ((__aligned__(16)));\n+unsigned int result[N];\n+\n+/* short->int widening-mult */\n+int\n+foo1(int len) {\n+  int i;\n+\n+  /* Not vectorized because X[i] and Y[i] are casted to 'int'\n+     so the widening multiplication pattern is not recognized.  */\n+  for (i=0; i<len; i++) {\n+    result[i] = (unsigned int)(X[i] * Y[i]);\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "214014196fba4b60ce0b1ad6961830cf3f6fb048", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char X[N] __attribute__ ((__aligned__(16)));\n+unsigned char Y[N] __attribute__ ((__aligned__(16)));\n+unsigned short result[N];\n+\n+/* char->short widening-mult */\n+int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    result[i] = X[i] * Y[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "b11b9c70086a418e38d8be2a55b625361a299058", "filename": "gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-dot-s8.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6300f037d02324e91b3987acbbb16f727dd3c9b8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6300f037d02324e91b3987acbbb16f727dd3c9b8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8.c?ref=6300f037d02324e91b3987acbbb16f727dd3c9b8", "patch": "@@ -1,108 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"tree-vect.h\"\n-\n-#define N 64\n-\n-#define DOT1 43680\n-#define DOT2 -21856\n-#define DOT3 43680\n-\n-signed char X[N] __attribute__ ((__aligned__(16)));\n-signed char Y[N] __attribute__ ((__aligned__(16)));\n-\n-/* char->short->int dot product.\n-   The dot-product pattern should be detected.\n-   Vectorizable on vect_sdot_qi targets (targets that support dot-product of \n-   signed chars).\n-\n-   In the future could also be vectorized as widening-mult + widening-summation,\n-   or with type-conversion support.\n- */\n-int\n-foo1(int len) {\n-  int i;\n-  int result = 0;\n-  short prod;\n-\n-  for (i=0; i<len; i++) {\n-    prod = X[i] * Y[i];\n-    result += prod;\n-  }\n-  return result;\n-}\n-\n-/* char->short->short dot product.\n-   The dot-product pattern should be detected.\n-   Should be vectorized on vect_sdot_qi targets (targets that support \n-   dot-product of signed char).  \n-   This test currently fails to vectorize on targets that support\n-   dot-product of chars when the accumulator is int.\n-\n-   In the future could also be vectorized as widening-mult + summation,\n-   or with type-conversion support.\n- */\n-short\n-foo2(int len) {\n-  int i;\n-  short result = 0;\n-\n-  for (i=0; i<len; i++) {\n-    result += (X[i] * Y[i]);\n-  }\n-  return result;\n-}\n-\n-/* char->int->int dot product. \n-   Not detected as a dot-product pattern.\n-   Currently fails to be vectorized due to presence of type conversions. */\n-int\n-foo3(int len) {\n-  int i;\n-  int result = 0;\n-\n-  for (i=0; i<len; i++) {\n-    result += (X[i] * Y[i]);\n-  }\n-  return result;\n-}\n-\n-int main (void)\n-{\n-  int i, dot1, dot3;\n-  short dot2;\n-\n-  check_vect ();\n-\n-  for (i=0; i<N; i++) {\n-    X[i] = i;\n-    Y[i] = 64-i;\n-  }\n-\n-  dot1 = foo1 (N);\n-  if (dot1 != DOT1)\n-    abort ();\n-\n-  dot2 = foo2 (N);\n-  if (dot2 != DOT2)\n-    abort ();\n-\n-  dot3 = foo3 (N);\n-  if (dot3 != DOT3)\n-    abort ();\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 2 \"vect\" } } */\n-\n-/* When vectorizer is enhanced to vectorize foo2 (accumulation into short) for targets \n-   that support accumulation into int (ia64) we'd have:\n-dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_sdot_qi } }\n-*/\n-/* In the meantime expect: */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_qi } } } */\n-\n-/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "724bb58b76751cdb97ba02a478543d79df555890", "filename": "gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-dot-s8b.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8b.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT -21856\n+\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+signed char Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* char->short->short dot product.\n+   The dot-product pattern should be detected.\n+   Should be vectorized on vect_sdot_qi targets (targets that support \n+   dot-product of signed char).  \n+   This test currently fails to vectorize on targets that support\n+   dot-product of chars into and int accumulator.\n+   Can also be vectorized as widening-mult + summation,\n+   or with type-conversion support.\n+ */\n+short\n+foo(int len) {\n+  int i;\n+  short result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  short dot;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot = foo (N);\n+  if (dot != DOT)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" } } */\n+\n+/* When vectorizer is enhanced to vectorize accumulation into short for targets \n+   that support accumulation into int (e.g. ia64) we'd have:\n+dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_qi } }\n+*/\n+/* In the meantime expect: */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "8e263a352d7d69951a3acb4a06f13d493dd8772a", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 108, "deletions": 28, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -1491,18 +1491,19 @@ proc check_effective_target_vect_no_bitwise { } {\n \n # Return 1 if the target plus current options supports a vector\n # widening summation of *short* args into *int* result, 0 otherwise.\n+# A target can also support this widening summation if it can support\n+# promotion (unpacking) from shorts to ints.\n #\n # This won't change for different subtargets so cache the result.\n                                                                                                 \n proc check_effective_target_vect_widen_sum_hi_to_si { } {\n     global et_vect_widen_sum_hi_to_si\n-                                                                                                \n+\n     if [info exists et_vect_widen_sum_hi_to_si_saved] {\n         verbose \"check_effective_target_vect_widen_sum_hi_to_si: using cached result\" 2\n     } else {\n-        set et_vect_widen_sum_hi_to_si_saved 0\n-        if { [istarget powerpc*-*-*]\n-\t     || [istarget ia64-*-*] } {\n+        set et_vect_widen_sum_hi_to_si_saved [check_effective_target_vect_unpack]\n+        if { [istarget powerpc*-*-*] } {\n             set et_vect_widen_sum_hi_to_si_saved 1\n         }\n     }\n@@ -1512,19 +1513,21 @@ proc check_effective_target_vect_widen_sum_hi_to_si { } {\n \n # Return 1 if the target plus current options supports a vector\n # widening summation of *char* args into *short* result, 0 otherwise.\n+# A target can also support this widening summation if it can support\n+# promotion (unpacking) from chars to shorts.\n #\n # This won't change for different subtargets so cache the result.\n                                                                                                 \n proc check_effective_target_vect_widen_sum_qi_to_hi { } {\n     global et_vect_widen_sum_qi_to_hi\n-                                                                                                \n+\n     if [info exists et_vect_widen_sum_qi_to_hi_saved] {\n         verbose \"check_effective_target_vect_widen_sum_qi_to_hi: using cached result\" 2\n     } else {\n         set et_vect_widen_sum_qi_to_hi_saved 0\n-        if { [istarget ia64-*-*] } {\n+\tif { [check_effective_target_vect_unpack] } {\n             set et_vect_widen_sum_qi_to_hi_saved 1\n-        }\n+\t}\n     }\n     verbose \"check_effective_target_vect_widen_sum_qi_to_hi: returning $et_vect_widen_sum_qi_to_hi_saved\" 2\n     return $et_vect_widen_sum_qi_to_hi_saved\n@@ -1537,7 +1540,7 @@ proc check_effective_target_vect_widen_sum_qi_to_hi { } {\n                                                                                                 \n proc check_effective_target_vect_widen_sum_qi_to_si { } {\n     global et_vect_widen_sum_qi_to_si\n-                                                                                                \n+\n     if [info exists et_vect_widen_sum_qi_to_si_saved] {\n         verbose \"check_effective_target_vect_widen_sum_qi_to_si: using cached result\" 2\n     } else {\n@@ -1551,24 +1554,61 @@ proc check_effective_target_vect_widen_sum_qi_to_si { } {\n }\n \n # Return 1 if the target plus current options supports a vector\n-# widening summation, 0 otherwise.\n+# widening multiplication of *char* args into *short* result, 0 otherwise.\n+# A target can also support this widening multplication if it can support\n+# promotion (unpacking) from chars to shorts, and vect_short_mult (non-widening\n+# multiplication of shorts).\n #\n # This won't change for different subtargets so cache the result.\n-                                                                                                \n-proc check_effective_target_vect_widen_sum { } {\n-    global et_vect_widen_sum\n-                                                                                                \n-    if [info exists et_vect_widen_sum_saved] {\n-        verbose \"check_effective_target_vect_widen_sum: using cached result\" 2\n+\n+\n+proc check_effective_target_vect_widen_mult_qi_to_hi { } {\n+    global et_vect_widen_mult_qi_to_hi\n+\n+    if [info exists et_vect_widen_mult_qi_to_hi_saved] {\n+        verbose \"check_effective_target_vect_widen_mult_qi_to_hi: using cached result\" 2\n     } else {\n-        set et_vect_widen_sum_saved 0\n-        if { [istarget powerpc*-*-*]\n-\t     || [istarget ia64-*-*] } {\n-            set et_vect_widen_sum_saved 1\n+\tif { [check_effective_target_vect_unpack]\n+\t     && [check_effective_target_vect_short_mult] } {\n+\t    set et_vect_widen_mult_qi_to_hi_saved 1\n+\t} else {\n+\t    set et_vect_widen_mult_qi_to_hi_saved 0\n+\t}\n+        if { [istarget powerpc*-*-*] } {\n+            set et_vect_widen_mult_qi_to_hi_saved 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_sum: returning $et_vect_widen_sum_saved\" 2\n-    return $et_vect_widen_sum_saved\n+    verbose \"check_effective_target_vect_widen_mult_qi_to_hi: returning $et_vect_widen_mult_qi_to_hi_saved\" 2\n+    return $et_vect_widen_mult_qi_to_hi_saved\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# widening multiplication of *short* args into *int* result, 0 otherwise.\n+# A target can also support this widening multplication if it can support\n+# promotion (unpacking) from shorts to ints, and vect_int_mult (non-widening\n+# multiplication of ints).\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+\n+proc check_effective_target_vect_widen_mult_hi_to_si { } {\n+    global et_vect_widen_mult_hi_to_si\n+\n+    if [info exists et_vect_widen_mult_hi_to_si_saved] {\n+        verbose \"check_effective_target_vect_widen_mult_hi_to_si: using cached result\" 2\n+    } else {\n+        if { [check_effective_target_vect_unpack]\n+             && [check_effective_target_vect_int_mult] } {\n+          set et_vect_widen_mult_hi_to_si_saved 1\n+        } else {\n+          set et_vect_widen_mult_hi_to_si_saved 0\n+        }\n+        if { [istarget powerpc*-*-*] } {\n+            set et_vect_widen_mult_hi_to_si_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_widen_mult_hi_to_si: returning $et_vect_widen_mult_hi_to_si_saved\" 2\n+    return $et_vect_widen_mult_hi_to_si_saved\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -1583,9 +1623,6 @@ proc check_effective_target_vect_sdot_qi { } {\n         verbose \"check_effective_target_vect_sdot_qi: using cached result\" 2\n     } else {\n         set et_vect_sdot_qi_saved 0\n-        if { [istarget ia64-*-*] } {\n-            set et_vect_sdot_qi_saved 1\n-        }\n     }\n     verbose \"check_effective_target_vect_sdot_qi: returning $et_vect_sdot_qi_saved\" 2\n     return $et_vect_sdot_qi_saved\n@@ -1603,8 +1640,7 @@ proc check_effective_target_vect_udot_qi { } {\n         verbose \"check_effective_target_vect_udot_qi: using cached result\" 2\n     } else {\n         set et_vect_udot_qi_saved 0\n-        if { [istarget powerpc*-*-*]\n-             || [istarget ia64-*-*] } {\n+        if { [istarget powerpc*-*-*] } {\n             set et_vect_udot_qi_saved 1\n         }\n     }\n@@ -1626,8 +1662,7 @@ proc check_effective_target_vect_sdot_hi { } {\n         set et_vect_sdot_hi_saved 0\n         if { [istarget powerpc*-*-*] \n \t     || [istarget i?86-*-*]\n-             || [istarget x86_64-*-*]\n-             || [istarget ia64-*-*] } {\n+             || [istarget x86_64-*-*] } {\n             set et_vect_sdot_hi_saved 1\n         }\n     }\n@@ -1656,6 +1691,51 @@ proc check_effective_target_vect_udot_hi { } {\n }\n \n \n+# Return 1 if the target plus current options supports a vector\n+# demotion (packing) of shorts (to chars) and ints (to shorts) \n+# using modulo arithmetic, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+                                                                                \n+proc check_effective_target_vect_pack_mod { } {\n+    global et_vect_pack_mod\n+                                                                                \n+    if [info exists et_vect_pack_mod_saved] {\n+        verbose \"check_effective_target_vect_pack_mod: using cached result\" 2\n+    } else {\n+        set et_vect_pack_mod_saved 0\n+        if { [istarget powerpc*-*-*]\n+             || [istarget i?86-*-*]\n+             || [istarget x86_64-*-*] } {\n+            set et_vect_pack_mod_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_pack_mod: returning $et_vect_pack_mod_saved\" 2\n+    return $et_vect_pack_mod_saved\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# promotion (unpacking) of chars (to shorts) and shorts (to ints), 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+                                   \n+proc check_effective_target_vect_unpack { } {\n+    global et_vect_unpack\n+                                        \n+    if [info exists et_vect_unpack_saved] {\n+        verbose \"check_effective_target_vect_unpack: using cached result\" 2\n+    } else {\n+        set et_vect_unpack_saved 0\n+        if { [istarget powerpc*-*-*]\n+             || [istarget i?86-*-*]\n+             || [istarget x86_64-*-*] } {\n+            set et_vect_unpack_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_unpack: returning $et_vect_unpack_saved\" 2  \n+    return $et_vect_unpack_saved\n+}\n+\n # Return 1 if the target plus current options does not support a vector\n # alignment mechanism, 0 otherwise.\n #"}, {"sha": "07fae35c909a2d0bfe08653c28bdf45b4604626d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -1765,6 +1765,12 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case REDUC_PLUS_EXPR:\n     case WIDEN_SUM_EXPR:\n     case DOT_PROD_EXPR: \n+    case VEC_WIDEN_MULT_HI_EXPR:\n+    case VEC_WIDEN_MULT_LO_EXPR:\n+    case VEC_UNPACK_HI_EXPR:\n+    case VEC_UNPACK_LO_EXPR:\n+    case VEC_PACK_MOD_EXPR:\n+    case VEC_PACK_SAT_EXPR:\n \n     case WIDEN_MULT_EXPR:\n "}, {"sha": "ddc84f374deb0f34143cdc94b950a712e01b299f", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -1702,9 +1702,9 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case DOT_PROD_EXPR:\n       pp_string (buffer, \" DOT_PROD_EXPR < \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_string (buffer, \" , \");\n+      pp_string (buffer, \", \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n-      pp_string (buffer, \" , \");\n+      pp_string (buffer, \", \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 2), spc, flags, false);\n       pp_string (buffer, \" > \");\n       break;\n@@ -1863,6 +1863,50 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case VEC_WIDEN_MULT_HI_EXPR:\n+      pp_string (buffer, \" VEC_WIDEN_MULT_HI_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_WIDEN_MULT_LO_EXPR:\n+      pp_string (buffer, \" VEC_WIDEN_MULT_LO_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_UNPACK_HI_EXPR:\n+      pp_string (buffer, \" VEC_UNPACK_HI_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_UNPACK_LO_EXPR:\n+      pp_string (buffer, \" VEC_UNPACK_LO_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_PACK_MOD_EXPR:\n+      pp_string (buffer, \" VEC_PACK_MOD_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+                                                                                \n+    case VEC_PACK_SAT_EXPR:\n+      pp_string (buffer, \" VEC_PACK_SAT_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+                                                                                \n     case BLOCK:\n       {\n \ttree t;\n@@ -2165,6 +2209,8 @@ op_prio (tree op)\n     case MINUS_EXPR:\n       return 12;\n \n+    case VEC_WIDEN_MULT_HI_EXPR:\n+    case VEC_WIDEN_MULT_LO_EXPR:\n     case WIDEN_MULT_EXPR:\n     case DOT_PROD_EXPR:\n     case MULT_EXPR:\n@@ -2218,6 +2264,10 @@ op_prio (tree op)\n     case REDUC_PLUS_EXPR:\n     case VEC_LSHIFT_EXPR:\n     case VEC_RSHIFT_EXPR:\n+    case VEC_UNPACK_HI_EXPR:\n+    case VEC_UNPACK_LO_EXPR:\n+    case VEC_PACK_MOD_EXPR:\n+    case VEC_PACK_SAT_EXPR:\n       return 16;\n \n     case SAVE_EXPR:"}, {"sha": "8151c74d92d2d99d7aba2774351b1c8982c3ab92", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -54,8 +54,6 @@ static bool vect_determine_vectorization_factor (loop_vec_info);\n \n /* Utility functions for the analyses.  */\n static bool exist_non_indexing_operands_for_use_p (tree, tree);\n-static void vect_mark_relevant (VEC(tree,heap) **, tree, bool, bool);\n-static bool vect_stmt_relevant_p (tree, loop_vec_info, bool *, bool *);\n static tree vect_get_loop_niters (struct loop *, tree *);\n static bool vect_analyze_data_ref_dependence\n   (struct data_dependence_relation *, loop_vec_info);\n@@ -187,22 +185,9 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"nunits = %d\", nunits);\n \n-          if (vectorization_factor)\n-            {\n-              /* FORNOW: don't allow mixed units. \n-                 This restriction will be relaxed in the future.  */\n-              if (nunits != vectorization_factor) \n-                {\n-                  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                    fprintf (vect_dump, \"not vectorized: mixed data-types\");\n-                  return false;\n-                }\n-            }\n-          else\n+\t  if (!vectorization_factor\n+              || (nunits > vectorization_factor))\n             vectorization_factor = nunits;\n-\n-          gcc_assert (GET_MODE_SIZE (TYPE_MODE (scalar_type))\n-                        * vectorization_factor == UNITS_PER_SIMD_WORD);\n         }\n     }\n \n@@ -310,7 +295,9 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n               gcc_assert (!VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))));\n               gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n \n-\t      ok = (vectorizable_operation (stmt, NULL, NULL)\n+\t      ok = (vectorizable_type_promotion (stmt, NULL, NULL)\n+\t\t    || vectorizable_type_demotion (stmt, NULL, NULL)\n+\t\t    || vectorizable_operation (stmt, NULL, NULL)\n \t\t    || vectorizable_assignment (stmt, NULL, NULL)\n \t\t    || vectorizable_load (stmt, NULL, NULL)\n \t\t    || vectorizable_store (stmt, NULL, NULL)\n@@ -588,6 +575,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   struct data_reference *drb = DDR_B (ddr);\n   stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra)); \n   stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+  int dra_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dra))));\n+  int drb_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (drb))));\n   lambda_vector dist_v;\n   unsigned int loop_depth;\n          \n@@ -628,7 +617,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \tfprintf (vect_dump, \"dependence distance  = %d.\", dist);\n \n       /* Same loop iteration.  */\n-      if (dist % vectorization_factor == 0)\n+      if (dist % vectorization_factor == 0 && dra_size == drb_size)\n \t{\n \t  /* Two references with distance zero have the same alignment.  */\n \t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n@@ -837,12 +826,15 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n                                    struct data_reference *dr_peel, int npeel)\n {\n   unsigned int i;\n-  int drsize;\n   VEC(dr_p,heap) *same_align_drs;\n   struct data_reference *current_dr;\n+  int dr_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n+  int dr_peel_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr_peel))));\n \n   if (known_alignment_for_access_p (dr)\n-      && DR_MISALIGNMENT (dr) == DR_MISALIGNMENT (dr_peel))\n+      && known_alignment_for_access_p (dr_peel)\n+      && (DR_MISALIGNMENT (dr)/dr_size == \n+\t  DR_MISALIGNMENT (dr_peel)/dr_peel_size))\n     {\n       DR_MISALIGNMENT (dr) = 0;\n       return;\n@@ -856,20 +848,22 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n     {\n       if (current_dr != dr)\n         continue;\n-      gcc_assert (DR_MISALIGNMENT (dr) == DR_MISALIGNMENT (dr_peel));\n+      gcc_assert (DR_MISALIGNMENT (dr)/dr_size == \n+\t\t  DR_MISALIGNMENT (dr_peel)/dr_peel_size);\n       DR_MISALIGNMENT (dr) = 0;\n       return;\n     }\n \n   if (known_alignment_for_access_p (dr)\n       && known_alignment_for_access_p (dr_peel))\n     {  \n-      drsize = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n-      DR_MISALIGNMENT (dr) += npeel * drsize;\n+      DR_MISALIGNMENT (dr) += npeel * dr_size;\n       DR_MISALIGNMENT (dr) %= UNITS_PER_SIMD_WORD;\n       return;\n     }\n \n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"Setting misalignment to -1.\");\n   DR_MISALIGNMENT (dr) = -1;\n }\n \n@@ -1014,6 +1008,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   bool do_versioning = false;\n   bool stat;\n \n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"=== vect_enhance_data_refs_alignment ===\");\n+\n   /* While cost model enhancements are expected in the future, the high level\n      view of the code at this time is as follows:\n \n@@ -1080,6 +1077,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           mis = DR_MISALIGNMENT (dr0);\n           mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n           npeel = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - mis;\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"Try peeling by %d\",npeel);\n         }\n \n       /* Ensure that all data refs can be vectorized after the peel.  */\n@@ -1423,14 +1422,14 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \n static void\n vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n-\t\t    bool relevant_p, bool live_p)\n+\t\t    enum vect_relevant relevant, bool live_p)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  bool save_relevant_p = STMT_VINFO_RELEVANT_P (stmt_info);\n+  enum vect_relevant save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n   bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"mark relevant %d, live %d.\",relevant_p, live_p);\n+    fprintf (vect_dump, \"mark relevant %d, live %d.\", relevant, live_p);\n \n   if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n     {\n@@ -1445,20 +1444,21 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n       pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n       stmt_info = vinfo_for_stmt (pattern_stmt);\n       gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == stmt);\n-      save_relevant_p = STMT_VINFO_RELEVANT_P (stmt_info);\n+      save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n       save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n       stmt = pattern_stmt;\n     }\n \n   STMT_VINFO_LIVE_P (stmt_info) |= live_p;\n-  STMT_VINFO_RELEVANT_P (stmt_info) |= relevant_p;\n+  if (relevant > STMT_VINFO_RELEVANT (stmt_info))\n+    STMT_VINFO_RELEVANT (stmt_info) = relevant;\n \n   if (TREE_CODE (stmt) == PHI_NODE)\n     /* Don't put phi-nodes in the worklist. Phis that are marked relevant\n        or live will fail vectorization later on.  */\n     return;\n \n-  if (STMT_VINFO_RELEVANT_P (stmt_info) == save_relevant_p\n+  if (STMT_VINFO_RELEVANT (stmt_info) == save_relevant\n       && STMT_VINFO_LIVE_P (stmt_info) == save_live_p)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1484,28 +1484,28 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n \n static bool\n vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n-\t\t      bool *relevant_p, bool *live_p)\n+\t\t      enum vect_relevant *relevant, bool *live_p)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   ssa_op_iter op_iter;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n   def_operand_p def_p;\n \n-  *relevant_p = false;\n+  *relevant = vect_unused_in_loop;\n   *live_p = false;\n \n   /* cond stmt other than loop exit cond.  */\n   if (is_ctrl_stmt (stmt) && (stmt != LOOP_VINFO_EXIT_COND (loop_vinfo)))\n-    *relevant_p = true;\n+    *relevant = vect_used_in_loop;\n \n   /* changing memory.  */\n   if (TREE_CODE (stmt) != PHI_NODE)\n     if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n       {\n \tif (vect_print_dump_info (REPORT_DETAILS))\n \t  fprintf (vect_dump, \"vec_stmt_relevant_p: stmt has vdefs.\");\n-\t*relevant_p = true;\n+\t*relevant = vect_used_in_loop;\n       }\n \n   /* uses outside the loop.  */\n@@ -1529,7 +1529,7 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n \t}\n     }\n \n-  return (*live_p || *relevant_p);\n+  return (*live_p || *relevant);\n }\n \n \n@@ -1564,7 +1564,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   stmt_vec_info stmt_vinfo;\n   basic_block bb;\n   tree phi;\n-  bool relevant_p, live_p;\n+  bool live_p;\n+  enum vect_relevant relevant;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n \n@@ -1584,8 +1585,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n           print_generic_expr (vect_dump, phi, TDF_SLIM);\n         }\n \n-      if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant_p, &live_p))\n-\tvect_mark_relevant (&worklist, phi, relevant_p, live_p);\n+      if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant, &live_p))\n+\tvect_mark_relevant (&worklist, phi, relevant, live_p);\n     }\n \n   for (i = 0; i < nbbs; i++)\n@@ -1601,8 +1602,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t    } \n \n-\t  if (vect_stmt_relevant_p (stmt, loop_vinfo, &relevant_p, &live_p))\n-            vect_mark_relevant (&worklist, stmt, relevant_p, live_p);\n+\t  if (vect_stmt_relevant_p (stmt, loop_vinfo, &relevant, &live_p))\n+            vect_mark_relevant (&worklist, stmt, relevant, live_p);\n \t}\n     }\n \n@@ -1619,7 +1620,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n           print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t}\n \n-      /* Examine the USEs of STMT. For each ssa-name USE thta is defined\n+      /* Examine the USEs of STMT. For each ssa-name USE that is defined\n          in the loop, mark the stmt that defines it (DEF_STMT) as\n          relevant/irrelevant and live/dead according to the liveness and\n          relevance properties of STMT.\n@@ -1630,13 +1631,13 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       ann = stmt_ann (stmt);\n       stmt_vinfo = vinfo_for_stmt (stmt);\n \n-      relevant_p = STMT_VINFO_RELEVANT_P (stmt_vinfo);\n+      relevant = STMT_VINFO_RELEVANT (stmt_vinfo);\n       live_p = STMT_VINFO_LIVE_P (stmt_vinfo);\n \n       /* Generally, the liveness and relevance properties of STMT are\n          propagated to the DEF_STMTs of its USEs:\n              STMT_VINFO_LIVE_P (DEF_STMT_info) <-- live_p\n-             STMT_VINFO_RELEVANT_P (DEF_STMT_info) <-- relevant_p\n+             STMT_VINFO_RELEVANT (DEF_STMT_info) <-- relevant\n \n          Exceptions:\n \n@@ -1659,18 +1660,22 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n              the def_stmt of these uses we want to set liveness/relevance\n              as follows:\n                STMT_VINFO_LIVE_P (DEF_STMT_info) <-- false\n-               STMT_VINFO_RELEVANT_P (DEF_STMT_info) <-- true\n+               STMT_VINFO_RELEVANT (DEF_STMT_info) <-- vect_used_by_reduction\n              because even though STMT is classified as live (since it defines a\n              value that is used across loop iterations) and irrelevant (since it\n              is not used inside the loop), it will be vectorized, and therefore\n              the corresponding DEF_STMTs need to marked as relevant.\n+\t     We distinguish between two kinds of relevant stmts - those that are\n+\t     used by a reduction conputation, and those that are (also) used by \t     a regular computation. This allows us later on to identify stmts \n+\t     that are used solely by a reduction, and therefore the order of \n+\t     the results that they produce does not have to be kept.\n        */\n \n       /* case 2.2:  */\n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n         {\n-          gcc_assert (!relevant_p && live_p);\n-          relevant_p = true;\n+          gcc_assert (relevant == vect_unused_in_loop && live_p);\n+          relevant = vect_used_by_reduction;\n           live_p = false;\n         }\n \n@@ -1710,7 +1715,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      && TREE_CODE (def_stmt) == PHI_NODE)\n \t    continue;\n \n-\t  vect_mark_relevant (&worklist, def_stmt, relevant_p, live_p);\n+\t  vect_mark_relevant (&worklist, def_stmt, relevant, live_p);\n \t}\n     }\t\t\t\t/* while worklist */\n \n@@ -1738,7 +1743,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n   /* Analyze phi functions of the loop header.  */\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_can_advance_ivs_p ===\");\n+    fprintf (vect_dump, \"vect_can_advance_ivs_p:\");\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {"}, {"sha": "d1ac94f898f8a058731021de66cb20fe3d4f46a9", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -411,9 +411,15 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n   gcc_assert (code != CONVERT_EXPR);\n   op = optab_for_tree_code (code, type);\n \n-  /* For widening vector operations, the relevant type is of the arguments,\n-     not the widened result.  */\n-  if (code == WIDEN_SUM_EXPR)\n+  /* For widening/narrowgin vector operations, the relevant type is of the \n+     arguments, not the widened result.  */\n+  if (code == WIDEN_SUM_EXPR\n+      || code == VEC_WIDEN_MULT_HI_EXPR\n+      || code == VEC_WIDEN_MULT_LO_EXPR\n+      || code == VEC_UNPACK_HI_EXPR\n+      || code == VEC_UNPACK_LO_EXPR\n+      || code == VEC_PACK_MOD_EXPR\n+      || code == VEC_PACK_SAT_EXPR)\n     type = TREE_TYPE (TREE_OPERAND (rhs, 0));\n \n   /* Optabs will try converting a negation into a subtraction, so"}, {"sha": "67ab90f1eec1c67bf04e6c9408f1086cade0cf3d", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -334,12 +334,69 @@ vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n */\n \n static tree\n-vect_recog_widen_mult_pattern (tree last_stmt ATTRIBUTE_UNUSED, \n-\t\t\t       tree *type_in ATTRIBUTE_UNUSED, \n-\t\t\t       tree *type_out ATTRIBUTE_UNUSED)\n+vect_recog_widen_mult_pattern (tree last_stmt, \n+\t\t\t       tree *type_in, \n+\t\t\t       tree *type_out)\n {\n-  /* Yet to be implemented.   */\n-  return NULL;\n+  tree expr;\n+  tree def_stmt0, def_stmt1;\n+  tree oprnd0, oprnd1;\n+  tree type, half_type0, half_type1;\n+  tree pattern_expr;\n+  tree vectype;\n+  tree dummy;\n+  enum tree_code dummy_code;\n+\n+  if (TREE_CODE (last_stmt) != MODIFY_EXPR)\n+    return NULL;\n+\n+  expr = TREE_OPERAND (last_stmt, 1);\n+  type = TREE_TYPE (expr);\n+\n+  /* Starting from LAST_STMT, follow the defs of its uses in search\n+     of the above pattern.  */\n+\n+  if (TREE_CODE (expr) != MULT_EXPR)\n+    return NULL;\n+\n+  oprnd0 = TREE_OPERAND (expr, 0);\n+  oprnd1 = TREE_OPERAND (expr, 1);\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (oprnd0)) != TYPE_MAIN_VARIANT (type)\n+      || TYPE_MAIN_VARIANT (TREE_TYPE (oprnd1)) != TYPE_MAIN_VARIANT (type))\n+    return NULL;\n+\n+  /* Check argument 0 */\n+  if (!widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0))\n+    return NULL;\n+  oprnd0 = TREE_OPERAND (TREE_OPERAND (def_stmt0, 1), 0);\n+\n+  /* Check argument 1 */\n+  if (!widened_name_p (oprnd1, last_stmt, &half_type1, &def_stmt1))\n+    return NULL;\n+  oprnd1 = TREE_OPERAND (TREE_OPERAND (def_stmt1, 1), 0);\n+\n+  if (TYPE_MAIN_VARIANT (half_type0) != TYPE_MAIN_VARIANT (half_type1))\n+    return NULL;\n+\n+  /* Pattern detected.  */\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_recog_widen_mult_pattern: detected: \");\n+\n+  /* Check target support  */\n+  vectype = get_vectype_for_scalar_type (half_type0);\n+  if (!supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt, vectype,\n+                                       &dummy, &dummy, &dummy_code,\n+                                       &dummy_code))\n+    return NULL;\n+\n+  *type_in = vectype;\n+  *type_out = NULL_TREE;\n+\n+  /* Pattern supported. Create a stmt to be used to replace the pattern: */\n+  pattern_expr = build2 (WIDEN_MULT_EXPR, type, oprnd0, oprnd1);\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    print_generic_expr (vect_dump, pattern_expr, TDF_SLIM);\n+  return pattern_expr;\n }\n \n "}, {"sha": "19097fd8c3e4339b6bc9349ff53a3837fdfaf019", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1070, "deletions": 248, "changes": 1318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -47,11 +47,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* Utility functions for the code transformation.  */\n static bool vect_transform_stmt (tree, block_stmt_iterator *);\n-static void vect_align_data_ref (tree);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n-  (tree, block_stmt_iterator *, tree, tree *, bool); \n+  (tree, block_stmt_iterator *, tree, tree *, tree *, bool); \n static tree vect_create_addr_base_for_vector_ref (tree, tree *, tree);\n+static tree vect_setup_realignment (tree, block_stmt_iterator *, tree *);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n static tree vect_get_vec_def_for_operand (tree, tree, tree *);\n static tree vect_init_vector (tree, tree);\n@@ -191,30 +191,14 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n }\n \n \n-/* Function vect_align_data_ref.\n-\n-   Handle misalignment of a memory accesses.\n-\n-   FORNOW: Can't handle misaligned accesses. \n-   Make sure that the dataref is aligned.  */\n-\n-static void\n-vect_align_data_ref (tree stmt)\n-{\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-\n-  /* FORNOW: can't handle misaligned accesses; \n-             all accesses expected to be aligned.  */\n-  gcc_assert (aligned_access_p (dr));\n-}\n-\n-\n /* Function vect_create_data_ref_ptr.\n \n-   Create a memory reference expression for vector access, to be used in a\n-   vector load/store stmt. The reference is based on a new pointer to vector\n-   type (vp).\n+   Create a new pointer to vector type (vp), that points to the first location\n+   accessed in the loop by STMT, along with the def-use update chain to \n+   appropriately advance the pointer through the loop iterations. Also set\n+   aliasing information for the pointer.  This vector pointer is used by the\n+   callers to this function to create a memory reference expression for vector \n+   load/store access.\n \n    Input:\n    1. STMT: a stmt that references memory. Expected to be of the form\n@@ -240,17 +224,18 @@ vect_align_data_ref (tree stmt)\n \n       Return the initial_address in INITIAL_ADDRESS.\n \n-   2. If ONLY_INIT is true, return the initial pointer.  Otherwise, create\n-      a data-reference in the loop based on the new vector pointer vp.  This\n-      new data reference will by some means be updated each iteration of\n-      the loop.  Return the pointer vp'.\n+   2. If ONLY_INIT is true, just return the initial pointer.  Otherwise, also\n+      update the pointer in each iteration of the loop.  \n \n-   FORNOW: handle only aligned and consecutive accesses.  */\n+      Return the increment stmt that updates the pointer in PTR_INCR.\n+\n+   3. Return the pointer.  */\n \n static tree\n vect_create_data_ref_ptr (tree stmt,\n \t\t\t  block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n-\t\t\t  tree offset, tree *initial_address, bool only_init)\n+\t\t\t  tree offset, tree *initial_address, tree *ptr_incr,\n+\t\t\t  bool only_init)\n {\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -362,12 +347,85 @@ vect_create_data_ref_ptr (tree stmt,\n \t}\n       merge_alias_info (vect_ptr_init, indx_before_incr);\n       merge_alias_info (vect_ptr_init, indx_after_incr);\n+      if (ptr_incr)\n+\t*ptr_incr = incr;\n \n       return indx_before_incr;\n     }\n }\n \n \n+/* Function bump_vector_ptr\n+\n+   Increment a pointer (to a vector type) by vector-size. Connect the new \n+   increment stmt to the exising def-use update-chain of the pointer.\n+\n+   The pointer def-use update-chain before this function:\n+                        DATAREF_PTR = phi (p_0, p_2)\n+                        ....\n+        PTR_INCR:       p_2 = DATAREF_PTR + step \n+\n+   The pointer def-use update-chain after this function:\n+                        DATAREF_PTR = phi (p_0, p_2)\n+                        ....\n+                        NEW_DATAREF_PTR = DATAREF_PTR + vector_size\n+                        ....\n+        PTR_INCR:       p_2 = NEW_DATAREF_PTR + step\n+\n+   Input:\n+   DATAREF_PTR - ssa_name of a pointer (to vector type) that is being updated \n+                 in the loop.\n+   PTR_INCR - the stmt that updates the pointer in each iteration of the loop.\n+              The increment amount across iterations is also expected to be\n+              vector_size.      \n+   BSI - location where the new update stmt is to be placed.\n+   STMT - the original scalar memory-access stmt that is being vectorized.\n+\n+   Output: Return NEW_DATAREF_PTR as illustrated above.\n+   \n+*/\n+\n+static tree\n+bump_vector_ptr (tree dataref_ptr, tree ptr_incr, block_stmt_iterator *bsi,\n+                 tree stmt)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vptr_type = TREE_TYPE (dataref_ptr);\n+  tree ptr_var = SSA_NAME_VAR (dataref_ptr);\n+  tree update = fold_convert (vptr_type, TYPE_SIZE_UNIT (vectype));\n+  tree incr_stmt;\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+  tree new_dataref_ptr;\n+\n+  incr_stmt = build2 (MODIFY_EXPR, void_type_node, ptr_var,\n+                build2 (PLUS_EXPR, vptr_type, dataref_ptr, update));\n+  new_dataref_ptr = make_ssa_name (ptr_var, incr_stmt);\n+  TREE_OPERAND (incr_stmt, 0) = new_dataref_ptr;\n+  vect_finish_stmt_generation (stmt, incr_stmt, bsi);\n+\n+  /* Update the vector-pointer's cross-iteration increment.  */\n+  FOR_EACH_SSA_USE_OPERAND (use_p, ptr_incr, iter, SSA_OP_USE)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+\n+      if (use == dataref_ptr)\n+        SET_USE (use_p, new_dataref_ptr);\n+      else\n+        gcc_assert (tree_int_cst_compare (use, update) == 0);\n+    }\n+\n+  /* Copy the points-to information if it exists. */\n+  if (DR_PTR_INFO (dr))\n+    duplicate_ssa_name_ptr_info (new_dataref_ptr, DR_PTR_INFO (dr));\n+  merge_alias_info (new_dataref_ptr, dataref_ptr);\n+\n+  return new_dataref_ptr;\n+}\n+\n+\n /* Function vect_create_destination_var.\n \n    Create a new temporary of type VECTYPE.  */\n@@ -568,14 +626,99 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n }\n \n \n+/* Function vect_get_vec_def_for_stmt_copy\n+\n+   Return a vector-def for an operand. This function is used when the \n+   vectorized stmt to be created (by the caller to this function) is a \"copy\" \n+   created in case the vectorized result cannot fit in one vector, and several \n+   copies of the vector-stmt are required. In this case the vector-def is \n+   retrieved from the vector stmt recorded in the STMT_VINFO_RELATED_STMT field \n+   of the stmt that defines VEC_OPRND. \n+   DT is the type of the vector def VEC_OPRND.\n+\n+   Context:\n+        In case the vectorization factor (VF) is bigger than the number\n+   of elements that can fit in a vectype (nunits), we have to generate\n+   more than one vector stmt to vectorize the scalar stmt. This situation\n+   arises when there are multiple data-types operated upon in the loop; the \n+   smallest data-type determines the VF, and as a result, when vectorizing\n+   stmts operating on wider types we need to create 'VF/nunits' \"copies\" of the\n+   vector stmt (each computing a vector of 'nunits' results, and together\n+   computing 'VF' results in each iteration).  This function is called when \n+   vectorizing such a stmt (e.g. vectorizing S2 in the illusration below, in \n+   which VF=16 and nuniti=4, so the number of copies required is 4):\n+\n+   scalar stmt:         vectorized into:        STMT_VINFO_RELATED_STMT\n+ \n+   S1: x = load         VS1.0:  vx.0 = memref0      VS1.1\n+                        VS1.1:  vx.1 = memref1      VS1.2\n+                        VS1.2:  vx.2 = memref2      VS1.3\n+                        VS1.3:  vx.3 = memref3 \n+\n+   S2: z = x + ...      VSnew.0:  vz0 = vx.0 + ...  VSnew.1\n+                        VSnew.1:  vz1 = vx.1 + ...  VSnew.2\n+                        VSnew.2:  vz2 = vx.2 + ...  VSnew.3\n+                        VSnew.3:  vz3 = vx.3 + ...\n+\n+   The vectorization of S1 is explained in vectorizable_load.\n+   The vectorization of S2:\n+        To create the first vector-stmt out of the 4 copies - VSnew.0 - \n+   the function 'vect_get_vec_def_for_operand' is called to \n+   get the relevant vector-def for each operand of S2. For operand x it\n+   returns  the vector-def 'vx.0'.\n+\n+        To create the remaining copies of the vector-stmt (VSnew.j), this \n+   function is called to get the relevant vector-def for each operand.  It is \n+   obtained from the respective VS1.j stmt, which is recorded in the \n+   STMT_VINFO_RELATED_STMT field of the stmt that defines VEC_OPRND.\n+\n+        For example, to obtain the vector-def 'vx.1' in order to create the \n+   vector stmt 'VSnew.1', this function is called with VEC_OPRND='vx.0'. \n+   Given 'vx0' we obtain the stmt that defines it ('VS1.0'); from the \n+   STMT_VINFO_RELATED_STMT field of 'VS1.0' we obtain the next copy - 'VS1.1',\n+   and return its def ('vx.1').\n+   Overall, to create the above sequence this function will be called 3 times:\n+        vx.1 = vect_get_vec_def_for_stmt_copy (dt, vx.0);\n+        vx.2 = vect_get_vec_def_for_stmt_copy (dt, vx.1);\n+        vx.3 = vect_get_vec_def_for_stmt_copy (dt, vx.2);  */\n+\n+static tree\n+vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n+{\n+  tree vec_stmt_for_operand;\n+  stmt_vec_info def_stmt_info;\n+\n+  if (dt == vect_invariant_def || dt == vect_constant_def)\n+    {\n+      /* Do nothing; can reuse same def.  */ ;\n+      return vec_oprnd;\n+    }\n+\n+  vec_stmt_for_operand = SSA_NAME_DEF_STMT (vec_oprnd);\n+  def_stmt_info = vinfo_for_stmt (vec_stmt_for_operand);\n+  gcc_assert (def_stmt_info);\n+  vec_stmt_for_operand = STMT_VINFO_RELATED_STMT (def_stmt_info);\n+  gcc_assert (vec_stmt_for_operand);\n+  vec_oprnd = TREE_OPERAND (vec_stmt_for_operand, 0);\n+\n+  return vec_oprnd;\n+}\n+\n+\n /* Function vect_finish_stmt_generation.\n \n    Insert a new stmt.  */\n \n static void\n-vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n+vect_finish_stmt_generation (tree stmt, tree vec_stmt, \n+\t\t\t     block_stmt_iterator *bsi)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+\n   bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n+  set_stmt_info (get_stmt_ann (vec_stmt), \n+\t\t new_stmt_vec_info (vec_stmt, loop_vinfo)); \n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -1135,7 +1278,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree vec_dest;\n   tree scalar_dest;\n   tree op;\n-  tree loop_vec_def0, loop_vec_def1;\n+  tree loop_vec_def0 = NULL_TREE, loop_vec_def1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -1145,7 +1288,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum machine_mode vec_mode;\n   int op_type;\n   optab optab, reduc_optab;\n-  tree new_temp;\n+  tree new_temp = NULL_TREE;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n   tree new_phi;\n@@ -1155,6 +1298,14 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   stmt_vec_info orig_stmt_info;\n   tree expr = NULL_TREE;\n   int i;\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  stmt_vec_info prev_stmt_info;\n+  tree reduc_def;\n+  tree new_stmt = NULL_TREE;\n+  int j;\n+\n+  gcc_assert (ncopies >= 1);\n \n   /* 1. Is vectorizable reduction?  */\n \n@@ -1194,7 +1345,6 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   operation = TREE_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n   op_type = TREE_CODE_LENGTH (code);\n-\n   if (op_type != binary_op && op_type != ternary_op)\n     return false;\n   scalar_dest = TREE_OPERAND (stmt, 0);\n@@ -1339,28 +1489,63 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   /* Create the reduction-phi that defines the reduction-operand.  */\n   new_phi = create_phi_node (vec_dest, loop->header);\n \n-  /* Prepare the operand that is defined inside the loop body  */\n-  op = TREE_OPERAND (operation, 0);\n-  loop_vec_def0 = vect_get_vec_def_for_operand (op, stmt, NULL);\n-  if (op_type == binary_op)\n-    expr = build2 (code, vectype, loop_vec_def0, PHI_RESULT (new_phi));\n-  else if (op_type == ternary_op)\n+  /* In case the vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits.  For more details see documentation\n+     in vectorizable_operation.  */\n+\n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n     {\n-      op = TREE_OPERAND (operation, 1);\n-      loop_vec_def1 = vect_get_vec_def_for_operand (op, stmt, NULL);\n-      expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1, \n-\t\t     PHI_RESULT (new_phi));\n+      /* Handle uses.  */\n+      if (j == 0)\n+        {\n+          op = TREE_OPERAND (operation, 0);\n+          loop_vec_def0 = vect_get_vec_def_for_operand (op, stmt, NULL);\n+          if (op_type == ternary_op)\n+            {\n+              op = TREE_OPERAND (operation, 1);\n+              loop_vec_def1 = vect_get_vec_def_for_operand (op, stmt, NULL);\n+            }\n+                                                                                \n+          /* Get the vector def for the reduction variable from the phi node */\n+          reduc_def = PHI_RESULT (new_phi);\n+        }\n+      else\n+        {\n+          enum vect_def_type dt = vect_unknown_def_type; /* Dummy */\n+          loop_vec_def0 = vect_get_vec_def_for_stmt_copy (dt, loop_vec_def0);\n+          if (op_type == ternary_op)\n+            loop_vec_def1 = vect_get_vec_def_for_stmt_copy (dt, loop_vec_def1);\n+                                                                                \n+          /* Get the vector def for the reduction variable from the vectorized\n+             reduction operation generated in the previous iteration (j-1)  */\n+          reduc_def = TREE_OPERAND (new_stmt ,0);\n+        }\n+                                                                                \n+      /* Arguments are ready. create the new vector stmt.  */\n+                                                                                \n+      if (op_type == binary_op)\n+        expr = build2 (code, vectype, loop_vec_def0, reduc_def);\n+      else\n+        expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1, \n+\t\t\t\t\t\t\t\treduc_def);\n+      new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, expr);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+                                                                                \n+      if (j == 0)\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      else\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n     }\n-\n-  /* Create the vectorized operation that computes the partial results  */\n-  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, expr);\n-  new_temp = make_ssa_name (vec_dest, *vec_stmt);\n-  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n-  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n-\n+                                                                                \n   /* Finalize the reduction-phi (set it's arguments) and create the\n      epilog reduction code.  */\n-  vect_create_epilog_for_reduction (new_temp, stmt, epilog_reduc_code, new_phi);\n+  vect_create_epilog_for_reduction (new_temp, stmt, epilog_reduc_code, new_phi);                                                                                \n   return true;\n }\n \n@@ -1385,6 +1570,12 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree new_temp;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+\n+  gcc_assert (ncopies >= 1);\n+  if (ncopies > 1)\n+    return false; /* FORNOW */\n \n   /* Is vectorizable assignment?  */\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -1475,21 +1666,28 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree scalar_dest;\n   tree operation;\n   tree op0, op1 = NULL;\n-  tree vec_oprnd0, vec_oprnd1=NULL;\n+  tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  int i;\n   enum tree_code code;\n   enum machine_mode vec_mode;\n   tree new_temp;\n   int op_type;\n-  tree op;\n   optab optab;\n   int icode;\n   enum machine_mode optab_op2_mode;\n   tree def, def_stmt;\n-  enum vect_def_type dt;\n+  enum vect_def_type dt0, dt1;\n+  tree new_stmt;\n+  stmt_vec_info prev_stmt_info;\n+  int nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n+  int nunits_out;\n+  tree vectype_out;\n+  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+  int j;\n+\n+  gcc_assert (ncopies >= 1);\n \n   /* Is STMT a vectorizable binary/unary operation?   */\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -1511,6 +1709,12 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n     return false;\n \n+  scalar_dest = TREE_OPERAND (stmt, 0);\n+  vectype_out = get_vectype_for_scalar_type (TREE_TYPE (scalar_dest));\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+  if (nunits_out != nunits_in)\n+    return false;\n+\n   operation = TREE_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n   optab = optab_for_tree_code (code, vectype);\n@@ -1524,16 +1728,24 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n-  for (i = 0; i < op_type; i++)\n+  op0 = TREE_OPERAND (operation, 0);\n+  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n     {\n-      op = TREE_OPERAND (operation, i);\n-      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n+                                                                                \n+  if (op_type == binary_op)\n+    {\n+      op1 = TREE_OPERAND (operation, 1);\n+      if (!vect_is_simple_use (op1, loop_vinfo, &def_stmt, &def, &dt1))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n \t  return false;\n-\t}\t\n-    } \n+\t}\n+    }\n \n   /* Supportable by target?  */\n   if (!optab)\n@@ -1576,8 +1788,8 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t by a scalar shift operand.  */\n       optab_op2_mode = insn_data[icode].operand[2].mode;\n       if (! (VECTOR_MODE_P (optab_op2_mode)\n-\t     || dt == vect_constant_def\n-\t     || dt == vect_invariant_def))\n+\t     || dt1 == vect_constant_def\n+\t     || dt1 == vect_invariant_def))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"operand mode requires invariant argument.\");\n@@ -1597,49 +1809,485 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     fprintf (vect_dump, \"transform binary/unary operation.\");\n \n   /* Handle def.  */\n-  scalar_dest = TREE_OPERAND (stmt, 0);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n-  /* Handle uses.  */\n+  /* In case the vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits. In doing so, we record a pointer\n+     from one copy of the vector stmt to the next, in the field\n+     STMT_VINFO_RELATED_STMT. This is necessary in order to allow following\n+     stages to find the correct vector defs to be used when vectorizing\n+     stmts that use the defs of the current stmt. The example below illustrates\n+     the vectorization process when VF=16 and nunits=4 (i.e - we need to create\n+     4 vectorized stmts):\n+                                                                                \n+     before vectorization:\n+                                RELATED_STMT    VEC_STMT\n+        S1:     x = memref      -               -\n+        S2:     z = x + 1       -               -\n+                                                                                \n+     step 1: vectorize stmt S1 (done in vectorizable_load. See more details\n+             there):\n+                                RELATED_STMT    VEC_STMT\n+        VS1_0:  vx0 = memref0   VS1_1           -\n+        VS1_1:  vx1 = memref1   VS1_2           -\n+        VS1_2:  vx2 = memref2   VS1_3           -\n+        VS1_3:  vx3 = memref3   -               -\n+        S1:     x = load        -               VS1_0\n+        S2:     z = x + 1       -               -\n+                                                                                \n+     step2: vectorize stmt S2 (done here):\n+        To vectorize stmt S2 we first need to find the relevant vector\n+        def for the first operand 'x'. This is, as usual, obtained from\n+        the vector stmt recorded in the STMT_VINFO_VEC_STMT of the stmt\n+        that defines 'x' (S1). This way we find the stmt VS1_0, and the\n+        relevant vector def 'vx0'. Having found 'vx0' we can generate\n+        the vector stmt VS2_0, and as usual, record it in the\n+        STMT_VINFO_VEC_STMT of stmt S2.\n+        When creating the second copy (VS2_1), we obtain the relevant vector\n+        def from the vector stmt recorded in the STMT_VINFO_RELATED_STMT of\n+        stmt VS1_0. This way we find the stmt VS1_1 and the relevant\n+        vector def 'vx1'. Using 'vx1' we create stmt VS2_1 and record a\n+        pointer to it in the STMT_VINFO_RELATED_STMT of the vector stmt VS2_0.\n+        Similarly when creating stmts VS2_2 and VS2_3. This is the resulting\n+        chain of stmts and pointers:\n+                                RELATED_STMT    VEC_STMT\n+        VS1_0:  vx0 = memref0   VS1_1           -\n+        VS1_1:  vx1 = memref1   VS1_2           -\n+        VS1_2:  vx2 = memref2   VS1_3           -\n+        VS1_3:  vx3 = memref3   -               -\n+        S1:     x = load        -               VS1_0\n+        VS2_0:  vz0 = vx0 + v1  VS2_1           -\n+        VS2_1:  vz1 = vx1 + v1  VS2_2           -\n+        VS2_2:  vz2 = vx2 + v1  VS2_3           -\n+        VS2_3:  vz3 = vx3 + v1  -               -\n+        S2:     z = x + 1       -               VS2_0  */\n+                                                                                \n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n+    {\n+      /* Handle uses.  */\n+      if (j == 0)\n+\t{\n+\t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+\t  if (op_type == binary_op)\n+\t    {\n+\t      if (code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n+\t        {\n+\t          /* Vector shl and shr insn patterns can be defined with\n+\t             scalar operand 2 (shift operand).  In this case, use\n+\t             constant or loop invariant op1 directly, without\n+\t             extending it to vector mode first.  */\n+\t          optab_op2_mode = insn_data[icode].operand[2].mode;\n+\t          if (!VECTOR_MODE_P (optab_op2_mode))\n+\t            {\n+\t              if (vect_print_dump_info (REPORT_DETAILS))\n+\t                fprintf (vect_dump, \"operand 1 using scalar mode.\");\n+\t              vec_oprnd1 = op1;\n+\t            }\n+\t        }\n+\t      if (!vec_oprnd1)\n+\t        vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t  if (op_type == binary_op)\n+\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt1, vec_oprnd1);\n+\t}\n+\n+      /* Arguments are ready. create the new vector stmt.  */\n+                                                                                \n+      if (op_type == binary_op)\n+        new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n+                    build2 (code, vectype, vec_oprnd0, vec_oprnd1));\n+      else\n+        new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n+                    build1 (code, vectype, vec_oprnd0));\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+                                                                                \n+      if (j == 0)\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      else\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Function vectorizable_type_demotion\n+                                                                                \n+   Check if STMT performs a binary or unary operation that involves\n+   type demotion, and if it can be vectorized.\n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+                                                                                \n+bool\n+vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n+                             tree *vec_stmt)\n+{\n+  tree vec_dest;\n+  tree scalar_dest;\n+  tree operation;\n+  tree op0;\n+  tree vec_oprnd0=NULL, vec_oprnd1=NULL;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  enum tree_code code;\n+  tree new_temp;\n+  tree def, def_stmt;\n+  enum vect_def_type dt0;\n+  tree new_stmt;\n+  stmt_vec_info prev_stmt_info;\n+  int nunits_in;\n+  int nunits_out;\n+  tree vectype_out;\n+  int ncopies;\n+  int j;\n+  tree expr;\n+  tree vectype_in;\n+  tree scalar_type;\n+  optab optab;\n+  enum machine_mode vec_mode;\n+                                                                                \n+  /* Is STMT a vectorizable type-demotion operation?  */\n+                                                                                \n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+                                                                                \n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+                                                                                \n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      /* FORNOW: not yet supported.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n+                                                                                \n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+                                                                                \n+  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+    return false;\n+                                                                                \n+  operation = TREE_OPERAND (stmt, 1);\n+  code = TREE_CODE (operation);\n+  if (code != NOP_EXPR && code != CONVERT_EXPR)\n+    return false;\n+                                                                                \n+  op0 = TREE_OPERAND (operation, 0);\n+  vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op0));\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n+                                                                                \n+  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_type = TREE_TYPE (scalar_dest);\n+  vectype_out = get_vectype_for_scalar_type (scalar_type);\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+  if (nunits_in != nunits_out / 2) /* FORNOW */\n+    return false;\n+                                                                                \n+  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n+  gcc_assert (ncopies >= 1);\n+                                                                                \n+  /* Check the operands of the operation.  */\n+  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n+                                                                                \n+  /* Supportable by target?  */\n+  code = VEC_PACK_MOD_EXPR;\n+  optab = optab_for_tree_code (VEC_PACK_MOD_EXPR, vectype_in);\n+  if (!optab)\n+    return false;\n+                                                                                \n+  vec_mode = TYPE_MODE (vectype_in);\n+  if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n+    return false;\n+                                                                                \n+  STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n+                                                                                \n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;\n+      return true;\n+    }\n+                                                                                \n+  /** Transform.  **/\n+                                                                                \n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"transform type demotion operation. ncopies = %d.\",\n+                        ncopies);\n+                                                                                \n+  /* Handle def.  */\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+  \n+  /* In case the vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits.   */\n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n+    {\n+      /* Handle uses.  */\n+      if (j == 0)\n+\t{\n+\t  enum vect_def_type dt = vect_unknown_def_type; /* Dummy */\n+\t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd0);\n+\t}\n+      else\n+\t{\n+\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd1);\n+\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t}\n+                                                                                \n+      /* Arguments are ready. Create the new vector stmt.  */\n+      expr = build2 (code, vectype_out, vec_oprnd0, vec_oprnd1);\n+      new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, expr);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+                                                                                \n+      if (j == 0)\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+      else\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+                                                                                \n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+    }\n+                                                                                \n+  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+  return true;\n+}\n+\n+\n+/* Function vect_gen_widened_results_half\n+\n+   Create a vector stmt whose code, type, number of arguments, and result\n+   variable are CODE, VECTYPE, OP_TYPE, and VEC_DEST, and its arguments are \n+   VEC_OPRND0 and VEC_OPRND1. The new vector stmt is to be inserted at BSI.\n+   In the case that CODE is a CALL_EXPR, this means that a call to DECL\n+   needs to be created (DECL is a function-decl of a target-builtin).\n+   STMT is the original scalar stmt that we are vectorizing.  */\n+\n+static tree\n+vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n+                               tree vec_oprnd0, tree vec_oprnd1, int op_type,\n+                               tree vec_dest, block_stmt_iterator *bsi,\n+\t\t\t       tree stmt)\n+{ \n+  tree vec_params;\n+  tree expr; \n+  tree new_stmt; \n+  tree new_temp; \n+  tree sym; \n+  ssa_op_iter iter;\n+ \n+  /* Generate half of the widened result:  */ \n+  if (code == CALL_EXPR) \n+    {  \n+      /* Target specific support  */ \n+      vec_params = build_tree_list (NULL_TREE, vec_oprnd0); \n+      if (op_type == binary_op) \n+        vec_params = tree_cons (NULL_TREE, vec_oprnd1, vec_params); \n+      expr = build_function_call_expr (decl, vec_params); \n+    } \n+  else \n+    { \n+      /* Generic support */ \n+      gcc_assert (op_type == TREE_CODE_LENGTH (code)); \n+      if (op_type == binary_op) \n+        expr = build2 (code, vectype, vec_oprnd0, vec_oprnd1); \n+      else  \n+        expr = build1 (code, vectype, vec_oprnd0); \n+    } \n+  new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, expr); \n+  new_temp = make_ssa_name (vec_dest, new_stmt); \n+  TREE_OPERAND (new_stmt, 0) = new_temp; \n+  vect_finish_stmt_generation (stmt, new_stmt, bsi); \n+\n+  if (code == CALL_EXPR)\n+    {\n+      FOR_EACH_SSA_TREE_OPERAND (sym, new_stmt, iter, SSA_OP_ALL_VIRTUALS)\n+        {\n+          if (TREE_CODE (sym) == SSA_NAME)\n+            sym = SSA_NAME_VAR (sym);\n+          mark_sym_for_renaming (sym);\n+        }\n+    }\n+\n+  return new_stmt;\n+}\n+\n+\n+/* Function vectorizable_type_promotion\n+\n+   Check if STMT performs a binary or unary operation that involves\n+   type promotion, and if it can be vectorized.\n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+bool\n+vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n+                             tree *vec_stmt)\n+{\n+  tree vec_dest;\n+  tree scalar_dest;\n+  tree operation;\n+  tree op0, op1 = NULL;\n+  tree vec_oprnd0=NULL, vec_oprnd1=NULL;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  enum tree_code code, code1 = CODE_FOR_nothing, code2 = CODE_FOR_nothing;\n+  tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n+  int op_type; \n+  tree def, def_stmt;\n+  enum vect_def_type dt0, dt1;\n+  tree new_stmt;\n+  stmt_vec_info prev_stmt_info;\n+  int nunits_in;\n+  int nunits_out;\n+  tree vectype_out;\n+  int ncopies;\n+  int j;\n+  tree vectype_in;\n+  \n+  /* Is STMT a vectorizable type-promotion operation?  */\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      /* FORNOW: not yet supported.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+    return false;\n+\n+  operation = TREE_OPERAND (stmt, 1);\n+  code = TREE_CODE (operation);\n+  if (code != NOP_EXPR && code != WIDEN_MULT_EXPR)\n+    return false;\n+\n   op0 = TREE_OPERAND (operation, 0);\n-  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+  vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op0));\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n+  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+  gcc_assert (ncopies >= 1);\n+\n+  scalar_dest = TREE_OPERAND (stmt, 0);\n+  vectype_out = get_vectype_for_scalar_type (TREE_TYPE (scalar_dest));\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+  if (nunits_out != nunits_in / 2) /* FORNOW */\n+    return false;\n+\n+  /* Check the operands of the operation.  */\n+  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n \n+  op_type = TREE_CODE_LENGTH (code);\n   if (op_type == binary_op)\n     {\n       op1 = TREE_OPERAND (operation, 1);\n+      if (!vect_is_simple_use (op1, loop_vinfo, &def_stmt, &def, &dt1))\n+        {\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"use not simple.\");\n+          return false;\n+        }\n+    }\n \n-      if (code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n-\t{\n-\t  /* Vector shl and shr insn patterns can be defined with\n-\t     scalar operand 2 (shift operand).  In this case, use\n-\t     constant or loop invariant op1 directly, without\n-\t     extending it to vector mode first.  */\n+  /* Supportable by target?  */\n+  if (!supportable_widening_operation (code, stmt, vectype_in,\n+\t\t\t\t       &decl1, &decl2, &code1, &code2))\n+    return false;\n \n-\t  optab_op2_mode = insn_data[icode].operand[2].mode;\n-\t  if (!VECTOR_MODE_P (optab_op2_mode))\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"operand 1 using scalar mode.\");\n-\t      vec_oprnd1 = op1;\n-\t    }\n-\t}\n+  STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n \n-      if (!vec_oprnd1)\n-\tvec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL); \n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;\n+      return true;\n     }\n \n-  /* Arguments are ready. create the new vector stmt.  */\n+  /** Transform.  **/\n \n-  if (op_type == binary_op)\n-    *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n-\t\tbuild2 (code, vectype, vec_oprnd0, vec_oprnd1));\n-  else\n-    *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n-\t\tbuild1 (code, vectype, vec_oprnd0));\n-  new_temp = make_ssa_name (vec_dest, *vec_stmt);\n-  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n-  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"transform type promotion operation. ncopies = %d.\",\n+                        ncopies);\n+\n+  /* Handle def.  */\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+\n+  /* In case the vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits.   */\n \n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n+    {\n+      /* Handle uses.  */\n+      if (j == 0)\n+        {\n+\t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+\t  if (op_type == binary_op)\n+\t    vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL);\n+        }\n+      else\n+        {\n+\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t  if (op_type == binary_op)\n+\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt1, vec_oprnd1);\n+        }\n+\n+      /* Arguments are ready. Create the new vector stmt.  We are creating \n+         two vector defs because the widened result does not fit in one vector.\n+         The vectorized stmt can be expressed as a call to a taregt builtin,\n+         or a using a tree-code.  */\n+      /* Generate first half of the widened result:  */\n+      new_stmt = vect_gen_widened_results_half (code1, vectype_out, decl1, \n+                        vec_oprnd0, vec_oprnd1, op_type, vec_dest, bsi, stmt);\n+      if (j == 0)\n+        STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+      else\n+        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\n+      /* Generate second half of the widened result:  */\n+      new_stmt = vect_gen_widened_results_half (code2, vectype_out, decl2,\n+                        vec_oprnd0, vec_oprnd1, op_type, vec_dest, bsi, stmt);\n+      STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\n+    }\n+\n+  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n   return true;\n }\n \n@@ -1658,7 +2306,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree scalar_dest;\n   tree data_ref;\n   tree op;\n-  tree vec_oprnd1;\n+  tree vec_oprnd = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -1667,8 +2315,16 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree dummy;\n   enum dr_alignment_support alignment_support_cheme;\n   ssa_op_iter iter;\n+  def_operand_p def_p;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n+  stmt_vec_info prev_stmt_info;\n+  tree dataref_ptr = NULL_TREE;\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int j;\n+\n+  gcc_assert (ncopies >= 1);\n \n   /* Is vectorizable store? */\n \n@@ -1707,45 +2363,188 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   /** Transform.  **/\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform store\");\n+    fprintf (vect_dump, \"transform store. ncopies = %d\",ncopies);\n \n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n   gcc_assert (alignment_support_cheme);\n   gcc_assert (alignment_support_cheme == dr_aligned);  /* FORNOW */\n \n-  /* Handle use - get the vectorized def from the defining stmt.  */\n-  vec_oprnd1 = vect_get_vec_def_for_operand (op, stmt, NULL);\n+  /* In case the vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits.  For more details see documentation in \n+     vect_get_vec_def_for_copy_stmt.  */\n \n-  /* Handle def.  */\n-  /* FORNOW: make sure the data reference is aligned.  */\n-  vect_align_data_ref (stmt);\n-  data_ref = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &dummy, false);\n-  data_ref = build_fold_indirect_ref (data_ref);\n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n+    {\n+      tree new_stmt;\n+      tree ptr_incr;\n \n-  /* Arguments are ready. create the new vector stmt.  */\n-  *vec_stmt = build2 (MODIFY_EXPR, vectype, data_ref, vec_oprnd1);\n-  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+      if (j == 0)\n+\t{\n+\t  vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t  dataref_ptr = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &dummy, \n+\t\t\t\t\t\t  &ptr_incr, false);\n+\t}\n+      else \n+\t{\n+\t  vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n+\t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n+\t}\n \n-  /* Copy the V_MAY_DEFS representing the aliasing of the original array\n-     element's definition to the vector's definition then update the\n-     defining statement.  The original is being deleted so the same\n-     SSA_NAMEs can be used.  */\n-  copy_virtual_operands (*vec_stmt, stmt);\n+      /* Arguments are ready. create the new vector stmt.  */\n+      data_ref = build_fold_indirect_ref (dataref_ptr);\n+      new_stmt = build2 (MODIFY_EXPR, vectype, data_ref, vec_oprnd);\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n-    {\n-      SSA_NAME_DEF_STMT (def) = *vec_stmt;\n+     /* Set the V_MAY_DEFS for the vector pointer. If this virtual def has a \n+\tuse outside the loop and a loop peel is performed then the def may be \n+\trenamed by the peel.  Mark it for renaming so the later use will also \n+\tbe renamed.  */\n+      copy_virtual_operands (new_stmt, stmt);\n+      if (j == 0)\n+\t{\n+\t  /* The original store is deleted so the same SSA_NAMEs can be used.  \n+\t   */\n+\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n+\t    {\n+\t      SSA_NAME_DEF_STMT (def) = new_stmt;\n+\t      mark_sym_for_renaming (SSA_NAME_VAR (def));\n+\t    }\n \n-      /* If this virtual def has a use outside the loop and a loop peel is \n-\t performed then the def may be renamed by the peel.  Mark it for \n-\t renaming so the later use will also be renamed.  */\n-      mark_sym_for_renaming (SSA_NAME_VAR (def));\n+\t  STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt =  new_stmt;\n+\t}\n+      else\n+\t{\n+\t  /* Create new names for all the definitions created by COPY and\n+\t     add replacement mappings for each new name.  */\n+          FOR_EACH_SSA_DEF_OPERAND (def_p, new_stmt, iter, SSA_OP_VMAYDEF)\n+\t    {\n+\t      create_new_def_for (DEF_FROM_PTR (def_p), new_stmt, def_p);\n+\t      mark_sym_for_renaming (SSA_NAME_VAR (DEF_FROM_PTR (def_p)));\n+\t    }\n+\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t}\n+\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n     }\n \n   return true;\n }\n \n \n+/* Function vect_setup_realignment\n+  \n+   This function is called when vectorizing an unaligned load using\n+   the dr_unaligned_software_pipeline scheme.\n+   This function generates the following code at the loop prolog:\n+\n+      p = initial_addr;\n+      msq_init = *(floor(p));   # prolog load\n+      realignment_token = call target_builtin; \n+    loop:\n+      msq = phi (msq_init, ---)\n+\n+   The code above sets up a new (vector) pointer, pointing to the first \n+   location accessed by STMT, and a \"floor-aligned\" load using that pointer.\n+   It also generates code to compute the \"realignment-token\" (if the relevant\n+   target hook was defined), and creates a phi-node at the loop-header bb\n+   whose arguments are the result of the prolog-load (created by this\n+   function) and the result of a load that takes place in the loop (to be\n+   created by the caller to this function).\n+   The caller to this function uses the phi-result (msq) to create the \n+   realignment code inside the loop, and sets up the missing phi argument,\n+   as follows:\n+\n+    loop: \n+      msq = phi (msq_init, lsq)\n+      lsq = *(floor(p'));        # load in loop\n+      result = realign_load (msq, lsq, realignment_token);\n+\n+   Input:\n+   STMT - (scalar) load stmt to be vectorized. This load accesses\n+          a memory location that may be unaligned.\n+   BSI - place where new code is to be inserted.\n+   \n+   Output:\n+   REALIGNMENT_TOKEN - the result of a call to the builtin_mask_for_load\n+                       target hook, if defined.\n+   Return value - the result of the loop-header phi node.\n+*/\n+\n+static tree\n+vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n+                        tree *realignment_token)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  edge pe = loop_preheader_edge (loop);\n+  tree scalar_dest = TREE_OPERAND (stmt, 0);\n+  tree vec_dest;\n+  tree init_addr;\n+  tree inc;\n+  tree ptr;\n+  tree data_ref;\n+  tree new_stmt;\n+  basic_block new_bb;\n+  tree msq_init;\n+  tree new_temp;\n+  tree phi_stmt;\n+  tree msq;\n+\n+  /* 1. Create msq_init = *(floor(p1)) in the loop preheader  */\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  ptr = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &init_addr, &inc, true);\n+  data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n+  new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n+  new_temp = make_ssa_name (vec_dest, new_stmt);\n+  TREE_OPERAND (new_stmt, 0) = new_temp;\n+  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n+  gcc_assert (!new_bb);\n+  msq_init = TREE_OPERAND (new_stmt, 0);\n+  copy_virtual_operands (new_stmt, stmt);\n+  update_vuses_to_preheader (new_stmt, loop);\n+\n+  /* 2. Create permutation mask, if required, in loop preheader.  */\n+  if (targetm.vectorize.builtin_mask_for_load)\n+    {\n+      tree builtin_decl;\n+      tree params = build_tree_list (NULL_TREE, init_addr);\n+\n+      vec_dest = vect_create_destination_var (scalar_dest, \n+\t\t\t\t\t\t\tTREE_TYPE (new_stmt));\n+      builtin_decl = targetm.vectorize.builtin_mask_for_load ();\n+      new_stmt = build_function_call_expr (builtin_decl, params);\n+      new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, new_stmt);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n+      gcc_assert (!new_bb);\n+      *realignment_token = TREE_OPERAND (new_stmt, 0);\n+\n+      /* The result of the CALL_EXPR to this builtin is determined from\n+         the value of the parameter and no global variables are touched\n+         which makes the builtin a \"const\" function.  Requiring the\n+         builtin to have the \"const\" attribute makes it unnecessary\n+         to call mark_call_clobbered.  */\n+      gcc_assert (TREE_READONLY (builtin_decl));\n+    }\n+\n+  /* 3. Create msq = phi <msq_init, lsq> in loop  */\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  msq = make_ssa_name (vec_dest, NULL_TREE);\n+  phi_stmt = create_phi_node (msq, loop->header); \n+  SSA_NAME_DEF_STMT (msq) = phi_stmt;\n+  add_phi_arg (phi_stmt, msq_init, loop_preheader_edge (loop));\n+\n+  return msq;\n+}\n+\n+\n /* vectorizable_load.\n \n    Check if STMT reads a non scalar data-ref (array/pointer/structure) that \n@@ -1762,18 +2561,25 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree data_ref = NULL;\n   tree op;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  stmt_vec_info prev_stmt_info; \n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree new_temp;\n   int mode;\n-  tree init_addr;\n   tree new_stmt;\n   tree dummy;\n-  basic_block new_bb;\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  edge pe = loop_preheader_edge (loop);\n   enum dr_alignment_support alignment_support_cheme;\n+  tree dataref_ptr = NULL_TREE;\n+  tree ptr_incr;\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int j;\n+  tree msq = NULL_TREE, lsq;\n+  tree offset = NULL_TREE;\n+  tree realignment_token = NULL_TREE;\n+  tree phi_stmt = NULL_TREE;\n \n   /* Is vectorizable load? */\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -1828,142 +2634,148 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n   gcc_assert (alignment_support_cheme);\n \n-  if (alignment_support_cheme == dr_aligned\n-      || alignment_support_cheme == dr_unaligned_supported)\n-    {\n-      /* Create:\n+  /* In case the vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits. In doing so, we record a pointer\n+     from one copy of the vector stmt to the next, in the field\n+     STMT_VINFO_RELATED_STMT. This is necessary in order to allow following\n+     stages to find the correct vector defs to be used when vectorizing\n+     stmts that use the defs of the current stmt. The example below illustrates\n+     the vectorization process when VF=16 and nunits=4 (i.e - we need to create\n+     4 vectorized stmts):\n+\n+     before vectorization:\n+                                RELATED_STMT    VEC_STMT\n+        S1:     x = memref      -               -\n+        S2:     z = x + 1       -               -\n+\n+     step 1: vectorize stmt S1:\n+        We first create the vector stmt VS1_0, and, as usual, record a\n+        pointer to it in the STMT_VINFO_VEC_STMT of the scalar stmt S1.\n+        Next, we create the vector stmt VS1_1, and record a pointer to\n+        it in the STMT_VINFO_RELATED_STMT of the vector stmt VS1_0.\n+        Similarly, for VS1_2 and VS1_3. This is the resulting chain of\n+        stmts and pointers:\n+                                RELATED_STMT    VEC_STMT\n+        VS1_0:  vx0 = memref0   VS1_1           -\n+        VS1_1:  vx1 = memref1   VS1_2           -\n+        VS1_2:  vx2 = memref2   VS1_3           -\n+        VS1_3:  vx3 = memref3   -               -\n+        S1:     x = load        -               VS1_0\n+        S2:     z = x + 1       -               -\n+\n+     See in documentation in vect_get_vec_def_for_stmt_copy for how the \n+     information we recorded in RELATED_STMT field is used to vectorize \n+     stmt S2.  */\n+\n+  /* If the data reference is aligned (dr_aligned) or potentially unaligned\n+     on a target that supports unaligned accesses (dr_unaligned_supported)\n+     we generate the following code:\n          p = initial_addr;\n          indx = 0;\n          loop {\n+\t   p = p + indx * vectype_size;\n            vec_dest = *(p);\n            indx = indx + 1;\n          }\n-      */\n \n-      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      data_ref = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &dummy, false);\n-      if (aligned_access_p (dr))\n-        data_ref = build_fold_indirect_ref (data_ref);\n-      else\n-\t{\n-\t  int mis = DR_MISALIGNMENT (dr);\n-\t  tree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n-\t  tmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));\n-\t  data_ref = build2 (MISALIGNED_INDIRECT_REF, vectype, data_ref, tmis);\n-\t}\n-      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n-      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-      copy_virtual_operands (new_stmt, stmt);\n+     Otherwise, the data reference is potentially unaligned on a target that\n+     does not support unaligned accesses (dr_unaligned_software_pipeline) - \n+     then generate the following code, in which the data in each iteration is\n+     obtained by two vector loads, one from the previous iteration, and one\n+     from the current iteration:\n+         p1 = initial_addr;\n+         msq_init = *(floor(p1))\n+         p2 = initial_addr + VS - 1;\n+         realignment_token = call target_builtin;\n+         indx = 0;\n+         loop {\n+           p2 = p2 + indx * vectype_size\n+           lsq = *(floor(p2))\n+           vec_dest = realign_load (msq, lsq, realignment_token)\n+           indx = indx + 1;\n+           msq = lsq;\n+         }\n+  */\n+\n+  if (alignment_support_cheme == dr_unaligned_software_pipeline)\n+    {\n+      msq = vect_setup_realignment (stmt, bsi, &realignment_token);\n+      phi_stmt = SSA_NAME_DEF_STMT (msq);\n+      offset = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n     }\n-  else if (alignment_support_cheme == dr_unaligned_software_pipeline)\n-    {\n-      /* Create:\n-\t p1 = initial_addr;\n-\t msq_init = *(floor(p1))\n-\t p2 = initial_addr + VS - 1;\n-\t magic = have_builtin ? builtin_result : initial_address;\n-\t indx = 0;\n-\t loop {\n-\t   p2' = p2 + indx * vectype_size\n-\t   lsq = *(floor(p2'))\n-\t   vec_dest = realign_load (msq, lsq, magic)\n-\t   indx = indx + 1;\n-\t   msq = lsq;\n-\t }\n-      */\n-\n-      tree offset;\n-      tree magic;\n-      tree phi_stmt;\n-      tree msq_init;\n-      tree msq, lsq;\n-      tree dataref_ptr;\n-      tree params;\n-\n-      /* <1> Create msq_init = *(floor(p1)) in the loop preheader  */\n-      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      data_ref = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, \n-\t\t\t\t\t   &init_addr, true);\n-      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, data_ref);\n-      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n-      new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n-      gcc_assert (!new_bb);\n-      msq_init = TREE_OPERAND (new_stmt, 0);\n-      copy_virtual_operands (new_stmt, stmt);\n-      update_vuses_to_preheader (new_stmt, loop);\n \n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n+    { \n+      /* 1. Create the vector pointer update chain.  */\n+      if (j == 0)\n+        dataref_ptr = vect_create_data_ref_ptr (stmt, bsi, offset,\n+                                                &dummy, &ptr_incr, false);\n+      else\n+        dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n \n-      /* <2> Create lsq = *(floor(p2')) in the loop  */ \n-      offset = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n+      /* 2. Create the vector-load in the loop.  */\n+      switch (alignment_support_cheme)\n+      {\n+      case dr_aligned:\n+        gcc_assert (aligned_access_p (dr));\n+        data_ref = build_fold_indirect_ref (dataref_ptr);\n+        break;\n+      case dr_unaligned_supported:\n+        {\n+          int mis = DR_MISALIGNMENT (dr);\n+          tree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n+\n+          gcc_assert (!aligned_access_p (dr));\n+          tmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));\n+          data_ref =\n+                build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);\n+          break;\n+        }\n+      case dr_unaligned_software_pipeline:\n+        gcc_assert (!aligned_access_p (dr));\n+        data_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n+        break;\n+      default:\n+        gcc_unreachable ();\n+      }\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      dataref_ptr = vect_create_data_ref_ptr (stmt, bsi, offset, &dummy, false);\n-      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n       new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       TREE_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-      lsq = TREE_OPERAND (new_stmt, 0);\n       copy_virtual_operands (new_stmt, stmt);\n+      mark_new_vars_to_rename (new_stmt);\n \n-\n-      /* <3> */\n-      if (targetm.vectorize.builtin_mask_for_load)\n-\t{\n-\t  /* Create permutation mask, if required, in loop preheader.  */\n-\t  tree builtin_decl;\n-\t  params = build_tree_list (NULL_TREE, init_addr);\n-\t  builtin_decl = targetm.vectorize.builtin_mask_for_load ();\n-\t  new_stmt = build_function_call_expr (builtin_decl, params);\n-\t  vec_dest = vect_create_destination_var (scalar_dest,\n-                                                  TREE_TYPE (new_stmt));\n-          new_stmt = build2 (MODIFY_EXPR, TREE_TYPE (vec_dest), vec_dest,\n-                             new_stmt);\n+      /* 3. Handle explicit realignment if necessary/supported.  */\n+      if (alignment_support_cheme == dr_unaligned_software_pipeline)\n+        {\n+          /* Create in loop: \n+             <vec_dest = realign_load (msq, lsq, realignment_token)>  */\n+          lsq = TREE_OPERAND (new_stmt, 0);\n+          if (!realignment_token)\n+            realignment_token = dataref_ptr;\n+          vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+          new_stmt =\n+            build3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, realignment_token);\n+          new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n           new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t  TREE_OPERAND (new_stmt, 0) = new_temp;\n-\t  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n-\t  gcc_assert (!new_bb);\n-\t  magic = TREE_OPERAND (new_stmt, 0);\n-\n-\t  /* The result of the CALL_EXPR to this builtin is determined from\n-\t     the value of the parameter and no global variables are touched\n-\t     which makes the builtin a \"const\" function.  Requiring the\n-\t     builtin to have the \"const\" attribute makes it unnecessary\n-\t     to call mark_call_clobbered.  */\n-\t  gcc_assert (TREE_READONLY (builtin_decl));\n-\t}\n-      else\n-\t{\n-\t  /* Use current address instead of init_addr for reduced reg pressure.\n-\t   */\n-\t  magic = dataref_ptr;\n-\t}\n-\n-\n-      /* <4> Create msq = phi <msq_init, lsq> in loop  */ \n-      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      msq = make_ssa_name (vec_dest, NULL_TREE);\n-      phi_stmt = create_phi_node (msq, loop->header); /* CHECKME */\n-      SSA_NAME_DEF_STMT (msq) = phi_stmt;\n-      add_phi_arg (phi_stmt, msq_init, loop_preheader_edge (loop));\n-      add_phi_arg (phi_stmt, lsq, loop_latch_edge (loop));\n-\n+          TREE_OPERAND (new_stmt, 0) = new_temp;\n+          vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+          if (j == ncopies - 1)\n+            add_phi_arg (phi_stmt, lsq, loop_latch_edge (loop));\n+          msq = lsq;\n+        }\n \n-      /* <5> Create <vec_dest = realign_load (msq, lsq, magic)> in loop  */\n-      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      new_stmt = build3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, magic);\n-      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n-      new_temp = make_ssa_name (vec_dest, new_stmt); \n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n-      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+      if (j == 0)\n+        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      else\n+        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n     }\n-  else\n-    gcc_unreachable ();\n \n-  *vec_stmt = new_stmt;\n   return true;\n }\n \n@@ -2093,6 +2905,12 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum machine_mode vec_mode;\n   tree def;\n   enum vect_def_type dt;\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+\n+  gcc_assert (ncopies >= 1);\n+  if (ncopies > 1)\n+    return false; /* FORNOW */\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -2203,6 +3021,16 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n     {\n       switch (STMT_VINFO_TYPE (stmt_info))\n       {\n+      case type_demotion_vec_info_type:\n+        done = vectorizable_type_demotion (stmt, bsi, &vec_stmt);\n+        gcc_assert (done);\n+        break;\n+                                                                                \n+      case type_promotion_vec_info_type:\n+\tdone = vectorizable_type_promotion (stmt, bsi, &vec_stmt);\n+\tgcc_assert (done);\n+\tbreak;\n+\n       case op_vec_info_type:\n \tdone = vectorizable_operation (stmt, bsi, &vec_stmt);\n \tgcc_assert (done);\n@@ -2269,12 +3097,6 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n         done = vectorizable_live_operation (stmt, bsi, &vec_stmt);\n         gcc_assert (done);\n       }\n-\n-      if (vec_stmt)\n-        {\n-          gcc_assert (!STMT_VINFO_VEC_STMT (stmt_info));\n-          STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n-        }\n     }\n \n   return is_store; \n@@ -2680,7 +3502,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n       int byte_misalign = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-      int element_size = vectype_align/vf;\n+      int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n       int elem_misalign = byte_misalign / element_size;\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3100,11 +3922,11 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t      bsi_next (&si);\n \t      continue;\n \t    }\n-\t  /* FORNOW: Verify that all stmts operate on the same number of\n-\t             units and no inner unrolling is necessary.  */\n-\t  gcc_assert \n-\t\t(TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n-\t\t == (unsigned HOST_WIDE_INT) vectorization_factor);\n+\n+\t  if ((TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n+\t\t != (unsigned HOST_WIDE_INT) vectorization_factor)\n+\t      && vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"multiple-types.\");\n \n \t  /* -------- vectorize statement ------------ */\n \t  if (vect_print_dump_info (REPORT_DETAILS))"}, {"sha": "c35fc3025978a079764f1479911e0e1d31d3fd6f", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 124, "deletions": 2, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -136,6 +136,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cfgloop.h\"\n #include \"cfglayout.h\"\n #include \"expr.h\"\n+#include \"recog.h\"\n #include \"optabs.h\"\n #include \"params.h\"\n #include \"toplev.h\"\n@@ -1359,8 +1360,8 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_TYPE (res) = undef_vec_info_type;\n   STMT_VINFO_STMT (res) = stmt;\n   STMT_VINFO_LOOP_VINFO (res) = loop_vinfo;\n-  STMT_VINFO_RELEVANT_P (res) = 0;\n-  STMT_VINFO_LIVE_P (res) = 0;\n+  STMT_VINFO_RELEVANT (res) = 0;\n+  STMT_VINFO_LIVE_P (res) = false;\n   STMT_VINFO_VECTYPE (res) = NULL;\n   STMT_VINFO_VEC_STMT (res) = NULL;\n   STMT_VINFO_IN_PATTERN_P (res) = false;\n@@ -1753,6 +1754,127 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n }\n \n \n+/* Function supportable_widening_operation\n+\n+   Check whether an operation represented by the code CODE is a \n+   widening operation that is supported by the target platform in \n+   vector form (i.e., when operating on arguments of type VECTYPE).\n+    \n+   The two kinds of widening operations we currently support are\n+   NOP and WIDEN_MULT. This function checks if these oprations\n+   are supported by the target platform either directly (via vector \n+   tree-codes), or via target builtins.\n+\n+   Output:\n+   - CODE1 and CODE2 are codes of vector operations to be used when \n+   vectorizing the operation, if available. \n+   - DECL1 and DECL2 are decls of target builtin functions to be used\n+   when vectorizing the operation, if available. In this case,\n+   CODE1 and CODE2 are CALL_EXPR.  */\n+\n+bool\n+supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n+                                tree *decl1, tree *decl2,\n+                                enum tree_code *code1, enum tree_code *code2)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  bool ordered_p;\n+  enum machine_mode vec_mode;\n+  enum insn_code icode1, icode2;\n+  optab optab1, optab2;\n+  tree expr = TREE_OPERAND (stmt, 1);\n+  tree type = TREE_TYPE (expr);\n+  tree wide_vectype = get_vectype_for_scalar_type (type);\n+  enum tree_code c1, c2;\n+\n+  /* The result of a vectorized widening operation usually requires two vectors \n+     (because the widened results do not fit int one vector). The generated \n+     vector results would normally be expected to be generated in the same \n+     order as in the original scalar computation. i.e. if 8 results are \n+     generated in each vector iteration, they are to be organized as follows:\n+        vect1: [res1,res2,res3,res4], vect2: [res5,res6,res7,res8]. \n+\n+     However, in the special case that the result of the widening operation is \n+     used in a reduction copmutation only, the order doesn't matter (because \n+     when vectorizing a reduction we change the order of the computation). \n+     Some targets can take advatage of this and generate more efficient code. \n+     For example, targets like Altivec, that support widen_mult using a sequence\n+     of {mult_even,mult_odd} generate the following vectors:\n+        vect1: [res1,res3,res5,res7], vect2: [res2,res4,res6,res8].  */\n+\n+   if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction)\n+     ordered_p = false;\n+   else\n+     ordered_p = true;\n+\n+  if (!ordered_p\n+      && code == WIDEN_MULT_EXPR\n+      && targetm.vectorize.builtin_mul_widen_even\n+      && targetm.vectorize.builtin_mul_widen_even (vectype)\n+      && targetm.vectorize.builtin_mul_widen_odd\n+      && targetm.vectorize.builtin_mul_widen_odd (vectype))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"Unordered widening operation detected.\");\n+\n+      *code1 = *code2 = CALL_EXPR;\n+      *decl1 = targetm.vectorize.builtin_mul_widen_even (vectype);\n+      *decl2 = targetm.vectorize.builtin_mul_widen_odd (vectype);\n+      return true;\n+    }\n+\n+  switch (code)\n+    {\n+    case WIDEN_MULT_EXPR:\n+      if (BYTES_BIG_ENDIAN)\n+        {\n+          c1 = VEC_WIDEN_MULT_HI_EXPR;\n+          c2 = VEC_WIDEN_MULT_LO_EXPR;\n+        }\n+      else\n+        {\n+          c2 = VEC_WIDEN_MULT_HI_EXPR;\n+          c1 = VEC_WIDEN_MULT_LO_EXPR;\n+        }\n+      break;\n+\n+    case NOP_EXPR:\n+      if (BYTES_BIG_ENDIAN)\n+        {\n+          c1 = VEC_UNPACK_HI_EXPR;\n+          c2 = VEC_UNPACK_LO_EXPR;\n+        }\n+      else\n+        {\n+          c2 = VEC_UNPACK_HI_EXPR;\n+          c1 = VEC_UNPACK_LO_EXPR;\n+        }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  *code1 = c1;\n+  *code2 = c2;\n+  optab1 = optab_for_tree_code (c1, vectype);\n+  optab2 = optab_for_tree_code (c2, vectype);\n+\n+  if (!optab1 || !optab2)\n+    return false;\n+\n+  vec_mode = TYPE_MODE (vectype);\n+  if ((icode1 = optab1->handlers[(int) vec_mode].insn_code) == CODE_FOR_nothing\n+      || insn_data[icode1].operand[0].mode != TYPE_MODE (wide_vectype)\n+      || (icode2 = optab2->handlers[(int) vec_mode].insn_code)\n+                                                        == CODE_FOR_nothing\n+      || insn_data[icode2].operand[0].mode != TYPE_MODE (wide_vectype))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n /* Function reduction_code_for_scalar_code\n \n    Input:"}, {"sha": "b56f7ded95c1a144ef003d02635333415564db18", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -165,7 +165,16 @@ enum stmt_vec_info_type {\n   op_vec_info_type,\n   assignment_vec_info_type,\n   condition_vec_info_type,\n-  reduc_vec_info_type\n+  reduc_vec_info_type,\n+  type_promotion_vec_info_type,\n+  type_demotion_vec_info_type\n+};\n+\n+/* Indicates whether/how a variable is used in the loop.  */\n+enum vect_relevant {\n+  vect_unused_in_loop = 0,\n+  vect_used_by_reduction,\n+  vect_used_in_loop  \n };\n \n typedef struct data_reference *dr_p;\n@@ -182,10 +191,10 @@ typedef struct _stmt_vec_info {\n   /* The loop_vec_info with respect to which STMT is vectorized.  */\n   loop_vec_info loop_vinfo;\n \n-  /* Not all stmts in the loop need to be vectorized. e.g, the incrementation\n+  /* Not all stmts in the loop need to be vectorized. e.g, the increment\n      of the loop induction variable and computation of array indexes. relevant\n      indicates whether the stmt needs to be vectorized.  */\n-  bool relevant;\n+  enum vect_relevant relevant;\n \n   /* Indicates whether this stmts is part of a computation whose result is\n      used outside the loop.  */\n@@ -232,7 +241,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_TYPE(S)                (S)->type\n #define STMT_VINFO_STMT(S)                (S)->stmt\n #define STMT_VINFO_LOOP_VINFO(S)          (S)->loop_vinfo\n-#define STMT_VINFO_RELEVANT_P(S)          (S)->relevant\n+#define STMT_VINFO_RELEVANT(S)            (S)->relevant\n #define STMT_VINFO_LIVE_P(S)              (S)->live\n #define STMT_VINFO_VECTYPE(S)             (S)->vectype\n #define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n@@ -242,6 +251,8 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_SAME_ALIGN_REFS(S)     (S)->same_align_refs\n #define STMT_VINFO_DEF_TYPE(S)            (S)->def_type\n \n+#define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_loop)\n+\n static inline void set_stmt_info (stmt_ann_t ann, stmt_vec_info stmt_info);\n static inline stmt_vec_info vinfo_for_stmt (tree stmt);\n \n@@ -328,6 +339,8 @@ extern bool vect_can_force_dr_alignment_p (tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n   (struct data_reference *);\n extern bool reduction_code_for_scalar_code (enum tree_code, enum tree_code *);\n+extern bool supportable_widening_operation (enum tree_code, tree, tree,\n+  tree *, tree *, enum tree_code *, enum tree_code *);\n /* Creation and deletion of loop and stmt info structs.  */\n extern loop_vec_info new_loop_vec_info (struct loop *loop);\n extern void destroy_loop_vec_info (loop_vec_info);\n@@ -354,6 +367,8 @@ void vect_pattern_recog (loop_vec_info);\n extern bool vectorizable_load (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_store (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_type_promotion (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_type_demotion (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);"}, {"sha": "2c16cb91f48d4340e5d17f3f0a9cd8242ef241c0", "filename": "gcc/tree.def", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d67ccabbe7c4b8150403c32199855008cd8522/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=89d67ccabbe7c4b8150403c32199855008cd8522", "patch": "@@ -1073,6 +1073,28 @@ DEFTREECODE (WIDEN_MULT_EXPR, \"widen_mult_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_LSHIFT_EXPR, \"vec_lshift_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_RSHIFT_EXPR, \"vec_rshift_expr\", tcc_binary, 2)\n \n+/* Widening vector multiplication.\n+   The two operands are vectors with N elements of size S. Multiplying the\n+   elements of the two vectors will result in N products of size 2*S.\n+   VEC_WIDEN_MULT_HI_EXPR computes the N/2 high products.\n+   VEC_WIDEN_MULT_LO_EXPR computes the N/2 low products.  */\n+DEFTREECODE (VEC_WIDEN_MULT_HI_EXPR, \"widen_mult_hi_expr\", tcc_binary, 2)\n+DEFTREECODE (VEC_WIDEN_MULT_LO_EXPR, \"widen_mult_hi_expr\", tcc_binary, 2)\n+\n+/* Unpack (extract and promote/widen) the high/low elements of the input vector\n+   into the output vector. The input vector has twice as many elements\n+   as the output vector, that are half the size of the elements\n+   of the output vector.  This is used to support type promotion. */\n+DEFTREECODE (VEC_UNPACK_HI_EXPR, \"vec_unpack_hi_expr\", tcc_unary, 1)\n+DEFTREECODE (VEC_UNPACK_LO_EXPR, \"vec_unpack_lo_expr\", tcc_unary, 1)\n+\n+/* Pack (demote/narrow and merge) the elements of the two input vectors\n+   into the output vector, using modulo/saturating arithmetic.\n+   The elements of the input vectors are twice the size of the elements of the\n+   output vector.  This is used to support type demotion.  */\n+DEFTREECODE (VEC_PACK_MOD_EXPR, \"vec_pack_mod_expr\", tcc_binary, 2)\n+DEFTREECODE (VEC_PACK_SAT_EXPR, \"vec_pack_sat_expr\", tcc_binary, 2)\n+                                                                                \n /*\n Local variables:\n mode:c"}]}