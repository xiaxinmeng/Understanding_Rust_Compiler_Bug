{"sha": "18095be17013444d9e91aa8c73ebe5cf58ccb3f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgwOTViZTE3MDEzNDQ0ZDllOTFhYThjNzNlYmU1Y2Y1OGNjYjNmMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-08-11T15:16:22Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-08-11T15:16:22Z"}, "message": "libstdc++: Make Networking TS work without gthreads [PR 89760]\n\nMake the experimental Networking TS code work without std::mutex and\nstd::condition_variable.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/89760\n\t* include/experimental/executor [!_GLIBCXX_HAS_GTHREADS]:\n\t(execution_context::mutex_type): Define dummy mutex type.\n\t(system_context): Use execution_context::mutex_type.\n\t(system_context) [!_GLIBCXX_HAS_GTHREADS]: Define dummy\n\tthread and condition variable types.\n\t[!_GLIBCXX_HAS_GTHREADS] (system_context::_M_run()): Do not\n\tdefine.\n\t(system_context::_M_post) [!_GLIBCXX_HAS_GTHREADS]: Throw\n\tan exception when threads aren't available.\n\t(strand::running_in_this_thread()): Defer to _M_state.\n\t(strand::_State::running_in_this_thread()): New function.\n\t(use_future_t): Do not depend on _GLIBCXX_USE_C99_STDINT_TR1.\n\t* include/experimental/io_context (io_context): Use the\n\texecution_context::mutex_type alias. Replace stack of thread\n\tIDs with counter.\n\t* testsuite/experimental/net/execution_context/use_service.cc:\n\tEnable test for non-pthread targets.", "tree": {"sha": "23aaf47967b46aaa80934817d6f24c2572f867e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23aaf47967b46aaa80934817d6f24c2572f867e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18095be17013444d9e91aa8c73ebe5cf58ccb3f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18095be17013444d9e91aa8c73ebe5cf58ccb3f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18095be17013444d9e91aa8c73ebe5cf58ccb3f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18095be17013444d9e91aa8c73ebe5cf58ccb3f1/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a6918e4fa57edbe0dc326d5f142350b1dd4afd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a6918e4fa57edbe0dc326d5f142350b1dd4afd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a6918e4fa57edbe0dc326d5f142350b1dd4afd7"}], "stats": {"total": 125, "additions": 87, "deletions": 38}, "files": [{"sha": "45e813f6747e93c89152f9082fbc6fd3387e681a", "filename": "libstdc++-v3/include/experimental/executor", "status": "modified", "additions": 50, "deletions": 15, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18095be17013444d9e91aa8c73ebe5cf58ccb3f1/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18095be17013444d9e91aa8c73ebe5cf58ccb3f1/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor?ref=18095be17013444d9e91aa8c73ebe5cf58ccb3f1", "patch": "@@ -506,7 +506,16 @@ inline namespace v1\n       bool _M_active;\n     };\n \n-    mutable std::mutex _M_mutex;\n+#if defined(_GLIBCXX_HAS_GTHREADS)\n+    using mutex_type = std::mutex;\n+#else\n+    struct mutex_type\n+    {\n+      void lock() const { }\n+      void unlock() const { }\n+    };\n+#endif\n+    mutable mutex_type _M_mutex;\n \n     // Sorted in order of beginning of service object lifetime.\n     std::list<_ServicePtr> _M_services;\n@@ -553,7 +562,7 @@ inline namespace v1\n       static_assert(is_base_of<_Key, _Service>::value,\n \t  \"a service type must match or derive from its key_type\");\n       auto __key = execution_context::_S_key<_Key>();\n-      std::lock_guard<std::mutex> __lock(__ctx._M_mutex);\n+      lock_guard<execution_context::mutex_type> __lock(__ctx._M_mutex);\n       auto& __svc = __ctx._M_keys[__key];\n       if (__svc == nullptr)\n \t{\n@@ -577,7 +586,7 @@ inline namespace v1\n       static_assert(is_base_of<_Key, _Service>::value,\n \t  \"a service type must match or derive from its key_type\");\n       auto __key = execution_context::_S_key<_Key>();\n-      std::lock_guard<std::mutex> __lock(__ctx._M_mutex);\n+      lock_guard<execution_context::mutex_type> __lock(__ctx._M_mutex);\n       auto& __svc = __ctx._M_keys[__key];\n       if (__svc != nullptr)\n \tthrow service_already_exists();\n@@ -599,7 +608,7 @@ inline namespace v1\n \t  \"a service type must derive from execution_context::service\");\n       static_assert(is_base_of<_Key, _Service>::value,\n \t  \"a service type must match or derive from its key_type\");\n-      std::lock_guard<std::mutex> __lock(__ctx._M_mutex);\n+      lock_guard<execution_context::mutex_type> __lock(__ctx._M_mutex);\n       return __ctx._M_keys.count(execution_context::_S_key<_Key>());\n     }\n \n@@ -865,20 +874,21 @@ inline namespace v1\n \n     void stop()\n     {\n-      lock_guard<mutex> __lock(_M_mtx);\n+      lock_guard<mutex_type> __lock(_M_mtx);\n       _M_stopped = true;\n       _M_cv.notify_all();\n     }\n \n     bool stopped() const noexcept\n     {\n-      lock_guard<mutex> __lock(_M_mtx);\n+      lock_guard<mutex_type> __lock(_M_mtx);\n       return _M_stopped;\n     }\n \n     void join()\n     {\n-      _M_thread.join();\n+      if (_M_thread.joinable())\n+\t_M_thread.join();\n     }\n \n   private:\n@@ -887,20 +897,33 @@ inline namespace v1\n     struct __tag { explicit __tag() = default; };\n     system_context(__tag) { }\n \n+#ifndef _GLIBCXX_HAS_GTHREADS\n+    struct thread\n+    {\n+      bool joinable() const { return false; }\n+      void join() { }\n+    };\n+    struct condition_variable\n+    {\n+      void notify_all() { }\n+    };\n+#endif\n+\n     thread\t\t\t_M_thread;\n-    mutable mutex\t\t_M_mtx;\n+    mutable mutex_type\t\t_M_mtx; // XXX can we reuse base's _M_mutex?\n     condition_variable\t\t_M_cv;\n     queue<function<void()>>\t_M_tasks;\n     bool\t\t\t_M_stopped = false;\n \n+#ifdef _GLIBCXX_HAS_GTHREADS\n     void\n     _M_run()\n     {\n       while (true)\n \t{\n \t  function<void()> __f;\n \t  {\n-\t    unique_lock<mutex> __lock(_M_mtx);\n+\t    unique_lock<mutex_type> __lock(_M_mtx);\n \t    _M_cv.wait(__lock,\n \t\t       [this]{ return _M_stopped || !_M_tasks.empty(); });\n \t    if (_M_stopped)\n@@ -911,17 +934,22 @@ inline namespace v1\n \t  __f();\n \t}\n     }\n+#endif\n \n     void\n-    _M_post(std::function<void()> __f)\n+    _M_post(std::function<void()> __f __attribute__((__unused__)))\n     {\n-      lock_guard<mutex> __lock(_M_mtx);\n+      lock_guard<mutex_type> __lock(_M_mtx);\n       if (_M_stopped)\n \treturn;\n+#ifdef _GLIBCXX_HAS_GTHREADS\n       if (!_M_thread.joinable())\n \t_M_thread = std::thread(&system_context::_M_run, this);\n       _M_tasks.push(std::move(__f)); // XXX allocator not used\n       _M_cv.notify_one();\n+#else\n+      __throw_system_error(EOPNOTSUPP);\n+#endif\n     }\n \n     static system_context&\n@@ -1536,7 +1564,7 @@ inline namespace v1\n \n       bool\n       running_in_this_thread() const noexcept\n-      { return std::this_thread::get_id() == _M_state->_M_running_on; }\n+      { return _M_state->running_in_this_thread(); }\n \n       execution_context&\n       context() const noexcept\n@@ -1572,13 +1600,21 @@ inline namespace v1\n       // TODO add synchronised queue\n       struct _State\n       {\n+#if defined(_GLIBCXX_HAS_GTHREADS)\n+\tbool\n+\trunning_in_this_thread() const\n+\t{ return std::this_thread::get_id() == _M_state->_M_running_on; }\n+\n \tstd::thread::id _M_running_on;\n+#else\n+\tbool running_in_this_thread() const { return true; }\n+#endif\n       };\n       shared_ptr<_State> _M_state;\n       _Executor _M_inner_ex;\n     };\n \n-#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n+#if defined(_GLIBCXX_HAS_GTHREADS)\n \n   // Completion token for asynchronous operations initiated with use_future.\n   template<typename _Func, typename _Alloc>\n@@ -1970,7 +2006,6 @@ inline namespace v1\n   // (probably need to move _Type outside of handler_type so we don't have\n   // a non-deduced context)\n \n-\n #endif\n \n   // [async.packaged.task.specializations]\n@@ -1994,7 +2029,7 @@ inline namespace v1\n       return_type _M_future;\n     };\n \n-#endif\n+#endif // _GLIBCXX_HAS_GTHREADS\n \n   /// @}\n "}, {"sha": "561bd37acbdc290e5297975b353a4abe3192a1a0", "filename": "libstdc++-v3/include/experimental/io_context", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18095be17013444d9e91aa8c73ebe5cf58ccb3f1/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18095be17013444d9e91aa8c73ebe5cf58ccb3f1/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context?ref=18095be17013444d9e91aa8c73ebe5cf58ccb3f1", "patch": "@@ -40,6 +40,7 @@\n #include <functional>\n #include <system_error>\n #include <thread>\n+#include <vector>\n #include <experimental/netfwd>\n #include <experimental/executor>\n #if _GLIBCXX_HAVE_UNISTD_H\n@@ -90,10 +91,14 @@ inline namespace v1\n \n       bool running_in_this_thread() const noexcept\n       {\n-\tlock_guard<mutex> __lock(_M_ctx->_M_mtx);\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+\tlock_guard<execution_context::mutex_type> __lock(_M_ctx->_M_mtx);\n \tauto __end = _M_ctx->_M_call_stack.end();\n \treturn std::find(_M_ctx->_M_call_stack.begin(), __end,\n \t\t\t this_thread::get_id()) != __end;\n+#else\n+\treturn _M_ctx->_M_run_count != 0;\n+#endif\n       }\n \n       io_context& context() const noexcept { return *_M_ctx; }\n@@ -115,7 +120,7 @@ inline namespace v1\n \tvoid\n \tpost(_Func&& __f, const _ProtoAllocator& __a) const\n \t{\n-\t  lock_guard<mutex> __lock(_M_ctx->_M_mtx);\n+\t  lock_guard<execution_context::mutex_type> __lock(_M_ctx->_M_mtx);\n \t  // TODO (re-use functionality in system_context)\n \t  _M_ctx->_M_reactor._M_notify();\n \t}\n@@ -217,14 +222,14 @@ inline namespace v1\n \n     void stop()\n     {\n-      lock_guard<mutex> __lock(_M_mtx);\n+      lock_guard<execution_context::mutex_type> __lock(_M_mtx);\n       _M_stopped = true;\n       _M_reactor._M_notify();\n     }\n \n     bool stopped() const noexcept\n     {\n-      lock_guard<mutex> __lock(_M_mtx);\n+      lock_guard<execution_context::mutex_type> __lock(_M_mtx);\n       return _M_stopped;\n     }\n \n@@ -270,11 +275,11 @@ inline namespace v1\n       __timer_queue_base(execution_context& __ctx) : service(__ctx)\n       {\n \tauto& __ioc = static_cast<io_context&>(__ctx);\n-\tlock_guard<mutex> __lock(__ioc._M_mtx);\n+\tlock_guard<execution_context::mutex_type> __lock(__ioc._M_mtx);\n \t__ioc._M_timers.push_back(this);\n       }\n \n-      mutable mutex\t_M_qmtx;\n+      mutable execution_context::mutex_type _M_qmtx;\n     };\n \n     template<typename _Timer, typename _Key = typename _Timer::_Key>\n@@ -296,7 +301,7 @@ inline namespace v1\n \tpush(const _Timer& __t, function<void(error_code)> __h)\n \t{\n \t  context().get_executor().on_work_started();\n-\t  lock_guard<mutex> __lock(_M_qmtx);\n+\t  lock_guard<execution_context::mutex_type> __lock(_M_qmtx);\n \t  _M_queue.emplace(__t, _M_next_id++, std::move(__h));\n \t  // no need to notify reactor unless this timer went to the front?\n \t}\n@@ -305,7 +310,7 @@ inline namespace v1\n \tsize_t\n \tcancel(const _Timer& __t)\n \t{\n-\t  lock_guard<mutex> __lock(_M_qmtx);\n+\t  lock_guard<execution_context::mutex_type> __lock(_M_qmtx);\n \t  size_t __count = 0;\n \t  auto __last = _M_queue.end();\n \t  for (auto __it = _M_queue.begin(), __end = __last; __it != __end;\n@@ -327,7 +332,7 @@ inline namespace v1\n \tbool\n \tcancel_one(const _Timer& __t)\n \t{\n-\t  lock_guard<mutex> __lock(_M_qmtx);\n+\t  lock_guard<execution_context::mutex_type> __lock(_M_qmtx);\n \t  const auto __end = _M_queue.end();\n \t  auto __oldest = __end;\n \t  for (auto __it = _M_queue.begin(); __it != __end; ++__it)\n@@ -346,7 +351,7 @@ inline namespace v1\n \t{\n \t  typename _Timer::time_point __exp;\n \t  {\n-\t    lock_guard<mutex> __lock(_M_qmtx);\n+\t    lock_guard<execution_context::mutex_type> __lock(_M_qmtx);\n \t    if (_M_queue.empty())\n \t      return chrono::milliseconds::max();  // no pending timers\n \t    if (_M_queue.top()._M_key == nullptr)\n@@ -367,7 +372,7 @@ inline namespace v1\n \t  function<void(error_code)> __h;\n \t  error_code __ec;\n \t  {\n-\t    lock_guard<mutex> __lock(_M_qmtx);\n+\t    lock_guard<execution_context::mutex_type> __lock(_M_qmtx);\n \n \t    if (_M_queue.top()._M_key == nullptr) // cancelled\n \t      {\n@@ -474,7 +479,7 @@ inline namespace v1\n       void\n       async_wait(int __fd, int __w, _Op&& __op)\n       {\n-\tlock_guard<mutex> __lock(_M_mtx);\n+\tlock_guard<execution_context::mutex_type> __lock(_M_mtx);\n \t// TODO need push_back, use std::list not std::forward_list\n \tauto __tail = _M_ops.before_begin(), __it = _M_ops.begin();\n \twhile (__it != _M_ops.end())\n@@ -493,7 +498,7 @@ inline namespace v1\n \n     void cancel(int __fd, error_code&)\n     {\n-      lock_guard<mutex> __lock(_M_mtx);\n+      lock_guard<execution_context::mutex_type> __lock(_M_mtx);\n       const auto __end = _M_ops.end();\n       auto __it = _M_ops.begin();\n       auto __prev = _M_ops.before_begin();\n@@ -553,22 +558,30 @@ inline namespace v1\n       };\n \n     atomic<count_type>\t\t_M_work_count;\n-    mutable mutex\t\t_M_mtx;\n+    mutable execution_context::mutex_type\t\t_M_mtx;\n     queue<function<void()>>\t_M_op;\n     bool\t\t\t_M_stopped = false;\n \n     struct __monitor\n     {\n       __monitor(io_context& __c) : _M_ctx(__c)\n       {\n-\tlock_guard<mutex> __lock(_M_ctx._M_mtx);\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+\tlock_guard<execution_context::mutex_type> __lock(_M_ctx._M_mtx);\n \t_M_ctx._M_call_stack.push_back(this_thread::get_id());\n+#else\n+\t_M_ctx._M_run_count++;\n+#endif\n       }\n \n       ~__monitor()\n       {\n-\tlock_guard<mutex> __lock(_M_ctx._M_mtx);\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+\tlock_guard<execution_context::mutex_type> __lock(_M_ctx._M_mtx);\n \t_M_ctx._M_call_stack.pop_back();\n+#else\n+\t_M_ctx._M_run_count--;\n+#endif\n \tif (_M_ctx._M_outstanding_work() == 0)\n \t  {\n \t    _M_ctx._M_stopped = true;\n@@ -613,7 +626,7 @@ inline namespace v1\n \t  chrono::milliseconds __ms{0};\n \n \t  {\n-\t    lock_guard<mutex> __lock(_M_mtx);\n+\t    lock_guard<execution_context::mutex_type> __lock(_M_mtx);\n \n \t    if (_M_stopped)\n \t      return false;\n@@ -677,7 +690,7 @@ inline namespace v1\n \t  if (__fds.empty()) // nothing to do\n \t    return false;\n \n-\t  lock_guard<mutex> __lock(_M_mtx);\n+\t  lock_guard<execution_context::mutex_type> __lock(_M_mtx);\n \t  for (auto __it = _M_ops.begin(), __end = _M_ops.end(),\n \t      __prev = _M_ops.before_begin(); __it != __end; ++__it, ++__prev)\n \t    {\n@@ -839,7 +852,11 @@ inline namespace v1\n     vector<__timer_queue_base*>\t\t\t_M_timers;\n     forward_list<unique_ptr<__async_operation>>\t_M_ops;\n \n+#ifdef _GLIBCXX_HAS_GTHREADS\n     vector<thread::id>\t_M_call_stack;\n+#else\n+    int _M_run_count = 0;\n+#endif\n   };\n \n   inline bool"}, {"sha": "2a3af881db5f70c68eef5c019252d29372c49c87", "filename": "libstdc++-v3/testsuite/experimental/net/execution_context/use_service.cc", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18095be17013444d9e91aa8c73ebe5cf58ccb3f1/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecution_context%2Fuse_service.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18095be17013444d9e91aa8c73ebe5cf58ccb3f1/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecution_context%2Fuse_service.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecution_context%2Fuse_service.cc?ref=18095be17013444d9e91aa8c73ebe5cf58ccb3f1", "patch": "@@ -15,11 +15,8 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-do run }\n-// { dg-options \"-pthread\"  }\n-// { dg-require-effective-target c++14 }\n-// { dg-require-effective-target pthread }\n-// { dg-require-gthreads \"\" }\n+// { dg-do run { target c++14 } }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n \n #include <experimental/executor>\n #include <testsuite_hooks.h>"}]}