{"sha": "33fbbb766cde302f16aca2208e25610c11484388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNmYmJiNzY2Y2RlMzAyZjE2YWNhMjIwOGUyNTYxMGMxMTQ4NDM4OA==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-08-27T02:49:22Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-08-27T02:49:22Z"}, "message": "Makefile.am: Add regex_scanner.{h,tcc}.\n\n2013-08-26  Tim Shen  <timshen91@gmail.com>\n\n\t* include/Makefile.am: Add regex_scanner.{h,tcc}.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/regex.h (match_search): Handle the `__first == __last`\n\t  situation correctly.\n\t* include/bits/regex_compiler.h: Move _Scanner...\n\t* include/bits/regex_scanner.h: ...to here. New.\n\t* include/bits/regex_compiler.tcc: Move _Scanner...\n\t* include/bits/regex_scanner.tcc: ...to here, too. New.\n\t* include/bits/regex_executor.tcc: Use value instead of reference for\n\t  submatch.\n\t* include/std/regex: Add regex_scanner.h\n\t* testsuite/28_regex/algorithms/regex_match/awk/cstring_01.cc: New.\n\t* testsuite/28_regex/algorithms/regex_match/basic/empty_range.cc: New.\n\t* testsuite/28_regex/algorithms/regex_match/ecma/cstring_hex.cc: New.\n\t* testsuite/28_regex/algorithms/regex_match/ecma/empty_range.cc: New.\n\t* testsuite/28_regex/algorithms/regex_search/ecma/string_01.cc: New.\n\nFrom-SVN: r202015", "tree": {"sha": "2152998d3b362b24cc7f901c04a1249d8fe40c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2152998d3b362b24cc7f901c04a1249d8fe40c68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33fbbb766cde302f16aca2208e25610c11484388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33fbbb766cde302f16aca2208e25610c11484388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33fbbb766cde302f16aca2208e25610c11484388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33fbbb766cde302f16aca2208e25610c11484388/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd91cfe3e0a62ff045811a6dc2fcce2930eef0b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd91cfe3e0a62ff045811a6dc2fcce2930eef0b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd91cfe3e0a62ff045811a6dc2fcce2930eef0b3"}], "stats": {"total": 2079, "additions": 1289, "deletions": 790}, "files": [{"sha": "866156686d379aed7c3395dc37df5a97dedb655a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -1,3 +1,22 @@\n+2013-08-26  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/Makefile.am: Add regex_scanner.{h,tcc}.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/regex.h (match_search): Handle the `__first == __last`\n+\t  situation correctly.\n+\t* include/bits/regex_compiler.h: Move _Scanner...\n+\t* include/bits/regex_scanner.h: ...to here. New.\n+\t* include/bits/regex_compiler.tcc: Move _Scanner...\n+\t* include/bits/regex_scanner.tcc: ...to here, too. New.\n+\t* include/bits/regex_executor.tcc: Use value instead of reference for\n+\t  submatch.\n+\t* include/std/regex: Add regex_scanner.h\n+\t* testsuite/28_regex/algorithms/regex_match/awk/cstring_01.cc: New.\n+\t* testsuite/28_regex/algorithms/regex_match/basic/empty_range.cc: New.\n+\t* testsuite/28_regex/algorithms/regex_match/ecma/cstring_hex.cc: New.\n+\t* testsuite/28_regex/algorithms/regex_match/ecma/empty_range.cc: New.\n+\t* testsuite/28_regex/algorithms/regex_search/ecma/string_01.cc: New.\n+\n 2013-08-22  Tim Shen  <timshen91@gmail.com>\n \n \t* include/bits/regex.h: Replace 8 spaces in indentation with a tab."}, {"sha": "0bceb5776a5e1712f6593fd5474a1e9f2c7486d2", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -128,6 +128,8 @@ bits_headers = \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex_constants.h \\\n \t${bits_srcdir}/regex_error.h \\\n+\t${bits_srcdir}/regex_scanner.h \\\n+\t${bits_srcdir}/regex_scanner.tcc \\\n \t${bits_srcdir}/regex_automaton.h \\\n \t${bits_srcdir}/regex_automaton.tcc \\\n \t${bits_srcdir}/regex_compiler.h \\"}, {"sha": "b160639701387b943128e52d97f959bd0ecb9d54", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -395,6 +395,8 @@ bits_headers = \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex_constants.h \\\n \t${bits_srcdir}/regex_error.h \\\n+\t${bits_srcdir}/regex_scanner.h \\\n+\t${bits_srcdir}/regex_scanner.tcc \\\n \t${bits_srcdir}/regex_automaton.h \\\n \t${bits_srcdir}/regex_automaton.tcc \\\n \t${bits_srcdir}/regex_compiler.h \\"}, {"sha": "48388198ce0ad0f75541d67123bc3090ad8d1069", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -740,11 +740,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @throws regex_error if @p [__first, __last) is not a valid regular\n        *         expression.\n        */\n-      template<typename _InputIterator>\n-\tbasic_regex(_InputIterator __first, _InputIterator __last,\n+      template<typename _FwdIter>\n+\tbasic_regex(_FwdIter __first, _FwdIter __last,\n \t\t    flag_type __f = ECMAScript)\n \t: _M_flags(__f),\n-\t  _M_automaton(__detail::_Compiler<_InputIterator, _Ch_type, _Rx_traits>\n+\t  _M_automaton(__detail::_Compiler<_FwdIter, _Ch_type, _Rx_traits>\n \t\t       (__first, __last, _M_traits, _M_flags)._M_get_nfa())\n \t{ }\n \n@@ -2371,7 +2371,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (__re._M_automaton == nullptr)\n \treturn false;\n-      for (auto __cur = __first; __cur != __last; ++__cur) // Any KMP-like algo?\n+      auto __cur = __first;\n+      // Continue when __cur == __last\n+      do\n \t{\n \t  __detail::__get_executor(__cur, __last, __m, __re, __flags)\n \t    ->_M_search_from_first();\n@@ -2391,10 +2393,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      return true;\n \t    }\n \t}\n+      while (__cur++ != __last);\n       return false;\n     }\n \n-\n   /**\n    * Searches for a regular expression within a range.\n    * @param __first [IN]  The start of the string to search."}, {"sha": "1d588b91df8b376c7100b6facb2b30f49a1a497a", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 103, "deletions": 192, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -39,213 +39,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-  /// Matches a character range (bracket expression)\n   template<typename _CharT, typename _TraitsT>\n-    struct _BracketMatcher\n-    {\n-      typedef typename _TraitsT::char_class_type  _CharClassT;\n-      typedef typename _TraitsT::string_type      _StringT;\n-      typedef regex_constants::syntax_option_type _FlagT;\n-\n-      explicit\n-      _BracketMatcher(bool __is_non_matching,\n-\t\t      const _TraitsT& __t,\n-\t\t      _FlagT __flags)\n-      : _M_is_non_matching(__is_non_matching), _M_traits(__t),\n-\t_M_flags(__flags), _M_class_set(0)\n-      { }\n-\n-      bool\n-      operator()(_CharT) const;\n-\n-      void\n-      _M_add_char(_CharT __c)\n-      {\n-\tif (_M_flags & regex_constants::collate)\n-\t  if (_M_is_icase())\n-\t    _M_char_set.push_back(_M_traits.translate_nocase(__c));\n-\t  else\n-\t    _M_char_set.push_back(_M_traits.translate(__c));\n-\telse\n-\t  _M_char_set.push_back(__c);\n-      }\n-\n-      void\n-      _M_add_collating_element(const _StringT& __s)\n-      {\n-\tauto __st = _M_traits.lookup_collatename(&*__s.begin(), &*__s.end());\n-\tif (__st.empty())\n-\t  __throw_regex_error(regex_constants::error_collate);\n-\t// TODO: digraph\n-\t_M_char_set.push_back(__st[0]);\n-      }\n-\n-      void\n-      _M_add_equivalence_class(const _StringT& __s)\n-      {\n-\t_M_add_character_class(\n-\t  _M_traits.transform_primary(&*__s.begin(), &*__s.end()));\n-      }\n-\n-      void\n-      _M_add_character_class(const _StringT& __s)\n-      {\n-\tauto __st = _M_traits.\n-\t  lookup_classname(&*__s.begin(), &*__s.end(), _M_is_icase());\n-\tif (__st == 0)\n-\t  __throw_regex_error(regex_constants::error_ctype);\n-\t_M_class_set |= __st;\n-      }\n-\n-      void\n-      _M_make_range(_CharT __l, _CharT __r)\n-      { _M_range_set.push_back(make_pair(_M_get_str(__l), _M_get_str(__r))); }\n-\n-      bool\n-      _M_is_icase() const\n-      { return _M_flags & regex_constants::icase; }\n-\n-      _StringT\n-      _M_get_str(_CharT __c) const\n-      {\n-\tauto __s = _StringT(1,\n-\t\t\t    _M_is_icase()\n-\t\t\t    ? _M_traits.translate_nocase(__c)\n-\t\t\t    : _M_traits.translate(__c));\n-\treturn _M_traits.transform(__s.begin(), __s.end());\n-      }\n-\n-      _TraitsT                              _M_traits;\n-      _FlagT                                _M_flags;\n-      bool                                  _M_is_non_matching;\n-      std::vector<_CharT>                   _M_char_set;\n-      std::vector<pair<_StringT, _StringT>> _M_range_set;\n-      _CharClassT                           _M_class_set;\n-    };\n-\n-  /**\n-   * @brief struct _Scanner. Scans an input range for regex tokens.\n-   *\n-   * The %_Scanner class interprets the regular expression pattern in\n-   * the input range passed to its constructor as a sequence of parse\n-   * tokens passed to the regular expression compiler.  The sequence\n-   * of tokens provided depends on the flag settings passed to the\n-   * constructor: different regular expression grammars will interpret\n-   * the same input pattern in syntactically different ways.\n-   */\n-  template<typename _InputIter>\n-    class _Scanner\n-    {\n-    public:\n-      typedef unsigned int                                          _StateT;\n-      typedef typename std::iterator_traits<_InputIter>::value_type _CharT;\n-      typedef std::basic_string<_CharT>                             _StringT;\n-      typedef regex_constants::syntax_option_type                   _FlagT;\n-      typedef const std::ctype<_CharT>                              _CtypeT;\n-\n-      /// Token types returned from the scanner.\n-      enum _TokenT\n-      {\n-\t_S_token_anychar,\n-\t_S_token_backref,\n-\t_S_token_bracket_begin,\n-\t_S_token_bracket_inverse_begin,\n-\t_S_token_bracket_end,\n-\t_S_token_char_class_name,\n-\t_S_token_closure0,\n-\t_S_token_closure1,\n-\t_S_token_collelem_multi,\n-\t_S_token_collelem_single,\n-\t_S_token_collsymbol,\n-\t_S_token_comma,\n-\t_S_token_dash,\n-\t_S_token_dup_count,\n-\t_S_token_eof,\n-\t_S_token_equiv_class_name,\n-\t_S_token_interval_begin,\n-\t_S_token_interval_end,\n-\t_S_token_line_begin,\n-\t_S_token_line_end,\n-\t_S_token_opt,\n-\t_S_token_or,\n-\t_S_token_ord_char,\n-\t_S_token_subexpr_begin,\n-\t_S_token_subexpr_end,\n-\t_S_token_word_begin,\n-\t_S_token_word_end,\n-\t_S_token_unknown\n-      };\n-\n-      _Scanner(_InputIter __begin, _InputIter __end,\n-\t       _FlagT __flags, std::locale __loc)\n-      : _M_current(__begin) , _M_end(__end) , _M_flags(__flags),\n-\t_M_ctype(std::use_facet<_CtypeT>(__loc)), _M_state(0)\n-      { _M_advance(); }\n-\n-      void\n-      _M_advance();\n-\n-      _TokenT\n-      _M_token() const\n-      { return _M_curToken; }\n-\n-      const _StringT&\n-      _M_value() const\n-      { return _M_curValue; }\n-\n-#ifdef _GLIBCXX_DEBUG\n-      std::ostream&\n-      _M_print(std::ostream&);\n-#endif\n-\n-    private:\n-      void\n-      _M_eat_escape();\n-\n-      void\n-      _M_scan_in_brace();\n-\n-      void\n-      _M_scan_in_bracket();\n-\n-      void\n-      _M_eat_charclass();\n-\n-      void\n-      _M_eat_equivclass();\n-\n-      void\n-      _M_eat_collsymbol();\n-\n-      static constexpr _StateT _S_state_in_brace    = 1 << 0;\n-      static constexpr _StateT _S_state_in_bracket  = 1 << 1;\n-      _InputIter  _M_current;\n-      _InputIter  _M_end;\n-      _FlagT      _M_flags;\n-      _CtypeT&    _M_ctype;\n-      _TokenT     _M_curToken;\n-      _StringT    _M_curValue;\n-      _StateT     _M_state;\n-    };\n+    struct _BracketMatcher;\n \n   /// Builds an NFA from an input iterator interval.\n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     class _Compiler\n     {\n     public:\n       typedef typename _TraitsT::string_type      _StringT;\n       typedef _NFA<_CharT, _TraitsT>              _RegexT;\n       typedef regex_constants::syntax_option_type _FlagT;\n \n-      _Compiler(_InputIter __b, _InputIter __e,\n+      _Compiler(_FwdIter __b, _FwdIter __e,\n \t\tconst _TraitsT& __traits, _FlagT __flags);\n \n       std::shared_ptr<_RegexT>\n       _M_get_nfa() const\n       { return std::shared_ptr<_RegexT>(new _RegexT(_M_state_store)); }\n \n     private:\n-      typedef _Scanner<_InputIter>                            _ScannerT;\n+      typedef _Scanner<_FwdIter>                              _ScannerT;\n       typedef typename _ScannerT::_TokenT                     _TokenT;\n       typedef _StateSeq<_CharT, _TraitsT>                     _StateSeqT;\n       typedef std::stack<_StateSeqT, std::vector<_StateSeqT>> _StackT;\n@@ -276,7 +90,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_bracket_expression();\n \n-      bool\n+      void\n       _M_bracket_list(_BMatcherT& __matcher);\n \n       bool\n@@ -303,14 +117,111 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       int\n       _M_cur_int_value(int __radix);\n \n+      bool\n+      _M_try_char();\n+\n+      _CharT\n+      _M_get_char();\n+\n       const _TraitsT& _M_traits;\n       _ScannerT       _M_scanner;\n-      _StringT        _M_cur_value;\n+      _StringT        _M_value;\n       _RegexT         _M_state_store;\n       _StackT         _M_stack;\n       _FlagT          _M_flags;\n     };\n \n+  /// Matches a character range (bracket expression)\n+  template<typename _CharT, typename _TraitsT>\n+    struct _BracketMatcher\n+    {\n+      typedef typename _TraitsT::char_class_type  _CharClassT;\n+      typedef typename _TraitsT::string_type      _StringT;\n+      typedef regex_constants::syntax_option_type _FlagT;\n+\n+      explicit\n+      _BracketMatcher(bool __is_non_matching,\n+\t\t      const _TraitsT& __t,\n+\t\t      _FlagT __flags)\n+      : _M_is_non_matching(__is_non_matching), _M_traits(__t),\n+\t_M_flags(__flags), _M_class_set(0)\n+      { }\n+\n+      bool\n+      operator()(_CharT) const;\n+\n+      void\n+      _M_add_char(_CharT __c)\n+      { _M_char_set.push_back(_M_translate(__c)); }\n+\n+      void\n+      _M_add_collating_element(const _StringT& __s)\n+      {\n+\tauto __st = _M_traits.lookup_collatename(__s.data(),\n+\t\t\t\t\t\t __s.data() + __s.size());\n+\tif (__st.empty())\n+\t  __throw_regex_error(regex_constants::error_collate);\n+\t// TODO: digraph\n+\t_M_char_set.push_back(__st[0]);\n+      }\n+\n+      void\n+      _M_add_equivalence_class(const _StringT& __s)\n+      {\n+\t_M_add_character_class(\n+\t  _M_traits.transform_primary(__s.data(),\n+\t\t\t\t      __s.data() + __s.size()));\n+      }\n+\n+      void\n+      _M_add_character_class(const _StringT& __s)\n+      {\n+\tauto __st = _M_traits.\n+\t  lookup_classname(__s.data(), __s.data() + __s.size(), _M_is_icase());\n+\tif (__st == 0)\n+\t  __throw_regex_error(regex_constants::error_ctype);\n+\t_M_class_set |= __st;\n+      }\n+\n+      void\n+      _M_make_range(_CharT __l, _CharT __r)\n+      {\n+\t_M_range_set.push_back(\n+\t  make_pair(_M_get_str(_M_translate(__l)),\n+\t\t    _M_get_str(_M_translate(__r))));\n+      }\n+\n+      _CharT\n+      _M_translate(_CharT __c) const\n+      {\n+\tif (_M_flags & regex_constants::collate)\n+\t  if (_M_is_icase())\n+\t    return _M_traits.translate_nocase(__c);\n+\t  else\n+\t    return _M_traits.translate(__c);\n+\telse\n+\t  return __c;\n+      }\n+\n+      bool\n+      _M_is_icase() const\n+      { return _M_flags & regex_constants::icase; }\n+\n+      _StringT\n+      _M_get_str(_CharT __c) const\n+      {\n+\t_StringT __s(1, __c);\n+\treturn _M_traits.transform(__s.begin(), __s.end());\n+      }\n+\n+      _TraitsT                              _M_traits;\n+      _FlagT                                _M_flags;\n+      bool                                  _M_is_non_matching;\n+      std::vector<_CharT>                   _M_char_set;\n+      std::vector<pair<_StringT, _StringT>> _M_range_set;\n+      _CharClassT                           _M_class_set;\n+    };\n+\n  //@} regex-detail\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail"}, {"sha": "bed091a4486deb5bbfb2db51f6236c21ef7e7b70", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 101, "deletions": 592, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -34,506 +34,15 @@ namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  template<typename _BiIter>\n-    void\n-    _Scanner<_BiIter>::\n-    _M_advance()\n-    {\n-      if (_M_current == _M_end)\n-\t{\n-\t  _M_curToken = _S_token_eof;\n-\t  return;\n-\t}\n-\n-      _CharT __c = *_M_current;\n-      if (_M_state & _S_state_in_bracket)\n-\t{\n-\t  _M_scan_in_bracket();\n-\t  return;\n-\t}\n-      if (_M_state & _S_state_in_brace)\n-\t{\n-\t  _M_scan_in_brace();\n-\t  return;\n-\t}\n-#if 0\n-      // TODO: re-enable line anchors when _M_assertion is implemented.\n-      // See PR libstdc++/47724\n-      else if (_M_state & _S_state_at_start && __c == _M_ctype.widen('^'))\n-\t{\n-\t  _M_curToken = _S_token_line_begin;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('$'))\n-\t{\n-\t  _M_curToken = _S_token_line_end;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-#endif\n-      else if (__c == _M_ctype.widen('.'))\n-\t{\n-\t  _M_curToken = _S_token_anychar;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('*'))\n-\t{\n-\t  _M_curToken = _S_token_closure0;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('+'))\n-\t{\n-\t  _M_curToken = _S_token_closure1;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('|'))\n-\t{\n-\t  _M_curToken = _S_token_or;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('['))\n-\t{\n-\t  if (*++_M_current == _M_ctype.widen('^'))\n-\t    {\n-\t      _M_curToken = _S_token_bracket_inverse_begin;\n-\t      ++_M_current;\n-\t    }\n-\t  else\n-\t    _M_curToken = _S_token_bracket_begin;\n-\t  _M_state |= _S_state_in_bracket;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('\\\\'))\n-\t{\n-\t  _M_eat_escape();\n-\t  return;\n-\t}\n-      else if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t{\n-\t  if (__c == _M_ctype.widen('('))\n-\t    {\n-\t      _M_curToken = _S_token_subexpr_begin;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n-\t  else if (__c == _M_ctype.widen(')'))\n-\t    {\n-\t      _M_curToken = _S_token_subexpr_end;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n-\t  else if (__c == _M_ctype.widen('{'))\n-\t    {\n-\t      _M_curToken = _S_token_interval_begin;\n-\t      _M_state |= _S_state_in_brace;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n-\t}\n-\n-      _M_curToken = _S_token_ord_char;\n-      _M_curValue.assign(1, __c);\n-      ++_M_current;\n-    }\n-\n-  template<typename _BiIter>\n-    void\n-    _Scanner<_BiIter>::\n-    _M_scan_in_brace()\n-    {\n-      if (_M_ctype.is(_CtypeT::digit, *_M_current))\n-\t{\n-\t  _M_curToken = _S_token_dup_count;\n-\t  _M_curValue.assign(1, *_M_current);\n-\t  ++_M_current;\n-\t  while (_M_current != _M_end\n-\t\t && _M_ctype.is(_CtypeT::digit, *_M_current))\n-\t    {\n-\t      _M_curValue += *_M_current;\n-\t      ++_M_current;\n-\t    }\n-\t  return;\n-\t}\n-      else if (*_M_current == _M_ctype.widen(','))\n-\t{\n-\t  _M_curToken = _S_token_comma;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      if (_M_flags & (regex_constants::basic | regex_constants::grep))\n-\t{\n-\t  if (*_M_current == _M_ctype.widen('\\\\'))\n-\t    _M_eat_escape();\n-\t}\n-      else\n-\t{\n-\t  if (*_M_current == _M_ctype.widen('}'))\n-\t    {\n-\t      _M_curToken = _S_token_interval_end;\n-\t      _M_state &= ~_S_state_in_brace;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  template<typename _BiIter>\n-    void\n-    _Scanner<_BiIter>::\n-    _M_scan_in_bracket()\n-    {\n-      if (*_M_current == _M_ctype.widen('['))\n-\t{\n-\t  ++_M_current;\n-\t  if (_M_current == _M_end)\n-\t    {\n-\t      _M_curToken = _S_token_eof;\n-\t      return;\n-\t    }\n-\n-\t  if (*_M_current == _M_ctype.widen('.'))\n-\t    {\n-\t      _M_curToken = _S_token_collsymbol;\n-\t      _M_eat_collsymbol();\n-\t      return;\n-\t    }\n-\t  else if (*_M_current == _M_ctype.widen(':'))\n-\t    {\n-\t      _M_curToken = _S_token_char_class_name;\n-\t      _M_eat_charclass();\n-\t      return;\n-\t    }\n-\t  else if (*_M_current == _M_ctype.widen('='))\n-\t    {\n-\t      _M_curToken = _S_token_equiv_class_name;\n-\t      _M_eat_equivclass();\n-\t      return;\n-\t    }\n-\t}\n-      else if (*_M_current == _M_ctype.widen('-'))\n-\t{\n-\t  _M_curToken = _S_token_dash;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (*_M_current == _M_ctype.widen(']'))\n-\t{\n-\t  _M_curToken = _S_token_bracket_end;\n-\t  _M_state &= ~_S_state_in_bracket;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (*_M_current == _M_ctype.widen('\\\\'))\n-\t{\n-\t  _M_eat_escape();\n-\t  return;\n-\t}\n-      _M_curToken = _S_token_collelem_single;\n-      _M_curValue.assign(1, *_M_current);\n-      ++_M_current;\n-    }\n-\n-  // TODO Complete it.\n-  template<typename _BiIter>\n-    void\n-    _Scanner<_BiIter>::\n-    _M_eat_escape()\n-    {\n-      ++_M_current;\n-      if (_M_current == _M_end)\n-\t{\n-\t  _M_curToken = _S_token_eof;\n-\t  return;\n-\t}\n-      _CharT __c = *_M_current;\n-      ++_M_current;\n-\n-      if (__c == _M_ctype.widen('('))\n-\t{\n-\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else\n-\t    _M_curToken = _S_token_subexpr_begin;\n-\t}\n-      else if (__c == _M_ctype.widen(')'))\n-\t{\n-\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else\n-\t    _M_curToken = _S_token_subexpr_end;\n-\t}\n-      else if (__c == _M_ctype.widen('{'))\n-\t{\n-\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else\n-\t    {\n-\t      _M_curToken = _S_token_interval_begin;\n-\t      _M_state |= _S_state_in_brace;\n-\t    }\n-\t}\n-      else if (__c == _M_ctype.widen('}'))\n-\t{\n-\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (!(_M_state && _S_state_in_brace))\n-\t\t__throw_regex_error(regex_constants::error_badbrace);\n-\t      _M_state &= ~_S_state_in_brace;\n-\t      _M_curToken = _S_token_interval_end;\n-\t    }\n-\t}\n-      else if (__c == _M_ctype.widen('x'))\n-\t{\n-\t  ++_M_current;\n-\t  if (_M_current == _M_end)\n-\t    {\n-\t      _M_curToken = _S_token_eof;\n-\t      return;\n-\t    }\n-\t  if (_M_ctype.is(_CtypeT::digit, *_M_current))\n-\t    {\n-\t      _M_curValue.assign(1, *_M_current);\n-\t      ++_M_current;\n-\t      if (_M_current == _M_end)\n-\t\t{\n-\t\t  _M_curToken = _S_token_eof;\n-\t\t  return;\n-\t\t}\n-\t      if (_M_ctype.is(_CtypeT::digit, *_M_current))\n-\t\t{\n-\t\t  _M_curValue += *_M_current;\n-\t\t  ++_M_current;\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n-      else if (__c == _M_ctype.widen('^')\n-\t       || __c == _M_ctype.widen('.')\n-\t       || __c == _M_ctype.widen('*')\n-\t       || __c == _M_ctype.widen('$')\n-\t       || __c == _M_ctype.widen('\\\\'))\n-\t{\n-\t  _M_curToken = _S_token_ord_char;\n-\t  _M_curValue.assign(1, __c);\n-\t}\n-      else if (_M_ctype.is(_CtypeT::digit, __c))\n-\t{\n-\t  _M_curToken = _S_token_backref;\n-\t  _M_curValue.assign(1, __c);\n-\t}\n-      else if (_M_state & _S_state_in_bracket)\n-\t{\n-\t  if (__c == _M_ctype.widen('-')\n-\t      || __c == _M_ctype.widen('[')\n-\t      || __c == _M_ctype.widen(']'))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else if ((_M_flags & regex_constants::ECMAScript)\n-\t\t   && __c == _M_ctype.widen('b'))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, _M_ctype.widen(' '));\n-\t    }\n-\t  else\n-\t    __throw_regex_error(regex_constants::error_escape);\n-\t}\n-      else\n-\t__throw_regex_error(regex_constants::error_escape);\n-    }\n-\n-  // Eats a character class or throwns an exception.\n-  // current point to ':' delimiter on entry, char after ']' on return\n-  template<typename _BiIter>\n-    void\n-    _Scanner<_BiIter>::\n-    _M_eat_charclass()\n-    {\n-      ++_M_current; // skip ':'\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_ctype);\n-      for (_M_curValue.clear();\n-\t   _M_current != _M_end && *_M_current != _M_ctype.widen(':');\n-\t   ++_M_current)\n-\t_M_curValue += *_M_current;\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_ctype);\n-      ++_M_current; // skip ':'\n-      if (*_M_current != _M_ctype.widen(']'))\n-\t__throw_regex_error(regex_constants::error_ctype);\n-      ++_M_current; // skip ']'\n-    }\n-\n-\n-  template<typename _BiIter>\n-    void\n-    _Scanner<_BiIter>::\n-    _M_eat_equivclass()\n-    {\n-      ++_M_current; // skip '='\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_collate);\n-      for (_M_curValue.clear();\n-\t   _M_current != _M_end && *_M_current != _M_ctype.widen('=');\n-\t   ++_M_current)\n-\t_M_curValue += *_M_current;\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_collate);\n-      ++_M_current; // skip '='\n-      if (*_M_current != _M_ctype.widen(']'))\n-\t__throw_regex_error(regex_constants::error_collate);\n-      ++_M_current; // skip ']'\n-    }\n-\n-\n-  template<typename _BiIter>\n-    void\n-    _Scanner<_BiIter>::\n-    _M_eat_collsymbol()\n-    {\n-      ++_M_current; // skip '.'\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_collate);\n-      for (_M_curValue.clear();\n-\t   _M_current != _M_end && *_M_current != _M_ctype.widen('.');\n-\t   ++_M_current)\n-\t_M_curValue += *_M_current;\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_collate);\n-      ++_M_current; // skip '.'\n-      if (*_M_current != _M_ctype.widen(']'))\n-\t__throw_regex_error(regex_constants::error_collate);\n-      ++_M_current; // skip ']'\n-    }\n-\n-#ifdef _GLIBCXX_DEBUG\n-  template<typename _BiIter>\n-    std::ostream&\n-    _Scanner<_BiIter>::\n-    _M_print(std::ostream& ostr)\n-    {\n-      switch (_M_curToken)\n-      {\n-\tcase _S_token_anychar:\n-\t  ostr << \"any-character\\n\";\n-\t  break;\n-\tcase _S_token_backref:\n-\t  ostr << \"backref\\n\";\n-\t  break;\n-\tcase _S_token_bracket_begin:\n-\t  ostr << \"bracket-begin\\n\";\n-\t  break;\n-\tcase _S_token_bracket_inverse_begin:\n-\t  ostr << \"bracket-inverse-begin\\n\";\n-\t  break;\n-\tcase _S_token_bracket_end:\n-\t  ostr << \"bracket-end\\n\";\n-\t  break;\n-\tcase _S_token_char_class_name:\n-\t  ostr << \"char-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_closure0:\n-\t  ostr << \"closure0\\n\";\n-\t  break;\n-\tcase _S_token_closure1:\n-\t  ostr << \"closure1\\n\";\n-\t  break;\n-\tcase _S_token_collelem_multi:\n-\t  ostr << \"coll-elem-multi \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_collelem_single:\n-\t  ostr << \"coll-elem-single \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_collsymbol:\n-\t  ostr << \"collsymbol \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_comma:\n-\t  ostr << \"comma\\n\";\n-\t  break;\n-\tcase _S_token_dash:\n-\t  ostr << \"dash\\n\";\n-\t  break;\n-\tcase _S_token_dup_count:\n-\t  ostr << \"dup count: \" << _M_curValue << \"\\n\";\n-\t  break;\n-\tcase _S_token_eof:\n-\t  ostr << \"EOF\\n\";\n-\t  break;\n-\tcase _S_token_equiv_class_name:\n-\t  ostr << \"equiv-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_interval_begin:\n-\t  ostr << \"interval begin\\n\";\n-\t  break;\n-\tcase _S_token_interval_end:\n-\t  ostr << \"interval end\\n\";\n-\t  break;\n-\tcase _S_token_line_begin:\n-\t  ostr << \"line begin\\n\";\n-\t  break;\n-\tcase _S_token_line_end:\n-\t  ostr << \"line end\\n\";\n-\t  break;\n-\tcase _S_token_opt:\n-\t  ostr << \"opt\\n\";\n-\t  break;\n-\tcase _S_token_or:\n-\t  ostr << \"or\\n\";\n-\t  break;\n-\tcase _S_token_ord_char:\n-\t  ostr << \"ordinary character: \\\"\" << _M_value() << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_subexpr_begin:\n-\t  ostr << \"subexpr begin\\n\";\n-\t  break;\n-\tcase _S_token_subexpr_end:\n-\t  ostr << \"subexpr end\\n\";\n-\t  break;\n-\tcase _S_token_word_begin:\n-\t  ostr << \"word begin\\n\";\n-\t  break;\n-\tcase _S_token_word_end:\n-\t  ostr << \"word end\\n\";\n-\t  break;\n-\tcase _S_token_unknown:\n-\t  ostr << \"-- unknown token --\\n\";\n-\t  break;\n-\tdefault:\n-\t  _GLIBCXX_DEBUG_ASSERT(false);\n-      }\n-      return ostr;\n-    }\n-#endif\n-\n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n-    _Compiler(_InputIter __b, _InputIter __e,\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n+    _Compiler(_FwdIter __b, _FwdIter __e,\n \t      const _TraitsT& __traits, _FlagT __flags)\n     : _M_traits(__traits), _M_scanner(__b, __e, __flags, _M_traits.getloc()),\n       _M_state_store(__flags), _M_flags(__flags)\n     {\n       _StateSeqT __r(_M_state_store,\n-      \t\t    _M_state_store._M_insert_subexpr_begin());\n+\t\t     _M_state_store._M_insert_subexpr_begin());\n       _M_disjunction();\n       if (!_M_stack.empty())\n \t{\n@@ -544,23 +53,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __r._M_append(_M_state_store._M_insert_accept());\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     bool\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n-    _M_match_token(_Compiler<_InputIter, _CharT, _TraitsT>::_TokenT token)\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n+    _M_match_token(_TokenT token)\n     {\n-      if (token == _M_scanner._M_token())\n+      if (token == _M_scanner._M_get_token())\n \t{\n-\t  _M_cur_value = _M_scanner._M_value();\n+\t  _M_value = _M_scanner._M_get_value();\n \t  _M_scanner._M_advance();\n \t  return true;\n \t}\n       return false;\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     void\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_disjunction()\n     {\n       this->_M_alternative();\n@@ -573,9 +82,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     void\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_alternative()\n     {\n       if (this->_M_term())\n@@ -591,9 +100,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     bool\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_term()\n     {\n       if (this->_M_assertion())\n@@ -606,37 +115,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  // TODO Implement it.\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     bool\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_assertion()\n     {\n-      if (_M_match_token(_ScannerT::_S_token_line_begin))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_line_begin);\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_line_end))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_line_end);\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_word_begin))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_word_begin);\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_word_end))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_word_end);\n-\t  return true;\n-\t}\n       return false;\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     void\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_quantifier()\n     {\n       if (_M_match_token(_ScannerT::_S_token_closure0))\n@@ -707,25 +197,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     bool\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_atom()\n     {\n       if (_M_match_token(_ScannerT::_S_token_anychar))\n \t{\n \t  const static auto&\n-\t  __any_matcher = [](_CharT) -> bool\n+\t  __any_matcher = [](_CharT __ch) -> bool\n \t  { return true; };\n \n \t  _M_stack.push(_StateSeqT(_M_state_store,\n \t\t\t\t  _M_state_store._M_insert_matcher\n \t\t\t\t  (__any_matcher)));\n \t  return true;\n \t}\n-      if (_M_match_token(_ScannerT::_S_token_ord_char))\n+      if (_M_try_char())\n \t{\n-\t  auto __c = _M_cur_value[0];\n+\t  _CharT __c = _M_value[0];\n \t  __detail::_Matcher<_CharT> f;\n \t  if (_M_flags & regex_constants::icase)\n \t    {\n@@ -744,7 +234,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       if (_M_match_token(_ScannerT::_S_token_backref))\n \t{\n-\t  // __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n \t  _M_stack.push(_StateSeqT(_M_state_store, _M_state_store.\n \t\t\t\t   _M_insert_backref(_M_cur_int_value(10))));\n \t  return true;\n@@ -770,126 +259,146 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return _M_bracket_expression();\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     bool\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_bracket_expression()\n     {\n-      bool __inverse =\n-\t_M_match_token(_ScannerT::_S_token_bracket_inverse_begin);\n-      if (!(__inverse || _M_match_token(_ScannerT::_S_token_bracket_begin)))\n+      bool __neg =\n+\t_M_match_token(_ScannerT::_S_token_bracket_neg_begin);\n+      if (!(__neg || _M_match_token(_ScannerT::_S_token_bracket_begin)))\n \treturn false;\n-      _BMatcherT __matcher( __inverse, _M_traits, _M_flags);\n-      // special case: only if  _not_ chr first after\n-      // '[' or '[^' or if ECMAscript\n-      if (!_M_bracket_list(__matcher) // list is empty\n-\t  && !(_M_flags & regex_constants::ECMAScript))\n-\t__throw_regex_error(regex_constants::error_brack);\n+      _BMatcherT __matcher(__neg, _M_traits, _M_flags);\n+      _M_bracket_list(__matcher);\n       _M_stack.push(_StateSeqT(_M_state_store,\n \t\t\t      _M_state_store._M_insert_matcher(__matcher)));\n       return true;\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n-    bool // list is non-empty\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n+    void\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_bracket_list(_BMatcherT& __matcher)\n     {\n       if (_M_match_token(_ScannerT::_S_token_bracket_end))\n-\treturn false;\n+\treturn;\n       _M_expression_term(__matcher);\n       _M_bracket_list(__matcher);\n-      return true;\n+      return;\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     void\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_expression_term(_BMatcherT& __matcher)\n     {\n       if (_M_match_token(_ScannerT::_S_token_collsymbol))\n \t{\n-\t  __matcher._M_add_collating_element(_M_cur_value);\n+\t  __matcher._M_add_collating_element(_M_value);\n \t  return;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_equiv_class_name))\n \t{\n-\t  __matcher._M_add_equivalence_class(_M_cur_value);\n+\t  __matcher._M_add_equivalence_class(_M_value);\n \t  return;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_char_class_name))\n \t{\n-\t  __matcher._M_add_character_class(_M_cur_value);\n+\t  __matcher._M_add_character_class(_M_value);\n \t  return;\n \t}\n-      if (_M_match_token(_ScannerT::_S_token_collelem_single)) // [a\n+      if (_M_try_char()) // [a\n \t{\n-\t  auto __ch = _M_cur_value[0];\n-\t  if (_M_match_token(_ScannerT::_S_token_dash)) // [a-\n+\t  auto __ch = _M_value[0];\n+\t  if (_M_try_char())\n \t    {\n-\t      // If the dash is the last character in the bracket expression,\n-\t      // it is not special.\n-\t      if (_M_scanner._M_token() == _ScannerT::_S_token_bracket_end)\n-\t\t__matcher._M_add_char(_M_cur_value[0]); // [a-] <=> [a\\-]\n-\t      else // [a-z]\n+\t      if (_M_value[0] == std::use_facet<std::ctype<_CharT>>\n+\t\t   (_M_traits.getloc()).widen('-')) // [a-\n \t\t{\n-\t\t  if (!_M_match_token(_ScannerT::_S_token_collelem_single))\n+\t\t  if (_M_try_char()) // [a-z]\n+\t\t    {\n+\t\t      __matcher._M_make_range(__ch, _M_value[0]);\n+\t\t      return;\n+\t\t    }\n+\t\t  // If the dash is the last character in the bracket\n+\t\t  // expression, it is not special.\n+\t\t  if (_M_scanner._M_get_token()\n+\t\t      != _ScannerT::_S_token_bracket_end)\n \t\t    __throw_regex_error(regex_constants::error_range);\n-\t\t  __matcher._M_make_range(__ch, _M_cur_value[0]);\n \t\t}\n+\t      __matcher._M_add_char(_M_value[0]);\n \t    }\n-\t  else // [a]\n-\t    __matcher._M_add_char(__ch);\n+\t  __matcher._M_add_char(__ch);\n \t  return;\n \t}\n       __throw_regex_error(regex_constants::error_brack);\n     }\n \n-  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n+    bool\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n+    _M_try_char()\n+    {\n+      bool __is_char = false;\n+      if (_M_match_token(_ScannerT::_S_token_oct_num))\n+\t{\n+\t  __is_char = true;\n+\t  _M_value.assign(1, _M_cur_int_value(8));\n+\t}\n+      else if (_M_match_token(_ScannerT::_S_token_hex_num))\n+\t{\n+\t  __is_char = true;\n+\t  _M_value.assign(1, _M_cur_int_value(16));\n+\t}\n+      else if (_M_match_token(_ScannerT::_S_token_ord_char))\n+\t__is_char = true;\n+      return __is_char;\n+    }\n+\n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     int\n-    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_cur_int_value(int __radix)\n     {\n       int __v = 0;\n       for (typename _StringT::size_type __i = 0;\n-\t   __i < _M_cur_value.length(); ++__i)\n-\t__v =__v * __radix + _M_traits.value(_M_cur_value[__i], __radix);\n+\t   __i < _M_value.length(); ++__i)\n+\t__v =__v * __radix + _M_traits.value(_M_value[__i], __radix);\n       return __v;\n     }\n \n   template<typename _CharT, typename _TraitsT>\n     bool _BracketMatcher<_CharT, _TraitsT>::\n     operator()(_CharT __ch) const\n     {\n-      auto __oldch = __ch;\n-      if (_M_flags & regex_constants::collate)\n-\tif (_M_is_icase())\n-\t  __ch = _M_traits.translate_nocase(__ch);\n-\telse\n-\t  __ch = _M_traits.translate(__ch);\n-\n       bool __ret = false;\n-      for (auto __c : _M_char_set)\n-\tif (__c == __ch)\n-\t  {\n-\t    __ret = true;\n-\t    break;\n-\t  }\n-      if (!__ret && _M_traits.isctype(__oldch, _M_class_set))\n+      if (_M_traits.isctype(__ch, _M_class_set))\n \t__ret = true;\n       else\n \t{\n-\t  _StringT __s = _M_get_str(__ch);\n-\t  for (auto& __it : _M_range_set)\n-\t    if (__it.first <= __s && __s <= __it.second)\n+\t  __ch = _M_translate(__ch);\n+\n+\t  for (auto __c : _M_char_set)\n+\t    if (__c == __ch)\n \t      {\n \t\t__ret = true;\n \t\tbreak;\n \t      }\n+\t  if (!__ret)\n+\t    {\n+\t      _StringT __s = _M_get_str(__ch);\n+\t      for (auto& __it : _M_range_set)\n+\t\tif (__it.first <= __s && __s <= __it.second)\n+\t\t  {\n+\t\t    __ret = true;\n+\t\t    break;\n+\t\t  }\n+\t    }\n \t}\n       if (_M_is_non_matching)\n-\t__ret = !__ret;\n-      return __ret;\n+\treturn !__ret;\n+      else\n+\treturn __ret;\n     }\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "edfd0b649ff78bb7a3bca20bae47f47ecaaa1b8b", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -260,7 +260,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       auto __size = __u.size();\n       for (auto __i = 0; __i < __size; __i++)\n \t{\n-\t  auto& __uit = __u[__i], __vit = __v[__i];\n+\t  auto __uit = __u[__i], __vit = __v[__i];\n \t  if (__uit.matched && !__vit.matched)\n \t    return true;\n \t  if (!__uit.matched && __vit.matched)"}, {"sha": "080ef635b0c24f608b916e382f937e2d31605d10", "filename": "libstdc++-v3/include/bits/regex_scanner.h", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -0,0 +1,194 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ *  @file bits/regex_scanner.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{regex}\n+ */\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace __detail\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @addtogroup regex-detail\n+   * @{\n+   */\n+\n+  /**\n+   * @brief struct _Scanner. Scans an input range for regex tokens.\n+   *\n+   * The %_Scanner class interprets the regular expression pattern in\n+   * the input range passed to its constructor as a sequence of parse\n+   * tokens passed to the regular expression compiler.  The sequence\n+   * of tokens provided depends on the flag settings passed to the\n+   * constructor: different regular expression grammars will interpret\n+   * the same input pattern in syntactically different ways.\n+   */\n+  template<typename _FwdIter>\n+    class _Scanner\n+    {\n+    public:\n+      typedef typename std::iterator_traits<_FwdIter>::value_type _CharT;\n+      typedef std::basic_string<_CharT>                           _StringT;\n+      typedef regex_constants::syntax_option_type                 _FlagT;\n+      typedef const std::ctype<_CharT>                            _CtypeT;\n+\n+      /// Token types returned from the scanner.\n+      enum _TokenT\n+      {\n+\t_S_token_anychar,\n+\t_S_token_ord_char,\n+\t_S_token_oct_num,\n+\t_S_token_hex_num,\n+\t_S_token_backref,\n+\t_S_token_subexpr_begin,\n+\t_S_token_subexpr_no_group_begin,\n+\t_S_token_subexpr_lookahead_begin,\n+\t_S_token_subexpr_neg_lookahead_begin,\n+\t_S_token_subexpr_end,\n+\t_S_token_bracket_begin,\n+\t_S_token_bracket_neg_begin,\n+\t_S_token_bracket_end,\n+\t_S_token_interval_begin,\n+\t_S_token_interval_end,\n+\t_S_token_quoted_class,\n+\t_S_token_char_class_name,\n+\t_S_token_collsymbol,\n+\t_S_token_equiv_class_name,\n+\t_S_token_opt,\n+\t_S_token_or,\n+\t_S_token_closure0,\n+\t_S_token_closure1,\n+\t_S_token_line_begin,\n+\t_S_token_line_end,\n+\t_S_token_comma,\n+\t_S_token_dup_count,\n+\t_S_token_eof,\n+\t_S_token_unknown\n+      };\n+\n+      _Scanner(_FwdIter __begin, _FwdIter __end,\n+\t       _FlagT __flags, std::locale __loc);\n+\n+      void\n+      _M_advance();\n+\n+      _TokenT\n+      _M_get_token() const\n+      { return _M_token; }\n+\n+      const _StringT&\n+      _M_get_value() const\n+      { return _M_value; }\n+\n+#ifdef _GLIBCXX_DEBUG\n+      std::ostream&\n+      _M_print(std::ostream&);\n+#endif\n+\n+    private:\n+      enum _StateT\n+      {\n+\t_S_state_normal,\n+\t_S_state_in_brace,\n+\t_S_state_in_bracket,\n+      };\n+\n+      void\n+      _M_scan_normal();\n+\n+      void\n+      _M_scan_in_bracket();\n+\n+      void\n+      _M_scan_in_brace();\n+\n+      void\n+      _M_eat_escape_ecma();\n+\n+      void\n+      _M_eat_escape_posix();\n+\n+      void\n+      _M_eat_escape_awk();\n+\n+      void\n+      _M_eat_class(char);\n+\n+      constexpr bool\n+      _M_is_ecma()\n+      { return _M_flags & regex_constants::ECMAScript; }\n+\n+      constexpr bool\n+      _M_is_basic()\n+      { return _M_flags & (regex_constants::basic | regex_constants::grep); }\n+\n+      constexpr bool\n+      _M_is_extended()\n+      {\n+\treturn _M_flags & (regex_constants::extended\n+\t\t\t   | regex_constants::egrep\n+\t\t\t   | regex_constants::awk);\n+      }\n+\n+      constexpr bool\n+      _M_is_grep()\n+      { return _M_flags & (regex_constants::grep | regex_constants::egrep); }\n+\n+      constexpr bool\n+      _M_is_awk()\n+      { return _M_flags & regex_constants::awk; }\n+\n+      _StateT                       _M_state;\n+      _FwdIter                      _M_current;\n+      _FwdIter                      _M_end;\n+      _FlagT                        _M_flags;\n+      _CtypeT&                      _M_ctype;\n+      _TokenT                       _M_token;\n+      _StringT                      _M_value;\n+      bool                          _M_at_bracket_start;\n+    public:\n+      // TODO: make them static when this file is stable.\n+      const std::map<char, _TokenT> _M_token_map;\n+      const std::map<char, char>    _M_ecma_escape_map;\n+      const std::map<char, char>    _M_awk_escape_map;\n+      const std::set<char>          _M_ecma_spec_char;\n+      const std::set<char>          _M_basic_spec_char;\n+      const std::set<char>          _M_extended_spec_char;\n+\n+      const std::map<char, char>&   _M_escape_map;\n+      const std::set<char>&         _M_spec_char;\n+      void (_Scanner::* _M_eat_escape)();\n+    };\n+\n+ //@} regex-detail\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __detail\n+} // namespace std\n+\n+#include <bits/regex_scanner.tcc>"}, {"sha": "0d1d2cd9778b633781bb6ca463c42d41342cf258", "filename": "libstdc++-v3/include/bits/regex_scanner.tcc", "status": "added", "additions": 609, "deletions": 0, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -0,0 +1,609 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ *  @file bits/regex_scanner.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{regex}\n+ */\n+\n+// TODO make comments doxygen format\n+\n+// N3376 specified 6 regex styles: ECMAScript, basic, extended, grep, egrep\n+// and awk\n+// 1) grep is basic except '\\n' is treated as '|'\n+// 2) egrep is extended except '\\n' is treated as '|'\n+// 3) awk is extended except special escaping rules, and there's no\n+//    back-reference.\n+//\n+// References:\n+//\n+// ECMAScript: ECMA-262 15.10\n+//\n+// basic, extended:\n+// http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html\n+//\n+// awk: http://pubs.opengroup.org/onlinepubs/000095399/utilities/awk.html\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace __detail\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _FwdIter>\n+    _Scanner<_FwdIter>::\n+    _Scanner(_FwdIter __begin, _FwdIter __end,\n+\t     _FlagT __flags, std::locale __loc)\n+    : _M_current(__begin) , _M_end(__end) , _M_flags(__flags),\n+      _M_ctype(std::use_facet<_CtypeT>(__loc)), _M_state(_S_state_normal),\n+      _M_at_bracket_start(false),\n+      _M_token_map\n+\t{\n+\t  {'^', _S_token_line_begin},\n+\t  {'$', _S_token_line_end},\n+\t  {'.', _S_token_anychar},\n+\t  {'*', _S_token_closure0},\n+\t  {'+', _S_token_closure1},\n+\t  {'?', _S_token_opt},\n+\t  {'|', _S_token_or},\n+\t  // grep and egrep\n+\t  {'\\n', _S_token_or},\n+\t},\n+      _M_ecma_escape_map\n+\t{\n+\t  {'0', '\\0'},\n+\t  {'b', '\\b'},\n+\t  {'f', '\\f'},\n+\t  {'n', '\\n'},\n+\t  {'r', '\\r'},\n+\t  {'t', '\\t'},\n+\t  {'v', '\\v'},\n+\t},\n+      _M_awk_escape_map\n+\t{\n+\t  {'\"', '\"'},\n+\t  {'/', '/'},\n+\t  {'\\\\', '\\\\'},\n+\t  {'a', '\\a'},\n+\t  {'b', '\\b'},\n+\t  {'f', '\\f'},\n+\t  {'n', '\\n'},\n+\t  {'r', '\\r'},\n+\t  {'t', '\\t'},\n+\t  {'v', '\\v'},\n+\t},\n+      _M_escape_map(_M_is_ecma()\n+\t\t    ? _M_ecma_escape_map\n+\t\t    : _M_awk_escape_map),\n+      _M_ecma_spec_char\n+\t{\n+\t  '^',\n+\t  '$',\n+\t  '\\\\',\n+\t  '.',\n+\t  '*',\n+\t  '+',\n+\t  '?',\n+\t  '(',\n+\t  ')',\n+\t  '[',\n+\t  ']',\n+\t  '{',\n+\t  '}',\n+\t  '|',\n+\t},\n+      _M_basic_spec_char\n+\t{\n+\t  '.',\n+\t  '[',\n+\t  '\\\\',\n+\t  '*',\n+\t  '^',\n+\t  '$',\n+\t},\n+      _M_extended_spec_char\n+\t{\n+\t  '.',\n+\t  '[',\n+\t  '\\\\',\n+\t  '(',\n+\t  ')',\n+\t  '*',\n+\t  '+',\n+\t  '?',\n+\t  '{',\n+\t  '|',\n+\t  '^',\n+\t  '$',\n+\t},\n+      _M_eat_escape(_M_is_ecma()\n+\t\t    ? &_Scanner::_M_eat_escape_ecma\n+\t\t    : &_Scanner::_M_eat_escape_posix),\n+      _M_spec_char(_M_is_ecma()\n+\t\t   ? _M_ecma_spec_char\n+\t\t   : _M_is_basic()\n+\t\t   ? _M_basic_spec_char\n+\t\t   : _M_extended_spec_char)\n+    { _M_advance(); }\n+\n+  template<typename _FwdIter>\n+    void\n+    _Scanner<_FwdIter>::\n+    _M_advance()\n+    {\n+      if (_M_current == _M_end)\n+\t{\n+\t  _M_token = _S_token_eof;\n+\t  return;\n+\t}\n+\n+      if (_M_state == _S_state_normal)\n+\t_M_scan_normal();\n+      else if (_M_state == _S_state_in_bracket)\n+\t_M_scan_in_bracket();\n+      else if (_M_state == _S_state_in_brace)\n+\t_M_scan_in_brace();\n+      else\n+\t_GLIBCXX_DEBUG_ASSERT(false);\n+    }\n+\n+  // Differences between styles:\n+  // 1) \"\\(\", \"\\)\", \"\\{\" in basic. It's not escaping.\n+  // 2) \"(?:\", \"(?=\", \"(?!\" in ECMAScript.\n+  template<typename _FwdIter>\n+    void\n+    _Scanner<_FwdIter>::\n+    _M_scan_normal()\n+    {\n+      auto __c = *_M_current++;\n+\n+      if (__c == '\\\\')\n+\t{\n+\t  if (_M_current == _M_end)\n+\t    __throw_regex_error(regex_constants::error_escape);\n+\n+\t  if (!_M_is_basic()\n+\t      || (*_M_current != '('\n+\t\t  && *_M_current != ')'\n+\t\t  && *_M_current != '{'))\n+\t    {\n+\t      (this->*_M_eat_escape)();\n+\t      return;\n+\t    }\n+\t  __c = *_M_current++;\n+\t}\n+      if (__c == '(')\n+\t{\n+\t  if (_M_is_ecma() && *_M_current == '?')\n+\t    {\n+\t      if (++_M_current == _M_end)\n+\t\t__throw_regex_error(regex_constants::error_paren);\n+\n+\t      if (*_M_current == ':')\n+\t\t{\n+\t\t  ++_M_current;\n+\t\t  _M_token = _S_token_subexpr_no_group_begin;\n+\t\t}\n+\t      else if (*_M_current == '=')\n+\t\t{\n+\t\t  ++_M_current;\n+\t\t  _M_token = _S_token_subexpr_lookahead_begin;\n+\t\t}\n+\t      else if (*_M_current == '!')\n+\t\t{\n+\t\t  ++_M_current;\n+\t\t  _M_token = _S_token_subexpr_neg_lookahead_begin;\n+\t\t}\n+\t      else\n+\t\t__throw_regex_error(regex_constants::error_paren);\n+\t    }\n+\t  else\n+\t    _M_token = _S_token_subexpr_begin;\n+\t}\n+      else if (__c == ')')\n+\t_M_token = _S_token_subexpr_end;\n+      else if (__c == '[')\n+\t{\n+\t  _M_state = _S_state_in_bracket;\n+\t  _M_at_bracket_start = true;\n+\t  if (_M_current != _M_end && *_M_current == '^')\n+\t    {\n+\t      _M_token = _S_token_bracket_neg_begin;\n+\t      ++_M_current;\n+\t    }\n+\t  else\n+\t    _M_token = _S_token_bracket_begin;\n+\t}\n+      else if (__c == '{')\n+\t{\n+\t  _M_state = _S_state_in_brace;\n+\t  _M_token = _S_token_interval_begin;\n+\t}\n+      else if (_M_spec_char.count(__c)\n+\t       && __c != ']'\n+\t       && __c != '}'\n+\t       || (_M_is_grep() && __c == '\\n'))\n+\t_M_token = _M_token_map.at(__c);\n+      else\n+\t{\n+\t  _M_token = _S_token_ord_char;\n+\t  _M_value.assign(1, __c);\n+\t}\n+    }\n+\n+  // Differences between styles:\n+  // 1) different semantics of \"[]\" and \"[^]\".\n+  // 2) Escaping in bracket expr.\n+  template<typename _FwdIter>\n+    void\n+    _Scanner<_FwdIter>::\n+    _M_scan_in_bracket()\n+    {\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_brack);\n+\n+      auto __c = *_M_current++;\n+\n+      if (__c == '[')\n+\t{\n+\t  if (_M_current == _M_end)\n+\t    __throw_regex_error(regex_constants::error_brack);\n+\n+\t  if (*_M_current == '.')\n+\t    {\n+\t      _M_token = _S_token_collsymbol;\n+\t      _M_eat_class(*_M_current++);\n+\t    }\n+\t  else if (*_M_current == ':')\n+\t    {\n+\t      _M_token = _S_token_char_class_name;\n+\t      _M_eat_class(*_M_current++);\n+\t    }\n+\t  else if (*_M_current == '=')\n+\t    {\n+\t      _M_token = _S_token_equiv_class_name;\n+\t      _M_eat_class(*_M_current++);\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_token = _S_token_ord_char;\n+\t      _M_value.assign(1, __c);\n+\t    }\n+\t}\n+      // In POSIX, when encountering \"[]\" or \"[^]\", the ']' is interpreted\n+      // literally. So \"[]]\" or \"[^]]\" is valid regex. See the testcases\n+      // `*/empty_range.cc`.\n+      else if (__c == ']' && (_M_is_ecma() || !_M_at_bracket_start))\n+\t{\n+\t  _M_token = _S_token_bracket_end;\n+\t  _M_state = _S_state_normal;\n+\t}\n+      // ECMAScirpt and awk permmits escaping in bracket.\n+      else if (__c == '\\\\' && (_M_is_ecma() || _M_is_awk()))\n+\t(this->*_M_eat_escape)();\n+      else\n+\t{\n+\t  _M_token = _S_token_ord_char;\n+\t  _M_value.assign(1, __c);\n+\t}\n+      _M_at_bracket_start = false;\n+    }\n+\n+  // Differences between styles:\n+  // 1) \"\\}\" in basic style.\n+  template<typename _FwdIter>\n+    void\n+    _Scanner<_FwdIter>::\n+    _M_scan_in_brace()\n+    {\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_brace);\n+\n+      auto __c = *_M_current++;\n+\n+      if (_M_ctype.is(_CtypeT::digit, __c))\n+\t{\n+\t  _M_token = _S_token_dup_count;\n+\t  _M_value.assign(1, __c);\n+\t  while (_M_current != _M_end\n+\t\t && _M_ctype.is(_CtypeT::digit, *_M_current))\n+\t    _M_value += *_M_current++;\n+\t}\n+      else if (__c == ',')\n+\t_M_token = _S_token_comma;\n+      // basic use \\}.\n+      else if (_M_is_basic())\n+\t{\n+\t  if (__c == '\\\\' && _M_current != _M_end && *_M_current == '}')\n+\t    {\n+\t      _M_state = _S_state_normal;\n+\t      _M_token = _S_token_interval_end;\n+\t      ++_M_current;\n+\t    }\n+\t  else\n+\t    __throw_regex_error(regex_constants::error_brace);\n+\t}\n+      else if (__c == '}')\n+\t{\n+\t  _M_state = _S_state_normal;\n+\t  _M_token = _S_token_interval_end;\n+\t}\n+      else\n+\t__throw_regex_error(regex_constants::error_brace);\n+    }\n+\n+  template<typename _FwdIter>\n+    void\n+    _Scanner<_FwdIter>::\n+    _M_eat_escape_ecma()\n+    {\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_escape);\n+\n+      auto __c = *_M_current++;\n+\n+      if (_M_escape_map.count(__c)\n+\t  && (__c != 'b' || _M_state == _S_state_in_bracket))\n+\t{\n+\t  _M_token = _S_token_ord_char;\n+\t  _M_value.assign(1, _M_escape_map.at(__c));\n+\t}\n+      // N3376 28.13\n+      else if (__c == 'b'\n+\t       || __c == 'B'\n+\t       || __c == 'd'\n+\t       || __c == 'D'\n+\t       || __c == 's'\n+\t       || __c == 'S'\n+\t       || __c == 'w'\n+\t       || __c == 'W')\n+\t{\n+\t  _M_token = _S_token_quoted_class;\n+\t  _M_value.assign(1, __c);\n+\t}\n+      else if (__c == 'c')\n+\t{\n+\t  if (_M_current == _M_end)\n+\t    __throw_regex_error(regex_constants::error_escape);\n+\t  _M_token = _S_token_ord_char;\n+\t  _M_value.assign(1, *_M_current++);\n+\t}\n+      else if (__c == 'x' || __c == 'u')\n+\t{\n+\t  _M_value.erase();\n+\t  for (int i = 0; i < (__c == 'x' ? 2 : 4); i++)\n+\t    {\n+\t      if (_M_current == _M_end\n+\t\t  || !_M_ctype.is(_CtypeT::xdigit, *_M_current))\n+\t\t__throw_regex_error(regex_constants::error_escape);\n+\t      _M_value += *_M_current++;\n+\t    }\n+\t  _M_token = _S_token_hex_num;\n+\t}\n+      // ECMAScript recongnizes multi-digit back-references.\n+      else if (_M_ctype.is(_CtypeT::digit, __c))\n+\t{\n+\t  _M_value.assign(1, __c);\n+\t  while (_M_current != _M_end\n+\t\t && _M_ctype.is(_CtypeT::digit, *_M_current))\n+\t    _M_value += *_M_current++;\n+\t  _M_token = _S_token_backref;\n+\t}\n+      else\n+\t{\n+\t  _M_token = _S_token_ord_char;\n+\t  _M_value.assign(1, __c);\n+\t}\n+    }\n+\n+  template<typename _FwdIter>\n+    void\n+    _Scanner<_FwdIter>::\n+    _M_eat_escape_posix()\n+    {\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_escape);\n+\n+      auto __c = *_M_current;\n+\n+      if (_M_spec_char.count(__c))\n+\t{\n+\t  _M_token = _S_token_ord_char;\n+\t  _M_value.assign(1, __c);\n+\t}\n+      // We MUST judge awk before handling backrefs. There's no backref in awk.\n+      else if (_M_is_awk())\n+\t{\n+\t  _M_eat_escape_awk();\n+\t  return;\n+\t}\n+      else if (_M_ctype.is(_CtypeT::digit, __c) && __c != '0')\n+\t{\n+\t  _M_token = _S_token_backref;\n+\t  _M_value.assign(1, __c);\n+\t}\n+      else\n+\t__throw_regex_error(regex_constants::error_escape);\n+      ++_M_current;\n+    }\n+\n+  template<typename _FwdIter>\n+    void\n+    _Scanner<_FwdIter>::\n+    _M_eat_escape_awk()\n+    {\n+      auto __c = *_M_current++;\n+\n+      if (_M_escape_map.count(__c))\n+\t{\n+\t  _M_token = _S_token_ord_char;\n+\t  _M_value.assign(1, _M_escape_map.at(__c));\n+\t}\n+      // \\ddd for oct representation\n+      else if (_M_ctype.is(_CtypeT::digit, __c)\n+\t       && __c != '8'\n+\t       && __c != '9')\n+\t{\n+\t  _M_value.assign(1,  __c);\n+\t  for (int __i = 0;\n+\t       __i < 2\n+\t       && _M_current != _M_end\n+\t       && _M_ctype.is(_CtypeT::digit, *_M_current)\n+\t       && *_M_current != '8'\n+\t       && *_M_current != '9';\n+\t       __i++)\n+\t    _M_value += *_M_current++;\n+\t  _M_token = _S_token_oct_num;\n+\t  return;\n+\t}\n+      else\n+\t__throw_regex_error(regex_constants::error_escape);\n+    }\n+\n+  // Eats a character class or throwns an exception.\n+  // __ch cound be ':', '.' or '=', _M_current is the char after ']' when\n+  // returning.\n+  template<typename _FwdIter>\n+    void\n+    _Scanner<_FwdIter>::\n+    _M_eat_class(char __ch)\n+    {\n+      for (_M_value.clear(); _M_current != _M_end && *_M_current != __ch;)\n+\t_M_value += *_M_current++;\n+      if (_M_current == _M_end\n+\t  || *_M_current++ != __ch\n+\t  || _M_current == _M_end // skip __ch\n+\t  || *_M_current++ != ']') // skip ']'\n+\tif (__ch == ':')\n+\t  __throw_regex_error(regex_constants::error_ctype);\n+\telse\n+\t  __throw_regex_error(regex_constants::error_collate);\n+    }\n+\n+#ifdef _GLIBCXX_DEBUG\n+  template<typename _FwdIter>\n+    std::ostream&\n+    _Scanner<_FwdIter>::\n+    _M_print(std::ostream& ostr)\n+    {\n+      switch (_M_token)\n+      {\n+      case _S_token_anychar:\n+\tostr << \"any-character\\n\";\n+\tbreak;\n+      case _S_token_backref:\n+\tostr << \"backref\\n\";\n+\tbreak;\n+      case _S_token_bracket_begin:\n+\tostr << \"bracket-begin\\n\";\n+\tbreak;\n+      case _S_token_bracket_neg_begin:\n+\tostr << \"bracket-neg-begin\\n\";\n+\tbreak;\n+      case _S_token_bracket_end:\n+\tostr << \"bracket-end\\n\";\n+\tbreak;\n+      case _S_token_char_class_name:\n+\tostr << \"char-class-name \\\"\" << _M_value << \"\\\"\\n\";\n+\tbreak;\n+      case _S_token_closure0:\n+\tostr << \"closure0\\n\";\n+\tbreak;\n+      case _S_token_closure1:\n+\tostr << \"closure1\\n\";\n+\tbreak;\n+      case _S_token_collsymbol:\n+\tostr << \"collsymbol \\\"\" << _M_value << \"\\\"\\n\";\n+\tbreak;\n+      case _S_token_comma:\n+\tostr << \"comma\\n\";\n+\tbreak;\n+      case _S_token_dup_count:\n+\tostr << \"dup count: \" << _M_value << \"\\n\";\n+\tbreak;\n+      case _S_token_eof:\n+\tostr << \"EOF\\n\";\n+\tbreak;\n+      case _S_token_equiv_class_name:\n+\tostr << \"equiv-class-name \\\"\" << _M_value << \"\\\"\\n\";\n+\tbreak;\n+      case _S_token_interval_begin:\n+\tostr << \"interval begin\\n\";\n+\tbreak;\n+      case _S_token_interval_end:\n+\tostr << \"interval end\\n\";\n+\tbreak;\n+      case _S_token_line_begin:\n+\tostr << \"line begin\\n\";\n+\tbreak;\n+      case _S_token_line_end:\n+\tostr << \"line end\\n\";\n+\tbreak;\n+      case _S_token_opt:\n+\tostr << \"opt\\n\";\n+\tbreak;\n+      case _S_token_or:\n+\tostr << \"or\\n\";\n+\tbreak;\n+      case _S_token_ord_char:\n+\tostr << \"ordinary character: \\\"\" << _M_value << \"\\\"\\n\";\n+\tbreak;\n+      case _S_token_subexpr_begin:\n+\tostr << \"subexpr begin\\n\";\n+\tbreak;\n+      case _S_token_subexpr_no_group_begin:\n+\tostr << \"no grouping subexpr begin\\n\";\n+\tbreak;\n+      case _S_token_subexpr_lookahead_begin:\n+\tostr << \"lookahead subexpr begin\\n\";\n+\tbreak;\n+      case _S_token_subexpr_neg_lookahead_begin:\n+\tostr << \"neg lookahead subexpr begin\\n\";\n+\tbreak;\n+      case _S_token_subexpr_end:\n+\tostr << \"subexpr end\\n\";\n+\tbreak;\n+      case _S_token_unknown:\n+\tostr << \"-- unknown token --\\n\";\n+\tbreak;\n+      case _S_token_oct_num:\n+\tostr << \"oct number \" << _M_value << \"\\n\";\n+\tbreak;\n+      case _S_token_hex_num:\n+\tostr << \"hex number \" << _M_value << \"\\n\";\n+\tbreak;\n+      case _S_token_quoted_class:\n+\tostr << \"quoted class \" << \"\\\\\" << _M_value << \"\\n\";\n+\tbreak;\n+      default:\n+\t_GLIBCXX_DEBUG_ASSERT(false);\n+      }\n+      return ostr;\n+    }\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __detail\n+} // namespace"}, {"sha": "36dd0a97b8f302e036c6cd9a222bfc7c3770b735", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -56,6 +56,7 @@\n \n #include <bits/regex_constants.h>\n #include <bits/regex_error.h>\n+#include <bits/regex_scanner.h>\n #include <bits/regex_automaton.h>\n #include <bits/regex_compiler.h>\n #include <bits/regex_executor.h>"}, {"sha": "d4edf123e97e90ce1147a612305f1d30d5baee9c", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/awk/cstring_01.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fawk%2Fcstring_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fawk%2Fcstring_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fawk%2Fcstring_01.cc?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-08-26  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests awk escaping.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  regex(\"\\\\[\", regex_constants::awk);\n+  VERIFY(regex_match(\"\\\"\", regex(\"[\\\\\\\"]\", regex_constants::awk)));\n+  VERIFY(regex_match(\"/\", regex(\"/\", regex_constants::awk)));\n+  VERIFY(regex_match(\"\\a\", regex(\"\\\\a\", regex_constants::awk)));\n+  VERIFY(regex_match(\"\\\"\", regex(\"\\\\\\\"\", regex_constants::awk)));\n+  VERIFY(regex_match(\"5\", regex(\"\\\\65\", regex_constants::awk)));\n+  VERIFY(regex_match(\"53\", regex(\"\\\\0653\", regex_constants::awk)));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "eb22569f337725e0fc2f18b66c49898ccd4763ee", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/basic/empty_range.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fbasic%2Fempty_range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fbasic%2Fempty_range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fbasic%2Fempty_range.cc?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-08-26  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ECMAScript empty range.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+#define FAIL(s) \\\n+  try\\\n+    {\\\n+      regex re(s, regex_constants::basic);\\\n+      VERIFY(false);\\\n+    }\\\n+  catch (...)\\\n+    {\\\n+      VERIFY(true);\\\n+    }\n+  FAIL(\"[]\");\n+  FAIL(\"[^]\");\n+  VERIFY(regex_match(\"]\", regex(\"[]]\", regex_constants::basic)));\n+  VERIFY(!regex_match(\"]\", regex(\"[^]]\", regex_constants::basic)));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a7ef0fb36cc358925ab7e3d9adf7a4235c997842", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/cstring_hex.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fcstring_hex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fcstring_hex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fcstring_hex.cc?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -0,0 +1,54 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-08-26  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ECMAScript \\x and \\u.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  VERIFY(regex_match(\":\", regex(\"\\\\x3a\")));\n+  VERIFY(regex_match(L\"\\u1234\", wregex(L\"\\\\u1234\")));\n+  try\n+    {\n+      regex(\"\\\\u400x\");\n+      VERIFY(false);\n+    }\n+  catch (...)\n+    {\n+      VERIFY(true);\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "93bca45bf9d50d12b026cb634adc1700541aaf7a", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/empty_range.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fempty_range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fempty_range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fempty_range.cc?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-08-26  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ECMAScript empty range.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  VERIFY(!regex_match(\"x\", regex(\"[]\")));\n+  VERIFY(regex_match(\"x\", regex(\"[^]\")));\n+  VERIFY(!regex_match(\"]\", regex(\"[]]\")));\n+  VERIFY(!regex_match(\"]\", regex(\"[^]]\")));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a2d290db28392ed3a2ce44c039c6bacc8f916353", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_search/ecma/string_01.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fstring_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fbbb766cde302f16aca2208e25610c11484388/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fstring_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fstring_01.cc?ref=33fbbb766cde302f16aca2208e25610c11484388", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-08-26  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.3 regex_search\n+// Tests BRE against a std::string target.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  VERIFY(std::regex_search(\"\", std::regex(\"\")));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}