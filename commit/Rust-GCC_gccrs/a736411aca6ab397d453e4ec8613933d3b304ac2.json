{"sha": "a736411aca6ab397d453e4ec8613933d3b304ac2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTczNjQxMWFjYTZhYjM5N2Q0NTNlNGVjODYxMzkzM2QzYjMwNGFjMg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-16T17:36:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-16T17:36:03Z"}, "message": "call.c (build_user_type_conversion_1): Use OVL_FIRST.\n\n\t* call.c (build_user_type_conversion_1): Use OVL_FIRST.\n\t(print_error_for_call_faulure): Use OVL_NAME.\n\t(build_op_call_1): Use ovl_iterator.\n\t(add_candidates): Use OVL_FIRST & lkp_iterator.\n\t(build_op_delete_call): Use MAYBE_BASELINK_FUNCTIONS &\n\tlkp_iterator.\n\t* class.c (deduce_noexcept_on_destructors): Use ovl_iterator.\n\t(type_has_user_nondefault_constructor)\n\tin_class_defaulted_default_constructor,\n\ttype_has_user_provided_constructor,\n\ttype_has_user_provided_or_explicit_constructor,\n\ttype_has_non_user_provided_default_constructor,\n\tvbase_has_user_provided_move_assign,\n\ttype_has_move_constructor, type_has_move_assign,\n\ttype_has_user_declared_move_constructor,\n\ttype_has_user_declared_move_assign,\n\ttype_build_ctor_call, type_build_dtor_call,\n\ttype_requires_array_cookie, explain_non_literal_class): Likewise.\n\t(finish_struct): Use lkp_iterator.\n\t(resolve_address_of_overloaded_function): Use OVL_NAME,\n\tlkp_iterator.\n\t(note_name_declared_in_class): Use OVL_NAME.\n\t* cxx-pretty-print.c (pp_cxx_unqualified_id): Use OVL_FIRST.\n\t(pp_cxx_qualified_id, cxx_pretty_printer::id_expression)\n\tcxx_pretty_printer::expression): Likewise.\n\t* decl2.c (check_classfn): Use ovl_iterator.\n\t* pt.c (retrieve_specialization): Use ovl_iterator.\n\t* tree.c (cp_tree_equal): Use lkp_iterator.\n\t(type_has_nontrivial_copy_init): Use ovl_iterator.\n((--This line, and those below, will be ignored--\n\nM    cp/ChangeLog\nM    cp/call.c\nM    cp/class.c\nM    cp/pt.c\nM    cp/decl2.c\nM    cp/tree.c\nM    cp/cxx-pretty-print.c\n\nFrom-SVN: r248120", "tree": {"sha": "13b600e24ba0d9440fe54a951498f9f4e07eeb10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13b600e24ba0d9440fe54a951498f9f4e07eeb10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a736411aca6ab397d453e4ec8613933d3b304ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a736411aca6ab397d453e4ec8613933d3b304ac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a736411aca6ab397d453e4ec8613933d3b304ac2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a736411aca6ab397d453e4ec8613933d3b304ac2/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c20c3b42c37a3dc64dddb9d3843bb2f640519def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20c3b42c37a3dc64dddb9d3843bb2f640519def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c20c3b42c37a3dc64dddb9d3843bb2f640519def"}], "stats": {"total": 325, "additions": 161, "deletions": 164}, "files": [{"sha": "4d508ec09dc1f6941c0e62b815e21d8d1b65ac33", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a736411aca6ab397d453e4ec8613933d3b304ac2", "patch": "@@ -1,5 +1,34 @@\n 2017-05-16  Nathan Sidwell  <nathan@acm.org>\n \n+\t* call.c (build_user_type_conversion_1): Use OVL_FIRST.\n+\t(print_error_for_call_faulure): Use OVL_NAME.\n+\t(build_op_call_1): Use ovl_iterator.\n+\t(add_candidates): Use OVL_FIRST & lkp_iterator.\n+\t(build_op_delete_call): Use MAYBE_BASELINK_FUNCTIONS &\n+\tlkp_iterator.\n+\t* class.c (deduce_noexcept_on_destructors): Use ovl_iterator.\n+\t(type_has_user_nondefault_constructor,\n+\tin_class_defaulted_default_constructor,\n+\ttype_has_user_provided_constructor,\n+\ttype_has_user_provided_or_explicit_constructor,\n+\ttype_has_non_user_provided_default_constructor,\n+\tvbase_has_user_provided_move_assign,\n+\ttype_has_move_constructor, type_has_move_assign,\n+\ttype_has_user_declared_move_constructor,\n+\ttype_has_user_declared_move_assign,\n+\ttype_build_ctor_call, type_build_dtor_call,\n+\ttype_requires_array_cookie, explain_non_literal_class): Likewise.\n+\t(finish_struct): Use lkp_iterator.\n+\t(resolve_address_of_overloaded_function): Use OVL_NAME, lkp_iterator.\n+\t(note_name_declared_in_class): Use OVL_NAME.\n+\t* cxx-pretty-print.c (pp_cxx_unqualified_id): Use OVL_FIRST.\n+\t(pp_cxx_qualified_id, cxx_pretty_printer::id_expression,\n+\tcxx_pretty_printer::expression): Likewise.\n+\t* decl2.c (check_classfn): Use ovl_iterator.\n+\t* pt.c (retrieve_specialization): Use ovl_iterator.\n+\t* tree.c (cp_tree_equal): Use lkp_iterator.\n+\t(type_has_nontrivial_copy_init): Use ovl_iterator.\n+\n \t* typeck2.c (cxx_incomplete_type_diagnostic): Revert change and\n \tcheck is_overloaded_fn.\n "}, {"sha": "1367344308fb3d2d3314cb943d18a3f0f71190d1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a736411aca6ab397d453e4ec8613933d3b304ac2", "patch": "@@ -3783,8 +3783,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n \n       /* We should never try to call the abstract or base constructor\n \t from here.  */\n-      gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n-\t\t  && !DECL_HAS_VTT_PARM_P (OVL_CURRENT (ctors)));\n+      gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_FIRST (ctors))\n+\t\t  && !DECL_HAS_VTT_PARM_P (OVL_FIRST (ctors)));\n \n       args = make_tree_vector_single (expr);\n       if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n@@ -4172,7 +4172,7 @@ print_error_for_call_failure (tree fn, vec<tree, va_gc> *args,\n       targs = TREE_OPERAND (fn, 1);\n       fn = TREE_OPERAND (fn, 0);\n     }\n-  tree name = DECL_NAME (OVL_CURRENT (fn));\n+  tree name = OVL_NAME (fn);\n   location_t loc = location_of (name);\n   if (targs)\n     name = lookup_template_function (name, targs);\n@@ -4449,16 +4449,15 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n-      tree fns = TREE_VALUE (convs);\n       tree totype = TREE_TYPE (convs);\n \n       if (TYPE_PTRFN_P (totype)\n \t  || TYPE_REFFN_P (totype)\n \t  || (TREE_CODE (totype) == REFERENCE_TYPE\n \t      && TYPE_PTRFN_P (TREE_TYPE (totype))))\n-\tfor (; fns; fns = OVL_NEXT (fns))\n+\tfor (ovl_iterator iter (TREE_VALUE (convs)); iter; ++iter)\n \t  {\n-\t    tree fn = OVL_CURRENT (fns);\n+\t    tree fn = *iter;\n \n \t    if (DECL_NONCONVERTING_P (fn))\n \t      continue;\n@@ -5376,13 +5375,12 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n   bool check_list_ctor;\n   bool check_converting;\n   unification_kind_t strict;\n-  tree fn;\n \n   if (!fns)\n     return;\n \n   /* Precalculate special handling of constructors and conversion ops.  */\n-  fn = OVL_CURRENT (fns);\n+  tree fn = OVL_FIRST (fns);\n   if (DECL_CONV_FN_P (fn))\n     {\n       check_list_ctor = false;\n@@ -5425,12 +5423,12 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n     /* Delay creating the implicit this parameter until it is needed.  */\n     non_static_args = NULL;\n \n-  for (; fns; fns = OVL_NEXT (fns))\n+  for (lkp_iterator iter (fns); iter; ++iter)\n     {\n       tree fn_first_arg;\n       const vec<tree, va_gc> *fn_args;\n \n-      fn = OVL_CURRENT (fns);\n+      fn = *iter;\n \n       if (check_converting && DECL_NONCONVERTING_P (fn))\n \tcontinue;\n@@ -6201,8 +6199,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n       if (fn == error_mark_node)\n \treturn NULL_TREE;\n \n-      if (BASELINK_P (fn))\n-\tfn = BASELINK_FUNCTIONS (fn);\n+      fn = MAYBE_BASELINK_FUNCTIONS (fn);\n \n       /* \"If the lookup finds the two-parameter form of a usual deallocation\n \t function (3.7.4.2) and that function, considered as a placement\n@@ -6221,10 +6218,10 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t     the usual deallocation function, so we shouldn't complain\n \t     about using the operator delete (void *, size_t).  */\n \t  if (DECL_CLASS_SCOPE_P (fn))\n-\t    for (t = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns;\n-\t\t t; t = OVL_NEXT (t))\n+\t    for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (fns));\n+\t\t iter; ++iter)\n \t      {\n-\t\ttree elt = OVL_CURRENT (t);\n+\t\ttree elt = *iter;\n \t\tif (usual_deallocation_fn_p (elt)\n \t\t    && FUNCTION_ARG_CHAIN (elt) == void_list_node)\n \t\t  goto ok;\n@@ -6263,10 +6260,9 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n        allocation function. If the lookup finds a single matching\n        deallocation function, that function will be called; otherwise, no\n        deallocation function will be called.\"  */\n-    for (t = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns;\n-\t t; t = OVL_NEXT (t))\n+    for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (fns)); iter; ++iter)\n       {\n-\ttree elt = OVL_CURRENT (t);\n+\ttree elt = *iter;\n \tif (usual_deallocation_fn_p (elt))\n \t  {\n \t    if (!fn)"}, {"sha": "6726a6fc29cf4ac8831c854b64251228f7949c8e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 64, "deletions": 85, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a736411aca6ab397d453e4ec8613933d3b304ac2", "patch": "@@ -5069,8 +5069,8 @@ deduce_noexcept_on_destructors (tree t)\n   if (!CLASSTYPE_METHOD_VEC (t))\n     return;\n \n-  for (tree fns = CLASSTYPE_DESTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n-    deduce_noexcept_on_destructor (OVL_CURRENT (fns));\n+  for (ovl_iterator iter (CLASSTYPE_DESTRUCTORS (t)); iter; ++iter)\n+    deduce_noexcept_on_destructor (*iter);\n }\n \n /* Subroutine of set_one_vmethod_tm_attributes.  Search base classes\n@@ -5230,14 +5230,12 @@ default_ctor_p (tree fn)\n bool\n type_has_user_nondefault_constructor (tree t)\n {\n-  tree fns;\n-\n   if (!TYPE_HAS_USER_CONSTRUCTOR (t))\n     return false;\n \n-  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       if (!DECL_ARTIFICIAL (fn)\n \t  && (TREE_CODE (fn) == TEMPLATE_DECL\n \t      || (skip_artificial_parms_for (fn, DECL_ARGUMENTS (fn))\n@@ -5257,9 +5255,9 @@ in_class_defaulted_default_constructor (tree t)\n   if (!TYPE_HAS_USER_CONSTRUCTOR (t))\n     return NULL_TREE;\n \n-  for (tree fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n \n       if (DECL_DEFAULTED_IN_CLASS_P (fn)\n \t  && default_ctor_p (fn))\n@@ -5288,8 +5286,6 @@ user_provided_p (tree fn)\n bool\n type_has_user_provided_constructor (tree t)\n {\n-  tree fns;\n-\n   if (!CLASS_TYPE_P (t))\n     return false;\n \n@@ -5300,8 +5296,8 @@ type_has_user_provided_constructor (tree t)\n   if (!CLASSTYPE_METHOD_VEC (t))\n     return false;\n \n-  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n-    if (user_provided_p (OVL_CURRENT (fns)))\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+    if (user_provided_p (*iter))\n       return true;\n \n   return false;\n@@ -5312,8 +5308,6 @@ type_has_user_provided_constructor (tree t)\n bool\n type_has_user_provided_or_explicit_constructor (tree t)\n {\n-  tree fns;\n-\n   if (!CLASS_TYPE_P (t))\n     return false;\n \n@@ -5324,9 +5318,9 @@ type_has_user_provided_or_explicit_constructor (tree t)\n   if (!CLASSTYPE_METHOD_VEC (t))\n     return false;\n \n-  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       if (user_provided_p (fn) || DECL_NONCONVERTING_P (fn))\n \treturn true;\n     }\n@@ -5341,16 +5335,14 @@ type_has_user_provided_or_explicit_constructor (tree t)\n bool\n type_has_non_user_provided_default_constructor (tree t)\n {\n-  tree fns;\n-\n   if (!TYPE_HAS_DEFAULT_CONSTRUCTOR (t))\n     return false;\n   if (CLASSTYPE_LAZY_DEFAULT_CTOR (t))\n     return true;\n \n-  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       if (TREE_CODE (fn) == FUNCTION_DECL\n \t  && default_ctor_p (fn)\n \t  && !user_provided_p (fn))\n@@ -5369,11 +5361,11 @@ bool\n vbase_has_user_provided_move_assign (tree type)\n {\n   /* Does the type itself have a user-provided move assignment operator?  */\n-  for (tree fns\n-\t = lookup_fnfields_slot_nolazy (type, cp_assignment_operator_id (NOP_EXPR));\n-       fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter (lookup_fnfields_slot_nolazy\n+\t\t\t  (type, cp_assignment_operator_id (NOP_EXPR)));\n+       iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       if (move_fn_p (fn) && user_provided_p (fn))\n \treturn true;\n     }\n@@ -5503,8 +5495,6 @@ type_has_virtual_destructor (tree type)\n bool\n type_has_move_constructor (tree t)\n {\n-  tree fns;\n-\n   if (CLASSTYPE_LAZY_MOVE_CTOR (t))\n     {\n       gcc_assert (COMPLETE_TYPE_P (t));\n@@ -5514,8 +5504,8 @@ type_has_move_constructor (tree t)\n   if (!CLASSTYPE_METHOD_VEC (t))\n     return false;\n \n-  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n-    if (move_fn_p (OVL_CURRENT (fns)))\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+    if (move_fn_p (*iter))\n       return true;\n \n   return false;\n@@ -5526,17 +5516,16 @@ type_has_move_constructor (tree t)\n bool\n type_has_move_assign (tree t)\n {\n-  tree fns;\n-\n   if (CLASSTYPE_LAZY_MOVE_ASSIGN (t))\n     {\n       gcc_assert (COMPLETE_TYPE_P (t));\n       lazily_declare_fn (sfk_move_assignment, t);\n     }\n \n-  for (fns = lookup_fnfields_slot_nolazy (t, cp_assignment_operator_id (NOP_EXPR));\n-       fns; fns = OVL_NEXT (fns))\n-    if (move_fn_p (OVL_CURRENT (fns)))\n+  for (ovl_iterator iter (lookup_fnfields_slot_nolazy\n+\t\t\t  (t, cp_assignment_operator_id (NOP_EXPR)));\n+       iter; ++iter)\n+    if (move_fn_p (*iter))\n       return true;\n \n   return false;\n@@ -5550,17 +5539,15 @@ type_has_move_assign (tree t)\n bool\n type_has_user_declared_move_constructor (tree t)\n {\n-  tree fns;\n-\n   if (CLASSTYPE_LAZY_MOVE_CTOR (t))\n     return false;\n \n   if (!CLASSTYPE_METHOD_VEC (t))\n     return false;\n \n-  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       if (move_fn_p (fn) && !DECL_ARTIFICIAL (fn))\n \treturn true;\n     }\n@@ -5574,15 +5561,14 @@ type_has_user_declared_move_constructor (tree t)\n bool\n type_has_user_declared_move_assign (tree t)\n {\n-  tree fns;\n-\n   if (CLASSTYPE_LAZY_MOVE_ASSIGN (t))\n     return false;\n \n-  for (fns = lookup_fnfields_slot_nolazy (t, cp_assignment_operator_id (NOP_EXPR));\n-       fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter (lookup_fnfields_slot_nolazy\n+\t\t\t  (t, cp_assignment_operator_id (NOP_EXPR)));\n+       iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       if (move_fn_p (fn) && !DECL_ARTIFICIAL (fn))\n \treturn true;\n     }\n@@ -5615,10 +5601,11 @@ type_build_ctor_call (tree t)\n     return false;\n   /* A user-declared constructor might be private, and a constructor might\n      be trivial but deleted.  */\n-  for (tree fns = lookup_fnfields_slot (inner, complete_ctor_identifier);\n-       fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter\n+\t (lookup_fnfields_slot (inner, complete_ctor_identifier));\n+       iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       if (!DECL_ARTIFICIAL (fn)\n \t  || DECL_DELETED_FN (fn))\n \treturn true;\n@@ -5642,10 +5629,11 @@ type_build_dtor_call (tree t)\n     return false;\n   /* A user-declared destructor might be private, and a destructor might\n      be trivial but deleted.  */\n-  for (tree fns = lookup_fnfields_slot (inner, complete_dtor_identifier);\n-       fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter\n+\t (lookup_fnfields_slot (inner, complete_dtor_identifier));\n+       iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       if (!DECL_ARTIFICIAL (fn)\n \t  || DECL_DELETED_FN (fn))\n \treturn true;\n@@ -5707,16 +5695,13 @@ type_requires_array_cookie (tree type)\n   if (!fns || fns == error_mark_node)\n     return false;\n   /* Loop through all of the functions.  */\n-  for (fns = BASELINK_FUNCTIONS (fns); fns; fns = OVL_NEXT (fns))\n+  for (lkp_iterator iter (BASELINK_FUNCTIONS (fns)); iter; ++iter)\n     {\n-      tree fn;\n-      tree second_parm;\n+      tree fn = *iter;\n \n-      /* Select the current function.  */\n-      fn = OVL_CURRENT (fns);\n       /* See if this function is a one-argument delete function.  If\n \t it is, then it will be the usual deallocation function.  */\n-      second_parm = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fn)));\n+      tree second_parm = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fn)));\n       if (second_parm == void_list_node)\n \treturn false;\n       /* Do not consider this function if its second argument is an\n@@ -5808,26 +5793,23 @@ explain_non_literal_class (tree t)\n \t      \"default constructor, and has no constexpr constructor that \"\n \t      \"is not a copy or move constructor\", t);\n       if (type_has_non_user_provided_default_constructor (t))\n-\t{\n-\t  /* Note that we can't simply call locate_ctor because when the\n-\t     constructor is deleted it just returns NULL_TREE.  */\n-\t  tree fns;\n-\t  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n-\t    {\n-\t      tree fn = OVL_CURRENT (fns);\n-\t      tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\t/* Note that we can't simply call locate_ctor because when the\n+\t   constructor is deleted it just returns NULL_TREE.  */\n+\tfor (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+\t  {\n+\t    tree fn = *iter;\n+\t    tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n \n-\t      parms = skip_artificial_parms_for (fn, parms);\n+\t    parms = skip_artificial_parms_for (fn, parms);\n \n-\t      if (sufficient_parms_p (parms))\n-\t\t{\n-\t\t  if (DECL_DELETED_FN (fn))\n-\t\t    maybe_explain_implicit_delete (fn);\n-\t\t  else\n-\t\t    explain_invalid_constexpr_fn (fn);\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t    if (sufficient_parms_p (parms))\n+\t      {\n+\t\tif (DECL_DELETED_FN (fn))\n+\t\t  maybe_explain_implicit_delete (fn);\n+\t\telse\n+\t\t  explain_invalid_constexpr_fn (fn);\n+\t\tbreak;\n+\t      }\n \t}\n     }\n   else\n@@ -7508,8 +7490,8 @@ finish_struct (tree t, tree attributes)\n \t  {\n \t    tree fn = strip_using_decl (x);\n \t    if (is_overloaded_fn (fn))\n-\t      for (; fn; fn = OVL_NEXT (fn))\n-\t\tadd_method (t, OVL_CURRENT (fn), x);\n+\t      for (lkp_iterator iter (fn); iter; ++iter)\n+\t\tadd_method (t, *iter, true);\n \t  }\n \n       /* Remember current #pragma pack value.  */\n@@ -8165,7 +8147,7 @@ resolve_address_of_overloaded_function (tree target_type,\n       if (complain & tf_error)\n \terror (\"cannot resolve overloaded function %qD based on\"\n \t       \" conversion to type %qT\",\n-\t       DECL_NAME (OVL_FUNCTION (overload)), target_type);\n+\t       OVL_NAME (overload), target_type);\n       return error_mark_node;\n     }\n \n@@ -8183,9 +8165,9 @@ resolve_address_of_overloaded_function (tree target_type,\n      if we're just going to throw them out anyhow.  But, of course, we\n      can only do this when we don't *need* a template function.  */\n   if (!template_only)\n-    for (tree fns = overload; fns; fns = OVL_NEXT (fns))\n+    for (lkp_iterator iter (overload); iter; ++iter)\n       {\n-\ttree fn = OVL_CURRENT (fns);\n+\ttree fn = *iter;\n \n \tif (TREE_CODE (fn) == TEMPLATE_DECL)\n \t  /* We're not looking for templates just yet.  */\n@@ -8214,7 +8196,6 @@ resolve_address_of_overloaded_function (tree target_type,\n     {\n       tree target_arg_types;\n       tree target_ret_type;\n-      tree fns;\n       tree *args;\n       unsigned int nargs, ia;\n       tree arg;\n@@ -8230,9 +8211,9 @@ resolve_address_of_overloaded_function (tree target_type,\n \targs[ia] = TREE_VALUE (arg);\n       nargs = ia;\n \n-      for (fns = overload; fns; fns = OVL_NEXT (fns))\n+      for (lkp_iterator iter (overload); iter; ++iter)\n \t{\n-\t  tree fn = OVL_CURRENT (fns);\n+\t  tree fn = *iter;\n \t  tree instantiation;\n \t  tree targs;\n \n@@ -8309,8 +8290,7 @@ resolve_address_of_overloaded_function (tree target_type,\n       if (complain & tf_error)\n \t{\n \t  error (\"no matches converting function %qD to type %q#T\",\n-\t\t DECL_NAME (OVL_CURRENT (overload)),\n-\t\t target_type);\n+\t\t OVL_NAME (overload), target_type);\n \n \t  print_candidates (overload);\n \t}\n@@ -8337,8 +8317,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  if (complain & tf_error)\n \t    {\n \t      error (\"converting overloaded function %qD to type %q#T is ambiguous\",\n-\t\t     DECL_NAME (OVL_FUNCTION (overload)),\n-\t\t     target_type);\n+\t\t     OVL_NAME (overload), target_type);\n \n \t      /* Since print_candidates expects the functions in the\n \t\t TREE_VALUE slot, we flip them here.  */\n@@ -8750,7 +8729,7 @@ note_name_declared_in_class (tree name, tree decl)\n       permerror (input_location, \"declaration of %q#D\", decl);\n       permerror (location_of ((tree) n->value),\n \t\t \"changes meaning of %qD from %q#D\",\n-\t\t DECL_NAME (OVL_CURRENT (decl)), (tree) n->value);\n+\t\t OVL_NAME (decl), (tree) n->value);\n     }\n }\n "}, {"sha": "e92a72af12924b77306f1f76c28a17355d60e5b2", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=a736411aca6ab397d453e4ec8613933d3b304ac2", "patch": "@@ -141,7 +141,7 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case OVERLOAD:\n-      t = OVL_CURRENT (t);\n+      t = OVL_FIRST (t);\n       /* FALLTHRU */\n     case VAR_DECL:\n     case PARM_DECL:\n@@ -281,7 +281,7 @@ pp_cxx_qualified_id (cxx_pretty_printer *pp, tree t)\n \t FIXME:  This is probably the wrong pretty-printing for conversion\n \t functions and some function templates.  */\n     case OVERLOAD:\n-      t = OVL_CURRENT (t);\n+      t = OVL_FIRST (t);\n       /* FALLTHRU */\n     case FUNCTION_DECL:\n       if (DECL_FUNCTION_MEMBER_P (t))\n@@ -350,7 +350,7 @@ void\n cxx_pretty_printer::id_expression (tree t)\n {\n   if (TREE_CODE (t) == OVERLOAD)\n-    t = OVL_CURRENT (t);\n+    t = OVL_FIRST (t);\n   if (DECL_P (t) && DECL_CONTEXT (t))\n     pp_cxx_qualified_id (this, t);\n   else\n@@ -1066,7 +1066,7 @@ cxx_pretty_printer::expression (tree t)\n       break;\n \n     case OVERLOAD:\n-      t = OVL_CURRENT (t);\n+      t = OVL_FIRST (t);\n       /* FALLTHRU */\n     case VAR_DECL:\n     case PARM_DECL:"}, {"sha": "3e8815459f76ce7feecebd143fc1b2d646b081ee", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a736411aca6ab397d453e4ec8613933d3b304ac2", "patch": "@@ -608,18 +608,12 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   if (ix >= 0)\n     {\n       vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (ctype);\n-      tree fndecls, fndecl = 0;\n-      bool is_conv_op;\n-      const char *format = NULL;\n \n-      for (fndecls = (*methods)[ix];\n-\t   fndecls; fndecls = OVL_NEXT (fndecls))\n+      for (ovl_iterator iter ((*methods)[ix]); iter; ++iter)\n \t{\n-\t  tree p1, p2;\n-\n-\t  fndecl = OVL_CURRENT (fndecls);\n-\t  p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n-\t  p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+\t  tree fndecl = *iter;\n+\t  tree p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n+\t  tree p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n \n \t  /* We cannot simply call decls_match because this doesn't\n \t     work for static member functions that are pretending to\n@@ -662,49 +656,47 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t      && (!DECL_TEMPLATE_SPECIALIZATION (function)\n \t\t  || (DECL_TI_TEMPLATE (function)\n \t\t      == DECL_TI_TEMPLATE (fndecl))))\n-\t    break;\n-\t}\n-      if (fndecls)\n-\t{\n-\t  if (pushed_scope)\n-\t    pop_scope (pushed_scope);\n-\t  return OVL_CURRENT (fndecls);\n+\t    {\n+\t      if (pushed_scope)\n+\t\tpop_scope (pushed_scope);\n+\t      return fndecl;\n+\t    }\n \t}\n-      \n+\n       error_at (DECL_SOURCE_LOCATION (function),\n \t\t\"prototype for %q#D does not match any in class %qT\",\n \t\tfunction, ctype);\n-      is_conv_op = DECL_CONV_FN_P (fndecl);\n+\n+      const char *format = NULL;\n+      tree first = OVL_FIRST ((*methods)[ix]);\n+      bool is_conv_op = DECL_CONV_FN_P (first);\n+      tree prev = NULL_TREE;\n \n       if (is_conv_op)\n \tix = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-      fndecls = (*methods)[ix];\n-      while (fndecls)\n+      do\n \t{\n-\t  fndecl = OVL_CURRENT (fndecls);\n-\t  fndecls = OVL_NEXT (fndecls);\n-\n-\t  if (!fndecls && is_conv_op)\n+\t  ovl_iterator iter ((*methods)[ix++]);\n+\t  if (is_conv_op && !DECL_CONV_FN_P (*iter))\n+\t    break;\n+\t  for (; iter; ++iter)\n \t    {\n-\t      if (methods->length () > (size_t) ++ix)\n+\t      if (prev)\n \t\t{\n-\t\t  fndecls = (*methods)[ix];\n-\t\t  if (!DECL_CONV_FN_P (OVL_CURRENT (fndecls)))\n-\t\t    {\n-\t\t      fndecls = NULL_TREE;\n-\t\t      is_conv_op = false;\n-\t\t    }\n+\t\t  if (!format)\n+\t\t    format = N_(\"candidates are: %+#D\");\n+\t\t  error (format, prev);\n+\t\t  format = \"                %+#D\";\n \t\t}\n-\t      else\n-\t\tis_conv_op = false;\n+\t      prev = *iter;\n \t    }\n-\t  if (format)\n-\t    format = \"                %+#D\";\n-\t  else if (fndecls)\n-\t    format = N_(\"candidates are: %+#D\");\n-\t  else\n+\t}\n+      while (is_conv_op && size_t (ix) < methods->length ());\n+      if (prev)\n+\t{\n+\t  if (!format)\n \t    format = N_(\"candidate is: %+#D\");\n-\t  error (format, fndecl);\n+\t  error (format, prev);\n \t}\n     }\n   else if (!COMPLETE_TYPE_P (ctype))"}, {"sha": "5fc47abf46f0bca6f37215120b6a9785f5c9bbcb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a736411aca6ab397d453e4ec8613933d3b304ac2", "patch": "@@ -1187,31 +1187,25 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n \n   if (optimize_specialization_lookup_p (tmpl))\n     {\n-      tree class_template;\n-      tree class_specialization;\n-      vec<tree, va_gc> *methods;\n-      tree fns;\n-      int idx;\n-\n       /* The template arguments actually apply to the containing\n \t class.  Find the class specialization with those\n \t arguments.  */\n-      class_template = CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (tmpl));\n-      class_specialization\n+      tree class_template = CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (tmpl));\n+      tree class_specialization\n \t= retrieve_specialization (class_template, args, 0);\n       if (!class_specialization)\n \treturn NULL_TREE;\n       /* Now, find the appropriate entry in the CLASSTYPE_METHOD_VEC\n \t for the specialization.  */\n-      idx = class_method_index_for_fn (class_specialization, tmpl);\n+      int idx = class_method_index_for_fn (class_specialization, tmpl);\n       if (idx == -1)\n \treturn NULL_TREE;\n       /* Iterate through the methods with the indicated name, looking\n \t for the one that has an instance of TMPL.  */\n-      methods = CLASSTYPE_METHOD_VEC (class_specialization);\n-      for (fns = (*methods)[idx]; fns; fns = OVL_NEXT (fns))\n+      vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (class_specialization);\n+      for (ovl_iterator iter ((*methods)[idx]); iter; ++iter)\n \t{\n-\t  tree fn = OVL_CURRENT (fns);\n+\t  tree fn = *iter;\n \t  if (DECL_TEMPLATE_INFO (fn) && DECL_TI_TEMPLATE (fn) == tmpl\n \t      /* using-declarations can add base methods to the method vec,\n \t\t and we don't want those here.  */"}, {"sha": "83dd7a3f2a7f11f441b704fb2ea533f70babeaf3", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a736411aca6ab397d453e4ec8613933d3b304ac2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a736411aca6ab397d453e4ec8613933d3b304ac2", "patch": "@@ -3403,9 +3403,16 @@ cp_tree_equal (tree t1, tree t2)\n       return same_type_p (PTRMEM_CST_CLASS (t1), PTRMEM_CST_CLASS (t2));\n \n     case OVERLOAD:\n-      if (OVL_FUNCTION (t1) != OVL_FUNCTION (t2))\n-\treturn false;\n-      return cp_tree_equal (OVL_CHAIN (t1), OVL_CHAIN (t2));\n+      {\n+\t/* Two overloads. Must be exactly the same set of decls.  */\n+\tlkp_iterator first (t1);\n+\tlkp_iterator second (t2);\n+\n+\tfor (; first && second; ++first, ++second)\n+\t  if (*first != *second)\n+\t    return false;\n+\treturn !(first || second);\n+      }\n \n     case TRAIT_EXPR:\n       if (TRAIT_EXPR_KIND (t1) != TRAIT_EXPR_KIND (t2))\n@@ -3682,9 +3689,9 @@ type_has_nontrivial_copy_init (const_tree type)\n \t}\n \n       if (!saw_non_deleted && CLASSTYPE_METHOD_VEC (t))\n-\tfor (tree fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+\tfor (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n \t  {\n-\t    tree fn = OVL_CURRENT (fns);\n+\t    tree fn = *iter;\n \t    if (copy_fn_p (fn))\n \t      {\n \t\tsaw_copy = true;"}]}