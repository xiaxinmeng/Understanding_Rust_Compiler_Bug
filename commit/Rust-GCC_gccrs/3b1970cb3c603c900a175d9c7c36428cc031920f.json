{"sha": "3b1970cb3c603c900a175d9c7c36428cc031920f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IxOTcwY2IzYzYwM2M5MDBhMTc1ZDljN2MzNjQyOGNjMDMxOTIwZg==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2016-12-14T09:10:31Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2016-12-14T09:10:31Z"}, "message": "tree-ssa-strlen.c (fold_strstr_to_memcmp): New function.\n\n2016-12-14  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\t* tree-ssa-strlen.c (fold_strstr_to_memcmp): New function.\n\t(strlen_optimize_stmt): Call fold_strstr_to_memcmp.\n\ntestsuite/\n\t* gcc.dg/strlenopt-30.c: New test-case.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r243633", "tree": {"sha": "87482185bbedc0d7800e5662413a0b59a40d0755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87482185bbedc0d7800e5662413a0b59a40d0755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b1970cb3c603c900a175d9c7c36428cc031920f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b1970cb3c603c900a175d9c7c36428cc031920f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b1970cb3c603c900a175d9c7c36428cc031920f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b1970cb3c603c900a175d9c7c36428cc031920f/comments", "author": null, "committer": null, "parents": [{"sha": "164f063463d64a1575841d6735ba0298605c4626", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/164f063463d64a1575841d6735ba0298605c4626", "html_url": "https://github.com/Rust-GCC/gccrs/commit/164f063463d64a1575841d6735ba0298605c4626"}], "stats": {"total": 183, "additions": 182, "deletions": 1}, "files": [{"sha": "93235608438f6a4d2e995c8bd1895fb2a6ffb472", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b1970cb3c603c900a175d9c7c36428cc031920f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b1970cb3c603c900a175d9c7c36428cc031920f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b1970cb3c603c900a175d9c7c36428cc031920f", "patch": "@@ -1,3 +1,9 @@\n+2016-12-14  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-ssa-strlen.c (fold_strstr_to_memcmp): New function.\n+\t(strlen_optimize_stmt): Call fold_strstr_to_memcmp.\n+\n 2016-12-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* lra-constraints.c (process_address_1): Do not attempt to decompose"}, {"sha": "d37ce76f9059156a4dca1eec4ea77cb2c9d30f50", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b1970cb3c603c900a175d9c7c36428cc031920f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b1970cb3c603c900a175d9c7c36428cc031920f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b1970cb3c603c900a175d9c7c36428cc031920f", "patch": "@@ -1,3 +1,8 @@\n+2016-12-14  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/strlenopt-30.c: New test-case.\n+\n 2016-12-14  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/78788"}, {"sha": "089b3a2341dab773955965302b81b4dc059936ae", "filename": "gcc/testsuite/gcc.dg/strlenopt-30.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b1970cb3c603c900a175d9c7c36428cc031920f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b1970cb3c603c900a175d9c7c36428cc031920f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-30.c?ref=3b1970cb3c603c900a175d9c7c36428cc031920f", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+__attribute__((no_icf))\n+_Bool f1(char *s)\n+{\n+  return __builtin_strstr (s, \"hello\") == s;\n+}\n+\n+__attribute__((no_icf))\n+_Bool f2(char *s)\n+{\n+  return s == __builtin_strstr (s, \"hello\");\n+}\n+\n+__attribute__((no_icf))\n+_Bool f3(char *s)\n+{\n+  return s != __builtin_strstr (s, \"hello\");\n+}\n+\n+__attribute__((no_icf))\n+_Bool f4()\n+{\n+  char *foo_f4(void);\n+  char *t1 = foo_f4();\n+  char *t2 = __builtin_strstr (t1, \"hello\");\n+  _Bool t3 = t2 == t1;\n+  return t3;\n+}\n+\n+__attribute__((no_icf))\n+void f5(char *s)\n+{\n+  char *t1 = __builtin_strstr (s, \"hello\");\n+  void foo_f5(void);\n+  if (t1 != s)\n+    foo_f5();\n+}\n+\n+/* Do not perform transform, since strlen (t)\n+   is unknown.  */\n+\n+__attribute__((no_icf))\n+_Bool f6(char *s, char *t)\n+{\n+  return __builtin_strstr (s, t) == s;\n+}\n+\n+/* Do not perform transform in this case, since\n+   t1 doesn't have single use.  */\n+\n+__attribute__((no_icf))\n+_Bool f7(char *s)\n+{\n+  void foo_f7(char *);\n+\n+  char *t1 = __builtin_strstr (s, \"hello\");\n+  foo_f7 (t1);\n+  return (t1 == s);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_memcmp\" 5 \"strlen\" } } */"}, {"sha": "67075f07e2962726c5585431ffe8f4aabf8efa7f", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b1970cb3c603c900a175d9c7c36428cc031920f/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b1970cb3c603c900a175d9c7c36428cc031920f/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=3b1970cb3c603c900a175d9c7c36428cc031920f", "patch": "@@ -2222,6 +2222,90 @@ handle_char_store (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n+/* Try to fold strstr (s, t) eq/ne s to memcmp (s, t, strlen (t)) eq/ne 0.  */\n+\n+static void\n+fold_strstr_to_memcmp (tree rhs1, tree rhs2, gimple *stmt)\n+{\n+  if (TREE_CODE (rhs1) != SSA_NAME\n+      || TREE_CODE (rhs2) != SSA_NAME)\n+    return;\n+\n+  gimple *call_stmt = NULL;\n+  for (int pass = 0; pass < 2; pass++)\n+    {\n+      gimple *g = SSA_NAME_DEF_STMT (rhs1);\n+      if (gimple_call_builtin_p (g, BUILT_IN_STRSTR)\n+\t  && has_single_use (rhs1)\n+\t  && gimple_call_arg (g, 0) == rhs2)\n+\t{\n+\t  call_stmt = g;\n+\t  break;\n+\t}\n+      std::swap (rhs1, rhs2);\n+    }\n+\n+  if (call_stmt)\n+    {\n+      tree arg0 = gimple_call_arg (call_stmt, 0);\n+\n+      if (arg0 == rhs2)\n+\t{\n+\t  tree arg1 = gimple_call_arg (call_stmt, 1);\n+\t  tree arg1_len = NULL_TREE;\n+\t  int idx = get_stridx (arg1);\n+\n+\t  if (idx)\n+\t    {\n+\t      if (idx < 0)\n+\t\targ1_len = build_int_cst (size_type_node, ~idx);\n+\t      else\n+\t\t{\n+\t\t  strinfo *si = get_strinfo (idx);\n+\t\t  if (si)\n+\t\t    arg1_len = get_string_length (si);\n+\t\t}\n+\t    }\n+\n+\t  if (arg1_len != NULL_TREE)\n+\t    {\n+\t      gimple_stmt_iterator gsi = gsi_for_stmt (call_stmt);\n+\t      tree memcmp_decl = builtin_decl_explicit (BUILT_IN_MEMCMP);\n+\t      gcall *memcmp_call = gimple_build_call (memcmp_decl, 3,\n+\t\t\t\t\t\t      arg0, arg1, arg1_len);\n+\t      tree memcmp_lhs = make_ssa_name (integer_type_node);\n+\t      gimple_set_vuse (memcmp_call, gimple_vuse (call_stmt));\n+\t      gimple_call_set_lhs (memcmp_call, memcmp_lhs);\n+\t      gsi_remove (&gsi, true);\n+\t      gsi_insert_before (&gsi, memcmp_call, GSI_SAME_STMT);\n+\t      tree zero = build_zero_cst (TREE_TYPE (memcmp_lhs));\n+\n+\t      if (is_gimple_assign (stmt))\n+\t\t{\n+\t\t  if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+\t\t    {\n+\t\t      tree cond = gimple_assign_rhs1 (stmt);\n+\t\t      TREE_OPERAND (cond, 0) = memcmp_lhs;\n+\t\t      TREE_OPERAND (cond, 1) = zero;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gimple_assign_set_rhs1 (stmt, memcmp_lhs);\n+\t\t      gimple_assign_set_rhs2 (stmt, zero);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcond *cond = as_a<gcond *> (stmt);\n+\t\t  gimple_cond_set_lhs (cond, memcmp_lhs);\n+\t\t  gimple_cond_set_rhs (cond, zero);\n+\t\t}\n+\t      update_stmt (stmt);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Attempt to optimize a single statement at *GSI using string length\n    knowledge.  */\n \n@@ -2302,7 +2386,23 @@ strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  else if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n \t    handle_pointer_plus (gsi);\n \t}\n-      else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n+    else if (TREE_CODE (lhs) == SSA_NAME && INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n+      {\n+\tenum tree_code code = gimple_assign_rhs_code (stmt);\n+\tif (code == COND_EXPR)\n+\t  {\n+\t    tree cond = gimple_assign_rhs1 (stmt);\n+\t    enum tree_code cond_code = TREE_CODE (cond);\n+\n+\t    if (cond_code == EQ_EXPR || cond_code == NE_EXPR)\n+\t      fold_strstr_to_memcmp (TREE_OPERAND (cond, 0),\n+\t\t\t\t     TREE_OPERAND (cond, 1), stmt);\n+\t  }\n+\telse if (code == EQ_EXPR || code == NE_EXPR)\n+\t  fold_strstr_to_memcmp (gimple_assign_rhs1 (stmt),\n+\t\t\t\t gimple_assign_rhs2 (stmt), stmt);\n+      }\n+    else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n \t{\n \t  tree type = TREE_TYPE (lhs);\n \t  if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -2316,6 +2416,13 @@ strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n \t    }\n \t}\n     }\n+  else if (gcond *cond = dyn_cast<gcond *> (stmt))\n+    {\n+      enum tree_code code = gimple_cond_code (cond);\n+      if (code == EQ_EXPR || code == NE_EXPR)\n+\tfold_strstr_to_memcmp (gimple_cond_lhs (stmt),\n+\t\t\t       gimple_cond_rhs (stmt), stmt);\n+    }\n \n   if (gimple_vdef (stmt))\n     maybe_invalidate (stmt);"}]}