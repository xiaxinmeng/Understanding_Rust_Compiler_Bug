{"sha": "515558b8ff520dc07f1014b29e524b8994f73c9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1NTU4YjhmZjUyMGRjMDdmMTAxNGIyOWU1MjRiODk5NGY3M2M5Yg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-03-31T08:57:13Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-03-31T08:57:13Z"}, "message": "tree-ssa-loop-ivopts.c (struct comp_cost): New scrach field.\n\n\n\t* tree-ssa-loop-ivopts.c (struct comp_cost): New scrach field.\n\t(no_cost, infinite_cost): Initialize the new field.\n\t(get_computation_cost_at): Record setup cost.\n\t(determine_use_iv_cost_address): Skip cost computation for sub\n\tuses if we can estimate it without losing accuracy.\n\nFrom-SVN: r234612", "tree": {"sha": "1967f313b30922e5e778e4db78b085e6d6488726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1967f313b30922e5e778e4db78b085e6d6488726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/515558b8ff520dc07f1014b29e524b8994f73c9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515558b8ff520dc07f1014b29e524b8994f73c9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/515558b8ff520dc07f1014b29e524b8994f73c9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515558b8ff520dc07f1014b29e524b8994f73c9b/comments", "author": null, "committer": null, "parents": [{"sha": "efc3536f46d9c96daf1f12b587edc583445c3902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc3536f46d9c96daf1f12b587edc583445c3902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc3536f46d9c96daf1f12b587edc583445c3902"}], "stats": {"total": 65, "additions": 55, "deletions": 10}, "files": [{"sha": "3c783194a94f946a2ec5e7a3336c52c5118542b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515558b8ff520dc07f1014b29e524b8994f73c9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515558b8ff520dc07f1014b29e524b8994f73c9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=515558b8ff520dc07f1014b29e524b8994f73c9b", "patch": "@@ -1,3 +1,11 @@\n+2016-03-31  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (struct comp_cost): New scrach field.\n+\t(no_cost, infinite_cost): Initialize the new field.\n+\t(get_computation_cost_at): Record setup cost.\n+\t(determine_use_iv_cost_address): Skip cost computation for sub\n+\tuses if we can estimate it without losing accuracy.\n+\n 2016-03-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree-ssa-loop-niter.c (idx_infer_loop_bounds): We can't get realistic"}, {"sha": "c8a8406134fd894fa1e47e021eb7e0b36bbf160e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515558b8ff520dc07f1014b29e524b8994f73c9b/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515558b8ff520dc07f1014b29e524b8994f73c9b/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=515558b8ff520dc07f1014b29e524b8994f73c9b", "patch": "@@ -172,10 +172,11 @@ struct comp_cost\n \t\t\t   the computation (in no concrete units --\n \t\t\t   complexity field should be larger for more\n \t\t\t   complex expressions and addressing modes).  */\n+  int scratch;\t\t/* Scratch used during cost computation.  */\n };\n \n-static const comp_cost no_cost = {0, 0};\n-static const comp_cost infinite_cost = {INFTY, INFTY};\n+static const comp_cost no_cost = {0, 0, 0};\n+static const comp_cost infinite_cost = {INFTY, INFTY, INFTY};\n \n /* The candidate - cost pair.  */\n struct cost_pair\n@@ -4953,6 +4954,8 @@ get_computation_cost_at (struct ivopts_data *data,\n       cost.cost += add_cost (data->speed, TYPE_MODE (ctype));\n     }\n \n+  /* Record setup cost in scrach field.  */\n+  cost.scratch = cost.cost;\n   /* Set of invariants depended on by sub use has already been computed\n      for the first use in the group.  */\n   if (use->sub_id)\n@@ -5088,12 +5091,12 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n \t\t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   bitmap depends_on;\n-  bool can_autoinc;\n+  bool can_autoinc, first;\n   int inv_expr_id = -1;\n   struct iv_use *sub_use;\n-  comp_cost sub_cost;\n   comp_cost cost = get_computation_cost (data, use, cand, true, &depends_on,\n \t\t\t\t\t &can_autoinc, &inv_expr_id);\n+  comp_cost sub_cost = cost;\n \n   if (cand->ainc_use == use)\n     {\n@@ -5105,13 +5108,47 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n       else if (cand->pos == IP_AFTER_USE || cand->pos == IP_BEFORE_USE)\n \tcost = infinite_cost;\n     }\n-  for (sub_use = use->next;\n-       sub_use && !infinite_cost_p (cost);\n-       sub_use = sub_use->next)\n+\n+  if (!infinite_cost_p (cost) && use->next)\n     {\n-      sub_cost = get_computation_cost (data, sub_use, cand, true, NULL,\n-\t\t\t\t       &can_autoinc, NULL);\n-      cost = add_costs (cost, sub_cost);\n+      first = true;\n+      sub_use = use->next;\n+      /* We don't want to add setup cost for sub-uses.  */\n+      sub_cost.cost -= sub_cost.scratch;\n+      /* Add cost for sub uses in group.  */\n+      do\n+\t{\n+\t  /* Compute cost for the first sub use with different offset to\n+\t     the main use and add it afterwards.  Costs for these uses\n+\t     could be quite different.  Given below uses in a group:\n+\t       use 0  : {base + A + offset_0, step}\n+\t       use 0.1: {base + A + offset_0, step}\n+\t       use 0.2: {base + A + offset_1, step}\n+\t       use 0.3: {base + A + offset_2, step}\n+\t     when we need to compute costs with candidate:\n+\t       cand 1 : {base + B + offset_0, step}\n+\n+\t     The first sub use with different offset is use 0.2, its cost\n+\t     is larger than cost of use 0/0.1 because we need to compute:\n+\t       A - B + offset_1 - offset_0\n+\t     rather than:\n+\t       A - B.  */\n+\t  if (first && use->addr_offset != sub_use->addr_offset)\n+\t    {\n+\t      first = false;\n+\t      sub_cost = get_computation_cost (data, sub_use, cand, true,\n+\t\t\t\t\t       NULL, &can_autoinc, NULL);\n+\t      if (infinite_cost_p (sub_cost))\n+\t\t{\n+\t\t  cost = infinite_cost;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  cost = add_costs (cost, sub_cost);\n+\t  sub_use = sub_use->next;\n+\t}\n+      while (sub_use);\n     }\n \n   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE, ERROR_MARK,"}]}