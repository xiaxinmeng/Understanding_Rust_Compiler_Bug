{"sha": "f53e9d40de7212413b361758d66aafb833173dd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUzZTlkNDBkZTcyMTI0MTNiMzYxNzU4ZDY2YWFmYjgzMzE3M2RkOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-03T08:53:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-03T08:56:40Z"}, "message": "tree-optimization/97678 - fix SLP induction epilogue vectorization\n\nThis restores not tracking SLP nodes for induction initial values\nin not nested context because this interferes with peeling and\nepilogue vectorization.\n\n2020-11-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97678\n\t* tree-vect-slp.c (vect_build_slp_tree_2): Do not track\n\tthe initial values of inductions when not nested.\n\t* tree-vect-loop.c (vectorizable_induction): Look at\n\tPHI node initial values again for SLP and not nested\n\tinductions.  Handle LOOP_VINFO_MASK_SKIP_NITERS and cost\n\tinvariants.\n\n\t* gcc.dg/vect/pr97678.c: New testcase.", "tree": {"sha": "344ff015118255a0f995d91c1b975dba80207786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/344ff015118255a0f995d91c1b975dba80207786"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f53e9d40de7212413b361758d66aafb833173dd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f53e9d40de7212413b361758d66aafb833173dd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f53e9d40de7212413b361758d66aafb833173dd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f53e9d40de7212413b361758d66aafb833173dd9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0caf400a865cb771f76bf1025cfc2a83e8ef00ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0caf400a865cb771f76bf1025cfc2a83e8ef00ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0caf400a865cb771f76bf1025cfc2a83e8ef00ed"}], "stats": {"total": 86, "additions": 79, "deletions": 7}, "files": [{"sha": "ebe4a35bb3f17b3c95018d04cc8880fd4a3f3be5", "filename": "gcc/testsuite/gcc.dg/vect/pr97678.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f53e9d40de7212413b361758d66aafb833173dd9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97678.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f53e9d40de7212413b361758d66aafb833173dd9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97678.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97678.c?ref=f53e9d40de7212413b361758d66aafb833173dd9", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-mavx2\" { target avx2_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+int\n+main ()\n+{\n+  unsigned int i = 0;\n+  unsigned short b[158 * 2];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 158; i++)\n+    {\n+      b[i * 2] = i * 7;\n+      b[i * 2 + 1] = i * 8;\n+    }\n+\n+  for (i = 0; i < 158; ++i)\n+    if (b[i*2] != (unsigned short)(i*7)\n+        || b[i*2+1] != (unsigned short)(i*8))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* The init loop should be vectorized with SLP.  */\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */"}, {"sha": "6fa185daa2836062814f9c9a6659011a3153c6a2", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f53e9d40de7212413b361758d66aafb833173dd9/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f53e9d40de7212413b361758d66aafb833173dd9/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f53e9d40de7212413b361758d66aafb833173dd9", "patch": "@@ -7800,6 +7800,10 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t    = record_stmt_cost (cost_vec,\n \t\t\t\tSLP_TREE_NUMBER_OF_VEC_STMTS (slp_node),\n \t\t\t\tvector_stmt, stmt_info, 0, vect_body);\n+\t  /* prologue cost for vec_init (if not nested) and step.  */\n+\t  prologue_cost = record_stmt_cost (cost_vec, 1 + !nested_in_vect_loop,\n+\t\t\t\t\t    scalar_to_vec,\n+\t\t\t\t\t    stmt_info, 0, vect_prologue);\n \t}\n       else /* if (!slp_node) */\n \t{\n@@ -7858,9 +7862,15 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t cycles we have to reconstruct the step from SCEV data.  */\n       unsigned group_size = SLP_TREE_LANES (slp_node);\n       tree *steps = XALLOCAVEC (tree, group_size);\n+      tree *inits = XALLOCAVEC (tree, group_size);\n       stmt_vec_info phi_info;\n       FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (slp_node), i, phi_info)\n-\tsteps[i] = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (phi_info);\n+\t{\n+\t  steps[i] = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (phi_info);\n+\t  if (!init_node)\n+\t    inits[i] = gimple_phi_arg_def (as_a<gphi *> (phi_info->stmt),\n+\t\t\t\t\t   pe->dest_idx);\n+\t}\n \n       /* Now generate the IVs.  */\n       unsigned nvects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n@@ -7875,27 +7885,55 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t\t\t\t ? build_real_from_wide (stept, lup_mul,\n \t\t\t\t\t\t\t UNSIGNED)\n \t\t\t\t : build_int_cstu (stept, lup_mul));\n+      tree peel_mul = NULL_TREE;\n+      if (LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo))\n+\t{\n+\t  stmts = NULL;\n+\t  if (SCALAR_FLOAT_TYPE_P (stept))\n+\t    peel_mul = gimple_build (&stmts, FLOAT_EXPR, stept,\n+\t\t\t\t     LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo));\n+\t  else\n+\t    peel_mul = gimple_convert (&stmts, stept,\n+\t\t\t\t       LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo));\n+\t  peel_mul = gimple_build_vector_from_val (&stmts, step_vectype, peel_mul);\n+\t  if (stmts)\n+\t    {\n+\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t      gcc_assert (!new_bb);\n+\t    }\n+\t}\n       unsigned ivn;\n       auto_vec<tree> vec_steps;\n       for (ivn = 0; ivn < nivs; ++ivn)\n \t{\n-\t  tree_vector_builder elts (step_vectype, const_nunits, 1);\n+\t  tree_vector_builder step_elts (step_vectype, const_nunits, 1);\n+\t  tree_vector_builder init_elts (vectype, const_nunits, 1);\n \t  tree_vector_builder mul_elts (step_vectype, const_nunits, 1);\n \t  for (unsigned eltn = 0; eltn < const_nunits; ++eltn)\n \t    {\n \t      tree elt = steps[(ivn*const_nunits + eltn) % group_size];\n-\t      elts.quick_push (elt);\n+\t      step_elts.quick_push (elt);\n+\t      if (!init_node)\n+\t\t{\n+\t\t  elt = inits[(ivn*const_nunits + eltn) % group_size];\n+\t\t  init_elts.quick_push (elt);\n+\t\t}\n \t      unsigned mul_elt = (ivn*const_nunits + eltn) / group_size;\n \t      mul_elts.quick_push (SCALAR_FLOAT_TYPE_P (stept)\n \t\t\t\t   ? build_real_from_wide (stept,\n \t\t\t\t\t\t\t   mul_elt, UNSIGNED)\n \t\t\t\t   : build_int_cstu (stept, mul_elt));\n \t    }\n \t  stmts = NULL;\n-\t  vec_step = gimple_build_vector (&stmts, &elts);\n+\t  vec_step = gimple_build_vector (&stmts, &step_elts);\n \t  vec_step = gimple_convert (&stmts, step_vectype, vec_step);\n \t  vec_steps.safe_push (vec_step);\n \t  tree step_mul = gimple_build_vector (&stmts, &mul_elts);\n+\t  if (peel_mul)\n+\t    gimple_build (&stmts, PLUS_EXPR, step_vectype,\n+\t\t\t  step_mul, peel_mul);\n+\t  if (!init_node)\n+\t    vec_init = gimple_build_vector (&stmts, &init_elts);\n \t  if (stmts)\n \t    {\n \t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n@@ -7926,7 +7964,8 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n \t\t       UNKNOWN_LOCATION);\n \n-\t  vec_init = vect_get_slp_vect_def (init_node, ivn);\n+\t  if (init_node)\n+\t    vec_init = vect_get_slp_vect_def (init_node, ivn);\n \t  if (!integer_zerop (step_mul))\n \t    {\n \t      stmts = NULL;"}, {"sha": "e97fbe897a76008d50ee94c3b1b009344cc37d4a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f53e9d40de7212413b361758d66aafb833173dd9/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f53e9d40de7212413b361758d66aafb833173dd9/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f53e9d40de7212413b361758d66aafb833173dd9", "patch": "@@ -1444,9 +1444,13 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \tif (def_type == vect_induction_def)\n \t  {\n \t    /* Induction PHIs are not cycles but walk the initial\n-\t       value.  */\n+\t       value.  Only for inner loops through, for outer loops\n+\t       we need to pick up the value from the actual PHIs\n+\t       to more easily support peeling and epilogue vectorization.  */\n \t    class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-\t    if (nested_in_vect_loop_p (loop, stmt_info))\n+\t    if (!nested_in_vect_loop_p (loop, stmt_info))\n+\t      skip_args[loop_preheader_edge (loop)->dest_idx] = true;\n+\t    else\n \t      loop = loop->inner;\n \t    skip_args[loop_latch_edge (loop)->dest_idx] = true;\n \t  }"}]}