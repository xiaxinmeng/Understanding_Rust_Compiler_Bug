{"sha": "b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFjMWQ3NjFjMWRiNDFkOTRlNjc5MWMwYjRmOGE0NzZlOTFmYTY3MQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2015-11-21T16:25:23Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2015-11-21T16:25:23Z"}, "message": "simplify.c (gfc_simplify_cshift): Implement simplification of CSHIFT.\n\n2015-11-21  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\t* simplify.c (gfc_simplify_cshift): Implement simplification of CSHIFT.\n\t(gfc_simplify_spread): Remove a FIXME and add error condition.\n\t* intrinsic.h: Prototype for gfc_simplify_cshift\n\t* intrinsic.c (add_functions): Use gfc_simplify_cshift.\n \n2015-11-21  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\t* gfortran.dg/simplify_cshift_1.f90: New test.\n\nFrom-SVN: r230709", "tree": {"sha": "6c2e1fd6488ddc49dce31cef0d3fa88c4d1e95f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c2e1fd6488ddc49dce31cef0d3fa88c4d1e95f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/comments", "author": null, "committer": null, "parents": [{"sha": "d43e15a4243b9e3436fcfa9f38e4d0df9af63074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43e15a4243b9e3436fcfa9f38e4d0df9af63074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43e15a4243b9e3436fcfa9f38e4d0df9af63074"}], "stats": {"total": 164, "additions": 157, "deletions": 7}, "files": [{"sha": "1d11ae74ff20f1e6423aae654bd539ce2b079151", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "patch": "@@ -1,3 +1,11 @@\n+2015-11-21  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* simplify.c (gfc_simplify_cshift): Implement simplification of\n+\tCSHIFT for rank=1 arrays.\n+\t(gfc_simplify_spread): Remove a FIXME and add error condition.\n+\t* intrinsic.h: Prototype for gfc_simplify_cshift\n+\t* intrinsic.c (add_functions): Use gfc_simplify_cshift.\n+ \n 2015-11-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68237"}, {"sha": "4e6a0d0e34ae4e2ca2413b7d3d51cf652c9f7108", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "patch": "@@ -1659,9 +1659,11 @@ add_functions (void)\n \n   make_generic (\"count\", GFC_ISYM_COUNT, GFC_STD_F95);\n \n-  add_sym_3 (\"cshift\", GFC_ISYM_CSHIFT, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-\t     gfc_check_cshift, NULL, gfc_resolve_cshift,\n-\t     ar, BT_REAL, dr, REQUIRED, sh, BT_INTEGER, di, REQUIRED,\n+  add_sym_3 (\"cshift\", GFC_ISYM_CSHIFT, CLASS_TRANSFORMATIONAL, ACTUAL_NO,\n+\t     BT_REAL, dr, GFC_STD_F95,\n+\t     gfc_check_cshift, gfc_simplify_cshift, gfc_resolve_cshift,\n+\t     ar, BT_REAL, dr, REQUIRED,\n+\t     sh, BT_INTEGER, di, REQUIRED,\n \t     dm, BT_INTEGER, ii, OPTIONAL);\n \n   make_generic (\"cshift\", GFC_ISYM_CSHIFT, GFC_STD_F95);"}, {"sha": "ca2ad306e0d4bc79225a50e4e1779bf854c8ec91", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "patch": "@@ -271,6 +271,7 @@ gfc_expr *gfc_simplify_conjg (gfc_expr *);\n gfc_expr *gfc_simplify_cos (gfc_expr *);\n gfc_expr *gfc_simplify_cosh (gfc_expr *);\n gfc_expr *gfc_simplify_count (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dcmplx (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dble (gfc_expr *);\n gfc_expr *gfc_simplify_digits (gfc_expr *);"}, {"sha": "9886d9e20e6c6a9f80c5365ef1db3ac5ce920605", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 93, "deletions": 4, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "patch": "@@ -1788,6 +1788,94 @@ gfc_simplify_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n+gfc_expr *\n+gfc_simplify_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n+{\n+  gfc_expr *a, *result;\n+  int dm;\n+\n+  /* DIM is only useful for rank > 1, but deal with it here as one can\n+     set DIM = 1 for rank = 1.  */\n+  if (dim)\n+    {\n+      if (!gfc_is_constant_expr (dim))\n+\treturn NULL;\n+      dm = mpz_get_si (dim->value.integer);\n+    }\n+  else\n+    dm = 1;\n+\n+  /* Copy array into 'a', simplify it, and then test for a constant array.\n+     An unexpected expr_type causes an ICE.   */\n+  switch (array->expr_type)\n+    {\n+      case EXPR_VARIABLE:\n+      case EXPR_ARRAY:\n+\ta = gfc_copy_expr (array);\n+\tgfc_simplify_expr (a, 0);\n+\tif (!is_constant_array_expr (a))\n+\t  {\n+\t    gfc_free_expr (a);\n+\t    return NULL;\n+\t  }\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  if (a->rank == 1)\n+    {\n+      gfc_constructor *ca, *cr;\n+      mpz_t size;\n+      int i, j, shft, sz;\n+\n+      if (!gfc_is_constant_expr (shift))\n+\t{\n+\t  gfc_free_expr (a);\n+\t  return NULL;\n+\t}\n+\n+      shft = mpz_get_si (shift->value.integer);\n+\n+      /*  Case (i):  If ARRAY has rank one, element i of the result is\n+\t  ARRAY (1 + MODULO (i + SHIFT - 1, SIZE (ARRAY))).  */\n+\n+      mpz_init (size);\n+      gfc_array_size (a, &size);\n+      sz = mpz_get_si (size);\n+      mpz_clear (size);\n+\n+      /* Adjust shft to deal with right or left shifts. */\n+      shft = shft < 0 ? 1 - shft : shft;\n+\n+      /* Special case: Shift to the original order!  */\n+      if (shft % sz == 0)\n+\treturn a;\n+\n+      result = gfc_copy_expr (a);\n+      cr = gfc_constructor_first (result->value.constructor);\n+      for (i = 0; i < sz; i++, cr = gfc_constructor_next (cr))\n+\t{\n+\t  j = (i + shft) % sz;\n+\t  ca = gfc_constructor_first (a->value.constructor);\n+\t  while (j-- > 0)\n+\t    ca = gfc_constructor_next (ca);\n+\t  cr->expr = gfc_copy_expr (ca->expr);\n+\t}\n+\n+      gfc_free_expr (a);\n+      return result;\n+    }\n+  else\n+    {\n+      /* FIXME: Deal with rank > 1 arrays.  For now, don't leak memory.  */\n+      gfc_free_expr (a);\n+    }\n+\n+  return NULL;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_dcmplx (gfc_expr *x, gfc_expr *y)\n {\n@@ -6089,10 +6177,11 @@ gfc_simplify_spread (gfc_expr *source, gfc_expr *dim_expr, gfc_expr *ncopies_exp\n \t}\n     }\n   else\n-    /* FIXME: Returning here avoids a regression in array_simplify_1.f90.\n-       Replace NULL with gcc_unreachable() after implementing\n-       gfc_simplify_cshift().  */\n-    return NULL;\n+    {\n+      gfc_error (\"Simplification of SPREAD at %L not yet implemented\",\n+\t\t &source->where);\n+      return &gfc_bad_expr;\n+    }\n \n   if (source->ts.type == BT_CHARACTER)\n     result->ts.u.cl = source->ts.u.cl;"}, {"sha": "10ef5c28246900d297ec0ee6287a64cd8d5ef236", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "patch": "@@ -1,3 +1,7 @@\n+2015-11-21  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* gfortran.dg/simplify_cshift_1.f90: New test.\n+\n 2015-11-21  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcc.dg/atomic-generic.c: Include <string.h>."}, {"sha": "dbe67f4c8e9a032890b3a260fab07b77f77da423", "filename": "gcc/testsuite/gfortran.dg/simplify_cshift_1.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c1d761c1db41d94e6791c0b4f8a476e91fa671/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_1.f90?ref=b1c1d761c1db41d94e6791c0b4f8a476e91fa671", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+program foo\n+\n+   implicit none\n+   \n+   type t\n+      integer i\n+   end type t\n+\n+   type(t), parameter :: d(5) = [t(1), t(2), t(3), t(4), t(5)]\n+   type(t) e(5), q(5)\n+\n+   integer, parameter :: a(5) = [1, 2, 3, 4, 5]\n+   integer i, b(5), c(5), v(5)\n+\n+   c = [1, 2, 3, 4, 5]\n+\n+   b = cshift(a, -2)\n+   v = cshift(c, -2)\n+   if (any(b /= v)) call abort\n+\n+   b = cshift(a, 2)\n+   v = cshift(c, 2)\n+   if (any(b /= v)) call abort\n+\n+   ! Special cases shift = 0, size(a), 1-size(a)\n+   b = cshift([1, 2, 3, 4, 5], 0)\n+   if (any(b /= a)) call abort\n+   b = cshift([1, 2, 3, 4, 5], size(a))\n+   if (any(b /= a)) call abort\n+   b = cshift([1, 2, 3, 4, 5], 1-size(a))\n+   if (any(b /= a)) call abort\n+\n+   ! simplification of array arg.\n+   b = cshift(2 * a, 0)\n+   if (any(b /= 2 * a)) call abort\n+\n+   ! An array of derived types works too.\n+   e = [t(1), t(2), t(3), t(4), t(5)]\n+   e = cshift(e, 3)\n+   q = cshift(d, 3)\n+   do i = 1, 5\n+      if (e(i)%i /= q(i)%i) call abort\n+   end do\n+\n+end program foo"}]}