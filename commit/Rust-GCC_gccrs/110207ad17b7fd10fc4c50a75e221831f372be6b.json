{"sha": "110207ad17b7fd10fc4c50a75e221831f372be6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwMjA3YWQxN2I3ZmQxMGZjNGM1MGE3NWUyMjE4MzFmMzcyYmU2Yg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2013-02-15T13:53:40Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2013-02-15T13:53:40Z"}, "message": "re PR target/55431 (Invalid auxv search in ppc linux-unwind code.)\n\n\tPR target/55431\n\t* config/rs6000/linux-unwind.h (ppc_linux_aux_vector): Delete.\n\t(ppc_fallback_frame_state): Always set up save locations for fp\n\tand altivec.  Don't bother with non-callee-saved regs, r0-r13\n\texcept for r2 on ppc64, fr0-fr13, v0-v19, vscr.\n\nFrom-SVN: r196077", "tree": {"sha": "c410c8f5af39ea8c001ef62fae6399b9fc3f6749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c410c8f5af39ea8c001ef62fae6399b9fc3f6749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/110207ad17b7fd10fc4c50a75e221831f372be6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110207ad17b7fd10fc4c50a75e221831f372be6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/110207ad17b7fd10fc4c50a75e221831f372be6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110207ad17b7fd10fc4c50a75e221831f372be6b/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45e4e1e9585a9a0437c7b7eeaad552b77f9d29b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e4e1e9585a9a0437c7b7eeaad552b77f9d29b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45e4e1e9585a9a0437c7b7eeaad552b77f9d29b3"}], "stats": {"total": 110, "additions": 33, "deletions": 77}, "files": [{"sha": "d4bc8109e7daeb3ec9cc176f9ff567f888c67b3c", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110207ad17b7fd10fc4c50a75e221831f372be6b/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110207ad17b7fd10fc4c50a75e221831f372be6b/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=110207ad17b7fd10fc4c50a75e221831f372be6b", "patch": "@@ -1,3 +1,11 @@\n+2013-02-16  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/55431\n+\t* config/rs6000/linux-unwind.h (ppc_linux_aux_vector): Delete.\n+\t(ppc_fallback_frame_state): Always set up save locations for fp\n+\tand altivec.  Don't bother with non-callee-saved regs, r0-r13\n+\texcept for r2 on ppc64, fr0-fr13, v0-v19, vscr.\n+\n 2013-02-12  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/54222"}, {"sha": "c9273c404e2d00f4642675b5e163b9640057800d", "filename": "libgcc/config/rs6000/linux-unwind.h", "status": "modified", "additions": 25, "deletions": 77, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110207ad17b7fd10fc4c50a75e221831f372be6b/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110207ad17b7fd10fc4c50a75e221831f372be6b/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h?ref=110207ad17b7fd10fc4c50a75e221831f372be6b", "patch": "@@ -26,7 +26,6 @@\n #define R_CR2\t\t70\n #define R_VR0\t\t77\n #define R_VRSAVE\t109\n-#define R_VSCR\t\t110\n \n struct gcc_vregs\n {\n@@ -175,38 +174,6 @@ get_regs (struct _Unwind_Context *context)\n }\n #endif\n \n-/* Find an entry in the process auxiliary vector.  The canonical way to\n-   test for VMX is to look at AT_HWCAP.  */\n-\n-static long\n-ppc_linux_aux_vector (long which)\n-{\n-  /* __libc_stack_end holds the original stack passed to a process.  */\n-  extern long *__libc_stack_end;\n-  long argc;\n-  char **argv;\n-  char **envp;\n-  struct auxv\n-  {\n-    long a_type;\n-    long a_val;\n-  } *auxp;\n-\n-  /* The Linux kernel puts argc first on the stack.  */\n-  argc = __libc_stack_end[0];\n-  /* Followed by argv, NULL terminated.  */\n-  argv = (char **) __libc_stack_end + 1;\n-  /* Followed by environment string pointers, NULL terminated. */\n-  envp = argv + argc + 1;\n-  while (*envp++)\n-    continue;\n-  /* Followed by the aux vector, zero terminated.  */\n-  for (auxp = (struct auxv *) envp; auxp->a_type != 0; ++auxp)\n-    if (auxp->a_type == which)\n-      return auxp->a_val;\n-  return 0;\n-}\n-\n /* Do code reading to identify a signal frame, and set the frame\n    state data appropriately.  See unwind-dw2.c for the structs.  */\n \n@@ -216,8 +183,8 @@ static _Unwind_Reason_Code\n ppc_fallback_frame_state (struct _Unwind_Context *context,\n \t\t\t  _Unwind_FrameState *fs)\n {\n-  static long hwcap = 0;\n   struct gcc_regs *regs = get_regs (context);\n+  struct gcc_vregs *vregs;\n   long new_cfa;\n   int i;\n \n@@ -229,12 +196,15 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n   fs->regs.cfa_reg = STACK_POINTER_REGNUM;\n   fs->regs.cfa_offset = new_cfa - (long) context->cfa;\n \n-  for (i = 0; i < 32; i++)\n-    if (i != STACK_POINTER_REGNUM)\n-      {\n-\tfs->regs.reg[i].how = REG_SAVED_OFFSET;\n-\tfs->regs.reg[i].loc.offset = (long) &regs->gpr[i] - new_cfa;\n-      }\n+#ifdef __powerpc64__\n+  fs->regs.reg[2].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[2].loc.offset = (long) &regs->gpr[2] - new_cfa;\n+#endif\n+  for (i = 14; i < 32; i++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset = (long) &regs->gpr[i] - new_cfa;\n+    }\n \n   fs->regs.reg[R_CR2].how = REG_SAVED_OFFSET;\n   /* CR? regs are always 32-bit and PPC is big-endian, so in 64-bit\n@@ -250,57 +220,35 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n   fs->retaddr_column = ARG_POINTER_REGNUM;\n   fs->signal_frame = 1;\n \n-  if (hwcap == 0)\n+  /* If we have a FPU...  */\n+  for (i = 14; i < 32; i++)\n     {\n-      hwcap = ppc_linux_aux_vector (16);\n-      /* These will already be set if we found AT_HWCAP.  A nonzero\n-\t value stops us looking again if for some reason we couldn't\n-\t find AT_HWCAP.  */\n-#ifdef __powerpc64__\n-      hwcap |= 0xc0000000;\n-#else\n-      hwcap |= 0x80000000;\n-#endif\n+      fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i + 32].loc.offset = (long) &regs->fpr[i] - new_cfa;\n     }\n \n-  /* If we have a FPU...  */\n-  if (hwcap & 0x08000000)\n-    for (i = 0; i < 32; i++)\n-      {\n-\tfs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n-\tfs->regs.reg[i + 32].loc.offset = (long) &regs->fpr[i] - new_cfa;\n-      }\n-\n   /* If we have a VMX unit...  */\n-  if (hwcap & 0x10000000)\n-    {\n-      struct gcc_vregs *vregs;\n #ifdef __powerpc64__\n-      vregs = regs->vp;\n+  vregs = regs->vp;\n #else\n-      vregs = &regs->vregs;\n+  vregs = &regs->vregs;\n #endif\n-      if (regs->msr & (1 << 25))\n+  if (regs->msr & (1 << 25))\n+    {\n+      for (i = 20; i < 32; i++)\n \t{\n-\t  for (i = 0; i < 32; i++)\n-\t    {\n-\t      fs->regs.reg[i + R_VR0].how = REG_SAVED_OFFSET;\n-\t      fs->regs.reg[i + R_VR0].loc.offset\n-\t\t= (long) &vregs->vr[i] - new_cfa;\n-\t    }\n-\n-\t  fs->regs.reg[R_VSCR].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[R_VSCR].loc.offset = (long) &vregs->vscr - new_cfa;\n+\t  fs->regs.reg[i + R_VR0].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[i + R_VR0].loc.offset = (long) &vregs->vr[i] - new_cfa;\n \t}\n-\n-      fs->regs.reg[R_VRSAVE].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[R_VRSAVE].loc.offset = (long) &vregs->vsave - new_cfa;\n     }\n \n+  fs->regs.reg[R_VRSAVE].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[R_VRSAVE].loc.offset = (long) &vregs->vsave - new_cfa;\n+\n   /* If we have SPE register high-parts... we check at compile-time to\n      avoid expanding the code for all other PowerPC.  */\n #ifdef __SPE__\n-  for (i = 0; i < 32; i++)\n+  for (i = 14; i < 32; i++)\n     {\n       fs->regs.reg[i + FIRST_PSEUDO_REGISTER - 1].how = REG_SAVED_OFFSET;\n       fs->regs.reg[i + FIRST_PSEUDO_REGISTER - 1].loc.offset"}]}