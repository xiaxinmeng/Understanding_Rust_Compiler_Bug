{"sha": "9847c2f6771c42f3448fe99ef5bbc1b3499133b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0N2MyZjY3NzFjNDJmMzQ0OGZlOTllZjViYmMxYjM0OTkxMzNiMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-19T20:38:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-19T20:38:15Z"}, "message": "(operand_subword): Fix arg of REAL_VALUE_TO_TARGET_SINGLE and ..._DOUBLE.\n\n(operand_subword): Fix arg of REAL_VALUE_TO_TARGET_SINGLE and\n.._DOUBLE.  Permit float subword extraction when host's word width iswider than target's.\n\nFrom-SVN: r7338", "tree": {"sha": "cfa2a666fb4abf98b5718507c2bb077a95f67c64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfa2a666fb4abf98b5718507c2bb077a95f67c64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9847c2f6771c42f3448fe99ef5bbc1b3499133b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9847c2f6771c42f3448fe99ef5bbc1b3499133b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9847c2f6771c42f3448fe99ef5bbc1b3499133b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9847c2f6771c42f3448fe99ef5bbc1b3499133b0/comments", "author": null, "committer": null, "parents": [{"sha": "2986ae008b26f29b421ee34debbc3113658d0453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2986ae008b26f29b421ee34debbc3113658d0453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2986ae008b26f29b421ee34debbc3113658d0453"}], "stats": {"total": 32, "additions": 18, "deletions": 14}, "files": [{"sha": "32e7fb530a639b5cf64c9bacc44a064cd7256cd1", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9847c2f6771c42f3448fe99ef5bbc1b3499133b0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9847c2f6771c42f3448fe99ef5bbc1b3499133b0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9847c2f6771c42f3448fe99ef5bbc1b3499133b0", "patch": "@@ -1075,30 +1075,35 @@ operand_subword (op, i, validate_address, mode)\n   /* The only remaining cases are when OP is a constant.  If the host and\n      target floating formats are the same, handling two-word floating\n      constants are easy.  Note that REAL_VALUE_TO_TARGET_{SINGLE,DOUBLE}\n-     are defined as returning 32 bit and 64-bit values, respectively,\n-     and not values of BITS_PER_WORD and 2 * BITS_PER_WORD bits.  */\n+     are defined as returning one or two 32 bit values, respectively,\n+     and not values of BITS_PER_WORD bits.  */\n #ifdef REAL_ARITHMETIC\n-  if ((HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n+/*  The output is some bits, the width of the target machine's word.\n+    A wider-word host can surely hold them in a CONST_INT. A narrower-word\n+    host can't.  */\n+  if (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD\n       && GET_MODE_CLASS (mode) == MODE_FLOAT\n       && GET_MODE_BITSIZE (mode) == 64\n       && GET_CODE (op) == CONST_DOUBLE)\n     {\n-      HOST_WIDE_INT k[2];\n+      long k[2];\n       REAL_VALUE_TYPE rv;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n       REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n \n-      /* We handle 32-bit and 64-bit host words here.  Note that the order in\n+      /* We handle 32-bit and >= 64-bit words here.  Note that the order in\n \t which the words are written depends on the word endianness.\n \n \t ??? This is a potential portability problem and should\n \t be fixed at some point.  */\n-      if (HOST_BITS_PER_WIDE_INT == 32)\n-\treturn GEN_INT (k[i]);\n-      else if (HOST_BITS_PER_WIDE_INT == 64 && i == 0)\n-\treturn GEN_INT ((k[! WORDS_BIG_ENDIAN] << (HOST_BITS_PER_WIDE_INT / 2))\n-\t\t\t| k[WORDS_BIG_ENDIAN]);\n+      if (BITS_PER_WORD == 32)\n+\treturn GEN_INT ((HOST_WIDE_INT) k[i]);\n+#if HOST_BITS_PER_WIDE_INT > 32\n+      else if (BITS_PER_WORD >= 64 && i == 0)\n+\treturn GEN_INT ((((HOST_WIDE_INT) k[! WORDS_BIG_ENDIAN]) << 32)\n+\t\t\t| (HOST_WIDE_INT) k[WORDS_BIG_ENDIAN]);\n+#endif\n       else\n \tabort ();\n     }\n@@ -1128,17 +1133,16 @@ operand_subword (op, i, validate_address, mode)\n      values often do not have the same high-order bits.  We have already\n      verified that we want the only defined word of the single-word value.  */\n #ifdef REAL_ARITHMETIC\n-  if ((HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-      && GET_MODE_CLASS (mode) == MODE_FLOAT\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n       && GET_MODE_BITSIZE (mode) == 32\n       && GET_CODE (op) == CONST_DOUBLE)\n     {\n-      HOST_WIDE_INT l;\n+      long l;\n       REAL_VALUE_TYPE rv;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n       REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n-      return GEN_INT (l);\n+      return GEN_INT ((HOST_WIDE_INT) l);\n     }\n #else\n   if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT"}]}