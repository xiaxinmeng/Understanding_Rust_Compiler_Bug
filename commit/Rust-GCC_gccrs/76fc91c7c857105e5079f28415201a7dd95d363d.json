{"sha": "76fc91c7c857105e5079f28415201a7dd95d363d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZmYzkxYzdjODU3MTA1ZTUwNzlmMjg0MTUyMDFhN2RkOTVkMzYzZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-25T19:21:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-25T19:21:27Z"}, "message": "except.h (eh_status): Adjust documentation for x_protect_list.\n\n\t* except.h (eh_status): Adjust documentation for x_protect_list.\n\t(begin_protect_partials): New function.\n\t* except.c (enqueue_eh_entry): Fix formatting.\n\t(get_first_handler): Add consistency check.\n\t(add_partial_entry): Adjust usage of protect_list.\n\t(emit_cleanup_handler): Save and restore ehqueue.\n\t(expand_start_all_catch): Add comment.\n\t(begin_protect_partials): New function.\n\t(end_protect_partials): Adjust usage of protect_list.\n\t(init_eh_for_function): Use xcalloc.\n\nFrom-SVN: r30667", "tree": {"sha": "e11758241a48589de283764322a42a688c5bb539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e11758241a48589de283764322a42a688c5bb539"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76fc91c7c857105e5079f28415201a7dd95d363d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fc91c7c857105e5079f28415201a7dd95d363d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76fc91c7c857105e5079f28415201a7dd95d363d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fc91c7c857105e5079f28415201a7dd95d363d/comments", "author": null, "committer": null, "parents": [{"sha": "913d08334a78012ba496b669bc0077a98d6e9b3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/913d08334a78012ba496b669bc0077a98d6e9b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/913d08334a78012ba496b669bc0077a98d6e9b3c"}], "stats": {"total": 116, "additions": 85, "deletions": 31}, "files": [{"sha": "040ec3a98a2acffd911245cb83ec2b58f9227d16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc91c7c857105e5079f28415201a7dd95d363d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc91c7c857105e5079f28415201a7dd95d363d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76fc91c7c857105e5079f28415201a7dd95d363d", "patch": "@@ -1,3 +1,16 @@\n+1999-11-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* except.h (eh_status): Adjust documentation for x_protect_list.\n+\t(begin_protect_partials): New function.\n+\t* except.c (enqueue_eh_entry): Fix formatting.\n+\t(get_first_handler): Add consistency check.\n+\t(add_partial_entry): Adjust usage of protect_list.\n+\t(emit_cleanup_handler): Save and restore ehqueue.\n+\t(expand_start_all_catch): Add comment.\n+\t(begin_protect_partials): New function.\n+\t(end_protect_partials): Adjust usage of protect_list.\n+\t(init_eh_for_function): Use xcalloc.\n+\t\n 1999-11-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-common.c (check_format_info): Don't call a variadic function"}, {"sha": "a06c408c84abc445c38441db77b29c482a4741e6", "filename": "gcc/except.c", "status": "modified", "additions": 63, "deletions": 28, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc91c7c857105e5079f28415201a7dd95d363d/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc91c7c857105e5079f28415201a7dd95d363d/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=76fc91c7c857105e5079f28415201a7dd95d363d", "patch": "@@ -643,13 +643,9 @@ enqueue_eh_entry (queue, entry)\n   node->chain = NULL;\n \n   if (queue->head == NULL)\n-    {\n-      queue->head = node;\n-    }\n+    queue->head = node;\n   else\n-    {\n-      queue->tail->chain = node;\n-    }\n+    queue->tail->chain = node;\n   queue->tail = node;\n }\n \n@@ -912,7 +908,10 @@ struct handler_info *\n get_first_handler (region)\n      int region;\n {\n-  return function_eh_regions[find_func_region (region)].handlers;\n+  int r = find_func_region (region);\n+  if (r == -1)\n+    abort ();\n+  return function_eh_regions[r].handlers;\n }\n \n /* Clean out the function_eh_region table and free all memory */\n@@ -1097,7 +1096,15 @@ add_partial_entry (handler)\n      with __terminate.  */\n   handler = protect_with_terminate (handler);\n \n-  protect_list = tree_cons (NULL_TREE, handler, protect_list);\n+  /* For backwards compatibility, we allow callers to omit calls to\n+     begin_protect_partials for the outermost region.  So, we must\n+     explicitly do so here.  */\n+  if (!protect_list)\n+    begin_protect_partials ();\n+\n+  /* Add this entry to the front of the list.  */\n+  TREE_VALUE (protect_list) \n+    = tree_cons (NULL_TREE, handler, TREE_VALUE (protect_list));\n   pop_obstacks ();\n }\n \n@@ -1675,7 +1682,7 @@ expand_leftover_cleanups ()\n        entry;\n        entry = dequeue_eh_entry (&ehqueue))\n     {\n-      /* A leftover try bock.  Shouldn't be one here.  */\n+      /* A leftover try block.  Shouldn't be one here.  */\n       if (entry->finalization == integer_zero_node)\n \tabort ();\n \n@@ -1788,6 +1795,13 @@ emit_cleanup_handler (entry)\n {\n   rtx prev;\n   rtx handler_insns;\n+  struct eh_queue q;\n+\n+  /* Since the cleanup could itself contain try-catch blocks, we\n+     squirrel away the current queue and replace it when we are done\n+     with this function.  */\n+  q = ehqueue;\n+  ehqueue.head = ehqueue.tail = NULL;\n \n   /* Put these handler instructions in a sequence.  */\n   do_pending_stack_adjust ();\n@@ -1828,6 +1842,10 @@ emit_cleanup_handler (entry)\n   emit_insns (handler_insns);\n   catch_clauses = get_insns ();\n   end_sequence ();\n+\n+  /* Now we've left the handler.  */\n+  expand_leftover_cleanups ();\n+  ehqueue = q;\n }\n \n /* Generate RTL for the start of a group of catch clauses. \n@@ -1868,6 +1886,9 @@ expand_start_all_catch ()\n      the handlers in this handler-seq.  */\n   start_sequence ();\n \n+  /* Throw away entries in the queue that we won't need anymore.  We\n+     need entries for regions that have ended but to which there might\n+     still be gotos pending.  */\n   for (entry = dequeue_eh_entry (&ehqueue); \n        entry->finalization != integer_zero_node;\n        entry = dequeue_eh_entry (&ehqueue))\n@@ -1989,17 +2010,44 @@ expand_rethrow (label)\n       emit_jump (label);\n }\n \n+/* Begin a region that will contain entries created with\n+   add_partial_entry.  */\n+\n+void\n+begin_protect_partials ()\n+{\n+  /* Put the entry on the function obstack.  */\n+  push_obstacks_nochange ();\n+  resume_temporary_allocation ();\n+\n+  /* Push room for a new list.  */\n+  protect_list = tree_cons (NULL_TREE, NULL_TREE, protect_list);\n+\n+  /* We're done with the function obstack now.  */\n+  pop_obstacks ();\n+}\n+\n /* End all the pending exception regions on protect_list. The handlers\n    will be emitted when expand_leftover_cleanups is invoked.  */\n \n void\n end_protect_partials ()\n {\n-  while (protect_list)\n-    {\n-      expand_eh_region_end (TREE_VALUE (protect_list));\n-      protect_list = TREE_CHAIN (protect_list);\n-    }\n+  tree t;\n+  \n+  /* For backwards compatibility, we allow callers to omit the call to\n+     begin_protect_partials for the outermost region.  So,\n+     PROTECT_LIST may be NULL.  */\n+  if (!protect_list)\n+    return;\n+\n+  /* End all the exception regions.  */\n+  for (t = TREE_VALUE (protect_list); t; t = TREE_CHAIN (t))\n+    expand_eh_region_end (TREE_VALUE (t));\n+\n+  /* Pop the topmost entry.  */\n+  protect_list = TREE_CHAIN (protect_list);\n+  \n }\n \n /* Arrange for __terminate to be called if there is an unhandled throw\n@@ -2528,20 +2576,7 @@ void\n init_eh_for_function ()\n {\n   current_function->eh\n-    = (struct eh_status *) xmalloc (sizeof (struct eh_status));\n-\n-  ehstack.top = 0;\n-  catchstack.top = 0;\n-  ehqueue.head = ehqueue.tail = 0;\n-  catch_clauses = NULL_RTX;\n-  false_label_stack = 0;\n-  caught_return_label_stack = 0;\n-  protect_list = NULL_TREE;\n-  current_function_ehc = NULL_RTX;\n-  eh_return_context = NULL_RTX;\n-  eh_return_stack_adjust = NULL_RTX;\n-  eh_return_handler = NULL_RTX;\n-  eh_return_stub_label = NULL_RTX;\n+    = (struct eh_status *) xcalloc (1, sizeof (struct eh_status));\n }\n \n void"}, {"sha": "6f15ff04a0927ecedb83ebb93036f8665dabb9a6", "filename": "gcc/except.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc91c7c857105e5079f28415201a7dd95d363d/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc91c7c857105e5079f28415201a7dd95d363d/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=76fc91c7c857105e5079f28415201a7dd95d363d", "patch": "@@ -125,9 +125,10 @@ struct eh_status\n      normal control flow out of a handler (instead of, say, returning to\n      the caller of the current function or exiting the program).  */\n   struct label_node *x_caught_return_label_stack;\n-  /* A TREE_CHAINed list of handlers for regions that are not yet\n-     closed. The TREE_VALUE of each entry contains the handler for the\n-     corresponding entry on the ehstack.  */\n+  /* A stack (TREE_LIST) of lists of handlers.  The TREE_VALUE of each\n+     node is itself a TREE_CHAINed list of handlers for regions that\n+     are not yet closed. The TREE_VALUE of each entry contains the\n+     handler for the corresponding entry on the ehstack.  */\n   union tree_node *x_protect_list;\n   /* The EH context.  Nonzero if the function has already\n      fetched a pointer to the EH context  for exception handling.  */\n@@ -368,6 +369,11 @@ extern void expand_start_all_catch\t\tPROTO((void));\n \n extern void expand_end_all_catch\t\tPROTO((void));\n \n+/* Begin a region that will contain entries created with\n+   add_partial_entry.  */\n+\n+extern void begin_protect_partials              PROTO((void));\n+\n #ifdef TREE_CODE\n /* Create a new exception region and add the handler for the region\n    onto a list. These regions will be ended (and their handlers"}]}