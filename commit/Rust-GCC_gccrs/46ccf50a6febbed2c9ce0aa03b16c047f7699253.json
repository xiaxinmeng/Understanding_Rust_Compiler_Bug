{"sha": "46ccf50a6febbed2c9ce0aa03b16c047f7699253", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZjY2Y1MGE2ZmViYmVkMmM5Y2UwYWEwM2IxNmMwNDdmNzY5OTI1Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-03-22T00:55:13Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-03-22T00:55:13Z"}, "message": "pt.c (instantiate_decl): Abort if we see a member constant instantiation that doesn't already have its...\n\n        * pt.c (instantiate_decl): Abort if we see a member constant\n        instantiation that doesn't already have its initializer.\n        Downgrade explicit instantiation without definition to pedwarn.\n\n        * cp-tree.h (DECL_TINFO_FN_P, SET_DECL_TINFO_FN_P): Remove.\n        * class.c (build_vtable_entry): Don't check DECL_TINFO_FN_P.\n        (import_export_decl): Check tinfo_decl_p, not DECL_TINFO_FN_P.\n\n        * cp-tree.h (CLASSTYPE_VTABLE_NEEDS_WRITING): Remove.\n        (pending_vtables): Remove.\n        * decl2.c (pending_vtables): Remove.\n        (import_export_vtable): Use CLASSTYPE_INTERFACE_ONLY, not\n        CLASSTYPE_VTABLE_NEEDS_WRITING.\n        (import_export_class): Likewise.\n        (init_decl2): Don't mark pending_vtables.\n        * lex.c (handle_pragma_vtable): Just sorry.\n        * pt.c (instantiate_class_template): Don't mess with\n        CLASSTYPE_VTABLE_NEEDS_WRITING.\n        (mark_class_instantiated): Likewise.\n        * ptree.c (print_lang_type): Don't print it.\n        * semantics.c (begin_class_definition): Don't set it.\n\n        * pt.c (template_tail): Replace with last_pending_template.\n        (maybe_templates, maybe_template_tail): Remove.\n        (add_pending_template): Adjust.\n        (instantiate_pending_templates): Adjust.\n\n        * cp-tree.h (struct saved_scope): Remove lang_stack field.\n        (current_lang_stack): Remove.\n        * decl.c (maybe_push_to_top_level): Don't initialize it.\n        (duplicate_decls): Use current_lang_depth.\n        (xref_basetypes): Likewise.\n        * class.c (current_lang_depth): New fn.\n        (push_lang_context): Use more varray functionality.\n        (pop_lang_context): Likewise.\n\nFrom-SVN: r40724", "tree": {"sha": "39735fdc6d6bfc4dde92935a692a9cc0fec1a584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39735fdc6d6bfc4dde92935a692a9cc0fec1a584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46ccf50a6febbed2c9ce0aa03b16c047f7699253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ccf50a6febbed2c9ce0aa03b16c047f7699253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46ccf50a6febbed2c9ce0aa03b16c047f7699253", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ccf50a6febbed2c9ce0aa03b16c047f7699253/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64d9c3fede833ead77f8379349cf1dfabfe7f69c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64d9c3fede833ead77f8379349cf1dfabfe7f69c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64d9c3fede833ead77f8379349cf1dfabfe7f69c"}], "stats": {"total": 220, "additions": 92, "deletions": 128}, "files": [{"sha": "f1cdaa755bd73a4865fed168c671a67b82ac2dd2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -1,4 +1,40 @@\n-2001-03-20  Jason Merrill  <jason@redhat.com>\n+2001-03-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* pt.c (instantiate_decl): Abort if we see a member constant\n+\tinstantiation that doesn't already have its initializer.\n+\tDowngrade explicit instantiation without definition to pedwarn.\n+\n+\t* cp-tree.h (DECL_TINFO_FN_P, SET_DECL_TINFO_FN_P): Remove.\n+\t* class.c (build_vtable_entry): Don't check DECL_TINFO_FN_P.\n+\t(import_export_decl): Check tinfo_decl_p, not DECL_TINFO_FN_P.\n+\n+\t* cp-tree.h (CLASSTYPE_VTABLE_NEEDS_WRITING): Remove.\n+\t(pending_vtables): Remove.\n+\t* decl2.c (pending_vtables): Remove.\n+\t(import_export_vtable): Use CLASSTYPE_INTERFACE_ONLY, not\n+\tCLASSTYPE_VTABLE_NEEDS_WRITING.\n+\t(import_export_class): Likewise.\n+\t(init_decl2): Don't mark pending_vtables.\n+\t* lex.c (handle_pragma_vtable): Just sorry.\n+\t* pt.c (instantiate_class_template): Don't mess with\n+\tCLASSTYPE_VTABLE_NEEDS_WRITING.\n+\t(mark_class_instantiated): Likewise.\n+\t* ptree.c (print_lang_type): Don't print it.\n+\t* semantics.c (begin_class_definition): Don't set it.\n+\n+\t* pt.c (template_tail): Replace with last_pending_template.\n+\t(maybe_templates, maybe_template_tail): Remove.\n+\t(add_pending_template): Adjust.\n+\t(instantiate_pending_templates): Adjust.\n+\n+\t* cp-tree.h (struct saved_scope): Remove lang_stack field.\n+\t(current_lang_stack): Remove.\n+\t* decl.c (maybe_push_to_top_level): Don't initialize it.\n+\t(duplicate_decls): Use current_lang_depth.\n+\t(xref_basetypes): Likewise.\n+\t* class.c (current_lang_depth): New fn.\n+\t(push_lang_context): Use more varray functionality.\n+\t(pop_lang_context): Likewise.\n \n \t* error.c (GLOBAL_THING): Always use '__'.\n "}, {"sha": "ea726d8c572aeccc424512f370da3f1d4de70e3b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -5757,22 +5757,22 @@ pop_nested_class ()\n     pop_nested_class ();\n }\n \n+/* Returns the number of extern \"LANG\" blocks we are nested within.  */\n+\n+int\n+current_lang_depth ()\n+{\n+  return VARRAY_ACTIVE_SIZE (current_lang_base);\n+}\n+\n /* Set global variables CURRENT_LANG_NAME to appropriate value\n    so that behavior of name-mangling machinery is correct.  */\n \n void\n push_lang_context (name)\n      tree name;\n {\n-  *current_lang_stack++ = current_lang_name;\n-  if (current_lang_stack - &VARRAY_TREE (current_lang_base, 0)\n-      >= (ptrdiff_t) VARRAY_SIZE (current_lang_base))\n-    {\n-      size_t old_size = VARRAY_SIZE (current_lang_base);\n-\n-      VARRAY_GROW (current_lang_base, old_size + 10);\n-      current_lang_stack = &VARRAY_TREE (current_lang_base, old_size);\n-    }\n+  VARRAY_PUSH_TREE (current_lang_base, current_lang_name);\n \n   if (name == lang_name_cplusplus)\n     {\n@@ -5807,10 +5807,8 @@ push_lang_context (name)\n void\n pop_lang_context ()\n {\n-  /* Clear the current entry so that garbage collector won't hold on\n-     to it.  */\n-  *current_lang_stack = NULL_TREE;\n-  current_lang_name = *--current_lang_stack;\n+  current_lang_name = VARRAY_TOP_TREE (current_lang_base);\n+  VARRAY_POP (current_lang_base);\n }\n \f\n /* Type instantiation routines.  */\n@@ -7847,8 +7845,7 @@ build_vtable_entry (delta, vcall_index, entry, generate_with_vtable_p)\n \n       fn = TREE_OPERAND (entry, 0);\n       if ((!integer_zerop (delta) || vcall_index != NULL_TREE)\n-\t  && fn != abort_fndecl\n-\t  && !DECL_TINFO_FN_P (fn))\n+\t  && fn != abort_fndecl)\n \t{\n \t  entry = make_thunk (entry, delta, vcall_index,\n \t\t\t      generate_with_vtable_p);"}, {"sha": "de63fb1813a037efc1662f7e92257f6318317bde", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -787,7 +787,6 @@ struct saved_scope {\n   tree access_specifier;\n   tree function_decl;\n   varray_type lang_base;\n-  tree *lang_stack;\n   tree lang_name;\n   tree template_parms;\n   tree x_previous_class_type;\n@@ -830,7 +829,6 @@ struct saved_scope {\n \n /* Pointer to the top of the language name stack.  */\n \n-#define current_lang_stack scope_chain->lang_stack\n #define current_lang_base scope_chain->lang_base\n #define current_lang_name scope_chain->lang_name\n \n@@ -1296,7 +1294,7 @@ struct lang_type\n   unsigned com_interface : 1;\n   unsigned non_pod_class : 1;\n   unsigned nearly_empty_p : 1;\n-  unsigned vtable_needs_writing : 1;\n+  unsigned user_align : 1;\n   unsigned has_assign_ref : 1;\n   unsigned has_new : 1;\n   unsigned has_array_new : 1;\n@@ -1328,7 +1326,6 @@ struct lang_type\n   unsigned has_abstract_assign_ref : 1;\n   unsigned non_aggregate : 1;\n   unsigned is_partial_instantiation : 1;\n-  unsigned user_align : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1337,7 +1334,7 @@ struct lang_type\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 8;\n+  unsigned dummy : 9;\n \n   int vsize;\n \n@@ -1573,10 +1570,6 @@ struct lang_type\n    and there is no need to change it.  */\n #define CLASSTYPE_NEEDS_VIRTUAL_REINIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->needs_virtual_reinit)\n \n-/* Nonzero means that if this type has virtual functions, that\n-   the virtual function table will be written out.  */\n-#define CLASSTYPE_VTABLE_NEEDS_WRITING(NODE) (TYPE_LANG_SPECIFIC(NODE)->vtable_needs_writing)\n-\n /* Nonzero means that this type has an X() constructor.  */\n #define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_default_ctor)\n \n@@ -1824,11 +1817,10 @@ struct lang_decl_flags\n   unsigned pending_inline_p : 1;\n   unsigned global_ctor_p : 1;\n   unsigned global_dtor_p : 1;\n-  unsigned tinfo_fn_p : 1;\n   unsigned assignment_operator_p : 1;\n   unsigned anticipated_p : 1;\n   unsigned generate_with_vtable_p : 1;\n-  /* One unused bit.  */\n+  /* Two unused bits.  */\n \n   union {\n     /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n@@ -2032,17 +2024,6 @@ struct lang_decl\n #define DECL_HAS_IN_CHARGE_PARM_P(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.has_in_charge_parm_p)\n \n-/* Non-zero for a FUNCTION_DECL that declares a type-info function.\n-   This only happens in the old abi.  */\n-#define DECL_TINFO_FN_P(NODE)\t\t\t\t\t\\\n-  (TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\t\\\n-   && DECL_ARTIFICIAL (NODE)\t\t\t\t\t\\\n-   && DECL_LANG_SPECIFIC(NODE)->decl_flags.tinfo_fn_p)\n-\n-/* Mark NODE as a type-info function.  */\n-#define SET_DECL_TINFO_FN_P(NODE) \\\n-  (DECL_LANG_SPECIFIC((NODE))->decl_flags.tinfo_fn_p = 1)\n-\n /* Nonzero if NODE is an overloaded `operator delete[]' function.  */\n #define DECL_ARRAY_DELETE_OPERATOR_P(NODE) \\\n   (DECL_OVERLOADED_OPERATOR_P (NODE) == VEC_DELETE_EXPR)\n@@ -3190,9 +3171,6 @@ extern int warn_nontemplate_friend;\n /* A node that is a list (length 1) of error_mark_nodes.  */\n extern tree error_mark_list;\n \n-/* A list of virtual function tables we must make sure to write out.  */\n-extern tree pending_vtables;\n-\n /* Node for \"pointer to (virtual) function\".\n    This may be distinct from ptr_type_node so gdb can distinguish them.  */\n #define vfunc_ptr_type_node \\\n@@ -3727,6 +3705,7 @@ extern void pushclass\t\t\t\tPARAMS ((tree, int));\n extern void popclass\t\t\t\tPARAMS ((void));\n extern void push_nested_class\t\t\tPARAMS ((tree, int));\n extern void pop_nested_class\t\t\tPARAMS ((void));\n+extern int current_lang_depth\t\t\tPARAMS ((void));\n extern void push_lang_context\t\t\tPARAMS ((tree));\n extern void pop_lang_context\t\t\tPARAMS ((void));\n extern tree instantiate_type\t\t\tPARAMS ((tree, tree, enum instantiate_type_flags));"}, {"sha": "67aea126f48fa427542498dfdbe102a3701bc629", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -2531,7 +2531,6 @@ maybe_push_to_top_level (pseudo)\n   scope_chain = s;\n   current_function_decl = NULL_TREE;\n   VARRAY_TREE_INIT (current_lang_base, 10, \"current_lang_base\");\n-  current_lang_stack = &VARRAY_TREE (current_lang_base, 0);\n   current_lang_name = lang_name_cplusplus;\n   current_namespace = global_namespace;\n }\n@@ -3313,8 +3312,7 @@ duplicate_decls (newdecl, olddecl)\n \t  /* extern \"C\" int foo ();\n \t     int foo () { bar (); }\n \t     is OK.  */\n-\t  if (current_lang_stack\n-\t      == &VARRAY_TREE (current_lang_base, 0))\n+\t  if (current_lang_depth () == 0)\n \t    DECL_LANGUAGE (newdecl) = DECL_LANGUAGE (olddecl);\n \t  else\n \t    {\n@@ -12723,8 +12721,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t    }\n \n \t  if (TYPE_FOR_JAVA (basetype)\n-\t      && (current_lang_stack\n-\t\t  == &VARRAY_TREE (current_lang_base, 0)))\n+\t      && (current_lang_depth () == 0))\n \t    TYPE_FOR_JAVA (ref) = 1;\n \n \t  /* Note that the BINFO records which describe individual"}, {"sha": "a8300b9fc9a029d31f6c53c393efcd8d002dc37a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -94,9 +94,6 @@ static tree get_guard_bits PARAMS ((tree));\n \n extern int current_class_depth;\n \n-/* A list of virtual function tables we must make sure to write out.  */\n-tree pending_vtables;\n-\n /* A list of static class variables.  This is needed, because a\n    static class variable can be declared inside the class without\n    an initializer, and then initialized, staticly, outside the class.  */\n@@ -1514,7 +1511,7 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n   DECL_CONTEXT (decl) = current_class_type;\n \n   /* We cannot call pushdecl here, because that would fill in the\n-     decl of our TREE_CHAIN.  Instead, we modify cp_finish_decl to do\n+     TREE_CHAIN of our decl.  Instead, we modify cp_finish_decl to do\n      the right thing, namely, to put this decl out straight away.  */\n   /* current_class_type can be NULL_TREE in case of error.  */\n   if (!asmspec_tree && current_class_type)\n@@ -2297,7 +2294,7 @@ mark_vtable_entries (decl)\n \n       if (TREE_CODE (fnaddr) != ADDR_EXPR)\n \t/* This entry is an offset: a virtual base class offset, a\n-\t   virtual call offset, and RTTI offset, etc.  */\n+\t   virtual call offset, an RTTI offset, etc.  */\n \tcontinue;\n \n       fn = TREE_OPERAND (fnaddr, 0);\n@@ -2411,7 +2408,7 @@ key_method (type)\n        method = TREE_CHAIN (method))\n     if (DECL_VINDEX (method) != NULL_TREE\n \t&& ! DECL_THIS_INLINE (method)\n-\t&& ! DECL_PURE_VIRTUAL_P (method))\n+\t&& (! DECL_PURE_VIRTUAL_P (method) || DECL_DESTRUCTOR_P (method)))\n       return method;\n \n   return NULL_TREE;\n@@ -2440,7 +2437,7 @@ import_export_vtable (decl, type, final)\n   else if (CLASSTYPE_INTERFACE_KNOWN (type))\n     {\n       TREE_PUBLIC (decl) = 1;\n-      DECL_EXTERNAL (decl) = ! CLASSTYPE_VTABLE_NEEDS_WRITING (type);\n+      DECL_EXTERNAL (decl) = CLASSTYPE_INTERFACE_ONLY (type);\n       DECL_INTERFACE_KNOWN (decl) = 1;\n     }\n   else\n@@ -2525,7 +2522,6 @@ import_export_class (ctype)\n   if (import_export)\n     {\n       SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n-      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = (import_export > 0);\n       CLASSTYPE_INTERFACE_ONLY (ctype) = (import_export < 0);\n     }\n }\n@@ -2695,7 +2691,7 @@ import_export_decl (decl)\n       else\n \tcomdat_linkage (decl);\n     }\n-  else if (DECL_TINFO_FN_P (decl))\n+  else if (tinfo_decl_p (decl, 0))\n     {\n       tree ctype = TREE_TYPE (DECL_NAME (decl));\n \n@@ -5387,5 +5383,4 @@ init_decl2 ()\n   ggc_add_tree_root (&ssdf_decl, 1);\n   ggc_add_tree_root (&priority_decl, 1);\n   ggc_add_tree_root (&initialize_p_decl, 1);\n-  ggc_add_tree_root (&pending_vtables, 1);\n }"}, {"sha": "97f74602498d0584556af83da50bb07a765b5a85", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -1078,12 +1078,8 @@ static void\n handle_pragma_vtable (dfile)\n      cpp_reader *dfile ATTRIBUTE_UNUSED;\n {\n-  tree vtbl = parse_strconst_pragma (\"vtable\", 0);\n-\n-  if (vtbl && vtbl != (tree)-1)\n-    pending_vtables = tree_cons (NULL_TREE,\n-\t\t\t\t get_identifier (TREE_STRING_POINTER (vtbl)),\n-\t\t\t\t pending_vtables);\n+  parse_strconst_pragma (\"vtable\", 0);\n+  sorry (\"#pragma vtable no longer supported\");\n }\n \n static void"}, {"sha": "c1cbf52c9fc8cbb6e750aeda4a810aefa2331f9d", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -686,7 +686,7 @@ expand_call_inline (tp, walk_subtrees, data)\n       return NULL_TREE;\n     }\n \n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+  if (TYPE_P (t))\n     /* Because types were not copied in copy_body, CALL_EXPRs beneath\n        them should not be expanded.  This can happen if the type is a\n        dynamic array type, for example.  */"}, {"sha": "e4e647167da0e26f2ca671783b52b56ee346be5d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -57,10 +57,7 @@ extern struct obstack permanent_obstack;\n    (for a function or static data member), or a TYPE (for a class)\n    indicating what we are hoping to instantiate.  */\n static tree pending_templates;\n-static tree *template_tail = &pending_templates;\n-\n-static tree maybe_templates;\n-static tree *maybe_template_tail = &maybe_templates;\n+static tree last_pending_template;\n \n int processing_template_parmlist;\n static int template_header_count;\n@@ -176,7 +173,6 @@ void\n init_pt ()\n {\n   ggc_add_tree_root (&pending_templates, 1);\n-  ggc_add_tree_root (&maybe_templates, 1);\n   ggc_add_tree_root (&saved_trees, 1);\n   ggc_add_tree_root (&current_tinst_level, 1);\n }\n@@ -3719,6 +3715,7 @@ add_pending_template (d)\n   tree ti = (TYPE_P (d)\n \t     ? CLASSTYPE_TEMPLATE_INFO (d)\n \t     : DECL_TEMPLATE_INFO (d));\n+  tree pt;\n   int level;\n \n   if (TI_PENDING_TEMPLATE_FLAG (ti))\n@@ -3732,8 +3729,14 @@ add_pending_template (d)\n   if (level)\n     push_tinst_level (d);\n \n-  *template_tail = tree_cons (current_tinst_level, d, NULL_TREE);\n-  template_tail = &TREE_CHAIN (*template_tail);\n+  pt = tree_cons (current_tinst_level, d, NULL_TREE);\n+  if (last_pending_template)\n+    TREE_CHAIN (last_pending_template) = pt;\n+  else\n+    pending_templates = pt;\n+\n+  last_pending_template = pt;\n+\n   TI_PENDING_TEMPLATE_FLAG (ti) = 1;\n \n   if (level)\n@@ -4962,24 +4965,17 @@ instantiate_class_template (type)\n \t{\n \t  CLASSTYPE_INTERFACE_ONLY (type) = interface_only;\n \t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X (type, interface_unknown);\n-\t  CLASSTYPE_VTABLE_NEEDS_WRITING (type)\n-\t    = (! CLASSTYPE_INTERFACE_ONLY (type)\n-\t       && CLASSTYPE_INTERFACE_KNOWN (type));\n \t}\n       else\n \t{\n \t  CLASSTYPE_INTERFACE_ONLY (type) = CLASSTYPE_INTERFACE_ONLY (pattern);\n \t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n \t    (type, CLASSTYPE_INTERFACE_UNKNOWN (pattern));\n-\t  CLASSTYPE_VTABLE_NEEDS_WRITING (type)\n-\t    = (! CLASSTYPE_INTERFACE_ONLY (type)\n-\t       && CLASSTYPE_INTERFACE_KNOWN (type));\n \t}\n     }\n   else\n     {\n       SET_CLASSTYPE_INTERFACE_UNKNOWN (type);\n-      CLASSTYPE_VTABLE_NEEDS_WRITING (type) = 1;\n     }\n \n   TYPE_HAS_CONSTRUCTOR (type) = TYPE_HAS_CONSTRUCTOR (pattern);\n@@ -9471,7 +9467,6 @@ mark_class_instantiated (t, extern_p)\n   SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n   SET_CLASSTYPE_INTERFACE_KNOWN (t);\n   CLASSTYPE_INTERFACE_ONLY (t) = extern_p;\n-  CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! extern_p;\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = extern_p;\n   if (! extern_p)\n     {\n@@ -9859,10 +9854,10 @@ instantiate_decl (d, defer_ok)\n \timport_export_decl (d);\n     }\n \n-  /* We need to set up DECL_INITIAL regardless, if\n-     the variable is initialized in the class body.  */\n-  if (TREE_CODE (d) == VAR_DECL && DECL_INITIALIZED_IN_CLASS_P (d))\n-    ;\n+  if (TREE_CODE (d) == VAR_DECL && DECL_INITIALIZED_IN_CLASS_P (d)\n+      && DECL_INITIAL (d) == NULL_TREE)\n+    /* We should have set up DECL_INITIAL in instantiate_class_template.  */\n+    abort ();\n   /* Reject all external templates except inline functions.  */\n   else if (DECL_INTERFACE_KNOWN (d)\n \t   && ! DECL_NOT_REALLY_EXTERN (d)\n@@ -9885,8 +9880,8 @@ instantiate_decl (d, defer_ok)\n \t   member function or static data member of a class template\n \t   shall be present in every translation unit in which it is\n \t   explicitly instantiated.  */\n-\tcp_error (\"explicit instantiation of `%D' but no definition available\",\n-\t\t  d);\n+\tcp_pedwarn\n+\t  (\"explicit instantiation of `%D' but no definition available\", d);\n \n       add_pending_template (d);\n       goto out;\n@@ -9979,6 +9974,7 @@ int\n instantiate_pending_templates ()\n {\n   tree *t;\n+  tree last = NULL_TREE;\n   int instantiated_something = 0;\n   int reconsider;\n   \n@@ -10017,8 +10013,11 @@ instantiate_pending_templates ()\n \t\t/* If INSTANTIATION has been instantiated, then we don't\n \t\t   need to consider it again in the future.  */\n \t\t*t = TREE_CHAIN (*t);\n-\t      else \n-\t\tt = &TREE_CHAIN (*t);\n+\t      else\n+\t\t{\n+\t\t  last = *t;\n+\t\t  t = &TREE_CHAIN (*t);\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -10039,43 +10038,16 @@ instantiate_pending_templates ()\n \t\t/* If INSTANTIATION has been instantiated, then we don't\n \t\t   need to consider it again in the future.  */\n \t\t*t = TREE_CHAIN (*t);\n-\t      else \n-\t\tt = &TREE_CHAIN (*t);\n+\t      else\n+\t\t{\n+\t\t  last = *t;\n+\t\t  t = &TREE_CHAIN (*t);\n+\t\t}\n \t    }\n \t  tinst_depth = 0;\n \t  current_tinst_level = NULL_TREE;\n \t}\n-      template_tail = t;\n-\n-      /* Go through the things that are template instantiations if we are\n-\t using guiding declarations.  */\n-      t = &maybe_templates;\n-      while (*t)\n-\t{\n-\t  tree template;\n-\t  tree fn;\n-\t  tree args;\n-\n-\t  fn = TREE_VALUE (*t);\n-\n-\t  if (DECL_INITIAL (fn))\n-\t    /* If the FN is already defined, then it was either already\n-\t       instantiated or, even though guiding declarations were\n-\t       allowed, a non-template definition was provided.  */\n-\t    ;\n-\t  else\n-\t    {\n-\t      template = TREE_PURPOSE (*t);\n-\t      args = get_bindings (template, fn, NULL_TREE);\n-\t      fn = instantiate_template (template, args);\n-\t      instantiate_decl (fn, /*defer_ok=*/0);\n-\t      reconsider = 1;\n-\t    }\n-\t\n-\t  /* Remove this entry from the chain.  */\n-\t  *t = TREE_CHAIN (*t);\n-\t}\n-      maybe_template_tail = t;\n+      last_pending_template = last;\n     } \n   while (reconsider);\n "}, {"sha": "8f2f577cc61e4afb586f1d00a1d7ef4bb9c1e5bf", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -152,8 +152,6 @@ print_lang_type (file, node, indent)\n \tfprintf (file, \" interface-only\");\n       if (CLASSTYPE_INTERFACE_UNKNOWN (node))\n \tfprintf (file, \" interface-unknown\");\n-      if (CLASSTYPE_VTABLE_NEEDS_WRITING (node))\n-\tfprintf (file, \" vtable-needs-writing\");\n       print_node (file, \"member-functions\", CLASSTYPE_METHOD_VEC (node),\n \t\t  indent + 4);\n     }"}, {"sha": "0cb37753f3d4224e4a7c2764544d0ffdbd27b384", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -340,7 +340,7 @@ get_tinfo_decl (type)\n     {\n       /* The tinfo decl is the type_info object itself.  We make all\n          tinfo objects look as type_info, even though they will end up\n-         being a subclass of that when emitted.  This means the we'll\n+         being a subclass of that when emitted.  This means that we'll\n          erroneously think we know the dynamic type -- be careful in the\n          runtime.  */\n       d = build_lang_decl (VAR_DECL, name, tinfo_decl_type);"}, {"sha": "6e037f4d727b96500ba1644553866059d4a132e8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ccf50a6febbed2c9ce0aa03b16c047f7699253/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=46ccf50a6febbed2c9ce0aa03b16c047f7699253", "patch": "@@ -1825,12 +1825,6 @@ begin_class_definition (t)\n \tSET_CLASSTYPE_INTERFACE_UNKNOWN_X\n \t  (t, interface_unknown);\n       }\n-    \n-    /* Only leave this bit clear if we know this\n-       class is part of an interface-only specification.  */\n-    if (! CLASSTYPE_INTERFACE_KNOWN (t)\n-\t|| ! CLASSTYPE_INTERFACE_ONLY (t))\n-      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n   }\n   reset_specialization();\n   "}]}