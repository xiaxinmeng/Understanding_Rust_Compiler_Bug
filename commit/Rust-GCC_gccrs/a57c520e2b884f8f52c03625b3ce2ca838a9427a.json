{"sha": "a57c520e2b884f8f52c03625b3ce2ca838a9427a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU3YzUyMGUyYjg4NGY4ZjUyYzAzNjI1YjNjZTJjYTgzOGE5NDI3YQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2017-01-19T10:35:38Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2017-01-19T10:35:38Z"}, "message": "[expand] Fix for PR rtl-optimization/79121 incorrect expansion of extend plus left shift\n    \n    When generating a shift from an extended value moving from one to two\n    machine registers, the type of the right shift is for the most\n    significant word should be determined by the signedness of the inner\n    type, not the signedness of the result type.\n    \n    gcc:\n        PR rtl-optimization/79121\n        * expr.c (expand_expr_real_2, case LSHIFT_EXPR): Look at the signedness\n        of the inner type when shifting an extended value.\n    \n    gcc/testsuite:\n        * gcc.c-torture/execute/pr79121.c: New test.\n\nFrom-SVN: r244613", "tree": {"sha": "c47101ed051263f16a24a2dc75fdb06684e3cf7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c47101ed051263f16a24a2dc75fdb06684e3cf7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a57c520e2b884f8f52c03625b3ce2ca838a9427a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a57c520e2b884f8f52c03625b3ce2ca838a9427a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a57c520e2b884f8f52c03625b3ce2ca838a9427a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a57c520e2b884f8f52c03625b3ce2ca838a9427a/comments", "author": null, "committer": null, "parents": [{"sha": "ea83dcf68d805065fc63a98056a0504ffcf5c2aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea83dcf68d805065fc63a98056a0504ffcf5c2aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea83dcf68d805065fc63a98056a0504ffcf5c2aa"}], "stats": {"total": 85, "additions": 72, "deletions": 13}, "files": [{"sha": "bb725d66140245104be16413255d3e8cb1cd168b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57c520e2b884f8f52c03625b3ce2ca838a9427a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57c520e2b884f8f52c03625b3ce2ca838a9427a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a57c520e2b884f8f52c03625b3ce2ca838a9427a", "patch": "@@ -1,3 +1,9 @@\n+2017-01-19  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR rtl-optimization/79121\n+\t* expr.c (expand_expr_real_2, case LSHIFT_EXPR): Look at the signedness\n+\tof the inner type when shifting an extended value.\n+\n 2017-01-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/78407"}, {"sha": "2d8868e52cefdfdc2d81135811cbf1cb3e6ff82b", "filename": "gcc/expr.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57c520e2b884f8f52c03625b3ce2ca838a9427a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57c520e2b884f8f52c03625b3ce2ca838a9427a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a57c520e2b884f8f52c03625b3ce2ca838a9427a", "patch": "@@ -9056,9 +9056,9 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \n \t/* Left shift optimization when shifting across word_size boundary.\n \n-\t   If mode == GET_MODE_WIDER_MODE (word_mode), then normally there isn't\n-\t   native instruction to support this wide mode left shift.  Given below\n-\t   scenario:\n+\t   If mode == GET_MODE_WIDER_MODE (word_mode), then normally\n+\t   there isn't native instruction to support this wide mode\n+\t   left shift.  Given below scenario:\n \n \t    Type A = (Type) B  << C\n \n@@ -9067,10 +9067,11 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \n \t\t\t | word_size |\n \n-\t   If the shift amount C caused we shift B to across the word size\n-\t   boundary, i.e part of B shifted into high half of destination\n-\t   register, and part of B remains in the low half, then GCC will use\n-\t   the following left shift expand logic:\n+\t   If the shift amount C caused we shift B to across the word\n+\t   size boundary, i.e part of B shifted into high half of\n+\t   destination register, and part of B remains in the low\n+\t   half, then GCC will use the following left shift expand\n+\t   logic:\n \n \t   1. Initialize dest_low to B.\n \t   2. Initialize every bit of dest_high to the sign bit of B.\n@@ -9080,20 +9081,30 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t   5. Logic right shift D by (word_size - C).\n \t   6. Or the result of 4 and 5 to finalize dest_high.\n \n-\t   While, by checking gimple statements, if operand B is coming from\n-\t   signed extension, then we can simplify above expand logic into:\n+\t   While, by checking gimple statements, if operand B is\n+\t   coming from signed extension, then we can simplify above\n+\t   expand logic into:\n \n \t      1. dest_high = src_low >> (word_size - C).\n \t      2. dest_low = src_low << C.\n \n-\t   We can use one arithmetic right shift to finish all the purpose of\n-\t   steps 2, 4, 5, 6, thus we reduce the steps needed from 6 into 2.  */\n+\t   We can use one arithmetic right shift to finish all the\n+\t   purpose of steps 2, 4, 5, 6, thus we reduce the steps\n+\t   needed from 6 into 2.\n+\n+\t   The case is similar for zero extension, except that we\n+\t   initialize dest_high to zero rather than copies of the sign\n+\t   bit from B.  Furthermore, we need to use a logical right shift\n+\t   in this case.\n+\n+\t   The choice of sign-extension versus zero-extension is\n+\t   determined entirely by whether or not B is signed and is\n+\t   independent of the current setting of unsignedp.  */\n \n \ttemp = NULL_RTX;\n \tif (code == LSHIFT_EXPR\n \t    && target\n \t    && REG_P (target)\n-\t    && ! unsignedp\n \t    && mode == GET_MODE_WIDER_MODE (word_mode)\n \t    && GET_MODE_SIZE (mode) == 2 * GET_MODE_SIZE (word_mode)\n \t    && TREE_CONSTANT (treeop1)\n@@ -9114,6 +9125,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t\t    rtx_insn *seq, *seq_old;\n \t\t    unsigned int high_off = subreg_highpart_offset (word_mode,\n \t\t\t\t\t\t\t\t    mode);\n+\t\t    bool extend_unsigned\n+\t\t      = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (def)));\n \t\t    rtx low = lowpart_subreg (word_mode, op0, mode);\n \t\t    rtx dest_low = lowpart_subreg (word_mode, target, mode);\n \t\t    rtx dest_high = simplify_gen_subreg (word_mode, target,\n@@ -9125,7 +9138,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t\t    start_sequence ();\n \t\t    /* dest_high = src_low >> (word_size - C).  */\n \t\t    temp = expand_variable_shift (RSHIFT_EXPR, word_mode, low,\n-\t\t\t\t\t\t  rshift, dest_high, unsignedp);\n+\t\t\t\t\t\t  rshift, dest_high,\n+\t\t\t\t\t\t  extend_unsigned);\n \t\t    if (temp != dest_high)\n \t\t      emit_move_insn (dest_high, temp);\n "}, {"sha": "dc54c0ae788a273785bfae4d731354417d381f29", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57c520e2b884f8f52c03625b3ce2ca838a9427a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57c520e2b884f8f52c03625b3ce2ca838a9427a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a57c520e2b884f8f52c03625b3ce2ca838a9427a", "patch": "@@ -1,3 +1,8 @@\n+2017-01-19  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR rtl-optimization/79121\n+\t* gcc.c-torture/execute/pr79121.c: New test.\n+\n 2017-01-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/p9-xxbr-1.c: Fix typos in submission."}, {"sha": "9fca7fbded6bfde7b89efabd50816fb521871b1d", "filename": "gcc/testsuite/gcc.c-torture/execute/pr79121.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57c520e2b884f8f52c03625b3ce2ca838a9427a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr79121.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57c520e2b884f8f52c03625b3ce2ca838a9427a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr79121.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr79121.c?ref=a57c520e2b884f8f52c03625b3ce2ca838a9427a", "patch": "@@ -0,0 +1,34 @@\n+extern void abort (void);\n+\n+__attribute__ ((noinline, noclone)) unsigned long long f1 (int x)\n+{\n+  return ((unsigned long long) x) << 4;\n+}\n+\n+__attribute__ ((noinline, noclone)) long long f2 (unsigned x)\n+{\n+  return ((long long) x) << 4;\n+}\n+\n+__attribute__ ((noinline, noclone)) unsigned long long f3 (unsigned x)\n+{\n+  return ((unsigned long long) x) << 4;\n+}\n+\n+__attribute__ ((noinline, noclone)) long long f4 (int x)\n+{\n+  return ((long long) x) << 4;\n+}\n+\n+int main ()\n+{\n+  if (f1 (0xf0000000) != 0xffffffff00000000)\n+    abort ();\n+  if (f2 (0xf0000000) != 0xf00000000)\n+    abort ();\n+  if (f3 (0xf0000000) != 0xf00000000)\n+    abort ();\n+  if (f4 (0xf0000000) != 0xffffffff00000000)\n+    abort ();\n+  return 0;\n+}"}]}