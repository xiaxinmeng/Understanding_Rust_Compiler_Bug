{"sha": "5538ada62ffabf0bd01e583416641137205ff7b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUzOGFkYTYyZmZhYmYwYmQwMWU1ODM0MTY2NDExMzcyMDVmZjdiNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.phys.columbia.edu", "date": "1999-02-04T11:36:54Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1999-02-04T11:36:54Z"}, "message": "cpplib.c (initialize_char_syntax): Move to cppinit.c.\n\n1999-02-04 14:33 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n\t* cpplib.c (initialize_char_syntax): Move to cppinit.c.\n\t(cpp_define): Remove redundant syntax checks.\n\t(make_assertion): Rename cpp_assert, remove redundant syntax\n\tchecks, export.\n\t(cpp_options_init): Don't init things to zero twice.\n\t(cpp_expand_to_buffer): Use memcpy, not a char-by-char loop.\n\t(do_include): Kill excessively verbose import warning that\n\tsnuck back in in the gcc2 merge.\n\t(convert_string): Removed.\n\t(do_line): Rewrite with simple last-name-used cache instead of\n\tprivate hashtable.\n\t(cpp_start_read): Call initialize_char_syntax here, not...\n\t(cpp_reader_init): ...here.\n\t(cpp_handle_options): Support the -std switch.\n\t* cpplib.h (cpp_buffer): Add last_nominal_fname member.\n\t(cpp_options): Add c9x flag.\n\tDeclare all the is_* tables and trigraph table here, as const.\n\tPrototype cpp_assert and initialize_char_syntax.\n\t* cppinit.c: New file.\n\t* cppfiles.c (read_and_prescan): Optimize.\n\t* Makefile.in (LIBCPP_OBJS): Add cppinit.o.\n\nFrom-SVN: r25024", "tree": {"sha": "f83be6cdafbc1c89d47e5f3cafe7b3c98fd2c0fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f83be6cdafbc1c89d47e5f3cafe7b3c98fd2c0fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5538ada62ffabf0bd01e583416641137205ff7b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5538ada62ffabf0bd01e583416641137205ff7b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5538ada62ffabf0bd01e583416641137205ff7b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5538ada62ffabf0bd01e583416641137205ff7b7/comments", "author": null, "committer": null, "parents": [{"sha": "c20df9e705681bf5ec620c8b887b03c1e0fd45bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20df9e705681bf5ec620c8b887b03c1e0fd45bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c20df9e705681bf5ec620c8b887b03c1e0fd45bb"}], "stats": {"total": 829, "additions": 397, "deletions": 432}, "files": [{"sha": "c66b7784c19e6c6b2170f9cc79881502e9525c7c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5538ada62ffabf0bd01e583416641137205ff7b7", "patch": "@@ -873,10 +873,10 @@ stamp-objlist: $(OBJS)\n # We call this executable `xgcc' rather than `gcc'\n # to avoid confusion if the current directory is in the path\n # and CC is `gcc'.  It is renamed to `gcc' when it is installed.\n-xgcc$(exeext): gcc.o version.o intl.o prefix.o \\\n-   version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)\n+xgcc$(exeext): gcc.o version.o choose-temp.o intl.o pexecute.o prefix.o \\\n+   version.o mkstemp.o $(LIBDEPS) $(EXTRA_GCC_OBJS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o prefix.o version.o \\\n-\t  $(EXTRA_GCC_OBJS) $(LIBS)\n+\t  choose-temp.o pexecute.o mkstemp.o $(EXTRA_GCC_OBJS) $(LIBS)\n \n # Dump a specs file to make -B./ read these specs over installed ones.\n specs: xgcc$(exeext)\n@@ -1337,11 +1337,11 @@ graph.o: graph.c $(CONFIG_H) system.h toplev.h flags.h output.h $(RTL_H) \\\n     hard-reg-set.h $(BASIC_BLOCK_H)\n sbitmap.o: sbitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H)\n \n-collect2$(exeext): collect2.o tlink.o hash.o underscore.o \\\n-\tversion.o $(LIBDEPS)\n+collect2$(exeext): collect2.o tlink.o hash.o cplus-dem.o underscore.o \\\n+\tversion.o choose-temp.o mkstemp.o $(LIBDEPS)\n \n-COLLECT2_OBJS = collect2.o tlink.o hash.o \\\n- intl.o underscore.o version.o \n+COLLECT2_OBJS = collect2.o tlink.o hash.o choose-temp.o cplus-dem.o \\\n+ intl.o underscore.o version.o mkstemp.o \n collect2 : $(COLLECT2_OBJS) $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n \t-rm -f collect2$(exeext)\n@@ -1356,6 +1356,16 @@ collect2.o : collect2.c $(CONFIG_H) system.h gstab.h intl.h \\\n tlink.o: tlink.c $(DEMANGLE_H) hash.h $(CONFIG_H) system.h toplev.h collect2.h\n hash.o: hash.c hash.h system.h toplev.h\n \n+cplus-dem.o: $(srcdir)/../libiberty/cplus-dem.c $(DEMANGLE_H)\n+\trm -f cplus-dem.c\n+\t$(LN_S) $(srcdir)/../libiberty/cplus-dem.c cplus-dem.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) cplus-dem.c\n+\n+pexecute.o: $(srcdir)/../libiberty/pexecute.c $(CONFIG_H) system.h\n+\trm -f pexecute.c\n+\t$(LN_S) $(srcdir)/../libiberty/pexecute.c pexecute.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) pexecute.c\n+\n vfprintf.o: $(srcdir)/../libiberty/vfprintf.c $(CONFIG_H) system.h\n \trm -f vfprintf.c\n \t$(LN_S) $(srcdir)/../libiberty/vfprintf.c vfprintf.c\n@@ -1423,6 +1433,16 @@ obstack.o: $(srcdir)/../libiberty/obstack.c $(CONFIG_H)\n \t$(LN_S) $(srcdir)/../libiberty/obstack.c obstack.c\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) obstack.c\n \n+choose-temp.o: $(srcdir)/../libiberty/choose-temp.c $(CONFIG_H) system.h\n+\trm -f choose-temp.c\n+\t$(LN_S) $(srcdir)/../libiberty/choose-temp.c choose-temp.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) choose-temp.c\n+\n+mkstemp.o: $(srcdir)/../libiberty/mkstemp.c $(CONFIG_H) system.h\n+\trm -f mkstemp.c\n+\t$(LN_S) $(srcdir)/../libiberty/mkstemp.c mkstemp.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) mkstemp.c\n+\n prefix.o: prefix.c $(CONFIG_H) system.h Makefile prefix.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t-DPREFIX=\\\"$(prefix)\\\" \\\n@@ -1959,7 +1979,7 @@ cccp.o: cccp.c $(CONFIG_H) intl.h pcp.h version.c config.status system.h \\\n \t  -c `echo $(srcdir)/cccp.c | sed 's,^\\./,,'`\n \n LIBCPP_OBJS =\tcpplib.o cpphash.o cppalloc.o cpperror.o cppexp.o cppfiles.o \\\n-\t\tcppulp.o prefix.o version.o mbchar.o @extra_cpp_objs@ intl.o\n+\t\tcppinit.o cppulp.o prefix.o version.o mbchar.o @extra_cpp_objs@\n \n # All the other archives built/used by this makefile are for targets.  This\n # one is strictly for the host.\n@@ -1996,12 +2016,15 @@ cpphash.o: cpphash.c cpplib.h machmode.h cpphash.h $(CONFIG_H) system.h\n \n cppalloc.o: cppalloc.c $(CONFIG_H) cpplib.h machmode.h system.h\n \n+cppinit.o: cppalloc.c $(CONFIG_H) cpplib.h machmode.h system.h\n+\n # Note for the stamp targets, we run the program `true' instead of\n # having an empty command (nothing following the semicolon).\n \n proto: config.status protoize$(exeext) unprotoize$(exeext) SYSCALLS.c.X\n \n-PROTO_OBJS = getpwd.o intl.o version.o \n+PROTO_OBJS = choose-temp.o getopt.o getopt1.o getpwd.o \\\n+  intl.o pexecute.o version.o mkstemp.o\n \n protoize$(exeext): protoize.o $(PROTO_OBJS) $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ protoize.o $(PROTO_OBJS) $(LIBS)\n@@ -2031,6 +2054,16 @@ unprotoize.o: unprotoize.c protoize.c $(srcdir)/../include/getopt.h \\\n \t  -DSTD_PROTO_DIR=\\\"$(libsubdir)\\\" \\\n \t  $(srcdir)/unprotoize.c\n \n+getopt.o: $(srcdir)/../libiberty/getopt.c $(srcdir)/../include/getopt.h\n+\trm -f getopt.c\n+\t$(LN_S) $(srcdir)/../libiberty/getopt.c getopt.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) getopt.c\n+\n+getopt1.o: $(srcdir)/../libiberty/getopt1.c $(srcdir)/../include/getopt.h\n+\trm -f getopt1.c\n+\t$(LN_S) $(srcdir)/../libiberty/getopt1.c getopt1.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) getopt1.c\n+\n # This info describes the target machine, so compile with GCC just built.\n SYSCALLS.c.X: $(srcdir)/sys-types.h $(srcdir)/sys-protos.h $(GCC_PASSES) \\\n    stmp-int-hdrs"}, {"sha": "9ef74f1b8f9ff8548ebe3d547c7318d8d2400428", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=5538ada62ffabf0bd01e583416641137205ff7b7", "patch": "@@ -814,12 +814,11 @@ read_and_prescan (pfile, fp, desc, len)\n      int desc;\n      size_t len;\n {\n-\n   U_CHAR *buf = (U_CHAR *) xmalloc (len);\n   U_CHAR *ip, *op, *line_base;\n   U_CHAR *ibase;\n   unsigned int line;\n-  int count, seen_eof;\n+  int count;\n   size_t offset;\n   /* 4096 bytes of buffer proper, 2 to detect running off the end without\n      address arithmetic all the time, and 2 for pushback in the case there's\n@@ -832,43 +831,43 @@ read_and_prescan (pfile, fp, desc, len)\n   line_base = buf;\n   line = 1;\n   ibase = intermed + 2;\n-  seen_eof = 0;\n \n   for (;;)\n     {\n     read_next:\n+\n       count = read (desc, intermed + 2, INTERMED_BUFFER_SIZE);\n       if (count < 0)\n-\t  goto error;\n-      if (count == 0)\n-\tseen_eof = 1;\n-      count += 2 - (ibase - intermed);\n-      if (count == 0)\n+\tgoto error;\n+      else if (count == 0)\n \tbreak;\n \n+      offset += count;\n       ip = ibase;\n-      ip[count] = ip[count+1] = '\\0';\n       ibase = intermed + 2;\n-      offset += count;\n-\n+      ibase[count] = ibase[count+1] = '\\0';\n+      \n       if (offset > len)\n \t{\n-\t  size_t delta_op = op - buf;\n-\t  size_t delta_line_base = line_base - buf;\n+\t  size_t delta_op;\n+\t  size_t delta_line_base;\n \t  len *= 2;\n \t  if (offset > len)\n \t      /* len overflowed.\n \t\t This could happen if the file is larger than half the\n \t\t maximum address space of the machine. */\n \t    goto too_big;\n+\n+\t  delta_op = op - buf;\n+\t  delta_line_base = line_base - buf;\n \t  buf = xrealloc (buf, len);\n \t  op = buf + delta_op;\n \t  line_base = buf + delta_line_base;\n \t}\n \n       for (;;)\n \t{\n-\t  U_CHAR c;\n+\t  unsigned int c;\n \t  c = *ip++;\n \t  switch (c)\n \t    {\n@@ -880,16 +879,14 @@ read_and_prescan (pfile, fp, desc, len)\n \t      break;\n \t      \n \t    case '\\0':\n-\t      if (seen_eof)\n-\t\tgoto eof;\n-\t      else\n-\t\tgoto read_next;\n+\t      goto read_next;\n \t    case '\\r':\n \t      if (*ip == '\\n') ip++;\n-\t      else if (*ip == '\\0' && !seen_eof)\n+\t      else if (*ip == '\\0')\n \t\t{\n-\t\t  *--ibase = '\\r';\n-\t\t  break;\n+\t\t  --ibase;\n+\t\t  intermed[1] = '\\r';\n+\t\t  goto read_next;\n \t\t}\n \t      *op++ = '\\n';\n \t      line++;\n@@ -898,10 +895,11 @@ read_and_prescan (pfile, fp, desc, len)\n \n \t    case '\\n':\n \t      if (*ip == '\\r') ip++;\n-\t      else if (*ip == '\\0' && !seen_eof)\n+\t      else if (*ip == '\\0')\n \t\t{\n-\t\t  *--ibase = '\\n';\n-\t\t  break;\n+\t\t  --ibase;\n+\t\t  intermed[1] = '\\n';\n+\t\t  goto read_next;\n \t\t}\n \t      *op++ = '\\n';\n \t      line++;\n@@ -912,64 +910,80 @@ read_and_prescan (pfile, fp, desc, len)\n \t      if (CPP_OPTIONS (pfile)->trigraphs\n \t\t  || CPP_OPTIONS (pfile)->warn_trigraphs)\n \t\t{\n+\t\t  unsigned int d;\n \t\t  /* If we're at the end of the intermediate buffer,\n \t\t     we have to shift the ?'s down to the start and\n \t\t     come back next pass. */\n-\t\t  c = ip[0];\n-\t\t  if (c == '\\0' && !seen_eof)\n+\t\t  d = ip[0];\n+\t\t  if (d == '\\0')\n \t\t    {\n-\t\t      *--ibase = '?';\n-\t\t      break;\n+\t\t      --ibase;\n+\t\t      intermed[1] = '?';\n+\t\t      goto read_next;\n \t\t    }\n-\t\t  if (c != '?')\n+\t\t  if (d != '?')\n \t\t    {\n \t\t      *op++ = '?';\n \t\t      break;\n \t\t    }\n-\t\t  c = ip[1];\n-\t\t  if (c == '\\0' && !seen_eof)\n+\t\t  d = ip[1];\n+\t\t  if (d == '\\0')\n \t\t    {\n-\t\t      *--ibase = '?';\n-\t\t      *--ibase = '?';\n-\t\t      break;\n+\t\t      ibase -= 2;\n+\t\t      intermed[0] = intermed[1] = '?';\n+\t\t      goto read_next;\n \t\t    }\n-\t\t  if (!trigraph_table[c])\n+\t\t  if (!trigraph_table[d])\n \t\t    {\n \t\t      *op++ = '?';\n \t\t      break;\n \t\t    }\n \n \t\t  if (CPP_OPTIONS (pfile)->warn_trigraphs)\n \t\t    cpp_warning_with_line (pfile, line, op-line_base,\n-\t\t\t\t\t   \"trigraph ??%c encountered\", c);\n+\t\t\t\t\t   \"trigraph ??%c encountered\", d);\n \t\t  if (CPP_OPTIONS (pfile)->trigraphs)\n-\t\t    {\n-\t\t      *op++ = trigraph_table[c];\n-\t\t      ip += 2;\n-\t\t      break;\n-\t\t    }\n+\t\t    *op++ = trigraph_table[d];\n \t\t  else\n \t\t    {\n \t\t      *op++ = '?';\n \t\t      *op++ = '?';\n-\t\t      *op++ = c;\n-\t\t      ip += 2;\n+\t\t      *op++ = d;\n \t\t    }\n+\t\t  ip += 2;\n \t\t}\n \t      else\n \t\t*op++ = c;\n \t    }\n \t}\n     }\n- eof:\n \n-  if (op == buf)\n+  if (offset == 0)\n     return 0;\n \n+  /* Deal with pushed-back chars at true EOF.\n+     If two chars were pushed back, they must both be ?'s.\n+     If one was, it might be ?, \\r, or \\n, and \\r needs to\n+     become \\n.\n+     We know we have space already. */\n+  if (ibase == intermed)\n+    {\n+      *op++ = '?';\n+      *op++ = '?';\n+    }\n+  else if (ibase == intermed + 1)\n+    {\n+      if (*ibase == '?')\n+\t*op++ = '?';\n+      else\n+\t*op++ = '\\n';\n+    }\n+\n   if (op[-1] != '\\n' || op[-2] == '\\\\')\n     {\n-      cpp_pedwarn_with_line (pfile, line, op - line_base,\n-\t\t\t     \"no newline at end of file\");\n+      if (CPP_PEDANTIC (pfile))\n+\tcpp_pedwarn_with_line (pfile, line, op - line_base,\n+\t\t\t       \"no newline at end of file\");\n       if (offset + 2 > len)\n \t{\n \t  len += 2;\n@@ -983,8 +997,7 @@ read_and_prescan (pfile, fp, desc, len)\n       *op++ = '\\n';\n     }\n \n-  buf = xrealloc (buf, op - buf);\n-  fp->buf = buf;\n+  fp->buf = (len - offset < 20) ? buf : xrealloc (buf, op - buf);\n   return op - buf;\n \n  too_big:"}, {"sha": "da7030f5b1b959d38fc3b92e10ef3fbd1490e97c", "filename": "gcc/cppinit.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=5538ada62ffabf0bd01e583416641137205ff7b7", "patch": "@@ -0,0 +1,129 @@\n+/* CPP Library.\n+   Copyright (C) 1986, 87, 89, 92-98, 1999 Free Software Foundation, Inc.\n+   Contributed by Per Bothner, 1994-95.\n+   Based on CCCP program by Paul Rubin, June 1986\n+   Adapted to ANSI C, Richard Stallman, Jan 1987\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+/* This file will have more stuff in it eventually, but right now\n+   we just have one hack: we move all the is_* table initialization\n+   in here, and we can declare them const in cpplib.h, which improves\n+   code a bit. */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+typedef unsigned char U_CHAR;\n+\n+/* table to tell if char can be part of a C identifier.  */\n+U_CHAR is_idchar[256] = { 0 };\n+/* table to tell if char can be first char of a c identifier.  */\n+U_CHAR is_idstart[256] = { 0 };\n+/* table to tell if c is horizontal space.  */\n+U_CHAR is_hor_space[256] = { 0 };\n+/* table to tell if c is horizontal or vertical space.  */\n+U_CHAR is_space[256] = { 0 };\n+/* Table to handle trigraph conversion, which occurs before all other\n+   processing, everywhere in the file.  (This is necessary since one\n+   of the trigraphs encodes backslash.)  Note it's off by default.\n+\n+\tfrom\tto\tfrom\tto\tfrom\tto\n+\t?? =\t#\t?? )\t]\t?? !\t|\n+\t?? (\t[\t?? '\t^\t?? >\t}\n+\t?? /\t\\\t?? <\t{\t?? -\t~\n+\n+   There is not a space between the ?? and the third char.  I put spaces\n+   there to avoid warnings when compiling this file. */\n+U_CHAR trigraph_table[256] = { 0 };\n+\n+/* Initialize syntactic classifications of characters. */\n+void\n+initialize_char_syntax (int dollar_in_ident)\n+{\n+  is_idstart['a'] = 1; is_idstart['b'] = 1; is_idstart['c'] = 1;\n+  is_idstart['d'] = 1; is_idstart['e'] = 1; is_idstart['f'] = 1;\n+  is_idstart['g'] = 1; is_idstart['h'] = 1; is_idstart['i'] = 1;\n+  is_idstart['j'] = 1; is_idstart['k'] = 1; is_idstart['l'] = 1;\n+  is_idstart['m'] = 1; is_idstart['n'] = 1; is_idstart['o'] = 1;\n+  is_idstart['p'] = 1; is_idstart['q'] = 1; is_idstart['r'] = 1;\n+  is_idstart['s'] = 1; is_idstart['t'] = 1; is_idstart['u'] = 1;\n+  is_idstart['v'] = 1; is_idstart['w'] = 1; is_idstart['x'] = 1;\n+  is_idstart['y'] = 1; is_idstart['z'] = 1;\n+\n+  is_idstart['A'] = 1; is_idstart['B'] = 1; is_idstart['C'] = 1;\n+  is_idstart['D'] = 1; is_idstart['E'] = 1; is_idstart['F'] = 1;\n+  is_idstart['G'] = 1; is_idstart['H'] = 1; is_idstart['I'] = 1;\n+  is_idstart['J'] = 1; is_idstart['K'] = 1; is_idstart['L'] = 1;\n+  is_idstart['M'] = 1; is_idstart['N'] = 1; is_idstart['O'] = 1;\n+  is_idstart['P'] = 1; is_idstart['Q'] = 1; is_idstart['R'] = 1;\n+  is_idstart['S'] = 1; is_idstart['T'] = 1; is_idstart['U'] = 1;\n+  is_idstart['V'] = 1; is_idstart['W'] = 1; is_idstart['X'] = 1;\n+  is_idstart['Y'] = 1; is_idstart['Z'] = 1;\n+\n+  is_idstart['_'] = 1;\n+\n+  is_idchar['a'] = 1; is_idchar['b'] = 1; is_idchar['c'] = 1;\n+  is_idchar['d'] = 1; is_idchar['e'] = 1; is_idchar['f'] = 1;\n+  is_idchar['g'] = 1; is_idchar['h'] = 1; is_idchar['i'] = 1;\n+  is_idchar['j'] = 1; is_idchar['k'] = 1; is_idchar['l'] = 1;\n+  is_idchar['m'] = 1; is_idchar['n'] = 1; is_idchar['o'] = 1;\n+  is_idchar['p'] = 1;  is_idchar['q'] = 1; is_idchar['r'] = 1;\n+  is_idchar['s'] = 1; is_idchar['t'] = 1;  is_idchar['u'] = 1;\n+  is_idchar['v'] = 1; is_idchar['w'] = 1; is_idchar['x'] = 1;\n+  is_idchar['y'] = 1; is_idchar['z'] = 1;\n+\n+  is_idchar['A'] = 1; is_idchar['B'] = 1; is_idchar['C'] = 1;\n+  is_idchar['D'] = 1; is_idchar['E'] = 1; is_idchar['F'] = 1;\n+  is_idchar['G'] = 1; is_idchar['H'] = 1; is_idchar['I'] = 1;\n+  is_idchar['J'] = 1; is_idchar['K'] = 1; is_idchar['L'] = 1;\n+  is_idchar['M'] = 1; is_idchar['N'] = 1; is_idchar['O'] = 1;\n+  is_idchar['P'] = 1; is_idchar['Q'] = 1; is_idchar['R'] = 1;\n+  is_idchar['S'] = 1; is_idchar['T'] = 1;  is_idchar['U'] = 1;\n+  is_idchar['V'] = 1; is_idchar['W'] = 1; is_idchar['X'] = 1;\n+  is_idchar['Y'] = 1; is_idchar['Z'] = 1;\n+\n+  is_idchar['1'] = 1; is_idchar['2'] = 1; is_idchar['3'] = 1;\n+  is_idchar['4'] = 1; is_idchar['5'] = 1; is_idchar['6'] = 1;\n+  is_idchar['7'] = 1; is_idchar['8'] = 1; is_idchar['9'] = 1;\n+  is_idchar['0'] = 1;\n+\n+  is_idchar['_']  = 1;\n+\n+  /* These will be reset later if -$ is in effect. */\n+  is_idchar['$']  = dollar_in_ident;\n+  is_idstart['$'] = dollar_in_ident;\n+\n+  /* horizontal space table */\n+  is_hor_space[' '] = 1;\n+  is_hor_space['\\t'] = 1;\n+  is_hor_space['\\v'] = 1;\n+  is_hor_space['\\f'] = 1;\n+  is_hor_space['\\r'] = 1;\n+\n+  is_space[' '] = 1;\n+  is_space['\\t'] = 1;\n+  is_space['\\v'] = 1;\n+  is_space['\\f'] = 1;\n+  is_space['\\n'] = 1;\n+  is_space['\\r'] = 1;\n+\n+  /* trigraph conversion */\n+  trigraph_table['='] = '#';  trigraph_table[')'] = ']';\n+  trigraph_table['!'] = '|';  trigraph_table['('] = '[';\n+  trigraph_table['\\''] = '^'; trigraph_table['>'] = '}';\n+  trigraph_table['/'] = '\\\\'; trigraph_table['<'] = '{';\n+  trigraph_table['-'] = '~';\n+}"}, {"sha": "abe54d8af83c75f9cc13d0770f6da53f41cc7703", "filename": "gcc/cpplib.c", "status": "modified", "additions": 150, "deletions": 370, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=5538ada62ffabf0bd01e583416641137205ff7b7", "patch": "@@ -127,10 +127,8 @@ struct cpp_pending {\n extern void cpp_hash_cleanup PARAMS ((cpp_reader *));\n \n static char *my_strerror\t\tPROTO ((int));\n-static void make_assertion\t\tPROTO ((cpp_reader *, char *, U_CHAR *));\n static void path_include\t\tPROTO ((cpp_reader *, char *));\n static void initialize_builtins\t\tPROTO ((cpp_reader *));\n-static void initialize_char_syntax\tPROTO ((void));\n static void validate_else\t\tPROTO ((cpp_reader *, char *));\n static int comp_def_part\t\tPROTO ((int, U_CHAR *, int, U_CHAR *,\n \t\t\t\t\t\tint, int));\n@@ -279,75 +277,6 @@ static struct directive directive_table[] = {\n   {  8, do_unassert, \"unassert\",     T_UNASSERT },\n   {  -1, 0, \"\", T_UNUSED }\n };\n-\f\n-/* table to tell if char can be part of a C identifier.  */\n-U_CHAR is_idchar[256] = { 0 };\n-/* table to tell if char can be first char of a c identifier.  */\n-U_CHAR is_idstart[256] = { 0 };\n-/* table to tell if c is horizontal space.  */\n-U_CHAR is_hor_space[256] = { 0 };\n-/* table to tell if c is horizontal or vertical space.  */\n-U_CHAR is_space[256] = { 0 };\n-/* Table to handle trigraph conversion, which occurs before all other\n-   processing, everywhere in the file.  (This is necessary since one\n-   of the trigraphs encodes backslash.)  Note it's off by default.\n-\n-\tfrom\tto\tfrom\tto\tfrom\tto\n-\t?? =\t#\t?? )\t]\t?? !\t|\n-\t?? (\t[\t?? '\t^\t?? >\t}\n-\t?? /\t\\\t?? <\t{\t?? -\t~\n-\n-   There is not a space between the ?? and the third char.  I put spaces\n-   there to avoid warnings when compiling this file. */\n-U_CHAR trigraph_table[256] = { 0 };\n-\n-/* Initialize syntactic classifications of characters. */\n-static void\n-initialize_char_syntax ()\n-{\n-  register int i;\n-\n-  /*\n-   * Set up is_idchar and is_idstart tables.  These should be\n-   * faster than saying (is_alpha (c) || c == '_'), etc.\n-   * Set up these things before calling any routines tthat\n-   * refer to them.\n-   * XXX We should setlocale(LC_CTYPE, \"C\") here for safety.\n-   */\n-  for (i = 0; i < 256; i++)\n-    {\n-      is_idchar[i]  = ISALNUM (i);\n-      is_idstart[i] = ISALPHA (i);\n-    }\n-\n-  is_idchar['_']  = 1;\n-  is_idstart['_'] = 1;\n-\n-  /* These will be reset later if -$ is in effect. */\n-  is_idchar['$']  = 1;\n-  is_idstart['$'] = 1;\n-\n-  /* horizontal space table */\n-  is_hor_space[' '] = 1;\n-  is_hor_space['\\t'] = 1;\n-  is_hor_space['\\v'] = 1;\n-  is_hor_space['\\f'] = 1;\n-  is_hor_space['\\r'] = 1;\n-\n-  is_space[' '] = 1;\n-  is_space['\\t'] = 1;\n-  is_space['\\v'] = 1;\n-  is_space['\\f'] = 1;\n-  is_space['\\n'] = 1;\n-  is_space['\\r'] = 1;\n-\n-  /* trigraph conversion */\n-  trigraph_table['='] = '#';  trigraph_table[')'] = ']';\n-  trigraph_table['!'] = '|';  trigraph_table['('] = '[';\n-  trigraph_table['\\''] = '^'; trigraph_table['>'] = '}';\n-  trigraph_table['/'] = '\\\\'; trigraph_table['<'] = '{';\n-  trigraph_table['-'] = '~';\n-}\n \n /* Place into PFILE a quoted string representing the string SRC.\n    Caller must reserve enough space in pfile->token_buffer.  */\n@@ -400,115 +329,48 @@ cpp_grow_buffer (pfile, n)\n   CPP_SET_WRITTEN (pfile, old_written);\n }\n \n-\f\n-/*\n- * process a given definition string, for initialization\n- * If STR is just an identifier, define it with value 1.\n- * If STR has anything after the identifier, then it should\n- * be identifier=definition.\n- */\n+/* Process the string STR as if it appeared as the body of a #define\n+   If STR is just an identifier, define it with value 1.\n+   If STR has anything after the identifier, then it should\n+   be identifier=definition. */\n \n void\n cpp_define (pfile, str)\n      cpp_reader *pfile;\n      U_CHAR *str;\n {\n   U_CHAR *buf, *p;\n+  size_t count;\n \n-  buf = str;\n-  p = str;\n-  if (!is_idstart[*p])\n-    {\n-      cpp_error (pfile, \"malformed option `-D %s'\", str);\n-      return;\n-    }\n-  while (is_idchar[*++p])\n-    ;\n-  if (*p == '(') {\n-    while (is_idchar[*++p] || *p == ',' || is_hor_space[*p])\n-      ;\n-    if (*p++ != ')')\n-      p = (U_CHAR *) str;\t\t\t/* Error */\n-  }\n-  if (*p == 0)\n-    {\n-      buf = (U_CHAR *) alloca (p - buf + 4);\n-      strcpy ((char *)buf, str);\n-      strcat ((char *)buf, \" 1\");\n-    }\n-  else if (*p != '=')\n+  /* Copy the entire option so we can modify it.  */\n+  count = strlen (str) + 3;\n+  buf = (U_CHAR *) alloca (count);\n+  memcpy (buf, str, count - 2);\n+  /* Change the first \"=\" in the string to a space.  If there is none,\n+     tack \" 1\" on the end. */\n+  p = strchr (buf, '=');\n+  if (p)\n     {\n-      cpp_error (pfile, \"malformed option `-D %s'\", str);\n-      return;\n+      *p = ' ';\n+      count -= 2;\n     }\n   else\n-    {\n-      U_CHAR *q;\n-      /* Copy the entire option so we can modify it.  */\n-      buf = (U_CHAR *) alloca (2 * strlen (str) + 1);\n-      strncpy (buf, str, p - str);\n-      /* Change the = to a space.  */\n-      buf[p - str] = ' ';\n-      /* Scan for any backslash-newline and remove it.  */\n-      p++;\n-      q = &buf[p - str];\n-      while (*p)\n-\t{\n-      if (*p == '\\\\' && p[1] == '\\n')\n-\tp += 2;\n-      else\n-\t*q++ = *p++;\n-    }\n-    *q = 0;\n-  }\n+      strcpy (&buf[count-3], \" 1\");\n   \n-  if (cpp_push_buffer (pfile, buf, strlen (buf)) != NULL)\n+  if (cpp_push_buffer (pfile, buf, count - 1) != NULL)\n     {\n       do_define (pfile, NULL);\n       cpp_pop_buffer (pfile);\n     }\n }\n-\f\n-/* Process the string STR as if it appeared as the body of a #assert.\n-   OPTION is the option name for which STR was the argument.  */\n \n-static void\n-make_assertion (pfile, option, str)\n+/* Process the string STR as if it appeared as the body of a #assert. */\n+void\n+cpp_assert (pfile, str)\n      cpp_reader *pfile;\n-     char *option;\n      U_CHAR *str;\n {\n-  U_CHAR *buf, *p, *q;\n-\n-  /* Copy the entire option so we can modify it.  */\n-  buf = (U_CHAR *) alloca (strlen (str) + 1);\n-  strcpy ((char *) buf, str);\n-  /* Scan for any backslash-newline and remove it.  */\n-  p = q = buf;\n-  while (*p) {\n-#if 0\n-    if (*p == '\\\\' && p[1] == '\\n')\n-      p += 2;\n-    else\n-#endif\n-      *q++ = *p++;\n-  }\n-  *q = 0;\n-\n-  p = buf;\n-  if (!is_idstart[*p]) {\n-    cpp_error (pfile, \"malformed option `%s %s'\", option, str);\n-    return;\n-  }\n-  while (is_idchar[*++p])\n-    ;\n-  while (*p == ' ' || *p == '\\t') p++;\n-  if (! (*p == 0 || *p == '(')) {\n-    cpp_error (pfile, \"malformed option `%s %s'\", option, str);\n-    return;\n-  }\n-\n-  if (cpp_push_buffer (pfile, buf, strlen (buf)) != NULL)\n+  if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n     {\n       do_assert (pfile, NULL);\n       cpp_pop_buffer (pfile);\n@@ -563,32 +425,10 @@ cpp_options_init (opts)\n      cpp_options *opts;\n {\n   bzero ((char *) opts, sizeof *opts);\n-  opts->in_fname = NULL;\n-  opts->out_fname = NULL;\n \n   opts->dollars_in_ident = 1;\n-  initialize_char_syntax ();\n-\n-  opts->no_line_commands = 0;\n-  opts->trigraphs = 0;\n-  opts->put_out_comments = 0;\n-  opts->print_include_names = 0;\n-  opts->dump_macros = dump_none;\n-  opts->no_output = 0;\n-  opts->remap = 0;\n-  opts->cplusplus = 0;\n   opts->cplusplus_comments = 1;\n-\n-  opts->verbose = 0;\n-  opts->objc = 0;\n-  opts->lang_asm = 0;\n-  opts->for_lint = 0;\n-  opts->chill = 0;\n-  opts->pedantic_errors = 0;\n-  opts->inhibit_warnings = 0;\n-  opts->warn_comments = 0;\n   opts->warn_import = 1;\n-  opts->warnings_are_errors = 0;\n }\n \n enum cpp_token\n@@ -1707,7 +1547,6 @@ cpp_expand_to_buffer (pfile, buf, length)\n #if 0\n   cpp_buffer obuf;\n #endif\n-  U_CHAR *limit = buf + length;\n   U_CHAR *buf1;\n #if 0\n   int odepth = indepth;\n@@ -1719,13 +1558,7 @@ cpp_expand_to_buffer (pfile, buf, length)\n   /* Set up the input on the input stack.  */\n \n   buf1 = (U_CHAR *) alloca (length + 1);\n-  {\n-    register U_CHAR *p1 = buf;\n-    register U_CHAR *p2 = buf1;\n-\n-    while (p1 != limit)\n-      *p2++ = *p1++;\n-  }\n+  memcpy (buf1, buf, length);\n   buf1[length] = 0;\n \n   ip = cpp_push_buffer (pfile, buf1, length);\n@@ -1739,11 +1572,6 @@ cpp_expand_to_buffer (pfile, buf, length)\n   /* Scan the input, create the output.  */\n   cpp_scan_buffer (pfile);\n \n-#if 0\n-  if (indepth != odepth)\n-    abort ();\n-#endif\n-\n   CPP_NUL_TERMINATE (pfile);\n }\n \n@@ -2932,19 +2760,7 @@ do_include (pfile, keyword)\n       && !CPP_BUFFER (pfile)->system_header_p && !pfile->import_warning)\n     {\n       pfile->import_warning = 1;\n-      cpp_warning (pfile, \"using `#import' is not recommended\");\n-      cpp_notice (\"The fact that a certain header file need not be processed more than once\\n\\\n-should be indicated in the header file, not where it is used.\\n\\\n-The best way to do this is with a conditional of this form:\\n\\\n-\\n\\\n-  #ifndef _FOO_H_INCLUDED\\n\\\n-  #define _FOO_H_INCLUDED\\n\\\n-  ... <real contents of file> ...\\n\\\n-  #endif /* Not _FOO_H_INCLUDED */\\n\\\n-\\n\\\n-Then users can use `#include' any number of times.\\n\\\n-GNU C automatically avoids processing the file more than once\\n\\\n-when it is equipped with such a conditional.\\n\");\n+      cpp_warning (pfile, \"`#import' is obsolete, use an #ifndef wrapper in the header file\");\n     }\n \n   pfile->parsing_include_directive++;\n@@ -3139,57 +2955,9 @@ when it is equipped with such a conditional.\\n\");\n   return 0;\n }\n \n-\f\n-/* Convert a character string literal into a nul-terminated string.\n-   The input string is [IN ... LIMIT).\n-   The result is placed in RESULT.  RESULT can be the same as IN.\n-   The value returned in the end of the string written to RESULT,\n-   or NULL on error.  */\n-\n-static U_CHAR *\n-convert_string (pfile, result, in, limit, handle_escapes)\n-     cpp_reader *pfile;\n-     register U_CHAR *result, *in, *limit;\n-     int handle_escapes;\n-{\n-  U_CHAR c;\n-  c = *in++;\n-  if (c != '\\\"')\n-    return NULL;\n-  while (in < limit)\n-    {\n-      U_CHAR c = *in++;\n-      switch (c)\n-\t{\n-\tcase '\\0':\n-\t  return NULL;\n-\tcase '\\\"':\n-\t  limit = in;\n-\t  break;\n-\tcase '\\\\':\n-\t  if (handle_escapes)\n-\t    {\n-\t      char *bpc = (char *) in;\n-\t      int i = (U_CHAR) cpp_parse_escape (pfile, &bpc, 0x00ff);\n-\t      in = (U_CHAR *) bpc;\n-\t      if (i >= 0)\n-\t\t*result++ = (U_CHAR)c;\n-\t      break;\n-\t    }\n-\t  /* else fall through */\n-\tdefault:\n-\t  *result++ = c;\n-\t}\n-    }\n-  *result = 0;\n-  return result;\n-}\n-\n-/*\n- * interpret #line command.  Remembers previously seen fnames\n- * in its very own hash table.\n- */\n-#define FNAME_HASHSIZE 37\n+/* Interpret #line command.\n+   Note that the filename string (if any) is treated as if it were an\n+   include filename.  That means no escape handling.  */\n \n static int\n do_line (pfile, keyword)\n@@ -3201,126 +2969,121 @@ do_line (pfile, keyword)\n   long old_written = CPP_WRITTEN (pfile);\n   enum file_change_code file_change = same_file;\n   enum cpp_token token;\n+  char *x;\n \n   token = get_directive_token (pfile);\n \n-  if (token != CPP_NUMBER\n-      || !ISDIGIT(pfile->token_buffer[old_written]))\n+  if (token != CPP_NUMBER)\n     {\n-      cpp_error (pfile, \"invalid format `#line' command\");\n+      cpp_error (pfile, \"token after `#line' is not an integer\");\n       goto bad_line_directive;\n     }\n \n-  /* The Newline at the end of this line remains to be processed.\n-     To put the next line at the specified line number,\n-     we must store a line number now that is one less.  */\n-  new_lineno = atoi ((char *)(pfile->token_buffer + old_written)) - 1;\n+  new_lineno = strtol (pfile->token_buffer + old_written, &x, 10);\n+  if (x[0] != '\\0')\n+    {\n+      cpp_error (pfile, \"token after `#line' is not an integer\");\n+      goto bad_line_directive;\n+    }      \n   CPP_SET_WRITTEN (pfile, old_written);\n \n-  /* NEW_LINENO is one less than the actual line number here.  */\n-  if (CPP_PEDANTIC (pfile) && new_lineno < 0)\n+  if (CPP_PEDANTIC (pfile) && new_lineno <= 0)\n     cpp_pedwarn (pfile, \"line number out of range in `#line' command\");\n \n-#if 0 /* #line 10\"foo.c\" is supposed to be allowed.  */\n-  if (PEEKC() && !is_space[PEEKC()]) {\n-    cpp_error (pfile, \"invalid format `#line' command\");\n-    goto bad_line_directive;\n-  }\n-#endif\n-\n   token = get_directive_token (pfile);\n \n-  if (token == CPP_STRING) {\n-    U_CHAR *fname = pfile->token_buffer + old_written;\n-    U_CHAR *end_name;\n-    static HASHNODE *fname_table[FNAME_HASHSIZE];\n-    HASHNODE *hp, **hash_bucket;\n-    U_CHAR *p;\n-    long num_start;\n-    int fname_length;\n-\n-    /* Turn the file name, which is a character string literal,\n-       into a null-terminated string.  Do this in place.  */\n-    end_name = convert_string (pfile, fname, fname, CPP_PWRITTEN (pfile), 1);\n-    if (end_name == NULL)\n+  if (token == CPP_STRING)\n     {\n-\tcpp_error (pfile, \"invalid format `#line' command\");\n-\tgoto bad_line_directive;\n-    }\n+      U_CHAR *fname = pfile->token_buffer + old_written + 1;\n+      U_CHAR *end_name = CPP_PWRITTEN (pfile) - 1;\n+      long num_start = CPP_WRITTEN (pfile);\n \n-    fname_length = end_name - fname;\n+      token = get_directive_token (pfile);\n+      if (token != CPP_VSPACE && token != CPP_EOF && token != CPP_POP)\n+\t{\n+\t  U_CHAR *p = pfile->token_buffer + num_start;\n+\t  if (CPP_PEDANTIC (pfile))\n+\t    cpp_pedwarn (pfile, \"garbage at end of `#line' command\");\n \n-    num_start = CPP_WRITTEN (pfile);\n-    token = get_directive_token (pfile);\n-    if (token != CPP_VSPACE && token != CPP_EOF && token != CPP_POP) {\n-      p = pfile->token_buffer + num_start;\n-      if (CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn (pfile, \"garbage at end of `#line' command\");\n+\t  if (token != CPP_NUMBER || *p < '0' || *p > '4' || p[1] != '\\0')\n+\t    {\n+\t      cpp_error (pfile, \"invalid format `#line' command\");\n+\t      goto bad_line_directive;\n+\t    }\n+\t  if (*p == '1')\n+\t    file_change = enter_file;\n+\t  else if (*p == '2')\n+\t    file_change = leave_file;\n+\t  else if (*p == '3')\n+\t    ip->system_header_p = 1;\n+\t  else /* if (*p == '4') */\n+\t    ip->system_header_p = 2;\n+\n+\t  CPP_SET_WRITTEN (pfile, num_start);\n+\t  token = get_directive_token (pfile);\n+\t  p = pfile->token_buffer + num_start;\n+\t  if (token == CPP_NUMBER && p[1] == '\\0' && (*p == '3' || *p== '4'))\n+\t    {\n+\t      ip->system_header_p = *p == '3' ? 1 : 2;\n+\t      token = get_directive_token (pfile);\n+\t    }\n+\t  if (token != CPP_VSPACE)\n+\t    {\n+\t      cpp_error (pfile, \"invalid format `#line' command\");\n+\t      goto bad_line_directive;\n+\t    }\n+\t}\n+      \n+      *end_name = '\\0';\n+      \n+      if (strcmp (fname, ip->nominal_fname))\n+\t{\n+\t  char *newname, *oldname;\n+\t  if (!strcmp (fname, ip->fname))\n+\t    newname = ip->fname;\n+\t  else if (ip->last_nominal_fname\n+\t\t   && !strcmp (fname, ip->last_nominal_fname))\n+\t    newname = ip->last_nominal_fname;\n+\t  else\n+\t    newname = xstrdup (fname);\n \n-      if (token != CPP_NUMBER || *p < '0' || *p > '4' || p[1] != '\\0')\n-      {\n-\tcpp_error (pfile, \"invalid format `#line' command\");\n-\tgoto bad_line_directive;\n-      }\n-      if (*p == '1')\n-\tfile_change = enter_file;\n-      else if (*p == '2')\n-\tfile_change = leave_file;\n-      else if (*p == '3')\n-\tip->system_header_p = 1;\n-      else /* if (*p == '4') */\n-\tip->system_header_p = 2;\n-\n-      CPP_SET_WRITTEN (pfile, num_start);\n-      token = get_directive_token (pfile);\n-      p = pfile->token_buffer + num_start;\n-      if (token == CPP_NUMBER && p[1] == '\\0' && (*p == '3' || *p== '4')) {\n-\tip->system_header_p = *p == '3' ? 1 : 2;\n-\ttoken = get_directive_token (pfile);\n-      }\n-      if (token != CPP_VSPACE) {\n-\tcpp_error (pfile, \"invalid format `#line' command\");\n-\tgoto bad_line_directive;\n-      }\n-    }\n+\t  oldname = ip->nominal_fname;\n+\t  ip->nominal_fname = newname;\n \n-    hash_bucket = &fname_table[hashf (fname, fname_length, FNAME_HASHSIZE)];\n-    for (hp = *hash_bucket; hp != NULL; hp = hp->next)\n-      if (hp->length == fname_length\n-\t  && strncmp (hp->value.cpval, fname, fname_length) == 0) {\n-\tip->nominal_fname = hp->value.cpval;\n-\tbreak;\n-      }\n-    if (hp == 0) {\n-      /* Didn't find it; cons up a new one.  */\n-      hp = (HASHNODE *) xcalloc (1, sizeof (HASHNODE) + fname_length + 1);\n-      hp->next = *hash_bucket;\n-      *hash_bucket = hp;\n-\n-      hp->length = fname_length;\n-      ip->nominal_fname = hp->value.cpval = ((char *) hp) + sizeof (HASHNODE);\n-      bcopy (fname, hp->value.cpval, fname_length);\n+\t  if (ip->last_nominal_fname\n+\t      && ip->last_nominal_fname != oldname\n+\t      && ip->last_nominal_fname != newname)\n+\t    free (ip->last_nominal_fname);\n+\n+\t  if (newname == ip->fname)\n+\t    ip->last_nominal_fname = NULL;\n+\t  else\n+\t    ip->last_nominal_fname = oldname;\n+\t} \n+    }\n+  else if (token != CPP_VSPACE && token != CPP_EOF)\n+    {\n+      cpp_error (pfile, \"token after `#line %d' is not a string\", new_lineno);\n+      goto bad_line_directive;\n     }\n-  }\n-  else if (token != CPP_VSPACE && token != CPP_EOF) {\n-    cpp_error (pfile, \"invalid format `#line' command\");\n-    goto bad_line_directive;\n-  }\n \n-  ip->lineno = new_lineno;\n+  /* The Newline at the end of this line remains to be processed.\n+     To put the next line at the specified line number,\n+     we must store a line number now that is one less.  */\n+  ip->lineno = new_lineno - 1;\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  output_line_command (pfile, 0, file_change);\n+  return 0;\n+\n  bad_line_directive:\n   skip_rest_of_line (pfile);\n   CPP_SET_WRITTEN (pfile, old_written);\n-  output_line_command (pfile, 0, file_change);\n   return 0;\n }\n \n-/*\n- * remove the definition of a symbol from the symbol table.\n- * according to un*x /lib/cpp, it is not an error to undef\n- * something that has no definitions, so it isn't one here either.\n- */\n-\n+/* Remove the definition of a symbol from the symbol table.\n+   According to the C standard, it is not an error to undef\n+   something that has no definitions. */\n static int\n do_undef (pfile, keyword)\n      cpp_reader *pfile;\n@@ -4711,22 +4474,21 @@ cpp_start_read (pfile, fname)\n   cpp_buffer *fp;\n   struct include_hash *ih_fake;\n \n-  /* The code looks at the defaults through this pointer, rather than through\n-     the constant structure above.  This pointer gets changed if an environment\n-     variable specifies other defaults.  */\n+  /* The code looks at the defaults through this pointer, rather than\n+     through the constant structure above.  This pointer gets changed\n+     if an environment variable specifies other defaults.  */\n   struct default_include *include_defaults = include_defaults_array;\n \n-  /* Now that we know dollars_in_ident for real,\n-     reset is_idchar/is_idstart. */\n-  is_idchar['$'] = opts->dollars_in_ident;\n-  is_idstart['$'] = opts->dollars_in_ident;\n+  /* Now that we know dollars_in_ident, we can initialize the syntax\n+     tables. */\n+  initialize_char_syntax (opts->dollars_in_ident);\n   \n   /* Add dirs from CPATH after dirs from -I.  */\n   /* There seems to be confusion about what CPATH should do,\n      so for the moment it is not documented.  */\n-  /* Some people say that CPATH should replace the standard include dirs,\n-     but that seems pointless: it comes before them, so it overrides them\n-     anyway.  */\n+  /* Some people say that CPATH should replace the standard include\n+     dirs, but that seems pointless: it comes before them, so it\n+     overrides them anyway.  */\n   GET_ENV_PATH_LIST (p, \"CPATH\");\n   if (p != 0 && ! opts->no_standard_includes)\n     path_include (pfile, p);\n@@ -4810,7 +4572,7 @@ cpp_start_read (pfile, fname)\n \tsave_char = *termination;\n \t*termination = '\\0';\n \t/* Install the assertion.  */\n-\tmake_assertion (pfile, \"-A\", assertion);\n+\tcpp_assert (pfile, assertion);\n \t*termination = (char) save_char;\n \tp = termination;\n \twhile (*p == ' ' || *p == '\\t')\n@@ -4844,7 +4606,7 @@ cpp_start_read (pfile, fname)\n \t      cpp_define (pfile, pend->arg);\n \t      break;\n \t    case 'A':\n-\t      make_assertion (pfile, \"-A\", pend->arg);\n+\t      cpp_assert (pfile, pend->arg);\n \t      break;\n \t    }\n \t}\n@@ -5273,6 +5035,10 @@ print_help ()\n   printf (\"  -lang-objc++              Assume that the input sources are in ObjectiveC++\\n\");\n   printf (\"  -lang-asm                 Assume that the input sources are in assembler\\n\");\n   printf (\"  -lang-chill               Assume that the input sources are in Chill\\n\");\n+  printf (\"  -std=<std name>           Specify the conformance standard; one of:\\n\");\n+  printf (\"                            gnu89, gnu9x, c89, c9x, iso9899:1990,\\n\");\n+  printf (\"                            iso9899:199409, iso9899:199x\\n\");\n+\n   printf (\"  -+                        Allow parsing of C++ style features\\n\");\n   printf (\"  -w                        Inhibit warning messages\\n\");\n   printf (\"  -Wtrigraphs               Warn if trigraphs are encountered\\n\");\n@@ -5520,19 +5286,19 @@ cpp_handle_option (pfile, argc, argv)\n     case 'l':\n       if (! strcmp (argv[i], \"-lang-c\"))\n \topts->cplusplus = 0, opts->cplusplus_comments = 1, opts->c89 = 0,\n-\t  opts->objc = 0;\n+\t  opts->c9x = 1, opts->objc = 0;\n       if (! strcmp (argv[i], \"-lang-c89\"))\n \topts->cplusplus = 0, opts->cplusplus_comments = 0, opts->c89 = 1,\n-\t  opts->objc = 0;\n+\t  opts->c9x = 0, opts->objc = 0;\n       if (! strcmp (argv[i], \"-lang-c++\"))\n \topts->cplusplus = 1, opts->cplusplus_comments = 1, opts->c89 = 0,\n-\t  opts->objc = 0;\n+\t  opts->c9x = 0, opts->objc = 0;\n       if (! strcmp (argv[i], \"-lang-objc\"))\n \topts->cplusplus = 0, opts->cplusplus_comments = 1, opts->c89 = 0,\n-\t  opts->objc = 1;\n+\t  opts->c9x = 0, opts->objc = 1;\n       if (! strcmp (argv[i], \"-lang-objc++\"))\n \topts->cplusplus = 1, opts->cplusplus_comments = 1, opts->c89 = 0,\n-\t  opts->objc = 1;\n+\t  opts->c9x = 0, opts->objc = 1;\n       if (! strcmp (argv[i], \"-lang-asm\"))\n \topts->lang_asm = 1;\n       if (! strcmp (argv[i], \"-lint\"))\n@@ -5545,7 +5311,21 @@ cpp_handle_option (pfile, argc, argv)\n     case '+':\n       opts->cplusplus = 1, opts->cplusplus_comments = 1;\n       break;\n-      \n+\n+    case 's':\n+      if (!strcmp (argv[i], \"-std=iso9899:1990\")\n+\t  || !strcmp (argv[i], \"-std=iso9899:199409\")\n+\t  || !strcmp (argv[i], \"-std=c89\")\n+\t  || !strcmp (argv[i], \"-std=gnu89\"))\n+\t  opts->cplusplus = 0, opts->cplusplus_comments = 0,\n+\t    opts->c89 = 1, opts->c9x = 0, opts->objc = 0;\n+      else if (!strcmp (argv[i], \"-std=iso9899:199x\")\n+\t       || !strcmp (argv[i], \"-std=c9x\")\n+\t       || !strcmp (argv[i], \"-std=gnu9x\"))\n+\topts->cplusplus = 0, opts->cplusplus_comments = 1, opts->c89 = 0,\n+\t  opts->c9x = 1, opts->objc = 0;\n+      break;\n+\n     case 'w':\n       opts->inhibit_warnings = 1;\n       break;"}, {"sha": "bd2caf5c3ca3ca844cbadd3928692e5498814713", "filename": "gcc/cpplib.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5538ada62ffabf0bd01e583416641137205ff7b7/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=5538ada62ffabf0bd01e583416641137205ff7b7", "patch": "@@ -108,6 +108,8 @@ struct cpp_buffer {\n   char *fname;\n   /* Filename specified with #line command.  */\n   char *nominal_fname;\n+  /* Last filename specified with #line command.  */\n+  char *last_nominal_fname;\n   /* Actual directory of this file, used only for \"\" includes */\n   struct file_name_list *actual_dir;\n \n@@ -422,6 +424,9 @@ struct cpp_options {\n   /* Nonzero for the 1989 C Standard, including corrigenda and amendments.  */\n   char c89;\n \n+  /* Nonzero for the 199x C Standard, including corrigenda and amendments.  */\n+  char c9x;\n+  \n   /* Nonzero means give all the error messages the ANSI standard requires.  */\n   char pedantic;\n \n@@ -639,10 +644,11 @@ struct definition {\n   } args;\n };\n \n-extern unsigned char is_idchar[256];\n-extern unsigned char is_hor_space[256];\n-extern unsigned char is_space[256];\n-extern unsigned char trigraph_table[256];\n+extern const unsigned char is_idstart[256];\n+extern const unsigned char is_idchar[256];\n+extern const unsigned char is_hor_space[256];\n+extern const unsigned char is_space[256];\n+extern const unsigned char trigraph_table[256];\n \n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n@@ -669,6 +675,7 @@ typedef struct if_stack IF_STACK_FRAME;\n extern void cpp_buf_line_and_col PARAMS((cpp_buffer *, long *, long *));\n extern cpp_buffer* cpp_file_buffer PARAMS((cpp_reader *));\n extern void cpp_define PARAMS ((cpp_reader*, unsigned char *));\n+extern void cpp_assert PARAMS ((cpp_reader *, unsigned char *));\n \n extern void cpp_error PVPROTO ((cpp_reader *, const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n@@ -729,6 +736,9 @@ extern int finclude\t\t\tPROTO ((cpp_reader *, int,\n extern void deps_output\t\t\tPROTO ((cpp_reader *, char *, int));\n extern struct include_hash *include_hash PROTO ((cpp_reader *, char *, int));\n \n+/* cppinit.c */\n+extern void initialize_char_syntax\tPROTO ((int));\n+\n #ifndef INCLUDE_LEN_FUDGE\n #define INCLUDE_LEN_FUDGE 0\n #endif"}]}