{"sha": "b677e2f67f72a8de2b0099f6548e42e4054c180f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY3N2UyZjY3ZjcyYThkZTJiMDA5OWY2NTQ4ZTQyZTQwNTRjMTgwZg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-07-02T12:34:52Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-07-02T12:34:52Z"}, "message": "eoshift0.c: For contiguous arrays, use block algorithm.\n\n2017-07-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* intrinsics/eoshift0.c:  For contiguous arrays, use\n\tblock algorithm.  Use memcpy where possible.\n\n2017-07-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran/eoshift_3.f90:  New test.\n\nFrom-SVN: r249882", "tree": {"sha": "404add44be33b9d6e666bd7780a716859b0e48fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/404add44be33b9d6e666bd7780a716859b0e48fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b677e2f67f72a8de2b0099f6548e42e4054c180f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b677e2f67f72a8de2b0099f6548e42e4054c180f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b677e2f67f72a8de2b0099f6548e42e4054c180f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b677e2f67f72a8de2b0099f6548e42e4054c180f/comments", "author": null, "committer": null, "parents": [{"sha": "b0e84cf75a6732833bb52f6c2445ad59bf4aa9d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e84cf75a6732833bb52f6c2445ad59bf4aa9d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0e84cf75a6732833bb52f6c2445ad59bf4aa9d9"}], "stats": {"total": 331, "additions": 295, "deletions": 36}, "files": [{"sha": "ac9c6a63d6170b43e14b5c3c83292e69d86d74c2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b677e2f67f72a8de2b0099f6548e42e4054c180f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b677e2f67f72a8de2b0099f6548e42e4054c180f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b677e2f67f72a8de2b0099f6548e42e4054c180f", "patch": "@@ -1,3 +1,7 @@\n+2017-07-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran/eoshift_3.f90:  New test.\n+\n 2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.dg/strlenopt-32.c: New testcase."}, {"sha": "d1087aa865413e5fd86447735c37644c604ad897", "filename": "gcc/testsuite/gfortran.dg/eoshift_3.f90", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b677e2f67f72a8de2b0099f6548e42e4054c180f/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b677e2f67f72a8de2b0099f6548e42e4054c180f/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_3.f90?ref=b677e2f67f72a8de2b0099f6548e42e4054c180f", "patch": "@@ -0,0 +1,178 @@\n+! { dg-do  run }\n+! Check that eoshift works for three-dimensional arrays.\n+module x\n+  implicit none\n+contains\n+  subroutine eoshift_0 (array, shift, boundary, dim, res)\n+    real, dimension(:,:,:), intent(in) :: array\n+    real, dimension(:,:,:), intent(out) :: res\n+    integer, value :: shift\n+    real, optional, intent(in) :: boundary\n+    integer, optional, intent(in) :: dim\n+    integer :: s1, s2, s3\n+    integer :: n1, n2, n3\n+\n+    real :: b\n+    integer :: d\n+    if (present(boundary)) then\n+       b = boundary\n+    else\n+       b = 0.0\n+    end if\n+\n+    if (present(dim)) then\n+       d = dim\n+    else\n+       d = 1\n+    end if\n+\n+    n1 = size(array,1)\n+    n2 = size(array,2)\n+    n3 = size(array,3)\n+\n+    select case(dim)\n+    case(1)\n+       if (shift > 0) then\n+          shift = min(shift, n1)\n+          do s3=1,n3\n+             do s2=1,n2\n+                do s1= 1, n1 - shift\n+                   res(s1,s2,s3) = array(s1+shift,s2,s3)\n+                end do\n+                do s1 = n1 - shift + 1,n1\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+          end do\n+\n+       else\n+          shift = max(shift, -n1)\n+          do s3=1,n3\n+             do s2=1,n2\n+                do s1=1,-shift\n+                   res(s1,s2,s3) = b\n+                end do\n+                do s1= 1-shift,n1\n+                   res(s1,s2,s3) = array(s1+shift,s2,s3)\n+                end do\n+             end do\n+          end do\n+       end if\n+\n+    case(2)\n+       if (shift > 0) then\n+          shift = min(shift, n2)\n+          do s3=1,n3\n+             do s2=1, n2 - shift\n+                do s1=1,n1\n+                   res(s1,s2,s3) = array(s1,s2+shift,s3)\n+                end do\n+             end do\n+             do s2=n2 - shift + 1, n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+          end do\n+       else\n+          shift = max(shift, -n2)\n+          do s3=1,n3\n+             do s2=1,-shift\n+                do s1=1,n1\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+             do s2=1-shift,n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = array(s1,s2+shift,s3)\n+                end do\n+             end do\n+          end do\n+       end if\n+\n+    case(3)\n+       if (shift > 0) then\n+          shift = min(shift, n3)\n+          do s3=1,n3 - shift\n+             do s2=1, n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = array(s1,s2,s3+shift)\n+                end do\n+             end do\n+          end do\n+          do s3=n3 - shift + 1, n3\n+             do s2=1, n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+          end do\n+       else\n+          shift = max(shift, -n3)\n+          do s3=1,-shift\n+             do s2=1,n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+          end do\n+          do s3=1-shift,n3\n+             do s2=1,n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = array(s1,s2,s3+shift)\n+                end do\n+             end do\n+          end do\n+       end if\n+\n+    case default\n+       stop \"Illegal dim\"\n+    end select\n+  end subroutine eoshift_0\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer, parameter :: n1=2,n2=4,n3=2\n+  real, dimension(n1,n2,n3) :: a,b,c\n+  integer :: dim, shift, shift_lim\n+  call random_number(a)\n+\n+  do dim=1,3\n+     if (dim == 1) then\n+        shift_lim = n1 + 1\n+     else if (dim == 2) then\n+        shift_lim = n2 + 1\n+     else\n+        shift_lim = n3 + 1\n+     end if\n+     do shift=-shift_lim, shift_lim\n+        b = eoshift(a,shift,dim=dim)\n+        call eoshift_0 (a, shift=shift, dim=dim, res=c)\n+        if (any (b /= c)) then\n+                print *,\"dim = \", dim, \"shift = \", shift\n+                call abort\n+        end if\n+     end do\n+  end do\n+  call random_number(b)\n+  c = b\n+\n+  do dim=1,3\n+     if (dim == 1) then\n+        shift_lim = n1/2 + 1\n+     else if (dim == 2) then\n+        shift_lim = n2/2 + 1\n+     else\n+        shift_lim = n3/2 + 1\n+     end if\n+     \n+     do shift=-shift_lim, shift_lim\n+        b(1:n1:2,:,:) = eoshift(a(1:n1/2,:,:),shift,dim=dim)\n+        call eoshift_0 (a(1:n1/2,:,:), shift=shift, dim=dim, res=c(1:n1:2,:,:))\n+        if (any (b /= c)) call abort\n+     end do\n+  end do\n+\n+end program main"}, {"sha": "fb69c81b04b34c23ba7dd6ccba4aab0c0c3fdef7", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b677e2f67f72a8de2b0099f6548e42e4054c180f/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b677e2f67f72a8de2b0099f6548e42e4054c180f/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b677e2f67f72a8de2b0099f6548e42e4054c180f", "patch": "@@ -1,3 +1,8 @@\n+2017-07-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* intrinsics/eoshift0.c:  For contiguous arrays, use\n+\tblock algorithm.  Use memcpy where possible.\n+\n 2017-06-26  Jim Wilson  <jim.wilson@r3-a15.aus-colo>\n \n \tPR libfortran/81195"}, {"sha": "24a23c30fda11f79ee901295ddcf00400e3c62b4", "filename": "libgfortran/intrinsics/eoshift0.c", "status": "modified", "additions": 108, "deletions": 36, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b677e2f67f72a8de2b0099f6548e42e4054c180f/libgfortran%2Fintrinsics%2Feoshift0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b677e2f67f72a8de2b0099f6548e42e4054c180f/libgfortran%2Fintrinsics%2Feoshift0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Feoshift0.c?ref=b677e2f67f72a8de2b0099f6548e42e4054c180f", "patch": "@@ -53,7 +53,8 @@ eoshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   index_type len;\n   index_type n;\n   index_type arraysize;\n-\n+  bool do_blocked;\n+  \n   /* The compiler cannot figure out that these are set, initialize\n      them to avoid warnings.  */\n   len = 0;\n@@ -102,38 +103,93 @@ eoshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   count[0] = 0;\n   sstride[0] = -1;\n   rstride[0] = -1;\n-  n = 0;\n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n-          if (roffset == 0)\n-            roffset = size;\n-          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n-          if (soffset == 0)\n-            soffset = size;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      size_t r_ex, a_ex;\n+      r_ex = 1;\n+      a_ex = 1;\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = size;\n-  if (rstride[0] == 0)\n-    rstride[0] = size;\n+  else\n+    do_blocked = false;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n-  rstride0 = rstride[0];\n-  sstride0 = sstride[0];\n-  rptr = ret->base_addr;\n-  sptr = array->base_addr;\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = eoshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = eoshift(a,sh*n1*n2,1)\n+\n+\t so a block move can be used for dim>1.  */\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);\n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      roffset = size;\n+      soffset = size;\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n+\t  n++;\n+\t}\n+      count[n] = 0;\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = size;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = size;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+    }\n \n   if ((shift >= 0 ? shift : -shift) > len)\n     {\n@@ -148,6 +204,11 @@ eoshift0 (gfc_array_char * ret, const gfc_array_char * array,\n \tlen = len + shift;\n     }\n \n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+\n   while (rptr)\n     {\n       /* Do the shift for this dimension.  */\n@@ -161,12 +222,23 @@ eoshift0 (gfc_array_char * ret, const gfc_array_char * array,\n           src = sptr;\n           dest = &rptr[-shift * roffset];\n         }\n-      for (n = 0; n < len; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+      /* If the elements are contiguous, perform a single block move.  */\n+\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * len;\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n       if (shift >= 0)\n         {\n           n = shift;"}]}