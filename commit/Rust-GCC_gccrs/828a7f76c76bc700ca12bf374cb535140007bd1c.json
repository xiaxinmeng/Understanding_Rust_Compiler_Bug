{"sha": "828a7f76c76bc700ca12bf374cb535140007bd1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI4YTdmNzZjNzZiYzcwMGNhMTJiZjM3NGNiNTM1MTQwMDA3YmQxYw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-05-29T09:36:29Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-05-29T09:36:29Z"}, "message": "PR preprocessor/53229 - Fix diagnostics location when pasting tokens\n\nAs stated in the audit trail of this problem report, consider this\ntest case:\n\n    $ cat test.c\n\t 1\tstruct x {\n\t 2\t  int i;\n\t 3\t};\n\t 4\tstruct x x;\n\t 5\n\t 6\t#define TEST(X) x.##X\n\t 7\n\t 8\tvoid foo (void)\n\t 9\t{\n\t10\t  TEST(i) = 0;\n\t11\t}\n    $\n\n    $ cc1 -quiet test.c\n    test.c: In function 'foo':\n    test.c:10:1: error: pasting \".\" and \"i\" does not give a valid preprocessing token\n       TEST(i) = 0;\n     ^\n    $\n\nSo, when pasting tokens, the error diagnostic uses the global and\nimprecise input_location variable, leading to an imprecise output.\n\nTo properly fix this, I think libcpp should keep the token of the\npasting operator '##', instead of representing it with flag on the LHS\noperand's token.  That way, it could use its location.  Doing that\nwould be quite intrusive though.  So this patch just uses the location\nof the LHS of the pasting operator, for now.  It's IMHO better than\nthe current situation.\n\nThe patch makes paste_tokens take a location parameter that is used in\nthe diagnostics.  This change can still be useful later when we can\nuse the location of the pasting operator, because paste_tokens will\njust be passed the new, more precise location.\n\nIncidentally, it appeared that when getting tokens from within\npreprocessor directives (like what is done in gcc.dg/cpp/paste12.c),\nwith -ftrack-macro-expansion disabled, the location of the expansion\npoint of macros was being lost because\ncpp_reader::set_invocation_location wasn't being properly set.  It's\nbecause when cpp_get_token_1 calls enter_macro_context, there is a\nlittle period of time between the beginning of that later function and\nwhen the macro is really pushed (and thus when the macro is really\nexpanded) where we wrongly consider that we are not expanding the\nmacro because macro_of_context is still NULL.  In that period of time,\nin the occurrences of indirect recursive calls to cpp_get_token_1,\nthis later function wrongly sets cpp_reader::invocation_location\nbecause cpp_reader::set_invocation_location is not being properly set.\n\nTo avoid that confusion the patch does away with\ncpp_reader::set_invocation_location and introduces a new flag\ncpp_reader::about_to_expand_macro_p that is set in the small time\ninterval exposed earlier.  A new in_macro_expansion_p is introduced as\nwell, so that cpp_get_token_1 can now accurately detect when we are in\nthe process of expanding a macro, and thus correctly collect the\nlocation of the expansion point.\n\nPeople seem to like screenshots.\n\nThus, after the patch, we now have:\n\n    $ cc1 -quiet test.c\n    test.c: In function 'foo':\n    test.c:6:18: error: pasting \".\" and \"i\" does not give a valid preprocessing token\n     #define TEST(X) x.##X\n\t\t      ^\n    test.c:10:3: note: in expansion of macro 'TEST'\n       TEST(i) = 0;\n       ^\n    $\n\nBootstrapped and tested on x86_64-unknown-linux-gnu against trunk.\n\nlibcpp/\n\n\tPR preprocessor/53229\n\t* internal.h (cpp_reader::set_invocation_location): Remove.\n\t(cpp_reader::about_to_expand_macro_p): New member flag.\n\t* directives.c (do_pragma):  Remove Kludge as\n\tpfile->set_invocation_location is no more.\n\t* macro.c (cpp_get_token_1): Do away with the use of\n\tcpp_reader::set_invocation_location.  Just collect the macro\n\texpansion point when we are about to expand the top-most macro.\n\tDo not override cpp_reader::about_to_expand_macro_p.\n\tThis fixes gcc.dg/cpp/paste12.c by making get_token_no_padding\n\tproperly handle locations of expansion points.\n\t(cpp_get_token_with_location): Adjust, as\n\tcpp_reader::set_invocation_location is no more.\n\t(paste_tokens): Take a virtual location parameter for\n\tthe LHS of the pasting operator.  Use it in diagnostics.  Update\n\tcomments.\n\t(paste_all_tokens): Tighten the assert.  Propagate the location of\n\tthe expansion point when no virtual locations are available.\n\tPass the virtual location to paste_tokens.\n\t(in_macro_expansion_p): New static function.\n\t(enter_macro_context): Set the cpp_reader::about_to_expand_macro_p\n\tflag until we really start expanding the macro.\n\ngcc/testsuite/\n\n\tPR preprocessor/53229\n\t* gcc.dg/cpp/paste6.c: Force to run without\n\t-ftrack-macro-expansion.\n\t* gcc.dg/cpp/paste8.c: Likewise.\n\t* gcc.dg/cpp/paste8-2.c: New test, like paste8.c but run with\n\t-ftrack-macro-expansion.\n\t* gcc.dg/cpp/paste12.c: Force to run without\n\t-ftrack-macro-expansion.\n\t* gcc.dg/cpp/paste12-2.c: New test, like paste12.c but run with\n\t-ftrack-macro-expansion.\n\t* gcc.dg/cpp/paste13.c: Likewise.\n\t* gcc.dg/cpp/paste14.c: Likewise.\n\t* gcc.dg/cpp/paste14-2.c: New test, like paste14.c but run with\n\t-ftrack-macro-expansion.\n\t* gcc.dg/cpp/paste18.c: New test.\n\nFrom-SVN: r187945", "tree": {"sha": "4d1a41dbd3a96306cc1ff6a62d9d8839ec0f16ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d1a41dbd3a96306cc1ff6a62d9d8839ec0f16ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/828a7f76c76bc700ca12bf374cb535140007bd1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/828a7f76c76bc700ca12bf374cb535140007bd1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/828a7f76c76bc700ca12bf374cb535140007bd1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/828a7f76c76bc700ca12bf374cb535140007bd1c/comments", "author": null, "committer": null, "parents": [{"sha": "0de9dab58d9ea8f1464c3b47be6634f6d507c7f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de9dab58d9ea8f1464c3b47be6634f6d507c7f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0de9dab58d9ea8f1464c3b47be6634f6d507c7f6"}], "stats": {"total": 233, "additions": 178, "deletions": 55}, "files": [{"sha": "1c1b28eeab97bfd16f4f6019b391d39bf3d366fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -1,3 +1,21 @@\n+2012-05-29  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/53229\n+\t* gcc.dg/cpp/paste6.c: Force to run without\n+\t-ftrack-macro-expansion.\n+\t* gcc.dg/cpp/paste8.c: Likewise.\n+\t* gcc.dg/cpp/paste8-2.c: New test, like paste8.c but run with\n+\t-ftrack-macro-expansion.\n+\t* gcc.dg/cpp/paste12.c: Force to run without\n+\t-ftrack-macro-expansion.\n+\t* gcc.dg/cpp/paste12-2.c: New test, like paste12.c but run with\n+\t-ftrack-macro-expansion.\n+\t* gcc.dg/cpp/paste13.c: Likewise.\n+\t* gcc.dg/cpp/paste14.c: Likewise.\n+\t* gcc.dg/cpp/paste14-2.c: New test, like paste14.c but run with\n+\t-ftrack-macro-expansion.\n+\t* gcc.dg/cpp/paste18.c: New test.\n+\n 2012-05-29  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* gcc.target/cris/torture/trap-1.c,"}, {"sha": "6e2e4f1057d739ab362ad177bba7e03df88da106", "filename": "gcc/testsuite/gcc.dg/cpp/paste12-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste12-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste12-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste12-2.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -0,0 +1,11 @@\n+/* \n+   { dg-options \"-ftrack-macro-expansion=2\" }\n+   { dg-do preprocess }\n+ */\n+\n+/* Test correct diagnostics when pasting in #include.\n+   Source: PR preprocessor/6780.  */\n+\n+#define inc2(a,b) <##a.b>  /* { dg-error \"pasting \\\"<\\\" and \\\"stdio\\\" does not\" } */\n+#define INC(X) inc2(X,h)\n+#include INC(stdio)"}, {"sha": "3e0f7b9592220986bafd7ec64c61cb108622680a", "filename": "gcc/testsuite/gcc.dg/cpp/paste12.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste12.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -1,4 +1,7 @@\n-/* { dg-do preprocess } */\n+/*\n+  { dg-options \"-ftrack-macro-expansion=0\" }\n+  { dg-do preprocess }\n+*/\n \n /* Test correct diagnostics when pasting in #include.\n    Source: PR preprocessor/6780.  */"}, {"sha": "f0f4fd894e2b3ab0eee8f09b62f9cfa649fd44af", "filename": "gcc/testsuite/gcc.dg/cpp/paste13.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste13.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -1,6 +1,9 @@\n /* Copyright (C) 2000 Free Software Foundation, Inc.  */\n \n-/* { dg-do preprocess } */\n+/*\n+  { dg-options \"-ftrack-macro-expansion=0\" }\n+  { dg-do preprocess }\n+*/\n \n /* This used to be recognized as a comment when lexing after pasting\n    spellings.  Neil Booth, 9 Oct 2002.  */"}, {"sha": "3b23ada3d215cf8a98aac24b33f6cacadf961ef6", "filename": "gcc/testsuite/gcc.dg/cpp/paste14-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste14-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste14-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste14-2.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -0,0 +1,11 @@\n+/* PR preprocessor/28709 */\n+/* \n+   { dg-options \"-ftrack-macro-expansion=2\" }\n+   { dg-do preprocess }\n+*/\n+\n+#define foo - ## >> /* { dg-error \"pasting \\\"-\\\" and \\\">>\\\"\" } */\n+foo\n+#define bar = ## == /* { dg-error \"pasting \\\"=\\\" and \\\"==\\\"\" } */\n+bar\n+"}, {"sha": "043d5e5804fffaf8ceab85c284c55f85b3001916", "filename": "gcc/testsuite/gcc.dg/cpp/paste14.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste14.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -1,5 +1,8 @@\n /* PR preprocessor/28709 */\n-/* { dg-do preprocess } */\n+/* \n+   { dg-options \"-ftrack-macro-expansion=0\" }\n+   { dg-do preprocess }\n+*/\n \n #define foo - ## >>\n foo\t\t/* { dg-error \"pasting \\\"-\\\" and \\\">>\\\"\" } */"}, {"sha": "2888144cb3bd82c0143da4eb3f3ab2a25d93fa5b", "filename": "gcc/testsuite/gcc.dg/cpp/paste18.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste18.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -0,0 +1,16 @@\n+/* \n+   { dg-options \"-ftrack-macro-expansion=2\" }\n+   { dg-do compile }\n+ */\n+\n+struct x {\n+  int i;\n+};\n+struct x x;\n+\n+#define TEST(X) x.##X /* { dg-error \"pasting\\[^\\n\\r\\]*does not give\\[^\\n\\r\\]*token\" } */\n+\n+void foo (void)\n+{\n+  TEST(i) = 0;\n+}"}, {"sha": "a4e70e450255a8415ddf6f90e94ab6a0765b6af9", "filename": "gcc/testsuite/gcc.dg/cpp/paste6.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste6.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -2,7 +2,10 @@\n    actual arguments.  Original bug exposed by Linux kernel.  Problem\n    reported by Jakub Jelinek <jakub@redhat.com>.  */\n \n-/* { dg-do compile } */\n+/*\n+  { dg-options \"-ftrack-macro-expansion=0\" }\n+  { dg-do compile }\n+*/\n \n extern int foo(int x);\n "}, {"sha": "c037e99e6fa1b2f289e61087ca38ec04af8b948e", "filename": "gcc/testsuite/gcc.dg/cpp/paste8-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste8-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste8-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste8-2.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do preprocess } */\n+/* { dg-options \"-ftrack-macro-expansion=2\" } */\n+\n+int foo(int, ...);\n+\n+#define a(x, y...) foo(x, ##y)\n+a(1)\n+a(1, 2, 3)\n+#define b(x, y, z...) foo(x, ##y) /* { dg-error \"valid preprocessing token\" } */\n+b(1, 2, 3)\t\t\t\n+#define c(x, y, z...) foo(x, ##z)\n+c(1, 2)\n+c(1, 2, 3)\n+#define d(x) fo(##x) /* { dg-error \"valid preprocessing token\" } */\n+d(1)\t\t\t\t"}, {"sha": "db1416c120e7fbf420617f31fa985d73c93c7706", "filename": "gcc/testsuite/gcc.dg/cpp/paste8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste8.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do preprocess } */\n-/* { dg-options \"\" } */\n+/* { dg-options \"-ftrack-macro-expansion=0\" } */\n \n int foo(int, ...);\n "}, {"sha": "19936fe431dcf9e95845cdebfe98852c9618bc00", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -1,3 +1,28 @@\n+2012-05-29  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/53229\n+\t* internal.h (cpp_reader::set_invocation_location): Remove.\n+\t(cpp_reader::about_to_expand_macro_p): New member flag.\n+\t* directives.c (do_pragma):  Remove Kludge as\n+\tpfile->set_invocation_location is no more.\n+\t* macro.c (cpp_get_token_1): Do away with the use of\n+\tcpp_reader::set_invocation_location.  Just collect the macro\n+\texpansion point when we are about to expand the top-most macro.\n+\tDo not override cpp_reader::about_to_expand_macro_p.\n+\tThis fixes gcc.dg/cpp/paste12.c by making get_token_no_padding\n+\tproperly handle locations of expansion points.\n+\t(cpp_get_token_with_location): Adjust, as\n+\tcpp_reader::set_invocation_location is no more.\n+\t(paste_tokens): Take a virtual location parameter for\n+\tthe LHS of the pasting operator.  Use it in diagnostics.  Update\n+\tcomments.\n+\t(paste_all_tokens): Tighten the assert.  Propagate the location of\n+\tthe expansion point when no virtual locations are available.\n+\tPass the virtual location to paste_tokens.\n+\t(in_macro_expansion_p): New static function.\n+\t(enter_macro_context): Set the cpp_reader::about_to_expand_macro_p\n+\tflag until we really start expanding the macro.\n+\n 2012-05-24  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR bootstrap/53459"}, {"sha": "66fa66daa643a31f84638277fe6e4f1707bad790", "filename": "libcpp/directives.c", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -1362,35 +1362,7 @@ do_pragma (cpp_reader *pfile)\n \t{\n \t  bool allow_name_expansion = p->allow_expansion;\n \t  if (allow_name_expansion)\n-\t    {\n-\t      pfile->state.prevent_expansion--;\n-\t      /*\n-\t\tKludge ahead.\n-\n-\t\tConsider this code snippet:\n-\n-\t\t#define P parallel\n-\t\t#pragma omp P for\n-\t\t... a for loop ...\n-\n-\t\tOnce we parsed the 'omp' namespace of the #pragma\n-\t\tdirective, we then parse the 'P' token that represents the\n-\t\tpragma name.  P being a macro, it is expanded into the\n-\t\tresulting 'parallel' token.\n-\n-\t\tAt this point the 'p' variable contains the 'parallel'\n-\t\tpragma name.  And pfile->context->macro is non-null\n-\t\tbecause we are still right at the end of the macro\n-\t\tcontext of 'P'.  The problem is, if we are being\n-\t\t(indirectly) called by cpp_get_token_with_location,\n-\t\tthat function might test pfile->context->macro to see\n-\t\tif we are in the context of a macro expansion, (and we\n-\t\tare) and then use pfile->invocation_location as the\n-\t\tlocation of the macro invocation.  So we must instruct\n-\t\tcpp_get_token below to set\n-\t\tpfile->invocation_location.  */\n-\t      pfile->set_invocation_location = true;\n-\t    }\n+\t    pfile->state.prevent_expansion--;\n \n \t  token = cpp_get_token (pfile);\n \t  if (token->type == CPP_NAME)"}, {"sha": "37aac821d62abd5f8d53d75d78f3b22079b19439", "filename": "libcpp/internal.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -413,9 +413,13 @@ struct cpp_reader\n      macro invocation.  */\n   source_location invocation_location;\n \n-  /* True if this call to cpp_get_token should consider setting\n-     invocation_location.  */\n-  bool set_invocation_location;\n+  /* Nonzero if we are about to expand a macro.  Note that if we are\n+     really expanding a macro, the function macro_of_context returns\n+     the macro being expanded and this flag is set to false.  Client\n+     code should use the function in_macro_expansion_p to know if we\n+     are either about to expand a macro, or are actually expanding\n+     one.  */\n+  bool about_to_expand_macro_p;\n \n   /* Search paths for include files.  */\n   struct cpp_dir *quote_include;\t/* \"\" */"}, {"sha": "89d70f1da9e454eb662a4e352078581f4f386104", "filename": "libcpp/macro.c", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/828a7f76c76bc700ca12bf374cb535140007bd1c/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/828a7f76c76bc700ca12bf374cb535140007bd1c/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=828a7f76c76bc700ca12bf374cb535140007bd1c", "patch": "@@ -100,7 +100,8 @@ static void expand_arg (cpp_reader *, macro_arg *);\n static const cpp_token *new_string_token (cpp_reader *, uchar *, unsigned int);\n static const cpp_token *stringify_arg (cpp_reader *, macro_arg *);\n static void paste_all_tokens (cpp_reader *, const cpp_token *);\n-static bool paste_tokens (cpp_reader *, const cpp_token **, const cpp_token *);\n+static bool paste_tokens (cpp_reader *, source_location,\n+\t\t\t  const cpp_token **, const cpp_token *);\n static void alloc_expanded_arg_mem (cpp_reader *, macro_arg *, size_t);\n static void ensure_expanded_arg_room (cpp_reader *, macro_arg *, size_t, size_t *);\n static void delete_macro_args (_cpp_buff*, unsigned num_args);\n@@ -167,6 +168,8 @@ static const cpp_token* cpp_get_token_1 (cpp_reader *, source_location *);\n \n static cpp_hashnode* macro_of_context (cpp_context *context);\n \n+static bool in_macro_expansion_p (cpp_reader *pfile);\n+\n /* Statistical counter tracking the number of macros that got\n    expanded.  */\n unsigned num_expanded_macros_counter = 0;\n@@ -544,9 +547,11 @@ stringify_arg (cpp_reader *pfile, macro_arg *arg)\n \n /* Try to paste two tokens.  On success, return nonzero.  In any\n    case, PLHS is updated to point to the pasted token, which is\n-   guaranteed to not have the PASTE_LEFT flag set.  */\n+   guaranteed to not have the PASTE_LEFT flag set.  LOCATION is\n+   the virtual location used for error reporting.  */\n static bool\n-paste_tokens (cpp_reader *pfile, const cpp_token **plhs, const cpp_token *rhs)\n+paste_tokens (cpp_reader *pfile, source_location location,\n+\t      const cpp_token **plhs, const cpp_token *rhs)\n {\n   unsigned char *buf, *end, *lhsend;\n   cpp_token *lhs;\n@@ -590,7 +595,7 @@ paste_tokens (cpp_reader *pfile, const cpp_token **plhs, const cpp_token *rhs)\n \n       /* Mandatory error for all apart from assembler.  */\n       if (CPP_OPTION (pfile, lang) != CLK_ASM)\n-\tcpp_error (pfile, CPP_DL_ERROR,\n+\tcpp_error_with_line (pfile, CPP_DL_ERROR, location, 0,\n \t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n \t\t   buf, cpp_token_as_text (pfile, rhs));\n       return false;\n@@ -615,9 +620,10 @@ paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n   cpp_context *context = pfile->context;\n   source_location virt_loc = 0;\n \n-  /* We must have been called on a token that appears at the left\n-     hand side of a ## operator.  */\n-  if (!(lhs->flags & PASTE_LEFT))\n+  /* We are expanding a macro and we must have been called on a token\n+     that appears at the left hand side of a ## operator.  */\n+  if (macro_of_context (pfile->context) == NULL\n+      || (!(lhs->flags & PASTE_LEFT)))\n     abort ();\n \n   if (context->tokens_kind == TOKENS_KIND_EXTENDED)\n@@ -628,6 +634,11 @@ paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n        resulting pasted token to have the location of the current\n        *LHS, though.  */\n     virt_loc = context->c.mc->cur_virt_loc[-1];\n+  else\n+    /* We are not tracking macro expansion.  So the best virtual\n+       location we can get here is the expansion point of the macro we\n+       are currently expanding.  */\n+    virt_loc = pfile->invocation_location;\n \n   do\n     {\n@@ -661,7 +672,7 @@ paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n \t  if (rhs->flags & PASTE_LEFT)\n \t    abort ();\n \t}\n-      if (!paste_tokens (pfile, &lhs, rhs))\n+      if (!paste_tokens (pfile, virt_loc, &lhs, rhs))\n \tbreak;\n     }\n   while (rhs->flags & PASTE_LEFT);\n@@ -1018,6 +1029,17 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \n   pfile->state.angled_headers = false;\n \n+  /* From here to when we push the context for the macro later down\n+     this function, we need to flag the fact that we are about to\n+     expand a macro.  This is useful when -ftrack-macro-expansion is\n+     turned off.  In that case, we need to record the location of the\n+     expansion point of the top-most macro we are about to to expand,\n+     into pfile->invocation_location.  But we must not record any such\n+     location once the process of expanding the macro starts; that is,\n+     we must not do that recording between now and later down this\n+     function where set this flag to FALSE.  */\n+  pfile->about_to_expand_macro_p = true;\n+\n   if ((node->flags & NODE_BUILTIN) && !(node->flags & NODE_USED))\n     {\n       node->flags |= NODE_USED;\n@@ -1057,6 +1079,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \t      if (pragma_buff)\n \t\t_cpp_release_buff (pfile, pragma_buff);\n \n+\t      pfile->about_to_expand_macro_p = false;\n \t      return 0;\n \t    }\n \n@@ -1146,12 +1169,15 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \n \t    }\n \t  while (pragma_buff != NULL);\n+\t  pfile->about_to_expand_macro_p = false;\n \t  return 2;\n \t}\n \n+      pfile->about_to_expand_macro_p = false;\n       return 1;\n     }\n \n+  pfile->about_to_expand_macro_p = false;\n   /* Handle built-in macros and the _Pragma operator.  */\n   return builtin_macro (pfile, node);\n }\n@@ -2143,6 +2169,20 @@ macro_of_context (cpp_context *context)\n     : context->c.macro;\n }\n \n+/* Return TRUE iff we are expanding a macro or are about to start\n+   expanding one.  If we are effectively expanding a macro, the\n+   function macro_of_context returns a pointer to the macro being\n+   expanded.  */\n+static bool\n+in_macro_expansion_p (cpp_reader *pfile)\n+{\n+  if (pfile == NULL)\n+    return false;\n+\n+  return (pfile->about_to_expand_macro_p \n+\t  || macro_of_context (pfile->context));\n+}\n+\n /* Pop the current context off the stack, re-enabling the macro if the\n    context represented a macro's replacement list.  Initially the\n    context structure was not freed so that we can re-use it later, but\n@@ -2298,11 +2338,13 @@ static const cpp_token*\n cpp_get_token_1 (cpp_reader *pfile, source_location *location)\n {\n   const cpp_token *result;\n-  bool can_set = pfile->set_invocation_location;\n   /* This token is a virtual token that either encodes a location\n      related to macro expansion or a spelling location.  */\n   source_location virt_loc = 0;\n-  pfile->set_invocation_location = false;\n+  /* pfile->about_to_expand_macro_p can be overriden by indirect calls\n+     to functions that push macro contexts.  So let's save it so that\n+     we can restore it when we are about to leave this routine.  */\n+  bool saved_about_to_expand_macro = pfile->about_to_expand_macro_p;\n \n   for (;;)\n     {\n@@ -2355,7 +2397,7 @@ cpp_get_token_1 (cpp_reader *pfile, source_location *location)\n \t  int ret = 0;\n \t  /* If not in a macro context, and we're going to start an\n \t     expansion, record the location.  */\n-\t  if (can_set && !context->c.macro)\n+\t  if (!in_macro_expansion_p (pfile))\n \t    pfile->invocation_location = result->src_loc;\n \t  if (pfile->state.prevent_expansion)\n \t    break;\n@@ -2423,15 +2465,16 @@ cpp_get_token_1 (cpp_reader *pfile, source_location *location)\n       *location = virt_loc;\n \n       if (!CPP_OPTION (pfile, track_macro_expansion)\n-\t  && can_set\n-\t  && pfile->context->c.macro != NULL)\n+\t  && macro_of_context (pfile->context) != NULL)\n \t/* We are in a macro expansion context, are not tracking\n \t   virtual location, but were asked to report the location\n \t   of the expansion point of the macro being expanded.  */\n \t*location = pfile->invocation_location;\n \n       *location = maybe_adjust_loc_for_trad_cpp (pfile, *location);\n     }\n+\n+  pfile->about_to_expand_macro_p = saved_about_to_expand_macro;\n   return result;\n }\n \n@@ -2493,11 +2536,7 @@ cpp_get_token (cpp_reader *pfile)\n const cpp_token *\n cpp_get_token_with_location (cpp_reader *pfile, source_location *loc)\n {\n-  const cpp_token *result;\n-\n-  pfile->set_invocation_location = true;\n-  result = cpp_get_token_1 (pfile, loc);\n-  return result;\n+  return cpp_get_token_1 (pfile, loc);\n }\n \n /* Returns true if we're expanding an object-like macro that was"}]}