{"sha": "6c8e70fe86da1b52160aa380f30cbb1bf644c407", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM4ZTcwZmU4NmRhMWI1MjE2MGFhMzgwZjMwY2JiMWJmNjQ0YzQwNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-01-30T12:23:31Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-05T12:17:34Z"}, "message": "[Ada] Rename parameter of routines in Checks\n\n2020-06-05  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* checks.ads (Apply_Length_Check): Rename Ck_Node parameter to\n\tExpr.\n\t(Apply_Range_Check): Likewise.\n\t(Get_Range_Checks): Likewise.\n\t* checks.adb (Apply_Float_Conversion_Check): Likewise.\n\t(Apply_Selected_Length_Checks): Likewise.\n\t(Apply_Selected_Range_Checks): Likewise.\n\t(Guard_Access): Likewise.\n\t(Selected_Length_Checks): Likewise.  Also avoid shadowing in\n\tchild procedures.\n\t(Selected_Range_Checks): Likewise.", "tree": {"sha": "8c0199b09534a8b92c25fb2219fe4c1391e4f9b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c0199b09534a8b92c25fb2219fe4c1391e4f9b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c8e70fe86da1b52160aa380f30cbb1bf644c407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c8e70fe86da1b52160aa380f30cbb1bf644c407", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c8e70fe86da1b52160aa380f30cbb1bf644c407", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c8e70fe86da1b52160aa380f30cbb1bf644c407/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4c17870b85470fa3b4727bfe2dbac7ca7464e50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c17870b85470fa3b4727bfe2dbac7ca7464e50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4c17870b85470fa3b4727bfe2dbac7ca7464e50"}], "stats": {"total": 270, "additions": 132, "deletions": 138}, "files": [{"sha": "bd9c6adab81262251b7cddfa2a7f4ab2fe835cfc", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 129, "deletions": 129, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c8e70fe86da1b52160aa380f30cbb1bf644c407/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c8e70fe86da1b52160aa380f30cbb1bf644c407/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=6c8e70fe86da1b52160aa380f30cbb1bf644c407", "patch": "@@ -223,15 +223,15 @@ package body Checks is\n    --  can be referenced and trusted only if ROK is set True.\n \n    procedure Apply_Float_Conversion_Check\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id);\n    --  The checks on a conversion from a floating-point type to an integer\n    --  type are delicate. They have to be performed before conversion, they\n    --  have to raise an exception when the operand is a NaN, and rounding must\n    --  be taken into account to determine the safe bounds of the operand.\n \n    procedure Apply_Selected_Length_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Do_Static  : Boolean);\n@@ -241,7 +241,7 @@ package body Checks is\n    --  only a static check is to be done.\n \n    procedure Apply_Selected_Range_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Do_Static  : Boolean);\n@@ -307,9 +307,9 @@ package body Checks is\n    --  To be cleaned up???\n \n    function Guard_Access\n-     (Cond    : Node_Id;\n-      Loc     : Source_Ptr;\n-      Ck_Node : Node_Id) return Node_Id;\n+     (Cond : Node_Id;\n+      Loc  : Source_Ptr;\n+      Expr : Node_Id) return Node_Id;\n    --  In the access type case, guard the test with a test to ensure\n    --  that the access value is non-null, since the checks do not\n    --  not apply to null access values.\n@@ -332,7 +332,7 @@ package body Checks is\n    --  of an entity, if these checks are suppressed for the entity.\n \n    function Selected_Length_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Warn_Node  : Node_Id) return Check_Result;\n@@ -345,7 +345,7 @@ package body Checks is\n    --  Selected_Range_Checks.\n \n    function Selected_Range_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Warn_Node  : Node_Id) return Check_Result;\n@@ -1999,17 +1999,17 @@ package body Checks is\n    --          Hi_OK be True.\n \n    procedure Apply_Float_Conversion_Check\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id)\n    is\n       LB          : constant Node_Id    := Type_Low_Bound (Target_Typ);\n       HB          : constant Node_Id    := Type_High_Bound (Target_Typ);\n-      Loc         : constant Source_Ptr := Sloc (Ck_Node);\n-      Expr_Type   : constant Entity_Id  := Base_Type (Etype (Ck_Node));\n+      Loc         : constant Source_Ptr := Sloc (Expr);\n+      Expr_Type   : constant Entity_Id  := Base_Type (Etype (Expr));\n       Target_Base : constant Entity_Id  :=\n         Implementation_Base_Type (Target_Typ);\n \n-      Par : constant Node_Id := Parent (Ck_Node);\n+      Par : constant Node_Id := Parent (Expr);\n       pragma Assert (Nkind (Par) = N_Type_Conversion);\n       --  Parent of check node, must be a type conversion\n \n@@ -2049,7 +2049,7 @@ package body Checks is\n       --  set the Do_Range check flag, since the range check is taken care of\n       --  by the code we will generate.\n \n-      Set_Do_Range_Check (Ck_Node, False);\n+      Set_Do_Range_Check (Expr, False);\n \n       if not Compile_Time_Known_Value (LB)\n           or not Compile_Time_Known_Value (HB)\n@@ -2064,7 +2064,7 @@ package body Checks is\n             Temp : constant Entity_Id := Make_Temporary (Loc, 'T', Par);\n \n          begin\n-            Apply_Float_Conversion_Check (Ck_Node, Target_Base);\n+            Apply_Float_Conversion_Check (Expr, Target_Base);\n             Set_Etype (Temp, Target_Base);\n \n             --  Note: Previously the declaration was inserted above the parent\n@@ -2105,21 +2105,21 @@ package body Checks is\n       --  we can do the comparison with the bounds and the conversion to\n       --  an integer type statically. The range checks are unchanged.\n \n-      if Nkind (Ck_Node) = N_Real_Literal\n-        and then Etype (Ck_Node) = Universal_Real\n+      if Nkind (Expr) = N_Real_Literal\n+        and then Etype (Expr) = Universal_Real\n         and then Is_Integer_Type (Target_Typ)\n       then\n          declare\n-            Int_Val : constant Uint := UR_To_Uint (Realval (Ck_Node));\n+            Int_Val : constant Uint := UR_To_Uint (Realval (Expr));\n \n          begin\n             if Int_Val <= Ilast and then Int_Val >= Ifirst then\n \n                --  Conversion is safe\n \n-               Rewrite (Parent (Ck_Node),\n+               Rewrite (Parent (Expr),\n                  Make_Integer_Literal (Loc, UI_To_Int (Int_Val)));\n-               Analyze_And_Resolve (Parent (Ck_Node), Target_Typ);\n+               Analyze_And_Resolve (Parent (Expr), Target_Typ);\n                return;\n             end if;\n          end;\n@@ -2140,7 +2140,7 @@ package body Checks is\n          Lo_OK := (Ifirst > 0);\n \n       else\n-         Lo := Machine (Expr_Type, UR_From_Uint (Ifirst), Round_Even, Ck_Node);\n+         Lo := Machine (Expr_Type, UR_From_Uint (Ifirst), Round_Even, Expr);\n          Lo_OK := (Lo >= UR_From_Uint (Ifirst));\n       end if;\n \n@@ -2149,14 +2149,14 @@ package body Checks is\n          --  Lo_Chk := (X >= Lo)\n \n          Lo_Chk := Make_Op_Ge (Loc,\n-                     Left_Opnd => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                     Left_Opnd => Duplicate_Subexpr_No_Checks (Expr),\n                      Right_Opnd => Make_Real_Literal (Loc, Lo));\n \n       else\n          --  Lo_Chk := (X > Lo)\n \n          Lo_Chk := Make_Op_Gt (Loc,\n-                     Left_Opnd => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                     Left_Opnd => Duplicate_Subexpr_No_Checks (Expr),\n                      Right_Opnd => Make_Real_Literal (Loc, Lo));\n       end if;\n \n@@ -2174,7 +2174,7 @@ package body Checks is\n          Hi := UR_From_Uint (Ilast) + Ureal_Half;\n          Hi_OK := (Ilast < 0);\n       else\n-         Hi := Machine (Expr_Type, UR_From_Uint (Ilast), Round_Even, Ck_Node);\n+         Hi := Machine (Expr_Type, UR_From_Uint (Ilast), Round_Even, Expr);\n          Hi_OK := (Hi <= UR_From_Uint (Ilast));\n       end if;\n \n@@ -2183,14 +2183,14 @@ package body Checks is\n          --  Hi_Chk := (X <= Hi)\n \n          Hi_Chk := Make_Op_Le (Loc,\n-                     Left_Opnd => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                     Left_Opnd => Duplicate_Subexpr_No_Checks (Expr),\n                      Right_Opnd => Make_Real_Literal (Loc, Hi));\n \n       else\n          --  Hi_Chk := (X < Hi)\n \n          Hi_Chk := Make_Op_Lt (Loc,\n-                     Left_Opnd => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                     Left_Opnd => Duplicate_Subexpr_No_Checks (Expr),\n                      Right_Opnd => Make_Real_Literal (Loc, Hi));\n       end if;\n \n@@ -2208,7 +2208,7 @@ package body Checks is\n \n       --  Raise CE if either conditions does not hold\n \n-      Insert_Action (Ck_Node,\n+      Insert_Action (Expr,\n         Make_Raise_Constraint_Error (Loc,\n           Condition => Make_Op_Not (Loc, Make_And_Then (Loc, Lo_Chk, Hi_Chk)),\n           Reason    => Reason));\n@@ -2219,13 +2219,13 @@ package body Checks is\n    ------------------------\n \n    procedure Apply_Length_Check\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty)\n    is\n    begin\n       Apply_Selected_Length_Checks\n-        (Ck_Node, Target_Typ, Source_Typ, Do_Static => False);\n+        (Expr, Target_Typ, Source_Typ, Do_Static => False);\n    end Apply_Length_Check;\n \n    -------------------------------------\n@@ -2853,13 +2853,13 @@ package body Checks is\n    -----------------------\n \n    procedure Apply_Range_Check\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty)\n    is\n    begin\n       Apply_Selected_Range_Checks\n-        (Ck_Node, Target_Typ, Source_Typ, Do_Static => False);\n+        (Expr, Target_Typ, Source_Typ, Do_Static => False);\n    end Apply_Range_Check;\n \n    ------------------------------\n@@ -3263,7 +3263,7 @@ package body Checks is\n    ----------------------------------\n \n    procedure Apply_Selected_Length_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Do_Static  : Boolean)\n@@ -3273,7 +3273,7 @@ package body Checks is\n                       or else\n                     not Length_Checks_Suppressed (Target_Typ);\n \n-      Loc : constant Source_Ptr := Sloc (Ck_Node);\n+      Loc : constant Source_Ptr := Sloc (Expr);\n \n       Cond     : Node_Id;\n       R_Cno    : Node_Id;\n@@ -3290,7 +3290,7 @@ package body Checks is\n       end if;\n \n       R_Result :=\n-        Selected_Length_Checks (Ck_Node, Target_Typ, Source_Typ, Empty);\n+        Selected_Length_Checks (Expr, Target_Typ, Source_Typ, Empty);\n \n       for J in 1 .. 2 loop\n          R_Cno := R_Result (J);\n@@ -3304,13 +3304,13 @@ package body Checks is\n          if Ekind (Current_Scope) = E_Package\n            and then Is_Compilation_Unit (Current_Scope)\n          then\n-            Ensure_Defined (Target_Typ, Ck_Node);\n+            Ensure_Defined (Target_Typ, Expr);\n \n             if Present (Source_Typ) then\n-               Ensure_Defined (Source_Typ, Ck_Node);\n+               Ensure_Defined (Source_Typ, Expr);\n \n-            elsif Is_Itype (Etype (Ck_Node)) then\n-               Ensure_Defined (Etype (Ck_Node), Ck_Node);\n+            elsif Is_Itype (Etype (Expr)) then\n+               Ensure_Defined (Etype (Expr), Expr);\n             end if;\n          end if;\n \n@@ -3324,15 +3324,15 @@ package body Checks is\n \n             --  Case where node does not now have a dynamic check\n \n-            if not Has_Dynamic_Length_Check (Ck_Node) then\n+            if not Has_Dynamic_Length_Check (Expr) then\n \n                --  If checks are on, just insert the check\n \n                if Checks_On then\n-                  Insert_Action (Ck_Node, R_Cno);\n+                  Insert_Action (Expr, R_Cno);\n \n                   if not Do_Static then\n-                     Set_Has_Dynamic_Length_Check (Ck_Node);\n+                     Set_Has_Dynamic_Length_Check (Expr);\n                   end if;\n \n                --  If checks are off, then analyze the length check after\n@@ -3341,7 +3341,7 @@ package body Checks is\n                --  compile time warning in this case.\n \n                else\n-                  Set_Parent (R_Cno, Ck_Node);\n+                  Set_Parent (R_Cno, Expr);\n                   Analyze (R_Cno);\n                end if;\n             end if;\n@@ -3352,7 +3352,7 @@ package body Checks is\n               and then Entity (Cond) = Standard_True\n             then\n                Apply_Compile_Time_Constraint_Error\n-                 (Ck_Node, \"wrong length for array of}??\",\n+                 (Expr, \"wrong length for array of}??\",\n                   CE_Length_Check_Failed,\n                   Ent => Target_Typ,\n                   Typ => Target_Typ);\n@@ -3377,7 +3377,7 @@ package body Checks is\n    ---------------------------------\n \n    procedure Apply_Selected_Range_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Do_Static  : Boolean)\n@@ -3387,7 +3387,7 @@ package body Checks is\n                       or else\n                     not Range_Checks_Suppressed (Target_Typ);\n \n-      Loc : constant Source_Ptr := Sloc (Ck_Node);\n+      Loc : constant Source_Ptr := Sloc (Expr);\n \n       Cond     : Node_Id;\n       R_Cno    : Node_Id;\n@@ -3406,7 +3406,7 @@ package body Checks is\n       end if;\n \n       R_Result :=\n-        Selected_Range_Checks (Ck_Node, Target_Typ, Source_Typ, Empty);\n+        Selected_Range_Checks (Expr, Target_Typ, Source_Typ, Empty);\n \n       if GNATprove_Mode then\n          return;\n@@ -3428,14 +3428,14 @@ package body Checks is\n             --  Insert the range check before the related context. Note that\n             --  this action analyses the triggering condition.\n \n-            Insert_Action (Ck_Node, R_Cno);\n+            Insert_Action (Expr, R_Cno);\n \n             --  This old code doesn't make sense, why is the context flagged as\n             --  requiring dynamic range checks now in the middle of generating\n             --  them ???\n \n             if not Do_Static then\n-               Set_Has_Dynamic_Range_Check (Ck_Node);\n+               Set_Has_Dynamic_Range_Check (Expr);\n             end if;\n \n             --  The triggering condition evaluates to True, the range check\n@@ -3449,19 +3449,19 @@ package body Checks is\n                --  N_Range. The warning message will point to the lower bound\n                --  and complain about a range, which seems OK.\n \n-               if Nkind (Ck_Node) = N_Range then\n+               if Nkind (Expr) = N_Range then\n                   Apply_Compile_Time_Constraint_Error\n-                    (Low_Bound (Ck_Node),\n+                    (Low_Bound (Expr),\n                      \"static range out of bounds of}??\",\n                      CE_Range_Check_Failed,\n                      Ent => Target_Typ,\n                      Typ => Target_Typ);\n \n-                  Set_Raises_Constraint_Error (Ck_Node);\n+                  Set_Raises_Constraint_Error (Expr);\n \n                else\n                   Apply_Compile_Time_Constraint_Error\n-                    (Ck_Node,\n+                    (Expr,\n                      \"static value out of range of}??\",\n                      CE_Range_Check_Failed,\n                      Ent => Target_Typ,\n@@ -7358,39 +7358,39 @@ package body Checks is\n    ----------------------\n \n    function Get_Range_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty;\n       Warn_Node  : Node_Id   := Empty) return Check_Result\n    is\n    begin\n       return\n-        Selected_Range_Checks (Ck_Node, Target_Typ, Source_Typ, Warn_Node);\n+        Selected_Range_Checks (Expr, Target_Typ, Source_Typ, Warn_Node);\n    end Get_Range_Checks;\n \n    ------------------\n    -- Guard_Access --\n    ------------------\n \n    function Guard_Access\n-     (Cond    : Node_Id;\n-      Loc     : Source_Ptr;\n-      Ck_Node : Node_Id) return Node_Id\n+     (Cond : Node_Id;\n+      Loc  : Source_Ptr;\n+      Expr : Node_Id) return Node_Id\n    is\n    begin\n       if Nkind (Cond) = N_Or_Else then\n          Set_Paren_Count (Cond, 1);\n       end if;\n \n-      if Nkind (Ck_Node) = N_Allocator then\n+      if Nkind (Expr) = N_Allocator then\n          return Cond;\n \n       else\n          return\n            Make_And_Then (Loc,\n              Left_Opnd =>\n                Make_Op_Ne (Loc,\n-                 Left_Opnd  => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                 Left_Opnd  => Duplicate_Subexpr_No_Checks (Expr),\n                  Right_Opnd => Make_Null (Loc)),\n              Right_Opnd => Cond);\n       end if;\n@@ -9555,12 +9555,12 @@ package body Checks is\n    ----------------------------\n \n    function Selected_Length_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Warn_Node  : Node_Id) return Check_Result\n    is\n-      Loc         : constant Source_Ptr := Sloc (Ck_Node);\n+      Loc         : constant Source_Ptr := Sloc (Expr);\n       S_Typ       : Entity_Id;\n       T_Typ       : Entity_Id;\n       Expr_Actual : Node_Id;\n@@ -9592,11 +9592,11 @@ package body Checks is\n       --    Typ'Length /= Exptyp'Length\n \n       function Length_N_Cond\n-        (Expr : Node_Id;\n+        (Exp  : Node_Id;\n          Typ  : Entity_Id;\n          Indx : Nat) return Node_Id;\n       --  Returns expression to compute:\n-      --    Typ'Length /= Expr'Length\n+      --    Typ'Length /= Exp'Length\n \n       function Length_Mismatch_Info_Message\n         (Left_Element_Count  : Uint;\n@@ -9641,7 +9641,7 @@ package body Checks is\n             N := Build_Discriminal_Subtype_Of_Component (E);\n \n             if Present (N) then\n-               Insert_Action (Ck_Node, N);\n+               Insert_Action (Expr, N);\n                E1 := Defining_Identifier (N);\n             end if;\n          end if;\n@@ -9780,15 +9780,15 @@ package body Checks is\n       -------------------\n \n       function Length_N_Cond\n-        (Expr : Node_Id;\n+        (Exp  : Node_Id;\n          Typ  : Entity_Id;\n          Indx : Nat) return Node_Id\n       is\n       begin\n          return\n            Make_Op_Ne (Loc,\n              Left_Opnd  => Get_E_Length (Typ, Indx),\n-             Right_Opnd => Get_N_Length (Expr, Indx));\n+             Right_Opnd => Get_N_Length (Exp, Indx));\n       end Length_N_Cond;\n \n       ----------------------------------\n@@ -9868,19 +9868,19 @@ package body Checks is\n \n       if Target_Typ = Any_Type\n         or else Target_Typ = Any_Composite\n-        or else Raises_Constraint_Error (Ck_Node)\n+        or else Raises_Constraint_Error (Expr)\n       then\n          return Ret_Result;\n       end if;\n \n       if No (Wnode) then\n-         Wnode := Ck_Node;\n+         Wnode := Expr;\n       end if;\n \n       T_Typ := Target_Typ;\n \n       if No (Source_Typ) then\n-         S_Typ := Etype (Ck_Node);\n+         S_Typ := Etype (Expr);\n       else\n          S_Typ := Source_Typ;\n       end if;\n@@ -9896,7 +9896,7 @@ package body Checks is\n \n          --  A simple optimization for the null case\n \n-         if Known_Null (Ck_Node) then\n+         if Known_Null (Expr) then\n             return Ret_Result;\n          end if;\n       end if;\n@@ -9909,10 +9909,10 @@ package body Checks is\n             --  freeze node does not appear within the generated if expression,\n             --  but ahead of it.\n \n-            Freeze_Before (Ck_Node, T_Typ);\n+            Freeze_Before (Expr, T_Typ);\n \n-            Expr_Actual := Get_Referenced_Object (Ck_Node);\n-            Exptyp      := Get_Actual_Subtype (Ck_Node);\n+            Expr_Actual := Get_Referenced_Object (Expr);\n+            Exptyp      := Get_Actual_Subtype (Expr);\n \n             if Is_Access_Type (Exptyp) then\n                Exptyp := Designated_Type (Exptyp);\n@@ -9972,9 +9972,9 @@ package body Checks is\n                       not In_Package_Body (Cunit_Entity (Current_Sem_Unit))\n                     and then In_Open_Scopes (Scope (Exptyp))\n                   then\n-                     Ref_Node := Make_Itype_Reference (Sloc (Ck_Node));\n+                     Ref_Node := Make_Itype_Reference (Sloc (Expr));\n                      Set_Itype (Ref_Node, Exptyp);\n-                     Insert_Action (Ck_Node, Ref_Node);\n+                     Insert_Action (Expr, Ref_Node);\n                   end if;\n \n                   L_Index := First_Index (T_Typ);\n@@ -10058,7 +10058,7 @@ package body Checks is\n             --  the length or range from the expression itself, making sure we\n             --  do not evaluate it more than once.\n \n-            --  Here Ck_Node is the original expression, or more properly the\n+            --  Here Expr is the original expression, or more properly the\n             --  result of applying Duplicate_Expr to the original tree, forcing\n             --  the result to be a name.\n \n@@ -10071,7 +10071,7 @@ package body Checks is\n \n                   for Indx in 1 .. Ndims loop\n                      Evolve_Or_Else\n-                       (Cond, Length_N_Cond (Ck_Node, T_Typ, Indx));\n+                       (Cond, Length_N_Cond (Expr, T_Typ, Indx));\n                   end loop;\n                end;\n             end if;\n@@ -10082,7 +10082,7 @@ package body Checks is\n \n       if Present (Cond) then\n          if Do_Access then\n-            Cond := Guard_Access (Cond, Loc, Ck_Node);\n+            Cond := Guard_Access (Cond, Loc, Expr);\n          end if;\n \n          Add_Check\n@@ -10099,12 +10099,12 @@ package body Checks is\n    ---------------------------\n \n    function Selected_Range_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Warn_Node  : Node_Id) return Check_Result\n    is\n-      Loc         : constant Source_Ptr := Sloc (Ck_Node);\n+      Loc         : constant Source_Ptr := Sloc (Expr);\n       S_Typ       : Entity_Id;\n       T_Typ       : Entity_Id;\n       Expr_Actual : Node_Id;\n@@ -10119,20 +10119,20 @@ package body Checks is\n       --  Adds the action given to Ret_Result if N is non-Empty\n \n       function Discrete_Range_Cond\n-        (Expr : Node_Id;\n-         Typ  : Entity_Id) return Node_Id;\n+        (Exp : Node_Id;\n+         Typ : Entity_Id) return Node_Id;\n       --  Returns expression to compute:\n-      --    Low_Bound (Expr) < Typ'First\n+      --    Low_Bound (Exp) < Typ'First\n       --      or else\n-      --    High_Bound (Expr) > Typ'Last\n+      --    High_Bound (Exp) > Typ'Last\n \n       function Discrete_Expr_Cond\n-        (Expr : Node_Id;\n-         Typ  : Entity_Id) return Node_Id;\n+        (Exp : Node_Id;\n+         Typ : Entity_Id) return Node_Id;\n       --  Returns expression to compute:\n-      --    Expr < Typ'First\n+      --    Exp < Typ'First\n       --      or else\n-      --    Expr > Typ'Last\n+      --    Exp > Typ'Last\n \n       function Get_E_First_Or_Last\n         (Loc  : Source_Ptr;\n@@ -10169,11 +10169,11 @@ package body Checks is\n       --    Exptyp'First /= Typ'First or else Exptyp'Last /= Typ'Last\n \n       function Range_N_Cond\n-        (Expr : Node_Id;\n+        (Exp  : Node_Id;\n          Typ  : Entity_Id;\n          Indx : Nat) return Node_Id;\n       --  Return expression to compute:\n-      --    Expr'First < Typ'First or else Expr'Last > Typ'Last\n+      --    Exp'First < Typ'First or else Exp'Last > Typ'Last\n \n       ---------------\n       -- Add_Check --\n@@ -10200,8 +10200,8 @@ package body Checks is\n       -------------------------\n \n       function Discrete_Expr_Cond\n-        (Expr : Node_Id;\n-         Typ  : Entity_Id) return Node_Id\n+        (Exp : Node_Id;\n+         Typ : Entity_Id) return Node_Id\n       is\n       begin\n          return\n@@ -10210,7 +10210,7 @@ package body Checks is\n                Make_Op_Lt (Loc,\n                  Left_Opnd =>\n                    Convert_To (Base_Type (Typ),\n-                     Duplicate_Subexpr_No_Checks (Expr)),\n+                     Duplicate_Subexpr_No_Checks (Exp)),\n                  Right_Opnd =>\n                    Convert_To (Base_Type (Typ),\n                                Get_E_First_Or_Last (Loc, Typ, 0, Name_First))),\n@@ -10219,7 +10219,7 @@ package body Checks is\n                Make_Op_Gt (Loc,\n                  Left_Opnd =>\n                    Convert_To (Base_Type (Typ),\n-                     Duplicate_Subexpr_No_Checks (Expr)),\n+                     Duplicate_Subexpr_No_Checks (Exp)),\n                  Right_Opnd =>\n                    Convert_To\n                      (Base_Type (Typ),\n@@ -10231,11 +10231,11 @@ package body Checks is\n       -------------------------\n \n       function Discrete_Range_Cond\n-        (Expr : Node_Id;\n-         Typ  : Entity_Id) return Node_Id\n+        (Exp : Node_Id;\n+         Typ : Entity_Id) return Node_Id\n       is\n-         LB : Node_Id := Low_Bound (Expr);\n-         HB : Node_Id := High_Bound (Expr);\n+         LB : Node_Id := Low_Bound (Exp);\n+         HB : Node_Id := High_Bound (Exp);\n \n          Left_Opnd  : Node_Id;\n          Right_Opnd : Node_Id;\n@@ -10391,7 +10391,7 @@ package body Checks is\n       ------------------\n \n       function Range_N_Cond\n-        (Expr : Node_Id;\n+        (Exp  : Node_Id;\n          Typ  : Entity_Id;\n          Indx : Nat) return Node_Id\n       is\n@@ -10401,14 +10401,14 @@ package body Checks is\n              Left_Opnd =>\n                Make_Op_Lt (Loc,\n                  Left_Opnd  =>\n-                   Get_N_First (Expr, Indx),\n+                   Get_N_First (Exp, Indx),\n                  Right_Opnd =>\n                    Get_E_First_Or_Last (Loc, Typ, Indx, Name_First)),\n \n              Right_Opnd =>\n                Make_Op_Gt (Loc,\n                  Left_Opnd  =>\n-                   Get_N_Last (Expr, Indx),\n+                   Get_N_Last (Exp, Indx),\n                  Right_Opnd =>\n                    Get_E_First_Or_Last (Loc, Typ, Indx, Name_Last)));\n       end Range_N_Cond;\n@@ -10427,19 +10427,19 @@ package body Checks is\n \n       if Target_Typ = Any_Type\n         or else Target_Typ = Any_Composite\n-        or else Raises_Constraint_Error (Ck_Node)\n+        or else Raises_Constraint_Error (Expr)\n       then\n          return Ret_Result;\n       end if;\n \n       if No (Wnode) then\n-         Wnode := Ck_Node;\n+         Wnode := Expr;\n       end if;\n \n       T_Typ := Target_Typ;\n \n       if No (Source_Typ) then\n-         S_Typ := Etype (Ck_Node);\n+         S_Typ := Etype (Expr);\n       else\n          S_Typ := Source_Typ;\n       end if;\n@@ -10449,7 +10449,7 @@ package body Checks is\n       end if;\n \n       --  The order of evaluating T_Typ before S_Typ seems to be critical\n-      --  because S_Typ can be derived from Etype (Ck_Node), if it's not passed\n+      --  because S_Typ can be derived from Etype (Expr), if it's not passed\n       --  in, and since Node can be an N_Range node, it might be invalid.\n       --  Should there be an assert check somewhere for taking the Etype of\n       --  an N_Range node ???\n@@ -10461,19 +10461,19 @@ package body Checks is\n \n          --  A simple optimization for the null case\n \n-         if Known_Null (Ck_Node) then\n+         if Known_Null (Expr) then\n             return Ret_Result;\n          end if;\n       end if;\n \n       --  For an N_Range Node, check for a null range and then if not\n       --  null generate a range check action.\n \n-      if Nkind (Ck_Node) = N_Range then\n+      if Nkind (Expr) = N_Range then\n \n          --  There's no point in checking a range against itself\n \n-         if Ck_Node = Scalar_Range (T_Typ) then\n+         if Expr = Scalar_Range (T_Typ) then\n             return Ret_Result;\n          end if;\n \n@@ -10483,8 +10483,8 @@ package body Checks is\n             Known_T_LB : constant Boolean := Compile_Time_Known_Value (T_LB);\n             Known_T_HB : constant Boolean := Compile_Time_Known_Value (T_HB);\n \n-            LB         : Node_Id := Low_Bound (Ck_Node);\n-            HB         : Node_Id := High_Bound (Ck_Node);\n+            LB         : Node_Id := Low_Bound (Expr);\n+            HB         : Node_Id := High_Bound (Expr);\n             Known_LB   : Boolean := False;\n             Known_HB   : Boolean := False;\n \n@@ -10568,7 +10568,7 @@ package body Checks is\n                      if No (Warn_Node) then\n                         Add_Check\n                           (Compile_Time_Constraint_Error\n-                             (Low_Bound (Ck_Node),\n+                             (Low_Bound (Expr),\n                               \"static value out of range of}??\", T_Typ));\n \n                      else\n@@ -10583,7 +10583,7 @@ package body Checks is\n                      if No (Warn_Node) then\n                         Add_Check\n                           (Compile_Time_Constraint_Error\n-                             (High_Bound (Ck_Node),\n+                             (High_Bound (Expr),\n                               \"static value out of range of}??\", T_Typ));\n \n                      else\n@@ -10597,8 +10597,8 @@ package body Checks is\n \n             else\n                declare\n-                  LB : Node_Id := Low_Bound (Ck_Node);\n-                  HB : Node_Id := High_Bound (Ck_Node);\n+                  LB : Node_Id := Low_Bound (Expr);\n+                  HB : Node_Id := High_Bound (Expr);\n \n                begin\n                   --  If either bound is a discriminant and we are within the\n@@ -10641,7 +10641,7 @@ package body Checks is\n                      end if;\n                   end if;\n \n-                  Cond := Discrete_Range_Cond (Ck_Node, T_Typ);\n+                  Cond := Discrete_Range_Cond (Expr, T_Typ);\n                   Set_Paren_Count (Cond, 1);\n \n                   Cond :=\n@@ -10668,15 +10668,15 @@ package body Checks is\n          --  arbitrary target type, so we do that here.\n \n          if Ekind (Base_Type (S_Typ)) /= Ekind (Base_Type (T_Typ)) then\n-            Cond := Discrete_Expr_Cond (Ck_Node, T_Typ);\n+            Cond := Discrete_Expr_Cond (Expr, T_Typ);\n \n          --  For literals, we can tell if the constraint error will be\n          --  raised at compile time, so we never need a dynamic check, but\n          --  if the exception will be raised, then post the usual warning,\n          --  and replace the literal with a raise constraint error\n          --  expression. As usual, skip this for access types\n \n-         elsif Compile_Time_Known_Value (Ck_Node) and then not Do_Access then\n+         elsif Compile_Time_Known_Value (Expr) and then not Do_Access then\n             declare\n                LB : constant Node_Id := Type_Low_Bound (T_Typ);\n                UB : constant Node_Id := Type_High_Bound (T_Typ);\n@@ -10692,17 +10692,17 @@ package body Checks is\n                if Static_Bounds then\n                   if Is_Floating_Point_Type (S_Typ) then\n                      Out_Of_Range :=\n-                       (Expr_Value_R (Ck_Node) < Expr_Value_R (LB))\n+                       (Expr_Value_R (Expr) < Expr_Value_R (LB))\n                          or else\n-                       (Expr_Value_R (Ck_Node) > Expr_Value_R (UB));\n+                       (Expr_Value_R (Expr) > Expr_Value_R (UB));\n \n                   --  Fixed or discrete type\n \n                   else\n                      Out_Of_Range :=\n-                       Expr_Value (Ck_Node) < Expr_Value (LB)\n+                       Expr_Value (Expr) < Expr_Value (LB)\n                          or else\n-                       Expr_Value (Ck_Node) > Expr_Value (UB);\n+                       Expr_Value (Expr) > Expr_Value (UB);\n                   end if;\n \n                   --  Bounds of the type are static and the literal is out of\n@@ -10712,7 +10712,7 @@ package body Checks is\n                      if No (Warn_Node) then\n                         Add_Check\n                           (Compile_Time_Constraint_Error\n-                             (Ck_Node,\n+                             (Expr,\n                               \"static value out of range of}??\", T_Typ));\n \n                      else\n@@ -10724,7 +10724,7 @@ package body Checks is\n                   end if;\n \n                else\n-                  Cond := Discrete_Expr_Cond (Ck_Node, T_Typ);\n+                  Cond := Discrete_Expr_Cond (Expr, T_Typ);\n                end if;\n             end;\n \n@@ -10734,15 +10734,15 @@ package body Checks is\n \n          else\n             if not In_Subrange_Of (S_Typ, T_Typ) then\n-               Cond := Discrete_Expr_Cond (Ck_Node, T_Typ);\n+               Cond := Discrete_Expr_Cond (Expr, T_Typ);\n             end if;\n          end if;\n       end if;\n \n       if Is_Array_Type (T_Typ) and then Is_Array_Type (S_Typ) then\n          if Is_Constrained (T_Typ) then\n \n-            Expr_Actual := Get_Referenced_Object (Ck_Node);\n+            Expr_Actual := Get_Referenced_Object (Expr);\n             Exptyp      := Get_Actual_Subtype (Expr_Actual);\n \n             if Is_Access_Type (Exptyp) then\n@@ -10817,7 +10817,7 @@ package body Checks is\n             --  the length or range from the expression itself, making sure we\n             --  do not evaluate it more than once.\n \n-            --  Here Ck_Node is the original expression, or more properly the\n+            --  Here Expr is the original expression, or more properly the\n             --  result of applying Duplicate_Expr to the original tree,\n             --  forcing the result to be a name.\n \n@@ -10830,7 +10830,7 @@ package body Checks is\n \n                   for Indx in 1 .. Ndims loop\n                      Evolve_Or_Else\n-                       (Cond, Range_N_Cond (Ck_Node, T_Typ, Indx));\n+                       (Cond, Range_N_Cond (Expr, T_Typ, Indx));\n                   end loop;\n                end;\n             end if;\n@@ -10843,7 +10843,7 @@ package body Checks is\n             --  array type, as 4.6(24.15/2) requires the designated subtypes\n             --  of the two access types to statically match.\n \n-            if Nkind (Parent (Ck_Node)) = N_Type_Conversion\n+            if Nkind (Parent (Expr)) = N_Type_Conversion\n               and then not Do_Access\n             then\n                declare\n@@ -10852,7 +10852,7 @@ package body Checks is\n                   Opnd_Range : Node_Id;\n \n                begin\n-                  Opnd_Index := First_Index (Get_Actual_Subtype (Ck_Node));\n+                  Opnd_Index := First_Index (Get_Actual_Subtype (Expr));\n                   Targ_Index := First_Index (T_Typ);\n                   while Present (Opnd_Index) loop\n \n@@ -10923,7 +10923,7 @@ package body Checks is\n \n       if Present (Cond) then\n          if Do_Access then\n-            Cond := Guard_Access (Cond, Loc, Ck_Node);\n+            Cond := Guard_Access (Cond, Loc, Expr);\n          end if;\n \n          Add_Check"}, {"sha": "eeb77201871807b16cd3de36fe69631109480dfa", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c8e70fe86da1b52160aa380f30cbb1bf644c407/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c8e70fe86da1b52160aa380f30cbb1bf644c407/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=6c8e70fe86da1b52160aa380f30cbb1bf644c407", "patch": "@@ -526,12 +526,6 @@ package Checks is\n    --                this node is further examined depends on the setting of\n    --                the parameter Source_Typ, as described below.\n \n-   --    ??? Apply_Length_Check and Apply_Range_Check do not have an Expr\n-   --        formal\n-\n-   --    ??? Apply_Length_Check and Apply_Range_Check have a Ck_Node formal\n-   --        which is undocumented, is it the same as Expr?\n-\n    --    Target_Typ  The target type on which the check is to be based. For\n    --                example, if we have a scalar range check, then the check\n    --                is that we are in range of this type.\n@@ -558,7 +552,7 @@ package Checks is\n    --  handled by the caller.\n \n    procedure Apply_Length_Check\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty);\n    --  This procedure builds a sequence of declarations to do a length check\n@@ -576,7 +570,7 @@ package Checks is\n    --  in this section.\n \n    procedure Apply_Range_Check\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty);\n    --  For a Node of kind N_Range, constructs a range check action that tests\n@@ -628,7 +622,7 @@ package Checks is\n    --  call to Insert_Range_Checks procedure.\n \n    function Get_Range_Checks\n-     (Ck_Node    : Node_Id;\n+     (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty;\n       Warn_Node  : Node_Id   := Empty) return Check_Result;"}]}