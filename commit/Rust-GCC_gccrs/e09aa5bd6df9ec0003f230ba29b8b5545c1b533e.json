{"sha": "e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA5YWE1YmQ2ZGY5ZWMwMDAzZjIzMGJhMjliOGI1NTQ1YzFiNTMzZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-12-23T15:49:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-12-23T15:49:43Z"}, "message": "builtins.c (unterminated_array): Rename \"data\" to \"lendata\".\n\n\t* builtins.c (unterminated_array): Rename \"data\" to \"lendata\".  Fix\n\ta few comments.\n\t(expand_builtin_strnlen, expand_builtin_stpcpy_1): Likewise.\n\t(fold_builtin_strlen): Likewise.\n\t* gimple-fold.c (get_range_strlen): Likewise.  Also rename a couple\n\tinstances of \"type\" to \"optype\" and \"arg\" to \"fld\".\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r267377", "tree": {"sha": "19ebc8a5196574fe141f83eee366f522faec0a65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19ebc8a5196574fe141f83eee366f522faec0a65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f46ef1ff6b040f8b61ef6311cbb025694db3594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f46ef1ff6b040f8b61ef6311cbb025694db3594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f46ef1ff6b040f8b61ef6311cbb025694db3594"}], "stats": {"total": 115, "additions": 62, "deletions": 53}, "files": [{"sha": "f1f9d70f25bc40dc9511dc9b237447e696fa9f45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "patch": "@@ -1,6 +1,13 @@\n 2018-12-23  Martin Sebor  <msebor@redhat.com>\n \t    Jeff Law  <law@redhat.com>\n \n+\t* builtins.c (unterminated_array): Rename \"data\" to \"lendata\".  Fix\n+\ta few comments.\n+\t(expand_builtin_strnlen, expand_builtin_stpcpy_1): Likewise.\n+\t(fold_builtin_strlen): Likewise.\n+\t* gimple-fold.c (get_range_strlen): Likewise.  Also rename a couple\n+\tinstances of \"type\" to \"optype\" and \"arg\" to \"fld\".\n+\n \t* builtins.c (unterminated_array): Use empty brace initialization\n \tfor c_strlen_data.\n \t(c_strlen, expand_builtin_strnlen): Likewise."}, {"sha": "0eb3df9ccc171479881f5d80112594e3b9ec2eef", "filename": "gcc/builtins.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "patch": "@@ -575,25 +575,25 @@ unterminated_array (tree exp, tree *size /* = NULL */, bool *exact /* = NULL */)\n {\n   /* C_STRLEN will return NULL and set DECL in the info\n      structure if EXP references a unterminated array.  */\n-  c_strlen_data data = { };\n-  tree len = c_strlen (exp, 1, &data);\n-  if (len == NULL_TREE && data.len && data.decl)\n+  c_strlen_data lendata = { };\n+  tree len = c_strlen (exp, 1, &lendata);\n+  if (len == NULL_TREE && lendata.len && lendata.decl)\n      {\n        if (size)\n \t{\n-\t  len = data.len;\n-\t  if (data.off)\n+\t  len = lendata.len;\n+\t  if (lendata.off)\n \t    {\n-\t      /* Constant offsets are already accounted for in data.len, but\n-\t\t not in a SSA_NAME + CST expression.  */\n-\t      if (TREE_CODE (data.off) == INTEGER_CST)\n+\t      /* Constant offsets are already accounted for in LENDATA.MINLEN,\n+\t\t but not in a SSA_NAME + CST expression.  */\n+\t      if (TREE_CODE (lendata.off) == INTEGER_CST)\n \t\t*exact = true;\n-\t      else if (TREE_CODE (data.off) == PLUS_EXPR\n-\t\t       && TREE_CODE (TREE_OPERAND (data.off, 1)) == INTEGER_CST)\n+\t      else if (TREE_CODE (lendata.off) == PLUS_EXPR\n+\t\t       && TREE_CODE (TREE_OPERAND (lendata.off, 1)) == INTEGER_CST)\n \t\t{\n \t\t  /* Subtract the offset from the size of the array.  */\n \t\t  *exact = false;\n-\t\t  tree temp = TREE_OPERAND (data.off, 1);\n+\t\t  tree temp = TREE_OPERAND (lendata.off, 1);\n \t\t  temp = fold_convert (ssizetype, temp);\n \t\t  len = fold_build2 (MINUS_EXPR, ssizetype, len, temp);\n \t\t}\n@@ -605,7 +605,7 @@ unterminated_array (tree exp, tree *size /* = NULL */, bool *exact /* = NULL */)\n \n \t  *size = len;\n \t}\n-       return data.decl;\n+       return lendata.decl;\n      }\n \n   return NULL_TREE;\n@@ -3083,8 +3083,8 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n \n   /* FIXME: Change c_strlen() to return sizetype instead of ssizetype\n      so these conversions aren't necessary.  */\n-  c_strlen_data data { };\n-  tree len = c_strlen (src, 0, &data, 1);\n+  c_strlen_data lendata = { };\n+  tree len = c_strlen (src, 0, &lendata, 1);\n   if (len)\n     len = fold_convert_loc (loc, TREE_TYPE (bound), len);\n \n@@ -3106,12 +3106,12 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n \t       strnlen (&a[i], sizeof a)\n \t     where the value of i is unknown.  Unless i's value is\n \t     zero, the call is unsafe because the bound is greater. */\n-\t  data.decl = unterminated_array (src, &len, &exact);\n-\t  if (!data.decl)\n+\t  lendata.decl = unterminated_array (src, &len, &exact);\n+\t  if (!lendata.decl)\n \t    return NULL_RTX;\n \t}\n \n-      if (data.decl\n+      if (lendata.decl\n \t  && !TREE_NO_WARNING (exp)\n \t  && ((tree_int_cst_lt (len, bound))\n \t      || !exact))\n@@ -3127,7 +3127,7 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n \t\t\t       \"of at most %E of unterminated array\"),\n \t\t\t  exp, func, bound, len))\n \t    {\n-\t      inform (DECL_SOURCE_LOCATION (data.decl),\n+\t      inform (DECL_SOURCE_LOCATION (lendata.decl),\n \t\t      \"referenced argument declared here\");\n \t      TREE_NO_WARNING (exp) = true;\n \t      return NULL_RTX;\n@@ -3160,12 +3160,12 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n   bool exact = true;\n   if (!len || TREE_CODE (len) != INTEGER_CST)\n     {\n-      data.decl = unterminated_array (src, &len, &exact);\n-      if (!data.decl)\n+      lendata.decl = unterminated_array (src, &len, &exact);\n+      if (!lendata.decl)\n \treturn NULL_RTX;\n     }\n \n-  if (data.decl\n+  if (lendata.decl\n       && !TREE_NO_WARNING (exp)\n       && (wi::ltu_p (wi::to_wide (len), min)\n \t  || !exact))\n@@ -3181,13 +3181,13 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n \t\t\t   \"the size of at most %E of unterminated array\"),\n \t\t      exp, func, min.to_uhwi (), max.to_uhwi (), len))\n \t{\n-\t  inform (DECL_SOURCE_LOCATION (data.decl),\n+\t  inform (DECL_SOURCE_LOCATION (lendata.decl),\n \t\t  \"referenced argument declared here\");\n \t  TREE_NO_WARNING (exp) = true;\n \t}\n     }\n \n-  if (data.decl)\n+  if (lendata.decl)\n     return NULL_RTX;\n \n   if (wi::gtu_p (min, wi::to_wide (len)))\n@@ -4083,14 +4083,14 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \t compile-time, not an expression containing a string.  This is\n \t because the latter will potentially produce pessimized code\n \t when used to produce the return value.  */\n-      c_strlen_data data = { };\n+      c_strlen_data lendata = { };\n       if (!c_getstr (src, NULL)\n-\t  || !(len = c_strlen (src, 0, &data, 1)))\n+\t  || !(len = c_strlen (src, 0, &lendata, 1)))\n \treturn expand_movstr (dst, src, target,\n \t\t\t      /*retmode=*/ RETURN_END_MINUS_ONE);\n \n-      if (data.decl && !TREE_NO_WARNING (exp))\n-\twarn_string_no_nul (EXPR_LOCATION (exp), \"stpcpy\", src, data.decl);\n+      if (lendata.decl && !TREE_NO_WARNING (exp))\n+\twarn_string_no_nul (EXPR_LOCATION (exp), \"stpcpy\", src, lendata.decl);\n \n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n       ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n@@ -8567,22 +8567,22 @@ fold_builtin_strlen (location_t loc, tree type, tree arg)\n     return NULL_TREE;\n   else\n     {\n-      c_strlen_data data = { };\n-      tree len = c_strlen (arg, 0, &data);\n+      c_strlen_data lendata = { };\n+      tree len = c_strlen (arg, 0, &lendata);\n \n       if (len)\n \treturn fold_convert_loc (loc, type, len);\n \n-      if (!data.decl)\n-\tc_strlen (arg, 1, &data);\n+      if (!lendata.decl)\n+\tc_strlen (arg, 1, &lendata);\n \n-      if (data.decl)\n+      if (lendata.decl)\n \t{\n \t  if (EXPR_HAS_LOCATION (arg))\n \t    loc = EXPR_LOCATION (arg);\n \t  else if (loc == UNKNOWN_LOCATION)\n \t    loc = input_location;\n-\t  warn_string_no_nul (loc, \"strlen\", arg, data.decl);\n+\t  warn_string_no_nul (loc, \"strlen\", arg, lendata.decl);\n \t}\n \n       return NULL_TREE;"}, {"sha": "0ba151498904cd2a3a3f6d276be0b0322b8ca502", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "patch": "@@ -1335,16 +1335,16 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t}\n       else\n \t{\n-\t  c_strlen_data data = { };\n-\t  val = c_strlen (arg, 1, &data, eltsize);\n+\t  c_strlen_data lendata = { };\n+\t  val = c_strlen (arg, 1, &lendata, eltsize);\n \n \t  /* If we potentially had a non-terminated string, then\n \t     bubble that information up to the caller.  */\n-\t  if (!val && data.decl)\n+\t  if (!val && lendata.decl)\n \t    {\n-\t      *nonstr = data.decl;\n-\t      *minlen = data.len;\n-\t      *maxlen = data.len;\n+\t      *nonstr = lendata.decl;\n+\t      *minlen = lendata.len;\n+\t      *maxlen = lendata.len;\n \t      return type == 0 ? false : true;\n \t    }\n \t}\n@@ -1358,20 +1358,21 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \n \t  if (TREE_CODE (arg) == ARRAY_REF)\n \t    {\n-\t      tree type = TREE_TYPE (TREE_OPERAND (arg, 0));\n+\t      tree optype = TREE_TYPE (TREE_OPERAND (arg, 0));\n \n \t      /* Determine the \"innermost\" array type.  */\n-\t      while (TREE_CODE (type) == ARRAY_TYPE\n-\t\t     && TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n-\t\ttype = TREE_TYPE (type);\n+\t      while (TREE_CODE (optype) == ARRAY_TYPE\n+\t\t     && TREE_CODE (TREE_TYPE (optype)) == ARRAY_TYPE)\n+\t\toptype = TREE_TYPE (optype);\n \n \t      /* Avoid arrays of pointers.  */\n-\t      tree eltype = TREE_TYPE (type);\n-\t      if (TREE_CODE (type) != ARRAY_TYPE\n+\t      tree eltype = TREE_TYPE (optype);\n+\t      if (TREE_CODE (optype) != ARRAY_TYPE\n \t\t  || !INTEGRAL_TYPE_P (eltype))\n \t\treturn false;\n \n-\t      val = TYPE_SIZE_UNIT (type);\n+\t      /* Fail when the array bound is unknown or zero.  */\n+\t      val = TYPE_SIZE_UNIT (optype);\n \t      if (!val || integer_zerop (val))\n \t\treturn false;\n \n@@ -1382,7 +1383,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t      *minlen = ssize_int (0);\n \n \t      if (TREE_CODE (TREE_OPERAND (arg, 0)) == COMPONENT_REF\n-\t\t  && type == TREE_TYPE (TREE_OPERAND (arg, 0))\n+\t\t  && optype == TREE_TYPE (TREE_OPERAND (arg, 0))\n \t\t  && array_at_struct_end_p (TREE_OPERAND (arg, 0)))\n \t\t*flexp = true;\n \t    }\n@@ -1401,16 +1402,17 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t      if (array_at_struct_end_p (arg))\n \t\t*flexp = true;\n \n-\t      arg = TREE_OPERAND (arg, 1);\n+\t      tree fld = TREE_OPERAND (arg, 1);\n \n-\t      tree type = TREE_TYPE (arg);\n+\t      tree optype = TREE_TYPE (fld);\n \n-\t      while (TREE_CODE (type) == ARRAY_TYPE\n-\t\t     && TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n-\t\ttype = TREE_TYPE (type);\n+\t      /* Determine the \"innermost\" array type.  */\n+\t      while (TREE_CODE (optype) == ARRAY_TYPE\n+\t\t     && TREE_CODE (TREE_TYPE (optype)) == ARRAY_TYPE)\n+\t\toptype = TREE_TYPE (optype);\n \n \t      /* Fail when the array bound is unknown or zero.  */\n-\t      val = TYPE_SIZE_UNIT (type);\n+\t      val = TYPE_SIZE_UNIT (optype);\n \t      if (!val || integer_zerop (val))\n \t\treturn false;\n \t      val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,"}]}