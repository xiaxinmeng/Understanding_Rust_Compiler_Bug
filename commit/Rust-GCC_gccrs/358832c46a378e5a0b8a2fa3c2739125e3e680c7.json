{"sha": "358832c46a378e5a0b8a2fa3c2739125e3e680c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU4ODMyYzQ2YTM3OGU1YTBiOGEyZmEzYzI3MzkxMjVlM2U2ODBjNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-05-23T02:19:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-05-24T20:24:45Z"}, "message": "compiler: mark global variables whose address is taken\n\nTo implement this, change the backend to use flag bits for variables.\n\nFixes https://gcc.gnu.org/PR100537\n\n\tPR go/100537\n\t* go-gcc.cc (class Gcc_backend): Update methods that create\n\tvariables to take a flags parameter.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/322129", "tree": {"sha": "9217b12417ae68331c8efd66fd230414b12b98dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9217b12417ae68331c8efd66fd230414b12b98dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/358832c46a378e5a0b8a2fa3c2739125e3e680c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358832c46a378e5a0b8a2fa3c2739125e3e680c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/358832c46a378e5a0b8a2fa3c2739125e3e680c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358832c46a378e5a0b8a2fa3c2739125e3e680c7/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c43f5ec9db163696de8691eb529df06c4999bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c43f5ec9db163696de8691eb529df06c4999bcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c43f5ec9db163696de8691eb529df06c4999bcc"}], "stats": {"total": 460, "additions": 276, "deletions": 184}, "files": [{"sha": "41f309e72942acbc454bcc6ef5b85120178f0c9e", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 105, "deletions": 50, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=358832c46a378e5a0b8a2fa3c2739125e3e680c7", "patch": "@@ -415,47 +415,46 @@ class Gcc_backend : public Backend\n   global_variable(const std::string& var_name,\n \t\t  const std::string& asm_name,\n \t\t  Btype* btype,\n-\t\t  bool is_external,\n-\t\t  bool is_hidden,\n-\t\t  bool in_unique_section,\n+\t\t  unsigned int flags,\n \t\t  Location location);\n \n   void\n   global_variable_set_init(Bvariable*, Bexpression*);\n \n   Bvariable*\n-  local_variable(Bfunction*, const std::string&, Btype*, Bvariable*, bool,\n-\t\t Location);\n+  local_variable(Bfunction*, const std::string&, Btype*, Bvariable*,\n+\t\t unsigned int, Location);\n \n   Bvariable*\n-  parameter_variable(Bfunction*, const std::string&, Btype*, bool,\n+  parameter_variable(Bfunction*, const std::string&, Btype*, unsigned int,\n \t\t     Location);\n \n   Bvariable*\n-  static_chain_variable(Bfunction*, const std::string&, Btype*, Location);\n+  static_chain_variable(Bfunction*, const std::string&, Btype*, unsigned int,\n+\t\t\tLocation);\n \n   Bvariable*\n-  temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression*, bool,\n+  temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression*, unsigned int,\n \t\t     Location, Bstatement**);\n \n   Bvariable*\n   implicit_variable(const std::string&, const std::string&, Btype*,\n-                    bool, bool, bool, int64_t);\n+                    unsigned int, int64_t);\n \n   void\n   implicit_variable_set_init(Bvariable*, const std::string&, Btype*,\n-\t\t\t     bool, bool, bool, Bexpression*);\n+\t\t\t     unsigned int, Bexpression*);\n \n   Bvariable*\n   implicit_variable_reference(const std::string&, const std::string&, Btype*);\n \n   Bvariable*\n   immutable_struct(const std::string&, const std::string&,\n-                   bool, bool, Btype*, Location);\n+                   unsigned int, Btype*, Location);\n \n   void\n-  immutable_struct_set_init(Bvariable*, const std::string&, bool, bool, Btype*,\n-\t\t\t    Location, Bexpression*);\n+  immutable_struct_set_init(Bvariable*, const std::string&, unsigned int,\n+\t\t\t    Btype*, Location, Bexpression*);\n \n   Bvariable*\n   immutable_struct_reference(const std::string&, const std::string&,\n@@ -2696,9 +2695,7 @@ Bvariable*\n Gcc_backend::global_variable(const std::string& var_name,\n \t\t\t     const std::string& asm_name,\n \t\t\t     Btype* btype,\n-\t\t\t     bool is_external,\n-\t\t\t     bool is_hidden,\n-\t\t\t     bool in_unique_section,\n+\t\t\t     unsigned int flags,\n \t\t\t     Location location)\n {\n   tree type_tree = btype->get_tree();\n@@ -2707,30 +2704,49 @@ Gcc_backend::global_variable(const std::string& var_name,\n \n   // The GNU linker does not like dynamic variables with zero size.\n   tree orig_type_tree = type_tree;\n+  bool is_external = (flags & variable_is_external) != 0;\n+  bool is_hidden = (flags & variable_is_hidden) != 0;\n   if ((is_external || !is_hidden) && int_size_in_bytes(type_tree) == 0)\n     type_tree = this->non_zero_size_type(type_tree);\n \n   tree decl = build_decl(location.gcc_location(), VAR_DECL,\n \t\t\t get_identifier_from_string(var_name),\n \t\t\t type_tree);\n-  if (is_external)\n-    DECL_EXTERNAL(decl) = 1;\n-  else\n-    TREE_STATIC(decl) = 1;\n-  if (!is_hidden)\n+  if ((flags & variable_is_external) != 0)\n     {\n-      TREE_PUBLIC(decl) = 1;\n-      SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n+      DECL_EXTERNAL(decl) = 1;\n+      flags &=~ variable_is_external;\n     }\n   else\n+    TREE_STATIC(decl) = 1;\n+\n+  if ((flags & variable_is_hidden) == 0)\n+    TREE_PUBLIC(decl) = 1;\n+  else\n+    flags &=~ variable_is_hidden;\n+\n+  if ((flags & variable_address_is_taken) != 0)\n     {\n-      SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n+      TREE_ADDRESSABLE(decl) = 1;\n+      flags &=~ variable_address_is_taken;\n     }\n \n+  // We take the address in Bvariable::get_tree if orig_type_tree is\n+  // different from type_tree.\n+  if (orig_type_tree != type_tree)\n+    TREE_ADDRESSABLE(decl) = 1;\n+\n+  SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n+\n   TREE_USED(decl) = 1;\n \n-  if (in_unique_section)\n-    resolve_unique_section (decl, 0, 1);\n+  if ((flags & variable_in_unique_section) != 0)\n+    {\n+      resolve_unique_section (decl, 0, 1);\n+      flags &=~ variable_in_unique_section;\n+    }\n+\n+  gcc_assert(flags == 0);\n \n   go_preserve_from_gc(decl);\n \n@@ -2768,7 +2784,7 @@ Gcc_backend::global_variable_set_init(Bvariable* var, Bexpression* expr)\n Bvariable*\n Gcc_backend::local_variable(Bfunction* function, const std::string& name,\n \t\t\t    Btype* btype, Bvariable* decl_var, \n-\t\t\t    bool is_address_taken, Location location)\n+\t\t\t    unsigned int flags, Location location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n@@ -2778,13 +2794,17 @@ Gcc_backend::local_variable(Bfunction* function, const std::string& name,\n \t\t\t type_tree);\n   DECL_CONTEXT(decl) = function->get_tree();\n   TREE_USED(decl) = 1;\n-  if (is_address_taken)\n-    TREE_ADDRESSABLE(decl) = 1;\n+  if ((flags & variable_address_is_taken) != 0)\n+    {\n+      TREE_ADDRESSABLE(decl) = 1;\n+      flags &=~ variable_address_is_taken;\n+    }\n   if (decl_var != NULL)\n     {\n       DECL_HAS_VALUE_EXPR_P(decl) = 1;\n       SET_DECL_VALUE_EXPR(decl, decl_var->get_decl());\n     }\n+  go_assert(flags == 0);\n   go_preserve_from_gc(decl);\n   return new Bvariable(decl);\n }\n@@ -2793,7 +2813,7 @@ Gcc_backend::local_variable(Bfunction* function, const std::string& name,\n \n Bvariable*\n Gcc_backend::parameter_variable(Bfunction* function, const std::string& name,\n-\t\t\t\tBtype* btype, bool is_address_taken,\n+\t\t\t\tBtype* btype, unsigned int flags,\n \t\t\t\tLocation location)\n {\n   tree type_tree = btype->get_tree();\n@@ -2805,8 +2825,12 @@ Gcc_backend::parameter_variable(Bfunction* function, const std::string& name,\n   DECL_CONTEXT(decl) = function->get_tree();\n   DECL_ARG_TYPE(decl) = type_tree;\n   TREE_USED(decl) = 1;\n-  if (is_address_taken)\n-    TREE_ADDRESSABLE(decl) = 1;\n+  if ((flags & variable_address_is_taken) != 0)\n+    {\n+      TREE_ADDRESSABLE(decl) = 1;\n+      flags &=~ variable_address_is_taken;\n+    }\n+  go_assert(flags == 0);\n   go_preserve_from_gc(decl);\n   return new Bvariable(decl);\n }\n@@ -2815,7 +2839,8 @@ Gcc_backend::parameter_variable(Bfunction* function, const std::string& name,\n \n Bvariable*\n Gcc_backend::static_chain_variable(Bfunction* function, const std::string& name,\n-\t\t\t\t   Btype* btype, Location location)\n+\t\t\t\t   Btype* btype, unsigned int flags,\n+\t\t\t\t   Location location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n@@ -2840,6 +2865,7 @@ Gcc_backend::static_chain_variable(Bfunction* function, const std::string& name,\n   gcc_assert(f->static_chain_decl == NULL);\n   f->static_chain_decl = decl;\n   DECL_STATIC_CHAIN(fndecl) = 1;\n+  go_assert(flags == 0);\n \n   go_preserve_from_gc(decl);\n   return new Bvariable(decl);\n@@ -2850,7 +2876,7 @@ Gcc_backend::static_chain_variable(Bfunction* function, const std::string& name,\n Bvariable*\n Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n \t\t\t\tBtype* btype, Bexpression* binit,\n-\t\t\t\tbool is_address_taken,\n+\t\t\t\tunsigned int flags,\n \t\t\t\tLocation location,\n \t\t\t\tBstatement** pstatement)\n {\n@@ -2904,8 +2930,13 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n       && TREE_TYPE(init_tree) != void_type_node)\n     DECL_INITIAL(var) = this->convert_tree(type_tree, init_tree, location);\n \n-  if (is_address_taken)\n-    TREE_ADDRESSABLE(var) = 1;\n+  if ((flags & variable_address_is_taken) != 0)\n+    {\n+      TREE_ADDRESSABLE(var) = 1;\n+      flags &=~ variable_address_is_taken;\n+    }\n+\n+  gcc_assert(flags == 0);\n \n   *pstatement = this->make_statement(build1_loc(location.gcc_location(),\n                                                 DECL_EXPR,\n@@ -2929,8 +2960,8 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n Bvariable*\n Gcc_backend::implicit_variable(const std::string& name,\n                                const std::string& asm_name,\n-                               Btype* type, bool is_hidden, bool is_constant,\n-\t\t\t       bool is_common, int64_t alignment)\n+                               Btype* type, unsigned int flags,\n+\t\t\t       int64_t alignment)\n {\n   tree type_tree = type->get_tree();\n   if (type_tree == error_mark_node)\n@@ -2939,11 +2970,14 @@ Gcc_backend::implicit_variable(const std::string& name,\n   tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL,\n                          get_identifier_from_string(name), type_tree);\n   DECL_EXTERNAL(decl) = 0;\n-  TREE_PUBLIC(decl) = !is_hidden;\n+  if ((flags & variable_is_hidden) != 0)\n+    flags &=~ variable_is_hidden;\n+  else\n+    TREE_PUBLIC(decl) = 1;\n   TREE_STATIC(decl) = 1;\n   TREE_USED(decl) = 1;\n   DECL_ARTIFICIAL(decl) = 1;\n-  if (is_common)\n+  if ((flags & variable_is_common) != 0)\n     {\n       DECL_COMMON(decl) = 1;\n \n@@ -2960,11 +2994,19 @@ Gcc_backend::implicit_variable(const std::string& name,\n       // mark this symbol as weak here.  We undo that below in\n       // immutable_struct_set_init before calling mark_decl_one_only.\n       DECL_WEAK(decl) = 1;\n+\n+      flags &=~ variable_is_common;\n     }\n-  if (is_constant)\n+  if ((flags & variable_is_constant) != 0)\n     {\n       TREE_READONLY(decl) = 1;\n       TREE_CONSTANT(decl) = 1;\n+      flags &=~ variable_is_constant;\n+    }\n+  if ((flags & variable_address_is_taken) != 0)\n+    {\n+      TREE_ADDRESSABLE(decl) = 1;\n+      flags &=~ variable_address_is_taken;\n     }\n   if (alignment != 0)\n     {\n@@ -2973,6 +3015,7 @@ Gcc_backend::implicit_variable(const std::string& name,\n     }\n   if (! asm_name.empty())\n     SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n+  gcc_assert(flags == 0);\n \n   go_preserve_from_gc(decl);\n   return new Bvariable(decl);\n@@ -2983,7 +3026,7 @@ Gcc_backend::implicit_variable(const std::string& name,\n \n void\n Gcc_backend::implicit_variable_set_init(Bvariable* var, const std::string&,\n-\t\t\t\t\tBtype*, bool, bool, bool is_common,\n+\t\t\t\t\tBtype*, unsigned int flags,\n \t\t\t\t\tBexpression* init)\n {\n   tree decl = var->get_decl();\n@@ -2999,7 +3042,7 @@ Gcc_backend::implicit_variable_set_init(Bvariable* var, const std::string&,\n \n   // Now that DECL_INITIAL is set, we can't call make_decl_one_only.\n   // See the comment where DECL_WEAK is set in implicit_variable.\n-  if (is_common)\n+  if ((flags & variable_is_common) != 0)\n     {\n       DECL_WEAK(decl) = 0;\n       make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n@@ -3038,8 +3081,8 @@ Gcc_backend::implicit_variable_reference(const std::string& name,\n Bvariable*\n Gcc_backend::immutable_struct(const std::string& name,\n                               const std::string& asm_name,\n-                              bool is_hidden,\n-\t\t\t      bool is_common, Btype* btype, Location location)\n+\t\t\t      unsigned int flags, Btype* btype,\n+\t\t\t      Location location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n@@ -3053,10 +3096,17 @@ Gcc_backend::immutable_struct(const std::string& name,\n   TREE_READONLY(decl) = 1;\n   TREE_CONSTANT(decl) = 1;\n   DECL_ARTIFICIAL(decl) = 1;\n-  if (!is_hidden)\n+  if ((flags & variable_is_hidden) != 0)\n+    flags &=~ variable_is_hidden;\n+  else\n     TREE_PUBLIC(decl) = 1;\n   if (! asm_name.empty())\n     SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n+  if ((flags & variable_address_is_taken) != 0)\n+    {\n+      TREE_ADDRESSABLE(decl) = 1;\n+      flags &=~ variable_address_is_taken;\n+    }\n \n   // When the initializer for one immutable_struct refers to another,\n   // it needs to know the visibility of the referenced struct so that\n@@ -3070,8 +3120,13 @@ Gcc_backend::immutable_struct(const std::string& name,\n   // the right value if some other initializer refers to this one, we\n   // mark this symbol as weak here.  We undo that below in\n   // immutable_struct_set_init before calling mark_decl_one_only.\n-  if (is_common)\n-    DECL_WEAK(decl) = 1;\n+  if ((flags & variable_is_common) != 0)\n+    {\n+      DECL_WEAK(decl) = 1;\n+      flags &=~ variable_is_common;\n+    }\n+\n+  gcc_assert(flags == 0);\n \n   // We don't call rest_of_decl_compilation until we have the\n   // initializer.\n@@ -3085,7 +3140,7 @@ Gcc_backend::immutable_struct(const std::string& name,\n \n void\n Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n-\t\t\t\t       bool, bool is_common, Btype*, Location,\n+\t\t\t\t       unsigned int flags, Btype*, Location,\n \t\t\t\t       Bexpression* initializer)\n {\n   tree decl = var->get_decl();\n@@ -3097,7 +3152,7 @@ Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n \n   // Now that DECL_INITIAL is set, we can't call make_decl_one_only.\n   // See the comment where DECL_WEAK is set in immutable_struct.\n-  if (is_common)\n+  if ((flags & variable_is_common) != 0)\n     {\n       DECL_WEAK(decl) = 0;\n       make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));"}, {"sha": "1f38c9110ba6b112543de1a566e4ea06bc17f204", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=358832c46a378e5a0b8a2fa3c2739125e3e680c7", "patch": "@@ -1,4 +1,4 @@\n-38228e7a91d37588463307ec60420c8f17f1aee4\n+5a801b15699cced5203af5c7339b375cd55ecbac\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "5b6ffea0f6ce79a2a612074480f2d7b302f00564", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 76, "deletions": 69, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=358832c46a378e5a0b8a2fa3c2739125e3e680c7", "patch": "@@ -481,24 +481,51 @@ class Backend\n   virtual Bvariable*\n   error_variable() = 0;\n \n+  // Bit flags to pass to the various methods that return Bvariable*.\n+  // Not all flags are meaningful for all methods.\n+\n+  // Set if the variable's address is taken.  For a local variable\n+  // this implies that the address does not escape the function, as\n+  // otherwise the variable would be on the heap.\n+  static const unsigned int variable_address_is_taken = 1 << 0;\n+\n+  // Set if the variable is defined in some other package.  Only\n+  // meaningful for the global_variable method.  At most one of\n+  // is_external, is_hidden, and is_common may be set.\n+  static const unsigned int variable_is_external = 1 << 1;\n+\n+  // Set if the variable is not exported, and as such is only defined\n+  // in the current package.  Only meaningful for global_variable,\n+  // implicit_variable, and immutable_struct.  At most one of\n+  // is_external, is_hidden, and is_common may be set.\n+  static const unsigned variable_is_hidden = 1 << 2;\n+\n+  // Set if the variable should be treated as a common variable:\n+  // multiple definitions with different sizes permitted in different\n+  // object files, all merged into the largest definition at link\n+  // time.  Only meaningful for implicit_variable and immutable_struct.\n+  // At most one of is_external, is_hidden, and is_common may be set.\n+  static const unsigned int variable_is_common = 1 << 3;\n+\n+  // Set if the variable should be put into a unique section if\n+  // possible; this is intended to permit the linker to garbage\n+  // collect the value if it is not referenced.  Only meaningful for\n+  // global_variable.\n+  static const unsigned int variable_in_unique_section = 1 << 4;\n+\n+  // Set if the variable should be treated as immutable.  Only\n+  // meaningful for implicit_variable.  For example, this is set for\n+  // slice initializers if the values must be copied to the heap.\n+  static const unsigned int variable_is_constant = 1 << 5;\n+\n   // Create a global variable. NAME is the package-qualified name of\n   // the variable.  ASM_NAME is the encoded identifier for the\n   // variable, incorporating the package, and made safe for the\n-  // assembler.  BTYPE is the type of the variable.  IS_EXTERNAL is\n-  // true if the variable is defined in some other package.  IS_HIDDEN\n-  // is true if the variable is not exported (name begins with a lower\n-  // case letter).  IN_UNIQUE_SECTION is true if the variable should\n-  // be put into a unique section if possible; this is intended to\n-  // permit the linker to garbage collect the variable if it is not\n-  // referenced.  LOCATION is where the variable was defined.\n+  // assembler.  BTYPE is the type of the variable.  FLAGS is the bit\n+  // flags defined above.  LOCATION is where the variable was defined.\n   virtual Bvariable*\n-  global_variable(const std::string& name,\n-                  const std::string& asm_name,\n-\t\t  Btype* btype,\n-\t\t  bool is_external,\n-\t\t  bool is_hidden,\n-\t\t  bool in_unique_section,\n-\t\t  Location location) = 0;\n+  global_variable(const std::string& name, const std::string& asm_name,\n+\t\t  Btype* btype, unsigned int flags, Location location) = 0;\n \n   // A global variable will 1) be initialized to zero, or 2) be\n   // initialized to a constant value, or 3) be initialized in the init\n@@ -516,42 +543,40 @@ class Backend\n   // null, gives the location at which the value of this variable may\n   // be found, typically used to create an inner-scope reference to an\n   // outer-scope variable, to extend the lifetime of the variable beyond\n-  // the inner scope.  IS_ADDRESS_TAKEN is true if the address of this\n-  // variable is taken (this implies that the address does not escape\n-  // the function, as otherwise the variable would be on the heap).\n+  // the inner scope.  FLAGS is the bit flags defined above.\n   // LOCATION is where the variable is defined.  For each local variable\n   // the frontend will call init_statement to set the initial value.\n   virtual Bvariable*\n   local_variable(Bfunction* function, const std::string& name, Btype* type,\n-\t\t Bvariable* decl_var, bool is_address_taken, Location location) = 0;\n+\t\t Bvariable* decl_var, unsigned int flags,\n+\t\t Location location) = 0;\n \n   // Create a function parameter.  This is an incoming parameter, not\n   // a result parameter (result parameters are treated as local\n   // variables).  The arguments are as for local_variable.\n   virtual Bvariable*\n   parameter_variable(Bfunction* function, const std::string& name,\n-\t\t     Btype* type, bool is_address_taken,\n-\t\t     Location location) = 0;\n+\t\t     Btype* type, unsigned int flags, Location location) = 0;\n \n   // Create a static chain parameter.  This is the closure parameter.\n   virtual Bvariable*\n   static_chain_variable(Bfunction* function, const std::string& name,\n-\t\t        Btype* type, Location location) = 0;\n+\t\t        Btype* type, unsigned int flags,\n+\t\t\tLocation location) = 0;\n \n   // Create a temporary variable.  A temporary variable has no name,\n   // just a type.  We pass in FUNCTION and BLOCK in case they are\n   // needed.  If INIT is not NULL, the variable should be initialized\n   // to that value.  Otherwise the initial value is irrelevant--the\n   // backend does not have to explicitly initialize it to zero.\n-  // ADDRESS_IS_TAKEN is true if the programs needs to take the\n-  // address of this temporary variable.  LOCATION is the location of\n+  // FLAGS is the bit flags defined above.  LOCATION is the location of\n   // the statement or expression which requires creating the temporary\n   // variable, and may not be very useful.  This function should\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n   virtual Bvariable*\n   temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression* init,\n-\t\t     bool address_is_taken, Location location,\n+\t\t     unsigned int flags, Location location,\n \t\t     Bstatement** pstatement) = 0;\n \n   // Create an implicit variable that is compiler-defined.  This is\n@@ -566,46 +591,33 @@ class Backend\n   //\n   // TYPE is the type of the implicit variable.\n   //\n-  // IS_HIDDEN will be true if the descriptor should only be visible\n-  // within the current object.\n-  //\n-  // IS_CONSTANT is true if the implicit variable should be treated like it is\n-  // immutable.  For slice initializers, if the values must be copied to the\n-  // heap, the variable IS_CONSTANT.\n-  //\n-  // IS_COMMON is true if the implicit variable should\n-  // be treated as a common variable (multiple definitions with\n-  // different sizes permitted in different object files, all merged\n-  // into the largest definition at link time); this will be true for\n-  // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n+  // FLAGS is the bit flags defined above.\n   //\n   // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n   virtual Bvariable*\n   implicit_variable(const std::string& name, const std::string& asm_name,\n-                    Btype* type, bool is_hidden, bool is_constant,\n-                    bool is_common, int64_t alignment) = 0;\n+                    Btype* type, unsigned int flags, int64_t alignment) = 0;\n \n \n   // Set the initial value of a variable created by implicit_variable.\n   // This must be called even if there is no initializer, i.e., INIT is NULL.\n-  // The NAME, TYPE, IS_HIDDEN, IS_CONSTANT, and IS_COMMON parameters are\n-  // the same ones passed to implicit_variable.  INIT will be a composite\n-  // literal of type TYPE.  It will not contain any function calls or anything\n-  // else that can not be put into a read-only data section.\n-  // It may contain the address of variables created by implicit_variable.\n+  // The NAME, TYPE, and FLAGS parameters are the same ones passed to\n+  // implicit_variable.  INIT will be a composite literal of type\n+  // TYPE.  It will not contain any function calls or anything else\n+  // that can not be put into a read-only data section.  It may\n+  // contain the address of variables created by implicit_variable.\n   //\n-  // If IS_COMMON is true, INIT will be NULL, and the\n+  // If variable_is_common is set in FLAGS, INIT will be NULL, and the\n   // variable should be initialized to all zeros.\n   virtual void\n   implicit_variable_set_init(Bvariable*, const std::string& name, Btype* type,\n-\t\t\t     bool is_hidden, bool is_constant, bool is_common,\n-\t\t\t     Bexpression* init) = 0;\n+\t\t\t     unsigned int flags, Bexpression* init) = 0;\n \n   // Create a reference to a named implicit variable defined in some\n   // other package.  This will be a variable created by a call to\n   // implicit_variable with the same NAME, ASM_NAME and TYPE and with\n-  // IS_COMMON passed as false.  This corresponds to an extern global\n-  // variable in C.\n+  // variable_is_common not set in FLAGS.  This corresponds to an\n+  // extern global variable in C.\n   virtual Bvariable*\n   implicit_variable_reference(const std::string& name,\n                               const std::string& asm_name,\n@@ -622,15 +634,12 @@ class Backend\n   // ASM_NAME is the encoded, assembler-friendly version of NAME, or\n   // the empty string if no encoding is needed.\n   //\n-  // IS_HIDDEN will be true if the descriptor should only be visible\n-  // within the current object.\n-  //\n-  // IS_COMMON is true if NAME may be defined by several packages, and\n-  // the linker should merge all such definitions.  If IS_COMMON is\n-  // false, NAME should be defined in only one file.  In general\n-  // IS_COMMON will be true for the type descriptor of an unnamed type\n-  // or a builtin type.  IS_HIDDEN and IS_COMMON will never both be\n-  // true.\n+  // FLAGS is the bit flags defined above.  The variable_is_common\n+  // flag will be set if NAME may be defined by several packages, and\n+  // the linker should merge all such definitions.  If the\n+  // variable_is_common flag is not set, NAME should be defined in\n+  // only one file.  In general variable_is_common will be set for the\n+  // type descriptor of an unnamed type or a builtin type.\n   //\n   // TYPE will be a struct type; the type of the returned expression\n   // must be a pointer to this struct type.\n@@ -640,28 +649,26 @@ class Backend\n   // address.  After calling this the frontend will call\n   // immutable_struct_set_init.\n   virtual Bvariable*\n-  immutable_struct(const std::string& name,\n-                   const std::string& asm_name,\n-                   bool is_hidden, bool is_common,\n-\t\t   Btype* type, Location) = 0;\n+  immutable_struct(const std::string& name, const std::string& asm_name,\n+\t\t   unsigned int flags, Btype* type, Location) = 0;\n \n   // Set the initial value of a variable created by immutable_struct.\n-  // The NAME, IS_HIDDEN, IS_COMMON, TYPE, and location parameters are\n-  // the same ones passed to immutable_struct.  INITIALIZER will be a\n-  // composite literal of type TYPE.  It will not contain any function\n-  // calls or anything else that can not be put into a read-only data\n-  // section.  It may contain the address of variables created by\n+  // The NAME, FLAGS, TYPE, and location parameters are the same ones\n+  // passed to immutable_struct.  INITIALIZER will be a composite\n+  // literal of type TYPE.  It will not contain any function calls or\n+  // anything else that can not be put into a read-only data section.\n+  // It may contain the address of variables created by\n   // immutable_struct.\n   virtual void\n   immutable_struct_set_init(Bvariable*, const std::string& name,\n-\t\t\t    bool is_hidden, bool is_common, Btype* type,\n+\t\t\t    unsigned int flags, Btype* type,\n \t\t\t    Location, Bexpression* initializer) = 0;\n \n   // Create a reference to a named immutable initialized data\n   // structure defined in some other package.  This will be a\n   // structure created by a call to immutable_struct with the same\n-  // NAME, ASM_NAME and TYPE and with IS_COMMON passed as false.  This\n-  // corresponds to an extern const global variable in C.\n+  // NAME, ASM_NAME and TYPE and with variable_is_common not set in\n+  // flags.  This corresponds to an extern const global variable in C.\n   virtual Bvariable*\n   immutable_struct_reference(const std::string& name,\n                              const std::string& asm_name,"}, {"sha": "5d45e4baab4f11a8212b8bc03e07114456dbe905", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=358832c46a378e5a0b8a2fa3c2739125e3e680c7", "patch": "@@ -1427,7 +1427,7 @@ Sink_expression::do_get_backend(Translate_context* context)\n       Bstatement* decl;\n       this->bvar_ =\n \tgogo->backend()->temporary_variable(fn_ctx, context->bblock(), bt, NULL,\n-\t\t\t\t\t    false, loc, &decl);\n+\t\t\t\t\t    0, loc, &decl);\n       Bexpression* var_ref =\n           gogo->backend()->var_expression(this->bvar_, loc);\n       var_ref = gogo->backend()->compound_expression(decl, var_ref, loc);\n@@ -1724,10 +1724,12 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n       if (no->is_function() && no->func_value()->is_referenced_by_inline())\n \tis_hidden = false;\n \n+      unsigned int flags = 0;\n+      if (is_hidden)\n+\tflags |= Backend::variable_is_hidden;\n       bvar = context->backend()->immutable_struct(bname.name(),\n \t\t\t\t\t\t  bname.optional_asm_name(),\n-                                                  is_hidden, false,\n-\t\t\t\t\t\t  btype, bloc);\n+\t\t\t\t\t\t  flags, btype, bloc);\n       Expression_list* vals = new Expression_list();\n       vals->push_back(Expression::make_func_code_reference(this->fn_, bloc));\n       Expression* init =\n@@ -1736,8 +1738,7 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n       bcontext.set_is_const();\n       Bexpression* binit = init->get_backend(&bcontext);\n       context->backend()->immutable_struct_set_init(bvar, bname.name(),\n-\t\t\t\t\t\t    is_hidden, false, btype,\n-\t\t\t\t\t\t    bloc, binit);\n+\t\t\t\t\t\t    flags, btype, bloc, binit);\n     }\n \n   this->dvar_ = bvar;\n@@ -5280,12 +5281,14 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t      copy_to_heap = (context->function() != NULL\n                               || context->is_const());\n \t    }\n+\t  unsigned int flags = (Backend::variable_is_hidden\n+\t\t\t\t| Backend::variable_address_is_taken);\n+\t  if (copy_to_heap)\n+\t    flags |= Backend::variable_is_constant;\n \t  Bvariable* implicit =\n-              gogo->backend()->implicit_variable(var_name, \"\", btype, true,\n-\t\t\t\t\t\t copy_to_heap, false, 0);\n+\t    gogo->backend()->implicit_variable(var_name, \"\", btype, flags, 0);\n \t  gogo->backend()->implicit_variable_set_init(implicit, var_name, btype,\n-\t\t\t\t\t\t      true, copy_to_heap, false,\n-\t\t\t\t\t\t      bexpr);\n+\t\t\t\t\t\t      flags, bexpr);\n \t  bexpr = gogo->backend()->var_expression(implicit, loc);\n \n \t  // If we are not copying a slice initializer to the heap,\n@@ -5307,22 +5310,24 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t       && this->expr_->is_static_initializer())\n         {\n \t  std::string var_name(gogo->initializer_name());\n+\t  unsigned int flags = (Backend::variable_is_hidden\n+\t\t\t\t| Backend::variable_address_is_taken);\n           Bvariable* decl =\n-              gogo->backend()->immutable_struct(var_name, \"\", true, false,\n-\t\t\t\t\t\tbtype, loc);\n-          gogo->backend()->immutable_struct_set_init(decl, var_name, true,\n-\t\t\t\t\t\t     false, btype, loc, bexpr);\n+\t    gogo->backend()->immutable_struct(var_name, \"\", flags, btype, loc);\n+          gogo->backend()->immutable_struct_set_init(decl, var_name, flags,\n+\t\t\t\t\t\t     btype, loc, bexpr);\n           bexpr = gogo->backend()->var_expression(decl, loc);\n         }\n       else if (this->expr_->is_constant())\n         {\n           std::string var_name(gogo->initializer_name());\n+\t  unsigned int flags = (Backend::variable_is_hidden\n+\t\t\t\t| Backend::variable_is_constant\n+\t\t\t\t| Backend::variable_address_is_taken);\n           Bvariable* decl =\n-              gogo->backend()->implicit_variable(var_name, \"\", btype,\n-                                                 true, true, false, 0);\n+\t    gogo->backend()->implicit_variable(var_name, \"\", btype, flags, 0);\n           gogo->backend()->implicit_variable_set_init(decl, var_name, btype,\n-                                                      true, true, false,\n-                                                      bexpr);\n+\t\t\t\t\t\t      flags, bexpr);\n           bexpr = gogo->backend()->var_expression(decl, loc);\n         }\n \n@@ -14888,7 +14893,9 @@ Allocation_expression::do_get_backend(Translate_context* context)\n                            : gogo->backend()->zero_expression(btype));\n       Bvariable* temp =\n         gogo->backend()->temporary_variable(fndecl, context->bblock(), btype,\n-                                            init, true, loc, &decl);\n+                                            init,\n+\t\t\t\t\t    Backend::variable_address_is_taken,\n+\t\t\t\t\t    loc, &decl);\n       Bexpression* ret = gogo->backend()->var_expression(temp, loc);\n       ret = gogo->backend()->address_expression(ret, loc);\n       ret = gogo->backend()->compound_expression(decl, ret, loc);\n@@ -17238,7 +17245,9 @@ Heap_expression::do_get_backend(Translate_context* context)\n   Bfunction* fndecl = fn->func_value()->get_or_make_decl(gogo, fn);\n   Bvariable* space_temp =\n     gogo->backend()->temporary_variable(fndecl, context->bblock(), btype,\n-\t\t\t\t\tspace, true, loc, &decl);\n+\t\t\t\t\tspace,\n+\t\t\t\t\tBackend::variable_address_is_taken,\n+\t\t\t\t\tloc, &decl);\n   Btype* expr_btype = etype->get_backend(gogo);\n \n   Bexpression* bexpr = this->expr_->get_backend(context);\n@@ -17259,8 +17268,9 @@ Heap_expression::do_get_backend(Translate_context* context)\n       Bstatement* edecl;\n       Bvariable* btemp =\n \tgogo->backend()->temporary_variable(fndecl, context->bblock(),\n-\t\t\t\t\t    expr_btype, bexpr, true, loc,\n-\t\t\t\t\t    &edecl);\n+\t\t\t\t\t    expr_btype, bexpr,\n+\t\t\t\t\t    Backend::variable_address_is_taken,\n+\t\t\t\t\t    loc, &edecl);\n       Bexpression* btempref = gogo->backend()->var_expression(btemp,\n \t\t\t\t\t\t\t      loc);\n       space = gogo->backend()->var_expression(space_temp, loc);\n@@ -18478,10 +18488,13 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n   Bexpression* ctor =\n       gogo->backend()->constructor_expression(btype, ctor_bexprs, loc);\n \n-  this->bvar_ = gogo->backend()->immutable_struct(mangled_name, \"\", false,\n-\t\t\t\t\t\t  !is_public, btype, loc);\n-  gogo->backend()->immutable_struct_set_init(this->bvar_, mangled_name, false,\n-                                             !is_public, btype, loc, ctor);\n+  unsigned int flags = 0;\n+  if (!is_public)\n+    flags |= Backend::variable_is_hidden;\n+  this->bvar_ = gogo->backend()->immutable_struct(mangled_name, \"\", flags,\n+\t\t\t\t\t\t  btype, loc);\n+  gogo->backend()->immutable_struct_set_init(this->bvar_, mangled_name, flags,\n+\t\t\t\t\t     btype, loc, ctor);\n   return gogo->backend()->var_expression(this->bvar_, loc);\n }\n "}, {"sha": "2872d2ed3ab4f51d1fa534c30529f0f69f7891a3", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=358832c46a378e5a0b8a2fa3c2739125e3e680c7", "patch": "@@ -918,9 +918,8 @@ Gogo::build_type_descriptor_list()\n \n   // Create the variable\n   std::string name = this->type_descriptor_list_symbol(this->pkgpath_symbol());\n-  Bvariable* bv = this->backend()->implicit_variable(name, name, bt,\n-                                                     false, true, false,\n-                                                     0);\n+  unsigned int flags = Backend::variable_is_constant;\n+  Bvariable* bv = this->backend()->implicit_variable(name, name, bt, flags, 0);\n \n   // Build the initializer\n   std::vector<unsigned long> indexes;\n@@ -946,8 +945,7 @@ Gogo::build_type_descriptor_list()\n   Bexpression* binit =\n     this->backend()->constructor_expression(bt, fields, builtin_loc);\n \n-  this->backend()->implicit_variable_set_init(bv, name, bt, false,\n-                                              true, false, binit);\n+  this->backend()->implicit_variable_set_init(bv, name, bt, flags, binit);\n }\n \n // Register the type descriptors with the runtime.  This is to help\n@@ -1002,11 +1000,11 @@ Gogo::register_type_descriptors(std::vector<Bstatement*>& init_stmts,\n \n   // Create a variable holding the list.\n   std::string name = this->typelists_symbol();\n-  Bvariable* bv = this->backend()->implicit_variable(name, name, bat,\n-                                                     true, true, false,\n+  unsigned int flags = (Backend::variable_is_hidden\n+\t\t\t| Backend::variable_is_constant);\n+  Bvariable* bv = this->backend()->implicit_variable(name, name, bat, flags,\n                                                      0);\n-  this->backend()->implicit_variable_set_init(bv, name, bat, true, true,\n-                                              false, barray);\n+  this->backend()->implicit_variable_set_init(bv, name, bat, flags, barray);\n \n   // Build the call in main package's init function.\n   Translate_context context(this, NULL, NULL, NULL);\n@@ -8062,16 +8060,24 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t      if (package != NULL)\n \t\tis_hidden = false;\n \n+\t      unsigned int flags = 0;\n+\t      if (this->is_address_taken_\n+\t\t  || this->is_non_escaping_address_taken_)\n+\t\tflags |= Backend::variable_address_is_taken;\n+\t      if (package != NULL)\n+\t\tflags |= Backend::variable_is_external;\n+\t      if (is_hidden)\n+\t\tflags |= Backend::variable_is_hidden;\n+\t      if (this->in_unique_section_)\n+\t\tflags |= Backend::variable_in_unique_section;\n+\n \t      // For some reason asm_name can't be the empty string\n \t      // for global_variable, so we call asm_name rather than\n \t      // optional_asm_name here.  FIXME.\n \n \t      bvar = backend->global_variable(bname.name(),\n \t\t\t\t\t      bname.asm_name(),\n-\t\t\t\t\t      btype,\n-\t\t\t\t\t      package != NULL,\n-\t\t\t\t\t      is_hidden,\n-\t\t\t\t\t      this->in_unique_section_,\n+\t\t\t\t\t      btype, flags,\n \t\t\t\t\t      this->location_);\n \t    }\n \t  else if (function == NULL)\n@@ -8083,15 +8089,16 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t    {\n \t      const std::string n = Gogo::unpack_hidden_name(name);\n \t      Bfunction* bfunction = function->func_value()->get_decl();\n-\t      bool is_address_taken = (this->is_non_escaping_address_taken_\n-\t\t\t\t       && !this->is_in_heap());\n+\t      unsigned int flags = 0;\n+\t      if (this->is_non_escaping_address_taken_\n+\t\t  && !this->is_in_heap())\n+\t\tflags |= Backend::variable_address_is_taken;\n \t      if (this->is_closure())\n \t\tbvar = backend->static_chain_variable(bfunction, n, btype,\n-\t\t\t\t\t\t      this->location_);\n+\t\t\t\t\t\t      flags, this->location_);\n \t      else if (is_parameter)\n \t\tbvar = backend->parameter_variable(bfunction, n, btype,\n-\t\t\t\t\t\t   is_address_taken,\n-\t\t\t\t\t\t   this->location_);\n+\t\t\t\t\t\t   flags, this->location_);\n \t      else\n                 {\n                   Bvariable* bvar_decl = NULL;\n@@ -8102,8 +8109,7 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n                         ->get_backend_variable(&context);\n                     }\n                   bvar = backend->local_variable(bfunction, n, btype,\n-                                                 bvar_decl,\n-                                                 is_address_taken,\n+                                                 bvar_decl, flags,\n                                                  this->location_);\n                 }\n \t    }\n@@ -8134,10 +8140,12 @@ Result_variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t  Btype* btype = type->get_backend(gogo);\n \t  Bfunction* bfunction = function->func_value()->get_decl();\n \t  std::string n = Gogo::unpack_hidden_name(name);\n-\t  bool is_address_taken = (this->is_non_escaping_address_taken_\n-\t\t\t\t   && !this->is_in_heap());\n+\t  unsigned int flags = 0;\n+\t  if (this->is_non_escaping_address_taken_\n+\t      && !this->is_in_heap())\n+\t    flags |= Backend::variable_address_is_taken;\n \t  this->backend_ = backend->local_variable(bfunction, n, btype,\n-\t\t\t\t\t\t   NULL, is_address_taken,\n+\t\t\t\t\t\t   NULL, flags,\n \t\t\t\t\t\t   this->location_);\n \t}\n     }"}, {"sha": "9643d1b42b3fa3c41b67a8950c6d92fdbf8ec1d0", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=358832c46a378e5a0b8a2fa3c2739125e3e680c7", "patch": "@@ -643,11 +643,13 @@ Temporary_statement::do_get_backend(Translate_context* context)\n     binit = context->backend()->convert_expression(btype, binit,\n                                                    this->location());\n \n+  unsigned int flags = 0;\n+  if (this->is_address_taken_)\n+    flags |= Backend::variable_address_is_taken;\n   Bstatement* statement;\n   this->bvariable_ =\n     context->backend()->temporary_variable(bfunction, context->bblock(),\n-\t\t\t\t\t   btype, binit,\n-\t\t\t\t\t   this->is_address_taken_,\n+\t\t\t\t\t   btype, binit, flags,\n \t\t\t\t\t   this->location(), &statement);\n   return statement;\n }"}, {"sha": "d08cbc96ea110d7554c70c4e6824fea8a656661a", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358832c46a378e5a0b8a2fa3c2739125e3e680c7/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=358832c46a378e5a0b8a2fa3c2739125e3e680c7", "patch": "@@ -1410,10 +1410,12 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   // ensure that type_descriptor_pointer will work if called while\n   // converting INITIALIZER.\n \n+  unsigned int flags = 0;\n+  if (is_common)\n+    flags |= Backend::variable_is_common;\n   this->type_descriptor_var_ =\n     gogo->backend()->immutable_struct(bname.name(), bname.optional_asm_name(),\n-\t\t\t\t      false, is_common, initializer_btype,\n-\t\t\t\t      loc);\n+\t\t\t\t      flags, initializer_btype, loc);\n   if (phash != NULL)\n     *phash = this->type_descriptor_var_;\n \n@@ -1422,7 +1424,7 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   Bexpression* binitializer = initializer->get_backend(&context);\n \n   gogo->backend()->immutable_struct_set_init(this->type_descriptor_var_,\n-\t\t\t\t\t     bname.name(), false, is_common,\n+\t\t\t\t\t     bname.name(), flags,\n \t\t\t\t\t     initializer_btype, loc,\n \t\t\t\t\t     binitializer);\n \n@@ -2714,18 +2716,21 @@ Type::make_gc_symbol_var(Gogo* gogo)\n   // Since we are building the GC symbol in this package, we must create the\n   // variable before converting the initializer to its backend representation\n   // because the initializer may refer to the GC symbol for this type.\n+  unsigned int flags = Backend::variable_is_constant;\n+  if (is_common)\n+    flags |= Backend::variable_is_common;\n+  else\n+    flags |= Backend::variable_is_hidden;\n   this->gc_symbol_var_ =\n-      gogo->backend()->implicit_variable(sym_name, \"\", sym_btype, false, true,\n-\t\t\t\t\t is_common, 0);\n+    gogo->backend()->implicit_variable(sym_name, \"\", sym_btype, flags, 0);\n   if (phash != NULL)\n     *phash = this->gc_symbol_var_;\n \n   Translate_context context(gogo, NULL, NULL, NULL);\n   context.set_is_const();\n   Bexpression* sym_binit = sym_init->get_backend(&context);\n   gogo->backend()->implicit_variable_set_init(this->gc_symbol_var_, sym_name,\n-\t\t\t\t\t      sym_btype, false, true, is_common,\n-\t\t\t\t\t      sym_binit);\n+\t\t\t\t\t      sym_btype, flags, sym_binit);\n }\n \n // Return whether this type needs a GC program, and set *PTRDATA to\n@@ -3013,11 +3018,12 @@ Type::gc_ptrmask_var(Gogo* gogo, int64_t ptrsize, int64_t ptrdata)\n   Bexpression* bval = val->get_backend(&context);\n \n   Btype *btype = val->type()->get_backend(gogo);\n+  unsigned int flags = (Backend::variable_is_constant\n+\t\t\t| Backend::variable_is_common);\n   Bvariable* ret = gogo->backend()->implicit_variable(sym_name, \"\",\n-\t\t\t\t\t\t      btype, false, true,\n-\t\t\t\t\t\t      true, 0);\n-  gogo->backend()->implicit_variable_set_init(ret, sym_name, btype, false,\n-\t\t\t\t\t      true, true, bval);\n+\t\t\t\t\t\t      btype, flags, 0);\n+  gogo->backend()->implicit_variable_set_init(ret, sym_name, btype, flags,\n+\t\t\t\t\t      bval);\n   ins.first->second = ret;\n   return ret;\n }\n@@ -8145,11 +8151,12 @@ Map_type::backend_zero_value(Gogo* gogo)\n   Btype* barray_type = gogo->backend()->array_type(buint8_type, blength);\n \n   std::string zname = Map_type::zero_value->name();\n+  unsigned int flags = Backend::variable_is_common;\n   Bvariable* zvar =\n-      gogo->backend()->implicit_variable(zname, \"\", barray_type, false, false,\n-\t\t\t\t\t true, Map_type::zero_value_align);\n+    gogo->backend()->implicit_variable(zname, \"\", barray_type, flags,\n+\t\t\t\t       Map_type::zero_value_align);\n   gogo->backend()->implicit_variable_set_init(zvar, zname, barray_type,\n-\t\t\t\t\t      false, false, true, NULL);\n+\t\t\t\t\t      flags, NULL);\n   return zvar;\n }\n "}]}