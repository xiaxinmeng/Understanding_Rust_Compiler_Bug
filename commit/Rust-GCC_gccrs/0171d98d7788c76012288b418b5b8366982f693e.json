{"sha": "0171d98d7788c76012288b418b5b8366982f693e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3MWQ5OGQ3Nzg4Yzc2MDEyMjg4YjQxOGI1YjgzNjY5ODJmNjkzZQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-11-23T23:28:42Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-23T23:28:42Z"}, "message": "fix PR68314: revert all patches touching the construction of the original schedule\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r230778", "tree": {"sha": "7a486edc067ee9a894bbf29e958ab2aacdd51b48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a486edc067ee9a894bbf29e958ab2aacdd51b48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0171d98d7788c76012288b418b5b8366982f693e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0171d98d7788c76012288b418b5b8366982f693e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0171d98d7788c76012288b418b5b8366982f693e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0171d98d7788c76012288b418b5b8366982f693e/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c61286797664f445db424050ea4c73cf265b242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c61286797664f445db424050ea4c73cf265b242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c61286797664f445db424050ea4c73cf265b242"}], "stats": {"total": 275, "additions": 73, "deletions": 202}, "files": [{"sha": "13c213b6a7bb0211086565266b4afc30e0bc0b4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0171d98d7788c76012288b418b5b8366982f693e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0171d98d7788c76012288b418b5b8366982f693e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0171d98d7788c76012288b418b5b8366982f693e", "patch": "@@ -1,3 +1,18 @@\n+2015-11-23  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/68314\n+\t* graphite-optimize-isl.c (optimize_isl): Do not call isl_union_map_is_equal.\n+\t* graphite-poly.c (new_scop): Remove original_schedule.\n+\t(free_scop): Same.\n+\t* graphite-poly.h (struct scop): Same.\n+\t* graphite-sese-to-poly.c (build_pbb_minimal_scattering_polyhedrons): Remove.\n+\t(build_pbb_scattering_polyhedrons): Add back.\n+\t(build_scop_minimal_scattering): Remove.\n+\t(build_scop_scattering): Add back.\n+\t(build_scop_original_schedule): Remove.\n+\t(build_poly_scop): Revert to only call build_scop_scattering.\n+\n 2015-11-23  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "559afc481b2d977e0e86e43a332771379035a827", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0171d98d7788c76012288b418b5b8366982f693e/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0171d98d7788c76012288b418b5b8366982f693e/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=0171d98d7788c76012288b418b5b8366982f693e", "patch": "@@ -442,23 +442,11 @@ optimize_isl (scop_p scop)\n #else\n   isl_union_map *schedule_map = get_schedule_map (schedule);\n #endif\n+  apply_schedule_map_to_scop (scop, schedule_map);\n \n-  if (isl_union_map_is_equal (scop->original_schedule, schedule_map))\n-    {\n-      if (dump_file && dump_flags)\n-\tfprintf (dump_file, \"\\nISL schedule same as original schedule\\n\");\n-\n-      isl_schedule_free (schedule);\n-      isl_union_map_free (schedule_map);\n-      return false;\n-    }\n-  else\n-    {\n-      apply_schedule_map_to_scop (scop, schedule_map);\n-      isl_schedule_free (schedule);\n-      isl_union_map_free (schedule_map);\n-      return true;\n-    }\n+  isl_schedule_free (schedule);\n+  isl_union_map_free (schedule_map);\n+  return true;\n }\n \n #endif /* HAVE_isl */"}, {"sha": "c783fc31e02cc87bdc00a7628621e0263e6df6f0", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0171d98d7788c76012288b418b5b8366982f693e/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0171d98d7788c76012288b418b5b8366982f693e/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=0171d98d7788c76012288b418b5b8366982f693e", "patch": "@@ -306,7 +306,6 @@ new_scop (edge entry, edge exit)\n   scop->must_waw_no_source = NULL;\n   scop->may_waw_no_source = NULL;\n   scop_set_region (scop, region);\n-  scop->original_schedule = NULL;\n   scop->pbbs.create (3);\n   scop->drs.create (3);\n \n@@ -343,7 +342,6 @@ free_scop (scop_p scop)\n   isl_union_map_free (scop->may_waw);\n   isl_union_map_free (scop->must_waw_no_source);\n   isl_union_map_free (scop->may_waw_no_source);\n-  isl_union_map_free (scop->original_schedule);\n   XDELETE (scop);\n }\n "}, {"sha": "d396d3f7d64668edd8681a2184524e07557230c8", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0171d98d7788c76012288b418b5b8366982f693e/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0171d98d7788c76012288b418b5b8366982f693e/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=0171d98d7788c76012288b418b5b8366982f693e", "patch": "@@ -417,9 +417,6 @@ struct scop\n   isl_union_map *must_raw, *may_raw, *must_raw_no_source, *may_raw_no_source,\n     *must_war, *may_war, *must_war_no_source, *may_war_no_source,\n     *must_waw, *may_waw, *must_waw_no_source, *may_waw_no_source;\n-\n-  /* Original schedule of the SCoP.  */\n-  isl_union_map *original_schedule;\n };\n \n extern scop_p new_scop (edge, edge);"}, {"sha": "ec7248b4417eb3e28502c4254605a97d52e040aa", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 54, "deletions": 181, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0171d98d7788c76012288b418b5b8366982f693e/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0171d98d7788c76012288b418b5b8366982f693e/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=0171d98d7788c76012288b418b5b8366982f693e", "patch": "@@ -113,181 +113,101 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)\n    | 0   0   1   0   0   0   0   0  -5  = 0  */\n \n static void\n-build_pbb_minimal_scattering_polyhedrons (isl_aff *static_sched, poly_bb_p pbb,\n-\t\t\t\t\t  int *sequence_dims,\n-\t\t\t\t\t  int nb_sequence_dim)\n+build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n+\t\t\t\t  poly_bb_p pbb)\n {\n-  int local_dim = isl_set_dim (pbb->domain, isl_dim_set);\n-\n-  /* Remove a sequence dimension if irrelevant to domain of current pbb.  */\n-  int actual_nb_dim = 0;\n-  for (int i = 0; i < nb_sequence_dim; i++)\n-    if (sequence_dims[i] <= local_dim)\n-      actual_nb_dim++;\n-\n-  /* Build an array that combines sequence dimensions and loops dimensions info.\n-     This is used later to compute the static scattering polyhedrons.  */\n-  bool *sequence_and_loop_dims = NULL;\n-  if (local_dim + actual_nb_dim > 0)\n-    {\n-      sequence_and_loop_dims = XNEWVEC (bool, local_dim + actual_nb_dim);\n+  isl_val *val;\n \n-      int i = 0, j = 0;\n-      for (; i < local_dim; i++)\n-\t{\n-\t  if (sequence_dims && sequence_dims[j] == i)\n-\t    {\n-\t      /* True for sequence dimension.  */\n-\t      sequence_and_loop_dims[i + j] = true;\n-\t      j++;\n-\t    }\n-\t  /* False for loop dimension.  */\n-\t  sequence_and_loop_dims[i + j] = false;\n-\t}\n-      /* Fake loops make things shifted by one.  */\n-      if (sequence_dims && sequence_dims[j] == i)\n-\tsequence_and_loop_dims[i + j] = true;\n-    }\n+  int scattering_dimensions = isl_set_dim (pbb->domain, isl_dim_set) * 2 + 1;\n \n-  int scattering_dimensions = local_dim + actual_nb_dim;\n   isl_space *dc = isl_set_get_space (pbb->domain);\n-  isl_space *dm = isl_space_add_dims (isl_space_from_domain (dc), isl_dim_out,\n-\t\t\t\t      scattering_dimensions);\n+  isl_space *dm = isl_space_add_dims (isl_space_from_domain (dc),\n+\t\t\t\t      isl_dim_out, scattering_dimensions);\n   pbb->schedule = isl_map_universe (dm);\n \n-  int k = 0;\n   for (int i = 0; i < scattering_dimensions; i++)\n     {\n-      if (!sequence_and_loop_dims[i])\n+      /* Textual order inside this loop.  */\n+      if ((i % 2) == 0)\n \t{\n-\t  /* Iterations of this loop - loop dimension.  */\n-\t  pbb->schedule = isl_map_equate (pbb->schedule, isl_dim_in, k,\n-\t\t\t\t\t  isl_dim_out, i);\n-\t  k++;\n-\t  continue;\n+\t  isl_constraint *c = isl_equality_alloc\n+\t      (isl_local_space_from_space (isl_map_get_space (pbb->schedule)));\n+\n+\t  val = isl_aff_get_coefficient_val (static_sched, isl_dim_in, i / 2);\n+\t  gcc_assert (val && isl_val_is_int (val));\n+\n+\t  val = isl_val_neg (val);\n+\t  c = isl_constraint_set_constant_val (c, val);\n+\t  c = isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n+\t  pbb->schedule = isl_map_add_constraint (pbb->schedule, c);\n \t}\n \n-      /* Textual order inside this loop - sequence dimension.  */\n-      isl_space *s = isl_map_get_space (pbb->schedule);\n-      isl_local_space *ls = isl_local_space_from_space (s);\n-      isl_constraint *c = isl_equality_alloc (ls);\n-      isl_val *val = isl_aff_get_coefficient_val (static_sched, isl_dim_in, k);\n-      gcc_assert (val && isl_val_is_int (val));\n-      val = isl_val_neg (val);\n-      c = isl_constraint_set_constant_val (c, val);\n-      c = isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n-      pbb->schedule = isl_map_add_constraint (pbb->schedule, c);\n+      /* Iterations of this loop.  */\n+      else /* if ((i % 2) == 1) */\n+\t{\n+\t  int loop = (i - 1) / 2;\n+\t  pbb->schedule = isl_map_equate (pbb->schedule, isl_dim_in, loop,\n+\t\t\t\t\t  isl_dim_out, i);\n+\t}\n     }\n \n-  XDELETEVEC (sequence_and_loop_dims);\n   pbb->transformed = isl_map_copy (pbb->schedule);\n }\n \n-/* Build the static schedule for BB.  This function minimizes the number of\n-   dimensions used for pbb sequences.\n+/* Build for BB the static schedule.\n+\n+   The static schedule is a Dewey numbering of the abstract syntax\n+   tree: http://en.wikipedia.org/wiki/Dewey_Decimal_Classification\n \n    The following example informally defines the static schedule:\n \n    A\n    for (i: ...)\n      {\n        for (j: ...)\n-\t{\n-\t  B\n-\t  C\n-\t}\n-     }\n-   for (i: ...)\n-     {\n+         {\n+           B\n+           C\n+         }\n+\n        for (k: ...)\n-\t{\n-\t  D\n-\t  E\n-\t}\n+         {\n+           D\n+           E\n+         }\n      }\n    F\n \n    Static schedules for A to F:\n \n-   A (0)\n-   B (1 i0 i1 0)\n-   C (1 i0 i1 1)\n-   D (2 i0 i1 2)\n-   E (2 i0 i1 3)\n-   F (3)\n+     DEPTH\n+     0 1 2\n+   A 0\n+   B 1 0 0\n+   C 1 0 1\n+   D 1 1 0\n+   E 1 1 1\n+   F 2\n */\n \n static void\n-build_scop_minimal_scattering (scop_p scop)\n+build_scop_scattering (scop_p scop)\n {\n   gimple_poly_bb_p previous_gbb = NULL;\n-  int *temp_for_sequence_dims = NULL;\n-  int i;\n-  poly_bb_p pbb;\n-\n-  /* Go through the pbbs to determine the minimum number of dimensions needed to\n-     build the static schedule.  */\n-  int nb_dims = 0;\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      int dim = isl_set_dim (pbb->domain, isl_dim_set);\n-      if (dim > nb_dims)\n-\tnb_dims = dim;\n-    }\n-\n-  /* One extra dimension for the outer fake loop.  */\n-  nb_dims++;\n-  temp_for_sequence_dims = XCNEWVEC (int, nb_dims);\n-\n-  /* Record the number of common loops for each dimension.  */\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n-      int prefix = 0;\n-\n-      if (previous_gbb)\n-\t{\n-\t  prefix = nb_common_loops (scop->scop_info->region, previous_gbb, gbb);\n-\t  temp_for_sequence_dims[prefix] += 1;\n-\t}\n-      previous_gbb = gbb;\n-    }\n-\n-  /* Analyze the info in temp_for_sequence_dim and determine the minimal number\n-     of sequence dimensions.  A dimension that did not appear as common\n-     dimension should not be considered as a sequence dimension.  */\n-  int nb_sequence_params = 0;\n-  for (i = 0; i < nb_dims; i++)\n-    if (temp_for_sequence_dims[i] > 0)\n-      nb_sequence_params++;\n-\n-  int *sequence_dims = NULL;\n-  if (nb_sequence_params > 0)\n-    {\n-      int j = 0;\n-      sequence_dims = XNEWVEC (int, nb_sequence_params);\n-      for (i = 0; i < nb_dims; i++)\n-\tif (temp_for_sequence_dims[i] > 0)\n-\t  {\n-\t    sequence_dims[j] = i;\n-\t    j++;\n-\t  }\n-    }\n-\n-  XDELETEVEC (temp_for_sequence_dims);\n-\n   isl_space *dc = isl_set_get_space (scop->param_context);\n+  isl_aff *static_sched;\n+\n   dc = isl_space_add_dims (dc, isl_dim_set, number_of_loops (cfun));\n-  isl_local_space *local_space = isl_local_space_from_space (dc);\n-  isl_aff *static_sched = isl_aff_zero_on_domain (local_space);\n+  static_sched = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n \n   /* We have to start schedules at 0 on the first component and\n      because we cannot compare_prefix_loops against a previous loop,\n      prefix will be equal to zero, and that index will be\n      incremented before copying.  */\n   static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in, 0, -1);\n \n-  previous_gbb = NULL;\n+  int i;\n+  poly_bb_p pbb;\n   FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n     {\n       gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n@@ -300,58 +220,12 @@ build_scop_minimal_scattering (scop_p scop)\n \n       static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in,\n \t\t\t\t\t\t prefix, 1);\n-      build_pbb_minimal_scattering_polyhedrons (static_sched, pbb,\n-\t\t\t\t\t\tsequence_dims, nb_sequence_params);\n+      build_pbb_scattering_polyhedrons (static_sched, pbb);\n     }\n \n-  XDELETEVEC (sequence_dims);\n   isl_aff_free (static_sched);\n }\n \n-/* Build the original schedule showing the orginal order of execution\n-   of statement instances.\n-\n-   The following example shows the original schedule:\n-\n-   for (i: ...)\n-     {\n-       for (j: ...)\n-         {\n-           A\n-         }\n-       B\n-     }\n-   C\n-   for (i: ...)\n-     {\n-       D\n-     }\n-\n-   Static schedules for A to D expressed in a union map:\n-   {\n-     S_A[i0, i1] -> [0, i0, 0, i1];\n-     S_B[i0]     -> [0, i0, 1];\n-     S_C[]       -> [1];\n-     S_D[i0]     -> [2, i0, 0]\n-   }\n-*/\n-\n-static void\n-build_scop_original_schedule (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  isl_space *space = isl_set_get_space (scop->param_context);\n-  isl_union_map *res = isl_union_map_empty (space);\n-\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    res = isl_union_map_add_map (res, isl_map_copy (pbb->schedule));\n-\n-  scop->original_schedule = res;\n-}\n-\n-\n static isl_pw_aff *extract_affine (scop_p, tree, __isl_take isl_space *space);\n \n /* Extract an affine expression from the chain of recurrence E.  */\n@@ -1244,8 +1118,7 @@ build_poly_scop (scop_p scop)\n     return false;\n \n   build_scop_drs (scop);\n-  build_scop_minimal_scattering (scop);\n-  build_scop_original_schedule (scop);\n+  build_scop_scattering (scop);\n   return true;\n }\n #endif  /* HAVE_isl */"}]}