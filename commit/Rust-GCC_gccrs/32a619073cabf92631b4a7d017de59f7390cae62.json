{"sha": "32a619073cabf92631b4a7d017de59f7390cae62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhNjE5MDczY2FiZjkyNjMxYjRhN2QwMTdkZTU5ZjczOTBjYWU2Mg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-04-27T18:57:51Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-04-27T18:57:51Z"}, "message": "varasm.c (const_str_htab_hash, [...]): Kill.\n\n\t* varasm.c (const_str_htab_hash, const_str_htab_eq, STRHASH,\n\tstruct deferred_string, const_str_htab): Kill.\n\t(n_deferred_strings): New static variable.\n\t(build_constant_desc): Set SYMBOL_REF_DECL of the new\n\tsymbol_ref to point to the constant.\n\t(output_constant_def): When a deferred string is forced out,\n\tjust clear STRING_POOL_ADDRESS_P and decrement n_deferred_strings.\n\t(mark_constant): Likewise.\n\t(maybe_output_constant_def_contents): When deferring a string\n\tconstant, just set STRING_POOL_ADDRESS_P and increment\n\tn_deferred_strings.\n\t(mark_constant_pool): Check n_deferred_strings, not the size\n\tof const_str_htab.\n\t(init_varasm_once): No need to create const_str_htab.\n\n\t* rtl.def, rtl.h, doc/rtl.texi: Document possibility that\n\tSYMBOL_REF_DECL points to a constant.\n\nFrom-SVN: r66133", "tree": {"sha": "74a2cd3ab97d99f3f1a03ae468e26032ae8717fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74a2cd3ab97d99f3f1a03ae468e26032ae8717fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32a619073cabf92631b4a7d017de59f7390cae62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a619073cabf92631b4a7d017de59f7390cae62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32a619073cabf92631b4a7d017de59f7390cae62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a619073cabf92631b4a7d017de59f7390cae62/comments", "author": null, "committer": null, "parents": [{"sha": "2d9d52359cf173f784d1649f0ae2e77b27e87b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d9d52359cf173f784d1649f0ae2e77b27e87b36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d9d52359cf173f784d1649f0ae2e77b27e87b36"}], "stats": {"total": 136, "additions": 42, "deletions": 94}, "files": [{"sha": "f472f6d16d066a12c1ab652b24024ecb39eb3912", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32a619073cabf92631b4a7d017de59f7390cae62", "patch": "@@ -1,3 +1,23 @@\n+2003-04-27  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* varasm.c (const_str_htab_hash, const_str_htab_eq, STRHASH,\n+\tstruct deferred_string, const_str_htab): Kill.\n+\t(n_deferred_strings): New static variable.\n+\t(build_constant_desc): Set SYMBOL_REF_DECL of the new\n+\tsymbol_ref to point to the constant.\n+\t(output_constant_def): When a deferred string is forced out,\n+\tjust clear STRING_POOL_ADDRESS_P and decrement n_deferred_strings.\n+\t(mark_constant): Likewise.\n+\t(maybe_output_constant_def_contents): When deferring a string\n+\tconstant, just set STRING_POOL_ADDRESS_P and increment\n+\tn_deferred_strings.\n+\t(mark_constant_pool): Check n_deferred_strings, not the size\n+\tof const_str_htab.\n+\t(init_varasm_once): No need to create const_str_htab.\n+\n+\t* rtl.def, rtl.h, doc/rtl.texi: Document possibility that\n+\tSYMBOL_REF_DECL points to a constant.\n+\n 2003-04-26  Zack Weinberg  <zack@codesourcery.com>\n \n \t* varasm.c (output_constant_def): Split out two new static"}, {"sha": "e906ccf835837a00298db4b3a3cc7e160b62c5e9", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=32a619073cabf92631b4a7d017de59f7390cae62", "patch": "@@ -438,7 +438,12 @@ declaration, this is the offset into that logical storage.\n If the @code{symbol_ref} @var{x} was created for a @code{VAR_DECL} or\n a @code{FUNCTION_DECL}, that tree is recorded here.  If this value is\n null, then @var{x} was created by back end code generation routines,\n-and so there is no associated front end symbol table entry.\n+and there is no associated front end symbol table entry.\n+\n+@code{SYMBOL_REF_DECL} may also point to a tree of class @code{'c'},\n+that is, some sort of constant.  In this case, the @code{symbol_ref}\n+is an entry in the per-file constant pool; again, there is no associated\n+front end symbol table entry.\n \n @findex SYMBOL_REF_FLAGS\n @item SYMBOL_REF_FLAGS (@var{x})"}, {"sha": "86d8317d925554b5f16b200b5271d6462f7923e8", "filename": "gcc/rtl.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=32a619073cabf92631b4a7d017de59f7390cae62", "patch": "@@ -863,7 +863,8 @@ DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", 'o')\n /* Reference to a named label: \n    Operand 0: label name\n    Operand 1: flags (see SYMBOL_FLAG_* in rtl.h)\n-   Operand 2: tree decl from which this symbol is derived, or null.  */\n+   Operand 2: tree from which this symbol is derived, or null.\n+   This is either a DECL node, or some kind of constant.  */\n DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s00\", 'o')\n \n /* The condition code register is represented, in our imagination,"}, {"sha": "7783258066af1e41d61c474ddf33dd5b56248d2a", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=32a619073cabf92631b4a7d017de59f7390cae62", "patch": "@@ -1252,7 +1252,7 @@ do {\t\t\t\t\t\t\\\n #define SYMBOL_REF_WEAK(RTX)\t\t\t\t\t\t\\\n   (RTL_FLAG_CHECK1(\"SYMBOL_REF_WEAK\", (RTX), SYMBOL_REF)->integrated)\n \n-/* The tree decl associated with the symbol, or null.  */\n+/* The tree (decl or constant) associated with the symbol, or null.  */\n #define SYMBOL_REF_DECL(RTX)\tX0TREE ((RTX), 2)\n \n /* A set of flags on a symbol_ref that are, in some respects, redundant with"}, {"sha": "27c7843d2c34df94bda2fec543f9d04067c56c9d", "filename": "gcc/varasm.c", "status": "modified", "additions": 13, "deletions": 91, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a619073cabf92631b4a7d017de59f7390cae62/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=32a619073cabf92631b4a7d017de59f7390cae62", "patch": "@@ -173,8 +173,6 @@ static void asm_output_aligned_bss\n   PARAMS ((FILE *, tree, const char *, int, int)) ATTRIBUTE_UNUSED;\n #endif\n #endif /* BSS_SECTION_ASM_OP */\n-static hashval_t const_str_htab_hash\tPARAMS ((const void *x));\n-static int const_str_htab_eq\t\tPARAMS ((const void *x, const void *y));\n static bool asm_emit_uninitialised\tPARAMS ((tree, const char*, int, int));\n static void resolve_unique_section\tPARAMS ((tree, int, int));\n static void mark_weak                   PARAMS ((tree));\n@@ -2166,43 +2164,7 @@ static GTY(()) struct constant_descriptor_tree *\n   const_hash_table[MAX_HASH_TABLE];\n \n static struct constant_descriptor_tree * build_constant_desc PARAMS ((tree));\n-\n-/* We maintain a hash table of STRING_CST values.  Unless we are asked to force\n-   out a string constant, we defer output of the constants until we know\n-   they are actually used.  This will be if something takes its address or if\n-   there is a usage of the string in the RTL of a function.  */\n-\n-#define STRHASH(x) htab_hash_pointer (x)\n-\n-struct deferred_string GTY(())\n-{\n-  const char *label;\n-  tree exp;\n-};\n-\n-static GTY ((param_is (struct deferred_string))) htab_t const_str_htab;\n-\n-/* Returns a hash code for X (which is a really a\n-   struct deferred_string *).  */\n-\n-static hashval_t\n-const_str_htab_hash (x)\n-     const void *x;\n-{\n-  return STRHASH (((const struct deferred_string *) x)->label);\n-}\n-\n-/* Returns nonzero if the value represented by X (which is really a\n-   struct deferred_string *) is the same as that given by Y\n-   (which is really a char *).  */\n-\n-static int\n-const_str_htab_eq (x, y)\n-     const void *x;\n-     const void *y;\n-{\n-  return (((const struct deferred_string *) x)->label == (const char *) y);\n-}\n+static unsigned int n_deferred_strings = 0;\n \n /* Compute a hash code for a constant expression.  */\n \n@@ -2562,6 +2524,7 @@ build_constant_desc (exp)\n   /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n   symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n   SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;\n+  SYMBOL_REF_DECL (symbol) = exp;\n \n   rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)), symbol);\n   set_mem_attributes (rtl, exp, 1);\n@@ -2627,20 +2590,10 @@ output_constant_def (exp, defer)\n     }\n   else if (!defer && STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)))\n     {\n-      /* If the string is currently deferred but we need to output it\n-\t now, remove it from the deferred string hash table.  */\n-      struct deferred_string **defstr;\n-\n-      defstr = (struct deferred_string **)\n-\thtab_find_slot_with_hash (const_str_htab, desc->label,\n-\t\t\t\t  STRHASH (desc->label), NO_INSERT);\n-#ifdef ENABLE_CHECKING\n-      if (!defstr)\n-\tabort ();\n-#endif\n-\n+      /* This string is currently deferred but we need to output it\n+\t now; mark it no longer deferred.  */\n       STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)) = 0;\n-      htab_clear_slot (const_str_htab, (void **) defstr);\n+      n_deferred_strings--;\n       maybe_output_constant_def_contents (exp, desc->rtl, 0);\n     }\n \n@@ -2658,36 +2611,18 @@ maybe_output_constant_def_contents (exp, rtl, defer)\n      rtx rtl;\n      int defer;\n {\n-  const char *label;\n-\n   if (flag_syntax_only)\n     return;\n \n-  label = XSTR (XEXP (rtl, 0), 0);\n-\n+  /* Is this a string constant that can be deferred?  */\n   if (defer && TREE_CODE (exp) == STRING_CST && !flag_writable_strings)\n     {\n-      struct deferred_string **defstr;\n-      defstr = (struct deferred_string **)\n-\thtab_find_slot_with_hash (const_str_htab, label,\n-\t\t\t\t  STRHASH (label), INSERT);\n-      if (defstr)\n-\t{\n-\t  struct deferred_string *p;\n-\n-\t  p = (struct deferred_string *)\n-\t    ggc_alloc (sizeof (struct deferred_string));\n-\n-\t  p->exp = exp;\n-\t  p->label = label;\n-\n-\t  *defstr = p;\n-\t  STRING_POOL_ADDRESS_P (XEXP (rtl, 0)) = 1;\n-\t  return;\n-\t}\n+      STRING_POOL_ADDRESS_P (XEXP (rtl, 0)) = 1;\n+      n_deferred_strings++;\n+      return;\n     }\n \n-  output_constant_def_contents (exp, label);\n+  output_constant_def_contents (exp, XSTR (XEXP (rtl, 0), 0));\n }\n \n /* Now output assembler code to define the label for EXP,\n@@ -3415,7 +3350,7 @@ mark_constant_pool ()\n   rtx link;\n   struct pool_constant *pool;\n \n-  if (first_pool == 0 && htab_elements (const_str_htab) == 0)\n+  if (first_pool == 0 && n_deferred_strings == 0)\n     return;\n \n   for (pool = first_pool; pool; pool = pool->next)\n@@ -3531,20 +3466,9 @@ mark_constant (current_rtx, data)\n \t}\n       else if (STRING_POOL_ADDRESS_P (x))\n \t{\n-\t  struct deferred_string *p, **defstr;\n-\n-\t  defstr = (struct deferred_string **)\n-\t    htab_find_slot_with_hash (const_str_htab, XSTR (x, 0),\n-\t\t\t\t      STRHASH (XSTR (x, 0)), NO_INSERT);\n-#ifdef ENABLE_CHECKING\n-\t  if (!defstr)\n-\t    abort ();\n-#endif\n-\n-\t  p = *defstr;\n \t  STRING_POOL_ADDRESS_P (x) = 0;\n-\t  output_constant_def_contents (p->exp, p->label);\n-\t  htab_clear_slot (const_str_htab, (void **) defstr);\n+\t  n_deferred_strings--;\n+\t  output_constant_def_contents (SYMBOL_REF_DECL (x), XSTR (x, 0));\n \t}\n     }\n   return 0;\n@@ -4628,8 +4552,6 @@ make_decl_one_only (decl)\n void\n init_varasm_once ()\n {\n-  const_str_htab = htab_create_ggc (128, const_str_htab_hash,\n-\t\t\t\t    const_str_htab_eq, NULL);\n   in_named_htab = htab_create_ggc (31, in_named_entry_hash,\n \t\t\t\t   in_named_entry_eq, NULL);\n "}]}