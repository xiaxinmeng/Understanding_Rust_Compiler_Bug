{"sha": "35ddff9f08028b857cd335bb176c150f3613d846", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVkZGZmOWYwODAyOGI4NTdjZDMzNWJiMTc2YzE1MGYzNjEzZDg0Ng==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-08-31T05:58:46Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-08-31T05:58:46Z"}, "message": "* java/io/ByteArrayInputStream.java: Merged with Classpath.\n\nFrom-SVN: r45309", "tree": {"sha": "f5b2544e94ad2a22a8c9108a3ffb806f1a4354c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5b2544e94ad2a22a8c9108a3ffb806f1a4354c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35ddff9f08028b857cd335bb176c150f3613d846", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ddff9f08028b857cd335bb176c150f3613d846", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35ddff9f08028b857cd335bb176c150f3613d846", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ddff9f08028b857cd335bb176c150f3613d846/comments", "author": null, "committer": null, "parents": [{"sha": "f5dd47c4d44b04a1b0ca9763829043fced2e14ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5dd47c4d44b04a1b0ca9763829043fced2e14ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5dd47c4d44b04a1b0ca9763829043fced2e14ba"}], "stats": {"total": 177, "additions": 158, "deletions": 19}, "files": [{"sha": "edfb3418d397592f96868e131613419152ec27c8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ddff9f08028b857cd335bb176c150f3613d846/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ddff9f08028b857cd335bb176c150f3613d846/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=35ddff9f08028b857cd335bb176c150f3613d846", "patch": "@@ -1,3 +1,7 @@\n+2001-08-31  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/io/ByteArrayInputStream.java: Merged with Classpath.\n+\n 2001-08-30  Tom Tromey  <tromey@redhat.com>\n \n \t* java/io/BufferedReader.java: Re-merged with Classpath."}, {"sha": "f95e6533a6baee3ca3168782a165e8ca3dc4c66a", "filename": "libjava/java/io/ByteArrayInputStream.java", "status": "modified", "additions": 154, "deletions": 19, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ddff9f08028b857cd335bb176c150f3613d846/libjava%2Fjava%2Fio%2FByteArrayInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ddff9f08028b857cd335bb176c150f3613d846/libjava%2Fjava%2Fio%2FByteArrayInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FByteArrayInputStream.java?ref=35ddff9f08028b857cd335bb176c150f3613d846", "patch": "@@ -1,43 +1,103 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* ByteArrayInputStream.java -- Read an array as a stream\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.io;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 7, 1998.  \n- */ \n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct\n- */\n- \n+  * This class permits an array of bytes to be read as an input stream.\n+  *\n+  * @author Warren Levy <warrenl@cygnus.com>\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */ \n public class ByteArrayInputStream extends InputStream\n {\n-  /* An array of bytes provided by the creator of the stream. */\n+  /**\n+   * The array that contains the data supplied during read operations\n+   */\n   protected byte[] buf;\n \n-  /* Position of the next byte in buf to be read. */\n+  /**\n+   * The array index of the next byte to be read from the buffer\n+   * <code>buf</code>\n+   */\n   protected int pos;\n \n-  /* The currently marked position in the stream. */\n+  /**\n+   * The currently marked position in the stream.  This defaults to 0, so a\n+   * reset operation on the stream resets it to read from array index 0 in\n+   * the buffer - even if the stream was initially created with an offset\n+   * greater than 0\n+   */\n   protected int mark;\n \n-  /* The index in buf one greater than the last valid character. */\n+  /**\n+   * This indicates the maximum number of bytes that can be read from this\n+   * stream.  It is the array index of the position after the last valid\n+   * byte in the buffer <code>buf</code>\n+   */\n   protected int count;\n \n+  /**\n+   * Create a new ByteArrayInputStream that will read bytes from the passed\n+   * in byte array.  This stream will read from the beginning to the end\n+   * of the array.  It is identical to calling an overloaded constructor\n+   * as <code>ByteArrayInputStream(buf, 0, buf.length)</code>.\n+   * <p>\n+   * Note that this array is not copied.  If its contents are changed \n+   * while this stream is being read, those changes will be reflected in the\n+   * bytes supplied to the reader.  Please use caution in changing the \n+   * contents of the buffer while this stream is open.\n+   *\n+   * @param buf The byte array buffer this stream will read from.\n+   */\n   public ByteArrayInputStream(byte[] buffer)\n   {\n     this(buffer, 0, buffer.length);\n   }\n \n+  /**\n+   * Create a new ByteArrayInputStream that will read bytes from the\n+   * passed in byte array.  This stream will read from position\n+   * <code>offset</code> in the array for a length of\n+   * <code>length</code> bytes past <code>offset</code>.  If the\n+   * stream is reset to a position before <code>offset</code> then\n+   * more than <code>length</code> bytes can be read from the stream.\n+   * The <code>length</code> value should be viewed as the array index\n+   * one greater than the last position in the buffer to read.\n+   * <p>\n+   * Note that this array is not copied.  If its contents are changed \n+   * while this stream is being read, those changes will be reflected in the\n+   * bytes supplied to the reader.  Please use caution in changing the \n+   * contents of the buffer while this stream is open.\n+   *\n+   * @param buf The byte array buffer this stream will read from.\n+   * @param offset The index into the buffer to start reading bytes from\n+   * @param length The number of bytes to read from the buffer\n+   */\n   public ByteArrayInputStream(byte[] buffer, int offset, int length)\n   {\n     if (offset < 0  || length < 0 || offset > buffer.length)\n@@ -53,29 +113,85 @@ public ByteArrayInputStream(byte[] buffer, int offset, int length)\n     mark = pos;\n   }\n \n+  /**\n+   * This method returns the number of bytes available to be read from this\n+   * stream.  The value returned will be equal to <code>count - pos</code>.\n+   *\n+   * @return The number of bytes that can be read from this stream\n+   * before blocking, which is all of them \n+   */\n   public synchronized int available()\n   {\n     return count - pos;\n   }\n \n+  /**\n+   * This method sets the mark position in this stream to the current\n+   * position.  Note that the <code>readlimit</code> parameter in this\n+   * method does nothing as this stream is always capable of\n+   * remembering all the bytes int it.\n+   * <p>\n+   * Note that in this class the mark position is set by default to\n+   * position 0 in the stream.  This is in constrast to some other\n+   * stream types where there is no default mark position.\n+   *\n+   * @param readlimit The number of bytes this stream must remember.\n+   * This parameter is ignored.\n+   */\n   public synchronized void mark(int readAheadLimit)\n   {\n     // readAheadLimit is ignored per Java Class Lib. book, p.220.\n     mark = pos;\n   }\n \n+  /**\n+   * This method overrides the <code>markSupported</code> method in\n+   * <code>InputStream</code> in order to return <code>true</code> -\n+   * indicating that this stream class supports mark/reset\n+   * functionality.\n+   *\n+   * @return <code>true</code> to indicate that this class supports\n+   * mark/reset.\n+   */\n   public boolean markSupported()\n   {\n     return true;\n   }\n \n+  /**\n+   * This method reads one byte from the stream.  The <code>pos</code>\n+   * counter is advanced to the next byte to be read.  The byte read is\n+   * returned as an int in the range of 0-255.  If the stream position\n+   * is already at the end of the buffer, no byte is read and a -1 is\n+   * returned in order to indicate the end of the stream.\n+   *\n+   * @return The byte read, or -1 if end of stream\n+   */\n   public synchronized int read()\n   {\n     if (pos < count)\n       return ((int) buf[pos++]) & 0xFF;\n     return -1;\n   }\n \n+  /**\n+   * This method reads bytes from the stream and stores them into a\n+   * caller supplied buffer.  It starts storing the data at index\n+   * <code>offset</code> into the buffer and attempts to read\n+   * <code>len</code> bytes.  This method can return before reading\n+   * the number of bytes requested if the end of the stream is\n+   * encountered first.  The actual number of bytes read is returned.\n+   * If no bytes can be read because the stream is already at the end\n+   * of stream position, a -1 is returned.\n+   * <p>\n+   * This method does not block.\n+   *\n+   * @param buf The array into which the bytes read should be stored.\n+   * @param offset The offset into the array to start storing bytes\n+   * @param len The requested number of bytes to read\n+   *\n+   * @return The actual number of bytes read, or -1 if end of stream.\n+   */\n   public synchronized int read(byte[] b, int off, int len)\n   {\n     if (pos >= count)\n@@ -87,11 +203,30 @@ public synchronized int read(byte[] b, int off, int len)\n     return numBytes;\n   }\n \n+  /**\n+   * This method sets the read position in the stream to the mark\n+   * point by setting the <code>pos</code> variable equal to the\n+   * <code>mark</code> variable.  Since a mark can be set anywhere in\n+   * the array, the mark/reset methods int this class can be used to\n+   * provide random search capabilities for this type of stream.\n+   */\n   public synchronized void reset()\n   {\n     pos = mark;\n   }\n \n+  /**\n+   * This method attempts to skip the requested number of bytes in the\n+   * input stream.  It does this by advancing the <code>pos</code>\n+   * value by the specified number of bytes.  It this would exceed the\n+   * length of the buffer, then only enough bytes are skipped to\n+   * position the stream at the end of the buffer.  The actual number\n+   * of bytes skipped is returned.\n+   *\n+   * @param num_bytes The requested number of bytes to skip\n+   *\n+   * @return The actual number of bytes skipped.\n+   */\n   public synchronized long skip(long n)\n   {\n     // Even though the var numBytes is a long, in reality it can never"}]}