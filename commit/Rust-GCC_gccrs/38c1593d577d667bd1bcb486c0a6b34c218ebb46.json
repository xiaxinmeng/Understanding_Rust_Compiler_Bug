{"sha": "38c1593d577d667bd1bcb486c0a6b34c218ebb46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhjMTU5M2Q1NzdkNjY3YmQxYmNiNDg2YzBhNmIzNGMyMThlYmI0Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-02-28T10:11:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-02-28T10:11:01Z"}, "message": "basic-block.h (BB_REACHABLE): Renumber.\n\n\t* basic-block.h (BB_REACHABLE): Renumber.\n\t(BB_DIRTY, BB_NEW): New flags.\n\t(clear_bb_flags): Declare.\n\t(update_life_info_in_dirty_blocks): Declare.\n\t* cfg.c (clear_bb_flags): New function.\n\t* cfgrtl.c (create_basic_block_structure): Set flags to BB_NEW.\n\t* emit-rtl.c (add_insn_after, add_insn_before, remove_insn,\n\treorder_insns, emit_insn_after): Mark block as dirty.\n\t* flow.c (update_life_info): Fix clearing of PROP_LOG_LINKS.\n\t(update_life_info_in_dirty_blocks): New function.\n\t* recog.c (apply_change_group): Dirtify block.\n\n\t* cse.c (cse_insn): Reorder emitting of jump insn to keep\n\tcfg consistent.\n\t* gcse.c (delete_null_pointer_checks): Likewise.\n\n\t* toplev.c (dump_file_index): Move cse2 after bp,\n\tadd DFI_null\n\t(dump_file_info): Similary.\n\t(rest_of_compilation): Avoid most of CFG rebuilds;\n\tdo first if converision after null pointer checks, do cse2\n\tafter branch prediction; avoid full liveness rebuild after\n\tinitializing subregs.\n\t* invoke.texi (-d options): Document -du, renumber.\n\n\t* cfgcleanup.c (bb_flags): Remove BB_UPDATE_LIFE.\n\t(notice_new_block): Do not set BB_UPDATE_LIFE.\n\t(try_forward_edges, merge_blocks_move_predecessor_nojumps,\n\t merge_blocks_move_successor_nojumps, merge_blocks,\n\t try_crossjump_to_edge): Likewise.\n\t(try_optimize_cfg): Likewise; use update_life_info_in_dirty_blocks.\n\t* cfgrtl.c (merge_blocks_nomove): Copy b's flags to a.\n\t* ifcvt.c (SET_UPDATE_LIFE, UPDATE_LIFE): Kill.\n\t(merge_of_block): Do not use life_data_ok.\n\t(find_if_case_1): Do not use SET_UPDATE_LIFE.\n\t(if_convert): Use BB_DIRTY mechanizm to update life.\n\t* lcm.c (optimize_mode_switching): Update\n\tupdate_life_info_in_dirty_blocks\n\nFrom-SVN: r50127", "tree": {"sha": "8d5067250a1945f16e7442da0ebfa33bcd46322d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d5067250a1945f16e7442da0ebfa33bcd46322d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38c1593d577d667bd1bcb486c0a6b34c218ebb46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c1593d577d667bd1bcb486c0a6b34c218ebb46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c1593d577d667bd1bcb486c0a6b34c218ebb46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c1593d577d667bd1bcb486c0a6b34c218ebb46/comments", "author": null, "committer": null, "parents": [{"sha": "bde131d34d70387ac376419405e9b5c8a788984c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde131d34d70387ac376419405e9b5c8a788984c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde131d34d70387ac376419405e9b5c8a788984c"}], "stats": {"total": 498, "additions": 272, "deletions": 226}, "files": [{"sha": "d757905eb2e97c1efa518f1d6445e8df0f2dcfd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -1,3 +1,44 @@\n+Don Feb 28 11:07:36 CET 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (BB_REACHABLE): Renumber.\n+\t(BB_DIRTY, BB_NEW): New flags.\n+\t(clear_bb_flags): Declare.\n+\t(update_life_info_in_dirty_blocks): Declare.\n+\t* cfg.c (clear_bb_flags): New function.\n+\t* cfgrtl.c (create_basic_block_structure): Set flags to BB_NEW.\n+\t* emit-rtl.c (add_insn_after, add_insn_before, remove_insn,\n+\treorder_insns, emit_insn_after): Mark block as dirty.\n+\t* flow.c (update_life_info): Fix clearing of PROP_LOG_LINKS.\n+\t(update_life_info_in_dirty_blocks): New function.\n+\t* recog.c (apply_change_group): Dirtify block.\n+\n+\t* cse.c (cse_insn): Reorder emitting of jump insn to keep\n+\tcfg consistent.\n+\t* gcse.c (delete_null_pointer_checks): Likewise.\n+\n+\t* toplev.c (dump_file_index): Move cse2 after bp,\n+\tadd DFI_null\n+\t(dump_file_info): Similary.\n+\t(rest_of_compilation): Avoid most of CFG rebuilds;\n+\tdo first if converision after null pointer checks, do cse2\n+\tafter branch prediction; avoid full liveness rebuild after\n+\tinitializing subregs.\n+\t* invoke.texi (-d options): Document -du, renumber.\n+\n+\t* cfgcleanup.c (bb_flags): Remove BB_UPDATE_LIFE.\n+\t(notice_new_block): Do not set BB_UPDATE_LIFE.\n+\t(try_forward_edges, merge_blocks_move_predecessor_nojumps,\n+\t merge_blocks_move_successor_nojumps, merge_blocks,\n+\t try_crossjump_to_edge): Likewise.\n+\t(try_optimize_cfg): Likewise; use update_life_info_in_dirty_blocks.\n+\t* cfgrtl.c (merge_blocks_nomove): Copy b's flags to a.\n+\t* ifcvt.c (SET_UPDATE_LIFE, UPDATE_LIFE): Kill.\n+\t(merge_of_block): Do not use life_data_ok.\n+\t(find_if_case_1): Do not use SET_UPDATE_LIFE.\n+\t(if_convert): Use BB_DIRTY mechanizm to update life.\n+\t* lcm.c (optimize_mode_switching): Update\n+\tupdate_life_info_in_dirty_blocks\n+\n 2002-02-28  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* Makefile.in (integrate.o): Update."}, {"sha": "39e24c82760c525d33c2f9c5ed671eb94c1abda3", "filename": "gcc/basic-block.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -221,7 +221,9 @@ typedef struct basic_block_def {\n #define BB_FREQ_MAX 10000\n \n /* Masks for basic_block.flags.  */\n-#define BB_REACHABLE\t\t1\n+#define BB_DIRTY\t\t1\n+#define BB_NEW\t\t\t2\n+#define BB_REACHABLE\t\t4\n \n /* Number of basic blocks in the current function.  */\n \n@@ -311,6 +313,7 @@ extern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\n extern basic_block create_basic_block_structure PARAMS ((int, rtx, rtx, rtx));\n extern basic_block create_basic_block\tPARAMS ((int, rtx, rtx));\n extern int flow_delete_block\t\tPARAMS ((basic_block));\n+extern void clear_bb_flags\t\tPARAMS ((void));\n extern void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));\n extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n \t\t\t\t\t\t basic_block));\n@@ -587,6 +590,8 @@ enum update_life_extent\n extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n extern void update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n \t\t\t\t\t int));\n+extern void update_life_info_in_dirty_blocks PARAMS ((enum update_life_extent,\n+\t\t\t\t\t\t      int));\n extern int count_or_remove_death_notes\tPARAMS ((sbitmap, int));\n extern int propagate_block\tPARAMS ((basic_block, regset, regset, regset,\n \t\t\t\t\t int));"}, {"sha": "a33beffd0b23352f2898bb15d3a7c8d4424ffd2b", "filename": "gcc/cfg.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -38,6 +38,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t dump_flow_info, debug_flow_info, dump_edge_info\n      - Allocation of AUX fields for basic blocks\n \t alloc_aux_for_blocks, free_aux_for_blocks, alloc_aux_for_block\n+     - clear_bb_flags\n  */\n \f\n #include \"config.h\"\n@@ -440,6 +441,16 @@ redirect_edge_pred (e, new_pred)\n   new_pred->succ = e;\n   e->src = new_pred;\n }\n+\n+void\n+clear_bb_flags ()\n+{\n+  int i;\n+  ENTRY_BLOCK_PTR->flags = 0;\n+  EXIT_BLOCK_PTR->flags = 0;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    BASIC_BLOCK (i)->flags = 0;\n+}\n \f\n void\n dump_flow_info (file)"}, {"sha": "017a4aa539031471ca52b3f4449e5f94ae5bcc9f", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 9, "deletions": 39, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -52,11 +52,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n enum bb_flags\n {\n-    /* Set if life info needs to be recomputed for given BB.  */\n-    BB_UPDATE_LIFE = 1,\n     /* Set if BB is the forwarder block to avoid too many\n        forwarder_block_p calls.  */\n-    BB_FORWARDER_BLOCK = 2\n+    BB_FORWARDER_BLOCK = 1\n };\n \n #define BB_FLAGS(BB) (enum bb_flags) (BB)->aux\n@@ -101,7 +99,6 @@ notice_new_block (bb)\n   if (!bb)\n     return;\n \n-  BB_SET_FLAG (bb, BB_UPDATE_LIFE);\n   if (forwarder_block_p (bb))\n     BB_SET_FLAG (bb, BB_FORWARDER_BLOCK);\n }\n@@ -519,7 +516,6 @@ try_forward_edges (mode, b)\n \n \t  if (!FORWARDER_BLOCK_P (b) && forwarder_block_p (b))\n \t    BB_SET_FLAG (b, BB_FORWARDER_BLOCK);\n-\t  BB_SET_FLAG (b, BB_UPDATE_LIFE);\n \n \t  do\n \t    {\n@@ -663,7 +659,7 @@ merge_blocks_move_predecessor_nojumps (a, b)\n   /* Scramble the insn chain.  */\n   if (a->end != PREV_INSN (b->head))\n     reorder_insns_nobb (a->head, a->end, PREV_INSN (b->head));\n-  BB_SET_FLAG (a, BB_UPDATE_LIFE);\n+  a->flags |= BB_DIRTY;\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Moved block %d before %d and merged.\\n\",\n@@ -731,7 +727,6 @@ merge_blocks_move_successor_nojumps (a, b)\n \n   /* Now blocks A and B are contiguous.  Merge them.  */\n   merge_blocks_nomove (a, b);\n-  BB_SET_FLAG (a, BB_UPDATE_LIFE);\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Moved block %d after %d and merged.\\n\",\n@@ -760,12 +755,6 @@ merge_blocks (e, b, c, mode)\n   if (e->flags & EDGE_FALLTHRU)\n     {\n       int b_index = b->index, c_index = c->index;\n-      /* We need to update liveness in case C already has broken liveness\n-\t or B ends by conditional jump to next instructions that will be\n-\t removed.  */\n-      if ((BB_FLAGS (c) & BB_UPDATE_LIFE)\n-\t  || GET_CODE (b->end) == JUMP_INSN)\n-\tBB_SET_FLAG (b, BB_UPDATE_LIFE);\n       merge_blocks_nomove (b, c);\n       update_forwarder_flag (b);\n \n@@ -831,8 +820,6 @@ merge_blocks (e, b, c, mode)\n \t  bb = force_nonfallthru (b_fallthru_edge);\n \t  if (bb)\n \t    notice_new_block (bb);\n-\t  else\n-\t    BB_SET_FLAG (b_fallthru_edge->src, BB_UPDATE_LIFE);\n \t}\n \n       merge_blocks_move_predecessor_nojumps (b, c);\n@@ -1418,7 +1405,6 @@ try_crossjump_to_edge (mode, e1, e2)\n     remove_edge (src1->succ);\n   make_single_succ_edge (src1, redirect_to, 0);\n \n-  BB_SET_FLAG (src1, BB_UPDATE_LIFE);\n   update_forwarder_flag (src1);\n \n   return true;\n@@ -1532,6 +1518,9 @@ try_optimize_cfg (mode)\n   for (i = 0; i < n_basic_blocks; i++)\n     update_forwarder_flag (BASIC_BLOCK (i));\n \n+  if (mode & CLEANUP_UPDATE_LIFE)\n+    clear_bb_flags ();\n+\n   if (! (* targetm.cannot_modify_jumps_p) ())\n     {\n       /* Attempt to merge blocks as made possible by edge removal.  If\n@@ -1633,10 +1622,7 @@ try_optimize_cfg (mode)\n \n \t      /* Simplify branch over branch.  */\n \t      if ((mode & CLEANUP_EXPENSIVE) && try_simplify_condjump (b))\n-\t\t{\n-\t\t  BB_SET_FLAG (b, BB_UPDATE_LIFE);\n-\t\t  changed_here = true;\n-\t\t}\n+\t\tchanged_here = true;\n \n \t      /* If B has a single outgoing edge, but uses a\n \t\t non-trivial jump instruction without side-effects, we\n@@ -1649,7 +1635,6 @@ try_optimize_cfg (mode)\n \t\t  && onlyjump_p (b->end)\n \t\t  && redirect_edge_and_branch (b->succ, b->succ->dest))\n \t\t{\n-\t\t  BB_SET_FLAG (b, BB_UPDATE_LIFE);\n \t\t  update_forwarder_flag (b);\n \t\t  changed_here = true;\n \t\t}\n@@ -1689,24 +1674,9 @@ try_optimize_cfg (mode)\n     remove_fake_edges ();\n \n   if ((mode & CLEANUP_UPDATE_LIFE) && changed_overall)\n-    {\n-      bool found = 0;\n-\n-      blocks = sbitmap_alloc (n_basic_blocks);\n-      sbitmap_zero (blocks);\n-      for (i = 0; i < n_basic_blocks; i++)\n-\tif (BB_FLAGS (BASIC_BLOCK (i)) & BB_UPDATE_LIFE)\n-\t  {\n-\t    found = 1;\n-\t    SET_BIT (blocks, i);\n-\t  }\n-\n-      if (found)\n-\tupdate_life_info (blocks, UPDATE_LIFE_GLOBAL,\n-\t\t\t  PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n-\t\t\t  | PROP_KILL_DEAD_CODE);\n-      sbitmap_free (blocks);\n-    }\n+    update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL,\n+\t\t\t\t      PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n+\t\t\t\t      | PROP_KILL_DEAD_CODE | PROP_LOG_LINKS);\n \n   for (i = 0; i < n_basic_blocks; i++)\n     BASIC_BLOCK (i)->aux = NULL;"}, {"sha": "1b00a61285cee8d6722ecccb7b7e88ea0fe7b6f3", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -271,6 +271,7 @@ create_basic_block_structure (index, head, end, bb_note)\n   bb->head = head;\n   bb->end = end;\n   bb->index = index;\n+  bb->flags = BB_NEW;\n   BASIC_BLOCK (index) = bb;\n   if (basic_block_for_insn)\n     update_bb_for_insn (bb);\n@@ -592,6 +593,7 @@ merge_blocks_nomove (a, b)\n   for (e = b->succ; e; e = e->succ_next)\n     e->src = a;\n   a->succ = b->succ;\n+  a->flags |= b->flags;\n \n   /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n   b->pred = b->succ = NULL;"}, {"sha": "557e8086d7f762fd6b2ce8975c76656aa1b2a040", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -5800,10 +5800,11 @@ cse_insn (insn, libcall_insn)\n \t     and hope for the best.  */\n \t  if (n_sets == 1)\n \t    {\n-\t      rtx new = emit_jump_insn_before (gen_jump (XEXP (src, 0)), insn);\n+\t      rtx new = emit_jump_insn_after (gen_jump (XEXP (src, 0)), insn);\n \n \t      JUMP_LABEL (new) = XEXP (src, 0);\n \t      LABEL_NUSES (XEXP (src, 0))++;\n+\t      delete_insn (insn);\n \t      insn = new;\n \n \t      /* Now emit a BARRIER after the unconditional jump.  */"}, {"sha": "8dab7a0f3a8004eaaef4b5ef021d2c0f2950b4dd", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -2853,19 +2853,19 @@ Here are the possible letters for use in @var{letters}, and their meanings:\n Annotate the assembler output with miscellaneous debugging information.\n @item b\n @opindex db\n-Dump after computing branch probabilities, to @file{@var{file}.14.bp}.\n+Dump after computing branch probabilities, to @file{@var{file}.15.bp}.\n @item B\n @opindex dB\n-Dump after block reordering, to @file{@var{file}.29.bbro}.\n+Dump after block reordering, to @file{@var{file}.30.bbro}.\n @item c\n @opindex dc\n-Dump after instruction combination, to the file @file{@var{file}.16.combine}.\n+Dump after instruction combination, to the file @file{@var{file}.17.combine}.\n @item C\n @opindex dC\n-Dump after the first if conversion, to the file @file{@var{file}.17.ce}.\n+Dump after the first if conversion, to the file @file{@var{file}.18.ce}.\n @item d\n @opindex dd\n-Dump after delayed branch scheduling, to @file{@var{file}.31.dbr}.\n+Dump after delayed branch scheduling, to @file{@var{file}.32.dbr}.\n @item D\n @opindex dD\n Dump all macro definitions, at the end of preprocessing, in addition to\n@@ -2876,28 +2876,28 @@ Dump after SSA optimizations, to @file{@var{file}.04.ssa} and\n @file{@var{file}.07.ussa}.\n @item E\n @opindex dE\n-Dump after the second if conversion, to @file{@var{file}.26.ce2}.\n+Dump after the second if conversion, to @file{@var{file}.27.ce2}.\n @item f\n @opindex df\n-Dump after life analysis, to @file{@var{file}.15.life}.\n+Dump after life analysis, to @file{@var{file}.16.life}.\n @item F\n @opindex dF\n-Dump after purging @code{ADDRESSOF} codes, to @file{@var{file}.09.addressof}.\n+Dump after purging @code{ADDRESSOF} codes, to @file{@var{file}.10.addressof}.\n @item g\n @opindex dg\n-Dump after global register allocation, to @file{@var{file}.21.greg}.\n+Dump after global register allocation, to @file{@var{file}.22.greg}.\n @item h\n @opindex dh\n Dump after finalization of EH handling code, to @file{@var{file}.02.eh}.\n @item k\n @opindex dk\n-Dump after reg-to-stack conversion, to @file{@var{file}.28.stack}.\n+Dump after reg-to-stack conversion, to @file{@var{file}.29.stack}.\n @item o\n @opindex do\n-Dump after post-reload optimizations, to @file{@var{file}.22.postreload}.\n+Dump after post-reload optimizations, to @file{@var{file}.23.postreload}.\n @item G\n @opindex dG\n-Dump after GCSE, to @file{@var{file}.10.gcse}.\n+Dump after GCSE, to @file{@var{file}.11.gcse}.\n @item i\n @opindex di\n Dump after sibling call optimizations, to @file{@var{file}.01.sibling}.\n@@ -2906,49 +2906,52 @@ Dump after sibling call optimizations, to @file{@var{file}.01.sibling}.\n Dump after the first jump optimization, to @file{@var{file}.03.jump}.\n @item k\n @opindex dk\n-Dump after conversion from registers to stack, to @file{@var{file}.32.stack}.\n+Dump after conversion from registers to stack, to @file{@var{file}.33.stack}.\n @item l\n @opindex dl\n-Dump after local register allocation, to @file{@var{file}.20.lreg}.\n+Dump after local register allocation, to @file{@var{file}.21.lreg}.\n @item L\n @opindex dL\n-Dump after loop optimization, to @file{@var{file}.11.loop}.\n+Dump after loop optimization, to @file{@var{file}.12.loop}.\n @item M\n @opindex dM\n Dump after performing the machine dependent reorganisation pass, to\n-@file{@var{file}.30.mach}.\n+@file{@var{file}.31.mach}.\n @item n\n @opindex dn\n-Dump after register renumbering, to @file{@var{file}.25.rnreg}.\n+Dump after register renumbering, to @file{@var{file}.26.rnreg}.\n @item N\n @opindex dN\n-Dump after the register move pass, to @file{@var{file}.18.regmove}.\n+Dump after the register move pass, to @file{@var{file}.19.regmove}.\n @item r\n @opindex dr\n Dump after RTL generation, to @file{@var{file}.00.rtl}.\n @item R\n @opindex dR\n-Dump after the second scheduling pass, to @file{@var{file}.27.sched2}.\n+Dump after the second scheduling pass, to @file{@var{file}.28.sched2}.\n @item s\n @opindex ds\n Dump after CSE (including the jump optimization that sometimes follows\n-CSE), to @file{@var{file}.08.cse}.\n+CSE), to @file{@var{file}.09.cse}.\n @item S\n @opindex dS\n-Dump after the first scheduling pass, to @file{@var{file}.19.sched}.\n+Dump after the first scheduling pass, to @file{@var{file}.20.sched}.\n @item t\n @opindex dt\n Dump after the second CSE pass (including the jump optimization that\n-sometimes follows CSE), to @file{@var{file}.12.cse2}.\n+sometimes follows CSE), to @file{@var{file}.13.cse2}.\n+@item u\n+@opindex du\n+Dump after null pointer ellimination pass ti @file{@var{file}.08.null}.\n @item w\n @opindex dw\n-Dump after the second flow pass, to @file{@var{file}.23.flow2}.\n+Dump after the second flow pass, to @file{@var{file}.24.flow2}.\n @item X\n @opindex dX\n Dump after SSA dead code elimination, to @file{@var{file}.06.ssadce}.\n @item z\n @opindex dz\n-Dump after the peephole pass, to @file{@var{file}.24.peephole2}.\n+Dump after the peephole pass, to @file{@var{file}.25.peephole2}.\n @item a\n @opindex da\n Produce all the dumps listed above."}, {"sha": "e248af19021e326ef88d7e0b79a3c4905e463b06", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -3276,6 +3276,8 @@ add_insn_after (insn, after)\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n       set_block_for_insn (insn, bb);\n+      if (INSN_P (insn))\n+        bb->flags |= BB_DIRTY;\n       /* Should not happen as first in the BB is always\n \t either NOTE or LABEL.  */\n       if (bb->end == after\n@@ -3343,6 +3345,8 @@ add_insn_before (insn, before)\n       && (bb = BLOCK_FOR_INSN (before)))\n     {\n       set_block_for_insn (insn, bb);\n+      if (INSN_P (insn))\n+        bb->flags |= BB_DIRTY;\n       /* Should not happen as first in the BB is always\n \t either NOTE or LABEl.  */\n       if (bb->head == insn\n@@ -3420,6 +3424,8 @@ remove_insn (insn)\n       && (unsigned int)INSN_UID (insn) < basic_block_for_insn->num_elements\n       && (bb = BLOCK_FOR_INSN (insn)))\n     {\n+      if (INSN_P (insn))\n+        bb->flags |= BB_DIRTY;\n       if (bb->head == insn)\n \t{\n \t  /* Never ever delete the basic block note without deleting whole basic\n@@ -3497,13 +3503,15 @@ reorder_insns (from, to, after)\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n       rtx x;\n+      bb->flags |= BB_DIRTY;\n  \n       if (basic_block_for_insn\n \t  && (unsigned int)INSN_UID (from) < basic_block_for_insn->num_elements\n \t  && (bb2 = BLOCK_FOR_INSN (from)))\n \t{\n \t  if (bb2->end == to)\n \t    bb2->end = prev;\n+\t  bb2->flags |= BB_DIRTY;\n \t}\n \n       if (bb->end == after)\n@@ -4028,6 +4036,7 @@ emit_insns_after (first, after)\n       && (unsigned int)INSN_UID (after) < basic_block_for_insn->num_elements\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n+      bb->flags |= BB_DIRTY;\n       for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n \tset_block_for_insn (last, bb);\n       set_block_for_insn (last, bb);"}, {"sha": "54985d921f588704dd9ba819c66f34b50fd4e572", "filename": "gcc/flow.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -645,10 +645,6 @@ update_life_info (blocks, extent, prop_flags)\n       && (extent == UPDATE_LIFE_LOCAL || blocks))\n     abort ();\n \n-  /* Clear log links in case we are asked to (re)compute them.  */\n-  if (prop_flags & PROP_LOG_LINKS)\n-    clear_log_links (blocks);\n-\n   /* For a global update, we go through the relaxation process again.  */\n   if (extent != UPDATE_LIFE_LOCAL)\n     {\n@@ -685,6 +681,10 @@ update_life_info (blocks, extent, prop_flags)\n \tcount_or_remove_death_notes (blocks, 1);\n     }\n \n+  /* Clear log links in case we are asked to (re)compute them.  */\n+  if (prop_flags & PROP_LOG_LINKS)\n+    clear_log_links (blocks);\n+\n   if (blocks)\n     {\n       EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n@@ -746,6 +746,31 @@ update_life_info (blocks, extent, prop_flags)\n \t       ? TV_LIFE_UPDATE : TV_LIFE);\n }\n \n+/* Update life information in all blocks where BB_DIRTY is set.  */\n+\n+void\n+update_life_info_in_dirty_blocks (extent, prop_flags)\n+     enum update_life_extent extent;\n+     int prop_flags;\n+{\n+  sbitmap update_life_blocks = sbitmap_alloc (n_basic_blocks);\n+  int block_num;\n+  int n = 0;\n+\n+  sbitmap_zero (update_life_blocks);\n+  for (block_num = 0; block_num < n_basic_blocks; block_num++)\n+    if (BASIC_BLOCK (block_num)->flags & BB_DIRTY)\n+      {\n+\tSET_BIT (update_life_blocks, block_num);\n+\tn++;\n+      }\n+\n+  if (n)\n+    update_life_info (update_life_blocks, extent, prop_flags);\n+\n+  sbitmap_free (update_life_blocks);\n+}\n+\n /* Free the variables allocated by find_basic_blocks.\n \n    KEEP_HEAD_END_P is non-zero if basic_block_info is not to be freed.  */"}, {"sha": "52013c1ddd1b285404793bd20fa518a253ae9b80", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -5330,8 +5330,8 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \t{\n \t  rtx new_jump;\n \n-\t  new_jump = emit_jump_insn_before (gen_jump (JUMP_LABEL (last_insn)),\n-\t\t\t\t\t    last_insn);\n+\t  new_jump = emit_jump_insn_after (gen_jump (JUMP_LABEL (last_insn)),\n+\t\t\t\t\t   last_insn);\n \t  JUMP_LABEL (new_jump) = JUMP_LABEL (last_insn);\n \t  LABEL_NUSES (JUMP_LABEL (new_jump))++;\n \t  emit_barrier_after (new_jump);"}, {"sha": "038b8c5d5fffb4239e049752af8434295ae0d5db", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -113,10 +113,8 @@ static void noce_emit_move_insn\t\tPARAMS ((rtx, rtx));\n    as well as a flag indicating that the block should be rescaned for\n    life analysis.  */\n \n-#define SET_ORIG_INDEX(BB,I)\t((BB)->aux = (void *)((size_t)(I) << 1))\n-#define ORIG_INDEX(BB)\t\t((size_t)(BB)->aux >> 1)\n-#define SET_UPDATE_LIFE(BB)\t((BB)->aux = (void *)((size_t)(BB)->aux | 1))\n-#define UPDATE_LIFE(BB)\t\t((size_t)(BB)->aux & 1)\n+#define SET_ORIG_INDEX(BB,I)\t((BB)->aux = (void *)((size_t)(I)))\n+#define ORIG_INDEX(BB)\t\t((size_t)(BB)->aux)\n \n \f\n /* Count the number of non-jump active insns in BB.  */\n@@ -1845,7 +1843,7 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n   /* First merge TEST block into THEN block.  This is a no-brainer since\n      the THEN block did not have a code label to begin with.  */\n \n-  if (life_data_ok)\n+  if (combo_bb->global_live_at_end)\n     COPY_REG_SET (combo_bb->global_live_at_end, then_bb->global_live_at_end);\n   merge_blocks_nomove (combo_bb, then_bb);\n   num_removed_blocks++;\n@@ -1886,7 +1884,7 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n \t   && join_bb != EXIT_BLOCK_PTR)\n     {\n       /* We can merge the JOIN.  */\n-      if (life_data_ok)\n+      if (combo_bb->global_live_at_end)\n \tCOPY_REG_SET (combo_bb->global_live_at_end,\n \t\t      join_bb->global_live_at_end);\n       merge_blocks_nomove (combo_bb, join_bb);\n@@ -1907,9 +1905,6 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n         tidy_fallthru_edge (combo_bb->succ, combo_bb, join_bb);\n     }\n \n-  /* Make sure we update life info properly.  */\n-  SET_UPDATE_LIFE (combo_bb);\n-\n   num_updated_if_blocks++;\n }\n \f\n@@ -2324,7 +2319,6 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   /* Conversion went ok, including moving the insns and fixing up the\n      jump.  Adjust the CFG to match.  */\n \n-  SET_UPDATE_LIFE (test_bb);\n   bitmap_operation (test_bb->global_live_at_end,\n \t\t    else_bb->global_live_at_start,\n \t\t    then_bb->global_live_at_end, BITMAP_IOR);\n@@ -2333,10 +2327,7 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   /* Make rest of code believe that the newly created block is the THEN_BB\n      block we are going to remove.  */\n   if (new_bb)\n-    {\n-      new_bb->aux = then_bb->aux;\n-      SET_UPDATE_LIFE (then_bb);\n-    }\n+    new_bb->aux = then_bb->aux;\n   flow_delete_block (then_bb);\n   /* We've possibly created jump to next insn, cleanup_cfg will solve that\n      later.  */\n@@ -2403,7 +2394,6 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   /* Conversion went ok, including moving the insns and fixing up the\n      jump.  Adjust the CFG to match.  */\n \n-  SET_UPDATE_LIFE (test_bb);\n   bitmap_operation (test_bb->global_live_at_end,\n \t\t    then_bb->global_live_at_start,\n \t\t    else_bb->global_live_at_end, BITMAP_IOR);\n@@ -2718,6 +2708,8 @@ if_convert (x_life_data_ok)\n       post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n       calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n     }\n+  if (life_data_ok)\n+    clear_bb_flags ();\n \n   /* Record initial block numbers.  */\n   for (block_num = 0; block_num < n_basic_blocks; block_num++)\n@@ -2742,28 +2734,15 @@ if_convert (x_life_data_ok)\n   /* Rebuild life info for basic blocks that require it.  */\n   if (num_removed_blocks && life_data_ok)\n     {\n-      sbitmap update_life_blocks = sbitmap_alloc (n_basic_blocks);\n-      sbitmap_zero (update_life_blocks);\n-\n       /* If we allocated new pseudos, we must resize the array for sched1.  */\n       if (max_regno < max_reg_num ())\n \t{\n \t  max_regno = max_reg_num ();\n \t  allocate_reg_info (max_regno, FALSE, FALSE);\n \t}\n-\n-      for (block_num = 0; block_num < n_basic_blocks; block_num++)\n-\tif (UPDATE_LIFE (BASIC_BLOCK (block_num)))\n-\t  SET_BIT (update_life_blocks, block_num);\n-\n-      count_or_remove_death_notes (update_life_blocks, 1);\n-      /* ??? See about adding a mode that verifies that the initial\n-\tset of blocks don't let registers come live.  */\n-      update_life_info (update_life_blocks, UPDATE_LIFE_GLOBAL,\n-\t\t\tPROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n-\t\t\t| PROP_KILL_DEAD_CODE);\n-\n-      sbitmap_free (update_life_blocks);\n+      update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t\t\tPROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n+\t\t\t\t\t| PROP_KILL_DEAD_CODE);\n     }\n   clear_aux_for_blocks ();\n "}, {"sha": "f64c7ada7d42c56b3b4d7377a67512eeccffbd1d", "filename": "gcc/lcm.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -1031,6 +1031,7 @@ optimize_mode_switching (file)\n   int max_num_modes = 0;\n   bool emited = false;\n \n+  clear_bb_flags ();\n #ifdef NORMAL_MODE\n   /* Increment n_basic_blocks before allocating bb_info.  */\n   n_basic_blocks++;\n@@ -1398,16 +1399,11 @@ optimize_mode_switching (file)\n   if (!need_commit && !emited)\n     return 0;\n \n-  /* Ideally we'd figure out what blocks were affected and start from\n-     there, but this is enormously complicated by commit_edge_insertions,\n-     which would screw up any indices we'd collected, and also need to\n-     be involved in the update.  Bail and recompute global life info for\n-     everything.  */\n-\n-  allocate_reg_life_data ();\n-  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t    (PROP_DEATH_NOTES | PROP_KILL_DEAD_CODE\n-\t\t     | PROP_SCAN_DEAD_CODE | PROP_REG_INFO));\n+  max_regno = max_reg_num ();\n+  allocate_reg_info (max_regno, FALSE, FALSE);\n+  update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t\t    (PROP_DEATH_NOTES | PROP_KILL_DEAD_CODE\n+\t\t\t\t     | PROP_SCAN_DEAD_CODE));\n \n   return 1;\n }"}, {"sha": "69f75b79bf6bb774e618bfcfb87f227b68cd6745", "filename": "gcc/recog.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -392,6 +392,17 @@ apply_change_group ()\n \n   if (i == num_changes)\n     {\n+      basic_block bb;\n+\n+      for (i = 0; i < num_changes; i++)\n+\tif (changes[i].object\n+\t    && INSN_P (changes[i].object)\n+\t    && basic_block_for_insn\n+\t    && ((unsigned int)INSN_UID (changes[i].object)\n+\t\t< basic_block_for_insn->num_elements)\n+\t    && (bb = BLOCK_FOR_INSN (changes[i].object)))\n+        bb->flags |= BB_DIRTY;\n+\n       num_changes = 0;\n       return 1;\n     }"}, {"sha": "7cf0c96db9a50d83b51699fa370b865a2feeadb0", "filename": "gcc/toplev.c", "status": "modified", "additions": 107, "deletions": 114, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1593d577d667bd1bcb486c0a6b34c218ebb46/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=38c1593d577d667bd1bcb486c0a6b34c218ebb46", "patch": "@@ -240,13 +240,14 @@ enum dump_file_index\n   DFI_ssa_ccp,\n   DFI_ssa_dce,\n   DFI_ussa,\n+  DFI_null,\n   DFI_cse,\n   DFI_addressof,\n   DFI_gcse,\n   DFI_loop,\n-  DFI_cse2,\n   DFI_cfg,\n   DFI_bp,\n+  DFI_cse2,\n   DFI_life,\n   DFI_combine,\n   DFI_ce,\n@@ -272,7 +273,7 @@ enum dump_file_index\n \n    Remaining -d letters:\n \n-\t\"              o q   u     \"\n+\t\"              o q         \"\n \t\"       H JK   OPQ  TUV  YZ\"\n */\n \n@@ -286,13 +287,14 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"ssaccp\",\t'W', 1, 0, 0 },\n   { \"ssadce\",\t'X', 1, 0, 0 },\n   { \"ussa\",\t'e', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n+  { \"null\",\t'u', 0, 0, 0 },\n   { \"cse\",\t's', 0, 0, 0 },\n   { \"addressof\", 'F', 0, 0, 0 },\n   { \"gcse\",\t'G', 1, 0, 0 },\n   { \"loop\",\t'L', 1, 0, 0 },\n-  { \"cse2\",\t't', 1, 0, 0 },\n   { \"cfg\",\t'f', 1, 0, 0 },\n   { \"bp\",\t'b', 1, 0, 0 },\n+  { \"cse2\",\t't', 1, 0, 0 },\n   { \"life\",\t'f', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n   { \"combine\",\t'c', 1, 0, 0 },\n   { \"ce\",\t'C', 1, 0, 0 },\n@@ -2608,6 +2610,8 @@ rest_of_compilation (decl)\n   reg_scan (insns, max_reg_num (), 0);\n   rebuild_jump_labels (insns);\n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP);\n \n   /* CFG is no longer maintained up-to-date.  */\n@@ -2616,11 +2620,11 @@ rest_of_compilation (decl)\n   purge_line_number_notes (insns);\n \n   timevar_pop (TV_JUMP);\n+  close_dump_file (DFI_jump, print_rtl, insns);\n \n   /* Now is when we stop if -fsyntax-only and -Wreturn-type.  */\n   if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n     {\n-      close_dump_file (DFI_jump, print_rtl, insns);\n       goto exit_rest_of_compilation;\n     }\n \n@@ -2697,23 +2701,22 @@ rest_of_compilation (decl)\n \n   if (optimize > 0)\n     {\n+      open_dump_file (DFI_null, decl);\n       find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+      if (rtl_dump_file)\n+\tdump_flow_info (rtl_dump_file);\n       cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP\n  \t\t   | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n-      /* ??? Run if-conversion before delete_null_pointer_checks,\n-         since the later does not preserve the CFG.  This should\n-\t be changed -- no since converting if's that are going to\n-\t be deleted.  */\n-      timevar_push (TV_IFCVT);\n-      if_convert (0);\n-      timevar_pop (TV_IFCVT);\n-\n-      /* CFG is no longer maintained up-to-date.  */\n-      free_bb_for_insn ();\n       /* Try to identify useless null pointer tests and delete them.  */\n       if (flag_delete_null_pointer_checks)\n \tdelete_null_pointer_checks (insns);\n+\n+      timevar_push (TV_IFCVT);\n+      if_convert (0);\n+      timevar_pop (TV_IFCVT);\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+      close_dump_file (DFI_null, print_rtl_with_bb, insns);\n     }\n \n   /* Jump optimization, and the removal of NULL pointer checks, may\n@@ -2722,9 +2725,11 @@ rest_of_compilation (decl)\n      maximum instruction UID, so if we can reduce the maximum UID\n      we'll save big on memory.  */\n   renumber_insns (rtl_dump_file);\n+  if (optimize)\n+    compute_bb_for_insn (get_max_uid ());\n   timevar_pop (TV_JUMP);\n \n-  close_dump_file (DFI_jump, print_rtl, insns);\n+  close_dump_file (DFI_jump, print_rtl_with_bb, insns);\n \n   ggc_collect ();\n \n@@ -2736,58 +2741,56 @@ rest_of_compilation (decl)\n   if (optimize > 0)\n     {\n       open_dump_file (DFI_cse, decl);\n+      if (rtl_dump_file)\n+\tdump_flow_info (rtl_dump_file);\n       timevar_push (TV_CSE);\n \n       reg_scan (insns, max_reg_num (), 1);\n \n       tem = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+      if (tem)\n+\trebuild_jump_labels (insns);\n+      purge_all_dead_edges (0);\n \n       /* If we are not running more CSE passes, then we are no longer\n \t expecting CSE to be run.  But always rerun it in a cheap mode.  */\n       cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;\n \n       if (tem || optimize > 1)\n-\t{\n-\t  timevar_push (TV_JUMP);\n-\t  rebuild_jump_labels (insns);\n-\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\t  timevar_pop (TV_JUMP);\n-\t  /* CFG is no longer maintained up-to-date.  */\n-\t  free_bb_for_insn ();\n-\t}\n+\tcleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \n       /* Run this after jump optmizations remove all the unreachable code\n \t so that unreachable code will not keep values live.  */\n-      delete_trivially_dead_insns (insns, max_reg_num (), 0);\n+      delete_trivially_dead_insns (insns, max_reg_num (), 1);\n \n       /* Try to identify useless null pointer tests and delete them.  */\n       if (flag_delete_null_pointer_checks || flag_thread_jumps)\n \t{\n \t  timevar_push (TV_JUMP);\n-\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \n \t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP\n \t\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n \t  if (flag_delete_null_pointer_checks)\n \t    delete_null_pointer_checks (insns);\n \t  /* CFG is no longer maintained up-to-date.  */\n-\t  free_bb_for_insn ();\n \t  timevar_pop (TV_JUMP);\n \t}\n \n       /* The second pass of jump optimization is likely to have\n          removed a bunch more instructions.  */\n       renumber_insns (rtl_dump_file);\n+      compute_bb_for_insn (get_max_uid ());\n \n       timevar_pop (TV_CSE);\n-      close_dump_file (DFI_cse, print_rtl, insns);\n+      close_dump_file (DFI_cse, print_rtl_with_bb, insns);\n     }\n \n   open_dump_file (DFI_addressof, decl);\n \n   purge_addressof (insns);\n+  if (optimize)\n+    purge_all_dead_edges (0);\n   reg_scan (insns, max_reg_num (), 1);\n \n   close_dump_file (DFI_addressof, print_rtl, insns);\n@@ -2804,7 +2807,6 @@ rest_of_compilation (decl)\n       timevar_push (TV_GCSE);\n       open_dump_file (DFI_gcse, decl);\n \n-      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n       cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n       tem = gcse_main (insns, rtl_dump_file);\n       rebuild_jump_labels (insns);\n@@ -2813,15 +2815,14 @@ rest_of_compilation (decl)\n       save_cfj = flag_cse_follow_jumps;\n       flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n \n-      /* CFG is no longer maintained up-to-date.  */\n-      free_bb_for_insn ();\n       /* If -fexpensive-optimizations, re-run CSE to clean up things done\n \t by gcse.  */\n       if (flag_expensive_optimizations)\n \t{\n \t  timevar_push (TV_CSE);\n \t  reg_scan (insns, max_reg_num (), 1);\n \t  tem2 = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+\t  purge_all_dead_edges (0);\n \t  timevar_pop (TV_CSE);\n \t  cse_not_expected = !flag_rerun_cse_after_loop;\n \t}\n@@ -2833,28 +2834,29 @@ rest_of_compilation (decl)\n \t  tem = tem2 = 0;\n \t  timevar_push (TV_JUMP);\n \t  rebuild_jump_labels (insns);\n-\t  delete_trivially_dead_insns (insns, max_reg_num (), 0);\n-\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t  delete_trivially_dead_insns (insns, max_reg_num (), 1);\n \t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\t  /* CFG is no longer maintained up-to-date.  */\n-\t  free_bb_for_insn ();\n \t  timevar_pop (TV_JUMP);\n \n \t  if (flag_expensive_optimizations)\n \t    {\n \t      timevar_push (TV_CSE);\n \t      reg_scan (insns, max_reg_num (), 1);\n \t      tem2 = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+\t      purge_all_dead_edges (0);\n \t      timevar_pop (TV_CSE);\n \t    }\n \t}\n \n-      close_dump_file (DFI_gcse, print_rtl, insns);\n+      close_dump_file (DFI_gcse, print_rtl_with_bb, insns);\n       timevar_pop (TV_GCSE);\n \n       ggc_collect ();\n       flag_cse_skip_blocks = save_csb;\n       flag_cse_follow_jumps = save_cfj;\n+#ifdef ENABLE_CHECKING\n+      verify_flow_info ();\n+#endif\n     }\n \n   /* Move constant computations out of loops.  */\n@@ -2863,6 +2865,7 @@ rest_of_compilation (decl)\n     {\n       timevar_push (TV_LOOP);\n       open_dump_file (DFI_loop, decl);\n+      /* CFG is no longer maintained up-to-date.  */\n       free_bb_for_insn ();\n \n       if (flag_rerun_loop_opt)\n@@ -2888,123 +2891,116 @@ rest_of_compilation (decl)\n \t\t     (flag_unroll_loops ? LOOP_UNROLL : 0) | LOOP_BCT\n \t\t     | (flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0));\n \n+      /* Loop can create trivially dead instructions.  */\n+      delete_trivially_dead_insns (insns, max_reg_num (), 0);\n       close_dump_file (DFI_loop, print_rtl, insns);\n       timevar_pop (TV_LOOP);\n \n       ggc_collect ();\n     }\n \n+  /* Do control and data flow analysis; wrote some of the results to\n+     the dump file.  */\n+\n+  timevar_push (TV_FLOW);\n+  open_dump_file (DFI_cfg, decl);\n+\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0)\n+\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+\n+  /* It may make more sense to mark constant functions after dead code is\n+     eliminated by life_analyzis, but we need to do it early, as -fprofile-arcs\n+     may insert code making function non-constant, but we still must consider\n+     it as constant, otherwise -fbranch-probabilities will not read data back.\n+\n+     life_analyzis rarely eliminates modification of external memory.\n+   */\n+  mark_constant_function ();\n+\n+  close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n+\n+  /* Do branch profiling and static profile estimation passes.  */\n+  if (optimize > 0 || profile_arc_flag || flag_test_coverage\n+      || flag_branch_probabilities)\n+    {\n+      struct loops loops;\n+\n+      timevar_push (TV_BRANCH_PROB);\n+      open_dump_file (DFI_bp, decl);\n+      if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+\tbranch_prob ();\n+\n+      /* Discover and record the loop depth at the head of each basic\n+\t block.  The loop infrastructure does the real job for us.  */\n+      flow_loops_find (&loops, LOOP_TREE);\n+\n+      /* Estimate using heuristics if no profiling info is available.  */\n+      if (flag_guess_branch_prob)\n+\testimate_probability (&loops);\n+\n+      if (rtl_dump_file)\n+\tflow_loops_dump (&loops, rtl_dump_file, NULL, 0);\n+\n+      flow_loops_free (&loops);\n+      close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n+      timevar_pop (TV_BRANCH_PROB);\n+    }\n+\n   if (optimize > 0)\n     {\n       timevar_push (TV_CSE2);\n       open_dump_file (DFI_cse2, decl);\n+      if (rtl_dump_file)\n+\tdump_flow_info (rtl_dump_file);\n \n       if (flag_rerun_cse_after_loop)\n \t{\n-\t  /* Running another jump optimization pass before the second\n-\t     cse pass sometimes simplifies the RTL enough to allow\n-\t     the second CSE pass to do a better job.  Jump_optimize can change\n-\t     max_reg_num so we must rerun reg_scan afterwards.\n-\t     ??? Rework to not call reg_scan so often.  */\n \t  timevar_push (TV_JUMP);\n \n-\t  /* The previous call to loop_optimize makes some instructions\n-\t     trivially dead.  We delete those instructions now in the\n-\t     hope that doing so will make the heuristics in jump work\n-\t     better and possibly speed up compilation.  */\n-\t  delete_trivially_dead_insns (insns, max_reg_num (), 0);\n-\n \t  reg_scan (insns, max_reg_num (), 0);\n \n \t  timevar_push (TV_IFCVT);\n-\n-\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \t  cleanup_cfg (CLEANUP_EXPENSIVE);\n \t  if_convert (0);\n-\n \t  timevar_pop(TV_IFCVT);\n \n \t  timevar_pop (TV_JUMP);\n-\n \t  /* CFG is no longer maintained up-to-date.  */\n-\t  free_bb_for_insn ();\n \t  reg_scan (insns, max_reg_num (), 0);\n \t  tem = cse_main (insns, max_reg_num (), 1, rtl_dump_file);\n+\t  purge_all_dead_edges (0);\n \n \t  if (tem)\n \t    {\n \t      timevar_push (TV_JUMP);\n \t      rebuild_jump_labels (insns);\n-\t      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \t      cleanup_cfg (CLEANUP_EXPENSIVE);\n-\t      /* CFG is no longer maintained up-to-date.  */\n-\t      free_bb_for_insn ();\n \t      timevar_pop (TV_JUMP);\n \t    }\n \t}\n \n-      close_dump_file (DFI_cse2, print_rtl, insns);\n+      close_dump_file (DFI_cse2, print_rtl_with_bb, insns);\n       timevar_pop (TV_CSE2);\n \n       ggc_collect ();\n     }\n \n   cse_not_expected = 1;\n \n+  close_dump_file (DFI_life, print_rtl_with_bb, insns);\n   regclass_init ();\n \n-  /* Do control and data flow analysis; wrote some of the results to\n-     the dump file.  */\n-\n-  timevar_push (TV_FLOW);\n-  open_dump_file (DFI_cfg, decl);\n-\n-  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0)\n-\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n   check_function_return_warnings ();\n \n-  /* It may make more sense to mark constant functions after dead code is\n-     eliminated by life_analyzis, but we need to do it early, as -fprofile-arcs\n-     may insert code making function non-constant, but we still must consider\n-     it as constant, otherwise -fbranch-probabilities will not read data back.\n-\n-     life_analyzis rarely eliminates modification of external memory.\n-   */\n-  mark_constant_function ();\n-\n-  close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n-\n-  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    {\n-      timevar_push (TV_BRANCH_PROB);\n-      open_dump_file (DFI_bp, decl);\n-\n-      branch_prob ();\n-\n-      close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n-      timevar_pop (TV_BRANCH_PROB);\n-    }\n-\n-  open_dump_file (DFI_life, decl);\n-  if (optimize)\n-    {\n-      struct loops loops;\n-\n-      /* Discover and record the loop depth at the head of each basic\n-\t block.  The loop infrastructure does the real job for us.  */\n-      flow_loops_find (&loops, LOOP_TREE);\n-\n-      /* Estimate using heuristics if no profiling info is available.  */\n-      if (flag_guess_branch_prob)\n-\testimate_probability (&loops);\n-\n-      if (rtl_dump_file)\n-\tflow_loops_dump (&loops, rtl_dump_file, NULL, 0);\n-\n-      flow_loops_free (&loops);\n-    }\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n   life_analysis (insns, rtl_dump_file, PROP_FINAL);\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n   timevar_pop (TV_FLOW);\n \n   no_new_pseudos = 1;\n@@ -3018,12 +3014,14 @@ rest_of_compilation (decl)\n \n   if (optimize)\n     {\n+      clear_bb_flags ();\n       if (initialize_uninitialized_subregs ())\n \t{\n \t  /* Insns were inserted, so things might look a bit different.  */\n \t  insns = get_insns ();\n-\t  life_analysis (insns, rtl_dump_file, \n-\t\t\t (PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES));\n+\t  update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t\t\t    PROP_LOG_LINKS | PROP_REG_INFO\n+\t\t\t\t\t    | PROP_DEATH_NOTES);\n \t}\n     }\n \n@@ -3089,6 +3087,7 @@ rest_of_compilation (decl)\n \n       regmove_optimize (insns, max_reg_num (), rtl_dump_file);\n \n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n       close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n       timevar_pop (TV_REGMOVE);\n \n@@ -3107,13 +3106,7 @@ rest_of_compilation (decl)\n   timevar_push (TV_MODE_SWITCH);\n \n   no_new_pseudos = 0;\n-  if (optimize_mode_switching (NULL))\n-    {\n-      /* We did work, and so had to regenerate global life information.\n-\t Take advantage of this and don't re-recompute register life\n-\t information below.  */\n-      register_life_up_to_date = 1;\n-    }\n+  optimize_mode_switching (NULL);\n   no_new_pseudos = 1;\n \n   timevar_pop (TV_MODE_SWITCH);"}]}