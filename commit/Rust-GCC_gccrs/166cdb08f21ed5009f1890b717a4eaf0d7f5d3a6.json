{"sha": "166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY2Y2RiMDhmMjFlZDUwMDlmMTg5MGI3MTdhNGVhZjBkN2Y1ZDNhNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-08-09T14:01:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-08-09T14:01:22Z"}, "message": "optabs.c (expand_widen_pattern_expr): Use optabs accestors.\n\n\n\t* optabs.c (expand_widen_pattern_expr): Use optabs accestors.\n\t(expand_ternary_op): Likewise.\n\t(expand_vec_shift_expr): Likewise.\n\t(expand_binop_directly): Likewise.\n\t(expand_binop): Likewise.\n\t(sign_expand_binop): Likewise.\n\t(expand_twoval_unop): Likewise.\n\t(expand_twoval_binop): Likewise.\n\t(expand_twoval_binop_libfunc): Likewise.\n\t(widen_clz): Likewise.\n\t(widen_bswap): Likewise.\n\t(expand_parity): Likewise.\n\t(expand_unop): Likewise.\n\t(expand_abs_nojump): Likewise.\n\t(expand_copysign): Likewise.\n\t(emit_no_conflict_block): Likewise.\n\t(emit_libcall_block): Likewise.\n\t(can_compare_p): Likewise.\n\t(prepare_cmp_insn): Likewise.\n\t(emit_cmp_and_jump_insn_1): Likewise.\n\t(prepare_float_lib_cmp): Likewise.\n\t(emit_conditional_add): Likewise.\n\t(gen_add2_insn): Likewise.\n\t(have_add2_insn): Likewise.\n\t(gen_sub2_insn): Likewise.\n\t(have_sub2_insn): Likewise.\n\t(can_extend_p): Likewise.\n\t(can_fix_p): Likewise.\n\t(can_float_p): Likewise.\n\t(expand_float): Likewise.\n\t(expand_fix): Likewise.\n\t(expand_sfix_optab): Likewise.\n\t(new_optab): Likewise.\n\t(new_convert_optab): Likewise.\n\t(init_libfuncs): Likewise.\n\t(init_interclass_conv_libfuncs): Likewise.\n\t(init_intraclass_conv_libfuncs): Likewise.\n\t(set_conv_libfunc): Likewise.\n\t(init_optabs): Likewise.\n\t(debug_optab_libfuncs): Likewise.\n\t(gen_cond_trap): Likewise.\n\t* optabs.h (optab_handler, convert_optab_hanlder): New.\n\t* genopinit.c: Update optabs generation table.\n\t* reload.c (find_reloads_address_1): Use optabs accestors.\n\t* builtins.c (expand_builtin_mathfn): Likewise.\n\t(expand_builtin_mathfn_2): Likewise.\n\t(expand_builtin_mathfn_3): Likewise.\n\t(expand_builtin_interclass_mathfn): Likewise.\n\t(expand_builtin_sincos): Likewise.\n\t(expand_builtin_cexpi): Likewise.\n\t(expand_builtin_powi): Likewise.\n\t(expand_builtin_strlen): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* expr.c (convert_move): Likewise.\n\t(move_by_pieces): Likewise.\n\t(move_by_pieces_ninsns): Likewise.\n\t(can_store_by_pieces): Likewise.\n\t(store_by_pieces_1): Likewise.\n\t(emit_move_via_integer): Likewise.\n\t(emit_move_complex): Likewise.\n\t(emit_move_ccmode): Likewise.\n\t(emit_move_insn_1): Likewise.\n\t(emit_single_push_insn): Likewise.\n\t(store_constructor): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t(do_store_flag): Likewise.\n\t* ada/misc.c (gnat_compute_largest_alignment): Likewise.\n\t(enumerate_modes): Likewise.\n\t* tree-vectorizer.c (vect_supportable_dr_alignment): Likewise.\n\t(supportable_widening_operation): Likewise.\n\t(supportable_narrowing_operation): Likewise.\n\t* expmed.c (store_bit_field_1): Likewise.\n\t(extract_bit_field_1): Likewise.\n\t(expand_mult_highpart_optab): Likewise.\n\t(expand_smod_pow2): Likewise.\n\t(expand_divmod): Likewise.\n\t(emit_store_flag): Likewise.\n\t* tree-vect-patterns.c\n\t(vect_pattern_recog_1): Likewise.\n\t* tree-ssa-loop-prefetch.c\n\t(nontemporal_store_p): Likewise.\n\t* tree-vect-transform.c (vect_model_reduction_cost): Likewise.\n\t(vect_create_epilog_for_reduction): Likewise.\n\t(vectorizable_reduction): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vect_strided_store_supported): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vect_strided_load_supported): Likewise.\n\t(vectorizable_load): Likewise.\n\t* combine.c (simplify_comparison): Likewise.\n\t* tree-vect-generic.c\n\t(type_for_widest_vector_mode): Likewise.\n\t(expand_vector_operations_1): Likewise.\n\t* config/spu/spu.c (spu_expand_mov): Likewise.\n\t(spu_emit_vector_compare): Likewise.\n\t* config/rs6000/rs6000.c\n\t(rs6000_emit_vector_compare): Likewise.\n\t* stmt.c (add_case_node): Likewise.\n\t* reload1.c (gen_reload):\n\nFrom-SVN: r127317", "tree": {"sha": "ef902503e2e5bb8764f6a2ef4dcaeff07116f6ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef902503e2e5bb8764f6a2ef4dcaeff07116f6ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/comments", "author": null, "committer": null, "parents": [{"sha": "3eb0da77ceb36a1f43b8b12fffaf55707272736b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb0da77ceb36a1f43b8b12fffaf55707272736b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb0da77ceb36a1f43b8b12fffaf55707272736b"}], "stats": {"total": 828, "additions": 470, "deletions": 358}, "files": [{"sha": "d5170d8e9f9af8fc454bd5fd2aeee7f904702a21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -1,3 +1,105 @@\n+2007-08-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* optabs.c (expand_widen_pattern_expr): Use optabs accestors.\n+\t(expand_ternary_op): Likewise.\n+\t(expand_vec_shift_expr): Likewise.\n+\t(expand_binop_directly): Likewise.\n+\t(expand_binop): Likewise.\n+\t(sign_expand_binop): Likewise.\n+\t(expand_twoval_unop): Likewise.\n+\t(expand_twoval_binop): Likewise.\n+\t(expand_twoval_binop_libfunc): Likewise.\n+\t(widen_clz): Likewise.\n+\t(widen_bswap): Likewise.\n+\t(expand_parity): Likewise.\n+\t(expand_unop): Likewise.\n+\t(expand_abs_nojump): Likewise.\n+\t(expand_copysign): Likewise.\n+\t(emit_no_conflict_block): Likewise.\n+\t(emit_libcall_block): Likewise.\n+\t(can_compare_p): Likewise.\n+\t(prepare_cmp_insn): Likewise.\n+\t(emit_cmp_and_jump_insn_1): Likewise.\n+\t(prepare_float_lib_cmp): Likewise.\n+\t(emit_conditional_add): Likewise.\n+\t(gen_add2_insn): Likewise.\n+\t(have_add2_insn): Likewise.\n+\t(gen_sub2_insn): Likewise.\n+\t(have_sub2_insn): Likewise.\n+\t(can_extend_p): Likewise.\n+\t(can_fix_p): Likewise.\n+\t(can_float_p): Likewise.\n+\t(expand_float): Likewise.\n+\t(expand_fix): Likewise.\n+\t(expand_sfix_optab): Likewise.\n+\t(new_optab): Likewise.\n+\t(new_convert_optab): Likewise.\n+\t(init_libfuncs): Likewise.\n+\t(init_interclass_conv_libfuncs): Likewise.\n+\t(init_intraclass_conv_libfuncs): Likewise.\n+\t(set_conv_libfunc): Likewise.\n+\t(init_optabs): Likewise.\n+\t(debug_optab_libfuncs): Likewise.\n+\t(gen_cond_trap): Likewise.\n+\t* optabs.h (optab_handler, convert_optab_hanlder): New.\n+\t* genopinit.c: Update optabs generation table.\n+\t* reload.c (find_reloads_address_1): Use optabs accestors.\n+\t* builtins.c (expand_builtin_mathfn): Likewise.\n+\t(expand_builtin_mathfn_2): Likewise.\n+\t(expand_builtin_mathfn_3): Likewise.\n+\t(expand_builtin_interclass_mathfn): Likewise.\n+\t(expand_builtin_sincos): Likewise.\n+\t(expand_builtin_cexpi): Likewise.\n+\t(expand_builtin_powi): Likewise.\n+\t(expand_builtin_strlen): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* expr.c (convert_move): Likewise.\n+\t(move_by_pieces): Likewise.\n+\t(move_by_pieces_ninsns): Likewise.\n+\t(can_store_by_pieces): Likewise.\n+\t(store_by_pieces_1): Likewise.\n+\t(emit_move_via_integer): Likewise.\n+\t(emit_move_complex): Likewise.\n+\t(emit_move_ccmode): Likewise.\n+\t(emit_move_insn_1): Likewise.\n+\t(emit_single_push_insn): Likewise.\n+\t(store_constructor): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t(do_store_flag): Likewise.\n+\t* ada/misc.c (gnat_compute_largest_alignment): Likewise.\n+\t(enumerate_modes): Likewise.\n+\t* tree-vectorizer.c (vect_supportable_dr_alignment): Likewise.\n+\t(supportable_widening_operation): Likewise.\n+\t(supportable_narrowing_operation): Likewise.\n+\t* expmed.c (store_bit_field_1): Likewise.\n+\t(extract_bit_field_1): Likewise.\n+\t(expand_mult_highpart_optab): Likewise.\n+\t(expand_smod_pow2): Likewise.\n+\t(expand_divmod): Likewise.\n+\t(emit_store_flag): Likewise.\n+\t* tree-vect-patterns.c\n+\t(vect_pattern_recog_1): Likewise.\n+\t* tree-ssa-loop-prefetch.c\n+\t(nontemporal_store_p): Likewise.\n+\t* tree-vect-transform.c (vect_model_reduction_cost): Likewise.\n+\t(vect_create_epilog_for_reduction): Likewise.\n+\t(vectorizable_reduction): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vect_strided_store_supported): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vect_strided_load_supported): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t* combine.c (simplify_comparison): Likewise.\n+\t* tree-vect-generic.c\n+\t(type_for_widest_vector_mode): Likewise.\n+\t(expand_vector_operations_1): Likewise.\n+\t* config/spu/spu.c (spu_expand_mov): Likewise.\n+\t(spu_emit_vector_compare): Likewise.\n+\t* config/rs6000/rs6000.c\n+\t(rs6000_emit_vector_compare): Likewise.\n+\t* stmt.c (add_case_node): Likewise.\n+\t* reload1.c (gen_reload):\n+\n 2007-08-09  Michael Matz  <matz@suse.de>\n \n \t* tree.h (fixed_zerop): Declare as taking a const_tree."}, {"sha": "24d450e96406732309c66c5e32188f8d353bac12", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -480,7 +480,7 @@ gnat_compute_largest_alignment (void)\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+    if (optab_handler (mov_optab, mode)->insn_code != CODE_FOR_nothing)\n       largest_move_alignment = MIN (BIGGEST_ALIGNMENT,\n \t\t\t\t    MAX (largest_move_alignment,\n \t\t\t\t\t GET_MODE_ALIGNMENT (mode)));\n@@ -900,7 +900,7 @@ enumerate_modes (void (*f) (int, int, int, int, int, int, unsigned int))\n \t any wider mode), meaning it is not supported by the hardware.  If\n \t this a complex or vector mode, we care about the inner mode.  */\n       for (j = inner_mode; j != VOIDmode; j = GET_MODE_WIDER_MODE (j))\n-\tif (add_optab->handlers[j].insn_code != CODE_FOR_nothing)\n+\tif (optab_handler (add_optab, j)->insn_code != CODE_FOR_nothing)\n \t  break;\n \n       if (float_p)"}, {"sha": "48350d7fdf46e1c0f2a18112625bf1aaf8f8d8ab", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -1879,7 +1879,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n     errno_set = false;\n \n   /* Before working hard, check whether the instruction is available.  */\n-  if (builtin_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  if (optab_handler (builtin_optab, mode)->insn_code != CODE_FOR_nothing)\n     {\n       target = gen_reg_rtx (mode);\n \n@@ -2030,7 +2030,7 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   mode = TYPE_MODE (TREE_TYPE (exp));\n \n   /* Before working hard, check whether the instruction is available.  */\n-  if (builtin_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (builtin_optab, mode)->insn_code == CODE_FOR_nothing)\n     return NULL_RTX;\n \n   target = gen_reg_rtx (mode);\n@@ -2120,7 +2120,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n \n   /* Check if sincos insn is available, otherwise fallback\n      to sin or cos insn.  */\n-  if (builtin_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (builtin_optab, mode)->insn_code == CODE_FOR_nothing)\n     switch (DECL_FUNCTION_CODE (fndecl))\n       {\n       CASE_FLT_FN (BUILT_IN_SIN):\n@@ -2132,7 +2132,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n       }\n \n   /* Before working hard, check whether the instruction is available.  */\n-  if (builtin_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  if (optab_handler (builtin_optab, mode)->insn_code != CODE_FOR_nothing)\n     {\n       target = gen_reg_rtx (mode);\n \n@@ -2241,7 +2241,7 @@ expand_builtin_interclass_mathfn (tree exp, rtx target, rtx subtarget)\n   mode = TYPE_MODE (TREE_TYPE (arg));\n \n   if (builtin_optab)\n-    icode = builtin_optab->handlers[(int) mode].insn_code;\n+    icode = optab_handler (builtin_optab, mode)->insn_code;\n  \n   /* Before working hard, check whether the instruction is available.  */\n   if (icode != CODE_FOR_nothing)\n@@ -2367,7 +2367,7 @@ expand_builtin_sincos (tree exp)\n   mode = TYPE_MODE (TREE_TYPE (arg));\n \n   /* Check if sincos insn is available, otherwise emit the call.  */\n-  if (sincos_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (sincos_optab, mode)->insn_code == CODE_FOR_nothing)\n     return NULL_RTX;\n \n   target1 = gen_reg_rtx (mode);\n@@ -2413,7 +2413,7 @@ expand_builtin_cexpi (tree exp, rtx target, rtx subtarget)\n   /* Try expanding via a sincos optab, fall back to emitting a libcall\n      to sincos or cexp.  We are sure we have sincos or cexp because cexpi\n      is only generated from sincos, cexp or if we have either of them.  */\n-  if (sincos_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  if (optab_handler (sincos_optab, mode)->insn_code != CODE_FOR_nothing)\n     {\n       op1 = gen_reg_rtx (mode);\n       op2 = gen_reg_rtx (mode);\n@@ -3100,7 +3100,7 @@ expand_builtin_powi (tree exp, rtx target, rtx subtarget)\n   if (GET_MODE (op1) != mode2)\n     op1 = convert_to_mode (mode2, op1, 0);\n \n-  target = emit_library_call_value (powi_optab->handlers[(int) mode].libfunc,\n+  target = emit_library_call_value (optab_handler (powi_optab, mode)->libfunc,\n \t\t\t\t    target, LCT_CONST_MAKE_BLOCK, mode, 2,\n \t\t\t\t    op0, mode, op1, mode2);\n \n@@ -3153,7 +3153,7 @@ expand_builtin_strlen (tree exp, rtx target,\n       /* Bail out if we can't compute strlen in the right mode.  */\n       while (insn_mode != VOIDmode)\n \t{\n-\t  icode = strlen_optab->handlers[(int) insn_mode].insn_code;\n+\t  icode = optab_handler (strlen_optab, insn_mode)->insn_code;\n \t  if (icode != CODE_FOR_nothing)\n \t    break;\n "}, {"sha": "c794e11857f813df22c4c1bf162958e8975e34ac", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -10442,7 +10442,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && ((unsigned HOST_WIDE_INT) const_op\n \t\t  < (((unsigned HOST_WIDE_INT) 1\n \t\t      << (GET_MODE_BITSIZE (mode) - 1))))\n-\t      && cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t      && optab_handler (cmp_optab, mode)->insn_code != CODE_FOR_nothing)\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      continue;\n@@ -10523,7 +10523,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && (unsigned_comparison_p || equality_comparison_p)\n \t      && (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t      && ((unsigned HOST_WIDE_INT) const_op < GET_MODE_MASK (mode))\n-\t      && cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t      && optab_handler (cmp_optab, mode)->insn_code != CODE_FOR_nothing)\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      continue;"}, {"sha": "d26da5272eeec95716a6ea854c348d2a67b64d45", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -12277,7 +12277,7 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n \t    eq_rtx = rs6000_emit_vector_compare (rev_code, op0, op1,\n \t\t\t\t\t\t dest_mode);\n \n-\t    nor_code = one_cmpl_optab->handlers[(int)dest_mode].insn_code;\n+\t    nor_code = optab_handler (one_cmpl_optab, (int)dest_mode)->insn_code;\n \t    gcc_assert (nor_code != CODE_FOR_nothing);\n \t    emit_insn (GEN_FCN (nor_code) (mask, eq_rtx));\n \n@@ -12327,7 +12327,7 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n \t    eq_rtx = rs6000_emit_vector_compare (EQ, op0, op1,\n \t\t\t\t\t\t dest_mode);\n \n-\t    ior_code = ior_optab->handlers[(int)dest_mode].insn_code;\n+\t    ior_code = optab_handler (ior_optab, (int)dest_mode)->insn_code;\n \t    gcc_assert (ior_code != CODE_FOR_nothing);\n \t    emit_insn (GEN_FCN (ior_code) (mask, c_rtx, eq_rtx));\n \t    if (dmode != dest_mode)"}, {"sha": "555beab5318a537516b4babc110a306706099e05", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -3460,7 +3460,7 @@ spu_expand_mov (rtx * ops, enum machine_mode mode)\n \n       if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (imode))\n \t{\n-\t  enum insn_code icode = trunc_optab->handlers[mode][imode].insn_code;\n+\t  enum insn_code icode = convert_optab_handler (trunc_optab, mode, imode)->insn_code;\n \t  emit_insn (GEN_FCN (icode) (ops[0], from));\n \t}\n       else\n@@ -5030,7 +5030,7 @@ spu_emit_vector_compare (enum rtx_code rcode,\n           {\n             enum insn_code nor_code;\n             rtx eq_rtx = spu_emit_vector_compare (EQ, op0, op1, dest_mode);\n-            nor_code = one_cmpl_optab->handlers[(int)dest_mode].insn_code;\n+            nor_code = optab_handler (one_cmpl_optab, (int)dest_mode)->insn_code;\n             gcc_assert (nor_code != CODE_FOR_nothing);\n             emit_insn (GEN_FCN (nor_code) (mask, eq_rtx));\n             if (dmode != dest_mode)\n@@ -5065,7 +5065,7 @@ spu_emit_vector_compare (enum rtx_code rcode,\n             c_rtx = spu_emit_vector_compare (new_code, op0, op1, dest_mode);\n             eq_rtx = spu_emit_vector_compare (EQ, op0, op1, dest_mode);\n \n-            ior_code = ior_optab->handlers[(int)dest_mode].insn_code;\n+            ior_code = optab_handler (ior_optab, (int)dest_mode)->insn_code;\n             gcc_assert (ior_code != CODE_FOR_nothing);\n             emit_insn (GEN_FCN (ior_code) (mask, c_rtx, eq_rtx));\n             if (dmode != dest_mode)"}, {"sha": "b619e0f49ded0859aeb4d7fcae6e4e61e68ecf3c", "filename": "gcc/dojump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -275,7 +275,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n           && (mode = mode_for_size (i + 1, MODE_INT, 0)) != BLKmode\n           && (type = lang_hooks.types.type_for_mode (mode, 1)) != 0\n           && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n-          && (cmp_optab->handlers[(int) TYPE_MODE (type)].insn_code\n+          && (optab_handler (cmp_optab, TYPE_MODE (type))->insn_code\n               != CODE_FOR_nothing))\n         {\n           do_jump (fold_convert (type, exp), if_false_label, if_true_label);\n@@ -334,7 +334,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n         if (! SLOW_BYTE_ACCESS\n             && type != 0 && bitsize >= 0\n             && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n-            && (cmp_optab->handlers[(int) TYPE_MODE (type)].insn_code\n+            && (optab_handler (cmp_optab, TYPE_MODE (type))->insn_code\n \t\t!= CODE_FOR_nothing))\n           {\n             do_jump (fold_convert (type, exp), if_false_label, if_true_label);"}, {"sha": "84a709adaa1a11493fe65516881ab1616bfc00d7", "filename": "gcc/expmed.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -403,15 +403,15 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && !MEM_P (op0)\n-      && (vec_set_optab->handlers[GET_MODE (op0)].insn_code\n+      && (optab_handler (vec_set_optab, GET_MODE (op0))->insn_code\n \t  != CODE_FOR_nothing)\n       && fieldmode == GET_MODE_INNER (GET_MODE (op0))\n       && bitsize == GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n       && !(bitnum % GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n     {\n       enum machine_mode outermode = GET_MODE (op0);\n       enum machine_mode innermode = GET_MODE_INNER (outermode);\n-      int icode = (int) vec_set_optab->handlers[outermode].insn_code;\n+      int icode = (int) optab_handler (vec_set_optab, outermode)->insn_code;\n       int pos = bitnum / GET_MODE_BITSIZE (innermode);\n       rtx rtxpos = GEN_INT (pos);\n       rtx src = value;\n@@ -517,10 +517,10 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (!MEM_P (op0)\n       && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n-      && (movstrict_optab->handlers[fieldmode].insn_code\n+      && (optab_handler (movstrict_optab, fieldmode)->insn_code\n \t  != CODE_FOR_nothing))\n     {\n-      int icode = movstrict_optab->handlers[fieldmode].insn_code;\n+      int icode = optab_handler (movstrict_optab, fieldmode)->insn_code;\n \n       /* Get appropriate low part of the value being stored.  */\n       if (GET_CODE (value) == CONST_INT || REG_P (value))\n@@ -1206,14 +1206,14 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && !MEM_P (op0)\n-      && (vec_extract_optab->handlers[GET_MODE (op0)].insn_code\n+      && (optab_handler (vec_extract_optab, GET_MODE (op0))->insn_code\n \t  != CODE_FOR_nothing)\n       && ((bitnum + bitsize - 1) / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n \t  == bitnum / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n     {\n       enum machine_mode outermode = GET_MODE (op0);\n       enum machine_mode innermode = GET_MODE_INNER (outermode);\n-      int icode = (int) vec_extract_optab->handlers[outermode].insn_code;\n+      int icode = (int) optab_handler (vec_extract_optab, outermode)->insn_code;\n       unsigned HOST_WIDE_INT pos = bitnum / GET_MODE_BITSIZE (innermode);\n       rtx rtxpos = GEN_INT (pos);\n       rtx src = op0;\n@@ -3422,7 +3422,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Try widening multiplication.  */\n   moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n-  if (moptab->handlers[wider_mode].insn_code != CODE_FOR_nothing\n+  if (optab_handler (moptab, wider_mode)->insn_code != CODE_FOR_nothing\n       && mul_widen_cost[wider_mode] < max_cost)\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1, 0,\n@@ -3432,7 +3432,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n     }\n \n   /* Try widening the mode and perform a non-widening multiplication.  */\n-  if (smul_optab->handlers[wider_mode].insn_code != CODE_FOR_nothing\n+  if (optab_handler (smul_optab, wider_mode)->insn_code != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n       && mul_cost[wider_mode] + shift_cost[mode][size-1] < max_cost)\n     {\n@@ -3459,7 +3459,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Try widening multiplication of opposite signedness, and adjust.  */\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n-  if (moptab->handlers[wider_mode].insn_code != CODE_FOR_nothing\n+  if (optab_handler (moptab, wider_mode)->insn_code != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n       && (mul_widen_cost[wider_mode] + 2 * shift_cost[mode][size-1]\n \t  + 4 * add_cost[mode] < max_cost))\n@@ -3580,7 +3580,7 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t     use a LSHIFTRT, 1 ADD, 1 SUB and an AND.  */\n \n \t  temp = gen_rtx_LSHIFTRT (mode, result, shift);\n-\t  if (lshr_optab->handlers[mode].insn_code == CODE_FOR_nothing\n+\t  if (optab_handler (lshr_optab, mode)->insn_code == CODE_FOR_nothing\n \t      || rtx_cost (temp, SET) > COSTS_N_INSNS (2))\n \t    {\n \t      temp = expand_binop (mode, xor_optab, op0, signmask,\n@@ -3879,15 +3879,15 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n   for (compute_mode = mode; compute_mode != VOIDmode;\n        compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n-    if (optab1->handlers[compute_mode].insn_code != CODE_FOR_nothing\n-\t|| optab2->handlers[compute_mode].insn_code != CODE_FOR_nothing)\n+    if (optab_handler (optab1, compute_mode)->insn_code != CODE_FOR_nothing\n+\t|| optab_handler (optab2, compute_mode)->insn_code != CODE_FOR_nothing)\n       break;\n \n   if (compute_mode == VOIDmode)\n     for (compute_mode = mode; compute_mode != VOIDmode;\n \t compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n-      if (optab1->handlers[compute_mode].libfunc\n-\t  || optab2->handlers[compute_mode].libfunc)\n+      if (optab_handler (optab1, compute_mode)->libfunc\n+\t  || optab_handler (optab2, compute_mode)->libfunc)\n \tbreak;\n \n   /* If we still couldn't find a mode, use MODE, but expand_binop will\n@@ -4134,11 +4134,13 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t      : sdiv_pow2_cheap[compute_mode])\n \t\t\t /* We assume that cheap metric is true if the\n \t\t\t    optab has an expander for this mode.  */\n-\t\t\t && (((rem_flag ? smod_optab : sdiv_optab)\n-\t\t\t      ->handlers[compute_mode].insn_code\n+\t\t\t && ((optab_handler ((rem_flag ? smod_optab\n+\t\t\t\t\t      : sdiv_optab),\n+\t\t\t\t\t      compute_mode)->insn_code\n \t\t\t      != CODE_FOR_nothing)\n-\t\t\t     || (sdivmod_optab->handlers[compute_mode]\n-\t\t\t\t .insn_code != CODE_FOR_nothing)))\n+\t\t\t     || (optab_handler(sdivmod_optab,\n+\t\t\t\t\t       compute_mode)\n+\t\t\t\t ->insn_code != CODE_FOR_nothing)))\n \t\t  ;\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d))\n \t\t  {\n@@ -4150,9 +4152,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t      }\n \n \t\t    if (sdiv_pow2_cheap[compute_mode]\n-\t\t\t&& ((sdiv_optab->handlers[compute_mode].insn_code\n+\t\t\t&& ((optab_handler (sdiv_optab, compute_mode)->insn_code\n \t\t\t     != CODE_FOR_nothing)\n-\t\t\t    || (sdivmod_optab->handlers[compute_mode].insn_code\n+\t\t\t    || (optab_handler (sdivmod_optab, compute_mode)->insn_code\n \t\t\t\t!= CODE_FOR_nothing)))\n \t\t      quotient = expand_divmod (0, TRUNC_DIV_EXPR,\n \t\t\t\t\t\tcompute_mode, op0,\n@@ -4800,7 +4802,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    = sign_expand_binop (compute_mode, umod_optab, smod_optab,\n \t\t\t\t op0, op1, target,\n \t\t\t\t unsignedp,\n-\t\t\t\t ((optab2->handlers[compute_mode].insn_code\n+\t\t\t\t ((optab_handler (optab2, compute_mode)->insn_code\n \t\t\t\t   != CODE_FOR_nothing)\n \t\t\t\t  ? OPTAB_DIRECT : OPTAB_WIDEN));\n \t  if (remainder == 0)\n@@ -4828,7 +4830,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t= sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n \t\t\t     op0, op1, rem_flag ? NULL_RTX : target,\n \t\t\t     unsignedp,\n-\t\t\t     ((optab2->handlers[compute_mode].insn_code\n+\t\t\t     ((optab_handler (optab2, compute_mode)->insn_code\n \t\t\t       != CODE_FOR_nothing)\n \t\t\t      ? OPTAB_DIRECT : OPTAB_WIDEN));\n \n@@ -5348,7 +5350,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       for (compare_mode = mode; compare_mode != VOIDmode;\n \t   compare_mode = GET_MODE_WIDER_MODE (compare_mode))\n \t{\n-\t  icode = cstore_optab->handlers[(int) compare_mode].insn_code;\n+\t  icode = optab_handler (cstore_optab, compare_mode)->insn_code;\n \t  if (icode != CODE_FOR_nothing)\n \t    break;\n \t}\n@@ -5512,9 +5514,9 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t that is compensated by the subsequent overflow when subtracting\n \t one / negating.  */\n \n-      if (abs_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+      if (optab_handler (abs_optab, mode)->insn_code != CODE_FOR_nothing)\n \ttem = expand_unop (mode, abs_optab, op0, subtarget, 1);\n-      else if (ffs_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+      else if (optab_handler (ffs_optab, mode)->insn_code != CODE_FOR_nothing)\n \ttem = expand_unop (mode, ffs_optab, op0, subtarget, 1);\n       else if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{"}, {"sha": "a002b0d30ecf5b6ebc89d64f6a6a86b8706baef8", "filename": "gcc/expr.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -426,7 +426,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \n       /* Try converting directly if the insn is supported.  */\n \n-      code = tab->handlers[to_mode][from_mode].insn_code;\n+      code = convert_optab_handler (tab, to_mode, from_mode)->insn_code;\n       if (code != CODE_FOR_nothing)\n \t{\n \t  emit_unop_insn (code, to, from,\n@@ -435,7 +435,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t}\n \n       /* Otherwise use a libcall.  */\n-      libcall = tab->handlers[to_mode][from_mode].libfunc;\n+      libcall = convert_optab_handler (tab, to_mode, from_mode)->libfunc;\n \n       /* Is this conversion implemented yet?  */\n       gcc_assert (libcall);\n@@ -460,12 +460,12 @@ convert_move (rtx to, rtx from, int unsignedp)\n       enum machine_mode full_mode\n \t= smallest_mode_for_size (GET_MODE_BITSIZE (to_mode), MODE_INT);\n \n-      gcc_assert (trunc_optab->handlers[to_mode][full_mode].insn_code\n+      gcc_assert (convert_optab_handler (trunc_optab, to_mode, full_mode)->insn_code\n \t\t  != CODE_FOR_nothing);\n \n       if (full_mode != from_mode)\n \tfrom = convert_to_mode (full_mode, from, unsignedp);\n-      emit_unop_insn (trunc_optab->handlers[to_mode][full_mode].insn_code,\n+      emit_unop_insn (convert_optab_handler (trunc_optab, to_mode, full_mode)->insn_code,\n \t\t      to, from, UNKNOWN);\n       return;\n     }\n@@ -475,18 +475,18 @@ convert_move (rtx to, rtx from, int unsignedp)\n       enum machine_mode full_mode\n \t= smallest_mode_for_size (GET_MODE_BITSIZE (from_mode), MODE_INT);\n \n-      gcc_assert (sext_optab->handlers[full_mode][from_mode].insn_code\n+      gcc_assert (convert_optab_handler (sext_optab, full_mode, from_mode)->insn_code\n \t\t  != CODE_FOR_nothing);\n \n       if (to_mode == full_mode)\n \t{\n-\t  emit_unop_insn (sext_optab->handlers[full_mode][from_mode].insn_code,\n+\t  emit_unop_insn (convert_optab_handler (sext_optab, full_mode, from_mode)->insn_code,\n \t\t\t  to, from, UNKNOWN);\n \t  return;\n \t}\n \n       new_from = gen_reg_rtx (full_mode);\n-      emit_unop_insn (sext_optab->handlers[full_mode][from_mode].insn_code,\n+      emit_unop_insn (convert_optab_handler (sext_optab, full_mode, from_mode)->insn_code,\n \t\t      new_from, from, UNKNOWN);\n \n       /* else proceed to integer conversions below.  */\n@@ -690,9 +690,9 @@ convert_move (rtx to, rtx from, int unsignedp)\n     }\n \n   /* Support special truncate insns for certain modes.  */\n-  if (trunc_optab->handlers[to_mode][from_mode].insn_code != CODE_FOR_nothing)\n+  if (convert_optab_handler (trunc_optab, to_mode, from_mode)->insn_code != CODE_FOR_nothing)\n     {\n-      emit_unop_insn (trunc_optab->handlers[to_mode][from_mode].insn_code,\n+      emit_unop_insn (convert_optab_handler (trunc_optab, to_mode, from_mode)->insn_code,\n \t\t      to, from, UNKNOWN);\n       return;\n     }\n@@ -984,7 +984,7 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n       if (mode == VOIDmode)\n \tbreak;\n \n-      icode = mov_optab->handlers[(int) mode].insn_code;\n+      icode = optab_handler (mov_optab, mode)->insn_code;\n       if (icode != CODE_FOR_nothing && align >= GET_MODE_ALIGNMENT (mode))\n \tmove_by_pieces_1 (GEN_FCN (icode), mode, &data);\n \n@@ -1064,7 +1064,7 @@ move_by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align,\n       if (mode == VOIDmode)\n \tbreak;\n \n-      icode = mov_optab->handlers[(int) mode].insn_code;\n+      icode = optab_handler (mov_optab, mode)->insn_code;\n       if (icode != CODE_FOR_nothing && align >= GET_MODE_ALIGNMENT (mode))\n \tn_insns += l / GET_MODE_SIZE (mode), l %= GET_MODE_SIZE (mode);\n \n@@ -2250,7 +2250,7 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n \t  if (mode == VOIDmode)\n \t    break;\n \n-\t  icode = mov_optab->handlers[(int) mode].insn_code;\n+\t  icode = optab_handler (mov_optab, mode)->insn_code;\n \t  if (icode != CODE_FOR_nothing\n \t      && align >= GET_MODE_ALIGNMENT (mode))\n \t    {\n@@ -2454,7 +2454,7 @@ store_by_pieces_1 (struct store_by_pieces *data ATTRIBUTE_UNUSED,\n       if (mode == VOIDmode)\n \tbreak;\n \n-      icode = mov_optab->handlers[(int) mode].insn_code;\n+      icode = optab_handler (mov_optab, mode)->insn_code;\n       if (icode != CODE_FOR_nothing && align >= GET_MODE_ALIGNMENT (mode))\n \tstore_by_pieces_2 (GEN_FCN (icode), mode, data);\n \n@@ -2921,7 +2921,7 @@ emit_move_via_integer (enum machine_mode mode, rtx x, rtx y, bool force)\n     return NULL_RTX;\n \n   /* The target must support moves in this mode.  */\n-  code = mov_optab->handlers[imode].insn_code;\n+  code = optab_handler (mov_optab, imode)->insn_code;\n   if (code == CODE_FOR_nothing)\n     return NULL_RTX;\n \n@@ -3071,7 +3071,7 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n \n   /* Move floating point as parts.  */\n   if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-      && mov_optab->handlers[GET_MODE_INNER (mode)].insn_code != CODE_FOR_nothing)\n+      && optab_handler (mov_optab, GET_MODE_INNER (mode))->insn_code != CODE_FOR_nothing)\n     try_int = false;\n   /* Not possible if the values are inherently not adjacent.  */\n   else if (GET_CODE (x) == CONCAT || GET_CODE (y) == CONCAT)\n@@ -3122,7 +3122,7 @@ emit_move_ccmode (enum machine_mode mode, rtx x, rtx y)\n   /* Assume all MODE_CC modes are equivalent; if we have movcc, use it.  */\n   if (mode != CCmode)\n     {\n-      enum insn_code code = mov_optab->handlers[CCmode].insn_code;\n+      enum insn_code code = optab_handler (mov_optab, CCmode)->insn_code;\n       if (code != CODE_FOR_nothing)\n \t{\n \t  x = emit_move_change_mode (CCmode, mode, x, true);\n@@ -3262,7 +3262,7 @@ emit_move_insn_1 (rtx x, rtx y)\n \n   gcc_assert ((unsigned int) mode < (unsigned int) MAX_MACHINE_MODE);\n \n-  code = mov_optab->handlers[mode].insn_code;\n+  code = optab_handler (mov_optab, mode)->insn_code;\n   if (code != CODE_FOR_nothing)\n     return emit_insn (GEN_FCN (code) (x, y));\n \n@@ -3514,7 +3514,7 @@ emit_single_push_insn (enum machine_mode mode, rtx x, tree type)\n   stack_pointer_delta += PUSH_ROUNDING (GET_MODE_SIZE (mode));\n   /* If there is push pattern, use it.  Otherwise try old way of throwing\n      MEM representing push operation to move expander.  */\n-  icode = push_optab->handlers[(int) mode].insn_code;\n+  icode = optab_handler (push_optab, mode)->insn_code;\n   if (icode != CODE_FOR_nothing)\n     {\n       if (((pred = insn_data[(int) icode].operand[0].predicate)\n@@ -4319,7 +4319,7 @@ static bool\n emit_storent_insn (rtx to, rtx from)\n {\n   enum machine_mode mode = GET_MODE (to), imode;\n-  enum insn_code code = storent_optab->handlers[mode].insn_code;\n+  enum insn_code code = optab_handler (storent_optab, mode)->insn_code;\n   rtx pattern;\n \n   if (code == CODE_FOR_nothing)\n@@ -5458,7 +5458,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  {\n \t    enum machine_mode mode = GET_MODE (target);\n \n-\t    icode = (int) vec_init_optab->handlers[mode].insn_code;\n+\t    icode = (int) optab_handler (vec_init_optab, mode)->insn_code;\n \t    if (icode != CODE_FOR_nothing)\n \t      {\n \t\tunsigned int i;\n@@ -7394,7 +7394,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t|| modifier == EXPAND_STACK_PARM);\n \n \t    /* The vectorizer should have already checked the mode.  */\n-\t    icode = movmisalign_optab->handlers[mode].insn_code;\n+\t    icode = optab_handler (movmisalign_optab, mode)->insn_code;\n \t    gcc_assert (icode != CODE_FOR_nothing);\n \n \t    /* We've already validated the memory, and we're creating a\n@@ -8107,7 +8107,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      bool zextend_p = TYPE_UNSIGNED (op0type);\n \t      this_optab = zextend_p ? umadd_widen_optab : smadd_widen_optab;\n \t      if (mode == GET_MODE_2XWIDER_MODE (innermode)\n-\t\t  && (this_optab->handlers[(int) mode].insn_code\n+\t\t  && (optab_handler (this_optab, mode)->insn_code\n \t\t      != CODE_FOR_nothing))\n \t\t{\n \t\t  expand_operands (TREE_OPERAND (subsubexp0, 0),\n@@ -8262,7 +8262,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      bool zextend_p = TYPE_UNSIGNED (op0type);\n \t      this_optab = zextend_p ? umsub_widen_optab : smsub_widen_optab;\n \t      if (mode == GET_MODE_2XWIDER_MODE (innermode)\n-\t\t  && (this_optab->handlers[(int) mode].insn_code\n+\t\t  && (optab_handler (this_optab, mode)->insn_code\n \t\t      != CODE_FOR_nothing))\n \t\t{\n \t\t  expand_operands (TREE_OPERAND (subsubexp0, 0),\n@@ -8377,7 +8377,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  this_optab = usmul_widen_optab;\n \t  if (mode == GET_MODE_WIDER_MODE (innermode))\n \t    {\n-\t      if (this_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t      if (optab_handler (this_optab, mode)->insn_code != CODE_FOR_nothing)\n \t\t{\n \t\t  if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subexp0, 0))))\n \t\t    expand_operands (TREE_OPERAND (subexp0, 0),\n@@ -8427,7 +8427,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t  if (mode == GET_MODE_2XWIDER_MODE (innermode))\n \t    {\n-\t      if (this_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t      if (optab_handler (this_optab, mode)->insn_code != CODE_FOR_nothing)\n \t\t{\n \t\t  if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n \t\t    expand_operands (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n@@ -8439,7 +8439,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t     NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \t\t  goto binop3;\n \t\t}\n-\t      else if (other_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n+\t      else if (optab_handler (other_optab, mode)->insn_code != CODE_FOR_nothing\n \t\t       && innermode == word_mode)\n \t\t{\n \t\t  rtx htem, hipart;\n@@ -9552,7 +9552,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n       for (wmode = operand_mode;\n \t   icode == CODE_FOR_nothing && wmode != VOIDmode;\n \t   wmode = GET_MODE_WIDER_MODE (wmode))\n-\ticode = cstore_optab->handlers[(int) wmode].insn_code;\n+\ticode = optab_handler (cstore_optab, wmode)->insn_code;\n     }\n \n   if (icode == CODE_FOR_nothing\n@@ -9565,9 +9565,9 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n \t;\n       else if (! only_cheap && (code == NE || code == EQ)\n \t       && TREE_CODE (type) != REAL_TYPE\n-\t       && ((abs_optab->handlers[(int) operand_mode].insn_code\n+\t       && ((optab_handler (abs_optab, operand_mode)->insn_code\n \t\t    != CODE_FOR_nothing)\n-\t\t   || (ffs_optab->handlers[(int) operand_mode].insn_code\n+\t\t   || (optab_handler (ffs_optab, operand_mode)->insn_code\n \t\t       != CODE_FOR_nothing)))\n \t;\n       else"}, {"sha": "44c48c7a663cccfe592ab6f11de30c9666cb7896", "filename": "gcc/genopinit.c", "status": "modified", "additions": 153, "deletions": 153, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -58,123 +58,123 @@ along with GCC; see the file COPYING3.  If not see\n    upper-case forms of the comparison, respectively.  */\n \n static const char * const optabs[] =\n-{ \"sext_optab->handlers[$B][$A].insn_code = CODE_FOR_$(extend$a$b2$)\",\n-  \"zext_optab->handlers[$B][$A].insn_code = CODE_FOR_$(zero_extend$a$b2$)\",\n-  \"sfix_optab->handlers[$B][$A].insn_code = CODE_FOR_$(fix$F$a$I$b2$)\",\n-  \"ufix_optab->handlers[$B][$A].insn_code = CODE_FOR_$(fixuns$F$a$b2$)\",\n-  \"sfixtrunc_optab->handlers[$B][$A].insn_code = CODE_FOR_$(fix_trunc$F$a$I$b2$)\",\n-  \"ufixtrunc_optab->handlers[$B][$A].insn_code = CODE_FOR_$(fixuns_trunc$F$a$I$b2$)\",\n-  \"sfloat_optab->handlers[$B][$A].insn_code = CODE_FOR_$(float$I$a$F$b2$)\",\n-  \"ufloat_optab->handlers[$B][$A].insn_code = CODE_FOR_$(floatuns$I$a$F$b2$)\",\n-  \"trunc_optab->handlers[$B][$A].insn_code = CODE_FOR_$(trunc$a$b2$)\",\n-  \"add_optab->handlers[$A].insn_code = CODE_FOR_$(add$P$a3$)\",\n-  \"addv_optab->handlers[$A].insn_code =\\n\\\n-    add_optab->handlers[$A].insn_code = CODE_FOR_$(add$F$a3$)\",\n-  \"addv_optab->handlers[$A].insn_code = CODE_FOR_$(addv$I$a3$)\",\n-  \"sub_optab->handlers[$A].insn_code = CODE_FOR_$(sub$P$a3$)\",\n-  \"subv_optab->handlers[$A].insn_code =\\n\\\n-    sub_optab->handlers[$A].insn_code = CODE_FOR_$(sub$F$a3$)\",\n-  \"subv_optab->handlers[$A].insn_code = CODE_FOR_$(subv$I$a3$)\",\n-  \"smul_optab->handlers[$A].insn_code = CODE_FOR_$(mul$P$a3$)\",\n-  \"smulv_optab->handlers[$A].insn_code =\\n\\\n-    smul_optab->handlers[$A].insn_code = CODE_FOR_$(mul$F$a3$)\",\n-  \"smulv_optab->handlers[$A].insn_code = CODE_FOR_$(mulv$I$a3$)\",\n-  \"umul_highpart_optab->handlers[$A].insn_code = CODE_FOR_$(umul$a3_highpart$)\",\n-  \"smul_highpart_optab->handlers[$A].insn_code = CODE_FOR_$(smul$a3_highpart$)\",\n-  \"smul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(mul$a$b3$)$N\",\n-  \"umul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(umul$a$b3$)$N\",\n-  \"usmul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(usmul$a$b3$)$N\",\n-  \"smadd_widen_optab->handlers[$B].insn_code = CODE_FOR_$(madd$a$b4$)$N\",\n-  \"umadd_widen_optab->handlers[$B].insn_code = CODE_FOR_$(umadd$a$b4$)$N\",\n-  \"smsub_widen_optab->handlers[$B].insn_code = CODE_FOR_$(msub$a$b4$)$N\",\n-  \"umsub_widen_optab->handlers[$B].insn_code = CODE_FOR_$(umsub$a$b4$)$N\",\n-  \"sdiv_optab->handlers[$A].insn_code = CODE_FOR_$(div$a3$)\",\n-  \"sdivv_optab->handlers[$A].insn_code = CODE_FOR_$(div$V$I$a3$)\",\n-  \"udiv_optab->handlers[$A].insn_code = CODE_FOR_$(udiv$I$a3$)\",\n-  \"sdivmod_optab->handlers[$A].insn_code = CODE_FOR_$(divmod$a4$)\",\n-  \"udivmod_optab->handlers[$A].insn_code = CODE_FOR_$(udivmod$a4$)\",\n-  \"smod_optab->handlers[$A].insn_code = CODE_FOR_$(mod$a3$)\",\n-  \"umod_optab->handlers[$A].insn_code = CODE_FOR_$(umod$a3$)\",\n-  \"fmod_optab->handlers[$A].insn_code = CODE_FOR_$(fmod$a3$)\",\n-  \"remainder_optab->handlers[$A].insn_code = CODE_FOR_$(remainder$a3$)\",\n-  \"ftrunc_optab->handlers[$A].insn_code = CODE_FOR_$(ftrunc$F$a2$)\",\n-  \"and_optab->handlers[$A].insn_code = CODE_FOR_$(and$a3$)\",\n-  \"ior_optab->handlers[$A].insn_code = CODE_FOR_$(ior$a3$)\",\n-  \"xor_optab->handlers[$A].insn_code = CODE_FOR_$(xor$a3$)\",\n-  \"ashl_optab->handlers[$A].insn_code = CODE_FOR_$(ashl$a3$)\",\n-  \"ashr_optab->handlers[$A].insn_code = CODE_FOR_$(ashr$a3$)\",\n-  \"lshr_optab->handlers[$A].insn_code = CODE_FOR_$(lshr$a3$)\",\n-  \"rotl_optab->handlers[$A].insn_code = CODE_FOR_$(rotl$a3$)\",\n-  \"rotr_optab->handlers[$A].insn_code = CODE_FOR_$(rotr$a3$)\",\n-  \"smin_optab->handlers[$A].insn_code = CODE_FOR_$(smin$a3$)\",\n-  \"smax_optab->handlers[$A].insn_code = CODE_FOR_$(smax$a3$)\",\n-  \"umin_optab->handlers[$A].insn_code = CODE_FOR_$(umin$I$a3$)\",\n-  \"umax_optab->handlers[$A].insn_code = CODE_FOR_$(umax$I$a3$)\",\n-  \"pow_optab->handlers[$A].insn_code = CODE_FOR_$(pow$a3$)\",\n-  \"atan2_optab->handlers[$A].insn_code = CODE_FOR_$(atan2$a3$)\",\n-  \"neg_optab->handlers[$A].insn_code = CODE_FOR_$(neg$P$a2$)\",\n-  \"negv_optab->handlers[$A].insn_code =\\n\\\n-    neg_optab->handlers[$A].insn_code = CODE_FOR_$(neg$F$a2$)\",\n-  \"negv_optab->handlers[$A].insn_code = CODE_FOR_$(negv$I$a2$)\",\n-  \"abs_optab->handlers[$A].insn_code = CODE_FOR_$(abs$P$a2$)\",\n-  \"absv_optab->handlers[$A].insn_code =\\n\\\n-    abs_optab->handlers[$A].insn_code = CODE_FOR_$(abs$F$a2$)\",\n-  \"absv_optab->handlers[$A].insn_code = CODE_FOR_$(absv$I$a2$)\",\n-  \"copysign_optab->handlers[$A].insn_code = CODE_FOR_$(copysign$F$a3$)\",\n-  \"signbit_optab->handlers[$A].insn_code = CODE_FOR_$(signbit$F$a2$)\",\n-  \"isinf_optab->handlers[$A].insn_code = CODE_FOR_$(isinf$a2$)\",\n-  \"sqrt_optab->handlers[$A].insn_code = CODE_FOR_$(sqrt$a2$)\",\n-  \"floor_optab->handlers[$A].insn_code = CODE_FOR_$(floor$a2$)\",\n-  \"lfloor_optab->handlers[$B][$A].insn_code = CODE_FOR_$(lfloor$F$a$I$b2$)\",\n-  \"ceil_optab->handlers[$A].insn_code = CODE_FOR_$(ceil$a2$)\",\n-  \"lceil_optab->handlers[$B][$A].insn_code = CODE_FOR_$(lceil$F$a$I$b2$)\",\n-  \"round_optab->handlers[$A].insn_code = CODE_FOR_$(round$a2$)\",\n-  \"btrunc_optab->handlers[$A].insn_code = CODE_FOR_$(btrunc$a2$)\",\n-  \"nearbyint_optab->handlers[$A].insn_code = CODE_FOR_$(nearbyint$a2$)\",\n-  \"rint_optab->handlers[$A].insn_code = CODE_FOR_$(rint$a2$)\",\n-  \"lrint_optab->handlers[$B][$A].insn_code = CODE_FOR_$(lrint$F$a$I$b2$)\",\n-  \"lround_optab->handlers[$B][$A].insn_code = CODE_FOR_$(lround$F$a$I$b2$)\",\n-  \"sincos_optab->handlers[$A].insn_code = CODE_FOR_$(sincos$a3$)\",\n-  \"sin_optab->handlers[$A].insn_code = CODE_FOR_$(sin$a2$)\",\n-  \"asin_optab->handlers[$A].insn_code = CODE_FOR_$(asin$a2$)\",\n-  \"cos_optab->handlers[$A].insn_code = CODE_FOR_$(cos$a2$)\",\n-  \"acos_optab->handlers[$A].insn_code = CODE_FOR_$(acos$a2$)\",\n-  \"exp_optab->handlers[$A].insn_code = CODE_FOR_$(exp$a2$)\",\n-  \"exp10_optab->handlers[$A].insn_code = CODE_FOR_$(exp10$a2$)\",\n-  \"exp2_optab->handlers[$A].insn_code = CODE_FOR_$(exp2$a2$)\",\n-  \"expm1_optab->handlers[$A].insn_code = CODE_FOR_$(expm1$a2$)\",\n-  \"ldexp_optab->handlers[$A].insn_code = CODE_FOR_$(ldexp$a3$)\",\n-  \"scalb_optab->handlers[$A].insn_code = CODE_FOR_$(scalb$a3$)\",\n-  \"logb_optab->handlers[$A].insn_code = CODE_FOR_$(logb$a2$)\",\n-  \"ilogb_optab->handlers[$A].insn_code = CODE_FOR_$(ilogb$a2$)\",\n-  \"log_optab->handlers[$A].insn_code = CODE_FOR_$(log$a2$)\",\n-  \"log10_optab->handlers[$A].insn_code = CODE_FOR_$(log10$a2$)\",  \n-  \"log2_optab->handlers[$A].insn_code = CODE_FOR_$(log2$a2$)\",  \n-  \"log1p_optab->handlers[$A].insn_code = CODE_FOR_$(log1p$a2$)\",  \n-  \"tan_optab->handlers[$A].insn_code = CODE_FOR_$(tan$a2$)\",\n-  \"atan_optab->handlers[$A].insn_code = CODE_FOR_$(atan$a2$)\",\n-  \"strlen_optab->handlers[$A].insn_code = CODE_FOR_$(strlen$a$)\",\n-  \"one_cmpl_optab->handlers[$A].insn_code = CODE_FOR_$(one_cmpl$a2$)\",\n-  \"bswap_optab->handlers[$A].insn_code = CODE_FOR_$(bswap$a2$)\",\n-  \"ffs_optab->handlers[$A].insn_code = CODE_FOR_$(ffs$a2$)\",\n-  \"clz_optab->handlers[$A].insn_code = CODE_FOR_$(clz$a2$)\",\n-  \"ctz_optab->handlers[$A].insn_code = CODE_FOR_$(ctz$a2$)\",\n-  \"popcount_optab->handlers[$A].insn_code = CODE_FOR_$(popcount$a2$)\",\n-  \"parity_optab->handlers[$A].insn_code = CODE_FOR_$(parity$a2$)\",\n-  \"mov_optab->handlers[$A].insn_code = CODE_FOR_$(mov$a$)\",\n-  \"movstrict_optab->handlers[$A].insn_code = CODE_FOR_$(movstrict$a$)\",\n-  \"movmisalign_optab->handlers[$A].insn_code = CODE_FOR_$(movmisalign$a$)\",\n-  \"storent_optab->handlers[$A].insn_code = CODE_FOR_$(storent$a$)\",\n-  \"cmp_optab->handlers[$A].insn_code = CODE_FOR_$(cmp$a$)\",\n-  \"tst_optab->handlers[$A].insn_code = CODE_FOR_$(tst$a$)\",\n-  \"addcc_optab->handlers[$A].insn_code = CODE_FOR_$(add$acc$)\",\n+{ \"convert_optab_handler (sext_optab, $B, $A)->insn_code = CODE_FOR_$(extend$a$b2$)\",\n+  \"convert_optab_handler (zext_optab, $B, $A)->insn_code = CODE_FOR_$(zero_extend$a$b2$)\",\n+  \"convert_optab_handler (sfix_optab, $B, $A)->insn_code = CODE_FOR_$(fix$F$a$I$b2$)\",\n+  \"convert_optab_handler (ufix_optab, $B, $A)->insn_code = CODE_FOR_$(fixuns$F$a$b2$)\",\n+  \"convert_optab_handler (sfixtrunc_optab, $B, $A)->insn_code = CODE_FOR_$(fix_trunc$F$a$I$b2$)\",\n+  \"convert_optab_handler (ufixtrunc_optab, $B, $A)->insn_code = CODE_FOR_$(fixuns_trunc$F$a$I$b2$)\",\n+  \"convert_optab_handler (sfloat_optab, $B, $A)->insn_code = CODE_FOR_$(float$I$a$F$b2$)\",\n+  \"convert_optab_handler (ufloat_optab, $B, $A)->insn_code = CODE_FOR_$(floatuns$I$a$F$b2$)\",\n+  \"convert_optab_handler (trunc_optab, $B, $A)->insn_code = CODE_FOR_$(trunc$a$b2$)\",\n+  \"optab_handler (add_optab, $A)->insn_code = CODE_FOR_$(add$P$a3$)\",\n+  \"optab_handler (addv_optab, $A)->insn_code =\\n\\\n+    optab_handler (add_optab, $A)->insn_code = CODE_FOR_$(add$F$a3$)\",\n+  \"optab_handler (addv_optab, $A)->insn_code = CODE_FOR_$(addv$I$a3$)\",\n+  \"optab_handler (sub_optab, $A)->insn_code = CODE_FOR_$(sub$P$a3$)\",\n+  \"optab_handler (subv_optab, $A)->insn_code =\\n\\\n+    optab_handler (sub_optab, $A)->insn_code = CODE_FOR_$(sub$F$a3$)\",\n+  \"optab_handler (subv_optab, $A)->insn_code = CODE_FOR_$(subv$I$a3$)\",\n+  \"optab_handler (smul_optab, $A)->insn_code = CODE_FOR_$(mul$P$a3$)\",\n+  \"optab_handler (smulv_optab, $A)->insn_code =\\n\\\n+    optab_handler (smul_optab, $A)->insn_code = CODE_FOR_$(mul$F$a3$)\",\n+  \"optab_handler (smulv_optab, $A)->insn_code = CODE_FOR_$(mulv$I$a3$)\",\n+  \"optab_handler (umul_highpart_optab, $A)->insn_code = CODE_FOR_$(umul$a3_highpart$)\",\n+  \"optab_handler (smul_highpart_optab, $A)->insn_code = CODE_FOR_$(smul$a3_highpart$)\",\n+  \"optab_handler (smul_widen_optab, $B)->insn_code = CODE_FOR_$(mul$a$b3$)$N\",\n+  \"optab_handler (umul_widen_optab, $B)->insn_code = CODE_FOR_$(umul$a$b3$)$N\",\n+  \"optab_handler (usmul_widen_optab, $B)->insn_code = CODE_FOR_$(usmul$a$b3$)$N\",\n+  \"optab_handler (smadd_widen_optab, $B)->insn_code = CODE_FOR_$(madd$a$b4$)$N\",\n+  \"optab_handler (umadd_widen_optab, $B)->insn_code = CODE_FOR_$(umadd$a$b4$)$N\",\n+  \"optab_handler (smsub_widen_optab, $B)->insn_code = CODE_FOR_$(msub$a$b4$)$N\",\n+  \"optab_handler (umsub_widen_optab, $B)->insn_code = CODE_FOR_$(umsub$a$b4$)$N\",\n+  \"optab_handler (sdiv_optab, $A)->insn_code = CODE_FOR_$(div$a3$)\",\n+  \"optab_handler (sdivv_optab, $A)->insn_code = CODE_FOR_$(div$V$I$a3$)\",\n+  \"optab_handler (udiv_optab, $A)->insn_code = CODE_FOR_$(udiv$I$a3$)\",\n+  \"optab_handler (sdivmod_optab, $A)->insn_code = CODE_FOR_$(divmod$a4$)\",\n+  \"optab_handler (udivmod_optab, $A)->insn_code = CODE_FOR_$(udivmod$a4$)\",\n+  \"optab_handler (smod_optab, $A)->insn_code = CODE_FOR_$(mod$a3$)\",\n+  \"optab_handler (umod_optab, $A)->insn_code = CODE_FOR_$(umod$a3$)\",\n+  \"optab_handler (fmod_optab, $A)->insn_code = CODE_FOR_$(fmod$a3$)\",\n+  \"optab_handler (remainder_optab, $A)->insn_code = CODE_FOR_$(remainder$a3$)\",\n+  \"optab_handler (ftrunc_optab, $A)->insn_code = CODE_FOR_$(ftrunc$F$a2$)\",\n+  \"optab_handler (and_optab, $A)->insn_code = CODE_FOR_$(and$a3$)\",\n+  \"optab_handler (ior_optab, $A)->insn_code = CODE_FOR_$(ior$a3$)\",\n+  \"optab_handler (xor_optab, $A)->insn_code = CODE_FOR_$(xor$a3$)\",\n+  \"optab_handler (ashl_optab, $A)->insn_code = CODE_FOR_$(ashl$a3$)\",\n+  \"optab_handler (ashr_optab, $A)->insn_code = CODE_FOR_$(ashr$a3$)\",\n+  \"optab_handler (lshr_optab, $A)->insn_code = CODE_FOR_$(lshr$a3$)\",\n+  \"optab_handler (rotl_optab, $A)->insn_code = CODE_FOR_$(rotl$a3$)\",\n+  \"optab_handler (rotr_optab, $A)->insn_code = CODE_FOR_$(rotr$a3$)\",\n+  \"optab_handler (smin_optab, $A)->insn_code = CODE_FOR_$(smin$a3$)\",\n+  \"optab_handler (smax_optab, $A)->insn_code = CODE_FOR_$(smax$a3$)\",\n+  \"optab_handler (umin_optab, $A)->insn_code = CODE_FOR_$(umin$I$a3$)\",\n+  \"optab_handler (umax_optab, $A)->insn_code = CODE_FOR_$(umax$I$a3$)\",\n+  \"optab_handler (pow_optab, $A)->insn_code = CODE_FOR_$(pow$a3$)\",\n+  \"optab_handler (atan2_optab, $A)->insn_code = CODE_FOR_$(atan2$a3$)\",\n+  \"optab_handler (neg_optab, $A)->insn_code = CODE_FOR_$(neg$P$a2$)\",\n+  \"optab_handler (negv_optab, $A)->insn_code =\\n\\\n+    optab_handler (neg_optab, $A)->insn_code = CODE_FOR_$(neg$F$a2$)\",\n+  \"optab_handler (negv_optab, $A)->insn_code = CODE_FOR_$(negv$I$a2$)\",\n+  \"optab_handler (abs_optab, $A)->insn_code = CODE_FOR_$(abs$P$a2$)\",\n+  \"optab_handler (absv_optab, $A)->insn_code =\\n\\\n+    optab_handler (abs_optab, $A)->insn_code = CODE_FOR_$(abs$F$a2$)\",\n+  \"optab_handler (absv_optab, $A)->insn_code = CODE_FOR_$(absv$I$a2$)\",\n+  \"optab_handler (copysign_optab, $A)->insn_code = CODE_FOR_$(copysign$F$a3$)\",\n+  \"optab_handler (signbit_optab, $A)->insn_code = CODE_FOR_$(signbit$F$a2$)\",\n+  \"optab_handler (isinf_optab, $A)->insn_code = CODE_FOR_$(isinf$a2$)\",\n+  \"optab_handler (sqrt_optab, $A)->insn_code = CODE_FOR_$(sqrt$a2$)\",\n+  \"optab_handler (floor_optab, $A)->insn_code = CODE_FOR_$(floor$a2$)\",\n+  \"convert_optab_handler (lfloor_optab, $B, $A)->insn_code = CODE_FOR_$(lfloor$F$a$I$b2$)\",\n+  \"optab_handler (ceil_optab, $A)->insn_code = CODE_FOR_$(ceil$a2$)\",\n+  \"convert_optab_handler (lceil_optab, $B, $A)->insn_code = CODE_FOR_$(lceil$F$a$I$b2$)\",\n+  \"optab_handler (round_optab, $A)->insn_code = CODE_FOR_$(round$a2$)\",\n+  \"optab_handler (btrunc_optab, $A)->insn_code = CODE_FOR_$(btrunc$a2$)\",\n+  \"optab_handler (nearbyint_optab, $A)->insn_code = CODE_FOR_$(nearbyint$a2$)\",\n+  \"optab_handler (rint_optab, $A)->insn_code = CODE_FOR_$(rint$a2$)\",\n+  \"convert_optab_handler (lrint_optab, $B, $A)->insn_code = CODE_FOR_$(lrint$F$a$I$b2$)\",\n+  \"convert_optab_handler (lround_optab, $B, $A)->insn_code = CODE_FOR_$(lround$F$a$I$b2$)\",\n+  \"optab_handler (sincos_optab, $A)->insn_code = CODE_FOR_$(sincos$a3$)\",\n+  \"optab_handler (sin_optab, $A)->insn_code = CODE_FOR_$(sin$a2$)\",\n+  \"optab_handler (asin_optab, $A)->insn_code = CODE_FOR_$(asin$a2$)\",\n+  \"optab_handler (cos_optab, $A)->insn_code = CODE_FOR_$(cos$a2$)\",\n+  \"optab_handler (acos_optab, $A)->insn_code = CODE_FOR_$(acos$a2$)\",\n+  \"optab_handler (exp_optab, $A)->insn_code = CODE_FOR_$(exp$a2$)\",\n+  \"optab_handler (exp10_optab, $A)->insn_code = CODE_FOR_$(exp10$a2$)\",\n+  \"optab_handler (exp2_optab, $A)->insn_code = CODE_FOR_$(exp2$a2$)\",\n+  \"optab_handler (expm1_optab, $A)->insn_code = CODE_FOR_$(expm1$a2$)\",\n+  \"optab_handler (ldexp_optab, $A)->insn_code = CODE_FOR_$(ldexp$a3$)\",\n+  \"optab_handler (scalb_optab, $A)->insn_code = CODE_FOR_$(scalb$a3$)\",\n+  \"optab_handler (logb_optab, $A)->insn_code = CODE_FOR_$(logb$a2$)\",\n+  \"optab_handler (ilogb_optab, $A)->insn_code = CODE_FOR_$(ilogb$a2$)\",\n+  \"optab_handler (log_optab, $A)->insn_code = CODE_FOR_$(log$a2$)\",\n+  \"optab_handler (log10_optab, $A)->insn_code = CODE_FOR_$(log10$a2$)\",  \n+  \"optab_handler (log2_optab, $A)->insn_code = CODE_FOR_$(log2$a2$)\",  \n+  \"optab_handler (log1p_optab, $A)->insn_code = CODE_FOR_$(log1p$a2$)\",  \n+  \"optab_handler (tan_optab, $A)->insn_code = CODE_FOR_$(tan$a2$)\",\n+  \"optab_handler (atan_optab, $A)->insn_code = CODE_FOR_$(atan$a2$)\",\n+  \"optab_handler (strlen_optab, $A)->insn_code = CODE_FOR_$(strlen$a$)\",\n+  \"optab_handler (one_cmpl_optab, $A)->insn_code = CODE_FOR_$(one_cmpl$a2$)\",\n+  \"optab_handler (bswap_optab, $A)->insn_code = CODE_FOR_$(bswap$a2$)\",\n+  \"optab_handler (ffs_optab, $A)->insn_code = CODE_FOR_$(ffs$a2$)\",\n+  \"optab_handler (clz_optab, $A)->insn_code = CODE_FOR_$(clz$a2$)\",\n+  \"optab_handler (ctz_optab, $A)->insn_code = CODE_FOR_$(ctz$a2$)\",\n+  \"optab_handler (popcount_optab, $A)->insn_code = CODE_FOR_$(popcount$a2$)\",\n+  \"optab_handler (parity_optab, $A)->insn_code = CODE_FOR_$(parity$a2$)\",\n+  \"optab_handler (mov_optab, $A)->insn_code = CODE_FOR_$(mov$a$)\",\n+  \"optab_handler (movstrict_optab, $A)->insn_code = CODE_FOR_$(movstrict$a$)\",\n+  \"optab_handler (movmisalign_optab, $A)->insn_code = CODE_FOR_$(movmisalign$a$)\",\n+  \"optab_handler (storent_optab, $A)->insn_code = CODE_FOR_$(storent$a$)\",\n+  \"optab_handler (cmp_optab, $A)->insn_code = CODE_FOR_$(cmp$a$)\",\n+  \"optab_handler (tst_optab, $A)->insn_code = CODE_FOR_$(tst$a$)\",\n+  \"optab_handler (addcc_optab, $A)->insn_code = CODE_FOR_$(add$acc$)\",\n   \"bcc_gen_fctn[$C] = gen_$(b$c$)\",\n   \"setcc_gen_code[$C] = CODE_FOR_$(s$c$)\",\n   \"movcc_gen_code[$A] = CODE_FOR_$(mov$acc$)\",\n-  \"cbranch_optab->handlers[$A].insn_code = CODE_FOR_$(cbranch$a4$)\",\n-  \"cmov_optab->handlers[$A].insn_code = CODE_FOR_$(cmov$a6$)\",\n-  \"cstore_optab->handlers[$A].insn_code = CODE_FOR_$(cstore$a4$)\",\n-  \"push_optab->handlers[$A].insn_code = CODE_FOR_$(push$a1$)\",\n+  \"optab_handler (cbranch_optab, $A)->insn_code = CODE_FOR_$(cbranch$a4$)\",\n+  \"optab_handler (cmov_optab, $A)->insn_code = CODE_FOR_$(cmov$a6$)\",\n+  \"optab_handler (cstore_optab, $A)->insn_code = CODE_FOR_$(cstore$a4$)\",\n+  \"optab_handler (push_optab, $A)->insn_code = CODE_FOR_$(push$a1$)\",\n   \"reload_in_optab[$A] = CODE_FOR_$(reload_in$a$)\",\n   \"reload_out_optab[$A] = CODE_FOR_$(reload_out$a$)\",\n   \"movmem_optab[$A] = CODE_FOR_$(movmem$a$)\",\n@@ -204,45 +204,45 @@ static const char * const optabs[] =\n   \"sync_compare_and_swap_cc[$A] = CODE_FOR_$(sync_compare_and_swap_cc$I$a$)\",\n   \"sync_lock_test_and_set[$A] = CODE_FOR_$(sync_lock_test_and_set$I$a$)\",\n   \"sync_lock_release[$A] = CODE_FOR_$(sync_lock_release$I$a$)\",\n-  \"vec_set_optab->handlers[$A].insn_code = CODE_FOR_$(vec_set$a$)\",\n-  \"vec_extract_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract$a$)\",\n-  \"vec_extract_even_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract_even$a$)\",\n-  \"vec_extract_odd_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract_odd$a$)\",\n-  \"vec_interleave_high_optab->handlers[$A].insn_code = CODE_FOR_$(vec_interleave_high$a$)\",\n-  \"vec_interleave_low_optab->handlers[$A].insn_code = CODE_FOR_$(vec_interleave_low$a$)\",\n-  \"vec_init_optab->handlers[$A].insn_code = CODE_FOR_$(vec_init$a$)\",\n-  \"vec_shl_optab->handlers[$A].insn_code = CODE_FOR_$(vec_shl_$a$)\",\n-  \"vec_shr_optab->handlers[$A].insn_code = CODE_FOR_$(vec_shr_$a$)\",\n-  \"vec_realign_load_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_load_$a$)\",\n+  \"optab_handler (vec_set_optab, $A)->insn_code = CODE_FOR_$(vec_set$a$)\",\n+  \"optab_handler (vec_extract_optab, $A)->insn_code = CODE_FOR_$(vec_extract$a$)\",\n+  \"optab_handler (vec_extract_even_optab, $A)->insn_code = CODE_FOR_$(vec_extract_even$a$)\",\n+  \"optab_handler (vec_extract_odd_optab, $A)->insn_code = CODE_FOR_$(vec_extract_odd$a$)\",\n+  \"optab_handler (vec_interleave_high_optab, $A)->insn_code = CODE_FOR_$(vec_interleave_high$a$)\",\n+  \"optab_handler (vec_interleave_low_optab, $A)->insn_code = CODE_FOR_$(vec_interleave_low$a$)\",\n+  \"optab_handler (vec_init_optab, $A)->insn_code = CODE_FOR_$(vec_init$a$)\",\n+  \"optab_handler (vec_shl_optab, $A)->insn_code = CODE_FOR_$(vec_shl_$a$)\",\n+  \"optab_handler (vec_shr_optab, $A)->insn_code = CODE_FOR_$(vec_shr_$a$)\",\n+  \"optab_handler (vec_realign_load_optab, $A)->insn_code = CODE_FOR_$(vec_realign_load_$a$)\",\n   \"vcond_gen_code[$A] = CODE_FOR_$(vcond$a$)\",\n   \"vcondu_gen_code[$A] = CODE_FOR_$(vcondu$a$)\",\n-  \"ssum_widen_optab->handlers[$A].insn_code = CODE_FOR_$(widen_ssum$I$a3$)\",\n-  \"usum_widen_optab->handlers[$A].insn_code = CODE_FOR_$(widen_usum$I$a3$)\",\n-  \"udot_prod_optab->handlers[$A].insn_code = CODE_FOR_$(udot_prod$I$a$)\",\n-  \"sdot_prod_optab->handlers[$A].insn_code = CODE_FOR_$(sdot_prod$I$a$)\",\n-  \"reduc_smax_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smax_$a$)\",\n-  \"reduc_umax_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_umax_$a$)\",\n-  \"reduc_smin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smin_$a$)\",\n-  \"reduc_umin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_umin_$a$)\",\n-  \"reduc_splus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_splus_$a$)\" ,\n-  \"reduc_uplus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_uplus_$a$)\",\n-  \"vec_widen_umult_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_widen_umult_hi_$a$)\",\n-  \"vec_widen_umult_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_widen_umult_lo_$a$)\",\n-  \"vec_widen_smult_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_widen_smult_hi_$a$)\",\n-  \"vec_widen_smult_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_widen_smult_lo_$a$)\",\n-  \"vec_unpacks_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_hi_$a$)\",\n-  \"vec_unpacks_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_lo_$a$)\",\n-  \"vec_unpacku_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_hi_$a$)\",\n-  \"vec_unpacku_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_lo_$a$)\",\n-  \"vec_unpacks_float_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_float_hi_$a$)\",\n-  \"vec_unpacks_float_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_float_lo_$a$)\",\n-  \"vec_unpacku_float_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_float_hi_$a$)\",\n-  \"vec_unpacku_float_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_float_lo_$a$)\",\n-  \"vec_pack_trunc_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_trunc_$a$)\",\n-  \"vec_pack_ssat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_ssat_$a$)\",\n-  \"vec_pack_usat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_usat_$a$)\",\n-  \"vec_pack_sfix_trunc_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_sfix_trunc_$a$)\",\n-  \"vec_pack_ufix_trunc_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_ufix_trunc_$a$)\"\n+  \"optab_handler (ssum_widen_optab, $A)->insn_code = CODE_FOR_$(widen_ssum$I$a3$)\",\n+  \"optab_handler (usum_widen_optab, $A)->insn_code = CODE_FOR_$(widen_usum$I$a3$)\",\n+  \"optab_handler (udot_prod_optab, $A)->insn_code = CODE_FOR_$(udot_prod$I$a$)\",\n+  \"optab_handler (sdot_prod_optab, $A)->insn_code = CODE_FOR_$(sdot_prod$I$a$)\",\n+  \"optab_handler (reduc_smax_optab, $A)->insn_code = CODE_FOR_$(reduc_smax_$a$)\",\n+  \"optab_handler (reduc_umax_optab, $A)->insn_code = CODE_FOR_$(reduc_umax_$a$)\",\n+  \"optab_handler (reduc_smin_optab, $A)->insn_code = CODE_FOR_$(reduc_smin_$a$)\",\n+  \"optab_handler (reduc_umin_optab, $A)->insn_code = CODE_FOR_$(reduc_umin_$a$)\",\n+  \"optab_handler (reduc_splus_optab, $A)->insn_code = CODE_FOR_$(reduc_splus_$a$)\" ,\n+  \"optab_handler (reduc_uplus_optab, $A)->insn_code = CODE_FOR_$(reduc_uplus_$a$)\",\n+  \"optab_handler (vec_widen_umult_hi_optab, $A)->insn_code = CODE_FOR_$(vec_widen_umult_hi_$a$)\",\n+  \"optab_handler (vec_widen_umult_lo_optab, $A)->insn_code = CODE_FOR_$(vec_widen_umult_lo_$a$)\",\n+  \"optab_handler (vec_widen_smult_hi_optab, $A)->insn_code = CODE_FOR_$(vec_widen_smult_hi_$a$)\",\n+  \"optab_handler (vec_widen_smult_lo_optab, $A)->insn_code = CODE_FOR_$(vec_widen_smult_lo_$a$)\",\n+  \"optab_handler (vec_unpacks_hi_optab, $A)->insn_code = CODE_FOR_$(vec_unpacks_hi_$a$)\",\n+  \"optab_handler (vec_unpacks_lo_optab, $A)->insn_code = CODE_FOR_$(vec_unpacks_lo_$a$)\",\n+  \"optab_handler (vec_unpacku_hi_optab, $A)->insn_code = CODE_FOR_$(vec_unpacku_hi_$a$)\",\n+  \"optab_handler (vec_unpacku_lo_optab, $A)->insn_code = CODE_FOR_$(vec_unpacku_lo_$a$)\",\n+  \"optab_handler (vec_unpacks_float_hi_optab, $A)->insn_code = CODE_FOR_$(vec_unpacks_float_hi_$a$)\",\n+  \"optab_handler (vec_unpacks_float_lo_optab, $A)->insn_code = CODE_FOR_$(vec_unpacks_float_lo_$a$)\",\n+  \"optab_handler (vec_unpacku_float_hi_optab, $A)->insn_code = CODE_FOR_$(vec_unpacku_float_hi_$a$)\",\n+  \"optab_handler (vec_unpacku_float_lo_optab, $A)->insn_code = CODE_FOR_$(vec_unpacku_float_lo_$a$)\",\n+  \"optab_handler (vec_pack_trunc_optab, $A)->insn_code = CODE_FOR_$(vec_pack_trunc_$a$)\",\n+  \"optab_handler (vec_pack_ssat_optab, $A)->insn_code = CODE_FOR_$(vec_pack_ssat_$a$)\",\n+  \"optab_handler (vec_pack_usat_optab, $A)->insn_code = CODE_FOR_$(vec_pack_usat_$a$)\",\n+  \"optab_handler (vec_pack_sfix_trunc_optab, $A)->insn_code = CODE_FOR_$(vec_pack_sfix_trunc_$a$)\",\n+  \"optab_handler (vec_pack_ufix_trunc_optab, $A)->insn_code = CODE_FOR_$(vec_pack_ufix_trunc_$a$)\"\n };\n \n static void gen_insn (rtx);\n@@ -475,8 +475,8 @@ from the machine description file `md'.  */\\n\\n\");\n      also convert validly to an unsigned one.  */\\n\\\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\\n\\\n     for (j = 0; j < NUM_MACHINE_MODES; j++)\\n\\\n-      ufixtrunc_optab->handlers[i][j].insn_code\\n\\\n-      = sfixtrunc_optab->handlers[i][j].insn_code;\\n\\\n+      convert_optab_handler (ufixtrunc_optab, i, j)->insn_code\\n\\\n+      = convert_optab_handler (sfixtrunc_optab, i, j)->insn_code;\\n\\\n #endif\\n\\\n }\");\n "}, {"sha": "5afd935657d76ae4f45e9e11145339bb97a29f21", "filename": "gcc/optabs.c", "status": "modified", "additions": 109, "deletions": 105, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -443,7 +443,7 @@ expand_widen_pattern_expr (tree exp, rtx op0, rtx op1, rtx wide_op, rtx target,\n   tmode0 = TYPE_MODE (TREE_TYPE (oprnd0));\n   widen_pattern_optab =\n         optab_for_tree_code (TREE_CODE (exp), TREE_TYPE (oprnd0));\n-  icode = (int) widen_pattern_optab->handlers[(int) tmode0].insn_code;\n+  icode = (int) optab_handler (widen_pattern_optab, tmode0)->insn_code;\n   gcc_assert (icode != CODE_FOR_nothing);\n   xmode0 = insn_data[icode].operand[1].mode;\n \n@@ -568,15 +568,15 @@ rtx\n expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0,\n \t\t   rtx op1, rtx op2, rtx target, int unsignedp)\n {\n-  int icode = (int) ternary_optab->handlers[(int) mode].insn_code;\n+  int icode = (int) optab_handler (ternary_optab, mode)->insn_code;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n   enum machine_mode mode2 = insn_data[icode].operand[3].mode;\n   rtx temp;\n   rtx pat;\n   rtx xop0 = op0, xop1 = op1, xop2 = op2;\n \n-  gcc_assert (ternary_optab->handlers[(int) mode].insn_code\n+  gcc_assert (optab_handler (ternary_optab, mode)->insn_code\n \t      != CODE_FOR_nothing);\n \n   if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n@@ -697,7 +697,7 @@ expand_vec_shift_expr (tree vec_shift_expr, rtx target)\n \tgcc_unreachable ();\n     }\n \n-  icode = (int) shift_optab->handlers[(int) mode].insn_code;\n+  icode = (int) optab_handler (shift_optab, mode)->insn_code;\n   gcc_assert (icode != CODE_FOR_nothing);\n \n   mode1 = insn_data[icode].operand[1].mode;\n@@ -1254,7 +1254,7 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n \t\t       rtx target, int unsignedp, enum optab_methods methods,\n \t\t       int commutative_op, rtx last)\n {\n-  int icode = (int) binoptab->handlers[(int) mode].insn_code;\n+  int icode = (int) optab_handler (binoptab, mode)->insn_code;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n   enum machine_mode tmp_mode;\n@@ -1437,7 +1437,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* If we can do it with a three-operand insn, do so.  */\n \n   if (methods != OPTAB_MUST_WIDEN\n-      && binoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+      && optab_handler (binoptab, mode)->insn_code != CODE_FOR_nothing)\n     {\n       temp = expand_binop_directly (mode, binoptab, op0, op1, target,\n \t\t\t\t    unsignedp, methods, commutative_op, last);\n@@ -1448,9 +1448,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* If we were trying to rotate, and that didn't work, try rotating\n      the other direction before falling back to shifts and bitwise-or.  */\n   if (((binoptab == rotl_optab\n-\t&& rotr_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t&& optab_handler (rotr_optab, mode)->insn_code != CODE_FOR_nothing)\n        || (binoptab == rotr_optab\n-\t   && rotl_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing))\n+\t   && optab_handler (rotl_optab, mode)->insn_code != CODE_FOR_nothing))\n       && class == MODE_INT)\n     {\n       optab otheroptab = (binoptab == rotl_optab ? rotr_optab : rotl_optab);\n@@ -1478,8 +1478,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   if (binoptab == smul_optab\n       && GET_MODE_WIDER_MODE (mode) != VOIDmode\n-      && (((unsignedp ? umul_widen_optab : smul_widen_optab)\n-\t   ->handlers[(int) GET_MODE_WIDER_MODE (mode)].insn_code)\n+      && ((optab_handler ((unsignedp ? umul_widen_optab : smul_widen_optab),\n+\t\t\t  GET_MODE_WIDER_MODE (mode))->insn_code)\n \t  != CODE_FOR_nothing))\n     {\n       temp = expand_binop (GET_MODE_WIDER_MODE (mode),\n@@ -1507,11 +1507,12 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t wider_mode != VOIDmode;\n \t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n       {\n-\tif (binoptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n+\tif (optab_handler (binoptab, wider_mode)->insn_code != CODE_FOR_nothing\n \t    || (binoptab == smul_optab\n \t\t&& GET_MODE_WIDER_MODE (wider_mode) != VOIDmode\n-\t\t&& (((unsignedp ? umul_widen_optab : smul_widen_optab)\n-\t\t     ->handlers[(int) GET_MODE_WIDER_MODE (wider_mode)].insn_code)\n+\t\t&& ((optab_handler ((unsignedp ? umul_widen_optab\n+\t\t\t\t     : smul_widen_optab),\n+\t\t\t\t     GET_MODE_WIDER_MODE (wider_mode))->insn_code)\n \t\t    != CODE_FOR_nothing)))\n \t  {\n \t    rtx xop0 = op0, xop1 = op1;\n@@ -1559,7 +1560,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if ((binoptab == and_optab || binoptab == ior_optab || binoptab == xor_optab)\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && binoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n+      && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n       int i;\n       rtx insns;\n@@ -1611,9 +1612,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && class == MODE_INT\n       && (GET_CODE (op1) == CONST_INT || !optimize_size)\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && binoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n-      && ashl_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n-      && lshr_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n+      && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing\n+      && optab_handler (ashl_optab, word_mode)->insn_code != CODE_FOR_nothing\n+      && optab_handler (lshr_optab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n       unsigned HOST_WIDE_INT shift_mask, double_shift_mask;\n       enum machine_mode op1_mode;\n@@ -1682,8 +1683,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && class == MODE_INT\n       && GET_CODE (op1) == CONST_INT\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && ashl_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n-      && lshr_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n+      && optab_handler (ashl_optab, word_mode)->insn_code != CODE_FOR_nothing\n+      && optab_handler (lshr_optab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n       rtx insns;\n       rtx into_target, outof_target;\n@@ -1799,7 +1800,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if ((binoptab == add_optab || binoptab == sub_optab)\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) >= 2 * UNITS_PER_WORD\n-      && binoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n+      && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n       unsigned int i;\n       optab otheroptab = binoptab == add_optab ? sub_optab : add_optab;\n@@ -1896,7 +1897,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       if (i == GET_MODE_BITSIZE (mode) / (unsigned) BITS_PER_WORD)\n \t{\n-\t  if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n+\t  if (optab_handler (mov_optab, mode)->insn_code != CODE_FOR_nothing\n \t      || ! rtx_equal_p (target, xtarget))\n \t    {\n \t      rtx temp = emit_move_insn (target, xtarget);\n@@ -1925,12 +1926,12 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if (binoptab == smul_optab\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && smul_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n-      && add_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n+      && optab_handler (smul_optab, word_mode)->insn_code != CODE_FOR_nothing\n+      && optab_handler (add_optab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n       rtx product = NULL_RTX;\n \n-      if (umul_widen_optab->handlers[(int) mode].insn_code\n+      if (optab_handler (umul_widen_optab, mode)->insn_code\n \t  != CODE_FOR_nothing)\n \t{\n \t  product = expand_doubleword_mult (mode, op0, op1, target,\n@@ -1940,7 +1941,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n \n       if (product == NULL_RTX\n-\t  && smul_widen_optab->handlers[(int) mode].insn_code\n+\t  && optab_handler (smul_widen_optab, mode)->insn_code\n \t     != CODE_FOR_nothing)\n \t{\n \t  product = expand_doubleword_mult (mode, op0, op1, target,\n@@ -1951,7 +1952,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       if (product != NULL_RTX)\n \t{\n-\t  if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t  if (optab_handler (mov_optab, mode)->insn_code != CODE_FOR_nothing)\n \t    {\n \t      temp = emit_move_insn (target ? target : product, product);\n \t      set_unique_reg_note (temp,\n@@ -1967,7 +1968,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* It can't be open-coded in this mode.\n      Use a library call if one is available and caller says that's ok.  */\n \n-  if (binoptab->handlers[(int) mode].libfunc\n+  if (optab_handler (binoptab, mode)->libfunc\n       && (methods == OPTAB_LIB || methods == OPTAB_LIB_WIDEN))\n     {\n       rtx insns;\n@@ -1991,7 +1992,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n-      value = emit_library_call_value (binoptab->handlers[(int) mode].libfunc,\n+      value = emit_library_call_value (optab_handler (binoptab, mode)->libfunc,\n \t\t\t\t       NULL_RTX, LCT_CONST, mode, 2,\n \t\t\t\t       op0, mode, op1x, op1_mode);\n \n@@ -2031,10 +2032,10 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if ((binoptab->handlers[(int) wider_mode].insn_code\n+\t  if ((optab_handler (binoptab, wider_mode)->insn_code\n \t       != CODE_FOR_nothing)\n \t      || (methods == OPTAB_LIB\n-\t\t  && binoptab->handlers[(int) wider_mode].libfunc))\n+\t\t  && optab_handler (binoptab, wider_mode)->libfunc))\n \t    {\n \t      rtx xop0 = op0, xop1 = op1;\n \t      int no_extend = 0;\n@@ -2108,8 +2109,8 @@ sign_expand_binop (enum machine_mode mode, optab uoptab, optab soptab,\n   /* Try widening to a signed int.  Make a fake signed optab that\n      hides any signed insn for direct use.  */\n   wide_soptab = *soptab;\n-  wide_soptab.handlers[(int) mode].insn_code = CODE_FOR_nothing;\n-  wide_soptab.handlers[(int) mode].libfunc = 0;\n+  optab_handler (&wide_soptab, mode)->insn_code = CODE_FOR_nothing;\n+  optab_handler (&wide_soptab, mode)->libfunc = 0;\n \n   temp = expand_binop (mode, &wide_soptab, op0, op1, target,\n \t\t       unsignedp, OPTAB_WIDEN);\n@@ -2168,9 +2169,9 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n   /* Record where to go back to if we fail.  */\n   last = get_last_insn ();\n \n-  if (unoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  if (optab_handler (unoptab, mode)->insn_code != CODE_FOR_nothing)\n     {\n-      int icode = (int) unoptab->handlers[(int) mode].insn_code;\n+      int icode = (int) optab_handler (unoptab, mode)->insn_code;\n       enum machine_mode mode0 = insn_data[icode].operand[2].mode;\n       rtx pat;\n       rtx xop0 = op0;\n@@ -2206,7 +2207,7 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (unoptab->handlers[(int) wider_mode].insn_code\n+\t  if (optab_handler (unoptab, wider_mode)->insn_code\n \t      != CODE_FOR_nothing)\n \t    {\n \t      rtx t0 = gen_reg_rtx (wider_mode);\n@@ -2271,9 +2272,9 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n   /* Record where to go back to if we fail.  */\n   last = get_last_insn ();\n \n-  if (binoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  if (optab_handler (binoptab, mode)->insn_code != CODE_FOR_nothing)\n     {\n-      int icode = (int) binoptab->handlers[(int) mode].insn_code;\n+      int icode = (int) optab_handler (binoptab, mode)->insn_code;\n       enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n       rtx pat;\n@@ -2329,7 +2330,7 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (binoptab->handlers[(int) wider_mode].insn_code\n+\t  if (optab_handler (binoptab, wider_mode)->insn_code\n \t      != CODE_FOR_nothing)\n \t    {\n \t      rtx t0 = gen_reg_rtx (wider_mode);\n@@ -2376,15 +2377,15 @@ expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n   gcc_assert (!targ0 != !targ1);\n \n   mode = GET_MODE (op0);\n-  if (!binoptab->handlers[(int) mode].libfunc)\n+  if (!optab_handler (binoptab, mode)->libfunc)\n     return false;\n \n   /* The value returned by the library function will have twice as\n      many bits as the nominal MODE.  */\n   libval_mode = smallest_mode_for_size (2 * GET_MODE_BITSIZE (mode),\n \t\t\t\t\tMODE_INT);\n   start_sequence ();\n-  libval = emit_library_call_value (binoptab->handlers[(int) mode].libfunc,\n+  libval = emit_library_call_value (optab_handler (binoptab, mode)->libfunc,\n \t\t\t\t    NULL_RTX, LCT_CONST,\n \t\t\t\t    libval_mode, 2,\n \t\t\t\t    op0, mode,\n@@ -2430,7 +2431,7 @@ widen_clz (enum machine_mode mode, rtx op0, rtx target)\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (clz_optab->handlers[(int) wider_mode].insn_code\n+\t  if (optab_handler (clz_optab, wider_mode)->insn_code\n \t      != CODE_FOR_nothing)\n \t    {\n \t      rtx xop0, temp, last;\n@@ -2473,7 +2474,7 @@ widen_bswap (enum machine_mode mode, rtx op0, rtx target)\n   for (wider_mode = GET_MODE_WIDER_MODE (mode);\n        wider_mode != VOIDmode;\n        wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n-    if (bswap_optab->handlers[wider_mode].insn_code != CODE_FOR_nothing)\n+    if (optab_handler (bswap_optab, wider_mode)->insn_code != CODE_FOR_nothing)\n       goto found;\n   return NULL_RTX;\n \n@@ -2535,7 +2536,7 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n       for (wider_mode = mode; wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (popcount_optab->handlers[(int) wider_mode].insn_code\n+\t  if (optab_handler (popcount_optab, wider_mode)->insn_code\n \t      != CODE_FOR_nothing)\n \t    {\n \t      rtx xop0, temp, last;\n@@ -2708,9 +2709,9 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   class = GET_MODE_CLASS (mode);\n \n-  if (unoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  if (optab_handler (unoptab, mode)->insn_code != CODE_FOR_nothing)\n     {\n-      int icode = (int) unoptab->handlers[(int) mode].insn_code;\n+      int icode = (int) optab_handler (unoptab, mode)->insn_code;\n       enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       rtx xop0 = op0;\n \n@@ -2769,7 +2770,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \treturn temp;\n \n       if (GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-\t  && unoptab->handlers[word_mode].insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (unoptab, word_mode)->insn_code != CODE_FOR_nothing)\n \t{\n \t  temp = expand_doubleword_bswap (mode, op0, target);\n \t  if (temp)\n@@ -2784,7 +2785,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t wider_mode != VOIDmode;\n \t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n       {\n-\tif (unoptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+\tif (optab_handler (unoptab, wider_mode)->insn_code != CODE_FOR_nothing)\n \t  {\n \t    rtx xop0 = op0;\n \n@@ -2823,7 +2824,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n   if (unoptab == one_cmpl_optab\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && unoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n+      && optab_handler (unoptab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n       int i;\n       rtx insns;\n@@ -2887,7 +2888,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n  try_libcall:\n   /* Now try a library call in this mode.  */\n-  if (unoptab->handlers[(int) mode].libfunc)\n+  if (optab_handler (unoptab, mode)->libfunc)\n     {\n       rtx insns;\n       rtx value;\n@@ -2904,7 +2905,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n-      value = emit_library_call_value (unoptab->handlers[(int) mode].libfunc,\n+      value = emit_library_call_value (optab_handler (unoptab, mode)->libfunc,\n \t\t\t\t       NULL_RTX, LCT_CONST, outmode,\n \t\t\t\t       1, op0, mode);\n       insns = get_insns ();\n@@ -2925,9 +2926,9 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if ((unoptab->handlers[(int) wider_mode].insn_code\n+\t  if ((optab_handler (unoptab, wider_mode)->insn_code\n \t       != CODE_FOR_nothing)\n-\t      || unoptab->handlers[(int) wider_mode].libfunc)\n+\t      || optab_handler (unoptab, wider_mode)->libfunc)\n \t    {\n \t      rtx xop0 = op0;\n \n@@ -3018,7 +3019,7 @@ expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n     }\n \n   /* If we have a MAX insn, we can do this as MAX (x, -x).  */\n-  if (smax_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n+  if (optab_handler (smax_optab, mode)->insn_code != CODE_FOR_nothing\n       && !HONOR_SIGNED_ZEROS (mode))\n     {\n       rtx last = get_last_insn ();\n@@ -3335,8 +3336,8 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n \n   if (fmt->signbit_ro >= 0\n       && (GET_CODE (op0) == CONST_DOUBLE\n-\t  || (neg_optab->handlers[mode].insn_code != CODE_FOR_nothing\n-\t      && abs_optab->handlers[mode].insn_code != CODE_FOR_nothing)))\n+\t  || (optab_handler (neg_optab, mode)->insn_code != CODE_FOR_nothing\n+\t      && optab_handler (abs_optab, mode)->insn_code != CODE_FOR_nothing)))\n     {\n       temp = expand_copysign_absneg (mode, op0, op1, target,\n \t\t\t\t     fmt->signbit_ro, op0_is_abs);\n@@ -3562,7 +3563,7 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n \t\t\t\t\t      REG_NOTES (insn));\n     }\n \n-  if (mov_optab->handlers[(int) GET_MODE (target)].insn_code\n+  if (optab_handler (mov_optab, GET_MODE (target))->insn_code\n       != CODE_FOR_nothing)\n     {\n       last = emit_move_insn (target, target);\n@@ -3720,7 +3721,7 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n     }\n \n   last = emit_move_insn (target, result);\n-  if (mov_optab->handlers[(int) GET_MODE (target)].insn_code\n+  if (optab_handler (mov_optab, GET_MODE (target))->insn_code\n       != CODE_FOR_nothing)\n     set_unique_reg_note (last, REG_EQUAL, copy_rtx (equiv));\n   else\n@@ -3758,7 +3759,7 @@ can_compare_p (enum rtx_code code, enum machine_mode mode,\n {\n   do\n     {\n-      if (cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+      if (optab_handler (cmp_optab, mode)->insn_code != CODE_FOR_nothing)\n \t{\n \t  if (purpose == ccp_jump)\n \t    return bcc_gen_fctn[(int) code] != NULL;\n@@ -3769,13 +3770,13 @@ can_compare_p (enum rtx_code code, enum machine_mode mode,\n \t    return 1;\n \t}\n       if (purpose == ccp_jump\n-\t  && cbranch_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (cbranch_optab, mode)->insn_code != CODE_FOR_nothing)\n \treturn 1;\n       if (purpose == ccp_cmov\n-\t  && cmov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (cmov_optab, mode)->insn_code != CODE_FOR_nothing)\n \treturn 1;\n       if (purpose == ccp_store_flag\n-\t  && cstore_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (cstore_optab, mode)->insn_code != CODE_FOR_nothing)\n \treturn 1;\n       mode = GET_MODE_WIDER_MODE (mode);\n     }\n@@ -3913,15 +3914,15 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \n   /* Handle a lib call just for the mode we are using.  */\n \n-  if (cmp_optab->handlers[(int) mode].libfunc && !SCALAR_FLOAT_MODE_P (mode))\n+  if (optab_handler (cmp_optab, mode)->libfunc && !SCALAR_FLOAT_MODE_P (mode))\n     {\n-      rtx libfunc = cmp_optab->handlers[(int) mode].libfunc;\n+      rtx libfunc = optab_handler (cmp_optab, mode)->libfunc;\n       rtx result;\n \n       /* If we want unsigned, and this mode has a distinct unsigned\n \t comparison routine, use that.  */\n-      if (unsignedp && ucmp_optab->handlers[(int) mode].libfunc)\n-\tlibfunc = ucmp_optab->handlers[(int) mode].libfunc;\n+      if (unsignedp && optab_handler (ucmp_optab, mode)->libfunc)\n+\tlibfunc = optab_handler (ucmp_optab, mode)->libfunc;\n \n       result = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST_MAKE_BLOCK,\n \t\t\t\t\ttargetm.libgcc_cmp_return_mode (),\n@@ -3997,7 +3998,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \n       if (label)\n \t{\n-\t  icode = cbranch_optab->handlers[(int) wider_mode].insn_code;\n+\t  icode = optab_handler (cbranch_optab, wider_mode)->insn_code;\n \n \t  if (icode != CODE_FOR_nothing\n \t      && insn_data[icode].operand[0].predicate (test, wider_mode))\n@@ -4010,7 +4011,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t}\n \n       /* Handle some compares against zero.  */\n-      icode = (int) tst_optab->handlers[(int) wider_mode].insn_code;\n+      icode = (int) optab_handler (tst_optab, wider_mode)->insn_code;\n       if (y == CONST0_RTX (mode) && icode != CODE_FOR_nothing)\n \t{\n \t  x = prepare_operand (icode, x, 0, mode, wider_mode, unsignedp);\n@@ -4022,7 +4023,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \n       /* Handle compares for which there is a directly suitable insn.  */\n \n-      icode = (int) cmp_optab->handlers[(int) wider_mode].insn_code;\n+      icode = (int) optab_handler (cmp_optab, wider_mode)->insn_code;\n       if (icode != CODE_FOR_nothing)\n \t{\n \t  x = prepare_operand (icode, x, 0, mode, wider_mode, unsignedp);\n@@ -4125,18 +4126,18 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      if ((libfunc = code_to_optab[comparison]->handlers[mode].libfunc))\n+      if ((libfunc = optab_handler (code_to_optab[comparison], mode)->libfunc))\n \tbreak;\n \n-      if ((libfunc = code_to_optab[swapped]->handlers[mode].libfunc))\n+      if ((libfunc = optab_handler (code_to_optab[swapped], mode)->libfunc))\n \t{\n \t  rtx tmp;\n \t  tmp = x; x = y; y = tmp;\n \t  comparison = swapped;\n \t  break;\n \t}\n \n-      if ((libfunc = code_to_optab[reversed]->handlers[mode].libfunc)\n+      if ((libfunc = optab_handler (code_to_optab[reversed], mode)->libfunc)\n \t  && FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, reversed))\n \t{\n \t  comparison = reversed;\n@@ -4431,7 +4432,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (mode == VOIDmode)\n     mode = GET_MODE (op2);\n \n-  icode = addcc_optab->handlers[(int) mode].insn_code;\n+  icode = optab_handler (addcc_optab, mode)->insn_code;\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4491,7 +4492,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n rtx\n gen_add2_insn (rtx x, rtx y)\n {\n-  int icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code;\n+  int icode = (int) optab_handler (add_optab, GET_MODE (x))->insn_code;\n \n   gcc_assert (insn_data[icode].operand[0].predicate\n \t      (x, insn_data[icode].operand[0].mode));\n@@ -4508,7 +4509,7 @@ gen_add2_insn (rtx x, rtx y)\n rtx\n gen_add3_insn (rtx r0, rtx r1, rtx c)\n {\n-  int icode = (int) add_optab->handlers[(int) GET_MODE (r0)].insn_code;\n+  int icode = (int) optab_handler (add_optab, GET_MODE (r0))->insn_code;\n \n   if (icode == CODE_FOR_nothing\n       || !(insn_data[icode].operand[0].predicate\n@@ -4529,7 +4530,7 @@ have_add2_insn (rtx x, rtx y)\n \n   gcc_assert (GET_MODE (x) != VOIDmode);\n \n-  icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code;\n+  icode = (int) optab_handler (add_optab, GET_MODE (x))->insn_code;\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4550,7 +4551,7 @@ have_add2_insn (rtx x, rtx y)\n rtx\n gen_sub2_insn (rtx x, rtx y)\n {\n-  int icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code;\n+  int icode = (int) optab_handler (sub_optab, GET_MODE (x))->insn_code;\n \n   gcc_assert (insn_data[icode].operand[0].predicate\n \t      (x, insn_data[icode].operand[0].mode));\n@@ -4567,7 +4568,7 @@ gen_sub2_insn (rtx x, rtx y)\n rtx\n gen_sub3_insn (rtx r0, rtx r1, rtx c)\n {\n-  int icode = (int) sub_optab->handlers[(int) GET_MODE (r0)].insn_code;\n+  int icode = (int) optab_handler (sub_optab, GET_MODE (r0))->insn_code;\n \n   if (icode == CODE_FOR_nothing\n       || !(insn_data[icode].operand[0].predicate\n@@ -4588,7 +4589,7 @@ have_sub2_insn (rtx x, rtx y)\n \n   gcc_assert (GET_MODE (x) != VOIDmode);\n \n-  icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code;\n+  icode = (int) optab_handler (sub_optab, GET_MODE (x))->insn_code;\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4634,7 +4635,7 @@ can_extend_p (enum machine_mode to_mode, enum machine_mode from_mode,\n #endif\n \n   tab = unsignedp ? zext_optab : sext_optab;\n-  return tab->handlers[to_mode][from_mode].insn_code;\n+  return convert_optab_handler (tab, to_mode, from_mode)->insn_code;\n }\n \n /* Generate the body of an insn to extend Y (with mode MFROM)\n@@ -4665,7 +4666,7 @@ can_fix_p (enum machine_mode fixmode, enum machine_mode fltmode,\n   enum insn_code icode;\n \n   tab = unsignedp ? ufixtrunc_optab : sfixtrunc_optab;\n-  icode = tab->handlers[fixmode][fltmode].insn_code;\n+  icode = convert_optab_handler (tab, fixmode, fltmode)->insn_code;\n   if (icode != CODE_FOR_nothing)\n     {\n       *truncp_ptr = 0;\n@@ -4676,9 +4677,9 @@ can_fix_p (enum machine_mode fixmode, enum machine_mode fltmode,\n      for this to work. We need to rework the fix* and ftrunc* patterns\n      and documentation.  */\n   tab = unsignedp ? ufix_optab : sfix_optab;\n-  icode = tab->handlers[fixmode][fltmode].insn_code;\n+  icode = convert_optab_handler (tab, fixmode, fltmode)->insn_code;\n   if (icode != CODE_FOR_nothing\n-      && ftrunc_optab->handlers[fltmode].insn_code != CODE_FOR_nothing)\n+      && optab_handler (ftrunc_optab, fltmode)->insn_code != CODE_FOR_nothing)\n     {\n       *truncp_ptr = 1;\n       return icode;\n@@ -4695,7 +4696,7 @@ can_float_p (enum machine_mode fltmode, enum machine_mode fixmode,\n   convert_optab tab;\n \n   tab = unsignedp ? ufloat_optab : sfloat_optab;\n-  return tab->handlers[fltmode][fixmode].insn_code;\n+  return convert_optab_handler (tab, fltmode, fixmode)->insn_code;\n }\n \f\n /* Generate code to convert FROM to floating point\n@@ -4874,7 +4875,8 @@ expand_float (rtx to, rtx from, int unsignedp)\n       if (GET_MODE_SIZE (GET_MODE (from)) < GET_MODE_SIZE (SImode))\n \tfrom = convert_to_mode (SImode, from, unsignedp);\n \n-      libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n+      libfunc = convert_optab_handler (tab, GET_MODE (to),\n+\t\t\t\t       GET_MODE (from))->libfunc;\n       gcc_assert (libfunc);\n \n       start_sequence ();\n@@ -5022,7 +5024,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \n \t  emit_label (lab2);\n \n-\t  if (mov_optab->handlers[(int) GET_MODE (to)].insn_code\n+\t  if (optab_handler (mov_optab, GET_MODE (to))->insn_code\n \t      != CODE_FOR_nothing)\n \t    {\n \t      /* Make a place for a REG_NOTE and add it.  */\n@@ -5054,7 +5056,8 @@ expand_fix (rtx to, rtx from, int unsignedp)\n       rtx libfunc;\n \n       convert_optab tab = unsignedp ? ufix_optab : sfix_optab;\n-      libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n+      libfunc = convert_optab_handler (tab, GET_MODE (to),\n+\t\t\t\t       GET_MODE (from))->libfunc;\n       gcc_assert (libfunc);\n \n       start_sequence ();\n@@ -5100,7 +5103,7 @@ expand_sfix_optab (rtx to, rtx from, convert_optab tab)\n     for (imode = GET_MODE (to); imode != VOIDmode;\n \t imode = GET_MODE_WIDER_MODE (imode))\n       {\n-\ticode = tab->handlers[imode][fmode].insn_code;\n+\ticode = convert_optab_handler (tab, imode, fmode)->insn_code;\n \tif (icode != CODE_FOR_nothing)\n \t  {\n \t    if (fmode != GET_MODE (from))\n@@ -5125,7 +5128,7 @@ int\n have_insn_for (enum rtx_code code, enum machine_mode mode)\n {\n   return (code_to_optab[(int) code] != 0\n-\t  && (code_to_optab[(int) code]->handlers[(int) mode].insn_code\n+\t  && (optab_handler (code_to_optab[(int) code], mode)->insn_code\n \t      != CODE_FOR_nothing));\n }\n \n@@ -5137,8 +5140,8 @@ new_optab (void)\n   optab op = ggc_alloc (sizeof (struct optab));\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n-      op->handlers[i].insn_code = CODE_FOR_nothing;\n-      op->handlers[i].libfunc = 0;\n+      optab_handler (op, i)->insn_code = CODE_FOR_nothing;\n+      optab_handler (op, i)->libfunc = 0;\n     }\n \n   return op;\n@@ -5152,8 +5155,8 @@ new_convert_optab (void)\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     for (j = 0; j < NUM_MACHINE_MODES; j++)\n       {\n-\top->handlers[i][j].insn_code = CODE_FOR_nothing;\n-\top->handlers[i][j].libfunc = 0;\n+\tconvert_optab_handler (op, i, j)->insn_code = CODE_FOR_nothing;\n+\tconvert_optab_handler (op, i, j)->libfunc = 0;\n       }\n   return op;\n }\n@@ -5231,7 +5234,7 @@ init_libfuncs (optab optable, int first_mode, int last_mode,\n       *p++ = suffix;\n       *p = '\\0';\n \n-      optable->handlers[(int) mode].libfunc\n+      optab_handler (optable, mode)->libfunc\n \t= init_one_libfunc (ggc_alloc_string (libfunc_name, p - libfunc_name));\n     }\n }\n@@ -5348,7 +5351,7 @@ init_interclass_conv_libfuncs (convert_optab tab, const char *opname,\n \n \t*p = '\\0';\n \n-\ttab->handlers[tmode][fmode].libfunc\n+\tconvert_optab_handler (tab, tmode, fmode)->libfunc\n \t  = init_one_libfunc (ggc_alloc_string (libfunc_name,\n \t\t\t\t\t\tp - libfunc_name));\n       }\n@@ -5423,8 +5426,8 @@ init_intraclass_conv_libfuncs (convert_optab tab, const char *opname,\n \t*p++ = '2';\n \t*p = '\\0';\n \n-\ttab->handlers[widening ? wmode : nmode]\n-\t             [widening ? nmode : wmode].libfunc\n+\tconvert_optab_handler(tab, widening ? wmode : nmode,\n+\t             \t      widening ? nmode : wmode)->libfunc\n \t  = init_one_libfunc (ggc_alloc_string (libfunc_name,\n \t\t\t\t\t\tp - libfunc_name));\n       }\n@@ -5461,9 +5464,9 @@ void\n set_optab_libfunc (optab optable, enum machine_mode mode, const char *name)\n {\n   if (name)\n-    optable->handlers[mode].libfunc = init_one_libfunc (name);\n+    optab_handler (optable, mode)->libfunc = init_one_libfunc (name);\n   else\n-    optable->handlers[mode].libfunc = 0;\n+    optab_handler (optable, mode)->libfunc = 0;\n }\n \n /* Call this to reset the function entry for one conversion optab\n@@ -5474,9 +5477,10 @@ set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n \t\t  enum machine_mode fmode, const char *name)\n {\n   if (name)\n-    optable->handlers[tmode][fmode].libfunc = init_one_libfunc (name);\n+    convert_optab_handler (optable, tmode, fmode)->libfunc\n+      = init_one_libfunc (name);\n   else\n-    optable->handlers[tmode][fmode].libfunc = 0;\n+    convert_optab_handler (optable, tmode, fmode)->libfunc = 0;\n }\n \n /* Call this once to initialize the contents of the optabs\n@@ -5710,7 +5714,7 @@ init_optabs (void)\n   /* The ffs function operates on `int'.  Fall back on it if we do not\n      have a libgcc2 function for that width.  */\n   int_mode = mode_for_size (INT_TYPE_SIZE, MODE_INT, 0);\n-  ffs_optab->handlers[(int) int_mode].libfunc = init_one_libfunc (\"ffs\");\n+  optab_handler (ffs_optab, int_mode)->libfunc = init_one_libfunc (\"ffs\");\n \n   /* Initialize the optabs with the names of the library functions.  */\n   init_integral_libfuncs (add_optab, \"add\", '3');\n@@ -5820,7 +5824,7 @@ init_optabs (void)\n   /* Use cabs for double complex abs, since systems generally have cabs.\n      Don't define any libcall for float complex, so that cabs will be used.  */\n   if (complex_double_type_node)\n-    abs_optab->handlers[TYPE_MODE (complex_double_type_node)].libfunc\n+    optab_handler (abs_optab, TYPE_MODE (complex_double_type_node))->libfunc\n       = init_one_libfunc (\"cabs\");\n \n   abort_libfunc = init_one_libfunc (\"abort\");\n@@ -5876,7 +5880,7 @@ debug_optab_libfuncs (void)\n \tstruct optab_handlers *h;\n \n \to = optab_table[i];\n-\th = &o->handlers[j];\n+\th = optab_handler (o, j);\n \tif (h->libfunc)\n \t  {\n \t    gcc_assert (GET_CODE (h->libfunc) == SYMBOL_REF);\n@@ -5896,7 +5900,7 @@ debug_optab_libfuncs (void)\n \t  struct optab_handlers *h;\n \n \t  o = &convert_optab_table[i];\n-\t  h = &o->handlers[j][k];\n+\t  h = convert_optab_handler(o, j, k);\n \t  if (h->libfunc)\n \t    {\n \t      gcc_assert (GET_CODE (h->libfunc) == SYMBOL_REF);\n@@ -5929,7 +5933,7 @@ gen_cond_trap (enum rtx_code code ATTRIBUTE_UNUSED, rtx op1,\n   if (mode == VOIDmode)\n     return 0;\n \n-  icode = cmp_optab->handlers[(int) mode].insn_code;\n+  icode = optab_handler (cmp_optab, mode)->insn_code;\n   if (icode == CODE_FOR_nothing)\n     return 0;\n "}, {"sha": "57cc4ff2361cd267e9b6d89e12478cd4c1fb554a", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -705,4 +705,8 @@ extern rtx expand_vec_cond_expr (tree, rtx);\n /* Generate code for VEC_LSHIFT_EXPR and VEC_RSHIFT_EXPR.  */\n extern rtx expand_vec_shift_expr (tree, rtx);\n \n+#define optab_handler(optab,mode) (&(optab)->handlers[(int) (mode)])\n+#define convert_optab_handler(optab,mode,mode2) \\\n+\t(&(optab)->handlers[(int) (mode)][(int) (mode2)])\n+\n #endif /* GCC_OPTABS_H */"}, {"sha": "ae913bf094ff38a21a94800bfa94b240f98539a9", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -5690,7 +5690,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t      rtx equiv = (MEM_P (XEXP (x, 0))\n \t\t\t   ? XEXP (x, 0)\n \t\t\t   : reg_equiv_mem[regno]);\n-\t      int icode = (int) add_optab->handlers[(int) Pmode].insn_code;\n+\t      int icode = (int) optab_handler (add_optab, Pmode)->insn_code;\n \t      if (insn && NONJUMP_INSN_P (insn) && equiv\n \t\t  && memory_operand (equiv, GET_MODE (equiv))\n #ifdef HAVE_cc0"}, {"sha": "e41dc9a8cfeecaab534581180093df9b794883ec", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -7940,7 +7940,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \t DEFINE_PEEPHOLE should be specified that recognizes the sequence\n \t we emit below.  */\n \n-      code = (int) add_optab->handlers[(int) GET_MODE (out)].insn_code;\n+      code = (int) optab_handler (add_optab, GET_MODE (out))->insn_code;\n \n       if (CONSTANT_P (op1) || MEM_P (op1) || GET_CODE (op1) == SUBREG\n \t  || (REG_P (op1)"}, {"sha": "cb4b1bd19e3454c54543dd2fe17ea2f1cf9a7ac3", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -2143,7 +2143,7 @@ add_case_node (struct case_node *head, tree type, tree low, tree high,\n \n /* By default, enable case bit tests on targets with ashlsi3.  */\n #ifndef CASE_USE_BIT_TESTS\n-#define CASE_USE_BIT_TESTS  (ashl_optab->handlers[word_mode].insn_code \\\n+#define CASE_USE_BIT_TESTS  (optab_handler (ashl_optab, word_mode)->insn_code \\\n \t\t\t     != CODE_FOR_nothing)\n #endif\n "}, {"sha": "705848216be93753ed3b98341059318136baf650", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -940,7 +940,7 @@ nontemporal_store_p (struct mem_ref *ref)\n   if (mode == BLKmode)\n     return false;\n \n-  code = storent_optab->handlers[mode].insn_code;\n+  code = optab_handler (storent_optab, mode)->insn_code;\n   return code != CODE_FOR_nothing;\n }\n "}, {"sha": "76a51e0f090b01fa07119ad61dc85431f8a67972", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -369,7 +369,7 @@ type_for_widest_vector_mode (enum machine_mode inner_mode, optab op, int satp)\n   for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n     if (GET_MODE_INNER (mode) == inner_mode\n         && GET_MODE_NUNITS (mode) > best_nunits\n-\t&& op->handlers[mode].insn_code != CODE_FOR_nothing)\n+\t&& optab_handler (op, mode)->insn_code != CODE_FOR_nothing)\n       best_mode = mode, best_nunits = GET_MODE_NUNITS (mode);\n \n   if (best_mode == VOIDmode)\n@@ -484,7 +484,7 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n \t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_ACCUM\n \t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_UACCUM)\n           && op != NULL\n-\t  && op->handlers[compute_mode].insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (op, compute_mode)->insn_code != CODE_FOR_nothing)\n \treturn;\n       else\n \t/* There is no operation in hardware, so fall back to scalars.  */"}, {"sha": "054bfcbc937f549b7f8adc1eb49eabd932918002", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -647,7 +647,7 @@ vect_pattern_recog_1 (\n       optab = optab_for_tree_code (TREE_CODE (pattern_expr), pattern_vectype);\n       vec_mode = TYPE_MODE (pattern_vectype);\n       if (!optab\n-          || (icode = optab->handlers[(int) vec_mode].insn_code) ==\n+          || (icode = optab_handler (optab, vec_mode)->insn_code) ==\n               CODE_FOR_nothing\n           || (type_out\n               && (!get_vectype_for_scalar_type (type_out)"}, {"sha": "8316aab9e86c09619b093a9729d8b7b01956833b", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -395,8 +395,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \n       /* We have a whole vector shift available.  */\n       if (VECTOR_MODE_P (mode)\n-\t  && optab->handlers[mode].insn_code != CODE_FOR_nothing\n-\t  && vec_shr_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (optab, mode)->insn_code != CODE_FOR_nothing\n+\t  && optab_handler (vec_shr_optab, mode)->insn_code != CODE_FOR_nothing)\n         /* Final reduction via vector shifts and the reduction operator. Also\n            requires scalar extract.  */\n \touter_cost += ((exact_log2(nelements) * 2) * TARG_VEC_STMT_COST\n@@ -1819,7 +1819,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n       int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n       tree vec_temp;\n \n-      if (vec_shr_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+      if (optab_handler (vec_shr_optab, mode)->insn_code != CODE_FOR_nothing)\n \tshift_code = VEC_RSHIFT_EXPR;\n       else\n \thave_whole_vector_shift = false;\n@@ -1835,7 +1835,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n       else\n \t{\n \t  optab optab = optab_for_tree_code (code, vectype);\n-\t  if (optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+\t  if (optab_handler (optab, mode)->insn_code == CODE_FOR_nothing)\n \t    have_whole_vector_shift = false;\n \t}\n \n@@ -2148,7 +2148,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n-  if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (optab, vec_mode)->insn_code == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"op not supported by target.\");\n@@ -2228,7 +2228,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n         fprintf (vect_dump, \"no optab for reduction.\");\n       epilog_reduc_code = NUM_TREE_CODES;\n     }\n-  if (reduc_optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (reduc_optab, vec_mode)->insn_code == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"reduc op not supported by target.\");\n@@ -3185,7 +3185,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n-  icode = (int) optab->handlers[(int) vec_mode].insn_code;\n+  icode = (int) optab_handler (optab, vec_mode)->insn_code;\n   if (icode == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3701,9 +3701,9 @@ vect_strided_store_supported (tree vectype)\n       return false;\n     }\n \n-  if (interleave_high_optab->handlers[(int) mode].insn_code \n+  if (optab_handler (interleave_high_optab, mode)->insn_code \n       == CODE_FOR_nothing\n-      || interleave_low_optab->handlers[(int) mode].insn_code \n+      || optab_handler (interleave_low_optab, mode)->insn_code \n       == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3918,7 +3918,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_mode = TYPE_MODE (vectype);\n   /* FORNOW. In some cases can vectorize even if data-type not supported\n      (e.g. - array initialization with 0).  */\n-  if (mov_optab->handlers[(int)vec_mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (mov_optab, (int)vec_mode)->insn_code == CODE_FOR_nothing)\n     return false;\n \n   if (!STMT_VINFO_DATA_REF (stmt_info))\n@@ -4234,7 +4234,7 @@ vect_strided_load_supported (tree vectype)\n       return false;\n     }\n \n-  if (perm_even_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (perm_even_optab, mode)->insn_code == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"perm_even op not supported by target.\");\n@@ -4249,7 +4249,7 @@ vect_strided_load_supported (tree vectype)\n       return false;\n     }\n \n-  if (perm_odd_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (perm_odd_optab, mode)->insn_code == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"perm_odd op not supported by target.\");\n@@ -4552,7 +4552,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /* FORNOW. In some cases can vectorize even if data-type not supported\n     (e.g. - data copies).  */\n-  if (mov_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+  if (optab_handler (mov_optab, mode)->insn_code == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"Aligned load, but unsupported type.\");"}, {"sha": "396146d803a0bdf3c2c74057f9e3be406df4228c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "patch": "@@ -111,7 +111,7 @@ along with GCC; see the file COPYING3.  If not see\n \tSince we only vectorize operations which vector form can be\n    expressed using existing tree codes, to verify that an operation is\n    supported, the vectorizer checks the relevant optab at the relevant\n-   machine_mode (e.g, add_optab->handlers[(int) V8HImode].insn_code). If\n+   machine_mode (e.g, optab_handler (add_optab, V8HImode)->insn_code). If\n    the value found is CODE_FOR_nothing, then there's no target support, and\n    we can't vectorize the stmt.\n \n@@ -1596,12 +1596,12 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n   \n   if (DR_IS_READ (dr))\n     {\n-      if (vec_realign_load_optab->handlers[mode].insn_code != CODE_FOR_nothing\n+      if (optab_handler (vec_realign_load_optab, mode)->insn_code != CODE_FOR_nothing\n \t  && (!targetm.vectorize.builtin_mask_for_load\n \t      || targetm.vectorize.builtin_mask_for_load ()))\n \treturn dr_unaligned_software_pipeline;\n \n-      if (movmisalign_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+      if (optab_handler (movmisalign_optab, mode)->insn_code != CODE_FOR_nothing)\n \t/* Can't software pipeline the loads, but can at least do them.  */\n \treturn dr_unaligned_supported;\n     }\n@@ -1869,9 +1869,9 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n     return false;\n \n   vec_mode = TYPE_MODE (vectype);\n-  if ((icode1 = optab1->handlers[(int) vec_mode].insn_code) == CODE_FOR_nothing\n+  if ((icode1 = optab_handler (optab1, vec_mode)->insn_code) == CODE_FOR_nothing\n       || insn_data[icode1].operand[0].mode != TYPE_MODE (wide_vectype)\n-      || (icode2 = optab2->handlers[(int) vec_mode].insn_code)\n+      || (icode2 = optab_handler (optab2, vec_mode)->insn_code)\n                                                         == CODE_FOR_nothing\n       || insn_data[icode2].operand[0].mode != TYPE_MODE (wide_vectype))\n     return false;\n@@ -1939,7 +1939,7 @@ supportable_narrowing_operation (enum tree_code code,\n     return false;\n \n   vec_mode = TYPE_MODE (vectype);\n-  if ((icode1 = optab1->handlers[(int) vec_mode].insn_code) == CODE_FOR_nothing\n+  if ((icode1 = optab_handler (optab1, vec_mode)->insn_code) == CODE_FOR_nothing\n       || insn_data[icode1].operand[0].mode != TYPE_MODE (narrow_vectype))\n     return false;\n "}]}