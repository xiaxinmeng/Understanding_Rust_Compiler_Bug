{"sha": "d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgxOTIyODliNThmOGE1ZmU4ZjY4YTUwZGQ4OGRiNDVjODFmOWFmYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T11:16:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T11:16:06Z"}, "message": "[multiple changes]\n\n2012-11-06  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb: Minor comment change.\n\n2012-11-06  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Extensive revision of documentation of overflow\n\tchecking.\n\t* vms_data.ads: Overflow check numbers must be in range 1-3,\n\tnot 0-3.\n\n2012-11-06  Tristan Gingold  <gingold@adacore.com>\n\n\t* sem_ch9.adb (Analyze_Protected_Type_Declaration): Emit a\n\twarning if pragma Priority is used in presence of an interrupt\n\thandler.\n\nFrom-SVN: r193234", "tree": {"sha": "dd9a3402195659649bf7a8c1a1d706f360c10504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd9a3402195659649bf7a8c1a1d706f360c10504"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/comments", "author": null, "committer": null, "parents": [{"sha": "a7f1b24f810a5f3312fee91a63f507da952498f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f1b24f810a5f3312fee91a63f507da952498f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f1b24f810a5f3312fee91a63f507da952498f3"}], "stats": {"total": 220, "additions": 133, "deletions": 87}, "files": [{"sha": "aec3b4f9904f4c01ec6d9ab9971a17090764ec7c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "patch": "@@ -1,3 +1,20 @@\n+2012-11-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb: Minor comment change.\n+\n+2012-11-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Extensive revision of documentation of overflow\n+\tchecking.\n+\t* vms_data.ads: Overflow check numbers must be in range 1-3,\n+\tnot 0-3.\n+\n+2012-11-06  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* sem_ch9.adb (Analyze_Protected_Type_Declaration): Emit a\n+\twarning if pragma Priority is used in presence of an interrupt\n+\thandler.\n+\n 2012-11-06  Robert Dewar  <dewar@adacore.com>\n \n \t* checks.ads, checks.adb, exp_ch4.adb: Minor changes throughout for"}, {"sha": "bf3a6479761f4fa4f60580f3a2a7d70f4f341e1a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "patch": "@@ -3715,7 +3715,7 @@ package body Exp_Ch4 is\n       --  Save result type\n \n       Lo, Hi : Uint;\n-      --  Bounds in Minimize calls, not used yet ???\n+      --  Bounds in Minimize calls, not used currently\n \n       LLIB : constant Entity_Id := Base_Type (Standard_Long_Long_Integer);\n       --  Entity for Long_Long_Integer'Base (Standard should export this???)"}, {"sha": "b9c57e0b57ef82398218647218a3feb5d25cdb9b", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 75, "deletions": 70, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "patch": "@@ -4339,15 +4339,14 @@ inlining, but that is no longer the case.\n \n @item -gnato??\n @cindex @option{-gnato??} (@command{gcc})\n-Set default overflow checking mode. Here `@code{??}' is two digits, a\n-single digit, or nothing. Each digit is one of the digits `@code{0}'\n+Set default mode for handling generation of code to avoid intermediate\n+arithmetic overflow. Here `@code{??}' is two digits, a\n+single digit, or nothing. Each digit is one of the digits `@code{1}'\n through `@code{3}':\n \n @itemize @bullet\n-@item   @code{0}:\n-suppress overflow checks (@code{SUPPRESSED})\n @item   @code{1}:\n-all intermediate overflows checked (@code{CHECKED})\n+all intermediate overflows checked against base type (@code{STRICT})\n @item   @code{2}:\n minimize intermediate overflows (@code{MINIMIZED})\n @item   @code{3}:\n@@ -4360,10 +4359,15 @@ assertions, and the second within assertions.\n \n If no digits follow the @option{-gnato}, then it is equivalent to\n @option{-gnato11},\n-causing all intermediate overflows to be checked.\n+causing all intermediate overflows to be handled in strict mode.\n+\n+This switch also causes arithmetic overflow checking to be performed\n+(as though pragma @code{Unsuppress (Overflow_Check)} has been specified.\n+\n+The default if no option @option{-gnato} is given is that overflow handling\n+is in @code{STRICT} mode (computations done using the base type), and that\n+overflow is not enabled.\n \n-The default if no option @option{-gnato} is given is that overflows are not\n-checked, which is equivalent to @option{-gnato00}.\n Note that division by zero is a separate check that is not\n controlled by this switch (division by zero checking is on by default).\n \n@@ -25619,7 +25623,8 @@ intermediate addition of @code{(A + 1)} raises an overflow error.\n \n The (perhaps surprising) answer is that the Ada language\n definition does not answer this question. Instead it leaves\n-it up to the implementation to do one of two things:\n+it up to the implementation to do one of two things if overflow\n+checks are enabled.\n \n @itemize @bullet\n @item\n@@ -25632,10 +25637,14 @@ subsequent operations.\n \n @noindent\n If the compiler chooses the first approach, then the assignment of this\n-example will indeed raise @code{Constraint_Error}. But if the compiler\n+example will indeed raise @code{Constraint_Error} if overflow checking is\n+enabled, or result in erroneous execution if overflow checks are suppressed.\n+\n+But if the compiler\n chooses the second approach, then it can perform both additions yielding\n the correct mathematical result, which is in range, so no exception\n-will be raised.\n+will be raised, and the right result is obtained, regardless of whether\n+overflow checks are suppressed.\n \n Note that in the first example an\n exception will be raised in either case, since if the compiler\n@@ -25700,30 +25709,22 @@ would prefer this precondition to be considered True at run time).\n To deal with the portability issue, and with the problem of\n mathematical versus run-time intepretation of the expressions in\n assertions, GNAT provides comprehensive control over the handling\n-of intermediate overflow. GNAT can operate in four modes, and\n+of intermediate overflow. GNAT can operate in three modes, and\n furthemore, permits separate selection of operating modes for\n the expressions within assertions (here the term ``assertions''\n is used in the technical sense, which includes preconditions and so forth)\n and for expressions appearing outside assertions.\n \n-The four modes are:\n+The three modes are:\n \n @itemize @bullet\n-@item   @i{Checks suppressed} (@code{SUPPRESSED})\n-\n-     This is the normal defined language mode, as specified by a pragma\n-     @code{Suppress (Overflow_Check)}. If any intermediate overflow occurs,\n-     then the program execution is erroneous, which means that anything\n-     could happen. Note in particular, that the result of evaluating\n-     a precondition may be plain wrong if there is an intermediate\n-     overflow, as in our examples above.\n-\n-@item   @i{All intermediate overflows checked} (@code{CHECKED})\n+@item   @i{All intermediate overflows checked} (@code{STRICT})\n \n      In this mode, all intermediate results for predefined arithmetic\n      operators must be in range of the base type. If this is not the\n-     case a constraint error is raised. This is the normal default mode\n-     specified by use of the pragma @code{Unsuppress (Overflow_Check)}.\n+     case then either an exception is raised (if overflow checks are\n+     enabled) or the execution is erroneous (if overflow checks are suppressed).\n+     This is the normal default mode.\n \n @item   @i{Most intermediate overflows avoided} (@code{MINIMIZED})\n \n@@ -25732,7 +25733,7 @@ The four modes are:\n      performed for predefined arithmetic operators. This is slightly more\n      expensive at\n      run time (compared to suppressing intermediate overflow checks), though\n-     the cost is minimal on modern 64-bit machines. For the examples given\n+     the cost is negligible on modern 64-bit machines. For the examples given\n      earlier, no intermediate overflows would have resulted in exceptions,\n      since the intermediate results are all in the range of\n      @code{Long_Long_Integer} (typically 64-bits on nearly all implementations\n@@ -25750,9 +25751,11 @@ The four modes are:\n      Now the intermediate results are\n      out of the range of @code{Long_Long_Integer} even though the final result\n      is in range and the precondition is True (from a mathematical point\n-     of view). In such a case, operating in this mode, an exception will\n-     be raised for the intermediate overflow (which is why this mode\n-     says @i{most} intermediate overflows are avoided).\n+     of view). In such a case, operating in this mode, an overflow occurs\n+     for the intermediate computation (which is why this mode\n+     says @i{most} intermediate overflows are avoided). In this case,\n+     an exception is raised if overflow checks are enabled, and the\n+     execution is erroneous if overflow checks are suppressed.\n \n @item   @i{All intermediate overflows avoided} (@code{ELIMINATED})\n \n@@ -25773,6 +25776,15 @@ The four modes are:\n      predefined arithmetic operators, meaning that there is never a\n      conflict between the mathematical view of the assertion, and its\n      run-time behavior.\n+\n+     Note that in this mode, the behavior is unaffected by whether or\n+     not overflow checks are suppressed, since overflow does not occur.\n+     It is possible for gigantic intermediate expressions to raise\n+     @code{Storage_Error} as a result of attempting to compute the\n+     results of such expressions (e.g. @code{Integer'Last ** Integer'Last})\n+     but overflow is impossible.\n+\n+\n @end itemize\n \n @noindent\n@@ -25781,9 +25793,10 @@ The four modes are:\n   aritmetic.\n \n   For fixed-point arithmetic, checks can be suppressed. But if checks\n-  are enabled (any of the three non-suppress modes will enable checks),\n+  are enabled\n   then fixed-point values are always checked for overflow against the\n-  base type for intermediate expressions.\n+  base type for intermediate expressions (that is such checks always\n+  operate in the equivalent of @code{STRICT} mode).\n \n   For floating-point, on nearly all architectures, @code{Machine_Overflows}\n   is False, and IEEE infinities are generated, so overflow exceptions\n@@ -25799,7 +25812,7 @@ The four modes are:\n @section Specifying the Desired Mode\n \n @noindent\n-The desired mode of overflow checking can be specified using\n+The desired mode of for handling intermediate overflow can be specified using\n either the @code{Overflow_Checks} pragma or an equivalent compiler switch.\n The pragma has the form\n @cindex pragma @code{Overflow_Checks}\n@@ -25812,8 +25825,7 @@ The pragma has the form\n where @code{MODE} is one of\n \n @itemize @bullet\n-@item   @code{SUPPRESSED}: suppress overflow checks\n-@item   @code{CHECKED}:  all intermediate overflows checked\n+@item   @code{STRICT}:  intermediate overflows checked (using base type)\n @item   @code{MINIMIZED}: minimize intermediate overflows\n @item   @code{ELIMINATED}: eliminate intermediate overflows\n @end itemize\n@@ -25850,17 +25862,21 @@ configuration pragma, specifying a default for the whole\n program, or in a declarative scope, where it applies to the\n remaining declarations and statements in that scope.\n \n+Note that pragma @code{Overflow_Checks} does not affect whether\n+overflow checks are enabled or suppressed. It only controls the\n+method used to compute intermediate values. To control whether\n+overflow checking is enabled or suppressed, use pragma @code{Suppress}\n+or @code{Unsuppress} in the usual manner\n+\n Additionally, a compiler switch @option{-gnato?} or @option{-gnato??}\n can be used to control the checking mode default (which can be subsequently\n-overridden using the pragma form).\n+overridden using pragmas).\n @cindex @option{-gnato?} (gcc)\n @cindex @option{-gnato??} (gcc)\n \n-Here `@code{?}' is one of the digits `@code{0}' through `@code{3}':\n+Here `@code{?}' is one of the digits `@code{1}' through `@code{3}':\n \n @itemize @bullet\n-@item   @code{0}:\n-suppress overflow checks (@code{SUPPRESSED})\n @item   @code{1}:\n all intermediate overflows checked (@code{CHECKED})\n @item   @code{2}:\n@@ -25879,6 +25895,11 @@ If no digits follow the @option{-gnato}, then it is equivalent to\n @option{-gnato11},\n causing all intermediate overflows to be checked.\n \n+In addition to setting the mode used for computation of intermediate\n+results, the @code{-gnato} switch also enables overflow checking (which\n+is suppressed by default). It thus combines the effect of using\n+a pragma @code{Overflow_Checks} and pragma @code{Unsuppress}.\n+\n \n @c -------------------------\n @node Default Settings\n@@ -25887,48 +25908,37 @@ causing all intermediate overflows to be checked.\n The default mode for overflow checks is\n \n @smallexample\n-   General => Suppressed\n+   General => Strict\n @end smallexample\n \n @noindent\n-which suppresses checks inside and outside assertions,\n+which causes all computations both inside and outside assertions to use\n+the base type. In addition overflow checks are suppressed.\n+\n This retains compatibility with previous versions of\n-GNAT which suppressed overflow checks by default.\n+GNAT which suppressed overflow checks by default and always\n+used the base type for computation of intermediate results.\n \n The switch @option{-gnato} (with no digits following) is equivalent to\n @cindex @option{-gnato} (gcc)\n \n @smallexample\n-   General => Checked\n+   General => Strict\n @end smallexample\n \n @noindent\n which causes overflow checking of all intermediate overflows\n-both inside and outside assertions. This provides compatibility\n+both inside and outside assertions against the base type.\n+This provides compatibility\n with this switch as implemented in previous versions of GNAT.\n \n-The pragma @code{Suppress (Overflow_Check)} sets mode\n-\n-@smallexample\n-   General => Suppressed\n-@end smallexample\n-\n-@noindent\n-suppressing all overflow checking within and outside\n-assertions.\n-@cindex @code{Overflow_Check} (argument to pragma Suppress)\n-\n-The pragam @code{Unsuppress (Overflow_Check)} sets mode\n-\n-@smallexample\n-   General => Checked\n-@end smallexample\n-\n-@noindent\n-which causes overflow checking of all intermediate overflows.\n-This applies both inside and outside assertions.\n-@cindex @code{Overflow_Check} (argument to pragma Unsuppress)\n+The pragma @code{Suppress (Overflow_Check)} disables overflow\n+checking, but it has no effect on the method used for computing\n+intermediate results.\n \n+The pragam @code{Unsuppress (Overflow_Check)} enables overflow\n+checking, but it has no effect on the method used for computing\n+intermediate results.\n \n @c -------------------------\n @node Implementation Notes\n@@ -25944,12 +25954,7 @@ makes sense if you want to\n make sure that your code is compatible with any other possible\n Ada implementation. This may be useful in ensuring portability\n for code that is to be exported to some other compiler than GNAT.\n-It is also appropriate if you intend to turn off checks for\n-the final delivered software, since in @code{SUPPRESSED} mode, the\n-assumption is that all intermediate results are in range. In\n-this situation, it is likely that you are also suppressing\n-assertions in the final executable, so in that case it does not\n-matter which mode is selected for assertions during development.\n+\n \n The Ada standard allows the reassociation of expressions at\n the same precedence level if no parentheses are present. For"}, {"sha": "8f6e4d7eaf4f65ce32ff3a6a12667f8fe0b5b2c7", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "patch": "@@ -2036,16 +2036,12 @@ package body Sem_Ch9 is\n          --  by an aspect/pragma.\n \n          declare\n-            Id : constant Entity_Id :=\n-                   Defining_Identifier (Original_Node (N));\n+            Id : constant Entity_Id := Defining_Identifier (Original_Node (N));\n             --  The warning must be issued on the original identifier in order\n             --  to deal properly with the case of a single protected object.\n \n             Prio_Item : constant Node_Id :=\n-                          Get_Rep_Item\n-                            (Defining_Identifier (N),\n-                             Name_Priority,\n-                             Check_Parents => False);\n+                          Get_Rep_Item (Def_Id, Name_Priority, False);\n \n          begin\n             if Present (Prio_Item) then\n@@ -2074,11 +2070,42 @@ package body Sem_Ch9 is\n          end if;\n       end if;\n \n+      --  If the Attach_Handler aspect is specified or the Interrupt_Handler\n+      --  aspect is True, then the initial ceiling priority must be in the\n+      --  range of System.Interrupt_Priority. It is therefore recommanded\n+      --  to use the Interrupt_Priority aspect instead of the Priority aspect.\n+\n+      if Has_Interrupt_Handler (T) or else Has_Attach_Handler (T) then\n+         declare\n+            Prio_Item : constant Node_Id :=\n+                          Get_Rep_Item (Def_Id, Name_Priority, False);\n+\n+         begin\n+            if Present (Prio_Item) then\n+\n+               --  Aspect case\n+\n+               if (Nkind (Prio_Item) = N_Aspect_Specification\n+                    or else From_Aspect_Specification (Prio_Item))\n+                 and then Chars (Identifier (Prio_Item)) = Name_Priority\n+               then\n+                  Error_Msg_N (\"?aspect Interrupt_Priority is preferred \"\n+                               & \"in presence of handlers\", Prio_Item);\n+\n+               --  Pragma case\n+\n+               elsif Pragma_Name (Prio_Item) = Name_Priority then\n+                  Error_Msg_N (\"?pragma Interrupt_Priority is preferred \"\n+                               & \"in presence of handlers\", Prio_Item);\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+\n       --  Case of a completion of a private declaration\n \n-      if T /= Def_Id\n-        and then Is_Private_Type (Def_Id)\n-      then\n+      if T /= Def_Id and then Is_Private_Type (Def_Id) then\n+\n          --  Deal with preelaborable initialization. Note that this processing\n          --  is done by Process_Full_View, but as can be seen below, in this\n          --  case the call to Process_Full_View is skipped if any serious\n@@ -2326,9 +2353,7 @@ package body Sem_Ch9 is\n             --  the first parameter of Entry_Id since it is the interface\n             --  controlling formal.\n \n-            if Ada_Version >= Ada_2012\n-              and then Is_Disp_Req\n-            then\n+            if Ada_Version >= Ada_2012 and then Is_Disp_Req then\n                declare\n                   Enclosing_Formal : Entity_Id;\n                   Target_Formal    : Entity_Id;\n@@ -2668,7 +2693,7 @@ package body Sem_Ch9 is\n       Ref_Id : Entity_Id;\n       --  This is the entity of the task or task type, and is the entity used\n       --  for cross-reference purposes (it differs from Spec_Id in the case of\n-      --  a single task, since Spec_Id is set to the task type)\n+      --  a single task, since Spec_Id is set to the task type).\n \n    begin\n       Tasking_Used := True;"}, {"sha": "e4b04b7835130a0e825a85548048953f36285c12", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8192289b58f8a5fe8f68a50dd88db45c81f9afc/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=d8192289b58f8a5fe8f68a50dd88db45c81f9afc", "patch": "@@ -2117,12 +2117,11 @@ package VMS_Data is\n    --   range 0-3, it sets the overflow checking mode for all expressions,\n    --   including those outside and within assertions. The meaning of nnn is:\n    --\n-   --     0   suppress overflow checks (SUPPRESSED)\n-   --     1   all intermediate overflows checked (CHECKED)\n+   --     1   all intermediate computations done using base type (STRICT)\n    --     2   minimize intermediate overflows (MINIMIZED)\n    --     3   eliminate intermediate overflows (ELIMINATED)\n    --\n-   --   Otherwise nn can be two digits, both 0-3, and in this case the first\n+   --   Otherwise nn can be two digits, both 1-3, and in this case the first\n    --   digit sets the mode (using the above code) for expressions outside an\n    --   assertion, and the second digit sets the mode for expressions within\n    --   an assertion."}]}