{"sha": "5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYwYjg5N2IyZWU0N2JmMzg0NWQ5MjRkZDViYzNiZWI5NDliYzc4Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-23T16:03:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-23T16:03:49Z"}, "message": "compiler: add go:notinheap magic comment\n    \n    Implement go:notinheap as the gc compiler does. A type marked as\n    go:notinheap may not live in the heap, and does not require a write\n    barrier. Struct and array types that incorporate notinheap types are\n    themselves notinheap. Allocating a value of a notinheap type on the\n    heap is an error.\n    \n    This is not just an optimization. There is code where a write barrier\n    may not occur that was getting a write barrier with gccgo but not gc,\n    because the types in question were notinheap. The case I found was\n    setting the mcache field in exitsyscallfast.\n    \n    Reviewed-on: https://go-review.googlesource.com/46490\n\nFrom-SVN: r249594", "tree": {"sha": "3f8b464d9ac9de6affa319ea9639ee19ef983302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f8b464d9ac9de6affa319ea9639ee19ef983302"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/comments", "author": null, "committer": null, "parents": [{"sha": "ef2361cbd8462374b28e9e8becf8710a9b30d125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef2361cbd8462374b28e9e8becf8710a9b30d125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef2361cbd8462374b28e9e8becf8710a9b30d125"}], "stats": {"total": 201, "additions": 178, "deletions": 23}, "files": [{"sha": "02be610b167085c0a154e6058286857c243aa462", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -1,4 +1,4 @@\n-c4adba240f9d5af8ab0534316d6b05bd988c432c\n+29c61dc3c5151df5de9362b7882ccf04679df976\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "12505b239392b87bd113e355513a5646e6835f7b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -7499,6 +7499,10 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n     }\n   Type* type = first_arg->type();\n \n+  if (!type->in_heap())\n+    go_error_at(first_arg->location(),\n+\t\t\"can't make slice of go:notinheap type\");\n+\n   bool is_slice = false;\n   bool is_map = false;\n   bool is_chan = false;\n@@ -8742,6 +8746,9 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t  }\n \n \tType* element_type = slice_type->array_type()->element_type();\n+\tif (!element_type->in_heap())\n+\t  go_error_at(args->front()->location(),\n+\t\t      \"can't append to slice of go:notinheap type\");\n \tif (this->is_varargs())\n \t  {\n \t    if (!args->back()->type()->is_slice_type()\n@@ -12436,6 +12443,13 @@ Allocation_expression::do_type()\n   return Type::make_pointer_type(this->type_);\n }\n \n+void\n+Allocation_expression::do_check_types(Gogo*)\n+{\n+  if (!this->type_->in_heap())\n+    go_error_at(this->location(), \"can't heap allocate go:notinheap type\");\n+}\n+\n // Make a copy of an allocation expression.\n \n Expression*"}, {"sha": "a144ff4168ba22375dc3fc9142547cad2467a630", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -3220,6 +3220,9 @@ class Allocation_expression : public Expression\n   do_determine_type(const Type_context*)\n   { }\n \n+  void\n+  do_check_types(Gogo*);\n+\n   Expression*\n   do_copy();\n "}, {"sha": "e9f11c2c1c0c5ab1ba93f497927712a92661d6a8", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -1897,6 +1897,11 @@ Lex::skip_cpp_comment()\n       // Applies to the next function.  Do not inline the function.\n       this->pragmas_ |= GOPRAGMA_NOINLINE;\n     }\n+  else if (verb == \"go:notinheap\")\n+    {\n+      // Applies to the next type.  The type does not live in the heap.\n+      this->pragmas_ |= GOPRAGMA_NOTINHEAP;\n+    }\n   else if (verb == \"go:systemstack\")\n     {\n       // Applies to the next function.  It must run on the system stack."}, {"sha": "a8b7091b584b7cf90247cba336cea6eb7c56fd3e", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -64,7 +64,8 @@ enum GoPragma\n   GOPRAGMA_NOWRITEBARRIER = 1 << 6,\t// No write barriers.\n   GOPRAGMA_NOWRITEBARRIERREC = 1 << 7,\t// No write barriers here or callees.\n   GOPRAGMA_CGOUNSAFEARGS = 1 << 8,\t// Pointer to arg is pointer to all.\n-  GOPRAGMA_UINTPTRESCAPES = 1 << 9\t// uintptr(p) escapes.\n+  GOPRAGMA_UINTPTRESCAPES = 1 << 9,\t// uintptr(p) escapes.\n+  GOPRAGMA_NOTINHEAP = 1 << 10\t\t// type is not in heap.\n };\n \n // A token returned from the lexer."}, {"sha": "28b1772f084f044ea477a69e99296fe7f3e4d827", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -1310,14 +1310,16 @@ Parse::declaration()\n   const Token* token = this->peek_token();\n \n   unsigned int pragmas = this->lex_->get_and_clear_pragmas();\n-  if (pragmas != 0 && !token->is_keyword(KEYWORD_FUNC))\n+  if (pragmas != 0\n+      && !token->is_keyword(KEYWORD_FUNC)\n+      && !token->is_keyword(KEYWORD_TYPE))\n     go_warning_at(token->location(), 0,\n \t\t  \"ignoring magic comment before non-function\");\n \n   if (token->is_keyword(KEYWORD_CONST))\n     this->const_decl();\n   else if (token->is_keyword(KEYWORD_TYPE))\n-    this->type_decl();\n+    this->type_decl(pragmas);\n   else if (token->is_keyword(KEYWORD_VAR))\n     this->var_decl();\n   else if (token->is_keyword(KEYWORD_FUNC))\n@@ -1342,7 +1344,8 @@ Parse::declaration_may_start_here()\n // Decl<P> = P | \"(\" [ List<P> ] \")\" .\n \n void\n-Parse::decl(void (Parse::*pfn)(void*), void* varg)\n+Parse::decl(void (Parse::*pfn)(void*, unsigned int), void* varg,\n+\t    unsigned int pragmas)\n {\n   if (this->peek_token()->is_eof())\n     {\n@@ -1352,9 +1355,12 @@ Parse::decl(void (Parse::*pfn)(void*), void* varg)\n     }\n \n   if (!this->peek_token()->is_op(OPERATOR_LPAREN))\n-    (this->*pfn)(varg);\n+    (this->*pfn)(varg, pragmas);\n   else\n     {\n+      if (pragmas != 0)\n+\tgo_warning_at(this->location(), 0,\n+\t\t      \"ignoring magic //go:... comment before group\");\n       if (!this->advance_token()->is_op(OPERATOR_RPAREN))\n \t{\n \t  this->list(pfn, varg, true);\n@@ -1378,9 +1384,10 @@ Parse::decl(void (Parse::*pfn)(void*), void* varg)\n // might follow.  This is either a '}' or a ')'.\n \n void\n-Parse::list(void (Parse::*pfn)(void*), void* varg, bool follow_is_paren)\n+Parse::list(void (Parse::*pfn)(void*, unsigned int), void* varg,\n+\t    bool follow_is_paren)\n {\n-  (this->*pfn)(varg);\n+  (this->*pfn)(varg, 0);\n   Operator follow = follow_is_paren ? OPERATOR_RPAREN : OPERATOR_RCURLY;\n   while (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t || this->peek_token()->is_op(OPERATOR_COMMA))\n@@ -1389,7 +1396,7 @@ Parse::list(void (Parse::*pfn)(void*), void* varg, bool follow_is_paren)\n \tgo_error_at(this->location(), \"unexpected comma\");\n       if (this->advance_token()->is_op(follow))\n \tbreak;\n-      (this->*pfn)(varg);\n+      (this->*pfn)(varg, 0);\n     }\n }\n \n@@ -1508,17 +1515,17 @@ Parse::const_spec(Type** last_type, Expression_list** last_expr_list)\n // TypeDecl = \"type\" Decl<TypeSpec> .\n \n void\n-Parse::type_decl()\n+Parse::type_decl(unsigned int pragmas)\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_TYPE));\n   this->advance_token();\n-  this->decl(&Parse::type_spec, NULL);\n+  this->decl(&Parse::type_spec, NULL, pragmas);\n }\n \n // TypeSpec = identifier [\"=\"] Type .\n \n void\n-Parse::type_spec(void*)\n+Parse::type_spec(void*, unsigned int pragmas)\n {\n   const Token* token = this->peek_token();\n   if (!token->is_identifier())\n@@ -1592,6 +1599,15 @@ Parse::type_spec(void*)\n \n \t  this->gogo_->define_type(named_type, nt);\n \t  go_assert(named_type->package() == NULL);\n+\n+\t  if ((pragmas & GOPRAGMA_NOTINHEAP) != 0)\n+\t    {\n+\t      nt->set_not_in_heap();\n+\t      pragmas &= ~GOPRAGMA_NOTINHEAP;\n+\t    }\n+\t  if (pragmas != 0)\n+\t    go_warning_at(location, 0,\n+\t\t\t  \"ignoring magic //go:... comment before type\");\n \t}\n       else\n \t{\n@@ -1608,15 +1624,19 @@ Parse::var_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_VAR));\n   this->advance_token();\n-  this->decl(&Parse::var_spec, NULL);\n+  this->decl(&Parse::var_spec, NULL, 0);\n }\n \n // VarSpec = IdentifierList\n //             ( CompleteType [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n \n void\n-Parse::var_spec(void*)\n+Parse::var_spec(void*, unsigned int pragmas)\n {\n+  if (pragmas != 0)\n+    go_warning_at(this->location(), 0,\n+\t\t  \"ignoring magic //go:... comment before var\");\n+\n   // Get the variable names.\n   Typed_identifier_list til;\n   this->identifier_list(&til);\n@@ -5698,14 +5718,18 @@ Parse::import_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_IMPORT));\n   this->advance_token();\n-  this->decl(&Parse::import_spec, NULL);\n+  this->decl(&Parse::import_spec, NULL, 0);\n }\n \n // ImportSpec = [ \".\" | PackageName ] PackageFileName .\n \n void\n-Parse::import_spec(void*)\n+Parse::import_spec(void*, unsigned int pragmas)\n {\n+  if (pragmas != 0)\n+    go_warning_at(this->location(), 0,\n+\t\t  \"ignoring magic //go:... comment before import\");\n+\n   const Token* token = this->peek_token();\n   Location location = token->location();\n "}, {"sha": "e416072830d780b3efebd895c228e9d3c3f205a8", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -182,14 +182,14 @@ class Parse\n   void method_spec(Typed_identifier_list*);\n   void declaration();\n   bool declaration_may_start_here();\n-  void decl(void (Parse::*)(void*), void*);\n-  void list(void (Parse::*)(void*), void*, bool);\n+  void decl(void (Parse::*)(void*, unsigned int), void*, unsigned int pragmas);\n+  void list(void (Parse::*)(void*, unsigned int), void*, bool);\n   void const_decl();\n   void const_spec(Type**, Expression_list**);\n-  void type_decl();\n-  void type_spec(void*);\n+  void type_decl(unsigned int pragmas);\n+  void type_spec(void*, unsigned int pragmas);\n   void var_decl();\n-  void var_spec(void*);\n+  void var_spec(void*, unsigned int pragmas);\n   void init_vars(const Typed_identifier_list*, Type*, Expression_list*,\n \t\t bool is_coloneq, Location);\n   bool init_vars_from_call(const Typed_identifier_list*, Type*, Expression*,\n@@ -278,7 +278,7 @@ class Parse\n   void goto_stat();\n   void package_clause();\n   void import_decl();\n-  void import_spec(void*);\n+  void import_spec(void*, unsigned int pragmas);\n \n   void reset_iota();\n   int iota_value();"}, {"sha": "b2756fde0482e0ee018dae8b1129851d8ffd11e2", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -746,6 +746,20 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n   if (Type::are_assignable(lhs, rhs, reason))\n     return true;\n \n+  // A pointer to a regular type may not be converted to a pointer to\n+  // a type that may not live in the heap, except when converting to\n+  // unsafe.Pointer.\n+  if (lhs->points_to() != NULL\n+      && rhs->points_to() != NULL\n+      && !rhs->points_to()->in_heap()\n+      && lhs->points_to()->in_heap()\n+      && !lhs->is_unsafe_pointer_type())\n+    {\n+      if (reason != NULL)\n+\treason->assign(_(\"conversion from notinheap type to normal type\"));\n+      return false;\n+    }\n+\n   // The types are convertible if they have identical underlying\n   // types, ignoring struct field tags.\n   if ((lhs->named_type() != NULL || rhs->named_type() != NULL)\n@@ -5955,6 +5969,24 @@ Struct_type::do_needs_key_update()\n   return false;\n }\n \n+// Return whether this struct type is permitted to be in the heap.\n+\n+bool\n+Struct_type::do_in_heap()\n+{\n+  const Struct_field_list* fields = this->fields_;\n+  if (fields == NULL)\n+    return true;\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf)\n+    {\n+      if (!pf->type()->in_heap())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n // Build identity and hash functions for this struct.\n \n // Hash code.\n@@ -8026,6 +8058,10 @@ Map_type::do_verify()\n   // The runtime support uses \"map[void]void\".\n   if (!this->key_type_->is_comparable() && !this->key_type_->is_void_type())\n     go_error_at(this->location_, \"invalid map key type\");\n+  if (!this->key_type_->in_heap())\n+    go_error_at(this->location_, \"go:notinheap map key not allowed\");\n+  if (!this->val_type_->in_heap())\n+    go_error_at(this->location_, \"go:notinheap map value not allowed\");\n   return true;\n }\n \n@@ -8540,6 +8576,19 @@ Type::make_map_type(Type* key_type, Type* val_type, Location location)\n \n // Class Channel_type.\n \n+// Verify.\n+\n+bool\n+Channel_type::do_verify()\n+{\n+  // We have no location for this error, but this is not something the\n+  // ordinary user will see.\n+  if (!this->element_type_->in_heap())\n+    go_error_at(Linemap::unknown_location(),\n+\t\t\"chan of go:notinheap type not allowed\");\n+  return true;\n+}\n+\n // Hash code.\n \n unsigned int"}, {"sha": "aeb04d6c50f56cc77689481993824c9f070b982b", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -636,6 +636,11 @@ class Type\n   needs_key_update()\n   { return this->do_needs_key_update(); }\n \n+  // Whether the type is permitted in the heap.\n+  bool\n+  in_heap()\n+  { return this->do_in_heap(); }\n+\n   // Return a hash code for this type for the method hash table.\n   // Types which are equivalent according to are_identical will have\n   // the same hash code.\n@@ -1051,6 +1056,10 @@ class Type\n   do_needs_key_update()\n   { return false; }\n \n+  virtual bool\n+  do_in_heap()\n+  { return true; }\n+\n   virtual unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1343,6 +1352,8 @@ class Type\n   // The GC symbol for this type.  This starts out as NULL and\n   // is filled in as needed.\n   Bvariable* gc_symbol_var_;\n+  // Whether this type can appear in the heap.\n+  bool in_heap_;\n };\n \n // Type hash table operations.\n@@ -2417,6 +2428,9 @@ class Struct_type : public Type\n   bool\n   do_needs_key_update();\n \n+  bool\n+  do_in_heap();\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2590,6 +2604,10 @@ class Array_type : public Type\n   do_needs_key_update()\n   { return this->element_type_->needs_key_update(); }\n \n+  bool\n+  do_in_heap()\n+  { return this->length_ == NULL || this->element_type_->in_heap(); }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2810,6 +2828,9 @@ class Channel_type : public Type\n   do_traverse(Traverse* traverse)\n   { return Type::traverse(this->element_type_, traverse); }\n \n+  bool\n+  do_verify();\n+\n   bool\n   do_has_pointer() const\n   { return true; }\n@@ -3047,7 +3068,7 @@ class Named_type : public Type\n       type_(type), local_methods_(NULL), all_methods_(NULL),\n       interface_method_tables_(NULL), pointer_interface_method_tables_(NULL),\n       location_(location), named_btype_(NULL), dependencies_(),\n-      is_alias_(false), is_visible_(true), is_error_(false),\n+      is_alias_(false), is_visible_(true), is_error_(false), in_heap_(true),\n       is_placeholder_(false), is_converted_(false), is_circular_(false),\n       is_verified_(false), seen_(false), seen_in_compare_is_identity_(false),\n       seen_in_get_backend_(false), seen_alias_(false)\n@@ -3079,6 +3100,11 @@ class Named_type : public Type\n   set_is_alias()\n   { this->is_alias_ = true; }\n \n+  // Mark this type as not permitted in the heap.\n+  void\n+  set_not_in_heap()\n+  { this->in_heap_ = false; }\n+\n   // Return the function in which this type is defined.  This will\n   // return NULL for a type defined in global scope.\n   const Named_object*\n@@ -3277,6 +3303,10 @@ class Named_type : public Type\n   bool\n   do_needs_key_update();\n \n+  bool\n+  do_in_heap()\n+  { return this->in_heap_ && this->type_->in_heap(); }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -3344,6 +3374,9 @@ class Named_type : public Type\n   bool is_visible_;\n   // Whether this type is erroneous.\n   bool is_error_;\n+  // Whether this type is permitted in the heap.  This is true by\n+  // default, false if there is a magic //go:notinheap comment.\n+  bool in_heap_;\n   // Whether the current value of named_btype_ is a placeholder for\n   // which the final size of the type is not known.\n   bool is_placeholder_;\n@@ -3436,6 +3469,10 @@ class Forward_declaration_type : public Type\n   do_needs_key_update()\n   { return this->real_type()->needs_key_update(); }\n \n+  bool\n+  do_in_heap()\n+  { return this->real_type()->in_heap(); }\n+\n   unsigned int\n   do_hash_for_method(Gogo* gogo) const\n   { return this->real_type()->hash_for_method(gogo); }"}, {"sha": "cbefc11c816bbb8f9dd11f79714bcb3b6e150d97", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0b897b2ee47bf3845d924dd5bc3beb949bc78b/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=5f0b897b2ee47bf3845d924dd5bc3beb949bc78b", "patch": "@@ -156,6 +156,13 @@ Write_barriers::variable(Named_object* no)\n   if (!var->has_pre_init() && init->is_static_initializer())\n     return TRAVERSE_CONTINUE;\n \n+  // Nothing to do for a type that can not be in the heap, or a\n+  // pointer to a type that can not be in the heap.\n+  if (!var->type()->in_heap())\n+    return TRAVERSE_CONTINUE;\n+  if (var->type()->points_to() != NULL && !var->type()->points_to()->in_heap())\n+    return TRAVERSE_CONTINUE;\n+\n   // Otherwise change the initializer into a pre_init assignment\n   // statement with a write barrier.\n \n@@ -215,6 +222,14 @@ Write_barriers::statement(Block* block, size_t* pindex, Statement* s)\n \tif (!var->type()->has_pointer())\n \t  break;\n \n+\t// Nothing to do for a type that can not be in the heap, or a\n+\t// pointer to a type that can not be in the heap.\n+\tif (!var->type()->in_heap())\n+\t  break;\n+\tif (var->type()->points_to() != NULL\n+\t    && !var->type()->points_to()->in_heap())\n+\t  break;\n+\n \t// Otherwise initialize the variable with a write barrier.\n \n \tFunction* function = this->function_;\n@@ -345,6 +360,13 @@ Gogo::assign_needs_write_barrier(Expression* lhs)\n \t}\n     }\n \n+  // Nothing to do for a type that can not be in the heap, or a\n+  // pointer to a type that can not be in the heap.\n+  if (!lhs->type()->in_heap())\n+    return false;\n+  if (lhs->type()->points_to() != NULL && !lhs->type()->points_to()->in_heap())\n+    return false;\n+\n   // Write barrier needed in other cases.\n   return true;\n }"}]}