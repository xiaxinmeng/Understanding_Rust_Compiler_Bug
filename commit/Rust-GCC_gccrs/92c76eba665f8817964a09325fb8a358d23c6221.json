{"sha": "92c76eba665f8817964a09325fb8a358d23c6221", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJjNzZlYmE2NjVmODgxNzk2NGEwOTMyNWZiOGEzNThkMjNjNjIyMQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2002-04-08T06:37:26Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-04-08T06:37:26Z"}, "message": "* gcj.texi (Invocation): Document CNI invocation API.\n\nFrom-SVN: r52012", "tree": {"sha": "1a40365f649284535cb2d05e6e85eb725effcfdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a40365f649284535cb2d05e6e85eb725effcfdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92c76eba665f8817964a09325fb8a358d23c6221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c76eba665f8817964a09325fb8a358d23c6221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92c76eba665f8817964a09325fb8a358d23c6221", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c76eba665f8817964a09325fb8a358d23c6221/comments", "author": null, "committer": null, "parents": [{"sha": "19fe522aa3a52d973d7d3e3002bafbc766bdb259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19fe522aa3a52d973d7d3e3002bafbc766bdb259", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19fe522aa3a52d973d7d3e3002bafbc766bdb259"}], "stats": {"total": 68, "additions": 67, "deletions": 1}, "files": [{"sha": "60620e60fd2de34bb06eb328206a3cbd055da612", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c76eba665f8817964a09325fb8a358d23c6221/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c76eba665f8817964a09325fb8a358d23c6221/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=92c76eba665f8817964a09325fb8a358d23c6221", "patch": "@@ -1,3 +1,7 @@\n+2002-04-08  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* gcj.texi (Invocation): Document CNI invocation API.\n+\n 2002-04-04  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* expr.c (truthvalue_conversion): Rename.  Update."}, {"sha": "c7776ebfb0fbc46d9c2ec90f24de38e77d68efd9", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c76eba665f8817964a09325fb8a358d23c6221/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c76eba665f8817964a09325fb8a358d23c6221/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=92c76eba665f8817964a09325fb8a358d23c6221", "patch": "@@ -860,6 +860,7 @@ alternative to the standard JNI (Java Native Interface).\n * Mixing with C++::             How CNI can interoperate with C++.\n * Exception Handling::          How exceptions are handled.\n * Synchronization::             Synchronizing between Java and C++.\n+* Invocation::\t\t\tStarting the Java runtime from C++.\n * Reflection::                  Using reflection from C++.\n @end menu\n \n@@ -1544,7 +1545,7 @@ in your @acronym{CNI} classes, as long as you use the appropriate cast.\n \n class ::MyClass : public java::lang::Object\n @{\n-   GcjRaw string;\n+   gnu.gcj.RawData string;\n \n    MyClass ();\n    gnu.gcj.RawData getText ();\n@@ -1683,6 +1684,67 @@ of a synchronized native method to handle the synchronization\n In otherwords, you need to manually add @code{JvSynchronize}\n in a @code{native synchornized} method.\n \n+@node Invocation\n+@section Invocation\n+\n+CNI permits C++ applications to make calls into Java classes, in addition to\n+allowing Java code to call into C++. Several functions, known as the \n+@dfn{invocation API}, are provided to support this.\n+\n+@deftypefun jint JvCreateJavaVM (void* @var{vm_args})\n+Initializes the Java runtime. This function performs essential initialization\n+of the threads interface, garbage collector, exception handling and other key\n+aspects of the runtime. It must be called once by an application with\n+a non-Java @code{main()} function, before any other Java or CNI calls are made.\n+It is safe, but not recommended, to call @code{JvCreateJavaVM()} more than\n+once provided it is only called from a single thread.\n+The @var{vmargs} parameter can be used to specify initialization parameters \n+for the Java runtime. It may be @code{NULL}.\n+This function returns @code{0} upon success, or @code{-1} if the runtime is\n+already initialized.\n+\n+@emph{Note:} In GCJ 3.1, the @code{vm_args} parameter is ignored. It may be \n+used in a future release.\n+@end deftypefun\n+\n+@deftypefun java::lang::Thread* JvAttachCurrentThread (jstring @var{name}, java::lang::ThreadGroup* @var{group})\n+Registers an existing thread with the Java runtime.  This must be called once\n+by a multi-threaded C++ application for each thread, before that thread makes\n+any other Java or CNI calls.\n+@var{name} specifies a name for the thread. It may be @code{NULL}, in which \n+case a name will be generated.\n+@var{group} is the ThreadGroup in which this thread will be a member. If it\n+is @code{NULL}, the thread will be a member of the main thread group.\n+The return value is the Java @code{Thread} object that represents the thread.\n+@end deftypefun\n+\n+@deftypefun jint JvDetachCurrentThread ()\n+Unregisters a thread from the Java runtime. This should be called by threads\n+that were attached using @code{JvAttachCurrentThread()}, after they have \n+finished making calls to Java code. This ensures that any resources associated\n+with the thread become eligible for garbage collection.\n+This function returns @code{0} upon success.\n+@end deftypefun\n+\n+The following example demonstrates the use of @code{JvCreateJavaVM()} from\n+a simple C++ application. It can be compiled with \n+@command{c++ test.cc -lgcj}.\n+\n+@example\n+// test.cc\n+#include <gcj/cni.h>\n+#include <java/lang/System.h>\n+#include <java/io/PrintStream.h>\n+\n+int main(int argc, char *argv)\n+@{\n+  using namespace java::lang;\n+  \n+  JvCreateJavaVM(NULL);\n+  String *hello = JvNewStringLatin1(\"Hello from C++\");\n+  System::out->println(hello);\n+@}\n+@end example\n \n @node Reflection\n @section Reflection"}]}