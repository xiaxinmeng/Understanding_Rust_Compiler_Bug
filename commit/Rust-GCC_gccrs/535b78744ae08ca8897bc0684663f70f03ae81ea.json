{"sha": "535b78744ae08ca8897bc0684663f70f03ae81ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1Yjc4NzQ0YWUwOGNhODg5N2JjMDY4NDY2M2Y3MGYwM2FlODFlYQ==", "commit": {"author": {"name": "Ralf Wildenhues", "email": "Ralf.Wildenhues@gmx.de", "date": "2011-01-17T19:13:05Z"}, "committer": {"name": "Ralf Wildenhues", "email": "rwild@gcc.gnu.org", "date": "2011-01-17T19:13:05Z"}, "message": "Markup and minor fixes in LTO documentation.\n\ngcc/:\n\t* doc/lto.texi (LTO): Ensure two spaces after period.  Fix\n\tspacing after 'e.g.', typos, comma, hyphenation.\n\nFrom-SVN: r168931", "tree": {"sha": "a875fac35f70902ca78bd44bee0e0d555729d0a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a875fac35f70902ca78bd44bee0e0d555729d0a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/535b78744ae08ca8897bc0684663f70f03ae81ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535b78744ae08ca8897bc0684663f70f03ae81ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/535b78744ae08ca8897bc0684663f70f03ae81ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535b78744ae08ca8897bc0684663f70f03ae81ea/comments", "author": null, "committer": null, "parents": [{"sha": "0ecf8f6684cb8d512ff34ec56f0f71eb495c6fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecf8f6684cb8d512ff34ec56f0f71eb495c6fe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ecf8f6684cb8d512ff34ec56f0f71eb495c6fe4"}], "stats": {"total": 65, "additions": 35, "deletions": 30}, "files": [{"sha": "a8f3ad7aa7ee026fa0ebe78b40a862eb0601aad1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535b78744ae08ca8897bc0684663f70f03ae81ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535b78744ae08ca8897bc0684663f70f03ae81ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=535b78744ae08ca8897bc0684663f70f03ae81ea", "patch": "@@ -1,3 +1,8 @@\n+2011-01-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n+\n+\t* doc/lto.texi (LTO): Ensure two spaces after period.  Fix\n+\tspacing after 'e.g.', typos, comma, hyphenation.\n+\n 2011-01-17  Richard Henderson  <rth@redhat.com>\n \n \t* config/rx/predicates.md (rx_constshift_operand): Use match_test."}, {"sha": "069dafb76e30d305e69d936b293dd2bed4e12203", "filename": "gcc/doc/lto.texi", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535b78744ae08ca8897bc0684663f70f03ae81ea/gcc%2Fdoc%2Flto.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535b78744ae08ca8897bc0684663f70f03ae81ea/gcc%2Fdoc%2Flto.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flto.texi?ref=535b78744ae08ca8897bc0684663f70f03ae81ea", "patch": "@@ -27,7 +27,7 @@ the files.  Additionally, one might be able to ship one set of fat\n objects which could be used both for development and the production of\n optimized builds.  A, perhaps surprising, side effect of this feature\n is that any mistake in the toolchain that leads to LTO information not\n-being used (e.g. an older @code{libtool} calling @code{ld} directly).\n+being used (e.g.@: an older @code{libtool} calling @code{ld} directly).\n This is both an advantage, as the system is more robust, and a\n disadvantage, as the user is not informed that the optimization has\n been disabled.\n@@ -54,7 +54,7 @@ Currently, this phase is composed of two IPA passes:\n @item @code{pass_ipa_lto_gimple_out}\n This pass executes the function @code{lto_output} in\n @file{lto-streamer-out.c}, which traverses the call graph encoding\n-every reachable declaration, type and function. This generates a\n+every reachable declaration, type and function.  This generates a\n memory representation of all the file sections described below.\n \n @item @code{pass_ipa_lto_finish_out}\n@@ -98,33 +98,33 @@ would be easy to implement.\n WHOPR splits LTO into three main stages:\n @enumerate\n @item Local generation (LGEN)\n-This stage executes in parallel. Every file in the program is compiled\n+This stage executes in parallel.  Every file in the program is compiled\n into the intermediate language and packaged together with the local\n call-graph and summary information.  This stage is the same for both\n the LTO and WHOPR compilation mode.\n \n @item Whole Program Analysis (WPA)\n-WPA is performed sequentially. The global call-graph is generated, and\n-a global analysis procedure makes transformation decisions. The global\n+WPA is performed sequentially.  The global call-graph is generated, and\n+a global analysis procedure makes transformation decisions.  The global\n call-graph is partitioned to facilitate parallel optimization during\n-phase 3. The results of the WPA stage are stored into new object files\n+phase 3.  The results of the WPA stage are stored into new object files\n which contain the partitions of program expressed in the intermediate\n language and the optimization decisions.\n \n @item Local transformations (LTRANS)\n-This stage executes in parallel. All the decisions made during phase 2\n+This stage executes in parallel.  All the decisions made during phase 2\n are implemented locally in each partitioned object file, and the final\n-object code is generated. Optimizations which cannot be decided\n+object code is generated.  Optimizations which cannot be decided\n efficiently during the phase 2 may be performed on the local\n call-graph partitions.\n @end enumerate\n \n WHOPR can be seen as an extension of the usual LTO mode of\n-compilation.  In LTO, WPA and LTRANS and are executed within a single\n+compilation.  In LTO, WPA and LTRANS are executed within a single\n execution of the compiler, after the whole program has been read into\n memory.\n \n-When compiling in WHOPR mode the callgraph is partitioned during\n+When compiling in WHOPR mode, the callgraph is partitioned during\n the WPA stage.  The whole program is split into a given number of\n partitions of roughly the same size.  The compiler tries to\n minimize the number of references which cross partition boundaries.\n@@ -149,13 +149,13 @@ are described below.\n @item Command line options (@code{.gnu.lto_.opts})\n \n This section contains the command line options used to generate the\n-object files.  This is used at link-time to determine the optimization\n+object files.  This is used at link time to determine the optimization\n level and other settings when they are not explicitly specified at the\n linker command line.\n \n Currently, GCC does not support combining LTO object files compiled\n with different set of the command line options into a single binary.\n-At link-time, the options given on the command line and the options\n+At link time, the options given on the command line and the options\n saved on all the files in a link-time set are applied globally.  No\n attempt is made at validating the combination of flags (other than the\n usual validation done by option processing).  This is implemented in\n@@ -165,7 +165,7 @@ usual validation done by option processing).  This is implemented in\n @item Symbol table (@code{.gnu.lto_.symtab})\n \n This table replaces the ELF symbol table for functions and variables\n-represented in the LTO IL. Symbols used and exported by the optimized\n+represented in the LTO IL.  Symbols used and exported by the optimized\n assembly code of ``fat'' objects might not match the ones used and\n exported by the intermediate code.  This table is necessary because\n the intermediate code is less optimized and thus requires a separate\n@@ -174,7 +174,7 @@ symbol table.\n Additionally, the binary code in the ``fat'' object will lack a call\n to a function, since the call was optimized out at compilation time\n after the intermediate language was streamed out.  In some special\n-cases, the same optimization may not happen  during link-time\n+cases, the same optimization may not happen during link-time\n optimization.  This would lead to an undefined symbol if only one\n symbol table was used.\n \n@@ -198,7 +198,7 @@ of pointers when the file is read back in\n @item The callgraph (@code{.gnu.lto_.cgraph})\n \n This section contains the basic data structure used by the GCC\n-inter-procedural optimization infrastructure. This section stores an\n+inter-procedural optimization infrastructure.  This section stores an\n annotated multi-graph which represents the functions and call sites as\n well as the variables, aliases and top-level @code{asm} statements.\n \n@@ -217,7 +217,7 @@ and read by @file{lto-cgraph.c}:@code{input_refs}.\n @item Function bodies (@code{.gnu.lto_.function_body.<name>})\n \n This section contains function bodies in the intermediate language\n-representation. Every function body is in a separate section to allow\n+representation.  Every function body is in a separate section to allow\n copying of the section independently to different object files or\n reading the function on demand.\n \n@@ -263,12 +263,12 @@ that are executed at different times during WHOPR compilation:\n @item LGEN time\n @enumerate\n @item @emph{Generate summary} (@code{generate_summary} in\n-@code{struct ipa_opt_pass_d}). This stage analyzes every function\n+@code{struct ipa_opt_pass_d}).  This stage analyzes every function\n body and variable initializer is examined and stores relevant\n information into a pass-specific data structure.\n \n @item @emph{Write summary} (@code{write_summary} in\n-@code{struct ipa_opt_pass_d}. This stage writes all the\n+@code{struct ipa_opt_pass_d}.  This stage writes all the\n pass-specific information generated by @code{generate_summary}.\n Summaries go into their own @code{LTO_section_*} sections that\n have to be declared in @file{lto-streamer.h}:@code{enum\n@@ -280,7 +280,7 @@ lto_section_type}.  A new section is created by calling\n @item WPA time\n @enumerate\n @item @emph{Read summary} (@code{read_summary} in\n-@code{struct ipa_opt_pass_d}). This stage reads all the\n+@code{struct ipa_opt_pass_d}).  This stage reads all the\n pass-specific information in exactly the same order that it was\n written by @code{write_summary}.\n \n@@ -335,7 +335,7 @@ between normal inter-procedural passes and small inter-procedural\n passes.  A @emph{small inter-procedural pass}\n (@code{SIMPLE_IPA_PASS}) is a pass that does\n everything at once and thus it can not be executed during WPA in\n-WHOPR mode. It defines only the @emph{Execute} stage and during\n+WHOPR mode.  It defines only the @emph{Execute} stage and during\n this stage it accesses and modifies the function bodies.  Such\n passes are useful for optimization at LGEN or LTRANS time and are\n used, for example, to implement early optimization before writing\n@@ -367,7 +367,7 @@ Most optimization passes split naturally into analysis,\n propagation and transformation stages.  But some do not.  The\n main problem arises when one pass performs changes and the\n following pass gets confused by seeing different callgraphs\n-betwee the @emph{Transform} stage and the @emph{Generate summary}\n+between the @emph{Transform} stage and the @emph{Generate summary}\n or @emph{Execute} stage.  This means that the passes are required\n to communicate their decisions with each other.\n \n@@ -430,7 +430,7 @@ GCC represents IPA references in the callgraph.  For a function\n or variable @code{A}, the @emph{IPA reference} is a list of all\n locations where the address of @code{A} is taken and, when\n @code{A} is a variable, a list of all direct stores and reads\n-to/from @code{A}. References represent an oriented multi-graph on\n+to/from @code{A}.  References represent an oriented multi-graph on\n the union of nodes of the callgraph and the varpool.  See\n @file{ipa-reference.c}:@code{ipa_reference_write_optimization_summary}\n and\n@@ -454,7 +454,7 @@ Link-time optimization gives relatively minor benefits when used\n alone.  The problem is that propagation of inter-procedural\n information does not work well across functions and variables\n that are called or referenced by other compilation units (such as\n-from a dynamically linked library). We say that such functions\n+from a dynamically linked library).  We say that such functions\n are variables are @emph{externally visible}.\n \n To make the situation even more difficult, many applications\n@@ -476,7 +476,7 @@ provided with the link-time information.  In GCC, the whole\n program option (@option{-fwhole-program}) asserts that every\n function and variable defined in the current compilation\n unit is static, except for function @code{main} (note: at\n-link-time, the current unit is the union of all objects compiled\n+link time, the current unit is the union of all objects compiled\n with LTO).  Since some functions and variables need to\n be referenced externally, for example by another DSO or from an\n assembler file, GCC also provides the function and variable\n@@ -485,7 +485,7 @@ the effect of @option{-fwhole-program} on a specific symbol.\n \n The whole program mode assumptions are slightly more complex in\n C++, where inline functions in headers are put into @emph{COMDAT}\n-sections. COMDAT function and variables can be defined by\n+sections.  COMDAT function and variables can be defined by\n multiple object files and their bodies are unified at link-time\n and dynamic link-time.  COMDAT functions are changed to local only\n when their address is not taken and thus un-sharing them with a\n@@ -500,9 +500,9 @@ externally visible symbols (or alternatively an\n the @code{default}, @code{protected}, @code{hidden} and\n @code{internal} visibilities.\n \n-The most commonly used is visibility is @code{hidden}. It\n+The most commonly used is visibility is @code{hidden}.  It\n specifies that the symbol cannot be referenced from outside of\n-the current shared library. Unfortunately, this information\n+the current shared library.  Unfortunately, this information\n cannot be used directly by the link-time optimization in the\n compiler since the whole shared library also might contain\n non-LTO objects and those are not visible to the compiler.\n@@ -519,7 +519,7 @@ which symbols provided by the claimed objects are bound from the\n rest of a binary being linked.\n \n Currently, the linker plugin  works only in combination\n-with the Gold linker,  but a GNU ld implementation is under\n+with the Gold linker, but a GNU ld implementation is under\n development.\n \n GCC is designed to be independent of the rest of the toolchain\n@@ -528,7 +528,7 @@ reason it does not use the linker plugin by default.  Instead,\n the object files are examined by @command{collect2} before being\n passed to the linker and objects found to have LTO sections are\n passed to @command{lto1} first.  This mode does not work for\n-library archives. The decision on what object files from the\n+library archives.  The decision on what object files from the\n archive are needed depends on the actual linking and thus GCC\n would have to implement the linker itself.  The resolution\n information is missing too and thus GCC needs to make an educated\n@@ -557,7 +557,7 @@ bodies.  It then drives the LTRANS phase.\n @opindex fltrans\n This option runs the link-time optimizer in the\n local-transformation (LTRANS) mode, which reads in output from a\n-previous run of the LTO in WPA mode. In the LTRANS mode, LTO\n+previous run of the LTO in WPA mode.  In the LTRANS mode, LTO\n optimizes an object and produces the final assembly.\n \n @item -fltrans-output-list=@var{file}"}]}