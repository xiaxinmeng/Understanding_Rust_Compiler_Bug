{"sha": "4e263cd91b6588a43e80ffbf29b7dc664852ed4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGUyNjNjZDkxYjY1ODhhNDNlODBmZmJmMjliN2RjNjY0ODUyZWQ0YQ==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-03-05T06:29:01Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-03-05T06:29:01Z"}, "message": "* treetree.c (init_c_lex): Follow change to c-common.h.\n\nFrom-SVN: r63828", "tree": {"sha": "3ca67a8ac591650b76262e0f0bb6f61c341e55b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ca67a8ac591650b76262e0f0bb6f61c341e55b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e263cd91b6588a43e80ffbf29b7dc664852ed4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e263cd91b6588a43e80ffbf29b7dc664852ed4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e263cd91b6588a43e80ffbf29b7dc664852ed4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e263cd91b6588a43e80ffbf29b7dc664852ed4a/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc2b3526d466d990f97ab50d57f2867779994f5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2b3526d466d990f97ab50d57f2867779994f5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2b3526d466d990f97ab50d57f2867779994f5c"}], "stats": {"total": 258, "additions": 131, "deletions": 127}, "files": [{"sha": "ed490c61e0649c9f977649da013bc906199b573e", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e263cd91b6588a43e80ffbf29b7dc664852ed4a/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e263cd91b6588a43e80ffbf29b7dc664852ed4a/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=4e263cd91b6588a43e80ffbf29b7dc664852ed4a", "patch": "@@ -1,28 +1,32 @@\n+2003-03-05  Andreas Jaeger  <aj@suse.de>\n+\n+\t* treetree.c (init_c_lex): Follow change to c-common.h.\n+\n 2003-03-04  Tom Tromey  <tromey@redhat.com>\n \n \t* Make-lang.in (treelang.tags): New target.\n \n 2003-03-01  Tim Josling  <tej@melbpc.org.au>\n \n         Name clashes with rtl.h fixed.\n-\t\n+\n \t* lex.l: Tokens PLUS, MINUS, RETURN changed to tl_PLUS tl_MINUS\n \ttl_RETURN.\n \n-\t* parse.y: Ditto.\t\n-\t\n+\t* parse.y: Ditto.\n+\n 2003-02-24  Tim Josling  <tej@melbpc.org.au>\n \n \t* parse.y (my_yylex): New - ensure lexer time is charged to\n \tTV_LEX.\n \t(yylex): redefine as invocation of my_yylex which then calls\n \tflex-generated yylex.\n \t(timevar.h): include.\n-\t\n+\n 2003-02-23  Tim Josling  <tej@melbpc.org.au>\n \n         Fix garbage collection, add more error checking, force GC always.\n-\t\n+\n \t* Make-lang.in (treelang/tree1.o): Depend on treelang/treetree.h\n \t(treelang/treetree.o): Depend on  treelang/parse.h\n "}, {"sha": "aedca9d3a25286bdd7813dc561e8de75ddafd21b", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e263cd91b6588a43e80ffbf29b7dc664852ed4a/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e263cd91b6588a43e80ffbf29b7dc664852ed4a/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=4e263cd91b6588a43e80ffbf29b7dc664852ed4a", "patch": "@@ -1,4 +1,4 @@\n-/* \n+/*\n \n     TREELANG Compiler back end interface (treetree.c)\n     Called by the parser.\n@@ -9,8 +9,8 @@\n     Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n     1999, 2000, 2001, 2002, 2003, Free Software Foundation, Inc.\n \n-    This code is based on toy.c written by Richard Kenner. \n-    \n+    This code is based on toy.c written by Richard Kenner.\n+\n     It was later modified by Jonathan Bartlett whose changes have all\n     been removed (by Tim Josling).\n \n@@ -38,7 +38,7 @@\n \n     In other words, you are welcome to use, share and improve this program.\n     You are forbidden to forbid anyone else to use, share and improve\n-    what you give them.   Help stamp out software-hoarding!  \n+    what you give them.   Help stamp out software-hoarding!\n \n     ---------------------------------------------------------------------------\n \n@@ -110,9 +110,9 @@ extern char **file_names;\n #define LANG_HOOKS_INIT treelang_init\n #undef LANG_HOOKS_NAME\n #define LANG_HOOKS_NAME\t\"GNU treelang\"\n-#undef LANG_HOOKS_FINISH \n+#undef LANG_HOOKS_FINISH\n #define LANG_HOOKS_FINISH\t\ttreelang_finish\n-#undef LANG_HOOKS_DECODE_OPTION\t\n+#undef LANG_HOOKS_DECODE_OPTION\n #define LANG_HOOKS_DECODE_OPTION treelang_decode_option\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n@@ -149,25 +149,25 @@ unsigned int tree_code_char_size = 0;\n \n /* Return the tree stuff for this type TYPE_NUM.  */\n \n-tree \n-tree_code_get_type (int type_num) \n+tree\n+tree_code_get_type (int type_num)\n {\n   switch (type_num)\n     {\n     case SIGNED_CHAR:\n       return signed_char_type_node;\n-      \n+\n     case UNSIGNED_CHAR:\n       return unsigned_char_type_node;\n \n     case SIGNED_INT:\n       return integer_type_node;\n \n     case UNSIGNED_INT:\n-      return unsigned_type_node; \n+      return unsigned_type_node;\n \n     case VOID_TYPE:\n-      return void_type_node; \n+      return void_type_node;\n \n     default:\n       abort ();\n@@ -182,9 +182,9 @@ void\n tree_code_if_start (tree exp, unsigned char* filename, int lineno)\n {\n   tree cond_exp;\n-  cond_exp = build (NE_EXPR, \n-                 TREE_TYPE (exp), \n-                 exp, \n+  cond_exp = build (NE_EXPR,\n+                 TREE_TYPE (exp),\n+                 exp,\n                  build1 (CONVERT_EXPR, TREE_TYPE (exp), integer_zero_node));\n   emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n   expand_start_cond (cond_exp, /* Exit-able if nonzero.  */ 0);\n@@ -193,7 +193,7 @@ tree_code_if_start (tree exp, unsigned char* filename, int lineno)\n /* Output the code for the else of an if statement.  The else occurred\n    at line LINENO in file FILENAME.  */\n \n-void \n+void\n tree_code_if_else (unsigned char* filename, int lineno)\n {\n   emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n@@ -203,7 +203,7 @@ tree_code_if_else (unsigned char* filename, int lineno)\n /* Output the code for the end_if an if statement.  The end_if (final brace) occurred\n    at line LINENO in file FILENAME.  */\n \n-void \n+void\n tree_code_if_end (unsigned char* filename, int lineno)\n {\n   emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n@@ -214,7 +214,7 @@ tree_code_if_end (unsigned char* filename, int lineno)\n    STORAGE_CLASS, type of return variable is RET_TYPE, parameter lists\n    is PARMS, returns decl for this function.  */\n \n-tree \n+tree\n tree_code_create_function_prototype (unsigned char* chars,\n                                     unsigned int storage_class,\n                                     unsigned int ret_type,\n@@ -264,24 +264,24 @@ tree_code_create_function_prototype (unsigned char* chars,\n \n   /* Real name (optional).  */\n   SET_DECL_ASSEMBLER_NAME (fn_decl, DECL_NAME (fn_decl));\n-  \n+\n   TREE_PUBLIC (fn_decl) = 0;\n-  DECL_EXTERNAL (fn_decl) = 0; \n-  TREE_STATIC (fn_decl) = 0; \n+  DECL_EXTERNAL (fn_decl) = 0;\n+  TREE_STATIC (fn_decl) = 0;\n   switch (storage_class)\n     {\n     case STATIC_STORAGE:\n-      TREE_PUBLIC (fn_decl) = 0; \n+      TREE_PUBLIC (fn_decl) = 0;\n       break;\n \n     case EXTERNAL_DEFINITION_STORAGE:\n       TREE_PUBLIC (fn_decl) = 1;\n-      TREE_STATIC (fn_decl) = 0; \n+      TREE_STATIC (fn_decl) = 0;\n       DECL_EXTERNAL (fn_decl) = 0;\n       break;\n-  \n+\n     case EXTERNAL_REFERENCE_STORAGE:\n-      TREE_PUBLIC (fn_decl) = 0; \n+      TREE_PUBLIC (fn_decl) = 0;\n       DECL_EXTERNAL (fn_decl) = 1;\n       break;\n \n@@ -302,8 +302,8 @@ tree_code_create_function_prototype (unsigned char* chars,\n     PREV_SAVED (as created by tree_code_create_function_prototype),\n     the function is at line number LINENO in file FILENAME.  The\n     parameter details are in the lists PARMS. Returns nothing.  */\n-void \n-tree_code_create_function_initial (tree prev_saved, \n+void\n+tree_code_create_function_initial (tree prev_saved,\n                                   unsigned char* filename,\n                                   int lineno,\n                                   struct prod_token_parm_item* parms)\n@@ -315,7 +315,7 @@ tree_code_create_function_initial (tree prev_saved,\n   tree parm_decl;\n   tree parm_list;\n   tree resultdecl;\n-  struct prod_token_parm_item* this_parm; \n+  struct prod_token_parm_item* this_parm;\n   struct prod_token_parm_item* parm;\n \n   fn_decl = prev_saved;\n@@ -336,7 +336,7 @@ tree_code_create_function_initial (tree prev_saved,\n   DECL_SOURCE_LINE (fn_decl) = lineno;\n \n   /* Prepare creation of rtl for a new function.  */\n-  \n+\n   resultdecl = DECL_RESULT (fn_decl) = build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (TREE_TYPE (fn_decl)));\n   DECL_CONTEXT (DECL_RESULT (fn_decl)) = fn_decl;\n   DECL_SOURCE_FILE (resultdecl) = (const char *)filename;\n@@ -348,10 +348,10 @@ tree_code_create_function_initial (tree prev_saved,\n   parm_list = NULL_TREE;\n   for (parm = parms; parm; parm = parm->tp.par.next)\n     {\n-      parm_decl = build_decl (PARM_DECL, get_identifier \n-                              ((const char*) (parm->tp.par.variable_name)), \n+      parm_decl = build_decl (PARM_DECL, get_identifier\n+                              ((const char*) (parm->tp.par.variable_name)),\n                               get_type_for_numeric_type (parm->type));\n-      \n+\n       /* Some languages have different nominal and real types.  */\n       DECL_ARG_TYPE (parm_decl) = TREE_TYPE (parm_decl);\n       if (!DECL_ARG_TYPE (parm_decl))\n@@ -366,7 +366,7 @@ tree_code_create_function_initial (tree prev_saved,\n \n   /* Back into reverse order as the back end likes them.  */\n   parm_list = nreverse (parm_list);\n-  \n+\n   DECL_ARGUMENTS (fn_decl) = parm_list;\n \n   /* Save the decls for use when the args are referred to.  */\n@@ -389,23 +389,23 @@ tree_code_create_function_initial (tree prev_saved,\n   make_decl_rtl (fn_decl, NULL);\n \n   /* Use filename/lineno from above.  */\n-  init_function_start (fn_decl, (const char *)filename, lineno); \n-  \n+  init_function_start (fn_decl, (const char *)filename, lineno);\n+\n   /* Create rtl for startup code of function, such as saving registers.  */\n-  \n+\n   expand_function_start (fn_decl, 0);\n-  \n+\n   /* Function.c requires a push at the start of the function. that\n      looks like a bug to me but let's make it happy.  */\n-  \n+\n   (*lang_hooks.decls.pushlevel) (0);\n-  \n+\n   /* Create rtl for the start of a new scope.  */\n-  \n+\n   expand_start_bindings (2);\n \n   /* Put the parameters into the symbol table.  */\n-  \n+\n   for (first_param = param_decl = nreverse (DECL_ARGUMENTS (fn_decl));\n        param_decl;\n        param_decl = next_param)\n@@ -423,76 +423,76 @@ tree_code_create_function_initial (tree prev_saved,\n \n   /* Force it to be output, else may be solely inlined.  */\n   TREE_ADDRESSABLE (fn_decl) = 1;\n-  \n+\n   /* Stop -O3 from deleting it.  */\n   TREE_USED (fn_decl) = 1;\n \n   /* Add a new level to the debugger symbol table.  */\n-  \n+\n   (*lang_hooks.decls.pushlevel) (0);\n-  \n+\n   /* Create rtl for the start of a new scope.  */\n-  \n+\n   expand_start_bindings (0);\n-  \n+\n   emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n }\n \n /* Wrapup a function contained in file FILENAME, ending at line LINENO.  */\n-void \n+void\n tree_code_create_function_wrapup (unsigned char* filename,\n                                  int lineno)\n {\n   tree block;\n   tree fn_decl;\n \n   fn_decl = current_function_decl;\n-  \n+\n   emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n \n   /* Get completely built level from debugger symbol table.  */\n-  \n+\n   block = (*lang_hooks.decls.poplevel) (1, 0, 0);\n-  \n+\n   /* Emit rtl for end of scope.  */\n-  \n+\n   expand_end_bindings (block, 0, 1);\n-  \n+\n   /* Emit rtl for end of function.  */\n-  \n+\n   expand_function_end ((const char *)filename, lineno, 0);\n-  \n+\n   /* Pop the level.  */\n \n   block = (*lang_hooks.decls.poplevel) (1, 0, 1);\n \n   /* And attach it to the function.  */\n-  \n+\n   DECL_INITIAL (fn_decl) = block;\n-  \n+\n   /* Emit rtl for end of scope.  */\n-  \n+\n   expand_end_bindings (block, 0, 1);\n-  \n+\n   /* Call optimization and convert optimized rtl to assembly code.  */\n-  \n+\n   rest_of_compilation (fn_decl);\n-  \n+\n   /* We are not inside of any scope now.  */\n-  \n+\n   current_function_decl = NULL_TREE;\n }\n \n-/* \n-   Create a variable. \n-   \n-   The storage class is STORAGE_CLASS (eg LOCAL).   \n-   The name is CHARS/LENGTH.   \n-   The type is EXPRESSION_TYPE (eg UNSIGNED_TYPE).  \n-   The init tree is INIT.  \n+/*\n+   Create a variable.\n+\n+   The storage class is STORAGE_CLASS (eg LOCAL).\n+   The name is CHARS/LENGTH.\n+   The type is EXPRESSION_TYPE (eg UNSIGNED_TYPE).\n+   The init tree is INIT.\n */\n \n-tree \n+tree\n tree_code_create_variable (unsigned int storage_class,\n                                unsigned char* chars,\n                                unsigned int length,\n@@ -522,10 +522,10 @@ tree_code_create_variable (unsigned int storage_class,\n     DECL_INITIAL (var_decl) = build1 (CONVERT_EXPR, var_type, init);\n   else\n     DECL_INITIAL (var_decl) = NULL_TREE;\n-      \n+\n   /* 4. Compute size etc.  */\n   layout_decl (var_decl, 0);\n-      \n+\n   if (TYPE_SIZE (var_type) == 0)\n     abort (); /* Did not calculate size.  */\n \n@@ -546,37 +546,37 @@ tree_code_create_variable (unsigned int storage_class,\n       TREE_STATIC (var_decl) = 0;\n       TREE_PUBLIC (var_decl) = 0;\n       break;\n-      \n+\n     case EXTERNAL_DEFINITION_STORAGE:\n-      TREE_STATIC (var_decl) = 0; \n+      TREE_STATIC (var_decl) = 0;\n       TREE_PUBLIC (var_decl) = 1;\n       break;\n-      \n+\n     case EXTERNAL_REFERENCE_STORAGE:\n       DECL_EXTERNAL (var_decl) = 1;\n       TREE_PUBLIC (var_decl) = 0;\n       break;\n-      \n+\n     default:\n       abort ();\n     }\n-      \n+\n   /* This should really only be set if the variable is used.  */\n   TREE_USED (var_decl) = 1;\n-      \n+\n   /* Expand declaration and initial value if any.  */\n-  \n-  if (TREE_STATIC (var_decl)) \n+\n+  if (TREE_STATIC (var_decl))\n     rest_of_decl_compilation (var_decl, 0, 0, 0);\n   else\n     {\n       expand_decl (var_decl);\n       if (DECL_INITIAL (var_decl))\n         expand_decl_init (var_decl);\n     }\n-  \n+\n   return pushdecl (copy_node (var_decl));\n-  \n+\n }\n \n \n@@ -599,7 +599,7 @@ tree_code_generate_return (tree type, tree exp)\n \n   if (exp)\n     {\n-      setret = build (MODIFY_EXPR, type, DECL_RESULT (current_function_decl), \n+      setret = build (MODIFY_EXPR, type, DECL_RESULT (current_function_decl),\n                      build1 (CONVERT_EXPR, type, exp));\n       TREE_SIDE_EFFECTS (setret) = 1;\n       TREE_USED (setret) = 1;\n@@ -611,12 +611,12 @@ tree_code_generate_return (tree type, tree exp)\n /* Output the code for this expression statement CODE.  */\n \n \n-void \n-tree_code_output_expression_statement (tree code, \n+void\n+tree_code_output_expression_statement (tree code,\n                                        unsigned char* filename, int lineno)\n {\n   /* Output the line number information.  */\n-  emit_line_note ((const char *)filename, lineno); \n+  emit_line_note ((const char *)filename, lineno);\n   TREE_USED (code) = 1;\n   TREE_SIDE_EFFECTS (code) = 1;\n   expand_expr_stmt (code);\n@@ -625,7 +625,7 @@ tree_code_output_expression_statement (tree code,\n /* Return a tree for a constant integer value in the token TOK.  No\n    size checking is done.  */\n \n-tree \n+tree\n tree_code_get_integer_value (unsigned char* chars, unsigned int length)\n {\n   long long int val = 0;\n@@ -654,8 +654,8 @@ tree_code_get_integer_value (unsigned char* chars, unsigned int length)\n \n /* Return the tree for an expresssion, type EXP_TYPE (see treetree.h)\n    with tree type TYPE and with operands1 OP1, OP2 (maybe), OP3 (maybe).  */\n-tree \n-tree_code_get_expression (unsigned int exp_type, \n+tree\n+tree_code_get_expression (unsigned int exp_type,\n                           tree type, tree op1, tree op2, tree op3 ATTRIBUTE_UNUSED)\n {\n   tree ret1;\n@@ -667,30 +667,30 @@ tree_code_get_expression (unsigned int exp_type,\n       if (!op1 || !op2)\n         abort ();\n       operator = MODIFY_EXPR;\n-      ret1 = build (operator, type, \n-                 op1, \n+      ret1 = build (operator, type,\n+                 op1,\n                  build1 (CONVERT_EXPR, type, op2));\n \n       break;\n \n     case EXP_PLUS:\n       operator = PLUS_EXPR;\n       goto binary_expression;\n-      \n+\n     case EXP_MINUS:\n       operator = MINUS_EXPR;\n       goto binary_expression;\n-      \n+\n     case EXP_EQUALS:\n       operator = EQ_EXPR;\n       goto binary_expression;\n-      \n+\n       /* Expand a binary expression.  Ensure the operands are the right type.  */\n     binary_expression:\n       if (!op1 || !op2)\n         abort ();\n-      ret1  =  build (operator, type, \n-                   build1 (CONVERT_EXPR, type, op1), \n+      ret1  =  build (operator, type,\n+                   build1 (CONVERT_EXPR, type, op1),\n                    build1 (CONVERT_EXPR, type, op2));\n       break;\n \n@@ -705,7 +705,7 @@ tree_code_get_expression (unsigned int exp_type,\n       else\n         ret1 = build1 (CONVERT_EXPR, type, op1);\n       break;\n-      \n+\n     case EXP_FUNCTION_INVOCATION:\n       if (!op1 || !op2)\n         abort ();\n@@ -719,13 +719,13 @@ tree_code_get_expression (unsigned int exp_type,\n     default:\n       abort ();\n     }\n-  \n+\n   return ret1;\n }\n \n /* Init parameter list and return empty list.  */\n \n-tree \n+tree\n tree_code_init_parameters (void)\n {\n   return NULL_TREE;\n@@ -734,11 +734,11 @@ tree_code_init_parameters (void)\n /* Add a parameter EXP whose expression type is EXP_PROTO to list\n    LIST, returning the new list.  */\n \n-tree \n+tree\n tree_code_add_parameter (tree list, tree proto_exp, tree exp)\n {\n   tree new_exp;\n-  new_exp = tree_cons (NULL_TREE, \n+  new_exp = tree_cons (NULL_TREE,\n                     build1 (CONVERT_EXPR, TREE_TYPE (proto_exp), exp),\n                     NULL_TREE);\n   if (!list)\n@@ -751,45 +751,45 @@ tree_code_add_parameter (tree list, tree proto_exp, tree exp)\n tree\n get_type_for_numeric_type (unsigned int numeric_type)\n {\n-  \n+\n   int size1;\n   int sign1;\n   switch (numeric_type)\n     {\n     case VOID_TYPE:\n       return void_type_node;\n-      \n+\n     case SIGNED_INT:\n       size1 = tree_code_int_size;\n       sign1 = 1;\n       break;\n-      \n+\n     case UNSIGNED_INT:\n       size1 = tree_code_int_size;\n       sign1 = 0;\n       break;\n-      \n+\n     case SIGNED_CHAR:\n       size1 = tree_code_char_size;\n       sign1 = 1;\n       break;\n-      \n+\n     case UNSIGNED_CHAR:\n       size1 = tree_code_char_size;\n       sign1 = 0;\n       break;\n-      \n+\n     default:\n       abort ();\n     }\n \n   return tree_code_get_numeric_type (size1, sign1);\n-  \n+\n }\n \n /* Return tree representing a numeric type of size SIZE1 bits and\n    signed if SIGN1 !=  0.  */\n-tree \n+tree\n tree_code_get_numeric_type (unsigned int size1, unsigned int sign1)\n {\n   tree ret1;\n@@ -808,10 +808,10 @@ tree_code_get_numeric_type (unsigned int size1, unsigned int sign1)\n         else\n           ret1 = unsigned_char_type_node;\n       }\n-    else \n+    else\n       abort ();\n-  \n-  return ret1;    \n+\n+  return ret1;\n }\n \n /* Garbage Collection.  */\n@@ -826,7 +826,7 @@ tree_ggc_storage_always_used (void * m)\n \n   if (*mm)\n     ggc_mark (*mm);\n-} \n+}\n \n /* Following  from c-lang.c.  */\n \n@@ -857,8 +857,8 @@ check_function_format (int *status ATTRIBUTE_UNUSED,\n /* Tell the c code we are not objective C.  */\n \n int\n-objc_comptypes (tree lhs ATTRIBUTE_UNUSED, \n-                tree rhs ATTRIBUTE_UNUSED, \n+objc_comptypes (tree lhs ATTRIBUTE_UNUSED,\n+                tree rhs ATTRIBUTE_UNUSED,\n                 int reflexive ATTRIBUTE_UNUSED)\n {\n   return 0;\n@@ -932,8 +932,8 @@ cpp_create_reader (enum c_lang lang ATTRIBUTE_UNUSED)\n \n /* Should not be called for treelang.   */\n \n-const char *\n-init_c_lex (const char *filename ATTRIBUTE_UNUSED)\n+void\n+init_c_lex (void)\n {\n   abort ();\n }\n@@ -973,7 +973,7 @@ handle_format_attribute (tree *node ATTRIBUTE_UNUSED,\n                          int flags ATTRIBUTE_UNUSED,\n                          bool *no_add_attrs ATTRIBUTE_UNUSED)\n {\n-  return NULL_TREE; \n+  return NULL_TREE;\n }\n \n /* Should not be called for treelang.   */\n@@ -1000,8 +1000,8 @@ cpp_handle_option (cpp_reader *pfile ATTRIBUTE_UNUSED,\n \n /* Should not be called for treelang.   */\n \n-void \n-cpp_assert (cpp_reader * cr ATTRIBUTE_UNUSED, \n+void\n+cpp_assert (cpp_reader * cr ATTRIBUTE_UNUSED,\n             const char *s ATTRIBUTE_UNUSED)\n {\n   abort ();\n@@ -1113,18 +1113,18 @@ defer_fn (tree fn ATTRIBUTE_UNUSED)\n \n /* Should not be called for treelang.   */\n \n-cpp_options \n+cpp_options\n *cpp_get_options (cpp_reader * cr ATTRIBUTE_UNUSED)\n {\n   abort ();\n }\n \n /* Should not be called for treelang.   */\n \n-void \n+void\n cpp_define (cpp_reader * cr ATTRIBUTE_UNUSED, const char * c ATTRIBUTE_UNUSED)\n {\n-  abort ();  \n+  abort ();\n }\n \n /* Should not be called for treelang.   */\n@@ -1247,7 +1247,7 @@ treelang_init_decl_processing ()\n   tree id;\n \n   ridpointers = (tree *) ggc_calloc ((int) RID_MAX, sizeof (tree));\n-  \n+\n   for (i = 0; i < N_reswords; i++)\n     {\n       id = get_identifier (reswords[i].word);"}]}