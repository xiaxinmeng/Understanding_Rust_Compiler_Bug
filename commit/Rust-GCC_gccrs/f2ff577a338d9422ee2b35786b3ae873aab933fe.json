{"sha": "f2ff577a338d9422ee2b35786b3ae873aab933fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJmZjU3N2EzMzhkOTQyMmVlMmIzNTc4NmIzYWU4NzNhYWI5MzNmZQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-01-09T17:47:04Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-01-09T17:47:04Z"}, "message": "re PR fortran/20923 (gfortran slow for large array constructors)\n\n2010-01-09 Jerry DeLisle <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/20923\n\tPR fortran/32489\n\t* trans-array.c (gfc_conv_array_initializer): Change call to\n\tgfc_error_now to call to gfc_fatal_error.\n\t* array.c (count_elements): Whitespace. (extract_element): Whitespace.\n\t(is_constant_element): Changed name from constant_element.\n\t(gfc_constant_ac): Only use expand_construuctor for expression\n\ttypes of EXPR_ARRAY.  If expression type is EXPR_CONSTANT, no need to\n\tcall gfc_is_constant_expr.\n\t* expr.c (gfc_reduce_init_expr): Adjust conditionals and delete error\n\tmessage.\n\t* resolve.c (gfc_is_expandable_expr): New function that determiners if\n\tarray expressions should have their constructors expanded.\n\t(gfc_resolve_expr): Use new function to determine whether or not to call\n\tgfc_expand_constructor.\n\nFrom-SVN: r155769", "tree": {"sha": "faf22ebd02e6d70418500dc89807d3068c3b0ad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faf22ebd02e6d70418500dc89807d3068c3b0ad2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2ff577a338d9422ee2b35786b3ae873aab933fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ff577a338d9422ee2b35786b3ae873aab933fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ff577a338d9422ee2b35786b3ae873aab933fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ff577a338d9422ee2b35786b3ae873aab933fe/comments", "author": null, "committer": null, "parents": [{"sha": "7c0281633fd3af8f287b51f89906ce3d528216d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c0281633fd3af8f287b51f89906ce3d528216d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c0281633fd3af8f287b51f89906ce3d528216d1"}], "stats": {"total": 118, "additions": 93, "deletions": 25}, "files": [{"sha": "d6ec8aa559707de3e9bf450c0cbca8747f172613", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f2ff577a338d9422ee2b35786b3ae873aab933fe", "patch": "@@ -1,3 +1,21 @@\n+2010-01-09 Jerry DeLisle <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/20923\n+\tPR fortran/32489\n+\t* trans-array.c (gfc_conv_array_initializer): Change call to\n+\tgfc_error_now to call to gfc_fatal_error.\n+\t* array.c (count_elements): Whitespace. (extract_element): Whitespace.\n+\t(is_constant_element): Changed name from constant_element.\n+\t(gfc_constant_ac): Only use expand_construuctor for expression\n+\ttypes of EXPR_ARRAY.  If expression type is EXPR_CONSTANT, no need to\n+\tcall gfc_is_constant_expr.\n+\t* expr.c (gfc_reduce_init_expr): Adjust conditionals and delete error\n+\tmessage.\n+\t* resolve.c (gfc_is_expandable_expr): New function that determiners if\n+\tarray expressions should have their constructors expanded.\n+\t(gfc_resolve_expr): Use new function to determine whether or not to call\n+\tgfc_expand_constructor.\n+\n 2010-01-09  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/41298"}, {"sha": "7bb51003418142429575e909c48ee065c89b2073", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=f2ff577a338d9422ee2b35786b3ae873aab933fe", "patch": "@@ -1237,7 +1237,6 @@ count_elements (gfc_expr *e)\n static gfc_try\n extract_element (gfc_expr *e)\n {\n-\n   if (e->rank != 0)\n     {\t\t\t\t/* Something unextractable */\n       gfc_free_expr (e);\n@@ -1250,6 +1249,7 @@ extract_element (gfc_expr *e)\n     gfc_free_expr (e);\n \n   current_expand.extract_count++;\n+  \n   return SUCCESS;\n }\n \n@@ -1495,7 +1495,7 @@ gfc_expand_constructor (gfc_expr *e)\n    FAILURE if not so.  */\n \n static gfc_try\n-constant_element (gfc_expr *e)\n+is_constant_element (gfc_expr *e)\n {\n   int rv;\n \n@@ -1517,14 +1517,38 @@ gfc_constant_ac (gfc_expr *e)\n {\n   expand_info expand_save;\n   gfc_try rc;\n+  gfc_constructor * con;\n+  \n+  rc = SUCCESS;\n \n-  iter_stack = NULL;\n-  expand_save = current_expand;\n-  current_expand.expand_work_function = constant_element;\n+  if (e->value.constructor\n+      && e->value.constructor->expr->expr_type == EXPR_ARRAY \n+      && !e->value.constructor->iterator)\n+    {\n+      /* Expand the constructor.  */\n+      iter_stack = NULL;\n+      expand_save = current_expand;\n+      current_expand.expand_work_function = is_constant_element;\n \n-  rc = expand_constructor (e->value.constructor);\n+      rc = expand_constructor (e->value.constructor);\n+\n+      current_expand = expand_save;\n+    }\n+  else\n+    {\n+      /* No need to expand this further.  */\n+      for (con = e->value.constructor; con; con = con->next)\n+\t{\n+\t  if (con->expr->expr_type == EXPR_CONSTANT)\n+\t    continue;\n+\t  else\n+\t    {\n+\t      if (!gfc_is_constant_expr (con->expr))\n+\t\trc = FAILURE;\n+\t    }\n+\t}\n+    }\n \n-  current_expand = expand_save;\n   if (rc == FAILURE)\n     return 0;\n "}, {"sha": "8fa46d82f708557f35ab8e9ca25f87275bba850c", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f2ff577a338d9422ee2b35786b3ae873aab933fe", "patch": "@@ -2460,18 +2460,12 @@ gfc_reduce_init_expr (gfc_expr *expr)\n   if (t == FAILURE)\n     return FAILURE;\n \n-  if (expr->expr_type == EXPR_ARRAY\n-      && (gfc_check_constructor_type (expr) == FAILURE\n-      || gfc_expand_constructor (expr) == FAILURE))\n-    return FAILURE;\n-\n-  /* Not all inquiry functions are simplified to constant expressions\n-     so it is necessary to call check_inquiry again.  */ \n-  if (!gfc_is_constant_expr (expr) && check_inquiry (expr, 1) != MATCH_YES\n-      && !gfc_in_match_data ())\n+  if (expr->expr_type == EXPR_ARRAY)\n     {\n-      gfc_error (\"Initialization expression didn't reduce %C\");\n-      return FAILURE;\n+      if (gfc_check_constructor_type (expr) == FAILURE)\n+\treturn FAILURE;\n+      if (gfc_expand_constructor (expr) == FAILURE)\n+\treturn FAILURE;\n     }\n \n   return SUCCESS;"}, {"sha": "7321c0dd7675de5a83426cf9332f597fdff73595", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f2ff577a338d9422ee2b35786b3ae873aab933fe", "patch": "@@ -5516,6 +5516,32 @@ resolve_expr_ppc (gfc_expr* e)\n }\n \n \n+static bool\n+gfc_is_expandable_expr (gfc_expr *e)\n+{\n+  gfc_constructor *con;\n+\n+  if (e->expr_type == EXPR_ARRAY)\n+    {\n+      /* Traverse the constructor looking for variables that are flavor\n+\t parameter.  Parameters must be expanded since they are fully used at\n+\t compile time.  */\n+      for (con = e->value.constructor; con; con = con->next)\n+\t{\n+\t  if (con->expr->expr_type == EXPR_VARIABLE\n+\t  && con->expr->symtree\n+\t  && (con->expr->symtree->n.sym->attr.flavor == FL_PARAMETER\n+\t      || con->expr->symtree->n.sym->attr.flavor == FL_VARIABLE))\n+\t    return true;\n+\t  if (con->expr->expr_type == EXPR_ARRAY\n+\t    && gfc_is_expandable_expr (con->expr))\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* Resolve an expression.  That is, make sure that types of operands agree\n    with their operators, intrinsic operators are converted to function calls\n    for overloaded types and unresolved function references are resolved.  */\n@@ -5582,14 +5608,20 @@ gfc_resolve_expr (gfc_expr *e)\n       if (t == SUCCESS)\n \t{\n \t  expression_rank (e);\n-\t  gfc_expand_constructor (e);\n+\t  if (gfc_is_constant_expr (e) || gfc_is_expandable_expr (e))\n+\t    gfc_expand_constructor (e);\n \t}\n \n       /* This provides the opportunity for the length of constructors with\n \t character valued function elements to propagate the string length\n \t to the expression.  */\n       if (t == SUCCESS && e->ts.type == BT_CHARACTER)\n-\tt = gfc_resolve_character_array_constructor (e);\n+        {\n+\t  /* For efficiency, we call gfc_expand_constructor for BT_CHARACTER\n+\t     here rather then add a duplicate test for it above.  */ \n+\t  gfc_expand_constructor (e);\n+\t  t = gfc_resolve_character_array_constructor (e);\n+\t}\n \n       break;\n "}, {"sha": "063b26297a70b8340384ce2a29f0228703a8c05d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ff577a338d9422ee2b35786b3ae873aab933fe/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f2ff577a338d9422ee2b35786b3ae873aab933fe", "patch": "@@ -4109,11 +4109,11 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n             {\n               /* Problems occur when we get something like\n                  integer :: a(lots) = (/(i, i=1, lots)/)  */\n-              gfc_error_now (\"The number of elements in the array constructor \"\n-\t\t\t     \"at %L requires an increase of the allowed %d \"\n-\t\t\t     \"upper limit.   See -fmax-array-constructor \"\n-\t\t\t     \"option\", &expr->where,\n-\t\t\t     gfc_option.flag_max_array_constructor);\n+              gfc_fatal_error (\"The number of elements in the array constructor \"\n+\t\t\t       \"at %L requires an increase of the allowed %d \"\n+\t\t\t       \"upper limit.   See -fmax-array-constructor \"\n+\t\t\t       \"option\", &expr->where,\n+\t\t\t       gfc_option.flag_max_array_constructor);\n \t      return NULL_TREE;\n \t    }\n           if (mpz_cmp_si (c->n.offset, 0) != 0)"}]}