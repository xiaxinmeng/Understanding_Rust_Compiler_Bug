{"sha": "d96b8556e569a1ccce36ef990e167031d07a661a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk2Yjg1NTZlNTY5YTFjY2NlMzZlZjk5MGUxNjcwMzFkMDdhNjYxYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-31T09:19:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-31T09:19:06Z"}, "message": "reassoc: Optimize x > 0x1fff || y > 0x1fff into (x | y) > 0x1fff [PR56719]\n\nThe following patch adds an optimization mentioned in PR56719 #c8.\nWe already have the x != 0 && y != 0 && z != 0 into (x | y | z) != 0\nand x != -1 && y != -1 && y != -1 into (x & y & z) != -1\noptimizations, this patch just extends that to\nx < C && y < C && z < C for power of two constants C into\n(x | y | z) < C (for unsigned comparisons).\n\nI didn't want to create too many buckets (there can be TYPE_PRECISION such\nconstants), so the patch instead just uses one buckets for all such\nconstants and loops over that bucket up to TYPE_PRECISION times.\n\n2020-12-31  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/56719\n\t* tree-ssa-reassoc.c (optimize_range_tests_cmp_bitwise): Also optimize\n\tx < C && y < C && z < C when C is a power of two constant into\n\t(x | y | z) < C.\n\n\t* gcc.dg/tree-ssa/pr56719.c: New test.", "tree": {"sha": "d05139a38775fcc9e673e0d1b808dbc60da0b897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d05139a38775fcc9e673e0d1b808dbc60da0b897"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d96b8556e569a1ccce36ef990e167031d07a661a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d96b8556e569a1ccce36ef990e167031d07a661a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d96b8556e569a1ccce36ef990e167031d07a661a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d96b8556e569a1ccce36ef990e167031d07a661a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1af3f4a2893203492cce59b72eff3f7bb4aef04c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af3f4a2893203492cce59b72eff3f7bb4aef04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af3f4a2893203492cce59b72eff3f7bb4aef04c"}], "stats": {"total": 120, "additions": 110, "deletions": 10}, "files": [{"sha": "5030b69541774aaf07176b65767f63d2e398e899", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr56719.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d96b8556e569a1ccce36ef990e167031d07a661a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr56719.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d96b8556e569a1ccce36ef990e167031d07a661a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr56719.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr56719.c?ref=d96b8556e569a1ccce36ef990e167031d07a661a", "patch": "@@ -0,0 +1,33 @@\n+/* PR tree-optimization/56719 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \" > 1023;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" > 2047;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" > 8191;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" <= 1023;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" <= 4095;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" <= 8191;\" 1 \"optimized\" } } */\n+\n+int\n+f1 (int x, int y)\n+{\n+  return x > 0x3ffU || y > 0x3ffU;\n+}\n+\n+int\n+f2 (int x, int y, int z, unsigned w)\n+{\n+  return x > 0x1fffU || z > 0x7ffU || w > 0x7ffU || y > 0x1fffU;\n+}\n+\n+int\n+f3 (int x, int y)\n+{\n+  return x <= 0x3ffU && y <= 0x3ffU;\n+}\n+\n+int\n+f4 (int x, int y, unsigned z, unsigned w)\n+{\n+  return x <= 0x1fffU && z <= 0xfff && w <= 0xfff && y <= 0x1fffU;\n+}"}, {"sha": "4bc9004ded754fa95bb95d1d3679280fd0304146", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 77, "deletions": 10, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d96b8556e569a1ccce36ef990e167031d07a661a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d96b8556e569a1ccce36ef990e167031d07a661a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=d96b8556e569a1ccce36ef990e167031d07a661a", "patch": "@@ -3317,7 +3317,9 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n }\n \n /* Optimize x != 0 && y != 0 && z != 0 into (x | y | z) != 0\n-   and similarly x != -1 && y != -1 && y != -1 into (x & y & z) != -1.  */\n+   and similarly x != -1 && y != -1 && y != -1 into (x & y & z) != -1.\n+   Also, handle x < C && y < C && z < C where C is power of two as\n+   (x | y | z) < C.  */\n \n static bool\n optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,\n@@ -3333,20 +3335,44 @@ optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,\n \n   for (i = first; i < length; i++)\n     {\n+      int idx;\n+\n       if (ranges[i].exp == NULL_TREE\n \t  || TREE_CODE (ranges[i].exp) != SSA_NAME\n \t  || !ranges[i].in_p\n \t  || TYPE_PRECISION (TREE_TYPE (ranges[i].exp)) <= 1\n-\t  || TREE_CODE (TREE_TYPE (ranges[i].exp)) == BOOLEAN_TYPE\n-\t  || ranges[i].low == NULL_TREE\n-\t  || ranges[i].low != ranges[i].high)\n+\t  || TREE_CODE (TREE_TYPE (ranges[i].exp)) == BOOLEAN_TYPE)\n \tcontinue;\n \n-      bool zero_p = integer_zerop (ranges[i].low);\n-      if (!zero_p && !integer_all_onesp (ranges[i].low))\n+      if (ranges[i].low != NULL_TREE\n+\t  && ranges[i].high != NULL_TREE\n+\t  && tree_int_cst_equal (ranges[i].low, ranges[i].high))\n+\t{\n+\t  idx = !integer_zerop (ranges[i].low);\n+\t  if (idx && !integer_all_onesp (ranges[i].low))\n+\t    continue;\n+\t}\n+      else if (ranges[i].high != NULL_TREE\n+\t       && TREE_CODE (ranges[i].high) == INTEGER_CST)\n+\t{\n+\t  wide_int w = wi::to_wide (ranges[i].high);\n+\t  int prec = TYPE_PRECISION (TREE_TYPE (ranges[i].exp));\n+\t  int l = wi::clz (w);\n+\t  idx = 2;\n+\t  if (l <= 0\n+\t      || l >= prec\n+\t      || w != wi::mask (prec - l, false, prec))\n+\t    continue;\n+\t  if (!((TYPE_UNSIGNED (TREE_TYPE (ranges[i].exp))\n+\t\t && ranges[i].low == NULL_TREE)\n+\t\t|| (ranges[i].low\n+\t\t    && integer_zerop (ranges[i].low))))\n+\t    continue;\n+\t}\n+      else\n \tcontinue;\n \n-      b = TYPE_PRECISION (TREE_TYPE (ranges[i].exp)) * 2 + !zero_p;\n+      b = TYPE_PRECISION (TREE_TYPE (ranges[i].exp)) * 3 + idx;\n       if (buckets.length () <= b)\n \tbuckets.safe_grow_cleared (b + 1, true);\n       if (chains.length () <= (unsigned) i)\n@@ -3359,6 +3385,44 @@ optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,\n     if (i && chains[i - 1])\n       {\n \tint j, k = i;\n+\tif ((b % 3) == 2)\n+\t  {\n+\t    /* When ranges[X - 1].high + 1 is a power of two,\n+\t       we need to process the same bucket up to\n+\t       precision - 1 times, each time split the entries\n+\t       with the same high bound into one chain and the\n+\t       rest into another one to be processed later.  */\n+\t    int this_prev = i;\n+\t    int other_prev = 0;\n+\t    for (j = chains[i - 1]; j; j = chains[j - 1])\n+\t      {\n+\t\tif (tree_int_cst_equal (ranges[i - 1].high,\n+\t\t\t\t\tranges[j - 1].high))\n+\t\t  {\n+\t\t    chains[this_prev - 1] = j;\n+\t\t    this_prev = j;\n+\t\t  }\n+\t\telse if (other_prev == 0)\n+\t\t  {\n+\t\t    buckets[b] = j;\n+\t\t    other_prev = j;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    chains[other_prev - 1] = j;\n+\t\t    other_prev = j;\n+\t\t  }\n+\t      }\n+\t    chains[this_prev - 1] = 0;\n+\t    if (other_prev)\n+\t      chains[other_prev - 1] = 0;\n+\t    if (chains[i - 1] == 0)\n+\t      {\n+\t\tif (other_prev)\n+\t\t  b--;\n+\t\tcontinue;\n+\t      }\n+\t  }\n \tfor (j = chains[i - 1]; j; j = chains[j - 1])\n \t  {\n \t    gimple *gk = SSA_NAME_DEF_STMT (ranges[k - 1].exp);\n@@ -3426,19 +3490,22 @@ optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,\n \t\texp = gimple_assign_lhs (g);\n \t      }\n \t    g = gimple_build_assign (make_ssa_name (id >= l ? type1 : type2),\n-\t\t\t\t     (b & 1) ? BIT_AND_EXPR : BIT_IOR_EXPR,\n-\t\t\t\t     op, exp);\n+\t\t\t\t     (b % 3) == 1\n+\t\t\t\t     ? BIT_AND_EXPR : BIT_IOR_EXPR, op, exp);\n \t    gimple_seq_add_stmt_without_update (&seq, g);\n \t    op = gimple_assign_lhs (g);\n \t  }\n \tcandidates.pop ();\n \tif (update_range_test (&ranges[k - 1], NULL, candidates.address (),\n \t\t\t       candidates.length (), opcode, ops, op,\n \t\t\t       seq, true, ranges[k - 1].low,\n-\t\t\t       ranges[k - 1].low, strict_overflow_p))\n+\t\t\t       ranges[k - 1].high, strict_overflow_p))\n \t  any_changes = true;\n \telse\n \t  gimple_seq_discard (seq);\n+\tif ((b % 3) == 2 && buckets[b] != i)\n+\t  /* There is more work to do for this bucket.  */\n+\t  b--;\n       }\n \n   return any_changes;"}]}