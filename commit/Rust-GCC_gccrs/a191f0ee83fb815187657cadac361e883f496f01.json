{"sha": "a191f0ee83fb815187657cadac361e883f496f01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE5MWYwZWU4M2ZiODE1MTg3NjU3Y2FkYWMzNjFlODgzZjQ5NmYwMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-18T17:55:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-18T17:55:38Z"}, "message": "machmode.def: Add BImode.\n\n        * machmode.def: Add BImode.  Add a column for bitsize.\n        * machmode.h (DEF_MACHMODE): Adjust for extra column.\n        (GET_MODE_BITSIZE): Use it.\n        * rtl.c (DEF_MACHMODE): Adjust for extra column.\n        (mode_bitsize): New.\n        (mode_mask_array): Use bitsize.\n        * combine.c (combine_simplify_rtx): Require inner and outer\n        modes to match on nonzero_bits optimizations.\n\nFrom-SVN: r36501", "tree": {"sha": "15eac562db9eb775cc5d5a1937b5f0e2fb7f5ce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15eac562db9eb775cc5d5a1937b5f0e2fb7f5ce0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a191f0ee83fb815187657cadac361e883f496f01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a191f0ee83fb815187657cadac361e883f496f01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a191f0ee83fb815187657cadac361e883f496f01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a191f0ee83fb815187657cadac361e883f496f01/comments", "author": null, "committer": null, "parents": [{"sha": "42d5d0f171ae6a0f933ed7d6cf3adeb653db19c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42d5d0f171ae6a0f933ed7d6cf3adeb653db19c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42d5d0f171ae6a0f933ed7d6cf3adeb653db19c5"}], "stats": {"total": 211, "additions": 124, "deletions": 87}, "files": [{"sha": "403109833e762c7b917da6da3808c3a6cc6aeb04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a191f0ee83fb815187657cadac361e883f496f01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a191f0ee83fb815187657cadac361e883f496f01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a191f0ee83fb815187657cadac361e883f496f01", "patch": "@@ -1,3 +1,14 @@\n+2000-09-18  Richard Henderson  <rth@cygnus.com>\n+\n+\t* machmode.def: Add BImode.  Add a column for bitsize.\n+\t* machmode.h (DEF_MACHMODE): Adjust for extra column.\n+\t(GET_MODE_BITSIZE): Use it.\n+\t* rtl.c (DEF_MACHMODE): Adjust for extra column.\n+\t(mode_bitsize): New.\n+\t(mode_mask_array): Use bitsize.\n+\t* combine.c (combine_simplify_rtx): Require inner and outer\n+\tmodes to match on nonzero_bits optimizations.\n+\n 2000-09-18  Bernd Schmidt  <bernds@redhat.co.uk>\n \n \t* reload1.c (forget_old_reloads_1): If a hard reg is stored, clear\n@@ -86,8 +97,8 @@\n \n \t* configure.in: Define _GNU_SOURCE only when using the GNU C\n \tLibrary.\n-        * configure: Regenerated.\n-        * config.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* config.in: Regenerated.\n \n 2000-09-17  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -141,15 +152,15 @@ Sun Sep 17 10:46:17 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2000-09-17  Bernd Schmidt  <bernds@redhat.co.uk>\n \n-        * expr.h (emit_library_call, emit_library_call_value): Delete\n+\t* expr.h (emit_library_call, emit_library_call_value): Delete\n \tdeclarations.\n \t* rtl.h (enum libcall_type): New.\n \t(emit_library_call, emit_library_call_value): Change fn_type arg to\n-        be of type enum libcall_type.\n+\tbe of type enum libcall_type.\n \t* calls.c: Likewise for the function definitions.  Several callers\n \tthroughout changed to use the new enumeration appropriately.\n \t(emit_library_call_value_1): Likewise.  Put back code to make libcall\n-        blocks of equal form, but only use it for the two new higher\n+\tblocks of equal form, but only use it for the two new higher\n \tenumeration values.\n \n 2000-09-16  Mark Mitchell  <mark@codesourcery.com>\n@@ -611,7 +622,7 @@ Wed Sep 13 02:31:23 EDT 2000  John Wehle  (john@feith.com)\n \n 2000-09-13  Michael Hayes  <mhayes@cygnus.com>\n \n-        * loop.c (note_set_pseudo_multiple_uses): Correct.\n+\t* loop.c (note_set_pseudo_multiple_uses): Correct.\n \n 2000-09-12  Jim Wilson  <wilson@cygnus.com>\n "}, {"sha": "be73be30d7cc0848649f002651211354c90b12bd", "filename": "gcc/combine.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a191f0ee83fb815187657cadac361e883f496f01/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a191f0ee83fb815187657cadac361e883f496f01/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a191f0ee83fb815187657cadac361e883f496f01", "patch": "@@ -4347,13 +4347,16 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \n \t  if (STORE_FLAG_VALUE == 1\n \t      && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n-\t      && op1 == const0_rtx && nonzero_bits (op0, mode) == 1)\n+\t      && op1 == const0_rtx\n+\t      && mode == GET_MODE (op0)\n+\t      && nonzero_bits (op0, mode) == 1)\n \t    return gen_lowpart_for_combine (mode,\n \t\t\t\t\t    expand_compound_operation (op0));\n \n \t  else if (STORE_FLAG_VALUE == 1\n \t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n+\t\t   && mode == GET_MODE (op0)\n \t\t   && (num_sign_bit_copies (op0, mode)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n@@ -4365,6 +4368,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  else if (STORE_FLAG_VALUE == 1\n \t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n+\t\t   && mode == GET_MODE (op0)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n@@ -4376,6 +4380,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  else if (STORE_FLAG_VALUE == 1\n \t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n+\t\t   && mode == GET_MODE (op0)\n \t\t   && (num_sign_bit_copies (op0, mode)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n@@ -4396,6 +4401,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  else if (STORE_FLAG_VALUE == -1\n \t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n+\t\t   && mode == GET_MODE (op0)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n@@ -4406,6 +4412,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  else if (STORE_FLAG_VALUE == -1\n \t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n+\t\t   && mode == GET_MODE (op0)\n \t\t   && (num_sign_bit_copies (op0, mode)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n@@ -4418,6 +4425,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  else if (STORE_FLAG_VALUE == -1\n \t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n+\t\t   && mode == GET_MODE (op0)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);"}, {"sha": "4df4da771cc68388c45dfda95c3b84bb08388335", "filename": "gcc/machmode.def", "status": "modified", "additions": 70, "deletions": 68, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a191f0ee83fb815187657cadac361e883f496f01/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a191f0ee83fb815187657cadac361e883f496f01/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=a191f0ee83fb815187657cadac361e883f496f01", "patch": "@@ -48,98 +48,100 @@ Boston, MA 02111-1307, USA.  */\n    MODE_VECTOR_INT, MODE_VECTOR_FLOAT - vector\n    MODE_RANDOM - anything else\n \n-   Fourth argument is the relative size of the object, in bytes.\n+   Fourth argument is the relative size of the object, in bits,\n+   so we can have modes smaller than 1 byte.\n+\n+   Fifth argument is the relative size of the object, in bytes.\n    It is zero when the size is meaningless or not determined.\n    A byte's size is determined by BITS_PER_UNIT in tm.h. \n \n-\n-   Fifth arg is the relative size of subunits of the object.\n+   Sixth arg is the relative size of subunits of the object.\n    It is same as the fourth argument except for complexes,\n    since they are really made of two equal size subunits.\n \n-   Sixth arg is next wider natural mode of the same class.\n+   Seventh arg is next wider natural mode of the same class.\n    0 if there is none.  */\n \n /* VOIDmode is used when no mode needs to be specified,\n    as for example on CONST_INT RTL expressions.  */\n-DEF_MACHMODE (VOIDmode, \"VOID\", MODE_RANDOM, 0, 0, VOIDmode)\n-\n-DEF_MACHMODE (PQImode, \"PQI\", MODE_PARTIAL_INT, 1, 1, PHImode)\n-DEF_MACHMODE (QImode, \"QI\", MODE_INT, 1, 1, HImode)\t\t/* int types */\n-DEF_MACHMODE (PHImode, \"PHI\", MODE_PARTIAL_INT, 2, 2, PSImode)\n-DEF_MACHMODE (HImode, \"HI\", MODE_INT, 2, 2, SImode)\n-/* Pointers on some machines use this type to distinguish them from ints.\n-   Useful if a pointer is 4 bytes but has some bits that are not significant,\n-   so it is really not quite as wide as an integer.  */\n-DEF_MACHMODE (PSImode, \"PSI\", MODE_PARTIAL_INT, 4, 4, PDImode)\n-DEF_MACHMODE (SImode, \"SI\", MODE_INT, 4, 4, DImode)\n-DEF_MACHMODE (PDImode, \"PDI\", MODE_PARTIAL_INT, 8, 8, VOIDmode)\n-DEF_MACHMODE (DImode, \"DI\", MODE_INT, 8, 8, TImode)\n-DEF_MACHMODE (TImode, \"TI\", MODE_INT, 16, 16, OImode)\n-DEF_MACHMODE (OImode, \"OI\", MODE_INT, 32, 32, VOIDmode)\n-\n-DEF_MACHMODE (QFmode, \"QF\", MODE_FLOAT, 1, 1, HFmode)\n-DEF_MACHMODE (HFmode, \"HF\", MODE_FLOAT, 2, 2, TQFmode)\n-DEF_MACHMODE (TQFmode, \"TQF\", MODE_FLOAT, 3, 3, SFmode)  /* MIL-STD-1750A */\n-DEF_MACHMODE (SFmode, \"SF\", MODE_FLOAT, 4, 4, DFmode)\n-DEF_MACHMODE (DFmode, \"DF\", MODE_FLOAT, 8, 8, XFmode)\n-DEF_MACHMODE (XFmode, \"XF\", MODE_FLOAT, 12, 12, TFmode)   /* IEEE extended */\n-DEF_MACHMODE (TFmode, \"TF\", MODE_FLOAT, 16, 16, VOIDmode)\n+DEF_MACHMODE (VOIDmode, \"VOID\", MODE_RANDOM, 0, 0, 0, VOIDmode)\n+\n+DEF_MACHMODE (BImode, \"BI\", MODE_INT, 1, 1, 1, QImode)\n+DEF_MACHMODE (QImode, \"QI\", MODE_INT, 8, 1, 1, HImode)\n+DEF_MACHMODE (HImode, \"HI\", MODE_INT, 16, 2, 2, SImode)\n+DEF_MACHMODE (SImode, \"SI\", MODE_INT, 32, 4, 4, DImode)\n+DEF_MACHMODE (DImode, \"DI\", MODE_INT, 64, 8, 8, TImode)\n+DEF_MACHMODE (TImode, \"TI\", MODE_INT, 128, 16, 16, OImode)\n+DEF_MACHMODE (OImode, \"OI\", MODE_INT, 256, 32, 32, VOIDmode)\n+\n+/* Pointers on some machines use these types to distinguish them from\n+   ints.  Useful if a pointer is 4 bytes but has some bits that are\n+   not significant, so it is really not quite as wide as an integer.  */\n+DEF_MACHMODE (PQImode, \"PQI\", MODE_PARTIAL_INT, 8, 1, 1, PHImode)\n+DEF_MACHMODE (PHImode, \"PHI\", MODE_PARTIAL_INT, 16, 2, 2, PSImode)\n+DEF_MACHMODE (PSImode, \"PSI\", MODE_PARTIAL_INT, 32, 4, 4, PDImode)\n+DEF_MACHMODE (PDImode, \"PDI\", MODE_PARTIAL_INT, 64, 8, 8, VOIDmode)\n+\n+DEF_MACHMODE (QFmode, \"QF\", MODE_FLOAT, 8, 1, 1, HFmode)\n+DEF_MACHMODE (HFmode, \"HF\", MODE_FLOAT, 16, 2, 2, TQFmode)\n+DEF_MACHMODE (TQFmode, \"TQF\", MODE_FLOAT, 24, 3, 3, SFmode) /* MIL-STD-1750A */\n+DEF_MACHMODE (SFmode, \"SF\", MODE_FLOAT, 32, 4, 4, DFmode)\n+DEF_MACHMODE (DFmode, \"DF\", MODE_FLOAT, 64, 8, 8, XFmode)\n+DEF_MACHMODE (XFmode, \"XF\", MODE_FLOAT, 96, 12, 12, TFmode) /* IEEE extended */\n+DEF_MACHMODE (TFmode, \"TF\", MODE_FLOAT, 128, 16, 16, VOIDmode)\n \n /* Complex modes.  */\n-DEF_MACHMODE (QCmode, \"QC\", MODE_COMPLEX_FLOAT, 2, 1, HCmode)\n-DEF_MACHMODE (HCmode, \"HC\", MODE_COMPLEX_FLOAT, 4, 2, SCmode)\n-DEF_MACHMODE (SCmode, \"SC\", MODE_COMPLEX_FLOAT, 8, 4, DCmode)\n-DEF_MACHMODE (DCmode, \"DC\", MODE_COMPLEX_FLOAT, 16, 8, XCmode)\n-DEF_MACHMODE (XCmode, \"XC\", MODE_COMPLEX_FLOAT, 24, 12, TCmode)\n-DEF_MACHMODE (TCmode, \"TC\", MODE_COMPLEX_FLOAT, 32, 16, VOIDmode)\n-\n-DEF_MACHMODE (CQImode, \"CQI\", MODE_COMPLEX_INT, 2, 1, CHImode)\n-DEF_MACHMODE (CHImode, \"CHI\", MODE_COMPLEX_INT, 4, 2, CSImode)\n-DEF_MACHMODE (CSImode, \"CSI\", MODE_COMPLEX_INT, 8, 4, CDImode)\n-DEF_MACHMODE (CDImode, \"CDI\", MODE_COMPLEX_INT, 16, 8, CTImode)\n-DEF_MACHMODE (CTImode, \"CTI\", MODE_COMPLEX_INT, 32, 16, COImode)\n-DEF_MACHMODE (COImode, \"COI\", MODE_COMPLEX_INT, 64, 32, VOIDmode)\n+DEF_MACHMODE (QCmode, \"QC\", MODE_COMPLEX_FLOAT, 16, 2, 1, HCmode)\n+DEF_MACHMODE (HCmode, \"HC\", MODE_COMPLEX_FLOAT, 32, 4, 2, SCmode)\n+DEF_MACHMODE (SCmode, \"SC\", MODE_COMPLEX_FLOAT, 64, 8, 4, DCmode)\n+DEF_MACHMODE (DCmode, \"DC\", MODE_COMPLEX_FLOAT, 128, 16, 8, XCmode)\n+DEF_MACHMODE (XCmode, \"XC\", MODE_COMPLEX_FLOAT, 192, 24, 12, TCmode)\n+DEF_MACHMODE (TCmode, \"TC\", MODE_COMPLEX_FLOAT, 256, 32, 16, VOIDmode)\n+\n+DEF_MACHMODE (CQImode, \"CQI\", MODE_COMPLEX_INT, 16, 2, 1, CHImode)\n+DEF_MACHMODE (CHImode, \"CHI\", MODE_COMPLEX_INT, 32, 4, 2, CSImode)\n+DEF_MACHMODE (CSImode, \"CSI\", MODE_COMPLEX_INT, 64, 8, 4, CDImode)\n+DEF_MACHMODE (CDImode, \"CDI\", MODE_COMPLEX_INT, 128, 16, 8, CTImode)\n+DEF_MACHMODE (CTImode, \"CTI\", MODE_COMPLEX_INT, 256, 32, 16, COImode)\n+DEF_MACHMODE (COImode, \"COI\", MODE_COMPLEX_INT, 512, 64, 32, VOIDmode)\n \n /* Vector modes.  */\n-/* There are no V1xx vector modes.  These are equivalent to normal non-vector\n-   modes.  */\n-DEF_MACHMODE (V2QImode, \"V2QI\", MODE_VECTOR_INT, 2, 1, VOIDmode)\n-DEF_MACHMODE (V2HImode, \"V2HI\", MODE_VECTOR_INT, 4, 2, VOIDmode)\n-DEF_MACHMODE (V2SImode, \"V2SI\", MODE_VECTOR_INT, 8, 4, VOIDmode)\n-DEF_MACHMODE (V2DImode, \"V2DI\", MODE_VECTOR_INT, 16, 8, VOIDmode)\n+/* There are no V1xx vector modes.  These are equivalent to normal\n+   scalar modes.  */\n+DEF_MACHMODE (V2QImode, \"V2QI\", MODE_VECTOR_INT, 16, 2, 1, VOIDmode)\n+DEF_MACHMODE (V2HImode, \"V2HI\", MODE_VECTOR_INT, 32, 4, 2, VOIDmode)\n+DEF_MACHMODE (V2SImode, \"V2SI\", MODE_VECTOR_INT, 64, 8, 4, VOIDmode)\n+DEF_MACHMODE (V2DImode, \"V2DI\", MODE_VECTOR_INT, 128, 16, 8, VOIDmode)\n \n-DEF_MACHMODE (V4QImode, \"V4QI\", MODE_VECTOR_INT, 4, 1, VOIDmode)\n-DEF_MACHMODE (V4HImode, \"V4HI\", MODE_VECTOR_INT, 8, 2, VOIDmode)\n-DEF_MACHMODE (V4SImode, \"V4SI\", MODE_VECTOR_INT, 16, 4, VOIDmode)\n-DEF_MACHMODE (V4DImode, \"V4DI\", MODE_VECTOR_INT, 32, 8, VOIDmode)\n+DEF_MACHMODE (V4QImode, \"V4QI\", MODE_VECTOR_INT, 32, 4, 1, VOIDmode)\n+DEF_MACHMODE (V4HImode, \"V4HI\", MODE_VECTOR_INT, 64, 8, 2, VOIDmode)\n+DEF_MACHMODE (V4SImode, \"V4SI\", MODE_VECTOR_INT, 128, 16, 4, VOIDmode)\n+DEF_MACHMODE (V4DImode, \"V4DI\", MODE_VECTOR_INT, 256, 32, 8, VOIDmode)\n \n-DEF_MACHMODE (V8QImode, \"V8QI\", MODE_VECTOR_INT, 8, 1, VOIDmode)\n-DEF_MACHMODE (V8HImode, \"V8HI\", MODE_VECTOR_INT, 16, 2, VOIDmode)\n-DEF_MACHMODE (V8SImode, \"V8SI\", MODE_VECTOR_INT, 32, 4, VOIDmode)\n-DEF_MACHMODE (V8DImode, \"V8DI\", MODE_VECTOR_INT, 64, 8, VOIDmode)\n+DEF_MACHMODE (V8QImode, \"V8QI\", MODE_VECTOR_INT, 64, 8, 1, VOIDmode)\n+DEF_MACHMODE (V8HImode, \"V8HI\", MODE_VECTOR_INT, 128, 16, 2, VOIDmode)\n+DEF_MACHMODE (V8SImode, \"V8SI\", MODE_VECTOR_INT, 256, 32, 4, VOIDmode)\n+DEF_MACHMODE (V8DImode, \"V8DI\", MODE_VECTOR_INT, 512, 64, 8, VOIDmode)\n \n-DEF_MACHMODE (V2SFmode, \"V2SF\", MODE_VECTOR_FLOAT, 8, 4, VOIDmode)\n-DEF_MACHMODE (V2DFmode, \"V2DF\", MODE_VECTOR_FLOAT, 16, 8, VOIDmode)\n+DEF_MACHMODE (V2SFmode, \"V2SF\", MODE_VECTOR_FLOAT, 64, 8, 4, VOIDmode)\n+DEF_MACHMODE (V2DFmode, \"V2DF\", MODE_VECTOR_FLOAT, 128, 16, 8, VOIDmode)\n \n-DEF_MACHMODE (V4SFmode, \"V4SF\", MODE_VECTOR_FLOAT, 16, 4, VOIDmode)\n-DEF_MACHMODE (V4DFmode, \"V4DF\", MODE_VECTOR_FLOAT, 32, 8, VOIDmode)\n+DEF_MACHMODE (V4SFmode, \"V4SF\", MODE_VECTOR_FLOAT, 128, 16, 4, VOIDmode)\n+DEF_MACHMODE (V4DFmode, \"V4DF\", MODE_VECTOR_FLOAT, 256, 32, 8, VOIDmode)\n \n-DEF_MACHMODE (V8SFmode, \"V8SF\", MODE_VECTOR_FLOAT, 32, 4, VOIDmode)\n-DEF_MACHMODE (V8DFmode, \"V8DF\", MODE_VECTOR_FLOAT, 64, 8, VOIDmode)\n+DEF_MACHMODE (V8SFmode, \"V8SF\", MODE_VECTOR_FLOAT, 256, 32, 4, VOIDmode)\n+DEF_MACHMODE (V8DFmode, \"V8DF\", MODE_VECTOR_FLOAT, 512, 64, 8, VOIDmode)\n \n /* BLKmode is used for structures, arrays, etc.\n    that fit no more specific mode.  */\n-DEF_MACHMODE (BLKmode, \"BLK\", MODE_RANDOM, 0, 0, VOIDmode)\n+DEF_MACHMODE (BLKmode, \"BLK\", MODE_RANDOM, 0, 0, 0, VOIDmode)\n \n-/* The modes for representing the condition codes come last.  CCmode is\n-   always defined.  Additional modes for the condition code can be specified\n-   in the EXTRA_CC_MODES macro.\n-   All MODE_CC modes are the same width as SImode and have VOIDmode as their\n-   next wider mode.\n-*/\n+/* The modes for representing the condition codes come last.  CCmode\n+   is always defined.  Additional modes for the condition code can be\n+   specified in the EXTRA_CC_MODES macro.  All MODE_CC modes are the\n+   same width as SImode and have VOIDmode as their next wider mode.  */\n \n-#define CC(E, M)  DEF_MACHMODE (E, M, MODE_CC, 4, 4, VOIDmode)\n+#define CC(E, M)  DEF_MACHMODE (E, M, MODE_CC, 32, 4, 4, VOIDmode)\n \n CC (CCmode, \"CC\")\n "}, {"sha": "e565cb70d21b90271737c80cf02b150657d0fee5", "filename": "gcc/machmode.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a191f0ee83fb815187657cadac361e883f496f01/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a191f0ee83fb815187657cadac361e883f496f01/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=a191f0ee83fb815187657cadac361e883f496f01", "patch": "@@ -24,7 +24,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Make an enum class that gives all the machine modes.  */\n \n-#define DEF_MACHMODE(SYM, NAME, TYPE, SIZE, UNIT, WIDER)  SYM,\n+#define DEF_MACHMODE(SYM, NAME, TYPE, BITSIZE, SIZE, UNIT, WIDER)  SYM,\n \n enum machine_mode {\n #include \"machmode.def\"\n@@ -93,7 +93,8 @@ extern const unsigned int mode_unit_size[];\n \n /* Get the size in bits of an object of mode MODE.  */\n \n-#define GET_MODE_BITSIZE(MODE)  (BITS_PER_UNIT * mode_size[(int) (MODE)])\n+extern const unsigned int mode_bitsize[];\n+#define GET_MODE_BITSIZE(MODE)  (mode_bitsize[(int) (MODE)])\n \n #ifdef HOST_WIDE_INT\n "}, {"sha": "aba68823f822b2b47be802a12e825295eb525216", "filename": "gcc/rtl.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a191f0ee83fb815187657cadac361e883f496f01/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a191f0ee83fb815187657cadac361e883f496f01/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a191f0ee83fb815187657cadac361e883f496f01", "patch": "@@ -128,7 +128,7 @@ const char * const rtx_name[] = {\n /* Indexed by machine mode, gives the name of that machine mode.\n    This name does not include the letters \"mode\".  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  NAME,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  NAME,\n \n const char * const mode_name[(int) MAX_MACHINE_MODE + 1] = {\n #include \"machmode.def\"\n@@ -139,21 +139,31 @@ const char * const mode_name[(int) MAX_MACHINE_MODE + 1] = {\n \n #undef DEF_MACHMODE\n \n-/* Indexed by machine mode, gives the length of the mode, in bytes.\n-   GET_MODE_CLASS uses this.  */\n+/* Indexed by machine mode, gives the class mode for GET_MODE_CLASS.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  CLASS,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  CLASS,\n \n const enum mode_class mode_class[(int) MAX_MACHINE_MODE] = {\n #include \"machmode.def\"\n };\n \n #undef DEF_MACHMODE\n \n+/* Indexed by machine mode, gives the length of the mode, in bits.\n+   GET_MODE_BITSIZE uses this.  */\n+\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  BITSIZE,\n+\n+const unsigned int mode_bitsize[(int) MAX_MACHINE_MODE] = {\n+#include \"machmode.def\"\n+};\n+\n+#undef DEF_MACHMODE\n+\n /* Indexed by machine mode, gives the length of the mode, in bytes.\n    GET_MODE_SIZE uses this.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  SIZE,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  SIZE,\n \n const unsigned int mode_size[(int) MAX_MACHINE_MODE] = {\n #include \"machmode.def\"\n@@ -164,7 +174,7 @@ const unsigned int mode_size[(int) MAX_MACHINE_MODE] = {\n /* Indexed by machine mode, gives the length of the mode's subunit.\n    GET_MODE_UNIT_SIZE uses this.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  UNIT,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  UNIT,\n \n const unsigned int mode_unit_size[(int) MAX_MACHINE_MODE] = {\n #include \"machmode.def\"\t\t/* machine modes are documented here */\n@@ -176,7 +186,7 @@ const unsigned int mode_unit_size[(int) MAX_MACHINE_MODE] = {\n    (QI -> HI -> SI -> DI, etc.)  Widening multiply instructions\n    use this.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  \\\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  \\\n   (unsigned char) WIDER,\n \n const unsigned char mode_wider_mode[(int) MAX_MACHINE_MODE] = {\n@@ -185,8 +195,8 @@ const unsigned char mode_wider_mode[(int) MAX_MACHINE_MODE] = {\n \n #undef DEF_MACHMODE\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  \\\n-  ((SIZE) * BITS_PER_UNIT >= HOST_BITS_PER_WIDE_INT) ? ~(unsigned HOST_WIDE_INT)0 : ((unsigned HOST_WIDE_INT) 1 << (SIZE) * BITS_PER_UNIT) - 1,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  \\\n+  ((BITSIZE) >= HOST_BITS_PER_WIDE_INT) ? ~(unsigned HOST_WIDE_INT)0 : ((unsigned HOST_WIDE_INT) 1 << (BITSIZE)) - 1,\n \n /* Indexed by machine mode, gives mask of significant bits in mode.  */\n \n@@ -196,7 +206,12 @@ const unsigned HOST_WIDE_INT mode_mask_array[(int) MAX_MACHINE_MODE] = {\n \n /* Indexed by mode class, gives the narrowest mode for each class.\n    The Q modes are always of width 1 (2 for complex) - it is impossible\n-   for any mode to be narrower.  */\n+   for any mode to be narrower.\n+\n+   Note that we use QImode instead of BImode for MODE_INT, since\n+   otherwise the middle end will try to use it for bitfields in\n+   structures and the like, which we do not want.  Only the target\n+   md file should generate BImode widgets.  */\n \n const enum machine_mode class_narrowest_mode[(int) MAX_MODE_CLASS] = {\n     /* MODE_RANDOM */\t\tVOIDmode,"}]}