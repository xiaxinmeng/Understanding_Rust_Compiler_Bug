{"sha": "13d3f0b659c7db21e006e8d2894c93707a95583d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNkM2YwYjY1OWM3ZGIyMWUwMDZlOGQyODk0YzkzNzA3YTk1NTgzZA==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2002-08-25T04:57:16Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2002-08-25T04:57:16Z"}, "message": "tree.c (lvalue_p_1): Add argument for whether casts of lvalues are allowable.\n\n2002-08-24  Matt Austern  <austern@apple.com>\n\n        * tree.c (lvalue_p_1): Add argument for whether casts of lvalues\n        are allowable.\n        (real_lvalue_p): Update caller.\n        (lvalue_p): Ditto.\n        (non_cast_lvalue_or_else): New.\n        * tree.h: Declare it.\n        * typeck.c (build_unary_op): Use non_cast_lvalue_or_else.\n\n2002-08-24  Matt Austern  <austern@apple.com>\n\n        * g++.dg/ext/lvaddr.C: New test.\n        * g++.dg/ext/lvcast.C: New test.\n\nFrom-SVN: r56560", "tree": {"sha": "7bb6f3b26e6d15d4a769a03c44e1525a5daa0f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bb6f3b26e6d15d4a769a03c44e1525a5daa0f24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13d3f0b659c7db21e006e8d2894c93707a95583d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13d3f0b659c7db21e006e8d2894c93707a95583d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13d3f0b659c7db21e006e8d2894c93707a95583d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13d3f0b659c7db21e006e8d2894c93707a95583d/comments", "author": null, "committer": null, "parents": [{"sha": "d241f75b9693bad3e4990196c2e3e785e73e7e70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d241f75b9693bad3e4990196c2e3e785e73e7e70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d241f75b9693bad3e4990196c2e3e785e73e7e70"}], "stats": {"total": 102, "additions": 85, "deletions": 17}, "files": [{"sha": "def395ea1264666f9eda5a1c09d8544b9231e6fc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=13d3f0b659c7db21e006e8d2894c93707a95583d", "patch": "@@ -1,3 +1,13 @@\n+2002-08-24  Matt Austern  <austern@apple.com>\n+\n+\t* tree.c (lvalue_p_1): Add argument for whether casts of lvalues\n+\tare allowable.\n+\t(real_lvalue_p): Update caller.\n+\t(lvalue_p): Ditto.\n+\t(non_cast_lvalue_or_else): New.\n+\t* tree.h: Declare it.\n+        * typeck.c (build_unary_op): Use non_cast_lvalue_or_else.\n+\n 2002-08-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* typeck.c (build_class_member_access_expr): Handle COMPOUND_EXPR"}, {"sha": "ef4f171829bc0124d318e68e28b1519523509604", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=13d3f0b659c7db21e006e8d2894c93707a95583d", "patch": "@@ -4184,6 +4184,7 @@ extern tree canonical_type_variant              PARAMS ((tree));\n extern void unshare_base_binfos\t\t\tPARAMS ((tree));\n extern int member_p\t\t\t\tPARAMS ((tree));\n extern cp_lvalue_kind real_lvalue_p\t\tPARAMS ((tree));\n+extern int non_cast_lvalue_or_else\t\tPARAMS ((tree, const char *));\n extern tree build_min\t\t\t\tPARAMS ((enum tree_code, tree,\n \t\t\t\t\t\t\t ...));\n extern tree build_min_nt\t\t\tPARAMS ((enum tree_code, ...));"}, {"sha": "6e092850762cf3cf78dde7ac21f520dd50d73212", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=13d3f0b659c7db21e006e8d2894c93707a95583d", "patch": "@@ -39,7 +39,7 @@ static tree build_cplus_array_type_1 PARAMS ((tree, tree));\n static int list_hash_eq PARAMS ((const void *, const void *));\n static hashval_t list_hash_pieces PARAMS ((tree, tree, tree));\n static hashval_t list_hash PARAMS ((const void *));\n-static cp_lvalue_kind lvalue_p_1 PARAMS ((tree, int));\n+static cp_lvalue_kind lvalue_p_1 PARAMS ((tree, int, int));\n static tree no_linkage_helper PARAMS ((tree *, int *, void *));\n static tree build_srcloc PARAMS ((const char *, int));\n static tree mark_local_for_remap_r PARAMS ((tree *, int *, void *));\n@@ -59,9 +59,10 @@ static tree handle_init_priority_attribute PARAMS ((tree *, tree, tree, int, boo\n    non-zero, rvalues of class type are considered lvalues.  */\n \n static cp_lvalue_kind\n-lvalue_p_1 (ref, treat_class_rvalues_as_lvalues)\n+lvalue_p_1 (ref, treat_class_rvalues_as_lvalues, allow_cast_as_lvalue)\n      tree ref;\n      int treat_class_rvalues_as_lvalues;\n+     int allow_cast_as_lvalue;\n {\n   cp_lvalue_kind op1_lvalue_kind = clk_none;\n   cp_lvalue_kind op2_lvalue_kind = clk_none;\n@@ -84,16 +85,28 @@ lvalue_p_1 (ref, treat_class_rvalues_as_lvalues)\n     case WITH_CLEANUP_EXPR:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      /* This shouldn't be here, but there are lots of places in the compiler\n-         that are sloppy about tacking on NOP_EXPRs to the same type when\n-\t no actual conversion is happening.  */\n-    case NOP_EXPR:\n       return lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t treat_class_rvalues_as_lvalues);\n+\t\t\t treat_class_rvalues_as_lvalues,\n+\t\t\t allow_cast_as_lvalue);\n+\n+    case NOP_EXPR:\n+      /* If expression doesn't change the type, we consider it as an\n+\t lvalue even when cast_as_lvalue extension isn't selected.\n+\t That's because parts of the compiler are alleged to be sloppy\n+\t about sticking in NOP_EXPR node for no good reason. */\n+      if (allow_cast_as_lvalue ||\n+\t  same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ref)),\n+\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (ref, 0)))))\n+\treturn lvalue_p_1 (TREE_OPERAND (ref, 0),\n+\t\t\t   treat_class_rvalues_as_lvalues,\n+\t\t\t   allow_cast_as_lvalue);\n+      else\n+\treturn clk_none;\n \n     case COMPONENT_REF:\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t\t    treat_class_rvalues_as_lvalues);\n+\t\t\t\t    treat_class_rvalues_as_lvalues,\n+\t\t\t\t    allow_cast_as_lvalue);\n       if (op1_lvalue_kind \n \t  /* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\n \t     situations.  */\n@@ -134,24 +147,29 @@ lvalue_p_1 (ref, treat_class_rvalues_as_lvalues)\n     case MAX_EXPR:\n     case MIN_EXPR:\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t\t    treat_class_rvalues_as_lvalues);\n+\t\t\t\t    treat_class_rvalues_as_lvalues,\n+\t\t\t\t    allow_cast_as_lvalue);\n       op2_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t    treat_class_rvalues_as_lvalues);\n+\t\t\t\t    treat_class_rvalues_as_lvalues,\n+\t\t\t\t    allow_cast_as_lvalue);\n       break;\n \n     case COND_EXPR:\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t    treat_class_rvalues_as_lvalues);\n+\t\t\t\t    treat_class_rvalues_as_lvalues,\n+\t\t\t\t    allow_cast_as_lvalue);\n       op2_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 2),\n-\t\t\t\t    treat_class_rvalues_as_lvalues);\n+\t\t\t\t    treat_class_rvalues_as_lvalues,\n+\t\t\t\t    allow_cast_as_lvalue);\n       break;\n \n     case MODIFY_EXPR:\n       return clk_ordinary;\n \n     case COMPOUND_EXPR:\n       return lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t treat_class_rvalues_as_lvalues);\n+\t\t\t treat_class_rvalues_as_lvalues,\n+\t\t\t allow_cast_as_lvalue);\n \n     case TARGET_EXPR:\n       return treat_class_rvalues_as_lvalues ? clk_class : clk_none;\n@@ -196,7 +214,7 @@ cp_lvalue_kind\n real_lvalue_p (ref)\n      tree ref;\n {\n-  return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/0);\n+  return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/ 0, /*cast*/ 1);\n }\n \n /* This differs from real_lvalue_p in that class rvalues are\n@@ -207,7 +225,7 @@ lvalue_p (ref)\n      tree ref;\n {\n   return \n-    (lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/1) != clk_none);\n+    (lvalue_p_1 (ref, /*class rvalue ok*/ 1, /*cast*/ 1) != clk_none);\n }\n \n /* Return nonzero if REF is an lvalue valid for this language;\n@@ -218,7 +236,20 @@ lvalue_or_else (ref, string)\n      tree ref;\n      const char *string;\n {\n-  int win = lvalue_p (ref);\n+  int ret = lvalue_p_1 (ref, /* class rvalue ok */ 1, /* cast ok */ 1);\n+  int win = (ret != clk_none);\n+  if (! win)\n+    error (\"non-lvalue in %s\", string);\n+  return win;\n+}\n+\n+int\n+non_cast_lvalue_or_else (ref, string)\n+     tree ref;\n+     const char *string;\n+{\n+  int ret = lvalue_p_1 (ref, /* class rvalue ok */ 1, /* cast ok */ 0);\n+  int win = (ret != clk_none);\n   if (! win)\n     error (\"non-lvalue in %s\", string);\n   return win;"}, {"sha": "8535cde4ae70f4f525fac07b25bfdeaa0feb0861", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=13d3f0b659c7db21e006e8d2894c93707a95583d", "patch": "@@ -4268,7 +4268,7 @@ build_unary_op (code, xarg, noconvert)\n \t is an error.  */\n       else if (TREE_CODE (argtype) != FUNCTION_TYPE\n \t       && TREE_CODE (argtype) != METHOD_TYPE\n-\t       && !lvalue_or_else (arg, \"unary `&'\"))\n+\t       && !non_cast_lvalue_or_else (arg, \"unary `&'\"))\n \treturn error_mark_node;\n \n       if (argtype != error_mark_node)"}, {"sha": "f509299f6e5d772ca1790bcfd0e6533eb6357487", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=13d3f0b659c7db21e006e8d2894c93707a95583d", "patch": "@@ -1,3 +1,8 @@\n+2002-08-24  Matt Austern  <austern@apple.com>\n+\n+\t* g++.dg/ext/lvaddr.C: New test.\n+\t* g++.dg/ext/lvcast.C: New test.\n+\t\n 2002-08-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* testsuite/g++.dg/inherit/cond1.C: New test."}, {"sha": "184afce900b6bca344c3901041446d73bb53891b", "filename": "gcc/testsuite/g++.dg/ext/lvaddr.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvaddr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvaddr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvaddr.C?ref=13d3f0b659c7db21e006e8d2894c93707a95583d", "patch": "@@ -0,0 +1,10 @@\n+// Copyright (C) 2002 Free Software Foundation\n+// Contributed by Matt Austern <austern@apple.com>\n+\n+// { dg-do compile }\n+\n+void f()\n+{\n+  int n;\n+  char* p = &(char) n;\t\t// { dg-error \"non-lvalue\" }\n+}"}, {"sha": "efff04ec0896703897678a1a4d9b414d4455ef77", "filename": "gcc/testsuite/g++.dg/ext/lvcast.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvcast.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d3f0b659c7db21e006e8d2894c93707a95583d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvcast.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvcast.C?ref=13d3f0b659c7db21e006e8d2894c93707a95583d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright (C) 2002 Free Software Foundation\n+// Contributed by Matt Austern <austern@apple.com>\n+\n+// { dg-do compile }\n+// { dg-options -fpermissive }\n+\n+void f ()\n+{\n+  int n;\n+  (char) n = 1;\n+}"}]}