{"sha": "97ecc8d5769e947e8659d32be51846d40c90f50c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdlY2M4ZDU3NjllOTQ3ZTg2NTlkMzJiZTUxODQ2ZDQwYzkwZjUwYw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-08-16T06:54:23Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-08-16T06:54:23Z"}, "message": "Add type to VR_VARYING.\n\nFrom-SVN: r274561", "tree": {"sha": "7451af2bf9f9c04582fba7f75cfc275b2619ddbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7451af2bf9f9c04582fba7f75cfc275b2619ddbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97ecc8d5769e947e8659d32be51846d40c90f50c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97ecc8d5769e947e8659d32be51846d40c90f50c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97ecc8d5769e947e8659d32be51846d40c90f50c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97ecc8d5769e947e8659d32be51846d40c90f50c/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3cfbeaf6b655b9c00d77efb8220a8a16341cb2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3cfbeaf6b655b9c00d77efb8220a8a16341cb2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3cfbeaf6b655b9c00d77efb8220a8a16341cb2e"}], "stats": {"total": 310, "additions": 221, "deletions": 89}, "files": [{"sha": "f25c00b57031561e0334c2926a97a7f4c2873603", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97ecc8d5769e947e8659d32be51846d40c90f50c", "patch": "@@ -1,3 +1,51 @@\n+2019-08-16  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gimple-ssa-evrp-analyze.c (record_ranges_from_phis): Skip PHIs\n+\tfor which we can't represent a range.\n+\t* ipa-cp.c (ipcp_vr_lattice::set_to_bottom): Pass type to\n+\tset_varying.\n+\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_phis):\n+\tSet VR_UNDEFINED if type is not supported.\n+\t* tree-ssanames.c (get_range_info): Pass type to set_varying.\n+\t* tree-vrp.c (value_range_base::check): Assert that a varying has\n+\tmin/max set.\n+\t(value_range_base::equal_p): Early bail for undefines.\n+\t(value_range_base::set_varying): Accept a type.\n+\t(value_range::set_varying): Same.\n+\t(value_range_base::type): VARYING can have a type, while UNDEFINE\n+\tis typeless.\n+\t(value_range_base::dump): Print type for VARYING nodes.\n+\t(value_range_base::set): Add type to VARYING.\n+\t(extract_range_from_multiplicative_op): Pass type to set_varying.\n+\t(extract_range_from_binary_expr): Same.\n+\t(value_range_base::intersect_helper): Same.\n+\t(value_range_base::union_helper): Same.\n+\t(value_range_base::normalize_symbolics): Same.\n+\t(determine_value_range_1): Same.\n+\t* tree-vrp.h (class value_range_base): Add type to set_varying.\n+\tAdd prototype for dump(void).\n+\tAdd prototype for supports_type_p.\n+\t(class value_range): Add type to set_varying.\n+\tAdd prototype for dump(void).\n+\t* vr-values.c (set_value_range_to_truthvalue): Pass type to\n+\tset_varying.\n+\t(vr_values::get_lattice_entry): Set varying even if propagation\n+\tfinished.\n+\tPass type to set_varying.\n+\t(vr_values::get_value_range): Remove vr_const_varying.\n+\tReallocate the lattice if needed.\n+\t(vr_values::update_value_range): Pass type to set_varying.\n+\t(vr_values::extract_range_for_var_from_comparison_expr): Same.\n+\t(vr_values::extract_range_from_binary_expr): Same.\n+\t(vr_values::extract_range_from_unary_expr): Same.\n+\t(vr_values::extract_range_from_cond_expr): Same.\n+\t(vr_values::check_for_binary_op_overflow): Same.\n+\t(vr_values::extract_range_basic): Same.\n+\t(vr_values::extract_range_from_assignment): Same.\n+\t(vr_values::vr_values): Increase size of num_vr_values.\n+\t(vr_values::extract_range_from_phi_node): Pass type to\n+\tset_varying.\n+\n 2019-08-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/90878"}, {"sha": "68f317f99302a0ed70354652a3cc1ff914aa76e4", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=97ecc8d5769e947e8659d32be51846d40c90f50c", "patch": "@@ -254,13 +254,18 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n       if (virtual_operand_p (lhs))\n \tcontinue;\n \n+      /* Skips floats and other things we can't represent in a\n+\t range.  */\n+      if (!value_range_base::supports_type_p (TREE_TYPE (lhs)))\n+\tcontinue;\n+\n       value_range vr_result;\n       bool interesting = stmt_interesting_for_vrp (phi);\n       if (!has_unvisited_preds && interesting)\n \tvr_values->extract_range_from_phi_node (phi, &vr_result);\n       else\n \t{\n-\t  vr_result.set_varying ();\n+\t  vr_result.set_varying (TREE_TYPE (lhs));\n \t  /* When we have an unvisited executable predecessor we can't\n \t     use PHI arg ranges which may be still UNDEFINED but have\n \t     to use VARYING for them.  But we can still resort to"}, {"sha": "0046064fea19c97aad47d573df6a03b80b50b408", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=97ecc8d5769e947e8659d32be51846d40c90f50c", "patch": "@@ -977,7 +977,12 @@ ipcp_vr_lattice::set_to_bottom ()\n {\n   if (m_vr.varying_p ())\n     return false;\n-  m_vr.set_varying ();\n+  /* ?? We create all sorts of VARYING ranges for floats, structures,\n+     and other types which we cannot handle as ranges.  We should\n+     probably avoid handling them throughout the pass, but it's easier\n+     to create a sensible VARYING here and let the lattice\n+     propagate.  */\n+  m_vr.set_varying (integer_type_node);\n   return true;\n }\n "}, {"sha": "1776a6d9ab4b601f4cdfb0e7a348a290ef768a47", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=97ecc8d5769e947e8659d32be51846d40c90f50c", "patch": "@@ -183,7 +183,7 @@ record_temporary_equivalences_from_phis (edge e,\n \t  else if (TREE_CODE (src) == INTEGER_CST)\n \t    new_vr->set (src);\n \t  else\n-\t    new_vr->set_varying ();\n+\t    new_vr->set_varying (TREE_TYPE (src));\n \n \t  /* This is a temporary range for DST, so push it.  */\n \t  evrp_range_analyzer->push_value_range (dst, new_vr);"}, {"sha": "3911db9c26e56017ef045a16cfd9673337105c67", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=97ecc8d5769e947e8659d32be51846d40c90f50c", "patch": "@@ -440,14 +440,16 @@ get_range_info (const_tree name, value_range_base &vr)\n   wide_int wmin, wmax;\n   enum value_range_kind kind = get_range_info (name, &wmin, &wmax);\n \n-  if (kind == VR_VARYING || kind == VR_UNDEFINED)\n-    min = max = NULL;\n+  if (kind == VR_VARYING)\n+    vr.set_varying (TREE_TYPE (name));\n+  else if (kind == VR_UNDEFINED)\n+    vr.set_undefined ();\n   else\n     {\n       min = wide_int_to_tree (TREE_TYPE (name), wmin);\n       max = wide_int_to_tree (TREE_TYPE (name), wmax);\n+      vr.set (kind, min, max);\n     }\n-  vr.set (kind, min, max);\n   return kind;\n }\n "}, {"sha": "8067f8560cd1854af7c9efc89e41586b97394532", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 93, "deletions": 49, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=97ecc8d5769e947e8659d32be51846d40c90f50c", "patch": "@@ -186,9 +186,11 @@ value_range_base::check ()\n \tbreak;\n       }\n     case VR_UNDEFINED:\n-    case VR_VARYING:\n       gcc_assert (!min () && !max ());\n       break;\n+    case VR_VARYING:\n+      gcc_assert (m_min && m_max);\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -214,6 +216,10 @@ value_range::check ()\n bool\n value_range_base::equal_p (const value_range_base &other) const\n {\n+  /* Ignore types for undefined.  All undefines are equal.  */\n+  if (undefined_p ())\n+    return m_kind == other.m_kind;\n+\n   return (m_kind == other.m_kind\n \t  && vrp_operand_equal_p (m_min, other.m_min)\n \t  && vrp_operand_equal_p (m_max, other.m_max));\n@@ -269,16 +275,24 @@ value_range::set_undefined ()\n }\n \n void\n-value_range_base::set_varying ()\n+value_range_base::set_varying (tree type)\n {\n   m_kind = VR_VARYING;\n-  m_min = m_max = NULL;\n+  if (supports_type_p (type))\n+    {\n+      m_min = vrp_val_min (type, true);\n+      m_max = vrp_val_max (type, true);\n+    }\n+  else\n+    /* We can't do anything range-wise with these types.  */\n+    m_min = m_max = error_mark_node;\n }\n \n void\n-value_range::set_varying ()\n+value_range::set_varying (tree type)\n {\n-  set (VR_VARYING, NULL, NULL, NULL);\n+  value_range_base::set_varying (type);\n+  equiv_clear ();\n }\n \n /* Return TRUE if it is possible that range contains VAL.  */\n@@ -355,9 +369,7 @@ value_range_base::singleton_p (tree *result) const\n tree\n value_range_base::type () const\n {\n-  /* Types are only valid for VR_RANGE and VR_ANTI_RANGE, which are\n-     known to have non-zero min/max.  */\n-  gcc_assert (min ());\n+  gcc_assert (m_min || undefined_p ());\n   return TREE_TYPE (min ());\n }\n \n@@ -395,11 +407,20 @@ value_range_base::dump (FILE *file) const\n       fprintf (file, \"]\");\n     }\n   else if (varying_p ())\n-    fprintf (file, \"VARYING\");\n+    {\n+      print_generic_expr (file, type ());\n+      fprintf (file, \" VARYING\");\n+    }\n   else\n     gcc_unreachable ();\n }\n \n+void\n+value_range_base::dump () const\n+{\n+  dump (stderr);\n+}\n+\n void\n value_range::dump (FILE *file) const\n {\n@@ -423,6 +444,12 @@ value_range::dump (FILE *file) const\n     }\n }\n \n+void\n+value_range::dump () const\n+{\n+  dump (stderr);\n+}\n+\n void\n dump_value_range (FILE *file, const value_range *vr)\n {\n@@ -658,7 +685,14 @@ value_range_base::set (enum value_range_kind kind, tree min, tree max)\n     }\n   else if (kind == VR_VARYING)\n     {\n-      set_varying ();\n+      gcc_assert (TREE_TYPE (min) == TREE_TYPE (max));\n+      tree typ = TREE_TYPE (min);\n+      if (supports_type_p (typ))\n+\t{\n+\t  gcc_assert (vrp_val_min (typ, true));\n+\t  gcc_assert (vrp_val_max (typ, true));\n+\t}\n+      set_varying (typ);\n       return;\n     }\n \n@@ -683,7 +717,7 @@ value_range_base::set (enum value_range_kind kind, tree min, tree max)\n \t for VR_ANTI_RANGE empty range, so drop to varying as well.  */\n       if (TYPE_PRECISION (TREE_TYPE (min)) == 1)\n \t{\n-\t  set_varying ();\n+\t  set_varying (TREE_TYPE (min));\n \t  return;\n \t}\n \n@@ -697,7 +731,7 @@ value_range_base::set (enum value_range_kind kind, tree min, tree max)\n \t to varying in this case.  */\n       if (tree_int_cst_lt (max, min))\n \t{\n-\t  set_varying ();\n+\t  set_varying (TREE_TYPE (min));\n \t  return;\n \t}\n \n@@ -720,7 +754,7 @@ value_range_base::set (enum value_range_kind kind, tree min, tree max)\n \t{\n \t  /* We cannot deal with empty ranges, drop to varying.\n \t     ???  This could be VR_UNDEFINED instead.  */\n-\t  set_varying ();\n+\t  set_varying (type);\n \t  return;\n \t}\n       else if (TYPE_PRECISION (TREE_TYPE (min)) == 1\n@@ -767,7 +801,7 @@ value_range_base::set (enum value_range_kind kind, tree min, tree max)\n       && wi::eq_p (wi::to_wide (max), wi::max_value (prec, sign)))\n     {\n       if (kind == VR_RANGE)\n-\tset_varying ();\n+\tset_varying (type);\n       else if (kind == VR_ANTI_RANGE)\n \tset_undefined ();\n       else\n@@ -1297,7 +1331,7 @@ extract_range_from_multiplicative_op (value_range_base *vr,\n \t      || code == LSHIFT_EXPR);\n   if (!range_int_cst_p (vr1))\n     {\n-      vr->set_varying ();\n+      vr->set_varying (type);\n       return;\n     }\n \n@@ -1332,7 +1366,7 @@ extract_range_from_multiplicative_op (value_range_base *vr,\n     vr->set (VR_RANGE, wide_int_to_tree (type, res_lb),\n \t     wide_int_to_tree (type, res_ub));\n   else\n-    vr->set_varying ();\n+    vr->set_varying (type);\n }\n \n /* If BOUND will include a symbolic bound, adjust it accordingly,\n@@ -1541,7 +1575,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n   if (!INTEGRAL_TYPE_P (expr_type)\n       && !POINTER_TYPE_P (expr_type))\n     {\n-      vr->set_varying ();\n+      vr->set_varying (expr_type);\n       return;\n     }\n \n@@ -1565,7 +1599,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n       && code != BIT_IOR_EXPR\n       && code != BIT_XOR_EXPR)\n     {\n-      vr->set_varying ();\n+      vr->set_varying (expr_type);\n       return;\n     }\n \n@@ -1580,9 +1614,9 @@ extract_range_from_binary_expr (value_range_base *vr,\n      have UNDEFINED result for all or some value-ranges of the not UNDEFINED\n      operand.  */\n   else if (vr0.undefined_p ())\n-    vr0.set_varying ();\n+    vr0.set_varying (expr_type);\n   else if (vr1.undefined_p ())\n-    vr1.set_varying ();\n+    vr1.set_varying (expr_type);\n \n   /* We get imprecise results from ranges_from_anti_range when\n      code is EXACT_DIV_EXPR.  We could mask out bits in the resulting\n@@ -1654,7 +1688,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t  || vr0.symbolic_p ()\n \t  || vr1.symbolic_p ()))\n     {\n-      vr->set_varying ();\n+      vr->set_varying (expr_type);\n       return;\n     }\n \n@@ -1672,7 +1706,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t  else if (vr0.zero_p () && vr1.zero_p ())\n \t    vr->set_zero (expr_type);\n \t  else\n-\t    vr->set_varying ();\n+\t    vr->set_varying (expr_type);\n \t}\n       else if (code == POINTER_PLUS_EXPR)\n \t{\n@@ -1701,7 +1735,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t  else if (vr0.zero_p () && vr1.zero_p ())\n \t    vr->set_zero (expr_type);\n \t  else\n-\t    vr->set_varying ();\n+\t    vr->set_varying (expr_type);\n \t}\n       else if (code == BIT_AND_EXPR)\n \t{\n@@ -1712,10 +1746,10 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t  else if (vr0.zero_p () || vr1.zero_p ())\n \t    vr->set_zero (expr_type);\n \t  else\n-\t    vr->set_varying ();\n+\t    vr->set_varying (expr_type);\n \t}\n       else\n-\tvr->set_varying ();\n+\tvr->set_varying (expr_type);\n \n       return;\n     }\n@@ -1793,7 +1827,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t  if (((bool)min_ovf && sym_min_op0 != sym_min_op1)\n \t      || ((bool)max_ovf && sym_max_op0 != sym_max_op1))\n \t    {\n-\t      vr->set_varying ();\n+\t      vr->set_varying (expr_type);\n \t      return;\n \t    }\n \n@@ -1804,7 +1838,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t\t\t\t\t wmin, wmax, min_ovf, max_ovf);\n \t  if (type == VR_VARYING)\n \t    {\n-\t      vr->set_varying ();\n+\t      vr->set_varying (expr_type);\n \t      return;\n \t    }\n \n@@ -1830,7 +1864,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t     a single range or anti-range as the above is\n \t\t [-INF+1, +INF(OVF)] intersected with ~[5, 5]\n \t     but one could use a scheme similar to equivalences for this. */\n-\t  vr->set_varying ();\n+\t  vr->set_varying (expr_type);\n \t  return;\n \t}\n     }\n@@ -1847,15 +1881,15 @@ extract_range_from_binary_expr (value_range_base *vr,\n \tvr->set (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n \t\t wide_int_to_tree (expr_type, wmax));\n       else\n-\tvr->set_varying ();\n+\tvr->set_varying (expr_type);\n       return;\n     }\n   else if (code == MULT_EXPR)\n     {\n       if (!range_int_cst_p (&vr0)\n \t  || !range_int_cst_p (&vr1))\n \t{\n-\t  vr->set_varying ();\n+\t  vr->set_varying (expr_type);\n \t  return;\n \t}\n       extract_range_from_multiplicative_op (vr, code, expr_type, &vr0, &vr1);\n@@ -1895,7 +1929,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t\t}\n \t    }\n \t}\n-      vr->set_varying ();\n+      vr->set_varying (expr_type);\n       return;\n     }\n   else if (code == TRUNC_DIV_EXPR\n@@ -1932,7 +1966,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t\t\t       TYPE_OVERFLOW_UNDEFINED (expr_type),\n \t\t\t       extra_range_p, extra_min, extra_max))\n \t{\n-\t  vr->set_varying ();\n+\t  vr->set_varying (expr_type);\n \t  return;\n \t}\n       vr->set (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n@@ -1991,7 +2025,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t      vr->set (VR_RANGE, min, max);\n \t    }\n \t  else\n-\t    vr->set_varying ();\n+\t    vr->set_varying (expr_type);\n \t  return;\n \t}\n       else if (code == BIT_IOR_EXPR)\n@@ -2009,7 +2043,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t      vr->set (VR_RANGE, min, max);\n \t    }\n \t  else\n-\t    vr->set_varying ();\n+\t    vr->set_varying (expr_type);\n \t  return;\n \t}\n       else if (code == BIT_XOR_EXPR)\n@@ -2025,7 +2059,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t      vr->set (VR_RANGE, min, max);\n \t    }\n \t  else\n-\t    vr->set_varying ();\n+\t    vr->set_varying (expr_type);\n \t  return;\n \t}\n     }\n@@ -2039,7 +2073,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n       || max == NULL_TREE\n       || TREE_OVERFLOW_P (max))\n     {\n-      vr->set_varying ();\n+      vr->set_varying (expr_type);\n       return;\n     }\n \n@@ -2048,7 +2082,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n      Note that we do accept [-INF, -INF] and [+INF, +INF].  */\n   if (vrp_val_is_min (min) && vrp_val_is_max (max))\n     {\n-      vr->set_varying ();\n+      vr->set_varying (expr_type);\n       return;\n     }\n \n@@ -2058,7 +2092,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n       /* If the new range has its limits swapped around (MIN > MAX),\n \t then the operation caused one of them to wrap around, mark\n \t the new range VARYING.  */\n-      vr->set_varying ();\n+      vr->set_varying (expr_type);\n     }\n   else\n     vr->set (type, min, max);\n@@ -2084,7 +2118,7 @@ extract_range_from_unary_expr (value_range_base *vr,\n       || !(INTEGRAL_TYPE_P (type)\n \t   || POINTER_TYPE_P (type)))\n     {\n-      vr->set_varying ();\n+      vr->set_varying (type);\n       return;\n     }\n \n@@ -2156,7 +2190,7 @@ extract_range_from_unary_expr (value_range_base *vr,\n \t  else if (vr0.zero_p ())\n \t    vr->set_zero (type);\n \t  else\n-\t    vr->set_varying ();\n+\t    vr->set_varying (type);\n \t  return;\n \t}\n \n@@ -2190,7 +2224,7 @@ extract_range_from_unary_expr (value_range_base *vr,\n \t  vr->set (VR_RANGE, min, max);\n \t}\n       else\n-\tvr->set_varying ();\n+\tvr->set_varying (outer_type);\n       return;\n     }\n   else if (code == ABS_EXPR)\n@@ -2203,7 +2237,7 @@ extract_range_from_unary_expr (value_range_base *vr,\n \tvr->set (VR_RANGE, wide_int_to_tree (type, wmin),\n \t\t wide_int_to_tree (type, wmax));\n       else\n-\tvr->set_varying ();\n+\tvr->set_varying (type);\n       return;\n     }\n   else if (code == ABSU_EXPR)\n@@ -2219,7 +2253,7 @@ extract_range_from_unary_expr (value_range_base *vr,\n     }\n \n   /* For unhandled operations fall back to varying.  */\n-  vr->set_varying ();\n+  vr->set_varying (type);\n   return;\n }\n \n@@ -6100,7 +6134,12 @@ value_range_base::intersect_helper (const value_range_base *vr0,\n      VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n      fall back to vr0 when this turns things to varying.  */\n   value_range_base tem;\n-  tem.set (vr0type, vr0min, vr0max);\n+  if (vr0type == VR_UNDEFINED)\n+    tem.set_undefined ();\n+  else if (vr0type == VR_VARYING)\n+    tem.set_varying (vr0->type ());\n+  else\n+    tem.set (vr0type, vr0min, vr0max);\n   /* If that failed, use the saved original VR0.  */\n   if (tem.varying_p ())\n     return *vr0;\n@@ -6205,7 +6244,12 @@ value_range_base::union_helper (const value_range_base *vr0,\n \n   /* Work on a temporary so we can still use vr0 when union returns varying.  */\n   value_range_base tem;\n-  tem.set (vr0type, vr0min, vr0max);\n+  if (vr0type == VR_UNDEFINED)\n+    tem.set_undefined ();\n+  else if (vr0type == VR_VARYING)\n+    tem.set_varying (vr0->type ());\n+  else\n+    tem.set (vr0type, vr0min, vr0max);\n \n   /* Failed to find an efficient meet.  Before giving up and setting\n      the result to VARYING, see if we can at least derive a useful\n@@ -6302,7 +6346,7 @@ value_range_base::normalize_symbolics () const\n   if (min_symbolic && max_symbolic)\n     {\n       value_range_base var;\n-      var.set_varying ();\n+      var.set_varying (ttype);\n       return var;\n     }\n   if (kind () == VR_RANGE)\n@@ -6323,7 +6367,7 @@ value_range_base::normalize_symbolics () const\n \t  return value_range_base (VR_RANGE, n, vrp_val_max (ttype));\n \t}\n       value_range_base var;\n-      var.set_varying ();\n+      var.set_varying (ttype);\n       return var;\n     }\n   // ~[NUM, SYM] -> [-MIN, NUM - 1]\n@@ -6333,7 +6377,7 @@ value_range_base::normalize_symbolics () const\n       return value_range_base (VR_RANGE, vrp_val_min (ttype), n);\n     }\n   value_range_base var;\n-  var.set_varying ();\n+  var.set_varying (ttype);\n   return var;\n }\n \n@@ -7010,7 +7054,7 @@ determine_value_range_1 (value_range_base *vr, tree expr)\n \tvr->set (kind, wide_int_to_tree (TREE_TYPE (expr), min),\n \t\t wide_int_to_tree (TREE_TYPE (expr), max));\n       else\n-\tvr->set_varying ();\n+\tvr->set_varying (TREE_TYPE (expr));\n     }\n }\n "}, {"sha": "c879a8c6df87fbd8c0914129778c201b71097586", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=97ecc8d5769e947e8659d32be51846d40c90f50c", "patch": "@@ -58,7 +58,7 @@ class GTY((for_user)) value_range_base\n   bool constant_p () const;\n   bool undefined_p () const;\n   bool varying_p () const;\n-  void set_varying ();\n+  void set_varying (tree type);\n   void set_undefined ();\n \n   void union_ (const value_range_base *);\n@@ -75,7 +75,9 @@ class GTY((for_user)) value_range_base\n   bool nonzero_p () const;\n   bool singleton_p (tree *result = NULL) const;\n   void dump (FILE *) const;\n+  void dump () const;\n \n+  static bool supports_type_p (tree);\n   value_range_base normalize_symbolics () const;\n \n protected:\n@@ -135,7 +137,7 @@ class GTY((user)) value_range : public value_range_base\n \n   /* Types of value ranges.  */\n   void set_undefined ();\n-  void set_varying ();\n+  void set_varying (tree);\n \n   /* Equivalence bitmap methods.  */\n   bitmap equiv () const;\n@@ -145,6 +147,7 @@ class GTY((user)) value_range : public value_range_base\n   /* Misc methods.  */\n   void deep_copy (const value_range *);\n   void dump (FILE *) const;\n+  void dump () const;\n \n  private:\n   /* Deep-copies bitmap argument.  */\n@@ -254,6 +257,17 @@ struct assert_info\n   tree expr;\n };\n \n+// Return true if TYPE is a valid type for value_range to operate on.\n+// Otherwise return FALSE.\n+\n+inline bool\n+value_range_base::supports_type_p (tree type)\n+{\n+  if (type && (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)))\n+    return type;\n+  return NULL;\n+}\n+\n extern void register_edge_assert_for (tree, edge, enum tree_code,\n \t\t\t\t      tree, tree, vec<assert_info> &);\n extern bool stmt_interesting_for_vrp (gimple *);"}, {"sha": "6f9a3612931cbff15612b6266844295ea7ef1184", "filename": "gcc/vr-values.c", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97ecc8d5769e947e8659d32be51846d40c90f50c/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=97ecc8d5769e947e8659d32be51846d40c90f50c", "patch": "@@ -64,7 +64,7 @@ static inline void\n set_value_range_to_truthvalue (value_range *vr, tree type)\n {\n   if (TYPE_PRECISION (type) == 1)\n-    vr->set_varying ();\n+    vr->set_varying (type);\n   else\n     vr->update (VR_RANGE, build_int_cst (type, 0), build_int_cst (type, 1));\n }\n@@ -89,12 +89,16 @@ vr_values::get_lattice_entry (const_tree var)\n   if (vr)\n     return vr;\n \n-  /* After propagation finished do not allocate new value-ranges.  */\n-  if (values_propagated)\n-    return NULL;\n-\n   /* Create a default value range.  */\n   vr_value[ver] = vr = vrp_value_range_pool.allocate ();\n+\n+  /* After propagation finished return varying.  */\n+  if (values_propagated)\n+    {\n+      vr->set_varying (TREE_TYPE (var));\n+      return vr;\n+    }\n+\n   vr->set_undefined ();\n \n   /* If VAR is a default definition of a parameter, the variable can\n@@ -118,10 +122,10 @@ vr_values::get_lattice_entry (const_tree var)\n \t    {\n \t      get_range_info (var, *vr);\n \t      if (vr->undefined_p ())\n-\t\tvr->set_varying ();\n+\t\tvr->set_varying (TREE_TYPE (sym));\n \t    }\n \t  else\n-\t    vr->set_varying ();\n+\t    vr->set_varying (TREE_TYPE (sym));\n \t}\n       else if (TREE_CODE (sym) == RESULT_DECL\n \t       && DECL_BY_REFERENCE (sym))\n@@ -142,15 +146,25 @@ vr_values::get_lattice_entry (const_tree var)\n const value_range *\n vr_values::get_value_range (const_tree var)\n {\n-  static const value_range vr_const_varying (VR_VARYING, NULL, NULL);\n-\n   /* If we have no recorded ranges, then return NULL.  */\n   if (!vr_value)\n     return NULL;\n \n   value_range *vr = get_lattice_entry (var);\n+\n+  /* Reallocate the lattice if needed.  */\n   if (!vr)\n-    return &vr_const_varying;\n+    {\n+      unsigned int old_sz = num_vr_values;\n+      num_vr_values = num_ssa_names + num_ssa_names / 10;\n+      vr_value = XRESIZEVEC (value_range *, vr_value, num_vr_values);\n+      for ( ; old_sz < num_vr_values; old_sz++)\n+        vr_value [old_sz] = NULL;\n+\n+      /* Now that the lattice has been resized, we should never fail.  */\n+      vr = get_lattice_entry (var);\n+      gcc_assert (vr);\n+    }\n \n   return vr;\n }\n@@ -162,7 +176,7 @@ vr_values::set_def_to_varying (const_tree def)\n {\n   value_range *vr = get_lattice_entry (def);\n   if (vr)\n-    vr->set_varying ();\n+    vr->set_varying (TREE_TYPE (def));\n }\n \n /* Set value-ranges of all SSA names defined by STMT to varying.  */\n@@ -220,13 +234,13 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n \t called, if we are anyway, keep it VARYING.  */\n       if (old_vr->varying_p ())\n \t{\n-\t  new_vr->set_varying ();\n+\t  new_vr->set_varying (new_vr->type ());\n \t  is_new = false;\n \t}\n       else if (new_vr->undefined_p ())\n \t{\n-\t  old_vr->set_varying ();\n-\t  new_vr->set_varying ();\n+\t  old_vr->set_varying (TREE_TYPE (var));\n+\t  new_vr->set_varying (TREE_TYPE (var));\n \t  return true;\n \t}\n       else\n@@ -457,7 +471,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n   if ((POINTER_TYPE_P (type) && cond_code != NE_EXPR && cond_code != EQ_EXPR)\n       || limit == var)\n     {\n-      vr_p->set_varying ();\n+      vr_p->set_varying (type);\n       return;\n     }\n \n@@ -617,7 +631,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t all should be optimized away above us.  */\n       if (cond_code == LT_EXPR\n \t  && compare_values (max, min) == 0)\n-\tvr_p->set_varying ();\n+\tvr_p->set_varying (TREE_TYPE (min));\n       else\n \t{\n \t  /* For LT_EXPR, we create the range [MIN, MAX - 1].  */\n@@ -657,7 +671,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t all should be optimized away above us.  */\n       if (cond_code == GT_EXPR\n \t  && compare_values (min, max) == 0)\n-\tvr_p->set_varying ();\n+\tvr_p->set_varying (TREE_TYPE (min));\n       else\n \t{\n \t  /* For GT_EXPR, we create the range [MIN + 1, MAX].  */\n@@ -765,14 +779,14 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n   else if (is_gimple_min_invariant (op0))\n     vr0.set (op0);\n   else\n-    vr0.set_varying ();\n+    vr0.set_varying (TREE_TYPE (op0));\n \n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n     vr1.set (op1);\n   else\n-    vr1.set_varying ();\n+    vr1.set_varying (TREE_TYPE (op1));\n \n   /* If one argument is varying, we can sometimes still deduce a\n      range for the output: any + [3, +INF] is in [MIN+3, +INF].  */\n@@ -913,7 +927,7 @@ vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n   else if (is_gimple_min_invariant (op0))\n     vr0.set (op0);\n   else\n-    vr0.set_varying ();\n+    vr0.set_varying (type);\n \n   ::extract_range_from_unary_expr (vr, code, type, &vr0, TREE_TYPE (op0));\n }\n@@ -935,7 +949,7 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n   else if (is_gimple_min_invariant (op0))\n     tem0.set (op0);\n   else\n-    tem0.set_varying ();\n+    tem0.set_varying (TREE_TYPE (op0));\n \n   tree op1 = gimple_assign_rhs3 (stmt);\n   value_range tem1;\n@@ -945,7 +959,7 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n   else if (is_gimple_min_invariant (op1))\n     tem1.set (op1);\n   else\n-    tem1.set_varying ();\n+    tem1.set_varying (TREE_TYPE (op1));\n \n   /* The resulting value range is the union of the operand ranges */\n   vr->deep_copy (vr0);\n@@ -997,14 +1011,14 @@ vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n   else if (TREE_CODE (op0) == INTEGER_CST)\n     vr0.set (op0);\n   else\n-    vr0.set_varying ();\n+    vr0.set_varying (TREE_TYPE (op0));\n \n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *get_value_range (op1);\n   else if (TREE_CODE (op1) == INTEGER_CST)\n     vr1.set (op1);\n   else\n-    vr1.set_varying ();\n+    vr1.set_varying (TREE_TYPE (op1));\n \n   tree vr0min = vr0.min (), vr0max = vr0.max ();\n   tree vr1min = vr1.min (), vr1max = vr1.max ();\n@@ -1332,7 +1346,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t  if (vr->kind () == VR_RANGE\n \t      && (vr->min () == vr->max ()\n \t\t  || operand_equal_p (vr->min (), vr->max (), 0)))\n-\t    vr->set_varying ();\n+\t    vr->set_varying (vr->type ());\n \t  return;\n \t}\n     }\n@@ -1388,7 +1402,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\t\tvr->set (build_int_cst (type, ovf));\n \t\t      else if (TYPE_PRECISION (type) == 1\n \t\t\t       && !TYPE_UNSIGNED (type))\n-\t\t\tvr->set_varying ();\n+\t\t\tvr->set_varying (type);\n \t\t      else\n \t\t\tvr->set (VR_RANGE, build_int_cst (type, 0),\n \t\t\t\t build_int_cst (type, 1));\n@@ -1433,7 +1447,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n       vr->equiv_clear ();\n     }\n   else\n-    vr->set_varying ();\n+    vr->set_varying (type);\n }\n \n \n@@ -1469,7 +1483,7 @@ vr_values::extract_range_from_assignment (value_range *vr, gassign *stmt)\n \t   && is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n     vr->set (gimple_assign_rhs1 (stmt));\n   else\n-    vr->set_varying ();\n+    vr->set_varying (TREE_TYPE (gimple_assign_lhs (stmt)));\n \n   if (vr->varying_p ())\n     extract_range_basic (vr, stmt);\n@@ -1938,7 +1952,7 @@ vr_values::dump_all_value_ranges (FILE *file)\n vr_values::vr_values () : vrp_value_range_pool (\"Tree VRP value ranges\")\n {\n   values_propagated = false;\n-  num_vr_values = num_ssa_names;\n+  num_vr_values = num_ssa_names * 2;\n   vr_value = XCNEWVEC (value_range *, num_vr_values);\n   vr_phi_edge_counts = XCNEWVEC (int, num_ssa_names);\n   bitmap_obstack_initialize (&vrp_equiv_obstack);\n@@ -2875,7 +2889,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t\t      vr_arg_tem.set (vr_arg_->kind (), vr_arg_->min (),\n \t\t\t\t      vr_arg_->max (), NULL);\n \t\t      if (vr_arg_tem.symbolic_p ())\n-\t\t\tvr_arg_tem.set_varying ();\n+\t\t\tvr_arg_tem.set_varying (TREE_TYPE (arg));\n \t\t    }\n \t\t  else\n \t\t    vr_arg = vr_arg_;\n@@ -2997,7 +3011,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n   goto update_range;\n \n varying:\n-  vr_result->set_varying ();\n+  vr_result->set_varying (TREE_TYPE (lhs));\n \n scev_check:\n   /* If this is a loop PHI node SCEV may known more about its value-range.\n@@ -3018,7 +3032,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t   || compare_values (vr_result->min (), vr_result->max ()) > 0))\n     ;\n   else\n-    vr_result->set_varying ();\n+    vr_result->set_varying (TREE_TYPE (lhs));\n \n   /* If the new range is different than the previous value, keep\n      iterating.  */"}]}