{"sha": "74f4ee8d38f5aa58e4722725f3016f6420d4654b", "node_id": "C_kwDOANBUbNoAKDc0ZjRlZThkMzhmNWFhNThlNDcyMjcyNWYzMDE2ZjY0MjBkNDY1NGI", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-05-03T11:45:45Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-05-04T12:13:12Z"}, "message": "Take advantage of OBJ_TYPE_REF'S in dyn calls\n\nOBJ_TYPE_REF's are the gcc nodes that signify that this is a virtual call\nwhich gives a hint to the optimizers for devirtualization.\n\nFixes #996\nFixes #854", "tree": {"sha": "be164dafb951987e1e8a25ac3be87c9555d0b6b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be164dafb951987e1e8a25ac3be87c9555d0b6b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74f4ee8d38f5aa58e4722725f3016f6420d4654b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74f4ee8d38f5aa58e4722725f3016f6420d4654b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74f4ee8d38f5aa58e4722725f3016f6420d4654b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74f4ee8d38f5aa58e4722725f3016f6420d4654b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b9e1226cfbc4137a881a71c5e6f904fc5b364e"}], "stats": {"total": 155, "additions": 83, "deletions": 72}, "files": [{"sha": "41f8c0a5ce4497d6c6af5db5e85f0d3d966592a3", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f4ee8d38f5aa58e4722725f3016f6420d4654b/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f4ee8d38f5aa58e4722725f3016f6420d4654b/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=74f4ee8d38f5aa58e4722725f3016f6420d4654b", "patch": "@@ -573,6 +573,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       receiver = p->resolve ();\n     }\n \n+  tree fn_expr = error_mark_node;\n   if (is_dyn_dispatch)\n     {\n       const TyTy::DynamicObjectType *dyn\n@@ -582,17 +583,20 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       for (auto &arg : expr.get_arguments ())\n \targuments.push_back (arg.get ());\n \n-      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, self,\n-\t\t\t\t\t      arguments, expr.get_locus ());\n-      return;\n+      fn_expr\n+\t= get_fn_addr_from_dyn (dyn, receiver, fntype, self, expr.get_locus ());\n+      self = get_receiver_from_dyn (dyn, receiver, fntype, self,\n+\t\t\t\t    expr.get_locus ());\n+    }\n+  else\n+    {\n+      // lookup compiled functions since it may have already been compiled\n+      HIR::PathExprSegment method_name = expr.get_method_name ();\n+      HIR::PathIdentSegment segment_name = method_name.get_segment ();\n+      fn_expr\n+\t= resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t\t  expr.get_mappings (), expr.get_locus ());\n     }\n-\n-  // lookup compiled functions since it may have already been compiled\n-  HIR::PathExprSegment method_name = expr.get_method_name ();\n-  HIR::PathIdentSegment segment_name = method_name.get_segment ();\n-  tree fn_expr\n-    = resolve_method_address (fntype, ref, receiver, segment_name,\n-\t\t\t      expr.get_mappings (), expr.get_locus ());\n \n   // lookup the autoderef mappings\n   std::vector<Resolver::Adjustment> *adjustments = nullptr;\n@@ -639,11 +643,10 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n }\n \n tree\n-CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n-\t\t\t\t\tTyTy::BaseType *receiver,\n-\t\t\t\t\tTyTy::FnType *fntype, tree receiver_ref,\n-\t\t\t\t\tstd::vector<HIR::Expr *> &arguments,\n-\t\t\t\t\tLocation expr_locus)\n+CompileExpr::get_fn_addr_from_dyn (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t   TyTy::BaseType *receiver,\n+\t\t\t\t   TyTy::FnType *fntype, tree receiver_ref,\n+\t\t\t\t   Location expr_locus)\n {\n   size_t offs = 0;\n   const Resolver::TraitItemReference *ref = nullptr;\n@@ -680,32 +683,49 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n       receiver_ref = indirect;\n     }\n \n-  // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n-  tree self_argument\n-    = ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n-\t\t\t\t\t\t    expr_locus);\n+  // cast it to the correct fntype\n+  tree expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+  tree idx = build_int_cst (size_type_node, offs);\n \n-  // access the vtable for the fn\n-  tree fn_vtable_access\n-    = ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n+  tree vtable_ptr\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, 1,\n \t\t\t\t\t\t    expr_locus);\n+  tree vtable_array_access = build4_loc (expr_locus.gcc_location (), ARRAY_REF,\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (vtable_ptr)),\n+\t\t\t\t\t vtable_ptr, idx, NULL_TREE, NULL_TREE);\n \n-  // cast it to the correct fntype\n-  tree expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n-  tree fn_convert_expr\n-    = ctx->get_backend ()->convert_expression (expected_fntype,\n-\t\t\t\t\t       fn_vtable_access, expr_locus);\n+  tree vcall\n+    = build3_loc (expr_locus.gcc_location (), OBJ_TYPE_REF, expected_fntype,\n+\t\t  vtable_array_access, receiver_ref, idx);\n+\n+  return vcall;\n+}\n+\n+tree\n+CompileExpr::get_receiver_from_dyn (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t    TyTy::BaseType *receiver,\n+\t\t\t\t    TyTy::FnType *fntype, tree receiver_ref,\n+\t\t\t\t    Location expr_locus)\n+{\n+  // get any indirection sorted out\n+  if (receiver->get_kind () == TyTy::TypeKind::REF)\n \n-  std::vector<tree> args;\n-  args.push_back (self_argument);\n-  for (auto &argument : arguments)\n     {\n-      tree compiled_expr = CompileExpr::Compile (argument, ctx);\n-      args.push_back (compiled_expr);\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+      auto indirect_ty = r->get_base ();\n+      tree indrect_compiled_tyty\n+\t= TyTyResolveCompile::compile (ctx, indirect_ty);\n+\n+      tree indirect\n+\t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n+\t\t\t\t\t\t    receiver_ref, true,\n+\t\t\t\t\t\t    expr_locus);\n+      receiver_ref = indirect;\n     }\n \n-  return ctx->get_backend ()->call_expression (fn_convert_expr, args, nullptr,\n-\t\t\t\t\t       expr_locus);\n+  // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n+  return ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n+\t\t\t\t\t\t       expr_locus);\n }\n \n tree\n@@ -832,28 +852,13 @@ CompileExpr::resolve_operator_overload (\n \t\t\t\t\t   &receiver);\n   rust_assert (ok);\n \n-  bool is_dyn_dispatch\n-    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n   bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n   if (is_generic_receiver)\n     {\n       TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n       receiver = p->resolve ();\n     }\n \n-  if (is_dyn_dispatch)\n-    {\n-      const TyTy::DynamicObjectType *dyn\n-\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n-\n-      std::vector<HIR::Expr *> arguments;\n-      if (rhs_expr != nullptr) // can be null for negation_expr (unary ones)\n-\targuments.push_back (rhs_expr);\n-\n-      return compile_dyn_dispatch_call (dyn, receiver, fntype, lhs, arguments,\n-\t\t\t\t\texpr.get_locus ());\n-    }\n-\n   // lookup compiled functions since it may have already been compiled\n   HIR::PathIdentSegment segment_name (\n     Analysis::RustLangItem::ToString (lang_item_type));"}, {"sha": "bb81d4ed7bc6eaed971abd1340c5c6cad0d29639", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f4ee8d38f5aa58e4722725f3016f6420d4654b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f4ee8d38f5aa58e4722725f3016f6420d4654b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=74f4ee8d38f5aa58e4722725f3016f6420d4654b", "patch": "@@ -789,11 +789,13 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n   void visit (HIR::AsyncBlockExpr &) override {}\n \n protected:\n-  tree compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n-\t\t\t\t  TyTy::BaseType *receiver,\n-\t\t\t\t  TyTy::FnType *fntype, tree receiver_ref,\n-\t\t\t\t  std::vector<HIR::Expr *> &arguments,\n-\t\t\t\t  Location expr_locus);\n+  tree get_fn_addr_from_dyn (const TyTy::DynamicObjectType *dyn,\n+\t\t\t     TyTy::BaseType *receiver, TyTy::FnType *fntype,\n+\t\t\t     tree receiver_ref, Location expr_locus);\n+\n+  tree get_receiver_from_dyn (const TyTy::DynamicObjectType *dyn,\n+\t\t\t      TyTy::BaseType *receiver, TyTy::FnType *fntype,\n+\t\t\t      tree receiver_ref, Location expr_locus);\n \n   tree resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \t\t\t       TyTy::BaseType *receiver,"}, {"sha": "03c2ca487f2b050e49ebc64de3e19cec4ad117bc", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f4ee8d38f5aa58e4722725f3016f6420d4654b/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f4ee8d38f5aa58e4722725f3016f6420d4654b/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=74f4ee8d38f5aa58e4722725f3016f6420d4654b", "patch": "@@ -532,25 +532,19 @@ TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n \n   tree uint = ctx->get_backend ()->integer_type (\n     true, ctx->get_backend ()->get_pointer_size ());\n-  tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+  tree uintptr_ty = build_pointer_type (uint);\n \n-  Backend::typed_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n+  Backend::typed_identifier f (\"pointer\", uintptr_ty,\n \t\t\t       ctx->get_mappings ()->lookup_location (\n \t\t\t\t type.get_ty_ref ()));\n   fields.push_back (std::move (f));\n \n-  for (size_t i = 0; i < items.size (); i++)\n-    {\n-      // mrustc seems to make a vtable consisting of uintptr's\n-      tree uint = ctx->get_backend ()->integer_type (\n-\ttrue, ctx->get_backend ()->get_pointer_size ());\n-      tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n-\n-      Backend::typed_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n-\t\t\t\t   ctx->get_mappings ()->lookup_location (\n-\t\t\t\t     type.get_ty_ref ()));\n-      fields.push_back (std::move (f));\n-    }\n+  tree vtable_size = build_int_cst (size_type_node, items.size ());\n+  tree vtable_type = ctx->get_backend ()->array_type (uintptr_ty, vtable_size);\n+  Backend::typed_identifier vtf (\"vtable\", vtable_type,\n+\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t   type.get_ty_ref ()));\n+  fields.push_back (std::move (vtf));\n \n   tree type_record = ctx->get_backend ()->struct_type (fields);\n   tree named_struct"}, {"sha": "49155d226404d864554376db56d0d207db1c5596", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f4ee8d38f5aa58e4722725f3016f6420d4654b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f4ee8d38f5aa58e4722725f3016f6420d4654b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=74f4ee8d38f5aa58e4722725f3016f6420d4654b", "patch": "@@ -312,6 +312,9 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n \t\t\t\t      Location locus)\n {\n   tree dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n+  tree dynamic_object_fields = TYPE_FIELDS (dynamic_object);\n+  tree vtable_field = DECL_CHAIN (dynamic_object_fields);\n+  rust_assert (TREE_CODE (TREE_TYPE (vtable_field)) == ARRAY_TYPE);\n \n   //' this assumes ordering and current the structure is\n   // __trait_object_ptr\n@@ -326,8 +329,10 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n       = address_expression (compiled_ref,\n \t\t\t    build_pointer_type (TREE_TYPE (compiled_ref)),\n \t\t\t    locus);\n-  std::vector<tree> vals;\n-  vals.push_back (address_of_compiled_ref);\n+\n+  std::vector<tree> vtable_ctor_elems;\n+  std::vector<unsigned long> vtable_ctor_idx;\n+  unsigned long i = 0;\n   for (auto &bound : ty->get_object_items ())\n     {\n       const Resolver::TraitItemReference *item = bound.first;\n@@ -336,11 +341,16 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n       auto address = compute_address_for_trait_item (item, predicate,\n \t\t\t\t\t\t     probed_bounds_for_receiver,\n \t\t\t\t\t\t     actual, actual, locus);\n-      vals.push_back (address);\n+      vtable_ctor_elems.push_back (address);\n+      vtable_ctor_idx.push_back (i++);\n     }\n \n+  tree vtable_ctor = ctx->get_backend ()->array_constructor_expression (\n+    TREE_TYPE (vtable_field), vtable_ctor_idx, vtable_ctor_elems, locus);\n+\n+  std::vector<tree> dyn_ctor = {address_of_compiled_ref, vtable_ctor};\n   return ctx->get_backend ()->constructor_expression (dynamic_object, false,\n-\t\t\t\t\t\t      vals, -1, locus);\n+\t\t\t\t\t\t      dyn_ctor, -1, locus);\n }\n \n tree"}]}