{"sha": "71d9e9f213d295971b7cb339ee18513bcbf45e2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkOWU5ZjIxM2QyOTU5NzFiN2NiMzM5ZWUxODUxM2JjYmY0NWUyZA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonber@gnat.com", "date": "2004-10-04T14:57:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-04T14:57:31Z"}, "message": "sem_ch3.adb (Build_Derived_Record_Type): Set First/Last entity of class_wide type after component list has been inherited.\n\n2004-10-04  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch3.adb (Build_Derived_Record_Type): Set First/Last entity of\n\tclass_wide type after component list has been inherited.\n\nFrom-SVN: r88497", "tree": {"sha": "04a820b992fdc23a86e99c715a7dd8a2e27546c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04a820b992fdc23a86e99c715a7dd8a2e27546c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71d9e9f213d295971b7cb339ee18513bcbf45e2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d9e9f213d295971b7cb339ee18513bcbf45e2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d9e9f213d295971b7cb339ee18513bcbf45e2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d9e9f213d295971b7cb339ee18513bcbf45e2d/comments", "author": null, "committer": null, "parents": [{"sha": "0b525beee7461b1713595233bc68edc4ef8ad6a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b525beee7461b1713595233bc68edc4ef8ad6a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b525beee7461b1713595233bc68edc4ef8ad6a7"}], "stats": {"total": 423, "additions": 191, "deletions": 232}, "files": [{"sha": "028e9a3a64ae87c49a6f773335669107b9cbcc34", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d9e9f213d295971b7cb339ee18513bcbf45e2d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d9e9f213d295971b7cb339ee18513bcbf45e2d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=71d9e9f213d295971b7cb339ee18513bcbf45e2d", "patch": "@@ -1,3 +1,8 @@\n+2004-10-04  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Record_Type): Set First/Last entity of\n+\tclass_wide type after component list has been inherited.\n+\n 2004-10-04  Ed Schonberg  <schonberg@gnat.com>\n \n \t* sem_ch12.adb (Check_Generic_Actuals): New predicate"}, {"sha": "c48f3b12ffab941a8c001a5bad38284a7d4fc931", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 186, "deletions": 232, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d9e9f213d295971b7cb339ee18513bcbf45e2d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d9e9f213d295971b7cb339ee18513bcbf45e2d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=71d9e9f213d295971b7cb339ee18513bcbf45e2d", "patch": "@@ -140,9 +140,9 @@ package body Sem_Ch3 is\n    --  an anonymous base type, and propagate constraint to subtype if needed.\n \n    procedure Build_Derived_Private_Type\n-     (N            : Node_Id;\n-      Parent_Type  : Entity_Id;\n-      Derived_Type : Entity_Id;\n+     (N             : Node_Id;\n+      Parent_Type   : Entity_Id;\n+      Derived_Type  : Entity_Id;\n       Is_Completion : Boolean;\n       Derive_Subps  : Boolean := True);\n    --  Subsidiary procedure to Build_Derived_Type. This procedure is complex\n@@ -758,7 +758,7 @@ package body Sem_Ch3 is\n      (T_Name : Entity_Id;\n       T_Def  : Node_Id)\n    is\n-      Formals : constant List_Id   := Parameter_Specifications (T_Def);\n+      Formals : constant List_Id := Parameter_Specifications (T_Def);\n       Formal  : Entity_Id;\n \n       Desig_Type : constant Entity_Id :=\n@@ -801,7 +801,6 @@ package body Sem_Ch3 is\n          Formal := First_Formal (Desig_Type);\n \n          while Present (Formal) loop\n-\n             if Ekind (Formal) /= E_In_Parameter\n               and then Nkind (T_Def) = N_Access_Function_Definition\n             then\n@@ -961,7 +960,6 @@ package body Sem_Ch3 is\n       function Contains_POC (Constr : Node_Id) return Boolean is\n       begin\n          case Nkind (Constr) is\n-\n             when N_Attribute_Reference =>\n                return Attribute_Name (Constr) = Name_Access\n                         and\n@@ -976,6 +974,7 @@ package body Sem_Ch3 is\n             when N_Index_Or_Discriminant_Constraint =>\n                declare\n                   IDC : Node_Id := First (Constraints (Constr));\n+\n                begin\n                   while Present (IDC) loop\n \n@@ -993,7 +992,7 @@ package body Sem_Ch3 is\n \n             when N_Range =>\n                return Denotes_Discriminant (Low_Bound (Constr))\n-                        or\n+                        or else\n                       Denotes_Discriminant (High_Bound (Constr));\n \n             when N_Range_Constraint =>\n@@ -1105,7 +1104,7 @@ package body Sem_Ch3 is\n       if Present (Subtype_Indication (Component_Definition (N))) then\n          declare\n             Sindic : constant Node_Id :=\n-               Subtype_Indication (Component_Definition (N));\n+                       Subtype_Indication (Component_Definition (N));\n \n          begin\n             if Nkind (Sindic) = N_Subtype_Indication\n@@ -1118,7 +1117,7 @@ package body Sem_Ch3 is\n       end if;\n \n       --  Ada 2005 (AI-231): Propagate the null-excluding attribute and carry\n-      --  out some static checks\n+      --  out some static checks.\n \n       if Ada_Version >= Ada_05\n         and then (Null_Exclusion_Present (Component_Definition (N))\n@@ -1135,7 +1134,7 @@ package body Sem_Ch3 is\n       P := Private_Component (T);\n \n       if Present (P) then\n-         --  Check for circular definitions.\n+         --  Check for circular definitions\n \n          if P = Any_Type then\n             Set_Etype (Id, Any_Type);\n@@ -1651,6 +1650,7 @@ package body Sem_Ch3 is\n          Set_Completion_Referenced (Id);\n \n          if Error_Posted (N) then\n+\n             --  Type mismatch or illegal redeclaration, Do not analyze\n             --  expression to avoid cascaded errors.\n \n@@ -1782,7 +1782,7 @@ package body Sem_Ch3 is\n             Check_Initialization (T, E);\n          end if;\n \n-         Set_Etype (Id, T);             --  may be overridden later on.\n+         Set_Etype (Id, T);             --  may be overridden later on\n          Resolve (E, T);\n          Check_Unset_Reference (E);\n \n@@ -1814,7 +1814,8 @@ package body Sem_Ch3 is\n \n       if Is_Abstract (T) and then Comes_From_Source (N) then\n          Error_Msg_N (\"type of object cannot be abstract\",\n-           Object_Definition (N));\n+                      Object_Definition (N));\n+\n          if Is_CPP_Class (T) then\n             Error_Msg_NE (\"\\} may need a cpp_constructor\",\n               Object_Definition (N), T);\n@@ -1916,7 +1917,7 @@ package body Sem_Ch3 is\n \n          elsif Nkind (E) = N_Raise_Constraint_Error then\n \n-            --  Aggregate is statically illegal. Place back in declaration\n+            --  Aggregate is statically illegal. Place back in declaration.\n \n             Set_Expression (N, E);\n             Set_No_Initialization (N, False);\n@@ -2028,7 +2029,6 @@ package body Sem_Ch3 is\n       then\n          if not Is_Library_Level_Entity (Id) then\n             Check_Restriction (No_Nested_Finalization, N);\n-\n          else\n             Validate_Controlled_Object (Id);\n          end if;\n@@ -2112,7 +2112,6 @@ package body Sem_Ch3 is\n \n          if Is_Library_Level_Entity (Id) then\n             Check_Restriction (Max_Tasks, N, Count_Tasks (Etype (Id)));\n-\n          else\n             Check_Restriction (Max_Tasks, N);\n             Check_Restriction (No_Task_Hierarchy, N);\n@@ -2125,9 +2124,7 @@ package body Sem_Ch3 is\n          --  will be raised at run-time since we can't have two tasks with\n          --  entries at the same address.\n \n-         if Is_Task_Type (Etype (Id))\n-           and then More_Ids (N)\n-         then\n+         if Is_Task_Type (Etype (Id)) and then More_Ids (N) then\n             declare\n                E : Entity_Id;\n \n@@ -2165,7 +2162,6 @@ package body Sem_Ch3 is\n       then\n          declare\n             Val : constant Node_Id := Constant_Value (Entity (E));\n-\n          begin\n             if Present (Val)\n               and then Nkind (Val) = N_String_Literal\n@@ -2229,7 +2225,6 @@ package body Sem_Ch3 is\n \n    procedure Analyze_Others_Choice (N : Node_Id) is\n       pragma Warnings (Off, N);\n-\n    begin\n       null;\n    end Analyze_Others_Choice;\n@@ -2240,7 +2235,6 @@ package body Sem_Ch3 is\n \n    procedure Analyze_Per_Use_Expression (N : Node_Id; T : Entity_Id) is\n       Save_In_Default_Expression : constant Boolean := In_Default_Expression;\n-\n    begin\n       In_Default_Expression := True;\n       Pre_Analyze_And_Resolve (N, T);\n@@ -3040,7 +3034,6 @@ package body Sem_Ch3 is\n       end if;\n \n       Nb_Index := 1;\n-\n       while Present (Index) loop\n          Analyze (Index);\n          Make_Index (Index, P, Related_Id, Nb_Index);\n@@ -3581,7 +3574,6 @@ package body Sem_Ch3 is\n         (Derived_Type, Corresponding_Record_Type (Parent_Type));\n \n       if Constraint_Present then\n-\n          if not Has_Discriminants (Parent_Type) then\n             Error_Msg_N (\"untagged parent must have discriminants\", N);\n \n@@ -3643,9 +3635,7 @@ package body Sem_Ch3 is\n       end if;\n \n       if Present (Discriminant_Specifications (N)) then\n-\n          Old_Disc := First_Discriminant (Parent_Type);\n-\n          while Present (Old_Disc) loop\n \n             if No (Next_Entity (Old_Disc))\n@@ -3824,10 +3814,9 @@ package body Sem_Ch3 is\n          --  must be implicitly converted to the new type.\n \n          if Nkind (Indic) = N_Subtype_Indication then\n-\n             declare\n-               R   : constant Node_Id :=\n-                       Range_Expression (Constraint (Indic));\n+               R : constant Node_Id :=\n+                     Range_Expression (Constraint (Indic));\n \n             begin\n                if Nkind (R) = N_Range then\n@@ -3856,7 +3845,6 @@ package body Sem_Ch3 is\n                         Prefix =>\n                           New_Occurrence_Of (Entity (Prefix (R)), Loc)));\n                end if;\n-\n             end;\n \n          else\n@@ -3932,7 +3920,7 @@ package body Sem_Ch3 is\n       Parent_Base   : constant Entity_Id  := Base_Type (Parent_Type);\n       No_Constraint : constant Boolean    := Nkind (Indic) /=\n                                                   N_Subtype_Indication;\n-      Implicit_Base    : Entity_Id;\n+      Implicit_Base : Entity_Id;\n \n       Lo : Node_Id;\n       Hi : Node_Id;\n@@ -4120,7 +4108,7 @@ package body Sem_Ch3 is\n       --------------------\n \n       procedure Copy_And_Build is\n-         Full_N  : Node_Id;\n+         Full_N : Node_Id;\n \n       begin\n          if Ekind (Parent_Type) in Record_Kind\n@@ -4149,7 +4137,6 @@ package body Sem_Ch3 is\n          return;\n \n       elsif Has_Discriminants (Parent_Type) then\n-\n          if Present (Full_View (Parent_Type)) then\n             if not Is_Completion then\n \n@@ -4173,9 +4160,8 @@ package body Sem_Ch3 is\n                --  serve as the underlying full view of the derived type.\n \n                if No (Discriminant_Specifications (N)) then\n-\n-                  if Nkind (Subtype_Indication (Type_Definition (N)))\n-                    = N_Subtype_Indication\n+                  if Nkind (Subtype_Indication (Type_Definition (N))) =\n+                                                        N_Subtype_Indication\n                   then\n                      Build_Underlying_Full_View (N, Derived_Type, Parent_Type);\n \n@@ -4220,8 +4206,8 @@ package body Sem_Ch3 is\n             if not Is_Tagged_Type (Parent_Type) then\n                Build_Derived_Record_Type\n                  (Full_Decl, Parent_Type, Full_Der, False);\n-            else\n \n+            else\n                --  If full view of parent is tagged, the completion\n                --  inherits the proper primitive operations.\n \n@@ -4334,8 +4320,8 @@ package body Sem_Ch3 is\n       else\n          --  Untagged type, No discriminants on either view\n \n-         if Nkind (Subtype_Indication (Type_Definition (N)))\n-           = N_Subtype_Indication\n+         if Nkind (Subtype_Indication (Type_Definition (N))) =\n+                                                   N_Subtype_Indication\n          then\n             Error_Msg_N\n               (\"illegal constraint on type without discriminants\", N);\n@@ -4367,17 +4353,17 @@ package body Sem_Ch3 is\n          --  view of the parent type. In order to get proper visibility,\n          --  we install the parent scope and its declarations.\n \n-         --  ??? if the parent is untagged private and its\n-         --  completion is tagged, this mechanism will not\n-         --  work because we cannot derive from the tagged\n-         --  full view unless we have an extension\n+         --  ??? if the parent is untagged private and its completion is\n+         --  tagged, this mechanism will not work because we cannot derive\n+         --  from the tagged full view unless we have an extension\n \n          if Present (Full_View (Parent_Type))\n            and then not Is_Tagged_Type (Full_View (Parent_Type))\n            and then not Is_Completion\n          then\n-            Full_Der := Make_Defining_Identifier (Sloc (Derived_Type),\n-                                              Chars (Derived_Type));\n+            Full_Der :=\n+              Make_Defining_Identifier (Sloc (Derived_Type),\n+                Chars => Chars (Derived_Type));\n             Set_Is_Itype (Full_Der);\n             Set_Has_Private_Declaration (Full_Der);\n             Set_Has_Private_Declaration (Derived_Type);\n@@ -4483,7 +4469,7 @@ package body Sem_Ch3 is\n    -- Build_Derived_Record_Type --\n    -------------------------------\n \n-   --  1. INTRODUCTION.\n+   --  1. INTRODUCTION\n \n    --  Ideally we would like to use the same model of type derivation for\n    --  tagged and untagged record types. Unfortunately this is not quite\n@@ -4519,7 +4505,7 @@ package body Sem_Ch3 is\n    --  semantic rules are somewhat different). We will explain what differs\n    --  below.\n \n-   --  2. DISCRIMINANTS UNDER INHERITANCE.\n+   --  2. DISCRIMINANTS UNDER INHERITANCE\n \n    --  The semantic rules governing the discriminants of derived types are\n    --  quite subtle.\n@@ -4624,7 +4610,7 @@ package body Sem_Ch3 is\n    --                 D2 in T3   empty    itself    yes\n    --                 D3 in T3   empty    itself    yes\n \n-   --  4. DISCRIMINANTS IN DERIVED TAGGED RECORD TYPES.\n+   --  4. DISCRIMINANTS IN DERIVED TAGGED RECORD TYPES\n \n    --  Type derivation for tagged types is fairly straightforward. if no\n    --  discriminants are specified by the derived type, these are inherited\n@@ -4637,7 +4623,7 @@ package body Sem_Ch3 is\n    --           type T1 is new R with null record;\n    --           type T2 (X1, X2: Int) is new T1 (X2, 88, X1) with null record;\n \n-   --  are changed into :\n+   --  are changed into:\n \n    --           type T1 (D1, D2, D3 : Int) is new R (D1, D2, D3) with record\n    --              _parent : R (D1, D2, D3);\n@@ -4663,7 +4649,7 @@ package body Sem_Ch3 is\n    --                 X1 in T2  D3 in T1   D3 in R   no\n    --                 X2 in T2  D1 in T1   D1 in R   no\n \n-   --  5. FIRST TRANSFORMATION FOR DERIVED RECORDS.\n+   --  5. FIRST TRANSFORMATION FOR DERIVED RECORDS\n    --\n    --  Regardless of whether we dealing with a tagged or untagged type\n    --  we will transform all derived type declarations of the form\n@@ -4752,7 +4738,7 @@ package body Sem_Ch3 is\n    --  above transformation will entail. This is done directly in routine\n    --  Inherit_Components.\n \n-   --  7. TYPE DERIVATION AND COMPONENT INHERITANCE.\n+   --  7. TYPE DERIVATION AND COMPONENT INHERITANCE\n \n    --  In both tagged and untagged derived types, regular non discriminant\n    --  components are inherited in the derived type from the parent type. In\n@@ -4785,7 +4771,7 @@ package body Sem_Ch3 is\n    --  For T2, for instance, this has the effect of replacing String (D1 .. D2)\n    --  by String (1 .. X).\n \n-   --  8. TYPE DERIVATION IN PRIVATE TYPE EXTENSIONS.\n+   --  8. TYPE DERIVATION IN PRIVATE TYPE EXTENSIONS\n \n    --  We explain here the rules governing private type extensions relevant to\n    --  type derivation. These rules are explained on the following example:\n@@ -4851,7 +4837,7 @@ package body Sem_Ch3 is\n    --  P's constraints on A's discriminants must statically match those\n    --  imposed by (...).\n \n-   --  9. IMPLEMENTATION OF TYPE DERIVATION FOR PRIVATE EXTENSIONS.\n+   --  9. IMPLEMENTATION OF TYPE DERIVATION FOR PRIVATE EXTENSIONS\n \n    --  The full view of a private extension is handled exactly as described\n    --  above. The model chose for the private view of a private extension\n@@ -4908,7 +4894,7 @@ package body Sem_Ch3 is\n    --  ??? Are there are other uncomfortable cases that we will have to\n    --      deal with.\n \n-   --  10. RECORD_TYPE_WITH_PRIVATE complications.\n+   --  10. RECORD_TYPE_WITH_PRIVATE complications\n \n    --  Types that are derived from a visible record type and have a private\n    --  extension present other peculiarities. They behave mostly like private\n@@ -4928,23 +4914,21 @@ package body Sem_Ch3 is\n    is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Parent_Base  : Entity_Id;\n-\n       Type_Def     : Node_Id;\n       Indic        : Node_Id;\n-\n       Discrim      : Entity_Id;\n       Last_Discrim : Entity_Id;\n       Constrs      : Elist_Id;\n-      Discs        : Elist_Id := New_Elmt_List;\n+\n+      Discs : Elist_Id := New_Elmt_List;\n       --  An empty Discs list means that there were no constraints in the\n       --  subtype indication or that there was an error processing it.\n \n-      Assoc_List   : Elist_Id;\n-      New_Discrs   : Elist_Id;\n-\n-      New_Base     : Entity_Id;\n-      New_Decl     : Node_Id;\n-      New_Indic    : Node_Id;\n+      Assoc_List : Elist_Id;\n+      New_Discrs : Elist_Id;\n+      New_Base   : Entity_Id;\n+      New_Decl   : Node_Id;\n+      New_Indic  : Node_Id;\n \n       Is_Tagged          : constant Boolean := Is_Tagged_Type (Parent_Type);\n       Discriminant_Specs : constant Boolean :=\n@@ -4989,7 +4973,7 @@ package body Sem_Ch3 is\n          Init_Size_Align (Derived_Type);\n       end if;\n \n-      --  STEP 0a: figure out what kind of derived type declaration we have.\n+      --  STEP 0a: figure out what kind of derived type declaration we have\n \n       if Private_Extension then\n          Type_Def := N;\n@@ -5046,7 +5030,7 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  STEP 0b: If needed, apply transformation given in point 5. above.\n+      --  STEP 0b: If needed, apply transformation given in point 5. above\n \n       if not Private_Extension\n         and then Has_Discriminants (Parent_Type)\n@@ -5162,15 +5146,13 @@ package body Sem_Ch3 is\n \n          Analyze (N);\n \n-         --  Derivation of subprograms must be delayed until the\n-         --  full subtype has been established to ensure proper\n-         --  overriding of subprograms inherited by full types.\n-         --  If the derivations occurred as part of the call to\n-         --  Build_Derived_Type above, then the check for type\n-         --  conformance would fail because earlier primitive\n-         --  subprograms could still refer to the full type prior\n-         --  the change to the new subtype and hence wouldn't\n-         --  match the new base type created here.\n+         --  Derivation of subprograms must be delayed until the full subtype\n+         --  has been established to ensure proper overriding of subprograms\n+         --  inherited by full types. If the derivations occurred as part of\n+         --  the call to Build_Derived_Type above, then the check for type\n+         --  conformance would fail because earlier primitive subprograms\n+         --  could still refer to the full type prior the change to the new\n+         --  subtype and hence would not match the new base type created here.\n \n          Derive_Subprograms (Parent_Type, Derived_Type);\n \n@@ -5193,6 +5175,7 @@ package body Sem_Ch3 is\n       --  STEP 1a: perform preliminary actions/checks for derived tagged types\n \n       if Is_Tagged then\n+\n          --  The parent type is frozen for non-private extensions (RM 13.14(7))\n \n          if not Private_Extension then\n@@ -5238,7 +5221,7 @@ package body Sem_Ch3 is\n       --  conformance. However, we must remove any existing components that\n       --  were inherited from the parent (and attached in Copy_And_Swap)\n       --  because the full type inherits all appropriate components anyway, and\n-      --  we don't want the partial view's components interfering.\n+      --  we do not want the partial view's components interfering.\n \n       if Has_Discriminants (Derived_Type) and then Discriminant_Specs then\n          Discrim := First_Discriminant (Derived_Type);\n@@ -5269,7 +5252,7 @@ package body Sem_Ch3 is\n       Set_Is_Tagged_Type    (Derived_Type, Is_Tagged);\n       Set_Is_Limited_Record (Derived_Type, Is_Limited_Record (Parent_Type));\n \n-      --  STEP 2a: process discriminants of derived type if any.\n+      --  STEP 2a: process discriminants of derived type if any\n \n       New_Scope (Derived_Type);\n \n@@ -5314,7 +5297,6 @@ package body Sem_Ch3 is\n             --  discriminants cannot rename old ones (implied by [7.3(13)]).\n \n             Discrim := First_Discriminant (Derived_Type);\n-\n             while Present (Discrim) loop\n                if not Is_Tagged\n                  and then not Present (Corresponding_Discriminant (Discrim))\n@@ -5422,7 +5404,7 @@ package body Sem_Ch3 is\n          Set_Is_Constrained\n            (Derived_Type,\n             not (Inherit_Discrims\n-                 or else Has_Unknown_Discriminants (Derived_Type)));\n+                   or else Has_Unknown_Discriminants (Derived_Type)));\n       end if;\n \n       --  STEP 3: initialize fields of derived type.\n@@ -5539,8 +5521,8 @@ package body Sem_Ch3 is\n       if not Is_Tagged then\n \n          --  Discriminant_Constraint (Derived_Type) has been properly\n-         --  constructed. Save it and temporarily set it to Empty because we do\n-         --  not want the call to New_Copy_Tree below to mess this list.\n+         --  constructed. Save it and temporarily set it to Empty because we\n+         --  do not want the call to New_Copy_Tree below to mess this list.\n \n          if Has_Discriminants (Derived_Type) then\n             Save_Discr_Constr := Discriminant_Constraint (Derived_Type);\n@@ -5549,9 +5531,9 @@ package body Sem_Ch3 is\n             Save_Discr_Constr := No_Elist;\n          end if;\n \n-         --  Save the Etype field of Derived_Type. It is correctly set now, but\n-         --  the call to New_Copy tree may remap it to point to itself, which\n-         --  is not what we want. Ditto for the Next_Entity field.\n+         --  Save the Etype field of Derived_Type. It is correctly set now,\n+         --  but the call to New_Copy tree may remap it to point to itself,\n+         --  which is not what we want. Ditto for the Next_Entity field.\n \n          Save_Etype       := Etype (Derived_Type);\n          Save_Next_Entity := Next_Entity (Derived_Type);\n@@ -5560,7 +5542,7 @@ package body Sem_Ch3 is\n          --  stored discriminants in the Derived_Type. It is fundamental that\n          --  no types or itypes with discriminants other than the stored\n          --  discriminants appear in the entities declared inside\n-         --  Derived_Type. Gigi won't like it.\n+         --  Derived_Type, since the back end cannot deal with it.\n \n          New_Decl :=\n            New_Copy_Tree\n@@ -5640,6 +5622,16 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Update the class_wide type, which shares the now-completed\n+      --  entity list with its specific type.\n+\n+      if Is_Tagged then\n+         Set_First_Entity\n+           (Class_Wide_Type (Derived_Type), First_Entity (Derived_Type));\n+         Set_Last_Entity\n+           (Class_Wide_Type (Derived_Type), Last_Entity (Derived_Type));\n+      end if;\n+\n    end Build_Derived_Record_Type;\n \n    ------------------------\n@@ -5775,9 +5767,11 @@ package body Sem_Ch3 is\n       CR_Disc : Entity_Id;\n \n    begin\n-      --  A discriminal has the same names as the discriminant.\n+      --  A discriminal has the same name as the discriminant\n \n-      D_Minal := Make_Defining_Identifier (Sloc (Discrim), Chars (Discrim));\n+      D_Minal :=\n+        Make_Defining_Identifier (Sloc (Discrim),\n+          Chars => Chars (Discrim));\n \n       Set_Ekind     (D_Minal, E_In_Parameter);\n       Set_Mechanism (D_Minal, Default_Mechanism);\n@@ -5811,10 +5805,11 @@ package body Sem_Ch3 is\n       Def         : Node_Id;\n       Derived_Def : Boolean := False) return Elist_Id\n    is\n-      C          : constant Node_Id := Constraint (Def);\n-      Nb_Discr   : constant Nat     := Number_Discriminants (T);\n+      C        : constant Node_Id := Constraint (Def);\n+      Nb_Discr : constant Nat     := Number_Discriminants (T);\n+\n       Discr_Expr : array (1 .. Nb_Discr) of Node_Id := (others => Empty);\n-      --  Saves the expression corresponding to a given discriminant in T.\n+      --  Saves the expression corresponding to a given discriminant in T\n \n       function Pos_Of_Discr (T : Entity_Id; D : Entity_Id) return Nat;\n       --  Return the Position number within array Discr_Expr of a discriminant\n@@ -5850,11 +5845,11 @@ package body Sem_Ch3 is\n       E     : Entity_Id;\n       Elist : constant Elist_Id := New_Elmt_List;\n \n-      Constr    : Node_Id;\n-      Expr      : Node_Id;\n-      Id        : Node_Id;\n-      Position  : Nat;\n-      Found     : Boolean;\n+      Constr   : Node_Id;\n+      Expr     : Node_Id;\n+      Id       : Node_Id;\n+      Position : Nat;\n+      Found    : Boolean;\n \n       Discrim_Present : Boolean := False;\n \n@@ -6744,7 +6739,6 @@ package body Sem_Ch3 is\n       Rewrite (E,\n         Make_Real_Literal (Sloc (E), Ureal_Tenth));\n       Analyze_And_Resolve (E, Standard_Float);\n-\n    end Check_Delta_Expression;\n \n    -----------------------------\n@@ -6905,7 +6899,6 @@ package body Sem_Ch3 is\n       Save_Homonym     := Homonym (Priv);\n \n       case Ekind (Full_Base) is\n-\n          when E_Record_Type    |\n               E_Record_Subtype |\n               Class_Wide_Kind  |\n@@ -6923,14 +6916,13 @@ package body Sem_Ch3 is\n             Set_Chars          (Full, Chars (Priv));\n             Conditional_Delay  (Full, Priv);\n             Set_Sloc           (Full, Sloc (Priv));\n-\n       end case;\n \n       Set_Next_Entity (Full, Save_Next_Entity);\n       Set_Homonym     (Full, Save_Homonym);\n       Set_Associated_Node_For_Itype (Full, Related_Nod);\n \n-      --  Set common attributes for all subtypes.\n+      --  Set common attributes for all subtypes\n \n       Set_Ekind (Full, Subtype_Kind (Ekind (Full_Base)));\n \n@@ -6944,7 +6936,7 @@ package body Sem_Ch3 is\n       --       Set_Etype (Full, Full_Base);\n \n       --  then we get inconsistencies in the front-end (confusion between\n-      --  views). Several outstanding bugs are related to this.\n+      --  views). Several outstanding bugs are related to this ???\n \n       Set_Is_First_Subtype (Full, False);\n       Set_Scope            (Full, Scope (Priv));\n@@ -6981,7 +6973,7 @@ package body Sem_Ch3 is\n       if not Is_Type (Scope (Full)) then\n          Set_Has_Delayed_Freeze (Full,\n            Has_Delayed_Freeze (Full_Base)\n-               and then (not Is_Frozen (Full_Base)));\n+             and then (not Is_Frozen (Full_Base)));\n       end if;\n \n       Set_Freeze_Node (Full, Empty);\n@@ -6991,6 +6983,7 @@ package body Sem_Ch3 is\n       if Has_Discriminants (Full) then\n          Set_Stored_Constraint_From_Discriminant_Constraint (Full);\n          Set_Stored_Constraint (Priv, Stored_Constraint (Full));\n+\n          if Has_Unknown_Discriminants (Full) then\n             Set_Discriminant_Constraint (Full, No_Elist);\n          end if;\n@@ -7029,7 +7022,7 @@ package body Sem_Ch3 is\n \n       elsif Is_Record_Type (Full_Base) then\n \n-         --  Show Full is simply a renaming of Full_Base.\n+         --  Show Full is simply a renaming of Full_Base\n \n          Set_Cloned_Subtype (Full, Full_Base);\n       end if;\n@@ -7080,7 +7073,6 @@ package body Sem_Ch3 is\n               Corresponding_Record_Type (Full_Base));\n          end if;\n       end if;\n-\n    end Complete_Private_Subtype;\n \n    ----------------------------\n@@ -7113,7 +7105,6 @@ package body Sem_Ch3 is\n       begin\n          if Is_Record_Type (Typ) then\n             Comp := First_Component (Typ);\n-\n             while Present (Comp) loop\n                if Comes_From_Source (Comp) then\n                   if Present (Expression (Parent (Comp)))\n@@ -7167,7 +7158,7 @@ package body Sem_Ch3 is\n          end if;\n \n       else\n-         --  Current declaration is illegal, diagnosed below in Enter_Name.\n+         --  Current declaration is illegal, diagnosed below in Enter_Name\n \n          T := Empty;\n          New_T := Any_Type;\n@@ -7183,7 +7174,7 @@ package body Sem_Ch3 is\n       then\n          Enter_Name (Id);\n \n-      --  Verify that types of both declarations match.\n+      --  Verify that types of both declarations match\n \n       elsif Base_Type (Etype (Prev)) /= Base_Type (New_T) then\n          Error_Msg_Sloc := Sloc (Prev);\n@@ -7258,27 +7249,24 @@ package body Sem_Ch3 is\n               or else Is_Incomplete_Or_Private_Type (Desig_Type))\n         and then not Is_Constrained (Desig_Type)\n       then\n-         --  ??? The following code is a temporary kludge to ignore\n-         --  discriminant constraint on access type if\n-         --  it is constraining the current record. Avoid creating the\n-         --  implicit subtype of the record we are currently compiling\n-         --  since right now, we cannot handle these.\n-         --  For now, just return the access type itself.\n+         --  ??? The following code is a temporary kludge to ignore a\n+         --  discriminant constraint on access type if it is constraining\n+         --  the current record. Avoid creating the implicit subtype of the\n+         --  record we are currently compiling since right now, we cannot\n+         --  handle these. For now, just return the access type itself.\n \n          if Desig_Type = Current_Scope\n            and then No (Def_Id)\n          then\n             Set_Ekind (Desig_Subtype, E_Record_Subtype);\n             Def_Id := Entity (Subtype_Mark (S));\n \n-            --  This call added to ensure that the constraint is\n-            --  analyzed (needed for a B test). Note that we\n-            --  still return early from this procedure to avoid\n-            --  recursive processing. ???\n+            --  This call added to ensure that the constraint is analyzed\n+            --  (needed for a B test). Note that we still return early from\n+            --  this procedure to avoid recursive processing. ???\n \n             Constrain_Discriminated_Type\n               (Desig_Subtype, S, Related_Nod, For_Access => True);\n-\n             return;\n          end if;\n \n@@ -7303,7 +7291,6 @@ package body Sem_Ch3 is\n                if Nkind (Pack) = N_Package_Declaration then\n                   Decls := Visible_Declarations (Specification (Pack));\n                   Decl := First (Decls);\n-\n                   while Present (Decl) loop\n                      if (Nkind (Decl) = N_Private_Type_Declaration\n                           and then\n@@ -7507,7 +7494,7 @@ package body Sem_Ch3 is\n \n       function Build_Constrained_Discriminated_Type\n         (Old_Type : Entity_Id) return Entity_Id;\n-      --  Ditto for record components.\n+      --  Ditto for record components\n \n       function Build_Constrained_Access_Type\n         (Old_Type : Entity_Id) return Entity_Id;\n@@ -7519,10 +7506,10 @@ package body Sem_Ch3 is\n       --  that apply to T. This routine builds the constrained subtype.\n \n       function Is_Discriminant (Expr : Node_Id) return Boolean;\n-      --  Returns True if Expr is a discriminant.\n+      --  Returns True if Expr is a discriminant\n \n       function Get_Discr_Value (Discrim : Entity_Id) return Node_Id;\n-      --  Find the value of discriminant Discrim in Constraint.\n+      --  Find the value of discriminant Discrim in Constraint\n \n       -----------------------------------\n       -- Build_Constrained_Access_Type --\n@@ -7579,6 +7566,7 @@ package body Sem_Ch3 is\n          end if;\n \n          if Desig_Subtype /= Desig_Type then\n+\n             --  The Related_Node better be here or else we won't be able\n             --  to attach new itypes to a node in the tree.\n \n@@ -7947,25 +7935,25 @@ package body Sem_Ch3 is\n       Related_Nod : Node_Id;\n       Related_Id  : Entity_Id) return Entity_Id\n    is\n-      T_Sub : constant Entity_Id\n-        := Create_Itype (E_Record_Subtype, Related_Nod, Related_Id, 'V');\n+      T_Sub : constant Entity_Id :=\n+                Create_Itype (E_Record_Subtype, Related_Nod, Related_Id, 'V');\n \n    begin\n-      Set_Etype                   (T_Sub, Corr_Rec);\n-      Init_Size_Align             (T_Sub);\n-      Set_Has_Discriminants       (T_Sub, Has_Discriminants (Prot_Subt));\n-      Set_Is_Constrained          (T_Sub, True);\n-      Set_First_Entity            (T_Sub, First_Entity (Corr_Rec));\n-      Set_Last_Entity             (T_Sub, Last_Entity  (Corr_Rec));\n+      Set_Etype             (T_Sub, Corr_Rec);\n+      Init_Size_Align       (T_Sub);\n+      Set_Has_Discriminants (T_Sub, Has_Discriminants (Prot_Subt));\n+      Set_Is_Constrained    (T_Sub, True);\n+      Set_First_Entity      (T_Sub, First_Entity (Corr_Rec));\n+      Set_Last_Entity       (T_Sub, Last_Entity  (Corr_Rec));\n \n       Conditional_Delay (T_Sub, Corr_Rec);\n \n       if Has_Discriminants (Prot_Subt) then -- False only if errors.\n-         Set_Discriminant_Constraint (T_Sub,\n-                                      Discriminant_Constraint (Prot_Subt));\n+         Set_Discriminant_Constraint\n+           (T_Sub, Discriminant_Constraint (Prot_Subt));\n          Set_Stored_Constraint_From_Discriminant_Constraint (T_Sub);\n-         Create_Constrained_Components (T_Sub, Related_Nod, Corr_Rec,\n-                                        Discriminant_Constraint (T_Sub));\n+         Create_Constrained_Components\n+           (T_Sub, Related_Nod, Corr_Rec, Discriminant_Constraint (T_Sub));\n       end if;\n \n       Set_Depends_On_Private      (T_Sub, Has_Private_Component (T_Sub));\n@@ -8028,12 +8016,11 @@ package body Sem_Ch3 is\n       if No (Range_Expr) then\n          Bound_Val := (Ureal_10 ** Digits_Val - Ureal_1) * Small_Value (T);\n          Range_Expr :=\n-            Make_Range (Loc,\n-               Low_Bound =>\n-                 Convert_To (T, Make_Real_Literal (Loc, (-Bound_Val))),\n-               High_Bound =>\n-                 Convert_To (T, Make_Real_Literal (Loc, Bound_Val)));\n-\n+           Make_Range (Loc,\n+             Low_Bound =>\n+               Convert_To (T, Make_Real_Literal (Loc, (-Bound_Val))),\n+             High_Bound =>\n+               Convert_To (T, Make_Real_Literal (Loc, Bound_Val)));\n       end if;\n \n       Set_Scalar_Range_For_Subtype (Def_Id, Range_Expr, T);\n@@ -8164,7 +8151,6 @@ package body Sem_Ch3 is\n       Set_Scalar_Range_For_Subtype (Def_Id, Range_Expression (C), T);\n \n       Set_Discrete_RM_Size (Def_Id);\n-\n    end Constrain_Enumeration;\n \n    ----------------------\n@@ -8283,14 +8269,15 @@ package body Sem_Ch3 is\n          end if;\n \n       elsif Nkind (S) = N_Subtype_Indication then\n-         --  the parser has verified that this is a discrete indication.\n+\n+         --  The parser has verified that this is a discrete indication\n \n          Resolve_Discrete_Subtype_Indication (S, T);\n          R := Range_Expression (Constraint (S));\n \n       elsif Nkind (S) = N_Discriminant_Association then\n \n-         --  syntactically valid in subtype indication.\n+         --  Syntactically valid in subtype indication\n \n          Error_Msg_N (\"invalid index constraint\", S);\n          Rewrite (S, New_Occurrence_Of (T, Sloc (S)));\n@@ -8302,7 +8289,6 @@ package body Sem_Ch3 is\n          Analyze (S);\n \n          if Is_Entity_Name (S) then\n-\n             if not Is_Type (Entity (S)) then\n                Error_Msg_N (\"expect subtype mark for index constraint\", S);\n \n@@ -8366,7 +8352,6 @@ package body Sem_Ch3 is\n       Set_Size_Info        (Def_Id,                  (T));\n       Set_First_Rep_Item   (Def_Id, First_Rep_Item   (T));\n       Set_Discrete_RM_Size (Def_Id);\n-\n    end Constrain_Integer;\n \n    ------------------------------\n@@ -8514,7 +8499,6 @@ package body Sem_Ch3 is\n    -------------------\n \n    procedure Copy_And_Swap (Priv, Full : Entity_Id) is\n-\n    begin\n       --  Initialize new full declaration entity by copying the pertinent\n       --  fields of the corresponding private declaration entity.\n@@ -8674,7 +8658,6 @@ package body Sem_Ch3 is\n \n          Old_C := First_Discriminant (Typ);\n          Discr_Val := First_Elmt (Constraints);\n-\n          while Present (Old_C) loop\n             Append_To (Assoc_List,\n               Make_Component_Association (Loc,\n@@ -8692,7 +8675,6 @@ package body Sem_Ch3 is\n            or else Has_Controlled_Component (Typ)\n          then\n             Old_C := First_Component (Typ);\n-\n             while Present (Old_C) loop\n                if Chars ((Old_C)) = Name_uTag\n                  or else Chars ((Old_C)) = Name_uParent\n@@ -8715,7 +8697,6 @@ package body Sem_Ch3 is\n \n       begin\n          Comp := First_Elmt (Comp_List);\n-\n          while Present (Comp) loop\n             Old_C := Node (Comp);\n             New_C := Create_Component (Old_C);\n@@ -8785,9 +8766,7 @@ package body Sem_Ch3 is\n       --  optimize the list of components.\n \n       Discr_Val := First_Elmt (Constraints);\n-\n       while Present (Discr_Val) loop\n-\n          if not Is_OK_Static_Expression (Node (Discr_Val)) then\n             Is_Static := False;\n             exit;\n@@ -8798,10 +8777,9 @@ package body Sem_Ch3 is\n \n       New_Scope (Subt);\n \n-      --  Inherit the discriminants of the parent type.\n+      --  Inherit the discriminants of the parent type\n \n       Old_C := First_Discriminant (Typ);\n-\n       while Present (Old_C) loop\n          New_C := Create_Component (Old_C);\n          Set_Is_Public (New_C, Is_Public (Subt));\n@@ -8851,7 +8829,6 @@ package body Sem_Ch3 is\n               (Record_Extension_Part (Type_Definition (Parent (Typ))))\n          then\n             Old_C := First_Component (Typ);\n-\n             while Present (Old_C) loop\n                if Original_Record_Component (Old_C) = Old_C\n                 and then Chars (Old_C) /= Name_uTag\n@@ -8873,7 +8850,6 @@ package body Sem_Ch3 is\n          --  parent type.\n \n          Old_C := First_Component (Typ);\n-\n          while Present (Old_C) loop\n             New_C := Create_Component (Old_C);\n \n@@ -9060,8 +9036,8 @@ package body Sem_Ch3 is\n       Parent_Type  : Entity_Id;\n       Actual_Subp  : Entity_Id := Empty)\n    is\n-      Formal     : Entity_Id;\n-      New_Formal : Entity_Id;\n+      Formal       : Entity_Id;\n+      New_Formal   : Entity_Id;\n       Visible_Subp : Entity_Id := Parent_Subp;\n \n       function Is_Private_Overriding return Boolean;\n@@ -9093,12 +9069,11 @@ package body Sem_Ch3 is\n          Prev : Entity_Id;\n \n       begin\n-         Prev := Homonym (Parent_Subp);\n-\n          --  The visible operation that is overriden is a homonym of\n          --  the parent subprogram. We scan the homonym chain to find\n          --  the one whose alias is the subprogram we are deriving.\n \n+         Prev := Homonym (Parent_Subp);\n          while Present (Prev) loop\n             if Is_Dispatching_Operation (Parent_Subp)\n               and then Present (Prev)\n@@ -9150,7 +9125,7 @@ package body Sem_Ch3 is\n                   Set_Etype (Acc_Type, Acc_Type);\n                   Set_Scope (Acc_Type, New_Subp);\n \n-                  --  Compute size of anonymous access type.\n+                  --  Compute size of anonymous access type\n \n                   if Is_Array_Type (Desig_Typ)\n                     and then not Is_Constrained (Desig_Typ)\n@@ -9161,7 +9136,6 @@ package body Sem_Ch3 is\n                   end if;\n \n                   Init_Alignment (Acc_Type);\n-\n                   Set_Directly_Designated_Type (Acc_Type, Derived_Type);\n \n                   Set_Etype (New_Id, Acc_Type);\n@@ -9459,8 +9433,6 @@ package body Sem_Ch3 is\n          Parent_Base := Parent_Type;\n       end if;\n \n-      Elmt := First_Elmt (Op_List);\n-\n       if Present (Generic_Actual) then\n          Act_List := Collect_Primitive_Operations (Generic_Actual);\n          Act_Elmt := First_Elmt (Act_List);\n@@ -9471,6 +9443,7 @@ package body Sem_Ch3 is\n       --  Literals are derived earlier in the process of building the\n       --  derived type, and are skipped here.\n \n+      Elmt := First_Elmt (Op_List);\n       while Present (Elmt) loop\n          Subp := Node (Elmt);\n \n@@ -9727,6 +9700,7 @@ package body Sem_Ch3 is\n            (\"type derived from untagged type cannot have extension\", Indic);\n \n       elsif No (Extension) and then Taggd then\n+\n          --  If this is within a private part (or body) of a generic\n          --  instantiation then the derivation is allowed (the parent\n          --  type can only appear tagged in this case if it's a generic\n@@ -9892,14 +9866,11 @@ package body Sem_Ch3 is\n \n       Discriminant :=\n          First_Stored_Discriminant (Explicitly_Discriminated_Type);\n-\n       while Present (Discriminant) loop\n-\n          Append_Elmt (\n            Get_Discriminant_Value (\n              Discriminant, Explicitly_Discriminated_Type, Constraint),\n            Expansion);\n-\n          Next_Stored_Discriminant (Discriminant);\n       end loop;\n \n@@ -9917,7 +9888,7 @@ package body Sem_Ch3 is\n       Prev_Par : Node_Id;\n \n    begin\n-      --  Find incomplete declaration, if some was given.\n+      --  Find incomplete declaration, if one was given\n \n       Prev := Current_Entity_In_Scope (Id);\n \n@@ -9991,19 +9962,19 @@ package body Sem_Ch3 is\n             elsif Nkind (N) /= N_Full_Type_Declaration\n               or else Nkind (Type_Definition (N)) /= N_Derived_Type_Definition\n             then\n-               Error_Msg_N (\"full view of private extension must be\"\n-                 & \" an extension\", N);\n+               Error_Msg_N\n+                 (\"full view of private extension must be an extension\", N);\n \n             elsif not (Abstract_Present (Parent (Prev)))\n               and then Abstract_Present (Type_Definition (N))\n             then\n-               Error_Msg_N (\"full view of non-abstract extension cannot\"\n-                 & \" be abstract\", N);\n+               Error_Msg_N\n+                 (\"full view of non-abstract extension cannot be abstract\", N);\n             end if;\n \n             if not In_Private_Part (Current_Scope) then\n                Error_Msg_N\n-                 (\"declaration of full view must appear in private part\",  N);\n+                 (\"declaration of full view must appear in private part\", N);\n             end if;\n \n             Copy_And_Swap (Prev, Id);\n@@ -10050,10 +10021,9 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         --  A prior untagged private type can have an associated\n-         --  class-wide type due to use of the class attribute,\n-         --  and in this case also the full type is required to\n-         --  be tagged.\n+         --  A prior untagged private type can have an associated class-wide\n+         --  type due to use of the class attribute, and in this case also the\n+         --  full type is required to be tagged.\n \n          if Is_Type (Prev)\n            and then (Is_Tagged_Type (Prev)\n@@ -10355,7 +10325,6 @@ package body Sem_Ch3 is\n       Set_RM_Size        (T, RM_Size        (Implicit_Base));\n       Set_First_Rep_Item (T, First_Rep_Item (Implicit_Base));\n       Set_Digits_Value   (T, Digs_Val);\n-\n    end Floating_Point_Type_Declaration;\n \n    ----------------------------\n@@ -10389,9 +10358,9 @@ package body Sem_Ch3 is\n    --  Typ_For_Constraint has discriminants, and the value for each\n    --  discriminant is given by its corresponding Elmt of Constraints.\n \n-   --  Discriminant is some discriminant in this hierarchy.\n+   --  Discriminant is some discriminant in this hierarchy\n \n-   --  We need to return its value.\n+   --  We need to return its value\n \n    --  We do this by recursively searching each level, and looking for\n    --  Discriminant. Once we get to the bottom, we start backing up\n@@ -10493,13 +10462,11 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         --  If Result is not a (reference to a) discriminant,\n-         --  return it, otherwise set Result_Entity to the discriminant.\n+         --  If Result is not a (reference to a) discriminant, return it,\n+         --  otherwise set Result_Entity to the discriminant.\n \n          if Nkind (Result) = N_Defining_Identifier then\n-\n             pragma Assert (Result = Discriminant);\n-\n             Result_Entity := Result;\n \n          else\n@@ -10532,7 +10499,6 @@ package body Sem_Ch3 is\n          end if;\n \n          while Present (Disc) loop\n-\n             pragma Assert (Present (Assoc));\n \n             if Original_Record_Component (Disc) = Result_Entity then\n@@ -10558,14 +10524,14 @@ package body Sem_Ch3 is\n    --  Start of processing for Get_Discriminant_Value\n \n    begin\n-      --  ??? this routine is a gigantic mess and will be deleted.\n-      --  for the time being just test for the trivial case before calling\n-      --  recurse.\n+      --  ??? This routine is a gigantic mess and will be deleted. For the\n+      --  time being just test for the trivial case before calling recurse.\n \n       if Base_Type (Scope (Discriminant)) = Base_Type (Typ_For_Constraint) then\n          declare\n             D : Entity_Id := First_Discriminant (Typ_For_Constraint);\n             E : Elmt_Id   := First_Elmt (Constraint);\n+\n          begin\n             while Present (D) loop\n                if Chars (D) = Chars (Discriminant) then\n@@ -10698,7 +10664,7 @@ package body Sem_Ch3 is\n             if (Is_Private_Type (Derived_Base)\n                   and then not Is_Generic_Type (Derived_Base))\n               or else (Is_Empty_Elmt_List (Discs)\n-                       and then  not Expander_Active)\n+                         and then  not Expander_Active)\n             then\n                Set_Etype (New_C, Etype (Old_C));\n             else\n@@ -10757,15 +10723,14 @@ package body Sem_Ch3 is\n          end if;\n       end Inherit_Component;\n \n-      --  Variables local to Inherit_Components.\n+      --  Variables local to Inherit_Component\n \n       Loc : constant Source_Ptr := Sloc (N);\n \n       Parent_Discrim : Entity_Id;\n       Stored_Discrim : Entity_Id;\n       D              : Entity_Id;\n-\n-      Component        : Entity_Id;\n+      Component      : Entity_Id;\n \n    --  Start of processing for Inherit_Components\n \n@@ -10792,8 +10757,8 @@ package body Sem_Ch3 is\n         and then not Is_Tagged\n         and then\n           (not Inherit_Discr\n-           or else First_Discriminant (Parent_Base) /=\n-                   First_Stored_Discriminant (Parent_Base))\n+             or else First_Discriminant (Parent_Base) /=\n+                     First_Stored_Discriminant (Parent_Base))\n       then\n          Stored_Discrim := First_Stored_Discriminant (Parent_Base);\n          while Present (Stored_Discrim) loop\n@@ -10816,9 +10781,9 @@ package body Sem_Ch3 is\n         and then Present (First_Discriminant (Derived_Base))\n         and then\n           (not Is_Private_Type (Derived_Base)\n-           or else Is_Completely_Hidden\n-             (First_Stored_Discriminant (Derived_Base))\n-           or else Is_Generic_Type (Derived_Base))\n+             or else Is_Completely_Hidden\n+               (First_Stored_Discriminant (Derived_Base))\n+             or else Is_Generic_Type (Derived_Base))\n       then\n          D := First_Discriminant (Derived_Base);\n          while Present (D) loop\n@@ -10886,7 +10851,6 @@ package body Sem_Ch3 is\n    is\n    begin\n       case T_Kind is\n-\n          when Enumeration_Kind |\n               Integer_Kind =>\n             return Constraint_Kind = N_Range_Constraint;\n@@ -10920,9 +10884,8 @@ package body Sem_Ch3 is\n             return Constraint_Kind = N_Index_Or_Discriminant_Constraint;\n \n          when others =>\n-            return True; -- Error will be detected later.\n+            return True; -- Error will be detected later\n       end case;\n-\n    end Is_Valid_Constraint_Kind;\n \n    --------------------------\n@@ -10956,6 +10919,7 @@ package body Sem_Ch3 is\n \n             Scop := Scope (Scop);\n          end loop;\n+\n          return False;\n       end Is_Local_Type;\n \n@@ -10996,28 +10960,26 @@ package body Sem_Ch3 is\n       elsif In_Instance_Body then\n          return True;\n \n-      --  Discriminants are always visible.\n+      --  Discriminants are always visible\n \n       elsif Ekind (Original_Comp) = E_Discriminant\n         and then not Has_Unknown_Discriminants (Original_Scope)\n       then\n          return True;\n \n-      --  If the component has been declared in an ancestor which is\n-      --  currently a private type, then it is not visible. The same\n-      --  applies if the component's containing type is not in an\n-      --  open scope and the original component's enclosing type\n-      --  is a visible full type of a private type (which can occur\n-      --  in cases where an attempt is being made to reference a\n-      --  component in a sibling package that is inherited from a\n-      --  visible component of a type in an ancestor package; the\n-      --  component in the sibling package should not be visible\n-      --  even though the component it inherited from is visible).\n-      --  This does not apply however in the case where the scope\n-      --  of the type is a private child unit, or when the parent\n-      --  comes from a local package in which the ancestor is\n-      --  currently visible. The latter suppression of visibility\n-      --  is needed for cases that are tested in B730006.\n+      --  If the component has been declared in an ancestor which is currently\n+      --  a private type, then it is not visible. The same applies if the\n+      --  component's containing type is not in an open scope and the original\n+      --  component's enclosing type is a visible full type of a private type\n+      --  (which can occur in cases where an attempt is being made to reference\n+      --  a component in a sibling package that is inherited from a visible\n+      --  component of a type in an ancestor package; the component in the\n+      --  sibling package should not be visible even though the component it\n+      --  inherited from is visible). This does not apply however in the case\n+      --  where the scope of the type is a private child unit, or when the\n+      --  parent comes from a local package in which the ancestor is currently\n+      --  visible. The latter suppression of visibility is needed for cases\n+      --  that are tested in B730006.\n \n       elsif Is_Private_Type (Original_Scope)\n         or else\n@@ -11140,7 +11102,6 @@ package body Sem_Ch3 is\n       --  The class-wide type of a class-wide type is itself (RM 3.9(14))\n \n       Set_Class_Wide_Type (CW_Type, CW_Type);\n-\n    end Make_Class_Wide_Type;\n \n    ----------------\n@@ -11267,7 +11228,7 @@ package body Sem_Ch3 is\n \n       elsif Nkind (I) = N_Subtype_Indication then\n \n-         --  The index is given by a subtype with a range constraint.\n+         --  The index is given by a subtype with a range constraint\n \n          T :=  Base_Type (Entity (Subtype_Mark (I)));\n \n@@ -11317,6 +11278,7 @@ package body Sem_Ch3 is\n             Error_Msg_N (\"invalid subtype mark in discrete range \", I);\n             Set_Etype (I, Any_Integer);\n             return;\n+\n          else\n             --  The type mark may be that of an incomplete type. It is only\n             --  now that we can get the full view, previous analysis does\n@@ -11383,10 +11345,9 @@ package body Sem_Ch3 is\n       --       not be recognized as the same type for the purposes of\n       --       eliminating checks in some circumstances.\n \n-      --  We signal this case by setting the subtype entity in Def_Id.\n+      --  We signal this case by setting the subtype entity in Def_Id\n \n       if No (Def_Id) then\n-\n          Def_Id :=\n            Create_Itype (E_Void, Related_Nod, Related_Id, 'D', Suffix_Index);\n          Set_Etype (Def_Id, Base_Type (T));\n@@ -11526,7 +11487,7 @@ package body Sem_Ch3 is\n                return;\n \n             else\n-               --  In the non-binary case, set size as per RM 13.3(55).\n+               --  In the non-binary case, set size as per RM 13.3(55)\n \n                Set_Modular_Size (Bits);\n                return;\n@@ -11564,7 +11525,6 @@ package body Sem_Ch3 is\n \n       function Make_Op_Formal (Typ, Op : Entity_Id) return Entity_Id is\n          Formal : Entity_Id;\n-\n       begin\n          Formal := New_Internal_Entity (E_In_Parameter, Op, Loc, 'P');\n          Set_Etype (Formal, Typ);\n@@ -11590,7 +11550,6 @@ package body Sem_Ch3 is\n \n       Append_Entity (Make_Op_Formal (Typ, Op), Op);\n       Append_Entity (Make_Op_Formal (Typ, Op), Op);\n-\n    end New_Concatenation_Op;\n \n    -------------------------------------------\n@@ -12376,7 +12335,6 @@ package body Sem_Ch3 is\n \n          Next_Elmt (Inc_Elmt);\n       end loop;\n-\n    end Process_Incomplete_Dependents;\n \n    --------------------------------\n@@ -12746,7 +12704,6 @@ package body Sem_Ch3 is\n          --  Remaining processing depends on type\n \n          case Ekind (Subtype_Mark_Id) is\n-\n             when Access_Kind =>\n                Constrain_Access (Def_Id, S, Related_Nod);\n \n@@ -12821,7 +12778,6 @@ package body Sem_Ch3 is\n          Set_Convention (Def_Id, Convention (Subtype_Mark_Id));\n \n          return Def_Id;\n-\n       end if;\n    end Process_Subtype;\n \n@@ -12844,8 +12800,9 @@ package body Sem_Ch3 is\n       --  if it detected an error for declaration T. This arises in the case of\n       --  private tagged types where the full view omits the word tagged.\n \n-      Is_Tagged := Tagged_Present (Def)\n-        or else (Serious_Errors_Detected > 0 and then Is_Tagged_Type (T));\n+      Is_Tagged :=\n+        Tagged_Present (Def)\n+          or else (Serious_Errors_Detected > 0 and then Is_Tagged_Type (T));\n \n       --  Records constitute a scope for the component declarations within.\n       --  The scope is created prior to the processing of these declarations.\n@@ -12972,7 +12929,6 @@ package body Sem_Ch3 is\n \n       Component := First_Entity (Current_Scope);\n       while Present (Component) loop\n-\n          if Ekind (Component) = E_Void then\n             Set_Ekind (Component, E_Component);\n             Init_Component_Location (Component);\n@@ -13135,6 +13091,7 @@ package body Sem_Ch3 is\n       Subt   : Entity_Id)\n    is\n       Kind : constant Entity_Kind :=  Ekind (Def_Id);\n+\n    begin\n       Set_Scalar_Range (Def_Id, R);\n \n@@ -13165,8 +13122,7 @@ package body Sem_Ch3 is\n      (E : Entity_Id)\n    is\n    begin\n-      --  Make sure set if encountered during\n-      --  Expand_To_Stored_Constraint\n+      --  Make sure set if encountered during Expand_To_Stored_Constraint\n \n       Set_Stored_Constraint (E, No_Elist);\n \n@@ -13176,7 +13132,6 @@ package body Sem_Ch3 is\n          Set_Stored_Constraint (E,\n            Expand_To_Stored_Constraint (E, Discriminant_Constraint (E)));\n       end if;\n-\n    end Set_Stored_Constraint_From_Discriminant_Constraint;\n \n    -------------------------------------\n@@ -13203,14 +13158,13 @@ package body Sem_Ch3 is\n       -- Can_Derive_From --\n       ---------------------\n \n+      --  Note we check both bounds against both end values, to deal with\n+      --  strange types like ones with a range of 0 .. -12341234.\n+\n       function Can_Derive_From (E : Entity_Id) return Boolean is\n          Lo : constant Uint := Expr_Value (Type_Low_Bound (E));\n          Hi : constant Uint := Expr_Value (Type_High_Bound (E));\n-\n       begin\n-         --  Note we check both bounds against both end values, to deal with\n-         --  strange types like ones with a range of 0 .. -12341234.\n-\n          return Lo <= Lo_Val and then Lo_Val <= Hi\n                   and then\n                 Lo <= Hi_Val and then Hi_Val <= Hi;"}]}