{"sha": "84046b192e568e1a0619b72a12c7263553d9610a", "node_id": "C_kwDOANBUbNoAKDg0MDQ2YjE5MmU1NjhlMWEwNjE5YjcyYTEyYzcyNjM1NTNkOTYxMGE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-30T00:56:27Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-30T00:56:27Z"}, "message": "analyzer: move stdio known fns to sm-file.cc\n\ngcc/analyzer/ChangeLog:\n\t* region-model-impl-calls.cc (class kf_fgets): Move to sm-file.cc.\n\t(kf_fgets::impl_call_pre): Likewise.\n\t(class kf_fread): Likewise.\n\t(kf_fread::impl_call_pre): Likewise.\n\t(class kf_getchar): Likewise.\n\t(class kf_stdio_output_fn): Likewise.\n\t(register_known_functions): Move registration of\n\tBUILT_IN_FPRINTF, BUILT_IN_FPRINTF_UNLOCKED, BUILT_IN_FPUTC,\n\tBUILT_IN_FPUTC_UNLOCKED, BUILT_IN_FPUTS, BUILT_IN_FPUTS_UNLOCKED,\n\tBUILT_IN_FWRITE, BUILT_IN_FWRITE_UNLOCKED, BUILT_IN_PRINTF,\n\tBUILT_IN_PRINTF_UNLOCKED, BUILT_IN_PUTC, BUILT_IN_PUTCHAR,\n\tBUILT_IN_PUTCHAR_UNLOCKED, BUILT_IN_PUTC_UNLOCKED, BUILT_IN_PUTS,\n\tBUILT_IN_PUTS_UNLOCKED, BUILT_IN_VFPRINTF, BUILT_IN_VPRINTF,\n\t\"getchar\", \"fgets\", \"fgets_unlocked\", and \"fread\" to\n\tregister_known_file_functions.\n\t* sm-file.cc (class kf_stdio_output_fn): Move here from\n\tregion-model-impl-calls.cc.\n\t(class kf_fgets): Likewise.\n\t(class kf_fread): Likewise.\n\t(class kf_getchar): Likewise.\n\t(register_known_file_functions): Move registration of\n\tBUILT_IN_FPRINTF, BUILT_IN_FPRINTF_UNLOCKED, BUILT_IN_FPUTC,\n\tBUILT_IN_FPUTC_UNLOCKED, BUILT_IN_FPUTS, BUILT_IN_FPUTS_UNLOCKED,\n\tBUILT_IN_FWRITE, BUILT_IN_FWRITE_UNLOCKED, BUILT_IN_PRINTF,\n\tBUILT_IN_PRINTF_UNLOCKED, BUILT_IN_PUTC, BUILT_IN_PUTCHAR,\n\tBUILT_IN_PUTCHAR_UNLOCKED, BUILT_IN_PUTC_UNLOCKED, BUILT_IN_PUTS,\n\tBUILT_IN_PUTS_UNLOCKED, BUILT_IN_VFPRINTF, BUILT_IN_VPRINTF,\n\t\"fgets\", \"fgets_unlocked\", \"fread\", and \"getchar\" to here from\n\tregister_known_functions.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "320788c07e0896ac153284256f829a96fe2b7f33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/320788c07e0896ac153284256f829a96fe2b7f33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84046b192e568e1a0619b72a12c7263553d9610a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84046b192e568e1a0619b72a12c7263553d9610a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84046b192e568e1a0619b72a12c7263553d9610a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84046b192e568e1a0619b72a12c7263553d9610a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78a17f4452db9514da7cc8706c654cb98ba0a8e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a17f4452db9514da7cc8706c654cb98ba0a8e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a17f4452db9514da7cc8706c654cb98ba0a8e6"}], "stats": {"total": 217, "additions": 106, "deletions": 111}, "files": [{"sha": "8ba644c33cd9eb860e26ae1c8b3b0b5fd64f4816", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84046b192e568e1a0619b72a12c7263553d9610a/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84046b192e568e1a0619b72a12c7263553d9610a/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=84046b192e568e1a0619b72a12c7263553d9610a", "patch": "@@ -704,66 +704,6 @@ kf_error::impl_call_pre (const call_details &cd) const\n       ctxt->terminate_path ();\n }\n \n-/* Handler for \"fgets\" and \"fgets_unlocked\".  */\n-\n-class kf_fgets : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return (cd.num_args () == 3\n-\t    && cd.arg_is_pointer_p (0)\n-\t    && cd.arg_is_pointer_p (2));\n-  }\n-\n-  void impl_call_pre (const call_details &cd) const final override;\n-};\n-\n-void\n-kf_fgets::impl_call_pre (const call_details &cd) const\n-{\n-  /* Ideally we would bifurcate state here between the\n-     error vs no error cases.  */\n-  region_model *model = cd.get_model ();\n-  const svalue *ptr_sval = cd.get_arg_svalue (0);\n-  if (const region *reg = ptr_sval->maybe_get_region ())\n-    {\n-      const region *base_reg = reg->get_base_region ();\n-      const svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n-      model->set_value (base_reg, new_sval, cd.get_ctxt ());\n-    }\n-}\n-\n-/* Handler for \"fread\"\".  */\n-\n-class kf_fread : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return (cd.num_args () == 4\n-\t    && cd.arg_is_pointer_p (0)\n-\t    && cd.arg_is_size_p (1)\n-\t    && cd.arg_is_size_p (2)\n-\t    && cd.arg_is_pointer_p (3));\n-  }\n-\n-  void impl_call_pre (const call_details &cd) const final override;\n-};\n-\n-void\n-kf_fread::impl_call_pre (const call_details &cd) const\n-{\n-  region_model *model = cd.get_model ();\n-  const svalue *ptr_sval = cd.get_arg_svalue (0);\n-  if (const region *reg = ptr_sval->maybe_get_region ())\n-    {\n-      const region *base_reg = reg->get_base_region ();\n-      const svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n-      model->set_value (base_reg, new_sval, cd.get_ctxt ());\n-    }\n-}\n-\n /* Handler for \"free\", after sm-handling.\n \n    If the ptr points to an underlying heap region, delete the region,\n@@ -803,20 +743,6 @@ kf_free::impl_call_post (const call_details &cd) const\n     }\n }\n \n-/* Handler for \"getchar\"\".  */\n-\n-class kf_getchar : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 0;\n-  }\n-\n-  /* Empty.  No side-effects (tracking stream state is out-of-scope\n-     for the analyzer).  */\n-};\n-\n /* Handle the on_call_pre part of \"malloc\".  */\n \n class kf_malloc : public known_function\n@@ -1455,21 +1381,6 @@ class kf_stack_save : public known_function\n   /* Currently a no-op.  */\n };\n \n-/* Handler for various stdio-related builtins that merely have external\n-   effects that are out of scope for the analyzer: we only want to model\n-   the effects on the return value.  */\n-\n-class kf_stdio_output_fn : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &) const final override\n-  {\n-    return true;\n-  }\n-\n-  /* A no-op; we just want the conjured return value.  */\n-};\n-\n /* Handler for \"strcpy\" and \"__builtin_strcpy_chk\".  */\n \n class kf_strcpy : public known_function\n@@ -1592,37 +1503,19 @@ register_known_functions (known_function_manager &kfm)\n     kfm.add (BUILT_IN_CALLOC, make_unique<kf_calloc> ());\n     kfm.add (BUILT_IN_EXPECT, make_unique<kf_expect> ());\n     kfm.add (BUILT_IN_EXPECT_WITH_PROBABILITY, make_unique<kf_expect> ());\n-    kfm.add (BUILT_IN_FPRINTF, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_FPRINTF_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_FPUTC, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_FPUTC_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_FPUTS, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_FPUTS_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n     kfm.add (BUILT_IN_FREE, make_unique<kf_free> ());\n-    kfm.add (BUILT_IN_FWRITE, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_FWRITE_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n     kfm.add (BUILT_IN_MALLOC, make_unique<kf_malloc> ());\n     kfm.add (BUILT_IN_MEMCPY, make_unique<kf_memcpy> ());\n     kfm.add (BUILT_IN_MEMCPY_CHK, make_unique<kf_memcpy> ());\n     kfm.add (BUILT_IN_MEMSET, make_unique<kf_memset> ());\n     kfm.add (BUILT_IN_MEMSET_CHK, make_unique<kf_memset> ());\n-    kfm.add (BUILT_IN_PRINTF, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_PRINTF_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_PUTC, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_PUTCHAR, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_PUTCHAR_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_PUTC_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_PUTS, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_PUTS_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n     kfm.add (BUILT_IN_REALLOC, make_unique<kf_realloc> ());\n     kfm.add (BUILT_IN_STACK_RESTORE, make_unique<kf_stack_restore> ());\n     kfm.add (BUILT_IN_STACK_SAVE, make_unique<kf_stack_save> ());\n     kfm.add (BUILT_IN_STRCHR, make_unique<kf_strchr> ());\n     kfm.add (BUILT_IN_STRCPY, make_unique<kf_strcpy> (2));\n     kfm.add (BUILT_IN_STRCPY_CHK, make_unique<kf_strcpy> (3));\n     kfm.add (BUILT_IN_STRLEN, make_unique<kf_strlen> ());\n-    kfm.add (BUILT_IN_VFPRINTF, make_unique<kf_stdio_output_fn> ());\n-    kfm.add (BUILT_IN_VPRINTF, make_unique<kf_stdio_output_fn> ());\n \n     register_varargs_builtins (kfm);\n   }\n@@ -1650,15 +1543,11 @@ register_known_functions (known_function_manager &kfm)\n \n   /* Known builtins and C standard library functions.  */\n   {\n-    kfm.add (\"getchar\", make_unique<kf_getchar> ());\n     kfm.add (\"memset\", make_unique<kf_memset> ());\n   }\n \n   /* Known POSIX functions, and some non-standard extensions.  */\n   {\n-    kfm.add (\"fgets\", make_unique<kf_fgets> ());\n-    kfm.add (\"fgets_unlocked\", make_unique<kf_fgets> ()); // non-standard\n-    kfm.add (\"fread\", make_unique<kf_fread> ());\n     kfm.add (\"putenv\", make_unique<kf_putenv> ());\n \n     register_known_fd_functions (kfm);"}, {"sha": "d2dcb4312a2076b112669c4572ffee732d225796", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84046b192e568e1a0619b72a12c7263553d9610a/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84046b192e568e1a0619b72a12c7263553d9610a/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=84046b192e568e1a0619b72a12c7263553d9610a", "patch": "@@ -489,6 +489,21 @@ make_fileptr_state_machine (logger *logger)\n   return new fileptr_state_machine (logger);\n }\n \n+/* Handler for various stdio-related builtins that merely have external\n+   effects that are out of scope for the analyzer: we only want to model\n+   the effects on the return value.  */\n+\n+class kf_stdio_output_fn : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &) const final override\n+  {\n+    return true;\n+  }\n+\n+  /* A no-op; we just want the conjured return value.  */\n+};\n+\n /* Handler for \"ferror\"\".  */\n \n class kf_ferror : public known_function\n@@ -517,6 +532,60 @@ class kf_fileno : public known_function\n   /* No side effects.  */\n };\n \n+/* Handler for \"fgets\" and \"fgets_unlocked\".  */\n+\n+class kf_fgets : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3\n+\t    && cd.arg_is_pointer_p (0)\n+\t    && cd.arg_is_pointer_p (2));\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    /* Ideally we would bifurcate state here between the\n+       error vs no error cases.  */\n+    region_model *model = cd.get_model ();\n+    const svalue *ptr_sval = cd.get_arg_svalue (0);\n+    if (const region *reg = ptr_sval->maybe_get_region ())\n+      {\n+\tconst region *base_reg = reg->get_base_region ();\n+\tconst svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n+\tmodel->set_value (base_reg, new_sval, cd.get_ctxt ());\n+      }\n+  }\n+};\n+\n+/* Handler for \"fread\"\".  */\n+\n+class kf_fread : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 4\n+\t    && cd.arg_is_pointer_p (0)\n+\t    && cd.arg_is_size_p (1)\n+\t    && cd.arg_is_size_p (2)\n+\t    && cd.arg_is_pointer_p (3));\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model *model = cd.get_model ();\n+    const svalue *ptr_sval = cd.get_arg_svalue (0);\n+    if (const region *reg = ptr_sval->maybe_get_region ())\n+      {\n+\tconst region *base_reg = reg->get_base_region ();\n+\tconst svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n+\tmodel->set_value (base_reg, new_sval, cd.get_ctxt ());\n+      }\n+  }\n+};\n+\n /* Handler for \"getc\"\".  */\n \n class kf_getc : public known_function\n@@ -531,15 +600,52 @@ class kf_getc : public known_function\n   /* No side effects.  */\n };\n \n+/* Handler for \"getchar\"\".  */\n+\n+class kf_getchar : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+\n+  /* Empty.  No side-effects (tracking stream state is out-of-scope\n+     for the analyzer).  */\n+};\n+\n /* Populate KFM with instances of known functions relating to\n    stdio streams.  */\n \n void\n register_known_file_functions (known_function_manager &kfm)\n {\n+  kfm.add (BUILT_IN_FPRINTF, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_FPRINTF_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_FPUTC, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_FPUTC_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_FPUTS, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_FPUTS_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_FWRITE, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_FWRITE_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_PRINTF, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_PRINTF_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_PUTC, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_PUTCHAR, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_PUTCHAR_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_PUTC_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_PUTS, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_PUTS_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_VFPRINTF, make_unique<kf_stdio_output_fn> ());\n+  kfm.add (BUILT_IN_VPRINTF, make_unique<kf_stdio_output_fn> ());\n+\n   kfm.add (\"ferror\", make_unique<kf_ferror> ());\n+  kfm.add (\"fgets\", make_unique<kf_fgets> ());\n+  kfm.add (\"fgets_unlocked\", make_unique<kf_fgets> ()); // non-standard\n   kfm.add (\"fileno\", make_unique<kf_fileno> ());\n+  kfm.add (\"fread\", make_unique<kf_fread> ());\n   kfm.add (\"getc\", make_unique<kf_getc> ());\n+  kfm.add (\"getchar\", make_unique<kf_getchar> ());\n }\n \n #if CHECKING_P"}]}