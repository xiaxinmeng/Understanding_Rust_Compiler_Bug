{"sha": "1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "node_id": "C_kwDOANBUbNoAKDEwNjBjZDJhZDAwYjUxNzRmNGY4ZWY4Y2EzZDhjMjgzZTMyMWZmY2E", "commit": {"author": {"name": "Jiufu Guo", "email": "guojiufu@linux.ibm.com", "date": "2022-12-20T03:43:57Z"}, "committer": {"name": "Jiufu Guo", "email": "guojiufu@linux.ibm.com", "date": "2022-12-20T03:52:10Z"}, "message": "rs6000: Optimize cmp on rotated 16bits constant\n\nHi,\n\nWhen checking eq/ne with a constant which has only 16bits, it can be\noptimized to check the rotated data.  By this, the constant building\nis optimized.\n\nAs the example in PR103743:\nFor \"in == 0x8000000000000000LL\", this patch generates:\n        rotldi 3,3,1 ; cmpldi 0,3,1\ninstead of:\n        li 9,-1 ; rldicr 9,9,0,0 ; cmpd 0,3,9\n\nCompare with previous version:\nhttps://gcc.gnu.org/pipermail/gcc-patches/2022-August/600475.html.\nThis patch refactor the code according to review comments.\ne.g. updating function names/comments/code.\n\nThis patch pass bootstrap and regtest on ppc64 and ppc64le.\nIs it ok for trunk?  Thanks for comments!\n\nBR,\nJeff(Jiufu)\n\n\tPR target/103743\n\ngcc/ChangeLog:\n\n\t* config/rs6000/rs6000-protos.h (can_be_rotated_to_lowbits): New.\n\t(can_be_rotated_to_positive_16bits): New.\n\t(can_be_rotated_to_negative_15bits): New.\n\t* config/rs6000/rs6000.cc (can_be_rotated_to_lowbits): New definition.\n\t(can_be_rotated_to_positive_16bits): New definition.\n\t(can_be_rotated_to_negative_15bits): New definition.\n\t* config/rs6000/rs6000.md (*rotate_on_cmpdi): New define_insn_and_split.\n\t(eqne): Move earlier.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/powerpc/pr103743.c: New test.\n\t* gcc.target/powerpc/pr103743_1.c: New test.", "tree": {"sha": "db92c2c3b809205b93a27d0027966cab91fe3881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db92c2c3b809205b93a27d0027966cab91fe3881"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/comments", "author": null, "committer": null, "parents": [{"sha": "d2ef2327bb357da9d4cff8111e15547441b74c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ef2327bb357da9d4cff8111e15547441b74c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2ef2327bb357da9d4cff8111e15547441b74c99"}], "stats": {"total": 281, "additions": 280, "deletions": 1}, "files": [{"sha": "8355621d4edc435d8d8c88cef81ebad78f66445c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "patch": "@@ -35,6 +35,9 @@ extern bool xxspltib_constant_p (rtx, machine_mode, int *, int *);\n extern int vspltis_shifted (rtx);\n extern HOST_WIDE_INT const_vector_elt_as_int (rtx, unsigned int);\n extern bool macho_lo_sum_memory_operand (rtx, machine_mode);\n+extern bool can_be_rotated_to_lowbits (unsigned HOST_WIDE_INT, int, int *);\n+extern bool can_be_rotated_to_positive_16bits (HOST_WIDE_INT);\n+extern bool can_be_rotated_to_negative_15bits (HOST_WIDE_INT);\n extern int num_insns_constant (rtx, machine_mode);\n extern int small_data_operand (rtx, machine_mode);\n extern bool mem_operand_gpr (rtx, machine_mode);"}, {"sha": "e074e8f7bdf36b06aa704a6c7a964c82b1ee7187", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "patch": "@@ -14950,6 +14950,71 @@ rs6000_reverse_condition (machine_mode mode, enum rtx_code code)\n     return reverse_condition (code);\n }\n \n+/* Check if C (as 64bit integer) can be rotated to a constant which constains\n+   nonzero bits at the LOWBITS low bits only.\n+\n+   Return true if C can be rotated to such constant.  If so, *ROT is written\n+   to the number by which C is rotated.\n+   Return false otherwise.  */\n+\n+bool\n+can_be_rotated_to_lowbits (unsigned HOST_WIDE_INT c, int lowbits, int *rot)\n+{\n+  int clz = HOST_BITS_PER_WIDE_INT - lowbits;\n+\n+  /* case a. 0..0xxx: already at least clz zeros.  */\n+  int lz = clz_hwi (c);\n+  if (lz >= clz)\n+    {\n+      *rot = 0;\n+      return true;\n+    }\n+\n+  /* case b. 0..0xxx0..0: at least clz zeros.  */\n+  int tz = ctz_hwi (c);\n+  if (lz + tz >= clz)\n+    {\n+      *rot = HOST_BITS_PER_WIDE_INT - tz;\n+      return true;\n+    }\n+\n+  /* case c. xx10.....0xx: rotate 'clz - 1' bits first, then check case b.\n+\t       ^bit -> Vbit, , then zeros are at head or tail.\n+\t     00...00xxx100, 'clz - 1' >= 'bits of xxxx'.  */\n+  const int rot_bits = lowbits + 1;\n+  unsigned HOST_WIDE_INT rc = (c >> rot_bits) | (c << (clz - 1));\n+  tz = ctz_hwi (rc);\n+  if (clz_hwi (rc) + tz >= clz)\n+    {\n+      *rot = HOST_BITS_PER_WIDE_INT - (tz + rot_bits);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Check if C (as 64bit integer) can be rotated to a positive 16bits constant\n+   which contains 48bits leading zeros and 16bits of any value.  */\n+\n+bool\n+can_be_rotated_to_positive_16bits (HOST_WIDE_INT c)\n+{\n+  int rot = 0;\n+  bool res = can_be_rotated_to_lowbits (c, 16, &rot);\n+  return res && rot > 0;\n+}\n+\n+/* Check if C (as 64bit integer) can be rotated to a negative 15bits constant\n+   which contains 49bits leading ones and 15bits of any value.  */\n+\n+bool\n+can_be_rotated_to_negative_15bits (HOST_WIDE_INT c)\n+{\n+  int rot = 0;\n+  bool res = can_be_rotated_to_lowbits (~c, 15, &rot);\n+  return res && rot > 0;\n+}\n+\n /* Generate a compare for CODE.  Return a brand-new rtx that\n    represents the result of the compare.  */\n "}, {"sha": "3cae64a264a0ce30228fb5761df75329255eaef7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "patch": "@@ -7765,6 +7765,71 @@\n   \"xscvdpsp %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n+\n+(define_code_iterator eqne [eq ne])\n+\n+;; \"i == C\" ==> \"rotl(i,N) == rotl(C,N)\"\n+(define_insn_and_split \"*rotate_on_cmpdi\"\n+  [(set (pc)\n+\t(if_then_else (eqne (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t\t      (label_ref (match_operand 0 \"\"))\n+\t\t      (pc)))\n+  (clobber (match_scratch:DI 3 \"=r\"))\n+  (clobber (match_scratch:CCUNS 4 \"=y\"))]\n+  \"TARGET_POWERPC64 && num_insns_constant (operands[2], DImode) > 1\n+   && (can_be_rotated_to_positive_16bits (INTVAL (operands[2]))\n+       || can_be_rotated_to_negative_15bits (INTVAL (operands[2])))\"\n+   \"#\"\n+   \"&& 1\"\n+  [(pc)]\n+{\n+  bool sgn = false;\n+  unsigned HOST_WIDE_INT C = INTVAL (operands[2]);\n+  int rot;\n+\n+  /* cmpldi */\n+  if (!can_be_rotated_to_lowbits (C, 16, &rot))\n+    {\n+      /* cmpdi */\n+      sgn = true;\n+      bool res = can_be_rotated_to_lowbits (~C, 15, &rot);\n+      gcc_assert (res);\n+    }\n+\n+  rtx n = GEN_INT (rot);\n+\n+  /* i' = rotl (i, n) */\n+  rtx op0 = can_create_pseudo_p () ? gen_reg_rtx (DImode) : operands[3];\n+  emit_insn (gen_rtx_SET (op0, gen_rtx_ROTATE (DImode, operands[1], n)));\n+\n+  /* C' = rotl (C, n) */\n+  rtx op1 = GEN_INT ((C << rot) | (C >> (HOST_BITS_PER_WIDE_INT - rot)));\n+\n+  /* i' ==  C' */\n+  machine_mode comp_mode = sgn ? CCmode : CCUNSmode;\n+  rtx cc = can_create_pseudo_p () ? gen_reg_rtx (comp_mode) : operands[4];\n+  PUT_MODE (cc, comp_mode);\n+  emit_insn (gen_rtx_SET (cc, gen_rtx_COMPARE (comp_mode, op0, op1)));\n+  rtx cmp = gen_rtx_<eqne:CODE> (CCmode, cc, const0_rtx);\n+  rtx loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n+  emit_jump_insn (gen_rtx_SET (pc_rtx,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, cmp,\n+\t\t\t\t\t\t     loc_ref, pc_rtx)));\n+\n+  /* Keep the probability info for the prediction of the branch insn.  */\n+  rtx note = find_reg_note (curr_insn, REG_BR_PROB, 0);\n+  if (note)\n+    {\n+      profile_probability prob\n+\t= profile_probability::from_reg_br_prob_note (XINT (note, 0));\n+\n+      add_reg_br_prob_note (get_last_insn (), prob);\n+    }\n+\n+  DONE;\n+})\n+\n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n \n@@ -13463,7 +13528,6 @@\n ;; rs6000_legitimate_combined_insn prevents combine creating any of\n ;; the ctr<mode> insns.\n \n-(define_code_iterator eqne [eq ne])\n (define_code_attr bd [(eq \"bdz\") (ne \"bdnz\")])\n (define_code_attr bd_neg [(eq \"bdnz\") (ne \"bdz\")])\n "}, {"sha": "41c686bb4cbd8457348fa52dd36dc388a7aca416", "filename": "gcc/testsuite/gcc.target/powerpc/pr103743.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743.c?ref=1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-options \"-O2\" } */\n+/* { dg-do compile { target has_arch_ppc64 } } */\n+\n+/* { dg-final { scan-assembler-times {\\mcmpldi\\M} 10  } } */\n+/* { dg-final { scan-assembler-times {\\mcmpdi\\M} 4  } } */\n+/* { dg-final { scan-assembler-times {\\mrotldi\\M} 14  } } */\n+\n+int foo (int a);\n+\n+int __attribute__ ((noinline)) udi_fun (unsigned long long in)\n+{\n+  if (in == (0x8642000000000000ULL))\n+    return foo (1);\n+  if (in == (0x7642000000000000ULL))\n+    return foo (12);\n+  if (in == (0x8000000000000000ULL))\n+    return foo (32);\n+  if (in == (0x8700000000000091ULL))\n+    return foo (33);\n+  if (in == (0x8642FFFFFFFFFFFFULL))\n+    return foo (46);\n+  if (in == (0x7642FFFFFFFFFFFFULL))\n+    return foo (51);\n+  if (in == (0x7567000000ULL))\n+    return foo (9);\n+  if (in == (0xFFF8567FFFFFFFFFULL))\n+    return foo (19);\n+\n+  return 0;\n+}\n+\n+int __attribute__ ((noinline)) di_fun (long long in)\n+{\n+  if (in == (0x8642000000000000LL))\n+    return foo (1);\n+  if (in == (0x7642000000000000LL))\n+    return foo (12);\n+  if (in == (0x8000000000000000LL))\n+    return foo (32);\n+  if (in == (0x8700000000000091LL))\n+    return foo (33);\n+  if (in == (0x8642FFFFFFFFFFFFLL))\n+    return foo (46);\n+  if (in == (0x7642FFFFFFFFFFFFLL))\n+    return foo (51);\n+  if (in == (0x7567000000LL))\n+    return foo (9);\n+  if (in == (0xFFF8567FFFFFFFFFLL))\n+    return foo (19);\n+\n+  return 0;\n+}"}, {"sha": "e128aae7574c2ea6988dbd1142a37a550a970cd5", "filename": "gcc/testsuite/gcc.target/powerpc/pr103743_1.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743_1.c?ref=1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+int\n+foo (int a)\n+{\n+  return a + 6;\n+}\n+\n+int __attribute__ ((noipa)) udi_fun (unsigned long long in)\n+{\n+  if (in == (0x8642000000000000ULL))\n+    return foo (1);\n+  if (in == (0x7642000000000000ULL))\n+    return foo (12);\n+  if (in == (0x8000000000000000ULL))\n+    return foo (32);\n+  if (in == (0x8700000000000091ULL))\n+    return foo (33);\n+  if (in == (0x8642FFFFFFFFFFFFULL))\n+    return foo (46);\n+  if (in == (0x7642FFFFFFFFFFFFULL))\n+    return foo (51);\n+  if (in == (0x7567000000ULL))\n+    return foo (9);\n+  if (in == (0xFFF8567FFFFFFFFFULL))\n+    return foo (19);\n+  \n+  return 0;\n+}\n+\n+int __attribute__ ((noipa)) di_fun (long long in)\n+{\n+  if (in == (0x8642000000000000LL))\n+    return foo (1);\n+  if (in == (0x7642000000000000LL))\n+    return foo (12);\n+  if (in == (0x8000000000000000LL))\n+    return foo (32);\n+  if (in == (0x8700000000000091LL))\n+    return foo (33);\n+  if (in == (0x8642FFFFFFFFFFFFLL))\n+    return foo (46);\n+  if (in == (0x7642FFFFFFFFFFFFLL))\n+    return foo (51);\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  int e = 0;\n+  if (udi_fun (6) != 0)\n+    e++;\n+  if (udi_fun (0x8642000000000000ULL) != foo (1))\n+    e++;\n+  if (udi_fun (0x7642000000000000ULL) != foo (12))\n+    e++;\n+  if (udi_fun (0x8000000000000000ULL) != foo (32))\n+    e++;\n+  if (udi_fun (0x8700000000000091ULL) != foo (33))\n+    e++;\n+  if (udi_fun (0x8642FFFFFFFFFFFFULL) != foo (46))\n+    e++;\n+  if (udi_fun (0x7642FFFFFFFFFFFFULL) != foo (51))\n+    e++;\n+  if (udi_fun (0x7567000000ULL) != foo (9))\n+    e++;\n+  if (udi_fun (0xFFF8567FFFFFFFFFULL) != foo (19))\n+    e++;\n+\n+  if (di_fun (6) != 0)\n+    e++;\n+  if (di_fun (0x8642000000000000LL) != foo (1))\n+    e++;\n+  if (di_fun (0x7642000000000000LL) != foo (12))\n+    e++;\n+  if (di_fun (0x8000000000000000LL) != foo (32))\n+    e++;\n+  if (di_fun (0x8700000000000091LL) != foo (33))\n+    e++;\n+  if (di_fun (0x8642FFFFFFFFFFFFLL) != foo (46))\n+    e++;\n+  if (di_fun (0x7642FFFFFFFFFFFFLL) != foo (51))\n+    e++;\n+  if (udi_fun (0x7567000000LL) != foo (9))\n+    e++;\n+  if (udi_fun (0xFFF8567FFFFFFFFFLL) != foo (19))\n+    e++;\n+\n+  if (e)\n+    __builtin_abort ();\n+  return 0;\n+}\n+"}]}