{"sha": "7d73a2bae9ca5a839059e88058686d36c8b094a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q3M2EyYmFlOWNhNWE4MzkwNTllODgwNTg2ODZkMzZjOGIwOTRhNw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-08-07T22:40:07Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-08-07T22:40:07Z"}, "message": "sh.c (calc_live_regs): If the return address pointer is live, force pr live.\n\n\t* sh.c (calc_live_regs): If the return address pointer is live,\n\tforce pr live.\n\t(sh5_schedule_saves): Exclude PR_MEDIA_REG from being a temp register\n\tfor saves / restores.\n\t(sh_expand_epilogue): If sh_media_register_for_return returns a\n\tregister number, flag the instructions that restores PR_MEDIA_REG\n\tas possibly dead.\n\tRemove dead update of offset.\n\t(sh_get_pr_initial_val): Use UNSPEC_RA if we don't know yet if\n\twe can use the result of get_hard_reg_initial_val.\n\t* sh.md (UNSPEC_RA): New constant.\n\t(movsi_i_lowpart+1): Changed into a define_insn_and_split, named:\n\t(load_ra).  Handle UNSPEC_RA.\n\t(sibcall_media): Use PR_MEDIA_REG.\n\nFrom-SVN: r70234", "tree": {"sha": "5ff69d39777d33ffc717df14e7e609fd24df84c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ff69d39777d33ffc717df14e7e609fd24df84c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d73a2bae9ca5a839059e88058686d36c8b094a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d73a2bae9ca5a839059e88058686d36c8b094a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d73a2bae9ca5a839059e88058686d36c8b094a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d73a2bae9ca5a839059e88058686d36c8b094a7/comments", "author": null, "committer": null, "parents": [{"sha": "7160c99da0fe3cce45ab75fb507df25151b4408e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7160c99da0fe3cce45ab75fb507df25151b4408e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7160c99da0fe3cce45ab75fb507df25151b4408e"}], "stats": {"total": 79, "additions": 61, "deletions": 18}, "files": [{"sha": "4eb8d9ca898eb4d182465abf44375770ef612eb0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d73a2bae9ca5a839059e88058686d36c8b094a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d73a2bae9ca5a839059e88058686d36c8b094a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d73a2bae9ca5a839059e88058686d36c8b094a7", "patch": "@@ -1,5 +1,20 @@\n 2003-08-07  J\"orn Rennecke <joern.rennecke@superh.com>\n \n+\t* sh.c (calc_live_regs): If the return address pointer is live,\n+\tforce pr live.\n+\t(sh5_schedule_saves): Exclude PR_MEDIA_REG from being a temp register\n+\tfor saves / restores.\n+\t(sh_expand_epilogue): If sh_media_register_for_return returns a\n+\tregister number, flag the instructions that restores PR_MEDIA_REG\n+\tas possibly dead.\n+\tRemove dead update of offset.\n+\t(sh_get_pr_initial_val): Use UNSPEC_RA if we don't know yet if\n+\twe can use the result of get_hard_reg_initial_val.\n+\t* sh.md (UNSPEC_RA): New constant.\n+\t(movsi_i_lowpart+1): Changed into a define_insn_and_split, named:\n+\t(load_ra).  Handle UNSPEC_RA.\n+\t(sibcall_media): Use PR_MEDIA_REG.\n+\n \t* sh.h (CALL_USED_REGISTERS): Include PR_REG and PR_MEDIA_REG.\n \t* sh.c (calc_live_regs): Use sh_pr_n_sets to determine if pr\n \tneeds saving on SHmedia."}, {"sha": "d1b203b943c5adfdd2b480210ae8442a10a4e686", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d73a2bae9ca5a839059e88058686d36c8b094a7/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d73a2bae9ca5a839059e88058686d36c8b094a7/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=7d73a2bae9ca5a839059e88058686d36c8b094a7", "patch": "@@ -4848,6 +4848,8 @@ calc_live_regs (live_regs_mask)\n      the initial value can become the PR_MEDIA_REG hard register, as seen for\n      execute/20010122-1.c:test9.  */\n   if (TARGET_SHMEDIA)\n+    /* ??? this function is called from initial_elimination_offset, hence we\n+       can't use the result of sh_media_register_for_return here.  */\n     pr_live = sh_pr_n_sets ();\n   else\n     {\n@@ -4856,6 +4858,10 @@ calc_live_regs (live_regs_mask)\n \t\t ? (GET_CODE (pr_initial) != REG\n \t\t    || REGNO (pr_initial) != (PR_REG))\n \t\t : regs_ever_live[PR_REG]);\n+      /* For Shcompact, if not optimizing, we end up with a memory reference\n+\t using the return address pointer for __builtin_return_address even\n+\t though there is no actual need to put the PR register on the stack.  */\n+      pr_live |= regs_ever_live[RETURN_ADDRESS_POINTER_REGNUM];\n     }\n   /* Force PR to be live if the prologue has to call the SHmedia\n      argument decoder or register saver.  */\n@@ -5027,7 +5033,7 @@ sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n \n   if (! current_function_interrupt)\n     for (i = FIRST_GENERAL_REG; tmpx < MAX_TEMPS && i <= LAST_GENERAL_REG; i++)\n-      if (call_used_regs[i] && ! fixed_regs[i]\n+      if (call_used_regs[i] && ! fixed_regs[i] && i != PR_MEDIA_REG\n \t  && ! FUNCTION_ARG_REGNO_P (i)\n \t  && i != FIRST_RET_REG\n \t  && ! (current_function_needs_context && i == STATIC_CHAIN_REGNUM)\n@@ -5169,6 +5175,9 @@ sh_expand_prologue ()\n \t  rtx insn = emit_move_insn (gen_rtx_REG (DImode, tr),\n \t\t\t\t     gen_rtx_REG (DImode, PR_MEDIA_REG));\n \n+\t  /* ??? We should suppress saving pr when we don't need it, but this\n+\t     is tricky because of builtin_return_address.  */\n+\n \t  /* If this function only exits with sibcalls, this copy\n \t     will be flagged as dead.  */\n \t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n@@ -5552,7 +5561,7 @@ sh_expand_epilogue ()\n       save_schedule schedule;\n       save_entry *entry;\n       int *tmp_pnt;\n-      \n+\n       entry = sh5_schedule_saves (&live_regs_mask, &schedule, d_rounding);\n       offset_base = -entry[1].offset + d_rounding;\n       tmp_pnt = schedule.temps;\n@@ -5660,8 +5669,11 @@ sh_expand_epilogue ()\n \t    }\n \n \t  insn = emit_move_insn (reg_rtx, mem_rtx);\n-\n-\t  offset += GET_MODE_SIZE (mode);\n+\t  if (reg == PR_MEDIA_REG && sh_media_register_for_return () >= 0)\n+\t    /* This is dead, unless we return with a sibcall.  */\n+\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n+\t\t\t\t\t\t  const0_rtx,\n+\t\t\t\t\t\t  REG_NOTES (insn));\n \t}\n \n       if (entry->offset + offset_base != d + d_rounding)\n@@ -8835,17 +8847,29 @@ scavenge_reg (HARD_REG_SET *s)\n rtx\n sh_get_pr_initial_val (void)\n {\n+  rtx val;\n+\n   /* ??? Unfortunately, get_hard_reg_initial_val doesn't always work for the\n      PR register on SHcompact, because it might be clobbered by the prologue.\n-     We don't know if that's the case before rtl generation is finished.  */\n+     We check first if that is known to be the case.  */\n   if (TARGET_SHCOMPACT\n-      && (rtx_equal_function_value_matters\n-\t  || (current_function_args_info.call_cookie\n-\t       & ~ CALL_COOKIE_RET_TRAMP (1))\n+      && ((current_function_args_info.call_cookie\n+\t   & ~ CALL_COOKIE_RET_TRAMP (1))\n \t  || current_function_has_nonlocal_label))\n     return gen_rtx_MEM (SImode, return_address_pointer_rtx);\n-  return\n-    get_hard_reg_initial_val (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n+\n+  /* If we haven't finished rtl generation, there might be a nonlocal label\n+     that we haven't seen yet.\n+     ??? get_hard_reg_initial_val fails if it is called while no_new_pseudos\n+     is set, unless it has been called before for the same register.  And even\n+     then, we end in trouble if we didn't use the register in the same\n+     basic block before.  So call get_hard_reg_initial_val now and wrap it\n+     in an unspec if we might need to replace it.  */\n+  val\n+    = get_hard_reg_initial_val (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n+  if (TARGET_SHCOMPACT && rtx_equal_function_value_matters)\n+    return gen_rtx_UNSPEC (SImode, gen_rtvec (1, val), UNSPEC_RA);\n+  return val;\n }\n \n #include \"gt-sh.h\""}, {"sha": "2c8462ffc589dcbf65c7ca3cc9820edaaa4edf55", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d73a2bae9ca5a839059e88058686d36c8b094a7/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d73a2bae9ca5a839059e88058686d36c8b094a7/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=7d73a2bae9ca5a839059e88058686d36c8b094a7", "patch": "@@ -142,6 +142,7 @@\n   (UNSPEC_DTPOFF\t23)\n   (UNSPEC_GOTTPOFF\t24)\n   (UNSPEC_TPOFF\t\t25)\n+  (UNSPEC_RA\t\t26)\n \n   ;; These are used with unspec_volatile.\n   (UNSPECV_BLOCKAGE\t0)\n@@ -3471,16 +3472,18 @@\n \tfake\t%1,%0\"\n   [(set_attr \"type\" \"pcload,move,load,move,prget,move,store,pcload\")])\n \n-(define_split\n+(define_insn_and_split \"load_ra\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n-\t(mem:SI (reg:SI RAP_REG)))]\n-  \"TARGET_SHCOMPACT\n-   && ! rtx_equal_function_value_matters\n-   && ! ((current_function_args_info.call_cookie\n-\t  & ~ CALL_COOKIE_RET_TRAMP (1))\n-\t || current_function_has_nonlocal_label)\"\n+\t(unspec:SI [(match_operand 1 \"register_operand\" \"\")] UNSPEC_RA))]\n+  \"TARGET_SHCOMPACT\"\n+  \"#\"\n+  \"&& ! rtx_equal_function_value_matters\"\n   [(set (match_dup 0) (match_dup 1))]\n-  \"operands[1] = sh_get_pr_initial_val ();\")\n+  \"\n+{\n+  if (current_function_has_nonlocal_label)\n+    operands[1] = gen_rtx_MEM (SImode, return_address_pointer_rtx);\n+}\")\n \n (define_insn \"*movsi_media\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\"\n@@ -6174,6 +6177,7 @@\n (define_insn \"sibcall_media\"\n   [(call (mem:DI (match_operand:DI 0 \"target_reg_operand\" \"k\"))\n \t (match_operand 1 \"\" \"\"))\n+   (use (reg:SI PR_MEDIA_REG))\n    (return)]\n   \"TARGET_SHMEDIA\"\n   \"blink\t%0, r63\""}]}