{"sha": "ef9f3bc4493033daaa1ccd509817226d01e0202b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY5ZjNiYzQ0OTMwMzNkYWFhMWNjZDUwOTgxNzIyNmQwMWUwMjAyYg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-12-04T20:18:35Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-12-04T20:18:35Z"}, "message": "defineclass.cc (read_one_method_attribute): `end_pc' for an exception can be equal to code length.\n\n\t* defineclass.cc (read_one_method_attribute): `end_pc' for an\n\texception can be equal to code length.\n\t* verify.cc (_Jv_BytecodeVerifier::verify_instructions_0): Removed\n\t`start_PC' from error invocation where it didn't make sense, and\n\tupdated error message.  Use `copy' to copy a state.  Only try to\n\tmerge current state with saved state when we've fallen through\n\tfrom the previous instruction.\n\t(_Jv_BytecodeVerifier::pop_ref_or_return): New method.\n\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_astore_0]: Use\n\tpop_ref_or_return.\n\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_astore]:\n\tLikewise.\n\t(_Jv_BytecodeVerifier::push_jump_merge): Pass max_locals, not\n\tmax_stack, to merge.\n\t(_Jv_BytecodeVerifier::verify_instructions_0): Likewise.\n\t(_Jv_BytecodeVerifier::push_jump_merge): Merge from new state into\n\tstate at branch target, not vice versa.\n\t(_Jv_BytecodeVerifier::branch_prepass): Allow end of exception to\n\tbe equal to code length.  Removed redundant test to see if\n\texception start is after exception end.\n\t(_Jv_BytecodeVerifier::verify_instructions_0): Type of argument to\n\t`finally' is Throwable.\n\nFrom-SVN: r47623", "tree": {"sha": "106e1d4bef880d76ab5ec7fbfb57a2f2fe42f3b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/106e1d4bef880d76ab5ec7fbfb57a2f2fe42f3b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef9f3bc4493033daaa1ccd509817226d01e0202b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9f3bc4493033daaa1ccd509817226d01e0202b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef9f3bc4493033daaa1ccd509817226d01e0202b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9f3bc4493033daaa1ccd509817226d01e0202b/comments", "author": null, "committer": null, "parents": [{"sha": "5b5e609d03ec31780977795463c3b12f1c2387f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5e609d03ec31780977795463c3b12f1c2387f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b5e609d03ec31780977795463c3b12f1c2387f3"}], "stats": {"total": 117, "additions": 83, "deletions": 34}, "files": [{"sha": "1e1311a1e9719b32b59ba6098ea7b268fbc4aaf5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef9f3bc4493033daaa1ccd509817226d01e0202b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef9f3bc4493033daaa1ccd509817226d01e0202b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ef9f3bc4493033daaa1ccd509817226d01e0202b", "patch": "@@ -1,3 +1,28 @@\n+2001-12-04  Tom Tromey  <tromey@redhat.com>\n+\n+\t* defineclass.cc (read_one_method_attribute): `end_pc' for an\n+\texception can be equal to code length.\n+\t* verify.cc (_Jv_BytecodeVerifier::verify_instructions_0): Removed\n+\t`start_PC' from error invocation where it didn't make sense, and\n+\tupdated error message.  Use `copy' to copy a state.  Only try to\n+\tmerge current state with saved state when we've fallen through\n+\tfrom the previous instruction.\n+\t(_Jv_BytecodeVerifier::pop_ref_or_return): New method.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_astore_0]: Use\n+\tpop_ref_or_return.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_astore]:\n+\tLikewise.\n+\t(_Jv_BytecodeVerifier::push_jump_merge): Pass max_locals, not\n+\tmax_stack, to merge.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0): Likewise.\n+\t(_Jv_BytecodeVerifier::push_jump_merge): Merge from new state into\n+\tstate at branch target, not vice versa.\n+\t(_Jv_BytecodeVerifier::branch_prepass): Allow end of exception to\n+\tbe equal to code length.  Removed redundant test to see if\n+\texception start is after exception end.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0): Type of argument to\n+\t`finally' is Throwable.\n+\n 2001-12-04  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* Makefile.in: Rebuilt with automake-gcj."}, {"sha": "5fb8de3b0f37b237df800c21f2afa241e724cf97", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef9f3bc4493033daaa1ccd509817226d01e0202b/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef9f3bc4493033daaa1ccd509817226d01e0202b/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=ef9f3bc4493033daaa1ccd509817226d01e0202b", "patch": "@@ -582,7 +582,9 @@ void _Jv_ClassReader::read_one_method_attribute (int method_index)\n \n \t  if (start_pc > end_pc\n \t      || start_pc < 0\n-\t      || end_pc >= code_length\n+\t      // END_PC can be equal to CODE_LENGTH.\n+\t      // See JVM Spec 4.7.4.\n+\t      || end_pc > code_length\n \t      || handler_pc >= code_length)\n \t    throw_class_format_error (\"erroneous exception handler info\");\n "}, {"sha": "3016ea42eca0752523b0f691acf3d643f85e3e3a", "filename": "libjava/verify.cc", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef9f3bc4493033daaa1ccd509817226d01e0202b/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef9f3bc4493033daaa1ccd509817226d01e0202b/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=ef9f3bc4493033daaa1ccd509817226d01e0202b", "patch": "@@ -8,7 +8,7 @@ This software is copyrighted work licensed under the terms of the\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n-// Writte by Tom Tromey <tromey@redhat.com>\n+// Written by Tom Tromey <tromey@redhat.com>\n \n #include <config.h>\n \n@@ -889,6 +889,15 @@ class _Jv_BytecodeVerifier\n     return t;\n   }\n \n+  // Pop a reference type or a return address.\n+  type pop_ref_or_return ()\n+  {\n+    type t = pop_raw ();\n+    if (! t.isreference () && t.key != return_address_type)\n+      verify_fail (\"expected reference or return address on stack\", start_PC);\n+    return t;\n+  }\n+\n   void push_type (type t)\n   {\n     // If T is a numeric type like short, promote it to int.\n@@ -1006,10 +1015,11 @@ class _Jv_BytecodeVerifier\n     return npc;\n   }\n \n-  // Merge the indicated state into a new state and schedule a new PC if\n-  // there is a change.  If RET_SEMANTICS is true, then we are merging\n-  // from a `ret' instruction into the instruction after a `jsr'.  This\n-  // is a special case with its own modified semantics.\n+  // Merge the indicated state into the state at the branch target and\n+  // schedule a new PC if there is a change.  If RET_SEMANTICS is\n+  // true, then we are merging from a `ret' instruction into the\n+  // instruction after a `jsr'.  This is a special case with its own\n+  // modified semantics.\n   void push_jump_merge (int npc, state *nstate, bool ret_semantics = false)\n   {\n     bool changed = true;\n@@ -1021,8 +1031,8 @@ class _Jv_BytecodeVerifier\n \t\t\t\t current_method->max_locals);\n       }\n     else\n-      changed = nstate->merge (states[npc], ret_semantics,\n-\t\t\t       current_method->max_stack);\n+      changed = states[npc]->merge (nstate, ret_semantics,\n+\t\t\t\t    current_method->max_locals);\n \n     if (changed && states[npc]->next == state::INVALID)\n       {\n@@ -1506,12 +1516,11 @@ class _Jv_BytecodeVerifier\n \tif (! (flags[exception[i].handler_pc] & FLAG_INSN_START))\n \t  verify_fail (\"exception handler not at instruction start\",\n \t\t       exception[i].handler_pc);\n-\tif (exception[i].start_pc > exception[i].end_pc)\n-\t  verify_fail (\"exception range inverted\");\n \tif (! (flags[exception[i].start_pc] & FLAG_INSN_START))\n \t  verify_fail (\"exception start not at instruction start\",\n \t\t       exception[i].start_pc);\n-\telse if (! (flags[exception[i].end_pc] & FLAG_INSN_START))\n+\tif (exception[i].end_pc != current_method->code_length\n+\t    && ! (flags[exception[i].end_pc] & FLAG_INSN_START))\n \t  verify_fail (\"exception end not at instruction start\",\n \t\t       exception[i].end_pc);\n \n@@ -1729,35 +1738,48 @@ class _Jv_BytecodeVerifier\n \t  {\n \t    PC = pop_jump ();\n \t    if (PC == state::INVALID)\n-\t      verify_fail (\"saw state::INVALID\", start_PC);\n+\t      verify_fail (\"can't happen: saw state::INVALID\");\n \t    if (PC == state::NO_NEXT)\n \t      break;\n \t    // Set up the current state.\n-\t    *current_state = *states[PC];\n+\t    current_state->copy (states[PC], current_method->max_stack,\n+\t\t\t\t current_method->max_locals);\n \t  }\n-\n-\t// Control can't fall off the end of the bytecode.\n-\tif (PC >= current_method->code_length)\n-\t  verify_fail (\"fell off end\");\n-\n-\tif (states[PC] != NULL)\n+\telse\n \t  {\n-\t    // We've already visited this instruction.  So merge the\n-\t    // states together.  If this yields no change then we don't\n-\t    // have to re-verify.\n-\t    if (! current_state->merge (states[PC], false,\n-\t\t\t\t\tcurrent_method->max_stack))\n+\t    // Control can't fall off the end of the bytecode.  We\n+\t    // only need to check this in the fall-through case,\n+\t    // because branch bounds are checked when they are\n+\t    // pushed.\n+\t    if (PC >= current_method->code_length)\n+\t      verify_fail (\"fell off end\");\n+\n+\t    // We only have to do this checking in the situation where\n+\t    // control flow falls through from the previous\n+\t    // instruction.  Otherwise merging is done at the time we\n+\t    // push the branch.\n+\t    if (states[PC] != NULL)\n \t      {\n-\t\tinvalidate_pc ();\n-\t\tcontinue;\n+\t\t// We've already visited this instruction.  So merge\n+\t\t// the states together.  If this yields no change then\n+\t\t// we don't have to re-verify.\n+\t\tif (! current_state->merge (states[PC], false,\n+\t\t\t\t\t    current_method->max_locals))\n+\t\t  {\n+\t\t    invalidate_pc ();\n+\t\t    continue;\n+\t\t  }\n+\t\t// Save a copy of it for later.\n+\t\tstates[PC]->copy (current_state, current_method->max_stack,\n+\t\t\t\t  current_method->max_locals);\n \t      }\n-\t    // Save a copy of it for later.\n-\t    states[PC]->copy (current_state, current_method->max_stack,\n-\t\t\t      current_method->max_locals);\n \t  }\n-\telse if ((flags[PC] & FLAG_BRANCH_TARGET))\n+\n+\t// We only have to keep saved state at branch targets.  If\n+\t// we're at a branch target and the state here hasn't been set\n+\t// yet, we set it now.\n+\tif (states[PC] == NULL && (flags[PC] & FLAG_BRANCH_TARGET))\n \t  {\n-\t    // We only have to keep saved state at branch targets.\n \t    states[PC] = new state (current_state, current_method->max_stack,\n \t\t\t\t    current_method->max_locals);\n \t  }\n@@ -1769,7 +1791,7 @@ class _Jv_BytecodeVerifier\n \t  {\n \t    if (PC >= exception[i].start_pc && PC < exception[i].end_pc)\n \t      {\n-\t\ttype handler = reference_type;\n+\t\ttype handler (&java::lang::Throwable::class$);\n \t\tif (exception[i].handler_type != 0)\n \t\t  handler = check_class_constant (exception[i].handler_type);\n \t\tpush_exception_jump (handler, exception[i].handler_pc);\n@@ -1932,7 +1954,7 @@ class _Jv_BytecodeVerifier\n \t    set_variable (get_byte (), pop_type (double_type));\n \t    break;\n \t  case op_astore:\n-\t    set_variable (get_byte (), pop_type (reference_type));\n+\t    set_variable (get_byte (), pop_ref_or_return ());\n \t    break;\n \t  case op_istore_0:\n \t  case op_istore_1:\n@@ -1962,7 +1984,7 @@ class _Jv_BytecodeVerifier\n \t  case op_astore_1:\n \t  case op_astore_2:\n \t  case op_astore_3:\n-\t    set_variable (opcode - op_astore_0, pop_type (reference_type));\n+\t    set_variable (opcode - op_astore_0, pop_ref_or_return ());\n \t    break;\n \t  case op_iastore:\n \t    pop_type (int_type);"}]}