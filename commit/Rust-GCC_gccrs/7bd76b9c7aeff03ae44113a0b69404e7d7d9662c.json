{"sha": "7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JkNzZiOWM3YWVmZjAzYWU0NDExM2EwYjY5NDA0ZTdkN2Q5NjYyYw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-01T08:34:02Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-01T08:34:02Z"}, "message": "re PR target/50457 (SH2A atomic functions)\n\n\tPR target/50457\n\t* config/sh/sh.opt (matomic-model): New option.\n\t(msoft-atomic): Mark as deprecated and alias to matomic-model=soft-gusa.\n\t(mhard-atomic): Delete.\n\t* config/sh/predicates.md (gbr_displacement): New predicate.\n\t* config/sh/sh-protos.h (sh_atomic_model): New struct.\n\t(selected_atomic_model): New declaration.\n\t(TARGET_ATOMIC_ANY, TARGET_ATOMIC_STRICT, TARGET_ATOMIC_SOFT_GUSA,\n\tTARGET_ATOMIC_HARD_LLCS, TARGET_ATOMIC_SOFT_TCB,\n\tTARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX, TARGET_ATOMIC_SOFT_IMASK):\n\tNew macros.\n\t* config/sh/linux.h (SUBTARGET_OVERRIDE_OPTIONS): Adapt setting to\n\tdefault atomic model.\n\t* config/sh/sh.c (selected_atomic_model_): New global variable.\n\t(selected_atomic_model, parse_validate_atomic_model_option): New\n\tfunctions.\n\t(sh_option_override): Replace atomic selection checks with call to\n\tparse_validate_atomic_model_option.\n\t* config/sh/sh.h (TARGET_ANY_ATOMIC, UNSUPPORTED_ATOMIC_OPTIONS,\n\tUNSUPPORTED_HARD_ATOMIC_CPU): Delete.\n\t(DRIVER_SELF_SPECS): Remove atomic checks.\n\tconfig/sh/sync.md: Update documentation comments.\n\t(atomic_compare_and_swap<mode>, atomic_exchange<mode>,\n\tatomic_fetch_<fetchop_name><mode>, atomic_fetch_nand<mode>,\n\tatomic_<fetchop_name>_fetch<mode>, atomic_nand_fetch<mode>): Use\n\tTARGET_ATOMIC_ANY as condition.  Add TARGET_ATOMIC_STRICT check for\n\tSH4A case.  Handle new TARGET_ATOMIC_SOFT_TCB and\n\tTARGET_ATOMIC_SOFT_IMASK cases.\n\t(atomic_test_and_set): Handle new TARGET_ATOMIC_SOFT_TCB and\n\tTARGET_ATOMIC_SOFT_IMASK cases.\n\t(atomic_compare_and_swapsi_hard, atomic_exchangesi_hard,\n\tatomic_fetch_<fetchop_name>si_hard, atomic_fetch_nandsi_hard,\n\tatomic_<fetchop_name>_fetchsi_hard, atomic_nand_fetchsi_hard):\n\tAdd TARGET_ATOMIC_STRICT check.\n\t(atomic_compare_and_swap<mode>_hard, atomic_exchange<mode>_hard,\n\tatomic_fetch_<fetchop_name><mode>_hard, atomic_fetch_nand<mode>_hard,\n\tatomic_<fetchop_name>_fetch<mode>_hard, atomic_nand_fetch<mode>_hard,\n\tatomic_test_and_set_hard): Use TARGET_ATOMIC_HARD_LLCS condition.\n\t(atomic_compare_and_swap<mode>_soft, atomic_exchange<mode>_soft,\n\tatomic_fetch_<fetchop_name><mode>_soft, atomic_fetch_nand<mode>_soft,\n\tatomic_<fetchop_name>_fetch<mode>_soft, atomic_nand_fetch<mode>_soft,\n\tatomic_test_and_set_soft): Append _gusa to the insn names and use\n\tTARGET_ATOMIC_SOFT_GUSA as condition.\n\t(atomic_compare_and_swap<mode>_soft_tcb, atomic_exchange<mode>_soft_tcb,\n\tatomic_fetch_<fetchop_name><mode>_soft_tcb,\n\tatomic_fetch_nand<mode>_soft_tcb,\n\tatomic_<fetchop_name>_fetch<mode>_soft_tcb,\n\tatomic_nand_fetch<mode>_soft_tcb, atomic_test_and_set_soft_tcb):\n\tNew insns.\n\t(atomic_compare_and_swap<mode>_soft_imask,\n\tatomic_exchange<mode>_soft_imask,\n\tatomic_fetch_<fetchop_name><mode>_soft_imask,\n\tatomic_fetch_nand<mode>_soft_imask,\n\tatomic_<fetchop_name>_fetch<mode>_soft_imask,\n\tatomic_nand_fetch<mode>_soft_imask, atomic_test_and_set_soft_imask):\n\tNew insns.\n\t* doc/invoke.texi (SH Options): Document new matomic-model option.\n\tRemove msoft-atomic and mhard-atomic options.\n\nFrom-SVN: r191899", "tree": {"sha": "9634121edebbd5607fd917c321c00f58848bbd6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9634121edebbd5607fd917c321c00f58848bbd6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/comments", "author": null, "committer": null, "parents": [{"sha": "3db3967673655193c5478148872aadca7fb0a925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db3967673655193c5478148872aadca7fb0a925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3db3967673655193c5478148872aadca7fb0a925"}], "stats": {"total": 998, "additions": 876, "deletions": 122}, "files": [{"sha": "2acf70a3077a3390cc485a8df38cdf88bbc438b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -1,3 +1,64 @@\n+2012-10-01  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50457\n+\t* config/sh/sh.opt (matomic-model): New option.\n+\t(msoft-atomic): Mark as deprecated and alias to matomic-model=soft-gusa.\n+\t(mhard-atomic): Delete.\n+\t* config/sh/predicates.md (gbr_displacement): New predicate.\n+\t* config/sh/sh-protos.h (sh_atomic_model): New struct.\n+\t(selected_atomic_model): New declaration.\n+\t(TARGET_ATOMIC_ANY, TARGET_ATOMIC_STRICT, TARGET_ATOMIC_SOFT_GUSA,\n+\tTARGET_ATOMIC_HARD_LLCS, TARGET_ATOMIC_SOFT_TCB,\n+\tTARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX, TARGET_ATOMIC_SOFT_IMASK):\n+\tNew macros.\n+\t* config/sh/linux.h (SUBTARGET_OVERRIDE_OPTIONS): Adapt setting to\n+\tdefault atomic model.\n+\t* config/sh/sh.c (selected_atomic_model_): New global variable.\n+\t(selected_atomic_model, parse_validate_atomic_model_option): New\n+\tfunctions.\n+\t(sh_option_override): Replace atomic selection checks with call to\n+\tparse_validate_atomic_model_option.\n+\t* config/sh/sh.h (TARGET_ANY_ATOMIC, UNSUPPORTED_ATOMIC_OPTIONS,\n+\tUNSUPPORTED_HARD_ATOMIC_CPU): Delete.\n+\t(DRIVER_SELF_SPECS): Remove atomic checks.\n+\tconfig/sh/sync.md: Update documentation comments.\n+\t(atomic_compare_and_swap<mode>, atomic_exchange<mode>,\n+\tatomic_fetch_<fetchop_name><mode>, atomic_fetch_nand<mode>,\n+\tatomic_<fetchop_name>_fetch<mode>, atomic_nand_fetch<mode>): Use\n+\tTARGET_ATOMIC_ANY as condition.  Add TARGET_ATOMIC_STRICT check for\n+\tSH4A case.  Handle new TARGET_ATOMIC_SOFT_TCB and\n+\tTARGET_ATOMIC_SOFT_IMASK cases.\n+\t(atomic_test_and_set): Handle new TARGET_ATOMIC_SOFT_TCB and\n+\tTARGET_ATOMIC_SOFT_IMASK cases.\n+\t(atomic_compare_and_swapsi_hard, atomic_exchangesi_hard,\n+\tatomic_fetch_<fetchop_name>si_hard, atomic_fetch_nandsi_hard,\n+\tatomic_<fetchop_name>_fetchsi_hard, atomic_nand_fetchsi_hard):\n+\tAdd TARGET_ATOMIC_STRICT check.\n+\t(atomic_compare_and_swap<mode>_hard, atomic_exchange<mode>_hard,\n+\tatomic_fetch_<fetchop_name><mode>_hard, atomic_fetch_nand<mode>_hard,\n+\tatomic_<fetchop_name>_fetch<mode>_hard, atomic_nand_fetch<mode>_hard,\n+\tatomic_test_and_set_hard): Use TARGET_ATOMIC_HARD_LLCS condition.\n+\t(atomic_compare_and_swap<mode>_soft, atomic_exchange<mode>_soft,\n+\tatomic_fetch_<fetchop_name><mode>_soft, atomic_fetch_nand<mode>_soft,\n+\tatomic_<fetchop_name>_fetch<mode>_soft, atomic_nand_fetch<mode>_soft,\n+\tatomic_test_and_set_soft): Append _gusa to the insn names and use\n+\tTARGET_ATOMIC_SOFT_GUSA as condition.\n+\t(atomic_compare_and_swap<mode>_soft_tcb, atomic_exchange<mode>_soft_tcb,\n+\tatomic_fetch_<fetchop_name><mode>_soft_tcb,\n+\tatomic_fetch_nand<mode>_soft_tcb,\n+\tatomic_<fetchop_name>_fetch<mode>_soft_tcb,\n+\tatomic_nand_fetch<mode>_soft_tcb, atomic_test_and_set_soft_tcb):\n+\tNew insns.\n+\t(atomic_compare_and_swap<mode>_soft_imask,\n+\tatomic_exchange<mode>_soft_imask,\n+\tatomic_fetch_<fetchop_name><mode>_soft_imask,\n+\tatomic_fetch_nand<mode>_soft_imask,\n+\tatomic_<fetchop_name>_fetch<mode>_soft_imask,\n+\tatomic_nand_fetch<mode>_soft_imask, atomic_test_and_set_soft_imask):\n+\tNew insns.\n+\t* doc/invoke.texi (SH Options): Document new matomic-model option.\n+\tRemove msoft-atomic and mhard-atomic options.\n+\n 2012-10-01  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \tPR target/54746"}, {"sha": "e3fec2f542d303096ff98f492dfaab362b6b065f", "filename": "gcc/config/sh/linux.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flinux.h?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -138,11 +138,16 @@ along with GCC; see the file COPYING3.  If not see\n #define TARGET_INIT_LIBFUNCS  sh_init_sync_libfuncs\n \n #undef SUBTARGET_OVERRIDE_OPTIONS\n-#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      /* Defaulting to -msoft-atomic.  */\t\t\\\n-      if (global_options_set.x_TARGET_SOFT_ATOMIC == 0)\t\\\n-\tTARGET_SOFT_ATOMIC = 1;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n+#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* Set default atomic model if it hasn't been specified.  */\t\\\n+      if (global_options_set.x_sh_atomic_model_str == 0)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (TARGET_SH3)\t\t\t\t\t\t\\\n+\t    sh_atomic_model_str = \"soft-gusa\";\t\t\t\t\\\n+\t  else if (TARGET_SH1)\t\t\t\t\t\t\\\n+\t    sh_atomic_model_str = \"soft-imask\";\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   while (0)"}, {"sha": "05ad85808bbf3fca92573f6a3625c981083808df", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -1071,3 +1071,19 @@\n \n   return false;\n })\n+\n+;; A predicate that determines whether a given constant is a valid\n+;; displacement for a gbr load/store of the specified mode.\n+(define_predicate \"gbr_displacement\"\n+  (match_code \"const_int\")\n+{\n+  const int mode_sz = GET_MODE_SIZE (mode);\n+  const int move_sz = mode_sz > GET_MODE_SIZE (SImode)\n+\t\t\t\t? GET_MODE_SIZE (SImode)\n+\t\t\t\t: mode_sz;\n+  int max_disp = 255 * move_sz;\n+  if (mode_sz > move_sz)\n+    max_disp -= mode_sz - move_sz;\n+\n+  return INTVAL (op) >= 0 && INTVAL (op) <= max_disp;\n+})"}, {"sha": "135a5c43a9d370c50e4ded4cb20d551f863ffe91", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -37,6 +37,51 @@ enum sh_function_kind {\n   SFUNC_STATIC\n };\n \n+/* Atomic model.  */\n+struct sh_atomic_model\n+{\n+  enum enum_type\n+  {\n+    none = 0,\n+    soft_gusa,\n+    hard_llcs,\n+    soft_tcb,\n+    soft_imask,\n+\n+    num_models\n+  };\n+\n+  /*  If strict is set, disallow mixing of different models, as it would\n+      happen on SH4A.  */\n+  bool strict;\n+  enum_type type;\n+  int tcb_gbr_offset;\n+};\n+\n+extern const sh_atomic_model& selected_atomic_model (void);\n+\n+/* Shortcuts to check the currently selected atomic model.  */\n+#define TARGET_ATOMIC_ANY \\\n+  selected_atomic_model ().type != sh_atomic_model::none\n+\n+#define TARGET_ATOMIC_STRICT \\\n+  selected_atomic_model ().strict\n+\n+#define TARGET_ATOMIC_SOFT_GUSA \\\n+  selected_atomic_model ().type == sh_atomic_model::soft_gusa\n+\n+#define TARGET_ATOMIC_HARD_LLCS \\\n+  selected_atomic_model ().type == sh_atomic_model::hard_llcs\n+\n+#define TARGET_ATOMIC_SOFT_TCB \\\n+  selected_atomic_model ().type == sh_atomic_model::soft_tcb\n+\n+#define TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX \\\n+  GEN_INT (selected_atomic_model ().tcb_gbr_offset)\n+\n+#define TARGET_ATOMIC_SOFT_IMASK \\\n+  selected_atomic_model ().type == sh_atomic_model::soft_imask\n+\n #ifdef RTX_CODE\n extern rtx sh_fsca_sf2int (void);\n extern rtx sh_fsca_int2sf (void);"}, {"sha": "ebfacbbcfe04af745c94db9e3f14ef8e579f4881", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 110, "deletions": 6, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -62,6 +62,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm-constrs.h\"\n #include \"opts.h\"\n \n+#include <sstream>\n+#include <vector>\n #include <algorithm>\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n@@ -596,6 +598,110 @@ static const struct attribute_spec sh_attribute_table[] =\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+\n+/* Information on the currently selected atomic model.\n+   This is initialized in sh_option_override.  */\n+static sh_atomic_model selected_atomic_model_;\n+\n+const sh_atomic_model&\n+selected_atomic_model (void)\n+{\n+  return selected_atomic_model_;\n+}\n+\n+static sh_atomic_model\n+parse_validate_atomic_model_option (const char* str)\n+{\n+  const char* model_names[sh_atomic_model::num_models];\n+  model_names[sh_atomic_model::none] = \"none\";\n+  model_names[sh_atomic_model::soft_gusa] = \"soft-gusa\";\n+  model_names[sh_atomic_model::hard_llcs] = \"hard-llcs\";\n+  model_names[sh_atomic_model::soft_tcb] = \"soft-tcb\";\n+  model_names[sh_atomic_model::soft_imask] = \"soft-imask\";\n+\n+  sh_atomic_model ret;\n+  ret.type = sh_atomic_model::none;\n+  ret.strict = false;\n+  ret.tcb_gbr_offset = -1;\n+\n+  /* Handle empty string as 'none'.  */\n+  if (str == NULL || *str == '\\0')\n+    return ret;\n+\n+#define err_ret(...) do { error (__VA_ARGS__); return ret; } while (0)\n+\n+  std::vector<std::string> tokens;\n+  for (std::stringstream ss (str); ss.good (); )\n+  {\n+    tokens.push_back (std::string ());\n+    std::getline (ss, tokens.back (), ',');\n+  }\n+\n+  if (tokens.empty ())\n+    err_ret (\"invalid atomic model option\");\n+\n+  /* The first token must be the atomic model name.  */\n+  {\n+    for (size_t i = 0; i < sh_atomic_model::num_models; ++i)\n+      if (tokens.front () == model_names[i])\n+\t{\n+\t  ret.type = (sh_atomic_model::enum_type)i;\n+\t  goto got_mode_name;\n+\t}\n+\n+    err_ret (\"invalid atomic model name \\\"%s\\\"\", tokens.front ().c_str ());\n+got_mode_name:;\n+  }\n+\n+  /* Go through the remaining tokens.  */\n+  for (size_t i = 1; i < tokens.size (); ++i)\n+    {\n+      if (tokens[i] == \"strict\")\n+\tret.strict = true;\n+      else if (tokens[i].find (\"gbr-offset=\") == 0)\n+\t{\n+\t  std::string offset_str = tokens[i].substr (strlen (\"gbr-offset=\"));\n+\t  ret.tcb_gbr_offset = integral_argument (offset_str.c_str ());\n+\t  if (offset_str.empty () || ret.tcb_gbr_offset == -1)\n+\t    err_ret (\"could not parse gbr-offset value \\\"%s\\\" in atomic model \"\n+\t\t     \"option\", offset_str.c_str ());\n+\t}\n+      else\n+\terr_ret (\"unknown parameter \\\"%s\\\" in atomic model option\",\n+\t         tokens[i].c_str ());\n+    }\n+\n+  /* Check that the selection makes sense.  */\n+  if (TARGET_SHMEDIA && ret.type != sh_atomic_model::none)\n+    err_ret (\"atomic operations are not supported on SHmedia\");\n+\n+  if (ret.type == sh_atomic_model::soft_gusa && !TARGET_SH3)\n+    err_ret (\"atomic model %s is only available on SH3 and SH4 targets\",\n+\t     model_names[ret.type]);\n+\n+  if (ret.type == sh_atomic_model::hard_llcs && !TARGET_SH4A)\n+    err_ret (\"atomic model %s is only available on SH4A targets\",\n+\t     model_names[ret.type]);\n+\n+  if (ret.type == sh_atomic_model::soft_tcb && ret.tcb_gbr_offset == -1)\n+    err_ret (\"atomic model %s requires gbr-offset parameter\", \n+\t     model_names[ret.type]);\n+\n+  if (ret.type == sh_atomic_model::soft_tcb\n+      && (ret.tcb_gbr_offset < 0 || ret.tcb_gbr_offset > 1020\n+          || (ret.tcb_gbr_offset & 3) != 0))\n+    err_ret (\"invalid gbr-offset value \\\"%d\\\" for atomic model %s; it must be \"\n+\t     \"a multiple of 4 in the range 0-1020\", ret.tcb_gbr_offset,\n+\t     model_names[ret.type]);\n+\n+  if (ret.type == sh_atomic_model::soft_imask && TARGET_USERMODE)\n+    err_ret (\"cannot use atomic model %s in user mode\", model_names[ret.type]);\n+\n+  return ret;\n+\n+#undef err_ret\n+}\n+\n /* Implement TARGET_OPTION_OVERRIDE macro.  Validate and override \n    various options, and do some machine dependent initialization.  */\n static void\n@@ -907,12 +1013,10 @@ sh_option_override (void)\n   if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))\n     flag_strict_volatile_bitfields = 1;\n \n-  /* Make sure that only one atomic mode is selected and that the selection\n-     is valid for the current target CPU.  */\n-  if (TARGET_SOFT_ATOMIC && TARGET_HARD_ATOMIC)\n-    error (\"-msoft-atomic and -mhard-atomic cannot be used at the same time\");\n-  if (TARGET_HARD_ATOMIC && ! TARGET_SH4A_ARCH)\n-    error (\"-mhard-atomic is only available for SH4A targets\");\n+  /* Parse atomic model option and make sure it is valid for the current\n+     target CPU.  */\n+  selected_atomic_model_\n+    = parse_validate_atomic_model_option (sh_atomic_model_str);\n }\n \f\n /* Print the operand address in x to the stream.  */"}, {"sha": "546cb6fd3cb200f32e41ed38625199234d0c8ad8", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -172,9 +172,6 @@ do { \\\n   (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5 \\\n    && ! (TARGET_HITACHI || sh_attr_renesas_p (FUN_DECL)))\n \n-/* Nonzero if either soft or hard atomics are enabled.  */\n-#define TARGET_ANY_ATOMIC (TARGET_SOFT_ATOMIC | TARGET_HARD_ATOMIC)\n-\n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT SELECT_SH1\n #define SUPPORT_SH1 1\n@@ -436,20 +433,8 @@ do { \\\n \"%{m2a*:%eSH2a does not support little-endian}}\"\n #endif\n \n-#define UNSUPPORTED_ATOMIC_OPTIONS \\\n-\"%{msoft-atomic:%{mhard-atomic:%e-msoft-atomic and -mhard-atomic cannot be \\\n-used at the same time}}\"\n-\n-#if TARGET_CPU_DEFAULT & MASK_SH4A\n-#define UNSUPPORTED_HARD_ATOMIC_CPU \"\"\n-#else\n-#define UNSUPPORTED_HARD_ATOMIC_CPU \\\n-\"%{!m4a*:%{mhard-atomic:%e-mhard-atomic is only available for SH4A targets}}\"\n-#endif\n-\n #undef DRIVER_SELF_SPECS\n-#define DRIVER_SELF_SPECS UNSUPPORTED_SH2A, UNSUPPORTED_ATOMIC_OPTIONS,\\\n-\t\t\t  UNSUPPORTED_HARD_ATOMIC_CPU\n+#define DRIVER_SELF_SPECS UNSUPPORTED_SH2A\n \n #define ASSEMBLER_DIALECT assembler_dialect\n "}, {"sha": "df9df6d3e1244a60aa1b7705fa570be44d7522ac", "filename": "gcc/config/sh/sh.opt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -320,12 +320,12 @@ Target Mask(HITACHI)\n Follow Renesas (formerly Hitachi) / SuperH calling conventions\n \n msoft-atomic\n-Target Report Var(TARGET_SOFT_ATOMIC)\n-Use gUSA software atomic sequences\n+Target Undocumented Alias(matomic-model=, soft-gusa, none)\n+Deprecated.  Use -matomic= instead to select the atomic model\n \n-mhard-atomic\n-Target Report Var(TARGET_HARD_ATOMIC)\n-Use hardware atomic sequences\n+matomic-model=\n+Target Report RejectNegative Joined Var(sh_atomic_model_str)\n+Specify the model for atomic operations\n \n mtas\n Target Report RejectNegative Var(TARGET_ENABLE_TAS)"}, {"sha": "6cd982c79b1eebe5d36efc8753480568374bf06a", "filename": "gcc/config/sh/sync.md", "status": "modified", "additions": 564, "deletions": 68, "changes": 632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fconfig%2Fsh%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsync.md?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -22,9 +22,12 @@\n ;; Atomic integer operations for the Renesas / SuperH SH CPUs.\n ;;\n ;; On SH CPUs atomic integer operations can be done either in 'software' or\n-;; in 'hardware', where true hardware support was introduced with the SH4A.\n-;; In addition to that all SH CPUs support the 'tas.b' instruction, which\n-;; can be optionally used to implement the 'atomic_test_and_set' builtin.\n+;; in 'hardware' in various styles.  True hardware support was introduced\n+;; with the SH4A.  Some SH2A dual-core models (e.g. SH7205) also come with\n+;; 'semaphore' hardware registers, but these are currently unsupported.\n+;; All SH CPUs support the 'tas.b' instruction, which can be optionally used\n+;; to implement the 'atomic_test_and_set' builtin.\n+;; The following atomic options and models are supported.\n ;;\n ;; tas.b atomic_test_and_set (-mtas)\n ;;\n@@ -37,7 +40,7 @@\n ;; other atomic operations.\n ;;\n ;;\n-;; Hardware Atomics (-mhard-atomic, SH4A only)\n+;; Hardware Atomics (-matomic-model=hard-llcs; SH4A only)\n ;;\n ;; Hardware atomics implement all atomic operations using the 'movli.l' and\n ;; 'movco.l' instructions that are availble on SH4A.  On multi-core hardware\n@@ -48,7 +51,7 @@\n ;; larger code.\n ;;\n ;;\n-;; Software Atomics (-msoft-atomic)\n+;; gUSA Software Atomics (-matomic-model=soft-gusa; SH3*, SH4* only)\n ;;\n ;; On single-core systems there can only be one execution context running\n ;; at a given point in time.  This allows the usage of rewindable atomic\n@@ -68,9 +71,8 @@\n ;;\t  interrupted_pc = atomic_entrypoint;\n ;;\n ;; This method is also known as gUSA (\"g\" User Space Atomicity) and the\n-;; Linux kernel for SH3/SH4 implements support for such software\n-;; atomic sequences.  However, it can also be implemented in freestanding\n-;; environments.\n+;; Linux kernel for SH3/SH4 implements support for such software atomic\n+;; sequences.  It can also be implemented in freestanding environments.\n ;;\n ;; For this the following atomic sequence ABI is used.\n ;;\n@@ -111,16 +113,72 @@\n ;; For correct operation the atomic sequences must not be rewound after\n ;; they have passed the write-back instruction.\n ;;\n+;; This is model works only on SH3* and SH4* because the stack pointer (r15)\n+;; is set to an invalid pointer temporarily.  SH1* and SH2* CPUs will try\n+;; to push SR and PC registers on the stack when an interrupt / exception\n+;; occurs, and thus require the stack pointer (r15) always to be valid.\n+;;\n+;;\n+;; TCB Software Atomics (-matomic-model=soft-tcb)\n+;;\n+;; This model is a variation of the gUSA model.  The concept of rewindable\n+;; atomic sequences is the same, but it does not use the stack pointer (r15)\n+;; for signaling the 'is in atomic sequence' condition.  Instead, a variable\n+;; in the thread control block (TCB) is set to hold the exit point of the\n+;; atomic sequence.  This assumes that the GBR is used as a thread pointer\n+;; register.  The offset of the variable in the TCB to be used must be\n+;; specified with an additional option 'gbr-offset', such as:\n+;;\t-matomic-model=soft-tcb,gbr-offset=4\n+;;\n+;; For this model the following atomic sequence ABI is used.\n+;; \n+;; @(#x,gbr) == 0:  Execution context is not in an atomic sequence.\n+;;\n+;; @(#x,gbr) != 0:  Execution context is in an atomic sequence.  In this\n+;;\t\t    case the following applies:\n+;;\n+;;\t\t    @(#x,gbr):\tPC of the first instruction after the atomic\n+;;\t\t\t\twrite-back instruction (exit point).\n+;;\n+;;\t\t    r1:\t\tNegative byte length of the atomic sequence.\n+;;\t\t\t\tThe entry point PC of the sequence can be\n+;;\t\t\t\tdetermined by doing @(#x,gbr) + r1\n+;;\n+;; Note: #x is the user specified gbr-offset.\n+;;\n+;;\n+;; Interrupt-Flipping Software Atomics (-matomic-model=soft-imask)\n+;;\n+;; This model achieves atomicity by temporarily disabling interrupts for\n+;; the duration of the atomic sequence.  This works only when the program\n+;; runs in privileged mode but does not require any support from the\n+;; interrupt / exception handling code.  There is no particular ABI.\n+;; To disable interrupts the SR.IMASK bits are set to '1111'.\n+;; This method is not as efficient as the other software atomic models,\n+;; since loading and storing SR (in order to flip interrupts on / off)\n+;; requires using multi-cycle instructions.  Moreover, it can potentially\n+;; increase the interrupt latency which might be important for hard-realtime\n+;; applications.\n+;;\n+;;\n+;; Compatibility Notes\n+;;\n+;; On single-core SH4A CPUs software atomic aware interrupt / exception code\n+;; is actually compatible with user code that utilizes hardware atomics.\n+;; Since SImode hardware atomic sequences are more compact on SH4A they are\n+;; always used, regardless of the selected atomic model.  This atomic model\n+;; mixing can be disabled by setting the 'strict' flag, like:\n+;;\t-matomic-model=soft-gusa,strict\n+;;\n+;; The software atomic models are generally compatible with each other,\n+;; but the interrupt / exception handling code has to support both gUSA and\n+;; TCB models.\n+;;\n ;; The current atomic support is limited to QImode, HImode and SImode \n ;; atomic operations.  DImode operations could also be implemented but\n ;; would require some ABI modifications to support multiple-instruction\n ;; write-back.  This is because SH1/SH2/SH3/SH4 does not have a DImode\n ;; store instruction.  DImode stores must be split into two SImode stores.\n-;;\n-;; On single-core SH4A CPUs software atomic aware interrupt / exception code\n-;; is actually compatible with user code that utilizes hardware atomics.\n-;; Since SImode hardware atomic sequences are more compact on SH4A they are\n-;; always used, regardless of the selected atomic mode.\n \n (define_c_enum \"unspec\" [\n   UNSPEC_ATOMIC\n@@ -158,20 +216,30 @@\n    (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n    (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; success model\n    (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; failure model\n-  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[2], 0));\n   rtx old_val = gen_lowpart (SImode, operands[1]);\n   rtx exp_val = operands[3];\n   rtx new_val = operands[4];\n   rtx atomic_insn;\n \n-  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+  if (TARGET_ATOMIC_HARD_LLCS\n+      || (TARGET_SH4A_ARCH && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n     atomic_insn = gen_atomic_compare_and_swap<mode>_hard (old_val, addr,\n \t\t\t\t\t\t\t  exp_val, new_val);\n+  else if (TARGET_ATOMIC_SOFT_GUSA)\n+    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_gusa (old_val, addr,\n+\t\t      exp_val, new_val);\n+  else if (TARGET_ATOMIC_SOFT_TCB)\n+    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_tcb (old_val, addr,\n+\t\t      exp_val, new_val, TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n+  else if (TARGET_ATOMIC_SOFT_IMASK)\n+    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_imask (old_val, addr,\n+\t\t      exp_val, new_val);\n   else\n-    atomic_insn = gen_atomic_compare_and_swap<mode>_soft (old_val, addr,\n-\t\t\t\t\t\t\t  exp_val, new_val);\n+    FAIL;\n+\n   emit_insn (atomic_insn);\n \n   if (<MODE>mode == QImode)\n@@ -196,7 +264,8 @@\n    (set (reg:SI T_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n    (clobber (reg:SI R0_REG))]\n-  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\n+   || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n   return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n \t \"\tcmp/eq\t%2,r0\"\t\t\"\\n\"\n@@ -224,7 +293,7 @@\n    (clobber (match_scratch:SI 4 \"=&r\"))\n    (clobber (match_scratch:SI 5 \"=&r\"))\n    (clobber (match_scratch:SI 6 \"=1\"))]\n-  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n {\n   return \"\\r\tmov\t#-4,%5\"\t\t\t\"\\n\"\n \t \"\t<i124extend_insn>\t%2,%4\"\t\"\\n\"\n@@ -245,7 +314,7 @@\n }\n   [(set_attr \"length\" \"30\")])\n \n-(define_insn \"atomic_compare_and_swap<mode>_soft\"\n+(define_insn \"atomic_compare_and_swap<mode>_soft_gusa\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&u\")\n \t(unspec_volatile:SI\n \t  [(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\"))\n@@ -259,7 +328,7 @@\n    (clobber (match_scratch:SI 4 \"=&u\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_SOFT_GUSA\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\t<i124extend_insn>\t%2,%4\"\t\"\\n\"\n@@ -274,6 +343,86 @@\n }\n   [(set_attr \"length\" \"20\")])\n \n+(define_insn \"atomic_compare_and_swap<mode>_soft_tcb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(unspec_volatile:SI\n+\t  [(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t   (match_operand:QIHISI 2 \"register_operand\" \"r\")\n+\t   (match_operand:QIHISI 3 \"register_operand\" \"r\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec_volatile:QIHISI [(const_int 0)] UNSPECV_CMPXCHG_2))\n+   (set (reg:SI T_REG)\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n+   (use (match_operand:SI 4 \"gbr_displacement\"))\n+   (clobber (match_scratch:SI 5 \"=&r\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\t<i124extend_insn>\t%2,%5\"\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O4,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tcmp/eq\t%0,%5\"\t\t\t\"\\n\"\n+\t \"\tbf\t1f\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov.l\tr0,@(%O4,gbr)\";\n+}\n+  [(set_attr \"length\" \"22\")])\n+\n+(define_insn \"atomic_compare_and_swap<mode>_soft_imask\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&z\")\n+\t(unspec_volatile:SI\n+\t  [(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t   (match_operand:QIHISI 2 \"register_operand\" \"r\")\n+\t   (match_operand:QIHISI 3 \"register_operand\" \"r\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec_volatile:QIHISI [(const_int 0)] UNSPECV_CMPXCHG_2))\n+   (set (reg:SI T_REG)\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n+   (clobber (match_scratch:SI 4 \"=&r\"))\n+   (clobber (match_scratch:SI 5 \"=&r\"))]\n+  \"TARGET_ATOMIC_SOFT_IMASK\"\n+{\n+  /* The comparison result is supposed to be in T_REG.\n+     Notice that restoring SR will overwrite the T_REG.  We handle this by\n+     rotating the T_REG into the saved SR before restoring SR.  On SH2A we\n+     can do one insn shorter by using the bst insn.  */\n+  if (!TARGET_SH2A)\n+    return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n+\t   \"\t<i124extend_insn>\t%2,%4\"\t\"\\n\"\n+\t   \"\tmov\t%0,%5\"\t\t\t\"\\n\"\n+\t   \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n+\t   \"\tshlr\t%5\"\t\t\t\"\\n\"\n+\t   \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n+\t   \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t   \"\tcmp/eq\t%4,%0\"\t\t\t\"\\n\"\n+\t   \"\tbf\t1f\"\t\t\t\"\\n\"\n+\t   \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t   \"1:\trotcl\t%5\"\t\t\t\"\\n\"\n+\t   \"\tldc\t%5,sr\";\n+  else\n+    return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n+\t   \"\t<i124extend_insn>\t%2,%4\"\t\"\\n\"\n+\t   \"\tmov\t%0,%5\"\t\t\t\"\\n\"\n+\t   \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n+\t   \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n+\t   \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t   \"\tcmp/eq\t%4,%0\"\t\t\t\"\\n\"\n+\t   \"\tbst\t#0,%5\"\t\t\t\"\\n\"\n+\t   \"\tbf\t1f\"\t\t\t\"\\n\"\n+\t   \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t   \"1:\tldc\t%5,sr\";\n+}\n+  [(set (attr \"length\") (if_then_else (match_test \"!TARGET_SH2A\")\n+\t\t\t\t      (const_string \"24\")\n+\t\t\t\t      (const_string \"22\")))])\n+\n ;;------------------------------------------------------------------------------\n ;; read - write - return old value\n \n@@ -282,16 +431,24 @@\n    (match_operand:QIHISI 1 \"memory_operand\" \"\")\t\t;; memory\n    (match_operand:QIHISI 2 \"atomic_arith_operand\" \"\")\t;; newval input\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; memory model\n-  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n   rtx val = operands[2];\n   rtx atomic_insn;\n \n-  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+  if (TARGET_ATOMIC_HARD_LLCS\n+      || (TARGET_SH4A_ARCH && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n     atomic_insn = gen_atomic_exchange<mode>_hard (operands[0], addr, val);\n+  else if (TARGET_ATOMIC_SOFT_GUSA)\n+    atomic_insn = gen_atomic_exchange<mode>_soft_gusa (operands[0], addr, val);\n+  else if (TARGET_ATOMIC_SOFT_TCB)\n+    atomic_insn = gen_atomic_exchange<mode>_soft_tcb (operands[0], addr, val,\n+\t\t      TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n+  else if (TARGET_ATOMIC_SOFT_IMASK)\n+    atomic_insn = gen_atomic_exchange<mode>_soft_imask (operands[0], addr, val);\n   else\n-    atomic_insn = gen_atomic_exchange<mode>_soft (operands[0], addr, val);\n+    FAIL;\n \n   emit_insn (atomic_insn);\n \n@@ -311,7 +468,8 @@\n \t(unspec:SI\n \t  [(match_operand:SI 2 \"arith_operand\" \"rI08\")] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))]\n-  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\n+   || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n   return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\"\\n\"\n@@ -330,7 +488,7 @@\n    (clobber (reg:SI R0_REG))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n    (clobber (match_scratch:SI 4 \"=1\"))]\n-  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n {\n   return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n \t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n@@ -347,15 +505,15 @@\n }\n   [(set_attr \"length\" \"24\")])\n \n-(define_insn \"atomic_exchange<mode>_soft\"\n+(define_insn \"atomic_exchange<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n \t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n \t  [(match_operand:QIHISI 2 \"register_operand\" \"u\")] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_SOFT_GUSA\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n@@ -367,6 +525,47 @@\n }\n   [(set_attr \"length\" \"14\")])\n \n+(define_insn \"atomic_exchange<mode>_soft_tcb\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n+\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(match_operand:QIHISI 2 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))\n+   (use (match_operand:SI 3 \"gbr_displacement\"))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%2,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"atomic_exchange<mode>_soft_imask\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n+\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(match_operand:QIHISI 2 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_ATOMIC_SOFT_IMASK\"\n+{\n+  return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n+\t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n+\t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n+\t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%2,@%1\"\t\t\"\\n\"\n+\t \"\tldc\t%3,sr\";\n+}\n+  [(set_attr \"length\" \"14\")])\n+\n ;;------------------------------------------------------------------------------\n ;; read - add|sub|or|and|xor|nand - write - return old value\n \n@@ -379,18 +578,27 @@\n \t     (match_operand:QIHISI 2 \"<fetchop_predicate>\" \"\"))]\n \t  UNSPEC_ATOMIC))\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n   rtx atomic_insn;\n \n-  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+  if (TARGET_ATOMIC_HARD_LLCS\n+      || (TARGET_SH4A_ARCH && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n     atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_hard (operands[0], addr,\n \t\t\t\t\t\t\t      operands[2]);\n+  else if (TARGET_ATOMIC_SOFT_GUSA)\n+    atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_soft_gusa (operands[0],\n+\t\t      addr, operands[2]);\n+  else if (TARGET_ATOMIC_SOFT_TCB)\n+    atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_soft_tcb (operands[0],\n+\t\t      addr, operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n+  else if (TARGET_ATOMIC_SOFT_IMASK)\n+    atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_soft_imask (operands[0],\n+\t\t      addr, operands[2]);\n   else\n-    atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_soft (operands[0],\n-\t\t\t\t\t\t\t      addr,\n-\t\t\t\t\t\t\t      operands[2]);\n+    FAIL;\n+\n   emit_insn (atomic_insn);\n \n   if (<MODE>mode == QImode)\n@@ -411,7 +619,8 @@\n \t     (match_operand:SI 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\"))]\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))]\n-  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\n+   || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n   return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\"\\n\"\n@@ -432,7 +641,7 @@\n    (clobber (reg:SI R0_REG))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n    (clobber (match_scratch:SI 4 \"=1\"))]\n-  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n {\n   return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n \t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n@@ -451,7 +660,7 @@\n }\n   [(set_attr \"length\" \"28\")])\n \n-(define_insn \"atomic_fetch_<fetchop_name><mode>_soft\"\n+(define_insn \"atomic_fetch_<fetchop_name><mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n \t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -462,7 +671,7 @@\n    (clobber (match_scratch:QIHISI 3 \"=&u\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_SOFT_GUSA\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n@@ -476,6 +685,57 @@\n }\n   [(set_attr \"length\" \"18\")])\n \n+(define_insn \"atomic_fetch_<fetchop_name><mode>_soft_tcb\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n+\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1))\n+\t     (match_operand:QIHISI 2 \"register_operand\" \"r\"))]\n+\t  UNSPEC_ATOMIC))\n+   (use (match_operand:SI 3 \"gbr_displacement\"))\n+   (clobber (match_scratch:QIHISI 4 \"=&r\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\t%0,%4\"\t\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,%4\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%4,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  [(set_attr \"length\" \"20\")])\n+\n+(define_insn \"atomic_fetch_<fetchop_name><mode>_soft_imask\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n+\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1))\n+\t     (match_operand:QIHISI 2 \"register_operand\" \"r\"))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:QIHISI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"TARGET_ATOMIC_SOFT_IMASK\"\n+{\n+  return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n+\t \"\tmov\t%0,%4\"\t\t\t\"\\n\"\n+\t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n+\t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,%3\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t \"\tldc\t%4,sr\";\n+}\n+  [(set_attr \"length\" \"18\")])\n+\n (define_expand \"atomic_fetch_nand<mode>\"\n   [(set (match_operand:QIHISI 0 \"register_operand\" \"\")\n \t(match_operand:QIHISI 1 \"memory_operand\" \"\"))\n@@ -485,17 +745,26 @@\n \t\t       (match_operand:QIHISI 2 \"atomic_logical_operand\" \"\")))]\n \t  UNSPEC_ATOMIC))\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n   rtx atomic_insn;\n \n-  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+  if (TARGET_ATOMIC_HARD_LLCS\n+      || (TARGET_SH4A_ARCH && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n     atomic_insn = gen_atomic_fetch_nand<mode>_hard (operands[0], addr,\n \t\t\t\t\t\t    operands[2]);\n+  else if (TARGET_ATOMIC_SOFT_GUSA)\n+    atomic_insn = gen_atomic_fetch_nand<mode>_soft_gusa (operands[0], addr,\n+\t\t\t\t\t\t\t operands[2]);\n+  else if (TARGET_ATOMIC_SOFT_TCB)\n+    atomic_insn = gen_atomic_fetch_nand<mode>_soft_tcb (operands[0], addr,\n+\t\t      operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n+  else if (TARGET_ATOMIC_SOFT_IMASK)\n+    atomic_insn = gen_atomic_fetch_nand<mode>_soft_imask (operands[0], addr,\n+\t\t\t\t\t\t\t  operands[2]);\n   else\n-    atomic_insn = gen_atomic_fetch_nand<mode>_soft (operands[0], addr,\n-\t\t\t\t\t\t    operands[2]);\n+    FAIL;\n \n   emit_insn (atomic_insn);\n \n@@ -517,7 +786,8 @@\n \t\t   (match_operand:SI 2 \"logical_operand\" \"rK08\")))]\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))]\n-  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\n+   || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n   return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\"\\n\"\n@@ -539,7 +809,7 @@\n    (clobber (reg:SI R0_REG))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n    (clobber (match_scratch:SI 4 \"=1\"))]\n-  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n {\n   return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n \t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n@@ -559,7 +829,7 @@\n }\n   [(set_attr \"length\" \"30\")])\n \n-(define_insn \"atomic_fetch_nand<mode>_soft\"\n+(define_insn \"atomic_fetch_nand<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n \t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -570,7 +840,7 @@\n    (clobber (match_scratch:QIHISI 3 \"=&u\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_SOFT_GUSA\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n@@ -585,6 +855,59 @@\n }\n   [(set_attr \"length\" \"20\")])\n \n+(define_insn \"atomic_fetch_nand<mode>_soft_tcb\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n+\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1))\n+\t     (match_operand:QIHISI 2 \"register_operand\" \"r\")))]\n+\t  UNSPEC_ATOMIC))\n+   (use (match_operand:SI 3 \"gbr_displacement\"))\n+   (clobber (match_scratch:QIHISI 4 \"=&r\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\t%2,%4\"\t\t\t\"\\n\"\n+\t \"\tand\t%0,%4\"\t\t\t\"\\n\"\n+\t \"\tnot\t%4,%4\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%4,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  [(set_attr \"length\" \"22\")])\n+\n+(define_insn \"atomic_fetch_nand<mode>_soft_imask\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n+\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1))\n+\t     (match_operand:QIHISI 2 \"register_operand\" \"r\")))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:QIHISI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"TARGET_ATOMIC_SOFT_IMASK\"\n+{\n+  return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n+\t \"\tmov\t%0,%4\"\t\t\t\"\\n\"\n+\t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n+\t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov\t%2,%3\"\t\t\t\"\\n\"\n+\t \"\tand\t%0,%3\"\t\t\t\"\\n\"\n+\t \"\tnot\t%3,%3\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t \"\tstc\t%4,sr\";\n+}\n+  [(set_attr \"length\" \"20\")])\n+\n ;;------------------------------------------------------------------------------\n ;; read - add|sub|or|and|xor|nand - write - return new value\n \n@@ -598,17 +921,27 @@\n \t  [(FETCHOP:QIHISI (match_dup 1) (match_dup 2))]\n \t  UNSPEC_ATOMIC))\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n   rtx atomic_insn;\n \n-  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+  if (TARGET_ATOMIC_HARD_LLCS\n+      || (TARGET_SH4A_ARCH && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n     atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_hard (operands[0], addr,\n \t\t\t\t\t\t\t      operands[2]);\n+  else if (TARGET_ATOMIC_SOFT_GUSA)\n+    atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_soft_gusa (operands[0],\n+\t\t      addr, operands[2]);\n+  else if (TARGET_ATOMIC_SOFT_TCB)\n+    atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_soft_tcb (operands[0],\n+\t\t      addr, operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n+  else if (TARGET_ATOMIC_SOFT_IMASK)\n+    atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_soft_imask (operands[0],\n+\t\t      addr, operands[2]);\n   else\n-    atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_soft (operands[0], addr,\n-\t\t\t\t\t\t\t      operands[2]);\n+    FAIL;\n+\n   emit_insn (atomic_insn);\n \n   if (<MODE>mode == QImode)\n@@ -629,7 +962,8 @@\n \t(unspec:SI\n \t  [(FETCHOP:SI (mem:SI (match_dup 1)) (match_dup 2))]\n \t  UNSPEC_ATOMIC))]\n-  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\n+   || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n   return \"\\r0:\tmovli.l\t@%1,%0\"\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,%0\"\t\"\\n\"\n@@ -647,11 +981,10 @@\n \t(unspec:QIHI\n \t  [(FETCHOP:QIHI (mem:QIHI (match_dup 1)) (match_dup 2))]\n \t  UNSPEC_ATOMIC))\n-\n    (clobber (reg:SI R0_REG))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n    (clobber (match_scratch:SI 4 \"=1\"))]\n-  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n {\n   return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n \t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n@@ -670,7 +1003,7 @@\n }\n   [(set_attr \"length\" \"28\")])\n \n-(define_insn \"atomic_<fetchop_name>_fetch<mode>_soft\"\n+(define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n \t(FETCHOP:QIHISI\n \t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\"))\n@@ -681,7 +1014,7 @@\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_SOFT_GUSA\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n@@ -694,6 +1027,55 @@\n }\n   [(set_attr \"length\" \"16\")])\n \n+(define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_tcb\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n+\t(FETCHOP:QIHISI\n+\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  (match_operand:QIHISI 2 \"register_operand\" \"r\")))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))\n+   (use (match_operand:SI 3 \"gbr_displacement\"))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  [(set_attr \"length\" \"18\")])\n+\n+(define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_imask\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n+\t(FETCHOP:QIHISI\n+\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  (match_operand:QIHISI 2 \"register_operand\" \"r\")))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_ATOMIC_SOFT_IMASK\"\n+{\n+  return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n+\t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n+\t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n+\t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tldc\t%3,sr\";\n+}\n+  [(set_attr \"length\" \"16\")])\n+\n (define_expand \"atomic_nand_fetch<mode>\"\n   [(set (match_operand:QIHISI 0 \"register_operand\" \"\")\n \t(not:QIHISI (and:QIHISI\n@@ -704,17 +1086,27 @@\n \t  [(not:QIHISI (and:QIHISI (match_dup 1) (match_dup 2)))]\n \t  UNSPEC_ATOMIC))\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n   rtx atomic_insn;\n \n-  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+  if (TARGET_ATOMIC_HARD_LLCS\n+      || (TARGET_SH4A_ARCH && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n     atomic_insn = gen_atomic_nand_fetch<mode>_hard (operands[0], addr,\n \t\t\t\t\t\t    operands[2]);\n+  else if (TARGET_ATOMIC_SOFT_GUSA)\n+    atomic_insn = gen_atomic_nand_fetch<mode>_soft_gusa (operands[0], addr,\n+\t\t\t\t\t\t\t operands[2]);\n+  else if (TARGET_ATOMIC_SOFT_TCB)\n+    atomic_insn = gen_atomic_nand_fetch<mode>_soft_tcb (operands[0], addr,\n+\t\t      operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n+  else if (TARGET_ATOMIC_SOFT_IMASK)\n+    atomic_insn = gen_atomic_nand_fetch<mode>_soft_imask (operands[0], addr,\n+\t\t\t\t\t\t\t  operands[2]);\n   else\n-    atomic_insn = gen_atomic_nand_fetch<mode>_soft (operands[0], addr,\n-\t\t\t\t\t\t    operands[2]);\n+    FAIL;\n+\n   emit_insn (atomic_insn);\n \n   if (<MODE>mode == QImode)\n@@ -734,7 +1126,8 @@\n \t(unspec:SI\n \t  [(not:SI (and:SI (mem:SI (match_dup 1)) (match_dup 2)))]\n \t  UNSPEC_ATOMIC))]\n-  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\n+   || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n   return \"\\r0:\tmovli.l\t@%1,%0\"\t\t\"\\n\"\n \t \"\tand\t%2,%0\"\t\t\"\\n\"\n@@ -756,7 +1149,7 @@\n    (clobber (reg:SI R0_REG))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n    (clobber (match_scratch:SI 4 \"=1\"))]\n-  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n {\n   return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n \t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n@@ -775,7 +1168,7 @@\n }\n   [(set_attr \"length\" \"28\")])\n \n-(define_insn \"atomic_nand_fetch<mode>_soft\"\n+(define_insn \"atomic_nand_fetch<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n \t(not:QIHISI (and:QIHISI\n \t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\"))\n@@ -786,7 +1179,7 @@\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_SOFT_GUSA\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n@@ -800,14 +1193,65 @@\n }\n   [(set_attr \"length\" \"18\")])\n \n+(define_insn \"atomic_nand_fetch<mode>_soft_tcb\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n+\t(not:QIHISI (and:QIHISI\n+\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  (match_operand:QIHISI 2 \"register_operand\" \"r\"))))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2)))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))\n+   (use (match_operand:SI 3 \"gbr_displacement\"))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tand\t%2,%0\"\t\t\t\"\\n\"\n+\t \"\tnot\t%0,%0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  [(set_attr \"length\" \"20\")])\n+\n+(define_insn \"atomic_nand_fetch<mode>_soft_imask\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n+\t(not:QIHISI (and:QIHISI\n+\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  (match_operand:QIHISI 2 \"register_operand\" \"r\"))))\n+   (set (mem:QIHISI (match_dup 1))\n+\t(unspec:QIHISI\n+\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2)))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_ATOMIC_SOFT_IMASK\"\n+{\n+  return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n+\t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n+\t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n+\t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tand\t%2,%0\"\t\t\t\"\\n\"\n+\t \"\tnot\t%0,%0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tldc\t%3,sr\";\n+}\n+  [(set_attr \"length\" \"18\")])\n+\n ;;------------------------------------------------------------------------------\n ;; read - test against zero - or with 0x80 - write - return test result\n \n (define_expand \"atomic_test_and_set\"\n   [(match_operand:SI 0 \"register_operand\" \"\")\t\t;; bool result output\n    (match_operand:QI 1 \"memory_operand\" \"\")\t\t;; memory\n    (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t;; model\n-  \"(TARGET_ANY_ATOMIC || TARGET_ENABLE_TAS) && !TARGET_SHMEDIA\"\n+  \"(TARGET_ATOMIC_ANY || TARGET_ENABLE_TAS) && !TARGET_SHMEDIA\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n \n@@ -818,10 +1262,17 @@\n       rtx val = gen_int_mode (targetm.atomic_test_and_set_trueval, QImode);\n       val = force_reg (QImode, val);\n \n-      if (TARGET_HARD_ATOMIC)\n+      if (TARGET_ATOMIC_HARD_LLCS)\n \t  emit_insn (gen_atomic_test_and_set_hard (addr, val));\n+      else if (TARGET_ATOMIC_SOFT_GUSA)\n+\t  emit_insn (gen_atomic_test_and_set_soft_gusa (addr, val));\n+      else if (TARGET_ATOMIC_SOFT_TCB)\n+\t  emit_insn (gen_atomic_test_and_set_soft_tcb (addr, val,\n+\t\t\t TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX));\n+      else if (TARGET_ATOMIC_SOFT_IMASK)\n+\t  emit_insn (gen_atomic_test_and_set_soft_imask (addr, val));\n       else\n-\t  emit_insn (gen_atomic_test_and_set_soft (addr, val));\n+\tFAIL;\n     }\n \n   /* The result of the test op is the inverse of what we are\n@@ -841,7 +1292,7 @@\n   \"tas.b\t@%0\"\n   [(set_attr \"insn_class\" \"co_group\")])\n \n-(define_insn \"atomic_test_and_set_soft\"\n+(define_insn \"atomic_test_and_set_soft_gusa\"\n   [(set (reg:SI T_REG)\n \t(eq:SI (mem:QI (match_operand:SI 0 \"register_operand\" \"u\"))\n \t       (const_int 0)))\n@@ -850,7 +1301,7 @@\n    (clobber (match_scratch:QI 2 \"=&u\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_ENABLE_TAS && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_SOFT_GUSA && !TARGET_ENABLE_TAS\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\"\\n\"\n@@ -863,6 +1314,51 @@\n }\n   [(set_attr \"length\" \"16\")])\n \n+(define_insn \"atomic_test_and_set_soft_tcb\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (mem:QI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t       (const_int 0)))\n+   (set (mem:QI (match_dup 0))\n+\t(unspec:QI [(match_operand:QI 1 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+   (use (match_operand:SI 2 \"gbr_displacement\"))\n+   (clobber (match_scratch:QI 3 \"=&r\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_ATOMIC_SOFT_TCB && !TARGET_ENABLE_TAS\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\"\\n\"\n+\t \"\t.align 2\"\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O2,gbr)\"\t\"\\n\"\n+\t \"0:\tmov.b\t@%0,%3\"\t\t\"\\n\"\n+\t \"\tmov\t#0,r0\"\t\t\"\\n\"\n+\t \"\tmov.b\t%1,@%0\"\t\t\"\\n\"\n+\t \"1:\tmov.l\tr0,@(%O2,gbr)\"\t\"\\n\"\n+\t \"\ttst\t%3,%3\";\n+}\n+  [(set_attr \"length\" \"18\")])\n+\n+(define_insn \"atomic_test_and_set_soft_imask\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (mem:QI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t       (const_int 0)))\n+   (set (mem:QI (match_dup 0))\n+\t(unspec:QI [(match_operand:QI 1 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+   (clobber (match_scratch:SI 2 \"=&r\"))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_SOFT_IMASK && !TARGET_ENABLE_TAS\"\n+{\n+  return \"\\r\tstc\tsr,r0\"\t\t\"\\n\"\n+\t \"\tmov\tr0,%2\"\t\t\"\\n\"\n+\t \"\tor\t#0xF0,r0\"\t\"\\n\"\n+\t \"\tldc\tr0,sr\"\t\t\"\\n\"\n+\t \"\tmov.b\t@%0,r0\"\t\t\"\\n\"\n+\t \"\tmov.b\t%1,@%0\"\t\t\"\\n\"\n+\t \"\tstc\t%2,sr\"\t\t\"\\n\"\n+\t \"\ttst\tr0,r0\";\n+}\n+  [(set_attr \"length\" \"16\")])\n+\n (define_insn \"atomic_test_and_set_hard\"\n   [(set (reg:SI T_REG)\n \t(eq:SI (mem:QI (match_operand:SI 0 \"register_operand\" \"r\"))\n@@ -873,7 +1369,7 @@\n    (clobber (match_scratch:SI 2 \"=&r\"))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n    (clobber (match_scratch:SI 4 \"=0\"))]\n-  \"TARGET_HARD_ATOMIC && !TARGET_ENABLE_TAS && TARGET_SH4A_ARCH\"\n+  \"TARGET_ATOMIC_HARD_LLCS && !TARGET_ENABLE_TAS\"\n {\n   return \"\\r\tmov\t#-4,%2\"\t\t\"\\n\"\n \t \"\tand\t%0,%2\"\t\t\"\\n\""}, {"sha": "7578ddac93b1ea6bb09d38b433997710db61ad77", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 62, "deletions": 20, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd76b9c7aeff03ae44113a0b69404e7d7d9662c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7bd76b9c7aeff03ae44113a0b69404e7d7d9662c", "patch": "@@ -893,7 +893,8 @@ See RS/6000 and PowerPC Options.\n -mspace -mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol\n -mdivsi3_libfunc=@var{name} -mfixed-range=@var{register-range} @gol\n -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol\n--maccumulate-outgoing-args -minvalid-symbols -msoft-atomic -mhard-atomic @gol\n+-maccumulate-outgoing-args -minvalid-symbols @gol\n+-matomic-model=@var{atomic-model} @gol\n -mbranch-cost=@var{num} -mzdcbranch -mno-zdcbranch -mcbranchdi -mcmpeqdi @gol\n -mfused-madd -mno-fused-madd -mfsca -mno-fsca -mfsrra -mno-fsrra @gol\n -mpretend-cmove -mtas}\n@@ -18297,26 +18298,67 @@ Dump instruction size and location in the assembly code.\n This option is deprecated.  It pads structures to multiple of 4 bytes,\n which is incompatible with the SH ABI@.\n \n-@item -msoft-atomic\n-@opindex msoft-atomic\n+@item -matomic-model=@var{model}\n+@opindex matomic-model=@var{model}\n+Sets the model of atomic operations and additional parameters as a comma\n+separated list.  For details on the atomic built-in functions see\n+@ref{__atomic Builtins}.  The following models and parameters are supported:\n+\n+@table @samp\n+\n+@item none\n+Disable compiler generated atomic sequences and emit library calls for atomic\n+operations.  This is the default if the target is not @code{sh-*-linux*}.\n+\n+@item soft-gusa\n Generate GNU/Linux compatible gUSA software atomic sequences for the atomic\n-built-in functions.  The generated atomic sequences require support from the \n-interrupt / exception handling code of the system and are only suitable for\n-single-core systems.  They will not operate correctly on multi-core systems.\n-This option is enabled by default when the target is @code{sh-*-linux*}.\n-When the target is SH4A, this option will also partially utilize the hardware\n-atomic instructions @code{movli.l} and @code{movco.l} to create more\n-efficient code.\n-For details on the atomic built-in functions see @ref{__atomic Builtins}.\n-\n-@item -mhard-atomic\n-@opindex hard-atomic\n-Generate hardware atomic sequences for the atomic built-in functions.  This\n-is only available on SH4A and is suitable for multi-core systems.  Code\n-compiled with this option will also be compatible with gUSA aware\n-interrupt / exception handling systems.  In contrast to the\n-@option{-msoft-atomic} option this will only use the instructions\n-@code{movli.l} and @code{movco.l} to create atomic sequences.\n+built-in functions.  The generated atomic sequences require additional support\n+from the interrupt/exception handling code of the system and are only suitable\n+for SH3* and SH4* single-core systems.  This option is enabled by default when\n+the target is @code{sh-*-linux*} and SH3* or SH4*.  When the target is SH4A,\n+this option will also partially utilize the hardware atomic instructions\n+@code{movli.l} and @code{movco.l} to create more efficient code, unless\n+@samp{strict} is specified.  \n+\n+@item soft-tcb\n+Generate software atomic sequences that use a variable in the thread control\n+block.  This is a variation of the gUSA sequences which can also be used on\n+SH1* and SH2* targets.  The generated atomic sequences require additional\n+support from the interrupt/exception handling code of the system and are only\n+suitable for single-core systems.  When using this model, the @samp{gbr-offset=}\n+parameter has to be specified as well.\n+\n+@item soft-imask\n+Generate software atomic sequences that temporarily disable interrupts by\n+setting @code{SR.IMASK = 1111}.  This model works only when the program runs\n+in privileged mode and is only suitable for single-core systems.  Additional\n+support from the interrupt/exception handling code of the system is not\n+required.  This model is enabled by default when the target is\n+@code{sh-*-linux*} and SH1* or SH2*.\n+\n+@item hard-llcs\n+Generate hardware atomic sequences using the @code{movli.l} and @code{movco.l}\n+instructions only.  This is only available on SH4A and is suitable for\n+multi-core systems.  Since the hardware instructions support only 32 bit atomic\n+variables access to 8 or 16 bit variables is emulated with 32 bit accesses.\n+Code compiled with this option will also be compatible with other software\n+atomic model interrupt/exception handling systems if executed on an SH4A\n+system.  Additional support from the interrupt/exception handling code of the\n+system is not required for this model.\n+\n+@item gbr-offset=\n+This parameter specifies the offset in bytes of the variable in the thread\n+control block structure that should be used by the generated atomic sequences\n+when the @samp{soft-tcb} model has been selected.  For other models this\n+parameter is ignored.  The specified value must be an integer multiple of four\n+and in the range 0-1020.\n+\n+@item strict\n+This parameter prevents mixed usage of multiple atomic models, even though they\n+would be compatible, and will make the compiler generate atomic sequences of the\n+specified model only.\n+\n+@end table\n \n @item -mtas\n @opindex mtas"}]}