{"sha": "14886cbe300c144a4390245d0515cdf28fc5f68f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ4ODZjYmUzMDBjMTQ0YTQzOTAyNDVkMDUxNWNkZjI4ZmM1ZjY4Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-19T21:10:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-19T21:29:48Z"}, "message": "c++: Incorrect module-number ordering [PR 98741]\n\nOne of the very strong invariants in modules is that module numbers\nare allocated such that (other than the current TU), all imports have\nlesser module numbers, and also that the binding vector is only\nappended to with increasing module numbers.   This broke down when\nmodule-directives became a thing and the preprocessing became entirely\ndecoupled from parsing.  We'd load header units and their macros (but\nnot symbols of course) during preprocessing.  Then we'd load named\nmodules during parsing.  This could lead to the situation where a\nheader unit appearing after a named import had a lower module number\nthan the import.  Consequently, if they both bound the same\nidentifier, the binding vector would be misorderd and bad things\nhappen.\n\nThis patch restores a pending import queue I previously had, but in\nsimpler form (hurrah).  During preprocessing we queue all\nmodule-directives and when we meet one for a header unit we do the\nminimal loading for all of the queue, so they get appropriate\nnumbering.  Then we load the preprocessor state for the header unit.\n\n\tPR c++/98741\n\tgcc/cp/\n\t* module.cc (pending_imports): New.\n\t(declare_module): Adjust test condition.\n\t(name_pending_imports): New.\n\t(preprocess_module): Reimplement using pending_imports.\n\t(preprocessed_module): Move name-getting to name_pending_imports.\n\t* name-lookup.c (append_imported_binding_slot): Assert module\n\tordering is increasing.\n\tgcc/testsuite/\n\t* g++.dg/modules/pr98741_a.H: New.\n\t* g++.dg/modules/pr98741_b.H: New.\n\t* g++.dg/modules/pr98741_c.C: New.\n\t* g++.dg/modules/pr98741_d.C: New.", "tree": {"sha": "378a970b311b4f7526a132c26a4b72f0330a96db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/378a970b311b4f7526a132c26a4b72f0330a96db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14886cbe300c144a4390245d0515cdf28fc5f68f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14886cbe300c144a4390245d0515cdf28fc5f68f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14886cbe300c144a4390245d0515cdf28fc5f68f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14886cbe300c144a4390245d0515cdf28fc5f68f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfa2f821c18b7e926b5f5d6e394a0c915937db5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa2f821c18b7e926b5f5d6e394a0c915937db5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfa2f821c18b7e926b5f5d6e394a0c915937db5e"}], "stats": {"total": 208, "additions": 132, "deletions": 76}, "files": [{"sha": "3d17b8ddcdb8b7a1ec4eaf6fc31fa222aa793c92", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 107, "deletions": 76, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=14886cbe300c144a4390245d0515cdf28fc5f68f", "patch": "@@ -3873,6 +3873,9 @@ module_state_hash::equal (const value_type existing,\n /* Mapper name.  */\n static const char *module_mapper_name;\n \n+/* Deferred import queue (FIFO).  */\n+static vec<module_state *, va_heap, vl_embed> *pending_imports;\n+\n /* CMI repository path and workspace.  */\n static char *cmi_repo;\n static size_t cmi_repo_length;\n@@ -18944,7 +18947,7 @@ declare_module (module_state *module, location_t from_loc, bool exporting_p,\n   gcc_assert (global_namespace == current_scope ());\n \n   module_state *current = (*modules)[0];\n-  if (module_purview_p () || module->loadedness != ML_NONE)\n+  if (module_purview_p () || module->loadedness > ML_CONFIG)\n     {\n       error_at (from_loc, module_purview_p ()\n \t\t? G_(\"module already declared\")\n@@ -19275,6 +19278,70 @@ module_begin_main_file (cpp_reader *reader, line_maps *lmaps,\n     }\n }\n \n+/* Process the pending_import queue, making sure we know the\n+   filenames.   */\n+\n+static void\n+name_pending_imports (cpp_reader *reader, bool at_end)\n+{\n+  auto *mapper = get_mapper (cpp_main_loc (reader));\n+\n+  bool only_headers = (flag_preprocess_only\n+\t\t       && !bool (mapper->get_flags () & Cody::Flags::NameOnly)\n+\t\t       && !cpp_get_deps (reader));\n+  if (at_end\n+      && (!vec_safe_length (pending_imports) || only_headers))\n+    /* Not doing anything.  */\n+    return;\n+\n+  timevar_start (TV_MODULE_MAPPER);\n+\n+  dump.push (NULL);\n+  dump () && dump (\"Resolving direct import names\");\n+\n+  mapper->Cork ();\n+  for (unsigned ix = 0; ix != pending_imports->length (); ix++)\n+    {\n+      module_state *module = (*pending_imports)[ix];\n+      gcc_checking_assert (module->is_direct ());\n+      if (!module->filename)\n+\t{\n+\t  Cody::Flags flags\n+\t    = (flag_preprocess_only ? Cody::Flags::None\n+\t       : Cody::Flags::NameOnly);\n+\n+\t  if (only_headers && !module->is_header ())\n+\t    ;\n+\t  else if (module->module_p\n+\t\t   && (module->is_partition () || module->exported_p))\n+\t    mapper->ModuleExport (module->get_flatname (), flags);\n+\t  else\n+\t    mapper->ModuleImport (module->get_flatname (), flags);\n+\t}\n+    }\n+  \n+  auto response = mapper->Uncork ();\n+  auto r_iter = response.begin ();\n+  for (unsigned ix = 0; ix != pending_imports->length (); ix++)\n+    {\n+      module_state *module = (*pending_imports)[ix];\n+      gcc_checking_assert (module->is_direct ());\n+      if (only_headers && !module->is_header ())\n+\t;\n+      else if (!module->filename)\n+\t{\n+\t  Cody::Packet const &p = *r_iter;\n+\t  ++r_iter;\n+\n+\t  module->set_filename (p);\n+\t}\n+    }\n+\n+  dump.pop (0);\n+\n+  timevar_stop (TV_MODULE_MAPPER);\n+}\n+\n /* We've just lexed a module-specific control line for MODULE.  Mark\n    the module as a direct import, and possibly load up its macro\n    state.  Returns the primary module, if this is a module\n@@ -19322,17 +19389,22 @@ preprocess_module (module_state *module, location_t from_loc,\n \t}\n     }\n \n+  auto desired = ML_CONFIG;\n   if (is_import\n-      && !module->is_module () && module->is_header ()\n-      && module->loadedness < ML_PREPROCESSOR\n+      && module->is_header ()\n       && (!cpp_get_options (reader)->preprocessed\n \t  || cpp_get_options (reader)->directives_only))\n+    /* We need preprocessor state now.  */\n+    desired = ML_PREPROCESSOR;\n+\n+  if (!is_import || module->loadedness < desired)\n     {\n-      timevar_start (TV_MODULE_IMPORT);\n-      unsigned n = dump.push (module);\n+      vec_safe_push (pending_imports, module);\n \n-      if (module->loadedness == ML_NONE)\n+      if (desired == ML_PREPROCESSOR)\n \t{\n+\t  name_pending_imports (reader, false);\n+\n \t  unsigned pre_hwm = 0;\n \n \t  /* Preserve the state of the line-map.  */\n@@ -19345,25 +19417,38 @@ preprocess_module (module_state *module, location_t from_loc,\n \t  spans.maybe_init ();\n \t  spans.close ();\n \n-\t  if (!module->filename)\n+\t  timevar_start (TV_MODULE_IMPORT);\n+\n+\t  /* Load the config of each pending import -- we must assign\n+\t     module numbers monotonically.  */\n+\t  for (unsigned ix = 0; ix != pending_imports->length (); ix++)\n \t    {\n-\t      auto *mapper = get_mapper (cpp_main_loc (reader));\n-\t      auto packet = mapper->ModuleImport (module->get_flatname ());\n-\t      module->set_filename (packet);\n+\t      auto *import = (*pending_imports)[ix];\n+\t      if (!(import->module_p\n+\t\t    && (import->is_partition () || import->exported_p))\n+\t\t  && import->loadedness == ML_NONE\n+\t\t  && (import->is_header () || !flag_preprocess_only))\n+\t\t{\n+\t\t  unsigned n = dump.push (import);\n+\t\t  import->do_import (reader, true);\n+\t\t  dump.pop (n);\n+\t\t}\n \t    }\n-\t  module->do_import (reader, true);\n+\t  vec_free (pending_imports);\n \n \t  /* Restore the line-map state.  */\n \t  linemap_module_restore (line_table, pre_hwm);\n \t  spans.open ();\n-\t}\n \n-      if (module->loadedness < ML_PREPROCESSOR)\n-\tif (module->read_preprocessor (true))\n-\t  module->import_macros ();\n+\t  /* Now read the preprocessor state of this particular\n+\t     import.  */\n+\t  unsigned n = dump.push (module);\n+\t  if (module->read_preprocessor (true))\n+\t    module->import_macros ();\n+\t  dump.pop (n);\n \n-      dump.pop (n);\n-      timevar_stop (TV_MODULE_IMPORT);\n+\t  timevar_stop (TV_MODULE_IMPORT);\n+\t}\n     }\n \n   return is_import ? NULL : get_primary (module);\n@@ -19377,68 +19462,13 @@ preprocess_module (module_state *module, location_t from_loc,\n void\n preprocessed_module (cpp_reader *reader)\n {\n-  auto *mapper = get_mapper (cpp_main_loc (reader));\n+  name_pending_imports (reader, true);\n+  vec_free (pending_imports);\n \n   spans.maybe_init ();\n   spans.close ();\n \n-  /* Stupid GTY doesn't grok a typedef here.  And using type = is, too\n-     modern.  */\n-#define iterator hash_table<module_state_hash>::iterator\n-  /* using iterator = hash_table<module_state_hash>::iterator;  */\n-\n-  /* Walk the module hash, asking for the names of all unknown\n-     direct imports and informing of an export (if that's what we\n-     are).  Notice these are emitted even when preprocessing as they\n-     inform the server of dependency edges.  */\n-  timevar_start (TV_MODULE_MAPPER);\n-\n-  dump.push (NULL);\n-  dump () && dump (\"Resolving direct import names\");\n-\n-  if (!flag_preprocess_only\n-      || bool (mapper->get_flags () & Cody::Flags::NameOnly)\n-      || cpp_get_deps (reader))\n-    {\n-      mapper->Cork ();\n-      iterator end = modules_hash->end ();\n-      for (iterator iter = modules_hash->begin (); iter != end; ++iter)\n-\t{\n-\t  module_state *module = *iter;\n-\t  if (module->is_direct () && !module->filename)\n-\t    {\n-\t      Cody::Flags flags\n-\t\t= (flag_preprocess_only ? Cody::Flags::None\n-\t\t   : Cody::Flags::NameOnly);\n-\n-\t      if (module->module_p\n-\t\t  && (module->is_partition () || module->exported_p))\n-\t\tmapper->ModuleExport (module->get_flatname (), flags);\n-\t      else\n-\t\tmapper->ModuleImport (module->get_flatname (), flags);\n-\t    }\n-\t}\n-\n-      auto response = mapper->Uncork ();\n-      auto r_iter = response.begin ();\n-      for (iterator iter = modules_hash->begin (); iter != end; ++iter)\n-\t{\n-\t  module_state *module = *iter;\n-\n-\t  if (module->is_direct () && !module->filename)\n-\t    {\n-\t      Cody::Packet const &p = *r_iter;\n-\t      ++r_iter;\n-\n-\t      module->set_filename (p);\n-\t    }\n-\t}\n-    }\n-\n-  dump.pop (0);\n-\n-  timevar_stop (TV_MODULE_MAPPER);\n-\n+  using iterator = hash_table<module_state_hash>::iterator;\n   if (mkdeps *deps = cpp_get_deps (reader))\n     {\n       /* Walk the module hash, informing the dependency machinery.  */\n@@ -19462,6 +19492,8 @@ preprocessed_module (cpp_reader *reader)\n \n   if (flag_header_unit && !flag_preprocess_only)\n     {\n+      /* Find the main module -- remember, it's not yet in the module\n+\t array.  */\n       iterator end = modules_hash->end ();\n       for (iterator iter = modules_hash->begin (); iter != end; ++iter)\n \t{\n@@ -19473,7 +19505,6 @@ preprocessed_module (cpp_reader *reader)\n \t    }\n \t}\n     }\n-#undef iterator\n }\n \n /* VAL is a global tree, add it to the global vec if it is"}, {"sha": "8e3038cb7ad5b5464b1b24112ef3c2a717c29aab", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=14886cbe300c144a4390245d0515cdf28fc5f68f", "patch": "@@ -367,6 +367,11 @@ append_imported_binding_slot (tree *slot, tree name, unsigned ix)\n \tlast->indices[off].base = ix;\n \tlast->indices[off].span = 1;\n \tlast->slots[off] = NULL_TREE;\n+\t/* Check monotonicity.  */\n+\tgcc_checking_assert (last[off ? 0 : -1]\n+\t\t\t     .indices[off ? off - 1\n+\t\t\t\t      : BINDING_VECTOR_SLOTS_PER_CLUSTER - 1]\n+\t\t\t     .base < ix);\n \treturn &last->slots[off];\n       }\n "}, {"sha": "c8d5d6604bcc051e2d74159bad0541451d0e36ca", "filename": "gcc/testsuite/g++.dg/modules/pr98741_a.H", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_a.H?ref=14886cbe300c144a4390245d0515cdf28fc5f68f", "patch": "@@ -0,0 +1,7 @@\n+// PR 98741 incorrect order of module number assignments\n+// { dg-additional-options {-fmodule-header} }\n+// { dg-module-cmi {} }\n+\n+namespace foo\n+{\n+}"}, {"sha": "c2bdf84ca9c6dca4f768118fe3f6ed3b66e505d0", "filename": "gcc/testsuite/g++.dg/modules/pr98741_b.H", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_b.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_b.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_b.H?ref=14886cbe300c144a4390245d0515cdf28fc5f68f", "patch": "@@ -0,0 +1,6 @@\n+// { dg-additional-options {-fmodule-header} }\n+// { dg-module-cmi {} }\n+\n+namespace foo\n+{\n+}"}, {"sha": "60bbe3279969f6c4b8275eccb9f55db5e3668165", "filename": "gcc/testsuite/g++.dg/modules/pr98741_c.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_c.C?ref=14886cbe300c144a4390245d0515cdf28fc5f68f", "patch": "@@ -0,0 +1,4 @@\n+// { dg-additional-options {-fmodules-ts} }\n+export module Foo;\n+// { dg-module-cmi {Foo} }\n+import \"pr98741_a.H\";"}, {"sha": "b8f48652e8e47225e8500300d0b1bc9b3082596a", "filename": "gcc/testsuite/g++.dg/modules/pr98741_d.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_d.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14886cbe300c144a4390245d0515cdf28fc5f68f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_d.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98741_d.C?ref=14886cbe300c144a4390245d0515cdf28fc5f68f", "patch": "@@ -0,0 +1,3 @@\n+// { dg-additional-options {-fmodules-ts} }\n+module Foo;\n+import \"pr98741_b.H\";"}]}