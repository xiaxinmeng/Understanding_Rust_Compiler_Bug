{"sha": "30b11d8d1be9c683f1517472c47a3cb69df02c4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBiMTFkOGQxYmU5YzY4M2YxNTE3NDcyYzQ3YTNjYjY5ZGYwMmM0Zg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-04-20T00:09:51Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-04-20T00:28:12Z"}, "message": "libphobos: Fix SIGBUS in read_encoded_value_with_base on sparc-sun-solaris (PR98584)\n\nInstead of unsafe pointer dereferencing, use memcpy() to read encoded\nvalues from memory.  The function `read_encoded_value' has been updated\nto accept a ref parameter, this simplifies handling of the pointer to\nmemory needing to be read.\n\nlibphobos/ChangeLog:\n\n\tPR d/98584\n\t* libdruntime/gcc/deh.d (scanLSDA): Update calls to read_uleb128 and\n\tread_encoded_value.\n\t(actionTableLookup): Update calls to read_sleb128 and\n\tread_encoded_value_with_base.\n\t* libdruntime/gcc/unwind/pe.d (read_uleb128): Update signature.\n\t(read_sleb128): Update signature.\n\t(read_unaligned): New function.\n\t(read_encoded_value_with_base): Update signature.  Call read_unaligned\n\tinstead of unsafe pointer dereferencing.\n\t(read_encoded_value): Update signature.", "tree": {"sha": "a81c8b8f62284a5e719aced71b91c904714054fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a81c8b8f62284a5e719aced71b91c904714054fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30b11d8d1be9c683f1517472c47a3cb69df02c4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b11d8d1be9c683f1517472c47a3cb69df02c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30b11d8d1be9c683f1517472c47a3cb69df02c4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b11d8d1be9c683f1517472c47a3cb69df02c4f/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e81e015d91568fc3df3939623ae999e0681a0fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e81e015d91568fc3df3939623ae999e0681a0fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e81e015d91568fc3df3939623ae999e0681a0fc"}], "stats": {"total": 105, "additions": 57, "deletions": 48}, "files": [{"sha": "eb83751c59dfa4bf7f25c5f990ea550fe738680a", "filename": "libphobos/libdruntime/gcc/deh.d", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b11d8d1be9c683f1517472c47a3cb69df02c4f/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b11d8d1be9c683f1517472c47a3cb69df02c4f/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d?ref=30b11d8d1be9c683f1517472c47a3cb69df02c4f", "patch": "@@ -547,7 +547,7 @@ _Unwind_Reason_Code scanLSDA(const(ubyte)* lsda, _Unwind_Exception_Class excepti\n     _Unwind_Ptr LPStart = 0;\n \n     if (LPStartEncoding != DW_EH_PE_omit)\n-        LPStart = read_encoded_value(context, LPStartEncoding, &p);\n+        LPStart = read_encoded_value(context, LPStartEncoding, p);\n     else\n         LPStart = Start;\n \n@@ -563,14 +563,14 @@ _Unwind_Reason_Code scanLSDA(const(ubyte)* lsda, _Unwind_Exception_Class excepti\n             // hardcoded OS-specific format.\n             TTypeEncoding = _TTYPE_ENCODING;\n         }\n-        auto TTbase = read_uleb128(&p);\n+        auto TTbase = read_uleb128(p);\n         TType = p + TTbase;\n     }\n \n     // The encoding and length of the call-site table; the action table\n     // immediately follows.\n     ubyte CSEncoding = *p++;\n-    auto CSTableSize = read_uleb128(&p);\n+    auto CSTableSize = read_uleb128(p);\n     const(ubyte)* actionTable = p + CSTableSize;\n \n     auto TTypeBase = base_of_encoded_value(TTypeEncoding, context);\n@@ -608,8 +608,8 @@ _Unwind_Reason_Code scanLSDA(const(ubyte)* lsda, _Unwind_Exception_Class excepti\n             _uleb128_t CSLandingPad, CSAction;\n             do\n             {\n-                CSLandingPad = read_uleb128(&p);\n-                CSAction = read_uleb128(&p);\n+                CSLandingPad = read_uleb128(p);\n+                CSAction = read_uleb128(p);\n             }\n             while (--ip);\n \n@@ -626,10 +626,10 @@ _Unwind_Reason_Code scanLSDA(const(ubyte)* lsda, _Unwind_Exception_Class excepti\n         while (p < actionTable)\n         {\n             // Note that all call-site encodings are \"absolute\" displacements.\n-            auto CSStart = read_encoded_value(null, CSEncoding, &p);\n-            auto CSLen = read_encoded_value(null, CSEncoding, &p);\n-            auto CSLandingPad = read_encoded_value(null, CSEncoding, &p);\n-            auto CSAction = read_uleb128(&p);\n+            auto CSStart = read_encoded_value(null, CSEncoding, p);\n+            auto CSLen = read_encoded_value(null, CSEncoding, p);\n+            auto CSLandingPad = read_encoded_value(null, CSEncoding, p);\n+            auto CSAction = read_uleb128(p);\n \n             // The table is sorted, so if we've passed the ip, stop.\n             if (ip < Start + CSStart)\n@@ -703,9 +703,9 @@ int actionTableLookup(_Unwind_Action actions, _Unwind_Exception* unwindHeader,\n     while (1)\n     {\n         auto ap = actionRecord;\n-        auto ARFilter = read_sleb128(&ap);\n+        auto ARFilter = read_sleb128(ap);\n         auto apn = ap;\n-        auto ARDisp = read_sleb128(&ap);\n+        auto ARDisp = read_sleb128(ap);\n \n         if (ARFilter == 0)\n         {\n@@ -725,7 +725,7 @@ int actionTableLookup(_Unwind_Action actions, _Unwind_Exception* unwindHeader,\n             // the ClassInfo is stored.\n             const(ubyte)* tp = TType - ARFilter * encodedSize;\n \n-            auto entry = read_encoded_value_with_base(TTypeEncoding, TTypeBase, &tp);\n+            auto entry = read_encoded_value_with_base(TTypeEncoding, TTypeBase, tp);\n             ClassInfo ci = cast(ClassInfo)cast(void*)(entry);\n \n             // D does not have catch-all handlers, and so the following"}, {"sha": "b9b05cbc8f6179df93b33798a468774c4697bd3d", "filename": "libphobos/libdruntime/gcc/unwind/pe.d", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b11d8d1be9c683f1517472c47a3cb69df02c4f/libphobos%2Flibdruntime%2Fgcc%2Funwind%2Fpe.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b11d8d1be9c683f1517472c47a3cb69df02c4f/libphobos%2Flibdruntime%2Fgcc%2Funwind%2Fpe.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Funwind%2Fpe.d?ref=30b11d8d1be9c683f1517472c47a3cb69df02c4f", "patch": "@@ -103,40 +103,37 @@ _Unwind_Ptr base_of_encoded_value(ubyte encoding, _Unwind_Context* context)\n     assert(0);\n }\n \n-// Read an unsigned leb128 value from P, *P is incremented past the value.\n+// Read an unsigned leb128 value from P, P is incremented past the value.\n // We assume that a word is large enough to hold any value so encoded;\n // if it is smaller than a pointer on some target, pointers should not be\n // leb128 encoded on that target.\n-_uleb128_t read_uleb128(const(ubyte)** p)\n+_uleb128_t read_uleb128(ref const(ubyte)* p)\n {\n-    auto q = *p;\n     _uleb128_t result = 0;\n     uint shift = 0;\n \n     while (1)\n     {\n-        ubyte b = *q++;\n+        ubyte b = *p++;\n         result |= cast(_uleb128_t)(b & 0x7F) << shift;\n         if ((b & 0x80) == 0)\n             break;\n         shift += 7;\n     }\n \n-    *p = q;\n     return result;\n }\n \n // Similar, but read a signed leb128 value.\n-_sleb128_t read_sleb128(const(ubyte)** p)\n+_sleb128_t read_sleb128(ref const(ubyte)* p)\n {\n-    auto q = *p;\n     _sleb128_t result = 0;\n     uint shift = 0;\n     ubyte b = void;\n \n     while (1)\n     {\n-        b = *q++;\n+        b = *p++;\n         result |= cast(_sleb128_t)(b & 0x7F) << shift;\n         shift += 7;\n         if ((b & 0x80) == 0)\n@@ -147,69 +144,82 @@ _sleb128_t read_sleb128(const(ubyte)** p)\n     if (shift < result.sizeof * 8 && (b & 0x40))\n         result |= -(cast(_sleb128_t)1 << shift);\n \n-    *p = q;\n     return result;\n }\n \n-// Load an encoded value from memory at P.  The value is returned in VAL;\n-// The function returns P incremented past the value.  BASE is as given\n+// Similar, but read an unaligned value of type T.\n+pragma(inline, true)\n+private T read_unaligned(T)(ref const(ubyte)* p)\n+{\n+    version (X86)         enum hasUnalignedLoads = true;\n+    else version (X86_64) enum hasUnalignedLoads = true;\n+    else                  enum hasUnalignedLoads = false;\n+\n+    static if (hasUnalignedLoads)\n+    {\n+        T result = *cast(T*)p;\n+    }\n+    else\n+    {\n+        import core.stdc.string : memcpy;\n+        T result = void;\n+        memcpy(&result, p, T.sizeof);\n+    }\n+    p += T.sizeof;\n+    return result;\n+}\n+\n+// Load an encoded value from memory at P.  The function returns the\n+// encoded value.  P is incremented past the value.  BASE is as given\n // by base_of_encoded_value for this encoding in the appropriate context.\n _Unwind_Ptr read_encoded_value_with_base(ubyte encoding, _Unwind_Ptr base,\n-                                         const(ubyte)** p)\n+                                         ref const(ubyte)* p)\n {\n-    auto q = *p;\n+    auto psave = p;\n     _Unwind_Internal_Ptr result;\n \n     if (encoding == DW_EH_PE_aligned)\n     {\n-        _Unwind_Internal_Ptr a = cast(_Unwind_Internal_Ptr)q;\n+        _Unwind_Internal_Ptr a = cast(_Unwind_Internal_Ptr)p;\n         a = cast(_Unwind_Internal_Ptr)((a + (void*).sizeof - 1) & - (void*).sizeof);\n         result = *cast(_Unwind_Internal_Ptr*)a;\n-        q = cast(ubyte*) cast(_Unwind_Internal_Ptr)(a + (void*).sizeof);\n+        p = cast(ubyte*) cast(_Unwind_Internal_Ptr)(a + (void*).sizeof);\n     }\n     else\n     {\n         switch (encoding & 0x0f)\n         {\n             case DW_EH_PE_uleb128:\n-                result = cast(_Unwind_Internal_Ptr)read_uleb128(&q);\n+                result = cast(_Unwind_Internal_Ptr)read_uleb128(p);\n                 break;\n \n             case DW_EH_PE_sleb128:\n-                result = cast(_Unwind_Internal_Ptr)read_sleb128(&q);\n+                result = cast(_Unwind_Internal_Ptr)read_sleb128(p);\n                 break;\n \n             case DW_EH_PE_udata2:\n-                result = cast(_Unwind_Internal_Ptr) *cast(ushort*)q;\n-                q += 2;\n+                result = cast(_Unwind_Internal_Ptr)read_unaligned!ushort(p);\n                 break;\n             case DW_EH_PE_udata4:\n-                result = cast(_Unwind_Internal_Ptr) *cast(uint*)q;\n-                q += 4;\n+                result = cast(_Unwind_Internal_Ptr)read_unaligned!uint(p);\n                 break;\n             case DW_EH_PE_udata8:\n-                result = cast(_Unwind_Internal_Ptr) *cast(ulong*)q;\n-                q += 8;\n+                result = cast(_Unwind_Internal_Ptr)read_unaligned!ulong(p);\n                 break;\n \n             case DW_EH_PE_sdata2:\n-                result = cast(_Unwind_Internal_Ptr) *cast(short*)q;\n-                q += 2;\n+                result = cast(_Unwind_Internal_Ptr)read_unaligned!short(p);\n                 break;\n             case DW_EH_PE_sdata4:\n-                result = cast(_Unwind_Internal_Ptr) *cast(int*)q;\n-                q += 4;\n+                result = cast(_Unwind_Internal_Ptr)read_unaligned!int(p);\n                 break;\n             case DW_EH_PE_sdata8:\n-                result = cast(_Unwind_Internal_Ptr) *cast(long*)q;\n-                q += 8;\n+                result = cast(_Unwind_Internal_Ptr)read_unaligned!long(p);\n                 break;\n \n             case DW_EH_PE_absptr:\n-                if (size_t.sizeof == 8)\n-                    goto case DW_EH_PE_udata8;\n-                else\n-                    goto case DW_EH_PE_udata4;\n+                result = cast(_Unwind_Internal_Ptr)read_unaligned!(size_t)(p);\n+                break;\n \n             default:\n                 __builtin_abort();\n@@ -218,20 +228,19 @@ _Unwind_Ptr read_encoded_value_with_base(ubyte encoding, _Unwind_Ptr base,\n         if (result != 0)\n         {\n             result += ((encoding & 0x70) == DW_EH_PE_pcrel\n-                       ? cast(_Unwind_Internal_Ptr)*p : base);\n+                       ? cast(_Unwind_Internal_Ptr)psave : base);\n             if (encoding & DW_EH_PE_indirect)\n                 result = *cast(_Unwind_Internal_Ptr*)result;\n         }\n     }\n \n-    *p = q;\n     return result;\n }\n \n // Like read_encoded_value_with_base, but get the base from the context\n // rather than providing it directly.\n _Unwind_Ptr read_encoded_value(_Unwind_Context* context, ubyte encoding,\n-                               const(ubyte)** p)\n+                               ref const(ubyte)* p)\n {\n     auto base = base_of_encoded_value(encoding, context);\n     return read_encoded_value_with_base(encoding, base, p);"}]}