{"sha": "6e539e23964d08d584a9c16050949424d44a3601", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU1MzllMjM5NjRkMDhkNTg0YTljMTYwNTA5NDk0MjRkNDRhMzYwMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-25T09:25:57Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-25T09:25:57Z"}, "message": "[multiple changes]\n\n2004-06-25  Dan Nicolaescu  <dann@ics.uci.edu>\n\t    Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_algobase.h (__fill, __fill_n): New helpers\n\tfor fill and fill_n, respectively: when copying is cheap, use a\n\ttemporary to avoid a memory read in each iteration.\n\n2004-06-25  Paolo Carlini  <pcarlini@suse.de>\n\n\t* testsuite/25_algorithms/fill/1.cc: New.\n\t* testsuite/25_algorithms/fill/2.cc: Likewise.\n\nFrom-SVN: r83645", "tree": {"sha": "1a8e35aa04613745272fa79f855dad4081915c11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a8e35aa04613745272fa79f855dad4081915c11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e539e23964d08d584a9c16050949424d44a3601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e539e23964d08d584a9c16050949424d44a3601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e539e23964d08d584a9c16050949424d44a3601", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e539e23964d08d584a9c16050949424d44a3601/comments", "author": null, "committer": null, "parents": [{"sha": "c19d6c9f9f39c010d76effe3bbbe863ec31ee667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c19d6c9f9f39c010d76effe3bbbe863ec31ee667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c19d6c9f9f39c010d76effe3bbbe863ec31ee667"}], "stats": {"total": 255, "additions": 229, "deletions": 26}, "files": [{"sha": "0ecd53334023ade5cea44ff53437cf2a65c4897f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e539e23964d08d584a9c16050949424d44a3601/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e539e23964d08d584a9c16050949424d44a3601/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6e539e23964d08d584a9c16050949424d44a3601", "patch": "@@ -1,3 +1,15 @@\n+2004-06-25  Dan Nicolaescu  <dann@ics.uci.edu>\n+\t    Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_algobase.h (__fill, __fill_n): New helpers\n+\tfor fill and fill_n, respectively: when copying is cheap, use a\n+\ttemporary to avoid a memory read in each iteration.\n+\n+2004-06-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* testsuite/25_algorithms/fill/1.cc: New.\n+\t* testsuite/25_algorithms/fill/2.cc: Likewise.\n+\n 2004-06-25  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/debug/formatter.h (__gnu_debug::_Error_formatter):"}, {"sha": "0db0ef7daac92a14473eed807d0d1b00cc7fe366", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 79, "deletions": 26, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e539e23964d08d584a9c16050949424d44a3601/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e539e23964d08d584a9c16050949424d44a3601/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=6e539e23964d08d584a9c16050949424d44a3601", "patch": "@@ -499,6 +499,32 @@ namespace std\n \t\t\t\t\t\t\t__result, __Normal());\n     }\n \n+  template<typename>\n+    struct __fill\n+    {\n+      template<typename _ForwardIterator, typename _Tp>\n+        static void\n+        fill(_ForwardIterator __first, _ForwardIterator __last,\n+\t     const _Tp& __value)\n+        {\n+\t  for (; __first != __last; ++__first)\n+\t    *__first = __value;\n+\t}\n+    };\n+\n+  template<>\n+    struct __fill<__true_type>\n+    {\n+      template<typename _ForwardIterator, typename _Tp>\n+        static void\n+        fill(_ForwardIterator __first, _ForwardIterator __last,\n+\t     const _Tp& __value)\n+        {\n+\t  const _Tp __tmp = __value;\n+\t  for (; __first != __last; ++__first)\n+\t    *__first = __tmp;\n+\t}\n+    };\n \n   /**\n    *  @brief Fills the range [first,last) with copies of value.\n@@ -520,31 +546,9 @@ namespace std\n \t\t\t\t  _ForwardIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      for ( ; __first != __last; ++__first)\n-\t*__first = __value;\n-    }\n-\n-  /**\n-   *  @brief Fills the range [first,first+n) with copies of value.\n-   *  @param  first  An output iterator.\n-   *  @param  n      The count of copies to perform.\n-   *  @param  value  A reference-to-const of arbitrary type.\n-   *  @return   The iterator at first+n.\n-   *\n-   *  This function fills a range with copies of the same value.  For one-byte\n-   *  types filling contiguous areas of memory, this becomes an inline call to\n-   *  @c memset.\n-  */\n-  template<typename _OutputIterator, typename _Size, typename _Tp>\n-    _OutputIterator\n-    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)\n-    {\n-      // concept requirements\n-      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,_Tp>)\n-\n-      for ( ; __n > 0; --__n, ++__first)\n-\t*__first = __value;\n-      return __first;\n+      typedef typename __type_traits<_Tp>::has_trivial_copy_constructor\n+\t_Trivial;\n+      std::__fill<_Trivial>::fill(__first, __last, __value);\n     }\n \n   // Specialization: for one-byte types we can use memset.\n@@ -572,6 +576,56 @@ namespace std\n     std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n   }\n \n+  template<typename>\n+    struct __fill_n\n+    {\n+      template<typename _OutputIterator, typename _Size, typename _Tp>\n+        static _OutputIterator\n+        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)\n+        {\n+\t  for (; __n > 0; --__n, ++__first)\n+\t    *__first = __value;\n+\t  return __first;\n+\t}\n+    };\n+\n+  template<>\n+    struct __fill_n<__true_type>\n+    {\n+      template<typename _OutputIterator, typename _Size, typename _Tp>\n+        static _OutputIterator\n+        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)\n+        {\n+\t  const _Tp __tmp = __value;\n+\t  for (; __n > 0; --__n, ++__first)\n+\t    *__first = __tmp;\n+\t  return __first;\t  \n+\t}\n+    };\n+\n+  /**\n+   *  @brief Fills the range [first,first+n) with copies of value.\n+   *  @param  first  An output iterator.\n+   *  @param  n      The count of copies to perform.\n+   *  @param  value  A reference-to-const of arbitrary type.\n+   *  @return   The iterator at first+n.\n+   *\n+   *  This function fills a range with copies of the same value.  For one-byte\n+   *  types filling contiguous areas of memory, this becomes an inline call to\n+   *  @c memset.\n+  */\n+  template<typename _OutputIterator, typename _Size, typename _Tp>\n+    _OutputIterator\n+    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator, _Tp>)\n+\n+      typedef typename __type_traits<_Tp>::has_trivial_copy_constructor\n+\t_Trivial;\n+      return std::__fill_n<_Trivial>::fill_n(__first, __n, __value);\n+    }\n+\n   template<typename _Size>\n     inline unsigned char*\n     fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)\n@@ -596,7 +650,6 @@ namespace std\n       return __first + __n;\n     }\n \n-\n   /**\n    *  @brief Finds the places in ranges which don't match.\n    *  @param  first1  An input iterator."}, {"sha": "62994bc5865f12e1ee82e0526165d2c8ca27b455", "filename": "libstdc++-v3/testsuite/25_algorithms/fill/1.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e539e23964d08d584a9c16050949424d44a3601/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e539e23964d08d584a9c16050949424d44a3601/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2F1.cc?ref=6e539e23964d08d584a9c16050949424d44a3601", "patch": "@@ -0,0 +1,69 @@\n+// 2004-06-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.2.5 [lib.alg.fill] Fill\n+\n+#include <list>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+class num\n+{\n+  int stored;\n+\n+public:\n+  num(int init = 0)\n+  : stored(init)\n+  { }\n+\n+  operator int() const\n+  { return stored; }\n+};\n+\n+// fill\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  const int val = 1;\n+\n+  const int V[] = { val, val, val, val, val, val, val };\n+  const list<int>::size_type N = sizeof(V) / sizeof(int);\n+\n+  list<int> coll(N);\n+  fill(coll.begin(), coll.end(), val);\n+  VERIFY( equal(coll.begin(), coll.end(), V) );\n+\n+  list<num> coll2(N);\n+  fill(coll2.begin(), coll2.end(), val);\n+  VERIFY( equal(coll2.begin(), coll2.end(), V) );\n+}\n+\n+#if !__GXX_WEAK__ && _MT_ALLOCATOR_H\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template class __gnu_cxx::__mt_alloc<std::_List_node<int> >;\n+#endif\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4f0437e80fbb68e926c66df99cca2da06de61915", "filename": "libstdc++-v3/testsuite/25_algorithms/fill/2.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e539e23964d08d584a9c16050949424d44a3601/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e539e23964d08d584a9c16050949424d44a3601/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2F2.cc?ref=6e539e23964d08d584a9c16050949424d44a3601", "patch": "@@ -0,0 +1,69 @@\n+// 2004-06-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.2.5 [lib.alg.fill] Fill\n+\n+#include <list>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+class num\n+{\n+  int stored;\n+\n+public:\n+  num(int init = 0)\n+  : stored(init)\n+  { }\n+\n+  operator int() const\n+  { return stored; }\n+};\n+\n+// fill_n\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  const int val = 3;\n+\n+  const int V[] = { val, val, val, val, val, val, val, val, val };\n+  const list<int>::size_type N = sizeof(V) / sizeof(int);\n+\n+  list<int> coll(N);\n+  fill_n(coll.begin(), coll.size(), val);\n+  VERIFY( equal(coll.begin(), coll.end(), V) );\n+\n+  list<num> coll2(N);\n+  fill_n(coll2.begin(), coll2.size(), val);\n+  VERIFY( equal(coll2.begin(), coll2.end(), V) );\n+}\n+\n+#if !__GXX_WEAK__ && _MT_ALLOCATOR_H\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template class __gnu_cxx::__mt_alloc<std::_List_node<int> >;\n+#endif\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}