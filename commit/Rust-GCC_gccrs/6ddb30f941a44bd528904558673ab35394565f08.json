{"sha": "6ddb30f941a44bd528904558673ab35394565f08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRkYjMwZjk0MWE0NGJkNTI4OTA0NTU4NjczYWIzNTM5NDU2NWYwOA==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-08-20T07:30:40Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-08-24T09:45:33Z"}, "message": "Optimize (a & b) | (c & ~b) to vpternlog instruction.\n\nAlso optimize below 3 forms to vpternlog, op1, op2, op3 are\nregister_operand or unary_p as (not reg)\n\nA: (any_logic (any_logic op1 op2) op3)\nB: (any_logic (any_logic op1 op2) (any_logic op3 op4)) op3/op4 should\nbe equal to op1/op2\nC: (any_logic (any_logic (any_logic:op1 op2) op3) op4) op3/op4 should\nbe equal to op1/op2\n\ngcc/ChangeLog:\n\n\tPR target/101989\n\t* config/i386/i386.c (ix86_rtx_costs): Define cost for\n\tUNSPEC_VTERNLOG.\n\t* config/i386/i386.h (STRIP_UNARY): New macro.\n\t* config/i386/predicates.md (reg_or_notreg_operand): New\n\tpredicate.\n\t* config/i386/sse.md (*<avx512>_vternlog<mode>_all): New define_insn.\n\t(*<avx512>_vternlog<mode>_1): New pre_reload\n\tdefine_insn_and_split.\n\t(*<avx512>_vternlog<mode>_2): Ditto.\n\t(*<avx512>_vternlog<mode>_3): Ditto.\n\t(any_logic1,any_logic2): New code iterator.\n\t(logic_op): New code attribute.\n\t(ternlogsuffix): Extend to VNxDF and VNxSF.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/101989\n\t* gcc.target/i386/pr101989-1.c: New test.\n\t* gcc.target/i386/pr101989-2.c: New test.\n\t* gcc.target/i386/avx512bw-shiftqihi-constant-1.c: Adjust testcase.", "tree": {"sha": "93e9d42f77d3b3ea0aebc3b0ae64345c5be60947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93e9d42f77d3b3ea0aebc3b0ae64345c5be60947"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ddb30f941a44bd528904558673ab35394565f08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ddb30f941a44bd528904558673ab35394565f08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ddb30f941a44bd528904558673ab35394565f08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ddb30f941a44bd528904558673ab35394565f08/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8571ff0ae0922bee292161c7fd61dd127d26a4ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8571ff0ae0922bee292161c7fd61dd127d26a4ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8571ff0ae0922bee292161c7fd61dd127d26a4ed"}], "stats": {"total": 405, "additions": 403, "deletions": 2}, "files": [{"sha": "ebec8668758e3e80257b0a144c73f9205a9d95a4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6ddb30f941a44bd528904558673ab35394565f08", "patch": "@@ -20542,6 +20542,11 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n     case UNSPEC:\n       if (XINT (x, 1) == UNSPEC_TP)\n \t*total = 0;\n+      else if (XINT(x, 1) == UNSPEC_VTERNLOG)\n+\t{\n+\t  *total = cost->sse_op;\n+\t  return true;\n+\t}\n       return false;\n \n     case VEC_SELECT:"}, {"sha": "65114229c86cdb6b12a18ea56710f7bb5a3e4588", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=6ddb30f941a44bd528904558673ab35394565f08", "patch": "@@ -1716,6 +1716,8 @@ typedef struct ix86_args {\n \n #define LEGITIMATE_PIC_OPERAND_P(X) legitimate_pic_operand_p (X)\n \n+#define STRIP_UNARY(X) (UNARY_P (X) ? XEXP (X, 0) : X)\n+\n #define SYMBOLIC_CONST(X)\t\\\n   (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n    || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\"}, {"sha": "df5acb425d48928c13a1dc707efeb326cea29eb4", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=6ddb30f941a44bd528904558673ab35394565f08", "patch": "@@ -1044,6 +1044,13 @@\n \t    (ior (match_test \"op == const1_rtx\")\n \t\t (match_test \"op == constm1_rtx\")))))\n \n+;; True for registers, or (not: registers).  Used to optimize 3-operand\n+;; bitwise operation.\n+(define_predicate \"reg_or_notreg_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"not\")\n+\t    (match_test \"register_operand (XEXP (op, 0), mode)\"))))\n+\n ;; True if OP is acceptable as operand of DImode shift expander.\n (define_predicate \"shiftdi_operand\"\n   (if_then_else (match_test \"TARGET_64BIT\")"}, {"sha": "25ca9a5c29c251c964d62f91d8e3b714f72acabd", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=6ddb30f941a44bd528904558673ab35394565f08", "patch": "@@ -933,7 +933,9 @@\n ;; Mapping of vector modes to VPTERNLOG suffix\n (define_mode_attr ternlogsuffix\n   [(V8DI \"q\") (V4DI \"q\") (V2DI \"q\")\n+   (V8DF \"q\") (V4DF \"q\") (V2DF \"q\")\n    (V16SI \"d\") (V8SI \"d\") (V4SI \"d\")\n+   (V16SF \"d\") (V8SF \"d\") (V4SF \"d\")\n    (V32HI \"d\") (V16HI \"d\") (V8HI \"d\")\n    (V64QI \"d\") (V32QI \"d\") (V16QI \"d\")])\n \n@@ -10041,6 +10043,238 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n+(define_insn \"*<avx512>_vternlog<mode>_all\"\n+  [(set (match_operand:V 0 \"register_operand\" \"=v\")\n+\t(unspec:V\n+\t  [(match_operand:V 1 \"register_operand\" \"0\")\n+\t   (match_operand:V 2 \"register_operand\" \"v\")\n+\t   (match_operand:V 3 \"nonimmediate_operand\" \"vm\")\n+\t   (match_operand:SI 4 \"const_0_to_255_operand\")]\n+\t  UNSPEC_VTERNLOG))]\n+  \"TARGET_AVX512F\"\n+  \"vpternlog<ternlogsuffix>\\t{%4, %3, %2, %0|%0, %2, %3, %4}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+;; There must be lots of other combinations like\n+;;\n+;; (any_logic:V\n+;;   (any_logic:V op1 op2)\n+;;   (any_logic:V op1 op3))\n+;;\n+;; (any_logic:V\n+;;   (any_logic:V\n+;;     (any_logic:V op1, op2)\n+;;     op3)\n+;;   op1)\n+;;\n+;; and so on.\n+\n+(define_code_iterator any_logic1 [and ior xor])\n+(define_code_iterator any_logic2 [and ior xor])\n+(define_code_attr logic_op [(and \"&\") (ior \"|\") (xor \"^\")])\n+\n+(define_insn_and_split \"*<avx512>_vpternlog<mode>_1\"\n+  [(set (match_operand:V 0 \"register_operand\")\n+\t(any_logic:V\n+\t  (any_logic1:V\n+\t    (match_operand:V 1 \"reg_or_notreg_operand\")\n+\t    (match_operand:V 2 \"reg_or_notreg_operand\"))\n+\t  (any_logic2:V\n+\t    (match_operand:V 3 \"reg_or_notreg_operand\")\n+\t    (match_operand:V 4 \"reg_or_notreg_operand\"))))]\n+  \"(<MODE_SIZE> == 64 || TARGET_AVX512VL)\n+   && ix86_pre_reload_split ()\n+   && (rtx_equal_p (STRIP_UNARY (operands[1]),\n+\t\t    STRIP_UNARY (operands[4]))\n+       || rtx_equal_p (STRIP_UNARY (operands[2]),\n+\t\t       STRIP_UNARY (operands[4]))\n+       || rtx_equal_p (STRIP_UNARY (operands[1]),\n+\t\t       STRIP_UNARY (operands[3]))\n+       || rtx_equal_p (STRIP_UNARY (operands[2]),\n+\t\t       STRIP_UNARY (operands[3])))\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(unspec:V\n+\t  [(match_dup 6)\n+\t   (match_dup 2)\n+\t   (match_dup 1)\n+\t   (match_dup 5)]\n+\t  UNSPEC_VTERNLOG))]\n+{\n+  /* VPTERNLOGD reg6, reg2, reg1, imm8.  */\n+  int reg6 = 0xF0;\n+  int reg2 = 0xCC;\n+  int reg1 = 0xAA;\n+  int reg3 = 0;\n+  int reg4 = 0;\n+  int reg_mask, tmp1, tmp2;\n+  if (rtx_equal_p (STRIP_UNARY (operands[1]),\n+\t\t   STRIP_UNARY (operands[4])))\n+    {\n+      reg4 = reg1;\n+      reg3 = reg6;\n+      operands[6] = operands[3];\n+    }\n+  else if (rtx_equal_p (STRIP_UNARY (operands[2]),\n+\t\t       STRIP_UNARY (operands[4])))\n+    {\n+      reg4 = reg2;\n+      reg3 = reg6;\n+      operands[6] = operands[3];\n+    }\n+  else if (rtx_equal_p (STRIP_UNARY (operands[1]),\n+\t\t\tSTRIP_UNARY (operands[3])))\n+    {\n+      reg4 = reg6;\n+      reg3 = reg1;\n+      operands[6] = operands[4];\n+    }\n+  else\n+    {\n+      reg4 = reg6;\n+      reg3 = reg2;\n+      operands[6] = operands[4];\n+    }\n+\n+  reg1 = UNARY_P (operands[1]) ? ~reg1 : reg1;\n+  reg2 = UNARY_P (operands[2]) ? ~reg2 : reg2;\n+  reg3 = UNARY_P (operands[3]) ? ~reg3 : reg3;\n+  reg4 = UNARY_P (operands[4]) ? ~reg4 : reg4;\n+\n+  tmp1 = reg1 <any_logic1:logic_op> reg2;\n+  tmp2 = reg3 <any_logic2:logic_op> reg4;\n+  reg_mask = tmp1  <any_logic:logic_op> tmp2;\n+  reg_mask &= 0xFF;\n+\n+  operands[1] = STRIP_UNARY (operands[1]);\n+  operands[2] = STRIP_UNARY (operands[2]);\n+  operands[6] = STRIP_UNARY (operands[6]);\n+  operands[5] = GEN_INT (reg_mask);\n+})\n+\n+(define_insn_and_split \"*<avx512>_vpternlog<mode>_2\"\n+  [(set (match_operand:V 0 \"register_operand\")\n+\t(any_logic:V\n+\t  (any_logic1:V\n+\t    (any_logic2:V\n+\t      (match_operand:V 1 \"reg_or_notreg_operand\")\n+\t      (match_operand:V 2 \"reg_or_notreg_operand\"))\n+\t    (match_operand:V 3 \"reg_or_notreg_operand\"))\n+\t  (match_operand:V 4 \"reg_or_notreg_operand\")))]\n+  \"(<MODE_SIZE> == 64 || TARGET_AVX512VL)\n+   && ix86_pre_reload_split ()\n+   && (rtx_equal_p (STRIP_UNARY (operands[1]),\n+\t\t    STRIP_UNARY (operands[4]))\n+       || rtx_equal_p (STRIP_UNARY (operands[2]),\n+\t\t       STRIP_UNARY (operands[4]))\n+       || rtx_equal_p (STRIP_UNARY (operands[1]),\n+\t\t       STRIP_UNARY (operands[3]))\n+       || rtx_equal_p (STRIP_UNARY (operands[2]),\n+\t\t       STRIP_UNARY (operands[3])))\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(unspec:V\n+\t  [(match_dup 6)\n+\t   (match_dup 2)\n+\t   (match_dup 1)\n+\t   (match_dup 5)]\n+\t  UNSPEC_VTERNLOG))]\n+{\n+  /* VPTERNLOGD reg6, reg2, reg1, imm8.  */\n+  int reg6 = 0xF0;\n+  int reg2 = 0xCC;\n+  int reg1 = 0xAA;\n+  int reg3 = 0;\n+  int reg4 = 0;\n+  int reg_mask, tmp1, tmp2;\n+  if (rtx_equal_p (STRIP_UNARY (operands[1]),\n+\t\t   STRIP_UNARY (operands[4])))\n+    {\n+      reg4 = reg1;\n+      reg3 = reg6;\n+      operands[6] = operands[3];\n+    }\n+  else if (rtx_equal_p (STRIP_UNARY (operands[2]),\n+\t\t       STRIP_UNARY (operands[4])))\n+    {\n+      reg4 = reg2;\n+      reg3 = reg6;\n+      operands[6] = operands[3];\n+    }\n+  else if (rtx_equal_p (STRIP_UNARY (operands[1]),\n+\t\t\tSTRIP_UNARY (operands[3])))\n+    {\n+      reg4 = reg6;\n+      reg3 = reg1;\n+      operands[6] = operands[4];\n+    }\n+  else\n+    {\n+      reg4 = reg6;\n+      reg3 = reg2;\n+      operands[6] = operands[4];\n+    }\n+\n+  reg1 = UNARY_P (operands[1]) ? ~reg1 : reg1;\n+  reg2 = UNARY_P (operands[2]) ? ~reg2 : reg2;\n+  reg3 = UNARY_P (operands[3]) ? ~reg3 : reg3;\n+  reg4 = UNARY_P (operands[4]) ? ~reg4 : reg4;\n+\n+  tmp1 = reg1 <any_logic2:logic_op> reg2;\n+  tmp2 = tmp1 <any_logic1:logic_op> reg3;\n+  reg_mask = tmp2 <any_logic:logic_op> reg4;\n+  reg_mask &= 0xFF;\n+\n+  operands[1] = STRIP_UNARY (operands[1]);\n+  operands[2] = STRIP_UNARY (operands[2]);\n+  operands[6] = STRIP_UNARY (operands[6]);\n+  operands[5] = GEN_INT (reg_mask);\n+})\n+\n+(define_insn_and_split \"*<avx512>_vpternlog<mode>_3\"\n+  [(set (match_operand:V 0 \"register_operand\")\n+\t(any_logic:V\n+\t  (any_logic1:V\n+\t    (match_operand:V 1 \"reg_or_notreg_operand\")\n+\t    (match_operand:V 2 \"reg_or_notreg_operand\"))\n+\t  (match_operand:V 3 \"reg_or_notreg_operand\")))]\n+  \"(<MODE_SIZE> == 64 || TARGET_AVX512VL)\n+   && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(unspec:V\n+\t  [(match_dup 3)\n+\t   (match_dup 2)\n+\t   (match_dup 1)\n+\t   (match_dup 4)]\n+\t  UNSPEC_VTERNLOG))]\n+{\n+  /* VPTERNLOGD reg3, reg2, reg1, imm8.  */\n+  int reg3 = 0xF0;\n+  int reg2 = 0xCC;\n+  int reg1 = 0xAA;\n+  int reg_mask, tmp1;\n+\n+  reg1 = UNARY_P (operands[1]) ? ~reg1 : reg1;\n+  reg2 = UNARY_P (operands[2]) ? ~reg2 : reg2;\n+  reg3 = UNARY_P (operands[3]) ? ~reg3 : reg3;\n+\n+  tmp1 = reg1 <any_logic1:logic_op> reg2;\n+  reg_mask = tmp1 <any_logic:logic_op> reg3;\n+  reg_mask &= 0xFF;\n+\n+  operands[1] = STRIP_UNARY (operands[1]);\n+  operands[2] = STRIP_UNARY (operands[2]);\n+  operands[3] = STRIP_UNARY (operands[3]);\n+  operands[4] = GEN_INT (reg_mask);\n+})\n+\n+\n (define_insn \"<avx512>_vternlog<mode>_mask\"\n   [(set (match_operand:VI48_AVX512VL 0 \"register_operand\" \"=v\")\n \t(vec_merge:VI48_AVX512VL"}, {"sha": "fbc3de08119e8beacb3344e9ac18cf47b2bedce7", "filename": "gcc/testsuite/gcc.target/i386/avx512bw-shiftqihi-constant-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-shiftqihi-constant-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-shiftqihi-constant-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-shiftqihi-constant-1.c?ref=6ddb30f941a44bd528904558673ab35394565f08", "patch": "@@ -1,7 +1,8 @@\n /* PR target/95524 */\n /* { dg-do compile } */\n /* { dg-options \"-O2 -mavx512bw\" } */\n-/* { dg-final { scan-assembler-times \"vpand\\[^\\n\\]*%zmm\" 3 } }  */\n+/* { dg-final { scan-assembler-times \"vpand\\[^\\n\\]*%zmm\" 2 } }  */\n+/* { dg-final { scan-assembler-times \"vpternlogd\\[^\\n\\]*%zmm\" 1 } }  */\n typedef char v64qi  __attribute__ ((vector_size (64)));\n typedef unsigned char v64uqi  __attribute__ ((vector_size (64)));\n \n@@ -11,7 +12,6 @@ foo_ashiftrt_512 (v64qi a)\n   return a >> 2;\n }\n /* { dg-final { scan-assembler-times \"vpsraw\\[^\\n\\]*%zmm\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vpxor\\[^\\n\\]*%zmm\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsubb\\[^\\n\\]*%zmm\" 1 } } */\n \n __attribute__((noipa)) v64qi"}, {"sha": "594093ecdde38bc2eafe19e6f4585f19fd8bd413", "filename": "gcc/testsuite/gcc.target/i386/pr101989-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101989-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101989-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101989-1.c?ref=6ddb30f941a44bd528904558673ab35394565f08", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"vpternlog\" 6 } } */\n+/* { dg-final { scan-assembler-not \"vpxor\" } } */\n+/* { dg-final { scan-assembler-not \"vpor\" } } */\n+/* { dg-final { scan-assembler-not \"vpand\" } } */\n+\n+#include<immintrin.h>\n+__m256d\n+__attribute__((noipa, target(\"avx512vl\")))\n+copysign2_pd(__m256d from, __m256d to) {\n+  __m256i a = _mm256_castpd_si256(from);\n+  __m256d avx_signbit = _mm256_castsi256_pd(_mm256_slli_epi64(_mm256_cmpeq_epi64(a, a), 63));\n+  /* (avx_signbit & from) | (~avx_signbit & to)  */\n+  return _mm256_or_pd(_mm256_and_pd(avx_signbit, from), _mm256_andnot_pd(avx_signbit, to));\n+}\n+\n+__m256i\n+__attribute__((noipa, target(\"avx512vl\")))\n+foo (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return (src2 & ~src1) | (src3 & src1);\n+}\n+\n+__m256i\n+__attribute__ ((noipa, target(\"avx512vl\")))\n+foo1 (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return (src2 & src1) | (src3 & ~src1);\n+}\n+\n+__m256i\n+__attribute__ ((noipa, target(\"avx512vl\")))\n+foo2 (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return (src2 & src1) | (~src3 & src1);\n+}\n+\n+__m256i\n+__attribute__ ((noipa, target(\"avx512vl\")))\n+foo3 (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return (~src2 & src1) | (src3 & src1);\n+}\n+\n+__m256i\n+__attribute__ ((noipa, target(\"avx512vl\")))\n+foo4 (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return src3 & src2 ^ src1;\n+}"}, {"sha": "9d9759a8e1dec9424bfb74a805b6c5ce3b2780a0", "filename": "gcc/testsuite/gcc.target/i386/pr101989-2.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101989-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb30f941a44bd528904558673ab35394565f08/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101989-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101989-2.c?ref=6ddb30f941a44bd528904558673ab35394565f08", "patch": "@@ -0,0 +1,102 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx2 -mno-avx512f\" } */\n+/* { dg-require-effective-target avx512vl } */\n+\n+#define AVX512VL\n+\n+#include \"avx512f-helper.h\"\n+\n+#include \"pr101989-1.c\"\n+__m256d\n+avx2_copysign2_pd (__m256d from, __m256d to) {\n+  __m256i a = _mm256_castpd_si256(from);\n+  __m256d avx_signbit = _mm256_castsi256_pd(_mm256_slli_epi64(_mm256_cmpeq_epi64(a, a), 63));\n+  /* (avx_signbit & from) | (~avx_signbit & to)  */\n+  return _mm256_or_pd(_mm256_and_pd(avx_signbit, from), _mm256_andnot_pd(avx_signbit, to));\n+}\n+\n+__m256i\n+avx2_foo (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return (src2 & ~src1) | (src3 & src1);\n+}\n+\n+__m256i\n+avx2_foo1 (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return (src2 & src1) | (src3 & ~src1);\n+}\n+\n+__m256i\n+avx2_foo2 (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return (src2 & src1) | (~src3 & src1);\n+}\n+\n+__m256i\n+avx2_foo3 (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return (~src2 & src1) | (src3 & src1);\n+}\n+\n+__m256i\n+avx2_foo4 (__m256i src1, __m256i src2, __m256i src3)\n+{\n+  return src3 & src2 ^ src1;\n+}\n+\n+\n+void\n+test_256 (void)\n+{\n+  union256i_q q1, q2, q3, res2, exp2;\n+  union256d d1, d2, res1, exp1;\n+  int i, sign = 1;\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      d1.a[i] = 12.34 * (i + 2000) * sign;\n+      d2.a[i] = 56.78 * (i - 30) * sign;\n+      q1.a[i] = 12 * (i + 2000) * sign;\n+      q2.a[i] = 56 * (i - 30) * sign;\n+      q3.a[i] = 90 * (i + 40) * sign;\n+      res1.a[i] = DEFAULT_VALUE;\n+      exp1.a[i] = DEFAULT_VALUE;\n+      res2.a[i] = exp2.a[i] = -1;\n+      sign = -sign;\n+    }\n+\n+  exp1.x = avx2_copysign2_pd (d1.x, d2.x);\n+  res1.x = copysign2_pd (d1.x, d2.x);\n+  if (UNION_CHECK (256, d) (res1, exp1.a))\n+    abort ();\n+\n+  exp2.x = avx2_foo1 (q1.x, q2.x, q3.x);\n+  res2.x = foo1 (q1.x, q2.x, q3.x);\n+  if (UNION_CHECK (256, i_q) (res2, exp2.a))\n+    abort ();\n+\n+  exp2.x = avx2_foo2 (q1.x, q2.x, q3.x);\n+  res2.x = foo2 (q1.x, q2.x, q3.x);\n+  if (UNION_CHECK (256, i_q) (res2, exp2.a))\n+    abort ();\n+\n+  exp2.x = avx2_foo3 (q1.x, q2.x, q3.x);\n+  res2.x = foo3 (q1.x, q2.x, q3.x);\n+  if (UNION_CHECK (256, i_q) (res2, exp2.a))\n+    abort ();\n+\n+  exp2.x = avx2_foo4 (q1.x, q2.x, q3.x);\n+  res2.x = foo4 (q1.x, q2.x, q3.x);\n+  if (UNION_CHECK (256, i_q) (res2, exp2.a))\n+    abort ();\n+\n+  exp2.x = avx2_foo (q1.x, q2.x, q3.x);\n+  res2.x = foo (q1.x, q2.x, q3.x);\n+  if (UNION_CHECK (256, i_q) (res2, exp2.a))\n+    abort ();\n+}\n+\n+static void\n+test_128 ()\n+{}"}]}