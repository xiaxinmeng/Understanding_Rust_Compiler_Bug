{"sha": "2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNlOGNiOTlhNjRlZDg1MTJiZTliM2FlNWU1YmVmMmMxODM1M2JhZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-08-15T15:22:44Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-08-15T15:22:44Z"}, "message": "re PR libstdc++/62154 (std::throw_with_nested should not require a polymorphic type)\n\n\tPR libstdc++/62154\n\t* libsupc++/nested_exception.h (throw_with_nested, rethrow_if_nested):\n\tRewrite to conform to C++11 requirements.\n\t* testsuite/18_support/nested_exception/62154.cc: New.\n\nFrom-SVN: r214025", "tree": {"sha": "0d0f1af2fe64278459b483900acea39afc2c15b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d0f1af2fe64278459b483900acea39afc2c15b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e54f6d3bac9f2e2626e4a1496e01a243d91b9d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e54f6d3bac9f2e2626e4a1496e01a243d91b9d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e54f6d3bac9f2e2626e4a1496e01a243d91b9d0"}], "stats": {"total": 192, "additions": 133, "deletions": 59}, "files": [{"sha": "71541111c756e53f78c9f22d6177ee2aff94f669", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf", "patch": "@@ -1,3 +1,10 @@\n+2014-08-15  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/62154\n+\t* libsupc++/nested_exception.h (throw_with_nested, rethrow_if_nested):\n+\tRewrite to conform to C++11 requirements.\n+\t* testsuite/18_support/nested_exception/62154.cc: New.\n+\n 2014-08-14  Matthias Klose  <doko@ubuntu.com>\n \n \t* testsuite/ext/random/uniform_on_sphere_distribution/requirements:"}, {"sha": "841c2237f66676ef4acd790e574066b077de7a7a", "filename": "libstdc++-v3/libsupc++/nested_exception.h", "status": "modified", "additions": 66, "deletions": 59, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h?ref=2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf", "patch": "@@ -59,101 +59,108 @@ namespace std\n   public:\n     nested_exception() noexcept : _M_ptr(current_exception()) { }\n \n-    nested_exception(const nested_exception&) = default;\n+    nested_exception(const nested_exception&) noexcept = default;\n \n-    nested_exception& operator=(const nested_exception&) = default;\n+    nested_exception& operator=(const nested_exception&) noexcept = default;\n \n     virtual ~nested_exception() noexcept;\n \n+    [[noreturn]]\n     void\n-    rethrow_nested() const __attribute__ ((__noreturn__))\n-    { rethrow_exception(_M_ptr); }\n+    rethrow_nested() const\n+    {\n+      if (_M_ptr)\n+\trethrow_exception(_M_ptr);\n+      std::terminate();\n+    }\n \n     exception_ptr\n-    nested_ptr() const\n+    nested_ptr() const noexcept\n     { return _M_ptr; }\n   };\n \n   template<typename _Except>\n     struct _Nested_exception : public _Except, public nested_exception\n     {\n+      explicit _Nested_exception(const _Except& __ex)\n+      : _Except(__ex)\n+      { }\n+\n       explicit _Nested_exception(_Except&& __ex)\n       : _Except(static_cast<_Except&&>(__ex))\n       { }\n     };\n \n-  template<typename _Ex>\n-    struct __get_nested_helper\n+  template<typename _Tp,\n+\t   bool __with_nested = !__is_base_of(nested_exception, _Tp)>\n+    struct _Throw_with_nested_impl\n     {\n-      static const nested_exception*\n-      _S_get(const _Ex& __ex)\n-      { return dynamic_cast<const nested_exception*>(&__ex); }\n+      template<typename _Up>\n+\tstatic void _S_throw(_Up&& __t)\n+\t{ throw _Nested_exception<_Tp>{static_cast<_Up&&>(__t)}; }\n     };\n \n-  template<typename _Ex>\n-    struct __get_nested_helper<_Ex*>\n+  template<typename _Tp>\n+    struct _Throw_with_nested_impl<_Tp, false>\n     {\n-      static const nested_exception*\n-      _S_get(const _Ex* __ex)\n-      { return dynamic_cast<const nested_exception*>(__ex); }\n+      template<typename _Up>\n+\tstatic void _S_throw(_Up&& __t)\n+\t{ throw static_cast<_Up&&>(__t); }\n     };\n \n-  template<typename _Ex>\n-    inline const nested_exception*\n-    __get_nested_exception(const _Ex& __ex)\n-    { return __get_nested_helper<_Ex>::_S_get(__ex); }\n-\n-  template<typename _Ex>\n-    void\n-    __throw_with_nested(_Ex&&, const nested_exception* = 0)\n-    __attribute__ ((__noreturn__));\n-\n-  template<typename _Ex>\n-    void\n-    __throw_with_nested(_Ex&&, ...) __attribute__ ((__noreturn__));\n-\n-  // This function should never be called, but is needed to avoid a warning\n-  // about ambiguous base classes when instantiating throw_with_nested<_Ex>()\n-  // with a type that has an accessible nested_exception base.\n-  template<typename _Ex>\n+  template<typename _Tp, bool = __is_class(_Tp)>\n+    struct _Throw_with_nested_helper : _Throw_with_nested_impl<_Tp>\n+    { };\n+\n+  template<typename _Tp>\n+    struct _Throw_with_nested_helper<_Tp, false>\n+    : _Throw_with_nested_impl<_Tp, false>\n+    { };\n+\n+  template<typename _Tp>\n+    struct _Throw_with_nested_helper<_Tp&, false>\n+    : _Throw_with_nested_helper<_Tp>\n+    { };\n+\n+  template<typename _Tp>\n+    struct _Throw_with_nested_helper<_Tp&&, false>\n+    : _Throw_with_nested_helper<_Tp>\n+    { };\n+\n+  /// If @p __t is derived from nested_exception, throws @p __t.\n+  /// Else, throws an implementation-defined object derived from both.\n+  template<typename _Tp>\n+    [[noreturn]]\n     inline void\n-    __throw_with_nested(_Ex&& __ex, const nested_exception*)\n-    { throw __ex; }\n+    throw_with_nested(_Tp&& __t)\n+    {\n+      _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp&&>(__t));\n+    }\n \n-  template<typename _Ex>\n-    inline void\n-    __throw_with_nested(_Ex&& __ex, ...)\n-    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }\n-  \n-  template<typename _Ex>\n-    void\n-    throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));\n+  template<typename _Tp, bool = __is_polymorphic(_Tp)>\n+    struct _Rethrow_if_nested_impl\n+    {\n+      static void _S_rethrow(const _Tp& __t)\n+      {\n+\tif (auto __tp = dynamic_cast<const nested_exception*>(&__t))\n+\t  __tp->rethrow_nested();\n+      }\n+    };\n \n-  /// If @p __ex is derived from nested_exception, @p __ex. \n-  /// Else, an implementation-defined object derived from both.\n-  template<typename _Ex>\n-    inline void\n-    throw_with_nested(_Ex __ex)\n+  template<typename _Tp>\n+    struct _Rethrow_if_nested_impl<_Tp, false>\n     {\n-      if (__get_nested_exception(__ex))\n-        throw __ex;\n-      __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);\n-    }\n+      static void _S_rethrow(const _Tp&) { }\n+    };\n \n   /// If @p __ex is derived from nested_exception, @p __ex.rethrow_nested().\n   template<typename _Ex>\n     inline void\n     rethrow_if_nested(const _Ex& __ex)\n     {\n-      if (const nested_exception* __nested = __get_nested_exception(__ex))\n-        __nested->rethrow_nested();\n+      _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);\n     }\n \n-  /// Overload, See N2619\n-  inline void\n-  rethrow_if_nested(const nested_exception& __ex)\n-  { __ex.rethrow_nested(); }\n-\n   // @} group exceptions\n } // namespace std\n "}, {"sha": "9c6725f603a7833b30234390c5fa2dc06b76f41e", "filename": "libstdc++-v3/testsuite/18_support/nested_exception/62154.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2F62154.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2F62154.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2F62154.cc?ref=2ce8cb99a64ed8512be9b3ae5e5bef2c18353baf", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <exception>\n+#include <testsuite_hooks.h>\n+\n+struct E { E(int) {} };\n+\n+void\n+test01()\n+{\n+  bool caught = false;\n+  try\n+  {\n+    std::throw_with_nested(E(42));\n+  }\n+  catch (const std::nested_exception& e)\n+  {\n+    caught = true;\n+  }\n+  VERIFY(caught);\n+}\n+\n+void\n+test02()\n+{\n+  bool caught = false;\n+  try\n+  {\n+    std::throw_with_nested(42);\n+  }\n+  catch (int)\n+  {\n+    caught = true;\n+  }\n+  VERIFY(caught);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}