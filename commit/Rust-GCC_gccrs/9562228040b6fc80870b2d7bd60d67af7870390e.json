{"sha": "9562228040b6fc80870b2d7bd60d67af7870390e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU2MjIyODA0MGI2ZmM4MDg3MGIyZDdiZDYwZDY3YWY3ODcwMzkwZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-05-07T09:44:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-05-07T09:44:30Z"}, "message": "cgraph.c (dump_cgraph_node): Update.\n\n\n\t* cgraph.c (dump_cgraph_node): Update.\n\t* cgraph.h (cgraph_local_info): Break out inline summary.\n\t* cgraphunit.c (cgraph_process_new_functions): Use inliner analysis\n\thook.\n\t* ipa-inline (inline_summary): New accestor function.\n\t(cgraph_clone_inlined_nodes, cgraph_check_inline_limits,\n\tcgraph_decide_inlining, compute_inline_parameters): Update.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Remove statistics.\n\nFrom-SVN: r135037", "tree": {"sha": "27271fad1665bd714366737d597a190b0a86136a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27271fad1665bd714366737d597a190b0a86136a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9562228040b6fc80870b2d7bd60d67af7870390e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9562228040b6fc80870b2d7bd60d67af7870390e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9562228040b6fc80870b2d7bd60d67af7870390e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9562228040b6fc80870b2d7bd60d67af7870390e/comments", "author": null, "committer": null, "parents": [{"sha": "96fcacb7d3047adc23f9f5688927053700476a88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fcacb7d3047adc23f9f5688927053700476a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96fcacb7d3047adc23f9f5688927053700476a88"}], "stats": {"total": 97, "additions": 50, "deletions": 47}, "files": [{"sha": "0a0e5215cda7c47a0a428f44997ea5450f8d6793", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9562228040b6fc80870b2d7bd60d67af7870390e", "patch": "@@ -1,3 +1,14 @@\n+2008-05-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (dump_cgraph_node): Update.\n+\t* cgraph.h (cgraph_local_info): Break out inline summary.\n+\t* cgraphunit.c (cgraph_process_new_functions): Use inliner analysis\n+\thook.\n+\t* ipa-inline (inline_summary): New accestor function.\n+\t(cgraph_clone_inlined_nodes, cgraph_check_inline_limits,\n+\tcgraph_decide_inlining, compute_inline_parameters): Update.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Remove statistics.\n+\n 2008-05-07  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \tCleanup ColdFire scheduling support and add V4 pipeline model."}, {"sha": "d3f8fa6671fd48ee8adde048af1e16d6ae6290b1", "filename": "gcc/cgraph.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=9562228040b6fc80870b2d7bd60d67af7870390e", "patch": "@@ -723,13 +723,14 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n \t     (HOST_WIDEST_INT)node->count);\n-  if (node->local.self_insns)\n-    fprintf (f, \" %i insns\", node->local.self_insns);\n-  if (node->global.insns && node->global.insns != node->local.self_insns)\n+  if (node->local.inline_summary.self_insns)\n+    fprintf (f, \" %i insns\", node->local.inline_summary.self_insns);\n+  if (node->global.insns && node->global.insns\n+      != node->local.inline_summary.self_insns)\n     fprintf (f, \" (%i after inlining)\", node->global.insns);\n-  if (node->local.estimated_self_stack_size)\n-    fprintf (f, \" %i bytes stack usage\", (int)node->local.estimated_self_stack_size);\n-  if (node->global.estimated_stack_size != node->local.estimated_self_stack_size)\n+  if (node->local.inline_summary.estimated_self_stack_size)\n+    fprintf (f, \" %i bytes stack usage\", (int)node->local.inline_summary.estimated_self_stack_size);\n+  if (node->global.estimated_stack_size != node->local.inline_summary.estimated_self_stack_size)\n     fprintf (f, \" %i bytes after inlining\", (int)node->global.estimated_stack_size);\n   if (node->origin)\n     fprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));"}, {"sha": "3b65dc829146b0d72beb8248e570f60edea11100", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9562228040b6fc80870b2d7bd60d67af7870390e", "patch": "@@ -53,11 +53,13 @@ extern const char * const cgraph_availability_names[];\n \n struct cgraph_local_info GTY(())\n {\n-  /* Estimated stack frame consumption by the function.  */\n-  HOST_WIDE_INT estimated_self_stack_size;\n+  struct inline_summary {\n+    /* Estimated stack frame consumption by the function.  */\n+    HOST_WIDE_INT estimated_self_stack_size;\n \n-  /* Size of the function before inlining.  */\n-  int self_insns;\n+    /* Size of the function before inlining.  */\n+    int self_insns;\n+  } inline_summary;\n \n   /* Set when function function is visible in current compilation unit only\n      and its address is never taken.  */"}, {"sha": "0806050ef64ca1eebd50e8ff0e9daa95c3e65b31", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9562228040b6fc80870b2d7bd60d67af7870390e", "patch": "@@ -460,16 +460,7 @@ cgraph_process_new_functions (void)\n \t    cgraph_analyze_function (node);\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t  current_function_decl = fndecl;\n-\t  node->local.inlinable = tree_inlinable_function_p (fndecl);\n-\t  node->local.self_insns = estimate_num_insns (fndecl,\n-\t\t\t\t\t\t       &eni_inlining_weights);\n-\t  node->local.disregard_inline_limits\n-\t    |= DECL_DISREGARD_INLINE_LIMITS (fndecl);\n-\t  /* Inlining characteristics are maintained by the\n-\t     cgraph_mark_inline.  */\n-\t  node->global.insns = node->local.self_insns;\n-\t  if (flag_really_no_inline && !node->local.disregard_inline_limits)\n-\t     node->local.inlinable = 0;\n+\t  pass_ipa_inline.function_generate_summary (node);\n \t  if ((cgraph_state == CGRAPH_STATE_IPA_SSA\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n \t      /* When not optimizing, be sure we run early local passes anyway"}, {"sha": "5361b8a1d1775dea76d47b74c045cd185695e717", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9562228040b6fc80870b2d7bd60d67af7870390e", "patch": "@@ -172,6 +172,12 @@ static int nfunctions_inlined;\n static int overall_insns;\n static gcov_type max_count;\n \n+static inline struct inline_summary *\n+inline_summary (struct cgraph_node *node)\n+{\n+  return &node->local.inline_summary;\n+}\n+\n /* Estimate size of the function after inlining WHAT into TO.  */\n \n static int\n@@ -226,8 +232,10 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate, bool update_o\n   else\n     e->callee->global.inlined_to = e->caller;\n   e->callee->global.stack_frame_offset\n-    = e->caller->global.stack_frame_offset + e->caller->local.estimated_self_stack_size;\n-  peak = e->callee->global.stack_frame_offset + e->callee->local.estimated_self_stack_size;\n+    = e->caller->global.stack_frame_offset\n+      + inline_summary (e->caller)->estimated_self_stack_size;\n+  peak = e->callee->global.stack_frame_offset\n+      + inline_summary (e->callee)->estimated_self_stack_size;\n   if (e->callee->global.inlined_to->global.estimated_stack_size < peak)\n     e->callee->global.inlined_to->global.estimated_stack_size = peak;\n \n@@ -359,10 +367,10 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n \n   /* When inlining large function body called once into small function,\n      take the inlined function as base for limiting the growth.  */\n-  if (to->local.self_insns > what->local.self_insns)\n-    limit = to->local.self_insns;\n+  if (inline_summary (to)->self_insns > inline_summary(what)->self_insns)\n+    limit = inline_summary (to)->self_insns;\n   else\n-    limit = what->local.self_insns;\n+    limit = inline_summary (what)->self_insns;\n \n   limit += limit * PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH) / 100;\n \n@@ -378,12 +386,12 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n       return false;\n     }\n \n-  stack_size_limit = to->local.estimated_self_stack_size;\n+  stack_size_limit = inline_summary (to)->estimated_self_stack_size;\n \n   stack_size_limit += stack_size_limit * PARAM_VALUE (PARAM_STACK_FRAME_GROWTH) / 100;\n \n   inlined_stack = (to->global.stack_frame_offset\n-\t\t   + to->local.estimated_self_stack_size\n+\t\t   + inline_summary (to)->estimated_self_stack_size\n \t\t   + what->global.estimated_stack_size);\n   if (inlined_stack  > stack_size_limit\n       && inlined_stack > PARAM_VALUE (PARAM_LARGE_STACK_FRAME))\n@@ -1036,8 +1044,8 @@ cgraph_decide_inlining (void)\n       {\n \tstruct cgraph_edge *e;\n \n-\tinitial_insns += node->local.self_insns;\n-\tgcc_assert (node->local.self_insns == node->global.insns);\n+\tinitial_insns += inline_summary (node)->self_insns;\n+\tgcc_assert (inline_summary (node)->self_insns == node->global.insns);\n \tfor (e = node->callees; e; e = e->next_callee)\n \t  if (max_count < e->count)\n \t    max_count = e->count;\n@@ -1517,19 +1525,21 @@ compute_inline_parameters (void)\n   struct cgraph_node *node = cgraph_node (current_function_decl);\n \n   gcc_assert (!node->global.inlined_to);\n-  node->local.estimated_self_stack_size = estimated_stack_frame_size ();\n-  node->global.estimated_stack_size = node->local.estimated_self_stack_size;\n+  inline_summary (node)->estimated_self_stack_size\n+    = estimated_stack_frame_size ();\n+  node->global.estimated_stack_size\n+    = inline_summary (node)->estimated_self_stack_size;\n   node->global.stack_frame_offset = 0;\n   node->local.inlinable = tree_inlinable_function_p (current_function_decl);\n-  node->local.self_insns = estimate_num_insns (current_function_decl,\n-\t\t\t\t\t       &eni_inlining_weights);\n+  inline_summary (node)->self_insns = estimate_num_insns (current_function_decl,\n+\t\t\t\t\t                  &eni_inlining_weights);\n   if (node->local.inlinable && !node->local.disregard_inline_limits)\n     node->local.disregard_inline_limits\n       = DECL_DISREGARD_INLINE_LIMITS (current_function_decl);\n   if (flag_really_no_inline && !node->local.disregard_inline_limits)\n     node->local.inlinable = 0;\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n-  node->global.insns = node->local.self_insns;\n+  node->global.insns = inline_summary (node)->self_insns;\n   return 0;\n }\n "}, {"sha": "06f838cb07d4bfbfaa5aa6d23009e17794ff28cf", "filename": "gcc/ipa.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=9562228040b6fc80870b2d7bd60d67af7870390e", "patch": "@@ -100,7 +100,6 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   struct cgraph_node *first = (struct cgraph_node *) (void *) 1;\n   struct cgraph_node *node, *next;\n   bool changed = false;\n-  int insns = 0;\n \n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n@@ -157,14 +156,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       next = node->next;\n       if (!node->aux)\n \t{\n-\t  int local_insns;\n-\t  tree decl = node->decl;\n-\n           node->global.inlined_to = NULL;\n-\t  if (DECL_STRUCT_FUNCTION (decl))\n-\t    local_insns = node->local.self_insns;\n-\t  else\n-\t    local_insns = 0;\n \t  if (file)\n \t    fprintf (file, \" %s\", cgraph_node_name (node));\n \t  if (!node->analyzed || !DECL_EXTERNAL (node->decl)\n@@ -197,15 +189,11 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      else\n \t\tcgraph_remove_node (node);\n \t    }\n-\t  if (!DECL_SAVED_TREE (decl))\n-\t    insns += local_insns;\n \t  changed = true;\n \t}\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;\n-  if (file)\n-    fprintf (file, \"\\nReclaimed %i insns\", insns);\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif"}, {"sha": "8830c442e51c811f7e9c67a682d0ce0d9fd457f9", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9562228040b6fc80870b2d7bd60d67af7870390e/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=9562228040b6fc80870b2d7bd60d67af7870390e", "patch": "@@ -384,11 +384,11 @@ extern struct gimple_opt_pass pass_reset_cc_flags;\n \n /* IPA Passes */\n extern struct ipa_opt_pass pass_ipa_inline;\n+extern struct simple_ipa_opt_pass pass_ipa_reference;\n \n extern struct simple_ipa_opt_pass pass_ipa_matrix_reorg;\n extern struct simple_ipa_opt_pass pass_ipa_cp;\n extern struct simple_ipa_opt_pass pass_ipa_early_inline;\n-extern struct simple_ipa_opt_pass pass_ipa_reference;\n extern struct simple_ipa_opt_pass pass_ipa_pure_const;\n extern struct simple_ipa_opt_pass pass_ipa_type_escape;\n extern struct simple_ipa_opt_pass pass_ipa_pta;"}]}