{"sha": "22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJmY2E0ODllYWY5OGYyNjkxNzcyYjUxNzczYTFlNGViN2JiNGVmMg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-08-26T18:29:45Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-08-26T18:29:45Z"}, "message": "PR tree-optimization/83431 - -Wformat-truncation may incorrectly report truncation\n\ngcc/ChangeLog:\n\n\tPR c++/83431\n\t* gimple-ssa-sprintf.c (pass_data_sprintf_length): Remove object.\n\t(sprintf_dom_walker): Remove class.\n\t(get_int_range): Make argument const.\n\t(directive::fmtfunc, directive::set_precision): Same.\n\t(format_none): Same.\n\t(build_intmax_type_nodes): Same.\n\t(adjust_range_for_overflow): Same.\n\t(format_floating): Same.\n\t(format_character): Same.\n\t(format_string): Same.\n\t(format_plain): Same.\n\t(get_int_range): Cast away constness.\n\t(format_integer): Same.\n\t(get_string_length): Call get_range_strlen_dynamic.  Handle\n\tnull lendata.maxbound.\n\t(should_warn_p): Adjust argument scope qualifier.\n\t(maybe_warn): Same.\n\t(format_directive): Same.\n\t(parse_directive): Same.\n\t(is_call_safe): Same.\n\t(try_substitute_return_value): Same.\n\t(sprintf_dom_walker::handle_printf_call): Rename...\n\t(handle_printf_call): ...to this.  Initialize target to host charmap\n\there instead of in pass_sprintf_length::execute.\n\t(struct call_info): Make global.\n\t(sprintf_dom_walker::compute_format_length): Make global.\n\t(sprintf_dom_walker::handle_gimple_call): Same.\n\t* passes.def (pass_sprintf_length): Replace with pass_strlen.\n\t* print-rtl.c (print_pattern): Reduce the number of spaces to\n\tavoid -Wformat-truncation.\n\t* tree-pass.h (make_pass_warn_printf): New function.\n\t* tree-ssa-strlen.c (strlen_optimize): New variable.\n\t(get_string_length): Add comments.\n\t(get_range_strlen_dynamic): New function.\n\t(check_and_optimize_call): New function.\n\t(handle_integral_assign): New function.\n\t(strlen_check_and_optimize_stmt): Factor code out into\n\tstrlen_check_and_optimize_call and handle_integral_assign.\n\t(strlen_dom_walker::evrp): New member.\n\t(strlen_dom_walker::before_dom_children): Use evrp member.\n\t(strlen_dom_walker::after_dom_children): Use evrp member.\n\t(printf_strlen_execute): New function.\n\t(pass_strlen::gate): Update to handle printf calls.\n\t(dump_strlen_info): New function.\n\t(pass_data_warn_printf): New variable.\n\t(pass_warn_printf): New class.\n\t* tree-ssa-strlen.h (get_range_strlen_dynamic): Declare.\n\t(handle_printf_call): Same.\n\t* tree-vrp.c (value_range_base::type): Adjust assertion.\n\t* vr-values.c (vr_values::update_value_range): Use type of the first\n\targument rather than the second.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/83431\n\t* gcc.dg/strlenopt-63.c: New test.\n\t* gcc.dg/pr79538.c: Adjust text of expected warning.\n\t* gcc.dg/pr81292-1.c: Adjust pass name.\n\t* gcc.dg/pr81292-2.c: Same.\n\t* gcc.dg/pr81703.c: Same.\n\t* gcc.dg/strcmpopt_2.c: Same.\n\t* gcc.dg/strcmpopt_3.c: Same.\n\t* gcc.dg/strcmpopt_4.c: Same.\n\t* gcc.dg/strlenopt-1.c: Same.\n\t* gcc.dg/strlenopt-10.c: Same.\n\t* gcc.dg/strlenopt-11.c: Same.\n\t* gcc.dg/strlenopt-13.c: Same.\n\t* gcc.dg/strlenopt-14g.c: Same.\n\t* gcc.dg/strlenopt-14gf.c: Same.\n\t* gcc.dg/strlenopt-15.c: Same.\n\t* gcc.dg/strlenopt-16g.c: Same.\n\t* gcc.dg/strlenopt-17g.c: Same.\n\t* gcc.dg/strlenopt-18g.c: Same.\n\t* gcc.dg/strlenopt-19.c: Same.\n\t* gcc.dg/strlenopt-1f.c: Same.\n\t* gcc.dg/strlenopt-2.c: Same.\n\t* gcc.dg/strlenopt-20.c: Same.\n\t* gcc.dg/strlenopt-21.c: Same.\n\t* gcc.dg/strlenopt-22.c: Same.\n\t* gcc.dg/strlenopt-22g.c: Same.\n\t* gcc.dg/strlenopt-24.c: Same.\n\t* gcc.dg/strlenopt-25.c: Same.\n\t* gcc.dg/strlenopt-26.c: Same.\n\t* gcc.dg/strlenopt-27.c: Same.\n\t* gcc.dg/strlenopt-28.c: Same.\n\t* gcc.dg/strlenopt-29.c: Same.\n\t* gcc.dg/strlenopt-2f.c: Same.\n\t* gcc.dg/strlenopt-3.c: Same.\n\t* gcc.dg/strlenopt-30.c: Same.\n\t* gcc.dg/strlenopt-31g.c: Same.\n\t* gcc.dg/strlenopt-32.c: Same.\n\t* gcc.dg/strlenopt-33.c: Same.\n\t* gcc.dg/strlenopt-33g.c: Same.\n\t* gcc.dg/strlenopt-34.c: Same.\n\t* gcc.dg/strlenopt-35.c: Same.\n\t* gcc.dg/strlenopt-4.c: Same.\n\t* gcc.dg/strlenopt-48.c: Same.\n\t* gcc.dg/strlenopt-49.c: Same.\n\t* gcc.dg/strlenopt-4g.c: Same.\n\t* gcc.dg/strlenopt-4gf.c: Same.\n\t* gcc.dg/strlenopt-5.c: Same.\n\t* gcc.dg/strlenopt-50.c: Same.\n\t* gcc.dg/strlenopt-51.c: Same.\n\t* gcc.dg/strlenopt-52.c: Same.\n\t* gcc.dg/strlenopt-53.c: Same.\n\t* gcc.dg/strlenopt-54.c: Same.\n\t* gcc.dg/strlenopt-55.c: Same.\n\t* gcc.dg/strlenopt-56.c: Same.\n\t* gcc.dg/strlenopt-6.c: Same.\n\t* gcc.dg/strlenopt-61.c: Same.\n\t* gcc.dg/strlenopt-7.c: Same.\n\t* gcc.dg/strlenopt-8.c: Same.\n\t* gcc.dg/strlenopt-9.c: Same.\n\t* gcc.dg/strlenopt.h (snprintf, snprintf): Declare.\n\t* gcc.dg/tree-ssa/builtin-snprintf-6.c: New test.\n\t* gcc.dg/tree-ssa/builtin-snprintf-7.c: New test.\n\t* gcc.dg/tree-ssa/builtin-snprintf-8.c: New test.\n\t* gcc.dg/tree-ssa/builtin-snprintf-9.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-21.c: New test.\n\t* gcc.dg/tree-ssa/dump-4.c: New test.\n\t* gcc.dg/tree-ssa/pr83501.c: Adjust pass name.\n\nFrom-SVN: r274933", "tree": {"sha": "268157065335369b092a662c434f7753bb19eb7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/268157065335369b092a662c434f7753bb19eb7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59bce4ad03e438e81dcaa8ed956fbad6461c7d75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bce4ad03e438e81dcaa8ed956fbad6461c7d75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59bce4ad03e438e81dcaa8ed956fbad6461c7d75"}], "stats": {"total": 2895, "additions": 2264, "deletions": 631}, "files": [{"sha": "852382efcb52d5efcba8bc996dedd9cd9da64756", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -1,3 +1,58 @@\n+2019-08-23  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83431\n+\t* gimple-ssa-sprintf.c (pass_data_sprintf_length): Remove object.\n+\t(sprintf_dom_walker): Remove class.\n+\t(get_int_range): Make argument const.\n+\t(directive::fmtfunc, directive::set_precision): Same.\n+\t(format_none): Same.\n+\t(build_intmax_type_nodes): Same.\n+\t(adjust_range_for_overflow): Same.\n+\t(format_floating): Same.\n+\t(format_character): Same.\n+\t(format_string): Same.\n+\t(format_plain): Same.\n+\t(get_int_range): Cast away constness.\n+\t(format_integer): Same.\n+\t(get_string_length): Call get_range_strlen_dynamic.  Handle\n+\tnull lendata.maxbound.\n+\t(should_warn_p): Adjust argument scope qualifier.\n+\t(maybe_warn): Same.\n+\t(format_directive): Same.\n+\t(parse_directive): Same.\n+\t(is_call_safe): Same.\n+\t(try_substitute_return_value): Same.\n+\t(sprintf_dom_walker::handle_printf_call): Rename...\n+\t(handle_printf_call): ...to this.  Initialize target to host charmap\n+\there instead of in pass_sprintf_length::execute.\n+\t(struct call_info): Make global.\n+\t(sprintf_dom_walker::compute_format_length): Make global.\n+\t(sprintf_dom_walker::handle_gimple_call): Same.\n+\t* passes.def (pass_sprintf_length): Replace with pass_strlen.\n+\t* print-rtl.c (print_pattern): Reduce the number of spaces to\n+\tavoid -Wformat-truncation.\n+\t* tree-pass.h (make_pass_warn_printf): New function.\n+\t* tree-ssa-strlen.c (strlen_optimize): New variable.\n+\t(get_string_length): Add comments.\n+\t(get_range_strlen_dynamic): New function.\n+\t(check_and_optimize_call): New function.\n+\t(handle_integral_assign): New function.\n+\t(strlen_check_and_optimize_stmt): Factor code out into\n+\tstrlen_check_and_optimize_call and handle_integral_assign.\n+\t(strlen_dom_walker::evrp): New member.\n+\t(strlen_dom_walker::before_dom_children): Use evrp member.\n+\t(strlen_dom_walker::after_dom_children): Use evrp member.\n+\t(printf_strlen_execute): New function.\n+\t(pass_strlen::gate): Update to handle printf calls.\n+\t(dump_strlen_info): New function.\n+\t(pass_data_warn_printf): New variable.\n+\t(pass_warn_printf): New class.\n+\t* tree-ssa-strlen.h (get_range_strlen_dynamic): Declare.\n+\t(handle_printf_call): Same.\n+\t* tree-vrp.c (value_range_base::type): Adjust assertion.\n+\t* vr-values.c (vr_values::update_value_range): Use type of the first\n+\targument rather than the second.\n+\n 2019-08-26  Richard Biener  <rguenther@suse.de>\n \n \t* config/i386/i386-features.c (general_remove_non_convertible_regs):"}, {"sha": "6a39a71900a05d264b7e854e4243cd3b88df89ec", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 75, "deletions": 188, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -85,7 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"alloc-pool.h\"\n #include \"vr-values.h\"\n-#include \"gimple-ssa-evrp-analyze.h\"\n+#include \"tree-ssa-strlen.h\"\n \n /* The likely worst case value of MB_LEN_MAX for the target, large enough\n    for UTF-8.  Ideally, this would be obtained by a target hook if it were\n@@ -100,80 +100,15 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace {\n \n-const pass_data pass_data_sprintf_length = {\n-  GIMPLE_PASS,             // pass type\n-  \"printf-return-value\",   // pass name\n-  OPTGROUP_NONE,           // optinfo_flags\n-  TV_NONE,                 // tv_id\n-  PROP_cfg,                // properties_required\n-  0,\t                   // properties_provided\n-  0,\t                   // properties_destroyed\n-  0,\t                   // properties_start\n-  0,\t                   // properties_finish\n-};\n-\n /* Set to the warning level for the current function which is equal\n    either to warn_format_trunc for bounded functions or to\n    warn_format_overflow otherwise.  */\n \n static int warn_level;\n \n+struct call_info;\n struct format_result;\n \n-class sprintf_dom_walker : public dom_walker\n-{\n- public:\n-  sprintf_dom_walker ()\n-    : dom_walker (CDI_DOMINATORS),\n-      evrp_range_analyzer (false) {}\n-  ~sprintf_dom_walker () {}\n-\n-  edge before_dom_children (basic_block) FINAL OVERRIDE;\n-  void after_dom_children (basic_block) FINAL OVERRIDE;\n-  bool handle_gimple_call (gimple_stmt_iterator *);\n-\n-  struct call_info;\n-  bool compute_format_length (call_info &, format_result *);\n-  class evrp_range_analyzer evrp_range_analyzer;\n-};\n-\n-class pass_sprintf_length : public gimple_opt_pass\n-{\n-  bool fold_return_value;\n-\n-public:\n-  pass_sprintf_length (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_sprintf_length, ctxt),\n-    fold_return_value (false)\n-  { }\n-\n-  opt_pass * clone () { return new pass_sprintf_length (m_ctxt); }\n-\n-  virtual bool gate (function *);\n-\n-  virtual unsigned int execute (function *);\n-\n-  void set_pass_param (unsigned int n, bool param)\n-    {\n-      gcc_assert (n == 0);\n-      fold_return_value = param;\n-    }\n-\n-};\n-\n-bool\n-pass_sprintf_length::gate (function *)\n-{\n-  /* Run the pass iff -Warn-format-overflow or -Warn-format-truncation\n-     is specified and either not optimizing and the pass is being invoked\n-     early, or when optimizing and the pass is being invoked during\n-     optimization (i.e., \"late\").  */\n-  return ((warn_format_overflow > 0\n-\t   || warn_format_trunc > 0\n-\t   || flag_printf_return_value)\n-\t  && (optimize > 0) == fold_return_value);\n-}\n-\n /* The minimum, maximum, likely, and unlikely maximum number of bytes\n    of output either a formatting function or an individual directive\n    can result in.  */\n@@ -684,7 +619,7 @@ fmtresult::type_max_digits (tree type, int base)\n \n static bool\n get_int_range (tree, HOST_WIDE_INT *, HOST_WIDE_INT *, bool, HOST_WIDE_INT,\n-\t       class vr_values *vr_values);\n+\t       const vr_values *);\n \n /* Description of a format directive.  A directive is either a plain\n    string or a conversion specification that starts with '%'.  */\n@@ -719,7 +654,7 @@ struct directive\n \n   /* Format conversion function that given a directive and an argument\n      returns the formatting result.  */\n-  fmtresult (*fmtfunc) (const directive &, tree, vr_values *);\n+  fmtresult (*fmtfunc) (const directive &, tree, const vr_values *);\n \n   /* Return True when a the format flag CHR has been used.  */\n   bool get_flag (char chr) const\n@@ -756,9 +691,9 @@ struct directive\n      or 0, whichever is greater.  For a non-constant ARG in some range\n      set width to its range adjusting each bound to -1 if it's less.\n      For an indeterminate ARG set width to [0, INT_MAX].  */\n-  void set_width (tree arg, vr_values *vr_values)\n+  void set_width (tree arg, const vr_values *vr)\n   {\n-    get_int_range (arg, width, width + 1, true, 0, vr_values);\n+    get_int_range (arg, width, width + 1, true, 0, vr);\n   }\n \n   /* Set both bounds of the precision range to VAL.  */\n@@ -772,9 +707,9 @@ struct directive\n      or -1 whichever is greater.  For a non-constant ARG in some range\n      set precision to its range adjusting each bound to -1 if it's less.\n      For an indeterminate ARG set precision to [-1, INT_MAX].  */\n-  void set_precision (tree arg, vr_values *vr_values)\n+  void set_precision (tree arg, const vr_values *vr)\n   {\n-    get_int_range (arg, prec, prec + 1, false, -1, vr_values);\n+    get_int_range (arg, prec, prec + 1, false, -1, vr);\n   }\n \n   /* Return true if both width and precision are known to be\n@@ -904,7 +839,7 @@ bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n \n /* Description of a call to a formatted function.  */\n \n-struct sprintf_dom_walker::call_info\n+struct call_info\n {\n   /* Function call statement.  */\n   gimple *callstmt;\n@@ -978,7 +913,7 @@ struct sprintf_dom_walker::call_info\n /* Return the result of formatting a no-op directive (such as '%n').  */\n \n static fmtresult\n-format_none (const directive &, tree, vr_values *)\n+format_none (const directive &, tree, const vr_values *)\n {\n   fmtresult res (0);\n   return res;\n@@ -987,7 +922,7 @@ format_none (const directive &, tree, vr_values *)\n /* Return the result of formatting the '%%' directive.  */\n \n static fmtresult\n-format_percent (const directive &, tree, vr_values *)\n+format_percent (const directive &, tree, const vr_values *)\n {\n   fmtresult res (1);\n   return res;\n@@ -1047,7 +982,7 @@ build_intmax_type_nodes (tree *pintmax, tree *puintmax)\n static bool\n get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t       bool absolute, HOST_WIDE_INT negbound,\n-\t       class vr_values *vr_values)\n+\t       const class vr_values *vr_values)\n {\n   /* The type of the result.  */\n   const_tree type = integer_type_node;\n@@ -1086,7 +1021,9 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t  && TYPE_PRECISION (argtype) <= TYPE_PRECISION (type))\n \t{\n \t  /* Try to determine the range of values of the integer argument.  */\n-\t  const value_range *vr = vr_values->get_value_range (arg);\n+\t  const value_range *vr\n+\t    = CONST_CAST (class vr_values *, vr_values)->get_value_range (arg);\n+\n \t  if (range_int_cst_p (vr))\n \t    {\n \t      HOST_WIDE_INT type_min\n@@ -1203,7 +1140,7 @@ adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n    used when the directive argument or its value isn't known.  */\n \n static fmtresult\n-format_integer (const directive &dir, tree arg, vr_values *vr_values)\n+format_integer (const directive &dir, tree arg, const vr_values *vr_values)\n {\n   tree intmax_type_node;\n   tree uintmax_type_node;\n@@ -1386,7 +1323,9 @@ format_integer (const directive &dir, tree arg, vr_values *vr_values)\n     {\n       /* Try to determine the range of values of the integer argument\n \t (range information is not available for pointers).  */\n-      const value_range *vr = vr_values->get_value_range (arg);\n+      const value_range *vr\n+\t= CONST_CAST (class vr_values *, vr_values)->get_value_range (arg);\n+\n       if (range_int_cst_p (vr))\n \t{\n \t  argmin = vr->min ();\n@@ -1836,7 +1775,7 @@ format_floating (const directive &dir, const HOST_WIDE_INT prec[2])\n    ARG.  */\n \n static fmtresult\n-format_floating (const directive &dir, tree arg, vr_values *)\n+format_floating (const directive &dir, tree arg, const vr_values *)\n {\n   HOST_WIDE_INT prec[] = { dir.prec[0], dir.prec[1] };\n   tree type = (dir.modifier == FMT_LEN_L || dir.modifier == FMT_LEN_ll\n@@ -2030,21 +1969,33 @@ format_floating (const directive &dir, tree arg, vr_values *)\n    Used by the format_string function below.  */\n \n static fmtresult\n-get_string_length (tree str, unsigned eltsize)\n+get_string_length (tree str, unsigned eltsize, const vr_values *vr)\n {\n   if (!str)\n     return fmtresult ();\n \n-  /* Determine the length of the shortest and longest string referenced\n-     by STR.  Strings of unknown lengths are bounded by the sizes of\n-     arrays that subexpressions of STR may refer to.  Pointers that\n-     aren't known to point any such arrays result in LENDATA.MAXLEN\n-     set to SIZE_MAX.  */\n+  /* Try to determine the dynamic string length first.  */\n   c_strlen_data lendata = { };\n-  get_range_strlen (str, &lendata, eltsize);\n+  if (eltsize == 1)\n+    get_range_strlen_dynamic (str, &lendata, vr);\n+  else\n+    {\n+      /* Determine the length of the shortest and longest string referenced\n+\t by STR.  Strings of unknown lengths are bounded by the sizes of\n+\t arrays that subexpressions of STR may refer to.  Pointers that\n+\t aren't known to point any such arrays result in LENDATA.MAXLEN\n+\t set to SIZE_MAX.  */\n+      get_range_strlen (str, &lendata, eltsize);\n+    }\n+\n+  /* LENDATA.MAXBOUND is null when LENDATA.MIN corresponds to the shortest\n+     string referenced by STR.  Otherwise, if it's not equal to .MINLEN it\n+     corresponds to the bound of the largest array STR refers to, if known,\n+     or it's SIZE_MAX otherwise.  */\n \n-  /* Return the default result when nothing is known about the string. */\n-  if (integer_all_onesp (lendata.maxbound)\n+  /* Return the default result when nothing is known about the string.  */\n+  if (lendata.maxbound\n+      && integer_all_onesp (lendata.maxbound)\n       && integer_all_onesp (lendata.maxlen))\n     return fmtresult ();\n \n@@ -2054,7 +2005,7 @@ get_string_length (tree str, unsigned eltsize)\n        : 0);\n \n   HOST_WIDE_INT max\n-    = (tree_fits_uhwi_p (lendata.maxbound)\n+    = (lendata.maxbound && tree_fits_uhwi_p (lendata.maxbound)\n        ? tree_to_uhwi (lendata.maxbound)\n        : HOST_WIDE_INT_M1U);\n \n@@ -2093,10 +2044,11 @@ get_string_length (tree str, unsigned eltsize)\n   else\n     {\n       /* When the upper bound is unknown (it can be zero or excessive)\n-\t set the likely length to the greater of 1 and the length of\n-\t the shortest string and reset the lower bound to zero.  */\n+\t set the likely length to the greater of 1.  If MAXBOUND is\n+\t set, also reset the length of the lower bound to zero.  */\n       res.range.likely = res.range.min ? res.range.min : warn_level > 1;\n-      res.range.min = 0;\n+      if (lendata.maxbound)\n+\tres.range.min = 0;\n     }\n \n   res.range.unlikely = unbounded ? HOST_WIDE_INT_MAX : res.range.max;\n@@ -2110,7 +2062,7 @@ get_string_length (tree str, unsigned eltsize)\n    vsprinf).  */\n \n static fmtresult\n-format_character (const directive &dir, tree arg, vr_values *vr_values)\n+format_character (const directive &dir, tree arg, const vr_values *vr_values)\n {\n   fmtresult res;\n \n@@ -2186,7 +2138,7 @@ format_character (const directive &dir, tree arg, vr_values *vr_values)\n    vsprinf).  */\n \n static fmtresult\n-format_string (const directive &dir, tree arg, vr_values *)\n+format_string (const directive &dir, tree arg, const vr_values *vr_values)\n {\n   fmtresult res;\n \n@@ -2204,7 +2156,7 @@ format_string (const directive &dir, tree arg, vr_values *)\n       gcc_checking_assert (count_by == 2 || count_by == 4);\n     }\n \n-  fmtresult slen = get_string_length (arg, count_by);\n+  fmtresult slen = get_string_length (arg, count_by, vr_values);\n   if (slen.range.min == slen.range.max\n       && slen.range.min < HOST_WIDE_INT_MAX)\n     {\n@@ -2376,7 +2328,7 @@ format_string (const directive &dir, tree arg, vr_values *)\n /* Format plain string (part of the format string itself).  */\n \n static fmtresult\n-format_plain (const directive &dir, tree, vr_values *)\n+format_plain (const directive &dir, tree, const vr_values *)\n {\n   fmtresult res (dir.len);\n   return res;\n@@ -2386,7 +2338,7 @@ format_plain (const directive &dir, tree, vr_values *)\n    should be diagnosed given the AVAILable space in the destination.  */\n \n static bool\n-should_warn_p (const sprintf_dom_walker::call_info &info,\n+should_warn_p (const call_info &info,\n \t       const result_range &avail, const result_range &result)\n {\n   if (result.max <= avail.min)\n@@ -2457,7 +2409,7 @@ should_warn_p (const sprintf_dom_walker::call_info &info,\n \n static bool\n maybe_warn (substring_loc &dirloc, location_t argloc,\n-\t    const sprintf_dom_walker::call_info &info,\n+\t    const call_info &info,\n \t    const result_range &avail_range, const result_range &res,\n \t    const directive &dir)\n {\n@@ -2737,9 +2689,9 @@ maybe_warn (substring_loc &dirloc, location_t argloc,\n    in *RES.  Return true if the directive has been handled.  */\n \n static bool\n-format_directive (const sprintf_dom_walker::call_info &info,\n+format_directive (const call_info &info,\n \t\t  format_result *res, const directive &dir,\n-\t\t  class vr_values *vr_values)\n+\t\t  const class vr_values *vr_values)\n {\n   /* Offset of the beginning of the directive from the beginning\n      of the format string.  */\n@@ -3086,10 +3038,10 @@ format_directive (const sprintf_dom_walker::call_info &info,\n    the directive.  */\n \n static size_t\n-parse_directive (sprintf_dom_walker::call_info &info,\n+parse_directive (call_info &info,\n \t\t directive &dir, format_result *res,\n \t\t const char *str, unsigned *argno,\n-\t\t vr_values *vr_values)\n+\t\t const vr_values *vr_values)\n {\n   const char *pcnt = strchr (str, target_percent);\n   dir.beg = str;\n@@ -3526,9 +3478,8 @@ parse_directive (sprintf_dom_walker::call_info &info,\n    on, false otherwise (e.g., when a unknown or unhandled directive was seen\n    that caused the processing to be terminated early).  */\n \n-bool\n-sprintf_dom_walker::compute_format_length (call_info &info,\n-\t\t\t\t\t   format_result *res)\n+static bool\n+compute_format_length (call_info &info, format_result *res, const vr_values *vr)\n {\n   if (dump_file)\n     {\n@@ -3564,12 +3515,10 @@ sprintf_dom_walker::compute_format_length (call_info &info,\n       directive dir = directive ();\n       dir.dirno = dirno;\n \n-      size_t n = parse_directive (info, dir, res, pf, &argno,\n-\t\t\t\t  evrp_range_analyzer.get_vr_values ());\n+      size_t n = parse_directive (info, dir, res, pf, &argno, vr);\n \n       /* Return failure if the format function fails.  */\n-      if (!format_directive (info, res, dir,\n-\t\t\t     evrp_range_analyzer.get_vr_values ()))\n+      if (!format_directive (info, res, dir, vr))\n \treturn false;\n \n       /* Return success the directive is zero bytes long and it's\n@@ -3617,7 +3566,7 @@ get_destination_size (tree dest)\n    of its return values.  */\n \n static bool\n-is_call_safe (const sprintf_dom_walker::call_info &info,\n+is_call_safe (const call_info &info,\n \t      const format_result &res, bool under4k,\n \t      unsigned HOST_WIDE_INT retval[2])\n {\n@@ -3676,7 +3625,7 @@ is_call_safe (const sprintf_dom_walker::call_info &info,\n \n static bool\n try_substitute_return_value (gimple_stmt_iterator *gsi,\n-\t\t\t     const sprintf_dom_walker::call_info &info,\n+\t\t\t     const call_info &info,\n \t\t\t     const format_result &res)\n {\n   tree lhs = gimple_get_lhs (info.callstmt);\n@@ -3794,7 +3743,7 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n \n static bool\n try_simplify_call (gimple_stmt_iterator *gsi,\n-\t\t   const sprintf_dom_walker::call_info &info,\n+\t\t   const call_info &info,\n \t\t   const format_result &res)\n {\n   unsigned HOST_WIDE_INT dummy[2];\n@@ -3847,13 +3796,17 @@ get_user_idx_format (tree fndecl, unsigned *idx_args)\n   return tree_to_uhwi (fmtarg) - 1;\n }\n \n-/* Determine if a GIMPLE CALL is to one of the sprintf-like built-in\n-   functions and if so, handle it.  Return true if the call is removed\n-   and gsi_next should not be performed in the caller.  */\n+}   /* Unnamed namespace.  */\n+\n+/* Determine if a GIMPLE call at *GSI is to one of the sprintf-like built-in\n+   functions and if so, handle it.  Return true if the call is removed and\n+   gsi_next should not be performed in the caller.  */\n \n bool\n-sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n+handle_printf_call (gimple_stmt_iterator *gsi, const vr_values *vr_values)\n {\n+  init_target_to_host_charmap ();\n+\n   call_info info = call_info ();\n \n   info.callstmt = gsi_stmt (*gsi);\n@@ -4119,7 +4072,9 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t  /* Try to determine the range of values of the argument\n \t     and use the greater of the two at level 1 and the smaller\n \t     of them at level 2.  */\n-\t  const value_range *vr = evrp_range_analyzer.get_value_range (size);\n+\t  const value_range *vr\n+\t    = CONST_CAST (class vr_values *, vr_values)->get_value_range (size);\n+\n \t  if (range_int_cst_p (vr))\n \t    {\n \t      unsigned HOST_WIDE_INT minsize = TREE_INT_CST_LOW (vr->min ());\n@@ -4230,7 +4185,7 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n      never set to true again).  */\n   res.posunder4k = posunder4k && dstptr;\n \n-  bool success = compute_format_length (info, &res);\n+  bool success = compute_format_length (info, &res, vr_values);\n   if (res.warned)\n     gimple_set_no_warning (info.callstmt, true);\n \n@@ -4256,71 +4211,3 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n \n   return call_removed;\n }\n-\n-edge\n-sprintf_dom_walker::before_dom_children (basic_block bb)\n-{\n-  evrp_range_analyzer.enter (bb);\n-  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si); )\n-    {\n-      /* Iterate over statements, looking for function calls.  */\n-      gimple *stmt = gsi_stmt (si);\n-\n-      /* First record ranges generated by this statement.  */\n-      evrp_range_analyzer.record_ranges_from_stmt (stmt, false);\n-\n-      if (is_gimple_call (stmt) && handle_gimple_call (&si))\n-\t/* If handle_gimple_call returns true, the iterator is\n-\t   already pointing to the next statement.  */\n-\tcontinue;\n-\n-      gsi_next (&si);\n-    }\n-  return NULL;\n-}\n-\n-void\n-sprintf_dom_walker::after_dom_children (basic_block bb)\n-{\n-  evrp_range_analyzer.leave (bb);\n-}\n-\n-/* Execute the pass for function FUN.  */\n-\n-unsigned int\n-pass_sprintf_length::execute (function *fun)\n-{\n-  init_target_to_host_charmap ();\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  bool use_scev = optimize > 0 && flag_printf_return_value;\n-  if (use_scev)\n-    {\n-      loop_optimizer_init (LOOPS_NORMAL);\n-      scev_initialize ();\n-    }\n-\n-  sprintf_dom_walker sprintf_dom_walker;\n-  sprintf_dom_walker.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n-\n-  if (use_scev)\n-    {\n-      scev_finalize ();\n-      loop_optimizer_finalize ();\n-    }\n-\n-  /* Clean up object size info.  */\n-  fini_object_sizes ();\n-  return 0;\n-}\n-\n-}   /* Unnamed namespace.  */\n-\n-/* Return a pointer to a pass object newly constructed from the context\n-   CTXT.  */\n-\n-gimple_opt_pass *\n-make_pass_sprintf_length (gcc::context *ctxt)\n-{\n-  return new pass_sprintf_length (ctxt);\n-}"}, {"sha": "e50cf62657c8797848fa7c9ae838a5f3f1d1e44c", "filename": "gcc/passes.def", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_build_cfg);\n   NEXT_PASS (pass_warn_function_return);\n   NEXT_PASS (pass_expand_omp);\n-  NEXT_PASS (pass_sprintf_length, false);\n+  NEXT_PASS (pass_warn_printf);\n   NEXT_PASS (pass_walloca, /*strict_mode_p=*/true);\n   NEXT_PASS (pass_build_cgraph_edges);\n   TERMINATE_PASS_LIST (all_lowering_passes)\n@@ -307,7 +307,6 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_lower_vector_ssa);\n       NEXT_PASS (pass_lower_switch);\n       NEXT_PASS (pass_cse_reciprocals);\n-      NEXT_PASS (pass_sprintf_length, true);\n       NEXT_PASS (pass_reassoc, false /* insert_powi_p */);\n       NEXT_PASS (pass_strength_reduction);\n       NEXT_PASS (pass_split_paths);\n@@ -358,7 +357,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_object_sizes);\n       /* Fold remaining builtins.  */\n       NEXT_PASS (pass_fold_builtins);\n-      NEXT_PASS (pass_sprintf_length, true);\n+      NEXT_PASS (pass_strlen);\n       /* Copy propagation also copy-propagates constants, this is necessary\n          to forward object-size and builtin folding results properly.  */\n       NEXT_PASS (pass_copy_prop);"}, {"sha": "b96ab5e0544aa717d87428451ca5975cf4aba2d2", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -1815,7 +1815,7 @@ print_pattern (pretty_printer *pp, const_rtx x, int verbose)\n \t    gcc_assert (strlen (print_rtx_head) < sizeof (indented_print_rtx_head) - 4);\n \t    snprintf (indented_print_rtx_head,\n \t\t      sizeof (indented_print_rtx_head),\n-\t\t      \"%s     \", print_rtx_head);\n+\t\t      \"%s    \", print_rtx_head);\n \t    print_rtx_head = indented_print_rtx_head;\n \t    for (int i = 0; i < seq->len (); i++)\n \t      print_insn_with_notes (pp, seq->insn (i));"}, {"sha": "9bdc2f9b0fb20787ec5e807f206c03cd92e3475f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -77,6 +77,76 @@\n \n \t* gcc.target/mips/get-fcsr-3.c: New test.\n \n+2019-08-23  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83431\n+\t* gcc.dg/strlenopt-63.c: New test.\n+\t* gcc.dg/pr79538.c: Adjust text of expected warning.\n+\t* gcc.dg/pr81292-1.c: Adjust pass name.\n+\t* gcc.dg/pr81292-2.c: Same.\n+\t* gcc.dg/pr81703.c: Same.\n+\t* gcc.dg/strcmpopt_2.c: Same.\n+\t* gcc.dg/strcmpopt_3.c: Same.\n+\t* gcc.dg/strcmpopt_4.c: Same.\n+\t* gcc.dg/strlenopt-1.c: Same.\n+\t* gcc.dg/strlenopt-10.c: Same.\n+\t* gcc.dg/strlenopt-11.c: Same.\n+\t* gcc.dg/strlenopt-13.c: Same.\n+\t* gcc.dg/strlenopt-14g.c: Same.\n+\t* gcc.dg/strlenopt-14gf.c: Same.\n+\t* gcc.dg/strlenopt-15.c: Same.\n+\t* gcc.dg/strlenopt-16g.c: Same.\n+\t* gcc.dg/strlenopt-17g.c: Same.\n+\t* gcc.dg/strlenopt-18g.c: Same.\n+\t* gcc.dg/strlenopt-19.c: Same.\n+\t* gcc.dg/strlenopt-1f.c: Same.\n+\t* gcc.dg/strlenopt-2.c: Same.\n+\t* gcc.dg/strlenopt-20.c: Same.\n+\t* gcc.dg/strlenopt-21.c: Same.\n+\t* gcc.dg/strlenopt-22.c: Same.\n+\t* gcc.dg/strlenopt-22g.c: Same.\n+\t* gcc.dg/strlenopt-24.c: Same.\n+\t* gcc.dg/strlenopt-25.c: Same.\n+\t* gcc.dg/strlenopt-26.c: Same.\n+\t* gcc.dg/strlenopt-27.c: Same.\n+\t* gcc.dg/strlenopt-28.c: Same.\n+\t* gcc.dg/strlenopt-29.c: Same.\n+\t* gcc.dg/strlenopt-2f.c: Same.\n+\t* gcc.dg/strlenopt-3.c: Same.\n+\t* gcc.dg/strlenopt-30.c: Same.\n+\t* gcc.dg/strlenopt-31g.c: Same.\n+\t* gcc.dg/strlenopt-32.c: Same.\n+\t* gcc.dg/strlenopt-33.c: Same.\n+\t* gcc.dg/strlenopt-33g.c: Same.\n+\t* gcc.dg/strlenopt-34.c: Same.\n+\t* gcc.dg/strlenopt-35.c: Same.\n+\t* gcc.dg/strlenopt-4.c: Same.\n+\t* gcc.dg/strlenopt-48.c: Same.\n+\t* gcc.dg/strlenopt-49.c: Same.\n+\t* gcc.dg/strlenopt-4g.c: Same.\n+\t* gcc.dg/strlenopt-4gf.c: Same.\n+\t* gcc.dg/strlenopt-5.c: Same.\n+\t* gcc.dg/strlenopt-50.c: Same.\n+\t* gcc.dg/strlenopt-51.c: Same.\n+\t* gcc.dg/strlenopt-52.c: Same.\n+\t* gcc.dg/strlenopt-53.c: Same.\n+\t* gcc.dg/strlenopt-54.c: Same.\n+\t* gcc.dg/strlenopt-55.c: Same.\n+\t* gcc.dg/strlenopt-56.c: Same.\n+\t* gcc.dg/strlenopt-6.c: Same.\n+\t* gcc.dg/strlenopt-61.c: Same.\n+\t* gcc.dg/strlenopt-7.c: Same.\n+\t* gcc.dg/strlenopt-8.c: Same.\n+\t* gcc.dg/strlenopt-9.c: Same.\n+\t* gcc.dg/strlenopt.h (snprintf, snprintf): Declare.\n+\t* gcc.dg/tree-ssa/builtin-snprintf-6.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-snprintf-7.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-snprintf-8.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-snprintf-9.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-21.c: New test.\n+\t* gcc.dg/tree-ssa/dump-4.c: New test.\n+\t* gcc.dg/tree-ssa/pr83501.c: Adjust pass name.\n+\n 2019-08-23  Martin Sebor  <msebor@redhat.com>\n \n \t* gcc.dg/Warray-bounds-36.c: Make functions static to avoid failures"}, {"sha": "4f10d97395e73af32a8a6fb051eab2b0c03e0313", "filename": "gcc/testsuite/gcc.dg/pr79538.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79538.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79538.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79538.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -17,6 +17,6 @@ void f ()\n {\n   char des[3];\n   char src[] = \"abcd\";\n-  __builtin_sprintf (des, \"%s\", src); /* { dg-warning \"directive writing up to 4 bytes into a region of size 3\" } */\n+  __builtin_sprintf (des, \"%s\", src); /* { dg-warning \"directive writing 4 bytes into a region of size 3\" } */\n   return;\n }"}, {"sha": "2a454df88a1b2343114fd48930794c210e060236", "filename": "gcc/testsuite/gcc.dg/pr81292-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81292-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81292-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81292-1.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -32,4 +32,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */"}, {"sha": "252884abca7f30c951b2c0b44f54bf92836a1b5e", "filename": "gcc/testsuite/gcc.dg/pr81292-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81292-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81292-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81292-2.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -32,4 +32,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 6 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 6 \"strlen1\" } } */"}, {"sha": "02edf267437ff14aaf36c810b3b14057e3bbb40b", "filename": "gcc/testsuite/gcc.dg/pr81703.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81703.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81703.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81703.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -9,4 +9,4 @@ unsigned g (void)\n   return __builtin_strlen (d);\n }\n \n-/* { dg-final { scan-tree-dump-not \"__builtin_strlen\" \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-not \"__builtin_strlen\" \"strlen1\" } } */"}, {"sha": "57d8f651c28593361a20ac5525f378d1846d10c1", "filename": "gcc/testsuite/gcc.dg/strcmpopt_2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -64,4 +64,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 8 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 8 \"strlen1\" } } */"}, {"sha": "571646ce001d9cc127e166e6252145e3bd058005", "filename": "gcc/testsuite/gcc.dg/strcmpopt_3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -28,4 +28,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strcmp\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcmp\" 0 \"strlen1\" } } */"}, {"sha": "4e26522eed14f638fc1f33ab8dead3ff94a5e299", "filename": "gcc/testsuite/gcc.dg/strcmpopt_4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -13,4 +13,4 @@ f1 (S * s)\n   return result;\n }\n \n-/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 1 \"strlen1\" } } */"}, {"sha": "24772c1449948970c8e842586bc793e9b5a912a3", "filename": "gcc/testsuite/gcc.dg/strlenopt-1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -36,9 +36,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "ce959c34a80e5277d4b692a3882870f96db9e035", "filename": "gcc/testsuite/gcc.dg/strlenopt-10.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -69,14 +69,14 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n /* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op\n    to expand the memcpy call at the end of fn2.  */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 8 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen\" { target { avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"\\\\*q_\\[0-9\\]* = 32;\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\\[^\\n\\r\\]*, 1\\\\)\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 8 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\*q_\\[0-9\\]* = 32;\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\\[^\\n\\r\\]*, 1\\\\)\" 1 \"strlen1\" } } */"}, {"sha": "abd9faebed6b4bffd9e7ebebaa0f60c8f3dd881a", "filename": "gcc/testsuite/gcc.dg/strlenopt-11.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -58,18 +58,18 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen1\" } } */\n /* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op\n    to expand the memcpy call at the end of fn1.  */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen\" { target { avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen1\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */\n /* Where the memcpy is expanded, the assignemts to elements of l are\n    propagated.  */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.9. = \" 1 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\" 3 \"strlen\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.9. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\" 3 \"strlen1\" { target { avr-*-* } } } } */"}, {"sha": "27ecc79c2d9153a4d71b8b6c4b80cbf60514f39c", "filename": "gcc/testsuite/gcc.dg/strlenopt-13.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -55,19 +55,19 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen1\" } } */\n /* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op\n    to expand the memcpy call at the end of fn1.  */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen\" { target { avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen1\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */\n /* Where the memcpy is expanded, the assignemts to elements of l are\n    propagated.  */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.1. = \" 1 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.5. = \" 1 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\" 4 \"strlen\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.1. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.5. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\" 4 \"strlen1\" { target { avr-*-* } } } } */"}, {"sha": "1368ed3f68e9b6dabfc91d7184ecbe3a7ae8f8e0", "filename": "gcc/testsuite/gcc.dg/strlenopt-14g.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14g.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -107,10 +107,10 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen1\" } } */"}, {"sha": "f7db2a8a53eb3acf6aff3a6ee3c8b44aaa0b90a2", "filename": "gcc/testsuite/gcc.dg/strlenopt-14gf.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14gf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14gf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14gf.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -11,15 +11,15 @@\n /* Compared to strlenopt-14gf.c, strcpy_chk with string literal as\n    second argument isn't being optimized by builtins.c into\n    memcpy.  */\n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__mempcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__mempcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen1\" } } */"}, {"sha": "b72c096ffa9c9fbe56829b875e33d7b3aa01e736", "filename": "gcc/testsuite/gcc.dg/strlenopt-15.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-15.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -51,9 +51,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "816cbbce8013bea4632451506d812e173b478e2b", "filename": "gcc/testsuite/gcc.dg/strlenopt-16g.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-16g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-16g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-16g.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -24,10 +24,10 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen1\" } } */"}, {"sha": "aa86f78ec7f27ce2286b5a70553a8879ce9325bf", "filename": "gcc/testsuite/gcc.dg/strlenopt-17g.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-17g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-17g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-17g.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -47,10 +47,10 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 3 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 3 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen1\" } } */"}, {"sha": "de692e0767ac965d98330744adbc4440b5e6a3de", "filename": "gcc/testsuite/gcc.dg/strlenopt-18g.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-18g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-18g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-18g.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -73,9 +73,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen1\" } } */"}, {"sha": "814f51b27f6a84fc44da062fe5a31cd0c2ad8bd3", "filename": "gcc/testsuite/gcc.dg/strlenopt-19.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-19.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -72,9 +72,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "4e3abd9472d67e7728a8512450bef44e977caa9d", "filename": "gcc/testsuite/gcc.dg/strlenopt-1f.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -5,13 +5,13 @@\n #define FORTIFY_SOURCE 2\n #include \"strlenopt-1.c\"\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "b09f7c17e39d03a713dde64569589b8c21c6cf90", "filename": "gcc/testsuite/gcc.dg/strlenopt-2.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -40,9 +40,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 5 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 5 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "79db12bc1028928466e2b16843db270953475ba9", "filename": "gcc/testsuite/gcc.dg/strlenopt-20.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-20.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -86,9 +86,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "7924ff30b511d676bad74beb558000e825f6e466", "filename": "gcc/testsuite/gcc.dg/strlenopt-21.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-21.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -57,9 +57,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 3 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 3 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "2d127b118325717a2614e7b57ebd77efdae3e7f2", "filename": "gcc/testsuite/gcc.dg/strlenopt-22.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-22.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -31,9 +31,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "1ecb85eae0cbb9fcd141a420b19ee46ce797cd10", "filename": "gcc/testsuite/gcc.dg/strlenopt-22g.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-22g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-22g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-22g.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -5,9 +5,9 @@\n #define USE_GNU\n #include \"strlenopt-22.c\"\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen1\" } } */"}, {"sha": "275b5602b70f93a96df6f158fb9e4c473ad1af45", "filename": "gcc/testsuite/gcc.dg/strlenopt-24.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-24.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -13,4 +13,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "faed5bec88954533171b240320080f41f59a792e", "filename": "gcc/testsuite/gcc.dg/strlenopt-25.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-25.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -14,4 +14,4 @@ main ()\n   return len - len2;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "0385aceaad3cd54bec8de8027ee6bef43bd4f3a4", "filename": "gcc/testsuite/gcc.dg/strlenopt-26.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-26.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -20,5 +20,5 @@ main (void)\n   return fn1 (p, q);\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "e3655930b3e9102e75d4e912435748e10e511e38", "filename": "gcc/testsuite/gcc.dg/strlenopt-27.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-27.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -19,4 +19,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "6bdbed7e9d0fa0127bb94856ab976a8c9b2a7bbd", "filename": "gcc/testsuite/gcc.dg/strlenopt-28.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-28.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -56,4 +56,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "8922101f549e06f03496d8aad488987805d72fa5", "filename": "gcc/testsuite/gcc.dg/strlenopt-29.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-29.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -24,4 +24,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "5786f8a1904764ba830163740ed113649d77d197", "filename": "gcc/testsuite/gcc.dg/strlenopt-2f.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2f.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -5,13 +5,13 @@\n #define FORTIFY_SOURCE 2\n #include \"strlenopt-2.c\"\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 5 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 5 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "a748f011c80161d100478291e89c323d9fa5eb67", "filename": "gcc/testsuite/gcc.dg/strlenopt-3.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-3.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -53,12 +53,12 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"return 0\" 3 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \"return 4\" 1 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \"return 3\" 1 \"optimized\" } } */"}, {"sha": "2a3098ba96f78641477703501711b4829340bdb0", "filename": "gcc/testsuite/gcc.dg/strlenopt-30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-30.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -60,4 +60,4 @@ _Bool f7(char *s)\n   return (t1 == s);\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin_strncmp\" 5 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_strncmp\" 5 \"strlen1\" } } */"}, {"sha": "4eff86448f1562be193e38e47850bebfc899edb0", "filename": "gcc/testsuite/gcc.dg/strlenopt-31g.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31g.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -4,6 +4,6 @@\n #define USE_GNU\n #include \"strlenopt-31.c\"\n \n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-not \"strlen \\\\(\" \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-not \"strlen \\\\(\" \"strlen1\" } } */"}, {"sha": "4220314fb3f06074e55319d8dc971d9e012f4e11", "filename": "gcc/testsuite/gcc.dg/strlenopt-32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-32.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -190,4 +190,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "4903a91a0a4ff3722ae20ccca66d0c8e09eab9e8", "filename": "gcc/testsuite/gcc.dg/strlenopt-33.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -39,4 +39,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */"}, {"sha": "a814160e234253e068d0a48aad318d280d72ab36", "filename": "gcc/testsuite/gcc.dg/strlenopt-33g.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33g.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -40,5 +40,5 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen1\" } } */"}, {"sha": "1979370cb5e352687f24ae955fffa2d332c7a84b", "filename": "gcc/testsuite/gcc.dg/strlenopt-34.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-34.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -35,4 +35,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */"}, {"sha": "d175fd7ff5051048907cdd90e0b5f6fbcf3bf96c", "filename": "gcc/testsuite/gcc.dg/strlenopt-35.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-35.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -28,4 +28,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen1\" } } */"}, {"sha": "1d0a6e615bc2be39da05642981e149612f46332a", "filename": "gcc/testsuite/gcc.dg/strlenopt-4.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -66,9 +66,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 3 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 3 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 3 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 3 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "c2d0ac66521bcecf0b950e9bb97553e4efd9b4ae", "filename": "gcc/testsuite/gcc.dg/strlenopt-48.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-48.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -31,5 +31,5 @@ void h (void)\n     abort();\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"optimized\" } }\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"optimized\" } }\n    { dg-final { scan-tree-dump-times \"abort\" 0 \"optimized\" } } */"}, {"sha": "bbea0e2db7247d26435c4910360504979ddf0177", "filename": "gcc/testsuite/gcc.dg/strlenopt-49.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-49.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-49.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-49.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -45,7 +45,7 @@ int cmp88 (void)\n   return cmp88;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"len0 = 0;\" 1 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"len = 18;\" 1 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"lenx = 8;\" 1 \"gimple\" } }"}, {"sha": "88dcec647e7a9bbd2acce301b03c08e09be04d1a", "filename": "gcc/testsuite/gcc.dg/strlenopt-4g.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4g.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -5,9 +5,9 @@\n #define USE_GNU\n #include \"strlenopt-4.c\"\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 5 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 5 \"strlen1\" } } */"}, {"sha": "033661ad4a96a91a97813d49e99793cf0b4638ba", "filename": "gcc/testsuite/gcc.dg/strlenopt-4gf.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4gf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4gf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4gf.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -6,13 +6,13 @@\n #define FORTIFY_SOURCE 2\n #include \"strlenopt-4.c\"\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 5 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 5 \"strlen1\" } } */"}, {"sha": "5a31322bfa15f1ee495fba3fa7dea6ee9cbc8be8", "filename": "gcc/testsuite/gcc.dg/strlenopt-5.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-5.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -48,9 +48,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "8e7c9dbd93df14758d4d499f22f73fe8603040d8", "filename": "gcc/testsuite/gcc.dg/strlenopt-50.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-50.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -112,5 +112,5 @@ void test_array_ref (void)\n   T (&b[16], 0);  T (&b[17], 0);  T (&b[18], 0);  T (&b[19], 0);\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"ccp1\" } } */"}, {"sha": "22a89385f5ef12152bc6949b8253e030092c3f2f", "filename": "gcc/testsuite/gcc.dg/strlenopt-51.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -84,4 +84,4 @@ void test_elim_a9_9 (unsigned i)\n   T (0); T (1); T (2); T (3); T (4); T (5); T (6); T (7); T (8);\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"gimple\" } } */"}, {"sha": "97b3da7cd0e468897493cd423a5e547e425f6f77", "filename": "gcc/testsuite/gcc.dg/strlenopt-52.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-52.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -284,5 +284,5 @@ void test_global_struct_struct_array (void)\n   T (ssa[5].sa9[3].a6, 3);\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"ccp1\" } } */"}, {"sha": "489c22b69372cd5695f8552715a296a274f4cf2e", "filename": "gcc/testsuite/gcc.dg/strlenopt-53.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-53.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -112,5 +112,5 @@ void test_array_ref (void)\n   T (&b[16], 0);  T (&b[17], 0);  T (&b[18], 0);  T (&b[19], 0);\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"ccp1\" } } */"}, {"sha": "d4e57ff62559212a8d3951fc9846b6f1f9087f1d", "filename": "gcc/testsuite/gcc.dg/strlenopt-54.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-54.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -105,5 +105,5 @@ void elim_after_init_memcpy (void)\n   T (\"AB\\000CD\", 0, \"ab\\000c\", 4, 2);\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"optimized\" } }\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"optimized\" } }\n    { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"optimized\" } } */"}, {"sha": "ea6fb22a2edbb7899def39581c998c9cc7f56aad", "filename": "gcc/testsuite/gcc.dg/strlenopt-55.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-55.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-55.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-55.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -224,7 +224,7 @@ const void test_large_string_size (void)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"memcmp\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"strcmp\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"optimized\" } } */"}, {"sha": "ffd02f1b6cfde89c683e8a2c1865641c5cc07d18", "filename": "gcc/testsuite/gcc.dg/strlenopt-56.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-56.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-56.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-56.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -45,6 +45,6 @@ void test_contents (void)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+/* { dg-final { scan-tree-dump-times \"strlen1\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"strcmp\" 0 \"gimple\" } }\n    { dg-final { scan-tree-dump-times \"abort\" 0 \"optimized\" } } */"}, {"sha": "dcbe778a27a988e921bbcc35ace4de3c9ce34eaf", "filename": "gcc/testsuite/gcc.dg/strlenopt-6.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-6.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -77,9 +77,9 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "3ddfa2ebc9f569e1c87e93490ede1321d803b551", "filename": "gcc/testsuite/gcc.dg/strlenopt-61.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-61.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -215,4 +215,4 @@ void test_ta2 (void)\n }\n \n /* { dg-final { scan-tree-dump-not \"failure\" \"optimized\" } }\n-   { dg-final { scan-tree-dump-not \"strlen\" \"gimple\" } } */\n+   { dg-final { scan-tree-dump-not \"strlen1\" \"gimple\" } } */"}, {"sha": "56d314e5d453583cb0733b9488d56b45d42f8a2e", "filename": "gcc/testsuite/gcc.dg/strlenopt-68.c", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-68.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -0,0 +1,382 @@\n+/* PR tree-optimization/83431 - Verify that snprintf (0, 0, \"%s\",\n+   with an argument that's a conditional expression evaluates to\n+   the expected result regardless of the order of the expression\n+   operands.\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define A(expr)                                                 \\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"assertion failed on line %i: %s\\n\",    \\\n+                        __LINE__, #expr),                       \\\n+      __builtin_abort ()))\n+\n+const char gs0[] = \"\";\n+const char gs3[] = \"123\";\n+\n+char gc;\n+char ga5[7];\n+\n+struct S { char n, ma7[7], max[]; };\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs0_gs3_ga5_m1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs0 : 0 < i ? gs3 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs0_gs3_ga5_0 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs0 : 0 < i ? gs3 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs0_gs3_ga5_p1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs0 : 0 < i ? gs3 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs0_ga5_gs3_m1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs0 : 0 < i ? ga5 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs0_ga5_gs3_0 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs0 : 0 < i ? ga5 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs0_ga5_gs3_p1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs0 : 0 < i ? ga5 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_ga5_gs0_gs3_m1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs0 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_ga5_gs0_gs3_0 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs0 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_ga5_gs0_gs3_p1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs0 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_ga5_gs3_gs0_m1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs3 : gs0;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_ga5_gs3_gs0_0 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs3 : gs0;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_ga5_gs3_gs0_p1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs3 : gs0;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs3_gs0_ga5_m1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs3 : 0 < i ? gs0 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs3_gs0_ga5_0 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs3 : 0 < i ? gs0 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+equal_4_gs3_gs0_ga5_p1 (int i)\n+{\n+  strcpy (ga5, \"1234\");\n+  const char *p = i < 0 ? gs3 : 0 < i ? gs0 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+\n+/* Similar to the above but with memcpy creating a string at least\n+   four characters long, and the address of the NUL character.  */\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gc_gs3_ga5_m1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? &gc : 0 < i ? gs3 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gc_gs3_ga5_0 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? &gc : 0 < i ? gs3 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gc_gs3_ga5_p1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? &gc : 0 < i ? gs3 : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gc_ga5_gs3_m1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? &gc : 0 < i ? ga5 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gc_ga5_gs3_0 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? &gc : 0 < i ? ga5 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gc_ga5_gs3_p1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? &gc : 0 < i ? ga5 : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_ga5_gc_gs3_m1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? ga5 : 0 < i ? &gc : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_ga5_gc_gs3_0 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? ga5 : 0 < i ? &gc : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_ga5_gc_gs3_p1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? ga5 : 0 < i ? &gc : gs3;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_ga5_gs3_gc_m1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs3 : &gc;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_ga5_gs3_gc_0 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs3 : &gc;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_ga5_gs3_gc_p1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? ga5 : 0 < i ? gs3 : &gc;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gs3_gc_ga5_m1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? gs3 : 0 < i ? &gc : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 3);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gs3_gc_ga5_0 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? gs3 : 0 < i ? &gc : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 4);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+min_4_gs3_gc_ga5_p1 (int i)\n+{\n+  gc = 0;\n+  memcpy (ga5, \"1234\", 4);\n+  const char *p = i < 0 ? gs3 : 0 < i ? &gc : ga5;\n+\n+  A (snprintf (0, 0, \"%s\", p) == 0);\n+}\n+\n+\n+int main (void)\n+{\n+  equal_4_gs0_gs3_ga5_m1 (-1);\n+  equal_4_gs0_gs3_ga5_0  ( 0);\n+  equal_4_gs0_gs3_ga5_p1 (+1);\n+\n+  equal_4_gs0_ga5_gs3_m1 (-1);\n+  equal_4_gs0_ga5_gs3_0  ( 0);\n+  equal_4_gs0_ga5_gs3_p1 (+1);\n+\n+  equal_4_ga5_gs0_gs3_m1 (-1);\n+  equal_4_ga5_gs0_gs3_0  ( 0);\n+  equal_4_ga5_gs0_gs3_p1 (+1);\n+\n+  equal_4_ga5_gs3_gs0_m1 (-1);\n+  equal_4_ga5_gs3_gs0_0  ( 0);\n+  equal_4_ga5_gs3_gs0_p1 (+1);\n+\n+  equal_4_gs3_gs0_ga5_m1 (-1);\n+  equal_4_gs3_gs0_ga5_0  ( 0);\n+  equal_4_gs3_gs0_ga5_p1 (+1);\n+\n+  /* Same as aabove but with memcpy creating a string at least four\n+     characters long.  */\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gc_gs3_ga5_m1 (-1);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gc_gs3_ga5_0  ( 0);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gc_gs3_ga5_p1 (+1);\n+\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gc_ga5_gs3_m1 (-1);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gc_ga5_gs3_0  ( 0);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gc_ga5_gs3_p1 (+1);\n+\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_ga5_gc_gs3_m1 (-1);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_ga5_gc_gs3_0  ( 0);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_ga5_gc_gs3_p1 (+1);\n+\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_ga5_gs3_gc_m1 (-1);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_ga5_gs3_gc_0  ( 0);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_ga5_gs3_gc_p1 (+1);\n+\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gs3_gc_ga5_m1 (-1);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gs3_gc_ga5_0  ( 0);\n+  memset (ga5, 0, sizeof ga5);\n+  min_4_gs3_gc_ga5_p1 (+1);\n+}"}, {"sha": "ba62c03962208ba560878715ccb0121d1a7e1af8", "filename": "gcc/testsuite/gcc.dg/strlenopt-7.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-7.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -40,12 +40,12 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"\\\\*r_\\[0-9\\]* = 0;\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\*r_\\[0-9\\]* = 0;\" 1 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"return 3;\" 1 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \"return 0;\" 2 \"optimized\" } } */"}, {"sha": "df6b594946aa60d4989762fb5f6a6fa346655473", "filename": "gcc/testsuite/gcc.dg/strlenopt-9.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -98,10 +98,10 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 5 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 5 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"return 4;\" 1 \"optimized\" } } */"}, {"sha": "518d0cf08b26ec85f1acab3979c663e3c9c8659e", "filename": "gcc/testsuite/gcc.dg/strlenopt.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -1,4 +1,4 @@\n-/* This is a replacement of needed parts from stdlib.h and string.h\n+/* This is a replacement of needed parts from <stdlib.h> and <string.h>\n    for -foptimize-strlen testing, to ensure we are testing the builtins\n    rather than whatever the OS has in its headers.  */\n \n@@ -25,6 +25,9 @@ void *mempcpy (void *__restrict, const void *__restrict, size_t);\n char *stpcpy (char *__restrict, const char *__restrict);\n #endif\n \n+int sprintf (char * __restrict, const char *__restrict, ...);\n+int snprintf (char * __restrict, size_t, const char *__restrict, ...);\n+\n #if defined(FORTIFY_SOURCE) && FORTIFY_SOURCE > 0 && __OPTIMIZE__\n # define bos(ptr) __builtin_object_size (ptr, FORTIFY_SOURCE > 0)\n # define bos0(ptr) __builtin_object_size (ptr, 0)"}, {"sha": "0d9b27505ec4648f39dee39aa727350b8c6d9b0e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-6.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-6.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -0,0 +1,139 @@\n+/* Test to verify that snprintf can determine the length of a dynamically\n+   constructed string argument and fold the result into a constant.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+char* strcpy (char * restrict, const char * restrict);\n+int sprintf (char * restrict, const char *restrict, ...);\n+int snprintf (char * restrict, size_t, const char *restrict, ...);\n+\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name, counter)\t\t\t\t\t\t\\\n+  CAT (CAT (CAT (call_ ## name ##_on_line_, __LINE__), _), counter)\n+\n+#define FAIL(name, counter) do {\t\t\t\\\n+    extern void FAILNAME (name, counter) (void);\t\\\n+    FAILNAME (name, counter)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+   call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr)\t\t\t\t\t\t\t\\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated, __COUNTER__); else (void)0\n+\n+#define ARGS(...) __VA_ARGS__\n+\n+#define T(expect, init, fmt, ...)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    char a[] = init;\t\t\t\t\t\\\n+    ELIM (expect == snprintf (0, 0, fmt, __VA_ARGS__));\t\\\n+  } while (0)\n+\n+/* Exercise a non-const local char array initialized by a string literal.  */\n+void test_assign_string (void)\n+{\n+  T (0, \"\", \"%s\", a);\n+  T (1, \"1\", \"%s\", a);\n+  T (4, \"1234\", \"%s\", a);\n+  T (5, \"123\", \"s=%s\", a);\n+  T (5, \"1234\", \"s=%s\", a + 1);\n+  T (2, \"1234\", \"s=%s\", a + 4);\n+  T (5, \"12345\", \"s=%s\", &a[2]);\n+  T (5, \"123456\", \"s=%.*s\", 3, &a[2]);\n+}\n+\n+/* Exercise a non-const local char array initialized by an initializer\n+   list.  */\n+void test_assign_init_list (void)\n+{\n+  T (0, ARGS ({ 0 }), \"%s\", a);\n+  T (1, ARGS ({ 1, 0 }), \"%s\", a);\n+  T (3, ARGS ({ [3] = 0, [1] = 2, [0] = 1, [2] = 3 }), \"%s\", a);\n+  T (3, ARGS ({ [3] = 0, [1] = 2, [0] = 1, [2] = 3, [4] = 0 }), \"%s\", a);\n+  T (4, ARGS ({ 1, 2, 3, 4, 0 }), \"%s\", a);\n+  T (5, ARGS ({ 1, 2, 3, 0 }), \"s=%s\", a);\n+  T (5, ARGS ({ 1, 2, 3, 4, 0 }), \"s=%s\", a + 1);\n+  T (2, ARGS ({ 1, 2, 3, 4, 0 }), \"s=%s\", a + 4);\n+  T (5, ARGS ({ 1, 2, 3, 4, 5, 0 }), \"s=%s\", &a[2]);\n+  T (5, ARGS ({ 1, 2, 3, 4, 5, 6, 0 }), \"s=%.*s\", 3, &a[2]);\n+}\n+\n+#undef T\n+#define T(expect, init, fmt, ...)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    struct { int n; char a[sizeof init]; }\t\t\\\n+    s = { sizeof init, init };\t\t\t\t\\\n+    ELIM (expect == snprintf (0, 0, fmt, __VA_ARGS__));\t\\\n+  } while (0)\n+\n+/* Exercise a non-const local struct initialized by an initializer\n+   list.  */\n+void test_assign_aggregate (void)\n+{\n+  T (0, \"\", \"%s\", s.a);\n+  T (1, \"1\", \"%s\", s.a);\n+  T (4, \"1234\", \"%s\", s.a);\n+  T (5, \"123\", \"s=%s\", s.a);\n+  T (5, \"1234\", \"s=%s\", s.a + 1);\n+  T (2, \"1234\", \"s=%s\", s.a + 4);\n+  T (5, \"12345\", \"s=%s\", &s.a[2]);\n+  T (5, \"123456\", \"s=%.*s\", 3, &s.a[2]);\n+}\n+\n+\n+#undef T\n+#define T(expect, init, fmt, ...)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    char a[sizeof init];\t\t\t\t\\\n+    strcpy (a, init);\t\t\t\t\t\\\n+    ELIM (expect == snprintf (0, 0, fmt, __VA_ARGS__));\t\\\n+  } while (0)\n+\n+/* Exercise a local char array initialized by a call to strcpy.  */\n+void test_local_strcpy (void)\n+{\n+  T (0, \"\", \"%s\", a);\n+  T (1, \"1\", \"%s\", a);\n+  T (2, \"12\", \"%s\", a);\n+  T (3, \"123\", \"%s\", a);\n+  T (4, \"1234\", \"%s\", a);\n+  T (5, \"123\", \"s=%s\", a);\n+  T (5, \"1234\", \"s=%s\", a + 1);\n+  T (2, \"1234\", \"s=%s\", a + 4);\n+  T (5, \"12345\", \"s=%s\", &a[2]);\n+  T (5, \"123456\", \"s=%.*s\", 3, &a[2]);\n+}\n+\n+#undef T\n+#define T(expect, init, fmt, ...)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    char a[n];\t\t\t\t\t\t\\\n+    strcpy (a, init);\t\t\t\t\t\\\n+    ELIM (expect == snprintf (0, 0, fmt, __VA_ARGS__));\t\\\n+  } while (0)\n+\n+/* Exercise a VLA initialized by a call to strcpy.  */\n+void test_vla_strcpy (unsigned n)\n+{\n+  T (0, \"\", \"%s\", a);\n+  T (1, \"1\", \"%s\", a);\n+  T (2, \"12\", \"%s\", a);\n+  T (3, \"123\", \"%s\", a);\n+  T (4, \"1234\", \"%s\", a);\n+  T (5, \"123\", \"s=%s\", a);\n+  T (5, \"1234\", \"s=%s\", a + 1);\n+  T (2, \"1234\", \"s=%s\", a + 4);\n+  T (5, \"12345\", \"s=%s\", &a[2]);\n+  T (5, \"123456\", \"s=%.*s\", 3, &a[2]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"printf\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"strlen\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"not_eliminated\" 0 \"optimized\" } } */"}, {"sha": "bf5072e955cfbeefe0dae36fb04448276fca8e00", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-7.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-7.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -0,0 +1,152 @@\n+/* Test to verify that snprintf can determine the correct range\n+   of lengths of dynamically constructed string arguments.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* memcpy (void*, const void*, size_t);\n+\n+char* strcpy (char * restrict, const char * restrict);\n+int snprintf (char * restrict, size_t, const char *restrict, ...);\n+\n+void sink (void*, ...);\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name, counter)\t\t\t\t\t\t\\\n+  CAT (CAT (CAT (call_ ## name ##_on_line_, __LINE__), _), counter)\n+\n+#define FAIL(name, counter) do {\t\t\t\\\n+    extern void FAILNAME (name, counter) (void);\t\\\n+    FAILNAME (name, counter)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+   call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define VERIFY_ELIM(expr)\t\t\t\t\t\t\\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated, __COUNTER__); else (void)0\n+\n+/* Macro to emit a call to a function named\n+     call_made_in_{true,false}_branch_on_line_NNN()\n+   for each call that's expected to be retained.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that the expected number of both kinds of calls appears in output\n+   (a pair for each line with the invocation of the KEEP() macro.  */\n+#define VERIFY_KEEP(expr)\t\t\t\\\n+  if (expr)\t\t\t\t\t\\\n+    FAIL (made_in_true_branch, __COUNTER__);\t\\\n+  else\t\t\t\t\t\t\\\n+    FAIL (made_in_false_branch, __COUNTER__)\n+\n+#define ARGS(...) __VA_ARGS__\n+\n+/* Each test macro expands to a new function to get around bug 81776\n+   - missing sprintf optimization due to pointer escape analysis.  */\n+#define ELIM(expect, dst, init, fmt, ...)\t\t\\\n+  void CAT (test_func_on_line_, __LINE__)(void)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    memcpy (dst, init, sizeof (init) - 1);\t\t\\\n+    const int res = snprintf (0, 0, fmt, __VA_ARGS__);\t\\\n+    VERIFY_ELIM (expect res);\t\t\t\t\\\n+  } typedef void dummy_typedef\n+\n+#define KEEP(expect, dst, init, fmt, ...)\t\t\\\n+  void CAT (test_func_on_line_, __LINE__)(void)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    memcpy (dst, init, sizeof (init) - 1);\t\t\\\n+    const int ret = snprintf (0, 0, fmt, __VA_ARGS__);\t\\\n+    VERIFY_KEEP (expect ret);\t\t\t\t\\\n+  } typedef void dummy_typedef\n+\n+\n+/* Verify that conditions involving snprintf calls with a string\n+   of some minimum but otherwise unbounded length stored in an array\n+   of unknown bound are not folded unless the format string itself\n+   restricts the maximum.  The string could be longer than INT_MAX\n+   making the snprintf call fail and return a negative value.  */\n+\n+extern char gax[];\n+\n+KEEP (1 <=, gax, \"1\",  \"%s\", gax);\n+KEEP (2 <=, gax, \"12\", \"%s\", gax);\n+KEEP (3 <=, gax, \"123\", \"%s\", gax);\n+\n+ELIM (3 ==, gax, \"123\", \"%.3s\", gax);\n+ELIM (5 ==, gax, \"123\", \"%.3s%.2s\", gax, gax);\n+\n+\n+/* Disabled.  The global pointer passed to memcpy as the destination\n+   might point at itself, i.e., gptr == &gptr is a valid argument to\n+   memcpy.\n+\n+extern char *gptr;\n+\n+KEEP (1 <=, gptr, \"1\",  \"%s\", gptr);\n+KEEP (2 <=, gptr, \"12\", \"%s\", gptr);\n+KEEP (3 <=, gptr, \"123\", \"%s\", gptr);\n+\n+ELIM (3 ==, gptr, \"123\", \"%.3s\", gptr);\n+ELIM (5 ==, gptr, \"123\", \"%.3s%.2s\", gptr, gptr);\n+\n+*/\n+\n+/* Verify that conditions involving snprintf calls with a string\n+   of some minimum but otherwise unbounded length stored in an array\n+   of a known bound are folded.  The longest string that can be\n+   stored in such arrays is bounded by the size of the array.  */\n+\n+extern char ga4[4];\n+\n+ELIM (0 <=, ga4, \"\\0\",   \"%s\", ga4);\n+ELIM (3 >=, ga4, \"\\0\",   \"%s\", ga4);\n+\n+ELIM (1 <=, ga4, \"1\",  \"%s\", ga4);\n+ELIM (0 <=, ga4, \"1\",  \"%s\", ga4 + 1);\n+ELIM (0 <=, ga4, \"1\",  \"%s\", &ga4[1]);\n+\n+ELIM (3 >=, ga4, \"1\",  \"%s\", ga4);\n+ELIM (2 >=, ga4, \"1\",  \"%s\", ga4 + 1);\n+ELIM (2 >=, ga4, \"1\",  \"%s\", &ga4[1]);\n+\n+ELIM (2 <=, ga4, \"12\", \"%s\", ga4);\n+ELIM (3 >=, ga4, \"12\", \"%s\", ga4);\n+\n+ELIM (3 <=, ga4, \"123\", \"%s\", ga4);\n+ELIM (3 ==, ga4, \"123\", \"%.3s\", ga4);\n+ELIM (5 ==, ga4, \"123\", \"%.3s%.2s\", ga4, ga4);\n+\n+/* Verify conditionals involving dynamically created strings of known\n+   length stored in local arrays.  */\n+\n+#undef ELIM\n+#define ELIM(expect, N1, N2, init1, init2, fmt, ...)\t\\\n+  void CAT (test_func_on_line_, __LINE__)(int i)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    char a1[N1], a2[N2];\t\t\t\t\\\n+    memcpy (a1, init1, sizeof (init1) - 1);\t\t\\\n+    memcpy (a2, init2, sizeof (init2) - 1);\t\t\\\n+    const int res = snprintf (0, 0, fmt, __VA_ARGS__);\t\\\n+    VERIFY_ELIM (expect res);\t\t\t\t\\\n+  } typedef void dummy_typedef\n+\n+ELIM (0 ==, 2, 2, \"\\0\", \"\\0\",   \"%s\",         i ? a1 : a2);\n+ELIM (2 ==, 2, 2, \"\\0\", \"\\0\",   \"s=%s\",       i ? a1 : a2);\n+\n+ELIM (1 ==, 2, 2, \"a\\0\", \"b\\0\", \"%s\",         i ? a1 : a2);\n+ELIM (3 ==, 2, 2, \"a\\0\", \"b\\0\", \"s=%s\",       i ? a1 : a2);\n+\n+ELIM (2 ==, 3, 5, \"ab\\0\", \"cd\\0\", \"%s\",       i ? a1 : a2);\n+ELIM (3 ==, 3, 5, \"ab\\0\", \"cd\\0\", \"%3s\",      i ? a1 : a2);\n+ELIM (3 ==, 5, 5, \"abcd\\0\", \"efgh\\0\", \"%.3s\", i ? a1 : a2);\n+\n+ELIM (3 ==, 4, 1, \"abc\\0\", \"\", \"%s\",          i ? a1 : \"def\");\n+ELIM (4 ==, 1, 5, \"\", \"efgh\\0\", \"%s\",         i ? \"abcd\" : a2);\n+\n+ELIM (4 ==, 5, 5, \"abcd\\0\", \"efgh\\0\", \"%s\",   i < 0 ? a1 : 0 < i ? a2 : \"ijkl\");\n+\n+/* { dg-final { scan-tree-dump-times \"_not_eliminated\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_\" 6 \"optimized\" } } */"}, {"sha": "95b0b44bcf07b4994257659db7b57d533c3b0913", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-8.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-8.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -0,0 +1,41 @@\n+/* Test to verify that snprintf can determine the correct range\n+   of lengths of string arguments based on the results of prior\n+   calls to strlen.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void abort (void);\n+size_t strlen (const char *);\n+int snprintf (char * restrict, size_t, const char *restrict, ...);\n+\n+void one_str_exact (const char *str)\n+{\n+  if (1 == strlen (str))\n+    if (1 != snprintf (0, 0, \"%s\", str))\n+      abort ();\n+}\n+\n+void two_str_exact (const char *s1, const char *s2)\n+{\n+  if (1 == strlen (s1) && 2 == strlen (s2))\n+    if (3 != snprintf (0, 0, \"%s%s\", s1, s2))\n+      abort ();\n+}\n+\n+void one_str_maxlen (const char *str)\n+{\n+  if (2 >= strlen (str))\n+    if (2 < snprintf (0, 0, \"%s\", str))\n+      abort ();\n+}\n+\n+void two_str_maxlen (const char *s1, const char *s2)\n+{\n+  if (2 >= strlen (s1) && 3 >= strlen (s2))\n+    if (5 < snprintf (0, 0, \"%s%s\", s1, s2))\n+      abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "9c238ce8bcc5afb681837cc2871e0a5bc0537d01", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-9.c", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-9.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -0,0 +1,163 @@\n+/* Test to verify that --param ssa_name_def_chain_limit can be used to\n+   limit the maximum number of SSA_NAME assignments the built-in code\n+   follows to determine the variable value/string length.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall --param ssa-name-def-chain-limit=4 -fdump-tree-optimized\" } */\n+\n+void abort (void);\n+int sprintf (char * restrict, const char *restrict, ...);\n+\n+void sink (const char*, ...);\n+\n+const char a0[] = \"\";\n+const char a1[] = \"1\";\n+const char a2[] = \"12\";\n+const char a3[] = \"123\";\n+const char a4[] = \"1234\";\n+const char a5[] = \"12345\";\n+const char a6[] = \"123456\";\n+const char a7[] = \"1234567\";\n+const char a8[] = \"12345678\";\n+const char a9[] = \"123456789\";\n+\n+int i0, i1, i2, i3, i4, i5, i6, i7, i8;\n+\n+void g1 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+\n+  sink (p0, p1);\n+\n+  if (sprintf (d, \"%s\", p1) > 2)\n+    abort ();\n+}\n+\n+void g2 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+\n+  sink (p0, p1, p2);\n+\n+  if (sprintf (d, \"%s\", p2) > 3)\n+    abort ();\n+}\n+\n+void g3 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+\n+  sink (p0, p1, p2, p3);\n+\n+  if (sprintf (d, \"%s\", p3) > 4)\n+    abort ();\n+}\n+\n+void g4 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+\n+  sink (p0, p1, p2, p3, p4);\n+\n+  // p4 below is the result of the following five PHI assignments\n+  // and with the limit set to 4 the sprintf call result is not\n+  // determined:\n+  //   iftmp.0_7 = PHI <&a0(2), &a1(3)>\n+  //   iftmp.2_8 = PHI <iftmp.0_7(4), &a2(5)>\n+  //   iftmp.4_9 = PHI <iftmp.2_8(6), &a3(7)>\n+  //   iftmp.6_10 = PHI <iftmp.4_9(8), &a4(9)>\n+  //   iftmp.8_17 = PHI <iftmp.6_10(10), &a5(11)>\n+  //   p4 = iftmp.8_17\n+  extern void keep_g4 (void);\n+  if (sprintf (d, \"%s\", p4) > 5)\n+    keep_g4 ();\n+}\n+\n+void g5 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+  const char *p5 = i5 ? p4 : a6;\n+\n+  sink (p0, p1, p2, p3, p4, p5);\n+\n+  extern void keep_g5 (void);\n+  if (sprintf (d, \"%s\", p5) > 6)\n+    keep_g5 ();\n+\n+  /* { dg-final { scan-tree-dump-times \"keep_g5\" 1 \"optimized\" } } */\n+}\n+\n+void g6 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+  const char *p5 = i5 ? p4 : a6;\n+  const char *p6 = i6 ? p5 : a7;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6);\n+\n+  extern void keep_g6 (void);\n+  if (sprintf (d, \"%s\", p6) > 7)\n+    keep_g6 ();\n+\n+  /* { dg-final { scan-tree-dump-times \"keep_g6\" 1 \"optimized\" } } */\n+}\n+\n+void g7 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+  const char *p5 = i5 ? p4 : a6;\n+  const char *p6 = i6 ? p5 : a7;\n+  const char *p7 = i7 ? p6 : a8;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7);\n+\n+  extern void keep_g7 (void);\n+  if (sprintf (d, \"%s\", p7) > 8)\n+    keep_g7 ();\n+\n+  /* { dg-final { scan-tree-dump-times \"keep_g7\" 1 \"optimized\" } } */\n+}\n+\n+void g8 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+  const char *p5 = i5 ? p4 : a6;\n+  const char *p6 = i6 ? p5 : a7;\n+  const char *p7 = i7 ? p6 : a8;\n+  const char *p8 = i8 ? p7 : a9;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7, p8);\n+\n+  extern void keep_g8 (void);\n+  if (sprintf (d, \"%s\", p8) > 9)\n+    keep_g8 ();\n+\n+  /* { dg-final { scan-tree-dump-times \"keep_g8\" 1 \"optimized\" } } */\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "becba05277b5159ec4963e48c220df6540b0032b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-warn-5.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-5.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -0,0 +1,140 @@\n+/* Test to verify that --param ssa_name_def_chain_limit can be used to\n+   limit the maximum number of SSA_NAME assignments the built-in code\n+   follows.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wformat-truncation=2 --param ssa-name-def-chain-limit=4 -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+int snprintf (char * restrict, size_t, const char *restrict, ...);\n+\n+void sink (const char*, ...);\n+\n+const char a0[] = \"\";\n+const char a1[] = \"1\";\n+const char a2[] = \"12\";\n+const char a3[] = \"123\";\n+const char a4[] = \"1234\";\n+const char a5[] = \"12345\";\n+const char a6[] = \"123456\";\n+const char a7[] = \"1234567\";\n+const char a8[] = \"12345678\";\n+const char a9[] = \"123456789\";\n+\n+int i0, i1, i2, i3, i4, i5, i6, i7, i8;\n+\n+void g1 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+\n+  sink (p0, p1);\n+\n+  snprintf (d, 1, \"%s\", p1);    // { dg-warning \"\\\\\\[-Wformat-truncation\" }\n+}\n+\n+void g2 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+\n+  sink (p0, p1, p2);\n+\n+  snprintf (d, 2, \"%s\", p2);    // { dg-warning \"\\\\\\[-Wformat-truncation\" }\n+}\n+\n+void g3 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+\n+  sink (p0, p1, p2, p3);\n+\n+  snprintf (d, 3, \"%s\", p3);    // { dg-warning \"\\\\\\[-Wformat-truncation\" }\n+}\n+\n+void g4 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+\n+  sink (p0, p1, p2, p3, p4);\n+\n+  // p4 below is the result of the following five PHI assignments\n+  // and with the limit set to 4 the snprintf call is not diagnosed\n+  //   iftmp.0_7 = PHI <&a0(2), &a1(3)>\n+  //   iftmp.2_8 = PHI <iftmp.0_7(4), &a2(5)>\n+  //   iftmp.4_9 = PHI <iftmp.2_8(6), &a3(7)>\n+  //   iftmp.6_10 = PHI <iftmp.4_9(8), &a4(9)>\n+  //   iftmp.8_17 = PHI <iftmp.6_10(10), &a5(11)>\n+  //   p4 = iftmp.8_17\n+  snprintf (d, 4, \"%s\", p4);\n+}\n+\n+void g5 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+  const char *p5 = i5 ? p4 : a6;\n+\n+  sink (p0, p1, p2, p3, p4, p5);\n+\n+  snprintf (d, 5, \"%s\", p5);\n+}\n+\n+void g6 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+  const char *p5 = i5 ? p4 : a6;\n+  const char *p6 = i6 ? p5 : a7;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6);\n+\n+  snprintf (d, 6, \"%s\", p6);\n+}\n+\n+void g7 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+  const char *p5 = i5 ? p4 : a6;\n+  const char *p6 = i6 ? p5 : a7;\n+  const char *p7 = i7 ? p6 : a8;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7);\n+\n+  snprintf (d, 7, \"%s\", p7);\n+}\n+\n+void g8 (char *d)\n+{\n+  const char *p0 = i0 ? a0 : a1;\n+  const char *p1 = i1 ? p0 : a2;\n+  const char *p2 = i2 ? p1 : a3;\n+  const char *p3 = i3 ? p2 : a4;\n+  const char *p4 = i4 ? p3 : a5;\n+  const char *p5 = i5 ? p4 : a6;\n+  const char *p6 = i6 ? p5 : a7;\n+  const char *p7 = i7 ? p6 : a8;\n+  const char *p8 = i8 ? p7 : a9;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7, p8);\n+\n+  snprintf (d, 8, \"%s\", p8);\n+}"}, {"sha": "41f932a41a878f405aeddc2e6a001c78da276e1f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-21.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-21.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -0,0 +1,94 @@\n+/* PR tree-optimization/83431 -Wformat-truncation may incorrectly report\n+   truncation\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern int snprintf (char*, size_t, const char*, ...);\n+extern char* strcpy (char*, const char*);\n+\n+struct S\n+{\n+  char a9[9];\n+  char a5[5];\n+  int x;\n+};\n+\n+\n+void test_assign_nowarn (struct S* s)\n+{\n+  int i = 0;\n+\n+  {\n+    char a9[9] = \"1234\";\n+    snprintf (s[i].a5, sizeof (s[i].a5), \"%s\", a9);         /* { dg-bogus \"\\\\\\[-Wformat-truncation]\" } */\n+  }\n+\n+  {\n+    ++i;\n+    char a8[8] = \"123\";\n+    snprintf (s[i].a5, sizeof (s[i].a5), \"%s\\n\", a8);       /* { dg-bogus \"\\\\\\[-Wformat-truncation]\" } */\n+  }\n+\n+  {\n+    ++i;\n+    char a7[7] = \"12\";\n+    snprintf (s[i].a5, sizeof (s[i].a5), \"[%s]\", a7);       /* { dg-bogus \"\\\\\\[-Wformat-truncation]\" } */\n+  }\n+\n+  {\n+    ++i;\n+    char a6[6] = \"1\";\n+    snprintf (s[i].a5, sizeof (s[i].a5), \"[%s]\\n\", a6);     /* { dg-bogus \"\\\\\\[-Wformat-truncation]\" } */\n+  }\n+}\n+\n+\n+void test_strcpy_nowarn (struct S* s)\n+{\n+  int i = 0;\n+\n+  strcpy (s[i].a9, \"1234\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"%s\", s[i].a9);\n+\n+  ++i;\n+  strcpy (s[i].a9, \"123\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"%s\\n\", s[i].a9);    /* { dg-bogus \"\\\\\\[-Wformat-truncation]\" } */\n+\n+  ++i;\n+  strcpy (s[i].a9, \"12\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"[%s]\", s[i].a9);    /* { dg-bogus \"\\\\\\[-Wformat-truncation]\" } */\n+\n+  ++i;\n+  strcpy (s[i].a9, \"1\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"[%s]\\n\", s[i].a9);  /* { dg-bogus \"\\\\\\[-Wformat-truncation]\" } */\n+}\n+\n+\n+void test_warn (struct S* s)\n+{\n+  int i = 0;\n+  strcpy (s[i].a9, \"12345678\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"%s\", s[i].a9);      /* { dg-warning \"'%s' directive output truncated writing 8 bytes into a region of size 5\" } */\n+\n+  ++i;\n+  strcpy (s[i].a9, \"1234567\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"%s\", s[i].a9);      /* { dg-warning \"'%s' directive output truncated writing 7 bytes into a region of size 5\" } */\n+\n+  ++i;\n+  strcpy (s[i].a9, \"123456\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"%s\", s[i].a9);      /* { dg-warning \"'%s' directive output truncated writing 6 bytes into a region of size 5\" } */\n+\n+  ++i;\n+  strcpy (s[i].a9, \"12345\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"%s\", s[i].a9);      /* { dg-warning \"'snprintf' output truncated before the last format character\" } */\n+\n+  ++i;\n+  strcpy (s[i].a9, \"1234\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \"%s\\n\", s[i].a9);    /* { dg-warning \"output truncated before the last format character\" } */\n+\n+  ++i;\n+  strcpy (s[i].a9, \"123\");\n+  snprintf (s[i].a5, sizeof (s[i].a5), \">%s<\", s[i].a9);    /* { dg-warning \"output truncated before the last format character\" } */\n+}"}, {"sha": "9377ed4f4201e893d4d8ea72a43a5cd067dd5c2b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/dump-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdump-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdump-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdump-4.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -0,0 +1,11 @@\n+/* PR middle-end/87052 - STRING_CST printing incomplete in Gimple dumps\n+   { dg-do compile }\n+   { dg-options \"-fdump-tree-original\" } */\n+\n+void* f (char *d, int c)\n+{\n+  return __builtin_memchr (\"1\\0\\0\", c, 4);\n+}\n+\n+/* Veriy the full string appears in the dump:\n+  { dg-final { scan-tree-dump \"\\\"1\\\\\\\\x00\\\\\\\\x00\\\"\" \"original\" } } */"}, {"sha": "a301d0d2e2b4336235e253a45847ea8b8f030b31", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr83501.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr83501.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr83501.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr83501.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -11,4 +11,4 @@ void f (void)\n     __builtin_abort ();\n }\n \n-/* { dg-final { scan-tree-dump-not \"__builtin_strlen\" \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-not \"__builtin_strlen\" \"strlen1\" } } */"}, {"sha": "079ee745a2c2c4171c5534fcbd3e9b9951103bc5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/strlen-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstrlen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstrlen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstrlen-2.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -12,4 +12,4 @@ void f3 (void)\n   f (__builtin_strlen (s));\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"strlen1\" } } */"}, {"sha": "be7603a4c72dd18413aa7045a9e09408bd6a9e8d", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -419,6 +419,7 @@ extern gimple_opt_pass *make_pass_omp_target_link (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_oacc_device_lower (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_omp_device_lower (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_object_sizes (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_warn_printf (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_strlen (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_fold_builtins (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_post_ipa_warn (gcc::context *ctxt);"}, {"sha": "5c5b83833c8f0ced8d5074fe9f35637a1acfe944", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 697, "deletions": 208, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -55,6 +55,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"attribs.h\"\n #include \"calls.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"tree-scalar-evolution.h\"\n+\n+#include \"vr-values.h\"\n+#include \"gimple-ssa-evrp-analyze.h\"\n \n /* A vector indexed by SSA_NAME_VERSION.  0 means unknown, positive value\n    is an index into strinfo vector, negative value stands for\n@@ -64,6 +70,9 @@ static vec<int> ssa_ver_to_stridx;\n /* Number of currently active string indexes plus one.  */\n static int max_stridx;\n \n+/* Set to true to optimize, false when just checking.  */\n+static bool strlen_optimize;\n+\n /* String information record.  */\n struct strinfo\n {\n@@ -154,7 +163,8 @@ struct decl_stridxlist_map\n \n /* Hash table for mapping decls to a chained list of offset -> idx\n    mappings.  */\n-static hash_map<tree_decl_hash, stridxlist> *decl_to_stridxlist_htab;\n+typedef hash_map<tree_decl_hash, stridxlist> decl_to_stridxlist_htab_t;\n+static decl_to_stridxlist_htab_t *decl_to_stridxlist_htab;\n \n /* Hash table mapping strlen (or strnlen with constant bound and return\n    smaller than bound) calls to stridx instances describing\n@@ -604,14 +614,21 @@ set_endptr_and_length (location_t loc, strinfo *si, tree endptr)\n   si->full_string_p = true;\n }\n \n-/* Return string length, or NULL if it can't be computed.  */\n+/* Return the string length, or NULL if it can't be computed.\n+   The length may but need not be constant.  Instead, it might be\n+   the result of a strlen() call.  */\n \n static tree\n get_string_length (strinfo *si)\n {\n+  /* If the length has already been computed return it if it's exact\n+     (i.e., the string is nul-terminated at NONZERO_CHARS), or return\n+     null if it isn't.  */\n   if (si->nonzero_chars)\n     return si->full_string_p ? si->nonzero_chars : NULL;\n \n+  /* If the string is the result of one of the built-in calls below\n+     attempt to compute the length from the call statement.  */\n   if (si->stmt)\n     {\n       gimple *stmt = si->stmt, *lenstmt;\n@@ -702,6 +719,336 @@ get_string_length (strinfo *si)\n   return si->nonzero_chars;\n }\n \n+/* Dump strlen data to FP for statement STMT.  When non-null, RVALS\n+   points to EVRP info and is used to dump strlen range for non-constant\n+   results.  */\n+\n+DEBUG_FUNCTION void\n+dump_strlen_info (FILE *fp, gimple *stmt, const vr_values *rvals)\n+{\n+  if (stmt)\n+    {\n+      fprintf (fp, \"\\nDumping strlen pass data after \");\n+      print_gimple_expr (fp, stmt, TDF_LINENO);\n+      fputc ('\\n', fp);\n+    }\n+  else\n+    fprintf (fp, \"\\nDumping strlen pass data\\n\");\n+\n+  fprintf (fp, \"max_stridx = %i\\n\", max_stridx);\n+  fprintf (fp, \"ssa_ver_to_stridx has %u elements\\n\",\n+\t   ssa_ver_to_stridx.length ());\n+  fprintf (fp, \"stridx_to_strinfo\");\n+  if (stridx_to_strinfo)\n+    {\n+      fprintf (fp, \" has %u elements\\n\", stridx_to_strinfo->length ());\n+      for (unsigned i = 0; i != stridx_to_strinfo->length (); ++i)\n+\t{\n+\t  if (strinfo *si = (*stridx_to_strinfo)[i])\n+\t    {\n+\t      if (!si->idx)\n+\t\tcontinue;\n+\t      fprintf (fp, \"  idx = %i\", si->idx);\n+\t      if (si->ptr)\n+\t\t{\n+\t\t  fprintf (fp, \", ptr = \");\n+\t\t  print_generic_expr (fp, si->ptr);\n+\t\t}\n+\t      fprintf (fp, \", nonzero_chars = \");\n+\t      print_generic_expr (fp, si->nonzero_chars);\n+\t      if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n+\t\t{\n+\t\t  value_range_kind rng = VR_UNDEFINED;\n+\t\t  wide_int min, max;\n+\t\t  if (rvals)\n+\t\t    {\n+\t\t      const value_range *vr\n+\t\t\t= CONST_CAST (class vr_values *, rvals)\n+\t\t\t->get_value_range (si->nonzero_chars);\n+\t\t      rng = vr->kind ();\n+\t\t      if (range_int_cst_p (vr))\n+\t\t\t{\n+\t\t\t  min = wi::to_wide (vr->min ());\n+\t\t\t  max = wi::to_wide (vr->max ());\n+\t\t\t}\n+\t\t      else\n+\t\t\trng = VR_UNDEFINED;\n+\t\t    }\n+\t\t  else\n+\t\t    rng = get_range_info (si->nonzero_chars, &min, &max);\n+\n+\t\t  if (rng == VR_RANGE || rng == VR_ANTI_RANGE)\n+\t\t    {\n+\t\t      fprintf (fp, \" %s[%llu, %llu]\",\n+\t\t\t       rng == VR_RANGE ? \"\" : \"~\",\n+\t\t\t       (long long) min.to_uhwi (),\n+\t\t\t       (long long) max.to_uhwi ());\n+\t\t    }\n+\t\t}\n+\t      fprintf (fp, \" , refcount = %i\", si->refcount);\n+\t      if (si->stmt)\n+\t\t{\n+\t\t  fprintf (fp, \", stmt = \");\n+\t\t  print_gimple_expr (fp, si->stmt, 0);\n+\t\t}\n+\t      if (si->writable)\n+\t\tfprintf (fp, \", writable\");\n+\t      if (si->full_string_p)\n+\t\tfprintf (fp, \", full_string_p\");\n+\t      if (strinfo *next = get_next_strinfo (si))\n+\t\t{\n+\t\t  fprintf (fp, \", {\");\n+\t\t  do\n+\t\t    fprintf (fp, \"%i%s\", next->idx, next->first ? \", \" : \"\");\n+\t\t  while ((next = get_next_strinfo (next)));\n+\t\t  fprintf (fp, \"}\");\n+\t\t}\n+\t      fputs (\"\\n\", fp);\n+\t    }\n+\t}\n+    }\n+  else\n+    fprintf (fp, \" = null\\n\");\n+\n+  fprintf (fp, \"decl_to_stridxlist_htab\");\n+  if (decl_to_stridxlist_htab)\n+    {\n+      fputs (\"\\n\", fp);\n+      typedef decl_to_stridxlist_htab_t::iterator iter_t;\n+      for (iter_t it = decl_to_stridxlist_htab->begin ();\n+\t   it != decl_to_stridxlist_htab->end (); ++it)\n+\t{\n+\t  tree decl = (*it).first;\n+\t  stridxlist *list = &(*it).second;\n+\t  fprintf (fp, \"  decl = \");\n+\t  print_generic_expr (fp, decl);\n+\t  if (list)\n+\t    {\n+\t      fprintf (fp, \", offsets = {\");\n+\t      for (; list; list = list->next)\n+\t\tfprintf (fp, \"%lli%s\", (long long) list->offset,\n+\t\t\t list->next ? \", \" : \"\");\n+\t      fputs (\"}\", fp);\n+\t    }\n+\t  fputs (\"\\n\", fp);\n+\t}\n+    }\n+  else\n+    fprintf (fp, \" = null\\n\");\n+\n+  if (laststmt.stmt)\n+    {\n+      fprintf (fp, \"laststmt = \");\n+      print_gimple_expr (fp, laststmt.stmt, 0);\n+      fprintf (fp, \", len = \");\n+      print_generic_expr (fp, laststmt.len);\n+      fprintf (fp, \", stridx = %i\\n\", laststmt.stridx);\n+    }\n+}\n+\n+/* Attempt to determine the length of the string SRC.  On success, store\n+   the length in *PDATA and return true.  Otherwise, return false.\n+   VISITED is a bitmap of visited PHI nodes.  RVALS points to EVRP info\n+   and PSSA_DEF_MAX to an SSA_NAME assignment limit used to prevent runaway\n+   recursion.  */\n+\n+static bool\n+get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n+\t\t\t  const vr_values *rvals, unsigned *pssa_def_max)\n+{\n+  int idx = get_stridx (src);\n+  if (!idx)\n+    {\n+      if (TREE_CODE (src) == SSA_NAME)\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (src);\n+\t  if (gimple_code (def_stmt) == GIMPLE_PHI)\n+\t    {\n+\t      if (!*visited)\n+\t\t*visited = BITMAP_ALLOC (NULL);\n+\n+\t      if (!bitmap_set_bit (*visited, SSA_NAME_VERSION (src)))\n+\t\treturn true;\n+\n+\t      if (*pssa_def_max == 0)\n+\t\treturn false;\n+\n+\t      --*pssa_def_max;\n+\n+\t      /* Iterate over the PHI arguments and determine the minimum\n+\t\t and maximum length/size of each and incorporate them into\n+\t\t the overall result.  */\n+\t      gphi *phi = as_a <gphi *> (def_stmt);\n+\t      for (unsigned i = 0; i != gimple_phi_num_args (phi); ++i)\n+\t\t{\n+\t\t  tree arg = gimple_phi_arg_def (phi, i);\n+\t\t  if (arg == gimple_phi_result (def_stmt))\n+\t\t    continue;\n+\n+\t\t  c_strlen_data argdata = { };\n+\t\t  if (get_range_strlen_dynamic (arg, &argdata, visited, rvals,\n+\t\t\t\t\t\tpssa_def_max))\n+\t\t    {\n+\t\t      /* Set the DECL of an unterminated array this argument\n+\t\t\t refers to if one hasn't been found yet.  */\n+\t\t      if (!pdata->decl && argdata.decl)\n+\t\t\tpdata->decl = argdata.decl;\n+\n+\t\t      if (!argdata.minlen\n+\t\t\t  || (integer_zerop (argdata.minlen)\n+\t\t\t      && integer_all_onesp (argdata.maxbound)\n+\t\t\t      && integer_all_onesp (argdata.maxlen)))\n+\t\t\t{\n+\t\t\t  /* Set the upper bound of the length to unbounded.  */\n+\t\t\t  pdata->maxlen = build_all_ones_cst (size_type_node);\n+\t\t\t  continue;\n+\t\t\t}\n+\n+\t\t      /* Adjust the minimum and maximum length determined\n+\t\t\t so far and the upper bound on the array size.  */\n+\t\t      if (!pdata->minlen\n+\t\t\t  || tree_int_cst_lt (argdata.minlen, pdata->minlen))\n+\t\t\tpdata->minlen = argdata.minlen;\n+\t\t      if (!pdata->maxlen\n+\t\t\t  || tree_int_cst_lt (pdata->maxlen, argdata.maxlen))\n+\t\t\tpdata->maxlen = argdata.maxlen;\n+\t\t      if (!pdata->maxbound\n+\t\t\t  || (tree_int_cst_lt (pdata->maxbound,\n+\t\t\t\t\t       argdata.maxbound)\n+\t\t\t      && !integer_all_onesp (argdata.maxbound)))\n+\t\t\tpdata->maxbound = argdata.maxbound;\n+\t\t    }\n+\t\t  else\n+\t\t    pdata->maxlen = build_all_ones_cst (size_type_node);\n+\t\t}\n+\n+\t      return true;\n+\t    }\n+\t}\n+\n+      /* Return success regardless of the result and handle *PDATA\n+\t in the caller.  */\n+      get_range_strlen (src, pdata, 1);\n+      return true;\n+    }\n+\n+  if (idx < 0)\n+    {\n+      /* SRC is a string of constant length.  */\n+      pdata->minlen = build_int_cst (size_type_node, ~idx);\n+      pdata->maxlen = pdata->minlen;\n+      pdata->maxbound = pdata->maxlen;\n+      return true;\n+    }\n+\n+  if (strinfo *si = get_strinfo (idx))\n+    {\n+      pdata->minlen = get_string_length (si);\n+      if (!pdata->minlen\n+\t  && si->nonzero_chars)\n+\t{\n+\t  if (TREE_CODE (si->nonzero_chars) == INTEGER_CST)\n+\t    pdata->minlen = si->nonzero_chars;\n+\t  else if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n+\t    {\n+\t      const value_range *vr\n+\t\t= CONST_CAST (class vr_values *, rvals)\n+\t\t->get_value_range (si->nonzero_chars);\n+\t      if (vr->kind () == VR_RANGE\n+\t\t  && range_int_cst_p (vr))\n+\t\t{\n+\t\t  pdata->minlen = vr->min ();\n+\t\t  pdata->maxlen = vr->max ();\n+\t\t}\n+\t      else\n+\t\tpdata->minlen = build_zero_cst (size_type_node);\n+\t    }\n+\t  else\n+\t    pdata->minlen = build_zero_cst (size_type_node);\n+\n+\t  tree base = si->ptr;\n+\t  if (TREE_CODE (base) == ADDR_EXPR)\n+\t    base = TREE_OPERAND (base, 0);\n+\n+\t  HOST_WIDE_INT off;\n+\t  poly_int64 poff;\n+\t  base = get_addr_base_and_unit_offset (base, &poff);\n+\t  if (base\n+\t      && DECL_P (base)\n+\t      && TREE_CODE (TREE_TYPE (base)) == ARRAY_TYPE\n+\t      && TYPE_SIZE_UNIT (TREE_TYPE (base))\n+\t      && poff.is_constant (&off))\n+\t    {\n+\t      tree basetype = TREE_TYPE (base);\n+\t      tree size = TYPE_SIZE_UNIT (basetype);\n+\t      ++off;   /* Increment for the terminating nul.  */\n+\t      pdata->maxlen = fold_build2 (MINUS_EXPR, size_type_node, size,\n+\t\t\t\t\t   build_int_cst (size_type_node, off));\n+\t      pdata->maxbound = pdata->maxlen;\n+\t    }\n+\t  else\n+\t    pdata->maxlen = build_all_ones_cst (size_type_node);\n+\t}\n+      else if (TREE_CODE (pdata->minlen) == SSA_NAME)\n+\t{\n+\t  const value_range *vr\n+\t    = CONST_CAST (class vr_values *, rvals)\n+\t    ->get_value_range (si->nonzero_chars);\n+\t  if (vr->kind () == VR_RANGE\n+\t      && range_int_cst_p (vr))\n+\t    {\n+\t      pdata->minlen = vr->min ();\n+\t      pdata->maxlen = vr->max ();\n+\t      pdata->maxbound = pdata->maxlen;\n+\t    }\n+\t  else\n+\t    {\n+\t      pdata->minlen = build_zero_cst (size_type_node);\n+\t      pdata->maxlen = build_all_ones_cst (size_type_node);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  pdata->maxlen = pdata->minlen;\n+\t  pdata->maxbound = pdata->minlen;\n+\t}\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Analogous to get_range_strlen but for dynamically created strings,\n+   i.e., those created by calls to strcpy as opposed to just string\n+   constants.\n+   Try to obtain the range of the lengths of the string(s) referenced\n+   by SRC, or the size of the largest array SRC refers to if the range\n+   of lengths cannot be determined, and store all in *PDATA.  RVALS\n+   points to EVRP info.  */\n+\n+void\n+get_range_strlen_dynamic (tree src, c_strlen_data *pdata,\n+\t\t\t  const vr_values *rvals)\n+{\n+  bitmap visited = NULL;\n+\n+  unsigned limit = PARAM_VALUE (PARAM_SSA_NAME_DEF_CHAIN_LIMIT);\n+  if (!get_range_strlen_dynamic (src, pdata, &visited, rvals, &limit))\n+    {\n+      /* On failure extend the length range to an impossible maximum\n+\t (a valid MAXLEN must be less than PTRDIFF_MAX - 1).  Other\n+\t members can stay unchanged regardless.  */\n+      pdata->minlen = ssize_int (0);\n+      pdata->maxlen = build_all_ones_cst (size_type_node);\n+    }\n+  else if (!pdata->minlen)\n+    pdata->minlen = ssize_int (0);\n+\n+  if (visited)\n+    BITMAP_FREE (visited);\n+}\n+\n /* Invalidate string length information for strings whose length\n    might change due to stores in stmt.  */\n \n@@ -4017,84 +4364,232 @@ is_char_type (tree type)\n \t  && TYPE_PRECISION (type) == TYPE_PRECISION (char_type_node));\n }\n \n+/* Check the built-in call at GSI for validity and optimize it.\n+   Return true to let the caller advance *GSI to the statement\n+   in the CFG and false otherwise.  */\n+\n+static bool\n+strlen_check_and_optimize_call (gimple_stmt_iterator *gsi,\n+\t\t\t\tconst vr_values *rvals)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+\n+  if (!flag_optimize_strlen\n+      || !strlen_optimize\n+      || !valid_builtin_call (stmt))\n+    {\n+      /* When not optimizing we must be checking printf calls which\n+\t we do even for user-defined functions when they are declared\n+\t with attribute format.  */\n+      handle_printf_call (gsi, rvals);\n+      return true;\n+    }\n+\n+  tree callee = gimple_call_fndecl (stmt);\n+  switch (DECL_FUNCTION_CODE (callee))\n+    {\n+    case BUILT_IN_STRLEN:\n+    case BUILT_IN_STRNLEN:\n+      handle_builtin_strlen (gsi);\n+      break;\n+    case BUILT_IN_STRCHR:\n+      handle_builtin_strchr (gsi);\n+      break;\n+    case BUILT_IN_STRCPY:\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STPCPY:\n+    case BUILT_IN_STPCPY_CHK:\n+      handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi);\n+      break;\n+\n+    case BUILT_IN_STRNCAT:\n+    case BUILT_IN_STRNCAT_CHK:\n+      handle_builtin_strncat (DECL_FUNCTION_CODE (callee), gsi);\n+      break;\n+\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STPNCPY_CHK:\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCPY_CHK:\n+      handle_builtin_stxncpy (DECL_FUNCTION_CODE (callee), gsi);\n+      break;\n+\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMPCPY_CHK:\n+      handle_builtin_memcpy (DECL_FUNCTION_CODE (callee), gsi);\n+      break;\n+    case BUILT_IN_STRCAT:\n+    case BUILT_IN_STRCAT_CHK:\n+      handle_builtin_strcat (DECL_FUNCTION_CODE (callee), gsi);\n+      break;\n+    case BUILT_IN_MALLOC:\n+    case BUILT_IN_CALLOC:\n+      handle_builtin_malloc (DECL_FUNCTION_CODE (callee), gsi);\n+      break;\n+    case BUILT_IN_MEMSET:\n+      if (handle_builtin_memset (gsi))\n+\treturn false;\n+      break;\n+    case BUILT_IN_MEMCMP:\n+      if (handle_builtin_memcmp (gsi))\n+\treturn false;\n+      break;\n+    case BUILT_IN_STRCMP:\n+    case BUILT_IN_STRNCMP:\n+      if (handle_builtin_string_cmp (gsi))\n+\treturn false;\n+      break;\n+    default:\n+      handle_printf_call (gsi, rvals);\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n+/* Handle an assignment statement at *GSI to a LHS of integral type.\n+   If GSI's basic block needs clean-up of EH, set *CLEANUP_EH to true.  */\n+\n+static void\n+handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree lhs_type = TREE_TYPE (lhs);\n+\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n+  if (code == COND_EXPR)\n+    {\n+      tree cond = gimple_assign_rhs1 (stmt);\n+      enum tree_code cond_code = TREE_CODE (cond);\n+\n+      if (cond_code == EQ_EXPR || cond_code == NE_EXPR)\n+\tfold_strstr_to_strncmp (TREE_OPERAND (cond, 0),\n+\t\t\t\tTREE_OPERAND (cond, 1), stmt);\n+    }\n+  else if (code == EQ_EXPR || code == NE_EXPR)\n+    fold_strstr_to_strncmp (gimple_assign_rhs1 (stmt),\n+\t\t\t    gimple_assign_rhs2 (stmt), stmt);\n+  else if (gimple_assign_load_p (stmt)\n+\t   && TREE_CODE (lhs_type) == INTEGER_TYPE\n+\t   && TYPE_MODE (lhs_type) == TYPE_MODE (char_type_node)\n+\t   && (TYPE_PRECISION (lhs_type)\n+\t       == TYPE_PRECISION (char_type_node))\n+\t   && !gimple_has_volatile_ops (stmt))\n+    {\n+      tree off = integer_zero_node;\n+      unsigned HOST_WIDE_INT coff = 0;\n+      int idx = 0;\n+      tree rhs1 = gimple_assign_rhs1 (stmt);\n+      if (code == MEM_REF)\n+\t{\n+\t  idx = get_stridx (TREE_OPERAND (rhs1, 0));\n+\t  if (idx > 0)\n+\t    {\n+\t      strinfo *si = get_strinfo (idx);\n+\t      if (si\n+\t\t  && si->nonzero_chars\n+\t\t  && TREE_CODE (si->nonzero_chars) == INTEGER_CST\n+\t\t  && (wi::to_widest (si->nonzero_chars)\n+\t\t      >= wi::to_widest (off)))\n+\t\toff = TREE_OPERAND (rhs1, 1);\n+\t      else\n+\t\t/* This case is not useful.  See if get_addr_stridx\n+\t\t   returns something usable.  */\n+\t\tidx = 0;\n+\t    }\n+\t}\n+      if (idx <= 0)\n+\tidx = get_addr_stridx (rhs1, NULL_TREE, &coff);\n+      if (idx > 0)\n+\t{\n+\t  strinfo *si = get_strinfo (idx);\n+\t  if (si\n+\t      && si->nonzero_chars\n+\t      && TREE_CODE (si->nonzero_chars) == INTEGER_CST)\n+\t    {\n+\t      widest_int w1 = wi::to_widest (si->nonzero_chars);\n+\t      widest_int w2 = wi::to_widest (off) + coff;\n+\t      if (w1 == w2\n+\t\t  && si->full_string_p)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Optimizing: \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t\t    }\n+\n+\t\t  /* Reading the final '\\0' character.  */\n+\t\t  tree zero = build_int_cst (lhs_type, 0);\n+\t\t  gimple_set_vuse (stmt, NULL_TREE);\n+\t\t  gimple_assign_set_rhs_from_tree (gsi, zero);\n+\t\t  *cleanup_eh\n+\t\t    |= maybe_clean_or_replace_eh_stmt (stmt,\n+\t\t\t\t\t\t       gsi_stmt (*gsi));\n+\t\t  stmt = gsi_stmt (*gsi);\n+\t\t  update_stmt (stmt);\n+\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"into: \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t\t    }\n+\t\t}\n+\t      else if (w1 > w2)\n+\t\t{\n+\t\t  /* Reading a character before the final '\\0'\n+\t\t     character.  Just set the value range to ~[0, 0]\n+\t\t     if we don't have anything better.  */\n+\t\t  wide_int min, max;\n+\t\t  signop sign = TYPE_SIGN (lhs_type);\n+\t\t  int prec = TYPE_PRECISION (lhs_type);\n+\t\t  value_range_kind vr = get_range_info (lhs, &min, &max);\n+\t\t  if (vr == VR_VARYING\n+\t\t      || (vr == VR_RANGE\n+\t\t\t  && min == wi::min_value (prec, sign)\n+\t\t\t  && max == wi::max_value (prec, sign)))\n+\t\t    set_range_info (lhs, VR_ANTI_RANGE,\n+\t\t\t\t    wi::zero (prec), wi::zero (prec));\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (strlen_to_stridx)\n+    {\n+      tree rhs1 = gimple_assign_rhs1 (stmt);\n+      if (stridx_strlenloc *ps = strlen_to_stridx->get (rhs1))\n+\tstrlen_to_stridx->put (lhs, stridx_strlenloc (*ps));\n+    }\n+}\n+\n /* Attempt to check for validity of the performed access a single statement\n    at *GSI using string length knowledge, and to optimize it.\n    If the given basic block needs clean-up of EH, CLEANUP_EH is set to\n    true.  */\n \n static bool\n-strlen_check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n+check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n+\t\t\t const vr_values *rvals)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n   if (is_gimple_call (stmt))\n     {\n-      tree callee = gimple_call_fndecl (stmt);\n-      if (valid_builtin_call (stmt))\n-\tswitch (DECL_FUNCTION_CODE (callee))\n-\t  {\n-\t  case BUILT_IN_STRLEN:\n-\t  case BUILT_IN_STRNLEN:\n-\t    handle_builtin_strlen (gsi);\n-\t    break;\n-\t  case BUILT_IN_STRCHR:\n-\t    handle_builtin_strchr (gsi);\n-\t    break;\n-\t  case BUILT_IN_STRCPY:\n-\t  case BUILT_IN_STRCPY_CHK:\n-\t  case BUILT_IN_STPCPY:\n-\t  case BUILT_IN_STPCPY_CHK:\n-\t    handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi);\n-\t    break;\n-\n-\t  case BUILT_IN_STRNCAT:\n-\t  case BUILT_IN_STRNCAT_CHK:\n-\t    handle_builtin_strncat (DECL_FUNCTION_CODE (callee), gsi);\n-\t    break;\n-\n-\t  case BUILT_IN_STPNCPY:\n-\t  case BUILT_IN_STPNCPY_CHK:\n-\t  case BUILT_IN_STRNCPY:\n-\t  case BUILT_IN_STRNCPY_CHK:\n-\t    handle_builtin_stxncpy (DECL_FUNCTION_CODE (callee), gsi);\n-\t    break;\n-\n-\t  case BUILT_IN_MEMCPY:\n-\t  case BUILT_IN_MEMCPY_CHK:\n-\t  case BUILT_IN_MEMPCPY:\n-\t  case BUILT_IN_MEMPCPY_CHK:\n-\t    handle_builtin_memcpy (DECL_FUNCTION_CODE (callee), gsi);\n-\t    break;\n-\t  case BUILT_IN_STRCAT:\n-\t  case BUILT_IN_STRCAT_CHK:\n-\t    handle_builtin_strcat (DECL_FUNCTION_CODE (callee), gsi);\n-\t    break;\n-\t  case BUILT_IN_MALLOC:\n-\t  case BUILT_IN_CALLOC:\n-\t    handle_builtin_malloc (DECL_FUNCTION_CODE (callee), gsi);\n-\t    break;\n-\t  case BUILT_IN_MEMSET:\n-\t    if (handle_builtin_memset (gsi))\n-\t      return false;\n-\t    break;\n-\t  case BUILT_IN_MEMCMP:\n-\t    if (handle_builtin_memcmp (gsi))\n-\t      return false;\n-\t    break;\n-\t  case BUILT_IN_STRCMP:\n-\t  case BUILT_IN_STRNCMP:\n-\t    if (handle_builtin_string_cmp (gsi))\n-\t      return false;\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n+      if (!strlen_check_and_optimize_call (gsi, rvals))\n+\treturn false;\n     }\n+  else if (!flag_optimize_strlen || !strlen_optimize)\n+    return true;\n   else if (is_gimple_assign (stmt) && !gimple_clobber_p (stmt))\n     {\n+      /* Handle non-clobbering assignment.  */\n       tree lhs = gimple_assign_lhs (stmt);\n+      tree lhs_type = TREE_TYPE (lhs);\n \n-      if (TREE_CODE (lhs) == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (lhs)))\n+      if (TREE_CODE (lhs) == SSA_NAME && POINTER_TYPE_P (lhs_type))\n \t{\n \t  if (gimple_assign_single_p (stmt)\n \t      || (gimple_assign_cast_p (stmt)\n@@ -4106,117 +4601,10 @@ strlen_check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n \t  else if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n \t    handle_pointer_plus (gsi);\n \t}\n-    else if (TREE_CODE (lhs) == SSA_NAME && INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-      {\n-\tenum tree_code code = gimple_assign_rhs_code (stmt);\n-\tif (code == COND_EXPR)\n-\t  {\n-\t    tree cond = gimple_assign_rhs1 (stmt);\n-\t    enum tree_code cond_code = TREE_CODE (cond);\n-\n-\t    if (cond_code == EQ_EXPR || cond_code == NE_EXPR)\n-\t      fold_strstr_to_strncmp (TREE_OPERAND (cond, 0),\n-\t\t\t\t      TREE_OPERAND (cond, 1), stmt);\n-\t  }\n-\telse if (code == EQ_EXPR || code == NE_EXPR)\n-\t  fold_strstr_to_strncmp (gimple_assign_rhs1 (stmt),\n-\t\t\t\t  gimple_assign_rhs2 (stmt), stmt);\n-\telse if (gimple_assign_load_p (stmt)\n-\t\t && TREE_CODE (TREE_TYPE (lhs)) == INTEGER_TYPE\n-\t\t && TYPE_MODE (TREE_TYPE (lhs)) == TYPE_MODE (char_type_node)\n-\t\t && (TYPE_PRECISION (TREE_TYPE (lhs))\n-\t\t     == TYPE_PRECISION (char_type_node))\n-\t\t && !gimple_has_volatile_ops (stmt))\n-\t  {\n-\t    tree off = integer_zero_node;\n-\t    unsigned HOST_WIDE_INT coff = 0;\n-\t    int idx = 0;\n-\t    tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t    if (code == MEM_REF)\n-\t      {\n-\t\tidx = get_stridx (TREE_OPERAND (rhs1, 0));\n-\t\tif (idx > 0)\n-\t\t  {\n-\t\t    strinfo *si = get_strinfo (idx);\n-\t\t    if (si\n-\t\t\t&& si->nonzero_chars\n-\t\t\t&& TREE_CODE (si->nonzero_chars) == INTEGER_CST\n-\t\t\t&& (wi::to_widest (si->nonzero_chars)\n-\t\t\t    >= wi::to_widest (off)))\n-\t\t      off = TREE_OPERAND (rhs1, 1);\n-\t\t    else\n-\t\t      /* This case is not useful.  See if get_addr_stridx\n-\t\t\t returns something usable.  */\n-\t\t      idx = 0;\n-\t\t  }\n-\t      }\n-\t    if (idx <= 0)\n-\t      idx = get_addr_stridx (rhs1, NULL_TREE, &coff);\n-\t    if (idx > 0)\n-\t      {\n-\t\tstrinfo *si = get_strinfo (idx);\n-\t\tif (si\n-\t\t    && si->nonzero_chars\n-\t\t    && TREE_CODE (si->nonzero_chars) == INTEGER_CST)\n-\t\t  {\n-\t\t    widest_int w1 = wi::to_widest (si->nonzero_chars);\n-\t\t    widest_int w2 = wi::to_widest (off) + coff;\n-\t\t    if (w1 == w2\n-\t\t\t&& si->full_string_p)\n-\t\t      {\n-\t\t\tif (dump_file && (dump_flags & TDF_DETAILS) != 0)\n-\t\t\t  {\n-\t\t\t    fprintf (dump_file, \"Optimizing: \");\n-\t\t\t    print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-\t\t\t  }\n-\n-\t\t\t/* Reading the final '\\0' character.  */\n-\t\t\ttree zero = build_int_cst (TREE_TYPE (lhs), 0);\n-\t\t\tgimple_set_vuse (stmt, NULL_TREE);\n-\t\t\tgimple_assign_set_rhs_from_tree (gsi, zero);\n-\t\t\t*cleanup_eh\n-\t\t\t  |= maybe_clean_or_replace_eh_stmt (stmt,\n-\t\t\t\t\t\t\t     gsi_stmt (*gsi));\n-\t\t\tstmt = gsi_stmt (*gsi);\n-\t\t\tupdate_stmt (stmt);\n-\n-\t\t\tif (dump_file && (dump_flags & TDF_DETAILS) != 0)\n-\t\t\t  {\n-\t\t\t    fprintf (dump_file, \"into: \");\n-\t\t\t    print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-\t\t\t  }\n-\t\t      }\n-\t\t    else if (w1 > w2)\n-\t\t      {\n-\t\t\t/* Reading a character before the final '\\0'\n-\t\t\t   character.  Just set the value range to ~[0, 0]\n-\t\t\t   if we don't have anything better.  */\n-\t\t\twide_int min, max;\n-\t\t\ttree type = TREE_TYPE (lhs);\n-\t\t\tenum value_range_kind vr\n-\t\t\t  = get_range_info (lhs, &min, &max);\n-\t\t\tif (vr == VR_VARYING\n-\t\t\t    || (vr == VR_RANGE\n-\t\t\t\t&& min == wi::min_value (TYPE_PRECISION (type),\n-\t\t\t\t\t\t\t TYPE_SIGN (type))\n-\t\t\t\t&& max == wi::max_value (TYPE_PRECISION (type),\n-\t\t\t\t\t\t\t TYPE_SIGN (type))))\n-\t\t\t  set_range_info (lhs, VR_ANTI_RANGE,\n-\t\t\t\t\t  wi::zero (TYPE_PRECISION (type)),\n-\t\t\t\t\t  wi::zero (TYPE_PRECISION (type)));\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\tif (strlen_to_stridx)\n-\t  {\n-\t    tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t    if (stridx_strlenloc *ps = strlen_to_stridx->get (rhs1))\n-\t      strlen_to_stridx->put (lhs, stridx_strlenloc (*ps));\n-\t  }\n-      }\n-    else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n+      else if (TREE_CODE (lhs) == SSA_NAME && INTEGRAL_TYPE_P (lhs_type))\n+\t/* Handle assignment to a character.  */\n+\thandle_integral_assign (gsi, cleanup_eh);\n+      else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n       {\n \ttree type = TREE_TYPE (lhs);\n \tif (TREE_CODE (type) == ARRAY_TYPE)\n@@ -4312,12 +4700,18 @@ class strlen_dom_walker : public dom_walker\n {\n public:\n   strlen_dom_walker (cdi_direction direction)\n-    : dom_walker (direction), m_cleanup_cfg (false)\n+    : dom_walker (direction),\n+    evrp (false),\n+    m_cleanup_cfg (false)\n   {}\n \n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n+  /* EVRP analyzer used for printf argument range processing, and\n+     to track strlen results across integer variable assignments.  */\n+  evrp_range_analyzer evrp;\n+\n   /* Flag that will trigger TODO_cleanup_cfg to be returned in strlen\n      execute function.  */\n   bool m_cleanup_cfg;\n@@ -4329,6 +4723,8 @@ class strlen_dom_walker : public dom_walker\n edge\n strlen_dom_walker::before_dom_children (basic_block bb)\n {\n+  evrp.enter (bb);\n+\n   basic_block dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n \n   if (dombb == NULL)\n@@ -4402,8 +4798,16 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n \n   /* Attempt to optimize individual statements.  */\n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n-    if (strlen_check_and_optimize_stmt (&gsi, &cleanup_eh))\n-      gsi_next (&gsi);\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+\n+      /* First record ranges generated by this statement so they\n+\t can be used by printf argument processing.  */\n+      evrp.record_ranges_from_stmt (stmt, false);\n+\n+      if (check_and_optimize_stmt (&gsi, &cleanup_eh, evrp.get_vr_values ()))\n+\tgsi_next (&gsi);\n+    }\n \n   if (cleanup_eh && gimple_purge_dead_eh_edges (bb))\n       m_cleanup_cfg = true;\n@@ -4420,6 +4824,8 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n void\n strlen_dom_walker::after_dom_children (basic_block bb)\n {\n+  evrp.leave (bb);\n+\n   if (bb->aux)\n     {\n       stridx_to_strinfo = ((vec<strinfo *, va_heap, vl_embed> *) bb->aux);\n@@ -4437,39 +4843,13 @@ strlen_dom_walker::after_dom_children (basic_block bb)\n     }\n }\n \n-/* Main entry point.  */\n-\n namespace {\n \n-const pass_data pass_data_strlen =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"strlen\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_STRLEN, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_strlen : public gimple_opt_pass\n+static unsigned int\n+printf_strlen_execute (function *fun, bool warn_only)\n {\n-public:\n-  pass_strlen (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_strlen, ctxt)\n-  {}\n+  strlen_optimize = !warn_only;\n \n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_optimize_strlen != 0; }\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_strlen\n-\n-unsigned int\n-pass_strlen::execute (function *fun)\n-{\n   gcc_assert (!strlen_to_stridx);\n   if (warn_stringop_overflow || warn_stringop_truncation)\n     strlen_to_stridx = new hash_map<tree, stridx_strlenloc> ();\n@@ -4479,10 +4859,17 @@ pass_strlen::execute (function *fun)\n \n   calculate_dominance_info (CDI_DOMINATORS);\n \n+  bool use_scev = optimize > 0 && flag_printf_return_value;\n+  if (use_scev)\n+    {\n+      loop_optimizer_init (LOOPS_NORMAL);\n+      scev_initialize ();\n+    }\n+\n   /* String length optimization is implemented as a walk of the dominator\n      tree and a forward walk of statements within each block.  */\n   strlen_dom_walker walker (CDI_DOMINATORS);\n-  walker.walk (fun->cfg->x_entry_block_ptr);\n+  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n \n   ssa_ver_to_stridx.release ();\n   strinfo_pool.release ();\n@@ -4503,11 +4890,113 @@ pass_strlen::execute (function *fun)\n       strlen_to_stridx = NULL;\n     }\n \n+  if (use_scev)\n+    {\n+      scev_finalize ();\n+      loop_optimizer_finalize ();\n+    }\n+\n+  /* Clean up object size info.  */\n+  fini_object_sizes ();\n+\n   return walker.m_cleanup_cfg ? TODO_cleanup_cfg : 0;\n }\n \n+/* This file defines two passes: one for warnings that runs only when\n+   optimization is disabled, and another that implements optimizations\n+   and also issues warnings.  */\n+\n+const pass_data pass_data_warn_printf =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"warn-printf\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  /* Normally an optimization pass would require PROP_ssa but because\n+     this pass runs early, with no optimization, to do sprintf format\n+     checking, it only requires PROP_cfg.  */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_warn_printf : public gimple_opt_pass\n+{\n+public:\n+  pass_warn_printf (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_warn_printf, ctxt)\n+  {}\n+\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *fun)\n+  {\n+    return printf_strlen_execute (fun, true);\n+  }\n+};\n+\n+\n+/* Return true to run the warning pass only when not optimizing and\n+   iff either -Wformat-overflow or -Wformat-truncation is specified.  */\n+\n+bool\n+pass_warn_printf::gate (function *)\n+{\n+  return !optimize && (warn_format_overflow > 0 || warn_format_trunc > 0);\n+}\n+\n+const pass_data pass_data_strlen =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"strlen\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_STRLEN, /* tv_id */\n+  PROP_cfg | PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_strlen : public gimple_opt_pass\n+{\n+public:\n+  pass_strlen (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_strlen, ctxt)\n+  {}\n+\n+  opt_pass * clone () { return new pass_strlen (m_ctxt); }\n+\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *fun)\n+  {\n+    return printf_strlen_execute (fun, false);\n+  }\n+};\n+\n+/* Return true to run the pass only when the sprintf and/or strlen\n+   optimizations are enabled and -Wformat-overflow or -Wformat-truncation\n+   are specified.  */\n+\n+bool\n+pass_strlen::gate (function *)\n+{\n+  return ((warn_format_overflow > 0\n+\t   || warn_format_trunc > 0\n+\t   || flag_optimize_strlen > 0\n+\t   || flag_printf_return_value)\n+\t  && optimize > 0);\n+}\n+\n } // anon namespace\n \n+gimple_opt_pass *\n+make_pass_warn_printf (gcc::context *ctxt)\n+{\n+  return new pass_warn_printf (ctxt);\n+}\n+\n gimple_opt_pass *\n make_pass_strlen (gcc::context *ctxt)\n {"}, {"sha": "4d43fc65e9eef6f26f9d70675d57be0f78cddf6a", "filename": "gcc/tree-ssa-strlen.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftree-ssa-strlen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftree-ssa-strlen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.h?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -25,4 +25,11 @@ extern bool is_strlen_related_p (tree, tree);\n extern bool maybe_diag_stxncpy_trunc (gimple_stmt_iterator, tree, tree);\n extern tree set_strlen_range (tree, wide_int, wide_int, tree = NULL_TREE);\n \n+struct c_strlen_data;\n+class vr_values;\n+extern void get_range_strlen_dynamic (tree , c_strlen_data *, const vr_values *);\n+\n+/* APIs internal to strlen pass.  Defined in in gimple-ssa-sprintf.c.  */\n+extern bool handle_printf_call (gimple_stmt_iterator *,  const vr_values *);\n+\n #endif   // GCC_TREE_SSA_STRLEN_H"}, {"sha": "5ec4d17f23b2d752e0455f4fb4d0e004a5409159", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -369,7 +369,7 @@ value_range_base::singleton_p (tree *result) const\n tree\n value_range_base::type () const\n {\n-  gcc_assert (m_min || undefined_p ());\n+  gcc_assert (m_min);\n   return TREE_TYPE (min ());\n }\n "}, {"sha": "96c764c987be96f71f5b4369d85e77f461130582", "filename": "gcc/vr-values.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fca489eaf98f2691772b51773a1e4eb7bb4ef2/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=22fca489eaf98f2691772b51773a1e4eb7bb4ef2", "patch": "@@ -234,7 +234,7 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n \t called, if we are anyway, keep it VARYING.  */\n       if (old_vr->varying_p ())\n \t{\n-\t  new_vr->set_varying (new_vr->type ());\n+\t  new_vr->set_varying (TREE_TYPE (var));\n \t  is_new = false;\n \t}\n       else if (new_vr->undefined_p ())"}]}