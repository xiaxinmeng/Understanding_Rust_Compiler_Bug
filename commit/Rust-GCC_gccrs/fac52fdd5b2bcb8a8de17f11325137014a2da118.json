{"sha": "fac52fdd5b2bcb8a8de17f11325137014a2da118", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFjNTJmZGQ1YjJiY2I4YThkZTE3ZjExMzI1MTM3MDE0YTJkYTExOA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-06-25T10:38:13Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-06-25T10:38:13Z"}, "message": "re PR middle-end/40493 (New SRA miscompiled binutils)\n\n2009-06-25  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/40493\n\t* tree-sra.c (sra_modify_expr): Correct BIT_FIELD_REF argument numbers.\n\t(enum unscalarized_data_handling): New type.\n\t(handle_unscalarized_data_in_subtree): Return what has been done.\n\t(load_assign_lhs_subreplacements): Handle left flushes differently.\n\t(sra_modify_assign): Use unscalarized_data_handling, simplified\n\tcondition determining whether to remove the statement.\n\n\t* testsuite/gcc.c-torture/execute/pr40493.c: New test.\n\nFrom-SVN: r148941", "tree": {"sha": "718da72732da433bf3f10ba2b58f028bd36e7d32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/718da72732da433bf3f10ba2b58f028bd36e7d32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fac52fdd5b2bcb8a8de17f11325137014a2da118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac52fdd5b2bcb8a8de17f11325137014a2da118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fac52fdd5b2bcb8a8de17f11325137014a2da118", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac52fdd5b2bcb8a8de17f11325137014a2da118/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a31c32ba59f8772f3bdf62b7f74523d0a0a4583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a31c32ba59f8772f3bdf62b7f74523d0a0a4583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a31c32ba59f8772f3bdf62b7f74523d0a0a4583"}], "stats": {"total": 169, "additions": 139, "deletions": 30}, "files": [{"sha": "1141473fad273a0ca8e4fba895fb2ac3a8f32c81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac52fdd5b2bcb8a8de17f11325137014a2da118/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac52fdd5b2bcb8a8de17f11325137014a2da118/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fac52fdd5b2bcb8a8de17f11325137014a2da118", "patch": "@@ -1,3 +1,13 @@\n+2009-06-25  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/40493\n+\t* tree-sra.c (sra_modify_expr): Correct BIT_FIELD_REF argument numbers.\n+\t(enum unscalarized_data_handling): New type.\n+\t(handle_unscalarized_data_in_subtree): Return what has been done.\n+\t(load_assign_lhs_subreplacements): Handle left flushes differently.\n+\t(sra_modify_assign): Use unscalarized_data_handling, simplified\n+\tcondition determining whether to remove the statement.\n+\n 2009-06-25  Basile Starynkevitch  <basile@starynkevitch.net>\n \t* doc/plugins.texi (Building GCC plugins): Corrected typo in\n \tMakefile excerpt - @ should be doubled for texinfo."}, {"sha": "91b9293b096616cae6c4e11e7f11c2ae20222dc1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac52fdd5b2bcb8a8de17f11325137014a2da118/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac52fdd5b2bcb8a8de17f11325137014a2da118/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fac52fdd5b2bcb8a8de17f11325137014a2da118", "patch": "@@ -1,3 +1,8 @@\n+2009-06-25  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/40493\n+\t* testsuite/gcc.c-torture/execute/pr40493.c: New test.\n+\n 2009-06-24  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/40342"}, {"sha": "c30786525eaea247d1931a3b9bdb9f3c83b77ed7", "filename": "gcc/testsuite/gcc.c-torture/execute/pr40493.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac52fdd5b2bcb8a8de17f11325137014a2da118/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr40493.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac52fdd5b2bcb8a8de17f11325137014a2da118/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr40493.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr40493.c?ref=fac52fdd5b2bcb8a8de17f11325137014a2da118", "patch": "@@ -0,0 +1,82 @@\n+extern void abort (void);\n+\n+typedef union i386_operand_type\n+{\n+  struct\n+    {\n+      unsigned int reg8:1;\n+      unsigned int reg16:1;\n+      unsigned int reg32:1;\n+      unsigned int reg64:1;\n+      unsigned int floatreg:1;\n+      unsigned int regmmx:1;\n+      unsigned int regxmm:1;\n+      unsigned int regymm:1;\n+      unsigned int control:1;\n+      unsigned int debug:1;\n+      unsigned int test:1;\n+      unsigned int sreg2:1;\n+      unsigned int sreg3:1;\n+      unsigned int imm1:1;\n+      unsigned int imm8:1;\n+      unsigned int imm8s:1;\n+      unsigned int imm16:1;\n+      unsigned int imm32:1;\n+      unsigned int imm32s:1;\n+      unsigned int imm64:1;\n+      unsigned int disp8:1;\n+      unsigned int disp16:1;\n+      unsigned int disp32:1;\n+      unsigned int disp32s:1;\n+      unsigned int disp64:1;\n+      unsigned int acc:1;\n+      unsigned int floatacc:1;\n+      unsigned int baseindex:1;\n+      unsigned int inoutportreg:1;\n+      unsigned int shiftcount:1;\n+      unsigned int jumpabsolute:1;\n+      unsigned int esseg:1;\n+      unsigned int regmem:1;\n+      unsigned int mem:1;\n+      unsigned int byte:1;\n+      unsigned int word:1;\n+      unsigned int dword:1;\n+      unsigned int fword:1;\n+      unsigned int qword:1;\n+      unsigned int tbyte:1;\n+      unsigned int xmmword:1;\n+      unsigned int ymmword:1;\n+      unsigned int unspecified:1;\n+      unsigned int anysize:1;\n+    } bitfield;\n+  unsigned int array[2];\n+} i386_operand_type;\n+\n+unsigned int x00, x01, y00, y01;\n+\n+int main (int argc, char *argv[])\n+{\n+  i386_operand_type a,b,c,d;\n+\n+  a.bitfield.reg16 = 1;\n+  a.bitfield.imm16 = 0;\n+  a.array[1] = 22;\n+\n+  b = a;\n+  x00 = b.array[0];\n+  x01 = b.array[1];\n+\n+  c = b;\n+  y00 = c.array[0];\n+  y01 = c.array[1];\n+\n+  d = c;\n+  if (d.bitfield.reg16 != 1)\n+    abort();\n+  if (d.bitfield.imm16 != 0)\n+    abort();\n+  if (d.array[1] != 22)\n+    abort();\n+\n+  return 0;\n+}"}, {"sha": "d26e03b50953424e57f2f5fb6142ac19e2cb1e88", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac52fdd5b2bcb8a8de17f11325137014a2da118/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac52fdd5b2bcb8a8de17f11325137014a2da118/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fac52fdd5b2bcb8a8de17f11325137014a2da118", "patch": "@@ -1907,8 +1907,8 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write,\n \t  && host_integerp (TREE_OPERAND (bfr, 1), 1)\n \t  && host_integerp (TREE_OPERAND (bfr, 2), 1))\n \t{\n-\t  start_offset = tree_low_cst (TREE_OPERAND (bfr, 1), 1);\n-\t  chunk_size = tree_low_cst (TREE_OPERAND (bfr, 2), 1);\n+\t  chunk_size = tree_low_cst (TREE_OPERAND (bfr, 1), 1);\n+\t  start_offset = tree_low_cst (TREE_OPERAND (bfr, 2), 1);\n \t}\n       else\n \tstart_offset = chunk_size = 0;\n@@ -1919,20 +1919,33 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write,\n   return true;\n }\n \n+/* Where scalar replacements of the RHS have been written to when a replacement\n+   of a LHS of an assigments cannot be direclty loaded from a replacement of\n+   the RHS. */\n+enum unscalarized_data_handling { SRA_UDH_NONE,  /* Nothing done so far. */\n+\t\t\t\t  SRA_UDH_RIGHT, /* Data flushed to the RHS. */\n+\t\t\t\t  SRA_UDH_LEFT }; /* Data flushed to the LHS. */\n+\n /* Store all replacements in the access tree rooted in TOP_RACC either to their\n    base aggregate if there are unscalarized data or directly to LHS\n    otherwise.  */\n \n-static void\n+static enum unscalarized_data_handling\n handle_unscalarized_data_in_subtree (struct access *top_racc, tree lhs,\n \t\t\t\t     gimple_stmt_iterator *gsi)\n {\n   if (top_racc->grp_unscalarized_data)\n-    generate_subtree_copies (top_racc->first_child, top_racc->base, 0, 0, 0,\n-\t\t\t     gsi, false, false);\n+    {\n+      generate_subtree_copies (top_racc->first_child, top_racc->base, 0, 0, 0,\n+\t\t\t       gsi, false, false);\n+      return SRA_UDH_RIGHT;\n+    }\n   else\n-    generate_subtree_copies (top_racc->first_child, lhs, top_racc->offset,\n-\t\t\t     0, 0, gsi, false, false);\n+    {\n+      generate_subtree_copies (top_racc->first_child, lhs, top_racc->offset,\n+\t\t\t       0, 0, gsi, false, false);\n+      return SRA_UDH_LEFT;\n+    }\n }\n \n \n@@ -1951,7 +1964,8 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t\t\t\t HOST_WIDE_INT right_offset,\n \t\t\t\t gimple_stmt_iterator *old_gsi,\n \t\t\t\t gimple_stmt_iterator *new_gsi,\n-\t\t\t\t bool *refreshed, tree lhs)\n+\t\t\t\t enum unscalarized_data_handling *refreshed,\n+\t\t\t\t tree lhs)\n {\n   do\n     {\n@@ -1975,30 +1989,31 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \n \t      /* No suitable access on the right hand side, need to load from\n \t\t the aggregate.  See if we have to update it first... */\n-\t      if (!*refreshed)\n+\t      if (*refreshed == SRA_UDH_NONE)\n+\t\t*refreshed = handle_unscalarized_data_in_subtree (top_racc,\n+\t\t\t\t\t\t\t\t  lhs, old_gsi);\n+\n+\t      if (*refreshed == SRA_UDH_LEFT)\n+\t\trhs = unshare_expr (lacc->expr);\n+\t      else\n \t\t{\n-\t\t  gcc_assert (top_racc->first_child);\n-\t\t  handle_unscalarized_data_in_subtree (top_racc, lhs, old_gsi);\n-\t\t  *refreshed = true;\n+\t\t  rhs = unshare_expr (top_racc->base);\n+\t\t  repl_found = build_ref_for_offset (&rhs,\n+\t\t\t\t\t\t     TREE_TYPE (top_racc->base),\n+\t\t\t\t\t\t     offset, lacc->type, false);\n+\t\t  gcc_assert (repl_found);\n \t\t}\n-\n-\t      rhs = unshare_expr (top_racc->base);\n-\t      repl_found = build_ref_for_offset (&rhs,\n-\t\t\t\t\t\t TREE_TYPE (top_racc->base),\n-\t\t\t\t\t\t offset, lacc->type, false);\n-\t      gcc_assert (repl_found);\n \t    }\n \n \t  stmt = gimple_build_assign (get_access_replacement (lacc), rhs);\n \t  gsi_insert_after (new_gsi, stmt, GSI_NEW_STMT);\n \t  update_stmt (stmt);\n \t  sra_stats.subreplacements++;\n \t}\n-      else if (lacc->grp_read && !lacc->grp_covered && !*refreshed)\n-\t{\n-\t  handle_unscalarized_data_in_subtree (top_racc, lhs, old_gsi);\n-\t  *refreshed = true;\n-\t}\n+      else if (*refreshed == SRA_UDH_NONE\n+\t       && lacc->grp_read && !lacc->grp_covered)\n+\t*refreshed = handle_unscalarized_data_in_subtree (top_racc, lhs,\n+\t\t\t\t\t\t\t  old_gsi);\n \n       if (lacc->first_child)\n \tload_assign_lhs_subreplacements (lacc->first_child, top_racc,\n@@ -2204,20 +2219,17 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (access_has_children_p (lacc) && access_has_children_p (racc))\n \t{\n \t  gimple_stmt_iterator orig_gsi = *gsi;\n-\t  bool refreshed;\n+\t  enum unscalarized_data_handling refreshed;\n \n \t  if (lacc->grp_read && !lacc->grp_covered)\n-\t    {\n-\t      handle_unscalarized_data_in_subtree (racc, lhs, gsi);\n-\t      refreshed = true;\n-\t    }\n+\t    refreshed = handle_unscalarized_data_in_subtree (racc, lhs, gsi);\n \t  else\n-\t    refreshed = false;\n+\t    refreshed = SRA_UDH_NONE;\n \n \t  load_assign_lhs_subreplacements (lacc->first_child, racc,\n \t\t\t\t\t   lacc->offset, racc->offset,\n \t\t\t\t\t   &orig_gsi, gsi, &refreshed, lhs);\n-\t  if (!refreshed || !racc->grp_unscalarized_data)\n+\t  if (refreshed != SRA_UDH_RIGHT)\n \t    {\n \t      if (*stmt == gsi_stmt (*gsi))\n \t\tgsi_next (gsi);"}]}