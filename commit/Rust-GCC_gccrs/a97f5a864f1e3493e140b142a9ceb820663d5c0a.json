{"sha": "a97f5a864f1e3493e140b142a9ceb820663d5c0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk3ZjVhODY0ZjFlMzQ5M2UxNDBiMTQyYTljZWI4MjA2NjNkNWMwYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-23T16:56:28Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-23T16:56:28Z"}, "message": "(expand_increment): Don't store directly ito a subreg\nthat is narrower than a word.\n\nFrom-SVN: r5433", "tree": {"sha": "9b2ecd4ac2fa497df584477021bbf38faf4c3d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b2ecd4ac2fa497df584477021bbf38faf4c3d4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a97f5a864f1e3493e140b142a9ceb820663d5c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97f5a864f1e3493e140b142a9ceb820663d5c0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a97f5a864f1e3493e140b142a9ceb820663d5c0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97f5a864f1e3493e140b142a9ceb820663d5c0a/comments", "author": null, "committer": null, "parents": [{"sha": "672fd7e23872348476fea0af028ae867d7160f37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672fd7e23872348476fea0af028ae867d7160f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/672fd7e23872348476fea0af028ae867d7160f37"}], "stats": {"total": 14, "additions": 12, "deletions": 2}, "files": [{"sha": "87dc0ad50d68989d5f7d29a2e64822b736acde7a", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97f5a864f1e3493e140b142a9ceb820663d5c0a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97f5a864f1e3493e140b142a9ceb820663d5c0a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a97f5a864f1e3493e140b142a9ceb820663d5c0a", "patch": "@@ -7648,6 +7648,10 @@ expand_increment (exp, post)\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n   int op0_is_copy = 0;\n   int single_insn = 0;\n+  /* 1 means we can't store into OP0 directly,\n+     because it is a subreg narrower than a word,\n+     and we don't dare clobber the rest of the word.  */\n+  int bad_subreg = 0;\n \n   if (output_bytecode)\n     {\n@@ -7688,6 +7692,9 @@ expand_increment (exp, post)\n \n   if (GET_CODE (op0) == SUBREG && SUBREG_PROMOTED_VAR_P (op0))\n     SUBREG_REG (op0) = copy_to_reg (SUBREG_REG (op0));\n+  else if (GET_CODE (op0) == SUBREG\n+\t   && GET_MODE_BITSIZE (GET_MODE (op0)) < BITS_PER_WORD)\n+    bad_subreg = 1;\n \n   op0_is_copy = ((GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n \t\t && temp != get_last_insn ());\n@@ -7723,8 +7730,11 @@ expand_increment (exp, post)\n      then we cannot just increment OP0.  We must therefore contrive to\n      increment the original value.  Then, for postincrement, we can return\n      OP0 since it is a copy of the old value.  For preincrement, expand here\n-     unless we can do it with a single insn.  */\n-  if (op0_is_copy || (!post && !single_insn))\n+     unless we can do it with a single insn.\n+\n+     Likewise if storing directly into OP0 would clobber high bits\n+     we need to preserve (bad_subreg).  */\n+  if (op0_is_copy || (!post && !single_insn) || bad_subreg)\n     {\n       /* This is the easiest way to increment the value wherever it is.\n \t Problems with multiple evaluation of INCREMENTED are prevented"}]}