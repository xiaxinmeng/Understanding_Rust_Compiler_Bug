{"sha": "ace3ffcd316976e021c61c58c57a394c21b69045", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNlM2ZmY2QzMTY5NzZlMDIxYzYxYzU4YzU3YTM5NGMyMWI2OTA0NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-06T05:58:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-06T05:58:11Z"}, "message": "reload1.c (eliminate_regs_in_insn): If a set has a REG_EQUAL note containing (plus (reg) (const_int))...\n\n\t* reload1.c (eliminate_regs_in_insn): If a set has a REG_EQUAL\n\tnote containing (plus (reg) (const_int)), where reg is an\n\teliminable reg, then perform the register elimination without\n\tdepending on eliminate_regs().\n\nFrom-SVN: r77378", "tree": {"sha": "069e6abdb4fa637c3c8989691451d99fc06b5044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/069e6abdb4fa637c3c8989691451d99fc06b5044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ace3ffcd316976e021c61c58c57a394c21b69045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace3ffcd316976e021c61c58c57a394c21b69045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ace3ffcd316976e021c61c58c57a394c21b69045", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace3ffcd316976e021c61c58c57a394c21b69045/comments", "author": null, "committer": null, "parents": [{"sha": "78bc94a2a8a20a2c3443d42b04cd4d8486f2ed41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bc94a2a8a20a2c3443d42b04cd4d8486f2ed41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78bc94a2a8a20a2c3443d42b04cd4d8486f2ed41"}], "stats": {"total": 61, "additions": 50, "deletions": 11}, "files": [{"sha": "5833a503d7955de5cb0d1b409321598ed40790bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace3ffcd316976e021c61c58c57a394c21b69045/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace3ffcd316976e021c61c58c57a394c21b69045/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ace3ffcd316976e021c61c58c57a394c21b69045", "patch": "@@ -1,3 +1,10 @@\n+2004-02-06  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* reload1.c (eliminate_regs_in_insn): If a set has a REG_EQUAL\n+\tnote containing (plus (reg) (const_int)), where reg is an\n+\teliminable reg, then perform the register elimination without\n+\tdepending on eliminate_regs().\n+\n 2004-02-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/arc/arc.c (arc_return_in_memory): Check the return"}, {"sha": "171283c4b55fe85538a8b86c0f56b235ca05749a", "filename": "gcc/reload1.c", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace3ffcd316976e021c61c58c57a394c21b69045/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace3ffcd316976e021c61c58c57a394c21b69045/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ace3ffcd316976e021c61c58c57a394c21b69045", "patch": "@@ -2879,6 +2879,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n   rtx substed_operand[MAX_RECOG_OPERANDS];\n   rtx orig_operand[MAX_RECOG_OPERANDS];\n   struct elim_table *ep;\n+  rtx plus_src;\n \n   if (! insn_is_asm && icode < 0)\n     {\n@@ -2982,17 +2983,40 @@ eliminate_regs_in_insn (rtx insn, int replace)\n     }\n \n   /* We allow one special case which happens to work on all machines we\n-     currently support: a single set with the source being a PLUS of an\n-     eliminable register and a constant.  */\n-  if (old_set\n-      && GET_CODE (SET_DEST (old_set)) == REG\n-      && GET_CODE (SET_SRC (old_set)) == PLUS\n-      && GET_CODE (XEXP (SET_SRC (old_set), 0)) == REG\n-      && GET_CODE (XEXP (SET_SRC (old_set), 1)) == CONST_INT\n-      && REGNO (XEXP (SET_SRC (old_set), 0)) < FIRST_PSEUDO_REGISTER)\n+     currently support: a single set with the source or a REG_EQUAL\n+     note being a PLUS of an eliminable register and a constant.  */\n+  plus_src = 0;\n+  if (old_set && GET_CODE (SET_DEST (old_set)) == REG)\n     {\n-      rtx reg = XEXP (SET_SRC (old_set), 0);\n-      HOST_WIDE_INT offset = INTVAL (XEXP (SET_SRC (old_set), 1));\n+      /* First see if the source is of the form (plus (reg) CST).  */\n+      if (GET_CODE (SET_SRC (old_set)) == PLUS\n+\t  && GET_CODE (XEXP (SET_SRC (old_set), 0)) == REG\n+\t  && GET_CODE (XEXP (SET_SRC (old_set), 1)) == CONST_INT\n+\t  && REGNO (XEXP (SET_SRC (old_set), 0)) < FIRST_PSEUDO_REGISTER)\n+\tplus_src = SET_SRC (old_set);\n+      else if (GET_CODE (SET_SRC (old_set)) == REG)\n+\t{\n+\t  /* Otherwise, see if we have a REG_EQUAL note of the form\n+\t     (plus (reg) CST).  */\n+\t  rtx links;\n+\t  for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n+\t    {\n+\t      if (REG_NOTE_KIND (links) == REG_EQUAL\n+\t\t  && GET_CODE (XEXP (links, 0)) == PLUS\n+\t\t  && GET_CODE (XEXP (XEXP (links, 0), 0)) == REG\n+\t\t  && GET_CODE (XEXP (XEXP (links, 0), 1)) == CONST_INT\n+\t\t  && REGNO (XEXP (XEXP (links, 0), 0)) < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  plus_src = XEXP (links, 0);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (plus_src)\n+    {\n+      rtx reg = XEXP (plus_src, 0);\n+      HOST_WIDE_INT offset = INTVAL (XEXP (plus_src, 1));\n \n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \tif (ep->from_rtx == reg && ep->can_eliminate)\n@@ -3022,7 +3046,12 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\tif (INSN_CODE (insn) < 0)\n \t\t  abort ();\n \t      }\n-\t    else\n+\t    /* If we have a nonzero offset, and the source is already\n+\t       a simple REG, the following transformation would\n+\t       increase the cost of the insn by replacing a simple REG\n+\t       with (plus (reg sp) CST).  So try only when plus_src\n+\t       comes from old_set proper, not REG_NOTES.  */\n+\t    else if (SET_SRC (old_set) == plus_src)\n \t      {\n \t\tnew_body = old_body;\n \t\tif (! replace)\n@@ -3037,6 +3066,9 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\tXEXP (SET_SRC (old_set), 0) = ep->to_rtx;\n \t\tXEXP (SET_SRC (old_set), 1) = GEN_INT (offset);\n \t      }\n+\t    else\n+\t      break;\n+\n \t    val = 1;\n \t    /* This can't have an effect on elimination offsets, so skip right\n \t       to the end.  */"}]}