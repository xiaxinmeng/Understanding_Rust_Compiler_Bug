{"sha": "b1f30bf42d8d47228e52de998f3172b2f5dd7265", "node_id": "C_kwDOANBUbNoAKGIxZjMwYmY0MmQ4ZDQ3MjI4ZTUyZGU5OThmMzE3MmIyZjVkZDcyNjU", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2023-01-16T17:14:45Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2023-01-16T17:14:45Z"}, "message": "Fix wrong code issues with ipa-sra\n\nFix wrong code issues in ipa-sra where we are trying to prove that on every\nexecution of a given function a call to other function will happen.  The code\nuses post dominators and makes a wrong query (which passes only for first BB in\nfunction). Hoever post-dominators are only valid if fake edges for every\npossible reason for fuction execution to terminate are added.\n\nFixing this using postdominators is somewhat costy since one needs to walk\nwhole body and add a lot of fake edges. I ended up implementing a special\npurpose function for this which is also useful in ipa-modref and other places\nthat does similar analysis.  One does not need to modify CFG to use it and\nmoreover for complex functions it usually stops on first unanalyzed function\ncall and ends up being relatively cheap.\n\nBootstrapped/regtested x86_64-linux, plan to commit it shortly.\n\ngcc/ChangeLog:\n\n2023-01-16  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/106077\n\t* ipa-modref.cc (modref_access_analysis::analyze): Use\n\tfind_always_executed_bbs.\n\t* ipa-sra.cc (process_scan_results): Likewise.\n\t* ipa-utils.cc (stmt_may_terminate_function_p): New function.\n\t(find_always_executed_bbs): New function.\n\t* ipa-utils.h (stmt_may_terminate_function_p): Declare.\n\t(find_always_executed_bbs): Declare.\n\ngcc/testsuite/ChangeLog:\n\n2023-01-16  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* g++.dg/tree-ssa/pr106077.C: New test.", "tree": {"sha": "088f21e88e5d378f5524369caf8744ba6b2432fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/088f21e88e5d378f5524369caf8744ba6b2432fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1f30bf42d8d47228e52de998f3172b2f5dd7265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f30bf42d8d47228e52de998f3172b2f5dd7265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1f30bf42d8d47228e52de998f3172b2f5dd7265", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f30bf42d8d47228e52de998f3172b2f5dd7265/comments", "author": null, "committer": null, "parents": [{"sha": "d694a3d57535fbb3737dd583b15b69e0845a5846", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d694a3d57535fbb3737dd583b15b69e0845a5846", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d694a3d57535fbb3737dd583b15b69e0845a5846"}], "stats": {"total": 303, "additions": 285, "deletions": 18}, "files": [{"sha": "e3196df8aa9ded9b1ccee272a252cb0443b4c974", "filename": "gcc/ipa-modref.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Fipa-modref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Fipa-modref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.cc?ref=b1f30bf42d8d47228e52de998f3172b2f5dd7265", "patch": "@@ -1875,11 +1875,11 @@ modref_access_analysis::analyze ()\n      statement cannot be analyzed (for any reason), the entire function cannot\n      be analyzed by modref.  */\n   basic_block bb;\n+  bitmap always_executed_bbs = find_always_executed_bbs (cfun, true);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       gimple_stmt_iterator si;\n-      bool always_executed\n-\t      = bb == single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->dest;\n+      bool always_executed = bitmap_bit_p (always_executed_bbs, bb->index);\n \n       for (si = gsi_start_nondebug_after_labels_bb (bb);\n \t   !gsi_end_p (si); gsi_next_nondebug (&si))\n@@ -1926,6 +1926,7 @@ modref_access_analysis::analyze ()\n \t  && !finite_function_p ())\n \tm_summary_lto->side_effects = true;\n     }\n+  BITMAP_FREE (always_executed_bbs);\n }\n \n /* Return true if OP accesses memory pointed to by SSA_NAME.  */"}, {"sha": "81b75910db1be090d967b1c916b32b32c168f969", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=b1f30bf42d8d47228e52de998f3172b2f5dd7265", "patch": "@@ -2529,7 +2529,8 @@ process_scan_results (cgraph_node *node, struct function *fun,\n      TODO: Measure the overhead and the effect of just being pessimistic.\n      Maybe this is only -O3 material?  */\n \n-  bool pdoms_calculated = false;\n+  hash_map<gimple *, bool> analyzed_stmts;\n+  bitmap always_executed_bbs = NULL;\n   if (check_pass_throughs)\n     for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n       {\n@@ -2566,27 +2567,46 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \t\tcontinue;\n \t      }\n \n-\t    /* Post-dominator check placed last, hoping that it usually won't\n-\t       be needed.  */\n-\t    if (!pdoms_calculated)\n+\t    /* Walk basic block and see if its execution can terminate earlier.\n+\t       Keep the info for later re-use to avoid quadratic behavoiur here.  */\n+\t    gimple_stmt_iterator gsi = gsi_for_stmt (call_stmt);\n+\t    bool safe = true;\n+\t    int n = 0;\n+\t    for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n \t      {\n-\t\tgcc_checking_assert (cfun);\n-\t\tconnect_infinite_loops_to_exit ();\n-\t\tcalculate_dominance_info (CDI_POST_DOMINATORS);\n-\t\tpdoms_calculated = true;\n+\t\tbool *b = analyzed_stmts.get (gsi_stmt (gsi));\n+\t\tif (b)\n+\t\t  {\n+\t\t    safe = *b;\n+\t\t    gsi_next (&gsi);\n+\t\t    break;\n+\t\t  }\n+\t\tn++;\n+\t\tif (stmt_may_terminate_function_p (fun, gsi_stmt (gsi), false))\n+\t\t  {\n+\t\t    safe = false;\n+\t\t    break;\n+\t\t  }\n \t      }\n-\t    if (dominated_by_p (CDI_POST_DOMINATORS,\n-\t\t\t\tgimple_bb (call_stmt),\n-\t\t\t\tsingle_succ (ENTRY_BLOCK_PTR_FOR_FN (fun))))\n+\t    if (n)\n+\t      {\n+\t\tif (gsi_end_p (gsi))\n+\t\t  gsi = gsi_start_bb (gimple_bb (call_stmt));\n+\t\tfor (; gsi_stmt (gsi) != call_stmt; gsi_next (&gsi))\n+\t\t  analyzed_stmts.get_or_insert (gsi_stmt (gsi)) = safe;\n+\t      }\n+\n+\t    if (safe && !always_executed_bbs)\n+\t      {\n+\t\tmark_dfs_back_edges ();\n+\t\talways_executed_bbs = find_always_executed_bbs (fun, false);\n+\t      }\n+\t    if (safe && bitmap_bit_p (always_executed_bbs, gimple_bb (call_stmt)->index))\n \t      csum->m_arg_flow[argidx].safe_to_import_accesses = true;\n \t  }\n \n       }\n-  if (pdoms_calculated)\n-    {\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      remove_fake_exit_edges ();\n-    }\n+  BITMAP_FREE (always_executed_bbs);\n \n   /* TODO: Add early exit if we disqualified everything.  This also requires\n      that we either relax the restriction that"}, {"sha": "3d5633340f11a51aeb4b40dd208dba01f7e1a9c6", "filename": "gcc/ipa-utils.cc", "status": "modified", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Fipa-utils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Fipa-utils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.cc?ref=b1f30bf42d8d47228e52de998f3172b2f5dd7265", "patch": "@@ -35,6 +35,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vrp.h\"\n #include \"ipa-prop.h\"\n #include \"ipa-fnsummary.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-iterator.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n+#include \"tree-ssa-loop-niter.h\"\n \n /* Debugging function for postorder and inorder code. NOTE is a string\n    that is printed before the nodes are printed.  ORDER is an array of\n@@ -781,3 +786,220 @@ recursive_call_p (tree func, tree dest)\n       return false;\n   return true;\n }\n+\n+/* Return true if stmt may terminate execution of function.\n+   If assume_return_or_eh we can further assume that the function ends\n+   either by retrn statement or EH (no trapping or infinite loops).  */\n+\n+bool\n+stmt_may_terminate_function_p (function *fun, gimple *stmt, bool assume_return_or_eh)\n+{\n+  if (stmt_can_throw_external (fun, stmt))\n+    return true;\n+  gasm *astmt = dyn_cast <gasm *> (stmt);\n+  if (astmt && gimple_asm_volatile_p (astmt))\n+    return true;\n+  if (assume_return_or_eh)\n+    return false;\n+  if (gimple_could_trap_p (stmt))\n+    return true;\n+  if (gcall *call = dyn_cast <gcall *> (stmt))\n+    {\n+      int flags = gimple_call_flags (call);\n+      if (flags & (ECF_PURE | ECF_CONST) && ! (flags & ECF_LOOPING_CONST_OR_PURE))\n+\treturn false;\n+      modref_summary *s = get_modref_function_summary (call, NULL);\n+      if (s && !s->side_effects)\n+\treturn false;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return bitmap of all basic blocks whose first statements are known to\n+   execute on every invocation of the function.\n+\n+   If assume_return_or_eh we can further assume that the function ends\n+   either by retrn statement or EH (no trapping or infinite loops).\n+   This is useful when sumarizing function in passes like ipa-modref.\n+ \n+   Seeing assume_return_or_eh to false is used to prove that given\n+   statmeent will be executed even if the function gets into infinite\n+   loop or trap.  */\n+bitmap\n+find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n+{\n+  auto_vec<basic_block, 20> stack;\n+  auto_vec<basic_block, 20> terminating_bbs;\n+  hash_set<basic_block> visited;\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* First walk all BBs reachable from entry stopping on statements that may\n+     terminate execution.  Everything past this statement is not going to be executed\n+     each invocation.  */\n+  stack.safe_push (ENTRY_BLOCK_PTR_FOR_FN (fun));\n+  while (!stack.is_empty ())\n+    {\n+      basic_block bb = stack.pop ();\n+      bool found = false, found_exit = false;\n+      if (!assume_return_or_eh\n+\t  && (EDGE_COUNT (bb->succs) == 0 || (bb->flags & BB_IRREDUCIBLE_LOOP)))\n+\tfound = true;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (fun))\n+\t    {\n+\t      found_exit = true;\n+\t      break;\n+\t    }\n+\t  /* Watch for infinite loops.  */\n+\t  if (!found && (assume_return_or_eh & EDGE_DFS_BACK)\n+\t      && !finite_loop_p (e->src->loop_father))\n+\t    found = true;\n+\t}\n+      for (gimple_stmt_iterator si = gsi_start_nondebug_after_labels_bb (bb);\n+\t   !gsi_end_p (si) && !found; gsi_next_nondebug (&si))\n+\tif (stmt_may_terminate_function_p (fun, gsi_stmt (si), assume_return_or_eh))\n+\t  {\n+\t    found = true;\n+\t    break;\n+\t  }\n+      if (found)\n+\t{\n+\t  visited.add (EXIT_BLOCK_PTR_FOR_FN (fun));\n+\t  if (!found_exit)\n+\t    terminating_bbs.safe_push (bb);\n+\t}\n+      else\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  if (!visited.add (e->dest))\n+\t    stack.safe_push (e->dest);\n+    }\n+\n+  /* Next walk from exit block and find all articulations in the CFG.\n+     Add all terminating basic blocks as \"fake\" predecessors of the\n+     exit block.  */\n+\n+  bitmap ret = BITMAP_ALLOC (NULL);\n+  /* A degenerated case when there is no path to exit.  */\n+  if (!visited.contains (EXIT_BLOCK_PTR_FOR_FN (fun))\n+      && terminating_bbs.is_empty ())\n+    {\n+      bitmap_set_bit (ret,\n+\t\t      single_succ_edge\n+\t\t        (ENTRY_BLOCK_PTR_FOR_FN (fun))->dest->index);\n+      return ret;\n+    }\n+\n+  struct astate\n+  {\n+    unsigned int dfs_preorder;\n+    unsigned int dfs_postorder;\n+\n+    unsigned int low, high;\n+  };\n+\n+  struct worklist\n+  {\n+    basic_block bb;\n+    astate *cstate;\n+  };\n+\n+  struct obstack state_obstack;\n+  gcc_obstack_init (&state_obstack);\n+  hash_map<basic_block, astate *> state;\n+  auto_vec<worklist, 32> worklist_vec;\n+  unsigned int next_dfs_num = 1;\n+\n+  /* Always executed blocks are blocks that are on every path from entry to exit.\n+     We proceed in two steps.  First we do backward DFS walk (so we know that entry\n+     is always reached) and record preorder and postorder visiting times.\n+\n+     In second step we proceed in postorder and for every block A we compute\n+     minimal preorder (A.low) and maximal postorder (A.high) of block reachable\n+     from the BBs in DFS subtree of A.  If A is always executed there are no\n+     edges out of this subtree.  This can be tested by checking that A.low == A.preorder\n+     and B.high == A.postorder.\n+    \n+     This is first step. Do backward DFS walk and record preorder, postorder\n+     and predecessor info.  Initialize stack in postorder.  */\n+  worklist we = {EXIT_BLOCK_PTR_FOR_FN (fun), NULL};\n+  worklist_vec.safe_push (we);\n+  while (!worklist_vec.is_empty ())\n+    {\n+      worklist &w = worklist_vec.last ();\n+      basic_block bb = w.bb;\n+      astate *cstate = w.cstate;\n+\n+      if (!cstate)\n+\t{\n+\t  astate **slot = &state.get_or_insert (bb);\n+\n+\t  cstate = *slot;\n+\t  /* Already processed by DFS?  */\n+\t  if (cstate)\n+\t    {\n+\t      worklist_vec.pop ();\n+\t      continue;\n+\t    }\n+\t  /* DFS is visiting BB for first time.  */\n+\t  *slot = cstate = XOBNEW (&state_obstack, struct astate);\n+\t  cstate->low = cstate->dfs_preorder = next_dfs_num++;\n+\t  w.cstate = cstate;\n+\t  /* Exit block is special; process all fake edges we identified.  */\n+\t  if (bb == EXIT_BLOCK_PTR_FOR_FN (fun))\n+\t    for (basic_block bb2 : terminating_bbs)\n+\t      {\n+\t\tworklist we = {bb2, NULL};\n+\t\tworklist_vec.safe_push (we);\n+\t      }\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    if (visited.contains (e->src))\n+\t      {\n+\t\tworklist we = {e->src, NULL};\n+\t\tworklist_vec.safe_push (we);\n+\t      }\n+\t  /* Keep BB on worklist so we process it last time.  */\n+\t  continue;\n+\t}\n+      /* We are finished with processing reachable BBs, see if we have articulation.  */\n+      worklist_vec.pop ();\n+      cstate->high = cstate->dfs_postorder = next_dfs_num++;\n+      stack.safe_push (bb);\n+    }\n+  /* This is the final postorder walk.  Determine low and high values and mark\n+     always executed blocks.  */\n+  for (basic_block bb : stack)\n+    {\n+      astate *cstate = *state.get (bb);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  astate **cstate2 = state.get (e->src);\n+\t  /* We skip walking part of CFG reached only after first edge to exit.\n+\t     No BB reachable from the skipped part is always executed */\n+\t  if (!cstate2)\n+\t    {\n+\t      if (e->src != ENTRY_BLOCK_PTR_FOR_FN (fun))\n+\t        cstate->low = 0;\n+\t      continue;\n+\t    }\n+\t  cstate->low = MIN (cstate->low, (*cstate2)->low);\n+\t  cstate->high = MAX (cstate->high, (*cstate2)->high);\n+\t}\n+      if (cstate->low == cstate->dfs_preorder && cstate->high == cstate->dfs_postorder\n+\t  && bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n+\tbitmap_set_bit (ret, bb->index);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  astate **cstate2 = state.get (e->dest);\n+\t  if (!cstate2)\n+\t    continue;\n+\t  cstate->low = MIN (cstate->low, (*cstate2)->low);\n+\t  cstate->high = MAX (cstate->high, (*cstate2)->high);\n+\t}\n+    }\n+  obstack_free (&state_obstack, NULL);\n+\n+  return ret;\n+}"}, {"sha": "0eefcf40d4401a18d88325212aa1e1a7f23f376b", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=b1f30bf42d8d47228e52de998f3172b2f5dd7265", "patch": "@@ -46,6 +46,8 @@ tree get_base_var (tree);\n void ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t struct cgraph_node *src, bool preserve_body = false);\n bool recursive_call_p (tree, tree);\n+bool stmt_may_terminate_function_p (function *fun, gimple *stmt, bool assume_return_or_eh);\n+bitmap find_always_executed_bbs (function *fun, bool assume_return_or_eh);\n \n /* In ipa-pure-const.cc  */\n bool finite_function_p ();"}, {"sha": "2c2f7293fa0909cc219d84cac9993e3a9f92bbb3", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr106077.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr106077.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f30bf42d8d47228e52de998f3172b2f5dd7265/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr106077.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr106077.C?ref=b1f30bf42d8d47228e52de998f3172b2f5dd7265", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-ipa-cp -fdump-tree-optimized\" }\n+short e,f;\n+static __attribute__ ((noinline))\n+int a(int *b)\n+{\n+        return *b;\n+}\n+static __attribute__ ((noinline))\n+__attribute__ ((optimize(\"non-call-exceptions\")))\n+int wrap(int *b,int e, int f)\n+{\n+        e/=f;\n+        return a(b)+e;\n+}\n+\n+int\n+t()\n+{\n+        return wrap(0,1,0);\n+}\n+// { dg-final { scan-tree-dump-not \"builtin_trap\" \"optimized\" } }"}]}