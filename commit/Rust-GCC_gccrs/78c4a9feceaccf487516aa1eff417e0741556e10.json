{"sha": "78c4a9feceaccf487516aa1eff417e0741556e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhjNGE5ZmVjZWFjY2Y0ODc1MTZhYTFlZmY0MTdlMDc0MTU1NmUxMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-04T18:10:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-04T18:10:56Z"}, "message": "gimple: Return fnspec only for replaceable new/delete operators called from new/delete [PR98130]\n\nAs mentioned in the PR, we shouldn't treat non-replaceable operator\nnew/delete (e.g. with the placement new) as replaceable ones.\n\nThere is some pending discussion that perhaps operator delete called from\ndelete if not replaceable should return some other fnspec, but can we handle\nthat incrementally, fix this wrong-code and then deal with a missed\noptimization?  I really don't know what exactly should be returned.\n\n2020-12-04  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/98130\n\t* gimple.c (gimple_call_fnspec): Only return \".co \" for replaceable\n\toperator delete or \".mC\" for replaceable operator new called from\n\tnew/delete.\n\n\t* g++.dg/opt/pr98130.C: New test.", "tree": {"sha": "7859396b43ee48402bc959acd0bc4572bb0ee56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7859396b43ee48402bc959acd0bc4572bb0ee56a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78c4a9feceaccf487516aa1eff417e0741556e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c4a9feceaccf487516aa1eff417e0741556e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78c4a9feceaccf487516aa1eff417e0741556e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c4a9feceaccf487516aa1eff417e0741556e10/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac2a6962b91128e700ee52db686dcdb2bab93790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac2a6962b91128e700ee52db686dcdb2bab93790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac2a6962b91128e700ee52db686dcdb2bab93790"}], "stats": {"total": 28, "additions": 27, "deletions": 1}, "files": [{"sha": "bb1345875c261da0d18655c92dc7d805da3930ae", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c4a9feceaccf487516aa1eff417e0741556e10/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c4a9feceaccf487516aa1eff417e0741556e10/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=78c4a9feceaccf487516aa1eff417e0741556e10", "patch": "@@ -1514,11 +1514,12 @@ gimple_call_fnspec (const gcall *stmt)\n      such operator, then we can treat it as free.  */\n   if (fndecl\n       && DECL_IS_OPERATOR_DELETE_P (fndecl)\n+      && DECL_IS_REPLACEABLE_OPERATOR (fndecl)\n       && gimple_call_from_new_or_delete (stmt))\n     return \".co \";\n   /* Similarly operator new can be treated as malloc.  */\n   if (fndecl\n-      && DECL_IS_OPERATOR_NEW_P (fndecl)\n+      && DECL_IS_REPLACEABLE_OPERATOR_NEW_P (fndecl)\n       && gimple_call_from_new_or_delete (stmt))\n     return \"mC\";\n   return \"\";"}, {"sha": "0af55ef0444642a676a8753140afdafb201dcef6", "filename": "gcc/testsuite/g++.dg/opt/pr98130.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c4a9feceaccf487516aa1eff417e0741556e10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98130.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c4a9feceaccf487516aa1eff417e0741556e10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98130.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98130.C?ref=78c4a9feceaccf487516aa1eff417e0741556e10", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/98130\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O2\" }\n+\n+#include <new>\n+\n+typedef int *T;\n+\n+static unsigned char storage[sizeof (T)] alignas (T);\n+static T *p = (T *) storage;\n+\n+static inline __attribute__((__always_inline__)) void\n+foo (T value)\n+{\n+  new (p) T(value);\n+}\n+\n+int\n+main ()\n+{\n+  int a;\n+  foo (&a);\n+  if (!*p)\n+    __builtin_abort ();\n+}"}]}