{"sha": "9ea940e4dcabbf99fbb44c125a0af7cf82e48146", "node_id": "C_kwDOANBUbNoAKDllYTk0MGU0ZGNhYmJmOTlmYmI0NGMxMjVhMGFmN2NmODJlNDgxNDY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-06T09:13:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-06T09:13:51Z"}, "message": "Merge #1216\n\n1216: ast: lower: Refactor ASTLowerItem in its own source file r=CohenArthur a=CohenArthur\n\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "47a2aaa0f4b012b559feed69cd170079011bdb70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47a2aaa0f4b012b559feed69cd170079011bdb70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ea940e4dcabbf99fbb44c125a0af7cf82e48146", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJidObPCRBK7hj4Ov3rIwAAwcwIADGQltu+wV5x4BQ6C4OFsnrq\nacNqGx5/qt9X070IrCWj7IOk46KuJIKY8xW5ps8gzp6AInza79UnGRtEfbkf+opx\ntdflDNeg4b0zyYBJU7GSXSpIjqgUdX/EW4MKYE7OM22ljj7sV1Okj4YN/Htszmf1\niGaQDLM8Mzh+o0RqzeHqidM38LF1OOO24hzRVJdEretBr5hf4yw1NPdkswUEBo/D\nmUfdC32Rytg50YdlYN9J2sFLJBRYF5imcoRwJiJMqxYQ3od2OgICpq149TqUII6l\nzv6aPc8VdjZJ9fcQyQoLXyTlRGlkIpEHvWWMCRE8Nkusbpy4ZEugoUCQx4lRLog=\n=IFvR\n-----END PGP SIGNATURE-----\n", "payload": "tree 47a2aaa0f4b012b559feed69cd170079011bdb70\nparent c936fd32559244c7c71137a743a22cb8af9edac8\nparent 41abd0fdb2f060320c615bc3c1caffd2e5343184\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1651828431 +0000\ncommitter GitHub <noreply@github.com> 1651828431 +0000\n\nMerge #1216\n\n1216: ast: lower: Refactor ASTLowerItem in its own source file r=CohenArthur a=CohenArthur\n\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ea940e4dcabbf99fbb44c125a0af7cf82e48146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ea940e4dcabbf99fbb44c125a0af7cf82e48146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ea940e4dcabbf99fbb44c125a0af7cf82e48146/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c936fd32559244c7c71137a743a22cb8af9edac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c936fd32559244c7c71137a743a22cb8af9edac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c936fd32559244c7c71137a743a22cb8af9edac8"}, {"sha": "41abd0fdb2f060320c615bc3c1caffd2e5343184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41abd0fdb2f060320c615bc3c1caffd2e5343184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41abd0fdb2f060320c615bc3c1caffd2e5343184"}], "stats": {"total": 1566, "additions": 788, "deletions": 778}, "files": [{"sha": "588333817efb8f5dd6113090376dcfe5c542b64b", "filename": "gcc/rust/hir/rust-ast-lower-item.cc", "status": "modified", "additions": 773, "deletions": 0, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ea940e4dcabbf99fbb44c125a0af7cf82e48146/gcc%2Frust%2Fhir%2Frust-ast-lower-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ea940e4dcabbf99fbb44c125a0af7cf82e48146/gcc%2Frust%2Fhir%2Frust-ast-lower-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.cc?ref=9ea940e4dcabbf99fbb44c125a0af7cf82e48146", "patch": "@@ -21,6 +21,779 @@\n namespace Rust {\n namespace HIR {\n \n+HIR::Item *\n+ASTLoweringItem::translate (AST::Item *item)\n+{\n+  ASTLoweringItem resolver;\n+  item->accept_vis (resolver);\n+\n+  if (resolver.translated != nullptr)\n+    resolver.handle_outer_attributes (*resolver.translated);\n+\n+  return resolver.translated;\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Module &module)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, module.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  // should be lowered from module.get_vis()\n+  HIR::Visibility vis = translate_visibility (module.get_visibility ());\n+\n+  auto items = std::vector<std::unique_ptr<Item>> ();\n+\n+  for (auto &item : module.get_items ())\n+    {\n+      auto transitem = translate (item.get ());\n+      items.push_back (std::unique_ptr<Item> (transitem));\n+    }\n+\n+  // should be lowered/copied from module.get_in/outer_attrs()\n+  AST::AttrVec inner_attrs;\n+  AST::AttrVec outer_attrs;\n+\n+  translated\n+    = new HIR::Module (mapping, module.get_name (), module.get_locus (),\n+\t\t       std::move (items), std::move (vis),\n+\t\t       std::move (inner_attrs), std::move (outer_attrs));\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_module (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t   static_cast<Module *> (translated));\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     module.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::TypeAlias &alias)\n+{\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : alias.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (alias.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (alias.has_generics ())\n+    generic_params = lower_generic_params (alias.get_generic_params ());\n+\n+  HIR::Type *existing_type\n+    = ASTLoweringType::translate (alias.get_type_aliased ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, alias.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::TypeAlias (mapping, alias.get_new_type_name (),\n+\t\t\t  std::move (generic_params), std::move (where_clause),\n+\t\t\t  std::unique_ptr<HIR::Type> (existing_type),\n+\t\t\t  std::move (vis), alias.get_outer_attrs (),\n+\t\t\t  alias.get_locus ());\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     alias.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::TupleStruct &struct_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (struct_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (struct_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n+\n+  std::vector<HIR::TupleField> fields;\n+  for (AST::TupleField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      // FIXME: How do we get the visibility from here?\n+      HIR::Visibility vis = translate_visibility (field.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::TupleField translated_field (mapping,\n+\t\t\t\t\tstd::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\tfield.get_locus (),\n+\t\t\t\t\tfield.get_outer_attrs ());\n+      fields.push_back (std::move (translated_field));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TupleStruct (mapping, std::move (fields),\n+\t\t\t\t     struct_decl.get_identifier (),\n+\t\t\t\t     std::move (generic_params),\n+\t\t\t\t     std::move (where_clause), vis,\n+\t\t\t\t     struct_decl.get_outer_attrs (),\n+\t\t\t\t     struct_decl.get_locus ());\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     struct_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::StructStruct &struct_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (struct_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (struct_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+\n+  HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n+\n+  bool is_unit = struct_decl.is_unit_struct ();\n+  std::vector<HIR::StructField> fields;\n+  for (AST::StructField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::Visibility vis = translate_visibility (field.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::StructField translated_field (mapping, field.get_field_name (),\n+\t\t\t\t\t std::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\t field.get_locus (),\n+\t\t\t\t\t field.get_outer_attrs ());\n+\n+      if (struct_field_name_exists (fields, translated_field))\n+\tbreak;\n+\n+      fields.push_back (std::move (translated_field));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::StructStruct (mapping, std::move (fields),\n+\t\t\t\t      struct_decl.get_identifier (),\n+\t\t\t\t      std::move (generic_params),\n+\t\t\t\t      std::move (where_clause), is_unit, vis,\n+\t\t\t\t      struct_decl.get_outer_attrs (),\n+\t\t\t\t      struct_decl.get_locus ());\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     struct_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Enum &enum_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (enum_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (enum_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : enum_decl.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (enum_decl.get_visibility ());\n+\n+  // bool is_unit = enum_decl.is_zero_variant ();\n+  std::vector<std::unique_ptr<HIR::EnumItem>> items;\n+  for (auto &variant : enum_decl.get_variants ())\n+    {\n+      if (variant->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::EnumItem *hir_item = ASTLoweringEnumItem::translate (variant.get ());\n+      items.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n+\t\t\t      std::move (generic_params),\n+\t\t\t      std::move (where_clause), /* is_unit, */\n+\t\t\t      std::move (items), enum_decl.get_outer_attrs (),\n+\t\t\t      enum_decl.get_locus ());\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     enum_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Union &union_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (union_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (union_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : union_decl.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (union_decl.get_visibility ());\n+\n+  std::vector<HIR::StructField> variants;\n+  for (AST::StructField &variant : union_decl.get_variants ())\n+    {\n+      if (variant.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      // FIXME: Does visibility apply here?\n+      HIR::Visibility vis = translate_visibility (variant.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (variant.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, variant.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::StructField translated_variant (mapping, variant.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, variant.get_locus (),\n+\t\t\t\t\t   variant.get_outer_attrs ());\n+\n+      if (struct_field_name_exists (variants, translated_variant))\n+\tbreak;\n+\n+      variants.push_back (std::move (translated_variant));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, union_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::Union (mapping, union_decl.get_identifier (), vis,\n+\t\t      std::move (generic_params), std::move (where_clause),\n+\t\t      std::move (variants), union_decl.get_outer_attrs (),\n+\t\t      union_decl.get_locus ());\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     union_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::StaticItem &var)\n+{\n+  HIR::Visibility vis = translate_visibility (var.get_visibility ());\n+\n+  HIR::Type *type = ASTLoweringType::translate (var.get_type ().get ());\n+  HIR::Expr *expr = ASTLoweringExpr::translate (var.get_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, var.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::StaticItem (mapping, var.get_identifier (),\n+\t\t\t\t    var.is_mutable () ? Mutability::Mut\n+\t\t\t\t\t\t      : Mutability::Imm,\n+\t\t\t\t    std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t    std::unique_ptr<HIR::Expr> (expr), vis,\n+\t\t\t\t    var.get_outer_attrs (), var.get_locus ());\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (), var.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::ConstantItem &constant)\n+{\n+  HIR::Visibility vis = translate_visibility (constant.get_visibility ());\n+\n+  HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+  HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::ConstantItem (mapping, constant.get_identifier (), vis,\n+\t\t\t\t      std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t      constant.get_outer_attrs (),\n+\t\t\t\t      constant.get_locus ());\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     constant.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Function &function)\n+{\n+  if (function.is_marked_for_strip ())\n+    return;\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : function.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::FunctionQualifiers qualifiers\n+    = lower_qualifiers (function.get_qualifiers ());\n+  HIR::Visibility vis = translate_visibility (function.get_visibility ());\n+\n+  // need\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (function.has_generics ())\n+    {\n+      generic_params = lower_generic_params (function.get_generic_params ());\n+    }\n+  Identifier function_name = function.get_function_name ();\n+  Location locus = function.get_locus ();\n+\n+  std::unique_ptr<HIR::Type> return_type\n+    = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\tASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t  : nullptr;\n+\n+  std::vector<HIR::FunctionParam> function_params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      auto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\tASTLoweringPattern::translate (param.get_pattern ().get ()));\n+      auto translated_type = std::unique_ptr<HIR::Type> (\n+\tASTLoweringType::translate (param.get_type ().get ()));\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      auto hir_param\n+\t= HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t      std::move (translated_type), param.get_locus ());\n+      function_params.push_back (std::move (hir_param));\n+    }\n+\n+  bool terminated = false;\n+  std::unique_ptr<HIR::BlockExpr> function_body\n+    = std::unique_ptr<HIR::BlockExpr> (\n+      ASTLoweringBlock::translate (function.get_definition ().get (),\n+\t\t\t\t   &terminated));\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  mappings->insert_location (crate_num,\n+\t\t\t     function_body->get_mappings ().get_hirid (),\n+\t\t\t     function.get_locus ());\n+\n+  auto fn\n+    = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t std::move (qualifiers), std::move (generic_params),\n+\t\t\t std::move (function_params), std::move (return_type),\n+\t\t\t std::move (where_clause), std::move (function_body),\n+\t\t\t std::move (vis), function.get_outer_attrs (),\n+\t\t\t HIR::SelfParam::error (), locus);\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     fn);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     function.get_locus ());\n+\n+  // add the mappings for the function params at the end\n+  for (auto &param : fn->get_function_params ())\n+    {\n+      mappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t  param.get_mappings ().get_hirid (), &param);\n+      mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t param.get_locus ());\n+    }\n+\n+  translated = fn;\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::InherentImpl &impl_block)\n+{\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : impl_block.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (impl_block.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (impl_block.has_generics ())\n+    {\n+      generic_params = lower_generic_params (impl_block.get_generic_params ());\n+\n+      for (auto &generic_param : generic_params)\n+\t{\n+\t  switch (generic_param->get_kind ())\n+\t    {\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tconst HIR::TypeParam &t\n+\t\t  = static_cast<const HIR::TypeParam &> (*generic_param);\n+\n+\t\tif (t.has_type ())\n+\t\t  {\n+\t\t    // see https://github.com/rust-lang/rust/issues/36887\n+\t\t    rust_error_at (\n+\t\t      t.get_locus (),\n+\t\t      \"defaults for type parameters are not allowed here\");\n+\t\t  }\n+\t      }\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  HIR::Type *impl_type\n+    = ASTLoweringType::translate (impl_block.get_type ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n+  std::vector<HirId> impl_item_ids;\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      if (impl_item->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::ImplItem *lowered\n+\t= ASTLowerImplItem::translate (impl_item.get (), mapping.get_hirid ());\n+      rust_assert (lowered != nullptr);\n+      impl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n+      impl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n+    }\n+\n+  Polarity polarity = Positive;\n+  HIR::ImplBlock *hir_impl_block = new HIR::ImplBlock (\n+    mapping, std::move (impl_items), std::move (generic_params),\n+    std::unique_ptr<HIR::Type> (impl_type), nullptr, where_clause, polarity,\n+    vis, impl_block.get_inner_attrs (), impl_block.get_outer_attrs (),\n+    impl_block.get_locus ());\n+  translated = hir_impl_block;\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_hir_impl_block (mapping.get_crate_num (),\n+\t\t\t\t   mapping.get_hirid (), hir_impl_block);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     impl_block.get_locus ());\n+\n+  for (auto &impl_item_id : impl_item_ids)\n+    {\n+      mappings->insert_impl_item_mapping (impl_item_id, hir_impl_block);\n+    }\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Trait &trait)\n+{\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : trait.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+\n+  HIR::Visibility vis = translate_visibility (trait.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (trait.has_generics ())\n+    {\n+      generic_params = lower_generic_params (trait.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n+  if (trait.has_type_param_bounds ())\n+    {\n+      for (auto &bound : trait.get_type_param_bounds ())\n+\t{\n+\t  HIR::TypeParamBound *b = lower_bound (bound.get ());\n+\t  type_param_bounds.push_back (\n+\t    std::unique_ptr<HIR::TypeParamBound> (b));\n+\t}\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::TraitItem>> trait_items;\n+  std::vector<HirId> trait_item_ids;\n+  for (auto &item : trait.get_trait_items ())\n+    {\n+      if (item->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::TraitItem *lowered = ASTLowerTraitItem::translate (item.get ());\n+      trait_items.push_back (std::unique_ptr<HIR::TraitItem> (lowered));\n+      trait_item_ids.push_back (lowered->get_mappings ().get_hirid ());\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, trait.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  auto trait_unsafety = Unsafety::Normal;\n+  if (trait.is_unsafe ())\n+    {\n+      trait_unsafety = Unsafety::Unsafe;\n+    }\n+\n+  HIR::Trait *hir_trait\n+    = new HIR::Trait (mapping, trait.get_identifier (), trait_unsafety,\n+\t\t      std::move (generic_params), std::move (type_param_bounds),\n+\t\t      where_clause, std::move (trait_items), vis,\n+\t\t      trait.get_outer_attrs (), trait.get_locus ());\n+  translated = hir_trait;\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     trait.get_locus ());\n+\n+  for (auto trait_item_id : trait_item_ids)\n+    {\n+      mappings->insert_trait_item_mapping (trait_item_id, hir_trait);\n+    }\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::TraitImpl &impl_block)\n+{\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : impl_block.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (impl_block.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (impl_block.has_generics ())\n+    {\n+      generic_params = lower_generic_params (impl_block.get_generic_params ());\n+\n+      for (auto &generic_param : generic_params)\n+\t{\n+\t  switch (generic_param->get_kind ())\n+\t    {\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tconst HIR::TypeParam &t\n+\t\t  = static_cast<const HIR::TypeParam &> (*generic_param);\n+\n+\t\tif (t.has_type ())\n+\t\t  {\n+\t\t    // see https://github.com/rust-lang/rust/issues/36887\n+\t\t    rust_error_at (\n+\t\t      t.get_locus (),\n+\t\t      \"defaults for type parameters are not allowed here\");\n+\t\t  }\n+\t      }\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  HIR::Type *impl_type\n+    = ASTLoweringType::translate (impl_block.get_type ().get ());\n+  HIR::TypePath *trait_ref\n+    = ASTLowerTypePath::translate (impl_block.get_trait_path ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n+  std::vector<HirId> impl_item_ids;\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      if (impl_item->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::ImplItem *lowered\n+\t= ASTLowerImplItem::translate (impl_item.get (), mapping.get_hirid ());\n+      rust_assert (lowered != nullptr);\n+      impl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n+      impl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n+    }\n+\n+  Polarity polarity = impl_block.is_exclam () ? Positive : Negative;\n+  HIR::ImplBlock *hir_impl_block = new HIR::ImplBlock (\n+    mapping, std::move (impl_items), std::move (generic_params),\n+    std::unique_ptr<HIR::Type> (impl_type),\n+    std::unique_ptr<HIR::TypePath> (trait_ref), where_clause, polarity, vis,\n+    impl_block.get_inner_attrs (), impl_block.get_outer_attrs (),\n+    impl_block.get_locus ());\n+  translated = hir_impl_block;\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_hir_impl_block (mapping.get_crate_num (),\n+\t\t\t\t   mapping.get_hirid (), hir_impl_block);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     impl_block.get_locus ());\n+\n+  for (auto &impl_item_id : impl_item_ids)\n+    {\n+      mappings->insert_impl_item_mapping (impl_item_id, hir_impl_block);\n+    }\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::ExternBlock &extern_block)\n+{\n+  HIR::Visibility vis = translate_visibility (extern_block.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::ExternalItem>> extern_items;\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      if (item->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::ExternalItem *lowered\n+\t= ASTLoweringExternItem::translate (item.get ());\n+      extern_items.push_back (std::unique_ptr<HIR::ExternalItem> (lowered));\n+    }\n+\n+  ABI abi = ABI::RUST;\n+  if (extern_block.has_abi ())\n+    {\n+      const std::string &extern_abi = extern_block.get_abi ();\n+      abi = get_abi_from_string (extern_abi);\n+      if (abi == ABI::UNKNOWN)\n+\trust_error_at (extern_block.get_locus (), \"unknown ABI option\");\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, extern_block.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  HIR::ExternBlock *hir_extern_block\n+    = new HIR::ExternBlock (mapping, abi, std::move (extern_items),\n+\t\t\t    std::move (vis), extern_block.get_inner_attrs (),\n+\t\t\t    extern_block.get_outer_attrs (),\n+\t\t\t    extern_block.get_locus ());\n+\n+  translated = hir_extern_block;\n+\n+  mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+  mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+  mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t     extern_block.get_locus ());\n+}\n+\n HIR::SimplePath\n ASTLoweringSimplePath::translate (const AST::SimplePath &path)\n {"}, {"sha": "5d4ee18f51780a593a0e0e04775f2d06f535f9d9", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 15, "deletions": 778, "changes": 793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ea940e4dcabbf99fbb44c125a0af7cf82e48146/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ea940e4dcabbf99fbb44c125a0af7cf82e48146/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=9ea940e4dcabbf99fbb44c125a0af7cf82e48146", "patch": "@@ -41,784 +41,21 @@ class ASTLoweringItem : public ASTLoweringBase\n   using Rust::HIR::ASTLoweringBase::visit;\n \n public:\n-  static HIR::Item *translate (AST::Item *item)\n-  {\n-    ASTLoweringItem resolver;\n-    item->accept_vis (resolver);\n-\n-    if (resolver.translated != nullptr)\n-      resolver.handle_outer_attributes (*resolver.translated);\n-\n-    return resolver.translated;\n-  }\n-\n-  void visit (AST::Module &module) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, module.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    // should be lowered from module.get_vis()\n-    HIR::Visibility vis = translate_visibility (module.get_visibility ());\n-\n-    auto items = std::vector<std::unique_ptr<Item>> ();\n-\n-    for (auto &item : module.get_items ())\n-      {\n-\tauto transitem = translate (item.get ());\n-\titems.push_back (std::unique_ptr<Item> (transitem));\n-      }\n-\n-    // should be lowered/copied from module.get_in/outer_attrs()\n-    AST::AttrVec inner_attrs;\n-    AST::AttrVec outer_attrs;\n-\n-    translated\n-      = new HIR::Module (mapping, module.get_name (), module.get_locus (),\n-\t\t\t std::move (items), std::move (vis),\n-\t\t\t std::move (inner_attrs), std::move (outer_attrs));\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_module (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t     static_cast<Module *> (translated));\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       module.get_locus ());\n-  }\n-\n-  void visit (AST::TypeAlias &alias) override\n-  {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : alias.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (alias.get_visibility ());\n-\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (alias.has_generics ())\n-      generic_params = lower_generic_params (alias.get_generic_params ());\n-\n-    HIR::Type *existing_type\n-      = ASTLoweringType::translate (alias.get_type_aliased ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, alias.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::TypeAlias (mapping, alias.get_new_type_name (),\n-\t\t\t\t     std::move (generic_params),\n-\t\t\t\t     std::move (where_clause),\n-\t\t\t\t     std::unique_ptr<HIR::Type> (existing_type),\n-\t\t\t\t     std::move (vis), alias.get_outer_attrs (),\n-\t\t\t\t     alias.get_locus ());\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       alias.get_locus ());\n-  }\n-\n-  void visit (AST::TupleStruct &struct_decl) override\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (struct_decl.has_generics ())\n-      {\n-\tgeneric_params\n-\t  = lower_generic_params (struct_decl.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : struct_decl.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n-\n-    std::vector<HIR::TupleField> fields;\n-    for (AST::TupleField &field : struct_decl.get_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\t// FIXME: How do we get the visibility from here?\n-\tHIR::Visibility vis = translate_visibility (field.get_visibility ());\n-\tHIR::Type *type\n-\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n-\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, field.get_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       mappings->get_next_localdef_id (\n-\t\t\t\t\t crate_num));\n-\n-\tHIR::TupleField translated_field (mapping,\n-\t\t\t\t\t  std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\t  vis, field.get_locus (),\n-\t\t\t\t\t  field.get_outer_attrs ());\n-\tfields.push_back (std::move (translated_field));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::TupleStruct (mapping, std::move (fields),\n-\t\t\t\t       struct_decl.get_identifier (),\n-\t\t\t\t       std::move (generic_params),\n-\t\t\t\t       std::move (where_clause), vis,\n-\t\t\t\t       struct_decl.get_outer_attrs (),\n-\t\t\t\t       struct_decl.get_locus ());\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       struct_decl.get_locus ());\n-  }\n-\n-  void visit (AST::StructStruct &struct_decl) override\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (struct_decl.has_generics ())\n-      {\n-\tgeneric_params\n-\t  = lower_generic_params (struct_decl.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : struct_decl.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-\n-    HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n-\n-    bool is_unit = struct_decl.is_unit_struct ();\n-    std::vector<HIR::StructField> fields;\n-    for (AST::StructField &field : struct_decl.get_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tHIR::Visibility vis = translate_visibility (field.get_visibility ());\n-\tHIR::Type *type\n-\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n-\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, field.get_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       mappings->get_next_localdef_id (\n-\t\t\t\t\t crate_num));\n-\n-\tHIR::StructField translated_field (mapping, field.get_field_name (),\n-\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\t   vis, field.get_locus (),\n-\t\t\t\t\t   field.get_outer_attrs ());\n-\n-\tif (struct_field_name_exists (fields, translated_field))\n-\t  break;\n-\n-\tfields.push_back (std::move (translated_field));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::StructStruct (mapping, std::move (fields),\n-\t\t\t\t\tstruct_decl.get_identifier (),\n-\t\t\t\t\tstd::move (generic_params),\n-\t\t\t\t\tstd::move (where_clause), is_unit, vis,\n-\t\t\t\t\tstruct_decl.get_outer_attrs (),\n-\t\t\t\t\tstruct_decl.get_locus ());\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       struct_decl.get_locus ());\n-  }\n-\n-  void visit (AST::Enum &enum_decl) override\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (enum_decl.has_generics ())\n-      {\n-\tgeneric_params = lower_generic_params (enum_decl.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : enum_decl.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (enum_decl.get_visibility ());\n-\n-    // bool is_unit = enum_decl.is_zero_variant ();\n-    std::vector<std::unique_ptr<HIR::EnumItem>> items;\n-    for (auto &variant : enum_decl.get_variants ())\n-      {\n-\tif (variant->is_marked_for_strip ())\n-\t  continue;\n-\n-\tHIR::EnumItem *hir_item\n-\t  = ASTLoweringEnumItem::translate (variant.get ());\n-\titems.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n-\t\t\t\tstd::move (generic_params),\n-\t\t\t\tstd::move (where_clause), /* is_unit, */\n-\t\t\t\tstd::move (items), enum_decl.get_outer_attrs (),\n-\t\t\t\tenum_decl.get_locus ());\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       enum_decl.get_locus ());\n-  }\n-\n-  void visit (AST::Union &union_decl) override\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (union_decl.has_generics ())\n-      {\n-\tgeneric_params\n-\t  = lower_generic_params (union_decl.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : union_decl.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (union_decl.get_visibility ());\n-\n-    std::vector<HIR::StructField> variants;\n-    for (AST::StructField &variant : union_decl.get_variants ())\n-      {\n-\tif (variant.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\t// FIXME: Does visibility apply here?\n-\tHIR::Visibility vis = translate_visibility (variant.get_visibility ());\n-\tHIR::Type *type\n-\t  = ASTLoweringType::translate (variant.get_field_type ().get ());\n-\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, variant.get_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       mappings->get_next_localdef_id (\n-\t\t\t\t\t crate_num));\n-\n-\tHIR::StructField translated_variant (mapping, variant.get_field_name (),\n-\t\t\t\t\t     std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\t     vis, variant.get_locus (),\n-\t\t\t\t\t     variant.get_outer_attrs ());\n-\n-\tif (struct_field_name_exists (variants, translated_variant))\n-\t  break;\n-\n-\tvariants.push_back (std::move (translated_variant));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, union_decl.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated\n-      = new HIR::Union (mapping, union_decl.get_identifier (), vis,\n-\t\t\tstd::move (generic_params), std::move (where_clause),\n-\t\t\tstd::move (variants), union_decl.get_outer_attrs (),\n-\t\t\tunion_decl.get_locus ());\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       union_decl.get_locus ());\n-  }\n-\n-  void visit (AST::StaticItem &var) override\n-  {\n-    HIR::Visibility vis = translate_visibility (var.get_visibility ());\n-\n-    HIR::Type *type = ASTLoweringType::translate (var.get_type ().get ());\n-    HIR::Expr *expr = ASTLoweringExpr::translate (var.get_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, var.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::StaticItem (mapping, var.get_identifier (),\n-\t\t\t\t      var.is_mutable () ? Mutability::Mut\n-\t\t\t\t\t\t\t: Mutability::Imm,\n-\t\t\t\t      std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t      std::unique_ptr<HIR::Expr> (expr), vis,\n-\t\t\t\t      var.get_outer_attrs (), var.get_locus ());\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       var.get_locus ());\n-  }\n-\n-  void visit (AST::ConstantItem &constant) override\n-  {\n-    HIR::Visibility vis = translate_visibility (constant.get_visibility ());\n-\n-    HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n-    HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::ConstantItem (mapping, constant.get_identifier (),\n-\t\t\t\t\tvis, std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\tstd::unique_ptr<HIR::Expr> (expr),\n-\t\t\t\t\tconstant.get_outer_attrs (),\n-\t\t\t\t\tconstant.get_locus ());\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       constant.get_locus ());\n-  }\n-\n-  void visit (AST::Function &function) override\n-  {\n-    if (function.is_marked_for_strip ())\n-      return;\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : function.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::FunctionQualifiers qualifiers\n-      = lower_qualifiers (function.get_qualifiers ());\n-    HIR::Visibility vis = translate_visibility (function.get_visibility ());\n-\n-    // need\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (function.has_generics ())\n-      {\n-\tgeneric_params = lower_generic_params (function.get_generic_params ());\n-      }\n-    Identifier function_name = function.get_function_name ();\n-    Location locus = function.get_locus ();\n-\n-    std::unique_ptr<HIR::Type> return_type\n-      = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n-\t  ASTLoweringType::translate (function.get_return_type ().get ()))\n-\t\t\t\t    : nullptr;\n-\n-    std::vector<HIR::FunctionParam> function_params;\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n-\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n-\tauto translated_type = std::unique_ptr<HIR::Type> (\n-\t  ASTLoweringType::translate (param.get_type ().get ()));\n-\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n-\n-\tauto hir_param\n-\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n-\t\t\t\tstd::move (translated_type),\n-\t\t\t\tparam.get_locus ());\n-\tfunction_params.push_back (std::move (hir_param));\n-      }\n-\n-    bool terminated = false;\n-    std::unique_ptr<HIR::BlockExpr> function_body\n-      = std::unique_ptr<HIR::BlockExpr> (\n-\tASTLoweringBlock::translate (function.get_definition ().get (),\n-\t\t\t\t     &terminated));\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    mappings->insert_location (crate_num,\n-\t\t\t       function_body->get_mappings ().get_hirid (),\n-\t\t\t       function.get_locus ());\n-\n-    auto fn\n-      = new HIR::Function (mapping, std::move (function_name),\n-\t\t\t   std::move (qualifiers), std::move (generic_params),\n-\t\t\t   std::move (function_params), std::move (return_type),\n-\t\t\t   std::move (where_clause), std::move (function_body),\n-\t\t\t   std::move (vis), function.get_outer_attrs (),\n-\t\t\t   HIR::SelfParam::error (), locus);\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       fn);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       function.get_locus ());\n-\n-    // add the mappings for the function params at the end\n-    for (auto &param : fn->get_function_params ())\n-      {\n-\tmappings->insert_hir_param (mapping.get_crate_num (),\n-\t\t\t\t    param.get_mappings ().get_hirid (), &param);\n-\tmappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t\t   param.get_locus ());\n-      }\n-\n-    translated = fn;\n-  }\n-\n-  void visit (AST::InherentImpl &impl_block) override\n-  {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : impl_block.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (impl_block.get_visibility ());\n-\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (impl_block.has_generics ())\n-      {\n-\tgeneric_params\n-\t  = lower_generic_params (impl_block.get_generic_params ());\n-\n-\tfor (auto &generic_param : generic_params)\n-\t  {\n-\t    switch (generic_param->get_kind ())\n-\t      {\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  const HIR::TypeParam &t\n-\t\t    = static_cast<const HIR::TypeParam &> (*generic_param);\n-\n-\t\t  if (t.has_type ())\n-\t\t    {\n-\t\t      // see https://github.com/rust-lang/rust/issues/36887\n-\t\t      rust_error_at (\n-\t\t\tt.get_locus (),\n-\t\t\t\"defaults for type parameters are not allowed here\");\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    HIR::Type *impl_type\n-      = ASTLoweringType::translate (impl_block.get_type ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n-    std::vector<HirId> impl_item_ids;\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      {\n-\tif (impl_item->is_marked_for_strip ())\n-\t  continue;\n-\n-\tHIR::ImplItem *lowered\n-\t  = ASTLowerImplItem::translate (impl_item.get (),\n-\t\t\t\t\t mapping.get_hirid ());\n-\trust_assert (lowered != nullptr);\n-\timpl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n-\timpl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n-      }\n-\n-    Polarity polarity = Positive;\n-    HIR::ImplBlock *hir_impl_block = new HIR::ImplBlock (\n-      mapping, std::move (impl_items), std::move (generic_params),\n-      std::unique_ptr<HIR::Type> (impl_type), nullptr, where_clause, polarity,\n-      vis, impl_block.get_inner_attrs (), impl_block.get_outer_attrs (),\n-      impl_block.get_locus ());\n-    translated = hir_impl_block;\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_hir_impl_block (mapping.get_crate_num (),\n-\t\t\t\t     mapping.get_hirid (), hir_impl_block);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       impl_block.get_locus ());\n-\n-    for (auto &impl_item_id : impl_item_ids)\n-      {\n-\tmappings->insert_impl_item_mapping (impl_item_id, hir_impl_block);\n-      }\n-  }\n-\n-  void visit (AST::Trait &trait) override\n-  {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : trait.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-\n-    HIR::Visibility vis = translate_visibility (trait.get_visibility ());\n-\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (trait.has_generics ())\n-      {\n-\tgeneric_params = lower_generic_params (trait.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n-    if (trait.has_type_param_bounds ())\n-      {\n-\tfor (auto &bound : trait.get_type_param_bounds ())\n-\t  {\n-\t    HIR::TypeParamBound *b = lower_bound (bound.get ());\n-\t    type_param_bounds.push_back (\n-\t      std::unique_ptr<HIR::TypeParamBound> (b));\n-\t  }\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::TraitItem>> trait_items;\n-    std::vector<HirId> trait_item_ids;\n-    for (auto &item : trait.get_trait_items ())\n-      {\n-\tif (item->is_marked_for_strip ())\n-\t  continue;\n-\n-\tHIR::TraitItem *lowered = ASTLowerTraitItem::translate (item.get ());\n-\ttrait_items.push_back (std::unique_ptr<HIR::TraitItem> (lowered));\n-\ttrait_item_ids.push_back (lowered->get_mappings ().get_hirid ());\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, trait.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    auto trait_unsafety = Unsafety::Normal;\n-    if (trait.is_unsafe ())\n-      {\n-\ttrait_unsafety = Unsafety::Unsafe;\n-      }\n-\n-    HIR::Trait *hir_trait\n-      = new HIR::Trait (mapping, trait.get_identifier (), trait_unsafety,\n-\t\t\tstd::move (generic_params),\n-\t\t\tstd::move (type_param_bounds), where_clause,\n-\t\t\tstd::move (trait_items), vis, trait.get_outer_attrs (),\n-\t\t\ttrait.get_locus ());\n-    translated = hir_trait;\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       trait.get_locus ());\n-\n-    for (auto trait_item_id : trait_item_ids)\n-      {\n-\tmappings->insert_trait_item_mapping (trait_item_id, hir_trait);\n-      }\n-  }\n-\n-  void visit (AST::TraitImpl &impl_block) override\n-  {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    for (auto &item : impl_block.get_where_clause ().get_items ())\n-      {\n-\tHIR::WhereClauseItem *i\n-\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n-\twhere_clause_items.push_back (\n-\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n-      }\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (impl_block.get_visibility ());\n-\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (impl_block.has_generics ())\n-      {\n-\tgeneric_params\n-\t  = lower_generic_params (impl_block.get_generic_params ());\n-\n-\tfor (auto &generic_param : generic_params)\n-\t  {\n-\t    switch (generic_param->get_kind ())\n-\t      {\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  const HIR::TypeParam &t\n-\t\t    = static_cast<const HIR::TypeParam &> (*generic_param);\n-\n-\t\t  if (t.has_type ())\n-\t\t    {\n-\t\t      // see https://github.com/rust-lang/rust/issues/36887\n-\t\t      rust_error_at (\n-\t\t\tt.get_locus (),\n-\t\t\t\"defaults for type parameters are not allowed here\");\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    HIR::Type *impl_type\n-      = ASTLoweringType::translate (impl_block.get_type ().get ());\n-    HIR::TypePath *trait_ref\n-      = ASTLowerTypePath::translate (impl_block.get_trait_path ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n-    std::vector<HirId> impl_item_ids;\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      {\n-\tif (impl_item->is_marked_for_strip ())\n-\t  continue;\n-\n-\tHIR::ImplItem *lowered\n-\t  = ASTLowerImplItem::translate (impl_item.get (),\n-\t\t\t\t\t mapping.get_hirid ());\n-\trust_assert (lowered != nullptr);\n-\timpl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n-\timpl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n-      }\n-\n-    Polarity polarity = impl_block.is_exclam () ? Positive : Negative;\n-    HIR::ImplBlock *hir_impl_block = new HIR::ImplBlock (\n-      mapping, std::move (impl_items), std::move (generic_params),\n-      std::unique_ptr<HIR::Type> (impl_type),\n-      std::unique_ptr<HIR::TypePath> (trait_ref), where_clause, polarity, vis,\n-      impl_block.get_inner_attrs (), impl_block.get_outer_attrs (),\n-      impl_block.get_locus ());\n-    translated = hir_impl_block;\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_hir_impl_block (mapping.get_crate_num (),\n-\t\t\t\t     mapping.get_hirid (), hir_impl_block);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       impl_block.get_locus ());\n-\n-    for (auto &impl_item_id : impl_item_ids)\n-      {\n-\tmappings->insert_impl_item_mapping (impl_item_id, hir_impl_block);\n-      }\n-  }\n-\n-  void visit (AST::ExternBlock &extern_block) override\n-  {\n-    HIR::Visibility vis = translate_visibility (extern_block.get_visibility ());\n-\n-    std::vector<std::unique_ptr<HIR::ExternalItem>> extern_items;\n-    for (auto &item : extern_block.get_extern_items ())\n-      {\n-\tif (item->is_marked_for_strip ())\n-\t  continue;\n-\n-\tHIR::ExternalItem *lowered\n-\t  = ASTLoweringExternItem::translate (item.get ());\n-\textern_items.push_back (std::unique_ptr<HIR::ExternalItem> (lowered));\n-      }\n-\n-    ABI abi = ABI::RUST;\n-    if (extern_block.has_abi ())\n-      {\n-\tconst std::string &extern_abi = extern_block.get_abi ();\n-\tabi = get_abi_from_string (extern_abi);\n-\tif (abi == ABI::UNKNOWN)\n-\t  rust_error_at (extern_block.get_locus (), \"unknown ABI option\");\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, extern_block.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    HIR::ExternBlock *hir_extern_block\n-      = new HIR::ExternBlock (mapping, abi, std::move (extern_items),\n-\t\t\t      std::move (vis), extern_block.get_inner_attrs (),\n-\t\t\t      extern_block.get_outer_attrs (),\n-\t\t\t      extern_block.get_locus ());\n-\n-    translated = hir_extern_block;\n-\n-    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n-    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n-    mappings->insert_location (crate_num, mapping.get_hirid (),\n-\t\t\t       extern_block.get_locus ());\n-  }\n+  static HIR::Item *translate (AST::Item *item);\n+\n+  void visit (AST::Module &module) override;\n+  void visit (AST::TypeAlias &alias) override;\n+  void visit (AST::TupleStruct &struct_decl) override;\n+  void visit (AST::StructStruct &struct_decl) override;\n+  void visit (AST::Enum &enum_decl) override;\n+  void visit (AST::Union &union_decl) override;\n+  void visit (AST::StaticItem &var) override;\n+  void visit (AST::ConstantItem &constant) override;\n+  void visit (AST::Function &function) override;\n+  void visit (AST::InherentImpl &impl_block) override;\n+  void visit (AST::Trait &trait) override;\n+  void visit (AST::TraitImpl &impl_block) override;\n+  void visit (AST::ExternBlock &extern_block) override;\n \n private:\n   ASTLoweringItem () : translated (nullptr) {}"}]}