{"sha": "b38086f06abab6f679bc6e63d833b8d853a5e04f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM4MDg2ZjA2YWJhYjZmNjc5YmM2ZTYzZDgzM2I4ZDg1M2E1ZTA0Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-04-30T08:31:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-04-30T08:31:29Z"}, "message": "decl.c (gnat_to_gnu_entity): In type annotation mode...\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): In type annotation mode,\n\tdo not adjust the size of a tagged type if there is a representation\n\tclause on it.  Otherwise, round the adjustment up to the alignment\n\tof the first field and use the appropriate helper routine.\n\t(maybe_pad_type): Do not warn in type annotation mode on a tagged type.\n\t(gnat_to_gnu_field): Do not error out under the same circumstances.\n\t(annotate_rep): In type annotation mode, do not adjust the offset of\n\tcomponents of a tagged type with representation clause.  Otherwise,\n\tround the adjustment up to the alignment of the first field.\n\nFrom-SVN: r186961", "tree": {"sha": "344606836405cdc8b8aabc044d626774a697e93e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/344606836405cdc8b8aabc044d626774a697e93e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b38086f06abab6f679bc6e63d833b8d853a5e04f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38086f06abab6f679bc6e63d833b8d853a5e04f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38086f06abab6f679bc6e63d833b8d853a5e04f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38086f06abab6f679bc6e63d833b8d853a5e04f/comments", "author": null, "committer": null, "parents": [{"sha": "bb358f1cd9fbf80190bfcc77fea21237d6f5a44d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb358f1cd9fbf80190bfcc77fea21237d6f5a44d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb358f1cd9fbf80190bfcc77fea21237d6f5a44d"}], "stats": {"total": 78, "additions": 55, "deletions": 23}, "files": [{"sha": "31d5ac418746367b856b17a8c9b3fc4ebf9beccc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38086f06abab6f679bc6e63d833b8d853a5e04f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38086f06abab6f679bc6e63d833b8d853a5e04f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b38086f06abab6f679bc6e63d833b8d853a5e04f", "patch": "@@ -1,3 +1,15 @@\n+2012-04-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): In type annotation mode,\n+\tdo not adjust the size of a tagged type if there is a representation\n+\tclause on it.  Otherwise, round the adjustment up to the alignment\n+\tof the first field and use the appropriate helper routine.\n+\t(maybe_pad_type): Do not warn in type annotation mode on a tagged type.\n+\t(gnat_to_gnu_field): Do not error out under the same circumstances.\n+\t(annotate_rep): In type annotation mode, do not adjust the offset of\n+\tcomponents of a tagged type with representation clause.  Otherwise,\n+\tround the adjustment up to the alignment of the first field.\n+\n 2012-04-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (finish_record_type): Force the traditional GCC\n@@ -14,7 +26,7 @@\n \t(destroy_dummy_type): Likewise.\n \t* gcc-interface/trans.c (gnat_validate_uc_list): New variable.\n \t(gigi): Call validate_unchecked_conversion on gnat_validate_uc_list\n-\tafter the translation is completed. \ufffdCall destroy_gnat_to_gnu and\n+\tafter the translation is completed.  Call destroy_gnat_to_gnu and\n \tdestroy_dummy_type at the end.\n \t(Subprogram_Body_to_gnu): Do not call mark_out_of_scope.\n \t(gnat_to_gnu) <N_Block_Statement>: Likewise."}, {"sha": "333d33b307e66f71cbcc60b6fb99fcc3ab4ae615", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38086f06abab6f679bc6e63d833b8d853a5e04f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38086f06abab6f679bc6e63d833b8d853a5e04f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b38086f06abab6f679bc6e63d833b8d853a5e04f", "patch": "@@ -5027,28 +5027,33 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  if (CONTAINS_PLACEHOLDER_P (gnu_size))\n \t    gnu_size = max_size (gnu_size, true);\n \n-\t  if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n+\t  /* If we are just annotating types and the type is tagged, the tag\n+\t     and the parent components are not generated by the front-end so\n+\t     sizes must be adjusted if there is no representation clause.  */\n+\t  if (type_annotate_only\n+\t      && Is_Tagged_Type (gnat_entity)\n+\t      && !VOID_TYPE_P (gnu_type)\n+\t      && (!TYPE_FIELDS (gnu_type)\n+\t\t  || integer_zerop (bit_position (TYPE_FIELDS (gnu_type)))))\n \t    {\n-\t      /* In this mode, the tag and the parent components are not\n-\t\t generated by the front-end so the sizes must be adjusted.  */\n \t      tree pointer_size = bitsize_int (POINTER_SIZE), offset;\n \t      Uint uint_size;\n \n \t      if (Is_Derived_Type (gnat_entity))\n \t\t{\n-\t\t  offset = UI_To_gnu (Esize (Etype (Base_Type (gnat_entity))),\n-\t\t\t\t      bitsizetype);\n-\t\t  Set_Alignment (gnat_entity,\n-\t\t\t\t Alignment (Etype (Base_Type (gnat_entity))));\n+\t\t  Entity_Id gnat_parent = Etype (Base_Type (gnat_entity));\n+\t\t  offset = UI_To_gnu (Esize (gnat_parent), bitsizetype);\n+\t\t  Set_Alignment (gnat_entity, Alignment (gnat_parent));\n \t\t}\n \t      else\n \t\toffset = pointer_size;\n \n+\t      if (TYPE_FIELDS (gnu_type))\n+\t\toffset\n+\t\t  = round_up (offset, DECL_ALIGN (TYPE_FIELDS (gnu_type)));\n+\n \t      gnu_size = size_binop (PLUS_EXPR, gnu_size, offset);\n-\t      gnu_size = size_binop (MULT_EXPR, pointer_size,\n-\t\t\t\t\t\tsize_binop (CEIL_DIV_EXPR,\n-\t\t\t\t\t\t\t    gnu_size,\n-\t\t\t\t\t\t\t    pointer_size));\n+\t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n \t      uint_size = annotate_value (gnu_size);\n \t      Set_Esize (gnat_entity, uint_size);\n \t      Set_RM_Size (gnat_entity, uint_size);\n@@ -6619,7 +6624,9 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   /* If the size was widened explicitly, maybe give a warning.  Take the\n      original size as the maximum size of the input if there was an\n      unconstrained record involved and round it up to the specified alignment,\n-     if one was specified.  */\n+     if one was specified.  But don't do it if we are just annotating types\n+     and the type is tagged, since tagged types aren't fully laid out in this\n+     mode.  */\n   if (CONTAINS_PLACEHOLDER_P (orig_size))\n     orig_size = max_size (orig_size, true);\n \n@@ -6635,7 +6642,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t   && TREE_CODE (orig_size) == INTEGER_CST\n \t   && (TREE_OVERFLOW (size)\n \t       || TREE_OVERFLOW (orig_size)\n-\t       || tree_int_cst_lt (size, orig_size))))\n+\t       || tree_int_cst_lt (size, orig_size)))\n+      && !(type_annotate_only && Is_Tagged_Type (Etype (gnat_entity))))\n     {\n       Node_Id gnat_error_node = Empty;\n \n@@ -6901,10 +6909,13 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t    }\n \t}\n \n-      /* If this field needs strict alignment, ensure the record is\n-\t sufficiently aligned and that that position and size are\n-\t consistent with the alignment.  */\n-      if (needs_strict_alignment)\n+      /* If this field needs strict alignment, check that the record is\n+\t sufficiently aligned and that position and size are consistent\n+\t with the alignment.  But don't do it if we are just annotating\n+\t types and the field's type is tagged, since tagged types aren't\n+\t fully laid out in this mode.  */\n+      if (needs_strict_alignment\n+\t  && !(type_annotate_only && Is_Tagged_Type (gnat_field_type)))\n \t{\n \t  TYPE_ALIGN (gnu_record_type)\n \t    = MAX (TYPE_ALIGN (gnu_record_type), TYPE_ALIGN (gnu_field_type));\n@@ -7839,19 +7850,28 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n \t  {\n \t    tree parent_offset;\n \n-\t    if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n+\t    /* If we are just annotating types and the type is tagged, the tag\n+\t       and the parent components are not generated by the front-end so\n+\t       we need to add the appropriate offset to each component without\n+\t       representation clause.  */\n+\t    if (type_annotate_only\n+\t\t&& Is_Tagged_Type (gnat_entity)\n+\t\t&& No (Component_Clause (gnat_field)))\n \t      {\n-\t\t/* In this mode the tag and parent components are not\n-\t\t   generated, so we add the appropriate offset to each\n-\t\t   component.  For a component appearing in the current\n-\t\t   extension, the offset is the size of the parent.  */\n+\t\t/* For a component appearing in the current extension, the\n+\t\t   offset is the size of the parent.  */\n \t\tif (Is_Derived_Type (gnat_entity)\n \t\t    && Original_Record_Component (gnat_field) == gnat_field)\n \t\t  parent_offset\n \t\t    = UI_To_gnu (Esize (Etype (Base_Type (gnat_entity))),\n \t\t\t\t bitsizetype);\n \t\telse\n \t\t  parent_offset = bitsize_int (POINTER_SIZE);\n+\n+\t\tif (TYPE_FIELDS (gnu_type))\n+\t\t  parent_offset\n+\t\t    = round_up (parent_offset,\n+\t\t\t\tDECL_ALIGN (TYPE_FIELDS (gnu_type)));\n \t      }\n \t    else\n \t      parent_offset = bitsize_zero_node;"}]}