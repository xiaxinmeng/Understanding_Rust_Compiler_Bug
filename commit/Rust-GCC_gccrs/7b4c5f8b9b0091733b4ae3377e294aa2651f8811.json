{"sha": "7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I0YzVmOGI5YjAwOTE3MzNiNGFlMzM3N2UyOTRhYTI2NTFmODgxMQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-12-05T13:42:32Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-12-05T13:42:32Z"}, "message": "re PR fortran/34333 (if(nan == nan) wrongly returns TRUE, when nan is a parameter)\n\n2007-12-05  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/34333\n        * arith.h (gfc_compare_expr): Add operator argument, needed\n        for compare_real.\n        * arith.c (gfc_arith_init_1): Use mpfr_min instead of\n        * mpfr_cmp/set\n        to account for NaN.\n        (compare_real): New function, as mpfr_cmp but takes NaN into\n        account.\n        (gfc_compare_expr): Use compare_real.\n        (compare_complex): Take NaN into account.\n        (gfc_arith_eq,gfc_arith_ne,gfc_arith_gt,gfc_arith_ge,gfc_arith_lt,\n        gfc_arith_le): Pass operator to gfc_compare_expr.\n        * resolve.c (compare_cases,resolve_select): Pass operator\n        to gfc_compare_expr.\n        * simplify.c (simplify_min_max): Take NaN into account.\n\n2007-12-05  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/34333\n        * gfortran.dg/nan_2.f90: New.\n\nFrom-SVN: r130623", "tree": {"sha": "5e83d0d41ff004471fcd506967d79fb199570a11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e83d0d41ff004471fcd506967d79fb199570a11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/comments", "author": null, "committer": null, "parents": [{"sha": "59b130b365bbb85a040ee7e1de221cf4aedb691a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b130b365bbb85a040ee7e1de221cf4aedb691a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b130b365bbb85a040ee7e1de221cf4aedb691a"}], "stats": {"total": 225, "additions": 193, "deletions": 32}, "files": [{"sha": "4752ae020ef85dc43629d0e8c22afe9cf96e0058", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "patch": "@@ -1,3 +1,19 @@\n+2007-12-05  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/34333\n+\t* arith.h (gfc_compare_expr): Add operator argument, needed\n+\tfor compare_real.\n+\t* arith.c (gfc_arith_init_1): Use mpfr_min instead of mpfr_cmp/set\n+\tto account for NaN.\n+\t(compare_real): New function, as mpfr_cmp but takes NaN into account.\n+\t(gfc_compare_expr): Use compare_real.\n+\t(compare_complex): Take NaN into account.\n+\t(gfc_arith_eq,gfc_arith_ne,gfc_arith_gt,gfc_arith_ge,gfc_arith_lt,\n+\tgfc_arith_le): Pass operator to gfc_compare_expr.\n+\t* resolve.c (compare_cases,resolve_select): Pass operator\n+\tto gfc_compare_expr.\n+\t* simplify.c (simplify_min_max): Take NaN into account.\n+\n 2007-12-04  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34318"}, {"sha": "01d2989f3169ebb50cd3cc4ee60ee44b3d5d2c84", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "patch": "@@ -226,8 +226,7 @@ gfc_arith_init_1 (void)\n       mpfr_neg (b, b, GFC_RND_MODE);\n \n       /* a = min(a, b)  */\n-      if (mpfr_cmp (a, b) > 0)\n-\tmpfr_set (a, b, GFC_RND_MODE);\n+      mpfr_min (a, a, b, GFC_RND_MODE);\n \n       mpfr_trunc (a, a);\n       gfc_mpfr_to_mpz (r, a);\n@@ -1115,12 +1114,43 @@ gfc_arith_concat (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n   return ARITH_OK;\n }\n \n+/* Comparison between real values; returns 0 if (op1 .op. op2) is true.\n+   This function mimics mpr_cmp but takes NaN into account.  */\n+\n+static int\n+compare_real (gfc_expr *op1, gfc_expr *op2, gfc_intrinsic_op op)\n+{\n+  int rc;\n+  switch (op)\n+    {\n+      case INTRINSIC_EQ:\n+\trc = mpfr_equal_p (op1->value.real, op2->value.real) ? 0 : 1;\n+\tbreak;\n+      case INTRINSIC_GT:\n+\trc = mpfr_greater_p (op1->value.real, op2->value.real) ? 1 : -1;\n+\tbreak;\n+      case INTRINSIC_GE:\n+\trc = mpfr_greaterequal_p (op1->value.real, op2->value.real) ? 1 : -1;\n+\tbreak;\n+      case INTRINSIC_LT:\n+\trc = mpfr_less_p (op1->value.real, op2->value.real) ? -1 : 1;\n+\tbreak;\n+      case INTRINSIC_LE:\n+\trc = mpfr_lessequal_p (op1->value.real, op2->value.real) ? -1 : 1;\n+\tbreak;\n+      default:\n+\tgfc_internal_error (\"compare_real(): Bad operator\");\n+    }\n+\n+  return rc;\n+}\n \n /* Comparison operators.  Assumes that the two expression nodes\n-   contain two constants of the same type.  */\n+   contain two constants of the same type. The op argument is\n+   needed to handle NaN correctly.  */\n \n int\n-gfc_compare_expr (gfc_expr *op1, gfc_expr *op2)\n+gfc_compare_expr (gfc_expr *op1, gfc_expr *op2, gfc_intrinsic_op op)\n {\n   int rc;\n \n@@ -1131,7 +1161,7 @@ gfc_compare_expr (gfc_expr *op1, gfc_expr *op2)\n       break;\n \n     case BT_REAL:\n-      rc = mpfr_cmp (op1->value.real, op2->value.real);\n+      rc = compare_real (op1, op2, op);\n       break;\n \n     case BT_CHARACTER:\n@@ -1157,8 +1187,8 @@ gfc_compare_expr (gfc_expr *op1, gfc_expr *op2)\n static int\n compare_complex (gfc_expr *op1, gfc_expr *op2)\n {\n-  return (mpfr_cmp (op1->value.complex.r, op2->value.complex.r) == 0\n-\t  && mpfr_cmp (op1->value.complex.i, op2->value.complex.i) == 0);\n+  return (mpfr_equal_p (op1->value.complex.r, op2->value.complex.r)\n+\t  && mpfr_equal_p (op1->value.complex.i, op2->value.complex.i));\n }\n \n \n@@ -1206,7 +1236,7 @@ gfc_arith_eq (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t\t\t\t&op1->where);\n   result->value.logical = (op1->ts.type == BT_COMPLEX)\n \t\t\t? compare_complex (op1, op2)\n-\t\t\t: (gfc_compare_expr (op1, op2) == 0);\n+\t\t\t: (gfc_compare_expr (op1, op2, INTRINSIC_EQ) == 0);\n \n   *resultp = result;\n   return ARITH_OK;\n@@ -1222,7 +1252,7 @@ gfc_arith_ne (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t\t\t\t&op1->where);\n   result->value.logical = (op1->ts.type == BT_COMPLEX)\n \t\t\t? !compare_complex (op1, op2)\n-\t\t\t: (gfc_compare_expr (op1, op2) != 0);\n+\t\t\t: (gfc_compare_expr (op1, op2, INTRINSIC_EQ) != 0);\n \n   *resultp = result;\n   return ARITH_OK;\n@@ -1236,7 +1266,7 @@ gfc_arith_gt (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n   result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n \t\t\t\t&op1->where);\n-  result->value.logical = (gfc_compare_expr (op1, op2) > 0);\n+  result->value.logical = (gfc_compare_expr (op1, op2, INTRINSIC_GT) > 0);\n   *resultp = result;\n \n   return ARITH_OK;\n@@ -1250,7 +1280,7 @@ gfc_arith_ge (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n   result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n \t\t\t\t&op1->where);\n-  result->value.logical = (gfc_compare_expr (op1, op2) >= 0);\n+  result->value.logical = (gfc_compare_expr (op1, op2, INTRINSIC_GE) >= 0);\n   *resultp = result;\n \n   return ARITH_OK;\n@@ -1264,7 +1294,7 @@ gfc_arith_lt (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n   result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n \t\t\t\t&op1->where);\n-  result->value.logical = (gfc_compare_expr (op1, op2) < 0);\n+  result->value.logical = (gfc_compare_expr (op1, op2, INTRINSIC_LT) < 0);\n   *resultp = result;\n \n   return ARITH_OK;\n@@ -1278,7 +1308,7 @@ gfc_arith_le (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n   result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n \t\t\t\t&op1->where);\n-  result->value.logical = (gfc_compare_expr (op1, op2) <= 0);\n+  result->value.logical = (gfc_compare_expr (op1, op2, INTRINSIC_LE) <= 0);\n   *resultp = result;\n \n   return ARITH_OK;"}, {"sha": "67d73617a746929bf7e29af19988772b334c03ed", "filename": "gcc/fortran/arith.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.h?ref=7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "patch": "@@ -38,7 +38,7 @@ gfc_expr *gfc_constant_result (bt, int, locus *);\n    for overflow and underflow.  */\n arith gfc_range_check (gfc_expr *);\n \n-int gfc_compare_expr (gfc_expr *, gfc_expr *);\n+int gfc_compare_expr (gfc_expr *, gfc_expr *, gfc_intrinsic_op);\n int gfc_compare_string (gfc_expr *, gfc_expr *);\n \n /* Constant folding for gfc_expr trees.  */"}, {"sha": "5083b9b3be92993a7dd0939c10bf2d44dc24be96", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "patch": "@@ -4822,7 +4822,7 @@ compare_cases (const gfc_case *op1, const gfc_case *op2)\n       retval = 0;\n       /* op2 = (M:) or (M:N),  L < M  */\n       if (op2->low != NULL\n-\t  && gfc_compare_expr (op1->high, op2->low) < 0)\n+\t  && gfc_compare_expr (op1->high, op2->low, INTRINSIC_LT) < 0)\n \tretval = -1;\n     }\n   else if (op1->high == NULL) /* op1 = (K:)  */\n@@ -4831,23 +4831,25 @@ compare_cases (const gfc_case *op1, const gfc_case *op2)\n       retval = 0;\n       /* op2 = (:N) or (M:N), K > N  */\n       if (op2->high != NULL\n-\t  && gfc_compare_expr (op1->low, op2->high) > 0)\n+\t  && gfc_compare_expr (op1->low, op2->high, INTRINSIC_GT) > 0)\n \tretval = 1;\n     }\n   else /* op1 = (K:L)  */\n     {\n       if (op2->low == NULL)       /* op2 = (:N), K > N  */\n-\tretval = (gfc_compare_expr (op1->low, op2->high) > 0) ? 1 : 0;\n+\tretval = (gfc_compare_expr (op1->low, op2->high, INTRINSIC_GT) > 0)\n+\t\t ? 1 : 0;\n       else if (op2->high == NULL) /* op2 = (M:), L < M  */\n-\tretval = (gfc_compare_expr (op1->high, op2->low) < 0) ? -1 : 0;\n+\tretval = (gfc_compare_expr (op1->high, op2->low, INTRINSIC_LT) < 0)\n+\t\t ? -1 : 0;\n       else\t\t\t/* op2 = (M:N)  */\n \t{\n \t  retval =  0;\n \t  /* L < M  */\n-\t  if (gfc_compare_expr (op1->high, op2->low) < 0)\n+\t  if (gfc_compare_expr (op1->high, op2->low, INTRINSIC_LT) < 0)\n \t    retval =  -1;\n \t  /* K > N  */\n-\t  else if (gfc_compare_expr (op1->low, op2->high) > 0)\n+\t  else if (gfc_compare_expr (op1->low, op2->high, INTRINSIC_GT) > 0)\n \t    retval =  1;\n \t}\n     }\n@@ -5122,7 +5124,7 @@ resolve_select (gfc_code *code)\n \t      /* Unreachable case ranges are discarded, so ignore.  */\n \t      if (cp->low != NULL && cp->high != NULL\n \t\t  && cp->low != cp->high\n-\t\t  && gfc_compare_expr (cp->low, cp->high) > 0)\n+\t\t  && gfc_compare_expr (cp->low, cp->high, INTRINSIC_GT) > 0)\n \t\tcontinue;\n \n \t      /* FIXME: Should a warning be issued?  */\n@@ -5210,7 +5212,7 @@ resolve_select (gfc_code *code)\n \n \t  if (cp->low != NULL && cp->high != NULL\n \t      && cp->low != cp->high\n-\t      && gfc_compare_expr (cp->low, cp->high) > 0)\n+\t      && gfc_compare_expr (cp->low, cp->high, INTRINSIC_GT) > 0)\n \t    {\n \t      if (gfc_option.warn_surprising)\n \t\tgfc_warning (\"Range specification at %L can never \""}, {"sha": "598ec57d02b4d70f19e00736ba66177eadab20de", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "patch": "@@ -2444,10 +2444,13 @@ simplify_min_max (gfc_expr *expr, int sign)\n \t  break;\n \n \tcase BT_REAL:\n-\t  if (mpfr_cmp (arg->expr->value.real, extremum->expr->value.real)\n-\t      * sign > 0)\n-\t    mpfr_set (extremum->expr->value.real, arg->expr->value.real,\n-\t\t      GFC_RND_MODE);\n+\t  /* We need to use mpfr_min and mpfr_max to treat NaN properly.  */\n+\t  if (sign > 0)\n+\t    mpfr_max (extremum->expr->value.real, extremum->expr->value.real,\n+\t\t      arg->expr->value.real, GFC_RND_MODE);\n+\t  else\n+\t    mpfr_min (extremum->expr->value.real, extremum->expr->value.real,\n+\t\t      arg->expr->value.real, GFC_RND_MODE);\n \t  break;\n \n \tcase BT_CHARACTER:"}, {"sha": "539a0a2a641ee92f1c19dbf0e01aabec68ccdaab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "patch": "@@ -1,3 +1,8 @@\n+2007-12-05  Tobias Burnus  <bU    gcc/stmt.c\n+\n+\tPR fortran/34333\n+\t* gfortran.dg/nan_2.f90: New.\n+\n 2007-12-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/34271\n@@ -16,8 +21,8 @@\n \n 2007-12-04  Douglas Gregor  <doug.gregor@gmail.com>\n \n-       PR c++/34101\n-       * g++.dg/cpp0x/variadic-ttp.C: New.\n+\tPR c++/34101\n+\t* g++.dg/cpp0x/variadic-ttp.C: New.\n \n 2007-12-04  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \t\n@@ -26,13 +31,13 @@\n \t\n 2007-12-04  Douglas Gregor  <doug.gregor@gmail.com>\n \n-       PR c++/33509\n-       * g++.dg/cpp0x/variadic-throw.C: New.\n+\tPR c++/33509\n+\t* g++.dg/cpp0x/variadic-throw.C: New.\n \n 2007-12-04  Douglas Gregor  <doug.gregor@gmail.com>\n \n-       PR c++/33091\n-       * g++.dg/cpp0x/variadic-unify.C: New.\n+\tPR c++/33091\n+\t* g++.dg/cpp0x/variadic-unify.C: New.\n \n 2007-12-04  Richard Guenther  <rguenther@suse.de>\n "}, {"sha": "9976abc37e0df11cdb0828c02d35adfc8138785d", "filename": "gcc/testsuite/gfortran.dg/nan_2.f90", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4c5f8b9b0091733b4ae3377e294aa2651f8811/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_2.f90?ref=7b4c5f8b9b0091733b4ae3377e294aa2651f8811", "patch": "@@ -0,0 +1,105 @@\n+! { dg-do run }\n+! { dg-options \"-fno-range-check -pedantic\" }\n+!\n+! PR fortran/34333\n+!\n+! Check that (NaN /= NaN) == .TRUE.\n+! and some other NaN options.\n+!\n+! Contrary to nan_1.f90, PARAMETERs are used and thus\n+! the front end resolves the min, max and binary operators at\n+! compile time.\n+!\n+\n+module aux2\n+  interface isinf\n+    module procedure isinf_r\n+    module procedure isinf_d\n+  end interface isinf\n+contains\n+  pure function isinf_r(x) result (isinf)\n+    logical :: isinf\n+    real, intent(in) :: x\n+\n+    isinf = (x > huge(x)) .or. (x < -huge(x))\n+  end function isinf_r\n+\n+  pure function isinf_d(x) result (isinf)\n+    logical :: isinf\n+    double precision, intent(in) :: x\n+\n+    isinf = (x > huge(x)) .or. (x < -huge(x))\n+  end function isinf_d\n+end module aux2\n+\n+program test\n+  use aux2\n+  implicit none\n+  real, parameter :: nan = 0.0/0.0, large = huge(large), inf = 1.0/0.0\n+\n+  if (nan == nan .or. nan > nan .or. nan < nan .or. nan >= nan &\n+      .or. nan <= nan) call abort\n+  if (isnan (2.d0) .or. (.not. isnan(nan)) .or. &\n+      (.not. isnan(real(nan,kind=kind(2.d0))))) call abort\n+\n+  ! Create an INF and check it\n+  if (isinf(nan) .or. isinf(large) .or. .not. isinf(inf)) call abort\n+  if (isinf(-nan) .or. isinf(-large) .or. .not. isinf(-inf)) call abort\n+\n+  ! Check that MIN and MAX behave correctly\n+  if (max(2.0, nan) /= 2.0) call abort\n+  if (min(2.0, nan) /= 2.0) call abort\n+  if (max(nan, 2.0) /= 2.0) call abort\n+  if (min(nan, 2.0) /= 2.0) call abort\n+\n+  if (max(2.d0, nan) /= 2.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+  if (min(2.d0, nan) /= 2.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+  if (max(nan, 2.d0) /= 2.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+  if (min(nan, 2.d0) /= 2.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+\n+  if (.not. isnan(min(nan,nan))) call abort\n+  if (.not. isnan(max(nan,nan))) call abort\n+\n+  ! Same thing, with more arguments\n+\n+  if (max(3.0, 2.0, nan) /= 3.0) call abort\n+  if (min(3.0, 2.0, nan) /= 2.0) call abort\n+  if (max(3.0, nan, 2.0) /= 3.0) call abort\n+  if (min(3.0, nan, 2.0) /= 2.0) call abort\n+  if (max(nan, 3.0, 2.0) /= 3.0) call abort\n+  if (min(nan, 3.0, 2.0) /= 2.0) call abort\n+\n+  if (max(3.d0, 2.d0, nan) /= 3.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+  if (min(3.d0, 2.d0, nan) /= 2.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+  if (max(3.d0, nan, 2.d0) /= 3.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+  if (min(3.d0, nan, 2.d0) /= 2.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+  if (max(nan, 3.d0, 2.d0) /= 3.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+  if (min(nan, 3.d0, 2.d0) /= 2.d0) call abort ! { dg-warning \"Extension: Different type kinds\" }\n+\n+  if (.not. isnan(min(nan,nan,nan))) call abort\n+  if (.not. isnan(max(nan,nan,nan))) call abort\n+  if (.not. isnan(min(nan,nan,nan,nan))) call abort\n+  if (.not. isnan(max(nan,nan,nan,nan))) call abort\n+  if (.not. isnan(min(nan,nan,nan,nan,nan))) call abort\n+  if (.not. isnan(max(nan,nan,nan,nan,nan))) call abort\n+\n+  ! Large values, INF and NaNs\n+  if (.not. isinf(max(large, inf))) call abort\n+  if (isinf(min(large, inf))) call abort\n+  if (.not. isinf(max(nan, large, inf))) call abort\n+  if (isinf(min(nan, large, inf))) call abort\n+  if (.not. isinf(max(large, nan, inf))) call abort\n+  if (isinf(min(large, nan, inf))) call abort\n+  if (.not. isinf(max(large, inf, nan))) call abort\n+  if (isinf(min(large, inf, nan))) call abort\n+\n+  if (.not. isinf(min(-large, -inf))) call abort\n+  if (isinf(max(-large, -inf))) call abort\n+  if (.not. isinf(min(nan, -large, -inf))) call abort\n+  if (isinf(max(nan, -large, -inf))) call abort\n+  if (.not. isinf(min(-large, nan, -inf))) call abort\n+  if (isinf(max(-large, nan, -inf))) call abort\n+  if (.not. isinf(min(-large, -inf, nan))) call abort\n+  if (isinf(max(-large, -inf, nan))) call abort\n+\n+end program test"}]}