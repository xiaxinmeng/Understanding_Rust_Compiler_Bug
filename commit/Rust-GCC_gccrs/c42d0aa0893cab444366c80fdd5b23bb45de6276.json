{"sha": "c42d0aa0893cab444366c80fdd5b23bb45de6276", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQyZDBhYTA4OTNjYWI0NDQzNjZjODBmZGQ1YjIzYmI0NWRlNjI3Ng==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-01-10T21:40:14Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-01-10T21:40:14Z"}, "message": "PR tree-optimization/83671 - Fix for false positive reported by -Wstringop-overflow does not work with inlining\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/83671\n\t* gcc.dg/strlenopt-40.c: New test.\n\t* gcc.dg/strlenopt-41.c: New test.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/83671\n\t* builtins.c (c_strlen): Unconditionally return zero for the empty\n\tstring.\n\tUse -Warray-bounds for warnings.\n\t* gimple-fold.c (get_range_strlen): Handle non-constant lengths\n\tfor non-constant array indices with COMPONENT_REF, arrays of\n\tarrays, and pointers to arrays.\n\t(gimple_fold_builtin_strlen): Determine and set length range for\n\tnon-constant character arrays.\n\nFrom-SVN: r256457", "tree": {"sha": "fafafff32b2c7dda509c5af6251cf14765cc834f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fafafff32b2c7dda509c5af6251cf14765cc834f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c42d0aa0893cab444366c80fdd5b23bb45de6276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42d0aa0893cab444366c80fdd5b23bb45de6276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c42d0aa0893cab444366c80fdd5b23bb45de6276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42d0aa0893cab444366c80fdd5b23bb45de6276/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e7c6abad7f0bcbf0e60d27bc8cff1087c5195f76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c6abad7f0bcbf0e60d27bc8cff1087c5195f76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7c6abad7f0bcbf0e60d27bc8cff1087c5195f76"}], "stats": {"total": 593, "additions": 564, "deletions": 29}, "files": [{"sha": "081c04aa8a783a050858539607a9fbe68a471bf4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c42d0aa0893cab444366c80fdd5b23bb45de6276", "patch": "@@ -1,3 +1,15 @@\n+2018-01-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/83671\n+\t* builtins.c (c_strlen): Unconditionally return zero for the empty\n+\tstring.\n+\tUse -Warray-bounds for warnings.\n+\t* gimple-fold.c (get_range_strlen): Handle non-constant lengths\n+\tfor non-constant array indices with COMPONENT_REF, arrays of\n+\tarrays, and pointers to arrays.\n+\t(gimple_fold_builtin_strlen): Determine and set length range for\n+\tnon-constant character arrays.\n+\n 2018-01-10  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR middle-end/81897"}, {"sha": "a0d0a10d38fcdb3e3204f32e887d77bff6ba28a4", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c42d0aa0893cab444366c80fdd5b23bb45de6276", "patch": "@@ -621,6 +621,9 @@ c_strlen (tree src, int only_value)\n \t  return NULL_TREE;\n \t}\n \n+      if (!maxelts)\n+\treturn ssize_int (0);\n+\n       /* We don't know the starting offset, but we do know that the string\n \t has no internal zero bytes.  We can assume that the offset falls\n \t within the bounds of the string; otherwise, the programmer deserves\n@@ -651,7 +654,8 @@ c_strlen (tree src, int only_value)\n       if (only_value != 2\n \t  && !TREE_NO_WARNING (src))\n         {\n-\t  warning_at (loc, 0, \"offset %qwi outside bounds of constant string\",\n+\t  warning_at (loc, OPT_Warray_bounds,\n+\t\t      \"offset %qwi outside bounds of constant string\",\n \t\t      eltoff);\n           TREE_NO_WARNING (src) = 1;\n         }"}, {"sha": "504a85d1441da6814229dee3028793b13cba2cde", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 113, "deletions": 27, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c42d0aa0893cab444366c80fdd5b23bb45de6276", "patch": "@@ -1299,7 +1299,7 @@ static bool\n get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t\t  bool fuzzy, bool *flexp)\n {\n-  tree var, val;\n+  tree var, val = NULL_TREE;\n   gimple *def_stmt;\n \n   /* The minimum and maximum length.  The MAXLEN pointer stays unchanged\n@@ -1311,14 +1311,33 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n     {\n       /* We can end up with &(*iftmp_1)[0] here as well, so handle it.  */\n       if (TREE_CODE (arg) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF\n-\t  && integer_zerop (TREE_OPERAND (TREE_OPERAND (arg, 0), 1)))\n+\t  && TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF)\n \t{\n-\t  tree aop0 = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-\t  if (TREE_CODE (aop0) == INDIRECT_REF\n-\t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n-\t    return get_range_strlen (TREE_OPERAND (aop0, 0),\n-\t\t\t\t     length, visited, type, fuzzy, flexp);\n+\t  tree op = TREE_OPERAND (arg, 0);\n+\t  if (integer_zerop (TREE_OPERAND (op, 1)))\n+\t    {\n+\t      tree aop0 = TREE_OPERAND (op, 0);\n+\t      if (TREE_CODE (aop0) == INDIRECT_REF\n+\t\t  && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n+\t\treturn get_range_strlen (TREE_OPERAND (aop0, 0),\n+\t\t\t\t\t length, visited, type, fuzzy, flexp);\n+\t    }\n+\t  else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF && fuzzy)\n+\t    {\n+\t      /* Fail if an array is the last member of a struct object\n+\t\t since it could be treated as a (fake) flexible array\n+\t\t member.  */\n+\t      tree idx = TREE_OPERAND (op, 1);\n+\n+\t      arg = TREE_OPERAND (op, 0);\n+\t      tree optype = TREE_TYPE (arg);\n+\t      if (tree dom = TYPE_DOMAIN (optype))\n+\t\tif (tree bound = TYPE_MAX_VALUE (dom))\n+\t\t  if (TREE_CODE (bound) == INTEGER_CST\n+\t\t      && TREE_CODE (idx) == INTEGER_CST\n+\t\t      && tree_int_cst_lt (bound, idx))\n+\t\t    return false;\n+\t    }\n \t}\n \n       if (type == 2)\n@@ -1337,21 +1356,48 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t    return get_range_strlen (TREE_OPERAND (arg, 0), length,\n \t\t\t\t     visited, type, fuzzy, flexp);\n \n-\t  if (TREE_CODE (arg) == COMPONENT_REF\n+\t  if (TREE_CODE (arg) == ARRAY_REF)\n+\t    {\n+\t      tree type = TREE_TYPE (TREE_OPERAND (arg, 0));\n+\n+\t      while (TREE_CODE (type) == ARRAY_TYPE\n+\t\t     && TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n+\t\ttype = TREE_TYPE (type);\n+\n+\t      val = TYPE_SIZE_UNIT (type);\n+\t      if (!val || integer_zerop (val))\n+\t\treturn false;\n+\n+\t      val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n+\t\t\t\t integer_one_node);\n+\t      /* Set the minimum size to zero since the string in\n+\t\t the array could have zero length.  */\n+\t      *minlen = ssize_int (0);\n+\t    }\n+\t  else if (TREE_CODE (arg) == COMPONENT_REF\n \t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 1))) == ARRAY_TYPE)\n \t    {\n \t      /* Use the type of the member array to determine the upper\n \t\t bound on the length of the array.  This may be overly\n \t\t optimistic if the array itself isn't NUL-terminated and\n \t\t the caller relies on the subsequent member to contain\n-\t\t the NUL.\n+\t\t the NUL but that would only be considered valid if\n+\t\t the array were the last member of a struct.\n \t\t Set *FLEXP to true if the array whose bound is being\n \t\t used is at the end of a struct.  */\n \t      if (array_at_struct_end_p (arg))\n \t\t*flexp = true;\n \n \t      arg = TREE_OPERAND (arg, 1);\n-\t      val = TYPE_SIZE_UNIT (TREE_TYPE (arg));\n+\n+\t      tree type = TREE_TYPE (arg);\n+\n+\t      while (TREE_CODE (type) == ARRAY_TYPE\n+\t\t     && TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n+\t\ttype = TREE_TYPE (type);\n+\n+\t      /* Fail when the array bound is unknown or zero.  */\n+\t      val = TYPE_SIZE_UNIT (type);\n \t      if (!val || integer_zerop (val))\n \t\treturn false;\n \t      val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n@@ -1361,17 +1407,25 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t      *minlen = ssize_int (0);\n \t    }\n \n-\t  if (VAR_P (arg) \n-\t      && TREE_CODE (TREE_TYPE (arg)) == ARRAY_TYPE)\n+\t  if (VAR_P (arg))\n \t    {\n-\t      val = TYPE_SIZE_UNIT (TREE_TYPE (arg));\n-\t      if (!val || TREE_CODE (val) != INTEGER_CST || integer_zerop (val))\n-\t\treturn false;\n-\t      val = wide_int_to_tree (TREE_TYPE (val), \n-\t\t\t\t      wi::sub(wi::to_wide (val), 1));\n-\t      /* Set the minimum size to zero since the string in\n-\t\t the array could have zero length.  */\n-\t      *minlen = ssize_int (0);\n+\t      tree type = TREE_TYPE (arg);\n+\t      if (POINTER_TYPE_P (type))\n+\t\ttype = TREE_TYPE (type);\n+\n+\t      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t\t{\n+\t\t  val = TYPE_SIZE_UNIT (type);\n+\t\t  if (!val\n+\t\t      || TREE_CODE (val) != INTEGER_CST\n+\t\t      || integer_zerop (val))\n+\t\t    return false;\n+\t\t  val = wide_int_to_tree (TREE_TYPE (val),\n+\t\t\t\t\t  wi::sub(wi::to_wide (val), 1));\n+\t\t  /* Set the minimum size to zero since the string in\n+\t\t     the array could have zero length.  */\n+\t\t  *minlen = ssize_int (0);\n+\t\t}\n \t    }\n \t}\n \n@@ -3462,12 +3516,44 @@ static bool\n gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n-  tree len = get_maxval_strlen (gimple_call_arg (stmt, 0), 0);\n-  if (!len)\n-    return false;\n-  len = force_gimple_operand_gsi (gsi, len, true, NULL, true, GSI_SAME_STMT);\n-  replace_call_with_value (gsi, len);\n-  return true;\n+\n+  wide_int minlen;\n+  wide_int maxlen;\n+\n+  tree lenrange[2];\n+  if (!get_range_strlen (gimple_call_arg (stmt, 0), lenrange)\n+      && lenrange[0] && TREE_CODE (lenrange[0]) == INTEGER_CST\n+      && lenrange[1] && TREE_CODE (lenrange[1]) == INTEGER_CST)\n+    {\n+      /* The range of lengths refers to either a single constant\n+\t string or to the longest and shortest constant string\n+\t referenced by the argument of the strlen() call, or to\n+\t the strings that can possibly be stored in the arrays\n+\t the argument refers to.  */\n+      minlen = wi::to_wide (lenrange[0]);\n+      maxlen = wi::to_wide (lenrange[1]);\n+    }\n+  else\n+    {\n+      unsigned prec = TYPE_PRECISION (sizetype);\n+\n+      minlen = wi::shwi (0, prec);\n+      maxlen = wi::to_wide (max_object_size (), prec) - 2;\n+    }\n+\n+  if (minlen == maxlen)\n+    {\n+      lenrange[0] = force_gimple_operand_gsi (gsi, lenrange[0], true, NULL,\n+\t\t\t\t\t      true, GSI_SAME_STMT);\n+      replace_call_with_value (gsi, lenrange[0]);\n+      return true;\n+    }\n+\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+    set_range_info (lhs, VR_RANGE, minlen, maxlen);\n+\n+  return false;\n }\n \n /* Fold a call to __builtin_acc_on_device.  */"}, {"sha": "10273a9d8a68f3312aec89cf7fea186aec8f21ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c42d0aa0893cab444366c80fdd5b23bb45de6276", "patch": "@@ -1,3 +1,9 @@\n+2018-01-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/83671\n+\t* gcc.dg/strlenopt-40.c: New test.\n+\t* gcc.dg/strlenopt-41.c: New test.\n+\n 2018-01-10  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/83093"}, {"sha": "a0b0d47de1b1b6c6d50af8417220ef5802f32416", "filename": "gcc/testsuite/g++.dg/warn/string1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fstring1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fstring1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fstring1.C?ref=c42d0aa0893cab444366c80fdd5b23bb45de6276", "patch": "@@ -1,5 +1,5 @@\n // PR c++/35652\n-// { dg-options \"-O\" }\n+// { dg-options \"-O -Wall\" }\n \n #include <string>\n int test() {"}, {"sha": "f4577d69e1a40dd098aac553dc452825db85f507", "filename": "gcc/testsuite/gcc.dg/strlenopt-40.c", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c?ref=c42d0aa0893cab444366c80fdd5b23bb45de6276", "patch": "@@ -0,0 +1,393 @@\n+/* PR tree-optimization/83671 - fix for false positive reported by\n+   -Wstringop-overflow does not work with inlining\n+   { dg-do compile }\n+   { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define DIFF_MAX __PTRDIFF_MAX__\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macros to emit a call to funcation named\n+     call_in_{true,false}_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM_TRUE(expr) \\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+#define ELIM_FALSE(expr)\t\t\t\t\t\\\n+  if (!!(expr)) FAIL (in_false_branch_not_eliminated); else (void)0\n+\n+/* Macro to emit a call to a function named\n+     call_made_in_{true,false}_branch_on_line_NNN()\n+   for each call that's expected to be retained.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that the expected number of both kinds of calls appears in output\n+   (a pair for each line with the invocation of the KEEP() macro.  */\n+#define KEEP(expr)\t\t\t\t\\\n+  if (expr)\t\t\t\t\t\\\n+    FAIL (made_in_true_branch);\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    FAIL (made_in_false_branch)\n+\n+typedef char A3[3], A5[5], A7[7], AX[];\n+\n+typedef A3 A7_3[7];\n+typedef A3 AX_3[];\n+typedef A5 A7_5[7];\n+typedef A7 A5_7[5];\n+\n+extern A7_3 a7_3;\n+extern A5_7 a5_7;\n+extern AX_3 ax_3;\n+\n+extern A3 a3;\n+extern A7 a5;\n+extern A7 a7;\n+extern AX ax;\n+\n+extern A3 *pa3;\n+extern A5 *pa5;\n+extern A7 *pa7;\n+\n+extern A7_3 *pa7_3;\n+extern AX_3 *pax_3;\n+extern A5_7 *pa5_7;\n+extern A7_5 *pa7_5;\n+\n+extern char *ptr;\n+\n+struct MemArrays0 {\n+  A7_3 a7_3;\n+  A5_7 a5_7;\n+  char a3[3], a5[5], a0[0];\n+};\n+struct MemArraysX { char a3[3], a5[5], ax[]; };\n+struct MemArrays7 { char a3[3], a5[5], a7[7]; };\n+\n+struct MemArrays0 ma0_3_5_7[3][5][7];\n+\n+void elim_strings (int i)\n+{\n+  ELIM_TRUE (strlen (i < 0 ? \"123\" : \"321\") == 3);\n+  ELIM_FALSE (strlen (i < 0 ? \"123\" : \"321\") > 3);\n+  ELIM_FALSE (strlen (i < 0 ? \"123\" : \"321\") < 3);\n+\n+  ELIM_TRUE (strlen (i < 0 ? \"123\" : \"4321\") >= 3);\n+  ELIM_FALSE (strlen (i < 0 ? \"123\" : \"4321\") > 4);\n+  ELIM_FALSE (strlen (i < 0 ? \"123\" : \"4321\") < 3);\n+\n+  ELIM_TRUE (strlen (i < 0 ? \"1234\" : \"321\") >= 3);\n+  ELIM_FALSE (strlen (i < 0 ? \"1234\" : \"321\") < 3);\n+  ELIM_FALSE (strlen (i < 0 ? \"1234\" : \"321\") > 4);\n+\n+  ELIM_TRUE (strlen (i < 0 ? \"123\" : \"4321\") <= 4);\n+  ELIM_TRUE (strlen (i < 0 ? \"1234\" : \"321\") <= 4);\n+\n+  ELIM_TRUE (strlen (i < 0 ? \"1\" : \"123456789\") <= 9);\n+  ELIM_TRUE (strlen (i < 0 ? \"1\" : \"123456789\") >= 1);\n+}\n+\n+/* Verify that strlen calls involving uninitialized global arrays\n+   of known size are eliminated when they appear in expressions\n+   that test for results that must be true.  */\n+void elim_global_arrays (int i)\n+{\n+  /* Verify that the expression involving the strlen call as well\n+     as whatever depends on it is eliminated  from the test output.\n+     All these expressions must be trivially true.  */\n+  ELIM_TRUE (strlen (a7_3[0]) < sizeof a7_3[0]);\n+  ELIM_TRUE (strlen (a7_3[1]) < sizeof a7_3[1]);\n+  ELIM_TRUE (strlen (a7_3[6]) < sizeof a7_3[6]);\n+  ELIM_TRUE (strlen (a7_3[i]) < sizeof a7_3[i]);\n+\n+  ELIM_TRUE (strlen (a5_7[0]) < sizeof a5_7[0]);\n+  ELIM_TRUE (strlen (a5_7[1]) < sizeof a5_7[1]);\n+  ELIM_TRUE (strlen (a5_7[4]) < sizeof a5_7[4]);\n+  ELIM_TRUE (strlen (a5_7[i]) < sizeof a5_7[0]);\n+\n+  ELIM_TRUE (strlen (ax_3[0]) < sizeof ax_3[0]);\n+  ELIM_TRUE (strlen (ax_3[1]) < sizeof ax_3[1]);\n+  ELIM_TRUE (strlen (ax_3[9]) < sizeof ax_3[9]);\n+  ELIM_TRUE (strlen (ax_3[i]) < sizeof ax_3[i]);\n+\n+  ELIM_TRUE (strlen (a3) < sizeof a3);\n+  ELIM_TRUE (strlen (a7) < sizeof a7);\n+\n+  ELIM_TRUE (strlen (ax) != DIFF_MAX);\n+  ELIM_TRUE (strlen (ax) != DIFF_MAX - 1);\n+  ELIM_TRUE (strlen (ax) < DIFF_MAX - 1);\n+}\n+\n+void elim_pointer_to_arrays (void)\n+{\n+  ELIM_TRUE (strlen (*pa7) < 7);\n+  ELIM_TRUE (strlen (*pa5) < 5);\n+  ELIM_TRUE (strlen (*pa3) < 3);\n+\n+  ELIM_TRUE (strlen ((*pa7_3)[0]) < 3);\n+  ELIM_TRUE (strlen ((*pa7_3)[1]) < 3);\n+  ELIM_TRUE (strlen ((*pa7_3)[6]) < 3);\n+\n+  ELIM_TRUE (strlen ((*pax_3)[0]) < 3);\n+  ELIM_TRUE (strlen ((*pax_3)[1]) < 3);\n+  ELIM_TRUE (strlen ((*pax_3)[9]) < 3);\n+\n+  ELIM_TRUE (strlen ((*pa5_7)[0]) < 7);\n+  ELIM_TRUE (strlen ((*pa5_7)[1]) < 7);\n+  ELIM_TRUE (strlen ((*pa5_7)[4]) < 7);\n+}\n+\n+void elim_global_arrays_and_strings (int i)\n+{\n+  ELIM_TRUE (strlen (i < 0 ? a3 : \"\") < 3);\n+  ELIM_TRUE (strlen (i < 0 ? a3 : \"1\") < 3);\n+  ELIM_TRUE (strlen (i < 0 ? a3 : \"12\") < 3);\n+  ELIM_TRUE (strlen (i < 0 ? a3 : \"123\") < 4);\n+\n+  ELIM_FALSE (strlen (i < 0 ? a3 : \"\") > 3);\n+  ELIM_FALSE (strlen (i < 0 ? a3 : \"1\") > 3);\n+  ELIM_FALSE (strlen (i < 0 ? a3 : \"12\") > 3);\n+  ELIM_FALSE (strlen (i < 0 ? a3 : \"123\") > 4);\n+\n+  ELIM_TRUE (strlen (i < 0 ? a7 : \"\") < 7);\n+  ELIM_TRUE (strlen (i < 0 ? a7 : \"1\") < 7);\n+  ELIM_TRUE (strlen (i < 0 ? a7 : \"12\") < 7);\n+  ELIM_TRUE (strlen (i < 0 ? a7 : \"123\") < 7);\n+  ELIM_TRUE (strlen (i < 0 ? a7 : \"123456\") < 7);\n+  ELIM_TRUE (strlen (i < 0 ? a7 : \"1234567\") < 8);\n+\n+  ELIM_FALSE (strlen (i < 0 ? a7 : \"\") > 6);\n+  ELIM_FALSE (strlen (i < 0 ? a7 : \"1\") > 6);\n+  ELIM_FALSE (strlen (i < 0 ? a7 : \"12\") > 6);\n+  ELIM_FALSE (strlen (i < 0 ? a7 : \"123\") > 6);\n+  ELIM_FALSE (strlen (i < 0 ? a7 : \"123456\") > 7);\n+  ELIM_FALSE (strlen (i < 0 ? a7 : \"1234567\") > 8);\n+}\n+\n+void elim_member_arrays_obj (int i)\n+{\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a3) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][1].a3) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][2].a3) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][6].a3) < 3);\n+\n+  ELIM_TRUE (strlen (ma0_3_5_7[1][0][0].a3) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][0][1].a3) < 3);\n+\n+  ELIM_TRUE (strlen (ma0_3_5_7[1][1][0].a3) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a3) < 3);\n+\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a5) < 5);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][1].a5) < 5);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][2].a5) < 5);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][6].a5) < 5);\n+\n+  ELIM_TRUE (strlen (ma0_3_5_7[1][0][0].a5) < 5);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][0][1].a5) < 5);\n+\n+  ELIM_TRUE (strlen (ma0_3_5_7[1][1][0].a5) < 5);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a5) < 5);\n+\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a7_3[0]) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a7_3[2]) < 3);\n+\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a5_7[0]) < 7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a5_7[4]) < 7);\n+}\n+\n+void elim_member_arrays_ptr (struct MemArrays0 *ma0,\n+\t\t\t     struct MemArraysX *max,\n+\t\t\t     struct MemArrays7 *ma7,\n+\t\t\t     int i)\n+{\n+  ELIM_TRUE (strlen (ma0->a7_3[0]) < 3);\n+  ELIM_TRUE (strlen (ma0->a7_3[1]) < 3);\n+  ELIM_TRUE (strlen (ma0->a7_3[6]) < 3);\n+  ELIM_TRUE (strlen (ma0->a7_3[6]) < 3);\n+  ELIM_TRUE (strlen (ma0->a7_3[i]) < 3);\n+  ELIM_TRUE (strlen (ma0->a7_3[i]) < 3);\n+\n+  ELIM_TRUE (strlen (ma0->a5_7[0]) < 7);\n+  ELIM_TRUE (strlen (ma0[0].a5_7[0]) < 7);\n+  ELIM_TRUE (strlen (ma0[1].a5_7[0]) < 7);\n+  ELIM_TRUE (strlen (ma0[1].a5_7[4]) < 7);\n+  ELIM_TRUE (strlen (ma0[9].a5_7[0]) < 7);\n+  ELIM_TRUE (strlen (ma0[9].a5_7[4]) < 7);\n+\n+  ELIM_TRUE (strlen (ma0->a3) < sizeof ma0->a3);\n+  ELIM_TRUE (strlen (ma0->a5) < sizeof ma0->a5);\n+  ELIM_TRUE (strlen (ma0->a0) < DIFF_MAX - 1);\n+\n+  ELIM_TRUE (strlen (max->a3) < sizeof max->a3);\n+  ELIM_TRUE (strlen (max->a5) < sizeof max->a5);\n+  ELIM_TRUE (strlen (max->ax) < DIFF_MAX - 1);\n+\n+  ELIM_TRUE (strlen (ma7->a3) < sizeof max->a3);\n+  ELIM_TRUE (strlen (ma7->a5) < sizeof max->a5);\n+  ELIM_TRUE (strlen (ma7->a7) < DIFF_MAX - 1);\n+}\n+\n+\n+#line 1000\n+\n+/* Verify that strlen calls involving uninitialized global arrays\n+   of unknown size are not eliminated when they appear in expressions\n+   that test for results that need not be true.  */\n+void keep_global_arrays (int i)\n+{\n+  KEEP (strlen (a7_3[0]) < 2);\n+  KEEP (strlen (a7_3[1]) < 2);\n+  KEEP (strlen (a7_3[6]) < 2);\n+  KEEP (strlen (a7_3[i]) < 2);\n+\n+  KEEP (strlen (a5_7[0]) < 6);\n+  KEEP (strlen (a5_7[1]) < 6);\n+  KEEP (strlen (a5_7[4]) < 6);\n+  KEEP (strlen (a5_7[i]) < 6);\n+\n+  KEEP (strlen (ax_3[0]) < 2);\n+  KEEP (strlen (ax_3[1]) < 2);\n+  KEEP (strlen (ax_3[2]) < 2);\n+  KEEP (strlen (ax_3[i]) < 2);\n+\n+  KEEP (strlen (a3) < 2);\n+  KEEP (strlen (a7) < 6);\n+\n+  KEEP (strlen (a3 + i) < 2);\n+  KEEP (strlen (a7 + i) < 2);\n+\n+  /* The length of an array of unknown size may be as large as\n+     DIFF_MAX - 2.  */\n+  KEEP (strlen (ax) != DIFF_MAX - 2);\n+  KEEP (strlen (ax) < DIFF_MAX - 2);\n+  KEEP (strlen (ax) < 999);\n+  KEEP (strlen (ax) < 1);\n+}\n+\n+void keep_pointer_to_arrays (void)\n+{\n+  KEEP (strlen (*pa7) < 6);\n+  KEEP (strlen (*pa5) < 4);\n+  KEEP (strlen (*pa3) < 2);\n+\n+  KEEP (strlen ((*pa7_3)[0]) < 2);\n+  KEEP (strlen ((*pa7_3)[1]) < 2);\n+  KEEP (strlen ((*pa7_3)[6]) < 2);\n+\n+  KEEP (strlen ((*pax_3)[0]) < 2);\n+  KEEP (strlen ((*pax_3)[1]) < 2);\n+  KEEP (strlen ((*pax_3)[9]) < 2);\n+\n+  KEEP (strlen ((*pa5_7)[0]) < 6);\n+  KEEP (strlen ((*pa5_7)[1]) < 6);\n+  KEEP (strlen ((*pa5_7)[4]) < 6);\n+}\n+\n+void keep_global_arrays_and_strings (int i)\n+{\n+  KEEP (strlen (i < 0 ? a3 : \"\") < 2);\n+  KEEP (strlen (i < 0 ? a3 : \"1\") < 2);\n+  KEEP (strlen (i < 0 ? a3 : \"12\") < 2);\n+  KEEP (strlen (i < 0 ? a3 : \"123\") < 3);\n+\n+  KEEP (strlen (i < 0 ? a7 : \"\") < 5);\n+  KEEP (strlen (i < 0 ? a7 : \"1\") < 5);\n+  KEEP (strlen (i < 0 ? a7 : \"12\") < 5);\n+  KEEP (strlen (i < 0 ? a7 : \"123\") < 5);\n+  KEEP (strlen (i < 0 ? a7 : \"123456\") < 6);\n+  KEEP (strlen (i < 0 ? a7 : \"1234567\") < 6);\n+}\n+\n+void keep_member_arrays_obj (int i)\n+{\n+  KEEP (strlen (ma0_3_5_7[0][0][0].a3) < 2);\n+  KEEP (strlen (ma0_3_5_7[0][0][1].a3) < 2);\n+  KEEP (strlen (ma0_3_5_7[0][0][2].a3) < 2);\n+  KEEP (strlen (ma0_3_5_7[0][0][6].a3) < 2);\n+\n+  KEEP (strlen (ma0_3_5_7[1][0][0].a3) < 2);\n+  KEEP (strlen (ma0_3_5_7[2][0][1].a3) < 2);\n+\n+  KEEP (strlen (ma0_3_5_7[1][1][0].a3) < 2);\n+  KEEP (strlen (ma0_3_5_7[2][4][6].a3) < 2);\n+\n+  KEEP (strlen (ma0_3_5_7[0][0][0].a5) < 4);\n+  KEEP (strlen (ma0_3_5_7[0][0][1].a5) < 4);\n+  KEEP (strlen (ma0_3_5_7[0][0][2].a5) < 4);\n+  KEEP (strlen (ma0_3_5_7[0][0][6].a5) < 4);\n+\n+  KEEP (strlen (ma0_3_5_7[1][0][0].a5) < 4);\n+  KEEP (strlen (ma0_3_5_7[2][0][1].a5) < 4);\n+\n+  KEEP (strlen (ma0_3_5_7[1][1][0].a5) < 4);\n+  KEEP (strlen (ma0_3_5_7[2][4][6].a5) < 4);\n+\n+  KEEP (strlen (ma0_3_5_7[0][0][0].a7_3[0]) < 2);\n+  KEEP (strlen (ma0_3_5_7[2][4][6].a7_3[2]) < 2);\n+\n+  KEEP (strlen (ma0_3_5_7[0][0][0].a5_7[0]) < 6);\n+  KEEP (strlen (ma0_3_5_7[2][4][6].a5_7[4]) < 6);\n+}\n+\n+void keep_member_arrays_ptr (struct MemArrays0 *ma0,\n+\t\t\t     struct MemArraysX *max,\n+\t\t\t     struct MemArrays7 *ma7,\n+\t\t\t     int i)\n+{\n+  KEEP (strlen (ma0->a7_3[0]) > 0);\n+  KEEP (strlen (ma0->a7_3[0]) < 2);\n+  KEEP (strlen (ma0->a7_3[1]) < 2);\n+  KEEP (strlen (ma0->a7_3[6]) < 2);\n+  KEEP (strlen (ma0->a7_3[6]) < 2);\n+  KEEP (strlen (ma0->a7_3[i]) > 0);\n+  KEEP (strlen (ma0->a7_3[i]) < 2);\n+  KEEP (strlen (ma0->a7_3[i]) < 2);\n+\n+  KEEP (strlen (ma0->a5_7[0]) < 5);\n+  KEEP (strlen (ma0[0].a5_7[0]) < 5);\n+  KEEP (strlen (ma0[1].a5_7[0]) < 5);\n+  KEEP (strlen (ma0[9].a5_7[0]) < 5);\n+  KEEP (strlen (ma0[9].a5_7[4]) < 5);\n+  KEEP (strlen (ma0[i].a5_7[4]) < 5);\n+  KEEP (strlen (ma0[i].a5_7[i]) < 5);\n+\n+  KEEP (strlen (ma0->a0) < DIFF_MAX - 2);\n+  KEEP (strlen (ma0->a0) < 999);\n+  KEEP (strlen (ma0->a0) < 1);\n+\n+  KEEP (strlen (max->ax) < DIFF_MAX - 2);\n+  KEEP (strlen (max->ax) < 999);\n+  KEEP (strlen (max->ax) < 1);\n+\n+  KEEP (strlen (ma7->a7) < DIFF_MAX - 2);\n+  KEEP (strlen (ma7->a7) < 999);\n+  KEEP (strlen (ma7->a7) < 1);\n+}\n+\n+void keep_pointers (const char *s)\n+{\n+  KEEP (strlen (ptr) < DIFF_MAX - 2);\n+  KEEP (strlen (ptr) < 999);\n+  KEEP (strlen (ptr) < 1);\n+\n+  KEEP (strlen (s) < DIFF_MAX - 2);\n+  KEEP (strlen (s) < 999);\n+  KEEP (strlen (s) < 1);\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated_\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_in_false_branch_not_eliminated_\" 0 \"optimized\" } }\n+\n+   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 92 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 92 \"optimized\" } } */"}, {"sha": "c5e8eb6d8df8dc5176297d8f7ca9b2a8e6c04786", "filename": "gcc/testsuite/gcc.dg/strlenopt-41.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42d0aa0893cab444366c80fdd5b23bb45de6276/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-41.c?ref=c42d0aa0893cab444366c80fdd5b23bb45de6276", "patch": "@@ -0,0 +1,34 @@\n+/* PR tree-optimization/83671 - fix for false positive reported by\n+   -Wstringop-overflow does not work with inlining\n+   Verify that the length the empty string is folded to zero even at -O1\n+   regardless of offset into it.\n+   Also verify that the length of a non-empty string isn't folded given\n+   a variable offset.\n+   { dg-do compile }\n+   { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+inline unsigned length (const char *s)\n+{\n+  return __builtin_strlen (s);\n+}\n+\n+void check_length_cst (int i)\n+{\n+  unsigned len = length (&\"\"[i]);\n+\n+  if (len)\n+    __builtin_abort ();\n+}\n+\n+void check_length_var (int i)\n+{\n+  unsigned len = length (&\"1\"[i]);\n+\n+  if (len != 1)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"abort\" 1 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"strlen\" 1 \"optimized\" } } */"}]}