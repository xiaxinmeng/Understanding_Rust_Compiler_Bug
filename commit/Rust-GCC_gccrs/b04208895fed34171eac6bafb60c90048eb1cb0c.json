{"sha": "b04208895fed34171eac6bafb60c90048eb1cb0c", "node_id": "C_kwDOANBUbNoAKGIwNDIwODg5NWZlZDM0MTcxZWFjNmJhZmI2MGM5MDA0OGViMWNiMGM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-27T06:04:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-27T06:18:00Z"}, "message": "c++: Implement P1467R9 - Extended floating-point types and standard names compiler part except for bfloat16 [PR106652]\n\nThe following patch implements the compiler part of C++23\nP1467R9 - Extended floating-point types and standard names compiler part\nby introducing _Float{16,32,64,128} as keywords and builtin types\nlike they are implemented for C already since GCC 7, with DF{16,32,64,128}_\nmangling.\nIt also introduces _Float{32,64,128}x for C++ with the\nhttps://github.com/itanium-cxx-abi/cxx-abi/pull/147\nproposed mangling of DF{32,64,128}x.\nThe patch doesn't add anything for bfloat16_t support, as right now\n__bf16 type refuses all conversions and arithmetic operations.\nThe patch wants to keep backwards compatibility with how __float128 has\nbeen handled in C++ before, both for mangling and behavior in binary\noperations, overload resolution etc.  So, there are some backend changes\nwhere for C __float128 and _Float128 are the same type (float128_type_node\nand float128t_type_node are the same pointer), but for C++ they are distinct\ntypes which mangle differently and _Float128 is treated as extended\nfloating-point type while __float128 is treated as non-standard floating\npoint type.  The various C++23 changes about how floating-point types\nare changed are actually implemented as written in the spec only if at least\none of the types involved is _Float{16,32,64,128,32x,64x,128x} (_FloatNx are\nalso treated as extended floating-point types) and kept previous behavior\notherwise.  For float/double/long double the rules are actually written that\nthey behave the same as before.\nThere is some backwards incompatibility at least on x86 regarding _Float16,\nbecause that type was already used by that name and with the DF16_ mangling\n(but only since GCC 12 and I think it isn't that widely used in the wild\nyet).  E.g. config/i386/avx512fp16intrin.h shows the issues, where\nin C or in GCC 12 in C++ one could pass 0.0f to a builtin taking _Float16\nargument, but with the changes that is not possible anymore, one needs\nto either use 0.0f16 or (_Float16) 0.0f.\nWe have also a problem with glibc headers, where since glibc 2.27\nmath.h and complex.h aren't compilable with these changes.  One gets\nerrors like:\nIn file included from /usr/include/math.h:43,\n                 from abc.c:1:\n/usr/include/bits/floatn.h:86:9: error: multiple types in one declaration\n   86 | typedef __float128 _Float128;\n      |         ^~~~~~~~~~\n/usr/include/bits/floatn.h:86:20: error: declaration does not declare anything [-fpermissive]\n   86 | typedef __float128 _Float128;\n      |                    ^~~~~~~~~\nIn file included from /usr/include/bits/floatn.h:119:\n/usr/include/bits/floatn-common.h:214:9: error: multiple types in one declaration\n  214 | typedef float _Float32;\n      |         ^~~~~\n/usr/include/bits/floatn-common.h:214:15: error: declaration does not declare anything [-fpermissive]\n  214 | typedef float _Float32;\n      |               ^~~~~~~~\n/usr/include/bits/floatn-common.h:251:9: error: multiple types in one declaration\n  251 | typedef double _Float64;\n      |         ^~~~~~\n/usr/include/bits/floatn-common.h:251:16: error: declaration does not declare anything [-fpermissive]\n  251 | typedef double _Float64;\n      |                ^~~~~~~~\nThis is from snippets like:\n /* The remaining of this file provides support for older compilers.  */\n # if __HAVE_FLOAT128\n\n /* The type _Float128 exists only since GCC 7.0.  */\n #  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n typedef __float128 _Float128;\n #  endif\nwhere it hardcodes that C++ doesn't have _Float{16,32,64,128,32x,64x,128x} support nor\n{f,F}{16,32,64,128}{,x} literal suffixes nor _Complex _Float{16,32,64,128,32x,64x,128x}.\nThe patch fixincludes this for now and hopefully if this is committed, then\nglibc can change those.  The patch changes those\n #  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\nconditions to\n #  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\nAnother thing is mangling, as said above, Itanium C++ ABI specifies\nDF <number> _ as _Float{16,32,64,128} mangling, but GCC was implementing\na mangling incompatible with that starting with DF for fixed point types.\nFixed point was never supported in C++ though, I believe the reason why\nthe mangling has been added was that due to a bug it would leak into the\nC++ FE through decltype (0.0r) etc.  But that has been shortly after the\nmangling was added fixed (I think in the same GCC release cycle), so we\nnow reject 0.0r etc. in C++.  If we ever need the fixed point mangling,\nI think it can be readded but better with a different prefix so that it\ndoesn't conflict with the published standard manglings.  So, this patch\nalso kills the fixed point mangling and implements the DF <number> _\ndemangling.\nThe patch predefines __STDCPP_FLOAT{16,32,64,128}_T__ macros when\nthose types are available, but only for C++23, while the underlying types\nare available in C++98 and later including the {f,F}{16,32,64,128} literal\nsuffixes (but those with a pedwarn for C++20 and earlier).  My understanding\nis that it needs to be predefined by the compiler, on the other side\npredefining even for older modes when <stdfloat> is a new C++23 header\nwould be weird.  One can find out if _Float{16,32,64,128,32x,64x,128x} is\nsupported in C++ by\n__GNUC__ >= 13 && defined(__FLT{16,32,64,128,32X,64X,128X}_MANT_DIG__)\n(but that doesn't work well with older G++ 13 snapshots).\n\nAs for std::bfloat16_t, three targets (aarch64, arm and x86) apparently\n\"support\" __bf16 type which has the bfloat16 format, but isn't really\nusable, e.g. {aarch64,arm,ix86}_invalid_conversion disallow any conversions\nfrom or to type with BFmode, {aarch64,arm,ix86}_invalid_unary_op disallows\nany unary operations on those except for ADDR_EXPR and\n{aarch64,arm,ix86}_invalid_binary_op disallows any binary operation on\nthose.  So, I think we satisfy:\n\"If the implementation supports an extended floating-point type with the\nproperties, as specified by ISO/IEC/IEEE 60559, of radix (b) of 2, storage\nwidth in bits (k) of 16, precision in bits (p) of 8, maximum exponent (emax)\nof 127, and exponent field width in bits (w) of 8, then the typedef-name\nstd::bfloat16_t is defined in the header <stdfloat> and names such a type,\nthe macro __STDCPP_BFLOAT16_T__ is defined, and the floating-point literal\nsuffixes bf16 and BF16 are supported.\"\nbecause we don't really support those right now.\n\n2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/106652\n\tPR c++/85518\ngcc/\n\t* tree-core.h (enum tree_index): Add TI_FLOAT128T_TYPE\n\tenumerator.\n\t* tree.h (float128t_type_node): Define.\n\t* tree.cc (build_common_tree_nodes): Initialize float128t_type_node.\n\t* builtins.def (DEF_FLOATN_BUILTIN): Adjust comment now that\n\t_Float<N> is supported in C++ too.\n\t* config/i386/i386.cc (ix86_mangle_type): Only mangle as \"g\"\n\tfloat128t_type_node.\n\t* config/i386/i386-builtins.cc (ix86_init_builtin_types): Use\n\tfloat128t_type_node for __float128 instead of float128_type_node\n\tand create it if NULL.\n\t* config/i386/avx512fp16intrin.h (_mm_setzero_ph, _mm256_setzero_ph,\n\t_mm512_setzero_ph, _mm_set_sh, _mm_load_sh): Use 0.0f16 instead of\n\t0.0f.\n\t* config/ia64/ia64.cc (ia64_init_builtins): Use\n\tfloat128t_type_node for __float128 instead of float128_type_node\n\tand create it if NULL.\n\t* config/rs6000/rs6000-c.cc (is_float128_p): Also return true\n\tfor float128t_type_node if non-NULL.\n\t* config/rs6000/rs6000.cc (rs6000_mangle_type): Don't mangle\n\tfloat128_type_node as \"u9__ieee128\".\n\t* config/rs6000/rs6000-builtin.cc (rs6000_init_builtins): Use\n\tfloat128t_type_node for __float128 instead of float128_type_node\n\tand create it if NULL.\ngcc/c-family/\n\t* c-common.cc (c_common_reswords): Change _Float{16,32,64,128} and\n\t_Float{32,64,128}x flags from D_CONLY to 0.\n\t(shorten_binary_op): Punt if common_type returns error_mark_node.\n\t(shorten_compare): Likewise.\n\t(c_common_nodes_and_builtins): For C++ record _Float{16,32,64,128}\n\tand _Float{32,64,128}x builtin types if available.  For C++\n\tclear float128t_type_node.\n\t* c-cppbuiltin.cc (c_cpp_builtins): Predefine\n\t__STDCPP_FLOAT{16,32,64,128}_T__ for C++23 if supported.\n\t* c-lex.cc (interpret_float): For q/Q suffixes prefer\n\tfloat128t_type_node over float128_type_node.  Allow\n\t{f,F}{16,32,64,128} suffixes for C++ if supported with pedwarn\n\tfor C++20 and older.  Allow {f,F}{32,64,128}x suffixes for C++\n\twith pedwarn.  Don't call excess_precision_type for C++.\ngcc/cp/\n\t* cp-tree.h (cp_compare_floating_point_conversion_ranks): Implement\n\tP1467R9 - Extended floating-point types and standard names except\n\tfor std::bfloat16_t for now.  Declare.\n\t(extended_float_type_p): New inline function.\n\t* mangle.cc (write_builtin_type): Mangle float{16,32,64,128}_type_node\n\tas DF{16,32,64,128}_.  Mangle float{32,64,128}x_type_node as\n\tDF{32,64,128}x.  Remove FIXED_POINT_TYPE mangling that conflicts\n\twith that.\n\t* typeck2.cc (check_narrowing): If one of ftype or type is extended\n\tfloating-point type, compare floating-point conversion ranks.\n\t* parser.cc (cp_keyword_starts_decl_specifier_p): Handle\n\tCASE_RID_FLOATN_NX.\n\t(cp_parser_simple_type_specifier): Likewise and diagnose missing\n\t_Float<N> or _Float<N>x support if not supported by target.\n\t* typeck.cc (cp_compare_floating_point_conversion_ranks): New function.\n\t(cp_common_type): If both types are REAL_TYPE and one or both are\n\textended floating-point types, select common type based on comparison\n\tof floating-point conversion ranks and subranks.\n\t(cp_build_binary_op): Diagnose operation with floating point arguments\n\twith unordered conversion ranks.\n\t* call.cc (standard_conversion): For floating-point conversion, if\n\teither from or to are extended floating-point types, set conv->bad_p\n\tfor implicit conversion from larger to smaller conversion rank or\n\twith unordered conversion ranks.\n\t(convert_like_internal): Emit a pedwarn on such conversions.\n\t(build_conditional_expr): Diagnose operation with floating point\n\targuments with unordered conversion ranks.\n\t(convert_arg_to_ellipsis): Don't promote extended floating-point types\n\tnarrower than double to double.\n\t(compare_ics): Implement P1467R9 [over.ics.rank]/4 changes.\ngcc/testsuite/\n\t* g++.dg/cpp23/ext-floating1.C: New test.\n\t* g++.dg/cpp23/ext-floating2.C: New test.\n\t* g++.dg/cpp23/ext-floating3.C: New test.\n\t* g++.dg/cpp23/ext-floating4.C: New test.\n\t* g++.dg/cpp23/ext-floating5.C: New test.\n\t* g++.dg/cpp23/ext-floating6.C: New test.\n\t* g++.dg/cpp23/ext-floating7.C: New test.\n\t* g++.dg/cpp23/ext-floating8.C: New test.\n\t* g++.dg/cpp23/ext-floating9.C: New test.\n\t* g++.dg/cpp23/ext-floating10.C: New test.\n\t* g++.dg/cpp23/ext-floating.h: New file.\n\t* g++.target/i386/float16-1.C: Adjust expected diagnostics.\nlibcpp/\n\t* expr.cc (interpret_float_suffix): Allow {f,F}{16,32,64,128} and\n\t{f,F}{32,64,128}x suffixes for C++.\ninclude/\n\t* demangle.h (enum demangle_component_type): Add\n\tDEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE.\n\t(struct demangle_component): Add u.s_extended_builtin member.\nlibiberty/\n\t* cp-demangle.c (d_dump): Handle\n\tDEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE.  Don't handle\n\tDEMANGLE_COMPONENT_FIXED_TYPE.\n\t(d_make_extended_builtin_type): New function.\n\t(cplus_demangle_builtin_types): Add _Float entry.\n\t(cplus_demangle_type): For DF demangle it as _Float<N> or\n\t_Float<N>x rather than fixed point which conflicts with it.\n\t(d_count_templates_scopes): Handle\n\tDEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE.  Just break; for\n\tDEMANGLE_COMPONENT_FIXED_TYPE.\n\t(d_find_pack): Handle DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE.\n\tDon't handle DEMANGLE_COMPONENT_FIXED_TYPE.\n\t(d_print_comp_inner): Likewise.\n\t* cp-demangle.h (D_BUILTIN_TYPE_COUNT): Bump.\n\t* testsuite/demangle-expected: Replace _Z3xxxDFyuVb test\n\twith _Z3xxxDF16_DF32_DF64_DF128_CDF16_Vb.  Add\n\t_Z3xxxDF32xDF64xDF128xCDF32xVb test.\nfixincludes/\n\t* inclhack.def (glibc_cxx_floatn_1, glibc_cxx_floatn_2,\n\tglibc_cxx_floatn_3): New fixes.\n\t* tests/base/bits/floatn.h: New file.\n\t* fixincl.x: Regenerated.", "tree": {"sha": "dcb54efa0d9259cd794dd7d0b1935c53d564e1f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcb54efa0d9259cd794dd7d0b1935c53d564e1f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b04208895fed34171eac6bafb60c90048eb1cb0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b04208895fed34171eac6bafb60c90048eb1cb0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b04208895fed34171eac6bafb60c90048eb1cb0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b04208895fed34171eac6bafb60c90048eb1cb0c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8be65640e12371571a88100864abd78733a7f7eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8be65640e12371571a88100864abd78733a7f7eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8be65640e12371571a88100864abd78733a7f7eb"}], "stats": {"total": 2122, "additions": 1974, "deletions": 148}, "files": [{"sha": "56c37b7fd08305222faf7e6b0923dc40e4c1ba35", "filename": "fixincludes/fixincl.x", "status": "modified", "additions": 149, "deletions": 5, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/fixincludes%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/fixincludes%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ffixincl.x?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -2,11 +2,11 @@\n  *\n  * DO NOT EDIT THIS FILE   (fixincl.x)\n  *\n- * It has been AutoGen-ed  February 27, 2022 at 07:47:03 PM by AutoGen 5.18.16\n+ * It has been AutoGen-ed  September 27, 2022 at 12:49:21 AM by AutoGen 5.18.16\n  * From the definitions    inclhack.def\n  * and the template file   fixincl\n  */\n-/* DO NOT SVN-MERGE THIS FILE, EITHER Sun Feb 27 19:47:03 UTC 2022\n+/* DO NOT SVN-MERGE THIS FILE, EITHER Tue Sep 27 00:49:21 CEST 2022\n  *\n  * You must regenerate it.  Use the ./genfixes script.\n  *\n@@ -15,7 +15,7 @@\n  * certain ANSI-incompatible system header files which are fixed to work\n  * correctly with ANSI C and placed in a directory that GNU C will search.\n  *\n- * This file contains 267 fixup descriptions.\n+ * This file contains 270 fixup descriptions.\n  *\n  * See README for more information.\n  *\n@@ -4105,6 +4105,132 @@ static const char* apzGlibc_C99_Inline_4Patch[] = {\n     \"%0 __attribute__ ((__gnu_inline__))\",\n     (char*)NULL };\n \n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Cxx_Floatn_1 fix\n+ */\n+tSCC zGlibc_Cxx_Floatn_1Name[] =\n+     \"glibc_cxx_floatn_1\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_Cxx_Floatn_1List[] =\n+  \"bits/floatn.h\\0bits/floatn-common.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_Cxx_Floatn_1Machs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_Cxx_Floatn_1Select0[] =\n+       \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n+(([ \\t]*/\\\\*[^\\n\\\n+]*\\\\*/\\n\\\n+)?([ \\t]*#[ \\t]*if[^\\n\\\n+]*\\n\\\n+)?[ \\t]*#[ \\t]*define __f(16|32|64|128)x?\\\\()\";\n+\n+#define    GLIBC_CXX_FLOATN_1_TEST_CT  1\n+static tTestDesc aGlibc_Cxx_Floatn_1Tests[] = {\n+  { TT_EGREP,    zGlibc_Cxx_Floatn_1Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Cxx_Floatn_1\n+ */\n+static const char* apzGlibc_Cxx_Floatn_1Patch[] = {\n+    \"format\",\n+    \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n\\\n+%2\",\n+    (char*)NULL };\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Cxx_Floatn_2 fix\n+ */\n+tSCC zGlibc_Cxx_Floatn_2Name[] =\n+     \"glibc_cxx_floatn_2\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_Cxx_Floatn_2List[] =\n+  \"bits/floatn.h\\0bits/floatn-common.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_Cxx_Floatn_2Machs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_Cxx_Floatn_2Select0[] =\n+       \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n+(([ \\t]*/\\\\*[^\\n\\\n+]*\\\\*/\\n\\\n+)?[ \\t]*typedef[ \\t]+[^\\n\\\n+]*[ \\t]+_Float(16|32|64|128)x?([ \\t]+__attribute__ \\\\(\\\\(__mode__ \\\\(__HF__\\\\)\\\\)\\\\))?;)\";\n+\n+#define    GLIBC_CXX_FLOATN_2_TEST_CT  1\n+static tTestDesc aGlibc_Cxx_Floatn_2Tests[] = {\n+  { TT_EGREP,    zGlibc_Cxx_Floatn_2Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Cxx_Floatn_2\n+ */\n+static const char* apzGlibc_Cxx_Floatn_2Patch[] = {\n+    \"format\",\n+    \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n\\\n+%2\",\n+    (char*)NULL };\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Cxx_Floatn_3 fix\n+ */\n+tSCC zGlibc_Cxx_Floatn_3Name[] =\n+     \"glibc_cxx_floatn_3\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_Cxx_Floatn_3List[] =\n+  \"bits/floatn.h\\0bits/floatn-common.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_Cxx_Floatn_3Machs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_Cxx_Floatn_3Select0[] =\n+       \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n+(([ \\t]*/\\\\*[^\\n\\\n+]*\\n\\\n+?[^\\n\\\n+]*\\\\*/\\n\\\n+)?([ \\t]*#[ \\t]*if[^\\n\\\n+]*\\n\\\n+)?([ \\t]*typedef[ \\t]+[^\\n\\\n+]*;\\n\\\n+)?[ \\t]*#[ \\t]*define __CFLOAT(16|32|64|128)X?[ \\t]+)\";\n+\n+#define    GLIBC_CXX_FLOATN_3_TEST_CT  1\n+static tTestDesc aGlibc_Cxx_Floatn_3Tests[] = {\n+  { TT_EGREP,    zGlibc_Cxx_Floatn_3Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Cxx_Floatn_3\n+ */\n+static const char* apzGlibc_Cxx_Floatn_3Patch[] = {\n+    \"format\",\n+    \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n\\\n+%2\",\n+    (char*)NULL };\n+\n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n  *  Description of Glibc_Mutex_Init fix\n@@ -10872,9 +10998,9 @@ static const char* apzX11_SprintfPatch[] = {\n  *\n  *  List of all fixes\n  */\n-#define REGEX_COUNT          305\n+#define REGEX_COUNT          308\n #define MACH_LIST_SIZE_LIMIT 187\n-#define FIX_COUNT            267\n+#define FIX_COUNT            270\n \n /*\n  *  Enumerate the fixes\n@@ -10977,6 +11103,9 @@ typedef enum {\n     GLIBC_C99_INLINE_2_FIXIDX,\n     GLIBC_C99_INLINE_3_FIXIDX,\n     GLIBC_C99_INLINE_4_FIXIDX,\n+    GLIBC_CXX_FLOATN_1_FIXIDX,\n+    GLIBC_CXX_FLOATN_2_FIXIDX,\n+    GLIBC_CXX_FLOATN_3_FIXIDX,\n     GLIBC_MUTEX_INIT_FIXIDX,\n     GLIBC_STDINT_FIXIDX,\n     GLIBC_STRNCPY_FIXIDX,\n@@ -11635,6 +11764,21 @@ tFixDesc fixDescList[ FIX_COUNT ] = {\n      GLIBC_C99_INLINE_4_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n      aGlibc_C99_Inline_4Tests,   apzGlibc_C99_Inline_4Patch, 0 },\n \n+  {  zGlibc_Cxx_Floatn_1Name,    zGlibc_Cxx_Floatn_1List,\n+     apzGlibc_Cxx_Floatn_1Machs,\n+     GLIBC_CXX_FLOATN_1_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_Cxx_Floatn_1Tests,   apzGlibc_Cxx_Floatn_1Patch, 0 },\n+\n+  {  zGlibc_Cxx_Floatn_2Name,    zGlibc_Cxx_Floatn_2List,\n+     apzGlibc_Cxx_Floatn_2Machs,\n+     GLIBC_CXX_FLOATN_2_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_Cxx_Floatn_2Tests,   apzGlibc_Cxx_Floatn_2Patch, 0 },\n+\n+  {  zGlibc_Cxx_Floatn_3Name,    zGlibc_Cxx_Floatn_3List,\n+     apzGlibc_Cxx_Floatn_3Machs,\n+     GLIBC_CXX_FLOATN_3_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_Cxx_Floatn_3Tests,   apzGlibc_Cxx_Floatn_3Patch, 0 },\n+\n   {  zGlibc_Mutex_InitName,    zGlibc_Mutex_InitList,\n      apzGlibc_Mutex_InitMachs,\n      GLIBC_MUTEX_INIT_TEST_CT, FD_MACH_ONLY,"}, {"sha": "a3f171ab4b61208b80b00ffb8c96d58bec6e3aef", "filename": "fixincludes/inclhack.def", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/fixincludes%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/fixincludes%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Finclhack.def?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -2015,6 +2015,102 @@ fix = {\n \tEOT;\n };\n \n+/*  glibc-2.27 to 2.36 assume GCC 7 or later supports some or all\n+ *  of _Float{16,32,64,128} and _Float{32,64,128}x keywords for C,\n+ *  but doesn't for C++.\n+ */\n+fix = {\n+    hackname  = glibc_cxx_floatn_1;\n+    files     = bits/floatn.h, bits/floatn-common.h;\n+    select    = \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n+\t\t\"(([ \\t]*/\\\\*[^\\n]*\\\\*/\\n)?\"\n+\t\t\"([ \\t]*#[ \\t]*if[^\\n]*\\n)?\"\n+\t\t\"[ \\t]*#[ \\t]*define __f(16|32|64|128)x?\\\\()\";\n+    c_fix     = format;\n+    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%2\";\n+    test_text = <<-EOT\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t/* The literal suffix f128 exists only since GCC 7.0.  */\n+\t#   define __f128(x) x##l\n+\t#  else\n+\t#   define __f128(x) x##f128\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t/* The literal suffix (f128) exist for powerpc only since GCC 7.0.  */\n+\t#   if __LDBL_MANT_DIG__ == 113\n+\t#    define __f128(x) x##l\n+\t#   else\n+\t#    define __f128(x) x##q\n+\t#   endif\n+\t#  else\n+\t#   define __f128(x) x##f128\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t#   ifdef __NO_LONG_DOUBLE_MATH\n+\t#    define __f64(x) x##l\n+\t#   else\n+\t#    define __f64(x) x\n+\t#   endif\n+\t#  else\n+\t#   define __f64(x) x##f64\n+\t#  endif\n+\tEOT;\n+};\n+\n+fix = {\n+    hackname  = glibc_cxx_floatn_2;\n+    files     = bits/floatn.h, bits/floatn-common.h;\n+    select    = \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n+\t\t\"(([ \\t]*/\\\\*[^\\n]*\\\\*/\\n)?\"\n+\t\t\"[ \\t]*typedef[ \\t]+[^\\n]*[ \\t]+_Float(16|32|64|128)x?([ \\t]+__attribute__ \\\\(\\\\(__mode__ \\\\(__HF__\\\\)\\\\)\\\\))?;)\";\n+    c_fix     = format;\n+    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%2\";\n+    test_text = <<-EOT\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\ttypedef float _Float16 __attribute__ ((__mode__ (__HF__)));\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\ttypedef __float128 _Float128;\n+\t#  endif\n+\tEOT;\n+};\n+\n+fix = {\n+    hackname  = glibc_cxx_floatn_3;\n+    files     = bits/floatn.h, bits/floatn-common.h;\n+    select    = \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n+\t\t\"(([ \\t]*/\\\\*[^\\n]*\\n?[^\\n]*\\\\*/\\n)?\"\n+\t\t\"([ \\t]*#[ \\t]*if[^\\n]*\\n)?\"\n+\t\t\"([ \\t]*typedef[ \\t]+[^\\n]*;\\n)?\"\n+\t\t\"[ \\t]*#[ \\t]*define __CFLOAT(16|32|64|128)X?[ \\t]+)\";\n+    c_fix     = format;\n+    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%2\";\n+    test_text = <<-EOT\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t#   define __CFLOAT128 _Complex long double\n+\t#  else\n+\t#   define __CFLOAT128 _Complex _Float128\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t/* Add a typedef for older GCC compilers which don't natively support\n+\t   _Complex _Float128.  */\n+\ttypedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));\n+\t#   define __CFLOAT128 __cfloat128\n+\t#  else\n+\t#   define __CFLOAT128 _Complex _Float128\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t#   ifdef __NO_LONG_DOUBLE_MATH\n+\t#    define __CFLOAT64 _Complex long double\n+\t#   else\n+\t#    define __CFLOAT64 _Complex double\n+\t#   endif\n+\t#  else\n+\t#   define __CFLOAT64 _Complex _Float64\n+\t#  endif\n+\tEOT;\n+};\n+\n /*  glibc-2.3.5 defines pthread mutex initializers incorrectly,\n  *  so we replace them with versions that correspond to the\n  *  definition."}, {"sha": "f09528b6e274ac812b0d78d39e423c64b91835f9", "filename": "fixincludes/tests/base/bits/floatn.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,74 @@\n+/*  DO NOT EDIT THIS FILE.\n+\n+    It has been auto-edited by fixincludes from:\n+\n+\t\"fixinc/tests/inc/bits/floatn.h\"\n+\n+    This had to be done to correct non-standard usages in the\n+    original, manufacturer supplied header file.  */\n+\n+\n+\n+#if defined( GLIBC_CXX_FLOATN_1_CHECK )\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+/* The literal suffix f128 exists only since GCC 7.0.  */\n+#   define __f128(x) x##l\n+#  else\n+#   define __f128(x) x##f128\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+/* The literal suffix (f128) exist for powerpc only since GCC 7.0.  */\n+#   if __LDBL_MANT_DIG__ == 113\n+#    define __f128(x) x##l\n+#   else\n+#    define __f128(x) x##q\n+#   endif\n+#  else\n+#   define __f128(x) x##f128\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+#   ifdef __NO_LONG_DOUBLE_MATH\n+#    define __f64(x) x##l\n+#   else\n+#    define __f64(x) x\n+#   endif\n+#  else\n+#   define __f64(x) x##f64\n+#  endif\n+#endif  /* GLIBC_CXX_FLOATN_1_CHECK */\n+\n+\n+#if defined( GLIBC_CXX_FLOATN_2_CHECK )\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+typedef float _Float16 __attribute__ ((__mode__ (__HF__)));\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+typedef __float128 _Float128;\n+#  endif\n+#endif  /* GLIBC_CXX_FLOATN_2_CHECK */\n+\n+\n+#if defined( GLIBC_CXX_FLOATN_3_CHECK )\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+#   define __CFLOAT128 _Complex long double\n+#  else\n+#   define __CFLOAT128 _Complex _Float128\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+/* Add a typedef for older GCC compilers which don't natively support\n+   _Complex _Float128.  */\n+typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));\n+#   define __CFLOAT128 __cfloat128\n+#  else\n+#   define __CFLOAT128 _Complex _Float128\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+#   ifdef __NO_LONG_DOUBLE_MATH\n+#    define __CFLOAT64 _Complex long double\n+#   else\n+#    define __CFLOAT64 _Complex double\n+#   endif\n+#  else\n+#   define __CFLOAT64 _Complex _Float64\n+#  endif\n+#endif  /* GLIBC_CXX_FLOATN_3_CHECK */"}, {"sha": "109b3879220501b06e86d292a970d120dbbeee28", "filename": "gcc/builtins.def", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -114,9 +114,8 @@ along with GCC; see the file COPYING3.  If not see\n    with an argument such as FLOAT32 to produce the enum value for the type.  If\n    we are compiling for the C language with GNU extensions, we enable the name\n    without the __builtin_ prefix as well as the name with the __builtin_\n-   prefix.  C++ does not enable these names by default because they don't have\n-   the _Float<N> and _Float<N>X keywords, and a class based library should use\n-   the __builtin_ names.  */\n+   prefix.  C++ does not enable these names by default because a class based\n+   library should use the __builtin_ names.  */\n #undef DEF_FLOATN_BUILTIN\n #define DEF_FLOATN_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\"}, {"sha": "cda6910e8c586bb3714e701e5726b84f045883c5", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -352,13 +352,13 @@ const struct c_common_resword c_common_reswords[] =\n   { \"_Bool\",\t\tRID_BOOL,      D_CONLY },\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n   { \"_Imaginary\",\tRID_IMAGINARY, D_CONLY },\n-  { \"_Float16\",         RID_FLOAT16,   D_CONLY },\n-  { \"_Float32\",         RID_FLOAT32,   D_CONLY },\n-  { \"_Float64\",         RID_FLOAT64,   D_CONLY },\n-  { \"_Float128\",        RID_FLOAT128,  D_CONLY },\n-  { \"_Float32x\",        RID_FLOAT32X,  D_CONLY },\n-  { \"_Float64x\",        RID_FLOAT64X,  D_CONLY },\n-  { \"_Float128x\",       RID_FLOAT128X, D_CONLY },\n+  { \"_Float16\",         RID_FLOAT16,    0 },\n+  { \"_Float32\",         RID_FLOAT32,    0 },\n+  { \"_Float64\",         RID_FLOAT64,    0 },\n+  { \"_Float128\",        RID_FLOAT128,   0 },\n+  { \"_Float32x\",        RID_FLOAT32X,   0 },\n+  { \"_Float64x\",        RID_FLOAT64X,   0 },\n+  { \"_Float128x\",       RID_FLOAT128X,  0 },\n   { \"_Decimal32\",       RID_DFLOAT32,  D_CONLY },\n   { \"_Decimal64\",       RID_DFLOAT64,  D_CONLY },\n   { \"_Decimal128\",      RID_DFLOAT128, D_CONLY },\n@@ -1431,8 +1431,11 @@ shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n \t  == TYPE_PRECISION (TREE_TYPE (arg0)))\n       && unsigned0 == unsigned1\n       && (unsigned0 || !uns))\n-    return c_common_signed_or_unsigned_type\n-      (unsigned0, common_type (TREE_TYPE (arg0), TREE_TYPE (arg1)));\n+    {\n+      tree ctype = common_type (TREE_TYPE (arg0), TREE_TYPE (arg1));\n+      if (ctype != error_mark_node)\n+\treturn c_common_signed_or_unsigned_type (unsigned0, ctype);\n+    }\n \n   else if (TREE_CODE (arg0) == INTEGER_CST\n \t   && (unsigned1 || !uns)\n@@ -3204,9 +3207,10 @@ shorten_compare (location_t loc, tree *op0_ptr, tree *op1_ptr,\n \n   else if (unsignedp0 == unsignedp1 && real1 == real2\n \t   && TYPE_PRECISION (TREE_TYPE (primop0)) < TYPE_PRECISION (*restype_ptr)\n-\t   && TYPE_PRECISION (TREE_TYPE (primop1)) < TYPE_PRECISION (*restype_ptr))\n+\t   && TYPE_PRECISION (TREE_TYPE (primop1)) < TYPE_PRECISION (*restype_ptr)\n+\t   && (type = common_type (TREE_TYPE (primop0), TREE_TYPE (primop1)))\n+\t      != error_mark_node)\n     {\n-      type = common_type (TREE_TYPE (primop0), TREE_TYPE (primop1));\n       type = c_common_signed_or_unsigned_type (unsignedp0\n \t\t\t\t\t       || TYPE_UNSIGNED (*restype_ptr),\n \t\t\t\t\t       type);\n@@ -4380,11 +4384,18 @@ c_common_nodes_and_builtins (void)\n   record_builtin_type (RID_DOUBLE, NULL, double_type_node);\n   record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n \n-  if (!c_dialect_cxx ())\n-    for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+  for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+    {\n       if (FLOATN_NX_TYPE_NODE (i) != NULL_TREE)\n \trecord_builtin_type ((enum rid) (RID_FLOATN_NX_FIRST + i), NULL,\n \t\t\t     FLOATN_NX_TYPE_NODE (i));\n+    }\n+\n+  /* For C, let float128t_type_node (__float128 in some backends) be the\n+     same type as float128_type_node (_Float128), for C++ let those\n+     be distinct types that mangle and behave differently.  */\n+  if (c_dialect_cxx ())\n+    float128t_type_node = NULL_TREE;\n \n   /* Only supported decimal floating point extension if the target\n      actually supports underlying modes. */"}, {"sha": "e3f4d3d4565099d07c862867c333c3c4f6343ed0", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -1246,6 +1246,14 @@ c_cpp_builtins (cpp_reader *pfile)\n     {\n       if (FLOATN_NX_TYPE_NODE (i) == NULL_TREE)\n \tcontinue;\n+      if (c_dialect_cxx ()\n+\t  && cxx_dialect > cxx20\n+\t  && !floatn_nx_types[i].extended)\n+\t{\n+\t  char name[sizeof (\"__STDCPP_FLOAT128_T__=1\")];\n+\t  sprintf (name, \"__STDCPP_FLOAT%d_T__=1\", floatn_nx_types[i].n);\n+\t  cpp_define (pfile, name);\n+\t}\n       char prefix[20], csuffix[20];\n       sprintf (prefix, \"FLT%d%s\", floatn_nx_types[i].n,\n \t       floatn_nx_types[i].extended ? \"X\" : \"\");"}, {"sha": "4d2252fd946bd242892e44c34d5c4c7d54428409", "filename": "gcc/c-family/c-lex.cc", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fc-family%2Fc-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fc-family%2Fc-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -960,6 +960,10 @@ interpret_float (const cpp_token *token, unsigned int flags,\n \t  pedwarn (input_location, OPT_Wpedantic, \"non-standard suffix on floating constant\");\n \n \ttype = c_common_type_for_mode (mode, 0);\n+\t/* For Q suffix, prefer float128t_type_node (__float128) type\n+\t   over float128_type_node (_Float128) type if they are distinct.  */\n+\tif (type == float128_type_node && float128t_type_node)\n+\t  type = float128t_type_node;\n \tgcc_assert (type);\n       }\n     else if ((flags & (CPP_N_FLOATN | CPP_N_FLOATNX)) != 0)\n@@ -979,8 +983,17 @@ interpret_float (const cpp_token *token, unsigned int flags,\n \t    error (\"unsupported non-standard suffix on floating constant\");\n \t    return error_mark_node;\n \t  }\n+\telse if (c_dialect_cxx () && !extended)\n+\t  {\n+\t    if (cxx_dialect < cxx23)\n+\t      pedwarn (input_location, OPT_Wpedantic,\n+\t\t       \"%<f%d%> or %<F%d%> suffix on floating constant only \"\n+\t\t       \"available with %<-std=c++2b%> or %<-std=gnu++2b%>\",\n+\t\t       n, n);\n+\t  }\n \telse\n-\t  pedwarn (input_location, OPT_Wpedantic, \"non-standard suffix on floating constant\");\n+\t  pedwarn (input_location, OPT_Wpedantic,\n+\t\t   \"non-standard suffix on floating constant\");\n       }\n     else if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n       type = long_double_type_node;\n@@ -990,7 +1003,10 @@ interpret_float (const cpp_token *token, unsigned int flags,\n     else\n       type = double_type_node;\n \n-  const_type = excess_precision_type (type);\n+  if (c_dialect_cxx ())\n+    const_type = NULL_TREE;\n+  else\n+    const_type = excess_precision_type (type);\n   if (!const_type)\n     const_type = type;\n "}, {"sha": "75f7475ad1824727f33fbac56da45de8d2a1635b", "filename": "gcc/config/i386/avx512fp16intrin.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Fi386%2Favx512fp16intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Fi386%2Favx512fp16intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favx512fp16intrin.h?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -183,21 +183,21 @@ extern __inline __m128h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm_setzero_ph (void)\n {\n-  return _mm_set1_ph (0.0f);\n+  return _mm_set1_ph (0.0f16);\n }\n \n extern __inline __m256h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm256_setzero_ph (void)\n {\n-  return _mm256_set1_ph (0.0f);\n+  return _mm256_set1_ph (0.0f16);\n }\n \n extern __inline __m512h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm512_setzero_ph (void)\n {\n-  return _mm512_set1_ph (0.0f);\n+  return _mm512_set1_ph (0.0f16);\n }\n \n extern __inline __m128h\n@@ -358,15 +358,16 @@ extern __inline __m128h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm_set_sh (_Float16 __F)\n {\n-  return _mm_set_ph (0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, __F);\n+  return _mm_set_ph (0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16,\n+\t\t     __F);\n }\n \n /* Create a vector with element 0 as *P and the rest zero.  */\n extern __inline __m128h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm_load_sh (void const *__P)\n {\n-  return _mm_set_ph (0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,\n+  return _mm_set_ph (0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16,\n \t\t     *(_Float16 const *) __P);\n }\n "}, {"sha": "b91aba182213c03f85952aeed15024a0a5527ce3", "filename": "gcc/config/i386/i386-builtins.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -1409,9 +1409,18 @@ ix86_init_builtin_types (void)\n   lang_hooks.types.register_builtin_type (float80_type_node, \"__float80\");\n \n   /* The __float128 type.  The node has already been created as\n-     _Float128, so we only need to register the __float128 name for\n-     it.  */\n-  lang_hooks.types.register_builtin_type (float128_type_node, \"__float128\");\n+     _Float128, so for C we only need to register the __float128 name for\n+     it.  For C++, we create a distinct type which will mangle differently\n+     (g) vs. _Float128 (DF128_) and behave backwards compatibly.  */\n+  if (float128t_type_node == NULL_TREE)\n+    {\n+      float128t_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (float128t_type_node)\n+\t= TYPE_PRECISION (float128_type_node);\n+      SET_TYPE_MODE (float128t_type_node, TYPE_MODE (float128_type_node));\n+      layout_type (float128t_type_node);\n+    }\n+  lang_hooks.types.register_builtin_type (float128t_type_node, \"__float128\");\n \n   ix86_register_float16_builtin_type ();\n "}, {"sha": "4386caf843eaf8b58b54836efad49d518d3404b8", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -22735,7 +22735,10 @@ ix86_mangle_type (const_tree type)\n       return \"DF16_\";\n     case E_TFmode:\n       /* __float128 is \"g\".  */\n-      return \"g\";\n+      if (type == float128t_type_node)\n+\treturn \"g\";\n+      /* _Float128 should mangle as \"DF128_\" done in generic code.  */\n+      return NULL;\n     case E_XFmode:\n       /* \"long double\" or __float80 is \"e\".  */\n       return \"e\";"}, {"sha": "d510573a0a43267150cf79123aa3b5a295f960f8", "filename": "gcc/config/ia64/ia64.cc", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Fia64%2Fia64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Fia64%2Fia64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -10466,11 +10466,19 @@ ia64_init_builtins (void)\n \t= build_pointer_type (build_qualified_type\n \t\t\t      (char_type_node, TYPE_QUAL_CONST));\n \n-      (*lang_hooks.types.register_builtin_type) (float128_type_node,\n+      if (float128t_type_node == NULL_TREE)\n+\t{\n+\t  float128t_type_node = make_node (REAL_TYPE);\n+\t  TYPE_PRECISION (float128t_type_node)\n+\t    = TYPE_PRECISION (float128_type_node);\n+\t  layout_type (float128t_type_node);\n+\t  SET_TYPE_MODE (float128t_type_node, TYPE_MODE (float128_type_node));\n+\t}\n+      (*lang_hooks.types.register_builtin_type) (float128t_type_node,\n \t\t\t\t\t\t \"__float128\");\n \n       /* TFmode support builtins.  */\n-      ftype = build_function_type_list (float128_type_node, NULL_TREE);\n+      ftype = build_function_type_list (float128t_type_node, NULL_TREE);\n       decl = add_builtin_function (\"__builtin_infq\", ftype,\n \t\t\t\t   IA64_BUILTIN_INFQ, BUILT_IN_MD,\n \t\t\t\t   NULL, NULL_TREE);\n@@ -10481,7 +10489,7 @@ ia64_init_builtins (void)\n \t\t\t\t   NULL, NULL_TREE);\n       ia64_builtins[IA64_BUILTIN_HUGE_VALQ] = decl;\n \n-      ftype = build_function_type_list (float128_type_node,\n+      ftype = build_function_type_list (float128t_type_node,\n \t\t\t\t\tconst_string_type,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_nanq\", ftype,\n@@ -10496,18 +10504,18 @@ ia64_init_builtins (void)\n       TREE_READONLY (decl) = 1;\n       ia64_builtins[IA64_BUILTIN_NANSQ] = decl;\n \n-      ftype = build_function_type_list (float128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n+      ftype = build_function_type_list (float128t_type_node,\n+\t\t\t\t\tfloat128t_type_node,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_fabsq\", ftype,\n \t\t\t\t   IA64_BUILTIN_FABSQ, BUILT_IN_MD,\n \t\t\t\t   \"__fabstf2\", NULL_TREE);\n       TREE_READONLY (decl) = 1;\n       ia64_builtins[IA64_BUILTIN_FABSQ] = decl;\n \n-      ftype = build_function_type_list (float128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n+      ftype = build_function_type_list (float128t_type_node,\n+\t\t\t\t\tfloat128t_type_node,\n+\t\t\t\t\tfloat128t_type_node,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_copysignq\", ftype,\n \t\t\t\t   IA64_BUILTIN_COPYSIGNQ, BUILT_IN_MD,"}, {"sha": "90ab39dc2588933c499e3478e4e2f264798b09d0", "filename": "gcc/config/rs6000/rs6000-builtin.cc", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -733,7 +733,22 @@ rs6000_init_builtins (void)\n       if (TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128)\n \tieee128_float_type_node = long_double_type_node;\n       else\n-\tieee128_float_type_node = float128_type_node;\n+\t{\n+\t  /* For C we only need to register the __ieee128 name for\n+\t     it.  For C++, we create a distinct type which will mangle\n+\t     differently (u9__ieee128) vs. _Float128 (DF128_) and behave\n+\t     backwards compatibly.  */\n+\t  if (float128t_type_node == NULL_TREE)\n+\t    {\n+\t      float128t_type_node = make_node (REAL_TYPE);\n+\t      TYPE_PRECISION (float128t_type_node)\n+\t\t= TYPE_PRECISION (float128_type_node);\n+\t      layout_type (float128t_type_node);\n+\t      SET_TYPE_MODE (float128t_type_node,\n+\t\t\t     TYPE_MODE (float128_type_node));\n+\t    }\n+\t  ieee128_float_type_node = float128t_type_node;\n+\t}\n       t = build_qualified_type (ieee128_float_type_node, TYPE_QUAL_CONST);\n       lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n \t\t\t\t\t      \"__ieee128\");"}, {"sha": "56609462629368bb230d67fe9638db8980fef652", "filename": "gcc/config/rs6000/rs6000-c.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -808,6 +808,7 @@ static inline bool\n is_float128_p (tree t)\n {\n   return (t == float128_type_node\n+\t  || (t && t == float128t_type_node)\n \t  || (TARGET_IEEEQUAD\n \t      && TARGET_LONG_DOUBLE_128\n \t      && t == long_double_type_node));"}, {"sha": "bbe21eacc6b95db99e20e54857bb68cbe1afa65a", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -20272,7 +20272,11 @@ rs6000_mangle_type (const_tree type)\n \n   if (SCALAR_FLOAT_TYPE_P (type) && FLOAT128_IBM_P (TYPE_MODE (type)))\n     return \"g\";\n-  if (SCALAR_FLOAT_TYPE_P (type) && FLOAT128_IEEE_P (TYPE_MODE (type)))\n+  if (SCALAR_FLOAT_TYPE_P (type)\n+      && FLOAT128_IEEE_P (TYPE_MODE (type))\n+      /* _Float128 should mangle as DF128_ (done in generic code)\n+\t rather than u9__ieee128 (used for __ieee128 and __float128).  */\n+      && type != float128_type_node)\n     return \"u9__ieee128\";\n \n   if (type == vector_pair_type_node)"}, {"sha": "3b7e5271de4b9336a32c1390eccba2ac7684e0a8", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -1541,6 +1541,22 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t   || (underlying_type && same_type_p (to, underlying_type)))\n \t  && next_conversion (conv)->rank <= cr_promotion)\n \tconv->rank = cr_promotion;\n+\n+      /* A prvalue of floating-point type can be converted to a prvalue of\n+\t another floating-point type with a greater or equal conversion\n+\t rank ([conv.rank]).  A prvalue of standard floating-point type can\n+\t be converted to a prvalue of another standard floating-point type.\n+\t For backwards compatibility with handling __float128 and other\n+\t non-standard floating point types, allow all implicit floating\n+\t point conversions if neither type is extended floating-point\n+\t type and if at least one of them is, fail if they have unordered\n+\t conversion rank or from has higher conversion rank.  */\n+      if (fcode == REAL_TYPE\n+\t  && tcode == REAL_TYPE\n+\t  && (extended_float_type_p (from)\n+\t      || extended_float_type_p (to))\n+\t  && cp_compare_floating_point_conversion_ranks (from, to) >= 2)\n+\tconv->bad_p = true;\n     }\n   else if (fcode == VECTOR_TYPE && tcode == VECTOR_TYPE\n \t   && vector_types_convertible_p (from, to, false))\n@@ -5842,6 +5858,21 @@ build_conditional_expr (const op_location_t &loc,\n       /* In this case, there is always a common type.  */\n       result_type = type_after_usual_arithmetic_conversions (arg2_type,\n \t\t\t\t\t\t\t     arg3_type);\n+      if (result_type == error_mark_node\n+\t  && TREE_CODE (arg2_type) == REAL_TYPE\n+\t  && TREE_CODE (arg3_type) == REAL_TYPE\n+\t  && (extended_float_type_p (arg2_type)\n+\t      || extended_float_type_p (arg3_type))\n+\t  && cp_compare_floating_point_conversion_ranks (arg2_type,\n+\t\t\t\t\t\t\t arg3_type) == 3)\n+\t{\n+\t  if (complain & tf_error)\n+\t    error_at (loc, \"operands to %<?:%> of types %qT and %qT \"\n+\t\t\t   \"have unordered conversion rank\",\n+\t\t      arg2_type, arg3_type);\n+\t  return error_mark_node;\n+\t}\n+\n       if (complain & tf_warning)\n \tdo_warn_double_promotion (result_type, arg2_type, arg3_type,\n \t\t\t\t  \"implicit conversion from %qH to %qI to \"\n@@ -7906,6 +7937,27 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t\t\t\t\"direct-initialization\",\n \t\t\t\ttotype, TREE_TYPE (expr));\n \n+      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+\t  && TREE_CODE (totype) == REAL_TYPE\n+\t  && (extended_float_type_p (TREE_TYPE (expr))\n+\t      || extended_float_type_p (totype)))\n+\tswitch (cp_compare_floating_point_conversion_ranks (TREE_TYPE (expr),\n+\t\t\t\t\t\t\t    totype))\n+\t  {\n+\t  case 2:\n+\t    pedwarn (loc, 0, \"converting to %qH from %qI with greater \"\n+\t\t\t     \"conversion rank\", totype, TREE_TYPE (expr));\n+\t    complained = true;\n+\t    break;\n+\t  case 3:\n+\t    pedwarn (loc, 0, \"converting to %qH from %qI with unordered \"\n+\t\t\t     \"conversion ranks\", totype, TREE_TYPE (expr));\n+\t    complained = true;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n       for (; t ; t = next_conversion (t))\n \t{\n \t  if (t->kind == ck_user && t->cand->reason)\n@@ -8531,7 +8583,8 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n   if (TREE_CODE (arg_type) == REAL_TYPE\n       && (TYPE_PRECISION (arg_type)\n \t  < TYPE_PRECISION (double_type_node))\n-      && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (arg_type)))\n+      && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (arg_type))\n+      && !extended_float_type_p (arg_type))\n     {\n       if ((complain & tf_warning)\n \t  && warn_double_promotion && !c_inhibit_evaluation_warnings)\n@@ -11719,6 +11772,81 @@ compare_ics (conversion *ics1, conversion *ics2)\n \treturn 1;\n     }\n \n+  {\n+    /* A conversion in either direction between floating-point type FP1 and\n+       floating-point type FP2 is better than a conversion in the same\n+       direction between FP1 and arithmetic type T3 if\n+       - the floating-point conversion rank of FP1 is equal to the rank of\n+\t FP2, and\n+       - T3 is not a floating-point type, or T3 is a floating-point type\n+\t whose rank is not equal to the rank of FP1, or the floating-point\n+\t conversion subrank of FP2 is greater than the subrank of T3.  */\n+    tree fp1 = from_type1;\n+    tree fp2 = to_type1;\n+    tree fp3 = from_type2;\n+    tree t3 = to_type2;\n+    int ret = 1;\n+    if (TYPE_MAIN_VARIANT (fp2) == TYPE_MAIN_VARIANT (t3))\n+      {\n+\tstd::swap (fp1, fp2);\n+\tstd::swap (fp3, t3);\n+      }\n+    if (TYPE_MAIN_VARIANT (fp1) == TYPE_MAIN_VARIANT (fp3)\n+\t&& TREE_CODE (fp1) == REAL_TYPE\n+\t/* Only apply this rule if at least one of the 3 types is\n+\t   extended floating-point type, otherwise keep them as\n+\t   before for compatibility reasons with types like __float128.\n+\t   float, double and long double alone have different conversion\n+\t   ranks and so when just those 3 types are involved, this\n+\t   rule doesn't trigger.  */\n+\t&& (extended_float_type_p (fp1)\n+\t    || (TREE_CODE (fp2) == REAL_TYPE && extended_float_type_p (fp2))\n+\t    || (TREE_CODE (t3) == REAL_TYPE && extended_float_type_p (t3))))\n+      {\n+\tif (TREE_CODE (fp2) != REAL_TYPE)\n+\t  {\n+\t    ret = -ret;\n+\t    std::swap (fp2, t3);\n+\t  }\n+\tif (TREE_CODE (fp2) == REAL_TYPE)\n+\t  {\n+\t    /* cp_compare_floating_point_conversion_ranks returns -1, 0 or 1\n+\t       if the conversion rank is equal (-1 or 1 if the subrank is\n+\t       different).  */\n+\t    if (IN_RANGE (cp_compare_floating_point_conversion_ranks (fp1,\n+\t\t\t\t\t\t\t\t      fp2),\n+\t\t\t  -1, 1))\n+\t      {\n+\t\t/* Conversion ranks of FP1 and FP2 are equal.  */\n+\t\tif (TREE_CODE (t3) != REAL_TYPE\n+\t\t    || !IN_RANGE (cp_compare_floating_point_conversion_ranks\n+\t\t\t\t\t\t\t\t(fp1, t3),\n+\t\t\t\t  -1, 1))\n+\t\t  /* FP1 <-> FP2 conversion is better.  */\n+\t\t  return ret;\n+\t\tint c = cp_compare_floating_point_conversion_ranks (fp2, t3);\n+\t\tgcc_assert (IN_RANGE (c, -1, 1));\n+\t\tif (c == 1)\n+\t\t  /* Conversion subrank of FP2 is greater than subrank of T3.\n+\t\t     FP1 <-> FP2 conversion is better.  */\n+\t\t  return ret;\n+\t\telse if (c == -1)\n+\t\t  /* Conversion subrank of FP2 is less than subrank of T3.\n+\t\t     FP1 <-> T3 conversion is better.  */\n+\t\t  return -ret;\n+\t      }\n+\t    else if (TREE_CODE (t3) == REAL_TYPE\n+\t\t     && IN_RANGE (cp_compare_floating_point_conversion_ranks\n+\t\t\t\t\t\t\t\t(fp1, t3),\n+\t\t\t\t  -1, 1))\n+\t      /* Conversion ranks of FP1 and FP2 are not equal, conversion\n+\t\t ranks of FP1 and T3 are equal.\n+\t\t FP1 <-> T3 conversion is better.  */\n+\t      return -ret;\n+\t  }\n+      }\n+  }\n+\n   if (TYPE_PTR_P (from_type1)\n       && TYPE_PTR_P (from_type2)\n       && TYPE_PTR_P (to_type1)"}, {"sha": "8779538abb369963bd569dfcd0456cd74af1021f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -7946,6 +7946,7 @@ extern tree require_complete_type\t\t(tree,\n extern tree complete_type\t\t\t(tree);\n extern tree complete_type_or_else\t\t(tree, tree);\n extern tree complete_type_or_maybe_complain\t(tree, tree, tsubst_flags_t);\n+extern int cp_compare_floating_point_conversion_ranks (tree, tree);\n inline bool type_unknown_p\t\t\t(const_tree);\n enum { ce_derived, ce_type, ce_normal, ce_exact };\n extern bool comp_except_specs\t\t\t(const_tree, const_tree, int);\n@@ -8688,6 +8689,18 @@ struct push_access_scope_guard\n   }\n };\n \n+/* True if TYPE is an extended floating-point type.  */\n+\n+inline bool\n+extended_float_type_p (tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+  for (int i = 0; i < NUM_FLOATN_NX_TYPES; ++i)\n+    if (type == FLOATN_TYPE_NODE (i))\n+      return true;\n+  return false;\n+}\n+\n #if CHECKING_P\n namespace selftest {\n   extern void run_cp_tests (void);"}, {"sha": "00d283fff8c1b2397d825effe78bbddba641837b", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 14, "deletions": 53, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -2648,63 +2648,24 @@ write_builtin_type (tree type)\n \twrite_string (\"Dd\");\n       else if (type == dfloat128_type_node || type == fallback_dfloat128_type)\n \twrite_string (\"De\");\n+      else if (type == float16_type_node)\n+\twrite_string (\"DF16_\");\n+      else if (type == float32_type_node)\n+\twrite_string (\"DF32_\");\n+      else if (type == float64_type_node)\n+\twrite_string (\"DF64_\");\n+      else if (type == float128_type_node)\n+\twrite_string (\"DF128_\");\n+      else if (type == float32x_type_node)\n+\twrite_string (\"DF32x\");\n+      else if (type == float64x_type_node)\n+\twrite_string (\"DF64x\");\n+      else if (type == float128x_type_node)\n+\twrite_string (\"DF128x\");\n       else\n \tgcc_unreachable ();\n       break;\n \n-    case FIXED_POINT_TYPE:\n-      write_string (\"DF\");\n-      if (GET_MODE_IBIT (TYPE_MODE (type)) > 0)\n-\twrite_unsigned_number (GET_MODE_IBIT (TYPE_MODE (type)));\n-      if (type == fract_type_node\n-\t  || type == sat_fract_type_node\n-\t  || type == accum_type_node\n-\t  || type == sat_accum_type_node)\n-\twrite_char ('i');\n-      else if (type == unsigned_fract_type_node\n-\t       || type == sat_unsigned_fract_type_node\n-\t       || type == unsigned_accum_type_node\n-\t       || type == sat_unsigned_accum_type_node)\n-\twrite_char ('j');\n-      else if (type == short_fract_type_node\n-\t       || type == sat_short_fract_type_node\n-\t       || type == short_accum_type_node\n-\t       || type == sat_short_accum_type_node)\n-\twrite_char ('s');\n-      else if (type == unsigned_short_fract_type_node\n-\t       || type == sat_unsigned_short_fract_type_node\n-\t       || type == unsigned_short_accum_type_node\n-\t       || type == sat_unsigned_short_accum_type_node)\n-\twrite_char ('t');\n-      else if (type == long_fract_type_node\n-\t       || type == sat_long_fract_type_node\n-\t       || type == long_accum_type_node\n-\t       || type == sat_long_accum_type_node)\n-\twrite_char ('l');\n-      else if (type == unsigned_long_fract_type_node\n-\t       || type == sat_unsigned_long_fract_type_node\n-\t       || type == unsigned_long_accum_type_node\n-\t       || type == sat_unsigned_long_accum_type_node)\n-\twrite_char ('m');\n-      else if (type == long_long_fract_type_node\n-\t       || type == sat_long_long_fract_type_node\n-\t       || type == long_long_accum_type_node\n-\t       || type == sat_long_long_accum_type_node)\n-\twrite_char ('x');\n-      else if (type == unsigned_long_long_fract_type_node\n-\t       || type == sat_unsigned_long_long_fract_type_node\n-\t       || type == unsigned_long_long_accum_type_node\n-\t       || type == sat_unsigned_long_long_accum_type_node)\n-\twrite_char ('y');\n-      else\n-\tsorry (\"mangling unknown fixed point type\");\n-      write_unsigned_number (GET_MODE_FBIT (TYPE_MODE (type)));\n-      if (TYPE_SATURATING (type))\n-\twrite_char ('s');\n-      else\n-\twrite_char ('n');\n-      break;\n-\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "3dedd14042852efa14de52b8e84d329d0c07506a", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -1129,6 +1129,7 @@ cp_keyword_starts_decl_specifier_p (enum rid keyword)\n     case RID_UNSIGNED:\n     case RID_FLOAT:\n     case RID_DOUBLE:\n+    CASE_RID_FLOATN_NX:\n     case RID_VOID:\n       /* CV qualifiers.  */\n     case RID_CONST:\n@@ -19716,6 +19717,14 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n     case RID_DOUBLE:\n       type = double_type_node;\n       break;\n+    CASE_RID_FLOATN_NX:\n+      type = FLOATN_NX_TYPE_NODE (token->keyword - RID_FLOATN_NX_FIRST);\n+      if (type == NULL_TREE)\n+\terror (\"%<_Float%d%s%> is not supported on this target\",\n+\t       floatn_nx_types[token->keyword - RID_FLOATN_NX_FIRST].n,\n+\t       floatn_nx_types[token->keyword - RID_FLOATN_NX_FIRST].extended\n+\t       ? \"x\" : \"\");\n+      break;\n     case RID_VOID:\n       type = void_type_node;\n       break;"}, {"sha": "4854b98376533338489ed57769cc3cb487a4c50b", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 171, "deletions": 1, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -267,6 +267,133 @@ merge_type_attributes_from (tree type, tree other_type)\n   return cp_build_type_attribute_variant (type, attrs);\n }\n \n+/* Compare floating point conversion ranks and subranks of T1 and T2\n+   types.  If T1 and T2 have unordered conversion ranks, return 3.\n+   If T1 has greater conversion rank than T2, return 2.\n+   If T2 has greater conversion rank than T1, return -2.\n+   If T1 has equal conversion rank as T2, return -1, 0 or 1 depending\n+   on if T1 has smaller, equal or greater conversion subrank than\n+   T2.  */\n+\n+int\n+cp_compare_floating_point_conversion_ranks (tree t1, tree t2)\n+{\n+  tree mv1 = TYPE_MAIN_VARIANT (t1);\n+  tree mv2 = TYPE_MAIN_VARIANT (t2);\n+  int extended1 = 0;\n+  int extended2 = 0;\n+\n+  if (mv1 == mv2)\n+    return 0;\n+\n+  for (int i = 0; i < NUM_FLOATN_NX_TYPES; ++i)\n+    {\n+      if (mv1 == FLOATN_NX_TYPE_NODE (i))\n+\textended1 = i + 1;\n+      if (mv2 == FLOATN_NX_TYPE_NODE (i))\n+\textended2 = i + 1;\n+    }\n+  if (extended2 && !extended1)\n+    {\n+      int ret = cp_compare_floating_point_conversion_ranks (t2, t1);\n+      return ret == 3 ? 3 : -ret;\n+    }\n+\n+  const struct real_format *fmt1 = REAL_MODE_FORMAT (TYPE_MODE (t1));\n+  const struct real_format *fmt2 = REAL_MODE_FORMAT (TYPE_MODE (t2));\n+  gcc_assert (fmt1->b == 2 && fmt2->b == 2);\n+  /* For {ibm,mips}_extended_format formats, the type has variable\n+     precision up to ~2150 bits when the first double is around maximum\n+     representable double and second double is subnormal minimum.\n+     So, e.g. for __ibm128 vs. std::float128_t, they have unordered\n+     ranks.  */\n+  int p1 = (MODE_COMPOSITE_P (TYPE_MODE (t1))\n+\t    ? fmt1->emax - fmt1->emin + fmt1->p - 1 : fmt1->p);\n+  int p2 = (MODE_COMPOSITE_P (TYPE_MODE (t2))\n+\t    ? fmt2->emax - fmt2->emin + fmt2->p - 1 : fmt2->p);\n+  /* The rank of a floating point type T is greater than the rank of\n+     any floating-point type whose set of values is a proper subset\n+     of the set of values of T.  */\n+  if ((p1 > p2 && fmt1->emax >= fmt2->emax)\n+       || (p1 == p2 && fmt1->emax > fmt2->emax))\n+    return 2;\n+  if ((p1 < p2 && fmt1->emax <= fmt2->emax)\n+       || (p1 == p2 && fmt1->emax < fmt2->emax))\n+    return -2;\n+  if ((p1 > p2 && fmt1->emax < fmt2->emax)\n+       || (p1 < p2 && fmt1->emax > fmt2->emax))\n+    return 3;\n+  if (!extended1 && !extended2)\n+    {\n+      /* The rank of long double is greater than the rank of double, which\n+\t is greater than the rank of float.  */\n+      if (t1 == long_double_type_node)\n+\treturn 2;\n+      else if (t2 == long_double_type_node)\n+\treturn -2;\n+      if (t1 == double_type_node)\n+\treturn 2;\n+      else if (t2 == double_type_node)\n+\treturn -2;\n+      if (t1 == float_type_node)\n+\treturn 2;\n+      else if (t2 == float_type_node)\n+\treturn -2;\n+      return 0;\n+    }\n+  /* Two extended floating-point types with the same set of values have equal\n+     ranks.  */\n+  if (extended1 && extended2)\n+    {\n+      if ((extended1 <= NUM_FLOATN_TYPES) == (extended2 <= NUM_FLOATN_TYPES))\n+\t{\n+\t  /* Prefer higher extendedN value.  */\n+\t  if (extended1 > extended2)\n+\t    return 1;\n+\t  else if (extended1 < extended2)\n+\t    return -1;\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (extended1 <= NUM_FLOATN_TYPES)\n+\t/* Prefer _FloatN type over _FloatMx type.  */\n+\treturn 1;\n+      else if (extended2 <= NUM_FLOATN_TYPES)\n+\treturn -1;\n+      else\n+\treturn 0;\n+    }\n+\n+  /* gcc_assert (extended1 && !extended2);  */\n+  tree *p;\n+  int cnt = 0;\n+  for (p = &float_type_node; p <= &long_double_type_node; ++p)\n+    {\n+      const struct real_format *fmt3 = REAL_MODE_FORMAT (TYPE_MODE (*p));\n+      gcc_assert (fmt3->b == 2);\n+      int p3 = (MODE_COMPOSITE_P (TYPE_MODE (*p))\n+\t\t? fmt3->emax - fmt3->emin + fmt3->p - 1 : fmt3->p);\n+      if (p1 == p3 && fmt1->emax == fmt3->emax)\n+\t++cnt;\n+    }\n+  /* An extended floating-point type with the same set of values\n+     as exactly one cv-unqualified standard floating-point type\n+     has a rank equal to the rank of that standard floating-point\n+     type.\n+\n+     An extended floating-point type with the same set of values\n+     as more than one cv-unqualified standard floating-point type\n+     has a rank equal to the rank of double.\n+\n+     Thus, if the latter is true and t2 is long double, t2\n+     has higher rank.  */\n+  if (cnt > 1 && mv2 == long_double_type_node)\n+    return -2;\n+  /* Otherwise, they have equal rank, but extended types\n+     (other than std::bfloat16_t) have higher subrank.  */\n+  return 1;\n+}\n+\n /* Return the common type for two arithmetic types T1 and T2 under the\n    usual arithmetic conversions.  The default conversions have already\n    been applied, and enumerated types converted to their compatible\n@@ -337,6 +464,23 @@ cp_common_type (tree t1, tree t2)\n   if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n     return build_type_attribute_variant (t2, attributes);\n \n+  if (code1 == REAL_TYPE\n+      && (extended_float_type_p (t1) || extended_float_type_p (t2)))\n+    {\n+      tree mv1 = TYPE_MAIN_VARIANT (t1);\n+      tree mv2 = TYPE_MAIN_VARIANT (t2);\n+      if (mv1 == mv2)\n+\treturn build_type_attribute_variant (t1, attributes);\n+\n+      int cmpret = cp_compare_floating_point_conversion_ranks (mv1, mv2);\n+      if (cmpret == 3)\n+\treturn error_mark_node;\n+      else if (cmpret >= 0)\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else\n+\treturn build_type_attribute_variant (t2, attributes);\n+    }\n+\n   /* Both real or both integers; use the one with greater precision.  */\n   if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n     return build_type_attribute_variant (t1, attributes);\n@@ -5037,7 +5181,20 @@ cp_build_binary_op (const op_location_t &location,\n        = targetm.invalid_binary_op (code, type0, type1)))\n     {\n       if (complain & tf_error)\n-\terror (invalid_op_diag);\n+\t{\n+\t  if (code0 == REAL_TYPE\n+\t      && code1 == REAL_TYPE\n+\t      && (extended_float_type_p (type0)\n+\t\t  || extended_float_type_p (type1))\n+\t      && cp_compare_floating_point_conversion_ranks (type0,\n+\t\t\t\t\t\t\t     type1) == 3)\n+\t    {\n+\t      rich_location richloc (line_table, location);\n+\t      binary_op_error (&richloc, code, type0, type1);\n+\t    }\n+\t  else\n+\t    error (invalid_op_diag);\n+\t}\n       return error_mark_node;\n     }\n \n@@ -5907,6 +6064,19 @@ cp_build_binary_op (const op_location_t &location,\n       && (shorten || common || short_compare))\n     {\n       result_type = cp_common_type (type0, type1);\n+      if (result_type == error_mark_node\n+\t  && code0 == REAL_TYPE\n+\t  && code1 == REAL_TYPE\n+\t  && (extended_float_type_p (type0) || extended_float_type_p (type1))\n+\t  && cp_compare_floating_point_conversion_ranks (type0, type1) == 3)\n+\t{\n+\t  if (complain & tf_error)\n+\t    {\n+\t      rich_location richloc (line_table, location);\n+\t      binary_op_error (&richloc, code, type0, type1);\n+\t    }\n+\t  return error_mark_node;\n+\t}\n       if (complain & tf_warning)\n \t{\n \t  do_warn_double_promotion (result_type, type0, type1,"}, {"sha": "d5236d19b09377e017763c23a00174e170574120", "filename": "gcc/cp/typeck2.cc", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Ftypeck2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Fcp%2Ftypeck2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -997,12 +997,25 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain,\n   else if (TREE_CODE (ftype) == REAL_TYPE\n \t   && TREE_CODE (type) == REAL_TYPE)\n     {\n-      if ((same_type_p (ftype, long_double_type_node)\n-\t   && (same_type_p (type, double_type_node)\n-\t       || same_type_p (type, float_type_node)))\n-\t  || (same_type_p (ftype, double_type_node)\n-\t      && same_type_p (type, float_type_node))\n-\t  || (TYPE_PRECISION (type) < TYPE_PRECISION (ftype)))\n+      if ((extended_float_type_p (ftype) || extended_float_type_p (type))\n+\t  ? /* \"from a floating-point type T to another floating-point type\n+\t       whose floating-point conversion rank is neither greater than\n+\t       nor equal to that of T\".\n+\t       So, it is ok if\n+\t       cp_compare_floating_point_conversion_ranks (ftype, type)\n+\t       returns -2 (type has greater conversion rank than ftype)\n+\t       or [-1..1] (type has equal conversion rank as ftype, possibly\n+\t       different subrank.  Only do this if at least one of the\n+\t       types is extended floating-point type, otherwise keep doing\n+\t       what we did before (for the sake of non-standard\n+\t       backend types).  */\n+\t    cp_compare_floating_point_conversion_ranks (ftype, type) >= 2\n+\t  : ((same_type_p (ftype, long_double_type_node)\n+\t      && (same_type_p (type, double_type_node)\n+\t\t  || same_type_p (type, float_type_node)))\n+\t     || (same_type_p (ftype, double_type_node)\n+\t\t && same_type_p (type, float_type_node))\n+\t     || (TYPE_PRECISION (type) < TYPE_PRECISION (ftype))))\n \t{\n \t  if (TREE_CODE (init) == REAL_CST)\n \t    {"}, {"sha": "ffd9e636a0de657d3a504d429815f3b34f766cf3", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating.h?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,30 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+\n+namespace std\n+{\n+  #ifdef __STDCPP_FLOAT16_T__\n+  using float16_t = _Float16;\n+  #endif\n+  #ifdef __STDCPP_FLOAT32_T__\n+  using float32_t = _Float32;\n+  #endif\n+  #ifdef __STDCPP_FLOAT64_T__\n+  using float64_t = _Float64;\n+  #endif\n+  #ifdef __STDCPP_FLOAT128_T__\n+  using float128_t = _Float128;\n+  #endif\n+  #undef __STDCPP_BFLOAT16_T__\n+  #ifdef __STDCPP_BFLOAT16_T__\n+  using bfloat16_t = __bf16; // ???\n+  #endif\n+  template<typename T, T v> struct integral_constant {\n+    static constexpr T value = v;\n+  };\n+  typedef integral_constant<bool, false> false_type;\n+  typedef integral_constant<bool, true> true_type;\n+  template<class T, class U>\n+  struct is_same : std::false_type {};\n+  template <class T>\n+  struct is_same<T, T> : std::true_type {};\n+}"}, {"sha": "63232afada81278a9becd59243aac4843085563a", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating1.C", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating1.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,447 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"\" }\n+\n+#include \"ext-floating.h\"\n+\n+#ifdef __STRICT_ANSI__\n+#undef __SIZEOF_FLOAT128__\n+#endif\n+\n+using namespace std;\n+\n+static_assert (!is_same<float, double>::value);\n+static_assert (!is_same<float, long double>::value);\n+static_assert (!is_same<double, long double>::value);\n+static_assert (is_same<decltype (0.0f), float>::value);\n+static_assert (is_same<decltype (0.0F), float>::value);\n+static_assert (is_same<decltype (0.0), double>::value);\n+static_assert (is_same<decltype (0.0l), long double>::value);\n+static_assert (is_same<decltype (0.0L), long double>::value);\n+static_assert (is_same<decltype (0.0f + 0.0F), float>::value);\n+static_assert (is_same<decltype (0.0F + 0.0f), float>::value);\n+static_assert (is_same<decltype (0.0 + 0.0), double>::value);\n+static_assert (is_same<decltype (0.0l + 0.0L), long double>::value);\n+static_assert (is_same<decltype (0.0L + 0.0l), long double>::value);\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (is_same<decltype (0.0q), __float128>::value);\n+static_assert (is_same<decltype (0.0Q), __float128>::value);\n+static_assert (is_same<decltype (0.0q + 0.0q), __float128>::value);\n+static_assert (is_same<decltype (0.0Q + 0.0Q), __float128>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT16_T__\n+static_assert (!is_same<float, float16_t>::value);\n+static_assert (!is_same<double, float16_t>::value);\n+static_assert (!is_same<long double, float16_t>::value);\n+static_assert (is_same<decltype (0.0f16), float16_t>::value);\n+static_assert (is_same<decltype (0.0F16), float16_t>::value);\n+static_assert (is_same<decltype (0.0f16 + 0.0f16), float16_t>::value);\n+static_assert (is_same<decltype (0.0F16 + 0.0F16), float16_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+static_assert (!is_same<float, float32_t>::value);\n+static_assert (!is_same<double, float32_t>::value);\n+static_assert (!is_same<long double, float32_t>::value);\n+static_assert (!is_same<decltype (0.0f), float32_t>::value);\n+static_assert (!is_same<decltype (0.0F), float32_t>::value);\n+static_assert (is_same<decltype (0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32), float32_t>::value);\n+static_assert (!is_same<decltype (0.0f32), float>::value);\n+static_assert (!is_same<decltype (0.0F32), float>::value);\n+static_assert (is_same<decltype (0.0f32 + 0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0F32), float32_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+static_assert (!is_same<float, float64_t>::value);\n+static_assert (!is_same<double, float64_t>::value);\n+static_assert (!is_same<long double, float64_t>::value);\n+static_assert (!is_same<decltype (0.0), float64_t>::value);\n+static_assert (is_same<decltype (0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64), float64_t>::value);\n+static_assert (!is_same<decltype (0.0f64), double>::value);\n+static_assert (!is_same<decltype (0.0F64), double>::value);\n+static_assert (is_same<decltype (0.0f64 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0F64), float64_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+static_assert (!is_same<float, float128_t>::value);\n+static_assert (!is_same<double, float128_t>::value);\n+static_assert (!is_same<long double, float128_t>::value);\n+static_assert (!is_same<decltype (0.0l), float128_t>::value);\n+static_assert (!is_same<decltype (0.0L), float128_t>::value);\n+static_assert (is_same<decltype (0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128), float128_t>::value);\n+static_assert (!is_same<decltype (0.0f128), long double>::value);\n+static_assert (!is_same<decltype (0.0F128), long double>::value);\n+static_assert (is_same<decltype (0.0f128 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F128), float128_t>::value);\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (!is_same<float128_t, __float128>::value);\n+static_assert (!is_same<decltype (0.0q), float128_t>::value);\n+static_assert (!is_same<decltype (0.0Q), float128_t>::value);\n+static_assert (!is_same<decltype (0.0f128), __float128>::value);\n+static_assert (!is_same<decltype (0.0F128), __float128>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+static_assert (!is_same<float, bfloat16_t>::value);\n+static_assert (!is_same<double, bfloat16_t>::value);\n+static_assert (!is_same<long double, bfloat16_t>::value);\n+static_assert (is_same<decltype (0.0bf16), bfloat16_t>::value);\n+static_assert (is_same<decltype (0.0BF16), bfloat16_t>::value);\n+static_assert (is_same<decltype (0.0bf16 + 0.0bf16), bfloat16_t>::value);\n+static_assert (is_same<decltype (0.0BF16 + 0.0BF16), bfloat16_t>::value);\n+#endif\n+#ifdef __FLT32X_MANT_DIG__\n+static_assert (!is_same<float, _Float32x>::value);\n+static_assert (!is_same<double, _Float32x>::value);\n+static_assert (!is_same<long double, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F), _Float32x>::value);\n+static_assert (is_same<decltype (0.0f32x), _Float32x>::value);\n+static_assert (is_same<decltype (0.0F32x), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float>::value);\n+static_assert (!is_same<decltype (0.0F32x), float>::value);\n+static_assert (is_same<decltype (0.0f32x + 0.0f32x), _Float32x>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F32x), _Float32x>::value);\n+#ifdef __STDCPP_FLOAT16_T__\n+static_assert (!is_same<float16_t, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f16), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F16), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float16_t>::value);\n+static_assert (!is_same<decltype (0.0F32x), float16_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+static_assert (!is_same<float32_t, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F32), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float32_t>::value);\n+static_assert (!is_same<decltype (0.0F32x), float32_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+static_assert (!is_same<float64_t, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f64), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F64), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float64_t>::value);\n+static_assert (!is_same<decltype (0.0F32x), float64_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+static_assert (!is_same<float128_t, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f128), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F128), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float128_t>::value);\n+static_assert (!is_same<decltype (0.0F32x), float128_t>::value);\n+#endif\n+#endif\n+#ifdef __FLT64X_MANT_DIG__\n+static_assert (!is_same<float, _Float64x>::value);\n+static_assert (!is_same<double, _Float64x>::value);\n+static_assert (!is_same<long double, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0), _Float64x>::value);\n+static_assert (is_same<decltype (0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), double>::value);\n+static_assert (!is_same<decltype (0.0F64x), double>::value);\n+static_assert (is_same<decltype (0.0f64x + 0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F64x), _Float64x>::value);\n+#ifdef __STDCPP_FLOAT16_T__\n+static_assert (!is_same<float16_t, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f16), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0F16), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), float16_t>::value);\n+static_assert (!is_same<decltype (0.0F64x), float16_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+static_assert (!is_same<float32_t, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f32), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0F32), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), float32_t>::value);\n+static_assert (!is_same<decltype (0.0F64x), float32_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+static_assert (!is_same<float64_t, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0F64), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), float64_t>::value);\n+static_assert (!is_same<decltype (0.0F64x), float64_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+static_assert (!is_same<float128_t, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f128), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0F128), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), float128_t>::value);\n+static_assert (!is_same<decltype (0.0F64x), float128_t>::value);\n+#endif\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (!is_same<_Float64x, __float128>::value);\n+static_assert (!is_same<decltype (0.0q), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0Q), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), __float128>::value);\n+static_assert (!is_same<decltype (0.0F64x), __float128>::value);\n+#endif\n+#endif\n+#ifdef __FLT128X_MANT_DIG__\n+static_assert (!is_same<float, _Float128x>::value);\n+static_assert (!is_same<double, _Float128x>::value);\n+static_assert (!is_same<long double, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0l), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0L), _Float128x>::value);\n+static_assert (is_same<decltype (0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), long double>::value);\n+static_assert (!is_same<decltype (0.0F128x), long double>::value);\n+static_assert (is_same<decltype (0.0f128x + 0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F128x), _Float128x>::value);\n+#ifdef __STDCPP_FLOAT16_T__\n+static_assert (!is_same<float16_t, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f16), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0F16), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), float16_t>::value);\n+static_assert (!is_same<decltype (0.0F128x), float16_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+static_assert (!is_same<float32_t, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f32), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0F32), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), float32_t>::value);\n+static_assert (!is_same<decltype (0.0F128x), float32_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+static_assert (!is_same<float64_t, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f64), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0F64), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), float64_t>::value);\n+static_assert (!is_same<decltype (0.0F128x), float64_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+static_assert (!is_same<float128_t, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0F128), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), float128_t>::value);\n+static_assert (!is_same<decltype (0.0F128x), float128_t>::value);\n+#endif\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (!is_same<_Float128x, __float128>::value);\n+static_assert (!is_same<decltype (0.0q), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0Q), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), __float128>::value);\n+static_assert (!is_same<decltype (0.0F128x), __float128>::value);\n+#endif\n+#endif\n+static_assert (is_same<decltype (0.0f + 0.0), double>::value);\n+static_assert (is_same<decltype (0.0 + 0.0F), double>::value);\n+static_assert (is_same<decltype (0.0L + 0.0), long double>::value);\n+static_assert (is_same<decltype (0.0 + 0.0L), long double>::value);\n+static_assert (is_same<decltype (0.0L + 0.0f), long double>::value);\n+static_assert (is_same<decltype (0.0F + 0.0l), long double>::value);\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__STDCPP_FLOAT32_T__)\n+static_assert (!is_same<float16_t, float32_t>::value);\n+static_assert (is_same<decltype (0.0f16 + 0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0F16), float32_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__STDCPP_FLOAT64_T__)\n+static_assert (!is_same<float16_t, float64_t>::value);\n+static_assert (is_same<decltype (0.0f16 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0F16), float64_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__STDCPP_FLOAT128_T__)\n+static_assert (!is_same<float16_t, float128_t>::value);\n+static_assert (is_same<decltype (0.0f16 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F16), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__FLT32X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f16 + 0.0f32x), _Float32x>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F16), _Float32x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__FLT64X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f16 + 0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F16), _Float64x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__FLT128X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f16 + 0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F16), _Float128x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__STDCPP_FLOAT64_T__)\n+static_assert (!is_same<float32_t, float64_t>::value);\n+static_assert (is_same<decltype (0.0f32 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0F32), float64_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__STDCPP_FLOAT128_T__)\n+static_assert (!is_same<float32_t, float128_t>::value);\n+static_assert (is_same<decltype (0.0f32 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F32), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__FLT32X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f32 + 0.0f32x), _Float32x>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F32), _Float32x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__FLT64X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f32 + 0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F32), _Float64x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__FLT128X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f32 + 0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F32), _Float128x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(__STDCPP_FLOAT128_T__)\n+static_assert (!is_same<float64_t, float128_t>::value);\n+static_assert (is_same<decltype (0.0f64 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F64), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(__FLT32X_MANT_DIG__) \\\n+    && __FLT64_MAX_EXP__ == __FLT32X_MAX_EXP__ \\\n+    && __FLT64_MANT_DIG__ == __FLT32X_MANT_DIG__\n+static_assert (is_same<decltype (0.0f64 + 0.0f32x), float64_t>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F64), float64_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(__FLT64X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f64 + 0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F64), _Float64x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(__FLT128X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f64 + 0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F64), _Float128x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) && defined(__FLT32X_MANT_DIG__) \\\n+    && __FLT128_MAX_EXP__ >= __FLT32X_MAX_EXP__ \\\n+    && __FLT128_MANT_DIG__ >= __FLT32X_MANT_DIG__\n+static_assert (is_same<decltype (0.0f128 + 0.0f32x), float128_t>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F128), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) && defined(__FLT64X_MANT_DIG__) \\\n+    && __FLT128_MAX_EXP__ >= __FLT64X_MAX_EXP__ \\\n+    && __FLT128_MANT_DIG__ >= __FLT64X_MANT_DIG__\n+static_assert (is_same<decltype (0.0f128 + 0.0f64x), float128_t>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F128), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) && defined(__FLT128X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f128 + 0.0f128x), _Float128>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F128), _Float128>::value);\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(__STDCPP_FLOAT32_T__)\n+static_assert (!is_same<bfloat16_t, float32_t>::value);\n+static_assert (is_same<decltype (0.0bf16 + 0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0BF16), float32_t>::value);\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(__STDCPP_FLOAT64_T__)\n+static_assert (!is_same<bfloat16_t, float64_t>::value);\n+static_assert (is_same<decltype (0.0bf16 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0BF16), float64_t>::value);\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(__STDCPP_FLOAT128_T__)\n+static_assert (!is_same<bfloat16_t, float128_t>::value);\n+static_assert (is_same<decltype (0.0bf16 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0BF16), float128_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT16_T__\n+#if __FLT_MAX_EXP__ > __FLT16_MAX_EXP__ && __FLT_MANT_DIG__ > __FLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0f16), float>::value);\n+static_assert (is_same<decltype (0.0F16 + 0.0F), float>::value);\n+#endif\n+#if __DBL_MAX_EXP__ > __FLT16_MAX_EXP__ && __DBL_MANT_DIG__ > __FLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0f16), double>::value);\n+static_assert (is_same<decltype (0.0F16 + 0.0), double>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ > __FLT16_MAX_EXP__ && __LDBL_MANT_DIG__ > __FLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0L + 0.0f16), long double>::value);\n+static_assert (is_same<decltype (0.0F16 + 0.0l), long double>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+#if __FLT_MAX_EXP__ == __FLT32_MAX_EXP__ && __FLT_MANT_DIG__ == __FLT32_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0F), float32_t>::value);\n+#endif\n+#if __DBL_MAX_EXP__ > __FLT32_MAX_EXP__ && __DBL_MANT_DIG__ > __FLT32_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0f32), double>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0), double>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ > __FLT32_MAX_EXP__ && __LDBL_MANT_DIG__ > __FLT32_MANT_DIG__\n+static_assert (is_same<decltype (0.0L + 0.0f32), long double>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0l), long double>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+#if __FLT_MAX_EXP__ < __FLT64_MAX_EXP__ && __FLT_MANT_DIG__ < __FLT64_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0F), float64_t>::value);\n+#endif\n+#if __DBL_MAX_EXP__ == __FLT64_MAX_EXP__ && __DBL_MANT_DIG__ == __FLT64_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0), float64_t>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ > __FLT64_MAX_EXP__ && __LDBL_MANT_DIG__ > __FLT64_MANT_DIG__\n+static_assert (is_same<decltype (0.0L + 0.0f64), long double>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0l), long double>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ == __FLT64_MAX_EXP__ && __LDBL_MANT_DIG__ == __FLT64_MANT_DIG__ \\\n+    && __DBL_MAX_EXP__ == __FLT64_MAX_EXP__ && __DBL_MANT_DIG__ == __FLT64_MANT_DIG__\n+// An extended floating-point type with the same set of values as more than one\n+// cv-unqualified standard floating-point type has a rank equal to the rank of\n+// double.\n+// Then long double will have higher rank than float64_t.\n+static_assert (is_same<decltype (0.0L + 0.0f64), long double>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0l), long double>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+#if __FLT_MAX_EXP__ < __FLT128_MAX_EXP__ && __FLT_MANT_DIG__ < __FLT128_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F), float128_t>::value);\n+#endif\n+#if __DBL_MAX_EXP__ < __FLT128_MAX_EXP__ && __DBL_MANT_DIG__ < __FLT128_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0), float128_t>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ <= __FLT128_MAX_EXP__ && __LDBL_MANT_DIG__ <= __FLT128_MANT_DIG__ \\\n+    && __LDBL_MANT_DIG__ != 106 // IBM extended long double and IEEE quad are unordered.\n+static_assert (is_same<decltype (0.0L + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0l), float128_t>::value);\n+#endif\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (is_same<decltype (0.0Q + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0q), float128_t>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+#if __FLT_MAX_EXP__ > __BFLT16_MAX_EXP__ && __FLT_MANT_DIG__ > __BFLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0bf16), float>::value);\n+static_assert (is_same<decltype (0.0BF16 + 0.0F), float>::value);\n+#endif\n+#if __DBL_MAX_EXP__ > __BFLT16_MAX_EXP__ && __DBL_MANT_DIG__ > __BFLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0bf16), double>::value);\n+static_assert (is_same<decltype (0.0BF16 + 0.0), double>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ > __BFLT16_MAX_EXP__ && __LDBL_MANT_DIG__ > __BFLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0L + 0.0bf16), long double>::value);\n+static_assert (is_same<decltype (0.0BF16 + 0.0l), long double>::value);\n+#endif\n+#endif\n+\n+void foo (float) {}\n+void foo (double) {}\n+void foo (long double) {}\n+#ifdef __STDCPP_FLOAT16_T__\n+void foo (float16_t) {}\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+void foo (float32_t) {}\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+void foo (float64_t) {}\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+void foo (float128_t) {}\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+void foo (bfloat16_t) {}\n+#endif\n+#ifdef __FLT32X_MANT_DIG__\n+void foo (_Float32x) {}\n+#endif\n+#ifdef __FLT64X_MANT_DIG__\n+void foo (_Float64x) {}\n+#endif\n+#ifdef __FLT128X_MANT_DIG__\n+void foo (_Float128x) {}\n+#endif"}, {"sha": "f5563fedd8271a455d24ded78ac756bf6b8225b2", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating10.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating10.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,13 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do run { target { c++23 && float128_runtime } } }\n+// { dg-options \"\" }\n+// { dg-add-options float128 }\n+\n+#ifndef WIDTH\n+#ifndef __STDCPP_FLOAT128_T__\n+#error Unexpected\n+#endif\n+#define WIDTH 128\n+#endif\n+\n+#include \"ext-floating7.C\""}, {"sha": "41e9a54ada5c5bd41a28ddc68c05d5d626d9a788", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating2.C", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating2.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,157 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"\" }\n+\n+#include \"ext-floating.h\"\n+\n+#ifdef __STRICT_ANSI__\n+#undef __SIZEOF_FLOAT128__\n+#endif\n+\n+using namespace std;\n+\n+float fa = 1.0f;\n+float fb = (float) 1.0f;\n+float fc = 1.0;\n+float fd = (float) 1.0;\n+float fe = 1.0L;\n+float ff = (float) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float fg = 1.0Q;\n+float fh = (float) 1.0Q;\n+#endif\n+double da = 1.0f;\n+double db = (double) 1.0f;\n+double dc = 1.0;\n+double dd = (double) 1.0;\n+double de = 1.0L;\n+double df = (double) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+double dg = 1.0Q;\n+double dh = (double) 1.0Q;\n+#endif\n+long double lda = 1.0f;\n+long double ldb = (long double) 1.0f;\n+long double ldc = 1.0;\n+long double ldd = (long double) 1.0;\n+long double lde = 1.0L;\n+long double ldf = (long double) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+long double ldg = 1.0Q;\n+long double ldh = (long double) 1.0Q;\n+__float128 qa = 1.0f;\n+__float128 qb = (__float128) 1.0f;\n+__float128 qc = 1.0;\n+__float128 qd = (__float128) 1.0;\n+__float128 qe = 1.0L;\n+__float128 qf = (__float128) 1.0L;\n+__float128 qg = 1.0Q;\n+__float128 qh = (__float128) 1.0Q;\n+#endif\n+#ifdef __STDCPP_FLOAT16_T__\n+float16_t f16a = 1.0F16;\n+float16_t f16b = (float16_t) 1.0F16;\n+#ifdef __STDCPP_FLOAT32_T__\n+float16_t f16c = 1.0F32;\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from '_Float32' with greater conversion rank\" \"\" { target { float16 && float32 } } }\n+float16_t f16d = (float16_t) 1.0F32;\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+float16_t f16e = 1.0F64;\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from '_Float64' with greater conversion rank\" \"\" { target { float16 && float64 } } }\n+float16_t f16f = (float16_t) 1.0F64;\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+float16_t f16g = 1.0F128;\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from '_Float128' with greater conversion rank\" \"\" { target { float16 && float128 } } }\n+float16_t f16h = (float16_t) 1.0F128;\n+#endif\n+float16_t f16j = (float16_t) 1.0f;\n+float16_t f16l = (float16_t) 1.0;\n+float16_t f16n = (float16_t) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float16_t f16p = (float16_t) 1.0Q;\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+#ifdef __STDCPP_FLOAT16_T__\n+float32_t f32a = 1.0F16;\n+float32_t f32b = (float32_t) 1.0F16;\n+#endif\n+float32_t f32c = 1.0F32;\n+float32_t f32d = (float32_t) 1.0F32;\n+#ifdef __STDCPP_FLOAT64_T__\n+float32_t f32e = 1.0F64;\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from '_Float64' with greater conversion rank\" \"\" { target { float32 && float64 } } }\n+float32_t f32f = (float32_t) 1.0F64;\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+float32_t f32g = 1.0F128;\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from '_Float128' with greater conversion rank\" \"\" { target { float32 && float128 } } }\n+float32_t f32h = (float32_t) 1.0F128;\n+#endif\n+#if __FLT_MAX_EXP__ <= __FLT32_MAX_EXP__ && __FLT_MANT_DIG__ <= __FLT32_MANT_DIG__\n+float32_t f32i = 1.0f;\n+#endif\n+float32_t f32j = (float32_t) 1.0f;\n+float32_t f32l = (float32_t) 1.0;\n+float32_t f32n = (float32_t) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float32_t f32p = (float32_t) 1.0Q;\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+#ifdef __STDCPP_FLOAT16_T__\n+float64_t f64a = 1.0F16;\n+float64_t f64b = (float64_t) 1.0F16;\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+float64_t f64c = 1.0F32;\n+float64_t f64d = (float64_t) 1.0F32;\n+#endif\n+float64_t f64e = 1.0F64;\n+float64_t f64f = (float64_t) 1.0F64;\n+#ifdef __STDCPP_FLOAT128_T__\n+float64_t f64g = 1.0F128;\t\t// { dg-warning \"converting to 'std::float64_t' \\\\\\{aka '_Float64'\\\\\\} from '_Float128' with greater conversion rank\" \"\" { target { float64 && float128 } } }\n+float64_t f64h = (float64_t) 1.0F128;\n+#endif\n+#if __FLT_MAX_EXP__ <= __FLT64_MAX_EXP__ && __FLT_MANT_DIG__ <= __FLT64_MANT_DIG__\n+float64_t f64i = 1.0f;\n+#endif\n+float64_t f64j = (float64_t) 1.0f;\n+#if __DBL_MAX_EXP__ <= __FLT64_MAX_EXP__ && __DBL_MANT_DIG__ <= __FLT64_MANT_DIG__\n+float64_t f64k = 1.0;\n+#endif\n+float64_t f64l = (float64_t) 1.0;\n+float64_t f64n = (float64_t) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float64_t f64p = (float64_t) 1.0Q;\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+#ifdef __STDCPP_FLOAT16_T__\n+float128_t f128a = 1.0F16;\n+float128_t f128b = (float128_t) 1.0F16;\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+float128_t f128c = 1.0F32;\n+float128_t f128d = (float128_t) 1.0F32;\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+float128_t f128e = 1.0F64;\n+float128_t f128f = (float128_t) 1.0F64;\n+#endif\n+float128_t f128g = 1.0F128;\n+float128_t f128h = (float128_t) 1.0F128;\n+#if __FLT_MAX_EXP__ <= __FLT128_MAX_EXP__ && __FLT_MANT_DIG__ <= __FLT128_MANT_DIG__\n+float128_t f128i = 1.0f;\n+#endif\n+float128_t f128j = (float128_t) 1.0f;\n+#if __DBL_MAX_EXP__ <= __FLT128_MAX_EXP__ && __DBL_MANT_DIG__ <= __FLT128_MANT_DIG__\n+float128_t f128k = 1.0;\n+#endif\n+float128_t f128l = (float128_t) 1.0;\n+#if __LDBL_MAX_EXP__ <= __FLT128_MAX_EXP__ && __LDBL_MANT_DIG__ <= __FLT128_MANT_DIG__ && __LDBL_MANT_DIG__ != 106\n+float128_t f128m = 1.0L;\n+#endif\n+float128_t f128n = (float128_t) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float128_t f128o = 1.0Q;\n+float128_t f128p = (float128_t) 1.0Q;\n+#endif\n+#endif"}, {"sha": "ca9399fccd2a67341a61d57d79735060bc1fa52d", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating3.C", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating3.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,134 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// Variant of ext-floating2.C test with x86 specific assumptions\n+// about float, double, long double and existence of __float128.\n+// And some further tests.\n+// { dg-do compile { target { c++23 && { i?86-*-linux* x86_64-*-linux* } } } }\n+// { dg-options \"\" }\n+\n+#include \"ext-floating.h\"\n+\n+#if !defined(__STDCPP_FLOAT32_T__) \\\n+    || !defined(__STDCPP_FLOAT64_T__) || !defined(__STDCPP_FLOAT128_T__) \\\n+    || __FLT_MAX_EXP__ != __FLT32_MAX_EXP__ || __FLT_MANT_DIG__ != __FLT32_MANT_DIG__ \\\n+    || __DBL_MAX_EXP__ != __FLT64_MAX_EXP__ || __DBL_MANT_DIG__ != __FLT64_MANT_DIG__ \\\n+    || __LDBL_MAX_EXP__ != __FLT128_MAX_EXP__ || __LDBL_MANT_DIG__ >= __FLT128_MANT_DIG__ \\\n+    || !defined(__SIZEOF_FLOAT128__)\n+#error Unexpected set of floating point types\n+#endif\n+\n+using namespace std;\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+float16_t f16i = 1.0f;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'float' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16k = 1.0;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'double' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'long double' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16o = 1.0Q;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from '__float128' with greater conversion rank\" \"\" { target float16 } }\n+#endif\n+float32_t f32i = 1.0f;\n+float32_t f32k = 1.0;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from 'double' with greater conversion rank\" }\n+float32_t f32m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from 'long double' with greater conversion rank\" }\n+float32_t f32o = 1.0Q;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from '__float128' with greater conversion rank\" }\n+float64_t f64i = 1.0f;\n+float64_t f64k = 1.0;\n+float64_t f64m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float64_t' \\\\\\{aka '_Float64'\\\\\\} from 'long double' with greater conversion rank\" }\n+float64_t f64o = 1.0Q;\t\t\t// { dg-warning \"converting to 'std::float64_t' \\\\\\{aka '_Float64'\\\\\\} from '__float128' with greater conversion rank\" }\n+float128_t f128i = 1.0f;\n+float128_t f128k = 1.0;\n+float128_t f128m = 1.0L;\n+float128_t f128o = 1.0Q;\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+constexpr float16_t f16x = 1.0F16;\n+#endif\n+constexpr float32_t f32x = 2.0F32;\n+constexpr float64_t f64x = 3.0F64;\n+constexpr float128_t f128x = 4.0F128;\n+constexpr float fx = 5.0f;\n+constexpr double dx = 6.0;\n+constexpr long double ldx = 7.0L;\n+\n+constexpr int foo (float32_t) { return 1; }\n+constexpr int foo (float64_t) { return 2; }\n+constexpr int bar (float) { return 3; }\n+constexpr int bar (double) { return 4; }\n+constexpr int bar (long double) { return 5; }\n+constexpr int baz (float32_t) { return 6; }\n+constexpr int baz (float64_t) { return 7; }\n+constexpr int baz (float128_t) { return 8; }\n+constexpr int qux (float64_t) { return 9; }\n+constexpr int qux (float32_t) { return 10; }\n+constexpr int fred (long double) { return 11; }\n+constexpr int fred (double) { return 12; }\n+constexpr int fred (float) { return 13; }\n+constexpr int thud (float128_t) { return 14; }\n+constexpr int thud (float64_t) { return 15; }\n+constexpr int thud (float32_t) { return 16; }\n+struct S {\n+  constexpr operator float32_t () const { return 1.0f32; }\n+  constexpr operator float64_t () const { return 2.0f64; }\n+};\n+struct T {\n+  constexpr operator float64_t () const { return 3.0f64; }\n+  constexpr operator float32_t () const { return 4.0f32; }\n+};\n+\n+void\n+test (S s, T t)\n+{\n+#ifdef __STDCPP_FLOAT16_T__\n+  foo (float16_t (1.0));\t\t\t// { dg-error \"call of overloaded 'foo\\\\\\(std::float16_t\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (foo (float (2.0)) == 1);\n+  static_assert (foo (double (3.0)) == 2);\n+  constexpr double x (s);\n+  static_assert (x == 2.0);\n+#ifdef __STDCPP_FLOAT16_T__\n+  bar (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'bar\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (bar (f32x) == 3);\n+  static_assert (bar (f64x) == 4);\n+  bar (f128x);\t\t\t\t\t// { dg-error \"no matching function for call to 'bar\\\\\\(const std::float128_t\\\\\\&\\\\\\)'\" }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'float' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'double' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-2 }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'long double' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-3 }\n+  static_assert (bar (fx) == 3);\n+  static_assert (bar (dx) == 4);\n+  static_assert (bar (ldx) == 5);\n+#ifdef __STDCPP_FLOAT16_T__\n+  baz (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'baz\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (baz (f32x) == 6);\n+  static_assert (baz (f64x) == 7);\n+  static_assert (baz (f128x) == 8);\n+  static_assert (baz (fx) == 6);\n+  static_assert (baz (dx) == 7);\n+  static_assert (baz (ldx) == 8);\n+#ifdef __STDCPP_FLOAT16_T__\n+  qux (float16_t (1.0));\t\t\t// { dg-error \"call of overloaded 'qux\\\\\\(std::float16_t\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (qux (float (2.0)) == 10);\n+  static_assert (qux (double (3.0)) == 9);\n+  constexpr double y (t);\n+  static_assert (y == 3.0);\n+#ifdef __STDCPP_FLOAT16_T__\n+  fred (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'fred\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (fred (f32x) == 13);\n+  static_assert (fred (f64x) == 12);\n+  fred (f128x);\t\t\t\t\t// { dg-error \"no matching function for call to 'fred\\\\\\(const std::float128_t\\\\\\&\\\\\\)'\" }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'float' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'double' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-2 }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'long double' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-3 }\n+  static_assert (fred (fx) == 13);\n+  static_assert (fred (dx) == 12);\n+  static_assert (fred (ldx) == 11);\n+#ifdef __STDCPP_FLOAT16_T__\n+  thud (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'thud\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (thud (f32x) == 16);\n+  static_assert (thud (f64x) == 15);\n+  static_assert (thud (f128x) == 14);\n+  static_assert (thud (fx) == 16);\n+  static_assert (thud (dx) == 15);\n+  static_assert (thud (ldx) == 14);\n+}"}, {"sha": "1bac1051f44b5e225a1bd692d56672cb9c09832b", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating4.C", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating4.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,126 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// Variant of ext-floating3.C test with different specific assumptions\n+// about float, double, long double.\n+// float, double and long double are assumed to be IEEE 754 single, double\n+// and quad.\n+// { dg-do compile { target { c++23 && { aarch64*-*-* powerpc64le*-*-linux* riscv*-*-* s390*-*-* sparc*-*-linux* } } } }\n+// { dg-options \"\" }\n+// { dg-additional-options \"-mlong-double-128\" { target s390*-*-* sparc*-*-linux* } }\n+// { dg-additional-options \"-mvsx -mfloat128 -mlong-double-128 -mabi=ieeelongdouble -Wno-psabi\" { target powerpc64le*-*-linux* } }\n+\n+#include \"ext-floating.h\"\n+\n+#if !defined(__STDCPP_FLOAT32_T__) \\\n+    || !defined(__STDCPP_FLOAT64_T__) || !defined(__STDCPP_FLOAT128_T__) \\\n+    || __FLT_MAX_EXP__ != __FLT32_MAX_EXP__ || __FLT_MANT_DIG__ != __FLT32_MANT_DIG__ \\\n+    || __DBL_MAX_EXP__ != __FLT64_MAX_EXP__ || __DBL_MANT_DIG__ != __FLT64_MANT_DIG__ \\\n+    || __LDBL_MAX_EXP__ != __FLT128_MAX_EXP__ || __LDBL_MANT_DIG__ != __FLT128_MANT_DIG__\n+#error Unexpected set of floating point types\n+#endif\n+\n+using namespace std;\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+float16_t f16i = 1.0f;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'float' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16k = 1.0;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'double' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'long double' with greater conversion rank\" \"\" { target float16 } }\n+#endif\n+float32_t f32i = 1.0f;\n+float32_t f32k = 1.0;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from 'double' with greater conversion rank\" }\n+float32_t f32m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from 'long double' with greater conversion rank\" }\n+float64_t f64i = 1.0f;\n+float64_t f64k = 1.0;\n+float64_t f64m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float64_t' \\\\\\{aka '_Float64'\\\\\\} from 'long double' with greater conversion rank\" }\n+float128_t f128i = 1.0f;\n+float128_t f128k = 1.0;\n+float128_t f128m = 1.0L;\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+constexpr float16_t f16x = 1.0F16;\n+#endif\n+constexpr float32_t f32x = 2.0F32;\n+constexpr float64_t f64x = 3.0F64;\n+constexpr float128_t f128x = 4.0F128;\n+constexpr float fx = 5.0f;\n+constexpr double dx = 6.0;\n+constexpr long double ldx = 7.0L;\n+\n+constexpr int foo (float32_t) { return 1; }\n+constexpr int foo (float64_t) { return 2; }\n+constexpr int bar (float) { return 3; }\n+constexpr int bar (double) { return 4; }\n+constexpr int bar (long double) { return 5; }\n+constexpr int baz (float32_t) { return 6; }\n+constexpr int baz (float64_t) { return 7; }\n+constexpr int baz (float128_t) { return 8; }\n+constexpr int qux (float64_t) { return 9; }\n+constexpr int qux (float32_t) { return 10; }\n+constexpr int fred (long double) { return 11; }\n+constexpr int fred (double) { return 12; }\n+constexpr int fred (float) { return 13; }\n+constexpr int thud (float128_t) { return 14; }\n+constexpr int thud (float64_t) { return 15; }\n+constexpr int thud (float32_t) { return 16; }\n+struct S {\n+  constexpr operator float32_t () const { return 1.0f32; }\n+  constexpr operator float64_t () const { return 2.0f64; }\n+};\n+struct T {\n+  constexpr operator float64_t () const { return 3.0f64; }\n+  constexpr operator float32_t () const { return 4.0f32; }\n+};\n+\n+void\n+test (S s, T t)\n+{\n+#ifdef __STDCPP_FLOAT16_T__\n+  foo (float16_t (1.0));\t\t\t// { dg-error \"call of overloaded 'foo\\\\\\(std::float16_t\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (foo (float (2.0)) == 1);\n+  static_assert (foo (double (3.0)) == 2);\n+  constexpr double x (s);\n+  static_assert (x == 2.0);\n+#ifdef __STDCPP_FLOAT16_T__\n+  bar (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'bar\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (bar (f32x) == 3);\n+  static_assert (bar (f64x) == 4);\n+  static_assert (bar (f128x) == 5);\n+  static_assert (bar (fx) == 3);\n+  static_assert (bar (dx) == 4);\n+  static_assert (bar (ldx) == 5);\n+#ifdef __STDCPP_FLOAT16_T__\n+  baz (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'baz\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (baz (f32x) == 6);\n+  static_assert (baz (f64x) == 7);\n+  static_assert (baz (f128x) == 8);\n+  static_assert (baz (fx) == 6);\n+  static_assert (baz (dx) == 7);\n+  static_assert (baz (ldx) == 8);\n+#ifdef __STDCPP_FLOAT16_T__\n+  qux (float16_t (1.0));\t\t\t// { dg-error \"call of overloaded 'qux\\\\\\(std::float16_t\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (qux (float (2.0)) == 10);\n+  static_assert (qux (double (3.0)) == 9);\n+  constexpr double y (t);\n+  static_assert (y == 3.0);\n+#ifdef __STDCPP_FLOAT16_T__\n+  fred (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'fred\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (fred (f32x) == 13);\n+  static_assert (fred (f64x) == 12);\n+  static_assert (fred (f128x) == 11);\n+  static_assert (fred (fx) == 13);\n+  static_assert (fred (dx) == 12);\n+  static_assert (fred (ldx) == 11);\n+#ifdef __STDCPP_FLOAT16_T__\n+  thud (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'thud\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (thud (f32x) == 16);\n+  static_assert (thud (f64x) == 15);\n+  static_assert (thud (f128x) == 14);\n+  static_assert (thud (fx) == 16);\n+  static_assert (thud (dx) == 15);\n+  static_assert (thud (ldx) == 14);\n+}"}, {"sha": "7c8bf6a946bd158a2ab6bcbfce57f83784b8e797", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating5.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating5.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,13 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// IBM extended long double and _Float128 should have unordered conversion\n+// ranks as IBM extended long double has variable precision from 53 bits\n+// for denormals to more than 2150 bits for certain numbers.\n+// { dg-do compile { target { c++23 && { powerpc*-*-linux* } } } }\n+// { dg-require-effective-target ppc_float128_sw }\n+// { dg-options \"-mvsx -mfloat128 -mlong-double-128 -mabi=ibmlongdouble\" }\n+\n+auto a = 1.0F128 + 1.0L;\t// { dg-error \"invalid operands to binary \\\\\\+ \\\\\\(have '_Float128' and 'long double'\\\\\\)\" }\n+auto b = 1.0L + 1.0F128;\t// { dg-error \"invalid operands to binary \\\\\\+ \\\\\\(have 'long double' and '_Float128'\\\\\\)\" }\n+bool c;\n+auto d = c ? 1.0F128 : 1.0L;\t// { dg-error \"operands to '\\\\\\?:' of types '_Float128' and 'long double' have unordered conversion rank\" }\n+auto e = c ? 1.0L : 1.0F128;\t// { dg-error \"operands to '\\\\\\?:' of types 'long double' and '_Float128' have unordered conversion rank\" }"}, {"sha": "70272a1b3c140fb4a03e5a4fd7cb91a051605943", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating6.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating6.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,30 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"\" }\n+\n+#include \"ext-floating.h\"\n+\n+#ifdef __STRICT_ANSI__\n+#undef __SIZEOF_FLOAT128__\n+#endif\n+\n+using namespace std;\n+\n+float foo (float x, float y, float z) { return x * y + z; }\n+double foo (double x, double y, double z) { return x * y + z; }\n+long double foo (long double x, long double y, long double z) { return x * y + z; }\n+#ifdef __STDCPP_FLOAT16_T__\n+float16_t foo (float16_t x, float16_t y, float16_t z) { return x * y + z; }\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+float32_t foo (float32_t x, float32_t y, float32_t z) { return x * y + z; }\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+float64_t foo (float64_t x, float64_t y, float64_t z) { return x * y + z; }\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+float128_t foo (float128_t x, float128_t y, float128_t z) { return x * y + z; }\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+bfloat16_t foo (bfloat16_t x, bfloat16_t y, bfloat16_t z) { return x * y + z; }\n+#endif"}, {"sha": "5c30a5979b6b38d77672970af0dbe5b82d0f71a6", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating7.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating7.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,119 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do run { target { c++23 && float16_runtime } } }\n+// { dg-options \"\" }\n+// { dg-add-options float16 }\n+\n+#ifndef WIDTH\n+#ifndef __STDCPP_FLOAT16_T__\n+#error Unexpected\n+#endif\n+#define WIDTH 16\n+#endif\n+\n+#include <stdarg.h>\n+#include \"ext-floating.h\"\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define TYPE CONCAT (_Float, WIDTH)\n+#define CST(C) CONCAT3 (C, f, WIDTH)\n+#define CSTU(C) CONCAT3 (C, F, WIDTH)\n+\n+extern \"C\" void abort ();\n+\n+volatile TYPE a = CST (1.0), b = CSTU (2.5), c = -CST (2.5);\n+volatile TYPE a2 = CST (1.0), z = CST (0.0), nz = -CST (0.0);\n+\n+// These types are not subject to default argument promotions.\n+\n+TYPE\n+vafn (TYPE arg1, ...)\n+{\n+  va_list ap;\n+  TYPE ret;\n+  va_start (ap, arg1);\n+  ret = arg1 + va_arg (ap, TYPE);\n+  va_end (ap);\n+  return ret;\n+}\n+\n+TYPE\n+fn (TYPE arg)\n+{\n+  return arg / 4;\n+}\n+\n+int\n+main (void)\n+{\n+  volatile TYPE r;\n+  r = -b;\n+  if (r != c)\n+    abort ();\n+  r = a + b;\n+  if (r != CST (3.5))\n+    abort ();\n+  r = a - b;\n+  if (r != -CST (1.5))\n+    abort ();\n+  r = 2 * c;\n+  if (r != -5)\n+    abort ();\n+  r = b * c;\n+  if (r != -CST (6.25))\n+    abort ();\n+  r = b / (a + a);\n+  if (r != CST (1.25))\n+    abort ();\n+  r = c * 3;\n+  if (r != -CST (7.5))\n+    abort ();\n+  volatile int i = r;\n+  if (i != -7)\n+    abort ();\n+  r = vafn (a, c);\n+  if (r != -CST (1.5))\n+    abort ();\n+  r = fn (a);\n+  if (r != CST (0.25))\n+    abort ();\n+  if ((a < b) != 1)\n+    abort ();\n+  if ((b < a) != 0)\n+    abort ();\n+  if ((a < a2) != 0)\n+    abort ();\n+  if ((nz < z) != 0)\n+    abort ();\n+  if ((a <= b) != 1)\n+    abort ();\n+  if ((b <= a) != 0)\n+    abort ();\n+  if ((a <= a2) != 1)\n+    abort ();\n+  if ((nz <= z) != 1)\n+    abort ();\n+  if ((a > b) != 0)\n+    abort ();\n+  if ((b > a) != 1)\n+    abort ();\n+  if ((a > a2) != 0)\n+    abort ();\n+  if ((nz > z) != 0)\n+    abort ();\n+  if ((a >= b) != 0)\n+    abort ();\n+  if ((b >= a) != 1)\n+    abort ();\n+  if ((a >= a2) != 1)\n+    abort ();\n+  if ((nz >= z) != 1)\n+    abort ();\n+  i = (nz == z);\n+  if (i != 1)\n+    abort ();\n+  i = (a == b);\n+  if (i != 0)\n+    abort ();\n+}"}, {"sha": "afb74a3abad843a4f3f1248193e14b2f46cc0d78", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating8.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating8.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,13 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do run { target { c++23 && float32_runtime } } }\n+// { dg-options \"\" }\n+// { dg-add-options float32 }\n+\n+#ifndef WIDTH\n+#ifndef __STDCPP_FLOAT32_T__\n+#error Unexpected\n+#endif\n+#define WIDTH 32\n+#endif\n+\n+#include \"ext-floating7.C\""}, {"sha": "f0118da30ccbcbfd0150670e0ff586fd9d51cab1", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating9.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating9.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -0,0 +1,13 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do run { target { c++23 && float64_runtime } } }\n+// { dg-options \"\" }\n+// { dg-add-options float64 }\n+\n+#ifndef WIDTH\n+#ifndef __STDCPP_FLOAT64_T__\n+#error Unexpected\n+#endif\n+#define WIDTH 64\n+#endif\n+\n+#include \"ext-floating7.C\""}, {"sha": "f96b932b69842388ef3fd8e47d74340e0707da9f", "filename": "gcc/testsuite/g++.target/i386/float16-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Ffloat16-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Ffloat16-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Ffloat16-1.C?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -1,8 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -mno-sse2\" } */\n \n-_Float16/* { dg-error \"does not name a type\" } */\n+_Float16\t/* { dg-error \"expected unqualified-id before '_Float16'\" } */\n foo (_Float16 x) \n {\n   return x;\n-}\n+}\t\t/* { dg-error \"'_Float16' is not supported on this target\" } */"}, {"sha": "55807fe15c695468c09a96c04a6af42daa9014a7", "filename": "gcc/tree-core.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -690,6 +690,10 @@ enum tree_index {\n \t\t\t     - TI_FLOATN_NX_TYPE_FIRST\t\t\\\n \t\t\t     + 1)\n \n+  /* Type used by certain backends for __float128, which in C++ should be\n+     distinct type from _Float128 for backwards compatibility reasons.  */\n+  TI_FLOAT128T_TYPE,\n+\n   /* Put the complex types after their component types, so that in (sequential)\n      tree streaming we can assert that their component types have already been\n      handled (see tree-streamer.cc:record_common_node).  */"}, {"sha": "756c14ff0cc3fdaba30d9e5c70f54c6dd6e27786", "filename": "gcc/tree.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -9461,6 +9461,7 @@ build_common_tree_nodes (bool signed_char)\n       layout_type (FLOATN_NX_TYPE_NODE (i));\n       SET_TYPE_MODE (FLOATN_NX_TYPE_NODE (i), mode);\n     }\n+  float128t_type_node = float128_type_node;\n \n   float_ptr_type_node = build_pointer_type (float_type_node);\n   double_ptr_type_node = build_pointer_type (double_type_node);"}, {"sha": "95285e45fb7f2021ec2a3ee1d2068344bb5f0ce6", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -4302,6 +4302,10 @@ tree_strip_any_location_wrapper (tree exp)\n #define float64x_type_node\t\tglobal_trees[TI_FLOAT64X_TYPE]\n #define float128x_type_node\t\tglobal_trees[TI_FLOAT128X_TYPE]\n \n+/* Type used by certain backends for __float128, which in C++ should be\n+   distinct type from _Float128 for backwards compatibility reasons.  */\n+#define float128t_type_node\t\tglobal_trees[TI_FLOAT128T_TYPE]\n+\n #define float_ptr_type_node\t\tglobal_trees[TI_FLOAT_PTR_TYPE]\n #define double_ptr_type_node\t\tglobal_trees[TI_DOUBLE_PTR_TYPE]\n #define long_double_ptr_type_node\tglobal_trees[TI_LONG_DOUBLE_PTR_TYPE]"}, {"sha": "81d4353a86f27b28714f11bd47f307496782e652", "filename": "include/demangle.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -457,6 +457,11 @@ enum demangle_component_type\n   DEMANGLE_COMPONENT_MODULE_PARTITION,\n   DEMANGLE_COMPONENT_MODULE_ENTITY,\n   DEMANGLE_COMPONENT_MODULE_INIT,\n+\n+  /* A builtin type with argument.  This holds the builtin type\n+     information.  */\n+  DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE\n+\n };\n \n /* Types which are only used internally.  */\n@@ -543,6 +548,15 @@ struct demangle_component\n       const struct demangle_builtin_type_info *type;\n     } s_builtin;\n \n+    /* For DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE.  */\n+    struct\n+    {\n+      /* Builtin type.  */\n+      const struct demangle_builtin_type_info *type;\n+      short arg;\n+      char suffix;\n+    } s_extended_builtin;\n+\n     /* For DEMANGLE_COMPONENT_SUB_STD.  */\n     struct\n     {"}, {"sha": "1d680643ad883f6b9ffb9dc288626a4a95a4e40e", "filename": "libcpp/expr.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/libcpp%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/libcpp%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.cc?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -215,7 +215,6 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n \tcase 'f': case 'F':\n \t  f++;\n \t  if (len > 0\n-\t      && !CPP_OPTION (pfile, cplusplus)\n \t      && s[1] >= '1'\n \t      && s[1] <= '9'\n \t      && fn_bits == 0)"}, {"sha": "7ff225ec1aa584033eb624a25808cb09780c756b", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -648,6 +648,13 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n       printf (\"builtin type %s\\n\", dc->u.s_builtin.type->name);\n       return;\n+    case DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE:\n+      {\n+\tchar suffix[2] = { dc->u.s_extended_builtin.type->suffix, 0 };\n+\tprintf (\"builtin type %s%d%s\\n\", dc->u.s_extended_builtin.type->name,\n+\t\tdc->u.s_extended_builtin.type->arg, suffix);\n+      }\n+      return;\n     case DEMANGLE_COMPONENT_OPERATOR:\n       printf (\"operator %s\\n\", dc->u.s_operator.op->name);\n       return;\n@@ -771,11 +778,6 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n       printf (\"pointer to member type\\n\");\n       break;\n-    case DEMANGLE_COMPONENT_FIXED_TYPE:\n-      printf (\"fixed-point type, accum? %d, sat? %d\\n\",\n-              dc->u.s_fixed.accum, dc->u.s_fixed.sat);\n-      d_dump (dc->u.s_fixed.length, indent + 2);\n-      break;\n     case DEMANGLE_COMPONENT_ARGLIST:\n       printf (\"argument list\\n\");\n       break;\n@@ -1109,6 +1111,28 @@ d_make_builtin_type (struct d_info *di,\n   return p;\n }\n \n+/* Add a new extended builtin type component.  */\n+\n+static struct demangle_component *\n+d_make_extended_builtin_type (struct d_info *di,\n+\t\t\t      const struct demangle_builtin_type_info *type,\n+\t\t\t      short arg, char suffix)\n+{\n+  struct demangle_component *p;\n+\n+  if (type == NULL)\n+    return NULL;\n+  p = d_make_empty (di);\n+  if (p != NULL)\n+    {\n+      p->type = DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE;\n+      p->u.s_extended_builtin.type = type;\n+      p->u.s_extended_builtin.arg = arg;\n+      p->u.s_extended_builtin.suffix = suffix;\n+    }\n+  return p;\n+}\n+\n /* Add a new operator component.  */\n \n static struct demangle_component *\n@@ -2464,6 +2488,7 @@ cplus_demangle_builtin_types[D_BUILTIN_TYPE_COUNT] =\n   /* 32 */ { NL (\"char32_t\"),\tNL (\"char32_t\"),\tD_PRINT_DEFAULT },\n   /* 33 */ { NL (\"decltype(nullptr)\"),\tNL (\"decltype(nullptr)\"),\n \t     D_PRINT_DEFAULT },\n+  /* 34 */ { NL (\"_Float\"),\tNL (\"_Float\"),\t\tD_PRINT_FLOAT },\n };\n \n CP_STATIC_IF_GLIBCPP_V3\n@@ -2727,19 +2752,26 @@ cplus_demangle_type (struct d_info *di)\n \t  break;\n \n \tcase 'F':\n-\t  /* Fixed point types. DF<int bits><length><fract bits><sat>  */\n-\t  ret = d_make_empty (di);\n-\t  ret->type = DEMANGLE_COMPONENT_FIXED_TYPE;\n-\t  if ((ret->u.s_fixed.accum = IS_DIGIT (d_peek_char (di))))\n-\t    /* For demangling we don't care about the bits.  */\n-\t    d_number (di);\n-\t  ret->u.s_fixed.length = cplus_demangle_type (di);\n-\t  if (ret->u.s_fixed.length == NULL)\n-\t    return NULL;\n-\t  d_number (di);\n-\t  peek = d_next_char (di);\n-\t  ret->u.s_fixed.sat = (peek == 's');\n-\t  break;\n+\t  /* DF<number>_ - _Float<number>.\n+\t     DF<number>x - _Float<number>x.  */\n+\t  {\n+\t    int arg = d_number (di);\n+\t    char buf[12];\n+\t    char suffix = 0;\n+\t    if (d_peek_char (di) == 'x')\n+\t      suffix = 'x';\n+\t    if (!suffix && d_peek_char (di) != '_')\n+\t      return NULL;\n+\t    ret\n+\t      = d_make_extended_builtin_type (di,\n+\t\t\t\t\t      &cplus_demangle_builtin_types[34],\n+\t\t\t\t\t      arg, suffix);\n+\t    d_advance (di, 1);\n+\t    sprintf (buf, \"%d\", arg);\n+\t    di->expansion += ret->u.s_extended_builtin.type->len\n+\t\t\t     + strlen (buf) + (suffix != 0);\n+\t    break;\n+\t  }\n \n \tcase 'v':\n \t  ret = d_vector_type (di);\n@@ -4202,6 +4234,7 @@ d_count_templates_scopes (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n     case DEMANGLE_COMPONENT_SUB_STD:\n     case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n+    case DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE:\n     case DEMANGLE_COMPONENT_OPERATOR:\n     case DEMANGLE_COMPONENT_CHARACTER:\n     case DEMANGLE_COMPONENT_NUMBER:\n@@ -4210,6 +4243,7 @@ d_count_templates_scopes (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_MODULE_NAME:\n     case DEMANGLE_COMPONENT_MODULE_PARTITION:\n     case DEMANGLE_COMPONENT_MODULE_INIT:\n+    case DEMANGLE_COMPONENT_FIXED_TYPE:\n       break;\n \n     case DEMANGLE_COMPONENT_TEMPLATE:\n@@ -4309,10 +4343,6 @@ d_count_templates_scopes (struct d_print_info *dpi,\n       d_count_templates_scopes (dpi, dc->u.s_extended_operator.name);\n       break;\n \n-    case DEMANGLE_COMPONENT_FIXED_TYPE:\n-      d_count_templates_scopes (dpi, dc->u.s_fixed.length);\n-      break;\n-\n     case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n     case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n     case DEMANGLE_COMPONENT_MODULE_ENTITY:\n@@ -4580,11 +4610,11 @@ d_find_pack (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_TAGGED_NAME:\n     case DEMANGLE_COMPONENT_OPERATOR:\n     case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n+    case DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE:\n     case DEMANGLE_COMPONENT_SUB_STD:\n     case DEMANGLE_COMPONENT_CHARACTER:\n     case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n     case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n-    case DEMANGLE_COMPONENT_FIXED_TYPE:\n     case DEMANGLE_COMPONENT_DEFAULT_ARG:\n     case DEMANGLE_COMPONENT_NUMBER:\n       return NULL;\n@@ -5387,6 +5417,14 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t\t\t dc->u.s_builtin.type->java_len);\n       return;\n \n+    case DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE:\n+      d_append_buffer (dpi, dc->u.s_extended_builtin.type->name,\n+\t\t       dc->u.s_extended_builtin.type->len);\n+      d_append_num (dpi, dc->u.s_extended_builtin.arg);\n+      if (dc->u.s_extended_builtin.suffix)\n+\td_append_buffer (dpi, &dc->u.s_extended_builtin.suffix, 1);\n+      return;\n+\n     case DEMANGLE_COMPONENT_VENDOR_TYPE:\n       d_print_comp (dpi, options, d_left (dc));\n       return;\n@@ -5525,22 +5563,6 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \treturn;\n       }\n \n-    case DEMANGLE_COMPONENT_FIXED_TYPE:\n-      if (dc->u.s_fixed.sat)\n-\td_append_string (dpi, \"_Sat \");\n-      /* Don't print \"int _Accum\".  */\n-      if (dc->u.s_fixed.length->u.s_builtin.type\n-\t  != &cplus_demangle_builtin_types['i'-'a'])\n-\t{\n-\t  d_print_comp (dpi, options, dc->u.s_fixed.length);\n-\t  d_append_char (dpi, ' ');\n-\t}\n-      if (dc->u.s_fixed.accum)\n-\td_append_string (dpi, \"_Accum\");\n-      else\n-\td_append_string (dpi, \"_Fract\");\n-      return;\n-\n     case DEMANGLE_COMPONENT_ARGLIST:\n     case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n       if (d_left (dc) != NULL)"}, {"sha": "c5d046b3f01711b65aca2b7a9917f365ba97c5cd", "filename": "libiberty/cp-demangle.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -180,7 +180,7 @@ d_advance (struct d_info *di, int i)\n extern const struct demangle_operator_info cplus_demangle_operators[];\n #endif\n \n-#define D_BUILTIN_TYPE_COUNT (34)\n+#define D_BUILTIN_TYPE_COUNT (35)\n \n CP_STATIC_IF_GLIBCPP_V3\n const struct demangle_builtin_type_info"}, {"sha": "8fad6893ae7618cda26c3a783767ec62112b4d9f", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b04208895fed34171eac6bafb60c90048eb1cb0c/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b04208895fed34171eac6bafb60c90048eb1cb0c/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=b04208895fed34171eac6bafb60c90048eb1cb0c", "patch": "@@ -1242,8 +1242,12 @@ _ZNSt9_Any_data9_M_accessIPZ4postISt8functionIFvvEEEvOT_EUlvE_EERS5_v\n post<std::function<void ()> >(std::function<void ()>&&)::{lambda()#1}*& std::_Any_data::_M_access<post<std::function<void ()> >(post<std::function<void ()> >(std::function<void ()>&&)::{lambda()#1}*&&)::{lambda()#1}*>()\n #\n --format=auto --no-params\n-_Z3xxxDFyuVb\n-xxx(unsigned long long _Fract, bool volatile)\n+_Z3xxxDF16_DF32_DF64_DF128_CDF16_Vb\n+xxx(_Float16, _Float32, _Float64, _Float128, _Float16 _Complex, bool volatile)\n+xxx\n+--format=auto --no-params\n+_Z3xxxDF32xDF64xDF128xCDF32xVb\n+xxx(_Float32x, _Float64x, _Float128x, _Float32x _Complex, bool volatile)\n xxx\n # https://sourceware.org/bugzilla/show_bug.cgi?id=16817\n --format=auto --no-params"}]}