{"sha": "ccc98036025e03d21bad2938785f2378ecb7136c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NjOTgwMzYwMjVlMDNkMjFiYWQyOTM4Nzg1ZjIzNzhlY2I3MTM2Yw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-05T03:31:42Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-05T03:31:42Z"}, "message": "(store_field): Test STRICT_ALIGNMENT at run time.\n\n(expand_expr, COMPONENT_REF case): Fetch unaligned field as bitfield.\n\nFrom-SVN: r4841", "tree": {"sha": "f036be7e948b9cefafd35100d2f1ecb5612be9da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f036be7e948b9cefafd35100d2f1ecb5612be9da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccc98036025e03d21bad2938785f2378ecb7136c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc98036025e03d21bad2938785f2378ecb7136c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccc98036025e03d21bad2938785f2378ecb7136c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc98036025e03d21bad2938785f2378ecb7136c/comments", "author": null, "committer": null, "parents": [{"sha": "06c94bceebd6f69c22f919c6b6e3673714dfb2f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c94bceebd6f69c22f919c6b6e3673714dfb2f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c94bceebd6f69c22f919c6b6e3673714dfb2f5"}], "stats": {"total": 31, "additions": 17, "deletions": 14}, "files": [{"sha": "4c6e84a6455483edd2b355d4459ed43e560db3b1", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccc98036025e03d21bad2938785f2378ecb7136c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccc98036025e03d21bad2938785f2378ecb7136c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ccc98036025e03d21bad2938785f2378ecb7136c", "patch": "@@ -2702,13 +2702,11 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n       || (mode != BLKmode && ! direct_store[(int) mode])\n       || GET_CODE (target) == REG\n       || GET_CODE (target) == SUBREG\n-      /* If the field isn't aligned enough to fetch as a unit,\n-\t fetch it as a bit field.  */\n-#ifdef STRICT_ALIGNMENT\n-      || align * BITS_PER_UNIT < GET_MODE_ALIGNMENT (mode)\n-      || bitpos % GET_MODE_ALIGNMENT (mode) != 0\n-#endif\n-      )\n+      /* If the field isn't aligned enough to store as an ordinary memref,\n+\t store it as a bit field.  */\n+      || (STRICT_ALIGNMENT\n+\t  && align * BITS_PER_UNIT < GET_MODE_ALIGNMENT (mode))\n+      || (STRICT_ALIGNMENT && bitpos % GET_MODE_ALIGNMENT (mode) != 0))\n     {\n       rtx temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n       /* Store the value in the bitfield.  */\n@@ -3970,18 +3968,23 @@ expand_expr (exp, target, tmode, modifier)\n \t    MEM_VOLATILE_P (op0) = 1;\n \t  }\n \n+\t/* In cases where an aligned union has an unaligned object\n+\t   as a field, we might be extracting a BLKmode value from\n+\t   an integer-mode (e.g., SImode) object.  Handle this case\n+\t   by doing the extract into an object as wide as the field\n+\t   (which we know to be the width of a basic mode), then\n+\t   storing into memory, and changing the mode to BLKmode.  */\n \tif (mode1 == VOIDmode\n \t    || (mode1 != BLKmode && ! direct_load[(int) mode1]\n \t\t&& modifier != EXPAND_CONST_ADDRESS\n \t\t&& modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n-\t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+\t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n+\t    /* If the field isn't aligned enough to fetch as a memref,\n+\t       fetch it as a bit field.  */\n+\t    || (STRICT_ALIGNMENT\n+\t\t&& TYPE_ALIGN (TREE_TYPE (tem)) < GET_MODE_ALIGNMENT (mode))\n+\t    || (STRICT_ALIGNMENT && bitpos % GET_MODE_ALIGNMENT (mode) != 0))\n \t  {\n-\t    /* In cases where an aligned union has an unaligned object\n-\t       as a field, we might be extracting a BLKmode value from\n-\t       an integer-mode (e.g., SImode) object.  Handle this case\n-\t       by doing the extract into an object as wide as the field\n-\t       (which we know to be the width of a basic mode), then\n-\t       storing into memory, and changing the mode to BLKmode.  */\n \t    enum machine_mode ext_mode = mode;\n \n \t    if (ext_mode == BLKmode)"}]}