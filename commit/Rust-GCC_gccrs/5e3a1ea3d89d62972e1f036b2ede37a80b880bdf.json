{"sha": "5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUzYTFlYTNkODlkNjI5NzJlMWYwMzZiMmVkZTM3YTgwYjg4MGJkZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-05-11T14:01:01Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-05-11T15:11:01Z"}, "message": "libstdc++: Fix missing members in std::allocator<void>\n\nThe changes in 75c6a925dab5b7af9ab47c10906cb0e140261cc2 were slightly\nincorrect, because the converting constructor should be noexcept, and\nthe POCMA and is_always_equal traits should still be present in C++20.\nThis fixes it, and slightly refactors the preprocessor conditions and\norder of members. Also add comments explaining things.\n\nThe non-standard construct and destroy members added for PR 78052 can be\nprivate if allocator_traits<allocator<void>> is made a friend.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/allocator.h (allocator<void>) [C++20]: Add\n\tmissing noexcept to constructor. Restore missing POCMA and\n\tis_always_equal_traits.\n\t[C++17]: Make construct and destroy members private and\n\tdeclare allocator_traits as a friend.\n\t* include/bits/memoryfwd.h (allocator_traits): Declare.\n\t* include/ext/malloc_allocator.h (malloc_allocator::allocate):\n\tAdd nodiscard attribute. Add static assertion for LWG 3307.\n\t* include/ext/new_allocator.h (new_allocator::allocate): Add\n\tstatic assertion for LWG 3307.\n\t* testsuite/20_util/allocator/void.cc: Check that converting\n\tconstructor is noexcept. Check for propagation traits and\n\tsize_type and difference_type. Check that pointer and\n\tconst_pointer are gone in C++20.", "tree": {"sha": "6bc92821a27ae889dcd16099d5dea1cdf9c856ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bc92821a27ae889dcd16099d5dea1cdf9c856ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ea40269a77a3754dd0f610f7c09b1a372e3c7f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea40269a77a3754dd0f610f7c09b1a372e3c7f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ea40269a77a3754dd0f610f7c09b1a372e3c7f7"}], "stats": {"total": 107, "additions": 88, "deletions": 19}, "files": [{"sha": "73d5d7a25be1c740b36c3b2d48320a1588edff26", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "patch": "@@ -60,6 +60,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @{\n    */\n \n+  // Since C++20 the primary template should be used for allocator<void>,\n+  // but then it would have a non-trivial default ctor and dtor, which\n+  // would be an ABI change. So C++20 still uses the allocator<void> explicit\n+  // specialization, with the historical ABI properties, but with the same\n+  // members that are present in the primary template.\n+\n+#if ! _GLIBCXX_INLINE_VERSION\n   /// allocator<void> specialization.\n   template<>\n     class allocator<void>\n@@ -68,28 +75,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef void        value_type;\n       typedef size_t      size_type;\n       typedef ptrdiff_t   difference_type;\n+\n #if __cplusplus <= 201703L\n+      // These were removed for C++20.\n       typedef void*       pointer;\n       typedef const void* const_pointer;\n \n       template<typename _Tp1>\n \tstruct rebind\n \t{ typedef allocator<_Tp1> other; };\n-#else\n-      allocator() = default;\n-\n-      template<typename _Up>\n-\tconstexpr\n-\tallocator(const allocator<_Up>&) { }\n-#endif // ! C++20\n+#endif\n \n-#if __cplusplus >= 201103L && __cplusplus <= 201703L\n+#if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 2103. std::allocator propagate_on_container_move_assignment\n       typedef true_type propagate_on_container_move_assignment;\n \n       typedef true_type is_always_equal;\n \n+#if __cplusplus >= 202002L\n+      allocator() = default;\n+\n+      template<typename _Up>\n+\tconstexpr\n+\tallocator(const allocator<_Up>&) noexcept { }\n+\n+      // No allocate member because it's ill-formed by LWG 3307.\n+      // No deallocate member because it would be undefined to call it\n+      // with any pointer which wasn't obtained from allocate.\n+\n+#else // ! C++20\n+    private:\n+      // This uses construct and destroy in C++11/14/17 modes.\n+      friend allocator_traits<allocator<void>>;\n+\n       template<typename _Up, typename... _Args>\n \tvoid\n \tconstruct(_Up* __p, _Args&&... __args)\n@@ -101,11 +120,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tdestroy(_Up* __p)\n \tnoexcept(std::is_nothrow_destructible<_Up>::value)\n \t{ __p->~_Up(); }\n-#endif // C++11 to C++17\n+#endif // C++17\n+#endif // C++11\n+\n     };\n+#endif // ! _GLIBCXX_INLINE_VERSION\n \n   /**\n-   * @brief  The @a standard allocator, as per [20.4].\n+   * @brief  The @a standard allocator, as per C++03 [20.4.1].\n    *\n    *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator\n    *  for further details.\n@@ -119,7 +141,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Tp        value_type;\n       typedef size_t     size_type;\n       typedef ptrdiff_t  difference_type;\n+\n #if __cplusplus <= 201703L\n+      // These were removed for C++20.\n       typedef _Tp*       pointer;\n       typedef const _Tp* const_pointer;\n       typedef _Tp&       reference;"}, {"sha": "b0f0307eb7b945fbb776a66d4c1633c4e0dc9e8a", "filename": "libstdc++-v3/include/bits/memoryfwd.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmemoryfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmemoryfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmemoryfwd.h?ref=5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "patch": "@@ -63,15 +63,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename>\n     class allocator;\n \n-#if __cplusplus <= 201703L\n   template<>\n     class allocator<void>;\n-#endif\n \n #if __cplusplus >= 201103L\n-  /// Declare uses_allocator so it can be specialized in \\<queue\\> etc.\n+  /// Declare uses_allocator so it can be specialized in `<queue>` etc.\n   template<typename, typename>\n     struct uses_allocator;\n+\n+  template<typename>\n+    struct allocator_traits;\n #endif\n \n   /// @} group memory"}, {"sha": "1e90b179f5317ce179c1c54b6bd6c780a08a6e71", "filename": "libstdc++-v3/include/ext/malloc_allocator.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h?ref=5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "patch": "@@ -99,9 +99,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // NB: __n is permitted to be 0.  The C++ standard says nothing\n       // about what the return value is when __n == 0.\n-      _Tp*\n+      _GLIBCXX_NODISCARD _Tp*\n       allocate(size_type __n, const void* = 0)\n       {\n+#if __cplusplus >= 201103L\n+\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t // 3308. std::allocator<void>().allocate(n)\n+\t static_assert(sizeof(_Tp) != 0, \"cannot allocate incomplete types\");\n+#endif\n+\n \tif (__builtin_expect(__n > this->_M_max_size(), false))\n \t  {\n \t    // _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "3fb893be1523da3c166d37151cecb54d87b1d256", "filename": "libstdc++-v3/include/ext/new_allocator.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h?ref=5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "patch": "@@ -42,7 +42,7 @@ namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /**\n-   *  @brief  An allocator that uses global new, as per [20.4].\n+   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].\n    *  @ingroup allocators\n    *\n    *  This is precisely the allocator defined in the C++ Standard.\n@@ -102,6 +102,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _GLIBCXX_NODISCARD _Tp*\n       allocate(size_type __n, const void* = static_cast<const void*>(0))\n       {\n+#if __cplusplus >= 201103L\n+\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t // 3308. std::allocator<void>().allocate(n)\n+\t static_assert(sizeof(_Tp) != 0, \"cannot allocate incomplete types\");\n+#endif\n+\n \tif (__builtin_expect(__n > this->_M_max_size(), false))\n \t  {\n \t    // _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "e3d024d525b838fe93fb364d0fbdf8186a11d1b3", "filename": "libstdc++-v3/testsuite/20_util/allocator/void.cc", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2Fvoid.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3a1ea3d89d62972e1f036b2ede37a80b880bdf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2Fvoid.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2Fvoid.cc?ref=5e3a1ea3d89d62972e1f036b2ede37a80b880bdf", "patch": "@@ -33,6 +33,18 @@ test01()\n   std::allocator_traits<alloc_type>::destroy(a, &i);\n }\n \n+static_assert( std::allocator<void>::propagate_on_container_move_assignment(),\n+\t       \"POCMA trait should always be present\" );\n+static_assert( std::allocator<void>::is_always_equal(),\n+\t       \"is_always_equal trait should always be present\" );\n+\n+static_assert(\n+    std::is_same<std::allocator<void>::size_type, std::size_t>(),\n+    \"size_type is size_t\" );\n+static_assert(\n+    std::is_same<std::allocator<void>::difference_type, std::ptrdiff_t>(),\n+    \"size_type is size_t\" );\n+\n // These properties are formally unspecified, but have always been true for\n // the libstdc++ definition of allocator<void>.\n static_assert(\n@@ -48,12 +60,32 @@ static_assert(\n     std::is_trivially_destructible<std::allocator<void>>::value,\n     \"explicit specialization has trivial destructor\");\n \n-#if __cplusplus > 201703L\n+#if __cplusplus >= 202002L\n // C++20 removes the allocator<void> explicit specialization, so it can now be\n // constructed using the converting constructor from other specializations.\n-static_assert( std::is_constructible_v<std::allocator<void>,\n-\t\t\t\t       std::allocator<int>> );\n-#endif\n+static_assert( std::is_nothrow_constructible_v<std::allocator<void>,\n+\t\t\t\t\t       std::allocator<int>> );\n+\n+template<typename T>\n+concept has_pointer = requires { typename T::pointer; };\n+template<typename T>\n+concept has_const_pointer = requires { typename T::const_pointer; };\n+template<typename T>\n+concept has_size_type = requires { typename T::size_type; };\n+template<typename T>\n+concept has_difference_type = requires { typename T::difference_type; };\n+\n+// These were removed for C++20\n+static_assert( ! has_pointer<std::allocator<void>> );\n+static_assert( ! has_const_pointer<std::allocator<void>> );\n+\n+#else\n+static_assert(\n+    std::is_same<std::allocator<void>::pointer, void*>(),\n+    \"pointer is void*\" );\n+static_assert( std::is_same<std::allocator<void>::const_pointer, const void*>(),\n+    \"const_pointer is const void*\" );\n+#endif // C++20\n \n int\n main()"}]}