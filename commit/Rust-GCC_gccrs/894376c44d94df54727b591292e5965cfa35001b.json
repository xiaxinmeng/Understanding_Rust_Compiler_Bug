{"sha": "894376c44d94df54727b591292e5965cfa35001b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0Mzc2YzQ0ZDk0ZGY1NDcyN2I1OTEyOTJlNTk2NWNmYTM1MDAxYg==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-12-08T21:34:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-28T09:38:15Z"}, "message": "[Ada] Simplify data structures for overloaded interpretations\n\ngcc/ada/\n\n\t* sem_type.ads (Write_Interp_Ref): Removed; no longer needed.\n\t* sem_type.adb (Headers): Removed; now the hash table is\n\tdirectly in the Interp_Map alone.\n\t(Interp_Map): Now an instance of the GNAT.HTable.Simple_HTable.\n\t(Last_Overloaded): New variable to emulate Interp_Map.Last.\n\t(Add_One_Interp): Adapt to new data structure.\n\t(Get_First_Interp): Likewise.\n\t(Hash): Likewise.\n\t(Init_Interp_Tables): Likewise.\n\t(New_Interps): Likewise.\n\t(Save_Interps): Likewise; handle O_N variable like in\n\tGet_First_Interp.\n\t(Write_Interp_Ref): Removed; no longer needed.", "tree": {"sha": "64b3ff2d954d1e1eb24e876bd6d86cf3df2fde9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64b3ff2d954d1e1eb24e876bd6d86cf3df2fde9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/894376c44d94df54727b591292e5965cfa35001b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894376c44d94df54727b591292e5965cfa35001b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894376c44d94df54727b591292e5965cfa35001b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894376c44d94df54727b591292e5965cfa35001b/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f358e5c17720c744e227da0c121c1ae168e5c533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f358e5c17720c744e227da0c121c1ae168e5c533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f358e5c17720c744e227da0c121c1ae168e5c533"}], "stats": {"total": 171, "additions": 50, "deletions": 121}, "files": [{"sha": "8c12b08b093b26a3b10a0abc97a544e90451ebff", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 50, "deletions": 117, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894376c44d94df54727b591292e5965cfa35001b/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894376c44d94df54727b591292e5965cfa35001b/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=894376c44d94df54727b591292e5965cfa35001b", "patch": "@@ -50,6 +50,8 @@ with Table;\n with Treepr;   use Treepr;\n with Uintp;    use Uintp;\n \n+with GNAT.HTable; use GNAT.HTable;\n+\n package body Sem_Type is\n \n    ---------------------\n@@ -60,21 +62,17 @@ package body Sem_Type is\n    --  their interpretations. An overloaded node has an entry in Interp_Map,\n    --  which in turn contains a pointer into the All_Interp array. The\n    --  interpretations of a given node are contiguous in All_Interp. Each set\n-   --  of interpretations is terminated with the marker No_Interp. In order to\n-   --  speed up the retrieval of the interpretations of an overloaded node, the\n-   --  Interp_Map table is accessed by means of a simple hashing scheme, and\n-   --  the entries in Interp_Map are chained. The heads of clash lists are\n-   --  stored in array Headers.\n-\n-   --              Headers        Interp_Map          All_Interp\n-\n-   --                 _            +-----+             +--------+\n-   --                |_|           |_____|         --->|interp1 |\n-   --                |_|---------->|node |         |   |interp2 |\n-   --                |_|           |index|---------|   |nointerp|\n-   --                |_|           |next |             |        |\n-   --                              |-----|             |        |\n-   --                              +-----+             +--------+\n+   --  of interpretations is terminated with the marker No_Interp.\n+\n+   --     Interp_Map           All_Interp\n+\n+   --      +-----+             +--------+\n+   --      |     |         --->|interp1 |\n+   --      |_____|         |   |interp2 |\n+   --      |index|---------|   |nointerp|\n+   --      |-----|             |        |\n+   --      |     |             |        |\n+   --      +-----+             +--------+\n \n    --  This scheme does not currently reclaim interpretations. In principle,\n    --  after a unit is compiled, all overloadings have been resolved, and the\n@@ -89,28 +87,26 @@ package body Sem_Type is\n      Table_Increment      => Alloc.All_Interp_Increment,\n      Table_Name           => \"All_Interp\");\n \n-   type Interp_Ref is record\n-      Node  : Node_Id;\n-      Index : Interp_Index;\n-      Next  : Int;\n-   end record;\n-\n-   Header_Size : constant Int := 2 ** 12;\n-   No_Entry    : constant Int := -1;\n-   Headers     : array (0 .. Header_Size) of Int;\n+   Header_Max : constant := 3079;\n+   --  The number of hash buckets; an arbitrary prime number\n \n-   package Interp_Map is new Table.Table (\n-     Table_Component_Type => Interp_Ref,\n-     Table_Index_Type     => Int,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => Alloc.Interp_Map_Initial,\n-     Table_Increment      => Alloc.Interp_Map_Increment,\n-     Table_Name           => \"Interp_Map\");\n+   subtype Header_Num is Integer range 0 .. Header_Max - 1;\n \n-   function Hash (N : Node_Id) return Int;\n+   function Hash (N : Node_Id) return Header_Num;\n    --  A trivial hashing function for nodes, used to insert an overloaded\n    --  node into the Interp_Map table.\n \n+   package Interp_Map is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Interp_Index,\n+      No_Element => -1,\n+      Key        => Node_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+\n+   Last_Overloaded : Node_Id := Empty;\n+   --  Overloaded node after initializing a new collection of intepretation\n+\n    -------------------------------------\n    -- Handling of Overload Resolution --\n    -------------------------------------\n@@ -479,9 +475,9 @@ package body Sem_Type is\n       --  node or the interpretation that is present is for a different\n       --  node. In both cases add a new interpretation to the table.\n \n-      elsif Interp_Map.Last < 0\n+      elsif No (Last_Overloaded)\n         or else\n-          (Interp_Map.Table (Interp_Map.Last).Node /= N\n+          (Last_Overloaded /= N\n             and then not Is_Overloaded (N))\n       then\n          New_Interps (N);\n@@ -2380,7 +2376,6 @@ package body Sem_Type is\n       It : out Interp)\n    is\n       Int_Ind : Interp_Index;\n-      Map_Ptr : Int;\n       O_N     : Node_Id;\n \n    begin\n@@ -2398,21 +2393,16 @@ package body Sem_Type is\n          O_N := N;\n       end if;\n \n-      Map_Ptr := Headers (Hash (O_N));\n-      while Map_Ptr /= No_Entry loop\n-         if Interp_Map.Table (Map_Ptr).Node = O_N then\n-            Int_Ind := Interp_Map.Table (Map_Ptr).Index;\n-            It := All_Interp.Table (Int_Ind);\n-            I := Int_Ind;\n-            return;\n-         else\n-            Map_Ptr := Interp_Map.Table (Map_Ptr).Next;\n-         end if;\n-      end loop;\n+      Int_Ind := Interp_Map.Get (O_N);\n \n       --  Procedure should never be called if the node has no interpretations\n \n-      raise Program_Error;\n+      if Int_Ind < 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      I  := Int_Ind;\n+      It := All_Interp.Table (Int_Ind);\n    end Get_First_Interp;\n \n    ---------------------\n@@ -2545,12 +2535,9 @@ package body Sem_Type is\n    -- Hash --\n    ----------\n \n-   function Hash (N : Node_Id) return Int is\n+   function Hash (N : Node_Id) return Header_Num is\n    begin\n-      --  Nodes have a size that is power of two, so to select significant\n-      --  bits only we remove the low-order bits.\n-\n-      return ((Int (N) / 2 ** 5) mod Header_Size);\n+      return Header_Num (N mod Header_Max);\n    end Hash;\n \n    --------------\n@@ -2575,8 +2562,7 @@ package body Sem_Type is\n    procedure Init_Interp_Tables is\n    begin\n       All_Interp.Init;\n-      Interp_Map.Init;\n-      Headers := (others => No_Entry);\n+      Interp_Map.Reset;\n    end Init_Interp_Tables;\n \n    -----------------------------------\n@@ -3094,47 +3080,12 @@ package body Sem_Type is\n    -----------------\n \n    procedure New_Interps (N : Node_Id) is\n-      Map_Ptr : Int;\n-\n    begin\n       All_Interp.Append (No_Interp);\n \n-      Map_Ptr := Headers (Hash (N));\n-\n-      if Map_Ptr = No_Entry then\n-\n-         --  Place new node at end of table\n-\n-         Interp_Map.Increment_Last;\n-         Headers (Hash (N)) := Interp_Map.Last;\n-\n-      else\n-         --   Place node at end of chain, or locate its previous entry\n-\n-         loop\n-            if Interp_Map.Table (Map_Ptr).Node = N then\n-\n-               --  Node is already in the table, and is being rewritten.\n-               --  Start a new interp section, retain hash link.\n-\n-               Interp_Map.Table (Map_Ptr).Node  := N;\n-               Interp_Map.Table (Map_Ptr).Index := All_Interp.Last;\n-               Set_Is_Overloaded (N, True);\n-               return;\n-\n-            else\n-               exit when Interp_Map.Table (Map_Ptr).Next = No_Entry;\n-               Map_Ptr := Interp_Map.Table (Map_Ptr).Next;\n-            end if;\n-         end loop;\n-\n-         --  Chain the new node\n-\n-         Interp_Map.Increment_Last;\n-         Interp_Map.Table (Map_Ptr).Next := Interp_Map.Last;\n-      end if;\n-\n-      Interp_Map.Table (Interp_Map.Last) := (N, All_Interp.Last, No_Entry);\n+      --  Add or rewrite the existing node\n+      Last_Overloaded := N;\n+      Interp_Map.Set (N, All_Interp.Last);\n       Set_Is_Overloaded (N, True);\n    end New_Interps;\n \n@@ -3319,8 +3270,8 @@ package body Sem_Type is\n    ------------------\n \n    procedure Save_Interps (Old_N : Node_Id; New_N : Node_Id) is\n-      Map_Ptr : Int;\n-      O_N     : Node_Id := Old_N;\n+      Old_Ind : Interp_Index;\n+      O_N     : Node_Id;\n \n    begin\n       if Is_Overloaded (Old_N) then\n@@ -3330,18 +3281,15 @@ package body Sem_Type is\n            and then Is_Overloaded (Selector_Name (Old_N))\n          then\n             O_N := Selector_Name (Old_N);\n+         else\n+            O_N := Old_N;\n          end if;\n \n-         Map_Ptr := Headers (Hash (O_N));\n-\n-         while Interp_Map.Table (Map_Ptr).Node /= O_N loop\n-            Map_Ptr := Interp_Map.Table (Map_Ptr).Next;\n-            pragma Assert (Map_Ptr /= No_Entry);\n-         end loop;\n+         Old_Ind := Interp_Map.Get (O_N);\n+         pragma Assert (Old_Ind >= 0);\n \n          New_Interps (New_N);\n-         Interp_Map.Table (Interp_Map.Last).Index :=\n-           Interp_Map.Table (Map_Ptr).Index;\n+         Interp_Map.Set (New_N, Old_Ind);\n       end if;\n    end Save_Interps;\n \n@@ -3646,21 +3594,6 @@ package body Sem_Type is\n       Print_Tree_Node (It.Abstract_Op);\n    end Write_Interp;\n \n-   ----------------------\n-   -- Write_Interp_Ref --\n-   ----------------------\n-\n-   procedure Write_Interp_Ref (Map_Ptr : Int) is\n-   begin\n-      Write_Str (\" Node:  \");\n-      Write_Int (Int (Interp_Map.Table (Map_Ptr).Node));\n-      Write_Str (\" Index: \");\n-      Write_Int (Int (Interp_Map.Table (Map_Ptr).Index));\n-      Write_Str (\" Next:  \");\n-      Write_Int (Interp_Map.Table (Map_Ptr).Next);\n-      Write_Eol;\n-   end Write_Interp_Ref;\n-\n    ---------------------\n    -- Write_Overloads --\n    ---------------------"}, {"sha": "a9c1ba29cc6666ae3e6563c352af68460f90ad52", "filename": "gcc/ada/sem_type.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894376c44d94df54727b591292e5965cfa35001b/gcc%2Fada%2Fsem_type.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894376c44d94df54727b591292e5965cfa35001b/gcc%2Fada%2Fsem_type.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.ads?ref=894376c44d94df54727b591292e5965cfa35001b", "patch": "@@ -268,10 +268,6 @@ package Sem_Type is\n    procedure Write_Interp (It : Interp);\n    --  Debugging procedure to display an Interp\n \n-   procedure Write_Interp_Ref (Map_Ptr : Int);\n-   --  Debugging procedure to display entry in Interp_Map. Would not be needed\n-   --  if it were possible to debug instantiations of Table.\n-\n    procedure Write_Overloads (N : Node_Id);\n    --  Debugging procedure to output info on possibly overloaded entities for\n    --  specified node."}]}