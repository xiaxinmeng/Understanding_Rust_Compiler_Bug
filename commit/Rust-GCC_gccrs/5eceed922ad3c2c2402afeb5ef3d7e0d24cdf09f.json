{"sha": "5eceed922ad3c2c2402afeb5ef3d7e0d24cdf09f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVjZWVkOTIyYWQzYzJjMjQwMmFmZWI1ZWYzZDdlMGQyNGNkZjA5Zg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-04-25T23:49:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-04-25T23:49:45Z"}, "message": "pa.c (emit_move_sequence): Handle function label arithmetic for PIC code generation too.\n\n\t* pa.c (emit_move_sequence): Handle function label arithmetic for\n\tPIC code generation too.\n\nFrom-SVN: r9469", "tree": {"sha": "1a510b347983c4e1883c260e870a1aae11fa19d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a510b347983c4e1883c260e870a1aae11fa19d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5eceed922ad3c2c2402afeb5ef3d7e0d24cdf09f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eceed922ad3c2c2402afeb5ef3d7e0d24cdf09f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eceed922ad3c2c2402afeb5ef3d7e0d24cdf09f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eceed922ad3c2c2402afeb5ef3d7e0d24cdf09f/comments", "author": null, "committer": null, "parents": [{"sha": "e9cf6a9776f6749d6a971034e5ec16cc63391a3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9cf6a9776f6749d6a971034e5ec16cc63391a3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9cf6a9776f6749d6a971034e5ec16cc63391a3f"}], "stats": {"total": 66, "additions": 40, "deletions": 26}, "files": [{"sha": "dfdca7255e445a4020e6f1289e1ceeabac68dfce", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eceed922ad3c2c2402afeb5ef3d7e0d24cdf09f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eceed922ad3c2c2402afeb5ef3d7e0d24cdf09f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=5eceed922ad3c2c2402afeb5ef3d7e0d24cdf09f", "patch": "@@ -927,6 +927,29 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t}\n       if (symbolic_operand (operand1, mode))\n \t{\n+\t  rtx const_part = NULL;\n+\n+\t  /* Argh.  The assembler and linker can't handle arithmetic\n+\t     involving plabels.  We'll have to split up operand1 here\n+\t     if it's a function label involved in an arithmetic\n+\t     expression.  Luckily, this only happens with addition\n+\t     of constants to plabels, which simplifies the test.\n+\n+\t     We add the constant back in just before returning to\n+\t     our caller.  */\n+\t  if (GET_CODE (operand1) == CONST\n+\t      && GET_CODE (XEXP (operand1, 0)) == PLUS\n+\t      && function_label_operand (XEXP (XEXP (operand1, 0), 0), Pmode))\n+\t    {\n+\t      /* Save away the constant part of the expression.  */\n+\t      const_part = XEXP (XEXP (operand1, 0), 1);\n+\t      if (GET_CODE (const_part) != CONST_INT)\n+\t\tabort ();\n+\n+\t      /* Set operand1 to just the SYMBOL_REF.  */\n+\t      operand1 = XEXP (XEXP (operand1, 0), 0);\n+\t    }\n+\n \t  if (flag_pic)\n \t    {\n \t      rtx temp;\n@@ -936,40 +959,31 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      else\n \t\ttemp = gen_reg_rtx (Pmode);\n \n-\t      operands[1] = legitimize_pic_address (operand1, mode, temp);\n-\t      emit_insn (gen_rtx (SET, VOIDmode, operand0, operands[1]));\n+\t      /* If operand1 is a function label, then we've got to\n+\t\t force it to memory, then load op0 from memory.  */\n+\t      if (function_label_operand (operand1, mode))\n+\t\t{\n+\t\t  operands[1] = force_const_mem (mode, operand1);\n+\t\t  emit_move_sequence (operands, mode, temp);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  operands[1] = legitimize_pic_address (operand1, mode, temp);\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operands[1]));\n+\t\t}\n \t    }\n \t  /* On the HPPA, references to data space are supposed to use dp,\n \t     register 27, but showing it in the RTL inhibits various cse\n \t     and loop optimizations.  */\n \t  else\n \t    {\n-\t      rtx temp, set, const_part = NULL;\n+\t      rtx temp, set;\n \n \t      if (reload_in_progress || reload_completed)\n \t\ttemp = scratch_reg ? scratch_reg : operand0;\n \t      else\n \t\ttemp = gen_reg_rtx (mode);\n \n-\t      /* Argh.  The assembler and linker can't handle arithmetic\n-\t\t involving plabels.  We'll have to split up operand1 here\n-\t\t if it's a function label involved in an arithmetic\n-\t\t expression.  Luckily, this only happens with addition\n-\t\t of constants to plabels, which simplifies the test.  */\n-\t     if (GET_CODE (operand1) == CONST\n-\t\t && GET_CODE (XEXP (operand1, 0)) == PLUS\n-\t\t && function_label_operand (XEXP (XEXP (operand1, 0), 0),\n-\t\t\t\t\t    Pmode))\n-\t\t{\n-\t\t  /* Save away the constant part of the expression.  */\n-\t\t  const_part = XEXP (XEXP (operand1, 0), 1);\n-\t\t  if (GET_CODE (const_part) != CONST_INT)\n-\t\t    abort ();\n-\n-\t\t  /* Set operand1 to just the SYMBOL_REF.  */\n-\t\t  operand1 = XEXP (XEXP (operand1, 0), 0);\n-\t\t}\n-\n \t      if (ishighonly)\n \t\tset = gen_rtx (SET, mode, operand0, temp);\n \t      else\n@@ -982,11 +996,11 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t\t\t  gen_rtx (HIGH, mode, operand1)));\n \t      emit_insn (set);\n \n-\t      /* Add back in the constant part if needed.  */\n-\t      if (const_part != NULL)\n-\t\texpand_inc (operand0, const_part);\n-\t      return 1;\n \t    }\n+\n+\t  /* Add back in the constant part if needed.  */\n+\t  if (const_part != NULL)\n+\t    expand_inc (operand0, const_part);\n \t  return 1;\n \t}\n       else if (GET_CODE (operand1) != CONST_INT"}]}