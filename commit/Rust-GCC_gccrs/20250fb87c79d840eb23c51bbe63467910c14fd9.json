{"sha": "20250fb87c79d840eb23c51bbe63467910c14fd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAyNTBmYjg3Yzc5ZDg0MGViMjNjNTFiYmU2MzQ2NzkxMGMxNGZkOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-20T12:31:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-20T12:31:47Z"}, "message": "[multiple changes]\n\n2016-06-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* make.adb, gnatbind.adb, g-socket.adb, sem_ch13.adb: Minor\n\treformatting.\n\t* lib.ads, sem_util.adb: Minor typo in comment.\n\n2016-06-20  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb, sem_prag.ads (Build_Pragma_Check_Equivalent):\n\tAdd parameter Keep_Pragma_Id to optionally keep\n\tthe identifier of the pragma instead of converting\n\tto pragma Check. Also set type of new function call\n\tappropriately.\t(Collect_Inherited_Class_Wide_Conditions):\n\tCall Build_Pragma_Check_Equivalent with the new parameter\n\tKeep_Pragma_Id set to True to keep the identifier of the copied\n\tpragma.\n\t* sinfo.ads: Add comment.\n\n2016-06-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Build_Invariant_Procedure_Body):\n\tAlways install the scope of the invariant procedure\n\tin order to produce better error messages. Do not\n\tinsert the body when the context is a generic unit.\n\t(Build_Invariant_Procedure_Declaration): Perform minimal\n\tdecoration of the invariant procedure and its formal parameter\n\tin case they are not analyzed.\tDo not insert the declaration\n\twhen the context is a generic unit.\n\nFrom-SVN: r237600", "tree": {"sha": "8b386d757c16c16568dbb9d414547e2d7eda794a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b386d757c16c16568dbb9d414547e2d7eda794a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20250fb87c79d840eb23c51bbe63467910c14fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20250fb87c79d840eb23c51bbe63467910c14fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20250fb87c79d840eb23c51bbe63467910c14fd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20250fb87c79d840eb23c51bbe63467910c14fd9/comments", "author": null, "committer": null, "parents": [{"sha": "9e3be36e465b0699d161e1e1ff9a78fd216c2c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e3be36e465b0699d161e1e1ff9a78fd216c2c60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e3be36e465b0699d161e1e1ff9a78fd216c2c60"}], "stats": {"total": 279, "additions": 190, "deletions": 89}, "files": [{"sha": "4987a23808ff902027af2096c411f26f204a2630", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -1,3 +1,32 @@\n+2016-06-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* make.adb, gnatbind.adb, g-socket.adb, sem_ch13.adb: Minor\n+\treformatting.\n+\t* lib.ads, sem_util.adb: Minor typo in comment.\n+\n+2016-06-20  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb, sem_prag.ads (Build_Pragma_Check_Equivalent):\n+\tAdd parameter Keep_Pragma_Id to optionally keep\n+\tthe identifier of the pragma instead of converting\n+\tto pragma Check. Also set type of new function call\n+\tappropriately.\t(Collect_Inherited_Class_Wide_Conditions):\n+\tCall Build_Pragma_Check_Equivalent with the new parameter\n+\tKeep_Pragma_Id set to True to keep the identifier of the copied\n+\tpragma.\n+\t* sinfo.ads: Add comment.\n+\n+2016-06-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Build_Invariant_Procedure_Body):\n+\tAlways install the scope of the invariant procedure\n+\tin order to produce better error messages. Do not\n+\tinsert the body when the context is a generic unit.\n+\t(Build_Invariant_Procedure_Declaration): Perform minimal\n+\tdecoration of the invariant procedure and its formal parameter\n+\tin case they are not analyzed.\tDo not insert the declaration\n+\twhen the context is a generic unit.\n+\n 2016-06-20  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Visible_Component): New procedure, subsidiary"}, {"sha": "b962fcc78a095da3910c3ee9b26ce94bcb099f22", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 74, "deletions": 28, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -4622,7 +4622,16 @@ package body Exp_Ch7 is\n \n       Set_Ghost_Mode_From_Entity (Work_Typ);\n \n+      --  Emulate the environment of the invariant procedure by installing\n+      --  its scope and formal parameters. Note that this is not need, but\n+      --  having the scope of the invariant procedure installed helps with\n+      --  the detection of invariant-related errors.\n+\n+      Push_Scope (Proc_Id);\n+      Install_Formals (Proc_Id);\n+\n       Obj_Id := First_Formal (Proc_Id);\n+      pragma Assert (Present (Obj_Id));\n \n       --  The \"partial\" invariant procedure verifies the invariants of the\n       --  partial view only.\n@@ -4631,23 +4640,13 @@ package body Exp_Ch7 is\n          pragma Assert (Present (Priv_Typ));\n          Freeze_Typ := Priv_Typ;\n \n-         --  Emulate the environment of the invariant procedure by installing\n-         --  its scope and formal parameters. Note that this is not need, but\n-         --  having the scope of the invariant procedure installed helps with\n-         --  the detection of invariant-related errors.\n-\n-         Push_Scope (Proc_Id);\n-         Install_Formals (Proc_Id);\n-\n          Add_Type_Invariants\n            (Priv_Typ => Priv_Typ,\n             Full_Typ => Empty,\n             CRec_Typ => Empty,\n             Obj_Id   => Obj_Id,\n             Checks   => Stmts);\n \n-         End_Scope;\n-\n       --  Otherwise the \"full\" invariant procedure verifies the invariants of\n       --  the full view, all array or record components, as well as class-wide\n       --  invariants inherited from parent types or interfaces. In addition, it\n@@ -4744,6 +4743,8 @@ package body Exp_Ch7 is\n          Add_Interface_Invariants (Full_Typ, Obj_Id, Stmts);\n       end if;\n \n+      End_Scope;\n+\n       --  At this point there should be at least one invariant check. If this\n       --  is not the case, then the invariant-related flags were not properly\n       --  set, or there is a missing invariant procedure on one of the array\n@@ -4759,6 +4760,12 @@ package body Exp_Ch7 is\n          Stmts := New_List (Make_Null_Statement (Loc));\n       end if;\n \n+      --  Generate:\n+      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>) is\n+      --    begin\n+      --       <Stmts>\n+      --    end <Work_Typ>[Partial_]Invariant;\n+\n       Proc_Body :=\n         Make_Subprogram_Body (Loc,\n           Specification                =>\n@@ -4769,16 +4776,30 @@ package body Exp_Ch7 is\n                 Statements => Stmts));\n       Proc_Body_Id := Defining_Entity (Proc_Body);\n \n+      --  Perform minor decoration in case the body is not analyzed\n+\n       Set_Ekind (Proc_Body_Id, E_Subprogram_Body);\n       Set_Etype (Proc_Body_Id, Standard_Void_Type);\n-      Set_Scope (Proc_Body_Id, Scope (Typ));\n+      Set_Scope (Proc_Body_Id, Current_Scope);\n \n       --  Link both spec and body to avoid generating duplicates\n \n       Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n       Set_Corresponding_Spec (Proc_Body, Proc_Id);\n \n-      Append_Freeze_Action (Freeze_Typ, Proc_Body);\n+      --  The body should not be inserted into the tree when the context is a\n+      --  generic unit because it is not part of the template. Note that the\n+      --  body must still be generated in order to resolve the invariants.\n+\n+      if Inside_A_Generic then\n+         null;\n+\n+      --  Otherwise the body is part of the freezing actions of the type\n+\n+      else\n+         Append_Freeze_Action (Freeze_Typ, Proc_Body);\n+      end if;\n+\n       Ghost_Mode := Save_Ghost_Mode;\n    end Build_Invariant_Procedure_Body;\n \n@@ -4794,8 +4815,10 @@ package body Exp_Ch7 is\n \n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n \n-      Proc_Id  : Entity_Id;\n-      Typ_Decl : Node_Id;\n+      Proc_Decl : Node_Id;\n+      Proc_Id   : Entity_Id;\n+      Proc_Nam  : Name_Id;\n+      Typ_Decl  : Node_Id;\n \n       CRec_Typ : Entity_Id;\n       --  The corresponding record type of Full_Typ\n@@ -4869,24 +4892,27 @@ package body Exp_Ch7 is\n       --  procedure.\n \n       if Partial_Invariant then\n-         Proc_Id :=\n-           Make_Defining_Identifier (Loc,\n-             Chars =>\n-               New_External_Name (Chars (Work_Typ), \"Partial_Invariant\"));\n-\n-         Set_Ekind (Proc_Id, E_Procedure);\n-         Set_Is_Partial_Invariant_Procedure (Proc_Id);\n-         Set_Partial_Invariant_Procedure (Work_Typ, Proc_Id);\n+         Proc_Nam := New_External_Name (Chars (Work_Typ), \"Partial_Invariant\");\n \n       --  Otherwise the caller requests the declaration of the \"full\" invariant\n       --  procedure.\n \n       else\n-         Proc_Id :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Work_Typ), \"Invariant\"));\n+         Proc_Nam := New_External_Name (Chars (Work_Typ), \"Invariant\");\n+      end if;\n+\n+      Proc_Id := Make_Defining_Identifier (Loc, Chars => Proc_Nam);\n+\n+      --  Perform minor decoration in case the declaration is not analyzed\n \n-         Set_Ekind (Proc_Id, E_Procedure);\n+      Set_Ekind (Proc_Id, E_Procedure);\n+      Set_Etype (Proc_Id, Standard_Void_Type);\n+      Set_Scope (Proc_Id, Current_Scope);\n+\n+      if Partial_Invariant then\n+         Set_Is_Partial_Invariant_Procedure (Proc_Id);\n+         Set_Partial_Invariant_Procedure (Work_Typ, Proc_Id);\n+      else\n          Set_Is_Invariant_Procedure (Proc_Id);\n          Set_Invariant_Procedure (Work_Typ, Proc_Id);\n       end if;\n@@ -4938,12 +4964,19 @@ package body Exp_Ch7 is\n       --  of the current type instance.\n \n       Obj_Id := Make_Defining_Identifier (Loc, Chars => Name_uObject);\n+\n+      --  Perform minor decoration in case the declaration is not analyzed\n+\n       Set_Ekind (Obj_Id, E_In_Parameter);\n+      Set_Etype (Obj_Id, Work_Typ);\n+      Set_Scope (Obj_Id, Proc_Id);\n+\n+      Set_First_Entity (Proc_Id, Obj_Id);\n \n       --  Generate:\n       --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>);\n \n-      Insert_After_And_Analyze (Typ_Decl,\n+      Proc_Decl :=\n         Make_Subprogram_Declaration (Loc,\n           Specification =>\n             Make_Procedure_Specification (Loc,\n@@ -4952,7 +4985,20 @@ package body Exp_Ch7 is\n                 Make_Parameter_Specification (Loc,\n                   Defining_Identifier => Obj_Id,\n                   Parameter_Type      =>\n-                    New_Occurrence_Of (Work_Typ, Loc))))));\n+                    New_Occurrence_Of (Work_Typ, Loc)))));\n+\n+      --  The declaration should not be inserted into the tree when the context\n+      --  is a generic unit because it is not part of the template.\n+\n+      if Inside_A_Generic then\n+         null;\n+\n+      --  Otherwise insert the declaration\n+\n+      else\n+         pragma Assert (Present (Typ_Decl));\n+         Insert_After_And_Analyze (Typ_Decl, Proc_Decl);\n+      end if;\n \n       Ghost_Mode := Save_Ghost_Mode;\n    end Build_Invariant_Procedure_Declaration;"}, {"sha": "75dc58de1a806ab8c536b5e2d21e59a1461b7aca", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -1505,27 +1505,26 @@ package body GNAT.Sockets is\n \n    function Is_IP_Address (Name : String) return Boolean is\n       Dots : Natural := 0;\n+\n    begin\n-      --  Perform a cursory check for a dotted quad: we must have 1 to 3\n-      --  dots, and there must be at least one digit around each.\n+      --  Perform a cursory check for a dotted quad: we must have 1 to 3 dots,\n+      --  and there must be at least one digit around each.\n \n       for J in Name'Range loop\n          if Name (J) = '.' then\n \n-            --  Check that the dot is not in first or last position, and\n-            --  that it is followed by a digit. Note that we already know\n-            --  that it is preceded by a digit, or we would have returned\n-            --  earlier on.\n+            --  Check that the dot is not in first or last position, and that\n+            --  it is followed by a digit. Note that we already know that it is\n+            --  preceded by a digit, or we would have returned earlier on.\n \n             if J in Name'First + 1 .. Name'Last - 1\n               and then Name (J + 1) in '0' .. '9'\n             then\n                Dots := Dots + 1;\n \n-            else\n-\n-               --  Definitely not a proper dotted quad\n+            --  Definitely not a proper dotted quad\n \n+            else\n                return False;\n             end if;\n "}, {"sha": "85f670716bdfbb9b15eb17dd4c84ae6ffadf7b03", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -90,7 +90,7 @@ procedure Gnatbind is\n    --  only with switch -R.\n \n    procedure Add_Artificial_ALI_File (Name : String);\n-   --  Artificially add ALI file Name in the closure.\n+   --  Artificially add ALI file Name in the closure\n \n    function Gnatbind_Supports_Auto_Init return Boolean;\n    --  Indicates if automatic initialization of elaboration procedure\n@@ -123,6 +123,7 @@ procedure Gnatbind is\n    procedure Add_Artificial_ALI_File (Name : String) is\n       Id : ALI_Id;\n       pragma Warnings (Off, Id);\n+\n    begin\n       Name_Len := Name'Length;\n       Name_Buffer (1 .. Name_Len) := Name;"}, {"sha": "0738cd73e2cd54f899d84917e2d148b168f27bef", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -261,7 +261,7 @@ package Lib is\n    -----------------\n \n    --  The units table has an entry for each unit (source file) read in by the\n-   --  current compilation. The table is indexed by the unit number value,\n+   --  current compilation. The table is indexed by the unit number value.\n    --  The first entry in the table, subscript Main_Unit, is for the main file.\n    --  Each entry in this units table contains the following data.\n \n@@ -286,7 +286,7 @@ package Lib is\n    --    Dynamic_Elab\n    --      A flag indicating if this unit was compiled with dynamic elaboration\n    --      checks specified (as the result of using the -gnatE compilation\n-   --      option or a pragma Elaboration_Checks (Dynamic).\n+   --      option or a pragma Elaboration_Checks (Dynamic)).\n \n    --    Error_Location\n    --      This is copied from the Sloc field of the Enode argument passed"}, {"sha": "9c8d5361ffe9fd811ea3a4322d0d06d5e0185b4a", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -2703,7 +2703,6 @@ package body Make is\n       procedure Check_Standard_Library is\n       begin\n          Need_To_Check_Standard_Library := False;\n-\n          Name_Len := 0;\n \n          if not Targparm.Suppress_Standard_Library_On_Target then\n@@ -2713,8 +2712,8 @@ package body Make is\n          end if;\n \n          declare\n-            Sfile  : File_Name_Type;\n             Add_It : Boolean := True;\n+            Sfile  : File_Name_Type;\n \n          begin\n             Sfile := Name_Enter;"}, {"sha": "06367aff0029aa157b448e51a03e32a38b37a793", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -12312,13 +12312,10 @@ package body Sem_Ch13 is\n \n       function Replace_Type_Ref (N : Node_Id) return Traverse_Result is\n          Loc : constant Source_Ptr := Sloc (N);\n-         C   : Entity_Id;\n-         S   : Entity_Id;\n-         P   : Node_Id;\n \n          procedure Add_Prefix (Ref : Node_Id; Comp : Entity_Id);\n-         --  Add the proper prefix to a reference to a component of the\n-         --  type when it is not already a selected component.\n+         --  Add the proper prefix to a reference to a component of the type\n+         --  when it is not already a selected component.\n \n          ----------------\n          -- Add_Prefix --\n@@ -12328,11 +12325,17 @@ package body Sem_Ch13 is\n          begin\n             Rewrite (Ref,\n               Make_Selected_Component (Loc,\n-                Prefix => New_Occurrence_Of (T, Loc),\n+                Prefix        => New_Occurrence_Of (T, Loc),\n                 Selector_Name => New_Occurrence_Of (Comp, Loc)));\n             Replace_Type_Reference (Prefix (Ref));\n          end Add_Prefix;\n \n+         --  Local variables\n+\n+         Comp : Entity_Id;\n+         Pref : Node_Id;\n+         Scop : Entity_Id;\n+\n       --  Start of processing for Replace_Type_Ref\n \n       begin\n@@ -12363,17 +12366,17 @@ package body Sem_Ch13 is\n                elsif Nkind (Parent (N)) = N_Indexed_Component\n                  and then N = Prefix (Parent (N))\n                then\n-                  C := Visible_Component (Chars (N));\n+                  Comp := Visible_Component (Chars (N));\n \n-                  if Present (C) and then Is_Array_Type (Etype (C)) then\n-                     Add_Prefix (N, C);\n+                  if Present (Comp) and then Is_Array_Type (Etype (Comp)) then\n+                     Add_Prefix (N, Comp);\n                   end if;\n \n                else\n-                  C := Visible_Component (Chars (N));\n+                  Comp := Visible_Component (Chars (N));\n \n-                  if Present (C) then\n-                     Add_Prefix (N, C);\n+                  if Present (Comp) then\n+                     Add_Prefix (N, Comp);\n                   end if;\n                end if;\n \n@@ -12404,20 +12407,20 @@ package body Sem_Ch13 is\n             else\n                --  Loop through scopes and prefixes, doing comparison\n \n-               S := Current_Scope;\n-               P := Prefix (N);\n+               Scop := Current_Scope;\n+               Pref := Prefix (N);\n                loop\n                   --  Continue if no more scopes or scope with no name\n \n-                  if No (S) or else Nkind (S) not in N_Has_Chars then\n+                  if No (Scop) or else Nkind (Scop) not in N_Has_Chars then\n                      return OK;\n                   end if;\n \n                   --  Do replace if prefix is an identifier matching the scope\n                   --  that we are currently looking at.\n \n-                  if Nkind (P) = N_Identifier\n-                    and then Chars (P) = Chars (S)\n+                  if Nkind (Pref) = N_Identifier\n+                    and then Chars (Pref) = Chars (Scop)\n                   then\n                      Replace_Type_Reference (N);\n                      return Skip;\n@@ -12427,12 +12430,12 @@ package body Sem_Ch13 is\n                   --  of a selected component, whose selector matches the scope\n                   --  we are currently looking at.\n \n-                  if Nkind (P) = N_Selected_Component\n-                    and then Nkind (Selector_Name (P)) = N_Identifier\n-                    and then Chars (Selector_Name (P)) = Chars (S)\n+                  if Nkind (Pref) = N_Selected_Component\n+                    and then Nkind (Selector_Name (Pref)) = N_Identifier\n+                    and then Chars (Selector_Name (Pref)) = Chars (Scop)\n                   then\n-                     S := Scope (S);\n-                     P := Prefix (P);\n+                     Scop := Scope (Scop);\n+                     Pref := Prefix (Pref);\n \n                   --  For anything else, we don't have a match, so keep on\n                   --  going, there are still some weird cases where we may\n@@ -12451,22 +12454,23 @@ package body Sem_Ch13 is\n          end if;\n       end Replace_Type_Ref;\n \n+      procedure Replace_Type_Refs is new Traverse_Proc (Replace_Type_Ref);\n+\n       -----------------------\n       -- Visible_Component --\n       -----------------------\n \n       function Visible_Component (Comp : Name_Id) return Entity_Id is\n          E : Entity_Id;\n+\n       begin\n          if Ekind (T) /= E_Record_Type then\n             return Empty;\n \n          else\n             E := First_Entity (T);\n             while Present (E) loop\n-               if Comes_From_Source (E)\n-                 and then Chars (E) = Comp\n-               then\n+               if Comes_From_Source (E) and then Chars (E) = Comp then\n                   return E;\n                end if;\n \n@@ -12477,7 +12481,7 @@ package body Sem_Ch13 is\n          end if;\n       end Visible_Component;\n \n-      procedure Replace_Type_Refs is new Traverse_Proc (Replace_Type_Ref);\n+   --  Start of processing for Replace_Type_References_Generic\n \n    begin\n       Replace_Type_Refs (N);"}, {"sha": "bb35ac49c20b7a6ebeb629551f96aa324c791e10", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -26277,9 +26277,10 @@ package body Sem_Prag is\n    -----------------------------------\n \n    function Build_Pragma_Check_Equivalent\n-     (Prag     : Node_Id;\n-      Subp_Id  : Entity_Id := Empty;\n-      Inher_Id : Entity_Id := Empty) return Node_Id\n+     (Prag           : Node_Id;\n+      Subp_Id        : Entity_Id := Empty;\n+      Inher_Id       : Entity_Id := Empty;\n+      Keep_Pragma_Id : Boolean := False) return Node_Id\n    is\n       Map : Elist_Id;\n       --  List containing the following mappings\n@@ -26361,6 +26362,15 @@ package body Sem_Prag is\n                    & \"for&#\", N, Current_Scope);\n             end if;\n \n+            --  Update type of function call node, which should be the same as\n+            --  the function's return type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+            then\n+               Set_Etype (Parent (N), Etype (Entity (N)));\n+            end if;\n+\n          --  The whole expression will be reanalyzed\n \n          elsif Nkind (N) in N_Has_Etype then\n@@ -26595,7 +26605,6 @@ package body Sem_Prag is\n \n       Set_Analyzed          (Check_Prag, False);\n       Set_Comes_From_Source (Check_Prag, False);\n-      Set_Class_Present     (Check_Prag, False);\n \n       --  The tree of the original pragma may contain references to the\n       --  formal parameters of the related subprogram. At the same time\n@@ -26621,15 +26630,20 @@ package body Sem_Prag is\n          Nam := Prag_Nam;\n       end if;\n \n-      --  Convert the copy into pragma Check by correcting the name and adding\n-      --  a check_kind argument.\n+      --  Unless Keep_Pragma_Id is True in order to keep the identifier of\n+      --  the copied pragma in the newly created pragma, convert the copy into\n+      --  pragma Check by correcting the name and adding a check_kind argument.\n \n-      Set_Pragma_Identifier\n-        (Check_Prag, Make_Identifier (Loc, Name_Check));\n+      if not Keep_Pragma_Id then\n+         Set_Class_Present (Check_Prag, False);\n \n-      Prepend_To (Pragma_Argument_Associations (Check_Prag),\n-        Make_Pragma_Argument_Association (Loc,\n-          Expression => Make_Identifier (Loc, Nam)));\n+         Set_Pragma_Identifier\n+           (Check_Prag, Make_Identifier (Loc, Name_Check));\n+\n+         Prepend_To (Pragma_Argument_Associations (Check_Prag),\n+           Make_Pragma_Argument_Association (Loc,\n+             Expression => Make_Identifier (Loc, Nam)));\n+      end if;\n \n       --  Update the error message when the pragma is inherited\n \n@@ -27154,7 +27168,8 @@ package body Sem_Prag is\n                end if;\n \n                New_Prag :=\n-                 Build_Pragma_Check_Equivalent (Prag, Subp, Parent_Subp);\n+                 Build_Pragma_Check_Equivalent (Prag, Subp, Parent_Subp,\n+                                                Keep_Pragma_Id => True);\n                Insert_After (Unit_Declaration_Node (Subp), New_Prag);\n                Preanalyze (New_Prag);\n "}, {"sha": "d8607089a8d7c73e85b148704363be91213af189", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -245,14 +245,18 @@ package Sem_Prag is\n    --  Perform preanalysis of pragma Test_Case\n \n    function Build_Pragma_Check_Equivalent\n-     (Prag     : Node_Id;\n-      Subp_Id  : Entity_Id := Empty;\n-      Inher_Id : Entity_Id := Empty) return Node_Id;\n-   --  Transform a [refined] pre- or postcondition denoted by Prag into an\n+     (Prag           : Node_Id;\n+      Subp_Id        : Entity_Id := Empty;\n+      Inher_Id       : Entity_Id := Empty;\n+      Keep_Pragma_Id : Boolean := False) return Node_Id;\n+   --  Transform a pre- or [refined] postcondition denoted by Prag into an\n    --  equivalent pragma Check. When the pre- or postcondition is inherited,\n-   --  the routine replaces the references of all formals of Inher_Id and\n-   --  primitive operations of its controlling type by references to the\n-   --  corresponding entities of Subp_Id and the descendant type.\n+   --  the routine replaces the references of all formals of Inher_Id\n+   --  and primitive operations of its controlling type by references\n+   --  to the corresponding entities of Subp_Id and the descendant type.\n+   --  Keep_Pragma_Id is True when the newly created pragma should be\n+   --  in fact of the same kind as the source pragma Prag. This is used\n+   --  in GNATprove_Mode to generate the inherited pre- and postconditions.\n \n    procedure Check_Applicable_Policy (N : Node_Id);\n    --  N is either an N_Aspect or an N_Pragma node. There are two cases. If"}, {"sha": "d66205167b8b331196bef39c2eb7abaade894a71", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -12626,7 +12626,7 @@ package body Sem_Util is\n             return True;\n \n          --  An array type is effectively volatile when it is subject to pragma\n-         --  Atomic_Components or Volatile_Components or its compolent type is\n+         --  Atomic_Components or Volatile_Components or its component type is\n          --  effectively volatile.\n \n          elsif Is_Array_Type (Id) then"}, {"sha": "860f0d1c9780f323e13ce6e27bfdf0463c1a73aa", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20250fb87c79d840eb23c51bbe63467910c14fd9/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=20250fb87c79d840eb23c51bbe63467910c14fd9", "patch": "@@ -7618,6 +7618,10 @@ package Sinfo is\n       --  source, or because a Pre (resp. Post) aspect specification has been\n       --  broken into AND THEN sections. See Split_PPC for details.\n \n+      --  In GNATprove mode, the inherited classwide pre- and postconditions\n+      --  (suitably specialized for the specific type of the overriding\n+      --  operation) are also in this list.\n+\n       --  Contract_Test_Cases contains a collection of pragmas that correspond\n       --  to aspects/pragmas Contract_Cases and Test_Case. The ordering in the\n       --  list is in LIFO fashion."}]}