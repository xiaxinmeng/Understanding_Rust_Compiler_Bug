{"sha": "cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FiYWRkMWNlMzM0MTJjNzBkMmM5MTBhZTQ5YzQzNDFmZTM5ZDNiNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-25T08:33:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-25T08:33:02Z"}, "message": "[multiple changes]\n\n2009-06-25  Emmanuel Briot  <briot@adacore.com>\n\n\t* gnatcmd.adb, make.adb, mlib-prj.adb, prj.adb, prj.ads, prj-nmsc.adb,\n\tprj-env.adb, prj-env.ads (Slash): removed, no longer used\n\t(Source_Data): no longer use Path.Name to point to a locally removed\n\tfile. Instead we use the field Locally_Removed which is clearer\n\n2009-06-25  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gcc-interface/Make-lang.in: Remove references to sem_maps.o\n\n\t* sem_maps.adb, sem_maps.ads: Removed, not used.\n\nFrom-SVN: r148931", "tree": {"sha": "df4aae4263012bbb39ad4216d707c67937758398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df4aae4263012bbb39ad4216d707c67937758398"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/comments", "author": null, "committer": null, "parents": [{"sha": "9763f8c821d7e6b851a114ea2ae810f07096ba64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9763f8c821d7e6b851a114ea2ae810f07096ba64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9763f8c821d7e6b851a114ea2ae810f07096ba64"}], "stats": {"total": 700, "additions": 61, "deletions": 639}, "files": [{"sha": "b5703fb60111c298b0541af510ba104210a524d6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -1,3 +1,16 @@\n+2009-06-25  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* gnatcmd.adb, make.adb, mlib-prj.adb, prj.adb, prj.ads, prj-nmsc.adb,\n+\tprj-env.adb, prj-env.ads (Slash): removed, no longer used\n+\t(Source_Data): no longer use Path.Name to point to a locally removed\n+\tfile. Instead we use the field Locally_Removed which is clearer\n+\n+2009-06-25  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gcc-interface/Make-lang.in: Remove references to sem_maps.o\n+\n+\t* sem_maps.adb, sem_maps.ads: Removed, not used.\n+\n 2009-06-25  Ed Falis  <falis@adacore.com>\n \n \t* s-vxwext-rtp.ads: Add missing declaration"}, {"sha": "dd8a4b4932954814f8d836249c112d52186103cd", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -157,7 +157,7 @@ GNAT_ADA_OBJS = ada/s-bitops.o ada/ada.o ada/a-charac.o ada/a-chlat1.o ada/a-exc\n  ada/sem_ch12.o ada/sem_ch13.o ada/sem_ch2.o ada/sem_ch3.o ada/sem_ch4.o \\\n  ada/sem_ch5.o  ada/sem_ch6.o ada/sem_ch7.o ada/sem_ch8.o ada/sem_ch9.o \\\n  ada/sem_case.o ada/sem_disp.o ada/sem_dist.o ada/sem_elab.o ada/sem_elim.o \\\n- ada/sem_eval.o ada/sem_intr.o ada/sem_maps.o ada/sem_mech.o ada/sem_prag.o \\\n+ ada/sem_eval.o ada/sem_intr.o ada/sem_mech.o ada/sem_prag.o \\\n  ada/sem_res.o ada/sem_smem.o ada/sem_type.o ada/sem_util.o ada/sem_vfpt.o \\\n  ada/sem_warn.o ada/sinfo-cn.o ada/sinfo.o ada/sinput.o ada/sinput-d.o \\\n  ada/sinput-l.o ada/snames.o ada/sprint.o ada/stand.o ada/stringt.o \\\n@@ -3686,19 +3686,6 @@ ada/sem_intr.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/tree_io.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n-ada/sem_maps.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n-   ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n-   ada/casing.ads ada/debug.ads ada/einfo.ads ada/einfo.adb ada/gnat.ads \\\n-   ada/g-htable.ads ada/hostparm.ads ada/namet.ads ada/nlists.ads \\\n-   ada/nlists.adb ada/opt.ads ada/output.ads ada/sem_maps.ads \\\n-   ada/sem_maps.adb ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n-   ada/snames.ads ada/stand.ads ada/system.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/uintp.adb \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n-\n ada/sem_mech.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n    ada/casing.ads ada/debug.ads ada/einfo.ads ada/einfo.adb \\"}, {"sha": "89dcb6860ca367dc5ff65c5c2ca98aa1962bff42", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -417,7 +417,7 @@ procedure GNATCmd is\n \n                if The_Command = List then\n                   if Unit.File_Names (Impl) /= null\n-                    and then Unit.File_Names (Impl).Path.Name /= Slash\n+                    and then not Unit.File_Names (Impl).Locally_Removed\n                   then\n                      --  There is a body, check if it is for this project\n \n@@ -427,7 +427,7 @@ procedure GNATCmd is\n                         Subunit := False;\n \n                         if Unit.File_Names (Spec) = null\n-                          or else Unit.File_Names (Spec).Path.Name = Slash\n+                          or else Unit.File_Names (Spec).Locally_Removed\n                         then\n                            --  We have a body with no spec: we need to check if\n                            --  this is a subunit, because gnatls will complain\n@@ -456,7 +456,7 @@ procedure GNATCmd is\n                      end if;\n \n                   elsif Unit.File_Names (Spec) /= null\n-                    and then Unit.File_Names (Spec).Path.Name /= Slash\n+                    and then not Unit.File_Names (Spec).Locally_Removed\n                   then\n                      --  We have a spec with no body. Check if it is for this\n                      --  project.\n@@ -478,7 +478,7 @@ procedure GNATCmd is\n \n                elsif The_Command = Stack then\n                   if Unit.File_Names (Impl) /= null\n-                    and then Unit.File_Names (Impl).Path.Name /= Slash\n+                    and then not Unit.File_Names (Impl).Locally_Removed\n                   then\n                      --  There is a body. Check if .ci files for this project\n                      --  must be added.\n@@ -489,7 +489,7 @@ procedure GNATCmd is\n                         Subunit := False;\n \n                         if Unit.File_Names (Spec) = null\n-                          or else Unit.File_Names (Spec).Path.Name = Slash\n+                          or else Unit.File_Names (Spec).Locally_Removed\n                         then\n                            --  We have a body with no spec: we need to check\n                            --  if this is a subunit, because .ci files are not\n@@ -523,7 +523,7 @@ procedure GNATCmd is\n                      end if;\n \n                   elsif Unit.File_Names (Spec) /= null\n-                    and then Unit.File_Names (Spec).Path.Name /= Slash\n+                    and then not Unit.File_Names (Spec).Locally_Removed\n                   then\n                      --  Spec with no body, check if it is for this project\n \n@@ -552,7 +552,7 @@ procedure GNATCmd is\n                      if Unit.File_Names (Kind) /= null\n                        and then Check_Project\n                                   (Unit.File_Names (Kind).Project, Project)\n-                       and then Unit.File_Names (Kind).Path.Name /= Slash\n+                       and then not Unit.File_Names (Kind).Locally_Removed\n                      then\n                         Get_Name_String\n                           (Unit.File_Names (Kind).Path.Display_Name);"}, {"sha": "5999951b5fbfc50e0ca336da8e745dcad2d16e26", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -3609,15 +3609,15 @@ package body Make is\n                               if Uid /= Prj.No_Unit_Index then\n                                  if Uid.File_Names (Impl) /= null\n                                    and then\n-                                     Uid.File_Names (Impl).Path.Name /= Slash\n+                                     not Uid.File_Names (Impl).Locally_Removed\n                                  then\n                                     Sfile := Uid.File_Names (Impl).File;\n                                     Source_Index :=\n                                       Uid.File_Names (Impl).Index;\n \n                                  elsif Uid.File_Names (Spec) /= null\n                                    and then\n-                                     Uid.File_Names (Spec).Path.Name /= Slash\n+                                     not Uid.File_Names (Spec).Locally_Removed\n                                  then\n                                     Sfile := Uid.File_Names (Spec).File;\n                                     Source_Index :=\n@@ -7002,7 +7002,7 @@ package body Make is\n          --  locally removed.\n \n          if Unit.File_Names (Impl) /= null\n-           and then Unit.File_Names (Impl).Path.Name /= Slash\n+           and then not Unit.File_Names (Impl).Locally_Removed\n          then\n             --  And it is a source for the specified project\n \n@@ -7049,7 +7049,7 @@ package body Make is\n             end if;\n \n          elsif Unit.File_Names (Spec) /= null\n-           and then Unit.File_Names (Spec).Path.Name /= Slash\n+           and then not Unit.File_Names (Spec).Locally_Removed\n            and then Check_Project (Unit.File_Names (Spec).Project)\n          then\n             --  If there is no source for the body, but there is a source"}, {"sha": "c7f0f0b73f0024fd126a56505b7bbc48c9346954", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -946,7 +946,7 @@ package body MLib.Prj is\n             Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n             while Unit /= No_Unit_Index loop\n                if Unit.File_Names (Impl) /= null\n-                 and then Unit.File_Names (Impl).Path.Name /= Slash\n+                 and then not Unit.File_Names (Impl).Locally_Removed\n                then\n                   if Check_Project (Unit.File_Names (Impl).Project) then\n                      if Unit.File_Names (Spec) = null then\n@@ -975,7 +975,7 @@ package body MLib.Prj is\n                   end if;\n \n                elsif Unit.File_Names (Spec) /= null\n-                 and then Unit.File_Names (Spec).Path.Name /= Slash\n+                 and then not Unit.File_Names (Spec).Locally_Removed\n                  and then Check_Project (Unit.File_Names (Spec).Project)\n                then\n                   Add_ALI_For (Unit.File_Names (Spec).File);"}, {"sha": "aa050d40913eea9fbae05eac68222a52397248e8", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -622,7 +622,8 @@ package body Prj.Env is\n          Last := Write (File, S (S'First)'Address, S'Length);\n \n          if Last /= S'Length then\n-            Prj.Com.Fail (\"Disk full\");\n+            Prj.Com.Fail\n+              (\"Disk full when creating \" & Get_Name_String (File_Name));\n          end if;\n \n          if Current_Verbosity = High then\n@@ -650,7 +651,8 @@ package body Prj.Env is\n          Last := Write (File, S0'Address, S0'Length);\n \n          if Last /= S'Length + 1 then\n-            Prj.Com.Fail (\"Disk full\");\n+            Prj.Com.Fail\n+              (\"Disk full when creating \" & Get_Name_String (File_Name));\n          end if;\n \n          if Current_Verbosity = High then\n@@ -676,6 +678,7 @@ package body Prj.Env is\n          while Current_Unit /= No_Unit_Index loop\n             if Current_Unit.File_Names (Spec) /= null\n               and then Current_Unit.File_Names (Spec).Naming_Exception\n+              and then not Current_Unit.File_Names (Spec).Locally_Removed\n             then\n                Put (Current_Unit.Name,\n                     Current_Unit.File_Names (Spec).File,\n@@ -685,6 +688,7 @@ package body Prj.Env is\n \n             if Current_Unit.File_Names (Impl) /= null\n               and then Current_Unit.File_Names (Impl).Naming_Exception\n+              and then not Current_Unit.File_Names (Impl).Locally_Removed\n             then\n                Put (Current_Unit.Name,\n                     Current_Unit.File_Names (Impl).File,\n@@ -718,7 +722,8 @@ package body Prj.Env is\n          GNAT.OS_Lib.Close (File, Status);\n \n          if not Status then\n-            Prj.Com.Fail (\"disk full\");\n+            Prj.Com.Fail\n+              (\"Disk full when creating \" & Get_Name_String (File_Name));\n          end if;\n \n          if Opt.Verbose_Mode then\n@@ -744,18 +749,17 @@ package body Prj.Env is\n    begin\n       Fmap.Reset_Tables;\n \n+      --  ??? Shouldn't we iterate on source files instead ?\n+\n       Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n       while Unit /= No_Unit_Index loop\n-\n-         --  Process only if the unit has a valid name\n-\n-         if Unit.Name /= No_Name then\n-            Data := Unit.File_Names (Spec);\n+         for S in Spec_Or_Body loop\n+            Data := Unit.File_Names (S);\n \n             --  If there is a spec put it in the mapping\n \n             if Data /= null then\n-               if Data.Path.Name = Slash then\n+               if Data.Locally_Removed then\n                   Fmap.Add_Forbidden_File_Name (Data.File);\n                else\n                   Fmap.Add_To_File_Map\n@@ -764,22 +768,7 @@ package body Prj.Env is\n                      Path_Name => File_Name_Type (Data.Path.Name));\n                end if;\n             end if;\n-\n-            Data := Unit.File_Names (Impl);\n-\n-            --  If there is a body (or subunit) put it in the mapping\n-\n-            if Data /= null then\n-               if Data.Path.Name = Slash then\n-                  Fmap.Add_Forbidden_File_Name (Data.File);\n-               else\n-                  Fmap.Add_To_File_Map\n-                    (Unit_Name => Unit_Name_Type (Unit.Name),\n-                     File_Name => Data.File,\n-                     Path_Name => File_Name_Type (Data.Path.Name));\n-               end if;\n-            end if;\n-         end if;\n+         end loop;\n \n          Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n       end loop;\n@@ -971,7 +960,6 @@ package body Prj.Env is\n                      exit when Source = No_Source;\n \n                      if Source.Language.Name = Language\n-                       and then not Source.Locally_Removed\n                        and then Source.Replaced_By = No_Source\n                        and then Source.Path.Name /= No_Path\n                      then\n@@ -997,7 +985,13 @@ package body Prj.Env is\n                         Get_Name_String (Source.File);\n                         Put_Name_Buffer;\n \n-                        Get_Name_String (Source.Path.Name);\n+                        if Source.Locally_Removed then\n+                           Name_Len := 1;\n+                           Name_Buffer (1 .. Name_Len) := \"/\";\n+                        else\n+                           Get_Name_String (Source.Path.Name);\n+                        end if;\n+\n                         Put_Name_Buffer;\n                      end if;\n "}, {"sha": "34b77aa4c250efcbba47d66c8f9b283e3085a672", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -56,6 +56,8 @@ package Prj.Env is\n    --  since the latter would have to match exactly the index of that language\n    --  for the specified project, and that is not information available in\n    --  buildgpr.adb.\n+   --\n+   --  See fmap for a description of the format of the mapping file\n \n    procedure Set_Mapping_File_Initial_State_To_Empty\n      (In_Tree : Project_Tree_Ref);"}, {"sha": "0f5cf320da215d4a30d50702c48c13b8dba4733c", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -4569,7 +4569,7 @@ package body Prj.Nmsc is\n                         --  Check that the unit is part of the project\n \n                         if UData.File_Names (Impl) /= null\n-                          and then UData.File_Names (Impl).Path.Name /= Slash\n+                          and then not UData.File_Names (Impl).Locally_Removed\n                         then\n                            if Check_Project\n                              (UData.File_Names (Impl).Project,\n@@ -4618,7 +4618,7 @@ package body Prj.Nmsc is\n                            end if;\n \n                         elsif UData.File_Names (Spec) /= null\n-                          and then UData.File_Names (Spec).Path.Name /= Slash\n+                          and then not UData.File_Names (Spec).Locally_Removed\n                           and then Check_Project\n                                      (UData.File_Names (Spec).Project,\n                                       Project, Extending)\n@@ -7802,7 +7802,6 @@ package body Prj.Nmsc is\n          Source   : Source_Id := No_Source;\n          OK       : Boolean;\n          Excluded : File_Found;\n-         Index    : Unit_Index;\n \n       begin\n          Excluded := Excluded_Sources_Htable.Get_First;\n@@ -7821,27 +7820,12 @@ package body Prj.Nmsc is\n                     or else Is_Extending (Project, Source.Project)\n                   then\n                      OK := True;\n+                     Source.Locally_Removed := True;\n \n-                     if Source.Unit /= No_Unit_Index then\n-                        Index :=\n-                          Units_Htable.Get\n-                            (In_Tree.Units_HT, Source.Unit.Name);\n-                        if Index.File_Names (Source.Kind) /= null then\n-                           Index.File_Names (Source.Kind).Path.Name := Slash;\n-                           Index.File_Names (Source.Kind).Naming_Exception :=\n-                             False;\n-\n-                           --  ??? Should we simply set (can be done from the\n-                           --  source)\n-                           --  Index.File_Names (Source.Kind) := null;\n-\n-                        end if;\n-                     end if;\n-\n-                     if Source /= No_Source then\n-                        Source.Locally_Removed := True;\n-                        Source.In_Interfaces := False;\n-                     end if;\n+                     Name_Len := 1;\n+                     Name_Buffer (1 .. Name_Len) := \"/\";\n+                     Source.Path.Name := Name_Find;\n+                     Source.In_Interfaces := False;\n \n                      if Current_Verbosity = High then\n                         Write_Str (\"Removing file \");\n@@ -8134,12 +8118,12 @@ package body Prj.Nmsc is\n             if UData.File_Names (Unit_Kind) = null\n               or else\n                 (UData.File_Names (Unit_Kind).File = Canonical_File\n-                  and then UData.File_Names (Unit_Kind).Path.Name = Slash)\n+                  and then UData.File_Names (Unit_Kind).Locally_Removed)\n               or else Is_Extending\n                 (Project.Extends, UData.File_Names (Unit_Kind).Project)\n             then\n                if UData.File_Names (Unit_Kind) /= null\n-                 and then UData.File_Names (Unit_Kind).Path.Name = Slash\n+                 and then UData.File_Names (Unit_Kind).Locally_Removed\n                then\n                   Remove_Forbidden_File_Name\n                     (UData.File_Names (Unit_Kind).File);"}, {"sha": "7d96eec8d4e28964feabbdec9c3187b87e2b68f2", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -53,7 +53,6 @@ package body Prj is\n \n    Default_Ada_Spec_Suffix_Id : File_Name_Type;\n    Default_Ada_Body_Suffix_Id : File_Name_Type;\n-   Slash_Id                   : Path_Name_Type;\n    --  Initialized in Prj.Initialize, then never modified\n \n    subtype Known_Casing is Casing_Type range All_Upper_Case .. Mixed_Case;\n@@ -620,9 +619,6 @@ package body Prj is\n          Name_Len := 4;\n          Name_Buffer (1 .. 4) := \".adb\";\n          Default_Ada_Body_Suffix_Id := Name_Find;\n-         Name_Len := 1;\n-         Name_Buffer (1) := '/';\n-         Slash_Id := Name_Find;\n \n          Prj.Attr.Initialize;\n          Set_Name_Table_Byte (Name_Project,  Token_Type'Pos (Tok_Project));\n@@ -1134,15 +1130,6 @@ package body Prj is\n       In_Tree.Array_Elements.Table (Naming.Spec_Suffix) := Element;\n    end Set_Spec_Suffix;\n \n-   -----------\n-   -- Slash --\n-   -----------\n-\n-   function Slash return Path_Name_Type is\n-   begin\n-      return Slash_Id;\n-   end Slash;\n-\n    -----------------------\n    -- Spec_Suffix_Id_Of --\n    -----------------------\n@@ -1464,7 +1451,8 @@ package body Prj is\n \n    function Is_Compilable (Source : Source_Id) return Boolean is\n    begin\n-      return Source.Language.Config.Compiler_Driver /= Empty_File_Name;\n+      return Source.Language.Config.Compiler_Driver /= Empty_File_Name\n+        and then not Source.Locally_Removed;\n    end Is_Compilable;\n \n    ----------------------------"}, {"sha": "456c17268accbe42ad4ec014a695f449091c8e29", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabadd1ce33412c70d2c910ae49c4341fe39d3b6/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=cabadd1ce33412c70d2c910ae49c4341fe39d3b6", "patch": "@@ -121,10 +121,6 @@ package Prj is\n    --  The name for the standard GNAT suffix for Ada body source file name\n    --  \".adb\". Initialized by Prj.Initialize.\n \n-   function Slash return Path_Name_Type;\n-   pragma Inline (Slash);\n-   --  \"/\", used as the path of locally removed files\n-\n    Config_Project_File_Extension : String := \".cgpr\";\n    Project_File_Extension : String := \".gpr\";\n    --  The standard config and user project file name extensions. They are not\n@@ -692,8 +688,6 @@ package Prj is\n \n       Path                   : Path_Information    := No_Path_Information;\n       --  Path name of the source\n-      --  Path.Name is set to Slash for an excluded file that does not belong\n-      --  in the project in fact\n \n       Source_TS              : Time_Stamp_Type     := Empty_Time_Stamp;\n       --  Time stamp of the source file"}, {"sha": "4e669d21e077fb49a0f648cf1c0c3b1427f73f93", "filename": "gcc/ada/sem_maps.adb", "status": "removed", "additions": 0, "deletions": 373, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fsem_maps.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fsem_maps.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_maps.adb?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -1,373 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             S E M _ M A P S                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1996-2007, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Atree;  use Atree;\n-with Einfo;  use Einfo;\n-with Namet;  use Namet;\n-with Output; use Output;\n-with Sinfo;  use Sinfo;\n-with Uintp;  use Uintp;\n-\n-package body Sem_Maps is\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Find_Assoc (M : Map; E : Entity_Id) return Assoc_Index;\n-   --  Standard hash table search. M is the map to be searched, E is the\n-   --  entity to be searched for, and Assoc_Index is the resulting\n-   --  association, or is set to No_Assoc if there is no association.\n-\n-   function Find_Header_Size (N : Int) return Header_Index;\n-   --  Find largest power of two smaller than the number of entries in\n-   --  the table. This load factor of 2 may be adjusted later if needed.\n-\n-   procedure Write_Map (E : Entity_Id);\n-   pragma Warnings (Off, Write_Map);\n-   --  For debugging purposes\n-\n-   ---------------------\n-   -- Add_Association --\n-   ---------------------\n-\n-   procedure Add_Association\n-     (M    : Map;\n-      O_Id : Entity_Id;\n-      N_Id : Entity_Id;\n-      Kind : Scope_Kind := S_Local)\n-   is\n-      Info : constant Map_Info      := Maps_Table.Table (M);\n-      Offh : constant Header_Index  := Info.Header_Offset;\n-      Offs : constant Header_Index  := Info.Header_Num;\n-      J    : constant Header_Index  := Header_Index (O_Id) mod Offs;\n-      K    : constant Assoc_Index   := Info.Assoc_Next;\n-\n-   begin\n-      Associations_Table.Table (K) := (O_Id, N_Id, Kind, No_Assoc);\n-      Maps_Table.Table (M).Assoc_Next := K + 1;\n-\n-      if Headers_Table.Table (Offh + J) /= No_Assoc then\n-\n-         --  Place new association at head of chain\n-\n-         Associations_Table.Table (K).Next := Headers_Table.Table (Offh + J);\n-      end if;\n-\n-      Headers_Table.Table (Offh + J) := K;\n-   end Add_Association;\n-\n-   ------------------------\n-   -- Build_Instance_Map --\n-   ------------------------\n-\n-   function Build_Instance_Map (M : Map) return Map is\n-      Info    : constant Map_Info     := Maps_Table.Table (M);\n-      Res     : constant Map          := New_Map (Int (Info.Assoc_Num));\n-      Offh1   : constant Header_Index := Info.Header_Offset;\n-      Offa1   : constant Assoc_Index  := Info.Assoc_Offset;\n-      Offh2   : constant Header_Index := Maps_Table.Table (Res).Header_Offset;\n-      Offa2   : constant Assoc_Index  := Maps_Table.Table (Res).Assoc_Offset;\n-      A       : Assoc;\n-      A_Index : Assoc_Index;\n-\n-   begin\n-      for J in 0 .. Info.Header_Num - 1 loop\n-         A_Index := Headers_Table.Table (Offh1 + J);\n-\n-         if A_Index /= No_Assoc then\n-            Headers_Table.Table (Offh2 + J) := A_Index + (Offa2 - Offa1);\n-         end if;\n-      end loop;\n-\n-      for J in 0 .. Info.Assoc_Num - 1 loop\n-         A  := Associations_Table.Table (Offa1 + J);\n-\n-         --  For local entities that come from source, create the\n-         --  corresponding local entities in the instance. Entities that\n-         --  do not come from source are etypes, and new ones will be\n-         --  generated when analyzing the instance.\n-\n-         if No (A.New_Id)\n-           and then A.Kind = S_Local\n-           and then Comes_From_Source (A.Old_Id)\n-         then\n-            A.New_Id := New_Copy (A.Old_Id);\n-            A.New_Id := New_Entity (Nkind (A.Old_Id), Sloc (A.Old_Id));\n-            Set_Chars (A.New_Id, Chars (A.Old_Id));\n-         end if;\n-\n-         if A.Next /= No_Assoc then\n-            A.Next := A.Next + (Offa2 - Offa1);\n-         end if;\n-\n-         Associations_Table.Table (Offa2 + J) := A;\n-      end loop;\n-\n-      Maps_Table.Table (Res).Assoc_Next := Associations_Table.Last;\n-      return Res;\n-   end Build_Instance_Map;\n-\n-   -------------\n-   -- Compose --\n-   -------------\n-\n-   function Compose (Orig_Map : Map; New_Map : Map) return Map is\n-      Res : constant Map         := Copy (Orig_Map);\n-      Off : constant Assoc_Index := Maps_Table.Table (Res).Assoc_Offset;\n-      A   : Assoc;\n-      K   : Assoc_Index;\n-\n-   begin\n-      --  Iterate over the contents of Orig_Map, looking for entities\n-      --  that are further mapped under New_Map.\n-\n-      for J in 0 .. Maps_Table.Table (Res).Assoc_Num - 1  loop\n-         A := Associations_Table.Table (Off + J);\n-         K := Find_Assoc (New_Map, A.New_Id);\n-\n-         if K /= No_Assoc then\n-            Associations_Table.Table (Off + J).New_Id\n-              := Associations_Table.Table (K).New_Id;\n-         end if;\n-      end loop;\n-\n-      return Res;\n-   end Compose;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy (M : Map) return Map is\n-      Info    : constant Map_Info     := Maps_Table.Table (M);\n-      Res     : constant Map          := New_Map (Int (Info.Assoc_Num));\n-      Offh1   : constant Header_Index := Info.Header_Offset;\n-      Offa1   : constant Assoc_Index  := Info.Assoc_Offset;\n-      Offh2   : constant Header_Index := Maps_Table.Table (Res).Header_Offset;\n-      Offa2   : constant Assoc_Index  := Maps_Table.Table (Res).Assoc_Offset;\n-      A       : Assoc;\n-      A_Index : Assoc_Index;\n-\n-   begin\n-      for J in 0 .. Info.Header_Num - 1 loop\n-         A_Index := Headers_Table.Table (Offh1 + J) + (Offa2 - Offa1);\n-\n-         if A_Index /= No_Assoc then\n-            Headers_Table.Table (Offh2 + J) := A_Index + (Offa2 - Offa1);\n-         end if;\n-      end loop;\n-\n-      for J in 0 .. Info.Assoc_Num - 1 loop\n-         A := Associations_Table.Table (Offa1 + J);\n-         A.Next := A.Next + (Offa2 - Offa1);\n-         Associations_Table.Table (Offa2 + J) := A;\n-      end loop;\n-\n-      Maps_Table.Table (Res).Assoc_Next := Associations_Table.Last;\n-      return Res;\n-   end Copy;\n-\n-   ----------------\n-   -- Find_Assoc --\n-   ----------------\n-\n-   function Find_Assoc (M : Map; E : Entity_Id) return Assoc_Index is\n-      Offh    : constant Header_Index := Maps_Table.Table (M).Header_Offset;\n-      Offs    : constant Header_Index := Maps_Table.Table (M).Header_Num;\n-      J       : constant Header_Index := Header_Index (E) mod Offs;\n-      A       : Assoc;\n-      A_Index : Assoc_Index;\n-\n-   begin\n-      A_Index := Headers_Table.Table (Offh + J);\n-\n-      if A_Index = No_Assoc then\n-         return A_Index;\n-\n-      else\n-         A := Associations_Table.Table (A_Index);\n-\n-         while Present (A.Old_Id) loop\n-\n-            if A.Old_Id = E then\n-               return A_Index;\n-\n-            elsif A.Next = No_Assoc then\n-               return No_Assoc;\n-\n-            else\n-               A_Index := A.Next;\n-               A := Associations_Table.Table (A.Next);\n-            end if;\n-         end loop;\n-\n-         return No_Assoc;\n-      end if;\n-   end Find_Assoc;\n-\n-   ----------------------\n-   -- Find_Header_Size --\n-   ----------------------\n-\n-   function Find_Header_Size (N : Int) return Header_Index is\n-      Siz : Header_Index;\n-\n-   begin\n-      Siz := 2;\n-      while 2 * Siz < Header_Index (N) loop\n-         Siz := 2 * Siz;\n-      end loop;\n-\n-      return Siz;\n-   end Find_Header_Size;\n-\n-   ------------\n-   -- Lookup --\n-   ------------\n-\n-   function Lookup (M : Map; E : Entity_Id) return Entity_Id is\n-      Offh : constant Header_Index := Maps_Table.Table (M).Header_Offset;\n-      Offs : constant Header_Index := Maps_Table.Table (M).Header_Num;\n-      J    : constant Header_Index := Header_Index (E) mod Offs;\n-      A    : Assoc;\n-\n-   begin\n-      if Headers_Table.Table (Offh + J) = No_Assoc then\n-         return Empty;\n-\n-      else\n-         A := Associations_Table.Table (Headers_Table.Table (Offh + J));\n-\n-         while Present (A.Old_Id) loop\n-\n-            if A.Old_Id = E then\n-               return A.New_Id;\n-\n-            elsif A.Next = No_Assoc then\n-               return Empty;\n-\n-            else\n-               A := Associations_Table.Table (A.Next);\n-            end if;\n-         end loop;\n-\n-         return Empty;\n-      end if;\n-   end Lookup;\n-\n-   -------------\n-   -- New_Map --\n-   -------------\n-\n-   function New_Map (Num_Assoc : Int) return Map is\n-      Header_Size : constant Header_Index := Find_Header_Size (Num_Assoc);\n-      Res         : Map_Info;\n-\n-   begin\n-      --  Allocate the tables for the new map at the current end of the\n-      --  global tables.\n-\n-      Associations_Table.Increment_Last;\n-      Headers_Table.Increment_Last;\n-      Maps_Table.Increment_Last;\n-\n-      Res.Header_Offset := Headers_Table.Last;\n-      Res.Header_Num    := Header_Size;\n-      Res.Assoc_Offset  := Associations_Table.Last;\n-      Res.Assoc_Next    := Associations_Table.Last;\n-      Res.Assoc_Num     := Assoc_Index (Num_Assoc);\n-\n-      Headers_Table.Set_Last (Headers_Table.Last + Header_Size);\n-      Associations_Table.Set_Last\n-        (Associations_Table.Last + Assoc_Index (Num_Assoc));\n-      Maps_Table.Table (Maps_Table.Last) := Res;\n-\n-      for J in 1 .. Header_Size loop\n-         Headers_Table.Table (Headers_Table.Last - J) := No_Assoc;\n-      end loop;\n-\n-      return Maps_Table.Last;\n-   end New_Map;\n-\n-   ------------------------\n-   -- Update_Association --\n-   ------------------------\n-\n-   procedure Update_Association\n-     (M    : Map;\n-      O_Id : Entity_Id;\n-      N_Id : Entity_Id;\n-      Kind : Scope_Kind := S_Local)\n-   is\n-      J : constant Assoc_Index := Find_Assoc (M, O_Id);\n-\n-   begin\n-      Associations_Table.Table (J).New_Id := N_Id;\n-      Associations_Table.Table (J).Kind := Kind;\n-   end Update_Association;\n-\n-   ---------------\n-   -- Write_Map --\n-   ---------------\n-\n-   procedure Write_Map (E : Entity_Id) is\n-      M    : constant Map          := Map (UI_To_Int (Renaming_Map (E)));\n-      Info : constant Map_Info     := Maps_Table.Table (M);\n-      Offh : constant Header_Index := Info.Header_Offset;\n-      Offa : constant Assoc_Index  := Info.Assoc_Offset;\n-      A    : Assoc;\n-\n-   begin\n-      Write_Str (\"Size : \");\n-      Write_Int (Int (Info.Assoc_Num));\n-      Write_Eol;\n-\n-      Write_Str (\"Headers\");\n-      Write_Eol;\n-\n-      for J in 0 .. Info.Header_Num - 1 loop\n-         Write_Int (Int (Offh + J));\n-         Write_Str (\" : \");\n-         Write_Int (Int (Headers_Table.Table (Offh + J)));\n-         Write_Eol;\n-      end loop;\n-\n-      for J in 0 .. Info.Assoc_Num - 1 loop\n-         A := Associations_Table.Table (Offa + J);\n-         Write_Int (Int (Offa + J));\n-         Write_Str (\" : \");\n-         Write_Name (Chars (A.Old_Id));\n-         Write_Str (\"  \");\n-         Write_Int (Int (A.Old_Id));\n-         Write_Str (\" ==> \");\n-         Write_Int (Int (A.New_Id));\n-         Write_Str (\" next = \");\n-         Write_Int (Int (A.Next));\n-         Write_Eol;\n-      end loop;\n-   end Write_Map;\n-\n-end Sem_Maps;"}, {"sha": "713999f92cc0306581a2d07d748666342b17b0d4", "filename": "gcc/ada/sem_maps.ads", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fsem_maps.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fsem_maps.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_maps.ads?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -1,167 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             S E M _ M A P S                              --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1996-2007, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains the operations on the renaming maps used for\n---  generic analysis and instantiation. Renaming maps are created when\n---  a generic unit is analyzed, in order to capture all references to\n---  global variables within the unit. The renaming map of a generic unit\n---  copied prior to each instantiation, and then updated by mapping the\n---  formals into the actuals and the local entities into entities local to\n---  the instance. When the generic tree is copied to produce the instance,\n---  all references are updated by means of the renaming map.\n-\n---  Map composition of renaming maps takes place for nested instantiations,\n---  for generic child units, and for formal packages.\n-\n---  For additional details, see the documentation in sem_ch12\n-\n-with Table;\n-with Types; use Types;\n-\n-package Sem_Maps is\n-\n-   type Map is new Int;\n-\n-   type Assoc is private;\n-\n-   type Scope_Kind is (S_Global, S_Formal, S_Local);\n-\n-   function New_Map (Num_Assoc : Int) return Map;\n-   --  Build empty map with the given number of associations, and a\n-   --  headers table of the appropriate size.\n-\n-   function Compose (Orig_Map : Map; New_Map : Map) return Map;\n-   --  Update the associations in Orig_Map, so that if Orig_Map (e1) = e2\n-   --  and New_Map (e2) = e3, then the image of e1 under the result is e3.\n-\n-   function Copy (M : Map) return Map;\n-   --  Full copy of contents and headers\n-\n-   function Lookup (M : Map; E : Entity_Id) return Entity_Id;\n-   --  Retrieve image of E under M, Empty if undefined\n-\n-   procedure Add_Association\n-     (M    : Map;\n-      O_Id : Entity_Id;\n-      N_Id : Entity_Id;\n-      Kind : Scope_Kind := S_Local);\n-   --  Update M in place. On entry M (O_Id) must not be defined\n-\n-   procedure Update_Association\n-     (M    : Map;\n-      O_Id : Entity_Id;\n-      N_Id : Entity_Id;\n-      Kind : Scope_Kind := S_Local);\n-   --  Update the entry in M for O_Id\n-\n-   function Build_Instance_Map (M : Map) return Map;\n-   --  Copy renaming map of generic, and create new entities for all the\n-   --  local entities within.\n-\n-private\n-\n-   --  New maps are created when a generic is analyzed, and for each of\n-   --  its instantiations. Maps are also updated for nested generics, for\n-   --  child units, and for formal packages. As a result we need to allocate\n-   --  maps dynamically.\n-\n-   --  When analyzing a generic, we do not know how many references are\n-   --  in it. We build an initial map after generic analysis, using a static\n-   --  structure that relies on the compiler's extensible table mechanism.\n-   --  After constructing this initial map, all subsequent uses and updates\n-   --  of this map do not modify its domain, so that dynamically allocated\n-   --  maps have a fixed size and never need to be reallocated. Furthermore,\n-   --  the headers of the hash table of a dynamically allocated map can be\n-   --  chosen according to the total number of entries in the map, to\n-   --  accommodate efficiently generic units of different sizes (Unchecked_\n-   --  Conversion vs. Generic_Elementary_Functions, for example). So in\n-   --  fact both components of a map have fixed size, and can be allocated\n-   --  using the standard table mechanism. A Maps_Table holds records that\n-   --  contain indices into the global Headers table and the Associations\n-   --  table, and a Map is an index into the Maps_Table.\n-   --\n-   --              Maps_Table          Headers_Table     Associations_Table\n-   --\n-   --                                    |_____|          |___________ |\n-   --               |_____|              |     |          |            |\n-   --        ------>|Map  |------------------------------>|Associations|\n-   --               |Info |------------->|     |=========>| for one    |\n-   --               |_____|              |     |====|     |   unit     |\n-   --               |     |              |     |    |====>|            |\n-   --                                    |_____|          |____________|\n-   --                                    |     |          |            |\n-   type Header_Index is new Int;\n-   type Assoc_Index  is new Int;\n-   No_Assoc : constant Assoc_Index := -1;\n-\n-   type Map_Info is record\n-      Header_Offset : Header_Index;\n-      Header_Num    : Header_Index;\n-      Assoc_Offset  : Assoc_Index;\n-      Assoc_Num     : Assoc_Index;\n-      Assoc_Next    : Assoc_Index;\n-   end record;\n-\n-   type Assoc is record\n-      Old_Id : Entity_Id   := Empty;\n-      New_Id : Entity_Id   := Empty;\n-      Kind   : Scope_Kind  := S_Local;\n-      Next   : Assoc_Index := No_Assoc;\n-   end record;\n-\n-   --  All maps are accessed through the following table. The map attribute\n-   --  of a generic unit or an instance is an index into this table.\n-\n-   package Maps_Table is new Table.Table (\n-      Table_Component_Type => Map_Info,\n-      Table_Index_Type     => Map,\n-      Table_Low_Bound      => 0,\n-      Table_Initial        => 100,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Maps_Table\");\n-\n-   --  All headers for hash tables are allocated in one global table. Each\n-   --  map stores the offset into this table at which its own headers start.\n-\n-   package Headers_Table is new Table.Table (\n-      Table_Component_Type => Assoc_Index,\n-      Table_Index_Type     => Header_Index,\n-      Table_Low_Bound      => 0,\n-      Table_Initial        => 1000,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Headers_Table\");\n-\n-   --  All associations are allocated in one global table. Each map stores\n-   --  the offset into this table at which its own associations start.\n-\n-   package Associations_Table is new Table.Table (\n-      Table_Component_Type => Assoc,\n-      Table_Index_Type     => Assoc_Index,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 1000,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Associations_Table\");\n-\n-end Sem_Maps;"}]}