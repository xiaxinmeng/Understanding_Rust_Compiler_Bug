{"sha": "7de4d00450a017b0edbbbf620dcfc5d9326f163c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RlNGQwMDQ1MGEwMTdiMGVkYmJiZjYyMGRjZmM1ZDkzMjZmMTYzYw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-09-25T22:34:53Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-09-25T22:34:53Z"}, "message": "cpphash.h (_cpp_digraph_spellings, [...]): New library-internal prototypes.\n\n\t* cpphash.h (_cpp_digraph_spellings, _cpp_process_directive,\n\t_cpp_can_paste): New library-internal prototypes.\n\t* cpplex.c (dump_param_spelling, output_line_command,\n\toutput_token, cpp_scan_buffer, cpp_scan_buffer_nooutput,\n\tcpp_printf, cpp_output_list): Move to cppoutput.c.\n\t(process_directive, can_paste, digraph_spellings): Add _cpp_ prefix.\n\t* cppmacro.c (dump_macro_args, cpp_dump_definition) Move to\n\tcppoutput.c.\n\t* cppoutput.c (dump_macro_args, cpp_dump_definition, output_token,\n\tdump_param_spelling, output_line_command, cpp_scan_buffer,\n\tcpp_scan_buffer_nooutput, cpp_printf, cpp_output_list): Moved\n\tfrom elsewhere.\n\t* Makefile.in: Add cppoutput.c.\n\t* po/POTFILES.in: Add cppoutput.c.\n\nFrom-SVN: r36634", "tree": {"sha": "e04909d8f7efef588ecf5b034183af04dbc5316d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e04909d8f7efef588ecf5b034183af04dbc5316d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7de4d00450a017b0edbbbf620dcfc5d9326f163c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de4d00450a017b0edbbbf620dcfc5d9326f163c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7de4d00450a017b0edbbbf620dcfc5d9326f163c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de4d00450a017b0edbbbf620dcfc5d9326f163c/comments", "author": null, "committer": null, "parents": [{"sha": "dcbd43e030914368ca0b5c089dc32cf8a208113d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcbd43e030914368ca0b5c089dc32cf8a208113d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcbd43e030914368ca0b5c089dc32cf8a208113d"}], "stats": {"total": 803, "additions": 423, "deletions": 380}, "files": [{"sha": "17a33151f942a40b9a0828531ef3068c979d13d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7de4d00450a017b0edbbbf620dcfc5d9326f163c", "patch": "@@ -1,3 +1,20 @@\n+Mon 25-Sep-2000 23:31:45 BST  Neil Booth  <neilb@earthling.net>\n+\n+\t* cpphash.h (_cpp_digraph_spellings, _cpp_process_directive,\n+\t_cpp_can_paste): New library-internal prototypes.\n+\t* cpplex.c (dump_param_spelling, output_line_command,\n+\toutput_token, cpp_scan_buffer, cpp_scan_buffer_nooutput,\n+\tcpp_printf, cpp_output_list): Move to cppoutput.c.\n+\t(process_directive, can_paste, digraph_spellings): Add _cpp_ prefix.\n+\t* cppmacro.c (dump_macro_args, cpp_dump_definition) Move to\n+\tcppoutput.c.\n+\t* cppoutput.c (dump_macro_args, cpp_dump_definition, output_token,\n+\tdump_param_spelling, output_line_command, cpp_scan_buffer,\n+\tcpp_scan_buffer_nooutput, cpp_printf, cpp_output_list): Moved\n+\tfrom elsewhere.\n+\t* Makefile.in: Add cppoutput.c.\n+\t* po/POTFILES.in: Add cppoutput.c.\n+\n 2000-09-25  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64.c (ia64_print_operand): Define 'e' as 64-n."}, {"sha": "f5cd9dc7714fc0f02f6263ca2c50d861a04c6ab0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7de4d00450a017b0edbbbf620dcfc5d9326f163c", "patch": "@@ -1792,7 +1792,7 @@ PREPROCESSOR_DEFINES = \\\n   -DTOOL_INCLUDE_DIR=\\\"$(gcc_tooldir)/include\\\"\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o \\\n-\t\tcpphash.o cpperror.o cppinit.o cppdefault.o \\\n+\t\tcpphash.o cpperror.o cppinit.o cppdefault.o cppoutput.o \\\n \t\tmkdeps.o prefix.o version.o mbchar.o @extra_cpp_objs@\n \n LIBCPP_DEPS =\tcpplib.h cpphash.h intl.h system.h\n@@ -1814,6 +1814,7 @@ cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS) defaults.h\n cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cppmacro.o: cppmacro.c $(CONFIG_H) $(LIBCPP_DEPS)\n+cppoutput.o: cppoutput.c $(CONFIG_H) $(LIBCPP_DEPS)\n cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h"}, {"sha": "fed1cf4b49299e7a6c1db5d73614a995aba0570f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=7de4d00450a017b0edbbbf620dcfc5d9326f163c", "patch": "@@ -231,6 +231,7 @@ extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *, cpp_buffer *));\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n \n /* In cpplex.c */\n+extern const unsigned char *_cpp_digraph_spellings[];\n extern void _cpp_skip_rest_of_line\tPARAMS ((cpp_reader *));\n extern void _cpp_free_temp_tokens\tPARAMS ((cpp_reader *));\n extern void _cpp_init_input_buffer\tPARAMS ((cpp_reader *));\n@@ -247,6 +248,7 @@ extern void _cpp_reserve_name_space\tPARAMS ((cpp_toklist *, unsigned int));\n extern void _cpp_expand_name_space\tPARAMS ((cpp_toklist *, unsigned int));\n extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const cpp_token *));\n+extern void _cpp_process_directive PARAMS ((cpp_reader *, const cpp_token *));\n extern void _cpp_run_directive\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const struct directive *,\n \t\t\t\t\t\t const char *, size_t,\n@@ -257,6 +259,8 @@ extern const cpp_token *_cpp_get_token PARAMS ((cpp_reader *));\n extern const cpp_token *_cpp_get_raw_token PARAMS ((cpp_reader *));\n extern void _cpp_push_token PARAMS ((cpp_reader *, const cpp_token*));\n extern const cpp_token *_cpp_glue_header_name PARAMS ((cpp_reader *));\n+extern enum cpp_ttype _cpp_can_paste PARAMS ((cpp_reader *, const cpp_token *,\n+\t\t\t\t\t      const cpp_token *, int *));\n \n /* In cpplib.c */\n extern const struct directive *_cpp_check_directive"}, {"sha": "c07c721bc088d8489c38bb7072656669965e993c", "filename": "gcc/cpplex.c", "status": "modified", "additions": 9, "deletions": 327, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=7de4d00450a017b0edbbbf620dcfc5d9326f163c", "patch": "@@ -41,6 +41,8 @@ o Correct pastability test for CPP_NAME and CPP_NUMBER.\n #include \"cpphash.h\"\n #include \"symcat.h\"\n \n+const unsigned char *_cpp_digraph_spellings [] = {U\"%:\", U\"%:%:\", U\"<:\",\n+\t\t\t\t\t\t  U\":>\", U\"<%\", U\"%>\"};\n static const cpp_token placemarker_token = {0, 0, CPP_PLACEMARKER,\n \t\t\t\t\t    0 UNION_INIT_ZERO};\n static const cpp_token eof_token = {0, 0, CPP_EOF, 0 UNION_INIT_ZERO};\n@@ -90,10 +92,6 @@ static int pop_context PARAMS ((cpp_reader *));\n static int push_macro_context PARAMS ((cpp_reader *, const cpp_token *));\n static void push_arg_context PARAMS ((cpp_reader *, const cpp_token *));\n static void free_macro_args PARAMS ((macro_args *));\n-static void dump_param_spelling PARAMS ((FILE *, const cpp_toklist *,\n-\t\t\t\t\t unsigned int));\n-static void output_line_command PARAMS ((cpp_reader *, cpp_printer *,\n-\t\t\t\t\t unsigned int));\n \n static cppchar_t handle_newline PARAMS ((cpp_buffer *, cppchar_t));\n static cppchar_t skip_escaped_newlines PARAMS ((cpp_buffer *, cppchar_t));\n@@ -115,16 +113,13 @@ static void lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n static void lex_token PARAMS ((cpp_reader *, cpp_token *));\n static int lex_next PARAMS ((cpp_reader *, int));\n \n-static void process_directive\tPARAMS ((cpp_reader *, const cpp_token *));\n static int is_macro_disabled PARAMS ((cpp_reader *, const cpp_toklist *,\n \t\t\t\t      const cpp_token *));\n \n static cpp_token *stringify_arg PARAMS ((cpp_reader *, const cpp_token *));\n static void expand_context_stack PARAMS ((cpp_reader *));\n static unsigned char * spell_token PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t\t    unsigned char *));\n-static void output_token PARAMS ((cpp_reader *, FILE *, const cpp_token *,\n-\t\t\t\t  const cpp_token *, int));\n typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n \t\t\t\t\t  cpp_token *));\n static cpp_token *make_string_token PARAMS ((cpp_token *, const U_CHAR *,\n@@ -135,14 +130,11 @@ static const cpp_token *special_symbol PARAMS ((cpp_reader *, cpp_hashnode *,\n static cpp_token *duplicate_token PARAMS ((cpp_reader *, const cpp_token *));\n static const cpp_token *maybe_paste_with_next PARAMS ((cpp_reader *,\n \t\t\t\t\t\t       const cpp_token *));\n-static enum cpp_ttype can_paste PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t\t const cpp_token *, int *));\n static unsigned int prevent_macro_expansion\tPARAMS ((cpp_reader *));\n static void restore_macro_expansion\tPARAMS ((cpp_reader *, unsigned int));\n static cpp_token *get_temp_token\tPARAMS ((cpp_reader *));\n static void release_temp_tokens\t\tPARAMS ((cpp_reader *));\n static U_CHAR * quote_string PARAMS ((U_CHAR *, const U_CHAR *, unsigned int));\n-static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n \n #define VALID_SIGN(c, prevc) \\\n   (((c) == '+' || (c) == '-') && \\\n@@ -194,167 +186,6 @@ _cpp_token_spellings [N_TTYPES] = {TTYPE_TABLE };\n #undef OP\n #undef TK\n \n-/* Notify the compiler proper that the current line number has jumped,\n-   or the current file name has changed.  */\n-\n-static void\n-output_line_command (pfile, print, line)\n-     cpp_reader *pfile;\n-     cpp_printer *print;\n-     unsigned int line;\n-{\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-\n-  if (line == 0)\n-    return;\n-\n-  /* End the previous line of text.  */\n-  if (pfile->need_newline)\n-    {\n-      putc ('\\n', print->outf);\n-      print->lineno++;\n-    }\n-  pfile->need_newline = 0;\n-\n-  if (CPP_OPTION (pfile, no_line_commands))\n-    return;\n-\n-  /* If the current file has not changed, we can output a few newlines\n-     instead if we want to increase the line number by a small amount.\n-     We cannot do this if print->lineno is zero, because that means we\n-     haven't output any line commands yet.  (The very first line\n-     command output is a `same_file' command.)\n-\n-     'nominal_fname' values are unique, so they can be compared by\n-     comparing pointers.  */\n-  if (ip->nominal_fname == print->last_fname && print->lineno > 0\n-      && line >= print->lineno && line < print->lineno + 8)\n-    {\n-      while (line > print->lineno)\n-\t{\n-\t  putc ('\\n', print->outf);\n-\t  print->lineno++;\n-\t}\n-      return;\n-    }\n-\n-  fprintf (print->outf, \"# %u \\\"%s\\\"%s\\n\", line, ip->nominal_fname,\n-\t   cpp_syshdr_flags (pfile, ip));\n-\n-  print->last_fname = ip->nominal_fname;\n-  print->lineno = line;\n-}\n-\n-/* Like fprintf, but writes to a printer object.  You should be sure\n-   always to generate a complete line when you use this function.  */\n-void\n-cpp_printf VPARAMS ((cpp_reader *pfile, cpp_printer *print,\n-\t\t     const char *fmt, ...))\n-{\n-  va_list ap;\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  cpp_printer *print;\n-  const char *fmt;\n-#endif\n-\n-  VA_START (ap, fmt);\n-\n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  print = va_arg (ap, cpp_printer *);\n-  fmt = va_arg (ap, const char *);\n-#endif\n-\n-  /* End the previous line of text.  */\n-  if (pfile->need_newline)\n-    {\n-      putc ('\\n', print->outf);\n-      print->lineno++;\n-    }\n-  pfile->need_newline = 0;\n-\n-  vfprintf (print->outf, fmt, ap);\n-  va_end (ap);\n-}\n-\n-/* Scan until CPP_BUFFER (PFILE) is exhausted, discarding output.  */\n-\n-void\n-cpp_scan_buffer_nooutput (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *stop = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n-  const cpp_token *token;\n-\n-  /* In no-output mode, we can ignore everything but directives.  */\n-  for (;;)\n-    {\n-      token = _cpp_get_token (pfile);\n-\n-      if (token->type == CPP_EOF)\n-\t{\n-\t  cpp_pop_buffer (pfile);\n-\t  if (CPP_BUFFER (pfile) == stop)\n-\t    break;\n-\t}\n-\n-      if (token->type == CPP_HASH && token->flags & BOL\n-\t  && pfile->token_list.directive)\n-\t{\n-\t  process_directive (pfile, token);\n-\t  continue;\n-\t}\n-\n-      _cpp_skip_rest_of_line (pfile);\n-    }\n-}\n-\n-/* Scan until CPP_BUFFER (pfile) is exhausted, writing output to PRINT.  */\n-void\n-cpp_scan_buffer (pfile, print)\n-     cpp_reader *pfile;\n-     cpp_printer *print;\n-{\n-  cpp_buffer *stop = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n-  const cpp_token *token, *prev = 0;\n-\n-  for (;;)\n-    {\n-      token = _cpp_get_token (pfile);\n-      if (token->type == CPP_EOF)\n-\t{\n-\t  cpp_pop_buffer (pfile);\n-\n-\t  if (CPP_BUFFER (pfile) == stop)\n-\t    return;\n-\n-\t  prev = 0;\n-\t  continue;\n-\t}\n-\n-      if (token->flags & BOL)\n-\t{\n-\t  output_line_command (pfile, print, token->line);\n-\t  prev = 0;\n-\n-\t  if (token->type == CPP_HASH && pfile->token_list.directive)\n-\t    {\n-\t      process_directive (pfile, token);\n-\t      continue;\n-\t    }\n-\t}\n-\n-      if (token->type != CPP_PLACEMARKER)\n-\t{\n-\t  output_token (pfile, print->outf, token, prev, 1);\n-\t  pfile->need_newline = 1;\n-\t}\n-\n-      prev = token;\n-    }\n-}\n-\n /* Helper routine used by parse_include, which can't see spell_token.\n    Reinterpret the current line as an h-char-sequence (< ... >); we are\n    looking at the first token after the <.  */\n@@ -564,9 +395,6 @@ cpp_ideq (token, string)\n   return !ustrcmp (token->val.node->name, (const U_CHAR *)string);\n }\n \n-static const unsigned char *digraph_spellings [] = {U\"%:\", U\"%:%:\", U\"<:\",\n-\t\t\t\t\t\t    U\":>\", U\"<%\", U\"%>\"};\n-\n /* Call when meeting a newline.  Returns the character after the newline\n    (or carriage-return newline combination), or EOF.  */\n static cppchar_t\n@@ -1714,152 +1542,6 @@ lex_line (pfile, list)\n   pfile->state.in_lex_line = 0;\n }\n \n-/* Write the spelling of a token TOKEN, with any appropriate\n-   whitespace before it, to FP.  PREV is the previous token, which\n-   is used to determine if we need to shove in an extra space in order\n-   to avoid accidental token paste.  If WHITE is 0, do not insert any\n-   leading whitespace.  */\n-static void\n-output_token (pfile, fp, token, prev, white)\n-     cpp_reader *pfile;\n-     FILE *fp;\n-     const cpp_token *token, *prev;\n-     int white;\n-{\n-  if (white)\n-    {\n-      int dummy;\n-\n-      if (token->col && (token->flags & BOL))\n-\t{\n-\t  /* Supply enough whitespace to put this token in its original\n-\t     column.  Don't bother trying to reconstruct tabs; we can't\n-\t     get it right in general, and nothing ought to care.  (Yes,\n-\t     some things do care; the fault lies with them.)  */\n-\t  unsigned int spaces = token->col - 1;\n-      \n-\t  while (spaces--)\n-\t    putc (' ', fp);\n-\t}\n-      else if (token->flags & PREV_WHITE)\n-\tputc (' ', fp);\n-      else\n-      /* Check for and prevent accidental token pasting.\n-\t In addition to the cases handled by can_paste, consider\n-\n-\t a + ++b - if there is not a space between the + and ++, it\n-\t will be misparsed as a++ + b.  But + ## ++ doesn't produce\n-\t a valid token.  */\n-\tif (prev\n-\t    && (can_paste (pfile, prev, token, &dummy) != CPP_EOF\n-\t\t|| (prev->type == CPP_PLUS && token->type == CPP_PLUS_PLUS)\n-\t\t|| (prev->type == CPP_MINUS && token->type == CPP_MINUS_MINUS)))\n-\tputc (' ', fp);\n-    }\n-\n-  switch (TOKEN_SPELL (token))\n-    {\n-    case SPELL_OPERATOR:\n-      {\n-\tconst unsigned char *spelling;\n-\n-\tif (token->flags & DIGRAPH)\n-\t  spelling = digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n-\telse if (token->flags & NAMED_OP)\n-\t  goto spell_ident;\n-\telse\n-\t  spelling = TOKEN_NAME (token);\n-\n-\tufputs (spelling, fp);\n-      }\n-      break;\n-\n-    case SPELL_IDENT:\n-      spell_ident:\n-      ufputs (token->val.node->name, fp);\n-      break;\n-\n-    case SPELL_STRING:\n-      {\n-\tint left, right, tag;\n-\tswitch (token->type)\n-\t  {\n-\t  case CPP_STRING:\tleft = '\"';  right = '\"';  tag = '\\0'; break;\n-\t  case CPP_WSTRING:\tleft = '\"';  right = '\"';  tag = 'L';  break;\n-\t  case CPP_OSTRING:\tleft = '\"';  right = '\"';  tag = '@';  break;\n-\t  case CPP_CHAR:\tleft = '\\''; right = '\\''; tag = '\\0'; break;\n-    \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n-\t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n-\t  default:\t\tleft = '\\0'; right = '\\0'; tag = '\\0'; break;\n-\t  }\n-\tif (tag) putc (tag, fp);\n-\tif (left) putc (left, fp);\n-\tfwrite (token->val.str.text, 1, token->val.str.len, fp);\n-\tif (right) putc (right, fp);\n-      }\n-      break;\n-\n-    case SPELL_CHAR:\n-      putc (token->val.aux, fp);\n-      break;\n-\n-    case SPELL_NONE:\n-      /* Placemarker or EOF - no output.  (Macro args are handled\n-         elsewhere.  */\n-      break;\n-    }\n-}\n-\n-/* Dump the original user's spelling of argument index ARG_NO to the\n-   macro whose expansion is LIST.  */\n-static void\n-dump_param_spelling (fp, list, arg_no)\n-     FILE *fp;\n-     const cpp_toklist *list;\n-     unsigned int arg_no;\n-{\n-  const U_CHAR *param = list->namebuf;\n-\n-  while (arg_no--)\n-    param += ustrlen (param) + 1;\n-  ufputs (param, fp);\n-}\n-\n-/* Output all the tokens of LIST, starting at TOKEN, to FP.  */\n-void\n-cpp_output_list (pfile, fp, list, token)\n-     cpp_reader *pfile;\n-     FILE *fp;\n-     const cpp_toklist *list;\n-     const cpp_token *token;\n-{\n-  const cpp_token *limit = list->tokens + list->tokens_used;\n-  const cpp_token *prev = 0;\n-  int white = 0;\n-\n-  while (token < limit)\n-    {\n-      /* XXX Find some way we can write macro args from inside\n-\t output_token/spell_token.  */\n-      if (token->type == CPP_MACRO_ARG)\n-\t{\n-\t  if (white && token->flags & PREV_WHITE)\n-\t    putc (' ', fp);\n-\t  if (token->flags & STRINGIFY_ARG)\n-\t    putc ('#', fp);\n-\t  dump_param_spelling (fp, list, token->val.aux);\n-\t}\n-      else\n-\toutput_token (pfile, fp, token, prev, white);\n-      if (token->flags & PASTE_LEFT)\n-\tfputs (\" ##\", fp);\n-      prev = token;\n-      token++;\n-      white = 1;\n-    }\n-}\n-\n-\n /* Write the spelling of a token TOKEN to BUFFER.  The buffer must\n    already contain the enough space to hold the token's spelling.\n    Returns a pointer to the character after the last character\n@@ -1879,7 +1561,7 @@ spell_token (pfile, token, buffer)\n \tunsigned char c;\n \n \tif (token->flags & DIGRAPH)\n-\t  spelling = digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n+\t  spelling = _cpp_digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n \telse if (token->flags & NAMED_OP)\n \t  goto spell_ident;\n \telse\n@@ -2501,8 +2183,8 @@ duplicate_token (pfile, token)\n    what the resulting token is.  Returns CPP_EOF if the tokens cannot\n    be pasted, or the appropriate type for the merged token if they\n    can.  */\n-static enum cpp_ttype\n-can_paste (pfile, token1, token2, digraph)\n+enum cpp_ttype\n+_cpp_can_paste (pfile, token1, token2, digraph)\n      cpp_reader * pfile;\n      const cpp_token *token1, *token2;\n      int* digraph;\n@@ -2651,7 +2333,7 @@ maybe_paste_with_next (pfile, token)\n       else\n \t{\n \t  int digraph = 0;\n-\t  enum cpp_ttype type = can_paste (pfile, token, second, &digraph);\n+\t  enum cpp_ttype type = _cpp_can_paste (pfile, token, second, &digraph);\n \n \t  if (type == CPP_EOF)\n \t    {\n@@ -2961,8 +2643,8 @@ _cpp_push_token (pfile, token)\n \n /* Handle a preprocessing directive.  TOKEN is the CPP_HASH token\n    introducing the directive.  */\n-static void\n-process_directive (pfile, token)\n+void\n+_cpp_process_directive (pfile, token)\n      cpp_reader *pfile;\n      const cpp_token *token;\n {\n@@ -3002,7 +2684,7 @@ cpp_get_token (pfile)\n       if (token->type == CPP_HASH && token->flags & BOL\n \t  && pfile->token_list.directive)\n \t{\n-\t  process_directive (pfile, token);\n+\t  _cpp_process_directive (pfile, token);\n \t  continue;\n \t}\n "}, {"sha": "321b318ea16a9ec2ea0e72c4e9a90f8d32f0d961", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=7de4d00450a017b0edbbbf620dcfc5d9326f163c", "patch": "@@ -40,7 +40,6 @@ struct macro_info\n   unsigned char flags;\n };\n \n-static void dump_macro_args PARAMS ((FILE *, const cpp_toklist *));\n static void count_params PARAMS ((cpp_reader *, struct macro_info *));\n static int is__va_args__ PARAMS ((cpp_reader *, const cpp_token *));\n \n@@ -577,57 +576,6 @@ _cpp_create_definition (pfile, hp)\n   return 1;\n }\n \n-/* Dump the definition of macro MACRO on FP.  The format is suitable\n-   to be read back in again.  Caller is expected to generate the\n-   \"#define NAME\" bit.  */\n-\n-void\n-cpp_dump_definition (pfile, fp, hp)\n-     cpp_reader *pfile;\n-     FILE *fp;\n-     const cpp_hashnode *hp;\n-{\n-  const cpp_toklist *list = hp->value.expansion;\n-\n-  if (hp->type != T_MACRO)\n-    {\n-      cpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n-      return;\n-    }\n-\n-  if (list->paramc >= 0)\n-    dump_macro_args (fp, list);\n-\n-  putc (' ', fp);\n-  cpp_output_list (pfile, fp, list, list->tokens);\n-}\n-\n-static void\n-dump_macro_args (fp, list)\n-     FILE *fp;\n-     const cpp_toklist *list;\n-{\n-  int i;\n-  const U_CHAR *param = list->namebuf;\n-\n-  putc ('(', fp);\n-  for (i = 0; i++ < list->paramc;)\n-    {\n-      unsigned int len;\n-\n-      len = ustrlen (param);\n-      if (!(list->flags & VAR_ARGS) || ustrcmp (param, U\"__VA_ARGS__\"))\n-\tufputs (param, fp);\n-      if (i < list->paramc)\n-\tfputs (\", \", fp);\n-      else if (list->flags & VAR_ARGS)\n-\tfputs (\"...\", fp);\n-\n-      param += len + 1;\n-    }\n-  putc (')', fp);\n-}\n-\n /* Warn if a token in `string' matches one of the function macro\n    arguments in `info'.  This function assumes that the macro is a\n    function macro and not an object macro.  */"}, {"sha": "53433ce4abd627443baf1b65308b274dc12bb20b", "filename": "gcc/cppoutput.c", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fcppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fcppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppoutput.c?ref=7de4d00450a017b0edbbbf620dcfc5d9326f163c", "patch": "@@ -0,0 +1,390 @@\n+/* CPP Library - non-diagnostic output.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Per Bothner, 1994-95.\n+   Based on CCCP program by Paul Rubin, June 1986\n+   Adapted to ANSI C, Richard Stallman, Jan 1987\n+   Broken out to separate file, Sep 2000\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"intl.h\"\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n+\n+static void output_line_command PARAMS ((cpp_reader *, cpp_printer *,\n+\t\t\t\t\t unsigned int));\n+static void output_token PARAMS ((cpp_reader *, FILE *, const cpp_token *,\n+\t\t\t\t  const cpp_token *, int));\n+static void dump_macro_args PARAMS ((FILE *, const cpp_toklist *));\n+static void dump_param_spelling PARAMS ((FILE *, const cpp_toklist *,\n+\t\t\t\t\t unsigned int));\n+\n+/* Scan until CPP_BUFFER (PFILE) is exhausted, discarding output.  Used\n+   for handling -imacros, -dM, -M and -MM.  */\n+void\n+cpp_scan_buffer_nooutput (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *stop = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n+  const cpp_token *token;\n+\n+  /* In no-output mode, we can ignore everything but directives.  */\n+  for (;;)\n+    {\n+      token = _cpp_get_token (pfile);\n+\n+      if (token->type == CPP_EOF)\n+\t{\n+\t  cpp_pop_buffer (pfile);\n+\t  if (CPP_BUFFER (pfile) == stop)\n+\t    break;\n+\t}\n+\n+      if (token->type == CPP_HASH && token->flags & BOL\n+\t  && pfile->token_list.directive)\n+\t{\n+\t  _cpp_process_directive (pfile, token);\n+\t  continue;\n+\t}\n+\n+      _cpp_skip_rest_of_line (pfile);\n+    }\n+}\n+\n+/* Scan until CPP_BUFFER (pfile) is exhausted, writing output to PRINT.  */\n+void\n+cpp_scan_buffer (pfile, print)\n+     cpp_reader *pfile;\n+     cpp_printer *print;\n+{\n+  cpp_buffer *stop = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n+  const cpp_token *token, *prev = 0;\n+\n+  for (;;)\n+    {\n+      token = _cpp_get_token (pfile);\n+      if (token->type == CPP_EOF)\n+\t{\n+\t  cpp_pop_buffer (pfile);\n+\n+\t  if (CPP_BUFFER (pfile) == stop)\n+\t    return;\n+\n+\t  prev = 0;\n+\t  continue;\n+\t}\n+\n+      if (token->flags & BOL)\n+\t{\n+\t  output_line_command (pfile, print, token->line);\n+\t  prev = 0;\n+\n+\t  if (token->type == CPP_HASH && pfile->token_list.directive)\n+\t    {\n+\t      _cpp_process_directive (pfile, token);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (token->type != CPP_PLACEMARKER)\n+\t{\n+\t  output_token (pfile, print->outf, token, prev, 1);\n+\t  pfile->need_newline = 1;\n+\t}\n+\n+      prev = token;\n+    }\n+}\n+\n+/* Notify the compiler proper that the current line number has jumped,\n+   or the current file name has changed.  */\n+static void\n+output_line_command (pfile, print, line)\n+     cpp_reader *pfile;\n+     cpp_printer *print;\n+     unsigned int line;\n+{\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n+\n+  if (line == 0)\n+    return;\n+\n+  /* End the previous line of text.  */\n+  if (pfile->need_newline)\n+    {\n+      putc ('\\n', print->outf);\n+      print->lineno++;\n+    }\n+  pfile->need_newline = 0;\n+\n+  if (CPP_OPTION (pfile, no_line_commands))\n+    return;\n+\n+  /* If the current file has not changed, we can output a few newlines\n+     instead if we want to increase the line number by a small amount.\n+     We cannot do this if print->lineno is zero, because that means we\n+     haven't output any line commands yet.  (The very first line\n+     command output is a `same_file' command.)\n+\n+     'nominal_fname' values are unique, so they can be compared by\n+     comparing pointers.  */\n+  if (ip->nominal_fname == print->last_fname && print->lineno > 0\n+      && line >= print->lineno && line < print->lineno + 8)\n+    {\n+      while (line > print->lineno)\n+\t{\n+\t  putc ('\\n', print->outf);\n+\t  print->lineno++;\n+\t}\n+      return;\n+    }\n+\n+  fprintf (print->outf, \"# %u \\\"%s\\\"%s\\n\", line, ip->nominal_fname,\n+\t   cpp_syshdr_flags (pfile, ip));\n+\n+  print->last_fname = ip->nominal_fname;\n+  print->lineno = line;\n+}\n+\n+/* Output all the tokens of LIST, starting at TOKEN, to FP.  */\n+void\n+cpp_output_list (pfile, fp, list, token)\n+     cpp_reader *pfile;\n+     FILE *fp;\n+     const cpp_toklist *list;\n+     const cpp_token *token;\n+{\n+  const cpp_token *limit = list->tokens + list->tokens_used;\n+  const cpp_token *prev = 0;\n+  int white = 0;\n+\n+  while (token < limit)\n+    {\n+      /* XXX Find some way we can write macro args from inside\n+\t output_token/spell_token.  */\n+      if (token->type == CPP_MACRO_ARG)\n+\t{\n+\t  if (white && token->flags & PREV_WHITE)\n+\t    putc (' ', fp);\n+\t  if (token->flags & STRINGIFY_ARG)\n+\t    putc ('#', fp);\n+\t  dump_param_spelling (fp, list, token->val.aux);\n+\t}\n+      else\n+\toutput_token (pfile, fp, token, prev, white);\n+      if (token->flags & PASTE_LEFT)\n+\tfputs (\" ##\", fp);\n+      prev = token;\n+      token++;\n+      white = 1;\n+    }\n+}\n+\n+/* Write the spelling of a token TOKEN, with any appropriate\n+   whitespace before it, to FP.  PREV is the previous token, which\n+   is used to determine if we need to shove in an extra space in order\n+   to avoid accidental token paste.  If WHITE is 0, do not insert any\n+   leading whitespace.  */\n+static void\n+output_token (pfile, fp, token, prev, white)\n+     cpp_reader *pfile;\n+     FILE *fp;\n+     const cpp_token *token, *prev;\n+     int white;\n+{\n+  if (white)\n+    {\n+      int dummy;\n+\n+      if (token->col && (token->flags & BOL))\n+\t{\n+\t  /* Supply enough whitespace to put this token in its original\n+\t     column.  Don't bother trying to reconstruct tabs; we can't\n+\t     get it right in general, and nothing ought to care.  (Yes,\n+\t     some things do care; the fault lies with them.)  */\n+\t  unsigned int spaces = token->col - 1;\n+      \n+\t  while (spaces--)\n+\t    putc (' ', fp);\n+\t}\n+      else if (token->flags & PREV_WHITE)\n+\tputc (' ', fp);\n+      else\n+      /* Check for and prevent accidental token pasting.\n+\t In addition to the cases handled by _cpp_can_paste, consider\n+\n+\t a + ++b - if there is not a space between the + and ++, it\n+\t will be misparsed as a++ + b.  But + ## ++ doesn't produce\n+\t a valid token.  */\n+\tif (prev\n+\t    && (_cpp_can_paste (pfile, prev, token, &dummy) != CPP_EOF\n+\t\t|| (prev->type == CPP_PLUS && token->type == CPP_PLUS_PLUS)\n+\t\t|| (prev->type == CPP_MINUS && token->type == CPP_MINUS_MINUS)))\n+\tputc (' ', fp);\n+    }\n+\n+  switch (TOKEN_SPELL (token))\n+    {\n+    case SPELL_OPERATOR:\n+      {\n+\tconst unsigned char *spelling;\n+\n+\tif (token->flags & DIGRAPH)\n+\t  spelling = _cpp_digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n+\telse if (token->flags & NAMED_OP)\n+\t  goto spell_ident;\n+\telse\n+\t  spelling = TOKEN_NAME (token);\n+\n+\tufputs (spelling, fp);\n+      }\n+      break;\n+\n+    case SPELL_IDENT:\n+      spell_ident:\n+      ufputs (token->val.node->name, fp);\n+      break;\n+\n+    case SPELL_STRING:\n+      {\n+\tint left, right, tag;\n+\tswitch (token->type)\n+\t  {\n+\t  case CPP_STRING:\tleft = '\"';  right = '\"';  tag = '\\0'; break;\n+\t  case CPP_WSTRING:\tleft = '\"';  right = '\"';  tag = 'L';  break;\n+\t  case CPP_OSTRING:\tleft = '\"';  right = '\"';  tag = '@';  break;\n+\t  case CPP_CHAR:\tleft = '\\''; right = '\\''; tag = '\\0'; break;\n+    \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n+\t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n+\t  default:\t\tleft = '\\0'; right = '\\0'; tag = '\\0'; break;\n+\t  }\n+\tif (tag) putc (tag, fp);\n+\tif (left) putc (left, fp);\n+\tfwrite (token->val.str.text, 1, token->val.str.len, fp);\n+\tif (right) putc (right, fp);\n+      }\n+      break;\n+\n+    case SPELL_CHAR:\n+      putc (token->val.aux, fp);\n+      break;\n+\n+    case SPELL_NONE:\n+      /* Placemarker or EOF - no output.  (Macro args are handled\n+         elsewhere.  */\n+      break;\n+    }\n+}\n+\n+/* Dump the original user's spelling of argument index ARG_NO to the\n+   macro whose expansion is LIST.  */\n+static void\n+dump_param_spelling (fp, list, arg_no)\n+     FILE *fp;\n+     const cpp_toklist *list;\n+     unsigned int arg_no;\n+{\n+  const U_CHAR *param = list->namebuf;\n+\n+  while (arg_no--)\n+    param += ustrlen (param) + 1;\n+  ufputs (param, fp);\n+}\n+\n+/* Dump the definition of macro MACRO on FP.  The format is suitable\n+   to be read back in again.  Caller is expected to generate the\n+   \"#define NAME\" bit.  */\n+\n+void\n+cpp_dump_definition (pfile, fp, hp)\n+     cpp_reader *pfile;\n+     FILE *fp;\n+     const cpp_hashnode *hp;\n+{\n+  const cpp_toklist *list = hp->value.expansion;\n+\n+  if (hp->type != T_MACRO)\n+    {\n+      cpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n+      return;\n+    }\n+\n+  if (list->paramc >= 0)\n+    dump_macro_args (fp, list);\n+\n+  putc (' ', fp);\n+  cpp_output_list (pfile, fp, list, list->tokens);\n+}\n+\n+static void\n+dump_macro_args (fp, list)\n+     FILE *fp;\n+     const cpp_toklist *list;\n+{\n+  int i;\n+  const U_CHAR *param = list->namebuf;\n+\n+  putc ('(', fp);\n+  for (i = 0; i++ < list->paramc;)\n+    {\n+      unsigned int len;\n+\n+      len = ustrlen (param);\n+      if (!(list->flags & VAR_ARGS) || ustrcmp (param, U\"__VA_ARGS__\"))\n+\tufputs (param, fp);\n+      if (i < list->paramc)\n+\tfputs (\", \", fp);\n+      else if (list->flags & VAR_ARGS)\n+\tfputs (\"...\", fp);\n+\n+      param += len + 1;\n+    }\n+  putc (')', fp);\n+}\n+\n+/* Like fprintf, but writes to a printer object.  You should be sure\n+   always to generate a complete line when you use this function.  */\n+void\n+cpp_printf VPARAMS ((cpp_reader *pfile, cpp_printer *print,\n+\t\t     const char *fmt, ...))\n+{\n+  va_list ap;\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  cpp_printer *print;\n+  const char *fmt;\n+#endif\n+\n+  VA_START (ap, fmt);\n+\n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  print = va_arg (ap, cpp_printer *);\n+  fmt = va_arg (ap, const char *);\n+#endif\n+\n+  /* End the previous line of text.  */\n+  if (pfile->need_newline)\n+    {\n+      putc ('\\n', print->outf);\n+      print->lineno++;\n+    }\n+  pfile->need_newline = 0;\n+\n+  vfprintf (print->outf, fmt, ap);\n+  va_end (ap);\n+}"}, {"sha": "66eccf9ac056b77d676086ed2fd295b3f75c95c7", "filename": "gcc/po/POTFILES.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fpo%2FPOTFILES.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de4d00450a017b0edbbbf620dcfc5d9326f163c/gcc%2Fpo%2FPOTFILES.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FPOTFILES.in?ref=7de4d00450a017b0edbbbf620dcfc5d9326f163c", "patch": "@@ -599,6 +599,7 @@ cpplex.c\n cpplib.c\n cpplib.h\n cppmain.c\n+cppoutput.c\n cppspec.c\n #crtstuff.c is part of the GCC library\n cse.c"}]}