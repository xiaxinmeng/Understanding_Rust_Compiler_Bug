{"sha": "980a0ff422442a1a0695df63ea48352df9578b09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgwYTBmZjQyMjQ0MmExYTA2OTVkZjYzZWE0ODM1MmRmOTU3OGIwOQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-03-22T19:37:35Z"}, "committer": {"name": "Denis Chertykov", "email": "denisc@gcc.gnu.org", "date": "2011-03-22T19:37:35Z"}, "message": "avr-protos.h (expand_epilogue): Change prototype\n\n\t* config/avr/avr-protos.h (expand_epilogue): Change prototype\n\t* config/avr/avr.h (struct machine_function): Add field sibcall_fails.\n\t* config/avr/avr.c (init_cumulative_args)\n\t(avr_function_arg_advance): Use it.\n\t* config/avr/avr.c (expand_epilogue): Add bool parameter. Handle\n\tsibcall epilogues.\n\t(TARGET_FUNCTION_OK_FOR_SIBCALL): Define to...\n\t(avr_function_ok_for_sibcall): ...this new function.\n\t(avr_lookup_function_attribute1): New static Function.\n\t(avr_naked_function_p, interrupt_function_p)\n\t(signal_function_p, avr_OS_task_function_p)\n\t(avr_OS_main_function_p): Use it.\n\t* config/avr/avr.md (\"sibcall\", \"sibcall_value\")\n\t(\"sibcall_epilogue\"): New expander.\n\t(\"*call_insn\", \"*call_value_insn\"): New insn.\n\t(\"call_insn\", \"call_value_insn\"): Remove\n\t(\"call\", \"call_value\", \"epilogue\"): Change expander to handle\n\tsibling calls.\n\nFrom-SVN: r171300", "tree": {"sha": "cb05f74aaccc4fd5a149ffccc42ab439ef9855fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb05f74aaccc4fd5a149ffccc42ab439ef9855fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/980a0ff422442a1a0695df63ea48352df9578b09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980a0ff422442a1a0695df63ea48352df9578b09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/980a0ff422442a1a0695df63ea48352df9578b09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980a0ff422442a1a0695df63ea48352df9578b09/comments", "author": null, "committer": null, "parents": [{"sha": "0d8c8b1b0279efdbdd66361c0693f06f038f0f54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8c8b1b0279efdbdd66361c0693f06f038f0f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8c8b1b0279efdbdd66361c0693f06f038f0f54"}], "stats": {"total": 332, "additions": 221, "deletions": 111}, "files": [{"sha": "283a80ed4cfa3d75ccdc6d41938a22623f994298", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=980a0ff422442a1a0695df63ea48352df9578b09", "patch": "@@ -1,3 +1,24 @@\n+2011-03-21  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr-protos.h (expand_epilogue): Change prototype\n+\t* config/avr/avr.h (struct machine_function): Add field sibcall_fails.\n+\t* config/avr/avr.c (init_cumulative_args)\n+\t(avr_function_arg_advance): Use it.\n+\t* config/avr/avr.c (expand_epilogue): Add bool parameter. Handle\n+\tsibcall epilogues.\n+\t(TARGET_FUNCTION_OK_FOR_SIBCALL): Define to...\n+\t(avr_function_ok_for_sibcall): ...this new function.\n+\t(avr_lookup_function_attribute1): New static Function.\n+\t(avr_naked_function_p, interrupt_function_p)\n+\t(signal_function_p, avr_OS_task_function_p)\n+\t(avr_OS_main_function_p): Use it.\n+\t* config/avr/avr.md (\"sibcall\", \"sibcall_value\")\n+\t(\"sibcall_epilogue\"): New expander.\n+\t(\"*call_insn\", \"*call_value_insn\"): New insn.\n+\t(\"call_insn\", \"call_value_insn\"): Remove\n+\t(\"call\", \"call_value\", \"epilogue\"): Change expander to handle\n+\tsibling calls.\n+\n 2011-03-21  Nick Clifton  <nickc@redhat.com>\n \n \t* doc/invoke.texi (Overall Options): Move closing brace to end of"}, {"sha": "b00637e069ef71b74f292922aaeea969984bc6d9", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=980a0ff422442a1a0695df63ea48352df9578b09", "patch": "@@ -76,7 +76,7 @@ extern const char *lshrsi3_out (rtx insn, rtx operands[], int *len);\n extern bool avr_rotate_bytes (rtx operands[]);\n \n extern void expand_prologue (void);\n-extern void expand_epilogue (void);\n+extern void expand_epilogue (bool);\n extern int avr_epilogue_uses (int regno);\n \n extern void avr_output_bld (rtx operands[], int bit_nr);"}, {"sha": "56b216b29e52d92f38e20ce030131964f91e4516", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 116, "deletions": 34, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=980a0ff422442a1a0695df63ea48352df9578b09", "patch": "@@ -102,6 +102,7 @@ static rtx avr_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n static void avr_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t      const_tree, bool);\n static void avr_help (void);\n+static bool avr_function_ok_for_sibcall (tree, tree);\n \n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n #define FIRST_CUM_REG 26\n@@ -249,6 +250,9 @@ static const struct default_options avr_option_optimization_table[] =\n #undef TARGET_EXCEPT_UNWIND_INFO\n #define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n \n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL avr_function_ok_for_sibcall\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n static void\n@@ -348,17 +352,34 @@ avr_regno_reg_class (int r)\n   return ALL_REGS;\n }\n \n+/* A helper for the subsequent function attribute used to dig for\n+   attribute 'name' in a FUNCTION_DECL or FUNCTION_TYPE */\n+\n+static inline int\n+avr_lookup_function_attribute1 (const_tree func, const char *name)\n+{\n+  if (FUNCTION_DECL == TREE_CODE (func))\n+    {\n+      if (NULL_TREE != lookup_attribute (name, DECL_ATTRIBUTES (func)))\n+        {\n+          return true;\n+        }\n+      \n+      func = TREE_TYPE (func);\n+    }\n+\n+  gcc_assert (TREE_CODE (func) == FUNCTION_TYPE\n+              || TREE_CODE (func) == METHOD_TYPE);\n+  \n+  return NULL_TREE != lookup_attribute (name, TYPE_ATTRIBUTES (func));\n+}\n+\n /* Return nonzero if FUNC is a naked function.  */\n \n static int\n avr_naked_function_p (tree func)\n {\n-  tree a;\n-\n-  gcc_assert (TREE_CODE (func) == FUNCTION_DECL);\n-  \n-  a = lookup_attribute (\"naked\", TYPE_ATTRIBUTES (TREE_TYPE (func)));\n-  return a != NULL_TREE;\n+  return avr_lookup_function_attribute1 (func, \"naked\");\n }\n \n /* Return nonzero if FUNC is an interrupt function as specified\n@@ -367,13 +388,7 @@ avr_naked_function_p (tree func)\n static int\n interrupt_function_p (tree func)\n {\n-  tree a;\n-\n-  if (TREE_CODE (func) != FUNCTION_DECL)\n-    return 0;\n-\n-  a = lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (func));\n-  return a != NULL_TREE;\n+  return avr_lookup_function_attribute1 (func, \"interrupt\");\n }\n \n /* Return nonzero if FUNC is a signal function as specified\n@@ -382,39 +397,23 @@ interrupt_function_p (tree func)\n static int\n signal_function_p (tree func)\n {\n-  tree a;\n-\n-  if (TREE_CODE (func) != FUNCTION_DECL)\n-    return 0;\n-\n-  a = lookup_attribute (\"signal\", DECL_ATTRIBUTES (func));\n-  return a != NULL_TREE;\n+  return avr_lookup_function_attribute1 (func, \"signal\");\n }\n \n /* Return nonzero if FUNC is a OS_task function.  */\n \n static int\n avr_OS_task_function_p (tree func)\n {\n-  tree a;\n-\n-  gcc_assert (TREE_CODE (func) == FUNCTION_DECL);\n-  \n-  a = lookup_attribute (\"OS_task\", TYPE_ATTRIBUTES (TREE_TYPE (func)));\n-  return a != NULL_TREE;\n+  return avr_lookup_function_attribute1 (func, \"OS_task\");\n }\n \n /* Return nonzero if FUNC is a OS_main function.  */\n \n static int\n avr_OS_main_function_p (tree func)\n {\n-  tree a;\n-\n-  gcc_assert (TREE_CODE (func) == FUNCTION_DECL);\n-  \n-  a = lookup_attribute (\"OS_main\", TYPE_ATTRIBUTES (TREE_TYPE (func)));\n-  return a != NULL_TREE;\n+  return avr_lookup_function_attribute1 (func, \"OS_main\");\n }\n \n /* Return the number of hard registers to push/pop in the prologue/epilogue\n@@ -935,7 +934,7 @@ emit_pop_byte (unsigned regno)\n /*  Output RTL epilogue.  */\n \n void\n-expand_epilogue (void)\n+expand_epilogue (bool sibcall_p)\n {\n   int reg;\n   int live_seq;\n@@ -946,6 +945,8 @@ expand_epilogue (void)\n   /* epilogue: naked  */\n   if (cfun->machine->is_naked)\n     {\n+      gcc_assert (!sibcall_p);\n+      \n       emit_jump_insn (gen_return ());\n       return;\n     }\n@@ -1088,7 +1089,8 @@ expand_epilogue (void)\n           emit_pop_byte (ZERO_REGNO);\n         }\n \n-      emit_jump_insn (gen_return ());\n+      if (!sibcall_p)\n+        emit_jump_insn (gen_return ());\n     }\n }\n \n@@ -1701,6 +1703,10 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx libname,\n   cum->regno = FIRST_CUM_REG;\n   if (!libname && stdarg_p (fntype))\n     cum->nregs = 0;\n+\n+  /* Assume the calle may be tail called */\n+  \n+  cfun->machine->sibcall_fails = 0;\n }\n \n /* Returns the number of registers to allocate for a function argument.  */\n@@ -1748,13 +1754,89 @@ avr_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   cum->nregs -= bytes;\n   cum->regno -= bytes;\n \n+  /* A parameter is being passed in a call-saved register. As the original\n+     contents of these regs has to be restored before leaving the function,\n+     a function must not pass arguments in call-saved regs in order to get\n+     tail-called. */\n+  \n+  if (cum->regno >= 0\n+      && !call_used_regs[cum->regno])\n+    {\n+      /* FIXME: We ship info on failing tail-call in struct machine_function.\n+         This uses internals of calls.c:expand_call() and the way args_so_far\n+         is used. targetm.function_ok_for_sibcall() needs to be extended to\n+         pass &args_so_far, too. At present, CUMULATIVE_ARGS is target\n+         dependent so that such an extension is not wanted. */\n+      \n+      cfun->machine->sibcall_fails = 1;\n+    }\n+\n   if (cum->nregs <= 0)\n     {\n       cum->nregs = 0;\n       cum->regno = FIRST_CUM_REG;\n     }\n }\n \n+/* Implement `TARGET_FUNCTION_OK_FOR_SIBCALL' */\n+/* Decide whether we can make a sibling call to a function.  DECL is the\n+   declaration of the function being targeted by the call and EXP is the\n+   CALL_EXPR representing the call. */\n+\n+static bool\n+avr_function_ok_for_sibcall (tree decl_callee, tree exp_callee)\n+{\n+  tree fntype_callee;\n+\n+  /* Tail-calling must fail if callee-saved regs are used to pass\n+     function args.  We must not tail-call when `epilogue_restores'\n+     is used.  Unfortunately, we cannot tell at this point if that\n+     actually will happen or not, and we cannot step back from\n+     tail-calling. Thus, we inhibit tail-calling with -mcall-prologues. */\n+  \n+  if (cfun->machine->sibcall_fails\n+      || TARGET_CALL_PROLOGUES)\n+    {\n+      return false;\n+    }\n+  \n+  fntype_callee = TREE_TYPE (CALL_EXPR_FN (exp_callee));\n+\n+  if (decl_callee)\n+    {\n+      decl_callee = TREE_TYPE (decl_callee);\n+    }\n+  else\n+    {\n+      decl_callee = fntype_callee;\n+      \n+      while (FUNCTION_TYPE != TREE_CODE (decl_callee)\n+             && METHOD_TYPE != TREE_CODE (decl_callee))\n+        {\n+          decl_callee = TREE_TYPE (decl_callee);\n+        }\n+    }\n+\n+  /* Ensure that caller and callee have compatible epilogues */\n+  \n+  if (interrupt_function_p (current_function_decl)\n+      || signal_function_p (current_function_decl)\n+      || avr_naked_function_p (decl_callee)\n+      || avr_naked_function_p (current_function_decl)\n+      /* FIXME: For OS_task and OS_main, we are over-conservative.\n+         This is due to missing documentation of these attributes\n+         and what they actually should do and should not do. */\n+      || (avr_OS_task_function_p (decl_callee)\n+          != avr_OS_task_function_p (current_function_decl))\n+      || (avr_OS_main_function_p (decl_callee)\n+          != avr_OS_main_function_p (current_function_decl)))\n+    {\n+      return false;\n+    }\n+ \n+  return true;\n+}\n+\n /***********************************************************************\n   Functions for outputting various mov's for a various modes\n ************************************************************************/"}, {"sha": "37fb3ed818a947b967adb7c6734aee7f0c784469", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=980a0ff422442a1a0695df63ea48352df9578b09", "patch": "@@ -826,4 +826,7 @@ struct GTY(()) machine_function\n   \n   /* Current function stack size.  */\n   int stack_usage;\n+\n+  /* 'true' if a callee might be tail called */\n+  int sibcall_fails;\n };"}, {"sha": "9c375e4c4baa4521282ad7309e7ccc75afd17614", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 80, "deletions": 76, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980a0ff422442a1a0695df63ea48352df9578b09/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=980a0ff422442a1a0695df63ea48352df9578b09", "patch": "@@ -2646,94 +2646,91 @@\n ;; call\n \n (define_expand \"call\"\n-  [(call (match_operand:HI 0 \"call_insn_operand\" \"\")\n-         (match_operand:HI 1 \"general_operand\" \"\"))]\n+  [(parallel[(call (match_operand:HI 0 \"call_insn_operand\" \"\")\n+                   (match_operand:HI 1 \"general_operand\" \"\"))\n+             (use (const_int 0))])]\n   ;; Operand 1 not used on the AVR.\n+  ;; Operand 2 is 1 for tail-call, 0 otherwise.\n+  \"\"\n+  \"\")\n+\n+(define_expand \"sibcall\"\n+  [(parallel[(call (match_operand:HI 0 \"call_insn_operand\" \"\")\n+                   (match_operand:HI 1 \"general_operand\" \"\"))\n+             (use (const_int 1))])]\n+  ;; Operand 1 not used on the AVR.\n+  ;; Operand 2 is 1 for tail-call, 0 otherwise.\n   \"\"\n   \"\")\n \n ;; call value\n \n (define_expand \"call_value\"\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-        (call (match_operand:HI 1 \"call_insn_operand\" \"\")\n-              (match_operand:HI 2 \"general_operand\" \"\")))]\n+  [(parallel[(set (match_operand 0 \"register_operand\" \"\")\n+                  (call (match_operand:HI 1 \"call_insn_operand\" \"\")\n+                        (match_operand:HI 2 \"general_operand\" \"\")))\n+             (use (const_int 0))])]\n+  ;; Operand 2 not used on the AVR.\n+  ;; Operand 3 is 1 for tail-call, 0 otherwise.\n+  \"\"\n+  \"\")\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel[(set (match_operand 0 \"register_operand\" \"\")\n+                  (call (match_operand:HI 1 \"call_insn_operand\" \"\")\n+                        (match_operand:HI 2 \"general_operand\" \"\")))\n+             (use (const_int 1))])]\n   ;; Operand 2 not used on the AVR.\n+  ;; Operand 3 is 1 for tail-call, 0 otherwise.\n   \"\"\n   \"\")\n \n-(define_insn \"call_insn\"\n-  [(call (mem:HI (match_operand:HI 0 \"nonmemory_operand\" \"!z,*r,s,n\"))\n-         (match_operand:HI 1 \"general_operand\" \"X,X,X,X\"))]\n-;; We don't need in saving Z register because r30,r31 is a call used registers\n+(define_insn \"*call_insn\"\n+  [(parallel[(call (mem:HI (match_operand:HI 0 \"nonmemory_operand\" \"z,s,z,s\"))\n+                   (match_operand:HI 1 \"general_operand\"           \"X,X,X,X\"))\n+             (use (match_operand:HI 2 \"const_int_operand\"          \"L,L,P,P\"))])]\n   ;; Operand 1 not used on the AVR.\n-  \"(register_operand (operands[0], HImode) || CONSTANT_P (operands[0]))\"\n-  \"*{\n-  if (which_alternative==0)\n-     return \\\"%!icall\\\";\n-  else if (which_alternative==1)\n-    {\n-      if (AVR_HAVE_MOVW)\n-\treturn (AS2 (movw, r30, %0) CR_TAB\n-               \\\"%!icall\\\");\n-      else\n-\treturn (AS2 (mov, r30, %A0) CR_TAB\n-\t\tAS2 (mov, r31, %B0) CR_TAB\n-\t\t\\\"%!icall\\\");\n-    }\n-  else if (which_alternative==2)\n-    return AS1(%~call,%x0);\n-  return (AS2 (ldi,r30,lo8(%0)) CR_TAB\n-          AS2 (ldi,r31,hi8(%0)) CR_TAB\n-          \\\"%!icall\\\");\n-}\"\n-  [(set_attr \"cc\" \"clobber,clobber,clobber,clobber\")\n+  ;; Operand 2 is 1 for tail-call, 0 otherwise.\n+  \"\"\n+  \"@\n+    %!icall\n+    %~call %x0\n+    %!ijmp\n+    %~jmp %x0\"\n+  [(set_attr \"cc\" \"clobber\")\n    (set_attr_alternative \"length\"\n-\t\t\t [(const_int 1)\n-\t\t\t  (if_then_else (eq_attr \"mcu_have_movw\" \"yes\")\n-\t\t\t\t\t(const_int 2)\n-\t\t\t\t\t(const_int 3))\n-\t\t\t  (if_then_else (eq_attr \"mcu_mega\" \"yes\")\n-\t\t\t\t\t(const_int 2)\n-\t\t\t\t\t(const_int 1))\n-\t\t\t  (const_int 3)])])\n-\n-(define_insn \"call_value_insn\"\n-  [(set (match_operand 0 \"register_operand\" \"=r,r,r,r\")\n-        (call (mem:HI (match_operand:HI 1 \"nonmemory_operand\" \"!z,*r,s,n\"))\n-;; We don't need in saving Z register because r30,r31 is a call used registers\n-              (match_operand:HI 2 \"general_operand\" \"X,X,X,X\")))]\n+                         [(const_int 1)\n+                          (if_then_else (eq_attr \"mcu_mega\" \"yes\")\n+                                        (const_int 2)\n+                                        (const_int 1))\n+                          (const_int 1)\n+                          (if_then_else (eq_attr \"mcu_mega\" \"yes\")\n+                                        (const_int 2)\n+                                        (const_int 1))])])\n+\n+(define_insn \"*call_value_insn\"\n+  [(parallel[(set (match_operand 0 \"register_operand\"                   \"=r,r,r,r\")\n+                  (call (mem:HI (match_operand:HI 1 \"nonmemory_operand\"  \"z,s,z,s\"))\n+                        (match_operand:HI 2 \"general_operand\"            \"X,X,X,X\")))\n+             (use (match_operand:HI 3 \"const_int_operand\"                \"L,L,P,P\"))])]\n   ;; Operand 2 not used on the AVR.\n-  \"(register_operand (operands[0], VOIDmode) || CONSTANT_P (operands[0]))\"\n-  \"*{\n-  if (which_alternative==0)\n-     return \\\"%!icall\\\";\n-  else if (which_alternative==1)\n-    {\n-      if (AVR_HAVE_MOVW)\n-\treturn (AS2 (movw, r30, %1) CR_TAB\n-\t\t\\\"%!icall\\\");\n-      else\n-\treturn (AS2 (mov, r30, %A1) CR_TAB\n-\t\tAS2 (mov, r31, %B1) CR_TAB\n-\t\t\\\"%!icall\\\");\n-    }\n-  else if (which_alternative==2)\n-    return AS1(%~call,%x1);\n-  return (AS2 (ldi, r30, lo8(%1)) CR_TAB\n-          AS2 (ldi, r31, hi8(%1)) CR_TAB\n-          \\\"%!icall\\\");\n-}\"\n-  [(set_attr \"cc\" \"clobber,clobber,clobber,clobber\")\n+  ;; Operand 3 is 1 for tail-call, 0 otherwise.\n+  \"\"\n+  \"@\n+    %!icall\n+    %~call %x1\n+    %!ijmp\n+    %~jmp %x1\"\n+  [(set_attr \"cc\" \"clobber\")\n    (set_attr_alternative \"length\"\n-\t\t\t [(const_int 1)\n-\t\t\t  (if_then_else (eq_attr \"mcu_have_movw\" \"yes\")\n-\t\t\t\t\t(const_int 2)\n-\t\t\t\t\t(const_int 3))\n-\t\t\t  (if_then_else (eq_attr \"mcu_mega\" \"yes\")\n-\t\t\t\t\t(const_int 2)\n-\t\t\t\t\t(const_int 1))\n-\t\t\t  (const_int 3)])])\n+                         [(const_int 1)\n+                          (if_then_else (eq_attr \"mcu_mega\" \"yes\")\n+                                        (const_int 2)\n+                                        (const_int 1))\n+                          (const_int 1)\n+                          (if_then_else (eq_attr \"mcu_mega\" \"yes\")\n+                                        (const_int 2)\n+                                        (const_int 1))])])\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -3237,8 +3234,15 @@\n (define_expand \"epilogue\"\n   [(const_int 0)]\n   \"\"\n-  \"\n   {\n-    expand_epilogue (); \n+    expand_epilogue (false /* sibcall_p */);\n     DONE;\n-  }\")\n+  })\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(const_int 0)]\n+  \"\"\n+  {\n+    expand_epilogue (true /* sibcall_p */);\n+    DONE;\n+  })"}]}