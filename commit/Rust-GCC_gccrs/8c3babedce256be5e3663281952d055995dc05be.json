{"sha": "8c3babedce256be5e3663281952d055995dc05be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzYmFiZWRjZTI1NmJlNWUzNjYzMjgxOTUyZDA1NTk5NWRjMDViZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-29T21:41:30Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-29T21:41:30Z"}, "message": "tree-phinodes.c (allocate_phi_node): New.\n\n\t* tree-phinodes.c (allocate_phi_node): New.\n\t(make_phi_node, resize_phi_node): Use it.\n\nFrom-SVN: r89852", "tree": {"sha": "5c42227d182cef3486c320d7cd5a2c85cca2f302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c42227d182cef3486c320d7cd5a2c85cca2f302"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c3babedce256be5e3663281952d055995dc05be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c3babedce256be5e3663281952d055995dc05be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c3babedce256be5e3663281952d055995dc05be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c3babedce256be5e3663281952d055995dc05be/comments", "author": null, "committer": null, "parents": [{"sha": "976c217af8797c7e09562a833dd772200a45de3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/976c217af8797c7e09562a833dd772200a45de3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/976c217af8797c7e09562a833dd772200a45de3e"}], "stats": {"total": 107, "additions": 49, "deletions": 58}, "files": [{"sha": "f43290d41d0dbea0f861b1152c2378bcd865abce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3babedce256be5e3663281952d055995dc05be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3babedce256be5e3663281952d055995dc05be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c3babedce256be5e3663281952d055995dc05be", "patch": "@@ -1,3 +1,8 @@\n+2004-10-29  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-phinodes.c (allocate_phi_node): New.\n+\t(make_phi_node, resize_phi_node): Use it.\n+\n 2004-10-29  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/sysv4.h (TARGET_POWER): Define as 0."}, {"sha": "71f04982a99453659b7b41a95c17ad047bc6c406", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 44, "deletions": 58, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3babedce256be5e3663281952d055995dc05be/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3babedce256be5e3663281952d055995dc05be/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=8c3babedce256be5e3663281952d055995dc05be", "patch": "@@ -123,6 +123,47 @@ phinodes_print_statistics (void)\n }\n #endif\n \n+/* Allocate a PHI node with at least LEN arguments.  If the free list\n+   happens to contain a PHI node with LEN arguments or more, return\n+   that one.  */\n+\n+static inline tree\n+allocate_phi_node (int len)\n+{\n+  tree phi;\n+  int bucket = NUM_BUCKETS - 2;\n+  int size = (sizeof (struct tree_phi_node)\n+\t      + (len - 1) * sizeof (struct phi_arg_d));\n+\n+  if (free_phinode_count)\n+    for (bucket = len - 2; bucket < NUM_BUCKETS - 2; bucket++)\n+      if (free_phinodes[bucket])\n+\tbreak;\n+\n+  /* If our free list has an element, then use it.  */\n+  if (bucket < NUM_BUCKETS - 2\n+      && PHI_ARG_CAPACITY (free_phinodes[bucket]) >= len)\n+    {\n+      free_phinode_count--;\n+      phi = free_phinodes[bucket];\n+      free_phinodes[bucket] = PHI_CHAIN (free_phinodes[bucket]);\n+#ifdef GATHER_STATISTICS\n+      phi_nodes_reused++;\n+#endif\n+    }\n+  else\n+    {\n+      phi = ggc_alloc (size);\n+#ifdef GATHER_STATISTICS\n+      phi_nodes_created++;\n+      tree_node_counts[(int) phi_kind]++;\n+      tree_node_sizes[(int) phi_kind] += size;\n+#endif\n+    }\n+\n+  return phi;\n+}\n+\n /* Given LEN, the original number of requested PHI arguments, return\n    a new, \"ideal\" length for the PHI node.  The \"ideal\" length rounds\n    the total size of the PHI node up to the next power of two bytes.\n@@ -165,39 +206,10 @@ tree\n make_phi_node (tree var, int len)\n {\n   tree phi;\n-  int size;\n-  int bucket = NUM_BUCKETS - 2;\n \n   len = ideal_phi_node_len (len);\n \n-  size = sizeof (struct tree_phi_node) + (len - 1) * sizeof (struct phi_arg_d);\n-\n-  if (free_phinode_count)\n-    for (bucket = len - 2; bucket < NUM_BUCKETS - 2; bucket++)\n-      if (free_phinodes[bucket])\n-\tbreak;\n-\n-  /* If our free list has an element, then use it.  */\n-  if (bucket < NUM_BUCKETS - 2\n-      && PHI_ARG_CAPACITY (free_phinodes[bucket]) >= len)\n-    {\n-      free_phinode_count--;\n-      phi = free_phinodes[bucket];\n-      free_phinodes[bucket] = PHI_CHAIN (free_phinodes[bucket]);\n-#ifdef GATHER_STATISTICS\n-      phi_nodes_reused++;\n-#endif\n-    }\n-  else\n-    {\n-      phi = ggc_alloc (size);\n-#ifdef GATHER_STATISTICS\n-      phi_nodes_created++;\n-      tree_node_counts[(int) phi_kind]++;\n-      tree_node_sizes[(int) phi_kind] += size;\n-#endif\n-\n-    }\n+  phi = allocate_phi_node (len);\n \n   /* We do not have to clear a part of the PHI node that stores PHI\n      arguments, which is safe because we tell the garbage collector to\n@@ -237,42 +249,16 @@ release_phi_node (tree phi)\n static void\n resize_phi_node (tree *phi, int len)\n {\n-  int size, old_size;\n+  int old_size;\n   tree new_phi;\n-  int bucket = NUM_BUCKETS - 2;\n \n   gcc_assert (len >= PHI_ARG_CAPACITY (*phi));\n \n   /* Note that OLD_SIZE is guaranteed to be smaller than SIZE.  */\n   old_size = (sizeof (struct tree_phi_node)\n \t     + (PHI_ARG_CAPACITY (*phi) - 1) * sizeof (struct phi_arg_d));\n-  size = sizeof (struct tree_phi_node) + (len - 1) * sizeof (struct phi_arg_d);\n-\n-  if (free_phinode_count)\n-    for (bucket = len - 2; bucket < NUM_BUCKETS - 2; bucket++)\n-      if (free_phinodes[bucket])\n-\tbreak;\n \n-  /* If our free list has an element, then use it.  */\n-  if (bucket < NUM_BUCKETS - 2\n-      && PHI_ARG_CAPACITY (free_phinodes[bucket]) >= len)\n-    {\n-      free_phinode_count--;\n-      new_phi = free_phinodes[bucket];\n-      free_phinodes[bucket] = PHI_CHAIN (free_phinodes[bucket]);\n-#ifdef GATHER_STATISTICS\n-      phi_nodes_reused++;\n-#endif\n-    }\n-  else\n-    {\n-      new_phi = ggc_alloc (size);\n-#ifdef GATHER_STATISTICS\n-      phi_nodes_created++;\n-      tree_node_counts[(int) phi_kind]++;\n-      tree_node_sizes[(int) phi_kind] += size;\n-#endif\n-    }\n+  new_phi = allocate_phi_node (len);\n \n   memcpy (new_phi, *phi, old_size);\n "}]}