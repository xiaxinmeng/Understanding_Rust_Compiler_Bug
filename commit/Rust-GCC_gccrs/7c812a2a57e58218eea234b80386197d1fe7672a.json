{"sha": "7c812a2a57e58218eea234b80386197d1fe7672a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M4MTJhMmE1N2U1ODIxOGVlYTIzNGI4MDM4NjE5N2QxZmU3NjcyYQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-09-05T15:20:39Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-09-05T15:20:39Z"}, "message": "regex_automaton.h: Add dummy node type.\n\n2013-09-05  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex_automaton.h: Add dummy node type. Rewrite\n\t_StateSeq.\n\t* include/bits/regex_automaton.tcc: Implement them.\n\t* include/bits/regex_compiler.h: Rewrite _Compiler to use new\n\t_StateSeq interfaces.\n\t* include/bits/regex_compiler.tcc: Implement them.\n\t* include/bits/regex_scanner.h: Add word boundry assertion token.\n\t* include/bits/regex_scanner.tcc (_Scanner<>::_M_eat_escape_ecma):\n\tSupport word boundry.\n\t* testsuite/28_regex/algorithms/regex_match/basic/\n\tstring_range_02_03.cc: Remove \"xfail\".\n\t* testsuite/28_regex/algorithms/regex_match/extended/cstring_plus.cc:\n\tLikewise.\n\t* testsuite/28_regex/algorithms/regex_match/extended/\n\tstring_range_02_03.cc: Likewise.\n\t* testsuite/28_regex/algorithms/regex_match/extended/\n\tcstring_questionmark.cc: Remove xfail and get correct length of\n\tc-string.\n\t* testsuite/28_regex/algorithms/regex_match/extended/\n\tstring_range_00_03.cc: Likewise.\n\t* testsuite/28_regex/algorithms/regex_match/ecma/char/quoted_char.cc:\n\tNew.\n\t* testsuite/28_regex/algorithms/regex_match/extended/cstring_range.cc:\n\tNew.\n\t* testsuite/28_regex/iterators/regex_iterator/wchar_t/string_02.cc: New.\n\nFrom-SVN: r202290", "tree": {"sha": "a2f8bf477aa8c0b5345a773df68b768a8f9698ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2f8bf477aa8c0b5345a773df68b768a8f9698ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c812a2a57e58218eea234b80386197d1fe7672a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c812a2a57e58218eea234b80386197d1fe7672a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c812a2a57e58218eea234b80386197d1fe7672a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c812a2a57e58218eea234b80386197d1fe7672a/comments", "author": null, "committer": null, "parents": [{"sha": "e6523306de7912d2cdb68dd6b19febe69b9fe201", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6523306de7912d2cdb68dd6b19febe69b9fe201", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6523306de7912d2cdb68dd6b19febe69b9fe201"}], "stats": {"total": 862, "additions": 552, "deletions": 310}, "files": [{"sha": "bdbde8d12ddad0291833ed2f98c984786a5067c5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -1,8 +1,36 @@\n+2013-09-05  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex_automaton.h: Add dummy node type. Rewrite\n+\t_StateSeq.\n+\t* include/bits/regex_automaton.tcc: Implement them.\n+\t* include/bits/regex_compiler.h: Rewrite _Compiler to use new\n+\t_StateSeq interfaces.\n+\t* include/bits/regex_compiler.tcc: Implement them.\n+\t* include/bits/regex_scanner.h: Add word boundry assertion token.\n+\t* include/bits/regex_scanner.tcc (_Scanner<>::_M_eat_escape_ecma):\n+\tSupport word boundry.\n+\t* testsuite/28_regex/algorithms/regex_match/basic/\n+\tstring_range_02_03.cc: Remove \"xfail\".\n+\t* testsuite/28_regex/algorithms/regex_match/extended/cstring_plus.cc:\n+\tLikewise.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/\n+\tstring_range_02_03.cc: Likewise.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/\n+\tcstring_questionmark.cc: Remove xfail and get correct length of\n+\tc-string.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/\n+\tstring_range_00_03.cc: Likewise.\n+\t* testsuite/28_regex/algorithms/regex_match/ecma/char/quoted_char.cc:\n+\tNew.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/cstring_range.cc:\n+\tNew.\n+\t* testsuite/28_regex/iterators/regex_iterator/wchar_t/string_02.cc: New.\n+\n 2013-09-03  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/58302\n \t* include/bits/random.tcc (negative_binomial_distribution<>::\n-\toperator()(_UniformRandomNumberGenerator&, const param_type&):\n+\toperator()(_UniformRandomNumberGenerator&, const param_type&)):\n \tFix typo in template argument.\n \t* testsuite/26_numerics/random/negative_binomial_distribution/\n \toperators/58302.cc: New."}, {"sha": "77551756f65a8b202758e52b2816613be4a0cdea", "filename": "libstdc++-v3/include/bits/regex_automaton.h", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -56,6 +56,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _S_opcode_backref       =   2,\n       _S_opcode_subexpr_begin =   4,\n       _S_opcode_subexpr_end   =   5,\n+      _S_opcode_dummy         =   6,\n       _S_opcode_match         = 100,\n       _S_opcode_accept        = 255\n   };\n@@ -69,7 +70,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _OpcodeT     _M_opcode;           // type of outgoing transition\n       _StateIdT    _M_next;             // outgoing transition\n-      union // Since they are mutual exclusive.\n+      union // Since they are mutually exclusive.\n       {\n \t_StateIdT    _M_alt;            // for _S_opcode_alternative\n \tunsigned int _M_subexpr;        // for _S_opcode_subexpr_*\n@@ -201,6 +202,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StateIdT\n       _M_insert_backref(unsigned int __index);\n \n+      _StateIdT\n+      _M_insert_dummy()\n+      {\n+\tthis->push_back(_StateT(_S_opcode_dummy));\n+\treturn this->size()-1;\n+      }\n+\n+      _StateIdT\n+      _M_insert_state(_StateT __s)\n+      {\n+\tthis->push_back(__s);\n+\treturn this->size()-1;\n+      }\n+\n+      // Eliminate dummy node in this NFA to make it compact.\n+      void\n+      _M_eliminate_dummy();\n+\n #ifdef _GLIBCXX_DEBUG\n       std::ostream&\n       _M_dot(std::ostream& __ostr) const;\n@@ -222,58 +241,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n     public:\n       typedef _NFA<_CharT, _TraitsT> _RegexT;\n-    public:\n-      // Constructs a single-node sequence\n-      _StateSeq(_RegexT& __ss, _StateIdT __s,\n-\t\t_StateIdT __e = _S_invalid_state_id)\n-      : _M_nfa(__ss), _M_start(__s), _M_end1(__s), _M_end2(__e)\n-      { }\n-      // Constructs a split sequence from two other sequencces\n-      _StateSeq(const _StateSeq& __e1, const _StateSeq& __e2)\n-      : _M_nfa(__e1._M_nfa),\n-\t_M_start(_M_nfa._M_insert_alt(__e1._M_start, __e2._M_start)),\n-\t_M_end1(__e1._M_end1), _M_end2(__e2._M_end1)\n-      { }\n \n-      // Constructs a split sequence from a single sequence\n-      _StateSeq(const _StateSeq& __e, _StateIdT __id)\n-      : _M_nfa(__e._M_nfa),\n-\t_M_start(_M_nfa._M_insert_alt(__id, __e._M_start)),\n-\t_M_end1(__id), _M_end2(__e._M_end1)\n+    public:\n+      _StateSeq(_RegexT& __nfa, _StateIdT __s)\n+      : _StateSeq(__nfa, __s, __s)\n       { }\n \n-      // Constructs a copy of a %_StateSeq\n-      _StateSeq(const _StateSeq& __rhs)\n-      : _M_nfa(__rhs._M_nfa), _M_start(__rhs._M_start),\n-\t_M_end1(__rhs._M_end1), _M_end2(__rhs._M_end2)\n+      _StateSeq(_RegexT& __nfa, _StateIdT __s, _StateIdT __end)\n+      : _M_nfa(__nfa), _M_start(__s), _M_end(__end)\n       { }\n \n-      _StateSeq& operator=(const _StateSeq& __rhs);\n-\n-      _StateIdT\n-      _M_front() const\n-      { return _M_start; }\n-\n-      // Extends a sequence by one.\n-      void\n-      _M_push_back(_StateIdT __id);\n-\n-      // Extends and maybe joins a sequence.\n+      // Append a state on *this and change *this to the new sequence.\n       void\n-      _M_append(_StateIdT __id);\n+      _M_append(_StateIdT __id)\n+      {\n+\t_M_nfa[_M_end]._M_next = __id;\n+\t_M_end = __id;\n+      }\n \n+      // Append a sequence on *this and change *this to the new sequence.\n       void\n-      _M_append(_StateSeq& __rhs);\n+      _M_append(const _StateSeq& __s)\n+      {\n+\t_M_nfa[_M_end]._M_next = __s._M_start;\n+\t_M_end = __s._M_end;\n+      }\n \n       // Clones an entire sequence.\n-      _StateIdT\n+      _StateSeq\n       _M_clone();\n \n-    private:\n+    public:\n       _RegexT&  _M_nfa;\n       _StateIdT _M_start;\n-      _StateIdT _M_end1;\n-      _StateIdT _M_end2;\n+      _StateIdT _M_end;\n     };\n \n  //@} regex-detail"}, {"sha": "2d34b95cdba618fbec0fc6d9e9970cdd2a3f96af", "filename": "libstdc++-v3/include/bits/regex_automaton.tcc", "status": "modified", "additions": 52, "deletions": 55, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -102,9 +102,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tcase _S_opcode_accept:\n \t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n \t  break;\n+\tcase _S_opcode_dummy:\n+\t  break;\n \tdefault:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nUNK\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"?\\\"];\\n\";\n+\t  _GLIBCXX_DEBUG_ASSERT(false);\n \t  break;\n       }\n       return __ostr;\n@@ -145,66 +146,62 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _CharT, typename _TraitsT>\n-    _StateSeq<_CharT, _TraitsT>& _StateSeq<_CharT, _TraitsT>::\n-    operator=(const _StateSeq& __rhs)\n-    {\n-      _M_start = __rhs._M_start;\n-      _M_end1  = __rhs._M_end1;\n-      _M_end2  = __rhs._M_end2;\n-      return *this;\n-    }\n-\n-  template<typename _CharT, typename _TraitsT>\n-    void _StateSeq<_CharT, _TraitsT>::\n-    _M_push_back(_StateIdT __id)\n+    void _NFA<_CharT, _TraitsT>::\n+    _M_eliminate_dummy()\n     {\n-      if (_M_end1 != _S_invalid_state_id)\n-\t_M_nfa[_M_end1]._M_next = __id;\n-      _M_end1 = __id;\n+      for (auto& __it : *this)\n+\t{\n+\t  while (__it._M_next >= 0 && (*this)[__it._M_next]._M_opcode\n+\t         == _S_opcode_dummy)\n+\t    __it._M_next = (*this)[__it._M_next]._M_next;\n+\t  if (__it._M_opcode == _S_opcode_alternative)\n+\t    while (__it._M_alt >= 0 && (*this)[__it._M_alt]._M_opcode\n+\t\t   == _S_opcode_dummy)\n+\t      __it._M_alt = (*this)[__it._M_alt]._M_next;\n+\t}\n     }\n \n+  // Just apply DFS on the sequence and re-link their links.\n   template<typename _CharT, typename _TraitsT>\n-    void _StateSeq<_CharT, _TraitsT>::\n-    _M_append(_StateIdT __id)\n-    {\n-      if (_M_end2 != _S_invalid_state_id)\n-      {\n-\tif (_M_end2 == _M_end1)\n-\t  _M_nfa[_M_end2]._M_alt = __id;\n-\telse\n-\t  _M_nfa[_M_end2]._M_next = __id;\n-\t_M_end2 = _S_invalid_state_id;\n-      }\n-      if (_M_end1 != _S_invalid_state_id)\n-\t_M_nfa[_M_end1]._M_next = __id;\n-      _M_end1 = __id;\n-    }\n-\n-  template<typename _CharT, typename _TraitsT>\n-    void _StateSeq<_CharT, _TraitsT>::\n-    _M_append(_StateSeq& __rhs)\n+    _StateSeq<_CharT, _TraitsT> _StateSeq<_CharT, _TraitsT>::\n+    _M_clone()\n     {\n-      if (_M_end2 != _S_invalid_state_id)\n-      {\n-\tif (_M_end2 == _M_end1)\n-\t  _M_nfa[_M_end2]._M_alt = __rhs._M_start;\n-\telse\n-\t  _M_nfa[_M_end2]._M_next = __rhs._M_start;\n-\t_M_end2 = _S_invalid_state_id;\n-      }\n-      if (__rhs._M_end2 != _S_invalid_state_id)\n-\t_M_end2 = __rhs._M_end2;\n-      if (_M_end1 != _S_invalid_state_id)\n-\t_M_nfa[_M_end1]._M_next = __rhs._M_start;\n-      _M_end1 = __rhs._M_end1;\n+      std::map<_StateIdT, _StateIdT> __m;\n+      std::stack<_StateIdT> __stack;\n+      __stack.push(_M_start);\n+      while (!__stack.empty())\n+\t{\n+\t  auto __u = __stack.top();\n+\t  __stack.pop();\n+\t  auto __dup = _M_nfa[__u];\n+\t  auto __id = _M_nfa._M_insert_state(__dup);\n+\t  __m[__u] = __id;\n+\t  if (__u == _M_end)\n+\t    continue;\n+\t  if (__m.count(__dup._M_next) == 0)\n+\t    __stack.push(__dup._M_next);\n+\t  if (__dup._M_opcode == _S_opcode_alternative)\n+\t    if (__m.count(__dup._M_alt) == 0)\n+\t      __stack.push(__dup._M_alt);\n+\t}\n+      for (auto __it : __m)\n+\t{\n+\t  auto& __ref = _M_nfa[__it.second];\n+\t  if (__ref._M_next != -1)\n+\t    {\n+\t      _GLIBCXX_DEBUG_ASSERT(__m.count(__ref._M_next));\n+\t      __ref._M_next = __m[__ref._M_next];\n+\t    }\n+\t  if (__ref._M_opcode == _S_opcode_alternative)\n+\t    if (__ref._M_alt != -1)\n+\t      {\n+\t\t_GLIBCXX_DEBUG_ASSERT(__m.count(__ref._M_alt));\n+\t\t__ref._M_alt = __m[__ref._M_alt];\n+\t      }\n+\t}\n+      return _StateSeq(_M_nfa, __m[_M_start], __m[_M_end]);\n     }\n \n-  // @todo implement this function.\n-  template<typename _CharT, typename _TraitsT>\n-    _StateIdT _StateSeq<_CharT, _TraitsT>::\n-    _M_clone()\n-    { return 0; }\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail\n } // namespace"}, {"sha": "96a0d29417754d0cc7a9d95e407808a186142ec8", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -56,14 +56,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       std::shared_ptr<_RegexT>\n       _M_get_nfa() const\n-      { return std::shared_ptr<_RegexT>(new _RegexT(_M_state_store)); }\n+      { return std::shared_ptr<_RegexT>(new _RegexT(_M_nfa)); }\n \n     private:\n       typedef _Scanner<_FwdIter>                              _ScannerT;\n       typedef typename _ScannerT::_TokenT                     _TokenT;\n       typedef _StateSeq<_CharT, _TraitsT>                     _StateSeqT;\n       typedef std::stack<_StateSeqT, std::vector<_StateSeqT>> _StackT;\n       typedef _BracketMatcher<_CharT, _TraitsT>               _BMatcherT;\n+      typedef std::ctype<_CharT>                              _CtypeT;\n \n       // accepts a specific token or returns false.\n       bool\n@@ -90,21 +91,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_bracket_expression();\n \n-      void\n-      _M_bracket_list(_BMatcherT& __matcher);\n-\n-      bool\n-      _M_follow_list(_BMatcherT& __matcher);\n-\n       void\n       _M_expression_term(_BMatcherT& __matcher);\n \n       bool\n       _M_range_expression(_BMatcherT& __matcher);\n \n-      bool\n-      _M_start_range(_BMatcherT& __matcher);\n-\n       bool\n       _M_collating_symbol(_BMatcherT& __matcher);\n \n@@ -120,12 +112,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_try_char();\n \n-      _CharT\n-      _M_get_char();\n+      _StateSeqT\n+      _M_pop()\n+      {\n+\tauto ret = _M_stack.top();\n+\t_M_stack.pop();\n+\treturn ret;\n+      }\n \n       const _TraitsT& _M_traits;\n+      const _CtypeT&  _M_ctype;\n       _ScannerT       _M_scanner;\n-      _RegexT         _M_state_store;\n+      _RegexT         _M_nfa;\n       _StringT        _M_value;\n       _StackT         _M_stack;\n       _FlagT          _M_flags;"}, {"sha": "a574e8e5ddd7e4f8ec38d7fe7706b0af610da3e0", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 170, "deletions": 139, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -28,6 +28,31 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n+// TODO make comments doxygen format.\n+\n+// This compiler refers to \"Regular Expression Matching Can Be Simple And Fast\"\n+// (http://swtch.com/~rsc/regexp/regexp1.html\"),\n+// but doesn't strictly follow it.\n+//\n+// When compiling, states are *chained* instead of tree- or graph-constructed.\n+// It's more like structured programs: there's if statement and loop statement.\n+//\n+// For alternative structure(say \"a|b\"), aka \"if statement\", two branchs should\n+// be constructed. However, these two shall merge to an \"end_tag\" at the end of\n+// this operator:\n+//\n+//                branch1\n+//              /        \\\n+// => begin_tag            end_tag =>\n+//              \\        /\n+//                branch2\n+//\n+// This is the difference between this implementation and that in Russ's\n+// article.\n+//\n+// That's why we introduced dummy node here ------ \"end_tag\" is a dummy node.\n+// All dummy node will be eliminated at the end of compiling process.\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __detail\n@@ -39,32 +64,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Compiler(_FwdIter __b, _FwdIter __e,\n \t      const _TraitsT& __traits, _FlagT __flags)\n     : _M_traits(__traits), _M_scanner(__b, __e, __flags, _M_traits.getloc()),\n-      _M_state_store(__flags), _M_flags(__flags)\n+      _M_ctype(std::use_facet<std::ctype<_CharT>>(_M_traits.getloc())),\n+      _M_nfa(__flags), _M_flags(__flags)\n     {\n-      _StateSeqT __r(_M_state_store,\n-\t\t     _M_state_store._M_insert_subexpr_begin());\n-      _M_disjunction();\n-      if (!_M_stack.empty())\n-\t{\n-\t  __r._M_append(_M_stack.top());\n-\t  _M_stack.pop();\n-\t}\n-      __r._M_append(_M_state_store._M_insert_subexpr_end());\n-      __r._M_append(_M_state_store._M_insert_accept());\n-    }\n-\n-  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n-    bool\n-    _Compiler<_FwdIter, _CharT, _TraitsT>::\n-    _M_match_token(_TokenT token)\n-    {\n-      if (token == _M_scanner._M_get_token())\n-\t{\n-\t  _M_value = _M_scanner._M_get_value();\n-\t  _M_scanner._M_advance();\n-\t  return true;\n-\t}\n-      return false;\n+      _StateSeqT __r(_M_nfa, _M_nfa._M_start());\n+      __r._M_append(_M_nfa._M_insert_subexpr_begin());\n+      this->_M_disjunction();\n+      if (!_M_match_token(_ScannerT::_S_token_eof))\n+\t__throw_regex_error(regex_constants::error_paren);\n+      __r._M_append(_M_pop());\n+      _GLIBCXX_DEBUG_ASSERT(_M_stack.empty());\n+      __r._M_append(_M_nfa._M_insert_subexpr_end());\n+      __r._M_append(_M_nfa._M_insert_accept());\n+      _M_nfa._M_eliminate_dummy();\n     }\n \n   template<typename _FwdIter, typename _CharT, typename _TraitsT>\n@@ -73,12 +85,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_disjunction()\n     {\n       this->_M_alternative();\n-      if (_M_match_token(_ScannerT::_S_token_or))\n+      // TODO empty alternative like, um, \"(|asdf)\"\n+      while (_M_match_token(_ScannerT::_S_token_or))\n \t{\n-\t  _StateSeqT __alt1 = _M_stack.top(); _M_stack.pop();\n-\t  this->_M_disjunction();\n-\t  _StateSeqT __alt2 = _M_stack.top(); _M_stack.pop();\n-\t  _M_stack.push(_StateSeqT(__alt1, __alt2));\n+\t  _StateSeqT __alt1 = _M_pop();\n+\t  this->_M_alternative();\n+\t  _StateSeqT __alt2 = _M_pop();\n+\t  auto __end = _M_nfa._M_insert_dummy();\n+\t  __alt1._M_append(__end);\n+\t  __alt2._M_append(__end);\n+\t  _M_stack.push(_StateSeqT(_M_nfa,\n+\t\t\t\t   _M_nfa._M_insert_alt(__alt1._M_start,\n+\t\t\t\t\t\t        __alt2._M_start),\n+\t\t\t\t   __end));\n \t}\n     }\n \n@@ -89,15 +108,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (this->_M_term())\n \t{\n-\t  _StateSeqT __re = _M_stack.top(); _M_stack.pop();\n+\t  _StateSeqT __re = _M_pop();\n \t  this->_M_alternative();\n-\t  if (!_M_stack.empty())\n-\t    {\n-\t      __re._M_append(_M_stack.top());\n-\t      _M_stack.pop();\n-\t    }\n+\t  __re._M_append(_M_pop());\n \t  _M_stack.push(__re);\n \t}\n+      else\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n     }\n \n   template<typename _FwdIter, typename _CharT, typename _TraitsT>\n@@ -121,7 +138,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_assertion()\n     {\n-      return false;\n+      // temporary place holders.\n+      if (_M_match_token(_ScannerT::_S_token_line_begin))\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+      else if (_M_match_token(_ScannerT::_S_token_line_end))\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+      else if (_M_match_token(_ScannerT::_S_token_word_bound))\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+      else if (_M_match_token(_ScannerT::_S_token_neg_word_bound))\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+      else if (_M_match_token(_ScannerT::_S_token_subexpr_lookahead_begin))\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+      else if (_M_match_token(_ScannerT::_S_token_subexpr_neg_lookahead_begin))\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+      else\n+\treturn false;\n+      return true;\n     }\n \n   template<typename _FwdIter, typename _CharT, typename _TraitsT>\n@@ -133,67 +165,70 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  if (_M_stack.empty())\n \t    __throw_regex_error(regex_constants::error_badrepeat);\n-\t  _StateSeqT __r(_M_stack.top(), -1);\n-\t  __r._M_append(__r._M_front());\n-\t  _M_stack.pop();\n+\t  auto __e = _M_pop();\n+\t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t\t      __e._M_start));\n+\t  __e._M_append(__r);\n \t  _M_stack.push(__r);\n-\t  return;\n \t}\n-      if (_M_match_token(_ScannerT::_S_token_closure1))\n+      else if (_M_match_token(_ScannerT::_S_token_closure1))\n \t{\n \t  if (_M_stack.empty())\n \t    __throw_regex_error(regex_constants::error_badrepeat);\n-\t  _StateSeqT __r(_M_state_store,\n-\t\t\t_M_state_store.\n-\t\t\t_M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t      _M_stack.top()._M_front()));\n-\t  _M_stack.top()._M_append(__r);\n-\t  return;\n+\t  auto __e = _M_pop();\n+\t  __e._M_append(_M_nfa._M_insert_alt(_S_invalid_state_id, __e._M_start));\n+\t  _M_stack.push(__e);\n \t}\n-      if (_M_match_token(_ScannerT::_S_token_opt))\n+      else if (_M_match_token(_ScannerT::_S_token_opt))\n \t{\n \t  if (_M_stack.empty())\n-\t  __throw_regex_error(regex_constants::error_badrepeat);\n-\t  _StateSeqT __r(_M_stack.top(), -1);\n-\t  _M_stack.pop();\n+\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  auto __e = _M_pop();\n+\t  auto __end = _M_nfa._M_insert_dummy();\n+\t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t\t      __e._M_start));\n+\t  __e._M_append(__end);\n+\t  __r._M_append(__end);\n \t  _M_stack.push(__r);\n-\t  return;\n \t}\n-      if (_M_match_token(_ScannerT::_S_token_interval_begin))\n+      else if (_M_match_token(_ScannerT::_S_token_interval_begin))\n \t{\n \t  if (_M_stack.empty())\n \t    __throw_regex_error(regex_constants::error_badrepeat);\n \t  if (!_M_match_token(_ScannerT::_S_token_dup_count))\n \t    __throw_regex_error(regex_constants::error_badbrace);\n-\t  _StateSeqT __r(_M_stack.top());\n+\t  _StateSeqT __r(_M_pop());\n+\t  _StateSeqT __e(_M_nfa, _M_nfa._M_insert_dummy());\n \t  int __min_rep = _M_cur_int_value(10);\n-\t  for (int __i = 1; __i < __min_rep; ++__i)\n-\t    _M_stack.top()._M_append(__r._M_clone());\n+\t  // {3\n+\t  for (int __i = 0; __i < __min_rep; ++__i)\n+\t    __e._M_append(__r._M_clone());\n \t  if (_M_match_token(_ScannerT::_S_token_comma))\n-\t    if (_M_match_token(_ScannerT::_S_token_dup_count))\n+\t    if (_M_match_token(_ScannerT::_S_token_dup_count)) // {3,7}\n \t      {\n-\t\tint __n = _M_cur_int_value(10) - __min_rep;\n-\t\tif (__n < 0)\n-\t\t  __throw_regex_error(regex_constants::error_badbrace);\n-\t\tfor (int __i = 0; __i < __n; ++__i)\n-\t\t  {\n-\t\t    _StateSeqT __r(_M_state_store,\n-\t\t\t\t  _M_state_store.\n-\t\t\t\t  _M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t_M_stack.top()._M_front()));\n-\t\t    _M_stack.top()._M_append(__r);\n-\t\t  }\n+\t        int __n = _M_cur_int_value(10) - __min_rep;\n+\t        if (__n < 0)\n+\t          __throw_regex_error(regex_constants::error_badbrace);\n+\t        auto __end = _M_nfa._M_insert_dummy();\n+\t        for (int __i = 0; __i < __n; ++__i)\n+\t          {\n+\t\t    auto __tmp = __r._M_clone();\n+\t\t    __e._M_append(_StateSeqT(_M_nfa, _M_nfa.\n+\t\t\t_M_insert_alt(__tmp._M_start, __end), __tmp._M_end));\n+\t          }\n+\t\t__e._M_append(__end);\n \t      }\n-\t    else\n+\t    else // {3,}\n \t      {\n-\t\t_StateSeqT __r(_M_stack.top(), -1);\n-\t\t__r._M_push_back(__r._M_front());\n-\t\t_M_stack.pop();\n-\t\t_M_stack.push(__r);\n+\t\tauto __tmp = __r._M_clone();\n+\t\t_StateSeqT __s(_M_nfa, _M_nfa._M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t\t\t    __tmp._M_start));\n+\t\t__tmp._M_append(__s);\n+\t\t__e._M_append(__s);\n \t      }\n \t  if (!_M_match_token(_ScannerT::_S_token_interval_end))\n \t    __throw_regex_error(regex_constants::error_brace);\n-\t  return;\n+\t  _M_stack.push(__e);\n \t}\n     }\n \n@@ -203,46 +238,50 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_atom()\n     {\n       if (_M_match_token(_ScannerT::_S_token_anychar))\n+\t_M_stack.push(_StateSeqT(_M_nfa,\n+\t\t\t\t_M_nfa._M_insert_matcher\n+\t\t\t\t(_AnyMatcher<_CharT, _TraitsT>(_M_traits))));\n+      else if (_M_try_char())\n+\t_M_stack.push(_StateSeqT(_M_nfa,\n+\t\t\t\t _M_nfa._M_insert_matcher\n+\t\t\t\t (_CharMatcher<_CharT, _TraitsT>(_M_value[0],\n+\t\t\t\t\t\t\t\t _M_traits,\n+\t\t\t\t\t\t\t\t _M_flags))));\n+      else if (_M_match_token(_ScannerT::_S_token_backref))\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n+\t\t\t\t _M_insert_backref(_M_cur_int_value(10))));\n+      else if (_M_match_token(_ScannerT::_S_token_quoted_class))\n \t{\n-\t  _M_stack.push(_StateSeqT(_M_state_store,\n-\t\t\t\t  _M_state_store._M_insert_matcher\n-\t\t\t\t  (_AnyMatcher<_CharT, _TraitsT>(_M_traits))));\n-\t  return true;\n-\t}\n-      if (_M_try_char())\n-\t{\n-\t  _M_stack.push(_StateSeqT(_M_state_store,\n-\t\t\t\t   _M_state_store._M_insert_matcher\n-\t\t\t\t   (_CharMatcher<_CharT, _TraitsT>(_M_value[0],\n-\t\t\t\t\t\t\t\t   _M_traits,\n-\t\t\t\t\t\t\t\t   _M_flags))));\n-\t  return true;\n+\t  _GLIBCXX_DEBUG_ASSERT(_M_value.size() == 1);\n+\t  _BMatcherT __matcher(_M_ctype.is(_CtypeT::upper, _M_value[0]),\n+\t\t\t       _M_traits, _M_flags);\n+\t  __matcher._M_add_character_class(_M_value);\n+\t  _M_stack.push(_StateSeqT(_M_nfa,\n+\t\t_M_nfa._M_insert_matcher(__matcher)));\n \t}\n-      if (_M_match_token(_ScannerT::_S_token_backref))\n+      else if (_M_match_token(_ScannerT::_S_token_subexpr_no_group_begin))\n \t{\n-\t  _M_stack.push(_StateSeqT(_M_state_store, _M_state_store.\n-\t\t\t\t   _M_insert_backref(_M_cur_int_value(10))));\n-\t  return true;\n+\t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_dummy());\n+\t  this->_M_disjunction();\n+\t  if (!_M_match_token(_ScannerT::_S_token_subexpr_end))\n+\t    __throw_regex_error(regex_constants::error_paren);\n+\t  __r._M_append(_M_pop());\n+\t  _M_stack.push(__r);\n \t}\n-      if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n+      else if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n \t{\n-\t  int __mark = _M_state_store._M_sub_count();\n-\t  _StateSeqT __r(_M_state_store,\n-\t\t\t_M_state_store.\n-\t\t\t_M_insert_subexpr_begin());\n+\t  int __mark = _M_nfa._M_sub_count();\n+\t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_subexpr_begin());\n \t  this->_M_disjunction();\n \t  if (!_M_match_token(_ScannerT::_S_token_subexpr_end))\n \t    __throw_regex_error(regex_constants::error_paren);\n-\t  if (!_M_stack.empty())\n-\t    {\n-\t      __r._M_append(_M_stack.top());\n-\t      _M_stack.pop();\n-\t    }\n-\t  __r._M_append(_M_state_store._M_insert_subexpr_end());\n+\t  __r._M_append(_M_pop());\n+\t  __r._M_append(_M_nfa._M_insert_subexpr_end());\n \t  _M_stack.push(__r);\n-\t  return true;\n \t}\n-      return _M_bracket_expression();\n+      else if (!_M_bracket_expression())\n+\treturn false;\n+      return true;\n     }\n \n   template<typename _FwdIter, typename _CharT, typename _TraitsT>\n@@ -255,51 +294,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (!(__neg || _M_match_token(_ScannerT::_S_token_bracket_begin)))\n \treturn false;\n       _BMatcherT __matcher(__neg, _M_traits, _M_flags);\n-      _M_bracket_list(__matcher);\n-      _M_stack.push(_StateSeqT(_M_state_store,\n-\t\t\t      _M_state_store._M_insert_matcher(__matcher)));\n+      while (!_M_match_token(_ScannerT::_S_token_bracket_end))\n+\t_M_expression_term(__matcher);\n+      _M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_matcher(__matcher)));\n       return true;\n     }\n \n-  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n-    void\n-    _Compiler<_FwdIter, _CharT, _TraitsT>::\n-    _M_bracket_list(_BMatcherT& __matcher)\n-    {\n-      if (_M_match_token(_ScannerT::_S_token_bracket_end))\n-\treturn;\n-      _M_expression_term(__matcher);\n-      _M_bracket_list(__matcher);\n-      return;\n-    }\n-\n   template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     void\n     _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_expression_term(_BMatcherT& __matcher)\n     {\n       if (_M_match_token(_ScannerT::_S_token_collsymbol))\n-\t{\n-\t  __matcher._M_add_collating_element(_M_value);\n-\t  return;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_equiv_class_name))\n-\t{\n-\t  __matcher._M_add_equivalence_class(_M_value);\n-\t  return;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_char_class_name))\n-\t{\n-\t  __matcher._M_add_character_class(_M_value);\n-\t  return;\n-\t}\n-      if (_M_try_char()) // [a\n+\t__matcher._M_add_collating_element(_M_value);\n+      else if (_M_match_token(_ScannerT::_S_token_equiv_class_name))\n+\t__matcher._M_add_equivalence_class(_M_value);\n+      else if (_M_match_token(_ScannerT::_S_token_char_class_name))\n+\t__matcher._M_add_character_class(_M_value);\n+      else if (_M_try_char()) // [a\n \t{\n \t  auto __ch = _M_value[0];\n \t  if (_M_try_char())\n \t    {\n-\t      if (_M_value[0] == std::use_facet<std::ctype<_CharT>>\n-\t\t   (_M_traits.getloc()).widen('-')) // [a-\n+\t      if (_M_value[0] == '-') // [a-\n \t\t{\n \t\t  if (_M_try_char()) // [a-z]\n \t\t    {\n@@ -315,9 +332,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      __matcher._M_add_char(_M_value[0]);\n \t    }\n \t  __matcher._M_add_char(__ch);\n-\t  return;\n \t}\n-      __throw_regex_error(regex_constants::error_brack);\n+      else\n+\t__throw_regex_error(regex_constants::error_brack);\n     }\n \n   template<typename _FwdIter, typename _CharT, typename _TraitsT>\n@@ -341,6 +358,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __is_char;\n     }\n \n+  template<typename _FwdIter, typename _CharT, typename _TraitsT>\n+    bool\n+    _Compiler<_FwdIter, _CharT, _TraitsT>::\n+    _M_match_token(_TokenT token)\n+    {\n+      if (token == _M_scanner._M_get_token())\n+\t{\n+\t  _M_value = _M_scanner._M_get_value();\n+\t  _M_scanner._M_advance();\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n   template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     int\n     _Compiler<_FwdIter, _CharT, _TraitsT>::"}, {"sha": "064c1832796fdec800bfb2cb8a112cfcea3d0d9b", "filename": "libstdc++-v3/include/bits/regex_scanner.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -86,6 +86,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_token_closure1,\n \t_S_token_line_begin,\n \t_S_token_line_end,\n+\t_S_token_word_bound,\n+\t_S_token_neg_word_bound,\n \t_S_token_comma,\n \t_S_token_dup_count,\n \t_S_token_eof,"}, {"sha": "3303aa56a38a553dd739818c4370f0b063ce6207", "filename": "libstdc++-v3/include/bits/regex_scanner.tcc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -28,7 +28,7 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n-// TODO make comments doxygen format\n+// TODO make comments doxygen format.\n \n // N3376 specified 6 regex styles: ECMAScript, basic, extended, grep, egrep\n // and awk\n@@ -370,10 +370,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_token = _S_token_ord_char;\n \t  _M_value.assign(1, _M_escape_map.at(__c));\n \t}\n+      else if (__c == 'b')\n+\t_M_token = _S_token_word_bound;\n+      else if (__c == 'B')\n+\t_M_token = _S_token_neg_word_bound;\n       // N3376 28.13\n-      else if (__c == 'b'\n-\t       || __c == 'B'\n-\t       || __c == 'd'\n+      else if (__c == 'd'\n \t       || __c == 'D'\n \t       || __c == 's'\n \t       || __c == 'S'"}, {"sha": "91bc101392b1eecc6f8c02a2b735c903ede663cb", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/basic/string_range_02_03.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fbasic%2Fstring_range_02_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fbasic%2Fstring_range_02_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fbasic%2Fstring_range_02_03.cc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -1,5 +1,4 @@\n // { dg-options \"-std=c++0x\" }\n-// { dg-do run { xfail *-*-* } }\n \n //\n // 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>"}, {"sha": "b54f5619a24c361779ca6d26fce6af2ab32b71ed", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/quoted_char.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Fquoted_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Fquoted_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Fquoted_char.cc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-09-05  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ECMAScript \\d \\D \\s \\S \\w \\W\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  VERIFY(regex_match(\"01\", regex(\"\\\\d*\")));\n+  VERIFY(regex_match(\"asdfjkl\", regex(\"\\\\D*\")));\n+  VERIFY(!regex_match(\"asdfjkl0\", regex(\"\\\\D*\")));\n+  VERIFY(regex_match(\"\\r\\t\\v\\f \", regex(\"\\\\s*\")));\n+  VERIFY(regex_match(\"asdfjkl\", regex(\"\\\\S*\")));\n+  VERIFY(!regex_match(\"asdfjkl\\r\", regex(\"\\\\S*\")));\n+  VERIFY(regex_match(\"_az\", regex(\"\\\\w*\")));\n+  VERIFY(regex_match(\"!@#$%\", regex(\"\\\\W*\")));\n+  VERIFY(!regex_match(\"_01234\", regex(\"\\\\W*\")));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "375f34b806456bc68635a82bae393dfe764abff1", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/cstring_plus.cc", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_plus.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_plus.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_plus.cc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -1,5 +1,4 @@\n // { dg-options \"-std=c++0x\" }\n-// { dg-do run { xfail *-*-* } }\n \n //\n // 2010-06-21  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n@@ -32,27 +31,31 @@ test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-\tstd::regex  re(\"(a+)\", std::regex::extended);\n-\tconst char target[] = \"aa\";\n-\tstd::cmatch m;\n+  std::regex  re(\"(a+)\", std::regex::extended);\n+  const char target[] = \"aa\";\n+  std::cmatch m;\n \n-\tVERIFY( std::regex_match(target, m, re) );\n+  VERIFY( std::regex_match(target, m, re) );\n \n-\tVERIFY( re.mark_count() == 1 );\n-\tVERIFY( m.size()  == re.mark_count()+1 );\n-\tVERIFY( m.empty() == false );\n-\tVERIFY( m.prefix().first == target );\n-\tVERIFY( m.prefix().second == target );\n-\tVERIFY( m.prefix().matched == false );\n-\tVERIFY( m.suffix().first == target+sizeof(target) );\n-\tVERIFY( m.suffix().second == target+sizeof(target) );\n-\tVERIFY( m.suffix().matched == false );\n-\tVERIFY( m[0].first == target );\n-\tVERIFY( m[0].second == target+sizeof(target) );\n-\tVERIFY( m[0].matched == true );\n-\tVERIFY( m[1].first == target );\n-\tVERIFY( m[1].second == target+sizeof(target) );\n-\tVERIFY( m[1].matched == true );\n+  VERIFY( re.mark_count() == 1 );\n+  VERIFY( m.size()  == re.mark_count()+1 );\n+  VERIFY( m.empty() == false );\n+  VERIFY( m.prefix().first == target );\n+  VERIFY( m.prefix().second == target );\n+  VERIFY( m.prefix().matched == false );\n+  VERIFY( m.suffix().first == target+sizeof(target)-1 );\n+  VERIFY( m.suffix().second == target+sizeof(target)-1 );\n+  VERIFY( m.suffix().matched == false );\n+  VERIFY( m[0].first == target );\n+  VERIFY( m[0].second == target+sizeof(target)-1 );\n+  VERIFY( m[0].matched == true );\n+  VERIFY( m[1].first == target );\n+  VERIFY( m[1].second == target+sizeof(target)-1 );\n+  VERIFY( m[1].matched == true );\n+\n+  VERIFY(!std::regex_match(\"\", std::regex(\"a+\", std::regex::extended)));\n+  VERIFY(std::regex_match(\"a\", std::regex(\"a+\", std::regex::extended)));\n+  VERIFY(std::regex_match(\"aa\", std::regex(\"a+\", std::regex::extended)));\n }\n \n "}, {"sha": "79b52a88c4f6337e18d5b9961f2724d07ca891bd", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/cstring_questionmark.cc", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_questionmark.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_questionmark.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_questionmark.cc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -1,5 +1,4 @@\n // { dg-options \"-std=c++0x\" }\n-// { dg-do run { xfail *-*-* } }\n \n //\n // 2010-06-21  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n@@ -32,27 +31,31 @@ test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-\tstd::regex  re(\"(aa?)\", std::regex::extended);\n-\tchar target[] = \"a\";\n-\tstd::cmatch m;\n+  std::regex  re(\"(aa?)\", std::regex::extended);\n+  char target[] = \"a\";\n+  std::cmatch m;\n \n-\tVERIFY( std::regex_match(target, m, re) );\n+  VERIFY( std::regex_match(target, m, re) );\n \n-\tVERIFY( re.mark_count() == 1 );\n-\tVERIFY( m.size()  == re.mark_count()+1 );\n-\tVERIFY( m.empty() == false );\n-\tVERIFY( m.prefix().first == target );\n-\tVERIFY( m.prefix().second == target );\n-\tVERIFY( m.prefix().matched == false );\n-\tVERIFY( m.suffix().first == target+sizeof(target) );\n-\tVERIFY( m.suffix().second == target+sizeof(target) );\n-\tVERIFY( m.suffix().matched == false );\n-\tVERIFY( m[0].first == target );\n-\tVERIFY( m[0].second == target+sizeof(target) );\n-\tVERIFY( m[0].matched == true );\n-\tVERIFY( m[1].first == target );\n-\tVERIFY( m[1].second == target+sizeof(target) );\n-\tVERIFY( m[1].matched == true );\n+  VERIFY( re.mark_count() == 1 );\n+  VERIFY( m.size()  == re.mark_count()+1 );\n+  VERIFY( m.empty() == false );\n+  VERIFY( m.prefix().first == target );\n+  VERIFY( m.prefix().second == target );\n+  VERIFY( m.prefix().matched == false );\n+  VERIFY( m.suffix().first == target+sizeof(target)-1 );\n+  VERIFY( m.suffix().second == target+sizeof(target)-1 );\n+  VERIFY( m.suffix().matched == false );\n+  VERIFY( m[0].first == target );\n+  VERIFY( m[0].second == target+sizeof(target)-1 );\n+  VERIFY( m[0].matched == true );\n+  VERIFY( m[1].first == target );\n+  VERIFY( m[1].second == target+sizeof(target)-1 );\n+  VERIFY( m[1].matched == true );\n+\n+  VERIFY(std::regex_match(\"\", std::regex(\"a?\", std::regex::extended)));\n+  VERIFY(std::regex_match(\"a\", std::regex(\"a?\", std::regex::extended)));\n+  VERIFY(!std::regex_match(\"aa\", std::regex(\"a?\", std::regex::extended)));\n }\n \n "}, {"sha": "62f825a0fb9644987caf20cc7c1d002443f4f082", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/cstring_range.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_range.cc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -0,0 +1,68 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-09-05  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests Extended interval range.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  regex re;\n+  re.assign(\"(ab){3}\", std::regex::extended);\n+  VERIFY(!regex_match(\"abab\", re));\n+  VERIFY(regex_match(\"ababab\", re));\n+  VERIFY(!regex_match(\"abababab\", re));\n+  re.assign(\"(ab){3,}\", std::regex::extended);\n+  VERIFY(!regex_match(\"abab\", re));\n+  VERIFY(regex_match(\"ababab\", re));\n+  VERIFY(regex_match(\"abababab\", re));\n+  VERIFY(regex_match(\"ababababab\", re));\n+  re.assign(\"(ab){0,3}\", std::regex::extended);\n+  VERIFY(regex_match(\"\", re));\n+  VERIFY(regex_match(\"ab\", re));\n+  VERIFY(regex_match(\"abab\", re));\n+  VERIFY(regex_match(\"ababab\", re));\n+  VERIFY(!regex_match(\"abababab\", re));\n+  re.assign(\"(a|b){0,2}\", std::regex::extended);\n+  VERIFY(regex_match(\"\", re));\n+  VERIFY(regex_match(\"a\", re));\n+  VERIFY(regex_match(\"b\", re));\n+  VERIFY(regex_match(\"aa\", re));\n+  VERIFY(regex_match(\"ab\", re));\n+  VERIFY(regex_match(\"ba\", re));\n+  VERIFY(regex_match(\"bb\", re));\n+  VERIFY(!regex_match(\"aaa\", re));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "e10dba81ffaf91648ea8d4a678ba668e75fc2602", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/string_range_00_03.cc", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_range_00_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_range_00_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_range_00_03.cc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -31,23 +31,23 @@ test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-\tstd::regex  re(\"a{0,3}\", std::regex::extended);\n-\tstd::string target(\"aa\");\n-\tstd::smatch m;\n-\n-\tVERIFY( std::regex_match(target, m, re) );\n-\n-\tVERIFY( m.size()  == re.mark_count()+1 );\n-\tVERIFY( m.empty() == false );\n-\tVERIFY( m.prefix().first == target.begin() );\n-\tVERIFY( m.prefix().second == target.begin() );\n-\tVERIFY( m.prefix().matched == false );\n-\tVERIFY( m.suffix().first == target.end() );\n-\tVERIFY( m.suffix().second == target.end() );\n-\tVERIFY( m.suffix().matched == false );\n-\tVERIFY( m[0].first == target.begin() );\n-\tVERIFY( m[0].second == target.end() );\n-\tVERIFY( m[0].matched == true );\n+  std::regex  re(\"a{0,3}\", std::regex::extended);\n+  std::string target(\"aa\");\n+  std::smatch m;\n+\n+  VERIFY( std::regex_match(target, m, re) );\n+\n+  VERIFY( m.size()  == re.mark_count()+1 );\n+  VERIFY( m.empty() == false );\n+  VERIFY( m.prefix().first == target.begin() );\n+  VERIFY( m.prefix().second == target.begin() );\n+  VERIFY( m.prefix().matched == false );\n+  VERIFY( m.suffix().first == target.end() );\n+  VERIFY( m.suffix().second == target.end() );\n+  VERIFY( m.suffix().matched == false );\n+  VERIFY( m[0].first == target.begin() );\n+  VERIFY( m[0].second == target.end() );\n+  VERIFY( m[0].matched == true );\n }\n \n "}, {"sha": "62793b4a1995c320c62ef25a8d92a1fb9defe286", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/string_range_02_03.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_range_02_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_range_02_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_range_02_03.cc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -1,5 +1,4 @@\n // { dg-options \"-std=c++0x\" }\n-// { dg-do run { xfail *-*-* } }\n \n //\n // 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>"}, {"sha": "cd2c68e33eeb4a6d6c6f9da12c81d99b84a2ad7b", "filename": "libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/wchar_t/string_02.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_02.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c812a2a57e58218eea234b80386197d1fe7672a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_02.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_02.cc?ref=7c812a2a57e58218eea234b80386197d1fe7672a", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-require-namedlocale \"en_US.UTF-8\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2013-09-05  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.1 regex_iterator\n+// Tests regex_iterator class\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::setlocale(LC_ALL, \"en_US.UTF-8\");\n+\n+  std::wstring str2 = L\"\u00e4\\u2009\u00c4\\u2009\u00f6\\u2009\u00d6\\u2009\u00fc\\u2009\u00dc\";\n+\n+  std::wregex re2;\n+  re2.imbue(std::locale(\"en_US.UTF-8\"));\n+\n+  re2.assign(L\"([[:lower:]]{0,1}[[:space:]]{0,1}[[:upper:]]{0,1})\");\n+\n+  std::wsregex_iterator p(str2.begin(), str2.end(), re2);\n+  auto a = p;\n+  ++p;\n+  VERIFY(a != p);\n+  //for (std::wsregex_iterator p(str2.begin(), str2.end(), re2);\n+  //    p != std::wsregex_iterator{}; ++p)\n+  //  std::wcout << (*p)[1] << std::endl;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}