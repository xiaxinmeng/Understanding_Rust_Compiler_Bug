{"sha": "7dd4ba48c445cbc9c729a416c3e153c83b90cb1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RkNGJhNDhjNDQ1Y2JjOWM3MjlhNDE2YzNlMTUzYzgzYjkwY2IxZg==", "commit": {"author": {"name": "Loren J. Rittle", "email": "ljrittle@acm.org", "date": "2001-11-16T20:59:10Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2001-11-16T20:59:10Z"}, "message": "howto.html (Thread-safety): Rename section to ``The Standard C++ library and multithreading'' and update...\n\n        * docs/html/17_intro/howto.html (Thread-safety): Rename\n        section to ``The Standard C++ library and multithreading'' and\n        update information based on recent mailing list traffic.  Move\n        all discussion of __USE_MALLOC to...\n        * docs/html/23_containers/howto.html (Containers and multithreading):\n        ...here and rework it based on recent mailing list traffic.\n\nFrom-SVN: r47102", "tree": {"sha": "2015d6de525a31b69c54cf2b334bfc43a5d42928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2015d6de525a31b69c54cf2b334bfc43a5d42928"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f/comments", "author": null, "committer": null, "parents": [{"sha": "847898f6f563031bad4d5b3f3587146f5549627c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/847898f6f563031bad4d5b3f3587146f5549627c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/847898f6f563031bad4d5b3f3587146f5549627c"}], "stats": {"total": 161, "additions": 111, "deletions": 50}, "files": [{"sha": "4feb240405132a077e743892c1cb2e39e45a2224", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7dd4ba48c445cbc9c729a416c3e153c83b90cb1f", "patch": "@@ -1,3 +1,12 @@\n+2001-11-16  Loren J. Rittle  <ljrittle@acm.org>\n+\n+\t* docs/html/17_intro/howto.html (Thread-safety): Rename\n+\tsection to ``The Standard C++ library and multithreading'' and\n+\tupdate information based on recent mailing list traffic.  Move\n+\tall discussion of __USE_MALLOC to...\n+\t* docs/html/23_containers/howto.html (Containers and multithreading):\n+\t...here and rework it based on recent mailing list traffic.\n+\n 2001-11-15  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* docs/html/faq/index.html (Is libstdc++-v3 thread-safe?): Clarify"}, {"sha": "c4bfcc3f28796d847a88ab6bdfc2cdca76a5f08e", "filename": "libstdc++-v3/docs/html/17_intro/howto.html", "status": "modified", "additions": 68, "deletions": 50, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html?ref=7dd4ba48c445cbc9c729a416c3e153c83b90cb1f", "patch": "@@ -25,7 +25,7 @@ <h1 class=\"centered\"><a name=\"top\">Chapter 17:  Library Introduction</a></h1>\n <h1>Contents</h1>\n <ul>\n    <li><a href=\"#2\">The Standard C++ header files</a>\n-   <li><a href=\"#3\">Thread-safety</a>\n+   <li><a href=\"#3\">The Standard C++ library and multithreading</a>\n    <li><a href=\"#4\"><code>&lt;foo&gt;</code> vs <code>&lt;foo.h&gt;</code></a>\n    <li><a href=\"porting-howto.html\">Porting HOWTO</a>\n </ul>\n@@ -50,59 +50,77 @@ <h2><a name=\"2\">The Standard C++ header files</a></h2>\n    </p>\n \n <hr>\n-<h2><a name=\"3\">Thread-safety</a></h2>\n-   <p>This is a thorny issue that gets brought up on the libstdc++-v3\n-      and gcc mailing lists on a regular basis (probably by a cron job).\n-      This entry will mention a very little bit about the general MT\n-      issues with libstdc++.  The latest status and quick notes will be\n-      in FAQ 5.6.  Some discussion about thread-safe containers will be\n-      in section 6.8 (the HOWTOs on containers).  This section only applies\n-      when gcc and libstdc++-v3 were configured with --enable-threads.\n+<h2><a name=\"3\">The Standard C++ library and multithreading</a></h2>\n+   <p>This section discusses issues surrounding the proper compilation\n+      of multithreaded applications which use the Standard C++\n+      library.  This information is gcc-specific since the C++\n+      standard does not address matters of multithreaded applications.\n+      Unless explicitly prefaced, all information in this section is\n+      current as of the gcc 3.0 release and all later point releases.\n    </p>\n-   <p>The libstdc++ code (all of it, not just the containers) has been\n-      designed so that thread-safety will be easily possible.  The first\n-      (!) problem is finding a <em>fast</em> method of implementation\n-      portable to all platforms.  A minor problem that pops up every so\n-      often is different interpretations of what &quot;thread-safe&quot;\n-      means for a library (not a general program).  We currently use the\n-      <a href=\"http://www.sgi.com/tech/stl/thread_safety.html\">same\n-      definition that SGI</a> uses for their STL subset.\n-      <em>Please see the many cautions given in\n-      <a href=\"../23_containers/howto.html\">HOWTOs on containers</a>.</em>\n+   <p>Earlier gcc releases had a somewhat different approach to\n+      threading configuration and proper compilation.  Before gcc 3.0,\n+      configuration of the threading model was dictated by compiler\n+      command-line options and macros (both of which were somewhat\n+      thread-implementation and port-specific).  There were no\n+      guarantees related to being able to link code compiled with one\n+      set of options and macro setting with another set.  For gcc 3.0,\n+      configuration of the threading model used with libraries and\n+      user-code is performed when gcc is configured and built using\n+      the --enable-threads and --disable-threads options.  The ABI is\n+      stable for symbol name-mangling and limited functional\n+      compatibility exists between code compiled under different\n+      threading models.\n    </p>\n-   <p>Here is another attempt at explaining the dangers of using the\n-      STL with threading support without understanding some important\n-      details.  The STL implementation is currently configured to use\n-      the high-speed caching memory allocator.  If you absolutely\n-      think you must change this on a global basis for your platform\n-      to support multi-threading, then please consult all commentary\n-      in include/bits/c++config and the HOWTOs on containers.  Be\n-      fully aware that you may change the external or internal ABI of\n-      libstdc++-v3 when you provide -D__USE_MALLOC on the command line\n-      or make a change to that configuration file.\n+   <p>All normal disclaimers aside, multithreaded C++ application are\n+      only supported when libstdc++ and all user code was built with\n+      compilers which report (via <em>gcc/g++ -v</em>) the same thread\n+      model and that model is not <em>single</em>.  As long as your\n+      final application is actually single-threaded, then it should be\n+      safe to mix user code built with a thread model of\n+      <em>single</em> with a libstdc++ and other C++ libraries built\n+      with another thread model useful on the platform.  Other mixes\n+      may or may not work but are not considered supported.  (Thus, if\n+      you distribute a shared C++ library in binary form only, it may\n+      be best to compile it with a gcc configured with\n+      --enable-threads for maximal interchangeability and usefulness\n+      with a user population that may have built gcc with either\n+      --enable-threads or --disable-threads.)\n    </p>\n-   <p>If you don't like caches of objects being retained inside the STL, then\n-      you might be tempted to define __USE_MALLOC either on the command\n-      line or by rebuilding c++config.h.  Please note, once you define\n-      __USE_MALLOC, only the malloc allocator is visible to application code\n-      (i.e. the typically higher-speed allocator is not even available\n-      in this configuration).  There is a better way:  It is possible\n-      to force the malloc-based allocator on a per-case-basis for some\n-      application code even when the above macro symbol is not defined.\n-      The library team generally believes that this is a better way to tune\n-      an application for high-speed using this implementation of the STL.\n-      Here is one possible example displaying the forcing of the malloc-based\n-      allocator over the typically higher-speed default allocator:\n-      <pre>\n-      std::list &lt;my_type, std::malloc_alloc&gt;  my_malloc_based_list;</pre>\n+   <p>When you link a multithreaded application, you will probably\n+      need to add a library or flag to g++.  This is a very\n+      non-standardized area of gcc across ports.  Some ports support a\n+      special flag (the spelling isn't even standardized yet) to add\n+      all required macros to a compilation (if any such flags are\n+      required then you must provide the flag for all compilations not\n+      just linking) and link-library additions and/or replacements at\n+      link time.  The documentation is weak.  Here is a quick summary\n+      to display how ad hoc this is: On Solaris, both -pthreads and\n+      -threads (with subtly different meanings) are honored.  On OSF,\n+      -pthread and -threads (with subtly different meanings) are\n+      honored.  On Linux/i386, -pthread is honored.  On FreeBSD,\n+      -pthread is honored.  Some other ports use other switches.\n+      AFAIK, none of this is properly documented anywhere other than\n+      in ``gcc -dumpspecs'' (look at lib and cpp entries).\n    </p>\n-   <p>A recent journal article has described &quot;atomic integer\n-      operations,&quot; which would allow us to, well, perform updates\n-      on integers atomically, and without requiring an explicit mutex\n-      lock.  This appears promising, but the major difficulty is that\n-      these operations &quot;may not be available on all systems, and\n-      if they are, may have different interfaces.&quot; [quoting from\n-      mailing list messages]\n+   <p>See <a href=\"../faq/index.html#3\">FAQ</a> (general overview), <a\n+      href=\"../23_containers/howto.html#3\">23</a> (containers), and <a\n+      href=\"../27_io/howto.html#9\">27</a> (I/O) for more information.\n+   </p>\n+   <p>The libstdc++-v3 library (unlike libstdc++-v2, all of it, not\n+      just the STL) has been designed so that multithreaded\n+      applications using it may be written.  The first problem is\n+      finding a <em>fast</em> method of implementation portable to all\n+      platforms.  Due to historical reasons, some of the library is\n+      written against per-CPU-architecture spinlocks and other parts\n+      against the gthr.h abstraction layer which is provided by gcc.\n+      A minor problem that pops up every so often is different\n+      interpretations of what &quot;thread-safe&quot; means for a\n+      library (not a general program).  We currently use the <a\n+      href=\"http://www.sgi.com/tech/stl/thread_safety.html\">same\n+      definition that SGI</a> uses for their STL subset.  However, the\n+      exception for read-only containers only applies to the STL\n+      components.\n    </p>\n    <p>Here is a small link farm to threads (no pun) in the mail archives\n       that discuss the threading problem.  Each link is to the first"}, {"sha": "8cdaab1615ae9c1a3a03e81ff8a08bef0bfbc01d", "filename": "libstdc++-v3/docs/html/23_containers/howto.html", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dd4ba48c445cbc9c729a416c3e153c83b90cb1f/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html?ref=7dd4ba48c445cbc9c729a416c3e153c83b90cb1f", "patch": "@@ -242,6 +242,40 @@ <h2><a name=\"3\">Containers and multithreading</a></h2>\n       mechanism.  Trying to provide a catch-all general template\n       solution would probably be more trouble than it's worth.\n    </p>\n+   <p>The STL implementation is currently configured to use the\n+      high-speed caching memory allocator.  If you absolutely think\n+      you must change this on a global basis for your platform to\n+      better support multi-threading, then please consult all\n+      commentary in include/bits/c++config.  (Explicit warning since\n+      so many people post after getting confused while attempting\n+      this:) Adding -D__USE_MALLOC on the command line is not a good\n+      idea.  Related to threading or otherwise, the current\n+      recommendation is that users not add any macro defines on the\n+      command line to enable features out of libstdc++-v3.  There is\n+      no condition under which it will help you without causing other\n+      issues to perhaps raise up (possible linkage/ABI problems).  In\n+      particular, __USE_MALLOC should only be added to a libstdc++-v3\n+      configuration file, include/bits/c++config (where such user\n+      action is cautioned against), and the entire library should be\n+      rebuilt.  If you do not, then you might be violating the\n+      one-definition rule of C/C++ and you might cause yourself untold\n+      problems.  If you find any platform where gcc reports a\n+      threading model other than single and where libstdc++-v3 builds\n+      a buggy container allocator when used with threads unless you\n+      define __USE_MALLOC, we want to hear about it ASAP.  In the\n+      past, correctness was the main reason people were led to believe\n+      that they should define __USE_MALLOC when using threads.\n+   </p>\n+   <p>There is a better way (not standardized yet): It is possible to\n+      force the malloc-based allocator on a per-case-basis for some\n+      application code.  The library team generally believes that this\n+      is a better way to tune an application for high-speed using this\n+      implementation of the STL.  Here is one possible example\n+      displaying the forcing of the malloc-based allocator over the\n+      typically higher-speed default allocator:\n+      <pre>\n+      std::list &lt;my_type, std::__malloc_alloc_template&lt;0&gt; &gt;  my_malloc_based_list;</pre>\n+   </p>\n    <p>Return <a href=\"#top\">to top of page</a> or\n       <a href=\"../faq/index.html\">to the FAQ</a>.\n    </p>"}]}