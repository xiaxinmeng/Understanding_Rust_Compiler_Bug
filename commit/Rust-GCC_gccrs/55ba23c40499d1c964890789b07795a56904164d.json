{"sha": "55ba23c40499d1c964890789b07795a56904164d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTViYTIzYzQwNDk5ZDFjOTY0ODkwNzg5YjA3Nzk1YTU2OTA0MTY0ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-07T10:49:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-07T10:49:53Z"}, "message": "trans.c (call_to_gnu): In the return-by-target-ptr case do not set the result type if...\n\n\t* gcc-interface/trans.c (call_to_gnu): In the return-by-target-ptr case\n\tdo not set the result type if there is a specified target and do not\n\tconvert the result in any cases.\n\t(protect_multiple_eval): Make direct SAVE_EXPR for CALL_EXPR.\n\t(maybe_stabilize_reference) <COMPOUND_EXPR>: Merge with CALL_EXPR.\n\nFrom-SVN: r158053", "tree": {"sha": "3bc081d5d0f96735caf03554ef6eabd3ed90486b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bc081d5d0f96735caf03554ef6eabd3ed90486b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55ba23c40499d1c964890789b07795a56904164d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55ba23c40499d1c964890789b07795a56904164d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55ba23c40499d1c964890789b07795a56904164d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55ba23c40499d1c964890789b07795a56904164d/comments", "author": null, "committer": null, "parents": [{"sha": "6392bea6024d79cc95344b1ed8c1d70a0e669fa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6392bea6024d79cc95344b1ed8c1d70a0e669fa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6392bea6024d79cc95344b1ed8c1d70a0e669fa0"}], "stats": {"total": 71, "additions": 30, "deletions": 41}, "files": [{"sha": "89f5cad29866e2cb9ab42987b555195d45ca271d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55ba23c40499d1c964890789b07795a56904164d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55ba23c40499d1c964890789b07795a56904164d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=55ba23c40499d1c964890789b07795a56904164d", "patch": "@@ -1,3 +1,11 @@\n+2010-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (call_to_gnu): In the return-by-target-ptr case\n+\tdo not set the result type if there is a specified target and do not\n+\tconvert the result in any cases.\n+\t(protect_multiple_eval): Make direct SAVE_EXPR for CALL_EXPR.\n+\t(maybe_stabilize_reference) <COMPOUND_EXPR>: Merge with CALL_EXPR.\n+\n 2010-03-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Makefile.in (SPARC/Solaris): Use sparcv8plus."}, {"sha": "fb770e8ebb6cc9386eaabd0d6e08e9aeb83f65c1", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55ba23c40499d1c964890789b07795a56904164d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55ba23c40499d1c964890789b07795a56904164d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=55ba23c40499d1c964890789b07795a56904164d", "patch": "@@ -2464,6 +2464,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    = create_var_decl (create_tmp_var_name (\"LR\"), NULL, gnu_obj_type,\n \t\t\t       NULL, false, false, false, false, NULL,\n \t\t\t       gnat_node);\n+\n+\t  *gnu_result_type_p = gnu_ret_type;\n \t}\n \n       gnu_actual_list\n@@ -2788,38 +2790,19 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n      the call should be emitted or not.  */\n   if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n     {\n-      /* Conceptually, what we need is a COMPOUND_EXPR with the call followed\n-\t by the target object converted to the proper type.  Doing so would\n-\t potentially be very inefficient, however, as this expression might\n-\t end up wrapped into an outer SAVE_EXPR later on, which would incur a\n-\t pointless temporary copy of the whole object.\n+      /* Conceptually, what we need is a COMPOUND_EXPR of the call followed by\n+\t the target object.  Doing so would potentially be inefficient though,\n+\t as this expression might be wrapped up into a SAVE_EXPR later, which\n+\t would incur a pointless temporary copy of the whole object.\n \n \t What we do instead is build a COMPOUND_EXPR returning the address of\n-\t the target, and then dereference.  Wrapping the COMPOUND_EXPR into a\n-\t SAVE_EXPR later on then only incurs a pointer copy.  */\n-\n-      tree gnu_result_type\n-\t= TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (gnu_subprog_type)));\n-\n-      /* Build and return\n-\t (result_type) *[gnu_subprog_call (&gnu_target, ...), &gnu_target]  */\n-\n-      tree gnu_target_address\n-\t= build_unary_op (ADDR_EXPR, NULL_TREE, gnu_target);\n-      set_expr_location_from_node (gnu_target_address, gnat_node);\n-\n-      gnu_result\n-\t= build2 (COMPOUND_EXPR, TREE_TYPE (gnu_target_address),\n-\t\t  gnu_subprog_call, gnu_target_address);\n-\n-      gnu_result\n-\t= unchecked_convert (gnu_result_type,\n-\t\t\t     build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t\t     gnu_result),\n-\t\t\t     false);\n-\n-      *gnu_result_type_p = gnu_result_type;\n-      return gnu_result;\n+\t the target, and then dereference.  Wrapping up the COMPOUND_EXPR into\n+\t a SAVE_EXPR then only incurs a mere pointer copy.  */\n+      tree gnu_target_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_target);\n+      set_expr_location_from_node (gnu_target_addr, gnat_node);\n+      gnu_result = build2 (COMPOUND_EXPR, TREE_TYPE (gnu_target_addr),\n+\t\t\t   gnu_subprog_call, gnu_target_addr);\n+      return build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n     }\n \n   /* If it is a function call, the result is the call expression unless\n@@ -7321,12 +7304,16 @@ protect_multiple_eval (tree exp)\n   return build1 (TREE_CODE (exp), type,\n \t\t protect_multiple_eval (TREE_OPERAND (exp, 0)));\n \n-  /* If this is a fat pointer or something that can be placed into a\n-     register, just make a SAVE_EXPR.  */\n-  if (TYPE_IS_FAT_POINTER_P (type) || TYPE_MODE (type) != BLKmode)\n+  /* If this is a fat pointer or something that can be placed in a register,\n+     just make a SAVE_EXPR.  Likewise for a CALL_EXPR as large objects are\n+     returned via invisible reference in most ABIs so the temporary will\n+     directly be filled by the callee.  */\n+  if (TYPE_IS_FAT_POINTER_P (type)\n+      || TYPE_MODE (type) != BLKmode\n+      || TREE_CODE (exp) == CALL_EXPR)\n     return save_expr (exp);\n \n-  /* Otherwise, reference, protect the address and dereference.  */\n+  /* Otherwise reference, protect the address and dereference.  */\n   return\n     build_unary_op (INDIRECT_REF, type,\n \t\t    save_expr (build_unary_op (ADDR_EXPR,\n@@ -7403,14 +7390,8 @@ maybe_stabilize_reference (tree ref, bool force, bool *success)\n \t\t       NULL_TREE, NULL_TREE);\n       break;\n \n-    case COMPOUND_EXPR:\n-      result = gnat_stabilize_reference_1 (ref, force);\n-      break;\n-\n     case CALL_EXPR:\n-      /* This generates better code than the scheme in protect_multiple_eval\n-\t because large objects will be returned via invisible reference in\n-\t most ABIs so the temporary will directly be filled by the callee.  */\n+    case COMPOUND_EXPR:\n       result = gnat_stabilize_reference_1 (ref, force);\n       break;\n "}]}