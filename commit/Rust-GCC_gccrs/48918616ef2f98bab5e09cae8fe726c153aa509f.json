{"sha": "48918616ef2f98bab5e09cae8fe726c153aa509f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg5MTg2MTZlZjJmOThiYWI1ZTA5Y2FlOGZlNzI2YzE1M2FhNTA5Zg==", "commit": {"author": {"name": "Roman Kennke", "email": "roman@ontographics.com", "date": "2005-04-19T06:16:17Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-19T06:16:17Z"}, "message": "2005-04-19  Roman Kennke  <roman@ontographics.com>\n\n\t* javax/swing/JList.java\n\t(getPreferredScrollableViewportSize):\n\tThe previous implementation was merely guessing the size,\n\tnow it respects layoutOrientation, visibleRowCount\n\tand preferredSize.\n\t(getScrollableTracksViewportHeight):\n\tReimplemented so that layoutOrientation, visibleRowCount\n\tand preferred size are respected.\n\t(getScrollableTracksViewportWidth):\n\tReimplemented so that layoutOrientation, visibleRowCount\n\tand preferred size are respected.\n\t* javax/swing/plaf/basic/BasicListUI.java\n\t(getPreferredSize):\n\tImproved calculation of preferredSize when JList is\n\tset to HORIZONTAL_WRAP or VERTICAL_WRAP.\n\t(getCellBounds):\n\tThe previous implementation assumed a layoutOrientation of\n\tJList.VERTICAL, now also ok with JList.HORIZONTAL_WRAP and\n\tJList.VERTICAL_WRAP.\n\n2005-04-19  Roman Kennke  <roman@ontographics.com>\n\n\t* javax/swing/plaf/basic/BasicListUI.java\n\t(paintCell): use CellRendererPane for painting the cells.\n\n2005-04-19  Roman Kennke  <roman@ontographics.com>\n\n\t* javax/swing/plaf/basic/BasicListUI:\n\tfixed modifiers of several fields, methods and inner\n\tclasses to match the 'spec'.\n\t(getMaximumSize): removed. It's not in the spec and the\n\timplementations was superfluous.\n\n2005-04-19  Roman Kennke  <roman@ontographics.com>\n\n\t* javax/swing/plaf/basic/BasicListUI:\n\tmake BasicListUI capable of wrapping lists\n\t(layoutOrientation property of javax.swing.JList)\n\n2005-04-19  Roman Kennke  <roman@ontographics.com>\n\n\t* javax/swing/plaf/basic/BasicListUI\n\t(updateLayoutState,paint): make BasicListUI aware of the\n\twidth of the rendered JList.\n\nFrom-SVN: r98385", "tree": {"sha": "1dca6700c6ae7fabc5104e3945bafaea71208f18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dca6700c6ae7fabc5104e3945bafaea71208f18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48918616ef2f98bab5e09cae8fe726c153aa509f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48918616ef2f98bab5e09cae8fe726c153aa509f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48918616ef2f98bab5e09cae8fe726c153aa509f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48918616ef2f98bab5e09cae8fe726c153aa509f/comments", "author": null, "committer": null, "parents": [{"sha": "b9d896d6002cad7cb268a7c6084e0008561aa4ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9d896d6002cad7cb268a7c6084e0008561aa4ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9d896d6002cad7cb268a7c6084e0008561aa4ea"}], "stats": {"total": 394, "additions": 310, "deletions": 84}, "files": [{"sha": "88bae2057a7996163eeaec4a11f1bcaf8f6d2f9f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48918616ef2f98bab5e09cae8fe726c153aa509f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48918616ef2f98bab5e09cae8fe726c153aa509f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=48918616ef2f98bab5e09cae8fe726c153aa509f", "patch": "@@ -1,3 +1,50 @@\n+2005-04-19  Roman Kennke  <roman@ontographics.com>\n+\n+\t* javax/swing/JList.java\n+\t(getPreferredScrollableViewportSize):\n+\tThe previous implementation was merely guessing the size,\n+\tnow it respects layoutOrientation, visibleRowCount\n+\tand preferredSize.\n+\t(getScrollableTracksViewportHeight):\n+\tReimplemented so that layoutOrientation, visibleRowCount\n+\tand preferred size are respected.\n+\t(getScrollableTracksViewportWidth):\n+\tReimplemented so that layoutOrientation, visibleRowCount\n+\tand preferred size are respected.\n+\t* javax/swing/plaf/basic/BasicListUI.java\n+\t(getPreferredSize):\n+\tImproved calculation of preferredSize when JList is\n+\tset to HORIZONTAL_WRAP or VERTICAL_WRAP.\n+\t(getCellBounds):\n+\tThe previous implementation assumed a layoutOrientation of\n+\tJList.VERTICAL, now also ok with JList.HORIZONTAL_WRAP and\n+\tJList.VERTICAL_WRAP.\n+\n+2005-04-19  Roman Kennke  <roman@ontographics.com>\n+\n+\t* javax/swing/plaf/basic/BasicListUI.java\n+\t(paintCell): use CellRendererPane for painting the cells.\n+\n+2005-04-19  Roman Kennke  <roman@ontographics.com>\n+\n+\t* javax/swing/plaf/basic/BasicListUI:\n+\tfixed modifiers of several fields, methods and inner\n+\tclasses to match the 'spec'.\n+\t(getMaximumSize): removed. It's not in the spec and the\n+\timplementations was superfluous.\n+\n+2005-04-19  Roman Kennke  <roman@ontographics.com>\n+\n+\t* javax/swing/plaf/basic/BasicListUI:\n+\tmake BasicListUI capable of wrapping lists\n+\t(layoutOrientation property of javax.swing.JList)\n+\n+2005-04-19  Roman Kennke  <roman@ontographics.com>\n+\n+\t* javax/swing/plaf/basic/BasicListUI\n+\t(updateLayoutState,paint): make BasicListUI aware of the\n+\twidth of the rendered JList.\n+\n 2005-04-19  Roman Kennke  <roman@kennke.org>\n \n \t* javax/swing/ImageIcon.java"}, {"sha": "d9e9fee7f7c16d7a6ce39b9a1d645f86dce7096e", "filename": "libjava/javax/swing/JList.java", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48918616ef2f98bab5e09cae8fe726c153aa509f/libjava%2Fjavax%2Fswing%2FJList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48918616ef2f98bab5e09cae8fe726c153aa509f/libjava%2Fjavax%2Fswing%2FJList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJList.java?ref=48918616ef2f98bab5e09cae8fe726c153aa509f", "patch": "@@ -1029,32 +1029,20 @@ public AccessibleContext getAccessibleContext()\n    */\n   public Dimension getPreferredScrollableViewportSize()\n   {\n-    int vis = getVisibleRowCount();\n-    int nrows = getModel() == null ? 0 : getModel().getSize();\n-    // FIXME: this is a somewhat arbitrary default, but.. ?\n-    Dimension single = new Dimension(10, 10);;\n-    Rectangle bounds = null;\n \n-    if (vis > nrows)\n+    Dimension retVal = getPreferredSize();\n+    if (getLayoutOrientation() == VERTICAL)\n       {\n-        if (fixedCellWidth != -1 && \n-            fixedCellHeight != -1)\n+        if (fixedCellHeight != -1)\n           {\n-            single = new Dimension(fixedCellWidth, fixedCellHeight);\n-          }\n-        else if (nrows != 0 && getUI() != null)\n-          {\n-            Rectangle tmp = getUI().getCellBounds(this, 0, 0);\n-            if (tmp != null)\n-              single = tmp.getSize();\n-          }\n-      }\n-    else if (getUI() != null)\n-      {\n-        return getUI().getCellBounds(this, 0, vis - 1).getSize();\n+            if (fixedCellWidth != -1)\n+              {\n+                int size = getModel().getSize();\n+                retVal = new Dimension(fixedCellWidth, size * fixedCellHeight);\n+              } // TODO: add else clause (preferredSize is ok for now)\n+          } // TODO: add else clause (preferredSize is ok for now)\n       }\n-\n-    return new Dimension(single.width, single.height * vis);\n+    return retVal;\n   }\n \n   /**\n@@ -1193,7 +1181,19 @@ public int getScrollableBlockIncrement(Rectangle visibleRect,\n    */\n   public boolean getScrollableTracksViewportWidth()\n   {\n-    return false;\n+    Component parent = getParent();\n+    boolean retVal = false;\n+    if (parent instanceof JViewport)\n+      {\n+        JViewport viewport = (JViewport) parent;\n+        Dimension pref = getPreferredSize();\n+        if (viewport.getSize().width > pref.width)\n+          retVal = true;\n+        if ((getLayoutOrientation() == HORIZONTAL_WRAP)\n+            && (getVisibleRowCount() <= 0))\n+          retVal = true;\n+      }\n+    return retVal;\n   }\n \n   /**\n@@ -1206,7 +1206,19 @@ public boolean getScrollableTracksViewportWidth()\n    */\n   public boolean getScrollableTracksViewportHeight()\n   {\n-    return false;\n+    Component parent = getParent();\n+    boolean retVal = false;\n+    if (parent instanceof JViewport)\n+      {\n+        JViewport viewport = (JViewport) parent;\n+        Dimension pref = getPreferredSize();\n+        if (viewport.getSize().height > pref.height)\n+          retVal = true;\n+        if ((getLayoutOrientation() == VERTICAL_WRAP)\n+            && (getVisibleRowCount() <= 0))\n+          retVal = true;\n+      }\n+    return retVal;\n   }\n \n   public int getAnchorSelectionIndex()"}, {"sha": "8cb0cb4c68cdd2245820feeec3e8ccbaecdc39bb", "filename": "libjava/javax/swing/plaf/basic/BasicListUI.java", "status": "modified", "additions": 227, "deletions": 60, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48918616ef2f98bab5e09cae8fe726c153aa509f/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48918616ef2f98bab5e09cae8fe726c153aa509f/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java?ref=48918616ef2f98bab5e09cae8fe726c153aa509f", "patch": "@@ -44,14 +44,19 @@\n import java.awt.Graphics;\n import java.awt.Point;\n import java.awt.Rectangle;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n import java.awt.event.FocusEvent;\n import java.awt.event.FocusListener;\n import java.awt.event.MouseEvent;\n import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n \n+import javax.swing.CellRendererPane;\n import javax.swing.JComponent;\n import javax.swing.JList;\n+import javax.swing.JViewport;\n import javax.swing.ListCellRenderer;\n import javax.swing.ListModel;\n import javax.swing.ListSelectionModel;\n@@ -71,11 +76,27 @@\n  */\n public class BasicListUI extends ListUI\n {\n+\n+  /**\n+   * A helper class which listens for {@link ComponentEvent}s from\n+   * the JList.\n+   */\n+  private class ComponentHandler extends ComponentAdapter {\n+\n+    /**\n+     * Called when the component is hidden. Invalidates the internal\n+     * layout.\n+     */\n+    public void componentResized(ComponentEvent ev) {\n+      BasicListUI.this.damageLayout();\n+    }\n+  }\n+\n   /**\n    * A helper class which listens for {@link FocusEvents}\n    * from the JList.\n    */\n-  class FocusHandler implements FocusListener\n+  public class FocusHandler implements FocusListener\n   {\n     /**\n      * Called when the JList acquires focus.\n@@ -112,7 +133,7 @@ void repaintCellFocus()\n    *\n    * @see javax.swing.JList#model\n    */\n-  class ListDataHandler implements ListDataListener\n+  public class ListDataHandler implements ListDataListener\n   {\n     /**\n      * Called when a general change has happened in the model which cannot\n@@ -150,7 +171,7 @@ public void intervalRemoved(ListDataEvent e)\n    * A helper class which listens for {@link ListSelectionEvent}s\n    * from the {@link JList}'s {@link ListSelectionModel}.\n    */\n-  class ListSelectionHandler implements ListSelectionListener\n+  public class ListSelectionHandler implements ListSelectionListener\n   {\n     /**\n      * Called when the list selection changes.  \n@@ -166,7 +187,7 @@ public void valueChanged(ListSelectionEvent e)\n    * A helper class which listens for {@link MouseEvent}s \n    * from the {@link JList}.\n    */\n-  class MouseInputHandler implements MouseInputListener\n+  public class MouseInputHandler implements MouseInputListener\n   {\n     /**\n      * Called when a mouse button press/release cycle completes\n@@ -186,11 +207,12 @@ public void mouseClicked(MouseEvent event)\n      */\n     public void mousePressed(MouseEvent event)\n     {\n-      int row = BasicListUI.this.convertYToRow(event.getY());\n-      if (row == -1)\n+      Point click = event.getPoint();\n+      int index = BasicListUI.this.locationToIndex(list, click);\n+      if (index == -1)\n         return;\n \n-      BasicListUI.this.list.setSelectedIndex(row);\n+      BasicListUI.this.list.setSelectedIndex(index);\n     }\n \n     /**\n@@ -248,7 +270,7 @@ public void mouseMoved(MouseEvent event)\n    * Helper class which listens to {@link PropertyChangeEvent}s\n    * from the {@link JList}.\n    */\n-  class PropertyChangeHandler implements PropertyChangeListener\n+  public class PropertyChangeHandler implements PropertyChangeListener\n   {\n     /**\n      * Called when the {@link JList} changes one of its bound properties.\n@@ -282,41 +304,50 @@ public static ComponentUI createUI(final JComponent c)\n   }\n \n   /** The current focus listener. */\n-  FocusHandler focusListener;\n+  protected FocusHandler focusListener;\n \n   /** The data listener listening to the model. */\n-  ListDataHandler listDataListener;\n+  protected ListDataHandler listDataListener;\n \n   /** The selection listener listening to the selection model. */\n-  ListSelectionHandler listSelectionListener;\n+  protected ListSelectionHandler listSelectionListener;\n \n   /** The mouse listener listening to the list. */\n-  MouseInputHandler mouseInputListener;\n+  protected MouseInputHandler mouseInputListener;\n \n   /** The property change listener listening to the list. */\n-  PropertyChangeHandler propertyChangeListener;\n+  protected PropertyChangeHandler propertyChangeListener;\n+\n+  /** The component listener that receives notification for resizing the\n+   * JList component.*/\n+  private ComponentListener componentListener;\n \n   /** Saved reference to the list this UI was created for. */\n-  JList list;\n+  protected JList list;\n \n   /** The height of a single cell in the list. */\n-  int cellHeight;\n+  protected int cellHeight;\n \n   /** The width of a single cell in the list. */\n-  int cellWidth;\n+  protected int cellWidth;\n \n   /** \n    * An array of varying heights of cells in the list, in cases where each\n    * cell might have a different height.\n    */\n-  int[] cellHeights;\n+  protected int[] cellHeights;\n \n   /**\n    * A simple counter. When nonzero, indicates that the UI class is out of\n    * date with respect to the underlying list, and must recalculate the\n    * list layout before painting or performing size calculations.\n    */\n-  int updateLayoutStateNeeded;\n+  protected int updateLayoutStateNeeded;\n+\n+  /**\n+   * The {@link CellRendererPane} that is used for painting.\n+   */\n+  protected CellRendererPane rendererPane;\n \n   /**\n    * Calculate the height of a particular row. If there is a fixed {@link\n@@ -328,7 +359,7 @@ public static ComponentUI createUI(final JComponent c)\n    *\n    * @return The height, in pixels, of the specified row\n    */\n-  int getRowHeight(int row)\n+  protected int getRowHeight(int row)\n   {\n     if (row < 0 || row >= cellHeights.length)\n       return -1;\n@@ -356,14 +387,21 @@ public Rectangle getCellBounds(JList l, int index1, int index2)\n     if (l != list || cellWidth == -1)\n       return null;\n \n-    int lo = Math.min(index1, index2);\n-    int hi = Math.max(index1, index2);\n-    Rectangle lobounds = new Rectangle(0, convertRowToY(lo), cellWidth,\n-                                       getRowHeight(lo));\n-    Rectangle hibounds = new Rectangle(0, convertRowToY(hi), cellWidth,\n-                                       getRowHeight(hi));\n+    int minIndex = Math.min(index1, index2);\n+    int maxIndex = Math.max(index1, index2);\n+    Point loc = indexToLocation(list, minIndex);\n+    Rectangle bounds = new Rectangle(loc.x, loc.y, cellWidth,\n+                                     getRowHeight(minIndex));\n \n-    return lobounds.union(hibounds);\n+    for (int i = minIndex + 1; i <= maxIndex; i++)\n+      {\n+        Point hiLoc = indexToLocation(list, i);\n+        Rectangle hibounds = new Rectangle(hiLoc.x, hiLoc.y, cellWidth,\n+                                       getRowHeight(i));\n+        bounds = bounds.union(hibounds);\n+      }\n+\n+    return bounds;\n   }\n \n   /**\n@@ -376,7 +414,7 @@ public Rectangle getCellBounds(JList l, int index1, int index2)\n    * @return The Y coordinate of the specified row, or <code>-1</code> if\n    * the specified row number is invalid\n    */\n-  int convertRowToY(int row)\n+  protected int convertRowToY(int row)\n   {\n     int y = 0;\n     for (int i = 0; i < row; ++i)\n@@ -399,7 +437,7 @@ int convertRowToY(int row)\n    * @return The row number containing the specified Y value, or <code>-1</code>\n    * if the specified Y coordinate is invalid\n    */\n-  int convertYToRow(int y0)\n+  protected int convertYToRow(int y0)\n   {\n     for (int row = 0; row < cellHeights.length; ++row)\n       {\n@@ -417,7 +455,7 @@ int convertYToRow(int y0)\n    * #cellWidth} properties by examining the variouis properties of the\n    * {@link JList}.\n    */\n-  void updateLayoutState()\n+  protected void updateLayoutState()\n   {\n     int nrows = list.getModel().getSize();\n     cellHeight = -1;\n@@ -436,7 +474,11 @@ void updateLayoutState()\n                                                                     false);\n             Dimension dim = flyweight.getPreferredSize();\n             cellHeights[i] = dim.height;\n+            // compute average cell height (little hack here)\n+            cellHeight = (cellHeight * i + cellHeights[i]) / (i + 1);\n             cellWidth = Math.max(cellWidth, dim.width);\n+            if (list.getLayoutOrientation() == JList.VERTICAL)\n+                cellWidth = Math.max(cellWidth, list.getSize().width);\n           }\n       }\n     else\n@@ -452,7 +494,7 @@ void updateLayoutState()\n    *\n    * @see #updateLayoutStateNeeded\n    */\n-  void damageLayout()\n+  private void damageLayout()\n   {\n     updateLayoutStateNeeded = 1;\n     list.revalidate();\n@@ -462,7 +504,7 @@ void damageLayout()\n    * Calls {@link #updateLayoutState} if {@link #updateLayoutStateNeeded}\n    * is nonzero, then resets {@link #updateLayoutStateNeeded} to zero.\n    */\n-  void maybeUpdateLayoutState()\n+  protected void maybeUpdateLayoutState()\n   {\n     if (updateLayoutStateNeeded != 0)\n       {\n@@ -481,7 +523,9 @@ public BasicListUI()\n     listSelectionListener = new ListSelectionHandler();\n     mouseInputListener = new MouseInputHandler();\n     propertyChangeListener = new PropertyChangeHandler();\n+    componentListener = new ComponentHandler();\n     updateLayoutStateNeeded = 1;\n+    rendererPane = new CellRendererPane();\n   }\n \n   /**\n@@ -490,7 +534,7 @@ public BasicListUI()\n    *\n    * @see #uninstallDefaults\n    */\n-  void installDefaults()\n+  protected void installDefaults()\n   {\n     UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n     list.setForeground(defaults.getColor(\"List.foreground\"));\n@@ -504,7 +548,7 @@ void installDefaults()\n    * Resets to <code>null</code> those defaults which were installed in \n    * {@link #installDefaults}\n    */\n-  void uninstallDefaults()\n+  protected void uninstallDefaults()\n   {\n     UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n     list.setForeground(null);\n@@ -519,20 +563,21 @@ void uninstallDefaults()\n    *\n    * @see #uninstallListeners\n    */\n-  void installListeners()\n+  protected void installListeners()\n   {\n     list.addFocusListener(focusListener);\n     list.getModel().addListDataListener(listDataListener);\n     list.addListSelectionListener(listSelectionListener);\n     list.addMouseListener(mouseInputListener);\n     list.addMouseMotionListener(mouseInputListener);\n     list.addPropertyChangeListener(propertyChangeListener);\n+    list.addComponentListener(componentListener);\n   }\n \n   /**\n    * Detaches all the listeners we attached in {@link #installListeners}.\n    */\n-  void uninstallListeners()\n+  protected void uninstallListeners()\n   {\n     list.removeFocusListener(focusListener);\n     list.getModel().removeListDataListener(listDataListener);\n@@ -545,14 +590,14 @@ void uninstallListeners()\n   /**\n    * Installs keyboard actions for this UI in the {@link JList}.\n    */\n-  void installKeyboardActions()\n+  protected void installKeyboardActions()\n   {\n   }\n \n   /**\n    * Uninstalls keyboard actions for this UI in the {@link JList}.\n    */\n-  void uninstallKeyboardActions()\n+  protected void uninstallKeyboardActions()\n   {\n   }\n \n@@ -590,18 +635,6 @@ public void uninstallUI(final JComponent c)\n     list = null;\n   }\n \n-  /**\n-   * Gets the maximum size this list can assume.\n-   *\n-   * @param c The component to measure the size of\n-   *\n-   * @return A new Dimension representing the component's maximum size\n-   */\n-  public Dimension getMaximumSize(JComponent c)\n-  {\n-    return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);\n-  }\n-\n   /**\n    * Gets the size this list would prefer to assume. This is calculated by\n    * calling {@link #getCellBounds} over the entire list.\n@@ -612,10 +645,34 @@ public Dimension getMaximumSize(JComponent c)\n    */\n   public Dimension getPreferredSize(JComponent c)\n   {\n-    if (list.getModel().getSize() == 0)\n+    int size = list.getModel().getSize();\n+    if (size == 0)\n       return new Dimension(0, 0);\n+    int visibleRows = list.getVisibleRowCount();\n+    int layoutOrientation = list.getLayoutOrientation();\n     Rectangle bounds = getCellBounds(list, 0, list.getModel().getSize() - 1);\n-    return bounds.getSize();\n+    Dimension retVal = bounds.getSize();\n+    Component parent = list.getParent();\n+    if ((visibleRows == -1) && (parent instanceof JViewport))\n+      {\n+        JViewport viewport = (JViewport) parent;\n+\n+        if (layoutOrientation == JList.HORIZONTAL_WRAP)\n+          {\n+            int h = viewport.getSize().height;\n+            int cellsPerCol = h / cellHeight;\n+            int w = size / cellsPerCol * cellWidth;\n+            retVal = new Dimension(w, h);\n+          }\n+        else if (layoutOrientation == JList.VERTICAL_WRAP)\n+          {\n+            int w = viewport.getSize().width;\n+            int cellsPerRow = Math.max(w / cellWidth, 1);\n+            int h = size / cellsPerRow * cellHeight;\n+            retVal = new Dimension(w, h);\n+          }\n+      }\n+    return retVal;\n   }\n \n   /**\n@@ -625,7 +682,7 @@ public Dimension getPreferredSize(JComponent c)\n    * @param g The graphics context to paint in\n    * @param c The component to paint the background of\n    */\n-  public void paintBackground(Graphics g, JComponent c)\n+  private void paintBackground(Graphics g, JComponent c)\n   {\n     Dimension size = getPreferredSize(c);\n     Color save = g.getColor();\n@@ -647,18 +704,18 @@ public void paintBackground(Graphics g, JComponent c)\n    * @param sel A selection model to provide to the cell renderer\n    * @param lead The lead selection index of the list\n    */\n-  void paintCell(Graphics g, int row, Rectangle bounds, ListCellRenderer rend,\n-                 ListModel data, ListSelectionModel sel, int lead)\n+  protected void paintCell(Graphics g, int row, Rectangle bounds,\n+                 ListCellRenderer rend, ListModel data,\n+                 ListSelectionModel sel, int lead)\n   {\n     boolean is_sel = list.isSelectedIndex(row);\n     boolean has_focus = false;\n     Component comp = rend.getListCellRendererComponent(list,\n                                                        data.getElementAt(row),\n                                                        0, is_sel, has_focus);\n-    g.translate(bounds.x, bounds.y);\n-    comp.setBounds(new Rectangle(0, 0, bounds.width, bounds.height));\n-    comp.paint(g);\n-    g.translate(-bounds.x, -bounds.y);\n+    //comp.setBounds(new Rectangle(0, 0, bounds.width, bounds.height));\n+    //comp.paint(g);\n+    rendererPane.paintComponent(g, comp, list, bounds);\n   }\n \n   /**\n@@ -690,13 +747,123 @@ public void paint(Graphics g, JComponent c)\n       }\n   }\n \n+  /**\n+   * Computes the index of a list cell given a point within the list.\n+   *\n+   * @param list the list which on which the computation is based on\n+   * @param location the coordinates\n+   *\n+   * @return the index of the list item that is located at the given\n+   *         coordinates or <code>null</code> if the location is invalid\n+   */\n   public int locationToIndex(JList list, Point location)\n   {\n-    return convertYToRow(location.y);\n+    int layoutOrientation = list.getLayoutOrientation();\n+    int index = -1;\n+    switch (layoutOrientation)\n+      {\n+      case JList.VERTICAL:\n+        index = convertYToRow(location.y);\n+        break;\n+      case JList.HORIZONTAL_WRAP:\n+        // determine visible rows and cells per row\n+        int visibleRows = list.getVisibleRowCount();\n+        int cellsPerRow = -1;\n+        int numberOfItems = list.getModel().getSize();\n+        Dimension listDim = list.getSize();\n+        if (visibleRows <= 0)\n+          {\n+            try\n+              {\n+                cellsPerRow = listDim.width / cellWidth;\n+              }\n+            catch (ArithmeticException ex)\n+              {\n+                cellsPerRow = 1;\n+              }\n+          }\n+        else\n+          {\n+            cellsPerRow = numberOfItems / visibleRows + 1;\n+          }\n+\n+        // determine index for the given location\n+        int cellsPerColumn = numberOfItems / cellsPerRow + 1;\n+        int gridX = Math.min(location.x / cellWidth, cellsPerRow - 1);\n+        int gridY = Math.min(location.y / cellHeight, cellsPerColumn);\n+        index = gridX + gridY * cellsPerRow;\n+        break;\n+      case JList.VERTICAL_WRAP:\n+        // determine visible rows and cells per column\n+        int visibleRows2 = list.getVisibleRowCount();\n+        if (visibleRows2 <= 0)\n+          {\n+            Dimension listDim2 = list.getSize();\n+            visibleRows2 = listDim2.height / cellHeight;\n+          }\n+        int numberOfItems2 = list.getModel().getSize();\n+        int cellsPerRow2 = numberOfItems2 / visibleRows2 + 1;\n+\n+        Dimension listDim2 = list.getSize();\n+        int gridX2 = Math.min(location.x / cellWidth, cellsPerRow2 - 1);\n+        int gridY2 = Math.min(location.y / cellHeight, visibleRows2);\n+        index = gridY2 + gridX2 * visibleRows2;\n+        break;\n+      }\n+    return index;\n   }\n \n   public Point indexToLocation(JList list, int index)\n   {\n-    return new Point(0, convertRowToY(index));\n+    int layoutOrientation = list.getLayoutOrientation();\n+    Point loc = null;\n+    switch (layoutOrientation)\n+      {\n+      case JList.VERTICAL:\n+        loc = new Point(0, convertRowToY(index));\n+        break;\n+      case JList.HORIZONTAL_WRAP:\n+        // determine visible rows and cells per row\n+        int visibleRows = list.getVisibleRowCount();\n+        int numberOfCellsPerRow = -1;\n+        if (visibleRows <= 0)\n+          {\n+            Dimension listDim = list.getSize();\n+            numberOfCellsPerRow = Math.max(listDim.width / cellWidth, 1);\n+          }\n+        else\n+          {\n+            int numberOfItems = list.getModel().getSize();\n+            numberOfCellsPerRow = numberOfItems / visibleRows + 1;\n+          }\n+        // compute coordinates inside the grid\n+        int gridX = index % numberOfCellsPerRow;\n+        int gridY = index / numberOfCellsPerRow;\n+        int locX = gridX * cellWidth;\n+        int locY = gridY * cellHeight;\n+        loc = new Point(locX, locY);\n+        break;\n+      case JList.VERTICAL_WRAP:\n+        // determine visible rows and cells per column\n+        int visibleRows2 = list.getVisibleRowCount();\n+        if (visibleRows2 <= 0)\n+          {\n+            Dimension listDim2 = list.getSize();\n+            visibleRows2 = listDim2.height / cellHeight;\n+          }\n+        // compute coordinates inside the grid\n+        if (visibleRows2 > 0)\n+          {\n+            int gridY2 = index % visibleRows2;\n+            int gridX2 = index / visibleRows2;\n+            int locX2 = gridX2 * cellWidth;\n+            int locY2 = gridY2 * cellHeight;\n+            loc = new Point(locX2, locY2);\n+          }\n+        else\n+          loc = new Point(0, convertRowToY(index));\n+        break;\n+      }\n+    return loc;\n   }\n }"}]}