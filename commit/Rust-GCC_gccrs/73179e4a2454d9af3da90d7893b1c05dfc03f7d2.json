{"sha": "73179e4a2454d9af3da90d7893b1c05dfc03f7d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMxNzllNGEyNDU0ZDlhZjNkYTkwZDc4OTNiMWMwNWRmYzAzZjdkMg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2014-09-04T16:37:36Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2014-09-04T16:37:36Z"}, "message": "dearly: Emit DIEs for decls early in the compilation process.\n\nThis is the original patch from Michael Matz, ported to a more recent\nmainline.\n\nFrom-SVN: r214906", "tree": {"sha": "64d516c6714ccf738bf4c8580b17ca9b6cfea129", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64d516c6714ccf738bf4c8580b17ca9b6cfea129"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73179e4a2454d9af3da90d7893b1c05dfc03f7d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73179e4a2454d9af3da90d7893b1c05dfc03f7d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73179e4a2454d9af3da90d7893b1c05dfc03f7d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73179e4a2454d9af3da90d7893b1c05dfc03f7d2/comments", "author": null, "committer": null, "parents": [{"sha": "514372694337432c7b8a2e989384d9bcb64c79ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514372694337432c7b8a2e989384d9bcb64c79ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/514372694337432c7b8a2e989384d9bcb64c79ac"}], "stats": {"total": 129, "additions": 118, "deletions": 11}, "files": [{"sha": "28bc2104b1b911b49514f581fb12368789cebba8", "filename": "gcc/debug.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73179e4a2454d9af3da90d7893b1c05dfc03f7d2/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73179e4a2454d9af3da90d7893b1c05dfc03f7d2/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=73179e4a2454d9af3da90d7893b1c05dfc03f7d2", "patch": "@@ -187,6 +187,8 @@ extern void dwarf2out_switch_text_section (void);\n const char *remap_debug_filename (const char *);\n void add_debug_prefix_map (const char *);\n \n+extern void dwarf2out_early_decl (tree);\n+\n /* For -fdump-go-spec.  */\n \n extern const struct gcc_debug_hooks *"}, {"sha": "e624e38ca7e8e1d4fe1f2ea058ef8024bfbe59eb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 111, "deletions": 9, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73179e4a2454d9af3da90d7893b1c05dfc03f7d2/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73179e4a2454d9af3da90d7893b1c05dfc03f7d2/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=73179e4a2454d9af3da90d7893b1c05dfc03f7d2", "patch": "@@ -3679,7 +3679,7 @@ decl_ultimate_origin (const_tree decl)\n   /* output_inline_function sets DECL_ABSTRACT_ORIGIN for all the\n      nodes in the function to point to themselves; ignore that if\n      we're trying to output the abstract instance of this function.  */\n-  if (DECL_ABSTRACT (decl) && DECL_ABSTRACT_ORIGIN (decl) == decl)\n+  if (/*DECL_ABSTRACT (decl) &&*/ DECL_ABSTRACT_ORIGIN (decl) == decl)\n     return NULL_TREE;\n \n   /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n@@ -4779,6 +4779,7 @@ remove_child_TAG (dw_die_ref die, enum dwarf_tag tag)\n     while (c->die_tag == tag)\n       {\n \tremove_child_with_prev (c, prev);\n+\tc->die_parent = NULL;\n \t/* Might have removed every child.  */\n \tif (c == c->die_sib)\n \t  return;\n@@ -5517,6 +5518,49 @@ debug_dwarf (void)\n   print_indent = 0;\n   print_die (comp_unit_die (), stderr);\n }\n+\n+/* Perform some sanity checks on DIEs after they have been generated\n+   earlier in the compilation process.  */\n+\n+static void\n+check_die (dw_die_ref die, unsigned level)\n+{\n+  static unsigned long mark = 1;\n+  dw_die_ref c, p;\n+  /* Check that all our childs have their parent set to us.  */\n+  c = die->die_child;\n+  if (c) do {\n+      c = c->die_sib;\n+      gcc_assert (c->die_parent == die);\n+    } while (c != die->die_child);\n+\n+  /* Check the we are part of our parent's child list.  */\n+  mark++;\n+  p = die->die_parent;\n+  if (p)\n+    {\n+      c = p->die_child;\n+      gcc_assert (c);\n+      do {\n+\tc = c->die_sib;\n+\t/* Found it.  */\n+\tif (c == die)\n+\t  break;\n+\t/* If we're at start --> not found.  */\n+\tgcc_assert (c != p->die_child);\n+\t/* If we've seen this node already the circular list doesn't\n+\t   even go back to start.  */\n+\tgcc_assert (c->die_abbrev != mark);\n+\tc->die_abbrev = mark;\n+      } while (1);\n+    }\n+\n+  if (!level)\n+    return;\n+\n+  FOR_EACH_CHILD (die, c, check_die (c, level - 1));\n+}\n+\n \f\n /* Start a new compilation unit DIE for an include file.  OLD_UNIT is the CU\n    for the enclosing include file, if any.  BINCL_DIE is the DW_TAG_GNU_BINCL\n@@ -17603,16 +17647,30 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n {\n   tree node_or_origin = node ? node : origin;\n   tree ultimate_origin;\n-  dw_die_ref parm_die\n-    = new_die (DW_TAG_formal_parameter, context_die, node);\n+  dw_die_ref parm_die;\n+  \n+  if (TREE_CODE_CLASS (TREE_CODE (node_or_origin)) == tcc_declaration)\n+    {\n+      parm_die = lookup_decl_die (node);\n+\n+      if (parm_die && parm_die->die_parent == NULL)\n+\t{\n+\t  add_child_die (context_die, parm_die);\n+\t  /* XXX check that parm_die already has all the right attributes\n+\t     that we would add below?  */\n+\t  return parm_die;\n+\t}\n+    }\n+\n+  parm_die = new_die (DW_TAG_formal_parameter, context_die, node);\n \n   switch (TREE_CODE_CLASS (TREE_CODE (node_or_origin)))\n     {\n     case tcc_declaration:\n       ultimate_origin = decl_ultimate_origin (node_or_origin);\n       if (node || ultimate_origin)\n \torigin = ultimate_origin;\n-      if (origin != NULL)\n+      if (origin != NULL && node != origin)\n \tadd_abstract_origin_attribute (parm_die, origin);\n       else if (emit_name_p)\n \tadd_name_and_src_coords_attributes (parm_die, node);\n@@ -18150,7 +18208,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       && debug_info_level > DINFO_LEVEL_TERSE)\n     old_die = force_decl_die (decl);\n \n-  if (origin != NULL)\n+  if (origin != NULL && origin != decl)\n     {\n       gcc_assert (!declaration || local_scope_p (context_die));\n \n@@ -18297,9 +18355,12 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n       equate_decl_number_to_die (decl, subr_die);\n     }\n-  else if (!DECL_EXTERNAL (decl))\n+  else if (!DECL_EXTERNAL (decl)\n+\t   && (!DECL_STRUCT_FUNCTION (decl)\n+\t       || DECL_STRUCT_FUNCTION (decl)->gimple_df))\n     {\n       HOST_WIDE_INT cfa_fb_offset;\n+\n       struct function *fun = DECL_STRUCT_FUNCTION (decl);\n \n       if (!old_die || !get_AT (old_die, DW_AT_inline))\n@@ -18462,10 +18523,20 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \tadd_AT_location_description (subr_die, DW_AT_static_link,\n \t\t loc_list_from_tree (fun->static_chain_decl, 2));\n     }\n+  else if (!DECL_EXTERNAL (decl))\n+    {\n+      if (!old_die || !get_AT (old_die, DW_AT_inline))\n+\tequate_decl_number_to_die (decl, subr_die);\n+    }\n \n   /* Generate child dies for template paramaters.  */\n   if (debug_info_level > DINFO_LEVEL_TERSE)\n-    gen_generic_params_dies (decl);\n+    {\n+      /* XXX */\n+      if (!lookup_decl_die (decl))\n+\tequate_decl_number_to_die (decl, subr_die);\n+      gen_generic_params_dies (decl);\n+    }\n \n   /* Now output descriptions of the arguments for this function. This gets\n      (unnecessarily?) complex because of the fact that the DECL_ARGUMENT list\n@@ -18569,7 +18640,9 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n      a BLOCK node representing the function's outermost pair of curly braces,\n      and any blocks used for the base and member initializers of a C++\n      constructor function.  */\n-  if (! declaration && outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n+  if (! declaration && outer_scope && TREE_CODE (outer_scope) != ERROR_MARK\n+      && (!DECL_STRUCT_FUNCTION (decl)\n+\t  || DECL_STRUCT_FUNCTION (decl)->gimple_df))\n     {\n       int call_site_note_count = 0;\n       int tail_call_site_note_count = 0;\n@@ -18889,7 +18962,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n      and if we already emitted a DIE for it, don't emit a second\n      DIE for it again. Allow re-declarations of DECLs that are\n      inside functions, though.  */\n-  if (old_die && declaration && !local_scope_p (context_die))\n+  if (old_die && !declaration && !local_scope_p (context_die))\n     return;\n \n   /* For static data members, the declaration in the class is supposed\n@@ -21010,6 +21083,35 @@ dwarf2out_decl (tree decl)\n     }\n \n   gen_decl_die (decl, NULL, context_die);\n+\n+  dw_die_ref die = lookup_decl_die (decl);\n+  if (die)\n+    check_die (die, 0);\n+}\n+\n+/* Early dumping of DECLs before we lose language data.  */\n+\n+void\n+dwarf2out_early_decl (tree decl)\n+{\n+  /* We don't handle TYPE_DECLs.  If required, they'll be reached via\n+     other DECLs and they can point to template types or other things\n+     that dwarf2out can't handle when done via dwarf2out_decl.  */\n+  if (TREE_CODE (decl) != TYPE_DECL\n+      && TREE_CODE (decl) != PARM_DECL)\n+    {\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  push_cfun (DECL_STRUCT_FUNCTION (decl));\n+\t  current_function_decl = decl;\n+\t}\n+      dwarf2out_decl (decl);\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  pop_cfun ();\n+\t  current_function_decl = NULL;\n+\t}\n+    }\n }\n \n /* Write the debugging output for DECL.  */"}, {"sha": "afc8e3d9559dd328b414d851fe3defcca7fd1703", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73179e4a2454d9af3da90d7893b1c05dfc03f7d2/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73179e4a2454d9af3da90d7893b1c05dfc03f7d2/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=73179e4a2454d9af3da90d7893b1c05dfc03f7d2", "patch": "@@ -5032,6 +5032,10 @@ free_lang_data_in_decl (tree decl)\n {\n   gcc_assert (DECL_P (decl));\n \n+  /* Early dumping of DECLs before we lose language data.  */\n+  if (debug_info_level > DINFO_LEVEL_NONE)\n+    dwarf2out_early_decl (decl);\n+\n   /* Give the FE a chance to remove its own data first.  */\n   lang_hooks.free_lang_data (decl);\n \n@@ -5630,8 +5634,7 @@ free_lang_data (void)\n   unsigned i;\n \n   /* If we are the LTO frontend we have freed lang-specific data already.  */\n-  if (in_lto_p\n-      || !flag_generate_lto)\n+  if (in_lto_p)\n     return 0;\n \n   /* Allocate and assign alias sets to the standard integer types"}]}