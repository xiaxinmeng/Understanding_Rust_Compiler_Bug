{"sha": "cc1328655c2b1f59816c92cd2b856daf10f9e28c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MxMzI4NjU1YzJiMWY1OTgxNmM5MmNkMmI4NTZkYWYxMGY5ZTI4Yw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-05-06T16:32:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-06T16:32:40Z"}, "message": "toplev.c (-fsched-max): Delete flag.\n\n        * toplev.c (-fsched-max): Delete flag.\n        (-fsched-interblock-max-blocks,-fsched-interblock-max-insns): Likewise.\n        * haifa-sched.c: Remove -fsched-max-N, -fsched-interblock-max-blocks-N\n        and -fsched-interblock-max-insns-N support.  Remove INTERBLOCK_DEBUG\n        conditionals.\n        * haifa-sched.c (find_rgns): Correctly handle reducible loops with\n        inner loops which are not reducible.\n\nFrom-SVN: r19586", "tree": {"sha": "df32e4e8f34d54d132db2a9ac05d98a4eb7098c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df32e4e8f34d54d132db2a9ac05d98a4eb7098c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc1328655c2b1f59816c92cd2b856daf10f9e28c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1328655c2b1f59816c92cd2b856daf10f9e28c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc1328655c2b1f59816c92cd2b856daf10f9e28c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1328655c2b1f59816c92cd2b856daf10f9e28c/comments", "author": null, "committer": null, "parents": [{"sha": "1b15c5def4e06df8f95d0d7253c7e7ee6c483b60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b15c5def4e06df8f95d0d7253c7e7ee6c483b60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b15c5def4e06df8f95d0d7253c7e7ee6c483b60"}], "stats": {"total": 155, "additions": 71, "deletions": 84}, "files": [{"sha": "2b6ca9f763ba1273227a27a9afe990a6bfc99221", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1328655c2b1f59816c92cd2b856daf10f9e28c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1328655c2b1f59816c92cd2b856daf10f9e28c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc1328655c2b1f59816c92cd2b856daf10f9e28c", "patch": "@@ -7,6 +7,15 @@ Wed May  6 15:51:39 1998  Jim Wilson  <wilson@cygnus.com>\n \n Wed May  6 16:46:01 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* toplev.c (-fsched-max): Delete flag.\n+\t(-fsched-interblock-max-blocks,-fsched-interblock-max-insns): Likewise.\n+\t* haifa-sched.c: Remove -fsched-max-N, -fsched-interblock-max-blocks-N\n+\tand -fsched-interblock-max-insns-N support.  Remove INTERBLOCK_DEBUG\n+\tconditionals.\n+\n+\t* haifa-sched.c (find_rgns): Correctly handle reducible loops with\n+\tinner loops which are not reducible.\n+\n \t* loop.c (regs_match_p): Fix typo in prototype.\n \n \t* regmove.c (try_auto_increment): Wrap declaration inside an"}, {"sha": "8bbe6ec19cc4c5c02530f2d8ff5767b6cc808ca3", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 62, "deletions": 78, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1328655c2b1f59816c92cd2b856daf10f9e28c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1328655c2b1f59816c92cd2b856daf10f9e28c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=cc1328655c2b1f59816c92cd2b856daf10f9e28c", "patch": "@@ -170,11 +170,6 @@ extern rtx *reg_known_value;\n \n #ifdef INSN_SCHEDULING\n \n-/* enable interblock scheduling code */\n-\n-/* define INTERBLOCK_DEBUG for using the -fsched-max debugging facility */\n-/* #define INTERBLOCK_DEBUG */\n-\n /* target_units bitmask has 1 for each unit in the cpu.  It should be\n    possible to compute this variable from the machine description.\n    But currently it is computed by examinning the insn list.  Since\n@@ -194,31 +189,20 @@ static int issue_rate;\n #define ISSUE_RATE 1\n #endif\n \n-/* sched_debug_count is used for debugging the scheduler by limiting\n-   the number of scheduled insns.  It is controlled by the option\n-   -fsched-max-N (N is a number).\n-\n-   sched-verbose controls the amount of debugging output the\n+/* sched-verbose controls the amount of debugging output the\n    scheduler prints.  It is controlled by -fsched-verbose-N:\n    N>0 and no -DSR : the output is directed to stderr.\n    N>=10 will direct the printouts to stderr (regardless of -dSR).\n    N=1: same as -dSR.\n    N=2: bb's probabilities, detailed ready list info, unit/insn info.\n    N=3: rtl at abort point, control-flow, regions info.\n-   N=5: dependences info.\n-\n-   max_rgn_blocks and max_region_insns limit region size for\n-   interblock scheduling.  They are controlled by\n-   -fsched-interblock-max-blocks-N, -fsched-interblock-max-insns-N */\n+   N=5: dependences info.  */\n \n #define MAX_RGN_BLOCKS 10\n #define MAX_RGN_INSNS 100\n \n-static int sched_debug_count = -1;\n static int sched_verbose_param = 0;\n static int sched_verbose = 0;\n-static int max_rgn_blocks = MAX_RGN_BLOCKS;\n-static int max_rgn_insns = MAX_RGN_INSNS;\n \n /* nr_inter/spec counts interblock/speculative motion for the function */\n static int nr_inter, nr_spec;\n@@ -235,15 +219,8 @@ void\n fix_sched_param (param, val)\n      char *param, *val;\n {\n-  if (!strcmp (param, \"max\"))\n-    sched_debug_count = ((sched_debug_count == -1) ?\n-\t\t\t atoi (val) : sched_debug_count);\n-  else if (!strcmp (param, \"verbose\"))\n+  if (!strcmp (param, \"verbose\"))\n     sched_verbose_param = atoi (val);\n-  else if (!strcmp (param, \"interblock-max-blocks\"))\n-    max_rgn_blocks = atoi (val);\n-  else if (!strcmp (param, \"interblock-max-insns\"))\n-    max_rgn_insns = atoi (val);\n   else\n     warning (\"fix_sched_param: unknown param: %s\", param);\n }\n@@ -1424,7 +1401,7 @@ too_large (block, num_bbs, num_insns)\n   (*num_bbs)++;\n   (*num_insns) += (INSN_LUID (basic_block_end[block]) -\n \t\t   INSN_LUID (basic_block_head[block]));\n-  if ((*num_bbs > max_rgn_blocks) || (*num_insns > max_rgn_insns))\n+  if ((*num_bbs > MAX_RGN_BLOCKS) || (*num_insns > MAX_RGN_INSNS))\n     return 1;\n   else\n     return 0;\n@@ -1507,6 +1484,9 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n   /* Note if a block is in the block queue. */\n   sbitmap in_queue;\n \n+  /* Note if a block is in the block queue. */\n+  sbitmap in_stack;\n+\n   /* Perform a DFS traversal of the cfg.  Identify loop headers, inner loops\n      and a mapping from block to its loop header (if the block is contained\n      in a loop, else -1).\n@@ -1534,6 +1514,9 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n   in_queue = sbitmap_alloc (n_basic_blocks);\n   sbitmap_zero (in_queue);\n \n+  in_stack = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (in_stack);\n+\n   for (i = 0; i < n_basic_blocks; i++)\n     max_hdr[i] = -1;\n \n@@ -1545,7 +1528,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n       if (current_edge == 0 || TEST_BIT (passed, current_edge))\n \t{\n \t  /* We have reached a leaf node or a node that was already\n-\t     proc4essed.  Pop edges off the stack until we find\n+\t     processed.  Pop edges off the stack until we find\n \t     an edge that has not yet been processed.  */\n \t  while (sp >= 0\n \t\t && (current_edge == 0 || TEST_BIT (passed, current_edge)))\n@@ -1554,7 +1537,8 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t      current_edge = stack[sp--];\n \t      node = FROM_BLOCK (current_edge);\n \t      child = TO_BLOCK (current_edge);\n-\t      if (max_hdr[child] >= 0 && TEST_BIT (dom[node], max_hdr[child]))\n+\t      RESET_BIT (in_stack, child);\n+\t      if (max_hdr[child] >= 0 && TEST_BIT (in_stack, max_hdr[child]))\n \t\tUPDATE_LOOP_RELATIONS (node, max_hdr[child]);\n \t      current_edge = NEXT_OUT (current_edge);\n \t    }\n@@ -1570,12 +1554,13 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n       /* Process a node.  */\n       node = FROM_BLOCK (current_edge);\n       child = TO_BLOCK (current_edge);\n+      SET_BIT (in_stack, node);\n       dfs_nr[node] = ++count;\n \n-      /* If the successor block dominates the current block, then\n-\t we've found a natural loop, record the header block for\n-\t future reference.  */\n-      if (TEST_BIT (dom[node], child))\n+      /* If the successor is in the stack, then we've found a loop.\n+\t Mark the loop, if it is not a natural loop, then it will\n+\t be rejected during the second traversal.  */\n+      if (TEST_BIT (in_stack, child))\n \t{\n \t  no_loops = 0;\n \t  SET_BIT (header, child);\n@@ -1590,7 +1575,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t with a new edge.  */\n       if (dfs_nr[child])\n \t{\n-\t  if (max_hdr[child] >= 0 && TEST_BIT (dom[node], max_hdr[child]))\n+\t  if (max_hdr[child] >= 0 && TEST_BIT (in_stack, max_hdr[child]))\n \t    UPDATE_LOOP_RELATIONS (node, max_hdr[child]);\n \t  SET_BIT (passed, current_edge);\n \t  current_edge = NEXT_OUT (current_edge);\n@@ -1638,25 +1623,56 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \n       queue = (int *) alloca (n_basic_blocks * sizeof (int));\n \n-      /* Find blocks which are inner loop headers.  */\n+      /* Find blocks which are inner loop headers.  We still have non-reducible\n+\t loops to consider at this point.  */\n       for (i = 0; i < n_basic_blocks; i++)\n \t{\n \t  if (TEST_BIT (header, i) && TEST_BIT (inner, i))\n \t    {\n \t      int_list_ptr ps;\n+\t      int j;\n+\n+\t      /* Now check that the loop is reducible.  We do this separate\n+\t\t from finding inner loops so that we do not find a reducible\n+\t\t loop which contains an inner  non-reducible loop.\n+\n+\t\t A simple way to find reducible/natrual loops is to verify\n+\t\t that each block in the loop is dominated by the loop\n+\t\t header.\n+\n+\t\t If there exists a block that is not dominated by the loop\n+\t\t header, then the block is reachable from outside the loop\n+\t\t and thus the loop is not a natural loop.  */\n+\t      for (j = 0; j < n_basic_blocks; j++)\t\n+\t\t{\n+\t\t  /* First identify blocks in the loop, except for the loop\n+\t\t     entry block.  */\n+\t\t  if (i == max_hdr[j] && i != j)\n+\t\t    {\n+\t\t      /* Now verify that the block is dominated by the loop\n+\t\t\t header.  */\n+\t\t      if (!TEST_BIT (dom[j], i))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\n+\t      /* If we exited the loop early, then I is the header of a non\n+\t\t reducible loop and we should quit processing it now.  */\n+\t      if (j != n_basic_blocks)\n+\t\tcontinue;\n \n-\t      /* I is a header of a reducible inner loop, or block 0 in a\n-\t\t subroutine with no loops at all.  */\n+\t      /* I is a header of an inner loop, or block 0 in a subroutine\n+\t\t with no loops at all.  */\n \t      head = tail = -1;\n \t      too_large_failure = 0;\n \t      loop_head = max_hdr[i];\n \n \t      /* Decrease degree of all I's successors for topological\n-\t\t ordering.  */\n+\t\t ordering.\n \t      for (ps = s_succs[i]; ps; ps = ps->next)\n \t\tif (INT_LIST_VAL (ps) != EXIT_BLOCK\n \t\t    && INT_LIST_VAL (ps) != ENTRY_BLOCK)\n-\t\t  --degree[INT_LIST_VAL (ps)];\n+\t\t  --degree[INT_LIST_VAL(ps)];\n \n \t      /* Estimate # insns, and count # blocks in the region.  */\n \t      num_bbs = 1;\n@@ -1833,6 +1849,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n   free (header);\n   free (inner);\n   free (in_queue);\n+  free (in_stack);\n }\n \n \n@@ -6566,8 +6583,6 @@ schedule_block (bb, rgn_n_insns)\n \t       INSN_UID (basic_block_end[b]),\n \t       (reload_completed ? \"after\" : \"before\"));\n       fprintf (dump, \";;   ======================================================\\n\");\n-      if (sched_debug_count >= 0)\n-\tfprintf (dump, \";;\\t -- sched_debug_count=%d\\n\", sched_debug_count);\n       fprintf (dump, \"\\n\");\n \n       visual_tbl = (char *) alloca (get_visual_tbl_length ());\n@@ -6704,10 +6719,6 @@ schedule_block (bb, rgn_n_insns)\n     {\n       int b1;\n \n-#ifdef INTERBLOCK_DEBUG\n-      if (sched_debug_count == 0)\n-\tbreak;\n-#endif\n       clock_var++;\n \n       /* Add to the ready list all pending insns that can be issued now.\n@@ -6750,11 +6761,6 @@ schedule_block (bb, rgn_n_insns)\n \t    }\n \t  else if (cost == 0)\n \t    {\n-#ifdef INTERBLOCK_DEBUG\n-\t      if (sched_debug_count == 0)\n-\t\tbreak;\n-#endif\n-\n \t      /* an interblock motion? */\n \t      if (INSN_BB (insn) != target_bb)\n \t\t{\n@@ -6823,11 +6829,6 @@ schedule_block (bb, rgn_n_insns)\n \n \t      can_issue_more--;\n \n-#ifdef INTERBLOCK_DEBUG\n-\t      if (sched_debug_count > 0)\n-\t\tsched_debug_count--;\n-#endif\n-\n \t      n_ready = schedule_insn (insn, ready, n_ready, clock_var);\n \n \t      /* remove insn from ready list */\n@@ -6843,10 +6844,6 @@ schedule_block (bb, rgn_n_insns)\n       if (sched_verbose)\n \t{\n \t  visualize_scheduled_insns (b, clock_var);\n-#ifdef INTERBLOCK_DEBUG\n-\t  if (sched_debug_count == 0)\n-\t    fprintf (dump, \"........   sched_debug_count == 0  .................\\n\");\n-#endif\n \t}\n     }\n \n@@ -6859,25 +6856,15 @@ schedule_block (bb, rgn_n_insns)\n     }\n \n   /* Sanity check -- queue must be empty now.  Meaningless if region has\n-     multiple bbs, or if scheduling stopped by sched_debug_count.  */\n+     multiple bbs.  */\n   if (current_nr_blocks > 1)\n-#ifdef INTERBLOCK_DEBUG\n-    if (sched_debug_count != 0)\n-#endif\n-      if (!flag_schedule_interblock && q_size != 0)\n-\tabort ();\n+    if (!flag_schedule_interblock && q_size != 0)\n+      abort ();\n \n   /* update head/tail boundaries.  */\n   head = NEXT_INSN (prev_head);\n   tail = last;\n \n-#ifdef INTERBLOCK_DEBUG\n-  if (sched_debug_count == 0)\n-    /* compensate for stopping scheduling prematurely */\n-    for (i = sched_target_n_insns; i < target_n_insns; i++)\n-      tail = move_insn (group_leader (NEXT_INSN (tail)), tail);\n-#endif\n-\n   /* Restore-other-notes: NOTE_LIST is the end of a chain of notes\n      previously found among the insns.  Insert them at the beginning\n      of the insns.  */\n@@ -7562,12 +7549,9 @@ schedule_region (rgn)\n #endif\n     }\n \n-#ifdef INTERBLOCK_DEBUG\n-  if (sched_debug_count != 0)\n-#endif\n-    /* sanity check: verify that all region insns were scheduled */\n-    if (sched_rgn_n_insns != rgn_n_insns)\n-      abort ();\n+  /* sanity check: verify that all region insns were scheduled */\n+  if (sched_rgn_n_insns != rgn_n_insns)\n+    abort ();\n \n   /* update register life and usage information */\n   if (reload_completed == 0)"}, {"sha": "e5bab05d43453c55d6378ef22c9584c200ff196b", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1328655c2b1f59816c92cd2b856daf10f9e28c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1328655c2b1f59816c92cd2b856daf10f9e28c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=cc1328655c2b1f59816c92cd2b856daf10f9e28c", "patch": "@@ -3994,12 +3994,6 @@ main (argc, argv, envp)\n #ifdef INSN_SCHEDULING\n \t      else if (!strncmp (p, \"sched-verbose-\",14))\n \t\tfix_sched_param(\"verbose\",&p[14]);\n-\t      else if (!strncmp (p, \"sched-max-\",10))\n-\t\tfix_sched_param(\"max\",&p[10]);\n-\t      else if (!strncmp (p, \"sched-inter-max-b-\",18))\n-\t\tfix_sched_param(\"interblock-max-blocks\",&p[18]);\n-\t      else if (!strncmp (p, \"sched-inter-max-i-\",18))\n-\t\tfix_sched_param(\"interblock-max-insns\",&p[18]);\n #endif\n #endif  /* HAIFA */\n \t      else if (!strncmp (p, \"fixed-\", 6))"}]}