{"sha": "a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVkZDZiNjlmY2JlNzRjMDJkNDgyMWFjMmRhZjJiOGM5ZjgxOWY2ZQ==", "commit": {"author": {"name": "Marius Hillenbrand", "email": "mhillen@linux.ibm.com", "date": "2020-12-01T10:02:27Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2020-12-01T10:29:09Z"}, "message": "IBM Z: Configure excess precision for float at compile-time\n\nHistorically, float_t has been defined as double on s390 and gcc would\nemit double precision insns for evaluating float expressions when in\nstandard-compliant mode. Configure that behavior at compile-time as prep\nfor changes in glibc: When glibc ties float_t to double, keep the old\nbehavior; when glibc derives float_t from FLT_EVAL_METHOD (as on most\nother archs), revert to the default behavior (i.e.,\nFLT_EVAL_METHOD_PROMOTE_TO_FLOAT). Provide a configure option\n--enable-s390-excess-float-precision to override the check.\n\ngcc/ChangeLog:\n\n2020-12-01  Marius Hillenbrand  <mhillen@linux.ibm.com>\n\n\t* configure.ac: Add configure option\n\t--enable-s390-excess-float-precision and check to derive default\n\tfrom glibc.\n\t* config/s390/s390.c: Guard s390_excess_precision with an ifdef\n\tfor ENABLE_S390_EXCESS_FLOAT_PRECISION.\n\t* doc/install.texi: Document --enable-s390-excess-float-precision.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.", "tree": {"sha": "78b146b12ca2fe39d2170da0e04c2eb9d1f9da52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78b146b12ca2fe39d2170da0e04c2eb9d1f9da52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/comments", "author": {"login": "mhillenbrand", "id": 1150167, "node_id": "MDQ6VXNlcjExNTAxNjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1150167?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mhillenbrand", "html_url": "https://github.com/mhillenbrand", "followers_url": "https://api.github.com/users/mhillenbrand/followers", "following_url": "https://api.github.com/users/mhillenbrand/following{/other_user}", "gists_url": "https://api.github.com/users/mhillenbrand/gists{/gist_id}", "starred_url": "https://api.github.com/users/mhillenbrand/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mhillenbrand/subscriptions", "organizations_url": "https://api.github.com/users/mhillenbrand/orgs", "repos_url": "https://api.github.com/users/mhillenbrand/repos", "events_url": "https://api.github.com/users/mhillenbrand/events{/privacy}", "received_events_url": "https://api.github.com/users/mhillenbrand/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cffd725c0eb44daa0234f3af39cd94ad97f2833d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffd725c0eb44daa0234f3af39cd94ad97f2833d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cffd725c0eb44daa0234f3af39cd94ad97f2833d"}], "stats": {"total": 163, "additions": 154, "deletions": 9}, "files": [{"sha": "cc6276d0df08297f875f9fedf079a1f67f1bf32e", "filename": "gcc/config.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "patch": "@@ -236,6 +236,10 @@\n /* Define if you want runtime assertions enabled. This is a cheap check. */\n #undef ENABLE_RUNTIME_CHECKING\n \n+/* Define to enable evaluating float expressions with double precision in\n+   standards-compatible mode on s390 targets. */\n+#undef ENABLE_S390_EXCESS_FLOAT_PRECISION\n+\n /* Define if you want all operations on trees (the basic data structure of the\n    front ends) to be checked for dynamic type safety at runtime. This is\n    moderately expensive. */"}, {"sha": "02f18366aa13bdc6686a8f8c583ac37b25836800", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "patch": "@@ -16376,20 +16376,28 @@ s390_invalid_binary_op (int op ATTRIBUTE_UNUSED, const_tree type1, const_tree ty\n   return NULL;\n }\n \n-/* Implement TARGET_C_EXCESS_PRECISION.\n+#if ENABLE_S390_EXCESS_FLOAT_PRECISION == 1\n+/* Implement TARGET_C_EXCESS_PRECISION to maintain historic behavior with older\n+   glibc versions\n \n-   FIXME: For historical reasons, float_t and double_t are typedef'ed to\n+   For historical reasons, float_t and double_t had been typedef'ed to\n    double on s390, causing operations on float_t to operate in a higher\n    precision than is necessary.  However, it is not the case that SFmode\n    operations have implicit excess precision, and we generate more optimal\n    code if we let the compiler know no implicit extra precision is added.\n \n-   That means when we are compiling with -fexcess-precision=fast, the value\n-   we set for FLT_EVAL_METHOD will be out of line with the actual precision of\n-   float_t (though they would be correct for -fexcess-precision=standard).\n+   With a glibc with that \"historic\" definition, configure will enable this hook\n+   to set FLT_EVAL_METHOD to 1 for -fexcess-precision=standard (e.g., as implied\n+   by -std=cXY).  That means when we are compiling with -fexcess-precision=fast,\n+   the value we set for FLT_EVAL_METHOD will be out of line with the actual\n+   precision of float_t.\n \n-   A complete fix would modify glibc to remove the unnecessary typedef\n-   of float_t to double.  */\n+   Newer versions of glibc will be modified to derive the definition of float_t\n+   from FLT_EVAL_METHOD on s390x, as on many other architectures.  There,\n+   configure will disable this hook by default, so that we defer to the default\n+   of FLT_EVAL_METHOD_PROMOTE_TO_FLOAT and a resulting typedef of float_t to\n+   float.  Note that in that scenario, float_t and FLT_EVAL_METHOD will be in\n+   line independent of -fexcess-precision. */\n \n static enum flt_eval_method\n s390_excess_precision (enum excess_precision_type type)\n@@ -16412,6 +16420,7 @@ s390_excess_precision (enum excess_precision_type type)\n     }\n   return FLT_EVAL_METHOD_UNPREDICTABLE;\n }\n+#endif\n \n /* Implement the TARGET_ASAN_SHADOW_OFFSET hook.  */\n \n@@ -16708,8 +16717,12 @@ s390_shift_truncation_mask (machine_mode mode)\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true\n \n+#if ENABLE_S390_EXCESS_FLOAT_PRECISION == 1\n+/* This hook is only needed to maintain the historic behavior with glibc\n+   versions that typedef float_t to double. */\n #undef TARGET_C_EXCESS_PRECISION\n #define TARGET_C_EXCESS_PRECISION s390_excess_precision\n+#endif\n \n #undef  TARGET_SCHED_ADJUST_PRIORITY\n #define TARGET_SCHED_ADJUST_PRIORITY s390_adjust_priority"}, {"sha": "de5fb5081826f05b512efc02992f48e8a7529f65", "filename": "gcc/configure", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "patch": "@@ -1024,6 +1024,7 @@ with_diagnostics_color\n with_diagnostics_urls\n enable_default_pie\n enable_cet\n+enable_s390_excess_float_precision\n '\n       ac_precious_vars='build_alias\n host_alias\n@@ -1783,6 +1784,9 @@ Optional Features:\n                           disable libquadmath support for Fortran\n   --enable-default-pie    enable Position Independent Executable as default\n   --enable-cet            enable Intel CET in host libraries [default=auto]\n+  --enable-s390-excess-float-precision\n+                          on s390 targets, evaluate float with double\n+                          precision when in standards-conforming mode\n \n Optional Packages:\n   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]\n@@ -19180,7 +19184,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19183 \"configure\"\n+#line 19187 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19286,7 +19290,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19289 \"configure\"\n+#line 19293 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -31731,6 +31735,75 @@ fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ld_pushpopstate_support\" >&5\n $as_echo \"$ld_pushpopstate_support\" >&6; }\n \n+# On s390, float_t has historically been statically defined as double for no\n+# good reason. To comply with the C standard in the light of this definition,\n+# gcc has evaluated float expressions in double precision when in\n+# standards-compatible mode or when given -fexcess-precision=standard. To enable\n+# a smooth transition towards the new model used by most architectures, where\n+# gcc describes its behavior via the macro __FLT_EVAL_METHOD__ and glibc derives\n+# float_t from that, this behavior can be configured with\n+# --enable-s390-excess-float-precision. When given as enabled, that flag selects\n+# the old model. When omitted, native builds will derive the flag from the\n+# behavior of glibc. When glibc clamps float_t to double, gcc follows the old\n+# model. In any other case, it defaults to the new model.\n+# Check whether --enable-s390-excess-float-precision was given.\n+if test \"${enable_s390_excess_float_precision+set}\" = set; then :\n+  enableval=$enable_s390_excess_float_precision;\n+else\n+  enable_s390_excess_float_precision=auto\n+fi\n+\n+\n+case $target in\n+  s390*-linux*)\n+  if test \"$target\" = \"$host\" -a \"$host\" = \"$build\" -a \\\n+      x\"$enable_s390_excess_float_precision\" = xauto; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for glibc clamping float_t to double\" >&5\n+$as_echo_n \"checking for glibc clamping float_t to double... \" >&6; }\n+if ${gcc_cv_float_t_clamped_to_double+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test \"$cross_compiling\" = yes; then :\n+  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+as_fn_error $? \"cannot run test program while cross compiling\n+See \\`config.log' for more details\" \"$LINENO\" 5; }\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+#define __FLT_EVAL_METHOD__ 0\n+#include <math.h>\n+int main() {\n+  return !(sizeof(float_t) == sizeof(double));\n+}\n+_ACEOF\n+if ac_fn_cxx_try_run \"$LINENO\"; then :\n+  gcc_cv_float_t_clamped_to_double=yes\n+else\n+  gcc_cv_float_t_clamped_to_double=no\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_float_t_clamped_to_double\" >&5\n+$as_echo \"$gcc_cv_float_t_clamped_to_double\" >&6; }\n+    if test x\"$gcc_cv_float_t_clamped_to_double\" = xyes; then\n+      enable_s390_excess_float_precision=yes\n+    fi\n+  fi\n+\n+\n+  if test x\"$enable_s390_excess_float_precision\" = xyes; then\n+\n+$as_echo \"#define ENABLE_S390_EXCESS_FLOAT_PRECISION 1\" >>confdefs.h\n+\n+  fi\n+  ;;\n+esac\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n "}, {"sha": "24679a540c153bff2d80f87e6529e1f4f0e06a02", "filename": "gcc/configure.ac", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "patch": "@@ -7318,6 +7318,51 @@ if test x\"$ld_pushpopstate_support\" = xyes; then\n fi\n AC_MSG_RESULT($ld_pushpopstate_support)\n \n+# On s390, float_t has historically been statically defined as double for no\n+# good reason. To comply with the C standard in the light of this definition,\n+# gcc has evaluated float expressions in double precision when in\n+# standards-compatible mode or when given -fexcess-precision=standard. To enable\n+# a smooth transition towards the new model used by most architectures, where\n+# gcc describes its behavior via the macro __FLT_EVAL_METHOD__ and glibc derives\n+# float_t from that, this behavior can be configured with\n+# --enable-s390-excess-float-precision. When given as enabled, that flag selects\n+# the old model. When omitted, native builds will derive the flag from the\n+# behavior of glibc. When glibc clamps float_t to double, gcc follows the old\n+# model. In any other case, it defaults to the new model.\n+AC_ARG_ENABLE(s390-excess-float-precision,\n+  [AS_HELP_STRING([--enable-s390-excess-float-precision],\n+\t\t  [on s390 targets, evaluate float with double precision\n+\t\t   when in standards-conforming mode])],\n+  [],[enable_s390_excess_float_precision=auto])\n+\n+case $target in\n+  s390*-linux*)\n+  if test \"$target\" = \"$host\" -a \"$host\" = \"$build\" -a \\\n+      x\"$enable_s390_excess_float_precision\" = xauto; then\n+    AC_CACHE_CHECK([for glibc clamping float_t to double],\n+      gcc_cv_float_t_clamped_to_double,\n+      [AC_RUN_IFELSE([AC_LANG_SOURCE([\n+#define __FLT_EVAL_METHOD__ 0\n+#include <math.h>\n+int main() {\n+  return !(sizeof(float_t) == sizeof(double));\n+}])],\n+        [gcc_cv_float_t_clamped_to_double=yes],\n+        [gcc_cv_float_t_clamped_to_double=no])])\n+    if test x\"$gcc_cv_float_t_clamped_to_double\" = xyes; then\n+      enable_s390_excess_float_precision=yes\n+    fi\n+  fi\n+\n+  GCC_TARGET_TEMPLATE(ENABLE_S390_EXCESS_FLOAT_PRECISION)\n+  if test x\"$enable_s390_excess_float_precision\" = xyes; then\n+    AC_DEFINE(ENABLE_S390_EXCESS_FLOAT_PRECISION, 1,\n+[Define to enable evaluating float expressions with double precision in\n+standards-compatible mode on s390 targets.])\n+  fi\n+  ;;\n+esac\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n "}, {"sha": "a38ca3e3ce864d74d637e549665992762eadf5d3", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=a5dd6b69fcbe74c02d4821ac2daf2b8c9f819f6e", "patch": "@@ -2270,6 +2270,16 @@ information in object.\n \n The option is disabled by default. It is enabled on RISC-V/ELF (bare-metal)\n target if target binutils supported.\n+\n+@item --enable-s390-excess-float-precision\n+@itemx --disable-s390-excess-float-precision\n+On s390(x) targets, enable treatment of float expressions with double precision\n+when in standards-compliant mode (e.g., when @code{--std=c99} or\n+@code{-fexcess-precision=standard} are given).\n+\n+For a native build, the option's default is derived from glibc's behavior. When\n+glibc clamps float_t to double, gcc follows and enables the option. In all other\n+cases, it defaults to off.\n @end table\n \n @subheading Cross-Compiler-Specific Options"}]}