{"sha": "b6e7a3d1f97d5a2c611797ba52e75790888f0379", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZlN2EzZDFmOTdkNWEyYzYxMTc5N2JhNTJlNzU3OTA4ODhmMDM3OQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-01-31T20:52:00Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-01-31T20:52:00Z"}, "message": "Use clock_gettime in libgfortran timing intrinsics, cleanup\n\nFrom-SVN: r169449", "tree": {"sha": "218eeedfb68b9af80b02714d695e24e0effb0fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/218eeedfb68b9af80b02714d695e24e0effb0fbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6e7a3d1f97d5a2c611797ba52e75790888f0379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e7a3d1f97d5a2c611797ba52e75790888f0379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e7a3d1f97d5a2c611797ba52e75790888f0379", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e7a3d1f97d5a2c611797ba52e75790888f0379/comments", "author": null, "committer": null, "parents": [{"sha": "e1bcd685a28f47ae3b70b5a0f3f005e2d327b580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1bcd685a28f47ae3b70b5a0f3f005e2d327b580", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1bcd685a28f47ae3b70b5a0f3f005e2d327b580"}], "stats": {"total": 431, "additions": 257, "deletions": 174}, "files": [{"sha": "1c7553904a78de3f37de6cb1e11cb25ddf2538cf", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -1,3 +1,19 @@\n+2011-01-31  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* configure.ac: Check for clock_gettime().\n+\t* configure: Regenerated.\n+\t* config.h.in: Regenerated.\n+\t* intrinsics/time_1.h (__time_1): Rename to gf_cputime, add\n+\ttimes() fallback.\n+\t(gf_gettime): New function.\n+\t* intrinsics/cpu_time.c (__cpu_time_1): Update to call gf_cputime.\n+\t* intrinsics/date_and_time.c (date_and_time): Use gf_gettime.\n+\t* intrinsics/dtime.c (dtime_sub): Use gf_cputime.\n+\t* intrinsics/etime.c (etime_sub): Use gf_cputime.\n+\t* intrinsics/system_clock.c (system_clock_4): Use gf_gettime.\n+\t(system_clock_8): Use gf_gettime, increase count rate to allow\n+\tnanosecond precision, remove overflow prone branch.\n+\n 2011-01-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/47434"}, {"sha": "fdf502b870c0551432f7470d0e5b8cb2dd0c0459", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -207,6 +207,9 @@\n /* Define to 1 if you have the `clock' function. */\n #undef HAVE_CLOCK\n \n+/* Define to 1 if you have the `clock_gettime' function. */\n+#undef HAVE_CLOCK_GETTIME\n+\n /* libm includes clog */\n #undef HAVE_CLOG\n "}, {"sha": "ec5c7ed999b3bf9f96c84b63b4632f4392779b46", "filename": "libgfortran/configure", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -16380,6 +16380,17 @@ _ACEOF\n fi\n done\n \n+for ac_func in clock_gettime\n+do :\n+  ac_fn_c_check_func \"$LINENO\" \"clock_gettime\" \"ac_cv_func_clock_gettime\"\n+if test \"x$ac_cv_func_clock_gettime\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_CLOCK_GETTIME 1\n+_ACEOF\n+\n+fi\n+done\n+\n \n # Check for glibc backtrace functions\n for ac_func in backtrace backtrace_symbols\n@@ -25249,6 +25260,58 @@ $as_echo \"#define HAVE_FEENABLEEXCEPT 1\" >>confdefs.h\n fi\n \n \n+# At least for glibc, clock_gettime is in librt.  But don't pull that\n+# in if it still doesn't give us the function we want.\n+# This test is copied from libgomp.\n+if test $ac_cv_func_clock_gettime = no; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for clock_gettime in -lrt\" >&5\n+$as_echo_n \"checking for clock_gettime in -lrt... \" >&6; }\n+if test \"${ac_cv_lib_rt_clock_gettime+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lrt  $LIBS\"\n+if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char clock_gettime ();\n+int\n+main ()\n+{\n+return clock_gettime ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  ac_cv_lib_rt_clock_gettime=yes\n+else\n+  ac_cv_lib_rt_clock_gettime=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_rt_clock_gettime\" >&5\n+$as_echo \"$ac_cv_lib_rt_clock_gettime\" >&6; }\n+if test \"x$ac_cv_lib_rt_clock_gettime\" = x\"\"yes; then :\n+  LIBS=\"-lrt $LIBS\"\n+\n+$as_echo \"#define HAVE_CLOCK_GETTIME 1\" >>confdefs.h\n+\n+fi\n+\n+fi\n+\n # Check for SysV fpsetmask\n \n   { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether fpsetmask is present\" >&5"}, {"sha": "ed1e2cc31a1821e6adfaab67b4ac23141bf4d37c", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -252,6 +252,7 @@ AC_CHECK_FUNCS(sleep time ttyname signal alarm ctime clock access fork execl)\n AC_CHECK_FUNCS(wait setmode execvp pipe dup2 close fdopen strcasestr getrlimit)\n AC_CHECK_FUNCS(gettimeofday stat fstat lstat getpwuid vsnprintf dup getcwd)\n AC_CHECK_FUNCS(localtime_r gmtime_r strerror_r getpwuid_r ttyname_r ctime_r)\n+AC_CHECK_FUNCS(clock_gettime)\n \n # Check for glibc backtrace functions\n AC_CHECK_FUNCS(backtrace backtrace_symbols)\n@@ -483,6 +484,16 @@ LIBGFOR_CHECK_FLOAT128\n # Check for GNU libc feenableexcept\n AC_CHECK_LIB([m],[feenableexcept],[have_feenableexcept=yes AC_DEFINE([HAVE_FEENABLEEXCEPT],[1],[libm includes feenableexcept])])\n \n+# At least for glibc, clock_gettime is in librt.  But don't pull that\n+# in if it still doesn't give us the function we want.\n+# This test is copied from libgomp.\n+if test $ac_cv_func_clock_gettime = no; then\n+  AC_CHECK_LIB(rt, clock_gettime,\n+    [LIBS=\"-lrt $LIBS\"  \n+     AC_DEFINE(HAVE_CLOCK_GETTIME, 1,\n+               [Define to 1 if you have the `clock_gettime' function.])])\n+fi\n+\n # Check for SysV fpsetmask\n LIBGFOR_CHECK_FPSETMASK\n "}, {"sha": "619f8d25246409e0f32c96299db724213aa62b45", "filename": "libgfortran/intrinsics/cpu_time.c", "status": "modified", "additions": 12, "deletions": 38, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fcpu_time.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fcpu_time.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fcpu_time.c?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -1,7 +1,7 @@\n /* Implementation of the CPU_TIME intrinsic.\n-   Copyright (C) 2003, 2007, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2007, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -25,49 +25,23 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include \"time_1.h\"\n \n-/* The most accurate way to get the CPU time is getrusage ().\n-   If we have times(), that's good enough, too.  */\n-#if !defined (HAVE_GETRUSAGE) || !defined (HAVE_SYS_RESOURCE_H)\n-/* For times(), we _must_ know the number of clock ticks per second.  */\n-#  if defined (HAVE_TIMES) && (defined (HZ) || defined (_SC_CLK_TCK) || defined (CLK_TCK))\n-#    ifdef HAVE_SYS_PARAM_H\n-#      include <sys/param.h>\n-#    endif\n-#    if defined (HAVE_SYS_TIMES_H)\n-#      include <sys/times.h>\n-#    endif\n-#    ifndef HZ\n-#      if defined _SC_CLK_TCK\n-#        define HZ  sysconf(_SC_CLK_TCK)\n-#      else\n-#        define HZ  CLK_TCK\n-#      endif\n-#    endif\n-#  endif  /* HAVE_TIMES etc.  */\n-#endif  /* !HAVE_GETRUSAGE || !HAVE_SYS_RESOURCE_H  */\n \n static inline void __cpu_time_1 (long *, long *) ATTRIBUTE_ALWAYS_INLINE;\n \n static inline void\n __cpu_time_1 (long *sec, long *usec)\n {\n-#if defined(__MINGW32__) || defined (HAVE_GETRUSAGE) && defined (HAVE_SYS_RESOURCE_H)\n   long user_sec, user_usec, system_sec, system_usec;\n-  __time_1 (&user_sec, &user_usec, &system_sec, &system_usec);\n-  *sec = user_sec + system_sec;\n-  *usec = user_usec + system_usec;\n-#else /* ! HAVE_GETRUSAGE || ! HAVE_SYS_RESOURCE_H  */\n-#ifdef HAVE_TIMES\n-  struct tms buf;\n-  times (&buf);\n-  *sec = 0;\n-  *usec = (buf.tms_utime + buf.tms_stime) * (1000000 / HZ);\n-#else /* ! HAVE_TIMES */\n-  /* We have nothing to go on.  Return -1.  */\n-  *sec = -1;\n-  *usec = 0;\n-#endif  /* HAVE_TIMES */\n-#endif  /* __MINGW32__ || HAVE_GETRUSAGE */\n+  if (gf_cputime (&user_sec, &user_usec, &system_sec, &system_usec) == 0)\n+    {\n+      *sec = user_sec + system_sec;\n+      *usec = user_usec + system_usec;\n+    }\n+  else\n+    {\n+      *sec = -1;\n+      *usec = 0;\n+    }\n }\n \n "}, {"sha": "714df14c8f12cea835f509c3aaa9ce1f0469cbed", "filename": "libgfortran/intrinsics/date_and_time.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fdate_and_time.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fdate_and_time.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdate_and_time.c?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of the DATE_AND_TIME intrinsic.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009, 2010\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Steven Bosscher.\n \n@@ -29,21 +29,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <assert.h>\n #include <stdlib.h>\n \n-#undef HAVE_NO_DATE_TIME\n-#if TIME_WITH_SYS_TIME\n-#  include <sys/time.h>\n-#  include <time.h>\n-#else\n-#  if HAVE_SYS_TIME_H\n-#    include <sys/time.h>\n-#  else\n-#    ifdef HAVE_TIME_H\n-#      include <time.h>\n-#    else\n-#      define HAVE_NO_DATE_TIME\n-#    endif  /* HAVE_TIME_H  */\n-#  endif  /* HAVE_SYS_TIME_H  */\n-#endif  /* TIME_WITH_SYS_TIME  */\n+#include \"time_1.h\"\n \n #ifndef abs\n #define abs(x) ((x)>=0 ? (x) : -(x))\n@@ -176,28 +162,12 @@ date_and_time (char *__date, char *__time, char *__zone,\n   struct tm local_time;\n   struct tm UTC_time;\n \n-#if HAVE_GETTIMEOFDAY\n-  {\n-    struct timeval tp;\n-\n-    if (!gettimeofday (&tp, NULL))\n-      {\n-         lt = tp.tv_sec;\n-         values[7] = tp.tv_usec / 1000;\n-      }\n-    else\n-      {\n-         lt = time (NULL);\n-         values[7] = 0;\n-      }\n-  }\n-#else\n-  lt = time (NULL);\n-  values[7] = 0;\n-#endif /* HAVE_GETTIMEOFDAY */\n+  long nanosecs;\n \n-  if (lt != (time_t) -1)\n+  if (!gf_gettime(GF_CLOCK_REALTIME, &lt, &nanosecs))\n     {\n+      values[7] = nanosecs / 1000000;\n+\n       localtime_r (&lt, &local_time);\n       gmtime_r (&lt, &UTC_time);\n "}, {"sha": "e36e1f1d04a9a9c5159bcb05bb17fcb0a9538ba6", "filename": "libgfortran/intrinsics/dtime.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fdtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fdtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdtime.c?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -1,7 +1,8 @@\n /* Implementation of the dtime intrinsic.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2009, 2011 Free Software\n+   Foundation, Inc.\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -47,7 +48,7 @@ dtime_sub (gfc_array_r4 *t, GFC_REAL_4 *result)\n     runtime_error (\"Insufficient number of elements in TARRAY.\");\n \n   __gthread_mutex_lock (&dtime_update_lock);\n-  if (__time_1 (&user_sec, &user_usec, &system_sec, &system_usec) == 0)\n+  if (gf_cputime (&user_sec, &user_usec, &system_sec, &system_usec) == 0)\n     {\n       tu = (GFC_REAL_4) ((user_sec - us) + 1.e-6 * (user_usec - uu));\n       ts = (GFC_REAL_4) ((system_sec - ss) + 1.e-6 * (system_usec - su));"}, {"sha": "d90bc3022d7e008202f84b495330b9670b9a2959", "filename": "libgfortran/intrinsics/etime.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fetime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fetime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fetime.c?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -1,8 +1,9 @@\n /* Implementation of the ETIME intrinsic.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2009, 2011 Free Software\n+   Foundation, Inc.\n    Contributed by Steven G. Kargl <kargls@comcast.net>.\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -38,7 +39,7 @@ etime_sub (gfc_array_r4 *t, GFC_REAL_4 *result)\n   if (((GFC_DESCRIPTOR_EXTENT(t,0))) < 2)\n     runtime_error (\"Insufficient number of elements in TARRAY.\");\n \n-  if (__time_1 (&user_sec, &user_usec, &system_sec, &system_usec) == 0)\n+  if (gf_cputime (&user_sec, &user_usec, &system_sec, &system_usec) == 0)\n     {\n       tu = (GFC_REAL_4)(user_sec + 1.e-6 * user_usec);\n       ts = (GFC_REAL_4)(system_sec + 1.e-6 * system_usec);"}, {"sha": "37155628d53076974060cb744e62962d1edb9951", "filename": "libgfortran/intrinsics/system_clock.c", "status": "modified", "additions": 26, "deletions": 85, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fsystem_clock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Fsystem_clock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsystem_clock.c?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -1,5 +1,6 @@\n /* Implementation of the SYSTEM_CLOCK intrinsic.\n-   Copyright (C) 2004, 2005, 2007, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2009, 2010, 2011 Free Software\n+   Foundation, Inc.\n \n This file is part of the GNU Fortran runtime library (libgfortran).\n \n@@ -26,15 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include <limits.h>\n \n-#if defined(HAVE_SYS_TIME_H) && defined(HAVE_GETTIMEOFDAY)\n-#  include <sys/time.h>\n-#elif defined(HAVE_TIME_H)\n-#  include <time.h>\n-#  define TCK 1\n-#else\n-#define TCK 0\n-#endif\n-\n+#include \"time_1.h\"\n \n extern void system_clock_4 (GFC_INTEGER_4 *, GFC_INTEGER_4 *, GFC_INTEGER_4 *);\n export_proto(system_clock_4);\n@@ -52,21 +45,21 @@ void\n system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n \t       GFC_INTEGER_4 *count_max)\n {\n+#undef TCK\n+#define TCK 1000\n   GFC_INTEGER_4 cnt;\n   GFC_INTEGER_4 mx;\n \n-#if defined(HAVE_SYS_TIME_H) && defined(HAVE_GETTIMEOFDAY)\n-#undef TCK\n-#define TCK 1000\n-  struct timeval tp1;\n+  time_t secs;\n+  long nanosecs;\n \n-  if (sizeof (tp1.tv_sec) < sizeof (GFC_INTEGER_4))\n-    internal_error (NULL, \"tv_sec too small\");\n+  if (sizeof (secs) < sizeof (GFC_INTEGER_4))\n+    internal_error (NULL, \"secs too small\");\n \n-  if (gettimeofday(&tp1, NULL) == 0)\n+  if (gf_gettime (GF_CLOCK_MONOTONIC, &secs, &nanosecs) == 0)\n     {\n-      GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) tp1.tv_sec * TCK;\n-      ucnt += (tp1.tv_usec + 500000 / TCK) / (1000000 / TCK);\n+      GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) secs * TCK;\n+      ucnt += (nanosecs + 500000000 / TCK) / (1000000000 / TCK);\n       if (ucnt > GFC_INTEGER_4_HUGE)\n \tcnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n       else\n@@ -83,22 +76,7 @@ system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n \t*count_max = 0;\n       return;\n     }\n-#elif defined(HAVE_TIME_H)\n-  GFC_UINTEGER_4 ucnt;\n-\n-  if (sizeof (time_t) < sizeof (GFC_INTEGER_4))\n-    internal_error (NULL, \"time_t too small\");\n \n-  ucnt = time (NULL);\n-  if (ucnt > GFC_INTEGER_4_HUGE)\n-    cnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n-  else\n-    cnt = ucnt;\n-  mx = GFC_INTEGER_4_HUGE;\n-#else\n-  cnt = - GFC_INTEGER_4_HUGE;\n-  mx = 0;\n-#endif\n   if (count != NULL)\n     *count = cnt;\n   if (count_rate != NULL)\n@@ -114,39 +92,26 @@ void\n system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n \t\tGFC_INTEGER_8 *count_max)\n {\n+#undef TCK\n+#define TCK 1000000000\n   GFC_INTEGER_8 cnt;\n   GFC_INTEGER_8 mx;\n \n-#if defined(HAVE_SYS_TIME_H) && defined(HAVE_GETTIMEOFDAY)\n-#undef TCK\n-#define TCK 1000000\n-  struct timeval tp1;\n+  time_t secs;\n+  long nanosecs;\n \n-  if (sizeof (tp1.tv_sec) < sizeof (GFC_INTEGER_4))\n-    internal_error (NULL, \"tv_sec too small\");\n+  if (sizeof (secs) < sizeof (GFC_INTEGER_4))\n+    internal_error (NULL, \"secs too small\");\n \n-  if (gettimeofday(&tp1, NULL) == 0)\n+  if (gf_gettime (GF_CLOCK_MONOTONIC, &secs, &nanosecs) == 0)\n     {\n-      if (sizeof (tp1.tv_sec) < sizeof (GFC_INTEGER_8))\n-\t{\n-\t  GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) tp1.tv_sec * TCK;\n-\t  ucnt += (tp1.tv_usec + 500000 / TCK) / (1000000 / TCK);\n-\t  if (ucnt > GFC_INTEGER_4_HUGE)\n-\t    cnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n-\t  else\n-\t    cnt = ucnt;\n-\t  mx = GFC_INTEGER_4_HUGE;\n-\t}\n+      GFC_UINTEGER_8 ucnt = (GFC_UINTEGER_8) secs * TCK;\n+      ucnt += (nanosecs + 500000000 / TCK) / (1000000000 / TCK);\n+      if (ucnt > GFC_INTEGER_8_HUGE)\n+\tcnt = ucnt - GFC_INTEGER_8_HUGE - 1;\n       else\n-\t{\n-\t  GFC_UINTEGER_8 ucnt = (GFC_UINTEGER_8) tp1.tv_sec * TCK;\n-\t  ucnt += (tp1.tv_usec + 500000 / TCK) / (1000000 / TCK);\n-\t  if (ucnt > GFC_INTEGER_8_HUGE)\n-\t    cnt = ucnt - GFC_INTEGER_8_HUGE - 1;\n-\t  else\n-\t    cnt = ucnt;\n-\t  mx = GFC_INTEGER_8_HUGE;\n-\t}\n+\tcnt = ucnt;\n+      mx = GFC_INTEGER_8_HUGE;\n     }\n   else\n     {\n@@ -159,31 +124,7 @@ system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n \n       return;\n     }\n-#elif defined(HAVE_TIME_H)\n-  if (sizeof (time_t) < sizeof (GFC_INTEGER_4))\n-    internal_error (NULL, \"time_t too small\");\n-  else if (sizeof (time_t) == sizeof (GFC_INTEGER_4))\n-    {\n-      GFC_UINTEGER_4 ucnt = time (NULL);\n-      if (ucnt > GFC_INTEGER_4_HUGE)\n-\tcnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n-      else\n-\tcnt = ucnt;\n-      mx = GFC_INTEGER_4_HUGE;\n-    }\n-  else\n-    {\n-      GFC_UINTEGER_8 ucnt = time (NULL);\n-      if (ucnt > GFC_INTEGER_8_HUGE)\n-\tcnt = ucnt - GFC_INTEGER_8_HUGE - 1;\n-      else\n-\tcnt = ucnt;\n-      mx = GFC_INTEGER_8_HUGE;\n-    }\n-#else\n-  cnt = - GFC_INTEGER_8_HUGE;\n-  mx = 0;\n-#endif\n+\n   if (count != NULL)\n     *count = cnt;\n   if (count_rate != NULL)"}, {"sha": "5ee5d5acb4a55bf11dacdf0ced96cbf1be436ee0", "filename": "libgfortran/intrinsics/time_1.h", "status": "modified", "additions": 112, "deletions": 9, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Ftime_1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7a3d1f97d5a2c611797ba52e75790888f0379/libgfortran%2Fintrinsics%2Ftime_1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ftime_1.h?ref=b6e7a3d1f97d5a2c611797ba52e75790888f0379", "patch": "@@ -1,7 +1,7 @@\n-/* Implementation of the CPU_TIME intrinsic.\n-   Copyright (C) 2003, 2007, 2009 Free Software Foundation, Inc.\n+/* Wrappers for platform timing functions.\n+   Copyright (C) 2003, 2007, 2009, 2011 Free Software Foundation, Inc.\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -60,16 +60,38 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #  include <sys/resource.h>\n #endif  /* HAVE_GETRUSAGE && HAVE_SYS_RESOURCE_H  */\n \n+/* The most accurate way to get the CPU time is getrusage ().\n+   If we have times(), that's good enough, too.  */\n+#if !defined (HAVE_GETRUSAGE) || !defined (HAVE_SYS_RESOURCE_H)\n+/* For times(), we _must_ know the number of clock ticks per second.  */\n+#  if defined (HAVE_TIMES) && (defined (HZ) || defined (_SC_CLK_TCK) || defined (CLK_TCK))\n+#    ifdef HAVE_SYS_PARAM_H\n+#      include <sys/param.h>\n+#    endif\n+#    if defined (HAVE_SYS_TIMES_H)\n+#      include <sys/times.h>\n+#    endif\n+#    ifndef HZ\n+#      if defined _SC_CLK_TCK\n+#        define HZ  sysconf(_SC_CLK_TCK)\n+#      else\n+#        define HZ  CLK_TCK\n+#      endif\n+#    endif\n+#  endif  /* HAVE_TIMES etc.  */\n+#endif  /* !HAVE_GETRUSAGE || !HAVE_SYS_RESOURCE_H  */\n+\n+\n #if defined (__GNUC__) && (__GNUC__ >= 3)\n #  define ATTRIBUTE_ALWAYS_INLINE __attribute__ ((__always_inline__))\n #else\n #  define ATTRIBUTE_ALWAYS_INLINE\n #endif\n \n-static inline int __time_1 (long *, long *, long *, long *) ATTRIBUTE_ALWAYS_INLINE;\n+static inline int gf_cputime (long *, long *, long *, long *) ATTRIBUTE_ALWAYS_INLINE;\n \n /* Helper function for the actual implementation of the DTIME, ETIME and\n-   CPU_TIME intrinsics.  Returns a CPU time in microseconds or -1 if no\n+   CPU_TIME intrinsics.  Returns 0 for success or -1 if no\n    CPU time could be computed.  */\n \n #ifdef __MINGW32__\n@@ -78,7 +100,7 @@ static inline int __time_1 (long *, long *, long *, long *) ATTRIBUTE_ALWAYS_INL\n #include <windows.h>\n \n static int\n-__time_1 (long *user_sec, long *user_usec, long *system_sec, long *system_usec)\n+gf_cputime (long *user_sec, long *user_usec, long *system_sec, long *system_usec)\n {\n   union {\n     FILETIME ft;\n@@ -112,23 +134,37 @@ __time_1 (long *user_sec, long *user_usec, long *system_sec, long *system_usec)\n #else\n \n static inline int\n-__time_1 (long *user_sec, long *user_usec, long *system_sec, long *system_usec)\n+gf_cputime (long *user_sec, long *user_usec, long *system_sec, long *system_usec)\n {\n #if defined (HAVE_GETRUSAGE) && defined (HAVE_SYS_RESOURCE_H)\n   struct rusage usage;\n-  getrusage (RUSAGE_SELF, &usage);\n+  int err;\n+  err = getrusage (RUSAGE_SELF, &usage);\n \n   *user_sec = usage.ru_utime.tv_sec;\n   *user_usec = usage.ru_utime.tv_usec;\n   *system_sec = usage.ru_stime.tv_sec;\n   *system_usec = usage.ru_stime.tv_usec;\n+  return err;\n+\n+#elif defined HAVE_TIMES\n+  struct tms buf;\n+  clock_t err;\n+  err = times (&buf);\n+  *user_sec = buf.tms_utime / HZ;\n+  *user_usec = buf.tms_utime % HZ * (1000000 / HZ);\n+  *system_sec = buf.tms_stime / HZ;\n+  *system_usec = buf.tms_stime % HZ * (1000000 / HZ);\n+  if ((err == (clock_t) -1) && errno != 0)\n+    return -1;\n   return 0;\n \n-#else /* ! HAVE_GETRUSAGE || ! HAVE_SYS_RESOURCE_H  */\n+#else \n \n   /* We have nothing to go on.  Return -1.  */\n   *user_sec = *system_sec = 0;\n   *user_usec = *system_usec = 0;\n+  errno = ENOSYS;\n   return -1;\n \n #endif\n@@ -137,4 +173,71 @@ __time_1 (long *user_sec, long *user_usec, long *system_sec, long *system_usec)\n #endif\n \n \n+/* POSIX states that CLOCK_REALTIME must be present if clock_gettime\n+   is available, others are optional.  */\n+#ifdef CLOCK_REALTIME\n+#define GF_CLOCK_REALTIME CLOCK_REALTIME\n+#else\n+#define GF_CLOCK_REALTIME 0\n+#endif\n+\n+#ifdef CLOCK_MONOTONIC\n+#define GF_CLOCK_MONOTONIC CLOCK_MONOTONIC\n+#else\n+#define GF_CLOCK_REALTIME GF_CLOCK_REALTIME\n+#endif\n+\n+/* Arguments:\n+   clock_id - INPUT, must be either GF_CLOCK_REALTIME or GF_CLOCK_MONOTONIC\n+   secs     - OUTPUT, seconds\n+   nanosecs - OUTPUT, OPTIONAL, nanoseconds\n+\n+   If clock_id equals GF_CLOCK_REALTIME, the OUTPUT arguments shall be\n+   the number of seconds and nanoseconds since the Epoch. If clock_id\n+   equals GF_CLOCK_MONOTONIC, and if the target supports it, the\n+   OUTPUT arguments represent a monotonically incrementing clock\n+   starting from some unspecified time in the past.\n+\n+   Return value: 0 for success, -1 for error. In case of error, errno\n+   is set.\n+*/\n+static inline int\n+gf_gettime (int clock_id __attribute__((unused)), time_t * secs, \n+            long * nanosecs)\n+{\n+#ifdef HAVE_CLOCK_GETTIME\n+  struct timespec ts;\n+  int err;\n+  err = clock_gettime (clock_id, &ts);\n+  *secs = ts.tv_sec;\n+  if (nanosecs)\n+    *nanosecs = ts.tv_nsec;\n+  return err;\n+#elif HAVE_GETTIMEOFDAY\n+  struct timeval tv;\n+  int err;\n+  err = gettimeofday (&tv, NULL);\n+  *secs = tv.tv_sec;\n+  if (nanosecs)\n+    *nanosecs = tv.tv_usec * 1000;\n+  return err;\n+#elif HAVE_TIME\n+  time_t t, t2;\n+  t = time (&t2);\n+  *secs = t2;\n+  if (nanosecs)\n+    *nanosecs = 0;\n+  if (t == ((time_t)-1))\n+    return -1;\n+  return 0;\n+#else\n+  *secs = 0;\n+  if (nanosecs)\n+    *nanosecs = 0;\n+  errno = ENOSYS;\n+  return -1;\n+#endif\n+}\n+\n+\n #endif /* LIBGFORTRAN_TIME_H */"}]}