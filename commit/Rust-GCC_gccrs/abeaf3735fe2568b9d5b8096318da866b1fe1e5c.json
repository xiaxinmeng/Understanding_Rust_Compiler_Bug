{"sha": "abeaf3735fe2568b9d5b8096318da866b1fe1e5c", "node_id": "C_kwDOANBUbNoAKGFiZWFmMzczNWZlMjU2OGI5ZDViODA5NjMxOGRhODY2YjFmZTFlNWM", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-10-26T21:47:29Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-11-02T19:51:40Z"}, "message": "Add 'libgomp.oacc-fortran/declare-allocatable-array_descriptor-1-runtime.f90'\n\n\tlibgomp/\n\t* testsuite/libgomp.oacc-fortran/declare-allocatable-array_descriptor-1-runtime.f90:\n\tNew.", "tree": {"sha": "bf1bdeb9f45721d26b9a535751c6d12903146965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf1bdeb9f45721d26b9a535751c6d12903146965"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abeaf3735fe2568b9d5b8096318da866b1fe1e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abeaf3735fe2568b9d5b8096318da866b1fe1e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abeaf3735fe2568b9d5b8096318da866b1fe1e5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abeaf3735fe2568b9d5b8096318da866b1fe1e5c/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59c6c5dbf267cd9d0a8df72b2a5eb5657b64268e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c6c5dbf267cd9d0a8df72b2a5eb5657b64268e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59c6c5dbf267cd9d0a8df72b2a5eb5657b64268e"}], "stats": {"total": 402, "additions": 402, "deletions": 0}, "files": [{"sha": "b27f312631dbca25abdcf94d1b1eb7e981aa4870", "filename": "libgomp/testsuite/libgomp.oacc-fortran/declare-allocatable-array_descriptor-1-runtime.f90", "status": "added", "additions": 402, "deletions": 0, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abeaf3735fe2568b9d5b8096318da866b1fe1e5c/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-runtime.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abeaf3735fe2568b9d5b8096318da866b1fe1e5c/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-runtime.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-runtime.f90?ref=abeaf3735fe2568b9d5b8096318da866b1fe1e5c", "patch": "@@ -0,0 +1,402 @@\n+! Test OpenACC 'declare create' with allocatable arrays.\n+\n+! { dg-do run }\n+\n+! Note that we're not testing OpenACC semantics here, but rather documenting\n+! current GCC behavior, specifically, behavior concerning updating of\n+! host/device array descriptors.\n+! { dg-skip-if n/a { *-*-* } { -DACC_MEM_SHARED=1 } }\n+\n+!TODO-OpenACC-declare-allocate\n+! Missing support for OpenACC \"Changes from Version 2.0 to 2.5\":\n+! \"The 'declare create' directive with a Fortran 'allocatable' has new behavior\".\n+! Thus, after 'allocate'/before 'deallocate', call 'acc_create'/'acc_delete'\n+! manually.\n+\n+\n+!TODO { dg-additional-options -fno-inline } for stable results regarding OpenACC 'routine'.\n+\n+\n+!TODO OpenACC 'serial' vs. GCC/nvptx:\n+!TODO { dg-prune-output {using 'vector_length \\(32\\)', ignoring 1} }\n+\n+\n+! { dg-additional-options -fdump-tree-original }\n+! { dg-additional-options -fdump-tree-gimple }\n+\n+\n+module vars\n+  implicit none\n+  integer, parameter :: n1_lb = -3\n+  integer, parameter :: n1_ub = 6\n+  integer, parameter :: n2_lb = -9999\n+  integer, parameter :: n2_ub = 22222\n+\n+  integer, allocatable :: b(:)\n+  !$acc declare create (b)\n+\n+end module vars\n+\n+program test\n+  use vars\n+  use openacc\n+  implicit none\n+  integer :: i\n+\n+  ! Identifiers for purposes of reliable '-fdump-tree-[...]' scanning.\n+  integer :: id1_1, id1_2\n+\n+  interface\n+\n+     subroutine verify_initial\n+       implicit none\n+       !$acc routine seq\n+     end subroutine verify_initial\n+\n+     subroutine verify_n1_allocated\n+       implicit none\n+       !$acc routine seq\n+     end subroutine verify_n1_allocated\n+\n+     subroutine verify_n1_values (addend)\n+       implicit none\n+       !$acc routine gang\n+       integer, value :: addend\n+     end subroutine verify_n1_values\n+\n+     subroutine verify_n1_deallocated (expect_allocated)\n+       implicit none\n+       !$acc routine seq\n+       logical, value :: expect_allocated\n+     end subroutine verify_n1_deallocated\n+\n+     subroutine verify_n2_allocated\n+       implicit none\n+       !$acc routine seq\n+     end subroutine verify_n2_allocated\n+\n+     subroutine verify_n2_values (addend)\n+       implicit none\n+       !$acc routine gang\n+       integer, value :: addend\n+     end subroutine verify_n2_values\n+\n+     subroutine verify_n2_deallocated (expect_allocated)\n+       implicit none\n+       !$acc routine seq\n+       logical, value :: expect_allocated\n+     end subroutine verify_n2_deallocated\n+\n+  end interface\n+\n+  call acc_create (id1_1)\n+  call acc_create (id1_2)\n+\n+  call verify_initial\n+  ! It is important here (and similarly, following) that there is no data\n+  ! clause for 'b' (explicit or implicit): no 'GOMP_MAP_TO_PSET'.\n+  !$acc serial\n+  call verify_initial\n+  !$acc end serial\n+\n+  allocate (b(n1_lb:n1_ub))\n+  call verify_n1_allocated\n+  if (acc_is_present (b)) error stop\n+  call acc_create (b)\n+  ! This is now OpenACC \"present\":\n+  if (.not.acc_is_present (b)) error stop\n+  ! This still has the initial array descriptor:\n+  !$acc serial\n+  call verify_initial\n+  !$acc end serial\n+\n+  do i = n1_lb, n1_ub\n+     b(i) = i - 1\n+  end do\n+\n+  ! Verify that host-to-device copy doesn't touch the device-side (still\n+  ! initial) array descriptor (but it does copy the array data).\n+  call acc_update_device (b)\n+  !$acc serial\n+  call verify_initial\n+  !$acc end serial\n+\n+  b = 40\n+\n+  ! Verify that device-to-host copy doesn't touch the host-side array\n+  ! descriptor, doesn't copy out the device-side (still initial) array\n+  ! descriptor (but it does copy the array data).\n+  call acc_update_self (b)\n+  call verify_n1_allocated\n+\n+  do i = n1_lb, n1_ub\n+     if (b(i) /= i - 1) error stop\n+     b(i) = b(i) + 2\n+  end do\n+\n+  ! The same using the OpenACC 'update' directive.\n+\n+  !$acc update device (b) self (id1_1)\n+  ! We do have 'GOMP_MAP_TO_PSET' here:\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc update map\\(force_to:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_1\\);$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_update map\\(force_to:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+  ! ..., but it's silently skipped in 'GOACC_update'.\n+  !$acc serial\n+  call verify_initial\n+  !$acc end serial\n+\n+  b = 41\n+\n+  !$acc update self (b) self (id1_2)\n+  ! We do have 'GOMP_MAP_TO_PSET' here:\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc update map\\(force_from:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_2\\);$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_update map\\(force_from:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+  ! ..., but it's silently skipped in 'GOACC_update'.\n+  call verify_n1_allocated\n+\n+  do i = n1_lb, n1_ub\n+     if (b(i) /= i + 1) error stop\n+     b(i) = b(i) + 2\n+  end do\n+\n+  ! Now install the actual array descriptor, via a data clause for 'b'\n+  ! (explicit or implicit): must get a 'GOMP_MAP_TO_PSET', which then in\n+  ! 'gomp_map_vars_internal' is handled as 'declare target', and because of\n+  ! '*(void **) hostaddrs[i] != NULL', we've got 'has_always_ptrset == true',\n+  ! 'always_to_cnt == 1', and therefore 'gomp_map_vars_existing' does update\n+  ! the 'GOMP_MAP_TO_PSET'.\n+  !$acc serial present (b) copyin (id1_1)\n+  call verify_initial\n+  id1_1 = 0\n+  !$acc end serial\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc serial map\\(force_present:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_1\\)$} 1 original } }\n+  !TODO ..., but without an actual use of 'b', the gimplifier removes the\n+  !TODO 'GOMP_MAP_TO_PSET':\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_serial map\\(force_present:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+  !$acc serial present (b) copyin (id1_2)\n+  call verify_n1_allocated\n+  !TODO Use of 'b':\n+  id1_2 = ubound (b, 1)\n+  !$acc end serial\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc serial map\\(force_present:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_2\\)$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_serial map\\(force_present:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+  !$acc parallel copyin (id1_1) ! No data clause for 'b' (explicit or implicit): no 'GOMP_MAP_TO_PSET'.\n+  call verify_n1_values (1)\n+  id1_1 = 0\n+  !$acc end parallel\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc parallel map\\(to:id1_1\\)$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_parallel map\\(to:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+  !$acc parallel copy (b) copyin (id1_2)\n+  ! As already present, 'copy (b)' doesn't copy; addend is still '1'.\n+  call verify_n1_values (1)\n+  id1_2 = 0\n+  !$acc end parallel\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc parallel map\\(tofrom:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_2\\)$} 1 original } }\n+  !TODO ..., but without an actual use of 'b', the gimplifier removes the\n+  !TODO 'GOMP_MAP_TO_PSET':\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_parallel map\\(tofrom:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+  call verify_n1_allocated\n+  if (.not.acc_is_present (b)) error stop\n+\n+  call acc_delete (b)\n+  if (.not.allocated (b)) error stop\n+  if (acc_is_present (b)) error stop\n+  ! The device-side array descriptor doesn't get updated, so 'b' still appears\n+  ! as \"allocated\":\n+  !$acc serial\n+  call verify_n1_allocated\n+  !$acc end serial\n+\n+  deallocate (b)\n+  call verify_n1_deallocated (.false.)\n+  ! The device-side array descriptor doesn't get updated, so 'b' still appears\n+  ! as \"allocated\":\n+  !$acc serial\n+  call verify_n1_allocated\n+  !$acc end serial\n+\n+  ! Now try to install the actual array descriptor, via a data clause for 'b'\n+  ! (explicit or implicit): must get a 'GOMP_MAP_TO_PSET', which then in\n+  ! 'gomp_map_vars_internal' is handled as 'declare target', but because of\n+  ! '*(void **) hostaddrs[i] == NULL', we've got 'has_always_ptrset == false',\n+  ! 'always_to_cnt == 0', and therefore 'gomp_map_vars_existing' doesn't update\n+  ! the 'GOMP_MAP_TO_PSET'.\n+  ! The device-side array descriptor doesn't get updated, so 'b' still appears\n+  ! as \"allocated\":\n+  !TODO Why does 'present (b)' still work here?\n+  !$acc serial present (b) copyout (id1_2)\n+  call verify_n1_deallocated (.true.)\n+  !TODO Use of 'b'.\n+  id1_2 = ubound (b, 1)\n+  !$acc end serial\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc serial map\\(force_present:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(from:id1_2\\)$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_serial map\\(force_present:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(from:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+\n+  ! Restart the procedure, with different array dimensions.\n+\n+  allocate (b(n2_lb:n2_ub))\n+  call verify_n2_allocated\n+  if (acc_is_present (b)) error stop\n+  call acc_create (b)\n+  if (.not.acc_is_present (b)) error stop\n+  ! This still has the previous (n1) array descriptor:\n+  !$acc serial\n+  call verify_n1_deallocated (.true.)\n+  !$acc end serial\n+\n+  do i = n2_lb, n2_ub\n+     b(i) = i + 20\n+  end do\n+\n+  call acc_update_device (b)\n+  !$acc serial\n+  call verify_n1_deallocated (.true.)\n+  !$acc end serial\n+\n+  b = -40\n+\n+  call acc_update_self (b)\n+  call verify_n2_allocated\n+\n+  do i = n2_lb, n2_ub\n+     if (b(i) /= i + 20) error stop\n+     b(i) = b(i) - 40\n+  end do\n+\n+  !$acc update device (b)\n+  !$acc serial\n+  call verify_n1_deallocated (.true.)\n+  !$acc end serial\n+\n+  b = -41\n+\n+  !$acc update self (b)\n+  call verify_n2_allocated\n+\n+  do i = n2_lb, n2_ub\n+     if (b(i) /= i - 20) error stop\n+     b(i) = b(i) + 10\n+  end do\n+\n+  !$acc serial present (b) copy (id1_2)\n+  call verify_n2_allocated\n+  !TODO Use of 'b':\n+  id1_2 = ubound (b, 1)\n+  !$acc end serial\n+\n+  !$acc parallel\n+  call verify_n2_values (-20)\n+  !$acc end parallel\n+\n+  !$acc parallel copy (b)\n+  call verify_n2_values (-20)\n+  !$acc end parallel\n+\n+  call verify_n2_allocated\n+  if (.not.acc_is_present (b)) error stop\n+\n+  call acc_delete (b)\n+  if (.not.allocated (b)) error stop\n+  if (acc_is_present (b)) error stop\n+  !$acc serial\n+  call verify_n2_allocated\n+  !$acc end serial\n+\n+  deallocate (b)\n+  call verify_n2_deallocated (.false.)\n+  !$acc serial\n+  call verify_n2_allocated\n+  !$acc end serial\n+\n+  !$acc serial present (b) copy (id1_2)\n+  call verify_n2_deallocated (.true.)\n+  !TODO Use of 'b':\n+  id1_2 = ubound (b, 1)\n+  !$acc end serial\n+\n+end program test\n+\n+\n+subroutine verify_initial\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+\n+  if (allocated (b)) error stop \"verify_initial allocated\"\n+  if (any (lbound (b) /= [0])) error stop \"verify_initial lbound\"\n+  if (any (ubound (b) /= [0])) error stop \"verify_initial ubound\"\n+end subroutine verify_initial\n+\n+subroutine verify_n1_allocated\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+\n+  if (.not.allocated (b)) error stop \"verify_n1_allocated allocated\"\n+  if (any (lbound (b) /= [n1_lb])) error stop \"verify_n1_allocated lbound\"\n+  if (any (ubound (b) /= [n1_ub])) error stop \"verify_n1_allocated ubound\"\n+end subroutine verify_n1_allocated\n+\n+subroutine verify_n1_values (addend)\n+  use vars\n+  implicit none\n+  !$acc routine gang\n+  integer, value :: addend\n+  integer :: i\n+\n+  !$acc loop\n+  do i = n1_lb, n1_ub\n+     if (b(i) /= i + addend) error stop\n+  end do\n+end subroutine verify_n1_values\n+\n+subroutine verify_n1_deallocated (expect_allocated)\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+  logical, value :: expect_allocated\n+\n+  if (allocated(b) .neqv. expect_allocated) error stop \"verify_n1_deallocated allocated\"\n+  ! Apparently 'deallocate'ing doesn't unset the bounds.\n+  if (any (lbound (b) /= [n1_lb])) error stop \"verify_n1_deallocated lbound\"\n+  if (any (ubound (b) /= [n1_ub])) error stop \"verify_n1_deallocated ubound\"\n+end subroutine verify_n1_deallocated\n+\n+subroutine verify_n2_allocated\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+\n+  if (.not.allocated(b)) error stop \"verify_n2_allocated allocated\"\n+  if (any (lbound (b) /= [n2_lb])) error stop \"verify_n2_allocated lbound\"\n+  if (any (ubound (b) /= [n2_ub])) error stop \"verify_n2_allocated ubound\"\n+end subroutine verify_n2_allocated\n+\n+subroutine verify_n2_values (addend)\n+  use vars\n+  implicit none\n+  !$acc routine gang\n+  integer, value :: addend\n+  integer :: i\n+\n+  !$acc loop\n+  do i = n2_lb, n2_ub\n+     if (b(i) /= i + addend) error stop\n+  end do\n+end subroutine verify_n2_values\n+\n+subroutine verify_n2_deallocated (expect_allocated)\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+  logical, value :: expect_allocated\n+\n+  if (allocated(b) .neqv. expect_allocated) error stop \"verify_n2_deallocated allocated\"\n+  ! Apparently 'deallocate'ing doesn't unset the bounds.\n+  if (any (lbound (b) /= [n2_lb])) error stop \"verify_n2_deallocated lbound\"\n+  if (any (ubound (b) /= [n2_ub])) error stop \"verify_n2_deallocated ubound\"\n+end subroutine verify_n2_deallocated"}]}