{"sha": "de27caacfb3da386f499e0f1c65a3246675824bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUyN2NhYWNmYjNkYTM4NmY0OTllMGYxYzY1YTMyNDY2NzU4MjRiYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-23T19:04:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-23T19:04:37Z"}, "message": "Implement new syscall package.\n\nCalls to library functions now use entersyscall and\nexitsyscall as appropriate.  This is a first step toward\nmultiplexing goroutines onto threads.\n\nFrom-SVN: r180345", "tree": {"sha": "664e8146cf480634282350e5f7f68403941ddfea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/664e8146cf480634282350e5f7f68403941ddfea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de27caacfb3da386f499e0f1c65a3246675824bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de27caacfb3da386f499e0f1c65a3246675824bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de27caacfb3da386f499e0f1c65a3246675824bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de27caacfb3da386f499e0f1c65a3246675824bc/comments", "author": null, "committer": null, "parents": [{"sha": "7b45b87f01235d15b5d9403fa59693a97e49611a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b45b87f01235d15b5d9403fa59693a97e49611a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b45b87f01235d15b5d9403fa59693a97e49611a"}], "stats": {"total": 5607, "additions": 3554, "deletions": 2053}, "files": [{"sha": "ce0fe837c4f2a1d6247117adaf989981c972dd39", "filename": "libgo/Makefile.am", "status": "modified", "additions": 97, "deletions": 105, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -1392,128 +1392,142 @@ go_testing_script_files = \\\n \n # Define Syscall and Syscall6.\n if LIBGO_IS_RTEMS\n-syscall_syscall_file = syscalls/syscall_stubs.go\n+syscall_syscall_file = go/syscall/syscall_stubs.go\n else\n-syscall_syscall_file = syscalls/syscall.go\n+syscall_syscall_file = go/syscall/syscall_unix.go\n endif\n \n-# Declare libc functions that vary for largefile systems.\n-if LIBGO_IS_LINUX\n-# Always use lseek64 on GNU/Linux.\n-syscall_filesize_file = syscalls/sysfile_largefile.go\n-syscall_stat_file = syscalls/sysfile_stat_largefile.go\n-else # !LIBGO_IS_LINUX\n-if LIBGO_IS_SOLARIS\n-if LIBGO_IS_386\n-# Use lseek64 on 32-bit Solaris/x86.\n-syscall_filesize_file = syscalls/sysfile_largefile.go\n-syscall_stat_file = syscalls/sysfile_stat_largefile.go\n-else # !LIBGO_IS_386\n-if LIBGO_IS_SPARC\n-# Use lseek64 on 32-bit Solaris/SPARC.\n-syscall_filesize_file = syscalls/sysfile_largefile.go\n-syscall_stat_file = syscalls/sysfile_stat_largefile.go\n-else # !LIBGO_IS_386 && !LIBGO_IS_SPARC\n-# Use lseek on 64-bit Solaris.\n-syscall_filesize_file = syscalls/sysfile_regfile.go\n-syscall_stat_file = syscalls/sysfile_stat_regfile.go\n-endif # !LIBGO_IS_386 && !LIBGO_IS_SPARC\n-endif # !LIBGO_IS_SOLARIS\n-else # !LIBGO_IS_LINUX && !LIBGO_IS_SOLARIS\n-# Use lseek by default.\n-syscall_filesize_file = syscalls/sysfile_regfile.go\n-syscall_stat_file = syscalls/sysfile_stat_regfile.go\n-endif # !LIBGO_IS_SOLARIS\n-endif # !LIBGO_IS_LINUX\n-\n-\n-# Define ForkExec, PtraceForkExec, and Exec.\n+# Define ForkExec and Exec.\n if LIBGO_IS_RTEMS\n-syscall_exec_os_file = syscalls/exec_stubs.go\n+syscall_exec_file = go/syscall/exec_stubs.go\n else\n-syscall_exec_os_file = syscalls/exec.go\n+syscall_exec_file = go/syscall/exec_unix.go\n endif\n \n # Define Wait4.\n if HAVE_WAIT4\n-syscall_wait_file = syscalls/wait4.go\n+syscall_wait_file = go/syscall/libcall_wait4.go\n else\n-syscall_wait_file = syscalls/waitpid.go\n+syscall_wait_file = go/syscall/libcall_waitpid.go\n endif\n \n # Define Sleep.\n if LIBGO_IS_RTEMS\n-syscall_sleep_file = syscalls/sleep_rtems.go\n+syscall_sleep_file = go/syscall/sleep_rtems.go\n else\n-syscall_sleep_file = syscalls/sleep_select.go\n+syscall_sleep_file = go/syscall/sleep_select.go\n endif\n \n # Define Errstr.\n+if LIBGO_IS_LINUX\n+syscall_errstr_file = go/syscall/errstr_linux.go\n+else\n if LIBGO_IS_RTEMS\n-syscall_errstr_file = syscalls/errstr_rtems.go\n+syscall_errstr_file = go/syscall/errstr_linux.go\n else\n if HAVE_STRERROR_R\n-syscall_errstr_file = syscalls/errstr.go\n+syscall_errstr_file = go/syscall/errstr.go\n else\n-syscall_errstr_file = syscalls/errstr_nor.go\n+syscall_errstr_file = go/syscall/errstr_nor.go\n+endif\n endif\n endif\n \n-# Declare libc_strerror_r which is the Go name for strerror_r.\n-if LIBGO_IS_RTEMS\n-# RTEMS uses newlib in which strerror_r returns char *.\n-syscall_errstr_decl_file = syscalls/errstr_decl_rtems.go\n-else\n+# Declare libc functions that vary for largefile systems.\n if LIBGO_IS_LINUX\n-# On GNU/Linux the POSIX strerror_r is called __xpg_strerror_r.\n-syscall_errstr_decl_file = syscalls/errstr_decl_linux.go\n-else\n-# On other systems we hope strerror_r is just strerror_r.\n-syscall_errstr_decl_file = syscalls/errstr_decl.go\n-endif\n-endif\n+# Always use lseek64 on GNU/Linux.\n+syscall_size_file = go/syscall/libcall_posix_largefile.go\n+else # !LIBGO_IS_LINUX\n+if LIBGO_IS_SOLARIS\n+if LIBGO_IS_386\n+# Use lseek64 on 32-bit Solaris/x86.\n+syscall_size_file = go/syscall/libcall_posix_largefile.go\n+else # !LIBGO_IS_386\n+if LIBGO_IS_SPARC\n+# Use lseek64 on 32-bit Solaris/SPARC.\n+syscall_size_file = go/syscall/libcall_posix_largefile.go\n+else # !LIBGO_IS_386 && !LIBGO_IS_SPARC\n+# Use lseek on 64-bit Solaris.\n+syscall_size_file = go/syscall/libcall_posix_regfile.go\n+endif # !LIBGO_IS_386 && !LIBGO_IS_SPARC\n+endif # !LIBGO_IS_SOLARIS\n+else # !LIBGO_IS_LINUX && !LIBGO_IS_SOLARIS\n+# Use lseek by default.\n+syscall_size_file = go/syscall/libcall_posix_regfile.go\n+endif # !LIBGO_IS_SOLARIS\n+endif # !LIBGO_IS_LINUX\n \n # Define socket sizes and types.\n if LIBGO_IS_LINUX\n-syscall_socket_os_file = syscalls/socket_linux.go\n+syscall_socket_file = go/syscall/socket_linux.go\n else\n if LIBGO_IS_SOLARIS\n-syscall_socket_os_file = syscalls/socket_solaris.go\n+syscall_socket_file = go/syscall/socket_solaris.go\n else\n if LIBGO_IS_IRIX\n-syscall_socket_os_file = syscalls/socket_irix.go\n+syscall_socket_file = go/syscall/socket_irix.go\n else\n-syscall_socket_os_file = syscalls/socket_bsd.go\n+syscall_socket_file = go/syscall/socket_bsd.go\n endif\n endif\n endif\n \n-# Support for epoll.\n-if LIBGO_IS_LINUX\n-syscall_socket_epoll_file = syscalls/socket_epoll.go\n-else\n-syscall_socket_epoll_file =\n-endif\n-\n # Support for uname.\n if LIBGO_IS_SOLARIS\n if LIBGO_IS_386\n-# 32-bit Solaris 2/x86 needs _nuname, handled in syscall_solaris_386.go.\n+# 32-bit Solaris 2/x86 needs _nuname, handled in libcall_solaris_386.go.\n syscall_uname_file =\n else # !LIBGO_IS_386 && LIBGO_IS_SOLARIS\n-syscall_uname_file = syscalls/syscall_uname.go\n+syscall_uname_file = go/syscall/libcall_uname.go\n endif\n else # !LIBGO_IS_SOLARIS\n-syscall_uname_file = syscalls/syscall_uname.go\n+syscall_uname_file = go/syscall/libcall_uname.go\n endif\n \n # Support for netlink sockets and messages.\n if LIBGO_IS_LINUX\n-syscall_netlink_file = syscalls/netlink_linux.go\n+syscall_netlink_file = go/syscall/netlink_linux.go\n else\n syscall_netlink_file =\n endif\n \n+go_base_syscall_files = \\\n+\tgo/syscall/libcall_support.go \\\n+\tgo/syscall/libcall_posix.go \\\n+\tgo/syscall/socket.go \\\n+\tgo/syscall/str.go \\\n+\tgo/syscall/syscall.go \\\n+\t$(syscall_syscall_file) \\\n+\t$(syscall_exec_file) \\\n+\t$(syscall_wait_file) \\\n+\t$(syscall_sleep_file) \\\n+\t$(syscall_errstr_file) \\\n+\t$(syscall_size_file) \\\n+\t$(syscall_socket_file) \\\n+\t$(syscall_uname_file) \\\n+\t$(syscall_netlink_file) \\\n+\t$(GO_LIBCALL_OS_FILE) \\\n+\t$(GO_LIBCALL_OS_ARCH_FILE) \\\n+\t$(GO_SYSCALL_OS_FILE) \\\n+\t$(GO_SYSCALL_OS_ARCH_FILE)\n+\n+go_syscall_files = \\\n+\t$(go_base_syscall_files) \\\n+\tlibcalls.go \\\n+\tsysinfo.go \\\n+\tsyscall_arch.go\n+go_syscall_c_files = \\\n+\tgo/syscall/errno.c \\\n+\tgo/syscall/wait.c\n+\n+libcalls.go: s-libcalls; @true\n+s-libcalls: Makefile go/syscall/mksyscall.awk $(go_base_syscall_files)\n+\trm -f libcalls.go.tmp\n+\tfiles=`echo $^ | sed -e 's/Makefile//' -e 's|[^ ]*go/syscall/mksyscall.awk||'`; \\\n+\t$(AWK) -f $(srcdir)/go/syscall/mksyscall.awk $${files} > libcalls.go.tmp\n+\t$(SHELL) $(srcdir)/../move-if-change libcalls.go.tmp libcalls.go\n+\t$(STAMP) $@\n+\n syscall_arch.go: s-syscall_arch; @true\n s-syscall_arch: Makefile\n \trm -f syscall_arch.go.tmp\n@@ -1523,30 +1537,11 @@ s-syscall_arch: Makefile\n \t$(SHELL) $(srcdir)/../move-if-change syscall_arch.go.tmp syscall_arch.go\n \t$(STAMP) $@\n \n-go_syscall_files = \\\n-\t$(syscall_errstr_file) \\\n-\t$(syscall_errstr_decl_file) \\\n-\tsyscalls/exec_helpers.go \\\n-\t$(syscall_exec_os_file) \\\n-\t$(syscall_wait_file) \\\n-\t$(syscall_filesize_file) \\\n-\t$(syscall_netlink_file) \\\n-\t$(syscall_stat_file) \\\n-\t$(syscall_sleep_file) \\\n-\tsyscalls/socket.go \\\n-\t$(syscall_socket_os_file) \\\n-\t$(syscall_socket_epoll_file) \\\n-\t$(syscall_syscall_file) \\\n-\t$(syscall_uname_file) \\\n-\tsyscalls/syscall_unix.go \\\n-\tsyscalls/stringbyte.go \\\n-\tsyscalls/syscall_$(GOOS).go \\\n-\t$(GO_SYSCALLS_SYSCALL_OS_ARCH_FILE) \\\n-\tsyscalls/sysfile_posix.go \\\n-\tsysinfo.go \\\n-\tsyscall_arch.go\n-go_syscall_c_files = \\\n-\tsyscalls/errno.c\n+sysinfo.go: s-sysinfo; @true\n+s-sysinfo: $(srcdir)/mksysinfo.sh config.h\n+\tCC=\"$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(OSCFLAGS)\" $(SHELL) $(srcdir)/mksysinfo.sh\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-sysinfo.go sysinfo.go\n+\t$(STAMP) $@\n \n if LIBGO_IS_LINUX\n # os_lib_inotify_lo = os/inotify.lo\n@@ -1708,8 +1703,9 @@ libgo_go_objs = \\\n \truntime/pprof.lo \\\n \tsync/atomic.lo \\\n \tsync/atomic_c.lo \\\n-\tsyscalls/syscall.lo \\\n-\tsyscalls/errno.lo \\\n+\tsyscall/syscall.lo \\\n+\tsyscall/errno.lo \\\n+\tsyscall/wait.lo \\\n \ttemplate/parse.lo \\\n \ttesting/testing.lo \\\n \ttesting/iotest.lo \\\n@@ -2983,16 +2979,12 @@ testing/script/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: testing/script/check\n \n-sysinfo.go: s-sysinfo; @true\n-s-sysinfo: $(srcdir)/mksysinfo.sh config.h\n-\tCC=\"$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(OSCFLAGS)\" $(SHELL) $(srcdir)/mksysinfo.sh\n-\t$(SHELL) $(srcdir)/../move-if-change tmp-sysinfo.go sysinfo.go\n-\t$(STAMP) $@\n-\n-syscalls/syscall.lo: $(go_syscall_files) sync.gox\n+syscall/syscall.lo: $(go_syscall_files) sync.gox\n \t$(BUILDPACKAGE)\n-syscalls/errno.lo: $(go_syscall_c_files) syscalls/syscall.lo\n-\t$(LTCOMPILE) -c -o $@ $(srcdir)/syscalls/errno.c\n+syscall/errno.lo: go/syscall/errno.c\n+\t$(LTCOMPILE) -c -o $@ $<\n+syscall/wait.lo: go/syscall/wait.c\n+\t$(LTCOMPILE) -c -o $@ $<\n \n # How to build a .gox file from a .lo file.\n BUILDGOX = \\\n@@ -3079,7 +3071,7 @@ sync.gox: sync/sync.lo\n \t$(BUILDGOX)\n syslog.gox: syslog/syslog.lo\n \t$(BUILDGOX)\n-syscall.gox: syscalls/syscall.lo\n+syscall.gox: syscall/syscall.lo\n \t$(BUILDGOX)\n tabwriter.gox: tabwriter/tabwriter.lo\n \t$(BUILDGOX)"}, {"sha": "e18d242c56fc61fa2450ce60ad568190a6368bbe", "filename": "libgo/Makefile.in", "status": "modified", "additions": 86, "deletions": 83, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -171,9 +171,10 @@ am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tmime/multipart.lo net/dict.lo net/textproto.lo old/template.lo \\\n \t$(am__DEPENDENCIES_1) os/user.lo os/signal.lo path/filepath.lo \\\n \trpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n-\tsync/atomic.lo sync/atomic_c.lo syscalls/syscall.lo \\\n-\tsyscalls/errno.lo template/parse.lo testing/testing.lo \\\n-\ttesting/iotest.lo testing/quick.lo testing/script.lo\n+\tsync/atomic.lo sync/atomic_c.lo syscall/syscall.lo \\\n+\tsyscall/errno.lo syscall/wait.lo template/parse.lo \\\n+\ttesting/testing.lo testing/iotest.lo testing/quick.lo \\\n+\ttesting/script.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -375,7 +376,10 @@ GOARCH = @GOARCH@\n GOC = @GOC@\n GOCFLAGS = $(CFLAGS)\n GOOS = @GOOS@\n-GO_SYSCALLS_SYSCALL_OS_ARCH_FILE = @GO_SYSCALLS_SYSCALL_OS_ARCH_FILE@\n+GO_LIBCALL_OS_ARCH_FILE = @GO_LIBCALL_OS_ARCH_FILE@\n+GO_LIBCALL_OS_FILE = @GO_LIBCALL_OS_FILE@\n+GO_SYSCALL_OS_ARCH_FILE = @GO_SYSCALL_OS_ARCH_FILE@\n+GO_SYSCALL_OS_FILE = @GO_SYSCALL_OS_FILE@\n GREP = @GREP@\n INSTALL = @INSTALL@\n INSTALL_DATA = @INSTALL_DATA@\n@@ -1781,97 +1785,85 @@ go_testing_quick_files = \\\n go_testing_script_files = \\\n \tgo/testing/script/script.go\n \n-@LIBGO_IS_RTEMS_FALSE@syscall_syscall_file = syscalls/syscall.go\n+@LIBGO_IS_RTEMS_FALSE@syscall_syscall_file = go/syscall/syscall_unix.go\n \n # Define Syscall and Syscall6.\n-@LIBGO_IS_RTEMS_TRUE@syscall_syscall_file = syscalls/syscall_stubs.go\n-# Use lseek on 64-bit Solaris.\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@@LIBGO_IS_SPARC_FALSE@syscall_filesize_file = syscalls/sysfile_regfile.go\n-# Use lseek64 on 32-bit Solaris/SPARC.\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@@LIBGO_IS_SPARC_TRUE@syscall_filesize_file = syscalls/sysfile_largefile.go\n-# Use lseek64 on 32-bit Solaris/x86.\n-@LIBGO_IS_386_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_filesize_file = syscalls/sysfile_largefile.go\n-# Use lseek by default.\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_filesize_file = syscalls/sysfile_regfile.go\n+@LIBGO_IS_RTEMS_TRUE@syscall_syscall_file = go/syscall/syscall_stubs.go\n+@LIBGO_IS_RTEMS_FALSE@syscall_exec_file = go/syscall/exec_unix.go\n \n-# Declare libc functions that vary for largefile systems.\n-# Always use lseek64 on GNU/Linux.\n-@LIBGO_IS_LINUX_TRUE@syscall_filesize_file = syscalls/sysfile_largefile.go\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@@LIBGO_IS_SPARC_FALSE@syscall_stat_file = syscalls/sysfile_stat_regfile.go\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@@LIBGO_IS_SPARC_TRUE@syscall_stat_file = syscalls/sysfile_stat_largefile.go\n-@LIBGO_IS_386_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_stat_file = syscalls/sysfile_stat_largefile.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_stat_file = syscalls/sysfile_stat_regfile.go\n-@LIBGO_IS_LINUX_TRUE@syscall_stat_file = syscalls/sysfile_stat_largefile.go\n-@LIBGO_IS_RTEMS_FALSE@syscall_exec_os_file = syscalls/exec.go\n-\n-# Define ForkExec, PtraceForkExec, and Exec.\n-@LIBGO_IS_RTEMS_TRUE@syscall_exec_os_file = syscalls/exec_stubs.go\n-@HAVE_WAIT4_FALSE@syscall_wait_file = syscalls/waitpid.go\n+# Define ForkExec and Exec.\n+@LIBGO_IS_RTEMS_TRUE@syscall_exec_file = go/syscall/exec_stubs.go\n+@HAVE_WAIT4_FALSE@syscall_wait_file = go/syscall/libcall_waitpid.go\n \n # Define Wait4.\n-@HAVE_WAIT4_TRUE@syscall_wait_file = syscalls/wait4.go\n-@LIBGO_IS_RTEMS_FALSE@syscall_sleep_file = syscalls/sleep_select.go\n+@HAVE_WAIT4_TRUE@syscall_wait_file = go/syscall/libcall_wait4.go\n+@LIBGO_IS_RTEMS_FALSE@syscall_sleep_file = go/syscall/sleep_select.go\n \n # Define Sleep.\n-@LIBGO_IS_RTEMS_TRUE@syscall_sleep_file = syscalls/sleep_rtems.go\n-@HAVE_STRERROR_R_FALSE@@LIBGO_IS_RTEMS_FALSE@syscall_errstr_file = syscalls/errstr_nor.go\n-@HAVE_STRERROR_R_TRUE@@LIBGO_IS_RTEMS_FALSE@syscall_errstr_file = syscalls/errstr.go\n+@LIBGO_IS_RTEMS_TRUE@syscall_sleep_file = go/syscall/sleep_rtems.go\n+@HAVE_STRERROR_R_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@syscall_errstr_file = go/syscall/errstr_nor.go\n+@HAVE_STRERROR_R_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@syscall_errstr_file = go/syscall/errstr.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_TRUE@syscall_errstr_file = go/syscall/errstr_linux.go\n \n # Define Errstr.\n-@LIBGO_IS_RTEMS_TRUE@syscall_errstr_file = syscalls/errstr_rtems.go\n-# On other systems we hope strerror_r is just strerror_r.\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@syscall_errstr_decl_file = syscalls/errstr_decl.go\n-# On GNU/Linux the POSIX strerror_r is called __xpg_strerror_r.\n-@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@syscall_errstr_decl_file = syscalls/errstr_decl_linux.go\n-\n-# Declare libc_strerror_r which is the Go name for strerror_r.\n-# RTEMS uses newlib in which strerror_r returns char *.\n-@LIBGO_IS_RTEMS_TRUE@syscall_errstr_decl_file = syscalls/errstr_decl_rtems.go\n-@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_socket_os_file = syscalls/socket_bsd.go\n-@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_socket_os_file = syscalls/socket_irix.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_socket_os_file = syscalls/socket_solaris.go\n+@LIBGO_IS_LINUX_TRUE@syscall_errstr_file = go/syscall/errstr_linux.go\n+# Use lseek on 64-bit Solaris.\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@@LIBGO_IS_SPARC_FALSE@syscall_size_file = go/syscall/libcall_posix_regfile.go\n+# Use lseek64 on 32-bit Solaris/SPARC.\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@@LIBGO_IS_SPARC_TRUE@syscall_size_file = go/syscall/libcall_posix_largefile.go\n+# Use lseek64 on 32-bit Solaris/x86.\n+@LIBGO_IS_386_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_size_file = go/syscall/libcall_posix_largefile.go\n+# Use lseek by default.\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_size_file = go/syscall/libcall_posix_regfile.go\n \n-# Define socket sizes and types.\n-@LIBGO_IS_LINUX_TRUE@syscall_socket_os_file = syscalls/socket_linux.go\n-@LIBGO_IS_LINUX_FALSE@syscall_socket_epoll_file = \n+# Declare libc functions that vary for largefile systems.\n+# Always use lseek64 on GNU/Linux.\n+@LIBGO_IS_LINUX_TRUE@syscall_size_file = go/syscall/libcall_posix_largefile.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_socket_file = go/syscall/socket_bsd.go\n+@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_socket_file = go/syscall/socket_irix.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_socket_file = go/syscall/socket_solaris.go\n \n-# Support for epoll.\n-@LIBGO_IS_LINUX_TRUE@syscall_socket_epoll_file = syscalls/socket_epoll.go\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_uname_file = syscalls/syscall_uname.go\n+# Define socket sizes and types.\n+@LIBGO_IS_LINUX_TRUE@syscall_socket_file = go/syscall/socket_linux.go\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_uname_file = go/syscall/libcall_uname.go\n \n # Support for uname.\n-# 32-bit Solaris 2/x86 needs _nuname, handled in syscall_solaris_386.go.\n+# 32-bit Solaris 2/x86 needs _nuname, handled in libcall_solaris_386.go.\n @LIBGO_IS_386_TRUE@@LIBGO_IS_SOLARIS_TRUE@syscall_uname_file = \n-@LIBGO_IS_SOLARIS_FALSE@syscall_uname_file = syscalls/syscall_uname.go\n+@LIBGO_IS_SOLARIS_FALSE@syscall_uname_file = go/syscall/libcall_uname.go\n @LIBGO_IS_LINUX_FALSE@syscall_netlink_file = \n \n # Support for netlink sockets and messages.\n-@LIBGO_IS_LINUX_TRUE@syscall_netlink_file = syscalls/netlink_linux.go\n-go_syscall_files = \\\n-\t$(syscall_errstr_file) \\\n-\t$(syscall_errstr_decl_file) \\\n-\tsyscalls/exec_helpers.go \\\n-\t$(syscall_exec_os_file) \\\n+@LIBGO_IS_LINUX_TRUE@syscall_netlink_file = go/syscall/netlink_linux.go\n+go_base_syscall_files = \\\n+\tgo/syscall/libcall_support.go \\\n+\tgo/syscall/libcall_posix.go \\\n+\tgo/syscall/socket.go \\\n+\tgo/syscall/str.go \\\n+\tgo/syscall/syscall.go \\\n+\t$(syscall_syscall_file) \\\n+\t$(syscall_exec_file) \\\n \t$(syscall_wait_file) \\\n-\t$(syscall_filesize_file) \\\n-\t$(syscall_netlink_file) \\\n-\t$(syscall_stat_file) \\\n \t$(syscall_sleep_file) \\\n-\tsyscalls/socket.go \\\n-\t$(syscall_socket_os_file) \\\n-\t$(syscall_socket_epoll_file) \\\n-\t$(syscall_syscall_file) \\\n+\t$(syscall_errstr_file) \\\n+\t$(syscall_size_file) \\\n+\t$(syscall_socket_file) \\\n \t$(syscall_uname_file) \\\n-\tsyscalls/syscall_unix.go \\\n-\tsyscalls/stringbyte.go \\\n-\tsyscalls/syscall_$(GOOS).go \\\n-\t$(GO_SYSCALLS_SYSCALL_OS_ARCH_FILE) \\\n-\tsyscalls/sysfile_posix.go \\\n+\t$(syscall_netlink_file) \\\n+\t$(GO_LIBCALL_OS_FILE) \\\n+\t$(GO_LIBCALL_OS_ARCH_FILE) \\\n+\t$(GO_SYSCALL_OS_FILE) \\\n+\t$(GO_SYSCALL_OS_ARCH_FILE)\n+\n+go_syscall_files = \\\n+\t$(go_base_syscall_files) \\\n+\tlibcalls.go \\\n \tsysinfo.go \\\n \tsyscall_arch.go\n \n go_syscall_c_files = \\\n-\tsyscalls/errno.c\n+\tgo/syscall/errno.c \\\n+\tgo/syscall/wait.c\n \n @LIBGO_IS_LINUX_FALSE@os_lib_inotify_lo = \n \n@@ -2030,8 +2022,9 @@ libgo_go_objs = \\\n \truntime/pprof.lo \\\n \tsync/atomic.lo \\\n \tsync/atomic_c.lo \\\n-\tsyscalls/syscall.lo \\\n-\tsyscalls/errno.lo \\\n+\tsyscall/syscall.lo \\\n+\tsyscall/errno.lo \\\n+\tsyscall/wait.lo \\\n \ttemplate/parse.lo \\\n \ttesting/testing.lo \\\n \ttesting/iotest.lo \\\n@@ -4377,6 +4370,14 @@ s-version: Makefile\n \t$(SHELL) $(srcdir)/../move-if-change version.go.tmp version.go\n \t$(STAMP) $@\n \n+libcalls.go: s-libcalls; @true\n+s-libcalls: Makefile go/syscall/mksyscall.awk $(go_base_syscall_files)\n+\trm -f libcalls.go.tmp\n+\tfiles=`echo $^ | sed -e 's/Makefile//' -e 's|[^ ]*go/syscall/mksyscall.awk||'`; \\\n+\t$(AWK) -f $(srcdir)/go/syscall/mksyscall.awk $${files} > libcalls.go.tmp\n+\t$(SHELL) $(srcdir)/../move-if-change libcalls.go.tmp libcalls.go\n+\t$(STAMP) $@\n+\n syscall_arch.go: s-syscall_arch; @true\n s-syscall_arch: Makefile\n \trm -f syscall_arch.go.tmp\n@@ -4386,6 +4387,12 @@ s-syscall_arch: Makefile\n \t$(SHELL) $(srcdir)/../move-if-change syscall_arch.go.tmp syscall_arch.go\n \t$(STAMP) $@\n \n+sysinfo.go: s-sysinfo; @true\n+s-sysinfo: $(srcdir)/mksysinfo.sh config.h\n+\tCC=\"$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(OSCFLAGS)\" $(SHELL) $(srcdir)/mksysinfo.sh\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-sysinfo.go sysinfo.go\n+\t$(STAMP) $@\n+\n asn1/asn1.lo: $(go_asn1_files) big.gox bytes.gox fmt.gox io.gox os.gox \\\n \t\treflect.gox strconv.gox strings.gox time.gox\n \t$(BUILDPACKAGE)\n@@ -5559,16 +5566,12 @@ testing/script/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: testing/script/check\n \n-sysinfo.go: s-sysinfo; @true\n-s-sysinfo: $(srcdir)/mksysinfo.sh config.h\n-\tCC=\"$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(OSCFLAGS)\" $(SHELL) $(srcdir)/mksysinfo.sh\n-\t$(SHELL) $(srcdir)/../move-if-change tmp-sysinfo.go sysinfo.go\n-\t$(STAMP) $@\n-\n-syscalls/syscall.lo: $(go_syscall_files) sync.gox\n+syscall/syscall.lo: $(go_syscall_files) sync.gox\n \t$(BUILDPACKAGE)\n-syscalls/errno.lo: $(go_syscall_c_files) syscalls/syscall.lo\n-\t$(LTCOMPILE) -c -o $@ $(srcdir)/syscalls/errno.c\n+syscall/errno.lo: go/syscall/errno.c\n+\t$(LTCOMPILE) -c -o $@ $<\n+syscall/wait.lo: go/syscall/wait.c\n+\t$(LTCOMPILE) -c -o $@ $<\n \n asn1.gox: asn1/asn1.lo\n \t$(BUILDGOX)\n@@ -5650,7 +5653,7 @@ sync.gox: sync/sync.lo\n \t$(BUILDGOX)\n syslog.gox: syslog/syslog.lo\n \t$(BUILDGOX)\n-syscall.gox: syscalls/syscall.lo\n+syscall.gox: syscall/syscall.lo\n \t$(BUILDGOX)\n tabwriter.gox: tabwriter/tabwriter.lo\n \t$(BUILDGOX)"}, {"sha": "b9e6a31f842517d0d55d596c905c861bb5aedd41", "filename": "libgo/configure", "status": "modified", "additions": 67, "deletions": 6, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -617,7 +617,10 @@ USING_SPLIT_STACK_FALSE\n USING_SPLIT_STACK_TRUE\n SPLIT_STACK\n OSCFLAGS\n-GO_SYSCALLS_SYSCALL_OS_ARCH_FILE\n+GO_SYSCALL_OS_ARCH_FILE\n+GO_SYSCALL_OS_FILE\n+GO_LIBCALL_OS_ARCH_FILE\n+GO_LIBCALL_OS_FILE\n GOARCH\n LIBGO_IS_X86_64_FALSE\n LIBGO_IS_X86_64_TRUE\n@@ -10913,7 +10916,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10916 \"configure\"\n+#line 10919 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11019,7 +11022,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11022 \"configure\"\n+#line 11025 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13151,6 +13154,49 @@ CC=\"$lt_save_CC\"\n CC_FOR_BUILD=${CC_FOR_BUILD:-gcc}\n \n \n+for ac_prog in gawk mawk nawk awk\n+do\n+  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n+set dummy $ac_prog; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if test \"${ac_cv_prog_AWK+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$AWK\"; then\n+  ac_cv_prog_AWK=\"$AWK\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if { test -f \"$as_dir/$ac_word$ac_exec_ext\" && $as_test_x \"$as_dir/$ac_word$ac_exec_ext\"; }; then\n+    ac_cv_prog_AWK=\"$ac_prog\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+AWK=$ac_cv_prog_AWK\n+if test -n \"$AWK\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $AWK\" >&5\n+$as_echo \"$AWK\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n+  test -n \"$AWK\" && break\n+done\n+\n+\n WARN_FLAGS='-Wall -Wextra -Wwrite-strings -Wcast-qual'\n \n \n@@ -13551,10 +13597,25 @@ fi\n \n \n \n-GO_SYSCALLS_SYSCALL_OS_ARCH_FILE=\n-if test -f ${srcdir}/syscalls/syscall_${GOOS}_${GOARCH}.go; then\n-  GO_SYSCALLS_SYSCALL_OS_ARCH_FILE=syscalls/syscall_${GOOS}_${GOARCH}.go\n+GO_LIBCALL_OS_FILE=\n+GO_LIBCALL_OS_ARCH_FILE=\n+GO_SYSCALL_OS_FILE=\n+GO_SYSCALL_OS_ARCH_FILE=\n+if test -f ${srcdir}/go/syscall/libcall_${GOOS}.go; then\n+  GO_LIBCALL_OS_FILE=go/syscall/libcall_${GOOS}.go\n fi\n+if test -f ${srcdir}/go/syscall/libcall_${GOOS}_${GOARCH}.go; then\n+  GO_LIBCALL_OS_ARCH_FILE=go/syscall/libcall_${GOOS}_${GOARCH}.go\n+fi\n+if test -f ${srcdir}/go/syscall/syscall_${GOOS}.go; then\n+  GO_SYSCALL_OS_FILE=go/syscall/syscall_${GOOS}.go\n+fi\n+if test -f ${srcdir}/go/syscall/syscall_${GOOS}_${GOARCH}.go; then\n+  GO_SYSCALL_OS_ARCH_FILE=go/syscall/syscall_${GOOS}_${GOARCH}.go\n+fi\n+\n+\n+\n \n \n case \"$target\" in"}, {"sha": "206e189bb9407310de7f742f31b68c842a0f9798", "filename": "libgo/configure.ac", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -45,6 +45,8 @@ AC_SUBST(enable_static)\n CC_FOR_BUILD=${CC_FOR_BUILD:-gcc}\n AC_SUBST(CC_FOR_BUILD)\n \n+AC_PROG_AWK\n+\n WARN_FLAGS='-Wall -Wextra -Wwrite-strings -Wcast-qual'\n AC_SUBST(WARN_FLAGS)\n \n@@ -249,11 +251,26 @@ AM_CONDITIONAL(LIBGO_IS_X86_64, test $is_x86_64 = yes)\n AC_SUBST(GOARCH)\n \n dnl Some files are only present when needed for specific architectures.\n-GO_SYSCALLS_SYSCALL_OS_ARCH_FILE=\n-if test -f ${srcdir}/syscalls/syscall_${GOOS}_${GOARCH}.go; then\n-  GO_SYSCALLS_SYSCALL_OS_ARCH_FILE=syscalls/syscall_${GOOS}_${GOARCH}.go\n+GO_LIBCALL_OS_FILE=\n+GO_LIBCALL_OS_ARCH_FILE=\n+GO_SYSCALL_OS_FILE=\n+GO_SYSCALL_OS_ARCH_FILE=\n+if test -f ${srcdir}/go/syscall/libcall_${GOOS}.go; then\n+  GO_LIBCALL_OS_FILE=go/syscall/libcall_${GOOS}.go\n+fi\n+if test -f ${srcdir}/go/syscall/libcall_${GOOS}_${GOARCH}.go; then\n+  GO_LIBCALL_OS_ARCH_FILE=go/syscall/libcall_${GOOS}_${GOARCH}.go\n+fi\n+if test -f ${srcdir}/go/syscall/syscall_${GOOS}.go; then\n+  GO_SYSCALL_OS_FILE=go/syscall/syscall_${GOOS}.go\n+fi\n+if test -f ${srcdir}/go/syscall/syscall_${GOOS}_${GOARCH}.go; then\n+  GO_SYSCALL_OS_ARCH_FILE=go/syscall/syscall_${GOOS}_${GOARCH}.go\n fi\n-AC_SUBST(GO_SYSCALLS_SYSCALL_OS_ARCH_FILE)\n+AC_SUBST(GO_LIBCALL_OS_FILE)\n+AC_SUBST(GO_LIBCALL_OS_ARCH_FILE)\n+AC_SUBST(GO_SYSCALL_OS_FILE)\n+AC_SUBST(GO_SYSCALL_OS_ARCH_FILE)\n \n dnl Some targets need special flags to build sysinfo.go.\n case \"$target\" in"}, {"sha": "d088eabc2b58c65acbe66bf0a5d9f8abbece3f45", "filename": "libgo/go/net/cgo_unix.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_unix.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -24,6 +24,17 @@ func libc_getaddrinfo(node *byte, service *byte, hints *syscall.Addrinfo, res **\n func libc_freeaddrinfo(res *syscall.Addrinfo) __asm__ (\"freeaddrinfo\")\n func libc_gai_strerror(errcode int) *byte __asm__ (\"gai_strerror\")\n \n+// bytePtrToString takes a NUL-terminated array of bytes and convert\n+// it to a Go string.\n+func bytePtrToString(p *byte) string {\n+\ta := (*[10000]byte)(unsafe.Pointer(p))\n+\ti := 0\n+\tfor a[i] != 0 {\n+\t\ti++\n+\t}\n+\treturn string(a[:i])\n+}\n+\n func cgoLookupHost(name string) (addrs []string, err os.Error, completed bool) {\n \tip, err, completed := cgoLookupIP(name)\n \tfor _, p := range ip {\n@@ -99,13 +110,13 @@ func cgoLookupIPCNAME(name string) (addrs []IP, cname string, err os.Error, comp\n \t\t} else if gerrno == syscall.EAI_SYSTEM {\n \t\t\tstr = syscall.Errstr(syscall.GetErrno())\n \t\t} else {\n-\t\t\tstr = syscall.BytePtrToString(libc_gai_strerror(gerrno))\n+\t\t\tstr = bytePtrToString(libc_gai_strerror(gerrno))\n \t\t}\n \t\treturn nil, \"\", &DNSError{Error: str, Name: name}, true\n \t}\n \tdefer libc_freeaddrinfo(res)\n \tif res != nil {\n-\t\tcname = syscall.BytePtrToString((*byte)(unsafe.Pointer(res.Ai_canonname)))\n+\t\tcname = bytePtrToString((*byte)(unsafe.Pointer(res.Ai_canonname)))\n \t\tif cname == \"\" {\n \t\t\tcname = name\n \t\t}"}, {"sha": "21fd8010fa693ae7749ffd1c11d494de5097a5b5", "filename": "libgo/go/net/fd_select.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fnet%2Ffd_select.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fnet%2Ffd_select.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_select.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -12,20 +12,20 @@ import (\n )\n \n type pollster struct {\n-\treadFds, writeFds, repeatFds *syscall.FdSet_t\n+\treadFds, writeFds, repeatFds *syscall.FdSet\n \tmaxFd int\n-\treadyReadFds, readyWriteFds *syscall.FdSet_t\n+\treadyReadFds, readyWriteFds *syscall.FdSet\n \tnReady int\n \tlastFd int\n }\n \n func newpollster() (p *pollster, err os.Error) {\n \tp = new(pollster)\n-\tp.readFds = new(syscall.FdSet_t)\n-\tp.writeFds = new(syscall.FdSet_t)\n-\tp.repeatFds = new(syscall.FdSet_t)\n-\tp.readyReadFds = new(syscall.FdSet_t)\n-\tp.readyWriteFds = new(syscall.FdSet_t)\n+\tp.readFds = new(syscall.FdSet)\n+\tp.writeFds = new(syscall.FdSet)\n+\tp.repeatFds = new(syscall.FdSet)\n+\tp.readyReadFds = new(syscall.FdSet)\n+\tp.readyWriteFds = new(syscall.FdSet)\n \tp.maxFd = -1\n \tp.nReady = 0\n \tp.lastFd = 0\n@@ -86,9 +86,9 @@ func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err os.E\n \t\t}\n \n \t\tvar n, e int\n-\t\tvar tmpReadFds, tmpWriteFds syscall.FdSet_t\n+\t\tvar tmpReadFds, tmpWriteFds syscall.FdSet\n \t\tfor {\n-\t\t\t// Temporary syscall.FdSet_ts into which the values are copied\n+\t\t\t// Temporary syscall.FdSet's into which the values are copied\n \t\t\t// because select mutates the values.\n \t\t\ttmpReadFds = *p.readFds\n \t\t\ttmpWriteFds = *p.writeFds"}, {"sha": "18a9687c26410dddb9103f098dae5e80570037c4", "filename": "libgo/go/os/user/lookup_unix.go", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -27,6 +27,17 @@ static int mygetpwuid_r(int uid, struct passwd *pwd,\n func libc_getpwnam_r(name *byte, pwd *syscall.Passwd, buf *byte, buflen syscall.Size_t, result **syscall.Passwd) int __asm__ (\"getpwnam_r\")\n func libc_getpwuid_r(uid syscall.Uid_t, pwd *syscall.Passwd, buf *byte, buflen syscall.Size_t, result **syscall.Passwd) int __asm__ (\"getpwuid_r\")\n \n+// bytePtrToString takes a NUL-terminated array of bytes and convert\n+// it to a Go string.\n+func bytePtrToString(p *byte) string {\n+\ta := (*[10000]byte)(unsafe.Pointer(p))\n+\ti := 0\n+\tfor a[i] != 0 {\n+\t\ti++\n+\t}\n+\treturn string(a[:i])\n+}\n+\n func init() {\n \timplemented = true\n }\n@@ -78,9 +89,9 @@ func lookup(uid int, username string, lookupByName bool) (*User, os.Error) {\n \tu := &User{\n \t\tUid:      int(pwd.Pw_uid),\n \t\tGid:      int(pwd.Pw_gid),\n-\t\tUsername: syscall.BytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_name))),\n-\t\tName:     syscall.BytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_gecos))),\n-\t\tHomeDir:  syscall.BytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_dir))),\n+\t\tUsername: bytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_name))),\n+\t\tName:     bytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_gecos))),\n+\t\tHomeDir:  bytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_dir))),\n \t}\n \t// The pw_gecos field isn't quite standardized.  Some docs\n \t// say: \"It is expected to be a comma separated list of"}, {"sha": "06a2953e7fed9f989f5077ee78331b620c63065f", "filename": "libgo/go/syscall/bpf_bsd.go", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd openbsd\n+\n+// Berkeley packet filter for BSD variants\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+func BpfStmt(code, k int) *BpfInsn {\n+\treturn &BpfInsn{Code: uint16(code), K: uint32(k)}\n+}\n+\n+func BpfJump(code, k, jt, jf int) *BpfInsn {\n+\treturn &BpfInsn{Code: uint16(code), Jt: uint8(jt), Jf: uint8(jf), K: uint32(k)}\n+}\n+\n+func BpfBuflen(fd int) (int, int) {\n+\tvar l int\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGBLEN, uintptr(unsafe.Pointer(&l)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn 0, e\n+\t}\n+\treturn l, 0\n+}\n+\n+func SetBpfBuflen(fd, l int) (int, int) {\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSBLEN, uintptr(unsafe.Pointer(&l)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn 0, e\n+\t}\n+\treturn l, 0\n+}\n+\n+func BpfDatalink(fd int) (int, int) {\n+\tvar t int\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGDLT, uintptr(unsafe.Pointer(&t)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn 0, e\n+\t}\n+\treturn t, 0\n+}\n+\n+func SetBpfDatalink(fd, t int) (int, int) {\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSDLT, uintptr(unsafe.Pointer(&t)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn 0, e\n+\t}\n+\treturn t, 0\n+}\n+\n+func SetBpfPromisc(fd, m int) int {\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCPROMISC, uintptr(unsafe.Pointer(&m)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\treturn 0\n+}\n+\n+func FlushBpf(fd int) int {\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCFLUSH, 0)\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\treturn 0\n+}\n+\n+type ivalue struct {\n+\tname  [IFNAMSIZ]byte\n+\tvalue int16\n+}\n+\n+func BpfInterface(fd int, name string) (string, int) {\n+\tvar iv ivalue\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGETIF, uintptr(unsafe.Pointer(&iv)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn \"\", e\n+\t}\n+\treturn name, 0\n+}\n+\n+func SetBpfInterface(fd int, name string) int {\n+\tvar iv ivalue\n+\tcopy(iv.name[:], []byte(name))\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSETIF, uintptr(unsafe.Pointer(&iv)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\treturn 0\n+}\n+\n+func BpfTimeout(fd int) (*Timeval, int) {\n+\tvar tv Timeval\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGRTIMEOUT, uintptr(unsafe.Pointer(&tv)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn nil, e\n+\t}\n+\treturn &tv, 0\n+}\n+\n+func SetBpfTimeout(fd int, tv *Timeval) int {\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSRTIMEOUT, uintptr(unsafe.Pointer(tv)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\treturn 0\n+}\n+\n+func BpfStats(fd int) (*BpfStat, int) {\n+\tvar s BpfStat\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGSTATS, uintptr(unsafe.Pointer(&s)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn nil, e\n+\t}\n+\treturn &s, 0\n+}\n+\n+func SetBpfImmediate(fd, m int) int {\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCIMMEDIATE, uintptr(unsafe.Pointer(&m)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\treturn 0\n+}\n+\n+func SetBpf(fd int, i []BpfInsn) int {\n+\tvar p BpfProgram\n+\tp.Len = uint32(len(i))\n+\tp.Insns = (*BpfInsn)(unsafe.Pointer(&i[0]))\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSETF, uintptr(unsafe.Pointer(&p)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\treturn 0\n+}\n+\n+func CheckBpfVersion(fd int) int {\n+\tvar v BpfVersion\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCVERSION, uintptr(unsafe.Pointer(&v)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\tif v.Major != BPF_MAJOR_VERSION || v.Minor != BPF_MINOR_VERSION {\n+\t\treturn EINVAL\n+\t}\n+\treturn 0\n+}\n+\n+func BpfHeadercmpl(fd int) (int, int) {\n+\tvar f int\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGHDRCMPLT, uintptr(unsafe.Pointer(&f)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn 0, e\n+\t}\n+\treturn f, 0\n+}\n+\n+func SetBpfHeadercmpl(fd, f int) int {\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSHDRCMPLT, uintptr(unsafe.Pointer(&f)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\treturn 0\n+}"}, {"sha": "854b5aaec28465054ba50c9acb3e52d96eca3232", "filename": "libgo/go/syscall/errno.c", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Ferrno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Ferrno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrno.c?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -9,8 +9,8 @@\n /* errno is typically a macro. These functions set \n    and get errno specific to the libc being used.  */\n \n-int GetErrno() asm (\"libgo_syscalls.syscall.GetErrno\");\n-void SetErrno(int) asm (\"libgo_syscalls.syscall.SetErrno\");\n+int GetErrno() asm (\"libgo_syscall.syscall.GetErrno\");\n+void SetErrno(int) asm (\"libgo_syscall.syscall.SetErrno\");\n \n int \n GetErrno()", "previous_filename": "libgo/syscalls/errno.c"}, {"sha": "d9f3fe82eb47101fc6cfe3e3bd67cb55156e7bf7", "filename": "libgo/go/syscall/errstr.go", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Ferrstr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Ferrstr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrstr.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -6,18 +6,21 @@\n \n package syscall\n \n-func Errstr(errno int) string {\n-\tfor len := Size_t(128); ; len *= 2 {\n+//sysnb\tstrerror_r(errnum int, buf []byte) (errno int)\n+//strerror_r(errnum int, buf *byte, buflen Size_t) int\n+\n+func Errstr(errnum int) string {\n+\tfor len := 128; ; len *= 2 {\n \t\tb := make([]byte, len)\n-\t\tr := libc_strerror_r(errno, &b[0], len)\n-\t\tif r >= 0 {\n+\t\terr := strerror_r(errnum, b)\n+\t\tif err == 0 {\n \t\t\ti := 0\n \t\t\tfor b[i] != 0 {\n \t\t\t\ti++\n \t\t\t}\n \t\t\treturn string(b[:i])\n \t\t}\n-\t\tif GetErrno() != ERANGE {\n+\t\tif err != ERANGE {\n \t\t\treturn \"Errstr failure\"\n \t\t}\n \t}", "previous_filename": "libgo/syscalls/errstr.go"}, {"sha": "00fca80fc142bcf0406431ea4a922c099bf65171", "filename": "libgo/go/syscall/errstr_linux.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Ferrstr_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Ferrstr_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrstr_linux.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,23 @@\n+// errstr_rtems.go -- RTEMS specific error strings.\n+\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+import \"unsafe\"\n+\n+//sysnb\tstrerror_r(errnum int, b []byte) (errstr *byte)\n+//strerror_r(errnum int, b *byte, len Size_t) *byte\n+\n+func Errstr(errnum int) string {\n+\ta := make([]byte, 128)\n+\tp := strerror_r(errnum, a)\n+\tb := (*[1000]byte)(unsafe.Pointer(p))\n+\ti := 0\n+\tfor b[i] != 0 {\n+\t\ti++\n+\t}\n+\treturn string(b[:i])\n+}"}, {"sha": "b331d0eb9657274dc401bc68c9e180ebc438b258", "filename": "libgo/go/syscall/errstr_nor.go", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Ferrstr_nor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Ferrstr_nor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrstr_nor.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -11,7 +11,8 @@ import (\n \t\"unsafe\"\n )\n \n-func libc_strerror(int) *byte __asm__ (\"strerror\")\n+//sysnb\tstrerror(errnum int) *byte\n+//strerror(errnum int) *byte\n \n var errstr_lock sync.Mutex\n ", "previous_filename": "libgo/syscalls/errstr_nor.go"}, {"sha": "ce5dabe1e3b212ffe33c3eb99b14522388175bb4", "filename": "libgo/go/syscall/exec_stubs.go", "status": "renamed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -1,5 +1,3 @@\n-// exec_stubs.go -- fork/exec stubs.\n-\n // Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n@@ -12,10 +10,6 @@ func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []int)\n \treturn -1, ENOSYS;\n }\n \n-func PtraceForkExec(argv0 string, argv []string, envv []string, dir string, fd []int) (pid int, err int) {\n-\treturn -1, ENOSYS;\n-}\n-\n func Exec(argv0 string, argv []string, envv []string) (err int) {\n \treturn ENOSYS;\n }", "previous_filename": "libgo/syscalls/exec_stubs.go"}, {"sha": "765f4d12fd5120779cc94f10a593020a5c1736f9", "filename": "libgo/go/syscall/exec_unix.go", "status": "renamed", "additions": 180, "deletions": 72, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -1,110 +1,224 @@\n-// exec.go -- fork/exec syscall support.\n-\n // Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin freebsd linux openbsd\n+\n // Fork, exec, wait, etc.\n \n package syscall\n \n-import \"unsafe\"\n-\n-func libc_fcntl(fd int, cmd int, arg int) int __asm__ (\"fcntl\")\n-func libc_fork() Pid_t __asm__ (\"fork\")\n-func libc_setsid() Pid_t __asm__ (\"setsid\")\n-func libc_setpgid(Pid_t, Pid_t) int __asm__ (\"setpgid\")\n-func libc_chroot(path *byte) int __asm__ (\"chroot\")\n-func libc_setuid(Uid_t) int __asm__ (\"setuid\")\n-func libc_setgid(Gid_t) int __asm__ (\"setgid\")\n-func libc_setgroups(Size_t, *Gid_t) int __asm__ (\"setgroups\")\n-func libc_chdir(name *byte) int __asm__ (\"chdir\")\n-func libc_dup2(int, int) int __asm__ (\"dup2\")\n-func libc_ioctl(int, int) int __asm__ (\"ioctl\")\n-func libc_execve(*byte, **byte, **byte) int __asm__ (\"execve\")\n-func libc_sysexit(int) __asm__ (\"_exit\")\n+import (\n+\t\"sync\"\n+\t\"unsafe\"\n+)\n+\n+//sysnb\traw_fork() (pid Pid_t, errno int)\n+//fork() Pid_t\n+\n+//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (errno int)\n+//ptrace(request int, pid Pid_t, addr *byte, data *byte) _C_long\n+\n+//sysnb raw_setsid() (errno int)\n+//setsid() Pid_t\n+\n+//sysnb\traw_chroot(path *byte) (errno int)\n+//chroot(path *byte) int\n+\n+//sysnb\traw_chdir(path *byte) (errno int)\n+//chdir(path *byte) int\n+\n+//sysnb\traw_fcntl(fd int, cmd int, arg int) (val int, errno int)\n+//fcntl(fd int, cmd int, arg int) int\n+\n+//sysnb\traw_close(fd int) (errno int)\n+//close(fd int) int\n+\n+//sysnb\traw_ioctl(fd int, cmd int, val int) (rval int, errno int)\n+//ioctl(fd int, cmd int, val int) int\n+\n+//sysnb\traw_execve(argv0 *byte, argv **byte, envv **byte) (errno int)\n+//execve(argv0 *byte, argv **byte, envv **byte) int\n+\n+//sysnb\traw_read(fd int, p *byte, np int) (n int, errno int)\n+//read(fd int, buf *byte, count Size_t) Ssize_t\n+\n+//sysnb\traw_write(fd int, buf *byte, count int) int\n+//write(fd int, buf *byte, count Size_t) Ssize_t\n+\n+//sysnb\traw_exit(status int)\n+//_exit(status int)\n+\n+// Lock synchronizing creation of new file descriptors with fork.\n+//\n+// We want the child in a fork/exec sequence to inherit only the\n+// file descriptors we intend.  To do that, we mark all file\n+// descriptors close-on-exec and then, in the child, explicitly\n+// unmark the ones we want the exec'ed program to keep.\n+// Unix doesn't make this easy: there is, in general, no way to\n+// allocate a new file descriptor close-on-exec.  Instead you\n+// have to allocate the descriptor and then mark it close-on-exec.\n+// If a fork happens between those two events, the child's exec\n+// will inherit an unwanted file descriptor.\n+//\n+// This lock solves that race: the create new fd/mark close-on-exec\n+// operation is done holding ForkLock for reading, and the fork itself\n+// is done holding ForkLock for writing.  At least, that's the idea.\n+// There are some complications.\n+//\n+// Some system calls that create new file descriptors can block\n+// for arbitrarily long times: open on a hung NFS server or named\n+// pipe, accept on a socket, and so on.  We can't reasonably grab\n+// the lock across those operations.\n+//\n+// It is worse to inherit some file descriptors than others.\n+// If a non-malicious child accidentally inherits an open ordinary file,\n+// that's not a big deal.  On the other hand, if a long-lived child\n+// accidentally inherits the write end of a pipe, then the reader\n+// of that pipe will not see EOF until that child exits, potentially\n+// causing the parent program to hang.  This is a common problem\n+// in threaded C programs that use popen.\n+//\n+// Luckily, the file descriptors that are most important not to\n+// inherit are not the ones that can take an arbitrarily long time\n+// to create: pipe returns instantly, and the net package uses\n+// non-blocking I/O to accept on a listening socket.\n+// The rules for which file descriptor-creating operations use the\n+// ForkLock are as follows:\n+//\n+// 1) Pipe.    Does not block.  Use the ForkLock.\n+// 2) Socket.  Does not block.  Use the ForkLock.\n+// 3) Accept.  If using non-blocking mode, use the ForkLock.\n+//             Otherwise, live with the race.\n+// 4) Open.    Can block.  Use O_CLOEXEC if available (Linux).\n+//             Otherwise, live with the race.\n+// 5) Dup.     Does not block.  Use the ForkLock.\n+//             On Linux, could use fcntl F_DUPFD_CLOEXEC\n+//             instead of the ForkLock, but only for dup(fd, -1).\n+\n+var ForkLock sync.RWMutex\n+\n+// Convert array of string to array\n+// of NUL-terminated byte pointer.\n+func StringSlicePtr(ss []string) []*byte {\n+\tbb := make([]*byte, len(ss)+1)\n+\tfor i := 0; i < len(ss); i++ {\n+\t\tbb[i] = StringBytePtr(ss[i])\n+\t}\n+\tbb[len(ss)] = nil\n+\treturn bb\n+}\n+\n+func CloseOnExec(fd int) { fcntl(fd, F_SETFD, FD_CLOEXEC) }\n+\n+func SetNonblock(fd int, nonblocking bool) (errno int) {\n+\tflag, err := fcntl(fd, F_GETFL, 0)\n+\tif err != 0 {\n+\t\treturn err\n+\t}\n+\tif nonblocking {\n+\t\tflag |= O_NONBLOCK\n+\t} else {\n+\t\tflag &= ^O_NONBLOCK\n+\t}\n+\t_, err = fcntl(fd, F_SETFL, flag)\n+\treturn err\n+}\n \n // Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\n // If a dup or exec fails, write the errno int to pipe.\n // (Pipe is close-on-exec so if exec succeeds, it will be closed.)\n // In the child, this function must not acquire any locks, because\n // they might have been locked at the time of the fork.  This means\n // no rescheduling, no malloc calls, and no new stack segments.\n+// The calls to RawSyscall are okay because they are assembly\n+// functions that do not grow the stack.\n func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err int) {\n \t// Declare all variables at top in case any\n \t// declarations require heap allocation (e.g., err1).\n-\tvar r1, r2, err1 uintptr\n+\tvar r1 Pid_t\n+\tvar err1 int\n \tvar nextfd int\n \tvar i int\n \n \t// guard against side effects of shuffling fds below.\n \tfd := append([]int(nil), attr.Files...)\n \n-\tdarwin := OS == \"darwin\"\n-\n \t// About to call fork.\n \t// No more allocation or calls of non-assembly functions.\n-\tchild := libc_fork()\n-\tif child == -1 {\n-\t\treturn 0, GetErrno()\n+\tr1, err1 = raw_fork()\n+\tif err1 != 0 {\n+\t\treturn 0, int(err1)\n \t}\n \n-\tif child != 0 {\n+\tif r1 != 0 {\n \t\t// parent; return PID\n-\t\treturn int(child), 0\n+\t\treturn int(r1), 0\n \t}\n \n \t// Fork succeeded, now in child.\n \n \t// Enable tracing if requested.\n \tif sys.Ptrace {\n-\t\tif libc_ptrace(_PTRACE_TRACEME, 0, 0, nil) < 0 {\n+\t\terr1 = raw_ptrace(_PTRACE_TRACEME, 0, nil, nil)\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n \n \t// Session ID\n \tif sys.Setsid {\n-\t\tif libc_setsid() == Pid_t(-1) {\n+\t\terr1 = raw_setsid()\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n \n \t// Set process group\n \tif sys.Setpgid {\n-\t\tif libc_setpgid(0, 0) < 0 {\n+\t\terr1 = Setpgid(0, 0)\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n \n \t// Chroot\n \tif chroot != nil {\n-\t\tif libc_chroot(chroot) < 0 {\n+\t\terr1 = raw_chroot(chroot)\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n \n \t// User and groups\n \tif cred := sys.Credential; cred != nil {\n-\t\tngroups := uintptr(len(cred.Groups))\n-\t\tvar groups *Gid_t\n-\t\tif ngroups > 0 {\n-\t\t\tgroups = (*Gid_t)(unsafe.Pointer(&cred.Groups[0]))\n+\t\tngroups := len(cred.Groups)\n+\t\tif ngroups == 0 {\n+\t\t\terr1 = setgroups(0, nil)\n+\t\t} else {\n+\t\t\tgroups := make([]Gid_t, ngroups)\n+\t\t\tfor i, v := range cred.Groups {\n+\t\t\t\tgroups[i] = Gid_t(v)\n+\t\t\t}\n+\t\t\terr1 = setgroups(ngroups, &groups[0])\n \t\t}\n-\t\tif libc_setgroups(Size_t(ngroups), groups) < 0 {\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n-\t\tif libc_setgid(Gid_t(cred.Gid)) < 0 {\n+\t\terr1 = Setgid(int(cred.Gid))\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n-\t\tif libc_setuid(Uid_t(cred.Uid)) < 0 {\n+\t\terr1 = Setuid(int(cred.Uid))\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n \n \t// Chdir\n \tif dir != nil {\n-\t\tif libc_chdir(dir) < 0 {\n+\t\terr1 = raw_chdir(dir)\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n@@ -113,21 +227,21 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t// so that pass 2 won't stomp on an fd it needs later.\n \tnextfd = int(len(fd))\n \tif pipe < nextfd {\n-\t\tr := libc_dup2(pipe, nextfd)\n-\t\tif r == -1 {\n+\t\t_, err1 = Dup2(pipe, nextfd)\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n-\t\tlibc_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n+\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n \t\tpipe = nextfd\n \t\tnextfd++\n \t}\n \tfor i = 0; i < len(fd); i++ {\n \t\tif fd[i] >= 0 && fd[i] < int(i) {\n-\t\t\tr := libc_dup2(fd[i], nextfd)\n-\t\t\tif r == -1 {\n+\t\t\t_, err1 = Dup2(fd[i], nextfd)\n+\t\t\tif err1 != 0 {\n \t\t\t\tgoto childerror\n \t\t\t}\n-\t\t\tlibc_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n+\t\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n \t\t\tfd[i] = nextfd\n \t\t\tnextfd++\n \t\t\tif nextfd == pipe { // don't stomp on pipe\n@@ -139,22 +253,22 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t// Pass 2: dup fd[i] down onto i.\n \tfor i = 0; i < len(fd); i++ {\n \t\tif fd[i] == -1 {\n-\t\t\tlibc_close(i)\n+\t\t\traw_close(i)\n \t\t\tcontinue\n \t\t}\n \t\tif fd[i] == int(i) {\n-\t\t\t// dup2(i, i) won't clear close-on-exec flag on Linux,\n+\t\t\t// Dup2(i, i) won't clear close-on-exec flag on Linux,\n \t\t\t// probably not elsewhere either.\n-\t\t\tr := libc_fcntl(fd[i], F_SETFD, 0)\n-\t\t\tif r != 0 {\n+\t\t\t_, err1 = raw_fcntl(fd[i], F_SETFD, 0)\n+\t\t\tif err1 != 0 {\n \t\t\t\tgoto childerror\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\t// The new fd is created NOT close-on-exec,\n \t\t// which is exactly what we want.\n-\t\tr := libc_dup2(fd[i], i)\n-\t\tif r == -1 {\n+\t\t_, err1 = Dup2(fd[i], i)\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n@@ -164,33 +278,33 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t// Programs that know they inherit fds >= 3 will need\n \t// to set them close-on-exec.\n \tfor i = len(fd); i < 3; i++ {\n-\t\tlibc_close(i)\n+\t\traw_close(i)\n \t}\n \n \t// Detach fd 0 from tty\n \tif sys.Noctty {\n-\t\tif libc_ioctl(0, TIOCNOTTY) < 0 {\n+\t\t_, err1 = raw_ioctl(0, TIOCNOTTY, 0)\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n \n \t// Make fd 0 the tty\n \tif sys.Setctty {\n-\t\tif libc_ioctl(0, TIOCSCTTY) < 0 {\n+\t\t_, err1 = raw_ioctl(0, TIOCSCTTY, 0)\n+\t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n \n \t// Time to exec.\n-\tlibc_execve(argv0, &argv[0], &envv[0])\n+\terr1 = raw_execve(argv0, &argv[0], &envv[0])\n \n childerror:\n \t// send error code on pipe\n-\tvar e uintptr = uintptr(GetErrno())\n-\tlibc_write(pipe, (*byte)(unsafe.Pointer(&e)),\n-\t\t   Size_t(unsafe.Sizeof(err1)))\n+\traw_write(pipe, (*byte)(unsafe.Pointer(&err1)), int(unsafe.Sizeof(err1)))\n \tfor {\n-\t\tlibc_sysexit(253)\n+\t\traw_exit(253)\n \t}\n \n \t// Calling panic is not actually safe,\n@@ -231,8 +345,7 @@ var zeroSysProcAttr SysProcAttr\n \n func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \tvar p [2]int\n-\tvar n Ssize_t\n-\tvar r1 int\n+\tvar n int\n \tvar err1 uintptr\n \tvar wstatus WaitStatus\n \n@@ -249,8 +362,8 @@ func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \n \t// Convert args to C form.\n \targv0p := StringBytePtr(argv0)\n-\targvp := StringArrayPtr(argv)\n-\tenvvp := StringArrayPtr(attr.Env)\n+\targvp := StringSlicePtr(argv)\n+\tenvvp := StringSlicePtr(attr.Env)\n \n \tif OS == \"freebsd\" && len(argv[0]) > len(argv0) {\n \t\targvp[0] = argv0p\n@@ -290,15 +403,10 @@ func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \n \t// Read child error status from pipe.\n \tClose(p[1])\n-\tn = libc_read(p[0], (*byte)(unsafe.Pointer(&err1)),\n-\t\t      Size_t(unsafe.Sizeof(err1)))\n-\terr = 0\n-\tif n < 0 {\n-\t\terr = GetErrno()\n-\t}\n+\tn, err = raw_read(p[0], (*byte)(unsafe.Pointer(&err1)), int(unsafe.Sizeof(err1)))\n \tClose(p[0])\n \tif err != 0 || n != 0 {\n-\t\tif int(n) == unsafe.Sizeof(err1) {\n+\t\tif n == int(unsafe.Sizeof(err1)) {\n \t\t\terr = int(err1)\n \t\t}\n \t\tif err == 0 {\n@@ -339,8 +447,8 @@ func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int,\n \n // Ordinary exec.\n func Exec(argv0 string, argv []string, envv []string) (err int) {\n-\targv_arg := StringArrayPtr(argv)\n-\tenvv_arg := StringArrayPtr(envv)\n-\tlibc_execve(StringBytePtr(argv0), &argv_arg[0], &envv_arg[0])\n-\treturn GetErrno()\n+\terr1 := raw_execve(StringBytePtr(argv0),\n+\t\t&StringSlicePtr(argv)[0],\n+\t\t&StringSlicePtr(envv)[0])\n+\treturn int(err1)\n }", "previous_filename": "libgo/syscalls/exec.go"}, {"sha": "e8b540ad1603e6e247adf1aecfd3e59edc967dd7", "filename": "libgo/go/syscall/exec_windows.go", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_windows.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,327 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Fork, exec, wait, etc.\n+\n+package syscall\n+\n+import (\n+\t\"sync\"\n+\t\"unsafe\"\n+\t\"utf16\"\n+)\n+\n+var ForkLock sync.RWMutex\n+\n+// EscapeArg rewrites command line argument s as prescribed\n+// in http://msdn.microsoft.com/en-us/library/ms880421.\n+// This function returns \"\" (2 double quotes) if s is empty.\n+// Alternatively, these transformations are done:\n+// - every back slash (\\) is doubled, but only if immediately\n+//   followed by double quote (\");\n+// - every double quote (\") is escaped by back slash (\\);\n+// - finally, s is wrapped with double quotes (arg -> \"arg\"),\n+//   but only if there is space or tab inside s.\n+func EscapeArg(s string) string {\n+\tif len(s) == 0 {\n+\t\treturn \"\\\"\\\"\"\n+\t}\n+\tn := len(s)\n+\thasSpace := false\n+\tfor i := 0; i < len(s); i++ {\n+\t\tswitch s[i] {\n+\t\tcase '\"', '\\\\':\n+\t\t\tn++\n+\t\tcase ' ', '\\t':\n+\t\t\thasSpace = true\n+\t\t}\n+\t}\n+\tif hasSpace {\n+\t\tn += 2\n+\t}\n+\tif n == len(s) {\n+\t\treturn s\n+\t}\n+\n+\tqs := make([]byte, n)\n+\tj := 0\n+\tif hasSpace {\n+\t\tqs[j] = '\"'\n+\t\tj++\n+\t}\n+\tslashes := 0\n+\tfor i := 0; i < len(s); i++ {\n+\t\tswitch s[i] {\n+\t\tdefault:\n+\t\t\tslashes = 0\n+\t\t\tqs[j] = s[i]\n+\t\tcase '\\\\':\n+\t\t\tslashes++\n+\t\t\tqs[j] = s[i]\n+\t\tcase '\"':\n+\t\t\tfor ; slashes > 0; slashes-- {\n+\t\t\t\tqs[j] = '\\\\'\n+\t\t\t\tj++\n+\t\t\t}\n+\t\t\tqs[j] = '\\\\'\n+\t\t\tj++\n+\t\t\tqs[j] = s[i]\n+\t\t}\n+\t\tj++\n+\t}\n+\tif hasSpace {\n+\t\tfor ; slashes > 0; slashes-- {\n+\t\t\tqs[j] = '\\\\'\n+\t\t\tj++\n+\t\t}\n+\t\tqs[j] = '\"'\n+\t\tj++\n+\t}\n+\treturn string(qs[:j])\n+}\n+\n+// makeCmdLine builds a command line out of args by escaping \"special\"\n+// characters and joining the arguments with spaces.\n+func makeCmdLine(args []string) string {\n+\tvar s string\n+\tfor _, v := range args {\n+\t\tif s != \"\" {\n+\t\t\ts += \" \"\n+\t\t}\n+\t\ts += EscapeArg(v)\n+\t}\n+\treturn s\n+}\n+\n+// createEnvBlock converts an array of environment strings into\n+// the representation required by CreateProcess: a sequence of NUL\n+// terminated strings followed by a nil.\n+// Last bytes are two UCS-2 NULs, or four NUL bytes.\n+func createEnvBlock(envv []string) *uint16 {\n+\tif len(envv) == 0 {\n+\t\treturn &utf16.Encode([]int(\"\\x00\\x00\"))[0]\n+\t}\n+\tlength := 0\n+\tfor _, s := range envv {\n+\t\tlength += len(s) + 1\n+\t}\n+\tlength += 1\n+\n+\tb := make([]byte, length)\n+\ti := 0\n+\tfor _, s := range envv {\n+\t\tl := len(s)\n+\t\tcopy(b[i:i+l], []byte(s))\n+\t\tcopy(b[i+l:i+l+1], []byte{0})\n+\t\ti = i + l + 1\n+\t}\n+\tcopy(b[i:i+1], []byte{0})\n+\n+\treturn &utf16.Encode([]int(string(b)))[0]\n+}\n+\n+func CloseOnExec(fd Handle) {\n+\tSetHandleInformation(Handle(fd), HANDLE_FLAG_INHERIT, 0)\n+}\n+\n+func SetNonblock(fd Handle, nonblocking bool) (errno int) {\n+\treturn 0\n+}\n+\n+// getFullPath retrieves the full path of the specified file.\n+// Just a wrapper for Windows GetFullPathName api.\n+func getFullPath(name string) (path string, err int) {\n+\tp := StringToUTF16Ptr(name)\n+\tbuf := make([]uint16, 100)\n+\tn, err := GetFullPathName(p, uint32(len(buf)), &buf[0], nil)\n+\tif err != 0 {\n+\t\treturn \"\", err\n+\t}\n+\tif n > uint32(len(buf)) {\n+\t\t// Windows is asking for bigger buffer.\n+\t\tbuf = make([]uint16, n)\n+\t\tn, err = GetFullPathName(p, uint32(len(buf)), &buf[0], nil)\n+\t\tif err != 0 {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif n > uint32(len(buf)) {\n+\t\t\treturn \"\", EINVAL\n+\t\t}\n+\t}\n+\treturn UTF16ToString(buf[:n]), 0\n+}\n+\n+func isSlash(c uint8) bool {\n+\treturn c == '\\\\' || c == '/'\n+}\n+\n+func normalizeDir(dir string) (name string, err int) {\n+\tndir, err := getFullPath(dir)\n+\tif err != 0 {\n+\t\treturn \"\", err\n+\t}\n+\tif len(ndir) > 2 && isSlash(ndir[0]) && isSlash(ndir[1]) {\n+\t\t// dir cannot have \\\\server\\share\\path form\n+\t\treturn \"\", EINVAL\n+\t}\n+\treturn ndir, 0\n+}\n+\n+func volToUpper(ch int) int {\n+\tif 'a' <= ch && ch <= 'z' {\n+\t\tch += 'A' - 'a'\n+\t}\n+\treturn ch\n+}\n+\n+func joinExeDirAndFName(dir, p string) (name string, err int) {\n+\tif len(p) == 0 {\n+\t\treturn \"\", EINVAL\n+\t}\n+\tif len(p) > 2 && isSlash(p[0]) && isSlash(p[1]) {\n+\t\t// \\\\server\\share\\path form\n+\t\treturn p, 0\n+\t}\n+\tif len(p) > 1 && p[1] == ':' {\n+\t\t// has drive letter\n+\t\tif len(p) == 2 {\n+\t\t\treturn \"\", EINVAL\n+\t\t}\n+\t\tif isSlash(p[2]) {\n+\t\t\treturn p, 0\n+\t\t} else {\n+\t\t\td, err := normalizeDir(dir)\n+\t\t\tif err != 0 {\n+\t\t\t\treturn \"\", err\n+\t\t\t}\n+\t\t\tif volToUpper(int(p[0])) == volToUpper(int(d[0])) {\n+\t\t\t\treturn getFullPath(d + \"\\\\\" + p[2:])\n+\t\t\t} else {\n+\t\t\t\treturn getFullPath(p)\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\t// no drive letter\n+\t\td, err := normalizeDir(dir)\n+\t\tif err != 0 {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif isSlash(p[0]) {\n+\t\t\treturn getFullPath(d[:2] + p)\n+\t\t} else {\n+\t\t\treturn getFullPath(d + \"\\\\\" + p)\n+\t\t}\n+\t}\n+\t// we shouldn't be here\n+\treturn \"\", EINVAL\n+}\n+\n+type ProcAttr struct {\n+\tDir   string\n+\tEnv   []string\n+\tFiles []Handle\n+\tSys   *SysProcAttr\n+}\n+\n+type SysProcAttr struct {\n+\tHideWindow bool\n+\tCmdLine    string // used if non-empty, else the windows command line is built by escaping the arguments passed to StartProcess\n+}\n+\n+var zeroProcAttr ProcAttr\n+var zeroSysProcAttr SysProcAttr\n+\n+func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int, err int) {\n+\tif len(argv0) == 0 {\n+\t\treturn 0, 0, EWINDOWS\n+\t}\n+\tif attr == nil {\n+\t\tattr = &zeroProcAttr\n+\t}\n+\tsys := attr.Sys\n+\tif sys == nil {\n+\t\tsys = &zeroSysProcAttr\n+\t}\n+\n+\tif len(attr.Files) > 3 {\n+\t\treturn 0, 0, EWINDOWS\n+\t}\n+\n+\tif len(attr.Dir) != 0 {\n+\t\t// StartProcess assumes that argv0 is relative to attr.Dir,\n+\t\t// because it implies Chdir(attr.Dir) before executing argv0.\n+\t\t// Windows CreateProcess assumes the opposite: it looks for\n+\t\t// argv0 relative to the current directory, and, only once the new\n+\t\t// process is started, it does Chdir(attr.Dir). We are adjusting\n+\t\t// for that difference here by making argv0 absolute.\n+\t\tvar err int\n+\t\targv0, err = joinExeDirAndFName(attr.Dir, argv0)\n+\t\tif err != 0 {\n+\t\t\treturn 0, 0, err\n+\t\t}\n+\t}\n+\targv0p := StringToUTF16Ptr(argv0)\n+\n+\tvar cmdline string\n+\t// Windows CreateProcess takes the command line as a single string:\n+\t// use attr.CmdLine if set, else build the command line by escaping\n+\t// and joining each argument with spaces\n+\tif sys.CmdLine != \"\" {\n+\t\tcmdline = sys.CmdLine\n+\t} else {\n+\t\tcmdline = makeCmdLine(argv)\n+\t}\n+\n+\tvar argvp *uint16\n+\tif len(cmdline) != 0 {\n+\t\targvp = StringToUTF16Ptr(cmdline)\n+\t}\n+\n+\tvar dirp *uint16\n+\tif len(attr.Dir) != 0 {\n+\t\tdirp = StringToUTF16Ptr(attr.Dir)\n+\t}\n+\n+\t// Acquire the fork lock so that no other threads\n+\t// create new fds that are not yet close-on-exec\n+\t// before we fork.\n+\tForkLock.Lock()\n+\tdefer ForkLock.Unlock()\n+\n+\tp, _ := GetCurrentProcess()\n+\tfd := make([]Handle, len(attr.Files))\n+\tfor i := range attr.Files {\n+\t\tif attr.Files[i] > 0 {\n+\t\t\terr := DuplicateHandle(p, Handle(attr.Files[i]), p, &fd[i], 0, true, DUPLICATE_SAME_ACCESS)\n+\t\t\tif err != 0 {\n+\t\t\t\treturn 0, 0, err\n+\t\t\t}\n+\t\t\tdefer CloseHandle(Handle(fd[i]))\n+\t\t}\n+\t}\n+\tsi := new(StartupInfo)\n+\tsi.Cb = uint32(unsafe.Sizeof(*si))\n+\tsi.Flags = STARTF_USESTDHANDLES\n+\tif sys.HideWindow {\n+\t\tsi.Flags |= STARTF_USESHOWWINDOW\n+\t\tsi.ShowWindow = SW_HIDE\n+\t}\n+\tsi.StdInput = fd[0]\n+\tsi.StdOutput = fd[1]\n+\tsi.StdErr = fd[2]\n+\n+\tpi := new(ProcessInformation)\n+\n+\terr = CreateProcess(argv0p, argvp, nil, nil, true, CREATE_UNICODE_ENVIRONMENT, createEnvBlock(attr.Env), dirp, si, pi)\n+\tif err != 0 {\n+\t\treturn 0, 0, err\n+\t}\n+\tdefer CloseHandle(Handle(pi.Thread))\n+\n+\treturn int(pi.ProcessId), int(pi.Process), 0\n+}\n+\n+func Exec(argv0 string, argv []string, envv []string) (err int) {\n+\treturn EWINDOWS\n+}"}, {"sha": "d3e1d3a90c5a4e45098aa6393fe593455cf6e8d8", "filename": "libgo/go/syscall/libcall_linux.go", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,319 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// GNU/Linux library calls.\n+\n+package syscall\n+\n+import \"unsafe\"\n+\n+//sys\tOpenat(dirfd int, path string, flags int, mode uint32) (fd int, errno int)\n+//openat(dirfd int, path *byte, flags int, mode Mode_t) int\n+\n+//sys\tfutimesat(dirfd int, path *byte, times *[2]Timeval) (errno int)\n+//futimesat(dirfd int, path *byte, times *[2]Timeval) int\n+func Futimesat(dirfd int, path string, tv []Timeval) (errno int) {\n+\tif len(tv) != 2 {\n+\t\treturn EINVAL\n+\t}\n+\treturn futimesat(dirfd, StringBytePtr(path), (*[2]Timeval)(unsafe.Pointer(&tv[0])))\n+}\n+\n+func Futimes(fd int, tv []Timeval) (errno int) {\n+\t// Believe it or not, this is the best we can do on Linux\n+\t// (and is what glibc does).\n+\treturn Utimes(\"/proc/self/fd/\"+itoa(fd), tv)\n+}\n+\n+//sys\tptrace(request int, pid int, addr uintptr, data uintptr) (errno int)\n+//ptrace(request int, pid Pid_t, addr *byte, data *byte) _C_long\n+\n+func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno int) {\n+\t// The peek requests are machine-size oriented, so we wrap it\n+\t// to retrieve arbitrary-length data.\n+\n+\t// The ptrace syscall differs from glibc's ptrace.\n+\t// Peeks returns the word in *data, not as the return value.\n+\n+\tvar buf [sizeofPtr]byte\n+\n+\t// Leading edge.  PEEKTEXT/PEEKDATA don't require aligned\n+\t// access (PEEKUSER warns that it might), but if we don't\n+\t// align our reads, we might straddle an unmapped page\n+\t// boundary and not get the bytes leading up to the page\n+\t// boundary.\n+\tn := 0\n+\tif addr%sizeofPtr != 0 {\n+\t\terrno = ptrace(req, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))\n+\t\tif errno != 0 {\n+\t\t\treturn 0, errno\n+\t\t}\n+\t\tn += copy(out, buf[addr%sizeofPtr:])\n+\t\tout = out[n:]\n+\t}\n+\n+\t// Remainder.\n+\tfor len(out) > 0 {\n+\t\t// We use an internal buffer to gaurantee alignment.\n+\t\t// It's not documented if this is necessary, but we're paranoid.\n+\t\terrno = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))\n+\t\tif errno != 0 {\n+\t\t\treturn n, errno\n+\t\t}\n+\t\tcopied := copy(out, buf[0:])\n+\t\tn += copied\n+\t\tout = out[copied:]\n+\t}\n+\n+\treturn n, 0\n+}\n+\n+func PtracePeekText(pid int, addr uintptr, out []byte) (count int, errno int) {\n+\treturn ptracePeek(PTRACE_PEEKTEXT, pid, addr, out)\n+}\n+\n+func PtracePeekData(pid int, addr uintptr, out []byte) (count int, errno int) {\n+\treturn ptracePeek(PTRACE_PEEKDATA, pid, addr, out)\n+}\n+\n+func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (count int, errno int) {\n+\t// As for ptracePeek, we need to align our accesses to deal\n+\t// with the possibility of straddling an invalid page.\n+\n+\t// Leading edge.\n+\tn := 0\n+\tif addr%sizeofPtr != 0 {\n+\t\tvar buf [sizeofPtr]byte\n+\t\terrno = ptrace(peekReq, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))\n+\t\tif errno != 0 {\n+\t\t\treturn 0, errno\n+\t\t}\n+\t\tn += copy(buf[addr%sizeofPtr:], data)\n+\t\tword := *((*uintptr)(unsafe.Pointer(&buf[0])))\n+\t\terrno = ptrace(pokeReq, pid, addr-addr%sizeofPtr, word)\n+\t\tif errno != 0 {\n+\t\t\treturn 0, errno\n+\t\t}\n+\t\tdata = data[n:]\n+\t}\n+\n+\t// Interior.\n+\tfor len(data) > int(sizeofPtr) {\n+\t\tword := *((*uintptr)(unsafe.Pointer(&data[0])))\n+\t\terrno = ptrace(pokeReq, pid, addr+uintptr(n), word)\n+\t\tif errno != 0 {\n+\t\t\treturn n, errno\n+\t\t}\n+\t\tn += int(sizeofPtr)\n+\t\tdata = data[sizeofPtr:]\n+\t}\n+\n+\t// Trailing edge.\n+\tif len(data) > 0 {\n+\t\tvar buf [sizeofPtr]byte\n+\t\terrno = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))\n+\t\tif errno != 0 {\n+\t\t\treturn n, errno\n+\t\t}\n+\t\tcopy(buf[0:], data)\n+\t\tword := *((*uintptr)(unsafe.Pointer(&buf[0])))\n+\t\terrno = ptrace(pokeReq, pid, addr+uintptr(n), word)\n+\t\tif errno != 0 {\n+\t\t\treturn n, errno\n+\t\t}\n+\t\tn += len(data)\n+\t}\n+\n+\treturn n, 0\n+}\n+\n+func PtracePokeText(pid int, addr uintptr, data []byte) (count int, errno int) {\n+\treturn ptracePoke(PTRACE_POKETEXT, PTRACE_PEEKTEXT, pid, addr, data)\n+}\n+\n+func PtracePokeData(pid int, addr uintptr, data []byte) (count int, errno int) {\n+\treturn ptracePoke(PTRACE_POKEDATA, PTRACE_PEEKDATA, pid, addr, data)\n+}\n+\n+func PtraceGetRegs(pid int, regsout *PtraceRegs) (errno int) {\n+\treturn ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))\n+}\n+\n+func PtraceSetRegs(pid int, regs *PtraceRegs) (errno int) {\n+\treturn ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))\n+}\n+\n+func PtraceSetOptions(pid int, options int) (errno int) {\n+\treturn ptrace(PTRACE_SETOPTIONS, pid, 0, uintptr(options))\n+}\n+\n+func PtraceGetEventMsg(pid int) (msg uint, errno int) {\n+\tvar data _C_long\n+\terrno = ptrace(PTRACE_GETEVENTMSG, pid, 0, uintptr(unsafe.Pointer(&data)))\n+\tmsg = uint(data)\n+\treturn\n+}\n+\n+func PtraceCont(pid int, signal int) (errno int) {\n+\treturn ptrace(PTRACE_CONT, pid, 0, uintptr(signal))\n+}\n+\n+func PtraceSingleStep(pid int) (errno int) { return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) }\n+\n+func PtraceAttach(pid int) (errno int) { return ptrace(PTRACE_ATTACH, pid, 0, 0) }\n+\n+func PtraceDetach(pid int) (errno int) { return ptrace(PTRACE_DETACH, pid, 0, 0) }\n+\n+// FIXME: mksysinfo needs to produce LINUX_REBOOT_MAGIC[12].\n+\n+// //sys\treboot(magic1 uint, magic2 uint, cmd int, arg string) (errno int)\n+// //reboot(magic1 uint, magic2 uint, cmd int, arg *byte) int\n+// func Reboot(cmd int) (errno int) {\n+// \treturn reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd, \"\")\n+// }\n+\n+//sys\tAcct(path string) (errno int)\n+//acct(path *byte) int\n+\n+// FIXME: mksysinfo Timex\n+// //sys\tAdjtimex(buf *Timex) (state int, errno int)\n+// //adjtimex(buf *Timex) int\n+\n+//sys\tFaccessat(dirfd int, path string, mode uint32, flags int) (errno int)\n+//faccessat(dirfd int, pathname *byte, mode int, flags int) int\n+\n+//sys\tFallocate(fd int, mode uint32, off int64, len int64) (errno int)\n+//fallocate(fd int, mode int, offset Offset_t, len Offset_t) int\n+\n+//sys\tFchmodat(dirfd int, path string, mode uint32, flags int) (errno int)\n+//fchmodat(dirfd int, pathname *byte, mode Mode_t, flags int) int\n+\n+//sys\tFchownat(dirfd int, path string, uid int, gid int, flags int) (errno int)\n+//fchownat(dirfd int, path *byte, owner Uid_t, group Gid_t, flags int) int\n+\n+// FIXME: mksysinfo statfs\n+// //sys\tFstatfs(fd int, buf *Statfs_t) (errno int)\n+// //fstatfs(fd int, buf *Statfs_t) int\n+\n+//sys\tIoperm(from int, num int, on int) (errno int)\n+//ioperm(from _C_long, num _C_long, on int) int\n+\n+//sys\tIopl(level int) (errno int)\n+//iopl(level int) int\n+\n+// FIXME: mksysinfo linux_dirent\n+//    Or just abandon this function.\n+// //sys\tGetdents(fd int, buf []byte) (n int, errno int)\n+// //getdents64(fd int, buf *byte, count uint)\n+\n+//sys\tInotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, errno int)\n+//inotify_add_watch(fd int, pathname *byte, mask uint32) int\n+\n+//sysnb\tInotifyInit() (fd int, errno int)\n+//inotify_init() int\n+\n+//sysnb\tInotifyInit1(flags int) (fd int, errno int)\n+//inotify_init1(flags int) int\n+\n+//sysnb\tInotifyRmWatch(fd int, watchdesc uint32) (success int, errno int)\n+//inotify_rm_watch(fd int, wd uint32) int\n+\n+//sys\tKlogctl(typ int, buf []byte) (n int, errno int)\n+//klogctl(typ int, bufp *byte, len int) int\n+\n+//sys\tMkdirat(dirfd int, path string, mode uint32) (errno int)\n+//mkdirat(dirfd int, path *byte, mode Mode_t) int\n+\n+//sys\tMknodat(dirfd int, path string, mode uint32, dev int) (errno int)\n+//mknodat(dirfd int, path *byte, mode Mode_t, dev _dev_t) int\n+\n+//sys\tPivotRoot(newroot string, putold string) (errno int)\n+//pivot_root(newroot *byte, putold *byte) int\n+\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (errno int)\n+//renameat(olddirfd int, oldpath *byte, newdirfd int, newpath *byte) int\n+\n+//sys\tsendfile(outfd int, infd int, offset *Offset_t, count int) (written int, errno int)\n+//sendfile64(outfd int, infd int, offset *Offset_t, count Size_t) Ssize_t\n+func Sendfile(outfd int, infd int, offset *int64, count int) (written int, errno int) {\n+\tvar soff Offset_t\n+\tvar psoff *Offset_t\n+\tif offset != nil {\n+\t\tpsoff = &soff\n+\t}\n+\twritten, errno = sendfile(outfd, infd, psoff, count)\n+\tif offset != nil {\n+\t\t*offset = int64(soff)\n+\t}\n+\treturn\n+}\n+\n+//sys\tSetfsgid(gid int) (errno int)\n+//setfsgid(gid Gid_t) int\n+\n+//sys\tSetfsuid(uid int) (errno int)\n+//setfsuid(uid Uid_t) int\n+\n+//sysnb\tSetresgid(rgid int, egid int, sgid int) (errno int)\n+//setresgid(rgid Gid_t, egid Gid_t, sgid Gid_t) int\n+\n+//sysnb\tSetresuid(ruid int, eguid int, suid int) (errno int)\n+//setresuid(ruid Uid_t, euid Uid_t, suid Uid_t) int\n+\n+//sys\tsplice(rfd int, roff *_loff_t, wfd int, woff *_loff_t, len int, flags int) (n int64, errno int)\n+//splice(rfd int, roff *_loff_t, wfd int, woff *_loff_t, len Size_t, flags uint) Ssize_t\n+func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, errno int) {\n+\tvar lroff _loff_t\n+\tvar plroff *_loff_t\n+\tif (roff != nil) {\n+\t\tplroff = &lroff\n+\t}\n+\tvar lwoff _loff_t\n+\tvar plwoff *_loff_t\n+\tif (woff != nil) {\n+\t\tplwoff = &lwoff\n+\t}\n+\tn, errno = splice(rfd, plroff, wfd, plwoff, len, flags)\n+\tif (roff != nil) {\n+\t\t*roff = int64(lroff)\n+\t}\n+\tif (woff != nil) {\n+\t\t*woff = int64(lwoff)\n+\t}\n+\treturn\n+}\n+\n+// FIXME: mksysinfo statfs\n+// //sys\tStatfs(path string, buf *Statfs_t) (errno int)\n+// //statfs(path *byte, buf *Statfs_t) int\n+\n+//sys\tSyncFileRange(fd int, off int64, n int64, flags int) (errno int)\n+//sync_file_range(fd int, off Offset_t, n Offset_t, flags uint) int\n+\n+// FIXME: mksysinfo Sysinfo_t\n+// //sysnb\tSysinfo(info *Sysinfo_t) (errno int)\n+// //sysinfo(info *Sysinfo_t) int\n+\n+//sys\tTee(rfd int, wfd int, len int, flags int) (n int64, errno int)\n+//tee(rfd int, wfd int, len Size_t, flags uint) Ssize_t\n+\n+//sysnb\tTgkill(tgid int, tid int, sig int) (errno int)\n+//tgkill(tgid int, tid int, sig int) int\n+\n+//sys\tunlinkat(dirfd int, path string, flags int) (errno int)\n+//unlinkat(dirfd int, path *byte, flags int) int\n+\n+func Unlinkat(dirfd int, path string) (errno int) {\n+\treturn unlinkat(dirfd, path, 0)\n+}\n+\n+//sys\tUnmount(target string, flags int) (errno int) = SYS_UMOUNT2\n+//umount2(target *byte, flags int) int\n+\n+//sys\tUnshare(flags int) (errno int)\n+//unshare(flags int) int\n+\n+// FIXME: mksysinfo Ustat_t\n+// //sys\tUstat(dev int, ubuf *Ustat_t) (errno int)\n+// //ustat(dev _dev_t, ubuf *Ustat_t) int"}, {"sha": "ea7dfc89af7a8eb6c6369c36a9bd4113f856ed6a", "filename": "libgo/go/syscall/libcall_posix.go", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,385 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// POSIX library calls.\n+// This file is compiled as ordinary Go code,\n+// but it is also input to mksyscall,\n+// which parses the //sys lines and generates library call stubs.\n+// Note that sometimes we use a lowercase //sys name and\n+// wrap it in our own nicer implementation.\n+\n+package syscall\n+\n+import \"unsafe\"\n+\n+/*\n+ * Wrapped\n+ */\n+\n+//sysnb\tpipe(p *[2]int) (errno int)\n+//pipe(p *[2]int) int\n+func Pipe(p []int) (errno int) {\n+\tif len(p) != 2 {\n+\t\treturn EINVAL\n+\t}\n+\tvar pp [2]int\n+\terrno = pipe(&pp)\n+\tp[0] = pp[0]\n+\tp[1] = pp[1]\n+\treturn\n+}\n+\n+//sys\tutimes(path string, times *[2]Timeval) (errno int)\n+//utimes(path *byte, times *[2]Timeval) int\n+func Utimes(path string, tv []Timeval) (errno int) {\n+\tif len(tv) != 2 {\n+\t\treturn EINVAL\n+\t}\n+\treturn utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))\n+}\n+\n+//sys\tgetcwd(buf *byte, size Size_t) (errno int)\n+//getcwd(buf *byte, size Size_t) *byte\n+\n+const ImplementsGetwd = true\n+\n+func Getwd() (ret string, errno int) {\n+\tfor len := Size_t(4096); ; len *= 2 {\n+\t\tb := make([]byte, len)\n+\t\terr := getcwd(&b[0], len)\n+\t\tif err == 0 {\n+\t\t\ti := 0;\n+\t\t\tfor b[i] != 0 {\n+\t\t\t\ti++;\n+\t\t\t}\n+\t\t\treturn string(b[0:i]), 0;\n+\t\t}\n+\t\tif err != ERANGE {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t}\n+}\n+\n+//sysnb\tgetgroups(size int, list *Gid_t) (nn int, errno int)\n+//getgroups(size int, list *Gid_t) int\n+\n+func Getgroups() (gids []int, errno int) {\n+\tn, err := getgroups(0, nil)\n+\tif err != 0 {\n+\t\treturn nil, errno\n+\t}\n+\tif n == 0 {\n+\t\treturn nil, 0\n+\t}\n+\n+\t// Sanity check group count.  Max is 1<<16 on Linux.\n+\tif n < 0 || n > 1<<20 {\n+\t\treturn nil, EINVAL\n+\t}\n+\n+\ta := make([]Gid_t, n)\n+\tn, err = getgroups(n, &a[0])\n+\tif err != 0 {\n+\t\treturn nil, errno\n+\t}\n+\tgids = make([]int, n)\n+\tfor i, v := range a[0:n] {\n+\t\tgids[i] = int(v)\n+\t}\n+\treturn\n+}\n+\n+//sysnb\tsetgroups(n int, list *Gid_t) (errno int)\n+//setgroups(n Size_t, list *Gid_t) int\n+\n+func Setgroups(gids []int) (errno int) {\n+\tif len(gids) == 0 {\n+\t\treturn setgroups(0, nil)\n+\t}\n+\n+\ta := make([]Gid_t, len(gids))\n+\tfor i, v := range gids {\n+\t\ta[i] = Gid_t(v)\n+\t}\n+\treturn setgroups(len(a), &a[0])\n+}\n+\n+type WaitStatus uint32\n+\n+// The WaitStatus methods are implemented in C, to pick up the macros\n+// #defines in <sys/wait.h>.\n+\n+func (w WaitStatus) Exited() bool\n+func (w WaitStatus) Signaled() bool\n+func (w WaitStatus) Stopped() bool\n+func (w WaitStatus) Continued() bool\n+func (w WaitStatus) CoreDump() bool\n+func (w WaitStatus) ExitStatus() int\n+func (w WaitStatus) Signal() int\n+func (w WaitStatus) StopSignal() int\n+func (w WaitStatus) TrapCause() int\n+\n+//sys\tMkfifo(path string, mode uint32) (errno int)\n+//mkfifo(path *byte, mode Mode_t) int\n+\n+//sys\tSelect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int)\n+//select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) int\n+\n+const nfdbits = unsafe.Sizeof(fds_bits_type) * 8\n+\n+type FdSet struct {\n+\tBits [(FD_SETSIZE + nfdbits - 1) / nfdbits]fds_bits_type\n+}\n+\n+func FDSet(fd int, set *FdSet) {\n+\tset.Bits[fd / nfdbits] |= (1 << (uint)(fd % nfdbits))\n+}\n+\n+func FDClr(fd int, set *FdSet) {\n+\tset.Bits[fd / nfdbits] &^= (1 << (uint)(fd % nfdbits))\n+}\n+\n+func FDIsSet(fd int, set *FdSet) bool {\n+\tif set.Bits[fd / nfdbits] & (1 << (uint)(fd % nfdbits)) != 0 {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}\n+\n+func FDZero(set *FdSet) {\n+\tfor i := range set.Bits {\n+\t\tset.Bits[i] = 0\n+\t}\n+}\n+\n+//sys\tAccess(path string, mode uint32) (errno int)\n+//access(path *byte, mode int) int\n+\n+//sys\tChdir(path string) (errno int)\n+//chdir(path *byte) int\n+\n+//sys\tChmod(path string, mode uint32) (errno int)\n+//chmod(path *byte, mode Mode_t) int\n+\n+//sys\tChown(path string, uid int, gid int) (errno int)\n+//chown(path *byte, uid Uid_t, gid Gid_t) int\n+\n+//sys\tChroot(path string) (errno int)\n+//chroot(path *byte) int\n+\n+//sys\tClose(fd int) (errno int)\n+//close(fd int) int\n+\n+//sys\tCreat(path string, mode uint32) (fd int, errno int)\n+//creat(path *byte, mode Mode_t) int\n+\n+//sysnb\tDup(oldfd int) (fd int, errno int)\n+//dup(oldfd int) int\n+\n+//sysnb\tDup2(oldfd int, newfd int) (fd int, errno int)\n+//dup2(oldfd int, newfd int) int\n+\n+//sys\tExit(code int)\n+//exit(code int)\n+\n+//sys\tFchdir(fd int) (errno int)\n+//fchdir(fd int) int\n+\n+//sys\tFchmod(fd int, mode uint32) (errno int)\n+//fchmod(fd int, mode Mode_t) int\n+\n+//sys\tFchown(fd int, uid int, gid int) (errno int)\n+//fchown(fd int, uid Uid_t, gid Gid_t) int\n+\n+//sys\tfcntl(fd int, cmd int, arg int) (val int, errno int)\n+//fcntl(fd int, cmd int, arg int) int\n+\n+//sys\tFdatasync(fd int) (errno int)\n+//fdatasync(fd int) int\n+\n+//sys\tFlock(fd int, how int) (errno int)\n+//flock(fd int, how int) int\n+\n+//sys\tFsync(fd int) (errno int)\n+//fsync(fd int) int\n+\n+//sysnb Getegid() (egid int)\n+//getegid() Gid_t\n+\n+//sysnb Geteuid() (euid int)\n+//geteuid() Uid_t\n+\n+//sysnb Getgid() (gid int)\n+//getgid() Gid_t\n+\n+//sysnb\tGetpagesize() (pagesize int)\n+//getpagesize() int\n+\n+//sysnb\tGetpgid(pid int) (pgid int, errno int)\n+//getpgid(pid Pid_t) Pid_t\n+\n+//sysnb\tGetpgrp() (pid int)\n+//getpgrp() Pid_t\n+\n+//sysnb\tGetpid() (pid int)\n+//getpid() Pid_t\n+\n+//sysnb\tGetppid() (ppid int)\n+//getppid() Pid_t\n+\n+// FIXME: mksysinfo Rlimit\n+// //sysnb\tGetrlimit(resource int, rlim *Rlimit) (errno int)\n+// //getrlimit(resource int, rlim *Rlimit) int\n+\n+//sysnb\tGetrusage(who int, rusage *Rusage) (errno int)\n+//getrusage(who int, rusage *Rusage) int\n+\n+//sysnb\tGettid() (tid int)\n+//gettid() Pid_t\n+\n+//sysnb\tgettimeofday(tv *Timeval, tz *byte) (errno int)\n+//gettimeofday(tv *Timeval, tz *byte) int\n+func Gettimeofday(tv *Timeval) (errno int) {\n+\treturn gettimeofday(tv, nil)\n+}\n+\n+//sysnb Getuid() (uid int)\n+//getuid() Uid_t\n+\n+//sysnb\tKill(pid int, sig int) (errno int)\n+//kill(pid Pid_t, sig int) int\n+\n+//sys\tLchown(path string, uid int, gid int) (errno int)\n+//lchown(path *byte, uid Uid_t, gid Gid_t) int\n+\n+//sys\tLink(oldpath string, newpath string) (errno int)\n+//link(oldpath *byte, newpath *byte) int\n+\n+//sys\tMkdir(path string, mode uint32) (errno int)\n+//mkdir(path *byte, mode Mode_t) int\n+\n+//sys\tMknod(path string, mode uint32, dev int) (errno int)\n+//mknod(path *byte, mode Mode_t, dev _dev_t) int\n+\n+//sys\tMount(source string, target string, fstype string, flags int, data string) (errno int)\n+//mount(source *byte, target *byte, fstype *byte, flags _C_long, data *byte) int\n+\n+//sys\tNanosleep(time *Timespec, leftover *Timespec) (errno int)\n+//nanosleep(time *Timespec, leftover *Timespec) int\n+\n+//sys\tPause() (errno int)\n+//pause() int\n+\n+//sys\tRead(fd int, p []byte) (n int, errno int)\n+//read(fd int, buf *byte, count Size_t) Ssize_t\n+\n+//sys\tReadlink(path string, buf []byte) (n int, errno int)\n+//readlink(path *byte, buf *byte, bufsiz Size_t) Ssize_t\n+\n+//sys\tRename(oldpath string, newpath string) (errno int)\n+//rename(oldpath *byte, newpath *byte) int\n+\n+//sys\tRmdir(path string) (errno int)\n+//rmdir(path *byte) int\n+\n+//sys\tSetdomainname(p []byte) (errno int)\n+//setdomainname(name *byte, len Size_t) int\n+\n+//sys\tSethostname(p []byte) (errno int)\n+//sethostname(name *byte, len Size_t) int\n+\n+//sysnb\tSetgid(gid int) (errno int)\n+//setgid(gid Gid_t) int\n+\n+//sysnb Setregid(rgid int, egid int) (errno int)\n+//setregid(rgid Gid_t, egid Gid_t) int\n+\n+//sysnb\tSetpgid(pid int, pgid int) (errno int)\n+//setpgid(pid Pid_t, pgid Pid_t) int\n+\n+//sysnb\tSetreuid(ruid int, euid int) (errno int)\n+//setreuid(ruid Uid_t, euid Uid_t) int\n+\n+// FIXME: mksysinfo Rlimit\n+// //sysnb\tSetrlimit(resource int, rlim *Rlimit) (errno int)\n+// //setrlimit(resource int, rlim *Rlimit) int\n+\n+//sysnb\tSetsid() (pid int, errno int)\n+//setsid() Pid_t\n+\n+//sysnb\tsettimeofday(tv *Timeval, tz *byte) (errno int)\n+//settimeofday(tv *Timeval, tz *byte) int\n+\n+func Settimeofday(tv *Timeval) (errno int) {\n+\treturn settimeofday(tv, nil)\n+}\n+\n+//sysnb\tSetuid(uid int) (errno int)\n+//setuid(uid Uid_t) int\n+\n+//sys\tSymlink(oldpath string, newpath string) (errno int)\n+//symlink(oldpath *byte, newpath *byte) int\n+\n+//sys\tSync()\n+//sync()\n+\n+// FIXME: mksysinfo Time_t\n+// //sysnb\tTime(t *Time_t) (tt Time_t, errno int)\n+// //time(t *Time_t) Time_t\n+\n+// FIXME: mksysinfo Tms\n+// //sysnb\tTimes(tms *Tms) (ticks uintptr, errno int)\n+// //times(tms *Tms) _clock_t\n+\n+//sysnb\tUmask(mask int) (oldmask int)\n+//umark(mask Mode_t) Mode_t\n+\n+//sys\tUnlink(path string) (errno int)\n+//unlink(path *byte) int\n+\n+// FIXME: mksysinfo Utimbuf\n+// //sys\tUtime(path string, buf *Utimbuf) (errno int)\n+// //utime(path *byte, buf *Utimbuf) int\n+\n+//sys\tWrite(fd int, p []byte) (n int, errno int)\n+//write(fd int, buf *byte, count Size_t) Ssize_t\n+\n+//sys\tmunmap(addr uintptr, length uintptr) (errno int)\n+//munmap(addr *byte, length Size_t) int\n+\n+//sys Madvise(b []byte, advice int) (errno int)\n+//madvise(addr *byte, len Size_t, advice int) int\n+\n+//sys\tMprotect(b []byte, prot int) (errno int)\n+//mprotect(addr *byte, len Size_t, prot int) int\n+\n+//sys\tMlock(b []byte) (errno int)\n+//mlock(addr *byte, len Size_t) int\n+\n+//sys\tMunlock(b []byte) (errno int)\n+//munlock(addr *byte, len Size_t) int\n+\n+//sys\tMlockall(flags int) (errno int)\n+//mlockall(flags int) int\n+\n+//sys\tMunlockall() (errno int)\n+//munlockall() int\n+\n+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }\n+\n+func NsecToTimespec(nsec int64) (ts Timespec) {\n+\tts.Sec = Timespec_sec_t(nsec / 1e9)\n+\tts.Nsec = Timespec_nsec_t(nsec % 1e9)\n+\treturn\n+}\n+\n+func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }\n+\n+func NsecToTimeval(nsec int64) (tv Timeval) {\n+\tnsec += 999 // round up to microsecond\n+\ttv.Sec = Timeval_sec_t(nsec / 1e9)\n+\ttv.Usec = Timeval_usec_t(nsec % 1e9 / 1e3)\n+\treturn\n+}"}, {"sha": "acfafecc58171f9f5eb5b24a4fa75fcd10ea4e30", "filename": "libgo/go/syscall/libcall_posix_largefile.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// POSIX library calls on systems which use the largefile interface.\n+\n+package syscall\n+\n+//sys\tFstat(fd int, stat *Stat_t) (errno int)\n+//fstat64(fd int, stat *Stat_t) int\n+\n+//sys\tFtruncate(fd int, length int64) (errno int)\n+//ftruncate64(fd int, length Offset_t) int\n+\n+//sys\tLstat(path string, stat *Stat_t) (errno int)\n+//lstat64(path *byte, stat *Stat_t) int\n+\n+//sys\tmmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, errno int)\n+//mmap64(addr *byte, length Size_t, prot int, flags int, fd int, offset Offset_t) *byte\n+\n+//sys\tOpen(path string, mode int, perm uint32) (fd int, errno int)\n+//open64(path *byte, mode int, perm Mode_t) int\n+\n+//sys\tPread(fd int, p []byte, offset int64) (n int, errno int)\n+//pread64(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t\n+\n+//sys\tPwrite(fd int, p []byte, offset int64) (n int, errno int)\n+//pwrite64(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t\n+\n+//sys\tSeek(fd int, offset int64, whence int) (off int64, errno int)\n+//lseek64(fd int, offset Offset_t, whence int) Offset_t\n+\n+//sys\tStat(path string, stat *Stat_t) (errno int)\n+//stat64(path *byte, stat *Stat_t) int\n+\n+//sys\tTruncate(path string, length int64) (errno int)\n+//truncate64(path *byte, length Offset_t) int"}, {"sha": "b71da0ceb48f1d9cad1ab1f0d9c71eecef4661ce", "filename": "libgo/go/syscall/libcall_posix_regfile.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// POSIX library calls on systems which do not use the largefile\n+// interface.\n+\n+package syscall\n+\n+//sys\tFstat(fd int, stat *Stat_t) (errno int)\n+//fstat(fd int, stat *Stat_t) int\n+\n+//sys\tFtruncate(fd int, length int64) (errno int)\n+//ftruncate(fd int, length Offset_t) int\n+\n+//sys\tLstat(path string, stat *Stat_t) (errno int)\n+//lstat(path *byte, stat *Stat_t) int\n+\n+//sys\tmmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, errno int)\n+//mmap(addr *byte, length Size_t, prot int, flags int, fd int, offset Offset_t) *byte\n+\n+//sys\tOpen(path string, mode int, perm uint32) (fd int, errno int)\n+//open(path *byte, mode int, perm Mode_t) int\n+\n+//sys\tPread(fd int, p []byte, offset int64) (n int, errno int)\n+//pread(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t\n+\n+//sys\tPwrite(fd int, p []byte, offset int64) (n int, errno int)\n+//pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t\n+\n+//sys\tSeek(fd int, offset int64, whence int) (off int64, errno int)\n+//lseek(fd int, offset Offset_t, whence int) Offset_t\n+\n+//sys\tStat(path string, stat *Stat_t) (errno int)\n+//stat(path *byte, stat *Stat_t) int\n+\n+//sys\tTruncate(path string, length int64) (errno int)\n+//truncate(path *byte, length Offset_t) int"}, {"sha": "a008a221db254cc29766dfa829227265db7fc83e", "filename": "libgo/go/syscall/libcall_solaris_386.go", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_386.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -1,7 +1,9 @@\n-// syscall_solaris.go -- Solaris 2 specific syscall interface.\n-\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n package syscall\n+\n+// 32-bit Solaris 2/x86 needs to use _nuname internally, cf. <sys/utsname.h>.\n+//sysnb\tUname(buf *Utsname) (errno int)\n+//_nuname(buf *Utsname) int", "previous_filename": "libgo/syscalls/syscall_solaris.go"}, {"sha": "daed8073caf5f0664c6319add8c921cd58f57969", "filename": "libgo/go/syscall/libcall_support.go", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_support.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_support.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_support.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -2,6 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// Declarations for functions which are actually written in C.\n+\n package syscall\n \n-func libc_uname(buf *Utsname) (errno int) __asm__(\"uname\")\n+func entersyscall()\n+func exitsyscall()\n+func GetErrno() int\n+func SetErrno(int)", "previous_filename": "libgo/syscalls/syscall_uname.go"}, {"sha": "e4c32b12d6adabf7228dbc59014551cf2f151d62", "filename": "libgo/go/syscall/libcall_uname.go", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -1,7 +1,8 @@\n-// syscall_rtems.go -- RTEMS specific syscall interface.\n-\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n package syscall\n+\n+//sysnb\tUname(buf *Utsname) (errno int)\n+//uname(buf *Utsname) int", "previous_filename": "libgo/syscalls/syscall_rtems.go"}, {"sha": "7a63bc71e97cf12378a6255917461e068ef372c6", "filename": "libgo/go/syscall/libcall_wait4.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_wait4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_wait4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_wait4.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// For systems with the wait4 library call.\n+\n+package syscall\n+\n+//sys\twait4(pid Pid_t, status *int, options int, rusage *Rusage) (wpid Pid_t, errno int)\n+//wait4(pid Pid_t, status *int, options int, rusage *Rusage) Pid_t\n+\n+func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {\n+\tvar status int\n+\tr, err := wait4(Pid_t(pid), &status, options, rusage)\n+\twpid = int(r)\n+\terrno = err\n+\tif wstatus != nil {\n+\t\t*wstatus = WaitStatus(status)\n+\t}\n+\treturn\n+}"}, {"sha": "014446307e320102bff13c33996caa02a75a48b8", "filename": "libgo/go/syscall/libcall_waitpid.go", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -1,20 +1,19 @@\n-// waitpid.go -- Wait4 for systems without wait4, but with waitpid.\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// For systems with the waitpid library call.\n+\n package syscall\n \n-func libc_waitpid(Pid_t, *int, int) Pid_t __asm__ (\"waitpid\")\n+//sys\twaitpid(pid Pid_t, status *int, options int) (wpid Pid_t, errno int)\n+//waitpid(pid Pid_t, status *int, options int) Pid_t\n \n func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {\n \tvar status int\n-\tr := libc_waitpid(Pid_t(pid), &status, options)\n+\tr, err := waitpid(Pid_t(pid), &status, options)\n \twpid = int(r)\n-\tif r < 0 {\n-\t\terrno = GetErrno()\n-\t}\n+\terrno = err\n \tif wstatus != nil {\n \t\t*wstatus = WaitStatus(status)\n \t}", "previous_filename": "libgo/syscalls/waitpid.go"}, {"sha": "f2bd2b757f9720d8baabed23aeaaf48bae61ab4d", "filename": "libgo/go/syscall/lsf_linux.go", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flsf_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Flsf_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flsf_linux.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Linux socket filter\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+func LsfStmt(code, k int) *SockFilter {\n+\treturn &SockFilter{Code: uint16(code), K: uint32(k)}\n+}\n+\n+func LsfJump(code, k, jt, jf int) *SockFilter {\n+\treturn &SockFilter{Code: uint16(code), Jt: uint8(jt), Jf: uint8(jf), K: uint32(k)}\n+}\n+\n+func LsfSocket(ifindex, proto int) (int, int) {\n+\tvar lsall SockaddrLinklayer\n+\ts, e := Socket(AF_PACKET, SOCK_RAW, proto)\n+\tif e != 0 {\n+\t\treturn 0, e\n+\t}\n+\tp := (*[2]byte)(unsafe.Pointer(&lsall.Protocol))\n+\tp[0] = byte(proto >> 8)\n+\tp[1] = byte(proto)\n+\tlsall.Ifindex = ifindex\n+\te = Bind(s, &lsall)\n+\tif e != 0 {\n+\t\tClose(s)\n+\t\treturn 0, e\n+\t}\n+\treturn s, 0\n+}\n+\n+type iflags struct {\n+\tname  [IFNAMSIZ]byte\n+\tflags uint16\n+}\n+\n+func SetLsfPromisc(name string, m bool) int {\n+\ts, e := Socket(AF_INET, SOCK_DGRAM, 0)\n+\tif e != 0 {\n+\t\treturn e\n+\t}\n+\tdefer Close(s)\n+\tvar ifl iflags\n+\tcopy(ifl.name[:], []byte(name))\n+\t_, _, ep := Syscall(SYS_IOCTL, uintptr(s), SIOCGIFFLAGS, uintptr(unsafe.Pointer(&ifl)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\tif m {\n+\t\tifl.flags |= uint16(IFF_PROMISC)\n+\t} else {\n+\t\tifl.flags &= ^uint16(IFF_PROMISC)\n+\t}\n+\t_, _, ep = Syscall(SYS_IOCTL, uintptr(s), SIOCSIFFLAGS, uintptr(unsafe.Pointer(&ifl)))\n+\tif e := int(ep); e != 0 {\n+\t\treturn e\n+\t}\n+\treturn 0\n+}\n+\n+func AttachLsf(fd int, i []SockFilter) int {\n+\tvar p SockFprog\n+\tp.Len = uint16(len(i))\n+\tp.Filter = (*SockFilter)(unsafe.Pointer(&i[0]))\n+\treturn setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, uintptr(unsafe.Pointer(&p)), unsafe.Sizeof(p))\n+}\n+\n+func DetachLsf(fd int) int {\n+\tvar dummy int\n+\treturn setsockopt(fd, SOL_SOCKET, SO_DETACH_FILTER, uintptr(unsafe.Pointer(&dummy)), unsafe.Sizeof(dummy))\n+}"}, {"sha": "d19a8ba73fc53a27a3e5cc9606d8afd351eca1ab", "filename": "libgo/go/syscall/mksyscall.awk", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fmksyscall.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fmksyscall.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fmksyscall.awk?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,233 @@\n+# Copyright 2011 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# This AWK script reads a Go file with comments describing syscall\n+# functions and the C routines they map to.  It generates the Go code\n+# which calls the C routines.\n+\n+# The syscall functins are marked by lines beginning with \"//sys\" and\n+# read like func declarations if //sys is replaced by func, but:\n+#\t* The parameter lists must give a name for each argument.\n+#\t  This includes return parameters.\n+#\t* The parameter lists must give a type for each argument:\n+#\t   the (x, y, z int) shorthand is not allowed.\n+#\t* If the return parameter is an error number, it must be named errno.\n+\n+# A line beginning with //sysnb is like //sys, except that the\n+# goroutine will not be suspended during the execution of the library\n+# call.  This must only be used for library calls which can never\n+# block, as otherwise the library call could cause all goroutines to\n+# hang.\n+\n+# After the //sys or //sysnb line comes a second line which describes\n+# the C function.  The name must be the name of the function in the C\n+# library, and may be the same as the Go function.  The limitations on\n+# the argument list are the same as for the //sys line, but there must\n+# be at most one result parameter, and it must be given as just a\n+# type, without a name.\n+\n+BEGIN {\n+    print \"// This file was automatically generated by mksyscall.awk\"\n+    print \"\"\n+    print \"package syscall\"\n+    print \"\"\n+    print \"import \\\"unsafe\\\"\"\n+    print \"\"\n+    status = 0\n+}\n+\n+/^\\/\\/sys/ {\n+    if ($1 == \"//sysnb\") {\n+\tblocking = 0\n+    } else {\n+\tblocking = 1\n+    }\n+\n+    if (match($0, \"//sys(nb)?[ \t]*([a-zA-Z0-9_]+)\\\\(([^()]*)\\\\) *(\\\\(([^()]+)\\\\))?\", gosig) == 0) {\n+\tprint \"unmatched line:\", $0 | \"cat 1>&2\"\n+\tstatus = 1\n+\tnext\n+    }\n+\n+    gofnname = gosig[2]\n+    gofnparams = gosig[3]\n+    gofnresults = gosig[5]\n+\n+    getline\n+\n+    if (match($0, \"//([a-zA-Z0-9_]+)\\\\(([^()]*)\\\\) *(.*)$\", csig) == 0) {\n+\tprint \"unmatched C line\", $0, \"after\", gofnname | \"cat 1>&2\"\n+\tstatus = 1\n+\tnext\n+    }\n+\n+    cfnname = csig[1]\n+    cfnparams = csig[2]\n+    cfnresult = csig[3]\n+\n+    printf(\"// Automatically generated wrapper for %s/%s\\n\", gofnname, cfnname)\n+    printf(\"func c_%s(%s) %s%s__asm__(\\\"%s\\\")\\n\",\n+\t   cfnname, cfnparams, cfnresult, cfnresult == \"\" ? \"\" : \" \", cfnname)\n+    printf(\"func %s(%s) %s%s{\\n\",\n+\t   gofnname, gofnparams, gosig[4], gosig[4] == \"\" ? \"\" : \" \")\n+\n+    if (blocking) {\n+\tprint \"\\tentersyscall()\"\n+    }\n+\n+    loc = gofnname \"/\" cfnname \":\"\n+\n+    split(gofnparams, goargs, \", *\")\n+    split(cfnparams, cargs, \", *\")\n+    args = \"\"\n+    carg = 1\n+    for (goarg = 1; goargs[goarg] != \"\"; goarg++) {\n+\tif (cargs[carg] == \"\") {\n+\t    print loc, \"not enough C parameters\"\n+\t}\n+\n+\tif (args != \"\") {\n+\t    args = args \", \"\n+\t}\n+\n+\tif (match(goargs[goarg], \"^([^ ]*) ([^ ]*)$\", goparam) == 0) {\n+\t    print loc, \"bad parameter:\", goargs[goarg] | \"cat 1>&2\"\n+\t    status = 1\n+\t    next\n+\t}\n+\n+\tgoname = goparam[1]\n+\tgotype = goparam[2]\n+\n+\tif (match(cargs[carg], \"^([^ ]*) ([^ ]*)$\", cparam) == 0) {\n+\t    print loc, \"bad C parameter:\", cargs[carg] | \"cat 1>&2\"\n+\t    status = 1\n+\t    next\n+\t}\n+\n+\tctype = cparam[2]\n+\n+\tif (gotype ~ /^\\*/) {\n+\t    if (gotype != ctype) {\n+\t\tprint loc, \"Go/C pointer type mismatch:\", gotype, ctype | \"cat 1>&2\"\n+\t\tstatus = 1\n+\t\tnext\n+\t    }\n+\t    args = args goname\n+\t} else if (gotype == \"string\") {\n+\t    if (ctype != \"*byte\") {\n+\t\tprint loc, \"Go string not matched to C *byte:\", gotype, ctype | \"cat 1>&2\"\n+\t\tstatus = 1\n+\t\tnext\n+\t    }\n+\t    args = args \"StringBytePtr(\" goname \")\"\n+\t} else if (gotype ~ /^\\[\\](.*)/) {\n+\t    if (ctype !~ /^\\*/ || cargs[carg + 1] == \"\") {\n+\t\tprint loc, \"bad C type for slice:\", gotype, ctype | \"cat 1>&2\"\n+\t\tstatus = 1\n+\t\tnext\n+\t    }\n+\n+\t    # Convert a slice into a pair of pointer, length.\n+\t    # Don't try to take the address of the zeroth element of a\n+\t    # nil slice.\n+\t    printf(\"\\tvar _p%d %s\\n\", goarg, ctype)\n+\t    printf(\"\\tif len(%s) > 0 {\\n\", goname)\n+\t    printf(\"\\t\\t_p%d = (%s)(unsafe.Pointer(&%s[0]))\\n\", goarg, ctype, goname)\n+\t    printf(\"\\t} else {\\n\")\n+\t    printf(\"\\t\\t_p%d = (%s)(unsafe.Pointer(&_zero))\\n\", goarg, ctype)\n+\t    printf(\"\\t}\\n\")\n+\n+\t    ++carg\n+\t    if (match(cargs[carg], \"^([^ ]*) ([^ ]*)$\", cparam) == 0) {\n+\t\tprint loc, \"bad C parameter:\", cargs[carg] | \"cat 1>&2\"\n+\t\tstatus = 1\n+\t\tnext\n+\t    }\n+\n+\t    args = sprintf(\"%s_p%d, %s(len(%s))\", args, goarg, cparam[2], goname)\n+\t} else if (gotype == \"uintptr\" && ctype ~ /^\\*/) {\n+\t    args = sprintf(\"%s(%s)(unsafe.Pointer(%s))\", args, ctype, goname)\n+\t} else {\n+\t    args = sprintf(\"%s%s(%s)\", args, ctype, goname)\n+\t}\n+\n+\tcarg++\n+    }\n+\n+    if (cargs[carg] != \"\") {\n+\tprint loc, \"too many C parameters\" | \"cat 1>&2\"\n+\tstatus = 1\n+\tnext\n+    }\n+\n+    printf(\"\\t\")\n+    if (gofnresults != \"\") {\n+\tprintf(\"_r := \")\n+    }\n+    printf(\"c_%s(%s)\\n\", cfnname, args)\n+\n+    if (gofnresults != \"\") {\n+\tfields = split(gofnresults, goresults, \", *\")\n+\tif (fields > 2) {\n+\t    print loc, \"too many Go results\" | \"cat 1>&2\"\n+\t    status = 1\n+\t    next\n+\t}\n+\tusedr = 0\n+\tfor (goresult = 1; goresults[goresult] != \"\"; goresult++) {\n+\t    if (match(goresults[goresult], \"^([^ ]*) ([^ ]*)$\", goparam) == 0) {\n+\t\tprint loc, \"bad result:\", goresults[goresult] | \"cat 1>&2\"\n+\t\tstatus = 1\n+\t\tnext\n+\t    }\n+\n+\t    goname = goparam[1]\n+\t    gotype = goparam[2]\n+\n+\t    if (goname == \"errno\") {\n+\t\tif (cfnresult ~ /^\\*/) {\n+\t\t    print \"\\tif _r == nil {\"\n+\t\t} else {\n+\t\t    print \"\\tif _r < 0 {\"\n+\t\t}\n+\t\tprint \"\\t\\terrno = GetErrno()\"\n+\t\tprint \"\\t}\"\n+\t    } else if (gotype == \"uintptr\" && cfnresult ~ /^\\*/) {\n+\t\tprintf(\"\\t%s = (%s)(unsafe.Pointer(_r))\\n\", goname, gotype)\n+\t    } else {\n+\t\tif (usedr) {\n+\t\t    print loc, \"two parameters but no errno parameter\" | \"cat 1>&2\"\n+\t\t    status = 1\n+\t\t    next\n+\t\t}\n+\t\tprintf(\"\\t%s = (%s)(_r)\\n\", goname, gotype)\n+\t\tusedr = 1\n+\t    }\n+\t}\n+    }\n+\n+    if (blocking) {\n+\tprint \"\\texitsyscall()\"\n+    }\n+\n+    if (gofnresults != \"\") {\n+\tprint \"\\treturn\"\n+    }\n+\n+    print \"}\"\n+\n+    print \"\"\n+\n+    next\n+}\n+\n+{ next }\n+\n+END {\n+    if (status != 0) {\n+\tprint \"*** mksyscall.awk failed\" | \"cat 1>&2\"\n+\texit status\n+    }\n+}"}, {"sha": "4ee78d62f25706597fa6a38b52f11d718d1d50ae", "filename": "libgo/go/syscall/netlink_linux.go", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -195,10 +195,12 @@ func ParseNetlinkRouteAttr(msg *NetlinkMessage) ([]NetlinkRouteAttr, int) {\n \t)\n \n \tswitch msg.Header.Type {\n-\tcase RTM_NEWLINK:\n+\tcase RTM_NEWLINK, RTM_DELLINK:\n \t\tbuf = msg.Data[SizeofIfInfomsg:]\n-\tcase RTM_NEWADDR:\n+\tcase RTM_NEWADDR, RTM_DELADDR:\n \t\tbuf = msg.Data[SizeofIfAddrmsg:]\n+\tcase RTM_NEWROUTE, RTM_DELROUTE:\n+\t\tbuf = msg.Data[SizeofRtMsg:]\n \tdefault:\n \t\treturn nil, EINVAL\n \t}", "previous_filename": "libgo/syscalls/netlink_linux.go"}, {"sha": "f6b124b64e474fe56a63785c4328900345eea46b", "filename": "libgo/go/syscall/route_bsd.go", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Froute_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Froute_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_bsd.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,197 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd openbsd\n+\n+// Routing sockets and messages\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// Round the length of a raw sockaddr up to align it properly.\n+func rsaAlignOf(salen int) int {\n+\tsalign := sizeofPtr\n+\t// NOTE: It seems like 64-bit Darwin kernel still requires 32-bit\n+\t// aligned access to BSD subsystem.\n+\tif darwinAMD64 {\n+\t\tsalign = 4\n+\t}\n+\tif salen == 0 {\n+\t\treturn salign\n+\t}\n+\treturn (salen + salign - 1) & ^(salign - 1)\n+}\n+\n+// RouteRIB returns routing information base, as known as RIB,\n+// which consists of network facility information, states and\n+// parameters.\n+func RouteRIB(facility, param int) ([]byte, int) {\n+\tvar (\n+\t\ttab []byte\n+\t\te   int\n+\t)\n+\n+\tmib := []_C_int{CTL_NET, AF_ROUTE, 0, 0, _C_int(facility), _C_int(param)}\n+\n+\t// Find size.\n+\tn := uintptr(0)\n+\tif e = sysctl(mib, nil, &n, nil, 0); e != 0 {\n+\t\treturn nil, e\n+\t}\n+\tif n == 0 {\n+\t\treturn nil, 0\n+\t}\n+\n+\ttab = make([]byte, n)\n+\tif e = sysctl(mib, &tab[0], &n, nil, 0); e != 0 {\n+\t\treturn nil, e\n+\t}\n+\n+\treturn tab[:n], 0\n+}\n+\n+// RoutingMessage represents a routing message.\n+type RoutingMessage interface {\n+\tsockaddr() []Sockaddr\n+}\n+\n+const anyMessageLen = int(unsafe.Sizeof(anyMessage{}))\n+\n+type anyMessage struct {\n+\tMsglen  uint16\n+\tVersion uint8\n+\tType    uint8\n+}\n+\n+// RouteMessage represents a routing message containing routing\n+// entries.\n+type RouteMessage struct {\n+\tHeader RtMsghdr\n+\tData   []byte\n+}\n+\n+const rtaRtMask = RTA_DST | RTA_GATEWAY | RTA_NETMASK | RTA_GENMASK\n+\n+func (m *RouteMessage) sockaddr() []Sockaddr {\n+\tvar (\n+\t\taf  int\n+\t\tsas [4]Sockaddr\n+\t)\n+\n+\tbuf := m.Data[:]\n+\tfor i := uint(0); i < RTAX_MAX; i++ {\n+\t\tif m.Header.Addrs&rtaRtMask&(1<<i) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\trsa := (*RawSockaddr)(unsafe.Pointer(&buf[0]))\n+\t\tswitch i {\n+\t\tcase RTAX_DST, RTAX_GATEWAY:\n+\t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n+\t\t\tif e != 0 {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif i == RTAX_DST {\n+\t\t\t\taf = int(rsa.Family)\n+\t\t\t}\n+\t\t\tsas[i] = sa\n+\t\tcase RTAX_NETMASK, RTAX_GENMASK:\n+\t\t\tswitch af {\n+\t\t\tcase AF_INET:\n+\t\t\t\trsa4 := (*RawSockaddrInet4)(unsafe.Pointer(&buf[0]))\n+\t\t\t\tsa := new(SockaddrInet4)\n+\t\t\t\tfor j := 0; rsa4.Len > 0 && j < int(rsa4.Len)-int(unsafe.Offsetof(rsa4.Addr)); j++ {\n+\t\t\t\t\tsa.Addr[j] = rsa4.Addr[j]\n+\t\t\t\t}\n+\t\t\t\tsas[i] = sa\n+\t\t\tcase AF_INET6:\n+\t\t\t\trsa6 := (*RawSockaddrInet6)(unsafe.Pointer(&buf[0]))\n+\t\t\t\tsa := new(SockaddrInet6)\n+\t\t\t\tfor j := 0; rsa6.Len > 0 && j < int(rsa6.Len)-int(unsafe.Offsetof(rsa6.Addr)); j++ {\n+\t\t\t\t\tsa.Addr[j] = rsa6.Addr[j]\n+\t\t\t\t}\n+\t\t\t\tsas[i] = sa\n+\t\t\t}\n+\t\t}\n+\t\tbuf = buf[rsaAlignOf(int(rsa.Len)):]\n+\t}\n+\n+\treturn sas[:]\n+}\n+\n+// InterfaceMessage represents a routing message containing\n+// network interface entries.\n+type InterfaceMessage struct {\n+\tHeader IfMsghdr\n+\tData   []byte\n+}\n+\n+func (m *InterfaceMessage) sockaddr() (sas []Sockaddr) {\n+\tif m.Header.Addrs&RTA_IFP == 0 {\n+\t\treturn nil\n+\t}\n+\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(&m.Data[0])))\n+\tif e != 0 {\n+\t\treturn nil\n+\t}\n+\treturn append(sas, sa)\n+}\n+\n+// InterfaceAddrMessage represents a routing message containing\n+// network interface address entries.\n+type InterfaceAddrMessage struct {\n+\tHeader IfaMsghdr\n+\tData   []byte\n+}\n+\n+const rtaIfaMask = RTA_IFA | RTA_NETMASK | RTA_BRD\n+\n+func (m *InterfaceAddrMessage) sockaddr() (sas []Sockaddr) {\n+\tif m.Header.Addrs&rtaIfaMask == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tbuf := m.Data[:]\n+\tfor i := uint(0); i < RTAX_MAX; i++ {\n+\t\tif m.Header.Addrs&rtaIfaMask&(1<<i) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\trsa := (*RawSockaddr)(unsafe.Pointer(&buf[0]))\n+\t\tswitch i {\n+\t\tcase RTAX_IFA:\n+\t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n+\t\t\tif e != 0 {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tsas = append(sas, sa)\n+\t\tcase RTAX_NETMASK, RTAX_BRD:\n+\t\t\t// nothing to do\n+\t\t}\n+\t\tbuf = buf[rsaAlignOf(int(rsa.Len)):]\n+\t}\n+\n+\treturn sas\n+}\n+\n+// ParseRoutingMessage parses buf as routing messages and returns\n+// the slice containing the RoutingMessage interfaces.\n+func ParseRoutingMessage(buf []byte) (msgs []RoutingMessage, errno int) {\n+\tfor len(buf) >= anyMessageLen {\n+\t\tany := (*anyMessage)(unsafe.Pointer(&buf[0]))\n+\t\tif any.Version != RTM_VERSION {\n+\t\t\treturn nil, EINVAL\n+\t\t}\n+\t\tmsgs = append(msgs, any.toRoutingMessage(buf))\n+\t\tbuf = buf[any.Msglen:]\n+\t}\n+\treturn msgs, 0\n+}\n+\n+// ParseRoutingMessage parses msg's payload as raw sockaddrs and\n+// returns the slice containing the Sockaddr interfaces.\n+func ParseRoutingSockaddr(msg RoutingMessage) (sas []Sockaddr, errno int) {\n+\treturn append(sas, msg.sockaddr()...), 0\n+}"}, {"sha": "9d3a701daba859e7fbcdb821b4848bc32091cacc", "filename": "libgo/go/syscall/route_darwin.go", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Froute_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Froute_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_darwin.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Routing sockets and messages for Darwin\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+func (any *anyMessage) toRoutingMessage(buf []byte) RoutingMessage {\n+\tswitch any.Type {\n+\tcase RTM_ADD, RTM_DELETE, RTM_CHANGE, RTM_GET, RTM_LOSING, RTM_REDIRECT, RTM_MISS, RTM_LOCK, RTM_RESOLVE:\n+\t\tp := (*RouteMessage)(unsafe.Pointer(any))\n+\t\trtm := &RouteMessage{}\n+\t\trtm.Header = p.Header\n+\t\trtm.Data = buf[SizeofRtMsghdr:any.Msglen]\n+\t\treturn rtm\n+\tcase RTM_IFINFO:\n+\t\tp := (*InterfaceMessage)(unsafe.Pointer(any))\n+\t\tifm := &InterfaceMessage{}\n+\t\tifm.Header = p.Header\n+\t\tifm.Data = buf[SizeofIfMsghdr:any.Msglen]\n+\t\treturn ifm\n+\tcase RTM_NEWADDR, RTM_DELADDR:\n+\t\tp := (*InterfaceAddrMessage)(unsafe.Pointer(any))\n+\t\tifam := &InterfaceAddrMessage{}\n+\t\tifam.Header = p.Header\n+\t\tifam.Data = buf[SizeofIfaMsghdr:any.Msglen]\n+\t\treturn ifam\n+\tcase RTM_NEWMADDR2, RTM_DELMADDR:\n+\t\tp := (*InterfaceMulticastAddrMessage)(unsafe.Pointer(any))\n+\t\tifmam := &InterfaceMulticastAddrMessage{}\n+\t\tifmam.Header = p.Header\n+\t\tifmam.Data = buf[SizeofIfmaMsghdr2:any.Msglen]\n+\t\treturn ifmam\n+\t}\n+\treturn nil\n+}\n+\n+// InterfaceMulticastAddrMessage represents a routing message\n+// containing network interface address entries.\n+type InterfaceMulticastAddrMessage struct {\n+\tHeader IfmaMsghdr2\n+\tData   []byte\n+}\n+\n+const rtaIfmaMask = RTA_GATEWAY | RTA_IFP | RTA_IFA\n+\n+func (m *InterfaceMulticastAddrMessage) sockaddr() (sas []Sockaddr) {\n+\tif m.Header.Addrs&rtaIfmaMask == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tbuf := m.Data[:]\n+\tfor i := uint(0); i < RTAX_MAX; i++ {\n+\t\tif m.Header.Addrs&rtaIfmaMask&(1<<i) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\trsa := (*RawSockaddr)(unsafe.Pointer(&buf[0]))\n+\t\tswitch i {\n+\t\tcase RTAX_IFA:\n+\t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n+\t\t\tif e != 0 {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tsas = append(sas, sa)\n+\t\tcase RTAX_GATEWAY, RTAX_IFP:\n+\t\t\t// nothing to do\n+\t\t}\n+\t\tbuf = buf[rsaAlignOf(int(rsa.Len)):]\n+\t}\n+\n+\treturn sas\n+}"}, {"sha": "0d61d08b08cfbaf186ed69d4a41a60760c4fc4db", "filename": "libgo/go/syscall/route_freebsd.go", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Froute_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Froute_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_freebsd.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Routing sockets and messages for FreeBSD\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+func (any *anyMessage) toRoutingMessage(buf []byte) RoutingMessage {\n+\tswitch any.Type {\n+\tcase RTM_ADD, RTM_DELETE, RTM_CHANGE, RTM_GET, RTM_LOSING, RTM_REDIRECT, RTM_MISS, RTM_LOCK, RTM_RESOLVE:\n+\t\tp := (*RouteMessage)(unsafe.Pointer(any))\n+\t\trtm := &RouteMessage{}\n+\t\trtm.Header = p.Header\n+\t\trtm.Data = buf[SizeofRtMsghdr:any.Msglen]\n+\t\treturn rtm\n+\tcase RTM_IFINFO:\n+\t\tp := (*InterfaceMessage)(unsafe.Pointer(any))\n+\t\tifm := &InterfaceMessage{}\n+\t\tifm.Header = p.Header\n+\t\tifm.Data = buf[SizeofIfMsghdr:any.Msglen]\n+\t\treturn ifm\n+\tcase RTM_NEWADDR, RTM_DELADDR:\n+\t\tp := (*InterfaceAddrMessage)(unsafe.Pointer(any))\n+\t\tifam := &InterfaceAddrMessage{}\n+\t\tifam.Header = p.Header\n+\t\tifam.Data = buf[SizeofIfaMsghdr:any.Msglen]\n+\t\treturn ifam\n+\tcase RTM_NEWMADDR, RTM_DELMADDR:\n+\t\tp := (*InterfaceMulticastAddrMessage)(unsafe.Pointer(any))\n+\t\tifmam := &InterfaceMulticastAddrMessage{}\n+\t\tifmam.Header = p.Header\n+\t\tifmam.Data = buf[SizeofIfmaMsghdr:any.Msglen]\n+\t\treturn ifmam\n+\t}\n+\treturn nil\n+}\n+\n+// InterfaceMulticastAddrMessage represents a routing message\n+// containing network interface address entries.\n+type InterfaceMulticastAddrMessage struct {\n+\tHeader IfmaMsghdr\n+\tData   []byte\n+}\n+\n+const rtaIfmaMask = RTA_GATEWAY | RTA_IFP | RTA_IFA\n+\n+func (m *InterfaceMulticastAddrMessage) sockaddr() (sas []Sockaddr) {\n+\tif m.Header.Addrs&rtaIfmaMask == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tbuf := m.Data[:]\n+\tfor i := uint(0); i < RTAX_MAX; i++ {\n+\t\tif m.Header.Addrs&rtaIfmaMask&(1<<i) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\trsa := (*RawSockaddr)(unsafe.Pointer(&buf[0]))\n+\t\tswitch i {\n+\t\tcase RTAX_IFA:\n+\t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n+\t\t\tif e != 0 {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tsas = append(sas, sa)\n+\t\tcase RTAX_GATEWAY, RTAX_IFP:\n+\t\t\t// nothing to do\n+\t\t}\n+\t\tbuf = buf[rsaAlignOf(int(rsa.Len)):]\n+\t}\n+\n+\treturn sas\n+}"}, {"sha": "30e1cac46fcda6f36a59102e81d5846a4114071d", "filename": "libgo/go/syscall/route_openbsd.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Froute_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Froute_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_openbsd.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Routing sockets and messages for OpenBSD\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+func (any *anyMessage) toRoutingMessage(buf []byte) RoutingMessage {\n+\tswitch any.Type {\n+\tcase RTM_ADD, RTM_DELETE, RTM_CHANGE, RTM_GET, RTM_LOSING, RTM_REDIRECT, RTM_MISS, RTM_LOCK, RTM_RESOLVE:\n+\t\tp := (*RouteMessage)(unsafe.Pointer(any))\n+\t\trtm := &RouteMessage{}\n+\t\trtm.Header = p.Header\n+\t\trtm.Data = buf[SizeofRtMsghdr:any.Msglen]\n+\t\treturn rtm\n+\tcase RTM_IFINFO:\n+\t\tp := (*InterfaceMessage)(unsafe.Pointer(any))\n+\t\tifm := &InterfaceMessage{}\n+\t\tifm.Header = p.Header\n+\t\tifm.Data = buf[SizeofIfMsghdr:any.Msglen]\n+\t\treturn ifm\n+\tcase RTM_NEWADDR, RTM_DELADDR:\n+\t\tp := (*InterfaceAddrMessage)(unsafe.Pointer(any))\n+\t\tifam := &InterfaceAddrMessage{}\n+\t\tifam.Header = p.Header\n+\t\tifam.Data = buf[SizeofIfaMsghdr:any.Msglen]\n+\t\treturn ifam\n+\t}\n+\treturn nil\n+}"}, {"sha": "8992eb53c3e1baa6f78d32d74dcf9ed2cd475301", "filename": "libgo/go/syscall/sleep_rtems.go", "status": "renamed", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -6,14 +6,8 @@\n \n package syscall\n \n-func libc_nanosleep(req *Timespec, rem *Timespec) int __asm__ (\"nanosleep\")\n-\n func Sleep(nsec int64) (errno int) {\n-\terrno = 0\n \tts := NsecToTimespec(nsec)\n-\tr := libc_nanosleep(&ts, nil)\n-\tif r < 0 {\n-\t\terrno = GetErrno()\n-\t}\n+\terrno = Nanosleep(&ts, nil)\n \treturn\n }", "previous_filename": "libgo/syscalls/sleep_rtems.go"}, {"sha": "3ebaf58f96994606dc346222864a699b3b927611", "filename": "libgo/go/syscall/sleep_select.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsleep_select.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsleep_select.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsleep_select.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -8,6 +8,6 @@ package syscall\n \n func Sleep(nsec int64) (errno int) {\n \ttv := NsecToTimeval(nsec);\n-\tn, err := Select(0, nil, nil, nil, &tv);\n+\t_, err := Select(0, nil, nil, nil, &tv);\n \treturn err;\n }", "previous_filename": "libgo/syscalls/sleep_select.go"}, {"sha": "b025ca52101b9717cb978813ce71800b0bf02598", "filename": "libgo/go/syscall/sockcmsg_linux.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Socket control messages\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// UnixCredentials encodes credentials into a socket control message\n+// for sending to another process. This can be used for\n+// authentication.\n+func UnixCredentials(ucred *Ucred) []byte {\n+\tbuf := make([]byte, CmsgSpace(SizeofUcred))\n+\tcmsg := (*Cmsghdr)(unsafe.Pointer(&buf[0]))\n+\tcmsg.Level = SOL_SOCKET\n+\tcmsg.Type = SCM_CREDENTIALS\n+\tcmsg.SetLen(CmsgLen(SizeofUcred))\n+\t*((*Ucred)(cmsgData(cmsg))) = *ucred\n+\treturn buf\n+}\n+\n+// ParseUnixCredentials decodes a socket control message that contains\n+// credentials in a Ucred structure. To receive such a message, the\n+// SO_PASSCRED option must be enabled on the socket.\n+func ParseUnixCredentials(msg *SocketControlMessage) (*Ucred, int) {\n+\tif msg.Header.Level != SOL_SOCKET {\n+\t\treturn nil, EINVAL\n+\t}\n+\tif msg.Header.Type != SCM_CREDENTIALS {\n+\t\treturn nil, EINVAL\n+\t}\n+\tucred := *(*Ucred)(unsafe.Pointer(&msg.Data[0]))\n+\treturn &ucred, 0\n+}"}, {"sha": "c9872aeba31ed35adfc24699b69c0649e1e10fa7", "filename": "libgo/go/syscall/sockcmsg_unix.go", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux openbsd\n+\n+// Socket control messages\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// Round the length of a raw sockaddr up to align it propery.\n+func cmsgAlignOf(salen int) int {\n+\tsalign := sizeofPtr\n+\t// NOTE: It seems like 64-bit Darwin kernel still requires 32-bit\n+\t// aligned access to BSD subsystem.\n+\tif darwinAMD64 {\n+\t\tsalign = 4\n+\t}\n+\tif salen == 0 {\n+\t\treturn salign\n+\t}\n+\treturn (salen + salign - 1) & ^(salign - 1)\n+}\n+\n+// CmsgLen returns the value to store in the Len field of the Cmsghdr\n+// structure, taking into account any necessary alignment.\n+func CmsgLen(datalen int) int {\n+\treturn cmsgAlignOf(SizeofCmsghdr) + datalen\n+}\n+\n+// CmsgSpace returns the number of bytes an ancillary element with\n+// payload of the passed data length occupies.\n+func CmsgSpace(datalen int) int {\n+\treturn cmsgAlignOf(SizeofCmsghdr) + cmsgAlignOf(datalen)\n+}\n+\n+func cmsgData(cmsg *Cmsghdr) unsafe.Pointer {\n+\treturn unsafe.Pointer(uintptr(unsafe.Pointer(cmsg)) + SizeofCmsghdr)\n+}\n+\n+type SocketControlMessage struct {\n+\tHeader Cmsghdr\n+\tData   []byte\n+}\n+\n+func ParseSocketControlMessage(buf []byte) ([]SocketControlMessage, int) {\n+\tvar (\n+\t\th     *Cmsghdr\n+\t\tdbuf  []byte\n+\t\te     int\n+\t\tcmsgs []SocketControlMessage\n+\t)\n+\n+\tfor len(buf) >= CmsgLen(0) {\n+\t\th, dbuf, e = socketControlMessageHeaderAndData(buf)\n+\t\tif e != 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tm := SocketControlMessage{}\n+\t\tm.Header = *h\n+\t\tm.Data = dbuf[:int(h.Len)-cmsgAlignOf(SizeofCmsghdr)]\n+\t\tcmsgs = append(cmsgs, m)\n+\t\tbuf = buf[cmsgAlignOf(int(h.Len)):]\n+\t}\n+\n+\treturn cmsgs, e\n+}\n+\n+func socketControlMessageHeaderAndData(buf []byte) (*Cmsghdr, []byte, int) {\n+\th := (*Cmsghdr)(unsafe.Pointer(&buf[0]))\n+\tif h.Len < SizeofCmsghdr || int(h.Len) > len(buf) {\n+\t\treturn nil, nil, EINVAL\n+\t}\n+\treturn h, buf[cmsgAlignOf(SizeofCmsghdr):], 0\n+}\n+\n+// UnixRights encodes a set of open file descriptors into a socket\n+// control message for sending to another process.\n+func UnixRights(fds ...int) []byte {\n+\tdatalen := len(fds) * 4\n+\tbuf := make([]byte, CmsgSpace(datalen))\n+\tcmsg := (*Cmsghdr)(unsafe.Pointer(&buf[0]))\n+\tcmsg.Level = SOL_SOCKET\n+\tcmsg.Type = SCM_RIGHTS\n+\tcmsg.SetLen(CmsgLen(datalen))\n+\n+\tdata := uintptr(cmsgData(cmsg))\n+\tfor _, fd := range fds {\n+\t\t*(*int32)(unsafe.Pointer(data)) = int32(fd)\n+\t\tdata += 4\n+\t}\n+\n+\treturn buf\n+}\n+\n+// ParseUnixRights decodes a socket control message that contains an\n+// integer array of open file descriptors from another process.\n+func ParseUnixRights(msg *SocketControlMessage) ([]int, int) {\n+\tif msg.Header.Level != SOL_SOCKET {\n+\t\treturn nil, EINVAL\n+\t}\n+\tif msg.Header.Type != SCM_RIGHTS {\n+\t\treturn nil, EINVAL\n+\t}\n+\tfds := make([]int, len(msg.Data)>>2)\n+\tfor i, j := 0, 0; i < len(msg.Data); i += 4 {\n+\t\tfds[j] = int(*(*int32)(unsafe.Pointer(&msg.Data[i])))\n+\t\tj++\n+\t}\n+\treturn fds, 0\n+}"}, {"sha": "9da8a686e3edb75d4d2f360dfae645c42ba43419", "filename": "libgo/go/syscall/socket.go", "status": "added", "additions": 423, "deletions": 0, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,423 @@\n+// socket.go -- Socket handling.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Low-level socket interface.\n+// Only for implementing net package.\n+// DO NOT USE DIRECTLY.\n+\n+package syscall\n+\n+import \"unsafe\"\n+\n+// For testing: clients can set this flag to force\n+// creation of IPv6 sockets to return EAFNOSUPPORT.\n+var SocketDisableIPv6 bool\n+\n+type Sockaddr interface {\n+\tsockaddr() (ptr *RawSockaddrAny, len Socklen_t, errno int)\t// lowercase; only we can define Sockaddrs\n+}\n+\n+type RawSockaddrAny struct {\n+\tAddr RawSockaddr\n+\tPad [12]int8\n+}\n+\n+const SizeofSockaddrAny = 0x1c\n+\n+type SockaddrInet4 struct {\n+\tPort int\n+\tAddr [4]byte\n+\traw RawSockaddrInet4\n+}\n+\n+func (sa *SockaddrInet4) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+\tif sa.Port < 0 || sa.Port > 0xFFFF {\n+\t\treturn nil, 0, EINVAL\n+\t}\n+\tsa.raw.Family = AF_INET\n+\tn := sa.raw.setLen()\n+\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))\n+\tp[0] = byte(sa.Port>>8)\n+\tp[1] = byte(sa.Port)\n+\tfor i := 0; i < len(sa.Addr); i++ {\n+\t\tsa.raw.Addr[i] = sa.Addr[i]\n+\t}\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, 0\n+}\n+\n+type SockaddrInet6 struct {\n+\tPort int\n+\tZoneId uint32\n+\tAddr [16]byte\n+\traw RawSockaddrInet6\n+}\n+\n+func (sa *SockaddrInet6) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+\tif sa.Port < 0 || sa.Port > 0xFFFF {\n+\t\treturn nil, 0, EINVAL\n+\t}\n+\tsa.raw.Family = AF_INET6\n+\tn := sa.raw.setLen()\n+\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))\n+\tp[0] = byte(sa.Port>>8)\n+\tp[1] = byte(sa.Port)\n+\tsa.raw.Scope_id = sa.ZoneId\n+\tfor i := 0; i < len(sa.Addr); i++ {\n+\t\tsa.raw.Addr[i] = sa.Addr[i]\n+\t}\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, 0\n+}\n+\n+type SockaddrUnix struct {\n+\tName string\n+\traw RawSockaddrUnix\n+}\n+\n+func (sa *SockaddrUnix) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+\tname := sa.Name\n+\tn := len(name)\n+\tif n >= len(sa.raw.Path) || n == 0 {\n+\t\treturn nil, 0, EINVAL\n+\t}\n+\tsa.raw.Family = AF_UNIX\n+\tsa.raw.setLen(n)\n+\tfor i := 0; i < n; i++ {\n+\t\tsa.raw.Path[i] = int8(name[i])\n+\t}\n+\tif sa.raw.Path[0] == '@' {\n+\t\tsa.raw.Path[0] = 0\n+\t}\n+\n+\t// length is family (uint16), name, NUL.\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), 2 + Socklen_t(n) + 1, 0\n+}\n+\n+func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {\n+\tswitch rsa.Addr.Family {\n+\tcase AF_UNIX:\n+\t\tpp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))\n+\t\tsa := new(SockaddrUnix)\n+\t\tn, err := pp.getLen()\n+\t\tif err != 0 {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tbytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));\n+\t\tsa.Name = string(bytes[0:n]);\n+\t\treturn sa, 0;\n+\n+\tcase AF_INET:\n+\t\tpp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));\n+\t\tsa := new(SockaddrInet4);\n+\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n+\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n+\t\tfor i := 0; i < len(sa.Addr); i++ {\n+\t\t\tsa.Addr[i] = pp.Addr[i];\n+\t\t}\n+\t\treturn sa, 0;\n+\n+\tcase AF_INET6:\n+\t\tpp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));\n+\t\tsa := new(SockaddrInet6);\n+\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n+\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n+\t\tfor i := 0; i < len(sa.Addr); i++ {\n+\t\t\tsa.Addr[i] = pp.Addr[i];\n+\t\t}\n+\t\treturn sa, 0;\n+\t}\n+\treturn anyToSockaddrOS(rsa)\n+}\n+\n+//sys\taccept(fd int, sa *RawSockaddrAny, len *Socklen_t) (nfd int, errno int)\n+//accept(fd int, sa *RawSockaddrAny, len *Socklen_t) int\n+\n+func Accept(fd int) (nfd int, sa Sockaddr, errno int) {\n+\tvar rsa RawSockaddrAny\n+\tvar len Socklen_t = SizeofSockaddrAny\n+\tnfd, errno = accept(fd, &rsa, &len)\n+\tif errno != 0 {\n+\t\treturn\n+\t}\n+\tsa, errno = anyToSockaddr(&rsa)\n+\tif errno != 0 {\n+\t\tClose(nfd)\n+\t\tnfd = 0\n+\t}\n+\treturn\n+}\n+\n+//sysnb\tgetsockname(fd int, sa *RawSockaddrAny, len *Socklen_t) (errno int)\n+//getsockname(fd int, sa *RawSockaddrAny, len *Socklen_t) int\n+\n+func Getsockname(fd int) (sa Sockaddr, errno int) {\n+\tvar rsa RawSockaddrAny\n+\tvar len Socklen_t = SizeofSockaddrAny\n+\tif errno = getsockname(fd, &rsa, &len); errno != 0 {\n+\t\treturn\n+\t}\n+\treturn anyToSockaddr(&rsa)\n+}\n+\n+//sysnb getpeername(fd int, sa *RawSockaddrAny, len *Socklen_t) (errno int)\n+//getpeername(fd int, sa *RawSockaddrAny, len *Socklen_t) int\n+\n+func Getpeername(fd int) (sa Sockaddr, errno int) {\n+\tvar rsa RawSockaddrAny\n+\tvar len Socklen_t = SizeofSockaddrAny\n+\tif getpeername(fd, &rsa, &len); errno != 0 {\n+\t\treturn\n+\t}\n+\treturn anyToSockaddr(&rsa)\n+}\n+\n+//sys\tbind(fd int, sa *RawSockaddrAny, len Socklen_t) (errno int)\n+//bind(fd int, sa *RawSockaddrAny, len Socklen_t) int\n+\n+func Bind(fd int, sa Sockaddr) (errno int) {\n+\tptr, n, err := sa.sockaddr()\n+\tif err != 0 {\n+\t\treturn err\n+\t}\n+\treturn bind(fd, ptr, n)\n+}\n+\n+//sys\tconnect(s int, addr *RawSockaddrAny, addrlen Socklen_t) (errno int)\n+//connect(s int, addr *RawSockaddrAny, addrlen Socklen_t) int\n+\n+func Connect(fd int, sa Sockaddr) (errno int) {\n+\tptr, n, err := sa.sockaddr()\n+\tif err != 0 {\n+\t\treturn err\n+\t}\n+\treturn connect(fd, ptr, n)\n+}\n+\n+//sysnb\tsocket(domain int, typ int, proto int) (fd int, errno int)\n+//socket(domain int, typ int, protocol int) int\n+\n+func Socket(domain, typ, proto int) (fd, errno int) {\n+\tif domain == AF_INET6 && SocketDisableIPv6 {\n+\t\treturn -1, EAFNOSUPPORT\n+\t}\n+\tfd, errno = socket(domain, typ, proto)\n+\treturn\n+}\n+\n+//sysnb\tsocketpair(domain int, typ int, proto int, fd *[2]int) (errno int)\n+//socketpair(domain int, typ int, protocol int, fd *[2]int) int\n+\n+func Socketpair(domain, typ, proto int) (fd [2]int, errno int) {\n+\terrno = socketpair(domain, typ, proto, &fd)\n+\treturn\n+}\n+\n+//sys\tgetsockopt(s int, level int, name int, val uintptr, vallen *Socklen_t) (errno int)\n+//getsockopt(s int, level int, name int, val *byte, vallen *Socklen_t) int\n+\n+func GetsockoptInt(fd, level, opt int) (value, errno int) {\n+\tvar n int32\n+\tvallen := Socklen_t(4)\n+\terrno = getsockopt(fd, level, opt, (uintptr)(unsafe.Pointer(&n)), &vallen)\n+\treturn int(n), errno\n+}\n+\n+func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, errno int) {\n+\tvallen := Socklen_t(4)\n+\terrno = getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value[0])), &vallen)\n+\treturn value, errno\n+}\n+\n+func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, int) {\n+\tvar value IPMreq\n+\tvallen := Socklen_t(SizeofIPMreq)\n+\terrno := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n+\treturn &value, errno\n+}\n+\n+/* FIXME: mksysinfo needs to support IPMreqn.\n+\n+func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, int) {\n+\tvar value IPMreqn\n+\tvallen := Socklen_t(SizeofIPMreqn)\n+\terrno := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n+\treturn &value, errno\n+}\n+\n+*/\n+\n+/* FIXME: mksysinfo needs to support IPv6Mreq.\n+\n+func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, int) {\n+\tvar value IPv6Mreq\n+\tvallen := Socklen_t(SizeofIPv6Mreq)\n+\terrno := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n+\treturn &value, errno\n+}\n+\n+*/\n+\n+//sys\tsetsockopt(s int, level int, name int, val *byte, vallen Socklen_t) (errno int)\n+//setsockopt(s int, level int, optname int, val *byte, vallen Socklen_t) int\n+\n+func SetsockoptInt(fd, level, opt int, value int) (errno int) {\n+\tvar n = int32(value)\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&n)), 4)\n+}\n+\n+func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (errno int) {\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&value[0])), 4)\n+}\n+\n+func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(tv)), Socklen_t(unsafe.Sizeof(*tv)))\n+}\n+\n+type Linger struct {\n+\tOnoff int32;\n+\tLinger int32;\n+}\n+\n+func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(l)), Socklen_t(unsafe.Sizeof(*l)));\n+}\n+\n+func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (errno int) {\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n+}\n+\n+/* FIXME: mksysinfo needs to support IMPreqn.\n+\n+func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (errno int) {\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n+}\n+\n+*/\n+\n+/* FIXME: mksysinfo needs to support IPv6Mreq.\n+\n+func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (errno int) {\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n+}\n+\n+*/\n+\n+func SetsockoptString(fd, level, opt int, s string) (errno int) {\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&[]byte(s)[0])), Socklen_t(len(s)))\n+}\n+\n+//sys\trecvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *Socklen_t) (n int, errno int)\n+//recvfrom(fd int, buf *byte, len Size_t, flags int, from *RawSockaddrAny, fromlen *Socklen_t) Ssize_t\n+\n+func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {\n+\tvar rsa RawSockaddrAny\n+\tvar len Socklen_t = SizeofSockaddrAny\n+\tif n, errno = recvfrom(fd, p, flags, &rsa, &len); errno != 0 {\n+\t\treturn\n+\t}\n+\tfrom, errno = anyToSockaddr(&rsa)\n+\treturn\n+}\n+\n+//sys\tsendto(s int, buf []byte, flags int, to *RawSockaddrAny, tolen Socklen_t) (errno int)\n+//sendto(s int, buf *byte, len Size_t, flags int, to *RawSockaddrAny, tolen Socklen_t) Ssize_t\n+\n+func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {\n+\tptr, n, err := to.sockaddr()\n+\tif err != 0 {\n+\t\treturn err\n+\t}\n+\treturn sendto(fd, p, flags, ptr, n)\n+}\n+\n+//sys\trecvmsg(s int, msg *Msghdr, flags int) (n int, errno int)\n+//recvmsg(s int, msg *Msghdr, flags int) Ssize_t\n+\n+func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, errno int) {\n+\tvar msg Msghdr\n+\tvar rsa RawSockaddrAny\n+\tmsg.Name = (*byte)(unsafe.Pointer(&rsa))\n+\tmsg.Namelen = uint32(SizeofSockaddrAny)\n+\tvar iov Iovec\n+\tif len(p) > 0 {\n+\t\tiov.Base = (*byte)(unsafe.Pointer(&p[0]))\n+\t\tiov.SetLen(len(p))\n+\t}\n+\tvar dummy byte\n+\tif len(oob) > 0 {\n+\t\t// receive at least one normal byte\n+\t\tif len(p) == 0 {\n+\t\t\tiov.Base = &dummy\n+\t\t\tiov.SetLen(1)\n+\t\t}\n+\t\tmsg.Control = (*byte)(unsafe.Pointer(&oob[0]))\n+\t\tmsg.SetControllen(len(oob))\n+\t}\n+\tmsg.Iov = &iov\n+\tmsg.Iovlen = 1\n+\tif n, errno = recvmsg(fd, &msg, flags); errno != 0 {\n+\t\treturn\n+\t}\n+\toobn = int(msg.Controllen)\n+\trecvflags = int(msg.Flags)\n+\t// source address is only specified if the socket is unconnected\n+\tif rsa.Addr.Family != AF_UNSPEC {\n+\t\tfrom, errno = anyToSockaddr(&rsa)\n+\t}\n+\treturn\n+}\n+\n+//sys\tsendmsg(s int, msg *Msghdr, flags int) (errno int)\n+//sendmsg(s int, msg *Msghdr, flags int) Ssize_t\n+\n+func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (errno int) {\n+\tvar ptr *RawSockaddrAny\n+\tvar salen Socklen_t\n+\tif to != nil {\n+\t\tvar err int\n+\t\tptr, salen, err = to.sockaddr()\n+\t\tif err != 0 {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tvar msg Msghdr\n+\tmsg.Name = (*byte)(unsafe.Pointer(ptr))\n+\tmsg.Namelen = uint32(salen)\n+\tvar iov Iovec\n+\tif len(p) > 0 {\n+\t\tiov.Base = (*byte)(unsafe.Pointer(&p[0]))\n+\t\tiov.SetLen(len(p))\n+\t}\n+\tvar dummy byte\n+\tif len(oob) > 0 {\n+\t\t// send at least one normal byte\n+\t\tif len(p) == 0 {\n+\t\t\tiov.Base = &dummy\n+\t\t\tiov.SetLen(1)\n+\t\t}\n+\t\tmsg.Control = (*byte)(unsafe.Pointer(&oob[0]))\n+\t\tmsg.SetControllen(len(oob))\n+\t}\n+\tmsg.Iov = &iov\n+\tmsg.Iovlen = 1\n+\tif errno = sendmsg(fd, &msg, flags); errno != 0 {\n+\t\treturn\n+\t}\n+\treturn\n+}\n+\n+//sys\tListen(fd int, n int) (errno int)\n+//listen(fd int, n int) int\n+\n+//sys\tShutdown(fd int, how int) (errno int)\n+//shutdown(fd int, how int) int\n+\n+func (iov *Iovec) SetLen(length int) {\n+\tiov.Len = Iovec_len_t(length)\n+}\n+\n+func (msghdr *Msghdr) SetControllen(length int) {\n+\tmsghdr.Controllen = Msghdr_controllen_t(length)\n+}"}, {"sha": "735baf98684292d309841f037a48366a24f58fe1", "filename": "libgo/go/syscall/socket_bsd.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "previous_filename": "libgo/syscalls/socket_bsd.go"}, {"sha": "6f2aaaff4d0b1ae3d67fb7dc3fd4ba955a93e3e4", "filename": "libgo/go/syscall/socket_irix.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "previous_filename": "libgo/syscalls/socket_irix.go"}, {"sha": "20a37f7390bc89f732ece270d8a1a1d5f3fe6822", "filename": "libgo/go/syscall/socket_linux.go", "status": "renamed", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -57,31 +57,31 @@ func (sa *SockaddrNetlink) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n }\n \n type RawSockaddrInet4 struct {\n-\tFamily uint16;\n-\tPort uint16;\n-\tAddr [4]byte /* in_addr */;\n-\tZero [8]uint8;\n+\tFamily uint16\n+\tPort uint16\n+\tAddr [4]byte /* in_addr */\n+\tZero [8]uint8\n }\n \n func (sa *RawSockaddrInet4) setLen() Socklen_t {\n \treturn SizeofSockaddrInet4\n }\n \n type RawSockaddrInet6 struct {\n-\tFamily uint16;\n-\tPort uint16;\n-\tFlowinfo uint32;\n-\tAddr [16]byte /* in6_addr */;\n-\tScope_id uint32;\n+\tFamily uint16\n+\tPort uint16\n+\tFlowinfo uint32\n+\tAddr [16]byte /* in6_addr */\n+\tScope_id uint32\n }\n \n func (sa *RawSockaddrInet6) setLen() Socklen_t {\n \treturn SizeofSockaddrInet6\n }\n \n type RawSockaddrUnix struct {\n-\tFamily uint16;\n-\tPath [108]int8;\n+\tFamily uint16\n+\tPath [108]int8\n }\n \n func (sa *RawSockaddrUnix) setLen(int) {\n@@ -94,17 +94,17 @@ func (sa *RawSockaddrUnix) getLen() (int, int) {\n \t\t// (This is the standard convention.)\n \t\t// Not friendly to overwrite in place,\n \t\t// but the callers below don't care.\n-\t\tsa.Path[0] = '@';\n+\t\tsa.Path[0] = '@'\n \t}\n \n \t// Assume path ends at NUL.\n \t// This is not technically the Linux semantics for\n \t// abstract Unix domain sockets--they are supposed\n \t// to be uninterpreted fixed-size binary blobs--but\n \t// everyone uses this convention.\n-\tn := 0;\n+\tn := 0\n \tfor n < len(sa.Path) - 3 && sa.Path[n] != 0 {\n-\t\tn++;\n+\t\tn++\n \t}\n \n \treturn n, 0\n@@ -128,8 +128,8 @@ type RawSockaddrNetlink struct {\n }\n \n type RawSockaddr struct {\n-\tFamily uint16;\n-\tData [14]int8;\n+\tFamily uint16\n+\tData [14]int8\n }\n \n // BindToDevice binds the socket associated with fd to device.\n@@ -161,5 +161,23 @@ func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, int) {\n \t\t}\n \t\treturn sa, 0\n \t}\n-\treturn nil, EAFNOSUPPORT;\n+\treturn nil, EAFNOSUPPORT\n+}\n+\n+// We don't take this type directly from the header file because it\n+// uses a union.  FIXME.\n+\n+type EpollEvent struct {\n+\tEvents uint32\n+\tFd int32\n+\tPad int32\n }\n+\n+//sysnb\tEpollCreate(size int) (fd int, errno int)\n+//epoll_create(size int) int\n+\n+//sysnb\tEpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int)\n+//epoll_ctl(epfd int, op int, fd int, event *EpollEvent) int\n+\n+//sys\tEpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int)\n+//epoll_wait(epfd int, events *EpollEvent, maxevents int, timeout int) int", "previous_filename": "libgo/syscalls/socket_linux.go"}, {"sha": "376707858a6000556433705ceb510c953c49adf3", "filename": "libgo/go/syscall/socket_solaris.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsocket_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_solaris.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "previous_filename": "libgo/syscalls/socket_solaris.go"}, {"sha": "0fce842e8c1351bdfac6723c51a0a76875037fc8", "filename": "libgo/go/syscall/str.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fstr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fstr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fstr.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+func itoa(val int) string { // do it here rather than with fmt to avoid dependency\n+\tif val < 0 {\n+\t\treturn \"-\" + itoa(-val)\n+\t}\n+\tvar buf [32]byte // big enough for int64\n+\ti := len(buf) - 1\n+\tfor val >= 10 {\n+\t\tbuf[i] = byte(val%10 + '0')\n+\t\ti--\n+\t\tval /= 10\n+\t}\n+\tbuf[i] = byte(val + '0')\n+\treturn string(buf[i:])\n+}"}, {"sha": "a802ba0bbf28a73a42a12e66a3bd84ddef80cc94", "filename": "libgo/go/syscall/syscall.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package syscall contains an interface to the low-level operating system\n+// primitives.  The details vary depending on the underlying system.\n+// Its primary use is inside other packages that provide a more portable\n+// interface to the system, such as \"os\", \"time\" and \"net\".  Use those\n+// packages rather than this one if you can.\n+// For details of the functions and data types in this package consult\n+// the manuals for the appropriate operating system.\n+// These calls return errno == 0 to indicate success; otherwise\n+// errno is an operating system error number describing the failure.\n+package syscall\n+\n+import \"unsafe\"\n+\n+// StringByteSlice returns a NUL-terminated slice of bytes\n+// containing the text of s.\n+func StringByteSlice(s string) []byte {\n+\ta := make([]byte, len(s)+1)\n+\tcopy(a, s)\n+\treturn a\n+}\n+\n+// StringBytePtr returns a pointer to a NUL-terminated array of bytes\n+// containing the text of s.\n+func StringBytePtr(s string) *byte { return &StringByteSlice(s)[0] }\n+\n+// Single-word zero for use when we need a valid pointer to 0 bytes.\n+// See mksyscall.pl.\n+var _zero uintptr\n+\n+var dummy *byte\n+const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))"}, {"sha": "aca9c7bf5ef4469e6839aaf07f9010aa92c8dfea", "filename": "libgo/go/syscall/syscall_linux_386.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_386.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "previous_filename": "libgo/syscalls/syscall_linux_386.go"}, {"sha": "d58f8eb13a5187534423e604b751224b300903c7", "filename": "libgo/go/syscall/syscall_linux_alpha.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_alpha.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_alpha.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_alpha.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "previous_filename": "libgo/syscalls/syscall_linux_alpha.go"}, {"sha": "9932579cc10a93ef702bb53fb2df4525ff28e09f", "filename": "libgo/go/syscall/syscall_linux_amd64.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_amd64.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "previous_filename": "libgo/syscalls/syscall_linux_amd64.go"}, {"sha": "76c05cb546a1a229d5fff24bc05e187a44dd9706", "filename": "libgo/go/syscall/syscall_stubs.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_stubs.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// These are stubs.\n+\n+package syscall\n+\n+func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n+\tz := -1\n+\treturn uintptr(z), 0, uintptr(ENOSYS)\n+}\n+\n+func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n+\tz := -1\n+\treturn uintptr(z), 0, uintptr(ENOSYS)\n+}\n+\n+func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n+\tz := -1\n+\treturn uintptr(z), 0, uintptr(ENOSYS)\n+}\n+\n+func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n+\tz := -1\n+\treturn uintptr(z), 0, uintptr(ENOSYS)\n+}"}, {"sha": "c734b2cf06aad8ef17ffb6f729ee860950a717c7", "filename": "libgo/go/syscall/syscall_unix.go", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux openbsd\n+\n+package syscall\n+\n+import (\n+\t\"sync\"\n+\t\"unsafe\"\n+)\n+\n+var (\n+\tStdin  = 0\n+\tStdout = 1\n+\tStderr = 2\n+)\n+\n+func c_syscall32(trap int32, a1, a2, a3, a4, a5, a6 int32) int32 __asm__ (\"syscall\");\n+func c_syscall64(trap int64, a1, a2, a3, a4, a5, a6 int64) int64 __asm__ (\"syscall\");\n+\n+// Do a system call.  We look at the size of uintptr to see how to pass\n+// the arguments, so that we don't pass a 64-bit value when the function\n+// expects a 32-bit one.\n+func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n+\tentersyscall()\n+\tvar r uintptr\n+\tif unsafe.Sizeof(r) == 4 {\n+\t\tr1 := c_syscall32(int32(trap), int32(a1), int32(a2), int32(a3), 0, 0, 0)\n+\t\tr = uintptr(r1)\n+\t} else {\n+\t\tr1 := c_syscall64(int64(trap), int64(a1), int64(a2), int64(a3), 0, 0, 0)\n+\t\tr = uintptr(r1)\n+\t}\n+\terrno := GetErrno()\n+\texitsyscall()\n+\treturn r, 0, uintptr(errno)\n+}\n+\n+func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n+\tentersyscall()\n+\tvar r uintptr\n+\tif unsafe.Sizeof(r) == 4 {\n+\t\tr1 := c_syscall32(int32(trap), int32(a1), int32(a2), int32(a3),\n+    \t\t\tint32(a4), int32(a5), int32(a6))\n+\t\tr = uintptr(r1)\n+\t} else {\n+\t\tr1 := c_syscall64(int64(trap), int64(a1), int64(a2), int64(a3),\n+\t\t\tint64(a4), int64(a5), int64(a6))\n+\t\tr = uintptr(r1)\n+\t}\n+\terrno := GetErrno()\n+\texitsyscall()\n+\treturn r, 0, uintptr(errno)\n+}\n+\n+func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n+\tvar r uintptr\n+\tif unsafe.Sizeof(r) == 4 {\n+\t\tr1 := c_syscall32(int32(trap), int32(a1), int32(a2), int32(a3), 0, 0, 0)\n+\t\tr = uintptr(r1)\n+\t} else {\n+\t\tr1 := c_syscall64(int64(trap), int64(a1), int64(a2), int64(a3), 0, 0, 0)\n+\t\tr = uintptr(r1)\n+\t}\n+\terrno := GetErrno()\n+\treturn r, 0, uintptr(errno)\n+}\n+\n+func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n+\tvar r uintptr\n+\tif unsafe.Sizeof(r) == 4 {\n+\t\tr1 := c_syscall32(int32(trap), int32(a1), int32(a2), int32(a3),\n+    \t\t\tint32(a4), int32(a5), int32(a6))\n+\t\tr = uintptr(r1)\n+\t} else {\n+\t\tr1 := c_syscall64(int64(trap), int64(a1), int64(a2), int64(a3),\n+\t\t\tint64(a4), int64(a5), int64(a6))\n+\t\tr = uintptr(r1)\n+\t}\n+\terrno := GetErrno()\n+\treturn r, 0, uintptr(errno)\n+}\n+\n+// Mmap manager, for use by operating system-specific implementations.\n+// Gccgo only has one implementation but we do this to correspond to gc.\n+\n+type mmapper struct {\n+\tsync.Mutex\n+\tactive map[*byte][]byte // active mappings; key is last byte in mapping\n+\tmmap   func(addr, length uintptr, prot, flags, fd int, offset int64) (uintptr, int)\n+\tmunmap func(addr uintptr, length uintptr) int\n+}\n+\n+func (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, errno int) {\n+\tif length <= 0 {\n+\t\treturn nil, EINVAL\n+\t}\n+\n+\t// Map the requested memory.\n+\taddr, errno := m.mmap(0, uintptr(length), prot, flags, fd, offset)\n+\tif errno != 0 {\n+\t\treturn nil, errno\n+\t}\n+\n+\t// Slice memory layout\n+\tvar sl = struct {\n+\t\taddr uintptr\n+\t\tlen  int\n+\t\tcap  int\n+\t}{addr, length, length}\n+\n+\t// Use unsafe to turn sl into a []byte.\n+\tb := *(*[]byte)(unsafe.Pointer(&sl))\n+\n+\t// Register mapping in m and return it.\n+\tp := &b[cap(b)-1]\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\tm.active[p] = b\n+\treturn b, 0\n+}\n+\n+func (m *mmapper) Munmap(data []byte) (errno int) {\n+\tif len(data) == 0 || len(data) != cap(data) {\n+\t\treturn EINVAL\n+\t}\n+\n+\t// Find the base of the mapping.\n+\tp := &data[cap(data)-1]\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\tb := m.active[p]\n+\tif b == nil || &b[0] != &data[0] {\n+\t\treturn EINVAL\n+\t}\n+\n+\t// Unmap the memory and update m.\n+\tif errno := m.munmap(uintptr(unsafe.Pointer(&b[0])), uintptr(len(b))); errno != 0 {\n+\t\treturn errno\n+\t}\n+\tm.active[p] = nil, false\n+\treturn 0\n+}\n+\n+var mapper = &mmapper{\n+\tactive: make(map[*byte][]byte),\n+\tmmap:   mmap,\n+\tmunmap: munmap,\n+}\n+\n+func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, errno int) {\n+\treturn mapper.Mmap(fd, offset, length, prot, flags)\n+}\n+\n+func Munmap(b []byte) (errno int) {\n+\treturn mapper.Munmap(b)\n+}"}, {"sha": "cee84c9cb525cc138f0d0c007970166160b59a8a", "filename": "libgo/go/syscall/wait.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fwait.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fgo%2Fsyscall%2Fwait.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fwait.c?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -0,0 +1,107 @@\n+/* wait.c -- functions for getting wait status values.\n+\n+   Copyright 2011 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.\n+\n+   We use C code to extract the wait status so that we can easily be\n+   OS-independent.  */\n+\n+#define _GNU_SOURCE\n+#define __EXTENSIONS__\n+\n+#include <stdint.h>\n+#include <sys/wait.h>\n+\n+extern _Bool Exited (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.Exited.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+_Bool\n+Exited (uint32_t *w)\n+{\n+  return WIFEXITED (*w) != 0;\n+}\n+\n+extern _Bool Signaled (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.Signaled.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+_Bool\n+Signaled (uint32_t *w)\n+{\n+  return WIFSIGNALED (*w) != 0;\n+}\n+\n+extern _Bool Stopped (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.Stopped.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+_Bool\n+Stopped (uint32_t *w)\n+{\n+  return WIFSTOPPED (*w) != 0;\n+}\n+\n+extern _Bool Continued (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.Continued.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+_Bool\n+Continued (uint32_t *w)\n+{\n+  return WIFCONTINUED (*w) != 0;\n+}\n+\n+extern _Bool CoreDump (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.CoreDump.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+_Bool\n+CoreDump (uint32_t *w)\n+{\n+  return WCOREDUMP (*w) != 0;\n+}\n+\n+extern int ExitStatus (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.ExitStatus.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+int\n+ExitStatus (uint32_t *w)\n+{\n+  if (!WIFEXITED (*w))\n+    return -1;\n+  return WEXITSTATUS (*w);\n+}\n+\n+extern int Signal (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.Signal.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+int\n+Signal (uint32_t *w)\n+{\n+  if (!WIFSIGNALED (*w))\n+    return -1;\n+  return WTERMSIG (*w);\n+}\n+\n+extern int StopSignal (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.StopSignal.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+int\n+StopSignal (uint32_t *w)\n+{\n+  if (!WIFSTOPPED (*w))\n+    return -1;\n+  return WSTOPSIG (*w);\n+}\n+\n+extern int TrapCause (uint32_t *w)\n+  __asm__ (\"libgo_syscall.syscall.TrapCause.N32_libgo_syscall.syscall.WaitStatus\");\n+\n+int\n+TrapCause (uint32_t *w)\n+{\n+#ifndef __linux__\n+  return -1;\n+#else\n+  if (!WIFSTOPPED (*w) || WSTOPSIG (*w) != SIGTRAP)\n+    return -1;\n+  return *w >> 16;\n+#endif\n+}"}, {"sha": "6bc10ee0c8af46e8e8b935033ec51ba7aafc2b68", "filename": "libgo/mksysinfo.sh", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fmksysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fmksysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksysinfo.sh?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -197,16 +197,13 @@ if ! grep '^const EPOLLRDHUP' ${OUT} >/dev/null 2>&1; then\n   echo \"const EPOLLRDHUP = 0x2000\" >> ${OUT}\n fi\n \n-# Ptrace constants.  We don't expose all the PTRACE flags, just the\n-# PTRACE_O_xxx and PTRACE_EVENT_xxx ones.\n-grep '^const _PTRACE_O' gen-sysinfo.go |\n-  sed -e 's/^\\(const \\)_\\(PTRACE_O[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n-grep '^const _PTRACE_EVENT' gen-sysinfo.go |\n-  sed -e 's/^\\(const \\)_\\(PTRACE_EVENT[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n-# We need PTRACE_SETOPTIONS and PTRACE_GETEVENTMSG, but they are not\n-# defined in older versions of glibc.\n-if ! grep '^const _PTRACE_SETOPTIONS' ${OUT} > /dev/null 2>&1; then\n-  echo \"const _PTRACE_SETOPTIONS = 0x4200\" >> ${OUT}\n+# Ptrace constants.\n+grep '^const _PTRACE' gen-sysinfo.go |\n+  sed -e 's/^\\(const \\)_\\(PTRACE[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n+# We need some ptrace options that are not defined in older versions\n+# of glibc.\n+if ! grep '^const PTRACE_SETOPTIONS' ${OUT} > /dev/null 2>&1; then\n+  echo \"const PTRACE_SETOPTIONS = 0x4200\" >> ${OUT}\n fi\n if ! grep '^const PTRACE_O_TRACESYSGOOD' ${OUT} > /dev/null 2>&1; then\n   echo \"const PTRACE_O_TRACESYSGOOD = 0x1\" >> ${OUT}\n@@ -254,7 +251,7 @@ if ! grep '^const PTRACE_EVENT_EXIT' ${OUT} > /dev/null 2>&1; then\n   echo \"const PTRACE_EVENT_EXIT = 6\" >> ${OUT}\n fi\n if ! grep '^const _PTRACE_TRACEME' ${OUT} > /dev/null 2>&1; then\n-  echo \"const _PTRACE_TRACEME = 0\" >> ${OUT}\n+  echo \"const PTRACE_TRACEME = 0\" >> ${OUT}\n fi\n \n # The registers returned by PTRACE_GETREGS.  This is probably\n@@ -474,6 +471,11 @@ grep '^type _ip_mreq ' gen-sysinfo.go | \\\n       -e 's/_in_addr/[4]byte/g' \\\n     >> ${OUT}\n \n+# The size of the ip_mreq struct.\n+if grep 'type IPMreq ' ${OUT} > /dev/null 2>&1; then\n+  echo 'var SizeofIPMreq = int(unsafe.Sizeof(IPMreq{}))' >> ${OUT}\n+fi\n+\n # Try to guess the type to use for fd_set.\n fd_set=`grep '^type _fd_set ' gen-sysinfo.go || true`\n fds_bits_type=\"_C_long\"\n@@ -531,6 +533,25 @@ if ! grep '^const NLMSG_HDRLEN' ${OUT} > /dev/null 2>&1; then\n   fi\n fi\n \n+# The rtmsg struct.\n+grep '^type _rtmsg ' gen-sysinfo.go | \\\n+    sed -e 's/_rtmsg/RtMsg/' \\\n+      -e 's/rtm_family/Family/' \\\n+      -e 's/rtm_dst_len/Dst_len/' \\\n+      -e 's/rtm_src_len/Src_len/' \\\n+      -e 's/rtm_tos/Tos/' \\\n+      -e 's/rtm_table/Table/' \\\n+      -e 's/rtm_protocol/Procotol/' \\\n+      -e 's/rtm_scope/Scope/' \\\n+      -e 's/rtm_type/Type/' \\\n+      -e 's/rtm_flags/Flags/' \\\n+    >> ${OUT}\n+\n+# The size of the rtmsg struct.\n+if grep 'type RtMsg ' ${OUT} > /dev/null 2>&1; then\n+  echo 'var SizeofRtMsg = int(unsafe.Sizeof(RtMsg{}))' >> ${OUT}\n+fi\n+\n # The rtgenmsg struct.\n grep '^type _rtgenmsg ' gen-sysinfo.go | \\\n     sed -e 's/_rtgenmsg/RtGenmsg/' \\"}, {"sha": "521bcd648ccdb09df80796a806f409d438c7992a", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -71,3 +71,21 @@ runtime_setcpuprofilerate(void (*fn)(uintptr*, int32), int32 hz)\n \tif(hz != 0)\n \t\truntime_resetcpuprofiler(hz);\n }\n+\n+/* The entersyscall and exitsyscall functions aren't used for anything\n+   yet.  Eventually they will be used to switch to a new OS thread\n+   when making a potentially-blocking library call.  */\n+\n+void runtime_entersyscall() __asm__(\"libgo_syscall.syscall.entersyscall\");\n+\n+void\n+runtime_entersyscall()\n+{\n+}\n+\n+void runtime_exitsyscall() __asm__(\"libgo_syscall.syscall.exitsyscall\");\n+\n+void\n+runtime_exitsyscall()\n+{\n+}"}, {"sha": "b6bff0fb00b3df500cc8be716ecdc79a01b8add3", "filename": "libgo/syscalls/errstr_decl.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Ferrstr_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Ferrstr_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Ferrstr_decl.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,9 +0,0 @@\n-// errstr.go -- Declare strerror_r.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-func libc_strerror_r(int, *byte, Size_t) int __asm__ (\"strerror_r\")"}, {"sha": "4c1cb82a073d12930c23069b1bad205bf76c6567", "filename": "libgo/syscalls/errstr_decl_linux.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Ferrstr_decl_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Ferrstr_decl_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Ferrstr_decl_linux.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,9 +0,0 @@\n-// errstr_decl_linux.go -- Declare strerror_r for GNU/Linux.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-func libc_strerror_r(int, *byte, Size_t) int __asm__ (\"__xpg_strerror_r\")"}, {"sha": "b83eedc8e1cfd30cb861c537ccf25de3e6c7393f", "filename": "libgo/syscalls/errstr_decl_rtems.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Ferrstr_decl_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Ferrstr_decl_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Ferrstr_decl_rtems.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,10 +0,0 @@\n-// errstr.go -- Declare strerror_r for RTEMS.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-// RTEMS uses strerror_r in newlib, which is a GNU extension returning a char *.\n-func libc_strerror_r(int, *byte, Size_t) *byte __asm__ (\"strerror_r\")"}, {"sha": "f6b453bdc7397658bef9d86340160b959ad056fd", "filename": "libgo/syscalls/errstr_rtems.go", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Ferrstr_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Ferrstr_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Ferrstr_rtems.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,26 +0,0 @@\n-// errstr_rtems.go -- RTEMS specific error strings.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-func Errstr(errno int) string {\n-\tfor len := Size_t(128); ; len *= 2 {\n-\t\tb := make([]byte, len+1)\n-\n-\t\t// The newlib strerror_r always returns the string in buffer.\n-\t\tlibc_strerror_r(errno, &b[0], len)\n-\t\tb[len] = 0\n-\n-\t\ti := 0\n-\t\tfor b[i] != 0 {\n-\t\t\ti++\n-\t\t}\n-\n-\t\tif Size_t(i) < len {\n-\t\t\treturn string(b[0:i])\n-\t\t}\n-\t}\n-}"}, {"sha": "c8a68a058b372b4bca66c15f147d6497c14322eb", "filename": "libgo/syscalls/exec_helpers.go", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fexec_helpers.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fexec_helpers.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fexec_helpers.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,154 +0,0 @@\n-// exec_helpers.go -- helper functions used with fork, exec, wait.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"sync\"\n-\n-// Lock synchronizing creation of new file descriptors with fork.\n-//\n-// We want the child in a fork/exec sequence to inherit only the\n-// file descriptors we intend.  To do that, we mark all file\n-// descriptors close-on-exec and then, in the child, explicitly\n-// unmark the ones we want the exec'ed program to keep.\n-// Unix doesn't make this easy: there is, in general, no way to\n-// allocate a new file descriptor close-on-exec.  Instead you\n-// have to allocate the descriptor and then mark it close-on-exec.\n-// If a fork happens between those two events, the child's exec\n-// will inherit an unwanted file descriptor.\n-//\n-// This lock solves that race: the create new fd/mark close-on-exec\n-// operation is done holding ForkLock for reading, and the fork itself\n-// is done holding ForkLock for writing.  At least, that's the idea.\n-// There are some complications.\n-//\n-// Some system calls that create new file descriptors can block\n-// for arbitrarily long times: open on a hung NFS server or named\n-// pipe, accept on a socket, and so on.  We can't reasonably grab\n-// the lock across those operations.\n-//\n-// It is worse to inherit some file descriptors than others.\n-// If a non-malicious child accidentally inherits an open ordinary file,\n-// that's not a big deal.  On the other hand, if a long-lived child\n-// accidentally inherits the write end of a pipe, then the reader\n-// of that pipe will not see EOF until that child exits, potentially\n-// causing the parent program to hang.  This is a common problem\n-// in threaded C programs that use popen.\n-//\n-// Luckily, the file descriptors that are most important not to\n-// inherit are not the ones that can take an arbitrarily long time\n-// to create: pipe returns instantly, and the net package uses\n-// non-blocking I/O to accept on a listening socket.\n-// The rules for which file descriptor-creating operations use the\n-// ForkLock are as follows:\n-//\n-// 1) Pipe.    Does not block.  Use the ForkLock.\n-// 2) Socket.  Does not block.  Use the ForkLock.\n-// 3) Accept.  If using non-blocking mode, use the ForkLock.\n-//             Otherwise, live with the race.\n-// 4) Open.    Can block.  Use O_CLOEXEC if available (Linux).\n-//             Otherwise, live with the race.\n-// 5) Dup.     Does not block.  Use the ForkLock.\n-//             On Linux, could use fcntl F_DUPFD_CLOEXEC\n-//             instead of the ForkLock, but only for dup(fd, -1).\n-\n-type WaitStatus int\n-\n-var ForkLock sync.RWMutex\n-\n-// Convert array of string to array\n-// of NUL-terminated byte pointer.\n-func StringArrayPtr(ss []string) []*byte {\n-\tbb := make([]*byte, len(ss)+1);\n-\tfor i := 0; i < len(ss); i++ {\n-\t\tbb[i] = StringBytePtr(ss[i]);\n-\t}\n-\tbb[len(ss)] = nil;\n-\treturn bb;\n-}\n-\n-func CloseOnExec(fd int) {\n-\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n-}\n-\n-func SetNonblock(fd int, nonblocking bool) (errno int) {\n-\tflag, err := fcntl(fd, F_GETFL, 0);\n-\tif err != 0 {\n-\t\treturn err;\n-\t}\n-\tif nonblocking {\n-\t\tflag |= O_NONBLOCK;\n-\t} else {\n-\t\tflag &= ^O_NONBLOCK;\n-\t}\n-\tflag, err = fcntl(fd, F_SETFL, flag);\n-\treturn err;\n-}\n-\n-// Wait status is 7 bits at bottom, either 0 (exited),\n-// 0x7F (stopped), or a signal number that caused an exit.\n-// The 0x80 bit is whether there was a core dump.\n-// An extra number (exit code, signal causing a stop)\n-// is in the high bits.  At least that's the idea.\n-// There are various irregularities.  For example, the\n-// \"continued\" status is 0xFFFF, distinguishing itself\n-// from stopped via the core dump bit.\n-\n-const (\n-\tmask = 0x7F;\n-\tcore = 0x80;\n-\texited = 0x00;\n-\tstopped = 0x7F;\n-\tshift = 8;\n-)\n-\n-func (w WaitStatus) Exited() bool {\n-\treturn w&mask == exited;\n-}\n-\n-func (w WaitStatus) Signaled() bool {\n-\treturn w&mask != stopped && w&mask != exited;\n-}\n-\n-func (w WaitStatus) Stopped() bool {\n-\treturn w&0xFF == stopped;\n-}\n-\n-func (w WaitStatus) Continued() bool {\n-\treturn w == 0xFFFF;\n-}\n-\n-func (w WaitStatus) CoreDump() bool {\n-\treturn w.Signaled() && w&core != 0;\n-}\n-\n-func (w WaitStatus) ExitStatus() int {\n-\tif !w.Exited() {\n-\t\treturn -1;\n-\t}\n-\treturn int(w >> shift) & 0xFF;\n-}\n-\n-func (w WaitStatus) Signal() int {\n-\tif !w.Signaled() {\n-\t\treturn -1;\n-\t}\n-\treturn int(w & mask);\n-}\n-\n-func (w WaitStatus) StopSignal() int {\n-\tif !w.Stopped() {\n-\t\treturn -1;\n-\t}\n-\treturn int(w >> shift) & 0xFF;\n-}\n-\n-func (w WaitStatus) TrapCause() int {\n-\tif w.StopSignal() != SIGTRAP {\n-\t\treturn -1;\n-\t}\n-\treturn int(w >> shift) >> 8;\n-}"}, {"sha": "be7a89b7ff2c81cad5bd520184e2f0cc3ce802ac", "filename": "libgo/syscalls/socket.go", "status": "removed", "additions": 0, "deletions": 392, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsocket.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,392 +0,0 @@\n-// socket.go -- Socket handling.\n-\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Low-level socket interface.\n-// Only for implementing net package.\n-// DO NOT USE DIRECTLY.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-type RawSockaddrAny struct {\n-\tAddr RawSockaddr;\n-\tPad [12]int8;\n-}\n-\n-const SizeofSockaddrAny = 0x1c;\n-\n-// For testing: clients can set this flag to force\n-// creation of IPv6 sockets to return EAFNOSUPPORT.\n-var SocketDisableIPv6 bool\n-\n-type Sockaddr interface {\n-\tsockaddr() (ptr *RawSockaddrAny, len Socklen_t, errno int);\t// lowercase; only we can define Sockaddrs\n-}\n-\n-type SockaddrInet4 struct {\n-\tPort int;\n-\tAddr [4]byte;\n-\traw RawSockaddrInet4;\n-}\n-\n-type SockaddrInet6 struct {\n-\tPort int;\n-\tAddr [16]byte;\n-\traw RawSockaddrInet6;\n-}\n-\n-type SockaddrUnix struct {\n-\tName string;\n-\traw RawSockaddrUnix;\n-}\n-\n-type Linger struct {\n-\tOnoff int32;\n-\tLinger int32;\n-}\n-\n-func (sa *SockaddrInet4) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tif sa.Port < 0 || sa.Port > 0xFFFF {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Family = AF_INET;\n-\tn := sa.raw.setLen()\n-\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));\n-\tp[0] = byte(sa.Port>>8);\n-\tp[1] = byte(sa.Port);\n-\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\tsa.raw.Addr[i] = sa.Addr[i];\n-\t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, 0;\n-}\n-\n-func (sa *SockaddrInet6) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tif sa.Port < 0 || sa.Port > 0xFFFF {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Family = AF_INET6;\n-\tn := sa.raw.setLen()\n-\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));\n-\tp[0] = byte(sa.Port>>8);\n-\tp[1] = byte(sa.Port);\n-\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\tsa.raw.Addr[i] = sa.Addr[i];\n-\t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, 0;\n-}\n-\n-func (sa *SockaddrUnix) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tname := sa.Name;\n-\tn := len(name);\n-\tif n >= len(sa.raw.Path) || n == 0 {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Family = AF_UNIX;\n-\tsa.raw.setLen(n)\n-\tfor i := 0; i < n; i++ {\n-\t\tsa.raw.Path[i] = int8(name[i]);\n-\t}\n-\tif sa.raw.Path[0] == '@' {\n-\t\tsa.raw.Path[0] = 0;\n-\t}\n-\n-\t// length is family (uint16), name, NUL.\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), 2 + Socklen_t(n) + 1, 0;\n-}\n-\n-func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {\n-\tswitch rsa.Addr.Family {\n-\tcase AF_UNIX:\n-\t\tpp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))\n-\t\tsa := new(SockaddrUnix)\n-\t\tn, err := pp.getLen()\n-\t\tif err != 0 {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tbytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));\n-\t\tsa.Name = string(bytes[0:n]);\n-\t\treturn sa, 0;\n-\n-\tcase AF_INET:\n-\t\tpp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrInet4);\n-\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n-\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n-\t\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\t\tsa.Addr[i] = pp.Addr[i];\n-\t\t}\n-\t\treturn sa, 0;\n-\n-\tcase AF_INET6:\n-\t\tpp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrInet6);\n-\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n-\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n-\t\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\t\tsa.Addr[i] = pp.Addr[i];\n-\t\t}\n-\t\treturn sa, 0;\n-\t}\n-\treturn anyToSockaddrOS(rsa)\n-}\n-\n-func libc_accept(fd int, sa *RawSockaddrAny, len *Socklen_t) int __asm__ (\"accept\");\n-func libc_bind(fd int, sa *RawSockaddrAny, len Socklen_t) int __asm__ (\"bind\");\n-func libc_connect(fd int, sa *RawSockaddrAny, len Socklen_t) int __asm__ (\"connect\");\n-func libc_socket(domain, typ, protocol int) int __asm__ (\"socket\");\n-func libc_setsockopt(fd, level, optname int, optval *byte, optlen Socklen_t) int __asm__ (\"setsockopt\");\n-func libc_listen(fd, backlog int) int __asm__ (\"listen\");\n-func libc_getsockopt(fd, level, optname int, optval *byte, optlen *Socklen_t) int __asm__ (\"getsockopt\");\n-func libc_getsockname(fd int, sa *RawSockaddrAny, len *Socklen_t) int __asm__ (\"getsockname\");\n-func libc_getpeername(fd int, sa *RawSockaddrAny, len *Socklen_t) int __asm__ (\"getpeername\");\n-func libc_recv(fd int, buf *byte, len Size_t, flags int) Ssize_t __asm__ (\"recv\");\n-func libc_recvfrom(fd int, buf *byte, len Size_t, flags int,\n-\tfrom *RawSockaddrAny, fromlen *Socklen_t) Ssize_t __asm__(\"recvfrom\");\n-func libc_recvmsg(fd int, msg *Msghdr, flags int) Ssize_t __asm__(\"recvmsg\")\n-func libc_send(fd int, buf *byte, len Size_t, flags int) Ssize_t __asm__(\"send\");\n-func libc_sendto(fd int, buf *byte, len Size_t, flags int,\n-\tto *RawSockaddrAny, tolen Socklen_t) Ssize_t __asm__(\"sendto\");\n-func libc_sendmsg(fd int, msg *Msghdr, flags int) Ssize_t __asm__(\"sendmsg\")\n-func libc_shutdown(fd int, how int) int __asm__ (\"shutdown\");\n-\n-func Accept(fd int) (nfd int, sa Sockaddr, errno int) {\n-\tvar rsa RawSockaddrAny;\n-\tvar len Socklen_t = SizeofSockaddrAny;\n-\tnfd = libc_accept(fd, &rsa, &len);\n-\tif nfd < 0 {\n-\t\terrno = GetErrno();\n-\t\treturn;\n-\t}\n-\tsa, errno = anyToSockaddr(&rsa);\n-\tif errno != 0 {\n-\t\tClose(nfd);\n-\t\tnfd = 0;\n-\t}\n-\treturn;\n-}\n-\n-func Bind(fd int, sa Sockaddr) (errno int) {\n-\tptr, n, err := sa.sockaddr();\n-\tif err != 0 {\n-\t\treturn err;\n-\t}\n-\tif libc_bind(fd, ptr, n) < 0 {\n-\t\terrno = GetErrno();\n-\t}\n-\treturn;\n-}\n-\n-func Connect(fd int, sa Sockaddr) (errno int) {\n-\tptr, n, err := sa.sockaddr();\n-\tif err != 0 {\n-\t\treturn err;\n-\t}\n-\tif libc_connect(fd, ptr, n) < 0 {\n-\t\terrno = GetErrno();\n-\t}\n-\treturn;\n-}\n-\n-func Socket(domain, typ, proto int) (fd, errno int) {\n-  if domain == AF_INET6 && SocketDisableIPv6 {\n-    return -1, EAFNOSUPPORT\n-  }\n-  fd = libc_socket(int(domain), int(typ), int(proto));\n-  if fd < 0 {\n-    errno = GetErrno();\n-  }\n-  return;\n-}\n-\n-func Listen(fd int, n int) (errno int) {\n-  r := libc_listen(int(fd), int(n));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func GetsockoptInt(fd, level, opt int) (value, errno int) {\n-\tvar n int32\n-\tvallen := Socklen_t(4)\n-\terrno = libc_getsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&n)), &vallen)\n-\treturn int(n), errno\n-}\n-\n-func setsockopt(fd, level, opt int, valueptr uintptr, length Socklen_t) (errno int) {\n-  r := libc_setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(valueptr)),\n-\t\t       length);\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func SetsockoptInt(fd, level, opt int, value int) (errno int) {\n-\tvar n = int32(value);\n-\treturn setsockopt(fd, level, opt, uintptr(unsafe.Pointer(&n)), 4);\n-}\n-\n-func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {\n-\treturn setsockopt(fd, level, opt, uintptr(unsafe.Pointer(tv)), Socklen_t(unsafe.Sizeof(*tv)));\n-}\n-\n-func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {\n-\treturn setsockopt(fd, level, opt, uintptr(unsafe.Pointer(l)), Socklen_t(unsafe.Sizeof(*l)));\n-}\n-\n-func SetsockoptString(fd, level, opt int, s string) (errno int) {\n-\treturn setsockopt(fd, level, opt, uintptr(unsafe.Pointer(&[]byte(s)[0])), Socklen_t(len(s)))\n-}\n-\n-func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (errno int) {\n-\treturn setsockopt(fd, level, opt, uintptr(unsafe.Pointer(mreq)), unsafe.Sizeof(*mreq))\n-}\n-\n-func Getsockname(fd int) (sa Sockaddr, errno int) {\n-\tvar rsa RawSockaddrAny;\n-\tvar len Socklen_t = SizeofSockaddrAny;\n-\tif libc_getsockname(fd, &rsa, &len) != 0 {\n-\t\terrno = GetErrno();\n-\t\treturn;\n-\t}\n-\treturn anyToSockaddr(&rsa);\n-}\n-\n-func Getpeername(fd int) (sa Sockaddr, errno int) {\n-\tvar rsa RawSockaddrAny;\n-\tvar len Socklen_t = SizeofSockaddrAny;\n-\tif libc_getpeername(fd, &rsa, &len) != 0 {\n-\t\terrno = GetErrno();\n-\t\treturn;\n-\t}\n-\treturn anyToSockaddr(&rsa);\n-}\n-\n-func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {\n-\tvar rsa RawSockaddrAny;\n-\tvar slen Socklen_t = SizeofSockaddrAny;\n-\tvar _p0 *byte;\n-\tif len(p) > 0 { _p0 = &p[0]; }\n-\tr := libc_recvfrom(fd, _p0, Size_t(len(p)), flags, &rsa, &slen);\n-\tn = int(r);\n-\tif r == -1 {\n-\t\terrno = GetErrno();\n-\t} else {\n-\t\tfrom, errno = anyToSockaddr(&rsa);\n-\t}\n-\treturn;\n-}\n-\n-func (iov *Iovec) SetLen(length int) {\n-\tiov.Len = Iovec_len_t(length)\n-}\n-\n-func (msghdr *Msghdr) SetControllen(length int) {\n-\tmsghdr.Controllen = Msghdr_controllen_t(length)\n-}\n-\n-func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, errno int) {\n-\tvar msg Msghdr\n-\tvar rsa RawSockaddrAny\n-\tmsg.Name = (*byte)(unsafe.Pointer(&rsa))\n-\tmsg.Namelen = uint32(SizeofSockaddrAny)\n-\tvar iov Iovec\n-\tif len(p) > 0 {\n-\t\tiov.Base = (*byte)(unsafe.Pointer(&p[0]))\n-\t\tiov.SetLen(len(p))\n-\t}\n-\tvar dummy byte\n-\tif len(oob) > 0 {\n-\t\t// receive at least one normal byte\n-\t\tif len(p) == 0 {\n-\t\t\tiov.Base = &dummy\n-\t\t\tiov.SetLen(1)\n-\t\t}\n-\t\tmsg.Control = (*byte)(unsafe.Pointer(&oob[0]))\n-\t\tmsg.SetControllen(len(oob))\n-\t}\n-\tmsg.Iov = &iov\n-\tmsg.Iovlen = 1\n-\tif n, errno = recvmsg(fd, &msg, flags); errno != 0 {\n-\t\treturn\n-\t}\n-\toobn = int(msg.Controllen)\n-\trecvflags = int(msg.Flags)\n-\t// source address is only specified if the socket is unconnected\n-\tif rsa.Addr.Family != 0 {\n-\t\tfrom, errno = anyToSockaddr(&rsa)\n-\t}\n-\treturn\n-}\n-\n-func recvmsg(s int, msg *Msghdr, flags int) (n int, errno int) {\n-\tr := libc_recvmsg(s, msg, flags)\n-\tif r < 0 {\n-\t\terrno = GetErrno()\n-\t} else {\n-\t\tn = int(r)\n-\t}\n-\treturn\n-}\n-\n-func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {\n-\tptr, n, err := to.sockaddr();\n-\tif err != 0 {\n-\t\treturn err;\n-\t}\n-\tvar _p0 *byte;\n-\tif len(p) > 0 { _p0 = &p[0]; }\n-\tr := libc_sendto(fd, _p0, Size_t(len(p)), flags, ptr, n);\n-\tif r == -1 { errno = GetErrno(); }\n-\treturn;\n-}\n-\n-func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (errno int) {\n-\tvar ptr *RawSockaddrAny\n-\tvar nsock Socklen_t\n-\tif to != nil {\n-\t\tvar err int\n-\t\tptr, nsock, err = to.sockaddr()\n-\t\tif err != 0 {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\tvar msg Msghdr\n-\tmsg.Name = (*byte)(unsafe.Pointer(ptr))\n-\tmsg.Namelen = uint32(nsock)\n-\tvar iov Iovec\n-\tif len(p) > 0 {\n-\t\tiov.Base = (*byte)(unsafe.Pointer(&p[0]))\n-\t\tiov.SetLen(len(p))\n-\t}\n-\tvar dummy byte\n-\tif len(oob) > 0 {\n-\t\t// send at least one normal byte\n-\t\tif len(p) == 0 {\n-\t\t\tiov.Base = &dummy\n-\t\t\tiov.SetLen(1)\n-\t\t}\n-\t\tmsg.Control = (*byte)(unsafe.Pointer(&oob[0]))\n-\t\tmsg.SetControllen(len(oob))\n-\t}\n-\tmsg.Iov = &iov\n-\tmsg.Iovlen = 1\n-\tif errno = sendmsg(fd, &msg, flags); errno != 0 {\n-\t\treturn\n-\t}\n-\treturn\n-}\n-\n-func sendmsg(s int, msg *Msghdr, flags int) (errno int) {\n-\tif libc_sendmsg(s, msg, flags) < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}\n-\n-func Shutdown(fd int, how int) (errno int) {\n-\tr := libc_shutdown(fd, how);\n-\tif r < 0 { errno = GetErrno() }\n-\treturn;\n-}"}, {"sha": "0013f33498f46479594a28ea2da850f2e74d3ff6", "filename": "libgo/syscalls/socket_epoll.go", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsocket_epoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsocket_epoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsocket_epoll.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,50 +0,0 @@\n-// socket_epoll.go -- GNU/Linux epoll handling.\n-\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Support for GNU/Linux epoll.\n-// Only for implementing net package.\n-// DO NOT USE DIRECTLY.\n-\n-package syscall\n-\n-// We don't take this type directly from the header file because it\n-// uses a union.  FIXME.\n-\n-type EpollEvent struct {\n-  Events uint32;\n-  Fd int32;\n-  Pad int32;\n-};\n-\n-func libc_epoll_create(size int) int __asm__ (\"epoll_create\");\n-func libc_epoll_ctl(epfd, op, fd int, event *EpollEvent) int __asm__ (\"epoll_ctl\");\n-func libc_epoll_wait(epfd int, events *EpollEvent, maxevents int,\n-                     timeout int) int __asm__ (\"epoll_wait\");\n-\n-\n-func EpollCreate(size int) (fd int, errno int) {\n-  fd = libc_epoll_create(int(size));\n-  if fd < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func EpollCtl(epfd, op, fd int, ev *EpollEvent) (errno int) {\n-  r := libc_epoll_ctl(epfd, op, fd, ev);\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func EpollWait(epfd int, ev []EpollEvent, msec int) (n int, errno int) {\n-  var events *EpollEvent;\n-  var maxevents int;\n-  if len(ev) > 0 {\n-    maxevents = len(ev);\n-    events = &ev[0]\n-  }\n-  n = libc_epoll_wait(epfd, events, maxevents, msec);\n-  if n < 0 { errno = GetErrno() }\n-  return;\n-}"}, {"sha": "17619536f2ebe0243317256d8048369f152b8839", "filename": "libgo/syscalls/stringbyte.go", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fstringbyte.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fstringbyte.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fstringbyte.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,37 +0,0 @@\n-// stringbyte.go -- string to bytes functions.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-// StringByteSlice returns a NUL-terminated slice of bytes\n-// containing the text of s.\n-func StringByteSlice(s string) []byte {\n-\ta := make([]byte, len(s)+1);\n-\tfor i := 0; i < len(s); i++ {\n-\t\ta[i] = s[i];\n-\t}\n-\treturn a;\n-}\n-\n-// StringBytePtr returns a pointer to a NUL-terminated array of bytes\n-// containing the text of s.\n-func StringBytePtr(s string) *byte {\n-\tp := StringByteSlice(s);\n-\treturn &p[0];\n-}\n-\n-// BytePtrToString takes a NUL-terminated array of bytes and convert\n-// it to a Go string.\n-func BytePtrToString(p *byte) string {\n-\ta := (*[10000]byte)(unsafe.Pointer(p))\n-\ti := 0\n-\tfor a[i] != 0 {\n-\t\ti++\n-\t}\n-\treturn string(a[:i])\n-}"}, {"sha": "8c7a7ba5fee18ac3700358a290ba9a038a95cf38", "filename": "libgo/syscalls/syscall.go", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,111 +0,0 @@\n-// syscall.go -- Basic syscall interface.\n-\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This package contains an interface to the low-level operating system\n-// primitives.  The details vary depending on the underlying system.\n-// Its primary use is inside other packages that provide a more portable\n-// interface to the system, such as \"os\", \"time\" and \"net\".  Use those\n-// packages rather than this one if you can.\n-// For details of the functions and data types in this package consult\n-// the manuals for the appropriate operating system.\n-package syscall\n-\n-import (\n-\t\"sync\"\n-\t\"unsafe\"\n-)\n-\n-func libc_syscall32(trap int32, a1, a2, a3, a4, a5, a6 int32) int32 __asm__ (\"syscall\");\n-func libc_syscall64(trap int64, a1, a2, a3, a4, a5, a6 int64) int64 __asm__ (\"syscall\");\n-\n-// Do a system call.  We look at the size of uintptr to see how to pass\n-// the arguments, so that we don't pass a 64-bit value when the function\n-// expects a 32-bit one.\n-func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n-  var r uintptr;\n-  if unsafe.Sizeof(r) == 4 {\n-    r1 := libc_syscall32(int32(trap), int32(a1), int32(a2), int32(a3), 0, 0, 0);\n-    r = uintptr(r1);\n-  } else {\n-    r1 := libc_syscall64(int64(trap), int64(a1), int64(a2), int64(a3), 0, 0, 0);\n-    r = uintptr(r1);\n-  }\n-  return r, 0, uintptr(GetErrno());\n-}\n-\n-func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n-  var r uintptr;\n-  if unsafe.Sizeof(r) == 4 {\n-    r1 := libc_syscall32(int32(trap), int32(a1), int32(a2), int32(a3),\n-    \t\t\t int32(a4), int32(a5), int32(a6));\n-    r = uintptr(r1);\n-  } else {\n-    r1 := libc_syscall64(int64(trap), int64(a1), int64(a2), int64(a3),\n-\t\t\t int64(a4), int64(a5), int64(a6));\n-    r = uintptr(r1);\n-  }\n-  return r, 0, uintptr(GetErrno());\n-}\n-\n-// Mmap manager, for use by operating system-specific implementations.\n-\n-type mmapper struct {\n-\tsync.Mutex\n-\tactive map[*byte][]byte // active mappings; key is last byte in mapping\n-\tmmap   func(addr, length uintptr, prot, flags, fd int, offset int64) (uintptr, int)\n-\tmunmap func(addr uintptr, length uintptr) int\n-}\n-\n-func (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, errno int) {\n-\tif length <= 0 {\n-\t\treturn nil, EINVAL\n-\t}\n-\n-\t// Map the requested memory.\n-\taddr, errno := m.mmap(0, uintptr(length), prot, flags, fd, offset)\n-\tif errno != 0 {\n-\t\treturn nil, errno\n-\t}\n-\n-\t// Slice memory layout\n-\tvar sl = struct {\n-\t\taddr uintptr\n-\t\tlen  int\n-\t\tcap  int\n-\t}{addr, length, length}\n-\n-\t// Use unsafe to turn sl into a []byte.\n-\tb := *(*[]byte)(unsafe.Pointer(&sl))\n-\n-\t// Register mapping in m and return it.\n-\tp := &b[cap(b)-1]\n-\tm.Lock()\n-\tdefer m.Unlock()\n-\tm.active[p] = b\n-\treturn b, 0\n-}\n-\n-func (m *mmapper) Munmap(data []byte) (errno int) {\n-\tif len(data) == 0 || len(data) != cap(data) {\n-\t\treturn EINVAL\n-\t}\n-\n-\t// Find the base of the mapping.\n-\tp := &data[cap(data)-1]\n-\tm.Lock()\n-\tdefer m.Unlock()\n-\tb := m.active[p]\n-\tif b == nil || &b[0] != &data[0] {\n-\t\treturn EINVAL\n-\t}\n-\n-\t// Unmap the memory and update m.\n-\tif errno := m.munmap(uintptr(unsafe.Pointer(&b[0])), uintptr(len(b))); errno != 0 {\n-\t\treturn errno\n-\t}\n-\tm.active[p] = nil, false\n-\treturn 0\n-}"}, {"sha": "e66cef045db66cb84d9d2877716aea5639e4b8df", "filename": "libgo/syscalls/syscall_irix.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_irix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_irix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_irix.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,17 +0,0 @@\n-// syscall_irix.go -- IRIX 6 specific syscall interface.\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-// FIXME: ptrace(3C) has this, but exec.go expects the next.\n-//func libc_ptrace(request int, pid Pid_t, addr int, data int) int __asm__ (\"ptrace\")\n-\n-func libc_ptrace(request int, pid Pid_t, addr uintptr, data *byte) int __asm__ (\"ptrace\")\n-\n-var dummy *byte\n-const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))"}, {"sha": "29c8b62403e4f36e98c36e97510230ca66038a33", "filename": "libgo/syscalls/syscall_linux.go", "status": "removed", "additions": 0, "deletions": 206, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_linux.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,206 +0,0 @@\n-// syscall_linux.go -- GNU/Linux specific syscall interface.\n-\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-func libc_ptrace(request int, pid Pid_t, addr uintptr, data *byte) _C_long __asm__ (\"ptrace\")\n-func libc_sendfile(int, int, *Offset_t, Size_t) Ssize_t __asm__ (\"sendfile\")\n-\n-var dummy *byte\n-const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))\n-\n-func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno int) {\n-\t// The peek requests are machine-size oriented, so we wrap it\n-\t// to retrieve arbitrary-length data.\n-\n-\tvar buf [sizeofPtr]byte;\n-\n-\t// Leading edge.  PEEKTEXT/PEEKDATA don't require aligned\n-\t// access (PEEKUSER warns that it might), but if we don't\n-\t// align our reads, we might straddle an unmapped page\n-\t// boundary and not get the bytes leading up to the page\n-\t// boundary.\n-\tn := 0;\n-\tif addr % sizeofPtr != 0 {\n-\t\tSetErrno(0);\n-\t\tval := libc_ptrace(req, Pid_t(pid), addr - addr%sizeofPtr, nil);\n-\t\tif errno := GetErrno(); errno != 0 {\n-\t\t\treturn 0, errno;\n-\t\t}\n-\t\t*(*_C_long)(unsafe.Pointer(&buf[0])) = val;\n-\t\tn += copy(out, buf[addr%sizeofPtr:]);\n-\t\tout = out[n:];\n-\t}\n-\n-\t// Remainder.\n-\tfor len(out) > 0 {\n-\t\t// We use an internal buffer to gaurantee alignment.\n-\t\t// It's not documented if this is necessary, but we're paranoid.\n-\t\tSetErrno(0);\n-\t\tval := libc_ptrace(req, Pid_t(pid), addr+uintptr(n), nil);\n-\t\tif errno = GetErrno(); errno != 0 {\n-\t\t\treturn n, errno;\n-\t\t}\n-\t\t*(*_C_long)(unsafe.Pointer(&buf[0])) = val;\n-\t\tcopied := copy(out, buf[0:]);\n-\t\tn += copied;\n-\t\tout = out[copied:];\n-\t}\n-\n-\treturn n, 0;\n-}\n-\n-func PtracePeekText(pid int, addr uintptr, out []byte) (count int, errno int) {\n-\treturn ptracePeek(_PTRACE_PEEKTEXT, pid, addr, out);\n-}\n-\n-func PtracePeekData(pid int, addr uintptr, out []byte) (count int, errno int) {\n-\treturn ptracePeek(_PTRACE_PEEKDATA, pid, addr, out);\n-}\n-\n-func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (count int, errno int) {\n-\t// As for ptracePeek, we need to align our accesses to deal\n-\t// with the possibility of straddling an invalid page.\n-\n-\t// Leading edge.\n-\tn := 0;\n-\tif addr % sizeofPtr != 0 {\n-\t\tvar buf [sizeofPtr]byte;\n-\t\tif libc_ptrace(peekReq, Pid_t(pid), addr - addr%sizeofPtr, &buf[0]) < 0 {\n-\t\t\treturn 0, GetErrno();\n-\t\t}\n-\t\tn += copy(buf[addr%sizeofPtr:], data);\n-\t\tword := (*byte)(unsafe.Pointer(*((*uintptr)(unsafe.Pointer(&buf[0])))));\n-\t\tif libc_ptrace(pokeReq, Pid_t(pid), addr - addr%sizeofPtr, word) < 0 {\n-\t\t\treturn 0, GetErrno();\n-\t\t}\n-\t\tdata = data[n:len(data)];\n-\t}\n-\n-\t// Interior.\n-\tfor uintptr(len(data)) > sizeofPtr {\n-\t\tword := (*byte)(unsafe.Pointer(*((*uintptr)(unsafe.Pointer(&data[0])))));\n-\t\tif libc_ptrace(pokeReq, Pid_t(pid), addr+uintptr(n), word) < 0 {\n-\t\t\treturn n, GetErrno();\n-\t\t}\n-\t\tn += int(sizeofPtr);\n-\t\tdata = data[sizeofPtr:len(data)];\n-\t}\n-\n-\t// Trailing edge.\n-\tif len(data) > 0 {\n-\t\tvar buf [sizeofPtr]byte;\n-\t\tif libc_ptrace(peekReq, Pid_t(pid), addr+uintptr(n), &buf[0]) < 0 {\n-\t\t\treturn n, GetErrno();\n-\t\t}\n-\t\tcopy(buf[0:], data);\n-\t\tword := (*byte)(unsafe.Pointer(*((*uintptr)(unsafe.Pointer(&buf[0])))));\n-\t\tif libc_ptrace(pokeReq, Pid_t(pid), addr+uintptr(n), word) < 0 {\n-\t\t\treturn n, GetErrno();\n-\t\t}\n-\t\tn += len(data);\n-\t}\n-\n-\treturn n, 0;\n-}\n-\n-func PtracePokeText(pid int, addr uintptr, data []byte) (count int, errno int) {\n-\treturn ptracePoke(_PTRACE_POKETEXT, _PTRACE_PEEKTEXT, pid, addr, data);\n-}\n-\n-func PtracePokeData(pid int, addr uintptr, data []byte) (count int, errno int) {\n-\treturn ptracePoke(_PTRACE_POKEDATA, _PTRACE_PEEKDATA, pid, addr, data);\n-}\n-\n-func PtraceGetRegs(pid int, regsout *PtraceRegs) (errno int) {\n-\tif libc_ptrace(_PTRACE_GETREGS, Pid_t(pid), 0, (*byte)(unsafe.Pointer(regsout))) < 0 {\n-\t\treturn GetErrno();\n-\t} else {\n-\t\treturn 0;\n-\t}\n-}\n-\n-func PtraceSetRegs(pid int, regs *PtraceRegs) (errno int) {\n-\tif libc_ptrace(_PTRACE_SETREGS, Pid_t(pid), 0, (*byte)(unsafe.Pointer(regs))) < 0 {\n-\t\treturn GetErrno();\n-\t} else {\n-\t\treturn 0;\n-\t}\n-}\n-\n-func PtraceSetOptions(pid int, options int) (errno int) {\n-\tif libc_ptrace(_PTRACE_SETOPTIONS, Pid_t(pid), 0, (*byte)(unsafe.Pointer(uintptr(options)))) < 0 {\n-\t\treturn GetErrno();\n-\t} else {\n-\t\treturn 0;\n-\t}\n-}\n-\n-func PtraceGetEventMsg(pid int) (msg uint, errno int) {\n-\tvar data _C_long;\n-\tif libc_ptrace(_PTRACE_GETEVENTMSG, Pid_t(pid), 0, (*byte)(unsafe.Pointer(&data))) < 0 {\n-\t\terrno = GetErrno();\n-\t}\n-\tmsg = uint(data);\n-\treturn;\n-}\n-\n-func PtraceCont(pid int, signal int) (errno int) {\n-\tif libc_ptrace(_PTRACE_CONT, Pid_t(pid), 0, (*byte)(unsafe.Pointer(uintptr(signal)))) < 0 {\n-\t\treturn GetErrno();\n-\t} else {\n-\t\treturn 0;\n-\t}\n-}\n-\n-func PtraceSingleStep(pid int) (errno int) {\n-\tif libc_ptrace(_PTRACE_SINGLESTEP, Pid_t(pid), 0, nil) < 0 {\n-\t\treturn GetErrno();\n-\t} else {\n-\t\treturn 0;\n-\t}\n-}\n-\n-func PtraceAttach(pid int) (errno int) {\n-\tif libc_ptrace(_PTRACE_ATTACH, Pid_t(pid), 0, nil) < 0 {\n-\t\treturn GetErrno();\n-\t} else {\n-\t\treturn 0;\n-\t}\n-}\n-\n-func PtraceDetach(pid int) (errno int) {\n-\tif libc_ptrace(_PTRACE_DETACH, Pid_t(pid), 0, nil) < 0 {\n-\t\treturn GetErrno();\n-\t} else {\n-\t\treturn 0;\n-\t}\n-}\n-\n-func Tgkill(tgid int, tid int, sig int) (errno int) {\n-\tr1, r2, err := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid),\n-\t\t\t\t uintptr(sig));\n-\treturn int(err);\n-}\n-\n-func Sendfile(outfd int, infd int, offset *int64, count int) (written int, errno int) {\n-\tvar o Offset_t\n-\tvar po *Offset_t\n-\tif offset != nil {\n-\t\to = Offset_t(*offset)\n-\t\tpo = &o\n-\t}\n-\tw := libc_sendfile(outfd, infd, po, Size_t(count))\n-\tif offset != nil {\n-\t\t*offset = int64(o)\n-\t}\n-\tif w < 0 {\n-\t\treturn 0, GetErrno()\n-\t}\n-\treturn int(w), 0\n-}"}, {"sha": "7ff8f5b07402a799ba764e9ce9969a702eac3557", "filename": "libgo/syscalls/syscall_solaris_386.go", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_solaris_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_solaris_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_solaris_386.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,20 +0,0 @@\n-// syscall_solaris_386.go -- Solaris/x86 specific support\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-// FIXME: ptrace(3C) has this, but exec.go expects the next.\n-//func libc_ptrace(request int, pid Pid_t, addr int, data int) int __asm__ (\"ptrace\")\n-\n-func libc_ptrace(request int, pid Pid_t, addr uintptr, data *byte) int __asm__ (\"ptrace\")\n-\n-var dummy *byte\n-const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))\n-\n-// 32-bit Solaris 2/x86 needs to use _nuname internally, cf. <sys/utsname.h>.\n-func libc_uname(buf *Utsname) (errno int) __asm__(\"_nuname\")"}, {"sha": "15d22561507ae94f0da1ffe2d598c351476f2787", "filename": "libgo/syscalls/syscall_solaris_amd64.go", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_solaris_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_solaris_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_solaris_amd64.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,21 +0,0 @@\n-// syscall_solaris_amd64.go -- Solaris/x64 specific support\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-// FIXME: ptrace(3C) has this, but exec.go expects the next.\n-//func libc_ptrace(request int, pid Pid_t, addr int, data int) int __asm__ (\"ptrace\")\n-\n-// 64-bit ptrace(3C) doesn't exist\n-func libc_ptrace(request int, pid Pid_t, addr uintptr, data *byte) int {\n-\tSetErrno(ENOSYS)\n-\treturn -1\n-}\n-\n-var dummy *byte\n-const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))"}, {"sha": "0be60b92967c889a15d9dd19086ce47d2d569160", "filename": "libgo/syscalls/syscall_solaris_sparc.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_solaris_sparc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_solaris_sparc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_solaris_sparc.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,17 +0,0 @@\n-// syscall_solaris_sparc.go -- Solaris/SPARC specific support\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-// FIXME: ptrace(3C) has this, but exec.go expects the next.\n-//func libc_ptrace(request int, pid Pid_t, addr int, data int) int __asm__ (\"ptrace\")\n-\n-func libc_ptrace(request int, pid Pid_t, addr uintptr, data *byte) int __asm__ (\"ptrace\")\n-\n-var dummy *byte\n-const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))"}, {"sha": "81e2010cd132508962fd6bf085bb8a4752c13c49", "filename": "libgo/syscalls/syscall_solaris_sparc64.go", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_solaris_sparc64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_solaris_sparc64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_solaris_sparc64.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,21 +0,0 @@\n-// syscall_solaris_sparc64.go -- Solaris/SPARCV9 specific support\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-// FIXME: ptrace(3C) has this, but exec.go expects the next.\n-//func libc_ptrace(request int, pid Pid_t, addr int, data int) int __asm__ (\"ptrace\")\n-\n-// 64-bit ptrace(3C) doesn't exist\n-func libc_ptrace(request int, pid Pid_t, addr uintptr, data *byte) int {\n-\tSetErrno(ENOSYS)\n-\treturn -1\n-}\n-\n-var dummy *byte\n-const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))"}, {"sha": "d864902eaf775e96dfc2dfe2cdb0e8ca0c7351cc", "filename": "libgo/syscalls/syscall_stubs.go", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_stubs.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,33 +0,0 @@\n-// syscall_stubs.go -- Stubs of the basic syscall interface.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This package contains an interface to the low-level operating system\n-// primitives.  The details vary depending on the underlying system.\n-// Its primary use is inside other packages that provide a more portable\n-// interface to the system, such as \"os\", \"time\" and \"net\".  Use those\n-// packages rather than this one if you can.\n-// For details of the functions and data types in this package consult\n-// the manuals for the appropriate operating system.\n-\n-// These are stubs.\n-\n-package syscall\n-\n-func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n-  var r uintptr;\n-  var i int;\n-  i = -1;\n-  r = uintptr(i);\n-  return r, 0, uintptr(ENOSYS);\n-}\n-\n-func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n-  var r uintptr;\n-  var i int;\n-  i = -1;\n-  r = uintptr(i);\n-  return r, 0, uintptr(ENOSYS);\n-}"}, {"sha": "e633ea19146ca28abc6593999bafecb69fa48334", "filename": "libgo/syscalls/syscall_unix.go", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsyscall_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_unix.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-var (\n-\tStdin  = 0\n-\tStdout = 1\n-\tStderr = 2\n-)\n-\n-const ENONE = 0\n-\n-func GetErrno() int\n-func SetErrno(int)\n-\n-func Uname(buf *Utsname) (errno int) {\n-\tr := libc_uname(buf)\n-\tif r < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}\n-\n-var mapper = &mmapper{\n-\tactive: make(map[*byte][]byte),\n-\tmmap:   mmap,\n-\tmunmap: munmap,\n-}\n-\n-func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, errno int) {\n-\treturn mapper.Mmap(fd, offset, length, prot, flags)\n-}\n-\n-func Munmap(b []byte) (errno int) {\n-\treturn mapper.Munmap(b)\n-}\n-\n-func libc_munmap(*byte, Size_t) int __asm__ (\"munmap\")\n-\n-func mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, errno int) {\n-\tr0 := libc_mmap((*byte)(unsafe.Pointer(addr)), Size_t(length), prot, flag, fd, Offset_t(pos))\n-\tret = uintptr(unsafe.Pointer(r0))\n-\tif ret + 1 == 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}\n-\n-func munmap(addr uintptr, length uintptr) (errno int) {\n-\tif libc_munmap((*byte)(unsafe.Pointer(addr)), Size_t(length)) < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}\n-\n-func libc_getrusage(who int, rusage *Rusage) int __asm__ (\"getrusage\")\n-\n-func Getrusage(who int, rusage *Rusage) (errno int) {\n-\tif libc_getrusage(who, rusage) < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}"}, {"sha": "c0c4e555e63a1e8102a1160dad260d99e7e31b76", "filename": "libgo/syscalls/sysfile_largefile.go", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_largefile.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,14 +0,0 @@\n-// sysfile_largefile.go -- For systems which use the large file interface.\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-func libc_pread(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pread64\")\n-func libc_pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pwrite64\")\n-func libc_lseek(int, Offset_t, int) Offset_t __asm__ (\"lseek64\")\n-func libc_truncate(path *byte, length Offset_t) int __asm__ (\"truncate64\")\n-func libc_ftruncate(fd int, length Offset_t) int __asm__ (\"ftruncate64\")\n-func libc_mmap(*byte, Size_t, int, int, int, Offset_t) *byte __asm__ (\"mmap64\")"}, {"sha": "a16ba4aba607f2341fbe97c52e4cf0342150cc19", "filename": "libgo/syscalls/sysfile_posix.go", "status": "removed", "additions": 0, "deletions": 429, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_posix.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,429 +0,0 @@\n-// sysfile_posix.go -- POSIX File handling.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Support for basic Unix file operations.  This file simply\n-// translates from Go data types to Unix data types, and handles\n-// errno.  FIXME: This could probably be done mechanically.\n-\n-package syscall\n-\n-import \"unsafe\"\n-\n-func libc_open(name *byte, mode int, perm Mode_t) int __asm__ (\"open\");\n-func libc_close(fd int) int __asm__ (\"close\");\n-func libc_read(fd int, buf *byte, count Size_t) Ssize_t __asm__ (\"read\");\n-func libc_write(fd int, buf *byte, count Size_t) Ssize_t __asm__ (\"write\");\n-func libc_fsync(fd int) int __asm__ (\"fsync\")\n-func libc_pipe(filedes *int) int __asm__(\"pipe\");\n-func libc_unlink(name *byte) int __asm__ (\"unlink\");\n-func libc_rmdir(name *byte) int __asm__ (\"rmdir\");\n-func libc_fcntl(fd int, cmd int, arg int) int __asm__ (\"fcntl\");\n-func libc_mkdir(name *byte, perm Mode_t) int __asm__ (\"mkdir\");\n-func libc_dup(int) int __asm__ (\"dup\")\n-func libc_gettimeofday(tv *Timeval, tz *byte) int __asm__ (\"gettimeofday\");\n-func libc_select(int, *byte, *byte, *byte, *Timeval) int __asm__ (\"select\");\n-func libc_chdir(name *byte) int __asm__ (\"chdir\");\n-func libc_fchdir(int) int __asm__ (\"fchdir\");\n-func libc_getcwd(*byte, Size_t) *byte __asm__ (\"getcwd\");\n-func libc_link(oldpath *byte, newpath *byte) int __asm__ (\"link\");\n-func libc_symlink(oldpath *byte, newpath *byte) int __asm__ (\"symlink\");\n-func libc_readlink(*byte, *byte, Size_t) Ssize_t  __asm__ (\"readlink\");\n-func libc_rename(oldpath *byte, newpath *byte) int __asm__ (\"rename\");\n-func libc_chmod(path *byte, mode Mode_t) int __asm__ (\"chmod\");\n-func libc_fchmod(fd int, mode Mode_t) int __asm__ (\"fchmod\");\n-func libc_chown(path *byte, owner Uid_t, group Gid_t) int __asm__ (\"chown\");\n-func libc_fchown(fd int, owner Uid_t, group Gid_t) int __asm__ (\"fchown\");\n-func libc_lchown(path *byte, owner Uid_t, group Gid_t) int __asm__ (\"lchown\");\n-func libc_utimes(filename *byte, times *[2]Timeval) int __asm__ (\"utimes\");\n-func libc_getuid() Uid_t __asm__ (\"getuid\");\n-func libc_geteuid() Uid_t __asm__ (\"geteuid\");\n-func libc_getgid() Gid_t __asm__ (\"getgid\");\n-func libc_getegid() Gid_t __asm__ (\"getegid\");\n-func libc_getgroups(size int, list *Gid_t) int __asm__ (\"getgroups\");\n-func libc_getpagesize() int __asm__ (\"getpagesize\");\n-func libc_exit(status int) __asm__ (\"exit\")\n-func libc_getpid() Pid_t __asm__ (\"getpid\")\n-func libc_getppid() Pid_t __asm__ (\"getppid\")\n-func libc_kill(Pid_t, int) int __asm__ (\"kill\")\n-\n-func Open(name string, mode int, perm uint32) (fd int, errno int) {\n-  fd = libc_open(StringBytePtr(name), mode, Mode_t(perm));\n-  if fd < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Creat(name string, perm uint32) (fd int, errno int) {\n-  fd = libc_open(StringBytePtr(name), O_CREAT | O_WRONLY | O_TRUNC, Mode_t(perm));\n-  if fd < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Close(fd int) (errno int) {\n-  r := libc_close(fd);\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Read(fd int, p []byte) (n int, errno int) {\n-  var _p0 *byte;\n-  if len(p) > 0 { _p0 = &p[0]; }\n-  r := libc_read(fd, _p0, Size_t(len(p)));\n-  if r == -1 { errno = GetErrno() }\n-  n = int(r);\n-  return;\n-}\n-\n-func Write(fd int, p []byte) (n int, errno int) {\n-  var _p0 *byte;\n-  if len(p) > 0 { _p0 = &p[0]; }\n-  r := libc_write(fd, _p0, Size_t(len(p)));\n-  if r == -1 { errno = GetErrno() }\n-  n = int(r);\n-  return;\n-}\n-\n-func Fsync(fd int) (errno int) {\n-\tif libc_fsync(fd) < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}\n-\n-func Pread(fd int, p []byte, offset int64) (n int, errno int) {\n-  var _p0 *byte;\n-  if len(p) > 0 { _p0 = &p[0]; }\n-  r := libc_pread(fd, _p0, Size_t(len(p)), Offset_t(offset));\n-  if r == -1 { errno = GetErrno() }\n-  n = int(r);\n-  return;\n-}\n-\n-func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {\n-  var _p0 *byte;\n-  if len(p) > 0 { _p0 = &p[0]; }\n-  r := libc_pwrite(fd, _p0, Size_t(len(p)), Offset_t(offset));\n-  if r == -1 { errno = GetErrno() }\n-  n = int(r);\n-  return;\n-}\n-\n-func Seek(fd int, offset int64, whence int) (off int64, errno int) {\n-  r := libc_lseek(fd, Offset_t(offset), whence);\n-  if r == -1 { errno = GetErrno() }\n-  off = int64(r);\n-  return;\n-}\n-\n-func Pipe(p []int) (errno int) {\n-  if len(p) != 2 {\n-    return EINVAL;\n-  }\n-  var pp [2]int;\n-  r := libc_pipe(&pp[0]);\n-  if r < 0 {\n-    errno = GetErrno();\n-  }\n-  p[0] = pp[0];\n-  p[1] = pp[1];\n-  return;\n-}\n-\n-func Stat(name string, buf *Stat_t) (errno int) {\n-  r := libc_stat(StringBytePtr(name), buf);\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Lstat(name string, buf *Stat_t) (errno int) {\n-  r := libc_lstat(StringBytePtr(name), buf);\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Fstat(fd int, buf *Stat_t) (errno int) {\n-  r := libc_fstat(fd, buf);\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Unlink(name string) (errno int) {\n-  r := libc_unlink(StringBytePtr(name));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Rmdir(name string) (errno int) {\n-  r := libc_rmdir(StringBytePtr(name));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Mkdir(path string, mode uint32) (errno int) {\n-  r := libc_mkdir(StringBytePtr(path), Mode_t(mode));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Dup(oldfd int) (fd int, errno int) {\n-\tfd = libc_dup(oldfd)\n-\tif fd < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}\n-\n-func Gettimeofday(tv *Timeval) (errno int) {\n-  r := libc_gettimeofday(tv, nil);\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-const nfdbits = unsafe.Sizeof(fds_bits_type) * 8\n-\n-type FdSet_t struct {\n-\tFds_bits [(FD_SETSIZE + nfdbits - 1) / nfdbits]fds_bits_type\n-}\n-\n-func FDSet(fd int, set *FdSet_t) {\n-\tset.Fds_bits[fd / nfdbits] |= (1 << (uint)(fd % nfdbits))\n-}\n-\n-func FDClr(fd int, set *FdSet_t) {\n-\tset.Fds_bits[fd / nfdbits] &^= (1 << (uint)(fd % nfdbits))\n-}\n-\n-func FDIsSet(fd int, set *FdSet_t) bool {\n-\tif set.Fds_bits[fd / nfdbits] & (1 << (uint)(fd % nfdbits)) != 0 {\n-\t\treturn true\n-\t} else {\n-\t\treturn false\n-\t}\n-}\n-\n-func FDZero(set *FdSet_t) {\n-\tfor i := range set.Fds_bits {\n-\t\tset.Fds_bits[i] = 0\n-\t}\n-}\n-\n-func Select(nfds int, r *FdSet_t, w *FdSet_t, e *FdSet_t, timeout *Timeval) (n int, errno int) {\n-  n = libc_select(nfds, (*byte)(unsafe.Pointer(r)),\n-\t\t  (*byte)(unsafe.Pointer(w)),\n-\t\t  (*byte)(unsafe.Pointer(e)), timeout);\n-  if n < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Chdir(path string) (errno int) {\n-  r := libc_chdir(StringBytePtr(path));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Fchdir(fd int) (errno int) {\n-  r := libc_fchdir(int(fd));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-const ImplementsGetwd = true\n-\n-func Getwd() (ret string, errno int) {\n-\tfor len := Size_t(4096); ; len *= 2 {\n-\t\tb := make([]byte, len);\n-\t\tp := libc_getcwd(&b[0], len);\n-\t\tif p != nil {\n-\t\t\ti := 0;\n-\t\t\tfor b[i] != 0 {\n-\t\t\t\ti++;\n-\t\t\t}\n-\t\t\treturn string(b[0:i]), 0;\n-\t\t}\n-\t\te := GetErrno();\n-\t\tif e != ERANGE {\n-\t\t\treturn \"\", e;\n-\t\t}\n-\t}\n-}\n-\n-func Link(oldpath, newpath string) (errno int) {\n-  r := libc_link(StringBytePtr(oldpath), StringBytePtr(newpath));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Symlink(oldpath, newpath string) (errno int) {\n-  r := libc_symlink(StringBytePtr(oldpath), StringBytePtr(newpath));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Readlink(path string, buf []byte) (n int, errno int) {\n-  var _p0 *byte;\n-  if len(buf) > 0 { _p0 = &buf[0]; }\n-  r := libc_readlink(StringBytePtr(path), _p0, Size_t(len(buf)));\n-  if r < 0 { errno = GetErrno() }\n-  n = int(r);\n-  return;\n-}\n-\n-func Rename(oldpath, newpath string) (errno int) {\n-\tr := libc_rename(StringBytePtr(oldpath), StringBytePtr(newpath));\n-\tif r < 0 { errno = GetErrno() }\n-\treturn \n-}\n-\n-func Chmod(path string, mode uint32) (errno int) {\n-  r := libc_chmod(StringBytePtr(path), Mode_t(mode));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Fchmod(fd int, mode uint32) (errno int) {\n-  r := libc_fchmod(fd, Mode_t(mode));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Chown(path string, uid int, gid int) (errno int) {\n-  r := libc_chown(StringBytePtr(path), Uid_t(uid), Gid_t(gid));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Lchown(path string, uid int, gid int) (errno int) {\n-  r := libc_lchown(StringBytePtr(path), Uid_t(uid), Gid_t(gid));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Fchown(fd int, uid int, gid int) (errno int) {\n-  r := libc_fchown(fd, Uid_t(uid), Gid_t(gid));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Truncate(path string, length int64) (errno int) {\n-  r := libc_truncate(StringBytePtr(path), Offset_t(length));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Ftruncate(fd int, length int64) (errno int) {\n-  r := libc_ftruncate(fd, Offset_t(length));\n-  if r < 0 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Utimes(path string, tv []Timeval) (errno int) {\n-  if len(tv) != 2 {\n-    return EINVAL;\n-  }\n-  r := libc_utimes(StringBytePtr(path),\n-\t\t   (*[2]Timeval)(unsafe.Pointer(&tv[0])));\n-  if r < 0 {\n-    errno = GetErrno();\n-  }\n-  return;\n-}\n-\n-// Getuid returns the numeric user id of the caller.\n-func Getuid() int {\n-  return int(libc_getuid());\n-}\n-\n-// Geteuid returns the numeric effective user id of the caller.\n-func Geteuid() int {\n-  return int(libc_geteuid());\n-}\n-\n-// Getgid returns the numeric group id of the caller.\n-func Getgid() int {\n-  return int(libc_getgid());\n-}\n-\n-// Getegid returns the numeric effective group id of the caller.\n-func Getegid() int {\n-  return int(libc_getegid());\n-}\n-\n-// Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n-func Getgroups() (gids []int, errno int) {\n-\tn := libc_getgroups(0, nil);\n-\tif n < 0 {\n-\t\treturn nil, GetErrno();\n-\t}\n-\tif n == 0 {\n-\t\treturn nil, 0;\n-\t}\n-\n-\t// Sanity check group count.  Max is 1<<16 on Linux.\n-\tif n < 0 || n > 1<<20 {\n-\t\treturn nil, EINVAL;\n-\t}\n-\n-\ta := make([]Gid_t, n);\n-\tn = libc_getgroups(n, &a[0]);\n-\tif n < 0 {\n-\t\treturn nil, GetErrno();\n-\t}\n-\tgids = make([]int, n);\n-\tfor i, v := range a[0:n] {\n-\t\tgids[i] = int(v);\n-\t}\n-\treturn;\n-}\n-\n-func Getpagesize() int {\n-\treturn libc_getpagesize();\n-}\n-\n-func TimespecToNsec(ts Timespec) int64 {\n-\treturn int64(ts.Sec)*1e9 + int64(ts.Nsec);\n-}\n-\n-func NsecToTimespec(nsec int64) (ts Timespec) {\n-\tts.Sec = Timespec_sec_t(nsec / 1e9);\n-\tts.Nsec = Timespec_nsec_t(nsec % 1e9);\n-\treturn;\n-}\n-\n-func TimevalToNsec(tv Timeval) int64 {\n-\treturn int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3;\n-}\n-\n-func NsecToTimeval(nsec int64) (tv Timeval) {\n-\tnsec += 999;\t// round up to microsecond\n-\ttv.Sec = Timeval_sec_t(nsec/1e9);\n-\ttv.Usec = Timeval_usec_t(nsec%1e9 / 1e3);\n-\treturn;\n-}\n-\n-func Exit(code int) {\n-\tlibc_exit(code);\n-}\n-\n-func fcntl(fd, cmd, arg int) (val int, errno int) {\n-  val = libc_fcntl(int(fd), int(cmd), int(arg));\n-  if val == -1 { errno = GetErrno() }\n-  return;\n-}\n-\n-func Getpid() (pid int) {\n-  return int(libc_getpid());\n-}\n-\n-func Getppid() (ppid int) {\n-  return int(libc_getppid());\n-}\n-\n-func Kill(pid int, sig int) (errno int) {\n-\tr := libc_kill(Pid_t(pid), sig)\n-\tif r < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}"}, {"sha": "fcbf254dc0e3238c39ca0671a419d0653f00e319", "filename": "libgo/syscalls/sysfile_regfile.go", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_regfile.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,14 +0,0 @@\n-// sysfile_regfile.go -- For systems which do not use the large file interface.\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-func libc_pread(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pread\")\n-func libc_pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pwrite\")\n-func libc_lseek(int, Offset_t, int) Offset_t __asm__ (\"lseek\")\n-func libc_truncate(path *byte, length Offset_t) int __asm__ (\"truncate\")\n-func libc_ftruncate(fd int, length Offset_t) int __asm__ (\"ftruncate\")\n-func libc_mmap(*byte, Size_t, int, int, int, Offset_t) *byte __asm__ (\"mmap\")"}, {"sha": "1b785f70a6415c9969cf6992176a28d4ed0c0fe7", "filename": "libgo/syscalls/sysfile_stat_largefile.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_stat_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_stat_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_stat_largefile.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,12 +0,0 @@\n-// sysfile_stat_largefile.go -- For systems which use the large file interface\n-// for *stat.\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-func libc_stat(name *byte, buf *Stat_t) int __asm__ (\"stat64\");\n-func libc_fstat(fd int, buf *Stat_t) int __asm__ (\"fstat64\");\n-func libc_lstat(name *byte, buf *Stat_t) int __asm__ (\"lstat64\");"}, {"sha": "b3d486413759cf23b65a0de11457b8f85b328ca7", "filename": "libgo/syscalls/sysfile_stat_regfile.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_stat_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fsysfile_stat_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_stat_regfile.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,12 +0,0 @@\n-// sysfile_stat_regfile.go -- For systems which do not use the large file\n-// interface for *stat.\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-func libc_stat(name *byte, buf *Stat_t) int __asm__ (\"stat\");\n-func libc_fstat(fd int, buf *Stat_t) int __asm__ (\"fstat\");\n-func libc_lstat(name *byte, buf *Stat_t) int __asm__ (\"lstat\");"}, {"sha": "bb00c792bc001c6f7e18bb49a519d5857d588e31", "filename": "libgo/syscalls/wait4.go", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fwait4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b45b87f01235d15b5d9403fa59693a97e49611a/libgo%2Fsyscalls%2Fwait4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fwait4.go?ref=7b45b87f01235d15b5d9403fa59693a97e49611a", "patch": "@@ -1,22 +0,0 @@\n-// wait4.go -- Wait4 for systems with wait4.\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-func libc_wait4(Pid_t, *int, int, *Rusage) Pid_t __asm__ (\"wait4\")\n-\n-func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {\n-\tvar status int\n-\tr := libc_wait4(Pid_t(pid), &status, options, rusage)\n-\twpid = int(r)\n-\tif r < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\tif wstatus != nil {\n-\t\t*wstatus = WaitStatus(status)\n-\t}\n-\treturn\n-}"}, {"sha": "3d3bc984a07c72ecd044ed5a9f15693589f72402", "filename": "libgo/testsuite/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de27caacfb3da386f499e0f1c65a3246675824bc/libgo%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2FMakefile.in?ref=de27caacfb3da386f499e0f1c65a3246675824bc", "patch": "@@ -86,7 +86,10 @@ GOARCH = @GOARCH@\n GOC = @GOC@\n GOCFLAGS = @GOCFLAGS@\n GOOS = @GOOS@\n-GO_SYSCALLS_SYSCALL_OS_ARCH_FILE = @GO_SYSCALLS_SYSCALL_OS_ARCH_FILE@\n+GO_LIBCALL_OS_ARCH_FILE = @GO_LIBCALL_OS_ARCH_FILE@\n+GO_LIBCALL_OS_FILE = @GO_LIBCALL_OS_FILE@\n+GO_SYSCALL_OS_ARCH_FILE = @GO_SYSCALL_OS_ARCH_FILE@\n+GO_SYSCALL_OS_FILE = @GO_SYSCALL_OS_FILE@\n GREP = @GREP@\n INSTALL = @INSTALL@\n INSTALL_DATA = @INSTALL_DATA@"}]}