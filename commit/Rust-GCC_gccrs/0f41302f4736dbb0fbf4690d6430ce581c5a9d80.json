{"sha": "0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY0MTMwMmY0NzM2ZGJiMGZiZjQ2OTBkNjQzMGNlNTgxYzVhOWQ4MA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-03T22:07:53Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-03T22:07:53Z"}, "message": "formatting tweaks\n\nFrom-SVN: r12390", "tree": {"sha": "e82dd48a4282d7b9e8b1c71b065b52af17254c52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e82dd48a4282d7b9e8b1c71b065b52af17254c52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/comments", "author": null, "committer": null, "parents": [{"sha": "9753f1136864a98cca12ab71f0ffe1af4dd84486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9753f1136864a98cca12ab71f0ffe1af4dd84486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9753f1136864a98cca12ab71f0ffe1af4dd84486"}], "stats": {"total": 5462, "additions": 3360, "deletions": 2102}, "files": [{"sha": "c93195df9e1b80693dc488c6389c851ae0304fb7", "filename": "gcc/bc-emit.c", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbc-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbc-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-emit.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -55,12 +55,13 @@ extern enum machine_mode byte_mode;\n /* Mode whose width is BITS_PER_WORD */\n extern enum machine_mode word_mode;\n \n-/* Vector indexed by opcode giving info about the args for each opcode. */\n+/* Vector indexed by opcode giving info about the args for each opcode.  */\n static struct arityvec arityvec[] = {\n #include \"bc-arity.h\"\n };\n \n /* How to print a symbol name for the assembler.  */\n+\n static void\n prsym (file, s)\n      FILE *file;\n@@ -78,7 +79,7 @@ prsym (file, s)\n \n }\n \n-/* Maintain a bucket hash table for symbol names. */\n+/* Maintain a bucket hash table for symbol names.  */\n \n #define HASH_BITS 32\n #define HASH_SIZE 509\n@@ -101,7 +102,8 @@ hash (name)\n }\n \n \n-/* Look up the named symbol, creating it if it doesn't exist. */\n+/* Look up the named symbol, creating it if it doesn't exist.  */\n+\n struct bc_sym *\n sym_lookup (name)\n      char *name;\n@@ -126,6 +128,7 @@ sym_lookup (name)\n \n \n /* Write out .globl and common symbols to the named file.  */\n+\n static void\n bc_sym_write (file)\n      FILE *file;\n@@ -160,7 +163,8 @@ bc_sym_write (file)\n \f\n \n \n-/* Create and initialize a new segment. */\n+/* Create and initialize a new segment.  */\n+\n static struct bc_seg *\n seg_create ()\n {\n@@ -176,7 +180,8 @@ seg_create ()\n }\n \n \n-/* Advance the segment index to the next alignment boundary. */\n+/* Advance the segment index to the next alignment boundary.  */\n+\n static void\n seg_align (seg, log)\n      struct bc_seg *seg;\n@@ -195,7 +200,8 @@ seg_align (seg, log)\n }\n \n \n-/* Append the given data to the given segment. */\n+/* Append the given data to the given segment.  */\n+\n static void\n seg_data (seg, data, size)\n      struct bc_seg *seg;\n@@ -215,6 +221,7 @@ seg_data (seg, data, size)\n \n \n /* Append a zero-filled skip to the given segment.  */\n+\n static void\n seg_skip (seg, size)\n      struct bc_seg *seg;\n@@ -234,7 +241,8 @@ seg_skip (seg, size)\n \n /* Define the given name as the current offset in the given segment.  It\n    is an error if the name is already defined.  Return 0 or 1 indicating\n-   failure or success respectively. */\n+   failure or success respectively.  */\n+\n static int\n seg_defsym (seg, name)\n      struct bc_seg *seg;\n@@ -258,7 +266,8 @@ seg_defsym (seg, name)\n \n \n /* Generate in seg's data a reference to the given sym, adjusted by\n-   the given offset. */\n+   the given offset.  */\n+\n static void\n seg_refsym (seg, name, offset)\n      struct bc_seg *seg;\n@@ -278,7 +287,8 @@ seg_refsym (seg, name, offset)\n }\n \n \n-/* Concatenate the contents of given segments into the first argument. */\n+/* Concatenate the contents of given segments into the first argument.  */\n+\n static void\n seg_concat (result, seg)\n      struct bc_seg *result, *seg;\n@@ -293,7 +303,7 @@ seg_concat (result, seg)\n   free (seg->data);\n \n   /* Go through the symbols and relocs of SEG, adjusting their offsets\n-     for their new location in RESULT. */\n+     for their new location in RESULT.  */\n   if (seg->syms)\n     {\n       segsym = seg->syms;\n@@ -317,6 +327,7 @@ seg_concat (result, seg)\n }\n \n /* Write a segment to a file.  */\n+\n static void\n bc_seg_write (seg, file)\n      struct bc_seg *seg;\n@@ -391,11 +402,12 @@ bc_seg_write (seg, file)\n \n \f\n \n-/* Text and data segments of the object file in making. */\n+/* Text and data segments of the object file in making.  */\n static struct bc_seg *bc_text_seg;\n static struct bc_seg *bc_data_seg;\n \n-/* Called before anything else in this module. */\n+/* Called before anything else in this module.  */\n+\n void\n bc_initialize ()\n {\n@@ -443,25 +455,26 @@ bc_initialize ()\n    require us to provide hairy location info and possibly obey alignment\n    rules imposed by the architecture) we build an auxiliary table of\n    pointer constants, and encode just offsets into this table into the\n-   actual bytecode. */\n+   actual bytecode.  */\n static struct bc_seg *ptrconsts;\n \n /* Trampoline code for the function entry.  */\n struct bc_seg *trampoline;\n \n-/* Actual byte code of the function. */\n+/* Actual byte code of the function.  */\n struct bc_seg *bytecode;\n \n-/* List of labels defined in the function. */\n+/* List of labels defined in the function.  */\n struct bc_label *labels;\n \n-/* List of label references in the function. */\n+/* List of label references in the function.  */\n struct bc_labelref *labelrefs;\n \n \n /* Add symbol to pointer table.  Return offset into table where\n    pointer was stored.  The offset usually goes into the bytecode\n-   stream as a constP literal. */\n+   stream as a constP literal.  */\n+\n int\n bc_define_pointer (p)\n      char *p;\n@@ -474,6 +487,7 @@ bc_define_pointer (p)\n \n \n /* Begin a bytecoded function.  */\n+\n int\n bc_begin_function (name)\n     char *name;\n@@ -486,6 +500,7 @@ bc_begin_function (name)\n \n \n /* Force alignment in inline bytecode.  */\n+\n void\n bc_align_bytecode (align)\n     int align;\n@@ -495,6 +510,7 @@ bc_align_bytecode (align)\n \n \n /* Emit data inline into bytecode.  */\n+\n void\n bc_emit_bytecode_const (data, size)\n      char *data;\n@@ -507,7 +523,8 @@ bc_emit_bytecode_const (data, size)\n \n /* Create a new \"bytecode label\", to have its value defined later.\n    Bytecode labels have nothing to do with the object file symbol table,\n-   and are purely local to a given bytecoded function. */\n+   and are purely local to a given bytecoded function.  */\n+\n struct bc_label *\n bc_get_bytecode_label ()\n {\n@@ -522,7 +539,8 @@ bc_get_bytecode_label ()\n }\n \n \n-/* Define the given label with the current location counter. */\n+/* Define the given label with the current location counter.  */\n+\n int\n bc_emit_bytecode_labeldef (label)\n      struct bc_label *label;\n@@ -545,7 +563,8 @@ bc_emit_bytecode_labeldef (label)\n \n \n /* Generate a location-relative reference to the given bytecode label.\n-   It need not be defined yet; label references will be backpatched later. */\n+   It need not be defined yet; label references will be backpatched later.  */\n+\n void\n bc_emit_bytecode_labelref (label)\n      struct bc_label *label;\n@@ -568,7 +587,8 @@ bc_emit_bytecode_labelref (label)\n \n \n /* Emit a reference to an external address; generate the reference in the\n-   ptrconst area, and emit an offset in the bytecode. */\n+   ptrconst area, and emit an offset in the bytecode.  */\n+\n void\n bc_emit_code_labelref (name, offset)\n      char *name;\n@@ -589,6 +609,7 @@ bc_emit_code_labelref (name, offset)\n /* Backpatch label references in the byte code, and concatenate the bytecode\n    and pointer constant segments to the cumulative text for the object file.\n    Return a label name for the pointer constants region.  */\n+\n char *\n bc_end_function ()\n {\n@@ -598,15 +619,15 @@ bc_end_function ()\n   char ptrconsts_label[20];\n   static int nlab;\n \n-  /* Backpatch bytecode label references. */\n+  /* Backpatch bytecode label references.  */\n   for (ref = labelrefs; ref; ref = ref->next)\n     if (ref->label->defined)\n       {\n \taddr = ref->label->offset;\n \tbcopy ((char *) &addr, bytecode->data + ref->offset, sizeof addr);\n       }\n \n-  /* Free the chains of labelrefs and labeldefs. */\n+  /* Free the chains of labelrefs and labeldefs.  */\n   for (ref = labelrefs; ref; ref = nextref)\n     {\n       nextref = ref->next;\n@@ -635,15 +656,17 @@ bc_end_function ()\n   return sym_lookup (ptrconsts_label)->name;\n }\n \n-/* Force alignment in const data. */\n+/* Force alignment in const data.  */\n+\n void\n bc_align_const (align)\n      int align;\n {\n   seg_align (bc_text_seg, align);\n }\n \n-/* Emit const data. */\n+/* Emit const data.  */\n+\n void\n bc_emit_const (data, size)\n      char *data;\n@@ -652,23 +675,26 @@ bc_emit_const (data, size)\n   seg_data (bc_text_seg, data, size);\n }\n \n-/* Emit a zero-filled constant skip. */\n+/* Emit a zero-filled constant skip.  */\n+\n void\n bc_emit_const_skip (size)\n      unsigned int size;\n {\n   seg_skip (bc_text_seg, size);\n }\n \n-/* Emit a label definition in const data. */\n+/* Emit a label definition in const data.  */\n+\n int\n bc_emit_const_labeldef (name)\n      char *name;\n {\n   return seg_defsym (bc_text_seg, name);\n }\n \n-/* Emit a label reference in const data. */\n+/* Emit a label reference in const data.  */\n+\n void\n bc_emit_const_labelref (name, offset)\n      char *name;\n@@ -677,15 +703,17 @@ bc_emit_const_labelref (name, offset)\n   seg_refsym (bc_text_seg, name, offset);\n }\n \n-/* Force alignment in data. */\n+/* Force alignment in data.  */\n+\n void\n bc_align_data (align)\n      int align;\n {\n   seg_align (bc_data_seg, align);\n }\n \n-/* Emit data. */\n+/* Emit data.  */\n+\n void\n bc_emit_data (data, size)\n      char *data;\n@@ -695,22 +723,25 @@ bc_emit_data (data, size)\n }\n \n /* Emit a zero-filled data skip.  */\n+\n void\n bc_emit_data_skip (size)\n      unsigned int size;\n {\n   seg_skip (bc_data_seg, size);\n }\n \n-/* Emit label definition in data. */\n+/* Emit label definition in data.  */\n+\n int\n bc_emit_data_labeldef (name)\n      char *name;\n {\n   return seg_defsym (bc_data_seg, name);\n }\n \n-/* Emit label reference in data. */\n+/* Emit label reference in data.  */\n+\n void\n bc_emit_data_labelref (name, offset)\n      char *name;\n@@ -722,6 +753,7 @@ bc_emit_data_labelref (name, offset)\n /* Emit a common block of the given name and size.  Note that\n    when the .o file is actually written non-global \"common\"\n    blocks will have to be turned into space in the data section.  */\n+\n int\n bc_emit_common (name, size)\n      char *name;\n@@ -739,7 +771,8 @@ bc_emit_common (name, size)\n   return 1;\n }\n \n-/* Globalize the given label. */\n+/* Globalize the given label.  */\n+\n void\n bc_globalize_label (name)\n      char *name;\n@@ -846,6 +879,7 @@ bc_gen_rtx (label, offset, bc_label)\n \n \n /* Print bytecode rtx */\n+\n void\n bc_print_rtl (fp, r)\n      FILE *fp;\n@@ -860,6 +894,7 @@ bc_print_rtl (fp, r)\n \n \n /* Emit a bytecode, keeping a running tally of the stack depth.  */\n+\n void\n bc_emit_bytecode (bytecode)\n      enum bytecode_opcode bytecode;\n@@ -883,7 +918,7 @@ bc_emit_bytecode (bytecode)\n      will cause an interpreter stack undeflow when executed.  Instead of\n      dumping core on such occasions, we omit the bytecode.  Erroneous code\n      should not be executed, regardless.  This makes life much easier, since\n-     we don't have to deceive ourselves about the known stack depth. */\n+     we don't have to deceive ourselves about the known stack depth.  */\n \n   bc_emit_bytecode_const (&byte, 1);\n \n@@ -907,7 +942,8 @@ bc_emit_bytecode (bytecode)\n \n /* Emit a complete bytecode instruction, expecting the correct number\n    of literal values in the call.  First argument is the instruction, the\n-   remaining arguments are literals of size HOST_WIDE_INT or smaller. */\n+   remaining arguments are literals of size HOST_WIDE_INT or smaller.  */\n+\n void\n bc_emit_instruction VPROTO((enum bytecode_opcode opcode, ...))\n {\n@@ -965,6 +1001,7 @@ bc_emit_instruction VPROTO((enum bytecode_opcode opcode, ...))\n    coded function.  The argument is a label name of the interpreter\n    bytecode callinfo structure; the return value is a label name for\n    the beginning of the actual bytecode.  */\n+\n char *\n bc_emit_trampoline (callinfo)\n      char *callinfo;"}, {"sha": "63587e284a91a9b760a4198bac68fd8f5d526877", "filename": "gcc/bc-optab.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbc-optab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbc-optab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-optab.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -55,8 +55,8 @@ static enum typecode unsigned_mode_to_code_map[MAX_MACHINE_MODE+1];\n static struct conversion_recipe\n {\n   unsigned char *opcodes;\t/* Bytecodes to emit in order.  */\n-  int nopcodes;\t\t\t/* Count of bytecodes. */\n-  int cost;\t\t\t/* A rather arbitrary cost function. */\n+  int nopcodes;\t\t\t/* Count of bytecodes.  */\n+  int cost;\t\t\t/* A rather arbitrary cost function.  */\n } conversion_recipe[NUM_TYPECODES][NUM_TYPECODES];\n \n /* Binary operator tables.  */\n@@ -405,6 +405,7 @@ struct conversion_list\n    * Either sign extensions or zero extensions may be present, but not both.\n    * No widening conversions occur after a signed/unsigned conversion.\n    * The sequence of sizes must be strict nonincreasing or nondecreasing.  */\n+\n static int\n conversion_reasonable_p (conversion, list)\n      struct conversion_info *conversion;\n@@ -517,6 +518,7 @@ conversion_reasonable_p (conversion, list)\n \n /* Exhaustively search all reasonable conversions to find one to\n    convert the given types.  */\n+\n static struct conversion_recipe\n deduce_conversion (from, to)\n      enum typecode from, to;\n@@ -614,6 +616,7 @@ deduce_conversion (from, to)\n \n \n /* Emit a conversion between the given scalar types.  */\n+\n void\n emit_typecode_conversion (from, to)\n      enum typecode from, to;\n@@ -627,6 +630,7 @@ emit_typecode_conversion (from, to)\n \n \n /* Initialize mode_to_code_map[] */\n+\n void\n bc_init_mode_to_code_map ()\n {\n@@ -650,6 +654,7 @@ bc_init_mode_to_code_map ()\n }\n \n /* Given a machine mode return the preferred typecode.  */\n+\n enum typecode\n preferred_typecode (mode, unsignedp)\n      enum machine_mode mode;\n@@ -668,6 +673,7 @@ preferred_typecode (mode, unsignedp)\n \n \n /* Expand a conversion between the given types.  */\n+\n void\n bc_expand_conversion (from, to)\n      tree from, to;\n@@ -681,6 +687,7 @@ bc_expand_conversion (from, to)\n }\n \n /* Expand a conversion of the given type to a truth value.  */\n+\n void\n bc_expand_truth_conversion (from)\n      tree from;\n@@ -692,6 +699,7 @@ bc_expand_truth_conversion (from)\n }\n \n /* Emit an appropriate binary operation.  */\n+\n void\n bc_expand_binary_operation (optab, resulttype, arg0, arg1)\n      struct binary_operator optab[];\n@@ -733,6 +741,7 @@ bc_expand_binary_operation (optab, resulttype, arg0, arg1)\n }\n \n /* Emit an appropriate unary operation.  */\n+\n void\n bc_expand_unary_operation (optab, resulttype, arg0)\n      struct unary_operator optab[];\n@@ -769,6 +778,7 @@ bc_expand_unary_operation (optab, resulttype, arg0)\n \n \n /* Emit an appropriate increment.  */\n+\n void\n bc_expand_increment (optab, type)\n      struct increment_operator optab[];"}, {"sha": "d0b4d5a112c74a73b3fe401c6d4afc24428aef0b", "filename": "gcc/bi-arity.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbi-arity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbi-arity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-arity.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -63,7 +63,8 @@ main ()\n }\n \n /* Safely allocate NBYTES bytes of memory. Returns pointer to block of\n-   memory. */\n+   memory.  */\n+\n char *\n xmalloc (nbytes)\n      int nbytes;"}, {"sha": "0ec0b1d56d3b05f68394051b584689500d2a6fc5", "filename": "gcc/bi-lexer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbi-lexer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbi-lexer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-lexer.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -24,7 +24,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n /* Safely allocate NBYTES bytes of memory.  Returns pointer to block of\n-   memory. */\n+   memory.  */\n \n static char *\n xmalloc (nbytes)\n@@ -43,7 +43,7 @@ xmalloc (nbytes)\n \n \n /* Safely reallocate BLOCK so its size becomes NBYTES.\n-   The block returned may be different from the one supplied. */\n+   The block returned may be different from the one supplied.  */\n \n static char *\n xrealloc (block, nbytes)\n@@ -68,7 +68,7 @@ xrealloc (block, nbytes)\n    purposes here, a sequence of characters that starts with the regexp\n    ``[^ #\\t\\n(),]'' and is then followed by the regexp ``[^#(),]*''. Any\n    character is accepted if preceded by a backslash, \"\\\\\".  It is assumed\n-   that the first character has already been checked by the main loop. */\n+   that the first character has already been checked by the main loop.  */\n \n static char *\n scan_string ()"}, {"sha": "9e5799c028beaba4c82232eaab8e450cbf459e4d", "filename": "gcc/bi-opcode.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbi-opcode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbi-opcode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-opcode.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -61,7 +61,8 @@ main(argc, argv)\n }\n \n /* Safely allocate NBYTES bytes of memory. Returns pointer to block of\n-   memory. */\n+   memory.  */\n+\n char *\n xmalloc (nbytes)\n      int nbytes;"}, {"sha": "ad86dd19cf23ed7df47f859d22f5165fa527f7a8", "filename": "gcc/bi-opname.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbi-opname.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fbi-opname.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-opname.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -42,7 +42,8 @@ main()\n }\n \n /* Safely allocate NBYTES bytes of memory. Returns pointer to block of\n-   memory. */\n+   memory.  */\n+\n char *\n xmalloc (nbytes)\n      int nbytes;"}, {"sha": "429601f21fa4b6a8847738ce79a373184a702177", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -27,7 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"c-tree.h\"\n \n-extern char* xmalloc ();\n+extern char *xmalloc ();\n \n enum formals_style_enum {\n   ansi,\n@@ -37,26 +37,26 @@ enum formals_style_enum {\n typedef enum formals_style_enum formals_style;\n \n \n-static char* data_type;\n+static char *data_type;\n \n-static char * concat ();\n-static char * concat3 ();\n-static char * gen_formal_list_for_type ();\n-static int    deserves_ellipsis ();\n-static char * gen_formal_list_for_func_def ();\n-static char * gen_type ();\n-static char * gen_decl ();\n+static char *concat ();\n+static char *concat3 ();\n+static char *gen_formal_list_for_type ();\n+static int   deserves_ellipsis ();\n+static char *gen_formal_list_for_func_def ();\n+static char *gen_type ();\n+static char *gen_decl ();\n void   gen_aux_info_record ();\n \f\n /*  Take two strings and mash them together into a newly allocated area.  */\n \n-static char*\n+static char *\n concat (s1, s2)\n-     char* s1;\n-     char* s2;\n+     char *s1;\n+     char *s2;\n {\n   int size1, size2;\n-  char* ret_val;\n+  char *ret_val;\n \n   if (!s1)\n     s1 = \"\";\n@@ -73,14 +73,14 @@ concat (s1, s2)\n \n /*  Take three strings and mash them together into a newly allocated area.  */\n \n-static char*\n+static char *\n concat3 (s1, s2, s3)\n-     char* s1;\n-     char* s2;\n-     char* s3;\n+     char *s1;\n+     char *s2;\n+     char *s3;\n {\n   int size1, size2, size3;\n-  char* ret_val;\n+  char *ret_val;\n \n   if (!s1)\n     s1 = \"\";\n@@ -113,7 +113,7 @@ concat3 (s1, s2, s3)\n    `const char *foo;' and *not* `char const *foo;' so we try to create types\n    that look as expected.  */\n \n-static char*\n+static char *\n affix_data_type (type_or_decl)\n      char *type_or_decl;\n {\n@@ -156,14 +156,14 @@ affix_data_type (type_or_decl)\n    this function type.  Return the whole formal parameter list (including\n    a pair of surrounding parens) as a string.   Note that if the style\n    we are currently aiming for is non-ansi, then we just return a pair\n-   of empty parens here. */\n+   of empty parens here.  */\n \n-static char*\n+static char *\n gen_formal_list_for_type (fntype, style)\n      tree fntype;\n      formals_style style;\n {\n-  char* formal_list = \"\";\n+  char *formal_list = \"\";\n   tree formal_type;\n \n   if (style != ansi)\n@@ -172,7 +172,7 @@ gen_formal_list_for_type (fntype, style)\n   formal_type = TYPE_ARG_TYPES (fntype);\n   while (formal_type && TREE_VALUE (formal_type) != void_type_node)\n     {\n-      char* this_type;\n+      char *this_type;\n \n       if (*formal_list)\n         formal_list = concat (formal_list, \", \");\n@@ -278,12 +278,12 @@ deserves_ellipsis (fntype)\n    This routine returns a string which is the source form for the entire\n    function formal parameter list.  */\n \n-static char*\n+static char *\n gen_formal_list_for_func_def (fndecl, style)\n      tree fndecl;\n      formals_style style;\n {\n-  char* formal_list = \"\";\n+  char *formal_list = \"\";\n   tree formal_decl;\n \n   formal_decl = DECL_ARGUMENTS (fndecl);\n@@ -353,9 +353,9 @@ gen_formal_list_for_func_def (fndecl, style)\n    to do at this point is for the initial caller to prepend the \"data_type\"\n    string onto the returned \"seed\".  */\n \n-static char*\n+static char *\n gen_type (ret_val, t, style)\n-     char* ret_val;\n+     char *ret_val;\n      tree t;\n      formals_style style;\n {\n@@ -517,13 +517,13 @@ gen_type (ret_val, t, style)\n    associated with a function definition.  In this case, we can assume that\n    an attached list of DECL nodes for function formal arguments is present.  */\n \n-static char*\n+static char *\n gen_decl (decl, is_func_definition, style)\n      tree decl;\n      int is_func_definition;\n      formals_style style;\n {\n-  char* ret_val;\n+  char *ret_val;\n \n   if (DECL_NAME (decl))\n     ret_val = IDENTIFIER_POINTER (DECL_NAME (decl));\n@@ -591,7 +591,7 @@ gen_decl (decl, is_func_definition, style)\n   return ret_val;\n }\n \n-extern FILE* aux_info_file;\n+extern FILE *aux_info_file;\n \n /* Generate and write a new line of info to the aux-info (.X) file.  This\n    routine is called once for each function declaration, and once for each"}, {"sha": "3330c73cce715fb5d79bf33071e063f95785aff6", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -284,7 +284,7 @@ init_attributes ()\n /* Process the attributes listed in ATTRIBUTES and PREFIX_ATTRIBUTES\n    and install them in NODE, which is either a DECL (including a TYPE_DECL)\n    or a TYPE.  PREFIX_ATTRIBUTES can appear after the declaration specifiers\n-   and declaration modifiers but before the declaration proper. */\n+   and declaration modifiers but before the declaration proper.  */\n \n void\n decl_attributes (node, attributes, prefix_attributes)\n@@ -645,7 +645,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t\tif (first_arg_num != 0)\n \t\t  {\n \t\t    /* Verify that first_arg_num points to the last arg,\n-\t\t       the ... */\n+\t\t       the ...  */\n \t\t    while (argument)\n \t\t      arg_num++, argument = TREE_CHAIN (argument);\n \t\t  if (arg_num != first_arg_num)\n@@ -2292,7 +2292,7 @@ truthvalue_conversion (expr)\n       if (TREE_CODE (TREE_TYPE (expr)) == REFERENCE_TYPE\n \t  || TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == REFERENCE_TYPE)\n \tbreak;\n-      /* fall through... */\n+      /* fall through...  */\n     case NOP_EXPR:\n       /* If this is widening the argument, we can ignore it.  */\n       if (TYPE_PRECISION (TREE_TYPE (expr))\n@@ -2306,7 +2306,7 @@ truthvalue_conversion (expr)\n       if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n \t  && TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE)\n \tbreak;\n-      /* fall through... */\n+      /* fall through...  */\n     case BIT_XOR_EXPR:\n       /* This and MINUS_EXPR can be changed into a comparison of the\n \t two objects.  */"}, {"sha": "2ed017f36305f2b00151eb4e26604e3a26172db6", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -455,7 +455,7 @@ int flag_no_nonansi_builtin;\n int flag_traditional;\n \n /* Nonzero means to allow single precision math even if we're generally\n-   being traditional. */\n+   being traditional.  */\n int flag_allow_single_precision = 0;\n \n /* Nonzero means to treat bitfields as signed unless they say `unsigned'.  */\n@@ -525,7 +525,7 @@ int warn_redundant_decls = 0;\n \n int warn_nested_externs = 0;\n \n-/* Warn about *printf or *scanf format/argument anomalies. */\n+/* Warn about *printf or *scanf format/argument anomalies.  */\n \n int warn_format;\n \n@@ -2807,7 +2807,7 @@ lookup_name_current_level (name)\n }\n \f\n /* Create the predefined scalar types of C,\n-   and some nodes representing standard constants (0, 1, (void *)0).\n+   and some nodes representing standard constants (0, 1, (void *) 0).\n    Initialize the global binding level.\n    Make definitions for built-in primitive functions.  */\n \n@@ -6086,7 +6086,7 @@ start_function (declspecs, declarator, prefix_attributes, attributes, nested)\n   tree restype;\n   int old_immediate_size_expand = immediate_size_expand;\n \n-  current_function_returns_value = 0;  /* Assume, until we see it does. */\n+  current_function_returns_value = 0;  /* Assume, until we see it does.  */\n   current_function_returns_null = 0;\n   warn_about_return_type = 0;\n   current_extern_inline = 0;"}, {"sha": "f8dec10b98b395d7ba823d4bad0a47a348b2ff00", "filename": "gcc/c-iterate.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -412,7 +412,7 @@ void\n push_iterator_stack ()\n {\n   struct iter_stack_node *new_top\n-    = (struct iter_stack_node*) \n+    = (struct iter_stack_node *) \n       obstack_alloc (&ixp_obstack, sizeof (struct iter_stack_node));\n \n   new_top->first = 0;\n@@ -445,15 +445,15 @@ add_ixpansion (idecl, pro_start, pro_end, epi_start, epi_end)\n      tree idecl;\n      rtx pro_start, pro_end, epi_start, epi_end;\n {\n-  struct ixpansion* newix;\n+  struct ixpansion *newix;\n     \n   /* Do nothing if we are not inside \"({...})\",\n      as in that case this expansion can't need subsequent RTL modification.  */\n   if (iter_stack == 0)\n     return;\n \n-  newix = (struct ixpansion*) obstack_alloc (&ixp_obstack,\n-\t\t\t\t\t     sizeof (struct ixpansion));\n+  newix = (struct ixpansion *) obstack_alloc (&ixp_obstack,\n+\t\t\t\t\t      sizeof (struct ixpansion));\n   newix->ixdecl = idecl;\n   newix->ixprologue_start = pro_start;\n   newix->ixprologue_end   = pro_end;\n@@ -474,7 +474,7 @@ static void\n delete_ixpansion (idecl)\n      tree idecl;\n {\n-  struct ixpansion* previx = 0, *ix;\n+  struct ixpansion *previx = 0, *ix;\n \n   for (ix = sublevel_ixpansions.first; ix; ix = ix->next)\n     if (ix->ixdecl == idecl)\n@@ -580,7 +580,7 @@ pixl (head)\n   return head;\n }\n \n-/* Print Iterator Stack*/\n+/* Print Iterator Stack.  */\n \n void\n pis ()"}, {"sha": "2e59e3a15cb7fa627ba2e0b55d5aac9c47d9a0de", "filename": "gcc/c-lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -129,7 +129,8 @@ GNU_xref_end ()\n   fatal (\"GCC does not yet support XREF\");\n }\n \n-/* called at end of parsing, but before end-of-file processing.  */\n+/* Called at end of parsing, but before end-of-file processing.  */\n+\n void\n finish_file ()\n {"}, {"sha": "2c06792bf476ddc950a8784ea2d1a2b8f2b447a0", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -29,7 +29,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* When structure field packing is in effect, this variable is the\n    number of bits to use as the maximum alignment.  When packing is not\n-   in effect, this is zero. */\n+   in effect, this is zero.  */\n \n extern int maximum_field_alignment;\n "}, {"sha": "e4a9ecef46751098140aeffb0de80f02e8a22ed1", "filename": "gcc/c-tree.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -40,27 +40,27 @@ struct lang_identifier\n /* This represents the value which the identifier has in the\n    file-scope namespace.  */\n #define IDENTIFIER_GLOBAL_VALUE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->global_value)\n+  (((struct lang_identifier *) (NODE))->global_value)\n /* This represents the value which the identifier has in the current\n    scope.  */\n #define IDENTIFIER_LOCAL_VALUE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->local_value)\n+  (((struct lang_identifier *) (NODE))->local_value)\n /* This represents the value which the identifier has as a label in\n    the current label scope.  */\n #define IDENTIFIER_LABEL_VALUE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->label_value)\n+  (((struct lang_identifier *) (NODE))->label_value)\n /* This records the extern decl of this identifier, if it has had one\n    at any point in this compilation.  */\n #define IDENTIFIER_LIMBO_VALUE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->limbo_value)\n+  (((struct lang_identifier *) (NODE))->limbo_value)\n /* This records the implicit function decl of this identifier, if it\n    has had one at any point in this compilation.  */\n #define IDENTIFIER_IMPLICIT_DECL(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->implicit_decl)\n+  (((struct lang_identifier *) (NODE))->implicit_decl)\n /* This is the last function in which we printed an \"undefined variable\"\n    message for this identifier.  Value is a FUNCTION_DECL or null.  */\n #define IDENTIFIER_ERROR_LOCUS(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->error_locus)\n+  (((struct lang_identifier *) (NODE))->error_locus)\n \n /* In identifiers, C uses the following fields in a special way:\n    TREE_PUBLIC        to record that there was a previous local extern decl.\n@@ -109,7 +109,7 @@ struct lang_type\n \n /* Store a value in that field.  */\n #define C_SET_EXP_ORIGINAL_CODE(exp, code) \\\n-  (TREE_COMPLEXITY (exp) = (int)(code))\n+  (TREE_COMPLEXITY (exp) = (int) (code))\n \n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))"}, {"sha": "9e97bffe006633cb41201cc69a3c2695aa55fe78", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -395,7 +395,7 @@ common_type (t1, t2)\n \t  }\n \n \tt1 = build_function_type (valtype, newargs);\n-\t/* ... falls through ... */\n+\t/* ... falls through ...  */\n       }\n \n     default:\n@@ -1721,7 +1721,7 @@ convert_arguments (typelist, values, name, fundecl)\n \t\t}\n \n \t      parmval = convert_for_assignment (type, val, \n-\t\t\t\t\t        (char *)0, /* arg passing  */\n+\t\t\t\t\t        (char *) 0, /* arg passing  */\n \t\t\t\t\t\tfundecl, name, parmnum + 1);\n \t      \n #ifdef PROMOTE_PROTOTYPES\n@@ -3284,7 +3284,7 @@ mark_addressable (exp)\n \t    return 0;\n \t  }\n \n-\t/* ... fall through ... */\n+\t/* ... fall through ...  */\n \n       case ADDR_EXPR:\n       case ARRAY_REF:\n@@ -4079,7 +4079,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t  if (! memb_types)\n \t    {\n \t      /* We have only a marginally acceptable member type;\n-\t\t it needs a warning. */\n+\t\t it needs a warning.  */\n \t      register tree ttl = TREE_TYPE (marginal_memb_type);\n \t      register tree ttr = TREE_TYPE (rhstype);\n \n@@ -5035,7 +5035,7 @@ static tree constructor_pending_elts;\n static int constructor_depth;\n \n /* 0 if implicitly pushing constructor levels is allowed.  */\n-int constructor_no_implicit = 0; /* 0 for C; 1 for some other languages. */\n+int constructor_no_implicit = 0; /* 0 for C; 1 for some other languages.  */\n \n /* 1 if this constructor level was entered implicitly.  */\n static int constructor_implicit;\n@@ -6369,7 +6369,7 @@ process_init_element (value)\n \t      break;\n \t    }\n \n-\t  /* In the case of [LO .. HI] = VALUE, only evaluate VALUE once. */\n+\t  /* In the case of [LO .. HI] = VALUE, only evaluate VALUE once.  */\n \t  if (constructor_range_end)\n \t    value = save_expr (value);\n "}, {"sha": "ed33ae709211e4d1b93e7c67becdb167b4520cc4", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -182,7 +182,8 @@ init_caller_save ()\n \t  reg_save_code[i][j] = recog_memoized (saveinsn);\n \t  reg_restore_code[i][j] = recog_memoized (restinsn);\n \n-\t  /* Now extract both insns and see if we can meet their constraints. */\n+\t  /* Now extract both insns and see if we can meet their\n+             constraints.  */\n \t  ok = (reg_save_code[i][j] != -1 && reg_restore_code[i][j] != -1);\n \t  if (ok)\n \t    {\n@@ -307,15 +308,15 @@ setup_save_areas (pchanged)\n \t      ok &= (TEST_HARD_REG_BIT (hard_regs_used, regno) != 0);\n \t    }\n \n-\t/* We have found an acceptable mode to store in. */\n+\t/* We have found an acceptable mode to store in.  */\n \tif (ok)\n \t  {\n \n \t    regno_save_mem[i][j]\n \t      = assign_stack_local (regno_save_mode[i][j],\n \t\t\t\t    GET_MODE_SIZE (regno_save_mode[i][j]), 0);\n \n-\t    /* Setup single word save area just in case... */\n+\t    /* Setup single word save area just in case...  */\n \t    for (k = 0; k < j; k++)\n \t      {\n \t\t/* This should not depend on WORDS_BIG_ENDIAN."}, {"sha": "8d627f9c5b8937da5bf355099e327273ef240e8e", "filename": "gcc/calls.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -261,7 +261,7 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n   funexp = protect_from_queue (funexp, 0);\n \n   if (fndecl != 0)\n-    /* Get possible static chain value for nested function in C. */\n+    /* Get possible static chain value for nested function in C.  */\n     static_chain_value = lookup_static_chain (fndecl);\n \n   /* Make a valid memory address and copy constants thru pseudo-regs,\n@@ -1392,8 +1392,9 @@ expand_call (exp, target, ignore)\n \n       int needed = args_size.constant;\n \n-      /* Store the maximum argument space used.  It will be pushed by the\n-\t prologue (if ACCUMULATE_OUTGOING_ARGS, or stack overflow checking). */\n+      /* Store the maximum argument space used.  It will be pushed by\n+\t the prologue (if ACCUMULATE_OUTGOING_ARGS, or stack overflow\n+\t checking).  */\n \n       if (needed > current_function_outgoing_args_size)\n \tcurrent_function_outgoing_args_size = needed;\n@@ -1611,7 +1612,7 @@ expand_call (exp, target, ignore)\n     }\n \n   /* Precompute all register parameters.  It isn't safe to compute anything\n-     once we have started filling any specific hard regs. */\n+     once we have started filling any specific hard regs.  */\n   reg_parm_seen = 0;\n   for (i = 0; i < num_actuals; i++)\n     if (args[i].reg != 0 && ! args[i].pass_on_stack)\n@@ -2212,7 +2213,7 @@ expand_call (exp, target, ignore)\n \n   /* If this was alloca, record the new stack level for nonlocal gotos.  \n      Check for the handler slots since we might not have a save area\n-     for non-local gotos. */\n+     for non-local gotos.  */\n \n   if (may_be_alloca && nonlocal_goto_handler_slot != 0)\n     emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, NULL_RTX);\n@@ -2380,7 +2381,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \tabort ();\n #endif\n \n-      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree)0, 1);\n+      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n     }\n   va_end (p);\n \n@@ -2639,7 +2640,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t  )\n \targs_size.constant += argvec[count].size.constant;\n \n-      FUNCTION_ARG_ADVANCE (args_so_far, Pmode, (tree)0, 1);\n+      FUNCTION_ARG_ADVANCE (args_so_far, Pmode, (tree) 0, 1);\n \n       count++;\n     }\n@@ -2728,7 +2729,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \tabort ();\n #endif\n \n-      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree)0, 1);\n+      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n     }\n   va_end (p);\n \n@@ -2971,8 +2972,8 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n   if (argblock && ! variable_size && arg->stack)\n     {\n #ifdef ARGS_GROW_DOWNWARD\n-      /* stack_slot is negative, but we want to index stack_usage_map */\n-      /* with positive values. */\n+      /* stack_slot is negative, but we want to index stack_usage_map\n+         with positive values.  */\n       if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n \tupper_bound = -INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1)) + 1;\n       else"}, {"sha": "ecc4b3b65cd1394d0111736c1b00718ae5b02ced", "filename": "gcc/cccp.c", "status": "modified", "additions": 183, "deletions": 202, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -301,7 +301,7 @@ static void hack_vms_include_specification ();\n #endif\n \n #ifndef NULL_PTR\n-#define NULL_PTR ((GENERIC_PTR)0)\n+#define NULL_PTR ((GENERIC_PTR) 0)\n #endif\n \n #ifndef INCLUDE_LEN_FUDGE\n@@ -427,7 +427,7 @@ static FILE *pcp_outfile;\n \n /* Nonzero means we are inside an IF during a -pcp run.  In this mode\n    macro expansion is done, and preconditions are output for all macro\n-   uses requiring them. */\n+   uses requiring them.  */\n static int pcp_inside_if;\n \n /* Nonzero means never to include precompiled files.\n@@ -547,7 +547,7 @@ typedef struct file_buf FILE_BUF;\n \n /* The output buffer.  Its LENGTH field is the amount of room allocated\n    for the buffer, not the number of chars actually present.  To get\n-   that, subtract outbuf.buf from outbuf.bufp. */\n+   that, subtract outbuf.buf from outbuf.bufp.  */\n \n #define OUTBUF_SIZE 10\t/* initial size of output buffer */\n static FILE_BUF outbuf;\n@@ -577,9 +577,9 @@ struct file_name_list\n     char fname[1];\n   };\n \n-/* #include \"file\" looks in source file dir, then stack. */\n-/* #include <file> just looks in the stack. */\n-/* -I directories are added to the end, then the defaults are added. */\n+/* #include \"file\" looks in source file dir, then stack.  */\n+/* #include <file> just looks in the stack.  */\n+/* -I directories are added to the end, then the defaults are added.  */\n /* The */\n static struct default_include {\n   char *fname;\t\t\t/* The name of the directory.  */\n@@ -721,7 +721,7 @@ enum sharp_token_type {\n    #define f(x) x+x+x+x+x+x+x would have replacement text \"++++++\" and\n    pattern list\n      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }\n-   where (x, y) means (nchars, argno). */\n+   where (x, y) means (nchars, argno).  */\n \n typedef struct definition DEFINITION;\n struct definition {\n@@ -755,7 +755,7 @@ struct definition {\n };\n \n /* different kinds of things that can appear in the value field\n-   of a hash node.  Actually, this may be useless now. */\n+   of a hash node.  Actually, this may be useless now.  */\n union hashval {\n   char *cpval;\n   DEFINITION *defn;\n@@ -782,7 +782,7 @@ static char rest_extension[] = \"...\";\n    plus some special tokens like __LINE__ (these each have their own\n    type, and the appropriate code is run when that type of node is seen.\n    It does not contain control words like \"#define\", which are recognized\n-   by a separate piece of code. */\n+   by a separate piece of code.  */\n \n /* different flavors of hash nodes --- also used in keyword table */\n enum node_type {\n@@ -831,7 +831,7 @@ struct hashnode {\n   struct hashnode *prev;\n   struct hashnode **bucket_hdr;\t/* also, a back pointer to this node's hash\n \t\t\t\t   chain is kept, in case the node is the head\n-\t\t\t\t   of the chain and gets deleted. */\n+\t\t\t\t   of the chain and gets deleted.  */\n   enum node_type type;\t\t/* type of special token */\n   int length;\t\t\t/* length of token, for quick comparison */\n   U_CHAR *name;\t\t\t/* the actual name */\n@@ -845,7 +845,7 @@ typedef struct hashnode HASHNODE;\n    loop computes the hash value `on the fly' for most tokens,\n    in order to avoid the overhead of a lot of procedure calls to\n    the hashf () function.  Hashf () only exists for the sake of\n-   politeness, for use when speed isn't so important. */\n+   politeness, for use when speed isn't so important.  */\n \n #define HASHSIZE 1403\n static HASHNODE *hashtab[HASHSIZE];\n@@ -919,7 +919,7 @@ struct assertion_hashnode {\n   struct assertion_hashnode *prev;\n   /* also, a back pointer to this node's hash\n      chain is kept, in case the node is the head\n-     of the chain and gets deleted. */\n+     of the chain and gets deleted.  */\n   struct assertion_hashnode **bucket_hdr;\n   int length;\t\t\t/* length of token, for quick comparison */\n   U_CHAR *name;\t\t\t/* the actual name */\n@@ -934,7 +934,7 @@ typedef struct assertion_hashnode ASSERTION_HASHNODE;\n    loop computes the hash value `on the fly' for most tokens,\n    in order to avoid the overhead of a lot of procedure calls to\n    the hashf function.  hashf only exists for the sake of\n-   politeness, for use when speed isn't so important. */\n+   politeness, for use when speed isn't so important.  */\n \n #define ASSERTION_HASHSIZE 37\n static ASSERTION_HASHNODE *assertion_hashtab[ASSERTION_HASHSIZE];\n@@ -951,7 +951,7 @@ struct directive {\n   int length;\t\t\t/* Length of name */\n   int (*func) DO_PROTO;\t/* Function to handle directive */\n   char *name;\t\t\t/* Name of directive */\n-  enum node_type type;\t\t/* Code which describes which directive. */\n+  enum node_type type;\t\t/* Code which describes which directive.  */\n   char angle_brackets;\t\t/* Nonzero => <...> is special.  */\n   char traditional_comments;\t/* Nonzero: keep comments if -traditional.  */\n   char pass_thru;\t\t/* Copy preprocessed directive to output file.  */\n@@ -1011,9 +1011,9 @@ static struct directive directive_table[] = {\n    this points to the # (or the : of the %:) that started the directive.  */\n U_CHAR *directive_start;\n \n-/* table to tell if char can be part of a C identifier. */\n+/* table to tell if char can be part of a C identifier.  */\n U_CHAR is_idchar[256];\n-/* table to tell if char can be first char of a c identifier. */\n+/* table to tell if char can be first char of a c identifier.  */\n U_CHAR is_idstart[256];\n /* table to tell if c is horizontal space.  */\n U_CHAR is_hor_space[256];\n@@ -1320,7 +1320,7 @@ main (argc, argv)\n     struct rlimit rlim;\n \n     /* Set the stack limit huge so that alloca (particularly stringtab\n-     * in dbxread.c) does not fail. */\n+       in dbxread.c) does not fail.  */\n     getrlimit (RLIMIT_STACK, &rlim);\n     rlim.rlim_cur = rlim.rlim_max;\n     setrlimit (RLIMIT_STACK, &rlim);\n@@ -1895,8 +1895,8 @@ main (argc, argv)\n \n   done_initializing = 1;\n \n-  { /* read the appropriate environment variable and if it exists\n-       replace include_defaults with the listed path. */\n+  { /* Read the appropriate environment variable and if it exists\n+       replace include_defaults with the listed path.  */\n     char *epath = 0;\n     switch ((objc << 1) + cplusplus)\n       {\n@@ -2351,7 +2351,7 @@ index0 (s, c, n)\n    Using an extra pass through the buffer takes a little extra time,\n    but is infinitely less hairy than trying to handle trigraphs inside\n    strings, etc. everywhere, and also makes sure that trigraphs are\n-   only translated in the top level of processing. */\n+   only translated in the top level of processing.  */\n \n static void\n trigraph_pcp (buf)\n@@ -2402,7 +2402,7 @@ trigraph_pcp (buf)\n     len = sptr - fptr - 2;\n \n     /* BSD doc says bcopy () works right for overlapping strings.  In ANSI\n-       C, this will be memmove (). */\n+       C, this will be memmove ().  */\n     if (bptr != fptr && len > 0)\n       bcopy ((char *) fptr, (char *) bptr, len);\n \n@@ -2497,8 +2497,7 @@ name_newline_fix (bp)\n \n    Upon return, any arg will be pointed to with argstart and will be\n    arglen long.  Note that we don't parse that arg since it will just\n-   be printed out again.\n-*/\n+   be printed out again.  */\n \n static char *\n get_lintcmd (ibp, limit, argstart, arglen, cmdlen)\n@@ -2702,7 +2701,7 @@ do { ip = &instack[indepth];\t\t\\\n \tif (ident_length)\n \t  goto specialchar;\n \t/* Copy #foo (bar lose) without macro expansion.  */\n-\tobp[-1] = '#';\t/* In case it was '%'. */\n+\tobp[-1] = '#';\t/* In case it was '%'.  */\n \tSKIP_WHITE_SPACE (ibp);\n \twhile (is_idchar[*ibp])\n \t  *obp++ = *ibp++;\n@@ -2922,10 +2921,10 @@ do { ip = &instack[indepth];\t\t\\\n \tgoto specialchar;\n \n       if (*ibp == '/') {\n-\t/* C++ style comment... */\n+\t/* C++ style comment...  */\n \tstart_line = ip->lineno;\n \n-\t/* Comments are equivalent to spaces. */\n+\t/* Comments are equivalent to spaces.  */\n \tif (! put_out_comments)\n \t  obp[-1] = ' ';\n \n@@ -2960,7 +2959,7 @@ do { ip = &instack[indepth];\t\t\\\n \n       start_line = ip->lineno;\n \n-      ++ibp;\t\t\t/* Skip the star. */\n+      ++ibp;\t\t\t/* Skip the star.  */\n \n       /* If this cpp is for lint, we peek inside the comments: */\n       if (for_lint) {\n@@ -3973,7 +3972,7 @@ handle_directive (ip, op)\n \t either the appropriate place in the input buffer, or to\n \t the temp buffer if it was necessary to make one.  cp\n \t points to the first char after the contents of the (possibly\n-\t copied) directive, in either case. */\n+\t copied) directive, in either case.  */\n       (*kt->func) (buf, cp, op, kt);\n       check_expand (op, ip->length - (ip->bufp - ip->buf));\n \n@@ -3991,7 +3990,7 @@ timestamp ()\n {\n   static struct tm *timebuf;\n   if (!timebuf) {\n-    time_t t = time ((time_t *)0);\n+    time_t t = time ((time_t *) 0);\n     timebuf = localtime (&t);\n   }\n   return timebuf;\n@@ -4138,7 +4137,7 @@ special_symbol (hp, op)\n       if (pcp_outfile && pcp_inside_if\n \t  && (hp->type == T_CONST\n \t      || (hp->type == T_MACRO && hp->value.defn->predefined)))\n-\t/* Output a precondition for this macro use. */\n+\t/* Output a precondition for this macro use.  */\n \tfprintf (pcp_outfile, \"#define %s\\n\", hp->name);\n       buf = \" 1 \";\n     }\n@@ -4263,9 +4262,9 @@ do_include (buf, limit, op, keyword)\n       }\n \n       /* We have \"filename\".  Figure out directory this source\n-\t file is coming from and put it on the front of the list. */\n+\t file is coming from and put it on the front of the list.  */\n \n-      /* If -I- was specified, don't search current dir, only spec'd ones. */\n+      /* If -I- was specified, don't search current dir, only spec'd ones.  */\n       if (ignore_srcdir) break;\n \n       for (fp = &instack[indepth]; fp >= instack; fp--)\n@@ -4317,7 +4316,7 @@ do_include (buf, limit, op, keyword)\n      * code from case '<' is repeated here) and generates a warning.\n      * (Note: macro expansion of `xyz' takes precedence.)\n      */\n-    if (retried && isalpha(*(U_CHAR *)(--fbeg))) {\n+    if (retried && isalpha(*(U_CHAR *) (--fbeg))) {\n       while (fin != limit && (!isspace(*fin)))\n \t*fend++ = *fin++;\n       warning (\"VAX-C-style include specification found, use '#include <filename.h>' !\");\n@@ -4622,6 +4621,7 @@ base_name (fname)\n }\n \n /* Yield nonzero if FILENAME is absolute (i.e. not relative).  */\n+\n static int\n absolute_filename (filename)\n      char *filename;\n@@ -5038,7 +5038,7 @@ finclude (f, inc, op, system_header_p, dirptr)\n   } else {\n     /* Cannot count its file size before reading.\n        First read the entire file into heap and\n-       copy them into buffer on stack. */\n+       copy them into buffer on stack.  */\n \n     int bsize = 2000;\n     int st_size = 0;\n@@ -5125,8 +5125,8 @@ record_control_macro (inc, macro_name)\n    the address of the buffer following the preconditions.  The buffer, in\n    this case, should never be freed because various pieces of it will\n    be referred to until all precompiled strings are output at the end of\n-   the run.\n-*/\n+   the run.  */\n+\n static char *\n check_precompiled (pcf, st, fname, limit)\n      int pcf;\n@@ -5157,7 +5157,7 @@ check_precompiled (pcf, st, fname, limit)\n   \n   *limit = buf + length;\n \n-  /* File is in core.  Check the preconditions. */\n+  /* File is in core.  Check the preconditions.  */\n   if (!check_preconditions (buf))\n     goto nope;\n   for (cp = buf; *cp; cp++)\n@@ -5179,6 +5179,7 @@ check_precompiled (pcf, st, fname, limit)\n    precompiled header.  These are a series of #define and #undef\n    lines which must match the current contents of the hash\n    table.  */\n+\n static int \n check_preconditions (prec)\n      char *prec;\n@@ -5237,7 +5238,8 @@ check_preconditions (prec)\n /* Process the main body of a precompiled file.  BUF points to the\n    string section of the file, following the preconditions.  LIMIT is one\n    character past the end.  NAME is the name of the file being read\n-   in.  OP is the main output buffer */\n+   in.  OP is the main output buffer.  */\n+\n static void\n pcfinclude (buf, limit, name, op)\n      U_CHAR *buf, *limit, *name;\n@@ -5254,7 +5256,7 @@ pcfinclude (buf, limit, name, op)\n   nstrings = (nstrings << 8) | *cp++;\n   nstrings = (nstrings << 8) | *cp++;\n   \n-  /* Looping over each string... */\n+  /* Looping over each string...  */\n   while (nstrings--) {\n     U_CHAR *string_start;\n     U_CHAR *endofthiskey;\n@@ -5273,7 +5275,7 @@ pcfinclude (buf, limit, name, op)\n     if ((HOST_WIDE_INT) cp & 3)\n       cp += 4 - ((HOST_WIDE_INT) cp & 3);\n     \n-    /* Now get the string. */\n+    /* Now get the string.  */\n     str = (STRINGDEF *) (GENERIC_PTR) cp;\n     string_start = cp += sizeof (STRINGDEF);\n     \n@@ -5283,7 +5285,7 @@ pcfinclude (buf, limit, name, op)\n     /* We need to macro expand the string here to ensure that the\n        proper definition environment is in place.  If it were only\n        expanded when we find out it is needed, macros necessary for\n-       its proper expansion might have had their definitions changed. */\n+       its proper expansion might have had their definitions changed.  */\n     tmpbuf = expand_to_temp_buffer (string_start, cp++, 0, 0);\n     /* Lineno is already set in the precompiled file */\n     str->contents = tmpbuf.buf;\n@@ -5296,14 +5298,14 @@ pcfinclude (buf, limit, name, op)\n     *stringlist_tailp = str;\n     stringlist_tailp = &str->chain;\n     \n-    /* Next comes a fourbyte number indicating the number of keys */\n-    /* for this string. */\n+    /* Next comes a fourbyte number indicating the number of keys\n+       for this string.  */\n     nkeys = *cp++;\n     nkeys = (nkeys << 8) | *cp++;\n     nkeys = (nkeys << 8) | *cp++;\n     nkeys = (nkeys << 8) | *cp++;\n \n-    /* If this number is -1, then the string is mandatory. */\n+    /* If this number is -1, then the string is mandatory.  */\n     if (nkeys == -1)\n       str->writeflag = 1;\n     else\n@@ -5316,11 +5318,11 @@ pcfinclude (buf, limit, name, op)\n \tcp += sizeof (KEYDEF);\n \t\n \t/* Find the end of the key.  At the end of this for loop we\n-\t   advance CP to the start of the next key using this variable. */\n+\t   advance CP to the start of the next key using this variable.  */\n \tendofthiskey = cp + strlen ((char *) cp);\n \tkp->str = str;\n \t\n-\t/* Expand the key, and enter it into the hash table. */\n+\t/* Expand the key, and enter it into the hash table.  */\n \ttmpbuf = expand_to_temp_buffer (cp, endofthiskey, 0, 0);\n \ttmpbuf.bufp = tmpbuf.buf;\n \t\n@@ -5347,12 +5349,13 @@ pcfinclude (buf, limit, name, op)\n   }\n   /* This output_line_directive serves to switch us back to the current\n      input file in case some of these strings get output (which will \n-     result in line directives for the header file being output). */\n+     result in line directives for the header file being output).   */\n   output_line_directive (&instack[indepth], op, 0, enter_file);\n }\n \n-/* Called from rescan when it hits a key for strings.  Mark them all */\n- /* used and clean up. */\n+/* Called from rescan when it hits a key for strings.  Mark them all\n+   used and clean up.  */\n+\n static void\n pcstring_used (hp)\n      HASHNODE *hp;\n@@ -5364,8 +5367,9 @@ pcstring_used (hp)\n   delete_macro (hp);\n }\n \n-/* Write the output, interspersing precompiled strings in their */\n- /* appropriate places. */\n+/* Write the output, interspersing precompiled strings in their\n+   appropriate places.  */\n+\n static void\n write_output ()\n {\n@@ -5375,10 +5379,10 @@ write_output ()\n   char *line_directive = xmalloc (line_directive_len);\n   int len;\n \n-  /* In each run through the loop, either cur_buf_loc == */\n-  /* next_string_loc, in which case we print a series of strings, or */\n-  /* it is less than next_string_loc, in which case we write some of */\n-  /* the buffer. */\n+  /* In each run through the loop, either cur_buf_loc ==\n+     next_string_loc, in which case we print a series of strings, or\n+     it is less than next_string_loc, in which case we write some of\n+     the buffer.  */\n   cur_buf_loc = outbuf.buf; \n   next_string = stringlist;\n   \n@@ -5451,7 +5455,7 @@ pass_thru_directive (buf, limit, op, keyword)\n    appeared.  So the arglist is just convenience data passed\n    between these two routines.  It is not kept around after\n    the current #define has been processed and entered into the\n-   hash table. */\n+   hash table.  */\n \n struct arglist {\n   struct arglist *next;\n@@ -5462,7 +5466,8 @@ struct arglist {\n };\n \n /* Create a DEFINITION node from a #define directive.  Arguments are \n-   as for do_define. */\n+   as for do_define.  */\n+\n static MACRODEF\n create_definition (buf, limit, op)\n      U_CHAR *buf, *limit;\n@@ -5491,7 +5496,7 @@ create_definition (buf, limit, op)\n \n   /* Lossage will occur if identifiers or control keywords are broken\n      across lines using backslash.  This is not the right place to take\n-     care of that. */\n+     care of that.  */\n \n   if (*bp == '(') {\n     struct arglist *arg_ptrs = NULL;\n@@ -5566,7 +5571,7 @@ create_definition (buf, limit, op)\n \n     ++bp;\t\t\t/* skip paren */\n     SKIP_WHITE_SPACE (bp);\n-    /* now everything from bp before limit is the definition. */\n+    /* now everything from bp before limit is the definition.  */\n     defn = collect_expansion (bp, limit, argno, arg_ptrs);\n     defn->rest_args = rest_args;\n \n@@ -5613,7 +5618,7 @@ create_definition (buf, limit, op)\n \t  }\n \t}\n       }\n-    /* Now everything from bp before limit is the definition. */\n+    /* Now everything from bp before limit is the definition.  */\n     defn = collect_expansion (bp, limit, -1, NULL_PTR);\n     defn->args.argnames = (U_CHAR *) \"\";\n   }\n@@ -5725,9 +5730,8 @@ check_macro_name (symname, usage)\n   return sym_length;\n }\n \n-/*\n- * return zero if two DEFINITIONs are isomorphic\n- */\n+/* Return zero if two DEFINITIONs are isomorphic.  */\n+     \n static int\n compare_defs (d1, d2)\n      DEFINITION *d1, *d2;\n@@ -5836,7 +5840,7 @@ collect_expansion (buf, end, nargs, arglist)\n   /* Scan thru the replacement list, ignoring comments and quoted\n      strings, picking up on the macro calls.  It does a linear search\n      thru the arg list on every potential symbol.  Profiling might say\n-     that something smarter should happen. */\n+     that something smarter should happen.  */\n \n   if (end < buf)\n     abort ();\n@@ -6133,7 +6137,7 @@ do_assert (buf, limit, op, keyword)\n \n   /* Lossage will occur if identifiers or control tokens are broken\n      across lines using backslash.  This is not the right place to take\n-     care of that. */\n+     care of that.  */\n \n   if (*bp != '(') {\n     error (\"missing token-sequence in `#assert'\");\n@@ -6212,7 +6216,7 @@ do_unassert (buf, limit, op, keyword)\n \n   /* Lossage will occur if identifiers or control tokens are broken\n      across lines using backslash.  This is not the right place to take\n-     care of that. */\n+     care of that.  */\n \n   if (*bp == '(') {\n     int error_flag = 0;\n@@ -6426,15 +6430,14 @@ free_token_list (tokens)\n   }\n }\n \f\n-/*\n- * Install a name in the assertion hash table.\n- *\n- * If LEN is >= 0, it is the length of the name.\n- * Otherwise, compute the length by scanning the entire name.\n- *\n- * If HASH is >= 0, it is the precomputed hash code.\n- * Otherwise, compute the hash code.\n- */\n+/* Install a name in the assertion hash table.\n+\n+   If LEN is >= 0, it is the length of the name.\n+   Otherwise, compute the length by scanning the entire name.\n+\n+   If HASH is >= 0, it is the precomputed hash code.\n+   Otherwise, compute the hash code.  */\n+\n static ASSERTION_HASHNODE *\n assertion_install (name, len, hash)\n      U_CHAR *name;\n@@ -6465,16 +6468,15 @@ assertion_install (name, len, hash)\n   return hp;\n }\n \n-/*\n- * find the most recent hash node for name name (ending with first\n- * non-identifier char) installed by install\n- *\n- * If LEN is >= 0, it is the length of the name.\n- * Otherwise, compute the length by scanning the entire name.\n- *\n- * If HASH is >= 0, it is the precomputed hash code.\n- * Otherwise, compute the hash code.\n- */\n+/* Find the most recent hash node for name name (ending with first\n+   non-identifier char) installed by install\n+\n+   If LEN is >= 0, it is the length of the name.\n+   Otherwise, compute the length by scanning the entire name.\n+\n+   If HASH is >= 0, it is the precomputed hash code.\n+   Otherwise, compute the hash code.  */\n+\n static ASSERTION_HASHNODE *\n assertion_lookup (name, len, hash)\n      U_CHAR *name;\n@@ -6502,8 +6504,8 @@ delete_assertion (hp)\n   if (hp->next != NULL)\n     hp->next->prev = hp->prev;\n \n-  /* make sure that the bucket chain header that\n-     the deleted guy was on points to the right thing afterwards. */\n+  /* Make sure that the bucket chain header that the deleted guy was\n+     on points to the right thing afterwards.  */\n   if (hp == *hp->bucket_hdr)\n     *hp->bucket_hdr = hp->next;\n \n@@ -6662,11 +6664,9 @@ do_line (buf, limit, op, keyword)\n   return 0;\n }\n \n-/*\n- * remove the definition of a symbol from the symbol table.\n- * according to un*x /lib/cpp, it is not an error to undef\n- * something that has no definitions, so it isn't one here either.\n- */\n+/* Remove the definition of a symbol from the symbol table.\n+   according to un*x /lib/cpp, it is not an error to undef\n+   something that has no definitions, so it isn't one here either.  */\n \n static int\n do_undef (buf, limit, op, keyword)\n@@ -6704,11 +6704,9 @@ do_undef (buf, limit, op, keyword)\n   return 0;\n }\n \f\n-/*\n- * Report an error detected by the program we are processing.\n- * Use the text of the line in the error message.\n- * (We use error because it prints the filename & line#.)\n- */\n+/* Report an error detected by the program we are processing.\n+   Use the text of the line in the error message.\n+   (We use error because it prints the filename & line#.)  */\n \n static int\n do_error (buf, limit, op, keyword)\n@@ -6725,11 +6723,9 @@ do_error (buf, limit, op, keyword)\n   return 0;\n }\n \n-/*\n- * Report a warning detected by the program we are processing.\n- * Use the text of the line in the warning message, then continue.\n- * (We use error because it prints the filename & line#.)\n- */\n+/* Report a warning detected by the program we are processing.\n+   Use the text of the line in the warning message, then continue.\n+   (We use error because it prints the filename & line#.)  */\n \n static int\n do_warning (buf, limit, op, keyword)\n@@ -6845,10 +6841,8 @@ do_pragma (buf, limit, op, keyword)\n /* This was a fun hack, but #pragma seems to start to be useful.\n    By failing to recognize it, we pass it through unchanged to cc1.  */\n \n-/*\n- * the behavior of the #pragma directive is implementation defined.\n- * this implementation defines it as follows.\n- */\n+/* The behavior of the #pragma directive is implementation defined.\n+   this implementation defines it as follows.  */\n \n static int\n do_pragma ()\n@@ -6885,18 +6879,16 @@ do_sccs (buf, limit, op, keyword)\n \n #endif /* defined (SCCS_DIRECTIVE) */\n \f\n-/*\n- * handle #if directive by\n- *   1) inserting special `defined' keyword into the hash table\n- *\tthat gets turned into 0 or 1 by special_symbol (thus,\n- *\tif the luser has a symbol called `defined' already, it won't\n- *      work inside the #if directive)\n- *   2) rescan the input into a temporary output buffer\n- *   3) pass the output buffer to the yacc parser and collect a value\n- *   4) clean up the mess left from steps 1 and 2.\n- *   5) call conditional_skip to skip til the next #endif (etc.),\n- *      or not, depending on the value from step 3.\n- */\n+/* Handle #if directive by\n+     1) inserting special `defined' keyword into the hash table\n+  \tthat gets turned into 0 or 1 by special_symbol (thus,\n+  \tif the luser has a symbol called `defined' already, it won't\n+        work inside the #if directive)\n+     2) rescan the input into a temporary output buffer\n+     3) pass the output buffer to the yacc parser and collect a value\n+     4) clean up the mess left from steps 1 and 2.\n+     5) call conditional_skip to skip til the next #endif (etc.),\n+        or not, depending on the value from step 3.  */\n \n static int\n do_if (buf, limit, op, keyword)\n@@ -6912,10 +6904,8 @@ do_if (buf, limit, op, keyword)\n   return 0;\n }\n \n-/*\n- * handle a #elif directive by not changing  if_stack  either.\n- * see the comment above do_else.\n- */\n+/* Handle a #elif directive by not changing  if_stack  either.\n+   see the comment above do_else.  */\n \n static int\n do_elif (buf, limit, op, keyword)\n@@ -6955,10 +6945,9 @@ do_elif (buf, limit, op, keyword)\n   return 0;\n }\n \n-/*\n- * evaluate a #if expression in BUF, of length LENGTH,\n- * then parse the result as a C expression and return the value as an int.\n- */\n+/* Evaluate a #if expression in BUF, of length LENGTH, then parse the\n+   result as a C expression and return the value as an int.  */\n+\n static HOST_WIDE_INT\n eval_if_expression (buf, length)\n      U_CHAR *buf;\n@@ -6983,11 +6972,9 @@ eval_if_expression (buf, length)\n   return value;\n }\n \n-/*\n- * routine to handle ifdef/ifndef.  Try to look up the symbol,\n- * then do or don't skip to the #endif/#else/#elif depending\n- * on what directive is actually being processed.\n- */\n+/* routine to handle ifdef/ifndef.  Try to look up the symbol, then do\n+   or don't skip to the #endif/#else/#elif depending on what directive\n+   is actually being processed.  */\n \n static int\n do_xifdef (buf, limit, op, keyword)\n@@ -7113,11 +7100,10 @@ conditional_skip (ip, skip, type, control_macro, op)\n   }\n }\n \n-/*\n- * skip to #endif, #else, or #elif.  adjust line numbers, etc.\n- * leaves input ptr at the sharp sign found.\n- * If ANY is nonzero, return at next directive of any sort.\n- */\n+/* Skip to #endif, #else, or #elif.  adjust line numbers, etc.\n+   Leaves input ptr at the sharp sign found.\n+   If ANY is nonzero, return at next directive of any sort.  */\n+     \n static void\n skip_if_group (ip, any, op)\n      FILE_BUF *ip;\n@@ -7405,12 +7391,10 @@ skip_if_group (ip, any, op)\n   }\n }\n \n-/*\n- * handle a #else directive.  Do this by just continuing processing\n- * without changing  if_stack ;  this is so that the error message\n- * for missing #endif's etc. will point to the original #if.  It\n- * is possible that something different would be better.\n- */\n+/* Handle a #else directive.  Do this by just continuing processing\n+   without changing  if_stack ;  this is so that the error message\n+   for missing #endif's etc. will point to the original #if.  It\n+   is possible that something different would be better.  */\n \n static int\n do_else (buf, limit, op, keyword)\n@@ -7453,9 +7437,7 @@ do_else (buf, limit, op, keyword)\n   return 0;\n }\n \n-/*\n- * unstack after #endif directive\n- */\n+/* Unstack after #endif directive.  */\n \n static int\n do_endif (buf, limit, op, keyword)\n@@ -7517,7 +7499,8 @@ do_endif (buf, limit, op, keyword)\n \n /* When an #else or #endif is found while skipping failed conditional,\n    if -pedantic was specified, this is called to warn about text after\n-   the directive name.  P points to the first char after the directive name.  */\n+   the directive name.  P points to the first char after the directive\n+   name.  */\n \n static void\n validate_else (p, limit)\n@@ -7565,9 +7548,10 @@ validate_else (p, limit)\n    counter is not sufficient to deal with newlines in the string.\n \n    If NOWARN is nonzero, don't warn about slash-star inside a comment.\n-   This feature is useful when processing a comment that is going to be\n-   processed or was processed at another point in the preprocessor,\n-   to avoid a duplicate warning.  Likewise for unterminated comment errors.  */\n+   This feature is useful when processing a comment that is going to\n+   be processed or was processed at another point in the preprocessor,\n+   to avoid a duplicate warning.  Likewise for unterminated comment\n+   errors.  */\n \n static U_CHAR *\n skip_to_end_of_comment (ip, line_counter, nowarn)\n@@ -7645,22 +7629,21 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n   return bp;\n }\n \n-/*\n- * Skip over a quoted string.  BP points to the opening quote.\n- * Returns a pointer after the closing quote.  Don't go past LIMIT.\n- * START_LINE is the line number of the starting point (but it need\n- * not be valid if the starting point is inside a macro expansion).\n- *\n- * The input stack state is not changed.\n- *\n- * If COUNT_NEWLINES is nonzero, it points to an int to increment\n- * for each newline passed.\n- *\n- * If BACKSLASH_NEWLINES_P is nonzero, store 1 thru it\n- * if we pass a backslash-newline.\n- *\n- * If EOFP is nonzero, set *EOFP to 1 if the string is unterminated.\n- */\n+/* Skip over a quoted string.  BP points to the opening quote.\n+   Returns a pointer after the closing quote.  Don't go past LIMIT.\n+   START_LINE is the line number of the starting point (but it need\n+   not be valid if the starting point is inside a macro expansion).\n+\n+   The input stack state is not changed.\n+\n+   If COUNT_NEWLINES is nonzero, it points to an int to increment\n+   for each newline passed.\n+\n+   If BACKSLASH_NEWLINES_P is nonzero, store 1 thru it\n+   if we pass a backslash-newline.\n+\n+   If EOFP is nonzero, set *EOFP to 1 if the string is unterminated.  */\n+\n static U_CHAR *\n skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p, eofp)\n      register U_CHAR *bp;\n@@ -7702,7 +7685,7 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n     } else if (c == '\\n') {\n       if (traditional) {\n  \t/* Unterminated strings and character constants are 'valid'.  */\n- \tbp--;\t/* Don't consume the newline. */\n+ \tbp--;\t/* Don't consume the newline.  */\n  \tif (eofp)\n  \t  *eofp = 1;\n  \tbreak;\n@@ -7732,6 +7715,7 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n \n /* Place into DST a quoted string representing the string SRC.\n    Return the address of DST's terminating null.  */\n+\n static char *\n quote_string (dst, src)\n      char *dst, *src;\n@@ -7816,13 +7800,11 @@ skip_paren_group (ip)\n   return p;\n }\n \f\n-/*\n- * write out a #line directive, for instance, after an #include file.\n- * If CONDITIONAL is nonzero, we can omit the #line if it would\n- * appear to be a no-op, and we can output a few newlines instead\n- * if we want to increase the line number by a small amount.\n- * FILE_CHANGE says whether we are entering a file, leaving, or neither.\n- */\n+/* Write out a #line directive, for instance, after an #include file.\n+   If CONDITIONAL is nonzero, we can omit the #line if it would\n+   appear to be a no-op, and we can output a few newlines instead\n+   if we want to increase the line number by a small amount.\n+   FILE_CHANGE says whether we are entering a file, leaving, or neither.  */\n \n static void\n output_line_directive (ip, op, conditional, file_change)\n@@ -7978,7 +7960,7 @@ macroexpand (hp, op)\n       if (rest_args)\n \tcontinue;\n       if (i < nargs || (nargs == 0 && i == 0)) {\n-\t/* if we are working on last arg which absorbs rest of args... */\n+\t/* If we are working on last arg which absorbs rest of args...  */\n \tif (i == nargs - 1 && defn->rest_args)\n \t  rest_args = 1;\n \tparse_error = macarg (&args[i], rest_args);\n@@ -8256,8 +8238,8 @@ macroexpand (hp, op)\n \t  abort ();\n       }\n \n-      /* if there is anything left of the definition\n-\t after handling the arg list, copy that in too. */\n+      /* If there is anything left of the definition after handling\n+\t the arg list, copy that in too.  */\n \n       for (i = offset; i < defn->length; i++) {\n \t/* if we've reached the end of the macro */\n@@ -8313,11 +8295,9 @@ macroexpand (hp, op)\n   }\n }\n \f\n-/*\n- * Parse a macro argument and store the info on it into *ARGPTR.\n- * REST_ARGS is passed to macarg1 to make it absorb the rest of the args.\n- * Return nonzero to indicate a syntax error.\n- */\n+/* Parse a macro argument and store the info on it into *ARGPTR.\n+   REST_ARGS is passed to macarg1 to make it absorb the rest of the args.\n+   Return nonzero to indicate a syntax error.  */\n \n static char *\n macarg (argptr, rest_args)\n@@ -8715,9 +8695,8 @@ change_newlines (start, length)\n   return obp - start;\n }\n \f\n-/*\n- * my_strerror - return the descriptive text associated with an `errno' code.\n- */\n+/* my_strerror - return the descriptive text associated with an\n+   `errno' code.  */\n \n char *\n my_strerror (errnum)\n@@ -8748,9 +8727,7 @@ my_strerror (errnum)\n   return result;\n }\n \n-/*\n- * error - print error message and increment count of errors.\n- */\n+/* error - print error message and increment count of errors.  */\n \n void\n error (PRINTF_ALIST (msg))\n@@ -8939,7 +8916,7 @@ vwarning_with_line (line, msg, args)\n   fprintf (stderr, \"\\n\");\n }\n \n-/* print an error message and maybe count it.  */\n+/* Print an error message and maybe count it.  */\n \n void\n pedwarn (PRINTF_ALIST (msg))\n@@ -9087,6 +9064,7 @@ line_for_error (line)\n \n /* You might think void was cleaner for the return type,\n    but that would get type mismatch in check_expand in strict ANSI.  */\n+\n static int\n grow_outbuf (obuf, needed)\n      register FILE_BUF *obuf;\n@@ -9128,8 +9106,9 @@ grow_outbuf (obuf, needed)\n  * Otherwise, compute the length by scanning the entire name.\n  *\n  * If HASH is >= 0, it is the precomputed hash code.\n- * Otherwise, compute the hash code.\n+ * Otherwise, compute the hash code. \n  */\n+\n static HASHNODE *\n install (name, len, type, value, hash)\n      U_CHAR *name;\n@@ -9183,6 +9162,7 @@ install (name, len, type, value, hash)\n  * If HASH is >= 0, it is the precomputed hash code.\n  * Otherwise, compute the hash code.\n  */\n+\n HASHNODE *\n lookup (name, len, hash)\n      U_CHAR *name;\n@@ -9233,8 +9213,8 @@ delete_macro (hp)\n   if (hp->next != NULL)\n     hp->next->prev = hp->prev;\n \n-  /* make sure that the bucket chain header that\n-     the deleted guy was on points to the right thing afterwards. */\n+  /* Make sure that the bucket chain header that the deleted guy was\n+     on points to the right thing afterwards.  */\n   if (hp == *hp->bucket_hdr)\n     *hp->bucket_hdr = hp->next;\n \n@@ -9257,6 +9237,7 @@ delete_macro (hp)\n  * return hash function on name.  must be compatible with the one\n  * computed a step at a time, elsewhere\n  */\n+\n static int\n hashf (name, len, hashsize)\n      register U_CHAR *name;\n@@ -9273,6 +9254,7 @@ hashf (name, len, hashsize)\n \f\n \n /* Dump the definition of a single macro HP to OF.  */\n+\n static void\n dump_single_macro (hp, of)\n      register HASHNODE *hp;\n@@ -9753,8 +9735,8 @@ make_assertion (option, str)\n   for (kt = directive_table; kt->type != T_ASSERT; kt++)\n     ;\n \n-  /* pass NULL as output ptr to do_define since we KNOW it never\n-     does any output.... */\n+  /* Pass NULL as output ptr to do_define since we KNOW it never does\n+     any output....  */\n   do_assert (buf, buf + strlen ((char *) buf) , NULL_PTR, kt);\n   --indepth;\n }\n@@ -10020,9 +10002,9 @@ savestring (input)\n \f\n #ifdef VMS\n \n-/* Under VMS we need to fix up the \"include\" specification\n-   filename so that everything following the 1st slash is\n-   changed into its correct VMS file specification. */\n+/* Under VMS we need to fix up the \"include\" specification filename so\n+   that everything following the 1st slash is changed into its correct\n+   VMS file specification.  */\n \n static void\n hack_vms_include_specification (fname)\n@@ -10054,7 +10036,7 @@ hack_vms_include_specification (fname)\n      needed to get things working properly.\n      \n      If no device is specified, then the first directory name is taken to be\n-     a device name (or a rooted logical). */\n+     a device name (or a rooted logical).  */\n \n   /* See if we found that 1st slash */\n   if (cp == 0) return;\t\t/* Nothing to do!!! */\n@@ -10104,14 +10086,14 @@ hack_vms_include_specification (fname)\n \n   /* If there are no other slashes then the filename will be\n      in the \"root\" directory.  Otherwise, we need to add\n-     directory specifications. */\n+     directory specifications.  */\n   if (index (cp1, '/') == 0) {\n     /* Just add \"000000]\" as the directory string */\n     strcpy (cp2, \"000000]\");\n     cp2 += strlen (cp2);\n     check_filename_before_returning = 1; /* we might need to fool with this later */\n   } else {\n-    /* As long as there are still subdirectories to add, do them. */\n+    /* As long as there are still subdirectories to add, do them.  */\n     while (index (cp1, '/') != 0) {\n       /* If this token is \".\" we can ignore it */\n       if ((cp1[0] == '.') && (cp1[1] == '/')) {\n@@ -10140,7 +10122,7 @@ hack_vms_include_specification (fname)\n   /* Now add the filename */\n   while (*cp1) *cp2++ = *cp1++;\n   *cp2 = 0;\n-  /* Now append it to the original VMS spec. */\n+  /* Now append it to the original VMS spec.  */\n   strcpy (cp, Local);\n \n   /* If we put a [000000] in the filename, try to open it first. If this fails,\n@@ -10226,8 +10208,7 @@ write (fd, buf, size)\n      \"mbc=16\" - Set multi-block count to 16 (use a 8192 byte buffer).\n      \"deq=64\" - When extending the file, extend it in chunks of 32Kbytes.\n      \"fop=tef\"- Truncate unused portions of file when closing file.\n-     \"shr=nil\"- Disallow file sharing while file is open.\n- */\n+     \"shr=nil\"- Disallow file sharing while file is open.  */\n \n static FILE *\n freopen (fname, type, oldfile)"}, {"sha": "5fed1071b3ac7b33e28463873cc442e4eab7edb3", "filename": "gcc/cexp.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -83,7 +83,7 @@ struct arglist {\n #endif\n \n #ifndef NULL_PTR\n-#define NULL_PTR ((GENERIC_PTR)0)\n+#define NULL_PTR ((GENERIC_PTR) 0)\n #endif\n \n /* Find the largest host integer type and set its size and type."}, {"sha": "849482d8eec2a888a251d8aa830320588a36f681", "filename": "gcc/collect2.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -25,7 +25,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* Build tables of static constructors and destructors and run ld. */\n+/* Build tables of static constructors and destructors and run ld.  */\n \n #include \"config.h\"\n #include <sys/types.h>\n@@ -189,7 +189,7 @@ int do_collecting = 1;\n int do_collecting = 0;\n #endif\n \f\n-/* Linked lists of constructor and destructor names. */\n+/* Linked lists of constructor and destructor names.  */\n \n struct id \n {\n@@ -231,9 +231,9 @@ static int shared_obj;\t\t        /* true if -shared */\n \n static int   temp_filename_length;\t/* Length of temp_filename */\n static char *temp_filename;\t\t/* Base of temp filenames */\n-static char *c_file;\t\t\t/* <xxx>.c for constructor/destructor list. */\n-static char *o_file;\t\t\t/* <xxx>.o for constructor/destructor list. */\n-static char *export_file;\t        /* <xxx>.x for AIX export list. */\n+static char *c_file;\t\t\t/* <xxx>.c for constructor/destructor list.  */\n+static char *o_file;\t\t\t/* <xxx>.o for constructor/destructor list.  */\n+static char *export_file;\t        /* <xxx>.x for AIX export list.  */\n char *ldout;\t\t\t\t/* File for ld errors.  */\n static char *output_file;\t\t/* Output file for ld.  */\n static char *nm_file_name;\t\t/* pathname of nm */\n@@ -262,8 +262,8 @@ extern FILE *fdopen ();\n \n struct prefix_list\n {\n-  char *prefix;               /* String to prepend to the path. */\n-  struct prefix_list *next;   /* Next in linked list. */\n+  char *prefix;               /* String to prepend to the path.  */\n+  struct prefix_list *next;   /* Next in linked list.  */\n };\n \n struct path_prefix\n@@ -373,7 +373,7 @@ collect_exit (status)\n }\n \n \f\n-/* Die when sys call fails. */\n+/* Die when sys call fails.  */\n \n void\n fatal_perror (string, arg1, arg2, arg3)\n@@ -387,7 +387,7 @@ fatal_perror (string, arg1, arg2, arg3)\n   collect_exit (1);\n }\n \n-/* Just die. */\n+/* Just die.  */\n \n void\n fatal (string, arg1, arg2, arg3)\n@@ -450,7 +450,7 @@ xcalloc (size1, size2)\n     return ptr;\n \n   fatal (\"out of memory\");\n-  return (char *)0;\n+  return (char *) 0;\n }\n \n char *\n@@ -462,7 +462,7 @@ xmalloc (size)\n     return ptr;\n \n   fatal (\"out of memory\");\n-  return (char *)0;\n+  return (char *) 0;\n }\n \n char *\n@@ -720,7 +720,7 @@ is_in_prefix_list (pprefix, string, filep)\n /* Search for NAME using prefix list PPREFIX.  We only look for executable\n    files. \n \n-   Return 0 if not found, otherwise return its name, allocated with malloc. */\n+   Return 0 if not found, otherwise return its name, allocated with malloc.  */\n \n static char *\n find_a_file (pprefix, name)\n@@ -857,7 +857,7 @@ prefix_from_string (p, pprefix)\n     }\n }\n \f\n-/* Main program. */\n+/* Main program.  */\n \n int\n main (argc, argv)\n@@ -1147,7 +1147,7 @@ main (argc, argv)\n \n   *ld1++ = *ld2++ = ld_file_name;\n \n-  /* Make temp file names. */\n+  /* Make temp file names.  */\n   temp_filename = choose_temp_base ();\n   temp_filename_length = strlen (temp_filename);\n   c_file = xcalloc (temp_filename_length + sizeof (\".c\"), 1);\n@@ -1170,11 +1170,11 @@ main (argc, argv)\n      If you propose to make GCC pass some other option,\n      just imagine what will happen if ld is really ld!!!  */\n \n-  /* Parse arguments.  Remember output file spec, pass the rest to ld. */\n+  /* Parse arguments.  Remember output file spec, pass the rest to ld.  */\n   /* After the first file, put in the c++ rt0.  */\n \n   first_file = 1;\n-  while ((arg = *++argv) != (char *)0)\n+  while ((arg = *++argv) != (char *) 0)\n     {\n       *ld1++ = *ld2++ = arg;\n \n@@ -1232,7 +1232,7 @@ main (argc, argv)\n \t      break;\n \t    }\n \t}\n-      else if ((p = rindex (arg, '.')) != (char *)0\n+      else if ((p = rindex (arg, '.')) != (char *) 0\n \t       && (strcmp (p, \".o\") == 0 || strcmp (p, \".a\") == 0))\n \t{\n \t  if (first_file)\n@@ -1281,7 +1281,7 @@ main (argc, argv)\n     *ld1++ = buf;\n     *ld2++ = buf;\n     exportf = fopen (export_file, \"w\");\n-    if (exportf == (FILE *)0)\n+    if (exportf == (FILE *) 0)\n       fatal_perror (\"%s\", export_file);\n     write_export_file (exportf);\n     if (fclose (exportf))\n@@ -1290,7 +1290,7 @@ main (argc, argv)\n #endif\n \n   *c_ptr++ = c_file;\n-  *object = *c_ptr = *ld1 = (char *)0;\n+  *object = *c_ptr = *ld1 = (char *) 0;\n \n   if (vflag)\n     {\n@@ -1399,7 +1399,7 @@ main (argc, argv)\n \n   maybe_unlink(output_file);\n   outf = fopen (c_file, \"w\");\n-  if (outf == (FILE *)0)\n+  if (outf == (FILE *) 0)\n     fatal_perror (\"%s\", c_file);\n \n   write_c_file (outf, c_file);\n@@ -1414,7 +1414,7 @@ main (argc, argv)\n   *ld2++ = LD_FINI_SWITCH;\n   *ld2++ = fininame;\n #endif\n-  *ld2 = (char*)0;\n+  *ld2 = (char*) 0;\n \n #ifdef COLLECT_EXPORT_LIST\n   if (shared_obj)\n@@ -1424,7 +1424,7 @@ main (argc, argv)\n       add_to_list (&exports, \"_GLOBAL__DI\");\n       add_to_list (&exports, \"_GLOBAL__DD\");\n       exportf = fopen (export_file, \"w\");\n-      if (exportf == (FILE *)0)\n+      if (exportf == (FILE *) 0)\n \tfatal_perror (\"%s\", export_file);\n       write_export_file (exportf);\n       if (fclose (exportf))\n@@ -1446,7 +1446,7 @@ main (argc, argv)\n     }\n \n   /* Assemble the constructor and destructor tables.\n-     Link the tables in with the rest of the program. */\n+     Link the tables in with the rest of the program.  */\n \n   fork_execute (\"gcc\",  c_argv);\n   fork_execute (\"ld\", ld2_argv);\n@@ -1462,7 +1462,7 @@ main (argc, argv)\n }\n \n \f\n-/* Wait for a process to finish, and exit if a non-zero status is found. */\n+/* Wait for a process to finish, and exit if a non-zero status is found.  */\n \n int\n collect_wait (prog)\n@@ -1531,7 +1531,7 @@ collect_execute (prog, argv, redir)\n       else\n \tfprintf (stderr, \"[cannot find %s]\", prog);\n \n-      for (p_argv = &argv[1]; (str = *p_argv) != (char *)0; p_argv++)\n+      for (p_argv = &argv[1]; (str = *p_argv) != (char *) 0; p_argv++)\n \tfprintf (stderr, \" %s\", str);\n \n       fprintf (stderr, \"\\n\");\n@@ -1756,7 +1756,7 @@ write_c_file_stat (stream, name)\n     }\n }\n \n-/* Write the constructor/destructor tables. */\n+/* Write the constructor/destructor tables.  */\n \n static void\n write_c_file_glob (stream, name)\n@@ -1844,13 +1844,13 @@ scan_prog_file (prog_name, which_pass)\n     nm_argv[argc++] = NM_FLAGS;\n \n   nm_argv[argc++] = prog_name;\n-  nm_argv[argc++] = (char *)0;\n+  nm_argv[argc++] = (char *) 0;\n \n   if (pipe (pipe_fd) < 0)\n     fatal_perror (\"pipe\");\n \n   inf = fdopen (pipe_fd[0], \"r\");\n-  if (inf == (FILE *)0)\n+  if (inf == (FILE *) 0)\n     fatal_perror (\"fdopen\");\n \n   /* Trace if needed.  */\n@@ -1859,7 +1859,7 @@ scan_prog_file (prog_name, which_pass)\n       char **p_argv;\n       char *str;\n \n-      for (p_argv = &nm_argv[0]; (str = *p_argv) != (char *)0; p_argv++)\n+      for (p_argv = &nm_argv[0]; (str = *p_argv) != (char *) 0; p_argv++)\n \tfprintf (stderr, \" %s\", str);\n \n       fprintf (stderr, \"\\n\");\n@@ -1908,13 +1908,13 @@ scan_prog_file (prog_name, which_pass)\n     fprintf (stderr, \"\\nnm output with constructors/destructors.\\n\");\n \n   /* Read each line of nm output.  */\n-  while (fgets (buf, sizeof buf, inf) != (char *)0)\n+  while (fgets (buf, sizeof buf, inf) != (char *) 0)\n     {\n       int ch, ch2;\n       char *name, *end;\n \n       /* If it contains a constructor or destructor name, add the name\n-\t to the appropriate list. */\n+\t to the appropriate list.  */\n \n       for (p = buf; (ch = *p) != '\\0' && ch != '\\n' && ch != '_'; p++)\n \tif (ch == ' ' && p[1] == 'U' && p[2] == ' ')\n@@ -2351,7 +2351,7 @@ scan_libraries (prog_name)\n       int ch, ch2;\n       char *name, *end, *p = buf;\n \n-      /* Extract names of libraries and add to list. */\n+      /* Extract names of libraries and add to list.  */\n       PARSE_LDD_OUTPUT (p);\n       if (p == 0)\n \tcontinue;\n@@ -2360,7 +2360,7 @@ scan_libraries (prog_name)\n       if (strncmp (name, \"not found\", sizeof (\"not found\") - 1) == 0)\n \tfatal (\"dynamic dependency %s not found\", buf);\n \n-      /* Find the end of the symbol name. */\n+      /* Find the end of the symbol name.  */\n       for (end = p; \n \t   (ch2 = *end) != '\\0' && ch2 != '\\n' && !isspace (ch2) && ch2 != '|';\n \t   end++)\n@@ -2474,7 +2474,7 @@ scan_prog_file (prog_name, which_pass)\n \n #ifdef XCOFF_DEBUGGING_INFO\n \t      /* All AIX function names have a duplicate entry beginning\n-\t\t with a dot. */\n+\t\t with a dot.  */\n \t      if (*name == '.')\n \t\t++name;\n #endif\n@@ -2640,7 +2640,7 @@ scan_libraries (prog_name)\n \t\t    fatal (\"%s: can't read loader section\", soname);\n \t\t  /*fprintf (stderr, \"\\tscanning %s\\n\", soname);*/\n \t\t  symcnt = soldh.l_nsyms;\n-\t\t  lsyms = (LDSYM*) alloca (symcnt * sizeof (*lsyms));\n+\t\t  lsyms = (LDSYM *) alloca (symcnt * sizeof (*lsyms));\n \t\t  symcnt = FREAD (lsyms, sizeof (*lsyms), symcnt, libptr);\n \t\t  ldstrings = alloca (soldh.l_stlen);\n \t\t  FSEEK (libptr, soldsh.s_scnptr+soldh.l_stoff, BEGINNING);\n@@ -2737,7 +2737,7 @@ extern int encode_mach_o_hdr ();\n static void add_func_table\tPROTO((mo_header_t *, load_all_t *,\n \t\t\t\t       symbol_info_t *, int));\n static void print_header\tPROTO((mo_header_t *));\n-static void print_load_command\tPROTO((load_union_t*, size_t, int));\n+static void print_load_command\tPROTO((load_union_t *, size_t, int));\n static void bad_header\t\tPROTO((int));\n static struct file_info\t*read_file  PROTO((char *, int, int));\n static void end_file\t\tPROTO((struct file_info *));\n@@ -2880,10 +2880,10 @@ scan_prog_file (prog_name, which_pass)\n \t    continue;\n \n \t  str_sect = load_array[load_hdr->sym.symc_strings_section].section;\n-\t  if (str_sect == (char *)0)\n+\t  if (str_sect == (char *) 0)\n \t    fatal (\"string section missing\");\n \n-\t  if (load_cmd->section == (char *)0)\n+\t  if (load_cmd->section == (char *) 0)\n \t    fatal (\"section pointer missing\");\n \n \t  num_syms = load_hdr->sym.symc_nentries;\n@@ -2952,7 +2952,7 @@ scan_prog_file (prog_name, which_pass)\n \t do anything, since in the current version, you cannot do mallocs\n \t and such in the constructors.  */\n \n-      if (main_sym != (symbol_info_t *)0\n+      if (main_sym != (symbol_info_t *) 0\n \t  && ((hdr.moh_flags & MOH_EXECABLE_F) == 0))\n \tadd_func_table (&hdr, load_array, main_sym, FNTC_INITIALIZATION);\n \n@@ -3007,7 +3007,7 @@ scan_prog_file (prog_name, which_pass)\n \t  if (debug)\n \t    print_load_command (load_hdr, offset, i);\n \n-\t  bcopy ((char *)load_hdr, (char *)(obj + offset), size);\n+\t  bcopy ((char *) load_hdr, (char *) (obj + offset), size);\n \t  offset += size;\n \t}\n     }\n@@ -3046,7 +3046,7 @@ add_func_table (hdr_p, load_array, sym, type)\n \n   load_cmd = &load_array[load_index];\n   load_cmd->load = ptr;\n-  load_cmd->section = (char *)0;\n+  load_cmd->section = (char *) 0;\n \n   /* Fill in func table load command.  */\n   ptr->func.ldc_header.ldci_cmd_type = LDC_FUNC_TABLE;\n@@ -3155,7 +3155,7 @@ print_load_command (load_hdr, offset, number)\n      int number;\n {\n   mo_long_t type = load_hdr->hdr.ldci_cmd_type;\n-  char *type_str = (char *)0;\n+  char *type_str = (char *) 0;\n \n   switch (type)\n     {\n@@ -3180,7 +3180,7 @@ print_load_command (load_hdr, offset, number)\n \t   (long) load_hdr->hdr.ldci_section_off,\n \t   (long) load_hdr->hdr.ldci_section_len);\n \n-  if (type_str == (char *)0)\n+  if (type_str == (char *) 0)\n     fprintf (stderr, \", ty: unknown (%ld)\\n\", (long) type);\n \n   else if (type != LDC_REGION)\n@@ -3219,7 +3219,7 @@ static void\n bad_header (status)\n      int status;\n {\n-  char *msg = (char *)0;\n+  char *msg = (char *) 0;\n \n   switch (status)\n     {\n@@ -3231,7 +3231,7 @@ bad_header (status)\n     case MO_ERROR_UNSUPPORTED_VERS:\tmsg = \"unsupported version\";\t\tbreak;\n     }\n \n-  if (msg == (char *)0)\n+  if (msg == (char *) 0)\n     fatal (\"unknown {de,en}code_mach_o_hdr return value %d\", status);\n   else\n     fatal (\"%s\", msg);\n@@ -3269,14 +3269,14 @@ read_file (name, fd, rw)\n     page_size = sysconf (_SC_PAGE_SIZE);\n \n   p->rounded_size = ((p->size + page_size - 1) / page_size) * page_size;\n-  p->start = mmap ((caddr_t)0,\n+  p->start = mmap ((caddr_t) 0,\n \t\t   (rw) ? p->rounded_size : p->size,\n \t\t   (rw) ? (PROT_READ | PROT_WRITE) : PROT_READ,\n \t\t   MAP_FILE | MAP_VARIABLE | MAP_SHARED,\n \t\t   fd,\n \t\t   0L);\n \n-  if (p->start != (char *)0 && p->start != (char *)-1)\n+  if (p->start != (char *) 0 && p->start != (char *) -1)\n     p->use_mmap = 1;\n \n   else"}, {"sha": "b83f020a98ba5b1feb8e6791b8bcdb40f2205a09", "filename": "gcc/combine.c", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -245,7 +245,7 @@ static int this_basic_block;\n    reg_last_set_invalid[i] is set non-zero when register I is being assigned\n    to and reg_last_set_table_tick[i] == label_tick.  */\n \n-/* Record last value assigned to (hard or pseudo) register n. */\n+/* Record last value assigned to (hard or pseudo) register n.  */\n \n static rtx *reg_last_set_value;\n \n@@ -255,7 +255,7 @@ static rtx *reg_last_set_value;\n static int *reg_last_set_label;\n \n /* Record the value of label_tick when an expression involving register n\n-   is placed in reg_last_set_value. */\n+   is placed in reg_last_set_value.  */\n \n static int *reg_last_set_table_tick;\n \n@@ -264,7 +264,7 @@ static int *reg_last_set_table_tick;\n \n static char *reg_last_set_invalid;\n \n-/* Incremented for each label. */\n+/* Incremented for each label.  */\n \n static int label_tick;\n \n@@ -1614,7 +1614,7 @@ try_combine (i3, i2, i1)\n     {\n       /* Before we can do this substitution, we must redo the test done\n \t above (see detailed comments there) that ensures  that I1DEST\n-\t isn't mentioned in any SETs in NEWPAT that are field assignments. */\n+\t isn't mentioned in any SETs in NEWPAT that are field assignments.  */\n \n       if (! combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX,\n \t\t\t      0, NULL_PTR))\n@@ -2777,14 +2777,14 @@ find_split_point (loc, insn)\n       split = find_split_point (&XEXP (x, 2), insn);\n       if (split)\n \treturn split;\n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n     case '2':\n     case 'c':\n     case '<':\n       split = find_split_point (&XEXP (x, 1), insn);\n       if (split)\n \treturn split;\n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n     case '1':\n       /* Some machines have (and (shift ...) ...) insns.  If X is not\n \t an AND, but XEXP (X, 0) is, use it as our split point.  */\n@@ -2885,7 +2885,8 @@ subst (x, from, to, in_dest, unique_copy)\n         || GET_CODE (SET_DEST (x)) == PC))\n     fmt = \"ie\";\n \n-  /* Get the mode of operand 0 in case X is now a SIGN_EXTEND of a constant. */\n+  /* Get the mode of operand 0 in case X is now a SIGN_EXTEND of a\n+     constant.  */\n   if (fmt[0] == 'e')\n     op0_mode = GET_MODE (XEXP (x, 0));\n \n@@ -3462,13 +3463,13 @@ simplify_rtx (x, op0_mode, last, in_dest)\n       /* (neg (minus X Y)) can become (minus Y X).  */\n       if (GET_CODE (XEXP (x, 0)) == MINUS\n \t  && (! FLOAT_MODE_P (mode)\n-\t      /* x-y != -(y-x) with IEEE floating point. */\n+\t      /* x-y != -(y-x) with IEEE floating point.  */\n \t      || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t      || flag_fast_math))\n \treturn gen_binary (MINUS, mode, XEXP (XEXP (x, 0), 1),\n \t\t\t   XEXP (XEXP (x, 0), 0));\n \n-      /* (neg (xor A 1)) is (plus A -1) if A is known to be either 0 or 1. */\n+      /* (neg (xor A 1)) is (plus A -1) if A is known to be either 0 or 1.  */\n       if (GET_CODE (XEXP (x, 0)) == XOR && XEXP (XEXP (x, 0), 1) == const1_rtx\n \t  && nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n \treturn gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n@@ -3883,7 +3884,7 @@ simplify_rtx (x, op0_mode, last, in_dest)\n     case SIGN_EXTRACT:\n     case ZERO_EXTEND:\n     case SIGN_EXTEND:\n-      /* If we are processing SET_DEST, we are done. */\n+      /* If we are processing SET_DEST, we are done.  */\n       if (in_dest)\n \treturn x;\n \n@@ -3973,11 +3974,11 @@ simplify_if_then_else (x)\n   rtx temp;\n   int i;\n \n-  /* Simplify storing of the truth value. */\n+  /* Simplify storing of the truth value.  */\n   if (comparison_p && true == const_true_rtx && false == const0_rtx)\n     return gen_binary (true_code, mode, XEXP (cond, 0), XEXP (cond, 1));\n       \n-  /* Also when the truth value has to be reversed. */\n+  /* Also when the truth value has to be reversed.  */\n   if (comparison_p && reversible_comparison_p (cond)\n       && true == const0_rtx && false == const_true_rtx)\n     return gen_binary (reverse_condition (true_code),\n@@ -4064,7 +4065,7 @@ simplify_if_then_else (x)\n \n       temp = true, true = false, false = temp, cond = XEXP (x, 0);\n \n-      /* It is possible that the conditional has been simplified out. */\n+      /* It is possible that the conditional has been simplified out.  */\n       true_code = GET_CODE (cond);\n       comparison_p = GET_RTX_CLASS (true_code) == '<';\n     }\n@@ -4152,7 +4153,7 @@ simplify_if_then_else (x)\n \tc1 = XEXP (t, 1), op = GET_CODE (t), z = f;\n \n       /* If an identity-zero op is commutative, check whether there\n-\t would be a match if we swapped the operands. */\n+\t would be a match if we swapped the operands.  */\n       else if ((GET_CODE (t) == PLUS || GET_CODE (t) == IOR\n \t\t|| GET_CODE (t) == XOR)\n \t       && rtx_equal_p (XEXP (t, 1), f))\n@@ -4466,7 +4467,7 @@ simplify_set (x)\n #ifdef LOAD_EXTEND_OP\n   /* If we have (set FOO (subreg:M (mem:N BAR) 0)) with M wider than N, this\n      would require a paradoxical subreg.  Replace the subreg with a\n-     zero_extend to avoid the reload that would otherwise be required. */\n+     zero_extend to avoid the reload that would otherwise be required.  */\n \n   if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n       && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))) != NIL\n@@ -4594,7 +4595,7 @@ simplify_logical (x, last)\n \n \t  /* If we have (ior (and (X C1) C2)) and the next restart would be\n \t     the last, simplify this by making C1 as small as possible\n-\t     and then exit. */\n+\t     and then exit.  */\n \t  if (last\n \t      && GET_CODE (x) == IOR && GET_CODE (op0) == AND\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n@@ -4966,7 +4967,7 @@ expand_field_assignment (x)\n      rtx x;\n {\n   rtx inner;\n-  rtx pos;\t\t\t/* Always counts from low bit. */\n+  rtx pos;\t\t\t/* Always counts from low bit.  */\n   int len;\n   rtx mask;\n   enum machine_mode compute_mode;\n@@ -5341,7 +5342,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t If it is mixed, we must adjust.  */\n \t     \n       /* If bytes are big endian and we had a paradoxical SUBREG, we must\n-\t adjust OFFSET to compensate. */\n+\t adjust OFFSET to compensate.  */\n       if (BYTES_BIG_ENDIAN\n \t  && ! spans_byte\n \t  && GET_MODE_SIZE (inner_mode) < GET_MODE_SIZE (is_mode))\n@@ -5400,7 +5401,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   /* Make POS_RTX unless we already have it and it is correct.  If we don't\n      have a POS_RTX but we do have an ORIG_POS_RTX, the latter must\n-     be a CONST_INT. */\n+     be a CONST_INT.  */\n   if (pos_rtx == 0 && orig_pos_rtx != 0 && INTVAL (orig_pos_rtx) == pos)\n     pos_rtx = orig_pos_rtx;\n \n@@ -5640,7 +5641,7 @@ make_compound_operation (x, in_code)\n \t  break;\n \t}\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case ASHIFTRT:\n       lhs = XEXP (x, 0);\n@@ -5847,7 +5848,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n     {\n     case CLOBBER:\n       /* If X is a (clobber (const_int)), return it since we know we are\n-\t generating something that won't match. */\n+\t generating something that won't match.  */\n       return x;\n \n     case USE:\n@@ -5961,7 +5962,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t\t\t\tmode, mask, reg, next_select);\n       }\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case MINUS:\n     case MULT:\n@@ -6125,7 +6126,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \n \t  if (GET_MODE_BITSIZE (GET_MODE (x)) > HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      nonzero = ~(HOST_WIDE_INT)0;\n+\t      nonzero = ~ (HOST_WIDE_INT) 0;\n \n \t      /* GET_MODE_BITSIZE (GET_MODE (x)) - INTVAL (XEXP (x, 1))\n \t\t is the number of bits a full-width mask would have set.\n@@ -6717,7 +6718,8 @@ apply_distributive_law (x)\n \n   lhs = XEXP (x, 0), rhs = XEXP (x, 1);\n \n-  /* If either operand is a primitive we can't do anything, so get out fast. */\n+  /* If either operand is a primitive we can't do anything, so get out\n+     fast.  */\n   if (GET_RTX_CLASS (GET_CODE (lhs)) == 'o'\n       || GET_RTX_CLASS (GET_CODE (rhs)) == 'o')\n     return x;\n@@ -6902,7 +6904,7 @@ simplify_and_const_int (x, mode, varop, constop)\n   else\n     varop = gen_lowpart_for_combine (mode, varop);\n \n-  /* If we can't make the SUBREG, try to return what we were given. */\n+  /* If we can't make the SUBREG, try to return what we were given.  */\n   if (GET_CODE (varop) == CLOBBER)\n     return x ? x : varop;\n \n@@ -7339,7 +7341,7 @@ num_sign_bit_copies (x, mode)\n \n   bitwidth = GET_MODE_BITSIZE (mode);\n \n-  /* For a smaller object, just ignore the high bits. */\n+  /* For a smaller object, just ignore the high bits.  */\n   if (bitwidth < GET_MODE_BITSIZE (GET_MODE (x)))\n     return MAX (1, (num_sign_bit_copies (x, GET_MODE (x))\n \t\t    - (GET_MODE_BITSIZE (GET_MODE (x)) - bitwidth)));\n@@ -7406,7 +7408,7 @@ num_sign_bit_copies (x, mode)\n \treturn MAX (bitwidth - GET_MODE_BITSIZE (GET_MODE (x)) + 1,\n \t\t    num_sign_bit_copies (SUBREG_REG (x), mode));\n \n-      /* For a smaller object, just ignore the high bits. */\n+      /* For a smaller object, just ignore the high bits.  */\n       if (bitwidth <= GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))))\n \t{\n \t  num0 = num_sign_bit_copies (SUBREG_REG (x), VOIDmode);\n@@ -7445,7 +7447,7 @@ num_sign_bit_copies (x, mode)\n \t      + num_sign_bit_copies (XEXP (x, 0), VOIDmode));\n \n     case TRUNCATE:\n-      /* For a smaller object, just ignore the high bits. */\n+      /* For a smaller object, just ignore the high bits.  */\n       num0 = num_sign_bit_copies (XEXP (x, 0), VOIDmode);\n       return MAX (1, (num0 - (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t\t\t      - bitwidth)));\n@@ -7836,7 +7838,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n       /* We need to determine what mode we will do the shift in.  If the\n \t shift is a right shift or a ROTATE, we must always do it in the mode\n \t it was originally done in.  Otherwise, we can do it in MODE, the\n-\t widest mode encountered. */\n+\t widest mode encountered.  */\n       shift_mode\n \t= (code == ASHIFTRT || code == LSHIFTRT || code == ROTATE\n \t   ? result_mode : mode);\n@@ -7869,7 +7871,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \n       /* Negative counts are invalid and should not have been made (a\n \t programmer-specified negative count should have been handled\n-\t above). */\n+\t above).  */\n       else if (count < 0)\n \tabort ();\n \n@@ -8022,7 +8024,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      continue;\n \t    }\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \n \tcase LSHIFTRT:\n \tcase ASHIFT:\n@@ -8413,7 +8415,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n   else if (GET_MODE (varop) != shift_mode)\n     varop = gen_lowpart_for_combine (shift_mode, varop);\n \n-  /* If we can't make the SUBREG, try to return what we were given. */\n+  /* If we can't make the SUBREG, try to return what we were given.  */\n   if (GET_CODE (varop) == CLOBBER)\n     return x ? x : varop;\n \n@@ -8799,7 +8801,7 @@ gen_binary (code, mode, op0, op1)\n       enum machine_mode op_mode = GET_MODE (op0);\n \n       /* Strip the COMPARE from (REL_OP (compare X Y) 0) to get \n-\t just (REL_OP X Y). */\n+\t just (REL_OP X Y).  */\n       if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n \t{\n \t  op1 = XEXP (op0, 1);\n@@ -8970,7 +8972,7 @@ simplify_comparison (code, pop0, pop1)\n \t      op1 = SUBREG_REG (inner_op1);\n \n \t      /* The resulting comparison is always unsigned since we masked\n-\t\t off the original sign bit. */\n+\t\t off the original sign bit.  */\n \t      code = unsigned_condition (code);\n \n \t      changed = 1;\n@@ -9110,7 +9112,7 @@ simplify_comparison (code, pop0, pop1)\n \t  break;\n \n \tcase GE:\n-\t  /* >= C is equivalent to > (C - 1). */\n+\t  /* >= C is equivalent to > (C - 1).  */\n \t  if (const_op > 0)\n \t    {\n \t      const_op -= 1;\n@@ -9146,7 +9148,7 @@ simplify_comparison (code, pop0, pop1)\n \t      const_op -= 1;\n \t      op1 = GEN_INT (const_op);\n \t      code = LEU;\n-\t      /* ... fall through ... */\n+\t      /* ... fall through ...  */\n \t    }\n \n \t  /* (unsigned) < 0x80000000 is equivalent to >= 0.  */\n@@ -9164,7 +9166,7 @@ simplify_comparison (code, pop0, pop1)\n \t  if (const_op == 0)\n \t    code = EQ;\n \n-\t  /* (unsigned) <= 0x7fffffff is equivalent to >= 0. */\n+\t  /* (unsigned) <= 0x7fffffff is equivalent to >= 0.  */\n \t  else if (const_op == ((HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n \t    {\n \t      const_op = 0, op1 = const0_rtx;\n@@ -9179,7 +9181,7 @@ simplify_comparison (code, pop0, pop1)\n \t      const_op -= 1;\n \t      op1 = GEN_INT (const_op);\n \t      code = GTU;\n-\t      /* ... fall through ... */\n+\t      /* ... fall through ...  */\n \t    }\n \n \t  /* (unsigned) >= 0x80000000 is equivalent to < 0.  */\n@@ -9256,7 +9258,7 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \n \tcase SIGN_EXTRACT:\n \t  tem = expand_compound_operation (op0);\n@@ -9316,7 +9318,7 @@ simplify_comparison (code, pop0, pop1)\n \t    }\n \n \t  /* If we have NEG of something whose two high-order bits are the\n-\t     same, we know that \"(-a) < 0\" is equivalent to \"a > 0\". */\n+\t     same, we know that \"(-a) < 0\" is equivalent to \"a > 0\".  */\n \t  if (num_sign_bit_copies (op0, mode) >= 2)\n \t    {\n \t      op0 = XEXP (op0, 0);\n@@ -9352,7 +9354,7 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \n \tcase ABS:\n \t  /* ABS is ignorable inside an equality comparison with zero.  */\n@@ -9419,7 +9421,7 @@ simplify_comparison (code, pop0, pop1)\n \t  else\n \t    break;\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \n \tcase ZERO_EXTEND:\n \t  if ((unsigned_comparison_p || equality_comparison_p)\n@@ -9702,7 +9704,7 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \tcase LSHIFTRT:\n \t  /* If we have (compare (xshiftrt FOO N) (const_int C)) and\n \t     the low order N bits of FOO are known to be zero, we can do this\n@@ -10152,7 +10154,7 @@ get_last_value (x)\n \n   /* If this is a non-paradoxical SUBREG, get the value of its operand and\n      then convert it to the desired mode.  If this is a paradoxical SUBREG,\n-     we cannot predict what values the \"extra\" bits might have. */\n+     we cannot predict what values the \"extra\" bits might have.  */\n   if (GET_CODE (x) == SUBREG\n       && subreg_lowpart_p (x)\n       && (GET_MODE_SIZE (GET_MODE (x))\n@@ -10166,7 +10168,8 @@ get_last_value (x)\n   regno = REGNO (x);\n   value = reg_last_set_value[regno];\n \n-  /* If we don't have a value or if it isn't for this basic block, return 0. */\n+  /* If we don't have a value or if it isn't for this basic block,\n+     return 0.  */\n \n   if (value == 0\n       || (reg_n_sets[regno] != 1"}, {"sha": "472f47e9543e4448dea952f9791bc528fadef973", "filename": "gcc/convert.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -20,7 +20,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n /* These routines are somewhat language-independent utility function\n-   intended to be called by the language-specific convert () functions. */\n+   intended to be called by the language-specific convert () functions.  */\n \n #include \"config.h\"\n #include \"tree.h\"\n@@ -30,7 +30,7 @@ Boston, MA 02111-1307, USA.  */\n /* Convert EXPR to some pointer or reference type TYPE.\n \n    EXPR must be pointer, reference, integer, enumeral, or literal zero;\n-   in other cases error is called. */\n+   in other cases error is called.  */\n \n tree\n convert_to_pointer (type, expr)\n@@ -74,7 +74,7 @@ convert_to_pointer (type, expr)\n /* Convert EXPR to some floating-point type TYPE.\n \n    EXPR must be float, integer, or enumeral;\n-   in other cases error is called. */\n+   in other cases error is called.  */\n \n tree\n convert_to_real (type, expr)"}, {"sha": "3ac168089312317265038683b262dc44e9e7eb05", "filename": "gcc/cplus-dem.c", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -23,7 +23,7 @@ Boston, MA 02111-1307, USA.  */\n \n    This file imports xmalloc and xrealloc, which are like malloc and\n    realloc except that they generate a fatal error if there is no\n-   available memory. */\n+   available memory.  */\n \n #include <ctype.h>\n #include <string.h>\n@@ -67,7 +67,7 @@ mystrstr (s1, s2)\n    We could avoid this if we could just get g++ to tell us what the actual\n    cplus marker character is as part of the debug information, perhaps by\n    ensuring that it is the character that terminates the gcc<n>_compiled\n-   marker symbol (FIXME). */\n+   marker symbol (FIXME).  */\n \n #if !defined (CPLUS_MARKER)\n #define CPLUS_MARKER '$'\n@@ -85,7 +85,7 @@ set_cplus_marker_for_demangling (ch)\n }\n \n /* Stuff that is shared between sub-routines.\n- * Using a shared structure allows cplus_demangle to be reentrant. */\n+   Using a shared structure allows cplus_demangle to be reentrant.  */\n \n struct work_stuff\n {\n@@ -190,7 +190,7 @@ static const struct optable\n \n \n typedef struct string\t\t/* Beware: these aren't required to be */\n-{\t\t\t\t/*  '\\0' terminated. */\n+{\t\t\t\t/*  '\\0' terminated.  */\n   char *b;\t\t\t/* pointer to start of string */\n   char *p;\t\t\t/* pointer after last character */\n   char *e;\t\t\t/* pointer after end of allocated space */\n@@ -304,7 +304,7 @@ string_prepends PARAMS ((string *, string *));\n /*  Translate count to integer, consuming tokens in the process.\n     Conversion terminates on the first non-digit character.\n     Trying to consume something that isn't a count results in\n-    no consumption of input and a return of 0. */\n+    no consumption of input and a return of 0.  */\n \n static int\n consume_count (type)\n@@ -374,7 +374,7 @@ cplus_demangle_opname (opname, result, options)\n \t{\n \t  if (opname[2] == 'a' && opname[5] == '\\0')\n \t    {\n-\t      /* Assignment. */\n+\t      /* Assignment.  */\n \t      for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n \t\t{\n \t\t  if (strlen (optable[i].in) == 3\n@@ -469,8 +469,8 @@ cplus_mangle_opname (opname, options)\n   return (0);\n }\n \n-/* check to see whether MANGLED can match TEXT in the first TEXT_LEN\n-   characters. */\n+/* Check to see whether MANGLED can match TEXT in the first TEXT_LEN\n+   characters.  */\n \n int cplus_match (mangled, text, text_len)\n      const char *mangled;\n@@ -536,7 +536,7 @@ cplus_demangle (mangled, options)\n \t recognize one of the gnu special forms rather than looking for a\n \t standard prefix.  In particular, don't worry about whether there\n \t is a \"__\" string in the mangled string.  Consider \"_$_5__foo\" for\n-\t example. */\n+\t example.  */\n \n       if ((AUTO_DEMANGLING || GNU_DEMANGLING))\n \t{\n@@ -573,7 +573,7 @@ mop_up (work, declp, success)\n {\n   char *demangled = NULL;\n \n-  /* Discard the remembered types, if any. */\n+  /* Discard the remembered types, if any.  */\n   \n   forget_types (work);\n   if (work -> typevec != NULL)\n@@ -582,7 +582,7 @@ mop_up (work, declp, success)\n     }\n   \n   /* If demangling was successful, ensure that the demangled string is null\n-     terminated and return it.  Otherwise, free the demangling decl. */\n+     terminated and return it.  Otherwise, free the demangling decl.  */\n   \n   if (!success)\n     {\n@@ -624,8 +624,7 @@ DESCRIPTION\n \n \tDemangling GNU style mangled names is nasty because there is no\n \texplicit token that marks the start of the outermost function\n-\targument list.\n-*/\n+\targument list.  */\n \n static int\n demangle_signature (work, mangled, declp)\n@@ -701,7 +700,7 @@ demangle_signature (work, mangled, declp)\n \t    /* ARM style demangling includes a specific 'F' character after\n \t     the class name.  For GNU style, it is just implied.  So we can\n \t     safely just consume any 'F' at this point and be compatible\n-\t     with either style. */\n+\t     with either style.  */\n \n \t    oldmangled = NULL;\n \t    func_done = 1;\n@@ -756,15 +755,15 @@ demangle_signature (work, mangled, declp)\n \t       so if we run into another '_' at this point we are dealing with\n \t       a mangled name that is either bogus, or has been mangled by\n \t       some algorithm we don't know how to deal with.  So just\n-\t       reject the entire demangling. */\n+\t       reject the entire demangling.  */\n \t    success = 0;\n \t    break;\n \n \t  default:\n \t    if (AUTO_DEMANGLING || GNU_DEMANGLING)\n \t      {\n \t\t/* Assume we have stumbled onto the first outermost function\n-\t\t   argument token, and start processing args. */\n+\t\t   argument token, and start processing args.  */\n \t\tfunc_done = 1;\n \t\tsuccess = demangle_args (work, mangled, declp);\n \t      }\n@@ -773,7 +772,7 @@ demangle_signature (work, mangled, declp)\n \t\t/* Non-GNU demanglers use a specific token to mark the start\n \t\t   of the outermost function argument tokens.  Typically 'F',\n \t\t   for ARM-demangling, for example.  So if we find something\n-\t\t   we are not prepared for, it must be an error. */\n+\t\t   we are not prepared for, it must be an error.  */\n \t\tsuccess = 0;\n \t      }\n \t    break;\n@@ -798,7 +797,7 @@ demangle_signature (work, mangled, declp)\n \t     first case, and need to ensure that the '(void)' gets added to\n \t     the current declp.  Note that with ARM, the first case\n \t     represents the name of a static data member 'foo::bar',\n-\t     which is in the current declp, so we leave it alone. */\n+\t     which is in the current declp, so we leave it alone.  */\n \t  success = demangle_args (work, mangled, declp);\n \t}\n     }\n@@ -1343,7 +1342,7 @@ demangle_prefix (work, mangled, declp)\n   if (scan != NULL)\n     {\n       /* We found a sequence of two or more '_', ensure that we start at\n-\t the last pair in the sequence. */\n+\t the last pair in the sequence.  */\n       i = strspn (scan, \"_\");\n       if (i > 2)\n \t{\n@@ -1412,7 +1411,7 @@ demangle_prefix (work, mangled, declp)\n     }\n   else if (ARM_DEMANGLING && scan[2] == 'p' && scan[3] == 't')\n     {\n-      /* Cfront-style parameterized type.  Handled later as a signature. */\n+      /* Cfront-style parameterized type.  Handled later as a signature.  */\n       success = 1;\n \n       /* ARM template? */\n@@ -1422,7 +1421,7 @@ demangle_prefix (work, mangled, declp)\n     {\n       /* Mangled name does not start with \"__\" but does have one somewhere\n \t in there with non empty stuff after it.  Looks like a global\n-\t function name. */\n+\t function name.  */\n       demangle_function_name (work, mangled, declp, scan);\n     }\n   else\n@@ -1498,7 +1497,7 @@ gnu_special (work, mangled, declp)\n       /* Found a GNU style virtual table, get past \"_vt<CPLUS_MARKER>\"\n          and create the decl.  Note that we consume the entire mangled\n \t input string, which means that demangle_signature has no work\n-\t to do. */\n+\t to do.  */\n       if ((*mangled)[2] == 'v')\n \t(*mangled) += 5; /* New style, with thunks: \"__vt_\" */\n       else\n@@ -1566,7 +1565,7 @@ gnu_special (work, mangled, declp)\n       if (success && (p == *mangled))\n \t{\n \t  /* Consumed everything up to the cplus_marker, append the\n-\t     variable name. */\n+\t     variable name.  */\n \t  (*mangled)++;\n \t  string_append (declp, \"::\");\n \t  n = strlen (*mangled);\n@@ -1642,7 +1641,7 @@ arm_special (work, mangled, declp)\n       /* Found a ARM style virtual table, get past ARM_VTABLE_STRING\n          and create the decl.  Note that we consume the entire mangled\n \t input string, which means that demangle_signature has no work\n-\t to do. */\n+\t to do.  */\n       scan = *mangled + ARM_VTABLE_STRLEN;\n       while (*scan != '\\0')        /* first check it can be demangled */\n         {\n@@ -1780,7 +1779,7 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n     return success;\n \n   /* Pick off the names and collect them in the temp buffer in the order\n-     in which they are found, separated by '::'. */\n+     in which they are found, separated by '::'.  */\n \n   while (qualifiers-- > 0)\n     {\n@@ -1812,7 +1811,7 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n   /* If we are using the result as a function name, we need to append\n      the appropriate '::' separated constructor or destructor name.\n      We do this here because this is the most convenient place, where\n-     we already have a pointer to the name and the length of the name. */\n+     we already have a pointer to the name and the length of the name.  */\n \n   if (isfuncname && (work->constructor & 1 || work->destructor & 1))\n     {\n@@ -1825,7 +1824,7 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n     }\n \n   /* Now either prepend the temp buffer to the result, or append it, \n-     depending upon the state of the append flag. */\n+     depending upon the state of the append flag.  */\n \n   if (append)\n     {\n@@ -1983,7 +1982,7 @@ do_type (work, mangled, result)\n \t    }\n \t  /* After picking off the function args, we expect to either find the\n \t     function return type (preceded by an '_') or the end of the\n-\t     string. */\n+\t     string.  */\n \t  if (!demangle_args (work, mangled, &decl)\n \t      || (**mangled != '_' && **mangled != '\\0'))\n \t    {\n@@ -2092,7 +2091,7 @@ do_type (work, mangled, result)\n \n   switch (**mangled)\n     {\n-      /* A qualified name, such as \"Outer::Inner\". */\n+      /* A qualified name, such as \"Outer::Inner\".  */\n       case 'Q':\n         success = demangle_qualified (work, mangled, result, 0, 1);\n \tbreak;\n@@ -2140,7 +2139,7 @@ demangle_fund_type (work, mangled, result)\n   int done = 0;\n   int success = 1;\n \n-  /* First pick off any type qualifiers.  There can be more than one. */\n+  /* First pick off any type qualifiers.  There can be more than one.  */\n \n   while (!done)\n     {\n@@ -2178,7 +2177,7 @@ demangle_fund_type (work, mangled, result)\n \t}\n     }\n \n-  /* Now pick off the fundamental type.  There can be only one. */\n+  /* Now pick off the fundamental type.  There can be only one.  */\n \n   switch (**mangled)\n     {\n@@ -2327,7 +2326,7 @@ remember_type (work, start, len)\n   work -> typevec[work -> ntypes++] = tem;\n }\n \n-/* Forget the remembered types, but not the type vector itself. */\n+/* Forget the remembered types, but not the type vector itself.  */\n \n static void\n forget_types (work)\n@@ -2452,7 +2451,7 @@ demangle_args (work, mangled, declp)\n \t      t--;\n \t    }\n \t  /* Validate the type index.  Protect against illegal indices from\n-\t     malformed type strings. */\n+\t     malformed type strings.  */\n \t  if ((t < 0) || (t >= work -> ntypes))\n \t    {\n \t      return (0);\n@@ -2533,7 +2532,7 @@ demangle_function_name (work, mangled, declp, scan)\n \n   /* Consume the function name, including the \"__\" separating the name\n      from the signature.  We are guaranteed that SCAN points to the\n-     separator. */\n+     separator.  */\n \n   (*mangled) = scan + 2;\n \n@@ -2543,7 +2542,7 @@ demangle_function_name (work, mangled, declp, scan)\n       /* See if we have an ARM style constructor or destructor operator.\n \t If so, then just record it, clear the decl, and return.\n \t We can't build the actual constructor/destructor decl until later,\n-\t when we recover the class name from the signature. */\n+\t when we recover the class name from the signature.  */\n \n       if (strcmp (declp -> b, \"__ct\") == 0)\n \t{\n@@ -2648,7 +2647,7 @@ demangle_function_name (work, mangled, declp, scan)\n \t{\n \t  if (declp->b[2] == 'a' && declp->b[5] == '\\0')\n \t    {\n-\t      /* Assignment. */\n+\t      /* Assignment.  */\n \t      for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n \t\t{\n \t\t  if (strlen (optable[i].in) == 3\n@@ -2817,7 +2816,7 @@ string_prependn (p, s, n)\n /* To generate a standalone demangler program for testing purposes,\n    just compile and link this file with -DMAIN and libiberty.a.  When\n    run, it demangles each command line arg, or each stdin string, and\n-   prints the result on stdout. */\n+   prints the result on stdout.  */\n \n #ifdef MAIN\n \n@@ -2860,7 +2859,7 @@ Usage: %s [-_] [-n] [-s {gnu,lucid,arm}] [--strip-underscores]\\n\\\n #define MBUF_SIZE 512\n char mbuffer[MBUF_SIZE];\n \n-/* Defined in the automatically-generated underscore.c. */\n+/* Defined in the automatically-generated underscore.c.  */\n extern int prepends_underscore;\n \n int strip_underscore = 0;\n@@ -2940,7 +2939,7 @@ main (argc, argv)\n \t{\n \t  int i = 0;\n \t  c = getchar ();\n-\t  /* Try to read a label. */\n+\t  /* Try to read a label.  */\n \t  while (c != EOF && (isalnum(c) || c == '_' || c == '$' || c == '.'))\n \t    {\n \t      if (i >= MBUF_SIZE-1)"}, {"sha": "0cf24b90ce37d1eade0421cfdb5402925eeca420", "filename": "gcc/cpperror.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -89,7 +89,9 @@ cpp_file_line_for_message (pfile, filename, line, column)\n }\n \n /* IS_ERROR is 2 for \"fatal\" error, 1 for error, 0 for warning */\n-void cpp_message (pfile, is_error, msg, arg1, arg2, arg3)\n+\n+void\n+cpp_message (pfile, is_error, msg, arg1, arg2, arg3)\n      int is_error;\n      cpp_reader *pfile;\n      char *msg;"}, {"sha": "dee3da26ca26d591724d3d8eadaa59d6229ab29e", "filename": "gcc/cppexp.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -20,7 +20,7 @@ Boston, MA 02111-1307, USA.\n  You are forbidden to forbid anyone else to use, share and improve\n  what you give them.   Help stamp out software-hoarding!\n \n-Written by Per Bothner 1994. */\n+Written by Per Bothner 1994.  */\n \n /* Parse a C expression from text in a string  */\n    \n@@ -60,7 +60,7 @@ struct arglist {\n #endif\n \n #ifndef NULL_PTR\n-#define NULL_PTR ((GENERIC_PTR)0)\n+#define NULL_PTR ((GENERIC_PTR) 0)\n #endif\n \n extern char *xmalloc ();\n@@ -122,7 +122,7 @@ static long right_shift ();\n #define RIGHT_OPERAND_REQUIRED 2\n #define HAVE_VALUE 4\n /* SKIP_OPERAND is set for '&&' '||' '?' and ':' when the\n-   following operand should be short-circuited instead of evaluated. */\n+   following operand should be short-circuited instead of evaluated.  */\n #define SKIP_OPERAND 8\n /*#define UNSIGNEDP 16*/\n \n@@ -140,10 +140,10 @@ static long right_shift ();\n \n struct operation {\n     short op;\n-    char rprio; /* Priority of op (relative to it right operand). */\n+    char rprio; /* Priority of op (relative to it right operand).  */\n     char flags;\n     char unsignedp;    /* true if value should be treated as unsigned */\n-    HOST_WIDE_INT value;        /* The value logically \"right\" of op. */\n+    HOST_WIDE_INT value;        /* The value logically \"right\" of op.  */\n };\n \f\n /* Take care of parsing a number (anything that starts with a digit).\n@@ -186,7 +186,7 @@ parse_number (pfile, start, olen)\n   else if (*p == '0')\n     base = 8;\n \n-  /* Some buggy compilers (e.g. MPW C) seem to need both casts. */\n+  /* Some buggy compilers (e.g. MPW C) seem to need both casts.  */\n   ULONG_MAX_over_base = ((unsigned long) -1) / ((unsigned long) base);\n \n   for (; len > 0; len--) {\n@@ -275,7 +275,7 @@ static struct token tokentab2[] = {\n   {NULL, ERROR}\n };\n \n-/* Read one token. */\n+/* Read one token.  */\n \n struct operation\n cpp_lex (pfile)\n@@ -310,7 +310,7 @@ cpp_lex (pfile)\n   pfile->limit = tok_start;\n   switch (token)\n   {\n-    case CPP_EOF: /* Should not happen ... */\n+    case CPP_EOF: /* Should not happen ...  */\n     case CPP_VSPACE:\n       op.op = 0;\n       return op;\n@@ -630,7 +630,7 @@ right_shift (pfile, a, unsignedp, b)\n     return a >> b;\n }\n \f\n-/* These priorities are all even, so we can handle associatively. */\n+/* These priorities are all even, so we can handle associatively.  */\n #define PAREN_INNER_PRIO 0\n #define COMMA_PRIO 4\n #define COND_PRIO (COMMA_PRIO+2)\n@@ -688,7 +688,7 @@ cpp_parse_expr (pfile)\n \n       /* See if the token is an operand, in which case go to set_value.\n \t If the token is an operator, figure out its left and right\n-\t priorities, and then goto maybe_reduce. */\n+\t priorities, and then goto maybe_reduce.  */\n \n       switch (op.op)\n \t{\n@@ -745,7 +745,7 @@ cpp_parse_expr (pfile)\n \t}\n \n     set_value:\n-      /* Push a value onto the stack. */\n+      /* Push a value onto the stack.  */\n       if (top->flags & HAVE_VALUE)\n \t{\n \t  cpp_error (pfile, \"syntax error in #if\");\n@@ -755,7 +755,7 @@ cpp_parse_expr (pfile)\n       continue;\n \n     maybe_reduce:\n-      /* Push an operator, and check if we can reduce now. */\n+      /* Push an operator, and check if we can reduce now.  */\n       while (top->rprio > lprio)\n \t{\n \t  long v1 = top[-1].value, v2 = top[0].value;\n@@ -985,22 +985,22 @@ cpp_parse_expr (pfile)\n \t}\n       top++;\n       \n-      /* Check for and handle stack overflow. */\n+      /* Check for and handle stack overflow.  */\n       if (top == limit)\n \t{\n \t  struct operation *new_stack;\n-\t  int old_size = (char*)limit - (char*)stack;\n+\t  int old_size = (char *) limit - (char *) stack;\n \t  int new_size = 2 * old_size;\n \t  if (stack != init_stack)\n-\t    new_stack = (struct operation*) xrealloc (stack, new_size);\n+\t    new_stack = (struct operation *) xrealloc (stack, new_size);\n \t  else\n \t    {\n-\t      new_stack = (struct operation*) xmalloc (new_size);\n+\t      new_stack = (struct operation *) xmalloc (new_size);\n \t      bcopy ((char *) stack, (char *) new_stack, old_size);\n \t    }\n \t  stack = new_stack;\n-\t  top = (struct operation*)((char*) new_stack + old_size);\n-\t  limit = (struct operation*)((char*) new_stack + new_size);\n+\t  top = (struct operation *) ((char *) new_stack + old_size);\n+\t  limit = (struct operation *) ((char *) new_stack + new_size);\n \t}\n       \n       top->flags = flags;"}, {"sha": "737ac39ef112d14955f1702f2d7a3096c9e4840c", "filename": "gcc/cpphash.c", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -28,10 +28,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n extern char *xmalloc PARAMS ((unsigned));\n \n-/*\n- * return hash function on name.  must be compatible with the one\n- * computed a step at a time, elsewhere\n- */\n+/* Return hash function on name.  must be compatible with the one\n+   computed a step at a time, elsewhere  */\n+\n int\n hashf (name, len, hashsize)\n      register const U_CHAR *name;\n@@ -46,16 +45,15 @@ hashf (name, len, hashsize)\n   return MAKE_POS (r) % hashsize;\n }\n \n-/*\n- * find the most recent hash node for name name (ending with first\n- * non-identifier char) installed by install\n- *\n- * If LEN is >= 0, it is the length of the name.\n- * Otherwise, compute the length by scanning the entire name.\n- *\n- * If HASH is >= 0, it is the precomputed hash code.\n- * Otherwise, compute the hash code.\n- */\n+/* Find the most recent hash node for name name (ending with first\n+   non-identifier char) installed by install\n+\n+   If LEN is >= 0, it is the length of the name.\n+   Otherwise, compute the length by scanning the entire name.\n+\n+   If HASH is >= 0, it is the precomputed hash code.\n+   Otherwise, compute the hash code.  */\n+\n HASHNODE *\n cpp_lookup (pfile, name, len, hash)\n      cpp_reader *pfile;\n@@ -81,7 +79,7 @@ cpp_lookup (pfile, name, len, hash)\n       return bucket;\n     bucket = bucket->next;\n   }\n-  return (HASHNODE*) 0;\n+  return (HASHNODE *) 0;\n }\n \n /*\n@@ -109,7 +107,7 @@ delete_macro (hp)\n     hp->next->prev = hp->prev;\n \n   /* make sure that the bucket chain header that\n-     the deleted guy was on points to the right thing afterwards. */\n+     the deleted guy was on points to the right thing afterwards.  */\n   if (hp == *hp->bucket_hdr)\n     *hp->bucket_hdr = hp->next;\n \n@@ -130,20 +128,20 @@ delete_macro (hp)\n \n   free (hp);\n }\n-/*\n- * install a name in the main hash table, even if it is already there.\n- *   name stops with first non alphanumeric, except leading '#'.\n- * caller must check against redefinition if that is desired.\n- * delete_macro () removes things installed by install () in fifo order.\n- * this is important because of the `defined' special symbol used\n- * in #if, and also if pushdef/popdef directives are ever implemented.\n- *\n- * If LEN is >= 0, it is the length of the name.\n- * Otherwise, compute the length by scanning the entire name.\n- *\n- * If HASH is >= 0, it is the precomputed hash code.\n- * Otherwise, compute the hash code.\n- */\n+\n+/* Install a name in the main hash table, even if it is already there.\n+     name stops with first non alphanumeric, except leading '#'.\n+   caller must check against redefinition if that is desired.\n+   delete_macro () removes things installed by install () in fifo order.\n+   this is important because of the `defined' special symbol used\n+   in #if, and also if pushdef/popdef directives are ever implemented.\n+\n+   If LEN is >= 0, it is the length of the name.\n+   Otherwise, compute the length by scanning the entire name.\n+\n+   If HASH is >= 0, it is the precomputed hash code.\n+   Otherwise, compute the hash code.  */\n+\n HASHNODE *\n install (name, len, type, ivalue, value, hash)\n      U_CHAR *name;"}, {"sha": "ed06c186aedbbd76282618d6adc7bb36ee1c810a", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -35,4 +35,4 @@ static HASHNODE *hashtab[HASHSIZE];\n #define HASHSTEP(old, c) ((old << 2) + c)\n #define MAKE_POS(v) (v & 0x7fffffff) /* make number positive */\n \n-extern HASHNODE* install PARAMS ((U_CHAR*,int,enum node_type, int,char*,int));\n+extern HASHNODE *install PARAMS ((U_CHAR *,int,enum node_type, int,char *,int));"}, {"sha": "6719c82adb278cc783d34bd4f64f9457ffc8965a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 113, "deletions": 106, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -84,7 +84,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #endif /* USG */\n #endif /* not VMS */\n \n-/* This defines \"errno\" properly for VMS, and gives us EACCES. */\n+/* This defines \"errno\" properly for VMS, and gives us EACCES.  */\n #include <errno.h>\n \n extern char *index ();\n@@ -136,7 +136,7 @@ extern char *rindex ();\n #endif\n \n #ifndef NULL_PTR\n-#define NULL_PTR ((GENERIC_PTR)0)\n+#define NULL_PTR ((GENERIC_PTR) 0)\n #endif\n \n #ifndef INCLUDE_LEN_FUDGE\n@@ -204,7 +204,7 @@ struct assertion_hashnode {\n   struct assertion_hashnode *prev;\n   /* also, a back pointer to this node's hash\n      chain is kept, in case the node is the head\n-     of the chain and gets deleted. */\n+     of the chain and gets deleted.  */\n   struct assertion_hashnode **bucket_hdr;\n   int length;\t\t\t/* length of token, for quick comparison */\n   U_CHAR *name;\t\t\t/* the actual name */\n@@ -233,7 +233,7 @@ struct assertion_hashnode {\n #define NEWLINE_FIX \\\n   do {while (PEEKC() == '\\\\' && PEEKN(1) == '\\n') FORWARD(2); } while(0)\n \n-/* Same, but assume we've already read the potential '\\\\' into C. */\n+/* Same, but assume we've already read the potential '\\\\' into C.  */\n #define NEWLINE_FIX1(C) do { \\\n     while ((C) == '\\\\' && PEEKC() == '\\n') { FORWARD(1); (C) = GETC(); }\\\n   } while(0)\n@@ -287,8 +287,8 @@ static struct arglist *read_token_list ();\n static void free_token_list ();\n static int safe_read ();\n static void push_macro_expansion PARAMS ((cpp_reader *,\n-\t\t\t\t\t  U_CHAR*, int, HASHNODE*));\n-static struct cpp_pending *nreverse_pending PARAMS ((struct cpp_pending*));\n+\t\t\t\t\t  U_CHAR *, int, HASHNODE *));\n+static struct cpp_pending *nreverse_pending PARAMS ((struct cpp_pending *));\n extern char *xrealloc ();\n static char *xcalloc ();\n static char *savestring ();\n@@ -301,7 +301,7 @@ enum file_change_code {same_file, enter_file, leave_file};\n \n /* External declarations.  */\n \n-extern HOST_WIDE_INT cpp_parse_expr PARAMS ((cpp_reader*));\n+extern HOST_WIDE_INT cpp_parse_expr PARAMS ((cpp_reader *));\n \n extern char *getenv ();\n extern FILE *fdopen ();\n@@ -347,12 +347,12 @@ struct file_name_list\n   };\n \n /* If a buffer's dir field is SELF_DIR_DUMMY, it means the file was found\n-   via the same directory as the file that #included it. */\n-#define SELF_DIR_DUMMY ((struct file_name_list*)(~0))\n+   via the same directory as the file that #included it.  */\n+#define SELF_DIR_DUMMY ((struct file_name_list *) (~0))\n \n-/* #include \"file\" looks in source file dir, then stack. */\n-/* #include <file> just looks in the stack. */\n-/* -I directories are added to the end, then the defaults are added. */\n+/* #include \"file\" looks in source file dir, then stack.  */\n+/* #include <file> just looks in the stack.  */\n+/* -I directories are added to the end, then the defaults are added.  */\n /* The */\n static struct default_include {\n   char *fname;\t\t\t/* The name of the directory.  */\n@@ -403,8 +403,8 @@ struct directive {\n   int length;\t\t\t/* Length of name */\n   int (*func)();\t\t/* Function to handle directive */\n   char *name;\t\t\t/* Name of directive */\n-  enum node_type type;\t\t/* Code which describes which directive. */\n-  char command_reads_line;      /* One if rest of line is read by func. */\n+  enum node_type type;\t\t/* Code which describes which directive.  */\n+  char command_reads_line;      /* One if rest of line is read by func.  */\n   char traditional_comments;\t/* Nonzero: keep comments if -traditional.  */\n   char pass_thru;\t\t/* Copy preprocessed directive to output file.*/\n };\n@@ -437,9 +437,9 @@ static struct directive directive_table[] = {\n   {  -1, 0, \"\", T_UNUSED},\n };\n \f\n-/* table to tell if char can be part of a C identifier. */\n+/* table to tell if char can be part of a C identifier.  */\n U_CHAR is_idchar[256];\n-/* table to tell if char can be first char of a c identifier. */\n+/* table to tell if char can be first char of a c identifier.  */\n U_CHAR is_idstart[256];\n /* table to tell if c is horizontal space.  */\n U_CHAR is_hor_space[256];\n@@ -490,7 +490,8 @@ initialize_char_syntax (opts)\n \n \n /* Place into PFILE a quoted string representing the string SRC.\n-   Caller must reserve enough space in pfile->token_buffer. */\n+   Caller must reserve enough space in pfile->token_buffer.  */\n+\n static void\n quote_string (pfile, src)\n      cpp_reader *pfile;\n@@ -525,7 +526,7 @@ quote_string (pfile, src)\n       }\n }\n \n-/* Re-allocates PFILE->token_buffer so it will hold at least N more chars. */\n+/* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n \n void\n cpp_grow_buffer (pfile, n)\n@@ -534,7 +535,7 @@ cpp_grow_buffer (pfile, n)\n {\n   long old_written = CPP_WRITTEN (pfile);\n   pfile->token_buffer_size = n + 2 * pfile->token_buffer_size;\n-  pfile->token_buffer = (U_CHAR*)\n+  pfile->token_buffer = (U_CHAR *)\n     xrealloc(pfile->token_buffer, pfile->token_buffer_size);\n   CPP_SET_WRITTEN (pfile, old_written);\n }\n@@ -827,7 +828,7 @@ macro_cleanup (pbuf, pfile)\n      cpp_buffer *pbuf;\n      cpp_reader *pfile;\n {\n-  HASHNODE *macro = (HASHNODE*)pbuf->data;\n+  HASHNODE *macro = (HASHNODE *) pbuf->data;\n   if (macro->type == T_DISABLED)\n     macro->type = T_MACRO;\n   if (macro->type != T_MACRO || pbuf->buf != macro->value.defn->expansion)\n@@ -852,7 +853,7 @@ file_cleanup (pbuf, pfile)\n    If this is the start of a comment (followed by '*' or '/'),\n    skip to the end of the comment, and return ' '.\n    Return EOF if we reached the end of file before the end of the comment.\n-   If not the start of a comment, return '/'. */\n+   If not the start of a comment, return '/'.  */\n \n static int\n skip_comment (pfile, linep)\n@@ -894,7 +895,7 @@ skip_comment (pfile, linep)\n \t{\n \t  c = GETC ();\n \t  if (c == EOF)\n-\t    return ' '; /* Allow // to be terminated by EOF. */\n+\t    return ' '; /* Allow // to be terminated by EOF.  */\n \t  while (c == '\\\\' && PEEKC() == '\\n')\n \t    {\n \t      FORWARD(1);\n@@ -904,7 +905,7 @@ skip_comment (pfile, linep)\n \t    }\n \t  if (c == '\\n')\n \t    {\n-\t      /* Don't consider final '\\n' to be part of comment. */\n+\t      /* Don't consider final '\\n' to be part of comment.  */\n \t      FORWARD(-1);\n \t      return ' ';\n \t    }\n@@ -915,6 +916,7 @@ skip_comment (pfile, linep)\n }     \n \n /* Skip whitespace \\-newline and comments.  Does not macro-expand.  */\n+\n void\n cpp_skip_hspace (pfile)\n      cpp_reader *pfile;\n@@ -951,7 +953,7 @@ cpp_skip_hspace (pfile)\n }\n \n /* Read the rest of the current line.\n-   The line is appended to PFILE's output buffer. */\n+   The line is appended to PFILE's output buffer.  */\n \n static void\n copy_rest_of_line (pfile)\n@@ -1036,7 +1038,7 @@ handle_directive (pfile)\n       goto done_a_directive;\n     }\n \n-  /* Now find the directive name. */\n+  /* Now find the directive name.  */\n   CPP_PUTC (pfile, '#');\n   parse_name (pfile, GETC());\n   ident = pfile->token_buffer + old_written + 1;\n@@ -1114,7 +1116,7 @@ handle_directive (pfile)\n       || (kt->type == T_DEFINE\n \t  && CPP_OPTIONS (pfile)->dump_macros == dump_definitions))\n     {\n-      /* Just leave the entire #define in the output stack. */\n+      /* Just leave the entire #define in the output stack.  */\n     }\n   else if (kt->type == T_DEFINE\n \t   && CPP_OPTIONS (pfile)->dump_macros == dump_names)\n@@ -1170,7 +1172,7 @@ pass_thru_directive (buf, limit, pfile, keyword)\n    appeared.  So the arglist is just convenience data passed\n    between these two routines.  It is not kept around after\n    the current #define has been processed and entered into the\n-   hash table. */\n+   hash table.  */\n \n struct arglist {\n   struct arglist *next;\n@@ -1212,7 +1214,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n   /* Scan thru the replacement list, ignoring comments and quoted\n      strings, picking up on the macro calls.  It does a linear search\n      thru the arg list on every potential symbol.  Profiling might say\n-     that something smarter should happen. */\n+     that something smarter should happen.  */\n \n   if (limit < buf)\n     abort ();\n@@ -1228,7 +1230,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n      leading and trailing newline-marker and final null.  */\n   maxsize = (sizeof (DEFINITION)\n \t     + (limit - p) + 5);\n-  /* Occurrences of '@' get doubled, so allocate extra space for them. */\n+  /* Occurrences of '@' get doubled, so allocate extra space for them.  */\n   while (p < limit)\n     if (*p++ == '@')\n       maxsize++;\n@@ -1241,7 +1243,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n   p = buf;\n \n   /* Add one initial space escape-marker to prevent accidental\n-     token-pasting (often removed by macroexpand). */\n+     token-pasting (often removed by macroexpand).  */\n   *exp_p++ = '@';\n   *exp_p++ = ' ';\n \n@@ -1278,7 +1280,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \n       case '@':\n \t/* An '@' in a string or character constant stands for itself,\n-\t   and does not need to be escaped. */\n+\t   and does not need to be escaped.  */\n \tif (!expected_delimiter)\n \t  *exp_p++ = c;\n \tbreak;\n@@ -1475,7 +1477,8 @@ static char rest_extension[] = \"...\";\n #define REST_EXTENSION_LENGTH\t(sizeof (rest_extension) - 1)\n \n /* Create a DEFINITION node from a #define directive.  Arguments are \n-   as for do_define. */\n+   as for do_define.  */\n+\n static MACRODEF\n create_definition (buf, limit, pfile, predefinition)\n      U_CHAR *buf, *limit;\n@@ -1506,7 +1509,7 @@ create_definition (buf, limit, pfile, predefinition)\n \n   /* Lossage will occur if identifiers or control keywords are broken\n      across lines using backslash.  This is not the right place to take\n-     care of that. */\n+     care of that.  */\n \n   if (*bp == '(') {\n     struct arglist *arg_ptrs = NULL;\n@@ -1580,7 +1583,7 @@ create_definition (buf, limit, pfile, predefinition)\n \n     ++bp;\t\t\t/* skip paren */\n     SKIP_WHITE_SPACE (bp);\n-    /* now everything from bp before limit is the definition. */\n+    /* now everything from bp before limit is the definition.  */\n     defn = collect_expansion (pfile, bp, limit, argno, arg_ptrs);\n     defn->rest_args = rest_args;\n \n@@ -1627,7 +1630,7 @@ create_definition (buf, limit, pfile, predefinition)\n \t  }\n \t}\n       }\n-    /* now everything from bp before limit is the definition. */\n+    /* now everything from bp before limit is the definition.  */\n     defn = collect_expansion (pfile, bp, limit, -1, NULL_PTR);\n     defn->args.argnames = (U_CHAR *) \"\";\n   }\n@@ -1666,7 +1669,7 @@ check_macro_name (pfile, symname, usage)\n   if (sym_length == 0)\n     cpp_error (pfile, \"invalid %s name\", usage);\n   else if (!is_idstart[*symname]) {\n-    U_CHAR *msg;\t\t\t/* what pain... */\n+    U_CHAR *msg;\t\t\t/* what pain...  */\n     msg = (U_CHAR *) alloca (sym_length + 1);\n     bcopy (symname, msg, sym_length);\n     msg[sym_length] = 0;\n@@ -1678,9 +1681,8 @@ check_macro_name (pfile, symname, usage)\n   return sym_length;\n }\n \n-/*\n- * return zero if two DEFINITIONs are isomorphic\n- */\n+/* Return zero if two DEFINITIONs are isomorphic.  */\n+\n static int\n compare_defs (d1, d2)\n      DEFINITION *d1, *d2;\n@@ -1795,7 +1797,7 @@ do_define (pfile, keyword, buf, limit)\n       /* Print the warning if it's not ok.  */\n       if (!ok)\n \t{\n-\t  U_CHAR *msg;\t\t/* what pain... */\n+\t  U_CHAR *msg;\t\t/* what pain...  */\n \n \t  /* If we are passing through #define and #undef directives, do\n \t     that for this re-definition now.  */\n@@ -1840,7 +1842,7 @@ do_define (pfile, keyword, buf, limit)\n    if stringified.\n    `use_count' is the number of times this macro arg is substituted\n    into the macro.  If the actual use count exceeds 10, \n-   the value stored is 10. */\n+   the value stored is 10.  */\n \n /* raw and expanded are relative to ARG_BASE */\n #define ARG_BASE ((pfile)->token_buffer)\n@@ -1857,9 +1859,9 @@ struct argdata {\n /* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.\n    If BUFFER != NULL, then use the LENGTH characters in BUFFER\n    as the new input buffer.\n-   Return the new buffer, or NULL on failure. */\n+   Return the new buffer, or NULL on failure.  */\n \n-cpp_buffer*\n+cpp_buffer *\n cpp_push_buffer (pfile, buffer, length)\n      cpp_reader *pfile;\n      U_CHAR *buffer;\n@@ -1884,7 +1886,7 @@ cpp_push_buffer (pfile, buffer, length)\n   return buf;\n }\n \n-cpp_buffer*\n+cpp_buffer *\n cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n@@ -1894,7 +1896,7 @@ cpp_pop_buffer (pfile)\n }\n \n /* Scan until CPP_BUFFER (PFILE) is exhausted into PFILE->token_buffer.\n-   Pop the buffer when done. */\n+   Pop the buffer when done.  */\n \n void\n cpp_scan_buffer (pfile)\n@@ -1904,7 +1906,7 @@ cpp_scan_buffer (pfile)\n   for (;;)\n     {\n       enum cpp_token token = cpp_get_token (pfile);\n-      if (token == CPP_EOF) /* Should not happen ... */\n+      if (token == CPP_EOF) /* Should not happen ...  */\n \tbreak;\n       if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n \t{\n@@ -1989,7 +1991,7 @@ adjust_position (buf, limit, linep, colp)\n     }\n }\n \n-/* Move line_base forward, updating lineno and colno. */\n+/* Move line_base forward, updating lineno and colno.  */\n \n static void\n update_position (pbuf)\n@@ -2028,9 +2030,9 @@ cpp_buf_line_and_col (pbuf, linep, colp)\n     }\n }\n \n-/* Return the cpp_buffer that corresponds to a file (not a macro). */\n+/* Return the cpp_buffer that corresponds to a file (not a macro).  */\n \n-cpp_buffer*\n+cpp_buffer *\n cpp_file_buffer (pfile)\n      cpp_reader *pfile;\n {\n@@ -2199,7 +2201,7 @@ macarg (pfile, rest_args)\n \t    goto found;\n \t  break;\n \tfound:\n-\t  /* Remove ',' or ')' from argument buffer. */\n+\t  /* Remove ',' or ')' from argument buffer.  */\n \t  CPP_ADJUST_WRITTEN (pfile, -1);\n \t  goto done;\n       default: ;\n@@ -2261,7 +2263,7 @@ timestamp (pfile)\n      cpp_reader *pfile;\n {\n   if (!pfile->timebuf) {\n-    time_t t = time ((time_t *)0);\n+    time_t t = time ((time_t *) 0);\n     pfile->timebuf = localtime (&t);\n   }\n   return pfile->timebuf;\n@@ -2420,7 +2422,7 @@ special_symbol (hp, pfile)\n \t  if (pcp_outfile && pcp_inside_if\n \t      && (hp->type == T_CONST\n \t\t  || (hp->type == T_MACRO && hp->value.defn->predefined)))\n-\t    /* Output a precondition for this macro use. */\n+\t    /* Output a precondition for this macro use.  */\n \t    fprintf (pcp_outfile, \"#define %s\\n\", hp->name);\n #endif\n \t  buf = \" 1 \";\n@@ -2535,7 +2537,7 @@ initialize_builtins (pfile)\n }\n \f\n /* Return 1 iff a token ending in C1 followed directly by a token C2\n-   could cause mis-tokenization. */\n+   could cause mis-tokenization.  */\n \n static int\n unsafe_chars (c1, c2)\n@@ -2556,7 +2558,7 @@ unsafe_chars (c1, c2)\n       goto letter;\n     case 'L':\n       if (c2 == '\\'' || c2 == '\\\"')\n-\treturn 1;   /* Could turn into L\"xxx\" or L'xxx'. */\n+\treturn 1;   /* Could turn into L\"xxx\" or L'xxx'.  */\n       goto letter;\n     letter:\n     case '_':\n@@ -2570,7 +2572,7 @@ unsafe_chars (c1, c2)\n     case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n     case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n     case 'Y': case 'Z':\n-      /* We're in the middle of either a name or a pre-processing number. */\n+      /* We're in the middle of either a name or a pre-processing number.  */\n       return (is_idchar[c2] || c2 == '.');\n     case '<': case '>': case '!': case '%': case '#': case ':':\n     case '^': case '&': case '|': case '*': case '/': case '=':\n@@ -2638,7 +2640,7 @@ macroexpand (pfile, hp)\n       /* Parse all the macro args that are supplied.  I counts them.\n \t The first NARGS args are stored in ARGS.\n \t The rest are discarded.  If rest_args is set then we assume\n-\t macarg absorbed the rest of the args. */\n+\t macarg absorbed the rest of the args.  */\n       i = 0;\n       rest_args = 0;\n       rest_args = 0;\n@@ -2746,7 +2748,7 @@ macroexpand (pfile, hp)\n \t\t  int c;\n \t\t  /* Initially need_space is -1.  Otherwise, 1 means the\n \t\t     previous character was a space, but we suppressed it;\n-\t\t     0 means the previous character was a non-space. */\n+\t\t     0 means the previous character was a non-space.  */\n \t\t  int need_space = -1;\n \t\t  i = 0;\n \t\t  arg->stringified = CPP_WRITTEN (pfile);\n@@ -2956,7 +2958,7 @@ macroexpand (pfile, hp)\n       }\n \n       /* if there is anything left of the definition\n-\t after handling the arg list, copy that in too. */\n+\t after handling the arg list, copy that in too.  */\n \n       for (i = offset; i < defn->length; i++)\n \t{\n@@ -2980,7 +2982,7 @@ macroexpand (pfile, hp)\n   push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n   CPP_BUFFER (pfile)->has_escapes = 1;\n \n-  /* Pop the space we've used in the token_buffer for argument expansion. */\n+  /* Pop the space we've used in the token_buffer for argument expansion.  */\n   CPP_SET_WRITTEN (pfile, old_written);\n     \n   /* Recursive macro use sometimes works traditionally.\n@@ -3048,7 +3050,7 @@ get_directive_token (pfile)\n       case CPP_POP:\n \t  if (! CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n \t      return token;\n-\t  /* ... else fall though ... */\n+\t  /* ... else fall though ...  */\n       case CPP_HSPACE:  case CPP_COMMENT:\n \t  CPP_SET_WRITTEN (pfile, old_written);\n \t  break;\n@@ -3064,7 +3066,7 @@ get_directive_token (pfile)\n    The input is normally in part of the output_buffer following\n    CPP_WRITTEN, and will get overwritten by output_line_command.\n    I.e. in input file specification has been popped by handle_directive.\n-   This is safe. */\n+   This is safe.  */\n \n static int\n do_include (pfile, keyword, unused1, unused2)\n@@ -3091,7 +3093,7 @@ do_include (pfile, keyword, unused1, unused2)\n   int f;\t\t\t/* file number */\n \n   int retried = 0;\t\t/* Have already tried macro\n-\t\t\t\t   expanding the include line*/\n+\t\t\t\t   expanding the include line */\n   int angle_brackets = 0;\t/* 0 for \"...\", 1 for <...> */\n   int pcf = -1;\n   char *pcfbuf;\n@@ -3133,12 +3135,12 @@ do_include (pfile, keyword, unused1, unused2)\n \t  if (CPP_OPTIONS (pfile)->first_bracket_include)\n \t    search_start = CPP_OPTIONS (pfile)->first_bracket_include;\n \t}\n-      /* If -I- was specified, don't search current dir, only spec'd ones. */\n+      /* If -I- was specified, don't search current dir, only spec'd ones.  */\n       else if (! CPP_OPTIONS (pfile)->ignore_srcdir)\n \t{\n \t  cpp_buffer *fp = CPP_BUFFER (pfile);\n \t  /* We have \"filename\".  Figure out directory this source\n-\t     file is coming from and put it on the front of the list. */\n+\t     file is coming from and put it on the front of the list.  */\n \n \t  for ( ; fp != CPP_NULL_BUFFER (pfile); fp = CPP_PREV_BUFFER (fp))\n \t    {\n@@ -3379,18 +3381,18 @@ do_include (pfile, keyword, unused1, unused2)\n     /* Check to see if this include file is a once-only include file.\n        If so, give up.  */\n \n-    struct file_name_list* ptr;\n+    struct file_name_list *ptr;\n \n     for (ptr = pfile->dont_repeat_files; ptr; ptr = ptr->next) {\n       if (!strcmp (ptr->fname, fname)) {\n \tclose (f);\n-        return 0;\t\t\t\t/* This file was once'd. */\n+        return 0;\t\t\t\t/* This file was once'd.  */\n       }\n     }\n \n     for (ptr = pfile->all_include_files; ptr; ptr = ptr->next) {\n       if (!strcmp (ptr->fname, fname))\n-        break;\t\t\t\t/* This file was included before. */\n+        break;\t\t\t\t/* This file was included before.  */\n     }\n \n     if (ptr == 0) {\n@@ -3425,7 +3427,7 @@ do_include (pfile, keyword, unused1, unused2)\n \n     /* Actually process the file.  */\n \n-    /* Record file on \"seen\" list for #import. */\n+    /* Record file on \"seen\" list for #import.  */\n     add_import (pfile, f, fname);\n \n     pcftry = (char *) alloca (strlen (fname) + 30);\n@@ -3546,6 +3548,7 @@ is_system_include (pfile, filename)\n  * If HASH is >= 0, it is the precomputed hash code.\n  * Otherwise, compute the hash code.\n  */\n+\n static ASSERTION_HASHNODE *\n assertion_install (pfile, name, len, hash)\n      cpp_reader *pfile;\n@@ -3623,8 +3626,8 @@ delete_assertion (hp)\n       tail = next;\n     }\n \n-  /* make sure that the bucket chain header that\n-     the deleted guy was on points to the right thing afterwards. */\n+  /* Make sure that the bucket chain header that\n+     the deleted guy was on points to the right thing afterwards.  */\n   if (hp == *hp->bucket_hdr)\n     *hp->bucket_hdr = hp->next;\n \n@@ -3637,7 +3640,7 @@ delete_assertion (hp)\n    The value returned in the end of the string written to RESULT,\n    or NULL on error.  */\n \n-static U_CHAR*\n+static U_CHAR *\n convert_string (pfile, result, in, limit, handle_escapes)\n      cpp_reader *pfile;\n      register U_CHAR *result, *in, *limit;\n@@ -3940,7 +3943,7 @@ do_ident (pfile, keyword, buf, limit)\n   if (CPP_PEDANTIC (pfile) && !CPP_BUFFER (pfile)->system_header_p)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#ident'\");\n \n-  /* Leave rest of line to be read by later calls to cpp_get_token. */\n+  /* Leave rest of line to be read by later calls to cpp_get_token.  */\n \n   return 0;\n }\n@@ -4102,6 +4105,7 @@ do_elif (pfile, keyword, buf, limit)\n  * evaluate a #if expression in BUF, of length LENGTH,\n  * then parse the result as a C expression and return the value as an int.\n  */\n+\n static HOST_WIDE_INT\n eval_if_expression (pfile, buf, length)\n      cpp_reader *pfile;\n@@ -4138,7 +4142,7 @@ do_xifdef (pfile, keyword, unused1, unused2)\n {\n   int skip;\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n-  U_CHAR* ident;\n+  U_CHAR *ident;\n   int ident_length;\n   enum cpp_token token;\n   int start_of_file = 0;\n@@ -4246,6 +4250,7 @@ conditional_skip (pfile, skip, type, control_macro)\n  * leaves input ptr at the sharp sign found.\n  * If ANY is nonzero, return at next directive of any sort.\n  */\n+\n static void\n skip_if_group (pfile, any)\n      cpp_reader *pfile;\n@@ -4363,7 +4368,7 @@ skip_if_group (pfile, any)\n \t}\n       c = GETC ();\n     }\n-  /* We're in the middle of a line.  Skip the rest of it. */\n+  /* We're in the middle of a line.  Skip the rest of it.  */\n   for (;;) {\n     switch (c)\n       {\n@@ -4542,9 +4547,8 @@ validate_else (pfile, directive)\n }\n \n /* Get the next token, and add it to the text in pfile->token_buffer.\n-   Return the kind of token we got. */\n+   Return the kind of token we got.  */\n   \n-\n enum cpp_token\n cpp_get_token (pfile)\n      cpp_reader *pfile;\n@@ -4577,7 +4581,7 @@ cpp_get_token (pfile)\n \t    {\n \t      /* We're about to return from an #include file.\n \t\t Emit #line information now (as part of the CPP_POP) result.\n-\t\t But the #line refers to the file we will pop to. */\n+\t\t But the #line refers to the file we will pop to.  */\n \t      cpp_buffer *cur_buffer = CPP_BUFFER (pfile);\n \t      CPP_BUFFER (pfile) = next_buf;\n \t      pfile->input_stack_listing_current = 0;\n@@ -4612,7 +4616,7 @@ cpp_get_token (pfile)\n \t\t\t\t   \"unterminated comment\");\n \t      goto handle_eof;\n \t    }\n-\t  c = '/';  /* Initial letter of comment. */\n+\t  c = '/';  /* Initial letter of comment.  */\n \treturn_comment:\n \t  /* Comments are equivalent to spaces.\n \t     For -traditional, a comment is equivalent to nothing.  */\n@@ -4637,7 +4641,7 @@ cpp_get_token (pfile)\n \t    {\n #if 0\n \t      /* This may not work if cpp_get_token is called recursively,\n-\t\t since many places look for horizontal space. */\n+\t\t since many places look for horizontal space.  */\n \t      if (newlines)\n \t\t{\n \t\t  /* Copy the newlines into the output buffer, in order to\n@@ -4678,7 +4682,7 @@ cpp_get_token (pfile)\n \n \t      /* OK, now bring us back to the state we were in before we entered\n \t\t this branch.  We need #line b/c the newline for the pragma\n-\t\t could fuck things up. */\n+\t\t could fuck things up.  */\n \t      output_line_command (pfile, 0, same_file);\n \t      *(obp++) = ' ';\t/* just in case, if comments are copied thru */\n \t      *(obp++) = '/';\n@@ -4776,7 +4780,7 @@ cpp_get_token (pfile)\n \t\t  cc = GETC();\n \t\t  if (cc == '\\n')\n \t\t    {\n-\t\t      /* Backslash newline is replaced by nothing at all. */\n+\t\t      /* Backslash newline is replaced by nothing at all.  */\n \t\t      CPP_ADJUST_WRITTEN (pfile, -1);\n \t\t      pfile->lineno++;\n \t\t    }\n@@ -4840,15 +4844,15 @@ cpp_get_token (pfile)\n \t      /* Chill style comment */\n \t      if (opts->put_out_comments)\n \t\tparse_set_mark (&start_mark, pfile);\n-\t      FORWARD(1);  /* Skip second '-'. */\n+\t      FORWARD(1);  /* Skip second '-'.  */\n \t      for (;;)\n \t\t{\n \t\t  c = GETC ();\n \t\t  if (c == EOF)\n \t\t    break;\n \t\t  if (c == '\\n')\n \t\t    {\n-\t\t      /* Don't consider final '\\n' to be part of comment. */\n+\t\t      /* Don't consider final '\\n' to be part of comment.  */\n \t\t      FORWARD(-1);\n \t\t      break;\n \t\t    }\n@@ -5061,7 +5065,7 @@ cpp_get_token (pfile)\n \t    if (hp->type == T_DISABLED)\n \t      {\n \t\tif (pfile->output_escapes)\n-\t\t  { /* Return \"@-IDENT\", followed by '\\0'. */\n+\t\t  { /* Return \"@-IDENT\", followed by '\\0'.  */\n \t\t    int i;\n \t\t    CPP_RESERVE (pfile, 3);\n \t\t    ident = pfile->token_buffer + before_name_written;\n@@ -5107,7 +5111,7 @@ cpp_get_token (pfile)\n \t      if (!is_macro_call)\n \t\treturn CPP_NAME;\n \t    }\n-\t    /* This is now known to be a macro call. */\n+\t    /* This is now known to be a macro call.  */\n \n \t    /* it might not actually be a macro.  */\n \t    if (hp->type != T_MACRO) {\n@@ -5131,7 +5135,7 @@ cpp_get_token (pfile)\n \t    /* An extra \"@ \" is added to the end of a macro expansion\n \t       to prevent accidental token pasting.  We prefer to avoid\n \t       unneeded extra spaces (for the sake of cpp-using tools like\n-\t       imake).  Here we remove the space if it is safe to do so. */\n+\t       imake).  Here we remove the space if it is safe to do so.  */\n \t    if (pfile->buffer->rlimit - pfile->buffer->cur >= 3\n \t\t&& pfile->buffer->rlimit[-2] == '@'\n \t\t&& pfile->buffer->rlimit[-1] == ' ')\n@@ -5188,7 +5192,8 @@ cpp_get_token (pfile)\n     }\n }\n \n-/* Like cpp_get_token, but skip spaces and comments. */\n+/* Like cpp_get_token, but skip spaces and comments.  */\n+\n enum cpp_token\n cpp_get_non_space_token (pfile)\n      cpp_reader *pfile;\n@@ -5204,7 +5209,7 @@ cpp_get_non_space_token (pfile)\n     }\n }\n \n-/* Parse an identifier starting with C. */\n+/* Parse an identifier starting with C.  */\n \n int\n parse_name (pfile, c)\n@@ -5223,7 +5228,7 @@ parse_name (pfile, c)\n \t  break;\n       }\n \n-      CPP_RESERVE(pfile, 2); /* One more for final NUL. */\n+      CPP_RESERVE(pfile, 2); /* One more for final NUL.  */\n       CPP_PUTC_Q (pfile, c);\n       c = GETC();\n       if (c == EOF)\n@@ -5368,7 +5373,8 @@ read_filename_string (ch, f)\n   return alloc;\n }\n \n-/* This structure holds a linked list of file name maps, one per directory. */\n+/* This structure holds a linked list of file name maps, one per directory.  */\n+\n struct file_name_map_list\n {\n   struct file_name_map_list *map_list_next;\n@@ -5591,7 +5597,7 @@ finclude (pfile, f, fname, system_header_p, dirptr)\n   } else {\n     /* Cannot count its file size before reading.\n        First read the entire file into heap and\n-       copy them into buffer on stack. */\n+       copy them into buffer on stack.  */\n \n     int bsize = 2000;\n \n@@ -5783,7 +5789,7 @@ cpp_start_read (pfile, fname)\n   /* Now handle the command line options.  */\n \n   /* Do -U's, -D's and -A's in the order they were seen.  */\n-  /* First reverse the list. */\n+  /* First reverse the list.  */\n   opts->pending = nreverse_pending (opts->pending);\n \n   for (pend = opts->pending;  pend;  pend = pend->next)\n@@ -5811,8 +5817,8 @@ cpp_start_read (pfile, fname)\n \n   opts->done_initializing = 1;\n \n-  { /* read the appropriate environment variable and if it exists\n-       replace include_defaults with the listed path. */\n+  { /* Read the appropriate environment variable and if it exists\n+       replace include_defaults with the listed path.  */\n     char *epath = 0;\n     switch ((opts->objc << 1) + opts->cplusplus)\n       {\n@@ -6139,7 +6145,7 @@ cpp_start_read (pfile, fname)\n     }\n   pfile->no_record_file--;\n \n-  /* Free the pending list. */\n+  /* Free the pending list.  */\n   for (pend = opts->pending;  pend; )\n     {\n       struct cpp_pending *next = pend->next;\n@@ -6173,7 +6179,7 @@ cpp_reader_init (pfile)\n   pfile->get_token = cpp_get_token;\n \n   pfile->token_buffer_size = 200;\n-  pfile->token_buffer = (U_CHAR*)xmalloc (pfile->token_buffer_size);\n+  pfile->token_buffer = (U_CHAR *) xmalloc (pfile->token_buffer_size);\n   CPP_SET_WRITTEN (pfile, 0);\n \n   pfile->system_include_depth = 0;\n@@ -6207,7 +6213,7 @@ push_pending (pfile, cmd, arg)\n      char *arg;\n {\n   struct cpp_pending *pend\n-    = (struct cpp_pending*)xmalloc (sizeof (struct cpp_pending));\n+    = (struct cpp_pending *) xmalloc (sizeof (struct cpp_pending));\n   pend->cmd = cmd;\n   pend->arg = arg;\n   pend->next = CPP_OPTIONS (pfile)->pending;\n@@ -6736,7 +6742,7 @@ cpp_finish (pfile)\n }\n \n /* Free resources used by PFILE.\n-   This is the cpp_reader 'finalizer' or 'destructor' (in C++ terminology). */\n+   This is the cpp_reader 'finalizer' or 'destructor' (in C++ terminology).  */\n \n void\n cpp_cleanup (pfile)\n@@ -7209,7 +7215,8 @@ savestring (input)\n   return output;\n }\n \f\n-/* Initialize PMARK to remember the current position of PFILE. */\n+/* Initialize PMARK to remember the current position of PFILE.  */\n+\n void\n parse_set_mark (pmark, pfile)\n      struct parse_marker *pmark;\n@@ -7222,7 +7229,8 @@ parse_set_mark (pmark, pfile)\n   pmark->position = pbuf->cur - pbuf->buf;\n }\n \n-/* Cleanup PMARK - we no longer need it. */\n+/* Cleanup PMARK - we no longer need it.  */\n+\n void\n parse_clear_mark (pmark)\n      struct parse_marker *pmark;\n@@ -7235,7 +7243,7 @@ parse_clear_mark (pmark)\n   *pp = pmark->next;\n }\n \n-/* Backup the current position of PFILE to that saved in PMARK. */\n+/* Backup the current position of PFILE to that saved in PMARK.  */\n \n void\n parse_goto_mark (pmark, pfile)\n@@ -7249,7 +7257,7 @@ parse_goto_mark (pmark, pfile)\n }\n \n /* Reset PMARK to point to the current position of PFILE.  (Same\n-   as parse_clear_mark (PMARK), parse_set_mark (PMARK, PFILE) but faster. */\n+   as parse_clear_mark (PMARK), parse_set_mark (PMARK, PFILE) but faster.  */\n \n void\n parse_move_mark (pmark, pfile)\n@@ -7427,7 +7435,7 @@ cpp_pedwarn_with_file_and_line (pfile, file, line, msg, arg1, arg2, arg3)\n \t       msg, arg1, arg2, arg3);\n }\n \n-/* This defines \"errno\" properly for VMS, and gives us EACCES. */\n+/* This defines \"errno\" properly for VMS, and gives us EACCES.  */\n #include <errno.h>\n #ifndef errno\n extern int errno;\n@@ -7448,9 +7456,8 @@ char *strerror ();\n char *strerror (int,...);\n #endif\n \n-/*\n- * my_strerror - return the descriptive text associated with an `errno' code.\n- */\n+/* my_strerror - return the descriptive text associated with an\n+   `errno' code.  */\n \n char *\n my_strerror (errnum)"}, {"sha": "aa3e327e0e0e35f9eaec657efe5a6a49f2172217", "filename": "gcc/cpplib.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -76,8 +76,8 @@ enum cpp_token {\n #endif\n #endif /* !PARAMS */\n \n-typedef enum cpp_token (*parse_underflow_t) PARAMS((cpp_reader*));\n-typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader*));\n+typedef enum cpp_token (*parse_underflow_t) PARAMS((cpp_reader *));\n+typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader *));\n \n /* A parse_marker indicates a previous position,\n    which we can backtrack to. */\n@@ -88,18 +88,18 @@ struct parse_marker {\n   int position;\n };\n \n-extern void parse_set_mark PARAMS ((struct parse_marker*, cpp_reader*));\n-extern void parse_clear_mark PARAMS ((struct parse_marker*));\n-extern void parse_goto_mark PARAMS((struct parse_marker*, cpp_reader*));\n-extern void parse_move_mark PARAMS((struct parse_marker*, cpp_reader*));\n+extern void parse_set_mark PARAMS ((struct parse_marker *, cpp_reader *));\n+extern void parse_clear_mark PARAMS ((struct parse_marker *));\n+extern void parse_goto_mark PARAMS((struct parse_marker *, cpp_reader *));\n+extern void parse_move_mark PARAMS((struct parse_marker *, cpp_reader *));\n \n-extern int cpp_handle_options PARAMS ((cpp_reader*, int, char**));\n-extern enum cpp_token cpp_get_token PARAMS ((struct parse_marker*));\n-extern void cpp_skip_hspace PARAMS((cpp_reader*));\n+extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n+extern enum cpp_token cpp_get_token PARAMS ((struct parse_marker *));\n+extern void cpp_skip_hspace PARAMS((cpp_reader *));\n extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n \n /* This frees resources used by PFILE. */\n-extern void cpp_cleanup PARAMS ((cpp_reader* PFILE));\n+extern void cpp_cleanup PARAMS ((cpp_reader *PFILE));\n \n /* Maintain and search list of included files, for #import.  */\n \n@@ -304,7 +304,7 @@ struct cpp_reader {\n #define CPP_ADJUST_WRITTEN(PFILE,DELTA) ((PFILE)->limit += (DELTA))\n #define CPP_SET_WRITTEN(PFILE,N) ((PFILE)->limit = (PFILE)->token_buffer + (N))\n \n-#define CPP_OPTIONS(PFILE) ((cpp_options*)(PFILE)->data)\n+#define CPP_OPTIONS(PFILE) ((cpp_options *) (PFILE)->data)\n \n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n #define CPP_PREV_BUFFER(BUFFER) ((BUFFER)+1)\n@@ -631,9 +631,9 @@ struct if_stack {\n };\n typedef struct if_stack IF_STACK_FRAME;\n \n-extern void cpp_buf_line_and_col PARAMS((cpp_buffer*, long*, long*));\n-extern cpp_buffer* cpp_file_buffer PARAMS((cpp_reader*));\n-extern void cpp_define PARAMS ((cpp_reader*, unsigned char*));\n+extern void cpp_buf_line_and_col PARAMS((cpp_buffer *, long *, long *));\n+extern cpp_buffer* cpp_file_buffer PARAMS((cpp_reader *));\n+extern void cpp_define PARAMS ((cpp_reader*, unsigned char *));\n \n extern void cpp_error ();\n extern void cpp_warning ();\n@@ -646,13 +646,13 @@ extern void cpp_error_from_errno ();\n extern void cpp_perror_with_name ();\n extern void cpp_pfatal_with_name ();\n \n-extern void cpp_grow_buffer PARAMS ((cpp_reader*, long));\n-extern int cpp_parse_escape PARAMS ((cpp_reader*, char**));\n-extern cpp_buffer* cpp_push_buffer PARAMS ((cpp_reader *,\n-\t\t\t\t\t    unsigned char*, long));\n-extern cpp_buffer* cpp_pop_buffer PARAMS ((cpp_reader *));\n+extern void cpp_grow_buffer PARAMS ((cpp_reader *, long));\n+extern int cpp_parse_escape PARAMS ((cpp_reader *, char **));\n+extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n+\t\t\t\t\t    unsigned char *, long));\n+extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n \n-extern cpp_hashnode* cpp_lookup PARAMS ((cpp_reader*, const unsigned char*,\n+extern cpp_hashnode *cpp_lookup PARAMS ((cpp_reader *, const unsigned char *,\n \t\t\t\t\t int, int));\n \n #ifdef __cplusplus"}, {"sha": "4f8d89ce3e0ec46dad6fb65a2051fe46f92dd6a1", "filename": "gcc/cppmain.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -53,7 +53,7 @@ main (argc, argv)\n {\n   char *p;\n   int i;\n-  int argi = 1;  /* Next argument to handle. */\n+  int argi = 1;  /* Next argument to handle.  */\n   struct cpp_options *opts = &options;\n \n   p = argv[0] + strlen (argv[0]);"}, {"sha": "ce5ef3293ec31a3d5954c7b0a21ae72a89db2e9e", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -123,6 +123,7 @@ __do_global_dtors_aux ()\n }\n \n /* Stick a call to __do_global_dtors_aux into the .fini section.  */\n+\n static void\n fini_dummy ()\n {\n@@ -142,6 +143,7 @@ fini_dummy ()\n    function.  It is externally callable so that __main can invoke it when\n    INVOKE__main is defined.  This has the additional effect of forcing cc1\n    to switch to the .text section.  */\n+\n static void __do_global_ctors_aux ();\n void __do_global_ctors ()\n {\n@@ -161,7 +163,7 @@ asm (INIT_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n    crti.o may do something, such as bump the stack, which we have to \n    undo before we reach the function prologue code for __do_global_ctors \n    (directly below).  For such systems, define the macro INIT_SECTION_PREAMBLE\n-   to expand into the code needed to undo the actions of the crti.o file. */\n+   to expand into the code needed to undo the actions of the crti.o file.  */\n \n #ifdef INIT_SECTION_PREAMBLE\n   INIT_SECTION_PREAMBLE;\n@@ -235,6 +237,7 @@ __do_global_ctors_aux ()\n }\n \n /* Stick a call to __do_global_ctors_aux into the .init section.  */\n+\n static void\n init_dummy ()\n {\n@@ -248,7 +251,7 @@ init_dummy ()\n /* This is a kludge. The i386 Linux dynamic linker needs ___brk_addr,\n    __environ and atexit (). We have to make sure they are in the .dynsym\n    section. We accomplish it by making a dummy call here. This\n-   code is never reached. */\n+   code is never reached.  */\n  \n #if defined(__linux__) && defined(__PIC__) && defined(__i386__)\n   {\n@@ -282,7 +285,7 @@ init_dummy ()\n    other libraries, etc.  That's because those other initializations may\n    include setup operations for very primitive things (e.g. initializing\n    the state of the floating-point coprocessor, etc.) which should be done\n-   before we start to execute any of the user's code. */\n+   before we start to execute any of the user's code.  */\n \n static void\n __do_global_ctors_aux ()\t/* prologue goes in .text section */"}, {"sha": "e2baf7db970ef42de2291628da848e2960fd17b6", "filename": "gcc/cse.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -534,7 +534,7 @@ static int constant_pool_entries_cost;\n \n struct write_data\n {\n-  int sp : 1;\t\t\t/* Invalidate stack pointer. */\n+  int sp : 1;\t\t\t/* Invalidate stack pointer.  */\n   int var : 1;\t\t\t/* Invalidate variable addresses.  */\n   int nonscalar : 1;\t\t/* Invalidate all but scalar variables.  */\n   int all : 1;\t\t\t/* Invalidate all memory refs.  */\n@@ -559,7 +559,7 @@ struct cse_basic_block_data {\n   int path_size;\n   /* Current branch path, indicating which branches will be taken.  */\n   struct branch_path {\n-    /* The branch insn. */\n+    /* The branch insn.  */\n     rtx branch;\n     /* Whether it should be taken or not.  AROUND is the same as taken\n        except that it is used when the destination label is not preceded\n@@ -1466,7 +1466,7 @@ merge_equiv_classes (class1, class2)\n \n       /* Remove old entry, make a new one in CLASS1's class.\n \t Don't do this for invalid entries as we cannot find their\n-\t hash code (it also isn't necessary). */\n+\t hash code (it also isn't necessary).  */\n       if (GET_CODE (exp) == REG || exp_equiv_p (exp, exp, 1, 0))\n \t{\n \t  hash_arg_in_memory = 0;\n@@ -1886,7 +1886,7 @@ canon_hash (x, mode)\n \t/* On some machines, we can't record any non-fixed hard register,\n \t   because extending its life will cause reload problems.  We\n \t   consider ap, fp, and sp to be fixed for this purpose.\n-\t   On all machines, we can't record any global registers. */\n+\t   On all machines, we can't record any global registers.  */\n \n \tif (regno < FIRST_PSEUDO_REGISTER\n \t    && (global_regs[regno]\n@@ -3179,7 +3179,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n     }\n \n   /* We can do some operations on integer CONST_DOUBLEs.  Also allow\n-     for a DImode operation on a CONST_INT. */\n+     for a DImode operation on a CONST_INT.  */\n   else if (GET_MODE (op) == VOIDmode && width <= HOST_BITS_PER_INT * 2\n \t   && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n     {\n@@ -3525,7 +3525,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  neg_double (l2, h2, &lv, &hv);\n \t  l2 = lv, h2 = hv;\n \n-\t  /* .. fall through ... */\n+\t  /* .. fall through ...  */\n \n \tcase PLUS:\n \t  add_double (l1, h1, l2, h2, &lv, &hv);\n@@ -3962,7 +3962,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && (arg1 = exact_log2 (INTVAL (op1))) > 0)\n \t    return gen_rtx (LSHIFTRT, mode, op0, GEN_INT (arg1));\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \n \tcase DIV:\n \t  if (op1 == CONST1_RTX (mode))\n@@ -4008,7 +4008,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && exact_log2 (INTVAL (op1)) > 0)\n \t    return gen_rtx (AND, mode, op0, GEN_INT (INTVAL (op1) - 1));\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \n \tcase MOD:\n \t  if ((op0 == const0_rtx || op1 == const1_rtx)\n@@ -4024,7 +4024,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && ! side_effects_p (op1))\n \t    return op0;\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \n \tcase ASHIFT:\n \tcase ASHIFTRT:\n@@ -5381,12 +5381,14 @@ fold_rtx (x, insn)\n \t  if (mode_arg0 == VOIDmode || GET_MODE_CLASS (mode_arg0) == MODE_CC)\n \t    break;\n \n-\t  /* If we do not now have two constants being compared, see if we\n-\t     can nevertheless deduce some things about the comparison.  */\n+\t  /* If we do not now have two constants being compared, see\n+\t     if we can nevertheless deduce some things about the\n+\t     comparison.  */\n \t  if (const_arg0 == 0 || const_arg1 == 0)\n \t    {\n-\t      /* Is FOLDED_ARG0 frame-pointer plus a constant?  Or non-explicit\n-\t\t constant?  These aren't zero, but we don't know their sign. */\n+\t      /* Is FOLDED_ARG0 frame-pointer plus a constant?  Or\n+\t\t non-explicit constant?  These aren't zero, but we\n+\t\t don't know their sign.  */\n \t      if (const_arg1 == const0_rtx\n \t\t  && (NONZERO_BASE_PLUS_P (folded_arg0)\n #if 0  /* Sad to say, on sysvr4, #pragma weak can make a symbol address\n@@ -5589,7 +5591,7 @@ fold_rtx (x, insn)\n \t\t\t\t NULL_RTX);\n \t    }\n \n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \n \tfrom_plus:\n \tcase SMIN:    case SMAX:      case UMIN:    case UMAX:\n@@ -6169,7 +6171,7 @@ cse_insn (insn, in_libcall_block)\n \t someplace else, so it isn't worth cse'ing (and on 80386 is unsafe)!\n \t Ensure we invalidate the destination register.  On the 80386 no\n \t other code would invalidate it since it is a fixed_reg.\n-\t We need not check the return of apply_change_group; see canon_reg. */\n+\t We need not check the return of apply_change_group; see canon_reg.  */\n \n       else if (GET_CODE (SET_SRC (x)) == CALL)\n \t{\n@@ -6741,7 +6743,7 @@ cse_insn (insn, in_libcall_block)\n          that are when they are equal cost.  Note that we can never\n          worsen an insn as the current contents will also succeed.\n \t If we find an equivalent identical to the destination, use it as best,\n-\t since this insn will probably be eliminated in that case. */\n+\t since this insn will probably be eliminated in that case.  */\n       if (src)\n \t{\n \t  if (rtx_equal_p (src, dest))\n@@ -7563,7 +7565,7 @@ note_mem_written (written, writes_ptr)\n     *writes_ptr = everything;\n   else if (GET_CODE (written) == MEM)\n     {\n-      /* Pushing or popping the stack invalidates just the stack pointer. */\n+      /* Pushing or popping the stack invalidates just the stack pointer.  */\n       rtx addr = XEXP (written, 0);\n       if ((GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n \t   || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n@@ -7995,7 +7997,8 @@ cse_set_around_loop (x, insn, loop_start)\n   if (writes_memory.var)\n     invalidate_memory (&writes_memory);\n \n-  /* See comment on similar code in cse_insn for explanation of these tests. */\n+  /* See comment on similar code in cse_insn for explanation of these\n+     tests.  */\n   if (GET_CODE (SET_DEST (x)) == REG || GET_CODE (SET_DEST (x)) == SUBREG\n       || (GET_CODE (SET_DEST (x)) == MEM && ! writes_memory.all\n \t  && ! cse_rtx_addr_varies_p (SET_DEST (x))))"}, {"sha": "158160b7b9ebbd04361a2de1b64a566ab4cc87fc", "filename": "gcc/dbxout.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -571,7 +571,7 @@ dbxout_source_line (file, filename, lineno)\n \n /* At the end of compilation, finish writing the symbol table.\n    Unless you define DBX_OUTPUT_MAIN_SOURCE_FILE_END, the default is\n-   to do nothing. */\n+   to do nothing.  */\n \n void\n dbxout_finish (file, filename)\n@@ -873,7 +873,7 @@ dbxout_type_methods (type)\n \t\t      /* Get past const and volatile qualifiers.  */\n \t\t      while (*method_name == 'C' || *method_name == 'V')\n \t\t\tmethod_name++;\n-\t\t      /* Skip digits for length of type_encoding. */\n+\t\t      /* Skip digits for length of type_encoding.  */\n \t\t      while (*method_name == *length_ptr && *length_ptr)\n \t\t\t  length_ptr++, method_name++;\n \t\t      if (! strncmp (method_name,\n@@ -890,7 +890,7 @@ dbxout_type_methods (type)\n \t\t  char *length_ptr = formatted_type_identifier_length;\n \t\t  while (*ctor_name == 'C' || *ctor_name == 'V')\n \t\t    ctor_name++;\n-\t\t  /* Skip digits for length of type_encoding. */\n+\t\t  /* Skip digits for length of type_encoding.  */\n \t\t  while (*ctor_name == *length_ptr && *length_ptr)\n \t\t      length_ptr++, ctor_name++;\n \t\t  if (!strncmp (IDENTIFIER_POINTER (type_encoding), ctor_name,\n@@ -925,7 +925,7 @@ dbxout_type_methods (type)\n \n /* Emit a \"range\" type specification, which has the form:\n    \"r<index type>;<lower bound>;<upper bound>;\".\n-   TYPE is an INTEGER_TYPE. */\n+   TYPE is an INTEGER_TYPE.  */\n \n static void\n dbxout_range_type (type)\n@@ -942,7 +942,7 @@ dbxout_range_type (type)\n \t were defined to be sub-ranges of int.  Unfortunately, this\n \t does not allow us to distinguish true sub-ranges from integer\n \t types.  So, instead we define integer (non-sub-range) types as\n-\t sub-ranges of themselves. */\n+\t sub-ranges of themselves.  */\n       dbxout_type_index (type);\n     }\n   if (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST)\n@@ -1222,7 +1222,7 @@ dbxout_type (type, full, show_arg_types)\n \t  fprintf (asmfile, \"@s%d;\",\n \t\t   BITS_PER_UNIT * int_size_in_bytes (type));\n \t  /* Check if a bitstring type, which in Chill is\n-\t     different from a [power]set. */\n+\t     different from a [power]set.  */\n \t  if (TYPE_STRING_FLAG (type))\n \t    fprintf (asmfile, \"@S;\");\n \t}\n@@ -1237,7 +1237,7 @@ dbxout_type (type, full, show_arg_types)\n \t followed by a reference to the target-type.\n \t ar1;0;N;M for a C array of type M and size N+1.  */\n       /* Check if a character string type, which in Chill is\n-\t different from an array of characters. */\n+\t different from an array of characters.  */\n       if (TYPE_STRING_FLAG (type) && use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;"}, {"sha": "65115c0c6422fbf5c701692ae9a32608e569ee4d", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -163,7 +163,7 @@ struct filename_entry {\n \n typedef struct filename_entry filename_entry;\n \n-/* Pointer to an array of elements, each one having the structure above. */\n+/* Pointer to an array of elements, each one having the structure above.  */\n \n static filename_entry *filename_table;\n \n@@ -202,7 +202,7 @@ static char *last_filename;\n \n static unsigned next_block_number = 2;\n \n-/* Counter to generate unique names for DIEs. */\n+/* Counter to generate unique names for DIEs.  */\n \n static unsigned next_unused_dienum = 1;\n \n@@ -1736,7 +1736,7 @@ output_bound_representation (bound, dim_num, u_or_l)\n \n       case NOP_EXPR:\n \tbound = TREE_OPERAND (bound, 0);\n-\t/* ... fall thru... */\n+\t/* ... fall thru...  */\n \n       case SAVE_EXPR:\n \t{\n@@ -2081,8 +2081,7 @@ location_attribute (rtl)\n    object\" which will be given in the AT_byte_size attribute for this\n    bit-field.  (See the `byte_size_attribute' function below.)  It is\n    also used when calculating the value of the AT_bit_offset attribute.\n-   (See the `bit_offset_attribute' function below.)\n-*/\n+   (See the `bit_offset_attribute' function below.)  */\n \n static void\n data_member_location_attribute (decl)\n@@ -2462,7 +2461,7 @@ subscript_data_attribute (type)\n \t  if (! type_is_fundamental (domain))\n \t    abort ();\n \n-\t  /* Output the representation format byte for this dimension. */\n+\t  /* Output the representation format byte for this dimension.  */\n \n \t  ASM_OUTPUT_DWARF_FMT_BYTE (asm_out_file,\n \t\t\t\t  FMT_CODE (1,\n@@ -3133,6 +3132,7 @@ output_set_type_die (arg)\n \n #if 0\n /* Implement this when there is a GNU FORTRAN or GNU Ada front end.  */\n+\n static void\n output_entry_point_die (arg)\n      register void *arg;\n@@ -3475,7 +3475,7 @@ output_member_die (arg)\n   member_attribute (DECL_CONTEXT (decl));\n   type_attribute (member_declared_type (decl),\n \t\t  TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n-  if (DECL_BIT_FIELD_TYPE (decl))\t/* If this is a bit field... */\n+  if (DECL_BIT_FIELD_TYPE (decl))\t/* If this is a bit field...  */\n     {\n       byte_size_attribute (decl);\n       bit_size_attribute (decl);\n@@ -3488,9 +3488,9 @@ output_member_die (arg)\n /* Don't generate either pointer_type DIEs or reference_type DIEs.  Use\n    modified types instead.\n \n-   We keep this code here just in case these types of DIEs may be needed\n-   to represent certain things in other languages (e.g. Pascal) someday.\n-*/\n+   We keep this code here just in case these types of DIEs may be\n+   needed to represent certain things in other languages (e.g. Pascal)\n+   someday.  */\n \n static void\n output_pointer_type_die (arg)\n@@ -3834,11 +3834,11 @@ end_sibling_chain ()\n    parameters as specified in some function type specification (except\n    for those which appear as part of a function *definition*).\n \n-   Note that we must be careful here to output all of the parameter DIEs\n-   *before* we output any DIEs needed to represent the types of the formal\n-   parameters.  This keeps svr4 SDB happy because it (incorrectly) thinks\n-   that the first non-parameter DIE it sees ends the formal parameter list.\n-*/\n+   Note that we must be careful here to output all of the parameter\n+   DIEs *before* we output any DIEs needed to represent the types of\n+   the formal parameters.  This keeps svr4 SDB happy because it\n+   (incorrectly) thinks that the first non-parameter DIE it sees ends\n+   the formal parameter list.  */\n \n static void\n output_formal_types (function_or_method_type)\n@@ -3983,7 +3983,7 @@ type_ok_for_scope (type, scope)\n    Note that we have to process the list in beginning-to-end order,\n    because the call made here to output_type may cause yet more types\n    to be added to the end of the list, and we may have to output some\n-   of them too. */\n+   of them too.  */\n \n static void\n output_pending_types_for_scope (containing_scope)\n@@ -4611,7 +4611,7 @@ output_decl (decl, containing_scope)\n \n \t    if (fn_arg_types)\n \t      {\n-\t      /* this is the prototyped case, check for ... */\n+\t      /* this is the prototyped case, check for ...  */\n \t      if (TREE_VALUE (tree_last (fn_arg_types)) != void_type_node)\n \t        output_die (output_unspecified_parameters_die, decl);\n               }\n@@ -5592,7 +5592,7 @@ dwarfout_finish ()\n      (or blame).  I didn't think of this scheme.  I just conformed to it.\n   */\n \n-  output_die (output_padded_null_die, (void *)0);\n+  output_die (output_padded_null_die, (void *) 0);\n   dienum_pop ();\n \n   sprintf (label, DIE_BEGIN_LABEL_FMT, NEXT_DIE_NUM);"}, {"sha": "85ba0adce6eaf9cb5a47ef531c11953c137cc5c2", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -73,9 +73,9 @@ char *opcode_name[] =\n \n /* Commonly used modes.  */\n \n-enum machine_mode byte_mode;\t/* Mode whose width is BITS_PER_UNIT. */\n-enum machine_mode word_mode;\t/* Mode whose width is BITS_PER_WORD. */\n-enum machine_mode ptr_mode;\t/* Mode whose width is POINTER_SIZE. */\n+enum machine_mode byte_mode;\t/* Mode whose width is BITS_PER_UNIT.  */\n+enum machine_mode word_mode;\t/* Mode whose width is BITS_PER_WORD.  */\n+enum machine_mode ptr_mode;\t/* Mode whose width is POINTER_SIZE.  */\n \n /* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n    After rtl generation, it is 1 plus the largest register number used.  */\n@@ -249,7 +249,7 @@ struct sequence_stack *sequence_stack;\n static struct sequence_stack *sequence_element_free_list;\n static rtx sequence_result[SEQUENCE_RESULT_SIZE];\n \n-/* During RTL generation, we also keep a list of free INSN rtl codes. */\n+/* During RTL generation, we also keep a list of free INSN rtl codes.  */\n static rtx free_insn;\n \n extern int rtx_equal_function_value_matters;\n@@ -753,7 +753,7 @@ gen_lowpart_common (mode, x)\n \tlow = CONST_DOUBLE_LOW (x), high = CONST_DOUBLE_HIGH (x);\n \n       /* REAL_VALUE_TARGET_DOUBLE takes the addressing order of the\n-\t target machine. */\n+\t target machine.  */\n       if (WORDS_BIG_ENDIAN)\n \ti[0] = high, i[1] = low;\n       else\n@@ -975,7 +975,7 @@ gen_highpart (mode, x)\n        */\n \n       if (REGNO (x) < FIRST_PSEUDO_REGISTER\n-\t  /* integrate.c can't handle parts of a return value register. */\n+\t  /* integrate.c can't handle parts of a return value register.  */\n \t  && (! REG_FUNCTION_VALUE_P (x)\n \t      || ! rtx_equal_function_value_matters)\n \t  /* We want to keep the stack, frame, and arg pointers special.  */\n@@ -1493,7 +1493,8 @@ restore_emit_status (p)\n   regno_pointer_flag_length = p->regno_pointer_flag_length;\n   regno_reg_rtx = p->regno_reg_rtx;\n \n-  /* Clear our cache of rtx expressions for start_sequence and gen_sequence. */\n+  /* Clear our cache of rtx expressions for start_sequence and\n+     gen_sequence.  */\n   sequence_element_free_list = 0;\n   for (i = 0; i < SEQUENCE_RESULT_SIZE; i++)\n     sequence_result[i] = 0;\n@@ -1560,7 +1561,7 @@ copy_rtx_if_shared (orig)\n     case PC:\n     case CC0:\n     case SCRATCH:\n-      /* SCRATCH must be shared because they represent distinct values. */\n+      /* SCRATCH must be shared because they represent distinct values.  */\n       return x;\n \n     case CONST:\n@@ -1871,7 +1872,7 @@ prev_nonnote_insn (insn)\n \n /* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;\n    or 0, if there is none.  This routine does not look inside\n-   SEQUENCEs. */\n+   SEQUENCEs.  */\n \n rtx\n next_real_insn (insn)"}, {"sha": "2518c732a6b208a85360c5a0bd76532aa6f87157", "filename": "gcc/enquire.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fenquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fenquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fenquire.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -1,5 +1,5 @@\n /* Everything you wanted to know about your machine and C compiler,\n-   but didn't know who to ask. */\n+   but didn't know who to ask.  */\n \n #ifndef VERSION\n #define VERSION \"4.3\"\n@@ -307,7 +307,7 @@\n #endif /* NO_FILE */\n #endif /* FILENAME */\n \n-/* If PASS isn't defined, then this is the first pass over this file. */\n+/* If PASS isn't defined, then this is the first pass over this file.  */\n #ifndef PASS\n #ifndef SEP\n #define PASS 1\n@@ -620,7 +620,7 @@ Procedure croak(place) int place; {\n \tfarewell(bugs+1); /* An exit isn't essential here, but avoids loops */\n }\n \n-/* This is here in case alloca.c is used, which calls this. */\n+/* This is here in case alloca.c is used, which calls this.  */\n char *xmalloc(size) unsigned size; {\n \tchar *value = (char *)malloc(size);\n \tif (value == 0) {\n@@ -806,7 +806,7 @@ Procedure i_define(desc, extra, sort, name, val, lim, req, mark)\n \t} else if (val + lim < 0) {\n \t\t/* We may not produce a constant like -1024 if the max\n \t\t   allowable value is 1023. It has then to be output as\n-\t\t   -1023-1. lim is the max allowable value. */\n+\t\t   -1023-1. lim is the max allowable value.  */\n \t\tprintf(\"#define %s%s (%ld%s%ld%s)\\n\",\n \t\t       sort, name, -lim, mark, val+lim, mark);\n \t} else {\n@@ -1090,7 +1090,7 @@ int promotions() {\n \t    eek_a_bug(\"promotions don't work properly in conditional expressions\\n\");\n \t  }\n \n-\tshowtype(\"unsigned short promotes to\", Promoted((unsigned short)0));\n+\tshowtype(\"unsigned short promotes to\", Promoted((unsigned short) 0));\n \tshowtype(\"long+unsigned gives\", sl+ui);\n \treturn 0;\n }\n@@ -1108,7 +1108,7 @@ Procedure check_defines() {\n \tusign= Signed;\n #else\n \t/* Implementations promote unsigned short differently */\n-\tusign= is_signed((unsigned short)0);\n+\tusign= is_signed((unsigned short) 0);\n #endif\n \n \tif (L) {\n@@ -1554,7 +1554,7 @@ if (V) printf (\"%s%s %s %s%s\\n\", co, \"Type size_t is\",\n \t/* Alignment constants ********************************************/\n \n #define alignment(TYPE) \\\n-\t((long)((char *)&((struct{char c; TYPE d;}*)0)->d - (char *)0))\n+\t((long)((char *)&((struct{char c; TYPE d;}*)0)->d - (char *) 0))\n \n \tVprintf(\"\\n%sALIGNMENTS%s\\n\", co, oc);\n \n@@ -2691,7 +2691,7 @@ int FPROP(bits_per_byte) int bits_per_byte; {\n \t\tmantbits=floor_log(2, (Long_double)f_radix)*f_mant_dig;\n \t\tif (mantbits == 64\n \t\t    && iexp == 15\n-\t\t    && f_max_exp+f_min_exp > 0 /* ??? f_min_exp may be wrong. */\n+\t\t    && f_max_exp+f_min_exp > 0 /* ??? f_min_exp may be wrong.  */\n \t\t    && mantbits+iexp+17 == (int)sizeof(Number)*bits_per_byte) {\n \t\t\tVprintf(\"%sArithmetic probably doesn't use a hidden bit%s\\n\", co, oc);\n \t\t\tVprintf(\"%sIt's probably 80387 or 68881 extended real%s\\n\", co, oc);"}, {"sha": "08fe69ccdae966d38f61b062aaee062549bac37b", "filename": "gcc/explow.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -815,7 +815,8 @@ round_push (size)\n   else\n     {\n       /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n-\t but we know it can't.  So add ourselves and then do TRUNC_DIV_EXPR. */\n+\t but we know it can't.  So add ourselves and then do\n+\t TRUNC_DIV_EXPR.  */\n       size = expand_binop (Pmode, add_optab, size, GEN_INT (align - 1),\n \t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n       size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size, GEN_INT (align),\n@@ -1117,7 +1118,8 @@ allocate_dynamic_stack_space (size, target, known_align)\n   if (MUST_ALIGN)\n     {\n       /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n-\t but we know it can't.  So add ourselves and then do TRUNC_DIV_EXPR. */\n+\t but we know it can't.  So add ourselves and then do\n+\t TRUNC_DIV_EXPR.  */\n       target = expand_binop (Pmode, add_optab, target,\n \t\t\t     GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n \t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);"}, {"sha": "459d284968f1f970f108a000b7078e14a1ef342a", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -1470,7 +1470,7 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n #ifdef SLOW_ZERO_EXTEND\n \t  /* Always generate an `and' if\n \t     we just zero-extended op0 and SLOW_ZERO_EXTEND, since it\n-\t     will combine fruitfully with the zero-extend. */\n+\t     will combine fruitfully with the zero-extend.  */\n \t  || tmode != mode\n #endif\n #endif\n@@ -2474,7 +2474,7 @@ invert_mod2n (x, n)\n      unsigned HOST_WIDE_INT x;\n      int n;\n {\n-  /* Solve x*y == 1 (mod 2^n), where x is odd.  Return y. */\n+  /* Solve x*y == 1 (mod 2^n), where x is odd.  Return y.  */\n \n   /* The algorithm notes that the choice y = x satisfies\n      x*y == 1 mod 2^3, since x is assumed odd.\n@@ -3909,7 +3909,7 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \n   /* For some comparisons with 1 and -1, we can convert this to \n      comparisons with zero.  This will often produce more opportunities for\n-     store-flag insns. */\n+     store-flag insns.  */\n \n   switch (code)\n     {"}, {"sha": "09eff9072b42265c851c0cff6d3baf960570ab59", "filename": "gcc/expr.c", "status": "modified", "additions": 94, "deletions": 80, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -239,7 +239,7 @@ enum insn_code movstr_optab[NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block clears.  */\n enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n \n-/* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow. */\n+/* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow.  */\n \n #ifndef SLOW_UNALIGNED_ACCESS\n #define SLOW_UNALIGNED_ACCESS STRICT_ALIGNMENT\n@@ -253,13 +253,14 @@ enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n #define OUTGOING_REGNO(IN) (IN)\n #endif\n \f\n-/* Maps used to convert modes to const, load, and store bytecodes. */\n+/* Maps used to convert modes to const, load, and store bytecodes.  */\n enum bytecode_opcode mode_to_const_map[MAX_MACHINE_MODE];\n enum bytecode_opcode mode_to_load_map[MAX_MACHINE_MODE];\n enum bytecode_opcode mode_to_store_map[MAX_MACHINE_MODE];\n \n /* Initialize maps used to convert modes to const, load, and store\n-   bytecodes. */\n+   bytecodes.  */\n+\n void\n bc_init_mode_to_opcode_maps ()\n {\n@@ -2807,7 +2808,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       dest_innermost = bc_expand_address (to);\n \n       /* Can't deduce from TYPE that we're dealing with a bitfield, so\n-\t take care of it here. */\n+\t take care of it here.  */\n \n       bc_store_memory (TREE_TYPE (to), dest_innermost);\n       return NULL;\n@@ -3375,7 +3376,7 @@ mostly_zeros_p (exp)\n \t     so the statistic will be somewhat inaccurate.\n \t     We do make a more accurate count in store_constructor itself,\n \t     so since this function is only used for nested array elements,\n-\t     this should be close enough. */\n+\t     this should be close enough.  */\n \t  if (mostly_zeros_p (TREE_VALUE (elt)))\n \t    zeros++;\n \t  elts++;\n@@ -3427,7 +3428,7 @@ store_constructor_field (target, bitsize, bitpos,\n \n /* Store the value of constructor EXP into the rtx TARGET.\n    TARGET is either a REG or a MEM.\n-   CLEARED is true if TARGET is known to have been zero'd. */\n+   CLEARED is true if TARGET is known to have been zero'd.  */\n \n static void\n store_constructor (exp, target, cleared)\n@@ -3611,7 +3612,7 @@ store_constructor (exp, target, cleared)\n \t\tzero_count += this_node_count;\n \t    }\n \t  /* Clear the entire array first if there are any missing elements,\n-\t     or if the incidence of zero elements is >= 75%. */\n+\t     or if the incidence of zero elements is >= 75%.  */\n \t  if (count < maxelt - minelt + 1\n \t      || 4 * zero_count >= 3 * count)\n \t    need_to_clear = 1;\n@@ -3658,7 +3659,7 @@ store_constructor (exp, target, cleared)\n \t      HOST_WIDE_INT lo, hi, count;\n \t      tree position;\n \n-\t      /* If the range is constant and \"small\", unroll the loop. */\n+\t      /* If the range is constant and \"small\", unroll the loop.  */\n \t      if (TREE_CODE (lo_index) == INTEGER_CST\n \t\t  && TREE_CODE (hi_index) == INTEGER_CST\n \t\t  && (lo = TREE_INT_CST_LOW (lo_index),\n@@ -3695,14 +3696,15 @@ store_constructor (exp, target, cleared)\n \t\t  if (TREE_CODE (value) == SAVE_EXPR\n \t\t      && SAVE_EXPR_RTL (value) == 0)\n \t\t    {\n-\t\t      /* Make sure value gets expanded once before the loop. */\n+\t\t      /* Make sure value gets expanded once before the\n+                         loop.  */\n \t\t      expand_expr (value, const0_rtx, VOIDmode, 0);\n \t\t      emit_queue ();\n \t\t    }\n \t\t  store_expr (lo_index, index_r, 0);\n \t\t  loop = expand_start_loop (0);\n \n-\t\t  /* Assign value to element index. */\n+\t\t  /* Assign value to element index.  */\n \t\t  position = size_binop (EXACT_DIV_EXPR, TYPE_SIZE (elttype),\n \t\t\t\t\t size_int (BITS_PER_UNIT));\n \t\t  position = size_binop (MULT_EXPR,\n@@ -3783,9 +3785,9 @@ store_constructor (exp, target, cleared)\n \t probably better to set it using memset (if available) or bzero.\n \t Also, if a large set has just a single range, it may also be\n \t better to first clear all the first clear the set (using\n-\t bzero/memset), and set the bits we want. */\n+\t bzero/memset), and set the bits we want.  */\n        \n-      /* Check for all zeros. */\n+      /* Check for all zeros.  */\n       if (elt == NULL_TREE)\n \t{\n \t  if (!cleared)\n@@ -3812,11 +3814,11 @@ store_constructor (exp, target, cleared)\n \t{\n \t  int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));\n \t  enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);\n-\t  char *bit_buffer = (char*) alloca (nbits);\n+\t  char *bit_buffer = (char *) alloca (nbits);\n \t  HOST_WIDE_INT word = 0;\n \t  int bit_pos = 0;\n \t  int ibit = 0;\n-\t  int offset = 0;  /* In bytes from beginning of set. */\n+\t  int offset = 0;  /* In bytes from beginning of set.  */\n \t  elt = get_set_constructor_bits (exp, bit_buffer, nbits);\n \t  for (;;)\n \t    {\n@@ -3834,8 +3836,9 @@ store_constructor (exp, target, cleared)\n \t\t    {\n \t\t      rtx datum = GEN_INT (word);\n \t\t      rtx to_rtx;\n-\t\t      /* The assumption here is that it is safe to use XEXP if\n-\t\t\t the set is multi-word, but not if it's single-word. */\n+\t\t      /* The assumption here is that it is safe to use\n+\t\t\t XEXP if the set is multi-word, but not if\n+\t\t\t it's single-word.  */\n \t\t      if (GET_CODE (target) == MEM)\n \t\t\t{\n \t\t\t  to_rtx = plus_constant (XEXP (target, 0), offset);\n@@ -3857,7 +3860,7 @@ store_constructor (exp, target, cleared)\n \t}\n       else if (!cleared)\n \t{\n-\t  /* Don't bother clearing storage if the set is all ones. */\n+\t  /* Don't bother clearing storage if the set is all ones.  */\n \t  if (TREE_CHAIN (elt) != NULL_TREE\n \t      || (TREE_PURPOSE (elt) == NULL_TREE\n \t\t  ? nbits != 1\n@@ -3915,7 +3918,7 @@ store_constructor (exp, target, cleared)\n #ifdef TARGET_MEM_FUNCTIONS\n \t  /* Optimization:  If startbit and endbit are\n \t     constants divisible by BITS_PER_UNIT,\n-\t     call memset instead. */\n+\t     call memset instead.  */\n \t  if (TREE_CODE (startbit) == INTEGER_CST\n \t      && TREE_CODE (endbit) == INTEGER_CST\n \t      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0\n@@ -4580,7 +4583,7 @@ safe_from_p (x, exp)\n \t  return safe_from_p (x, TREE_OPERAND (exp, 1));\n \n \tcase METHOD_CALL_EXPR:\n-\t  /* This takes a rtx argument, but shouldn't appear here. */\n+\t  /* This takes a rtx argument, but shouldn't appear here.  */\n \t  abort ();\n \t}\n \n@@ -4747,7 +4750,7 @@ expand_expr (exp, target, tmode, modifier)\n       else if ((code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n \t       && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n \t/* If the second operand has no side effects, just evaluate\n-\t   the first. */\n+\t   the first.  */\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n \t\t\t    VOIDmode, modifier);\n \n@@ -4798,7 +4801,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  return CONST0_RTX (mode);\n \t}\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case VAR_DECL:\n       /* If a static var's type was incomplete when the decl was written,\n@@ -4813,7 +4816,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  pop_obstacks ();\n \t}\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case FUNCTION_DECL:\n     case RESULT_DECL:\n@@ -5017,7 +5020,7 @@ expand_expr (exp, target, tmode, modifier)\n \n       /* If the mode of SAVE_EXPR_RTL does not match that of the expression, it\n \t must be a promoted value.  We return a SUBREG of the wanted mode,\n-\t but mark it so that we know that it was already extended. */\n+\t but mark it so that we know that it was already extended.  */\n \n       if (GET_CODE (SAVE_EXPR_RTL (exp)) == REG\n \t  && GET_MODE (SAVE_EXPR_RTL (exp)) != mode)\n@@ -5282,7 +5285,7 @@ expand_expr (exp, target, tmode, modifier)\n \t       for any array for which this case will be reached.  */\n \n \t    /* Don't forget the const or volatile flag from the array\n-\t       element. */\n+\t       element.  */\n \t    tree variant_type = build_type_variant (type,\n \t\t\t\t\t\t    TREE_READONLY (exp),\n \t\t\t\t\t\t    TREE_THIS_VOLATILE (exp));\n@@ -5811,7 +5814,8 @@ expand_expr (exp, target, tmode, modifier)\n       return target;\n \n     case PLUS_EXPR:\n-      /* We come here from MINUS_EXPR when the second operand is a constant. */\n+      /* We come here from MINUS_EXPR when the second operand is a\n+         constant.  */\n     plus_expr:\n       this_optab = add_optab;\n \n@@ -6330,7 +6334,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (temp != 0)\n \treturn temp;\n \n-      /* For foo != 0, load foo, and if it is nonzero load 1 instead. */\n+      /* For foo != 0, load foo, and if it is nonzero load 1 instead.  */\n       if (code == NE_EXPR && integer_zerop (TREE_OPERAND (exp, 1))\n \t  && original_target\n \t  && GET_CODE (original_target) == REG\n@@ -6404,7 +6408,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* Used to save a pointer to the place to put the setting of\n \t   the flag that indicates if this side of the conditional was\n \t   taken.  We backpatch the code, if we find out later that we\n-\t   have any conditional cleanups that need to be performed. */\n+\t   have any conditional cleanups that need to be performed.  */\n \trtx dest_right_flag = NULL_RTX;\n \trtx dest_left_flag = NULL_RTX;\n \n@@ -6556,7 +6560,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    else\n \t      jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here. */\n+\t    /* Allows cleanups up to here.  */\n \t    old_cleanups = cleanups_this_call;\n \t    if (binary_op && temp == 0)\n \t      /* Just touch the other operand.  */\n@@ -6602,7 +6606,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    dest_left_flag = get_last_insn ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here. */\n+\t    /* Allows cleanups up to here.  */\n \t    old_cleanups = cleanups_this_call;\n \t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    op1 = op0;\n@@ -6627,7 +6631,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    dest_left_flag = get_last_insn ();\n \t    jumpif (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here. */\n+\t    /* Allows cleanups up to here.  */\n \t    old_cleanups = cleanups_this_call;\n \t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n \t    op1 = op0;\n@@ -6647,7 +6651,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    dest_left_flag = get_last_insn ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here. */\n+\t    /* Allows cleanups up to here.  */\n \t    old_cleanups = cleanups_this_call;\n \t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    op1 = op0;\n@@ -6658,7 +6662,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    op1 = gen_label_rtx ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here. */\n+\t    /* Allows cleanups up to here.  */\n \t    old_cleanups = cleanups_this_call;\n \t    if (temp != 0)\n \t      store_expr (TREE_OPERAND (exp, 1), temp, 0);\n@@ -6667,7 +6671,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n \t    dest_left_flag = get_last_insn ();\n \n-\t    /* Handle conditional cleanups, if any. */\n+\t    /* Handle conditional cleanups, if any.  */\n \t    left_cleanups = defer_cleanups_to (old_cleanups);\n \n \t    emit_queue ();\n@@ -6682,33 +6686,33 @@ expand_expr (exp, target, tmode, modifier)\n \t    dest_right_flag = get_last_insn ();\n \t  }\n \n-\t/* Handle conditional cleanups, if any. */\n+\t/* Handle conditional cleanups, if any.  */\n \tright_cleanups = defer_cleanups_to (old_cleanups);\n \n \temit_queue ();\n \temit_label (op1);\n \tOK_DEFER_POP;\n \n-\t/* Add back in, any conditional cleanups. */\n+\t/* Add back in, any conditional cleanups.  */\n \tif (left_cleanups || right_cleanups)\n \t  {\n \t    tree new_cleanups;\n \t    tree cond;\n \t    rtx last;\n \n \t    /* Now that we know that a flag is needed, go back and add in the\n-\t       setting of the flag. */\n+\t       setting of the flag.  */\n \n-\t    /* Do the left side flag. */\n+\t    /* Do the left side flag.  */\n \t    last = get_last_insn ();\n-\t    /* Flag left cleanups as needed. */\n+\t    /* Flag left cleanups as needed.  */\n \t    emit_move_insn (flag, const1_rtx);\n \t    /* ??? deprecated, use sequences instead.  */\n \t    reorder_insns (NEXT_INSN (last), get_last_insn (), dest_left_flag);\n \n-\t    /* Do the right side flag. */\n+\t    /* Do the right side flag.  */\n \t    last = get_last_insn ();\n-\t    /* Flag left cleanups as needed. */\n+\t    /* Flag left cleanups as needed.  */\n \t    emit_move_insn (flag, const0_rtx);\n \t    /* ??? deprecated, use sequences instead.  */\n \t    reorder_insns (NEXT_INSN (last), get_last_insn (), dest_right_flag);\n@@ -6717,7 +6721,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    push_obstacks_nochange ();\n \t    resume_temporary_allocation ();\n \n-\t    /* convert flag, which is an rtx, into a tree. */\n+\t    /* convert flag, which is an rtx, into a tree.  */\n \t    cond = make_node (RTL_EXPR);\n \t    TREE_TYPE (cond) = integer_type_node;\n \t    RTL_EXPR_RTL (cond) = flag;\n@@ -6932,7 +6936,7 @@ expand_expr (exp, target, tmode, modifier)\n \n     case ADDR_EXPR:\n       /* If nonzero, TEMP will be set to the address of something that might\n-\t be a MEM corresponding to a stack slot. */\n+\t be a MEM corresponding to a stack slot.  */\n       temp = 0;\n \n       /* Are we taking the address of a nested function?  */\n@@ -6982,7 +6986,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t   || GET_CODE (op0) == CONCAT)\n \t    {\n \t      /* If this object is in a register, it must be not\n-\t\t be BLKmode. */\n+\t\t be BLKmode.  */\n \t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t      rtx memloc = assign_temp (inner_type, 1, 1, 1);\n \n@@ -7138,7 +7142,8 @@ expand_expr (exp, target, tmode, modifier)\n }\n \n \n-/* Emit bytecode to evaluate the given expression EXP to the stack. */\n+/* Emit bytecode to evaluate the given expression EXP to the stack.  */\n+\n void\n bc_expand_expr (exp)\n     tree exp;\n@@ -7253,7 +7258,7 @@ bc_expand_expr (exp)\n \t\n \t/* Allocate a location for the return value and push its\n \t   address on the evaluation stack.  Also make an entry\n-\t   at the front of the calldesc for the return value type. */\n+\t   at the front of the calldesc for the return value type.  */\n \t\n \ttype = TREE_TYPE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))));\n \tretval = bc_allocate_local (int_size_in_bytes (type), TYPE_ALIGN (type));\n@@ -7274,7 +7279,7 @@ bc_expand_expr (exp)\n \tr = output_constant_def (calldesc);\n \tbc_load_externaddr (r);\n \t\n-\t/* Push the address of the function to be called. */\n+\t/* Push the address of the function to be called.  */\n \tbc_expand_expr (TREE_OPERAND (exp, 0));\n \t\n \t/* Call the function, popping its address and the calldesc vector\n@@ -7910,7 +7915,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n     case BUILT_IN_SIN:\n     case BUILT_IN_COS:\n-      /* Treat these like sqrt, but only if the user asks for them. */\n+      /* Treat these like sqrt, but only if the user asks for them.  */\n       if (! flag_fast_math)\n \tbreak;\n     case BUILT_IN_FSQRT:\n@@ -7996,7 +8001,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  }\n #else\n \t  /* We can't set errno=EDOM directly; let the library call do it.\n-\t     Pop the arguments right away in case the call gets deleted. */\n+\t     Pop the arguments right away in case the call gets deleted.  */\n \t  NO_DEFER_POP;\n \t  expand_call (exp, target, 0);\n \t  OK_DEFER_POP;\n@@ -8005,7 +8010,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  emit_label (lab1);\n \t}\n \n-      /* Output the entire sequence. */\n+      /* Output the entire sequence.  */\n       insns = get_insns ();\n       end_sequence ();\n       emit_insns (insns);\n@@ -8385,15 +8390,15 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  enum machine_mode insn_mode = value_mode, char_mode;\n \t  enum insn_code icode;\n \n-\t  /* If the length is known, just return it. */\n+\t  /* If the length is known, just return it.  */\n \t  if (len != 0)\n \t    return expand_expr (len, target, mode, 0);\n \n-\t  /* If SRC is not a pointer type, don't do this operation inline. */\n+\t  /* If SRC is not a pointer type, don't do this operation inline.  */\n \t  if (align == 0)\n \t    break;\n \n-\t  /* Call a function if we can't compute strlen in the right mode. */\n+\t  /* Call a function if we can't compute strlen in the right mode.  */\n \n \t  while (insn_mode != VOIDmode)\n \t    {\n@@ -8973,12 +8978,12 @@ static enum machine_mode apply_result_mode[FIRST_PSEUDO_REGISTER];\n /* For each register that may be used for calling a function, this\n    gives the offset of that register into the block returned by\n    __builtin_apply_args.  0 indicates that the register is not\n-   used for calling a function. */\n+   used for calling a function.  */\n static int apply_args_reg_offset[FIRST_PSEUDO_REGISTER];\n \n /* Return the offset of register REGNO into the block returned by \n    __builtin_apply_args.  This is not declared static, since it is\n-   needed in objc-act.c. */\n+   needed in objc-act.c.  */\n \n int \n apply_args_register_offset (regno)\n@@ -8987,7 +8992,7 @@ apply_args_register_offset (regno)\n   apply_args_size ();\n \n   /* Arguments are always put in outgoing registers (in the argument\n-     block) if such make sense. */\n+     block) if such make sense.  */\n #ifdef OUTGOING_REGNO\n   regno = OUTGOING_REGNO(regno);\n #endif\n@@ -9958,19 +9963,19 @@ do_jump (exp, if_false_label, if_true_label)\n \t    tree new_cleanups;\n \t    tree cond;\n \n-\t    /* Flag cleanups as not needed. */\n+\t    /* Flag cleanups as not needed.  */\n \t    emit_move_insn (flag, const0_rtx);\n \t    emit_insns (seq1);\n \n-\t    /* Flag cleanups as needed. */\n+\t    /* Flag cleanups as needed.  */\n \t    emit_move_insn (flag, const1_rtx);\n \t    emit_insns (seq2);\n \n \t    /* All cleanups must be on the function_obstack.  */\n \t    push_obstacks_nochange ();\n \t    resume_temporary_allocation ();\n \n-\t    /* convert flag, which is an rtx, into a tree. */\n+\t    /* convert flag, which is an rtx, into a tree.  */\n \t    cond = make_node (RTL_EXPR);\n \t    TREE_TYPE (cond) = integer_type_node;\n \t    RTL_EXPR_RTL (cond) = flag;\n@@ -10022,19 +10027,19 @@ do_jump (exp, if_false_label, if_true_label)\n \t    tree new_cleanups;\n \t    tree cond;\n \n-\t    /* Flag cleanups as not needed. */\n+\t    /* Flag cleanups as not needed.  */\n \t    emit_move_insn (flag, const0_rtx);\n \t    emit_insns (seq1);\n \n-\t    /* Flag cleanups as needed. */\n+\t    /* Flag cleanups as needed.  */\n \t    emit_move_insn (flag, const1_rtx);\n \t    emit_insns (seq2);\n \n \t    /* All cleanups must be on the function_obstack.  */\n \t    push_obstacks_nochange ();\n \t    resume_temporary_allocation ();\n \n-\t    /* convert flag, which is an rtx, into a tree. */\n+\t    /* convert flag, which is an rtx, into a tree.  */\n \t    cond = make_node (RTL_EXPR);\n \t    TREE_TYPE (cond) = integer_type_node;\n \t    RTL_EXPR_RTL (cond) = flag;\n@@ -10661,7 +10666,7 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n #if 0\n   /* There's no need to do this now that combine.c can eliminate lots of\n      sign extensions.  This can be less efficient in certain cases on other\n-     machines. */\n+     machines.  */\n \n   /* If this is a signed equality comparison, we can do it as an\n      unsigned comparison since zero-extension is cheaper than sign\n@@ -11047,7 +11052,7 @@ do_tablejump (index, mode, range, table_label, default_label)\n \n /* Emit a suitable bytecode to load a value from memory, assuming a pointer\n    to that value is on the top of the stack. The resulting type is TYPE, and\n-   the source declaration is DECL. */\n+   the source declaration is DECL.  */\n \n void\n bc_load_memory (type, decl)\n@@ -11058,7 +11063,7 @@ bc_load_memory (type, decl)\n   \n   /* Bit fields are special.  We only know about signed and\n      unsigned ints, and enums.  The latter are treated as\n-     signed integers. */\n+     signed integers.  */\n   \n   if (DECL_BIT_FIELD (decl))\n     if (TREE_CODE (type) == ENUMERAL_TYPE\n@@ -11067,7 +11072,7 @@ bc_load_memory (type, decl)\n     else\n       abort ();\n   else\n-    /* See corresponding comment in bc_store_memory(). */\n+    /* See corresponding comment in bc_store_memory().  */\n     if (TYPE_MODE (type) == BLKmode\n \t|| TYPE_MODE (type) == VOIDmode)\n       return;\n@@ -11087,7 +11092,7 @@ bc_load_memory (type, decl)\n \n /* Store the contents of the second stack slot to the address in the\n    top stack slot.  DECL is the declaration of the destination and is used\n-   to determine whether we're dealing with a bitfield. */\n+   to determine whether we're dealing with a bitfield.  */\n \n void\n bc_store_memory (type, decl)\n@@ -11113,7 +11118,7 @@ bc_store_memory (type, decl)\n \t   structure size in size units (usually bytes).  The two first arguments\n \t   are already on the stack; so we just put the size on level 1.  For some\n \t   other languages, the size may be variable, this is why we don't encode\n-\t   it as a storeBLK literal, but rather treat it as a full-fledged expression. */\n+\t   it as a storeBLK literal, but rather treat it as a full-fledged expression.  */\n \t\n \tbc_expand_expr (TYPE_SIZE (type));\n \topcode = storeBLK;\n@@ -11169,7 +11174,7 @@ bc_allocate_local (size, alignment)\n \n \n /* Allocate variable-sized local array. Variable-sized arrays are\n-   actually pointers to the address in memory where they are stored. */\n+   actually pointers to the address in memory where they are stored.  */\n \n rtx\n bc_allocate_variable_array (size)\n@@ -11192,6 +11197,7 @@ bc_allocate_variable_array (size)\n \n \n /* Push the machine address for the given external variable offset.  */\n+\n void\n bc_load_externaddr (externaddr)\n      rtx externaddr;\n@@ -11207,6 +11213,7 @@ bc_load_externaddr (externaddr)\n \n \n /* Like above, but expects an IDENTIFIER.  */\n+\n void\n bc_load_externaddr_id (id, offset)\n      tree id;\n@@ -11225,6 +11232,7 @@ bc_load_externaddr_id (id, offset)\n \n \n /* Push the machine address for the given local variable offset.  */\n+\n void\n bc_load_localaddr (localaddr)\n      rtx localaddr;\n@@ -11234,7 +11242,8 @@ bc_load_localaddr (localaddr)\n \n \n /* Push the machine address for the given parameter offset.\n-   NOTE: offset is in bits. */\n+   NOTE: offset is in bits.  */\n+\n void\n bc_load_parmaddr (parmaddr)\n      rtx parmaddr;\n@@ -11245,6 +11254,7 @@ bc_load_parmaddr (parmaddr)\n \n \n /* Convert a[i] into *(a + i).  */\n+\n tree\n bc_canonicalize_array_ref (exp)\n      tree exp;\n@@ -11280,7 +11290,7 @@ bc_canonicalize_array_ref (exp)\n /* Load the address of the component referenced by the given\n    COMPONENT_REF expression.\n \n-   Returns innermost lvalue. */\n+   Returns innermost lvalue.  */\n \n tree\n bc_expand_component_address (exp)\n@@ -11330,6 +11340,7 @@ bc_expand_component_address (exp)\n \n \n /* Emit code to push two SI constants */\n+\n void\n bc_push_offset_and_size (offset, size)\n      HOST_WIDE_INT offset, size;\n@@ -11343,7 +11354,7 @@ bc_push_offset_and_size (offset, size)\n    the stack.  If it's a bit field, we also push offset and size info.\n \n    Returns innermost component, which allows us to determine not only\n-   its type, but also whether it's a bitfield. */\n+   its type, but also whether it's a bitfield.  */\n \n tree\n bc_expand_address (exp)\n@@ -11370,7 +11381,7 @@ bc_expand_address (exp)\n \n       /* For variable-sized types: retrieve pointer.  Sometimes the\n \t TYPE_SIZE tree is NULL.  Is this a bug or a feature?  Let's\n-\t also make sure we have an operand, just in case... */\n+\t also make sure we have an operand, just in case...  */\n \n       if (TREE_OPERAND (exp, 0)\n \t  && TYPE_SIZE (TREE_TYPE (TREE_OPERAND (exp, 0)))\n@@ -11457,7 +11468,7 @@ bc_expand_address (exp)\n       break;\n     }\n \n-  /* Most lvalues don't have components. */\n+  /* Most lvalues don't have components.  */\n   return (exp);\n }\n \n@@ -11499,6 +11510,7 @@ bc_runtime_type_code (type)\n \n \n /* Generate constructor label */\n+\n char *\n bc_gen_constr_label ()\n {\n@@ -11516,7 +11528,7 @@ bc_gen_constr_label ()\n    The pointer is put in the pointer table and is retrieved by a constP\n    bytecode instruction.  We then loop and store each constructor member in\n    the corresponding component.  Finally, we return the original pointer on\n-   the stack. */\n+   the stack.  */\n \n void\n bc_expand_constructor (constr)\n@@ -11529,7 +11541,7 @@ bc_expand_constructor (constr)\n   \n   /* Literal constructors are handled as constants, whereas\n      non-literals are evaluated and stored element by element\n-     into the data segment. */\n+     into the data segment.  */\n   \n   /* Allocate space in proper segment and push pointer to space on stack.\n    */\n@@ -11554,18 +11566,18 @@ bc_expand_constructor (constr)\n   \n   /* Add reference to pointer table and recall pointer to stack;\n      this code is common for both types of constructors: literals\n-     and non-literals. */\n+     and non-literals.  */\n \n   ptroffs = bc_define_pointer (l);\n   bc_emit_instruction (constP, ptroffs);\n \n-  /* This is all that has to be done if it's a literal. */\n+  /* This is all that has to be done if it's a literal.  */\n   if (TREE_CONSTANT (constr))\n     return;\n \n \n   /* At this point, we have the pointer to the structure on top of the stack.\n-     Generate sequences of store_memory calls for the constructor. */\n+     Generate sequences of store_memory calls for the constructor.  */\n   \n   /* constructor type is structure */\n   if (TREE_CODE (TREE_TYPE (constr)) == RECORD_TYPE)\n@@ -11632,7 +11644,7 @@ bc_expand_constructor (constr)\n \t\n \t\n \t/* Store each element of the constructor into the corresponding\n-\t   element of TARGET, determined by counting the elements. */\n+\t   element of TARGET, determined by counting the elements.  */\n \t\n \tfor (elt = CONSTRUCTOR_ELTS (constr), i = 0;\n \t     elt;\n@@ -11712,6 +11724,7 @@ bc_store_field (field, bitsize, bitpos, mode, exp, type,\n \n \n /* Store SI/SU in bitfield */\n+\n void\n bc_store_bit_field (offset, size, unsignedp)\n      int offset, size, unsignedp;\n@@ -11725,6 +11738,7 @@ bc_store_bit_field (offset, size, unsignedp)\n \n \n /* Load SI/SU from bitfield */\n+\n void\n bc_load_bit_field (offset, size, unsignedp)\n      int offset, size, unsignedp;\n@@ -11740,7 +11754,7 @@ bc_load_bit_field (offset, size, unsignedp)\n /* Adjust interpreter stack by NLEVELS.  Positive means drop NLEVELS\n    (adjust stack pointer upwards), negative means add that number of\n    levels (adjust the stack pointer downwards).  Only positive values\n-   normally make sense. */\n+   normally make sense.  */\n \n void\n bc_adjust_stack (nlevels)"}, {"sha": "f6a9247b30b1806dc157f6e0489a4aa0233fc1c7", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -628,12 +628,12 @@ extern void emit_group_load PROTO((rtx, rtx));\n extern void emit_group_store PROTO((rtx, rtx));\n \n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n-extern void use_reg PROTO((rtx*, rtx));\n+extern void use_reg PROTO((rtx *, rtx));\n /* Mark NREGS consecutive regs, starting at REGNO, as holding parameters\n    for the next CALL_INSN.  */\n-extern void use_regs PROTO((rtx*, int, int));\n+extern void use_regs PROTO((rtx *, int, int));\n /* Mark a PARALLEL as holding a parameter for the next CALL_INSN.  */\n-extern void use_group_regs PROTO((rtx*, rtx));\n+extern void use_group_regs PROTO((rtx *, rtx));\n \n /* Write zeros through the storage of OBJECT.\n    If OBJECT has BLKmode, SIZE is its length in bytes and ALIGN is its"}, {"sha": "2932f8996d487e936761b676acdd7c04218926d1", "filename": "gcc/final.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -338,7 +338,7 @@ end_final (filename)\n \t 7:  address of table of function names (LPBX4).\n \t 8:  address of table of line numbers (LPBX5) or 0.\n \t 9:  address of table of file names (LPBX6) or 0.\n-\t10:  space reserved for basic block profiling. */\n+\t10:  space reserved for basic block profiling.  */\n \n       ASM_OUTPUT_ALIGN (asm_out_file, align);\n \n@@ -709,7 +709,7 @@ shorten_branches (first)\n #endif\n \t  /* Inside a delay slot sequence, we do not do any branch shortening\n \t     if the shortening could change the number of delay slots\n-\t     of the branch. */\n+\t     of the branch.  */\n \t  for (i = 0; i < XVECLEN (body, 0); i++)\n \t    {\n \t      rtx inner_insn = XVECEXP (body, 0, i);\n@@ -897,7 +897,7 @@ final_start_function (first, file, optimize)\n   /* For SDB and XCOFF, the function beginning must be marked between\n      the function label and the prologue.  We always need this, even when\n      -g1 was used.  Defer on MIPS systems so that parameter descriptions\n-     follow function entry. */\n+     follow function entry.  */\n #if defined(SDB_DEBUGGING_INFO) && !defined(MIPS_DEBUGGING_INFO)\n   if (write_symbols == SDB_DEBUG)\n     sdbout_begin_function (last_linenum);\n@@ -1152,7 +1152,7 @@ add_bb_string (string, perm_p)\n       string = p;\n     }\n   else\n-    for (ptr = sbb_head; ptr != (struct bb_str *)0; ptr = ptr->next)\n+    for (ptr = sbb_head; ptr != (struct bb_str *) 0; ptr = ptr->next)\n       if (ptr->string == string)\n \tbreak;\n \n@@ -1321,7 +1321,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t{\n #if defined(SDB_DEBUGGING_INFO) && defined(MIPS_DEBUGGING_INFO)\n \t  /* MIPS stabs require the parameter descriptions to be after the\n-\t     function entry point rather than before. */\n+\t     function entry point rather than before.  */\n \t  if (write_symbols == SDB_DEBUG)\n \t    sdbout_begin_function (last_linenum);\n \t  else\n@@ -2768,8 +2768,8 @@ asm_fprintf VPROTO((FILE *file, char *p, ...))\n   VA_START (argptr, p);\n \n #ifndef __STDC__\n-  file = va_arg (argptr, FILE*);\n-  p = va_arg (argptr, char*);\n+  file = va_arg (argptr, FILE *);\n+  p = va_arg (argptr, char *);\n #endif\n \n   buf[0] = '%';\n@@ -2991,7 +2991,7 @@ split_double (value, first, second)\n       /* Note, this converts the REAL_VALUE_TYPE to the target's\n \t format, splits up the floating point double and outputs\n \t exactly 32 bits of it into each of l[0] and l[1] --\n-\t not necessarily BITS_PER_WORD bits. */\n+\t not necessarily BITS_PER_WORD bits.  */\n       REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n \n       *first = GEN_INT ((HOST_WIDE_INT) l[0]);"}, {"sha": "f059952587b58c15a5b2ce95cae68d42e81514f7", "filename": "gcc/fix-header.c", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -68,7 +68,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    if anything needs to be done.  (e.g. ./include/stdio.h)\n    * OPTIONS are such as you would pass to cpp.\n \n-   Written by Per Bothner <bothner@cygnus.com>, July 1993. */\n+   Written by Per Bothner <bothner@cygnus.com>, July 1993.  */\n \n #include <stdio.h>\n #include <ctype.h>\n@@ -105,7 +105,7 @@ int missing_extern_C_count = 0;\n #include \"xsys-protos.h\"\n \n #ifdef FIXPROTO_IGNORE_LIST\n-/* This is a currently unused feature. */\n+/* This is a currently unused feature.  */\n \n /* List of files and directories to ignore.\n    A directory name (ending in '/') means ignore anything in that\n@@ -135,23 +135,23 @@ enum special_file\n };\n \n /* A NAMELIST is a sequence of names, separated by '\\0', and terminated\n-   by an empty name (i.e. by \"\\0\\0\"). */\n+   by an empty name (i.e. by \"\\0\\0\").  */\n \n-typedef const char* namelist;\n+typedef const char *namelist;\n \n-/* The following macros provide the bits for symbol_flags. */\n+/* The following macros provide the bits for symbol_flags.  */\n typedef int symbol_flags;\n \n-/* Used to mark names defined in the ANSI/ISO C standard. */\n+/* Used to mark names defined in the ANSI/ISO C standard.  */\n #define ANSI_SYMBOL 1\n \n-/* Used to mark names defined in the Posix.1 or Posix.2 standard. */\n+/* Used to mark names defined in the Posix.1 or Posix.2 standard.  */\n #define POSIX1_SYMBOL 2\n #define POSIX2_SYMBOL 4\n \n-/* Used to mark names defined in X/Open Portability Guide. */\n+/* Used to mark names defined in X/Open Portability Guide.  */\n #define XOPEN_SYMBOL 8\n-/* Used to mark names defined in X/Open UNIX Extensions. */\n+/* Used to mark names defined in X/Open UNIX Extensions.  */\n #define XOPEN_EXTENDED_SYMBOL 16\n \n /* Used to indicate names that are not functions */\n@@ -176,7 +176,7 @@ add_symbols (flags, names)\n   cur_symbol_table_size++;\n   if (cur_symbol_table_size >= SYMBOL_TABLE_SIZE)\n     fatal (\"too many calls to add_symbols\");\n-  symbol_table[cur_symbol_table_size].names = NULL; /* Termination. */\n+  symbol_table[cur_symbol_table_size].names = NULL; /* Termination.  */\n }\n \n struct std_include_entry {\n@@ -185,9 +185,9 @@ struct std_include_entry {\n   namelist names;\n };\n \n-const char NONE[] = \"\";  /* The empty namelist. */\n+const char NONE[] = \"\";  /* The empty namelist.  */\n \n-/* Special name to indicate a continuation line in std_include_table. */\n+/* Special name to indicate a continuation line in std_include_table.  */\n const char CONTINUED[] = \"\";\n \n struct std_include_entry *include_entry;\n@@ -201,7 +201,7 @@ isprint\\0ispunct\\0isspace\\0isupper\\0isxdigit\\0tolower\\0toupper\\0\" },\n \n   { \"errno.h\", ANSI_SYMBOL|MACRO_SYMBOL, \"errno\\0\" },\n \n-  /* ANSI_SYMBOL is wrong, but ... */\n+  /* ANSI_SYMBOL is wrong, but ...  */\n   { \"curses.h\", ANSI_SYMBOL, \"box\\0delwin\\0endwin\\0getcurx\\0getcury\\0initscr\\0\\\n mvcur\\0mvwprintw\\0mvwscanw\\0newwin\\0overlay\\0overwrite\\0\\\n scroll\\0subwin\\0touchwin\\0waddstr\\0wclear\\0wclrtobot\\0wclrtoeol\\0\\\n@@ -226,14 +226,14 @@ tan\\0tanh\\0\" },\n \n   { \"pwd.h\", POSIX1_SYMBOL, \"getpwnam\\0getpwuid\\0\" },\n \n-  /* Left out siglongjmp sigsetjmp - these depend on sigjmp_buf. */\n+  /* Left out siglongjmp sigsetjmp - these depend on sigjmp_buf.  */\n   { \"setjmp.h\", ANSI_SYMBOL, \"longjmp\\0setjmp\\0\" },\n \n   /* Left out signal() - its prototype is too complex for us!\n      Also left out \"sigaction sigaddset sigdelset sigemptyset\n      sigfillset sigismember sigpending sigprocmask sigsuspend\"\n      because these need sigset_t or struct sigaction.\n-     Most systems that provide them will also declare them. */\n+     Most systems that provide them will also declare them.  */\n   { \"signal.h\", ANSI_SYMBOL, \"kill\\0raise\\0\" },\n \n   { \"stdio.h\", ANSI_SYMBOL,\n@@ -244,7 +244,7 @@ printf\\0putc\\0putchar\\0puts\\0remove\\0rename\\0rewind\\0scanf\\0setbuf\\0\\\n setvbuf\\0sprintf\\0sscanf\\0vprintf\\0vsprintf\\0vfprintf\\0tmpfile\\0\\\n tmpnam\\0ungetc\\0\" },\n   { CONTINUED, POSIX1_SYMBOL, \"fdopen\\0fileno\\0\" },\n-  { CONTINUED, POSIX2_SYMBOL, \"pclose\\0popen\\0\" },  /* I think ... */\n+  { CONTINUED, POSIX2_SYMBOL, \"pclose\\0popen\\0\" },  /* I think ...  */\n /* Should perhaps also handle NULL, EOF, ... ? */\n \n   /* \"div ldiv\", - ignored because these depend on div_t, ldiv_t\n@@ -270,7 +270,7 @@ strtok\\0strxfrm\\0\" },\n \n   /* Actually, XPG4 does not seem to have <sys/ioctl.h>, but defines\n      ioctl in <strops.h>.  However, many systems have it is sys/ioctl.h,\n-     and many systems do have <sys/ioctl.h> but not <strops.h>. */\n+     and many systems do have <sys/ioctl.h> but not <strops.h>.  */\n   { \"sys/ioctl.h\", XOPEN_EXTENDED_SYMBOL, \"ioctl\\0\" },\n \n   { \"sys/socket.h\", XOPEN_EXTENDED_SYMBOL, \"socket\\0\" },\n@@ -324,7 +324,7 @@ ttyname\\0unlink\\0write\\0\" },\n \n enum special_file special_file_handling = no_special;\n \n-/* They are set if the corresponding macro has been seen. */\n+/* They are set if the corresponding macro has been seen.  */\n /* The following are only used when handling sys/stat.h */\n int seen_S_IFBLK = 0, seen_S_ISBLK  = 0;\n int seen_S_IFCHR = 0, seen_S_ISCHR  = 0;\n@@ -337,7 +337,7 @@ int seen_errno = 0;\n /* The following are only used when handling stdlib.h */\n int seen_EXIT_FAILURE = 0, seen_EXIT_SUCCESS = 0;\n \f\n-/* Wrapper around free, to avoid prototype clashes. */\n+/* Wrapper around free, to avoid prototype clashes.  */\n \n void\n xfree (ptr)\n@@ -361,6 +361,7 @@ fancy_abort ()\n struct obstack scan_file_obstack;\n \n /* NOTE:  If you edit this, also edit gen-protos.c !! */\n+\n struct fn_decl *\n lookup_std_proto (name, name_length)\n      const char *name;\n@@ -435,10 +436,10 @@ void\n recognized_macro (fname)\n      char *fname;\n {\n-  /* The original include file defines fname as a macro. */\n+  /* The original include file defines fname as a macro.  */\n   struct fn_decl *fn = lookup_std_proto (fname, strlen (fname));\n \n-  /* Since fname is a macro, don't require a prototype for it. */\n+  /* Since fname is a macro, don't require a prototype for it.  */\n   if (fn)\n     {\n       if (REQUIRED (fn))\n@@ -498,7 +499,7 @@ recognized_extern (name, name_length, type, type_length)\n    KIND is 'I' for an inline function;\n    'F' if a normal function declaration preceded by 'extern \"C\"'\n    (or nested inside 'extern \"C\"' braces); or\n-   'f' for other function declarations. */\n+   'f' for other function declarations.  */\n \n void\n recognized_function (fname, fname_length,\n@@ -523,23 +524,23 @@ recognized_function (fname, fname_length,\n \n   fn = lookup_std_proto (fname, fname_length);\n \n-  /* Remove the function from the list of required function. */\n+  /* Remove the function from the list of required function.  */\n   if (fn)\n     {\n       if (REQUIRED (fn))\n \trequired_unseen_count--;\n       SET_SEEN (fn);\n     }\n \n-  /* If we have a full prototype, we're done. */\n+  /* If we have a full prototype, we're done.  */\n   if (have_arg_list)\n     return;\n       \n   if (kind == 'I')  /* don't edit inline function */\n     return;\n \n   /* If the partial prototype was included from some other file,\n-     we don't need to patch it up (in this run). */\n+     we don't need to patch it up (in this run).  */\n   i = strlen (file_seen);\n   if (i < inc_filename_length\n       || strcmp (inc_filename, file_seen + (i - inc_filename_length)) != 0)\n@@ -551,9 +552,9 @@ recognized_function (fname, fname_length,\n     return;\n \n   /* We only have a partial function declaration,\n-     so remember that we have to add a complete prototype. */\n+     so remember that we have to add a complete prototype.  */\n   partial_count++;\n-  partial = (struct partial_proto*)\n+  partial = (struct partial_proto *)\n     obstack_alloc (&scan_file_obstack, sizeof (struct partial_proto));\n   partial->fname = obstack_alloc (&scan_file_obstack, fname_length + 1);\n   bcopy (fname, partial->fname, fname_length);\n@@ -573,7 +574,7 @@ recognized_function (fname, fname_length,\n }\n \n /* For any name in NAMES that is defined as a macro,\n-   call recognized_macro on it. */\n+   call recognized_macro on it.  */\n \n void\n check_macro_names (pfile, names)\n@@ -626,7 +627,7 @@ read_scan_file (in_fname, argc, argv)\n     exit (0);\n \n   /* Traditionally, getc and putc are defined in terms of _filbuf and _flsbuf.\n-     If so, those functions are also required. */\n+     If so, those functions are also required.  */\n   if (special_file_handling == stdio_h\n       && (fn = lookup_std_proto (\"_filbuf\", 7)) != NULL)\n     {\n@@ -636,13 +637,13 @@ read_scan_file (in_fname, argc, argv)\n       int old_written = CPP_WRITTEN (&scan_in);\n       int seen_filbuf = 0;\n \n-      /* Scan the macro expansion of \"getchar();\". */\n+      /* Scan the macro expansion of \"getchar();\".  */\n       for (;;)\n \t{\n \t  enum cpp_token token = cpp_get_token (&scan_in);\n \t  int length = CPP_WRITTEN (&scan_in) - old_written;\n \t  CPP_SET_WRITTEN (&scan_in, old_written);\n-\t  if (token == CPP_EOF) /* Should not happen ... */\n+\t  if (token == CPP_EOF) /* Should not happen ...  */\n \t    break;\n \t  if (token == CPP_POP && CPP_BUFFER (&scan_in) == buf)\n \t    {\n@@ -660,7 +661,7 @@ read_scan_file (in_fname, argc, argv)\n \t  int need_flsbuf\n \t    = flsbuf_fn && !SEEN (flsbuf_fn) && !REQUIRED (flsbuf_fn);\n \n-\t  /* Append \"_filbuf\" and/or \"_flsbuf\" to the required functions. */\n+\t  /* Append \"_filbuf\" and/or \"_flsbuf\" to the required functions.  */\n \t  if (need_filbuf + need_flsbuf)\n \t    {\n \t      char *new_list;\n@@ -723,7 +724,7 @@ write_rbrac ()\n #endif\n     }\n \n-  /* Now we print out prototypes for those functions that we haven't seen. */\n+  /* Now we print out prototypes for those functions that we haven't seen.  */\n   for (cur_symbols = &symbol_table[0]; cur_symbols->names; cur_symbols++)\n     {\n       int if_was_emitted = 0;\n@@ -854,7 +855,7 @@ xstrdup (str)\n \n  */\n \n-#define INF_GET() (inf_ptr < inf_limit ? *(unsigned char*)inf_ptr++ : EOF)\n+#define INF_GET() (inf_ptr < inf_limit ? *(unsigned char *) inf_ptr++ : EOF)\n #define INF_UNGET(c) ((c)!=EOF && inf_ptr--)\n \n int\n@@ -894,7 +895,7 @@ inf_skip_spaces (c)\n   return c;\n }\n \n-/* Read into STR from inf_buffer upto DELIM. */\n+/* Read into STR from inf_buffer upto DELIM.  */\n \n int\n inf_read_upto (str, delim)\n@@ -938,7 +939,7 @@ inf_scan_ident (s, c)\n /* Returns 1 if the file is correctly protected against multiple\n    inclusion, setting *ifndef_line to the line number of the initial #ifndef\n    and setting *endif_line to the final #endif.\n-   Otherwise return 0. */\n+   Otherwise return 0.  */\n \n int\n check_protection (ifndef_line, endif_line)\n@@ -949,7 +950,7 @@ check_protection (ifndef_line, endif_line)\n   char *protect_name = NULL; /* Identifier following initial #ifndef */\n   int define_seen = 0;\n \n-  /* Skip initial white space (including comments). */\n+  /* Skip initial white space (including comments).  */\n   for (;; lineno++)\n     {\n       c = inf_skip_spaces (' ');\n@@ -964,7 +965,7 @@ check_protection (ifndef_line, endif_line)\n   if (SSTRING_LENGTH (&buf) == 0 || strcmp (buf.base, \"ifndef\") != 0)\n     return 0;\n \n-  /* So far so good: We've seen an initial #ifndef. */\n+  /* So far so good: We've seen an initial #ifndef.  */\n   *ifndef_line = lineno;\n   c = inf_scan_ident (&buf, inf_skip_spaces (c));\n   if (SSTRING_LENGTH (&buf) == 0 || c == EOF)\n@@ -1032,7 +1033,7 @@ check_protection (ifndef_line, endif_line)\n   if (!define_seen)\n      return 0;\n   *endif_line = lineno;\n-  /* Skip final white space (including comments). */\n+  /* Skip final white space (including comments).  */\n   for (;;)\n     {\n       c = inf_skip_spaces (' ');\n@@ -1130,7 +1131,7 @@ main (argc, argv)\n   else\n     symbol_table[0].names = NULL;\n \n-  /* Count and mark the prototypes required for this include file. */ \n+  /* Count and mark the prototypes required for this include file.  */ \n   for (cur_symbols = &symbol_table[0]; cur_symbols->names; cur_symbols++)\n     {\n       int name_len;\n@@ -1165,7 +1166,7 @@ main (argc, argv)\n       exit (-1);\n     }\n   inf_size = sbuf.st_size;\n-  inf_buffer = (char*) xmalloc (inf_size + 2);\n+  inf_buffer = (char *) xmalloc (inf_size + 2);\n   inf_buffer[inf_size] = '\\n';\n   inf_buffer[inf_size + 1] = '\\0';\n   inf_limit = inf_buffer + inf_size;\n@@ -1191,7 +1192,7 @@ main (argc, argv)\n \n   close (inf_fd);\n \n-  /* If file doesn't end with '\\n', add one. */\n+  /* If file doesn't end with '\\n', add one.  */\n   if (inf_limit > inf_buffer && inf_limit[-1] != '\\n')\n     inf_limit++;\n \n@@ -1218,7 +1219,7 @@ main (argc, argv)\n       rbrac_line = -1;\n     }\n \n-  /* Reset input file. */\n+  /* Reset input file.  */\n   inf_ptr = inf_buffer;\n   lineno = 1;\n \n@@ -1242,7 +1243,7 @@ main (argc, argv)\n \t      fn = lookup_std_proto (buf.base, strlen (buf.base));\n \t      /* We only want to edit the declaration matching the one\n \t\t seen by scan-decls, as there can be multiple\n-\t\t declarations, selected by #ifdef __STDC__ or whatever. */\n+\t\t declarations, selected by #ifdef __STDC__ or whatever.  */\n \t      if (fn && fn->partial && fn->partial->line_seen == lineno)\n \t\t{\n \t\t  c = inf_skip_spaces (' ');\n@@ -1285,7 +1286,7 @@ main (argc, argv)\n }\n \f\n /* Stub error functions.  These replace cpperror.c,\n-   because we want to suppress error messages. */\n+   because we want to suppress error messages.  */\n \n void\n cpp_file_line_for_message (pfile, filename, line, column)\n@@ -1308,6 +1309,7 @@ cpp_print_containing_files (pfile)\n }\n \n /* IS_ERROR is 2 for fatal error, 1 for error, 0 for warning */\n+\n void cpp_message (pfile, is_error, msg, arg1, arg2, arg3)\n      int is_error;\n      cpp_reader *pfile;"}, {"sha": "222a67514c24bdfa7be279710f53c41bc88e39ad", "filename": "gcc/flags.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -315,6 +315,11 @@ extern int flag_pedantic_errors;\n \n extern int flag_pic;\n \n+/* Nonzero means generate extra code for exception handling and enable\n+   exception handling.  */\n+\n+extern int flag_exceptions;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n "}, {"sha": "bdcdf57ddd0b9ea42549f21500462766964fc098", "filename": "gcc/floatlib.c", "status": "added", "additions": 838, "deletions": 0, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffloatlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffloatlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffloatlib.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -0,0 +1,838 @@\n+/*\n+** libgcc support for software floating point.\n+** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.\n+** Permission is granted to do *anything* you want with this file,\n+** commercial or otherwise, provided this message remains intact.  So there!\n+** I would appreciate receiving any updates/patches/changes that anyone\n+** makes, and am willing to be the repository for said changes (am I\n+** making a big mistake?).\n+\n+Warning! Only single-precision is actually implemented.  This file\n+won't really be much use until double-precision is supported.\n+\n+However, once that is done, this file might eventually become a\n+replacement for libgcc1.c.  It might also make possible\n+cross-compilation for an IEEE target machine from a non-IEEE\n+host such as a VAX.\n+\n+If you'd like to work on completing this, please talk to rms@gnu.ai.mit.edu.\n+\n+\n+**\n+** Pat Wood\n+** Pipeline Associates, Inc.\n+** pipeline!phw@motown.com or\n+** sun!pipeline!phw or\n+** uunet!motown!pipeline!phw\n+**\n+** 05/01/91 -- V1.0 -- first release to gcc mailing lists\n+** 05/04/91 -- V1.1 -- added float and double prototypes and return values\n+**                  -- fixed problems with adding and subtracting zero\n+**                  -- fixed rounding in truncdfsf2\n+**                  -- fixed SWAP define and tested on 386\n+*/\n+\n+/*\n+** The following are routines that replace the libgcc soft floating point\n+** routines that are called automatically when -msoft-float is selected.\n+** The support single and double precision IEEE format, with provisions\n+** for byte-swapped machines (tested on 386).  Some of the double-precision\n+** routines work at full precision, but most of the hard ones simply punt\n+** and call the single precision routines, producing a loss of accuracy.\n+** long long support is not assumed or included.\n+** Overall accuracy is close to IEEE (actually 68882) for single-precision\n+** arithmetic.  I think there may still be a 1 in 1000 chance of a bit\n+** being rounded the wrong way during a multiply.  I'm not fussy enough to\n+** bother with it, but if anyone is, knock yourself out.\n+**\n+** Efficiency has only been addressed where it was obvious that something\n+** would make a big difference.  Anyone who wants to do this right for\n+** best speed should go in and rewrite in assembler.\n+**\n+** I have tested this only on a 68030 workstation and 386/ix integrated\n+** in with -msoft-float.\n+*/\n+\n+/* the following deal with IEEE single-precision numbers */\n+#define D_PHANTOM_BIT   0x00100000\n+#define EXCESS\t\t126\n+#define SIGNBIT\t\t0x80000000\n+#define HIDDEN\t\t(1 << 23)\n+#define SIGN(fp)\t((fp) & SIGNBIT)\n+#define EXP(fp)\t\t(((fp) >> 23) & 0xFF)\n+#define MANT(fp)\t(((fp) & 0x7FFFFF) | HIDDEN)\n+#define PACK(s,e,m)\t((s) | ((e) << 23) | (m))\n+\n+/* the following deal with IEEE double-precision numbers */\n+#define EXCESSD\t\t1022\n+#define HIDDEND\t\t(1 << 20)\n+#define EXPD(fp)\t(((fp.l.upper) >> 20) & 0x7FF)\n+#define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n+#define MANTD(fp)\t(((((fp.l.upper) & 0xFFFFF) | HIDDEND) << 10) | \\\n+\t\t\t\t(fp.l.lower >> 22))\n+\n+/* define SWAP for 386/960 reverse-byte-order brain-damaged CPUs */\n+union double_long\n+  {\n+    double d;\n+#ifdef SWAP\n+    struct {\n+      unsigned long lower;\n+      long upper;\n+    } l;\n+#else\n+    struct {\n+      long upper;\n+      unsigned long lower;\n+    } l;\n+#endif\n+  };\n+\n+union float_long\n+  {\n+    float f;\n+    long l;\n+  };\n+\n+   struct _ieee {\n+#ifdef SWAP\n+      unsigned mantissa2 : 32;\n+      unsigned mantissa1 : 20;\n+      unsigned exponent  : 11;\n+      unsigned sign      : 1;\n+#else\n+      unsigned exponent  : 11;\n+      unsigned sign      : 1;\n+      unsigned mantissa2 : 32;\n+      unsigned mantissa1 : 20;\n+#endif\n+   };\n+\n+   union _doubleu {\n+      double d;\n+      struct _ieee ieee;\n+#ifdef SWAP\n+      struct {\n+         unsigned long lower;\n+         long upper;\n+      } l;\n+#else\n+      struct {\n+         long upper;\n+         unsigned long lower;\n+      } l;\n+#endif\n+   };\n+\n+/* add two floats */\n+\n+float\n+__addsf3 (float a1, float a2)\n+{\n+  register long mant1, mant2;\n+  register union float_long fl1, fl2;\n+  register int exp1, exp2;\n+  int sign = 0;\n+\n+  fl1.f = a1;\n+  fl2.f = a2;\n+\n+  /* check for zero args */\n+  if (!fl1.l)\n+    return (fl2.f);\n+  if (!fl2.l)\n+    return (fl1.f);\n+\n+  exp1 = EXP (fl1.l);\n+  exp2 = EXP (fl2.l);\n+\n+  if (exp1 > exp2 + 25)\n+    return (fl1.l);\n+  if (exp2 > exp1 + 25)\n+    return (fl2.l);\n+\n+  /* do everything in excess precision so's we can round later */\n+  mant1 = MANT (fl1.l) << 6;\n+  mant2 = MANT (fl2.l) << 6;\n+\n+  if (SIGN (fl1.l))\n+    mant1 = -mant1;\n+  if (SIGN (fl2.l))\n+    mant2 = -mant2;\n+\n+  if (exp1 > exp2)\n+    {\n+      mant2 >>= exp1 - exp2;\n+    }\n+  else\n+    {\n+      mant1 >>= exp2 - exp1;\n+      exp1 = exp2;\n+    }\n+  mant1 += mant2;\n+\n+  if (mant1 < 0)\n+    {\n+      mant1 = -mant1;\n+      sign = SIGNBIT;\n+    }\n+  else if (!mant1)\n+    return (0);\n+\n+  /* normalize up */\n+  while (!(mant1 & 0xE0000000))\n+    {\n+      mant1 <<= 1;\n+      exp1--;\n+    }\n+\n+  /* normalize down? */\n+  if (mant1 & (1 << 30))\n+    {\n+      mant1 >>= 1;\n+      exp1++;\n+    }\n+\n+  /* round to even */\n+  mant1 += (mant1 & 0x40) ? 0x20 : 0x1F;\n+\n+  /* normalize down? */\n+  if (mant1 & (1 << 30))\n+    {\n+      mant1 >>= 1;\n+      exp1++;\n+    }\n+\n+  /* lose extra precision */\n+  mant1 >>= 6;\n+\n+  /* turn off hidden bit */\n+  mant1 &= ~HIDDEN;\n+\n+  /* pack up and go home */\n+  fl1.l = PACK (sign, exp1, mant1);\n+  return (fl1.f);\n+}\n+\n+/* subtract two floats */\n+\n+float\n+__subsf3 (float a1, float a2)\n+{\n+  register union float_long fl1, fl2;\n+\n+  fl1.f = a1;\n+  fl2.f = a2;\n+\n+  /* check for zero args */\n+  if (!fl2.l)\n+    return (fl1.f);\n+  if (!fl1.l)\n+    return (-fl2.f);\n+\n+  /* twiddle sign bit and add */\n+  fl2.l ^= SIGNBIT;\n+  return __addsf3 (a1, fl2.f);\n+}\n+\n+/* compare two floats */\n+\n+long\n+__cmpsf2 (float a1, float a2)\n+{\n+  register union float_long fl1, fl2;\n+\n+  fl1.f = a1;\n+  fl2.f = a2;\n+\n+  if (SIGN (fl1.l) && SIGN (fl2.l))\n+    {\n+      fl1.l ^= SIGNBIT;\n+      fl2.l ^= SIGNBIT;\n+    }\n+  if (fl1.l < fl2.l)\n+    return (-1);\n+  if (fl1.l > fl2.l)\n+    return (1);\n+  return (0);\n+}\n+\n+/* multiply two floats */\n+\n+float\n+__mulsf3 (float a1, float a2)\n+{\n+  register union float_long fl1, fl2;\n+  register unsigned long result;\n+  register int exp;\n+  int sign;\n+\n+  fl1.f = a1;\n+  fl2.f = a2;\n+\n+  if (!fl1.l || !fl2.l)\n+    return (0);\n+\n+  /* compute sign and exponent */\n+  sign = SIGN (fl1.l) ^ SIGN (fl2.l);\n+  exp = EXP (fl1.l) - EXCESS;\n+  exp += EXP (fl2.l);\n+\n+  fl1.l = MANT (fl1.l);\n+  fl2.l = MANT (fl2.l);\n+\n+  /* the multiply is done as one 16x16 multiply and two 16x8 multiples */\n+  result = (fl1.l >> 8) * (fl2.l >> 8);\n+  result += ((fl1.l & 0xFF) * (fl2.l >> 8)) >> 8;\n+  result += ((fl2.l & 0xFF) * (fl1.l >> 8)) >> 8;\n+\n+  if (result & 0x80000000)\n+    {\n+      /* round */\n+      result += 0x80;\n+      result >>= 8;\n+    }\n+  else\n+    {\n+      /* round */\n+      result += 0x40;\n+      result >>= 7;\n+      exp--;\n+    }\n+\n+  result &= ~HIDDEN;\n+\n+  /* pack up and go home */\n+  fl1.l = PACK (sign, exp, result);\n+  return (fl1.f);\n+}\n+\n+/* divide two floats */\n+\n+float\n+__divsf3 (float a1, float a2)\n+{\n+  register union float_long fl1, fl2;\n+  register int result;\n+  register int mask;\n+  register int exp, sign;\n+\n+  fl1.f = a1;\n+  fl2.f = a2;\n+\n+  /* subtract exponents */\n+  exp = EXP (fl1.l) - EXP (fl2.l) + EXCESS;\n+\n+  /* compute sign */\n+  sign = SIGN (fl1.l) ^ SIGN (fl2.l);\n+\n+  /* divide by zero??? */\n+  if (!fl2.l)\n+    /* return NaN or -NaN */\n+    return (sign ? 0xFFFFFFFF : 0x7FFFFFFF);\n+\n+  /* numerator zero??? */\n+  if (!fl1.l)\n+    return (0);\n+\n+  /* now get mantissas */\n+  fl1.l = MANT (fl1.l);\n+  fl2.l = MANT (fl2.l);\n+\n+  /* this assures we have 25 bits of precision in the end */\n+  if (fl1.l < fl2.l)\n+    {\n+      fl1.l <<= 1;\n+      exp--;\n+    }\n+\n+  /* now we perform repeated subtraction of fl2.l from fl1.l */\n+  mask = 0x1000000;\n+  result = 0;\n+  while (mask)\n+    {\n+      if (fl1.l >= fl2.l)\n+\t{\n+\t  result |= mask;\n+\t  fl1.l -= fl2.l;\n+\t}\n+      fl1.l <<= 1;\n+      mask >>= 1;\n+    }\n+\n+  /* round */\n+  result += 1;\n+\n+  /* normalize down */\n+  exp++;\n+  result >>= 1;\n+\n+  result &= ~HIDDEN;\n+\n+  /* pack up and go home */\n+  fl1.l = PACK (sign, exp, result);\n+  return (fl1.f);\n+}\n+\n+/* convert int to double */\n+\n+double\n+__floatsidf (register long a1)\n+{\n+  register int sign = 0, exp = 31 + EXCESSD;\n+  union double_long dl;\n+\n+  if (!a1)\n+    {\n+      dl.l.upper = dl.l.lower = 0;\n+      return (dl.d);\n+    }\n+\n+  if (a1 < 0)\n+    {\n+      sign = SIGNBIT;\n+      a1 = -a1;\n+    }\n+\n+  while (a1 < 0x1000000)\n+    {\n+      a1 <<= 4;\n+      exp -= 4;\n+    }\n+\n+  while (a1 < 0x40000000)\n+    {\n+      a1 <<= 1;\n+      exp--;\n+    }\n+\n+  /* pack up and go home */\n+  dl.l.upper = sign;\n+  dl.l.upper |= exp << 20;\n+  dl.l.upper |= (a1 >> 10) & ~HIDDEND;\n+  dl.l.lower = a1 << 22;\n+\n+  return (dl.d);\n+}\n+\n+/* negate a float */\n+\n+float\n+__negsf2 (float a1)\n+{\n+  register union float_long fl1;\n+\n+  fl1.f = a1;\n+  if (!fl1.l)\n+    return (0);\n+\n+  fl1.l ^= SIGNBIT;\n+  return (fl1.f);\n+}\n+\n+/* negate a double */\n+\n+double\n+__negdf2 (double a1)\n+{\n+  register union double_long dl1;\n+\n+  dl1.d = a1;\n+\n+  if (!dl1.l.upper && !dl1.l.lower)\n+      return (dl1.d);\n+\n+  dl1.l.upper ^= SIGNBIT;\n+  return (dl1.d);\n+}\n+\n+/* convert float to double */\n+\n+double\n+__extendsfdf2 (float a1)\n+{\n+  register union float_long fl1;\n+  register union double_long dl;\n+  register int exp;\n+\n+  fl1.f = a1;\n+\n+  if (!fl1.l)\n+    {\n+      dl.l.upper = dl.l.lower = 0;\n+      return (dl.d);\n+    }\n+\n+  dl.l.upper = SIGN (fl1.l);\n+  exp = EXP (fl1.l) - EXCESS + EXCESSD;\n+  dl.l.upper |= exp << 20;\n+  dl.l.upper |= (MANT (fl1.l) & ~HIDDEN) >> 3;\n+  dl.l.lower = MANT (fl1.l) << 29;\n+\n+  return (dl.d);\n+}\n+\n+/* convert double to float */\n+\n+float\n+__truncdfsf2 (double a1)\n+{\n+  register int exp;\n+  register long mant;\n+  register union float_long fl;\n+  register union double_long dl1;\n+\n+  dl1.d = a1;\n+\n+  if (!dl1.l.upper && !dl1.l.lower)\n+    return (0);\n+\n+  exp = EXPD (dl1) - EXCESSD + EXCESS;\n+\n+  /* shift double mantissa 6 bits so we can round */\n+  mant = MANTD (dl1) >> 6;\n+\n+  /* now round and shift down */\n+  mant += 1;\n+  mant >>= 1;\n+\n+  /* did the round overflow? */\n+  if (mant & 0xFF000000)\n+    {\n+      mant >>= 1;\n+      exp++;\n+    }\n+\n+  mant &= ~HIDDEN;\n+\n+  /* pack up and go home */\n+  fl.l = PACK (SIGND (dl1), exp, mant);\n+  return (fl.f);\n+}\n+\n+/* compare two doubles */\n+\n+long\n+__cmpdf2 (double a1, double a2)\n+{\n+  register union double_long dl1, dl2;\n+\n+  dl1.d = a1;\n+  dl2.d = a2;\n+\n+  if (SIGND (dl1) && SIGND (dl2))\n+    {\n+      dl1.l.upper ^= SIGNBIT;\n+      dl2.l.upper ^= SIGNBIT;\n+    }\n+  if (dl1.l.upper < dl2.l.upper)\n+    return (-1);\n+  if (dl1.l.upper > dl2.l.upper)\n+    return (1);\n+  if (dl1.l.lower < dl2.l.lower)\n+    return (-1);\n+  if (dl1.l.lower > dl2.l.lower)\n+    return (1);\n+  return (0);\n+}\n+\n+/* convert double to int */\n+\n+long\n+__fixdfsi (double a1)\n+{\n+  register union double_long dl1;\n+  register int exp;\n+  register long l;\n+\n+  dl1.d = a1;\n+\n+  if (!dl1.l.upper && !dl1.l.lower)\n+    return (0);\n+\n+  exp = EXPD (dl1) - EXCESSD - 31;\n+  l = MANTD (dl1);\n+\n+  if (exp > 0)\n+    return (0x7FFFFFFF | SIGND (dl1)); /* largest integer */\n+\n+  /* shift down until exp = 0 or l = 0 */\n+  if (exp < 0 && exp > -32 && l)\n+    l >>= -exp;\n+  else\n+    return (0);\n+\n+  return (SIGND (dl1) ? -l : l);\n+}\n+\n+/* convert double to unsigned int */\n+\n+unsigned\n+long __fixunsdfsi (double a1)\n+{\n+  register union double_long dl1;\n+  register int exp;\n+  register unsigned long l;\n+\n+  dl1.d = a1;\n+\n+  if (!dl1.l.upper && !dl1.l.lower)\n+    return (0);\n+\n+  exp = EXPD (dl1) - EXCESSD - 32;\n+  l = (((((dl1.l.upper) & 0xFFFFF) | HIDDEND) << 11) | (dl1.l.lower >> 21));\n+\n+  if (exp > 0)\n+    return (0xFFFFFFFF);\t/* largest integer */\n+\n+  /* shift down until exp = 0 or l = 0 */\n+  if (exp < 0 && exp > -32 && l)\n+    l >>= -exp;\n+  else\n+    return (0);\n+\n+  return (l);\n+}\n+\n+/* For now, the hard double-precision routines simply\n+   punt and do it in single */\n+/* addtwo doubles */\n+\n+double\n+__adddf3 (double a1, double a2)\n+{\n+  return ((float) a1 + (float) a2);\n+}\n+\n+/* subtract two doubles */\n+\n+double\n+__subdf3 (double a1, double a2)\n+{\n+  return ((float) a1 - (float) a2);\n+}\n+\n+/* multiply two doubles */\n+\n+double\n+__muldf3 (double a1, double a2)\n+{\n+  return ((float) a1 * (float) a2);\n+}\n+\n+/*\n+ *\n+ * Name:   Barrett Richardson\n+ * E-mail: barrett@iglou.com\n+ * When:   Thu Dec 15 10:31:11 EST 1994\n+ *\n+ *    callable function:\n+ *\n+ *       double __divdf3(double a1, double a2);\n+ *\n+ *       Does software divide of a1 / a2.\n+ *\n+ *       Based largely on __divsf3() in floatlib.c in the gcc\n+ *       distribution.\n+ *\n+ *    Purpose: To be used in conjunction with the -msoft-float\n+ *             option of gcc. You should be able to tack it to the\n+ *             end of floatlib.c included in the gcc distribution,\n+ *             and delete the __divdf3() already there which just \n+ *             calls the single precision function (or may just\n+ *             use the floating point processor with some configurations).\n+ *\n+ *   You may use this code for whatever your heart desires.\n+ */\n+\n+\n+\n+\n+/*\n+ * Compare the the mantissas of two doubles.\n+ * Each mantissa is in two longs.\n+ * \n+ *   return      1   if x1's mantissa is greater than x2's\n+ *              -1   if x1's mantissa is less than x2's\n+ *               0   if the two mantissa's are equal.\n+ *\n+ *   The Mantissas won't fit into a 4 byte word, so they are\n+ *   broken up into two parts.\n+ *\n+ *   This function is used internally by __divdf3()\n+ */\n+\n+int\n+__dcmp (long x1m1, long x1m2, long x2m1, long x2m2)\n+{\n+   if (x1m1 > x2m1)\n+      return 1;\n+\n+   if (x1m1 < x2m1)\n+      return -1;\n+\n+ /*  If the first word in the two mantissas were equal check the second word */\n+\n+   if (x1m2 > x2m2)\n+      return 1;\n+\n+   if (x1m2 < x2m2)\n+      return -1;\n+\n+   return 0;\n+}\n+\n+\n+/* divide two doubles */\n+\n+double\n+__divdf3 (double a1, double a2)\n+{\n+\n+   int  sign,\n+        exponent,\n+        bit_bucket;\n+\n+   register unsigned long mantissa1,\n+                          mantissa2,\n+                          x1m1,\n+                          x1m2,\n+                          x2m1,\n+                          x2m2,\n+                          mask;\n+\n+   union _doubleu x1,\n+                  x2,\n+                  result;\n+\n+\n+   x1.d = a1;\n+   x2.d = a2;\n+\n+   exponent = x1.ieee.exponent - x2.ieee.exponent + EXCESSD;\n+\n+   sign = x1.ieee.sign ^ x2.ieee.sign;\n+\n+   x2.ieee.sign = 0;  /* don't want the sign bit to affect any zero */\n+                      /* comparisons when checking for zero divide  */\n+\n+   if (!x2.l.lower && !x2.l.upper) { /* check for zero divide */\n+      result.l.lower = 0x0;\n+      if (sign)\n+         result.l.upper = 0xFFF00000;   /* negative infinity */\n+      else\n+         result.l.upper = 0x7FF00000;   /* positive infinity */\n+      return result.d;\n+   }\n+\n+   if (!x1.l.upper && !x1.l.lower)  /* check for 0.0 numerator */\n+      return (0.0);\n+\n+   x1m1 = x1.ieee.mantissa1 | D_PHANTOM_BIT;  /* turn on phantom bit */\n+   x1m2 = x1.ieee.mantissa2;\n+\n+   x2m1 = x2.ieee.mantissa1 | D_PHANTOM_BIT;  /* turn on phantom bit */\n+   x2m2 = x2.ieee.mantissa2;\n+\n+   if (__dcmp(x1m1,x1m2,x2m1,x2m2) < 0) {\n+\n+   /* if x1's mantissa is less than x2's shift it left one and decrement */\n+   /* the exponent to accomodate the change in the mantissa              */\n+\n+      x1m1 <<= 1;               /*                          */\n+      bit_bucket = x1m2 >> 31;  /*  Shift mantissa left one */\n+      x1m1 |= bit_bucket;       /*                          */\n+      x1m2 <<= 1;               /*                          */\n+\n+      exponent--;\n+   }\n+\n+\n+   mantissa1 = 0;\n+   mantissa2 = 0;\n+\n+\n+  /* Get the first part of the results mantissa using successive */\n+  /* subtraction.                                                */\n+\n+   mask = 0x00200000;\n+   while (mask) {\n+\n+      if (__dcmp(x1m1,x1m2,x2m1,x2m2) >= 0) {\n+\n+     /* subtract x2's mantissa from x1's */\n+\n+         mantissa1 |= mask;   /* turn on a bit in the result */\n+\n+         if (x2m2 > x1m2)\n+            x1m1--;\n+         x1m2 -= x2m2; \n+         x1m1 -= x2m1;\n+      }\n+\n+      x1m1 <<= 1;               /*                          */\n+      bit_bucket = x1m2 >> 31;  /*  Shift mantissa left one */\n+      x1m1 |= bit_bucket;       /*                          */\n+      x1m2 <<= 1;               /*                          */\n+\n+      mask >>= 1;\n+   }\n+\n+  /* Get the second part of the results mantissa using successive */\n+  /* subtraction.                                                 */\n+\n+   mask = 0x80000000;\n+   while (mask) {\n+\n+      if (__dcmp(x1m1,x1m2,x2m1,x2m2) >= 0) {\n+\n+     /* subtract x2's mantissa from x1's */\n+\n+         mantissa2 |= mask;   /* turn on a bit in the result */\n+\n+         if (x2m2 > x1m2)\n+            x1m1--;\n+         x1m2 -= x2m2; \n+         x1m1 -= x2m1;\n+      }\n+      x1m1 <<= 1;               /*                          */\n+      bit_bucket = x1m2 >> 31;  /*  Shift mantissa left one */\n+      x1m1 |= bit_bucket;       /*                          */\n+      x1m2 <<= 1;               /*                          */\n+\n+      mask >>= 1;\n+   }\n+\n+  /* round up by adding 1 to mantissa */\n+\n+   if (mantissa2 == 0xFFFFFFFF) {  /* check for over flow */\n+\n+   /* spill if overflow */\n+\n+      mantissa2 = 0;\n+      mantissa1++;\n+   }\n+   else\n+      mantissa2++;\n+\n+   exponent++;   /* increment exponent (mantissa must be shifted right */\n+                 /* also)                                              */\n+\n+ /* shift mantissa right one and assume a phantom bit (which really gives */\n+ /* 53 bits of precision in the mantissa)                                 */\n+\n+   mantissa2 >>= 1;\n+   bit_bucket = mantissa1 & 1;\n+   mantissa2 |= (bit_bucket << 31);\n+   mantissa1 >>= 1;\n+\n+  /* put all the info into the result */\n+\n+   result.ieee.exponent  = exponent;\n+   result.ieee.sign      = sign;\n+   result.ieee.mantissa1 = mantissa1;\n+   result.ieee.mantissa2 = mantissa2;\n+\n+\n+   return result.d;\n+}"}, {"sha": "e521150371bddaca630fea7ff37cfcba47dc5ce7", "filename": "gcc/flow.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -154,7 +154,8 @@ int n_basic_blocks;\n \n int max_regno;\n \n-/* Maximum number of SCRATCH rtx's used in any basic block of this function. */\n+/* Maximum number of SCRATCH rtx's used in any basic block of this\n+   function.  */\n \n int max_scratch;\n \n@@ -327,7 +328,7 @@ flow_analysis (f, nregs, file)\n #endif\n \n   /* Record which registers will be eliminated.  We use this in\n-     mark_used_regs. */\n+     mark_used_regs.  */\n \n   CLEAR_HARD_REG_SET (elim_reg_set);\n \n@@ -969,7 +970,7 @@ life_analysis (f, nregs)\n \n   /* Record which insns refer to any volatile memory\n      or for any reason can't be deleted just because they are dead stores.\n-     Also, delete any insns that copy a register to itself. */\n+     Also, delete any insns that copy a register to itself.  */\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n@@ -1300,7 +1301,7 @@ allocate_for_life_analysis ()\n   register regset tem;\n \n   regset_size = ((max_regno + REGSET_ELT_BITS - 1) / REGSET_ELT_BITS);\n-  regset_bytes = regset_size * sizeof (*(regset)0);\n+  regset_bytes = regset_size * sizeof (*(regset) 0);\n \n   reg_n_refs = (int *) oballoc (max_regno * sizeof (int));\n   bzero ((char *) reg_n_refs, max_regno * sizeof (int));\n@@ -1775,7 +1776,7 @@ insn_dead_p (x, needed, call_ok)\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n \t      /* Make sure insns to set arg pointer are never deleted\n \t\t (if the arg pointer isn't fixed, there will be a USE for\n-\t\t it, so we can treat it normally). */\n+\t\t it, so we can treat it normally).  */\n \t      || (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n #endif\n \t      || (needed[offset] & bit) != 0)\n@@ -2430,7 +2431,7 @@ mark_used_regs (needed, live, x, final, insn)\n \t  return;\n \t}\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case REG:\n       /* See a register other than being set\n@@ -2720,7 +2721,7 @@ try_pre_increment_1 (insn)\n   if (y != 0\n       && BLOCK_NUM (y) == BLOCK_NUM (insn)\n       /* Don't do this if the reg dies, or gets set in y; a standard addressing\n-\t mode would be better. */\n+\t mode would be better.  */\n       && ! dead_or_set_p (y, SET_DEST (x))\n       && try_pre_increment (y, SET_DEST (PATTERN (insn)),\n \t\t\t    amount))"}, {"sha": "634894390e641b5bee40f256a38c9231e9bd602c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -4626,7 +4626,7 @@ fold (expr)\n \t      /* For NE, we can only do this simplification if integer.  */\n \t      if (! INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n \t\tbreak;\n-\t      /* ... fall through ... */\n+\t      /* ... fall through ...  */\n \t    case GT_EXPR:\n \t    case LT_EXPR:\n \t      t = build_int_2 (0, 0);"}, {"sha": "beaca62f60a928e7bf410d31a4bb235d043cc82c", "filename": "gcc/function.c", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -60,7 +60,7 @@ Boston, MA 02111-1307, USA.  */\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or neither. */\n+   must define both, or neither.  */\n #ifndef NAME__MAIN\n #define NAME__MAIN \"__main\"\n #define SYMBOL__MAIN __main\n@@ -153,7 +153,7 @@ int current_function_args_size;\n int current_function_pretend_args_size;\n \n /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n-   defined, the needed space is pushed by the prologue. */\n+   defined, the needed space is pushed by the prologue.  */\n \n int current_function_outgoing_args_size;\n \n@@ -299,13 +299,6 @@ static int max_parm_reg;\n    if we discover that that parm must go in the stack.  */\n static rtx *parm_reg_stack_loc;\n \n-#if 0  /* Turned off because 0 seems to work just as well.  */\n-/* Cleanup lists are required for binding levels regardless of whether\n-   that binding level has cleanups or not.  This node serves as the\n-   cleanup list whenever an empty list is required.  */\n-static tree empty_cleanup_list;\n-#endif\n-\n /* Nonzero once virtual register instantiation has been done.\n    assign_stack_local uses frame_pointer_rtx when this is nonzero.  */\n static int virtuals_instantiated;\n@@ -345,7 +338,7 @@ struct temp_slot\n {\n   /* Points to next temporary slot.  */\n   struct temp_slot *next;\n-  /* The rtx to used to reference the slot. */\n+  /* The rtx to used to reference the slot.  */\n   rtx slot;\n   /* The rtx used to represent the address if not the address of the\n      slot above.  May be an EXPR_LIST if multiple addresses exist.  */\n@@ -941,7 +934,7 @@ assign_temp (type, keep, memory_required, dont_promote)\n       /* Unfortunately, we don't yet know how to allocate variable-sized\n \t temporaries.  However, sometimes we have a fixed upper limit on\n \t the size (which is stored in TYPE_ARRAY_MAX_SIZE) and can use that\n-\t instead.  This is the case for Chill variable-sized strings. */\n+\t instead.  This is the case for Chill variable-sized strings.  */\n       if (size == -1 && TREE_CODE (type) == ARRAY_TYPE\n \t  && TYPE_ARRAY_MAX_SIZE (type) != NULL_TREE\n \t  && TREE_CODE (TYPE_ARRAY_MAX_SIZE (type)) == INTEGER_CST)\n@@ -1465,7 +1458,7 @@ fixup_var_refs (var, promoted_mode, unsignedp)\n \f\n /* REPLACEMENTS is a pointer to a list of the struct fixup_replacement and X is\n    some part of an insn.  Return a struct fixup_replacement whose OLD\n-   value is equal to X.  Allocate a new structure if no such entry exists. */\n+   value is equal to X.  Allocate a new structure if no such entry exists.  */\n \n static struct fixup_replacement *\n find_fixup_replacement (replacements, x)\n@@ -1919,7 +1912,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t}\n \n       /* If SET_DEST is now a paradoxical SUBREG, put the result of this\n-\t insn into a pseudo and store the low part of the pseudo into VAR. */\n+\t insn into a pseudo and store the low part of the pseudo into VAR.  */\n       if (GET_CODE (SET_DEST (x)) == SUBREG\n \t  && SUBREG_REG (SET_DEST (x)) == var\n \t  && (GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n@@ -2191,7 +2184,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n    If any insns must be emitted to compute NEWADDR, put them before INSN.\n \n    UNCRITICAL nonzero means accept paradoxical subregs.\n-   This is used for subregs found inside REG_NOTES. */\n+   This is used for subregs found inside REG_NOTES.  */\n \n static rtx\n fixup_memory_subreg (x, insn, uncritical)\n@@ -2605,7 +2598,7 @@ instantiate_decls (fndecl, valid_only)\n \t\t\tint_size_in_bytes (TREE_TYPE (decl)), valid_only);\n     }\n \n-  /* Now process all variables defined in the function or its subblocks. */\n+  /* Now process all variables defined in the function or its subblocks.  */\n   instantiate_decls_1 (DECL_INITIAL (fndecl), valid_only);\n \n   if (DECL_INLINE (fndecl) || DECL_DEFER_OUTPUT (fndecl))\n@@ -2864,7 +2857,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t     in the case of old offset equals new just changing the register\n \t     will yield a valid insn.  In the interests of a little efficiency,\n \t     however, we only call validate change once (we don't queue up the\n-\t     changes and then call apply_change_group). */\n+\t     changes and then call apply_change_group).  */\n \n \t  old = XEXP (x, 0);\n \t  if (offset == 0\n@@ -3287,7 +3280,7 @@ assign_parms (fndecl, second_time)\n \n   /* Nonzero if function takes extra anonymous args.\n      This means the last named arg must be on the stack\n-     right before the anonymous ones. */\n+     right before the anonymous ones.  */\n   int stdarg\n     = (TYPE_ARG_TYPES (fntype) != 0\n        && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n@@ -3585,7 +3578,7 @@ assign_parms (fndecl, second_time)\n       FUNCTION_ARG_ADVANCE (args_so_far, promoted_mode,\n \t\t\t    passed_type, ! last_named);\n \n-      /* If this is our second time through, we are done with this parm. */\n+      /* If this is our second time through, we are done with this parm.  */\n       if (second_time)\n \tcontinue;\n \n@@ -4802,7 +4795,7 @@ all_blocks (block, vector)\n   return n_blocks;\n }\n \f\n-/* Build bytecode call descriptor for function SUBR. */\n+/* Build bytecode call descriptor for function SUBR.  */\n \n rtx\n bc_build_calldesc (subr)\n@@ -5035,7 +5028,7 @@ expand_main_function ()\n extern struct obstack permanent_obstack;\n \n /* Expand start of bytecode function. See comment at\n-   expand_function_start below for details. */\n+   expand_function_start below for details.  */\n \n void\n bc_expand_function_start (subr, parms_have_cleanups)\n@@ -5065,7 +5058,7 @@ bc_expand_function_start (subr, parms_have_cleanups)\n \t}\n       else\n \t{\n-\t  /* Variable-sized objects are pointers to their storage. */\n+\t  /* Variable-sized objects are pointers to their storage.  */\n \t  DECL_RTL (thisarg) = bc_gen_rtx ((char *) 0, argsz, (struct bc_label *) 0);\n \t  argsz += POINTER_SIZE;\n \t}\n@@ -5084,7 +5077,7 @@ bc_expand_function_start (subr, parms_have_cleanups)\n \n \n /* Expand end of bytecode function. See details the comment of\n-   expand_function_end(), below. */\n+   expand_function_end(), below.  */\n \n void\n bc_expand_function_end ()\n@@ -5095,7 +5088,7 @@ bc_expand_function_end ()\n \n   /* Emit any fixup code. This must be done before the call to\n      to BC_END_FUNCTION (), since that will cause the bytecode\n-     segment to be finished off and closed. */\n+     segment to be finished off and closed.  */\n \n   expand_fixups (NULL_RTX);\n "}, {"sha": "1135db9875623088c379e3b21059b79a33c14ea0", "filename": "gcc/gansidecl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgansidecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgansidecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgansidecl.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -69,7 +69,7 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n #ifndef NULL_PTR\n-#define NULL_PTR ((GENERIC_PTR)0)\n+#define NULL_PTR ((GENERIC_PTR) 0)\n #endif\n \n #ifdef __STDC__"}, {"sha": "6393a9045ab9fcdb305082fa414b99d0be400b83", "filename": "gcc/gbl-ctors.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgbl-ctors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgbl-ctors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgbl-ctors.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -45,7 +45,7 @@ extern void atexit (void (*) (void));\n #define ON_EXIT(FUNC,ARG) atexit ((FUNC))\n #else\n #ifdef sun\n-extern int on_exit (void*, void*);\t/* The man page says it returns int. */\n+extern int on_exit (void *, void *);\t/* The man page says it returns int. */\n #define ON_EXIT(FUNC,ARG) on_exit ((FUNC), (ARG))\n #endif\n #endif"}, {"sha": "cb0ede84611300b2b3ac0649f86758561456533c", "filename": "gcc/gcc.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -81,7 +81,7 @@ extern int pwait PROTO ((int, int *, int));\n #define WEXITSTATUS(S) (((S) & 0xff00) >> 8)\n #endif\n \n-/* Define O_RDONLY if the system hasn't defined it for us. */\n+/* Define O_RDONLY if the system hasn't defined it for us.  */\n #ifndef O_RDONLY\n #define O_RDONLY 0\n #endif\n@@ -105,7 +105,7 @@ extern int pwait PROTO ((int, int *, int));\n #define EXECUTABLE_SUFFIX \"\"\n #endif\n \n-/* By default, the suffix for object files is \".o\". */\n+/* By default, the suffix for object files is \".o\".  */\n #ifdef OBJECT_SUFFIX\n #define HAVE_OBJECT_SUFFIX\n #else\n@@ -161,7 +161,7 @@ static int print_search_dirs;\n \n static char *print_file_name = NULL;\n \n-/* As print_file_name, but search for executable file. */\n+/* As print_file_name, but search for executable file.  */\n \n static char *print_prog_name = NULL;\n \n@@ -1144,23 +1144,24 @@ skip_whitespace (p)\n   return p;\n }\n \f\n-/* Structure to keep track of the specs that have been defined so far.  These\n-   are accessed using %(specname) or %[specname] in a compiler or link spec. */\n+/* Structure to keep track of the specs that have been defined so far.\n+   These are accessed using %(specname) or %[specname] in a compiler\n+   or link spec.  */\n \n struct spec_list\n {\n-  char *name;                 /* Name of the spec. */\n-  char *spec;                 /* The spec itself. */\n-  struct spec_list *next;     /* Next spec in linked list. */\n+  char *name;                 /* Name of the spec.  */\n+  char *spec;                 /* The spec itself.  */\n+  struct spec_list *next;     /* Next spec in linked list.  */\n };\n \n-/* List of specs that have been defined so far. */\n+/* List of specs that have been defined so far.  */\n \n static struct spec_list *specs = (struct spec_list *) 0;\n \f\n /* Change the value of spec NAME to SPEC.  If SPEC is empty, then the spec is\n    removed; If the spec starts with a + then SPEC is added to the end of the\n-   current spec. */\n+   current spec.  */\n \n static void\n set_spec (name, spec)\n@@ -1279,12 +1280,12 @@ static int signal_count;\n \n static char *programname;\n \f\n-/* Structures to keep track of prefixes to try when looking for files. */\n+/* Structures to keep track of prefixes to try when looking for files.  */\n \n struct prefix_list\n {\n-  char *prefix;               /* String to prepend to the path. */\n-  struct prefix_list *next;   /* Next in linked list. */\n+  char *prefix;               /* String to prepend to the path.  */\n+  struct prefix_list *next;   /* Next in linked list.  */\n   int require_machine_suffix; /* Don't use without machine_suffix.  */\n   /* 2 means try both machine_suffix and just_machine_suffix.  */\n   int *used_flag_ptr;\t      /* 1 if a file was found with this prefix.  */\n@@ -1297,11 +1298,11 @@ struct path_prefix\n   char *name;                 /* Name of this list (used in config stuff) */\n };\n \n-/* List of prefixes to try when looking for executables. */\n+/* List of prefixes to try when looking for executables.  */\n \n static struct path_prefix exec_prefixes = { 0, 0, \"exec\" };\n \n-/* List of prefixes to try when looking for startup (crt0) files. */\n+/* List of prefixes to try when looking for startup (crt0) files.  */\n \n static struct path_prefix startfile_prefixes = { 0, 0, \"startfile\" };\n \n@@ -1642,7 +1643,8 @@ build_search_list (paths, prefix, check_dir_p)\n   return obstack_finish (&collect_obstack);\n }\n \n-/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables for collect.  */\n+/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables\n+   for collect.  */\n \n static void\n putenv_from_prefixes (paths, env_var)\n@@ -1654,7 +1656,7 @@ putenv_from_prefixes (paths, env_var)\n \f\n /* Search for NAME using the prefix list PREFIXES.  MODE is passed to\n    access to check permissions.\n-   Return 0 if not found, otherwise return its name, allocated with malloc. */\n+   Return 0 if not found, otherwise return its name, allocated with malloc.  */\n \n static char *\n find_a_file (pprefix, name, mode)\n@@ -1856,7 +1858,7 @@ unused_prefix_warnings (pprefix)\n     }\n }\n \n-/* Get rid of all prefixes built up so far in *PLISTP. */\n+/* Get rid of all prefixes built up so far in *PLISTP.  */\n \n static void\n free_path_prefix (pprefix)\n@@ -3484,7 +3486,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      int len;\n \n \t      /* The string after the S/P is the name of a spec that is to be\n-\t\t processed. */\n+\t\t processed.  */\n \t      while (*p && *p != ')' && *p != ']')\n \t\tp++;\n \n@@ -3832,7 +3834,7 @@ check_live_switch (switchnum, prefix_length)\n     case 'W':  case 'f':  case 'm':\n       if (! strncmp (name + 1, \"no-\", 3))\n \t{\n-\t  /* We have Xno-YYY, search for XYYY. */\n+\t  /* We have Xno-YYY, search for XYYY.  */\n \t  for (i = switchnum + 1; i < n_switches; i++)\n \t    if (switches[i].part1[0] == name[0]\n \t\t&& ! strcmp (&switches[i].part1[1], &name[4]))\n@@ -4030,7 +4032,7 @@ main (argc, argv)\n     char **q = multilib_raw;\n \n     obstack_init (&multilib_obstack);\n-    while ((p = *q++) != (char *)0)\n+    while ((p = *q++) != (char *) 0)\n       obstack_grow (&multilib_obstack, p, strlen (p));\n \n     obstack_1grow (&multilib_obstack, 0);\n@@ -4500,7 +4502,7 @@ concat VPROTO((char *first, ...))\n   char *first;\n #endif\n \n-  /* First compute the size of the result and get sufficient memory. */\n+  /* First compute the size of the result and get sufficient memory.  */\n \n   VA_START (args, first);\n #ifndef __STDC__\n@@ -4519,7 +4521,7 @@ concat VPROTO((char *first, ...))\n   newstr = (char *) xmalloc (length + 1);\n   va_end (args);\n \n-  /* Now copy the individual pieces to the result string. */\n+  /* Now copy the individual pieces to the result string.  */\n \n   VA_START (args, first);\n #ifndef __STDC__\n@@ -4606,7 +4608,7 @@ fatal VPROTO((char *format, ...))\n   VA_START (ap, format);\n \n #ifndef __STDC__\n-  format = va_arg (ap, char*);\n+  format = va_arg (ap, char *);\n #endif\n \n   fprintf (stderr, \"%s: \", programname);\n@@ -4628,7 +4630,7 @@ error VPROTO((char *format, ...))\n   VA_START (ap, format);\n \n #ifndef __STDC__\n-  format = va_arg (ap, char*);\n+  format = va_arg (ap, char *);\n #endif\n \n   fprintf (stderr, \"%s: \", programname);"}, {"sha": "8e03840ebd02eabc0c619248a750b9f0fcacc429", "filename": "gcc/gen-protos.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -57,7 +57,7 @@ fancy_abort ()\n int\n main (argc, argv)\n      int argc;\n-     char** argv;\n+     char **argv;\n {\n   FILE *inf = stdin;\n   FILE *outf = stdout;"}, {"sha": "38285f1c33b2d0142421d89e5409d5f1528f64dd", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -146,12 +146,12 @@ void fancy_abort ();\n \n struct insn_def\n {\n-  int insn_code;\t\t/* Instruction number. */\n-  int insn_index;\t\t/* Expression numer in file, for errors. */\n-  struct insn_def *next;\t/* Next insn in chain. */\n-  rtx def;\t\t\t/* The DEFINE_... */\n+  int insn_code;\t\t/* Instruction number.  */\n+  int insn_index;\t\t/* Expression numer in file, for errors.  */\n+  struct insn_def *next;\t/* Next insn in chain.  */\n+  rtx def;\t\t\t/* The DEFINE_...  */\n   int num_alternatives;\t\t/* Number of alternatives.  */\n-  int vec_idx;\t\t\t/* Index of attribute vector in `def'. */\n+  int vec_idx;\t\t\t/* Index of attribute vector in `def'.  */\n };\n \n /* Once everything has been read in, we store in each attribute value a list\n@@ -182,15 +182,15 @@ struct attr_value\n \n struct attr_desc\n {\n-  char *name;\t\t\t/* Name of attribute. */\n-  struct attr_desc *next;\t/* Next attribute. */\n-  int is_numeric;\t\t/* Values of this attribute are numeric. */\n+  char *name;\t\t\t/* Name of attribute.  */\n+  struct attr_desc *next;\t/* Next attribute.  */\n+  int is_numeric;\t\t/* Values of this attribute are numeric.  */\n   int negative_ok;\t\t/* Allow negative numeric values.  */\n   int unsigned_p;\t\t/* Make the output function unsigned int.  */\n   int is_const;\t\t\t/* Attribute value constant for each run.  */\n-  int is_special;\t\t/* Don't call `write_attr_set'. */\n-  struct attr_value *first_value; /* First value of this attribute. */\n-  struct attr_value *default_val; /* Default value for this attribute. */\n+  int is_special;\t\t/* Don't call `write_attr_set'.  */\n+  struct attr_value *first_value; /* First value of this attribute.  */\n+  struct attr_value *default_val; /* Default value for this attribute.  */\n };\n \n #define NULL_ATTR (struct attr_desc *) NULL\n@@ -208,7 +208,7 @@ struct range\n struct delay_desc\n {\n   rtx def;\t\t\t/* DEFINE_DELAY expression.  */\n-  struct delay_desc *next;\t/* Next DEFINE_DELAY. */\n+  struct delay_desc *next;\t/* Next DEFINE_DELAY.  */\n   int num;\t\t\t/* Number of DEFINE_DELAY, starting at 1.  */\n };\n \n@@ -236,7 +236,7 @@ struct function_unit\n   int multiplicity;\t\t/* Number of units of this type.  */\n   int simultaneity;\t\t/* Maximum number of simultaneous insns\n \t\t\t\t   on this function unit or 0 if unlimited.  */\n-  rtx condexp;\t\t\t/* Expression TRUE for insn needing unit. */\n+  rtx condexp;\t\t\t/* Expression TRUE for insn needing unit.  */\n   int num_opclasses;\t\t/* Number of different operation types.  */\n   struct function_unit_op *ops;\t/* Pointer to first operation type.  */\n   int needs_conflict_function;\t/* Nonzero if a conflict function required.  */\n@@ -299,7 +299,7 @@ struct dimension\n   int num_values;\t\t/* Length of the values list.  */\n };\n \n-/* Other variables. */\n+/* Other variables.  */\n \n static int insn_code_number;\n static int insn_index_number;\n@@ -741,7 +741,7 @@ attr_printf VPROTO((register int len, char *fmt, ...))\n \n #ifndef __STDC__\n   len = va_arg (p, int);\n-  fmt = va_arg (p, char*);\n+  fmt = va_arg (p, char *);\n #endif\n \n   /* Print the string into a temporary location.  */\n@@ -1152,7 +1152,7 @@ check_attr_value (exp, attr)\n \t/* A constant SYMBOL_REF is valid as a constant attribute test and\n \t   is expanded later by make_canonical into a COND.  */\n \treturn attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n-      /* Otherwise, fall through... */\n+      /* Otherwise, fall through...  */\n \n     default:\n       fatal (\"Invalid operation `%s' for attribute value\",\n@@ -1239,7 +1239,7 @@ convert_set_attr (exp, num_alt, insn_code, insn_index)\n \f\n /* Scan all definitions, checking for validity.  Also, convert any SET_ATTR\n    and SET_ATTR_ALTERNATIVE expressions to the corresponding SET\n-   expressions. */\n+   expressions.  */\n \n static void\n check_defs ()\n@@ -1403,7 +1403,7 @@ make_canonical (attr, exp)\n \tint allsame = 1;\n \trtx defval;\n \n-\t/* First, check for degenerate COND. */\n+\t/* First, check for degenerate COND.  */\n \tif (XVECLEN (exp, 0) == 0)\n \t  return make_canonical (attr, XEXP (exp, 1));\n \tdefval = XEXP (exp, 1) = make_canonical (attr, XEXP (exp, 1));\n@@ -2728,7 +2728,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n \t For each possible COND value, call ourselves recursively.\n \n \t The extra TRUE and FALSE expressions will be eliminated by another\n-\t call to the simplification routine. */\n+\t call to the simplification routine.  */\n \n       orexp = false_rtx;\n       andexp = true_rtx;\n@@ -3089,7 +3089,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t    fatal (\"Invalid alternative specified for pattern number %d\",\n \t\t   insn_index);\n \n-\t  /* If all alternatives are excluded, this is false. */\n+\t  /* If all alternatives are excluded, this is false.  */\n \t  i ^= insn_alternatives[insn_code];\n \t  if (i == 0)\n \t    return false_rtx;\n@@ -3182,7 +3182,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t    fatal (\"Invalid alternative specified for pattern number %d\",\n \t\t   insn_index);\n \n-\t  /* If all alternatives are included, this is true. */\n+\t  /* If all alternatives are included, this is true.  */\n \t  i ^= insn_alternatives[insn_code];\n \t  if (i == 0)\n \t    return true_rtx;\n@@ -4019,7 +4019,7 @@ gen_attr (exp)\n   if (! strcmp (attr->name, \"length\") && ! attr->is_numeric)\n     fatal (\"`length' attribute must take numeric values\");\n \n-  /* Set up the default value. */\n+  /* Set up the default value.  */\n   XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n   attr->default_val = get_attr_value (XEXP (exp, 2), attr, -2);\n }\n@@ -4472,7 +4472,7 @@ write_test_expr (exp, in_comparison)\n \t\tXSTR (exp, 1), XINT (exp, 0), GET_MODE_NAME (GET_MODE (exp)));\n       break;\n \n-    /* Constant integer. */\n+    /* Constant integer.  */\n     case CONST_INT:\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n       printf (\"%d\", XWINT (exp, 0));\n@@ -4481,7 +4481,7 @@ write_test_expr (exp, in_comparison)\n #endif\n       break;\n \n-    /* A random C expression. */\n+    /* A random C expression.  */\n     case SYMBOL_REF:\n       printf (\"%s\", XSTR (exp, 0));\n       break;\n@@ -4630,7 +4630,7 @@ write_attr_get (attr)\n   struct attr_value *av, *common_av;\n \n   /* Find the most used attribute value.  Handle that as the `default' of the\n-     switch we will generate. */\n+     switch we will generate.  */\n   common_av = find_most_used (attr);\n \n   /* Write out start of function, then all values with explicit `case' lines,\n@@ -5546,7 +5546,7 @@ main (argc, argv)\n   {\n     struct rlimit rlim;\n \n-    /* Set the stack limit huge so that alloca does not fail. */\n+    /* Set the stack limit huge so that alloca does not fail.  */\n     getrlimit (RLIMIT_STACK, &rlim);\n     rlim.rlim_cur = rlim.rlim_max;\n     setrlimit (RLIMIT_STACK, &rlim);\n@@ -5676,7 +5676,7 @@ from the machine description file `md'.  */\\n\\n\");\n   /* Construct extra attributes for `length'.  */\n   make_length_attrs ();\n \n-  /* Perform any possible optimizations to speed up compilation. */\n+  /* Perform any possible optimizations to speed up compilation.  */\n   optimize_attrs ();\n \n   /* Now write out all the `gen_attr_...' routines.  Do these before the"}, {"sha": "e80e4c71668716921c1e5c33940616ce210a6dba", "filename": "gcc/genemit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -272,7 +272,7 @@ gen_insn (insn)\n \n   /* See if the pattern for this insn ends with a group of CLOBBERs of (hard)\n      registers or MATCH_SCRATCHes.  If so, store away the information for\n-     later. */\n+     later.  */\n \n   if (XVEC (insn, 1))\n     {\n@@ -506,6 +506,7 @@ gen_expand (expand)\n }\n \n /* Like gen_expand, but generates a SEQUENCE.  */\n+\n static void\n gen_split (split)\n      rtx split;"}, {"sha": "471a43987e6535aa50d62d00fed9b8696cfa34ec", "filename": "gcc/genextract.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -140,7 +140,7 @@ gen_insn (insn)\n   link = (struct code_ptr *) xmalloc (sizeof (struct code_ptr));\n   link->insn_code = insn_code_number;\n \n-  /* See if we find something that already had this extraction method. */\n+  /* See if we find something that already had this extraction method.  */\n \n   for (p = extractions; p; p = p->next)\n     {"}, {"sha": "f8b39833f65aa3effc769d69872bf1073dadca1b", "filename": "gcc/genflags.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -50,6 +50,7 @@ static struct obstack call_obstack, normal_obstack;\n static int max_id_len;\n \n /* Count the number of match_operand's found.  */\n+\n static int\n num_operands (x)\n      rtx x;\n@@ -87,6 +88,7 @@ num_operands (x)\n }\n \n /* Print out prototype information for a function.  */\n+\n static void\n gen_proto (insn)\n      rtx insn;\n@@ -108,6 +110,7 @@ gen_proto (insn)\n }\n \n /* Print out a function declaration without a prototype.  */\n+\n static void\n gen_nonproto (insn)\n      rtx insn;\n@@ -258,7 +261,7 @@ from the machine description file `md'.  */\\n\\n\");\n     }\n \n   /* Print out the prototypes now.  */\n-  dummy = (rtx)0;\n+  dummy = (rtx) 0;\n   obstack_grow (&call_obstack, &dummy, sizeof (rtx));\n   call_insns = (rtx *) obstack_finish (&call_obstack);\n "}, {"sha": "b07c70fc46f1cec875f7b8c3fb40adb634549c38", "filename": "gcc/genrecog.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -120,7 +120,7 @@ static int next_number;\n static int next_insn_code;\n \n /* Similar, but counts all expressions in the MD file; used for\n-   error messages. */\n+   error messages.  */\n \n static int next_index;\n \n@@ -498,7 +498,7 @@ add_to_sequence (pattern, last, position)\n       if (GET_CODE (XEXP (pattern, 0)) == CC0)\n \tbreak;\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n       \n     case COMPARE:\n       /* Enforce the mode on the first operand to avoid ambiguous insns.  */\n@@ -572,7 +572,7 @@ not_both_true (d1, d2, toplevel)\n   struct decision *p1, *p2;\n \n   /* If they are both to test modes and the modes are different, they aren't\n-     both true.  Similarly for codes, integer elements, and vector lengths. */\n+     both true.  Similarly for codes, integer elements, and vector lengths.  */\n \n   if ((d1->enforce_mode && d2->enforce_mode\n        && d1->mode != VOIDmode && d2->mode != VOIDmode && d1->mode != d2->mode)\n@@ -1139,7 +1139,7 @@ write_tree_1 (tree, prevpos, afterward, type)\n \t     seen any of the codes that are valid for the predicate, we\n \t     can write a series of \"case\" statement, one for each possible\n \t     code.  Since we are already in a switch, these redundant tests\n-\t     are very cheap and will reduce the number of predicate called. */\n+\t     are very cheap and will reduce the number of predicate called.  */\n \n \t  if (p->pred >= 0)\n \t    {\n@@ -1309,7 +1309,7 @@ write_tree_1 (tree, prevpos, afterward, type)\n \t}\n \n       /* Now that most mode and code tests have been done, we can write out\n-\t a label for an inner node, if we haven't already. */\n+\t a label for an inner node, if we haven't already.  */\n       if (p->label_needed)\n \tprintf (\"%sL%d:\\n\", indents[indent - 2], p->number);\n "}, {"sha": "6cebb382b693840703a5f7e1e7b4fedb22891c8c", "filename": "gcc/gmon.c", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgmon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fgmon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgmon.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -0,0 +1,329 @@\n+/*-\n+ * Copyright (c) 1991 The Regents of the University of California.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *\tThis product includes software developed by the University of\n+ *\tCalifornia, Berkeley and its contributors.\n+ * 4. Neither the name of the University nor the names of its contributors\n+ *    may be used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ */\n+\n+#ifndef lint\n+static char sccsid[] = \"@(#)gmon.c\t5.3 (Berkeley) 5/22/91\";\n+#endif /* not lint */\n+\n+#if 0\n+#include <unistd.h>\n+\n+#endif\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#include \"gmon.h\"\n+\n+extern mcount() asm (\"mcount\");\n+extern char *minbrk asm (\"minbrk\");\n+\n+#ifdef __alpha\n+extern char *sbrk ();\n+#endif\n+\n+    /*\n+     *\tfroms is actually a bunch of unsigned shorts indexing tos\n+     */\n+static int\t\tprofiling = 3;\n+static unsigned short\t*froms;\n+static struct tostruct\t*tos = 0;\n+static long\t\ttolimit = 0;\n+static char\t\t*s_lowpc = 0;\n+static char\t\t*s_highpc = 0;\n+static unsigned long\ts_textsize = 0;\n+\n+static int\tssiz;\n+static char\t*sbuf;\n+static int\ts_scale;\n+    /* see profil(2) where this is describe (incorrectly) */\n+#define\t\tSCALE_1_TO_1\t0x10000L\n+\n+#define\tMSG \"No space for profiling buffer(s)\\n\"\n+\n+monstartup(lowpc, highpc)\n+    char\t*lowpc;\n+    char\t*highpc;\n+{\n+    int\t\t\tmonsize;\n+    char\t\t*buffer;\n+    register int\to;\n+\n+\t/*\n+\t *\tround lowpc and highpc to multiples of the density we're using\n+\t *\tso the rest of the scaling (here and in gprof) stays in ints.\n+\t */\n+    lowpc = (char *)\n+\t    ROUNDDOWN((unsigned) lowpc, HISTFRACTION*sizeof(HISTCOUNTER));\n+    s_lowpc = lowpc;\n+    highpc = (char *)\n+\t    ROUNDUP((unsigned) highpc, HISTFRACTION*sizeof(HISTCOUNTER));\n+    s_highpc = highpc;\n+    s_textsize = highpc - lowpc;\n+    monsize = (s_textsize / HISTFRACTION) + sizeof(struct phdr);\n+    buffer = sbrk( monsize );\n+    if ( buffer == (char *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\treturn;\n+    }\n+    froms = (unsigned short *) sbrk( s_textsize / HASHFRACTION );\n+    if ( froms == (unsigned short *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\tfroms = 0;\n+\treturn;\n+    }\n+    tolimit = s_textsize * ARCDENSITY / 100;\n+    if ( tolimit < MINARCS ) {\n+\ttolimit = MINARCS;\n+    } else if ( tolimit > 65534 ) {\n+\ttolimit = 65534;\n+    }\n+    tos = (struct tostruct *) sbrk( tolimit * sizeof( struct tostruct ) );\n+    if ( tos == (struct tostruct *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\tfroms = 0;\n+\ttos = 0;\n+\treturn;\n+    }\n+    minbrk = sbrk(0);\n+    tos[0].link = 0;\n+    sbuf = buffer;\n+    ssiz = monsize;\n+    ( (struct phdr *) buffer ) -> lpc = lowpc;\n+    ( (struct phdr *) buffer ) -> hpc = highpc;\n+    ( (struct phdr *) buffer ) -> ncnt = ssiz;\n+    monsize -= sizeof(struct phdr);\n+    if ( monsize <= 0 )\n+\treturn;\n+    o = highpc - lowpc;\n+    if( monsize < o )\n+#ifndef hp300\n+\ts_scale = ( (float) monsize / o ) * SCALE_1_TO_1;\n+#else /* avoid floating point */\n+    {\n+\tint quot = o / monsize;\n+\n+\tif (quot >= 0x10000)\n+\t\ts_scale = 1;\n+\telse if (quot >= 0x100)\n+\t\ts_scale = 0x10000 / quot;\n+\telse if (o >= 0x800000)\n+\t\ts_scale = 0x1000000 / (o / (monsize >> 8));\n+\telse\n+\t\ts_scale = 0x1000000 / ((o << 8) / monsize);\n+    }\n+#endif\n+    else\n+\ts_scale = SCALE_1_TO_1;\n+    moncontrol(1);\n+}\n+\n+_mcleanup()\n+{\n+    int\t\t\tfd;\n+    int\t\t\tfromindex;\n+    int\t\t\tendfrom;\n+    char\t\t*frompc;\n+    int\t\t\ttoindex;\n+    struct rawarc\trawarc;\n+\n+    moncontrol(0);\n+    fd = creat( \"gmon.out\" , 0666 );\n+    if ( fd < 0 ) {\n+\tperror( \"mcount: gmon.out\" );\n+\treturn;\n+    }\n+#   ifdef DEBUG\n+\tfprintf( stderr , \"[mcleanup] sbuf 0x%x ssiz %d\\n\" , sbuf , ssiz );\n+#   endif DEBUG\n+    write( fd , sbuf , ssiz );\n+    endfrom = s_textsize / (HASHFRACTION * sizeof(*froms));\n+    for ( fromindex = 0 ; fromindex < endfrom ; fromindex++ ) {\n+\tif ( froms[fromindex] == 0 ) {\n+\t    continue;\n+\t}\n+\tfrompc = s_lowpc + (fromindex * HASHFRACTION * sizeof(*froms));\n+\tfor (toindex=froms[fromindex]; toindex!=0; toindex=tos[toindex].link) {\n+#\t    ifdef DEBUG\n+\t\tfprintf( stderr ,\n+\t\t\t\"[mcleanup] frompc 0x%x selfpc 0x%x count %d\\n\" ,\n+\t\t\tfrompc , tos[toindex].selfpc , tos[toindex].count );\n+#\t    endif DEBUG\n+\t    rawarc.raw_frompc = (unsigned long) frompc;\n+\t    rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;\n+\t    rawarc.raw_count = tos[toindex].count;\n+\t    write( fd , &rawarc , sizeof rawarc );\n+\t}\n+    }\n+    close( fd );\n+}\n+\n+mcount()\n+{\n+\tregister char\t\t\t*selfpc;\n+\tregister unsigned short\t\t*frompcindex;\n+\tregister struct tostruct\t*top;\n+\tregister struct tostruct\t*prevtop;\n+\tregister long\t\t\ttoindex;\n+\n+\t/*\n+\t *\tfind the return address for mcount,\n+\t *\tand the return address for mcount's caller.\n+\t */\n+\n+\t/* selfpc = pc pushed by mcount call.\n+\t   This identifies the function that was just entered.  */\n+\tselfpc = (void *) __builtin_return_address (0);\n+\t/* frompcindex = pc in preceding frame.\n+\t   This identifies the caller of the function just entered.  */\n+\tfrompcindex = (void *) __builtin_return_address (1);\n+\t/*\n+\t *\tcheck that we are profiling\n+\t *\tand that we aren't recursively invoked.\n+\t */\n+\tif (profiling) {\n+\t\tgoto out;\n+\t}\n+\tprofiling++;\n+\t/*\n+\t *\tcheck that frompcindex is a reasonable pc value.\n+\t *\tfor example:\tsignal catchers get called from the stack,\n+\t *\t\t\tnot from text space.  too bad.\n+\t */\n+\tfrompcindex = (unsigned short *) ((long) frompcindex - (long) s_lowpc);\n+\tif ((unsigned long) frompcindex > s_textsize) {\n+\t\tgoto done;\n+\t}\n+\tfrompcindex =\n+\t    &froms[((long) frompcindex) / (HASHFRACTION * sizeof(*froms))];\n+\ttoindex = *frompcindex;\n+\tif (toindex == 0) {\n+\t\t/*\n+\t\t *\tfirst time traversing this arc\n+\t\t */\n+\t\ttoindex = ++tos[0].link;\n+\t\tif (toindex >= tolimit) {\n+\t\t\tgoto overflow;\n+\t\t}\n+\t\t*frompcindex = toindex;\n+\t\ttop = &tos[toindex];\n+\t\ttop->selfpc = selfpc;\n+\t\ttop->count = 1;\n+\t\ttop->link = 0;\n+\t\tgoto done;\n+\t}\n+\ttop = &tos[toindex];\n+\tif (top->selfpc == selfpc) {\n+\t\t/*\n+\t\t *\tarc at front of chain; usual case.\n+\t\t */\n+\t\ttop->count++;\n+\t\tgoto done;\n+\t}\n+\t/*\n+\t *\thave to go looking down chain for it.\n+\t *\ttop points to what we are looking at,\n+\t *\tprevtop points to previous top.\n+\t *\twe know it is not at the head of the chain.\n+\t */\n+\tfor (; /* goto done */; ) {\n+\t\tif (top->link == 0) {\n+\t\t\t/*\n+\t\t\t *\ttop is end of the chain and none of the chain\n+\t\t\t *\thad top->selfpc == selfpc.\n+\t\t\t *\tso we allocate a new tostruct\n+\t\t\t *\tand link it to the head of the chain.\n+\t\t\t */\n+\t\t\ttoindex = ++tos[0].link;\n+\t\t\tif (toindex >= tolimit) {\n+\t\t\t\tgoto overflow;\n+\t\t\t}\n+\t\t\ttop = &tos[toindex];\n+\t\t\ttop->selfpc = selfpc;\n+\t\t\ttop->count = 1;\n+\t\t\ttop->link = *frompcindex;\n+\t\t\t*frompcindex = toindex;\n+\t\t\tgoto done;\n+\t\t}\n+\t\t/*\n+\t\t *\totherwise, check the next arc on the chain.\n+\t\t */\n+\t\tprevtop = top;\n+\t\ttop = &tos[top->link];\n+\t\tif (top->selfpc == selfpc) {\n+\t\t\t/*\n+\t\t\t *\tthere it is.\n+\t\t\t *\tincrement its count\n+\t\t\t *\tmove it to the head of the chain.\n+\t\t\t */\n+\t\t\ttop->count++;\n+\t\t\ttoindex = prevtop->link;\n+\t\t\tprevtop->link = top->link;\n+\t\t\ttop->link = *frompcindex;\n+\t\t\t*frompcindex = toindex;\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t}\n+done:\n+\tprofiling--;\n+\t/* and fall through */\n+out:\n+\treturn;\t\t/* normal return restores saved registers */\n+\n+overflow:\n+\tprofiling++; /* halt further profiling */\n+#   define\tTOLIMIT\t\"mcount: tos overflow\\n\"\n+\twrite(2, TOLIMIT, sizeof(TOLIMIT));\n+\tgoto out;\n+}\n+\n+/* Control profiling\n+  \tprofiling is what mcount checks to see if\n+  \tall the data structures are ready.  */\n+\n+moncontrol(mode)\n+    int mode;\n+{\n+    if (mode) {\n+\t/* start */\n+\tprofil(sbuf + sizeof(struct phdr), ssiz - sizeof(struct phdr),\n+\t\t(int)s_lowpc, s_scale);\n+\tprofiling = 0;\n+    } else {\n+\t/* stop */\n+\tprofil((char *) 0, 0, 0, 0);\n+\tprofiling = 3;\n+    }\n+}\n+"}, {"sha": "3e0ae2135e06a3f0505b203e5eb9f5b42e26886d", "filename": "gcc/halfpic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fhalfpic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fhalfpic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -135,7 +135,7 @@ half_pic_hash (name, len, create_p)\n \n   /* name not in hash table.  */\n   if (!create_p)\n-    return (struct all_refs *)0;\n+    return (struct all_refs *) 0;\n \n   ptr = (struct all_refs *) obstack_alloc (&half_pic_obstack, sizeof (struct all_refs));\n   *ptr = zero_all_refs;\n@@ -144,7 +144,7 @@ half_pic_hash (name, len, create_p)\n   ptr->real_len  = len;\n \n   /* Update circular links.  */\n-  if (first == (struct all_refs *)0)\n+  if (first == (struct all_refs *) 0)\n     ptr->hash_next = ptr;\n \n   else\n@@ -342,7 +342,7 @@ half_pic_address_p (addr)\n \treturn FALSE;\n \n       ptr = half_pic_hash (name, len, FALSE);\n-      if (ptr == (struct all_refs *)0)\n+      if (ptr == (struct all_refs *) 0)\n \treturn FALSE;\n \n       if (ptr->external_p)\n@@ -376,7 +376,7 @@ half_pic_ptr (operand)\n   name = XSTR (operand, 0);\n   len = strlen (name);\n   p = half_pic_hash (name, len, FALSE);\n-  if (p == (struct all_refs *)0 || !p->external_p)\n+  if (p == (struct all_refs *) 0 || !p->external_p)\n     return operand;\n \n   if (!p->pointer_p)"}, {"sha": "106e4fe9ad427cd0e882b0cbd608478067b8fc08", "filename": "gcc/integrate.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -394,7 +394,7 @@ save_for_inline_copying (fndecl)\n   char *new, *new1;\n \n   /* Make and emit a return-label if we have not already done so. \n-     Do this before recording the bounds on label numbers. */\n+     Do this before recording the bounds on label numbers.  */\n \n   if (return_label == 0)\n     {\n@@ -1466,7 +1466,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t     that flag set if it is a register.\n \n \t     Also, don't allow hard registers here; they might not be valid\n-\t     when substituted into insns. */\n+\t     when substituted into insns.  */\n \n \t  if ((GET_CODE (copy) != REG && GET_CODE (copy) != SUBREG)\n \t      || (GET_CODE (copy) == REG && REG_USERVAR_P (loc)\n@@ -1497,7 +1497,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t     that flag set if it is a register.\n \n \t     Also, don't allow hard registers here; they might not be valid\n-\t     when substituted into insns. */\n+\t     when substituted into insns.  */\n \t  rtx locreal = gen_realpart (GET_MODE (XEXP (loc, 0)), loc);\n \t  rtx locimag = gen_imagpart (GET_MODE (XEXP (loc, 0)), loc);\n \t  rtx copyreal = gen_realpart (GET_MODE (locreal), copy);\n@@ -2152,7 +2152,7 @@ copy_rtx_and_substitute (orig, map)\n \t  else if (regno == VIRTUAL_INCOMING_ARGS_REGNUM)\n \t    {\n \t      /* Do the same for a block to contain any arguments referenced\n-\t\t in memory. */\n+\t\t in memory.  */\n \t      rtx loc, seq;\n \t      int size = FUNCTION_ARGS_SIZE (DECL_SAVED_INSNS (map->fndecl));\n \n@@ -2161,7 +2161,7 @@ copy_rtx_and_substitute (orig, map)\n \t      loc = XEXP (loc, 0);\n \t      /* When arguments grow downward, the virtual incoming \n \t\t args pointer points to the top of the argument block,\n-\t\t so the remapped location better do the same. */\n+\t\t so the remapped location better do the same.  */\n #ifdef ARGS_GROW_DOWNWARD\n \t      loc = plus_constant (loc, size);\n #endif\n@@ -2345,7 +2345,7 @@ copy_rtx_and_substitute (orig, map)\n \t will not have valid reg_map entries.  This can cause try_constants()\n \t to fail because assumes that all registers in the rtx have valid\n \t reg_map entries, and it may end up replacing one of these new\n-\t registers with junk. */\n+\t registers with junk.  */\n \n       if (! memory_address_p (GET_MODE (temp), XEXP (temp, 0)))\n \ttemp = change_address (temp, GET_MODE (temp), XEXP (temp, 0));"}, {"sha": "b5e60fc3fc645fa95083fa58d533d9cb186763d3", "filename": "gcc/jump.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -100,7 +100,7 @@ int can_reach_end;\n    Normally they are not significant, because of A and B jump to C,\n    and R dies in A, it must die in B.  But this might not be true after\n    stack register conversion, and we must compare death notes in that\n-   case. */\n+   case.  */\n \n static int cross_jump_death_matters = 0;\n \n@@ -499,7 +499,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t    else if (GET_CODE (body) == PARALLEL)\n \t      {\n \t\t/* If each part is a set between two identical registers or\n-\t\t   a USE or CLOBBER, delete the insn. */\n+\t\t   a USE or CLOBBER, delete the insn.  */\n \t\tint i, sreg, dreg;\n \t\trtx tem;\n \n@@ -943,7 +943,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \t  /* Finally, handle the case where two insns are used to \n \t     compute EXP but a temporary register is used.  Here we must\n-\t     ensure that the temporary register is not used anywhere else. */\n+\t     ensure that the temporary register is not used anywhere else.  */\n \n \t  if (! reload_completed\n \t      && after_regscan\n@@ -1924,7 +1924,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \t      /* Now that the jump has been tensioned,\n \t\t try cross jumping: check for identical code\n-\t\t before the jump and before its target label. */\n+\t\t before the jump and before its target label.  */\n \n \t      /* First, cross jumping of conditional jumps:  */\n \n@@ -1959,7 +1959,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t      INSN_CODE (insn) = -1;\n \t\t      emit_barrier_after (insn);\n \t\t      /* Add to jump_chain unless this is a new label\n-\t\t\t whose UID is too large. */\n+\t\t\t whose UID is too large.  */\n \t\t      if (INSN_UID (JUMP_LABEL (insn)) < max_jump_chain)\n \t\t\t{\n \t\t\t  jump_chain[INSN_UID (insn)]\n@@ -2441,13 +2441,13 @@ find_cross_jump (e1, e2, minimum, f1, f2)\n #ifdef STACK_REGS\n       /* If cross_jump_death_matters is not 0, the insn's mode\n \t indicates whether or not the insn contains any stack-like\n-\t regs. */\n+\t regs.  */\n \n       if (!lose && cross_jump_death_matters && GET_MODE (i1) == QImode)\n \t{\n \t  /* If register stack conversion has already been done, then\n \t     death notes must also be compared before it is certain that\n-\t     the two instruction streams match. */\n+\t     the two instruction streams match.  */\n \n \t  rtx note;\n \t  HARD_REG_SET i1_regset, i2_regset;\n@@ -4422,7 +4422,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n \n     case MEM:\n       /* If memory modified or either volatile, not equivalent.\n-\t Else, check address. */\n+\t Else, check address.  */\n       if (modified_mem || MEM_VOLATILE_P (x) || MEM_VOLATILE_P (y))\n \treturn 0;\n "}, {"sha": "043b431eb6c65bf8f319a0e793b0675cff580ca0", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 71, "deletions": 73, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -533,7 +533,7 @@ __udivmoddi4 (n, d, rp)\n \t      udiv_qrnnd (q1, n1, n2, n1, d0);\n \t    }\n \n-\t  /* n1 != d0... */\n+\t  /* n1 != d0...  */\n \n \t  udiv_qrnnd (q0, n0, n1, n0, d0);\n \n@@ -1404,7 +1404,7 @@ asm (\"___builtin_saveregs:\");\n   asm (\"\tsw\t$7,12($30)\");\n   asm (\"\tj\t$31\");\n   asm (\"\t.end __builtin_saveregs\");\n-#else /* not __mips__, etc. */\n+#else /* not __mips__, etc.  */\n \n void *\n __builtin_saveregs ()\n@@ -1517,7 +1517,7 @@ __bb_exit_func (void)\n       /* We check the length field explicitly in order to allow compatibility\n \t with older GCC's which did not provide it.  */\n \n-      for (ptr = bb_head; ptr != (struct bb *)0; ptr = ptr->next)\n+      for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n \t{\n \t  int i;\n \t  int func_p\t= (ptr->nwords >= sizeof (struct bb) && ptr->nwords <= 1000);\n@@ -1609,7 +1609,7 @@ void\n __bb_init_func (struct bb *blocks)\n {\n   /* User is supposed to check whether the first word is non-0,\n-     but just in case.... */\n+     but just in case....  */\n \n   if (blocks->zero_word)\n     return;\n@@ -1635,16 +1635,16 @@ __bb_init_func (struct bb *blocks)\n \n #include <string.h>\n \n-/* Number of buckets in hashtable of basic block addresses. */\n+/* Number of buckets in hashtable of basic block addresses.  */\n \n #define BB_BUCKETS 311\n \n-/* Maximum length of string in file bb.in. */\n+/* Maximum length of string in file bb.in.  */\n \n #define BBINBUFSIZE 500\n \n /* BBINBUFSIZE-1 with double quotes. We could use #BBINBUFSIZE or\n-   \"BBINBUFSIZE\" but want to avoid trouble with preprocessors. */\n+   \"BBINBUFSIZE\" but want to avoid trouble with preprocessors.  */\n \n #define BBINBUFSIZESTR \"499\"\n \n@@ -1671,26 +1671,26 @@ struct bb_func\n \n /* This is the connection to the outside world.\n    The BLOCK_PROFILER macro must set __bb.blocks\n-   and __bb.blockno. */\n+   and __bb.blockno.  */\n \n struct {\n   unsigned long blockno;\n   struct bb *blocks;\n } __bb;\n \n /* Vars to store addrs of source and destination basic blocks \n-   of a jump. */\n+   of a jump.  */\n \n static unsigned long bb_src = 0;\n static unsigned long bb_dst = 0;\n \n-static FILE *bb_tracefile = (FILE*)0;\n-static struct bb_edge **bb_hashbuckets = (struct bb_edge**)0;\n-static struct bb_func *bb_func_head = (struct bb_func*)0;\n+static FILE *bb_tracefile = (FILE *) 0;\n+static struct bb_edge **bb_hashbuckets = (struct bb_edge **) 0;\n+static struct bb_func *bb_func_head = (struct bb_func *) 0;\n static unsigned long bb_callcount = 0;\n static int bb_mode = 0;\n \n-static unsigned long *bb_stack = (unsigned long *)0;\n+static unsigned long *bb_stack = (unsigned long *) 0;\n static size_t bb_stacksize = 0;\n \n static int reported = 0;\n@@ -1710,14 +1710,14 @@ bb_mode & 8 != 0   :   Insert return instructions in basic block flow.\n #include <sys/stat.h>\n /*#include <malloc.h>*/\n \n-/* Commands executed by gopen. */\n+/* Commands executed by gopen.  */\n \n #define GOPENDECOMPRESS \"gzip -cd \"\n #define GOPENCOMPRESS \"gzip -c >\"\n \n /* Like fopen but pipes through gzip.  mode may only be \"r\" or \"w\".\n    If it does not compile, simply replace gopen by fopen and delete\n-   '.gz' from any first parameter to gopen. */\n+   '.gz' from any first parameter to gopen.  */\n \n static FILE *\n gopen (fn, mode)\n@@ -1728,10 +1728,10 @@ gopen (fn, mode)\n   char *p;\n \n   if (mode[1])\n-    return (FILE*)0;\n+    return (FILE *) 0;\n \n   if (mode[0] != 'r' && mode[0] != 'w') \n-    return (FILE*)0;\n+    return (FILE *) 0;\n \n   p = fn + strlen (fn)-1;\n   use_gzip = ((p[-1] == '.' && (p[0] == 'Z' || p[0] == 'z')) ||\n@@ -1742,8 +1742,8 @@ gopen (fn, mode)\n       if (mode[0]=='r')\n         {\n           FILE *f;\n-          char *s = (char*) malloc (sizeof (char) * strlen (fn)\n-                                    + sizeof (GOPENDECOMPRESS));\n+          char *s = (char *) malloc (sizeof (char) * strlen (fn)\n+\t\t\t\t     + sizeof (GOPENDECOMPRESS));\n           strcpy (s, GOPENDECOMPRESS);\n           strcpy (s + (sizeof (GOPENDECOMPRESS)-1), fn);\n           f = popen (s, mode);\n@@ -1754,8 +1754,8 @@ gopen (fn, mode)\n       else\n         {\n           FILE *f;\n-          char *s = (char*) malloc (sizeof (char) * strlen (fn)\n-                                    + sizeof (GOPENCOMPRESS));\n+          char *s = (char *) malloc (sizeof (char) * strlen (fn)\n+\t\t\t\t     + sizeof (GOPENCOMPRESS));\n           strcpy (s, GOPENCOMPRESS);\n           strcpy (s + (sizeof (GOPENCOMPRESS)-1), fn);\n           if (!(f = popen (s, mode)))\n@@ -1787,7 +1787,7 @@ gclose (f)\n \n #endif /* HAVE_POPEN */\n \n-/* Called once per program. */\n+/* Called once per program.  */\n \n static void\n __bb_exit_trace_func ()\n@@ -1812,7 +1812,7 @@ __bb_exit_trace_func ()\n #endif /* HAVE_POPEN */\n     }\n \n-  /* Check functions in `bb.in'. */\n+  /* Check functions in `bb.in'.  */\n \n   if (file)\n     {\n@@ -1822,14 +1822,14 @@ __bb_exit_trace_func ()\n       struct bb *ptr;\n       long blk;\n \n-      /* This is somewhat type incorrect. */\n+      /* This is somewhat type incorrect.  */\n       time ((void *) &time_value);\n \n-      for (p = bb_func_head; p != (struct bb_func *)0; p = p->next)\n+      for (p = bb_func_head; p != (struct bb_func *) 0; p = p->next)\n         {\n-          for (ptr = bb_head; ptr != (struct bb *)0; ptr = ptr->next)\n+          for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n             {\n-              if (!ptr->filename || p->filename != (char *)0 && strcmp (p->filename, ptr->filename))\n+              if (!ptr->filename || p->filename != (char *) 0 && strcmp (p->filename, ptr->filename))\n                 continue;\n               for (blk = 0; blk < ptr->ncounts; blk++)\n                 {\n@@ -1894,7 +1894,7 @@ found:        ;\n               break;\n \n               case 4:\n-\t\t/* Print nothing. */\n+\t\t/* Print nothing.  */\n               break;\n \n               case 8:\n@@ -1945,7 +1945,7 @@ found:        ;\n    if (file)\n      fclose (file);\n \n-   /* Free allocated memory. */\n+   /* Free allocated memory.  */\n \n    f = bb_func_head;\n    while (f)\n@@ -1983,7 +1983,7 @@ found:        ;\n      if (b->flags) free (b->flags);\n }\n \n-/* Called once per program. */\n+/* Called once per program.  */\n \n static void\n __bb_init_prg ()\n@@ -2025,31 +2025,31 @@ __bb_init_prg ()\n         bb_mode |= 8;\n       else \n         {\n-          struct bb_func *f = (struct bb_func*) malloc (sizeof (struct bb_func));\n+          struct bb_func *f = (struct bb_func *) malloc (sizeof (struct bb_func));\n           if (f)\n             {\n               unsigned long l;\n               f->next = bb_func_head;\n               if (pos = strchr (p, ':'))\n                 {\n-                  if (!(f->funcname = (char*) malloc (strlen (pos+1)+1)))\n+                  if (!(f->funcname = (char *) malloc (strlen (pos+1)+1)))\n                     continue;\n                   strcpy (f->funcname, pos+1);\n                   l = pos-p;\n-                  if ((f->filename = (char*) malloc (l+1)))\n+                  if ((f->filename = (char *) malloc (l+1)))\n                     {\n                       strncpy (f->filename, p, l);\n                       f->filename[l] = '\\0';\n                     }\n                   else\n-                    f->filename = (char*)0;\n+                    f->filename = (char *) 0;\n                 }\n               else\n                 {\n-                  if (!(f->funcname = (char*) malloc (strlen (p)+1)))\n+                  if (!(f->funcname = (char *) malloc (strlen (p)+1)))\n                     continue;\n                   strcpy (f->funcname, p);\n-                  f->filename = (char*)0;\n+                  f->filename = (char *) 0;\n                 }\n               f->mode = m;\n               bb_func_head = f;\n@@ -2091,7 +2091,7 @@ __bb_init_prg ()\n \n }\n \n-/* Called upon entering a basic block. */\n+/* Called upon entering a basic block.  */\n \n void\n __bb_trace_func ()\n@@ -2116,7 +2116,7 @@ __bb_trace_func ()\n       struct bb_edge **startbucket, **oldnext;\n \n       oldnext = startbucket =\n-          & bb_hashbuckets[ (((int)bb_src*8)^(int)bb_dst) % BB_BUCKETS ];\n+          & bb_hashbuckets[ (((int) bb_src*8) ^ (int) bb_dst) % BB_BUCKETS ];\n       bucket = *startbucket;\n \n       for (bucket = *startbucket; bucket; \n@@ -2164,7 +2164,7 @@ __bb_trace_func ()\n \n }\n \n-/* Called when returning from a function and `__bb_showret__' is set. */\n+/* Called when returning from a function and `__bb_showret__' is set.  */\n \n static void\n __bb_trace_func_ret ()\n@@ -2179,7 +2179,7 @@ __bb_trace_func_ret ()\n       struct bb_edge **startbucket, **oldnext;\n \n       oldnext = startbucket =\n-          & bb_hashbuckets[ (((int)bb_dst*8)^(int)bb_src) % BB_BUCKETS ];\n+          & bb_hashbuckets[ (((int) bb_dst * 8) ^ (int) bb_src) % BB_BUCKETS ];\n       bucket = *startbucket;\n \n       for (bucket = *startbucket; bucket; \n@@ -2225,7 +2225,7 @@ __bb_trace_func_ret ()\n \n }\n \n-/* Called upon entering the first function of a file. */\n+/* Called upon entering the first function of a file.  */\n \n static void\n __bb_init_file (blocks)\n@@ -2243,7 +2243,7 @@ __bb_init_file (blocks)\n \n   blocks->flags = 0;\n   if (!bb_func_head ||\n-      !(blocks->flags = (char*) malloc (sizeof (char) * blocks->ncounts)))\n+      !(blocks->flags = (char *) malloc (sizeof (char) * blocks->ncounts)))\n     return;\n \n   for (blk = 0; blk < ncounts; blk++)\n@@ -2263,7 +2263,7 @@ __bb_init_file (blocks)\n \n }\n \n-/* Called when exiting from a function. */\n+/* Called when exiting from a function.  */\n \n void\n __bb_trace_ret ()\n@@ -2287,7 +2287,7 @@ __bb_trace_ret ()\n \n }\n \n-/* Called when entering a function. */\n+/* Called when entering a function.  */\n \n void\n __bb_init_trace_func (blocks, blockno)\n@@ -2360,11 +2360,11 @@ stack_overflow:;\n #endif /* L_bb */\n \f\n /* Default free-store management functions for C++, per sections 12.5 and\n-   17.3.3 of the Working Paper. */\n+   17.3.3 of the Working Paper.  */\n \n #ifdef L_op_new\n /* operator new (size_t), described in 17.3.3.5.  This function is used by\n-   C++ programs to allocate a block of memory to hold a single object. */\n+   C++ programs to allocate a block of memory to hold a single object.  */\n \n typedef void (*vfp)(void);\n extern vfp __new_handler;\n@@ -2420,7 +2420,7 @@ __builtin_vec_new (size_t sz)\n #ifdef L_new_handler\n /* set_new_handler (fvoid_t *) and the default new handler, described in\n    17.3.3.2 and 17.3.3.5.  These functions define the result of a failure\n-   to allocate the amount of memory requested from operator new or new []. */\n+   to allocate the amount of memory requested from operator new or new [].  */\n \n #ifndef inhibit_libc\n /* This gets us __GNU_LIBRARY__.  */\n@@ -2437,7 +2437,7 @@ __builtin_vec_new (size_t sz)\n typedef void (*vfp)(void);\n void __default_new_handler (void);\n \n-vfp __new_handler = (vfp)0;\n+vfp __new_handler = (vfp) 0;\n \n vfp\n set_new_handler (vfp handler)\n@@ -2470,7 +2470,7 @@ __default_new_handler ()\n #ifdef L_op_delete\n /* operator delete (void *), described in 17.3.3.3.  This function is used\n    by C++ programs to return to the free store a block of memory allocated\n-   as a single object. */\n+   as a single object.  */\n \n #ifdef WEAK_ALIAS\n void __builtin_delete (void *ptr)\n@@ -2490,7 +2490,7 @@ __builtin_delete (void *ptr)\n #ifdef L_op_vdel\n /* operator delete [] (void *), described in 17.3.3.4.  This function is\n    used by C++ programs to return to the free store a block of memory\n-   allocated as an array. */\n+   allocated as an array.  */\n \n extern void __builtin_delete (void *);\n \n@@ -2560,7 +2560,7 @@ __clear_cache (beg, end)\n \t    = JUMP_AHEAD_INSTRUCTION + INSN_CACHE_LINE_WIDTH;\n \t  ptr += INSN_CACHE_LINE_WIDTH;\n \t}\n-      *(INSTRUCTION_TYPE *)(ptr - INSN_CACHE_LINE_WIDTH) = RETURN_INSTRUCTION;\n+      *(INSTRUCTION_TYPE *) (ptr - INSN_CACHE_LINE_WIDTH) = RETURN_INSTRUCTION;\n \n       initialized = 1;\n     }\n@@ -2739,14 +2739,14 @@ __enable_execute_stack ()\n       lowest = current;\n     }\n \n-  /* Clear instruction cache in case an old trampoline is in it. */\n+  /* Clear instruction cache in case an old trampoline is in it.  */\n   asm (\"pich\");\n }\n #endif /* __convex__ */\n \n #ifdef __DOLPHIN__\n \n-/* Modified from the convex -code above. */\n+/* Modified from the convex -code above.  */\n \n #include <sys/param.h>\n #include <errno.h>\n@@ -2786,7 +2786,7 @@ __enable_execute_stack ()\n #include <sys/vmmac.h>\n \n /* Modified from the convex -code above.\n-   mremap promises to clear the i-cache. */\n+   mremap promises to clear the i-cache.  */\n \n void\n __enable_execute_stack ()\n@@ -2809,7 +2809,7 @@ __enable_execute_stack ()\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or neither. */\n+   must define both, or neither.  */\n #ifndef NAME__MAIN\n #define NAME__MAIN \"__main\"\n #define SYMBOL__MAIN __main\n@@ -3008,7 +3008,7 @@ static struct exception_table_node *exception_table_list;\n \n static exception_table *\n find_exception_table (pc)\n-     void* pc;\n+     void *pc;\n {\n   register struct exception_table_node *table = exception_table_list;\n   for ( ; table != 0; table = table->next)\n@@ -3041,9 +3041,7 @@ find_exception_table (pc)\n    return the tightest match...\n \n    In the advent of a tie, we have to give the last entry, as it represents\n-   an inner block.\n- */\n-\n+   an inner block.  */\n \n void *\n __find_first_exception_table_match(pc)\n@@ -3053,9 +3051,9 @@ void *pc;\n   int pos = 0;\n   int best = 0;\n   if (table == 0)\n-    return (void*)0;\n+    return (void *) 0;\n #if 0\n-  printf(\"find_first_exception_table_match(): pc = %x!\\n\",pc);\n+  printf (\"find_first_exception_table_match(): pc = %x!\\n\", pc);\n #endif\n \n   except_pc = pc;\n@@ -3068,24 +3066,24 @@ void *pc;\n       /* found the first table[pos].start > except_pc, so the previous\n \t entry better be the one we want! */\n       break;\n-  } while(table[pos].exception_handler != (void*)-1);\n+  } while (table[pos].exception_handler != (void *) -1);\n \n   --pos;\n   if (table[pos].start <= except_pc && table[pos].end > except_pc)\n     {\n       except_table_pos = pos;\n #if 0\n-      printf(\"find_first_eh_table_match(): found match: %x\\n\",table[pos].exception_handler);\n+      printf (\"find_first_eh_table_match(): found match: %x\\n\", table[pos].exception_handler);\n #endif\n       return table[pos].exception_handler;\n     }\n #else\n-  while (table[++pos].exception_handler != (void*)-1) {\n+  while (table[++pos].exception_handler != (void *) -1) {\n     if (table[pos].start <= except_pc && table[pos].end > except_pc)\n       {\n \t/* This can apply.  Make sure it is better or as good as the previous\n \t   best.  */\n-\t/* The best one ends first. */\n+\t/* The best one ends first.  */\n \tif (best == 0 || (table[pos].end <= table[best].end\n \t\t\t  /* The best one starts last.  */\n \t\t\t  && table[pos].start >= table[best].start))\n@@ -3120,18 +3118,18 @@ __register_exceptions (exception_table *table)\n   struct exception_table_node *node;\n   exception_table *range = table + 1;\n \n-  if (range->start == (void*)-1)\n+  if (range->start == (void *) -1)\n     return;\n \n-  node = (struct exception_table_node*)\n+  node = (struct exception_table_node *)\n     malloc (sizeof (struct exception_table_node));\n   node->table = table;\n \n   /* This look can be optimized away either if the table\n-     is sorted, or if we pass in extra parameters. */\n+     is sorted, or if we pass in extra parameters.  */\n   node->start = range->start;\n   node->end = range->end;\n-  for (range++ ; range->start != (void*)(-1); range++)\n+  for (range++ ; range->start != (void *) (-1); range++)\n     {\n       if (range->start < node->start)\n \tnode->start = range->start;\n@@ -3159,9 +3157,9 @@ __unwind_function(void *ptr)\n   /* like ret, but stay here */\n   asm(\"addl $4,%esp\");\n   \n-  /* Now, undo previous frame. */\n+  /* Now, undo previous frame.  */\n   /* This is a test routine, as we have to dynamically probe to find out\n-     what to pop for certain, this is just a guess. */\n+     what to pop for certain, this is just a guess.  */\n   asm(\"leal -16(%ebp),%esp\");\n   asm(\"pop %ebx\");\n   asm(\"pop %esi\");\n@@ -3182,7 +3180,7 @@ __unwind_function(void *ptr)\n \n   asm(\"mr 31,1\");\n   asm(\"l 1,0(1)\");\n-  /* use 31 as a scratch register to restore the link register. */\n+  /* use 31 as a scratch register to restore the link register.  */\n   asm(\"l 31, 8(1);mtlr 31 # l lr,8(1)\");\n   asm(\"l 31,-4(1)\");\n   asm(\"# br\");\n@@ -3198,7 +3196,7 @@ __unwind_function(void *ptr)\n \n   asm(\"mr 31,1\");\n   asm(\"lwz 1,0(1)\");\n-  /* use 31 as a scratch register to restore the link register. */\n+  /* use 31 as a scratch register to restore the link register.  */\n   asm(\"lwz 31, 8(1);mtlr 31 # l lr,8(1)\");\n   asm(\"lwz 31,-4(1)\");\n   asm(\"# br\");"}, {"sha": "156fe92d53748dd097a46ec5088f20315768a4ee", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -103,7 +103,7 @@ static HARD_REG_SET *qty_phys_sugg;\n \n static short *qty_phys_num_copy_sugg;\n \n-/* Element Q is the number of suggested registers in qty_phys_sugg. */\n+/* Element Q is the number of suggested registers in qty_phys_sugg.  */\n \n static short *qty_phys_num_sugg;\n \n@@ -737,7 +737,7 @@ optimize_reg_copy_1 (insn, dest, src)\n \tbreak;\n \n       /* See if all of SRC dies in P.  This test is slightly more\n-\t conservative than it needs to be. */\n+\t conservative than it needs to be.  */\n       if ((note = find_regno_note (p, REG_DEAD, sregno)) != 0\n \t  && GET_MODE (XEXP (note, 0)) == GET_MODE (src))\n \t{\n@@ -1461,13 +1461,13 @@ block_alloc (b)\n       if (qty_sugg_compare (1, 2) > 0)\n \tEXCHANGE (2, 1);\n \n-      /* ... Fall through ... */\n+      /* ... Fall through ...  */\n     case 2:\n       /* Put the best one to allocate in qty_order[0].  */\n       if (qty_sugg_compare (0, 1) > 0)\n \tEXCHANGE (0, 1);\n \n-      /* ... Fall through ... */\n+      /* ... Fall through ...  */\n \n     case 1:\n     case 0:\n@@ -1510,13 +1510,13 @@ block_alloc (b)\n       if (qty_compare (1, 2) > 0)\n \tEXCHANGE (2, 1);\n \n-      /* ... Fall through ... */\n+      /* ... Fall through ...  */\n     case 2:\n       /* Put the best one to allocate in qty_order[0].  */\n       if (qty_compare (0, 1) > 0)\n \tEXCHANGE (0, 1);\n \n-      /* ... Fall through ... */\n+      /* ... Fall through ...  */\n \n     case 1:\n     case 0:\n@@ -1782,7 +1782,7 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n       || (offset > 0 && usize + offset > ssize)\n       || (offset < 0 && usize + offset < ssize)\n       /* Do not combine with a smaller already-assigned object\n-\t if that smaller object is already combined with something bigger. */\n+\t if that smaller object is already combined with something bigger.  */\n       || (ssize > usize && ureg >= FIRST_PSEUDO_REGISTER\n \t  && usize < qty_size[reg_qty[ureg]])\n       /* Can't combine if SREG is not a register we can allocate.  */\n@@ -2139,7 +2139,7 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n     SET_HARD_REG_BIT (used, eliminables[i].from);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n   /* If FRAME_POINTER_REGNUM is not a real register, then protect the one\n-     that it might be eliminated into. */\n+     that it might be eliminated into.  */\n   SET_HARD_REG_BIT (used, HARD_FRAME_POINTER_REGNUM);\n #endif\n #else"}, {"sha": "9d369de12456a58297c26a722baed1f5fcac59ce", "filename": "gcc/longlong.h", "status": "modified", "additions": 264, "deletions": 264, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -165,11 +165,11 @@\n \taddcs\t%0, %0, #65536\n \tadds\t%1, %1, %3, lsl #16\n \tadc\t%0, %0, %3, lsr #16\"\t\t\t\t\t\\\n-\t   : \"=&r\" ((USItype)(xh)),\t\t\t\t\t\\\n-\t     \"=r\" ((USItype)(xl)),\t\t\t\t\t\\\n+\t   : \"=&r\" ((USItype) (xh)),\t\t\t\t\t\\\n+\t     \"=r\" ((USItype) (xl)),\t\t\t\t\t\\\n \t     \"=&r\" (__t0), \"=&r\" (__t1), \"=r\" (__t2)\t\t\t\\\n-\t   : \"r\" ((USItype)(a)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(b)));}\n+\t   : \"r\" ((USItype) (a)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (b)));}\n #define UMUL_TIME 20\n #define UDIV_TIME 100\n #endif /* __arm__ */\n@@ -181,85 +181,85 @@\n \t  } __xx;\t\t\t\t\t\t\t\\\n   __asm__ (\"mulwux %2,%0\"\t\t\t\t\t\t\\\n \t   : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(v)));\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (v)));\t\t\t\t\t\\\n   (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n #define smul_ppmm(w1, w0, u, v) \\\n   ({union {DItype __ll;\t\t\t\t\t\t\t\\\n \t   struct {SItype __l, __h;} __i;\t\t\t\t\\\n \t  } __xx;\t\t\t\t\t\t\t\\\n   __asm__ (\"mulwx %2,%0\"\t\t\t\t\t\t\\\n \t   : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n-\t   : \"%0\" ((SItype)(u)),\t\t\t\t\t\\\n-\t     \"r\" ((SItype)(v)));\t\t\t\t\t\\\n+\t   : \"%0\" ((SItype) (u)),\t\t\t\t\t\\\n+\t     \"r\" ((SItype) (v)));\t\t\t\t\t\\\n   (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n #define __umulsidi3(u, v) \\\n   ({UDItype __w;\t\t\t\t\t\t\t\\\n     __asm__ (\"mulwux %2,%0\"\t\t\t\t\t\t\\\n \t     : \"=r\" (__w)\t\t\t\t\t\t\\\n-\t     : \"%0\" ((USItype)(u)),\t\t\t\t\t\\\n-\t       \"r\" ((USItype)(v)));\t\t\t\t\t\\\n+\t     : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n+\t       \"r\" ((USItype) (v)));\t\t\t\t\t\\\n     __w; })\n #endif /* __clipper__ */\n \n #if defined (__gmicro__)\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"add.w %5,%1\n \taddx %3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=g\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&g\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"sub.w %5,%1\n \tsubx %3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=g\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&g\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #define umul_ppmm(ph, pl, m0, m1) \\\n   __asm__ (\"mulx %3,%0,%1\"\t\t\t\t\t\t\\\n-\t   : \"=g\" ((USItype)(ph)),\t\t\t\t\t\\\n-\t     \"=r\" ((USItype)(pl))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(m0)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(m1)))\n+\t   : \"=g\" ((USItype) (ph)),\t\t\t\t\t\\\n+\t     \"=r\" ((USItype) (pl))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (m0)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (m1)))\n #define udiv_qrnnd(q, r, nh, nl, d) \\\n   __asm__ (\"divx %4,%0,%1\"\t\t\t\t\t\t\\\n-\t   : \"=g\" ((USItype)(q)),\t\t\t\t\t\\\n-\t     \"=r\" ((USItype)(r))\t\t\t\t\t\\\n-\t   : \"1\" ((USItype)(nh)),\t\t\t\t\t\\\n-\t     \"0\" ((USItype)(nl)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(d)))\n+\t   : \"=g\" ((USItype) (q)),\t\t\t\t\t\\\n+\t     \"=r\" ((USItype) (r))\t\t\t\t\t\\\n+\t   : \"1\" ((USItype) (nh)),\t\t\t\t\t\\\n+\t     \"0\" ((USItype) (nl)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (d)))\n #define count_leading_zeros(count, x) \\\n   __asm__ (\"bsch/1 %1,%0\"\t\t\t\t\t\t\\\n \t   : \"=g\" (count)\t\t\t\t\t\t\\\n-\t   : \"g\" ((USItype)(x)),\t\t\t\t\t\\\n-\t     \"0\" ((USItype)0))\n+\t   : \"g\" ((USItype) (x)),\t\t\t\t\t\\\n+\t     \"0\" ((USItype) 0))\n #endif\n \n #if defined (__hppa)\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"add %4,%5,%1\n \taddc %2,%3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%rM\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"rM\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%rM\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"rM\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%rM\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"rM\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%rM\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"rM\" ((USItype) (bl)))\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"sub %4,%5,%1\n \tsubb %2,%3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"rM\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"rM\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"rM\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"rM\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"rM\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"rM\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"rM\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"rM\" ((USItype) (bl)))\n #if defined (_PA_RISC1_1)\n #define umul_ppmm(w1, w0, u, v) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -270,8 +270,8 @@\n       } __t;\t\t\t\t\t\t\t\t\\\n     __asm__ (\"xmpyu %1,%2,%0\"\t\t\t\t\t\t\\\n \t     : \"=x\" (__t.__f)\t\t\t\t\t\t\\\n-\t     : \"x\" ((USItype)(u)),\t\t\t\t\t\\\n-\t       \"x\" ((USItype)(v)));\t\t\t\t\t\\\n+\t     : \"x\" ((USItype) (u)),\t\t\t\t\t\\\n+\t       \"x\" ((USItype) (v)));\t\t\t\t\t\\\n     (w1) = __t.__w1w0.__w1;\t\t\t\t\t\t\\\n     (w0) = __t.__w1w0.__w0;\t\t\t\t\t\t\\\n      } while (0)\n@@ -307,39 +307,39 @@\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addl %5,%1\n \tadcl %3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"subl %5,%1\n \tsbbl %3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #define umul_ppmm(w1, w0, u, v) \\\n   __asm__ (\"mull %3\"\t\t\t\t\t\t\t\\\n-\t   : \"=a\" ((USItype)(w0)),\t\t\t\t\t\\\n-\t     \"=d\" ((USItype)(w1))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"rm\" ((USItype)(v)))\n+\t   : \"=a\" ((USItype) (w0)),\t\t\t\t\t\\\n+\t     \"=d\" ((USItype) (w1))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"rm\" ((USItype) (v)))\n #define udiv_qrnnd(q, r, n1, n0, d) \\\n   __asm__ (\"divl %4\"\t\t\t\t\t\t\t\\\n-\t   : \"=a\" ((USItype)(q)),\t\t\t\t\t\\\n-\t     \"=d\" ((USItype)(r))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(n0)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(n1)),\t\t\t\t\t\\\n-\t     \"rm\" ((USItype)(d)))\n+\t   : \"=a\" ((USItype) (q)),\t\t\t\t\t\\\n+\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n+\t     \"rm\" ((USItype) (d)))\n #define count_leading_zeros(count, x) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     USItype __cbtmp;\t\t\t\t\t\t\t\\\n     __asm__ (\"bsrl %1,%0\"\t\t\t\t\t\t\\\n-\t     : \"=r\" (__cbtmp) : \"rm\" ((USItype)(x)));\t\t\t\\\n+\t     : \"=r\" (__cbtmp) : \"rm\" ((USItype) (x)));\t\t\t\\\n     (count) = __cbtmp ^ 31;\t\t\t\t\t\t\\\n   } while (0)\n #define UMUL_TIME 40\n@@ -394,64 +394,64 @@\n \t  } __xx;\t\t\t\t\t\t\t\\\n   __asm__ (\"emul\t%2,%1,%0\"\t\t\t\t\t\\\n \t   : \"=d\" (__xx.__ll)\t\t\t\t\t\t\\\n-\t   : \"%dI\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"dI\" ((USItype)(v)));\t\t\t\t\t\\\n+\t   : \"%dI\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"dI\" ((USItype) (v)));\t\t\t\t\t\\\n   (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n #define __umulsidi3(u, v) \\\n   ({UDItype __w;\t\t\t\t\t\t\t\\\n     __asm__ (\"emul\t%2,%1,%0\"\t\t\t\t\t\\\n \t     : \"=d\" (__w)\t\t\t\t\t\t\\\n-\t     : \"%dI\" ((USItype)(u)),\t\t\t\t\t\\\n-\t       \"dI\" ((USItype)(v)));\t\t\t\t\t\\\n+\t     : \"%dI\" ((USItype) (u)),\t\t\t\t\t\\\n+\t       \"dI\" ((USItype) (v)));\t\t\t\t\t\\\n     __w; })  \n #endif /* __i960__ */\n \n #if defined (__mc68000__)\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"add%.l %5,%1\n \taddx%.l %3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=d\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&d\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"d\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=d\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&d\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"d\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"sub%.l %5,%1\n \tsubx%.l %3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=d\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&d\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"d\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=d\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&d\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"d\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #if defined (__mc68020__) || defined (__NeXT__) || defined(mc68020)\n #define umul_ppmm(w1, w0, u, v) \\\n   __asm__ (\"mulu%.l %3,%1:%0\"\t\t\t\t\t\t\\\n-\t   : \"=d\" ((USItype)(w0)),\t\t\t\t\t\\\n-\t     \"=d\" ((USItype)(w1))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"dmi\" ((USItype)(v)))\n+\t   : \"=d\" ((USItype) (w0)),\t\t\t\t\t\\\n+\t     \"=d\" ((USItype) (w1))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"dmi\" ((USItype) (v)))\n #define UMUL_TIME 45\n #define udiv_qrnnd(q, r, n1, n0, d) \\\n   __asm__ (\"divu%.l %4,%1:%0\"\t\t\t\t\t\t\\\n-\t   : \"=d\" ((USItype)(q)),\t\t\t\t\t\\\n-\t     \"=d\" ((USItype)(r))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(n0)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(n1)),\t\t\t\t\t\\\n-\t     \"dmi\" ((USItype)(d)))\n+\t   : \"=d\" ((USItype) (q)),\t\t\t\t\t\\\n+\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n+\t     \"dmi\" ((USItype) (d)))\n #define UDIV_TIME 90\n #define sdiv_qrnnd(q, r, n1, n0, d) \\\n   __asm__ (\"divs%.l %4,%1:%0\"\t\t\t\t\t\t\\\n-\t   : \"=d\" ((USItype)(q)),\t\t\t\t\t\\\n-\t     \"=d\" ((USItype)(r))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(n0)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(n1)),\t\t\t\t\t\\\n-\t     \"dmi\" ((USItype)(d)))\n+\t   : \"=d\" ((USItype) (q)),\t\t\t\t\t\\\n+\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n+\t     \"dmi\" ((USItype) (d)))\n #define count_leading_zeros(count, x) \\\n   __asm__ (\"bfffo %1{%b2:%b2},%0\"\t\t\t\t\t\\\n-\t   : \"=d\" ((USItype)(count))\t\t\t\t\t\\\n-\t   : \"od\" ((USItype)(x)), \"n\" (0))\n+\t   : \"=d\" ((USItype) (count))\t\t\t\t\t\\\n+\t   : \"od\" ((USItype) (x)), \"n\" (0))\n #else /* not mc68020 */\n /* %/ inserts REGISTER_PREFIX, %# inserts IMMEDIATE_PREFIX.  */\n #define umul_ppmm(xh, xl, a, b) \\\n@@ -481,10 +481,10 @@\n \tmove%.l\t%/d2,%1\n \tadd%.l\t%/d1,%/d0\n \tmove%.l\t%/d0,%0\"\t\t\t\t\t\t\\\n-\t   : \"=g\" ((USItype)(xh)),\t\t\t\t\t\\\n-\t     \"=g\" ((USItype)(xl))\t\t\t\t\t\\\n-\t   : \"g\" ((USItype)(a)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(b))\t\t\t\t\t\t\\\n+\t   : \"=g\" ((USItype) (xh)),\t\t\t\t\t\\\n+\t     \"=g\" ((USItype) (xl))\t\t\t\t\t\\\n+\t   : \"g\" ((USItype) (a)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (b))\t\t\t\t\t\t\\\n \t   : \"d0\", \"d1\", \"d2\", \"d3\", \"d4\")\n #define UMUL_TIME 100\n #define UDIV_TIME 400\n@@ -495,27 +495,27 @@\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addu.co %1,%r4,%r5\n \taddu.ci %0,%r2,%r3\"\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%rJ\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"rJ\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%rJ\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"rJ\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"rJ\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%rJ\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"rJ\" ((USItype) (bl)))\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"subu.co %1,%r4,%r5\n \tsubu.ci %0,%r2,%r3\"\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"rJ\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"rJ\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"rJ\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"rJ\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"rJ\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"rJ\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"rJ\" ((USItype) (bl)))\n #define count_leading_zeros(count, x) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     USItype __cbtmp;\t\t\t\t\t\t\t\\\n     __asm__ (\"ff1 %0,%1\"\t\t\t\t\t\t\\\n \t     : \"=r\" (__cbtmp)\t\t\t\t\t\t\\\n-\t     : \"r\" ((USItype)(x)));\t\t\t\t\t\\\n+\t     : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n     (count) = __cbtmp ^ 31;\t\t\t\t\t\t\\\n   } while (0)\n #if defined (__mc88110__)\n@@ -526,8 +526,8 @@\n \t  } __xx;\t\t\t\t\t\t\t\\\n     __asm__ (\"mulu.d\t%0,%1,%2\"\t\t\t\t\t\\\n \t     : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n-\t     : \"r\" ((USItype)(u)),\t\t\t\t\t\\\n-\t       \"r\" ((USItype)(v)));\t\t\t\t\t\\\n+\t     : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n+\t       \"r\" ((USItype) (v)));\t\t\t\t\t\\\n     (wh) = __xx.__i.__h;\t\t\t\t\t\t\\\n     (wl) = __xx.__i.__l;\t\t\t\t\t\t\\\n   } while (0)\n@@ -540,7 +540,7 @@\n   __asm__ (\"divu.d %0,%1,%2\"\t\t\t\t\t\t\\\n \t   : \"=r\" (__q)\t\t\t\t\t\t\t\\\n \t   : \"r\" (__xx.__ll),\t\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(d)));\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (d)));\t\t\t\t\t\\\n   (r) = (n0) - __q * (d); (q) = __q; })\n #define UMUL_TIME 5\n #define UDIV_TIME 25\n@@ -553,10 +553,10 @@\n #if defined (__mips__)\n #define umul_ppmm(w1, w0, u, v) \\\n   __asm__ (\"multu %2,%3\"\t\t\t\t\t\t\\\n-\t   : \"=l\" ((USItype)(w0)),\t\t\t\t\t\\\n-\t     \"=h\" ((USItype)(w1))\t\t\t\t\t\\\n-\t   : \"d\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"d\" ((USItype)(v)))\n+\t   : \"=l\" ((USItype) (w0)),\t\t\t\t\t\\\n+\t     \"=h\" ((USItype) (w1))\t\t\t\t\t\\\n+\t   : \"d\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"d\" ((USItype) (v)))\n #define UMUL_TIME 10\n #define UDIV_TIME 100\n #endif /* __mips__ */\n@@ -568,15 +568,15 @@\n \t  } __xx;\t\t\t\t\t\t\t\\\n   __asm__ (\"meid %2,%0\"\t\t\t\t\t\t\t\\\n \t   : \"=g\" (__xx.__ll)\t\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(v)));\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (v)));\t\t\t\t\t\\\n   (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n #define __umulsidi3(u, v) \\\n   ({UDItype __w;\t\t\t\t\t\t\t\\\n     __asm__ (\"meid %2,%0\"\t\t\t\t\t\t\\\n \t     : \"=g\" (__w)\t\t\t\t\t\t\\\n-\t     : \"%0\" ((USItype)(u)),\t\t\t\t\t\\\n-\t       \"g\" ((USItype)(v)));\t\t\t\t\t\\\n+\t     : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n+\t       \"g\" ((USItype) (v)));\t\t\t\t\t\\\n     __w; })\n #define udiv_qrnnd(q, r, n1, n0, d) \\\n   ({union {UDItype __ll;\t\t\t\t\t\t\\\n@@ -586,7 +586,7 @@\n   __asm__ (\"deid %2,%0\"\t\t\t\t\t\t\t\\\n \t   : \"=g\" (__xx.__ll)\t\t\t\t\t\t\\\n \t   : \"0\" (__xx.__ll),\t\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(d)));\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (d)));\t\t\t\t\t\\\n   (r) = __xx.__i.__l; (q) = __xx.__i.__h; })\n #endif /* __ns32000__ */\n \n@@ -595,70 +595,70 @@\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (__builtin_constant_p (bh) && (bh) == 0)\t\t\t\t\\\n       __asm__ (\"{a%I4|add%I4c} %1,%3,%4\\n\\t{aze|addze} %0,%2\"\t\t\\\n-\t     : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t       \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t     : \"%r\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t       \"%r\" ((USItype)(al)),\t\t\t\t\t\\\n-\t       \"rI\" ((USItype)(bl)));\t\t\t\t\t\\\n+\t     : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t       \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t     : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t       \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n+\t       \"rI\" ((USItype) (bl)));\t\t\t\t\t\\\n     else if (__builtin_constant_p (bh) && (bh) ==~(USItype) 0)\t\t\\\n       __asm__ (\"{a%I4|add%I4c} %1,%3,%4\\n\\t{ame|addme} %0,%2\"\t\t\\\n-\t     : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t       \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t     : \"%r\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t       \"%r\" ((USItype)(al)),\t\t\t\t\t\\\n-\t       \"rI\" ((USItype)(bl)));\t\t\t\t\t\\\n+\t     : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t       \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t     : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t       \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n+\t       \"rI\" ((USItype) (bl)));\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       __asm__ (\"{a%I5|add%I5c} %1,%4,%5\\n\\t{ae|adde} %0,%2,%3\"\t\t\\\n-\t     : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t       \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t     : \"%r\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t       \"r\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t       \"%r\" ((USItype)(al)),\t\t\t\t\t\\\n-\t       \"rI\" ((USItype)(bl)));\t\t\t\t\t\\\n+\t     : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t       \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t     : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t       \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t       \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n+\t       \"rI\" ((USItype) (bl)));\t\t\t\t\t\\\n   } while (0)\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (__builtin_constant_p (ah) && (ah) == 0)\t\t\t\t\\\n       __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{sfze|subfze} %0,%2\"\t\\\n-\t       : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t\t \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t       : \"r\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t\t \"rI\" ((USItype)(al)),\t\t\t\t\t\\\n-\t\t \"r\" ((USItype)(bl)));\t\t\t\t\t\\\n+\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t       : \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n+\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n     else if (__builtin_constant_p (ah) && (ah) ==~(USItype) 0)\t\t\\\n       __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{sfme|subfme} %0,%2\"\t\\\n-\t       : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t\t \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t       : \"r\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t\t \"rI\" ((USItype)(al)),\t\t\t\t\t\\\n-\t\t \"r\" ((USItype)(bl)));\t\t\t\t\t\\\n+\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t       : \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n+\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n     else if (__builtin_constant_p (bh) && (bh) == 0)\t\t\t\\\n       __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{ame|addme} %0,%2\"\t\t\\\n-\t       : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t\t \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t       : \"r\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t\t \"rI\" ((USItype)(al)),\t\t\t\t\t\\\n-\t\t \"r\" ((USItype)(bl)));\t\t\t\t\t\\\n+\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t       : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n+\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n     else if (__builtin_constant_p (bh) && (bh) ==~(USItype) 0)\t\t\\\n       __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{aze|addze} %0,%2\"\t\t\\\n-\t       : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t\t \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t       : \"r\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t\t \"rI\" ((USItype)(al)),\t\t\t\t\t\\\n-\t\t \"r\" ((USItype)(bl)));\t\t\t\t\t\\\n+\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t       : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n+\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       __asm__ (\"{sf%I4|subf%I4c} %1,%5,%4\\n\\t{sfe|subfe} %0,%3,%2\"\t\\\n-\t       : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t\t \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t       : \"r\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t\t \"r\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t\t \"rI\" ((USItype)(al)),\t\t\t\t\t\\\n-\t\t \"r\" ((USItype)(bl)));\t\t\t\t\t\\\n+\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t       : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t\t \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n+\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n   } while (0)\n #define count_leading_zeros(count, x) \\\n   __asm__ (\"{cntlz|cntlzw} %0,%1\"\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(count))\t\t\t\t\t\\\n-\t   : \"r\" ((USItype)(x)))\n+\t   : \"=r\" ((USItype) (count))\t\t\t\t\t\\\n+\t   : \"r\" ((USItype) (x)))\n #if defined (_ARCH_PPC)\n #define umul_ppmm(ph, pl, m0, m1) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -686,8 +686,8 @@\n   do {\t\t\t\t\t\t\t\t\t\\\n     USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n     __asm__ (\"mul %0,%2,%3\"\t\t\t\t\t\t\\\n-\t     : \"=r\" ((USItype)(xh)),\t\t\t\t\t\\\n-\t       \"=q\" ((USItype)(xl))\t\t\t\t\t\\\n+\t     : \"=r\" ((USItype) (xh)),\t\t\t\t\t\\\n+\t       \"=q\" ((USItype) (xl))\t\t\t\t\t\\\n \t     : \"r\" (__m0),\t\t\t\t\t\t\\\n \t       \"r\" (__m1));\t\t\t\t\t\t\\\n     (xh) += ((((SItype) __m0 >> 31) & __m1)\t\t\t\t\\\n@@ -696,15 +696,15 @@\n #define UMUL_TIME 8\n #define smul_ppmm(xh, xl, m0, m1) \\\n   __asm__ (\"mul %0,%2,%3\"\t\t\t\t\t\t\\\n-\t   : \"=r\" ((SItype)(xh)),\t\t\t\t\t\\\n-\t     \"=q\" ((SItype)(xl))\t\t\t\t\t\\\n+\t   : \"=r\" ((SItype) (xh)),\t\t\t\t\t\\\n+\t     \"=q\" ((SItype) (xl))\t\t\t\t\t\\\n \t   : \"r\" (m0),\t\t\t\t\t\t\t\\\n \t     \"r\" (m1))\n #define SMUL_TIME 4\n #define sdiv_qrnnd(q, r, nh, nl, d) \\\n   __asm__ (\"div %0,%2,%4\"\t\t\t\t\t\t\\\n-\t   : \"=r\" ((SItype)(q)), \"=q\" ((SItype)(r))\t\t\t\\\n-\t   : \"r\" ((SItype)(nh)), \"1\" ((SItype)(nl)), \"r\" ((SItype)(d)))\n+\t   : \"=r\" ((SItype) (q)), \"=q\" ((SItype) (r))\t\t\t\\\n+\t   : \"r\" ((SItype) (nh)), \"1\" ((SItype) (nl)), \"r\" ((SItype) (d)))\n #define UDIV_TIME 100\n #endif\n #endif /* Power architecture variants.  */\n@@ -713,21 +713,21 @@\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addw\t%5,%1\n \taddwc\t%3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"subw\t%5,%1\n \tsubwb\t%3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n /* This insn works on Pyramids with AP, XP, or MI CPUs, but not with SP.  */\n #define umul_ppmm(w1, w0, u, v) \\\n   ({union {UDItype __ll;\t\t\t\t\t\t\\\n@@ -737,29 +737,29 @@\n \tuemul %2,%0\"\t\t\t\t\t\t\t\\\n \t   : \"=&r\" (__xx.__ll)\t\t\t\t\t\t\\\n \t   : \"g\" ((USItype) (u)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(v)));\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (v)));\t\t\t\t\t\\\n   (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n #endif /* __pyr__ */\n \n #if defined (__ibm032__) /* RT/ROMP */\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"a %1,%5\n \tae %0,%3\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (bl)))\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"s %1,%5\n \tse %0,%3\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(bl)))\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (bl)))\n #define umul_ppmm(ph, pl, m0, m1) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n@@ -784,8 +784,8 @@\n \tm\tr2,%3\n \tcas\t%0,r2,r0\n \tmfs\tr10,%1\"\t\t\t\t\t\t\t\\\n-\t     : \"=r\" ((USItype)(ph)),\t\t\t\t\t\\\n-\t       \"=r\" ((USItype)(pl))\t\t\t\t\t\\\n+\t     : \"=r\" ((USItype) (ph)),\t\t\t\t\t\\\n+\t       \"=r\" ((USItype) (pl))\t\t\t\t\t\\\n \t     : \"%r\" (__m0),\t\t\t\t\t\t\\\n \t\t\"r\" (__m1)\t\t\t\t\t\t\\\n \t     : \"r2\");\t\t\t\t\t\t\t\\\n@@ -798,13 +798,13 @@\n   do {\t\t\t\t\t\t\t\t\t\\\n     if ((x) >= 0x10000)\t\t\t\t\t\t\t\\\n       __asm__ (\"clz\t%0,%1\"\t\t\t\t\t\t\\\n-\t       : \"=r\" ((USItype)(count))\t\t\t\t\\\n-\t       : \"r\" ((USItype)(x) >> 16));\t\t\t\t\\\n+\t       : \"=r\" ((USItype) (count))\t\t\t\t\\\n+\t       : \"r\" ((USItype) (x) >> 16));\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \t__asm__ (\"clz\t%0,%1\"\t\t\t\t\t\t\\\n-\t\t : \"=r\" ((USItype)(count))\t\t\t\t\\\n-\t\t : \"r\" ((USItype)(x)));\t\t\t\t\t\\\n+\t\t : \"=r\" ((USItype) (count))\t\t\t\t\\\n+\t\t : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n \t(count) += 16;\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n@@ -814,47 +814,47 @@\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addcc %r4,%5,%1\n \taddx %r2,%3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%rJ\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"rI\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%rJ\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"rI\" ((USItype)(bl))\t\t\t\t\t\\\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%rJ\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"rI\" ((USItype) (bl))\t\t\t\t\t\\\n \t   __CLOBBER_CC)\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"subcc %r4,%5,%1\n \tsubx %r2,%3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"rJ\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"rI\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"rJ\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"rI\" ((USItype)(bl))\t\t\t\t\t\\\n+\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"rJ\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"rI\" ((USItype) (bl))\t\t\t\t\t\\\n \t   __CLOBBER_CC)\n #if defined (__sparc_v8__)\n #define umul_ppmm(w1, w0, u, v) \\\n   __asm__ (\"umul %2,%3,%1;rd %%y,%0\"\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(w1)),\t\t\t\t\t\\\n-\t     \"=r\" ((USItype)(w0))\t\t\t\t\t\\\n-\t   : \"r\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(v)))\n+\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n+\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n+\t   : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (v)))\n #define udiv_qrnnd(q, r, n1, n0, d) \\\n   __asm__ (\"mov %2,%%y;nop;nop;nop;udiv %3,%4,%0;umul %0,%4,%1;sub %3,%1,%1\"\\\n-\t   : \"=&r\" ((USItype)(q)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(r))\t\t\t\t\t\\\n-\t   : \"r\" ((USItype)(n1)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(n0)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(d)))\n+\t   : \"=&r\" ((USItype) (q)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (r))\t\t\t\t\t\\\n+\t   : \"r\" ((USItype) (n1)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (n0)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (d)))\n #else\n #if defined (__sparclite__)\n /* This has hardware multiply but not divide.  It also has two additional\n    instructions scan (ffs from high bit) and divscc.  */\n #define umul_ppmm(w1, w0, u, v) \\\n   __asm__ (\"umul %2,%3,%1;rd %%y,%0\"\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(w1)),\t\t\t\t\t\\\n-\t     \"=r\" ((USItype)(w0))\t\t\t\t\t\\\n-\t   : \"r\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(v)))\n+\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n+\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n+\t   : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (v)))\n #define udiv_qrnnd(q, r, n1, n0, d) \\\n   __asm__ (\"! Inlined udiv_qrnnd\n \twr\t%%g0,%2,%%y\t! Not a delayed write for sparclite\n@@ -895,17 +895,17 @@\n \tbl,a 1f\n \tadd\t%1,%4,%1\n 1:\t! End of inline udiv_qrnnd\"\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(q)),\t\t\t\t\t\\\n-\t     \"=r\" ((USItype)(r))\t\t\t\t\t\\\n-\t   : \"r\" ((USItype)(n1)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(n0)),\t\t\t\t\t\\\n-\t     \"rI\" ((USItype)(d))\t\t\t\t\t\\\n+\t   : \"=r\" ((USItype) (q)),\t\t\t\t\t\\\n+\t     \"=r\" ((USItype) (r))\t\t\t\t\t\\\n+\t   : \"r\" ((USItype) (n1)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (n0)),\t\t\t\t\t\\\n+\t     \"rI\" ((USItype) (d))\t\t\t\t\t\\\n \t   : \"%g1\" __AND_CLOBBER_CC)\n #define UDIV_TIME 37\n #define count_leading_zeros(count, x) \\\n   __asm__ (\"scan %1,0,%0\"\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(x))\t\t\t\t\t\\\n-\t   : \"r\" ((USItype)(count)))\n+\t   : \"=r\" ((USItype) (x))\t\t\t\t\t\\\n+\t   : \"r\" ((USItype) (count)))\n #else\n /* SPARC without integer multiplication and divide instructions.\n    (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */\n@@ -950,10 +950,10 @@\n \tmulscc\t%%g1,0,%%g1\n \tadd\t%%g1,%%g2,%0\n \trd\t%%y,%1\"\t\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype)(w1)),\t\t\t\t\t\\\n-\t     \"=r\" ((USItype)(w0))\t\t\t\t\t\\\n-\t   : \"%rI\" ((USItype)(u)),\t\t\t\t\t\\\n-\t     \"r\" ((USItype)(v))\t\t\t\t\t\t\\\n+\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n+\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n+\t   : \"%rI\" ((USItype) (u)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype) (v))\t\t\t\t\t\t\\\n \t   : \"%g1\", \"%g2\" __AND_CLOBBER_CC)\n #define UMUL_TIME 39\t\t/* 39 instructions */\n /* It's quite necessary to add this much assembler for the sparc.\n@@ -983,11 +983,11 @@\n \tsub\t%1,%2,%1\n 3:\txnor\t%0,0,%0\n \t! End of inline udiv_qrnnd\"\t\t\t\t\t\\\n-\t   : \"=&r\" ((USItype)(q)),\t\t\t\t\t\\\n-\t     \"=&r\" ((USItype)(r))\t\t\t\t\t\\\n-\t   : \"r\" ((USItype)(d)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(n1)),\t\t\t\t\t\\\n-\t     \"0\" ((USItype)(n0)) : \"%g1\" __AND_CLOBBER_CC)\n+\t   : \"=&r\" ((USItype) (q)),\t\t\t\t\t\\\n+\t     \"=&r\" ((USItype) (r))\t\t\t\t\t\\\n+\t   : \"r\" ((USItype) (d)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n+\t     \"0\" ((USItype) (n0)) : \"%g1\" __AND_CLOBBER_CC)\n #define UDIV_TIME (3+7*32)\t/* 7 instructions/iteration. 32 iterations. */\n #endif /* __sparclite__ */\n #endif /* __sparc_v8__ */\n@@ -997,21 +997,21 @@\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addl2 %5,%1\n \tadwc %3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=g\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&g\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"%0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"%1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"subl2 %5,%1\n \tsbwc %3,%0\"\t\t\t\t\t\t\t\\\n-\t   : \"=g\" ((USItype)(sh)),\t\t\t\t\t\\\n-\t     \"=&g\" ((USItype)(sl))\t\t\t\t\t\\\n-\t   : \"0\" ((USItype)(ah)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bh)),\t\t\t\t\t\\\n-\t     \"1\" ((USItype)(al)),\t\t\t\t\t\\\n-\t     \"g\" ((USItype)(bl)))\n+\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n+\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n+\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n+\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n+\t     \"g\" ((USItype) (bl)))\n #define umul_ppmm(xh, xl, m0, m1) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     union {\t\t\t\t\t\t\t\t\\"}, {"sha": "4ac5d76b36b83675d1317414626f526086a82951", "filename": "gcc/loop.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -207,10 +207,10 @@ extern char *oballoc ();\n struct movable\n {\n   rtx insn;\t\t\t/* A movable insn */\n-  rtx set_src;\t\t\t/* The expression this reg is set from. */\n-  rtx set_dest;\t\t\t/* The destination of this SET. */\n+  rtx set_src;\t\t\t/* The expression this reg is set from.  */\n+  rtx set_dest;\t\t\t/* The destination of this SET.  */\n   rtx dependencies;\t\t/* When INSN is libcall, this is an EXPR_LIST\n-\t\t\t\t   of any registers used within the LIBCALL. */\n+\t\t\t\t   of any registers used within the LIBCALL.  */\n   int consec;\t\t\t/* Number of consecutive following insns \n \t\t\t\t   that must be moved with this one.  */\n   int regno;\t\t\t/* The register it sets */\n@@ -233,7 +233,7 @@ struct movable\n \t\t\t\t   invariant.  */\n   unsigned int move_insn : 1;\t/* 1 means that we call emit_move_insn to\n \t\t\t\t   load SRC, rather than copying INSN.  */\n-  unsigned int is_equiv : 1;\t/* 1 means a REG_EQUIV is present on INSN. */\n+  unsigned int is_equiv : 1;\t/* 1 means a REG_EQUIV is present on INSN.  */\n   enum machine_mode savemode;   /* Nonzero means it is a mode for a low part\n \t\t\t\t   that we should avoid changing when clearing\n \t\t\t\t   the rest of the reg.  */\n@@ -346,7 +346,7 @@ loop_optimize (f, dumpfile)\n \n   regs_may_share = 0;\n \n-  /* Count the number of loops. */\n+  /* Count the number of loops.  */\n \n   max_loop_num = 0;\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n@@ -877,7 +877,7 @@ scan_loop (loop_start, end, nregs)\n \n \t\t     If this insn was made by loop, we don't know its\n \t\t     INSN_LUID and hence must make a conservative\n-\t\t     assumption. */\n+\t\t     assumption.  */\n \t\t  m->global = (INSN_UID (p) >= max_uid_for_loop\n \t\t\t       || (uid_luid[regno_last_uid[regno]]\n \t\t\t\t   > INSN_LUID (end))\n@@ -1116,7 +1116,7 @@ libcall_benefit (last)\n     {\n       if (GET_CODE (insn) == CALL_INSN)\n \tbenefit += 10;\t\t/* Assume at least this many insns in a library\n-\t\t\t\t   routine. */\n+\t\t\t\t   routine.  */\n       else if (GET_CODE (insn) == INSN\n \t       && GET_CODE (PATTERN (insn)) != USE\n \t       && GET_CODE (PATTERN (insn)) != CLOBBER)\n@@ -1723,7 +1723,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t    {\n \t\t      rtx i1, temp;\n \n-\t\t      /* If first insn of libcall sequence, skip to end. */\n+\t\t      /* If first insn of libcall sequence, skip to end.  */\n \t\t      /* Do this at start of loop, since p is guaranteed to \n \t\t\t be an insn here.  */\n \t\t      if (GET_CODE (p) != NOTE\n@@ -1875,7 +1875,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t      /* This isn't needed because REG_NOTES is copied\n \t\t\t below and is wrong since P might be a PARALLEL.  */\n \t\t      if (REG_NOTES (i1) == 0\n-\t\t\t  && ! m->partial /* But not if it's a zero-extend clr. */\n+\t\t\t  && ! m->partial /* But not if it's a zero-extend clr.  */\n \t\t\t  && ! m->global /* and not if used outside the loop\n \t\t\t\t\t    (since it might get set outside).  */\n \t\t\t  && CONSTANT_P (SET_SRC (PATTERN (p))))\n@@ -2415,7 +2415,7 @@ find_and_verify_loops (f)\n \t\t    LABEL_NUSES (cond_label)++;\n \n \t\t    /* Verify that uid_loop_num is large enough and that\n-\t\t       we can invert P. */\n+\t\t       we can invert P.  */\n \t\t   if (invert_jump (p, new_label))\n \t\t     {\n \t\t       rtx q, r;\n@@ -2458,7 +2458,7 @@ find_and_verify_loops (f)\n \t\t\t\tloop_num = loop_outer_loop[loop_num])\n \t\t\t     loop_number_exit_count[loop_num]--;\n \n-\t\t\t   /* If we didn't find it, then something is wrong. */\n+\t\t\t   /* If we didn't find it, then something is wrong.  */\n \t\t\t   if (! r)\n \t\t\t     abort ();\n \t\t\t }\n@@ -3175,10 +3175,10 @@ static rtx addr_placeholder;\n    it is safe to keep the value in a register for the duration of the\n    loop. One tricky thing is that the copying of the value back from the\n    register has to be done on all exits from the loop.  You need to check that\n-   all the exits from the loop go to the same place. */\n+   all the exits from the loop go to the same place.  */\n \n /* ??? The interaction of biv elimination, and recognition of 'constant'\n-   bivs, may cause problems. */\n+   bivs, may cause problems.  */\n \n /* ??? Add heuristics so that DEST_ADDR strength reduction does not cause\n    performance problems.\n@@ -3590,7 +3590,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      ((benefit = general_induction_var (SET_SRC (set),\n \t\t\t\t\t\t &src_reg, &add_val,\n \t\t\t\t\t\t &mult_val))\n-\t       /* Equivalent expression is a giv. */\n+\t       /* Equivalent expression is a giv.  */\n \t       || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))\n \t\t   && (benefit = general_induction_var (XEXP (regnote, 0),\n \t\t\t\t\t\t\t&src_reg,\n@@ -3602,7 +3602,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      && dest_reg != src_reg\n \t      /* This must be the only place where the register is set.  */\n \t      && (n_times_set[REGNO (dest_reg)] == 1\n-\t\t  /* or all sets must be consecutive and make a giv. */\n+\t\t  /* or all sets must be consecutive and make a giv.  */\n \t\t  || (benefit = consec_sets_giv (benefit, p,\n \t\t\t\t\t\t src_reg, dest_reg,\n \t\t\t\t\t\t &add_val, &mult_val))))\n@@ -4141,14 +4141,14 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t     or otherwise drop straight in, based on this test, then\n \t     we might want to rewrite it also.  This way some later\n \t     pass has more hope of removing the initialization of this\n-\t     biv entirely. */\n+\t     biv entirely.  */\n \n \t  /* If final_value != 0, then the biv may be used after loop end\n \t     and we must emit an insn to set it just in case.\n \n \t     Reversed bivs already have an insn after the loop setting their\n \t     value, so we don't need another one.  We can't calculate the\n-\t     proper final value for such a biv here anyways. */\n+\t     proper final value for such a biv here anyways.  */\n \t  if (final_value != 0 && ! bl->reversed)\n \t    {\n \t      rtx insert_before;\n@@ -4509,7 +4509,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n \n       /* If the lifetime is zero, it means that this register is\n \t really a dead store.  So mark this as a giv that can be\n-\t ignored.  This will not prevent the biv from being eliminated. */\n+\t ignored.  This will not prevent the biv from being eliminated.  */\n       if (v->lifetime == 0)\n \tv->ignore = 1;\n \n@@ -4988,7 +4988,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n \t\t\t\t     : GET_MODE (SET_SRC (set))),\n \t\t\t\t    dest_reg, insn,\n \t\t\t\t    inc_val, mult_val);\n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n       /* Can accept constant setting of biv only when inside inner most loop.\n   \t Otherwise, a biv of an inner loop may be incorrectly recognized\n@@ -5264,7 +5264,7 @@ simplify_giv_expr (x, benefit)\n \t\t\t\tbenefit);\n \n     case MINUS:\n-      /* Handle \"a - b\" as \"a + b * (-1)\". */\n+      /* Handle \"a - b\" as \"a + b * (-1)\".  */\n       return simplify_giv_expr (gen_rtx (PLUS, mode,\n \t\t\t\t\t XEXP (x, 0),\n \t\t\t\t\t gen_rtx (MULT, mode,\n@@ -5304,7 +5304,7 @@ simplify_giv_expr (x, benefit)\n \t  return GEN_INT (INTVAL (arg0) * INTVAL (arg1));\n \n \tcase USE:\n-\t  /* invar * invar.  Not giv. */\n+\t  /* invar * invar.  Not giv.  */\n \t  return 0;\n \n \tcase MULT:\n@@ -5645,7 +5645,7 @@ combine_givs (bl)\n \t  {\n \t    g2 = giv_array[j];\n \t    if (g1 != g2\n-\t\t/* First try to combine with replaceable givs, then all givs. */\n+\t\t/* First try to combine with replaceable givs, then all givs.  */\n \t\t&& (g1->replaceable || pass == 1)\n \t\t/* If either has already been combined or is to be ignored, can't\n \t\t   combine.  */\n@@ -5692,7 +5692,7 @@ emit_iv_add_mult (b, m, a, reg, insert_before)\n   a = copy_rtx (a);\n   b = copy_rtx (b);\n \n-  /* Increase the lifetime of any invariants moved further in code. */\n+  /* Increase the lifetime of any invariants moved further in code.  */\n   update_reg_last_use (a, insert_before);\n   update_reg_last_use (b, insert_before);\n   update_reg_last_use (m, insert_before);\n@@ -5721,7 +5721,7 @@ product_cheap_p (a, b)\n   char *storage = (char *) obstack_alloc (&temp_obstack, 0);\n   int win = 1;\n \n-  /* If only one is constant, make it B. */\n+  /* If only one is constant, make it B.  */\n   if (GET_CODE (a) == CONST_INT)\n     tmp = a, a = b, b = tmp;\n \n@@ -6057,7 +6057,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t\t{\n \t\t  JUMP_LABEL (tem) = XEXP (jump_label, 0);\n \n-\t\t  /* Increment of LABEL_NUSES done above. */\n+\t\t  /* Increment of LABEL_NUSES done above.  */\n \t\t  /* Register is now always nonnegative,\n \t\t     so add REG_NONNEG note to the branch.  */\n \t\t  REG_NOTES (tem) = gen_rtx (EXPR_LIST, REG_NONNEG, NULL_RTX,"}, {"sha": "927e29d0cd991b46e8f01ee5ac13fa9a6d00da53", "filename": "gcc/machmode.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -77,7 +77,7 @@ MAX_MACHINE_MODE };\n /* Get the name of mode MODE as a string.  */\n \n extern char *mode_name[];\n-#define GET_MODE_NAME(MODE)\t\t(mode_name[(int)(MODE)])\n+#define GET_MODE_NAME(MODE)\t\t(mode_name[(int) (MODE)])\n \n enum mode_class { MODE_RANDOM, MODE_INT, MODE_FLOAT, MODE_PARTIAL_INT, MODE_CC,\n \t\t  MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT, MAX_MODE_CLASS};\n@@ -86,7 +86,7 @@ enum mode_class { MODE_RANDOM, MODE_INT, MODE_FLOAT, MODE_PARTIAL_INT, MODE_CC,\n    (integer, floating, complex, etc.)  */\n \n extern enum mode_class mode_class[];\n-#define GET_MODE_CLASS(MODE)\t\t(mode_class[(int)(MODE)])\n+#define GET_MODE_CLASS(MODE)\t\t(mode_class[(int) (MODE)])\n \n /* Nonzero if MODE is an integral mode.  */\n #define INTEGRAL_MODE_P(MODE)\t\t\t\\\n@@ -102,12 +102,12 @@ extern enum mode_class mode_class[];\n /* Get the size in bytes of an object of mode MODE.  */\n \n extern int mode_size[];\n-#define GET_MODE_SIZE(MODE)\t\t(mode_size[(int)(MODE)])\n+#define GET_MODE_SIZE(MODE)\t\t(mode_size[(int) (MODE)])\n \n /* Get the size in bytes of the basic parts of an object of mode MODE.  */\n \n extern int mode_unit_size[];\n-#define GET_MODE_UNIT_SIZE(MODE)\t(mode_unit_size[(int)(MODE)])\n+#define GET_MODE_UNIT_SIZE(MODE)\t(mode_unit_size[(int) (MODE)])\n \n /* Get the number of units in the object.  */\n \n@@ -117,7 +117,7 @@ extern int mode_unit_size[];\n \n /* Get the size in bits of an object of mode MODE.  */\n \n-#define GET_MODE_BITSIZE(MODE)  (BITS_PER_UNIT * mode_size[(int)(MODE)])\n+#define GET_MODE_BITSIZE(MODE)  (BITS_PER_UNIT * mode_size[(int) (MODE)])\n \n /* Get a bitmask containing 1 for all bits in a word\n    that fit within mode MODE.  */\n@@ -129,7 +129,7 @@ extern int mode_unit_size[];\n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n \n extern enum machine_mode mode_wider_mode[];\n-#define GET_MODE_WIDER_MODE(MODE)\t(mode_wider_mode[(int)(MODE)])\n+#define GET_MODE_WIDER_MODE(MODE)\t(mode_wider_mode[(int) (MODE)])\n \n /* Return the mode for data of a given size SIZE and mode class CLASS.\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n@@ -150,7 +150,7 @@ extern enum machine_mode get_best_mode PROTO((int, int, int, enum machine_mode,\n /* For each class, get the narrowest mode in that class.  */\n \n extern enum machine_mode class_narrowest_mode[];\n-#define GET_CLASS_NARROWEST_MODE(CLASS) class_narrowest_mode[(int)(CLASS)]\n+#define GET_CLASS_NARROWEST_MODE(CLASS) class_narrowest_mode[(int) (CLASS)]\n \n /* Define the integer modes whose sizes are BITS_PER_UNIT and BITS_PER_WORD\n    and the mode whose class is Pmode and whose size is POINTER_SIZE.  */"}, {"sha": "6890fc73e22af97de61818b6b326d47bd8462751", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -44,7 +44,7 @@ Boston, MA 02111-1307, USA.  */\n    which does not include mips.h.\n \n    These must match the corresponding definitions in gdb/mipsread.c.\n-   Unfortunately, gcc and gdb do not currently share any directories. */\n+   Unfortunately, gcc and gdb do not currently share any directories.  */\n \n #define CODE_MASK 0x8F300\n #define MIPS_IS_STAB(sym) (((sym)->index & 0xFFF00) == CODE_MASK)\n@@ -308,7 +308,7 @@ read_seek (ptr, size, offset, context)\n   if (size == 0)\t\t/* nothing to read */\n     return ptr;\n \n-  if ((ptr == (PTR_T)0 && (ptr = malloc (size)) == (PTR_T)0)\n+  if ((ptr == (PTR_T) 0 && (ptr = malloc (size)) == (PTR_T) 0)\n       || (tfile_offset != offset && lseek (tfile_fd, offset, 0) == -1)\n       || (read_size = read (tfile_fd, ptr, size)) < 0)\n     {\n@@ -721,7 +721,7 @@ type_to_string (aux_ptr, index, fdp)\n \t\tint j;\n \n \t\t/* Print array bounds reversed (ie, in the order the C\n-\t\t   programmer writes them).  C is such a fun language.... */\n+\t\t   programmer writes them).  C is such a fun language....  */\n \n \t\twhile (i < 5 && qualifiers[i+1].type == tq_Array)\n \t\t  i++;\n@@ -833,60 +833,60 @@ print_sym_hdr (sym_ptr)\n   printf(\"    %-*s %11s %11s %11s\\n\", width, \"====\", \"======\", \"======\", \"=====\\n\");\n \n   printf(\"    %-*s %11ld %11ld %11ld [%d]\\n\", width, \"Line numbers\",\n-\t (long)sym_ptr->cbLineOffset,\n-\t (long)sym_ptr->cbLine,\n-\t (long)sym_ptr->cbLine,\n-\t (int)sym_ptr->ilineMax);\n+\t (long) sym_ptr->cbLineOffset,\n+\t (long) sym_ptr->cbLine,\n+\t (long) sym_ptr->cbLine,\n+\t (int) sym_ptr->ilineMax);\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"Dense numbers\",\n-\t (long)sym_ptr->cbDnOffset,\n-\t (long)sym_ptr->idnMax,\n-\t (long)(sym_ptr->idnMax * sizeof (DNR)));\n+\t (long) sym_ptr->cbDnOffset,\n+\t (long) sym_ptr->idnMax,\n+\t (long) (sym_ptr->idnMax * sizeof (DNR)));\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"Procedures Tables\",\n-\t (long)sym_ptr->cbPdOffset,\n-\t (long)sym_ptr->ipdMax,\n-\t (long)(sym_ptr->ipdMax * sizeof (PDR)));\n+\t (long) sym_ptr->cbPdOffset,\n+\t (long) sym_ptr->ipdMax,\n+\t (long) (sym_ptr->ipdMax * sizeof (PDR)));\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"Local Symbols\",\n-\t (long)sym_ptr->cbSymOffset,\n-\t (long)sym_ptr->isymMax,\n-\t (long)(sym_ptr->isymMax * sizeof (SYMR)));\n+\t (long) sym_ptr->cbSymOffset,\n+\t (long) sym_ptr->isymMax,\n+\t (long) (sym_ptr->isymMax * sizeof (SYMR)));\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"Optimization Symbols\",\n-\t (long)sym_ptr->cbOptOffset,\n-\t (long)sym_ptr->ioptMax,\n-\t (long)(sym_ptr->ioptMax * sizeof (OPTR)));\n+\t (long) sym_ptr->cbOptOffset,\n+\t (long) sym_ptr->ioptMax,\n+\t (long) (sym_ptr->ioptMax * sizeof (OPTR)));\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"Auxiliary Symbols\",\n-\t (long)sym_ptr->cbAuxOffset,\n-\t (long)sym_ptr->iauxMax,\n-\t (long)(sym_ptr->iauxMax * sizeof (AUXU)));\n+\t (long) sym_ptr->cbAuxOffset,\n+\t (long) sym_ptr->iauxMax,\n+\t (long) (sym_ptr->iauxMax * sizeof (AUXU)));\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"Local Strings\",\n-\t (long)sym_ptr->cbSsOffset,\n-\t (long)sym_ptr->issMax,\n-\t (long)sym_ptr->issMax);\n+\t (long) sym_ptr->cbSsOffset,\n+\t (long) sym_ptr->issMax,\n+\t (long) sym_ptr->issMax);\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"External Strings\",\n-\t (long)sym_ptr->cbSsExtOffset,\n-\t (long)sym_ptr->issExtMax,\n-\t (long)sym_ptr->issExtMax);\n+\t (long) sym_ptr->cbSsExtOffset,\n+\t (long) sym_ptr->issExtMax,\n+\t (long) sym_ptr->issExtMax);\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"File Tables\",\n-\t (long)sym_ptr->cbFdOffset,\n-\t (long)sym_ptr->ifdMax,\n-\t (long)(sym_ptr->ifdMax * sizeof (FDR)));\n+\t (long) sym_ptr->cbFdOffset,\n+\t (long) sym_ptr->ifdMax,\n+\t (long) (sym_ptr->ifdMax * sizeof (FDR)));\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"Relative Files\",\n-\t (long)sym_ptr->cbRfdOffset,\n-\t (long)sym_ptr->crfd,\n-\t (long)(sym_ptr->crfd * sizeof (ulong)));\n+\t (long) sym_ptr->cbRfdOffset,\n+\t (long) sym_ptr->crfd,\n+\t (long) (sym_ptr->crfd * sizeof (ulong)));\n \n   printf(\"    %-*s %11ld %11ld %11ld\\n\", width, \"External Symbols\",\n-\t (long)sym_ptr->cbExtOffset,\n-\t (long)sym_ptr->iextMax,\n-\t (long)(sym_ptr->iextMax * sizeof (EXTR)));\n+\t (long) sym_ptr->cbExtOffset,\n+\t (long) sym_ptr->iextMax,\n+\t (long) (sym_ptr->iextMax * sizeof (EXTR)));\n }\n \n \f\n@@ -909,7 +909,7 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n \n   printf (\"\\n    Symbol# %d: \\\"%s\\\"\\n\", number, sym_ptr->iss + strbase);\n \n-  if (aux_base != (AUXU *)0 && index != indexNil)\n+  if (aux_base != (AUXU *) 0 && index != indexNil)\n     switch (symbol_type)\n       {\n       case st_Nil:\n@@ -921,7 +921,7 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n \tprintf (\"      End+1 symbol: %ld\\n\", index);\n \tif (want_scope)\n \t  {\n-\t    if (free_scope == (scope_t *)0)\n+\t    if (free_scope == (scope_t *) 0)\n \t      scope_ptr = (scope_t *) malloc (sizeof (scope_t));\n \t    else\n \t      {\n@@ -947,7 +947,7 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n \n \tif (want_scope)\n \t  {\n-\t    if (cur_scope == (scope_t *)0)\n+\t    if (cur_scope == (scope_t *) 0)\n \t      printf (\"      Can't pop end scope\\n\");\n \t    else\n \t      {\n@@ -975,7 +975,7 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n \n \tif (want_scope)\n \t  {\n-\t    if (free_scope == (scope_t *)0)\n+\t    if (free_scope == (scope_t *) 0)\n \t      scope_ptr = (scope_t *) malloc (sizeof (scope_t));\n \t    else\n \t      {\n@@ -1011,12 +1011,12 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n   if (want_scope)\n     {\n       printf (\"      Scopes:  \");\n-      if (cur_scope == (scope_t *)0)\n+      if (cur_scope == (scope_t *) 0)\n \tprintf (\" none\\n\");\n       else\n \t{\n \t  for (scope_ptr = cur_scope;\n-\t       scope_ptr != (scope_t *)0;\n+\t       scope_ptr != (scope_t *) 0;\n \t       scope_ptr = scope_ptr->prev)\n \t    {\n \t      char *class;\n@@ -1220,7 +1220,7 @@ print_file_desc (fdp, number)\n \t (ulong) (fdp->rfdBase * sizeof(ulong) + sym_hdr.cbRfdOffset));\n \n \n-  if (want_scope && cur_scope != (scope_t *)0)\n+  if (want_scope && cur_scope != (scope_t *) 0)\n     printf (\"\\n    Warning scope does not start at 0!\\n\");\n \n   /* \n@@ -1238,7 +1238,7 @@ print_file_desc (fdp, number)\n \t\t  -1,\n \t\t  fdp);\n \n-  if (want_scope && cur_scope != (scope_t *)0)\n+  if (want_scope && cur_scope != (scope_t *) 0)\n     printf (\"\\n    Warning scope does not end at 0!\\n\");\n \n   /*\n@@ -1328,7 +1328,7 @@ print_file_desc (fdp, number)\n \n \t  if (pdi == fdp->cpd + fdp->ipdFirst - 1)\t/* last procedure */\n \t    line_end = ((uchar *)lines) + fdp->cbLine + fdp->cbLineOffset;\n-\t  else\t\t\t\t\t\t/* not last proc. */\n+\t  else\t\t\t\t\t\t/* not last proc.  */\n \t    line_end = (((uchar *)lines) + proc_desc[pdi+1].cbLineOffset\n \t\t\t+ fdp->cbLineOffset);\n \n@@ -1368,12 +1368,12 @@ read_tfile __proto((void))\n   short magic;\n   off_t sym_hdr_offset = 0;\n \n-  (void) read_seek ((PTR_T) &magic, sizeof (magic), (off_t)0, \"Magic number\");\n+  (void) read_seek ((PTR_T) &magic, sizeof (magic), (off_t) 0, \"Magic number\");\n   if (!tfile)\n     {\n       /* Print out the global header, since this is not a T-file.  */\n \n-      (void) read_seek ((PTR_T) &global_hdr, sizeof (global_hdr), (off_t)0,\n+      (void) read_seek ((PTR_T) &global_hdr, sizeof (global_hdr), (off_t) 0,\n \t\t\t\"Global file header\");\n \n       print_global_hdr (&global_hdr);\n@@ -1394,67 +1394,67 @@ read_tfile __proto((void))\n \n   print_sym_hdr (&sym_hdr);\n \n-  lines = (LINER *) read_seek ((PTR_T)0,\n+  lines = (LINER *) read_seek ((PTR_T) 0,\n \t\t\t       sym_hdr.cbLine,\n \t\t\t       sym_hdr.cbLineOffset,\n \t\t\t       \"Line numbers\");\n \n-  dense_nums = (DNR *) read_seek ((PTR_T)0,\n+  dense_nums = (DNR *) read_seek ((PTR_T) 0,\n \t\t\t\t  sym_hdr.idnMax * sizeof (DNR),\n \t\t\t\t  sym_hdr.cbDnOffset,\n \t\t\t\t  \"Dense numbers\");\n \n-  proc_desc = (PDR *) read_seek ((PTR_T)0,\n+  proc_desc = (PDR *) read_seek ((PTR_T) 0,\n \t\t\t\t sym_hdr.ipdMax * sizeof (PDR),\n \t\t\t\t sym_hdr.cbPdOffset,\n \t\t\t\t \"Procedure tables\");\n \n-  l_symbols = (SYMR *) read_seek ((PTR_T)0,\n+  l_symbols = (SYMR *) read_seek ((PTR_T) 0,\n \t\t\t\t  sym_hdr.isymMax * sizeof (SYMR),\n \t\t\t\t  sym_hdr.cbSymOffset,\n \t\t\t\t  \"Local symbols\");\n \n-  opt_symbols = (OPTR *) read_seek ((PTR_T)0,\n+  opt_symbols = (OPTR *) read_seek ((PTR_T) 0,\n \t\t\t\t    sym_hdr.ioptMax * sizeof (OPTR),\n \t\t\t\t    sym_hdr.cbOptOffset,\n \t\t\t\t    \"Optimization symbols\");\n \n-  aux_symbols = (AUXU *) read_seek ((PTR_T)0,\n+  aux_symbols = (AUXU *) read_seek ((PTR_T) 0,\n \t\t\t\t    sym_hdr.iauxMax * sizeof (AUXU),\n \t\t\t\t    sym_hdr.cbAuxOffset,\n \t\t\t\t    \"Auxiliary symbols\");\n \n   if (sym_hdr.iauxMax > 0)\n     {\n       aux_used = calloc (sym_hdr.iauxMax, 1);\n-      if (aux_used == (char *)0)\n+      if (aux_used == (char *) 0)\n \t{\n \t  perror (\"calloc\");\n \t  exit (1);\n \t}\n     }\n \n-  l_strings = (char *) read_seek ((PTR_T)0,\n+  l_strings = (char *) read_seek ((PTR_T) 0,\n \t\t\t\t  sym_hdr.issMax,\n \t\t\t\t  sym_hdr.cbSsOffset,\n \t\t\t\t  \"Local string table\");\n \n-  e_strings = (char *) read_seek ((PTR_T)0,\n+  e_strings = (char *) read_seek ((PTR_T) 0,\n \t\t\t\t  sym_hdr.issExtMax,\n \t\t\t\t  sym_hdr.cbSsExtOffset,\n \t\t\t\t  \"External string table\");\n \n-  file_desc = (FDR *) read_seek ((PTR_T)0,\n+  file_desc = (FDR *) read_seek ((PTR_T) 0,\n \t\t\t\t sym_hdr.ifdMax * sizeof (FDR),\n \t\t\t\t sym_hdr.cbFdOffset,\n \t\t\t\t \"File tables\");\n \n-  rfile_desc = (ulong *) read_seek ((PTR_T)0,\n+  rfile_desc = (ulong *) read_seek ((PTR_T) 0,\n \t\t\t\t    sym_hdr.crfd * sizeof (ulong),\n \t\t\t\t    sym_hdr.cbRfdOffset,\n \t\t\t\t    \"Relative file tables\");\n \n-  e_symbols = (EXTR *) read_seek ((PTR_T)0,\n+  e_symbols = (EXTR *) read_seek ((PTR_T) 0,\n \t\t\t\t  sym_hdr.iextMax * sizeof (EXTR),\n \t\t\t\t  sym_hdr.cbExtOffset,\n \t\t\t\t  \"External symbols\");"}, {"sha": "61bbbc9c9a173d55f1f46ebbc57535fccb7809e3", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 174, "deletions": 174, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -939,7 +939,7 @@ typedef enum coff_dt {\n typedef enum hash_state {\n   hash_no\t= 0,\t\t/* don't hash type */\n   hash_yes\t= 1,\t\t/* ok to hash type, or use previous hash */\n-  hash_record\t= 2\t\t/* ok to record hash, but don't use prev. */\n+  hash_record\t= 2\t\t/* ok to record hash, but don't use prev.  */\n } hash_state_t;\n \n \n@@ -1014,15 +1014,15 @@ typedef struct varray {\n #endif\n \n #define INIT_VARRAY(type) {\t/* macro to initialize a varray */\t\\\n-  (vlinks_t *)0,\t\t/* first */\t\t\t\t\\\n-  (vlinks_t *)0,\t\t/* last */\t\t\t\t\\\n+  (vlinks_t *) 0,\t\t/* first */\t\t\t\t\\\n+  (vlinks_t *) 0,\t\t/* last */\t\t\t\t\\\n   0,\t\t\t\t/* num_allocated */\t\t\t\\\n   sizeof (type),\t\t/* object_size */\t\t\t\\\n   OBJECTS_PER_PAGE (type),\t/* objects_per_page */\t\t\t\\\n   OBJECTS_PER_PAGE (type),\t/* objects_last_page */\t\t\t\\\n }\n \n-/* Master type for indexes within the symbol table. */\n+/* Master type for indexes within the symbol table.  */\n typedef unsigned long symint_t;\n \n \n@@ -1171,22 +1171,22 @@ static efdr_t init_file =\n     0,\t\t\t/* cbLine:\tsize of lines for this file */\n   },\n \n-  (FDR *)0,\t\t/* orig_fdr:\toriginal file header pointer */\n-  (char *)0,\t\t/* name:\tpointer to filename */\n+  (FDR *) 0,\t\t/* orig_fdr:\toriginal file header pointer */\n+  (char *) 0,\t\t/* name:\tpointer to filename */\n   0,\t\t\t/* name_len:\tlength of filename */\n   0,\t\t\t/* void_type:\tptr to aux node for void type */\n   0,\t\t\t/* int_type:\tptr to aux node for int type */\n-  (scope_t *)0,\t\t/* cur_scope:\tcurrent scope being processed */\n+  (scope_t *) 0,\t/* cur_scope:\tcurrent scope being processed */\n   0,\t\t\t/* file_index:\tcurrent file # */\n   0,\t\t\t/* nested_scopes: # nested scopes */\n   INIT_VARRAY (char),\t/* strings:\tlocal string varray */\n   INIT_VARRAY (SYMR),\t/* symbols:\tlocal symbols varray */\n   INIT_VARRAY (PDR),\t/* procs:\tprocedure varray */\n   INIT_VARRAY (AUXU),\t/* aux_syms:\tauxiliary symbols varray */\n \n-  (struct efdr *)0,\t/* next_file:\tnext file structure */\n+  (struct efdr *) 0,\t/* next_file:\tnext file structure */\n \n-  (shash_t **)0,\t/* shash_head:\tstring hash table */\n+  (shash_t **) 0,\t/* shash_head:\tstring hash table */\n   { 0 },\t\t/* thash_head:\ttype hash table */\n };\n \n@@ -1609,17 +1609,17 @@ static PDR     *cur_proc_ptr\t= (PDR *) 0;\t/* current procedure header */\n static SYMR    *cur_oproc_begin\t= (SYMR *) 0;\t/* original proc. sym begin info */\n static SYMR    *cur_oproc_end\t= (SYMR *) 0;\t/* original proc. sym end info */\n static PDR     *cur_oproc_ptr\t= (PDR *) 0;\t/* current original procedure*/\n-static thead_t *cur_tag_head\t= (thead_t *)0;\t/* current tag head */\n+static thead_t *cur_tag_head\t= (thead_t *) 0;/* current tag head */\n static long\tfile_offset\t= 0;\t\t/* current file offset */\n static long\tmax_file_offset\t= 0;\t\t/* maximum file offset */\n-static FILE    *object_stream\t= (FILE *)0;\t/* file desc. to output .o */\n-static FILE    *obj_in_stream\t= (FILE *)0;\t/* file desc. to input .o */\n-static char    *progname\t= (char *)0;\t/* program name for errors */\n+static FILE    *object_stream\t= (FILE *) 0;\t/* file desc. to output .o */\n+static FILE    *obj_in_stream\t= (FILE *) 0;\t/* file desc. to input .o */\n+static char    *progname\t= (char *) 0;\t/* program name for errors */\n static char    *input_name\t= \"stdin\";\t/* name of input file */\n-static char    *object_name\t= (char *)0;\t/* tmp. name of object file */\n-static char    *obj_in_name\t= (char *)0;\t/* name of input object file */\n-static char    *cur_line_start\t= (char *)0;\t/* current line read in */\n-static char    *cur_line_ptr\t= (char *)0;\t/* ptr within current line */\n+static char    *object_name\t= (char *) 0;\t/* tmp. name of object file */\n+static char    *obj_in_name\t= (char *) 0;\t/* name of input object file */\n+static char    *cur_line_start\t= (char *) 0;\t/* current line read in */\n+static char    *cur_line_ptr\t= (char *) 0;\t/* ptr within current line */\n static unsigned\tcur_line_nbytes\t= 0;\t\t/* # bytes for current line */\n static unsigned\tcur_line_alloc\t= 0;\t\t/* # bytes total in buffer */\n static long\tline_number\t= 0;\t\t/* current input line number */\n@@ -1782,7 +1782,7 @@ extern char *sys_siglist[NSIG + 1];\n /* List of assembler pseudo ops and beginning sequences that need\n    special actions.  Someday, this should be a hash table, and such,\n    but for now a linear list of names and calls to memcmp will\n-   do...... */\n+   do......  */\n \n typedef struct _pseudo_ops {\n   const char *name;\t\t\t/* pseudo-op in ascii */\n@@ -1826,7 +1826,7 @@ add_varray_page (vp)\n   new_links->start_index = vp->num_allocated;\n   vp->objects_last_page = 0;\n \n-  if (vp->first == (vlinks_t *)0)\t\t/* first allocation? */\n+  if (vp->first == (vlinks_t *) 0)\t\t/* first allocation? */\n     vp->first = vp->last = new_links;\n   else\n     {\t\t\t\t\t\t/* 2nd or greater allocation */\n@@ -1860,10 +1860,10 @@ hash_string (text, hash_len, hash_tbl, ret_hash_index)\n   hi &= (1 << HASHBITS) - 1;\n   hi %= SHASH_SIZE;\n \n-  if (ret_hash_index != (symint_t *)0)\n+  if (ret_hash_index != (symint_t *) 0)\n     *ret_hash_index = hi;\n \n-  for (ptr = hash_tbl[hi]; ptr != (shash_t *)0; ptr = ptr->next)\n+  for (ptr = hash_tbl[hi]; ptr != (shash_t *) 0; ptr = ptr->next)\n     if (hash_len == ptr->len\n \t&& first_ch == ptr->string[0]\n \t&& memcmp ((CPTR_T) text, (CPTR_T) ptr->string, hash_len) == 0)\n@@ -1893,7 +1893,7 @@ add_string (vp, hash_tbl, start, end_p1, ret_hash)\n     fatal (\"String too big (%ld bytes)\", (long) len);\n \n   hash_ptr = hash_string (start, len, hash_tbl, &hi);\n-  if (hash_ptr == (shash_t *)0)\n+  if (hash_ptr == (shash_t *) 0)\n     {\n       register char *p;\n \n@@ -1921,7 +1921,7 @@ add_string (vp, hash_tbl, start, end_p1, ret_hash)\n       *p = '\\0';\n     }\n \n-  if (ret_hash != (shash_t **)0)\n+  if (ret_hash != (shash_t **) 0)\n     *ret_hash = hash_ptr;\n \n   return hash_ptr->indx;\n@@ -1947,7 +1947,7 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n   register tag_t *ptag_next;\n   register varray_t *vp = &cur_file_ptr->symbols;\n   register int scope_delta = 0;\n-  shash_t *hash_ptr = (shash_t *)0;\n+  shash_t *hash_ptr = (shash_t *) 0;\n \n   if (vp->objects_last_page == vp->objects_per_page)\n     add_varray_page (vp);\n@@ -1958,7 +1958,7 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n   psym->st = (unsigned) type;\n   psym->sc = (unsigned) storage;\n   psym->index = indx;\n-  psym->iss = (str_start == (const char *)0)\n+  psym->iss = (str_start == (const char *) 0)\n \t\t? 0\n \t\t: add_string (&cur_file_ptr->strings,\n \t\t\t      &cur_file_ptr->shash_head[0],\n@@ -1973,7 +1973,7 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n \n   /* Save the symbol within the hash table if this is a static\n      item, and it has a name.  */\n-  if (hash_ptr != (shash_t *)0\n+  if (hash_ptr != (shash_t *) 0\n       && (type == st_Global || type == st_Static || type == st_Label\n \t  || type == st_Proc || type == st_StaticProc))\n     hash_ptr->sym_ptr = psym;\n@@ -2030,10 +2030,10 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n \t      cur_tag_head = ptag_head->prev;\n \n \t      for (ptag = ptag_head->first_tag;\n-\t\t   ptag != (tag_t *)0;\n+\t\t   ptag != (tag_t *) 0;\n \t\t   ptag = ptag_next)\n \t\t{\n-\t\t  if (ptag->forward_ref != (forward_t *)0)\n+\t\t  if (ptag->forward_ref != (forward_t *) 0)\n \t\t    add_unknown_tag (ptag);\n \n \t\t  ptag_next = ptag->same_block;\n@@ -2119,7 +2119,7 @@ add_ext_symbol (str_start, str_end_p1, type, storage, value, indx, ifd)\n {\n   register EXTR *psym;\n   register varray_t *vp = &ext_symbols;\n-  shash_t *hash_ptr = (shash_t *)0;\n+  shash_t *hash_ptr = (shash_t *) 0;\n \n   if (debug > 1)\n     {\n@@ -2146,7 +2146,7 @@ add_ext_symbol (str_start, str_end_p1, type, storage, value, indx, ifd)\n   psym->asym.st    = (unsigned) type;\n   psym->asym.sc    = (unsigned) storage;\n   psym->asym.index = indx;\n-  psym->asym.iss   = (str_start == (const char *)0)\n+  psym->asym.iss   = (str_start == (const char *) 0)\n \t\t\t? 0\n \t\t\t: add_string (&ext_strings,\n \t\t\t\t      &ext_str_hash[0],\n@@ -2232,7 +2232,7 @@ add_aux_sym_tir (t, state, hash_tbl)\n \n \n   /* For anything that adds additional information, we must not hash,\n-     so check here, and reset our state. */\n+     so check here, and reset our state.  */\n \n   if (state != hash_no\n       && (t->type_qualifiers[0] == tq_Array\n@@ -2262,17 +2262,17 @@ add_aux_sym_tir (t, state, hash_tbl)\n       hi %= THASH_SIZE;\n \n       for (hash_ptr = hash_tbl[hi];\n-\t   hash_ptr != (thash_t *)0;\n+\t   hash_ptr != (thash_t *) 0;\n \t   hash_ptr = hash_ptr->next)\n \t{\n \t  if (aux.isym == hash_ptr->type.isym)\n \t    break;\n \t}\n \n-      if (hash_ptr != (thash_t *)0 && state == hash_yes)\n+      if (hash_ptr != (thash_t *) 0 && state == hash_yes)\n \treturn hash_ptr->indx;\n \n-      if (hash_ptr == (thash_t *)0)\n+      if (hash_ptr == (thash_t *) 0)\n \t{\n \t  hash_ptr = allocate_thash ();\n \t  hash_ptr->next = hash_tbl[hi];\n@@ -2282,7 +2282,7 @@ add_aux_sym_tir (t, state, hash_tbl)\n \t}\n     }\n \n-  /* Everything is set up, add the aux symbol. */\n+  /* Everything is set up, add the aux symbol.  */\n   if (vp->objects_last_page == vp->objects_per_page)\n     add_varray_page (vp);\n \n@@ -2350,15 +2350,15 @@ add_aux_sym_tir (t, state, hash_tbl)\n \t\t\t       cur_file_ptr->int_type);\n \n       (void) add_aux_sym_symint (cur_file_ptr->file_index);\t/* file index*/\n-      (void) add_aux_sym_symint ((symint_t)0);\t\t\t/* low bound */\n+      (void) add_aux_sym_symint ((symint_t) 0);\t\t\t/* low bound */\n       (void) add_aux_sym_symint (t->dimensions[i] - 1);\t\t/* high bound*/\n       (void) add_aux_sym_symint ((t->dimensions[i] == 0)\t/* stride */\n \t\t\t      ? 0\n \t\t\t      : (t->sizes[i] * 8) / t->dimensions[i]);\n     };\n \n   /* NOTE:  Mips documentation claims that the bitfield width goes here.\n-     But it needs to be emitted earlier. */\n+     But it needs to be emitted earlier.  */\n \n   return ret;\n }\n@@ -2378,10 +2378,10 @@ get_tag (tag_start, tag_end_p1, indx, basic_type)\n   hash_ptr = hash_string (tag_start,\n \t\t\t  tag_end_p1 - tag_start,\n \t\t\t  &tag_hash[0],\n-\t\t\t  (symint_t *)0);\n+\t\t\t  (symint_t *) 0);\n \n-  if (hash_ptr != (shash_t *)0\n-      && hash_ptr->tag_ptr != (tag_t *)0)\n+  if (hash_ptr != (shash_t *) 0\n+      && hash_ptr->tag_ptr != (tag_t *) 0)\n   {\n     tag_ptr = hash_ptr->tag_ptr;\n     if (indx != indexNil)\n@@ -2448,17 +2448,17 @@ add_unknown_tag (ptag)\n \t\t\t\tname_end_p1,\n \t\t\t\tst_Block,\n \t\t\t\tsc_Info,\n-\t\t\t\t(symint_t)0,\n-\t\t\t\t(symint_t)0);\n+\t\t\t\t(symint_t) 0,\n+\t\t\t\t(symint_t) 0);\n \n   (void) add_local_symbol (name_start,\n \t\t\t   name_end_p1,\n \t\t\t   st_End,\n \t\t\t   sc_Info,\n-\t\t\t   (symint_t)0,\n-\t\t\t   (symint_t)0);\n+\t\t\t   (symint_t) 0,\n+\t\t\t   (symint_t) 0);\n \n-  while (f_next != (forward_t *)0)\n+  while (f_next != (forward_t *) 0)\n     {\n       f_cur  = f_next;\n       f_next = f_next->next;\n@@ -2490,7 +2490,7 @@ add_procedure (func_start, func_end_p1)\n   register shash_t *shash_ptr = hash_string (func_start,\n \t\t\t\t\t    func_end_p1 - func_start,\n \t\t\t\t\t    &orig_str_hash[0],\n-\t\t\t\t\t    (symint_t *)0);\n+\t\t\t\t\t    (symint_t *) 0);\n \n   if (debug)\n     fputc ('\\n', stderr);\n@@ -2504,14 +2504,14 @@ add_procedure (func_start, func_end_p1)\n \n \n   /* Did the assembler create this procedure?  If so, get the PDR information.  */\n-  cur_oproc_ptr = (PDR *)0;\n-  if (shash_ptr != (shash_t *)0)\n+  cur_oproc_ptr = (PDR *) 0;\n+  if (shash_ptr != (shash_t *) 0)\n     {\n       register PDR *old_proc_ptr = shash_ptr->proc_ptr;\n       register SYMR *sym_ptr = shash_ptr->sym_ptr;\n \n-      if (old_proc_ptr != (PDR *)0\n-\t  && sym_ptr != (SYMR *)0\n+      if (old_proc_ptr != (PDR *) 0\n+\t  && sym_ptr != (SYMR *) 0\n \t  && ((st_t)sym_ptr->st == st_Proc || (st_t)sym_ptr->st == st_StaticProc))\n \t{\n \t  cur_oproc_begin = sym_ptr;\n@@ -2524,17 +2524,17 @@ add_procedure (func_start, func_end_p1)\n \t}\n     }\n \n-  if (cur_oproc_ptr == (PDR *)0)\n+  if (cur_oproc_ptr == (PDR *) 0)\n     error (\"Did not find a PDR block for %.*s\", func_end_p1 - func_start, func_start);\n \n-  /* Determine the start of symbols. */\n+  /* Determine the start of symbols.  */\n   new_proc_ptr->isym = file_ptr->symbols.num_allocated;\n \n   /* Push the start of the function.  */\n   (void) add_local_symbol (func_start, func_end_p1,\n \t\t\t   proc_type, sc_Text,\n \t\t\t   value,\n-\t\t\t   (symint_t)0);\n+\t\t\t   (symint_t) 0);\n }\n \n \f\n@@ -2558,7 +2558,7 @@ add_file (file_start, file_end_p1)\n \n   /* See if the file has already been created.  */\n   for (file_ptr = first_file;\n-       file_ptr != (efdr_t *)0;\n+       file_ptr != (efdr_t *) 0;\n        file_ptr = file_ptr->next_file)\n     {\n       if (first_ch == file_ptr->name[0]\n@@ -2570,8 +2570,8 @@ add_file (file_start, file_end_p1)\n \t}\n     }\n \n-  /* If this is a new file, create it. */\n-  if (file_ptr == (efdr_t *)0)\n+  /* If this is a new file, create it.  */\n+  if (file_ptr == (efdr_t *) 0)\n     {\n       if (file_desc.objects_last_page == file_desc.objects_per_page)\n \tadd_varray_page (&file_desc);\n@@ -2590,15 +2590,15 @@ add_file (file_start, file_end_p1)\n \t\t  &file_ptr->shash_head[0],\n \t\t  &zero_bytes[0],\n \t\t  &zero_bytes[0],\n-\t\t  (shash_t **)0);\n+\t\t  (shash_t **) 0);\n \n       if (file_end_p1 - file_start > PAGE_USIZE-2)\n \tfatal (\"Filename goes over one page boundary.\");\n \n       /* Push the start of the filename. We assume that the filename\n          will be stored at string offset 1.  */\n       (void) add_local_symbol (file_start, file_end_p1, st_File, sc_Text,\n-\t\t\t       (symint_t)0, (symint_t)0);\n+\t\t\t       (symint_t) 0, (symint_t) 0);\n       file_ptr->fdr.rss = 1;\n       file_ptr->name = &file_ptr->strings.last->datum->byte[1];\n       file_ptr->name_len = file_end_p1 - file_start;\n@@ -2745,7 +2745,7 @@ read_line __proto((void))\n   register int ch;\n   register char *ptr;\n \n-  if (cur_line_start == (char *)0)\n+  if (cur_line_start == (char *) 0)\n     {\t\t\t\t/* allocate initial page */\n       cur_line_start = (char *) allocate_page ();\n       cur_line_alloc = PAGE_SIZE;\n@@ -2804,8 +2804,8 @@ read_line __proto((void))\n   if (ferror (stdin))\n     pfatal_with_name (input_name);\n \n-  cur_line_ptr = (char *)0;\n-  return (char *)0;\n+  cur_line_ptr = (char *) 0;\n+  return (char *) 0;\n }\n \n \f\n@@ -2820,13 +2820,13 @@ parse_begin (start)\n   int ch;\n   shash_t *hash_ptr;\t\t\t/* hash pointer to lookup label */\n \n-  if (cur_file_ptr == (efdr_t *)0)\n+  if (cur_file_ptr == (efdr_t *) 0)\n     {\n       error (\"#.begin directive without a preceding .file directive\");\n       return;\n     }\n \n-  if (cur_proc_ptr == (PDR *)0)\n+  if (cur_proc_ptr == (PDR *) 0)\n     {\n       error (\"#.begin directive without a preceding .ent directive\");\n       return;\n@@ -2838,24 +2838,24 @@ parse_begin (start)\n   hash_ptr = hash_string (start,\n \t\t\t  end_p1 - start,\n \t\t\t  &orig_str_hash[0],\n-\t\t\t  (symint_t *)0);\n+\t\t\t  (symint_t *) 0);\n \n-  if (hash_ptr == (shash_t *)0)\n+  if (hash_ptr == (shash_t *) 0)\n     {\n       error (\"Label %.*s not found for #.begin\", end_p1 - start, start);\n       return;\n     }\n \n-  if (cur_oproc_begin == (SYMR *)0)\n+  if (cur_oproc_begin == (SYMR *) 0)\n     {\n       error (\"Procedure table %.*s not found for #.begin\", end_p1 - start, start);\n       return;\n     }\n \n-  (void) add_local_symbol ((const char *)0, (const char *)0,\n+  (void) add_local_symbol ((const char *) 0, (const char *) 0,\n \t\t\t   st_Block, sc_Text,\n-\t\t\t   (symint_t)hash_ptr->sym_ptr->value - cur_oproc_begin->value,\n-\t\t\t   (symint_t)0);\n+\t\t\t   (symint_t) hash_ptr->sym_ptr->value - cur_oproc_begin->value,\n+\t\t\t   (symint_t) 0);\n }\n \n \f\n@@ -2870,13 +2870,13 @@ parse_bend (start)\n   int ch;\n   shash_t *hash_ptr;\t\t\t/* hash pointer to lookup label */\n \n-  if (cur_file_ptr == (efdr_t *)0)\n+  if (cur_file_ptr == (efdr_t *) 0)\n     {\n       error (\"#.begin directive without a preceding .file directive\");\n       return;\n     }\n \n-  if (cur_proc_ptr == (PDR *)0)\n+  if (cur_proc_ptr == (PDR *) 0)\n     {\n       error (\"#.bend directive without a preceding .ent directive\");\n       return;\n@@ -2888,24 +2888,24 @@ parse_bend (start)\n   hash_ptr = hash_string (start,\n \t\t\t  end_p1 - start,\n \t\t\t  &orig_str_hash[0],\n-\t\t\t  (symint_t *)0);\n+\t\t\t  (symint_t *) 0);\n \n-  if (hash_ptr == (shash_t *)0)\n+  if (hash_ptr == (shash_t *) 0)\n     {\n       error (\"Label %.*s not found for #.bend\", end_p1 - start, start);\n       return;\n     }\n \n-  if (cur_oproc_begin == (SYMR *)0)\n+  if (cur_oproc_begin == (SYMR *) 0)\n     {\n       error (\"Procedure table %.*s not found for #.bend\", end_p1 - start, start);\n       return;\n     }\n \n-  (void) add_local_symbol ((const char *)0, (const char *)0,\n+  (void) add_local_symbol ((const char *) 0, (const char *) 0,\n \t\t\t   st_End, sc_Text,\n \t\t\t   (symint_t)hash_ptr->sym_ptr->value - cur_oproc_begin->value,\n-\t\t\t   (symint_t)0);\n+\t\t\t   (symint_t) 0);\n }\n \n \f\n@@ -2929,12 +2929,12 @@ parse_def (name_start)\n   const char *arg_start;\t\t\t/* start of current argument */\n   const char *arg_end_p1;\t\t\t/* end+1 of current argument */\n   const char *name_end_p1;\t\t\t/* end+1 of label */\n-  const char *tag_start\t  = (const char *)0;\t/* start of tag name */\n-  const char *tag_end_p1  = (const char *)0;\t/* end+1 of tag name */\n+  const char *tag_start\t  = (const char *) 0;\t/* start of tag name */\n+  const char *tag_end_p1  = (const char *) 0;\t/* end+1 of tag name */\n   sc_t storage_class\t  = sc_Nil;\n   st_t symbol_type\t  = st_Nil;\n   type_info_t t;\n-  EXTR *eptr\t\t  = (EXTR *)0;\t\t/* ext. sym equivalent to def*/\n+  EXTR *eptr\t\t  = (EXTR *) 0;\t\t/* ext. sym equivalent to def*/\n   int is_function\t  = 0;\t\t\t/* != 0 if function */\n   symint_t value\t  = 0;\n   symint_t indx\t\t  = cur_file_ptr->void_type;\n@@ -3002,7 +3002,7 @@ parse_def (name_start)\n \n       /* Pick up the subdirective argument now.  */\n       arg_was_number = arg_number = 0;\n-      arg_end_p1 = (const char *)0;\n+      arg_end_p1 = (const char *) 0;\n       arg_start = dir_end_p1+1;\n       ch = *arg_start;\n       while (ch == ' ' || ch == '\\t')\n@@ -3247,20 +3247,20 @@ parse_def (name_start)\n \t\t  ext_hash_ptr = hash_string (arg_start,\n \t\t\t\t\t      arg_end_p1 - arg_start,\n \t\t\t\t\t      &ext_str_hash[0],\n-\t\t\t\t\t      (symint_t *)0);\n+\t\t\t\t\t      (symint_t *) 0);\n \n-\t\t  if (ext_hash_ptr != (shash_t *)0\n-\t\t      && ext_hash_ptr->esym_ptr != (EXTR *)0)\n+\t\t  if (ext_hash_ptr != (shash_t *) 0\n+\t\t      && ext_hash_ptr->esym_ptr != (EXTR *) 0)\n \t\t    eptr = ext_hash_ptr->esym_ptr;\n \n \t\t  orig_hash_ptr = hash_string (arg_start,\n \t\t\t\t\t       arg_end_p1 - arg_start,\n \t\t\t\t\t       &orig_str_hash[0],\n-\t\t\t\t\t       (symint_t *)0);\n+\t\t\t\t\t       (symint_t *) 0);\n \n-\t\t  if ((orig_hash_ptr == (shash_t *)0\n-\t\t       || orig_hash_ptr->sym_ptr == (SYMR *)0)\n-\t\t      && eptr == (EXTR *)0)\n+\t\t  if ((orig_hash_ptr == (shash_t *) 0\n+\t\t       || orig_hash_ptr->sym_ptr == (SYMR *) 0)\n+\t\t      && eptr == (EXTR *) 0)\n \t\t    {\n \t\t      fprintf (stderr, \"warning, %.*s not found in original or external symbol tables, value defaults to 0\\n\",\n \t\t\t       arg_end_p1 - arg_start,\n@@ -3269,8 +3269,8 @@ parse_def (name_start)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      SYMR *ptr = (orig_hash_ptr != (shash_t *)0\n-\t\t\t\t   && orig_hash_ptr->sym_ptr != (SYMR *)0)\n+\t\t      SYMR *ptr = (orig_hash_ptr != (shash_t *) 0\n+\t\t\t\t   && orig_hash_ptr->sym_ptr != (SYMR *) 0)\n \t\t\t\t\t? orig_hash_ptr->sym_ptr\n \t\t\t\t\t: &eptr->asym;\n \n@@ -3294,7 +3294,7 @@ parse_def (name_start)\n     }\n \n \n-  t.extra_sizes = (tag_start != (char *)0);\n+  t.extra_sizes = (tag_start != (char *) 0);\n   if (t.num_dims > 0)\n     {\n       int diff = t.num_dims - t.num_sizes;\n@@ -3352,7 +3352,7 @@ parse_def (name_start)\n \t  || t.basic_type == bt_Union\n \t  || t.basic_type == bt_Enum)\n \t{\n-\t  if (tag_start == (char *)0)\n+\t  if (tag_start == (char *) 0)\n \t    {\n \t      error (\"No tag specified for %.*s\",\n \t\t     name_end_p1 - name_start,\n@@ -3380,8 +3380,8 @@ parse_def (name_start)\n   /* If this is an external or static symbol, update the appropriate\n      external symbol.  */\n \n-  if (eptr != (EXTR *)0\n-      && (eptr->asym.index == indexNil || cur_proc_ptr == (PDR *)0))\n+  if (eptr != (EXTR *) 0\n+      && (eptr->asym.index == indexNil || cur_proc_ptr == (PDR *) 0))\n     {\n       eptr->ifd = cur_file_ptr->file_index;\n       eptr->asym.index = indx;\n@@ -3418,7 +3418,7 @@ parse_def (name_start)\n \t that any error reporting above gives the correct name.  */\n \n     case st_End:\n-      name_start = name_end_p1 = (const char *)0;\n+      name_start = name_end_p1 = (const char *) 0;\n       value = inside_enumeration = 0;\n       break;\n \n@@ -3440,9 +3440,9 @@ parse_def (name_start)\n   /* Add the symbol, except for global symbols outside of functions,\n      for which the external symbol table is fine enough.  */\n \n-  if (eptr == (EXTR *)0\n+  if (eptr == (EXTR *) 0\n       || eptr->asym.st == (int)st_Nil\n-      || cur_proc_ptr != (PDR *)0)\n+      || cur_proc_ptr != (PDR *) 0)\n     {\n       symint_t isym = add_local_symbol (name_start, name_end_p1,\n \t\t\t\t\tsymbol_type, storage_class,\n@@ -3465,7 +3465,7 @@ parse_def (name_start)\n \t  forward_t *f_next = tag_ptr->forward_ref;\n \t  forward_t *f_cur;\n \n-\t  while (f_next != (forward_t *)0)\n+\t  while (f_next != (forward_t *) 0)\n \t    {\n \t      f_cur  = f_next;\n \t      f_next = f_next->next;\n@@ -3476,7 +3476,7 @@ parse_def (name_start)\n \t      free_forward (f_cur);\n \t    }\n \n-\t  tag_ptr->forward_ref = (forward_t *)0;\n+\t  tag_ptr->forward_ref = (forward_t *) 0;\n         }\n     }\n \n@@ -3505,13 +3505,13 @@ parse_end (start)\n   register symint_t value;\n   register FDR *orig_fdr;\n \n-  if (cur_file_ptr == (efdr_t *)0)\n+  if (cur_file_ptr == (efdr_t *) 0)\n     {\n       error (\".end directive without a preceding .file directive\");\n       return;\n     }\n \n-  if (cur_proc_ptr == (PDR *)0)\n+  if (cur_proc_ptr == (PDR *) 0)\n     {\n       error (\".end directive without a preceding .ent directive\");\n       return;\n@@ -3541,7 +3541,7 @@ parse_end (start)\n \n   orig_fdr = cur_file_ptr->orig_fdr;\n   value = 0;\n-  if (orig_fdr != (FDR *)0 && cur_oproc_end != (SYMR *)0)\n+  if (orig_fdr != (FDR *)0 && cur_oproc_end != (SYMR *) 0)\n     value = cur_oproc_end->value;\n \n   else\n@@ -3550,9 +3550,9 @@ parse_end (start)\n   (void) add_local_symbol (start_func, end_func_p1,\n \t\t\t   st_End, sc_Text,\n \t\t\t   value,\n-\t\t\t   (symint_t)0);\n+\t\t\t   (symint_t) 0);\n \n-  cur_proc_ptr = cur_oproc_ptr = (PDR *)0;\n+  cur_proc_ptr = cur_oproc_ptr = (PDR *) 0;\n }\n \n \f\n@@ -3565,13 +3565,13 @@ parse_ent (start)\n   register const char *start_func, *end_func_p1;\n   register int ch;\n \n-  if (cur_file_ptr == (efdr_t *)0)\n+  if (cur_file_ptr == (efdr_t *) 0)\n     {\n       error (\".ent directive without a preceding .file directive\");\n       return;\n     }\n \n-  if (cur_proc_ptr != (PDR *)0)\n+  if (cur_proc_ptr != (PDR *) 0)\n     {\n       error (\"second .ent directive found before .end directive\");\n       return;\n@@ -3605,14 +3605,14 @@ parse_file (start)\n \n   (void) strtol (start, &p, 0);\n   if (start == p\n-      || (start_name = local_index (p, '\"')) == (char *)0\n-      || (end_name_p1 = local_rindex (++start_name, '\"')) == (char *)0)\n+      || (start_name = local_index (p, '\"')) == (char *) 0\n+      || (end_name_p1 = local_rindex (++start_name, '\"')) == (char *) 0)\n     {\n       error (\"Invalid .file directive\");\n       return;\n     }\n \n-  if (cur_proc_ptr != (PDR *)0)\n+  if (cur_proc_ptr != (PDR *) 0)\n     {\n       error (\"No way to handle .file within .ent/.end section\");\n       return;\n@@ -3630,7 +3630,7 @@ mark_stabs (start)\n {\n   if (!stabs_seen)\n     {\n-      /* Add a dummy @stabs symbol. */\n+      /* Add a dummy @stabs symbol.  */\n       stabs_seen = 1;\n       (void) add_local_symbol (stabs_symbol,\n \t\t\t       stabs_symbol + sizeof (stabs_symbol),\n@@ -3673,7 +3673,7 @@ STATIC void\n parse_stabs_common (string_start, string_end, rest)\n      const char *string_start;\t\t/* start of string or NULL */\n      const char *string_end;\t\t/* end+1 of string or NULL */\n-     const char *rest;\t\t\t/* rest of the directive. */\n+     const char *rest;\t\t\t/* rest of the directive.  */\n {\n   efdr_t *save_file_ptr = cur_file_ptr;\n   symint_t code;\n@@ -3733,10 +3733,10 @@ parse_stabs_common (string_start, string_end, rest)\n       shash_ptr = hash_string (p,\n \t\t\t       strlen (p) - 1,\n \t\t\t       &orig_str_hash[0],\n-\t\t\t       (symint_t *)0);\n+\t\t\t       (symint_t *) 0);\n \n-      if (shash_ptr == (shash_t *)0\n-\t  || (sym_ptr = shash_ptr->sym_ptr) == (SYMR *)0)\n+      if (shash_ptr == (shash_t *) 0\n+\t  || (sym_ptr = shash_ptr->sym_ptr) == (SYMR *) 0)\n \t{\n \t  error (\"Invalid .stabs/.stabn directive, value not found\");\n \t  return;\n@@ -3796,27 +3796,27 @@ parse_stabs_common (string_start, string_end, rest)\n \t  const char *start, *end_p1;\n \n \t  start = p;\n-\t  if ((end_p1 = strchr (start, '+')) == (char *)0)\n+\t  if ((end_p1 = strchr (start, '+')) == (char *) 0)\n \t    {\n-\t      if ((end_p1 = strchr (start, '-')) == (char *)0)\n+\t      if ((end_p1 = strchr (start, '-')) == (char *) 0)\n \t\tend_p1 = start + strlen(start) - 1;\n \t    }\n \n \t  shash_ptr = hash_string (start,\n \t\t\t\t   end_p1 - start,\n \t\t\t\t   &orig_str_hash[0],\n-\t\t\t\t   (symint_t *)0);\n+\t\t\t\t   (symint_t *) 0);\n \n-\t  if (shash_ptr == (shash_t *)0\n-\t      || (sym_ptr = shash_ptr->sym_ptr) == (SYMR *)0)\n+\t  if (shash_ptr == (shash_t *) 0\n+\t      || (sym_ptr = shash_ptr->sym_ptr) == (SYMR *) 0)\n \t    {\n \t      shash_ptr = hash_string (start,\n \t\t\t\t       end_p1 - start,\n \t\t\t\t       &ext_str_hash[0],\n-\t\t\t\t       (symint_t *)0);\n+\t\t\t\t       (symint_t *) 0);\n \n-\t      if (shash_ptr == (shash_t *)0\n-\t\t  || shash_ptr->esym_ptr == (EXTR *)0)\n+\t      if (shash_ptr == (shash_t *) 0\n+\t\t  || shash_ptr->esym_ptr == (EXTR *) 0)\n \t\t{\n \t\t  error (\"Invalid .stabs/.stabn directive, value not found\");\n \t\t  return;\n@@ -3825,8 +3825,8 @@ parse_stabs_common (string_start, string_end, rest)\n \t\tsym_ptr = &(shash_ptr->esym_ptr->asym);\n \t    }\n \n-\t  /* Traditionally, N_LBRAC and N_RBRAC are *not* relocated. */\n-\t  if (code == (int)N_LBRAC || code == (int)N_RBRAC)\n+\t  /* Traditionally, N_LBRAC and N_RBRAC are *not* relocated.  */\n+\t  if (code == (int) N_LBRAC || code == (int) N_RBRAC)\n \t    {\n \t      sc = scNil;\n \t      st = stNil;\n@@ -3874,7 +3874,7 @@ parse_stabs (start)\n {\n   const char *end = local_index (start+1, '\"');\n \n-  if (*start != '\"' || end == (const char *)0 || end[1] != ',')\n+  if (*start != '\"' || end == (const char *) 0 || end[1] != ',')\n     {\n       error (\"Invalid .stabs directive, no string\");\n       return;\n@@ -3888,7 +3888,7 @@ STATIC void\n parse_stabn (start)\n      const char *start;\t\t\t/* start of directive */\n {\n-  parse_stabs_common ((const char *)0, (const char *)0, start);\n+  parse_stabs_common ((const char *) 0, (const char *) 0, start);\n }\n \n \f\n@@ -3914,7 +3914,7 @@ parse_input __proto((void))\n   ptag_head->prev = cur_tag_head;\n   cur_tag_head = ptag_head;\n \n-  while ((p = read_line ()) != (char *)0)\n+  while ((p = read_line ()) != (char *) 0)\n     {\n       /* Skip leading blanks */\n       while (isspace (*p))\n@@ -3939,10 +3939,10 @@ parse_input __proto((void))\n   cur_tag_head = ptag_head->prev;\n \n   for (ptag = ptag_head->first_tag;\n-       ptag != (tag_t *)0;\n+       ptag != (tag_t *) 0;\n        ptag = ptag_next)\n     {\n-      if (ptag->forward_ref != (forward_t *)0)\n+      if (ptag->forward_ref != (forward_t *) 0)\n \tadd_unknown_tag (ptag);\n \n       ptag_next = ptag->same_block;\n@@ -3985,7 +3985,7 @@ update_headers __proto((void))\n      for the filename.  */\n \n   for (file_ptr = first_file;\n-       file_ptr != (efdr_t *)0;\n+       file_ptr != (efdr_t *) 0;\n        file_ptr = file_ptr->next_file)\n     {\n       register SYMR *sym_start;\n@@ -4015,8 +4015,8 @@ update_headers __proto((void))\n \t      hash_ptr = hash_string (str,\n \t\t\t\t      (Ptrdiff_t)len,\n \t\t\t\t      &file_ptr->shash_head[0],\n-\t\t\t  \t      (symint_t *)0);\n-\t      if (hash_ptr == (shash_t *)0)\n+\t\t\t  \t      (symint_t *) 0);\n+\t      if (hash_ptr == (shash_t *) 0)\n \t\t{\n \t\t  (void) add_local_symbol (str, str + len,\n \t\t\t\t\t   (st_t)sym->st, (sc_t)sym->sc,\n@@ -4025,10 +4025,10 @@ update_headers __proto((void))\n \t\t}\n \t    }\n \t}\n-      (void) add_local_symbol ((const char *)0, (const char *)0,\n+      (void) add_local_symbol ((const char *) 0, (const char *) 0,\n \t\t\t       st_End, sc_Text,\n-\t\t\t       (symint_t)0,\n-\t\t\t       (symint_t)0);\n+\t\t\t       (symint_t) 0,\n+\t\t\t       (symint_t) 0);\n \n       file_ptr->fdr.cpd = file_ptr->procs.num_allocated;\n       file_ptr->fdr.ipdFirst = symbolic_header.ipdMax;\n@@ -4092,7 +4092,7 @@ update_headers __proto((void))\n       file_offset = ALIGN_SYMTABLE_OFFSET (file_offset);\n     }\n \n-  i = symbolic_header.iauxMax;\t\t\t/* aux syms. */\n+  i = symbolic_header.iauxMax;\t\t\t/* aux syms.  */\n   if (i > 0)\n     {\n       symbolic_header.cbAuxOffset = file_offset;\n@@ -4164,9 +4164,9 @@ write_varray (vp, offset, str)\n       && fseek (object_stream, (long)offset, SEEK_SET) < 0)\n     pfatal_with_name (object_name);\n \n-  for (ptr = vp->first; ptr != (vlinks_t *)0; ptr = ptr->next)\n+  for (ptr = vp->first; ptr != (vlinks_t *) 0; ptr = ptr->next)\n     {\n-      num_write = (ptr->next == (vlinks_t *)0)\n+      num_write = (ptr->next == (vlinks_t *) 0)\n \t? vp->objects_last_page * vp->object_size\n \t: vp->objects_per_page  * vp->object_size;\n \n@@ -4284,7 +4284,7 @@ write_object __proto((void))\n     {\n       offset = symbolic_header.cbPdOffset;\n       for (file_ptr = first_file;\n-\t   file_ptr != (efdr_t *)0;\n+\t   file_ptr != (efdr_t *) 0;\n \t   file_ptr = file_ptr->next_file)\n \t{\n \t  write_varray (&file_ptr->procs, offset, \"Procedure tables\");\n@@ -4296,7 +4296,7 @@ write_object __proto((void))\n     {\n       offset = symbolic_header.cbSymOffset;\n       for (file_ptr = first_file;\n-\t   file_ptr != (efdr_t *)0;\n+\t   file_ptr != (efdr_t *) 0;\n \t   file_ptr = file_ptr->next_file)\n \t{\n \t  write_varray (&file_ptr->symbols, offset, \"Local symbols\");\n@@ -4308,7 +4308,7 @@ write_object __proto((void))\n     {\n       offset = symbolic_header.cbAuxOffset;\n       for (file_ptr = first_file;\n-\t   file_ptr != (efdr_t *)0;\n+\t   file_ptr != (efdr_t *) 0;\n \t   file_ptr = file_ptr->next_file)\n \t{\n \t  write_varray (&file_ptr->aux_syms, offset, \"Aux. symbols\");\n@@ -4320,7 +4320,7 @@ write_object __proto((void))\n     {\n       offset = symbolic_header.cbSsOffset;\n       for (file_ptr = first_file;\n-\t   file_ptr != (efdr_t *)0;\n+\t   file_ptr != (efdr_t *) 0;\n \t   file_ptr = file_ptr->next_file)\n \t{\n \t  write_varray (&file_ptr->strings, offset, \"Local strings\");\n@@ -4340,7 +4340,7 @@ write_object __proto((void))\n \n       file_offset = offset;\n       for (file_ptr = first_file;\n-\t   file_ptr != (efdr_t *)0;\n+\t   file_ptr != (efdr_t *) 0;\n \t   file_ptr = file_ptr->next_file)\n \t{\n \t  if (debug)\n@@ -4416,7 +4416,7 @@ read_seek (size, offset, str)\n   long sys_read = 0;\n \n   if (size == 0)\t\t/* nothing to read */\n-    return (page_t *)0;\n+    return (page_t *) 0;\n \n   if (debug)\n     fprintf (stderr, \"\\trseek\\tsize = %7u, offset = %7u, currently at %7u, %s\\n\",\n@@ -4542,7 +4542,7 @@ copy_object __proto((void))\n      sections, so in theory no extra seeks are done.\n \n      For simplicity sake, round each read up to a page boundary,\n-     we may want to revisit this later.... */\n+     we may want to revisit this later....  */\n \n   file_offset =  orig_file_header.f_symptr + sizeof (struct filehdr);\n \n@@ -4623,7 +4623,7 @@ copy_object __proto((void))\n       char *filename = orig_local_strs + (orig_files->issBase + orig_files->rss);\n       char *suffix = local_rindex (filename, '.');\n \n-      if (suffix != (char *)0 && strcmp (suffix, \".s\") == 0)\n+      if (suffix != (char *) 0 && strcmp (suffix, \".s\") == 0)\n \tdelete_ifd = 1;\n     }\n \n@@ -4670,7 +4670,7 @@ copy_object __proto((void))\n \t\t\t     (st_t) eptr->asym.st,\n \t\t\t     (sc_t) eptr->asym.sc,\n \t\t\t     eptr->asym.value,\n-\t\t\t     (symint_t)((eptr->asym.index == indexNil) ? indexNil : 0),\n+\t\t\t     (symint_t) ((eptr->asym.index == indexNil) ? indexNil : 0),\n \t\t\t     (ifd < orig_sym_hdr.ifdMax) ? remap_file_number[ ifd ] : ifd);\n     }\n \n@@ -4735,7 +4735,7 @@ copy_object __proto((void))\n \t\t\t\t\t\t\t   &orig_str_hash[0],\n \t\t\t\t\t\t\t   &hash_index);\n \n-\t\tif (shash_ptr != (shash_t *)0)\n+\t\tif (shash_ptr != (shash_t *) 0)\n \t\t  error (\"internal error, %s is already in original symbol table\", str);\n \n \t\telse\n@@ -4763,9 +4763,9 @@ copy_object __proto((void))\n \t\t      register shash_t *shash_ptr = hash_string (str,\n \t\t\t\t\t\t\t\t (Ptrdiff_t)len,\n \t\t\t\t\t\t\t\t &orig_str_hash[0],\n-\t\t\t\t\t\t\t\t (symint_t *)0);\n+\t\t\t\t\t\t\t\t (symint_t *) 0);\n \n-\t\t      if (shash_ptr != (shash_t *)0)\n+\t\t      if (shash_ptr != (shash_t *) 0)\n \t\t\tshash_ptr->end_ptr = sym;\n \t\t    }\n \t\t}\n@@ -4793,9 +4793,9 @@ copy_object __proto((void))\n \t  register shash_t *shash_ptr = hash_string (str,\n \t\t\t\t\t\t     (Ptrdiff_t)len,\n \t\t\t\t\t\t     &orig_str_hash[0],\n-\t\t\t\t\t\t     (symint_t *)0);\n+\t\t\t\t\t\t     (symint_t *) 0);\n \n-\t  if (shash_ptr == (shash_t *)0)\n+\t  if (shash_ptr == (shash_t *) 0)\n \t    error (\"internal error, function %s is not in original symbol table\", str);\n \n \t  else\n@@ -4811,12 +4811,12 @@ copy_object __proto((void))\n \n   /* Copy all of the object file up to the symbol table.  Originally\n      we were going to use ftruncate, but that doesn't seem to work\n-     on Ultrix 3.1.... */\n+     on Ultrix 3.1....  */\n \n-  if (fseek (obj_in_stream, (long)0, SEEK_SET) != 0)\n+  if (fseek (obj_in_stream, (long) 0, SEEK_SET) != 0)\n     pfatal_with_name (obj_in_name);\n \n-  if (fseek (object_stream, (long)0, SEEK_SET) != 0)\n+  if (fseek (object_stream, (long) 0, SEEK_SET) != 0)\n     pfatal_with_name (object_name);\n \n   for (remaining = orig_file_header.f_symptr;\n@@ -4910,15 +4910,15 @@ main (argc, argv)\n \tbreak;\n \n       case 'I':\n-\tif (rename_output || obj_in_name != (char *)0)\n+\tif (rename_output || obj_in_name != (char *) 0)\n \t  had_errors++;\n \telse\n \t  rename_output = 1;\n \n \t/* fall through to 'i' case.  */\n \n       case 'i':\n-\tif (obj_in_name == (char *)0)\n+\tif (obj_in_name == (char *) 0)\n \t  {\n \t    obj_in_name = optarg;\n \t    iflag++;\n@@ -4928,7 +4928,7 @@ main (argc, argv)\n \tbreak;\n \n       case 'o':\n-\tif (object_name == (char *)0)\n+\tif (object_name == (char *) 0)\n \t  object_name = optarg;\n \telse\n \t  had_errors++;\n@@ -4939,22 +4939,22 @@ main (argc, argv)\n \tbreak;\n       }\n \n-  if (obj_in_name == (char *)0 && optind <= argc - 2)\n+  if (obj_in_name == (char *) 0 && optind <= argc - 2)\n     obj_in_name = argv[--argc];\n \n-  if (object_name == (char *)0 && optind <= argc - 2)\n+  if (object_name == (char *) 0 && optind <= argc - 2)\n     object_name = argv[--argc];\n \n   /* If there is an output name, but no input name use\n      the same file for both, deleting the name between\n      opening it for input and opening it for output.  */\n-  if (obj_in_name == (char *)0 && object_name != (char *)0)\n+  if (obj_in_name == (char *) 0 && object_name != (char *)0)\n     {\n       obj_in_name = object_name;\n       delete_input = 1;\n     }\n \n-  if (object_name == (char *)0 || had_errors || optind != argc - 1)\n+  if (object_name == (char *) 0 || had_errors || optind != argc - 1)\n     {\n       fprintf (stderr, \"Calling Sequence:\\n\");\n       fprintf (stderr, \"\\tmips-tfile [-d <num>] [-v] [-i <o-in-file>] -o <o-out-file> <s-file> (or)\\n\");\n@@ -4979,7 +4979,7 @@ main (argc, argv)\n       fputc ('\\n', stderr);\n     }\n \n-  if (obj_in_name == (char *)0)\n+  if (obj_in_name == (char *) 0)\n     obj_in_name = object_name;\n \n   if (rename_output && rename (object_name, obj_in_name) != 0)\n@@ -5024,14 +5024,14 @@ main (argc, argv)\n   /* Must open input before output, since the output may be the same file, and\n      we need to get the input handle before truncating it.  */\n   obj_in_stream = fopen (obj_in_name, \"r\");\n-  if (obj_in_stream == (FILE *)0)\n+  if (obj_in_stream == (FILE *) 0)\n     pfatal_with_name (obj_in_name);\n \n   if (delete_input && unlink (obj_in_name) != 0)\n     pfatal_with_name (obj_in_name);\n \n   object_stream = fopen (object_name, \"w\");\n-  if (object_stream == (FILE *)0)\n+  if (object_stream == (FILE *) 0)\n     pfatal_with_name (object_name);\n \n   if (strcmp (argv[optind], \"-\") != 0)\n@@ -5072,7 +5072,7 @@ STATIC void\n catch_signal (signum)\n      int signum;\n {\n-  (void) signal (signum, SIG_DFL);\t/* just in case... */\n+  (void) signal (signum, SIG_DFL);\t/* just in case...  */\n #ifdef NO_SYS_SIGLIST\n   fatal (\"caught signal\");\n #else\n@@ -5087,7 +5087,7 @@ void\n pfatal_with_name (msg)\n      char *msg;\n {\n-  int save_errno = errno;\t\t/* just in case.... */\n+  int save_errno = errno;\t\t/* just in case....  */\n   if (line_number > 0)\n     fprintf (stderr, \"%s, %s:%ld \", progname, input_name, line_number);\n   else\n@@ -5275,7 +5275,7 @@ allocate_scope __proto((void))\n \n #ifndef MALLOC_CHECK\n   ptr = alloc_counts[ (int)alloc_type_scope ].free_list.f_scope;\n-  if (ptr != (scope_t *)0)\n+  if (ptr != (scope_t *) 0)\n     alloc_counts[ (int)alloc_type_scope ].free_list.f_scope = ptr->free;\n \n   else\n@@ -5432,7 +5432,7 @@ allocate_tag __proto((void))\n \n #ifndef MALLOC_CHECK\n   ptr = alloc_counts[ (int)alloc_type_tag ].free_list.f_tag;\n-  if (ptr != (tag_t *)0)\n+  if (ptr != (tag_t *) 0)\n     alloc_counts[ (int)alloc_type_tag ].free_list.f_tag = ptr->free;\n \n   else\n@@ -5490,7 +5490,7 @@ allocate_forward __proto((void))\n \n #ifndef MALLOC_CHECK\n   ptr = alloc_counts[ (int)alloc_type_forward ].free_list.f_forward;\n-  if (ptr != (forward_t *)0)\n+  if (ptr != (forward_t *) 0)\n     alloc_counts[ (int)alloc_type_forward ].free_list.f_forward = ptr->free;\n \n   else\n@@ -5548,7 +5548,7 @@ allocate_thead __proto((void))\n \n #ifndef MALLOC_CHECK\n   ptr = alloc_counts[ (int)alloc_type_thead ].free_list.f_thead;\n-  if (ptr != (thead_t *)0)\n+  if (ptr != (thead_t *) 0)\n     alloc_counts[ (int)alloc_type_thead ].free_list.f_thead = ptr->free;\n \n   else\n@@ -5614,7 +5614,7 @@ fatal VPROTO((const char *format, ...))\n   VA_START (ap, format);\n \n #ifndef __STDC__\n-  format = va_arg (ap, char*);\n+  format = va_arg (ap, char *);\n #endif\n \n   if (line_number > 0)\n@@ -5644,7 +5644,7 @@ error VPROTO((const char *format, ...))\n   VA_START (ap, format);\n \n #ifndef __STDC__\n-  format = va_arg (ap, char*);\n+  format = va_arg (ap, char *);\n #endif\n \n   if (line_number > 0)\n@@ -5779,7 +5779,7 @@ local_index (str, sentinel)\n   for ( ; (ch = *str) != sentinel; str++)\n     {\n       if (ch == '\\0')\n-\treturn (char *)0;\n+\treturn (char *) 0;\n     }\n \n   return (char *)str;\n@@ -5791,7 +5791,7 @@ local_rindex (str, sentinel)\n      int sentinel;\n {\n   int ch;\n-  const char *ret = (const char *)0;\n+  const char *ret = (const char *) 0;\n \n   for ( ; (ch = *str) != '\\0'; str++)\n     {"}, {"sha": "be52fc690252c66180ad25ce0f93a1b64ada1b5f", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 159, "deletions": 155, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -143,12 +143,12 @@ static tree static_instances_decl;\n \n /*** Private Interface (procedures) ***/\n \n-/* Used by compile_file. */\n+/* Used by compile_file.  */\n \n static void init_objc\t\t\t\tPROTO((void));\n static void finish_objc\t\t\t\tPROTO((void));\n \n-/* Code generation. */\n+/* Code generation.  */\n \n static void synth_module_prologue\t\tPROTO((void));\n static tree build_constructor\t\t\tPROTO((tree, tree));\n@@ -230,13 +230,13 @@ static tree build_objc_string_decl\t\tPROTO((tree,\n \t\t\t\t\t\t       enum string_section));\n static tree build_selector_reference_decl\tPROTO((tree));\n \n-/* Protocol additions. */\n+/* Protocol additions.  */\n \n static tree add_protocol\t\t\tPROTO((tree));\n static tree lookup_protocol\t\t\tPROTO((tree));\n static tree lookup_and_install_protocols\tPROTO((tree));\n \n-/* Type encoding. */\n+/* Type encoding.  */\n \n static void encode_type_qualifiers\t\tPROTO((tree));\n static void encode_pointer\t\t\tPROTO((tree, int, int));\n@@ -252,7 +252,7 @@ static int comp_proto_with_proto\t\tPROTO((tree, tree));\n static tree get_arg_type_list\t\t\tPROTO((tree, int, int));\n static tree expr_last\t\t\t\tPROTO((tree));\n \n-/* Utilities for debugging and error diagnostics. */\n+/* Utilities for debugging and error diagnostics.  */\n \n static void warn_with_method\t\t\tPROTO((char *, int, tree));\n static void error_with_ivar\t\t\tPROTO((char *, tree, tree));\n@@ -263,7 +263,7 @@ static int is_complex_decl\t\t\tPROTO((tree));\n static void adorn_decl\t\t\t\tPROTO((tree, char *));\n static void dump_interface\t\t\tPROTO((FILE *, tree));\n \n-/* Everything else. */\n+/* Everything else.  */\n \n static void objc_fatal\t\t\t\tPROTO((void));\n static tree define_decl\t\t\t\tPROTO((tree, tree));\n@@ -323,7 +323,7 @@ static void handle_class_ref\t\t\tPROTO((tree));\n \n /*** Private Interface (data) ***/\n \n-/* Reserved tag definitions. */\n+/* Reserved tag definitions.  */\n \n #define TYPE_ID\t\t\t\"id\"\n #define TAG_OBJECT\t\t\"objc_object\"\n@@ -388,23 +388,24 @@ static tree alias_chain = NULL_TREE;\n static tree interface_chain = NULL_TREE;\n static tree protocol_chain = NULL_TREE;\n \n-/* Chains to manage selectors that are referenced and defined in the module. */\n+/* Chains to manage selectors that are referenced and defined in the\n+   module.  */\n \n-static tree cls_ref_chain = NULL_TREE;\t/* Classes referenced. */\n-static tree sel_ref_chain = NULL_TREE;\t/* Selectors referenced. */\n+static tree cls_ref_chain = NULL_TREE;\t/* Classes referenced.  */\n+static tree sel_ref_chain = NULL_TREE;\t/* Selectors referenced.  */\n \n-/* Chains to manage uniquing of strings. */\n+/* Chains to manage uniquing of strings.  */\n \n static tree class_names_chain = NULL_TREE;\n static tree meth_var_names_chain = NULL_TREE;\n static tree meth_var_types_chain = NULL_TREE;\n \n-/* Hash tables to manage the global pool of method prototypes. */\n+/* Hash tables to manage the global pool of method prototypes.  */\n \n static hash *nst_method_hash_list = 0;\n static hash *cls_method_hash_list = 0;\n \n-/* Backend data declarations. */\n+/* Backend data declarations.  */\n \n static tree UOBJC_SYMBOLS_decl;\n static tree UOBJC_INSTANCE_VARIABLES_decl, UOBJC_CLASS_VARIABLES_decl;\n@@ -457,7 +458,7 @@ static int  method_slot = 0;\t/* Used by start_method_def, */\n \n static char *errbuf;\t/* Buffer for error diagnostics */\n \n-/* Data imported from tree.c. */\n+/* Data imported from tree.c.  */\n \n extern enum debug_info_type write_symbols;\n \n@@ -482,7 +483,7 @@ int flag_gen_declaration = 0;\n FILE *gen_declaration_file;\n \n /* Warn if multiple methods are seen for the same selector, but with\n-   different argument types. */\n+   different argument types.  */\n \n int warn_selector = 0;\n \n@@ -496,7 +497,7 @@ int flag_warn_protocol = 1;\n    type descriptors for instance variables (as opposed to methods).\n    Type descriptors for instance variables contain more information\n    than methods (for static typing and embedded structures). This\n-   was added to support features being planned for dbkit2. */\n+   was added to support features being planned for dbkit2.  */\n \n static int generating_instance_variables = 0;\n \n@@ -677,7 +678,7 @@ lookup_protocol_in_reflist (rproto_list, lproto)\n {\n    tree rproto, p;\n \n-   /* Make sure the protocol is support by the object on the rhs. */\n+   /* Make sure the protocol is support by the object on the rhs.  */\n    if (TREE_CODE (lproto) == PROTOCOL_INTERFACE_TYPE)\n      {\n        tree fnd = 0;\n@@ -699,7 +700,7 @@ lookup_protocol_in_reflist (rproto_list, lproto)\n \t }\n      }\n    else\n-     ; /* An identifier...if we could not find a protocol. */\n+     ; /* An identifier...if we could not find a protocol.  */\n \n    return 0;\n }\n@@ -715,7 +716,7 @@ objc_comptypes (lhs, rhs, reflexive)\n      tree rhs;\n      int reflexive;\n {\n-  /* New clause for protocols. */\n+  /* New clause for protocols.  */\n \n   if (TREE_CODE (lhs) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (lhs)) == RECORD_TYPE\n@@ -767,7 +768,7 @@ objc_comptypes (lhs, rhs, reflexive)\n \t\t      rproto_list = CLASS_PROTOCOL_LIST (rinter);\n \t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n \n-\t\t      /* Check for protocols adopted by categories. */\n+\t\t      /* Check for protocols adopted by categories.  */\n \t\t      cat = CLASS_CATEGORY_LIST (rinter);\n \t\t      while (cat && !rproto)\n \t\t\t{\n@@ -802,7 +803,7 @@ objc_comptypes (lhs, rhs, reflexive)\n   else if (TREE_CODE (lhs) == RECORD_TYPE && TREE_CODE (rhs) == RECORD_TYPE)\n     ; /* Fall thru.  This is the case we have been handling all along */\n   else\n-    /* Defer to comptypes. */\n+    /* Defer to comptypes.  */\n     return -1;\n \n   /* `id' = `<class> *', `<class> *' = `id' */\n@@ -847,7 +848,7 @@ objc_comptypes (lhs, rhs, reflexive)\n       return 0;\n     }\n   else\n-    /* Defer to comptypes. */\n+    /* Defer to comptypes.  */\n     return -1;\n }\n \n@@ -987,7 +988,7 @@ lookup_and_install_protocols (protocols)\n \t}\n       else\n \t{\n-\t  /* Replace identifier with actual protocol node. */\n+\t  /* Replace identifier with actual protocol node.  */\n \t  TREE_VALUE (proto) = p;\n \t  prev = proto;\n \t}\n@@ -1620,7 +1621,7 @@ build_module_descriptor ()\n \n   finish_struct (objc_module_template, field_decl_chain, NULL_TREE);\n \n-  /* Create an instance of \"objc_module\". */\n+  /* Create an instance of \"objc_module\".  */\n \n   decl_specs = tree_cons (NULL_TREE, objc_module_template,\n \t\t\t  build_tree_list (NULL_TREE,\n@@ -1635,13 +1636,13 @@ build_module_descriptor ()\n \t       init_module_descriptor (TREE_TYPE (UOBJC_MODULES_decl)),\n \t       NULL_TREE);\n \n-  /* Mark the decl to avoid \"defined but not used\" warning. */\n+  /* Mark the decl to avoid \"defined but not used\" warning.  */\n   DECL_IN_SYSTEM_HEADER (UOBJC_MODULES_decl) = 1;\n \n   /* Generate a constructor call for the module descriptor.\n      This code was generated by reading the grammar rules\n      of c-parse.in;  Therefore, it may not be the most efficient\n-     way of generating the requisite code. */\n+     way of generating the requisite code.  */\n \n   if (flag_next_runtime)\n     return 0;\n@@ -1652,7 +1653,7 @@ build_module_descriptor ()\n     extern tree get_file_function_name ();\n     tree init_function_name = get_file_function_name ('I');\n \n-    /* Declare void __objc_execClass (void*); */\n+    /* Declare void __objc_execClass (void *); */\n \n     void_list_node = build_tree_list (NULL_TREE, void_type_node);\n     function_type\n@@ -1823,7 +1824,7 @@ generate_static_references ()\n   finish_decl (static_instances_decl, expr, NULL_TREE);\n }\n \n-/* Output all strings. */\n+/* Output all strings.  */\n \n static void\n generate_strings ()\n@@ -2012,7 +2013,7 @@ build_selector_translation_table ()\n       /* Cause the variable and its initial value to be actually output.  */\n       DECL_EXTERNAL (UOBJC_SELECTOR_TABLE_decl) = 0;\n       TREE_STATIC (UOBJC_SELECTOR_TABLE_decl) = 1;\n-      /* NULL terminate the list and fix the decl for output. */\n+      /* NULL terminate the list and fix the decl for output.  */\n       initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n       DECL_INITIAL (UOBJC_SELECTOR_TABLE_decl) = (tree) 1;\n       initlist = build_constructor (TREE_TYPE (UOBJC_SELECTOR_TABLE_decl),\n@@ -2214,7 +2215,7 @@ get_class_reference (ident)\n    generation.\n \n    For each string section we have a chain which maps identifier nodes\n-   to decls for the strings. */\n+   to decls for the strings.  */\n \n static tree\n add_objc_string (ident, section)\n@@ -2497,7 +2498,7 @@ build_private_template (class)\n   return ivar_context;\n }\n \f\n-/* Begin code generation for protocols... */\n+/* Begin code generation for protocols...  */\n \n /* struct objc_protocol {\n      char *protocol_name;\n@@ -2616,7 +2617,7 @@ build_method_prototype_list_template (list_type, size)\n   tree objc_ivar_list_record;\n   tree decl_specs, field_decl, field_decl_chain;\n \n-  /* Generate an unnamed struct definition. */\n+  /* Generate an unnamed struct definition.  */\n \n   objc_ivar_list_record = start_struct (RECORD_TYPE, NULL_TREE);\n \n@@ -2682,7 +2683,7 @@ build_method_prototype_template ()\n   return proto_record;\n }\n \n-/* True if last call to forwarding_offset yielded a register offset. */\n+/* True if last call to forwarding_offset yielded a register offset.  */\n static int offset_is_register;\n \n static int\n@@ -2742,15 +2743,15 @@ encode_method_prototype (method_decl, func_decl)\n   char buf[40];\n   tree result;\n \n-  /* ONEWAY and BYCOPY, for remote object are the only method qualifiers. */\n+  /* ONEWAY and BYCOPY, for remote object are the only method qualifiers.  */\n   encode_type_qualifiers (TREE_PURPOSE (TREE_TYPE (method_decl)));\n \n-  /* C type. */\n+  /* C type.  */\n   encode_type (TREE_TYPE (TREE_TYPE (func_decl)),\n \t       obstack_object_size (&util_obstack),\n \t       OBJC_ENCODE_INLINE_DEFS);\n \n-  /* Stack size. */\n+  /* Stack size.  */\n   for (parms = DECL_ARGUMENTS (func_decl); parms;\n        parms = TREE_CHAIN (parms))\n     {\n@@ -2769,26 +2770,26 @@ encode_method_prototype (method_decl, func_decl)\n \n   user_args = METHOD_SEL_ARGS (method_decl);\n \n-  /* Argument types. */\n+  /* Argument types.  */\n   for (parms = DECL_ARGUMENTS (func_decl), i = 0; parms;\n        parms = TREE_CHAIN (parms), i++)\n     {\n-      /* Process argument qualifiers for user supplied arguments. */\n+      /* Process argument qualifiers for user supplied arguments.  */\n       if (i > 1)\n         {\n \t  encode_type_qualifiers (TREE_PURPOSE (TREE_TYPE (user_args)));\n \t  user_args = TREE_CHAIN (user_args);\n  \t}\n \n-      /* Type. */\n+      /* Type.  */\n       encode_type (TREE_TYPE (parms),\n \t\t   obstack_object_size (&util_obstack),\n \t\t   OBJC_ENCODE_INLINE_DEFS);\n \n-      /* Compute offset. */\n+      /* Compute offset.  */\n       sprintf (buf, \"%d\", forwarding_offset (parms));\n \n-      /* Indicate register. */\n+      /* Indicate register.  */\n       if (offset_is_register)\n \tobstack_1grow (&util_obstack, '+');\n       \n@@ -2928,7 +2929,7 @@ hack_method_prototype (nst_methods, tmp_decl)\n   tree parms;\n   tree parm;\n \n-  /* Hack to avoid problem with static typing of self arg. */\n+  /* Hack to avoid problem with static typing of self arg.  */\n   TREE_SET_CODE (nst_methods, CLASS_METHOD_DECL);\n   start_method_def (nst_methods);\n   TREE_SET_CODE (nst_methods, INSTANCE_METHOD_DECL);\n@@ -2974,7 +2975,7 @@ generate_protocol_references (plist)\n {\n   tree lproto;\n \n-  /* Forward declare protocols referenced. */\n+  /* Forward declare protocols referenced.  */\n   for (lproto = plist; lproto; lproto = TREE_CHAIN (lproto))\n     {\n       tree proto = TREE_VALUE (lproto);\n@@ -3018,7 +3019,7 @@ generate_protocols ()\n       if (! PROTOCOL_FORWARD_DECL (p))\n \tcontinue;\n \n-      /* Make sure we link in the Protocol class. */\n+      /* Make sure we link in the Protocol class.  */\n       add_class_reference (get_identifier (PROTOCOL_OBJECT_CLASS_NAME));\n \n       while (nst_methods)\n@@ -3086,7 +3087,7 @@ generate_protocols ()\n \t\t\t\t\t     UOBJC_CLASS_METHODS_decl);\n       finish_decl (decl, initlist, NULL_TREE);\n \n-      /* Mark the decl as used to avoid \"defined but not used\" warning. */\n+      /* Mark the decl as used to avoid \"defined but not used\" warning.  */\n       TREE_USED (decl) = 1;\n     }\n }\n@@ -3424,7 +3425,7 @@ synth_forward_declarations ()\n   TREE_USED (UOBJC_METACLASS_decl) = 1;\n   DECL_ARTIFICIAL(UOBJC_METACLASS_decl) = 1;\n \n-  /* Pre-build the following entities - for speed/convenience. */\n+  /* Pre-build the following entities - for speed/convenience.  */\n \n   an_id = get_identifier (\"super_class\");\n   ucls_super_ref = build_component_ref (UOBJC_CLASS_decl, an_id);\n@@ -3696,17 +3697,17 @@ build_ivar_list_initializer (type, field_decl)\n     {\n       tree ivar = NULL_TREE;\n \n-      /* Set name. */\n+      /* Set name.  */\n       if (DECL_NAME (field_decl))\n \tivar = tree_cons (NULL_TREE,\n \t\t\t  add_objc_string (DECL_NAME (field_decl),\n \t\t\t\t\t   meth_var_names),\n \t\t\t  ivar);\n       else\n-\t/* Unnamed bit-field ivar (yuck). */\n+\t/* Unnamed bit-field ivar (yuck).  */\n \tivar = tree_cons (NULL_TREE, build_int_2 (0, 0), ivar);\n \n-      /* Set type. */\n+      /* Set type.  */\n       encode_field_decl (field_decl,\n \t\t\t obstack_object_size (&util_obstack),\n \t\t\t OBJC_ENCODE_DONT_INLINE_DEFS);\n@@ -3786,7 +3787,7 @@ generate_ivar_lists ()\n   variable_length_type = groktypename (cast);\n \n   /* Only generate class variables for the root of the inheritance\n-     hierarchy since these will be the same for every class. */\n+     hierarchy since these will be the same for every class.  */\n \n   if (CLASS_SUPER_NAME (implementation_template) == NULL_TREE\n       && (chain = TYPE_FIELDS (objc_class_template)))\n@@ -3997,7 +3998,7 @@ generate_dispatch_tables ()\n \t\t\t\t     \"_OBJC_INSTANCE_METHODS\",\n \t\t\t\t     size, initlist);\n       else\n-\t/* We have a category. */\n+\t/* We have a category.  */\n \tUOBJC_INSTANCE_METHODS_decl\n \t  = generate_dispatch_table (method_list_template,\n \t\t\t\t     \"_OBJC_CATEGORY_INSTANCE_METHODS\",\n@@ -4034,13 +4035,13 @@ generate_protocol_list (i_or_p)\n \t\t\t\t     get_identifier (UTAG_PROTOCOL))),\n \t  build1 (INDIRECT_REF, NULL_TREE, NULL_TREE)));\n \n-  /* Compute size. */\n+  /* Compute size.  */\n   for (lproto = plist; lproto; lproto = TREE_CHAIN (lproto))\n     if (TREE_CODE (TREE_VALUE (lproto)) == PROTOCOL_INTERFACE_TYPE\n \t&& PROTOCOL_FORWARD_DECL (TREE_VALUE (lproto)))\n       size++;\n \n-  /* Build initializer. */\n+  /* Build initializer.  */\n   initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), NULL_TREE);\n \n   e = build_int_2 (size, 0);\n@@ -4260,6 +4261,7 @@ build_shared_structure_initializer (type, isa, super, name, size, status,\n }\n \n /* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */\n+\n static void\n generate_category (cat)\n      tree cat;\n@@ -4340,7 +4342,7 @@ generate_shared_structures ()\n       while (1);\n     }\n   else\n-    /* No super class. */\n+    /* No super class.  */\n     my_root_id = CLASS_NAME (implementation_template);\n \n   cast_type\n@@ -4352,7 +4354,7 @@ generate_shared_structures ()\n   name_expr = add_objc_string (CLASS_NAME (implementation_template),\n \t\t\t       class_names);\n \n-  /* Install class `isa' and `super' pointers at runtime. */\n+  /* Install class `isa' and `super' pointers at runtime.  */\n   if (my_super_id)\n     {\n       super_expr = add_objc_string (my_super_id, class_names);\n@@ -4436,7 +4438,7 @@ synth_id_with_class_suffix (preamble, ctxt)\n   else if (TREE_CODE (ctxt) == CATEGORY_IMPLEMENTATION_TYPE\n \t   || TREE_CODE (ctxt) == CATEGORY_INTERFACE_TYPE)\n     {\n-      /* We have a category. */\n+      /* We have a category.  */\n       char *class_name\n \t= IDENTIFIER_POINTER (CLASS_NAME (implementation_context));\n       char *class_super_name\n@@ -4526,7 +4528,7 @@ build_keyword_decl (key_name, arg_type, arg_name)\n {\n   tree keyword_decl;\n \n-  /* If no type is specified, default to \"id\". */\n+  /* If no type is specified, default to \"id\".  */\n   arg_type = adjust_type_for_id_default (arg_type);\n \n   keyword_decl = make_node (KEYWORD_DECL);\n@@ -4558,7 +4560,7 @@ build_keyword_selector (selector)\n       if (key_name)\n \tlen += IDENTIFIER_LENGTH (key_name) + 1;\n       else\n-\t/* Just a ':' arg. */\n+\t/* Just a ':' arg.  */\n \tlen++;\n     }\n \n@@ -4580,7 +4582,7 @@ build_keyword_selector (selector)\n   return get_identifier (buf);\n }\n \n-/* Used for declarations and definitions. */\n+/* Used for declarations and definitions.  */\n \n tree\n build_method_decl (code, ret_type, selector, add_args)\n@@ -4591,7 +4593,7 @@ build_method_decl (code, ret_type, selector, add_args)\n {\n   tree method_decl;\n \n-  /* If no type is specified, default to \"id\". */\n+  /* If no type is specified, default to \"id\".  */\n   ret_type = adjust_type_for_id_default (ret_type);\n \n   method_decl = make_node (code);\n@@ -4633,18 +4635,18 @@ get_arg_type_list (meth, context, superflag)\n {\n   tree arglist, akey;\n \n-  /* Receiver type. */\n+  /* Receiver type.  */\n   if (flag_next_runtime && superflag)\n     arglist = build_tree_list (NULL_TREE, super_type);\n   else if (context == METHOD_DEF)\n     arglist = build_tree_list (NULL_TREE, TREE_TYPE (self_decl));\n   else\n     arglist = build_tree_list (NULL_TREE, id_type);\n \n-  /* Selector type - will eventually change to `int'. */\n+  /* Selector type - will eventually change to `int'.  */\n   chainon (arglist, build_tree_list (NULL_TREE, selector_type));\n \n-  /* Build a list of argument types. */\n+  /* Build a list of argument types.  */\n   for (akey = METHOD_SEL_ARGS (meth); akey; akey = TREE_CHAIN (akey))\n     {\n       tree arg_decl = groktypename_in_parm_context (TREE_TYPE (akey));\n@@ -4680,7 +4682,7 @@ check_duplicates (hsh)\n \n       if (hsh->list)\n         {\n-\t  /* We have two methods with the same name and different types. */\n+\t  /* We have two methods with the same name and different types.  */\n \t  attr loop;\n \t  char type = (TREE_CODE (meth) == INSTANCE_METHOD_DECL) ? '-' : '+';\n \n@@ -4709,7 +4711,7 @@ receiver_is_class_object (receiver)\n       /* The receiver is a variable created by build_class_reference_decl.  */\n       if (TREE_CODE (receiver) == VAR_DECL\n \t  && TREE_TYPE (receiver) == objc_class_type)\n-\t/* Look up the identifier. */\n+\t/* Look up the identifier.  */\n \tfor (chain = cls_ref_chain; chain; chain = TREE_CHAIN (chain))\n \t  if (TREE_PURPOSE (chain) == receiver)\n \t    return TREE_VALUE (chain);\n@@ -4741,7 +4743,7 @@ receiver_is_class_object (receiver)\n \f\n /* If we are currently building a message expr, this holds\n    the identifier of the selector of the message.  This is\n-   used when printing warnings about argument mismatches. */\n+   used when printing warnings about argument mismatches.  */\n \n static tree building_objc_message_expr = 0;\n \n@@ -4781,7 +4783,7 @@ build_message_expr (mess)\n   if (TREE_CODE (receiver) == ERROR_MARK)\n     return error_mark_node;\n \n-  /* Determine receiver type. */\n+  /* Determine receiver type.  */\n   rtype = TREE_TYPE (receiver);\n   super = IS_SUPER (rtype);\n \n@@ -4808,7 +4810,7 @@ build_message_expr (mess)\n       if (statically_allocated)\n \treceiver = build_unary_op (ADDR_EXPR, receiver, 0);\n \n-      /* Don't evaluate the receiver twice. */\n+      /* Don't evaluate the receiver twice.  */\n       receiver = save_expr (receiver);\n       self_object = receiver;\n     }\n@@ -4819,7 +4821,7 @@ build_message_expr (mess)\n   /* Obtain the full selector name.  */\n \n   if (TREE_CODE (args) == IDENTIFIER_NODE)\n-    /* A unary selector. */\n+    /* A unary selector.  */\n     sel_name = args;\n   else if (TREE_CODE (args) == TREE_LIST)\n     sel_name = build_keyword_selector (args);\n@@ -4917,7 +4919,8 @@ build_message_expr (mess)\n \n \t  if (! method_prototype\n \t      && implementation_template != implementation_context)\n-\t    /* The method is not published in the interface.  Check locally. */\n+\t    /* The method is not published in the interface.  Check\n+               locally.  */\n \t    method_prototype\n \t      = lookup_method (CLASS_NST_METHODS (implementation_context),\n \t\t\t       sel_name);\n@@ -4954,7 +4957,8 @@ build_message_expr (mess)\n \n \t  if (!method_prototype\n \t      && implementation_template != implementation_context)\n-\t    /* The method is not published in the interface. Check locally. */\n+\t    /* The method is not published in the interface. Check\n+               locally.  */\n \t    method_prototype\n \t      = lookup_method (CLASS_CLS_METHODS (implementation_context),\n \t\t\t       sel_name);\n@@ -4990,7 +4994,7 @@ build_message_expr (mess)\n \t  warning (\"method `%s' not implemented by protocol.\",\n \t\t   IDENTIFIER_POINTER (sel_name));\n \n-          /* Try and find the method signature in the global pools. */\n+          /* Try and find the method signature in the global pools.  */\n \n           if (!(hsh = hash_lookup (nst_method_hash_list, sel_name)))\n \t    hsh = hash_lookup (cls_method_hash_list, sel_name);\n@@ -5007,7 +5011,7 @@ build_message_expr (mess)\n       hsh = hash_lookup (nst_method_hash_list, sel_name);\n       if (!hsh)\n \t/* For various loopholes, like sending messages to self in a\n-\t   factory context. */\n+\t   factory context.  */\n \thsh = hash_lookup (cls_method_hash_list, sel_name);\n \n       method_prototype = check_duplicates (hsh);\n@@ -5221,9 +5225,9 @@ build_selector_expr (selnamelist)\n   if (!doing_objc_thang)\n     objc_fatal ();\n \n-  /* Obtain the full selector name. */\n+  /* Obtain the full selector name.  */\n   if (TREE_CODE (selnamelist) == IDENTIFIER_NODE)\n-    /* A unary selector. */\n+    /* A unary selector.  */\n     selname = selnamelist;\n   else if (TREE_CODE (selnamelist) == TREE_LIST)\n     selname = build_keyword_selector (selnamelist);\n@@ -5249,7 +5253,7 @@ build_encode_expr (type)\n   obstack_1grow (&util_obstack, 0);    /* null terminate string */\n   string = obstack_finish (&util_obstack);\n \n-  /* Synthesize a string that represents the encoded struct/union. */\n+  /* Synthesize a string that represents the encoded struct/union.  */\n   result = my_build_string (strlen (string) + 1, string);\n   obstack_free (&util_obstack, util_firstobj);\n   return result;\n@@ -5530,7 +5534,7 @@ add_class_method (class, method)\n \t       IDENTIFIER_POINTER (METHOD_SEL_NAME (mth)));\n       else\n         {\n-\t  /* Check types; if different, complain. */\n+\t  /* Check types; if different, complain.  */\n \t  if (!comp_proto_with_proto (method, mth))\n \t    error (\"duplicate declaration of class method `%s'.\",\n \t\t   IDENTIFIER_POINTER (METHOD_SEL_NAME (mth)));\n@@ -5539,12 +5543,12 @@ add_class_method (class, method)\n \n   if (!(hsh = hash_lookup (cls_method_hash_list, METHOD_SEL_NAME (method))))\n     {\n-      /* Install on a global chain. */\n+      /* Install on a global chain.  */\n       hash_enter (cls_method_hash_list, method);\n     }\n   else\n     {\n-      /* Check types; if different, add to a list. */\n+      /* Check types; if different, add to a list.  */\n       if (!comp_proto_with_proto (method, hsh->key))\n         hash_add_attr (hsh, method);\n     }\n@@ -5576,7 +5580,7 @@ add_instance_method (class, method)\n \t       IDENTIFIER_POINTER (METHOD_SEL_NAME (mth)));\n       else\n         {\n-\t  /* Check types; if different, complain. */\n+\t  /* Check types; if different, complain.  */\n \t  if (!comp_proto_with_proto (method, mth))\n \t    error (\"duplicate declaration of instance method `%s'.\",\n \t\t   IDENTIFIER_POINTER (METHOD_SEL_NAME (mth)));\n@@ -5585,7 +5589,7 @@ add_instance_method (class, method)\n \n   if (!(hsh = hash_lookup (nst_method_hash_list, METHOD_SEL_NAME (method))))\n     {\n-      /* Install on a global chain. */\n+      /* Install on a global chain.  */\n       hash_enter (nst_method_hash_list, method);\n     }\n   else\n@@ -5601,7 +5605,7 @@ static tree\n add_class (class)\n      tree class;\n {\n-  /* Put interfaces on list in reverse order. */\n+  /* Put interfaces on list in reverse order.  */\n   TREE_CHAIN (class) = interface_chain;\n   interface_chain = class;\n   return interface_chain;\n@@ -5612,7 +5616,7 @@ add_category (class, category)\n       tree class;\n       tree category;\n {\n-  /* Put categories on list in reverse order. */\n+  /* Put categories on list in reverse order.  */\n   tree cat = CLASS_CATEGORY_LIST (class);\n \n   while (cat)\n@@ -5653,7 +5657,7 @@ add_instance_variable (class, public, declarator, declspecs, width)\n   field_decl = grokfield (input_filename, lineno,\n \t\t\t  declarator, declspecs, width);\n \n-  /* Overload the public attribute, it is not used for FIELD_DECLs. */\n+  /* Overload the public attribute, it is not used for FIELD_DECLs.  */\n   switch (public)\n     {\n     case 0:\n@@ -5768,7 +5772,7 @@ is_public (expr, identifier)\n   return 1;\n }\n \n-/* Implement @defs (<classname>) within struct bodies. */\n+/* Implement @defs (<classname>) within struct bodies.  */\n \n tree\n get_class_ivars (interface)\n@@ -5780,7 +5784,7 @@ get_class_ivars (interface)\n   return build_ivar_chain (interface, 1);\n }\n \f\n-/* Make sure all entries in CHAIN are also in LIST. */\n+/* Make sure all entries in CHAIN are also in LIST.  */\n \n static int\n check_methods (chain, list, mtype)\n@@ -5846,7 +5850,7 @@ conforms_to_protocol (class, protocol)\n }\n \n /* Make sure all methods in CHAIN are accessible as MTYPE methods in \n-   CONTEXT.  This is one of two mechanisms to check protocol integrity. */\n+   CONTEXT.  This is one of two mechanisms to check protocol integrity.  */\n \n static int\n check_methods_accessible (chain, context, mtype)\n@@ -5906,7 +5910,7 @@ check_methods_accessible (chain, context, mtype)\n \t\t   mtype, IDENTIFIER_POINTER (METHOD_SEL_NAME (chain)));\n \t}\n \n-      chain = TREE_CHAIN (chain); /* next method... */\n+      chain = TREE_CHAIN (chain); /* next method...  */\n     }\n     return first;\n }\n@@ -5925,7 +5929,7 @@ check_protocols (proto_list, type, name)\n \t{\n \t  int f1, f2;\n \t  \n-\t  /* Ensure that all protocols have bodies. */\n+\t  /* Ensure that all protocols have bodies.  */\n \t  if (flag_warn_protocol) {\n \t    f1 = check_methods (PROTOCOL_CLS_METHODS (p),\n \t\t\t\tCLASS_CLS_METHODS (implementation_context),\n@@ -5950,7 +5954,7 @@ check_protocols (proto_list, type, name)\n       else\n \t; /* An identifier if we could not find a protocol.  */\n \n-      /* Check protocols recursively. */\n+      /* Check protocols recursively.  */\n       if (PROTOCOL_LIST (p))\n \t{\n \t  tree super_class\n@@ -6017,7 +6021,7 @@ start_class (code, class_name, super_name, protocol_list)\n \t\t\t\t\t      implemented_classes);\n       }\n \n-      /* Pre-build the following entities - for speed/convenience. */\n+      /* Pre-build the following entities - for speed/convenience.  */\n       if (!self_id)\n \t  self_id = get_identifier (\"self\");\n       if (!ucmd_id)\n@@ -6033,7 +6037,7 @@ start_class (code, class_name, super_name, protocol_list)\n \n       implementation_context = class;\n \n-      /* Lookup the interface for this implementation. */\n+      /* Lookup the interface for this implementation.  */\n \n       if (!(implementation_template = lookup_interface (class_name)))\n         {\n@@ -6099,7 +6103,7 @@ start_class (code, class_name, super_name, protocol_list)\n \n   else if (code == CATEGORY_IMPLEMENTATION_TYPE)\n     {\n-      /* Pre-build the following entities for speed/convenience. */\n+      /* Pre-build the following entities for speed/convenience.  */\n       if (!self_id)\n         self_id = get_identifier (\"self\");\n       if (!ucmd_id)\n@@ -6117,7 +6121,7 @@ start_class (code, class_name, super_name, protocol_list)\n \n       /* For a category, class_name is really the name of the class that\n \t the following set of methods will be associated with.  We must\n-\t find the interface so that can derive the objects template. */\n+\t find the interface so that can derive the objects template.  */\n \n       if (!(implementation_template = lookup_interface (class_name)))\n         {\n@@ -6139,7 +6143,7 @@ continue_class (class)\n       struct imp_entry *imp_entry;\n       tree ivar_context;\n \n-      /* Check consistency of the instance variables. */\n+      /* Check consistency of the instance variables.  */\n \n       if (CLASS_IVARS (class))\n \tcheck_ivars (implementation_template, class);\n@@ -6163,7 +6167,7 @@ continue_class (class)\n       imp_entry->class_decl = UOBJC_CLASS_decl;\n       imp_entry->meta_decl = UOBJC_METACLASS_decl;\n \n-      /* Append to front and increment count. */\n+      /* Append to front and increment count.  */\n       imp_list = imp_entry;\n       if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE)\n \timp_count++;\n@@ -6201,11 +6205,11 @@ finish_class (class)\n {\n   if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE)\n     {\n-      /* All code generation is done in finish_objc. */\n+      /* All code generation is done in finish_objc.  */\n \n       if (implementation_template != implementation_context)\n \t{\n-\t  /* Ensure that all method listed in the interface contain bodies. */\n+\t  /* Ensure that all method listed in the interface contain bodies.  */\n \t  check_methods (CLASS_CLS_METHODS (implementation_template),\n \t\t\t CLASS_CLS_METHODS (implementation_context), '+');\n \t  check_methods (CLASS_NST_METHODS (implementation_template),\n@@ -6222,7 +6226,7 @@ finish_class (class)\n     {\n       tree category = CLASS_CATEGORY_LIST (implementation_template);\n \n-      /* Find the category interface from the class it is associated with. */\n+      /* Find the category interface from the class it is associated with.  */\n       while (category)\n \t{\n \t  if (CLASS_SUPER_NAME (class) == CLASS_SUPER_NAME (category))\n@@ -6232,7 +6236,7 @@ finish_class (class)\n \n       if (category)\n \t{\n-\t  /* Ensure all method listed in the interface contain bodies. */\n+\t  /* Ensure all method listed in the interface contain bodies.  */\n \t  check_methods (CLASS_CLS_METHODS (category),\n \t\t\t CLASS_CLS_METHODS (implementation_context), '+');\n \t  check_methods (CLASS_NST_METHODS (category),\n@@ -6266,7 +6270,7 @@ static tree\n add_protocol (protocol)\n      tree protocol;\n {\n-  /* Put protocol on list in reverse order. */\n+  /* Put protocol on list in reverse order.  */\n   TREE_CHAIN (protocol) = protocol_chain;\n   protocol_chain = protocol;\n   return protocol_chain;\n@@ -6464,12 +6468,12 @@ encode_aggregate (type, curtype, format)\n \t  {\n \t    tree name = TYPE_NAME (type);\n \n-\t    /* We have a reference; this is a NeXT extension. */\n+\t    /* We have a reference; this is a NeXT extension.  */\n \n \t    if (obstack_object_size (&util_obstack) - curtype == 1\n \t\t&& format == OBJC_ENCODE_INLINE_DEFS)\n \t      {\n-\t\t/* Output format of struct for first level only. */\n+\t\t/* Output format of struct for first level only.  */\n \t\ttree fields = TYPE_FIELDS (type);\n \n \t\tif (name && TREE_CODE (name) == IDENTIFIER_NODE)\n@@ -6500,7 +6504,7 @@ encode_aggregate (type, curtype, format)\n \t      }\n \n \t    else\n-\t      /* We have an untagged structure or a typedef. */\n+\t      /* We have an untagged structure or a typedef.  */\n \t      obstack_grow (&util_obstack, \"{?}\", 3);\n \t  }\n \n@@ -6554,7 +6558,7 @@ encode_aggregate (type, curtype, format)\n \t\t\t\tIDENTIFIER_POINTER (name),\n \t\t\t\tstrlen (IDENTIFIER_POINTER (name)));\n \t\telse\n-\t\t  /* We have an untagged structure or a typedef. */\n+\t\t  /* We have an untagged structure or a typedef.  */\n \t\t  obstack_1grow (&util_obstack, '?');\n \n \t\tobstack_1grow (&util_obstack, '}');\n@@ -6581,7 +6585,7 @@ encode_aggregate (type, curtype, format)\n \t      }\n \n \t    else\n-\t      /* We have an untagged structure or a typedef. */\n+\t      /* We have an untagged structure or a typedef.  */\n \t      obstack_grow (&util_obstack, \"(?)\", 3);\n \t  }\n \telse\n@@ -6637,7 +6641,7 @@ encode_type (type, curtype, format)\n       if (TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) == 0\n \t  && TREE_INT_CST_HIGH (TYPE_MIN_VALUE (type)) == 0)\n \t{\n-\t  /* Unsigned integer types. */\n+\t  /* Unsigned integer types.  */\n \n \t  if (TYPE_MODE (type) == QImode)\n \t    obstack_1grow (&util_obstack, 'C');\n@@ -6655,7 +6659,7 @@ encode_type (type, curtype, format)\n \t}\n \n       else\n-\t/* Signed integer types. */\n+\t/* Signed integer types.  */\n \t{\n \t  if (TYPE_MODE (type) == QImode)\n \t    obstack_1grow (&util_obstack, 'c');\n@@ -6676,7 +6680,7 @@ encode_type (type, curtype, format)\n \n   else if (code == REAL_TYPE)\n     {\n-      /* Floating point types. */\n+      /* Floating point types.  */\n \n       if (TYPE_MODE (type) == SFmode)\n \tobstack_1grow (&util_obstack, 'f');\n@@ -6711,7 +6715,7 @@ encode_field_decl (field_decl, curtype, format)\n \n  /* If this field is obviously a bitfield, or is a bitfield that has been\n      clobbered to look like a ordinary integer mode, go ahead and generate\n-     the bitfield typing information. */\n+     the bitfield typing information.  */\n   type = TREE_TYPE (field_decl);\n   if (DECL_BIT_FIELD (field_decl))\n     encode_bitfield (DECL_FIELD_SIZE (field_decl), format);\n@@ -6794,7 +6798,7 @@ start_method_def (method)\n \t\t   build_tree_list (unused_list, NULL_TREE)));\n #endif /* not OBJC_INT_SELECTORS */\n \n-  /* Generate argument declarations if a keyword_decl. */\n+  /* Generate argument declarations if a keyword_decl.  */\n   if (METHOD_SEL_ARGS (method))\n     {\n       tree arglist = METHOD_SEL_ARGS (method);\n@@ -6807,13 +6811,13 @@ start_method_def (method)\n \t    {\n \t      tree last_expr = expr_last (arg_decl);\n \n-\t      /* Unite the abstract decl with its name. */\n+\t      /* Unite the abstract decl with its name.  */\n \t      TREE_OPERAND (last_expr, 0) = KEYWORD_ARG_NAME (arglist);\n \t      push_parm_decl (build_tree_list\n \t\t\t      (build_tree_list (arg_spec, arg_decl),\n \t\t\t       build_tree_list (NULL_TREE, NULL_TREE)));\n \n-\t      /* Unhook: restore the abstract declarator. */\n+\t      /* Unhook: restore the abstract declarator.  */\n \t      TREE_OPERAND (last_expr, 0) = NULL_TREE;\n \t    }\n \n@@ -6830,7 +6834,7 @@ start_method_def (method)\n \n   if (METHOD_ADD_ARGS (method) > (tree)1)\n     {\n-      /* We have a variable length selector - in \"prototype\" format. */\n+      /* We have a variable length selector - in \"prototype\" format.  */\n       tree akey = TREE_PURPOSE (METHOD_ADD_ARGS (method));\n       while (akey)\n \t{\n@@ -6861,15 +6865,15 @@ warn_with_method (message, mtype, method)\n \t   message, mtype, gen_method_decl (method, errbuf));\n }\n \n-/* Return 1 if METHOD is consistent with PROTO. */\n+/* Return 1 if METHOD is consistent with PROTO.  */\n \n static int\n comp_method_with_proto (method, proto)\n      tree method, proto;\n {\n   static tree function_type = 0;\n \n-  /* Create a function_type node once. */\n+  /* Create a function_type node once.  */\n   if (!function_type)\n     {\n       push_obstacks_nochange ();\n@@ -6887,15 +6891,15 @@ comp_method_with_proto (method, proto)\n   return comptypes (TREE_TYPE (METHOD_DEFINITION (method)), function_type);\n }\n \n-/* Return 1 if PROTO1 is consistent with PROTO2. */\n+/* Return 1 if PROTO1 is consistent with PROTO2.  */\n \n static int\n comp_proto_with_proto (proto1, proto2)\n      tree proto1, proto2;\n {\n   static tree function_type1 = 0, function_type2 = 0;\n \n-  /* Create a couple function_type node's once. */\n+  /* Create a couple function_type node's once.  */\n   if (!function_type1)\n     {\n       push_obstacks_nochange ();\n@@ -6909,7 +6913,7 @@ comp_proto_with_proto (proto1, proto2)\n   TYPE_ARG_TYPES (function_type1) = get_arg_type_list (proto1, METHOD_REF, 0);\n   TYPE_ARG_TYPES (function_type2) = get_arg_type_list (proto2, METHOD_REF, 0);\n \n-  /* Install return type. */\n+  /* Install return type.  */\n   TREE_TYPE (function_type1) = groktypename (TREE_TYPE (proto1));\n   TREE_TYPE (function_type2) = groktypename (TREE_TYPE (proto2));\n \n@@ -6930,7 +6934,7 @@ really_start_method (method, parmlist)\n   tree method_decl, method_id;\n   char *buf, *sel_name, *class_name, *cat_name;\n \n-  /* Synth the storage class & assemble the return type. */\n+  /* Synth the storage class & assemble the return type.  */\n   sc_spec = tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC], NULL_TREE);\n   ret_spec = TREE_PURPOSE (TREE_TYPE (method));\n   decl_specs = chainon (sc_spec, ret_spec);\n@@ -6954,7 +6958,7 @@ really_start_method (method, parmlist)\n \n   method_decl = build_nt (CALL_EXPR, method_id, parmlist, NULL_TREE);\n \n-  /* Check the declarator portion of the return type for the method. */\n+  /* Check the declarator portion of the return type for the method.  */\n   if ((ret_decl = TREE_VALUE (TREE_TYPE (method))))\n     {\n       /* Unite the complex decl (specified in the abstract decl) with the\n@@ -6964,21 +6968,21 @@ really_start_method (method, parmlist)\n       TREE_OPERAND (save_expr, 0) = method_decl;\n       method_decl = ret_decl;\n \n-      /* Fool the parser into thinking it is starting a function. */\n+      /* Fool the parser into thinking it is starting a function.  */\n       start_function (decl_specs, method_decl, NULL_TREE, NULL_TREE, 0);\n \n-      /* Unhook: this has the effect of restoring the abstract declarator. */\n+      /* Unhook: this has the effect of restoring the abstract declarator.  */\n       TREE_OPERAND (save_expr, 0) = NULL_TREE;\n     }\n \n   else\n     {\n       TREE_VALUE (TREE_TYPE (method)) = method_decl;\n \n-      /* Fool the parser into thinking it is starting a function. */\n+      /* Fool the parser into thinking it is starting a function.  */\n       start_function (decl_specs, method_decl, NULL_TREE, NULL_TREE, 0);\n \n-      /* Unhook: this has the effect of restoring the abstract declarator. */\n+      /* Unhook: this has the effect of restoring the abstract declarator.  */\n       TREE_VALUE (TREE_TYPE (method)) = NULL_TREE;\n     }\n \n@@ -7044,7 +7048,7 @@ add_objc_decls ()\n \n       finish_decl (UOBJC_SUPER_decl, NULL_TREE, NULL_TREE);\n \n-      /* This prevents `unused variable' warnings when compiling with -Wall. */\n+      /* This prevents `unused variable' warnings when compiling with -Wall.  */\n       TREE_USED (UOBJC_SUPER_decl) = 1;\n       DECL_ARTIFICIAL (UOBJC_SUPER_decl) = 1;\n     }\n@@ -7063,12 +7067,12 @@ get_super_receiver ()\n     {\n       tree super_expr, super_expr_list;\n \n-      /* Set receiver to self. */\n+      /* Set receiver to self.  */\n       super_expr = build_component_ref (UOBJC_SUPER_decl, self_id);\n       super_expr = build_modify_expr (super_expr, NOP_EXPR, self_decl);\n       super_expr_list = build_tree_list (NULL_TREE, super_expr);\n \n-      /* Set class to begin searching. */\n+      /* Set class to begin searching.  */\n       super_expr = build_component_ref (UOBJC_SUPER_decl,\n \t\t\t\t\tget_identifier (\"class\"));\n \n@@ -7085,7 +7089,7 @@ get_super_receiver ()\n \t}\n \n       else\n-\t/* We have a category. */\n+\t/* We have a category.  */\n \t{\n \t  tree super_name = CLASS_SUPER_NAME (implementation_template);\n \t  tree super_class;\n@@ -7148,12 +7152,12 @@ encode_method_def (func_decl)\n   char buffer[40];\n   tree result;\n \n-  /* Return type. */\n+  /* Return type.  */\n   encode_type (TREE_TYPE (TREE_TYPE (func_decl)),\n \t       obstack_object_size (&util_obstack),\n \t       OBJC_ENCODE_INLINE_DEFS);\n \n-  /* Stack size. */\n+  /* Stack size.  */\n   for (parms = DECL_ARGUMENTS (func_decl); parms;\n        parms = TREE_CHAIN (parms))\n     {\n@@ -7170,19 +7174,19 @@ encode_method_def (func_decl)\n   sprintf (buffer, \"%d\", stack_size);\n   obstack_grow (&util_obstack, buffer, strlen (buffer));\n \n-  /* Argument types. */\n+  /* Argument types.  */\n   for (parms = DECL_ARGUMENTS (func_decl); parms;\n        parms = TREE_CHAIN (parms))\n     {\n-      /* Type. */\n+      /* Type.  */\n       encode_type (TREE_TYPE (parms),\n \t\t   obstack_object_size (&util_obstack),\n \t\t   OBJC_ENCODE_INLINE_DEFS);\n \n-      /* Compute offset. */\n+      /* Compute offset.  */\n       sprintf (buffer, \"%d\", forwarding_offset (parms));\n \n-      /* Indicate register. */\n+      /* Indicate register.  */\n       if (offset_is_register)\n \tobstack_1grow (&util_obstack, '+');\n \n@@ -7381,7 +7385,7 @@ gen_declarator (decl, buf, name)\n \t  strcpy (buf, name);\n \t  str = buf;\n \n-\t  /* This clause is done iteratively rather than recursively. */\n+\t  /* This clause is done iteratively rather than recursively.  */\n \t  do\n \t    {\n \t      op = (is_complex_decl (TREE_TYPE (decl))\n@@ -7410,7 +7414,7 @@ gen_declarator (decl, buf, name)\n \t  break;\n \n \tcase IDENTIFIER_NODE:\n-\t  /* Will only happen if we are processing a \"raw\" expr-decl. */\n+\t  /* Will only happen if we are processing a \"raw\" expr-decl.  */\n \t  strcpy (buf, IDENTIFIER_POINTER (decl));\n \t  return buf;\n \t}\n@@ -7419,7 +7423,7 @@ gen_declarator (decl, buf, name)\n     }\n \n   else\n-    /* We have an abstract declarator or a _DECL node. */\n+    /* We have an abstract declarator or a _DECL node.  */\n     {\n       strcpy (buf, name);\n       return buf;\n@@ -7531,15 +7535,15 @@ gen_declspecs (declspecs, buf, raw)\n     }\n   else\n     {\n-      /* Type qualifiers. */\n+      /* Type qualifiers.  */\n       if (TREE_READONLY (declspecs))\n \tstrcat (buf, \"const \");\n       if (TYPE_VOLATILE (declspecs))\n \tstrcat (buf, \"volatile \");\n \n       switch (TREE_CODE (declspecs))\n \t{\n-\t  /* Type specifiers. */\n+\t  /* Type specifiers.  */\n \n \tcase INTEGER_TYPE:\n \t  declspecs = TYPE_MAIN_VARIANT (declspecs);\n@@ -7558,7 +7562,7 @@ gen_declspecs (declspecs, buf, raw)\n \t\t   || declspecs == char_type_node)\n \t    strcat (buf, \"char \");\n \n-\t  /* Unsigned integer types. */\n+\t  /* Unsigned integer types.  */\n \n \t  else if (declspecs == short_unsigned_type_node)\n \t    strcat (buf, \"unsigned short \");\n@@ -7684,9 +7688,9 @@ gen_declaration (atype_or_adecl, buf)\n   if (TREE_CODE (atype_or_adecl) == TREE_LIST)\n     {\n       tree declspecs;\t/* \"identifier_node\", \"record_type\" */\n-      tree declarator;\t/* \"array_ref\", \"indirect_ref\", \"call_expr\"... */\n+      tree declarator;\t/* \"array_ref\", \"indirect_ref\", \"call_expr\"...  */\n \n-      /* We have a \"raw\", abstract declarator (typename). */\n+      /* We have a \"raw\", abstract declarator (typename).  */\n       declarator = TREE_VALUE (atype_or_adecl);\n       declspecs  = TREE_PURPOSE (atype_or_adecl);\n \n@@ -7701,22 +7705,22 @@ gen_declaration (atype_or_adecl, buf)\n   else\n     {\n       tree atype;\n-      tree declspecs;\t/* \"integer_type\", \"real_type\", \"record_type\"... */\n-      tree declarator;\t/* \"array_type\", \"function_type\", \"pointer_type\". */\n+      tree declspecs;\t/* \"integer_type\", \"real_type\", \"record_type\"...  */\n+      tree declarator;\t/* \"array_type\", \"function_type\", \"pointer_type\".  */\n \n       if (TREE_CODE (atype_or_adecl) == FIELD_DECL\n \t  || TREE_CODE (atype_or_adecl) == PARM_DECL\n \t  || TREE_CODE (atype_or_adecl) == FUNCTION_DECL)\n \tatype = TREE_TYPE (atype_or_adecl);\n       else\n-\t/* Assume we have a *_type node. */\n+\t/* Assume we have a *_type node.  */\n \tatype = atype_or_adecl;\n \n       if (is_complex_decl (atype))\n \t{\n \t  tree chain;\n \n-\t  /* Get the declaration specifier; it is at the end of the list. */\n+\t  /* Get the declaration specifier; it is at the end of the list.  */\n \t  declarator = chain = atype;\n \t  do\n \t    chain = TREE_TYPE (chain); /* not TREE_CHAIN (chain); */\n@@ -7781,7 +7785,7 @@ gen_method_decl (method, buf)\n   chain = METHOD_SEL_ARGS (method);\n   if (chain)\n     {\n-      /* We have a chain of keyword_decls. */\n+      /* We have a chain of keyword_decls.  */\n       do\n         {\n \t  if (KEYWORD_KEY_NAME (chain))\n@@ -7808,7 +7812,7 @@ gen_method_decl (method, buf)\n \t  /* We have a tree list node as generate by get_parm_info.  */\n \t  chain  = TREE_PURPOSE (METHOD_ADD_ARGS (method));\n \n-          /* Know we have a chain of parm_decls. */\n+          /* Know we have a chain of parm_decls.  */\n           while (chain)\n             {\n \t      strcat (buf, \", \");\n@@ -7819,7 +7823,7 @@ gen_method_decl (method, buf)\n     }\n \n   else\n-    /* We have a unary selector. */\n+    /* We have a unary selector.  */\n     strcat (buf, IDENTIFIER_POINTER (METHOD_SEL_NAME (method)));\n \n   return buf;\n@@ -7991,7 +7995,7 @@ finish_objc ()\n   for (impent = imp_list; impent; impent = impent->next)\n     handle_impent (impent);\n \n-  /* Dump the string table last. */\n+  /* Dump the string table last.  */\n \n   generate_strings ();\n \n@@ -8007,7 +8011,7 @@ finish_objc ()\n       hash hsh;\n \n       /* Run through the selector hash tables and print a warning for any\n-         selector which has multiple methods. */\n+         selector which has multiple methods.  */\n \n       for (slot = 0; slot < SIZEHASHTABLE; slot++)\n \tfor (hsh = cls_method_hash_list[slot]; hsh; hsh = hsh->next)\n@@ -8163,7 +8167,7 @@ handle_impent (impent)\n \n       /* Do the same for categories.  Even though no references to these\n \t symbols are generated automatically by the compiler, it gives\n-\t you a handle to pull them into an archive by hand. */\n+\t you a handle to pull them into an archive by hand.  */\n       if (flag_next_runtime)\n \t{\n \t  /* Grossly unportable.  */\n@@ -8203,7 +8207,7 @@ objc_debug (fp)\n       {\n \tif (TREE_CODE (loop) == FUNCTION_DECL && DECL_INITIAL (loop))\n \t  {\n-\t    /* We have a function definition: generate prototype. */\n+\t    /* We have a function definition: generate prototype.  */\n             bzero (errbuf, BUFSIZE);\n \t    gen_declaration (loop, errbuf);\n \t    fprintf (fp, \"%s;\\n\", errbuf);\n@@ -8212,7 +8216,7 @@ objc_debug (fp)\n       }\n   }\n   {\n-    /* Dump global chains. */\n+    /* Dump global chains.  */\n     tree loop;\n     int i, index = 0, offset = 0;\n     hash hashlist;"}, {"sha": "a30819753a53a0c22a39bbb49adf7534d705450f", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -88,7 +88,7 @@ optab strlen_optab;\n /* Tables of patterns for extending one integer mode to another.  */\n enum insn_code extendtab[MAX_MACHINE_MODE][MAX_MACHINE_MODE][2];\n \n-/* Tables of patterns for converting between fixed and floating point. */\n+/* Tables of patterns for converting between fixed and floating point.  */\n enum insn_code fixtab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n enum insn_code fixtrunctab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n enum insn_code floattab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n@@ -438,7 +438,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \ttemp = gen_reg_rtx (mode);\n \n       /* If it is a commutative operator and the modes would match\n-\t if we would swap the operands, we can save the conversions. */\n+\t if we would swap the operands, we can save the conversions.  */\n       if (commutative_op)\n \t{\n \t  if (GET_MODE (op0) != mode0 && GET_MODE (op1) != mode1\n@@ -3517,7 +3517,7 @@ expand_float (to, from, unsignedp)\n \t  /* There is no such mode.  Pretend the target is wide enough.  */\n \t  fmode = GET_MODE (to);\n \n-\t  /* Avoid double-rounding when TO is narrower than FROM. */\n+\t  /* Avoid double-rounding when TO is narrower than FROM.  */\n \t  if ((significand_size (fmode) + 1)\n \t      < GET_MODE_BITSIZE (GET_MODE (from)))\n \t    {\n@@ -4338,7 +4338,7 @@ init_optabs ()\n \f\n #ifdef BROKEN_LDEXP\n \n-/* SCO 3.2 apparently has a broken ldexp. */\n+/* SCO 3.2 apparently has a broken ldexp.  */\n \n double\n ldexp(x,n)"}, {"sha": "2972137dccbaecb458ed82b854677c964934996f", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -231,7 +231,7 @@ print_node (file, prefix, node, indent)\n       return;\n     }\n \n-  /* It is unsafe to look at any other filds of an ERROR_MARK node. */\n+  /* It is unsafe to look at any other filds of an ERROR_MARK node.  */\n   if (TREE_CODE (node) == ERROR_MARK)\n     {\n       print_node_brief (file, prefix, node, indent);"}, {"sha": "7cc0b0a599561b1148a7aff93f61ffae2bb7cf3c", "filename": "gcc/protoize.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -20,7 +20,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Any reasonable C++ compiler should have all of the same features\n    as __STDC__ plus more, so make sure that __STDC__ is defined if\n-   __cplusplus is defined. */\n+   __cplusplus is defined.  */\n \n #if defined(__cplusplus) && !defined(__STDC__)\n #define __STDC__ 1\n@@ -264,7 +264,7 @@ static char * syscalls_absolute_filename;\n \n #endif /* !defined (UNPROTOIZE) */\n \n-/* Type of the structure that holds information about macro unexpansions. */\n+/* Type of the structure that holds information about macro unexpansions.  */\n \n struct unexpansion_struct {\n   const char *expanded;\n@@ -511,7 +511,7 @@ static const char *indent_string = \"     \";\t/* Indentation for newly\n static int local_flag = 0;\t\t/* Insert new local decls (when?).  */\n static int global_flag = 0;\t\t/* set by -g option */\n static int cplusplus_flag = 0;\t\t/* Rename converted files to *.C.  */\n-static const char* nondefault_syscalls_dir = 0; /* Dir to look for\n+static const char *nondefault_syscalls_dir = 0; /* Dir to look for\n \t\t\t\t\t\t   SYSCALLS.c.X in.  */\n #endif /* !defined (UNPROTOIZE) */\n \n@@ -546,7 +546,7 @@ static const char *convert_filename;\n \n /* Pointer to relative root string (taken from aux_info file) which indicates\n    where directory the user was in when he did the compilation step that\n-   produced the containing aux_info file. */\n+   produced the containing aux_info file.  */\n \n static const char *invocation_filename;\n \n@@ -1033,14 +1033,14 @@ needs_to_be_converted (file_p)\n \n #ifndef UNPROTOIZE\n \n-      /* ... and if we a protoizing and this function is in old style ... */\n+      /* ... and if we a protoizing and this function is in old style ...  */\n       !ddp->prototyped\n-      /* ... and if this a definition or is a decl with an associated def ... */\n+      /* ... and if this a definition or is a decl with an associated def ...  */\n       && (ddp->is_func_def || (!ddp->is_func_def && ddp->definition))\n \n #else /* defined (UNPROTOIZE) */\n \n-      /* ... and if we are unprotoizing and this function is in new style ... */\n+      /* ... and if we are unprotoizing and this function is in new style ...  */\n       ddp->prototyped\n \n #endif /* defined (UNPROTOIZE) */\n@@ -1226,7 +1226,7 @@ unexpand_if_needed (aux_info_line)\n {\n   static char *line_buf = 0;\n   static int line_buf_size = 0;\n-  const unexpansion* unexp_p;\n+  const unexpansion *unexp_p;\n   int got_unexpanded = 0;\n   const char *s;\n   char *copy_p = line_buf;\n@@ -1700,7 +1700,7 @@ save_def_or_dec (l, is_syscalls)\n   /* Check that this record describes a new-style, old-style, or implicit\n      definition or declaration.  */\n \n-  p++;\t/* Skip over the `:'. */\n+  p++;\t/* Skip over the `:'.  */\n   check_aux_info ((*p == 'N') || (*p == 'O') || (*p == 'I'));\n \n   /* Is this a new style (ANSI prototyped) definition or declaration? */\n@@ -1906,7 +1906,7 @@ save_def_or_dec (l, is_syscalls)\n       check_aux_info (*++p == '(');\n \n       {\n-        const char *kr_names_start = ++p;   /* Point just inside '('. */\n+        const char *kr_names_start = ++p;   /* Point just inside '('.  */\n \n         while (*p++ != ')')\n           continue;\n@@ -2597,7 +2597,7 @@ find_extern_def (head, user)\n     if (dd_p->is_func_def && !dd_p->is_static)\n       {\n         if (!extern_def_p)\t/* Previous definition? */\n-          extern_def_p = dd_p;\t/* Remember the first definition found. */\n+          extern_def_p = dd_p;\t/* Remember the first definition found.  */\n         else\n           {\n             /* Ignore definition just found if it came from SYSCALLS.c.X.  */\n@@ -2717,7 +2717,7 @@ find_extern_def (head, user)\n \f\n /* Find the (only?) static definition for a particular function name in a\n    given file.  Here we get the function-name and the file info indirectly\n-   from the def_dec_info record pointer which is passed in. */\n+   from the def_dec_info record pointer which is passed in.  */\n \n static const def_dec_info *\n find_static_definition (user)\n@@ -3413,11 +3413,11 @@ edit_formals_lists (end_formals, f_list_count, def_dec_p)\n   return 0;\n }\n \n-/* Given a pointer to a byte in the clean text buffer which points to the\n-   beginning of a line that contains a \"follower\" token for a function\n-   definition header, do whatever is necessary to find the right closing\n-   paren for the rightmost formals list of the function definition header.\n-*/\n+/* Given a pointer to a byte in the clean text buffer which points to\n+   the beginning of a line that contains a \"follower\" token for a\n+   function definition header, do whatever is necessary to find the\n+   right closing paren for the rightmost formals list of the function\n+   definition header.  */\n \n static const char *\n find_rightmost_formals_list (clean_text_p)\n@@ -3685,7 +3685,7 @@ add_global_decls (file_p, clean_text_p)\n \n   /* Now scan forward for the first non-whitespace character.  In theory,\n      this should be the first character of the following function definition\n-     header.  We will put in the added declarations just prior to that. */\n+     header.  We will put in the added declarations just prior to that.  */\n \n   scan_p++;\n   while (isspace (*scan_p))\n@@ -4592,7 +4592,7 @@ main (argc, argv)\n #endif\n \t\t\t   longopts, &longind)) != EOF)\n     {\n-      if (c == 0)\t\t/* Long option. */\n+      if (c == 0)\t\t/* Long option.  */\n \tc = longopts[longind].val;\n       switch (c)\n \t{"}, {"sha": "aab1e40882b6e60011853207688e11dfe4767b6a", "filename": "gcc/real.c", "status": "modified", "additions": 84, "deletions": 82, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -120,7 +120,7 @@ netlib.att.com: netlib/cephes.   */\n #if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n #define IEEE\n #else /* it's not IEEE either */\n-/* UNKnown arithmetic.  We don't support this and can't go on. */\n+/* UNKnown arithmetic.  We don't support this and can't go on.  */\n unknown arithmetic type\n #define UNK 1\n #endif /* not IEEE */\n@@ -163,15 +163,15 @@ unknown arithmetic type\n #define NANS\n #endif\n \n-/* Support of NaNs requires support of infinity. */\n+/* Support of NaNs requires support of infinity.  */\n #ifdef NANS\n #ifndef INFINITY\n #define INFINITY\n #endif\n #endif\n \f\n /* Find a host integer type that is at least 16 bits wide,\n-   and another type at least twice whatever that size is. */\n+   and another type at least twice whatever that size is.  */\n \n #if HOST_BITS_PER_CHAR >= 16\n #define EMUSHORT char\n@@ -193,7 +193,7 @@ unknown arithmetic type\n #define EMUSHORT_SIZE HOST_BITS_PER_LONG\n #define EMULONG_SIZE (2 * HOST_BITS_PER_LONG)\n #else\n-/*  You will have to modify this program to have a smaller unit size. */\n+/*  You will have to modify this program to have a smaller unit size.  */\n #define EMU_NON_COMPILE\n #endif\n #endif\n@@ -212,20 +212,20 @@ unknown arithmetic type\n #if HOST_BITS_PER_LONG_LONG >= EMULONG_SIZE\n #define EMULONG long long int\n #else\n-/*  You will have to modify this program to have a smaller unit size. */\n+/*  You will have to modify this program to have a smaller unit size.  */\n #define EMU_NON_COMPILE\n #endif\n #endif\n #endif\n #endif\n \n \n-/* The host interface doesn't work if no 16-bit size exists. */\n+/* The host interface doesn't work if no 16-bit size exists.  */\n #if EMUSHORT_SIZE != 16\n #define EMU_NON_COMPILE\n #endif\n \n-/* OK to continue compilation. */\n+/* OK to continue compilation.  */\n #ifndef EMU_NON_COMPILE\n \n /* Construct macros to translate between REAL_VALUE_TYPE and e type.\n@@ -253,12 +253,12 @@ unknown arithmetic type\n #define MINDECEXP -4956\n #ifdef REAL_ARITHMETIC\n /* Emulator uses target format internally\n-   but host stores it in host endian-ness. */\n+   but host stores it in host endian-ness.  */\n \n #define GET_REAL(r,e)\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n      if (HOST_FLOAT_WORDS_BIG_ENDIAN == REAL_WORDS_BIG_ENDIAN)\t\\\n-       e53toe ((unsigned EMUSHORT*) (r), (e));\t\t\t\\\n+       e53toe ((unsigned EMUSHORT *) (r), (e));\t\t\t\\\n      else\t\t\t\t\t\t\t\\\n        {\t\t\t\t\t\t\t\\\n \t unsigned EMUSHORT w[4];\t\t\t\t\\\n@@ -440,15 +440,15 @@ endian (e, x, mode)\n \t{\n \n \tcase TFmode:\n-\t  /* Swap halfwords in the fourth long. */\n+\t  /* Swap halfwords in the fourth long.  */\n \t  th = (unsigned long) e[6] & 0xffff;\n \t  t = (unsigned long) e[7] & 0xffff;\n \t  t |= th << 16;\n \t  x[3] = (long) t;\n \n \tcase XFmode:\n \n-\t  /* Swap halfwords in the third long. */\n+\t  /* Swap halfwords in the third long.  */\n \t  th = (unsigned long) e[4] & 0xffff;\n \t  t = (unsigned long) e[5] & 0xffff;\n \t  t |= th << 16;\n@@ -480,14 +480,14 @@ endian (e, x, mode)\n     }\n   else\n     {\n-      /* Pack the output array without swapping. */\n+      /* Pack the output array without swapping.  */\n \n       switch (mode)\n \t{\n \n \tcase TFmode:\n \n-\t  /* Pack the fourth long. */\n+\t  /* Pack the fourth long.  */\n \t  th = (unsigned long) e[7] & 0xffff;\n \t  t = (unsigned long) e[6] & 0xffff;\n \t  t |= th << 16;\n@@ -545,7 +545,7 @@ earith (value, icode, r1, r2)\n   GET_REAL (r1, d1);\n   GET_REAL (r2, d2);\n #ifdef NANS\n-/*  Return NaN input back to the caller. */\n+/*  Return NaN input back to the caller.  */\n   if (eisnan (d1))\n     {\n       PUT_REAL (d1, value);\n@@ -945,7 +945,7 @@ ereal_ldexp (x, n)\n \n #ifdef REAL_ARITHMETIC\n \n-/* Check for infinity in a REAL_VALUE_TYPE. */\n+/* Check for infinity in a REAL_VALUE_TYPE.  */\n \n int\n target_isinf (x)\n@@ -961,7 +961,7 @@ target_isinf (x)\n #endif\n }\n \n-/* Check whether a REAL_VALUE_TYPE item is a NaN. */\n+/* Check whether a REAL_VALUE_TYPE item is a NaN.  */\n \n int\n target_isnan (x)\n@@ -979,7 +979,7 @@ target_isnan (x)\n \n \n /* Check for a negative REAL_VALUE_TYPE number.\n-   This just checks the sign bit, so that -0 counts as negative. */\n+   This just checks the sign bit, so that -0 counts as negative.  */\n \n int\n target_negative (x)\n@@ -1330,7 +1330,7 @@ ereal_isneg (x)\n   ensure that these values are correct for your computer.\n  \n   For ANSI C compatibility, define ANSIC equal to 1.  Currently\n-  this affects only the atan2 function and others that use it. */\n+  this affects only the atan2 function and others that use it.  */\n \n /* Constant definitions for math error conditions.  */\n \n@@ -1507,7 +1507,7 @@ eisnan (x)\n   /* NaN has maximum exponent */\n   if ((x[NE - 1] & 0x7fff) != 0x7fff)\n     return (0);\n-  /* ... and non-zero significand field. */\n+  /* ... and non-zero significand field.  */\n   for (i = 0; i < NE - 1; i++)\n     {\n       if (*x++ != 0)\n@@ -1519,7 +1519,7 @@ eisnan (x)\n }\n \n /*  Fill e-type number X with infinity pattern (IEEE)\n-    or largest possible number (non-IEEE). */\n+    or largest possible number (non-IEEE).  */\n \n static void \n einfin (x)\n@@ -1675,7 +1675,7 @@ ecleaz (xi)\n     *xi++ = 0;\n }\n \n-/* Clear out exploded e-type XI, but don't touch the sign. */\n+/* Clear out exploded e-type XI, but don't touch the sign.  */\n \n static void \n ecleazs (xi)\n@@ -1716,7 +1716,7 @@ einan (x)\n   x[M + 1] = 0xc000;\n }\n \n-/* Return nonzero if exploded e-type X is a NaN. */\n+/* Return nonzero if exploded e-type X is a NaN.  */\n \n static int \n eiisnan (x)\n@@ -1757,7 +1757,7 @@ eiinfin (x)\n   x[E] = 0x7fff;\n }\n \n-/* Return nonzero if exploded e-type X is infinite. */\n+/* Return nonzero if exploded e-type X is infinite.  */\n \n static int \n eiisinf (x)\n@@ -2090,6 +2090,7 @@ edivm (den, num)\n \n \n /* Multiply significands */\n+\n int \n emulm (a, b)\n      unsigned EMUSHORT a[], b[];\n@@ -2140,7 +2141,7 @@ emulm (a, b)\n /* Radix 65536 versions of multiply and divide.  */\n \n /* Multiply significand of e-type number B\n-   by 16-bit quantity A, return e-type result to C. */\n+   by 16-bit quantity A, return e-type result to C.  */\n \n static void\n m16m (a, b, c)\n@@ -2208,17 +2209,17 @@ edivm (den, num)\n   tdenm = den[M+1];\n   for (i=M; i<NI; i++)\n     {\n-      /* Find trial quotient digit (the radix is 65536). */\n+      /* Find trial quotient digit (the radix is 65536).  */\n       tnum = (((unsigned EMULONG) num[M]) << 16) + num[M+1];\n \n-      /* Do not execute the divide instruction if it will overflow. */\n+      /* Do not execute the divide instruction if it will overflow.  */\n       if ((tdenm * 0xffffL) < tnum)\n \ttquot = 0xffff;\n       else\n \ttquot = tnum / tdenm;\n-      /* Multiply denominator by trial quotient digit. */\n+      /* Multiply denominator by trial quotient digit.  */\n       m16m ((unsigned int)tquot, den, tprod);\n-      /* The quotient digit may have been overestimated. */\n+      /* The quotient digit may have been overestimated.  */\n       if (ecmpm (tprod, num) > 0)\n \t{\n \t  tquot -= 1;\n@@ -2341,7 +2342,7 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n   /* Normalize */\n   j = enormlz (s);\n \n-  /* a blank significand could mean either zero or infinity. */\n+  /* a blank significand could mean either zero or infinity.  */\n #ifndef INFINITY\n   if (j > NBITS)\n     {\n@@ -2375,10 +2376,10 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n \t  return;\n \t}\n     }\n-  /* Round off, unless told not to by rcntrl. */\n+  /* Round off, unless told not to by rcntrl.  */\n   if (rcntrl == 0)\n     goto mdfin;\n-  /* Set up rounding parameters if the control register changed. */\n+  /* Set up rounding parameters if the control register changed.  */\n   if (rndprc != rlast)\n     {\n       ecleaz (rbit);\n@@ -2475,7 +2476,7 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n       eaddm (rbit, s);\n     }\n  mddone:\n-/* Undo the temporary shift for denormal values. */\n+/* Undo the temporary shift for denormal values.  */\n   if ((exp <= 0) && (rndprc != NBITS)\n       && ((rndprc != 64) || ((rndprc == 64) && ! REAL_WORDS_BIG_ENDIAN)))\n     {\n@@ -2544,7 +2545,7 @@ esub (a, b, c)\n       return;\n     }\n /* Infinity minus infinity is a NaN.\n-   Test for subtracting infinities of the same sign. */\n+   Test for subtracting infinities of the same sign.  */\n   if (eisinf (a) && eisinf (b)\n       && ((eisneg (a) ^ eisneg (b)) == 0))\n     {\n@@ -2557,15 +2558,15 @@ esub (a, b, c)\n   eadd1 (a, b, c);\n }\n \n-/* Add.  C = A + B, all e type. */\n+/* Add.  C = A + B, all e type.  */\n \n static void \n eadd (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n \n #ifdef NANS\n-/* NaN plus anything is a NaN. */\n+/* NaN plus anything is a NaN.  */\n   if (eisnan (a))\n     {\n       emov (a, c);\n@@ -2577,7 +2578,7 @@ eadd (a, b, c)\n       return;\n     }\n /* Infinity minus infinity is a NaN.\n-   Test for adding infinities of opposite signs. */\n+   Test for adding infinities of opposite signs.  */\n   if (eisinf (a) && eisinf (b)\n       && ((eisneg (a) ^ eisneg (b)) != 0))\n     {\n@@ -2716,7 +2717,7 @@ ediv (a, b, c)\n   sign = eisneg(a) ^ eisneg(b);\n \n #ifdef NANS\n-/* Return any NaN input. */\n+/* Return any NaN input.  */\n   if (eisnan (a))\n     {\n     emov (a, c);\n@@ -2727,7 +2728,7 @@ ediv (a, b, c)\n     emov (b, c);\n     return;\n     }\n-/* Zero over zero, or infinity over infinity, is a NaN. */\n+/* Zero over zero, or infinity over infinity, is a NaN.  */\n   if (((ecmp (a, ezero) == 0) && (ecmp (b, ezero) == 0))\n       || (eisinf (a) && eisinf (b)))\n     {\n@@ -2736,14 +2737,14 @@ ediv (a, b, c)\n     return;\n     }\n #endif\n-/* Infinity over anything else is infinity. */\n+/* Infinity over anything else is infinity.  */\n #ifdef INFINITY\n   if (eisinf (b))\n     {\n       einfin (c);\n       goto divsign;\n     }\n-/* Anything else over infinity is zero. */\n+/* Anything else over infinity is zero.  */\n   if (eisinf (a))\n     {\n       eclear (c);\n@@ -2755,7 +2756,7 @@ ediv (a, b, c)\n   lta = ai[E];\n   ltb = bi[E];\n   if (bi[E] == 0)\n-    {\t\t\t\t/* See if numerator is zero. */\n+    {\t\t\t\t/* See if numerator is zero.  */\n       for (i = 1; i < NI - 1; i++)\n \t{\n \t  if (bi[i] != 0)\n@@ -2820,7 +2821,7 @@ emul (a, b, c)\n   sign = eisneg(a) ^ eisneg(b);\n \n #ifdef NANS\n-/* NaN times anything is the same NaN. */\n+/* NaN times anything is the same NaN.  */\n   if (eisnan (a))\n     {\n     emov (a, c);\n@@ -2831,7 +2832,7 @@ emul (a, b, c)\n     emov (b, c);\n     return;\n     }\n-/* Zero times infinity is a NaN. */\n+/* Zero times infinity is a NaN.  */\n   if ((eisinf (a) && (ecmp (b, ezero) == 0))\n       || (eisinf (b) && (ecmp (a, ezero) == 0)))\n     {\n@@ -2840,7 +2841,7 @@ emul (a, b, c)\n     return;\n     }\n #endif\n-/* Infinity times anything else is infinity. */\n+/* Infinity times anything else is infinity.  */\n #ifdef INFINITY\n   if (eisinf (a) || eisinf (b))\n     {\n@@ -2965,7 +2966,7 @@ e53toe (pe, y)\n #endif  /* INFINITY */\n   r >>= 4;\n   /* If zero exponent, then the significand is denormalized.\n-     So take back the understood high significand bit. */\n+     So take back the understood high significand bit.  */\n \n   if (r == 0)\n     {\n@@ -3017,7 +3018,7 @@ e64toe (pe, y)\n   p = yy;\n   for (i = 0; i < NE - 5; i++)\n     *p++ = 0;\n-/* This precision is not ordinarily supported on DEC or IBM. */\n+/* This precision is not ordinarily supported on DEC or IBM.  */\n #ifdef DEC\n   for (i = 0; i < 5; i++)\n     *p++ = *e++;\n@@ -3197,7 +3198,7 @@ e113toe (pe, y)\n \t*p++ = *e++;\n     }\n #endif\n-/* If denormal, remove the implied bit; else shift down 1. */\n+/* If denormal, remove the implied bit; else shift down 1.  */\n   if (r == 0)\n     {\n       yy[M] = 0;\n@@ -3272,7 +3273,7 @@ e24toe (pe, y)\n #endif  /* INFINITY */\n   r >>= 7;\n   /* If zero exponent, then the significand is denormalized.\n-     So take back the understood high significand bit. */\n+     So take back the understood high significand bit.  */\n   if (r == 0)\n     {\n       denorm = 1;\n@@ -3360,7 +3361,7 @@ toe113 (a, b)\n   else\n     q = b + 7;\t\t\t/* point to output exponent */\n \n-  /* If not denormal, delete the implied bit. */\n+  /* If not denormal, delete the implied bit.  */\n   if (a[E] != 0)\n     {\n       eshup1 (a);\n@@ -3649,7 +3650,8 @@ toe53 (x, y)\n \n   i = *p++;\n   if (i >= (unsigned int) 2047)\n-    {\t\t\t\t/* Saturate at largest number less than infinity. */\n+    {\n+      /* Saturate at largest number less than infinity.  */\n #ifdef INFINITY\n       *y |= 0x7ff0;\n       if (! REAL_WORDS_BIG_ENDIAN)\n@@ -3800,7 +3802,7 @@ toe24 (x, y)\n     *y = 0x8000;\t\t/* output sign bit */\n \n   i = *p++;\n-/* Handle overflow cases. */\n+/* Handle overflow cases.  */\n   if (i >= 255)\n     {\n #ifdef INFINITY\n@@ -4160,7 +4162,7 @@ euifrac (x, i, frac)\n       *i = (HOST_WIDE_INT) xi[M] & 0xffff;\n     }\n \n-  if (xi[0])  /* A negative value yields unsigned integer 0. */\n+  if (xi[0])  /* A negative value yields unsigned integer 0.  */\n     *i = 0L;\n \n   xi[0] = 0;\n@@ -4528,7 +4530,7 @@ etoasc (x, string, ndigs)\n     }\n  tnzro:\n \n-  /* Test for infinity. */\n+  /* Test for infinity.  */\n   if (y[NE - 1] == 0x7fff)\n     {\n       if (sign)\n@@ -4558,7 +4560,7 @@ etoasc (x, string, ndigs)\n \n   if (i < 0)\n     {\t\t\t\t/* Number is greater than 1 */\n-      /* Convert significand to an integer and strip trailing decimal zeros. */\n+      /* Convert significand to an integer and strip trailing decimal zeros.  */\n       emov (y, u);\n       u[NE - 1] = EXONE + NBITS - 1;\n \n@@ -4588,7 +4590,7 @@ etoasc (x, string, ndigs)\n       emov (eone, t);\n       m = MAXP;\n       p = &etens[0][0];\n-      /* An unordered compare result shouldn't happen here. */\n+      /* An unordered compare result shouldn't happen here.  */\n       while (ecmp (ten, u) <= 0)\n \t{\n \t  if (ecmp (p, u) <= 0)\n@@ -4605,7 +4607,7 @@ etoasc (x, string, ndigs)\n     }\n   else\n     {\t\t\t\t/* Number is less than 1.0 */\n-      /* Pad significand with trailing decimal zeros. */\n+      /* Pad significand with trailing decimal zeros.  */\n       if (y[NE - 1] == 0)\n \t{\n \t  while ((y[NE - 2] & 0x8000) == 0)\n@@ -4663,7 +4665,7 @@ etoasc (x, string, ndigs)\n       ediv (t, eone, t);\n     }\n  isone:\n-  /* Find the first (leading) digit. */\n+  /* Find the first (leading) digit.  */\n   emovi (t, w);\n   emovz (w, t);\n   emovi (y, w);\n@@ -4686,7 +4688,7 @@ etoasc (x, string, ndigs)\n     *s++ = '-';\n   else\n     *s++ = ' ';\n-  /* Examine number of digits requested by caller. */\n+  /* Examine number of digits requested by caller.  */\n   if (ndigs < 0)\n     ndigs = 0;\n   if (ndigs > NDEC)\n@@ -4707,7 +4709,7 @@ etoasc (x, string, ndigs)\n       *s++ = (char)digit + '0';\n       *s++ = '.';\n     }\n-  /* Generate digits after the decimal point. */\n+  /* Generate digits after the decimal point.  */\n   for (k = 0; k <= ndigs; k++)\n     {\n       /* multiply current number by 10, without normalizing */\n@@ -4725,7 +4727,7 @@ etoasc (x, string, ndigs)\n   /* round off the ASCII string */\n   if (digit > 4)\n     {\n-      /* Test for critical rounding case in ASCII output. */\n+      /* Test for critical rounding case in ASCII output.  */\n       if (digit == 5)\n \t{\n \t  emovo (y, t);\n@@ -4846,7 +4848,7 @@ asctoe (s, y)\n }\n \n /* Convert ASCII string SS to e type Y, with a specified rounding precision\n-   of OPREC bits. */\n+   of OPREC bits.  */\n \n static void \n asctoeg (ss, y, oprec)\n@@ -4861,7 +4863,7 @@ asctoeg (ss, y, oprec)\n   unsigned EMUSHORT nsign, *p;\n   char *sp, *s, *lstr;\n \n-  /* Copy the input string. */\n+  /* Copy the input string.  */\n   lstr = (char *) alloca (strlen (ss) + 1);\n   s = ss;\n   while (*s == ' ')\t\t/* skip leading spaces */\n@@ -4890,7 +4892,7 @@ asctoeg (ss, y, oprec)\n       /* Ignore leading zeros */\n       if ((prec == 0) && (decflg == 0) && (k == 0))\n \tgoto donchr;\n-      /* Identify and strip trailing zeros after the decimal point. */\n+      /* Identify and strip trailing zeros after the decimal point.  */\n       if ((trail == 0) && (decflg != 0))\n \t{\n \t  sp = s;\n@@ -5038,7 +5040,7 @@ asctoeg (ss, y, oprec)\n \n  daldone:\n   nexp = exp - nexp;\n-  /* Pad trailing zeros to minimize power of 10, per IEEE spec. */\n+  /* Pad trailing zeros to minimize power of 10, per IEEE spec.  */\n   while ((nexp > 0) && (yy[2] == 0))\n     {\n       emovz (yy, xt);\n@@ -5080,7 +5082,7 @@ asctoeg (ss, y, oprec)\n       esign = -1;\n       if (nexp > 4096)\n \t{\n-\t  /* Punt.  Can't handle this without 2 divides. */\n+\t  /* Punt.  Can't handle this without 2 divides.  */\n \t  emovi (etens[0], tt);\n \t  lexp -= tt[E];\n \t  k = edivm (tt, yy);\n@@ -5640,7 +5642,7 @@ toibm (x, y, mode)\n \n /* If special NaN bit patterns are required, define them in tm.h\n    as arrays of unsigned 16-bit shorts.  Otherwise, use the default\n-   patterns here. */\n+   patterns here.  */\n #ifdef TFMODE_NAN\n TFMODE_NAN;\n #else\n@@ -5692,7 +5694,7 @@ make_nan (nan, sign, mode)\n   switch (mode)\n     {\n /* Possibly the `reserved operand' patterns on a VAX can be\n-   used like NaN's, but probably not in the same way as IEEE. */\n+   used like NaN's, but probably not in the same way as IEEE.  */\n #if !defined(DEC) && !defined(IBM)\n     case TFmode:\n       n = 8;\n@@ -5759,9 +5761,9 @@ ereal_from_float (f)\n       s[0] = (unsigned EMUSHORT) f;\n       s[1] = (unsigned EMUSHORT) (f >> 16);\n     }\n-  /* Convert and promote the target float to E-type. */\n+  /* Convert and promote the target float to E-type.  */\n   e24toe (s, e);\n-  /* Output E-type to REAL_VALUE_TYPE. */\n+  /* Output E-type to REAL_VALUE_TYPE.  */\n   PUT_REAL (e, &r);\n   return r;\n }\n@@ -5813,9 +5815,9 @@ ereal_from_double (d)\n       s[3] = (unsigned EMUSHORT) (d[0] >> 48);\n #endif\n     }\n-  /* Convert target double to E-type. */\n+  /* Convert target double to E-type.  */\n   e53toe (s, e);\n-  /* Output E-type to REAL_VALUE_TYPE. */\n+  /* Output E-type to REAL_VALUE_TYPE.  */\n   PUT_REAL (e, &r);\n   return r;\n }\n@@ -5827,7 +5829,7 @@ ereal_from_double (d)\n \n static void\n uditoe (di, e)\n-     unsigned EMUSHORT *di;  /* Address of the 64-bit int. */\n+     unsigned EMUSHORT *di;  /* Address of the 64-bit int.  */\n      unsigned EMUSHORT *e;\n {\n   unsigned EMUSHORT yi[NI];\n@@ -5852,11 +5854,11 @@ uditoe (di, e)\n   emovo (yi, e);\n }\n \n-/* Convert target computer signed 64-bit integer to e-type. */\n+/* Convert target computer signed 64-bit integer to e-type.  */\n \n static void\n ditoe (di, e)\n-     unsigned EMUSHORT *di;  /* Address of the 64-bit int. */\n+     unsigned EMUSHORT *di;  /* Address of the 64-bit int.  */\n      unsigned EMUSHORT *e;\n {\n   unsigned EMULONG acc;\n@@ -5901,7 +5903,7 @@ ditoe (di, e)\n }\n \n \n-/* Convert e-type to unsigned 64-bit int. */\n+/* Convert e-type to unsigned 64-bit int.  */\n \n static void \n etoudi (x, i)\n@@ -5984,7 +5986,7 @@ etoudi (x, i)\n }\n \n \n-/* Convert e-type to signed 64-bit int. */\n+/* Convert e-type to signed 64-bit int.  */\n \n static void \n etodi (x, i)\n@@ -6082,7 +6084,7 @@ etodi (x, i)\n }\n \n \n-/* Longhand square root routine. */\n+/* Longhand square root routine.  */\n \n \n static int esqinited = 0;\n@@ -6124,7 +6126,7 @@ esqrt (x, y)\n       return;\n     }\n #endif\n-  /* Bring in the arg and renormalize if it is denormal. */\n+  /* Bring in the arg and renormalize if it is denormal.  */\n   emovi (x, xx);\n   m = (EMULONG) xx[1];\t\t/* local long word exponent */\n   if (m == 0)\n@@ -6153,7 +6155,7 @@ esqrt (x, y)\n       /* bring in next word of arg */\n       if (j < NE)\n \tnum[NI - 1] = xx[j + 3];\n-      /* Do additional bit on last outer loop, for roundoff. */\n+      /* Do additional bit on last outer loop, for roundoff.  */\n       if (nlups <= 8)\n \tn = nlups + 1;\n       for (i = 0; i < n; i++)\n@@ -6179,15 +6181,15 @@ esqrt (x, y)\n       j += 1;\n     }\n \n-  /* Adjust for extra, roundoff loop done. */\n+  /* Adjust for extra, roundoff loop done.  */\n   exp += (NBITS - 1) - rndprc;\n \n-  /* Sticky bit = 1 if the remainder is nonzero. */\n+  /* Sticky bit = 1 if the remainder is nonzero.  */\n   k = 0;\n   for (i = 3; i < NI; i++)\n     k |= (int) num[i];\n \n-  /* Renormalize and round off. */\n+  /* Renormalize and round off.  */\n   emdnorm (sq, k, 0, exp, 64);\n   emovo (sq, y);\n }"}, {"sha": "8d64cd96b9dd94e50ae07cc1353d7da34fdae676", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -1765,8 +1765,9 @@ constrain_operands (insn_code_num, strict)\n \t\tbreak;\n \n \t      case 'X':\n-\t\t/* This is used for a MATCH_SCRATCH in the cases when we\n-\t\t   don't actually need anything.  So anything goes any time. */\n+\t\t/* This is used for a MATCH_SCRATCH in the cases when\n+\t\t   we don't actually need anything.  So anything goes\n+\t\t   any time.  */\n \t\twin = 1;\n \t\tbreak;\n \n@@ -1921,7 +1922,7 @@ constrain_operands (insn_code_num, strict)\n \t\t  if ((GET_CODE (recog_operand[opno]) == MEM\n \t\t       || op_types[opno] != OP_OUT)\n \t\t      && opno != eopno\n-\t\t      /* Ignore things like match_operator operands. */\n+\t\t      /* Ignore things like match_operator operands.  */\n \t\t      && *constraints[opno] != 0\n \t\t      && ! (matching_operands[opno] == eopno\n \t\t\t    && rtx_equal_p (recog_operand[opno],"}, {"sha": "10c1d76a5b211b55a091f6e31eeeb91cad1118a1", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 115, "deletions": 114, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -214,7 +214,7 @@ static HARD_REG_SET *block_out_reg_set;\n    up by find_blocks and used there and in life_analysis.  It can be used\n    later, but only to look up an insn that is the head or tail of some\n    block.  life_analysis and the stack register conversion process can\n-   add insns within a block. */\n+   add insns within a block.  */\n static int *block_number;\n \n /* This is the register file for all register after conversion */\n@@ -225,7 +225,7 @@ static rtx\n   (FP_mode_reg[(regno)-FIRST_STACK_REG][(int)(mode)])\n \n /* Get the basic block number of an insn.  See note at block_number\n-   definition are validity of this information. */\n+   definition are validity of this information.  */\n \n #define BLOCK_NUM(INSN)  \\\n   ((INSN_UID (INSN) > max_uid)\t\\\n@@ -421,7 +421,7 @@ reg_to_stack (first, file)\n \t   before_function_beg = 0;\n \n \t/* Remember whether or not this insn mentions an FP regs.\n-\t   Check JUMP_INSNs too, in case someone creates a funny PARALLEL. */\n+\t   Check JUMP_INSNs too, in case someone creates a funny PARALLEL.  */\n \n \tif (GET_RTX_CLASS (code) == 'i'\n \t    && stack_regs_mentioned_p (PATTERN (insn)))\n@@ -433,7 +433,7 @@ reg_to_stack (first, file)\n \n \t    if (before_function_beg && code == INSN\n \t        && GET_CODE (PATTERN (insn)) == USE)\n-              record_reg_life_pat (PATTERN (insn), (HARD_REG_SET*) 0,\n+              record_reg_life_pat (PATTERN (insn), (HARD_REG_SET *) 0,\n \t\t\t\t   &stackentry, 1);\n \t  }\n \telse\n@@ -453,13 +453,13 @@ reg_to_stack (first, file)\n   if (! stack_reg_seen)\n     return;\n \n-  /* If there are stack registers, there must be at least one block. */\n+  /* If there are stack registers, there must be at least one block.  */\n \n   if (! blocks)\n     abort ();\n \n   /* Allocate some tables that last till end of compiling this function\n-     and some needed only in find_blocks and life_analysis. */\n+     and some needed only in find_blocks and life_analysis.  */\n \n   block_begin = (rtx *) alloca (blocks * sizeof (rtx));\n   block_end = (rtx *) alloca (blocks * sizeof (rtx));\n@@ -477,7 +477,7 @@ reg_to_stack (first, file)\n \n   /* Dump the life analysis debug information before jump\n      optimization, as that will destroy the LABEL_REFS we keep the\n-     information in. */\n+     information in.  */\n \n   if (file)\n     dump_stack_info (file);\n@@ -490,7 +490,7 @@ reg_to_stack (first, file)\n \f\n /* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the\n    label's chain of references, and note which insn contains each\n-   reference. */\n+   reference.  */\n \n static void\n record_label_references (insn, pat)\n@@ -508,11 +508,12 @@ record_label_references (insn, pat)\n       if (GET_CODE (label) != CODE_LABEL)\n \tabort ();\n \n-      /* If this is an undefined label, LABEL_REFS (label) contains garbage. */\n+      /* If this is an undefined label, LABEL_REFS (label) contains\n+         garbage.  */\n       if (INSN_UID (label) == 0)\n \treturn;\n \n-      /* Don't make a duplicate in the code_label's chain. */\n+      /* Don't make a duplicate in the code_label's chain.  */\n \n       for (ref = LABEL_REFS (label);\n \t   ref && ref != label;\n@@ -543,7 +544,7 @@ record_label_references (insn, pat)\n \f\n /* Return a pointer to the REG expression within PAT.  If PAT is not a\n    REG, possible enclosed by a conversion rtx, return the inner part of\n-   PAT that stopped the search. */\n+   PAT that stopped the search.  */\n \n static rtx *\n get_true_reg (pat)\n@@ -554,7 +555,7 @@ get_true_reg (pat)\n       {\n \tcase SUBREG:\n \t\t/* eliminate FP subregister accesses in favour of the\n-\t\t   actual FP register in use. */\n+\t\t   actual FP register in use.  */\n \t {\n \t   rtx subreg;\n \t   if (FP_REG_P (subreg = SUBREG_REG (*pat)))\n@@ -587,7 +588,7 @@ get_true_reg (pat)\n    OPERAND_CLASS is set to `class' as required by the constraints, not to\n    the subclass. If an alternative allows more than one class,\n    OPERAND_CLASS is set to the smallest class that is a union of the\n-   allowed classes. */\n+   allowed classes.  */\n \n static int\n constrain_asm_operands (n_operands, operands, operand_constraints,\n@@ -660,11 +661,11 @@ constrain_asm_operands (n_operands, operands, operand_constraints,\n \t      case '!':\n \t      case '*':\n \t      case '%':\n-\t\t/* Ignore these. */\n+\t\t/* Ignore these.  */\n \t\tbreak;\n \n \t      case '#':\n-\t\t/* Ignore rest of this alternative. */\n+\t\t/* Ignore rest of this alternative.  */\n \t\twhile (*p && *p != ',') p++;\n \t\tbreak;\n \n@@ -678,7 +679,7 @@ constrain_asm_operands (n_operands, operands, operand_constraints,\n \t\t   This kind of constraint is used for instructions such\n \t\t   as add when they take only two operands.\n \n-\t\t   Note that the lower-numbered operand is passed first. */\n+\t\t   Note that the lower-numbered operand is passed first.  */\n \n \t\tif (operands_match_p (operands[c - '0'],\n \t\t\t\t      operands[this_operand]))\n@@ -690,7 +691,7 @@ constrain_asm_operands (n_operands, operands, operand_constraints,\n \n \t      case 'p':\n \t\t/* p is used for address_operands.  Since this is an asm,\n-\t\t   just to make sure that the operand is valid for Pmode. */\n+\t\t   just to make sure that the operand is valid for Pmode.  */\n \n \t\tif (strict_memory_address_p (Pmode, op))\n \t\t  win = 1;\n@@ -723,7 +724,7 @@ constrain_asm_operands (n_operands, operands, operand_constraints,\n \n \t      case 'X':\n \t\t/* This is used for a MATCH_SCRATCH in the cases when we\n-\t\t   don't actually need anything.  So anything goes any time. */\n+\t\t   don't actually need anything.  So anything goes any time.  */\n \t\twin = 1;\n \t\tbreak;\n \n@@ -847,7 +848,7 @@ constrain_asm_operands (n_operands, operands, operand_constraints,\n     }\n \n   /* For operands constrained to match another operand, copy the other\n-     operand's class to this operand's class. */\n+     operand's class to this operand's class.  */\n   for (j = 0; j < n_operands; j++)\n     if (operand_matches[j] >= 0)\n       operand_class[j] = operand_class[operand_matches[j]];\n@@ -863,7 +864,7 @@ constrain_asm_operands (n_operands, operands, operand_constraints,\n \n    There are many rules that an asm statement for stack-like regs must\n    follow.  Those rules are explained at the top of this file: the rule\n-   numbers below refer to that explanation. */\n+   numbers below refer to that explanation.  */\n \n static void\n record_asm_reg_life (insn, regstack, operands, constraints,\n@@ -898,7 +899,7 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n   if (i < 0)\n     malformed_asm = 1;\n \n-  /* Strip SUBREGs here to make the following code simpler. */\n+  /* Strip SUBREGs here to make the following code simpler.  */\n   for (i = 0; i < n_operands; i++)\n     if (GET_CODE (operands[i]) == SUBREG\n \t&& GET_CODE (SUBREG_REG (operands[i])) == REG)\n@@ -934,7 +935,7 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n      operand constraints must select a class with a single reg.\n \n      Also enforce rule #5: Output operands must start at the top of\n-     the reg-stack: output operands may not \"skip\" a reg. */\n+     the reg-stack: output operands may not \"skip\" a reg.  */\n \n   bzero ((char *) reg_used_as_output, sizeof (reg_used_as_output));\n   for (i = 0; i < n_outputs; i++)\n@@ -967,14 +968,14 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n \n   /* Enforce rule #2: All implicitly popped input regs must be closer\n      to the top of the reg-stack than any input that is not implicitly\n-     popped. */\n+     popped.  */\n \n   bzero ((char *) implicitly_dies, sizeof (implicitly_dies));\n   for (i = first_input; i < first_input + n_inputs; i++)\n     if (STACK_REG_P (operands[i]))\n       {\n \t/* An input reg is implicitly popped if it is tied to an\n-\t   output, or if there is a CLOBBER for it. */\n+\t   output, or if there is a CLOBBER for it.  */\n \tint j;\n \n \tfor (j = 0; j < n_clobbers; j++)\n@@ -1006,7 +1007,7 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n      output constraints must use the \"&\" earlyclobber.\n \n      ???  Detect this more deterministically by having constraint_asm_operands\n-     record any earlyclobber. */\n+     record any earlyclobber.  */\n \n   for (i = first_input; i < first_input + n_inputs; i++)\n     if (operand_matches[i] == -1)\n@@ -1079,7 +1080,7 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n    a SET_DEST in DEST, and other registers in SRC.\n \n    This function does not know about SET_DESTs that are both input and\n-   output (such as ZERO_EXTRACT) - this cannot happen on a 387. */\n+   output (such as ZERO_EXTRACT) - this cannot happen on a 387.  */\n \n static void\n record_reg_life_pat (pat, src, dest, douse)\n@@ -1109,7 +1110,7 @@ record_reg_life_pat (pat, src, dest, douse)\n       return;\n     }\n \n-  /* We don't need to consider either of these cases. */\n+  /* We don't need to consider either of these cases.  */\n   if (GET_CODE (pat) == USE && !douse || GET_CODE (pat) == CLOBBER)\n     return;\n \n@@ -1131,7 +1132,7 @@ record_reg_life_pat (pat, src, dest, douse)\n /* Calculate the number of inputs and outputs in BODY, an\n    asm_operands.  N_OPERANDS is the total number of operands, and\n    N_INPUTS and N_OUTPUTS are pointers to ints into which the results are\n-   placed. */\n+   placed.  */\n \n static void\n get_asm_operand_lengths (body, n_operands, n_inputs, n_outputs)\n@@ -1168,7 +1169,7 @@ get_asm_operand_lengths (body, n_operands, n_inputs, n_outputs)\n    register.  The block_end[] data is kept accurate.\n \n    Existing death and unset notes for stack registers are deleted\n-   before processing the insn. */\n+   before processing the insn.  */\n \n static void\n record_reg_life (insn, block, regstack)\n@@ -1194,13 +1195,13 @@ record_reg_life (insn, block, regstack)\n     else\n       note_link = &XEXP (note, 1);\n \n-  /* Process all patterns in the insn. */\n+  /* Process all patterns in the insn.  */\n \n   n_operands = asm_noperands (PATTERN (insn));\n   if (n_operands >= 0)\n     {\n       /* This insn is an `asm' with operands.  Decode the operands,\n-\t decide how many are inputs, and record the life information. */\n+\t decide how many are inputs, and record the life information.  */\n \n       rtx operands[MAX_RECOG_OPERANDS];\n       rtx body = PATTERN (insn);\n@@ -1249,7 +1250,7 @@ record_reg_life (insn, block, regstack)\n \n           /* There might be a reg that is live after a function call.\n              Initialize it to zero so that the program does not crash.  See\n-\t     comment towards the end of stack_reg_life_analysis(). */\n+\t     comment towards the end of stack_reg_life_analysis().  */\n \n           for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n \t    if (! TEST_HARD_REG_BIT (dest, reg)\n@@ -1260,7 +1261,7 @@ record_reg_life (insn, block, regstack)\n \t        /* The insn will use virtual register numbers, and so\n \t           convert_regs is expected to process these.  But BLOCK_NUM\n \t           cannot be used on these insns, because they do not appear in\n-\t           block_number[]. */\n+\t           block_number[].  */\n \n \t        pat = gen_rtx (SET, VOIDmode, FP_MODE_REG (reg, DFmode),\n \t\t\t       CONST0_RTX (DFmode));\n@@ -1270,7 +1271,7 @@ record_reg_life (insn, block, regstack)\n \t        CLEAR_HARD_REG_BIT (regstack->reg_set, reg);\n \n \t        /* If the CALL_INSN was the end of a block, move the\n-\t           block_end to point to the new insn. */\n+\t           block_end to point to the new insn.  */\n \n \t        if (block_end[block] == insn)\n \t          block_end[block] = init;\n@@ -1286,7 +1287,7 @@ record_reg_life (insn, block, regstack)\n }\n \f\n /* Find all basic blocks of the function, which starts with FIRST.\n-   For each JUMP_INSN, build the chain of LABEL_REFS on each CODE_LABEL. */\n+   For each JUMP_INSN, build the chain of LABEL_REFS on each CODE_LABEL.  */\n \n static void\n find_blocks (first)\n@@ -1299,7 +1300,7 @@ find_blocks (first)\n   rtx label_value_list = 0;\n \n   /* Record where all the blocks start and end.\n-     Record which basic blocks control can drop in to. */\n+     Record which basic blocks control can drop in to.  */\n \n   block = -1;\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n@@ -1479,7 +1480,7 @@ stack_result (decl)\n \n    If there are registers that are live at the start of the function,\n    insns are emitted to initialize these registers.  Something similar is\n-   done after CALL_INSNs in record_reg_life. */\n+   done after CALL_INSNs in record_reg_life.  */\n \n static void\n stack_reg_life_analysis (first, stackentry)\n@@ -1494,15 +1495,15 @@ stack_reg_life_analysis (first, stackentry)\n \n      if (retvalue = stack_result (current_function_decl))\n       {\n-        /* Find all RETURN insns and mark them. */\n+        /* Find all RETURN insns and mark them.  */\n \n         for (block = blocks - 1; --block >= 0;)\n \t   if (GET_CODE (block_end[block]) == JUMP_INSN\n \t     && GET_CODE (PATTERN (block_end[block])) == RETURN)\n \t      mark_regs_pat (retvalue, block_out_reg_set+block);\n \n         /* Mark off the end of last block if we \"fall off\" the end of the\n-\t   function into the epilogue. */\n+\t   function into the epilogue.  */\n \n         if (GET_CODE (block_end[blocks-1]) != JUMP_INSN\n \t    || GET_CODE (PATTERN (block_end[blocks-1])) == RETURN)\n@@ -1529,21 +1530,21 @@ stack_reg_life_analysis (first, stackentry)\n \n \t  /* If the insn is a CALL_INSN, we need to ensure that\n \t     everything dies.  But otherwise don't process unless there\n-\t     are some stack regs present. */\n+\t     are some stack regs present.  */\n \n \t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n \t    record_reg_life (insn, block, &regstack);\n \n \t} while (insn != block_begin[block]);\n \n       /* Set the state at the start of the block.  Mark that no\n-\t register mapping information known yet. */\n+\t register mapping information known yet.  */\n \n       COPY_HARD_REG_SET (block_stack_in[block].reg_set, regstack.reg_set);\n       block_stack_in[block].top = -2;\n \n       /* If there is a label, propagate our register life to all jumps\n-\t to this label. */\n+\t to this label.  */\n \n       if (GET_CODE (insn) == CODE_LABEL)\n \t{\n@@ -1564,7 +1565,7 @@ stack_reg_life_analysis (first, stackentry)\n \t\t     processed.  If there are registers that were not known\n \t\t     to be live then, but are live now, we must back up\n \t\t     and restart life analysis from that point with the new\n-\t\t     life information. */\n+\t\t     life information.  */\n \n \t\t  GO_IF_HARD_REG_SUBSET (block_stack_in[block].reg_set,\n \t\t\t\t\t block_out_reg_set[jump_block],\n@@ -1594,7 +1595,7 @@ stack_reg_life_analysis (first, stackentry)\n     /* If any reg is live at the start of the first block of a\n        function, then we must guarantee that the reg holds some value by\n        generating our own \"load\" of that register.  Otherwise a 387 would\n-       fault trying to access an empty register. */\n+       fault trying to access an empty register.  */\n \n   /* Load zero into each live register.  The fact that a register\n      appears live at the function start necessarily implies an error\n@@ -1605,7 +1606,7 @@ stack_reg_life_analysis (first, stackentry)\n \n      Note that we are inserting virtual register references here:\n      these insns must be processed by convert_regs later.  Also, these\n-     insns will not be in block_number, so BLOCK_NUM() will fail for them. */\n+     insns will not be in block_number, so BLOCK_NUM() will fail for them.  */\n \n   for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; reg--)\n     if (TEST_HARD_REG_BIT (block_stack_in[0].reg_set, reg)\n@@ -1628,7 +1629,7 @@ stack_reg_life_analysis (first, stackentry)\n  *****************************************************************************/\n \n /* Replace REG, which is a pointer to a stack reg RTX, with an RTX for\n-   the desired hard REGNO. */\n+   the desired hard REGNO.  */\n \n static void\n replace_reg (reg, regno)\n@@ -1650,7 +1651,7 @@ replace_reg (reg, regno)\n }\n \n /* Remove a note of type NOTE, which must be found, for register\n-   number REGNO from INSN.  Remove only one such note. */\n+   number REGNO from INSN.  Remove only one such note.  */\n \n static void\n remove_regno_note (insn, note, regno)\n@@ -1676,7 +1677,7 @@ remove_regno_note (insn, note, regno)\n \n /* Find the hard register number of virtual register REG in REGSTACK.\n    The hard register number is relative to the top of the stack.  -1 is\n-   returned if the register is not found. */\n+   returned if the register is not found.  */\n \n static int\n get_hard_regnum (regstack, reg)\n@@ -1697,7 +1698,7 @@ get_hard_regnum (regstack, reg)\n \n /* Delete INSN from the RTL.  Mark the insn, but don't remove it from\n    the chain of insns.  Doing so could confuse block_begin and block_end\n-   if this were the only insn in the block. */\n+   if this were the only insn in the block.  */\n \n static void\n delete_insn_for_stacker (insn)\n@@ -1713,7 +1714,7 @@ delete_insn_for_stacker (insn)\n    pop.  WHEN is either emit_insn_before or emit_insn_after.  A pop insn\n    is represented as a SET whose destination is the register to be popped\n    and source is the top of stack.  A death note for the top of stack\n-   cases the movdf pattern to pop. */\n+   cases the movdf pattern to pop.  */\n \n static rtx\n emit_pop_insn (insn, regstack, reg, when)\n@@ -1734,7 +1735,7 @@ emit_pop_insn (insn, regstack, reg, when)\n \t\t     FP_MODE_REG (FIRST_STACK_REG, DFmode));\n \n   pop_insn = (*when) (pop_rtx, insn);\n-  /* ??? This used to be VOIDmode, but that seems wrong. */\n+  /* ??? This used to be VOIDmode, but that seems wrong.  */\n   PUT_MODE (pop_insn, QImode);\n \n   REG_NOTES (pop_insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n@@ -1755,7 +1756,7 @@ emit_pop_insn (insn, regstack, reg, when)\n    the swap.  A swap insn is represented as a PARALLEL of two patterns:\n    each pattern moves one reg to the other.\n \n-   If REG is already at the top of the stack, no insn is emitted. */\n+   If REG is already at the top of the stack, no insn is emitted.  */\n \n static void\n emit_swap_insn (insn, regstack, reg)\n@@ -1799,7 +1800,7 @@ emit_swap_insn (insn, regstack, reg)\n       rtx i1dest = *get_true_reg (&SET_DEST (i1set));\n \n       /* If the previous register stack push was from the reg we are to\n-\t swap with, omit the swap. */\n+\t swap with, omit the swap.  */\n \n       if (GET_CODE (i1dest) == REG && REGNO (i1dest) == FIRST_STACK_REG\n \t  && GET_CODE (i1src) == REG && REGNO (i1src) == hard_regno - 1\n@@ -1825,12 +1826,12 @@ emit_swap_insn (insn, regstack, reg)\n   swap_rtx = gen_swapdf (FP_MODE_REG (hard_regno, DFmode),\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n   swap_insn = emit_insn_after (swap_rtx, i1);\n-  /* ??? This used to be VOIDmode, but that seems wrong. */\n+  /* ??? This used to be VOIDmode, but that seems wrong.  */\n   PUT_MODE (swap_insn, QImode);\n }\n \f\n /* Handle a move to or from a stack register in PAT, which is in INSN.\n-   REGSTACK is the current stack. */\n+   REGSTACK is the current stack.  */\n \n static void\n move_for_stack_reg (insn, regstack, pat)\n@@ -1848,27 +1849,27 @@ move_for_stack_reg (insn, regstack, pat)\n   if (STACK_REG_P (src) && STACK_REG_P (dest))\n     {\n       /* Write from one stack reg to another.  If SRC dies here, then\n-\t just change the register mapping and delete the insn. */\n+\t just change the register mapping and delete the insn.  */\n \n       note = find_regno_note (insn, REG_DEAD, REGNO (src));\n       if (note)\n \t{\n \t  int i;\n \n-\t  /* If this is a no-op move, there must not be a REG_DEAD note. */\n+\t  /* If this is a no-op move, there must not be a REG_DEAD note.  */\n \t  if (REGNO (src) == REGNO (dest))\n \t    abort ();\n \n \t  for (i = regstack->top; i >= 0; i--)\n \t    if (regstack->reg[i] == REGNO (src))\n \t      break;\n \n-\t  /* The source must be live, and the dest must be dead. */\n+\t  /* The source must be live, and the dest must be dead.  */\n \t  if (i < 0 || get_hard_regnum (regstack, dest) >= FIRST_STACK_REG)\n \t    abort ();\n \n \t  /* It is possible that the dest is unused after this insn.\n-\t     If so, just pop the src. */\n+\t     If so, just pop the src.  */\n \n \t  if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n \t    {\n@@ -1888,12 +1889,12 @@ move_for_stack_reg (insn, regstack, pat)\n \t  return;\n \t}\n \n-      /* The source reg does not die. */\n+      /* The source reg does not die.  */\n \n       /* If this appears to be a no-op move, delete it, or else it\n \t will confuse the machine description output patterns. But if\n \t it is REG_UNUSED, we must pop the reg now, as per-insn processing\n-\t for REG_UNUSED will not work for deleted insns. */\n+\t for REG_UNUSED will not work for deleted insns.  */\n \n       if (REGNO (src) == REGNO (dest))\n \t{\n@@ -1918,7 +1919,7 @@ move_for_stack_reg (insn, regstack, pat)\n     {\n       /* Save from a stack reg to MEM, or possibly integer reg.  Since\n \t only top of stack may be saved, emit an exchange first if\n-\t needs be. */\n+\t needs be.  */\n \n       emit_swap_insn (insn, regstack, src);\n \n@@ -2006,7 +2007,7 @@ swap_rtx_condition (pat)\n    Also, a pop insn may need to be emitted.  The 387 does have an\n    `fcompp' insn that can pop two regs, but it is sometimes too expensive\n    to do this - a `fcomp' followed by a `fstpl %st(0)' may be easier to\n-   set up. */\n+   set up.  */\n \n static void\n compare_for_stack_reg (insn, regstack, pat)\n@@ -2021,7 +2022,7 @@ compare_for_stack_reg (insn, regstack, pat)\n   src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n \n   /* ??? If fxch turns out to be cheaper than fstp, give priority to\n-     registers that die in this insn - move those to stack top first. */\n+     registers that die in this insn - move those to stack top first.  */\n   if (! STACK_REG_P (*src1)\n       || (STACK_REG_P (*src2)\n \t  && get_hard_regnum (regstack, *src2) == FIRST_STACK_REG))\n@@ -2044,7 +2045,7 @@ compare_for_stack_reg (insn, regstack, pat)\n       INSN_CODE (insn) = -1;\n     }\n \n-  /* We will fix any death note later. */\n+  /* We will fix any death note later.  */\n \n   src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n \n@@ -2069,7 +2070,7 @@ compare_for_stack_reg (insn, regstack, pat)\n \n   /* If the second operand dies, handle that.  But if the operands are\n      the same stack register, don't bother, because only one death is\n-     needed, and it was just handled. */\n+     needed, and it was just handled.  */\n \n   if (src2_note\n       && ! (STACK_REG_P (*src1) && STACK_REG_P (*src2)\n@@ -2078,7 +2079,7 @@ compare_for_stack_reg (insn, regstack, pat)\n       /* As a special case, two regs may die in this insn if src2 is\n \t next to top of stack and the top of stack also dies.  Since\n \t we have already popped src1, \"next to top of stack\" is really\n-\t at top (FIRST_STACK_REG) now. */\n+\t at top (FIRST_STACK_REG) now.  */\n \n       if (get_hard_regnum (regstack, XEXP (src2_note, 0)) == FIRST_STACK_REG\n \t  && src1_note)\n@@ -2091,7 +2092,7 @@ compare_for_stack_reg (insn, regstack, pat)\n \t{\n \t  /* The 386 can only represent death of the first operand in\n \t     the case handled above.  In all other cases, emit a separate\n-\t     pop and remove the death note from here. */\n+\t     pop and remove the death note from here.  */\n \n \t  link_cc0_insns (insn);\n \n@@ -2104,7 +2105,7 @@ compare_for_stack_reg (insn, regstack, pat)\n }\n \f\n /* Substitute new registers in PAT, which is part of INSN.  REGSTACK\n-   is the current register layout. */\n+   is the current register layout.  */\n \n static void\n subst_stack_regs_pat (insn, regstack, pat)\n@@ -2122,7 +2123,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n   dest = get_true_reg (&SET_DEST (pat));\n   src  = get_true_reg (&SET_SRC (pat));\n \n-  /* See if this is a `movM' pattern, and handle elsewhere if so. */\n+  /* See if this is a `movM' pattern, and handle elsewhere if so.  */\n \n   if (*dest != cc0_rtx\n       && (STACK_REG_P (*src)\n@@ -2151,13 +2152,13 @@ subst_stack_regs_pat (insn, regstack, pat)\n \tbreak;\n \n       case REG:\n-\t/* This is a `tstM2' case. */\n+\t/* This is a `tstM2' case.  */\n \tif (*dest != cc0_rtx)\n \t  abort ();\n \n \tsrc1 = src;\n \n-\t/* Fall through. */\n+\t/* Fall through.  */\n \n       case FLOAT_TRUNCATE:\n       case SQRT:\n@@ -2193,18 +2194,18 @@ subst_stack_regs_pat (insn, regstack, pat)\n       case DIV:\n \t/* On i386, reversed forms of subM3 and divM3 exist for\n \t   MODE_FLOAT, so the same code that works for addM3 and mulM3\n-\t   can be used. */\n+\t   can be used.  */\n       case MULT:\n       case PLUS:\n \t/* These insns can accept the top of stack as a destination\n \t   from a stack reg or mem, or can use the top of stack as a\n \t   source and some other stack register (possibly top of stack)\n-\t   as a destination. */\n+\t   as a destination.  */\n \n \tsrc1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n \tsrc2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n \n-\t/* We will fix any death note later. */\n+\t/* We will fix any death note later.  */\n \n \tif (STACK_REG_P (*src1))\n \t  src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n@@ -2216,7 +2217,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t  src2_note = NULL_RTX;\n \n \t/* If either operand is not a stack register, then the dest\n-\t   must be top of stack. */\n+\t   must be top of stack.  */\n \n \tif (! STACK_REG_P (*src1) || ! STACK_REG_P (*src2))\n \t  emit_swap_insn (insn, regstack, *dest);\n@@ -2249,7 +2250,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t       the destination is somewhere else - merely substitute it.\n \t       But if the reg that dies is not at top of stack, then\n \t       move the top of stack to the dead reg, as though we had\n-\t       done the insn and then a store-with-pop. */\n+\t       done the insn and then a store-with-pop.  */\n \n \t    if (REGNO (XEXP (src1_note, 0)) == regstack->reg[regstack->top])\n \t      {\n@@ -2388,14 +2389,14 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n   /* Find out what the constraints required.  If no constraint\n      alternative matches, that is a compiler bug: we should have caught\n      such an insn during the life analysis pass (and reload should have\n-     caught it regardless). */\n+     caught it regardless).  */\n \n   i = constrain_asm_operands (n_operands, operands, constraints,\n \t\t\t      operand_matches, operand_class);\n   if (i < 0)\n     abort ();\n \n-  /* Strip SUBREGs here to make the following code simpler. */\n+  /* Strip SUBREGs here to make the following code simpler.  */\n   for (i = 0; i < n_operands; i++)\n     if (GET_CODE (operands[i]) == SUBREG\n \t&& GET_CODE (SUBREG_REG (operands[i])) == REG)\n@@ -2481,7 +2482,7 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \t   these constraints are for single register classes, and reload\n \t   guaranteed that operand[i] is already in that class, we can\n \t   just use REGNO (operands[i]) to know which actual reg this\n-\t   operand needs to be in. */\n+\t   operand needs to be in.  */\n \n \tint regno = get_hard_regnum (&temp_stack, operands[i]);\n \n@@ -2493,7 +2494,7 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \t    /* operands[i] is not in the right place.  Find it\n \t       and swap it with whatever is already in I's place.\n \t       K is where operands[i] is now.  J is where it should\n-\t       be. */\n+\t       be.  */\n \t    int j, k, temp;\n \n \t    k = temp_stack.top - (regno - FIRST_STACK_REG);\n@@ -2512,7 +2513,7 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n   change_stack (insn, regstack, &temp_stack, emit_insn_before);\n \n   /* Make the needed input register substitutions.  Do death notes and\n-     clobbers too, because these are for inputs, not outputs. */\n+     clobbers too, because these are for inputs, not outputs.  */\n \n   for (i = first_input; i < first_input + n_inputs; i++)\n     if (STACK_REG_P (operands[i]))\n@@ -2552,13 +2553,13 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \t}\n     }\n \n-  /* Now remove from REGSTACK any inputs that the asm implicitly popped. */\n+  /* Now remove from REGSTACK any inputs that the asm implicitly popped.  */\n \n   for (i = first_input; i < first_input + n_inputs; i++)\n     if (STACK_REG_P (operands[i]))\n       {\n \t/* An input reg is implicitly popped if it is tied to an\n-\t   output, or if there is a CLOBBER for it. */\n+\t   output, or if there is a CLOBBER for it.  */\n \tint j;\n \n \tfor (j = 0; j < n_clobbers; j++)\n@@ -2581,7 +2582,7 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \n   /* Now add to REGSTACK any outputs that the asm implicitly pushed.\n      Note that there isn't any need to substitute register numbers.\n-     ???  Explain why this is true. */\n+     ???  Explain why this is true.  */\n \n   for (i = LAST_STACK_REG; i >= FIRST_STACK_REG; i--)\n     {\n@@ -2639,7 +2640,7 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n /* Substitute stack hard reg numbers for stack virtual registers in\n    INSN.  Non-stack register numbers are not changed.  REGSTACK is the\n    current stack content.  Insns may be emitted as needed to arrange the\n-   stack for the 387 based on the contents of the insn. */\n+   stack for the 387 based on the contents of the insn.  */\n \n static void\n subst_stack_regs (insn, regstack)\n@@ -2676,7 +2677,7 @@ subst_stack_regs (insn, regstack)\n      Since we only record whether entire insn mentions stack regs, and\n      subst_stack_regs_pat only works for patterns that contain stack regs,\n      we must check each pattern in a parallel here.  A call_value_pop could\n-     fail otherwise. */\n+     fail otherwise.  */\n \n   if (GET_MODE (insn) == QImode)\n     {\n@@ -2685,7 +2686,7 @@ subst_stack_regs (insn, regstack)\n \t{\n \t  /* This insn is an `asm' with operands.  Decode the operands,\n \t     decide how many are inputs, and do register substitution.\n-\t     Any REG_UNUSED notes will be handled by subst_asm_stack_regs. */\n+\t     Any REG_UNUSED notes will be handled by subst_asm_stack_regs.  */\n \n \t  rtx operands[MAX_RECOG_OPERANDS];\n \t  rtx *operands_loc[MAX_RECOG_OPERANDS];\n@@ -2714,15 +2715,15 @@ subst_stack_regs (insn, regstack)\n     }\n \n   /* subst_stack_regs_pat may have deleted a no-op insn.  If so, any\n-     REG_UNUSED will already have been dealt with, so just return. */\n+     REG_UNUSED will already have been dealt with, so just return.  */\n \n   if (GET_CODE (insn) == NOTE)\n     return;\n \n   /* If there is a REG_UNUSED note on a stack register on this insn,\n      the indicated reg must be popped.  The REG_UNUSED note is removed,\n      since the form of the newly emitted pop insn references the reg,\n-     making it no longer `unset'. */\n+     making it no longer `unset'.  */\n \n   note_link = &REG_NOTES(insn);\n   for (note = *note_link; note; note = XEXP (note, 1))\n@@ -2745,7 +2746,7 @@ subst_stack_regs (insn, regstack)\n    will be the same as NEW upon return.\n \n    This function will not preserve block_end[].  But that information\n-   is no longer needed once this has executed. */\n+   is no longer needed once this has executed.  */\n \n static void\n change_stack (insn, old, new, when)\n@@ -2763,7 +2764,7 @@ change_stack (insn, old, new, when)\n   if (when == emit_insn_after)\n     insn = NEXT_INSN (insn);\n \n-  /* Pop any registers that are not needed in the new block. */\n+  /* Pop any registers that are not needed in the new block.  */\n \n   for (reg = old->top; reg >= 0; reg--)\n     if (! TEST_HARD_REG_BIT (new->reg_set, old->reg[reg]))\n@@ -2773,18 +2774,18 @@ change_stack (insn, old, new, when)\n   if (new->top == -2)\n     {\n       /* If the new block has never been processed, then it can inherit\n-\t the old stack order. */\n+\t the old stack order.  */\n \n       new->top = old->top;\n       bcopy (old->reg, new->reg, sizeof (new->reg));\n     }\n   else\n     {\n       /* This block has been entered before, and we must match the\n-\t previously selected stack order. */\n+\t previously selected stack order.  */\n \n       /* By now, the only difference should be the order of the stack,\n-\t not their depth or liveliness. */\n+\t not their depth or liveliness.  */\n \n       GO_IF_HARD_REG_EQUAL (old->reg_set, new->reg_set, win);\n \n@@ -2800,12 +2801,12 @@ change_stack (insn, old, new, when)\n \t depth of the stack.  In some cases, the reg at the top of\n \t stack may be correct, but swapped anyway in order to fix\n \t other regs.  But since we never swap any other reg away from\n-\t its correct slot, this algorithm will converge. */\n+\t its correct slot, this algorithm will converge.  */\n \n       do\n \t{\n \t  /* Swap the reg at top of stack into the position it is\n-\t     supposed to be in, until the correct top of stack appears. */\n+\t     supposed to be in, until the correct top of stack appears.  */\n \n \t  while (old->reg[old->top] != new->reg[new->top])\n \t    {\n@@ -2822,7 +2823,7 @@ change_stack (insn, old, new, when)\n \n \t  /* See if any regs remain incorrect.  If so, bring an\n \t     incorrect reg to the top of stack, and let the while loop\n-\t     above fix it. */\n+\t     above fix it.  */\n \n \t  for (reg = new->top; reg >= 0; reg--)\n \t    if (new->reg[reg] != old->reg[reg])\n@@ -2833,7 +2834,7 @@ change_stack (insn, old, new, when)\n \t      }\n \t} while (reg >= 0);\n \n-      /* At this point there must be no differences. */\n+      /* At this point there must be no differences.  */\n \n       for (reg = old->top; reg >= 0; reg--)\n \tif (old->reg[reg] != new->reg[reg])\n@@ -2849,7 +2850,7 @@ change_stack (insn, old, new, when)\n    is the order of the register stack in INSN.\n \n    Any code that is emitted here must not be later processed as part\n-   of any block, as it will already contain hard register numbers. */\n+   of any block, as it will already contain hard register numbers.  */\n \n static void\n goto_block_pat (insn, regstack, pat)\n@@ -2891,7 +2892,7 @@ goto_block_pat (insn, regstack, pat)\n   if (GET_CODE (label) != CODE_LABEL)\n     abort ();\n \n-  /* First, see if in fact anything needs to be done to the stack at all. */\n+  /* First, see if in fact anything needs to be done to the stack at all.  */\n   if (INSN_UID (label) <= 0)\n     return;\n \n@@ -2900,15 +2901,15 @@ goto_block_pat (insn, regstack, pat)\n   if (label_stack->top == -2)\n     {\n       /* If the target block hasn't had a stack order selected, then\n-\t we need merely ensure that no pops are needed. */\n+\t we need merely ensure that no pops are needed.  */\n \n       for (reg = regstack->top; reg >= 0; reg--)\n \tif (! TEST_HARD_REG_BIT (label_stack->reg_set, regstack->reg[reg]))\n \t  break;\n \n       if (reg == -1)\n \t{\n-\t  /* change_stack will not emit any code in this case. */\n+\t  /* change_stack will not emit any code in this case.  */\n \n \t  change_stack (label, regstack, label_stack, emit_insn_after);\n \t  return;\n@@ -2928,7 +2929,7 @@ goto_block_pat (insn, regstack, pat)\n      a jump around the code we are about to emit.  Emit a label for the new\n      code, and point the original insn at this new label. We can't use\n      redirect_jump here, because we're using fld[4] of the code labels as\n-     LABEL_REF chains, no NUSES counters. */\n+     LABEL_REF chains, no NUSES counters.  */\n \n   new_jump = emit_jump_insn_before (gen_jump (label), label);\n   record_label_references (new_jump, PATTERN (new_jump));\n@@ -2941,7 +2942,7 @@ goto_block_pat (insn, regstack, pat)\n   LABEL_REFS (new_label) = new_label;\n \n   /* The old label_ref will no longer point to the code_label if now uses,\n-     so strip the label_ref from the code_label's chain of references. */\n+     so strip the label_ref from the code_label's chain of references.  */\n \n   for (ref = &LABEL_REFS (label); *ref != label; ref = &LABEL_NEXTREF (*ref))\n     if (*ref == pat)\n@@ -2958,7 +2959,7 @@ goto_block_pat (insn, regstack, pat)\n   if (JUMP_LABEL (insn) == label)\n     JUMP_LABEL (insn) = new_label;\n \n-  /* Now emit the needed code. */\n+  /* Now emit the needed code.  */\n \n   temp_stack = *regstack;\n \n@@ -2967,7 +2968,7 @@ goto_block_pat (insn, regstack, pat)\n \f\n /* Traverse all basic blocks in a function, converting the register\n    references in each insn from the \"flat\" register file that gcc uses, to\n-   the stack-like registers the 387 uses. */\n+   the stack-like registers the 387 uses.  */\n \n static void\n convert_regs ()\n@@ -2992,7 +2993,7 @@ convert_regs ()\n \n       /* Process all insns in this block.  Keep track of `next' here,\n \t so that we don't process any insns emitted while making\n-\t substitutions in INSN. */\n+\t substitutions in INSN.  */\n \n       next = block_begin[block];\n       regstack = block_stack_in[block];\n@@ -3003,14 +3004,14 @@ convert_regs ()\n \n \t  /* Don't bother processing unless there is a stack reg\n \t     mentioned or if it's a CALL_INSN (register passing of\n-\t     floating point values). */\n+\t     floating point values).  */\n \n \t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n \t    subst_stack_regs (insn, &regstack);\n \n \t} while (insn != block_end[block]);\n \n-      /* Something failed if the stack life doesn't match. */\n+      /* Something failed if the stack life doesn't match.  */\n \n       GO_IF_HARD_REG_EQUAL (regstack.reg_set, block_out_reg_set[block], win);\n \n@@ -3021,12 +3022,12 @@ convert_regs ()\n       /* Adjust the stack of this block on exit to match the stack of\n \t the target block, or copy stack information into stack of\n \t jump target if the target block's stack order hasn't been set\n-\t yet. */\n+\t yet.  */\n \n       if (GET_CODE (insn) == JUMP_INSN)\n \tgoto_block_pat (insn, &regstack, PATTERN (insn));\n \n-      /* Likewise handle the case where we fall into the next block. */\n+      /* Likewise handle the case where we fall into the next block.  */\n \n       if ((block < blocks - 1) && block_drops_in[block+1])\n \tchange_stack (insn, &regstack, &block_stack_in[block+1],\n@@ -3035,7 +3036,7 @@ convert_regs ()\n \n   /* If the last basic block is the end of a loop, and that loop has\n      regs live at its start, then the last basic block will have regs live\n-     at its end that need to be popped before the function returns. */\n+     at its end that need to be popped before the function returns.  */\n \n    {\n      int value_reg_low, value_reg_high;\n@@ -3061,7 +3062,7 @@ convert_regs ()\n }\n \f\n /* Check expression PAT, which is in INSN, for label references.  if\n-   one is found, print the block number of destination to FILE. */\n+   one is found, print the block number of destination to FILE.  */\n \n static void\n print_blocks (file, insn, pat)"}, {"sha": "f56247228132e3c129a7f1e599147b5aba799f65", "filename": "gcc/regclass.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -834,7 +834,7 @@ regclass (f, nregs)\n \t\t\t      basic_block_head[b] = newinsn;\n \t\t\t}\n \n-\t\t      /* This makes one more setting of new insns's dest. */\n+\t\t      /* This makes one more setting of new insns's dest.  */\n \t\t      reg_n_sets[REGNO (recog_operand[0])]++;\n \n \t\t      *recog_operand_loc[1] = recog_operand[0];\n@@ -1841,7 +1841,7 @@ reg_scan_mark_refs (x, insn, note_flag)\n \t\t      || GET_CODE (XEXP (note, 0)) == LABEL_REF))))\n \tREGNO_POINTER_FLAG (REGNO (SET_DEST (x))) = 1;\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     default:\n       {"}, {"sha": "72116404d70e8d1afd54824dc5b9e4d6b2e66739", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -212,10 +212,10 @@ static int n_replacements;\n /* Used to track what is modified by an operand.  */\n struct decomposition\n {\n-  int reg_flag;\t\t/* Nonzero if referencing a register. */\n-  int safe;\t\t/* Nonzero if this can't conflict with anything. */\n-  rtx base;\t\t/* Base address for MEM. */\n-  HOST_WIDE_INT start;\t/* Starting offset or register number. */\n+  int reg_flag;\t\t/* Nonzero if referencing a register.  */\n+  int safe;\t\t/* Nonzero if this can't conflict with anything.  */\n+  rtx base;\t\t/* Base address for MEM.  */\n+  HOST_WIDE_INT start;\t/* Starting offset or register number.  */\n   HOST_WIDE_INT end;\t/* Ending offset or register number.  */\n };\n \n@@ -849,7 +849,7 @@ push_reload (in, out, inloc, outloc, class,\n      the class whose registers cannot be referenced in a different size\n      and M1 is not the same size as M2.  If SUBREG_WORD is nonzero, we\n      cannot reload just the inside since we might end up with the wrong\n-     register class. */\n+     register class.  */\n \n   if (in != 0 && GET_CODE (in) == SUBREG && SUBREG_WORD (in) == 0\n #ifdef CLASS_CANNOT_CHANGE_SIZE\n@@ -1579,7 +1579,7 @@ combine_reloads ()\n \treload_out[output_reload] = 0;\n \t/* The combined reload is needed for the entire insn.  */\n \treload_when_needed[i] = RELOAD_OTHER;\n-\t/* If the output reload had a secondary reload, copy it. */\n+\t/* If the output reload had a secondary reload, copy it.  */\n \tif (reload_secondary_out_reload[output_reload] != -1)\n \t  {\n \t    reload_secondary_out_reload[i]\n@@ -1594,7 +1594,7 @@ combine_reloads ()\n \t  secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]]\n \t    = secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]];\n #endif\n-\t/* If required, minimize the register class. */\n+\t/* If required, minimize the register class.  */\n \tif (reg_class_subset_p (reload_reg_class[output_reload],\n \t\t\t\treload_reg_class[i]))\n \t  reload_reg_class[i] = reload_reg_class[output_reload];\n@@ -3689,7 +3689,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   /* If we have a pair of reloads for parts of an address, they are reloading\n      the same object, the operands themselves were not reloaded, and they\n      are for two operands that are supposed to match, merge the reloads and\n-     change the type of the surviving reload to RELOAD_FOR_OPERAND_ADDRESS. */\n+     change the type of the surviving reload to RELOAD_FOR_OPERAND_ADDRESS.  */\n \n   for (i = 0; i < n_reloads; i++)\n     {\n@@ -3747,7 +3747,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      || reload_optional[operand_reloadnum[reload_opnum[i]]]))\n \t{\n \t  /* If we have a secondary reload to go along with this reload,\n-\t     change its type to RELOAD_FOR_OPADDR_ADDR. */\n+\t     change its type to RELOAD_FOR_OPADDR_ADDR.  */\n \n \t  if (reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n \t      && reload_secondary_in_reload[i] != -1)\n@@ -3757,7 +3757,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      reload_when_needed[secondary_in_reload] = \n \t\tRELOAD_FOR_OPADDR_ADDR;\n \n-\t      /* If there's a tertiary reload we have to change it also. */\n+\t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_in_reload > 0\n \t\t  && reload_secondary_in_reload[secondary_in_reload] != -1)\n \t\treload_when_needed[reload_secondary_in_reload[secondary_in_reload]] \n@@ -3772,7 +3772,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      reload_when_needed[secondary_out_reload] = \n \t\tRELOAD_FOR_OPADDR_ADDR;\n \n-\t      /* If there's a tertiary reload we have to change it also. */\n+\t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_out_reload\n \t\t  && reload_secondary_out_reload[secondary_out_reload] != -1)\n \t\treload_when_needed[reload_secondary_out_reload[secondary_out_reload]] \n@@ -5465,7 +5465,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n       if (p == 0 || GET_CODE (p) == CODE_LABEL)\n \treturn 0;\n       if (GET_CODE (p) == INSN\n-\t  /* If we don't want spill regs ... */\n+\t  /* If we don't want spill regs ...  */\n \t  && (! (reload_reg_p != 0\n \t\t && reload_reg_p != (short *) (HOST_WIDE_INT) 1)\n \t  /* ... then ignore insns introduced by reload; they aren't useful"}, {"sha": "d18244bf1e460bdda44340ffcbb80a46a2c21ec2", "filename": "gcc/reload1.c", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -79,7 +79,7 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \f\n /* During reload_as_needed, element N contains a REG rtx for the hard reg\n-   into which reg N has been reloaded (perhaps for a previous insn). */\n+   into which reg N has been reloaded (perhaps for a previous insn).  */\n static rtx *reg_last_reload_reg;\n \n /* Elt N nonzero if reg_last_reload_reg[N] has been set in this insn\n@@ -288,22 +288,22 @@ extern int *reg_allocno;\n \n static struct elim_table\n {\n-  int from;\t\t\t/* Register number to be eliminated. */\n-  int to;\t\t\t/* Register number used as replacement. */\n-  int initial_offset;\t\t/* Initial difference between values. */\n-  int can_eliminate;\t\t/* Non-zero if this elimination can be done. */\n+  int from;\t\t\t/* Register number to be eliminated.  */\n+  int to;\t\t\t/* Register number used as replacement.  */\n+  int initial_offset;\t\t/* Initial difference between values.  */\n+  int can_eliminate;\t\t/* Non-zero if this elimination can be done.  */\n   int can_eliminate_previous;\t/* Value of CAN_ELIMINATE in previous scan over\n-\t\t\t\t   insns made by reload. */\n-  int offset;\t\t\t/* Current offset between the two regs. */\n-  int max_offset;\t\t/* Maximum offset between the two regs. */\n-  int previous_offset;\t\t/* Offset at end of previous insn. */\n-  int ref_outside_mem;\t\t/* \"to\" has been referenced outside a MEM. */\n+\t\t\t\t   insns made by reload.  */\n+  int offset;\t\t\t/* Current offset between the two regs.  */\n+  int max_offset;\t\t/* Maximum offset between the two regs.  */\n+  int previous_offset;\t\t/* Offset at end of previous insn.  */\n+  int ref_outside_mem;\t\t/* \"to\" has been referenced outside a MEM.  */\n   rtx from_rtx;\t\t\t/* REG rtx for the register to be eliminated.\n \t\t\t\t   We cannot simply compare the number since\n \t\t\t\t   we might then spuriously replace a hard\n \t\t\t\t   register corresponding to a pseudo\n-\t\t\t\t   assigned to the reg to be eliminated. */\n-  rtx to_rtx;\t\t\t/* REG rtx for the replacement. */\n+\t\t\t\t   assigned to the reg to be eliminated.  */\n+  rtx to_rtx;\t\t\t/* REG rtx for the replacement.  */\n } reg_eliminate[] =\n \n /* If a set of eliminable registers was specified, define the table from it.\n@@ -429,7 +429,7 @@ init_reload ()\n \t}\n     }\n \n-  /* Initialize obstack for our rtl allocation. */\n+  /* Initialize obstack for our rtl allocation.  */\n   gcc_obstack_init (&reload_obstack);\n   reload_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n }\n@@ -1220,7 +1220,7 @@ reload (first, global, dumpfile)\n \t\t\t and operand addresses but not things used to reload\n \t\t\t them.  Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads\n \t\t\t don't conflict with things needed to reload inputs or\n-\t\t\t outputs. */\n+\t\t\t outputs.  */\n \n \t\t      in_max = MAX (MAX (insn_needs.op_addr.regs[j][i],\n \t\t\t\t\t insn_needs.op_addr_reload.regs[j][i]),\n@@ -1378,7 +1378,7 @@ reload (first, global, dumpfile)\n \t\t    }\n \n \t\t  /* Now count extra regs if there might be a conflict with\n-\t\t     the return value register. */\n+\t\t     the return value register.  */\n \n \t\t  for (r = regno; r < regno + nregs; r++)\n \t\t    if (spill_reg_order[r] >= 0)\n@@ -2495,7 +2495,7 @@ set_label_offsets (x, insn, initial_p)\n \n       x = XEXP (x, 0);\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case CODE_LABEL:\n       /* If we know nothing about this label, set the desired offsets.  Note\n@@ -2550,7 +2550,7 @@ set_label_offsets (x, insn, initial_p)\n     case JUMP_INSN:\n       set_label_offsets (PATTERN (insn), insn, initial_p);\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case INSN:\n     case CALL_INSN:\n@@ -2835,7 +2835,7 @@ eliminate_regs (x, mem_mode, insn)\n \t\t\t       ep->previous_offset * INTVAL (XEXP (x, 1)));\n \t    }\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case CALL:\n     case COMPARE:\n@@ -2867,7 +2867,7 @@ eliminate_regs (x, mem_mode, insn)\n \t    x = gen_rtx (EXPR_LIST, REG_NOTE_KIND (x), new, XEXP (x, 1));\n \t}\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case INSN_LIST:\n       /* Now do eliminations in the rest of the chain.  If this was\n@@ -3316,15 +3316,15 @@ eliminate_regs_in_insn (insn, replace)\n      If we are replacing a body that was a (set X (plus Y Z)), try to\n      re-recognize the insn.  We do this in case we had a simple addition\n      but now can do this as a load-address.  This saves an insn in this\n-     common case. */\n+     common case.  */\n \n   new_body = eliminate_regs (old_body, 0, replace ? insn : NULL_RTX);\n   if (new_body != old_body)\n     {\n       /* If we aren't replacing things permanently and we changed something,\n \t make another copy to ensure that all the RTL is new.  Otherwise\n \t things can go wrong if find_reload swaps commutative operands\n-\t and one is inside RTL that has been copied while the other is not. */\n+\t and one is inside RTL that has been copied while the other is not.  */\n \n       /* Don't copy an asm_operands because (1) there's no need and (2)\n \t copy_rtx can't do it properly when there are multiple outputs.  */\n@@ -4601,7 +4601,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n \t  return 0;\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case RELOAD_FOR_OPERAND_ADDRESS:\n       /* Check outputs and their addresses.  */\n@@ -4628,7 +4628,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \n       opnum = -1;\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case RELOAD_FOR_OUTPUT:\n     case RELOAD_FOR_OUTPUT_ADDRESS:\n@@ -4658,7 +4658,8 @@ reloads_conflict (r1, r2)\n   int r1_opnum = reload_opnum[r1];\n   int r2_opnum = reload_opnum[r2];\n \n-  /* RELOAD_OTHER conflicts with everything except RELOAD_FOR_OTHER_ADDRESS. */\n+  /* RELOAD_OTHER conflicts with everything except\n+     RELOAD_FOR_OTHER_ADDRESS.  */\n   \n   if (r2_type == RELOAD_OTHER && r1_type != RELOAD_FOR_OTHER_ADDRESS)\n     return 1;\n@@ -5241,7 +5242,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t\t\t\t   reload_when_needed[r]))\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n-\t\t\t registers still have their values intact. */\n+\t\t\t registers still have their values intact.  */\n \t\t      int nr\n \t\t\t= HARD_REGNO_NREGS (spill_regs[i], reload_mode[r]);\n \t\t      int k;\n@@ -5363,8 +5364,9 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t      break;\n \t\t    }\n \n-\t      /* JRV: If the equiv register we have found is explicitly\n-\t\t clobbered in the current insn, mark but don't use, as above. */\n+\t      /* JRV: If the equiv register we have found is\n+\t\t explicitly clobbered in the current insn, mark but\n+\t\t don't use, as above.  */\n \n \t      if (equiv != 0 && regno_clobbered_p (regno, insn))\n \t\t{\n@@ -5449,7 +5451,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t    continue;\n \n \t  /* Skip reloads that already have a register allocated or are\n-\t     optional. */\n+\t     optional.  */\n \t  if (reload_reg_rtx[r] != 0 || reload_optional[r])\n \t    continue;\n \n@@ -6838,7 +6840,7 @@ gen_reload (out, in, opnum, type)\n \t if the add instruction is two-address and the second operand\n \t of the add is the same as the reload reg, which is frequently\n \t the case.  If the insn would be A = B + A, rearrange it so\n-\t it will be A = A + B as constrain_operands expects. */\n+\t it will be A = A + B as constrain_operands expects.  */\n \n       if (GET_CODE (XEXP (in, 1)) == REG\n \t  && REGNO (out) == REGNO (XEXP (in, 1)))\n@@ -6888,7 +6890,7 @@ gen_reload (out, in, opnum, type)\n       insn = emit_insn (gen_add2_insn (out, op1));\n \n       /* If that failed, copy the address register to the reload register.\n-\t Then add the constant to the reload register. */\n+\t Then add the constant to the reload register.  */\n \n       code = recog_memoized (insn);\n "}, {"sha": "54ad9389aa0f4f8296a4364acdb35707e6aa87e3", "filename": "gcc/reorg.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -170,8 +170,8 @@ static rtx *unfilled_firstobj;\n struct resources\n {\n   char memory;\t\t\t/* Insn sets or needs a memory location.  */\n-  char unch_memory;\t\t/* Insn sets of needs a \"unchanging\" MEM. */\n-  char volatil;\t\t\t/* Insn sets or needs a volatile memory loc. */\n+  char unch_memory;\t\t/* Insn sets of needs a \"unchanging\" MEM.  */\n+  char volatil;\t\t\t/* Insn sets or needs a volatile memory loc.  */\n   char cc;\t\t\t/* Insn sets or needs the condition codes.  */\n   HARD_REG_SET regs;\t\t/* Which registers are set or needed.  */\n };\n@@ -395,7 +395,7 @@ mark_referenced_resources (x, res, include_delayed_effects)\n \t  rtx next = NEXT_INSN (x);\n \t  int i;\n \n-\t  /* If we are part of a delay slot sequence, point at the SEQUENCE. */\n+\t  /* If we are part of a delay slot sequence, point at the SEQUENCE.  */\n \t  if (NEXT_INSN (insn) != x)\n \t    {\n \t      next = NEXT_INSN (NEXT_INSN (insn));\n@@ -454,7 +454,7 @@ mark_referenced_resources (x, res, include_delayed_effects)\n \t  }\n \t}\n \n-      /* ... fall through to other INSN processing ... */\n+      /* ... fall through to other INSN processing ...  */\n \n     case INSN:\n     case JUMP_INSN:\n@@ -813,7 +813,7 @@ find_end_label ()\n       end_of_function_label = gen_label_rtx ();\n       LABEL_NUSES (end_of_function_label) = 0;\n \n-      /* Put the label before an USE insns that may proceed the RETURN insn. */\n+      /* Put the label before an USE insns that may proceed the RETURN insn.  */\n       while (GET_CODE (temp) == USE)\n \ttemp = PREV_INSN (temp);\n \n@@ -870,14 +870,14 @@ emit_delay_sequence (insn, list, length, avail)\n   register rtx li;\n   int had_barrier = 0;\n \n-  /* Allocate the the rtvec to hold the insns and the SEQUENCE. */\n+  /* Allocate the the rtvec to hold the insns and the SEQUENCE.  */\n   rtvec seqv = rtvec_alloc (length + 1);\n   rtx seq = gen_rtx (SEQUENCE, VOIDmode, seqv);\n   rtx seq_insn = make_insn_raw (seq);\n   rtx first = get_insns ();\n   rtx last = get_last_insn ();\n \n-  /* Make a copy of the insn having delay slots. */\n+  /* Make a copy of the insn having delay slots.  */\n   rtx delay_insn = copy_rtx (insn);\n \n   /* If INSN is followed by a BARRIER, delete the BARRIER since it will only\n@@ -1227,6 +1227,7 @@ optimize_skip (insn)\n \n     Non conditional branches return no direction information and\n     are predicted as very likely taken.  */\n+\n static int\n get_jump_flags (insn, label)\n      rtx insn, label;\n@@ -1382,7 +1383,7 @@ mostly_true_jump (jump_insn, condition)\n     }\n \n   /* Look at the relative rarities of the fallthrough and destination.  If\n-     they differ, we can predict the branch that way. */\n+     they differ, we can predict the branch that way.  */\n \n   switch (rare_fallthrough - rare_dest)\n     {"}, {"sha": "8c65d483b10419ef550d34dca9e6ea1ce34b9c86", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -278,7 +278,7 @@ copy_rtx (orig)\n     case PC:\n     case CC0:\n     case SCRATCH:\n-      /* SCRATCH must be shared because they represent distinct values. */\n+      /* SCRATCH must be shared because they represent distinct values.  */\n       return orig;\n \n     case CONST:"}, {"sha": "892b709186a11f13ec874c8485a0ed9903a053d0", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -47,16 +47,16 @@ enum rtx_code  {\n \t\t\t\t/* The cast here, saves many elsewhere.  */\n \n extern int rtx_length[];\n-#define GET_RTX_LENGTH(CODE)\t\t(rtx_length[(int)(CODE)])\n+#define GET_RTX_LENGTH(CODE)\t\t(rtx_length[(int) (CODE)])\n \n extern char *rtx_name[];\n-#define GET_RTX_NAME(CODE)\t\t(rtx_name[(int)(CODE)])\n+#define GET_RTX_NAME(CODE)\t\t(rtx_name[(int) (CODE)])\n \n extern char *rtx_format[];\n-#define GET_RTX_FORMAT(CODE)\t\t(rtx_format[(int)(CODE)])\n+#define GET_RTX_FORMAT(CODE)\t\t(rtx_format[(int) (CODE)])\n \n extern char rtx_class[];\n-#define GET_RTX_CLASS(CODE)\t\t(rtx_class[(int)(CODE)])\n+#define GET_RTX_CLASS(CODE)\t\t(rtx_class[(int) (CODE)])\n \f\n /* Common union for an element of an rtx.  */\n \n@@ -311,7 +311,7 @@ enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n /* Names for REG_NOTE's in EXPR_LIST insn's.  */\n \n extern char *reg_note_name[];\n-#define GET_REG_NOTE_NAME(MODE) (reg_note_name[(int)(MODE)])\n+#define GET_REG_NOTE_NAME(MODE) (reg_note_name[(int) (MODE)])\n \n /* This field is only present on CALL_INSNs.  It holds a chain of EXPR_LIST of\n    USE and CLOBBER expressions.\n@@ -709,7 +709,7 @@ extern int get_pool_offset\t\tPROTO((rtx));\n extern rtx simplify_subtraction\t\tPROTO((rtx));\n extern rtx assign_stack_local\t\tPROTO((enum machine_mode, int, int));\n extern rtx assign_stack_temp\t\tPROTO((enum machine_mode, int, int));\n-extern rtx assign_temp\t\t\tPROTO((union tree_node*, int,\n+extern rtx assign_temp\t\t\tPROTO((union tree_node *, int,\n \t\t\t\t\t       int, int));\n extern rtx protect_from_queue\t\tPROTO((rtx, int));\n extern void emit_queue\t\t\tPROTO((void));"}, {"sha": "3e6b4aea45b1d6e7dc37e27eb44c49c5d6d18110", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -393,7 +393,7 @@ reg_referenced_p (x, body)\n \n /* Nonzero if register REG is referenced in an insn between\n    FROM_INSN and TO_INSN (exclusive of those two).  Sets of REG do\n-   not count. */\n+   not count.  */\n \n int\n reg_referenced_between_p (reg, from_insn, to_insn)"}, {"sha": "253f3fc22b3615d55e4a357c8e6e9aa6d82ccdb2", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -78,13 +78,13 @@ int\n scan_decls (pfile, argc, argv)\n      cpp_reader *pfile;\n      int argc;\n-     char**argv;\n+     char **argv;\n {\n   int saw_extern, saw_inline;\n   int old_written;\n   /* If declarator_start is non-zero, it marks the start of the current\n      declarator.  If it is zero, we are either still parsing the\n-     decl-specs, or prev_id_start marks the start of the declarator. */\n+     decl-specs, or prev_id_start marks the start of the declarator.  */\n   int declarator_start;\n   int prev_id_start, prev_id_end;\n   enum cpp_token token;\n@@ -128,7 +128,7 @@ scan_decls (pfile, argc, argv)\n       switch (token)\n \t{\n \tcase CPP_LPAREN:\n-\t  /* Looks like this is the start of a formal parameter list. */\n+\t  /* Looks like this is the start of a formal parameter list.  */\n \t  if (prev_id_start)\n \t    {\n \t      int nesting = 1;\n@@ -187,7 +187,7 @@ scan_decls (pfile, argc, argv)\n \t\t\t\t pfile->token_buffer,\n \t\t\t\t prev_id_start);\n \t    }\n-\t  /* ... fall through ... */\n+\t  /* ... fall through ...  */\n \tmaybe_handle_comma:\n \t  if (token != CPP_COMMA)\n \t    goto new_statement;\n@@ -228,7 +228,7 @@ scan_decls (pfile, argc, argv)\n \t\tgoto handle_token;\n \t      break;\n \t    }\n-\t  /* This may be the name of a variable or function. */\n+\t  /* This may be the name of a variable or function.  */\n \t  prev_id_start = start_written;\n \t  prev_id_end = CPP_WRITTEN (pfile);\n \t  break;\n@@ -240,7 +240,7 @@ scan_decls (pfile, argc, argv)\n \t  goto new_statement;  /* handle_statement? */\n \t  \n \tcase CPP_HSPACE:  case CPP_VSPACE:  case CPP_COMMENT:  case CPP_POP:\n-\t  /* Skip initial white space. */\n+\t  /* Skip initial white space.  */\n \t  if (start_written == 0)\n \t    CPP_SET_WRITTEN (pfile, 0);\n \t  break;"}, {"sha": "4f575b38a9fe8d135f732be787cdb3e0e340ee24", "filename": "gcc/scan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fscan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fscan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -111,7 +111,7 @@ scan_string (fp, s, init)\n   return c;\n }\n \n-/* Skip horizontal white spaces (spaces, tabs, and C-style comments). */\n+/* Skip horizontal white spaces (spaces, tabs, and C-style comments).  */\n \n int\n skip_spaces (fp, c)"}, {"sha": "929a1ef5fee34f6ef6990afb4a2878ab526d4a86", "filename": "gcc/scan.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fscan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fscan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -51,22 +51,22 @@ struct fn_decl\n };\n \n extern int lineno;\n-extern void sstring_append _PARAMS((sstring*, sstring*));\n-extern void make_sstring_space _PARAMS((sstring*, int));\n-extern int skip_spaces _PARAMS((FILE*, int));\n+extern void sstring_append _PARAMS((sstring *, sstring *));\n+extern void make_sstring_space _PARAMS((sstring *, int));\n+extern int skip_spaces _PARAMS((FILE *, int));\n extern int scan_ident _PARAMS((FILE *, sstring *, int));\n-extern int scan_string _PARAMS((FILE*, sstring *, int));\n-extern int read_upto _PARAMS((FILE*, sstring*, int));\n+extern int scan_string _PARAMS((FILE *, sstring *, int));\n+extern int read_upto _PARAMS((FILE *, sstring *, int));\n extern char *xmalloc _PARAMS((unsigned));\n extern char *xrealloc _PARAMS((char *, unsigned));\n-extern unsigned long hash _PARAMS((const char*));\n+extern unsigned long hash _PARAMS((const char *));\n \n /* get_token is a simple C lexer. */\n #define IDENTIFIER_TOKEN 300\n #define CHAR_TOKEN 301\n #define STRING_TOKEN 302\n #define INT_TOKEN 303\n-extern int get_token _PARAMS ((FILE*, sstring*));\n+extern int get_token _PARAMS ((FILE *, sstring *));\n \n /* Current file and line numer, taking #-directives into account */\n extern int source_lineno;"}, {"sha": "aea307f8eff2f5e3f29e7a3e115c149694508449", "filename": "gcc/sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -355,7 +355,7 @@ static rtx *reg_known_value;\n /* Vector recording for each reg_known_value whether it is due to a\n    REG_EQUIV note.  Future passes (viz., reload) may replace the\n    pseudo with the equivalent expression and so we account for the\n-   dependences that would be introduced if that happens. */\n+   dependences that would be introduced if that happens.  */\n /* ??? This is a problem only on the Convex.  The REG_EQUIV notes created in\n    assign_parms mention the arg pointer, and there are explicit insns in the\n    RTL that modify the arg pointer.  Thus we must ensure that such insns don't\n@@ -4058,7 +4058,7 @@ schedule_block (b, file)\n \t    prev = PREV_INSN (insn);\n \t    if (LINE_NOTE (note))\n \t      {\n-\t\t/* Re-use the original line-number note. */\n+\t\t/* Re-use the original line-number note.  */\n \t\tLINE_NOTE (note) = 0;\n \t\tPREV_INSN (note) = prev;\n \t\tNEXT_INSN (prev) = note;"}, {"sha": "be72faf0b04731de4abb570aeea918fd1131fd43", "filename": "gcc/sdbout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -572,8 +572,8 @@ plain_type_1 (type, level)\n \t       only if the .def has already been finished.\n \t       At least on 386, the Unix assembler\n \t       cannot handle forward references to tags.  */\n-\t    /* But the 88100, it requires them, sigh... */\n-\t    /* And the MIPS requires unknown refs as well... */\n+\t    /* But the 88100, it requires them, sigh...  */\n+\t    /* And the MIPS requires unknown refs as well...  */\n \t    tag = KNOWN_TYPE_TAG (type);\n \t    PUT_SDB_TAG (tag);\n \t    /* These 3 lines used to follow the close brace.\n@@ -947,7 +947,7 @@ sdbout_toplevel_data (decl)\n \f\n #ifdef SDB_ALLOW_FORWARD_REFERENCES\n \n-/* Machinery to record and output anonymous types. */\n+/* Machinery to record and output anonymous types.  */\n \n static tree anonymous_types;\n "}, {"sha": "6d6443f43ef148284c9e3272d02762c97fbc3a2a", "filename": "gcc/stmt.c", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -222,7 +222,7 @@ struct nesting\n \t     and no `else' has been seen yet.  */\n \t  rtx endif_label;\n \t  /* Label for the end of this alternative.\n-\t     This may be the end of the if or the next else/elseif. */\n+\t     This may be the end of the if or the next else/elseif.  */\n \t  rtx next_label;\n \t} cond;\n       /* For loops.  */\n@@ -246,7 +246,7 @@ struct nesting\n \t     in order of entry.  */\n \t  int block_start_count;\n \t  /* Nonzero => value to restore stack to on exit.  Complemented by\n-\t     bc_stack_level (see below) when generating bytecodes. */\n+\t     bc_stack_level (see below) when generating bytecodes.  */\n \t  rtx stack_level;\n \t  /* The NOTE that starts this contour.\n \t     Used by expand_goto to check whether the destination\n@@ -285,7 +285,7 @@ struct nesting\n \t  rtx start;\n \t  /* For bytecodes, the case table is in-lined right in the code.\n \t     A label is needed for skipping over this block. It is only\n-\t     used when generating bytecodes. */\n+\t     used when generating bytecodes.  */\n \t  rtx skip_label;\n \t  /* A list of case labels; it is first built as an AVL tree.\n \t     During expand_end_case, this is converted to a list, and may be\n@@ -773,7 +773,7 @@ expand_goto_internal (body, label, last_insn)\n   /* NOTICE!  If a bytecode instruction other than `jump' is needed,\n      then the caller has to call bc_expand_goto_internal()\n      directly. This is rather an exceptional case, and there aren't\n-     that many places where this is necessary. */\n+     that many places where this is necessary.  */\n   if (output_bytecode)\n     {\n       expand_goto_internal (body, label, last_insn);\n@@ -808,8 +808,9 @@ expand_goto_internal (body, label, last_insn)\n \n       if (stack_level)\n \t{\n-\t  /* Ensure stack adjust isn't done by emit_jump, as this would clobber\n-\t     the stack pointer.  This one should be deleted as dead by flow. */\n+\t  /* Ensure stack adjust isn't done by emit_jump, as this\n+\t     would clobber the stack pointer.  This one should be\n+\t     deleted as dead by flow.  */\n \t  clear_pending_stack_adjust ();\n \t  do_pending_stack_adjust ();\n \t  emit_stack_restore (SAVE_BLOCK, stack_level, NULL_RTX);\n@@ -833,7 +834,7 @@ expand_goto_internal (body, label, last_insn)\n }\n \f\n /* Generate a jump with OPCODE to the given bytecode LABEL which is\n-   found within BODY. */\n+   found within BODY.  */\n \n static void\n bc_expand_goto_internal (opcode, label, body)\n@@ -846,7 +847,7 @@ bc_expand_goto_internal (opcode, label, body)\n \n   /* If the label is defined, adjust the stack as necessary.\n      If it's not defined, we have to push the reference on the\n-     fixup list. */\n+     fixup list.  */\n \n   if (label->defined)\n     {\n@@ -874,7 +875,7 @@ bc_expand_goto_internal (opcode, label, body)\n \t must do so after the jump, since the jump may depend on\n \t what's on the stack.  Thus, any stack-modifying conditional\n \t jumps (these are the only ones that rely on what's on the\n-\t stack) go into the fixup list. */\n+\t stack) go into the fixup list.  */\n \n       if (stack_level >= 0\n \t  && stack_depth != stack_level\n@@ -1212,7 +1213,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \n   /* For any still-undefined labels, do the cleanups for this block now.\n      We must do this now since items in the cleanup list may go out\n-     of scope when the block ends. */\n+     of scope when the block ends.  */\n   for (prev = 0, f = goto_fixup_chain; f; prev = f, f = f->next)\n     if (f->before_jump != 0\n \t&& PREV_INSN (f->target_rtl) == 0\n@@ -1299,7 +1300,7 @@ bc_fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n       bc_emit_bytecode_labeldef (f->label);\n \n       /* Save stack_depth across call, since bc_adjust_stack () will alter\n-         the perceived stack depth via the instructions generated. */\n+         the perceived stack depth via the instructions generated.  */\n \n       if (f->bc_stack_level >= 0)\n \t{\n@@ -1842,7 +1843,7 @@ warn_if_unused_value (exp)\n \t the user cannot control it.  */\n       if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == REFERENCE_TYPE)\n \treturn warn_if_unused_value (TREE_OPERAND (exp, 0));\n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n       \n     default:\n       /* Referencing a volatile value is a side effect, so don't warn.  */\n@@ -1920,7 +1921,7 @@ expand_end_stmt_expr (t)\n \t of adding code to inhibit dropping the last expression value, it\n \t is here recovered by undoing the `drop'.  Since `drop' is\n \t equivalent to `adjustackSI [1]', it can be undone with `adjstackSI\n-\t [-1]'. */\n+\t [-1]'.  */\n       \n       bc_adjust_stack (-1);\n       \n@@ -2040,7 +2041,7 @@ expand_start_else ()\n \n   emit_jump (cond_stack->data.cond.endif_label);\n   emit_label (cond_stack->data.cond.next_label);\n-  cond_stack->data.cond.next_label = 0;  /* No more _else or _elseif calls. */\n+  cond_stack->data.cond.next_label = 0;  /* No more _else or _elseif calls.  */\n }\n \n /* After calling expand_start_else, turn this \"else\" into an \"else if\"\n@@ -2081,7 +2082,7 @@ expand_end_cond ()\n /* Generate code for the start of an if-then.  COND is the expression\n    whose truth is to be tested; if EXITFLAG is nonzero this conditional\n    is to be visible to exit_something.  It is assumed that the caller\n-   has pushed the previous context on the cond stack. */\n+   has pushed the previous context on the cond stack.  */\n \n static void\n bc_expand_start_cond (cond, exitflag)\n@@ -2620,7 +2621,7 @@ expand_return (retval)\n   struct nesting *block;\n \n   /* Bytecode returns are quite simple, just leave the result on the\n-     arithmetic stack. */\n+     arithmetic stack.  */\n   if (output_bytecode)\n     {\n       bc_expand_expr (retval);\n@@ -3624,7 +3625,7 @@ expand_decl_init (decl)\n \n /* Expand initialization for variable-sized types. Allocate array\n    using newlocalSI and set local variable, which is a pointer to the\n-   storage. */\n+   storage.  */\n \n static void\n bc_expand_variable_local_init (decl)\n@@ -3648,7 +3649,7 @@ bc_expand_variable_local_init (decl)\n      using expand_address() since that would cause the pointer to be\n      pushed rather than its address. Hence the hard-coded reference;\n      notice also that the variable is always local (no global\n-     variable-size type variables). */\n+     variable-size type variables).  */\n \n   bc_load_localaddr (DECL_RTL (decl));\n   bc_emit_instruction (storeP);\n@@ -3673,7 +3674,7 @@ bc_expand_decl_init (decl)\n \n   /* If the type is variable-size, we first create its space (we ASSUME\n      it CAN'T be static).  We do this regardless of whether there's an\n-     initializer assignment or not. */\n+     initializer assignment or not.  */\n \n   if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n     bc_expand_variable_local_init (decl);\n@@ -3961,7 +3962,7 @@ expand_start_case (exit_flag, expr, type, printname)\n \n \n /* Enter a case statement. It is assumed that the caller has pushed\n-   the current context onto the case stack. */\n+   the current context onto the case stack.  */\n \n static void\n bc_expand_start_case (thiscase, expr, type, printname)\n@@ -4177,11 +4178,11 @@ pushcase_range (value1, value2, converter, label, duplicate)\n   case_stack->data.case_stmt.seenlabel = 1;\n \n   /* Convert VALUEs to type in which the comparisons are nominally done.  */\n-  if (value1 == 0)  /* Negative infinity. */\n+  if (value1 == 0)  /* Negative infinity.  */\n     value1 = TYPE_MIN_VALUE(index_type);\n   value1 = (*converter) (nominal_type, value1);\n \n-  if (value2 == 0)  /* Positive infinity. */\n+  if (value2 == 0)  /* Positive infinity.  */\n     value2 = TYPE_MAX_VALUE(index_type);\n   value2 = (*converter) (nominal_type, value2);\n \n@@ -4435,7 +4436,7 @@ add_case_node (low, high, label, duplicate)\n    2 and do nothing.  If VALUE is out of range, return 3 and do nothing.\n    Return 0 on success.  This function is a leftover from the earlier\n    bytecode compiler, which was based on gcc 1.37.  It should be\n-   merged into pushcase. */\n+   merged into pushcase.  */\n \n static int\n bc_pushcase (value, label)\n@@ -4519,7 +4520,7 @@ all_cases_count (type, spareness)\n \t  /* count\n \t     = TREE_INT_CST_LOW (TYPE_MAX_VALUE (type))\n \t     - TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) + 1\n-\t     but with overflow checking. */\n+\t     but with overflow checking.  */\n \t  tree mint = TYPE_MIN_VALUE (type);\n \t  tree maxt = TYPE_MAX_VALUE (type);\n \t  HOST_WIDE_INT lo, hi;\n@@ -4564,11 +4565,11 @@ all_cases_count (type, spareness)\n \n \n #define BITARRAY_TEST(ARRAY, INDEX) \\\n-  ((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\\\n-\t\t\t  & (1 << ((unsigned)(INDEX) % HOST_BITS_PER_CHAR)))\n+  ((ARRAY)[(unsigned) (INDEX) / HOST_BITS_PER_CHAR]\\\n+\t\t\t  & (1 << ((unsigned) (INDEX) % HOST_BITS_PER_CHAR)))\n #define BITARRAY_SET(ARRAY, INDEX) \\\n-  ((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\\\n-\t\t\t  |= 1 << ((unsigned)(INDEX) % HOST_BITS_PER_CHAR))\n+  ((ARRAY)[(unsigned) (INDEX) / HOST_BITS_PER_CHAR]\\\n+\t\t\t  |= 1 << ((unsigned) (INDEX) % HOST_BITS_PER_CHAR))\n \n /* Set the elements of the bitstring CASES_SEEN (which has length COUNT),\n    with the case values we have seen, assuming the case expression\n@@ -4718,17 +4719,17 @@ check_for_full_enumeration_handling (type)\n   register tree chain;\n   int all_values = 1;\n \n-  /* True iff the selector type is a numbered set mode. */\n+  /* True iff the selector type is a numbered set mode.  */\n   int sparseness = 0;\n \n-  /* The number of possible selector values. */\n+  /* The number of possible selector values.  */\n   HOST_WIDE_INT size;\n \n   /* For each possible selector value. a one iff it has been matched\n-     by a case value alternative. */\n+     by a case value alternative.  */\n   unsigned char *cases_seen;\n \n-  /* The allocated size of cases_seen, in chars. */\n+  /* The allocated size of cases_seen, in chars.  */\n   long bytes_needed;\n   tree t;\n \n@@ -4745,7 +4746,7 @@ check_for_full_enumeration_handling (type)\n   bytes_needed = (size + HOST_BITS_PER_CHAR) / HOST_BITS_PER_CHAR;\n \n   if (size > 0 && size < 600000\n-      /* We deliberately use malloc here - not xmalloc. */\n+      /* We deliberately use malloc here - not xmalloc.  */\n       && (cases_seen = (unsigned char *) malloc (bytes_needed)) != NULL)\n     {\n       long i;\n@@ -4755,7 +4756,7 @@ check_for_full_enumeration_handling (type)\n       /* The time complexity of this code is normally O(N), where\n \t N being the number of members in the enumerated type.\n \t However, if type is a ENUMERAL_TYPE whose values do not\n-\t increase monotonically, O(N*log(N)) time may be needed. */\n+\t increase monotonically, O(N*log(N)) time may be needed.  */\n \n       mark_seen_cases (type, cases_seen, size, sparseness);\n \n@@ -4772,7 +4773,7 @@ check_for_full_enumeration_handling (type)\n   /* Now we go the other way around; we warn if there are case\n      expressions that don't correspond to enumerators.  This can\n      occur since C and C++ don't enforce type-checking of\n-     assignments to enumeration variables. */\n+     assignments to enumeration variables.  */\n \n   if (case_stack->data.case_stmt.case_list\n       && case_stack->data.case_stmt.case_list->left)\n@@ -5402,7 +5403,7 @@ bc_expand_end_case (expr)\n }\n \n \n-/* Return unique bytecode ID. */\n+/* Return unique bytecode ID.  */\n \n int \n bc_new_uid ()\n@@ -5843,7 +5844,7 @@ emit_case_nodes (index, node, default_label, index_type)\n   else if (tree_int_cst_equal (node->low, node->high))\n     {\n       /* Node is single valued.  First see if the index expression matches\n-\t this node and then check our children, if any. */\n+\t this node and then check our children, if any.  */\n \n       do_jump_if_equal (index, expand_expr (node->low, NULL_RTX, VOIDmode, 0),\n \t\t\tlabel_rtx (node->code_label), unsignedp);"}, {"sha": "691cb5077b4a2397056e44fc686e7f91dd16f043", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -934,7 +934,7 @@ layout_type (type)\n       break;\n \n     /* Pascal and Chill types */\n-    case BOOLEAN_TYPE:\t\t /* store one byte/boolean for now. */\n+    case BOOLEAN_TYPE:\t\t /* store one byte/boolean for now.  */\n       TYPE_MODE (type) = QImode;\n       TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_PRECISION (type) = 1;"}, {"sha": "0f9b95545931ef9e69301bb4cda8d59b09141e82", "filename": "gcc/stupid.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -356,7 +356,7 @@ stupid_find_reg (call_preserved, class, mode,\n #endif\n \n   /* If this register's life is more than 5,000 insns, we probably\n-     can't allocate it, so don't waste the time trying.  This avoid\n+     can't allocate it, so don't waste the time trying.  This avoids\n      quadratic behavior on programs that have regularly-occurring\n      SAVE_EXPRs.  */\n   if (dead_insn > born_insn + 5000)"}, {"sha": "566569d86e71002cd64fafa8bcd514a2a1d11ab9", "filename": "gcc/sys-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fsys-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fsys-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsys-protos.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -1070,7 +1070,7 @@ extern int                    stime(const time_t *);\n extern struct netbuf *        stoa(char *, struct netbuf *);\n extern void                   store(datum, datum);\n extern char *                 strcadd(char *, const char *);\n-extern int                    strcasecmp(const char *, const char*);\n+extern int                    strcasecmp(const char *, const char *);\n extern char *                 strcat(char *, const char *);\n extern char *                 strccpy(char *, const char *);\n extern char *                 strchr(const char *, int);\n@@ -1088,7 +1088,7 @@ extern char *                 strerror(int);\n extern int                    strfind(const char *, const char *);\n extern size_t                 strftime(char *, size_t, const char *, const struct tm *);\n extern size_t                 strlen(const char *);\n-extern int                    strncasecmp(const char *, const char*, size_t);\n+extern int                    strncasecmp(const char *, const char *, size_t);\n extern char *                 strncat(char *, const char *, size_t);\n extern int                    strncmp(const char *, const char *, size_t);\n extern char *                 strncpy(char *, const char *, size_t);"}, {"sha": "a05ebd546d99da9fc53d0e2ff7da6393f275eee0", "filename": "gcc/toplev.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -424,7 +424,7 @@ int flag_no_peephole = 0;\n /* Nonzero allows GCC to violate some IEEE or ANSI rules regarding math\n    operations in the interest of optimization.  For example it allows\n    GCC to assume arguments to sqrt are nonnegative numbers, allowing\n-   faster code for sqrt to be generated. */\n+   faster code for sqrt to be generated.  */\n \n int flag_fast_math = 0;\n \n@@ -1067,9 +1067,9 @@ default_print_error_function (file)\n }\n \n /* Called by report_error_function to print out function name.\n- * Default may be overridden by language front-ends. */\n+ * Default may be overridden by language front-ends.  */\n \n-void (*print_error_function) PROTO((char*)) = default_print_error_function;\n+void (*print_error_function) PROTO((char *)) = default_print_error_function;\n \n /* Prints out, if necessary, the name of the current function\n   that caused an error.  Called from all error and warning functions.  */\n@@ -1932,6 +1932,7 @@ strip_off_ending (name, len)\n }\n \n /* Output a quoted string.  */\n+\n void\n output_quoted_string (asm_file, string)\n      FILE *asm_file;\n@@ -1980,7 +1981,8 @@ output_file_directive (asm_file, input_name)\n #endif\n }\n \f\n-/* Routine to build language identifier for object file. */\n+/* Routine to build language identifier for object file.  */\n+\n static void\n output_lang_identify (asm_out_file)\n      FILE *asm_out_file;\n@@ -1992,6 +1994,7 @@ output_lang_identify (asm_out_file)\n }\n \n /* Routine to open a dump file.  */\n+\n static FILE *\n open_dump_file (base_name, suffix)\n      char *base_name;\n@@ -2216,7 +2219,7 @@ compile_file (name)\n     }\n \n   /* Output something to inform GDB that this compilation was by GCC.  Also\n-     serves to tell GDB file consists of bytecodes. */\n+     serves to tell GDB file consists of bytecodes.  */\n   if (output_bytecode)\n     fprintf (asm_out_file, \"bc_gcc2_compiled.:\\n\");\n   else\n@@ -2228,7 +2231,7 @@ compile_file (name)\n #endif\n     }\n \n-  /* Output something to identify which front-end produced this file. */\n+  /* Output something to identify which front-end produced this file.  */\n #ifdef ASM_IDENTIFY_LANGUAGE\n   ASM_IDENTIFY_LANGUAGE (asm_out_file);\n #endif\n@@ -2387,7 +2390,7 @@ compile_file (name)\n \n \t       ??? A tempting alternative (for both C and C++) would be\n \t       to force a constant to be written if and only if it is\n-\t       defined in a main file, as opposed to an include file. */\n+\t       defined in a main file, as opposed to an include file.  */\n \n \t    if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl)\n \t\t&& (! TREE_READONLY (decl)\n@@ -2473,7 +2476,7 @@ compile_file (name)\n \t  TIMEVAR (symout_time, sdbout_symbol (decl, 0));\n \n \t/* Output COFF information for non-global\n-\t   file-scope initialized variables. */\n+\t   file-scope initialized variables.  */\n \tif (write_symbols == SDB_DEBUG\n \t    && TREE_CODE (decl) == VAR_DECL\n \t    && DECL_INITIAL (decl)\n@@ -3248,7 +3251,7 @@ rest_of_compilation (decl)\n #endif\n \n   /* If a scheduling pass for delayed branches is to be done,\n-     call the scheduling code. */\n+     call the scheduling code.  */\n \n #ifdef DELAY_SLOTS\n   if (optimize > 0 && flag_delayed_branch)\n@@ -3412,7 +3415,7 @@ main (argc, argv, envp)\n   {\n     struct rlimit rlim;\n \n-    /* Set the stack limit huge so that alloca does not fail. */\n+    /* Set the stack limit huge so that alloca does not fail.  */\n     getrlimit (RLIMIT_STACK, &rlim);\n     rlim.rlim_cur = rlim.rlim_max;\n     setrlimit (RLIMIT_STACK, &rlim);\n@@ -3927,7 +3930,7 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n     }\n \n   /* Initialize for bytecode output.  A good idea to do this as soon as\n-     possible after the \"-f\" options have been parsed. */\n+     possible after the \"-f\" options have been parsed.  */\n   if (output_bytecode)\n     {\n #ifndef TARGET_SUPPORTS_BYTECODE"}, {"sha": "9010a9745e0866ca894c014095f7fbb9fb40804e", "filename": "gcc/tree.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -753,7 +753,7 @@ print_obstack_name (object, file, prefix)\n       obstack_name = \"temp_decl_obstack\";\n     }\n \n-  /* Check to see if the object is in the free area of the obstack. */\n+  /* Check to see if the object is in the free area of the obstack.  */\n   if (obstack != NULL)\n     {\n       if (object >= obstack->next_free\n@@ -1170,7 +1170,7 @@ copy_node (node)\n \t the copy is different from the original type.\n \t The two statements usually duplicate each other\n \t (because they clear fields of the same union),\n-\t but the optimizer should catch that. */\n+\t but the optimizer should catch that.  */\n       TYPE_SYMTAB_POINTER (t) = 0;\n       TYPE_SYMTAB_ADDRESS (t) = 0;\n     }\n@@ -1228,9 +1228,9 @@ get_identifier (text)\n     hash_len = id_clash_len;\n \n   /* Compute hash code */\n-  hi = hash_len * 613 + (unsigned)text[0];\n+  hi = hash_len * 613 + (unsigned) text[0];\n   for (i = 1; i < hash_len; i += 2)\n-    hi = ((hi * 613) + (unsigned)(text[i]));\n+    hi = ((hi * 613) + (unsigned) (text[i]));\n \n   hi &= (1 << HASHBITS) - 1;\n   hi %= MAX_HASH_TABLE;\n@@ -1464,6 +1464,7 @@ build_complex (real, imag)\n }\n \n /* Build a newly constructed TREE_VEC node of length LEN.  */\n+\n tree\n make_tree_vec (len)\n      int len;\n@@ -1711,7 +1712,7 @@ binfo_member (elem, list)\n   return NULL_TREE;\n }\n \n-/* Return nonzero if ELEM is part of the chain CHAIN. */\n+/* Return nonzero if ELEM is part of the chain CHAIN.  */\n \n int\n chain_member (elem, chain)\n@@ -1728,7 +1729,7 @@ chain_member (elem, chain)\n }\n \n /* Return nonzero if ELEM is equal to TREE_VALUE (CHAIN) for any piece of\n-   chain CHAIN. */\n+   chain CHAIN.  */\n /* ??? This function was added for machine specific attributes but is no\n    longer used.  It could be deleted if we could confirm all front ends\n    don't use it.  */\n@@ -1748,7 +1749,7 @@ chain_member_value (elem, chain)\n }\n \n /* Return nonzero if ELEM is equal to TREE_PURPOSE (CHAIN)\n-   for any piece of chain CHAIN. */\n+   for any piece of chain CHAIN.  */\n /* ??? This function was added for machine specific attributes but is no\n    longer used.  It could be deleted if we could confirm all front ends\n    don't use it.  */\n@@ -2130,7 +2131,7 @@ save_expr (expr)\n      fact (i.e. this allows further folding, and direct checks for constants).\n      However, a read-only object that has side effects cannot be bypassed.\n      Since it is no problem to reevaluate literals, we just return the \n-     literal node. */\n+     literal node.  */\n \n   if (TREE_CONSTANT (t) || (TREE_READONLY (t) && ! TREE_SIDE_EFFECTS (t))\n       || TREE_CODE (t) == SAVE_EXPR || TREE_CODE (t) == ERROR_MARK)\n@@ -2160,6 +2161,7 @@ save_expr (expr)\n /* Arrange for an expression to be expanded multiple independent\n    times.  This is useful for cleanup actions, as the backend can\n    expand them multiple times in different places.  */\n+\n tree\n unsave_expr (expr)\n      tree expr;\n@@ -2177,6 +2179,7 @@ unsave_expr (expr)\n \n /* Modify a tree in place so that all the evaluate only once things\n    are cleared out.  Return the EXPR given.  */\n+\n tree\n unsave_expr_now (expr)\n      tree expr;\n@@ -2681,6 +2684,7 @@ build VPROTO((enum tree_code code, tree tt, ...))\n /* Same as above, but only builds for unary operators.\n    Saves lions share of calls to `build'; cuts down use\n    of varargs, which is expensive for RISC machines.  */\n+\n tree\n build1 (code, type, node)\n      enum tree_code code;\n@@ -2860,7 +2864,7 @@ build_block (vars, tags, subblocks, supercontext, chain)\n }\n \f\n /* Return a declaration like DDECL except that its DECL_MACHINE_ATTRIBUTE\n-   is ATTRIBUTE. */\n+   is ATTRIBUTE.  */\n \n tree\n build_decl_attribute_variant (ddecl, attribute)\n@@ -2930,7 +2934,7 @@ build_type_attribute_variant (ttype, attribute)\n \n /* Return a 1 if ATTR_NAME and ATTR_ARGS is valid for either declaration DECL\n    or type TYPE and 0 otherwise.  Validity is determined the configuration\n-   macros VALID_MACHINE_DECL_ATTRIBUTE and VALID_MACHINE_TYPE_ATTRIBUTE. */\n+   macros VALID_MACHINE_DECL_ATTRIBUTE and VALID_MACHINE_TYPE_ATTRIBUTE.  */\n \n int\n valid_machine_attribute (attr_name, attr_args, decl, type)\n@@ -3715,7 +3719,7 @@ build_index_type (maxval)\n /* Create a range of some discrete type TYPE (an INTEGER_TYPE,\n    ENUMERAL_TYPE, BOOLEAN_TYPE, or CHAR_TYPE), with\n    low bound LOWVAL and high bound HIGHVAL.\n-   if TYPE==NULL_TREE, sizetype is used. */\n+   if TYPE==NULL_TREE, sizetype is used.  */\n \n tree\n build_range_type (type, lowval, highval)\n@@ -3744,7 +3748,7 @@ build_range_type (type, lowval, highval)\n }\n \n /* Just like build_index_type, but takes lowval and highval instead\n-   of just highval (maxval). */\n+   of just highval (maxval).  */\n \n tree\n build_index_2_type (lowval,highval)\n@@ -4340,7 +4344,7 @@ dump_tree_statistics ()\n extern char * first_global_object_name;\n \n /* If KIND=='I', return a suitable global initializer (constructor) name.\n-   If KIND=='D', return a suitable global clean-up (destructor) name. */\n+   If KIND=='D', return a suitable global clean-up (destructor) name.  */\n \n tree\n get_file_function_name (kind)\n@@ -4377,7 +4381,7 @@ get_file_function_name (kind)\n #ifndef NO_DOLLAR_IN_LABEL\t/* this for `$'; unlikely, but... -- kr */\n \t       || *p == '$'\n #endif\n-#ifndef NO_DOT_IN_LABEL\t\t/* this for `.'; unlikely, but... */\n+#ifndef NO_DOT_IN_LABEL\t\t/* this for `.'; unlikely, but...  */\n \t       || *p == '.'\n #endif\n \t       || (*p >= 'A' && *p <= 'Z')\n@@ -4395,7 +4399,7 @@ get_file_function_name (kind)\n    with one bit in each char ('\\000' or '\\001').\n \n    If the constructor is constant, NULL_TREE is returned.\n-   Otherwise, a TREE_LIST of the non-constant elements is emitted. */\n+   Otherwise, a TREE_LIST of the non-constant elements is emitted.  */\n \n tree\n get_set_constructor_bits (init, buffer, bit_size)\n@@ -4421,7 +4425,7 @@ get_set_constructor_bits (init, buffer, bit_size)\n \t  tree_cons (TREE_PURPOSE (vals), TREE_VALUE (vals), non_const_bits);\n       else if (TREE_PURPOSE (vals) != NULL_TREE)\n \t{\n-\t  /* Set a range of bits to ones. */\n+\t  /* Set a range of bits to ones.  */\n \t  HOST_WIDE_INT lo_index\n \t    = TREE_INT_CST_LOW (TREE_PURPOSE (vals)) - domain_min;\n \t  HOST_WIDE_INT hi_index\n@@ -4434,7 +4438,7 @@ get_set_constructor_bits (init, buffer, bit_size)\n \t}\n       else\n \t{\n-\t  /* Set a single bit to one. */\n+\t  /* Set a single bit to one.  */\n \t  HOST_WIDE_INT index\n \t    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;\n \t  if (index < 0 || index >= bit_size)\n@@ -4451,7 +4455,7 @@ get_set_constructor_bits (init, buffer, bit_size)\n /* Expand (the constant part of) a SET_TYPE CONSTRUCTOR node.\n    The result is placed in BUFFER (which is an array of bytes).\n    If the constructor is constant, NULL_TREE is returned.\n-   Otherwise, a TREE_LIST of the non-constant elements is emitted. */\n+   Otherwise, a TREE_LIST of the non-constant elements is emitted.  */\n \n tree\n get_set_constructor_bytes (init, buffer, wd_size)\n@@ -4465,7 +4469,7 @@ get_set_constructor_bytes (init, buffer, wd_size)\n   int bit_size = wd_size * set_word_size;\n   int bit_pos = 0;\n   unsigned char *bytep = buffer;\n-  char *bit_buffer = (char*)alloca(bit_size);\n+  char *bit_buffer = (char *) alloca(bit_size);\n   tree non_const_bits = get_set_constructor_bits (init, bit_buffer, bit_size);\n \n   for (i = 0; i < wd_size; i++)"}, {"sha": "ad801f8b340237d2e308f00de81b8ea22b36128c", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -1634,9 +1634,9 @@ extern void (*incomplete_decl_finalize_hook) ();\n \f\n /* In tree.c */\n extern char *perm_calloc\t\t\tPROTO((int, long));\n-extern tree get_set_constructor_bits\t\tPROTO((tree, char*, int));\n+extern tree get_set_constructor_bits\t\tPROTO((tree, char *, int));\n extern tree get_set_constructor_bytes\t\tPROTO((tree,\n-\t\t\t\t\t\t       unsigned char*, int));\n+\t\t\t\t\t\t       unsigned char *, int));\n \f\n /* In stmt.c */\n "}, {"sha": "4470c5b82e1d537890d68e33b0654b00bd61e6af", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -3007,7 +3007,7 @@ reg_dead_after_loop (reg, loop_start, loop_end)\n \t      if (GET_CODE (PATTERN (insn)) == RETURN)\n \t\tbreak;\n \t      else if (! simplejump_p (insn)\n-\t\t       /* Prevent infinite loop following infinite loops. */\n+\t\t       /* Prevent infinite loop following infinite loops.  */\n \t\t       || jump_count++ > 20)\n \t\treturn 0;\n \t      else"}, {"sha": "3d8e766ef59ae185ee7def058eaed80472f6333f", "filename": "gcc/varasm.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f41302f4736dbb0fbf4690d6430ce581c5a9d80/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=0f41302f4736dbb0fbf4690d6430ce581c5a9d80", "patch": "@@ -224,15 +224,15 @@ readonly_data_section ()\n #endif\n }\n \n-/* Determine if we're in the text section. */\n+/* Determine if we're in the text section.  */\n \n int\n in_text_section ()\n {\n   return in_section == in_text;\n }\n \n-/* Determine if we're in the data section. */\n+/* Determine if we're in the data section.  */\n \n int\n in_data_section ()\n@@ -1563,7 +1563,7 @@ contains_pointers_p (type)\n     }\n }\n \n-/* Output text storage for constructor CONSTR. */\n+/* Output text storage for constructor CONSTR.  */\n \n void\n bc_output_constructor (constr, size)\n@@ -1573,7 +1573,7 @@ bc_output_constructor (constr, size)\n   int i;\n \n   /* Must always be a literal; non-literal constructors are handled\n-     differently. */\n+     differently.  */\n \n   if (!TREE_CONSTANT (constr))\n     abort ();\n@@ -1592,7 +1592,7 @@ bc_output_constructor (constr, size)\n   output_constant (constr, size);\n }\n \n-/* Create storage for constructor CONSTR. */\n+/* Create storage for constructor CONSTR.  */\n \n void\n bc_output_data_constructor (constr)\n@@ -1608,7 +1608,7 @@ bc_output_data_constructor (constr)\n   if (i > 0)\n     BC_OUTPUT_ALIGN (asm_out_file, i);\n \n-  /* The constructor is filled in at runtime. */\n+  /* The constructor is filled in at runtime.  */\n   BC_OUTPUT_SKIP (asm_out_file, int_size_in_bytes (TREE_TYPE (constr)));\n }\n \n@@ -1819,7 +1819,7 @@ assemble_integer (x, size, force)\n      int force;\n {\n   /* First try to use the standard 1, 2, 4, 8, and 16 byte\n-     ASM_OUTPUT... macros. */\n+     ASM_OUTPUT... macros.  */\n \n   switch (size)\n     {\n@@ -2329,7 +2329,7 @@ const_hash (exp)\n   else if (code == CONSTRUCTOR && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n     {\n       len = int_size_in_bytes (TREE_TYPE (exp));\n-      p = (char*) alloca (len);\n+      p = (char *) alloca (len);\n       get_set_constructor_bytes (exp, (unsigned char *) p, len);\n     }\n   else if (code == CONSTRUCTOR)\n@@ -2366,7 +2366,7 @@ const_hash (exp)\n \t  hi = value.offset;\n \t  p = XSTR (value.base, 0);\n \t  for (i = 0; p[i] != 0; i++)\n-\t    hi = ((hi * 613) + (unsigned)(p[i]));\n+\t    hi = ((hi * 613) + (unsigned) (p[i]));\n \t}\n       else if (GET_CODE (value.base) == LABEL_REF)\n \thi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;\n@@ -2384,7 +2384,7 @@ const_hash (exp)\n   /* Compute hashing function */\n   hi = len;\n   for (i = 0; i < len; i++)\n-    hi = ((hi * 613) + (unsigned)(p[i]));\n+    hi = ((hi * 613) + (unsigned) (p[i]));\n \n   hi &= (1 << HASHBITS) - 1;\n   hi %= MAX_HASH_TABLE;\n@@ -2460,7 +2460,7 @@ compare_constant_1 (exp, p)\n   else if (code == CONSTRUCTOR && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n     {\n       int xlen = len = int_size_in_bytes (TREE_TYPE (exp));\n-      strp = (char*) alloca (len);\n+      strp = (char *) alloca (len);\n       get_set_constructor_bytes (exp, (unsigned char *) strp, len);\n       if (bcmp ((char *) &xlen, p, sizeof xlen))\n \treturn 0;\n@@ -3113,7 +3113,7 @@ decode_rtx_const (mode, x, value)\n       *p++ = 0;\n   }\n \n-  value->kind = RTX_INT;\t/* Most usual kind. */\n+  value->kind = RTX_INT;\t/* Most usual kind.  */\n   value->mode = mode;\n \n   switch (GET_CODE (x))\n@@ -3342,7 +3342,7 @@ force_const_mem (mode, x)\n \t copy of X that is in the saveable obstack in case we are being\n \t called from combine or some other phase that discards memory\n \t it allocates.  We need only do this if it is a CONST, since\n-\t no other RTX should be allocated in this situation. */\n+\t no other RTX should be allocated in this situation.  */\n       if (rtl_obstack != saveable_obstack\n \t  && GET_CODE (x) == CONST)\n \t{\n@@ -3737,7 +3737,7 @@ output_constant (exp, size)\n     assemble_zeros (size);\n }\n \n-/* Bytecode specific code to output assembler for integer. */\n+/* Bytecode specific code to output assembler for integer.  */\n \n static void\n bc_assemble_integer (exp, size)\n@@ -4123,6 +4123,7 @@ output_constructor (exp, size)\n }\n \n /* Output asm to handle ``#pragma weak'' */\n+\n void\n handle_pragma_weak (what, name, value)\n      enum pragma_state what;\n@@ -4193,7 +4194,7 @@ assemble_alias (decl, target)\n #ifdef ASM_OUTPUT_DEF\n   char *name;\n \n-  make_decl_rtl (decl, (char*)0, 1);\n+  make_decl_rtl (decl, (char *) 0, 1);\n   name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n \n   /* Make name accessible from other files, if appropriate.  */"}]}