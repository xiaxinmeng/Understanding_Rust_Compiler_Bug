{"sha": "07eef8164aa7feb3aa60d5479894ea2d926643ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdlZWY4MTY0YWE3ZmViM2FhNjBkNTQ3OTg5NGVhMmQ5MjY2NDNjZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-10-08T03:33:46Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-10-08T03:33:46Z"}, "message": "re PR middle-end/23150 (20050713-1.c fails on arm-none-eabi with -O2 or -Os.)\n\n\tPR middle-end/23150\n\t* calls.c (mem_overlaps_already_clobbered_arg_p): New.\n\t(load_register_parameters): Call it.\n\t(check_sibcall_argument_overlap_1): Likewise.\n\t(store_one_arg): Likewise.\n\nFrom-SVN: r105114", "tree": {"sha": "5149051171e2a14191cc4236f39dee629b2c797b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5149051171e2a14191cc4236f39dee629b2c797b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07eef8164aa7feb3aa60d5479894ea2d926643ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07eef8164aa7feb3aa60d5479894ea2d926643ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07eef8164aa7feb3aa60d5479894ea2d926643ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07eef8164aa7feb3aa60d5479894ea2d926643ce/comments", "author": null, "committer": null, "parents": [{"sha": "3dbb4dcecd9a93e308c01ec61a725b9a3c9d2381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dbb4dcecd9a93e308c01ec61a725b9a3c9d2381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dbb4dcecd9a93e308c01ec61a725b9a3c9d2381"}], "stats": {"total": 115, "additions": 57, "deletions": 58}, "files": [{"sha": "6aeade95bb2200970ea9a4703b7cb47d5bed6e30", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07eef8164aa7feb3aa60d5479894ea2d926643ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07eef8164aa7feb3aa60d5479894ea2d926643ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07eef8164aa7feb3aa60d5479894ea2d926643ce", "patch": "@@ -1,3 +1,11 @@\n+2005-10-08  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR middle-end/23150\n+\t* calls.c (mem_overlaps_already_clobbered_arg_p): New.\n+\t(load_register_parameters): Call it.\n+\t(check_sibcall_argument_overlap_1): Likewise.\n+\t(store_one_arg): Likewise.\n+\n 2005-10-07  James E. Wilson  <wilson@specifix.com>\n \n \t* config/ia64/vect.md (ashl<mode>3, ashr<mode>3, lshr<mode>3): Use"}, {"sha": "7dbc21fe4153b60fac2757d689806da065fc05a1", "filename": "gcc/calls.c", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07eef8164aa7feb3aa60d5479894ea2d926643ce/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07eef8164aa7feb3aa60d5479894ea2d926643ce/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=07eef8164aa7feb3aa60d5479894ea2d926643ce", "patch": "@@ -1437,6 +1437,42 @@ rtx_for_function_call (tree fndecl, tree addr)\n   return funexp;\n }\n \n+/* Return true if and only if SIZE storage units (usually bytes)\n+   starting from address ADDR overlap with already clobbered argument\n+   area.  This function is used to determine if we should give up a\n+   sibcall.  */\n+\n+static bool\n+mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n+{\n+  HOST_WIDE_INT i;\n+\n+  if (addr == current_function_internal_arg_pointer)\n+    i = 0;\n+  else if (GET_CODE (addr) == PLUS\n+\t   && (XEXP (addr, 0)\n+\t       == current_function_internal_arg_pointer)\n+\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+    i = INTVAL (XEXP (addr, 1));\n+  else\n+    return false;\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  i = -i - size;\n+#endif\n+  if (size > 0)\n+    {\n+      unsigned HOST_WIDE_INT k;\n+\n+      for (k = 0; k < size; k++)\n+\tif (i + k < stored_args_map->n_bits\n+\t    && TEST_BIT (stored_args_map, i + k))\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Do the register loads required for any wholly-register parms or any\n    parms which are passed both on the stack and in a register.  Their\n    expressions were already evaluated.\n@@ -1534,6 +1570,12 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t    {\n \t      rtx mem = validize_mem (args[i].value);\n \n+\t      /* Check for overlap with already clobbered argument area.  */\n+\t      if (is_sibcall\n+\t\t  && mem_overlaps_already_clobbered_arg_p (XEXP (args[i].value, 0),\n+\t\t\t\t\t\t\t   size))\n+\t\t*sibcall_failure = 1;\n+\n \t      /* Handle a BLKmode that needs shifting.  */\n \t      if (nregs == 1 && size < UNITS_PER_WORD\n #ifdef BLOCK_REG_PADDING\n@@ -1647,7 +1689,6 @@ check_sibcall_argument_overlap_1 (rtx x)\n {\n   RTX_CODE code;\n   int i, j;\n-  unsigned int k;\n   const char *fmt;\n \n   if (x == NULL_RTX)\n@@ -1656,28 +1697,8 @@ check_sibcall_argument_overlap_1 (rtx x)\n   code = GET_CODE (x);\n \n   if (code == MEM)\n-    {\n-      if (XEXP (x, 0) == current_function_internal_arg_pointer)\n-\ti = 0;\n-      else if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t       && XEXP (XEXP (x, 0), 0) ==\n-\t\t  current_function_internal_arg_pointer\n-\t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n-\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n-      else\n-\treturn 0;\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-      i = -i - GET_MODE_SIZE (GET_MODE (x));\n-#endif\n-\n-      for (k = 0; k < GET_MODE_SIZE (GET_MODE (x)); k++)\n-\tif (i + k < stored_args_map->n_bits\n-\t    && TEST_BIT (stored_args_map, i + k))\n-\t  return 1;\n-\n-      return 0;\n-    }\n+    return mem_overlaps_already_clobbered_arg_p (XEXP (x, 0),\n+\t\t\t\t\t\t GET_MODE_SIZE (GET_MODE (x)));\n \n   /* Scan all subexpressions.  */\n   fmt = GET_RTX_FORMAT (code);\n@@ -4080,41 +4101,11 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n     }\n \n   /* Check for overlap with already clobbered argument area.  */\n-  if ((flags & ECF_SIBCALL) && MEM_P (arg->value))\n-    {\n-      int i = -1;\n-      unsigned HOST_WIDE_INT k;\n-      rtx x = arg->value;\n-\n-      if (XEXP (x, 0) == current_function_internal_arg_pointer)\n-\ti = 0;\n-      else if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t       && XEXP (XEXP (x, 0), 0) ==\n-\t\t  current_function_internal_arg_pointer\n-\t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n-\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n-      else\n-\ti = -1;\n-\n-      if (i >= 0)\n-\t{\n-#ifdef ARGS_GROW_DOWNWARD\n-\t  i = -i - arg->locate.size.constant;\n-#endif\n-\t  if (arg->locate.size.constant > 0)\n-\t    {\n-\t      unsigned HOST_WIDE_INT sc = arg->locate.size.constant;\n-\n-\t      for (k = 0; k < sc; k++)\n-\t\tif (i + k < stored_args_map->n_bits\n-\t\t    && TEST_BIT (stored_args_map, i + k))\n-\t\t  {\n-\t\t    sibcall_failure = 1;\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t}\n-    }\n+  if ((flags & ECF_SIBCALL)\n+      && MEM_P (arg->value)\n+      && mem_overlaps_already_clobbered_arg_p (XEXP (arg->value, 0),\n+\t\t\t\t\t       arg->locate.size.constant))\n+    sibcall_failure = 1;\n \n   /* Don't allow anything left on stack from computation\n      of argument to alloca.  */"}]}