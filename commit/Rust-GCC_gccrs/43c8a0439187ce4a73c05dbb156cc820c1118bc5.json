{"sha": "43c8a0439187ce4a73c05dbb156cc820c1118bc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNjOGEwNDM5MTg3Y2U0YTczYzA1ZGJiMTU2Y2M4MjBjMTExOGJjNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-11-07T00:22:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-07T00:22:18Z"}, "message": "gcse.c: Adjust outdated comments throughout.\n\n\t* gcse.c: Adjust outdated comments throughout.\n\t(struct mem_conflict_info): New structure.\n\t(mems_conflict_for_gcse_p): Use it to communicate with caller.\n\t(load_killed_in_block_p): Pass it to note_stores.\n\t(hash_expr): Remove superfluous line break.\n\t(hash_scan_set): Rename PAT parameter into SET.\n\t(hash_scan_insn): Reorder cases.\n\t(canon_list_insert): Fix long line.\n\t(edge_list): Delete.\n\t(prune_expressions): Rename E local variable into EXPR.\n\t(compute_pre_data): Return struct edge_list * object.\n\t(pre_expr_reaches_here_p_work): Fix formatting.\n\t(process_insert_insn): Move around comment.\n\t(pre_edge_insert): Fix long line.\n\t(pre_insert_copies): Likewise.\n\t(gcse_emit_move_after): Swap SRC and DEST parameters.\n\t(pre_delete): Adjust call to gcse_emit_move_after.\n\t(pre_gcse): Take struct edge_list * parameter.  Fix long line.\n\t(one_pre_gcse_pass): Use flag_gcse_lm condition for all routines.\n\tUse a local list of edges.\n\t(hoist_code): Fix long line.  Adjust call to gcse_emit_move_after.\n\t(pre_ldst_expr_hash): Fix long line.\n\t(free_ldst_mems): Rename into...\n\t(free_ld_motion_mems): ...this.\n\t(first_ls_expr): Delete.\n\t(next_ls_expr): Likewise.\n\t(print_ldst_list): Do not use above two functions.\n\t(simple_mem): Adjust interface.\n\t(compute_ld_motion_mems): Fix formatting.\n\t(update_ld_motion_stores): Reuse local variable.\n\nFrom-SVN: r181054", "tree": {"sha": "923f52516c0c4bc924fb27ca5a3b6d66307b0c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/923f52516c0c4bc924fb27ca5a3b6d66307b0c12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43c8a0439187ce4a73c05dbb156cc820c1118bc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c8a0439187ce4a73c05dbb156cc820c1118bc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43c8a0439187ce4a73c05dbb156cc820c1118bc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c8a0439187ce4a73c05dbb156cc820c1118bc5/comments", "author": null, "committer": null, "parents": [{"sha": "c8772697e1cc765dbf1a063016dbf6b2872d82e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8772697e1cc765dbf1a063016dbf6b2872d82e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8772697e1cc765dbf1a063016dbf6b2872d82e7"}], "stats": {"total": 294, "additions": 146, "deletions": 148}, "files": [{"sha": "9356d2509c105fa051d08308668b17bc2f5fc7f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c8a0439187ce4a73c05dbb156cc820c1118bc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c8a0439187ce4a73c05dbb156cc820c1118bc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43c8a0439187ce4a73c05dbb156cc820c1118bc5", "patch": "@@ -1,3 +1,36 @@\n+2011-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcse.c: Adjust outdated comments throughout.\n+\t(struct mem_conflict_info): New structure.\n+\t(mems_conflict_for_gcse_p): Use it to communicate with caller.\n+\t(load_killed_in_block_p): Pass it to note_stores.\n+\t(hash_expr): Remove superfluous line break.\n+\t(hash_scan_set): Rename PAT parameter into SET.\n+\t(hash_scan_insn): Reorder cases.\n+\t(canon_list_insert): Fix long line.\n+\t(edge_list): Delete.\n+\t(prune_expressions): Rename E local variable into EXPR.\n+\t(compute_pre_data): Return struct edge_list * object.\n+\t(pre_expr_reaches_here_p_work): Fix formatting.\n+\t(process_insert_insn): Move around comment.\n+\t(pre_edge_insert): Fix long line.\n+\t(pre_insert_copies): Likewise.\n+\t(gcse_emit_move_after): Swap SRC and DEST parameters.\n+\t(pre_delete): Adjust call to gcse_emit_move_after.\n+\t(pre_gcse): Take struct edge_list * parameter.  Fix long line.\n+\t(one_pre_gcse_pass): Use flag_gcse_lm condition for all routines.\n+\tUse a local list of edges.\n+\t(hoist_code): Fix long line.  Adjust call to gcse_emit_move_after.\n+\t(pre_ldst_expr_hash): Fix long line.\n+\t(free_ldst_mems): Rename into...\n+\t(free_ld_motion_mems): ...this.\n+\t(first_ls_expr): Delete.\n+\t(next_ls_expr): Likewise.\n+\t(print_ldst_list): Do not use above two functions.\n+\t(simple_mem): Adjust interface.\n+\t(compute_ld_motion_mems): Fix formatting.\n+\t(update_ld_motion_stores): Reuse local variable.\n+\n 2011-11-06  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-decl.c (shadow_tag_warned, grokdeclarator): Handle _Alignas"}, {"sha": "4806753f4a7f327221cce1f6b6d303a7b783ffe7", "filename": "gcc/gcse.c", "status": "modified", "additions": 113, "deletions": 148, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c8a0439187ce4a73c05dbb156cc820c1118bc5/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c8a0439187ce4a73c05dbb156cc820c1118bc5/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=43c8a0439187ce4a73c05dbb156cc820c1118bc5", "patch": "@@ -23,10 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n    - do rough calc of how many regs are needed in each block, and a rough\n      calc of how many regs are available in each class and use that to\n      throttle back the code in cases where RTX_COST is minimal.\n-   - a store to the same address as a load does not kill the load if the\n-     source of the store is also the destination of the load.  Handling this\n-     allows more load motion, particularly out of loops.\n-\n */\n \n /* References searched while implementing this.\n@@ -267,7 +263,7 @@ struct reg_use {rtx reg_rtx; };\n \n struct expr\n {\n-  /* The expression (SET_SRC for expressions, PATTERN for assignments).  */\n+  /* The expression.  */\n   rtx expr;\n   /* Index in the available expression bitmaps.  */\n   int bitmap_index;\n@@ -346,14 +342,12 @@ static struct hash_table_d expr_hash_table;\n \n /* This is a list of expressions which are MEMs and will be used by load\n    or store motion.\n-   Load motion tracks MEMs which aren't killed by\n-   anything except itself. (i.e., loads and stores to a single location).\n+   Load motion tracks MEMs which aren't killed by anything except itself,\n+   i.e. loads and stores to a single location.\n    We can then allow movement of these MEM refs with a little special\n    allowance. (all stores copy the same value to the reaching reg used\n    for the loads).  This means all values used to store into memory must have\n-   no side effects so we can re-issue the setter value.\n-   Store Motion uses this structure as an expression table to track stores\n-   which look interesting, and might be moveable towards the exit block.  */\n+   no side effects so we can re-issue the setter value.  */\n \n struct ls_expr\n {\n@@ -454,14 +448,14 @@ static int load_killed_in_block_p (const_basic_block, int, const_rtx, int);\n static void canon_list_insert (rtx, const_rtx, void *);\n static void alloc_pre_mem (int, int);\n static void free_pre_mem (void);\n-static void compute_pre_data (void);\n+static struct edge_list *compute_pre_data (void);\n static int pre_expr_reaches_here_p (basic_block, struct expr *,\n \t\t\t\t    basic_block);\n static void insert_insn_end_basic_block (struct expr *, basic_block);\n static void pre_insert_copy_insn (struct expr *, rtx);\n static void pre_insert_copies (void);\n static int pre_delete (void);\n-static int pre_gcse (void);\n+static int pre_gcse (struct edge_list *);\n static int one_pre_gcse_pass (void);\n static void add_label_notes (rtx, rtx);\n static void alloc_code_hoist_mem (int, int);\n@@ -478,11 +472,9 @@ static int pre_expr_reaches_here_p_work (basic_block, struct expr *,\n \t\t\t\t\t basic_block, char *);\n static struct ls_expr * ldst_entry (rtx);\n static void free_ldst_entry (struct ls_expr *);\n-static void free_ldst_mems (void);\n+static void free_ld_motion_mems (void);\n static void print_ldst_list (FILE *);\n static struct ls_expr * find_rtx_in_ldst (rtx);\n-static inline struct ls_expr * first_ls_expr (void);\n-static inline struct ls_expr * next_ls_expr (struct ls_expr *);\n static int simple_mem (const_rtx);\n static void invalidate_any_buried_refs (rtx);\n static void compute_ld_motion_mems (void);\n@@ -555,7 +547,6 @@ can_copy_p (enum machine_mode mode)\n \n   return can_copy[mode] != 0;\n }\n-\n \f\n /* Cover function to xmalloc to record bytes allocated.  */\n \n@@ -714,7 +705,6 @@ struct reg_avail_info\n static struct reg_avail_info *reg_avail_info;\n static basic_block current_bb;\n \n-\n /* See whether X, the source of a set, is something we want to consider for\n    GCSE.  */\n \n@@ -935,25 +925,29 @@ oprs_unchanged_p (const_rtx x, const_rtx insn, int avail_p)\n   return 1;\n }\n \n-/* Used for communication between mems_conflict_for_gcse_p and\n-   load_killed_in_block_p.  Nonzero if mems_conflict_for_gcse_p finds a\n-   conflict between two memory references.  */\n-static int gcse_mems_conflict_p;\n+/* Info passed from load_killed_in_block_p to mems_conflict_for_gcse_p.  */\n \n-/* Used for communication between mems_conflict_for_gcse_p and\n-   load_killed_in_block_p.  A memory reference for a load instruction,\n-   mems_conflict_for_gcse_p will see if a memory store conflicts with\n-   this memory load.  */\n-static const_rtx gcse_mem_operand;\n+struct mem_conflict_info\n+{\n+  /* A memory reference for a load instruction, mems_conflict_for_gcse_p will\n+     see if a memory store conflicts with this memory load.  */\n+  const_rtx mem;\n \n-/* DEST is the output of an instruction.  If it is a memory reference, and\n-   possibly conflicts with the load found in gcse_mem_operand, then set\n-   gcse_mems_conflict_p to a nonzero value.  */\n+  /* True if mems_conflict_for_gcse_p finds a conflict between two memory\n+     references.  */\n+  bool conflict;\n+};\n+\n+/* DEST is the output of an instruction.  If it is a memory reference and\n+   possibly conflicts with the load found in DATA, then communicate this\n+   information back through DATA.  */\n \n static void\n mems_conflict_for_gcse_p (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n-\t\t\t  void *data ATTRIBUTE_UNUSED)\n+\t\t\t  void *data)\n {\n+  struct mem_conflict_info *mci = (struct mem_conflict_info *) data;\n+\n   while (GET_CODE (dest) == SUBREG\n \t || GET_CODE (dest) == ZERO_EXTRACT\n \t || GET_CODE (dest) == STRICT_LOW_PART)\n@@ -967,17 +961,15 @@ mems_conflict_for_gcse_p (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n \n   /* If we are setting a MEM in our list of specially recognized MEMs,\n      don't mark as killed this time.  */\n-\n-  if (expr_equiv_p (dest, gcse_mem_operand) && pre_ldst_mems != NULL)\n+  if (pre_ldst_mems != NULL && expr_equiv_p (dest, mci->mem))\n     {\n       if (!find_rtx_in_ldst (dest))\n-\tgcse_mems_conflict_p = 1;\n+\tmci->conflict = true;\n       return;\n     }\n \n-  if (true_dependence (dest, GET_MODE (dest), gcse_mem_operand,\n-\t\t       rtx_addr_varies_p))\n-    gcse_mems_conflict_p = 1;\n+  if (true_dependence (dest, GET_MODE (dest), mci->mem, rtx_addr_varies_p))\n+    mci->conflict = true;\n }\n \n /* Return nonzero if the expression in X (a memory reference) is killed\n@@ -989,7 +981,8 @@ mems_conflict_for_gcse_p (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n    AVAIL_P to 0.  */\n \n static int\n-load_killed_in_block_p (const_basic_block bb, int uid_limit, const_rtx x, int avail_p)\n+load_killed_in_block_p (const_basic_block bb, int uid_limit, const_rtx x,\n+\t\t\tint avail_p)\n {\n   VEC (rtx,heap) *list = modify_mem_list[bb->index];\n   rtx setter;\n@@ -1001,6 +994,8 @@ load_killed_in_block_p (const_basic_block bb, int uid_limit, const_rtx x, int av\n \n   FOR_EACH_VEC_ELT_REVERSE (rtx, list, ix, setter)\n     {\n+      struct mem_conflict_info mci;\n+\n       /* Ignore entries in the list that do not apply.  */\n       if ((avail_p\n \t   && DF_INSN_LUID (setter) < uid_limit)\n@@ -1015,14 +1010,11 @@ load_killed_in_block_p (const_basic_block bb, int uid_limit, const_rtx x, int av\n \treturn 1;\n \n       /* SETTER must be an INSN of some kind that sets memory.  Call\n-\t note_stores to examine each hunk of memory that is modified.\n-\n-\t The note_stores interface is pretty limited, so we have to\n-\t communicate via global variables.  Yuk.  */\n-      gcse_mem_operand = x;\n-      gcse_mems_conflict_p = 0;\n-      note_stores (PATTERN (setter), mems_conflict_for_gcse_p, NULL);\n-      if (gcse_mems_conflict_p)\n+\t note_stores to examine each hunk of memory that is modified.  */\n+      mci.mem = x;\n+      mci.conflict = false;\n+      note_stores (PATTERN (setter), mems_conflict_for_gcse_p, &mci);\n+      if (mci.conflict)\n \treturn 1;\n     }\n   return 0;\n@@ -1061,8 +1053,7 @@ hash_expr (const_rtx x, enum machine_mode mode, int *do_not_record_p,\n \n   *do_not_record_p = 0;\n \n-  hash = hash_rtx (x, mode, do_not_record_p,\n-\t\t   NULL,  /*have_reg_qty=*/false);\n+  hash = hash_rtx (x, mode, do_not_record_p, NULL, /*have_reg_qty=*/false);\n   return hash % hash_table_size;\n }\n \n@@ -1190,13 +1181,13 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n     }\n }\n \n-/* Scan pattern PAT of INSN and add an entry to the hash TABLE.  */\n+/* Scan SET present in INSN and add an entry to the hash TABLE.  */\n \n static void\n-hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n+hash_scan_set (rtx set, rtx insn, struct hash_table_d *table)\n {\n-  rtx src = SET_SRC (pat);\n-  rtx dest = SET_DEST (pat);\n+  rtx src = SET_SRC (set);\n+  rtx dest = SET_DEST (set);\n   rtx note;\n \n   if (GET_CODE (src) == CALL)\n@@ -1227,7 +1218,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t  && REG_NOTE_KIND (note) == REG_EQUAL\n \t  && !REG_P (src)\n \t  && want_to_gcse_p (XEXP (note, 0), NULL))\n-\tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n+\tsrc = XEXP (note, 0), set = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Only record sets of pseudo-regs in the hash table.  */\n       if (regno >= FIRST_PSEUDO_REGISTER\n@@ -1242,7 +1233,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t  /* Is SET_SRC something we want to gcse?  */\n \t  && want_to_gcse_p (src, &max_distance)\n \t  /* Don't CSE a nop.  */\n-\t  && ! set_noop_p (pat)\n+\t  && ! set_noop_p (set)\n \t  /* Don't GCSE if it has attached REG_EQUIV note.\n \t     At this point this only function parameters should have\n \t     REG_EQUIV notes and if the argument slot is used somewhere\n@@ -1286,7 +1277,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t   /* Is SET_DEST something we want to gcse?  */\n \t   && want_to_gcse_p (dest, &max_distance)\n \t   /* Don't CSE a nop.  */\n-\t   && ! set_noop_p (pat)\n+\t   && ! set_noop_p (set)\n \t   /* Don't GCSE if it has attached REG_EQUIV note.\n \t      At this point this only function parameters should have\n \t      REG_EQUIV notes and if the argument slot is used somewhere\n@@ -1325,16 +1316,7 @@ hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n   /* Currently nothing to do.  */\n }\n \n-/* Process INSN and add hash table entries as appropriate.\n-\n-   Only available expressions that set a single pseudo-reg are recorded.\n-\n-   Single sets in a PARALLEL could be handled, but it's an extra complication\n-   that isn't dealt with right now.  The trick is handling the CLOBBERs that\n-   are also in the PARALLEL.  Later.\n-\n-   If SET_P is nonzero, this is for the assignment hash table,\n-   otherwise it is for the expression hash table.  */\n+/* Process INSN and add hash table entries as appropriate.  */\n \n static void\n hash_scan_insn (rtx insn, struct hash_table_d *table)\n@@ -1347,6 +1329,13 @@ hash_scan_insn (rtx insn, struct hash_table_d *table)\n \n   if (GET_CODE (pat) == SET)\n     hash_scan_set (pat, insn, table);\n+\n+  else if (GET_CODE (pat) == CLOBBER)\n+    hash_scan_clobber (pat, insn, table);\n+\n+  else if (GET_CODE (pat) == CALL)\n+    hash_scan_call (pat, insn, table);\n+\n   else if (GET_CODE (pat) == PARALLEL)\n     for (i = 0; i < XVECLEN (pat, 0); i++)\n       {\n@@ -1359,13 +1348,10 @@ hash_scan_insn (rtx insn, struct hash_table_d *table)\n \telse if (GET_CODE (x) == CALL)\n \t  hash_scan_call (x, insn, table);\n       }\n-\n-  else if (GET_CODE (pat) == CLOBBER)\n-    hash_scan_clobber (pat, insn, table);\n-  else if (GET_CODE (pat) == CALL)\n-    hash_scan_call (pat, insn, table);\n }\n \n+/* Dump the hash table TABLE to file FILE under the name NAME.  */\n+\n static void\n dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n {\n@@ -1429,13 +1415,12 @@ record_last_reg_set_info (rtx insn, int regno)\n     }\n }\n \n-\n /* Record all of the canonicalized MEMs of record_last_mem_set_info's insn.\n    Note we store a pair of elements in the list, so they have to be\n    taken off pairwise.  */\n \n static void\n-canon_list_insert (rtx dest ATTRIBUTE_UNUSED, const_rtx unused1 ATTRIBUTE_UNUSED,\n+canon_list_insert (rtx dest ATTRIBUTE_UNUSED, const_rtx x ATTRIBUTE_UNUSED,\n \t\t   void * v_insn)\n {\n   rtx dest_addr, insn;\n@@ -1634,7 +1619,6 @@ free_modify_mem_tables (void)\n   modify_mem_list = 0;\n   canon_modify_mem_list = 0;\n }\n-\n \f\n /* For each block, compute whether X is transparent.  X is either an\n    expression or an assignment [though we don't care which, for this context\n@@ -1745,11 +1729,11 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap)\n \t  compute_transp (XVECEXP (x, i, j), indx, bmap);\n     }\n }\n-\n \f\n /* Compute PRE+LCM working variables.  */\n \n /* Local properties of expressions.  */\n+\n /* Nonzero for expressions that are transparent in the block.  */\n static sbitmap *transp;\n \n@@ -1772,9 +1756,6 @@ static sbitmap *pre_insert_map;\n /* Nonzero for expressions which should be deleted in a specific block.  */\n static sbitmap *pre_delete_map;\n \n-/* Contains the edge_list returned by pre_edge_lcm.  */\n-static struct edge_list *edge_list;\n-\n /* Allocate vars used for PRE analysis.  */\n \n static void\n@@ -1826,46 +1807,46 @@ static void\n prune_expressions (bool pre_p)\n {\n   sbitmap prune_exprs;\n+  struct expr *expr;\n   unsigned int ui;\n   basic_block bb;\n \n   prune_exprs = sbitmap_alloc (expr_hash_table.n_elems);\n   sbitmap_zero (prune_exprs);\n   for (ui = 0; ui < expr_hash_table.size; ui++)\n     {\n-      struct expr *e;\n-      for (e = expr_hash_table.table[ui]; e != NULL; e = e->next_same_hash)\n+      for (expr = expr_hash_table.table[ui]; expr; expr = expr->next_same_hash)\n \t{\n \t  /* Note potentially trapping expressions.  */\n-\t  if (may_trap_p (e->expr))\n+\t  if (may_trap_p (expr->expr))\n \t    {\n-\t      SET_BIT (prune_exprs, e->bitmap_index);\n+\t      SET_BIT (prune_exprs, expr->bitmap_index);\n \t      continue;\n \t    }\n \n-\t  if (!pre_p && MEM_P (e->expr))\n+\t  if (!pre_p && MEM_P (expr->expr))\n \t    /* Note memory references that can be clobbered by a call.\n \t       We do not split abnormal edges in hoisting, so would\n \t       a memory reference get hoisted along an abnormal edge,\n \t       it would be placed /before/ the call.  Therefore, only\n \t       constant memory references can be hoisted along abnormal\n \t       edges.  */\n \t    {\n-\t      if (GET_CODE (XEXP (e->expr, 0)) == SYMBOL_REF\n-\t\t  && CONSTANT_POOL_ADDRESS_P (XEXP (e->expr, 0)))\n+\t      if (GET_CODE (XEXP (expr->expr, 0)) == SYMBOL_REF\n+\t\t  && CONSTANT_POOL_ADDRESS_P (XEXP (expr->expr, 0)))\n \t\tcontinue;\n \n-\t      if (MEM_READONLY_P (e->expr)\n-\t\t  && !MEM_VOLATILE_P (e->expr)\n-\t\t  && MEM_NOTRAP_P (e->expr))\n+\t      if (MEM_READONLY_P (expr->expr)\n+\t\t  && !MEM_VOLATILE_P (expr->expr)\n+\t\t  && MEM_NOTRAP_P (expr->expr))\n \t\t/* Constant memory reference, e.g., a PIC address.  */\n \t\tcontinue;\n \n \t      /* ??? Optimally, we would use interprocedural alias\n \t\t analysis to determine if this mem is actually killed\n \t\t by this call.  */\n \n-\t      SET_BIT (prune_exprs, e->bitmap_index);\n+\t      SET_BIT (prune_exprs, expr->bitmap_index);\n \t    }\n \t}\n     }\n@@ -1976,9 +1957,10 @@ prune_insertions_deletions (int n_elems)\n \n /* Top level routine to do the dataflow analysis needed by PRE.  */\n \n-static void\n+static struct edge_list *\n compute_pre_data (void)\n {\n+  struct edge_list *edge_list;\n   basic_block bb;\n \n   compute_local_properties (transp, comp, antloc, &expr_hash_table);\n@@ -2004,6 +1986,8 @@ compute_pre_data (void)\n   ae_kill = NULL;\n \n   prune_insertions_deletions (expr_hash_table.n_elems);\n+\n+  return edge_list;\n }\n \f\n /* PRE utilities */\n@@ -2022,7 +2006,8 @@ compute_pre_data (void)\n    the closest such expression.  */\n \n static int\n-pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr, basic_block bb, char *visited)\n+pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr,\n+\t\t\t      basic_block bb, char *visited)\n {\n   edge pred;\n   edge_iterator ei;\n@@ -2079,15 +2064,13 @@ pre_expr_reaches_here_p (basic_block occr_bb, struct expr *expr, basic_block bb)\n   return rval;\n }\n \f\n-\n-/* Given an expr, generate RTL which we can insert at the end of a BB,\n-   or on an edge.  Set the block number of any insns generated to\n-   the value of BB.  */\n+/* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */\n \n static rtx\n process_insert_insn (struct expr *expr)\n {\n   rtx reg = expr->reaching_reg;\n+  /* Copy the expression to make sure we don't have any sharing issues.  */\n   rtx exp = copy_rtx (expr->expr);\n   rtx pat;\n \n@@ -2099,8 +2082,7 @@ process_insert_insn (struct expr *expr)\n     emit_move_insn (reg, exp);\n \n   /* Otherwise, make a new insn to compute this expression and make sure the\n-     insn will be recognized (this also adds any needed CLOBBERs).  Copy the\n-     expression to make sure we don't have any sharing issues.  */\n+     insn will be recognized (this also adds any needed CLOBBERs).  */\n   else\n     {\n       rtx insn = emit_insn (gen_rtx_SET (VOIDmode, reg, exp));\n@@ -2109,7 +2091,6 @@ process_insert_insn (struct expr *expr)\n \tgcc_unreachable ();\n     }\n \n-\n   pat = get_insns ();\n   end_sequence ();\n \n@@ -2254,7 +2235,9 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n \t{\n \t  SBITMAP_ELT_TYPE insert = pre_insert_map[e]->elms[i];\n \n-\t  for (j = indx; insert && j < (int) expr_hash_table.n_elems; j++, insert >>= 1)\n+\t  for (j = indx;\n+\t       insert && j < (int) expr_hash_table.n_elems;\n+\t       j++, insert >>= 1)\n \t    if ((insert & 1) != 0 && index_map[j]->reaching_reg != NULL_RTX)\n \t      {\n \t\tstruct expr *expr = index_map[j];\n@@ -2430,7 +2413,7 @@ pre_insert_copies (void)\n      Need to do some profiling.  */\n \n   for (i = 0; i < expr_hash_table.size; i++)\n-    for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n+    for (expr = expr_hash_table.table[i]; expr; expr = expr->next_same_hash)\n       {\n \t/* If the basic block isn't reachable, PPOUT will be TRUE.  However,\n \t   we don't want to insert a copy here because the expression may not\n@@ -2481,8 +2464,9 @@ pre_insert_copies (void)\n \n /* Emit move from SRC to DEST noting the equivalence with expression computed\n    in INSN.  */\n+\n static rtx\n-gcse_emit_move_after (rtx src, rtx dest, rtx insn)\n+gcse_emit_move_after (rtx dest, rtx src, rtx insn)\n {\n   rtx new_rtx;\n   rtx set = single_set (insn), set2;\n@@ -2513,7 +2497,7 @@ gcse_emit_move_after (rtx src, rtx dest, rtx insn)\n    the expression into the result of the SET.  It is left to later passes\n    (cprop, cse2, flow, combine, regmove) to propagate the copy or eliminate it.\n \n-   Returns nonzero if a change is made.  */\n+   Return nonzero if a change is made.  */\n \n static int\n pre_delete (void)\n@@ -2525,15 +2509,11 @@ pre_delete (void)\n \n   changed = 0;\n   for (i = 0; i < expr_hash_table.size; i++)\n-    for (expr = expr_hash_table.table[i];\n-\t expr != NULL;\n-\t expr = expr->next_same_hash)\n+    for (expr = expr_hash_table.table[i]; expr; expr = expr->next_same_hash)\n       {\n \tint indx = expr->bitmap_index;\n \n-\t/* We only need to search antic_occr since we require\n-\t   ANTLOC != 0.  */\n-\n+\t/* We only need to search antic_occr since we require ANTLOC != 0.  */\n \tfor (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n \t  {\n \t    rtx insn = occr->insn;\n@@ -2551,7 +2531,7 @@ pre_delete (void)\n \t\tif (expr->reaching_reg == NULL)\n \t\t  expr->reaching_reg = gen_reg_rtx_and_attrs (SET_DEST (set));\n \n-\t\tgcse_emit_move_after (expr->reaching_reg, SET_DEST (set), insn);\n+\t\tgcse_emit_move_after (SET_DEST (set), expr->reaching_reg, insn);\n \t\tdelete_insn (insn);\n \t\toccr->deleted_p = 1;\n \t\tchanged = 1;\n@@ -2593,7 +2573,7 @@ pre_delete (void)\n    redundancies.  */\n \n static int\n-pre_gcse (void)\n+pre_gcse (struct edge_list *edge_list)\n {\n   unsigned int i;\n   int did_insert, changed;\n@@ -2605,7 +2585,7 @@ pre_gcse (void)\n \n   index_map = XCNEWVEC (struct expr *, expr_hash_table.n_elems);\n   for (i = 0; i < expr_hash_table.size; i++)\n-    for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n+    for (expr = expr_hash_table.table[i]; expr; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n \n   /* Delete the redundant insns first so that\n@@ -2659,20 +2639,23 @@ one_pre_gcse_pass (void)\n     compute_ld_motion_mems ();\n \n   compute_hash_table (&expr_hash_table);\n-  trim_ld_motion_mems ();\n+  if (flag_gcse_lm)\n+    trim_ld_motion_mems ();\n   if (dump_file)\n     dump_hash_table (dump_file, \"Expression\", &expr_hash_table);\n \n   if (expr_hash_table.n_elems > 0)\n     {\n+      struct edge_list *edge_list;\n       alloc_pre_mem (last_basic_block, expr_hash_table.n_elems);\n-      compute_pre_data ();\n-      changed |= pre_gcse ();\n+      edge_list = compute_pre_data ();\n+      changed |= pre_gcse (edge_list);\n       free_edge_list (edge_list);\n       free_pre_mem ();\n     }\n \n-  free_ldst_mems ();\n+  if (flag_gcse_lm)\n+    free_ld_motion_mems ();\n   remove_fake_exit_edges ();\n   free_hash_table (&expr_hash_table);\n \n@@ -2924,6 +2907,7 @@ hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n }\n \f\n /* Find occurence in BB.  */\n+\n static struct occr *\n find_occr_in_bb (struct occr *occr, basic_block bb)\n {\n@@ -2955,7 +2939,7 @@ hoist_code (void)\n \n   index_map = XCNEWVEC (struct expr *, expr_hash_table.n_elems);\n   for (i = 0; i < expr_hash_table.size; i++)\n-    for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n+    for (expr = expr_hash_table.table[i]; expr; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n \n   /* Calculate sizes of basic blocks and note how far\n@@ -3145,7 +3129,7 @@ hoist_code (void)\n \t\t    expr->reaching_reg\n \t\t      = gen_reg_rtx_and_attrs (SET_DEST (set));\n \n-\t\t  gcse_emit_move_after (expr->reaching_reg, SET_DEST (set),\n+\t\t  gcse_emit_move_after (SET_DEST (set), expr->reaching_reg,\n \t\t\t\t\tinsn);\n \t\t  delete_insn (insn);\n \t\t  occr->deleted_p = 1;\n@@ -3233,9 +3217,9 @@ one_code_hoisting_pass (void)\n   return changed;\n }\n \f\n-/*  Here we provide the things required to do store motion towards\n-    the exit. In order for this to be effective, gcse also needed to\n-    be taught how to move a load when it is kill only by a store to itself.\n+/*  Here we provide the things required to do store motion towards the exit.\n+    In order for this to be effective, gcse also needed to be taught how to\n+    move a load when it is killed only by a store to itself.\n \n \t    int i;\n \t    float a[10];\n@@ -3251,7 +3235,7 @@ one_code_hoisting_pass (void)\n     of the loop.\n \n       The 'Load Motion' referred to and implemented in this file is\n-    an enhancement to gcse which when using edge based lcm, recognizes\n+    an enhancement to gcse which when using edge based LCM, recognizes\n     this situation and allows gcse to move the load out of the loop.\n \n       Once gcse has hoisted the load, store motion can then push this\n@@ -3263,7 +3247,8 @@ pre_ldst_expr_hash (const void *p)\n {\n   int do_not_record_p = 0;\n   const struct ls_expr *const x = (const struct ls_expr *) p;\n-  return hash_rtx (x->pattern, GET_MODE (x->pattern), &do_not_record_p, NULL, false);\n+  return\n+    hash_rtx (x->pattern, GET_MODE (x->pattern), &do_not_record_p, NULL, false);\n }\n \n static int\n@@ -3326,7 +3311,7 @@ free_ldst_entry (struct ls_expr * ptr)\n /* Free up all memory associated with the ldst list.  */\n \n static void\n-free_ldst_mems (void)\n+free_ld_motion_mems (void)\n {\n   if (pre_ldst_table)\n     htab_delete (pre_ldst_table);\n@@ -3353,7 +3338,7 @@ print_ldst_list (FILE * file)\n \n   fprintf (file, \"LDST list: \\n\");\n \n-  for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n+  for (ptr = pre_ldst_mems; ptr != NULL; ptr = ptr->next)\n     {\n       fprintf (file, \"  Pattern (%3d): \", ptr->index);\n \n@@ -3394,35 +3379,16 @@ find_rtx_in_ldst (rtx x)\n     return NULL;\n   return (struct ls_expr *) *slot;\n }\n-\n-/* Return first item in the list.  */\n-\n-static inline struct ls_expr *\n-first_ls_expr (void)\n-{\n-  return pre_ldst_mems;\n-}\n-\n-/* Return the next item in the list after the specified one.  */\n-\n-static inline struct ls_expr *\n-next_ls_expr (struct ls_expr * ptr)\n-{\n-  return ptr->next;\n-}\n \f\n /* Load Motion for loads which only kill themselves.  */\n \n-/* Return true if x is a simple MEM operation, with no registers or\n-   side effects. These are the types of loads we consider for the\n-   ld_motion list, otherwise we let the usual aliasing take care of it.  */\n+/* Return true if x, a MEM, is a simple access with no side effects.\n+   These are the types of loads we consider for the ld_motion list,\n+   otherwise we let the usual aliasing take care of it.  */\n \n static int\n simple_mem (const_rtx x)\n {\n-  if (! MEM_P (x))\n-    return 0;\n-\n   if (MEM_VOLATILE_P (x))\n     return 0;\n \n@@ -3499,8 +3465,8 @@ compute_ld_motion_mems (void)\n   rtx insn;\n \n   pre_ldst_mems = NULL;\n-  pre_ldst_table = htab_create (13, pre_ldst_expr_hash,\n-\t\t\t\tpre_ldst_expr_eq, NULL);\n+  pre_ldst_table\n+    = htab_create (13, pre_ldst_expr_hash, pre_ldst_expr_eq, NULL);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -3641,7 +3607,7 @@ update_ld_motion_stores (struct expr * expr)\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"PRE:  store updated with reaching reg \");\n-\t      print_rtl (dump_file, expr->reaching_reg);\n+\t      print_rtl (dump_file, reg);\n \t      fprintf (dump_file, \":\\n\t\");\n \t      print_inline_rtx (dump_file, insn, 8);\n \t      fprintf (dump_file, \"\\n\");\n@@ -3698,7 +3664,6 @@ is_too_expensive (const char *pass)\n \n   return false;\n }\n-\n \f\n /* All the passes implemented in this file.  Each pass has its\n    own gate and execute function, and at the end of the file a"}]}