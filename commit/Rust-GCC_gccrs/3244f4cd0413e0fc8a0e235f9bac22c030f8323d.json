{"sha": "3244f4cd0413e0fc8a0e235f9bac22c030f8323d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI0NGY0Y2QwNDEzZTBmYzhhMGUyMzVmOWJhYzIyYzAzMGY4MzIzZA==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-07-07T11:10:12Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-07-07T11:10:12Z"}, "message": "re PR fortran/66578 ([F2008] Invalid free on allocate(...,source=a(:)) in block)\n\ngcc/testsuite/ChangeLog:\n\n2015-07-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/66578\n\t* gfortran.dg/allocate_with_source_9.f08: New test.\n\n\ngcc/fortran/ChangeLog:\n\n2015-07-07  Mikael Morin  <mikael@gcc.gnu.org>\n\t    Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/66578\n\t* trans-array.c (gfc_conv_expr_descriptor): Ensure array descriptor\n\tis one-based for non-full array refs. Correct the offset when a\n\trank_remap occurs.\n\nFrom-SVN: r225507", "tree": {"sha": "0327748848b646295f057bfd409d185641444971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0327748848b646295f057bfd409d185641444971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3244f4cd0413e0fc8a0e235f9bac22c030f8323d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3244f4cd0413e0fc8a0e235f9bac22c030f8323d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3244f4cd0413e0fc8a0e235f9bac22c030f8323d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "970bb2de656b95612d485b735481160c446500d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/970bb2de656b95612d485b735481160c446500d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/970bb2de656b95612d485b735481160c446500d2"}], "stats": {"total": 95, "additions": 73, "deletions": 22}, "files": [{"sha": "75bce2f6e53e17962928965c4d19d3d271e3193f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3244f4cd0413e0fc8a0e235f9bac22c030f8323d", "patch": "@@ -1,3 +1,10 @@\n+2015-07-07  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/66578\n+\t* trans-array.c (gfc_conv_expr_descriptor): Ensure array descriptor\n+\tis one-based for non-full array refs. Correct the offset when a\n+\trank_remap occurs.\n+\n 2015-07-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* io.c (check_char_variable): New function."}, {"sha": "afea5eca7d0f971fdc344fb108a0e7d6cca77572", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=3244f4cd0413e0fc8a0e235f9bac22c030f8323d", "patch": "@@ -6912,9 +6912,10 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       tree from;\n       tree to;\n       tree base;\n-      bool onebased = false;\n+      bool onebased = false, rank_remap;\n \n       ndim = info->ref ? info->ref->u.ar.dimen : ss->dimen;\n+      rank_remap = ss->dimen < ndim;\n \n       if (se->want_coarray)\n \t{\n@@ -6947,6 +6948,22 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       if (expr->ts.type == BT_CHARACTER)\n \tse->string_length =  gfc_get_expr_charlen (expr);\n \n+      /* If we have an array section or are assigning make sure that\n+\t the lower bound is 1.  References to the full\n+\t array should otherwise keep the original bounds.  */\n+      if ((!info->ref || info->ref->u.ar.type != AR_FULL) && !se->want_pointer)\n+\tfor (dim = 0; dim < loop.dimen; dim++)\n+\t  if (!integer_onep (loop.from[dim]))\n+\t    {\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, gfc_index_one_node,\n+\t\t\t\t     loop.from[dim]);\n+\t      loop.to[dim] = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t      gfc_array_index_type,\n+\t\t\t\t\t      loop.to[dim], tmp);\n+\t      loop.from[dim] = gfc_index_one_node;\n+\t    }\n+\n       desc = info->descriptor;\n       if (se->direct_byref && !se->byref_noassign)\n \t{\n@@ -7040,20 +7057,6 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t  from = loop.from[dim];\n \t  to = loop.to[dim];\n \n-\t  /* If we have an array section or are assigning make sure that\n-\t     the lower bound is 1.  References to the full\n-\t     array should otherwise keep the original bounds.  */\n-\t  if ((!info->ref\n-\t          || info->ref->u.ar.type != AR_FULL)\n-\t      && !integer_onep (from))\n-\t    {\n-\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t     gfc_array_index_type, gfc_index_one_node,\n-\t\t\t\t     from);\n-\t      to = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t    gfc_array_index_type, to, tmp);\n-\t      from = gfc_index_one_node;\n-\t    }\n \t  onebased = integer_onep (from);\n \t  gfc_conv_descriptor_lbound_set (&loop.pre, parm,\n \t\t\t\t\t  gfc_rank_cst[dim], from);\n@@ -7079,7 +7082,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t    {\n \t      tmp = gfc_conv_array_lbound (desc, n);\n \t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t     TREE_TYPE (base), tmp, loop.from[dim]);\n+\t\t\t\t     TREE_TYPE (base), tmp, from);\n \t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t     TREE_TYPE (base), tmp,\n \t\t\t\t     gfc_conv_array_stride (desc, n));\n@@ -7114,7 +7117,19 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       /* Force the offset to be -1, when the lower bound of the highest\n \t dimension is one and the symbol is present and is not a\n \t pointer/allocatable or associated.  */\n-      if (onebased && se->use_offset\n+      if (((se->direct_byref || GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n+\t   && !se->data_not_needed)\n+\t  || (se->use_offset && base != NULL_TREE))\n+\t{\n+\t  /* Set the offset depending on base.  */\n+\t  tmp = rank_remap && !se->direct_byref ?\n+\t\tfold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, base,\n+\t\t\t\t offset)\n+\t      : base;\n+\t  gfc_conv_descriptor_offset_set (&loop.pre, parm, tmp);\n+\t}\n+      else if (onebased && (!rank_remap || se->use_offset)\n \t  && expr->symtree\n \t  && !(expr->symtree->n.sym && expr->symtree->n.sym->ts.type == BT_CLASS\n \t       && !CLASS_DATA (expr->symtree->n.sym)->attr.class_pointer)\n@@ -7129,11 +7144,6 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t  tmp = gfc_conv_mpz_to_tree (minus_one, gfc_index_integer_kind);\n \t  gfc_conv_descriptor_offset_set (&loop.pre, parm, tmp);\n \t}\n-      else if (((se->direct_byref || GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n-\t\t&& !se->data_not_needed)\n-\t       || (se->use_offset && base != NULL_TREE))\n-\t/* Set the offset depending on base.  */\n-\tgfc_conv_descriptor_offset_set (&loop.pre, parm, base);\n       else\n \t{\n \t  /* Only the callee knows what the correct offset it, so just set"}, {"sha": "631872176ff31a059894923cc24533b7c889cb7b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3244f4cd0413e0fc8a0e235f9bac22c030f8323d", "patch": "@@ -1,3 +1,8 @@\n+2015-07-07  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/66578\n+\t* gfortran.dg/allocate_with_source_9.f08: New test.\n+\n 2015-07-07  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/52144"}, {"sha": "aa7cb47687948f01d9252580a93dc9dfd2048c09", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_9.f08", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_9.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244f4cd0413e0fc8a0e235f9bac22c030f8323d/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_9.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_9.f08?ref=3244f4cd0413e0fc8a0e235f9bac22c030f8323d", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+!\n+! Contributed by Thomas Koenig  <tkoenig@gcc.gnu.org>,\n+!                Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+program main\n+\n+  type T\n+     integer, allocatable :: acc(:)\n+  end type\n+\n+  integer :: n, lb, ub\n+  integer :: vec(9)\n+  type(T) :: o1, o2\n+  vec = [(i, i= 1, 9)]\n+  n = 42\n+  lb = 7\n+  ub = lb + 2\n+  allocate(o1%acc, source=vec)\n+  allocate(o2%acc, source=o1%acc(lb:ub))\n+  if (any (o2%acc /= [7, 8, 9])) call abort()\n+  block\n+    real, dimension(0:n) :: a\n+    real, dimension(:), allocatable :: c\n+    call random_number(a)\n+    allocate(c,source=a(:))\n+    if (any (abs(a - c) > 1E-6)) call abort()\n+  end block\n+end program main"}]}