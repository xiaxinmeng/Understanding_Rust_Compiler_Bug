{"sha": "16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZlNGYxYWQ0NGUzYzAwYjhiNzNjOWU0YWRlM2QyMzZlYTcwNDRhOA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-09T09:26:33Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-20T16:21:23Z"}, "message": "Refactor range handling of builtins in vr_values and ranger.\n\nThis sets things up so we can share range handling of builtins between\nvr_values and ranger.  It is meant to refactor the code so that we can\nverify that both implementations yield the same results.\n\nFirst, we abstract out gimple_ranger::range_of_builtin_call into an externally\nvisible counterpart that can be called from vr_values.  It will take a\nrange_query since both ranger and vr_values inherit from this base class.\n\nThen we abstract out all the builtin handling in vr_values into a separate\nmethod that is easier to compare against.\n\nFinally, we call the ranger version from vr_values and compare it with the\nvr_values version.  Since this proves both versions return the same,\nwe can remove vr_values::extract_range_builtin in a follow-up patch.\n\nThe vr_values::range_of_expr change brings the vr_values version up to par\nwith the ranger version.  It should've handled non-SSA's.  This was\na small oversight that went unnoticed because the vr_value version isn't\nstressed nearly as much as the ranger version.  The change is needed because\nthe ranger code handling builtins calls, may call it for integer arguments\nin range_of_builtin_ubsan_call.\n\nThere should be no change in functionality.\n\ngcc/ChangeLog:\n\n\t* gimple-range.cc (gimple_ranger::range_of_builtin_ubsan_call):\n\tMake externally visble...\n\t(range_of_builtin_ubsan_call): ...here.  Add range_query argument.\n\t(gimple_ranger::range_of_builtin_call): Make externally visible...\n\t(range_of_builtin_call): ...here.  Add range_query argument.\n\t* gimple-range.h (range_of_builtin_call): Move out from class and\n\tmake externally visible.\n\t* vr-values.c (vr_values::extract_range_basic): Abstract out\n\tbuiltin handling to...\n\t(vr_values::range_of_expr): Handle non SSAs.\n\t(vr_values::extract_range_builtin): ...here.\n\t* vr-values.h (class vr_values): Add extract_range_builtin.\n\t(range_of_expr): Rename NAME to EXPR.", "tree": {"sha": "8d9782b4176bc6c40aac2f84355ffca712d75b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d9782b4176bc6c40aac2f84355ffca712d75b73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d53ec27015b916640171e891870adf2c6fdfd4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d53ec27015b916640171e891870adf2c6fdfd4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d53ec27015b916640171e891870adf2c6fdfd4c"}], "stats": {"total": 551, "additions": 293, "deletions": 258}, "files": [{"sha": "b790d62d75f496a7e4e46938129a0a615fd4c49a", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8", "patch": "@@ -552,10 +552,13 @@ gimple_ranger::range_of_call (irange &r, gcall *call)\n   return true;\n }\n \n+// Return the range of a __builtin_ubsan* in CALL and set it in R.\n+// CODE is the type of ubsan call (PLUS_EXPR, MINUS_EXPR or\n+// MULT_EXPR).\n \n-void\n-gimple_ranger::range_of_builtin_ubsan_call (irange &r, gcall *call,\n-\t\t\t\t\t    tree_code code)\n+static void\n+range_of_builtin_ubsan_call (range_query &query, irange &r, gcall *call,\n+\t\t\t     tree_code code)\n {\n   gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR\n \t\t       || code == MULT_EXPR);\n@@ -565,8 +568,8 @@ gimple_ranger::range_of_builtin_ubsan_call (irange &r, gcall *call,\n   int_range_max ir0, ir1;\n   tree arg0 = gimple_call_arg (call, 0);\n   tree arg1 = gimple_call_arg (call, 1);\n-  gcc_assert (range_of_expr (ir0, arg0, call));\n-  gcc_assert (range_of_expr (ir1, arg1, call));\n+  gcc_assert (query.range_of_expr (ir0, arg0, call));\n+  gcc_assert (query.range_of_expr (ir1, arg1, call));\n \n   bool saved_flag_wrapv = flag_wrapv;\n   // Pretend the arithmetic is wrapping.  If there is any overflow,\n@@ -582,9 +585,11 @@ gimple_ranger::range_of_builtin_ubsan_call (irange &r, gcall *call,\n     r.set_varying (type);\n }\n \n+// For a builtin in CALL, return a range in R if known and return\n+// TRUE.  Otherwise return FALSE.\n \n bool\n-gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n+range_of_builtin_call (range_query &query, irange &r, gcall *call)\n {\n   combined_fn func = gimple_call_combined_fn (call);\n   if (func == CFN_LAST)\n@@ -605,7 +610,7 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n \t  return true;\n \t}\n       arg = gimple_call_arg (call, 0);\n-      if (range_of_expr (r, arg, call) && r.singleton_p ())\n+      if (query.range_of_expr (r, arg, call) && r.singleton_p ())\n \t{\n \t  r.set (build_one_cst (type), build_one_cst (type));\n \t  return true;\n@@ -619,7 +624,7 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n       prec = TYPE_PRECISION (TREE_TYPE (arg));\n       mini = 0;\n       maxi = prec;\n-      gcc_assert (range_of_expr (r, arg, call));\n+      gcc_assert (query.range_of_expr (r, arg, call));\n       // If arg is non-zero, then ffs or popcount are non-zero.\n       if (!range_includes_zero_p (&r))\n \tmini = 1;\n@@ -663,7 +668,7 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n \t    }\n \t}\n \n-      gcc_assert (range_of_expr (r, arg, call));\n+      gcc_assert (query.range_of_expr (r, arg, call));\n       // From clz of minimum we can compute result maximum.\n       if (r.constant_p ())\n \t{\n@@ -728,7 +733,7 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n \t\tmini = -2;\n \t    }\n \t}\n-      gcc_assert (range_of_expr (r, arg, call));\n+      gcc_assert (query.range_of_expr (r, arg, call));\n       if (!r.undefined_p ())\n \t{\n \t  if (r.lower_bound () != 0)\n@@ -766,13 +771,13 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n       r.set (build_int_cst (type, 0), build_int_cst (type, prec - 1));\n       return true;\n     case CFN_UBSAN_CHECK_ADD:\n-      range_of_builtin_ubsan_call (r, call, PLUS_EXPR);\n+      range_of_builtin_ubsan_call (query, r, call, PLUS_EXPR);\n       return true;\n     case CFN_UBSAN_CHECK_SUB:\n-      range_of_builtin_ubsan_call (r, call, MINUS_EXPR);\n+      range_of_builtin_ubsan_call (query, r, call, MINUS_EXPR);\n       return true;\n     case CFN_UBSAN_CHECK_MUL:\n-      range_of_builtin_ubsan_call (r, call, MULT_EXPR);\n+      range_of_builtin_ubsan_call (query, r, call, MULT_EXPR);\n       return true;\n \n     case CFN_GOACC_DIM_SIZE:\n@@ -822,6 +827,11 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n }\n \n \n+bool\n+gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n+{\n+  return ::range_of_builtin_call (*this, r, call);\n+}\n \n // Calculate a range for COND_EXPR statement S and return it in R.\n // If a range cannot be calculated, return false."}, {"sha": "0aa6d4672ee794d806b43d3eec4540883ea56fd4", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8", "patch": "@@ -64,7 +64,6 @@ class gimple_ranger : public range_query\n   bool range_of_phi (irange &r, gphi *phi);\n   bool range_of_non_trivial_assignment (irange &r, gimple *s);\n   bool range_of_builtin_call (irange &r, gcall *call);\n-  void range_of_builtin_ubsan_call (irange &r, gcall *call, tree_code code);\n   bool range_with_loop_info (irange &r, tree name);\n   void range_of_ssa_name_with_loop_info (irange &, tree, class loop *,\n \t\t\t\t\t gphi *);\n@@ -179,4 +178,7 @@ class trace_ranger : public gimple_ranger\n // Flag to enable debugging the various internal Caches.\n #define DEBUG_RANGE_CACHE (dump_file && (param_evrp_mode & EVRP_MODE_DEBUG))\n \n+// Temporary external interface to share with vr_values.\n+bool range_of_builtin_call (range_query &query, irange &r, gcall *call);\n+\n #endif // GCC_GIMPLE_RANGE_STMT_H"}, {"sha": "11beef82a64fef01788a3fbb3f2ee673f8c9d330", "filename": "gcc/vr-values.c", "status": "modified", "additions": 265, "deletions": 243, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vr-values.h\"\n #include \"cfghooks.h\"\n #include \"range-op.h\"\n+#include \"gimple-range.h\"\n \n /* Set value range VR to a non-negative range of type TYPE.  */\n \n@@ -174,9 +175,12 @@ vr_values::get_value_range (const_tree var,\n }\n \n bool\n-vr_values::range_of_expr (irange &r, tree name, gimple *stmt)\n+vr_values::range_of_expr (irange &r, tree expr, gimple *stmt)\n {\n-  if (const value_range *vr = get_value_range (name, stmt))\n+  if (!gimple_range_ssa_p (expr))\n+    return get_tree_range (r, expr);\n+\n+  if (const value_range *vr = get_value_range (expr, stmt))\n     {\n       if (vr->undefined_p () || vr->varying_p () || vr->constant_p ())\n \tr = *vr;\n@@ -1151,271 +1155,289 @@ check_for_binary_op_overflow (range_query *query,\n   return true;\n }\n \n-/* Try to derive a nonnegative or nonzero range out of STMT relying\n-   primarily on generic routines in fold in conjunction with range data.\n-   Store the result in *VR */\n+/* Derive a range from a builtin.  Set range in VR and return TRUE if\n+   successful.  */\n \n-void\n-vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n+bool\n+vr_values::extract_range_builtin (value_range_equiv *vr, gimple *stmt)\n {\n-  bool sop;\n+  gcc_assert (is_gimple_call (stmt));\n   tree type = gimple_expr_type (stmt);\n+  tree arg;\n+  int mini, maxi, zerov = 0, prec;\n+  enum tree_code subcode = ERROR_MARK;\n+  combined_fn cfn = gimple_call_combined_fn (stmt);\n+  scalar_int_mode mode;\n \n-  if (is_gimple_call (stmt))\n+  switch (cfn)\n     {\n-      tree arg;\n-      int mini, maxi, zerov = 0, prec;\n-      enum tree_code subcode = ERROR_MARK;\n-      combined_fn cfn = gimple_call_combined_fn (stmt);\n-      scalar_int_mode mode;\n-\n-      switch (cfn)\n+    case CFN_BUILT_IN_CONSTANT_P:\n+      /* Resolve calls to __builtin_constant_p after inlining.  */\n+      if (cfun->after_inlining)\n \t{\n-\tcase CFN_BUILT_IN_CONSTANT_P:\n-\t  /* Resolve calls to __builtin_constant_p after inlining.  */\n-\t  if (cfun->after_inlining)\n-\t    {\n-\t      vr->set_zero (type);\n-\t      vr->equiv_clear ();\n-\t      return;\n-\t    }\n-\t  break;\n-\t  /* Both __builtin_ffs* and __builtin_popcount return\n-\t     [0, prec].  */\n-\tCASE_CFN_FFS:\n-\tCASE_CFN_POPCOUNT:\n-\t  arg = gimple_call_arg (stmt, 0);\n-\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n-\t  mini = 0;\n-\t  maxi = prec;\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t  vr->set_zero (type);\n+\t  vr->equiv_clear ();\n+\t  return true;\n+\t}\n+      break;\n+      /* Both __builtin_ffs* and __builtin_popcount return\n+\t [0, prec].  */\n+    CASE_CFN_FFS:\n+    CASE_CFN_POPCOUNT:\n+      arg = gimple_call_arg (stmt, 0);\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      mini = 0;\n+      maxi = prec;\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  const value_range_equiv *vr0 = get_value_range (arg);\n+\t  /* If arg is non-zero, then ffs or popcount are non-zero.  */\n+\t  if (range_includes_zero_p (vr0) == 0)\n+\t    mini = 1;\n+\t  /* If some high bits are known to be zero,\n+\t     we can decrease the maximum.  */\n+\t  if (vr0->kind () == VR_RANGE\n+\t      && TREE_CODE (vr0->max ()) == INTEGER_CST\n+\t      && !operand_less_p (vr0->min (),\n+\t\t\t\t  build_zero_cst (TREE_TYPE (vr0->min ()))))\n+\t    maxi = tree_floor_log2 (vr0->max ()) + 1;\n+\t}\n+      goto bitop_builtin;\n+      /* __builtin_parity* returns [0, 1].  */\n+    CASE_CFN_PARITY:\n+      mini = 0;\n+      maxi = 1;\n+      goto bitop_builtin;\n+      /* __builtin_clz* return [0, prec-1], except for\n+\t when the argument is 0, but that is undefined behavior.\n+\t Always handle __builtin_clz* which can be only written\n+\t by user as UB on 0 and so [0, prec-1] range, and the internal-fn\n+\t calls depending on how CLZ_DEFINED_VALUE_AT_ZERO is defined.  */\n+    CASE_CFN_CLZ:\n+      arg = gimple_call_arg (stmt, 0);\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      mini = 0;\n+      maxi = prec - 1;\n+      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n+      if (gimple_call_internal_p (stmt))\n+\t{\n+\t  if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n+\t      && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n \t    {\n-\t      const value_range_equiv *vr0 = get_value_range (arg);\n-\t      /* If arg is non-zero, then ffs or popcount are non-zero.  */\n-\t      if (range_includes_zero_p (vr0) == 0)\n-\t\tmini = 1;\n-\t      /* If some high bits are known to be zero,\n-\t\t we can decrease the maximum.  */\n-\t      if (vr0->kind () == VR_RANGE\n-\t\t  && TREE_CODE (vr0->max ()) == INTEGER_CST\n-\t\t  && !operand_less_p (vr0->min (),\n-\t\t\t\t      build_zero_cst (TREE_TYPE (vr0->min ()))))\n-\t\tmaxi = tree_floor_log2 (vr0->max ()) + 1;\n+\t      /* Handle only the single common value.  */\n+\t      if (zerov == prec)\n+\t\tmaxi = prec;\n+\t      /* Magic value to give up, unless vr0 proves\n+\t\t arg is non-zero.  */\n+\t      else\n+\t\tmini = -2;\n \t    }\n-\t  goto bitop_builtin;\n-\t  /* __builtin_parity* returns [0, 1].  */\n-\tCASE_CFN_PARITY:\n-\t  mini = 0;\n-\t  maxi = 1;\n-\t  goto bitop_builtin;\n-\t  /* __builtin_clz* return [0, prec-1], except for\n-\t     when the argument is 0, but that is undefined behavior.\n-\t     Always handle __builtin_clz* which can be only written\n-\t     by user as UB on 0 and so [0, prec-1] range, and the internal-fn\n-\t     calls depending on how CLZ_DEFINED_VALUE_AT_ZERO is defined.  */\n-\tCASE_CFN_CLZ:\n-\t  arg = gimple_call_arg (stmt, 0);\n-\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n-\t  mini = 0;\n-\t  maxi = prec - 1;\n-\t  mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-\t  if (gimple_call_internal_p (stmt))\n+\t}\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  const value_range_equiv *vr0 = get_value_range (arg);\n+\t  /* From clz of VR_RANGE minimum we can compute\n+\t     result maximum.  */\n+\t  if (vr0->kind () == VR_RANGE\n+\t      && TREE_CODE (vr0->min ()) == INTEGER_CST\n+\t      && integer_nonzerop (vr0->min ()))\n \t    {\n-\t      if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n-\t\t  && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n-\t\t{\n-\t\t  /* Handle only the single common value.  */\n-\t\t  if (zerov == prec)\n-\t\t    maxi = prec;\n-\t\t  /* Magic value to give up, unless vr0 proves\n-\t\t     arg is non-zero.  */\n-\t\t  else\n-\t\t    mini = -2;\n-\t\t}\n+\t      maxi = prec - 1 - tree_floor_log2 (vr0->min ());\n+\t      if (mini == -2)\n+\t\tmini = 0;\n \t    }\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t  else if (vr0->kind () == VR_ANTI_RANGE\n+\t\t   && integer_zerop (vr0->min ()))\n \t    {\n-\t      const value_range_equiv *vr0 = get_value_range (arg);\n-\t      /* From clz of VR_RANGE minimum we can compute\n-\t\t result maximum.  */\n-\t      if (vr0->kind () == VR_RANGE\n-\t\t  && TREE_CODE (vr0->min ()) == INTEGER_CST\n-\t\t  && integer_nonzerop (vr0->min ()))\n-\t\t{\n-\t\t  maxi = prec - 1 - tree_floor_log2 (vr0->min ());\n-\t\t  if (mini == -2)\n-\t\t    mini = 0;\n-\t\t}\n-\t      else if (vr0->kind () == VR_ANTI_RANGE\n-\t\t       && integer_zerop (vr0->min ()))\n-\t\t{\n-\t\t  maxi = prec - 1;\n-\t\t  mini = 0;\n-\t\t}\n-\t      if (mini == -2)\n-\t\tbreak;\n-\t      /* From clz of VR_RANGE maximum we can compute\n-\t\t result minimum.  */\n-\t      if (vr0->kind () == VR_RANGE\n-\t\t  && TREE_CODE (vr0->max ()) == INTEGER_CST)\n-\t\t{\n-\t\t  int newmini = prec - 1 - tree_floor_log2 (vr0->max ());\n-\t\t  if (newmini == prec)\n-\t\t    {\n-\t\t      if (maxi == prec)\n-\t\t\tmini = prec;\n-\t\t    }\n-\t\t  else\n-\t\t    mini = newmini;\n-\t\t}\n+\t      maxi = prec - 1;\n+\t      mini = 0;\n \t    }\n \t  if (mini == -2)\n \t    break;\n-\t  goto bitop_builtin;\n-\t  /* __builtin_ctz* return [0, prec-1], except for\n-\t     when the argument is 0, but that is undefined behavior.\n-\t     Always handle __builtin_ctz* which can be only written\n-\t     by user as UB on 0 and so [0, prec-1] range, and the internal-fn\n-\t     calls depending on how CTZ_DEFINED_VALUE_AT_ZERO is defined.  */\n-\tCASE_CFN_CTZ:\n-\t  arg = gimple_call_arg (stmt, 0);\n-\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n-\t  mini = 0;\n-\t  maxi = prec - 1;\n-\t  mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-\t  if (gimple_call_internal_p (stmt))\n+\t  /* From clz of VR_RANGE maximum we can compute\n+\t     result minimum.  */\n+\t  if (vr0->kind () == VR_RANGE\n+\t      && TREE_CODE (vr0->max ()) == INTEGER_CST)\n \t    {\n-\t      if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n-\t\t  && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t      int newmini = prec - 1 - tree_floor_log2 (vr0->max ());\n+\t      if (newmini == prec)\n \t\t{\n-\t\t  /* Handle only the two common values.  */\n-\t\t  if (zerov == -1)\n-\t\t    mini = -1;\n-\t\t  else if (zerov == prec)\n-\t\t    maxi = prec;\n-\t\t  else\n-\t\t    /* Magic value to give up, unless vr0 proves\n-\t\t       arg is non-zero.  */\n-\t\t    mini = -2;\n+\t\t  if (maxi == prec)\n+\t\t    mini = prec;\n \t\t}\n+\t      else\n+\t\tmini = newmini;\n \t    }\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t}\n+      if (mini == -2)\n+\tbreak;\n+      goto bitop_builtin;\n+      /* __builtin_ctz* return [0, prec-1], except for\n+\t when the argument is 0, but that is undefined behavior.\n+\t Always handle __builtin_ctz* which can be only written\n+\t by user as UB on 0 and so [0, prec-1] range, and the internal-fn\n+\t calls depending on how CTZ_DEFINED_VALUE_AT_ZERO is defined.  */\n+    CASE_CFN_CTZ:\n+      arg = gimple_call_arg (stmt, 0);\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      mini = 0;\n+      maxi = prec - 1;\n+      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n+      if (gimple_call_internal_p (stmt))\n+\t{\n+\t  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n+\t      && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n \t    {\n-\t      const value_range_equiv *vr0 = get_value_range (arg);\n-\t      /* If arg is non-zero, then use [0, prec - 1].  */\n-\t      if ((vr0->kind () == VR_RANGE\n-\t\t   && integer_nonzerop (vr0->min ()))\n-\t\t  || (vr0->kind () == VR_ANTI_RANGE\n-\t\t      && integer_zerop (vr0->min ())))\n-\t\t{\n-\t\t  mini = 0;\n-\t\t  maxi = prec - 1;\n-\t\t}\n-\t      /* If some high bits are known to be zero,\n-\t\t we can decrease the result maximum.  */\n-\t      if (vr0->kind () == VR_RANGE\n-\t\t  && TREE_CODE (vr0->max ()) == INTEGER_CST)\n+\t      /* Handle only the two common values.  */\n+\t      if (zerov == -1)\n+\t\tmini = -1;\n+\t      else if (zerov == prec)\n+\t\tmaxi = prec;\n+\t      else\n+\t\t/* Magic value to give up, unless vr0 proves\n+\t\t   arg is non-zero.  */\n+\t\tmini = -2;\n+\t    }\n+\t}\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  const value_range_equiv *vr0 = get_value_range (arg);\n+\t  /* If arg is non-zero, then use [0, prec - 1].  */\n+\t  if ((vr0->kind () == VR_RANGE\n+\t       && integer_nonzerop (vr0->min ()))\n+\t      || (vr0->kind () == VR_ANTI_RANGE\n+\t\t  && integer_zerop (vr0->min ())))\n+\t    {\n+\t      mini = 0;\n+\t      maxi = prec - 1;\n+\t    }\n+\t  /* If some high bits are known to be zero,\n+\t     we can decrease the result maximum.  */\n+\t  if (vr0->kind () == VR_RANGE\n+\t      && TREE_CODE (vr0->max ()) == INTEGER_CST)\n+\t    {\n+\t      int newmaxi = tree_floor_log2 (vr0->max ());\n+\t      if (newmaxi == -1)\n \t\t{\n-\t\t  int newmaxi = tree_floor_log2 (vr0->max ());\n-\t\t  if (newmaxi == -1)\n-\t\t    {\n-\t\t      if (mini == -1)\n-\t\t\tmaxi = -1;\n-\t\t      else if (maxi == prec)\n-\t\t\tmini = prec;\n-\t\t    }\n-\t\t  else if (maxi != prec)\n-\t\t    maxi = newmaxi;\n+\t\t  if (mini == -1)\n+\t\t    maxi = -1;\n+\t\t  else if (maxi == prec)\n+\t\t    mini = prec;\n \t\t}\n+\t      else if (maxi != prec)\n+\t\tmaxi = newmaxi;\n \t    }\n-\t  if (mini == -2)\n-\t    break;\n-\t  goto bitop_builtin;\n-\t  /* __builtin_clrsb* returns [0, prec-1].  */\n-\tCASE_CFN_CLRSB:\n-\t  arg = gimple_call_arg (stmt, 0);\n-\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n-\t  mini = 0;\n-\t  maxi = prec - 1;\n-\t  goto bitop_builtin;\n-\tbitop_builtin:\n-\t  vr->set (build_int_cst (type, mini), build_int_cst (type, maxi));\n-\t  return;\n-\tcase CFN_UBSAN_CHECK_ADD:\n-\t  subcode = PLUS_EXPR;\n-\t  break;\n-\tcase CFN_UBSAN_CHECK_SUB:\n-\t  subcode = MINUS_EXPR;\n-\t  break;\n-\tcase CFN_UBSAN_CHECK_MUL:\n-\t  subcode = MULT_EXPR;\n-\t  break;\n-\tcase CFN_GOACC_DIM_SIZE:\n-\tcase CFN_GOACC_DIM_POS:\n-\t  /* Optimizing these two internal functions helps the loop\n-\t     optimizer eliminate outer comparisons.  Size is [1,N]\n-\t     and pos is [0,N-1].  */\n+\t}\n+      if (mini == -2)\n+\tbreak;\n+      goto bitop_builtin;\n+      /* __builtin_clrsb* returns [0, prec-1].  */\n+    CASE_CFN_CLRSB:\n+      arg = gimple_call_arg (stmt, 0);\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      mini = 0;\n+      maxi = prec - 1;\n+      goto bitop_builtin;\n+    bitop_builtin:\n+      vr->set (build_int_cst (type, mini), build_int_cst (type, maxi));\n+      return true;\n+    case CFN_UBSAN_CHECK_ADD:\n+      subcode = PLUS_EXPR;\n+      break;\n+    case CFN_UBSAN_CHECK_SUB:\n+      subcode = MINUS_EXPR;\n+      break;\n+    case CFN_UBSAN_CHECK_MUL:\n+      subcode = MULT_EXPR;\n+      break;\n+    case CFN_GOACC_DIM_SIZE:\n+    case CFN_GOACC_DIM_POS:\n+      /* Optimizing these two internal functions helps the loop\n+\t optimizer eliminate outer comparisons.  Size is [1,N]\n+\t and pos is [0,N-1].  */\n+      {\n+\tbool is_pos = cfn == CFN_GOACC_DIM_POS;\n+\tint axis = oacc_get_ifn_dim_arg (stmt);\n+\tint size = oacc_get_fn_dim_size (current_function_decl, axis);\n+\n+\tif (!size)\n+\t  /* If it's dynamic, the backend might know a hardware\n+\t     limitation.  */\n+\t  size = targetm.goacc.dim_limit (axis);\n+\n+\ttree type = TREE_TYPE (gimple_call_lhs (stmt));\n+\tvr->set(build_int_cst (type, is_pos ? 0 : 1),\n+\t\tsize\n+\t\t? build_int_cst (type, size - is_pos) : vrp_val_max (type));\n+      }\n+      return true;\n+    case CFN_BUILT_IN_STRLEN:\n+      if (tree lhs = gimple_call_lhs (stmt))\n+\tif (ptrdiff_type_node\n+\t    && (TYPE_PRECISION (ptrdiff_type_node)\n+\t\t== TYPE_PRECISION (TREE_TYPE (lhs))))\n \t  {\n-\t    bool is_pos = cfn == CFN_GOACC_DIM_POS;\n-\t    int axis = oacc_get_ifn_dim_arg (stmt);\n-\t    int size = oacc_get_fn_dim_size (current_function_decl, axis);\n-\n-\t    if (!size)\n-\t      /* If it's dynamic, the backend might know a hardware\n-\t\t limitation.  */\n-\t      size = targetm.goacc.dim_limit (axis);\n-\n-\t    tree type = TREE_TYPE (gimple_call_lhs (stmt));\n-\t    vr->set(build_int_cst (type, is_pos ? 0 : 1),\n-\t\t    size\n-\t\t    ? build_int_cst (type, size - is_pos) : vrp_val_max (type));\n+\t    tree type = TREE_TYPE (lhs);\n+\t    tree max = vrp_val_max (ptrdiff_type_node);\n+\t    wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n+\t    tree range_min = build_zero_cst (type);\n+\t    /* To account for the terminating NUL, the maximum length\n+\t       is one less than the maximum array size, which in turn\n+\t       is one  less than PTRDIFF_MAX (or SIZE_MAX where it's\n+\t       smaller than the former type).\n+\t       FIXME: Use max_object_size() - 1 here.  */\n+\t    tree range_max = wide_int_to_tree (type, wmax - 2);\n+\t    vr->set (range_min, range_max);\n+\t    return true;\n \t  }\n-\t  return;\n-\tcase CFN_BUILT_IN_STRLEN:\n-\t  if (tree lhs = gimple_call_lhs (stmt))\n-\t    if (ptrdiff_type_node\n-\t\t&& (TYPE_PRECISION (ptrdiff_type_node)\n-\t\t    == TYPE_PRECISION (TREE_TYPE (lhs))))\n-\t      {\n-\t\ttree type = TREE_TYPE (lhs);\n-\t\ttree max = vrp_val_max (ptrdiff_type_node);\n-\t\twide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n-\t\ttree range_min = build_zero_cst (type);\n-\t\t/* To account for the terminating NUL, the maximum length\n-\t\t   is one less than the maximum array size, which in turn\n-\t\t   is one  less than PTRDIFF_MAX (or SIZE_MAX where it's\n-\t\t   smaller than the former type).\n-\t\t   FIXME: Use max_object_size() - 1 here.  */\n-\t\ttree range_max = wide_int_to_tree (type, wmax - 2);\n-\t\tvr->set (range_min, range_max);\n-\t\treturn;\n-\t      }\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n-      if (subcode != ERROR_MARK)\n-\t{\n-\t  bool saved_flag_wrapv = flag_wrapv;\n-\t  /* Pretend the arithmetics is wrapping.  If there is\n-\t     any overflow, we'll complain, but will actually do\n-\t     wrapping operation.  */\n-\t  flag_wrapv = 1;\n-\t  extract_range_from_binary_expr (vr, subcode, type,\n-\t\t\t\t\t  gimple_call_arg (stmt, 0),\n-\t\t\t\t\t  gimple_call_arg (stmt, 1));\n-\t  flag_wrapv = saved_flag_wrapv;\n-\n-\t  /* If for both arguments vrp_valueize returned non-NULL,\n-\t     this should have been already folded and if not, it\n-\t     wasn't folded because of overflow.  Avoid removing the\n-\t     UBSAN_CHECK_* calls in that case.  */\n-\t  if (vr->kind () == VR_RANGE\n-\t      && (vr->min () == vr->max ()\n-\t\t  || operand_equal_p (vr->min (), vr->max (), 0)))\n-\t    vr->set_varying (vr->type ());\n-\t  return;\n-\t}\n+      break;\n+    default:\n+      break;\n+    }\n+  if (subcode != ERROR_MARK)\n+    {\n+      bool saved_flag_wrapv = flag_wrapv;\n+      /* Pretend the arithmetics is wrapping.  If there is\n+\t any overflow, we'll complain, but will actually do\n+\t wrapping operation.  */\n+      flag_wrapv = 1;\n+      extract_range_from_binary_expr (vr, subcode, type,\n+\t\t\t\t      gimple_call_arg (stmt, 0),\n+\t\t\t\t      gimple_call_arg (stmt, 1));\n+      flag_wrapv = saved_flag_wrapv;\n+\n+      /* If for both arguments vrp_valueize returned non-NULL,\n+\t this should have been already folded and if not, it\n+\t wasn't folded because of overflow.  Avoid removing the\n+\t UBSAN_CHECK_* calls in that case.  */\n+      if (vr->kind () == VR_RANGE\n+\t  && (vr->min () == vr->max ()\n+\t      || operand_equal_p (vr->min (), vr->max (), 0)))\n+\tvr->set_varying (vr->type ());\n+\n+      return !vr->varying_p ();\n+    }\n+  return false;\n+}\n+\n+/* Try to derive a nonnegative or nonzero range out of STMT relying\n+   primarily on generic routines in fold in conjunction with range data.\n+   Store the result in *VR */\n+\n+void\n+vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n+{\n+  bool sop;\n+  tree type = gimple_expr_type (stmt);\n+\n+  if (is_gimple_call (stmt) && extract_range_builtin (vr, stmt))\n+    {\n+      value_range_equiv tmp;\n+      /* Assert that any ranges vr_values::extract_range_builtin gets\n+\t are also handled by the ranger counterpart.  */\n+      gcc_assert (range_of_builtin_call (*this, tmp, as_a<gcall *> (stmt)));\n+      gcc_assert (tmp.equal_p (*vr, /*ignore_equivs=*/false));\n+      return;\n     }\n   /* Handle extraction of the two results (result of arithmetics and\n      a flag whether arithmetics overflowed) from {ADD,SUB,MUL}_OVERFLOW"}, {"sha": "b0ff68d8e340bb84dbcbc0f573a8b69b24b42016", "filename": "gcc/vr-values.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=16e4f1ad44e3c00b8b73c9e4ade3d236ea7044a8", "patch": "@@ -101,7 +101,7 @@ class vr_values : public range_query\n   vr_values (void);\n   ~vr_values (void);\n \n-  virtual bool range_of_expr (irange &r, tree name, gimple *stmt) OVERRIDE;\n+  virtual bool range_of_expr (irange &r, tree expr, gimple *stmt) OVERRIDE;\n   virtual tree value_of_expr (tree, gimple * = NULL) OVERRIDE;\n   virtual tree value_on_edge (edge, tree) OVERRIDE;\n   virtual tree value_of_stmt (gimple *, tree = NULL_TREE) OVERRIDE;\n@@ -148,6 +148,7 @@ class vr_values : public range_query\n   void extract_range_from_comparison (value_range_equiv *, gimple *);\n   void vrp_visit_assignment_or_call (gimple*, tree *, value_range_equiv *);\n   void vrp_visit_switch_stmt (gswitch *, edge *);\n+  bool extract_range_builtin (value_range_equiv *, gimple *);\n \n   /* This probably belongs in the lattice rather than in here.  */\n   bool values_propagated;"}]}