{"sha": "694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk0ZDRhNmQwYzQ2NmQwZmJjOTc5MjBhOWM2NjQxYTdiMzQ5Y2EzNQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-12-02T13:32:37Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-12-02T13:32:37Z"}, "message": "Use the section flag 'o' for __patchable_function_entries\n\nThis commit in GNU binutils 2.35:\n\nhttps://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=commit;h=b7d072167715829eed0622616f6ae0182900de3e\n\nadded the section flag 'o' to .section directive:\n\n.section __patchable_function_entries,\"awo\",@progbits,foo\n\nwhich specifies the symbol name which the section references.  Assembler\ncreates a unique __patchable_function_entries section with the section,\nwhere foo is defined, as its linked-to section.  Linker keeps a section\nif its linked-to section is kept during garbage collection.\n\nThis patch checks assembler support for the section flag 'o' and uses\nit to implement __patchable_function_entries section.  Since Solaris may\nuse GNU assembler with Solairs ld.  Even if GNU assembler supports the\nsection flag 'o', it doesn't mean that Solairs ld supports it.  This\nfeature is disabled for Solairs targets.\n\ngcc/\n\n\tPR middle-end/93195\n\tPR middle-end/93197\n\t* configure.ac (HAVE_GAS_SECTION_LINK_ORDER): New.  Define 1 if\n\tthe assembler supports the section flag 'o' for specifying\n\tsection with link-order.\n\t* output.h (SECTION_LINK_ORDER): New.  Defined to 0x8000000.\n\t(SECTION_MACH_DEP): Changed from 0x8000000 to 0x10000000.\n\t* targhooks.c (default_print_patchable_function_entry): Pass\n\tSECTION_LINK_ORDER to switch_to_section if the section flag 'o'\n\tworks.  Pass current_function_decl to switch_to_section.\n\t* varasm.c (default_elf_asm_named_section): Use 'o' flag for\n\tSECTION_LINK_ORDER if assembler supports it.\n\t* config.in: Regenerated.\n\t* configure: Likewise.\n\t* doc/sourcebuild.texi: Document o_flag_in_section.\n\ngcc/testsuite/\n\n\tPR middle-end/93195\n\t* g++.dg/pr93195a.C: New test.\n\t* g++.dg/pr93195b.C: Likewise.\n\t* lib/target-supports.exp\n\t(check_effective_target_o_flag_in_section): New proc.", "tree": {"sha": "9ef8e10abea2aa46892a2af8db490bc3c1e585a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ef8e10abea2aa46892a2af8db490bc3c1e585a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1ebd4f9f71adbb17b2f187c67f2fb49f0a8fe51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ebd4f9f71adbb17b2f187c67f2fb49f0a8fe51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ebd4f9f71adbb17b2f187c67f2fb49f0a8fe51"}], "stats": {"total": 182, "additions": 180, "deletions": 2}, "files": [{"sha": "216505abd2c54ead937387d798ec556c3175b6c7", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -1386,6 +1386,12 @@\n #endif\n \n \n+/* Define 0/1 if your assembler supports 'o' flag in .section directive. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_GAS_SECTION_LINK_ORDER\n+#endif\n+\n+\n /* Define 0/1 if your assembler supports marking sections with SHF_GNU_RETAIN\n    flag. */\n #ifndef USED_FOR_TARGET"}, {"sha": "785d6560987a2865a0a490f5e992cee2fd65dd03", "filename": "gcc/configure", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -24481,6 +24481,58 @@ cat >>confdefs.h <<_ACEOF\n _ACEOF\n \n \n+# Test if the assembler supports the section flag 'o' for specifying\n+# section with link-order.\n+case \"${target}\" in\n+  # Solaris may use GNU assembler with Solairs ld.  Even if GNU\n+  # assembler supports the section flag 'o', it doesn't mean that\n+  # Solairs ld supports it.\n+  *-*-solaris2*)\n+    gcc_cv_as_section_link_order=no\n+    ;;\n+  *)\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for section 'o' flag\" >&5\n+$as_echo_n \"checking assembler for section 'o' flag... \" >&6; }\n+if ${gcc_cv_as_section_link_order+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_section_link_order=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 35 \\) \\* 1000 + 0`\n+  then gcc_cv_as_section_link_order=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    $as_echo '.section .foo,\"a\"\n+.byte 0\n+.section __patchable_function_entries,\"awo\",%progbits,.foo\n+.byte 0' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags --fatal-warnings -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_section_link_order=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_section_link_order\" >&5\n+$as_echo \"$gcc_cv_as_section_link_order\" >&6; }\n+\n+\n+    ;;\n+esac\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_GAS_SECTION_LINK_ORDER `if test $gcc_cv_as_section_link_order = yes; then echo 1; else echo 0; fi`\n+_ACEOF\n+\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for section merging support\" >&5\n $as_echo_n \"checking assembler for section merging support... \" >&6; }\n if ${gcc_cv_as_shf_merge+:} false; then :"}, {"sha": "062f57fa12b78eabbf07fb21e22bf4380bbf06af", "filename": "gcc/configure.ac", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -3350,6 +3350,28 @@ AC_DEFINE_UNQUOTED(HAVE_GAS_SHF_GNU_RETAIN,\n   [`if test $gcc_cv_as_shf_gnu_retain = yes; then echo 1; else echo 0; fi`],\n   [Define 0/1 if your assembler supports marking sections with SHF_GNU_RETAIN flag.])\n \n+# Test if the assembler supports the section flag 'o' for specifying\n+# section with link-order.\n+case \"${target}\" in\n+  # Solaris may use GNU assembler with Solairs ld.  Even if GNU\n+  # assembler supports the section flag 'o', it doesn't mean that\n+  # Solairs ld supports it.\n+  *-*-solaris2*)\n+    gcc_cv_as_section_link_order=no\n+    ;;\n+  *)\n+    gcc_GAS_CHECK_FEATURE([section 'o' flag], gcc_cv_as_section_link_order,\n+      [2,35,0], [--fatal-warnings],\n+      [.section .foo,\"a\"\n+.byte 0\n+.section __patchable_function_entries,\"awo\",%progbits,.foo\n+.byte 0])\n+    ;;\n+esac\n+AC_DEFINE_UNQUOTED(HAVE_GAS_SECTION_LINK_ORDER,\n+  [`if test $gcc_cv_as_section_link_order = yes; then echo 1; else echo 0; fi`],\n+  [Define 0/1 if your assembler supports 'o' flag in .section directive.])\n+\n gcc_GAS_CHECK_FEATURE(section merging support, gcc_cv_as_shf_merge,\n  [elf,2,12,0], [--fatal-warnings],\n  [.section .rodata.str, \"aMS\", @progbits, 1])"}, {"sha": "586dce75740af97a4d536423441918ff0fa53894", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -2548,6 +2548,9 @@ Target supports the @code{noinit} variable attribute.\n @item nonpic\n Target does not generate PIC by default.\n \n+@item o_flag_in_section\n+Target supports the 'o' flag in .section directive in assembly inputs.\n+\n @item offload_gcn\n Target has been configured for OpenACC/OpenMP offloading on AMD GCN.\n "}, {"sha": "fa8ace1f394bf0a714c87fa0fa19fc6b54b7e1e3", "filename": "gcc/output.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -382,10 +382,11 @@ extern void no_asm_to_stream (FILE *);\n #define SECTION_RELRO\t 0x1000000\t/* data is readonly after relocation processing */\n #define SECTION_EXCLUDE  0x2000000\t/* discarded by the linker */\n #define SECTION_RETAIN\t 0x4000000\t/* retained by the linker.  */\n+#define SECTION_LINK_ORDER 0x8000000\t/* section needs link-order.  */\n \n /* NB: The maximum SECTION_MACH_DEP is 0x10000000 since AVR needs 4 bits\n    in SECTION_MACH_DEP.  */\n-#define SECTION_MACH_DEP 0x8000000\t/* subsequent bits reserved for target */\n+#define SECTION_MACH_DEP 0x10000000\t/* subsequent bits reserved for target */\n \n /* This SECTION_STYLE is used for unnamed sections that we can switch\n    to using a special assembler directive.  */"}, {"sha": "6e12e13d68e1a0a0eabf497c86f6d821bedfc449", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -1864,8 +1864,11 @@ default_print_patchable_function_entry (FILE *file,\n       patch_area_number++;\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LPFE\", patch_area_number);\n \n+      unsigned int flags = SECTION_WRITE | SECTION_RELRO;\n+      if (HAVE_GAS_SECTION_LINK_ORDER)\n+\tflags |= SECTION_LINK_ORDER;\n       switch_to_section (get_section (\"__patchable_function_entries\",\n-\t\t\t\t      SECTION_WRITE | SECTION_RELRO, NULL));\n+\t\t\t\t      flags, current_function_decl));\n       assemble_align (POINTER_SIZE);\n       fputs (asm_op, file);\n       assemble_name_raw (file, buf);"}, {"sha": "26d265da74ebf7754a1724c0ba5694c5b28d03b3", "filename": "gcc/testsuite/g++.dg/pr93195a.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr93195a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr93195a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr93195a.C?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do link { target { ! { nvptx*-*-* visium-*-* } } } } */\n+// { dg-require-effective-target o_flag_in_section }\n+/* { dg-options \"-O0 -fpatchable-function-entry=1\" } */\n+/* { dg-additional-options \"-fno-pie\" { target sparc*-*-* } } */\n+/* { dg-additional-sources pr93195b.C } */\n+\n+extern void bar1 (void);\n+\n+inline void\n+foo (void)\n+{\n+}\n+\n+void\n+bar (void)\n+{\n+  foo ();\n+  bar1 ();\n+}\n+\n+int\n+main ()\n+{\n+  bar ();\n+  return 0;\n+}\n+"}, {"sha": "303d8588c0f64dee24f8a6a122281e3650b7ca3e", "filename": "gcc/testsuite/g++.dg/pr93195b.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr93195b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr93195b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr93195b.C?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { ! { nvptx*-*-* visium-*-* } } } } */\n+/* { dg-options \"-O0 -fpatchable-function-entry=1\" } */\n+/* { dg-additional-options \"-fno-pie\" { target sparc*-*-* } } */\n+\n+inline void\n+foo (void)\n+{\n+}\n+\n+void\n+bar1 (void)\n+{\n+  foo ();\n+}"}, {"sha": "89c4f67554f6da90fe420694ec2a61e6770f04a8", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -10702,3 +10702,43 @@ proc check_effective_target_R_flag_in_section { } {\n \t}\n     }]\n }\n+\n+# Return 1 if this target supports 'o' flag in .section directive, 0\n+# otherwise.  Cache the result.\n+\n+proc check_effective_target_o_flag_in_section { } {\n+    global tool\n+    global GCC_UNDER_TEST\n+\n+    # Need auto-host.h to check linker support.\n+    if { ![file exists ../../auto-host.h ] } {\n+\treturn 0\n+    }\n+\n+    return [check_cached_effective_target o_flag_in_section {\n+\n+\tset src pie[pid].c\n+\tset obj pie[pid].o\n+\n+\tset f [open $src \"w\"]\n+\tputs $f \"#include \\\"../../auto-host.h\\\"\"\n+\tputs $f \"#if HAVE_GAS_SECTION_LINK_ORDER == 0\"\n+\tputs $f \"# error Assembler does not support 'o' flag in .section directive.\"\n+\tputs $f \"#endif\"\n+\tclose $f\n+\n+\tverbose \"check_effective_target_o_flag_in_section compiling testfile $src\" 2\n+\tset lines [${tool}_target_compile $src $obj object \"\"]\n+\n+\tfile delete $src\n+\tfile delete $obj\n+\n+\tif [string match \"\" $lines] then {\n+\t    verbose \"check_effective_target_o_flag_in_section testfile compilation passed\" 2\n+\t    return 1\n+\t} else {\n+\t    verbose \"check_effective_target_o_flag_in_section testfile compilation failed\" 2\n+\t    return 0\n+\t}\n+    }]\n+}"}, {"sha": "961d2d6fe3ba90a4827c4e3ae57a3fae79de345c", "filename": "gcc/varasm.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d4a6d0c466d0fbc97920a9c6641a7b349ca35/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=694d4a6d0c466d0fbc97920a9c6641a7b349ca35", "patch": "@@ -6789,6 +6789,8 @@ default_elf_asm_named_section (const char *name, unsigned int flags,\n \t*f++ = 'G';\n       if (flags & SECTION_RETAIN)\n \t*f++ = 'R';\n+      if (flags & SECTION_LINK_ORDER)\n+\t*f++ = 'o';\n #ifdef MACH_DEP_SECTION_ASM_FLAG\n       if (flags & SECTION_MACH_DEP)\n \t*f++ = MACH_DEP_SECTION_ASM_FLAG;\n@@ -6821,6 +6823,14 @@ default_elf_asm_named_section (const char *name, unsigned int flags,\n \n       if (flags & SECTION_ENTSIZE)\n \tfprintf (asm_out_file, \",%d\", flags & SECTION_ENTSIZE);\n+      if (flags & SECTION_LINK_ORDER)\n+\t{\n+\t  tree id = DECL_ASSEMBLER_NAME (decl);\n+\t  ultimate_transparent_alias_target (&id);\n+\t  const char *name = IDENTIFIER_POINTER (id);\n+\t  name = targetm.strip_name_encoding (name);\n+\t  fprintf (asm_out_file, \",%s\", name);\n+\t}\n       if (HAVE_COMDAT_GROUP && (flags & SECTION_LINKONCE))\n \t{\n \t  if (TREE_CODE (decl) == IDENTIFIER_NODE)"}]}