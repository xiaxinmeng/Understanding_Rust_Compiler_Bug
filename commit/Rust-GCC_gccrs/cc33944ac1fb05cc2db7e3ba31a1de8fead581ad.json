{"sha": "cc33944ac1fb05cc2db7e3ba31a1de8fead581ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MzMzk0NGFjMWZiMDVjYzJkYjdlM2JhMzFhMWRlOGZlYWQ1ODFhZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-07T12:52:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-07T12:52:33Z"}, "message": "(regs_change_size): New variable.\n\n(stupid_life_analysis): Alloc, init and pass it to stupid_free_reg.\n(stupid_mark_regs): Set it.\n(stupid_find_reg): New arg, CHANGES_SIZE; avoid regs in\nCLASS_CANNOT_CHANGE_SIZE if defined and CHANGES_SIZE nonzero.\n\nFrom-SVN: r7867", "tree": {"sha": "756b4aea1c587a9d6d360bc80511e80ad12ce53c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/756b4aea1c587a9d6d360bc80511e80ad12ce53c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc33944ac1fb05cc2db7e3ba31a1de8fead581ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc33944ac1fb05cc2db7e3ba31a1de8fead581ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc33944ac1fb05cc2db7e3ba31a1de8fead581ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc33944ac1fb05cc2db7e3ba31a1de8fead581ad/comments", "author": null, "committer": null, "parents": [{"sha": "d546b10a8ec570dde00451c2412d65bd581751af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d546b10a8ec570dde00451c2412d65bd581751af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d546b10a8ec570dde00451c2412d65bd581751af"}], "stats": {"total": 40, "additions": 34, "deletions": 6}, "files": [{"sha": "f324aeb3a81c90ea28d79a996dcb9dbb0beb496d", "filename": "gcc/stupid.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc33944ac1fb05cc2db7e3ba31a1de8fead581ad/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc33944ac1fb05cc2db7e3ba31a1de8fead581ad/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=cc33944ac1fb05cc2db7e3ba31a1de8fead581ad", "patch": "@@ -82,6 +82,11 @@ static int *reg_order;\n \n static char *regs_live;\n \n+/* Indexed by reg number, nonzero if reg was used in a SUBREG that changes\n+   its size.  */\n+\n+static char *regs_change_size;\n+\n /* Indexed by insn's suid, the set of hard regs live after that insn.  */\n \n static HARD_REG_SET *after_insn_hard_regs;\n@@ -93,7 +98,7 @@ static HARD_REG_SET *after_insn_hard_regs;\n \n static int stupid_reg_compare\tPROTO((int *, int *));\n static int stupid_find_reg\tPROTO((int, enum reg_class, enum machine_mode,\n-\t\t\t\t       int, int));\n+\t\t\t\t       int, int, int));\n static void stupid_mark_refs\tPROTO((rtx, rtx));\n \f\n /* Stupid life analysis is for the case where only variables declared\n@@ -157,6 +162,9 @@ stupid_life_analysis (f, nregs, file)\n   reg_order = (int *) alloca (nregs * sizeof (int));\n   bzero ((char *) reg_order, nregs * sizeof (int));\n \n+  regs_change_size = (char *) alloca (nregs * sizeof (char));\n+  bzero ((char *) regs_change_size, nregs * sizeof (char));\n+\n   reg_renumber = (short *) oballoc (nregs * sizeof (short));\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_renumber[i] = i;\n@@ -254,15 +262,17 @@ stupid_life_analysis (f, nregs, file)\n \t\t\t\t\t   reg_preferred_class (r),\n \t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n \t\t\t\t\t   reg_where_born[r],\n-\t\t\t\t\t   reg_where_dead[r]);\n+\t\t\t\t\t   reg_where_dead[r],\n+\t\t\t\t\t   regs_change_size[r]);\n \n       /* If no reg available in that class, try alternate class.  */\n       if (reg_renumber[r] == -1 && reg_alternate_class (r) != NO_REGS)\n \treg_renumber[r] = stupid_find_reg (reg_n_calls_crossed[r],\n \t\t\t\t\t   reg_alternate_class (r),\n \t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n \t\t\t\t\t   reg_where_born[r],\n-\t\t\t\t\t   reg_where_dead[r]);\n+\t\t\t\t\t   reg_where_dead[r],\n+\t\t\t\t\t   regs_change_size[r]);\n     }\n \n   if (file)\n@@ -303,14 +313,19 @@ stupid_reg_compare (r1p, r2p)\n    Return -1 if such a block cannot be found.\n \n    If CALL_PRESERVED is nonzero, insist on registers preserved\n-   over subroutine calls, and return -1 if cannot find such.  */\n+   over subroutine calls, and return -1 if cannot find such.\n+\n+   If CHANGES_SIZE is nonzero, it means this register was used as the\n+   operand of a SUBREG that changes its size.  */\n \n static int\n-stupid_find_reg (call_preserved, class, mode, born_insn, dead_insn)\n+stupid_find_reg (call_preserved, class, mode,\n+\t\t born_insn, dead_insn, changes_size)\n      int call_preserved;\n      enum reg_class class;\n      enum machine_mode mode;\n      int born_insn, dead_insn;\n+     int changes_size;\n {\n   register int i, ins;\n #ifdef HARD_REG_SET\n@@ -339,6 +354,12 @@ stupid_find_reg (call_preserved, class, mode, born_insn, dead_insn)\n \n   IOR_COMPL_HARD_REG_SET (used, reg_class_contents[(int) class]);\n \n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+  if (changes_size)\n+    IOR_HARD_REG_SET (used,\n+\t\t      reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE]);\n+#endif\n+\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n #ifdef REG_ALLOC_ORDER\n@@ -471,9 +492,16 @@ stupid_mark_refs (x, insn)\n       return;\n     }\n \n+  else if (code == SUBREG\n+\t   && GET_CODE (SUBREG_REG (x)) == REG\n+\t   && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER\n+\t   && (GET_MODE_SIZE (GET_MODE (x))\n+\t       != GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+    regs_change_size[REGNO (SUBREG_REG (x))] = 1;\n+\n   /* Register value being used, not set.  */\n \n-  if (code == REG)\n+  else if (code == REG)\n     {\n       regno = REGNO (x);\n       if (regno < FIRST_PSEUDO_REGISTER)"}]}