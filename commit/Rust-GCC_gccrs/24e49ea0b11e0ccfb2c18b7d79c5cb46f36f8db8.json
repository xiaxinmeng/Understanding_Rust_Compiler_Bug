{"sha": "24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRlNDllYTBiMTFlMGNjZmIyYzE4YjdkNzljNWNiNDZmMzZmOGRiOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-06-12T22:23:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-06-12T22:23:55Z"}, "message": "symtab.c (symtab_node::reset_section): New method.\n\n\t* symtab.c (symtab_node::reset_section): New method.\n\t* cgraph.c (cgraph_node_cannot_be_local_p_1): Accept non-local\n\tfor localization.\n\t* cgraph.h (reset_section): Declare.\n\t* ipa-inline-analysis.c (do_estimate_growth): Check for comdat groups;\n\tdo not consider comdat locals.\n\t* cgraphclones.c (set_new_clone_decl_and_node_flags): Get section\n\tfor new symbol.\n\t* ipa-visiblity.c (cgraph_externally_visible_p): Cleanup.\n\t(update_visibility_by_resolution_info): Consider UNDEF; fix checking;\n\treset sections of symbols dragged out of the comdats.\n\t(function_and_variable_visibility): Reset sections of localized symbols.\n\nFrom-SVN: r211600", "tree": {"sha": "614d47109aba7fe36bcb27ee602307278455a372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/614d47109aba7fe36bcb27ee602307278455a372"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/comments", "author": null, "committer": null, "parents": [{"sha": "6ad386b725dfac340e0d337d4c20e603929c7f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ad386b725dfac340e0d337d4c20e603929c7f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ad386b725dfac340e0d337d4c20e603929c7f9a"}], "stats": {"total": 76, "additions": 57, "deletions": 19}, "files": [{"sha": "f3deff30f5200d11730feaadd02cdf4ffb9b47be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "patch": "@@ -1,3 +1,18 @@\n+2014-06-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* symtab.c (symtab_node::reset_section): New method.\n+\t* cgraph.c (cgraph_node_cannot_be_local_p_1): Accept non-local\n+\tfor localization.\n+\t* cgraph.h (reset_section): Declare.\n+\t* ipa-inline-analysis.c (do_estimate_growth): Check for comdat groups;\n+\tdo not consider comdat locals.\n+\t* cgraphclones.c (set_new_clone_decl_and_node_flags): Get section\n+\tfor new symbol.\n+\t* ipa-visiblity.c (cgraph_externally_visible_p): Cleanup.\n+\t(update_visibility_by_resolution_info): Consider UNDEF; fix checking;\n+\treset sections of symbols dragged out of the comdats.\n+\t(function_and_variable_visibility): Reset sections of localized symbols.\n+\n 2014-06-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree-vect-data-refs.c (vect_can_force_dr_alignment_p): Reorg"}, {"sha": "f535740f11070ea33667223906c9ff31e1a51de0", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "patch": "@@ -2169,6 +2169,7 @@ cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n \t\t&& !node->forced_by_abi\n \t        && !symtab_used_from_object_file_p (node)\n \t\t&& !node->same_comdat_group)\n+\t       || DECL_EXTERNAL (node->decl)\n \t       || !node->externally_visible));\n }\n \n@@ -2259,14 +2260,14 @@ cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n     {\n       symtab_make_decl_local (node->decl);\n \n-      node->set_section (NULL);\n       node->set_comdat_group (NULL);\n       node->externally_visible = false;\n       node->forced_by_abi = false;\n       node->local.local = true;\n-      node->set_section (NULL);\n+      node->reset_section ();\n       node->unique_name = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t  || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n+\t\t\t   || node->unique_name\n+\t\t\t   || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n       node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n       gcc_assert (cgraph_function_body_availability (node) == AVAIL_LOCAL);\n     }"}, {"sha": "ce99166fd4d718c9a52dda9ebce36b0c0e667cc4", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "patch": "@@ -208,6 +208,7 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Set section for symbol and its aliases.  */\n   void set_section (const char *section);\n   void set_section_for_node (const char *section);\n+  void reset_section ();\n };\n \n enum availability"}, {"sha": "94c9760b37f0053b6208f9e77e9e8b00ad0e4edc", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "patch": "@@ -293,6 +293,7 @@ set_new_clone_decl_and_node_flags (cgraph_node *new_node)\n   new_node->externally_visible = 0;\n   new_node->local.local = 1;\n   new_node->lowered = true;\n+  new_node->reset_section ();\n }\n \n /* Duplicate thunk THUNK if necessary but make it to refer to NODE."}, {"sha": "7f9febc5fe80e7b8612f8e0765d6204d186dbae1", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "patch": "@@ -3877,7 +3877,7 @@ do_estimate_growth (struct cgraph_node *node)\n       /* COMDAT functions are very often not shared across multiple units\n          since they come from various template instantiations.\n          Take this into account.  */\n-      else if (DECL_COMDAT (node->decl)\n+      else if (node->externally_visible && node->get_comdat_group ()\n \t       && cgraph_can_remove_if_no_direct_calls_p (node))\n \td.growth -= (info->size\n \t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n@@ -3928,7 +3928,7 @@ growth_likely_positive (struct cgraph_node *node, int edge_growth ATTRIBUTE_UNUS\n       && (ret = node_growth_cache[node->uid]))\n     return ret > 0;\n   if (!cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n-      && (!DECL_COMDAT (node->decl)\n+      && (!node->externally_visible || !node->get_comdat_group ()\n \t  || !cgraph_can_remove_if_no_direct_calls_p (node)))\n     return true;\n   max_callers = inline_summary (node)->size * 4 / edge_growth + 2;"}, {"sha": "97f9a00e36d10454bbb84c2f18af24a388cc1025", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "patch": "@@ -236,7 +236,7 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n     return true;\n   if (node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n-  /* When doing LTO or whole program, we can bring COMDAT functoins static.\n+  /* When doing LTO or whole program, we can bring COMDAT functions static.\n      This improves code quality and we know we will duplicate them at most twice\n      (in the case that we are not using plugin and link with object file\n       implementing same COMDAT)  */\n@@ -295,8 +295,6 @@ varpool_externally_visible_p (varpool_node *vnode)\n      Even if the linker clams the symbol is unused, never bring internal\n      symbols that are declared by user as used or externally visible.\n      This is needed for i.e. references from asm statements.   */\n-  if (symtab_used_from_object_file_p (vnode))\n-    return true;\n   if (vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n \n@@ -386,7 +384,8 @@ update_visibility_by_resolution_info (symtab_node * node)\n \n   if (!node->externally_visible\n       || (!DECL_WEAK (node->decl) && !DECL_ONE_ONLY (node->decl))\n-      || node->resolution == LDPR_UNKNOWN)\n+      || node->resolution == LDPR_UNKNOWN\n+      || node->resolution == LDPR_UNDEF)\n     return;\n \n   define = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n@@ -397,7 +396,7 @@ update_visibility_by_resolution_info (symtab_node * node)\n   if (node->same_comdat_group)\n     for (symtab_node *next = node->same_comdat_group;\n \t next != node; next = next->same_comdat_group)\n-      gcc_assert (!node->externally_visible\n+      gcc_assert (!next->externally_visible\n \t\t  || define == (next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t        || next->resolution == LDPR_PREVAILING_DEF\n \t\t\t        || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP));\n@@ -411,11 +410,15 @@ update_visibility_by_resolution_info (symtab_node * node)\n \tif (next->externally_visible\n \t    && !define)\n \t  DECL_EXTERNAL (next->decl) = true;\n+\tif (!next->alias)\n+\t  next->reset_section ();\n       }\n   node->set_comdat_group (NULL);\n   DECL_WEAK (node->decl) = false;\n   if (!define)\n     DECL_EXTERNAL (node->decl) = true;\n+  if (!node->alias)\n+    node->reset_section ();\n   symtab_dissolve_same_comdat_group_list (node);\n }\n \n@@ -476,7 +479,7 @@ function_and_variable_visibility (bool whole_program)\n \t  symtab_dissolve_same_comdat_group_list (node);\n \t}\n       gcc_assert ((!DECL_WEAK (node->decl)\n-\t\t  && !DECL_COMDAT (node->decl))\n+\t\t   && !DECL_COMDAT (node->decl))\n       \t          || TREE_PUBLIC (node->decl)\n \t\t  || node->weakref\n \t\t  || DECL_EXTERNAL (node->decl));\n@@ -494,6 +497,7 @@ function_and_variable_visibility (bool whole_program)\n \t  && node->definition && !node->weakref\n \t  && !DECL_EXTERNAL (node->decl))\n \t{\n+\t  bool reset = TREE_PUBLIC (node->decl);\n \t  gcc_assert (whole_program || in_lto_p\n \t\t      || !TREE_PUBLIC (node->decl));\n \t  node->unique_name = ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n@@ -512,9 +516,9 @@ function_and_variable_visibility (bool whole_program)\n \t\t     next = next->same_comdat_group)\n \t\t{\n \t\t  next->set_comdat_group (NULL);\n-\t\t  if (!next->alias)\n-\t\t    next->set_section (NULL);\n \t\t  symtab_make_decl_local (next->decl);\n+\t\t  if (!node->alias)\n+\t\t    node->reset_section ();\n \t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t\t|| next->unique_name\n \t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n@@ -528,9 +532,9 @@ function_and_variable_visibility (bool whole_program)\n \t    }\n \t  if (TREE_PUBLIC (node->decl))\n \t    node->set_comdat_group (NULL);\n-\t  if (DECL_COMDAT (node->decl) && !node->alias)\n-\t    node->set_section (NULL);\n \t  symtab_make_decl_local (node->decl);\n+\t  if (reset && !node->alias)\n+\t    node->reset_section ();\n \t}\n \n       if (node->thunk.thunk_p\n@@ -632,6 +636,7 @@ function_and_variable_visibility (bool whole_program)\n       if (!vnode->externally_visible\n \t  && !vnode->weakref)\n \t{\n+\t  bool reset = TREE_PUBLIC (vnode->decl);\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n \t  vnode->unique_name = ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t       || vnode->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n@@ -647,9 +652,9 @@ function_and_variable_visibility (bool whole_program)\n \t\t     next = next->same_comdat_group)\n \t\t{\n \t\t  next->set_comdat_group (NULL);\n-\t\t  if (!next->alias)\n-\t\t    next->set_section (NULL);\n \t\t  symtab_make_decl_local (next->decl);\n+\t\t  if (!next->alias)\n+\t\t    next->reset_section ();\n \t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t\t|| next->unique_name\n \t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n@@ -659,9 +664,9 @@ function_and_variable_visibility (bool whole_program)\n \t    }\n \t  if (TREE_PUBLIC (vnode->decl))\n \t    vnode->set_comdat_group (NULL);\n-\t  if (DECL_COMDAT (vnode->decl) && !vnode->alias)\n-\t    vnode->set_section (NULL);\n \t  symtab_make_decl_local (vnode->decl);\n+\t  if (reset && !vnode->alias)\n+\t    vnode->reset_section ();\n \t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t}\n       update_visibility_by_resolution_info (vnode);"}, {"sha": "b68a16fcde83b094d61a5d8cf041a435a7e08e8a", "filename": "gcc/symtab.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=24e49ea0b11e0ccfb2c18b7d79c5cb46f36f8db8", "patch": "@@ -1176,6 +1176,21 @@ symtab_node::set_section (const char *section)\n   symtab_for_node_and_aliases (this, set_section_1, const_cast<char *>(section), true);\n }\n \n+/* Reset section of NODE.  That is when NODE is being brought local\n+   we may want to clear section produced for comdat group and depending\n+   on function-sections produce now, local, unique section for it.  */\n+\n+void\n+symtab_node::reset_section ()\n+{\n+  if (!this->implicit_section)\n+    return;\n+  this->set_section (NULL);\n+  resolve_unique_section (this->decl, 0,\n+\t\t\t  is_a <cgraph_node *> (this)\n+\t\t\t  ? flag_function_sections : flag_data_sections);\n+}\n+\n /* Worker for symtab_resolve_alias.  */\n \n static bool"}]}