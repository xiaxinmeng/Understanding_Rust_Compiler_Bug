{"sha": "e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZmZDA5N2VmY2EyZTNmNzZkM2ZlNTFjNTVjZDEyNDk5OGI3ZmQ0Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-17T22:18:59Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-17T22:18:59Z"}, "message": "functiion.h (struct function): Add x_whole_function_mode_p.\n\n\t* functiion.h (struct function): Add x_whole_function_mode_p.\n\t(retrofit_block): Declare.\n\t* function.c (retrofit_block): New function.\n\t(identify_blocks): Add assertions.  Allow an incomplete set of\n\tblock notes if we're still generating code for the function.\n\t* integrate.c: Include loop.h.\n\t(expand_inline_function): Call find_loop_tree_blocks to map block\n\tnotes to blocks when in whole-function mode.  Use retrofit_block\n\tto insert new BLOCKs for the inlined function, rather than\n\tinsert_block.\n\t* stmt.c (expand_fixup): Likewise.  Don't use pushlevel/polevel.\n\t* Makefile.in (integrate.o): Depend on loop.h.\n\nFrom-SVN: r29487", "tree": {"sha": "746da641a670a45baec442090a6d5de50aee6389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/746da641a670a45baec442090a6d5de50aee6389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/comments", "author": null, "committer": null, "parents": [{"sha": "ba7166773bd7a4d1e0da5bad0a61c20fac3bef78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba7166773bd7a4d1e0da5bad0a61c20fac3bef78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba7166773bd7a4d1e0da5bad0a61c20fac3bef78"}], "stats": {"total": 123, "additions": 114, "deletions": 9}, "files": [{"sha": "1f0d6e67bbb716ebed85798e0dfff5b0c254df47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "patch": "@@ -1,3 +1,18 @@\n+Fri Sep 17 15:19:01 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* functiion.h (struct function): Add x_whole_function_mode_p.\n+\t(retrofit_block): Declare.\n+\t* function.c (retrofit_block): New function.\n+\t(identify_blocks): Add assertions.  Allow an incomplete set of\n+\tblock notes if we're still generating code for the function.\n+\t* integrate.c: Include loop.h.\n+\t(expand_inline_function): Call find_loop_tree_blocks to map block\n+\tnotes to blocks when in whole-function mode.  Use retrofit_block\n+\tto insert new BLOCKs for the inlined function, rather than\n+\tinsert_block.\n+\t* stmt.c (expand_fixup): Likewise.  Don't use pushlevel/polevel.\n+\t* Makefile.in (integrate.o): Depend on loop.h.\n+\n Fri Sep 17 15:11:20 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.h (warn_about_unused_variables): Declare."}, {"sha": "428f4f5d2553e181dfa75572fde8c1aa712748c6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "patch": "@@ -1519,7 +1519,7 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n real.o : real.c $(CONFIG_H) system.h $(TREE_H) toplev.h\n integrate.o : integrate.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    integrate.h insn-flags.h insn-config.h $(EXPR_H) real.h $(REGS_H) \\\n-   intl.h function.h output.h $(RECOG_H) except.h toplev.h\n+   intl.h function.h output.h $(RECOG_H) except.h toplev.h loop.h\n jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n    toplev.h insn-attr.h"}, {"sha": "ffbcd0185c4b14cc00ae1f4c81843a7dd013e300", "filename": "gcc/function.c", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "patch": "@@ -5381,6 +5381,49 @@ round_trampoline_addr (tramp)\n   return tramp;\n }\n \f\n+/* Insert the BLOCK in the block-tree before LAST_INSN.  */\n+\n+void\n+retrofit_block (block, last_insn)\n+     tree block;\n+     rtx last_insn;\n+{\n+  rtx insn;\n+\n+  /* Now insert the new BLOCK at the right place in the block trees\n+     for the function which called the inline function.  We just look\n+     backwards for a NOTE_INSN_BLOCK_{BEG,END}.  If we find the\n+     beginning of a block, then this new block becomes the first\n+     subblock of that block.  If we find the end of a block, then this\n+     new block follows that block in the list of blocks.  */\n+  for (insn = last_insn; insn; insn = PREV_INSN (insn))\n+    if (GET_CODE (insn) == NOTE\n+\t&& (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n+\t    || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n+      break;\n+  if (!insn || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n+    {\n+      tree superblock;\n+\n+      if (insn)\n+\tsuperblock = NOTE_BLOCK (insn);\n+      else\n+\tsuperblock = DECL_INITIAL (current_function_decl);\n+\n+      BLOCK_SUPERCONTEXT (block) = superblock;\n+      BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (superblock);\n+      BLOCK_SUBBLOCKS (superblock) = block;\n+    }\n+  else\n+    {\n+      tree prevblock = NOTE_BLOCK (insn);\n+\n+      BLOCK_SUPERCONTEXT (block) = BLOCK_SUPERCONTEXT (prevblock);\n+      BLOCK_CHAIN (block) = BLOCK_CHAIN (prevblock);\n+      BLOCK_CHAIN (prevblock) = block;\n+    }\n+}\n+\n /* The functions identify_blocks and reorder_blocks provide a way to\n    reorder the tree of BLOCK nodes, for optimizers that reshuffle or\n    duplicate portions of the RTL code.  Call identify_blocks before\n@@ -5423,15 +5466,30 @@ identify_blocks (block, insns)\n \t  {\n \t    tree b;\n \n+\t      /* If there are more block notes than BLOCKs, something\n+\t\t is badly wrong.  */\n+\t    if (current_block_number == n_blocks)\n+\t      abort ();\n+\n \t    b = block_vector[current_block_number++];\n \t    NOTE_BLOCK (insn) = b;\n \t    block_stack[depth++] = b;\n \t  }\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n-\t  NOTE_BLOCK (insn) = block_stack[--depth];\n+\telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t  {\n+\t    if (depth == 0)\n+\t      /* There are more NOTE_INSN_BLOCK_ENDs that\n+\t\t NOTE_INSN_BLOCK_BEGs.  Something is badly wrong.  */\n+\t      abort ();\n+\n+\t    NOTE_BLOCK (insn) = block_stack[--depth];\n+\t  }\n       }\n \n-  if (n_blocks != current_block_number)\n+  /* In whole-function mode, we might not have seen the whole function\n+     yet, so we might not use up all the blocks.  */\n+  if (n_blocks != current_block_number \n+      && !current_function->x_whole_function_mode_p)\n     abort ();\n \n   free (block_vector);"}, {"sha": "80053d20c3076a292f8400c21e7eccd7c2859a02", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "patch": "@@ -293,6 +293,12 @@ struct function\n   /* Number of function calls seen so far in current function.  */\n   int x_function_call_count;\n \n+  /* Nonzero if this function is being processed in function-at-a-time\n+     mode.  In other words, if all tree structure for this function,\n+     including the BLOCK tree is created, before RTL generation\n+     commences.  */\n+  int x_whole_function_mode_p;\n+\n   /* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels\n      (labels to which there can be nonlocal gotos from nested functions)\n      in this function.  */\n@@ -521,6 +527,8 @@ extern struct function *outer_function_chain;\n    Also store in each NOTE for the beginning or end of a block\n    the index of that block in the vector.  */\n extern void identify_blocks PROTO((tree, rtx));\n+/* Insert a new BLOCK at an appropriate place in the block tree.  */\n+extern void retrofit_block PROTO((tree, rtx));\n \n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;"}, {"sha": "e1b7990f21aee37b5345e46dec86dac31ce1ce1e", "filename": "gcc/integrate.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"toplev.h\"\n #include \"intl.h\"\n+#include \"loop.h\"\n \n #include \"obstack.h\"\n #define\tobstack_chunk_alloc\txmalloc\n@@ -74,8 +75,6 @@ static void set_decl_origin_self\tPROTO((tree));\n static void set_block_abstract_flags\tPROTO((tree, int));\n static void process_reg_param\t\tPROTO((struct inline_remap *, rtx,\n \t\t\t\t\t       rtx));\n-\n-\n void set_decl_abstract_flags\t\tPROTO((tree, int));\n static tree copy_and_set_decl_abstract_origin PROTO((tree));\n \n@@ -742,6 +741,11 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \tRTX_INTEGRATED_P (note) = 1;\n     }\n \n+  /* Figure out where the blocks are if we're going to have to insert\n+     new BLOCKs into the existing block tree.  */\n+  if (current_function->x_whole_function_mode_p)\n+    find_loop_tree_blocks ();\n+\n   /* Process each argument.  For each, set up things so that the function's\n      reference to the argument will refer to the argument being passed.\n      We only replace REG with REG here.  Any simplifications are done\n@@ -1279,7 +1283,16 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   BLOCK_ABSTRACT_ORIGIN (block) = (DECL_ABSTRACT_ORIGIN (fndecl) == NULL\n \t\t\t\t   ? fndecl : DECL_ABSTRACT_ORIGIN (fndecl));\n   inline_function_decl = 0;\n-  insert_block (block);\n+\n+  if (current_function->x_whole_function_mode_p)\n+    /* Insert the block into the already existing block-tree.  */\n+    retrofit_block (block, map->insns_at_start);\n+  else\n+    /* In statement-at-a-time mode, we just tell the front-end to add\n+       this block to the list of blocks at this binding level.  We\n+       can't do it the way it's done for function-at-a-time mode the\n+       superblocks have not been created yet.  */\n+    insert_block (block);\n \n   /* End the scope containing the copied formal parameter variables\n      and copied LABEL_DECLs.  We pass NULL_TREE for the variables list"}, {"sha": "5a9a25e11800079c39ecffe511c50c00f15325a2", "filename": "gcc/stmt.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6fd097efca2e3f76d3fe51c55cd124998b7fd42/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "patch": "@@ -1016,13 +1016,24 @@ expand_fixup (tree_label, rtl_label, last_insn)\n         register rtx original_before_jump\n           = last_insn ? last_insn : get_last_insn ();\n \trtx start;\n+\ttree block;\n+\n+\tblock = make_node (BLOCK);\n+\tTREE_USED (block) = 1;\n+\n+\tif (current_function->x_whole_function_mode_p)\n+\t  {\n+\t    find_loop_tree_blocks ();\n+\t    retrofit_block (block, original_before_jump);\n+\t  }\n+\telse\n+\t  insert_block (block);\n \n         start_sequence ();\n-        pushlevel (0);\n         start = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n \tfixup->before_jump = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n         last_block_end_note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n-        fixup->context = poplevel (1, 0, 0);  /* Create the BLOCK node now! */\n+        fixup->context = block;\n         end_sequence ();\n         emit_insns_after (start, original_before_jump);\n       }"}]}