{"sha": "3fe0ddc88334f9afd622458653a6d103948994bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZlMGRkYzg4MzM0ZjlhZmQ2MjI0NTg2NTNhNmQxMDM5NDg5OTRiZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2019-06-26T21:36:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-06-26T21:36:27Z"}, "message": "re PR tree-optimization/90883 (Generated code is worse if returned struct is unnamed)\n\n\tPR tree-optimization/90883\n\t* tree-ssa-alias.c (stmt_kills_ref_p): Handle BUILT_IN_CALLOC.\n\t* tree-ssa-dse.c: Update various comments to distinguish between\n\tdead and redundant stores.\n\t(initialize_ao_ref_for_dse): Handle BUILT_IN_CALLOC.\n\t(dse_optimize_redundant_stores): New function.\n\t(delete_dead_or_redundant_call): Renamed from delete_dead_call.\n\tDistinguish between dead and redundant calls in dump output.  All\n\tcallers updated.\n\t(delete_dead_or_redundant_assignment): Similarly for assignments.\n\t(dse_optimize_stmt): Handle _CHK variants.  For statements which\n\tstore 0 into multiple memory locations, try to prove a subsequent\n\tstore is redundant.\n\n        PR tree-optimization/90883\n\t* g++.dg/tree-ssa/pr90883.C: New test.\n\t* gcc.dg/tree-ssa/ssa-dse-36.c: New test.\n\nFrom-SVN: r272717", "tree": {"sha": "e8a0a198a8f1f0670e7862902b0f7deceeef4afd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8a0a198a8f1f0670e7862902b0f7deceeef4afd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fe0ddc88334f9afd622458653a6d103948994bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe0ddc88334f9afd622458653a6d103948994bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fe0ddc88334f9afd622458653a6d103948994bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe0ddc88334f9afd622458653a6d103948994bd/comments", "author": null, "committer": null, "parents": [{"sha": "9f962469cabc7fdc2ee830125a5cb4e61e1632e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f962469cabc7fdc2ee830125a5cb4e61e1632e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f962469cabc7fdc2ee830125a5cb4e61e1632e4"}], "stats": {"total": 283, "additions": 268, "deletions": 15}, "files": [{"sha": "eacda19dff1ff265bd6fac2d4bc546e29f4f2906", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fe0ddc88334f9afd622458653a6d103948994bd", "patch": "@@ -1,3 +1,19 @@\n+2019-06-26  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/90883\n+\t* tree-ssa-alias.c (stmt_kills_ref_p): Handle BUILT_IN_CALLOC.\n+\t* tree-ssa-dse.c: Update various comments to distinguish between\n+\tdead and redundant stores.\n+\t(initialize_ao_ref_for_dse): Handle BUILT_IN_CALLOC.\n+\t(dse_optimize_redundant_stores): New function.\n+\t(delete_dead_or_redundant_call): Renamed from delete_dead_call.\n+\tDistinguish between dead and redundant calls in dump output.  All\n+\tcallers updated.\n+\t(delete_dead_or_redundant_assignment): Similarly for assignments.\n+\t(dse_optimize_stmt): Handle _CHK variants.  For statements which\n+\tstore 0 into multiple memory locations, try to prove a subsequent\n+\tstore is redundant.\n+\n 2019-06-26  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/89021"}, {"sha": "eb5340122a4110dc8ae92301c699a6b2aaa7f639", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fe0ddc88334f9afd622458653a6d103948994bd", "patch": "@@ -1,3 +1,9 @@\n+2019-06-26  Jeff Law  <law@redhat.com>\n+\n+        PR tree-optimization/90883\n+\t* g++.dg/tree-ssa/pr90883.C: New test.\n+\t* gcc.dg/tree-ssa/ssa-dse-36.c: New test.\n+\n 2019-06-26  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/89021"}, {"sha": "005b2103b4b961456bf18b0d00bd0e24c5176de6", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr90883.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90883.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90883.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90883.C?ref=3fe0ddc88334f9afd622458653a6d103948994bd", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-O2 -fdump-tree-dse1-details -std=c++11\" }\n+\n+\n+    class C\n+    {\n+        char a[7]{};\n+        int b{};\n+    };\n+\n+    C slow()\n+    {\n+        return {};\n+    }\n+\n+\n+// We want to match enough here to capture that we deleted an empty\n+// constructor store\n+// { dg-final { scan-tree-dump \"Deleted redundant store: .*\\.a = {}\" \"dse1\" } }\n+"}, {"sha": "23a53bb4ad2fb909d9911991e97e574297aaf4fd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-36.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-36.c?ref=3fe0ddc88334f9afd622458653a6d103948994bd", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-options \"-O2 -fdump-tree-dse-details -fno-tree-fre\" } */\n+#include <string.h>\n+#include <stdlib.h>\n+\n+struct X\n+{\n+  char mem0[10];\n+  char mem1[10];\n+};\n+\n+\n+void blah (struct X);\n+\n+\n+void\n+foo1()\n+{\n+  struct X x = { };\n+  memset (x.mem1, 0, sizeof x.mem1);\n+  blah (x);\n+}\n+\n+void\n+foo2()\n+{\n+  struct X x = { };\n+  x.mem1[5] = 0;\n+  blah (x);\n+}\n+\n+void\n+bar1 ()\n+{\n+  struct X x;\n+  memset (&x, 0, sizeof x);\n+  memset (&x.mem1, 0, sizeof x.mem1);\n+  blah (x);\n+}\n+void\n+bar2 ()\n+{\n+  struct X x;\n+  memset (&x, 0, sizeof x);\n+  x.mem1[5] = 0;\n+  blah (x);\n+}\n+\n+void\n+baz1 ()\n+{\n+  struct X *x = calloc (sizeof (struct X), 1);\n+  memset (&x->mem1, 0, sizeof x->mem1);\n+  blah (*x);\n+}\n+\n+void\n+baz2 ()\n+{\n+  struct X *x = calloc (sizeof (struct X), 1);\n+  x->mem1[5] = 0;\n+  blah (*x);\n+}\n+/* { dg-final { scan-tree-dump-times \"Deleted redundant call\" 3 \"dse1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Deleted redundant store\" 3 \"dse1\" } } */\n+"}, {"sha": "6e7db2b03a6f06f70350cb29f9903954512e66ef", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=3fe0ddc88334f9afd622458653a6d103948994bd", "patch": "@@ -2849,13 +2849,36 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t  case BUILT_IN_MEMSET_CHK:\n \t  case BUILT_IN_STRNCPY:\n \t  case BUILT_IN_STPNCPY:\n+\t  case BUILT_IN_CALLOC:\n \t    {\n \t      /* For a must-alias check we need to be able to constrain\n \t\t the access properly.  */\n \t      if (!ref->max_size_known_p ())\n \t\treturn false;\n-\t      tree dest = gimple_call_arg (stmt, 0);\n-\t      tree len = gimple_call_arg (stmt, 2);\n+\t      tree dest;\n+\t      tree len;\n+\n+\t      /* In execution order a calloc call will never kill\n+\t\t anything.  However, DSE will (ab)use this interface\n+\t\t to ask if a calloc call writes the same memory locations\n+\t\t as a later assignment, memset, etc.  So handle calloc\n+\t\t in the expected way.  */\n+\t      if (DECL_FUNCTION_CODE (callee) == BUILT_IN_CALLOC)\n+\t\t{\n+\t\t  tree arg0 = gimple_call_arg (stmt, 0);\n+\t\t  tree arg1 = gimple_call_arg (stmt, 1);\n+\t\t  if (TREE_CODE (arg0) != INTEGER_CST\n+\t\t      || TREE_CODE (arg1) != INTEGER_CST)\n+\t\t    return false;\n+\n+\t\t  dest = gimple_call_lhs (stmt);\n+\t\t  len = fold_build2 (MULT_EXPR, TREE_TYPE (arg0), arg0, arg1);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dest = gimple_call_arg (stmt, 0);\n+\t\t  len = gimple_call_arg (stmt, 2);\n+\t\t}\n \t      if (!poly_int_tree_p (len))\n \t\treturn false;\n \t      tree rbase = ref->base;"}, {"sha": "9b4d19232ee0a83672acd676ee86a57fa988a862", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 137, "deletions": 13, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe0ddc88334f9afd622458653a6d103948994bd/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=3fe0ddc88334f9afd622458653a6d103948994bd", "patch": "@@ -1,4 +1,4 @@\n-/* Dead store elimination\n+/* Dead and redundant store elimination\n    Copyright (C) 2004-2019 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -41,12 +41,20 @@ along with GCC; see the file COPYING3.  If not see\n \n    A dead store is a store into a memory location which will later be\n    overwritten by another store without any intervening loads.  In this\n-   case the earlier store can be deleted.\n+   case the earlier store can be deleted or trimmed if the store\n+   was partially dead.\n+\n+   A redundant store is a store into a memory location which stores\n+   the exact same value as a prior store to the same memory location.\n+   While this can often be handled by dead store elimination, removing\n+   the redundant store is often better than removing or trimming the\n+   dead store.\n \n    In our SSA + virtual operand world we use immediate uses of virtual\n-   operands to detect dead stores.  If a store's virtual definition\n+   operands to detect these cases.  If a store's virtual definition\n    is used precisely once by a later store to the same location which\n-   post dominates the first store, then the first store is dead.\n+   post dominates the first store, then the first store is dead.  If\n+   the data stored is the same, then the second store is redundant.\n \n    The single use of the store's virtual definition ensures that\n    there are no intervening aliased loads and the requirement that\n@@ -58,14 +66,18 @@ along with GCC; see the file COPYING3.  If not see\n    the point immediately before the later store.  Again, the single\n    use of the virtual definition and the post-dominance relationship\n    ensure that such movement would be safe.  Clearly if there are\n-   back to back stores, then the second is redundant.\n+   back to back stores, then the second is makes the first dead.  If\n+   the second store stores the same value, then the second store is\n+   redundant.\n \n    Reviewing section 10.7.2 in Morgan's \"Building an Optimizing Compiler\"\n    may also help in understanding this code since it discusses the\n    relationship between dead store and redundant load elimination.  In\n    fact, they are the same transformation applied to different views of\n    the CFG.  */\n \n+static void delete_dead_or_redundant_assignment (gimple_stmt_iterator *, char []);\n+static void delete_dead_or_redundant_call (gimple_stmt_iterator *, char []);\n \n /* Bitmap of blocks that have had EH statements cleaned.  We should\n    remove their dead edges eventually.  */\n@@ -109,6 +121,25 @@ initialize_ao_ref_for_dse (gimple *stmt, ao_ref *write)\n \t      ao_ref_init_from_ptr_and_size (write, ptr, size);\n \t      return true;\n \t    }\n+\n+\t  /* A calloc call can never be dead, but it can make\n+\t     subsequent stores redundant if they store 0 into\n+\t     the same memory locations.  */\n+\t  case BUILT_IN_CALLOC:\n+\t    {\n+\t      tree nelem = gimple_call_arg (stmt, 0);\n+\t      tree selem = gimple_call_arg (stmt, 1);\n+\t      if (TREE_CODE (nelem) == INTEGER_CST\n+\t\t  && TREE_CODE (selem) == INTEGER_CST)\n+\t\t{\n+\t\t  tree lhs = gimple_call_lhs (stmt);\n+\t\t  tree size = fold_build2 (MULT_EXPR, TREE_TYPE (nelem),\n+\t\t\t\t\t   nelem, selem);\n+\t\t  ao_ref_init_from_ptr_and_size (write, lhs, size);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\n \t  default:\n \t    break;\n \t}\n@@ -557,6 +588,74 @@ check_name (tree, tree *idx, void *data)\n   return true;\n }\n \n+/* STMT stores the value 0 into one or more memory locations\n+   (via memset, empty constructor, calloc call, etc).\n+\n+   See if there is a subsequent store of the value 0 to one\n+   or more of the same memory location(s).  If so, the subsequent\n+   store is redundant and can be removed.\n+\n+   The subsequent stores could be via memset, empty constructors,\n+   simple MEM stores, etc.  */\n+\n+static void\n+dse_optimize_redundant_stores (gimple *stmt)\n+{\n+  int cnt = 0;\n+\n+  /* We could do something fairly complex and look through PHIs\n+     like DSE_CLASSIFY_STORE, but it doesn't seem to be worth\n+     the effort.\n+\n+     Look at all the immediate uses of the VDEF (which are obviously\n+     dominated by STMT).   See if one or more stores 0 into the same\n+     memory locations a STMT, if so remove the immediate use statements.  */\n+  tree defvar = gimple_vdef (stmt);\n+  imm_use_iterator ui;\n+  gimple *use_stmt;\n+  FOR_EACH_IMM_USE_STMT (use_stmt, ui, defvar)\n+    {\n+      /* Limit stmt walking.  */\n+      if (++cnt > PARAM_VALUE (PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE))\n+\tBREAK_FROM_IMM_USE_STMT (ui);\n+\n+      /* If USE_STMT stores 0 into one or more of the same locations\n+\t as STMT and STMT would kill USE_STMT, then we can just remove\n+\t USE_STMT.  */\n+      tree fndecl;\n+      if ((is_gimple_assign (use_stmt)\n+\t   && gimple_vdef (use_stmt)\n+\t   && ((gimple_assign_rhs_code (use_stmt) == CONSTRUCTOR\n+\t        && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (use_stmt)) == 0\n+\t        && !gimple_clobber_p (stmt))\n+\t       || (gimple_assign_rhs_code (use_stmt) == INTEGER_CST\n+\t\t   && integer_zerop (gimple_assign_rhs1 (use_stmt)))))\n+\t  || (gimple_call_builtin_p (use_stmt, BUILT_IN_NORMAL)\n+\t      && (fndecl = gimple_call_fndecl (use_stmt)) != NULL\n+\t      && (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMSET\n+\t\t  || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMSET_CHK)\n+\t      && integer_zerop (gimple_call_arg (use_stmt, 1))))\n+\t{\n+\t  ao_ref write;\n+\n+\t  if (!initialize_ao_ref_for_dse (use_stmt, &write))\n+\t    BREAK_FROM_IMM_USE_STMT (ui)\n+\n+\t  if (valid_ao_ref_for_dse (&write)\n+\t      && stmt_kills_ref_p (stmt, &write))\n+\t    {\n+\t      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+\t      if (is_gimple_assign (use_stmt))\n+\t\tdelete_dead_or_redundant_assignment (&gsi, \"redundant\");\n+\t      else if (is_gimple_call (use_stmt))\n+\t\tdelete_dead_or_redundant_call (&gsi, \"redundant\");\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t}\n+    }\n+}\n+\n /* A helper of dse_optimize_stmt.\n    Given a GIMPLE_ASSIGN in STMT that writes to REF, classify it\n    according to downstream uses and defs.  Sets *BY_CLOBBER_P to true\n@@ -769,12 +868,12 @@ class dse_dom_walker : public dom_walker\n \n /* Delete a dead call at GSI, which is mem* call of some kind.  */\n static void\n-delete_dead_call (gimple_stmt_iterator *gsi)\n+delete_dead_or_redundant_call (gimple_stmt_iterator *gsi, char *type)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"  Deleted dead call: \");\n+      fprintf (dump_file, \"  Deleted %s call: \", type);\n       print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n       fprintf (dump_file, \"\\n\");\n     }\n@@ -803,12 +902,12 @@ delete_dead_call (gimple_stmt_iterator *gsi)\n /* Delete a dead store at GSI, which is a gimple assignment. */\n \n static void\n-delete_dead_assignment (gimple_stmt_iterator *gsi)\n+delete_dead_or_redundant_assignment (gimple_stmt_iterator *gsi, char *type)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"  Deleted dead store: \");\n+      fprintf (dump_file, \"  Deleted %s store: \", type);\n       print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n       fprintf (dump_file, \"\\n\");\n     }\n@@ -861,7 +960,8 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n      some builtin calls.  */\n   if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n     {\n-      switch (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt)))\n+      tree fndecl = gimple_call_fndecl (stmt);\n+      switch (DECL_FUNCTION_CODE (fndecl))\n \t{\n \t  case BUILT_IN_MEMCPY:\n \t  case BUILT_IN_MEMMOVE:\n@@ -876,10 +976,18 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t      tree size = gimple_call_arg (stmt, 2);\n \t      if (integer_zerop (size))\n \t\t{\n-\t\t  delete_dead_call (gsi);\n+\t\t  delete_dead_or_redundant_call (gsi, \"dead\");\n \t\t  return;\n \t\t}\n \n+\t      /* If this is a memset call that initializes an object\n+\t\t to zero, it may be redundant with an earlier memset\n+\t\t or empty CONSTRUCTOR of a larger object.  */\n+\t      if ((DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMSET\n+\t\t   || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMSET_CHK)\n+\t\t  && integer_zerop (gimple_call_arg (stmt, 1)))\n+\t\tdse_optimize_redundant_stores (stmt);\n+\n \t      enum dse_store_status store_status;\n \t      m_byte_tracking_enabled\n \t\t= setup_live_bytes_from_ref (&ref, m_live_bytes);\n@@ -896,10 +1004,14 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t\t}\n \n \t      if (store_status == DSE_STORE_DEAD)\n-\t\tdelete_dead_call (gsi);\n+\t\tdelete_dead_or_redundant_call (gsi, \"dead\");\n \t      return;\n \t    }\n \n+\t  case BUILT_IN_CALLOC:\n+\t    /* We already know the arguments are integer constants.  */\n+\t    dse_optimize_redundant_stores (stmt);\n+\n \t  default:\n \t    return;\n \t}\n@@ -909,6 +1021,18 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n     {\n       bool by_clobber_p = false;\n \n+      /* First see if this store is a CONSTRUCTOR and if there\n+\t are subsequent CONSTRUCTOR stores which are totally\n+\t subsumed by this statement.  If so remove the subsequent\n+\t CONSTRUCTOR store.\n+\n+\t This will tend to make fewer calls into memset with longer\n+\t arguments.  */\n+      if (gimple_assign_rhs_code (stmt) == CONSTRUCTOR\n+\t  && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt)) == 0\n+\t  && !gimple_clobber_p (stmt))\n+\tdse_optimize_redundant_stores (stmt);\n+\n       /* Self-assignments are zombies.  */\n       if (operand_equal_p (gimple_assign_rhs1 (stmt),\n \t\t\t   gimple_assign_lhs (stmt), 0))\n@@ -939,7 +1063,7 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  && !by_clobber_p)\n \treturn;\n \n-      delete_dead_assignment (gsi);\n+      delete_dead_or_redundant_assignment (gsi, \"dead\");\n     }\n }\n "}]}