{"sha": "ef0feeb2f6b5ecad73f8d519929ebffab079031e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYwZmVlYjJmNmI1ZWNhZDczZjhkNTE5OTI5ZWJmZmFiMDc5MDMxZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-03-21T12:31:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-03-21T12:31:12Z"}, "message": "decl.c (components_to_record): Add REORDER parameter...\n\n\t* gcc-interface/decl.c (components_to_record): Add REORDER parameter,\n\trename DEBUG_INFO_P into DEBUG_INFO and move P_GNU_REP_LIST parameter\n\tto the end of the list.  Adjust recursive call.  Rename local variable.\n\tIf REORDER is true, reorder components of the record type.\n\t(gnat_to_gnu_entity): Pass OK_To_Reorder_Components flag as argument to\n\tcomponents_to_record and adjust the parameter list.\n\nFrom-SVN: r171228", "tree": {"sha": "c3d3c338888d0bed462a50385a7a017768f5a88b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3d3c338888d0bed462a50385a7a017768f5a88b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef0feeb2f6b5ecad73f8d519929ebffab079031e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef0feeb2f6b5ecad73f8d519929ebffab079031e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef0feeb2f6b5ecad73f8d519929ebffab079031e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef0feeb2f6b5ecad73f8d519929ebffab079031e/comments", "author": null, "committer": null, "parents": [{"sha": "c43d9a1b38d995014f72928cccfcfbbcbeb9ddfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43d9a1b38d995014f72928cccfcfbbcbeb9ddfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c43d9a1b38d995014f72928cccfcfbbcbeb9ddfe"}], "stats": {"total": 176, "additions": 123, "deletions": 53}, "files": [{"sha": "3ddcda5ad491ac871ea105e44de7937cc9e472dd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef0feeb2f6b5ecad73f8d519929ebffab079031e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef0feeb2f6b5ecad73f8d519929ebffab079031e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ef0feeb2f6b5ecad73f8d519929ebffab079031e", "patch": "@@ -1,3 +1,12 @@\n+2011-03-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (components_to_record): Add REORDER parameter,\n+\trename DEBUG_INFO_P into DEBUG_INFO and move P_GNU_REP_LIST parameter\n+\tto the end of the list.  Adjust recursive call.  Rename local variable.\n+\tIf REORDER is true, reorder components of the record type.\n+\t(gnat_to_gnu_entity): Pass OK_To_Reorder_Components flag as argument to\n+\tcomponents_to_record and adjust the parameter list.\n+\n 2011-03-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (elaborate_expression_1): When optimization is"}, {"sha": "ab571ab7b6c737f9d87a986c9e6d4a98144a5bfb", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 114, "deletions": 53, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef0feeb2f6b5ecad73f8d519929ebffab079031e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef0feeb2f6b5ecad73f8d519929ebffab079031e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ef0feeb2f6b5ecad73f8d519929ebffab079031e", "patch": "@@ -159,8 +159,8 @@ static bool array_type_has_nonaliased_component (tree, Entity_Id);\n static bool compile_time_known_address_p (Node_Id);\n static bool cannot_be_superflat_p (Node_Id);\n static bool constructor_address_p (tree);\n-static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n-\t\t\t\t  bool, bool, bool, bool, bool);\n+static void components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n+\t\t\t\t  bool, bool, bool, bool, tree *);\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n@@ -2951,9 +2951,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Add the fields into the record type and finish it up.  */\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n-\t\t\t      gnu_field_list, packed, definition, NULL,\n-\t\t\t      false, all_rep, is_unchecked_union,\n-\t\t\t      debug_info_p, false);\n+\t\t\t      gnu_field_list, packed, definition, false,\n+\t\t\t      all_rep, is_unchecked_union, debug_info_p,\n+\t\t\t      false, OK_To_Reorder_Components (gnat_entity),\n+\t\t\t      NULL);\n \n \t/* If it is passed by reference, force BLKmode to ensure that objects\n \t   of this type will always be put in memory.  */\n@@ -6992,10 +6993,6 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n \n    DEFINITION is true if we are defining this record type.\n \n-   P_GNU_REP_LIST, if nonzero, is a pointer to a list to which each field\n-   with a rep clause is to be added; in this case, that is all that should\n-   be done with such fields.\n-\n    CANCEL_ALIGNMENT is true if the alignment should be zeroed before laying\n    out the record.  This means the alignment only serves to force fields to\n    be bitfields, but not to require the record to be that aligned.  This is\n@@ -7006,27 +7003,37 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n    UNCHECKED_UNION is true if we are building this type for a record with a\n    Pragma Unchecked_Union.\n \n-   DEBUG_INFO_P is true if we need to write debug information about the type.\n+   DEBUG_INFO is true if we need to write debug information about the type.\n \n    MAYBE_UNUSED is true if this type may be unused in the end; this doesn't\n-   mean that its contents may be unused as well, but only the container.  */\n+   mean that its contents may be unused as well, only the container itself.\n \n+   REORDER is true if we are permitted to reorder components of this type.\n+\n+   P_GNU_REP_LIST, if nonzero, is a pointer to a list to which each field\n+   with a rep clause is to be added; in this case, that is all that should\n+   be done with such fields.  */\n \n static void\n components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t      tree gnu_field_list, int packed, bool definition,\n-\t\t      tree *p_gnu_rep_list, bool cancel_alignment,\n-\t\t      bool all_rep, bool unchecked_union, bool debug_info_p,\n-\t\t      bool maybe_unused)\n+\t\t      bool cancel_alignment, bool all_rep,\n+\t\t      bool unchecked_union, bool debug_info,\n+\t\t      bool maybe_unused, bool reorder,\n+\t\t      tree *p_gnu_rep_list)\n {\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n   bool layout_with_rep = false;\n   Node_Id component_decl, variant_part;\n-  tree gnu_our_rep_list = NULL_TREE;\n-  tree gnu_field, gnu_next, gnu_last = tree_last (gnu_field_list);\n+  tree gnu_field, gnu_next, gnu_last;\n+  tree gnu_variant_part = NULL_TREE;\n+  tree gnu_rep_list = NULL_TREE;\n+  tree gnu_var_list = NULL_TREE;\n+  tree gnu_self_list = NULL_TREE;\n \n   /* For each component referenced in a component declaration create a GCC\n      field and add it to the list, skipping pragmas in the GNAT list.  */\n+  gnu_last = tree_last (gnu_field_list);\n   if (Present (Component_Items (gnat_component_list)))\n     for (component_decl\n \t   = First_Non_Pragma (Component_Items (gnat_component_list));\n@@ -7046,7 +7053,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \telse\n \t  {\n \t    gnu_field = gnat_to_gnu_field (gnat_field, gnu_record_type, packed,\n-\t\t\t\t\t   definition, debug_info_p);\n+\t\t\t\t\t   definition, debug_info);\n \n \t    /* If this is the _Tag field, put it before any other fields.  */\n \t    if (gnat_name == Name_uTag)\n@@ -7091,7 +7098,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       tree gnu_var_name\n \t= concat_name (get_identifier (Get_Name_String (Chars (gnat_discr))),\n \t\t       \"XVN\");\n-      tree gnu_union_type, gnu_union_name, gnu_union_field;\n+      tree gnu_union_type, gnu_union_name;\n       tree gnu_variant_list = NULL_TREE;\n \n       if (TREE_CODE (gnu_name) == TYPE_DECL)\n@@ -7151,8 +7158,9 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t     we aren't sure to really use it at this point, see below.  */\n \t  components_to_record (gnu_variant_type, Component_List (variant),\n \t\t\t\tNULL_TREE, packed, definition,\n-\t\t\t\t&gnu_our_rep_list, !all_rep_and_size, all_rep,\n-\t\t\t\tunchecked_union, debug_info_p, true);\n+\t\t\t\t!all_rep_and_size, all_rep,\n+\t\t\t\tunchecked_union, debug_info,\n+\t\t\t\ttrue, reorder, &gnu_rep_list);\n \n \t  gnu_qual = choices_to_gnu (gnu_discr, Discrete_Choices (variant));\n \n@@ -7177,7 +7185,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t the fields associated with these empty variants.  */\n \t      rest_of_record_type_compilation (gnu_variant_type);\n \t      create_type_decl (TYPE_NAME (gnu_variant_type), gnu_variant_type,\n-\t\t\t\tNULL, true, debug_info_p, gnat_component_list);\n+\t\t\t\tNULL, true, debug_info, gnat_component_list);\n \n \t      gnu_field\n \t\t= create_field_decl (gnu_inner_name, gnu_variant_type,\n@@ -7211,7 +7219,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t    }\n \n \t  finish_record_type (gnu_union_type, nreverse (gnu_variant_list),\n-\t\t\t      all_rep_and_size ? 1 : 0, debug_info_p);\n+\t\t\t      all_rep_and_size ? 1 : 0, debug_info);\n \n \t  /* If GNU_UNION_TYPE is our record type, it means we must have an\n \t     Unchecked_Union with no fields.  Verify that and, if so, just\n@@ -7220,71 +7228,124 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t    {\n \t      gcc_assert (unchecked_union\n \t\t\t  && !gnu_field_list\n-\t\t\t  && !gnu_our_rep_list);\n+\t\t\t  && !gnu_rep_list);\n \t      return;\n \t    }\n \n \t  create_type_decl (TYPE_NAME (gnu_union_type), gnu_union_type,\n-\t\t\t    NULL, true, debug_info_p, gnat_component_list);\n+\t\t\t    NULL, true, debug_info, gnat_component_list);\n \n \t  /* Deal with packedness like in gnat_to_gnu_field.  */\n \t  union_field_packed\n \t    = adjust_packed (gnu_union_type, gnu_record_type, packed);\n \n-\t  gnu_union_field\n+\t  gnu_variant_part\n \t    = create_field_decl (gnu_var_name, gnu_union_type, gnu_record_type,\n \t\t\t\t all_rep ? TYPE_SIZE (gnu_union_type) : 0,\n \t\t\t\t all_rep ? bitsize_zero_node : 0,\n \t\t\t\t union_field_packed, 0);\n \n-\t  DECL_INTERNAL_P (gnu_union_field) = 1;\n-\t  DECL_CHAIN (gnu_union_field) = gnu_field_list;\n-\t  gnu_field_list = gnu_union_field;\n+\t  DECL_INTERNAL_P (gnu_variant_part) = 1;\n+\t  DECL_CHAIN (gnu_variant_part) = gnu_field_list;\n+\t  gnu_field_list = gnu_variant_part;\n \t}\n     }\n \n-  /* Scan GNU_FIELD_LIST and see if any fields have rep clauses.  If they\n-     do, pull them out and put them into GNU_OUR_REP_LIST.  We have to do\n-     this in a separate pass since we want to handle the discriminants but\n-     can't play with them until we've used them in debugging data above.\n+  /* Scan GNU_FIELD_LIST and see if any fields have rep clauses and, if we are\n+     permitted to reorder components, self-referential sizes or variable sizes.\n+     If they do, pull them out and put them onto the appropriate list.  We have\n+     to do this in a separate pass since we want to handle the discriminants\n+     but can't play with them until we've used them in debugging data above.\n \n-     ??? If we then reorder them, debugging information will be wrong but\n-     there's nothing that can be done about this at the moment.  */\n+     ??? If we reorder them, debugging information will be wrong but there is\n+     nothing that can be done about this at the moment.  */\n   gnu_last = NULL_TREE;\n+\n+#define MOVE_FROM_FIELD_LIST_TO(LIST)\t\\\n+  do {\t\t\t\t\t\\\n+    if (gnu_last)\t\t\t\\\n+      DECL_CHAIN (gnu_last) = gnu_next;\t\\\n+    else\t\t\t\t\\\n+      gnu_field_list = gnu_next;\t\\\n+\t\t\t\t\t\\\n+    DECL_CHAIN (gnu_field) = (LIST);\t\\\n+    (LIST) = gnu_field;\t\t\t\\\n+  } while (0)\n+\n   for (gnu_field = gnu_field_list; gnu_field; gnu_field = gnu_next)\n     {\n       gnu_next = DECL_CHAIN (gnu_field);\n \n       if (DECL_FIELD_OFFSET (gnu_field))\n \t{\n-\t  if (!gnu_last)\n-\t    gnu_field_list = gnu_next;\n-\t  else\n-\t    DECL_CHAIN (gnu_last) = gnu_next;\n+\t  MOVE_FROM_FIELD_LIST_TO (gnu_rep_list);\n+\t  continue;\n+\t}\n+\n+      if (reorder)\n+\t{\n+\t  /* Pull out the variant part and put it onto GNU_SELF_LIST.  */\n+\t  if (gnu_field == gnu_variant_part)\n+\t    {\n+\t      MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n+\t      continue;\n+\t    }\n \n-\t  DECL_CHAIN (gnu_field) = gnu_our_rep_list;\n-\t  gnu_our_rep_list = gnu_field;\n+\t  /* Skip internal fields and fields with fixed size.  */\n+\t  if (!DECL_INTERNAL_P (gnu_field)\n+\t      && !(DECL_SIZE (gnu_field)\n+\t\t   && TREE_CODE (DECL_SIZE (gnu_field)) == INTEGER_CST))\n+\t    {\n+\t      tree type_size = TYPE_SIZE (TREE_TYPE (gnu_field));\n+\n+\t      if (CONTAINS_PLACEHOLDER_P (type_size))\n+\t\t{\n+\t\t  MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (TREE_CODE (type_size) != INTEGER_CST)\n+\t\t{\n+\t\t  MOVE_FROM_FIELD_LIST_TO (gnu_var_list);\n+\t\t  continue;\n+\t\t}\n+\t    }\n \t}\n-      else\n-\tgnu_last = gnu_field;\n+\n+      gnu_last = gnu_field;\n     }\n \n+#undef MOVE_FROM_FIELD_LIST_TO\n+\n+  /* If permitted, we reorder the components as follows:\n+\n+       1) all fixed length fields,\n+       2) all fields whose length doesn't depend on discriminants,\n+       3) all fields whose length depends on discriminants,\n+       4) the variant part,\n+\n+     within the record and within each variant recursively.  */\n+  if (reorder)\n+    gnu_field_list\n+      = chainon (nreverse (gnu_self_list),\n+\t\t chainon (nreverse (gnu_var_list), gnu_field_list));\n+\n   /* If we have any fields in our rep'ed field list and it is not the case that\n      all the fields in the record have rep clauses and P_REP_LIST is nonzero,\n      set it and ignore these fields.  */\n-  if (gnu_our_rep_list && p_gnu_rep_list && !all_rep)\n-    *p_gnu_rep_list = chainon (*p_gnu_rep_list, gnu_our_rep_list);\n+  if (gnu_rep_list && p_gnu_rep_list && !all_rep)\n+    *p_gnu_rep_list = chainon (*p_gnu_rep_list, gnu_rep_list);\n \n   /* Otherwise, sort the fields by bit position and put them into their own\n      record, before the others, if we also have fields without rep clauses.  */\n-  else if (gnu_our_rep_list)\n+  else if (gnu_rep_list)\n     {\n       tree gnu_rep_type\n \t= (gnu_field_list ? make_node (RECORD_TYPE) : gnu_record_type);\n-      int i, len = list_length (gnu_our_rep_list);\n+      int i, len = list_length (gnu_rep_list);\n       tree *gnu_arr = XALLOCAVEC (tree, len);\n \n-      for (gnu_field = gnu_our_rep_list, i = 0;\n+      for (gnu_field = gnu_rep_list, i = 0;\n \t   gnu_field;\n \t   gnu_field = DECL_CHAIN (gnu_field), i++)\n \tgnu_arr[i] = gnu_field;\n@@ -7293,17 +7354,17 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \n       /* Put the fields in the list in order of increasing position, which\n \t means we start from the end.  */\n-      gnu_our_rep_list = NULL_TREE;\n+      gnu_rep_list = NULL_TREE;\n       for (i = len - 1; i >= 0; i--)\n \t{\n-\t  DECL_CHAIN (gnu_arr[i]) = gnu_our_rep_list;\n-\t  gnu_our_rep_list = gnu_arr[i];\n+\t  DECL_CHAIN (gnu_arr[i]) = gnu_rep_list;\n+\t  gnu_rep_list = gnu_arr[i];\n \t  DECL_CONTEXT (gnu_arr[i]) = gnu_rep_type;\n \t}\n \n       if (gnu_field_list)\n \t{\n-\t  finish_record_type (gnu_rep_type, gnu_our_rep_list, 1, debug_info_p);\n+\t  finish_record_type (gnu_rep_type, gnu_rep_list, 1, debug_info);\n \t  gnu_field\n \t    = create_field_decl (get_identifier (\"REP\"), gnu_rep_type,\n \t\t\t\t gnu_record_type, NULL_TREE, NULL_TREE, 0, 1);\n@@ -7313,15 +7374,15 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       else\n \t{\n \t  layout_with_rep = true;\n-\t  gnu_field_list = nreverse (gnu_our_rep_list);\n+\t  gnu_field_list = nreverse (gnu_rep_list);\n \t}\n     }\n \n   if (cancel_alignment)\n     TYPE_ALIGN (gnu_record_type) = 0;\n \n   finish_record_type (gnu_record_type, nreverse (gnu_field_list),\n-\t\t      layout_with_rep ? 1 : 0, debug_info_p && !maybe_unused);\n+\t\t      layout_with_rep ? 1 : 0, debug_info && !maybe_unused);\n }\n \f\n /* Given GNU_SIZE, a GCC tree representing a size, return a Uint to be"}]}