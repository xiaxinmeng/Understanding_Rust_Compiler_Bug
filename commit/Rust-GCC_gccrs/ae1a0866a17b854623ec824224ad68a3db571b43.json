{"sha": "ae1a0866a17b854623ec824224ad68a3db571b43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUxYTA4NjZhMTdiODU0NjIzZWM4MjQyMjRhZDY4YTNkYjU3MWI0Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-16T14:20:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-16T14:20:40Z"}, "message": "An alternative fix for PR70944\n\nThe transformations made by make_compound_operation apply\nonly to scalar integer modes.  The fix for PR70944 had enforced\nthat by returning early for vector modes at the top of the\nfunction.  However, the function is supposed to be recursive,\nso we should continue to look at integer suboperands even if\nthe outer operation is a vector one.\n\nThis patch instead splits out the non-recursive parts\nof make_compound_operation into a subroutine and checks\nthat the mode is a scalar integer before calling it.\nThe patch was originally written to help with the later\nconversion to static type checking of mode classes, but it\nalso happened to reenable optimisation of things like\nvec_duplicate operands.\n\nNote that the gen_lowparts in the PLUS and MINUS cases\nwere redundant, since new_rtx already had mode \"mode\"\nat those points.\n\ngcc/\n2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* combine.c (maybe_swap_commutative_operands): New function.\n\t(combine_simplify_rtx): Use it.\n\t(change_zero_ext): Likewise.\n\t(make_compound_operation_int): New function, split out of...\n\t(make_compound_operation): ...here.  Use\n\tmaybe_swap_commutative_operands for both.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r242492", "tree": {"sha": "0bcd5914eb382b11bba28bec7e24f2bbc32e6aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bcd5914eb382b11bba28bec7e24f2bbc32e6aa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae1a0866a17b854623ec824224ad68a3db571b43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1a0866a17b854623ec824224ad68a3db571b43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1a0866a17b854623ec824224ad68a3db571b43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1a0866a17b854623ec824224ad68a3db571b43/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c012e9bf7a7c16283091714f18f8aa3633d89b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c012e9bf7a7c16283091714f18f8aa3633d89b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c012e9bf7a7c16283091714f18f8aa3633d89b6"}], "stats": {"total": 172, "additions": 98, "deletions": 74}, "files": [{"sha": "722b94bff35b498c3279c87fdd98962857285889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1a0866a17b854623ec824224ad68a3db571b43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1a0866a17b854623ec824224ad68a3db571b43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae1a0866a17b854623ec824224ad68a3db571b43", "patch": "@@ -1,3 +1,14 @@\n+2016-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (maybe_swap_commutative_operands): New function.\n+\t(combine_simplify_rtx): Use it.\n+\t(change_zero_ext): Likewise.\n+\t(make_compound_operation_int): New function, split out of...\n+\t(make_compound_operation): ...here.  Use\n+\tmaybe_swap_commutative_operands for both.\n+\n 2016-11-16  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm/arm-fpus.def (vfpv2): New FPU, currently an alias for 'vfp'."}, {"sha": "ca5ddae9c78c22a6dfce04367015c7ebb855dfa0", "filename": "gcc/combine.c", "status": "modified", "additions": 87, "deletions": 74, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1a0866a17b854623ec824224ad68a3db571b43/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1a0866a17b854623ec824224ad68a3db571b43/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ae1a0866a17b854623ec824224ad68a3db571b43", "patch": "@@ -5479,6 +5479,21 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n   return x;\n }\n \f\n+/* If X is a commutative operation whose operands are not in the canonical\n+   order, use substitutions to swap them.  */\n+\n+static void\n+maybe_swap_commutative_operands (rtx x)\n+{\n+  if (COMMUTATIVE_ARITH_P (x)\n+      && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n+    {\n+      rtx temp = XEXP (x, 0);\n+      SUBST (XEXP (x, 0), XEXP (x, 1));\n+      SUBST (XEXP (x, 1), temp);\n+    }\n+}\n+\n /* Simplify X, a piece of RTL.  We just operate on the expression at the\n    outer level; call `subst' to simplify recursively.  Return the new\n    expression.\n@@ -5498,13 +5513,7 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \n   /* If this is a commutative operation, put a constant last and a complex\n      expression first.  We don't need to do this for comparisons here.  */\n-  if (COMMUTATIVE_ARITH_P (x)\n-      && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n-    {\n-      temp = XEXP (x, 0);\n-      SUBST (XEXP (x, 0), XEXP (x, 1));\n-      SUBST (XEXP (x, 1), temp);\n-    }\n+  maybe_swap_commutative_operands (x);\n \n   /* Try to fold this expression in case we have constants that weren't\n      present before.  */\n@@ -7744,55 +7753,38 @@ extract_left_shift (rtx x, int count)\n   return 0;\n }\n \f\n-/* Look at the expression rooted at X.  Look for expressions\n-   equivalent to ZERO_EXTRACT, SIGN_EXTRACT, ZERO_EXTEND, SIGN_EXTEND.\n-   Form these expressions.\n-\n-   Return the new rtx, usually just X.\n+/* Subroutine of make_compound_operation.  *X_PTR is the rtx at the current\n+   level of the expression and MODE is its mode.  IN_CODE is as for\n+   make_compound_operation.  *NEXT_CODE_PTR is the value of IN_CODE\n+   that should be used when recursing on operands of *X_PTR.\n \n-   Also, for machines like the VAX that don't have logical shift insns,\n-   try to convert logical to arithmetic shift operations in cases where\n-   they are equivalent.  This undoes the canonicalizations to logical\n-   shifts done elsewhere.\n+   There are two possible actions:\n \n-   We try, as much as possible, to re-use rtl expressions to save memory.\n+   - Return null.  This tells the caller to recurse on *X_PTR with IN_CODE\n+     equal to *NEXT_CODE_PTR, after which *X_PTR holds the final value.\n \n-   IN_CODE says what kind of expression we are processing.  Normally, it is\n-   SET.  In a memory address it is MEM.  When processing the arguments of\n-   a comparison or a COMPARE against zero, it is COMPARE, or EQ if more\n-   precisely it is an equality comparison against zero.  */\n+   - Return a new rtx, which the caller returns directly.  */\n \n-rtx\n-make_compound_operation (rtx x, enum rtx_code in_code)\n+static rtx\n+make_compound_operation_int (machine_mode mode, rtx *x_ptr,\n+\t\t\t     enum rtx_code in_code,\n+\t\t\t     enum rtx_code *next_code_ptr)\n {\n+  rtx x = *x_ptr;\n+  enum rtx_code next_code = *next_code_ptr;\n   enum rtx_code code = GET_CODE (x);\n-  machine_mode mode = GET_MODE (x);\n   int mode_width = GET_MODE_PRECISION (mode);\n   rtx rhs, lhs;\n-  enum rtx_code next_code;\n-  int i, j;\n   rtx new_rtx = 0;\n+  int i;\n   rtx tem;\n-  const char *fmt;\n   bool equality_comparison = false;\n \n-  /* PR rtl-optimization/70944.  */\n-  if (VECTOR_MODE_P (mode))\n-    return x;\n-\n-  /* Select the code to be used in recursive calls.  Once we are inside an\n-     address, we stay there.  If we have a comparison, set to COMPARE,\n-     but once inside, go back to our default of SET.  */\n-\n   if (in_code == EQ)\n     {\n       equality_comparison = true;\n       in_code = COMPARE;\n     }\n-  next_code = (code == MEM ? MEM\n-\t       : ((code == COMPARE || COMPARISON_P (x))\n-\t\t  && XEXP (x, 1) == const0_rtx) ? COMPARE\n-\t       : in_code == COMPARE ? SET : in_code);\n \n   /* Process depending on the code of this operation.  If NEW is set\n      nonzero, it will be returned.  */\n@@ -7804,8 +7796,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t an address.  */\n       if (in_code == MEM && CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT\n-\t  && INTVAL (XEXP (x, 1)) >= 0\n-\t  && SCALAR_INT_MODE_P (mode))\n+\t  && INTVAL (XEXP (x, 1)) >= 0)\n \t{\n \t  HOST_WIDE_INT count = INTVAL (XEXP (x, 1));\n \t  HOST_WIDE_INT multval = HOST_WIDE_INT_1 << count;\n@@ -7826,8 +7817,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n       rhs = XEXP (x, 1);\n       lhs = make_compound_operation (lhs, next_code);\n       rhs = make_compound_operation (rhs, next_code);\n-      if (GET_CODE (lhs) == MULT && GET_CODE (XEXP (lhs, 0)) == NEG\n-\t  && SCALAR_INT_MODE_P (mode))\n+      if (GET_CODE (lhs) == MULT && GET_CODE (XEXP (lhs, 0)) == NEG)\n \t{\n \t  tem = simplify_gen_binary (MULT, mode, XEXP (XEXP (lhs, 0), 0),\n \t\t\t\t     XEXP (lhs, 1));\n@@ -7846,22 +7836,20 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t{\n \t  SUBST (XEXP (x, 0), lhs);\n \t  SUBST (XEXP (x, 1), rhs);\n-\t  goto maybe_swap;\n \t}\n-      x = gen_lowpart (mode, new_rtx);\n-      goto maybe_swap;\n+      maybe_swap_commutative_operands (x);\n+      return x;\n \n     case MINUS:\n       lhs = XEXP (x, 0);\n       rhs = XEXP (x, 1);\n       lhs = make_compound_operation (lhs, next_code);\n       rhs = make_compound_operation (rhs, next_code);\n-      if (GET_CODE (rhs) == MULT && GET_CODE (XEXP (rhs, 0)) == NEG\n-\t  && SCALAR_INT_MODE_P (mode))\n+      if (GET_CODE (rhs) == MULT && GET_CODE (XEXP (rhs, 0)) == NEG)\n \t{\n \t  tem = simplify_gen_binary (MULT, mode, XEXP (XEXP (rhs, 0), 0),\n \t\t\t\t     XEXP (rhs, 1));\n-\t  new_rtx = simplify_gen_binary (PLUS, mode, tem, lhs);\n+\t  return simplify_gen_binary (PLUS, mode, tem, lhs);\n \t}\n       else if (GET_CODE (rhs) == MULT\n \t       && (CONST_INT_P (XEXP (rhs, 1)) && INTVAL (XEXP (rhs, 1)) < 0))\n@@ -7870,15 +7858,14 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t\t\t\t     simplify_gen_unary (NEG, mode,\n \t\t\t\t\t\t\t XEXP (rhs, 1),\n \t\t\t\t\t\t\t mode));\n-\t  new_rtx = simplify_gen_binary (PLUS, mode, tem, lhs);\n+\t  return simplify_gen_binary (PLUS, mode, tem, lhs);\n \t}\n       else\n \t{\n \t  SUBST (XEXP (x, 0), lhs);\n \t  SUBST (XEXP (x, 1), rhs);\n \t  return x;\n \t}\n-      return gen_lowpart (mode, new_rtx);\n \n     case AND:\n       /* If the second operand is not a constant, we can't do anything\n@@ -8171,15 +8158,60 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n     }\n \n   if (new_rtx)\n+    *x_ptr = gen_lowpart (mode, new_rtx);\n+  *next_code_ptr = next_code;\n+  return NULL_RTX;\n+}\n+\n+/* Look at the expression rooted at X.  Look for expressions\n+   equivalent to ZERO_EXTRACT, SIGN_EXTRACT, ZERO_EXTEND, SIGN_EXTEND.\n+   Form these expressions.\n+\n+   Return the new rtx, usually just X.\n+\n+   Also, for machines like the VAX that don't have logical shift insns,\n+   try to convert logical to arithmetic shift operations in cases where\n+   they are equivalent.  This undoes the canonicalizations to logical\n+   shifts done elsewhere.\n+\n+   We try, as much as possible, to re-use rtl expressions to save memory.\n+\n+   IN_CODE says what kind of expression we are processing.  Normally, it is\n+   SET.  In a memory address it is MEM.  When processing the arguments of\n+   a comparison or a COMPARE against zero, it is COMPARE, or EQ if more\n+   precisely it is an equality comparison against zero.  */\n+\n+rtx\n+make_compound_operation (rtx x, enum rtx_code in_code)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt;\n+  int i, j;\n+  enum rtx_code next_code;\n+  rtx new_rtx, tem;\n+\n+  /* Select the code to be used in recursive calls.  Once we are inside an\n+     address, we stay there.  If we have a comparison, set to COMPARE,\n+     but once inside, go back to our default of SET.  */\n+\n+  next_code = (code == MEM ? MEM\n+\t       : ((code == COMPARE || COMPARISON_P (x))\n+\t\t  && XEXP (x, 1) == const0_rtx) ? COMPARE\n+\t       : in_code == COMPARE || in_code == EQ ? SET : in_code);\n+\n+  if (SCALAR_INT_MODE_P (GET_MODE (x)))\n     {\n-      x = gen_lowpart (mode, new_rtx);\n+      rtx new_rtx = make_compound_operation_int (GET_MODE (x), &x,\n+\t\t\t\t\t\t in_code, &next_code);\n+      if (new_rtx)\n+\treturn new_rtx;\n       code = GET_CODE (x);\n     }\n \n   /* Now recursively process each operand of this operation.  We need to\n      handle ZERO_EXTEND specially so that we don't lose track of the\n      inner mode.  */\n-  if (GET_CODE (x) == ZERO_EXTEND)\n+  if (code == ZERO_EXTEND)\n     {\n       new_rtx = make_compound_operation (XEXP (x, 0), next_code);\n       tem = simplify_const_unary_operation (ZERO_EXTEND, GET_MODE (x),\n@@ -8204,17 +8236,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t  SUBST (XVECEXP (x, i, j), new_rtx);\n \t}\n \n- maybe_swap:\n-  /* If this is a commutative operation, the changes to the operands\n-     may have made it noncanonical.  */\n-  if (COMMUTATIVE_ARITH_P (x)\n-      && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n-    {\n-      tem = XEXP (x, 0);\n-      SUBST (XEXP (x, 0), XEXP (x, 1));\n-      SUBST (XEXP (x, 1), tem);\n-    }\n-\n+  maybe_swap_commutative_operands (x);\n   return x;\n }\n \f\n@@ -11220,16 +11242,7 @@ change_zero_ext (rtx pat)\n \n   if (changed)\n     FOR_EACH_SUBRTX_PTR (iter, array, src, NONCONST)\n-      {\n-\trtx x = **iter;\n-\tif (COMMUTATIVE_ARITH_P (x)\n-\t    && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n-\t  {\n-\t    rtx tem = XEXP (x, 0);\n-\t    SUBST (XEXP (x, 0), XEXP (x, 1));\n-\t    SUBST (XEXP (x, 1), tem);\n-\t  }\n-      }\n+      maybe_swap_commutative_operands (**iter);\n \n   rtx *dst = &SET_DEST (pat);\n   if (GET_CODE (*dst) == ZERO_EXTRACT"}]}