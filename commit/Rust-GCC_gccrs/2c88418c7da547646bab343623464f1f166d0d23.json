{"sha": "2c88418c7da547646bab343623464f1f166d0d23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4ODQxOGM3ZGE1NDc2NDZiYWIzNDM2MjM0NjRmMWYxNjZkMGQyMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-01T05:13:56Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-01T05:13:56Z"}, "message": "Initial revision\n\nFrom-SVN: r92", "tree": {"sha": "f29bbb3bafe27603cf944234c9890d3014a83490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f29bbb3bafe27603cf944234c9890d3014a83490"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c88418c7da547646bab343623464f1f166d0d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c88418c7da547646bab343623464f1f166d0d23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c88418c7da547646bab343623464f1f166d0d23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c88418c7da547646bab343623464f1f166d0d23/comments", "author": null, "committer": null, "parents": [{"sha": "e472c795635cea4eba88e477a9b1caf264f96791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e472c795635cea4eba88e477a9b1caf264f96791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e472c795635cea4eba88e477a9b1caf264f96791"}], "stats": {"total": 1574, "additions": 1574, "deletions": 0}, "files": [{"sha": "95271f0465176ad453c09f2ea876299751230dfb", "filename": "gcc/rtlanal.c", "status": "added", "additions": 1574, "deletions": 0, "changes": 1574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c88418c7da547646bab343623464f1f166d0d23/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c88418c7da547646bab343623464f1f166d0d23/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=2c88418c7da547646bab343623464f1f166d0d23", "patch": "@@ -0,0 +1,1574 @@\n+/* Analyze RTL for C-Compiler\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+\n+void note_stores ();\n+int reg_set_p ();\n+\n+/* Bit flags that specify the machine subtype we are compiling for.\n+   Bits are tested using macros TARGET_... defined in the tm.h file\n+   and set by `-m...' switches.  Must be defined in rtlanal.c.  */\n+\n+int target_flags;\n+\f\n+/* Return 1 if the value of X is unstable\n+   (would be different at a different point in the program).\n+   The frame pointer, arg pointer, etc. are considered stable\n+   (within one function) and so is anything marked `unchanging'.  */\n+\n+int\n+rtx_unstable_p (x)\n+     rtx x;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+  register int i;\n+  register char *fmt;\n+\n+  if (code == MEM)\n+    return ! RTX_UNCHANGING_P (x);\n+\n+  if (code == QUEUED)\n+    return 1;\n+\n+  if (code == CONST || code == CONST_INT)\n+    return 0;\n+\n+  if (code == REG)\n+    return ! (REGNO (x) == FRAME_POINTER_REGNUM\n+\t      || REGNO (x) == ARG_POINTER_REGNUM\n+\t      || RTX_UNCHANGING_P (x));\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      if (rtx_unstable_p (XEXP (x, i)))\n+\treturn 1;\n+  return 0;\n+}\n+\n+/* Return 1 if X has a value that can vary even between two\n+   executions of the program.  0 means X can be compared reliably\n+   against certain constants or near-constants.\n+   The frame pointer and the arg pointer are considered constant.  */\n+\n+int\n+rtx_varies_p (x)\n+     rtx x;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+  register int i;\n+  register char *fmt;\n+\n+  switch (code)\n+    {\n+    case MEM:\n+    case QUEUED:\n+      return 1;\n+\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case REG:\n+      /* Note that we have to test for the actual rtx used for the frame\n+\t and arg pointers and not just the register number in case we have\n+\t eliminated the frame and/or arg pointer and are using it\n+\t for pseudos.  */\n+      return ! (x == frame_pointer_rtx || x == arg_pointer_rtx);\n+\n+    case LO_SUM:\n+      /* The operand 0 of a LO_SUM is considered constant\n+\t (in fact is it related specifically to operand 1).  */\n+      return rtx_varies_p (XEXP (x, 1));\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      if (rtx_varies_p (XEXP (x, i)))\n+\treturn 1;\n+  return 0;\n+}\n+\n+/* Return 0 if the use of X as an address in a MEM can cause a trap.  */\n+\n+int\n+rtx_addr_can_trap_p (x)\n+     register rtx x;\n+{\n+  register enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      /* SYMBOL_REF is problematic due to the possible presence of\n+\t a #pragma weak, but to say that loads from symbols can trap is\n+\t *very* costly.  It's not at all clear what's best here.  For\n+\t now, we ignore the impact of #pragma weak.  */\n+      return 0;\n+\n+    case REG:\n+      /* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */\n+      return ! (x == frame_pointer_rtx || x == stack_pointer_rtx\n+\t\t|| x == arg_pointer_rtx);\n+\n+    case CONST:\n+      return rtx_addr_can_trap_p (XEXP (x, 0));\n+\n+    case PLUS:\n+      /* An address is assumed not to trap if it is an address that can't\n+\t trap plus a constant integer.  */\n+      return (rtx_addr_can_trap_p (XEXP (x, 0))\n+\t      || GET_CODE (XEXP (x, 1)) != CONST_INT);\n+\n+    case LO_SUM:\n+      return rtx_addr_can_trap_p (XEXP (x, 1));\n+    }\n+\n+  /* If it isn't one of the case above, it can cause a trap.  */\n+  return 1;\n+}\n+\n+/* Return 1 if X refers to a memory location whose address \n+   cannot be compared reliably with constant addresses,\n+   or if X refers to a BLKmode memory object.  */\n+\n+int\n+rtx_addr_varies_p (x)\n+     rtx x;\n+{\n+  register enum rtx_code code;\n+  register int i;\n+  register char *fmt;\n+\n+  if (x == 0)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+  if (code == MEM)\n+    return GET_MODE (x) == BLKmode || rtx_varies_p (XEXP (x, 0));\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      if (rtx_addr_varies_p (XEXP (x, i)))\n+\treturn 1;\n+  return 0;\n+}\n+\f\n+/* Return the value of the integer term in X, if one is apparent;\n+   otherwise return 0.\n+   Only obvious integer terms are detected.\n+   This is used in cse.c with the `related_value' field.*/\n+\n+int\n+get_integer_term (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == MINUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    return - INTVAL (XEXP (x, 1));\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    return INTVAL (XEXP (x, 1));\n+  return 0;\n+}\n+\n+/* If X is a constant, return the value sans apparent integer term;\n+   otherwise return 0.\n+   Only obvious integer terms are detected.  */\n+\n+rtx\n+get_related_value (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) != CONST)\n+    return 0;\n+  x = XEXP (x, 0);\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    return XEXP (x, 0);\n+  else if (GET_CODE (x) == MINUS\n+\t   && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    return XEXP (x, 0);\n+  return 0;\n+}\n+\f\n+/* Nonzero if register REG appears somewhere within IN.\n+   Also works if REG is not a register; in this case it checks\n+   for a subexpression of IN that is Lisp \"equal\" to REG.  */\n+\n+int\n+reg_mentioned_p (reg, in)\n+     register rtx reg, in;\n+{\n+  register char *fmt;\n+  register int i;\n+  register enum rtx_code code;\n+\n+  if (in == 0)\n+    return 0;\n+\n+  if (reg == in)\n+    return 1;\n+\n+  if (GET_CODE (in) == LABEL_REF)\n+    return reg == XEXP (in, 0);\n+\n+  code = GET_CODE (in);\n+\n+  switch (code)\n+    {\n+      /* Compare registers by number.  */\n+    case REG:\n+      return GET_CODE (reg) == REG && REGNO (in) == REGNO (reg);\n+\n+      /* These codes have no constituent expressions\n+\t and are unique.  */\n+    case SCRATCH:\n+    case CC0:\n+    case PC:\n+      return 0;\n+\n+    case CONST_INT:\n+      return GET_CODE (reg) == CONST_INT && INTVAL (in) == INTVAL (reg);\n+      \n+    case CONST_DOUBLE:\n+      /* These are kept unique for a given value.  */\n+      return 0;\n+    }\n+\n+  if (GET_CODE (reg) == code && rtx_equal_p (reg, in))\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (code);\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = XVECLEN (in, i) - 1; j >= 0; j--)\n+\t    if (reg_mentioned_p (reg, XVECEXP (in, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e'\n+\t       && reg_mentioned_p (reg, XEXP (in, i)))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\f\n+/* Return 1 if in between BEG and END, exclusive of BEG and END, there is\n+   no CODE_LABEL insn.  */\n+\n+int\n+no_labels_between_p (beg, end)\n+     rtx beg, end;\n+{\n+  register rtx p;\n+  for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n+    if (GET_CODE (p) == CODE_LABEL)\n+      return 0;\n+  return 1;\n+}\n+\n+/* Nonzero if register REG is used in an insn between\n+   FROM_INSN and TO_INSN (exclusive of those two).  */\n+\n+int\n+reg_used_between_p (reg, from_insn, to_insn)\n+     rtx reg, from_insn, to_insn;\n+{\n+  register rtx insn;\n+\n+  if (from_insn == to_insn)\n+    return 0;\n+\n+  for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t&& reg_overlap_mentioned_p (reg, PATTERN (insn)))\n+      return 1;\n+  return 0;\n+}\n+\f\n+/* Nonzero if the old value of X, a register, is referenced in BODY.  If X\n+   is entirely replaced by a new value and the only use is as a SET_DEST,\n+   we do not consider it a reference.  */\n+\n+int\n+reg_referenced_p (x, body)\n+     rtx x;\n+     rtx body;\n+{\n+  int i;\n+\n+  switch (GET_CODE (body))\n+    {\n+    case SET:\n+      if (reg_overlap_mentioned_p (x, SET_SRC (body)))\n+\treturn 1;\n+\n+      /* If the destination is anything other than CC0, PC, a REG or a SUBREG\n+\t of a REG that occupies all of the REG, the insn references X if\n+\t it is mentioned in the destination.  */\n+      if (GET_CODE (SET_DEST (body)) != CC0\n+\t  && GET_CODE (SET_DEST (body)) != PC\n+\t  && GET_CODE (SET_DEST (body)) != REG\n+\t  && ! (GET_CODE (SET_DEST (body)) == SUBREG\n+\t\t&& GET_CODE (SUBREG_REG (SET_DEST (body))) == REG\n+\t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (body))))\n+\t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (body)))\n+\t\t\t + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n+\t  && reg_overlap_mentioned_p (x, SET_DEST (body)))\n+\treturn 1;\n+      break;\n+\n+    case ASM_OPERANDS:\n+      for (i = ASM_OPERANDS_INPUT_LENGTH (body) - 1; i >= 0; i--)\n+\tif (reg_overlap_mentioned_p (x, ASM_OPERANDS_INPUT (body, i)))\n+\t  return 1;\n+      break;\n+\n+    case CALL:\n+    case USE:\n+      return reg_overlap_mentioned_p (x, body);\n+\n+    case TRAP_IF:\n+      return reg_overlap_mentioned_p (x, TRAP_CONDITION (body));\n+\n+    case PARALLEL:\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; i--)\n+\tif (reg_referenced_p (x, XVECEXP (body, 0, i)))\n+\t  return 1;\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Nonzero if register REG is referenced in an insn between\n+   FROM_INSN and TO_INSN (exclusive of those two).  Sets of REG do\n+   not count. */\n+\n+int\n+reg_referenced_between_p (reg, from_insn, to_insn)\n+     rtx reg, from_insn, to_insn;\n+{\n+  register rtx insn;\n+\n+  if (from_insn == to_insn)\n+    return 0;\n+\n+  for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t&& reg_referenced_p (reg, PATTERN (insn)))\n+      return 1;\n+  return 0;\n+}\n+\f\n+/* Nonzero if register REG is set or clobbered in an insn between\n+   FROM_INSN and TO_INSN (exclusive of those two).  */\n+\n+int\n+reg_set_between_p (reg, from_insn, to_insn)\n+     rtx reg, from_insn, to_insn;\n+{\n+  register rtx insn;\n+\n+  if (from_insn == to_insn)\n+    return 0;\n+\n+  for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t&& reg_set_p (reg, PATTERN (insn)))\n+      return 1;\n+  return 0;\n+}\n+\n+/* Internals of reg_set_between_p.  */\n+\n+static rtx reg_set_reg;\n+static int reg_set_flag;\n+\n+void\n+reg_set_p_1 (x)\n+     rtx x;\n+{\n+  /* We don't want to return 1 if X is a MEM that contains a register\n+     within REG_SET_REG.  */\n+\n+  if ((GET_CODE (x) != MEM)\n+      && reg_overlap_mentioned_p (reg_set_reg, x))\n+    reg_set_flag = 1;\n+}\n+\n+int\n+reg_set_p (reg, insn)\n+     rtx reg, insn;\n+{\n+  rtx body = insn;\n+\n+  /* We can be passed an insn or part of one.  If we are passed an insn,\n+     check if a side-effect of the insn clobbers REG.  */\n+  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+    {\n+      if (FIND_REG_INC_NOTE (insn, reg)\n+\t  || (GET_CODE (insn) == CALL_INSN\n+\t      /* We'd like to test call_used_regs here, but rtlanal.c can't\n+\t\t reference that variable due to its use in genattrtab.  So\n+\t\t we'll just be more conservative.  */\n+\t      && ((GET_CODE (reg) == REG\n+\t\t   && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n+\t\t  || GET_CODE (reg) == MEM)))\n+\treturn 1;\n+\n+      body = PATTERN (insn);\n+    }\n+\n+  reg_set_reg = reg;\n+  reg_set_flag = 0;\n+  note_stores (body, reg_set_p_1);\n+  return reg_set_flag;\n+}\n+\n+/* Similar to reg_set_between_p, but check all registers in X.  Return 0\n+   only if none of them are modified between START and END.  Return 1 if\n+   X contains a MEM; this routine does not perform any memory aliasing.  */\n+\n+int\n+modified_between_p (x, start, end)\n+     rtx x;\n+     rtx start, end;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  char *fmt;\n+  int i;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case PC:\n+    case CC0:\n+      return 1;\n+\n+    case MEM:\n+      /* If the memory is not constant, assume it is modified.  If it is\n+\t constant, we still have to check the address.  */\n+      if (! RTX_UNCHANGING_P (x))\n+\treturn 1;\n+      break;\n+\n+    case REG:\n+      return reg_set_between_p (x, start, end);\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e'\n+\t&& modified_between_p (XEXP (x, i), start, end))\n+      return 1;\n+\n+  return 0;\n+}\n+\f\n+/* Given an INSN, return a SET expression if this insn has only a single SET.\n+   It may also have CLOBBERs, USEs, or SET whose output\n+   will not be used, which we ignore.  */\n+\n+rtx\n+single_set (insn)\n+     rtx insn;\n+{\n+  rtx set;\n+  int i;\n+  \n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+    return 0;\n+\n+  if (GET_CODE (PATTERN (insn)) == SET)\n+    return PATTERN (insn);\n+  \n+  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+    {\n+      for (i = 0, set = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET\n+\t    && ! (find_reg_note (insn, REG_UNUSED,\n+\t\t\t\tSET_DEST (XVECEXP (PATTERN (insn), 0, i)))\n+\t\t  || side_effects_p (XVECEXP (PATTERN (insn), 0, i))))\n+\t  {\n+\t    if (set)\n+\t      return 0;\n+\t    else\n+\t      set = XVECEXP (PATTERN (insn), 0, i);\n+\t  }\n+      return set;\n+    }\n+  \n+  return 0;\n+}\n+\f\n+/* Return the last thing that X was assigned from before *PINSN.  Verify that\n+   the object is not modified up to VALID_TO.  If it was, if we hit\n+   a partial assignment to X, or hit a CODE_LABEL first, return X.  If we\n+   found an assignment, update *PINSN to point to it.  */\n+\n+rtx\n+find_last_value (x, pinsn, valid_to)\n+     rtx x;\n+     rtx *pinsn;\n+     rtx valid_to;\n+{\n+  rtx p;\n+\n+  for (p = PREV_INSN (*pinsn); p && GET_CODE (p) != CODE_LABEL;\n+       p = PREV_INSN (p))\n+    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n+      {\n+\trtx set = single_set (p);\n+\trtx note = find_reg_note (p, REG_EQUAL, 0);\n+\n+\tif (set && rtx_equal_p (x, SET_DEST (set)))\n+\t  {\n+\t    rtx src = SET_SRC (set);\n+\n+\t    if (note && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n+\t      src = XEXP (note, 0);\n+\n+\t    if (! modified_between_p (src, PREV_INSN (p), valid_to)\n+\t\t/* Reject hard registers because we don't usually want\n+\t\t   to use them; we'd rather use a pseudo.  */\n+\t\t&& ! (GET_CODE (src) == REG\n+\t\t      && REGNO (src) < FIRST_PSEUDO_REGISTER))\n+\t      {\n+\t\t*pinsn = p;\n+\t\treturn src;\n+\t      }\n+\t  }\n+\t  \n+\t/* If set in non-simple way, we don't have a value.  */\n+\tif (reg_set_p (x, p))\n+\t  break;\n+      }\n+\n+  return x;\n+}     \n+\f\n+/* Return nonzero if register in range [REGNO, ENDREGNO)\n+   appears either explicitly or implicitly in X\n+   other than being stored into.\n+\n+   References contained within the substructure at LOC do not count.\n+   LOC may be zero, meaning don't ignore anything.  */\n+\n+int\n+refers_to_regno_p (regno, endregno, x, loc)\n+     int regno, endregno;\n+     rtx x;\n+     rtx *loc;\n+{\n+  register int i;\n+  register RTX_CODE code;\n+  register char *fmt;\n+\n+ repeat:\n+  /* The contents of a REG_NONNEG note is always zero, so we must come here\n+     upon repeat in case the last REG_NOTE is a REG_NONNEG note.  */\n+  if (x == 0)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case REG:\n+      i = REGNO (x);\n+      return (endregno > i\n+\t      && regno < i + (i < FIRST_PSEUDO_REGISTER \n+\t\t\t      ? HARD_REGNO_NREGS (i, GET_MODE (x))\n+\t\t\t      : 1));\n+\n+    case SUBREG:\n+      /* If this is a SUBREG of a hard reg, we can see exactly which\n+\t registers are being modified.  Otherwise, handle normally.  */\n+      if (GET_CODE (SUBREG_REG (x)) == REG\n+\t  && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int inner_regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n+\t  int inner_endregno\n+\t    = inner_regno + (inner_regno < FIRST_PSEUDO_REGISTER\n+\t\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\n+\t  return endregno > inner_regno && regno < inner_endregno;\n+\t}\n+      break;\n+\n+    case CLOBBER:\n+    case SET:\n+      if (&SET_DEST (x) != loc\n+\t  /* Note setting a SUBREG counts as referring to the REG it is in for\n+\t     a pseudo but not for hard registers since we can\n+\t     treat each word individually.  */\n+\t  && ((GET_CODE (SET_DEST (x)) == SUBREG\n+\t       && loc != &SUBREG_REG (SET_DEST (x))\n+\t       && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG\n+\t       && REGNO (SUBREG_REG (SET_DEST (x))) >= FIRST_PSEUDO_REGISTER\n+\t       && refers_to_regno_p (regno, endregno,\n+\t\t\t\t     SUBREG_REG (SET_DEST (x)), loc))\n+\t      || (GET_CODE (SET_DEST (x)) != REG\n+\t\t  && refers_to_regno_p (regno, endregno, SET_DEST (x), loc))))\n+\treturn 1;\n+\n+      if (code == CLOBBER || loc == &SET_SRC (x))\n+\treturn 0;\n+      x = SET_SRC (x);\n+      goto repeat;\n+    }\n+\n+  /* X does not match, so try its subexpressions.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e' && loc != &XEXP (x, i))\n+\t{\n+\t  if (i == 0)\n+\t    {\n+\t      x = XEXP (x, 0);\n+\t      goto repeat;\n+\t    }\n+\t  else\n+\t    if (refers_to_regno_p (regno, endregno, XEXP (x, i), loc))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >=0; j--)\n+\t    if (loc != &XVECEXP (x, i, j)\n+\t\t&& refers_to_regno_p (regno, endregno, XVECEXP (x, i, j), loc))\n+\t      return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Nonzero if modifying X will affect IN.  If X is a register or a SUBREG,\n+   we check if any register number in X conflicts with the relevant register\n+   numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN\n+   contains a MEM (we don't bother checking for memory addresses that can't\n+   conflict because we expect this to be a rare case.  */\n+\n+int\n+reg_overlap_mentioned_p (x, in)\n+     rtx x, in;\n+{\n+  int regno, endregno;\n+\n+  if (GET_CODE (x) == SUBREG)\n+    {\n+      regno = REGNO (SUBREG_REG (x));\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\tregno += SUBREG_WORD (x);\n+    }\n+  else if (GET_CODE (x) == REG)\n+    regno = REGNO (x);\n+  else if (CONSTANT_P (x))\n+    return 0;\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      char *fmt;\n+      int i;\n+\n+      if (GET_CODE (in) == MEM)\n+\treturn 1;\n+\n+      fmt = GET_RTX_FORMAT (GET_CODE (in));\n+\n+      for (i = GET_RTX_LENGTH (GET_CODE (in)) - 1; i >= 0; i--)\n+\tif (fmt[i] == 'e' && reg_overlap_mentioned_p (x, XEXP (in, i)))\n+\t  return 1;\n+\n+      return 0;\n+    }\n+  else if (GET_CODE (x) == SCRATCH || GET_CODE (x) == PC\n+\t   || GET_CODE (x) == CC0)\n+    return reg_mentioned_p (x, in);\n+  else\n+    abort ();\n+\n+  endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n+\t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\n+  return refers_to_regno_p (regno, endregno, in, 0);\n+}\n+\f\n+/* Used for communications between the next few functions.  */\n+\n+static int reg_set_last_unknown;\n+static rtx reg_set_last_value;\n+static int reg_set_last_first_regno, reg_set_last_last_regno;\n+\n+/* Called via note_stores from reg_set_last.  */\n+\n+static void\n+reg_set_last_1 (x, pat)\n+     rtx x;\n+     rtx pat;\n+{\n+  int first, last;\n+\n+  /* If X is not a register, or is not one in the range we care\n+     about, ignore.  */\n+  if (GET_CODE (x) != REG)\n+    return;\n+\n+  first = REGNO (x);\n+  last = first + (first < FIRST_PSEUDO_REGISTER\n+\t\t  ? HARD_REGNO_NREGS (first, GET_MODE (x)) : 1);\n+\n+  if (first >= reg_set_last_last_regno\n+      || last <= reg_set_last_first_regno)\n+    return;\n+\n+  /* If this is a CLOBBER or is some complex LHS, or doesn't modify\n+     exactly the registers we care about, show we don't know the value.  */\n+  if (GET_CODE (pat) == CLOBBER || SET_DEST (pat) != x\n+      || first != reg_set_last_first_regno\n+      || last != reg_set_last_last_regno)\n+    reg_set_last_unknown = 1;\n+  else\n+    reg_set_last_value = SET_SRC (pat);\n+}\n+\n+/* Return the last value to which REG was set prior to INSN.  If we can't\n+   find it easily, return 0.\n+\n+   We only return a REG or constant because it is too hard to check if a\n+   MEM remains unchanged.  */\n+\n+rtx\n+reg_set_last (x, insn)\n+     rtx x;\n+     rtx insn;\n+{\n+  rtx orig_insn = insn;\n+\n+  reg_set_last_first_regno = REGNO (x);\n+\n+  reg_set_last_last_regno\n+    = reg_set_last_first_regno\n+      + (reg_set_last_first_regno < FIRST_PSEUDO_REGISTER\n+\t ? HARD_REGNO_NREGS (reg_set_last_first_regno, GET_MODE (x)) : 1);\n+\n+  reg_set_last_unknown = 0;\n+  reg_set_last_value = 0;\n+\n+  /* Scan backwards until reg_set_last_1 changed one of the above flags.\n+     Stop when we reach a label or X is a hard reg and we reach a\n+     CALL_INSN (if reg_set_last_last_regno is a hard reg).\n+\n+     If we find a set of X, ensure that its SET_SRC remains unchanged.  */\n+\n+  for (;\n+       insn && GET_CODE (insn) != CODE_LABEL\n+       && ! (GET_CODE (insn) == CALL_INSN\n+\t     && reg_set_last_last_regno <= FIRST_PSEUDO_REGISTER);\n+       insn = PREV_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+      {\n+\tnote_stores (PATTERN (insn), reg_set_last_1);\n+\tif (reg_set_last_unknown)\n+\t  return 0;\n+\telse if (reg_set_last_value)\n+\t  {\n+\t    if (CONSTANT_P (reg_set_last_value)\n+\t\t|| (GET_CODE (reg_set_last_value) == REG\n+\t\t    && ! reg_set_between_p (reg_set_last_value,\n+\t\t\t\t\t    NEXT_INSN (insn), orig_insn)))\n+\t      return reg_set_last_value;\n+\t    else\n+\t      return 0;\n+\t  }\n+      }\n+\n+  return 0;\n+}\n+\f\n+/* This is 1 until after reload pass.  */\n+int rtx_equal_function_value_matters;\n+\n+/* Return 1 if X and Y are identical-looking rtx's.\n+   This is the Lisp function EQUAL for rtx arguments.  */\n+\n+int\n+rtx_equal_p (x, y)\n+     rtx x, y;\n+{\n+  register int i;\n+  register int j;\n+  register enum rtx_code code;\n+  register char *fmt;\n+\n+  if (x == y)\n+    return 1;\n+  if (x == 0 || y == 0)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+  /* Rtx's of different codes cannot be equal.  */\n+  if (code != GET_CODE (y))\n+    return 0;\n+\n+  /* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.\n+     (REG:SI x) and (REG:HI x) are NOT equivalent.  */\n+\n+  if (GET_MODE (x) != GET_MODE (y))\n+    return 0;\n+\n+  /* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */\n+\n+  if (code == REG)\n+    /* Until rtl generation is complete, don't consider a reference to the\n+       return register of the current function the same as the return from a\n+       called function.  This eases the job of function integration.  Once the\n+       distinction is no longer needed, they can be considered equivalent.  */\n+    return (REGNO (x) == REGNO (y)\n+\t    && (! rtx_equal_function_value_matters\n+\t\t|| REG_FUNCTION_VALUE_P (x) == REG_FUNCTION_VALUE_P (y)));\n+  else if (code == LABEL_REF)\n+    return XEXP (x, 0) == XEXP (y, 0);\n+  else if (code == SYMBOL_REF)\n+    return XSTR (x, 0) == XSTR (y, 0);\n+  else if (code == SCRATCH || code == CONST_DOUBLE)\n+    return 0;\n+\n+  /* Compare the elements.  If any pair of corresponding elements\n+     fail to match, return 0 for the whole things.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'n':\n+\tcase 'i':\n+\t  if (XINT (x, i) != XINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return 0;\n+\n+\t  /* And the corresponding elements must match.  */\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (rtx_equal_p (XVECEXP (x, i, j), XVECEXP (y, i, j)) == 0)\n+\t      return 0;\n+\t  break;\n+\n+\tcase 'e':\n+\t  if (rtx_equal_p (XEXP (x, i), XEXP (y, i)) == 0)\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'u':\n+\t  /* These are just backpointers, so they don't matter.  */\n+\t  break;\n+\n+\tcase '0':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's,\n+\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return 1;\n+}\n+\f\n+/* Call FUN on each register or MEM that is stored into or clobbered by X.\n+   (X would be the pattern of an insn).\n+   FUN receives two arguments:\n+     the REG, MEM, CC0 or PC being stored in or clobbered,\n+     the SET or CLOBBER rtx that does the store.\n+\n+  If the item being stored in or clobbered is a SUBREG of a hard register,\n+  the SUBREG will be passed.  */\n+     \n+void\n+note_stores (x, fun)\n+     register rtx x;\n+     void (*fun) ();\n+{\n+  if ((GET_CODE (x) == SET || GET_CODE (x) == CLOBBER))\n+    {\n+      register rtx dest = SET_DEST (x);\n+      while ((GET_CODE (dest) == SUBREG\n+\t      && (GET_CODE (SUBREG_REG (dest)) != REG\n+\t\t  || REGNO (SUBREG_REG (dest)) >= FIRST_PSEUDO_REGISTER))\n+\t     || GET_CODE (dest) == ZERO_EXTRACT\n+\t     || GET_CODE (dest) == SIGN_EXTRACT\n+\t     || GET_CODE (dest) == STRICT_LOW_PART)\n+\tdest = XEXP (dest, 0);\n+      (*fun) (dest, x);\n+    }\n+  else if (GET_CODE (x) == PARALLEL)\n+    {\n+      register int i;\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t{\n+\t  register rtx y = XVECEXP (x, 0, i);\n+\t  if (GET_CODE (y) == SET || GET_CODE (y) == CLOBBER)\n+\t    {\n+\t      register rtx dest = SET_DEST (y);\n+\t      while ((GET_CODE (dest) == SUBREG\n+\t\t      && (GET_CODE (SUBREG_REG (dest)) != REG\n+\t\t\t  || (REGNO (SUBREG_REG (dest))\n+\t\t\t      >= FIRST_PSEUDO_REGISTER)))\n+\t\t     || GET_CODE (dest) == ZERO_EXTRACT\n+\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n+\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n+\t\tdest = XEXP (dest, 0);\n+\t      (*fun) (dest, y);\n+\t    }\n+\t}\n+    }\n+}\n+\f\n+/* Return nonzero if X's old contents don't survive after INSN.\n+   This will be true if X is (cc0) or if X is a register and\n+   X dies in INSN or because INSN entirely sets X.\n+\n+   \"Entirely set\" means set directly and not through a SUBREG,\n+   ZERO_EXTRACT or SIGN_EXTRACT, so no trace of the old contents remains.\n+   Likewise, REG_INC does not count.\n+\n+   REG may be a hard or pseudo reg.  Renumbering is not taken into account,\n+   but for this use that makes no difference, since regs don't overlap\n+   during their lifetimes.  Therefore, this function may be used\n+   at any time after deaths have been computed (in flow.c).\n+\n+   If REG is a hard reg that occupies multiple machine registers, this\n+   function will only return 1 if each of those registers will be replaced\n+   by INSN.  */\n+\n+int\n+dead_or_set_p (insn, x)\n+     rtx insn;\n+     rtx x;\n+{\n+  register int regno, last_regno;\n+  register int i;\n+\n+  /* Can't use cc0_rtx below since this file is used by genattrtab.c.  */\n+  if (GET_CODE (x) == CC0)\n+    return 1;\n+\n+  if (GET_CODE (x) != REG)\n+    abort ();\n+\n+  regno = REGNO (x);\n+  last_regno = (regno >= FIRST_PSEUDO_REGISTER ? regno\n+\t\t: regno + HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1);\n+\n+  for (i = regno; i <= last_regno; i++)\n+    if (! dead_or_set_regno_p (insn, i))\n+      return 0;\n+\n+  return 1;\n+}\n+\n+/* Utility function for dead_or_set_p to check an individual register.  Also\n+   called from flow.c.  */\n+\n+int\n+dead_or_set_regno_p (insn, test_regno)\n+     rtx insn;\n+     int test_regno;\n+{\n+  int regno, endregno;\n+  rtx link;\n+\n+  /* See if there is a death note for something that includes TEST_REGNO.  */\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    {\n+      if (REG_NOTE_KIND (link) != REG_DEAD || GET_CODE (XEXP (link, 0)) != REG)\n+\tcontinue;\n+\n+      regno = REGNO (XEXP (link, 0));\n+      endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n+\t\t  : regno + HARD_REGNO_NREGS (regno,\n+\t\t\t\t\t      GET_MODE (XEXP (link, 0))));\n+\n+      if (test_regno >= regno && test_regno < endregno)\n+\treturn 1;\n+    }\n+\n+  if (GET_CODE (PATTERN (insn)) == SET)\n+    {\n+      rtx dest = SET_DEST (PATTERN (insn));\n+ \n+      /* A value is totally replaced if it is the destination or the\n+\t destination is a SUBREG of REGNO that does not change the number of\n+\t words in it.  */\n+     if (GET_CODE (dest) == SUBREG\n+\t  && (((GET_MODE_SIZE (GET_MODE (dest))\n+\t\t+ UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n+\t\t   + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n+\tdest = SUBREG_REG (dest);\n+\n+      if (GET_CODE (dest) != REG)\n+\treturn 0;\n+\n+      regno = REGNO (dest);\n+      endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n+\t\t  : regno + HARD_REGNO_NREGS (regno, GET_MODE (dest)));\n+\n+      return (test_regno >= regno && test_regno < endregno);\n+    }\n+  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+    {\n+      register int i;\n+\n+      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t{\n+\t  rtx body = XVECEXP (PATTERN (insn), 0, i);\n+\n+\t  if (GET_CODE (body) == SET || GET_CODE (body) == CLOBBER)\n+\t    {\n+\t      rtx dest = SET_DEST (body);\n+\n+\t      if (GET_CODE (dest) == SUBREG\n+\t\t  && (((GET_MODE_SIZE (GET_MODE (dest))\n+\t\t\t+ UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\t\t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n+\t\t\t   + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n+\t\tdest = SUBREG_REG (dest);\n+\n+\t      if (GET_CODE (dest) != REG)\n+\t\tcontinue;\n+\n+\t      regno = REGNO (dest);\n+\t      endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n+\t\t\t  : regno + HARD_REGNO_NREGS (regno, GET_MODE (dest)));\n+\n+\t      if (test_regno >= regno && test_regno < endregno)\n+\t\treturn 1;\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return the reg-note of kind KIND in insn INSN, if there is one.\n+   If DATUM is nonzero, look for one whose datum is DATUM.  */\n+\n+rtx\n+find_reg_note (insn, kind, datum)\n+     rtx insn;\n+     enum reg_note kind;\n+     rtx datum;\n+{\n+  register rtx link;\n+\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (REG_NOTE_KIND (link) == kind\n+\t&& (datum == 0 || datum == XEXP (link, 0)))\n+      return link;\n+  return 0;\n+}\n+\n+/* Return the reg-note of kind KIND in insn INSN which applies to register\n+   number REGNO, if any.  Return 0 if there is no such reg-note.  */\n+\n+rtx\n+find_regno_note (insn, kind, regno)\n+     rtx insn;\n+     enum reg_note kind;\n+     int regno;\n+{\n+  register rtx link;\n+\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (REG_NOTE_KIND (link) == kind\n+\t/* Verify that it is a register, so that scratch and MEM won't cause a\n+\t   problem here.  */\n+\t&& GET_CODE (XEXP (link, 0)) == REG\n+\t&& REGNO (XEXP (link, 0)) == regno)\n+      return link;\n+  return 0;\n+}\n+\f\n+/* Remove register note NOTE from the REG_NOTES of INSN.  */\n+\n+void\n+remove_note (insn, note)\n+     register rtx note;\n+     register rtx insn;\n+{\n+  register rtx link;\n+\n+  if (REG_NOTES (insn) == note)\n+    {\n+      REG_NOTES (insn) = XEXP (note, 1);\n+      return;\n+    }\n+\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (XEXP (link, 1) == note)\n+      {\n+\tXEXP (link, 1) = XEXP (note, 1);\n+\treturn;\n+      }\n+\n+  abort ();\n+}\n+\f\n+/* Nonzero if X contains any volatile memory references\n+   or volatile ASM_OPERANDS expressions.  */\n+\n+int\n+volatile_refs_p (x)\n+     rtx x;\n+{\n+  register RTX_CODE code;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+    case CONST:\n+    case CONST_DOUBLE:\n+    case CC0:\n+    case PC:\n+    case REG:\n+    case SCRATCH:\n+    case CLOBBER:\n+    case ASM_INPUT:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return 0;\n+\n+    case CALL:\n+ /* case TRAP_IF: This isn't clear yet.  */\n+      return 1;\n+\n+    case MEM:\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 1;\n+    }\n+\n+  /* Recursively scan the operands of this expression.  */\n+\n+  {\n+    register char *fmt = GET_RTX_FORMAT (code);\n+    register int i;\n+    \n+    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+      {\n+\tif (fmt[i] == 'e')\n+\t  {\n+\t    if (volatile_refs_p (XEXP (x, i)))\n+\t      return 1;\n+\t  }\n+\tif (fmt[i] == 'E')\n+\t  {\n+\t    register int j;\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      if (volatile_refs_p (XVECEXP (x, i, j)))\n+\t\treturn 1;\n+\t  }\n+      }\n+  }\n+  return 0;\n+}\n+\n+/* Similar to above, except that it also rejects register pre- and post-\n+   incrementing.  */\n+\n+int\n+side_effects_p (x)\n+     rtx x;\n+{\n+  register RTX_CODE code;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+    case CONST:\n+    case CONST_DOUBLE:\n+    case CC0:\n+    case PC:\n+    case REG:\n+    case SCRATCH:\n+    case ASM_INPUT:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return 0;\n+\n+    case CLOBBER:\n+      /* Reject CLOBBER with a non-VOID mode.  These are made by combine.c\n+\t when some combination can't be done.  If we see one, don't think\n+\t that we can simplify the expression.  */\n+      return (GET_MODE (x) != VOIDmode);\n+\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case POST_INC:\n+    case POST_DEC:\n+    case CALL:\n+ /* case TRAP_IF: This isn't clear yet.  */\n+      return 1;\n+\n+    case MEM:\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 1;\n+    }\n+\n+  /* Recursively scan the operands of this expression.  */\n+\n+  {\n+    register char *fmt = GET_RTX_FORMAT (code);\n+    register int i;\n+    \n+    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+      {\n+\tif (fmt[i] == 'e')\n+\t  {\n+\t    if (side_effects_p (XEXP (x, i)))\n+\t      return 1;\n+\t  }\n+\tif (fmt[i] == 'E')\n+\t  {\n+\t    register int j;\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      if (side_effects_p (XVECEXP (x, i, j)))\n+\t\treturn 1;\n+\t  }\n+      }\n+  }\n+  return 0;\n+}\n+\f\n+/* Return nonzero if evaluating rtx X might cause a trap.  */\n+\n+int\n+may_trap_p (x)\n+     rtx x;\n+{\n+  int i;\n+  enum rtx_code code;\n+  char *fmt;\n+\n+  if (x == 0)\n+    return 0;\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+      /* Handle these cases quickly.  */\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST:\n+    case PC:\n+    case CC0:\n+    case REG:\n+    case SCRATCH:\n+      return 0;\n+\n+      /* Conditional trap can trap!  */\n+    case TRAP_IF:\n+      return 1;\n+\n+      /* Memory ref can trap unless it's a static var or a stack slot.  */\n+    case MEM:\n+      return rtx_addr_can_trap_p (XEXP (x, 0));\n+\n+      /* Division by a non-constant might trap.  */\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      if (! CONSTANT_P (XEXP (x, 1)))\n+\treturn 1;\n+      /* This was const0_rtx, but by not using that,\n+\t we can link this file into other programs.  */\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) == 0)\n+\treturn 1;\n+    default:\n+      /* Any floating arithmetic may trap.  */\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+\treturn 1;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (may_trap_p (XEXP (x, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (may_trap_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\f\n+/* Return nonzero if X contains a comparison that is not either EQ or NE,\n+   i.e., an inequality.  */\n+\n+int\n+inequality_comparisons_p (x)\n+     rtx x;\n+{\n+  register char *fmt;\n+  register int len, i;\n+  register enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case SCRATCH:\n+    case PC:\n+    case CC0:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      return 0;\n+\n+    case LT:\n+    case LTU:\n+    case GT:\n+    case GTU:\n+    case LE:\n+    case LEU:\n+    case GE:\n+    case GEU:\n+      return 1;\n+    }\n+\n+  len = GET_RTX_LENGTH (code);\n+  fmt = GET_RTX_FORMAT (code);\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (inequality_comparisons_p (XEXP (x, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (inequality_comparisons_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+    }\n+\t    \n+  return 0;\n+}\n+\f\n+/* Replace any occurrence of FROM in X with TO.\n+\n+   Note that copying is not done so X must not be shared unless all copies\n+   are to be modified.  */\n+\n+rtx\n+replace_rtx (x, from, to)\n+     rtx x, from, to;\n+{\n+  register int i, j;\n+  register char *fmt;\n+\n+  if (x == from)\n+    return to;\n+\n+  /* Allow this function to make replacements in EXPR_LISTs.  */\n+  if (x == 0)\n+    return 0;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tXEXP (x, i) = replace_rtx (XEXP (x, i), from, to);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  XVECEXP (x, i, j) = replace_rtx (XVECEXP (x, i, j), from, to);\n+    }\n+\n+  return x;\n+}  \n+\f\n+/* Throughout the rtx X, replace many registers according to REG_MAP.\n+   Return the replacement for X (which may be X with altered contents).\n+   REG_MAP[R] is the replacement for register R, or 0 for don't replace.\n+   NREGS is the length of REG_MAP; regs >= NREGS are not mapped.  \n+\n+   We only support REG_MAP entries of REG or SUBREG.  Also, hard registers\n+   should not be mapped to pseudos or vice versa since validate_change\n+   is not called.\n+\n+   If REPLACE_DEST is 1, replacements are also done in destinations;\n+   otherwise, only sources are replaced.  */\n+\n+rtx\n+replace_regs (x, reg_map, nregs, replace_dest)\n+     rtx x;\n+     rtx *reg_map;\n+     int nregs;\n+     int replace_dest;\n+{\n+  register enum rtx_code code;\n+  register int i;\n+  register char *fmt;\n+\n+  if (x == 0)\n+    return x;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case SCRATCH:\n+    case PC:\n+    case CC0:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return x;\n+\n+    case REG:\n+      /* Verify that the register has an entry before trying to access it.  */\n+      if (REGNO (x) < nregs && reg_map[REGNO (x)] != 0)\n+\treturn reg_map[REGNO (x)];\n+      return x;\n+\n+    case SUBREG:\n+      /* Prevent making nested SUBREGs.  */\n+      if (GET_CODE (SUBREG_REG (x)) == REG && REGNO (SUBREG_REG (x)) < nregs\n+\t  && reg_map[REGNO (SUBREG_REG (x))] != 0\n+\t  && GET_CODE (reg_map[REGNO (SUBREG_REG (x))]) == SUBREG)\n+\t{\n+\t  rtx map_val = reg_map[REGNO (SUBREG_REG (x))];\n+\t  rtx map_inner = SUBREG_REG (map_val);\n+\n+\t  if (GET_MODE (x) == GET_MODE (map_inner))\n+\t    return map_inner;\n+\t  else\n+\t    {\n+\t      /* We cannot call gen_rtx here since we may be linked with\n+\t\t genattrtab.c.  */\n+\t      /* Let's try clobbering the incoming SUBREG and see\n+\t\t if this is really safe.  */\n+\t      SUBREG_REG (x) = map_inner;\n+\t      SUBREG_WORD (x) += SUBREG_WORD (map_val);\n+\t      return x;\n+#if 0\n+\t      rtx new = rtx_alloc (SUBREG);\n+\t      PUT_MODE (new, GET_MODE (x));\n+\t      SUBREG_REG (new) = map_inner;\n+\t      SUBREG_WORD (new) = SUBREG_WORD (x) + SUBREG_WORD (map_val);\n+#endif\n+\t    }\n+\t}\n+      break;\n+\n+    case SET:\n+      if (replace_dest)\n+\tSET_DEST (x) = replace_regs (SET_DEST (x), reg_map, nregs, 0);\n+\n+      else if (GET_CODE (SET_DEST (x)) == MEM\n+\t       || GET_CODE (SET_DEST (x)) == STRICT_LOW_PART)\n+\t/* Even if we are not to replace destinations, replace register if it\n+\t   is CONTAINED in destination (destination is memory or\n+\t   STRICT_LOW_PART).  */\n+\tXEXP (SET_DEST (x), 0) = replace_regs (XEXP (SET_DEST (x), 0),\n+\t\t\t\t\t       reg_map, nregs, 0);\n+      else if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT)\n+\t/* Similarly, for ZERO_EXTRACT we replace all operands.  */\n+\tbreak;\n+\n+      SET_SRC (x) = replace_regs (SET_SRC (x), reg_map, nregs, 0);\n+      return x;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tXEXP (x, i) = replace_regs (XEXP (x, i), reg_map, nregs, replace_dest);\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    XVECEXP (x, i, j) = replace_regs (XVECEXP (x, i, j), reg_map,\n+\t\t\t\t\t      nregs, replace_dest);\n+\t}\n+    }\n+  return x;\n+}"}]}