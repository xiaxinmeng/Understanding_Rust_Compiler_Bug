{"sha": "3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MyYzRmMjIwMjJlYzQxYjJhOTgxOTI0NGU5NjFlNWEyNjdjYmQ4Yg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-23T14:28:29Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-23T14:28:29Z"}, "message": "sbitmap.h (struct int_list): Remove.\n\n\t* sbitmap.h (struct int_list): Remove.\n\t(sbitmap_intersect_of_predsucc, sbitmap_union_of_predsucc):\n\tRemove prototypes of non-existing function.\n\t(sbitmap_intersect_of_predecessors, sbitmap_intersect_of_successors,\n\tsbitmap_union_of_predecessors, sbitmap_union_of_successors): Remove\n\tunused defines.\n\t(sbitmap_intersection_of_succs, sbitmap_intersection_of_preds,\n\tsbitmap_union_of_succs, sbitmap_union_of_preds): Move prototypes to...\n\t* basic-block.h: ... here.\n\t* sbitmap.c: Do not include basic-block.h.\n\t(sbitmap_intersection_of_succs, sbitmap_intersection_of_preds,\n\tsbitmap_union_of_succs, sbitmap_union_of_preds): Move functions to...\n\t* cfganal.c: ... here.\n\t* bt-load.c (compute_out, link_btr_uses): Update for above changes.\n\t* gcse.c (compute_code_hoist_vbeinout): Likewise.\n\t* lcm.c (compute_antinout_edge, compute_available): Likewise.\n\t* Makefile.in: Fix sbitmap.o dependencies.\n\nFrom-SVN: r189785", "tree": {"sha": "f6da776c8dafac61253e8fb4ce7919242d83abf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6da776c8dafac61253e8fb4ce7919242d83abf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/comments", "author": null, "committer": null, "parents": [{"sha": "87d84e1eb6830abc45c9df8418b2213a6447351d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d84e1eb6830abc45c9df8418b2213a6447351d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d84e1eb6830abc45c9df8418b2213a6447351d"}], "stats": {"total": 428, "additions": 210, "deletions": 218}, "files": [{"sha": "6ab125ca83aebd2651492334542389a593ec0cfe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -1,3 +1,23 @@\n+2012-07-22  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* sbitmap.h (struct int_list): Remove.\n+\t(sbitmap_intersect_of_predsucc, sbitmap_union_of_predsucc):\n+\tRemove prototypes of non-existing function.\n+\t(sbitmap_intersect_of_predecessors, sbitmap_intersect_of_successors,\n+\tsbitmap_union_of_predecessors, sbitmap_union_of_successors): Remove\n+\tunused defines.\n+\t(sbitmap_intersection_of_succs, sbitmap_intersection_of_preds,\n+\tsbitmap_union_of_succs, sbitmap_union_of_preds): Move prototypes to...\n+\t* basic-block.h: ... here.\n+\t* sbitmap.c: Do not include basic-block.h.\n+\t(sbitmap_intersection_of_succs, sbitmap_intersection_of_preds,\n+\tsbitmap_union_of_succs, sbitmap_union_of_preds): Move functions to...\n+\t* cfganal.c: ... here.\n+\t* bt-load.c (compute_out, link_btr_uses): Update for above changes.\n+\t* gcse.c (compute_code_hoist_vbeinout): Likewise.\n+\t* lcm.c (compute_antinout_edge, compute_available): Likewise.\n+\t* Makefile.in: Fix sbitmap.o dependencies.\n+\n 2012-07-23  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n \t    Nick Clifton  <nickc@redhat.com>\n "}, {"sha": "c688fa5880539ddf7e9cd9caedad0fc99d09f34d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -1842,7 +1842,7 @@ graph.o: graph.c $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H) $\n     $(RTL_H) $(FUNCTION_H) hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(OBSTACK_H) \\\n     $(CONFIG_H) $(EMIT_RTL_H)\n \n-sbitmap.o: sbitmap.c sbitmap.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(BASIC_BLOCK_H)\n+sbitmap.o: sbitmap.c sbitmap.h $(CONFIG_H) $(SYSTEM_H) coretypes.h\n ebitmap.o: ebitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(EBITMAP_H)\n sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h $(CONFIG_H)\n "}, {"sha": "15d34e0e1ac8be1b651dc77bb5edb37c029d089b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -674,6 +674,12 @@ ei_cond (edge_iterator ei, edge *p)\n #define CLEANUP_CFGLAYOUT\t32\t/* Do cleanup in cfglayout mode.  */\n #define CLEANUP_CFG_CHANGED\t64      /* The caller changed the CFG.  */\n \n+/* In cfganal.c */\n+extern void sbitmap_intersection_of_succs (sbitmap, sbitmap *, basic_block);\n+extern void sbitmap_intersection_of_preds (sbitmap, sbitmap *, basic_block);\n+extern void sbitmap_union_of_succs (sbitmap, sbitmap *, basic_block);\n+extern void sbitmap_union_of_preds (sbitmap, sbitmap *, basic_block);\n+\n /* In lcm.c */\n extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,\n \t\t\t\t       sbitmap *, sbitmap *, sbitmap **,"}, {"sha": "2cab03cc86e44258e3a3bc307f315deda4f3125f", "filename": "gcc/bt-load.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -650,7 +650,7 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n       changed = 0;\n       for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n \t{\n-\t  sbitmap_union_of_preds (bb_in, bb_out, i);\n+\t  sbitmap_union_of_preds (bb_in, bb_out, BASIC_BLOCK (i));\n \t  changed |= sbitmap_union_of_diff_cg (bb_out[i], bb_gen[i],\n \t\t\t\t\t       bb_in, bb_kill[i]);\n \t}\n@@ -673,7 +673,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n       rtx insn;\n       rtx last;\n \n-      sbitmap_union_of_preds (reaching_defs, bb_out, i);\n+      sbitmap_union_of_preds (reaching_defs, bb_out, BASIC_BLOCK (i));\n       for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n \t   insn != last;\n \t   insn = NEXT_INSN (insn))"}, {"sha": "692be3808b81762f8c8c0a34289beb2b7138422b", "filename": "gcc/cfganal.c", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -1182,4 +1182,177 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n   return phi_insertion_points;\n }\n \n+/* Intersection and union of preds/succs for sbitmap based data flow\n+   solvers.  All four functions defined below take the same arguments:\n+   B is the basic block to perform the operation for.  DST is the\n+   target sbitmap, i.e. the result.  SRC is an sbitmap vector of size\n+   last_basic_block so that it can be indexed with basic block indices.\n+   DST may be (but does not have to be) SRC[B->index].  */\n \n+/* Set the bitmap DST to the intersection of SRC of successors of\n+   basic block B.  */\n+\n+void\n+sbitmap_intersection_of_succs (sbitmap dst, sbitmap *src,\n+\t\t\t       basic_block b)\n+{\n+  unsigned int set_size = dst->size;\n+  edge e;\n+  unsigned ix;\n+\n+  gcc_assert (!dst->popcount);\n+\n+  for (e = NULL, ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n+    {\n+      e = EDGE_SUCC (b, ix);\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      sbitmap_copy (dst, src[e->dest->index]);\n+      break;\n+    }\n+\n+  if (e == 0)\n+    sbitmap_ones (dst);\n+  else\n+    for (++ix; ix < EDGE_COUNT (b->succs); ix++)\n+      {\n+\tunsigned int i;\n+\tSBITMAP_ELT_TYPE *p, *r;\n+\n+\te = EDGE_SUCC (b, ix);\n+\tif (e->dest == EXIT_BLOCK_PTR)\n+\t  continue;\n+\n+\tp = src[e->dest->index]->elms;\n+\tr = dst->elms;\n+\tfor (i = 0; i < set_size; i++)\n+\t  *r++ &= *p++;\n+      }\n+}\n+\n+/* Set the bitmap DST to the intersection of SRC of predecessors of\n+   basic block B.  */\n+\n+void\n+sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src,\n+\t\t\t       basic_block b)\n+{\n+  unsigned int set_size = dst->size;\n+  edge e;\n+  unsigned ix;\n+\n+  gcc_assert (!dst->popcount);\n+\n+  for (e = NULL, ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n+    {\n+      e = EDGE_PRED (b, ix);\n+      if (e->src == ENTRY_BLOCK_PTR)\n+\tcontinue;\n+\n+      sbitmap_copy (dst, src[e->src->index]);\n+      break;\n+    }\n+\n+  if (e == 0)\n+    sbitmap_ones (dst);\n+  else\n+    for (++ix; ix < EDGE_COUNT (b->preds); ix++)\n+      {\n+\tunsigned int i;\n+\tSBITMAP_ELT_TYPE *p, *r;\n+\n+\te = EDGE_PRED (b, ix);\n+\tif (e->src == ENTRY_BLOCK_PTR)\n+\t  continue;\n+\n+\tp = src[e->src->index]->elms;\n+\tr = dst->elms;\n+\tfor (i = 0; i < set_size; i++)\n+\t  *r++ &= *p++;\n+      }\n+}\n+\n+/* Set the bitmap DST to the union of SRC of successors of\n+   basic block B.  */\n+\n+void\n+sbitmap_union_of_succs (sbitmap dst, sbitmap *src,\n+\t\t\tbasic_block b)\n+{\n+  unsigned int set_size = dst->size;\n+  edge e;\n+  unsigned ix;\n+\n+  gcc_assert (!dst->popcount);\n+\n+  for (ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n+    {\n+      e = EDGE_SUCC (b, ix);\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      sbitmap_copy (dst, src[e->dest->index]);\n+      break;\n+    }\n+\n+  if (ix == EDGE_COUNT (b->succs))\n+    sbitmap_zero (dst);\n+  else\n+    for (ix++; ix < EDGE_COUNT (b->succs); ix++)\n+      {\n+\tunsigned int i;\n+\tSBITMAP_ELT_TYPE *p, *r;\n+\n+\te = EDGE_SUCC (b, ix);\n+\tif (e->dest == EXIT_BLOCK_PTR)\n+\t  continue;\n+\n+\tp = src[e->dest->index]->elms;\n+\tr = dst->elms;\n+\tfor (i = 0; i < set_size; i++)\n+\t  *r++ |= *p++;\n+      }\n+}\n+\n+/* Set the bitmap DST to the union of SRC of predecessors of\n+   basic block B.  */\n+\n+void\n+sbitmap_union_of_preds (sbitmap dst, sbitmap *src,\n+\t\t\tbasic_block b)\n+{\n+  unsigned int set_size = dst->size;\n+  edge e;\n+  unsigned ix;\n+\n+  gcc_assert (!dst->popcount);\n+\n+  for (ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n+    {\n+      e = EDGE_PRED (b, ix);\n+      if (e->src== ENTRY_BLOCK_PTR)\n+\tcontinue;\n+\n+      sbitmap_copy (dst, src[e->src->index]);\n+      break;\n+    }\n+\n+  if (ix == EDGE_COUNT (b->preds))\n+    sbitmap_zero (dst);\n+  else\n+    for (ix++; ix < EDGE_COUNT (b->preds); ix++)\n+      {\n+\tunsigned int i;\n+\tSBITMAP_ELT_TYPE *p, *r;\n+\n+\te = EDGE_PRED (b, ix);\n+\tif (e->src == ENTRY_BLOCK_PTR)\n+\t  continue;\n+\n+\tp = src[e->src->index]->elms;\n+\tr = dst->elms;\n+\tfor (i = 0; i < set_size; i++)\n+\t  *r++ |= *p++;\n+      }\n+}"}, {"sha": "f7c42d200926798182427ec745b902cb8334c48a", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -2790,7 +2790,7 @@ compute_code_hoist_vbeinout (void)\n \t  if (bb->next_bb != EXIT_BLOCK_PTR)\n \t    {\n \t      sbitmap_intersection_of_succs (hoist_vbeout[bb->index],\n-\t\t\t\t\t     hoist_vbein, bb->index);\n+\t\t\t\t\t     hoist_vbein, bb);\n \n \t      /* Include expressions in VBEout that are calculated\n \t\t in BB and available at its end.  */"}, {"sha": "fec2ba45d306779427d6ebeb4334013a01e37125", "filename": "gcc/lcm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -145,7 +145,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \t  /* Clear the aux field of this block so that it can be added to\n \t     the worklist again if necessary.  */\n \t  bb->aux = NULL;\n-\t  sbitmap_intersection_of_succs (antout[bb->index], antin, bb->index);\n+\t  sbitmap_intersection_of_succs (antout[bb->index], antin, bb);\n \t}\n \n       if (sbitmap_a_or_b_and_c_cg (antin[bb->index], antloc[bb->index],\n@@ -526,7 +526,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n \t  /* Clear the aux field of this block so that it can be added to\n \t     the worklist again if necessary.  */\n \t  bb->aux = NULL;\n-\t  sbitmap_intersection_of_preds (avin[bb->index], avout, bb->index);\n+\t  sbitmap_intersection_of_preds (avin[bb->index], avout, bb);\n \t}\n \n       if (sbitmap_union_of_diff_cg (avout[bb->index], avloc[bb->index],"}, {"sha": "d606736c4c7d283ee52cdaa42fc390d2b45fe887", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 4, "deletions": 191, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -23,15 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"sbitmap.h\"\n \n-#ifdef IN_GCC\n-/* FIXME: sbitmap is just a data structure, but we define dataflow functions\n-   here also.  This is conditional on IN_GCC (see second #ifdef IN_GCC\n-   further down).\n-   For now, also only conditionally include basic-block.h, but we should\n-   find a better place for the dataflow functions.  Perhaps cfganal.c?  */\n-#include \"basic-block.h\"\n-#endif\n-\n #if GCC_VERSION >= 3400\n #  if HOST_BITS_PER_WIDEST_FAST_INT == HOST_BITS_PER_LONG\n #    define do_popcount(x) __builtin_popcountl(x)\n@@ -744,184 +735,6 @@ sbitmap_a_and_b_or_c (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitm\n     *dstp++ = *ap++ & (*bp++ | *cp++);\n }\n \n-#ifdef IN_GCC\n-/* FIXME: depends on basic-block.h, see comment at start of this file.\n-\n-   Ironically, the comments before the functions below suggest they do\n-   dataflow using the \"new flow graph structures\", but that's the *old*\n-   new data structures.  The functions receive basic block numbers and\n-   use BASIC_BLOCK(idx) to get the basic block.  They should receive\n-   the basic block directly,  *sigh*.  */\n-\n-/* Set the bitmap DST to the intersection of SRC of successors of\n-   block number BB, using the new flow graph structures.  */\n-\n-void\n-sbitmap_intersection_of_succs (sbitmap dst, sbitmap *src, int bb)\n-{\n-  basic_block b = BASIC_BLOCK (bb);\n-  unsigned int set_size = dst->size;\n-  edge e;\n-  unsigned ix;\n-\n-  gcc_assert (!dst->popcount);\n-\n-  for (e = NULL, ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n-    {\n-      e = EDGE_SUCC (b, ix);\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      sbitmap_copy (dst, src[e->dest->index]);\n-      break;\n-    }\n-\n-  if (e == 0)\n-    sbitmap_ones (dst);\n-  else\n-    for (++ix; ix < EDGE_COUNT (b->succs); ix++)\n-      {\n-\tunsigned int i;\n-\tsbitmap_ptr p, r;\n-\n-\te = EDGE_SUCC (b, ix);\n-\tif (e->dest == EXIT_BLOCK_PTR)\n-\t  continue;\n-\n-\tp = src[e->dest->index]->elms;\n-\tr = dst->elms;\n-\tfor (i = 0; i < set_size; i++)\n-\t  *r++ &= *p++;\n-      }\n-}\n-\n-/* Set the bitmap DST to the intersection of SRC of predecessors of\n-   block number BB, using the new flow graph structures.  */\n-\n-void\n-sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src, int bb)\n-{\n-  basic_block b = BASIC_BLOCK (bb);\n-  unsigned int set_size = dst->size;\n-  edge e;\n-  unsigned ix;\n-\n-  gcc_assert (!dst->popcount);\n-\n-  for (e = NULL, ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n-    {\n-      e = EDGE_PRED (b, ix);\n-      if (e->src == ENTRY_BLOCK_PTR)\n-\tcontinue;\n-\n-      sbitmap_copy (dst, src[e->src->index]);\n-      break;\n-    }\n-\n-  if (e == 0)\n-    sbitmap_ones (dst);\n-  else\n-    for (++ix; ix < EDGE_COUNT (b->preds); ix++)\n-      {\n-\tunsigned int i;\n-\tsbitmap_ptr p, r;\n-\n-\te = EDGE_PRED (b, ix);\n-\tif (e->src == ENTRY_BLOCK_PTR)\n-\t  continue;\n-\n-\tp = src[e->src->index]->elms;\n-\tr = dst->elms;\n-\tfor (i = 0; i < set_size; i++)\n-\t  *r++ &= *p++;\n-      }\n-}\n-\n-/* Set the bitmap DST to the union of SRC of successors of\n-   block number BB, using the new flow graph structures.  */\n-\n-void\n-sbitmap_union_of_succs (sbitmap dst, sbitmap *src, int bb)\n-{\n-  basic_block b = BASIC_BLOCK (bb);\n-  unsigned int set_size = dst->size;\n-  edge e;\n-  unsigned ix;\n-\n-  gcc_assert (!dst->popcount);\n-\n-  for (ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n-    {\n-      e = EDGE_SUCC (b, ix);\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      sbitmap_copy (dst, src[e->dest->index]);\n-      break;\n-    }\n-\n-  if (ix == EDGE_COUNT (b->succs))\n-    sbitmap_zero (dst);\n-  else\n-    for (ix++; ix < EDGE_COUNT (b->succs); ix++)\n-      {\n-\tunsigned int i;\n-\tsbitmap_ptr p, r;\n-\n-\te = EDGE_SUCC (b, ix);\n-\tif (e->dest == EXIT_BLOCK_PTR)\n-\t  continue;\n-\n-\tp = src[e->dest->index]->elms;\n-\tr = dst->elms;\n-\tfor (i = 0; i < set_size; i++)\n-\t  *r++ |= *p++;\n-      }\n-}\n-\n-/* Set the bitmap DST to the union of SRC of predecessors of\n-   block number BB, using the new flow graph structures.  */\n-\n-void\n-sbitmap_union_of_preds (sbitmap dst, sbitmap *src, int bb)\n-{\n-  basic_block b = BASIC_BLOCK (bb);\n-  unsigned int set_size = dst->size;\n-  edge e;\n-  unsigned ix;\n-\n-  gcc_assert (!dst->popcount);\n-\n-  for (ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n-    {\n-      e = EDGE_PRED (b, ix);\n-      if (e->src== ENTRY_BLOCK_PTR)\n-\tcontinue;\n-\n-      sbitmap_copy (dst, src[e->src->index]);\n-      break;\n-    }\n-\n-  if (ix == EDGE_COUNT (b->preds))\n-    sbitmap_zero (dst);\n-  else\n-    for (ix++; ix < EDGE_COUNT (b->preds); ix++)\n-      {\n-\tunsigned int i;\n-\tsbitmap_ptr p, r;\n-\n-\te = EDGE_PRED (b, ix);\n-\tif (e->src == ENTRY_BLOCK_PTR)\n-\t  continue;\n-\n-\tp = src[e->src->index]->elms;\n-\tr = dst->elms;\n-\tfor (i = 0; i < set_size; i++)\n-\t  *r++ |= *p++;\n-      }\n-}\n-#endif\n-\n /* Return number of first bit set in the bitmap, -1 if none.  */\n \n int\n@@ -1021,13 +834,13 @@ void\n dump_sbitmap_vector (FILE *file, const char *title, const char *subtitle,\n \t\t     sbitmap *bmaps, int n_maps)\n {\n-  int bb;\n+  int i;\n \n   fprintf (file, \"%s\\n\", title);\n-  for (bb = 0; bb < n_maps; bb++)\n+  for (i = 0; i < n_maps; i++)\n     {\n-      fprintf (file, \"%s %d\\n\", subtitle, bb);\n-      dump_sbitmap (file, bmaps[bb]);\n+      fprintf (file, \"%s %d\\n\", subtitle, i);\n+      dump_sbitmap (file, bmaps[i]);\n     }\n \n   fprintf (file, \"\\n\");"}, {"sha": "9bd4ccdcde06b844b3d97a84145bde881d161dd9", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2c4f22022ec41b2a9819244e961e5a267cbd8b/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "patch": "@@ -201,8 +201,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define sbitmap_free(MAP)\t\t(free((MAP)->popcount), free((MAP)))\n #define sbitmap_vector_free(VEC)\tfree(VEC)\n \n-struct int_list;\n-\n extern void dump_sbitmap (FILE *, const_sbitmap);\n extern void dump_sbitmap_file (FILE *, const_sbitmap);\n extern void dump_sbitmap_vector (FILE *, const char *, const char *, sbitmap *,\n@@ -241,26 +239,8 @@ extern bool sbitmap_a_subset_b_p (const_sbitmap, const_sbitmap);\n extern int sbitmap_first_set_bit (const_sbitmap);\n extern int sbitmap_last_set_bit (const_sbitmap);\n \n-extern void sbitmap_intersect_of_predsucc (sbitmap, sbitmap *, int,\n-\t\t\t\t\t   struct int_list **);\n-#define sbitmap_intersect_of_predecessors  sbitmap_intersect_of_predsucc\n-#define sbitmap_intersect_of_successors    sbitmap_intersect_of_predsucc\n-\n-extern void sbitmap_union_of_predsucc (sbitmap, sbitmap *, int,\n-\t\t\t\t       struct int_list **);\n-#define sbitmap_union_of_predecessors  sbitmap_union_of_predsucc\n-#define sbitmap_union_of_successors    sbitmap_union_of_predsucc\n-\n-/* Intersection and Union of preds/succs using the new flow graph\n-   structure instead of the pred/succ arrays.  */\n-\n-extern void sbitmap_intersection_of_succs (sbitmap, sbitmap *, int);\n-extern void sbitmap_intersection_of_preds (sbitmap, sbitmap *, int);\n-extern void sbitmap_union_of_succs (sbitmap, sbitmap *, int);\n-extern void sbitmap_union_of_preds (sbitmap, sbitmap *, int);\n-\n extern void debug_sbitmap (const_sbitmap);\n extern sbitmap sbitmap_realloc (sbitmap, unsigned int);\n-extern unsigned long sbitmap_popcount(const_sbitmap, unsigned long);\n+extern unsigned long sbitmap_popcount (const_sbitmap, unsigned long);\n extern void sbitmap_verify_popcount (const_sbitmap);\n #endif /* ! GCC_SBITMAP_H */"}]}