{"sha": "30d02149ea4baeea9045e07354a152a68e120fec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBkMDIxNDllYTRiYWVlYTkwNDVlMDczNTRhMTUyYTY4ZTEyMGZlYw==", "commit": {"author": {"name": "Carl Love", "email": "cel@us.ibm.com", "date": "2020-07-02T20:30:30Z"}, "committer": {"name": "Carl Love", "email": "carll@us.ibm.com", "date": "2020-08-05T04:08:29Z"}, "message": "rs6000, Update support for vec_extract\n\nGCC maintainers:\n\nMove the existing vector extract support in altivec.md to vsx.md\nso all of the vector insert and extract support is in the same file.\n\nThe patch also updates the name of the builtins and descriptions for the\nbuiltins in the documentation file so they match the approved builtin\nnames and descriptions.\n\nThe patch does not make any functional changes.\n\nPlease let me know if the changes are acceptable for mainline.  Thanks.\n\n                  Carl Love\n\n------------------------------------------------------\n\ngcc/ChangeLog\n\n\t    2020-08-04  Carl Love  <cel@us.ibm.com>\n\n\t* config/rs6000/altivec.md: (UNSPEC_EXTRACTL, UNSPEC_EXTRACTR)\n\t(vextractl<mode>, vextractr<mode>)\n\t(vextractl<mode>_internal, vextractr<mode>_internal for mode VI2)\n\t(VI2): Move to ...\n\t* config/rs6000/vsx.md:\t(UNSPEC_EXTRACTL, UNSPEC_EXTRACTR)\n\t(vextractl<mode>, vextractr<mode>)\n\t(vextractl<mode>_internal, vextractr<mode>_internal for mode VI2)\n\t(VI2):  ..here.\n\t* doc/extend.texi: Update documentation for vec_extractl.\n\tReplace builtin name vec_extractr with vec_extracth.  Update\n\tdescription of vec_extracth.", "tree": {"sha": "427e169b9e9997631a12b031a445e7e8a3fb36f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/427e169b9e9997631a12b031a445e7e8a3fb36f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30d02149ea4baeea9045e07354a152a68e120fec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d02149ea4baeea9045e07354a152a68e120fec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30d02149ea4baeea9045e07354a152a68e120fec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d02149ea4baeea9045e07354a152a68e120fec/comments", "author": {"login": "carlelove", "id": 86435705, "node_id": "MDQ6VXNlcjg2NDM1NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/86435705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carlelove", "html_url": "https://github.com/carlelove", "followers_url": "https://api.github.com/users/carlelove/followers", "following_url": "https://api.github.com/users/carlelove/following{/other_user}", "gists_url": "https://api.github.com/users/carlelove/gists{/gist_id}", "starred_url": "https://api.github.com/users/carlelove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carlelove/subscriptions", "organizations_url": "https://api.github.com/users/carlelove/orgs", "repos_url": "https://api.github.com/users/carlelove/repos", "events_url": "https://api.github.com/users/carlelove/events{/privacy}", "received_events_url": "https://api.github.com/users/carlelove/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "abba25914e8b2bd16c7722342eb2e34ecd316796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abba25914e8b2bd16c7722342eb2e34ecd316796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abba25914e8b2bd16c7722342eb2e34ecd316796"}], "stats": {"total": 213, "additions": 110, "deletions": 103}, "files": [{"sha": "dff4399ba4ac098d1cb2b0696d8166e9440142d3", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d02149ea4baeea9045e07354a152a68e120fec/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d02149ea4baeea9045e07354a152a68e120fec/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=30d02149ea4baeea9045e07354a152a68e120fec", "patch": "@@ -173,8 +173,6 @@\n    UNSPEC_XXEVAL\n    UNSPEC_VSTRIR\n    UNSPEC_VSTRIL\n-   UNSPEC_EXTRACTL\n-   UNSPEC_EXTRACTR\n ])\n \n (define_c_enum \"unspecv\"\n@@ -185,8 +183,6 @@\n    UNSPECV_DSS\n   ])\n \n-;; Like VI, defined in vector.md, but add ISA 2.07 integer vector ops\n-(define_mode_iterator VI2 [V4SI V8HI V16QI V2DI])\n ;; Short vec int modes\n (define_mode_iterator VIshort [V8HI V16QI])\n ;; Longer vec int modes for rotate/mask ops\n@@ -787,66 +783,6 @@\n   DONE;\n })\n \n-(define_expand \"vextractl<mode>\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\")\n-\t(unspec:V2DI [(match_operand:VI2 1 \"altivec_register_operand\")\n-\t\t      (match_operand:VI2 2 \"altivec_register_operand\")\n-\t\t      (match_operand:SI 3 \"register_operand\")]\n-\t\t     UNSPEC_EXTRACTL))]\n-  \"TARGET_POWER10\"\n-{\n-  if (BYTES_BIG_ENDIAN)\n-    {\n-      emit_insn (gen_vextractl<mode>_internal (operands[0], operands[1],\n-\t\t\t\t\t       operands[2], operands[3]));\n-      emit_insn (gen_xxswapd_v2di (operands[0], operands[0]));\n-    }\n-  else\n-    emit_insn (gen_vextractr<mode>_internal (operands[0], operands[2],\n-\t\t\t\t\t     operands[1], operands[3]));\n-  DONE;\n-})\n-\n-(define_insn \"vextractl<mode>_internal\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n-\t(unspec:V2DI [(match_operand:VEC_I 1 \"altivec_register_operand\" \"v\")\n-\t\t      (match_operand:VEC_I 2 \"altivec_register_operand\" \"v\")\n-\t\t      (match_operand:SI 3 \"register_operand\" \"r\")]\n-\t\t     UNSPEC_EXTRACTL))]\n-  \"TARGET_POWER10\"\n-  \"vext<du_or_d><wd>vlx %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_expand \"vextractr<mode>\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\")\n-\t(unspec:V2DI [(match_operand:VI2 1 \"altivec_register_operand\")\n-\t\t      (match_operand:VI2 2 \"altivec_register_operand\")\n-\t\t      (match_operand:SI 3 \"register_operand\")]\n-\t\t     UNSPEC_EXTRACTR))]\n-  \"TARGET_POWER10\"\n-{\n-  if (BYTES_BIG_ENDIAN)\n-    {\n-      emit_insn (gen_vextractr<mode>_internal (operands[0], operands[1],\n-\t\t\t\t\t       operands[2], operands[3]));\n-      emit_insn (gen_xxswapd_v2di (operands[0], operands[0]));\n-    }\n-  else\n-    emit_insn (gen_vextractl<mode>_internal (operands[0], operands[2],\n-    \t\t\t\t\t     operands[1], operands[3]));\n-  DONE;\n-})\n-\n-(define_insn \"vextractr<mode>_internal\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n-\t(unspec:V2DI [(match_operand:VEC_I 1 \"altivec_register_operand\" \"v\")\n-\t\t      (match_operand:VEC_I 2 \"altivec_register_operand\" \"v\")\n-\t\t      (match_operand:SI 3 \"register_operand\" \"r\")]\n-\t\t     UNSPEC_EXTRACTR))]\n-  \"TARGET_POWER10\"\n-  \"vext<du_or_d><wd>vrx %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n (define_expand \"vstrir_<mode>\"\n   [(set (match_operand:VIshort 0 \"altivec_register_operand\")\n \t(unspec:VIshort [(match_operand:VIshort 1 \"altivec_register_operand\")]"}, {"sha": "77b2afef57e885e0d5327e089ee8ccd0b17cd21b", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d02149ea4baeea9045e07354a152a68e120fec/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d02149ea4baeea9045e07354a152a68e120fec/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=30d02149ea4baeea9045e07354a152a68e120fec", "patch": "@@ -355,6 +355,8 @@\n    UNSPEC_VCNTMB\n    UNSPEC_VEXPAND\n    UNSPEC_VEXTRACT\n+   UNSPEC_EXTRACTL\n+   UNSPEC_EXTRACTR\n   ])\n \n (define_int_iterator XVCVBF16\t[UNSPEC_VSX_XVCVSPBF16\n@@ -363,6 +365,9 @@\n (define_int_attr xvcvbf16       [(UNSPEC_VSX_XVCVSPBF16 \"xvcvspbf16\")\n \t\t\t\t (UNSPEC_VSX_XVCVBF16SP \"xvcvbf16sp\")])\n \n+;; Like VI, defined in vector.md, but add ISA 2.07 integer vector ops\n+(define_mode_iterator VI2 [V4SI V8HI V16QI V2DI])\n+\n ;; VSX moves\n \n ;; The patterns for LE permuted loads and stores come before the general\n@@ -3846,6 +3851,67 @@\n }\n   [(set_attr \"type\" \"load\")])\n \n+;; ISA 3.1 extract\n+(define_expand \"vextractl<mode>\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\")\n+\t(unspec:V2DI [(match_operand:VI2 1 \"altivec_register_operand\")\n+\t\t      (match_operand:VI2 2 \"altivec_register_operand\")\n+\t\t      (match_operand:SI 3 \"register_operand\")]\n+\t\t     UNSPEC_EXTRACTL))]\n+  \"TARGET_POWER10\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      emit_insn (gen_vextractl<mode>_internal (operands[0], operands[1],\n+\t\t\t\t\t       operands[2], operands[3]));\n+      emit_insn (gen_xxswapd_v2di (operands[0], operands[0]));\n+    }\n+  else\n+    emit_insn (gen_vextractr<mode>_internal (operands[0], operands[2],\n+\t\t\t\t\t     operands[1], operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"vextractl<mode>_internal\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:V2DI [(match_operand:VEC_I 1 \"altivec_register_operand\" \"v\")\n+\t\t      (match_operand:VEC_I 2 \"altivec_register_operand\" \"v\")\n+\t\t      (match_operand:SI 3 \"register_operand\" \"r\")]\n+\t\t     UNSPEC_EXTRACTL))]\n+  \"TARGET_POWER10\"\n+  \"vext<du_or_d><wd>vlx %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_expand \"vextractr<mode>\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\")\n+\t(unspec:V2DI [(match_operand:VI2 1 \"altivec_register_operand\")\n+\t\t      (match_operand:VI2 2 \"altivec_register_operand\")\n+\t\t      (match_operand:SI 3 \"register_operand\")]\n+\t\t     UNSPEC_EXTRACTR))]\n+  \"TARGET_POWER10\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      emit_insn (gen_vextractr<mode>_internal (operands[0], operands[1],\n+\t\t\t\t\t       operands[2], operands[3]));\n+      emit_insn (gen_xxswapd_v2di (operands[0], operands[0]));\n+    }\n+  else\n+    emit_insn (gen_vextractl<mode>_internal (operands[0], operands[2],\n+\t\t\t\t\t     operands[1], operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"vextractr<mode>_internal\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:V2DI [(match_operand:VEC_I 1 \"altivec_register_operand\" \"v\")\n+\t\t      (match_operand:VEC_I 2 \"altivec_register_operand\" \"v\")\n+\t\t      (match_operand:SI 3 \"register_operand\" \"r\")]\n+\t\t     UNSPEC_EXTRACTR))]\n+  \"TARGET_POWER10\"\n+  \"vext<du_or_d><wd>vrx %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n ;; VSX_EXTRACT optimizations\n ;; Optimize double d = (double) vec_extract (vi, <n>)\n ;; Get the element into the top position and use XVCVSWDP/XVCVUWDP"}, {"sha": "e76636f77ce198e80129618a11dc938cfb9387dc", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d02149ea4baeea9045e07354a152a68e120fec/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d02149ea4baeea9045e07354a152a68e120fec/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=30d02149ea4baeea9045e07354a152a68e120fec", "patch": "@@ -20952,6 +20952,9 @@ Perform a 128-bit vector gather  operation, as if implemented by the\n integer value between 2 and 7 inclusive.\n @findex vec_gnb\n \n+\n+Vector Extract\n+\n @smallexample\n @exdent vector unsigned long long int\n @exdent vec_extractl (vector unsigned char, vector unsigned char, unsigned int)\n@@ -20962,52 +20965,54 @@ integer value between 2 and 7 inclusive.\n @exdent vector unsigned long long int\n @exdent vec_extractl (vector unsigned long long, vector unsigned long long, unsigned int)\n @end smallexample\n-Extract a single element from the vector formed by catenating this function's\n-first two arguments at the byte offset specified by this function's\n-third argument.  On big-endian targets, this function behaves as if\n-implemented by the @code{vextdubvlx}, @code{vextduhvlx},\n-@code{vextduwvlx}, or @code{vextddvlx} instructions, depending on the\n-types of the function's first two arguments.  On little-endian\n-targets, this function behaves as if implemented by the\n-@code{vextdubvrx}, @code{vextduhvrx},\n-@code{vextduwvrx}, or @code{vextddvrx} instructions.\n-The byte offset of the element to be extracted is calculated\n-by computing the remainder of dividing the third argument by 32.\n-If this reminader value is not a multiple of the vector element size,\n-or if its value added to the vector element size exceeds 32, the\n-result is undefined.\n+Extract an element from two concatenated vectors starting at the given byte index\n+in natural-endian order, and place it zero-extended in doubleword 1 of the result\n+according to natural element order.  If the byte index is out of range for the\n+data type, the intrinsic will be rejected.\n+For little-endian, this output will match the placement by the hardware\n+instruction, i.e., dword[0] in RTL notation.  For big-endian, an additional\n+instruction is needed to move it from the \"left\" doubleword to the  \"right\" one.\n+For little-endian, semantics matching the @code{vextdubvrx},\n+@code{vextduhvrx}, @code{vextduwvrx} instruction will be generated, while for\n+big-endian, semantics matching the @code{vextdubvlx}, @code{vextduhvlx},\n+@code{vextduwvlx} instructions\n+will be generated.  Note that some fairly anomalous results can be generated if\n+the byte index is not aligned on an element boundary for the element being\n+extracted.  This is a limitation of the bi-endian vector programming model is\n+consistent with the limitation on @code{vec_perm}.\n @findex vec_extractl\n \n @smallexample\n @exdent vector unsigned long long int\n-@exdent vec_extractr (vector unsigned char, vector unsigned char, unsigned int)\n+@exdent vec_extracth (vector unsigned char, vector unsigned char, unsigned int)\n @exdent vector unsigned long long int\n-@exdent vec_extractr (vector unsigned short, vector unsigned short, unsigned int)\n+@exdent vec_extracth (vector unsigned short, vector unsigned short,\n+unsigned int)\n @exdent vector unsigned long long int\n-@exdent vec_extractr (vector unsigned int, vector unsigned int, unsigned int)\n+@exdent vec_extracth (vector unsigned int, vector unsigned int, unsigned int)\n @exdent vector unsigned long long int\n-@exdent vec_extractr (vector unsigned long long, vector unsigned long long, unsigned int)\n-@end smallexample\n-Extract a single element from the vector formed by catenating this function's\n-first two arguments at the byte offset calculated by subtracting this\n-function's third argument from 31.  On big-endian targets, this\n-function behaves as if\n-implemented by the\n-@code{vextdubvrx}, @code{vextduhvrx},\n-@code{vextduwvrx}, or @code{vextddvrx} instructions, depending on the\n-types of the function's first two arguments.\n-On little-endian\n-targets, this function behaves as if implemented by the\n-@code{vextdubvlx}, @code{vextduhvlx},\n-@code{vextduwvlx}, or @code{vextddvlx} instructions.\n-The byte offset of the element to be extracted, measured from the\n-right end of the catenation of the two vector arguments, is calculated\n-by computing the remainder of dividing the third argument by 32.\n-If this reminader value is not a multiple of the vector element size,\n-or if its value added to the vector element size exceeds 32, the\n-result is undefined.\n-@findex vec_extractr\n-\n+@exdent vec_extracth (vector unsigned long long, vector unsigned long long,\n+unsigned int)\n+@end smallexample\n+Extract an element from two concatenated vectors starting at the given byte\n+index.  The index is based on big endian order for a little endian system.\n+Similarly, the index is based on little endian order for a big endian system.\n+The extraced elements are zero-extended and put in doubleword 1\n+according to natural element order.  If the byte index is out of range for the\n+data type, the intrinsic will be rejected.  For little-endian, this output\n+will match the placement by the hardware instruction (vextdubvrx, vextduhvrx,\n+vextduwvrx, vextddvrx) i.e., dword[0] in RTL\n+notation.  For big-endian, an additional instruction is needed to move it\n+from the \"left\" doubleword to the \"right\" one.  For little-endian, semantics\n+matching the @code{vextdubvlx}, @code{vextduhvlx}, @code{vextduwvlx}\n+instructions will be generated, while for big-endian, semantics matching the\n+@code{vextdubvrx}, @code{vextduhvrx}, @code{vextduwvrx} instructions will\n+be generated.  Note that some fairly anomalous\n+results can be generated if the byte index is not aligned on the\n+element boundary for the element being extracted.  This is a\n+limitation of the bi-endian vector programming model consistent with the\n+limitation on @code{vec_perm}.\n+@findex vec_extracth\n @smallexample\n @exdent vector unsigned long long int\n @exdent vec_pdep (vector unsigned long long int, vector unsigned long long int)"}]}