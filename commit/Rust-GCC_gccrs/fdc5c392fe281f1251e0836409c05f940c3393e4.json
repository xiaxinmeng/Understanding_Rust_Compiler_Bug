{"sha": "fdc5c392fe281f1251e0836409c05f940c3393e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRjNWMzOTJmZTI4MWYxMjUxZTA4MzY0MDljMDVmOTQwYzMzOTNlNA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:54:05Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:54:05Z"}, "message": "Remove old pool allocator.\n\n\t* alloc-pool.c (create_alloc_pool): Remove.\n\t(empty_alloc_pool): Likewise.\n\t(free_alloc_pool): Likewise.\n\t(free_alloc_pool_if_empty): Likewise.\n\t(pool_alloc): Likewise.\n\t(pool_free): Likewise.\n\t* alloc-pool.h: Remove old declarations.\n\nFrom-SVN: r223973", "tree": {"sha": "cfb9d6ce423da8146e2d2e410058a541d5646cad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfb9d6ce423da8146e2d2e410058a541d5646cad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdc5c392fe281f1251e0836409c05f940c3393e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc5c392fe281f1251e0836409c05f940c3393e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdc5c392fe281f1251e0836409c05f940c3393e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc5c392fe281f1251e0836409c05f940c3393e4/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0b470bae0c63add191f3a66c2538a9d16c0f52e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b470bae0c63add191f3a66c2538a9d16c0f52e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b470bae0c63add191f3a66c2538a9d16c0f52e0"}], "stats": {"total": 335, "additions": 10, "deletions": 325}, "files": [{"sha": "f96a2ef8d0b7aa547bb33f36d76269d9ed515f4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc5c392fe281f1251e0836409c05f940c3393e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc5c392fe281f1251e0836409c05f940c3393e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdc5c392fe281f1251e0836409c05f940c3393e4", "patch": "@@ -1,3 +1,13 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* alloc-pool.c (create_alloc_pool): Remove.\n+\t(empty_alloc_pool): Likewise.\n+\t(free_alloc_pool): Likewise.\n+\t(free_alloc_pool_if_empty): Likewise.\n+\t(pool_alloc): Likewise.\n+\t(pool_free): Likewise.\n+\t* alloc-pool.h: Remove old declarations.\n+\n 2015-06-01  Martin Liska  <mliska@suse.cz>\n \n \t* ira-build.c (initiate_allocnos): Use new type-based pool allocator."}, {"sha": "e9fdc86b01675d6ba026f9cb07e0f481d38304b5", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 0, "deletions": 274, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc5c392fe281f1251e0836409c05f940c3393e4/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc5c392fe281f1251e0836409c05f940c3393e4/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=fdc5c392fe281f1251e0836409c05f940c3393e4", "patch": "@@ -27,39 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n \n ALLOC_POOL_ID_TYPE last_id;\n \n-#define align_eight(x) (((x+7) >> 3) << 3)\n-\n-/* The internal allocation object.  */\n-typedef struct allocation_object_def\n-{\n-#ifdef ENABLE_CHECKING\n-  /* The ID of alloc pool which the object was allocated from.  */\n-  ALLOC_POOL_ID_TYPE id;\n-#endif\n-\n-  union\n-    {\n-      /* The data of the object.  */\n-      char data[1];\n-\n-      /* Because we want any type of data to be well aligned after the ID,\n-\t the following elements are here.  They are never accessed so\n-\t the allocated object may be even smaller than this structure.\n-\t We do not care about alignment for floating-point types.  */\n-      char *align_p;\n-      int64_t align_i;\n-    } u;\n-} allocation_object;\n-\n-/* Convert a pointer to allocation_object from a pointer to user data.  */\n-#define ALLOCATION_OBJECT_PTR_FROM_USER_PTR(X)\t\t\t\t\\\n-   ((allocation_object *) (((char *) (X))\t\t\t\t\\\n-\t\t\t   - offsetof (allocation_object, u.data)))\n-\n-/* Convert a pointer to user data from a pointer to allocation_object.  */\n-#define USER_PTR_FROM_ALLOCATION_OBJECT_PTR(X)\t\t\t\t\\\n-   ((void *) (((allocation_object *) (X))->u.data))\n-\n /* Hashtable mapping alloc_pool names to descriptors.  */\n hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n \n@@ -74,247 +41,6 @@ allocate_pool_descriptor (const char *name)\n   return &alloc_pool_hash->get_or_insert (name);\n }\n \n-\n-/* Create a pool of things of size SIZE, with NUM in each block we\n-   allocate.  */\n-\n-alloc_pool\n-create_alloc_pool (const char *name, size_t size, size_t num)\n-{\n-  alloc_pool pool;\n-  size_t header_size;\n-\n-  gcc_checking_assert (name);\n-\n-  /* Make size large enough to store the list header.  */\n-  if (size < sizeof (alloc_pool_list))\n-    size = sizeof (alloc_pool_list);\n-\n-  /* Now align the size to a multiple of 4.  */\n-  size = align_eight (size);\n-\n-#ifdef ENABLE_CHECKING\n-  /* Add the aligned size of ID.  */\n-  size += offsetof (allocation_object, u.data);\n-#endif\n-\n-  /* Um, we can't really allocate 0 elements per block.  */\n-  gcc_checking_assert (num);\n-\n-  /* Allocate memory for the pool structure.  */\n-  pool = XNEW (struct alloc_pool_def);\n-\n-  /* Now init the various pieces of our pool structure.  */\n-  pool->name = /*xstrdup (name)*/name;\n-  pool->elt_size = size;\n-  pool->elts_per_block = num;\n-\n-  if (GATHER_STATISTICS)\n-    {\n-      struct alloc_pool_descriptor *desc = allocate_pool_descriptor (name);\n-      desc->elt_size = size;\n-      desc->created++;\n-    }\n-\n-  /* List header size should be a multiple of 8.  */\n-  header_size = align_eight (sizeof (struct alloc_pool_list_def));\n-\n-  pool->block_size = (size * num) + header_size;\n-  pool->returned_free_list = NULL;\n-  pool->virgin_free_list = NULL;\n-  pool->virgin_elts_remaining = 0;\n-  pool->elts_allocated = 0;\n-  pool->elts_free = 0;\n-  pool->blocks_allocated = 0;\n-  pool->block_list = NULL;\n-\n-#ifdef ENABLE_CHECKING\n-  /* Increase the last used ID and use it for this pool.\n-     ID == 0 is used for free elements of pool so skip it.  */\n-  last_id++;\n-  if (last_id == 0)\n-    last_id++;\n-\n-  pool->id = last_id;\n-#endif\n-\n-  return (pool);\n-}\n-\n-/* Free all memory allocated for the given memory pool.  */\n-void\n-empty_alloc_pool (alloc_pool pool)\n-{\n-  alloc_pool_list block, next_block;\n-\n-  gcc_checking_assert (pool);\n-\n-  /* Free each block allocated to the pool.  */\n-  for (block = pool->block_list; block != NULL; block = next_block)\n-    {\n-      next_block = block->next;\n-      free (block);\n-    }\n-\n-  if (GATHER_STATISTICS)\n-    {\n-      struct alloc_pool_descriptor *desc = allocate_pool_descriptor (pool->name);\n-      desc->current -= (pool->elts_allocated - pool->elts_free) * pool->elt_size;\n-    }\n-\n-  pool->returned_free_list = NULL;\n-  pool->virgin_free_list = NULL;\n-  pool->virgin_elts_remaining = 0;\n-  pool->elts_allocated = 0;\n-  pool->elts_free = 0;\n-  pool->blocks_allocated = 0;\n-  pool->block_list = NULL;\n-}\n-\n-/* Free all memory allocated for the given memory pool and the pool itself.  */\n-void\n-free_alloc_pool (alloc_pool pool)\n-{\n-  /* First empty the pool.  */\n-  empty_alloc_pool (pool);\n-#ifdef ENABLE_CHECKING\n-  memset (pool, 0xaf, sizeof (*pool));\n-#endif\n-  /* Lastly, free the pool.  */\n-  free (pool);\n-}\n-\n-/* Frees the alloc_pool, if it is empty and zero *POOL in this case.  */\n-void\n-free_alloc_pool_if_empty (alloc_pool *pool)\n-{\n-  if ((*pool)->elts_free == (*pool)->elts_allocated)\n-    {\n-      free_alloc_pool (*pool);\n-      *pool = NULL;\n-    }\n-}\n-\n-/* Allocates one element from the pool specified.  */\n-void *\n-pool_alloc (alloc_pool pool)\n-{\n-  alloc_pool_list header;\n-#ifdef ENABLE_VALGRIND_ANNOTATIONS\n-  int size;\n-#endif\n-\n-  if (GATHER_STATISTICS)\n-    {\n-      struct alloc_pool_descriptor *desc = allocate_pool_descriptor (pool->name);\n-\n-      desc->allocated += pool->elt_size;\n-      desc->current += pool->elt_size;\n-      if (desc->peak < desc->current)\n-\tdesc->peak = desc->current;\n-    }\n-\n-  gcc_checking_assert (pool);\n-#ifdef ENABLE_VALGRIND_ANNOTATIONS\n-  size = pool->elt_size - offsetof (allocation_object, u.data);\n-#endif\n-\n-  /* If there are no more free elements, make some more!.  */\n-  if (!pool->returned_free_list)\n-    {\n-      char *block;\n-      if (!pool->virgin_elts_remaining)\n-\t{\n-\t  alloc_pool_list block_header;\n-\n-\t  /* Make the block.  */\n-\t  block = XNEWVEC (char, pool->block_size);\n-\t  block_header = (alloc_pool_list) block;\n-\t  block += align_eight (sizeof (struct alloc_pool_list_def));\n-\n-\t  /* Throw it on the block list.  */\n-\t  block_header->next = pool->block_list;\n-\t  pool->block_list = block_header;\n-\n-\t  /* Make the block available for allocation.  */\n-\t  pool->virgin_free_list = block;\n-\t  pool->virgin_elts_remaining = pool->elts_per_block;\n-\n-\t  /* Also update the number of elements we have free/allocated, and\n-\t     increment the allocated block count.  */\n-\t  pool->elts_allocated += pool->elts_per_block;\n-\t  pool->elts_free += pool->elts_per_block;\n-\t  pool->blocks_allocated += 1;\n-\t}\n-\n-\n-      /* We now know that we can take the first elt off the virgin list and\n-\t put it on the returned list. */\n-      block = pool->virgin_free_list;\n-      header = (alloc_pool_list) USER_PTR_FROM_ALLOCATION_OBJECT_PTR (block);\n-      header->next = NULL;\n-#ifdef ENABLE_CHECKING\n-      /* Mark the element to be free.  */\n-      ((allocation_object *) block)->id = 0;\n-#endif\n-      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (header,size));\n-      pool->returned_free_list = header;\n-      pool->virgin_free_list += pool->elt_size;\n-      pool->virgin_elts_remaining--;\n-\n-    }\n-\n-  /* Pull the first free element from the free list, and return it.  */\n-  header = pool->returned_free_list;\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (header, sizeof (*header)));\n-  pool->returned_free_list = header->next;\n-  pool->elts_free--;\n-\n-#ifdef ENABLE_CHECKING\n-  /* Set the ID for element.  */\n-  ALLOCATION_OBJECT_PTR_FROM_USER_PTR (header)->id = pool->id;\n-#endif\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (header, size));\n-\n-  return ((void *) header);\n-}\n-\n-/* Puts PTR back on POOL's free list.  */\n-void\n-pool_free (alloc_pool pool, void *ptr)\n-{\n-  alloc_pool_list header;\n-#if defined(ENABLE_VALGRIND_ANNOTATIONS) || defined(ENABLE_CHECKING)\n-  int size;\n-  size = pool->elt_size - offsetof (allocation_object, u.data);\n-#endif\n-\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (ptr\n-\t      /* Check if we free more than we allocated, which is Bad (TM).  */\n-\t      && pool->elts_free < pool->elts_allocated\n-\t      /* Check whether the PTR was allocated from POOL.  */\n-\t      && pool->id == ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id);\n-\n-  memset (ptr, 0xaf, size);\n-\n-  /* Mark the element to be free.  */\n-  ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id = 0;\n-#endif\n-\n-  header = (alloc_pool_list) ptr;\n-  header->next = pool->returned_free_list;\n-  pool->returned_free_list = header;\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (ptr, size));\n-  pool->elts_free++;\n-\n-  if (GATHER_STATISTICS)\n-    {\n-      struct alloc_pool_descriptor *desc = allocate_pool_descriptor (pool->name);\n-      desc->current -= pool->elt_size;\n-    }\n-}\n-\n /* Output per-alloc_pool statistics.  */\n \n /* Used to accumulate statistics about alloc_pool sizes.  */"}, {"sha": "65087265527dd86ec1280ccefe1c0e9249ab972b", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc5c392fe281f1251e0836409c05f940c3393e4/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc5c392fe281f1251e0836409c05f940c3393e4/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=fdc5c392fe281f1251e0836409c05f940c3393e4", "patch": "@@ -22,46 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"hash-map.h\"\n \n-typedef unsigned long ALLOC_POOL_ID_TYPE;\n-\n-typedef struct alloc_pool_list_def\n-{\n-  struct alloc_pool_list_def *next;\n-}\n- *alloc_pool_list;\n-\n-typedef struct alloc_pool_def\n-{\n-  const char *name;\n-  ALLOC_POOL_ID_TYPE id;\n-  size_t elts_per_block;\n-\n-  /* These are the elements that have been allocated at least once and freed.  */\n-  alloc_pool_list returned_free_list;\n-\n-  /* These are the elements that have not yet been allocated out of\n-     the last block obtained from XNEWVEC.  */\n-  char* virgin_free_list;\n-\n-  /* The number of elements in the virgin_free_list that can be\n-     allocated before needing another block.  */\n-  size_t virgin_elts_remaining;\n-\n-  size_t elts_allocated;\n-  size_t elts_free;\n-  size_t blocks_allocated;\n-  alloc_pool_list block_list;\n-  size_t block_size;\n-  size_t elt_size;\n-}\n- *alloc_pool;\n-\n-extern alloc_pool create_alloc_pool (const char *, size_t, size_t);\n-extern void free_alloc_pool (alloc_pool);\n-extern void empty_alloc_pool (alloc_pool);\n-extern void free_alloc_pool_if_empty (alloc_pool *);\n-extern void *pool_alloc (alloc_pool) ATTRIBUTE_MALLOC;\n-extern void pool_free (alloc_pool, void *);\n extern void dump_alloc_pool_statistics (void);\n \n typedef unsigned long ALLOC_POOL_ID_TYPE;\n@@ -76,21 +36,10 @@ class pool_allocator\n      potentially IGNORE_TYPE_SIZE.  */\n   pool_allocator (const char *name, size_t num, size_t extra_size = 0,\n \t\t  bool ignore_type_size = false);\n-\n-  /* Default destuctor.  */\n   ~pool_allocator ();\n-\n-  /* Release internal data structures.  */\n   void release ();\n-\n-  /* Release internal data structures if the pool has not allocated\n-     an object.  */\n   void release_if_empty ();\n-\n-  /* Allocate a new object.  */\n   T *allocate () ATTRIBUTE_MALLOC;\n-\n-  /* Release OBJECT that must come from the pool.  */\n   void remove (T *object);\n \n private:"}]}