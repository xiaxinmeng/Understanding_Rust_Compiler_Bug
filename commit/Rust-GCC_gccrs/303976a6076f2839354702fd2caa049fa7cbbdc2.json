{"sha": "303976a6076f2839354702fd2caa049fa7cbbdc2", "node_id": "C_kwDOANBUbNoAKDMwMzk3NmE2MDc2ZjI4MzkzNTQ3MDJmZDJjYWEwNDlmYTdjYmJkYzI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-27T06:36:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-27T06:36:28Z"}, "message": "c++: Implement C++23 P1169R4 - static operator() [PR106651]\n\nThe following patch attempts to implement C++23 P1169R4 - static operator()\npaper's compiler side (there is some small library side too not implemented\nyet).  This allows static members as user operator() declarations and\nstatic specifier on lambdas without lambda capture.\nThe synthetized conversion operator changes for static lambdas as it can just\nreturn the operator() static method address, doesn't need to create a thunk\nfor it.\nThe change in call.cc (joust) is to avoid ICEs because we assumed that len\ncould be different only if both candidates are direct calls but it can be\none direct and one indirect call, and to implement the\n[over.match.best.general]/1 and [over.best.ics.general] changes from\nthe paper (implemented always as Jason is sure it doesn't make a difference\nin C++20 and earlier unless static member function operator() or\nstatic lambda which we accept with pedwarn in earlier standards too appears\nand my testing confirmed that).\n\n2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/106651\ngcc/c-family/\n\t* c-cppbuiltin.cc (c_cpp_builtins): Predefine\n\t__cpp_static_call_operator=202207L for C++23.\ngcc/cp/\n\t* cp-tree.h (LAMBDA_EXPR_STATIC_P): Implement C++23\n\tP1169R4 - static operator().  Define.\n\t* parser.cc (CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR): Document\n\tthat it also allows static.\n\t(cp_parser_lambda_declarator_opt): Handle static lambda specifier.\n\t(cp_parser_decl_specifier_seq): Allow RID_STATIC for\n\tCP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR.\n\t* decl.cc (grok_op_properties): If operator() isn't a method,\n\tuse a different error wording, if it is static member function,\n\tallow it (for C++20 and older with a pedwarn unless it is\n\ta lambda function or template instantiation).\n\t* call.cc (joust): Don't ICE if one candidate is static member\n\tfunction and the other is an indirect call.  If the parameter\n\tconversion on the other candidate is user defined conversion,\n\tellipsis or bad conversion, make static member function candidate\n\ta winner for that parameter.\n\t* lambda.cc (maybe_add_lambda_conv_op): Handle static lambdas.\n\t* error.cc (dump_lambda_function): Print static for static lambdas.\ngcc/testsuite/\n\t* g++.dg/template/error30.C: Adjust expected diagnostics.\n\t* g++.dg/cpp1z/constexpr-lambda13.C: Likewise.\n\t* g++.dg/cpp23/feat-cxx2b.C: Test __cpp_static_call_operator.\n\t* g++.dg/cpp23/static-operator-call1.C: New test.\n\t* g++.dg/cpp23/static-operator-call2.C: New test.\n\t* g++.old-deja/g++.jason/operator.C: Adjust expected diagnostics.", "tree": {"sha": "db5c11f6e2e2761b76a004ed2ae9aef02151df94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db5c11f6e2e2761b76a004ed2ae9aef02151df94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/303976a6076f2839354702fd2caa049fa7cbbdc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/303976a6076f2839354702fd2caa049fa7cbbdc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/303976a6076f2839354702fd2caa049fa7cbbdc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/303976a6076f2839354702fd2caa049fa7cbbdc2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb8f25c5dc9f6d5207c826c2dafe25f68458ceaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb8f25c5dc9f6d5207c826c2dafe25f68458ceaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb8f25c5dc9f6d5207c826c2dafe25f68458ceaf"}], "stats": {"total": 268, "additions": 235, "deletions": 33}, "files": [{"sha": "ca5f500e079b5c45721504b6b587a98bdbf4fa51", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -1081,6 +1081,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_constexpr=202110L\");\n \t  cpp_define (pfile, \"__cpp_multidimensional_subscript=202110L\");\n \t  cpp_define (pfile, \"__cpp_named_character_escapes=202207L\");\n+\t  cpp_define (pfile, \"__cpp_static_call_operator=202207L\");\n \t}\n       if (flag_concepts)\n         {"}, {"sha": "fc86b74a5a43e610a0bb16dde0b6dbbc6795bbe4", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -12261,10 +12261,14 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n   len = cand1->num_convs;\n   if (len != cand2->num_convs)\n     {\n-      int static_1 = DECL_STATIC_FUNCTION_P (cand1->fn);\n-      int static_2 = DECL_STATIC_FUNCTION_P (cand2->fn);\n-\n-      if (DECL_CONSTRUCTOR_P (cand1->fn)\n+      int static_1 = (TREE_CODE (cand1->fn) == FUNCTION_DECL\n+\t\t      && DECL_STATIC_FUNCTION_P (cand1->fn));\n+      int static_2 = (TREE_CODE (cand2->fn) == FUNCTION_DECL\n+\t\t      && DECL_STATIC_FUNCTION_P (cand2->fn));\n+\n+      if (TREE_CODE (cand1->fn) == FUNCTION_DECL\n+\t  && TREE_CODE (cand2->fn) == FUNCTION_DECL\n+\t  && DECL_CONSTRUCTOR_P (cand1->fn)\n \t  && is_list_ctor (cand1->fn) != is_list_ctor (cand2->fn))\n \t/* We're comparing a near-match list constructor and a near-match\n \t   non-list constructor.  Just treat them as unordered.  */\n@@ -12273,9 +12277,20 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n       gcc_assert (static_1 != static_2);\n \n       if (static_1)\n-\toff2 = 1;\n+\t{\n+\t  /* C++23 [over.best.ics.general] says:\n+\t     When the parameter is the implicit object parameter of a static\n+\t     member function, the implicit conversion sequence is a standard\n+\t     conversion sequence that is neither better nor worse than any\n+\t     other standard conversion sequence.  */\n+\t  if (CONVERSION_RANK (cand2->convs[0]) >= cr_user)\n+\t    winner = 1;\n+\t  off2 = 1;\n+\t}\n       else\n \t{\n+\t  if (CONVERSION_RANK (cand1->convs[0]) >= cr_user)\n+\t    winner = -1;\n \t  off1 = 1;\n \t  --len;\n \t}"}, {"sha": "99b486b80027ed7c80fc8e61b48d9ec060abdf57", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -504,6 +504,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       OVL_NESTED_P (in OVERLOAD)\n       DECL_MODULE_EXPORT_P (in _DECL)\n       PACK_EXPANSION_FORCE_EXTRA_ARGS_P (in *_PACK_EXPANSION)\n+      LAMBDA_EXPR_STATIC_P (in LAMBDA_EXPR)\n    4: IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n \t  CALL_EXPR, or FIELD_DECL).\n@@ -1490,6 +1491,10 @@ enum cp_lambda_default_capture_mode_type {\n #define LAMBDA_EXPR_CAPTURE_OPTIMIZED(NODE) \\\n   TREE_LANG_FLAG_2 (LAMBDA_EXPR_CHECK (NODE))\n \n+/* Predicate tracking whether the lambda was declared 'static'.  */\n+#define LAMBDA_EXPR_STATIC_P(NODE) \\\n+  TREE_LANG_FLAG_3 (LAMBDA_EXPR_CHECK (NODE))\n+\n /* True if this TREE_LIST in LAMBDA_EXPR_CAPTURE_LIST is for an explicit\n    capture.  */\n #define LAMBDA_CAPTURE_EXPLICIT_P(NODE) \\"}, {"sha": "fb85564a19139abfde3cc75fe1cb8167e5165be8", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -15300,8 +15300,25 @@ grok_op_properties (tree decl, bool complain)\n      an enumeration, or a reference to an enumeration.  13.4.0.6 */\n   if (! methodp || DECL_STATIC_FUNCTION_P (decl))\n     {\n+      if (operator_code == CALL_EXPR)\n+\t{\n+\t  if (! DECL_STATIC_FUNCTION_P (decl))\n+\t    {\n+\t      error_at (loc, \"%qD must be a member function\", decl);\n+\t      return false;\n+\t    }\n+\t  if (cxx_dialect < cxx23\n+\t      /* For lambdas we diagnose static lambda specifier elsewhere.  */\n+\t      && ! LAMBDA_FUNCTION_P (decl)\n+\t      /* For instantiations, we have diagnosed this already.  */\n+\t      && ! DECL_USE_TEMPLATE (decl))\n+\t    pedwarn (loc, OPT_Wc__23_extensions, \"%qD may be a static member \"\n+\t      \"function only with %<-std=c++23%> or %<-std=gnu++23%>\", decl);\n+\t  /* There are no further restrictions on the arguments to an\n+\t     overloaded \"operator ()\".  */\n+\t  return true;\n+\t}\n       if (operator_code == TYPE_EXPR\n-\t  || operator_code == CALL_EXPR\n \t  || operator_code == COMPONENT_REF\n \t  || operator_code == ARRAY_REF\n \t  || operator_code == NOP_EXPR)"}, {"sha": "0389f35d731469b74f07949006af1693c65802c5", "filename": "gcc/cp/error.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Ferror.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Ferror.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.cc?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -1692,7 +1692,13 @@ dump_lambda_function (cxx_pretty_printer *pp,\n {\n   /* A lambda's signature is essentially its \"type\".  */\n   dump_type (pp, DECL_CONTEXT (fn), flags);\n-  if (!(TYPE_QUALS (class_of_this_parm (TREE_TYPE (fn))) & TYPE_QUAL_CONST))\n+  if (TREE_CODE (TREE_TYPE (fn)) == FUNCTION_TYPE)\n+    {\n+      pp->padding = pp_before;\n+      pp_c_ws_string (pp, \"static\");\n+    }\n+  else if (!(TYPE_QUALS (class_of_this_parm (TREE_TYPE (fn)))\n+\t     & TYPE_QUAL_CONST))\n     {\n       pp->padding = pp_before;\n       pp_c_ws_string (pp, \"mutable\");"}, {"sha": "e9d5d4dc1c52a816219891363cfd48b9889af0f3", "filename": "gcc/cp/lambda.cc", "status": "modified", "additions": 71, "deletions": 18, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Flambda.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Flambda.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.cc?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -1099,7 +1099,9 @@ maybe_add_lambda_conv_op (tree type)\n   tree optype = TREE_TYPE (callop);\n   tree fn_result = TREE_TYPE (optype);\n \n-  tree thisarg = build_int_cst (TREE_TYPE (DECL_ARGUMENTS (callop)), 0);\n+  tree thisarg = NULL_TREE;\n+  if (TREE_CODE (optype) == METHOD_TYPE)\n+    thisarg = build_int_cst (TREE_TYPE (DECL_ARGUMENTS (callop)), 0);\n   if (generic_lambda_p)\n     {\n       ++processing_template_decl;\n@@ -1109,18 +1111,25 @@ maybe_add_lambda_conv_op (tree type)\n \t return expression for a deduced return call op to allow for simple\n \t implementation of the conversion operator.  */\n \n-      tree instance = cp_build_fold_indirect_ref (thisarg);\n-      tree objfn = lookup_template_function (DECL_NAME (callop),\n-\t\t\t\t\t     DECL_TI_ARGS (callop));\n-      objfn = build_min (COMPONENT_REF, NULL_TREE,\n-\t\t\t instance, objfn, NULL_TREE);\n-      int nargs = list_length (DECL_ARGUMENTS (callop)) - 1;\n+      tree objfn;\n+      int nargs = list_length (DECL_ARGUMENTS (callop));\n+      if (thisarg)\n+\t{\n+\t  tree instance = cp_build_fold_indirect_ref (thisarg);\n+\t  objfn = lookup_template_function (DECL_NAME (callop),\n+\t\t\t\t\t    DECL_TI_ARGS (callop));\n+\t  objfn = build_min (COMPONENT_REF, NULL_TREE,\n+\t\t\t     instance, objfn, NULL_TREE);\n+\t  --nargs;\n+\t  call = prepare_op_call (objfn, nargs);\n+\t}\n+      else\n+\tobjfn = callop;\n \n-      call = prepare_op_call (objfn, nargs);\n       if (type_uses_auto (fn_result))\n \tdecltype_call = prepare_op_call (objfn, nargs);\n     }\n-  else\n+  else if (thisarg)\n     {\n       direct_argvec = make_tree_vector ();\n       direct_argvec->quick_push (thisarg);\n@@ -1135,9 +1144,11 @@ maybe_add_lambda_conv_op (tree type)\n   tree fn_args = NULL_TREE;\n   {\n     int ix = 0;\n-    tree src = DECL_CHAIN (DECL_ARGUMENTS (callop));\n+    tree src = FUNCTION_FIRST_USER_PARM (callop);\n     tree tgt = NULL;\n \n+    if (!thisarg && !decltype_call)\n+      src = NULL_TREE;\n     while (src)\n       {\n \ttree new_node = copy_node (src);\n@@ -1160,12 +1171,15 @@ maybe_add_lambda_conv_op (tree type)\n \tif (generic_lambda_p)\n \t  {\n \t    tree a = tgt;\n-\t    if (DECL_PACK_P (tgt))\n+\t    if (thisarg)\n \t      {\n-\t\ta = make_pack_expansion (a);\n-\t\tPACK_EXPANSION_LOCAL_P (a) = true;\n+\t\tif (DECL_PACK_P (tgt))\n+\t\t  {\n+\t\t    a = make_pack_expansion (a);\n+\t\t    PACK_EXPANSION_LOCAL_P (a) = true;\n+\t\t  }\n+\t\tCALL_EXPR_ARG (call, ix) = a;\n \t      }\n-\t    CALL_EXPR_ARG (call, ix) = a;\n \n \t    if (decltype_call)\n \t      {\n@@ -1193,7 +1207,7 @@ maybe_add_lambda_conv_op (tree type)\n \t     tf_warning_or_error);\n \t}\n     }\n-  else\n+  else if (thisarg)\n     {\n       /* Don't warn on deprecated or unavailable lambda declarations, unless\n \t the lambda is actually called.  */\n@@ -1203,10 +1217,14 @@ maybe_add_lambda_conv_op (tree type)\n \t\t\t   direct_argvec->address ());\n     }\n \n-  CALL_FROM_THUNK_P (call) = 1;\n-  SET_EXPR_LOCATION (call, UNKNOWN_LOCATION);\n+  if (thisarg)\n+    {\n+      CALL_FROM_THUNK_P (call) = 1;\n+      SET_EXPR_LOCATION (call, UNKNOWN_LOCATION);\n+    }\n \n-  tree stattype = build_function_type (fn_result, FUNCTION_ARG_CHAIN (callop));\n+  tree stattype\n+    = build_function_type (fn_result, FUNCTION_FIRST_USER_PARMTYPE (callop));\n   stattype = (cp_build_type_attribute_variant\n \t      (stattype, TYPE_ATTRIBUTES (optype)));\n   if (flag_noexcept_type\n@@ -1249,6 +1267,41 @@ maybe_add_lambda_conv_op (tree type)\n \n   add_method (type, fn, false);\n \n+  if (thisarg == NULL_TREE)\n+    {\n+      /* For static lambda, just return operator().  */\n+      if (nested)\n+\tpush_function_context ();\n+      else\n+\t/* Still increment function_depth so that we don't GC in the\n+\t   middle of an expression.  */\n+\t++function_depth;\n+\n+      /* Generate the body of the conversion op.  */\n+\n+      start_preparsed_function (convfn, NULL_TREE,\n+\t\t\t\tSF_PRE_PARSED | SF_INCLASS_INLINE);\n+      tree body = begin_function_body ();\n+      tree compound_stmt = begin_compound_stmt (0);\n+\n+      /* decl_needed_p needs to see that it's used.  */\n+      TREE_USED (callop) = 1;\n+      finish_return_stmt (decay_conversion (callop, tf_warning_or_error));\n+\n+      finish_compound_stmt (compound_stmt);\n+      finish_function_body (body);\n+\n+      fn = finish_function (/*inline_p=*/true);\n+      if (!generic_lambda_p)\n+\texpand_or_defer_fn (fn);\n+\n+      if (nested)\n+\tpop_function_context ();\n+      else\n+\t--function_depth;\n+      return;\n+    }\n+\n   /* Generic thunk code fails for varargs; we'll complain in mark_used if\n      the conversion op is used.  */\n   if (varargs_function_p (callop))"}, {"sha": "d501178634a01ed997f111d620fa09f66b8970b0", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -1996,7 +1996,7 @@ enum\n      constexpr.  */\n   CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR = 0x8,\n   /* When parsing a decl-specifier-seq, only allow mutable, constexpr or\n-     for C++20 consteval.  */\n+     for C++20 consteval or for C++23 static.  */\n   CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR = 0x10,\n   /* When parsing a decl-specifier-seq, allow missing typename.  */\n   CP_PARSER_FLAGS_TYPENAME_OPTIONAL = 0x20,\n@@ -11731,6 +11731,18 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       LAMBDA_EXPR_MUTABLE_P (lambda_expr) = 1;\n       quals = TYPE_UNQUALIFIED;\n     }\n+  else if (lambda_specs.storage_class == sc_static)\n+    {\n+      if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) != CPLD_NONE\n+\t  || LAMBDA_EXPR_CAPTURE_LIST (lambda_expr))\n+\terror_at (lambda_specs.locations[ds_storage_class],\n+\t\t  \"%<static%> lambda specifier with lambda capture\");\n+      else\n+\t{\n+\t  LAMBDA_EXPR_STATIC_P (lambda_expr) = 1;\n+\t  quals = TYPE_UNQUALIFIED;\n+\t}\n+    }\n \n   tx_qual = cp_parser_tx_qualifier_opt (parser);\n   if (omitted_parms_loc && tx_qual)\n@@ -11816,6 +11828,12 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     if (lambda_specs.locations[ds_consteval])\n       return_type_specs.locations[ds_consteval]\n \t= lambda_specs.locations[ds_consteval];\n+    if (LAMBDA_EXPR_STATIC_P (lambda_expr))\n+      {\n+\treturn_type_specs.storage_class = sc_static;\n+\treturn_type_specs.locations[ds_storage_class]\n+\t  = lambda_specs.locations[ds_storage_class];\n+      }\n \n     p = obstack_alloc (&declarator_obstack, 0);\n \n@@ -11839,8 +11857,9 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       {\n \tDECL_INITIALIZED_IN_CLASS_P (fco) = 1;\n \tDECL_ARTIFICIAL (fco) = 1;\n-\t/* Give the object parameter a different name.  */\n-\tDECL_NAME (DECL_ARGUMENTS (fco)) = closure_identifier;\n+\tif (!LAMBDA_EXPR_STATIC_P (lambda_expr))\n+\t  /* Give the object parameter a different name.  */\n+\t  DECL_NAME (DECL_ARGUMENTS (fco)) = closure_identifier;\n \tDECL_SET_LAMBDA_FUNCTION (fco, true);\n       }\n     if (template_param_list)\n@@ -16034,8 +16053,15 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  && token->keyword != RID_MUTABLE\n \t  && token->keyword != RID_CONSTEXPR\n \t  && token->keyword != RID_CONSTEVAL)\n-\terror_at (token->location, \"%qD invalid in lambda\",\n-\t\t  ridpointers[token->keyword]);\n+\t{\n+\t  if (token->keyword != RID_STATIC)\n+\t    error_at (token->location, \"%qD invalid in lambda\",\n+\t\t      ridpointers[token->keyword]);\n+\t  else if (cxx_dialect < cxx23)\n+\t    pedwarn (token->location, OPT_Wc__23_extensions,\n+\t\t     \"%qD only valid in lambda with %<-std=c++23%> or \"\n+\t\t     \"%<-std=gnu++23%>\", ridpointers[token->keyword]);\n+\t}\n \n       if (ds != ds_last)\n \tset_and_check_decl_spec_loc (decl_specs, ds, token);"}, {"sha": "0323a0d05fc6afc6cf0f0a4dc3a2f9b2b1b1ea36", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-lambda13.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda13.C?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -2,4 +2,4 @@\n \n auto l1 = []() constexpr constexpr { }; // { dg-error \"duplicate\" }\n auto l2 = []() mutable mutable { }; // { dg-error \"duplicate\" }\n-auto l3 = []() static { };\t    // { dg-error \"static\" }\n+auto l3 = []() static { };\t    // { dg-error \"static' only valid in lambda with\" \"\" { target c++20_down } }"}, {"sha": "2f6b21ead7006ecb6ac848f4bf0abe41d5dd20d5", "filename": "gcc/testsuite/g++.dg/cpp23/feat-cxx2b.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -563,3 +563,9 @@\n #elif __cpp_named_character_escapes != 202207\n #  error \"__cpp_named_character_escapes != 202207\"\n #endif\n+\n+#ifndef __cpp_static_call_operator\n+#  error \"__cpp_static_call_operator\"\n+#elif __cpp_static_call_operator != 202207\n+#  error \"__cpp_static_call_operator != 202207\"\n+#endif"}, {"sha": "42219bfd8628777f313dddd943ec75d0c66bbf6d", "filename": "gcc/testsuite/g++.dg/cpp23/static-operator-call1.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call1.C?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -0,0 +1,41 @@\n+// P1169R4 - static operator()\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" }\n+\n+template <typename T>\n+struct S\n+{\n+  static constexpr bool operator () (T const &x, T const &y) { return x < y; }; // { dg-warning \"may be a static member function only with\" \"\" { target c++20_down } }\n+  using P = bool (*) (T const &, T const &);\n+  operator P () const { return operator (); }\n+};\n+\n+static_assert (S<int> {} (1, 2), \"\");\n+\n+template <typename T>\n+void\n+bar (T &x)\n+{\n+  x (1, 2);\n+}\n+\n+void\n+foo ()\n+{\n+#if __cpp_constexpr >= 201603L\n+  auto a = [](int x, int y) static constexpr { return x + y; };\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target { c++17 && c++20_down } } }\n+  static_assert (a (1, 2) == 3, \"\");\n+  bar (*a);\n+#endif\n+  auto b = []() static { return 1; };\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } }\n+  b ();\n+  auto c = [](int x, int y) static { return x + y; };\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } }\n+  c (1, 2);\n+  bar (*c);\n+#if __cpp_generic_lambdas >= 201707L\n+  auto d = []<typename T, typename U>(T x, U y) static { return x + y; };\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_only } }\n+  d (1, 2L);\n+#endif\n+  S<long> s;\n+  s(1L, 2L);\n+}"}, {"sha": "21f3d4484970027ee63527a586ed0faa74f4008e", "filename": "gcc/testsuite/g++.dg/cpp23/static-operator-call2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call2.C?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -0,0 +1,22 @@\n+// P1169R4 - static operator()\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" }\n+\n+void\n+foo ()\n+{\n+  int u = 0;\n+  auto a = [](int x, int y) mutable mutable { return x + y; };\t\t// { dg-error \"duplicate 'mutable' specifier\" }\n+  auto b = [](int x, int y) static static { return x + y; };\t\t// { dg-error \"duplicate 'static' specifier\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto c = [](int x, int y) static mutable { return x + y; };\t\t// { dg-error \"'mutable' specifier conflicts with 'static'\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto d = [](int x, int y) mutable static { return x + y; };\t\t// { dg-error \"'static' specifier conflicts with 'mutable'\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto e = [=](int x, int y) static { return x + y; };\t\t\t// { dg-error \"lambda specifier with lambda capture\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto f = [&](int x, int y) static { return x + y; };\t\t\t// { dg-error \"lambda specifier with lambda capture\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto g = [u](int x, int y) static { return x + y; };\t\t\t// { dg-error \"lambda specifier with lambda capture\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+}"}, {"sha": "9c84db621563915cabbd1104e0aac8680203e435", "filename": "gcc/testsuite/g++.dg/cpp23/static-operator-call3.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call3.C?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -0,0 +1,10 @@\n+// P1169R4 - static operator()\n+// { dg-do compile { target c++14 } }\n+// { dg-options \"\" }\n+\n+void\n+foo ()\n+{\n+  auto a = [] (auto x) static { return x; };\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } }\n+  int (*b) (int) = a;\n+}"}, {"sha": "5a3047c11c4f211d63136d3299c9f2b204b58365", "filename": "gcc/testsuite/g++.dg/template/error30.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror30.C?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -2,4 +2,4 @@\n \n template<int> struct A;\n \n-template<template<typename> class B> A<B<int>::x> operator() (); // { dg-error \"51:.A<B<int>::x> operator\\\\(\\\\)\\\\(\\\\). must be a non-static member function\" }\n+template<template<typename> class B> A<B<int>::x> operator() (); // { dg-error \"51:.A<B<int>::x> operator\\\\(\\\\)\\\\(\\\\). must be a member function\" }"}, {"sha": "c18790190b52b3c291e2bc2f32953c8de563fa9b", "filename": "gcc/testsuite/g++.old-deja/g++.jason/operator.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303976a6076f2839354702fd2caa049fa7cbbdc2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C?ref=303976a6076f2839354702fd2caa049fa7cbbdc2", "patch": "@@ -6,7 +6,7 @@ typedef __SIZE_TYPE__ size_t;\n \n struct A {\n   int operator?:(int a, int b);\t   // { dg-error \"prohibits overloading\" } \n-  static int operator()(int a);\t   // { dg-error \"14:.static int A::operator\\\\(\\\\)\\\\(int\\\\). must be a non-static member function\" }\n+  static int operator()(int a);\t   // { dg-warning \"14:.static int A::operator\\\\(\\\\)\\\\(int\\\\). may be a static member function only with\" \"\" { target c++20_down } }\n   static int operator+(A,A);\t   // { dg-error \"14:.static int A::operator\\\\+\\\\(A, A\\\\). must be either a non-static member function or a non-member function\" } \n   int operator+(int a, int b = 1); // { dg-error \"7:.int A::operator\\\\+\\\\(int, int\\\\). must have either zero or one argument\" }\n   int operator++(char);\t\t   // { dg-error \"7:postfix .int A::operator\\\\+\\\\+\\\\(char\\\\). must have .int. as its argument\" }"}]}