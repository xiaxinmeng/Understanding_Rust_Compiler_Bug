{"sha": "4fa25a7eb322f0a003c1eb15680c71ece345e01e", "node_id": "C_kwDOANBUbNoAKDRmYTI1YTdlYjMyMmYwYTAwM2MxZWIxNTY4MGM3MWVjZTM0NWUwMWU", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-01-24T14:45:38Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-11-30T13:03:43Z"}, "message": "Improve profile handling in switch lowering.\n\n\tPR tree-optimization/101301\n\tPR tree-optimization/103680\n\ngcc/ChangeLog:\n\n\t* tree-switch-conversion.cc (bit_test_cluster::emit):\n\tHandle correctly remaining probability.\n\t(switch_decision_tree::try_switch_expansion): Fix BB's count\n\twhere a cluster expansion happens.\n\t(switch_decision_tree::emit_cmp_and_jump_insns): Fill up also\n\tBB count.\n\t(switch_decision_tree::do_jump_if_equal): Likewise.\n\t(switch_decision_tree::emit_case_nodes): Handle special case\n\tfor BT expansion which can also fallback to a default BB.\n\t* tree-switch-conversion.h (cluster::cluster): Add\n\tm_default_prob probability.", "tree": {"sha": "52b4d065f5870abbf4215efc517ef2aacb84cbb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52b4d065f5870abbf4215efc517ef2aacb84cbb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fa25a7eb322f0a003c1eb15680c71ece345e01e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fa25a7eb322f0a003c1eb15680c71ece345e01e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fa25a7eb322f0a003c1eb15680c71ece345e01e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fa25a7eb322f0a003c1eb15680c71ece345e01e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b628cad9e093f7a33042fb9dd647f183394eefae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b628cad9e093f7a33042fb9dd647f183394eefae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b628cad9e093f7a33042fb9dd647f183394eefae"}], "stats": {"total": 65, "additions": 46, "deletions": 19}, "files": [{"sha": "83ba1c1ca031f884a7e2602c7342ba9ba6ac6b35", "filename": "gcc/tree-switch-conversion.cc", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fa25a7eb322f0a003c1eb15680c71ece345e01e/gcc%2Ftree-switch-conversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fa25a7eb322f0a003c1eb15680c71ece345e01e/gcc%2Ftree-switch-conversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.cc?ref=4fa25a7eb322f0a003c1eb15680c71ece345e01e", "patch": "@@ -1538,10 +1538,12 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n \t  test[k].target_bb = n->m_case_bb;\n \t  test[k].label = n->m_case_label_expr;\n \t  test[k].bits = 0;\n+\t  test[k].prob = profile_probability::never ();\n \t  count++;\n \t}\n \n       test[k].bits += n->get_range (n->get_low (), n->get_high ());\n+      test[k].prob += n->m_prob;\n \n       lo = tree_to_uhwi (int_const_binop (MINUS_EXPR, n->get_low (), minval));\n       if (n->get_high () == NULL_TREE)\n@@ -1629,6 +1631,11 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n \t\t\t\t  /*simple=*/true, NULL_TREE,\n \t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n \n+  profile_probability subtree_prob = m_subtree_prob;\n+  profile_probability default_prob = m_default_prob;\n+  if (!default_prob.initialized_p ())\n+    default_prob = m_subtree_prob.invert ();\n+\n   if (m_handles_entire_switch && entry_test_needed)\n     {\n       tree range = int_const_binop (MINUS_EXPR, maxval, minval);\n@@ -1638,10 +1645,11 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n \t\t\t\t    fold_convert (unsigned_index_type, range),\n \t\t\t\t    /*simple=*/true, NULL_TREE,\n \t\t\t\t    /*before=*/true, GSI_SAME_STMT);\n-      tmp = fold_build2_loc (loc, GT_EXPR, boolean_type_node, idx, range);\n+      tmp = fold_build2 (GT_EXPR, boolean_type_node, idx, range);\n+      default_prob = default_prob / 2;\n       basic_block new_bb\n \t= hoist_edge_and_branch_if_true (&gsi, tmp, default_bb,\n-\t\t\t\t\t profile_probability::unlikely (), loc);\n+\t\t\t\t\t default_prob, loc);\n       gsi = gsi_last_bb (new_bb);\n     }\n \n@@ -1662,14 +1670,12 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n   else\n     csui = tmp;\n \n-  profile_probability prob = profile_probability::always ();\n-\n   /* for each unique set of cases:\n        if (const & csui) goto target  */\n   for (k = 0; k < count; k++)\n     {\n-      prob = profile_probability::always ().apply_scale (test[k].bits,\n-\t\t\t\t\t\t\t bt_range);\n+      profile_probability prob = test[k].prob / (subtree_prob + default_prob);\n+      subtree_prob -= test[k].prob;\n       bt_range -= test[k].bits;\n       tmp = wide_int_to_tree (word_type_node, test[k].mask);\n       tmp = fold_build2_loc (loc, BIT_AND_EXPR, word_type_node, csui, tmp);\n@@ -1912,9 +1918,13 @@ switch_decision_tree::try_switch_expansion (vec<cluster *> &clusters)\n       /* Emit cluster-specific switch handling.  */\n       for (unsigned i = 0; i < clusters.length (); i++)\n \tif (clusters[i]->get_type () != SIMPLE_CASE)\n-\t  clusters[i]->emit (index_expr, index_type,\n-\t\t\t     gimple_switch_default_label (m_switch),\n-\t\t\t     m_default_bb, gimple_location (m_switch));\n+\t  {\n+\t    edge e = single_pred_edge (clusters[i]->m_case_bb);\n+\t    e->dest->count = e->src->count.apply_probability (e->probability);\n+\t    clusters[i]->emit (index_expr, index_type,\n+\t\t\t       gimple_switch_default_label (m_switch),\n+\t\t\t       m_default_bb, gimple_location (m_switch));\n+\t  }\n     }\n \n   fix_phi_operands_for_edges ();\n@@ -2162,6 +2172,7 @@ switch_decision_tree::emit_cmp_and_jump_insns (basic_block bb, tree op0,\n   edge false_edge = split_block (bb, cond);\n   false_edge->flags = EDGE_FALSE_VALUE;\n   false_edge->probability = prob.invert ();\n+  false_edge->dest->count = bb->count.apply_probability (prob.invert ());\n \n   edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n   true_edge->probability = prob;\n@@ -2192,6 +2203,7 @@ switch_decision_tree::do_jump_if_equal (basic_block bb, tree op0, tree op1,\n   edge false_edge = split_block (bb, cond);\n   false_edge->flags = EDGE_FALSE_VALUE;\n   false_edge->probability = prob.invert ();\n+  false_edge->dest->count = bb->count.apply_probability (prob.invert ());\n \n   edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n   true_edge->probability = prob;\n@@ -2227,7 +2239,7 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t\t\t     node->m_c->m_case_bb, p, loc);\n       /* Since this case is taken at this point, reduce its weight from\n \t subtree_weight.  */\n-      node->m_c->m_subtree_prob -= p;\n+      node->m_c->m_subtree_prob -= node->m_c->m_prob;\n \n       if (node->m_left != NULL && node->m_right != NULL)\n \t{\n@@ -2246,6 +2258,7 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = do_jump_if_equal (bb, index, node->m_right->m_c->get_low (),\n \t\t\t\t     node->m_right->m_c->m_case_bb, p, loc);\n+\t      node->m_c->m_subtree_prob -= node->m_right->m_c->m_prob;\n \n \t      p = (node->m_left->m_c->m_prob\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n@@ -2261,6 +2274,7 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \n \t      p = ((node->m_right->m_c->m_subtree_prob + default_prob / 2)\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n+\t      test_bb->count = bb->count.apply_probability (p);\n \t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n \t\t\t\t\t    GT_EXPR, test_bb, p, loc);\n \t      default_prob /= 2;\n@@ -2347,21 +2361,28 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t is the one to branch to.  */\n       if (node->has_child () || node->m_c->get_type () != SIMPLE_CASE)\n \t{\n+\t  bool is_bt = node->m_c->get_type () == BIT_TEST;\n+\t  int parts = is_bt ? 3 : 2;\n+\n \t  /* Branch to a label where we will handle it later.  */\n \t  basic_block test_bb = split_edge (single_succ_edge (bb));\n \t  redirect_edge_succ (single_pred_edge (test_bb),\n \t\t\t      single_succ_edge (bb)->dest);\n \n+\t  profile_probability right_prob = profile_probability::never ();\n+\t  if (node->m_right)\n+\t    right_prob = node->m_right->m_c->m_subtree_prob;\n+\t  p = ((right_prob + default_prob / parts)\n+\t       / (node->m_c->m_subtree_prob + default_prob));\n+\t  test_bb->count = bb->count.apply_probability (p);\n \n-\t   profile_probability right_prob = profile_probability::never ();\n-\t   if (node->m_right)\n-\t     right_prob = node->m_right->m_c->m_subtree_prob;\n-\t   p = ((right_prob + default_prob / 2)\n-\t\t/ (node->m_c->m_subtree_prob + default_prob));\n+\t  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n+\t\t\t\t\tGT_EXPR, test_bb, p, loc);\n \n-\t   bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n-\t\t\t\t\t GT_EXPR, test_bb, p, loc);\n-\t   default_prob /= 2;\n+\t  default_prob /= parts;\n+\t  node->m_c->m_subtree_prob -= right_prob;\n+\t  if (is_bt)\n+\t    node->m_c->m_default_prob = default_prob;\n \n \t   /* Value belongs to this node or to the left-hand subtree.  */\n \t   p = node->m_c->m_prob / (node->m_c->m_subtree_prob + default_prob);"}, {"sha": "431cf1add46d4ff5821ef30d47741a01f89d0a90", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fa25a7eb322f0a003c1eb15680c71ece345e01e/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fa25a7eb322f0a003c1eb15680c71ece345e01e/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=4fa25a7eb322f0a003c1eb15680c71ece345e01e", "patch": "@@ -102,6 +102,10 @@ class cluster\n   /* Probability of reaching subtree rooted at this node.  */\n   profile_probability m_subtree_prob;\n \n+  /* Probability of default case when reaching the node.\n+     It is used by bit-test right now.  */\n+  profile_probability m_default_prob;\n+\n protected:\n   /* Default constructor.  */\n   cluster () {}\n@@ -110,7 +114,8 @@ class cluster\n cluster::cluster (tree case_label_expr, basic_block case_bb,\n \t\t  profile_probability prob, profile_probability subtree_prob):\n   m_case_label_expr (case_label_expr), m_case_bb (case_bb), m_prob (prob),\n-  m_subtree_prob (subtree_prob)\n+  m_subtree_prob (subtree_prob),\n+  m_default_prob (profile_probability::uninitialized ())\n {\n }\n \n@@ -545,6 +550,7 @@ class case_bit_test\n   basic_block target_bb;\n   tree label;\n   int bits;\n+  profile_probability prob;\n \n   /* Comparison function for qsort to order bit tests by decreasing\n      probability of execution.  */"}]}