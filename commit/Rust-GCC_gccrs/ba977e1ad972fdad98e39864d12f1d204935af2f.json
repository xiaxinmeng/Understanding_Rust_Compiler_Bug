{"sha": "ba977e1ad972fdad98e39864d12f1d204935af2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE5NzdlMWFkOTcyZmRhZDk4ZTM5ODY0ZDEyZjFkMjA0OTM1YWYyZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-05-26T18:23:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-05-26T18:23:38Z"}, "message": "re PR tree-optimization/36329 (latent problem with tree inlining)\n\n\tPR tree-optimization/36329\n\t* tree.h (CALL_CANNOT_INLINE_P): Add access check.\n\t* tree-gimple.h (CALL_STMT_CANNOT_INLINE_P): New macro.\n\t* cgraphbuild.c (initialize_inline_failed): Use the latter\n\tmacro in lieu of the former.\n\t* ipa-inline.c (cgraph_mark_inline): Likewise.\n\t(cgraph_decide_inlining_of_small_function): Likewise.\n\t(cgraph_decide_inlining): Likewise.\n\t(cgraph_decide_inlining_incrementally): Likewise.\n\nFrom-SVN: r135954", "tree": {"sha": "160cb158346c46e3b94ea89324a4be86274f11d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/160cb158346c46e3b94ea89324a4be86274f11d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba977e1ad972fdad98e39864d12f1d204935af2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba977e1ad972fdad98e39864d12f1d204935af2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba977e1ad972fdad98e39864d12f1d204935af2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba977e1ad972fdad98e39864d12f1d204935af2f/comments", "author": null, "committer": null, "parents": [{"sha": "4d492420f6e180fbce3e5616cfc10a322f39630c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d492420f6e180fbce3e5616cfc10a322f39630c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d492420f6e180fbce3e5616cfc10a322f39630c"}], "stats": {"total": 31, "additions": 23, "deletions": 8}, "files": [{"sha": "831b1a992785d07ff3d1d65ac9e8437dd99bf0f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba977e1ad972fdad98e39864d12f1d204935af2f", "patch": "@@ -1,3 +1,15 @@\n+2008-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR tree-optimization/36329\n+\t* tree.h (CALL_CANNOT_INLINE_P): Add access check.\n+\t* tree-gimple.h (CALL_STMT_CANNOT_INLINE_P): New macro.\n+\t* cgraphbuild.c (initialize_inline_failed): Use the latter\n+\tmacro in lieu of the former.\n+\t* ipa-inline.c (cgraph_mark_inline): Likewise.\n+\t(cgraph_decide_inlining_of_small_function): Likewise.\n+\t(cgraph_decide_inlining): Likewise.\n+\t(cgraph_decide_inlining_incrementally): Likewise.\n+\n 2008-05-26  Tristan Gingold  <gingold@adacore.com>\n             Anatoly Sokolov  <aesok@post.ru>\n "}, {"sha": "e37ca86f51d41d1d7de878b48aaf47544a2b9eed", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=ba977e1ad972fdad98e39864d12f1d204935af2f", "patch": "@@ -97,7 +97,7 @@ initialize_inline_failed (struct cgraph_node *node)\n \t\t\t   \"considered for inlining\");\n       else if (!node->local.inlinable)\n \te->inline_failed = N_(\"function not inlinable\");\n-      else if (CALL_CANNOT_INLINE_P (e->call_stmt))\n+      else if (CALL_STMT_CANNOT_INLINE_P (e->call_stmt))\n \te->inline_failed = N_(\"mismatched arguments\");\n       else\n \te->inline_failed = N_(\"function not considered for inlining\");"}, {"sha": "6ac851a5bc96755e29af5a465d9fb36ed79d6999", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ba977e1ad972fdad98e39864d12f1d204935af2f", "patch": "@@ -296,7 +296,7 @@ cgraph_mark_inline (struct cgraph_edge *edge)\n   struct cgraph_node *what = edge->callee;\n   struct cgraph_edge *e, *next;\n \n-  gcc_assert (!CALL_CANNOT_INLINE_P (edge->call_stmt));\n+  gcc_assert (!CALL_STMT_CANNOT_INLINE_P (edge->call_stmt));\n   /* Look for all calls, mark them inline and clone recursively\n      all inlined functions.  */\n   for (e = what->callers; e; e = next)\n@@ -967,7 +967,7 @@ cgraph_decide_inlining_of_small_functions (void)\n       else\n \t{\n \t  struct cgraph_node *callee;\n-\t  if (CALL_CANNOT_INLINE_P (edge->call_stmt)\n+\t  if (CALL_STMT_CANNOT_INLINE_P (edge->call_stmt)\n \t      || !cgraph_check_inline_limits (edge->caller, edge->callee,\n \t\t\t\t\t      &edge->inline_failed, true))\n \t    {\n@@ -1093,7 +1093,7 @@ cgraph_decide_inlining (void)\n       for (e = node->callers; e; e = next)\n \t{\n \t  next = e->next_caller;\n-\t  if (!e->inline_failed || CALL_CANNOT_INLINE_P (e->call_stmt))\n+\t  if (!e->inline_failed || CALL_STMT_CANNOT_INLINE_P (e->call_stmt))\n \t    continue;\n \t  if (cgraph_recursive_inlining_p (e->caller, e->callee,\n \t\t\t\t  \t   &e->inline_failed))\n@@ -1134,7 +1134,7 @@ cgraph_decide_inlining (void)\n \n \t  if (node->callers && !node->callers->next_caller && !node->needed\n \t      && node->local.inlinable && node->callers->inline_failed\n-\t      && !CALL_CANNOT_INLINE_P (node->callers->call_stmt)\n+\t      && !CALL_STMT_CANNOT_INLINE_P (node->callers->call_stmt)\n \t      && !DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n \t    {\n \t      if (dump_file)\n@@ -1297,7 +1297,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n       if (!e->callee->local.disregard_inline_limits\n \t  && (mode != INLINE_ALL || !e->callee->local.inlinable))\n \tcontinue;\n-      if (CALL_CANNOT_INLINE_P (e->call_stmt))\n+      if (CALL_STMT_CANNOT_INLINE_P (e->call_stmt))\n \tcontinue;\n       /* When the edge is already inlined, we just need to recurse into\n \t it in order to fully flatten the leaves.  */\n@@ -1399,7 +1399,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t  }\n \tif (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n \t\t\t\t        false)\n-\t    || CALL_CANNOT_INLINE_P (e->call_stmt))\n+\t    || CALL_STMT_CANNOT_INLINE_P (e->call_stmt))\n \t  {\n \t    if (dump_file)\n \t      {"}, {"sha": "3864d5d9d3eaf16b1be37cab1ab0405e96549068", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=ba977e1ad972fdad98e39864d12f1d204935af2f", "patch": "@@ -96,6 +96,9 @@ extern bool is_gimple_non_addressable (tree t);\n extern bool is_gimple_call_addr (tree);\n /* If T makes a function call, returns the CALL_EXPR operand.  */\n extern tree get_call_expr_in (tree t);\n+/* Returns true iff T contains a CALL_EXPR not suitable for inlining.  */\n+#define CALL_STMT_CANNOT_INLINE_P(T) \\\n+  CALL_CANNOT_INLINE_P (get_call_expr_in (T))\n \n extern void recalculate_side_effects (tree);\n "}, {"sha": "014f9e93680cdbbe2843fe215f8643699713e6c0", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba977e1ad972fdad98e39864d12f1d204935af2f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ba977e1ad972fdad98e39864d12f1d204935af2f", "patch": "@@ -1249,7 +1249,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n   (CASE_LABEL_EXPR_CHECK (NODE)->base.static_flag)\n \n /* Used to mark a CALL_EXPR as not suitable for inlining.  */\n-#define CALL_CANNOT_INLINE_P(NODE) ((NODE)->base.static_flag)\n+#define CALL_CANNOT_INLINE_P(NODE) (CALL_EXPR_CHECK (NODE)->base.static_flag)\n \n /* In an expr node (usually a conversion) this means the node was made\n    implicitly and should not lead to any sort of warning.  In a decl node,"}]}