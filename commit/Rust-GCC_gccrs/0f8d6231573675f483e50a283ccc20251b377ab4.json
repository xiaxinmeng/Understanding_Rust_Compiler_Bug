{"sha": "0f8d6231573675f483e50a283ccc20251b377ab4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY4ZDYyMzE1NzM2NzVmNDgzZTUwYTI4M2NjYzIwMjUxYjM3N2FiNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-10-18T15:32:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-10-18T15:32:00Z"}, "message": "re PR tree-optimization/45967 (gcc-4.5.x optimizes code with side-effects away)\n\n2010-10-18  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/45967\n\t* tree-ssa-structalias.c (type_could_have_pointers): Remove.\n\t(could_have_pointers): Likewise.\n\t(handle_rhs_call, handle_const_call, handle_pure_call,\n\tfind_func_aliases, intra_create_variable_infos): Remove calls to them.\n\t(struct fieldoff): Add must_have_pointers field.\n\t(type_must_have_pointers): New function.\n\t(field_must_have_pointers): Likewise.\n\t(push_fields_onto_fieldstack): Remove must_have_pointers_p argument.\n\tAdjust field merging.\n\t(create_function_info_for): May-have-pointers of varinfo is\n\talmost always true.\n\t(create_variable_info_for_1): Likewise.\n\n\t* gcc.dg/torture/pr45967.c: New testcase.\n\t* gcc.dg/ipa/ipa-pta-10.c: Adjust.\n\t* gcc.dg/ipa/ipa-pta-13.c: Likewise\n\t* gcc.dg/torture/pr39074-2.c: Likewise\n\t* gcc.dg/torture/pta-escape-1.c: Likewise\n\t* gcc.dg/torture/pta-ptrarith-1.c: Likewise\n\t* gcc.dg/tree-ssa/pta-callused.c: Likewise\n\t* gcc.dg/tree-ssa/pta-escape-1.c: Likewise\n\t* gcc.dg/tree-ssa/pta-escape-2.c: Likewise\n\t* gcc.dg/tree-ssa/pta-escape-3.c: Likewise\n\t* gcc.dg/tree-ssa/ssa-pre-21.c: Likewise\n\nFrom-SVN: r165641", "tree": {"sha": "02cbaf0300d83a152360f7d67a78514ee12a19f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02cbaf0300d83a152360f7d67a78514ee12a19f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f8d6231573675f483e50a283ccc20251b377ab4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8d6231573675f483e50a283ccc20251b377ab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f8d6231573675f483e50a283ccc20251b377ab4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8d6231573675f483e50a283ccc20251b377ab4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1915c739f0010675511d273e01e184507f5c99fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1915c739f0010675511d273e01e184507f5c99fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1915c739f0010675511d273e01e184507f5c99fb"}], "stats": {"total": 303, "additions": 160, "deletions": 143}, "files": [{"sha": "55303f252203a5a33959606595e555d316e75399", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -1,3 +1,19 @@\n+2010-10-18  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45967\n+\t* tree-ssa-structalias.c (type_could_have_pointers): Remove.\n+\t(could_have_pointers): Likewise.\n+\t(handle_rhs_call, handle_const_call, handle_pure_call,\n+\tfind_func_aliases, intra_create_variable_infos): Remove calls to them.\n+\t(struct fieldoff): Add must_have_pointers field.\n+\t(type_must_have_pointers): New function.\n+\t(field_must_have_pointers): Likewise.\n+\t(push_fields_onto_fieldstack): Remove must_have_pointers_p argument.\n+\tAdjust field merging.\n+\t(create_function_info_for): May-have-pointers of varinfo is\n+\talmost always true.\n+\t(create_variable_info_for_1): Likewise.\n+\n 2010-10-18  Tejas Belagod  <tejas.belagod@arm.com>\n \n \t* config/arm/neon.md (neon_move_hi_quad_<mode>): Fix the order"}, {"sha": "6a2738f6aa00c680d4c80e7845f347cac294b2ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -1,3 +1,18 @@\n+2010-10-18  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45967\n+\t* gcc.dg/torture/pr45967.c: New testcase.\n+\t* gcc.dg/ipa/ipa-pta-10.c: Adjust.\n+\t* gcc.dg/ipa/ipa-pta-13.c: Likewise\n+\t* gcc.dg/torture/pr39074-2.c: Likewise\n+\t* gcc.dg/torture/pta-escape-1.c: Likewise\n+\t* gcc.dg/torture/pta-ptrarith-1.c: Likewise\n+\t* gcc.dg/tree-ssa/pta-callused.c: Likewise\n+\t* gcc.dg/tree-ssa/pta-escape-1.c: Likewise\n+\t* gcc.dg/tree-ssa/pta-escape-2.c: Likewise\n+\t* gcc.dg/tree-ssa/pta-escape-3.c: Likewise\n+\t* gcc.dg/tree-ssa/ssa-pre-21.c: Likewise\n+\n 2010-10-18  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* gfortran.dg/bessel_7.f90: Set xfail for mingw targets."}, {"sha": "6e4c3c512f6dcc6ba8de3b213441cdb3a1152a37", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-10.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -26,5 +26,5 @@ int main()\n /* Verify we properly handle variadic arguments and do not let escape\n    stuff through it.  */\n \n-/* { dg-final { scan-ipa-dump \"ESCAPED = { }\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"ESCAPED = { ESCAPED NONLOCAL }\" \"pta\" } } */\n /* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "1e04bfc21186b04fbd369b5a1b01de437d56ae7a", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-13.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-13.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -15,6 +15,8 @@ local_address_taken (int *p)\n   *p = 1;\n }\n \n+void *anyfn_global;\n+\n /* Even though not referenced in this TU we should have added constraints\n    for the initializer.  */\n /* { dg-final { scan-ipa-dump \"ex = &local_address_taken\" \"pta\" } } */\n@@ -24,7 +26,7 @@ extern void link_error (void);\n \n int main()\n {\n-  void (*anyfn)(int *) = (void (*)(int *))(__SIZE_TYPE__)x;\n+  void (*anyfn)(int *) = (void (*)(int *))(__SIZE_TYPE__)anyfn_global;\n   /* The following should cause local_address_taken to get &x\n      as argument, but not local.  We shouldn't get &x added to\n      arbitrary special sub-vars of local_address_taken though,\n@@ -34,9 +36,13 @@ int main()\n      We shouldn't get the functions sub-vars in the ESCAPED solution\n      though, another missed-optimization.  This also causes the functions\n      uses to be messed up even further.  */\n-  /* { dg-final { scan-ipa-dump \"local_address_taken.arg0 = { ESCAPED NONLOCAL y x }\" \"pta\" } } */\n-  /* { dg-final { scan-ipa-dump \"local_address_taken.clobber = { ESCAPED NONLOCAL y x }\" \"pta\" } } */\n+  /* ???  As we don't expand the ESCAPED solution we either get x printed here\n+     or not based on the phase of the moon.  */\n+  /* { dg-final { scan-ipa-dump \"local_address_taken.arg0 = { ESCAPED NONLOCAL y x }\" \"pta\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-ipa-dump \"local_address_taken.clobber = { ESCAPED NONLOCAL y x }\" \"pta\" { xfail *-*-* } } } */\n   /* { dg-final { scan-ipa-dump \"local_address_taken.use = { }\" \"pta\" { xfail *-*-* } } } */\n+  /* ??? But make sure x really escaped.  */\n+  /* { dg-final { scan-ipa-dump \"ESCAPED = {\\[^\\n\\}\\]* x \\[^\\n\\}\\]*}\" \"pta\" } } */\n   (*anyfn) (&x);\n   x = 0;\n   local (&y);"}, {"sha": "a90c5643dca55d9332a01110e3a2e8e250ed86b1", "filename": "gcc/testsuite/gcc.dg/torture/pr39074-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-2.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -30,5 +30,5 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"y.._., points-to non-local, points-to escaped, points-to vars: { i }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"y.._., points-to vars: { i }\" \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "0a5b206e5e1ca557ead57a5fb186b6a23578dd7c", "filename": "gcc/testsuite/gcc.dg/torture/pr45967.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45967.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45967.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45967.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+void __attribute__((noinline,noclone))\n+foo (void *p_)\n+{\n+  int *p;\n+  int i;\n+  for (i = 0; i < sizeof(int *); ++i)\n+    ((char *)&p)[i] = ((char *)p_)[i];\n+  *p = 1;\n+}\n+int main()\n+{\n+  int i = 0;\n+  int *p = &i;\n+  foo (&p);\n+  if (i != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "2aafe80b38f903cd744a8f97230fa3d333f38a17", "filename": "gcc/testsuite/gcc.dg/torture/pta-escape-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-escape-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-escape-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-escape-1.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -30,5 +30,5 @@ main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"ESCAPED = { ESCAPED NONLOCAL i }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"ESCAPED = {\\[^\\n\\}\\]* i \\[^\\n\\}\\]*}\" \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "d41868eb453b0a859b8a37c1d2ae7eb36e363c5b", "filename": "gcc/testsuite/gcc.dg/torture/pta-ptrarith-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-1.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -29,5 +29,5 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"ESCAPED = { ESCAPED NONLOCAL f .* i }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"ESCAPED = {\\[^\\n\\}\\]* i f \\[^\\n\\}\\]*}\" \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "9c8ec3034f368dddddbb92d8b6dfc1bec182a6f8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-callused.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -22,6 +22,6 @@ int bar (int b)\n   return *foo (&q);\n }\n \n-/* { dg-final { scan-tree-dump \"CALLUSED = { f.* i q }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"CALLUSED = { ESCAPED NONLOCAL f.* i q }\" \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */\n "}, {"sha": "7cc19be6c49c5ba773ebf8d982d0e817025c2b28", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-escape-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-1.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -33,5 +33,5 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"ESCAPED, points-to non-local, points-to vars: { x }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"ESCAPED, points-to non-local, points-to NULL, points-to vars: { x }\" \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "878352d269ca015eba904b5df7f3c8f0f98f397e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-escape-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-2.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -34,5 +34,5 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"ESCAPED, points-to non-local, points-to vars: { x }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"ESCAPED, points-to non-local, points-to NULL, points-to vars: { x }\" \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "8e779d8461e267f0c07b16c9a50278069dbf5a91", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-escape-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-escape-3.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -38,5 +38,5 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"ESCAPED, points-to non-local, points-to vars: { x }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"ESCAPED, points-to non-local, points-to NULL, points-to vars: { x }\" \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "10efb12b4abecf2ac0168cff087cd6e8454838ad", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-21.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-21.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -11,5 +11,5 @@ NumSift (long *array, unsigned long k)\n \n /* There should be only two loads left.  */\n \n-/* { dg-final { scan-tree-dump-times \"= \\\\\\*D\" 2 \"pre\" } } */\n+/* { dg-final { scan-tree-dump-times \"= \\\\\\*D\\[^\\n;\\]*;\" 2 \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "ed05178c23d47e70b779b3a943109693c1543a38", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 90, "deletions": 131, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8d6231573675f483e50a283ccc20251b377ab4/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0f8d6231573675f483e50a283ccc20251b377ab4", "patch": "@@ -2931,38 +2931,6 @@ process_constraint (constraint_t t)\n     }\n }\n \n-/* Return true if T is a type that could contain pointers.  */\n-\n-static bool\n-type_could_have_pointers (tree type)\n-{\n-  if (POINTER_TYPE_P (type))\n-    return true;\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    return type_could_have_pointers (TREE_TYPE (type));\n-\n-  /* A function or method can consume pointers.\n-     ???  We could be more precise here.  */\n-  if (TREE_CODE (type) == FUNCTION_TYPE\n-      || TREE_CODE (type) == METHOD_TYPE)\n-    return true;\n-\n-  return AGGREGATE_TYPE_P (type);\n-}\n-\n-/* Return true if T is a variable of a type that could contain\n-   pointers.  */\n-\n-static bool\n-could_have_pointers (tree t)\n-{\n-  return (((TREE_CODE (t) == VAR_DECL\n-\t    || TREE_CODE (t) == PARM_DECL\n-\t    || TREE_CODE (t) == RESULT_DECL)\n-\t   && (TREE_PUBLIC (t) || DECL_EXTERNAL (t) || TREE_ADDRESSABLE (t)))\n-\t  || type_could_have_pointers (TREE_TYPE (t)));\n-}\n \n /* Return the position, in bits, of FIELD_DECL from the beginning of its\n    structure.  */\n@@ -3786,10 +3754,8 @@ handle_rhs_call (gimple stmt, VEC(ce_s, heap) **results)\n       tree arg = gimple_call_arg (stmt, i);\n       int flags = gimple_call_arg_flags (stmt, i);\n \n-      /* If the argument is not used or it does not contain pointers\n-\t we can ignore it.  */\n-      if ((flags & EAF_UNUSED)\n-\t  || !could_have_pointers (arg))\n+      /* If the argument is not used we can ignore it.  */\n+      if (flags & EAF_UNUSED)\n \tcontinue;\n \n       /* As we compute ESCAPED context-insensitive we do not gain\n@@ -3952,17 +3918,13 @@ handle_const_call (gimple stmt, VEC(ce_s, heap) **results)\n   for (k = 0; k < gimple_call_num_args (stmt); ++k)\n     {\n       tree arg = gimple_call_arg (stmt, k);\n-\n-      if (could_have_pointers (arg))\n-\t{\n-\t  VEC(ce_s, heap) *argc = NULL;\n-\t  unsigned i;\n-\t  struct constraint_expr *argp;\n-\t  get_constraint_for_rhs (arg, &argc);\n-\t  FOR_EACH_VEC_ELT (ce_s, argc, i, argp)\n-\t    VEC_safe_push (ce_s, heap, *results, argp);\n-\t  VEC_free(ce_s, heap, argc);\n-\t}\n+      VEC(ce_s, heap) *argc = NULL;\n+      unsigned i;\n+      struct constraint_expr *argp;\n+      get_constraint_for_rhs (arg, &argc);\n+      FOR_EACH_VEC_ELT (ce_s, argc, i, argp)\n+\tVEC_safe_push (ce_s, heap, *results, argp);\n+      VEC_free(ce_s, heap, argc);\n     }\n \n   /* May return addresses of globals.  */\n@@ -3986,16 +3948,12 @@ handle_pure_call (gimple stmt, VEC(ce_s, heap) **results)\n   for (i = 0; i < gimple_call_num_args (stmt); ++i)\n     {\n       tree arg = gimple_call_arg (stmt, i);\n-\n-      if (could_have_pointers (arg))\n+      if (!uses)\n \t{\n-\t  if (!uses)\n-\t    {\n-\t      uses = get_call_use_vi (stmt);\n-\t      make_transitive_closure_constraints (uses);\n-\t    }\n-\t  make_constraint_to (uses->id, arg);\n+\t  uses = get_call_use_vi (stmt);\n+\t  make_transitive_closure_constraints (uses);\n \t}\n+      make_constraint_to (uses->id, arg);\n     }\n \n   /* The static chain is used as well.  */\n@@ -4075,34 +4033,27 @@ find_func_aliases (gimple origt)\n   /* Now build constraints expressions.  */\n   if (gimple_code (t) == GIMPLE_PHI)\n     {\n-      gcc_assert (!AGGREGATE_TYPE_P (TREE_TYPE (gimple_phi_result (t))));\n+      size_t i;\n+      unsigned int j;\n \n-      /* Only care about pointers and structures containing\n-\t pointers.  */\n-      if (could_have_pointers (gimple_phi_result (t)))\n+      /* For a phi node, assign all the arguments to\n+\t the result.  */\n+      get_constraint_for (gimple_phi_result (t), &lhsc);\n+      for (i = 0; i < gimple_phi_num_args (t); i++)\n \t{\n-\t  size_t i;\n-\t  unsigned int j;\n-\n-\t  /* For a phi node, assign all the arguments to\n-\t     the result.  */\n-\t  get_constraint_for (gimple_phi_result (t), &lhsc);\n-\t  for (i = 0; i < gimple_phi_num_args (t); i++)\n-\t    {\n-\t      tree strippedrhs = PHI_ARG_DEF (t, i);\n+\t  tree strippedrhs = PHI_ARG_DEF (t, i);\n \n-\t      STRIP_NOPS (strippedrhs);\n-\t      get_constraint_for_rhs (gimple_phi_arg_def (t, i), &rhsc);\n+\t  STRIP_NOPS (strippedrhs);\n+\t  get_constraint_for_rhs (gimple_phi_arg_def (t, i), &rhsc);\n \n-\t      FOR_EACH_VEC_ELT (ce_s, lhsc, j, c)\n+\t  FOR_EACH_VEC_ELT (ce_s, lhsc, j, c)\n+\t    {\n+\t      struct constraint_expr *c2;\n+\t      while (VEC_length (ce_s, rhsc) > 0)\n \t\t{\n-\t\t  struct constraint_expr *c2;\n-\t\t  while (VEC_length (ce_s, rhsc) > 0)\n-\t\t    {\n-\t\t      c2 = VEC_last (ce_s, rhsc);\n-\t\t      process_constraint (new_constraint (*c, *c2));\n-\t\t      VEC_pop (ce_s, rhsc);\n-\t\t    }\n+\t\t  c2 = VEC_last (ce_s, rhsc);\n+\t\t  process_constraint (new_constraint (*c, *c2));\n+\t\t  VEC_pop (ce_s, rhsc);\n \t\t}\n \t    }\n \t}\n@@ -4353,16 +4304,7 @@ find_func_aliases (gimple origt)\n \t  else\n \t    handle_rhs_call (t, &rhsc);\n \t  if (gimple_call_lhs (t))\n-\t    {\n-\t      if (could_have_pointers (gimple_call_lhs (t)))\n-\t\thandle_lhs_call (t, gimple_call_lhs (t), flags, rhsc, fndecl);\n-\t      /* Similar to conversions a result that is not a pointer\n-\t\t is an escape point for any pointer the function might\n-\t\t return.  */\n-\t      else if (flags & (ECF_CONST|ECF_PURE\n-\t\t\t\t|ECF_NOVOPS|ECF_LOOPING_CONST_OR_PURE))\n-\t\tmake_constraints_to (escaped_id, rhsc);\n-\t    }\n+\t    handle_lhs_call (t, gimple_call_lhs (t), flags, rhsc, fndecl);\n \t  VEC_free (ce_s, heap, rhsc);\n \t}\n       else\n@@ -4380,9 +4322,6 @@ find_func_aliases (gimple origt)\n \t      struct constraint_expr *rhsp;\n \t      tree arg = gimple_call_arg (t, j);\n \n-\t      if (!could_have_pointers (arg))\n-\t\tcontinue;\n-\n \t      get_constraint_for_rhs (arg, &rhsc);\n \t      lhs = get_function_part_constraint (fi, fi_parm_base + j);\n \t      while (VEC_length (ce_s, rhsc) != 0)\n@@ -4395,8 +4334,7 @@ find_func_aliases (gimple origt)\n \n \t  /* If we are returning a value, assign it to the result.  */\n \t  lhsop = gimple_call_lhs (t);\n-\t  if (lhsop\n-\t      && type_could_have_pointers (TREE_TYPE (lhsop)))\n+\t  if (lhsop)\n \t    {\n \t      struct constraint_expr rhs;\n \t      struct constraint_expr *lhsp;\n@@ -4449,8 +4387,7 @@ find_func_aliases (gimple origt)\n   /* Otherwise, just a regular assignment statement.  Only care about\n      operations with pointer result, others are dealt with as escape\n      points if they have pointer operands.  */\n-  else if (is_gimple_assign (t)\n-\t   && type_could_have_pointers (TREE_TYPE (gimple_assign_lhs (t))))\n+  else if (is_gimple_assign (t))\n     {\n       /* Otherwise, just a regular assignment statement.  */\n       tree lhsop = gimple_assign_lhs (t);\n@@ -4460,7 +4397,6 @@ find_func_aliases (gimple origt)\n \tdo_structure_copy (lhsop, rhsop);\n       else\n \t{\n-\t  struct constraint_expr temp;\n \t  get_constraint_for (lhsop, &lhsc);\n \n \t  if (gimple_assign_rhs_code (t) == POINTER_PLUS_EXPR)\n@@ -4481,10 +4417,19 @@ find_func_aliases (gimple origt)\n \t    get_constraint_for_rhs (rhsop, &rhsc);\n \t  else\n \t    {\n-\t      temp.type = ADDRESSOF;\n-\t      temp.var = anything_id;\n-\t      temp.offset = 0;\n-\t      VEC_safe_push (ce_s, heap, rhsc, &temp);\n+\t      /* All other operations are merges.  */\n+\t      VEC (ce_s, heap) *tmp = NULL;\n+\t      struct constraint_expr *rhsp;\n+\t      unsigned i, j;\n+\t      get_constraint_for_rhs (gimple_assign_rhs1 (t), &rhsc);\n+\t      for (i = 2; i < gimple_num_ops (t); ++i)\n+\t\t{\n+\t\t  get_constraint_for_rhs (gimple_op (t, i), &tmp);\n+\t\t  FOR_EACH_VEC_ELT (ce_s, tmp, j, rhsp)\n+\t\t    VEC_safe_push (ce_s, heap, rhsc, rhsp);\n+\t\t  VEC_truncate (ce_s, tmp, 0);\n+\t\t}\n+\t      VEC_free (ce_s, heap, tmp);\n \t    }\n \t  process_all_all_constraints (lhsc, rhsc);\n \t}\n@@ -4505,17 +4450,9 @@ find_func_aliases (gimple origt)\n \tmake_constraint_from_restrict (get_vi_for_tree (lhsop),\n \t\t\t\t       \"CAST_RESTRICT\");\n     }\n-  /* For conversions of pointers to non-pointers the pointer escapes.  */\n-  else if (gimple_assign_cast_p (t)\n-\t   && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (t)))\n-\t   && !POINTER_TYPE_P (TREE_TYPE (gimple_assign_lhs (t))))\n-    {\n-      make_escape_constraint (gimple_assign_rhs1 (t));\n-    }\n   /* Handle escapes through return.  */\n   else if (gimple_code (t) == GIMPLE_RETURN\n-\t   && gimple_return_retval (t) != NULL_TREE\n-\t   && could_have_pointers (gimple_return_retval (t)))\n+\t   && gimple_return_retval (t) != NULL_TREE)\n     {\n       fi = NULL;\n       if (!in_ipa_mode\n@@ -4561,7 +4498,7 @@ find_func_aliases (gimple origt)\n \n \t  /* The asm may read global memory, so outputs may point to\n \t     any global memory.  */\n-\t  if (op && could_have_pointers (op))\n+\t  if (op)\n \t    {\n \t      VEC(ce_s, heap) *lhsc = NULL;\n \t      struct constraint_expr rhsc, *lhsp;\n@@ -4591,7 +4528,7 @@ find_func_aliases (gimple origt)\n \t  /* Strictly we'd only need the constraint to ESCAPED if\n \t     the asm clobbers memory, otherwise using something\n \t     along the lines of per-call clobbers/uses would be enough.  */\n-\t  else if (op && could_have_pointers (op))\n+\t  else if (op)\n \t    make_escape_constraint (op);\n \t}\n     }\n@@ -4960,6 +4897,8 @@ struct fieldoff\n \n   unsigned has_unknown_size : 1;\n \n+  unsigned must_have_pointers : 1;\n+\n   unsigned may_have_pointers : 1;\n \n   unsigned only_restrict_pointers : 1;\n@@ -5021,6 +4960,32 @@ var_can_have_subvars (const_tree v)\n   return false;\n }\n \n+/* Return true if T is a type that does contain pointers.  */\n+\n+static bool\n+type_must_have_pointers (tree type)\n+{\n+  if (POINTER_TYPE_P (type))\n+    return true;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return type_must_have_pointers (TREE_TYPE (type));\n+\n+  /* A function or method can have pointers as arguments, so track\n+     those separately.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE\n+      || TREE_CODE (type) == METHOD_TYPE)\n+    return true;\n+\n+  return false;\n+}\n+\n+static bool\n+field_must_have_pointers (tree t)\n+{\n+  return type_must_have_pointers (TREE_TYPE (t));\n+}\n+\n /* Given a TYPE, and a vector of field offsets FIELDSTACK, push all\n    the fields of TYPE onto fieldstack, recording their offsets along\n    the way.\n@@ -5032,7 +4997,7 @@ var_can_have_subvars (const_tree v)\n \n static bool\n push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n-\t\t\t     HOST_WIDE_INT offset, bool must_have_pointers_p)\n+\t\t\t     HOST_WIDE_INT offset)\n {\n   tree field;\n   bool empty_p = true;\n@@ -5057,8 +5022,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t    || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n \t  push = true;\n \telse if (!push_fields_onto_fieldstack\n-\t\t    (TREE_TYPE (field), fieldstack, offset + foff,\n-\t\t     must_have_pointers_p)\n+\t\t    (TREE_TYPE (field), fieldstack, offset + foff)\n \t\t && (DECL_SIZE (field)\n \t\t     && !integer_zerop (DECL_SIZE (field))))\n \t  /* Empty structures may have actual size, like in C++.  So\n@@ -5070,6 +5034,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t  {\n \t    fieldoff_s *pair = NULL;\n \t    bool has_unknown_size = false;\n+\t    bool must_have_pointers_p;\n \n \t    if (!VEC_empty (fieldoff_s, *fieldstack))\n \t      pair = VEC_last (fieldoff_s, *fieldstack);\n@@ -5079,13 +5044,13 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t      has_unknown_size = true;\n \n \t    /* If adjacent fields do not contain pointers merge them.  */\n+\t    must_have_pointers_p = field_must_have_pointers (field);\n \t    if (pair\n-\t\t&& !pair->may_have_pointers\n-\t\t&& !pair->has_unknown_size\n \t\t&& !has_unknown_size\n-\t\t&& pair->offset + (HOST_WIDE_INT)pair->size == offset + foff\n \t\t&& !must_have_pointers_p\n-\t\t&& !could_have_pointers (field))\n+\t\t&& !pair->must_have_pointers\n+\t\t&& !pair->has_unknown_size\n+\t\t&& pair->offset + (HOST_WIDE_INT)pair->size == offset + foff)\n \t      {\n \t\tpair->size += TREE_INT_CST_LOW (DECL_SIZE (field));\n \t      }\n@@ -5098,8 +5063,8 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\t  pair->size = TREE_INT_CST_LOW (DECL_SIZE (field));\n \t\telse\n \t\t  pair->size = -1;\n-\t\tpair->may_have_pointers\n-\t\t  = must_have_pointers_p || could_have_pointers (field);\n+\t\tpair->must_have_pointers = must_have_pointers_p;\n+\t\tpair->may_have_pointers = true;\n \t\tpair->only_restrict_pointers\n \t\t  = (!has_unknown_size\n \t\t     && POINTER_TYPE_P (TREE_TYPE (field))\n@@ -5245,7 +5210,7 @@ create_function_info_for (tree decl, const char *name)\n       resultvi->fullsize = vi->fullsize;\n       resultvi->is_full_var = true;\n       if (DECL_RESULT (decl))\n-\tresultvi->may_have_pointers = could_have_pointers (DECL_RESULT (decl));\n+\tresultvi->may_have_pointers = true;\n       gcc_assert (prev_vi->offset < resultvi->offset);\n       prev_vi->next = resultvi;\n       prev_vi = resultvi;\n@@ -5275,7 +5240,7 @@ create_function_info_for (tree decl, const char *name)\n       argvi->is_full_var = true;\n       argvi->fullsize = vi->fullsize;\n       if (arg)\n-\targvi->may_have_pointers = could_have_pointers (arg);\n+\targvi->may_have_pointers = true;\n       gcc_assert (prev_vi->offset < argvi->offset);\n       prev_vi->next = argvi;\n       prev_vi = argvi;\n@@ -5359,7 +5324,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n       vi->fullsize = ~0;\n       vi->is_unknown_size_var = true;\n       vi->is_full_var = true;\n-      vi->may_have_pointers = could_have_pointers (decl);\n+      vi->may_have_pointers = true;\n       return vi;\n     }\n \n@@ -5376,10 +5341,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n       bool notokay = false;\n       unsigned int i;\n \n-      push_fields_onto_fieldstack (decl_type, &fieldstack, 0,\n-\t\t\t\t   TREE_PUBLIC (decl)\n-\t\t\t\t   || DECL_EXTERNAL (decl)\n-\t\t\t\t   || TREE_ADDRESSABLE (decl));\n+      push_fields_onto_fieldstack (decl_type, &fieldstack, 0);\n \n       for (i = 0; !notokay && VEC_iterate (fieldoff_s, fieldstack, i, fo); i++)\n \tif (fo->has_unknown_size\n@@ -5414,7 +5376,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n     {\n       vi = new_var_info (decl, name);\n       vi->offset = 0;\n-      vi->may_have_pointers = could_have_pointers (decl);\n+      vi->may_have_pointers = true;\n       vi->fullsize = TREE_INT_CST_LOW (declsize);\n       vi->size = vi->fullsize;\n       vi->is_full_var = true;\n@@ -5558,9 +5520,6 @@ intra_create_variable_infos (void)\n     {\n       varinfo_t p;\n \n-      if (!could_have_pointers (t))\n-\tcontinue;\n-\n       /* For restrict qualified pointers to objects passed by\n          reference build a real representative for the pointed-to object.  */\n       if (DECL_BY_REFERENCE (t)"}]}