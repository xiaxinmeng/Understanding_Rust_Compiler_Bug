{"sha": "f6f2b01933268f73bf439ead94a1a72416a36cd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZmMmIwMTkzMzI2OGY3M2JmNDM5ZWFkOTRhMWE3MjQxNmEzNmNkNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-01-12T22:25:37Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-01-12T22:25:37Z"}, "message": "libgccjit: detect various kinds of errors relating to params and locals\n\ngcc/jit/ChangeLog:\n\t* jit-recording.c (class gcc::jit::rvalue_usage_validator): New.\n\t(gcc::jit::rvalue_usage_validator::rvalue_usage_validator): New\n\tctor.\n\t(gcc::jit::rvalue_usage_validator::visit): New function.\n\t(gcc::jit::recording::rvalue::verify_valid_within_stmt): New\n\tfunction.\n\t(gcc::jit::recording::rvalue::set_scope): New function.\n\t(gcc::jit::recording::function::function): Call set_scope on each\n\tparam, issuing errors for any params that already have a function.\n\t(gcc::jit::recording::block::add_eval): Return the new statement;\n\tupdate the comment given that some error-checking now happens after\n\tthis returns.\n\t(gcc::jit::recording::block::add_assignment): Likewise.\n\t(gcc::jit::recording::block::add_assignment_op): Likewise.\n\t(gcc::jit::recording::block::add_comment): Likewise.\n\t(gcc::jit::recording::block::end_with_conditional): Likewise.\n\t(gcc::jit::recording::block::end_with_jump): Likewise.\n\t(gcc::jit::recording::block::end_with_return): Likewise.\n\t(gcc::jit::recording::block::validate): Add a comment.\n\t(gcc::jit::recording::unary_op::visit_children): New function.\n\t(gcc::jit::recording::binary_op::visit_children): New function.\n\t(gcc::jit::recording::comparison::visit_children): New function.\n\t(gcc::jit::recording::cast::visit_children): New function.\n\t(gcc::jit::recording::call::visit_children): New function.\n\t(gcc::jit::recording::call_through_ptr::visit_children): New function.\n\t(gcc::jit::recording::array_access::visit_children): New function.\n\t(gcc::jit::recording::access_field_of_lvalue::visit_children): New\n\tfunction.\n\t(gcc::jit::recording::access_field_rvalue::visit_children): New\n\tfunction.\n\t(gcc::jit::recording::dereference_field_rvalue::visit_children):\n\tNew function.\n\t(gcc::jit::recording::dereference_rvalue::visit_children): New\n\tfunction.\n\t(gcc::jit::recording::get_address_of_lvalue::visit_children): New\n\tfunction.\n\t* jit-recording.h: Within namespace gcc::jit::recording...\n\t(class rvalue_visitor): New.\n\t(rvalue::rvalue): Initialize m_scope.\n\t(rvalue::get_loc): New accessor.\n\t(rvalue::verify_valid_within_stmt): New function.\n\t(rvalue::visit_children): New pure virtual function.\n\t(rvalue::set_scope): New function.\n\t(rvalue::get_scope): New function.\n\t(rvalue::dyn_cast_param): New function.\n\t(rvalue::m_scope): New field.\n\t(param::visit_children): New empty function.\n\t(param::dyn_cast_param): New function.\n\t(function::get_loc): New function.\n\t(block::add_eval): Return the new statement.\n\t(block::add_assignment): Likewise.\n\t(block::add_assignment_op): Likewise.\n\t(block::add_comment): Likewise.\n\t(block::end_with_conditional): Likewise.\n\t(block::end_with_jump): Likewise.\n\t(block::end_with_return): Likewise.\n\t(global::visit_children): New function.\n\t(memento_of_new_rvalue_from_const<HOST_TYPE>::visit_children):\n\tNew function.\n\t(memento_of_new_string_literal::visit_children): New function.\n\t(unary_op::visit_children): New function.\n\t(binary_op::visit_children): New function.\n\t(comparison::visit_children): New function.\n\t(cast::visit_children): New function.\n\t(call::visit_children): New function.\n\t(call_through_ptr::visit_children): New function.\n\t(array_access::visit_children): New function.\n\t(access_field_of_lvalue::visit_children): New function.\n\t(access_field_rvalue::visit_children): New function.\n\t(dereference_field_rvalue::visit_children): New function.\n\t(dereference_rvalue::visit_children): New function.\n\t(get_address_of_lvalue::visit_children): New function.\n\t(local::local): Call set_scope.\n\t(local::visit_children): New function.\n\t(statement::get_block): Make public.\n\t* libgccjit.c (RETURN_VAL_IF_FAIL_PRINTF5): New macro.\n\t(RETURN_NULL_IF_FAIL_PRINTF5): New macro.\n\t(gcc_jit_context_new_function): Verify that each param has\n\tnot yet been used for creating another function.\n\t(gcc_jit_block_add_eval): After creating the stmt, verify\n\tthat the rvalue expression tree is valid to use within it.\n\t(gcc_jit_block_add_assignment): Likewise for the lvalue and\n\trvalue expression trees.\n\t(gcc_jit_block_add_assignment_op): Likewise.\n\t(gcc_jit_block_end_with_conditional): Likewise for the boolval\n\texpression tree.\n\t(gcc_jit_block_end_with_return): Likewise for the rvalue\n\texpression tree.\n\t(gcc_jit_block_end_with_void_return): Remove return of \"void\",\n\tnow that block::end_with_return is now non-void.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/test-error-local-used-from-other-function.c: New test\n\tcase.\n\t* jit.dg/test-error-param-reuse.c: New test case.\n\t* jit.dg/test-error-param-sharing.c: New test case.\n\t* jit.dg/test-error-param-used-from-other-function.c: New test\n\tcase.\n\t* jit.dg/test-error-param-used-without-a-function.c: New test\n\tcase.\n\nFrom-SVN: r219498", "tree": {"sha": "d71d1bb61a2a2fc41e045a009e7486b70d2b7b9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d71d1bb61a2a2fc41e045a009e7486b70d2b7b9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6f2b01933268f73bf439ead94a1a72416a36cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f2b01933268f73bf439ead94a1a72416a36cd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6f2b01933268f73bf439ead94a1a72416a36cd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f2b01933268f73bf439ead94a1a72416a36cd5/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16ba620346c945cddbd0ad49ef5c628e693cad33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ba620346c945cddbd0ad49ef5c628e693cad33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ba620346c945cddbd0ad49ef5c628e693cad33"}], "stats": {"total": 881, "additions": 840, "deletions": 41}, "files": [{"sha": "dbc1dc692d0e4632bd0bc716d4d6e007ac5cfa14", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -1,3 +1,96 @@\n+2015-01-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit-recording.c (class gcc::jit::rvalue_usage_validator): New.\n+\t(gcc::jit::rvalue_usage_validator::rvalue_usage_validator): New\n+\tctor.\n+\t(gcc::jit::rvalue_usage_validator::visit): New function.\n+\t(gcc::jit::recording::rvalue::verify_valid_within_stmt): New\n+\tfunction.\n+\t(gcc::jit::recording::rvalue::set_scope): New function.\n+\t(gcc::jit::recording::function::function): Call set_scope on each\n+\tparam, issuing errors for any params that already have a function.\n+\t(gcc::jit::recording::block::add_eval): Return the new statement;\n+\tupdate the comment given that some error-checking now happens after\n+\tthis returns.\n+\t(gcc::jit::recording::block::add_assignment): Likewise.\n+\t(gcc::jit::recording::block::add_assignment_op): Likewise.\n+\t(gcc::jit::recording::block::add_comment): Likewise.\n+\t(gcc::jit::recording::block::end_with_conditional): Likewise.\n+\t(gcc::jit::recording::block::end_with_jump): Likewise.\n+\t(gcc::jit::recording::block::end_with_return): Likewise.\n+\t(gcc::jit::recording::block::validate): Add a comment.\n+\t(gcc::jit::recording::unary_op::visit_children): New function.\n+\t(gcc::jit::recording::binary_op::visit_children): New function.\n+\t(gcc::jit::recording::comparison::visit_children): New function.\n+\t(gcc::jit::recording::cast::visit_children): New function.\n+\t(gcc::jit::recording::call::visit_children): New function.\n+\t(gcc::jit::recording::call_through_ptr::visit_children): New function.\n+\t(gcc::jit::recording::array_access::visit_children): New function.\n+\t(gcc::jit::recording::access_field_of_lvalue::visit_children): New\n+\tfunction.\n+\t(gcc::jit::recording::access_field_rvalue::visit_children): New\n+\tfunction.\n+\t(gcc::jit::recording::dereference_field_rvalue::visit_children):\n+\tNew function.\n+\t(gcc::jit::recording::dereference_rvalue::visit_children): New\n+\tfunction.\n+\t(gcc::jit::recording::get_address_of_lvalue::visit_children): New\n+\tfunction.\n+\t* jit-recording.h: Within namespace gcc::jit::recording...\n+\t(class rvalue_visitor): New.\n+\t(rvalue::rvalue): Initialize m_scope.\n+\t(rvalue::get_loc): New accessor.\n+\t(rvalue::verify_valid_within_stmt): New function.\n+\t(rvalue::visit_children): New pure virtual function.\n+\t(rvalue::set_scope): New function.\n+\t(rvalue::get_scope): New function.\n+\t(rvalue::dyn_cast_param): New function.\n+\t(rvalue::m_scope): New field.\n+\t(param::visit_children): New empty function.\n+\t(param::dyn_cast_param): New function.\n+\t(function::get_loc): New function.\n+\t(block::add_eval): Return the new statement.\n+\t(block::add_assignment): Likewise.\n+\t(block::add_assignment_op): Likewise.\n+\t(block::add_comment): Likewise.\n+\t(block::end_with_conditional): Likewise.\n+\t(block::end_with_jump): Likewise.\n+\t(block::end_with_return): Likewise.\n+\t(global::visit_children): New function.\n+\t(memento_of_new_rvalue_from_const<HOST_TYPE>::visit_children):\n+\tNew function.\n+\t(memento_of_new_string_literal::visit_children): New function.\n+\t(unary_op::visit_children): New function.\n+\t(binary_op::visit_children): New function.\n+\t(comparison::visit_children): New function.\n+\t(cast::visit_children): New function.\n+\t(call::visit_children): New function.\n+\t(call_through_ptr::visit_children): New function.\n+\t(array_access::visit_children): New function.\n+\t(access_field_of_lvalue::visit_children): New function.\n+\t(access_field_rvalue::visit_children): New function.\n+\t(dereference_field_rvalue::visit_children): New function.\n+\t(dereference_rvalue::visit_children): New function.\n+\t(get_address_of_lvalue::visit_children): New function.\n+\t(local::local): Call set_scope.\n+\t(local::visit_children): New function.\n+\t(statement::get_block): Make public.\n+\t* libgccjit.c (RETURN_VAL_IF_FAIL_PRINTF5): New macro.\n+\t(RETURN_NULL_IF_FAIL_PRINTF5): New macro.\n+\t(gcc_jit_context_new_function): Verify that each param has\n+\tnot yet been used for creating another function.\n+\t(gcc_jit_block_add_eval): After creating the stmt, verify\n+\tthat the rvalue expression tree is valid to use within it.\n+\t(gcc_jit_block_add_assignment): Likewise for the lvalue and\n+\trvalue expression trees.\n+\t(gcc_jit_block_add_assignment_op): Likewise.\n+\t(gcc_jit_block_end_with_conditional): Likewise for the boolval\n+\texpression tree.\n+\t(gcc_jit_block_end_with_return): Likewise for the rvalue\n+\texpression tree.\n+\t(gcc_jit_block_end_with_void_return): Remove return of \"void\",\n+\tnow that block::end_with_return is now non-void.\n+\n 2015-01-12  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit-playback.c (gcc::jit::playback::context::read_dump_file):"}, {"sha": "ec247e5a70b07fc5451a300ffc97820fc80e34e5", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 275, "deletions": 20, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -2034,6 +2034,115 @@ recording::rvalue::dereference (recording::location *loc)\n   return result;\n }\n \n+/* An rvalue visitor, for validating that every rvalue within an expression\n+   trees within \"STMT\" has the correct scope (e.g. no access to locals\n+   of a different function).  */\n+\n+class rvalue_usage_validator : public recording::rvalue_visitor\n+{\n+ public:\n+  rvalue_usage_validator (const char *api_funcname,\n+\t\t\t  recording::context *ctxt,\n+\t\t\t  recording::statement *stmt);\n+\n+  void\n+  visit (recording::rvalue *rvalue);\n+\n+ private:\n+  const char *m_api_funcname;\n+  recording::context *m_ctxt;\n+  recording::statement *m_stmt;\n+};\n+\n+/* The trivial constructor for rvalue_usage_validator.  */\n+\n+rvalue_usage_validator::rvalue_usage_validator (const char *api_funcname,\n+\t\t\t\t\t\trecording::context *ctxt,\n+\t\t\t\t\t\trecording::statement *stmt)\n+  : m_api_funcname (api_funcname),\n+    m_ctxt (ctxt),\n+    m_stmt (stmt)\n+{\n+}\n+\n+/* Verify that the given rvalue is in the correct scope.  */\n+\n+void\n+rvalue_usage_validator::visit (recording::rvalue *rvalue)\n+{\n+  gcc_assert (m_stmt->get_block ());\n+  recording::function *stmt_scope = m_stmt->get_block ()->get_function ();\n+\n+  /* Most rvalues don't have a scope (only locals and params).  */\n+  if (rvalue->get_scope ())\n+    {\n+      if (rvalue->get_scope () != stmt_scope)\n+\tm_ctxt->add_error\n+\t  (rvalue->get_loc (),\n+\t   \"%s:\"\n+\t   \" rvalue %s (type: %s)\"\n+\t   \" has scope limited to function %s\"\n+\t   \" but was used within function %s\"\n+\t   \" (in statement: %s)\",\n+\t   m_api_funcname,\n+\t   rvalue->get_debug_string (),\n+\t   rvalue->get_type ()->get_debug_string (),\n+\t   rvalue->get_scope ()->get_debug_string (),\n+\t   stmt_scope->get_debug_string (),\n+\t   m_stmt->get_debug_string ());\n+    }\n+  else\n+    {\n+      if (rvalue->dyn_cast_param ())\n+\tm_ctxt->add_error\n+\t  (rvalue->get_loc (),\n+\t   \"%s:\"\n+\t   \" param %s (type: %s)\"\n+\t   \" was used within function %s\"\n+\t   \" (in statement: %s)\"\n+\t   \" but is not associated with any function\",\n+\t   m_api_funcname,\n+\t   rvalue->get_debug_string (),\n+\t   rvalue->get_type ()->get_debug_string (),\n+\t   stmt_scope->get_debug_string (),\n+\t   m_stmt->get_debug_string ());\n+    }\n+}\n+\n+/* Verify that it's valid to use this rvalue (and all expressions\n+   in the tree below it) within the given statement.\n+\n+   For example, we must reject attempts to use a local from one\n+   function within a different function here, or we'll get\n+   an ICE deep inside toplev::main.  */\n+\n+void\n+recording::rvalue::verify_valid_within_stmt (const char *api_funcname, statement *s)\n+{\n+  rvalue_usage_validator v (api_funcname,\n+\t\t\t    s->get_context (),\n+\t\t\t    s);\n+\n+  /* Verify that it's OK to use this rvalue within s.  */\n+  v.visit (this);\n+\n+  /* Traverse the expression tree below \"this\", verifying all rvalues\n+     within it.  */\n+  visit_children (&v);\n+}\n+\n+/* Set the scope of this rvalue to be the given function.  This can only\n+   be done once on a given rvalue.  */\n+\n+void\n+recording::rvalue::set_scope (function *scope)\n+{\n+  gcc_assert (scope);\n+  gcc_assert (NULL == m_scope);\n+  m_scope = scope;\n+}\n+\n+\n /* The implementation of class gcc::jit::recording::lvalue.  */\n \n /* Create a recording::new_access_field_of_lvalue instance and add it to\n@@ -2106,7 +2215,40 @@ recording::function::function (context *ctxt,\n   m_blocks ()\n {\n   for (int i = 0; i< num_params; i++)\n-    m_params.safe_push (params[i]);\n+    {\n+      param *param = params[i];\n+      gcc_assert (param);\n+\n+      /* Associate each param with this function.\n+\n+\t Verify that the param doesn't already have a function.  */\n+      if (param->get_scope ())\n+\t{\n+\t  /* We've already rejected attempts to reuse a param between\n+\t     different functions (within gcc_jit_context_new_function), so\n+\t     if the param *does* already have a function, it must be being\n+\t     reused within the params array for this function.  We must\n+\t     produce an error for this reuse (blocking the compile), since\n+\t     otherwise we'd have an ICE later on.  */\n+\t  gcc_assert (this == param->get_scope ());\n+\t  ctxt->add_error\n+\t    (loc,\n+\t     \"gcc_jit_context_new_function:\"\n+\t     \" parameter %s (type: %s)\"\n+\t     \" is used more than once when creating function %s\",\n+\t     param->get_debug_string (),\n+\t     param->get_type ()->get_debug_string (),\n+\t     name->c_str ());\n+\t}\n+      else\n+\t{\n+\t  /* The normal, non-error case: associate this function with the\n+\t     param.  */\n+\t  param->set_scope (this);\n+\t}\n+\n+      m_params.safe_push (param);\n+    }\n }\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -2366,43 +2508,42 @@ recording::function::make_debug_string ()\n    the block's context's list of mementos, and to the block's\n    list of statements.\n \n-   Implements the post-error-checking part of\n-   gcc_jit_block_add_eval.  */\n+   Implements the heart of gcc_jit_block_add_eval.  */\n \n-void\n+recording::statement *\n recording::block::add_eval (recording::location *loc,\n \t\t\t    recording::rvalue *rvalue)\n {\n   statement *result = new eval (this, loc, rvalue);\n   m_ctxt->record (result);\n   m_statements.safe_push (result);\n+  return result;\n }\n \n /* Create a recording::assignment instance and add it to\n    the block's context's list of mementos, and to the block's\n    list of statements.\n \n-   Implements the post-error-checking part of\n-   gcc_jit_block_add_assignment.  */\n+   Implements the heart of gcc_jit_block_add_assignment.  */\n \n-void\n+recording::statement *\n recording::block::add_assignment (recording::location *loc,\n \t\t\t\t  recording::lvalue *lvalue,\n \t\t\t\t  recording::rvalue *rvalue)\n {\n   statement *result = new assignment (this, loc, lvalue, rvalue);\n   m_ctxt->record (result);\n   m_statements.safe_push (result);\n+  return result;\n }\n \n /* Create a recording::assignment_op instance and add it to\n    the block's context's list of mementos, and to the block's\n    list of statements.\n \n-   Implements the post-error-checking part of\n-   gcc_jit_block_add_assignment_op.  */\n+   Implements the heart of gcc_jit_block_add_assignment_op.  */\n \n-void\n+recording::statement *\n recording::block::add_assignment_op (recording::location *loc,\n \t\t\t\t     recording::lvalue *lvalue,\n \t\t\t\t     enum gcc_jit_binary_op op,\n@@ -2411,32 +2552,32 @@ recording::block::add_assignment_op (recording::location *loc,\n   statement *result = new assignment_op (this, loc, lvalue, op, rvalue);\n   m_ctxt->record (result);\n   m_statements.safe_push (result);\n+  return result;\n }\n \n /* Create a recording::comment instance and add it to\n    the block's context's list of mementos, and to the block's\n    list of statements.\n \n-   Implements the post-error-checking part of\n-   gcc_jit_block_add_comment.  */\n+   Implements the heart of gcc_jit_block_add_comment.  */\n \n-void\n+recording::statement *\n recording::block::add_comment (recording::location *loc,\n \t\t\t       const char *text)\n {\n   statement *result = new comment (this, loc, new_string (text));\n   m_ctxt->record (result);\n   m_statements.safe_push (result);\n+  return result;\n }\n \n /* Create a recording::end_with_conditional instance and add it to\n    the block's context's list of mementos, and to the block's\n    list of statements.\n \n-   Implements the post-error-checking part of\n-   gcc_jit_block_end_with_conditional.  */\n+   Implements the heart of gcc_jit_block_end_with_conditional.  */\n \n-void\n+recording::statement *\n recording::block::end_with_conditional (recording::location *loc,\n \t\t\t\t\trecording::rvalue *boolval,\n \t\t\t\t\trecording::block *on_true,\n@@ -2446,23 +2587,24 @@ recording::block::end_with_conditional (recording::location *loc,\n   m_ctxt->record (result);\n   m_statements.safe_push (result);\n   m_has_been_terminated = true;\n+  return result;\n }\n \n /* Create a recording::end_with_jump instance and add it to\n    the block's context's list of mementos, and to the block's\n    list of statements.\n \n-   Implements the post-error-checking part of\n-   gcc_jit_block_end_with_jump.  */\n+   Implements the heart of gcc_jit_block_end_with_jump.  */\n \n-void\n+recording::statement *\n recording::block::end_with_jump (recording::location *loc,\n \t\t\t\t recording::block *target)\n {\n   statement *result = new jump (this, loc, target);\n   m_ctxt->record (result);\n   m_statements.safe_push (result);\n   m_has_been_terminated = true;\n+  return result;\n }\n \n /* Create a recording::end_with_return instance and add it to\n@@ -2473,7 +2615,7 @@ recording::block::end_with_jump (recording::location *loc,\n    gcc_jit_block_end_with_return and\n    gcc_jit_block_end_with_void_return.  */\n \n-void\n+recording::statement *\n recording::block::end_with_return (recording::location *loc,\n \t\t\t\t   recording::rvalue *rvalue)\n {\n@@ -2484,6 +2626,7 @@ recording::block::end_with_return (recording::location *loc,\n   m_ctxt->record (result);\n   m_statements.safe_push (result);\n   m_has_been_terminated = true;\n+  return result;\n }\n \n /* Override the default implementation of\n@@ -2513,6 +2656,7 @@ recording::block::write_to_dump (dump &d)\n bool\n recording::block::validate ()\n {\n+  /* Check for termination.  */\n   if (!has_been_terminated ())\n     {\n       statement *stmt = get_last_statement ();\n@@ -2856,6 +3000,14 @@ recording::unary_op::replay_into (replayer *r)\n \t\t\t\t     m_a->playback_rvalue ()));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::unary_op.  */\n+void\n+recording::unary_op::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_a);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    unary ops.  */\n \n@@ -2890,6 +3042,15 @@ recording::binary_op::replay_into (replayer *r)\n \t\t\t\t      m_b->playback_rvalue ()));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::binary_op.  */\n+void\n+recording::binary_op::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_a);\n+  v->visit (m_b);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    binary ops.  */\n \n@@ -2955,6 +3116,16 @@ recording::comparison::replay_into (replayer *r)\n \t\t\t\t       m_b->playback_rvalue ()));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::comparison.  */\n+\n+void\n+recording::comparison::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_a);\n+  v->visit (m_b);\n+}\n+\n /* Implementation of pure virtual hook recording::memento::replay_into\n    for recording::cast.  */\n \n@@ -2966,6 +3137,14 @@ recording::cast::replay_into (replayer *r)\n \t\t\t\t get_type ()->playback_type ()));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::cast.  */\n+void\n+recording::cast::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_rvalue);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    casts.  */\n \n@@ -3011,6 +3190,16 @@ recording::call::replay_into (replayer *r)\n \t\t\t\t &playback_args));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::call.  */\n+\n+void\n+recording::call::visit_children (rvalue_visitor *v)\n+{\n+  for (unsigned i = 0; i< m_args.length (); i++)\n+    v->visit (m_args[i]);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    function calls.  */\n \n@@ -3088,6 +3277,17 @@ recording::call_through_ptr::replay_into (replayer *r)\n \t\t\t\t\t     &playback_args));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::call_through_ptr.  */\n+\n+void\n+recording::call_through_ptr::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_fn_ptr);\n+  for (unsigned i = 0; i< m_args.length (); i++)\n+    v->visit (m_args[i]);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    calls through function ptrs.  */\n \n@@ -3144,6 +3344,16 @@ recording::array_access::replay_into (replayer *r)\n \t\t\t m_index->playback_rvalue ()));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::array_access.  */\n+\n+void\n+recording::array_access::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_ptr);\n+  v->visit (m_index);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    array accesses.  */\n \n@@ -3171,6 +3381,15 @@ recording::access_field_of_lvalue::replay_into (replayer *r)\n \n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::access_field_of_lvalue.  */\n+\n+void\n+recording::access_field_of_lvalue::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_lvalue);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    accessing a field of an lvalue.  */\n \n@@ -3197,6 +3416,15 @@ recording::access_field_rvalue::replay_into (replayer *r)\n \t\t      m_field->playback_field ()));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::access_field_rvalue.  */\n+\n+void\n+recording::access_field_rvalue::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_rvalue);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    accessing a field of an rvalue.  */\n \n@@ -3224,6 +3452,15 @@ recording::dereference_field_rvalue::replay_into (replayer *r)\n \t\t\t m_field->playback_field ()));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::dereference_field_rvalue.  */\n+\n+void\n+recording::dereference_field_rvalue::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_rvalue);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    dereferencing a field of an rvalue.  */\n \n@@ -3249,6 +3486,15 @@ recording::dereference_rvalue::replay_into (replayer *r)\n       dereference (playback_location (r, m_loc)));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::dereference_rvalue.  */\n+\n+void\n+recording::dereference_rvalue::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_rvalue);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    dereferencing an rvalue.  */\n \n@@ -3273,6 +3519,15 @@ recording::get_address_of_lvalue::replay_into (replayer *r)\n       get_address (playback_location (r, m_loc)));\n }\n \n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::get_address_of_lvalue.  */\n+\n+void\n+recording::get_address_of_lvalue::visit_children (rvalue_visitor *v)\n+{\n+  v->visit (m_lvalue);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    getting the address of an lvalue.  */\n "}, {"sha": "812205c0a1bb7cdb48e9c5cba109e196e8cce055", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 79, "deletions": 11, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -800,6 +800,18 @@ class union_ : public compound_type\n   fields *m_fields;\n };\n \n+/* An abstract base class for operations that visit all rvalues within an\n+   expression tree.\n+   Currently the only implementation is class rvalue_usage_validator within\n+   jit-recording.c.  */\n+\n+class rvalue_visitor\n+{\n+ public:\n+  virtual ~rvalue_visitor () {}\n+  virtual void visit (rvalue *rvalue) = 0;\n+};\n+\n class rvalue : public memento\n {\n public:\n@@ -808,11 +820,14 @@ class rvalue : public memento\n \t  type *type_)\n   : memento (ctxt),\n     m_loc (loc),\n-    m_type (type_)\n+    m_type (type_),\n+    m_scope (NULL)\n   {\n     gcc_assert (type_);\n   }\n \n+  location * get_loc () const { return m_loc; }\n+\n   /* Get the recording::type of this rvalue.\n \n      Implements the post-error-checking part of\n@@ -835,9 +850,23 @@ class rvalue : public memento\n   lvalue *\n   dereference (location *loc);\n \n+  void\n+  verify_valid_within_stmt (const char *api_funcname, statement *s);\n+\n+  virtual void visit_children (rvalue_visitor *v) = 0;\n+\n+  void set_scope (function *scope);\n+  function *get_scope () const { return m_scope; }\n+\n+  /* Dynamic cast.  */\n+  virtual param *dyn_cast_param () { return NULL; }\n+\n protected:\n   location *m_loc;\n   type *m_type;\n+\n+ private:\n+  function *m_scope; /* NULL for globals, non-NULL for locals/params */\n };\n \n class lvalue : public rvalue\n@@ -881,12 +910,16 @@ class param : public lvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *) {}\n+\n   playback::param *\n   playback_param () const\n   {\n     return static_cast <playback::param *> (m_playback_obj);\n   }\n \n+  param *dyn_cast_param () { return this; }\n+\n private:\n   string * make_debug_string () { return m_name; }\n \n@@ -925,6 +958,7 @@ class function : public memento\n   block*\n   new_block (const char *name);\n \n+  location *get_loc () const { return m_loc; }\n   type *get_return_type () const { return m_return_type; }\n   string * get_name () const { return m_name; }\n   const vec<param *> &get_params () const { return m_params; }\n@@ -979,36 +1013,36 @@ class block : public memento\n   bool has_been_terminated () { return m_has_been_terminated; }\n   bool is_reachable () { return m_is_reachable; }\n \n-  void\n+  statement *\n   add_eval (location *loc,\n \t    rvalue *rvalue);\n \n-  void\n+  statement *\n   add_assignment (location *loc,\n \t\t  lvalue *lvalue,\n \t\t  rvalue *rvalue);\n \n-  void\n+  statement *\n   add_assignment_op (location *loc,\n \t\t     lvalue *lvalue,\n \t\t     enum gcc_jit_binary_op op,\n \t\t     rvalue *rvalue);\n \n-  void\n+  statement *\n   add_comment (location *loc,\n \t       const char *text);\n \n-  void\n+  statement *\n   end_with_conditional (location *loc,\n \t\t\trvalue *boolval,\n \t\t\tblock *on_true,\n \t\t\tblock *on_false);\n \n-  void\n+  statement *\n   end_with_jump (location *loc,\n \t\t block *target);\n \n-  void\n+  statement *\n   end_with_return (location *loc,\n \t\t   rvalue *rvalue);\n \n@@ -1063,6 +1097,8 @@ class global : public lvalue\n \n   void replay_into (replayer *);\n \n+  void visit_children (rvalue_visitor *) {}\n+\n   void write_to_dump (dump &d);\n \n private:\n@@ -1086,6 +1122,8 @@ class memento_of_new_rvalue_from_const : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *) {}\n+\n private:\n   string * make_debug_string ();\n \n@@ -1104,6 +1142,8 @@ class memento_of_new_string_literal : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *) {}\n+\n private:\n   string * make_debug_string ();\n \n@@ -1126,6 +1166,8 @@ class unary_op : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1149,6 +1191,8 @@ class binary_op : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1173,6 +1217,8 @@ class comparison : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1195,6 +1241,8 @@ class cast : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1213,6 +1261,8 @@ class call : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1232,6 +1282,8 @@ class call_through_ptr : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1254,6 +1306,8 @@ class array_access : public lvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1276,6 +1330,8 @@ class access_field_of_lvalue : public lvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1298,6 +1354,8 @@ class access_field_rvalue : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1320,6 +1378,8 @@ class dereference_field_rvalue : public lvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1339,6 +1399,8 @@ class dereference_rvalue : public lvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1358,6 +1420,8 @@ class get_address_of_lvalue : public rvalue\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *v);\n+\n private:\n   string * make_debug_string ();\n \n@@ -1371,10 +1435,15 @@ class local : public lvalue\n   local (function *func, location *loc, type *type_, string *name)\n     : lvalue (func->m_ctxt, loc, type_),\n     m_func (func),\n-    m_name (name) {}\n+    m_name (name)\n+  {\n+    set_scope (func);\n+  }\n \n   void replay_into (replayer *r);\n \n+  void visit_children (rvalue_visitor *) {}\n+\n   void write_to_dump (dump &d);\n \n private:\n@@ -1393,6 +1462,7 @@ class statement : public memento\n \n   void write_to_dump (dump &d);\n \n+  block *get_block () const { return m_block; }\n   location *get_loc () const { return m_loc; }\n \n protected:\n@@ -1401,8 +1471,6 @@ class statement : public memento\n     m_block (b),\n     m_loc (loc) {}\n \n-  block *get_block () const { return m_block; }\n-\n   playback::location *\n   playback_location (replayer *r) const\n   {"}, {"sha": "ad8ee752d29f11c40b4e96e670f4416f850ba631", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 73, "deletions": 10, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -172,6 +172,16 @@ struct gcc_jit_param : public gcc::jit::recording::param\n       }\t\t\t\t\t\t\t\t\\\n   JIT_END_STMT\n \n+#define RETURN_VAL_IF_FAIL_PRINTF5(TEST_EXPR, RETURN_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\t\\\n+\t\t   __func__, (A0), (A1), (A2), (A3), (A4));\t\\\n+\treturn (RETURN_EXPR);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n #define RETURN_VAL_IF_FAIL_PRINTF6(TEST_EXPR, RETURN_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4, A5) \\\n   JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n     if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n@@ -197,6 +207,9 @@ struct gcc_jit_param : public gcc::jit::recording::param\n #define RETURN_NULL_IF_FAIL_PRINTF4(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3) \\\n   RETURN_VAL_IF_FAIL_PRINTF4 (TEST_EXPR, NULL, CTXT, LOC, ERR_FMT, A0, A1, A2, A3)\n \n+#define RETURN_NULL_IF_FAIL_PRINTF5(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4) \\\n+  RETURN_VAL_IF_FAIL_PRINTF5 (TEST_EXPR, NULL, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4)\n+\n #define RETURN_NULL_IF_FAIL_PRINTF6(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4, A5) \\\n   RETURN_VAL_IF_FAIL_PRINTF6 (TEST_EXPR, NULL, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4, A5)\n \n@@ -844,10 +857,23 @@ gcc_jit_context_new_function (gcc_jit_context *ctxt,\n     ctxt, loc,\n     \"NULL params creating function %s\", name);\n   for (int i = 0; i < num_params; i++)\n-    RETURN_NULL_IF_FAIL_PRINTF2 (\n-      params[i],\n-      ctxt, loc,\n-      \"NULL parameter %i creating function %s\", i, name);\n+    {\n+      RETURN_NULL_IF_FAIL_PRINTF2 (\n+\tparams[i],\n+\tctxt, loc,\n+\t\"NULL parameter %i creating function %s\", i, name);\n+      RETURN_NULL_IF_FAIL_PRINTF5 (\n+\t(NULL == params[i]->get_scope ()),\n+\tctxt, loc,\n+\t\"parameter %i \\\"%s\\\"\"\n+\t\" (type: %s)\"\n+\t\" for function %s\"\n+\t\" was already used for function %s\",\n+\ti, params[i]->get_debug_string (),\n+\tparams[i]->get_type ()->get_debug_string (),\n+\tname,\n+\tparams[i]->get_scope ()->get_debug_string ());\n+    }\n \n   return (gcc_jit_function*)\n     ctxt->new_function (loc, kind, return_type, name,\n@@ -1800,7 +1826,14 @@ gcc_jit_block_add_eval (gcc_jit_block *block,\n   /* LOC can be NULL.  */\n   RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n \n-  return block->add_eval (loc, rvalue);\n+  gcc::jit::recording::statement *stmt = block->add_eval (loc, rvalue);\n+\n+  /* \"stmt\" should be good enough to be usable in error-messages,\n+     but might still not be compilable; perform some more\n+     error-checking here.  We do this here so that the error messages\n+     can contain a stringified version of \"stmt\", whilst appearing\n+     as close as possible to the point of failure.  */\n+  rvalue->verify_valid_within_stmt (__func__, stmt);\n }\n \n /* Public entrypoint.  See description in libgccjit.h.\n@@ -1832,7 +1865,15 @@ gcc_jit_block_add_assignment (gcc_jit_block *block,\n     rvalue->get_debug_string (),\n     rvalue->get_type ()->get_debug_string ());\n \n-  return block->add_assignment (loc, lvalue, rvalue);\n+  gcc::jit::recording::statement *stmt = block->add_assignment (loc, lvalue, rvalue);\n+\n+  /* \"stmt\" should be good enough to be usable in error-messages,\n+     but might still not be compilable; perform some more\n+     error-checking here.  We do this here so that the error messages\n+     can contain a stringified version of \"stmt\", whilst appearing\n+     as close as possible to the point of failure.  */\n+  lvalue->verify_valid_within_stmt (__func__, stmt);\n+  rvalue->verify_valid_within_stmt (__func__, stmt);\n }\n \n /* Public entrypoint.  See description in libgccjit.h.\n@@ -1860,7 +1901,15 @@ gcc_jit_block_add_assignment_op (gcc_jit_block *block,\n     op);\n   RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n \n-  return block->add_assignment_op (loc, lvalue, op, rvalue);\n+  gcc::jit::recording::statement *stmt = block->add_assignment_op (loc, lvalue, op, rvalue);\n+\n+  /* \"stmt\" should be good enough to be usable in error-messages,\n+     but might still not be compilable; perform some more\n+     error-checking here.  We do this here so that the error messages\n+     can contain a stringified version of \"stmt\", whilst appearing\n+     as close as possible to the point of failure.  */\n+  lvalue->verify_valid_within_stmt (__func__, stmt);\n+  rvalue->verify_valid_within_stmt (__func__, stmt);\n }\n \n /* Internal helper function for determining if rvalue BOOLVAL is of\n@@ -1921,7 +1970,14 @@ gcc_jit_block_end_with_conditional (gcc_jit_block *block,\n     on_false->get_debug_string (),\n     on_false->get_function ()->get_debug_string ());\n \n-  return block->end_with_conditional (loc, boolval, on_true, on_false);\n+  gcc::jit::recording::statement *stmt = block->end_with_conditional (loc, boolval, on_true, on_false);\n+\n+  /* \"stmt\" should be good enough to be usable in error-messages,\n+     but might still not be compilable; perform some more\n+     error-checking here.  We do this here so that the error messages\n+     can contain a stringified version of \"stmt\", whilst appearing\n+     as close as possible to the point of failure.  */\n+  boolval->verify_valid_within_stmt (__func__, stmt);\n }\n \n /* Public entrypoint.  See description in libgccjit.h.\n@@ -2003,7 +2059,14 @@ gcc_jit_block_end_with_return (gcc_jit_block *block,\n     func->get_debug_string (),\n     func->get_return_type ()->get_debug_string ());\n \n-  return block->end_with_return (loc, rvalue);\n+  gcc::jit::recording::statement *stmt = block->end_with_return (loc, rvalue);\n+\n+  /* \"stmt\" should be good enough to be usable in error-messages,\n+     but might still not be compilable; perform some more\n+     error-checking here.  We do this here so that the error messages\n+     can contain a stringified version of \"stmt\", whilst appearing\n+     as close as possible to the point of failure.  */\n+  rvalue->verify_valid_within_stmt (__func__, stmt);\n }\n \n /* Public entrypoint.  See description in libgccjit.h.\n@@ -2029,7 +2092,7 @@ gcc_jit_block_end_with_void_return (gcc_jit_block *block,\n     func->get_debug_string (),\n     func->get_return_type ()->get_debug_string ());\n \n-  return block->end_with_return (loc, NULL);\n+  block->end_with_return (loc, NULL);\n }\n \n /**********************************************************************"}, {"sha": "ba472c521b66dd2ed0fa87492fab2a08a5fa1b70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -1,3 +1,14 @@\n+2015-01-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-local-used-from-other-function.c: New test\n+\tcase.\n+\t* jit.dg/test-error-param-reuse.c: New test case.\n+\t* jit.dg/test-error-param-sharing.c: New test case.\n+\t* jit.dg/test-error-param-used-from-other-function.c: New test\n+\tcase.\n+\t* jit.dg/test-error-param-used-without-a-function.c: New test\n+\tcase.\n+\n 2015-01-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/64563"}, {"sha": "fac47c853e84c1d90b6cdfe884fa102ad3034652", "filename": "gcc/testsuite/jit.dg/test-error-local-used-from-other-function.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-local-used-from-other-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-local-used-from-other-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-local-used-from-other-function.c?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -0,0 +1,70 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     void\n+     fn_one ()\n+     {\n+       int i;\n+     }\n+\n+     int\n+     fn_two ()\n+     {\n+       return i;\n+     }\n+\n+     and verify that the API complains about the use of the local\n+     from the other function.  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_function *fn_one =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  void_type,\n+\t\t\t\t  \"fn_one\",\n+\t\t\t\t  0, NULL,\n+\t\t\t\t  0);\n+  gcc_jit_lvalue *local =\n+    gcc_jit_function_new_local (fn_one, NULL, int_type, \"i\");\n+\n+  gcc_jit_function *fn_two =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  int_type,\n+                                  \"fn_two\",\n+                                  0, NULL,\n+                                  0);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (fn_two, NULL);\n+  /* \"return i;\", using local i from the wrong function.  */\n+  gcc_jit_block_end_with_return (block,\n+\t\t\t\t NULL,\n+\t\t\t\t gcc_jit_lvalue_as_rvalue (local));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_block_end_with_return:\"\n+\t\t       \" rvalue i (type: int)\"\n+\t\t       \" has scope limited to function fn_one\"\n+\t\t       \" but was used within function fn_two\"\n+\t\t       \" (in statement: return i;)\"));\n+}\n+"}, {"sha": "32cb0c015c1b77fb6077f7f848b1496c213bb67a", "filename": "gcc/testsuite/jit.dg/test-error-param-reuse.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-reuse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-reuse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-reuse.c?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -0,0 +1,48 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Verify that we get an error (rather than a crash)\n+     if the client code reuses a gcc_jit_param * within\n+     a function.  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Create a param.  */\n+  gcc_jit_param *param =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+\n+  /* Try to use it twice when creating \"fn\".  */\n+  gcc_jit_param *params[2];\n+  params[0] = param;\n+  params[1] = param;\n+\n+  gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\tGCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\tvoid_type,\n+\t\t\t\t\"fn\",\n+\t\t\t\t2, params,\n+\t\t\t\t0);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_context_new_function:\"\n+\t\t       \" parameter i (type: int)\"\n+\t\t       \" is used more than once when creating function\"\n+\t\t       \" fn\"))\n+}\n+"}, {"sha": "036049c58660a2b3d17fbb6028680d8ba592faa2", "filename": "gcc/testsuite/jit.dg/test-error-param-sharing.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-sharing.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-sharing.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-sharing.c?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -0,0 +1,61 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+  extern void\n+  called_function (void *ptr);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Verify that we get an error (rather than a crash)\n+     if the client code reuses a gcc_jit_param * for\n+     two different functions.  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Create a param.  */\n+  gcc_jit_param *param =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+\n+  /* Try to use it for two different functions. */\n+  gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\tGCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\tvoid_type,\n+\t\t\t\t\"fn_one\",\n+\t\t\t\t1, &param,\n+\t\t\t\t0);\n+  gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\tGCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\tvoid_type,\n+\t\t\t\t\"fn_two\",\n+\t\t\t\t1, &param,\n+\t\t\t\t0);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_context_new_function:\"\n+\t\t       \" parameter 0 \\\"i\\\" (type: int)\"\n+\t\t       \" for function fn_two\"\n+\t\t       \" was already used for function fn_one\"))\n+}\n+"}, {"sha": "84e898b1c952149cb9673a12ca546cd16ae96f0a", "filename": "gcc/testsuite/jit.dg/test-error-param-used-from-other-function.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-used-from-other-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-used-from-other-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-used-from-other-function.c?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -0,0 +1,74 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     void\n+     fn_one (int i)\n+     {\n+     }\n+\n+     int\n+     fn_two ()\n+     {\n+       return i * 2;\n+     }\n+\n+     and verify that the API complains about the use of the param\n+     from the other function.  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_param *param =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+\n+  gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\tGCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\tvoid_type,\n+\t\t\t\t\"fn_one\",\n+\t\t\t\t1, &param,\n+\t\t\t\t0);\n+  gcc_jit_function *fn_two =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  int_type,\n+                                  \"fn_two\",\n+                                  0, NULL,\n+                                  0);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (fn_two, NULL);\n+  /* \"return i * 2;\", using param i from the wrong function.  */\n+  gcc_jit_block_end_with_return (\n+    block,\n+    NULL,\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_MULT,\n+      int_type,\n+      gcc_jit_param_as_rvalue (param),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 2)));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_block_end_with_return:\"\n+\t\t       \" rvalue i (type: int)\"\n+\t\t       \" has scope limited to function fn_one\"\n+\t\t       \" but was used within function fn_two\"\n+\t\t       \" (in statement: return i * (int)2;)\"));\n+}\n+"}, {"sha": "f369c6baf3097efa86907a4ea8363f453bcc94b1", "filename": "gcc/testsuite/jit.dg/test-error-param-used-without-a-function.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-used-without-a-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f2b01933268f73bf439ead94a1a72416a36cd5/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-used-without-a-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-param-used-without-a-function.c?ref=f6f2b01933268f73bf439ead94a1a72416a36cd5", "patch": "@@ -0,0 +1,56 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     int\n+     test_fn ()\n+     {\n+       return i;\n+     }\n+\n+     where \"i\" is a param that isn't associated with any function,\n+     and verify that the API complains.  */\n+\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_param *param =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  int_type,\n+                                  \"test_fn\",\n+                                  0, NULL,\n+                                  0);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  /* \"return i;\", using param i from the wrong function.  */\n+  gcc_jit_block_end_with_return (block,\n+\t\t\t\t NULL,\n+\t\t\t\t gcc_jit_param_as_rvalue (param));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_block_end_with_return:\"\n+\t\t       \" param i (type: int)\"\n+\t\t       \" was used within function test_fn\"\n+\t\t       \" (in statement: return i;)\"\n+\t\t       \" but is not associated with any function\"))\n+}\n+"}]}