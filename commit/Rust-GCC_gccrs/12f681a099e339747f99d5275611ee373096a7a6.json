{"sha": "12f681a099e339747f99d5275611ee373096a7a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJmNjgxYTA5OWUzMzk3NDdmOTlkNTI3NTYxMWVlMzczMDk2YTdhNg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-11-01T13:26:19Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-11-01T13:26:19Z"}, "message": "re PR fortran/35681 (wrong result for vector subscripted array expression in MVBITS)\n\n2008-11-01  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/35681\n\t* gfortran.h (struct gfc_code): New field `resolved_isym'.\n\t* trans.h (gfc_build_memcpy_call): Made public.\n\t* trans-array.h (gfc_trans_create_temp_array): New argument `initial'.\n\t* intrinsic.c (gfc_intrinsic_sub_interface): Set resolved_isym.\n\t* iresolve.c (create_formal_for_intents): New helper method.\n\t(gfc_resolve_mvbits): Put dummy formal arglist on resolved_sym.\n\t* resolve.c (resolve_call): Initialize resolved_isym to NULL.\n\t* trans-array.c (gfc_trans_allocate_array_storage): New argument\n\t`initial' to allow initializing the allocated storage to some initial\n\tvalue copied from another array.\n\t(gfc_trans_create_temp_array): Allow initialization of the temporary\n\twith a copy of some other array by using the new extension.\n\t(gfc_trans_array_constructor): Pass NULL_TREE for initial argument.\n\t(gfc_conv_loop_setup): Ditto.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_array_transfer): Ditto.\n\t* trans-expr.c (gfc_conv_function_call): Ditto.\n\t(gfc_build_memcpy_call): Made public.\n\t* trans-stmt.c (gfc_conv_elemental_dependencies): Initialize created\n\ttemporary for INTENT(INOUT) arguments to the value of the mirrored\n\tarray and clean up the temporary as very last intructions in the created\n\tblock.\n\t* trans.c (gfc_trans_code): For EXEC_CALL, see if we have a MVBITS call\n\tand enable elemental dependency checking if we have.\n\n2008-11-01  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/35681\n\t* gfortran.dg/mvbits_4.f90: New test.\n\nFrom-SVN: r141516", "tree": {"sha": "2e2f8034dbe6387ba74d7083bb295d1062d519e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e2f8034dbe6387ba74d7083bb295d1062d519e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12f681a099e339747f99d5275611ee373096a7a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f681a099e339747f99d5275611ee373096a7a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f681a099e339747f99d5275611ee373096a7a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f681a099e339747f99d5275611ee373096a7a6/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c6acea9d4fd505ca611df1f8b248bbbecaa4fef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6acea9d4fd505ca611df1f8b248bbbecaa4fef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6acea9d4fd505ca611df1f8b248bbbecaa4fef6"}], "stats": {"total": 297, "additions": 242, "deletions": 55}, "files": [{"sha": "a7baab24526db10e9b1e2bd633da8d74211c22ce", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -1,3 +1,30 @@\n+2008-11-01  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/35681\n+\t* gfortran.h (struct gfc_code): New field `resolved_isym'.\n+\t* trans.h (gfc_build_memcpy_call): Made public.\n+\t* trans-array.h (gfc_trans_create_temp_array): New argument `initial'.\n+\t* intrinsic.c (gfc_intrinsic_sub_interface): Set resolved_isym.\n+\t* iresolve.c (create_formal_for_intents): New helper method.\n+\t(gfc_resolve_mvbits): Put dummy formal arglist on resolved_sym.\n+\t* resolve.c (resolve_call): Initialize resolved_isym to NULL.\n+\t* trans-array.c (gfc_trans_allocate_array_storage): New argument\n+\t`initial' to allow initializing the allocated storage to some initial\n+\tvalue copied from another array.\n+\t(gfc_trans_create_temp_array): Allow initialization of the temporary\n+\twith a copy of some other array by using the new extension.\n+\t(gfc_trans_array_constructor): Pass NULL_TREE for initial argument.\n+\t(gfc_conv_loop_setup): Ditto.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_array_transfer): Ditto.\n+\t* trans-expr.c (gfc_conv_function_call): Ditto.\n+\t(gfc_build_memcpy_call): Made public.\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies): Initialize created\n+\ttemporary for INTENT(INOUT) arguments to the value of the mirrored\n+\tarray and clean up the temporary as very last intructions in the created\n+\tblock.\n+\t* trans.c (gfc_trans_code): For EXEC_CALL, see if we have a MVBITS call\n+\tand enable elemental dependency checking if we have.\n+\n 2008-11-01  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/36322"}, {"sha": "5f4880eebf240514afd2bd8d4b9c26e2e7957b45", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -1886,6 +1886,7 @@ typedef struct gfc_code\n      symbol for the interface definition.\n   const char *sub_name;  */\n   gfc_symbol *resolved_sym;\n+  gfc_intrinsic_sym *resolved_isym;\n \n   union\n   {"}, {"sha": "1864785a318e5ea16277e58d5c2d996c1e254cd5", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -3746,6 +3746,7 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n   if (!error_flag)\n     gfc_pop_suppress_errors ();\n \n+  c->resolved_isym = isym;\n   if (isym->resolve.s1 != NULL)\n     isym->resolve.s1 (c);\n   else"}, {"sha": "619d7e9546af0a004d32cf1546c0ab62afb4e603", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -2608,9 +2608,43 @@ gfc_resolve_cpu_time (gfc_code *c)\n }\n \n \n+/* Create a formal arglist based on an actual one and set the INTENTs given.  */\n+\n+static gfc_formal_arglist*\n+create_formal_for_intents (gfc_actual_arglist* actual, const sym_intent* ints)\n+{\n+  gfc_formal_arglist* head;\n+  gfc_formal_arglist* tail;\n+  int i;\n+\n+  if (!actual)\n+    return NULL;\n+\n+  head = tail = gfc_get_formal_arglist ();\n+  for (i = 0; actual; actual = actual->next, tail = tail->next, ++i)\n+    {\n+      gfc_symbol* sym;\n+\n+      sym = gfc_new_symbol (\"dummyarg\", NULL);\n+      sym->ts = actual->expr->ts;\n+\n+      sym->attr.intent = ints[i];\n+      tail->sym = sym;\n+\n+      if (actual->next)\n+\ttail->next = gfc_get_formal_arglist ();\n+    }\n+\n+  return head;\n+}\n+\n+\n void\n gfc_resolve_mvbits (gfc_code *c)\n {\n+  static const sym_intent INTENTS[] = {INTENT_IN, INTENT_IN, INTENT_IN,\n+\t\t\t\t       INTENT_INOUT, INTENT_IN};\n+\n   const char *name;\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n@@ -2632,6 +2666,10 @@ gfc_resolve_mvbits (gfc_code *c)\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n   /* Mark as elemental subroutine as this does not happen automatically.  */\n   c->resolved_sym->attr.elemental = 1;\n+\n+  /* Create a dummy formal arglist so the INTENTs are known later for purpose\n+     of creating temporaries.  */\n+  c->resolved_sym->formal = create_formal_for_intents (c->ext.actual, INTENTS);\n }\n \n "}, {"sha": "c03f6a629d8b722d934bc1d945b7f63cd2979f35", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -2913,23 +2913,26 @@ resolve_call (gfc_code *c)\n \n   t = SUCCESS;\n   if (c->resolved_sym == NULL)\n-    switch (procedure_kind (csym))\n-      {\n-      case PTYPE_GENERIC:\n-\tt = resolve_generic_s (c);\n-\tbreak;\n+    {\n+      c->resolved_isym = NULL;\n+      switch (procedure_kind (csym))\n+\t{\n+\tcase PTYPE_GENERIC:\n+\t  t = resolve_generic_s (c);\n+\t  break;\n \n-      case PTYPE_SPECIFIC:\n-\tt = resolve_specific_s (c);\n-\tbreak;\n+\tcase PTYPE_SPECIFIC:\n+\t  t = resolve_specific_s (c);\n+\t  break;\n \n-      case PTYPE_UNKNOWN:\n-\tt = resolve_unknown_s (c);\n-\tbreak;\n+\tcase PTYPE_UNKNOWN:\n+\t  t = resolve_unknown_s (c);\n+\t  break;\n \n-      default:\n-\tgfc_internal_error (\"resolve_subroutine(): bad function type\");\n-      }\n+\tdefault:\n+\t  gfc_internal_error (\"resolve_subroutine(): bad function type\");\n+\t}\n+    }\n \n   /* Some checks of elemental subroutine actual arguments.  */\n   if (resolve_elemental_actual (NULL, c) == FAILURE)"}, {"sha": "db43a40d82de51da8d9d0e9c9c5a7b3b11729699", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 72, "deletions": 23, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -493,14 +493,17 @@ gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping * mapping,\n    callee will allocate the array.  If DEALLOC is true, also generate code to\n    free the array afterwards.\n \n+   If INITIAL is not NULL, it is packed using internal_pack and the result used\n+   as data instead of allocating a fresh, unitialized area of memory.\n+\n    Initialization code is added to PRE and finalization code to POST.\n    DYNAMIC is true if the caller may want to extend the array later\n    using realloc.  This prevents us from putting the array on the stack.  */\n \n static void\n gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n-                                  gfc_ss_info * info, tree size, tree nelem,\n-                                  bool dynamic, bool dealloc)\n+\t\t\t\t  gfc_ss_info * info, tree size, tree nelem,\n+\t\t\t\t  tree initial, bool dynamic, bool dealloc)\n {\n   tree tmp;\n   tree desc;\n@@ -517,7 +520,8 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n   else\n     {\n       /* Allocate the temporary.  */\n-      onstack = !dynamic && gfc_can_put_var_on_stack (size);\n+      onstack = !dynamic && initial == NULL_TREE\n+\t\t\t && gfc_can_put_var_on_stack (size);\n \n       if (onstack)\n \t{\n@@ -534,9 +538,53 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n \t}\n       else\n \t{\n-\t  /* Allocate memory to hold the data.  */\n-\t  tmp = gfc_call_malloc (pre, NULL, size);\n-\t  tmp = gfc_evaluate_now (tmp, pre);\n+\t  /* Allocate memory to hold the data or call internal_pack.  */\n+\t  if (initial == NULL_TREE)\n+\t    {\n+\t      tmp = gfc_call_malloc (pre, NULL, size);\n+\t      tmp = gfc_evaluate_now (tmp, pre);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree packed;\n+\t      tree source_data;\n+\t      tree was_packed;\n+\t      stmtblock_t do_copying;\n+\n+\t      tmp = TREE_TYPE (initial); /* Pointer to descriptor.  */\n+\t      gcc_assert (TREE_CODE (tmp) == POINTER_TYPE);\n+\t      tmp = TREE_TYPE (tmp); /* The descriptor itself.  */\n+\t      tmp = gfc_get_element_type (tmp);\n+\t      gcc_assert (tmp == gfc_get_element_type (TREE_TYPE (desc)));\n+\t      packed = gfc_create_var (build_pointer_type (tmp), \"data\");\n+\n+\t      tmp = build_call_expr (gfor_fndecl_in_pack, 1, initial);\n+\t      tmp = fold_convert (TREE_TYPE (packed), tmp);\n+\t      gfc_add_modify (pre, packed, tmp);\n+\n+\t      tmp = build_fold_indirect_ref (initial);\n+\t      source_data = gfc_conv_descriptor_data_get (tmp);\n+\n+\t      /* internal_pack may return source->data without any allocation\n+\t\t or copying if it is already packed.  If that's the case, we\n+\t\t need to allocate and copy manually.  */\n+\n+\t      gfc_start_block (&do_copying);\n+\t      tmp = gfc_call_malloc (&do_copying, NULL, size);\n+\t      tmp = fold_convert (TREE_TYPE (packed), tmp);\n+\t      gfc_add_modify (&do_copying, packed, tmp);\n+\t      tmp = gfc_build_memcpy_call (packed, source_data, size);\n+\t      gfc_add_expr_to_block (&do_copying, tmp);\n+\n+\t      was_packed = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t\tpacked, source_data);\n+\t      tmp = gfc_finish_block (&do_copying);\n+\t      tmp = build3_v (COND_EXPR, was_packed, tmp, build_empty_stmt ());\n+\t      gfc_add_expr_to_block (pre, tmp);\n+\n+\t      tmp = fold_convert (pvoid_type_node, packed);\n+\t    }\n+\n \t  gfc_conv_descriptor_data_set (pre, desc, tmp);\n \t}\n     }\n@@ -567,14 +615,15 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n    fields of info if known.  Returns the size of the array, or NULL for a\n    callee allocated array.\n \n-   PRE, POST, DYNAMIC and DEALLOC are as for gfc_trans_allocate_array_storage.\n+   PRE, POST, INITIAL, DYNAMIC and DEALLOC are as for\n+   gfc_trans_allocate_array_storage.\n  */\n \n tree\n gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \t\t\t     gfc_loopinfo * loop, gfc_ss_info * info,\n-\t\t\t     tree eltype, bool dynamic, bool dealloc,\n-\t\t\t     bool callee_alloc, locus * where)\n+\t\t\t     tree eltype, tree initial, bool dynamic,\n+\t\t\t     bool dealloc, bool callee_alloc, locus * where)\n {\n   tree type;\n   tree desc;\n@@ -600,8 +649,8 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n       else\n \t{\n \t  /* Callee allocated arrays may not have a known bound yet.  */\n-          if (loop->to[n])\n-              loop->to[n] = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t  if (loop->to[n])\n+\t      loop->to[n] = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t\t\t loop->to[n], loop->from[n]);\n \t  loop->from[n] = gfc_index_zero_node;\n \t}\n@@ -635,7 +684,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n        {\n \t stride[n] = size\n \t delta = ubound[n] + 1 - lbound[n];\n-         size = size * delta;\n+\t size = size * delta;\n        }\n      size = size * sizeof(element);\n   */\n@@ -654,17 +703,17 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n   for (n = 0; n < info->dimen; n++)\n      {\n       if (size == NULL_TREE)\n-        {\n+\t{\n \t  /* For a callee allocated array express the loop bounds in terms\n \t     of the descriptor fields.  */\n-          tmp =\n+\t  tmp =\n \t    fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]),\n \t\t\t gfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]));\n-          loop->to[n] = tmp;\n-          continue;\n-        }\n-        \n+\t  loop->to[n] = tmp;\n+\t  continue;\n+\t}\n+\t\n       /* Store the stride and bound components in the descriptor.  */\n       tmp = gfc_conv_descriptor_stride (desc, gfc_rank_cst[n]);\n       gfc_add_modify (pre, tmp, size);\n@@ -712,8 +761,8 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n       size = NULL_TREE;\n     }\n \n-  gfc_trans_allocate_array_storage (pre, post, info, size, nelem, dynamic,\n-\t\t\t            dealloc);\n+  gfc_trans_allocate_array_storage (pre, post, info, size, nelem, initial,\n+\t\t\t\t    dynamic, dealloc);\n \n   if (info->dimen > loop->temp_dim)\n     loop->temp_dim = info->dimen;\n@@ -1811,7 +1860,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n     }\n \n   gfc_trans_create_temp_array (&loop->pre, &loop->post, loop, &ss->data.info,\n-\t\t\t       type, dynamic, true, false, where);\n+\t\t\t       type, NULL_TREE, dynamic, true, false, where);\n \n   desc = ss->data.info.descriptor;\n   offset = gfc_index_zero_node;\n@@ -3523,8 +3572,8 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n       loop->temp_ss->type = GFC_SS_SECTION;\n       loop->temp_ss->data.info.dimen = n;\n       gfc_trans_create_temp_array (&loop->pre, &loop->post, loop,\n-\t\t\t\t   &loop->temp_ss->data.info, tmp, false, true,\n-\t\t\t\t   false, where);\n+\t\t\t\t   &loop->temp_ss->data.info, tmp, NULL_TREE,\n+\t\t\t\t   false, true, false, where);\n     }\n \n   for (n = 0; n < loop->temp_dim; n++)"}, {"sha": "49818d4fe6d34330aed6e935c38f30d894d8562c", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -32,7 +32,7 @@ void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,\n \n /* Generate code to create a temporary array.  */\n tree gfc_trans_create_temp_array (stmtblock_t *, stmtblock_t *, gfc_loopinfo *,\n-                                  gfc_ss_info *, tree, bool, bool, bool,\n+\t\t\t\t  gfc_ss_info *, tree, tree, bool, bool, bool,\n \t\t\t\t  locus *);\n \n /* Generate function entry code for allocation of compiler allocated array"}, {"sha": "a3265ace7564d3db0eea7b9ae102404b872db4b7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -2863,8 +2863,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t     mustn't be deallocated.  */\n \t  callee_alloc = sym->attr.allocatable || sym->attr.pointer;\n \t  gfc_trans_create_temp_array (&se->pre, &se->post, se->loop, info, tmp,\n-\t\t\t\t       false, !sym->attr.pointer, callee_alloc,\n-\t\t\t\t       &se->ss->expr->where);\n+\t\t\t\t       NULL_TREE, false, !sym->attr.pointer,\n+\t\t\t\t       callee_alloc, &se->ss->expr->where);\n \n \t  /* Pass the temporary as the first argument.  */\n \t  tmp = info->descriptor;\n@@ -4384,7 +4384,7 @@ gfc_trans_zero_assign (gfc_expr * expr)\n /* Helper for gfc_trans_array_copy and gfc_trans_array_constructor_copy\n    that constructs the call to __builtin_memcpy.  */\n \n-static tree\n+tree\n gfc_build_memcpy_call (tree dst, tree src, tree len)\n {\n   tree tmp;"}, {"sha": "acf0b73a760c4b57fc944f6794d62056099f9d4c", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -3787,7 +3787,7 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n      FIXME callee_alloc is not set!  */\n \n   gfc_trans_create_temp_array (&se->pre, &se->post, se->loop,\n-\t\t\t       info, mold_type, false, true, false,\n+\t\t\t       info, mold_type, NULL_TREE, false, true, false,\n \t\t\t       &expr->where);\n \n   /* Cast the pointer to the result.  */"}, {"sha": "343d5359d2823833c43be76a2c063727b7cb5eab", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -251,6 +251,9 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t    && gfc_check_fncall_dependency (e, fsym->attr.intent,\n \t\t\t\t\t    sym, arg0))\n \t{\n+\t  tree initial;\n+\t  stmtblock_t temp_post;\n+\n \t  /* Make a local loopinfo for the temporary creation, so that\n \t     none of the other ss->info's have to be renormalized.  */\n \t  gfc_init_loopinfo (&tmp_loop);\n@@ -261,27 +264,38 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t      tmp_loop.order[n] = loopse->loop->order[n];\n \t    }\n \n+\t  /* Obtain the argument descriptor for unpacking.  */\n+\t  gfc_init_se (&parmse, NULL);\n+\t  parmse.want_pointer = 1;\n+\t  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));\n+\t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n+\n+\t  /* If we've got INTENT(INOUT), initialize the array temporary with\n+\t     a copy of the values.  */\n+\t  if (fsym->attr.intent == INTENT_INOUT)\n+\t    initial = parmse.expr;\n+\t  else\n+\t    initial = NULL_TREE;\n+\n \t  /* Generate the temporary.  Merge the block so that the\n-\t     declarations are put at the right binding level.  */\n+\t     declarations are put at the right binding level.  Cleaning up the\n+\t     temporary should be the very last thing done, so we add the code to\n+\t     a new block and add it to se->post as last instructions.  */\n \t  size = gfc_create_var (gfc_array_index_type, NULL);\n \t  data = gfc_create_var (pvoid_type_node, NULL);\n \t  gfc_start_block (&block);\n+\t  gfc_init_block (&temp_post);\n \t  tmp = gfc_typenode_for_spec (&e->ts);\n-\t  tmp = gfc_trans_create_temp_array (&se->pre, &se->post,\n-\t\t\t\t\t      &tmp_loop, info, tmp,\n-\t\t\t\t\t      false, true, false,\n-\t\t\t\t\t     & arg->expr->where);\n+\t  tmp = gfc_trans_create_temp_array (&se->pre, &temp_post,\n+\t\t\t\t\t     &tmp_loop, info, tmp,\n+\t\t\t\t\t     initial,\n+\t\t\t\t\t     false, true, false,\n+\t\t\t\t\t     &arg->expr->where);\n \t  gfc_add_modify (&se->pre, size, tmp);\n \t  tmp = fold_convert (pvoid_type_node, info->data);\n \t  gfc_add_modify (&se->pre, data, tmp);\n \t  gfc_merge_block_scope (&block);\n \n-\t  /* Obtain the argument descriptor for unpacking.  */\n-\t  gfc_init_se (&parmse, NULL);\n-\t  parmse.want_pointer = 1;\n-\t  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));\n-\t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n-\n \t  /* Calculate the offset for the temporary.  */\n \t  offset = gfc_index_zero_node;\n \t  for (n = 0; n < info->dimen; n++)\n@@ -296,11 +310,16 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t  info->offset = gfc_create_var (gfc_array_index_type, NULL);\t  \n \t  gfc_add_modify (&se->pre, info->offset, offset);\n \n+\n \t  /* Copy the result back using unpack.  */\n \t  tmp = build_call_expr (gfor_fndecl_in_unpack, 2, parmse.expr, data);\n \t  gfc_add_expr_to_block (&se->post, tmp);\n \n+\t  /* XXX: This is possibly not needed; but isn't it cleaner this way? */\n+\t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n+\n \t  gfc_add_block_to_block (&se->post, &parmse.post);\n+\t  gfc_add_block_to_block (&se->post, &temp_post);\n \t}\n     }\n }\n@@ -367,7 +386,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n       gfc_se loopse;\n \n       /* gfc_walk_elemental_function_args renders the ss chain in the\n-         reverse order to the actual argument order.  */\n+\t reverse order to the actual argument order.  */\n       ss = gfc_reverse_ss (ss);\n \n       /* Initialize the loop.  */"}, {"sha": "628c2a08346b86815d593051f5407d782458a78a", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -1102,7 +1102,15 @@ gfc_trans_code (gfc_code * code)\n \t  break;\n \n \tcase EXEC_CALL:\n-\t  res = gfc_trans_call (code, false);\n+\t  /* For MVBITS we've got the special exception that we need a\n+\t     dependency check, too.  */\n+\t  {\n+\t    bool is_mvbits = false;\n+\t    if (code->resolved_isym\n+\t\t&& code->resolved_isym->id == GFC_ISYM_MVBITS)\n+\t      is_mvbits = true;\n+\t    res = gfc_trans_call (code, is_mvbits);\n+\t  }\n \t  break;\n \n \tcase EXEC_ASSIGN_CALL:"}, {"sha": "23d61ea04d912c10a0deeb2af4ed7195bd8e8329", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -464,6 +464,9 @@ tree gfc_call_free (tree);\n /* Allocate memory after performing a few checks.  */\n tree gfc_call_malloc (stmtblock_t *, tree, tree);\n \n+/* Build a memcpy call.  */\n+tree gfc_build_memcpy_call (tree, tree, tree);\n+\n /* Allocate memory for arrays, with optional status variable.  */\n tree gfc_allocate_array_with_status (stmtblock_t*, tree, tree, tree, gfc_expr*);\n "}, {"sha": "bd150932b10d73bd8820c0e8ea0466e05f3d27b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -1,3 +1,8 @@\n+2008-11-01  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/35681\n+\t* gfortran.dg/mvbits_4.f90: New test.\n+\n 2008-11-01  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/36322"}, {"sha": "b8d32140c78bed3dfdcc8c2c439f32c6930f5da5", "filename": "gcc/testsuite/gfortran.dg/mvbits_4.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ftestsuite%2Fgfortran.dg%2Fmvbits_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f681a099e339747f99d5275611ee373096a7a6/gcc%2Ftestsuite%2Fgfortran.dg%2Fmvbits_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmvbits_4.f90?ref=12f681a099e339747f99d5275611ee373096a7a6", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+\n+! PR fortran/35681\n+! Check that dependencies of MVBITS arguments are resolved correctly by using\n+! temporaries if both arguments refer to the same variable.\n+\n+  integer, dimension(10) :: ila1 = (/1,2,3,4,5,6,7,8,9,10/)\n+  integer, dimension(20) :: ila2\n+  integer, dimension(10), target :: ila3\n+  integer, pointer :: ila3_ptr(:)\n+  integer, parameter :: SHOULD_BE(10) = (/17,18,11,4,13,22,7,16,9,18/)\n+  integer, parameter :: INDEX_VECTOR(10) = (/9,9,6,2,4,9,2,9,6,10/)\n+\n+  ila2(2:20:2) = ila1\n+  ila3 = ila1\n+\n+  ! Argument is already packed.\n+  call mvbits (ila1(INDEX_VECTOR), 2, 4, ila1, 3)\n+  write (*,'(10(I3))') ila1\n+  if (any (ila1 /= SHOULD_BE)) call abort ()\n+\n+  ! Argument is not packed.\n+  call mvbits (ila2(2*INDEX_VECTOR), 2, 4, ila2(2:20:2), 3)\n+  write (*,'(10(I3))') ila2(2:20:2)\n+  if (any (ila2(2:20:2) /= SHOULD_BE)) call abort ()\n+\n+  ! Pointer and target\n+  ila3_ptr => ila3\n+  call mvbits (ila3(INDEX_VECTOR), 2, 4, ila3_ptr, 3)\n+  write (*,'(10(I3))') ila3\n+  if (any (ila3 /= SHOULD_BE)) call abort ()\n+\n+  end "}]}