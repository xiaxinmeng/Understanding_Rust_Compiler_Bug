{"sha": "b3f27c1577aba48ad3dc74ebb59587f23506e726", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNmMjdjMTU3N2FiYTQ4YWQzZGM3NGViYjU5NTg3ZjIzNTA2ZTcyNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-03-30T14:35:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-03-30T14:35:03Z"}, "message": "re PR debug/39563 (C block scopes have no DW_TAG_lexical_block)\n\n\tPR debug/39563\n\t* c-decl.c (struct c_binding): Add locus field.\n\t(bind): Add locus argument, set locus field from it.\n\t(pop_scope): For b->nested VAR_DECL or FUNCTION_DECL,\n\tadd a DECL_EXTERNAL copy of b->decl to current BLOCK_VARS.\n\t(push_file_scope, pushtag, pushdecl, pushdecl_top_level,\n\timplicitly_declare, undeclared_variable, lookup_label,\n\tdeclare_label, c_make_fname_decl, c_builtin_function,\n\tc_builtin_function_ext_scope, store_parm_decls_newstyle): Adjust\n\tbind callers.\n\nFrom-SVN: r145293", "tree": {"sha": "fd2dd5a642f24faf2f5a2b44dda8f15f056e3afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd2dd5a642f24faf2f5a2b44dda8f15f056e3afc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3f27c1577aba48ad3dc74ebb59587f23506e726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f27c1577aba48ad3dc74ebb59587f23506e726", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3f27c1577aba48ad3dc74ebb59587f23506e726", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f27c1577aba48ad3dc74ebb59587f23506e726/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "680e8a004a9a664e55fde3239d7c7820290439ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/680e8a004a9a664e55fde3239d7c7820290439ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/680e8a004a9a664e55fde3239d7c7820290439ac"}], "stats": {"total": 92, "additions": 71, "deletions": 21}, "files": [{"sha": "421be6ac670cfb49818ac3425a9664765c1d578b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f27c1577aba48ad3dc74ebb59587f23506e726/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f27c1577aba48ad3dc74ebb59587f23506e726/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3f27c1577aba48ad3dc74ebb59587f23506e726", "patch": "@@ -1,3 +1,16 @@\n+2009-03-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/39563\n+\t* c-decl.c (struct c_binding): Add locus field.\n+\t(bind): Add locus argument, set locus field from it.\n+\t(pop_scope): For b->nested VAR_DECL or FUNCTION_DECL,\n+\tadd a DECL_EXTERNAL copy of b->decl to current BLOCK_VARS.\n+\t(push_file_scope, pushtag, pushdecl, pushdecl_top_level,\n+\timplicitly_declare, undeclared_variable, lookup_label,\n+\tdeclare_label, c_make_fname_decl, c_builtin_function,\n+\tc_builtin_function_ext_scope, store_parm_decls_newstyle): Adjust\n+\tbind callers.\n+\n 2008-03-30  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/38781"}, {"sha": "3c1c2773f206e982bd368fe03cf5f4e4d70c929f", "filename": "gcc/c-decl.c", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f27c1577aba48ad3dc74ebb59587f23506e726/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f27c1577aba48ad3dc74ebb59587f23506e726/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b3f27c1577aba48ad3dc74ebb59587f23506e726", "patch": "@@ -209,6 +209,7 @@ struct c_binding GTY((chain_next (\"%h.prev\")))\n   BOOL_BITFIELD nested : 1;     /* do not set DECL_CONTEXT when popping */\n   BOOL_BITFIELD inner_comp : 1; /* incomplete array completed in inner scope */\n   /* one free bit */\n+  location_t locus;\t\t/* location for nested bindings */\n };\n #define B_IN_SCOPE(b1, b2) ((b1)->depth == (b2)->depth)\n #define B_IN_CURRENT_SCOPE(b) ((b)->depth == current_scope->depth)\n@@ -460,7 +461,8 @@ c_print_identifier (FILE *file, tree node, int indent)\n    which may be any of several kinds of DECL or TYPE or error_mark_node,\n    in the scope SCOPE.  */\n static void\n-bind (tree name, tree decl, struct c_scope *scope, bool invisible, bool nested)\n+bind (tree name, tree decl, struct c_scope *scope, bool invisible,\n+      bool nested, location_t locus)\n {\n   struct c_binding *b, **here;\n \n@@ -479,6 +481,7 @@ bind (tree name, tree decl, struct c_scope *scope, bool invisible, bool nested)\n   b->invisible = invisible;\n   b->nested = nested;\n   b->inner_comp = 0;\n+  b->locus = locus;\n \n   b->type = 0;\n \n@@ -824,6 +827,29 @@ pop_scope (void)\n \t      TREE_CHAIN (p) = BLOCK_VARS (block);\n \t      BLOCK_VARS (block) = p;\n \t    }\n+\t  else if (VAR_OR_FUNCTION_DECL_P (p))\n+\t    {\n+\t      /* For block local externs add a special\n+\t\t DECL_EXTERNAL decl for debug info generation.  */\n+\t      tree extp = copy_node (p);\n+\n+\t      DECL_EXTERNAL (extp) = 1;\n+\t      TREE_STATIC (extp) = 0;\n+\t      TREE_PUBLIC (extp) = 1;\n+\t      DECL_INITIAL (extp) = NULL_TREE;\n+\t      DECL_LANG_SPECIFIC (extp) = NULL;\n+\t      DECL_CONTEXT (extp) = current_function_decl;\n+\t      if (TREE_CODE (p) == FUNCTION_DECL)\n+\t\t{\n+\t\t  DECL_RESULT (extp) = NULL_TREE;\n+\t\t  DECL_SAVED_TREE (extp) = NULL_TREE;\n+\t\t  DECL_STRUCT_FUNCTION (extp) = NULL;\n+\t\t}\n+\t      if (b->locus != UNKNOWN_LOCATION)\n+\t\tDECL_SOURCE_LOCATION (extp) = b->locus;\n+\t      TREE_CHAIN (extp) = BLOCK_VARS (block);\n+\t      BLOCK_VARS (block) = extp;\n+\t    }\n \t  /* If this is the file scope, and we are processing more\n \t     than one translation unit in this compilation, set\n \t     DECL_CONTEXT of each decl to the TRANSLATION_UNIT_DECL.\n@@ -905,7 +931,7 @@ push_file_scope (void)\n \n   for (decl = visible_builtins; decl; decl = TREE_CHAIN (decl))\n     bind (DECL_NAME (decl), decl, file_scope,\n-\t  /*invisible=*/false, /*nested=*/true);\n+\t  /*invisible=*/false, /*nested=*/true, DECL_SOURCE_LOCATION (decl));\n }\n \n void\n@@ -951,7 +977,8 @@ pushtag (tree name, tree type)\n   /* Record the identifier as the type's name if it has none.  */\n   if (name && !TYPE_NAME (type))\n     TYPE_NAME (type) = name;\n-  bind (name, type, current_scope, /*invisible=*/false, /*nested=*/false);\n+  bind (name, type, current_scope, /*invisible=*/false, /*nested=*/false,\n+\tUNKNOWN_LOCATION);\n \n   /* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE will be the\n      tagged type we just added to the current scope.  This fake\n@@ -2051,6 +2078,7 @@ pushdecl (tree x)\n   struct c_scope *scope = current_scope;\n   struct c_binding *b;\n   bool nested = false;\n+  location_t locus = DECL_SOURCE_LOCATION (x);\n \n   /* Must set DECL_CONTEXT for everything not at file scope or\n      DECL_FILE_SCOPE_P won't work.  Local externs don't count\n@@ -2069,7 +2097,8 @@ pushdecl (tree x)\n   /* Anonymous decls are just inserted in the scope.  */\n   if (!name)\n     {\n-      bind (name, x, scope, /*invisible=*/false, /*nested=*/false);\n+      bind (name, x, scope, /*invisible=*/false, /*nested=*/false,\n+\t    locus);\n       return x;\n     }\n \n@@ -2229,7 +2258,8 @@ pushdecl (tree x)\n \t      = build_type_attribute_variant (thistype,\n \t\t\t\t\t      TYPE_ATTRIBUTES (b->type));\n \t  TREE_TYPE (b->decl) = thistype;\n-\t  bind (name, b->decl, scope, /*invisible=*/false, /*nested=*/true);\n+\t  bind (name, b->decl, scope, /*invisible=*/false, /*nested=*/true,\n+\t\tlocus);\n \t  return b->decl;\n \t}\n       else if (TREE_PUBLIC (x))\n@@ -2247,7 +2277,7 @@ pushdecl (tree x)\n \t  else\n \t    {\n \t      bind (name, x, external_scope, /*invisible=*/true,\n-\t\t    /*nested=*/false);\n+\t\t    /*nested=*/false, locus);\n \t      nested = true;\n \t    }\n \t}\n@@ -2260,7 +2290,7 @@ pushdecl (tree x)\n   if (TREE_CODE (x) == TYPE_DECL)\n     clone_underlying_type (x);\n \n-  bind (name, x, scope, /*invisible=*/false, nested);\n+  bind (name, x, scope, /*invisible=*/false, nested, locus);\n \n   /* If x's type is incomplete because it's based on a\n      structure or union which has not yet been fully declared,\n@@ -2309,11 +2339,12 @@ pushdecl_top_level (tree x)\n \n   if (TREE_PUBLIC (x))\n     {\n-      bind (name, x, external_scope, /*invisible=*/true, /*nested=*/false);\n+      bind (name, x, external_scope, /*invisible=*/true, /*nested=*/false,\n+\t    UNKNOWN_LOCATION);\n       nested = true;\n     }\n   if (file_scope)\n-    bind (name, x, file_scope, /*invisible=*/false, nested);\n+    bind (name, x, file_scope, /*invisible=*/false, nested, UNKNOWN_LOCATION);\n \n   return x;\n }\n@@ -2368,7 +2399,8 @@ implicitly_declare (tree functionid)\n       if (!DECL_BUILT_IN (decl) && DECL_IS_BUILTIN (decl))\n \t{\n \t  bind (functionid, decl, file_scope,\n-\t\t/*invisible=*/false, /*nested=*/true);\n+\t\t/*invisible=*/false, /*nested=*/true,\n+\t\tDECL_SOURCE_LOCATION (decl));\n \t  return decl;\n \t}\n       else\n@@ -2409,7 +2441,8 @@ implicitly_declare (tree functionid)\n \t  b->type = TREE_TYPE (decl);\n \t  TREE_TYPE (decl) = newtype;\n \t  bind (functionid, decl, current_scope,\n-\t\t/*invisible=*/false, /*nested=*/true);\n+\t\t/*invisible=*/false, /*nested=*/true,\n+\t\tDECL_SOURCE_LOCATION (decl));\n \t  return decl;\n \t}\n     }\n@@ -2472,7 +2505,8 @@ undeclared_variable (tree id, location_t loc)\n \t will be nonnull but current_function_scope will be null.  */\n       scope = current_function_scope ? current_function_scope : current_scope;\n     }\n-  bind (id, error_mark_node, scope, /*invisible=*/false, /*nested=*/false);\n+  bind (id, error_mark_node, scope, /*invisible=*/false, /*nested=*/false,\n+\tUNKNOWN_LOCATION);\n }\n \f\n /* Subroutine of lookup_label, declare_label, define_label: construct a\n@@ -2526,7 +2560,7 @@ lookup_label (tree name)\n \n   /* Ordinary labels go in the current function scope.  */\n   bind (name, label, current_function_scope,\n-\t/*invisible=*/false, /*nested=*/false);\n+\t/*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n   return label;\n }\n \n@@ -2556,7 +2590,7 @@ declare_label (tree name)\n \n   /* Declared labels go in the current scope.  */\n   bind (name, label, current_scope,\n-\t/*invisible=*/false, /*nested=*/false);\n+\t/*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n   return label;\n }\n \n@@ -2603,7 +2637,7 @@ define_label (location_t location, tree name)\n \n       /* Ordinary labels go in the current function scope.  */\n       bind (name, label, current_function_scope,\n-\t    /*invisible=*/false, /*nested=*/false);\n+\t    /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n     }\n \n   if (!in_system_header && lookup_name (name))\n@@ -2806,7 +2840,7 @@ c_make_fname_decl (tree id, int type_dep)\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       bind (id, decl, current_function_scope,\n-\t    /*invisible=*/false, /*nested=*/false);\n+\t    /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n     }\n \n   finish_decl (decl, init, NULL_TREE);\n@@ -2826,7 +2860,8 @@ c_builtin_function (tree decl)\n   /* Should never be called on a symbol with a preexisting meaning.  */\n   gcc_assert (!I_SYMBOL_BINDING (id));\n \n-  bind (id, decl, external_scope, /*invisible=*/true, /*nested=*/false);\n+  bind (id, decl, external_scope, /*invisible=*/true, /*nested=*/false,\n+\tUNKNOWN_LOCATION);\n \n   /* Builtins in the implementation namespace are made visible without\n      needing to be explicitly declared.  See push_file_scope.  */\n@@ -2851,7 +2886,8 @@ c_builtin_function_ext_scope (tree decl)\n   /* Should never be called on a symbol with a preexisting meaning.  */\n   gcc_assert (!I_SYMBOL_BINDING (id));\n \n-  bind (id, decl, external_scope, /*invisible=*/false, /*nested=*/false);\n+  bind (id, decl, external_scope, /*invisible=*/false, /*nested=*/false,\n+\tUNKNOWN_LOCATION);\n \n   /* Builtins in the implementation namespace are made visible without\n      needing to be explicitly declared.  See push_file_scope.  */\n@@ -6412,7 +6448,8 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n       if (DECL_NAME (decl))\n \t{\n \t  bind (DECL_NAME (decl), decl, current_scope,\n-\t\t/*invisible=*/false, /*nested=*/false);\n+\t\t/*invisible=*/false, /*nested=*/false,\n+\t\tUNKNOWN_LOCATION);\n \t  if (!TREE_USED (decl))\n \t    warn_if_shadowing (decl);\n \t}\n@@ -6429,14 +6466,14 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl))\n \tbind (DECL_NAME (decl), decl, current_scope,\n-\t      /*invisible=*/false, /*nested=*/false);\n+\t      /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n     }\n \n   /* And all the tag declarations.  */\n   for (decl = arg_info->tags; decl; decl = TREE_CHAIN (decl))\n     if (TREE_PURPOSE (decl))\n       bind (TREE_PURPOSE (decl), TREE_VALUE (decl), current_scope,\n-\t    /*invisible=*/false, /*nested=*/false);\n+\t    /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n }\n \n /* Subroutine of store_parm_decls which handles old-style function"}]}