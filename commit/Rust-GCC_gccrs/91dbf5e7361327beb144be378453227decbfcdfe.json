{"sha": "91dbf5e7361327beb144be378453227decbfcdfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFkYmY1ZTczNjEzMjdiZWIxNDRiZTM3ODQ1MzIyN2RlY2JmY2RmZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-21T11:42:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-21T11:42:06Z"}, "message": "(rescan): Add support for %: and %:%: digraphs.\n\n(collect_expansion, skip_if_group, dump_single_macro): Likewise.\n(union hashval): Remove ival member; it doesn't suffice for `199409L'.\n(special_symbol): Use cpval instead of ival for T_CONST macros.\n(install): Remove ivalue argument, since string value now suffices.\nAll callers changed.\n(initialize_builtins): Switch from int to string values for T_CONST.\nIf not traditional, initialize __STDC_VERSION__ to 199409L.\n(STDC_VALUE): Remove no-longer-used configuration macro.\n\nFrom-SVN: r8983", "tree": {"sha": "4027dc59b8d8782167f828a51ac8f57febacbe3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4027dc59b8d8782167f828a51ac8f57febacbe3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91dbf5e7361327beb144be378453227decbfcdfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91dbf5e7361327beb144be378453227decbfcdfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91dbf5e7361327beb144be378453227decbfcdfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91dbf5e7361327beb144be378453227decbfcdfe/comments", "author": null, "committer": null, "parents": [{"sha": "1f746936683604f4094bf85eabf81d802ae9dedf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f746936683604f4094bf85eabf81d802ae9dedf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f746936683604f4094bf85eabf81d802ae9dedf"}], "stats": {"total": 178, "additions": 126, "deletions": 52}, "files": [{"sha": "21768745d7184e60e02fab657ad0baa756023e1f", "filename": "gcc/cccp.c", "status": "modified", "additions": 126, "deletions": 52, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91dbf5e7361327beb144be378453227decbfcdfe/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91dbf5e7361327beb144be378453227decbfcdfe/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=91dbf5e7361327beb144be378453227decbfcdfe", "patch": "@@ -57,10 +57,6 @@ typedef unsigned char U_CHAR;\n \n #include \"pcp.h\"\n \n-#ifndef STDC_VALUE\n-#define STDC_VALUE 1\n-#endif\n-\n /* By default, colon separates directories in a path.  */\n #ifndef PATH_SEPARATOR\n #define PATH_SEPARATOR ':'\n@@ -714,10 +710,14 @@ struct definition {\n   char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n   struct reflist {\n     struct reflist *next;\n+\n+    /* The following three members have the value '#' if spelled with \"#\",\n+       and '%' if spelled with \"%:\".  */\n     char stringify;\t\t/* nonzero if this arg was preceded by a\n \t\t\t\t   # operator. */\n     char raw_before;\t\t/* Nonzero if a ## operator before arg. */\n     char raw_after;\t\t/* Nonzero if a ## operator after arg. */\n+\n     char rest_args;\t\t/* Nonzero if this arg. absorbs the rest */\n     int nchars;\t\t\t/* Number of literal chars to copy before\n \t\t\t\t   this arg occurrence.  */\n@@ -735,7 +735,6 @@ struct definition {\n /* different kinds of things that can appear in the value field\n    of a hash node.  Actually, this may be useless now. */\n union hashval {\n-  int ival;\n   char *cpval;\n   DEFINITION *defn;\n   KEYDEF *keydef;\n@@ -955,7 +954,7 @@ static struct directive directive_table[] = {\n };\n \n /* When a directive handler is called,\n-   this points to the # that started the directive.  */\n+   this points to the # (or the : of the %:) that started the directive.  */\n U_CHAR *directive_start;\n \n /* table to tell if char can be part of a C identifier. */\n@@ -2581,9 +2580,24 @@ do { ip = &instack[indepth];\t\t\\\n \t*obp++ = *ibp++;\n       break;\n \n+    case '%':\n+      if (ident_length || ip->macro || traditional)\n+\tgoto randomchar;\n+      if (ip->fname == 0 && beg_of_line == ip->buf)\n+\tgoto randomchar;\n+      while (*ibp == '\\\\' && ibp[1] == '\\n') {\n+\tibp += 2;\n+\t++ip->lineno;\n+      }\n+      if (*ibp != ':')\n+\tbreak;\n+      /* Treat this %: digraph as if it were #.  */\n+      /* Fall through.  */\n+\n     case '#':\n       if (assertions_flag) {\n \t/* Copy #foo (bar lose) without macro expansion.  */\n+\tobp[-1] = '#';\t/* In case it was '%'. */\n \tSKIP_WHITE_SPACE (ibp);\n \twhile (is_idchar[*ibp])\n \t  *obp++ = *ibp++;\n@@ -2621,7 +2635,7 @@ do { ip = &instack[indepth];\t\t\\\n \t   If not, this # is not special.  */\n \tbp = beg_of_line;\n \t/* If -traditional, require # to be at beginning of line.  */\n-\tif (!traditional)\n+\tif (!traditional) {\n \t  while (1) {\n \t    if (is_hor_space[*bp])\n \t      bp++;\n@@ -2638,6 +2652,18 @@ do { ip = &instack[indepth];\t\t\\\n \t       comment and we would never reach here.  */\n \t    else break;\n \t  }\n+\t  if (c == '%') {\n+\t    if (bp[0] != '%')\n+\t      break;\n+\t    while (bp[1] == '\\\\' && bp[2] == '\\n')\n+\t      bp += 2;\n+\t    if (bp + 1 != ibp)\n+\t      break;\n+\t    /* %: appears at start of line; skip past the ':' too.  */\n+\t    bp++;\n+\t    ibp++;\n+\t  }\n+\t}\n \tif (bp + 1 != ibp)\n \t  goto randomchar;\n       }\n@@ -2663,7 +2689,7 @@ do { ip = &instack[indepth];\t\t\\\n \t  beg_of_line = ibp;\n \t  break;\n \t}\n-\t++obp;\t\t/* Copy the '#' after all */\n+\t*obp++ = '#';\t/* Copy # (even if it was originally %:).  */\n \t/* Don't expand an identifier that could be a macro directive.\n \t   (Section 3.8.3 of the ANSI C standard)\t\t\t*/\n \tSKIP_WHITE_SPACE (ibp);\n@@ -3295,7 +3321,8 @@ do { ip = &instack[indepth];\t\t\\\n \t\t before the macro call.  */\n \t      if (!traditional && obp != op->buf) {\n \t\tswitch (obp[-1]) {\n-\t\tcase '&': case '+': case '-': case '<': case '>': case '|':\n+\t\tcase '%':  case '&':  case '+':  case '-':\n+\t\tcase ':':  case '<':  case '>':  case '|':\n \t\t  /* If we are expanding a macro arg, make a newline marker\n \t\t     to separate the tokens.  If we are making real output,\n \t\t     a plain space will do.  */\n@@ -3956,11 +3983,10 @@ special_symbol (hp, op)\n     break;\n \n   case T_CONST:\n-    buf = (char *) alloca (4 * sizeof (int));\n-    sprintf (buf, \"%d\", hp->value.ival);\n+    buf = hp->value.cpval;\n     if (pcp_inside_if && pcp_outfile)\n       /* Output a precondition for this macro use */\n-      fprintf (pcp_outfile, \"#define %s %d\\n\", hp->name, hp->value.ival);\n+      fprintf (pcp_outfile, \"#define %s %s\\n\", hp->name, buf);\n     break;\n \n   case T_SPECLINE:\n@@ -5221,7 +5247,7 @@ pcfinclude (buf, limit, name, op)\n \thp = lookup (tmpbuf.bufp, -1, -1);\n \tif (hp == NULL) {\n \t  kp->chain = 0;\n-\t  install (tmpbuf.bufp, -1, T_PCSTRING, 0, (char *) kp, -1);\n+\t  install (tmpbuf.bufp, -1, T_PCSTRING, (char *) kp, -1);\n \t}\n \telse if (hp->type == T_PCSTRING) {\n \t  kp->chain = hp->value.keydef;\n@@ -5586,7 +5612,7 @@ do_define (buf, limit, op, keyword)\n \t that for this new definition now.  */\n       if (debug_output && op)\n \tpass_thru_directive (buf, limit, op, keyword);\n-      install (mdef.symnam, mdef.symlen, T_MACRO, 0,\n+      install (mdef.symnam, mdef.symlen, T_MACRO,\n \t       (char *) mdef.defn, hashcode);\n     }\n   }\n@@ -5735,6 +5761,9 @@ collect_expansion (buf, end, nargs, arglist)\n   U_CHAR *concat = 0;\n   /* Pointer to first nonspace after last single-# seen.  */\n   U_CHAR *stringify = 0;\n+  /* How those tokens were spelled: 0, '#', or '%' (meaning %:).  */\n+  char concat_spelling = 0;\n+  char stringify_spelling = 0;\n   int maxsize;\n   int expected_delimiter = '\\0';\n \n@@ -5775,9 +5804,11 @@ collect_expansion (buf, end, nargs, arglist)\n     *exp_p++ = *p++;\n   }\n \n-  if (limit - p >= 2 && p[0] == '#' && p[1] == '#') {\n+  if (p[0] == '#'\n+      ? p[1] == '#'\n+      : p[0] == '%' && p[1] == ':' && p[2] == '%' && p[3] == ':') {\n     error (\"`##' at start of macro definition\");\n-    p += 2;\n+    p += p[0] == '#' ? 2 : 4;\n   }\n \n   /* Process the main body of the definition.  */\n@@ -5806,11 +5837,32 @@ collect_expansion (buf, end, nargs, arglist)\n \t}\n \tbreak;\n \n+      case '%':\n+\tif (!expected_delimiter && *p == ':') {\n+\t  /* %: is not a digraph if preceded by an odd number of '<'s.  */\n+\t  U_CHAR *p0 = p - 1;\n+\t  while (buf < p0 && p0[-1] == '<')\n+\t    p0--;\n+\t  if ((p - p0) & 1) {\n+\t    /* Treat %:%: as ## and %: as #.  */\n+\t    if (p[1] == '%' && p[2] == ':') {\n+\t      p += 2;\n+\t      goto hash_hash_token;\n+\t    }\n+\t    if (nargs >= 0) {\n+\t      p++;\n+\t      goto hash_token;\n+\t    }\n+\t  }\n+\t}\n+\tbreak;\n+\n       case '#':\n \t/* # is ordinary inside a string.  */\n \tif (expected_delimiter)\n \t  break;\n-\tif (p < limit && *p == '#') {\n+\tif (*p == '#') {\n+\thash_hash_token:\n \t  /* ##: concatenate preceding and following tokens.  */\n \t  /* Take out the first #, discard preceding whitespace.  */\n \t  exp_p--;\n@@ -5821,17 +5873,21 @@ collect_expansion (buf, end, nargs, arglist)\n \t  /* Discard following whitespace.  */\n \t  SKIP_WHITE_SPACE (p);\n \t  concat = p;\n+\t  concat_spelling = c;\n \t  if (p == limit)\n \t    error (\"`##' at end of macro definition\");\n \t} else if (nargs >= 0) {\n \t  /* Single #: stringify following argument ref.\n \t     Don't leave the # in the expansion.  */\n+\thash_token:\n \t  exp_p--;\n \t  SKIP_WHITE_SPACE (p);\n-\t  if (p == limit || ! is_idstart[*p] || nargs == 0)\n+\t  if (! is_idstart[*p] || nargs == 0)\n \t    error (\"`#' operator is not followed by a macro argument name\");\n-\t  else\n+\t  else {\n \t    stringify = p;\n+\t    stringify_spelling = c;\n+\t  }\n \t}\n \tbreak;\n       }\n@@ -5913,11 +5969,11 @@ collect_expansion (buf, end, nargs, arglist)\n \t       the pat list */\n \t    tpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n \t    tpat->next = NULL;\n-\t    tpat->raw_before = concat == id_beg;\n+\t    tpat->raw_before = concat == id_beg ? concat_spelling : 0;\n \t    tpat->raw_after = 0;\n \t    tpat->rest_args = arg->rest_args;\n \t    tpat->stringify = (traditional ? expected_delimiter != '\\0'\n-\t\t\t       : stringify == id_beg);\n+\t\t\t       : stringify == id_beg) ? stringify_spelling : 0;\n \n \t    if (endpat == NULL)\n \t      defn->pattern = tpat;\n@@ -5930,8 +5986,10 @@ collect_expansion (buf, end, nargs, arglist)\n \t    {\n \t      register U_CHAR *p1 = p;\n \t      SKIP_WHITE_SPACE (p1);\n-\t      if (p1 + 2 <= limit && p1[0] == '#' && p1[1] == '#')\n-\t\ttpat->raw_after = 1;\n+\t      if (p1[0]=='#'\n+\t          ? p1[1]=='#'\n+\t\t  : p1[0]=='%' && p1[1]==':' && p1[2]=='%' && p1[3]==':')\n+\t\ttpat->raw_after = p1[0];\n \t    }\n \t    lastp = exp_p;\t/* place to start copying from next time */\n \t    skipped_arg = 1;\n@@ -6841,7 +6899,7 @@ eval_if_expression (buf, length)\n   HASHNODE *save_defined;\n   HOST_WIDE_INT value;\n \n-  save_defined = install (\"defined\", -1, T_SPEC_DEFINED, 0, NULL_PTR, -1);\n+  save_defined = install (\"defined\", -1, T_SPEC_DEFINED, NULL_PTR, -1);\n   pcp_inside_if = 1;\n   temp_obuf = expand_to_temp_buffer (buf, buf + length, 0, 1);\n   pcp_inside_if = 0;\n@@ -7044,18 +7102,27 @@ skip_if_group (ip, any, op)\n       ++ip->lineno;\n       beg_of_line = bp;\n       break;\n-    case '#':\n+    case '%':\n+      if (beg_of_line == 0 || traditional)\n+\tbreak;\n       ip->bufp = bp - 1;\n-\n+      while (bp[0] == '\\\\' && bp[1] == '\\n')\n+\tbp += 2;\n+      if (*bp == ':')\n+\tgoto hash_token;\n+      break;\n+    case '#':\n       /* # keyword: a # must be first nonblank char on the line */\n       if (beg_of_line == 0)\n \tbreak;\n+      ip->bufp = bp - 1;\n+    hash_token:\n       /* Scan from start of line, skipping whitespace, comments\n \t and backslash-newlines, and see if we reach this #.\n \t If not, this # is not special.  */\n       bp = beg_of_line;\n       /* If -traditional, require # to be at beginning of line.  */\n-      if (!traditional)\n+      if (!traditional) {\n \twhile (1) {\n \t  if (is_hor_space[*bp])\n \t    bp++;\n@@ -7072,12 +7139,21 @@ skip_if_group (ip, any, op)\n \t     comment and we would never reach here.  */\n \t  else break;\n \t}\n+      }\n       if (bp != ip->bufp) {\n \tbp = ip->bufp + 1;\t/* Reset bp to after the #.  */\n \tbreak;\n       }\n \n       bp = ip->bufp + 1;\t/* Point after the '#' */\n+      if (ip->bufp[0] == '%') {\n+\t/* Skip past the ':' again.  */\n+\twhile (*bp == '\\\\') {\n+\t  ip->lineno++;\n+\t  bp += 2;\n+\t}\n+\tbp++;\n+      }\n \n       /* Skip whitespace and \\-newline.  */\n       while (1) {\n@@ -8902,11 +8978,10 @@ grow_outbuf (obuf, needed)\n  * Otherwise, compute the hash code.\n  */\n static HASHNODE *\n-install (name, len, type, ivalue, value, hash)\n+install (name, len, type, value, hash)\n      U_CHAR *name;\n      int len;\n      enum node_type type;\n-     int ivalue;\n      char *value;\n      int hash;\n {\n@@ -8935,10 +9010,7 @@ install (name, len, type, ivalue, value, hash)\n     hp->next->prev = hp;\n   hp->type = type;\n   hp->length = len;\n-  if (hp->type == T_CONST)\n-    hp->value.ival = ivalue;\n-  else\n-    hp->value.cpval = value;\n+  hp->value.cpval = value;\n   hp->name = ((U_CHAR *) hp) + sizeof (HASHNODE);\n   p = hp->name;\n   q = name;\n@@ -9086,14 +9158,14 @@ dump_single_macro (hp, of)\n       if (ap->nchars != 0)\n \tconcat = 0;\n       if (ap->stringify)\n-\tfprintf (of, \" #\");\n+\tfprintf (of, ap->stringify == '#' ? \" #\" : \" %:\");\n       if (ap->raw_before && !concat)\n-\tfprintf (of, \" ## \");\n+\tfprintf (of, ap->raw_before == '#' ? \" ## \" : \" %:%: \");\n       concat = 0;\n     }\n     dump_arg_n (defn, ap->argno, of);\n     if (!traditional && ap->raw_after) {\n-      fprintf (of, \" ## \");\n+      fprintf (of, ap->raw_after == '#' ? \" ## \" : \" %:%: \");\n       concat = 1;\n     }\n   }\n@@ -9227,29 +9299,31 @@ initialize_builtins (inp, outp)\n      FILE_BUF *inp;\n      FILE_BUF *outp;\n {\n-  install (\"__LINE__\", -1, T_SPECLINE, 0, NULL_PTR, -1);\n-  install (\"__DATE__\", -1, T_DATE, 0, NULL_PTR, -1);\n-  install (\"__FILE__\", -1, T_FILE, 0, NULL_PTR, -1);\n-  install (\"__BASE_FILE__\", -1, T_BASE_FILE, 0, NULL_PTR, -1);\n-  install (\"__INCLUDE_LEVEL__\", -1, T_INCLUDE_LEVEL, 0, NULL_PTR, -1);\n-  install (\"__VERSION__\", -1, T_VERSION, 0, NULL_PTR, -1);\n+  install (\"__LINE__\", -1, T_SPECLINE, NULL_PTR, -1);\n+  install (\"__DATE__\", -1, T_DATE, NULL_PTR, -1);\n+  install (\"__FILE__\", -1, T_FILE, NULL_PTR, -1);\n+  install (\"__BASE_FILE__\", -1, T_BASE_FILE, NULL_PTR, -1);\n+  install (\"__INCLUDE_LEVEL__\", -1, T_INCLUDE_LEVEL, NULL_PTR, -1);\n+  install (\"__VERSION__\", -1, T_VERSION, NULL_PTR, -1);\n #ifndef NO_BUILTIN_SIZE_TYPE\n-  install (\"__SIZE_TYPE__\", -1, T_SIZE_TYPE, 0, NULL_PTR, -1);\n+  install (\"__SIZE_TYPE__\", -1, T_SIZE_TYPE, NULL_PTR, -1);\n #endif\n #ifndef NO_BUILTIN_PTRDIFF_TYPE\n-  install (\"__PTRDIFF_TYPE__ \", -1, T_PTRDIFF_TYPE, 0, NULL_PTR, -1);\n+  install (\"__PTRDIFF_TYPE__ \", -1, T_PTRDIFF_TYPE, NULL_PTR, -1);\n #endif\n-  install (\"__WCHAR_TYPE__\", -1, T_WCHAR_TYPE, 0, NULL_PTR, -1);\n-  install (\"__USER_LABEL_PREFIX__\",-1,T_USER_LABEL_PREFIX_TYPE,0,NULL_PTR, -1);\n-  install (\"__REGISTER_PREFIX__\", -1, T_REGISTER_PREFIX_TYPE, 0, NULL_PTR, -1);\n-  install (\"__TIME__\", -1, T_TIME, 0, NULL_PTR, -1);\n-  if (!traditional)\n-    install (\"__STDC__\", -1, T_CONST, STDC_VALUE, NULL_PTR, -1);\n+  install (\"__WCHAR_TYPE__\", -1, T_WCHAR_TYPE, NULL_PTR, -1);\n+  install (\"__USER_LABEL_PREFIX__\",-1,T_USER_LABEL_PREFIX_TYPE, NULL_PTR, -1);\n+  install (\"__REGISTER_PREFIX__\", -1, T_REGISTER_PREFIX_TYPE, NULL_PTR, -1);\n+  install (\"__TIME__\", -1, T_TIME, NULL_PTR, -1);\n+  if (!traditional) {\n+    install (\"__STDC__\", -1, T_CONST, \"1\", -1);\n+    install (\"__STDC_VERSION__\", -1, T_CONST, \"199409L\", -1);\n+  }\n   if (objc)\n-    install (\"__OBJC__\", -1, T_CONST, 1, NULL_PTR, -1);\n+    install (\"__OBJC__\", -1, T_CONST, \"1\", -1);\n /*  This is supplied using a -D by the compiler driver\n     so that it is present only when truly compiling with GNU C.  */\n-/*  install (\"__GNUC__\", -1, T_CONST, 2, NULL_PTR, -1);  */\n+/*  install (\"__GNUC__\", -1, T_CONST, \"2\", -1);  */\n \n   if (debug_output)\n     {"}]}