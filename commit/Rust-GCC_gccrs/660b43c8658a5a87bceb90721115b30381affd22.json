{"sha": "660b43c8658a5a87bceb90721115b30381affd22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYwYjQzYzg2NThhNWE4N2JjZWI5MDcyMTExNWIzMDM4MWFmZmQyMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T22:28:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T22:28:47Z"}, "message": "Rewrite attribute parsing; update the expected conflicts and state\nnumbers.\n\nFrom-SVN: r7252", "tree": {"sha": "91ae017d3b91c8e68b9060dee60f7e5c9b26cfba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91ae017d3b91c8e68b9060dee60f7e5c9b26cfba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/660b43c8658a5a87bceb90721115b30381affd22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660b43c8658a5a87bceb90721115b30381affd22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/660b43c8658a5a87bceb90721115b30381affd22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660b43c8658a5a87bceb90721115b30381affd22/comments", "author": null, "committer": null, "parents": [{"sha": "bad1b4ba2000218c46e7a4ae1b8b2caf57d8eb68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad1b4ba2000218c46e7a4ae1b8b2caf57d8eb68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad1b4ba2000218c46e7a4ae1b8b2caf57d8eb68"}], "stats": {"total": 126, "additions": 60, "deletions": 66}, "files": [{"sha": "fc91e1a43a6abf84faddb646347aa5fa5ba55c47", "filename": "gcc/c-parse.in", "status": "modified", "additions": 60, "deletions": 66, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660b43c8658a5a87bceb90721115b30381affd22/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660b43c8658a5a87bceb90721115b30381affd22/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=660b43c8658a5a87bceb90721115b30381affd22", "patch": "@@ -27,22 +27,23 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n written by AT&T, but I have never seen it.  */\n \n ifobjc\n-%expect 20\n+%expect 22\n end ifobjc\n ifc\n-%expect 8\n+%expect 10\n \n-/* These are the 8 conflicts you should get in parse.output;\n+/* These are the 10 conflicts you should get in parse.output;\n    the state numbers may vary if minor changes in the grammar are made.\n \n State 41 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n-State 92 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n-State 99 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n-State 103 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n-State 119 contains 1 shift/reduce conflict.  (See comment at component_decl.)\n-State 183 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n-State 193 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n-State 199 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 97 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 104 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 108 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 124 contains 1 shift/reduce conflict.  (See comment at component_decl.)\n+State 191 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 204 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 210 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 449 contains 2 shift/reduce conflicts.  (Four ways to parse this.)\n */\n end ifc\n \n@@ -178,7 +179,8 @@ void yyerror ();\n %type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n %type <ttype> init maybeasm\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n-%type <ttype> maybe_attribute attribute_list attrib\n+%type <ttype> maybe_attribute attributes attribute attribute_list attrib\n+%type <ttype> any_word\n \n %type <ttype> compstmt\n \n@@ -1048,63 +1050,55 @@ notype_initdcl:\n /* the * rules are dummies to accept the Apollo extended syntax\n    so that the header files compile. */\n maybe_attribute:\n+      /* empty */\n+  \t\t{ $$ = NULL_TREE; }\n+\t| attributes\n+\t\t{ $$ = $1; }\n+\t;\n+ \n+attributes:\n+      attribute\n+\t\t{ $$ = $1; }\n+\t| attributes attribute\n+\t\t{ $$ = chainon ($1, $2); }\n+\t;\n+\n+attribute:\n+      ATTRIBUTE '(' '(' attribute_list ')' ')'\n+\t\t{ $$ = $4; }\n+\t;\n+\n+attribute_list:\n+      attrib\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| attribute_list ',' attrib\n+\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n+\t;\n+ \n+attrib:\n     /* empty */\n \t\t{ $$ = NULL_TREE; }\n-    | maybe_attribute ATTRIBUTE '(' '(' attribute_list ')' ')'\n-\t\t{ $$ = chainon ($5, $1); }\n-    ;\n-\n-attribute_list\n-    : attrib\n-\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-    | attribute_list ',' attrib\n-\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n-    ;\n-\n-attrib\n-    : identifier\n-\t{ if (strcmp (IDENTIFIER_POINTER ($1), \"packed\")\n-\t      && strcmp (IDENTIFIER_POINTER ($1), \"noreturn\"))\n-\t    warning (\"`%s' attribute directive ignored\",\n-\t\t     IDENTIFIER_POINTER ($1));\n-\t  $$ = $1; }\n-    | TYPE_QUAL\n-    | identifier '(' expr_no_commas ')'\n-\t{ /* If not aligned(n) or section(name), then issue warning */\n-\t  if (strcmp (IDENTIFIER_POINTER ($1), \"section\") == 0\n-\t      || strcmp (IDENTIFIER_POINTER ($1), \"mode\") == 0)\n-\t    {\n-\t      if (TREE_CODE ($3) != STRING_CST)\n-\t\t{\n-\t\t  error (\"invalid argument in `%s' attribute\",\n-\t\t\t IDENTIFIER_POINTER ($1));\n-\t\t  $$ = $1;\n-\t\t}\n-\t      $$ = tree_cons ($1, $3, NULL_TREE);\n-\t    }\n-\t  else if (strcmp (IDENTIFIER_POINTER ($1), \"aligned\") != 0)\n-\t    {\n-\t      warning (\"`%s' attribute directive ignored\",\n-\t\t       IDENTIFIER_POINTER ($1));\n-\t      $$ = $1;\n-\t    }\n-\t  else\n-\t    $$ = tree_cons ($1, $3, NULL_TREE); }\n-    | identifier '(' IDENTIFIER ',' expr_no_commas ',' expr_no_commas ')'\n-\t{ /* if not \"format(...)\", then issue warning */\n-\t  if (strcmp (IDENTIFIER_POINTER ($1), \"format\") != 0)\n-\t    {\n-\t      warning (\"`%s' attribute directive ignored\",\n-\t\t       IDENTIFIER_POINTER ($1));\n-\t      $$ = $1;\n-\t    }\n-\t  else\n-\t    $$ = tree_cons ($1,\n-\t\t\t    tree_cons ($3,\n-\t\t\t\t       tree_cons ($5, $7, NULL_TREE),\n-\t\t\t\t       NULL_TREE),\n-\t\t\t    NULL_TREE); }\n-    ;\n+\t| any_word\n+\t\t{ $$ = $1; }\n+\t| any_word '(' IDENTIFIER ')'\n+\t\t{ $$ = tree_cons ($1, NULL_TREE,\n+\t\t\t\t  build_tree_list (NULL_TREE, $3)); }\n+\t| any_word '(' IDENTIFIER ',' nonnull_exprlist ')'\n+\t\t{ $$ = tree_cons ($1, NULL_TREE,\n+\t\t\t\t  tree_cons (NULL_TREE, $3, $5)); }\n+\t| any_word '(' nonnull_exprlist ')'\n+\t\t{ $$ = tree_cons ($1, NULL_TREE, $3); }\n+\t;\n+\n+/* This still leaves out most reserved keywords,\n+   shouldn't we include them?  */\n+\n+any_word:\n+\t  identifier\n+\t| SCSPEC\n+\t| TYPESPEC\n+\t| TYPE_QUAL\n+\t;\n \f\n /* Initializers.  `init' is the entry point.  */\n "}]}