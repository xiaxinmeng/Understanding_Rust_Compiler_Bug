{"sha": "0fa43fb73b386b98e9c92d85905633f81d0c326e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZhNDNmYjczYjM4NmI5OGU5YzkyZDg1OTA1NjMzZjgxZDBjMzI2ZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-06-04T16:42:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-06-04T16:42:27Z"}, "message": "re PR debug/41371 (var-tracking is slow and memory hungry)\n\n\tPR debug/41371\n\t* var-tracking.c (find_loc_in_1pdv): Mark initial value before\n\trecursing.  Check that recursion is bounded.  Rename inner var\n\tto avoid hiding incoming argument.\n\nFrom-SVN: r160280", "tree": {"sha": "3e74a3daa7d1c8a42ea5a8a20c52da3c2f15e740", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e74a3daa7d1c8a42ea5a8a20c52da3c2f15e740"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fa43fb73b386b98e9c92d85905633f81d0c326e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa43fb73b386b98e9c92d85905633f81d0c326e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fa43fb73b386b98e9c92d85905633f81d0c326e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa43fb73b386b98e9c92d85905633f81d0c326e/comments", "author": null, "committer": null, "parents": [{"sha": "ad1f7916e754694a877cb6d701112e2d9ec6643c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad1f7916e754694a877cb6d701112e2d9ec6643c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad1f7916e754694a877cb6d701112e2d9ec6643c"}], "stats": {"total": 87, "additions": 77, "deletions": 10}, "files": [{"sha": "fcf8e965f99472b211d7ac1ded9a4914b0f6c015", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa43fb73b386b98e9c92d85905633f81d0c326e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa43fb73b386b98e9c92d85905633f81d0c326e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fa43fb73b386b98e9c92d85905633f81d0c326e", "patch": "@@ -1,3 +1,10 @@\n+2010-06-04  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41371\n+\t* var-tracking.c (find_loc_in_1pdv): Mark initial value before\n+\trecursing.  Check that recursion is bounded.  Rename inner var\n+\tto avoid hiding incoming argument.\n+\n 2010-06-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*addqi_2): Do not assert operands[2] == 255"}, {"sha": "eb6144fa3e5a06ba0b12c0f076e92b9154b3d4c3", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 70, "deletions": 10, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa43fb73b386b98e9c92d85905633f81d0c326e/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa43fb73b386b98e9c92d85905633f81d0c326e/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0fa43fb73b386b98e9c92d85905633f81d0c326e", "patch": "@@ -2486,16 +2486,21 @@ find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n {\n   location_chain node;\n   enum rtx_code loc_code;\n+  location_chain ret = NULL;\n+  int unmark_self = 0;\n+#ifdef ENABLE_CHECKING\n+  static int mark_count;\n+#endif\n \n   if (!var)\n-    return NULL;\n+    return ret;\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (dv_onepart_p (var->dv));\n #endif\n \n   if (!var->n_var_parts)\n-    return NULL;\n+    return ret;\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (var->var_part[0].offset == 0);\n@@ -2510,34 +2515,89 @@ find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n \t    continue;\n \t}\n       else if (loc == node->loc)\n-\treturn node;\n+\t{\n+\t  ret = node;\n+\t  break;\n+\t}\n       else if (loc_code != VALUE)\n \t{\n \t  if (rtx_equal_p (loc, node->loc))\n-\t    return node;\n+\t    {\n+\t      ret = node;\n+\t      break;\n+\t    }\n \t  continue;\n \t}\n       if (!VALUE_RECURSED_INTO (node->loc))\n \t{\n \t  decl_or_value dv = dv_from_value (node->loc);\n-\t  variable var = (variable)\n-\t\t\t htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n+\t  variable rvar = (variable)\n+\t    htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n \n-\t  if (var)\n+\t  if (rvar)\n \t    {\n \t      location_chain where;\n+\n+\t      if (!unmark_self)\n+\t\t{\n+\t\t  if (dv_is_value_p (var->dv)\n+\t\t      && !VALUE_RECURSED_INTO (dv_as_value (var->dv)))\n+\t\t    {\n+\t\t      unmark_self = 1;\n+#ifdef ENABLE_CHECKING\n+\t\t      mark_count++;\n+#endif\n+\t\t      VALUE_RECURSED_INTO (dv_as_value (var->dv)) = true;\n+\t\t    }\n+\t\t  else\n+\t\t    unmark_self = -1;\n+\t\t}\n+\n+#ifdef ENABLE_CHECKING\n+\t      mark_count++;\n+\t      /* The recursion count is bounded because we're\n+\t\t searching in a star-canonicalized set, i.e., each\n+\t\t equivalence set of values is arranged so that the\n+\t\t canonical value has all locations and equivalent\n+\t\t values, whereas equivalent values only point back to\n+\t\t the canonical.  So, if we start at the canonical\n+\t\t value, we'll recurse at most into each sibling, so\n+\t\t the recurse limit will be 2.  If we start at a\n+\t\t non-canonical value, we'll recurse into the\n+\t\t canonical, and from there to other siblings, so\n+\t\t recurse limit will be 3.  If we start at a one-part\n+\t\t variable, we add one level of recursion, but we don't\n+\t\t count it.  */\n+\t      gcc_assert (mark_count <= 3);\n+#endif\n \t      VALUE_RECURSED_INTO (node->loc) = true;\n-\t      if ((where = find_loc_in_1pdv (loc, var, vars)))\n+\t      if ((where = find_loc_in_1pdv (loc, rvar, vars)))\n \t\t{\n+#ifdef ENABLE_CHECKING\n+\t\t  mark_count--;\n+#endif\n \t\t  VALUE_RECURSED_INTO (node->loc) = false;\n-\t\t  return where;\n+\t\t  ret = where;\n+\t\t  break;\n \t\t}\n \t      VALUE_RECURSED_INTO (node->loc) = false;\n+#ifdef ENABLE_CHECKING\n+\t      mark_count--;\n+#endif\n \t    }\n \t}\n     }\n \n-  return NULL;\n+  if (unmark_self > 0)\n+    {\n+      VALUE_RECURSED_INTO (dv_as_value (var->dv)) = false;\n+#ifdef ENABLE_CHECKING\n+      mark_count--;\n+      gcc_assert (mark_count == 0);\n+#endif\n+    }\n+\n+  return ret;\n }\n \n /* Hash table iteration argument passed to variable_merge.  */"}]}