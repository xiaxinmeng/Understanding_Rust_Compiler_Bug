{"sha": "fa4a5557dd8f2e4a57bd30bfdf55115c302fc189", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE0YTU1NTdkZDhmMmU0YTU3YmQzMGJmZGY1NTExNWMzMDJmYzE4OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-06-15T00:06:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-06-15T00:06:18Z"}, "message": "fold-const.c (fold): Move X>=C / X<C transfomation earlier.\n\n        * fold-const.c (fold) [compare ops]: Move X>=C / X<C transfomation\n        earlier.  Re-factor comparisons vs extrema.\n\nFrom-SVN: r54626", "tree": {"sha": "3ce76f54a4557c8ffdfc9a085936ab7f4e482770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ce76f54a4557c8ffdfc9a085936ab7f4e482770"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189/comments", "author": null, "committer": null, "parents": [{"sha": "d95eb49f76442102a21330652340889b4d1af9ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95eb49f76442102a21330652340889b4d1af9ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d95eb49f76442102a21330652340889b4d1af9ee"}], "stats": {"total": 194, "additions": 99, "deletions": 95}, "files": [{"sha": "197ac511706143aa73c3642c00f16ee3466c283a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa4a5557dd8f2e4a57bd30bfdf55115c302fc189", "patch": "@@ -1,3 +1,8 @@\n+2002-06-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* fold-const.c (fold) [compare ops]: Move X>=C / X<C transfomation\n+\tearlier.  Re-factor comparisons vs extrema.\n+\n 2002-06-14  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.md (builtin_zapnot): Fix op2 mode."}, {"sha": "31bcddba89b56a3387cd69f306e44b6a2b577b69", "filename": "gcc/fold-const.c", "status": "modified", "additions": 94, "deletions": 95, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fa4a5557dd8f2e4a57bd30bfdf55115c302fc189", "patch": "@@ -6013,9 +6013,34 @@ fold (expr)\n \t  }\n       }\n \n+      /* Change X >= C to X > (C - 1) and X < C to X <= (C - 1) if C > 0.\n+\t This transformation affects the cases which are handled in later\n+\t optimizations involving comparisons with non-negative constants.  */\n+      if (TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (arg0) != INTEGER_CST\n+\t  && tree_int_cst_sgn (arg1) > 0)\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case GE_EXPR:\n+\t      code = GT_EXPR;\n+\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n+\t      t = build (code, type, TREE_OPERAND (t, 0), arg1);\n+\t      break;\n+\n+\t    case LT_EXPR:\n+\t      code = LE_EXPR;\n+\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n+\t      t = build (code, type, TREE_OPERAND (t, 0), arg1);\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n       /* Comparisons with the highest or lowest possible integer of\n-\t the specified size will have known values and an unsigned\n-\t <= 0x7fffffff can be simplified.  */\n+\t the specified size will have known values.  */\n       {\n \tint width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg1)));\n \n@@ -6025,43 +6050,76 @@ fold (expr)\n \t    && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n \t\t|| POINTER_TYPE_P (TREE_TYPE (arg1))))\n \t  {\n+\t    unsigned HOST_WIDE_INT signed_max;\n+\t    unsigned HOST_WIDE_INT max, min;\n+\n+\t    signed_max = ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1;\n+\n+\t    if (TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t      {\n+\t        max = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;\n+\t\tmin = 0;\n+\t      }\n+\t    else\n+\t      {\n+\t        max = signed_max;\n+\t\tmin = ((unsigned HOST_WIDE_INT) -1 << (width - 1));\n+\t      }\n+\n \t    if (TREE_INT_CST_HIGH (arg1) == 0\n-\t\t&& (TREE_INT_CST_LOW (arg1)\n-\t\t    == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n-\t\t&& ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t      switch (TREE_CODE (t))\n+\t\t&& TREE_INT_CST_LOW (arg1) == max)\n+\t      switch (code)\n \t\t{\n \t\tcase GT_EXPR:\n \t\t  return omit_one_operand (type,\n \t\t\t\t\t   convert (type, integer_zero_node),\n \t\t\t\t\t   arg0);\n \t\tcase GE_EXPR:\n+\t\t  code = EQ_EXPR;\n \t\t  TREE_SET_CODE (t, EQ_EXPR);\n \t\t  break;\n-\n \t\tcase LE_EXPR:\n \t\t  return omit_one_operand (type,\n \t\t\t\t\t   convert (type, integer_one_node),\n \t\t\t\t\t   arg0);\n \t\tcase LT_EXPR:\n+\t\t  code = NE_EXPR;\n \t\t  TREE_SET_CODE (t, NE_EXPR);\n \t\t  break;\n \n+\t\t/* The GE_EXPR and LT_EXPR cases above are not normally\n+\t\t   reached because of  previous transformations.  */\n+\n \t\tdefault:\n \t\t  break;\n \t\t}\n-\n-\t    else if (TREE_INT_CST_HIGH (arg1) == -1\n-\t\t     && (TREE_INT_CST_LOW (arg1)\n-\t\t\t == ((unsigned HOST_WIDE_INT) -1 << (width - 1)))\n-\t\t     && ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t      switch (TREE_CODE (t))\n+\t    else if (TREE_INT_CST_HIGH (arg1) == 0\n+\t\t     && TREE_INT_CST_LOW (arg1) == max - 1)\n+\t      switch (code)\n+\t\t{\n+\t\tcase GT_EXPR:\n+\t\t  code = EQ_EXPR;\n+\t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n+\t\t  t = build (code, type, TREE_OPERAND (t, 0), arg1);\n+\t\t  break;\n+\t\tcase LE_EXPR:\n+\t\t  code = NE_EXPR;\n+\t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n+\t\t  t = build (code, type, TREE_OPERAND (t, 0), arg1);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    else if (TREE_INT_CST_HIGH (arg1) == (min ? -1 : 0)\n+\t\t     && TREE_INT_CST_LOW (arg1) == min)\n+\t      switch (code)\n \t\t{\n \t\tcase LT_EXPR:\n \t\t  return omit_one_operand (type,\n \t\t\t\t\t   convert (type, integer_zero_node),\n \t\t\t\t\t   arg0);\n \t\tcase LE_EXPR:\n+\t\t  code = EQ_EXPR;\n \t\t  TREE_SET_CODE (t, EQ_EXPR);\n \t\t  break;\n \n@@ -6070,112 +6128,53 @@ fold (expr)\n \t\t\t\t\t   convert (type, integer_one_node),\n \t\t\t\t\t   arg0);\n \t\tcase GT_EXPR:\n+\t\t  code = NE_EXPR;\n \t\t  TREE_SET_CODE (t, NE_EXPR);\n \t\t  break;\n \n \t\tdefault:\n \t\t  break;\n \t\t}\n+\t    else if (TREE_INT_CST_HIGH (arg1) == (min ? -1 : 0)\n+\t\t     && TREE_INT_CST_LOW (arg1) == min + 1)\n+\t      switch (code)\n+\t\t{\n+\t\tcase GE_EXPR:\n+\t\t  code = NE_EXPR;\n+\t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n+\t\t  t = build (code, type, TREE_OPERAND (t, 0), arg1);\n+\t\t  break;\n+\t\tcase LT_EXPR:\n+\t\t  code = EQ_EXPR;\n+\t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n+\t\t  t = build (code, type, TREE_OPERAND (t, 0), arg1);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n \n \t    else if (TREE_INT_CST_HIGH (arg1) == 0\n-\t\t     && (TREE_INT_CST_LOW (arg1)\n-\t\t\t == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n+\t\t     && TREE_INT_CST_LOW (arg1) == signed_max\n \t\t     && TREE_UNSIGNED (TREE_TYPE (arg1))\n \t\t     /* signed_type does not work on pointer types.  */\n \t\t     && INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n \t      {\n-\t\tif (TREE_CODE (t) == LE_EXPR || TREE_CODE (t) == GT_EXPR)\n+\t\t/* The following case also applies to X < signed_max+1\n+\t\t   and X >= signed_max+1 because previous transformations.  */\n+\t\tif (code == LE_EXPR || code == GT_EXPR)\n \t\t  {\n \t\t    tree st0, st1;\n \t\t    st0 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg0));\n \t\t    st1 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg1));\n \t\t    return fold\n-\t\t      (build (TREE_CODE (t) == LE_EXPR ? GE_EXPR: LT_EXPR,\n+\t\t      (build (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n \t\t\t      type, convert (st0, arg0),\n \t\t\t      convert (st1, integer_zero_node)));\n \t\t  }\n \t      }\n-\t    else if (TREE_INT_CST_HIGH (arg1) == 0\n-\t\t     && (TREE_INT_CST_LOW (arg1)\n-\t\t\t == ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1)\n-\t\t     && TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t      switch (TREE_CODE (t))\n-\t\t{\n-\t\tcase GT_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_zero_node),\n-\t\t\t\t\t   arg0);\n-\t\tcase GE_EXPR:\n-\t\t  TREE_SET_CODE (t, EQ_EXPR);\n-\t\t  break;\n-\n-\t\tcase LE_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_one_node),\n-\t\t\t\t\t   arg0);\n-\t\tcase LT_EXPR:\n-\t\t  TREE_SET_CODE (t, NE_EXPR);\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n \t  }\n       }\n \n-      /* Change X >= C to X > C-1 and X < C to X <= C-1 if C is positive.  */\n-      if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (arg0) != INTEGER_CST\n-\t  && tree_int_cst_sgn (arg1) > 0)\n-\t{\n-\t  switch (TREE_CODE (t))\n-\t    {\n-\t    case GE_EXPR:\n-\t      code = GT_EXPR;\n-\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      t = build (code, type, TREE_OPERAND (t, 0), arg1);\n-\t      break;\n-\n-\t    case LT_EXPR:\n-\t      code = LE_EXPR;\n-\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      t = build (code, type, TREE_OPERAND (t, 0), arg1);\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* An unsigned comparison against 0 can be simplified.  */\n-      if (integer_zerop (arg1)\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t      || POINTER_TYPE_P (TREE_TYPE (arg1)))\n-\t  && TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t{\n-\t  switch (TREE_CODE (t))\n-\t    {\n-\t    case GT_EXPR:\n-\t      code = NE_EXPR;\n-\t      TREE_SET_CODE (t, NE_EXPR);\n-\t      break;\n-\t    case LE_EXPR:\n-\t      code = EQ_EXPR;\n-\t      TREE_SET_CODE (t, EQ_EXPR);\n-\t      break;\n-\t    case GE_EXPR:\n-\t      return omit_one_operand (type,\n-\t\t\t\t       convert (type, integer_one_node),\n-\t\t\t\t       arg0);\n-\t    case LT_EXPR:\n-\t      return omit_one_operand (type,\n-\t\t\t\t       convert (type, integer_zero_node),\n-\t\t\t\t       arg0);\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-\n       /* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or\n \t a MINUS_EXPR of a constant, we can convert it into a comparison with\n \t a revised constant as long as no overflow occurs.  */"}]}