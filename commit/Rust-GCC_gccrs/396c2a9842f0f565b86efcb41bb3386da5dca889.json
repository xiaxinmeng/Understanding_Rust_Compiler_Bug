{"sha": "396c2a9842f0f565b86efcb41bb3386da5dca889", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk2YzJhOTg0MmYwZjU2NWI4NmVmY2I0MWJiMzM4NmRhNWRjYTg4OQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-12-13T06:00:53Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-12-13T06:00:53Z"}, "message": "[rs6000] Adjust vectorization cost for scalar COND_EXPR\n\nWe found that the vectorization cost modeling on scalar COND_EXPR is a bit off\non rs6000.  One typical case is 548.exchange2_r, -Ofast -mcpu=power9 -mrecip\n-fvect-cost-model=unlimited is better than -Ofast -mcpu=power9 -mrecip (the\ndefault is -fvect-cost-model=dynamic) by 1.94%.  Scalar COND_EXPR is expanded\ninto compare + branch or compare + isel normally, either of them should be\npriced more than the simple FXU operation.  This patch is to add additional\nvectorization cost onto scalar COND_EXPR on top of builtin_vectorization_cost.\nThe idea to use additional cost value 2 instead of the others: 1) try various\npossible value candidates from 1 to 5, 2 is the best measured on Power9.  2) \nfrom latency view, compare takes 3 cycles and isel takes 2 on Power9, it's \n2.5 times of simple FXU instruction which takes cost 1 in the current\nmodeling, it's close.  3) get fine SPEC2017 ratio on Power8 as well.\n\ngcc/ChangeLog\n\n    * config/rs6000/rs6000.c (adjust_vectorization_cost): New function.\n    (rs6000_add_stmt_cost): Call adjust_vectorization_cost and update\n    stmt_cost.\n\nFrom-SVN: r279336", "tree": {"sha": "381a323f8fd9bdec0fcc7222ae69101d35ef8958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/381a323f8fd9bdec0fcc7222ae69101d35ef8958"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/396c2a9842f0f565b86efcb41bb3386da5dca889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396c2a9842f0f565b86efcb41bb3386da5dca889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/396c2a9842f0f565b86efcb41bb3386da5dca889", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396c2a9842f0f565b86efcb41bb3386da5dca889/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1af2dd9c3a5f6b4885db739f6fc3d80ed80007a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1af2dd9c3a5f6b4885db739f6fc3d80ed80007a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1af2dd9c3a5f6b4885db739f6fc3d80ed80007a"}], "stats": {"total": 30, "additions": 30, "deletions": 0}, "files": [{"sha": "981b3ff422581f8795709b5004b8eddcd9a4068c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396c2a9842f0f565b86efcb41bb3386da5dca889/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396c2a9842f0f565b86efcb41bb3386da5dca889/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=396c2a9842f0f565b86efcb41bb3386da5dca889", "patch": "@@ -1,3 +1,9 @@\n+2019-12-13  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\t* config/rs6000/rs6000.c (adjust_vectorization_cost): New function.\n+\t(rs6000_add_stmt_cost): Call adjust_vectorization_cost and update\n+\tstmt_cost.\n+\n 2019-12-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/92904"}, {"sha": "6f0c7fa2db951a2872065f6c9b57485ff5a20968", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396c2a9842f0f565b86efcb41bb3386da5dca889/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396c2a9842f0f565b86efcb41bb3386da5dca889/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=396c2a9842f0f565b86efcb41bb3386da5dca889", "patch": "@@ -4997,6 +4997,29 @@ rs6000_init_cost (struct loop *loop_info)\n   return data;\n }\n \n+/* Adjust vectorization cost after calling rs6000_builtin_vectorization_cost.\n+   For some statement, we would like to further fine-grain tweak the cost on\n+   top of rs6000_builtin_vectorization_cost handling which doesn't have any\n+   information on statement operation codes etc.  One typical case here is\n+   COND_EXPR, it takes the same cost to simple FXU instruction when evaluating\n+   for scalar cost, but it should be priced more whatever transformed to either\n+   compare + branch or compare + isel instructions.  */\n+\n+static unsigned\n+adjust_vectorization_cost (enum vect_cost_for_stmt kind,\n+\t\t\t   struct _stmt_vec_info *stmt_info)\n+{\n+  if (kind == scalar_stmt && stmt_info && stmt_info->stmt\n+      && gimple_code (stmt_info->stmt) == GIMPLE_ASSIGN)\n+    {\n+      tree_code subcode = gimple_assign_rhs_code (stmt_info->stmt);\n+      if (subcode == COND_EXPR)\n+\treturn 2;\n+    }\n+\n+  return 0;\n+}\n+\n /* Implement targetm.vectorize.add_stmt_cost.  */\n \n static unsigned\n@@ -5012,6 +5035,7 @@ rs6000_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n       tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n       int stmt_cost = rs6000_builtin_vectorization_cost (kind, vectype,\n \t\t\t\t\t\t\t misalign);\n+      stmt_cost += adjust_vectorization_cost (kind, stmt_info);\n       /* Statements in an inner loop relative to the loop being\n \t vectorized are weighted more heavily.  The value here is\n \t arbitrary and could potentially be improved with analysis.  */"}]}