{"sha": "eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVkNDBiY2E2ZjJlYjNhZjBjODExY2Y2ZWM5ZTEyM2M1YmY0OTA3ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-01-05T06:13:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-01-19T22:29:18Z"}, "message": "compiler: initialize variables with go:embed directives\n\nThis completes the compiler work for go:embed.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/281536", "tree": {"sha": "d87463098b6241ae8b4998b6249c49e8c9c93493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d87463098b6241ae8b4998b6249c49e8c9c93493"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d89b00c095e99cd5cb6d3e05f30d3a61fa592000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89b00c095e99cd5cb6d3e05f30d3a61fa592000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d89b00c095e99cd5cb6d3e05f30d3a61fa592000"}], "stats": {"total": 349, "additions": 347, "deletions": 2}, "files": [{"sha": "f67c30a5d3a86263b445b6f08d135341eda26e52", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d", "patch": "@@ -1,4 +1,4 @@\n-9e78cef2b689aa586dbf677fb47ea3f08f197b91\n+83eea1930671ce2bba863582a67f2609bc4f9f36\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "bea1003bc087a79bdada0f6bdabfa5881b46d432", "filename": "gcc/go/gofrontend/embed.cc", "status": "modified", "additions": 321, "deletions": 1, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/gcc%2Fgo%2Fgofrontend%2Fembed.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/gcc%2Fgo%2Fgofrontend%2Fembed.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fembed.cc?ref=eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d", "patch": "@@ -9,6 +9,8 @@\n #include \"operator.h\"\n #include \"go-diagnostics.h\"\n #include \"lex.h\"\n+#include \"types.h\"\n+#include \"expressions.h\"\n #include \"gogo.h\"\n \n #ifndef O_BINARY\n@@ -301,7 +303,41 @@ Gogo::read_embedcfg(const char *filename)\n       return;\n     }\n \n-  // TODO: Actually do something with patterns and files.\n+  for (Json_value::map_iterator p = patterns->map_begin();\n+       p != patterns->map_end();\n+       ++p)\n+    {\n+      if (p->second->classification() != Json_value::JSON_VALUE_ARRAY)\n+\t{\n+\t  r.error(\"invalid embedcfg: Patterns entry is not an array\");\n+\t  return;\n+\t}\n+      std::vector<std::string> files;\n+      p->second->get_and_clear_array(&files);\n+\n+      std::pair<std::string, std::vector<std::string> > val;\n+      val.first = p->first;\n+      std::pair<Embed_patterns::iterator, bool> ins =\n+\tthis->embed_patterns_.insert(val);\n+      if (!ins.second)\n+\t{\n+\t  r.error(\"invalid embedcfg: duplicate Patterns entry\");\n+\t  return;\n+\t}\n+      std::swap(ins.first->second, files);\n+    }\n+\n+  for (Json_value::map_iterator p = files->map_begin();\n+       p != files->map_end();\n+       ++p)\n+    {\n+      if (p->second->classification() != Json_value::JSON_VALUE_STRING)\n+\t{\n+\t  r.error(\"invalid embedcfg: Files entry is not a string\");\n+\t  return;\n+\t}\n+      this->embed_files_[p->first] = p->second->to_string();\n+    }\n }\n \n // Read the contents of FILENAME into this->data_.  Returns whether it\n@@ -641,3 +677,287 @@ Gogo::is_embed_imported() const\n   // the package has been imported if there is at least one alias.\n   return !p->second->aliases().empty();\n }\n+\n+// Implement the sort order for a list of embedded files, as discussed\n+// at the docs for embed.FS.\n+\n+class Embedfs_sort\n+{\n+ public:\n+  bool\n+  operator()(const std::string& p1, const std::string& p2) const;\n+\n+ private:\n+  void\n+  split(const std::string&, size_t*, size_t*, size_t*) const;\n+};\n+\n+bool\n+Embedfs_sort::operator()(const std::string& p1, const std::string& p2) const\n+{\n+  size_t dirlen1, elem1, elemlen1;\n+  this->split(p1, &dirlen1, &elem1, &elemlen1);\n+  size_t dirlen2, elem2, elemlen2;\n+  this->split(p2, &dirlen2, &elem2, &elemlen2);\n+\n+  if (dirlen1 == 0)\n+    {\n+      if (dirlen2 > 0)\n+\t{\n+\t  int i = p2.compare(0, dirlen2, \".\");\n+\t  if (i != 0)\n+\t    return i > 0;\n+\t}\n+    }\n+  else if (dirlen2 == 0)\n+    {\n+      int i = p1.compare(0, dirlen1, \".\");\n+      if (i != 0)\n+\treturn i < 0;\n+    }\n+  else\n+    {\n+      int i = p1.compare(0, dirlen1, p2, 0, dirlen2);\n+      if (i != 0)\n+\treturn i < 0;\n+    }\n+\n+  int i = p1.compare(elem1, elemlen1, p2, elem2, elemlen2);\n+  return i < 0;\n+}\n+\n+// Pick out the directory and file name components for comparison.\n+\n+void\n+Embedfs_sort::split(const std::string& s, size_t* dirlen, size_t* elem,\n+\t\t    size_t* elemlen) const\n+{\n+  size_t len = s.size();\n+  if (len > 0 && s[len - 1] == '/')\n+    --len;\n+  size_t slash = s.rfind('/', len - 1);\n+  if (slash == std::string::npos)\n+    {\n+      *dirlen = 0;\n+      *elem = 0;\n+      *elemlen = len;\n+    }\n+  else\n+    {\n+      *dirlen = slash;\n+      *elem = slash + 1;\n+      *elemlen = len - (slash + 1);\n+    }\n+}\n+\n+// Convert the go:embed directives for a variable into an initializer\n+// for that variable.\n+\n+Expression*\n+Gogo::initializer_for_embeds(Type* type,\n+\t\t\t     const std::vector<std::string>* embeds,\n+\t\t\t     Location loc)\n+{\n+  if (this->embed_patterns_.empty())\n+    {\n+      go_error_at(loc,\n+\t\t  (\"invalid go:embed: build system did not \"\n+\t\t   \"supply embed configuration\"));\n+      return Expression::make_error(loc);\n+    }\n+\n+  type = type->unalias();\n+\n+  enum {\n+    EMBED_STRING = 0,\n+    EMBED_BYTES = 1,\n+    EMBED_FS = 2\n+  } embed_kind;\n+\n+  const Named_type* nt = type->named_type();\n+  if (nt != NULL\n+      && nt->named_object()->package() != NULL\n+      && nt->named_object()->package()->pkgpath() == \"embed\"\n+      && nt->name() == \"FS\")\n+    embed_kind = EMBED_FS;\n+  else if (type->is_string_type())\n+    embed_kind = EMBED_STRING;\n+  else if (type->is_slice_type()\n+\t   && type->array_type()->element_type()->integer_type() != NULL\n+\t   && type->array_type()->element_type()->integer_type()->is_byte())\n+    embed_kind = EMBED_BYTES;\n+  else\n+    {\n+      go_error_at(loc, \"invalid type for go:embed\");\n+      return Expression::make_error(loc);\n+    }\n+\n+  // The patterns in the go:embed directive(s) are in EMBEDS.  Find\n+  // them in the patterns in the embedcfg file.\n+\n+  Unordered_set(std::string) have;\n+  std::vector<std::string> paths;\n+  for (std::vector<std::string>::const_iterator pe = embeds->begin();\n+       pe != embeds->end();\n+       pe++)\n+    {\n+      Embed_patterns::const_iterator pp = this->embed_patterns_.find(*pe);\n+      if (pp == this->embed_patterns_.end())\n+\t{\n+\t  go_error_at(loc,\n+\t\t      (\"invalid go:embed: build system did not \"\n+\t\t       \"map pattern %<%s%>\"),\n+\t\t      pe->c_str());\n+\t  continue;\n+\t}\n+\n+      // Each pattern in the embedcfg file maps to a list of file\n+      // names.  For each file name, the embedcfg file records an\n+      // absolute path.  Add those absolute paths to PATHS.\n+      for (std::vector<std::string>::const_iterator pf = pp->second.begin();\n+\t   pf != pp->second.end();\n+\t   pf++)\n+\t{\n+\t  if (this->embed_files_.find(*pf) == this->embed_files_.end())\n+\t    {\n+\t      go_error_at(loc,\n+\t\t\t  (\"invalid go:embed: build system did not \"\n+\t\t\t   \"map file %<%s%>\"),\n+\t\t\t  pf->c_str());\n+\t      continue;\n+\t    }\n+\n+\t  std::pair<Unordered_set(std::string)::iterator, bool> ins\n+\t    = have.insert(*pf);\n+\t  if (ins.second)\n+\t    {\n+\t      const std::string& path(*pf);\n+\t      paths.push_back(path);\n+\n+\t      if (embed_kind == EMBED_FS)\n+\t\t{\n+\t\t  // Add each required directory, with a trailing slash.\n+\t\t  size_t i = std::string::npos;\n+\t\t  while (i > 0)\n+\t\t    {\n+\t\t      i = path.rfind('/', i);\n+\t\t      if (i == std::string::npos)\n+\t\t\tbreak;\n+\t\t      std::string dir = path.substr(0, i + 1);\n+\t\t      ins = have.insert(dir);\n+\t\t      if (ins.second)\n+\t\t\tpaths.push_back(dir);\n+\t\t      --i;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (embed_kind == EMBED_STRING || embed_kind == EMBED_BYTES)\n+    {\n+      if (paths.size() > 1)\n+\t{\n+\t  go_error_at(loc,\n+\t\t      (\"invalid go:embed: multiple files for \"\n+\t\t       \"string or byte slice\"));;\n+\t  return Expression::make_error(loc);\n+\t}\n+\n+      std::string data;\n+      if (!read_file(paths[0].c_str(), loc, &data))\n+\treturn Expression::make_error(loc);\n+\n+      Expression* e = Expression::make_string(data, loc);\n+      if (embed_kind == EMBED_BYTES)\n+\te = Expression::make_cast(type, e, loc);\n+      return e;\n+    }\n+\n+  std::sort(paths.begin(), paths.end(), Embedfs_sort());\n+\n+  if (type->struct_type() == NULL\n+      || type->struct_type()->field_count() != 1)\n+    {\n+      go_error_at(loc,\n+\t\t  (\"internal error: embed.FS should be struct type \"\n+\t\t   \"with one field\"));\n+      return Expression::make_error(loc);\n+    }\n+\n+  Type* ptr_type = type->struct_type()->field(0)->type();\n+  if (ptr_type->points_to() == NULL)\n+    {\n+      go_error_at(loc,\n+\t\t  \"internal error: embed.FS struct field should be pointer\");\n+      return Expression::make_error(loc);\n+    }\n+\n+  Type* slice_type = ptr_type->points_to();\n+  if (!slice_type->is_slice_type())\n+    {\n+      go_error_at(loc,\n+\t\t  (\"internal error: embed.FS struct field should be \"\n+\t\t   \"pointer to slice\"));\n+      return Expression::make_error(loc);\n+    }\n+\n+  Type* file_type = slice_type->array_type()->element_type();\n+  if (file_type->struct_type() == NULL\n+      || (file_type->struct_type()->find_local_field(\".embed.name\", NULL)\n+\t  == NULL)\n+      || (file_type->struct_type()->find_local_field(\".embed.data\", NULL)\n+\t  == NULL))\n+    {\n+      go_error_at(loc,\n+\t\t  (\"internal error: embed.FS slice element should be struct \"\n+\t\t   \"with name and data fields\"));\n+      return Expression::make_error(loc);\n+    }\n+\n+  const Struct_field_list* file_fields = file_type->struct_type()->fields();\n+  Expression_list* file_vals = new(Expression_list);\n+  file_vals->reserve(paths.size());\n+  for (std::vector<std::string>::const_iterator pp = paths.begin();\n+       pp != paths.end();\n+       ++pp)\n+    {\n+      std::string data;\n+      if ((*pp)[pp->size() - 1] != '/')\n+\t{\n+\t  if (!read_file(this->embed_files_[*pp].c_str(), loc, &data))\n+\t    return Expression::make_error(loc);\n+\t}\n+\n+      Expression_list* field_vals = new(Expression_list);\n+      for (Struct_field_list::const_iterator pf = file_fields->begin();\n+\t   pf != file_fields->end();\n+\t   ++pf)\n+\t{\n+\t  if (pf->is_field_name(\".embed.name\"))\n+\t    field_vals->push_back(Expression::make_string(*pp, loc));\n+\t  else if (pf->is_field_name(\".embed.data\"))\n+\t    field_vals->push_back(Expression::make_string(data, loc));\n+\t  else\n+\t    {\n+\t      // FIXME: The embed.file type has a hash field, which is\n+\t      // currently unused.  We should fill it in, but don't.\n+\t      // The hash is a SHA256, and we don't have convenient\n+\t      // SHA256 code.  Do this later when the field is\n+\t      // actually used.\n+\t      field_vals->push_back(NULL);\n+\t    }\n+\t}\n+\n+      Expression* file_val =\n+\tExpression::make_struct_composite_literal(file_type, field_vals, loc);\n+      file_vals->push_back(file_val);\n+    }\n+\n+  Expression* slice_init =\n+    Expression::make_slice_composite_literal(slice_type, file_vals, loc);\n+  Expression* fs_init = Expression::make_heap_expression(slice_init, loc);\n+  Expression_list* fs_vals = new Expression_list();\n+  fs_vals->push_back(fs_init);\n+  return Expression::make_struct_composite_literal(type, fs_vals, loc);\n+}"}, {"sha": "62b06be827b7f56865dc1f769039ec26c3bd7f60", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d", "patch": "@@ -7502,6 +7502,17 @@ Variable::lower_init_expression(Gogo* gogo, Named_object* function,\n   if (dep != NULL && dep->is_variable())\n     dep->var_value()->lower_init_expression(gogo, function, inserter);\n \n+  if (this->embeds_ != NULL)\n+    {\n+      // Now that we have seen any possible type aliases, convert the\n+      // go:embed directives into an initializer.\n+      go_assert(this->init_ == NULL && this->type_ != NULL);\n+      this->init_ = gogo->initializer_for_embeds(this->type_, this->embeds_,\n+\t\t\t\t\t\t this->location_);\n+      delete this->embeds_;\n+      this->embeds_ = NULL;\n+    }\n+\n   if (this->init_ != NULL && !this->init_is_lowered_)\n     {\n       if (this->seen_)"}, {"sha": "51b6575ba47f36c617d2c526837b622f86f3ed5d", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=eed40bca6f2eb3af0c811cf6ec9e123c5bf4907d", "patch": "@@ -401,6 +401,10 @@ class Gogo\n   bool\n   is_embed_imported() const;\n \n+  // Build an initializer for a variable with a go:embed directive.\n+  Expression*\n+  initializer_for_embeds(Type*, const std::vector<std::string>*, Location);\n+\n   // Return whether to check for division by zero in binary operations.\n   bool\n   check_divide_by_zero() const\n@@ -1178,6 +1182,12 @@ class Gogo\n   static bool\n   is_digits(const std::string&);\n \n+  // Type used to map go:embed patterns to a list of files.\n+  typedef Unordered_map(std::string, std::vector<std::string>) Embed_patterns;\n+\n+  // Type used to map go:embed file names to their full path.\n+  typedef Unordered_map(std::string, std::string) Embed_files;\n+\n   // Type used to map import names to packages.\n   typedef std::map<std::string, Package*> Imports;\n \n@@ -1273,6 +1283,10 @@ class Gogo\n   std::string relative_import_path_;\n   // The C header file to write, from the -fgo-c-header option.\n   std::string c_header_;\n+  // Patterns from an embedcfg file.\n+  Embed_patterns embed_patterns_;\n+  // Mapping from file to full path from an embedcfg file.\n+  Embed_files embed_files_;\n   // Whether or not to check for division by zero, from the\n   // -fgo-check-divide-zero option.\n   bool check_divide_by_zero_;"}]}