{"sha": "ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiMDc1MjBjZGRhYTEzZGE0MGRiZDY3NzVjNWZmM2YxYjIyNDk0Yw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-03-08T19:02:51Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-03-08T19:02:51Z"}, "message": "tree-eh.c (do_return_redirection): Call build_gimple_modify_stmt instead of calling build2 with a GIMPLE_MODIFY_STMT.\n\n\n\t* tree-eh.c (do_return_redirection): Call build_gimple_modify_stmt\n\tinstead of calling build2 with a GIMPLE_MODIFY_STMT.\n\t(honor_protect_cleanup_actions, lower_try_finally_switch):\n\tLikewise.\n\t* tree-if-conv.c (replace_phi_with_cond_gimple_modify_stmt,\n\tifc_temp_var): Likewise.\n\t* tree-inline.c (setup_one_parameter): Likewise.\n\t* tree-mudflap.c (mf_decl_cache_locals,\n\tmf_build_check_statement_for): Likewise.\n\t* tree-nested.c (init_tmp_var, save_tmp_var,\n\tfinalize_nesting_tree_1): Likewise.\n\t* tree-outof-ssa.c (insert_copy_on_edge,\n\tinsert_backedge_copies): Likewise.\n\t* tree-profile.c (tree_gen_edge_profiler,\n\ttree_gen_ic_profiler): Likewise.\n\t* tree-scalar-evolution.c (scev_const_prop): Likewise.\n\t* tree-sra.c (sra_build_assignment): Likewise.\n\t* tree-ssa-loop-im.c (determine_invariantness_stmt): Likewise.\n\t* tree-ssa-math-opts.c (insert_reciprocals,\n\texecute_cse_sincos_1): Likewise.\n\t* tree-tailcall.c (adjust_accumulator_values,\n\tadjust_return_value): Likewise.\n\t* tree-vect-patterns.c (vect_pattern_recog_1): Likewise.\n\t* tree-vect-transform.c (vect_create_data_ref_ptr,\n\tbump_vector_ptr, vect_init_vector, get_initial_def_for_induction,\n\tvect_create_epilog_for_reduction, vectorizable_reduction,\n\tvectorizable_call, vectorizable_conversion,\n\tvectorizable_assignment, vectorizable_operation,\n\tvectorizable_type_demotion, vect_gen_widened_results_half,\n\tvect_permute_store_chain, vectorizable_store,\n\tvect_setup_realignment, vect_permute_load_chain,\n\tvectorizable_load, vectorizable_condition,\n\tvect_create_cond_for_align_checks): Likewise.\n\t* tree-vrp.c (build_assert_expr_for): Likewise.\n\nFrom-SVN: r122707", "tree": {"sha": "3617ec1a2bb412824e9bea9c93c38f76d7505941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3617ec1a2bb412824e9bea9c93c38f76d7505941"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/comments", "author": null, "committer": null, "parents": [{"sha": "0c948c27462a668b4e01f7841c0cca812fbbdd8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c948c27462a668b4e01f7841c0cca812fbbdd8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c948c27462a668b4e01f7841c0cca812fbbdd8c"}], "stats": {"total": 382, "additions": 203, "deletions": 179}, "files": [{"sha": "75b37e4b98194ae09f1664c74ff046356671d324", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,3 +1,40 @@\n+2007-03-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* tree-eh.c (do_return_redirection): Call build_gimple_modify_stmt\n+\tinstead of calling build2 with a GIMPLE_MODIFY_STMT.\n+\t(honor_protect_cleanup_actions, lower_try_finally_switch):\n+\tLikewise.\n+\t* tree-if-conv.c (replace_phi_with_cond_gimple_modify_stmt,\n+\tifc_temp_var): Likewise.\n+\t* tree-inline.c (setup_one_parameter): Likewise.\n+\t* tree-mudflap.c (mf_decl_cache_locals,\n+\tmf_build_check_statement_for): Likewise.\n+\t* tree-nested.c (init_tmp_var, save_tmp_var,\n+\tfinalize_nesting_tree_1): Likewise.\n+\t* tree-outof-ssa.c (insert_copy_on_edge,\n+\tinsert_backedge_copies): Likewise.\n+\t* tree-profile.c (tree_gen_edge_profiler,\n+\ttree_gen_ic_profiler): Likewise.\n+\t* tree-scalar-evolution.c (scev_const_prop): Likewise.\n+\t* tree-sra.c (sra_build_assignment): Likewise.\n+\t* tree-ssa-loop-im.c (determine_invariantness_stmt): Likewise.\n+\t* tree-ssa-math-opts.c (insert_reciprocals,\n+\texecute_cse_sincos_1): Likewise.\n+\t* tree-tailcall.c (adjust_accumulator_values,\n+\tadjust_return_value): Likewise.\n+\t* tree-vect-patterns.c (vect_pattern_recog_1): Likewise.\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr,\n+\tbump_vector_ptr, vect_init_vector, get_initial_def_for_induction,\n+\tvect_create_epilog_for_reduction, vectorizable_reduction,\n+\tvectorizable_call, vectorizable_conversion,\n+\tvectorizable_assignment, vectorizable_operation,\n+\tvectorizable_type_demotion, vect_gen_widened_results_half,\n+\tvect_permute_store_chain, vectorizable_store,\n+\tvect_setup_realignment, vect_permute_load_chain,\n+\tvectorizable_load, vectorizable_condition,\n+\tvect_create_cond_for_align_checks): Likewise.\n+\t* tree-vrp.c (build_assert_expr_for): Likewise.\n+\n 2007-03-08  Ian Lance Taylor  <iant@google.com>\n \n \t* tree-vrp.c: Include \"intl.h\"."}, {"sha": "edd17cbcf61d8d7bb05e84386be26a0f9669be27", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -634,13 +634,13 @@ do_return_redirection (struct goto_queue_node *q, tree finlab, tree mod,\n \t    else\n \t      new = *return_value_p;\n \n-\t    x = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (new), new, old);\n+\t    x = build_gimple_modify_stmt (new, old);\n \t    append_to_statement_list (x, &q->repl_stmt);\n \n \t    if (new == result)\n \t      x = result;\n \t    else\n-\t      x = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (result), result, new);\n+\t      x = build_gimple_modify_stmt (result, new);\n \t    q->cont_stmt = build1 (RETURN_EXPR, void_type_node, x);\n \t  }\n \n@@ -830,20 +830,20 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n \n       i = tsi_start (finally);\n       x = build0 (EXC_PTR_EXPR, ptr_type_node);\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, save_eptr, x);\n+      x = build_gimple_modify_stmt (save_eptr, x);\n       tsi_link_before (&i, x, TSI_CONTINUE_LINKING);\n \n       x = build0 (FILTER_EXPR, integer_type_node);\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, save_filt, x);\n+      x = build_gimple_modify_stmt (save_filt, x);\n       tsi_link_before (&i, x, TSI_CONTINUE_LINKING);\n \n       i = tsi_last (finally);\n       x = build0 (EXC_PTR_EXPR, ptr_type_node);\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, x, save_eptr);\n+      x = build_gimple_modify_stmt (x, save_eptr);\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n \n       x = build0 (FILTER_EXPR, integer_type_node);\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, x, save_filt);\n+      x = build_gimple_modify_stmt (x, save_filt);\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n \n       x = build_resx (get_eh_region_number (tf->region));\n@@ -1165,8 +1165,9 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n   if (tf->may_fallthru)\n     {\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, finally_tmp,\n-\t\t  build_int_cst (NULL_TREE, fallthru_index));\n+      x = build_gimple_modify_stmt (finally_tmp,\n+\t\t\t\t    build_int_cst (integer_type_node,\n+\t\t\t\t\t\t   fallthru_index));\n       append_to_statement_list (x, tf->top_p);\n \n       if (tf->may_throw)\n@@ -1195,8 +1196,9 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       x = build1 (LABEL_EXPR, void_type_node, tf->eh_label);\n       append_to_statement_list (x, tf->top_p);\n \n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, finally_tmp,\n-\t\t  build_int_cst (NULL_TREE, eh_index));\n+      x = build_gimple_modify_stmt (finally_tmp,\n+\t\t\t\t    build_int_cst (integer_type_node,\n+\t\t\t\t\t\t   eh_index));\n       append_to_statement_list (x, tf->top_p);\n \n       last_case = build3 (CASE_LABEL_EXPR, void_type_node,\n@@ -1227,15 +1229,17 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n       if (q->index < 0)\n \t{\n-\t  mod = build2 (GIMPLE_MODIFY_STMT, void_type_node, finally_tmp,\n-\t\t        build_int_cst (NULL_TREE, return_index));\n+\t  mod = build_gimple_modify_stmt (finally_tmp,\n+\t\t\t\t\t  build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t return_index));\n \t  do_return_redirection (q, finally_label, mod, &return_val);\n \t  switch_id = return_index;\n \t}\n       else\n \t{\n-\t  mod = build2 (GIMPLE_MODIFY_STMT, void_type_node, finally_tmp,\n-\t\t        build_int_cst (NULL_TREE, q->index));\n+\t  mod = build_gimple_modify_stmt (finally_tmp,\n+\t\t\t\t\t  build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t q->index));\n \t  do_goto_redirection (q, finally_label, mod);\n \t  switch_id = q->index;\n \t}"}, {"sha": "7d1a838d944241808f6cc54c255b31651180ea40", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,5 @@\n /* If-conversion for vectorizer.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Devang Patel <dpatel@apple.com>\n \n This file is part of GCC.\n@@ -802,8 +802,7 @@ replace_phi_with_cond_gimple_modify_stmt (tree phi, tree cond,\n \t        unshare_expr (arg_1));\n \n   /* Create new MODIFY expression using RHS.  */\n-  new_stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (PHI_RESULT (phi)),\n-\t\t     unshare_expr (PHI_RESULT (phi)), rhs);\n+  new_stmt = build_gimple_modify_stmt (unshare_expr (PHI_RESULT (phi)), rhs);\n \n   /* Make new statement definition of the original phi result.  */\n   SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = new_stmt;\n@@ -983,7 +982,7 @@ ifc_temp_var (tree type, tree exp)\n   add_referenced_var (var);\n \n   /* Build new statement to assign EXP to new variable.  */\n-  stmt = build2 (GIMPLE_MODIFY_STMT, type, var, exp);\n+  stmt = build_gimple_modify_stmt (var, exp);\n \n   /* Get SSA name for the new variable and set make new statement\n      its definition statement.  */"}, {"sha": "966da8449f669c3bbec064333adf36f452a6c56d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,6 @@\n /* Tree inlining.\n-   Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -1399,13 +1400,13 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n       if (def && gimple_in_ssa_p (cfun) && is_gimple_reg (p))\n \t{\n \t  def = remap_ssa_name (def, id);\n-          init_stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), def, rhs);\n+          init_stmt = build_gimple_modify_stmt (def, rhs);\n \t  SSA_NAME_DEF_STMT (def) = init_stmt;\n \t  SSA_NAME_IS_DEFAULT_DEF (def) = 0;\n \t  set_default_def (var, NULL);\n \t}\n       else\n-        init_stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), var, rhs);\n+        init_stmt = build_gimple_modify_stmt (var, rhs);\n \n       /* If we did not create a gimple value and we did not create a gimple\n \t cast of a gimple value, then we will need to gimplify INIT_STMTS"}, {"sha": "698114e5dcebeeacd45ad2462f82e6b027e8941c", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,6 @@\n /* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Frank Ch. Eigler <fche@redhat.com>\n    and Graydon Hoare <graydon@redhat.com>\n \n@@ -458,14 +459,12 @@ mf_decl_cache_locals (void)\n \n   /* Build initialization nodes for the cache vars.  We just load the\n      globals into the cache variables.  */\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (mf_cache_shift_decl_l),\n-              mf_cache_shift_decl_l, mf_cache_shift_decl);\n+  t = build_gimple_modify_stmt (mf_cache_shift_decl_l, mf_cache_shift_decl);\n   SET_EXPR_LOCATION (t, DECL_SOURCE_LOCATION (current_function_decl));\n   gimplify_to_stmt_list (&t);\n   shift_init_stmts = t;\n \n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (mf_cache_mask_decl_l),\n-              mf_cache_mask_decl_l, mf_cache_mask_decl);\n+  t = build_gimple_modify_stmt (mf_cache_mask_decl_l, mf_cache_mask_decl);\n   SET_EXPR_LOCATION (t, DECL_SOURCE_LOCATION (current_function_decl));\n   gimplify_to_stmt_list (&t);\n   mask_init_stmts = t;\n@@ -553,16 +552,18 @@ mf_build_check_statement_for (tree base, tree limit,\n   mf_limit = create_tmp_var (mf_uintptr_type, \"__mf_limit\");\n \n   /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, mf_base,\n-              convert (mf_uintptr_type, unshare_expr (base)));\n+  t = build_gimple_modify_stmt (mf_base,\n+\t\t\t\tfold_convert (mf_uintptr_type,\n+\t\t\t\t\t      unshare_expr (base)));\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   head = tsi_start (t);\n   tsi = tsi_last (t);\n \n   /* Build: __mf_limit = (uintptr_t) <limit address expression>.  */\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, mf_limit,\n-              convert (mf_uintptr_type, unshare_expr (limit)));\n+  t = build_gimple_modify_stmt (mf_limit,\n+\t\t\t\tfold_convert (mf_uintptr_type,\n+\t\t\t\t\t      unshare_expr (limit)));\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n@@ -577,7 +578,7 @@ mf_build_check_statement_for (tree base, tree limit,\n               TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n               mf_cache_array_decl, t, NULL_TREE, NULL_TREE);\n   t = build1 (ADDR_EXPR, mf_cache_structptr_type, t);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, mf_elem, t);\n+  t = build_gimple_modify_stmt (mf_elem, t);\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n@@ -623,7 +624,7 @@ mf_build_check_statement_for (tree base, tree limit,\n      can use as the condition for the conditional jump.  */\n   t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, u);\n   cond = create_tmp_var (boolean_type_node, \"__mf_unlikely_cond\");\n-  t = build2 (GIMPLE_MODIFY_STMT, boolean_type_node, cond, t);\n+  t = build_gimple_modify_stmt (cond, t);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n@@ -669,12 +670,12 @@ mf_build_check_statement_for (tree base, tree limit,\n \n   if (! flag_mudflap_threads)\n     {\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-                  mf_cache_shift_decl_l, mf_cache_shift_decl);\n+      t = build_gimple_modify_stmt (mf_cache_shift_decl_l,\n+\t\t\t\t    mf_cache_shift_decl);\n       tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-                  mf_cache_mask_decl_l, mf_cache_mask_decl);\n+      t = build_gimple_modify_stmt (mf_cache_mask_decl_l,\n+\t\t\t\t    mf_cache_mask_decl);\n       tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n     }\n "}, {"sha": "f26c9ba26ad2629a8fd5b182fee325e04f04b083", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,5 @@\n /* Nested function decomposition for trees.\n-   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -361,7 +361,7 @@ init_tmp_var (struct nesting_info *info, tree exp, tree_stmt_iterator *tsi)\n   tree t, stmt;\n \n   t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n-  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (t), t, exp);\n+  stmt = build_gimple_modify_stmt (t, exp);\n   SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n   tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n \n@@ -389,7 +389,7 @@ save_tmp_var (struct nesting_info *info, tree exp,\n   tree t, stmt;\n \n   t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n-  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (t), exp, t);\n+  stmt = build_gimple_modify_stmt (exp, t);\n   SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n   tsi_link_after (tsi, stmt, TSI_SAME_STMT);\n \n@@ -1757,7 +1757,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \n \t  y = build3 (COMPONENT_REF, TREE_TYPE (field),\n \t\t      root->frame_decl, field, NULL_TREE);\n-\t  x = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (field), y, x);\n+\t  x = build_gimple_modify_stmt (y, x);\n \t  append_to_statement_list (x, &stmt_list);\n \t}\n     }\n@@ -1768,7 +1768,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n     {\n       tree x = build3 (COMPONENT_REF, TREE_TYPE (root->chain_field),\n \t\t       root->frame_decl, root->chain_field, NULL_TREE);\n-      x = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (x), x, get_chain_decl (root));\n+      x = build_gimple_modify_stmt (x, get_chain_decl (root));\n       append_to_statement_list (x, &stmt_list);\n     }\n "}, {"sha": "7e759ba81762492da9a09a5f3ab139d325f8649e", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,5 @@\n /* Convert a program in SSA form into Normal form.\n-   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Andrew Macleod <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -141,7 +141,7 @@ insert_copy_on_edge (edge e, tree dest, tree src)\n {\n   tree copy;\n \n-  copy = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (dest), dest, src);\n+  copy = build_gimple_modify_stmt (dest, src);\n   set_is_used (dest);\n \n   if (TREE_CODE (src) == ADDR_EXPR)\n@@ -1254,8 +1254,8 @@ insert_backedge_copies (void)\n \n \t\t  /* Create a new instance of the underlying variable of the \n \t\t     PHI result.  */\n-\t\t  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (result_var),\n-\t\t\t\t NULL_TREE, PHI_ARG_DEF (phi, i));\n+\t\t  stmt = build_gimple_modify_stmt (NULL_TREE,\n+\t\t\t\t\t\t   PHI_ARG_DEF (phi, i));\n \t\t  name = make_ssa_name (result_var, stmt);\n \t\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n "}, {"sha": "54e88479cdfc99c0dd71ed3cea9e7f3fcd0337c5", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,6 +1,7 @@\n /* Calculate branch probabilities, and basic block execution counts.\n    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n    based on some ideas from Dain Samples of UC Berkeley.\n    Further mangling by Bob Manson, Cygnus Support.\n@@ -171,11 +172,12 @@ tree_gen_edge_profiler (int edgeno, edge e)\n   tree tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n   tree tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n   tree ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n-  tree stmt1 = build2 (GIMPLE_MODIFY_STMT, gcov_type_node, tmp1, ref);\n-  tree stmt2 = build2 (GIMPLE_MODIFY_STMT, gcov_type_node, tmp2,\n-\t\t       build2 (PLUS_EXPR, gcov_type_node, \n-\t\t\t      tmp1, integer_one_node));\n-  tree stmt3 = build2 (GIMPLE_MODIFY_STMT, gcov_type_node, ref, tmp2);\n+  tree one = build_int_cst (gcov_type_node, 1);\n+  tree stmt1 = build_gimple_modify_stmt (tmp1, ref);\n+  tree stmt2 = build_gimple_modify_stmt (tmp2,\n+\t\t\t\t\t build2 (PLUS_EXPR, gcov_type_node,\n+\t\t\t\t\t\t tmp1, one));\n+  tree stmt3 = build_gimple_modify_stmt (ref, tmp2);\n   bsi_insert_on_edge (e, stmt1);\n   bsi_insert_on_edge (e, stmt2);\n   bsi_insert_on_edge (e, stmt3);\n@@ -282,13 +284,9 @@ tree_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n    */\n \n   tmp1 = create_tmp_var (ptr_void, \"PROF\");\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, \n-\t\t  build_pointer_type (get_gcov_type ()), \n-\t\t  ic_gcov_type_ptr_var, ref_ptr);\n-  stmt2 = build2 (GIMPLE_MODIFY_STMT, ptr_void, tmp1, \n-\t\t  unshare_expr (value->hvalue.value));\n-  stmt3 = build2 (GIMPLE_MODIFY_STMT, ptr_void, \n-\t\t  ic_void_ptr_var, tmp1);\n+  stmt1 = build_gimple_modify_stmt (ic_gcov_type_ptr_var, ref_ptr);\n+  stmt2 = build_gimple_modify_stmt (tmp1, unshare_expr (value->hvalue.value));\n+  stmt3 = build_gimple_modify_stmt (ic_void_ptr_var, tmp1);\n \n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);"}, {"sha": "f1914c3d51ec521672f15e765f312ef4e52edabe", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -2999,7 +2999,7 @@ scev_const_prop (void)\n \t  def = unshare_expr (def);\n \t  remove_phi_node (phi, NULL_TREE, false);\n \n-\t  ass = build2 (GIMPLE_MODIFY_STMT, void_type_node, rslt, NULL_TREE);\n+\t  ass = build_gimple_modify_stmt (rslt, NULL_TREE);\n \t  SSA_NAME_DEF_STMT (rslt) = ass;\n \t  {\n \t    block_stmt_iterator dest = bsi;"}, {"sha": "7db39c454f50a8e868f6dcc961ddd754fa373a34", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1742,7 +1742,7 @@ sra_build_assignment (tree dst, tree src)\n      anyway, there's little point in making tests and/or adding\n      conversions to ensure the types of src and dst are the same.\n      So we just assume type differences at this point are ok.  */\n-  return build2 (GIMPLE_MODIFY_STMT, void_type_node, dst, src);\n+  return build_gimple_modify_stmt (dst, src);\n }\n \n /* Generate a set of assignment statements in *LIST_P to copy all"}, {"sha": "49741dab1ee595cc8228d0454160ab081bd78d30", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -619,23 +619,23 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t  && outermost_invariant_loop_expr (rhs,\n \t\t\t\t\t    loop_containing_stmt (stmt)) == NULL)\n \t{\n-\t  tree lhs, stmt1, stmt2, var, name;\n+\t  tree lhs, stmt1, stmt2, var, name, tmp;\n \n \t  lhs = GENERIC_TREE_OPERAND (stmt, 0);\n \n \t  /* stmt must be GIMPLE_MODIFY_STMT.  */\n \t  var = create_tmp_var (TREE_TYPE (rhs), \"reciptmp\");\n \t  add_referenced_var (var);\n \n-\t  stmt1 = build2 (GIMPLE_MODIFY_STMT, void_type_node, var,\n-\t\t\t  build2 (RDIV_EXPR, TREE_TYPE (rhs),\n-\t\t\t\t  build_real (TREE_TYPE (rhs), dconst1),\n-\t\t\t\t  TREE_OPERAND (rhs, 1)));\n+\t  tmp = build2 (RDIV_EXPR, TREE_TYPE (rhs),\n+\t\t\tbuild_real (TREE_TYPE (rhs), dconst1),\n+\t\t\tTREE_OPERAND (rhs, 1));\n+\t  stmt1 = build_gimple_modify_stmt (var, tmp);\n \t  name = make_ssa_name (var, stmt1);\n \t  GIMPLE_STMT_OPERAND (stmt1, 0) = name;\n-\t  stmt2 = build2 (GIMPLE_MODIFY_STMT, void_type_node, lhs,\n-\t\t\t  build2 (MULT_EXPR, TREE_TYPE (rhs),\n-\t\t\t\t  name, TREE_OPERAND (rhs, 0)));\n+\t  tmp = build2 (MULT_EXPR, TREE_TYPE (rhs),\n+\t\t\tname, TREE_OPERAND (rhs, 0));\n+\t  stmt2 = build_gimple_modify_stmt (lhs, tmp);\n \n \t  /* Replace division stmt with reciprocal and multiply stmts.\n \t     The multiply stmt is not invariant, so update iterator"}, {"sha": "0bb999c40d63a95c9a9bef24cf804842ee04b293", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,5 @@\n /* Global, SSA-based optimizations using mathematical identities.\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -303,9 +303,10 @@ insert_reciprocals (block_stmt_iterator *def_bsi, struct occurrence *occ,\n       /* Make a variable with the replacement and substitute it.  */\n       type = TREE_TYPE (def);\n       recip_def = make_rename_temp (type, \"reciptmp\");\n-      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, recip_def,\n-\t\t         fold_build2 (RDIV_EXPR, type, build_one_cst (type),\n-\t\t\t\t      def));\n+      new_stmt = build_gimple_modify_stmt (recip_def,\n+\t\t\t\t\t   fold_build2 (RDIV_EXPR, type,\n+\t\t\t\t\t\t\tbuild_one_cst (type),\n+\t\t\t\t\t\t\tdef));\n   \n   \n       if (occ->bb_has_division)\n@@ -607,7 +608,7 @@ execute_cse_sincos_1 (tree name)\n     return;\n   res = make_rename_temp (TREE_TYPE (TREE_TYPE (fndecl)), \"sincostmp\");\n   call = build_call_expr (fndecl, 1, name);\n-  stmt = build2 (GIMPLE_MODIFY_STMT, NULL_TREE, res, call);\n+  stmt = build_gimple_modify_stmt (res, call);\n   def_stmt = SSA_NAME_DEF_STMT (name);\n   if (bb_for_stmt (def_stmt) == top_bb\n       && TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT)"}, {"sha": "fa63637fb6dba1b622b0892e70f1714f3236fd95", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,5 @@\n /* Tail call optimization on trees.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -560,8 +560,9 @@ adjust_accumulator_values (block_stmt_iterator bsi, tree m, tree a, edge back)\n \t    var = m_acc;\n \t  else\n \t    {\n-\t      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n-\t\t\t     build2 (MULT_EXPR, ret_type, m_acc, a));\n+\t      stmt = build_gimple_modify_stmt (NULL_TREE,\n+\t\t\t\t\t       build2 (MULT_EXPR, ret_type,\n+\t\t\t\t\t\t       m_acc, a));\n \n \t      tmp = create_tmp_var (ret_type, \"acc_tmp\");\n \t      add_referenced_var (tmp);\n@@ -574,8 +575,8 @@ adjust_accumulator_values (block_stmt_iterator bsi, tree m, tree a, edge back)\n       else\n \tvar = a;\n \n-      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n-\t\t     build2 (PLUS_EXPR, ret_type, a_acc, var));\n+      stmt = build_gimple_modify_stmt (NULL_TREE, build2 (PLUS_EXPR, ret_type,\n+\t\t\t\t\t\t\t  a_acc, var));\n       var = make_ssa_name (SSA_NAME_VAR (a_acc), stmt);\n       GIMPLE_STMT_OPERAND (stmt, 0) = var;\n       bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n@@ -584,8 +585,9 @@ adjust_accumulator_values (block_stmt_iterator bsi, tree m, tree a, edge back)\n \n   if (m)\n     {\n-      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n-\t\t     build2 (MULT_EXPR, ret_type, m_acc, m));\n+      stmt = build_gimple_modify_stmt (NULL_TREE,\n+\t\t\t\t       build2 (MULT_EXPR, ret_type,\n+\t\t\t\t\t       m_acc, m));\n       var = make_ssa_name (SSA_NAME_VAR (m_acc), stmt);\n       GIMPLE_STMT_OPERAND (stmt, 0) = var;\n       bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n@@ -638,8 +640,9 @@ adjust_return_value (basic_block bb, tree m, tree a)\n \n   if (m)\n     {\n-      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n-\t\t     build2 (MULT_EXPR, ret_type, m_acc, ret_var));\n+      stmt = build_gimple_modify_stmt (NULL_TREE,\n+\t\t\t\t       build2 (MULT_EXPR, ret_type,\n+\t\t\t\t\t       m_acc, ret_var));\n \n       tmp = create_tmp_var (ret_type, \"acc_tmp\");\n       add_referenced_var (tmp);\n@@ -653,8 +656,9 @@ adjust_return_value (basic_block bb, tree m, tree a)\n \n   if (a)\n     {\n-      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n-\t\t     build2 (PLUS_EXPR, ret_type, a_acc, var));\n+      stmt = build_gimple_modify_stmt (NULL_TREE,\n+\t\t\t\t       build2 (PLUS_EXPR, ret_type,\n+\t\t\t\t\t       a_acc, var));\n \n       tmp = create_tmp_var (ret_type, \"acc_tmp\");\n       add_referenced_var (tmp);"}, {"sha": "63255bd3fb14d88338c283707988338631a6fcb6", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,5 @@\n /* Analysis Utilities for Loop Vectorization.\n-   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Dorit Nuzman <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -674,8 +674,7 @@ vect_pattern_recog_1 (\n   var = create_tmp_var (pattern_type, \"patt\");\n   add_referenced_var (var);\n   var_name = make_ssa_name (var, NULL_TREE);\n-  pattern_expr = build2 (GIMPLE_MODIFY_STMT, void_type_node, var_name,\n-      \t\t\t pattern_expr);\n+  pattern_expr = build_gimple_modify_stmt (var_name, pattern_expr);\n   SSA_NAME_DEF_STMT (var_name) = pattern_expr;\n   bsi_insert_before (&si, pattern_expr, BSI_SAME_STMT);\n   ann = stmt_ann (pattern_expr);"}, {"sha": "6938841628d661d4d8eed91a71172f85f6d59f48", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 69, "deletions": 87, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -1,5 +1,5 @@\n /* Transformation Utilities for Loop Vectorization.\n-   Copyright (C) 2003,2004,2005,2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -323,7 +323,7 @@ vect_create_data_ref_ptr (tree stmt,\n \n   /* Create: p = (vectype *) initial_base  */\n   vec_stmt = fold_convert (vect_ptr_type, new_temp);\n-  vec_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vect_ptr, vec_stmt);\n+  vec_stmt = build_gimple_modify_stmt (vect_ptr, vec_stmt);\n   vect_ptr_init = make_ssa_name (vect_ptr, vec_stmt);\n   GIMPLE_STMT_OPERAND (vec_stmt, 0) = vect_ptr_init;\n   new_bb = bsi_insert_on_edge_immediate (pe, vec_stmt);\n@@ -416,8 +416,9 @@ bump_vector_ptr (tree dataref_ptr, tree ptr_incr, block_stmt_iterator *bsi,\n   use_operand_p use_p;\n   tree new_dataref_ptr;\n \n-  incr_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, ptr_var,\n-                build2 (PLUS_EXPR, vptr_type, dataref_ptr, update));\n+  incr_stmt = build_gimple_modify_stmt (ptr_var,\n+\t\t\t\t\tbuild2 (PLUS_EXPR, vptr_type,\n+\t\t\t\t\t\tdataref_ptr, update));\n   new_dataref_ptr = make_ssa_name (ptr_var, incr_stmt);\n   GIMPLE_STMT_OPERAND (incr_stmt, 0) = new_dataref_ptr;\n   vect_finish_stmt_generation (stmt, incr_stmt, bsi);\n@@ -491,7 +492,7 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n   new_var = vect_get_new_vect_var (vector_type, vect_simple_var, \"cst_\");\n   add_referenced_var (new_var); \n  \n-  init_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, new_var, vector_var);\n+  init_stmt = build_gimple_modify_stmt (new_var, vector_var);\n   new_temp = make_ssa_name (new_var, init_stmt);\n   GIMPLE_STMT_OPERAND (init_stmt, 0) = new_temp;\n \n@@ -579,11 +580,13 @@ get_initial_def_for_induction (tree stmt, tree iv_phi)\n   t = tree_cons (NULL_TREE, init_expr, t);\n   for (i = 1; i < nunits; i++)\n     {\n+      tree tmp;\n+\n       /* Create: new_name = new_name + step_expr  */\n       new_var = vect_get_new_vect_var (scalar_type, vect_scalar_var, \"var_\");\n       add_referenced_var (new_var);\n-      init_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, new_var,\n-                          fold_build2 (PLUS_EXPR, scalar_type, new_name, step_expr));\n+      tmp = fold_build2 (PLUS_EXPR, scalar_type, new_name, step_expr);\n+      init_stmt = build_gimple_modify_stmt (new_var, tmp);\n       new_name = make_ssa_name (new_var, init_stmt);\n       GIMPLE_STMT_OPERAND (init_stmt, 0) = new_name;\n \n@@ -631,8 +634,9 @@ get_initial_def_for_induction (tree stmt, tree iv_phi)\n   induc_def = PHI_RESULT (induction_phi);\n \n   /* Create the iv update inside the loop  */\n-  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, NULL_TREE,\n-                     build2 (PLUS_EXPR, vectype, induc_def, vec_step));\n+  new_stmt = build_gimple_modify_stmt (NULL_TREE,\n+\t\t\t\t       build2 (PLUS_EXPR, vectype,\n+\t\t\t\t\t       induc_def, vec_step));\n   vec_def = make_ssa_name (vec_dest, new_stmt);\n   GIMPLE_STMT_OPERAND (new_stmt, 0) = vec_def;\n   bsi = bsi_for_stmt (stmt);\n@@ -666,10 +670,11 @@ get_initial_def_for_induction (tree stmt, tree iv_phi)\n       prev_stmt_vinfo = vinfo_for_stmt (induction_phi);\n       for (i = 1; i < ncopies; i++)\n \t{\n+\t  tree tmp;\n+\n \t  /* vec_i = vec_prev + vec_{step*nunits}  */\n-\t\t\t \n-\t  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, NULL_TREE,\n-\t\t\tbuild2 (PLUS_EXPR, vectype, vec_def, vec_step));\n+\t  tmp = build2 (PLUS_EXPR, vectype, vec_def, vec_step);\n+\t  new_stmt = build_gimple_modify_stmt (NULL_TREE, tmp);\n \t  vec_def = make_ssa_name (vec_dest, new_stmt);\n \t  GIMPLE_STMT_OPERAND (new_stmt, 0) = vec_def;\n \t  bsi = bsi_for_stmt (stmt);\n@@ -1237,15 +1242,17 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \n   if (reduc_code < NUM_TREE_CODES)\n     {\n+      tree tmp;\n+\n       /*** Case 1:  Create:\n \t   v_out2 = reduc_expr <v_out1>  */\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"Reduce using direct vector reduction.\");\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n-\t\t\tbuild1 (reduc_code, vectype,  PHI_RESULT (new_phi)));\n+      tmp = build1 (reduc_code, vectype,  PHI_RESULT (new_phi));\n+      epilog_stmt = build_gimple_modify_stmt (vec_dest, tmp);\n       new_temp = make_ssa_name (vec_dest, epilog_stmt);\n       GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1301,19 +1308,14 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t       bit_offset /= 2)\n \t    {\n \t      tree bitpos = size_int (bit_offset);\n-\n-\t      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t\t  \t\t    vec_dest,\n-\t\t\t\t    build2 (shift_code, vectype,\n-\t\t\t\t\t    new_temp, bitpos));\n+\t      tree tmp = build2 (shift_code, vectype, new_temp, bitpos);\n+\t      epilog_stmt = build_gimple_modify_stmt (vec_dest, tmp);\n \t      new_name = make_ssa_name (vec_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n-\t      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t\t  \t\t    vec_dest,\n-\t\t\t\t    build2 (code, vectype,\n-\t\t\t\t\t    new_name, new_temp));\n+\t      tmp = build2 (code, vectype, new_name, new_temp);\n+\t      epilog_stmt = build_gimple_modify_stmt (vec_dest, tmp);\n \t      new_temp = make_ssa_name (vec_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1343,8 +1345,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t  rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n \t\t\t bitsize_zero_node);\n \t  BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t  epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t      \t\t\tnew_scalar_dest, rhs);\n+\t  epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n \t  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t  GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n \t  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1353,20 +1354,19 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t       bit_offset < vec_size_in_bits;\n \t       bit_offset += element_bitsize)\n \t    { \n+\t      tree tmp;\n \t      tree bitpos = bitsize_int (bit_offset);\n \t      tree rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n \t\t\t\t bitpos);\n \t\t\n \t      BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t\t  \t\t    new_scalar_dest, rhs);\t\n+\t      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\t\n \t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n-\t      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t\t  \t\tnew_scalar_dest,\n-\t\t\t\tbuild2 (code, scalar_type, new_name, new_temp));\n+\t      tmp = build2 (code, scalar_type, new_name, new_temp);\n+\t      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, tmp);\n \t      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1395,8 +1395,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \n       rhs = build3 (BIT_FIELD_REF, scalar_type, new_temp, bitsize, bitpos);\n       BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t  \t\t    new_scalar_dest, rhs);\n+      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp; \n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1411,9 +1410,8 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   \n   if (scalar_initial_def)\n     {\n-      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t  \t      new_scalar_dest,\n-                      build2 (code, scalar_type, new_temp, scalar_initial_def));\n+      tree tmp = build2 (code, scalar_type, new_temp, scalar_initial_def);\n+      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, tmp);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1745,7 +1743,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       else\n         expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1, \n \t\t\t\t\t\t\t\treduc_def);\n-      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, expr);\n+      new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n@@ -1928,7 +1926,7 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       vargs = nreverse (vargs);\n \n       rhs = build_function_call_expr (fndecl, vargs);\n-      new_stmt = build2 (GIMPLE_MODIFY_STMT, NULL_TREE, vec_dest, rhs);\n+      new_stmt = build_gimple_modify_stmt (vec_dest, rhs);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n \n@@ -2080,8 +2078,7 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n       new_stmt = build_call_expr (builtin_decl, 1, vec_oprnd0);\n \n       /* Arguments are ready. create the new vector stmt.  */\n-      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n-\t\t\t new_stmt);\n+      new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n@@ -2168,7 +2165,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n \n   /* Arguments are ready. create the new vector stmt.  */\n-  *vec_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, vec_oprnd);\n+  *vec_stmt = build_gimple_modify_stmt (vec_dest, vec_oprnd);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);\n   GIMPLE_STMT_OPERAND (*vec_stmt, 0) = new_temp;\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n@@ -2453,10 +2450,10 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       /* Arguments are ready. create the new vector stmt.  */\n                                                                                 \n       if (op_type == binary_op)\n-        new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n+        new_stmt = build_gimple_modify_stmt (vec_dest,\n                     build2 (code, vectype, vec_oprnd0, vec_oprnd1));\n       else\n-        new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n+        new_stmt = build_gimple_modify_stmt (vec_dest,\n                     build1 (code, vectype, vec_oprnd0));\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n@@ -2609,7 +2606,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n                                                                                 \n       /* Arguments are ready. Create the new vector stmt.  */\n       expr = build2 (code, vectype_out, vec_oprnd0, vec_oprnd1);\n-      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, expr);\n+      new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n@@ -2666,7 +2663,7 @@ vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n       else  \n         expr = build1 (code, vectype, vec_oprnd0); \n     } \n-  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, expr);\n+  new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n   new_temp = make_ssa_name (vec_dest, new_stmt); \n   GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp; \n   vect_finish_stmt_generation (stmt, new_stmt, bsi); \n@@ -2958,7 +2955,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n {\n   tree perm_dest, perm_stmt, vect1, vect2, high, low;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n-  tree scalar_dest;\n+  tree scalar_dest, tmp;\n   int i;\n   unsigned int j;\n   VEC(tree,heap) *first, *second;\n@@ -2989,13 +2986,10 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n           if (BYTES_BIG_ENDIAN)\n-\t    perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n-\t        \t\tbuild2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, \n-                                        vect1, vect2)); \n+\t    tmp = build2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, vect1, vect2); \n \t  else\n-            perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n-                                build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, \n-                                        vect1, vect2));\n+\t    tmp = build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, vect1, vect2);\n+\t  perm_stmt = build_gimple_modify_stmt (perm_dest, tmp);\n \t  high = make_ssa_name (perm_dest, perm_stmt);\n \t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = high;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n@@ -3010,13 +3004,10 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n \t  if (BYTES_BIG_ENDIAN)\n-\t    perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n-\t               \t        build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, \n- \t\t\t\t\tvect1, vect2));\n+\t    tmp = build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, vect1, vect2);\n \t  else\n-            perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n-                                build2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, \n-                                        vect1, vect2));\n+\t    tmp = build2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, vect1, vect2);\n+\t  perm_stmt = build_gimple_modify_stmt (perm_dest, tmp);\n \t  low = make_ssa_name (perm_dest, perm_stmt);\n \t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = low;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n@@ -3252,8 +3243,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n \t  data_ref = build_fold_indirect_ref (dataref_ptr);\n \t  /* Arguments are ready. Create the new vector stmt.  */\n-\t  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, data_ref, \n-\t\t\t     vec_oprnd);\n+\t  new_stmt = build_gimple_modify_stmt (data_ref, vec_oprnd);\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \n \t  /* Set the VDEFs for the vector pointer. If this virtual def\n@@ -3364,7 +3354,7 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n   ptr = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &init_addr, &inc, true,\n \t\t\t\t  NULL_TREE);\n   data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n-  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, data_ref);\n+  new_stmt = build_gimple_modify_stmt (vec_dest, data_ref);\n   new_temp = make_ssa_name (vec_dest, new_stmt);\n   GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n   new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n@@ -3382,8 +3372,7 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n       new_stmt = build_call_expr (builtin_decl, 1, init_addr);\n       vec_dest = vect_create_destination_var (scalar_dest, \n \t\t\t\t\t      TREE_TYPE (new_stmt));\n-      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n-\t  \t\t new_stmt);\n+      new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n@@ -3540,6 +3529,7 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n {\n   tree perm_dest, perm_stmt, data_ref, first_vect, second_vect;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+  tree tmp;\n   int i;\n   unsigned int j;\n \n@@ -3559,10 +3549,10 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  perm_dest = create_tmp_var (vectype, \"vect_perm_even\");\n \t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n-\t \n-\t  perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n-\t\t\t      build2 (VEC_EXTRACT_EVEN_EXPR, vectype, \n-\t\t\t\t      first_vect, second_vect));\n+\n+\t  tmp = build2 (VEC_EXTRACT_EVEN_EXPR, vectype,\n+\t\t\tfirst_vect, second_vect);\n+\t  perm_stmt = build_gimple_modify_stmt (perm_dest, tmp);\n \n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n \t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = data_ref;\n@@ -3576,9 +3566,9 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n \n-\t  perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n-\t\t\t      build2 (VEC_EXTRACT_ODD_EXPR, vectype, \n-\t\t\t\t      first_vect, second_vect));\n+\t  tmp = build2 (VEC_EXTRACT_ODD_EXPR, vectype, \n+\t\t\tfirst_vect, second_vect);\n+\t  perm_stmt = build_gimple_modify_stmt (perm_dest, tmp);\n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n \t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = data_ref;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n@@ -3940,8 +3930,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t      gcc_unreachable ();\n \t    }\n \t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-\t  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n-\t      \t\t     data_ref);\n+\t  new_stmt = build_gimple_modify_stmt (vec_dest, data_ref);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n@@ -3959,8 +3948,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \t      new_stmt =\n \t\tbuild3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, realignment_token);\n-\t      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n-\t\t  \t\t new_stmt);\n+\t      new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n \t      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n@@ -4208,8 +4196,7 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_cond_expr = build3 (VEC_COND_EXPR, vectype, \n \t\t\t  vec_compare, vec_then_clause, vec_else_clause);\n \n-  *vec_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n-      \t\t      vec_cond_expr);\n+  *vec_stmt = build_gimple_modify_stmt (vec_dest, vec_cond_expr);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);\n   GIMPLE_STMT_OPERAND (*vec_stmt, 0) = new_temp;\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n@@ -4953,7 +4940,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n {\n   VEC(tree,heap) *may_misalign_stmts\n     = LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo);\n-  tree ref_stmt;\n+  tree ref_stmt, tmp;\n   int mask = LOOP_VINFO_PTR_MASK (loop_vinfo);\n   tree mask_cst;\n   unsigned int i;\n@@ -4997,8 +4984,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n       add_referenced_var (addr_tmp);\n       addr_tmp_name = make_ssa_name (addr_tmp, NULL_TREE);\n       addr_stmt = fold_convert (int_ptrsize_type, addr_base);\n-      addr_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-                          addr_tmp_name, addr_stmt);\n+      addr_stmt = build_gimple_modify_stmt (addr_tmp_name, addr_stmt);\n       SSA_NAME_DEF_STMT (addr_tmp_name) = addr_stmt;\n       append_to_statement_list_force (addr_stmt, cond_expr_stmt_list);\n \n@@ -5011,11 +4997,9 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n           or_tmp = create_tmp_var (int_ptrsize_type, tmp_name);\n           add_referenced_var (or_tmp);\n           new_or_tmp_name = make_ssa_name (or_tmp, NULL_TREE);\n-          or_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t      \t\t    new_or_tmp_name,\n-                            build2 (BIT_IOR_EXPR, int_ptrsize_type,\n-\t                            or_tmp_name,\n-                                    addr_tmp_name));\n+\t  tmp = build2 (BIT_IOR_EXPR, int_ptrsize_type,\n+\t\t\tor_tmp_name, addr_tmp_name);\n+          or_stmt = build_gimple_modify_stmt (new_or_tmp_name, tmp);\n           SSA_NAME_DEF_STMT (new_or_tmp_name) = or_stmt;\n           append_to_statement_list_force (or_stmt, cond_expr_stmt_list);\n           or_tmp_name = new_or_tmp_name;\n@@ -5032,10 +5016,8 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   add_referenced_var (and_tmp);\n   and_tmp_name = make_ssa_name (and_tmp, NULL_TREE);\n \n-  and_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-                     and_tmp_name,\n-                     build2 (BIT_AND_EXPR, int_ptrsize_type,\n-                             or_tmp_name, mask_cst));\n+  tmp = build2 (BIT_AND_EXPR, int_ptrsize_type, or_tmp_name, mask_cst);\n+  and_stmt = build_gimple_modify_stmt (and_tmp_name, tmp);\n   SSA_NAME_DEF_STMT (and_tmp_name) = and_stmt;\n   append_to_statement_list_force (and_stmt, cond_expr_stmt_list);\n "}, {"sha": "74f63e2478829b6869e8a41c5dcedd00255d3391", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb07520cddaa13da40dbd6775c5ff3f1b22494c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=ebb07520cddaa13da40dbd6775c5ff3f1b22494c", "patch": "@@ -2993,22 +2993,20 @@ build_assert_expr_for (tree cond, tree v)\n   if (COMPARISON_CLASS_P (cond))\n     {\n       tree a = build2 (ASSERT_EXPR, TREE_TYPE (v), v, cond); \n-      assertion = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (v), n, a);\n+      assertion = build_gimple_modify_stmt (n, a);\n     }\n   else if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n     {\n       /* Given !V, build the assignment N = false.  */\n       tree op0 = TREE_OPERAND (cond, 0);\n       gcc_assert (op0 == v);\n-      assertion = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (v), n,\n-\t\t\t  boolean_false_node);\n+      assertion = build_gimple_modify_stmt (n, boolean_false_node);\n     }\n   else if (TREE_CODE (cond) == SSA_NAME)\n     {\n       /* Given V, build the assignment N = true.  */\n       gcc_assert (v == cond);\n-      assertion = build2 (GIMPLE_MODIFY_STMT,\n-\t  \t\t  TREE_TYPE (v), n, boolean_true_node);\n+      assertion = build_gimple_modify_stmt (n, boolean_true_node);\n     }\n   else\n     gcc_unreachable ();"}]}