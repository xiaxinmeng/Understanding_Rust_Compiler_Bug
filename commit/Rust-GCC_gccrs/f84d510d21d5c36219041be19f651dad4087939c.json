{"sha": "f84d510d21d5c36219041be19f651dad4087939c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg0ZDUxMGQyMWQ1YzM2MjE5MDQxYmUxOWY2NTFkYWQ0MDg3OTM5Yw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-05-29T16:03:43Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-05-29T16:03:43Z"}, "message": "char_pointer_assign.f90: Test character-pointerassignments and pointer assignments.\n\n2005-05-29 Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/char_pointer_assign.f90:\n\tTest character-pointerassignments and pointer assignments.\n\t* gfortran.dg/char_pointer_dummy.f90:\n\tTest character-pointer dummy arguments.\n\t* gfortran.dg/char_pointer_func.f90:\n\tTest character-pointer function returns.\n\t* gfortran.dg/char_pointer_dependency.f90:\n\tTest character-pointer functions with dependencies.\n\nFrom-SVN: r100325", "tree": {"sha": "f14c7025d133933f2528f7c3cf647662fb7ead10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f14c7025d133933f2528f7c3cf647662fb7ead10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f84d510d21d5c36219041be19f651dad4087939c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84d510d21d5c36219041be19f651dad4087939c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84d510d21d5c36219041be19f651dad4087939c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84d510d21d5c36219041be19f651dad4087939c/comments", "author": null, "committer": null, "parents": [{"sha": "72caba17ea465d1cfb1a4982f531566dcac27232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72caba17ea465d1cfb1a4982f531566dcac27232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72caba17ea465d1cfb1a4982f531566dcac27232"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "ee3da5245286771cef9ce341da8fb95300cc815c", "filename": "gcc/testsuite/gfortran.dg/char_pointer_assign.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84d510d21d5c36219041be19f651dad4087939c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_assign.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84d510d21d5c36219041be19f651dad4087939c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_assign.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_assign.f90?ref=f84d510d21d5c36219041be19f651dad4087939c", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+program char_pointer_assign\r\n+! Test character pointer assignments, required\r\n+! to fix PR18890 and PR21297\r\n+! Provided by Paul Thomas pault@gcc.gnu.org\r\n+  implicit none\r\n+  character*4, target        :: t1\r\n+  character*4, target        :: t2(4) =(/\"lmno\",\"lmno\",\"lmno\",\"lmno\"/)\r\n+  character*4                :: const\r\n+  character*4, pointer       :: c1, c3\r\n+  character*4, pointer       :: c2(:), c4(:)\n+  allocate (c3, c4(4))\r\n+! Scalars first.\r\n+  c3 = \"lmno\"          ! pointer = constant\r\n+  t1 = c3              ! target = pointer\r\n+  c1 => t1             ! pointer =>target\r\n+  c1(2:3) = \"nm\"\r\n+  c3 = c1              ! pointer = pointer\r\n+  c3(1:1) = \"o\"\r\n+  c3(4:4) = \"l\"\r\n+  c1 => c3             ! pointer => pointer\r\n+  if (t1 /= \"lnmo\") call abort ()\r\n+  if (c1 /= \"onml\") call abort ()\r\n+\r\n+! Now arrays.\r\n+  c4 = \"lmno\"          ! pointer = constant\r\n+  t2 = c4              ! target = pointer\n+  c2 => t2             ! pointer =>target\n+  const = c2(1)\n+  const(2:3) =\"nm\"     ! c2(:)(2:3) = \"nm\" is still broken\r\n+  c2 = const\r\n+  c4 = c2              ! pointer = pointer\r\n+  const = c4(1)\n+  const(1:1) =\"o\"      ! c4(:)(1:1) = \"o\" is still broken\r\n+  const(4:4) =\"l\"      ! c4(:)(4:4) = \"l\" is still broken\r\n+  c4 = const\r\n+  c2 => c4             ! pointer => pointer\r\n+  if (any (t2 /= \"lnmo\")) call abort ()\r\n+  if (any (c2 /= \"onml\")) call abort ()\r\n+  deallocate (c3, c4)\r\n+end program char_pointer_assign\n\\ No newline at end of file"}, {"sha": "94976cbb33c63b6c17145ce2a0e763f12588b191", "filename": "gcc/testsuite/gfortran.dg/char_pointer_dependency.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84d510d21d5c36219041be19f651dad4087939c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_dependency.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84d510d21d5c36219041be19f651dad4087939c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_dependency.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_dependency.f90?ref=f84d510d21d5c36219041be19f651dad4087939c", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! Test assignments from character pointer functions with dependencies\n+! are correctly resolved.\n+! Provided by Paul Thomas pault@gcc.gnu.org\n+program char_pointer_dependency\n+  implicit none\n+  character*4, pointer       :: c2(:)\n+  allocate (c2(2))\n+  c2 = (/\"abcd\",\"efgh\"/)\n+  c2 = afoo (c2)\n+  if (c2(1) /= \"efgh\") call abort ()\n+  if (c2(2) /= \"abcd\") call abort ()\n+  deallocate (c2)\n+contains\n+  function afoo (ac0) result (ac1)\n+    integer                    :: j\n+    character*4                :: ac0(:)\n+    character*4, pointer       :: ac1(:)\n+    allocate (ac1(2))\n+    do j = 1,2\n+      ac1(j) = ac0(3-j)\n+    end do\n+  end function afoo\n+end program char_pointer_dependency"}, {"sha": "1935de51113818044c4c0fa98f201bcbfd4d7a72", "filename": "gcc/testsuite/gfortran.dg/char_pointer_dummy.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84d510d21d5c36219041be19f651dad4087939c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_dummy.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84d510d21d5c36219041be19f651dad4087939c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_dummy.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_dummy.f90?ref=f84d510d21d5c36219041be19f651dad4087939c", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+program char_pointer_dummy\r\n+! Test character pointer dummy arguments, required\r\n+! to fix PR16939 and PR18689\r\n+! Provided by Paul Thomas pault@gcc.gnu.org\r\n+  implicit none\r\n+  character*4                :: c0\r\n+  character*4, pointer       :: c1\r\n+  character*4, pointer       :: c2(:)\r\n+  allocate (c1, c2(1))\r\n+! Check that we have not broken non-pointer characters.\r\n+  c0 = \"wxyz\"\r\n+  call foo (c0)\r\n+! Now the pointers\r\n+  c1 = \"wxyz\"\r\n+  call sfoo (c1)\r\n+  c2 = \"wxyz\"\r\n+  call afoo (c2)\r\n+  deallocate (c1, c2)\r\n+contains\r\n+  subroutine foo (cc1)\r\n+    character*4                :: cc1\r\n+    if (cc1 /= \"wxyz\") call abort ()\r\n+  end subroutine foo\r\n+  subroutine sfoo (sc1)\r\n+    character*4, pointer       :: sc1\r\n+    if (sc1 /= \"wxyz\") call abort ()\r\n+  end subroutine sfoo\r\n+  subroutine afoo (ac1)\r\n+    character*4, pointer       :: ac1(:)\r\n+    if (ac1(1) /= \"wxyz\") call abort ()\r\n+  end subroutine afoo\r\n+end program char_pointer_dummy\n\\ No newline at end of file"}, {"sha": "ddca76f40b211b6baf4b3c428653404cb4669dd7", "filename": "gcc/testsuite/gfortran.dg/char_pointer_func.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84d510d21d5c36219041be19f651dad4087939c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_func.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84d510d21d5c36219041be19f651dad4087939c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_func.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_func.f90?ref=f84d510d21d5c36219041be19f651dad4087939c", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+program char_pointer_func\n+! Test assignments from character pointer functions, required\n+! to fix PR17192 and PR17202\n+! Provided by Paul Thomas pault@gcc.gnu.org\n+  implicit none\n+  character*4                :: c0\n+  character*4, pointer       :: c1\n+  character*4, pointer       :: c2(:)\n+  allocate (c1, c2(1))\n+! Check that we have not broken non-pointer characters.\n+  c0 = foo ()\n+  if (c0 /= \"abcd\") call abort ()\n+! Value assignments\n+  c1 = sfoo ()\n+  if (c1 /= \"abcd\") call abort ()\n+  c2 = afoo (c0)\n+  if (c2(1) /= \"abcd\") call abort ()\n+  deallocate (c1, c2)\n+! Pointer assignments\n+  c1 => sfoo ()\n+  if (c1 /= \"abcd\") call abort ()\n+  c2 => afoo (c0)\n+  if (c2(1) /= \"abcd\") call abort ()\n+  deallocate (c1, c2)\n+contains\n+  function foo () result (cc1)\n+    character*4                :: cc1\n+    cc1 = \"abcd\"\n+  end function foo\n+  function sfoo () result (sc1)\n+    character*4, pointer       :: sc1\n+    allocate (sc1)\n+    sc1 = \"abcd\"\n+  end function sfoo\n+  function afoo (c0) result (ac1)\n+    character*4                :: c0\n+    character*4, pointer       :: ac1(:)\n+    allocate (ac1(1))\n+    ac1 = \"abcd\"\n+  end function afoo\n+end program char_pointer_func"}]}