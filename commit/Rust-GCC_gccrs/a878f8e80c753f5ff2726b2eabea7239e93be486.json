{"sha": "a878f8e80c753f5ff2726b2eabea7239e93be486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg3OGY4ZTgwYzc1M2Y1ZmYyNzI2YjJlYWJlYTcyMzllOTNiZTQ4Ng==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-01-18T15:52:49Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-01-18T15:52:49Z"}, "message": "re PR fortran/64578 ([OOP] Seg-fault and ICE with unlimited polymorphic array pointer function)\n\n2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/64578\n\t* trans-expr.c (gfc_trans_subcomponent_assign): Use a deep copy\n\tfor allocatable components, where the source is a variable.\n\n2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/64578\n\t* gfortran.dg/block_13.f08: New test\n\nFrom-SVN: r219818", "tree": {"sha": "75b1935cf96f9816a14a93f980a4101f05050482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75b1935cf96f9816a14a93f980a4101f05050482"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a878f8e80c753f5ff2726b2eabea7239e93be486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a878f8e80c753f5ff2726b2eabea7239e93be486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a878f8e80c753f5ff2726b2eabea7239e93be486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a878f8e80c753f5ff2726b2eabea7239e93be486/comments", "author": null, "committer": null, "parents": [{"sha": "fded3d73da69224b9abdd03fa71d274c76fbe3c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fded3d73da69224b9abdd03fa71d274c76fbe3c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fded3d73da69224b9abdd03fa71d274c76fbe3c6"}], "stats": {"total": 81, "additions": 79, "deletions": 2}, "files": [{"sha": "3f308f79fc1b5e8436798e794c752a20b02675b1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a878f8e80c753f5ff2726b2eabea7239e93be486/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a878f8e80c753f5ff2726b2eabea7239e93be486/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a878f8e80c753f5ff2726b2eabea7239e93be486", "patch": "@@ -1,3 +1,9 @@\n+2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/64578\n+\t* trans-expr.c (gfc_trans_subcomponent_assign): Use a deep copy\n+\tfor allocatable components, where the source is a variable.\n+\n 2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/55901"}, {"sha": "fca6d33011906590fd5005849ed321621f86e199", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a878f8e80c753f5ff2726b2eabea7239e93be486/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a878f8e80c753f5ff2726b2eabea7239e93be486/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a878f8e80c753f5ff2726b2eabea7239e93be486", "patch": "@@ -6474,8 +6474,16 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&block, &se.pre);\n-\t  gfc_add_modify (&block, dest,\n-\t\t\t       fold_convert (TREE_TYPE (dest), se.expr));\n+\t  if (cm->ts.u.derived->attr.alloc_comp\n+\t      && expr->expr_type == EXPR_VARIABLE)\n+\t    {\n+\t      tmp = gfc_copy_alloc_comp (cm->ts.u.derived, se.expr,\n+\t\t\t\t\t dest, expr->rank);\n+\t      gfc_add_expr_to_block (&block, tmp);\n+\t    }\n+\t  else\n+\t    gfc_add_modify (&block, dest,\n+\t\t\t    fold_convert (TREE_TYPE (dest), se.expr));\n \t  gfc_add_block_to_block (&block, &se.post);\n \t}\n       else"}, {"sha": "8871283b6803b02a136de22586d0fb1748eba659", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a878f8e80c753f5ff2726b2eabea7239e93be486/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a878f8e80c753f5ff2726b2eabea7239e93be486/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a878f8e80c753f5ff2726b2eabea7239e93be486", "patch": "@@ -1,3 +1,8 @@\n+2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/64578\n+\t* gfortran.dg/block_13.f08: New test\n+\n 2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/55901"}, {"sha": "5956a90c240cfe6da7efa4ec97e980beb0cca1a0", "filename": "gcc/testsuite/gfortran.dg/block_13.f08", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a878f8e80c753f5ff2726b2eabea7239e93be486/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_13.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a878f8e80c753f5ff2726b2eabea7239e93be486/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_13.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_13.f08?ref=a878f8e80c753f5ff2726b2eabea7239e93be486", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+! Checks the fix for PR57959. The first assignment to a was proceeding\n+! without a deep copy. Since the anum field of 'uKnot' was being pointed\n+! to twice, the frees in the finally block, following the BLOCK caused\n+! a double free.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+program main\n+  implicit none\n+  type :: type1\n+    real, allocatable :: anum\n+    character(len = :), allocatable :: chr\n+  end type type1\n+  real, parameter :: five = 5.0\n+  real, parameter :: point_one = 0.1\n+\n+  type :: type2\n+    type(type1) :: temp\n+  end type type2\n+  block\n+    type(type1) :: uKnot\n+    type(type2) :: a\n+\n+    uKnot = type1 (five, \"hello\")\n+    call check (uKnot%anum, five)\n+    call check_chr (uKnot%chr, \"hello\")\n+\n+    a = type2 (uKnot) ! Deep copy needed here\n+    call check (a%temp%anum, five)\n+    call check_chr (a%temp%chr, \"hello\")\n+\n+    a = type2 (type1(point_one, \"goodbye\")) ! Not here\n+    call check (a%temp%anum, point_one)\n+    call check_chr (a%temp%chr, \"goodbye\")\n+\n+    a = type2 (foo (five)) ! Not here\n+    call check (a%temp%anum, five)\n+    call check_chr (a%temp%chr, \"foo set me\")\n+  end block\n+contains\n+  subroutine check (arg1, arg2)\n+    real :: arg1, arg2\n+    if (arg1 .ne. arg2) call abort ()\n+  end subroutine\n+\n+  subroutine check_chr (arg1, arg2)\n+    character(*) :: arg1, arg2\n+    if (len (arg1) .ne. len (arg2)) call abort\n+    if (arg1 .ne. arg2) call abort\n+  end subroutine\n+\n+  type(type1) function foo (arg)\n+    real :: arg\n+    foo = type1 (arg, \"foo set me\")\n+  end function\n+end\n+"}]}