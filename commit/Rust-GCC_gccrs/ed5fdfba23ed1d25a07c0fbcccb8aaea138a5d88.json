{"sha": "ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ1ZmRmYmEyM2VkMWQyNWEwN2MwZmJjY2NiOGFhZWExMzhhNWQ4OA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2016-11-10T11:06:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2016-11-10T11:06:32Z"}, "message": "debug/78112: remove recent duplicates for DW_TAG_subprogram attributes\n\nDisable unnecessary calls to dwarf2out_decl for the parents of nested\nfunctions. This fixes a libstdc++ build regression on\nx86_64-apple-darwin, as these calls used to add duplicate attributes\n(for instance DW_AT_inline and DW_AT_object_pointer) to the\ncorresponding DW_TAG_subprogram DIE.\n\nBootstrapped and regtested on x86_64-linux.\n\ngcc/\n\tPR debug/78112\n\t* dwarf2out.c (dwarf2out_early_global_decl): Call dwarf2out_decl\n\ton the context only when it has no DIE yet.\n\ntestsuite/\n\tPR debug/78112\n\t* g++.dg/pr78112.C: New testcase\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r242035", "tree": {"sha": "15279e8dd6695f3a48cb4d1822e264443453539f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15279e8dd6695f3a48cb4d1822e264443453539f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b854516cc1943199ce15a23df340a7d2d7196a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b854516cc1943199ce15a23df340a7d2d7196a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b854516cc1943199ce15a23df340a7d2d7196a56"}], "stats": {"total": 182, "additions": 178, "deletions": 4}, "files": [{"sha": "f5c9add7720425575b8cc83020329145970b3334", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88", "patch": "@@ -1,3 +1,9 @@\n+2016-11-10  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\tPR debug/78112\n+\t* dwarf2out.c (dwarf2out_early_global_decl): Call dwarf2out_decl\n+\ton the context only when it has no DIE yet.\n+\n 2016-11-10  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.h (target_cpus): Delete."}, {"sha": "f9ec0903b78904cbe8f531040188acd1eb7e7b1f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88", "patch": "@@ -25256,11 +25256,11 @@ dwarf2out_early_global_decl (tree decl)\n \t  if (!DECL_STRUCT_FUNCTION (decl))\n \t    goto early_decl_exit;\n \n-\t  /* For nested functions, emit DIEs for the parents first so that all\n-\t     nested DIEs are generated at the proper scope in the first\n-\t     shot.  */\n+\t  /* For nested functions, make sure we have DIEs for the parents first\n+\t     so that all nested DIEs are generated at the proper scope in the\n+\t     first shot.  */\n \t  tree context = decl_function_context (decl);\n-\t  if (context != NULL)\n+\t  if (context != NULL && lookup_decl_die (context) == NULL)\n \t    {\n \t      current_function_decl = context;\n \t      dwarf2out_decl (context);"}, {"sha": "9dfd15c5e458a40e51a78373d4cfac5ab77df929", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88", "patch": "@@ -1,3 +1,9 @@\n+2016-11-10  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/78112\n+\t* g++.dg/pr78112.C: New testcase\n+\n 2016-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/asan/asan_test.C: Remove -Wno-format, add"}, {"sha": "95d9e59fb64aa2ed75a747acbf5e8947840c9ba2", "filename": "gcc/testsuite/g++.dg/pr78112.C", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78112.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78112.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78112.C?ref=ed5fdfba23ed1d25a07c0fbcccb8aaea138a5d88", "patch": "@@ -0,0 +1,162 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-g -dA -std=gnu++11\" } */\n+/* { dg-final { scan-assembler-times DW_AT_inline 6 } } */\n+/* { dg-final { scan-assembler-times DW_AT_object_pointer 37 } } */\n+namespace std\n+{\n+template <typename _Tp> struct integral_constant\n+{\n+  static constexpr _Tp value = 0;\n+};\n+template <int> using __bool_constant = integral_constant<int>;\n+struct __not_ : integral_constant<int>\n+{\n+};\n+template <typename, typename, template <typename...> class _Op,\n+          typename... _Args>\n+struct __detector\n+{\n+  using type = _Op<_Args...>;\n+};\n+template <typename _Default, template <typename...> class _Op,\n+          typename... _Args>\n+using __detected_or = __detector<_Default, void, _Op, _Args...>;\n+template <typename _Default, template <typename...> class _Op,\n+          typename... _Args>\n+using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;\n+template <template <typename...> class _Default,\n+          template <typename...> class _Op, typename... _Args>\n+using __detected_or_t_ = __detected_or_t<_Default<_Args...>, _Op, _Args...>;\n+template <typename, typename> struct pair;\n+template <typename, typename> using __replace_first_arg_t = int;\n+}\n+class new_allocator\n+{\n+};\n+namespace std\n+{\n+template <typename> using __allocator_base = new_allocator;\n+template <typename> class allocator : __allocator_base<int>\n+{\n+};\n+template <typename> struct equal_to;\n+struct __allocator_traits_base\n+{\n+  template <typename _Alloc, typename _Up>\n+  using __rebind = typename _Alloc::template rebind<_Up>::other;\n+};\n+template <typename _Alloc, typename _Up>\n+using __alloc_rebind\n+    = __detected_or_t_<__replace_first_arg_t,\n+                       __allocator_traits_base::__rebind, _Alloc, _Up>;\n+}\n+struct __alloc_traits\n+{\n+  static int _S_select_on_copy;\n+};\n+namespace std\n+{\n+template <typename> struct hash;\n+namespace __detail\n+{\n+struct _Select1st;\n+struct _Hashtable_traits\n+{\n+  using __hash_cached = __bool_constant<0>;\n+};\n+template <typename, int> struct _Hash_node;\n+template <typename _Value> struct _Hash_node<_Value, 0>\n+{\n+  int &_M_v ();\n+};\n+struct _Mod_range_hashing;\n+struct _Default_ranged_hash;\n+struct _Prime_rehash_policy\n+{\n+  using __has_load_factor = integral_constant<int>;\n+};\n+struct _Map_base\n+{\n+};\n+struct _Insert\n+{\n+};\n+template <typename _Policy>\n+using __has_load_factor = typename _Policy::__has_load_factor;\n+template <typename _RehashPolicy, typename,\n+          typename = __detected_or_t<integral_constant<bool>,\n+                                     __has_load_factor, _RehashPolicy> >\n+struct _Rehash_base;\n+template <typename _RehashPolicy, typename _Traits>\n+struct _Rehash_base<_RehashPolicy, _Traits, integral_constant<int> > {};\n+struct _Hashtable_ebo_helper { template <typename _OtherTp> _Hashtable_ebo_helper (_OtherTp); };\n+struct _Hashtable_base {};\n+struct _Equality {};\n+template <typename _NodeAlloc> struct _Hashtable_alloc : _Hashtable_ebo_helper\n+{\n+  using __ebo_node_alloc = _Hashtable_ebo_helper;\n+  using __node_type = typename _NodeAlloc::value_type;\n+  using __node_alloc_traits = __alloc_traits;\n+  template <typename _Alloc> _Hashtable_alloc (_Alloc) : __ebo_node_alloc (0) {}\n+  template <typename... _Args> __node_type *_M_allocate_node (...);\n+};\n+}\n+template <typename, typename> using __cache_default = __not_;\n+template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2,\n+          typename _Hash, typename _RehashPolicy, typename _Traits>\n+struct _Hashtable : __detail::_Hashtable_base, __detail::_Map_base, __detail::_Insert, __detail::_Rehash_base<_RehashPolicy, int>,\n+  __detail::_Equality, __detail:: _Hashtable_alloc<__alloc_rebind<_Alloc, __detail::_Hash_node<_Value, _Traits::__hash_cached::value> > >\n+{\n+  using __traits_type = _Traits;\n+  using __hash_cached = typename __traits_type::__hash_cached;\n+  using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;\n+  using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;\n+  using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;\n+  using typename __hashtable_alloc::__node_alloc_traits;\n+  _Key key_type;\n+  _RehashPolicy _M_rehash_policy;\n+  template <typename _NodeGenerator>\n+  void _M_assign (const _Hashtable &, const _NodeGenerator &);\n+  _Hashtable ();\n+  _Hashtable (const _Hashtable &);\n+};\n+template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2,\n+          typename _Hash, typename _RehashPolicy, typename _Traits>\n+template <typename _NodeGenerator>\n+void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy,\n+                _Traits>::_M_assign (const _Hashtable &__ht, const _NodeGenerator &__node_gen) try {\n+__node_type *__this_n = __node_gen (0); } catch (...) {}\n+template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2,\n+          typename _Hash, typename _RehashPolicy, typename _Traits>\n+_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable (const _Hashtable &__ht)\n+    : __hashtable_alloc (__node_alloc_traits::_S_select_on_copy), _M_rehash_policy ()\n+{\n+  _M_assign (__ht, [this](__node_type *__n) { return this->_M_allocate_node (__n->_M_v ()); });\n+}\n+template <bool _Cache> using __umap_traits = __detail::_Hashtable_traits;\n+template <typename _Key, typename _Tp, typename _Hash = hash<_Key>, typename _Pred = std::equal_to<_Key>,\n+          typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n+          typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value> >\n+using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, __detail::_Select1st, _Pred, _Hash,\n+                                    __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, _Tr>;\n+template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>,\n+          class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n+struct unordered_map\n+{\n+  typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;\n+  _Hashtable _M_h;\n+  unordered_map (const int &__a) : _M_h () {}\n+};\n+}\n+struct uneq_allocator_base {};\n+template <typename Tp> struct uneq_allocator : uneq_allocator_base { typedef Tp value_type; };\n+template <typename Tp, typename Alloc = std::allocator<Tp> >\n+struct Trans_NS___gnu_test_propagating_allocator : public uneq_allocator<Tp>\n+{\n+  template <typename Up> struct rebind { typedef Trans_NS___gnu_test_propagating_allocator<Up, int> other; };\n+};\n+void fn1 ()\n+{\n+  std::unordered_map<int, int, int, int, Trans_NS___gnu_test_propagating_allocator<int> > v1 (0);\n+  std::unordered_map<int, int, int, int, Trans_NS___gnu_test_propagating_allocator<int> > v2 (v1);\n+}"}]}