{"sha": "61b644c2ae3055e797ba6c4de28888565b667b35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFiNjQ0YzJhZTMwNTVlNzk3YmE2YzRkZTI4ODg4NTY1YjY2N2IzNQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-07-23T09:53:45Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-07-23T09:53:45Z"}, "message": "re PR fortran/44709 (BLOCK and GOTO/EXIT/CYCLE)\n\n2010-07-23  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/44709\n\t* gfortran.h (gfc_find_symtree_in_proc): New method.\n\t* symbol.c (gfc_find_symtree_in_proc): New method.\n\t* match.c (match_exit_cycle): Look for loop name also in parent\n\tnamespaces within current procedure.\n\n2010-07-23  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/44709\n\t* gfortran.dg/exit_1.f08: New test.\n\t* gfortran.dg/exit_2.f08: New test.\n\nFrom-SVN: r162450", "tree": {"sha": "3d969e0ac991bf7dbb5c018e6d1d583e084a1d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d969e0ac991bf7dbb5c018e6d1d583e084a1d98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61b644c2ae3055e797ba6c4de28888565b667b35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b644c2ae3055e797ba6c4de28888565b667b35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b644c2ae3055e797ba6c4de28888565b667b35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b644c2ae3055e797ba6c4de28888565b667b35/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed3100b2ed8224bafd294f7c56390daed9bbc2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3100b2ed8224bafd294f7c56390daed9bbc2bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3100b2ed8224bafd294f7c56390daed9bbc2bd"}], "stats": {"total": 136, "additions": 134, "deletions": 2}, "files": [{"sha": "80b48764948c223c16b8c67a407abfbf1b79d78c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=61b644c2ae3055e797ba6c4de28888565b667b35", "patch": "@@ -1,3 +1,11 @@\n+2010-07-23  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/44709\n+\t* gfortran.h (gfc_find_symtree_in_proc): New method.\n+\t* symbol.c (gfc_find_symtree_in_proc): New method.\n+\t* match.c (match_exit_cycle): Look for loop name also in parent\n+\tnamespaces within current procedure.\n+\n 2010-07-22  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/45019"}, {"sha": "401e501c41ddcad7993a99246938206c7ffd1af8", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=61b644c2ae3055e797ba6c4de28888565b667b35", "patch": "@@ -2512,6 +2512,7 @@ gfc_user_op *gfc_get_uop (const char *);\n gfc_user_op *gfc_find_uop (const char *, gfc_namespace *);\n void gfc_free_symbol (gfc_symbol *);\n gfc_symbol *gfc_new_symbol (const char *, gfc_namespace *);\n+gfc_symtree* gfc_find_symtree_in_proc (const char *, gfc_namespace *);\n int gfc_find_symbol (const char *, gfc_namespace *, int, gfc_symbol **);\n int gfc_find_sym_tree (const char *, gfc_namespace *, int, gfc_symtree **);\n int gfc_get_symbol (const char *, gfc_namespace *, gfc_symbol **);"}, {"sha": "92580e359dbdf5e758ece2f9b990b6e9ea1f5b6a", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=61b644c2ae3055e797ba6c4de28888565b667b35", "patch": "@@ -2006,7 +2006,10 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n     sym = NULL;\n   else\n     {\n-      m = gfc_match (\"% %s%t\", &sym);\n+      char name[GFC_MAX_SYMBOL_LEN + 1];\n+      gfc_symtree* stree;\n+\n+      m = gfc_match (\"% %n%t\", name);\n       if (m == MATCH_ERROR)\n \treturn MATCH_ERROR;\n       if (m == MATCH_NO)\n@@ -2015,10 +2018,22 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \t  return MATCH_ERROR;\n \t}\n \n+      /* Find the corresponding symbol.  If there's a BLOCK statement\n+\t between here and the label, it is not in gfc_current_ns but a parent\n+\t namespace!  */\n+      stree = gfc_find_symtree_in_proc (name, gfc_current_ns);\n+      if (!stree)\n+\t{\n+\t  gfc_error (\"Name '%s' in %s statement at %C is unknown\",\n+\t\t     name, gfc_ascii_statement (st));\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      sym = stree->n.sym;\n       if (sym->attr.flavor != FL_LABEL)\n \t{\n \t  gfc_error (\"Name '%s' in %s statement at %C is not a loop name\",\n-\t\t     sym->name, gfc_ascii_statement (st));\n+\t\t     name, gfc_ascii_statement (st));\n \t  return MATCH_ERROR;\n \t}\n     }"}, {"sha": "18f7b253a28843713f2b01c073fe19bd6b9a7411", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=61b644c2ae3055e797ba6c4de28888565b667b35", "patch": "@@ -2565,6 +2565,27 @@ select_type_insert_tmp (gfc_symtree **st)\n }\n \n \n+/* Look for a symtree in the current procedure -- that is, go up to\n+   parent namespaces but only if inside a BLOCK.  Returns NULL if not found.  */\n+\n+gfc_symtree*\n+gfc_find_symtree_in_proc (const char* name, gfc_namespace* ns)\n+{\n+  while (ns)\n+    {\n+      gfc_symtree* st = gfc_find_symtree (ns->sym_root, name);\n+      if (st)\n+\treturn st;\n+\n+      if (!ns->construct_entities)\n+\tbreak;\n+      ns = ns->parent;\n+    }\n+\n+  return NULL;\n+}\n+\n+\n /* Search for a symtree starting in the current namespace, resorting to\n    any parent namespaces if requested by a nonzero parent_flag.\n    Returns nonzero if the name is ambiguous.  */"}, {"sha": "550b4b1bba78a2bb0f7d2c857df54c6fa56a2430", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=61b644c2ae3055e797ba6c4de28888565b667b35", "patch": "@@ -1,3 +1,9 @@\n+2010-07-23  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/44709\n+\t* gfortran.dg/exit_1.f08: New test.\n+\t* gfortran.dg/exit_2.f08: New test.\n+\n 2010-07-22  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR tree-optimization/39839"}, {"sha": "9ebc2eccb507b5f3675d97e64b86d00b62439637", "filename": "gcc/testsuite/gfortran.dg/exit_1.f08", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_1.f08?ref=61b644c2ae3055e797ba6c4de28888565b667b35", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fall-intrinsics\" }\n+\n+! PR fortran/44709\n+! Check that exit and cycle from within a BLOCK works for loops as expected.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER :: i\n+  \n+  ! Simple exit without loop name.\n+  DO\n+    BLOCK\n+      EXIT\n+    END BLOCK\n+    CALL abort ()\n+  END DO\n+\n+  ! Cycle without loop name.\n+  DO i = 1, 1\n+    BLOCK\n+      CYCLE\n+    END BLOCK\n+    CALL abort ()\n+  END DO\n+\n+  ! Exit loop by name from within a BLOCK.\n+  loop1: DO\n+    DO\n+      BLOCK\n+        EXIT loop1\n+      END BLOCK\n+      CALL abort ()\n+    END DO\n+    CALL abort ()\n+  END DO loop1\n+\n+  ! Cycle loop by name from within a BLOCK.\n+  loop2: DO i = 1, 1\n+    loop3: DO\n+      BLOCK\n+        CYCLE loop2\n+      END BLOCK\n+      CALL abort ()\n+    END DO loop3\n+    CALL abort ()\n+  END DO loop2\n+END PROGRAM main"}, {"sha": "23e7009cbf823701fc68f69a1b7357b1fde7f8bf", "filename": "gcc/testsuite/gfortran.dg/exit_2.f08", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b644c2ae3055e797ba6c4de28888565b667b35/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_2.f08?ref=61b644c2ae3055e797ba6c4de28888565b667b35", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+\n+! PR fortran/44709\n+! Check that the resolving of loop names in parent namespaces introduced to\n+! handle intermediate BLOCK's does not go too far and other sanity checks.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  \n+  EXIT ! { dg-error \"is not within a loop\" }\n+  EXIT foobar ! { dg-error \"is unknown\" }\n+  EXIT main ! { dg-error \"is not a loop name\" }\n+\n+  mainLoop: DO\n+    CALL test ()\n+  END DO mainLoop\n+\n+  otherLoop: DO\n+    EXIT mainLoop ! { dg-error \"is not within loop 'mainloop'\" }\n+  END DO otherLoop\n+\n+CONTAINS\n+\n+  SUBROUTINE test ()\n+    EXIT mainLoop ! { dg-error \"is unknown\" }\n+  END SUBROUTINE test\n+\n+END PROGRAM main"}]}