{"sha": "708c7f7fb884199b55bede6d00bd7ed6021e6dbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4YzdmN2ZiODg0MTk5YjU1YmVkZTZkMDBiZDdlZDYwMjFlNmRiZg==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2015-02-23T23:24:59Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2015-02-23T23:24:59Z"}, "message": "re PR target/65153 ([SH][4.9 Regression] \"insn does not satisfy its constraints\" when compiling libmcrypt)\n\nPR target/65153\n[SH] Fix PR target/65153 with removing movsicc_true+3 peephole2.\n\nFrom-SVN: r220922", "tree": {"sha": "828c7fdf72d754ff675d384ebc37fa29ac63a560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/828c7fdf72d754ff675d384ebc37fa29ac63a560"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/708c7f7fb884199b55bede6d00bd7ed6021e6dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708c7f7fb884199b55bede6d00bd7ed6021e6dbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/708c7f7fb884199b55bede6d00bd7ed6021e6dbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/comments", "author": null, "committer": null, "parents": [{"sha": "025e5647099ed6387bd4d5f4a856c7cca77ca244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025e5647099ed6387bd4d5f4a856c7cca77ca244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/025e5647099ed6387bd4d5f4a856c7cca77ca244"}], "stats": {"total": 218, "additions": 7, "deletions": 211}, "files": [{"sha": "843716d5b4dffcd052fa5efb67326814395cae95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=708c7f7fb884199b55bede6d00bd7ed6021e6dbf", "patch": "@@ -1,3 +1,10 @@\n+2015-02-23  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/65153\n+\t* config/sh/sh.md (movsicc_true+3): Remove peephole.\n+\t* config/sh/sh-protos.h (replace_n_hard_rtx): Don't declare.\n+\t* config/sh/sh.c (replace_n_hard_rtx): Remove.\n+\n 2015-02-23  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR fortran/63427"}, {"sha": "c706e745c19c033b5e6b81086c48f0ed27a4a172", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=708c7f7fb884199b55bede6d00bd7ed6021e6dbf", "patch": "@@ -384,7 +384,6 @@ extern void sh_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree,\n \t\t\t\t     signed int, machine_mode);\n extern rtx sh_dwarf_register_span (rtx);\n \n-extern rtx replace_n_hard_rtx (rtx, rtx *, int , int);\n extern int shmedia_cleanup_truncate (rtx);\n \n extern bool sh_contains_memref_p (rtx);"}, {"sha": "02c617667b2b820c6e3138f409d5db587d978e92", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=708c7f7fb884199b55bede6d00bd7ed6021e6dbf", "patch": "@@ -13015,146 +13015,6 @@ sh_init_cumulative_args (CUMULATIVE_ARGS *  pcum,\n     }\n }\n \n-/* Replace any occurrence of FROM(n) in X with TO(n).  The function does\n-   not enter into CONST_DOUBLE for the replace.\n-\n-   Note that copying is not done so X must not be shared unless all copies\n-   are to be modified.\n-\n-   This is like replace_rtx, except that we operate on N_REPLACEMENTS\n-   replacements simultaneously - FROM(n) is replacements[n*2] and to(n) is\n-   replacements[n*2+1] - and that we take mode changes into account.\n-\n-   If a replacement is ambiguous, return NULL_RTX.\n-\n-   If MODIFY is zero, don't modify any rtl in place,\n-   just return zero or nonzero for failure / success.  */\n-rtx\n-replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n-{\n-  int i, j;\n-  const char *fmt;\n-\n-  /* The following prevents loops occurrence when we change MEM in\n-     CONST_DOUBLE onto the same CONST_DOUBLE.  */\n-  if (x != NULL_RTX && GET_CODE (x) == CONST_DOUBLE)\n-    return x;\n-\n-  for (i = n_replacements - 1; i >= 0 ; i--)\n-  if (x == replacements[i*2] && GET_MODE (x) == GET_MODE (replacements[i*2+1]))\n-    return replacements[i*2+1];\n-\n-  /* Allow this function to make replacements in EXPR_LISTs.  */\n-  if (x == NULL_RTX)\n-    return NULL_RTX;\n-\n-  if (GET_CODE (x) == SUBREG)\n-    {\n-      rtx new_rtx = replace_n_hard_rtx (SUBREG_REG (x), replacements,\n-\t\t\t\t    n_replacements, modify);\n-\n-      if (CONST_INT_P (new_rtx))\n-\t{\n-\t  x = simplify_subreg (GET_MODE (x), new_rtx,\n-\t\t\t       GET_MODE (SUBREG_REG (x)),\n-\t\t\t       SUBREG_BYTE (x));\n-\t  if (! x)\n-\t    abort ();\n-\t}\n-      else if (modify)\n-\tSUBREG_REG (x) = new_rtx;\n-\n-      return x;\n-    }\n-  else if (REG_P (x))\n-    {\n-      unsigned regno = REGNO (x);\n-      unsigned nregs = (regno < FIRST_PSEUDO_REGISTER\n-\t\t\t? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n-      rtx result = NULL_RTX;\n-\n-      for (i = n_replacements - 1; i >= 0; i--)\n-\t{\n-\t  rtx from = replacements[i*2];\n-\t  rtx to = replacements[i*2+1];\n-\t  unsigned from_regno, from_nregs, to_regno, new_regno;\n-\n-\t  if (!REG_P (from))\n-\t    continue;\n-\t  from_regno = REGNO (from);\n-\t  from_nregs = (from_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t? HARD_REGNO_NREGS (from_regno, GET_MODE (from)) : 1);\n-\t  if (regno < from_regno + from_nregs && regno + nregs > from_regno)\n-\t    {\n-\t      if (regno < from_regno\n-\t\t  || regno + nregs > from_regno + nregs\n-\t\t  || !REG_P (to)\n-\t\t  || result)\n-\t\treturn NULL_RTX;\n-\t      to_regno = REGNO (to);\n-\t      if (to_regno < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  new_regno = regno + to_regno - from_regno;\n-\t\t  if ((unsigned) HARD_REGNO_NREGS (new_regno, GET_MODE (x))\n-\t\t      != nregs)\n-\t\t    return NULL_RTX;\n-\t\t  result = gen_rtx_REG (GET_MODE (x), new_regno);\n-\t\t}\n-\t      else if (GET_MODE (x) <= GET_MODE (to))\n-\t\tresult = gen_lowpart_common (GET_MODE (x), to);\n-\t      else\n-\t\tresult = gen_lowpart_SUBREG (GET_MODE (x), to);\n-\t    }\n-\t}\n-      return result ? result : x;\n-    }\n-  else if (GET_CODE (x) == ZERO_EXTEND)\n-    {\n-      rtx new_rtx = replace_n_hard_rtx (XEXP (x, 0), replacements,\n-\t\t\t\t    n_replacements, modify);\n-\n-      if (CONST_INT_P (new_rtx))\n-\t{\n-\t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n-\t\t\t\t\tnew_rtx, GET_MODE (XEXP (x, 0)));\n-\t  if (! x)\n-\t    abort ();\n-\t}\n-      else if (modify)\n-\tXEXP (x, 0) = new_rtx;\n-\n-      return x;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n-    {\n-      rtx new_rtx;\n-\n-      if (fmt[i] == 'e')\n-\t{\n-\t  new_rtx = replace_n_hard_rtx (XEXP (x, i), replacements,\n-\t\t\t\t    n_replacements, modify);\n-\t  if (!new_rtx)\n-\t    return NULL_RTX;\n-\t  if (modify)\n-\t    XEXP (x, i) = new_rtx;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  {\n-\t    new_rtx = replace_n_hard_rtx (XVECEXP (x, i, j), replacements,\n-\t\t\t\t      n_replacements, modify);\n-\t  if (!new_rtx)\n-\t    return NULL_RTX;\n-\t    if (modify)\n-\t      XVECEXP (x, i, j) = new_rtx;\n-\t  }\n-    }\n-\n-  return x;\n-}\n-\n rtx\n sh_gen_truncate (machine_mode mode, rtx x, int need_sign_ext)\n {"}, {"sha": "d2f34a3a9910889afde9bbef3cd8751d15f92ebb", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708c7f7fb884199b55bede6d00bd7ed6021e6dbf/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=708c7f7fb884199b55bede6d00bd7ed6021e6dbf", "patch": "@@ -1706,76 +1706,6 @@\n   replace_rtx (operands[4], operands[0], operands[1]);\n })\n \n-(define_peephole2\n-  [(set (match_operand 0 \"any_register_operand\" \"\")\n-\t(match_operand 1 \"any_register_operand\" \"\"))\n-   (set (match_operand 2 \"any_register_operand\" \"\") (match_operand 3 \"\" \"\"))\n-   (set (match_operand 4 \"\" \"\") (match_operand 5 \"\" \"\"))]\n-  \"(HARD_REGNO_NREGS (REGNO (operands[0]), GET_MODE (operands[2]))\n-    <= HARD_REGNO_NREGS (REGNO (operands[0]), GET_MODE (operands[0])))\n-   && peep2_reg_dead_p (3, operands[0]) && peep2_reg_dead_p (3, operands[2])\n-   && ! FIND_REG_INC_NOTE (peep2_next_insn (2), operands[0])\n-   && ! FIND_REG_INC_NOTE (peep2_next_insn (2), operands[2])\n-   && ! reg_overlap_mentioned_p (operands[0], operands[3])\n-   && ! reg_overlap_mentioned_p (operands[2], operands[0])\n-   && ! reg_overlap_mentioned_p (operands[0], operands[1])\n-   && (REGNO_REG_CLASS (REGNO (operands[0]))\n-       == REGNO_REG_CLASS (REGNO (operands[2])))\n-   && (REGNO_REG_CLASS (REGNO (operands[1]))\n-       == REGNO_REG_CLASS (REGNO (operands[0])))\"\n-  [(set (match_dup 0) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))]\n-{\n-  rtx set1, set2;\n-  rtx_insn *insn1, *insn2;\n-  rtx replacements[4];\n-\n-  /* We want to replace occurrences of operands[0] with operands[1] and\n-     operands[2] with operands[0] in operands[4]/operands[5].\n-     Doing just two replace_rtx calls naively would result in the second\n-     replacement undoing all that the first did if operands[1] and operands[2]\n-     are identical, so we must do this simultaneously.  */\n-  replacements[0] = operands[0];\n-  replacements[1] = operands[1];\n-  replacements[2] = operands[2];\n-  replacements[3] = operands[0];\n-  if (!replace_n_hard_rtx (operands[5], replacements, 2, 0)\n-      || !replace_n_hard_rtx (operands[4], replacements, 2, 0)\n-      || !replace_n_hard_rtx (operands[2], replacements, 2, 0))\n-    FAIL;\n-\n-  operands[5] = replace_n_hard_rtx (operands[5], replacements, 2, 1);\n-  replace_n_hard_rtx (operands[4], replacements, 2, 1);\n-  operands[2] = replace_n_hard_rtx (operands[2], replacements, 2, 1);\n-  /* The operands array is aliased to recog_data.operand, which gets\n-     clobbered by extract_insn, so finish with it now.  */\n-  set1 = gen_rtx_SET (VOIDmode, operands[2], operands[3]);\n-  set2 = gen_rtx_SET (VOIDmode, operands[4], operands[5]);\n-  /* ??? The last insn might be a jump insn, but the generic peephole2 code\n-     always uses emit_insn.  */\n-  /* Check that we don't violate matching constraints or earlyclobbers.  */\n-  basic_block bb = BLOCK_FOR_INSN (peep2_next_insn (2));\n-  insn1 = emit_insn (set1);\n-  extract_insn (insn1);\n-  if (! constrain_operands (1, get_preferred_alternatives (insn1, bb)))\n-    goto failure;\n-  insn2 = emit (set2);\n-  if (GET_CODE (insn2) == BARRIER)\n-    goto failure;\n-  extract_insn (insn2);\n-  if (! constrain_operands (1, get_preferred_alternatives (insn2, bb)))\n-    {\n-    failure:\n-      std::swap (replacements[0], replacements[1]);\n-      std::swap (replacements[2], replacements[3]);\n-      replace_n_hard_rtx (SET_DEST (set1), replacements, 2, 1);\n-      replace_n_hard_rtx (SET_DEST (set2), replacements, 2, 1);\n-      replace_n_hard_rtx (SET_SRC (set2), replacements, 2, 1);\n-      FAIL;\n-    }\n-  DONE;\n-})\n-\n ;; The register allocator is rather clumsy in handling multi-way conditional\n ;; moves, so allow the combiner to make them, and we split them up after\n ;; reload.  */"}]}