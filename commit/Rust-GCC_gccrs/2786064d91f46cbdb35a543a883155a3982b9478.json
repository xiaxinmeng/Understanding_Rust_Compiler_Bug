{"sha": "2786064d91f46cbdb35a543a883155a3982b9478", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc4NjA2NGQ5MWY0NmNiZGIzNWE1NDNhODgzMTU1YTM5ODJiOTQ3OA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-18T02:44:41Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-18T02:44:41Z"}, "message": "libstdc++: Move ranges algos used by <ranges> into ranges_util.h\n\nThe <ranges> header defines simplified copies of some ranges algorithms\nin order to avoid including the entirety of ranges_algo.h.  A subsequent\npatch is going to want to use ranges::search in <ranges> as well, and\nthat algorithm is more complicated compared to the other copied ones.\n\nSo rather than additionally copying ranges::search into <ranges>, this\npatch splits out all the ranges algos used by <ranges> (including\nranges::search) from ranges_algo.h to ranges_util.h, and deletes the\nsimplified copies in <ranges>.  This seems like the best place to\nput these algorithms, as ranges_util.h is currently included only from\n<ranges> and ranges_algo.h.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ranges_algo.h (__find_fn, find, __find_if_fn)\n\t(find_if, __find_if_not_fn, find_if_not, _in_in_result)\n\t(__mismatch_fn, mismatch, __search_fn, search): Move to ...\n\t* include/bits/ranges_util.h: ... here.\n\t* include/std/ranges (__detail::find, __detail::find_if)\n\t(__detail::find_if_not, __detail::mismatch): Remove.\n\t(filter_view): Use ranges::find_if instead.\n\t(drop_while_view): Use ranges::find_if_not instead.\n\t(split_view): Use ranges::find and ranges::mismatch instead.", "tree": {"sha": "d67a15dab09a4ffb0bb7e90f72883952c4eca324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d67a15dab09a4ffb0bb7e90f72883952c4eca324"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2786064d91f46cbdb35a543a883155a3982b9478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2786064d91f46cbdb35a543a883155a3982b9478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2786064d91f46cbdb35a543a883155a3982b9478", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2786064d91f46cbdb35a543a883155a3982b9478/comments", "author": null, "committer": null, "parents": [{"sha": "4b4f5666b4c2f3aab2a9f3d53d394e390b9b682d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4f5666b4c2f3aab2a9f3d53d394e390b9b682d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b4f5666b4c2f3aab2a9f3d53d394e390b9b682d"}], "stats": {"total": 506, "additions": 233, "deletions": 273}, "files": [{"sha": "9eeebff65258623aac7e0db859c64b220106a64b", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 2, "deletions": 213, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2786064d91f46cbdb35a543a883155a3982b9478/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2786064d91f46cbdb35a543a883155a3982b9478/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=2786064d91f46cbdb35a543a883155a3982b9478", "patch": "@@ -234,91 +234,7 @@ namespace ranges\n \n   inline constexpr __for_each_n_fn for_each_n{};\n \n-  struct __find_fn\n-  {\n-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,\n-\t     typename _Proj = identity>\n-      requires indirect_binary_predicate<ranges::equal_to,\n-\t\t\t\t\t projected<_Iter, _Proj>, const _Tp*>\n-      constexpr _Iter\n-      operator()(_Iter __first, _Sent __last,\n-\t\t const _Tp& __value, _Proj __proj = {}) const\n-      {\n-\twhile (__first != __last\n-\t    && !(std::__invoke(__proj, *__first) == __value))\n-\t  ++__first;\n-\treturn __first;\n-      }\n-\n-    template<input_range _Range, typename _Tp, typename _Proj = identity>\n-      requires indirect_binary_predicate<ranges::equal_to,\n-\t\t\t\t\t projected<iterator_t<_Range>, _Proj>,\n-\t\t\t\t\t const _Tp*>\n-      constexpr borrowed_iterator_t<_Range>\n-      operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const\n-      {\n-\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n-\t\t       __value, std::move(__proj));\n-      }\n-  };\n-\n-  inline constexpr __find_fn find{};\n-\n-  struct __find_if_fn\n-  {\n-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t     typename _Proj = identity,\n-\t     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>\n-      constexpr _Iter\n-      operator()(_Iter __first, _Sent __last,\n-\t\t _Pred __pred, _Proj __proj = {}) const\n-      {\n-\twhile (__first != __last\n-\t    && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))\n-\t  ++__first;\n-\treturn __first;\n-      }\n-\n-    template<input_range _Range, typename _Proj = identity,\n-\t     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>\n-\t       _Pred>\n-      constexpr borrowed_iterator_t<_Range>\n-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const\n-      {\n-\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n-\t\t       std::move(__pred), std::move(__proj));\n-      }\n-  };\n-\n-  inline constexpr __find_if_fn find_if{};\n-\n-  struct __find_if_not_fn\n-  {\n-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t     typename _Proj = identity,\n-\t     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>\n-      constexpr _Iter\n-      operator()(_Iter __first, _Sent __last,\n-\t\t _Pred __pred, _Proj __proj = {}) const\n-      {\n-\twhile (__first != __last\n-\t    && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))\n-\t  ++__first;\n-\treturn __first;\n-      }\n-\n-    template<input_range _Range, typename _Proj = identity,\n-\t     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>\n-\t       _Pred>\n-      constexpr borrowed_iterator_t<_Range>\n-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const\n-      {\n-\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n-\t\t       std::move(__pred), std::move(__proj));\n-      }\n-  };\n-\n-  inline constexpr __find_if_not_fn find_if_not{};\n+  // find, find_if and find_if_not are defined in <bits/ranges_util.h>.\n \n   struct __find_first_of_fn\n   {\n@@ -421,134 +337,7 @@ namespace ranges\n \n   inline constexpr __count_if_fn count_if{};\n \n-  template<typename _Iter1, typename _Iter2>\n-    struct in_in_result\n-    {\n-      [[no_unique_address]] _Iter1 in1;\n-      [[no_unique_address]] _Iter2 in2;\n-\n-      template<typename _IIter1, typename _IIter2>\n-\trequires convertible_to<const _Iter1&, _IIter1>\n-\t  && convertible_to<const _Iter2&, _IIter2>\n-\tconstexpr\n-\toperator in_in_result<_IIter1, _IIter2>() const &\n-\t{ return {in1, in2}; }\n-\n-      template<typename _IIter1, typename _IIter2>\n-\trequires convertible_to<_Iter1, _IIter1>\n-\t  && convertible_to<_Iter2, _IIter2>\n-\tconstexpr\n-\toperator in_in_result<_IIter1, _IIter2>() &&\n-\t{ return {std::move(in1), std::move(in2)}; }\n-    };\n-\n-  template<typename _Iter1, typename _Iter2>\n-    using mismatch_result = in_in_result<_Iter1, _Iter2>;\n-\n-  struct __mismatch_fn\n-  {\n-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t     typename _Pred = ranges::equal_to,\n-\t     typename _Proj1 = identity, typename _Proj2 = identity>\n-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n-      constexpr mismatch_result<_Iter1, _Iter2>\n-      operator()(_Iter1 __first1, _Sent1 __last1,\n-\t\t _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},\n-\t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n-      {\n-\twhile (__first1 != __last1 && __first2 != __last2\n-\t       && (bool)std::__invoke(__pred,\n-\t\t\t\t      std::__invoke(__proj1, *__first1),\n-\t\t\t\t      std::__invoke(__proj2, *__first2)))\n-\t{\n-\t  ++__first1;\n-\t  ++__first2;\n-\t}\n-\treturn { std::move(__first1), std::move(__first2) };\n-      }\n-\n-    template<input_range _Range1, input_range _Range2,\n-\t     typename _Pred = ranges::equal_to,\n-\t     typename _Proj1 = identity, typename _Proj2 = identity>\n-      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,\n-\t\t\t\t     _Pred, _Proj1, _Proj2>\n-      constexpr mismatch_result<iterator_t<_Range1>, iterator_t<_Range2>>\n-      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},\n-\t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n-      {\n-\treturn (*this)(ranges::begin(__r1), ranges::end(__r1),\n-\t\t       ranges::begin(__r2), ranges::end(__r2),\n-\t\t       std::move(__pred),\n-\t\t       std::move(__proj1), std::move(__proj2));\n-      }\n-  };\n-\n-  inline constexpr __mismatch_fn mismatch{};\n-\n-  struct __search_fn\n-  {\n-    template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t     forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t     typename _Pred = ranges::equal_to,\n-\t     typename _Proj1 = identity, typename _Proj2 = identity>\n-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n-      constexpr subrange<_Iter1>\n-      operator()(_Iter1 __first1, _Sent1 __last1,\n-\t\t _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},\n-\t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n-      {\n-\tif (__first1 == __last1 || __first2 == __last2)\n-\t  return {__first1, __first1};\n-\n-\tfor (;;)\n-\t  {\n-\t    for (;;)\n-\t      {\n-\t\tif (__first1 == __last1)\n-\t\t  return {__first1, __first1};\n-\t\tif (std::__invoke(__pred,\n-\t\t\t\t  std::__invoke(__proj1, *__first1),\n-\t\t\t\t  std::__invoke(__proj2, *__first2)))\n-\t\t  break;\n-\t\t++__first1;\n-\t      }\n-\t    auto __cur1 = __first1;\n-\t    auto __cur2 = __first2;\n-\t    for (;;)\n-\t      {\n-\t\tif (++__cur2 == __last2)\n-\t\t  return {__first1, ++__cur1};\n-\t\tif (++__cur1 == __last1)\n-\t\t  return {__cur1, __cur1};\n-\t\tif (!(bool)std::__invoke(__pred,\n-\t\t\t\t\t std::__invoke(__proj1, *__cur1),\n-\t\t\t\t\t std::__invoke(__proj2, *__cur2)))\n-\t\t  {\n-\t\t    ++__first1;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n-    template<forward_range _Range1, forward_range _Range2,\n-\t     typename _Pred = ranges::equal_to,\n-\t     typename _Proj1 = identity, typename _Proj2 = identity>\n-      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,\n-\t\t\t\t     _Pred, _Proj1, _Proj2>\n-      constexpr borrowed_subrange_t<_Range1>\n-      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},\n-\t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n-      {\n-\treturn (*this)(ranges::begin(__r1), ranges::end(__r1),\n-\t\t       ranges::begin(__r2), ranges::end(__r2),\n-\t\t       std::move(__pred),\n-\t\t       std::move(__proj1), std::move(__proj2));\n-      }\n-  };\n-\n-  inline constexpr __search_fn search{};\n+  // in_in_result, mismatch and search are defined in <bits/ranges_util.h>.\n \n   struct __search_n_fn\n   {"}, {"sha": "9a07079ac13c9d43a4d57e79e0060e2ef5e035b4", "filename": "libstdc++-v3/include/bits/ranges_util.h", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2786064d91f46cbdb35a543a883155a3982b9478/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2786064d91f46cbdb35a543a883155a3982b9478/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h?ref=2786064d91f46cbdb35a543a883155a3982b9478", "patch": "@@ -420,7 +420,226 @@ namespace ranges\n     using borrowed_subrange_t = conditional_t<borrowed_range<_Range>,\n \t\t\t\t\t      subrange<iterator_t<_Range>>,\n \t\t\t\t\t      dangling>;\n+} // namespace ranges\n+\n+// The following ranges algorithms are used by <ranges>, and are defined here\n+// so that <ranges> can avoid including all of <bits/ranges_algo.h>.\n+namespace ranges\n+{\n+  struct __find_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,\n+\t     typename _Proj = identity>\n+      requires indirect_binary_predicate<ranges::equal_to,\n+\t\t\t\t\t projected<_Iter, _Proj>, const _Tp*>\n+      constexpr _Iter\n+      operator()(_Iter __first, _Sent __last,\n+\t\t const _Tp& __value, _Proj __proj = {}) const\n+      {\n+\twhile (__first != __last\n+\t    && !(std::__invoke(__proj, *__first) == __value))\n+\t  ++__first;\n+\treturn __first;\n+      }\n+\n+    template<input_range _Range, typename _Tp, typename _Proj = identity>\n+      requires indirect_binary_predicate<ranges::equal_to,\n+\t\t\t\t\t projected<iterator_t<_Range>, _Proj>,\n+\t\t\t\t\t const _Tp*>\n+      constexpr borrowed_iterator_t<_Range>\n+      operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t       __value, std::move(__proj));\n+      }\n+  };\n+\n+  inline constexpr __find_fn find{};\n+\n+  struct __find_if_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>\n+      constexpr _Iter\n+      operator()(_Iter __first, _Sent __last,\n+\t\t _Pred __pred, _Proj __proj = {}) const\n+      {\n+\twhile (__first != __last\n+\t    && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))\n+\t  ++__first;\n+\treturn __first;\n+      }\n+\n+    template<input_range _Range, typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>\n+\t       _Pred>\n+      constexpr borrowed_iterator_t<_Range>\n+      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t       std::move(__pred), std::move(__proj));\n+      }\n+  };\n+\n+  inline constexpr __find_if_fn find_if{};\n+\n+  struct __find_if_not_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>\n+      constexpr _Iter\n+      operator()(_Iter __first, _Sent __last,\n+\t\t _Pred __pred, _Proj __proj = {}) const\n+      {\n+\twhile (__first != __last\n+\t    && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))\n+\t  ++__first;\n+\treturn __first;\n+      }\n+\n+    template<input_range _Range, typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>\n+\t       _Pred>\n+      constexpr borrowed_iterator_t<_Range>\n+      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t       std::move(__pred), std::move(__proj));\n+      }\n+  };\n+\n+  inline constexpr __find_if_not_fn find_if_not{};\n+\n+  template<typename _Iter1, typename _Iter2>\n+    struct in_in_result\n+    {\n+      [[no_unique_address]] _Iter1 in1;\n+      [[no_unique_address]] _Iter2 in2;\n+\n+      template<typename _IIter1, typename _IIter2>\n+\trequires convertible_to<const _Iter1&, _IIter1>\n+\t  && convertible_to<const _Iter2&, _IIter2>\n+\tconstexpr\n+\toperator in_in_result<_IIter1, _IIter2>() const &\n+\t{ return {in1, in2}; }\n+\n+      template<typename _IIter1, typename _IIter2>\n+\trequires convertible_to<_Iter1, _IIter1>\n+\t  && convertible_to<_Iter2, _IIter2>\n+\tconstexpr\n+\toperator in_in_result<_IIter1, _IIter2>() &&\n+\t{ return {std::move(in1), std::move(in2)}; }\n+    };\n+\n+  template<typename _Iter1, typename _Iter2>\n+    using mismatch_result = in_in_result<_Iter1, _Iter2>;\n+\n+  struct __mismatch_fn\n+  {\n+    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n+\t     typename _Pred = ranges::equal_to,\n+\t     typename _Proj1 = identity, typename _Proj2 = identity>\n+      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n+      constexpr mismatch_result<_Iter1, _Iter2>\n+      operator()(_Iter1 __first1, _Sent1 __last1,\n+\t\t _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},\n+\t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n+      {\n+\twhile (__first1 != __last1 && __first2 != __last2\n+\t       && (bool)std::__invoke(__pred,\n+\t\t\t\t      std::__invoke(__proj1, *__first1),\n+\t\t\t\t      std::__invoke(__proj2, *__first2)))\n+\t{\n+\t  ++__first1;\n+\t  ++__first2;\n+\t}\n+\treturn { std::move(__first1), std::move(__first2) };\n+      }\n+\n+    template<input_range _Range1, input_range _Range2,\n+\t     typename _Pred = ranges::equal_to,\n+\t     typename _Proj1 = identity, typename _Proj2 = identity>\n+      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,\n+\t\t\t\t     _Pred, _Proj1, _Proj2>\n+      constexpr mismatch_result<iterator_t<_Range1>, iterator_t<_Range2>>\n+      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},\n+\t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n+      {\n+\treturn (*this)(ranges::begin(__r1), ranges::end(__r1),\n+\t\t       ranges::begin(__r2), ranges::end(__r2),\n+\t\t       std::move(__pred),\n+\t\t       std::move(__proj1), std::move(__proj2));\n+      }\n+  };\n+\n+  inline constexpr __mismatch_fn mismatch{};\n+\n+  struct __search_fn\n+  {\n+    template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t     forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n+\t     typename _Pred = ranges::equal_to,\n+\t     typename _Proj1 = identity, typename _Proj2 = identity>\n+      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n+      constexpr subrange<_Iter1>\n+      operator()(_Iter1 __first1, _Sent1 __last1,\n+\t\t _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},\n+\t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n+      {\n+\tif (__first1 == __last1 || __first2 == __last2)\n+\t  return {__first1, __first1};\n+\n+\tfor (;;)\n+\t  {\n+\t    for (;;)\n+\t      {\n+\t\tif (__first1 == __last1)\n+\t\t  return {__first1, __first1};\n+\t\tif (std::__invoke(__pred,\n+\t\t\t\t  std::__invoke(__proj1, *__first1),\n+\t\t\t\t  std::__invoke(__proj2, *__first2)))\n+\t\t  break;\n+\t\t++__first1;\n+\t      }\n+\t    auto __cur1 = __first1;\n+\t    auto __cur2 = __first2;\n+\t    for (;;)\n+\t      {\n+\t\tif (++__cur2 == __last2)\n+\t\t  return {__first1, ++__cur1};\n+\t\tif (++__cur1 == __last1)\n+\t\t  return {__cur1, __cur1};\n+\t\tif (!(bool)std::__invoke(__pred,\n+\t\t\t\t\t std::__invoke(__proj1, *__cur1),\n+\t\t\t\t\t std::__invoke(__proj2, *__cur2)))\n+\t\t  {\n+\t\t    ++__first1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    template<forward_range _Range1, forward_range _Range2,\n+\t     typename _Pred = ranges::equal_to,\n+\t     typename _Proj1 = identity, typename _Proj2 = identity>\n+      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,\n+\t\t\t\t     _Pred, _Proj1, _Proj2>\n+      constexpr borrowed_subrange_t<_Range1>\n+      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},\n+\t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n+      {\n+\treturn (*this)(ranges::begin(__r1), ranges::end(__r1),\n+\t\t       ranges::begin(__r2), ranges::end(__r2),\n+\t\t       std::move(__pred),\n+\t\t       std::move(__proj1), std::move(__proj2));\n+      }\n+  };\n \n+  inline constexpr __search_fn search{};\n } // namespace ranges\n \n   using ranges::get;"}, {"sha": "f93a880ff8a89e632466d054e43cfd9dd272b9b8", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 12, "deletions": 60, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2786064d91f46cbdb35a543a883155a3982b9478/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2786064d91f46cbdb35a543a883155a3982b9478/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=2786064d91f46cbdb35a543a883155a3982b9478", "patch": "@@ -1144,54 +1144,6 @@ namespace views::__adaptor\n       using all_t = decltype(all(std::declval<_Range>()));\n   } // namespace views\n \n-  // The following simple algos are transcribed from ranges_algo.h to avoid\n-  // having to include that entire header.\n-  namespace __detail\n-  {\n-    template<typename _Iter, typename _Sent, typename _Tp>\n-      constexpr _Iter\n-      find(_Iter __first, _Sent __last, const _Tp& __value)\n-      {\n-\twhile (__first != __last\n-\t       && !(bool)(*__first == __value))\n-\t  ++__first;\n-\treturn __first;\n-      }\n-\n-    template<typename _Iter, typename _Sent, typename _Pred>\n-      constexpr _Iter\n-      find_if(_Iter __first, _Sent __last, _Pred __pred)\n-      {\n-\twhile (__first != __last\n-\t       && !(bool)std::__invoke(__pred, *__first))\n-\t  ++__first;\n-\treturn __first;\n-      }\n-\n-    template<typename _Iter, typename _Sent, typename _Pred>\n-      constexpr _Iter\n-      find_if_not(_Iter __first, _Sent __last, _Pred __pred)\n-      {\n-\twhile (__first != __last\n-\t       && (bool)std::__invoke(__pred, *__first))\n-\t  ++__first;\n-\treturn __first;\n-      }\n-\n-    template<typename _Iter1, typename _Sent1, typename _Iter2, typename _Sent2>\n-      constexpr pair<_Iter1, _Iter2>\n-      mismatch(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2)\n-      {\n-\twhile (__first1 != __last1 && __first2 != __last2\n-\t       && (bool)ranges::equal_to{}(*__first1, *__first2))\n-\t  {\n-\t    ++__first1;\n-\t    ++__first2;\n-\t  }\n-\treturn { std::move(__first1), std::move(__first2) };\n-      }\n-  } // namespace __detail\n-\n   namespace __detail\n   {\n     template<typename _Tp>\n@@ -1449,9 +1401,9 @@ namespace views::__adaptor\n \tconstexpr _Iterator&\n \toperator++()\n \t{\n-\t  _M_current = __detail::find_if(std::move(++_M_current),\n-\t\t\t\t\t ranges::end(_M_parent->_M_base),\n-\t\t\t\t\t std::ref(*_M_parent->_M_pred));\n+\t  _M_current = ranges::find_if(std::move(++_M_current),\n+\t\t\t\t       ranges::end(_M_parent->_M_base),\n+\t\t\t\t       std::ref(*_M_parent->_M_pred));\n \t  return *this;\n \t}\n \n@@ -1560,9 +1512,9 @@ namespace views::__adaptor\n \t  return {this, _M_cached_begin._M_get(_M_base)};\n \n \t__glibcxx_assert(_M_pred.has_value());\n-\tauto __it = __detail::find_if(ranges::begin(_M_base),\n-\t\t\t\t      ranges::end(_M_base),\n-\t\t\t\t      std::ref(*_M_pred));\n+\tauto __it = ranges::find_if(ranges::begin(_M_base),\n+\t\t\t\t    ranges::end(_M_base),\n+\t\t\t\t    std::ref(*_M_pred));\n \t_M_cached_begin._M_set(_M_base, __it);\n \treturn {this, std::move(__it)};\n       }\n@@ -2453,9 +2405,9 @@ namespace views::__adaptor\n \t  return _M_cached_begin._M_get(_M_base);\n \n \t__glibcxx_assert(_M_pred.has_value());\n-\tauto __it = __detail::find_if_not(ranges::begin(_M_base),\n-\t\t\t\t\t  ranges::end(_M_base),\n-\t\t\t\t\t  std::cref(*_M_pred));\n+\tauto __it = ranges::find_if_not(ranges::begin(_M_base),\n+\t\t\t\t\tranges::end(_M_base),\n+\t\t\t\t\tstd::cref(*_M_pred));\n \t_M_cached_begin._M_set(_M_base, __it);\n \treturn __it;\n       }\n@@ -3031,16 +2983,16 @@ namespace views::__adaptor\n \t      ++__current();\n \t    else if constexpr (__detail::__tiny_range<_Pattern>)\n \t      {\n-\t\t__current() = __detail::find(std::move(__current()), __end,\n-\t\t\t\t\t     *__pbegin);\n+\t\t__current() = ranges::find(std::move(__current()), __end,\n+\t\t\t\t\t   *__pbegin);\n \t\tif (__current() != __end)\n \t\t  ++__current();\n \t      }\n \t    else\n \t      do\n \t\t{\n \t\t  auto [__b, __p]\n-\t\t    = __detail::mismatch(__current(), __end, __pbegin, __pend);\n+\t\t    = ranges::mismatch(__current(), __end, __pbegin, __pend);\n \t\t  if (__p == __pend)\n \t\t    {\n \t\t      __current() = __b;"}]}