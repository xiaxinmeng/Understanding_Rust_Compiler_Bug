{"sha": "935fb2880ccd5cc9f91d3984faaa914065843f7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM1ZmIyODgwY2NkNWNjOWY5MWQzOTg0ZmFhYTkxNDA2NTg0M2Y3ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-15T12:21:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-15T12:21:03Z"}, "message": "(tstdi): Optimized for \"d\" case.\n\n(movqi): Allow moving \"i\" into \"a\".\n(zero_extendsidi2): Alternatives merged.\n(extendplussidi): Fixed when operands 0 and 1 share a register.\n(adddi_sexthishl32): Constraints reordered for better reload.\n(adddi3,subdi_sexthishl32,subdi3,negdi2): Likewise.\n(ashldi_sexthi): Accept \"m\" as operand 0.\n(ashldi_const32): Alternatives merged.\n(ashift patterns): Output \"lsl\" instead of \"asl\".\n(beq0_di): If condition codes already set, output only branch insn.\n(bne0_di,bge0_di,blt0_di): Likewise.\n\nFrom-SVN: r11783", "tree": {"sha": "ba9e67dee849ed5315f0a1fbfa90cbb8a0d3a9ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba9e67dee849ed5315f0a1fbfa90cbb8a0d3a9ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/935fb2880ccd5cc9f91d3984faaa914065843f7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935fb2880ccd5cc9f91d3984faaa914065843f7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/935fb2880ccd5cc9f91d3984faaa914065843f7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935fb2880ccd5cc9f91d3984faaa914065843f7e/comments", "author": null, "committer": null, "parents": [{"sha": "2dedbe1f310983cd826910160c779a4a755377f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dedbe1f310983cd826910160c779a4a755377f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dedbe1f310983cd826910160c779a4a755377f0"}], "stats": {"total": 390, "additions": 248, "deletions": 142}, "files": [{"sha": "78deaf71586ac4f7dd89b067839d30999496a8f0", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 248, "deletions": 142, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935fb2880ccd5cc9f91d3984faaa914065843f7e/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935fb2880ccd5cc9f91d3984faaa914065843f7e/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=935fb2880ccd5cc9f91d3984faaa914065843f7e", "patch": "@@ -37,7 +37,7 @@\n ;;- 'd' one of the data registers can be used.\n ;;- 'f' one of the m68881 registers can be used\n ;;- 'r' either a data or an address register can be used.\n-;;- 'x' if one of the Sun FPA registers                    \n+;;- 'x' if one of the Sun FPA registers\n ;;- 'y' if one of the Low Sun FPA registers (fpa0-fpa15).\n \n ;;- Immediate Floating point operator constraints\n@@ -96,12 +96,11 @@\n ;;- Information about 68060 port.\n \n ;;- The 68060 executes all 68030 and 68881/2 instructions, but some must\n-;;- be emulated in software by the OS.  It is faster to avoid these \n-;;- instructions and issue a library call rather than trapping into \n+;;- be emulated in software by the OS.  It is faster to avoid these\n+;;- instructions and issue a library call rather than trapping into\n ;;- the kernel.  The affected instructions are: divs.l <ea>,Dr:Dq;\n ;;- divu.l <ea>,Dr:Dq; muls.l <ea>,Dr:Dq; mulu.l <ea>,Dr:Dq; and\n-;;- fscale.  The TARGET_68060 flag turns the use of the opcodes \n-;;- off.\n+;;- fscale.  The TARGET_68060 flag turns the use of the opcodes off.\n \n ;;- \t\tFPA port explanation:\n \n@@ -292,23 +291,36 @@\n ;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n ;; be folded while optimizing anyway.\n \n-(define_expand \"tstdi\"\n-  [(parallel\n-    [(set (cc0)\n-\t  (match_operand:DI 0 \"nonimmediate_operand\" \"d\"))\n-     (clobber (match_dup 1))])]\n-  \"\"\n-  \"operands[1] = gen_reg_rtx (DImode);\")\n-\n-(define_insn \"\"\n+(define_insn \"tstdi\"\n   [(set (cc0)\n-\t(match_operand:DI 1 \"nonimmediate_operand\" \"0\"))\n-   (clobber (match_operand:DI 0 \"register_operand\" \"=d\"))]\n+\t(match_operand:DI 0 \"nonimmediate_operand\" \"am,d\"))\n+   (clobber (match_scratch:SI 1 \"=X,d\"))\n+   (clobber (match_scratch:DI 2 \"=d,X\"))]\n   \"\"\n   \"*\n {\n-  cc_status.flags |= CC_REVERSED;\n-  return \\\"neg%.l %R0\\;negx%.l %0\\\";\n+  if (which_alternative == 0)\n+    {\n+      rtx xoperands[2];\n+\n+      xoperands[0] = operands[2];\n+      xoperands[1] = operands[0];\n+      output_move_double (xoperands);\n+      cc_status.flags |= CC_REVERSED;\n+      return \\\"neg%.l %R2\\;negx%.l %2\\\";\n+    }\n+  if (find_reg_note (insn, REG_DEAD, operands[0]))\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      return \\\"neg%.l %R0\\;negx%.l %0\\\";\n+    }\n+  else\n+    /*\n+    ** 'sub' clears %1, and also clears the X cc bit\n+    ** 'tst' sets the Z cc bit according to the low part of the DImode operand\n+    ** 'subx %1' (i.e. subx #0) acts as a (non-existent) tstx on the high part\n+    */\n+    return \\\"sub%.l %1,%1\\;tst%.l %R0\\;subx%.l %1,%0\\\";\n }\")\n \n (define_insn \"tstsi\"\n@@ -347,7 +359,7 @@\n \t(match_operand:QI 0 \"nonimmediate_operand\" \"dm\"))]\n   \"\"\n   \"tst%.b %0\")\n-  \n+\n (define_expand \"tstsf\"\n   [(set (cc0)\n \t(match_operand:SF 0 \"general_operand\" \"\"))]\n@@ -449,9 +461,9 @@\n   \"\"\n   \"\n {\n-  if (flag_pic && symbolic_operand (operands[1], SImode)) \n+  if (flag_pic && symbolic_operand (operands[1], SImode))\n     {\n-      /* The source is an address which requires PIC relocation.  \n+      /* The source is an address which requires PIC relocation.\n          Call legitimize_pic_address with the source, mode, and a relocation\n          register (a new pseudo, or the final destination if reload_in_progress\n          is set).   Then fall through normally */\n@@ -721,7 +733,7 @@\n     {\n       operands[0] = adj_offsettable_operand (operands[0],\n \t\t\t\t\t     INTVAL (operands[1]) / 8);\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t     7 - INTVAL (operands[1]) % 8);\n       return output_btst (operands, operands[1], operands[0], insn, 7);\n     }\n@@ -757,12 +769,12 @@\n ;; Special case of fullword move when source is zero.\n ;; The reason this is special is to avoid loading a zero\n ;; into a data reg with moveq in order to store it elsewhere.\n-   \n+\n (define_insn \"movsi_const0\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(const_int 0))]\n   ;; clr insns on 68000 read before writing.\n-  ;; This isn't so on the 68010, but we have no alternative for it.\n+  ;; This isn't so on the 68010, but we have no TARGET_68010.\n   \"(TARGET_68020\n     || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\"\n   \"*\n@@ -779,24 +791,24 @@\n   return \\\"clr%.l %0\\\";\n }\")\n \n-;; General case of fullword move. \n+;; General case of fullword move.\n ;;\n ;; This is the main \"hook\" for PIC code.  When generating\n ;; PIC, movsi is responsible for determining when the source address\n ;; needs PIC relocation and appropriately calling legitimize_pic_address\n ;; to perform the actual relocation.\n ;;\n ;; In both the PIC and non-PIC cases the patterns generated will\n-;; matched by the next define_insn. \n+;; matched by the next define_insn.\n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (flag_pic && symbolic_operand (operands[1], SImode)) \n+  if (flag_pic && symbolic_operand (operands[1], SImode))\n     {\n-      /* The source is an address which requires PIC relocation.  \n+      /* The source is an address which requires PIC relocation.\n          Call legitimize_pic_address with the source, mode, and a relocation\n          register (a new pseudo, or the final destination if reload_in_progress\n          is set).   Then fall through normally */\n@@ -819,7 +831,7 @@\n   \"*\n {\n   if (which_alternative == 3)\n-    return \\\"fpmove%.l %x1,fpa0\\;fpmove%.l fpa0,%x0\\\";\t\n+    return \\\"fpmove%.l %x1,fpa0\\;fpmove%.l fpa0,%x0\\\";\n   if (FPA_REG_P (operands[1]) || FPA_REG_P (operands[0]))\n     return \\\"fpmove%.l %x1,%x0\\\";\n   if (GET_CODE (operands[1]) == CONST_INT)\n@@ -847,7 +859,7 @@\n \t  && (DATA_REG_P (operands[0])\n \t      || GET_CODE (operands[0]) == MEM)\n \t  /* clr insns on 68000 read before writing.\n-\t     This isn't so on the 68010, but we have no alternative for it.  */\n+\t     This isn't so on the 68010, but we have no TARGET_68010.  */\n \t  && (TARGET_68020\n \t      || !(GET_CODE (operands[0]) == MEM\n \t\t   && MEM_VOLATILE_P (operands[0]))))\n@@ -915,7 +927,7 @@\n \t  && (DATA_REG_P (operands[0])\n \t      || GET_CODE (operands[0]) == MEM)\n \t  /* clr insns on 68000 read before writing.\n-\t     This isn't so on the 68010, but we have no alternative for it.  */\n+\t     This isn't so on the 68010, but we have no TARGET_68010.  */\n \t  && (TARGET_68020\n \t      || !(GET_CODE (operands[0]) == MEM\n \t\t   && MEM_VOLATILE_P (operands[0]))))\n@@ -926,7 +938,7 @@\n \n (define_insn \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,m,m,?*a\")\n-\t(match_operand:QI 1 \"general_operand\" \"dmi*a,d*a,dmi,?*a,m\"))]\n+\t(match_operand:QI 1 \"general_operand\" \"dmi*a,di*a,dmi,?*a,m\"))]\n   \"\"\n   \"*\n {\n@@ -1000,7 +1012,7 @@\n       else\n \treturn \\\"exg %/d0,%0\\;move%.b %1,%/d0\\;exg %/d0,%0\\\";\n     }\n-    \n+\n   /* Likewise for moving from an address reg.  */\n   if (ADDRESS_REG_P (operands[1]) && GET_CODE (operands[0]) == MEM)\n     {\n@@ -1015,7 +1027,7 @@\n \t{\n \t  /* See if the stack pointer is used in the address.  If it isn't,\n \t     we can push d0 or d1 (the insn can't use both of them) on\n-\t     the stack, copy the byte to d0/1, perform our move from d0/d1, \n+\t     the stack, copy the byte to d0/1, perform our move from d0/d1,\n \t     and pop d0/1.  */\n \t  if (! reg_mentioned_p (stack_pointer_rtx, operands[0]))\n \t    {\n@@ -1050,9 +1062,10 @@\n     }\n \n   /* clr and st insns on 68000 read before writing.\n-     This isn't so on the 68010, but we have no alternative for it.  */\n-  if (TARGET_68020\n-      || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\n+     This isn't so on the 68010, but we have no TARGET_68010.  */\n+  if (!ADDRESS_REG_P (operands[0])\n+      && (TARGET_68020\n+\t  || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n     {\n       if (operands[1] == const0_rtx)\n \treturn \\\"clr%.b %0\\\";\n@@ -1089,7 +1102,7 @@\n {\n   if (operands[1] == const0_rtx\n       /* clr insns on 68000 read before writing.\n-         This isn't so on the 68010, but we have no alternative for it.  */\n+         This isn't so on the 68010, but we have no TARGET_68010.  */\n       && (TARGET_68020\n           || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n     return \\\"clr%.b %0\\\";\n@@ -1420,18 +1433,18 @@\n \n ;; this is the canonical form for (lshiftrt:DI x 32)\n (define_insn \"zero_extendsidi2\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"ro,<,>\")\n-    (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm,rm,rm\")))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"rm\")\n+    (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm\")))]\n   \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n-  if (which_alternative == 2)\n-    return \\\"clr%.l %0\\;move%.l %1,%0\\\";\n-  if (which_alternative == 1)\n-    return \\\"move%.l %1,%0\\;clr%.l %0\\\";\n   if (GET_CODE (operands[0]) == REG)\n     operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    return \\\"move%.l %1,%0\\;clr%.l %0\\\";\n+  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    return \\\"clr%.l %0\\;move%.l %1,%0\\\";\n   else\n     operands[2] = adj_offsettable_operand (operands[0], 4);\n   if (ADDRESS_REG_P (operands[0]))\n@@ -1681,10 +1694,15 @@\n       operands[1] = operands[2];\n       operands[2] = tmp;\n     }\n+  if (GET_CODE (operands[1]) == REG\n+      && REGNO (operands[1]) == REGNO (operands[3]))\n+    output_asm_insn (\\\"add%.l %2,%3\\\", operands);\n+  else\n+    output_asm_insn (\\\"move%.l %2,%3\\;add%.l %1,%3\\\", operands);\n   if (TARGET_68020)\n-    return \\\"move%.l %2,%3\\;add%.l %1,%3\\;smi %0\\;extb%.l %0\\\";\n+    return \\\"smi %0\\;extb%.l %0\\\";\n   else\n-    return \\\"move%.l %2,%3\\;add%.l %1,%3\\;smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n+    return \\\"smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n }\")\n \n (define_insn \"extendhisi2\"\n@@ -2018,24 +2036,22 @@\n }\")\n \n (define_insn \"adddi_sexthishl32\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=o,d,a\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"=o,a,*d,*d\")\n     (plus:DI (ashift:DI (sign_extend:DI\n-          (match_operand:HI 1 \"general_operand\" \"rm,rm,rm\"))\n+          (match_operand:HI 1 \"general_operand\" \"rm,rm,rm,rm\"))\n             (const_int 32))\n-        (match_operand:DI 2 \"general_operand\" \"0,0,0\")))\n-   (clobber (match_scratch:SI 3 \"=&d*a,a*d,X\"))]\n+        (match_operand:DI 2 \"general_operand\" \"0,0,0,0\")))\n+   (clobber (match_scratch:SI 3 \"=&d,X,a,?d\"))]\n   \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n   if (ADDRESS_REG_P (operands[0]))\n     return \\\"add%.w %1,%0\\\";\n-  else if (DATA_REG_P (operands[3]))\n-    return \\\"move%.w %1,%3\\;ext%.l %3\\;add%.l %3,%0\\\";\n-  else if (DATA_REG_P (operands[0]))\n+  else if (ADDRESS_REG_P (operands[3]))\n     return \\\"move%.w %1,%3\\;add%.l %3,%0\\\";\n   else\n-    return \\\"move%.l %0,%3\\;add%.w %1,%3\\;mov%.l %3,%0\\\";\n+    return \\\"move%.w %1,%3\\;ext%.l %3\\;add%.l %3,%0\\\";\n } \")\n \n (define_insn \"adddi_dilshr32\"\n@@ -2077,10 +2093,10 @@\n } \")\n \n (define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,<,d,o<>\")\n-\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"d,<,*ao>,d\")))\n-   (clobber (match_scratch:SI 3 \"=X,X,&d,&d\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=<,o<>,d,d,d\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0,0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"<,d,o>,d,a\")))\n+   (clobber (match_scratch:SI 3 \"=X,&d,&d,X,&d\"))]\n   \"\"\n   \"*\n {\n@@ -2230,17 +2246,17 @@\n       if (INTVAL (operands[2]) > 8\n \t  && INTVAL (operands[2]) <= 16\n \t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020) \n+\t  && TARGET_68020)\n \t{\n \t  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 8);\n \t  return \\\"addq%.w %#8,%0\\;addq%.w %2,%0\\\";\n \t}\n       if (INTVAL (operands[2]) < -8\n \t  && INTVAL (operands[2]) >= -16\n \t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020) \n+\t  && TARGET_68020)\n \t{\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t  - INTVAL (operands[2]) - 8);\n \t  return \\\"subq%.w %#8,%0\\;subq%.w %2,%0\\\";\n \t}\n@@ -2296,17 +2312,17 @@\n       if (INTVAL (operands[2]) > 8\n \t  && INTVAL (operands[2]) <= 16\n \t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020) \n+\t  && TARGET_68020)\n \t{\n \t  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 8);\n \t  return \\\"addq%.w %#8,%0\\;addq%.w %2,%0\\\";\n \t}\n       if (INTVAL (operands[2]) < -8\n \t  && INTVAL (operands[2]) >= -16\n \t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020) \n+\t  && TARGET_68020)\n \t{\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t - INTVAL (operands[2]) - 8);\n \t  return \\\"subq%.w %#8,%0\\;subq%.w %2,%0\\\";\n \t}\n@@ -2356,17 +2372,17 @@\n       if (INTVAL (operands[1]) > 8\n \t  && INTVAL (operands[1]) <= 16\n \t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020) \n+\t  && TARGET_68020)\n \t{\n \t  operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) - 8);\n \t  return \\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\";\n \t}\n       if (INTVAL (operands[1]) < -8\n \t  && INTVAL (operands[1]) >= -16\n \t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020) \n+\t  && TARGET_68020)\n \t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t - INTVAL (operands[1]) - 8);\n \t  return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n \t}\n@@ -2410,17 +2426,17 @@\n       if (INTVAL (operands[1]) > 8\n \t  && INTVAL (operands[1]) <= 16\n \t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020) \n+\t  && TARGET_68020)\n \t{\n \t  operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) - 8);\n \t  return \\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\";\n \t}\n       if (INTVAL (operands[1]) < -8\n \t  && INTVAL (operands[1]) >= -16\n \t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020) \n+\t  && TARGET_68020)\n \t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t - INTVAL (operands[1]) - 8);\n \t  return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n \t}\n@@ -2625,23 +2641,21 @@\n ;; subtract instructions\n \n (define_insn \"subdi_sexthishl32\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=o,d,a\")\n-    (minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0\")\n-        (ashift:DI (sign_extend:DI (match_operand:HI 2 \"general_operand\" \"rm,rm,rm\"))\n+  [(set (match_operand:DI 0 \"general_operand\" \"=o,a,*d,*d\")\n+    (minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0\")\n+        (ashift:DI (sign_extend:DI (match_operand:HI 2 \"general_operand\" \"rm,rm,rm,rm\"))\n             (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=&d*a,a*d,X\"))]\n+   (clobber (match_scratch:SI 3 \"=&d,X,a,?d\"))]\n   \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n   if (ADDRESS_REG_P (operands[0]))\n     return \\\"sub%.w %2,%0\\\";\n-  else if (DATA_REG_P (operands[3]))\n-    return \\\"move%.w %2,%3\\;ext%.l %3\\;sub%.l %3,%0\\\";\n-  else if (DATA_REG_P (operands[0]))\n+  else if (ADDRESS_REG_P (operands[3]))\n     return \\\"move%.w %2,%3\\;sub%.l %3,%0\\\";\n   else\n-    return \\\"move%.l %0,%3\\;sub%.w %2,%3\\;mov%.l %3,%0\\\";\n+    return \\\"move%.w %2,%3\\;ext%.l %3\\;sub%.l %3,%0\\\";\n } \")\n \n (define_insn \"subdi_dishl32\"\n@@ -2661,10 +2675,10 @@\n } \")\n \n (define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,<,d,o<>\")\n-\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"d,<,*ao>,d\")))\n-   (clobber (match_scratch:SI 3 \"=X,X,&d,&d\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=<,o<>,d,d,d\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0,0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"<,d,o>,d,a\")))\n+   (clobber (match_scratch:SI 3 \"=X,&d,&d,X,&d\"))]\n   \"\"\n   \"*\n {\n@@ -3511,7 +3525,7 @@\n       && (INTVAL (operands[2]) | 0xffff) == 0xffffffff\n       && (DATA_REG_P (operands[0])\n \t  || offsettable_memref_p (operands[0])))\n-    { \n+    {\n       if (GET_CODE (operands[0]) != REG)\n         operands[0] = adj_offsettable_operand (operands[0], 2);\n       operands[2] = gen_rtx (CONST_INT, VOIDmode,\n@@ -3526,7 +3540,7 @@\n       && (logval = exact_log2 (~ INTVAL (operands[2]))) >= 0\n       && (DATA_REG_P (operands[0])\n           || offsettable_memref_p (operands[0])))\n-    { \n+    {\n       if (DATA_REG_P (operands[0]))\n         {\n           operands[1] = gen_rtx (CONST_INT, VOIDmode, logval);\n@@ -3599,7 +3613,7 @@\n       && INTVAL (operands[2]) >> 16 == 0\n       && (DATA_REG_P (operands[0])\n \t  || offsettable_memref_p (operands[0])))\n-    { \n+    {\n       if (GET_CODE (operands[0]) != REG)\n         operands[0] = adj_offsettable_operand (operands[0], 2);\n       /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n@@ -3610,7 +3624,7 @@\n       && (logval = exact_log2 (INTVAL (operands[2]))) >= 0\n       && (DATA_REG_P (operands[0])\n \t  || offsettable_memref_p (operands[0])))\n-    { \n+    {\n       if (DATA_REG_P (operands[0]))\n \t{\n \t  operands[1] = gen_rtx (CONST_INT, VOIDmode, logval);\n@@ -3699,7 +3713,7 @@\n   if (GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) >> 16 == 0\n       && (offsettable_memref_p (operands[0]) || DATA_REG_P (operands[0])))\n-    { \n+    {\n       if (! DATA_REG_P (operands[0]))\n \toperands[0] = adj_offsettable_operand (operands[0], 2);\n       /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n@@ -3755,12 +3769,12 @@\n ;; negation instructions\n \n (define_insn \"negdi2\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d*ao,<\")\n-\t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0\")))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=<,do,!*a\")\n+\t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0,0\")))]\n   \"\"\n   \"*\n {\n-  if (which_alternative == 1)\n+  if (which_alternative == 0)\n     return \\\"neg%.l %0\\;negx%.l %0\\\";\n   if (GET_CODE (operands[0]) == REG)\n     operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n@@ -3875,7 +3889,7 @@\n \n       if (result != target)\n \temit_move_insn (result, target);\n-  \n+\n       emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n \t\t      operand_subword_force (operands[1], 1, DFmode));\n \n@@ -4004,7 +4018,7 @@\n \n       if (result != target)\n \temit_move_insn (result, target);\n-  \n+\n       emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n \t\t      operand_subword_force (operands[1], 1, DFmode));\n \n@@ -4107,23 +4121,35 @@\n } \")\n \n (define_insn \"ashldi_sexthi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=*da\")\n-    (ashift:DI (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"rm\"))\n-        (const_int 32)))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=m,a*d\")\n+    (ashift:DI (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"rm,rm\"))\n+        (const_int 32)))\n+    (clobber (match_scratch:SI 2 \"=a,X\"))]\n   \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n-  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-  if (DATA_REG_P (operands[0]))\n-    return \\\"move%.w %1,%0\\;ext%.l %0\\;clr%.l %2\\\";\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+    if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+      return \\\"clr%.l %0\\;move%.w %1,%2\\;move%.l %2,%0\\\";\n+    else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+      return \\\"move%.w %1,%2\\;move%.l %2,%0\\;clr%.l %0\\\";\n+    else\n+      {\n+\toperands[3] = adj_offsettable_operand (operands[0], 4);\n+\treturn \\\"move%.w %1,%2\\;move%.l %2,%0\\;clr%.l %3\\\";\n+      }\n+    }\n+  else if (DATA_REG_P (operands[0]))\n+    return \\\"move%.w %1,%0\\;ext%.l %0\\;clr%.l %R0\\\";\n   else\n-    return \\\"move%.w %1,%0\\;sub%.l %2,%2\\\";\n+    return \\\"move%.w %1,%0\\;sub%.l %R0,%R0\\\";\n } \")\n \n (define_insn \"ashldi_const32\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=ro,<,>\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"ro,ro,ro\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n \t\t     (const_int 32)))]\n   \"\"\n   \"*\n@@ -4133,12 +4159,12 @@\n     operands[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n   else\n     operands[3] = adj_offsettable_operand (operands[1], 4);\n-  if (which_alternative == 1)\n-    return \\\"clr%.l %0\\;move%.l %3,%0\\\";\n-  if (which_alternative == 2)\n-    return \\\"move%.l %3,%0\\;clr%.l %0\\\";\n   if (GET_CODE (operands[0]) == REG)\n     operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    return \\\"clr%.l %0\\;move%.l %3,%0\\\";\n+  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    return \\\"move%.l %3,%0\\;clr%.l %0\\\";\n   else\n     operands[2] = adj_offsettable_operand (operands[0], 4);\n   if (ADDRESS_REG_P (operands[2]))\n@@ -4197,6 +4223,9 @@\n   return \\\"swap %0\\;clr%.w %0\\\";\n }\")\n \n+;; ashift patterns : use lsl instead of asl, because lsl always clears the\n+;; overflow bit, so we must not set CC_NO_OVERFLOW.\n+\n ;; On the 68000, this makes faster code in a special case.\n \n (define_insn \"\"\n@@ -4210,7 +4239,7 @@\n   CC_STATUS_INIT;\n \n   operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 16);\n-  return \\\"asl%.w %2,%0\\;swap %0\\;clr%.w %0\\\";\n+  return \\\"lsl%.w %2,%0\\;swap %0\\;clr%.w %0\\\";\n }\")\n \n (define_insn \"ashlsi3\"\n@@ -4221,37 +4250,40 @@\n   \"*\n {\n   if (operands[2] == const1_rtx)\n-    return \\\"add%.l %0,%0\\\";\n-  return \\\"asl%.l %2,%0\\\";\n+    {\n+      cc_status.flags = CC_NO_OVERFLOW;\n+      return \\\"add%.l %0,%0\\\";\n+    }\n+  return \\\"lsl%.l %2,%0\\\";\n }\")\n \n (define_insn \"ashlhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:HI 2 \"general_operand\" \"dI\")))]\n   \"\"\n-  \"asl%.w %2,%0\")\n+  \"lsl%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n \t(ashift:HI (match_dup 0)\n \t\t   (match_operand:HI 1 \"general_operand\" \"dI\")))]\n   \"\"\n-  \"asl%.w %1,%0\")\n+  \"lsl%.w %1,%0\")\n \n (define_insn \"ashlqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:QI 2 \"general_operand\" \"dI\")))]\n   \"\"\n-  \"asl%.b %2,%0\")\n+  \"lsl%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+d\"))\n \t(ashift:QI (match_dup 0)\n \t\t   (match_operand:QI 1 \"general_operand\" \"dI\")))]\n   \"\"\n-  \"asl%.b %1,%0\")\n+  \"lsl%.b %1,%0\")\n \n ;; On all 68k models, this makes faster code in a special case.\n \n@@ -5089,7 +5121,7 @@\n {\n   if (operands[1] == const1_rtx\n       && GET_CODE (operands[2]) == CONST_INT)\n-    {    \n+    {\n       int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n       return output_btst (operands,\n \t\t\t  gen_rtx (CONST_INT, VOIDmode,\n@@ -5105,7 +5137,7 @@\n   return \\\"bftst %0{%b2:%b1}\\\";\n }\")\n \n-  \n+\n ;;; now handle the register cases\n (define_insn \"\"\n   [(set (cc0)\n@@ -5117,7 +5149,7 @@\n {\n   if (operands[1] == const1_rtx\n       && GET_CODE (operands[2]) == CONST_INT)\n-    {    \n+    {\n       int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n       return output_btst (operands,\n \t\t\t  gen_rtx (CONST_INT, VOIDmode,\n@@ -5244,12 +5276,25 @@\n   \"\"\n   \"*\n {\n+  CC_STATUS_INIT;\n   if (which_alternative == 1)\n #ifdef MOTOROLA\n     return \\\"move%.l %0,%2\\;or%.l %0,%2\\;jbeq %l1\\\";\n #else\n     return \\\"move%.l %0,%2\\;or%.l %0,%2\\;jeq %l1\\\";\n #endif\n+  if ((cc_prev_status.value1\n+      && rtx_equal_p (cc_prev_status.value1, operands[0]))\n+    || (cc_prev_status.value2\n+      && rtx_equal_p (cc_prev_status.value2, operands[0])))\n+    {\n+      cc_status = cc_prev_status;\n+#ifdef MOTOROLA\n+      return \\\"jbeq %l1\\\";\n+#else\n+      return \\\"jeq %l1\\\";\n+#endif\n+    }\n   if (GET_CODE (operands[0]) == REG)\n     operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n   else\n@@ -5277,10 +5322,23 @@\n             (const_int 0))\n         (label_ref (match_operand 1 \"\" \",\"))\n         (pc)))\n-   (clobber (match_scratch:SI 2 \"=d,\"))]\n+   (clobber (match_scratch:SI 2 \"=d,X\"))]\n   \"\"\n   \"*\n {\n+  if ((cc_prev_status.value1\n+      && rtx_equal_p (cc_prev_status.value1, operands[0]))\n+    || (cc_prev_status.value2\n+      && rtx_equal_p (cc_prev_status.value2, operands[0])))\n+    {\n+      cc_status = cc_prev_status;\n+#ifdef MOTOROLA\n+      return \\\"jbne %l1\\\";\n+#else\n+      return \\\"jne %l1\\\";\n+#endif\n+    }\n+  CC_STATUS_INIT;\n   if (GET_CODE (operands[0]) == REG)\n     operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n   else\n@@ -5308,10 +5366,34 @@\n   \"\"\n   \"*\n {\n+  if ((cc_prev_status.value1\n+      && rtx_equal_p (cc_prev_status.value1, operands[0]))\n+    || (cc_prev_status.value2\n+      && rtx_equal_p (cc_prev_status.value2, operands[0])))\n+    {\n+      cc_status = cc_prev_status;\n+      if (cc_status.flags & CC_REVERSED)\n+\t{\n #ifdef MOTOROLA\n-  return \\\"tst%.l %0\\;jbge %l1\\\";\n+\t  return \\\"jble %l1\\\";\n #else\n-  return \\\"tst%.l %0\\;jge %l1\\\";\n+\t  return \\\"jle %l1\\\";\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef MOTOROLA\n+\t  return \\\"jbpl %l1\\\";\n+#else\n+\t  return \\\"jpl %l1\\\";\n+#endif\n+\t}\n+    }\n+  CC_STATUS_INIT;\n+#ifdef MOTOROLA\n+  return \\\"tst%.l %0\\;jbpl %l1\\\";\n+#else\n+  return \\\"tst%.l %0\\;jpl %l1\\\";\n #endif\n } \")\n \n@@ -5324,6 +5406,30 @@\n   \"\"\n   \"*\n {\n+  if ((cc_prev_status.value1\n+      && rtx_equal_p (cc_prev_status.value1, operands[0]))\n+    || (cc_prev_status.value2\n+      && rtx_equal_p (cc_prev_status.value2, operands[0])))\n+    {\n+      cc_status = cc_prev_status;\n+      if (cc_status.flags & CC_REVERSED)\n+\t{\n+#ifdef MOTOROLA\n+\t  return \\\"jbgt %l1\\\";\n+#else\n+\t  return \\\"jgt %l1\\\";\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef MOTOROLA\n+\t  return \\\"jbmi %l1\\\";\n+#else\n+\t  return \\\"jmi %l1\\\";\n+#endif\n+\t}\n+    }\n+  CC_STATUS_INIT;\n #ifdef MOTOROLA\n   return \\\"tst%.l %0\\;jbmi %l1\\\";\n #else\n@@ -5905,10 +6011,10 @@\n \n \n ;; For PIC calls, in order to be able to support\n-;; dynamic linker LAZY BINDING, all the procedure calls need to go \n+;; dynamic linker LAZY BINDING, all the procedure calls need to go\n ;; through the PLT (Procedure Linkage Table) section in PIC mode.\n ;;\n-;; PIC calls are handled by loading the address of the function into a \n+;; PIC calls are handled by loading the address of the function into a\n ;; register (via movsi), then emitting a register indirect call using\n ;; the \"jsr\" function call syntax.\n ;;\n@@ -5919,26 +6025,26 @@\n ;; We have different patterns for PIC calls and non-PIC calls.  The\n ;; different patterns are only used to choose the right syntax.\n ;;\n-;; The svr4 m68k assembler recognizes this syntax: `bsr FUNC@PLTPC' and it \n-;; will create the correct relocation entry (R_68K_PLT32) for `FUNC', \n+;; The svr4 m68k assembler recognizes this syntax: `bsr FUNC@PLTPC' and it\n+;; will create the correct relocation entry (R_68K_PLT32) for `FUNC',\n ;; that tells the linker editor to create an entry for `FUNC' in PLT\n ;; section at link time. However, all global objects reference are still\n-;; done by using `OBJ@GOT'. So, the goal here is to output the function \n-;; call operand as `FUNC@PLTPC', but output object operand as `OBJ@GOT'. \n+;; done by using `OBJ@GOT'. So, the goal here is to output the function\n+;; call operand as `FUNC@PLTPC', but output object operand as `OBJ@GOT'.\n ;; We need to have a way to differentiate these two different operands.\n ;;\n-;; The strategy I use here is to use SYMBOL_REF_FLAG to differentiate \n+;; The strategy I use here is to use SYMBOL_REF_FLAG to differentiate\n ;; these two different operands. The macro LEGITIMATE_PIC_OPERAND_P needs\n-;; to be changed to recognize function calls symbol_ref operand as a valid \n-;; PIC operand (by checking whether SYMBOL_REF_FLAG is set). This will \n-;; avoid the compiler to load this symbol_ref operand into a register. \n-;; Remember, the operand \"foo@PLTPC\" cannot be called via jsr directly \n+;; to be changed to recognize function calls symbol_ref operand as a valid\n+;; PIC operand (by checking whether SYMBOL_REF_FLAG is set). This will\n+;; avoid the compiler to load this symbol_ref operand into a register.\n+;; Remember, the operand \"foo@PLTPC\" cannot be called via jsr directly\n ;; since the value is a PC relative offset, not a real address.\n ;;\n-;; All global objects are treated in the similar way as in SUN3. The only \n-;; difference is: on m68k svr4, the reference of such global object needs \n+;; All global objects are treated in the similar way as in SUN3. The only\n+;; difference is: on m68k svr4, the reference of such global object needs\n ;; to end with a suffix \"@GOT\" so the assembler and linker know to create\n-;; an entry for it in GOT (Global Offset Table) section. This is done in \n+;; an entry for it in GOT (Global Offset Table) section. This is done in\n ;; m68k.c.\n \n ;; Call subroutine with no return value.\n@@ -5964,7 +6070,7 @@\n   \"*\n #if defined (MOTOROLA) && !defined (USE_GAS)\n #ifdef MOTOROLA_BSR\n-  if (GET_CODE (operands[0]) == MEM \n+  if (GET_CODE (operands[0]) == MEM\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n     return \\\"bsr %0\\\";\n #endif\n@@ -5982,7 +6088,7 @@\n \n   \"flag_pic\"\n   \"*\n-  if (GET_CODE (operands[0]) == MEM \n+  if (GET_CODE (operands[0]) == MEM\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n #ifdef MOTOROLA\n #ifdef HPUX_ASM\n@@ -6027,7 +6133,7 @@\n   \"*\n #if defined (MOTOROLA) && !defined (USE_GAS)\n #ifdef MOTOROLA_BSR\n-  if (GET_CODE (operands[1]) == MEM \n+  if (GET_CODE (operands[1]) == MEM\n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n     return \\\"bsr %1\\\";\n #endif\n@@ -6045,7 +6151,7 @@\n   ;; Operand 2 not really used on the m68000.\n   \"flag_pic\"\n   \"*\n-  if (GET_CODE (operands[1]) == MEM \n+  if (GET_CODE (operands[1]) == MEM\n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n #ifdef MOTOROLA\n #ifdef HPUX_ASM\n@@ -6219,7 +6325,7 @@\n         output_asm_insn (\\\"addq%.w %1,%0\\\", xoperands);\n       else if (INTVAL (xoperands[1]) <= 16 && TARGET_68020)\n \t{\n-\t  xoperands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t  xoperands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t  INTVAL (xoperands[1]) - 8);\n \t  output_asm_insn (\\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\", xoperands);\n \t}\n@@ -6256,7 +6362,7 @@\n         output_asm_insn (\\\"addq%.w %1,%0\\\", xoperands);\n       else if (INTVAL (xoperands[1]) <= 16 && TARGET_68020)\n \t{\n-\t  xoperands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t  xoperands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t  INTVAL (xoperands[1]) - 8);\n \t  output_asm_insn (\\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\", xoperands);\n \t}\n@@ -6310,7 +6416,7 @@\n \t  && (DATA_REG_P (operands[0])\n \t      || GET_CODE (operands[0]) == MEM)\n \t  /* clr insns on 68000 read before writing.\n-\t     This isn't so on the 68010, but we have no alternative for it.  */\n+\t     This isn't so on the 68010, but we have no TARGET_68010.  */\n \t  && (TARGET_68020\n \t      || !(GET_CODE (operands[0]) == MEM\n \t\t   && MEM_VOLATILE_P (operands[0]))))\n@@ -6624,7 +6730,7 @@\n     }\n   return \\\"fmove%.d %f1,%0\\\";\n }\")\n- \n+\n (define_insn \"truncxfsf2\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=dm\")\n \t(float_truncate:SF\n@@ -6835,7 +6941,7 @@\n \n       if (result != target)\n \temit_move_insn (result, target);\n-  \n+\n       emit_move_insn (operand_subword (operands[0], 1, 1, XFmode),\n \t\t      operand_subword_force (operands[1], 1, XFmode));\n       emit_move_insn (operand_subword (operands[0], 2, 1, XFmode),\n@@ -6884,7 +6990,7 @@\n \n       if (result != target)\n \temit_move_insn (result, target);\n-  \n+\n       emit_move_insn (operand_subword (operands[0], 1, 1, XFmode),\n \t\t      operand_subword_force (operands[1], 1, XFmode));\n       emit_move_insn (operand_subword (operands[0], 2, 1, XFmode),"}]}