{"sha": "6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNkYTIzMWVkOTFhZDdlM2MxYjUzNTdiMGZmYzA0YTkyNWZmMzRmNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-09-18T05:18:54Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-09-18T05:18:54Z"}, "message": "re PR fortran/16861 ([4.0 only] segfault with doubly used module)\n\n2005-09-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/16861\n\t* module.c (read_module): Give symbols from module procedures\n\tdifferent true_name entries to those from the module proper.\n\n2005-09-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/16861\n\t* gfortran.dg/nested_modules_2.f90: New test.\n\nFrom-SVN: r104388", "tree": {"sha": "5a25bc941590a75d5331f4e5dd69bba6e6730d72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a25bc941590a75d5331f4e5dd69bba6e6730d72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/comments", "author": null, "committer": null, "parents": [{"sha": "b695055179b834455a2fe617ea8922621637429e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b695055179b834455a2fe617ea8922621637429e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b695055179b834455a2fe617ea8922621637429e"}], "stats": {"total": 64, "additions": 58, "deletions": 6}, "files": [{"sha": "ca4a80d83e9a8d680145d215d54efa714ae565ba", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7", "patch": "@@ -1,3 +1,9 @@\n+2005-09-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/16861\n+\t* module.c (read_module): Give symbols from module procedures\n+\tdifferent true_name entries to those from the module proper.\n+\n 2005-09-17  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/15586"}, {"sha": "8f225aa8d9d3823139d5045eeec783837e3378a7", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7", "patch": "@@ -3099,7 +3099,7 @@ read_module (void)\n   const char *p;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_intrinsic_op i;\n-  int ambiguous, symbol, j, nuse;\n+  int ambiguous, j, nuse, series, symbol;\n   pointer_info *info;\n   gfc_use_rename *u;\n   gfc_symtree *st;\n@@ -3142,6 +3142,14 @@ read_module (void)\n          being loaded again.  */\n \n       sym = find_true_name (info->u.rsym.true_name, info->u.rsym.module);\n+\n+      /* If a module contains subroutines with assumed shape dummy\n+       arguments, the symbols for indices need to be different from\n+       from those in the module proper(ns = 1).  */\n+      if (sym !=NULL && info->u.rsym.ns != 1)\n+\tsym = find_true_name (info->u.rsym.true_name,\n+\t\tgfc_get_string (\"%s@%d\",module_name, series++));\n+\n       if (sym == NULL)\n \tcontinue;\n \n@@ -3485,11 +3493,6 @@ write_symbol1 (pointer_info * p)\n   if (p->type != P_SYMBOL || p->u.wsym.state != NEEDS_WRITE)\n     return 0;\n \n-  /* FIXME: This shouldn't be necessary, but it works around\n-     deficiencies in the module loader or/and symbol handling.  */\n-  if (p->u.wsym.sym->module == NULL && p->u.wsym.sym->attr.dummy)\n-    p->u.wsym.sym->module = gfc_get_string (module_name);\n-\n   p->u.wsym.state = WRITTEN;\n   write_symbol (p->integer, p->u.wsym.sym);\n "}, {"sha": "c60cb5587aaa2de1bb0dfbd0c94a6b8ebc6529fa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7", "patch": "@@ -1,3 +1,8 @@\n+2005-09-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/16861\n+\t* gfortran.dg/nested_modules_2.f90: New test.\n+\n 2005-09-17  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/18368"}, {"sha": "91ab766c1be8cc8f2dade556a6a7457c70609c5f", "filename": "gcc/testsuite/gfortran.dg/nested_modules_2.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_2.f90?ref=6cda231ed91ad7e3c1b5357b0ffc04a925ff34f7", "patch": "@@ -0,0 +1,38 @@\n+! { dg do-run }\n+! This tests the patch for PR16861.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+module foo\n+INTEGER :: i\n+end module foo\n+\n+module bar\n+contains\n+subroutine sub1 (j)\n+  use foo\n+  integer, dimension(i) :: j\n+  j = 42\n+end subroutine sub1\n+subroutine sub2 (k)\n+  use foo\n+  integer, dimension(i) :: k\n+  k = 84\n+end subroutine sub2\n+end module bar\n+\n+module foobar\n+  use foo                      !This used to cause an ICE\n+  use bar\n+end module foobar\n+\n+program testfoobar\n+  use foobar\n+  integer, dimension(3)  :: l = 0\n+  i = 2\n+  call sub1 (l)\n+  i = 1\n+  call sub2 (l)\n+  if (all (l.ne.(/84,42,0/))) call abort ()\n+end program testfoobar\n+"}]}