{"sha": "4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJmOWU1YThhMmE0MGZiNGNhODdkZWVkZTJjZjdiMGNiMDE2Y2Q0NQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2015-11-03T11:28:22Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2015-11-03T11:28:22Z"}, "message": "OpenACC atomic directive\n\n\tgcc/c-family/\n\t* c-pragma.c (oacc_pragmas): Add \"atomic\".\n\t* c-pragma.h (pragma_kind): Add PRAGMA_OACC_ATOMIC.\n\tgcc/c/\n\t* c-parser.c (c_parser_omp_construct): Handle PRAGMA_OACC_ATOMIC.\n\tgcc/cp/\n\t* parser.c (cp_parser_omp_construct, cp_parser_pragma): Handle\n\tPRAGMA_OACC_ATOMIC.\n\tgcc/fortran/\n\t* gfortran.h (gfc_statement): Add ST_OACC_ATOMIC,\n\tST_OACC_END_ATOMIC.\n\t(gfc_exec_op): Add EXEC_OACC_ATOMIC.\n\t* match.h (gfc_match_oacc_atomic): New prototype.\n\t* openmp.c (gfc_match_omp_atomic, gfc_match_oacc_atomic): New\n\twrapper functions around...\n\t(gfc_match_omp_oacc_atomic): ... this new function.\n\t(oacc_code_to_statement, gfc_resolve_oacc_directive): Handle\n\tEXEC_OACC_ATOMIC.\n\t* parse.c (decode_oacc_directive): Handle \"atomic\", \"end atomic\".\n\t(case_exec_markers): Add ST_OACC_ATOMIC.\n\t(gfc_ascii_statement): Handle ST_OACC_ATOMIC, ST_OACC_END_ATOMIC.\n\t(parse_omp_atomic): Rename to...\n\t(parse_omp_oacc_atomic): ... this new function.  Add omp_p formal\n\tparameter.  Adjust all users.\n\t(parse_executable): Handle ST_OACC_ATOMIC.\n\t(is_oacc): Handle EXEC_OACC_ATOMIC.\n\t* resolve.c (gfc_resolve_blocks, gfc_resolve_code): Handle\n\tEXEC_OACC_ATOMIC.\n\t* st.c (gfc_free_statement): Handle EXEC_OACC_ATOMIC.\n\t* trans-openmp.c (gfc_trans_oacc_directive): Handle\n\tEXEC_OACC_ATOMIC.\n\t* trans.c (trans_code): Handle EXEC_OACC_ATOMIC.\n\tgcc/\n\t* builtins.def (DEF_GOMP_BUILTIN): Enable for flag_openacc.\n\t* omp-low.c (check_omp_nesting_restrictions): Allow\n\tGIMPLE_OMP_ATOMIC_LOAD, GIMPLE_OMP_ATOMIC_STORE inside OpenACC\n\tcontexts.\n\tgcc/testsuite/\n\t* c-c++-common/goacc-gomp/nesting-fail-1.c: Move \"atomic\" tests\n\tfrom here to...\n\t* c-c++-common/goacc-gomp/nesting-1.c: ... here, and expect them\n\tto succeed.\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/atomic_capture-1.c: New\n\tfile.\n\t* testsuite/libgomp.oacc-c-c++-common/atomic_capture-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/atomic_rw-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/atomic_update-1.c: Likewise.\n\t* testsuite/libgomp.oacc-fortran/atomic_capture-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/atomic_rw-1.f90: New file.\n\t* testsuite/libgomp.oacc-fortran/atomic_update-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/par-reduction-1.c: New file.\n\t* testsuite/libgomp.oacc-c-c++-common/par-reduction-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/worker-single-1a.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/worker-single-4.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/worker-single-6.c: Likewise.\n\nFrom-SVN: r229703", "tree": {"sha": "d3e95324162ff347ee0c5e2bff2c95e88fe0f321", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3e95324162ff347ee0c5e2bff2c95e88fe0f321"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/comments", "author": null, "committer": null, "parents": [{"sha": "496ea87db62abbf97da6d5791b4d5fb406350767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496ea87db62abbf97da6d5791b4d5fb406350767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/496ea87db62abbf97da6d5791b4d5fb406350767"}], "stats": {"total": 4871, "additions": 4827, "deletions": 44}, "files": [{"sha": "947b9a7c8f75881a9915dcccdae4f4a4478beaec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1,3 +1,11 @@\n+2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* builtins.def (DEF_GOMP_BUILTIN): Enable for flag_openacc.\n+\t* omp-low.c (check_omp_nesting_restrictions): Allow\n+\tGIMPLE_OMP_ATOMIC_LOAD, GIMPLE_OMP_ATOMIC_STORE inside OpenACC\n+\tcontexts.\n+\n 2015-11-03  Bilyan Borisov  <bilyan.borisov@arm.com>\n \n \t* config/aarch64/aarch64-simd-builtins.def (fmulx): New."}, {"sha": "886b45ccec34c0ddcfc02d3f328c171efae38c90", "filename": "gcc/builtins.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -182,7 +182,8 @@ along with GCC; see the file COPYING3.  If not see\n #define DEF_GOMP_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n                false, true, true, ATTRS, false, \\\n-\t       (flag_openmp \\\n+\t       (flag_openacc \\\n+\t\t|| flag_openmp \\\n \t\t|| flag_tree_parallelize_loops > 1 \\\n \t\t|| flag_cilkplus \\\n \t\t|| flag_offload_abi != OFFLOAD_ABI_UNSET))"}, {"sha": "7f56722ac66d796837fffb6a3652cb240406b2f3", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1,3 +1,9 @@\n+2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* c-pragma.c (oacc_pragmas): Add \"atomic\".\n+\t* c-pragma.h (pragma_kind): Add PRAGMA_OACC_ATOMIC.\n+\n 2015-10-30  Evgeny Stupachenko  <evstupac@gmail.com>\n \n \t* c-common.c (handle_target_clones_attribute): New."}, {"sha": "ac1183828164182222458c16bb393ac89e417e91", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1204,6 +1204,7 @@ static vec<pragma_ns_name> registered_pp_pragmas;\n \n struct omp_pragma_def { const char *name; unsigned int id; };\n static const struct omp_pragma_def oacc_pragmas[] = {\n+  { \"atomic\", PRAGMA_OACC_ATOMIC },\n   { \"cache\", PRAGMA_OACC_CACHE },\n   { \"data\", PRAGMA_OACC_DATA },\n   { \"enter\", PRAGMA_OACC_ENTER_DATA },"}, {"sha": "69e7392eee32f04f7c68437383d0df402b04f5f6", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n enum pragma_kind {\n   PRAGMA_NONE = 0,\n \n+  PRAGMA_OACC_ATOMIC,\n   PRAGMA_OACC_CACHE,\n   PRAGMA_OACC_DATA,\n   PRAGMA_OACC_ENTER_DATA,"}, {"sha": "7ddafa373c7e7ea82315bd2f17c701f106d9d834", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1,3 +1,8 @@\n+2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* c-parser.c (c_parser_omp_construct): Handle PRAGMA_OACC_ATOMIC.\n+\n 2015-10-29  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c-array-notation.c: Reorder #include's and remove duplicates."}, {"sha": "ec88c65d8461791e8723213f081ce36dc42f84f4", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -16243,6 +16243,9 @@ c_parser_omp_construct (c_parser *parser)\n \n   switch (p_kind)\n     {\n+    case PRAGMA_OACC_ATOMIC:\n+      c_parser_omp_atomic (loc, parser);\n+      return;\n     case PRAGMA_OACC_CACHE:\n       strcpy (p_name, \"#pragma acc\");\n       stmt = c_parser_oacc_cache (loc, parser);"}, {"sha": "884da0fb5f00ac3b69ad676231e62258b55668e6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1,3 +1,9 @@\n+2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* parser.c (cp_parser_omp_construct, cp_parser_pragma): Handle\n+\tPRAGMA_OACC_ATOMIC.\n+\n 2015-10-31  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tRemove the implementation of N3994, terse range-for loops."}, {"sha": "a90bf3b4051e3066a88b5abdaf38d195ad1bc907", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -35464,6 +35464,9 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n \n   switch (pragma_tok->pragma_kind)\n     {\n+    case PRAGMA_OACC_ATOMIC:\n+      cp_parser_omp_atomic (parser, pragma_tok);\n+      return;\n     case PRAGMA_OACC_CACHE:\n       stmt = cp_parser_oacc_cache (parser, pragma_tok);\n       break;\n@@ -36040,6 +36043,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n       cp_parser_omp_declare (parser, pragma_tok, context);\n       return false;\n \n+    case PRAGMA_OACC_ATOMIC:\n     case PRAGMA_OACC_CACHE:\n     case PRAGMA_OACC_DATA:\n     case PRAGMA_OACC_ENTER_DATA:"}, {"sha": "108e2fcd5fa134362e17f2924a281e50eb82f48e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1,3 +1,30 @@\n+2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* gfortran.h (gfc_statement): Add ST_OACC_ATOMIC,\n+\tST_OACC_END_ATOMIC.\n+\t(gfc_exec_op): Add EXEC_OACC_ATOMIC.\n+\t* match.h (gfc_match_oacc_atomic): New prototype.\n+\t* openmp.c (gfc_match_omp_atomic, gfc_match_oacc_atomic): New\n+\twrapper functions around...\n+\t(gfc_match_omp_oacc_atomic): ... this new function.\n+\t(oacc_code_to_statement, gfc_resolve_oacc_directive): Handle\n+\tEXEC_OACC_ATOMIC.\n+\t* parse.c (decode_oacc_directive): Handle \"atomic\", \"end atomic\".\n+\t(case_exec_markers): Add ST_OACC_ATOMIC.\n+\t(gfc_ascii_statement): Handle ST_OACC_ATOMIC, ST_OACC_END_ATOMIC.\n+\t(parse_omp_atomic): Rename to...\n+\t(parse_omp_oacc_atomic): ... this new function.  Add omp_p formal\n+\tparameter.  Adjust all users.\n+\t(parse_executable): Handle ST_OACC_ATOMIC.\n+\t(is_oacc): Handle EXEC_OACC_ATOMIC.\n+\t* resolve.c (gfc_resolve_blocks, gfc_resolve_code): Handle\n+\tEXEC_OACC_ATOMIC.\n+\t* st.c (gfc_free_statement): Handle EXEC_OACC_ATOMIC.\n+\t* trans-openmp.c (gfc_trans_oacc_directive): Handle\n+\tEXEC_OACC_ATOMIC.\n+\t* trans.c (trans_code): Handle EXEC_OACC_ATOMIC.\n+\n 2015-10-31  Cesar Philippidis  <cesar@codesourcery.com>\n \n \tPR Bootstrap/68168"}, {"sha": "e13b4d48afa26bc9e95fa2d52f062dc81898a05d", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -209,6 +209,7 @@ enum gfc_statement\n   ST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE, ST_OACC_WAIT,\n   ST_OACC_CACHE, ST_OACC_KERNELS_LOOP, ST_OACC_END_KERNELS_LOOP,\n   ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA, ST_OACC_ROUTINE,\n+  ST_OACC_ATOMIC, ST_OACC_END_ATOMIC,\n   ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_ATOMIC,\n   ST_OMP_END_CRITICAL, ST_OMP_END_DO, ST_OMP_END_MASTER, ST_OMP_END_ORDERED,\n   ST_OMP_END_PARALLEL, ST_OMP_END_PARALLEL_DO, ST_OMP_END_PARALLEL_SECTIONS,\n@@ -2322,7 +2323,7 @@ enum gfc_exec_op\n   EXEC_OACC_KERNELS_LOOP, EXEC_OACC_PARALLEL_LOOP,\n   EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS, EXEC_OACC_DATA, EXEC_OACC_HOST_DATA,\n   EXEC_OACC_LOOP, EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,\n-  EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA,\n+  EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA, EXEC_OACC_ATOMIC,\n   EXEC_OMP_CRITICAL, EXEC_OMP_DO, EXEC_OMP_FLUSH, EXEC_OMP_MASTER,\n   EXEC_OMP_ORDERED, EXEC_OMP_PARALLEL, EXEC_OMP_PARALLEL_DO,\n   EXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,"}, {"sha": "a52c189c1cf5f2d111b670f693030c394ccd0417", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -124,6 +124,7 @@ gfc_common_head *gfc_get_common (const char *, int);\n /* openmp.c.  */\n \n /* OpenACC directive matchers.  */\n+match gfc_match_oacc_atomic (void);\n match gfc_match_oacc_cache (void);\n match gfc_match_oacc_wait (void);\n match gfc_match_oacc_update (void);"}, {"sha": "929a739972d95e78084347c75dc0059bd006d642", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -2452,8 +2452,8 @@ gfc_match_omp_ordered (void)\n }\n \n \n-match\n-gfc_match_omp_atomic (void)\n+static match\n+gfc_match_omp_oacc_atomic (bool omp_p)\n {\n   gfc_omp_atomic_op op = GFC_OMP_ATOMIC_UPDATE;\n   int seq_cst = 0;\n@@ -2491,13 +2491,24 @@ gfc_match_omp_atomic (void)\n       gfc_error (\"Unexpected junk after $OMP ATOMIC statement at %C\");\n       return MATCH_ERROR;\n     }\n-  new_st.op = EXEC_OMP_ATOMIC;\n+  new_st.op = (omp_p ? EXEC_OMP_ATOMIC : EXEC_OACC_ATOMIC);\n   if (seq_cst)\n     op = (gfc_omp_atomic_op) (op | GFC_OMP_ATOMIC_SEQ_CST);\n   new_st.ext.omp_atomic = op;\n   return MATCH_YES;\n }\n \n+match\n+gfc_match_oacc_atomic (void)\n+{\n+  return gfc_match_omp_oacc_atomic (false);\n+}\n+\n+match\n+gfc_match_omp_atomic (void)\n+{\n+  return gfc_match_omp_oacc_atomic (true);\n+}\n \n match\n gfc_match_omp_barrier (void)\n@@ -4317,6 +4328,8 @@ oacc_code_to_statement (gfc_code *code)\n       return ST_OACC_KERNELS_LOOP;\n     case EXEC_OACC_LOOP:\n       return ST_OACC_LOOP;\n+    case EXEC_OACC_ATOMIC:\n+      return ST_OACC_ATOMIC;\n     default:\n       gcc_unreachable ();\n     }\n@@ -4661,6 +4674,9 @@ gfc_resolve_oacc_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n     case EXEC_OACC_LOOP:\n       resolve_oacc_loop (code);\n       break;\n+    case EXEC_OACC_ATOMIC:\n+      resolve_omp_atomic (code);\n+      break;\n     default:\n       break;\n     }"}, {"sha": "b98dda1ef551ecc9e2f294cdfac921777d623480", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -637,6 +637,9 @@ decode_oacc_directive (void)\n \n   switch (c)\n     {\n+    case 'a':\n+      match (\"atomic\", gfc_match_oacc_atomic, ST_OACC_ATOMIC);\n+      break;\n     case 'c':\n       match (\"cache\", gfc_match_oacc_cache, ST_OACC_CACHE);\n       break;\n@@ -645,6 +648,7 @@ decode_oacc_directive (void)\n       match (\"declare\", gfc_match_oacc_declare, ST_OACC_DECLARE);\n       break;\n     case 'e':\n+      match (\"end atomic\", gfc_match_omp_eos, ST_OACC_END_ATOMIC);\n       match (\"end data\", gfc_match_omp_eos, ST_OACC_END_DATA);\n       match (\"end host_data\", gfc_match_omp_eos, ST_OACC_END_HOST_DATA);\n       match (\"end kernels loop\", gfc_match_omp_eos, ST_OACC_END_KERNELS_LOOP);\n@@ -1373,7 +1377,8 @@ next_statement (void)\n   case ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD: \\\n   case ST_CRITICAL: \\\n   case ST_OACC_PARALLEL_LOOP: case ST_OACC_PARALLEL: case ST_OACC_KERNELS: \\\n-  case ST_OACC_DATA: case ST_OACC_HOST_DATA: case ST_OACC_LOOP: case ST_OACC_KERNELS_LOOP\n+  case ST_OACC_DATA: case ST_OACC_HOST_DATA: case ST_OACC_LOOP: \\\n+  case ST_OACC_KERNELS_LOOP: case ST_OACC_ATOMIC\n \n /* Declaration statements */\n \n@@ -1937,6 +1942,12 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OACC_ROUTINE:\n       p = \"!$ACC ROUTINE\";\n       break;\n+    case ST_OACC_ATOMIC:\n+      p = \"!ACC ATOMIC\";\n+      break;\n+    case ST_OACC_END_ATOMIC:\n+      p = \"!ACC END ATOMIC\";\n+      break;\n     case ST_OMP_ATOMIC:\n       p = \"!$OMP ATOMIC\";\n       break;\n@@ -4316,14 +4327,24 @@ parse_omp_do (gfc_statement omp_st)\n /* Parse the statements of OpenMP atomic directive.  */\n \n static gfc_statement\n-parse_omp_atomic (void)\n+parse_omp_oacc_atomic (bool omp_p)\n {\n-  gfc_statement st;\n+  gfc_statement st, st_atomic, st_end_atomic;\n   gfc_code *cp, *np;\n   gfc_state_data s;\n   int count;\n \n-  accept_statement (ST_OMP_ATOMIC);\n+  if (omp_p)\n+    {\n+      st_atomic = ST_OMP_ATOMIC;\n+      st_end_atomic = ST_OMP_END_ATOMIC;\n+    }\n+  else\n+    {\n+      st_atomic = ST_OACC_ATOMIC;\n+      st_end_atomic = ST_OACC_END_ATOMIC;\n+    }\n+  accept_statement (st_atomic);\n \n   cp = gfc_state_stack->tail;\n   push_state (&s, COMP_OMP_STRUCTURED_BLOCK, NULL);\n@@ -4350,7 +4371,7 @@ parse_omp_atomic (void)\n   pop_state ();\n \n   st = next_statement ();\n-  if (st == ST_OMP_END_ATOMIC)\n+  if (st == st_end_atomic)\n     {\n       gfc_clear_new_st ();\n       gfc_commit_symbols ();\n@@ -4646,7 +4667,7 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n \t\t  continue;\n \n \t\tcase ST_OMP_ATOMIC:\n-\t\t  st = parse_omp_atomic ();\n+\t\t  st = parse_omp_oacc_atomic (true);\n \t\t  continue;\n \n \t\tdefault:\n@@ -4865,8 +4886,12 @@ parse_executable (gfc_statement st)\n \t    return st;\n \t  continue;\n \n+\tcase ST_OACC_ATOMIC:\n+\t  st = parse_omp_oacc_atomic (false);\n+\t  continue;\n+\n \tcase ST_OMP_ATOMIC:\n-\t  st = parse_omp_atomic ();\n+\t  st = parse_omp_oacc_atomic (true);\n \t  continue;\n \n \tdefault:\n@@ -5782,6 +5807,7 @@ is_oacc (gfc_state_data *sd)\n     case EXEC_OACC_CACHE:\n     case EXEC_OACC_ENTER_DATA:\n     case EXEC_OACC_EXIT_DATA:\n+    case EXEC_OACC_ATOMIC:\n       return true;\n \n     default:"}, {"sha": "bf2837c5b72b39f4106d1649716cc6e3ce06f8c7", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -9372,6 +9372,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OACC_CACHE:\n \tcase EXEC_OACC_ENTER_DATA:\n \tcase EXEC_OACC_EXIT_DATA:\n+\tcase EXEC_OACC_ATOMIC:\n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_CRITICAL:\n \tcase EXEC_OMP_DISTRIBUTE:\n@@ -10644,6 +10645,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OACC_CACHE:\n \tcase EXEC_OACC_ENTER_DATA:\n \tcase EXEC_OACC_EXIT_DATA:\n+\tcase EXEC_OACC_ATOMIC:\n \t  gfc_resolve_oacc_directive (code, ns);\n \t  break;\n "}, {"sha": "629b51d371c9236c8d8e3a437f25576911ae0d30", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -240,6 +240,7 @@ gfc_free_statement (gfc_code *p)\n       gfc_free_omp_namelist (p->ext.omp_namelist);\n       break;\n \n+    case EXEC_OACC_ATOMIC:\n     case EXEC_OMP_ATOMIC:\n     case EXEC_OMP_BARRIER:\n     case EXEC_OMP_MASTER:"}, {"sha": "5f4c382a5dd0ec63f616a8ba9a599654139282eb", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -4409,6 +4409,8 @@ gfc_trans_oacc_directive (gfc_code *code)\n       return gfc_trans_oacc_executable_directive (code);\n     case EXEC_OACC_WAIT:\n       return gfc_trans_oacc_wait_directive (code);\n+    case EXEC_OACC_ATOMIC:\n+      return gfc_trans_omp_atomic (code);\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "9495450b2ba7863281221e88dd02531eb9786091", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1903,6 +1903,7 @@ trans_code (gfc_code * code, tree cond)\n \tcase EXEC_OACC_PARALLEL_LOOP:\n \tcase EXEC_OACC_ENTER_DATA:\n \tcase EXEC_OACC_EXIT_DATA:\n+\tcase EXEC_OACC_ATOMIC:\n \t  res = gfc_trans_oacc_directive (code);\n \t  break;\n "}, {"sha": "ccf0b63ce50c5a1125811b56526c6c91fffd2d30", "filename": "gcc/omp-low.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -3212,7 +3212,10 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n     {\n       for (omp_context *ctx_ = ctx; ctx_ != NULL; ctx_ = ctx_->outer)\n \tif (is_gimple_omp (ctx_->stmt)\n-\t    && is_gimple_omp_oacc (ctx_->stmt))\n+\t    && is_gimple_omp_oacc (ctx_->stmt)\n+\t    /* Except for atomic codes that we share with OpenMP.  */\n+\t    && ! (gimple_code (stmt) == GIMPLE_OMP_ATOMIC_LOAD\n+\t\t  || gimple_code (stmt) == GIMPLE_OMP_ATOMIC_STORE))\n \t  {\n \t    error_at (gimple_location (stmt),\n \t\t      \"non-OpenACC construct inside of OpenACC region\");"}, {"sha": "c1ac2b002e57caf4ce901eca9d155887acaec18c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1,3 +1,10 @@\n+2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* c-c++-common/goacc-gomp/nesting-fail-1.c: Move \"atomic\" tests\n+\tfrom here to...\n+\t* c-c++-common/goacc-gomp/nesting-1.c: ... here, and expect them\n+\tto succeed.\n+\n 2015-11-03  Bilyan Borisov  <bilyan.borisov@arm.com>\n \n \t* gcc/testsuite/gcc.target/aarch64/simd/vmulx_f32_1.c: New."}, {"sha": "dabba8cb5ea8e244b4869c9635f93550ee4ee36d", "filename": "gcc/testsuite/c-c++-common/goacc-gomp/nesting-1.c", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1,12 +1,46 @@\n void\n-f_omp_parallel (void)\n+f_acc_data (void)\n {\n-#pragma omp parallel\n+#pragma acc data\n   {\n     int i;\n+#pragma omp atomic write\n+    i = 0;\n+  }\n+}\n+\n+void\n+f_acc_kernels (void)\n+{\n+#pragma acc kernels\n+  {\n+    int i;\n+#pragma omp atomic write\n+    i = 0;\n+  }\n+}\n \n-#pragma acc loop /* { dg-error \"loop directive must be associated with an OpenACC compute region\" } */\n-    for (i = 0; i < 2; ++i)\n-      ;\n+void\n+f_acc_loop (void)\n+{\n+  int i;\n+\n+#pragma acc parallel\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp atomic write\n+      i = 0;\n+    }\n+}\n+\n+void\n+f_acc_parallel (void)\n+{\n+#pragma acc parallel\n+  {\n+    int i;\n+#pragma omp atomic write\n+    i = 0;\n   }\n }"}, {"sha": "e98258c3353c5be0ef47cf999c946418c872c144", "filename": "gcc/testsuite/c-c++-common/goacc-gomp/nesting-fail-1.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -214,12 +214,6 @@ f_acc_parallel (void)\n     ;\n   }\n \n-#pragma acc parallel\n-  {\n-#pragma omp atomic write\n-    i = 0; /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n-  }\n-\n #pragma acc parallel\n   {\n #pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n@@ -284,12 +278,6 @@ f_acc_kernels (void)\n     ;\n   }\n \n-#pragma acc kernels\n-  {\n-#pragma omp atomic write\n-    i = 0; /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n-  }\n-\n #pragma acc kernels\n   {\n #pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n@@ -354,12 +342,6 @@ f_acc_data (void)\n     ;\n   }\n \n-#pragma acc data\n-  {\n-#pragma omp atomic write\n-    i = 0; /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n-  }\n-\n #pragma acc data\n   {\n #pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n@@ -438,14 +420,6 @@ f_acc_loop (void)\n       ;\n     }\n \n-#pragma acc parallel\n-#pragma acc loop\n-  for (i = 0; i < 2; ++i)\n-    {\n-#pragma omp atomic write\n-      i = 0; /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n-    }\n-\n #pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)"}, {"sha": "7894a7e2c16261811d2b05f4b3d5ac71d991035f", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -1,3 +1,25 @@\n+2015-11-03  Julian Brown  <julian@codesourcery.com>\n+\t    Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* testsuite/libgomp.oacc-c-c++-common/par-reduction-1.c: New file.\n+\t* testsuite/libgomp.oacc-c-c++-common/par-reduction-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/worker-single-1a.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/worker-single-4.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/worker-single-6.c: Likewise.\n+\n+2015-11-03  James Norris  <jnorris@codesourcery.com>\n+\n+\t* testsuite/libgomp.oacc-c-c++-common/atomic_capture-1.c: New\n+\tfile.\n+\t* testsuite/libgomp.oacc-c-c++-common/atomic_capture-2.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/atomic_rw-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/atomic_update-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/atomic_capture-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/atomic_rw-1.f90: New file.\n+\t* testsuite/libgomp.oacc-fortran/atomic_update-1.f90: Likewise.\n+\n 2015-10-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* openacc.h (enum acc_device_t): Reformat. Ensure layout"}, {"sha": "ad958cd1f9eaaf8aec13de614963618d0d85b98a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_capture-1.c", "status": "added", "additions": 866, "deletions": 0, "changes": 866, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-1.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,866 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+int\n+main(int argc, char **argv)\n+{\n+  int   iexp, igot;\n+  long long lexp, lgot;\n+  int   N = 32;\n+  int   idata[N];\n+  long long   ldata[N];\n+  float fexp, fgot;\n+  float fdata[N];\n+  int i;\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic capture\n+        idata[i] = igot++;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic capture\n+        idata[i] = igot--;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic capture\n+        idata[i] = ++igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic capture\n+        idata[i] = --igot;\n+      }\n+  }\n+\n+  /* BINOP = + */\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot += expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = igot + expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = expr + igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = * */\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot *= expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot = lgot * expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot = expr * lgot;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = - */\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot -= expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = igot - expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = expr - igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+\n+  /* BINOP = / */\n+  lgot = 1LL << 32;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot /= expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << 32;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot = lgot / expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 2LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot = expr / lgot;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = & */\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot &= expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = igot & expr;\n+    }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = expr & igot;\n+     }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = ^ */\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot ^= expr;\n+     }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = igot ^ expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = expr ^ igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = | */\n+  igot = 0;\n+  iexp = ~0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot |= expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = ~0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = igot | expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = ~0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        idata[i] = igot = expr | igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = << */\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot <<= expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        idata[i] = lgot = lgot << expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel\n+    {\n+      long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+      ldata[0] = lgot = expr << lgot;\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = >> */\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot >>= expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        ldata[i] = lgot = lgot >> expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << 63;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel\n+    {\n+      long long expr = 1LL << 32;\n+\n+#pragma acc atomic capture\n+      ldata[0] = lgot = expr >> lgot;\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic capture\n+        fdata[i] = fgot++;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic capture\n+        fdata[i] = fgot--;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic capture\n+        fdata[i] = ++fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic capture\n+        fdata[i] = --fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = + */\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot += expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot = fgot + expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot = expr + fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = * */\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot *= expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot = fgot * expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot = expr * fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = - */\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot -= expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot = fgot - expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 32.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot = expr - fgot;\n+      }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (fdata[i] != 31.0)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (fdata[i] != 1.0)\n+\t  abort ();\n+      }\n+\n+\n+  /* BINOP = / */\n+  fexp = 1.0;\n+  fgot = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot /= expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fexp = 1.0;\n+  fgot = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        fdata[i] = fgot = fgot / expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fexp = 1.0;\n+  fgot = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel\n+    {\n+      float expr = 8192.0*8192.0*64.0;\n+\n+#pragma acc atomic capture\n+      fdata[0] = fgot = expr / fgot;\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+  \n+  return 0;\n+}"}, {"sha": "842f2de4722db93ee38c65af45781a2defef9ff7", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_capture-2.c", "status": "added", "additions": 1626, "deletions": 0, "changes": 1626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-2.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,1626 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+int\n+main(int argc, char **argv)\n+{\n+  int   iexp, igot, imax, imin;\n+  long long lexp, lgot;\n+  int   N = 32;\n+  int\ti;\n+  int   idata[N];\n+  long long ldata[N];\n+  float fexp, fgot;\n+  float fdata[N];\n+\n+  igot = 1234;\n+  iexp = 31;\n+\n+  for (i = 0; i < N; i++)\n+    idata[i] = i;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot = i; }\n+  }\n+\n+  imax = 0;\n+  imin = N;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      imax = idata[i] > imax ? idata[i] : imax;\n+      imin = idata[i] < imin ? idata[i] : imin;\n+    }\n+\n+  if (imax != 1234 || imin != 0)\n+    abort ();\n+\n+  return 0;\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot++; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; ++igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { ++igot; idata[i] = igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { igot++; idata[i] = igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot--; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; --igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { --igot; idata[i] = igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { igot--; idata[i] = igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = + */\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { idata[i] = igot; igot += expr; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot += expr; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { idata[i] = igot; igot = igot + expr; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { idata[i] = igot; igot = expr + igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot = igot + expr; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot = expr + igot; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = * */\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot *= expr; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { lgot *= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot * expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot = expr * lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { lgot = lgot * expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2;\n+\n+#pragma acc atomic capture\n+      { lgot = expr * lgot; ldata[i] = lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = - */\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      int expr = 1;\n+\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot -= expr; }\n+    }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot -= expr; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { idata[i] = igot; igot = igot - expr; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 1;\n+  iexp = 1;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      int expr = 1;\n+\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot = expr - igot; }\n+    }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (idata[i] != 1)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (idata[i] != 0)\n+\t  abort ();\n+      }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 1;\n+  iexp = -31;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot = igot - expr; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 1;\n+  iexp = 1;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot = expr - igot; idata[i] = igot; }\n+      }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (idata[i] != 0)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (idata[i] != 1)\n+\t  abort ();\n+      }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = / */\n+  lgot = 1LL << 32;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot /= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << 32;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { lgot /= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << 32;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot = lgot / expr; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 2LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr / lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 2LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { lgot = lgot / expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 2LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { lgot = expr / lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = & */\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot &= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  iexp = 0LL; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot &= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot & expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr & lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  iexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = lgot & expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+      { lgot = expr & lgot; ldata[i] = lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = ^ */\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 1 << i;\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot ^= expr; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  iexp = 0LL; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot ^= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot ^ expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot = expr ^ lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  iexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = lgot ^ expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = expr ^ lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = | */\n+  lgot = 0LL;\n+  lexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot |= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  iexp = ~0LL; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot |= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  lexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot | expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  lexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr | lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  iexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = lgot | expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  lexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = expr | lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = << */\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot <<= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  iexp = 1LL << N; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot <<= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot << expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr << lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot = lgot << expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot = expr << lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = >> */\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+  \n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot >>= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << N;\n+  iexp = 1LL; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot >>= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot >> expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << (N - 1);\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr >> lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot = lgot >> expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << (N - 1);\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { lgot = expr >> lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  // FLOAT FLOAT FLOAT\n+\n+  /* BINOP = + */\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      float expr = 1.0;\n+\n+#pragma acc atomic capture\n+      { fdata[i] = fgot; fgot += expr; }\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot += expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { idata[i] = fgot; fgot = fgot + expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      float expr = 1.0;\n+\n+#pragma acc atomic capture\n+      { fdata[i] = fgot; fgot = expr + fgot; }\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot = fgot + expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot = expr + fgot; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = * */\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      float expr = 2.0;\n+\n+#pragma acc atomic capture\n+      { fdata[i] = fgot; fgot *= expr; }\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fgot *= expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = fgot * expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = expr * fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+      { lgot = lgot * expr; ldata[i] = lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2;\n+\n+#pragma acc atomic capture\n+        { fgot = expr * fgot; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = - */\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+  \n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot -= expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      float expr = 1.0;\n+\n+#pragma acc atomic capture\n+      { fgot -= expr; fdata[i] = fgot; }\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = fgot - expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = expr - fgot; }\n+      }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (fdata[i] != 1.0)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (fdata[i] != 0.0)\n+\t  abort ();\n+      }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = -31.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot = fgot - expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot = expr - fgot; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (fdata[i] != 0.0)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (fdata[i] != 1.0)\n+\t  abort ();\n+      }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = / */\n+  fgot = 8192.0*8192.0*64.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot /= expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 8192.0*8192.0*64.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fgot /= expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 8192.0*8192.0*64.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = fgot / expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 8192.0*8192.0*64.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = expr / fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 4.0;\n+  fexp = 4.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { fgot = fgot / expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 4.0;\n+  fexp = 4.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fgot = expr / fgot; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "ae4f22e0d29c58116a3b4433173edfa90e202f54", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_rw-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_rw-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_rw-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_rw-1.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+int\n+main(int argc, char **argv)\n+{\n+  int v1, v2;\n+  int x;\n+\n+  x = 99;\n+\n+#pragma acc parallel copy (v1, v2, x)\n+  {\n+\n+#pragma acc atomic read\n+    v1 = x;\n+\n+#pragma acc atomic write\n+    x = 32;\n+\n+#pragma acc atomic read\n+    v2 = x;\n+\n+  }\n+\n+  if (v1 != 99)\n+    abort ();\n+\n+  if (v2 != 32)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "18ee3aa945bc77b750997b5517aacccb6b2133b4", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_update-1.c", "status": "added", "additions": 760, "deletions": 0, "changes": 760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_update-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_update-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_update-1.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,760 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+int\n+main(int argc, char **argv)\n+{\n+  float fexp, fgot;\n+  int   iexp, igot;\n+  long long lexp, lgot;\n+  int   N = 32;\n+  int\ti;\n+\n+  fgot = 1234.0;\n+  fexp = 1235.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+#pragma acc atomic update\n+      fgot++;\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = fgot - N;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic update\n+        fgot--;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = fgot + N;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic update\n+        ++fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = fgot - N;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+#pragma acc atomic update\n+        --fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = + */\n+\n+  fgot = 1234.0;\n+  fexp = fgot + N;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+#pragma acc atomic update\n+        fgot += expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = fgot + N;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+#pragma acc atomic update\n+        fgot = fgot + expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = fgot + N;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+#pragma acc atomic update\n+        fgot = expr + fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 0.5;\n+#pragma acc atomic update\n+        fgot = (expr + expr) + fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = * */\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp *= 2.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+#pragma acc atomic update\n+        fgot *= expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp = fexp * 2.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+#pragma acc atomic update\n+        fgot = fgot * expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp = 2.0 * fexp;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+#pragma acc atomic update\n+        fgot = expr * fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+#pragma acc atomic update\n+        fgot = (expr + expr) * fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = - */\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp -= 2.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+#pragma acc atomic update\n+        fgot -= expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp = fexp - 2.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+#pragma acc atomic update\n+        fgot = fgot - expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp = 2.0 - fexp;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic update\n+        fgot = expr - fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+#pragma acc atomic update\n+        fgot = (expr + expr) - fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = / */\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp /= 2.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+#pragma acc atomic update\n+        fgot /= expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp = fexp / 2.0;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\t\n+#pragma acc atomic update\n+        fgot = fgot / expr;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp = 2.0 / fexp;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic update\n+        fgot = expr / fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1234.0;\n+  fexp = 1234.0;\n+\n+  for (i = 0; i < N; i++)\n+    fexp = 2.0 / fexp;\n+\n+#pragma acc data copy (fgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+#pragma acc atomic update\n+        fgot = (expr + expr) / fgot;\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = & */\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = ~(1 << i);\n+\n+#pragma acc atomic update\n+        igot &= expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = ~(1 << i);\n+#pragma acc atomic update\n+        igot = igot / expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = ~(1 << i);\n+#pragma acc atomic update\n+        igot = expr & igot;\n+     }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = ~(1 << i);\n+        int zero = 0;\n+\n+#pragma acc atomic update\n+        igot = (expr + zero) & igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = ^ */\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = (1 << i);\n+\n+#pragma acc atomic update\n+        igot ^= expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = (1 << i);\n+\n+#pragma acc atomic update\n+        igot = igot ^ expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = (1 << i);\n+\n+#pragma acc atomic update\n+        igot = expr ^ igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = ~0;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = (1 << i);\n+        int zero = 0;\n+\n+#pragma acc atomic update\n+        igot = (expr + zero) ^ igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = | */\n+\n+  igot = 0;\n+  iexp = ~0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = (1 << i);\n+\n+#pragma acc atomic update\n+        igot |= expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = ~0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = (1 << i);\n+\n+#pragma acc atomic update\n+        igot = igot | expr;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = ~0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = (1 << i);\n+\n+#pragma acc atomic update\n+        igot = expr | igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = ~0;\n+\n+#pragma acc data copy (igot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = (1 << i);\n+        int zero = 0;\n+\n+#pragma acc atomic update\n+        igot = (expr + zero) | igot;\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = << */\n+\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic update\n+        lgot <<= expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic update\n+        lgot = lgot << expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic update\n+        lgot = expr << lgot;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL;\n+        long long zero = 0LL;\n+\n+#pragma acc atomic update\n+        lgot = (expr + zero) << lgot;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = >> */\n+\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic update\n+        lgot >>= expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic update\n+        lgot = lgot >> expr;\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << (N - 1);\n+\n+#pragma acc data copy (lgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic update\n+        lgot = expr >> lgot;\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << (N - 1);\n+\n+#pragma acc data copy (lgot)\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL << N;\n+        long long zero = 0LL;\n+\n+#pragma acc atomic update\n+        lgot = (expr + zero) >> lgot;\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "dbe82fe67e19b3cc8c3a2193db1926c05188c01e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/par-reduction-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpar-reduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpar-reduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpar-reduction-1.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,44 @@\n+#include <assert.h>\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int res, res2 = 0;\n+\n+#if defined(ACC_DEVICE_TYPE_host)\n+# define GANGS 1\n+#else\n+# define GANGS 256\n+#endif\n+  #pragma acc parallel num_gangs(GANGS) num_workers(1) vector_length(1) \\\n+\t\t       copy(res2)\n+  {\n+    #pragma acc atomic\n+    res2 += 5;\n+  }\n+  res = GANGS * 5;\n+\n+  assert (res == res2);\n+#undef GANGS\n+\n+  res = res2 = 1;\n+\n+#if defined(ACC_DEVICE_TYPE_host)\n+# define GANGS 1\n+#else\n+# define GANGS 8\n+#endif\n+  #pragma acc parallel num_gangs(GANGS) num_workers(1) vector_length(1) \\\n+\t\t       copy(res2)\n+  {\n+    #pragma acc atomic\n+    res2 *= 5;\n+  }\n+  for (int i = 0; i < GANGS; ++i)\n+    res *= 5;\n+\n+  assert (res == res2);\n+#undef GANGS\n+\n+  return 0;\n+}"}, {"sha": "12ab552284ca8c814356633d521ffdd8ffeb3c47", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/par-reduction-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpar-reduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpar-reduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpar-reduction-2.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,48 @@\n+#include <assert.h>\n+#include <openacc.h>\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int res, res2 = 0;\n+\n+#if defined(ACC_DEVICE_TYPE_host)\n+# define GANGS 1\n+#else\n+# define GANGS 256\n+#endif\n+  #pragma acc parallel num_gangs(GANGS) num_workers(1) vector_length(1) \\\n+\t\t       copy(res2) async(1)\n+  {\n+    #pragma acc atomic\n+    res2 += 5;\n+  }\n+  res = GANGS * 5;\n+\n+  acc_wait (1);\n+\n+  assert (res == res2);\n+#undef GANGS\n+\n+  res = res2 = 1;\n+\n+#if defined(ACC_DEVICE_TYPE_host)\n+# define GANGS 1\n+#else\n+# define GANGS 8\n+#endif\n+  #pragma acc parallel num_gangs(GANGS) num_workers(1) vector_length(1) \\\n+\t\t       copy(res2) async(1)\n+  {\n+    #pragma acc atomic\n+    res2 *= 5;\n+  }\n+  for (int i = 0; i < GANGS; ++i)\n+    res *= 5;\n+\n+  acc_wait (1);\n+\n+  assert (res == res2);\n+\n+  return 0;\n+}"}, {"sha": "99c6dfbf8a3ccd5ddc0a8c01389dc1dfe7ae0b44", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/worker-single-1a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-1a.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,28 @@\n+#include <assert.h>\n+\n+/* Test worker-single/vector-single mode.  */\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int arr[32], i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 0;\n+\n+  #pragma acc parallel copy(arr) num_gangs(8) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      {\n+\t#pragma acc atomic\n+\tarr[j]++;\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == 1);\n+\n+  return 0;\n+}"}, {"sha": "84080d0a8e5fe654bfe819f0a95e8902b469a26e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/worker-single-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-4.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,28 @@\n+#include <assert.h>\n+\n+/* Test worker-single/vector-partitioned mode.  */\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int arr[32], i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(1) num_workers(8) vector_length(32)\n+      {\n+\tint k;\n+\t#pragma acc loop vector\n+\tfor (k = 0; k < 32; k++)\n+\t  {\n+\t    #pragma acc atomic\n+\t    arr[k]++;\n+\t  }\n+      }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == i + 1);\n+\n+  return 0;\n+}"}, {"sha": "cbc3e37a3a0166fd6d2f2d07a0552cfabae0980e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/worker-single-6.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-6.c?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,46 @@\n+#include <assert.h>\n+\n+#if defined(ACC_DEVICE_TYPE_host)\n+#define ACTUAL_GANGS 1\n+#else\n+#define ACTUAL_GANGS 8\n+#endif\n+\n+/* Test worker-single, vector-partitioned, gang-redundant mode.  */\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int n, arr[32], i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 0;\n+\n+  n = 0;\n+\n+  #pragma acc parallel copy(n, arr) num_gangs(ACTUAL_GANGS) num_workers(8) \\\n+\t  vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc atomic\n+    n++;\n+\n+    #pragma acc loop vector\n+    for (j = 0; j < 32; j++)\n+      {\n+\t#pragma acc atomic\n+\tarr[j] += 1;\n+      }\n+\n+    #pragma acc atomic\n+    n++;\n+  }\n+\n+  assert (n == ACTUAL_GANGS * 2);\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == ACTUAL_GANGS);\n+\n+  return 0;\n+}"}, {"sha": "27c5c9e57bdc47b801ae3cd05a1c50e7d2132edd", "filename": "libgomp/testsuite/libgomp.oacc-fortran/atomic_capture-1.f90", "status": "added", "additions": 784, "deletions": 0, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_capture-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_capture-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_capture-1.f90?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,784 @@\n+! { dg-do run }\n+\n+program main\n+  integer igot, iexp, itmp\n+  real fgot, fexp, ftmp\n+  logical lgot, lexp, ltmp\n+  integer, parameter :: N = 32\n+\n+  igot = 0\n+  iexp = N * 2\n+\n+  !$acc parallel copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = i + i\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel\n+\n+  if (igot /= iexp) call abort\n+  if (itmp /= iexp - 2) call abort\n+\n+  fgot = 1234.0\n+  fexp = 1266.0\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      ftmp = fgot\n+      fgot = fgot + 1.0\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp - 1.0) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 1.0\n+  fexp = 2.0**32\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      ftmp = fgot\n+      fgot = fgot * 2.0\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp / 2.0) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 32.0\n+  fexp = fgot - N\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      ftmp = fgot\n+      fgot = fgot - 1.0\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp + 1.0) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 2**32.0\n+  fexp = 1.0\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      ftmp = fgot\n+      fgot = fgot / 2.0\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fgot * 2.0) call abort\n+  if (fgot /= fexp) call abort\n+\n+  lgot = .TRUE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    ltmp = lgot\n+    lgot = lgot .and. .FALSE.\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. .not. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    ltmp = lgot\n+    lgot = lgot .or. .FALSE.\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    ltmp = lgot\n+    lgot = lgot .eqv. .TRUE.\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .TRUE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    ltmp = lgot\n+    lgot = lgot .neqv. .TRUE.\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. .not. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  fgot = 1234.0\n+  fexp = 1266.0\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      ftmp = fgot\n+      fgot = 1.0 + fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp - 1.0) call abort \n+  if (fgot /= fexp) call abort\n+\n+  fgot = 1.0\n+  fexp = 2.0**32\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      ftmp = fgot\n+      fgot = 2.0 * fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp / 2.0) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 32.0\n+  fexp = 32.0\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      ftmp = fgot\n+      fgot = 2.0 - fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= 2.0 - fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 2.0**16\n+  fexp = 2.0**16\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      ftmp = fgot\n+      fgot = 2.0 / fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= 2.0 / fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  lgot = .TRUE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    ltmp = lgot\n+    lgot = .FALSE. .and. lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. .not. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    ltmp = lgot\n+    lgot = .FALSE. .or. lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    ltmp = lgot\n+    lgot = .TRUE. .eqv. lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .TRUE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    ltmp = lgot\n+    lgot = .TRUE. .neqv. lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. .not. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  igot = 1\n+  iexp = N\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = max (igot, i)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp - 1) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = N\n+  iexp = 1\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = min (igot, i)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = ibclr (-2, i)\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = iand (igot, iexpr)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= ibset (iexp, N - 1)) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = 0\n+  iexp = -1 \n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = ior (igot, iexpr)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= ieor (iexp, lshift (1, N - 1))) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0 \n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = ieor (igot, iexpr)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= ior (iexp, lshift (1, N - 1))) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = 1\n+  iexp = N\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = max (i, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp - 1) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = N\n+  iexp = 1\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = min (i, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = ibclr (-2, i)\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = iand (iexpr, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= ibset (iexp, N - 1)) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = 0\n+  iexp = -1 \n+\t!!\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = ior (iexpr, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= ieor (iexp, lshift (1, N - 1))) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0 \n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic capture\n+      itmp = igot\n+      igot = ieor (iexpr, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= ior (iexp, lshift (1, N - 1))) call abort\n+  if (igot /= iexp) call abort\n+\n+  fgot = 1234.0\n+  fexp = 1266.0\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      fgot = fgot + 1.0\n+      ftmp = fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 1.0\n+  fexp = 2.0**32\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      fgot = fgot * 2.0\n+      ftmp = fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 32.0\n+  fexp = fgot - N\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      fgot = fgot - 1.0\n+      ftmp = fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 2**32.0\n+  fexp = 1.0\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      fgot = fgot / 2.0\n+      ftmp = fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  lgot = .TRUE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    lgot = lgot .and. .FALSE.\n+    ltmp = lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    lgot = lgot .or. .FALSE.\n+    ltmp = lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    lgot = lgot .eqv. .TRUE.\n+    ltmp = lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .TRUE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    lgot = lgot .neqv. .TRUE.\n+    ltmp = lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  fgot = 1234.0\n+  fexp = 1266.0\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      fgot = 1.0 + fgot\n+      ftmp = fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 1.0\n+  fexp = 2.0**32\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      fgot = 2.0 * fgot\n+      ftmp = fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 32.0\n+  fexp = 32.0\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      fgot = 2.0 - fgot\n+      ftmp = fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 2.0**16\n+  fexp = 2.0**16\n+\n+  !$acc parallel loop copy (fgot, ftmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      fgot = 2.0 / fgot\n+      ftmp = fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (ftmp /= fexp) call abort\n+  if (fgot /= fexp) call abort\n+\n+  lgot = .TRUE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    lgot = .FALSE. .and. lgot\n+    ltmp = lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    lgot = .FALSE. .or. lgot\n+    ltmp = lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    lgot = .TRUE. .eqv. lgot\n+    ltmp = lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .TRUE.\n+\n+  !$acc parallel copy (lgot, ltmp)\n+  !$acc atomic capture\n+    lgot = .TRUE. .neqv. lgot\n+    ltmp = lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (ltmp .neqv. lexp) call abort\n+  if (lgot .neqv. lexp) call abort\n+\n+  igot = 1\n+  iexp = N\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      igot = max (igot, i)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = N\n+  iexp = 1\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      igot = min (igot, i)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = ibclr (-2, i)\n+  !$acc atomic capture\n+      igot = iand (igot, iexpr)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = 0\n+  iexp = -1 \n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic capture\n+      igot = ior (igot, iexpr)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0 \n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic capture\n+      igot = ieor (igot, iexpr)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = 1\n+  iexp = N\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      igot = max (i, igot)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = N\n+  iexp = 1\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 1, N\n+  !$acc atomic capture\n+      igot = min (i, igot)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0\n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = ibclr (-2, i)\n+  !$acc atomic capture\n+      igot = iand (iexpr, igot)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = 0\n+  iexp = -1 \n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic capture\n+      igot = ior (iexpr, igot)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0 \n+\n+  !$acc parallel loop copy (igot, itmp)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic capture\n+      igot = ieor (iexpr, igot)\n+      itmp = igot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (itmp /= iexp) call abort\n+  if (igot /= iexp) call abort\n+\n+end program"}, {"sha": "51ec9aaca8729d327b84f90a82112197e0273b83", "filename": "libgomp/testsuite/libgomp.oacc-fortran/atomic_rw-1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_rw-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_rw-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_rw-1.f90?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+\n+program main\n+  integer v1, v2\n+  integer x\n+\n+  x = 99\n+\n+  !$acc parallel copy (v1, v2, x)\n+\n+  !$acc atomic read\n+    v1 = x;\n+  !$acc end atomic\n+\n+  !$acc atomic write\n+    x = 32;\n+  !$acc end atomic\n+\n+  !$acc atomic read\n+    v2 = x;\n+  !$acc end atomic\n+\n+  !$acc end parallel\n+\n+  if (v1 .ne. 99) call abort\n+\n+  if (v2 .ne. 32) call abort\n+\n+end program main"}, {"sha": "6607c77c9356bfe76426ed1ba6bae13afd691c33", "filename": "libgomp/testsuite/libgomp.oacc-fortran/atomic_update-1.f90", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_update-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_update-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fatomic_update-1.f90?ref=4bf9e5a8a2a40fb4ca87deede2cf7b0cb016cd45", "patch": "@@ -0,0 +1,338 @@\n+! { dg-do run }\n+\n+program main\n+  integer igot, iexp, iexpr\n+  real fgot, fexp\n+  integer i\n+  integer, parameter :: N = 32\n+  logical lgot, lexp\n+\n+  fgot = 1234.0\n+  fexp = 1266.0\n+\n+  !$acc parallel loop copy (fgot)\n+    do i = 1, N\n+  !$acc atomic update\n+      fgot = fgot + 1.0\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 1.0\n+  fexp = 2.0**32\n+\n+  !$acc parallel loop copy (fgot)\n+    do i = 1, N\n+  !$acc atomic update\n+      fgot = fgot * 2.0\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 32.0\n+  fexp = fgot - N\n+\n+  !$acc parallel loop copy (fgot)\n+    do i = 1, N\n+  !$acc atomic update\n+      fgot = fgot - 1.0\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 2**32.0\n+  fexp = 1.0\n+\n+  !$acc parallel loop copy (fgot)\n+    do i = 1, N\n+  !$acc atomic update\n+      fgot = fgot / 2.0\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (fgot /= fexp) call abort\n+\n+  lgot = .TRUE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot)\n+  !$acc atomic update\n+    lgot = lgot .and. .FALSE.\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot)\n+  !$acc atomic update\n+    lgot = lgot .or. .FALSE.\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot)\n+  !$acc atomic update\n+    lgot = lgot .eqv. .TRUE.\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .TRUE.\n+\n+  !$acc parallel copy (lgot)\n+  !$acc atomic update\n+    lgot = lgot .neqv. .TRUE.\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (lgot .neqv. lexp) call abort\n+\n+  fgot = 1234.0\n+  fexp = 1266.0\n+\n+  !$acc parallel loop copy (fgot)\n+    do i = 1, N\n+  !$acc atomic update\n+      fgot = 1.0 + fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 1.0\n+  fexp = 2.0**32\n+\n+  !$acc parallel loop copy (fgot)\n+    do i = 1, N\n+  !$acc atomic update\n+      fgot = 2.0 * fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 32.0\n+  fexp = 32.0\n+\n+  !$acc parallel loop copy (fgot)\n+    do i = 1, N\n+  !$acc atomic update\n+      fgot = 2.0 - fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (fgot /= fexp) call abort\n+\n+  fgot = 2.0**16\n+  fexp = 2.0**16\n+\n+  !$acc parallel loop copy (fgot)\n+    do i = 1, N\n+  !$acc atomic update\n+      fgot = 2.0 / fgot\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (fgot /= fexp) call abort\n+\n+  lgot = .TRUE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot)\n+  !$acc atomic update\n+    lgot = .FALSE. .and. lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot)\n+  !$acc atomic update\n+    lgot = .FALSE. .or. lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .FALSE.\n+\n+  !$acc parallel copy (lgot)\n+  !$acc atomic update\n+    lgot = .TRUE. .eqv. lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (lgot .neqv. lexp) call abort\n+\n+  lgot = .FALSE.\n+  lexp = .TRUE.\n+\n+  !$acc parallel copy (lgot)\n+  !$acc atomic update\n+    lgot = .TRUE. .neqv. lgot\n+  !$acc end atomic\n+  !$acc end parallel\n+\n+  if (lgot .neqv. lexp) call abort\n+\n+  igot = 1\n+  iexp = N\n+\n+  !$acc parallel loop copy (igot)\n+    do i = 1, N\n+  !$acc atomic update\n+      igot = max (igot, i)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = N\n+  iexp = 1\n+\n+  !$acc parallel loop copy (igot)\n+    do i = 1, N\n+  !$acc atomic update\n+      igot = min (igot, i)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0\n+\n+  !$acc parallel loop copy (igot)\n+    do i = 0, N - 1\n+      iexpr = ibclr (-2, i)\n+  !$acc atomic update\n+      igot = iand (igot, iexpr)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = 0\n+  iexp = -1 \n+\n+  !$acc parallel loop copy (igot)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic update\n+      igot = ior (igot, iexpr)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0 \n+\n+  !$acc parallel loop copy (igot)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic update\n+      igot = ieor (igot, iexpr)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = 1\n+  iexp = N\n+\n+  !$acc parallel loop copy (igot)\n+    do i = 1, N\n+  !$acc atomic update\n+      igot = max (i, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = N\n+  iexp = 1\n+\n+  !$acc parallel loop copy (igot)\n+    do i = 1, N\n+  !$acc atomic update\n+      igot = min (i, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0\n+\n+  !$acc parallel loop copy (igot)\n+    do i = 0, N - 1\n+      iexpr = ibclr (-2, i)\n+  !$acc atomic update\n+      igot = iand (iexpr, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = 0\n+  iexp = -1 \n+\n+  !$acc parallel loop copy (igot)\n+    do i = 0, N - 1\n+        iexpr = lshift (1, i)\n+  !$acc atomic update\n+      igot = ior (iexpr, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+  igot = -1\n+  iexp = 0 \n+\n+  !$acc parallel loop copy (igot)\n+    do i = 0, N - 1\n+      iexpr = lshift (1, i)\n+  !$acc atomic update\n+      igot = ieor (iexpr, igot)\n+  !$acc end atomic\n+    end do\n+  !$acc end parallel loop\n+\n+  if (igot /= iexp) call abort\n+\n+end program"}]}