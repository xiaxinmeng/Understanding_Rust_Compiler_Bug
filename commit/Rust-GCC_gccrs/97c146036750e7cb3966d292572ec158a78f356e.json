{"sha": "97c146036750e7cb3966d292572ec158a78f356e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdjMTQ2MDM2NzUwZTdjYjM5NjZkMjkyNTcyZWMxNThhNzhmMzU2ZQ==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2019-10-29T13:15:46Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2019-10-29T13:15:46Z"}, "message": "[vect]PR 88915: Vectorize epilogues when versioning loops\n\ngcc/ChangeLog:\n2019-10-29  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\tPR 88915\n\t* tree-ssa-loop-niter.h (simplify_replace_tree): Change declaration.\n\t* tree-ssa-loop-niter.c (simplify_replace_tree): Add context parameter\n\tand make the valueize function pointer also take a void pointer.\n\t* gcc/tree-ssa-sccvn.c (vn_valueize_wrapper): New function to wrap\n\taround vn_valueize, to call it without a context.\n\t(process_bb): Use vn_valueize_wrapper instead of vn_valueize.\n\t* tree-vect-loop.c (_loop_vec_info): Initialize epilogue_vinfos.\n\t(~_loop_vec_info): Release epilogue_vinfos.\n\t(vect_analyze_loop_costing): Use knowledge of main VF to estimate\n\tnumber of iterations of epilogue.\n\t(vect_analyze_loop_2): Adapt to analyse main loop for all supported\n\tvector sizes when vect-epilogues-nomask=1.  Also keep track of lowest\n\tversioning threshold needed for main loop.\n\t(vect_analyze_loop): Likewise.\n\t(find_in_mapping): New helper function.\n\t(update_epilogue_loop_vinfo): New function.\n\t(vect_transform_loop): When vectorizing epilogues re-use analysis done\n\ton main loop and call update_epilogue_loop_vinfo to update it.\n\t* tree-vect-loop-manip.c (vect_update_inits_of_drs): No longer insert\n\tstmts on loop preheader edge.\n\t(vect_do_peeling): Enable skip-vectors when doing loop versioning if\n\twe decided to vectorize epilogues.  Update epilogues NITERS and\n\tconstruct ADVANCE to update epilogues data references where needed.\n\t* tree-vectorizer.h (_loop_vec_info): Add epilogue_vinfos.\n\t(vect_do_peeling, vect_update_inits_of_drs,\n\t determine_peel_for_niter, vect_analyze_loop): Add or update\n\tdeclarations.\n\t* tree-vectorizer.c (try_vectorize_loop_1): Make sure to use already\n\tcreated loop_vec_info's for epilogues when available.  Otherwise analyse\n\tepilogue separately.\n\nFrom-SVN: r277569", "tree": {"sha": "f8bd6e942ea43e0643932c1975603c427d76bb64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8bd6e942ea43e0643932c1975603c427d76bb64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97c146036750e7cb3966d292572ec158a78f356e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c146036750e7cb3966d292572ec158a78f356e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c146036750e7cb3966d292572ec158a78f356e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c146036750e7cb3966d292572ec158a78f356e/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ab768774318cff1ecc7951a59bc9f66ceb015ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ab768774318cff1ecc7951a59bc9f66ceb015ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ab768774318cff1ecc7951a59bc9f66ceb015ff"}], "stats": {"total": 623, "additions": 524, "deletions": 99}, "files": [{"sha": "48f562ba6aafd98a26851a9114b838c21dcbc938", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c146036750e7cb3966d292572ec158a78f356e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c146036750e7cb3966d292572ec158a78f356e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97c146036750e7cb3966d292572ec158a78f356e", "patch": "@@ -1,3 +1,37 @@\n+2019-10-29  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tPR 88915\n+\t* tree-ssa-loop-niter.h (simplify_replace_tree): Change declaration.\n+\t* tree-ssa-loop-niter.c (simplify_replace_tree): Add context parameter\n+\tand make the valueize function pointer also take a void pointer.\n+\t* gcc/tree-ssa-sccvn.c (vn_valueize_wrapper): New function to wrap\n+\taround vn_valueize, to call it without a context.\n+\t(process_bb): Use vn_valueize_wrapper instead of vn_valueize.\n+\t* tree-vect-loop.c (_loop_vec_info): Initialize epilogue_vinfos.\n+\t(~_loop_vec_info): Release epilogue_vinfos.\n+\t(vect_analyze_loop_costing): Use knowledge of main VF to estimate\n+\tnumber of iterations of epilogue.\n+\t(vect_analyze_loop_2): Adapt to analyse main loop for all supported\n+\tvector sizes when vect-epilogues-nomask=1.  Also keep track of lowest\n+\tversioning threshold needed for main loop.\n+\t(vect_analyze_loop): Likewise.\n+\t(find_in_mapping): New helper function.\n+\t(update_epilogue_loop_vinfo): New function.\n+\t(vect_transform_loop): When vectorizing epilogues re-use analysis done\n+\ton main loop and call update_epilogue_loop_vinfo to update it.\n+\t* tree-vect-loop-manip.c (vect_update_inits_of_drs): No longer insert\n+\tstmts on loop preheader edge.\n+\t(vect_do_peeling): Enable skip-vectors when doing loop versioning if\n+\twe decided to vectorize epilogues.  Update epilogues NITERS and\n+\tconstruct ADVANCE to update epilogues data references where needed.\n+\t* tree-vectorizer.h (_loop_vec_info): Add epilogue_vinfos.\n+\t(vect_do_peeling, vect_update_inits_of_drs,\n+\t determine_peel_for_niter, vect_analyze_loop): Add or update\n+\tdeclarations.\n+\t* tree-vectorizer.c (try_vectorize_loop_1): Make sure to use already\n+\tcreated loop_vec_info's for epilogues when available.  Otherwise analyse\n+\tepilogue separately.\n+\n 2019-10-29  Richard Biener  <rguenther@suse.de>\n \n \t* doc/tree-ssa.texi (Immediate Uses): Fix FOR_EACH_IMM_USE_STMT"}, {"sha": "db666f019808850ed3a4aeef1a454a7ae2c65ef2", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=97c146036750e7cb3966d292572ec158a78f356e", "patch": "@@ -1935,7 +1935,7 @@ number_of_iterations_cond (class loop *loop,\n \n tree\n simplify_replace_tree (tree expr, tree old, tree new_tree,\n-\t\t       tree (*valueize) (tree))\n+\t\t       tree (*valueize) (tree, void*), void *context)\n {\n   unsigned i, n;\n   tree ret = NULL_TREE, e, se;\n@@ -1951,7 +1951,7 @@ simplify_replace_tree (tree expr, tree old, tree new_tree,\n     {\n       if (TREE_CODE (expr) == SSA_NAME)\n \t{\n-\t  new_tree = valueize (expr);\n+\t  new_tree = valueize (expr, context);\n \t  if (new_tree != expr)\n \t    return new_tree;\n \t}\n@@ -1967,7 +1967,7 @@ simplify_replace_tree (tree expr, tree old, tree new_tree,\n   for (i = 0; i < n; i++)\n     {\n       e = TREE_OPERAND (expr, i);\n-      se = simplify_replace_tree (e, old, new_tree, valueize);\n+      se = simplify_replace_tree (e, old, new_tree, valueize, context);\n       if (e == se)\n \tcontinue;\n "}, {"sha": "aec6225125ce42ab0e4dbc930fc1a93862e6e267", "filename": "gcc/tree-ssa-loop-niter.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=97c146036750e7cb3966d292572ec158a78f356e", "patch": "@@ -53,7 +53,9 @@ extern bool scev_probably_wraps_p (tree, tree, tree, gimple *,\n \t\t\t\t   class loop *, bool);\n extern void free_numbers_of_iterations_estimates (class loop *);\n extern void free_numbers_of_iterations_estimates (function *);\n-extern tree simplify_replace_tree (tree, tree, tree, tree (*)(tree) = NULL);\n+extern tree simplify_replace_tree (tree, tree,\n+\t\t\t\t   tree, tree (*)(tree, void *) = NULL,\n+\t\t\t\t   void * = NULL);\n extern void substitute_in_loop_info (class loop *, tree, tree);\n \n #endif /* GCC_TREE_SSA_LOOP_NITER_H */"}, {"sha": "7465bedb3496b829dbf07febb831dea2f1b8185d", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=97c146036750e7cb3966d292572ec158a78f356e", "patch": "@@ -309,6 +309,10 @@ static vn_tables_t valid_info;\n /* Valueization hook.  Valueize NAME if it is an SSA name, otherwise\n    just return it.  */\n tree (*vn_valueize) (tree);\n+tree vn_valueize_wrapper (tree t, void* context ATTRIBUTE_UNUSED)\n+{\n+  return vn_valueize (t);\n+}\n \n \n /* This represents the top of the VN lattice, which is the universal\n@@ -6412,7 +6416,7 @@ process_bb (rpo_elim &avail, basic_block bb,\n       if (bb->loop_father->nb_iterations)\n \tbb->loop_father->nb_iterations\n \t  = simplify_replace_tree (bb->loop_father->nb_iterations,\n-\t\t\t\t   NULL_TREE, NULL_TREE, vn_valueize);\n+\t\t\t\t   NULL_TREE, NULL_TREE, &vn_valueize_wrapper);\n     }\n \n   /* Value-number all defs in the basic-block.  */"}, {"sha": "dffb40ec9999a0363e53b1748af2fdcf270710ff", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 176, "deletions": 27, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=97c146036750e7cb3966d292572ec158a78f356e", "patch": "@@ -1726,7 +1726,7 @@ vect_update_init_of_dr (struct data_reference *dr, tree niters, tree_code code)\n    Apply vect_update_inits_of_dr to all accesses in LOOP_VINFO.\n    CODE and NITERS are as for vect_update_inits_of_dr.  */\n \n-static void\n+void\n vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,\n \t\t\t  tree_code code)\n {\n@@ -1736,21 +1736,12 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,\n \n   DUMP_VECT_SCOPE (\"vect_update_inits_of_dr\");\n \n-  /* Adjust niters to sizetype and insert stmts on loop preheader edge.  */\n+  /* Adjust niters to sizetype.  We used to insert the stmts on loop preheader\n+     here, but since we might use these niters to update the epilogues niters\n+     and data references we can't insert them here as this definition might not\n+     always dominate its uses.  */\n   if (!types_compatible_p (sizetype, TREE_TYPE (niters)))\n-    {\n-      gimple_seq seq;\n-      edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n-      tree var = create_tmp_var (sizetype, \"prolog_loop_adjusted_niters\");\n-\n-      niters = fold_convert (sizetype, niters);\n-      niters = force_gimple_operand (niters, &seq, false, var);\n-      if (seq)\n-\t{\n-\t  basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, seq);\n-\t  gcc_assert (!new_bb);\n-\t}\n-    }\n+    niters = fold_convert (sizetype, niters);\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n@@ -2393,7 +2384,22 @@ slpeel_update_phi_nodes_for_lcssa (class loop *epilog)\n \n    Note this function peels prolog and epilog only if it's necessary,\n    as well as guards.\n-   Returns created epilogue or NULL.\n+   This function returns the epilogue loop if a decision was made to vectorize\n+   it, otherwise NULL.\n+\n+   The analysis resulting in this epilogue loop's loop_vec_info was performed\n+   in the same vect_analyze_loop call as the main loop's.  At that time\n+   vect_analyze_loop constructs a list of accepted loop_vec_info's for lower\n+   vectorization factors than the main loop.  This list is stored in the main\n+   loop's loop_vec_info in the 'epilogue_vinfos' member.  Everytime we decide to\n+   vectorize the epilogue loop for a lower vectorization factor,  the\n+   loop_vec_info sitting at the top of the epilogue_vinfos list is removed,\n+   updated and linked to the epilogue loop.  This is later used to vectorize\n+   the epilogue.  The reason the loop_vec_info needs updating is that it was\n+   constructed based on the original main loop, and the epilogue loop is a\n+   copy of this loop, so all links pointing to statements in the original loop\n+   need updating.  Furthermore, these loop_vec_infos share the\n+   data_reference's records, which will also need to be updated.\n \n    TODO: Guard for prefer_scalar_loop should be emitted along with\n    versioning conditions if loop versioning is needed.  */\n@@ -2403,14 +2409,16 @@ class loop *\n vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t tree *niters_vector, tree *step_vector,\n \t\t tree *niters_vector_mult_vf_var, int th,\n-\t\t bool check_profitability, bool niters_no_overflow)\n+\t\t bool check_profitability, bool niters_no_overflow,\n+\t\t tree *advance, drs_init_vec &orig_drs_init)\n {\n   edge e, guard_e;\n   tree type = TREE_TYPE (niters), guard_cond;\n   basic_block guard_bb, guard_to;\n   profile_probability prob_prolog, prob_vector, prob_epilog;\n   int estimated_vf;\n   int prolog_peeling = 0;\n+  bool vect_epilogues = loop_vinfo->epilogue_vinfos.length () > 0;\n   /* We currently do not support prolog peeling if the target alignment is not\n      known at compile time.  'vect_gen_prolog_loop_niters' depends on the\n      target alignment being constant.  */\n@@ -2464,19 +2472,73 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   int bound_prolog = 0;\n   if (prolog_peeling)\n     niters_prolog = vect_gen_prolog_loop_niters (loop_vinfo, anchor,\n-\t\t\t\t\t\t &bound_prolog);\n+\t\t\t\t\t\t  &bound_prolog);\n   else\n     niters_prolog = build_int_cst (type, 0);\n \n+  loop_vec_info epilogue_vinfo = NULL;\n+  if (vect_epilogues)\n+    {\n+      epilogue_vinfo = loop_vinfo->epilogue_vinfos[0];\n+      loop_vinfo->epilogue_vinfos.ordered_remove (0);\n+    }\n+\n+  tree niters_vector_mult_vf = NULL_TREE;\n+  /* Saving NITERs before the loop, as this may be changed by prologue.  */\n+  tree before_loop_niters = LOOP_VINFO_NITERS (loop_vinfo);\n+  edge update_e = NULL, skip_e = NULL;\n+  unsigned int lowest_vf = constant_lower_bound (vf);\n+  /* If we know the number of scalar iterations for the main loop we should\n+     check whether after the main loop there are enough iterations left over\n+     for the epilogue.  */\n+  if (vect_epilogues\n+      && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && prolog_peeling >= 0\n+      && known_eq (vf, lowest_vf))\n+    {\n+      unsigned HOST_WIDE_INT eiters\n+\t= (LOOP_VINFO_INT_NITERS (loop_vinfo)\n+\t   - LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));\n+\n+      eiters -= prolog_peeling;\n+      eiters\n+\t= eiters % lowest_vf + LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo);\n+\n+      unsigned int ratio;\n+      while (!(constant_multiple_p (loop_vinfo->vector_size,\n+\t\t\t\t    epilogue_vinfo->vector_size, &ratio)\n+\t       && eiters >= lowest_vf / ratio))\n+\t{\n+\t  delete epilogue_vinfo;\n+\t  epilogue_vinfo = NULL;\n+\t  if (loop_vinfo->epilogue_vinfos.length () == 0)\n+\t    {\n+\t      vect_epilogues = false;\n+\t      break;\n+\t    }\n+\t  epilogue_vinfo = loop_vinfo->epilogue_vinfos[0];\n+\t  loop_vinfo->epilogue_vinfos.ordered_remove (0);\n+\t}\n+    }\n   /* Prolog loop may be skipped.  */\n   bool skip_prolog = (prolog_peeling != 0);\n-  /* Skip to epilog if scalar loop may be preferred.  It's only needed\n-     when we peel for epilog loop and when it hasn't been checked with\n-     loop versioning.  */\n+  /* Skip this loop to epilog when there are not enough iterations to enter this\n+     vectorized loop.  If true we should perform runtime checks on the NITERS\n+     to check whether we should skip the current vectorized loop.  If we know\n+     the number of scalar iterations we may choose to add a runtime check if\n+     this number \"maybe\" smaller than the number of iterations required\n+     when we know the number of scalar iterations may potentially\n+     be smaller than the number of iterations required to enter this loop, for\n+     this we use the upper bounds on the prolog and epilog peeling.  When we\n+     don't know the number of iterations and don't require versioning it is\n+     because we have asserted that there are enough scalar iterations to enter\n+     the main loop, so this skip is not necessary.  When we are versioning then\n+     we only add such a skip if we have chosen to vectorize the epilogue.  */\n   bool skip_vector = (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n \t\t      ? maybe_lt (LOOP_VINFO_INT_NITERS (loop_vinfo),\n \t\t\t\t  bound_prolog + bound_epilog)\n-\t\t      : !LOOP_REQUIRES_VERSIONING (loop_vinfo));\n+\t\t      : (!LOOP_REQUIRES_VERSIONING (loop_vinfo)\n+\t\t\t || vect_epilogues));\n   /* Epilog loop must be executed if the number of iterations for epilog\n      loop is known at compile time, otherwise we need to add a check at\n      the end of vector loop and skip to the end of epilog loop.  */\n@@ -2506,6 +2568,12 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \n   dump_user_location_t loop_loc = find_loop_location (loop);\n   class loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n+  if (vect_epilogues)\n+    /* Make sure to set the epilogue's epilogue scalar loop, such that we can\n+       use the original scalar loop as remaining epilogue if necessary.  */\n+    LOOP_VINFO_SCALAR_LOOP (epilogue_vinfo)\n+      = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n+\n   if (prolog_peeling)\n     {\n       e = loop_preheader_edge (loop);\n@@ -2552,6 +2620,15 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  scale_bbs_frequencies (&bb_after_prolog, 1, prob_prolog);\n \t  scale_loop_profile (prolog, prob_prolog, bound_prolog);\n \t}\n+\n+      /* Save original inits for each data_reference before advancing them with\n+\t NITERS_PROLOG.  */\n+      unsigned int i;\n+      struct data_reference *dr;\n+      vec<data_reference_p> datarefs = loop_vinfo->shared->datarefs;\n+      FOR_EACH_VEC_ELT (datarefs, i, dr)\n+\torig_drs_init.safe_push (std::make_pair (dr, DR_OFFSET (dr)));\n+\n       /* Update init address of DRs.  */\n       vect_update_inits_of_drs (loop_vinfo, niters_prolog, PLUS_EXPR);\n       /* Update niters for vector loop.  */\n@@ -2586,8 +2663,15 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t\t   \"loop can't be duplicated to exit edge.\\n\");\n \t  gcc_unreachable ();\n \t}\n-      /* Peel epilog and put it on exit edge of loop.  */\n-      epilog = slpeel_tree_duplicate_loop_to_edge_cfg (loop, scalar_loop, e);\n+      /* Peel epilog and put it on exit edge of loop.  If we are vectorizing\n+\t said epilog then we should use a copy of the main loop as a starting\n+\t point.  This loop may have already had some preliminary transformations\n+\t to allow for more optimal vectorization, for example if-conversion.\n+\t If we are not vectorizing the epilog then we should use the scalar loop\n+\t as the transformations mentioned above make less or no sense when not\n+\t vectorizing.  */\n+      epilog = vect_epilogues ? get_loop_copy (loop) : scalar_loop;\n+      epilog = slpeel_tree_duplicate_loop_to_edge_cfg (loop, epilog, e);\n       if (!epilog)\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, loop_loc,\n@@ -2616,6 +2700,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t\t\t\t   guard_to, guard_bb,\n \t\t\t\t\t   prob_vector.invert (),\n \t\t\t\t\t   irred_flag);\n+\t  skip_e = guard_e;\n \t  e = EDGE_PRED (guard_to, 0);\n \t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n \t  slpeel_update_phi_nodes_for_guard1 (first_loop, epilog, guard_e, e);\n@@ -2637,7 +2722,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t}\n \n       basic_block bb_before_epilog = loop_preheader_edge (epilog)->src;\n-      tree niters_vector_mult_vf;\n       /* If loop is peeled for non-zero constant times, now niters refers to\n \t orig_niters - prolog_peeling, it won't overflow even the orig_niters\n \t overflows.  */\n@@ -2660,7 +2744,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       /* Update IVs of original loop as if they were advanced by\n \t niters_vector_mult_vf steps.  */\n       gcc_checking_assert (vect_can_advance_ivs_p (loop_vinfo));\n-      edge update_e = skip_vector ? e : loop_preheader_edge (epilog);\n+      update_e = skip_vector ? e : loop_preheader_edge (epilog);\n       vect_update_ivs_after_vectorizer (loop_vinfo, niters_vector_mult_vf,\n \t\t\t\t\tupdate_e);\n \n@@ -2701,10 +2785,75 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       adjust_vec_debug_stmts ();\n       scev_reset ();\n     }\n+\n+  if (vect_epilogues)\n+    {\n+      epilog->aux = epilogue_vinfo;\n+      LOOP_VINFO_LOOP (epilogue_vinfo) = epilog;\n+\n+      loop_constraint_clear (epilog, LOOP_C_INFINITE);\n+\n+      /* We now must calculate the number of NITERS performed by the previous\n+\t loop and EPILOGUE_NITERS to be performed by the epilogue.  */\n+      tree niters = fold_build2 (PLUS_EXPR, TREE_TYPE (niters_vector_mult_vf),\n+\t\t\t\t niters_prolog, niters_vector_mult_vf);\n+\n+      /* If skip_vector we may skip the previous loop, we insert a phi-node to\n+\t determine whether we are coming from the previous vectorized loop\n+\t using the update_e edge or the skip_vector basic block using the\n+\t skip_e edge.  */\n+      if (skip_vector)\n+\t{\n+\t  gcc_assert (update_e != NULL && skip_e != NULL);\n+\t  gphi *new_phi = create_phi_node (make_ssa_name (TREE_TYPE (niters)),\n+\t\t\t\t\t   update_e->dest);\n+\t  tree new_ssa = make_ssa_name (TREE_TYPE (niters));\n+\t  gimple *stmt = gimple_build_assign (new_ssa, niters);\n+\t  gimple_stmt_iterator gsi;\n+\t  if (TREE_CODE (niters_vector_mult_vf) == SSA_NAME\n+\t      && SSA_NAME_DEF_STMT (niters_vector_mult_vf)->bb != NULL)\n+\t    {\n+\t      gsi = gsi_for_stmt (SSA_NAME_DEF_STMT (niters_vector_mult_vf));\n+\t      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+\t    }\n+\t  else\n+\t    {\n+\t      gsi = gsi_last_bb (update_e->src);\n+\t      gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n+\t    }\n+\n+\t  niters = new_ssa;\n+\t  add_phi_arg (new_phi, niters, update_e, UNKNOWN_LOCATION);\n+\t  add_phi_arg (new_phi, build_zero_cst (TREE_TYPE (niters)), skip_e,\n+\t\t       UNKNOWN_LOCATION);\n+\t  niters = PHI_RESULT (new_phi);\n+\t}\n+\n+      /* Subtract the number of iterations performed by the vectorized loop\n+\t from the number of total iterations.  */\n+      tree epilogue_niters = fold_build2 (MINUS_EXPR, TREE_TYPE (niters),\n+\t\t\t\t\t  before_loop_niters,\n+\t\t\t\t\t  niters);\n+\n+      LOOP_VINFO_NITERS (epilogue_vinfo) = epilogue_niters;\n+      LOOP_VINFO_NITERSM1 (epilogue_vinfo)\n+\t= fold_build2 (MINUS_EXPR, TREE_TYPE (epilogue_niters),\n+\t\t       epilogue_niters,\n+\t\t       build_one_cst (TREE_TYPE (epilogue_niters)));\n+\n+      /* Set ADVANCE to the number of iterations performed by the previous\n+\t loop and its prologue.  */\n+      *advance = niters;\n+\n+      /* Redo the peeling for niter analysis as the NITERs and alignment\n+\t may have been updated to take the main loop into account.  */\n+      determine_peel_for_niter (epilogue_vinfo);\n+    }\n+\n   adjust_vec.release ();\n   free_original_copy_tables ();\n \n-  return epilog;\n+  return vect_epilogues ? epilog : NULL;\n }\n \n /* Function vect_create_cond_for_niters_checks."}, {"sha": "9b7d2485b7cae81578c6a7d33304dc48134cc850", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 272, "deletions": 60, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=97c146036750e7cb3966d292572ec158a78f356e", "patch": "@@ -888,6 +888,8 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n \t    }\n \t}\n     }\n+\n+  epilogue_vinfos.create (6);\n }\n \n /* Free all levels of MASKS.  */\n@@ -912,6 +914,7 @@ _loop_vec_info::~_loop_vec_info ()\n   release_vec_loop_masks (&masks);\n   delete ivexpr_map;\n   delete scan_map;\n+  epilogue_vinfos.release ();\n \n   loop->aux = NULL;\n }\n@@ -1685,9 +1688,20 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n       return 0;\n     }\n \n-  HOST_WIDE_INT estimated_niter = estimated_stmt_executions_int (loop);\n-  if (estimated_niter == -1)\n-    estimated_niter = likely_max_stmt_executions_int (loop);\n+  HOST_WIDE_INT estimated_niter;\n+\n+  /* If we are vectorizing an epilogue then we know the maximum number of\n+     scalar iterations it will cover is at least one lower than the\n+     vectorization factor of the main loop.  */\n+  if (LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n+    estimated_niter\n+      = vect_vf_for_cost (LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo)) - 1;\n+  else\n+    {\n+      estimated_niter = estimated_stmt_executions_int (loop);\n+      if (estimated_niter == -1)\n+\testimated_niter = likely_max_stmt_executions_int (loop);\n+    }\n   if (estimated_niter != -1\n       && ((unsigned HOST_WIDE_INT) estimated_niter\n \t  < MAX (th, (unsigned) min_profitable_estimate)))\n@@ -1874,6 +1888,15 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   int res;\n   unsigned int max_vf = MAX_VECTORIZATION_FACTOR;\n   poly_uint64 min_vf = 2;\n+  loop_vec_info orig_loop_vinfo = NULL;\n+\n+  /* If we are dealing with an epilogue then orig_loop_vinfo points to the\n+     loop_vec_info of the first vectorized loop.  */\n+  if (LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n+    orig_loop_vinfo = LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo);\n+  else\n+    orig_loop_vinfo = loop_vinfo;\n+  gcc_assert (orig_loop_vinfo);\n \n   /* The first group of checks is independent of the vector size.  */\n   fatal = true;\n@@ -2153,8 +2176,18 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   /* During peeling, we need to check if number of loop iterations is\n      enough for both peeled prolog loop and vector loop.  This check\n      can be merged along with threshold check of loop versioning, so\n-     increase threshold for this case if necessary.  */\n-  if (LOOP_REQUIRES_VERSIONING (loop_vinfo))\n+     increase threshold for this case if necessary.\n+\n+     If we are analyzing an epilogue we still want to check what its\n+     versioning threshold would be.  If we decide to vectorize the epilogues we\n+     will want to use the lowest versioning threshold of all epilogues and main\n+     loop.  This will enable us to enter a vectorized epilogue even when\n+     versioning the loop.  We can't simply check whether the epilogue requires\n+     versioning though since we may have skipped some versioning checks when\n+     analyzing the epilogue.  For instance, checks for alias versioning will be\n+     skipped when dealing with epilogues as we assume we already checked them\n+     for the main loop.  So instead we always check the 'orig_loop_vinfo'.  */\n+  if (LOOP_REQUIRES_VERSIONING (orig_loop_vinfo))\n     {\n       poly_uint64 niters_th = 0;\n       unsigned int th = LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo);\n@@ -2347,6 +2380,14 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n   poly_uint64 autodetected_vector_size = 0;\n   opt_loop_vec_info first_loop_vinfo = opt_loop_vec_info::success (NULL);\n   poly_uint64 next_vector_size = 0;\n+  poly_uint64 lowest_th = 0;\n+  unsigned vectorized_loops = 0;\n+\n+  /* Only vectorize epilogues if PARAM_VECT_EPILOGUES_NOMASK is enabled, this\n+     is not a simd loop and it is the most inner loop.  */\n+  bool vect_epilogues\n+    = !loop->simdlen && loop->inner == NULL\n+      && PARAM_VALUE (PARAM_VECT_EPILOGUES_NOMASK);\n   while (1)\n     {\n       /* Check the CFG characteristics of the loop (nesting, entry/exit).  */\n@@ -2366,6 +2407,8 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n \n       if (orig_loop_vinfo)\n \tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = orig_loop_vinfo;\n+      else if (vect_epilogues && first_loop_vinfo)\n+\tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = first_loop_vinfo;\n \n       opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts);\n       if (next_size == 0)\n@@ -2374,18 +2417,43 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n       if (res)\n \t{\n \t  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n+\t  vectorized_loops++;\n \n-\t  if (loop->simdlen\n-\t      && maybe_ne (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n-\t\t\t   (unsigned HOST_WIDE_INT) loop->simdlen))\n+\t  if ((loop->simdlen\n+\t       && maybe_ne (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n+\t\t\t    (unsigned HOST_WIDE_INT) loop->simdlen))\n+\t      || vect_epilogues)\n \t    {\n \t      if (first_loop_vinfo == NULL)\n \t\t{\n \t\t  first_loop_vinfo = loop_vinfo;\n+\t\t  lowest_th\n+\t\t    = LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo);\n \t\t  loop->aux = NULL;\n \t\t}\n \t      else\n-\t\tdelete loop_vinfo;\n+\t\t{\n+\t\t  /* Keep track of vector sizes that we know we can vectorize\n+\t\t     the epilogue with.  Only vectorize first epilogue.  */\n+\t\t  if (vect_epilogues\n+\t\t      && first_loop_vinfo->epilogue_vinfos.is_empty ())\n+\t\t    {\n+\t\t      loop->aux = NULL;\n+\t\t      first_loop_vinfo->epilogue_vinfos.reserve (1);\n+\t\t      first_loop_vinfo->epilogue_vinfos.quick_push (loop_vinfo);\n+\t\t      LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = first_loop_vinfo;\n+\t\t      poly_uint64 th\n+\t\t\t= LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo);\n+\t\t      gcc_assert (!LOOP_REQUIRES_VERSIONING (loop_vinfo)\n+\t\t\t\t  || maybe_ne (lowest_th, 0U));\n+\t\t      /* Keep track of the known smallest versioning\n+\t\t\t threshold.  */\n+\t\t      if (ordered_p (lowest_th, th))\n+\t\t\tlowest_th = ordered_min (lowest_th, th);\n+\t\t    }\n+\t\t  else\n+\t\t    delete loop_vinfo;\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -2419,6 +2487,8 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n \t\t  dump_dec (MSG_NOTE, first_loop_vinfo->vector_size);\n \t\t  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n+\t      LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo) = lowest_th;\n+\n \t      return first_loop_vinfo;\n \t    }\n \t  else\n@@ -7932,6 +8002,186 @@ vect_transform_loop_stmt (loop_vec_info loop_vinfo, stmt_vec_info stmt_info,\n     *seen_store = stmt_info;\n }\n \n+/* Helper function to pass to simplify_replace_tree to enable replacing tree's\n+   in the hash_map with its corresponding values.  */\n+\n+static tree\n+find_in_mapping (tree t, void *context)\n+{\n+  hash_map<tree,tree>* mapping = (hash_map<tree, tree>*) context;\n+\n+  tree *value = mapping->get (t);\n+  return value ? *value : t;\n+}\n+\n+/* Update EPILOGUE's loop_vec_info.  EPILOGUE was constructed as a copy of the\n+   original loop that has now been vectorized.\n+\n+   The inits of the data_references need to be advanced with the number of\n+   iterations of the main loop.  This has been computed in vect_do_peeling and\n+   is stored in parameter ADVANCE.  We first restore the data_references\n+   initial offset with the values recored in ORIG_DRS_INIT.\n+\n+   Since the loop_vec_info of this EPILOGUE was constructed for the original\n+   loop, its stmt_vec_infos all point to the original statements.  These need\n+   to be updated to point to their corresponding copies as well as the SSA_NAMES\n+   in their PATTERN_DEF_SEQs and RELATED_STMTs.\n+\n+   The data_reference's connections also need to be updated.  Their\n+   corresponding dr_vec_info need to be reconnected to the EPILOGUE's\n+   stmt_vec_infos, their statements need to point to their corresponding copy,\n+   if they are gather loads or scatter stores then their reference needs to be\n+   updated to point to its corresponding copy and finally we set\n+   'base_misaligned' to false as we have already peeled for alignment in the\n+   prologue of the main loop.  */\n+\n+static void\n+update_epilogue_loop_vinfo (class loop *epilogue, tree advance,\n+\t\t\t    drs_init_vec &orig_drs_init)\n+{\n+  loop_vec_info epilogue_vinfo = loop_vec_info_for_loop (epilogue);\n+  auto_vec<gimple *> stmt_worklist;\n+  hash_map<tree,tree> mapping;\n+  gimple *orig_stmt, *new_stmt;\n+  gimple_stmt_iterator epilogue_gsi;\n+  gphi_iterator epilogue_phi_gsi;\n+  stmt_vec_info stmt_vinfo = NULL, related_vinfo;\n+  basic_block *epilogue_bbs = get_loop_body (epilogue);\n+\n+  LOOP_VINFO_BBS (epilogue_vinfo) = epilogue_bbs;\n+\n+  /* Restore original data_reference's offset, before the previous loop and its\n+     prologue.  */\n+  std::pair<data_reference*, tree> *dr_init;\n+  unsigned i;\n+  for (i = 0; orig_drs_init.iterate (i, &dr_init); i++)\n+    DR_OFFSET (dr_init->first) = dr_init->second;\n+\n+  /* Advance data_reference's with the number of iterations of the previous\n+     loop and its prologue.  */\n+  vect_update_inits_of_drs (epilogue_vinfo, advance, PLUS_EXPR);\n+\n+\n+  /* The EPILOGUE loop is a copy of the original loop so they share the same\n+     gimple UIDs.  In this loop we update the loop_vec_info of the EPILOGUE to\n+     point to the copied statements.  We also create a mapping of all LHS' in\n+     the original loop and all the LHS' in the EPILOGUE and create worklists to\n+     update teh STMT_VINFO_PATTERN_DEF_SEQs and STMT_VINFO_RELATED_STMTs.  */\n+  for (unsigned i = 0; i < epilogue->num_nodes; ++i)\n+    {\n+      for (epilogue_phi_gsi = gsi_start_phis (epilogue_bbs[i]);\n+\t   !gsi_end_p (epilogue_phi_gsi); gsi_next (&epilogue_phi_gsi))\n+\t{\n+\t  new_stmt = epilogue_phi_gsi.phi ();\n+\n+\t  gcc_assert (gimple_uid (new_stmt) > 0);\n+\t  stmt_vinfo\n+\t    = epilogue_vinfo->stmt_vec_infos[gimple_uid (new_stmt) - 1];\n+\n+\t  orig_stmt = STMT_VINFO_STMT (stmt_vinfo);\n+\t  STMT_VINFO_STMT (stmt_vinfo) = new_stmt;\n+\n+\t  mapping.put (gimple_phi_result (orig_stmt),\n+\t\t       gimple_phi_result (new_stmt));\n+\t  /* PHI nodes can not have patterns or related statements.  */\n+\t  gcc_assert (STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) == NULL\n+\t\t      && STMT_VINFO_RELATED_STMT (stmt_vinfo) == NULL);\n+\t}\n+\n+      for (epilogue_gsi = gsi_start_bb (epilogue_bbs[i]);\n+\t   !gsi_end_p (epilogue_gsi); gsi_next (&epilogue_gsi))\n+\t{\n+\t  new_stmt = gsi_stmt (epilogue_gsi);\n+\n+\t  gcc_assert (gimple_uid (new_stmt) > 0);\n+\t  stmt_vinfo\n+\t    = epilogue_vinfo->stmt_vec_infos[gimple_uid (new_stmt) - 1];\n+\n+\t  orig_stmt = STMT_VINFO_STMT (stmt_vinfo);\n+\t  STMT_VINFO_STMT (stmt_vinfo) = new_stmt;\n+\n+\t  if (tree old_lhs = gimple_get_lhs (orig_stmt))\n+\t    mapping.put (old_lhs, gimple_get_lhs (new_stmt));\n+\n+\t  if (STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo))\n+\t    {\n+\t      gimple_seq seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo);\n+\t      for (gimple_stmt_iterator gsi = gsi_start (seq);\n+\t\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t\tstmt_worklist.safe_push (gsi_stmt (gsi));\n+\t    }\n+\n+\t  related_vinfo = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n+\t  if (related_vinfo != NULL && related_vinfo != stmt_vinfo)\n+\t    {\n+\t      gimple *stmt = STMT_VINFO_STMT (related_vinfo);\n+\t      stmt_worklist.safe_push (stmt);\n+\t      /* Set BB such that the assert in\n+\t\t'get_initial_def_for_reduction' is able to determine that\n+\t\tthe BB of the related stmt is inside this loop.  */\n+\t      gimple_set_bb (stmt,\n+\t\t\t     gimple_bb (new_stmt));\n+\t      related_vinfo = STMT_VINFO_RELATED_STMT (related_vinfo);\n+\t      gcc_assert (related_vinfo == NULL\n+\t\t\t  || related_vinfo == stmt_vinfo);\n+\t    }\n+\t}\n+    }\n+\n+  /* The PATTERN_DEF_SEQs and RELATED_STMTs in the epilogue were constructed\n+     using the original main loop and thus need to be updated to refer to the\n+     cloned variables used in the epilogue.  */\n+  for (unsigned i = 0; i < stmt_worklist.length (); ++i)\n+    {\n+      gimple *stmt = stmt_worklist[i];\n+      tree *new_op;\n+\n+      for (unsigned j = 1; j < gimple_num_ops (stmt); ++j)\n+\t{\n+\t  tree op = gimple_op (stmt, j);\n+\t  if ((new_op = mapping.get(op)))\n+\t    gimple_set_op (stmt, j, *new_op);\n+\t  else\n+\t    {\n+\t      op = simplify_replace_tree (op, NULL_TREE, NULL_TREE,\n+\t\t\t\t     &find_in_mapping, &mapping);\n+\t      gimple_set_op (stmt, j, op);\n+\t    }\n+\t}\n+    }\n+\n+  struct data_reference *dr;\n+  vec<data_reference_p> datarefs = epilogue_vinfo->shared->datarefs;\n+  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+    {\n+      orig_stmt = DR_STMT (dr);\n+      gcc_assert (gimple_uid (orig_stmt) > 0);\n+      stmt_vinfo = epilogue_vinfo->stmt_vec_infos[gimple_uid (orig_stmt) - 1];\n+      /* Data references for gather loads and scatter stores do not use the\n+\t updated offset we set using ADVANCE.  Instead we have to make sure the\n+\t reference in the data references point to the corresponding copy of\n+\t the original in the epilogue.  */\n+      if (STMT_VINFO_GATHER_SCATTER_P (stmt_vinfo))\n+\t{\n+\t  DR_REF (dr)\n+\t    = simplify_replace_tree (DR_REF (dr), NULL_TREE, NULL_TREE,\n+\t\t\t\t     &find_in_mapping, &mapping);\n+\t  DR_BASE_ADDRESS (dr)\n+\t    = simplify_replace_tree (DR_BASE_ADDRESS (dr), NULL_TREE, NULL_TREE,\n+\t\t\t\t     &find_in_mapping, &mapping);\n+\t}\n+      DR_STMT (dr) = STMT_VINFO_STMT (stmt_vinfo);\n+      stmt_vinfo->dr_aux.stmt = stmt_vinfo;\n+      /* The vector size of the epilogue is smaller than that of the main loop\n+\t so the alignment is either the same or lower. This means the dr will\n+\t thus by definition be aligned.  */\n+      STMT_VINFO_DR_INFO (stmt_vinfo)->base_misaligned = false;\n+    }\n+\n+  epilogue_vinfo->shared->datarefs_copy.release ();\n+  epilogue_vinfo->shared->save_datarefs ();\n+}\n+\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -7969,11 +8219,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   if (th >= vect_vf_for_cost (loop_vinfo)\n       && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"Profitability threshold is %d loop iterations.\\n\",\n-                         th);\n-      check_profitability = true;\n+\tif (dump_enabled_p ())\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"Profitability threshold is %d loop iterations.\\n\",\n+\t\t\t   th);\n+\tcheck_profitability = true;\n     }\n \n   /* Make sure there exists a single-predecessor exit bb.  Do this before \n@@ -8017,9 +8267,14 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = niters;\n   tree nitersm1 = unshare_expr (LOOP_VINFO_NITERSM1 (loop_vinfo));\n   bool niters_no_overflow = loop_niters_no_overflow (loop_vinfo);\n+  tree advance;\n+  drs_init_vec orig_drs_init;\n+\n   epilogue = vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector,\n \t\t\t      &step_vector, &niters_vector_mult_vf, th,\n-\t\t\t      check_profitability, niters_no_overflow);\n+\t\t\t      check_profitability, niters_no_overflow,\n+\t\t\t      &advance, orig_drs_init);\n+\n   if (LOOP_VINFO_SCALAR_LOOP (loop_vinfo)\n       && LOOP_VINFO_SCALAR_LOOP_SCALING (loop_vinfo).initialized_p ())\n     scale_loop_frequencies (LOOP_VINFO_SCALAR_LOOP (loop_vinfo),\n@@ -8278,57 +8533,14 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      since vectorized loop can have loop-carried dependencies.  */\n   loop->safelen = 0;\n \n-  /* Don't vectorize epilogue for epilogue.  */\n-  if (LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n-    epilogue = NULL;\n-\n-  if (!PARAM_VALUE (PARAM_VECT_EPILOGUES_NOMASK))\n-    epilogue = NULL;\n-\n   if (epilogue)\n     {\n-      auto_vector_sizes vector_sizes;\n-      targetm.vectorize.autovectorize_vector_sizes (&vector_sizes, false);\n-      unsigned int next_size = 0;\n-\n-      /* Note LOOP_VINFO_NITERS_KNOWN_P and LOOP_VINFO_INT_NITERS work\n-         on niters already ajusted for the iterations of the prologue.  */\n-      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t  && known_eq (vf, lowest_vf))\n-\t{\n-\t  unsigned HOST_WIDE_INT eiters\n-\t    = (LOOP_VINFO_INT_NITERS (loop_vinfo)\n-\t       - LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));\n-\t  eiters\n-\t    = eiters % lowest_vf + LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo);\n-\t  epilogue->nb_iterations_upper_bound = eiters - 1;\n-\t  epilogue->any_upper_bound = true;\n-\n-\t  unsigned int ratio;\n-\t  while (next_size < vector_sizes.length ()\n-\t\t && !(constant_multiple_p (loop_vinfo->vector_size,\n-\t\t\t\t\t   vector_sizes[next_size], &ratio)\n-\t\t      && eiters >= lowest_vf / ratio))\n-\t    next_size += 1;\n-\t}\n-      else\n-\twhile (next_size < vector_sizes.length ()\n-\t       && maybe_lt (loop_vinfo->vector_size, vector_sizes[next_size]))\n-\t  next_size += 1;\n+      update_epilogue_loop_vinfo (epilogue, advance, orig_drs_init);\n \n-      if (next_size == vector_sizes.length ())\n-\tepilogue = NULL;\n-    }\n-\n-  if (epilogue)\n-    {\n+      epilogue->simduid = loop->simduid;\n       epilogue->force_vectorize = loop->force_vectorize;\n       epilogue->safelen = loop->safelen;\n       epilogue->dont_vectorize = false;\n-\n-      /* We may need to if-convert epilogue to vectorize it.  */\n-      if (LOOP_VINFO_SCALAR_LOOP (loop_vinfo))\n-\ttree_if_conversion (epilogue);\n     }\n \n   return epilogue;"}, {"sha": "8e02647c7bad6ce4a92a225a4d37f82439f771ae", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=97c146036750e7cb3966d292572ec158a78f356e", "patch": "@@ -874,17 +874,25 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n   vec_info_shared shared;\n   auto_purge_vect_location sentinel;\n   vect_location = find_loop_location (loop);\n+\n   if (LOCATION_LOCUS (vect_location.get_location_t ()) != UNKNOWN_LOCATION\n       && dump_enabled_p ())\n     dump_printf (MSG_NOTE | MSG_PRIORITY_INTERNALS,\n \t\t \"\\nAnalyzing loop at %s:%d\\n\",\n \t\t LOCATION_FILE (vect_location.get_location_t ()),\n \t\t LOCATION_LINE (vect_location.get_location_t ()));\n \n-  /* Try to analyze the loop, retaining an opt_problem if dump_enabled_p.  */\n-  opt_loop_vec_info loop_vinfo\n-    = vect_analyze_loop (loop, orig_loop_vinfo, &shared);\n-  loop->aux = loop_vinfo;\n+  opt_loop_vec_info loop_vinfo = opt_loop_vec_info::success (NULL);\n+  /* In the case of epilogue vectorization the loop already has its\n+     loop_vec_info set, we do not require to analyze the loop in this case.  */\n+  if (loop_vec_info vinfo = loop_vec_info_for_loop (loop))\n+    loop_vinfo = opt_loop_vec_info::success (vinfo);\n+  else\n+    {\n+      /* Try to analyze the loop, retaining an opt_problem if dump_enabled_p.  */\n+      loop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo, &shared);\n+      loop->aux = loop_vinfo;\n+    }\n \n   if (!loop_vinfo)\n     if (dump_enabled_p ())\n@@ -1012,8 +1020,13 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \n   /* Epilogue of vectorized loop must be vectorized too.  */\n   if (new_loop)\n-    ret |= try_vectorize_loop_1 (simduid_to_vf_htab, num_vectorized_loops,\n-\t\t\t\t new_loop, loop_vinfo, NULL, NULL);\n+    {\n+      /* Don't include vectorized epilogues in the \"vectorized loops\" count.\n+       */\n+      unsigned dont_count = *num_vectorized_loops;\n+      ret |= try_vectorize_loop_1 (simduid_to_vf_htab, &dont_count,\n+\t\t\t\t   new_loop, loop_vinfo, NULL, NULL);\n+    }\n \n   return ret;\n }"}, {"sha": "71b5f380e2c91a7a551f6e26920bb17809abedf0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c146036750e7cb3966d292572ec158a78f356e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=97c146036750e7cb3966d292572ec158a78f356e", "patch": "@@ -26,6 +26,7 @@ typedef class _stmt_vec_info *stmt_vec_info;\n #include \"tree-data-ref.h\"\n #include \"tree-hash-traits.h\"\n #include \"target.h\"\n+#include <utility>\n \n /* Used for naming of new temporaries.  */\n enum vect_var_kind {\n@@ -456,6 +457,8 @@ struct rgroup_masks {\n \n typedef auto_vec<rgroup_masks> vec_loop_masks;\n \n+typedef auto_vec<std::pair<data_reference*, tree> > drs_init_vec;\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n@@ -639,6 +642,10 @@ typedef class _loop_vec_info : public vec_info {\n      this points to the original vectorized loop.  Otherwise NULL.  */\n   _loop_vec_info *orig_loop_info;\n \n+  /* Used to store loop_vec_infos of epilogues of this loop during\n+     analysis.  */\n+  vec<_loop_vec_info *> epilogue_vinfos;\n+\n } *loop_vec_info;\n \n /* Access Functions.  */\n@@ -1589,10 +1596,12 @@ class loop *slpeel_tree_duplicate_loop_to_edge_cfg (class loop *,\n \t\t\t\t\t\t     class loop *, edge);\n class loop *vect_loop_versioning (loop_vec_info);\n extern class loop *vect_do_peeling (loop_vec_info, tree, tree,\n-\t\t\t\t     tree *, tree *, tree *, int, bool, bool);\n+\t\t\t\t    tree *, tree *, tree *, int, bool, bool,\n+\t\t\t\t    tree *, drs_init_vec &);\n extern void vect_prepare_for_masked_peels (loop_vec_info);\n extern dump_user_location_t find_loop_location (class loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n+extern void vect_update_inits_of_drs (loop_vec_info, tree, tree_code);\n \n /* In tree-vect-stmts.c.  */\n extern tree get_vectype_for_scalar_type (vec_info *, tree);\n@@ -1700,6 +1709,8 @@ extern tree vect_create_addr_base_for_vector_ref (stmt_vec_info, gimple_seq *,\n \n /* In tree-vect-loop.c.  */\n extern widest_int vect_iv_limit_for_full_masking (loop_vec_info loop_vinfo);\n+/* Used in tree-vect-loop-manip.c */\n+extern void determine_peel_for_niter (loop_vec_info);\n /* Used in gimple-loop-interchange.c and tree-parloops.c.  */\n extern bool check_reduction_path (dump_user_location_t, loop_p, gphi *, tree,\n \t\t\t\t  enum tree_code);"}]}