{"sha": "452811eb53e9c0457f99f4f23a4ca10354c088e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUyODExZWI1M2U5YzA0NTdmOTlmNGYyM2E0Y2ExMDM1NGMwODhlMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-11-07T23:09:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-11-07T23:09:21Z"}, "message": "C++ cleanups before C++17 noexcept in types.\n\n\t* call.c (standard_conversion): Reorganize pointer conversions.\n\t* pt.c (convert_nontype_argument_function): Convert to ref here.\n\t(convert_nontype_argument): Not here.\n\t(convert_template_argument): Add original type to error message.\n\t(RECUR_AND_CHECK_FAILURE): Remove trailing semicolon.\n\t(unify): Compare function-qualifiers.\n\t* typeck.c (same_type_ignoring_top_level_qualifiers_p): Use\n\tcp_build_qualified_type rather than TYPE_MAIN_VARIANT.\n\nFrom-SVN: r241943", "tree": {"sha": "ef83934093b77ac1811c1e96ea216bb5a580699a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef83934093b77ac1811c1e96ea216bb5a580699a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/452811eb53e9c0457f99f4f23a4ca10354c088e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/452811eb53e9c0457f99f4f23a4ca10354c088e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/452811eb53e9c0457f99f4f23a4ca10354c088e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/452811eb53e9c0457f99f4f23a4ca10354c088e1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ab71abd2650621b8de283e326fda9cad2669787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab71abd2650621b8de283e326fda9cad2669787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab71abd2650621b8de283e326fda9cad2669787"}], "stats": {"total": 111, "additions": 70, "deletions": 41}, "files": [{"sha": "a65ddec3343b5d6c03347c13710d6f6e4d1f70a6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=452811eb53e9c0457f99f4f23a4ca10354c088e1", "patch": "@@ -1,5 +1,14 @@\n 2016-11-07  Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (standard_conversion): Reorganize pointer conversions.\n+\t* pt.c (convert_nontype_argument_function): Convert to ref here.\n+\t(convert_nontype_argument): Not here.\n+\t(convert_template_argument): Add original type to error message.\n+\t(RECUR_AND_CHECK_FAILURE): Remove trailing semicolon.\n+\t(unify): Compare function-qualifiers.\n+\t* typeck.c (same_type_ignoring_top_level_qualifiers_p): Use\n+\tcp_build_qualified_type rather than TYPE_MAIN_VARIANT.\n+\n \t* pt.c (push_tinst_level_loc): Add template instantiations to the\n \tannounce_function stream.\n "}, {"sha": "0466cd13e3824f3f31308c087bc08ddcf29270db", "filename": "gcc/cp/call.c", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=452811eb53e9c0457f99f4f23a4ca10354c088e1", "patch": "@@ -1212,19 +1212,40 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       tree to_pointee;\n       tree from_pointee;\n \n+      if (tcode == POINTER_TYPE)\n+\t{\n+\t  to_pointee = TREE_TYPE (to);\n+\t  from_pointee = TREE_TYPE (from);\n+\n+\t  /* Since this is the target of a pointer, it can't have function\n+\t     qualifiers, so any TYPE_QUALS must be for attributes const or\n+\t     noreturn.  Strip them.  */\n+\t  if (TREE_CODE (to_pointee) == FUNCTION_TYPE\n+\t      && TYPE_QUALS (to_pointee))\n+\t    to_pointee = build_qualified_type (to_pointee, TYPE_UNQUALIFIED);\n+\t  if (TREE_CODE (from_pointee) == FUNCTION_TYPE\n+\t      && TYPE_QUALS (from_pointee))\n+\t    from_pointee = build_qualified_type (from_pointee, TYPE_UNQUALIFIED);\n+\t}\n+      else\n+\t{\n+\t  to_pointee = TYPE_PTRMEM_POINTED_TO_TYPE (to);\n+\t  from_pointee = TYPE_PTRMEM_POINTED_TO_TYPE (from);\n+\t}\n+\n       if (tcode == POINTER_TYPE\n-\t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (from),\n-\t\t\t\t\t\t\tTREE_TYPE (to)))\n+\t  && same_type_ignoring_top_level_qualifiers_p (from_pointee,\n+\t\t\t\t\t\t\tto_pointee))\n \t;\n-      else if (VOID_TYPE_P (TREE_TYPE (to))\n+      else if (VOID_TYPE_P (to_pointee)\n \t       && !TYPE_PTRDATAMEM_P (from)\n-\t       && TREE_CODE (TREE_TYPE (from)) != FUNCTION_TYPE)\n+\t       && TREE_CODE (from_pointee) != FUNCTION_TYPE)\n \t{\n \t  tree nfrom = TREE_TYPE (from);\n \t  /* Don't try to apply restrict to void.  */\n \t  int quals = cp_type_quals (nfrom) & ~TYPE_QUAL_RESTRICT;\n-\t  from = build_pointer_type\n-\t    (cp_build_qualified_type (void_type_node, quals));\n+\t  from_pointee = cp_build_qualified_type (void_type_node, quals);\n+\t  from = build_pointer_type (from_pointee);\n \t  conv = build_conv (ck_ptr, from, conv);\n \t}\n       else if (TYPE_PTRDATAMEM_P (from))\n@@ -1234,18 +1255,16 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \n \t  if (DERIVED_FROM_P (fbase, tbase)\n \t      && (same_type_ignoring_top_level_qualifiers_p\n-\t\t  (TYPE_PTRMEM_POINTED_TO_TYPE (from),\n-\t\t   TYPE_PTRMEM_POINTED_TO_TYPE (to))))\n+\t\t  (from_pointee, to_pointee)))\n \t    {\n-\t      from = build_ptrmem_type (tbase,\n-\t\t\t\t\tTYPE_PTRMEM_POINTED_TO_TYPE (from));\n+\t      from = build_ptrmem_type (tbase, from_pointee);\n \t      conv = build_conv (ck_pmem, from, conv);\n \t    }\n \t  else if (!same_type_p (fbase, tbase))\n \t    return NULL;\n \t}\n-      else if (CLASS_TYPE_P (TREE_TYPE (from))\n-\t       && CLASS_TYPE_P (TREE_TYPE (to))\n+      else if (CLASS_TYPE_P (from_pointee)\n+\t       && CLASS_TYPE_P (to_pointee)\n \t       /* [conv.ptr]\n \n \t\t  An rvalue of type \"pointer to cv D,\" where D is a\n@@ -1257,38 +1276,28 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t\t  that necessitates this conversion is ill-formed.\n \t\t  Therefore, we use DERIVED_FROM_P, and do not check\n \t\t  access or uniqueness.  */\n-\t       && DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))\n+\t       && DERIVED_FROM_P (to_pointee, from_pointee))\n \t{\n-\t  from =\n-\t    cp_build_qualified_type (TREE_TYPE (to),\n-\t\t\t\t     cp_type_quals (TREE_TYPE (from)));\n-\t  from = build_pointer_type (from);\n+\t  from_pointee\n+\t    = cp_build_qualified_type (to_pointee,\n+\t\t\t\t       cp_type_quals (from_pointee));\n+\t  from = build_pointer_type (from_pointee);\n \t  conv = build_conv (ck_ptr, from, conv);\n \t  conv->base_p = true;\n \t}\n-      else if (tx_safe_fn_type_p (TREE_TYPE (from)))\n+      else if (tx_safe_fn_type_p (from_pointee))\n \t{\n \t  /* A prvalue of type \"pointer to transaction_safe function\" can be\n \t     converted to a prvalue of type \"pointer to function\". */\n-\t  tree unsafe = tx_unsafe_fn_variant (TREE_TYPE (from));\n-\t  if (same_type_p (unsafe, TREE_TYPE (to)))\n+\t  tree unsafe = tx_unsafe_fn_variant (from_pointee);\n+\t  if (same_type_p (unsafe, to_pointee))\n \t    {\n+\t      from_pointee = unsafe;\n \t      from = build_pointer_type (unsafe);\n \t      conv = build_conv (ck_tsafe, from, conv);\n \t    }\n \t}\n \n-      if (tcode == POINTER_TYPE)\n-\t{\n-\t  to_pointee = TREE_TYPE (to);\n-\t  from_pointee = TREE_TYPE (from);\n-\t}\n-      else\n-\t{\n-\t  to_pointee = TYPE_PTRMEM_POINTED_TO_TYPE (to);\n-\t  from_pointee = TYPE_PTRMEM_POINTED_TO_TYPE (from);\n-\t}\n-\n       if (same_type_p (from, to))\n \t/* OK */;\n       else if (c_cast_p && comp_ptr_ttypes_const (to, from))"}, {"sha": "45965aa788da53d72cdc1b1980dec3b25b5b8e0d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=452811eb53e9c0457f99f4f23a4ca10354c088e1", "patch": "@@ -5913,11 +5913,11 @@ convert_nontype_argument_function (tree type, tree expr,\n \t  error (\"%qE is not a valid template argument for type %qT\",\n \t\t expr, type);\n \t  if (TYPE_PTR_P (type))\n-\t    error (\"it must be the address of a function with \"\n-\t\t   \"external linkage\");\n+\t    inform (input_location, \"it must be the address of a function \"\n+\t\t    \"with external linkage\");\n \t  else\n-\t    error (\"it must be the name of a function with \"\n-\t\t   \"external linkage\");\n+\t    inform (input_location, \"it must be the name of a function with \"\n+\t\t    \"external linkage\");\n \t}\n       return NULL_TREE;\n     }\n@@ -5939,6 +5939,11 @@ convert_nontype_argument_function (tree type, tree expr,\n       return NULL_TREE;\n     }\n \n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    fn = build_address (fn);\n+  if (!same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (fn)))\n+    fn = build_nop (type, fn);\n+\n   return fn;\n }\n \n@@ -6648,8 +6653,6 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \texpr = convert_nontype_argument_function (type, expr, complain);\n       if (!expr || expr == error_mark_node)\n \treturn expr;\n-\n-      expr = build_nop (type, build_address (expr));\n     }\n   /* [temp.arg.nontype]/5, bullet 6\n \n@@ -7325,7 +7328,8 @@ convert_template_argument (tree parm,\n       if (val == NULL_TREE)\n \tval = error_mark_node;\n       else if (val == error_mark_node && (complain & tf_error))\n-\terror (\"could not convert template argument %qE to %qT\",  orig_arg, t);\n+\terror (\"could not convert template argument %qE from %qT to %qT\",\n+\t       orig_arg, TREE_TYPE (orig_arg), t);\n \n       if (INDIRECT_REF_P (val))\n         {\n@@ -19354,7 +19358,7 @@ template_parm_level_and_index (tree parm, int* level, int* index)\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (unify (TP, TA, P, A, S, EP))\t\t\t\t\t\\\n       return 1;\t\t\t\t\t\t\t\t\\\n-  } while (0);\n+  } while (0)\n \n /* Unifies the remaining arguments in PACKED_ARGS with the pack\n    expansion at the end of PACKED_PARMS. Returns 0 if the type\n@@ -20312,6 +20316,11 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t\t class_of_this_parm (arg),\n \t\t class_of_this_parm (parm))))\n \t  return unify_cv_qual_mismatch (explain_p, parm, arg);\n+\tif (TREE_CODE (arg) == FUNCTION_TYPE\n+\t    && type_memfn_quals (parm) != type_memfn_quals (arg))\n+\t  return unify_cv_qual_mismatch (explain_p, parm, arg);\n+\tif (type_memfn_rqual (parm) != type_memfn_rqual (arg))\n+\t  return unify_type_mismatch (explain_p, parm, arg);\n \n \tRECUR_AND_CHECK_FAILURE (tparms, targs, TREE_TYPE (parm),\n \t\t\t\t TREE_TYPE (arg), UNIFY_ALLOW_NONE, explain_p);"}, {"sha": "4ff2bc2d26ecff8f5b8c6578d348bb1a5f5659a1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=452811eb53e9c0457f99f4f23a4ca10354c088e1", "patch": "@@ -1457,7 +1457,9 @@ same_type_ignoring_top_level_qualifiers_p (tree type1, tree type2)\n   if (type1 == error_mark_node || type2 == error_mark_node)\n     return false;\n \n-  return same_type_p (TYPE_MAIN_VARIANT (type1), TYPE_MAIN_VARIANT (type2));\n+  type1 = cp_build_qualified_type (type1, TYPE_UNQUALIFIED);\n+  type2 = cp_build_qualified_type (type2, TYPE_UNQUALIFIED);\n+  return same_type_p (type1, type2);\n }\n \n /* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */"}, {"sha": "746f0e279a73c54ba3988aa7efe0eb44dd69d20e", "filename": "gcc/testsuite/g++.dg/template/func2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffunc2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452811eb53e9c0457f99f4f23a4ca10354c088e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffunc2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffunc2.C?ref=452811eb53e9c0457f99f4f23a4ca10354c088e1", "patch": "@@ -5,7 +5,7 @@ fptr zeroptr = 0;\n template<typename T, fptr F> struct foo { };\n template<typename T> struct foo<T,zeroptr> { };\n // { dg-error \"not a valid template argument\" \"not valid\" { target *-*-* } 6 } \n-// { dg-error \"must be the address\" \"must be the address \" { target *-*-* } 6 }\n+// { dg-message \"must be the address\" \"must be the address \" { target *-*-* } 6 }\n \n // The rest is needed to trigger the ICE in 4.0 to 4.3:\n void f() { }"}]}