{"sha": "f014c65363d0b8a52807e55c4bda620c57440a4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxNGM2NTM2M2QwYjhhNTI4MDdlNTVjNGJkYTYyMGM1NzQ0MGE0ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-06-18T07:16:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-06-18T07:16:12Z"}, "message": "gimplify.c (omp_notice_variable): If n is non-NULL and no flags change in ORT_TARGET region, don't jump to do_outer.\n\n\t* gimplify.c (omp_notice_variable): If n is non-NULL\n\tand no flags change in ORT_TARGET region, don't jump to\n\tdo_outer.\n\t(struct gimplify_adjust_omp_clauses_data): New type.\n\t(gimplify_adjust_omp_clauses_1): Adjust for data being\n\ta struct gimplify_adjust_omp_clauses_data pointer instead\n\tof tree *.  Pass pre_p as a new argument to\n\tlang_hooks.decls.omp_finish_clause hook.\n\t(gimplify_adjust_omp_clauses): Add pre_p argument, adjust\n\tsplay_tree_foreach to pass both list_p and pre_p.\n\t(gimplify_omp_parallel, gimplify_omp_task, gimplify_omp_for,\n\tgimplify_omp_workshare, gimplify_omp_target_update): Adjust\n\tgimplify_adjust_omp_clauses callers.\n\t* langhooks.c (lhd_omp_finish_clause): New function.\n\t* langhooks-def.h (lhd_omp_finish_clause): New prototype.\n\t(LANG_HOOKS_OMP_FINISH_CLAUSE): Define to lhd_omp_finish_clause.\n\t* langhooks.h (struct lang_hooks_for_decls): Add a new\n\tgimple_seq * argument to omp_finish_clause hook.\n\t* omp-low.c (scan_sharing_clauses): Call scan_omp_op on\n\tnon-DECL_P OMP_CLAUSE_DECL if ctx->outer.\n\t(scan_omp_parallel, lower_omp_for): When adding\n\t_LOOPTEMP_ clause var, add it to outer ctx's decl_map\n\tas identity.\n\t* tree-core.h (OMP_CLAUSE_MAP_TO_PSET): New map kind.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Handle various OpenMP 4.0 clauses.\n\t* tree-pretty-print.c (dump_omp_clause): Handle\n\tOMP_CLAUSE_MAP_TO_PSET.\ngcc/cp/\n\t* cp-gimplify.c (cxx_omp_finish_clause): Add a gimple_seq *\n\targument.\n\t* cp-tree.h (cxx_omp_finish_clause): Adjust prototype.\ngcc/fortran/\n\t* cpp.c (cpp_define_builtins): Change _OPENMP macro to\n\t201307.\n\t* dump-parse-tree.c (show_omp_namelist): Add list_type\n\targument.  Adjust for rop being u.reduction_op now,\n\thandle depend_op or map_op.\n\t(show_omp_node): Adjust callers.  Print some new\n\tOpenMP 4.0 clauses, adjust for OMP_LIST_DEPEND_{IN,OUT}\n\tbecoming a single OMP_LIST_DEPEND.\n\t* f95-lang.c (gfc_handle_omp_declare_target_attribute): New\n\tfunction.\n\t(gfc_attribute_table): New variable.\n\t(LANG_HOOKS_OMP_FINISH_CLAUSE, LANG_HOOKS_ATTRIBUTE_TABLE): Redefine.\n\t* frontend-passes.c (gfc_code_walker): Handle new OpenMP target\n\tEXEC_OMP_* codes and new clauses.\n\t* gfortran.h (gfc_statement): Add ST_OMP_TARGET, ST_OMP_END_TARGET,\n\tST_OMP_TARGET_DATA, ST_OMP_END_TARGET_DATA, ST_OMP_TARGET_UPDATE,\n\tST_OMP_DECLARE_TARGET, ST_OMP_TEAMS, ST_OMP_END_TEAMS,\n\tST_OMP_DISTRIBUTE, ST_OMP_END_DISTRIBUTE, ST_OMP_DISTRIBUTE_SIMD,\n\tST_OMP_END_DISTRIBUTE_SIMD, ST_OMP_DISTRIBUTE_PARALLEL_DO,\n\tST_OMP_END_DISTRIBUTE_PARALLEL_DO, ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD,\n\tST_OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD, ST_OMP_TARGET_TEAMS,\n\tST_OMP_END_TARGET_TEAMS, ST_OMP_TEAMS_DISTRIBUTE,\n\tST_OMP_END_TEAMS_DISTRIBUTE, ST_OMP_TEAMS_DISTRIBUTE_SIMD,\n\tST_OMP_END_TEAMS_DISTRIBUTE_SIMD, ST_OMP_TARGET_TEAMS_DISTRIBUTE,\n\tST_OMP_END_TARGET_TEAMS_DISTRIBUTE,\n\tST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD,\n\tST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD,\n\tST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO,\n\tST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO,\n\tST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n\tST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n\tST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n\tST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n\tST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD and\n\tST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD.\n\t(symbol_attribute): Add omp_declare_target field.\n\t(gfc_omp_depend_op, gfc_omp_map_op): New enums.\n\t(gfc_omp_namelist): Replace rop field with union\n\tcontaining reduction_op, depend_op and map_op.\n\t(OMP_LIST_DEPEND_IN, OMP_LIST_DEPEND_OUT): Remove.\n\t(OMP_LIST_DEPEND, OMP_LIST_MAP, OMP_LIST_TO, OMP_LIST_FROM): New.\n\t(gfc_omp_clauses): Add num_teams, device, thread_limit,\n\tdist_sched_kind, dist_chunk_size fields.\n\t(gfc_common_head): Add omp_declare_target field.\n\t(gfc_exec_op): Add EXEC_OMP_TARGET, EXEC_OMP_TARGET_DATA,\n\tEXEC_OMP_TEAMS, EXEC_OMP_DISTRIBUTE, EXEC_OMP_DISTRIBUTE_SIMD,\n\tEXEC_OMP_DISTRIBUTE_PARALLEL_DO, EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD,\n\tEXEC_OMP_TARGET_TEAMS, EXEC_OMP_TEAMS_DISTRIBUTE,\n\tEXEC_OMP_TEAMS_DISTRIBUTE_SIMD, EXEC_OMP_TARGET_TEAMS_DISTRIBUTE,\n\tEXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD,\n\tEXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO,\n\tEXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n\tEXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n\tEXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD and\n\tEXEC_OMP_TARGET_UPDATE.\n\t(gfc_add_omp_declare_target): New prototype.\n\t* match.h (gfc_match_omp_declare_target, gfc_match_omp_distribute,\n\tgfc_match_omp_distribute_parallel_do,\n\tgfc_match_omp_distribute_parallel_do_simd,\n\tgfc_match_omp_distribute_simd, gfc_match_omp_target,\n\tgfc_match_omp_target_data, gfc_match_omp_target_teams,\n\tgfc_match_omp_target_teams_distribute,\n\tgfc_match_omp_target_teams_distribute_parallel_do,\n\tgfc_match_omp_target_teams_distribute_parallel_do_simd,\n\tgfc_match_omp_target_teams_distribute_simd,\n\tgfc_match_omp_target_update, gfc_match_omp_teams,\n\tgfc_match_omp_teams_distribute,\n\tgfc_match_omp_teams_distribute_parallel_do,\n\tgfc_match_omp_teams_distribute_parallel_do_simd,\n\tgfc_match_omp_teams_distribute_simd): New prototypes.\n\t* module.c (ab_attribute): Add AB_OMP_DECLARE_TARGET.\n\t(attr_bits): Likewise.\n\t(mio_symbol_attribute): Handle omp_declare_target attribute.\n\t(gfc_free_omp_clauses): Free num_teams, device, thread_limit\n\tand dist_chunk_size expressions.\n\t(OMP_CLAUSE_PRIVATE, OMP_CLAUSE_FIRSTPRIVATE, OMP_CLAUSE_LASTPRIVATE,\n\tOMP_CLAUSE_COPYPRIVATE, OMP_CLAUSE_SHARED, OMP_CLAUSE_COPYIN,\n\tOMP_CLAUSE_REDUCTION, OMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS,\n\tOMP_CLAUSE_SCHEDULE, OMP_CLAUSE_DEFAULT, OMP_CLAUSE_ORDERED,\n\tOMP_CLAUSE_COLLAPSE, OMP_CLAUSE_UNTIED, OMP_CLAUSE_FINAL,\n\tOMP_CLAUSE_MERGEABLE, OMP_CLAUSE_ALIGNED, OMP_CLAUSE_DEPEND,\n\tOMP_CLAUSE_INBRANCH, OMP_CLAUSE_LINEAR, OMP_CLAUSE_NOTINBRANCH,\n\tOMP_CLAUSE_PROC_BIND, OMP_CLAUSE_SAFELEN, OMP_CLAUSE_SIMDLEN,\n\tOMP_CLAUSE_UNIFORM): Use 1U instead of 1.\n\t(OMP_CLAUSE_DEVICE, OMP_CLAUSE_MAP, OMP_CLAUSE_TO, OMP_CLAUSE_FROM,\n\tOMP_CLAUSE_NUM_TEAMS, OMP_CLAUSE_THREAD_LIMIT,\n\tOMP_CLAUSE_DIST_SCHEDULE): Define.\n\t(gfc_match_omp_clauses): Change mask parameter to unsigned int.\n\tAdjust for rop becoming u.reduction_op.  Disallow inbranch with\n\tnotinbranch.  For depend clause, always create OMP_LIST_DEPEND\n\tand fill in u.depend_op.  Handle num_teams, device, map,\n\tto, from, thread_limit and dist_schedule clauses.\n\t(OMP_DECLARE_SIMD_CLAUSES): Or in OMP_CLAUSE_INBRANCH and\n\tOMP_CLAUSE_NOTINBRANCH.\n\t(OMP_TARGET_CLAUSES, OMP_TARGET_DATA_CLAUSES,\n\tOMP_TARGET_UPDATE_CLAUSES, OMP_TEAMS_CLAUSES,\n\tOMP_DISTRIBUTE_CLAUSES): Define.\n\t(match_omp): New function.\n\t(gfc_match_omp_do, gfc_match_omp_do_simd, gfc_match_omp_parallel,\n\tgfc_match_omp_parallel_do, gfc_match_omp_parallel_do_simd,\n\tgfc_match_omp_parallel_sections, gfc_match_omp_parallel_workshare,\n\tgfc_match_omp_sections, gfc_match_omp_simd, gfc_match_omp_single,\n\tgfc_match_omp_task): Rewritten using match_omp.\n\t(gfc_match_omp_threadprivate, gfc_match_omp_declare_reduction):\n\tDiagnose if the directives are followed by unexpected junk.\n\t(gfc_match_omp_distribute, gfc_match_omp_distribute_parallel_do,\n\tgfc_match_omp_distribute_parallel_do_simd,\n\tgfc_match_omp_distrbute_simd, gfc_match_omp_declare_target,\n\tgfc_match_omp_target, gfc_match_omp_target_data,\n\tgfc_match_omp_target_teams, gfc_match_omp_target_teams_distribute,\n\tgfc_match_omp_target_teams_distribute_parallel_do,\n\tgfc_match_omp_target_teams_distribute_parallel_do_simd,\n\tgfc_match_omp_target_teams_distrbute_simd, gfc_match_omp_target_update,\n\tgfc_match_omp_teams, gfc_match_omp_teams_distribute,\n\tgfc_match_omp_teams_distribute_parallel_do,\n\tgfc_match_omp_teams_distribute_parallel_do_simd,\n\tgfc_match_omp_teams_distrbute_simd): New functions.\n\t* openmp.c (resolve_omp_clauses): Adjust for\n\tOMP_LIST_DEPEND_{IN,OUT} being changed to OMP_LIST_DEPEND.  Handle\n\tOMP_LIST_MAP, OMP_LIST_FROM, OMP_LIST_TO, num_teams, device,\n\tdist_chunk_size and thread_limit.\n\t(gfc_resolve_omp_parallel_blocks): Only put sharing clauses into\n\tctx.sharing_clauses.  Call gfc_resolve_omp_do_blocks for various\n\tnew EXEC_OMP_* codes.\n\t(resolve_omp_do): Handle various new EXEC_OMP_* codes.\n\t(gfc_resolve_omp_directive): Likewise.\n\t(gfc_resolve_omp_declare_simd): Add missing space to diagnostics.\n\t* parse.c (decode_omp_directive): Handle parsing of OpenMP 4.0\n\toffloading related directives.\n\t(case_executable): Add ST_OMP_TARGET_UPDATE.\n\t(case_exec_markers): Add ST_OMP_TARGET*, ST_OMP_TEAMS*,\n\tST_OMP_DISTRIBUTE*.\n\t(case_decl): Add ST_OMP_DECLARE_TARGET.\n\t(gfc_ascii_statement): Handle new ST_OMP_* codes.\n\t(parse_omp_do): Handle various new ST_OMP_* codes.\n\t(parse_executable): Likewise.\n\t* resolve.c (gfc_resolve_blocks): Handle various new EXEC_OMP_*\n\tcodes.\n\t(resolve_code): Likewise.\n\t(resolve_symbol): Change that !$OMP DECLARE TARGET variables\n\tare saved.\n\t* st.c (gfc_free_statement): Handle various new EXEC_OMP_* codes.\n\t* symbol.c (check_conflict): Check omp_declare_target conflicts.\n\t(gfc_add_omp_declare_target): New function.\n\t(gfc_copy_attr): Copy omp_declare_target.\n\t* trans.c (trans_code): Handle various new EXEC_OMP_* codes.\n\t* trans-common.c (build_common_decl): Add \"omp declare target\"\n\tattribute if needed.\n\t* trans-decl.c (add_attributes_to_decl): Likewise.\n\t* trans.h (gfc_omp_finish_clause): New prototype.\n\t* trans-openmp.c (gfc_omp_finish_clause): New function.\n\t(gfc_trans_omp_reduction_list): Adjust for rop being renamed\n\tto u.reduction_op.\n\t(gfc_trans_omp_clauses): Adjust for OMP_LIST_DEPEND_{IN,OUT}\n\tchange to OMP_LIST_DEPEND and fix up depend handling.\n\tHandle OMP_LIST_MAP, OMP_LIST_TO, OMP_LIST_FROM, num_teams,\n\tthread_limit, device, dist_chunk_size and dist_sched_kind.\n\t(gfc_trans_omp_do): Handle EXEC_OMP_DISTRIBUTE.\n\t(GFC_OMP_SPLIT_DISTRIBUTE, GFC_OMP_SPLIT_TEAMS,\n\tGFC_OMP_SPLIT_TARGET, GFC_OMP_SPLIT_NUM, GFC_OMP_MASK_DISTRIBUTE,\n\tGFC_OMP_MASK_TEAMS, GFC_OMP_MASK_TARGET, GFC_OMP_MASK_NUM): New.\n\t(gfc_split_omp_clauses): Handle splitting of clauses for new\n\tEXEC_OMP_* codes.\n\t(gfc_trans_omp_do_simd): Add pblock argument, adjust for being\n\tcallable for combined constructs.\n\t(gfc_trans_omp_parallel_do, gfc_trans_omp_parallel_do_simd): Likewise.\n\t(gfc_trans_omp_distribute, gfc_trans_omp_teams,\n\tgfc_trans_omp_target, gfc_trans_omp_target_data,\n\tgfc_trans_omp_target_update): New functions.\n\t(gfc_trans_omp_directive): Adjust gfc_trans_omp_* callers, handle\n\tnew EXEC_OMP_* codes.\ngcc/testsuite/\n\t* gfortran.dg/gomp/declare-simd-1.f90: New test.\n\t* gfortran.dg/gomp/depend-1.f90: New test.\n\t* gfortran.dg/gomp/target1.f90: New test.\n\t* gfortran.dg/gomp/target2.f90: New test.\n\t* gfortran.dg/gomp/target3.f90: New test.\n\t* gfortran.dg/gomp/udr4.f90: Adjust expected diagnostics.\n\t* gfortran.dg/openmp-define-3.f90: Expect _OPENMP 201307 instead of\n\t201107.\nlibgomp/\n\t* omp_lib.f90.in (openmp_version): Set to 201307.\n\t* omp_lib.h.in (openmp_version): Likewise.\n\t* testsuite/libgomp.c/target-8.c: New test.\n\t* testsuite/libgomp.fortran/declare-simd-1.f90: Add notinbranch\n\tand inbranch clauses.\n\t* testsuite/libgomp.fortran/depend-3.f90: New test.\n\t* testsuite/libgomp.fortran/openmp_version-1.f: Adjust for new\n\topenmp_version.\n\t* testsuite/libgomp.fortran/openmp_version-2.f90: Likewise.\n\t* testsuite/libgomp.fortran/target1.f90: New test.\n\t* testsuite/libgomp.fortran/target2.f90: New test.\n\t* testsuite/libgomp.fortran/target3.f90: New test.\n\t* testsuite/libgomp.fortran/target4.f90: New test.\n\t* testsuite/libgomp.fortran/target5.f90: New test.\n\t* testsuite/libgomp.fortran/target6.f90: New test.\n\t* testsuite/libgomp.fortran/target7.f90: New test.\n\nFrom-SVN: r211768", "tree": {"sha": "20e7887bc99ba095e639c296ace7f2c40b3b9f11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20e7887bc99ba095e639c296ace7f2c40b3b9f11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f014c65363d0b8a52807e55c4bda620c57440a4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f014c65363d0b8a52807e55c4bda620c57440a4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f014c65363d0b8a52807e55c4bda620c57440a4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f014c65363d0b8a52807e55c4bda620c57440a4d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e9c4087ccc59ef152dd387e51fa544c64c58b38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e9c4087ccc59ef152dd387e51fa544c64c58b38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e9c4087ccc59ef152dd387e51fa544c64c58b38"}], "stats": {"total": 3913, "additions": 3583, "deletions": 330}, "files": [{"sha": "0fc67169c8e58dbd567020c381f80f27a4d1bd66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1,3 +1,34 @@\n+2014-06-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimplify.c (omp_notice_variable): If n is non-NULL\n+\tand no flags change in ORT_TARGET region, don't jump to\n+\tdo_outer.\n+\t(struct gimplify_adjust_omp_clauses_data): New type.\n+\t(gimplify_adjust_omp_clauses_1): Adjust for data being\n+\ta struct gimplify_adjust_omp_clauses_data pointer instead\n+\tof tree *.  Pass pre_p as a new argument to\n+\tlang_hooks.decls.omp_finish_clause hook.\n+\t(gimplify_adjust_omp_clauses): Add pre_p argument, adjust\n+\tsplay_tree_foreach to pass both list_p and pre_p.\n+\t(gimplify_omp_parallel, gimplify_omp_task, gimplify_omp_for,\n+\tgimplify_omp_workshare, gimplify_omp_target_update): Adjust\n+\tgimplify_adjust_omp_clauses callers.\n+\t* langhooks.c (lhd_omp_finish_clause): New function.\n+\t* langhooks-def.h (lhd_omp_finish_clause): New prototype.\n+\t(LANG_HOOKS_OMP_FINISH_CLAUSE): Define to lhd_omp_finish_clause.\n+\t* langhooks.h (struct lang_hooks_for_decls): Add a new\n+\tgimple_seq * argument to omp_finish_clause hook.\n+\t* omp-low.c (scan_sharing_clauses): Call scan_omp_op on\n+\tnon-DECL_P OMP_CLAUSE_DECL if ctx->outer.\n+\t(scan_omp_parallel, lower_omp_for): When adding\n+\t_LOOPTEMP_ clause var, add it to outer ctx's decl_map\n+\tas identity.\n+\t* tree-core.h (OMP_CLAUSE_MAP_TO_PSET): New map kind.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses,\n+\tconvert_local_omp_clauses): Handle various OpenMP 4.0 clauses.\n+\t* tree-pretty-print.c (dump_omp_clause): Handle\n+\tOMP_CLAUSE_MAP_TO_PSET.\n+\n 2014-06-17  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* tree-dfa.h (get_addr_base_and_unit_offset_1): Move from here."}, {"sha": "9b4818ed971f9b9a2f68d51e6969439f486ca2fb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1,3 +1,9 @@\n+2014-06-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-gimplify.c (cxx_omp_finish_clause): Add a gimple_seq *\n+\targument.\n+\t* cp-tree.h (cxx_omp_finish_clause): Adjust prototype.\n+\n 2014-06-17  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/60605"}, {"sha": "296bd5f2443e2403a23e391763562787c5b7498c", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1592,7 +1592,7 @@ cxx_omp_predetermined_sharing (tree decl)\n /* Finalize an implicitly determined clause.  */\n \n void\n-cxx_omp_finish_clause (tree c)\n+cxx_omp_finish_clause (tree c, gimple_seq *)\n {\n   tree decl, inner_type;\n   bool make_shared = false;"}, {"sha": "71298efe504cd0d0f1ef098f929a95220960562f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -6228,7 +6228,7 @@ extern tree cxx_omp_clause_default_ctor\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_copy_ctor\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_assign_op\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n-extern void cxx_omp_finish_clause\t\t(tree);\n+extern void cxx_omp_finish_clause\t\t(tree, gimple_seq *);\n extern bool cxx_omp_privatize_by_reference\t(const_tree);\n \n /* in name-lookup.c */"}, {"sha": "3a5d6aab4419df4ef184f7c001c9aba2b0c23cc8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1,3 +1,177 @@\n+2014-06-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cpp.c (cpp_define_builtins): Change _OPENMP macro to\n+\t201307.\n+\t* dump-parse-tree.c (show_omp_namelist): Add list_type\n+\targument.  Adjust for rop being u.reduction_op now,\n+\thandle depend_op or map_op.\n+\t(show_omp_node): Adjust callers.  Print some new\n+\tOpenMP 4.0 clauses, adjust for OMP_LIST_DEPEND_{IN,OUT}\n+\tbecoming a single OMP_LIST_DEPEND.\n+\t* f95-lang.c (gfc_handle_omp_declare_target_attribute): New\n+\tfunction.\n+\t(gfc_attribute_table): New variable.\n+\t(LANG_HOOKS_OMP_FINISH_CLAUSE, LANG_HOOKS_ATTRIBUTE_TABLE): Redefine.\n+\t* frontend-passes.c (gfc_code_walker): Handle new OpenMP target\n+\tEXEC_OMP_* codes and new clauses.\n+\t* gfortran.h (gfc_statement): Add ST_OMP_TARGET, ST_OMP_END_TARGET,\n+\tST_OMP_TARGET_DATA, ST_OMP_END_TARGET_DATA, ST_OMP_TARGET_UPDATE,\n+\tST_OMP_DECLARE_TARGET, ST_OMP_TEAMS, ST_OMP_END_TEAMS,\n+\tST_OMP_DISTRIBUTE, ST_OMP_END_DISTRIBUTE, ST_OMP_DISTRIBUTE_SIMD,\n+\tST_OMP_END_DISTRIBUTE_SIMD, ST_OMP_DISTRIBUTE_PARALLEL_DO,\n+\tST_OMP_END_DISTRIBUTE_PARALLEL_DO, ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD,\n+\tST_OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD, ST_OMP_TARGET_TEAMS,\n+\tST_OMP_END_TARGET_TEAMS, ST_OMP_TEAMS_DISTRIBUTE,\n+\tST_OMP_END_TEAMS_DISTRIBUTE, ST_OMP_TEAMS_DISTRIBUTE_SIMD,\n+\tST_OMP_END_TEAMS_DISTRIBUTE_SIMD, ST_OMP_TARGET_TEAMS_DISTRIBUTE,\n+\tST_OMP_END_TARGET_TEAMS_DISTRIBUTE,\n+\tST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD,\n+\tST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD,\n+\tST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+\tST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+\tST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+\tST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+\tST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+\tST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+\tST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD and\n+\tST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD.\n+\t(symbol_attribute): Add omp_declare_target field.\n+\t(gfc_omp_depend_op, gfc_omp_map_op): New enums.\n+\t(gfc_omp_namelist): Replace rop field with union\n+\tcontaining reduction_op, depend_op and map_op.\n+\t(OMP_LIST_DEPEND_IN, OMP_LIST_DEPEND_OUT): Remove.\n+\t(OMP_LIST_DEPEND, OMP_LIST_MAP, OMP_LIST_TO, OMP_LIST_FROM): New.\n+\t(gfc_omp_clauses): Add num_teams, device, thread_limit,\n+\tdist_sched_kind, dist_chunk_size fields.\n+\t(gfc_common_head): Add omp_declare_target field.\n+\t(gfc_exec_op): Add EXEC_OMP_TARGET, EXEC_OMP_TARGET_DATA,\n+\tEXEC_OMP_TEAMS, EXEC_OMP_DISTRIBUTE, EXEC_OMP_DISTRIBUTE_SIMD,\n+\tEXEC_OMP_DISTRIBUTE_PARALLEL_DO, EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD,\n+\tEXEC_OMP_TARGET_TEAMS, EXEC_OMP_TEAMS_DISTRIBUTE,\n+\tEXEC_OMP_TEAMS_DISTRIBUTE_SIMD, EXEC_OMP_TARGET_TEAMS_DISTRIBUTE,\n+\tEXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD,\n+\tEXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+\tEXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+\tEXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+\tEXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD and\n+\tEXEC_OMP_TARGET_UPDATE.\n+\t(gfc_add_omp_declare_target): New prototype.\n+\t* match.h (gfc_match_omp_declare_target, gfc_match_omp_distribute,\n+\tgfc_match_omp_distribute_parallel_do,\n+\tgfc_match_omp_distribute_parallel_do_simd,\n+\tgfc_match_omp_distribute_simd, gfc_match_omp_target,\n+\tgfc_match_omp_target_data, gfc_match_omp_target_teams,\n+\tgfc_match_omp_target_teams_distribute,\n+\tgfc_match_omp_target_teams_distribute_parallel_do,\n+\tgfc_match_omp_target_teams_distribute_parallel_do_simd,\n+\tgfc_match_omp_target_teams_distribute_simd,\n+\tgfc_match_omp_target_update, gfc_match_omp_teams,\n+\tgfc_match_omp_teams_distribute,\n+\tgfc_match_omp_teams_distribute_parallel_do,\n+\tgfc_match_omp_teams_distribute_parallel_do_simd,\n+\tgfc_match_omp_teams_distribute_simd): New prototypes.\n+\t* module.c (ab_attribute): Add AB_OMP_DECLARE_TARGET.\n+\t(attr_bits): Likewise.\n+\t(mio_symbol_attribute): Handle omp_declare_target attribute.\n+\t(gfc_free_omp_clauses): Free num_teams, device, thread_limit\n+\tand dist_chunk_size expressions.\n+\t(OMP_CLAUSE_PRIVATE, OMP_CLAUSE_FIRSTPRIVATE, OMP_CLAUSE_LASTPRIVATE,\n+\tOMP_CLAUSE_COPYPRIVATE, OMP_CLAUSE_SHARED, OMP_CLAUSE_COPYIN,\n+\tOMP_CLAUSE_REDUCTION, OMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS,\n+\tOMP_CLAUSE_SCHEDULE, OMP_CLAUSE_DEFAULT, OMP_CLAUSE_ORDERED,\n+\tOMP_CLAUSE_COLLAPSE, OMP_CLAUSE_UNTIED, OMP_CLAUSE_FINAL,\n+\tOMP_CLAUSE_MERGEABLE, OMP_CLAUSE_ALIGNED, OMP_CLAUSE_DEPEND,\n+\tOMP_CLAUSE_INBRANCH, OMP_CLAUSE_LINEAR, OMP_CLAUSE_NOTINBRANCH,\n+\tOMP_CLAUSE_PROC_BIND, OMP_CLAUSE_SAFELEN, OMP_CLAUSE_SIMDLEN,\n+\tOMP_CLAUSE_UNIFORM): Use 1U instead of 1.\n+\t(OMP_CLAUSE_DEVICE, OMP_CLAUSE_MAP, OMP_CLAUSE_TO, OMP_CLAUSE_FROM,\n+\tOMP_CLAUSE_NUM_TEAMS, OMP_CLAUSE_THREAD_LIMIT,\n+\tOMP_CLAUSE_DIST_SCHEDULE): Define.\n+\t(gfc_match_omp_clauses): Change mask parameter to unsigned int.\n+\tAdjust for rop becoming u.reduction_op.  Disallow inbranch with\n+\tnotinbranch.  For depend clause, always create OMP_LIST_DEPEND\n+\tand fill in u.depend_op.  Handle num_teams, device, map,\n+\tto, from, thread_limit and dist_schedule clauses.\n+\t(OMP_DECLARE_SIMD_CLAUSES): Or in OMP_CLAUSE_INBRANCH and\n+\tOMP_CLAUSE_NOTINBRANCH.\n+\t(OMP_TARGET_CLAUSES, OMP_TARGET_DATA_CLAUSES,\n+\tOMP_TARGET_UPDATE_CLAUSES, OMP_TEAMS_CLAUSES,\n+\tOMP_DISTRIBUTE_CLAUSES): Define.\n+\t(match_omp): New function.\n+\t(gfc_match_omp_do, gfc_match_omp_do_simd, gfc_match_omp_parallel,\n+\tgfc_match_omp_parallel_do, gfc_match_omp_parallel_do_simd,\n+\tgfc_match_omp_parallel_sections, gfc_match_omp_parallel_workshare,\n+\tgfc_match_omp_sections, gfc_match_omp_simd, gfc_match_omp_single,\n+\tgfc_match_omp_task): Rewritten using match_omp.\n+\t(gfc_match_omp_threadprivate, gfc_match_omp_declare_reduction):\n+\tDiagnose if the directives are followed by unexpected junk.\n+\t(gfc_match_omp_distribute, gfc_match_omp_distribute_parallel_do,\n+\tgfc_match_omp_distribute_parallel_do_simd,\n+\tgfc_match_omp_distrbute_simd, gfc_match_omp_declare_target,\n+\tgfc_match_omp_target, gfc_match_omp_target_data,\n+\tgfc_match_omp_target_teams, gfc_match_omp_target_teams_distribute,\n+\tgfc_match_omp_target_teams_distribute_parallel_do,\n+\tgfc_match_omp_target_teams_distribute_parallel_do_simd,\n+\tgfc_match_omp_target_teams_distrbute_simd, gfc_match_omp_target_update,\n+\tgfc_match_omp_teams, gfc_match_omp_teams_distribute,\n+\tgfc_match_omp_teams_distribute_parallel_do,\n+\tgfc_match_omp_teams_distribute_parallel_do_simd,\n+\tgfc_match_omp_teams_distrbute_simd): New functions.\n+\t* openmp.c (resolve_omp_clauses): Adjust for\n+\tOMP_LIST_DEPEND_{IN,OUT} being changed to OMP_LIST_DEPEND.  Handle\n+\tOMP_LIST_MAP, OMP_LIST_FROM, OMP_LIST_TO, num_teams, device,\n+\tdist_chunk_size and thread_limit.\n+\t(gfc_resolve_omp_parallel_blocks): Only put sharing clauses into\n+\tctx.sharing_clauses.  Call gfc_resolve_omp_do_blocks for various\n+\tnew EXEC_OMP_* codes.\n+\t(resolve_omp_do): Handle various new EXEC_OMP_* codes.\n+\t(gfc_resolve_omp_directive): Likewise.\n+\t(gfc_resolve_omp_declare_simd): Add missing space to diagnostics.\n+\t* parse.c (decode_omp_directive): Handle parsing of OpenMP 4.0\n+\toffloading related directives.\n+\t(case_executable): Add ST_OMP_TARGET_UPDATE.\n+\t(case_exec_markers): Add ST_OMP_TARGET*, ST_OMP_TEAMS*,\n+\tST_OMP_DISTRIBUTE*.\n+\t(case_decl): Add ST_OMP_DECLARE_TARGET.\n+\t(gfc_ascii_statement): Handle new ST_OMP_* codes.\n+\t(parse_omp_do): Handle various new ST_OMP_* codes.\n+\t(parse_executable): Likewise.\n+\t* resolve.c (gfc_resolve_blocks): Handle various new EXEC_OMP_*\n+\tcodes.\n+\t(resolve_code): Likewise.\n+\t(resolve_symbol): Change that !$OMP DECLARE TARGET variables\n+\tare saved.\n+\t* st.c (gfc_free_statement): Handle various new EXEC_OMP_* codes.\n+\t* symbol.c (check_conflict): Check omp_declare_target conflicts.\n+\t(gfc_add_omp_declare_target): New function.\n+\t(gfc_copy_attr): Copy omp_declare_target.\n+\t* trans.c (trans_code): Handle various new EXEC_OMP_* codes.\n+\t* trans-common.c (build_common_decl): Add \"omp declare target\"\n+\tattribute if needed.\n+\t* trans-decl.c (add_attributes_to_decl): Likewise.\n+\t* trans.h (gfc_omp_finish_clause): New prototype.\n+\t* trans-openmp.c (gfc_omp_finish_clause): New function.\n+\t(gfc_trans_omp_reduction_list): Adjust for rop being renamed\n+\tto u.reduction_op.\n+\t(gfc_trans_omp_clauses): Adjust for OMP_LIST_DEPEND_{IN,OUT}\n+\tchange to OMP_LIST_DEPEND and fix up depend handling.\n+\tHandle OMP_LIST_MAP, OMP_LIST_TO, OMP_LIST_FROM, num_teams,\n+\tthread_limit, device, dist_chunk_size and dist_sched_kind.\n+\t(gfc_trans_omp_do): Handle EXEC_OMP_DISTRIBUTE.\n+\t(GFC_OMP_SPLIT_DISTRIBUTE, GFC_OMP_SPLIT_TEAMS,\n+\tGFC_OMP_SPLIT_TARGET, GFC_OMP_SPLIT_NUM, GFC_OMP_MASK_DISTRIBUTE,\n+\tGFC_OMP_MASK_TEAMS, GFC_OMP_MASK_TARGET, GFC_OMP_MASK_NUM): New.\n+\t(gfc_split_omp_clauses): Handle splitting of clauses for new\n+\tEXEC_OMP_* codes.\n+\t(gfc_trans_omp_do_simd): Add pblock argument, adjust for being\n+\tcallable for combined constructs.\n+\t(gfc_trans_omp_parallel_do, gfc_trans_omp_parallel_do_simd): Likewise.\n+\t(gfc_trans_omp_distribute, gfc_trans_omp_teams,\n+\tgfc_trans_omp_target, gfc_trans_omp_target_data,\n+\tgfc_trans_omp_target_update): New functions.\n+\t(gfc_trans_omp_directive): Adjust gfc_trans_omp_* callers, handle\n+\tnew EXEC_OMP_* codes.\n+\n 2014-06-18  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/61126"}, {"sha": "7fb8d160267fb9f399f2550fda6d8519e5b71071", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -171,7 +171,7 @@ cpp_define_builtins (cpp_reader *pfile)\n   cpp_define (pfile, \"_LANGUAGE_FORTRAN=1\");\n \n   if (gfc_option.gfc_flag_openmp)\n-    cpp_define (pfile, \"_OPENMP=201107\");\n+    cpp_define (pfile, \"_OPENMP=201307\");\n \n   /* The defines below are necessary for the TARGET_* macros.\n "}, {"sha": "de942f83819b25b6c893fcf4fa31bbb6853a9252", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 76, "deletions": 34, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1016,32 +1016,51 @@ show_code (int level, gfc_code *c)\n }\n \n static void\n-show_omp_namelist (gfc_omp_namelist *n)\n+show_omp_namelist (int list_type, gfc_omp_namelist *n)\n {\n   for (; n; n = n->next)\n     {\n-      switch (n->rop)\n-\t{\n-\tcase OMP_REDUCTION_PLUS:\n-\tcase OMP_REDUCTION_TIMES:\n-\tcase OMP_REDUCTION_MINUS:\n-\tcase OMP_REDUCTION_AND:\n-\tcase OMP_REDUCTION_OR:\n-\tcase OMP_REDUCTION_EQV:\n-\tcase OMP_REDUCTION_NEQV:\n-\t  fprintf (dumpfile, \"%s:\", gfc_op2string ((gfc_intrinsic_op) n->rop));\n-\t  break;\n-\tcase OMP_REDUCTION_MAX: fputs (\"max:\", dumpfile); break;\n-\tcase OMP_REDUCTION_MIN: fputs (\"min:\", dumpfile); break;\n-\tcase OMP_REDUCTION_IAND: fputs (\"iand:\", dumpfile); break;\n-\tcase OMP_REDUCTION_IOR: fputs (\"ior:\", dumpfile); break;\n-\tcase OMP_REDUCTION_IEOR: fputs (\"ieor:\", dumpfile); break;\n-\tcase OMP_REDUCTION_USER:\n-\t  if (n->udr)\n-\t    fprintf (dumpfile, \"%s:\", n->udr->name);\n-\t  break;\n-\tdefault: break;\n-\t}\n+      if (list_type == OMP_LIST_REDUCTION)\n+\tswitch (n->u.reduction_op)\n+\t  {\n+\t  case OMP_REDUCTION_PLUS:\n+\t  case OMP_REDUCTION_TIMES:\n+\t  case OMP_REDUCTION_MINUS:\n+\t  case OMP_REDUCTION_AND:\n+\t  case OMP_REDUCTION_OR:\n+\t  case OMP_REDUCTION_EQV:\n+\t  case OMP_REDUCTION_NEQV:\n+\t    fprintf (dumpfile, \"%s:\",\n+\t\t     gfc_op2string ((gfc_intrinsic_op) n->u.reduction_op));\n+\t    break;\n+\t  case OMP_REDUCTION_MAX: fputs (\"max:\", dumpfile); break;\n+\t  case OMP_REDUCTION_MIN: fputs (\"min:\", dumpfile); break;\n+\t  case OMP_REDUCTION_IAND: fputs (\"iand:\", dumpfile); break;\n+\t  case OMP_REDUCTION_IOR: fputs (\"ior:\", dumpfile); break;\n+\t  case OMP_REDUCTION_IEOR: fputs (\"ieor:\", dumpfile); break;\n+\t  case OMP_REDUCTION_USER:\n+\t    if (n->udr)\n+\t      fprintf (dumpfile, \"%s:\", n->udr->name);\n+\t    break;\n+\t  default: break;\n+\t  }\n+      else if (list_type == OMP_LIST_DEPEND)\n+\tswitch (n->u.depend_op)\n+\t  {\n+\t  case OMP_DEPEND_IN: fputs (\"in:\", dumpfile); break;\n+\t  case OMP_DEPEND_OUT: fputs (\"out:\", dumpfile); break;\n+\t  case OMP_DEPEND_INOUT: fputs (\"inout:\", dumpfile); break;\n+\t  default: break;\n+\t  }\n+      else if (list_type == OMP_LIST_MAP)\n+\tswitch (n->u.map_op)\n+\t  {\n+\t  case OMP_MAP_ALLOC: fputs (\"alloc:\", dumpfile); break;\n+\t  case OMP_MAP_TO: fputs (\"to:\", dumpfile); break;\n+\t  case OMP_MAP_FROM: fputs (\"from:\", dumpfile); break;\n+\t  case OMP_MAP_TOFROM: fputs (\"tofrom:\", dumpfile); break;\n+\t  default: break;\n+\t  }\n       fprintf (dumpfile, \"%s\", n->sym->name);\n       if (n->expr)\n \t{\n@@ -1117,7 +1136,7 @@ show_omp_node (int level, gfc_code *c)\n       if (c->ext.omp_namelist)\n \t{\n \t  fputs (\" (\", dumpfile);\n-\t  show_omp_namelist (c->ext.omp_namelist);\n+\t  show_omp_namelist (OMP_LIST_NUM, c->ext.omp_namelist);\n \t  fputc (')', dumpfile);\n \t}\n       return;\n@@ -1226,18 +1245,12 @@ show_omp_node (int level, gfc_code *c)\n \t      case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n \t      case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n \t      case OMP_LIST_REDUCTION: type = \"REDUCTION\"; break;\n-\t      case OMP_LIST_DEPEND_IN:\n-\t\tfprintf (dumpfile, \" DEPEND(IN:\");\n-\t\tbreak;\n-\t      case OMP_LIST_DEPEND_OUT:\n-\t\tfprintf (dumpfile, \" DEPEND(OUT:\");\n-\t\tbreak;\n+\t      case OMP_LIST_DEPEND: type = \"DEPEND\"; break;\n \t      default:\n \t\tgcc_unreachable ();\n \t      }\n-\t    if (type)\n-\t      fprintf (dumpfile, \" %s(\", type);\n-\t    show_omp_namelist (omp_clauses->lists[list_type]);\n+\t    fprintf (dumpfile, \" %s(\", type);\n+\t    show_omp_namelist (list_type, omp_clauses->lists[list_type]);\n \t    fputc (')', dumpfile);\n \t  }\n       if (omp_clauses->safelen_expr)\n@@ -1269,6 +1282,34 @@ show_omp_node (int level, gfc_code *c)\n \t    }\n \t  fprintf (dumpfile, \" PROC_BIND(%s)\", type);\n \t}\n+      if (omp_clauses->num_teams)\n+\t{\n+\t  fputs (\" NUM_TEAMS(\", dumpfile);\n+\t  show_expr (omp_clauses->num_teams);\n+\t  fputc (')', dumpfile);\n+\t}\n+      if (omp_clauses->device)\n+\t{\n+\t  fputs (\" DEVICE(\", dumpfile);\n+\t  show_expr (omp_clauses->device);\n+\t  fputc (')', dumpfile);\n+\t}\n+      if (omp_clauses->thread_limit)\n+\t{\n+\t  fputs (\" THREAD_LIMIT(\", dumpfile);\n+\t  show_expr (omp_clauses->thread_limit);\n+\t  fputc (')', dumpfile);\n+\t}\n+      if (omp_clauses->dist_sched_kind != OMP_SCHED_NONE)\n+\t{\n+\t  fprintf (dumpfile, \" DIST_SCHEDULE (static\");\n+\t  if (omp_clauses->dist_chunk_size)\n+\t    {\n+\t      fputc (',', dumpfile);\n+\t      show_expr (omp_clauses->dist_chunk_size);\n+\t    }\n+\t  fputc (')', dumpfile);\n+\t}\n     }\n   fputc ('\\n', dumpfile);\n   if (c->op == EXEC_OMP_SECTIONS || c->op == EXEC_OMP_PARALLEL_SECTIONS)\n@@ -1296,7 +1337,8 @@ show_omp_node (int level, gfc_code *c)\n       if (omp_clauses->lists[OMP_LIST_COPYPRIVATE])\n \t{\n \t  fputs (\" COPYPRIVATE(\", dumpfile);\n-\t  show_omp_namelist (omp_clauses->lists[OMP_LIST_COPYPRIVATE]);\n+\t  show_omp_namelist (OMP_LIST_COPYPRIVATE,\n+\t\t\t     omp_clauses->lists[OMP_LIST_COPYPRIVATE]);\n \t  fputc (')', dumpfile);\n \t}\n       else if (omp_clauses->nowait)"}, {"sha": "e41f61a9f5d81f208abc9c1b0401ea29182215db", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -87,6 +87,24 @@ static alias_set_type gfc_get_alias_set (tree);\n static void gfc_init_ts (void);\n static tree gfc_builtin_function (tree);\n \n+/* Handle an \"omp declare target\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+gfc_handle_omp_declare_target_attribute (tree *, tree, tree, int, bool *)\n+{\n+  return NULL_TREE;\n+}\n+\n+/* Table of valid Fortran attributes.  */\n+static const struct attribute_spec gfc_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n+       affects_type_identity } */\n+  { \"omp declare target\", 0, 0, true,  false, false,\n+    gfc_handle_omp_declare_target_attribute, false },\n+  { NULL,\t\t  0, 0, false, false, false, NULL, false }\n+};\n+\n #undef LANG_HOOKS_NAME\n #undef LANG_HOOKS_INIT\n #undef LANG_HOOKS_FINISH\n@@ -109,13 +127,15 @@ static tree gfc_builtin_function (tree);\n #undef LANG_HOOKS_OMP_CLAUSE_COPY_CTOR\n #undef LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP\n #undef LANG_HOOKS_OMP_CLAUSE_DTOR\n+#undef LANG_HOOKS_OMP_FINISH_CLAUSE\n #undef LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\n #undef LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\n #undef LANG_HOOKS_OMP_PRIVATE_OUTER_REF\n #undef LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES\n #undef LANG_HOOKS_BUILTIN_FUNCTION\n #undef LANG_HOOKS_BUILTIN_FUNCTION\n #undef LANG_HOOKS_GET_ARRAY_DESCR_INFO\n+#undef LANG_HOOKS_ATTRIBUTE_TABLE\n \n /* Define lang hooks.  */\n #define LANG_HOOKS_NAME                 \"GNU Fortran\"\n@@ -139,13 +159,15 @@ static tree gfc_builtin_function (tree);\n #define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR\t\tgfc_omp_clause_copy_ctor\n #define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP\t\tgfc_omp_clause_assign_op\n #define LANG_HOOKS_OMP_CLAUSE_DTOR\t\tgfc_omp_clause_dtor\n+#define LANG_HOOKS_OMP_FINISH_CLAUSE\t\tgfc_omp_finish_clause\n #define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\tgfc_omp_disregard_value_expr\n #define LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\tgfc_omp_private_debug_clause\n #define LANG_HOOKS_OMP_PRIVATE_OUTER_REF\tgfc_omp_private_outer_ref\n #define LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES \\\n   gfc_omp_firstprivatize_type_sizes\n-#define LANG_HOOKS_BUILTIN_FUNCTION          gfc_builtin_function\n-#define LANG_HOOKS_GET_ARRAY_DESCR_INFO\t     gfc_get_array_descr_info\n+#define LANG_HOOKS_BUILTIN_FUNCTION\tgfc_builtin_function\n+#define LANG_HOOKS_GET_ARRAY_DESCR_INFO\tgfc_get_array_descr_info\n+#define LANG_HOOKS_ATTRIBUTE_TABLE\tgfc_attribute_table\n \n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "4646cc33fd3841566a96a88b4023950284bd6ece", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -2147,14 +2147,31 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t      in_omp_workshare = true;\n \n \t      /* Fall through  */\n-\t      \n+\n+\t    case EXEC_OMP_DISTRIBUTE:\n+\t    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+\t    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_DISTRIBUTE_SIMD:\n \t    case EXEC_OMP_DO:\n \t    case EXEC_OMP_DO_SIMD:\n \t    case EXEC_OMP_SECTIONS:\n \t    case EXEC_OMP_SINGLE:\n \t    case EXEC_OMP_END_SINGLE:\n \t    case EXEC_OMP_SIMD:\n+\t    case EXEC_OMP_TARGET:\n+\t    case EXEC_OMP_TARGET_DATA:\n+\t    case EXEC_OMP_TARGET_TEAMS:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+\t    case EXEC_OMP_TARGET_UPDATE:\n \t    case EXEC_OMP_TASK:\n+\t    case EXEC_OMP_TEAMS:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n \n \t      /* Come to this label only from the\n \t\t EXEC_OMP_PARALLEL_* cases above.  */\n@@ -2163,28 +2180,28 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \n \t      if (co->ext.omp_clauses)\n \t\t{\n+\t\t  gfc_omp_namelist *n;\n+\t\t  static int list_types[]\n+\t\t    = { OMP_LIST_ALIGNED, OMP_LIST_LINEAR, OMP_LIST_DEPEND,\n+\t\t\tOMP_LIST_MAP, OMP_LIST_TO, OMP_LIST_FROM };\n+\t\t  size_t idx;\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->if_expr);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->final_expr);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->num_threads);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->chunk_size);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->safelen_expr);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->simdlen_expr);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->num_teams);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->device);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->thread_limit);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->dist_chunk_size);\n+\t\t  for (idx = 0;\n+\t\t       idx < sizeof (list_types) / sizeof (list_types[0]);\n+\t\t       idx++)\n+\t\t    for (n = co->ext.omp_clauses->lists[list_types[idx]];\n+\t\t\t n; n = n->next)\n+\t\t      WALK_SUBEXPR (n->expr);\n \t\t}\n-\t      {\n-\t\tgfc_omp_namelist *n;\n-\t\tfor (n = co->ext.omp_clauses->lists[OMP_LIST_ALIGNED];\n-\t\t     n; n = n->next)\n-\t\t  WALK_SUBEXPR (n->expr);\n-\t\tfor (n = co->ext.omp_clauses->lists[OMP_LIST_LINEAR];\n-\t\t     n; n = n->next)\n-\t\t  WALK_SUBEXPR (n->expr);\n-\t\tfor (n = co->ext.omp_clauses->lists[OMP_LIST_DEPEND_IN];\n-\t\t     n; n = n->next)\n-\t\t  WALK_SUBEXPR (n->expr);\n-\t\tfor (n = co->ext.omp_clauses->lists[OMP_LIST_DEPEND_OUT];\n-\t\t     n; n = n->next)\n-\t\t  WALK_SUBEXPR (n->expr);\n-\t      }\n \t      break;\n \t    default:\n \t      break;"}, {"sha": "a11ca3d704f0a1dd36f7bfbc770f51c0befc89c2", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -215,6 +215,24 @@ typedef enum\n   ST_OMP_TASKGROUP, ST_OMP_END_TASKGROUP, ST_OMP_SIMD, ST_OMP_END_SIMD,\n   ST_OMP_DO_SIMD, ST_OMP_END_DO_SIMD, ST_OMP_PARALLEL_DO_SIMD,\n   ST_OMP_END_PARALLEL_DO_SIMD, ST_OMP_DECLARE_SIMD, ST_OMP_DECLARE_REDUCTION,\n+  ST_OMP_TARGET, ST_OMP_END_TARGET, ST_OMP_TARGET_DATA, ST_OMP_END_TARGET_DATA,\n+  ST_OMP_TARGET_UPDATE, ST_OMP_DECLARE_TARGET,\n+  ST_OMP_TEAMS, ST_OMP_END_TEAMS, ST_OMP_DISTRIBUTE, ST_OMP_END_DISTRIBUTE,\n+  ST_OMP_DISTRIBUTE_SIMD, ST_OMP_END_DISTRIBUTE_SIMD,\n+  ST_OMP_DISTRIBUTE_PARALLEL_DO, ST_OMP_END_DISTRIBUTE_PARALLEL_DO,\n+  ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD, ST_OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD,\n+  ST_OMP_TARGET_TEAMS, ST_OMP_END_TARGET_TEAMS, ST_OMP_TEAMS_DISTRIBUTE,\n+  ST_OMP_END_TEAMS_DISTRIBUTE, ST_OMP_TEAMS_DISTRIBUTE_SIMD,\n+  ST_OMP_END_TEAMS_DISTRIBUTE_SIMD, ST_OMP_TARGET_TEAMS_DISTRIBUTE,\n+  ST_OMP_END_TARGET_TEAMS_DISTRIBUTE, ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD,\n+  ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD, ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+  ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+  ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+  ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+  ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+  ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+  ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+  ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n   ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n   ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE\n }\n@@ -821,6 +839,9 @@ typedef struct\n      !$OMP DECLARE REDUCTION.  */\n   unsigned omp_udr_artificial_var:1;\n \n+  /* Mentioned in OMP DECLARE TARGET.  */\n+  unsigned omp_declare_target:1;\n+\n   /* Attributes set by compiler extensions (!GCC$ ATTRIBUTES).  */\n   unsigned ext_attr:EXT_ATTR_NUM;\n \n@@ -1060,14 +1081,36 @@ typedef enum\n }\n gfc_omp_reduction_op;\n \n+typedef enum\n+{\n+  OMP_DEPEND_IN,\n+  OMP_DEPEND_OUT,\n+  OMP_DEPEND_INOUT\n+}\n+gfc_omp_depend_op;\n+\n+typedef enum\n+{\n+  OMP_MAP_ALLOC,\n+  OMP_MAP_TO,\n+  OMP_MAP_FROM,\n+  OMP_MAP_TOFROM\n+}\n+gfc_omp_map_op;\n+\n /* For use in OpenMP clauses in case we need extra information\n    (aligned clause alignment, linear clause step, etc.).  */\n \n typedef struct gfc_omp_namelist\n {\n   struct gfc_symbol *sym;\n   struct gfc_expr *expr;\n-  gfc_omp_reduction_op rop;\n+  union\n+    {\n+      gfc_omp_reduction_op reduction_op;\n+      gfc_omp_depend_op depend_op;\n+      gfc_omp_map_op map_op;\n+    } u;\n   struct gfc_omp_udr *udr;\n   struct gfc_omp_namelist *next;\n }\n@@ -1086,8 +1129,10 @@ enum\n   OMP_LIST_UNIFORM,\n   OMP_LIST_ALIGNED,\n   OMP_LIST_LINEAR,\n-  OMP_LIST_DEPEND_IN,\n-  OMP_LIST_DEPEND_OUT,\n+  OMP_LIST_DEPEND,\n+  OMP_LIST_MAP,\n+  OMP_LIST_TO,\n+  OMP_LIST_FROM,\n   OMP_LIST_REDUCTION,\n   OMP_LIST_NUM\n };\n@@ -1147,6 +1192,11 @@ typedef struct gfc_omp_clauses\n   enum gfc_omp_proc_bind_kind proc_bind;\n   struct gfc_expr *safelen_expr;\n   struct gfc_expr *simdlen_expr;\n+  struct gfc_expr *num_teams;\n+  struct gfc_expr *device;\n+  struct gfc_expr *thread_limit;\n+  enum gfc_omp_sched_kind dist_sched_kind;\n+  struct gfc_expr *dist_chunk_size;\n }\n gfc_omp_clauses;\n \n@@ -1387,7 +1437,7 @@ struct gfc_undo_change_set\n typedef struct gfc_common_head\n {\n   locus where;\n-  char use_assoc, saved, threadprivate;\n+  char use_assoc, saved, threadprivate, omp_declare_target;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   struct gfc_symbol *head;\n   const char* binding_label;\n@@ -2217,7 +2267,17 @@ typedef enum\n   EXEC_OMP_END_SINGLE, EXEC_OMP_TASK, EXEC_OMP_TASKWAIT,\n   EXEC_OMP_TASKYIELD, EXEC_OMP_CANCEL, EXEC_OMP_CANCELLATION_POINT,\n   EXEC_OMP_TASKGROUP, EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD,\n-  EXEC_OMP_PARALLEL_DO_SIMD\n+  EXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_TARGET, EXEC_OMP_TARGET_DATA,\n+  EXEC_OMP_TEAMS, EXEC_OMP_DISTRIBUTE, EXEC_OMP_DISTRIBUTE_SIMD,\n+  EXEC_OMP_DISTRIBUTE_PARALLEL_DO, EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD,\n+  EXEC_OMP_TARGET_TEAMS, EXEC_OMP_TEAMS_DISTRIBUTE,\n+  EXEC_OMP_TEAMS_DISTRIBUTE_SIMD, EXEC_OMP_TARGET_TEAMS_DISTRIBUTE,\n+  EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD,\n+  EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+  EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+  EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+  EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+  EXEC_OMP_TARGET_UPDATE\n }\n gfc_exec_op;\n \n@@ -2682,6 +2742,7 @@ bool gfc_add_protected (symbol_attribute *, const char *, locus *);\n bool gfc_add_result (symbol_attribute *, const char *, locus *);\n bool gfc_add_save (symbol_attribute *, save_state, const char *, locus *);\n bool gfc_add_threadprivate (symbol_attribute *, const char *, locus *);\n+bool gfc_add_omp_declare_target (symbol_attribute *, const char *, locus *);\n bool gfc_add_saved_common (symbol_attribute *, locus *);\n bool gfc_add_target (symbol_attribute *, locus *);\n bool gfc_add_dummy (symbol_attribute *, const char *, locus *);"}, {"sha": "d07db11ef30e7caa0f91d71165d4f111ed0dbf50", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -131,6 +131,11 @@ match gfc_match_omp_cancellation_point (void);\n match gfc_match_omp_critical (void);\n match gfc_match_omp_declare_reduction (void);\n match gfc_match_omp_declare_simd (void);\n+match gfc_match_omp_declare_target (void);\n+match gfc_match_omp_distribute (void);\n+match gfc_match_omp_distribute_parallel_do (void);\n+match gfc_match_omp_distribute_parallel_do_simd (void);\n+match gfc_match_omp_distribute_simd (void);\n match gfc_match_omp_do (void);\n match gfc_match_omp_do_simd (void);\n match gfc_match_omp_flush (void);\n@@ -144,10 +149,23 @@ match gfc_match_omp_parallel_workshare (void);\n match gfc_match_omp_sections (void);\n match gfc_match_omp_simd (void);\n match gfc_match_omp_single (void);\n+match gfc_match_omp_target (void);\n+match gfc_match_omp_target_data (void);\n+match gfc_match_omp_target_teams (void);\n+match gfc_match_omp_target_teams_distribute (void);\n+match gfc_match_omp_target_teams_distribute_parallel_do (void);\n+match gfc_match_omp_target_teams_distribute_parallel_do_simd (void);\n+match gfc_match_omp_target_teams_distribute_simd (void);\n+match gfc_match_omp_target_update (void);\n match gfc_match_omp_task (void);\n match gfc_match_omp_taskgroup (void);\n match gfc_match_omp_taskwait (void);\n match gfc_match_omp_taskyield (void);\n+match gfc_match_omp_teams (void);\n+match gfc_match_omp_teams_distribute (void);\n+match gfc_match_omp_teams_distribute_parallel_do (void);\n+match gfc_match_omp_teams_distribute_parallel_do_simd (void);\n+match gfc_match_omp_teams_distribute_simd (void);\n match gfc_match_omp_threadprivate (void);\n match gfc_match_omp_workshare (void);\n match gfc_match_omp_end_nowait (void);"}, {"sha": "bdd9961652d5783ae10849012cc9ae5eb84de104", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1877,7 +1877,7 @@ typedef enum\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n   AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,\n-  AB_IMPLICIT_PURE, AB_ARTIFICIAL, AB_UNLIMITED_POLY\n+  AB_IMPLICIT_PURE, AB_ARTIFICIAL, AB_UNLIMITED_POLY, AB_OMP_DECLARE_TARGET\n }\n ab_attribute;\n \n@@ -1932,6 +1932,7 @@ static const mstring attr_bits[] =\n     minit (\"CLASS_POINTER\", AB_CLASS_POINTER),\n     minit (\"IMPLICIT_PURE\", AB_IMPLICIT_PURE),\n     minit (\"UNLIMITED_POLY\", AB_UNLIMITED_POLY),\n+    minit (\"OMP_DECLARE_TARGET\", AB_OMP_DECLARE_TARGET),\n     minit (NULL, -1)\n };\n \n@@ -2110,6 +2111,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_VTYPE, attr_bits);\n       if (attr->vtab)\n \tMIO_NAME (ab_attribute) (AB_VTAB, attr_bits);\n+      if (attr->omp_declare_target)\n+\tMIO_NAME (ab_attribute) (AB_OMP_DECLARE_TARGET, attr_bits);\n \n       mio_rparen ();\n \n@@ -2273,6 +2276,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_VTAB:\n \t      attr->vtab = 1;\n \t      break;\n+\t    case AB_OMP_DECLARE_TARGET:\n+\t      attr->omp_declare_target = 1;\n+\t      break;\n \t    }\n \t}\n     }"}, {"sha": "266ac3d9a9d4e3dc53d21df98e60ed0ea42642d9", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 635, "deletions": 177, "changes": 812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -72,6 +72,10 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n   gfc_free_expr (c->chunk_size);\n   gfc_free_expr (c->safelen_expr);\n   gfc_free_expr (c->simdlen_expr);\n+  gfc_free_expr (c->num_teams);\n+  gfc_free_expr (c->device);\n+  gfc_free_expr (c->thread_limit);\n+  gfc_free_expr (c->dist_chunk_size);\n   for (i = 0; i < OMP_LIST_NUM; i++)\n     gfc_free_omp_namelist (c->lists[i]);\n   free (c);\n@@ -283,38 +287,45 @@ gfc_match_omp_variable_list (const char *str, gfc_omp_namelist **list,\n   return MATCH_ERROR;\n }\n \n-#define OMP_CLAUSE_PRIVATE\t(1 << 0)\n-#define OMP_CLAUSE_FIRSTPRIVATE\t(1 << 1)\n-#define OMP_CLAUSE_LASTPRIVATE\t(1 << 2)\n-#define OMP_CLAUSE_COPYPRIVATE\t(1 << 3)\n-#define OMP_CLAUSE_SHARED\t(1 << 4)\n-#define OMP_CLAUSE_COPYIN\t(1 << 5)\n-#define OMP_CLAUSE_REDUCTION\t(1 << 6)\n-#define OMP_CLAUSE_IF\t\t(1 << 7)\n-#define OMP_CLAUSE_NUM_THREADS\t(1 << 8)\n-#define OMP_CLAUSE_SCHEDULE\t(1 << 9)\n-#define OMP_CLAUSE_DEFAULT\t(1 << 10)\n-#define OMP_CLAUSE_ORDERED\t(1 << 11)\n-#define OMP_CLAUSE_COLLAPSE\t(1 << 12)\n-#define OMP_CLAUSE_UNTIED\t(1 << 13)\n-#define OMP_CLAUSE_FINAL\t(1 << 14)\n-#define OMP_CLAUSE_MERGEABLE\t(1 << 15)\n-#define OMP_CLAUSE_ALIGNED\t(1 << 16)\n-#define OMP_CLAUSE_DEPEND\t(1 << 17)\n-#define OMP_CLAUSE_INBRANCH\t(1 << 18)\n-#define OMP_CLAUSE_LINEAR\t(1 << 19)\n-#define OMP_CLAUSE_NOTINBRANCH\t(1 << 20)\n-#define OMP_CLAUSE_PROC_BIND\t(1 << 21)\n-#define OMP_CLAUSE_SAFELEN\t(1 << 22)\n-#define OMP_CLAUSE_SIMDLEN\t(1 << 23)\n-#define OMP_CLAUSE_UNIFORM\t(1 << 24)\n+#define OMP_CLAUSE_PRIVATE\t(1U << 0)\n+#define OMP_CLAUSE_FIRSTPRIVATE\t(1U << 1)\n+#define OMP_CLAUSE_LASTPRIVATE\t(1U << 2)\n+#define OMP_CLAUSE_COPYPRIVATE\t(1U << 3)\n+#define OMP_CLAUSE_SHARED\t(1U << 4)\n+#define OMP_CLAUSE_COPYIN\t(1U << 5)\n+#define OMP_CLAUSE_REDUCTION\t(1U << 6)\n+#define OMP_CLAUSE_IF\t\t(1U << 7)\n+#define OMP_CLAUSE_NUM_THREADS\t(1U << 8)\n+#define OMP_CLAUSE_SCHEDULE\t(1U << 9)\n+#define OMP_CLAUSE_DEFAULT\t(1U << 10)\n+#define OMP_CLAUSE_ORDERED\t(1U << 11)\n+#define OMP_CLAUSE_COLLAPSE\t(1U << 12)\n+#define OMP_CLAUSE_UNTIED\t(1U << 13)\n+#define OMP_CLAUSE_FINAL\t(1U << 14)\n+#define OMP_CLAUSE_MERGEABLE\t(1U << 15)\n+#define OMP_CLAUSE_ALIGNED\t(1U << 16)\n+#define OMP_CLAUSE_DEPEND\t(1U << 17)\n+#define OMP_CLAUSE_INBRANCH\t(1U << 18)\n+#define OMP_CLAUSE_LINEAR\t(1U << 19)\n+#define OMP_CLAUSE_NOTINBRANCH\t(1U << 20)\n+#define OMP_CLAUSE_PROC_BIND\t(1U << 21)\n+#define OMP_CLAUSE_SAFELEN\t(1U << 22)\n+#define OMP_CLAUSE_SIMDLEN\t(1U << 23)\n+#define OMP_CLAUSE_UNIFORM\t(1U << 24)\n+#define OMP_CLAUSE_DEVICE\t(1U << 25)\n+#define OMP_CLAUSE_MAP\t\t(1U << 26)\n+#define OMP_CLAUSE_TO\t\t(1U << 27)\n+#define OMP_CLAUSE_FROM\t\t(1U << 28)\n+#define OMP_CLAUSE_NUM_TEAMS\t(1U << 29)\n+#define OMP_CLAUSE_THREAD_LIMIT\t(1U << 30)\n+#define OMP_CLAUSE_DIST_SCHEDULE\t(1U << 31)\n \n /* Match OpenMP directive clauses. MASK is a bitmask of\n    clauses that are allowed for a particular directive.  */\n \n static match\n-gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n-\t\t       bool needs_space = true)\n+gfc_match_omp_clauses (gfc_omp_clauses **cp, unsigned int mask,\n+\t\t       bool first = true, bool needs_space = true)\n {\n   gfc_omp_clauses *c = gfc_get_omp_clauses ();\n   locus old_loc;\n@@ -474,7 +485,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n \t      else\n \t\tfor (n = *head; n; n = n->next)\n \t\t  {\n-\t\t    n->rop = rop;\n+\t\t    n->u.reduction_op = rop;\n \t\t    n->udr = udr;\n \t\t  }\n \t      continue;\n@@ -570,13 +581,13 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n \t      continue;\n \t    }\n \t}\n-      if ((mask & OMP_CLAUSE_INBRANCH) && !c->inbranch\n+      if ((mask & OMP_CLAUSE_INBRANCH) && !c->inbranch && !c->notinbranch\n \t  && gfc_match (\"inbranch\") == MATCH_YES)\n \t{\n \t  c->inbranch = needs_space = true;\n \t  continue;\n \t}\n-      if ((mask & OMP_CLAUSE_NOTINBRANCH) && !c->notinbranch\n+      if ((mask & OMP_CLAUSE_NOTINBRANCH) && !c->notinbranch && !c->inbranch\n \t  && gfc_match (\"notinbranch\") == MATCH_YES)\n \t{\n \t  c->notinbranch = needs_space = true;\n@@ -662,21 +673,94 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n \t  continue;\n \t}\n       if ((mask & OMP_CLAUSE_DEPEND)\n-\t  && gfc_match_omp_variable_list (\"depend ( in : \",\n-\t\t\t\t\t  &c->lists[OMP_LIST_DEPEND_IN], false,\n-\t\t\t\t\t  NULL, NULL, true)\n-\t     == MATCH_YES)\n+\t  && gfc_match (\"depend ( \") == MATCH_YES)\n+\t{\n+\t  match m = MATCH_YES;\n+\t  gfc_omp_depend_op depend_op = OMP_DEPEND_OUT;\n+\t  if (gfc_match (\"inout\") == MATCH_YES)\n+\t    depend_op = OMP_DEPEND_INOUT;\n+\t  else if (gfc_match (\"in\") == MATCH_YES)\n+\t    depend_op = OMP_DEPEND_IN;\n+\t  else if (gfc_match (\"out\") == MATCH_YES)\n+\t    depend_op = OMP_DEPEND_OUT;\n+\t  else\n+\t    m = MATCH_NO;\n+\t  head = NULL;\n+\t  if (m == MATCH_YES\n+\t      && gfc_match_omp_variable_list (\" : \",\n+\t\t\t\t\t      &c->lists[OMP_LIST_DEPEND],\n+\t\t\t\t\t      false, NULL, &head, true)\n+\t\t == MATCH_YES)\n+\t    {\n+\t      gfc_omp_namelist *n;\n+\t      for (n = *head; n; n = n->next)\n+\t\tn->u.depend_op = depend_op;\n+\t      continue;\n+\t    }\n+\t  else\n+\t    gfc_current_locus = old_loc;\n+\t}\n+      if ((mask & OMP_CLAUSE_DIST_SCHEDULE)\n+\t  && c->dist_sched_kind == OMP_SCHED_NONE\n+\t  && gfc_match (\"dist_schedule ( static\") == MATCH_YES)\n+\t{\n+\t  match m = MATCH_NO;\n+\t  c->dist_sched_kind = OMP_SCHED_STATIC;\n+\t  m = gfc_match (\" , %e )\", &c->dist_chunk_size);\n+\t  if (m != MATCH_YES)\n+\t    m = gfc_match_char (')');\n+\t  if (m != MATCH_YES)\n+\t    {\n+\t      c->dist_sched_kind = OMP_SCHED_NONE;\n+\t      gfc_current_locus = old_loc;\n+\t    }\n+\t  else\n+\t    continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_NUM_TEAMS) && c->num_teams == NULL\n+\t  && gfc_match (\"num_teams ( %e )\", &c->num_teams) == MATCH_YES)\n \tcontinue;\n-      if ((mask & OMP_CLAUSE_DEPEND)\n-\t  && gfc_match_omp_variable_list (\"depend ( out : \",\n-\t\t\t\t\t  &c->lists[OMP_LIST_DEPEND_OUT], false,\n-\t\t\t\t\t  NULL, NULL, true)\n+      if ((mask & OMP_CLAUSE_DEVICE) && c->device == NULL\n+\t  && gfc_match (\"device ( %e )\", &c->device) == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_THREAD_LIMIT) && c->thread_limit == NULL\n+\t  && gfc_match (\"thread_limit ( %e )\", &c->thread_limit) == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_MAP)\n+\t  && gfc_match (\"map ( \") == MATCH_YES)\n+\t{\n+\t  gfc_omp_map_op map_op = OMP_MAP_TOFROM;\n+\t  if (gfc_match (\"alloc : \") == MATCH_YES)\n+\t    map_op = OMP_MAP_ALLOC;\n+\t  else if (gfc_match (\"tofrom : \") == MATCH_YES)\n+\t    map_op = OMP_MAP_TOFROM;\n+\t  else if (gfc_match (\"to : \") == MATCH_YES)\n+\t    map_op = OMP_MAP_TO;\n+\t  else if (gfc_match (\"from : \") == MATCH_YES)\n+\t    map_op = OMP_MAP_FROM;\n+\t  head = NULL;\n+\t  if (gfc_match_omp_variable_list (\"\", &c->lists[OMP_LIST_MAP],\n+\t\t\t\t\t   false, NULL, &head, true)\n+\t      == MATCH_YES)\n+\t    {\n+\t      gfc_omp_namelist *n;\n+\t      for (n = *head; n; n = n->next)\n+\t\tn->u.map_op = map_op;\n+\t      continue;\n+\t    }\n+\t  else\n+\t    gfc_current_locus = old_loc;\n+\t}\n+      if ((mask & OMP_CLAUSE_TO)\n+\t  && gfc_match_omp_variable_list (\"to (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_TO], false,\n+\t\t\t\t\t  NULL, &head, true)\n \t     == MATCH_YES)\n \tcontinue;\n-      if ((mask & OMP_CLAUSE_DEPEND)\n-\t  && gfc_match_omp_variable_list (\"depend ( inout : \",\n-\t\t\t\t\t  &c->lists[OMP_LIST_DEPEND_OUT], false,\n-\t\t\t\t\t  NULL, NULL, true)\n+      if ((mask & OMP_CLAUSE_FROM)\n+\t  && gfc_match_omp_variable_list (\"from (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_FROM], false,\n+\t\t\t\t\t  NULL, &head, true)\n \t     == MATCH_YES)\n \tcontinue;\n \n@@ -699,7 +783,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n    | OMP_CLAUSE_NUM_THREADS | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_PROC_BIND)\n #define OMP_DECLARE_SIMD_CLAUSES \\\n   (OMP_CLAUSE_SIMDLEN | OMP_CLAUSE_LINEAR | OMP_CLAUSE_UNIFORM\t\t\\\n-   | OMP_CLAUSE_ALIGNED)\n+   | OMP_CLAUSE_ALIGNED | OMP_CLAUSE_INBRANCH | OMP_CLAUSE_NOTINBRANCH)\n #define OMP_DO_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION\t\t\t\\\n@@ -715,100 +799,97 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n    | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_UNTIED\t\t\\\n    | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE | OMP_CLAUSE_DEPEND)\n-\n-match\n-gfc_match_omp_parallel (void)\n-{\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_PARALLEL_CLAUSES) != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_PARALLEL;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n-}\n+#define OMP_TARGET_CLAUSES \\\n+  (OMP_CLAUSE_DEVICE | OMP_CLAUSE_MAP | OMP_CLAUSE_IF)\n+#define OMP_TARGET_DATA_CLAUSES \\\n+  (OMP_CLAUSE_DEVICE | OMP_CLAUSE_MAP | OMP_CLAUSE_IF)\n+#define OMP_TARGET_UPDATE_CLAUSES \\\n+  (OMP_CLAUSE_DEVICE | OMP_CLAUSE_IF | OMP_CLAUSE_TO | OMP_CLAUSE_FROM)\n+#define OMP_TEAMS_CLAUSES \\\n+  (OMP_CLAUSE_NUM_TEAMS | OMP_CLAUSE_THREAD_LIMIT | OMP_CLAUSE_DEFAULT\t\\\n+   | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n+   | OMP_CLAUSE_REDUCTION)\n+#define OMP_DISTRIBUTE_CLAUSES \\\n+  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_COLLAPSE\t\\\n+   | OMP_CLAUSE_DIST_SCHEDULE)\n \n \n-match\n-gfc_match_omp_task (void)\n+static match\n+match_omp (gfc_exec_op op, unsigned int mask)\n {\n   gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_TASK_CLAUSES) != MATCH_YES)\n+  if (gfc_match_omp_clauses (&c, mask) != MATCH_YES)\n     return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_TASK;\n+  new_st.op = op;\n   new_st.ext.omp_clauses = c;\n   return MATCH_YES;\n }\n \n \n match\n-gfc_match_omp_taskwait (void)\n+gfc_match_omp_critical (void)\n {\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n+\n+  if (gfc_match (\" ( %n )\", n) != MATCH_YES)\n+    n[0] = '\\0';\n   if (gfc_match_omp_eos () != MATCH_YES)\n     {\n-      gfc_error (\"Unexpected junk after TASKWAIT clause at %C\");\n+      gfc_error (\"Unexpected junk after $OMP CRITICAL statement at %C\");\n       return MATCH_ERROR;\n     }\n-  new_st.op = EXEC_OMP_TASKWAIT;\n-  new_st.ext.omp_clauses = NULL;\n+  new_st.op = EXEC_OMP_CRITICAL;\n+  new_st.ext.omp_name = n[0] ? xstrdup (n) : NULL;\n   return MATCH_YES;\n }\n \n \n match\n-gfc_match_omp_taskyield (void)\n+gfc_match_omp_distribute (void)\n {\n-  if (gfc_match_omp_eos () != MATCH_YES)\n-    {\n-      gfc_error (\"Unexpected junk after TASKYIELD clause at %C\");\n-      return MATCH_ERROR;\n-    }\n-  new_st.op = EXEC_OMP_TASKYIELD;\n-  new_st.ext.omp_clauses = NULL;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_DISTRIBUTE, OMP_DISTRIBUTE_CLAUSES);\n }\n \n \n match\n-gfc_match_omp_critical (void)\n+gfc_match_omp_distribute_parallel_do (void)\n {\n-  char n[GFC_MAX_SYMBOL_LEN+1];\n+  return match_omp (EXEC_OMP_DISTRIBUTE_PARALLEL_DO,\n+\t\t    OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n+\t\t    | OMP_DO_CLAUSES);\n+}\n \n-  if (gfc_match (\" ( %n )\", n) != MATCH_YES)\n-    n[0] = '\\0';\n-  if (gfc_match_omp_eos () != MATCH_YES)\n-    {\n-      gfc_error (\"Unexpected junk after $OMP CRITICAL statement at %C\");\n-      return MATCH_ERROR;\n-    }\n-  new_st.op = EXEC_OMP_CRITICAL;\n-  new_st.ext.omp_name = n[0] ? xstrdup (n) : NULL;\n-  return MATCH_YES;\n+\n+match\n+gfc_match_omp_distribute_parallel_do_simd (void)\n+{\n+  return match_omp (EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD,\n+\t\t    (OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n+\t\t     | OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n+\t\t    & ~OMP_CLAUSE_ORDERED);\n+}\n+\n+\n+match\n+gfc_match_omp_distribute_simd (void)\n+{\n+  return match_omp (EXEC_OMP_DISTRIBUTE_SIMD,\n+\t\t    OMP_DISTRIBUTE_CLAUSES | OMP_SIMD_CLAUSES);\n }\n \n \n match\n gfc_match_omp_do (void)\n {\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_DO_CLAUSES) != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_DO;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_DO, OMP_DO_CLAUSES);\n }\n \n \n match\n gfc_match_omp_do_simd (void)\n {\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, ((OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n-\t\t\t\t  & ~OMP_CLAUSE_ORDERED))\n-      != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_DO_SIMD;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_DO_SIMD, ((OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n+\t\t\t\t       & ~OMP_CLAUSE_ORDERED));\n }\n \n \n@@ -829,18 +910,6 @@ gfc_match_omp_flush (void)\n }\n \n \n-match\n-gfc_match_omp_simd (void)\n-{\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_SIMD_CLAUSES) != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_SIMD;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n-}\n-\n-\n match\n gfc_match_omp_declare_simd (void)\n {\n@@ -1235,13 +1304,116 @@ gfc_match_omp_declare_reduction (void)\n   if (end_loc_set)\n     {\n       gfc_current_locus = end_loc;\n+      if (gfc_match_omp_eos () != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Unexpected junk after !$OMP DECLARE REDUCTION at %C\");\n+\t  gfc_current_locus = where;\n+\t  return MATCH_ERROR;\n+\t}\n+\n       return MATCH_YES;\n     }\n   gfc_clear_error ();\n   return MATCH_ERROR;\n }\n \n \n+match\n+gfc_match_omp_declare_target (void)\n+{\n+  locus old_loc;\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n+  gfc_symbol *sym;\n+  match m;\n+  gfc_symtree *st;\n+\n+  old_loc = gfc_current_locus;\n+\n+  m = gfc_match (\" (\");\n+\n+  if (gfc_current_ns->proc_name\n+      && gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY\n+      && m == MATCH_YES)\n+    {\n+      gfc_error (\"Only the !$OMP DECLARE TARGET form without \"\n+\t\t \"list is allowed in interface block at %C\");\n+      goto cleanup;\n+    }\n+\n+  if (m == MATCH_NO\n+      && gfc_current_ns->proc_name\n+      && gfc_match_omp_eos () == MATCH_YES)\n+    {\n+      if (!gfc_add_omp_declare_target (&gfc_current_ns->proc_name->attr,\n+\t\t\t\t       gfc_current_ns->proc_name->name,\n+\t\t\t\t       &old_loc))\n+\tgoto cleanup;\n+      return MATCH_YES;\n+    }\n+\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  for (;;)\n+    {\n+      m = gfc_match_symbol (&sym, 0);\n+      switch (m)\n+\t{\n+\tcase MATCH_YES:\n+\t  if (sym->attr.in_common)\n+\t    gfc_error_now (\"OMP DECLARE TARGET on a variable at %C is an \"\n+\t\t\t   \"element of a COMMON block\");\n+\t  else if (!gfc_add_omp_declare_target (&sym->attr, sym->name,\n+\t\t\t\t\t\t&sym->declared_at))\n+\t    goto cleanup;\n+\t  goto next_item;\n+\tcase MATCH_NO:\n+\t  break;\n+\tcase MATCH_ERROR:\n+\t  goto cleanup;\n+\t}\n+\n+      m = gfc_match (\" / %n /\", n);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO || n[0] == '\\0')\n+\tgoto syntax;\n+\n+      st = gfc_find_symtree (gfc_current_ns->common_root, n);\n+      if (st == NULL)\n+\t{\n+\t  gfc_error (\"COMMON block /%s/ not found at %C\", n);\n+\t  goto cleanup;\n+\t}\n+      st->n.common->omp_declare_target = 1;\n+      for (sym = st->n.common->head; sym; sym = sym->common_next)\n+\tif (!gfc_add_omp_declare_target (&sym->attr, sym->name,\n+\t\t\t\t\t &sym->declared_at))\n+\t  goto cleanup;\n+\n+    next_item:\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after !$OMP DECLARE TARGET at %C\");\n+      goto cleanup;\n+    }\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in !$OMP DECLARE TARGET list at %C\");\n+\n+cleanup:\n+  gfc_current_locus = old_loc;\n+  return MATCH_ERROR;\n+}\n+\n+\n match\n gfc_match_omp_threadprivate (void)\n {\n@@ -1299,6 +1471,12 @@ gfc_match_omp_threadprivate (void)\n \tgoto syntax;\n     }\n \n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after OMP THREADPRIVATE at %C\");\n+      goto cleanup;\n+    }\n+\n   return MATCH_YES;\n \n syntax:\n@@ -1310,83 +1488,213 @@ gfc_match_omp_threadprivate (void)\n }\n \n \n+match\n+gfc_match_omp_parallel (void)\n+{\n+  return match_omp (EXEC_OMP_PARALLEL, OMP_PARALLEL_CLAUSES);\n+}\n+\n+\n match\n gfc_match_omp_parallel_do (void)\n {\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES)\n-      != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_PARALLEL_DO;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_PARALLEL_DO,\n+\t\t    OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES);\n }\n \n \n match\n gfc_match_omp_parallel_do_simd (void)\n {\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, (OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES\n-\t\t\t\t  | OMP_SIMD_CLAUSES) & ~OMP_CLAUSE_ORDERED)\n-      != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_PARALLEL_DO_SIMD;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_PARALLEL_DO_SIMD,\n+\t\t    (OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n+\t\t    & ~OMP_CLAUSE_ORDERED);\n }\n \n \n match\n gfc_match_omp_parallel_sections (void)\n {\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_PARALLEL_CLAUSES | OMP_SECTIONS_CLAUSES)\n-      != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_PARALLEL_SECTIONS;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_PARALLEL_SECTIONS,\n+\t\t    OMP_PARALLEL_CLAUSES | OMP_SECTIONS_CLAUSES);\n }\n \n \n match\n gfc_match_omp_parallel_workshare (void)\n {\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_PARALLEL_CLAUSES) != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_PARALLEL_WORKSHARE;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_PARALLEL_WORKSHARE, OMP_PARALLEL_CLAUSES);\n }\n \n \n match\n gfc_match_omp_sections (void)\n {\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_SECTIONS_CLAUSES) != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_SECTIONS;\n-  new_st.ext.omp_clauses = c;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_SECTIONS, OMP_SECTIONS_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_simd (void)\n+{\n+  return match_omp (EXEC_OMP_SIMD, OMP_SIMD_CLAUSES);\n }\n \n \n match\n gfc_match_omp_single (void)\n {\n-  gfc_omp_clauses *c;\n-  if (gfc_match_omp_clauses (&c, OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE)\n-      != MATCH_YES)\n-    return MATCH_ERROR;\n-  new_st.op = EXEC_OMP_SINGLE;\n-  new_st.ext.omp_clauses = c;\n+  return match_omp (EXEC_OMP_SINGLE,\n+\t\t    OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE);\n+}\n+\n+\n+match\n+gfc_match_omp_task (void)\n+{\n+  return match_omp (EXEC_OMP_TASK, OMP_TASK_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_taskwait (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after TASKWAIT clause at %C\");\n+      return MATCH_ERROR;\n+    }\n+  new_st.op = EXEC_OMP_TASKWAIT;\n+  new_st.ext.omp_clauses = NULL;\n   return MATCH_YES;\n }\n \n \n+match\n+gfc_match_omp_taskyield (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after TASKYIELD clause at %C\");\n+      return MATCH_ERROR;\n+    }\n+  new_st.op = EXEC_OMP_TASKYIELD;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_omp_target (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET, OMP_TARGET_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_target_data (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_DATA, OMP_TARGET_DATA_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_target_teams (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_TEAMS,\n+\t\t    OMP_TARGET_CLAUSES | OMP_TEAMS_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_target_teams_distribute (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_TEAMS_DISTRIBUTE,\n+\t\t    OMP_TARGET_CLAUSES | OMP_TEAMS_CLAUSES\n+\t\t    | OMP_DISTRIBUTE_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_target_teams_distribute_parallel_do (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+\t\t    OMP_TARGET_CLAUSES | OMP_TEAMS_CLAUSES\n+\t\t    | OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n+\t\t    | OMP_DO_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_target_teams_distribute_parallel_do_simd (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+\t\t    (OMP_TARGET_CLAUSES | OMP_TEAMS_CLAUSES\n+\t\t     | OMP_DISTRIBUTE_CLAUSES | OMP_PARALLEL_CLAUSES\n+\t\t     | OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n+\t\t    & ~OMP_CLAUSE_ORDERED);\n+}\n+\n+\n+match\n+gfc_match_omp_target_teams_distribute_simd (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD,\n+\t\t    OMP_TARGET_CLAUSES | OMP_TEAMS_CLAUSES\n+\t\t    | OMP_DISTRIBUTE_CLAUSES | OMP_SIMD_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_target_update (void)\n+{\n+  return match_omp (EXEC_OMP_TARGET_UPDATE, OMP_TARGET_UPDATE_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_teams (void)\n+{\n+  return match_omp (EXEC_OMP_TEAMS, OMP_TEAMS_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_teams_distribute (void)\n+{\n+  return match_omp (EXEC_OMP_TEAMS_DISTRIBUTE,\n+\t\t    OMP_TEAMS_CLAUSES | OMP_DISTRIBUTE_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_teams_distribute_parallel_do (void)\n+{\n+  return match_omp (EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO,\n+\t\t    OMP_TEAMS_CLAUSES | OMP_DISTRIBUTE_CLAUSES\n+\t\t    | OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES);\n+}\n+\n+\n+match\n+gfc_match_omp_teams_distribute_parallel_do_simd (void)\n+{\n+  return match_omp (EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n+\t\t    (OMP_TEAMS_CLAUSES | OMP_DISTRIBUTE_CLAUSES\n+\t\t     | OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES\n+\t\t     | OMP_SIMD_CLAUSES) & ~OMP_CLAUSE_ORDERED);\n+}\n+\n+\n+match\n+gfc_match_omp_teams_distribute_simd (void)\n+{\n+  return match_omp (EXEC_OMP_TEAMS_DISTRIBUTE_SIMD,\n+\t\t    OMP_TEAMS_CLAUSES | OMP_DISTRIBUTE_CLAUSES\n+\t\t    | OMP_SIMD_CLAUSES);\n+}\n+\n+\n match\n gfc_match_omp_workshare (void)\n {\n@@ -1602,8 +1910,8 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n   int list;\n   static const char *clause_names[]\n     = { \"PRIVATE\", \"FIRSTPRIVATE\", \"LASTPRIVATE\", \"COPYPRIVATE\", \"SHARED\",\n-\t\"COPYIN\", \"UNIFORM\", \"ALIGNED\", \"LINEAR\", \"DEPEND\", \"DEPEND\",\n-\t\"REDUCTION\" };\n+\t\"COPYIN\", \"UNIFORM\", \"ALIGNED\", \"LINEAR\", \"DEPEND\", \"MAP\",\n+\t\"TO\", \"FROM\", \"REDUCTION\" };\n \n   if (omp_clauses == NULL)\n     return;\n@@ -1692,8 +2000,10 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n     if (list != OMP_LIST_FIRSTPRIVATE\n \t&& list != OMP_LIST_LASTPRIVATE\n \t&& list != OMP_LIST_ALIGNED\n-\t&& list != OMP_LIST_DEPEND_IN\n-\t&& list != OMP_LIST_DEPEND_OUT)\n+\t&& list != OMP_LIST_DEPEND\n+\t&& list != OMP_LIST_MAP\n+\t&& list != OMP_LIST_FROM\n+\t&& list != OMP_LIST_TO)\n       for (n = omp_clauses->lists[list]; n; n = n->next)\n \t{\n \t  if (n->sym->mark)\n@@ -1745,6 +2055,20 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \tn->sym->mark = 1;\n     }\n \n+  for (n = omp_clauses->lists[OMP_LIST_TO]; n; n = n->next)\n+    n->sym->mark = 0;\n+  for (n = omp_clauses->lists[OMP_LIST_FROM]; n; n = n->next)\n+    if (n->expr == NULL)\n+      n->sym->mark = 1;\n+  for (n = omp_clauses->lists[OMP_LIST_TO]; n; n = n->next)\n+    {\n+      if (n->expr == NULL && n->sym->mark)\n+\tgfc_error (\"Symbol '%s' present on both FROM and TO clauses at %L\",\n+\t\t   n->sym->name, where);\n+      else\n+\tn->sym->mark = 1;\n+    }\n+\n   for (list = 0; list < OMP_LIST_NUM; list++)\n     if ((n = omp_clauses->lists[list]) != NULL)\n       {\n@@ -1819,8 +2143,10 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t  }\n \t      }\n \t    break;\n-\t  case OMP_LIST_DEPEND_IN:\n-\t  case OMP_LIST_DEPEND_OUT:\n+\t  case OMP_LIST_DEPEND:\n+\t  case OMP_LIST_MAP:\n+\t  case OMP_LIST_TO:\n+\t  case OMP_LIST_FROM:\n \t    for (; n != NULL; n = n->next)\n \t      if (n->expr)\n \t\t{\n@@ -1829,11 +2155,11 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t      || n->expr->ref == NULL\n \t\t      || n->expr->ref->next\n \t\t      || n->expr->ref->type != REF_ARRAY)\n-\t\t    gfc_error (\"'%s' in DEPEND clause at %L is not a proper \"\n-\t\t\t       \"array section\", n->sym->name, where);\n+\t\t    gfc_error (\"'%s' in %s clause at %L is not a proper \"\n+\t\t\t       \"array section\", n->sym->name, name, where);\n \t\t  else if (n->expr->ref->u.ar.codimen)\n-\t\t    gfc_error (\"Coarrays not supported in DEPEND clause at %L\",\n-\t\t\t       where);\n+\t\t    gfc_error (\"Coarrays not supported in %s clause at %L\",\n+\t\t\t       name, where);\n \t\t  else\n \t\t    {\n \t\t      int i;\n@@ -1842,19 +2168,20 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\tif (ar->stride[i])\n \t\t\t  {\n \t\t\t    gfc_error (\"Stride should not be specified for \"\n-\t\t\t\t       \"array section in DEPEND clause at %L\",\n-\t\t\t\t       where);\n+\t\t\t\t       \"array section in %s clause at %L\",\n+\t\t\t\t       name, where);\n \t\t\t    break;\n \t\t\t  }\n \t\t\telse if (ar->dimen_type[i] != DIMEN_ELEMENT\n \t\t\t\t && ar->dimen_type[i] != DIMEN_RANGE)\n \t\t\t  {\n-\t\t\t    gfc_error (\"'%s' in DEPEND clause at %L is not a \"\n+\t\t\t    gfc_error (\"'%s' in %s clause at %L is not a \"\n \t\t\t\t       \"proper array section\",\n-\t\t\t\t       n->sym->name, where);\n+\t\t\t\t       n->sym->name, name, where);\n \t\t\t    break;\n \t\t\t  }\n-\t\t\telse if (ar->start[i]\n+\t\t\telse if (list == OMP_LIST_DEPEND\n+\t\t\t\t && ar->start[i]\n \t\t\t\t && ar->start[i]->expr_type == EXPR_CONSTANT\n \t\t\t\t && ar->end[i]\n \t\t\t\t && ar->end[i]->expr_type == EXPR_CONSTANT\n@@ -1868,6 +2195,17 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\t  }\n \t\t    }\n \t\t}\n+\t    if (list != OMP_LIST_DEPEND)\n+\t      for (n = omp_clauses->lists[list]; n != NULL; n = n->next)\n+\t\t{\n+\t\t  n->sym->attr.referenced = 1;\n+\t\t  if (n->sym->attr.threadprivate)\n+\t\t    gfc_error (\"THREADPRIVATE object '%s' in %s clause at %L\",\n+\t\t\t       n->sym->name, name, where);\n+\t\t  if (n->sym->attr.cray_pointee)\n+\t\t    gfc_error (\"Cray pointee '%s' in %s clause at %L\",\n+\t\t\t       n->sym->name, name, where);\n+\t\t}\n \t    break;\n \t  default:\n \t    for (; n != NULL; n = n->next)\n@@ -1917,7 +2255,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\tswitch (list)\n \t\t  {\n \t\t  case OMP_LIST_REDUCTION:\n-\t\t    switch (n->rop)\n+\t\t    switch (n->u.reduction_op)\n \t\t      {\n \t\t      case OMP_REDUCTION_PLUS:\n \t\t      case OMP_REDUCTION_TIMES:\n@@ -1964,7 +2302,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\tif (n->udr == NULL)\n \t\t\t  {\n \t\t\t    if (udr_name == NULL)\n-\t\t\t      switch (n->rop)\n+\t\t\t      switch (n->u.reduction_op)\n \t\t\t\t{\n \t\t\t\tcase OMP_REDUCTION_PLUS:\n \t\t\t\tcase OMP_REDUCTION_TIMES:\n@@ -1974,7 +2312,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\t\tcase OMP_REDUCTION_EQV:\n \t\t\t\tcase OMP_REDUCTION_NEQV:\n \t\t\t\t  udr_name = gfc_op2string ((gfc_intrinsic_op)\n-\t\t\t\t\t\t\t    n->rop);\n+\t\t\t\t\t\t\t    n->u.reduction_op);\n \t\t\t\t  break;\n \t\t\t\tcase OMP_REDUCTION_MAX:\n \t\t\t\t  udr_name = \"max\";\n@@ -1999,7 +2337,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\t\t       gfc_typename (&n->sym->ts), where);\n \t\t\t  }\n \t\t\telse\n-\t\t\t  n->rop = OMP_REDUCTION_USER;\n+\t\t\t  n->u.reduction_op = OMP_REDUCTION_USER;\n \t\t      }\n \t\t    break;\n \t\t  case OMP_LIST_LINEAR:\n@@ -2051,6 +2389,38 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \tgfc_error (\"SIMDLEN clause at %L requires a scalar \"\n \t\t   \"INTEGER expression\", &expr->where);\n     }\n+  if (omp_clauses->num_teams)\n+    {\n+      gfc_expr *expr = omp_clauses->num_teams;\n+      if (!gfc_resolve_expr (expr)\n+\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+\tgfc_error (\"NUM_TEAMS clause at %L requires a scalar \"\n+\t\t   \"INTEGER expression\", &expr->where);\n+    }\n+  if (omp_clauses->device)\n+    {\n+      gfc_expr *expr = omp_clauses->device;\n+      if (!gfc_resolve_expr (expr)\n+\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+\tgfc_error (\"DEVICE clause at %L requires a scalar \"\n+\t\t   \"INTEGER expression\", &expr->where);\n+    }\n+  if (omp_clauses->dist_chunk_size)\n+    {\n+      gfc_expr *expr = omp_clauses->dist_chunk_size;\n+      if (!gfc_resolve_expr (expr)\n+\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+\tgfc_error (\"DIST_SCHEDULE clause's chunk_size at %L requires \"\n+\t\t   \"a scalar INTEGER expression\", &expr->where);\n+    }\n+  if (omp_clauses->thread_limit)\n+    {\n+      gfc_expr *expr = omp_clauses->thread_limit;\n+      if (!gfc_resolve_expr (expr)\n+\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+\tgfc_error (\"THREAD_LIMIT clause at %L requires a scalar \"\n+\t\t   \"INTEGER expression\", &expr->where);\n+    }\n }\n \n \n@@ -2565,14 +2935,38 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n   omp_current_ctx = &ctx;\n \n   for (list = 0; list < OMP_LIST_NUM; list++)\n-    for (n = omp_clauses->lists[list]; n; n = n->next)\n-      pointer_set_insert (ctx.sharing_clauses, n->sym);\n+    switch (list)\n+      {\n+      case OMP_LIST_SHARED:\n+      case OMP_LIST_PRIVATE:\n+      case OMP_LIST_FIRSTPRIVATE:\n+      case OMP_LIST_LASTPRIVATE:\n+      case OMP_LIST_REDUCTION:\n+      case OMP_LIST_LINEAR:\n+\tfor (n = omp_clauses->lists[list]; n; n = n->next)\n+\t  pointer_set_insert (ctx.sharing_clauses, n->sym);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n \n-  if (code->op == EXEC_OMP_PARALLEL_DO\n-      || code->op == EXEC_OMP_PARALLEL_DO_SIMD)\n-    gfc_resolve_omp_do_blocks (code, ns);\n-  else\n-    gfc_resolve_blocks (code->block, ns);\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n+      gfc_resolve_omp_do_blocks (code, ns);\n+      break;\n+    default:\n+      gfc_resolve_blocks (code->block, ns);\n+    }\n \n   omp_current_ctx = ctx.previous;\n   pointer_set_destroy (ctx.sharing_clauses);\n@@ -2660,13 +3054,52 @@ resolve_omp_do (gfc_code *code)\n \n   switch (code->op)\n     {\n+    case EXEC_OMP_DISTRIBUTE: name = \"!$OMP DISTRIBUTE\"; break;\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+      name = \"!$OMP DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      name = \"!$OMP DISTRIBUTE PARALLEL DO SIMD\";\n+      is_simd = true;\n+      break;\n+    case EXEC_OMP_DISTRIBUTE_SIMD:\n+      name = \"!$OMP DISTRIBUTE SIMD\";\n+      is_simd = true;\n+      break;\n     case EXEC_OMP_DO: name = \"!$OMP DO\"; break;\n     case EXEC_OMP_DO_SIMD: name = \"!$OMP DO SIMD\"; is_simd = true; break;\n     case EXEC_OMP_PARALLEL_DO: name = \"!$OMP PARALLEL DO\"; break;\n     case EXEC_OMP_PARALLEL_DO_SIMD:\n       name = \"!$OMP PARALLEL DO SIMD\";\n-      is_simd = true; break;\n+      is_simd = true;\n+      break;\n     case EXEC_OMP_SIMD: name = \"!$OMP SIMD\"; is_simd = true; break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+      name = \"!$OMP TARGET TEAMS_DISTRIBUTE\";\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      name = \"!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      name = \"!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO SIMD\";\n+      is_simd = true;\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+      name = \"!$OMP TARGET TEAMS DISTRIBUTE SIMD\";\n+      is_simd = true;\n+      break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE: name = \"!$OMP TEAMS_DISTRIBUTE\"; break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      name = \"!$OMP TEAMS DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      name = \"!$OMP TEAMS DISTRIBUTE PARALLEL DO SIMD\";\n+      is_simd = true;\n+      break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n+      name = \"!$OMP TEAMS DISTRIBUTE SIMD\";\n+      is_simd = true;\n+      break;\n     default: gcc_unreachable ();\n     }\n \n@@ -2786,11 +3219,23 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n \n   switch (code->op)\n     {\n+    case EXEC_OMP_DISTRIBUTE:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_DISTRIBUTE_SIMD:\n     case EXEC_OMP_DO:\n     case EXEC_OMP_DO_SIMD:\n     case EXEC_OMP_PARALLEL_DO:\n     case EXEC_OMP_PARALLEL_DO_SIMD:\n     case EXEC_OMP_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n       resolve_omp_do (code);\n       break;\n     case EXEC_OMP_CANCEL:\n@@ -2799,11 +3244,24 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n     case EXEC_OMP_PARALLEL_SECTIONS:\n     case EXEC_OMP_SECTIONS:\n     case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_TARGET:\n+    case EXEC_OMP_TARGET_DATA:\n+    case EXEC_OMP_TARGET_TEAMS:\n     case EXEC_OMP_TASK:\n+    case EXEC_OMP_TEAMS:\n     case EXEC_OMP_WORKSHARE:\n       if (code->ext.omp_clauses)\n \tresolve_omp_clauses (code, &code->loc, code->ext.omp_clauses, NULL);\n       break;\n+    case EXEC_OMP_TARGET_UPDATE:\n+      if (code->ext.omp_clauses)\n+\tresolve_omp_clauses (code, &code->loc, code->ext.omp_clauses, NULL);\n+      if (code->ext.omp_clauses == NULL\n+\t  || (code->ext.omp_clauses->lists[OMP_LIST_TO] == NULL\n+\t      && code->ext.omp_clauses->lists[OMP_LIST_FROM] == NULL))\n+\tgfc_error (\"OMP TARGET UPDATE at %L requires at least one TO or \"\n+\t\t   \"FROM clause\", &code->loc);\n+      break;\n     case EXEC_OMP_ATOMIC:\n       resolve_omp_atomic (code);\n       break;\n@@ -2822,7 +3280,7 @@ gfc_resolve_omp_declare_simd (gfc_namespace *ns)\n   for (ods = ns->omp_declare_simd; ods; ods = ods->next)\n     {\n       if (ods->proc_name != ns->proc_name)\n-\tgfc_error (\"!$OMP DECLARE SIMD should refer to containing procedure\"\n+\tgfc_error (\"!$OMP DECLARE SIMD should refer to containing procedure \"\n \t\t   \"'%s' at %L\", ns->proc_name->name, &ods->where);\n       if (ods->clauses)\n \tresolve_omp_clauses (NULL, &ods->where, ods->clauses, ns);"}, {"sha": "e8dcb70edb243afff9e180b332220456a15a3e27", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 283, "deletions": 5, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -633,12 +633,29 @@ decode_omp_directive (void)\n \t      ST_OMP_DECLARE_REDUCTION);\n       matchs (\"declare simd\", gfc_match_omp_declare_simd,\n \t      ST_OMP_DECLARE_SIMD);\n+      matcho (\"declare target\", gfc_match_omp_declare_target,\n+\t      ST_OMP_DECLARE_TARGET);\n+      matchs (\"distribute parallel do simd\",\n+\t      gfc_match_omp_distribute_parallel_do_simd,\n+\t      ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD);\n+      matcho (\"distribute parallel do\", gfc_match_omp_distribute_parallel_do,\n+\t      ST_OMP_DISTRIBUTE_PARALLEL_DO);\n+      matchs (\"distribute simd\", gfc_match_omp_distribute_simd,\n+\t      ST_OMP_DISTRIBUTE_SIMD);\n+      matcho (\"distribute\", gfc_match_omp_distribute, ST_OMP_DISTRIBUTE);\n       matchs (\"do simd\", gfc_match_omp_do_simd, ST_OMP_DO_SIMD);\n       matcho (\"do\", gfc_match_omp_do, ST_OMP_DO);\n       break;\n     case 'e':\n       matcho (\"end atomic\", gfc_match_omp_eos, ST_OMP_END_ATOMIC);\n       matcho (\"end critical\", gfc_match_omp_critical, ST_OMP_END_CRITICAL);\n+      matchs (\"end distribute parallel do simd\", gfc_match_omp_eos,\n+\t      ST_OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD);\n+      matcho (\"end distribute parallel do\", gfc_match_omp_eos,\n+\t      ST_OMP_END_DISTRIBUTE_PARALLEL_DO);\n+      matchs (\"end distribute simd\", gfc_match_omp_eos,\n+\t      ST_OMP_END_DISTRIBUTE_SIMD);\n+      matcho (\"end distribute\", gfc_match_omp_eos, ST_OMP_END_DISTRIBUTE);\n       matchs (\"end do simd\", gfc_match_omp_end_nowait, ST_OMP_END_DO_SIMD);\n       matcho (\"end do\", gfc_match_omp_end_nowait, ST_OMP_END_DO);\n       matchs (\"end simd\", gfc_match_omp_eos, ST_OMP_END_SIMD);\n@@ -654,8 +671,29 @@ decode_omp_directive (void)\n       matcho (\"end parallel\", gfc_match_omp_eos, ST_OMP_END_PARALLEL);\n       matcho (\"end sections\", gfc_match_omp_end_nowait, ST_OMP_END_SECTIONS);\n       matcho (\"end single\", gfc_match_omp_end_single, ST_OMP_END_SINGLE);\n+      matcho (\"end target data\", gfc_match_omp_eos, ST_OMP_END_TARGET_DATA);\n+      matchs (\"end target teams distribute parallel do simd\",\n+\t      gfc_match_omp_eos,\n+\t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD);\n+      matcho (\"end target teams distribute parallel do\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO);\n+      matchs (\"end target teams distribute simd\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD);\n+      matcho (\"end target teams distribute\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE);\n+      matcho (\"end target teams\", gfc_match_omp_eos, ST_OMP_END_TARGET_TEAMS);\n+      matcho (\"end target\", gfc_match_omp_eos, ST_OMP_END_TARGET);\n       matcho (\"end taskgroup\", gfc_match_omp_eos, ST_OMP_END_TASKGROUP);\n       matcho (\"end task\", gfc_match_omp_eos, ST_OMP_END_TASK);\n+      matchs (\"end teams distribute parallel do simd\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD);\n+      matcho (\"end teams distribute parallel do\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO);\n+      matchs (\"end teams distribute simd\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TEAMS_DISTRIBUTE_SIMD);\n+      matcho (\"end teams distribute\", gfc_match_omp_eos,\n+\t      ST_OMP_END_TEAMS_DISTRIBUTE);\n+      matcho (\"end teams\", gfc_match_omp_eos, ST_OMP_END_TEAMS);\n       matcho (\"end workshare\", gfc_match_omp_end_nowait,\n \t      ST_OMP_END_WORKSHARE);\n       break;\n@@ -685,10 +723,37 @@ decode_omp_directive (void)\n       matcho (\"single\", gfc_match_omp_single, ST_OMP_SINGLE);\n       break;\n     case 't':\n+      matcho (\"target data\", gfc_match_omp_target_data, ST_OMP_TARGET_DATA);\n+      matchs (\"target teams distribute parallel do simd\",\n+\t      gfc_match_omp_target_teams_distribute_parallel_do_simd,\n+\t      ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD);\n+      matcho (\"target teams distribute parallel do\",\n+\t      gfc_match_omp_target_teams_distribute_parallel_do,\n+\t      ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO);\n+      matchs (\"target teams distribute simd\",\n+\t      gfc_match_omp_target_teams_distribute_simd,\n+\t      ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD);\n+      matcho (\"target teams distribute\", gfc_match_omp_target_teams_distribute,\n+\t      ST_OMP_TARGET_TEAMS_DISTRIBUTE);\n+      matcho (\"target teams\", gfc_match_omp_target_teams, ST_OMP_TARGET_TEAMS);\n+      matcho (\"target update\", gfc_match_omp_target_update,\n+\t      ST_OMP_TARGET_UPDATE);\n+      matcho (\"target\", gfc_match_omp_target, ST_OMP_TARGET);\n       matcho (\"taskgroup\", gfc_match_omp_taskgroup, ST_OMP_TASKGROUP);\n       matcho (\"taskwait\", gfc_match_omp_taskwait, ST_OMP_TASKWAIT);\n       matcho (\"taskyield\", gfc_match_omp_taskyield, ST_OMP_TASKYIELD);\n       matcho (\"task\", gfc_match_omp_task, ST_OMP_TASK);\n+      matchs (\"teams distribute parallel do simd\",\n+\t      gfc_match_omp_teams_distribute_parallel_do_simd,\n+\t      ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD);\n+      matcho (\"teams distribute parallel do\",\n+\t      gfc_match_omp_teams_distribute_parallel_do,\n+\t      ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO);\n+      matchs (\"teams distribute simd\", gfc_match_omp_teams_distribute_simd,\n+\t      ST_OMP_TEAMS_DISTRIBUTE_SIMD);\n+      matcho (\"teams distribute\", gfc_match_omp_teams_distribute,\n+\t      ST_OMP_TEAMS_DISTRIBUTE);\n+      matcho (\"teams\", gfc_match_omp_teams, ST_OMP_TEAMS);\n       matcho (\"threadprivate\", gfc_match_omp_threadprivate,\n \t      ST_OMP_THREADPRIVATE);\n       break;\n@@ -1094,8 +1159,8 @@ next_statement (void)\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n   case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_OMP_TASKYIELD: \\\n   case ST_OMP_CANCEL: case ST_OMP_CANCELLATION_POINT: \\\n-  case ST_ERROR_STOP: case ST_SYNC_ALL: case ST_SYNC_IMAGES: \\\n-  case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK\n+  case ST_OMP_TARGET_UPDATE: case ST_ERROR_STOP: case ST_SYNC_ALL: \\\n+  case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK\n \n /* Statements that mark other executable statements.  */\n \n@@ -1108,14 +1173,27 @@ next_statement (void)\n   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \\\n   case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE: \\\n   case ST_OMP_TASK: case ST_OMP_TASKGROUP: case ST_OMP_SIMD: \\\n-  case ST_OMP_DO_SIMD: case ST_OMP_PARALLEL_DO_SIMD: case ST_CRITICAL\n+  case ST_OMP_DO_SIMD: case ST_OMP_PARALLEL_DO_SIMD: case ST_OMP_TARGET: \\\n+  case ST_OMP_TARGET_DATA: case ST_OMP_TARGET_TEAMS: \\\n+  case ST_OMP_TARGET_TEAMS_DISTRIBUTE: \\\n+  case ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD: \\\n+  case ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO: \\\n+  case ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD: \\\n+  case ST_OMP_TEAMS: case ST_OMP_TEAMS_DISTRIBUTE: \\\n+  case ST_OMP_TEAMS_DISTRIBUTE_SIMD: \\\n+  case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO: \\\n+  case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD: case ST_OMP_DISTRIBUTE: \\\n+  case ST_OMP_DISTRIBUTE_SIMD: case ST_OMP_DISTRIBUTE_PARALLEL_DO: \\\n+  case ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD: \\\n+  case ST_CRITICAL\n \n /* Declaration statements */\n \n #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \\\n   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \\\n   case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE: \\\n-  case ST_PROCEDURE: case ST_OMP_DECLARE_SIMD: case ST_OMP_DECLARE_REDUCTION\n+  case ST_PROCEDURE: case ST_OMP_DECLARE_SIMD: case ST_OMP_DECLARE_REDUCTION: \\\n+  case ST_OMP_DECLARE_TARGET\n \n /* Block end statements.  Errors associated with interchanging these\n    are detected in gfc_match_end().  */\n@@ -1621,6 +1699,21 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_DECLARE_SIMD:\n       p = \"!$OMP DECLARE SIMD\";\n       break;\n+    case ST_OMP_DECLARE_TARGET:\n+      p = \"!$OMP DECLARE TARGET\";\n+      break;\n+    case ST_OMP_DISTRIBUTE:\n+      p = \"!$OMP DISTRIBUTE\";\n+      break;\n+    case ST_OMP_DISTRIBUTE_PARALLEL_DO:\n+      p = \"!$OMP DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      p = \"!$OMP DISTRIBUTE PARALLEL DO SIMD\";\n+      break;\n+    case ST_OMP_DISTRIBUTE_SIMD:\n+      p = \"!$OMP DISTRIBUTE SIMD\";\n+      break;\n     case ST_OMP_DO:\n       p = \"!$OMP DO\";\n       break;\n@@ -1633,6 +1726,18 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_END_CRITICAL:\n       p = \"!$OMP END CRITICAL\";\n       break;\n+    case ST_OMP_END_DISTRIBUTE:\n+      p = \"!$OMP END DISTRIBUTE\";\n+      break;\n+    case ST_OMP_END_DISTRIBUTE_PARALLEL_DO:\n+      p = \"!$OMP END DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case ST_OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      p = \"!$OMP END DISTRIBUTE PARALLEL DO SIMD\";\n+      break;\n+    case ST_OMP_END_DISTRIBUTE_SIMD:\n+      p = \"!$OMP END DISTRIBUTE SIMD\";\n+      break;\n     case ST_OMP_END_DO:\n       p = \"!$OMP END DO\";\n       break;\n@@ -1672,9 +1777,45 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_END_TASK:\n       p = \"!$OMP END TASK\";\n       break;\n+    case ST_OMP_END_TARGET:\n+      p = \"!$OMP END TARGET\";\n+      break;\n+    case ST_OMP_END_TARGET_DATA:\n+      p = \"!$OMP END TARGET DATA\";\n+      break;\n+    case ST_OMP_END_TARGET_TEAMS:\n+      p = \"!$OMP END TARGET TEAMS\";\n+      break;\n+    case ST_OMP_END_TARGET_TEAMS_DISTRIBUTE:\n+      p = \"!$OMP END TARGET TEAMS DISTRIBUTE\";\n+      break;\n+    case ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      p = \"!$OMP END TARGET TEAMS DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      p = \"!$OMP END TARGET TEAMS DISTRIBUTE PARALLEL DO SIMD\";\n+      break;\n+    case ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+      p = \"!$OMP END TARGET TEAMS DISTRIBUTE SIMD\";\n+      break;\n     case ST_OMP_END_TASKGROUP:\n       p = \"!$OMP END TASKGROUP\";\n       break;\n+    case ST_OMP_END_TEAMS:\n+      p = \"!$OMP END TEAMS\";\n+      break;\n+    case ST_OMP_END_TEAMS_DISTRIBUTE:\n+      p = \"!$OMP END TEAMS DISTRIBUTE\";\n+      break;\n+    case ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      p = \"!$OMP END TEAMS DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      p = \"!$OMP END TEAMS DISTRIBUTE PARALLEL DO SIMD\";\n+      break;\n+    case ST_OMP_END_TEAMS_DISTRIBUTE_SIMD:\n+      p = \"!$OMP END TEAMS DISTRIBUTE SIMD\";\n+      break;\n     case ST_OMP_END_WORKSHARE:\n       p = \"!$OMP END WORKSHARE\";\n       break;\n@@ -1714,6 +1855,30 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_SINGLE:\n       p = \"!$OMP SINGLE\";\n       break;\n+    case ST_OMP_TARGET:\n+      p = \"!$OMP TARGET\";\n+      break;\n+    case ST_OMP_TARGET_DATA:\n+      p = \"!$OMP TARGET DATA\";\n+      break;\n+    case ST_OMP_TARGET_TEAMS:\n+      p = \"!$OMP TARGET TEAMS\";\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE:\n+      p = \"!$OMP TARGET TEAMS DISTRIBUTE\";\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      p = \"!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      p = \"!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO SIMD\";\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+      p = \"!$OMP TARGET TEAMS DISTRIBUTE SIMD\";\n+      break;\n+    case ST_OMP_TARGET_UPDATE:\n+      p = \"!$OMP TARGET UPDATE\";\n+      break;\n     case ST_OMP_TASK:\n       p = \"!$OMP TASK\";\n       break;\n@@ -1726,6 +1891,21 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_TASKYIELD:\n       p = \"!$OMP TASKYIELD\";\n       break;\n+    case ST_OMP_TEAMS:\n+      p = \"!$OMP TEAMS\";\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE:\n+      p = \"!$OMP TEAMS DISTRIBUTE\";\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      p = \"!$OMP TEAMS DISTRIBUTE PARALLEL DO\";\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      p = \"!$OMP TEAMS DISTRIBUTE PARALLEL DO SIMD\";\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_SIMD:\n+      p = \"!$OMP TEAMS DISTRIBUTE SIMD\";\n+      break;\n     case ST_OMP_THREADPRIVATE:\n       p = \"!$OMP THREADPRIVATE\";\n       break;\n@@ -3699,13 +3879,47 @@ parse_omp_do (gfc_statement omp_st)\n   gfc_statement omp_end_st = ST_OMP_END_DO;\n   switch (omp_st)\n     {\n-    case ST_OMP_SIMD: omp_end_st = ST_OMP_END_SIMD; break;\n+    case ST_OMP_DISTRIBUTE: omp_end_st = ST_OMP_END_DISTRIBUTE; break;\n+    case ST_OMP_DISTRIBUTE_PARALLEL_DO:\n+      omp_end_st = ST_OMP_END_DISTRIBUTE_PARALLEL_DO;\n+      break;\n+    case ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      omp_end_st = ST_OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD;\n+      break;\n+    case ST_OMP_DISTRIBUTE_SIMD:\n+      omp_end_st = ST_OMP_END_DISTRIBUTE_SIMD;\n+      break;\n     case ST_OMP_DO: omp_end_st = ST_OMP_END_DO; break;\n     case ST_OMP_DO_SIMD: omp_end_st = ST_OMP_END_DO_SIMD; break;\n     case ST_OMP_PARALLEL_DO: omp_end_st = ST_OMP_END_PARALLEL_DO; break;\n     case ST_OMP_PARALLEL_DO_SIMD:\n       omp_end_st = ST_OMP_END_PARALLEL_DO_SIMD;\n       break;\n+    case ST_OMP_SIMD: omp_end_st = ST_OMP_END_SIMD; break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE;\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO;\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD;\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD;\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE:\n+      omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE;\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO;\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD;\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_SIMD:\n+      omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE_SIMD;\n+      break;\n     default: gcc_unreachable ();\n     }\n   if (st == omp_end_st)\n@@ -3814,12 +4028,60 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n     case ST_OMP_SINGLE:\n       omp_end_st = ST_OMP_END_SINGLE;\n       break;\n+    case ST_OMP_TARGET:\n+      omp_end_st = ST_OMP_END_TARGET;\n+      break;\n+    case ST_OMP_TARGET_DATA:\n+      omp_end_st = ST_OMP_END_TARGET_DATA;\n+      break;\n+    case ST_OMP_TARGET_TEAMS:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS;\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE;\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO;\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD;\n+      break;\n+    case ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+      omp_end_st = ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD;\n+      break;\n     case ST_OMP_TASK:\n       omp_end_st = ST_OMP_END_TASK;\n       break;\n     case ST_OMP_TASKGROUP:\n       omp_end_st = ST_OMP_END_TASKGROUP;\n       break;\n+    case ST_OMP_TEAMS:\n+      omp_end_st = ST_OMP_END_TEAMS;\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE:\n+      omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE;\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO;\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD;\n+      break;\n+    case ST_OMP_TEAMS_DISTRIBUTE_SIMD:\n+      omp_end_st = ST_OMP_END_TEAMS_DISTRIBUTE_SIMD;\n+      break;\n+    case ST_OMP_DISTRIBUTE:\n+      omp_end_st = ST_OMP_END_DISTRIBUTE;\n+      break;\n+    case ST_OMP_DISTRIBUTE_PARALLEL_DO:\n+      omp_end_st = ST_OMP_END_DISTRIBUTE_PARALLEL_DO;\n+      break;\n+    case ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      omp_end_st = ST_OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD;\n+      break;\n+    case ST_OMP_DISTRIBUTE_SIMD:\n+      omp_end_st = ST_OMP_END_DISTRIBUTE_SIMD;\n+      break;\n     case ST_OMP_WORKSHARE:\n       omp_end_st = ST_OMP_END_WORKSHARE;\n       break;\n@@ -4052,6 +4314,10 @@ parse_executable (gfc_statement st)\n \tcase ST_OMP_CRITICAL:\n \tcase ST_OMP_MASTER:\n \tcase ST_OMP_SINGLE:\n+\tcase ST_OMP_TARGET:\n+\tcase ST_OMP_TARGET_DATA:\n+\tcase ST_OMP_TARGET_TEAMS:\n+\tcase ST_OMP_TEAMS:\n \tcase ST_OMP_TASK:\n \tcase ST_OMP_TASKGROUP:\n \t  parse_omp_structured_block (st, false);\n@@ -4062,11 +4328,23 @@ parse_executable (gfc_statement st)\n \t  parse_omp_structured_block (st, true);\n \t  break;\n \n+\tcase ST_OMP_DISTRIBUTE:\n+\tcase ST_OMP_DISTRIBUTE_PARALLEL_DO:\n+\tcase ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase ST_OMP_DISTRIBUTE_SIMD:\n \tcase ST_OMP_DO:\n \tcase ST_OMP_DO_SIMD:\n \tcase ST_OMP_PARALLEL_DO:\n \tcase ST_OMP_PARALLEL_DO_SIMD:\n \tcase ST_OMP_SIMD:\n+\tcase ST_OMP_TARGET_TEAMS_DISTRIBUTE:\n+\tcase ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\tcase ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+\tcase ST_OMP_TEAMS_DISTRIBUTE:\n+\tcase ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\tcase ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase ST_OMP_TEAMS_DISTRIBUTE_SIMD:\n \t  st = parse_omp_do (st);\n \t  if (st == ST_IMPLIED_ENDDO)\n \t    return st;"}, {"sha": "64f3489877093121af262a7c0b4dcf7de1a70f60", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -9032,6 +9032,10 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_CRITICAL:\n+\tcase EXEC_OMP_DISTRIBUTE:\n+\tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_DISTRIBUTE_SIMD:\n \tcase EXEC_OMP_DO:\n \tcase EXEC_OMP_DO_SIMD:\n \tcase EXEC_OMP_MASTER:\n@@ -9044,10 +9048,23 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OMP_SECTIONS:\n \tcase EXEC_OMP_SIMD:\n \tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_TARGET:\n+\tcase EXEC_OMP_TARGET_DATA:\n+\tcase EXEC_OMP_TARGET_TEAMS:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+\tcase EXEC_OMP_TARGET_UPDATE:\n \tcase EXEC_OMP_TASK:\n \tcase EXEC_OMP_TASKGROUP:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n+\tcase EXEC_OMP_TEAMS:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n \tcase EXEC_OMP_WORKSHARE:\n \t  break;\n \n@@ -9827,11 +9844,23 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    case EXEC_OMP_PARALLEL_DO:\n \t    case EXEC_OMP_PARALLEL_DO_SIMD:\n \t    case EXEC_OMP_PARALLEL_SECTIONS:\n+\t    case EXEC_OMP_TARGET_TEAMS:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n \t    case EXEC_OMP_TASK:\n+\t    case EXEC_OMP_TEAMS:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\t    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n \t      omp_workshare_save = omp_workshare_flag;\n \t      omp_workshare_flag = 0;\n \t      gfc_resolve_omp_parallel_blocks (code, ns);\n \t      break;\n+\t    case EXEC_OMP_DISTRIBUTE:\n+\t    case EXEC_OMP_DISTRIBUTE_SIMD:\n \t    case EXEC_OMP_DO:\n \t    case EXEC_OMP_DO_SIMD:\n \t    case EXEC_OMP_SIMD:\n@@ -10160,16 +10189,34 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OMP_CANCELLATION_POINT:\n \tcase EXEC_OMP_CRITICAL:\n \tcase EXEC_OMP_FLUSH:\n+\tcase EXEC_OMP_DISTRIBUTE:\n+\tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_DISTRIBUTE_SIMD:\n \tcase EXEC_OMP_DO:\n \tcase EXEC_OMP_DO_SIMD:\n \tcase EXEC_OMP_MASTER:\n \tcase EXEC_OMP_ORDERED:\n \tcase EXEC_OMP_SECTIONS:\n \tcase EXEC_OMP_SIMD:\n \tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_TARGET:\n+\tcase EXEC_OMP_TARGET_DATA:\n+\tcase EXEC_OMP_TARGET_TEAMS:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+\tcase EXEC_OMP_TARGET_UPDATE:\n+\tcase EXEC_OMP_TASK:\n \tcase EXEC_OMP_TASKGROUP:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n+\tcase EXEC_OMP_TEAMS:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n \tcase EXEC_OMP_WORKSHARE:\n \t  gfc_resolve_omp_directive (code, ns);\n \t  break;\n@@ -10179,7 +10226,6 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OMP_PARALLEL_DO_SIMD:\n \tcase EXEC_OMP_PARALLEL_SECTIONS:\n \tcase EXEC_OMP_PARALLEL_WORKSHARE:\n-\tcase EXEC_OMP_TASK:\n \t  omp_workshare_save = omp_workshare_flag;\n \t  omp_workshare_flag = 0;\n \t  gfc_resolve_omp_directive (code, ns);\n@@ -13541,6 +13587,18 @@ resolve_symbol (gfc_symbol *sym)\n \t      || sym->ns->proc_name->attr.flavor != FL_MODULE)))\n     gfc_error (\"Threadprivate at %L isn't SAVEd\", &sym->declared_at);\n \n+  /* Check omp declare target restrictions.  */\n+  if (sym->attr.omp_declare_target\n+      && sym->attr.flavor == FL_VARIABLE\n+      && !sym->attr.save\n+      && !sym->ns->save_all\n+      && (!sym->attr.in_common\n+\t  && sym->module == NULL\n+\t  && (sym->ns->proc_name == NULL\n+\t      || sym->ns->proc_name->attr.flavor != FL_MODULE)))\n+    gfc_error (\"!$OMP DECLARE TARGET variable '%s' at %L isn't SAVEd\",\n+\t       sym->name, &sym->declared_at);\n+\n   /* If we have come this far we can apply default-initializers, as\n      described in 14.7.5, to those variables that have not already\n      been assigned one.  */"}, {"sha": "0f18f787231c9b2e4d87ed99e4c7a1e2a1a2105f", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -187,6 +187,10 @@ gfc_free_statement (gfc_code *p)\n \n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n+    case EXEC_OMP_DISTRIBUTE:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_DISTRIBUTE_SIMD:\n     case EXEC_OMP_DO:\n     case EXEC_OMP_DO_SIMD:\n     case EXEC_OMP_END_SINGLE:\n@@ -197,7 +201,20 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OMP_SECTIONS:\n     case EXEC_OMP_SIMD:\n     case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_TARGET:\n+    case EXEC_OMP_TARGET_DATA:\n+    case EXEC_OMP_TARGET_TEAMS:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TARGET_UPDATE:\n     case EXEC_OMP_TASK:\n+    case EXEC_OMP_TEAMS:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n     case EXEC_OMP_WORKSHARE:\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n       gfc_free_omp_clauses (p->ext.omp_clauses);"}, {"sha": "aee7510a463b0ab5048e81084738f5ef70ada827", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -367,6 +367,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     *asynchronous = \"ASYNCHRONOUS\", *codimension = \"CODIMENSION\",\n     *contiguous = \"CONTIGUOUS\", *generic = \"GENERIC\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n+  static const char *omp_declare_target = \"OMP DECLARE TARGET\";\n \n   const char *a1, *a2;\n   int standard;\n@@ -453,6 +454,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (dummy, entry);\n   conf (dummy, intrinsic);\n   conf (dummy, threadprivate);\n+  conf (dummy, omp_declare_target);\n   conf (pointer, target);\n   conf (pointer, intrinsic);\n   conf (pointer, elemental);\n@@ -495,6 +497,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (in_equivalence, entry);\n   conf (in_equivalence, allocatable);\n   conf (in_equivalence, threadprivate);\n+  conf (in_equivalence, omp_declare_target);\n \n   conf (dummy, result);\n   conf (entry, result);\n@@ -543,6 +546,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (cray_pointee, in_common);\n   conf (cray_pointee, in_equivalence);\n   conf (cray_pointee, threadprivate);\n+  conf (cray_pointee, omp_declare_target);\n \n   conf (data, dummy);\n   conf (data, function);\n@@ -596,6 +600,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \n   conf (proc_pointer, abstract)\n \n+  conf (entry, omp_declare_target)\n+\n   a1 = gfc_code2string (flavors, attr->flavor);\n \n   if (attr->in_namelist\n@@ -631,6 +637,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (function);\n       conf2 (subroutine);\n       conf2 (threadprivate);\n+      conf2 (omp_declare_target);\n \n       if (attr->access == ACCESS_PUBLIC || attr->access == ACCESS_PRIVATE)\n \t{\n@@ -712,6 +719,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (subroutine);\n       conf2 (threadprivate);\n       conf2 (result);\n+      conf2 (omp_declare_target);\n \n       if (attr->intent != INTENT_UNKNOWN)\n \t{\n@@ -1206,6 +1214,22 @@ gfc_add_threadprivate (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n+bool\n+gfc_add_omp_declare_target (symbol_attribute *attr, const char *name,\n+\t\t\t    locus *where)\n+{\n+\n+  if (check_used (attr, name, where))\n+    return false;\n+\n+  if (attr->omp_declare_target)\n+    return true;\n+\n+  attr->omp_declare_target = 1;\n+  return check_conflict (attr, name, where);\n+}\n+\n+\n bool\n gfc_add_target (symbol_attribute *attr, locus *where)\n {\n@@ -1761,6 +1785,9 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n   if (src->threadprivate\n       && !gfc_add_threadprivate (dest, NULL, where))\n     goto fail;\n+  if (src->omp_declare_target\n+      && !gfc_add_omp_declare_target (dest, NULL, where))\n+    goto fail;\n   if (src->target && !gfc_add_target (dest, where))\n     goto fail;\n   if (src->dummy && !gfc_add_dummy (dest, NULL, where))"}, {"sha": "f28eda6b634726ca617fc7106c2638084871c590", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -456,6 +456,11 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n       if (com->threadprivate)\n \tset_decl_tls_model (decl, decl_default_tls_model (decl));\n \n+      if (com->omp_declare_target)\n+\tDECL_ATTRIBUTES (decl)\n+\t  = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t       NULL_TREE, DECL_ATTRIBUTES (decl));\n+\n       /* Place the back end declaration for this common block in\n          GLOBAL_BINDING_LEVEL.  */\n       gfc_map_of_all_commons[identifier] = pushdecl_top_level (decl);"}, {"sha": "f1a18c3cfd26fa819c82fc5f147d491de6019ce2", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1222,6 +1222,10 @@ add_attributes_to_decl (symbol_attribute sym_attr, tree list)\n \tlist = chainon (list, attr);\n       }\n \n+  if (sym_attr.omp_declare_target)\n+    list = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t      NULL_TREE, list);\n+\n   return list;\n }\n "}, {"sha": "7667f2534f76d093fe4cadb0b23c0c7c2daae513", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 870, "deletions": 63, "changes": 933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -873,6 +873,110 @@ gfc_omp_clause_dtor (tree clause, tree decl)\n }\n \n \n+void\n+gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n+{\n+  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+    return;\n+\n+  tree decl = OMP_CLAUSE_DECL (c);\n+  tree c2 = NULL_TREE, c3 = NULL_TREE, c4 = NULL_TREE;\n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      if (!gfc_omp_privatize_by_reference (decl)\n+\t  && !GFC_DECL_GET_SCALAR_POINTER (decl)\n+\t  && !GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)\n+\t  && !GFC_DECL_CRAY_POINTEE (decl)\n+\t  && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n+\treturn;\n+      c4 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_MAP_KIND (c4) = OMP_CLAUSE_MAP_POINTER;\n+      OMP_CLAUSE_DECL (c4) = decl;\n+      OMP_CLAUSE_SIZE (c4) = size_int (0);\n+      decl = build_fold_indirect_ref (decl);\n+      OMP_CLAUSE_DECL (c) = decl;\n+    }\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      stmtblock_t block;\n+      gfc_start_block (&block);\n+      tree type = TREE_TYPE (decl);\n+      tree ptr = gfc_conv_descriptor_data_get (decl);\n+      ptr = fold_convert (build_pointer_type (char_type_node), ptr);\n+      ptr = build_fold_indirect_ref (ptr);\n+      OMP_CLAUSE_DECL (c) = ptr;\n+      c2 = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_MAP_KIND (c2) = OMP_CLAUSE_MAP_TO_PSET;\n+      OMP_CLAUSE_DECL (c2) = decl;\n+      OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (type);\n+      c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_MAP_KIND (c3) = OMP_CLAUSE_MAP_POINTER;\n+      OMP_CLAUSE_DECL (c3) = gfc_conv_descriptor_data_get (decl);\n+      OMP_CLAUSE_SIZE (c3) = size_int (0);\n+      tree size = create_tmp_var (gfc_array_index_type, NULL);\n+      tree elemsz = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+      elemsz = fold_convert (gfc_array_index_type, elemsz);\n+      if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER\n+\t  || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER_CONT)\n+\t{\n+\t  stmtblock_t cond_block;\n+\t  tree tem, then_b, else_b, zero, cond;\n+\n+\t  gfc_init_block (&cond_block);\n+\t  tem = gfc_full_array_size (&cond_block, decl,\n+\t\t\t\t     GFC_TYPE_ARRAY_RANK (type));\n+\t  gfc_add_modify (&cond_block, size, tem);\n+\t  gfc_add_modify (&cond_block, size,\n+\t\t\t  fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t       size, elemsz));\n+\t  then_b = gfc_finish_block (&cond_block);\n+\t  gfc_init_block (&cond_block);\n+\t  zero = build_int_cst (gfc_array_index_type, 0);\n+\t  gfc_add_modify (&cond_block, size, zero);\n+\t  else_b = gfc_finish_block (&cond_block);\n+\t  tem = gfc_conv_descriptor_data_get (decl);\n+\t  tem = fold_convert (pvoid_type_node, tem);\n+\t  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t  boolean_type_node, tem, null_pointer_node);\n+\t  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t\t     void_type_node, cond,\n+\t\t\t\t\t\t     then_b, else_b));\n+\t}\n+      else\n+\t{\n+\t  gfc_add_modify (&block, size,\n+\t\t\t  gfc_full_array_size (&block, decl,\n+\t\t\t\t\t       GFC_TYPE_ARRAY_RANK (type)));\n+\t  gfc_add_modify (&block, size,\n+\t\t\t  fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t       size, elemsz));\n+\t}\n+      OMP_CLAUSE_SIZE (c) = size;\n+      tree stmt = gfc_finish_block (&block);\n+      gimplify_and_add (stmt, pre_p);\n+    }\n+  tree last = c;\n+  if (c2)\n+    {\n+      OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (last);\n+      OMP_CLAUSE_CHAIN (last) = c2;\n+      last = c2;\n+    }\n+  if (c3)\n+    {\n+      OMP_CLAUSE_CHAIN (c3) = OMP_CLAUSE_CHAIN (last);\n+      OMP_CLAUSE_CHAIN (last) = c3;\n+      last = c3;\n+    }\n+  if (c4)\n+    {\n+      OMP_CLAUSE_CHAIN (c4) = OMP_CLAUSE_CHAIN (last);\n+      OMP_CLAUSE_CHAIN (last) = c4;\n+      last = c4;\n+    }\n+}\n+\n+\n /* Return true if DECL's DECL_VALUE_EXPR (if any) should be\n    disregarded in OpenMP construct, because it is going to be\n    remapped during OpenMP lowering.  SHARED is true if DECL\n@@ -1487,7 +1591,7 @@ gfc_trans_omp_reduction_list (gfc_omp_namelist *namelist, tree list,\n \t    tree node = build_omp_clause (where.lb->location,\n \t\t\t\t\t  OMP_CLAUSE_REDUCTION);\n \t    OMP_CLAUSE_DECL (node) = t;\n-\t    switch (namelist->rop)\n+\t    switch (namelist->u.reduction_op)\n \t      {\n \t      case OMP_REDUCTION_PLUS:\n \t\tOMP_CLAUSE_REDUCTION_CODE (node) = PLUS_EXPR;\n@@ -1532,7 +1636,7 @@ gfc_trans_omp_reduction_list (gfc_omp_namelist *namelist, tree list,\n \t\tgcc_unreachable ();\n \t      }\n \t    if (namelist->sym->attr.dimension\n-\t\t|| namelist->rop == OMP_REDUCTION_USER\n+\t\t|| namelist->u.reduction_op == OMP_REDUCTION_USER\n \t\t|| namelist->sym->attr.allocatable)\n \t      gfc_trans_omp_array_reduction_or_udr (node, namelist, where);\n \t    list = gfc_trans_add_clause (node, list);\n@@ -1661,8 +1765,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t      }\n \t  }\n \t  break;\n-\tcase OMP_LIST_DEPEND_IN:\n-\tcase OMP_LIST_DEPEND_OUT:\n+\tcase OMP_LIST_DEPEND:\n \t  for (; n != NULL; n = n->next)\n \t    {\n \t      if (!n->sym->attr.referenced)\n@@ -1671,9 +1774,19 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t      tree node = build_omp_clause (input_location, OMP_CLAUSE_DEPEND);\n \t      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)\n \t\t{\n-\t\t  OMP_CLAUSE_DECL (node) = gfc_get_symbol_decl (n->sym);\n-\t\t  if (DECL_P (OMP_CLAUSE_DECL (node)))\n-\t\t    TREE_ADDRESSABLE (OMP_CLAUSE_DECL (node)) = 1;\n+\t\t  tree decl = gfc_get_symbol_decl (n->sym);\n+\t\t  if (gfc_omp_privatize_by_reference (decl))\n+\t\t    decl = build_fold_indirect_ref (decl);\n+\t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+\t\t    {\n+\t\t      decl = gfc_conv_descriptor_data_get (decl);\n+\t\t      decl = fold_convert (build_pointer_type (char_type_node),\n+\t\t\t\t\t   decl);\n+\t\t      decl = build_fold_indirect_ref (decl);\n+\t\t    }\n+\t\t  else if (DECL_P (decl))\n+\t\t    TREE_ADDRESSABLE (decl) = 1;\n+\t\t  OMP_CLAUSE_DECL (node) = decl;\n \t\t}\n \t      else\n \t\t{\n@@ -1691,13 +1804,286 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t    }\n \t\t  gfc_add_block_to_block (block, &se.pre);\n \t\t  gfc_add_block_to_block (block, &se.post);\n-\t\t  OMP_CLAUSE_DECL (node)\n-\t\t    = fold_build1_loc (input_location, INDIRECT_REF,\n-\t\t\t\t       TREE_TYPE (TREE_TYPE (ptr)), ptr);\n+\t\t  ptr = fold_convert (build_pointer_type (char_type_node),\n+\t\t\t\t      ptr);\n+\t\t  OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (ptr);\n+\t\t}\n+\t      switch (n->u.depend_op)\n+\t\t{\n+\t\tcase OMP_DEPEND_IN:\n+\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_IN;\n+\t\t  break;\n+\t\tcase OMP_DEPEND_OUT:\n+\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_OUT;\n+\t\t  break;\n+\t\tcase OMP_DEPEND_INOUT:\n+\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_INOUT;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n+\t    }\n+\t  break;\n+\tcase OMP_LIST_MAP:\n+\t  for (; n != NULL; n = n->next)\n+\t    {\n+\t      if (!n->sym->attr.referenced)\n+\t\tcontinue;\n+\n+\t      tree node = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n+\t      tree node2 = NULL_TREE;\n+\t      tree node3 = NULL_TREE;\n+\t      tree node4 = NULL_TREE;\n+\t      tree decl = gfc_get_symbol_decl (n->sym);\n+\t      if (DECL_P (decl))\n+\t\tTREE_ADDRESSABLE (decl) = 1;\n+\t      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)\n+\t\t{\n+\t\t  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+\t\t    {\n+\t\t      node4 = build_omp_clause (input_location,\n+\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_MAP_KIND (node4) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_DECL (node4) = decl;\n+\t\t      OMP_CLAUSE_SIZE (node4) = size_int (0);\n+\t\t      decl = build_fold_indirect_ref (decl);\n+\t\t    }\n+\t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+\t\t    {\n+\t\t      tree type = TREE_TYPE (decl);\n+\t\t      tree ptr = gfc_conv_descriptor_data_get (decl);\n+\t\t      ptr = fold_convert (build_pointer_type (char_type_node),\n+\t\t\t\t\t  ptr);\n+\t\t      ptr = build_fold_indirect_ref (ptr);\n+\t\t      OMP_CLAUSE_DECL (node) = ptr;\n+\t\t      node2 = build_omp_clause (input_location,\n+\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_MAP_KIND (node2) = OMP_CLAUSE_MAP_TO_PSET;\n+\t\t      OMP_CLAUSE_DECL (node2) = decl;\n+\t\t      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n+\t\t      node3 = build_omp_clause (input_location,\n+\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_DECL (node3)\n+\t\t\t= gfc_conv_descriptor_data_get (decl);\n+\t\t      OMP_CLAUSE_SIZE (node3) = size_int (0);\n+\t\t      if (n->sym->attr.pointer)\n+\t\t\t{\n+\t\t\t  stmtblock_t cond_block;\n+\t\t\t  tree size\n+\t\t\t    = gfc_create_var (gfc_array_index_type, NULL);\n+\t\t\t  tree tem, then_b, else_b, zero, cond;\n+\n+\t\t\t  gfc_init_block (&cond_block);\n+\t\t\t  tem\n+\t\t\t    = gfc_full_array_size (&cond_block, decl,\n+\t\t\t\t\t\t   GFC_TYPE_ARRAY_RANK (type));\n+\t\t\t  gfc_add_modify (&cond_block, size, tem);\n+\t\t\t  then_b = gfc_finish_block (&cond_block);\n+\t\t\t  gfc_init_block (&cond_block);\n+\t\t\t  zero = build_int_cst (gfc_array_index_type, 0);\n+\t\t\t  gfc_add_modify (&cond_block, size, zero);\n+\t\t\t  else_b = gfc_finish_block (&cond_block);\n+\t\t\t  tem = gfc_conv_descriptor_data_get (decl);\n+\t\t\t  tem = fold_convert (pvoid_type_node, tem);\n+\t\t\t  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t\t  tem, null_pointer_node);\n+\t\t\t  gfc_add_expr_to_block (block,\n+\t\t\t\t\t\t build3_loc (input_location,\n+\t\t\t\t\t\t\t     COND_EXPR,\n+\t\t\t\t\t\t\t     void_type_node,\n+\t\t\t\t\t\t\t     cond, then_b,\n+\t\t\t\t\t\t\t     else_b));\n+\t\t\t  OMP_CLAUSE_SIZE (node) = size;\n+\t\t\t}\n+\t\t      else\n+\t\t\tOMP_CLAUSE_SIZE (node)\n+\t\t\t  = gfc_full_array_size (block, decl,\n+\t\t\t\t\t\t GFC_TYPE_ARRAY_RANK (type));\n+\t\t      tree elemsz\n+\t\t\t= TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+\t\t      elemsz = fold_convert (gfc_array_index_type, elemsz);\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t       OMP_CLAUSE_SIZE (node), elemsz);\n+\t\t    }\n+\t\t  else\n+\t\t    OMP_CLAUSE_DECL (node) = decl;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree ptr, ptr2;\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  if (n->expr->ref->u.ar.type == AR_ELEMENT)\n+\t\t    {\n+\t\t      gfc_conv_expr_reference (&se, n->expr);\n+\t\t      gfc_add_block_to_block (block, &se.pre);\n+\t\t      ptr = se.expr;\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= TYPE_SIZE_UNIT (TREE_TYPE (ptr));\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gfc_conv_expr_descriptor (&se, n->expr);\n+\t\t      ptr = gfc_conv_array_data (se.expr);\n+\t\t      tree type = TREE_TYPE (se.expr);\n+\t\t      gfc_add_block_to_block (block, &se.pre);\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= gfc_full_array_size (block, se.expr,\n+\t\t\t\t\t       GFC_TYPE_ARRAY_RANK (type));\n+\t\t      tree elemsz\n+\t\t\t= TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+\t\t      elemsz = fold_convert (gfc_array_index_type, elemsz);\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t       OMP_CLAUSE_SIZE (node), elemsz);\n+\t\t    }\n+\t\t  gfc_add_block_to_block (block, &se.post);\n+\t\t  ptr = fold_convert (build_pointer_type (char_type_node),\n+\t\t\t\t      ptr);\n+\t\t  OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (ptr);\n+\n+\t\t  if (POINTER_TYPE_P (TREE_TYPE (decl))\n+\t\t      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n+\t\t    {\n+\t\t      node4 = build_omp_clause (input_location,\n+\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_MAP_KIND (node4) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_DECL (node4) = decl;\n+\t\t      OMP_CLAUSE_SIZE (node4) = size_int (0);\n+\t\t      decl = build_fold_indirect_ref (decl);\n+\t\t    }\n+\t\t  ptr = fold_convert (sizetype, ptr);\n+\t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+\t\t    {\n+\t\t      tree type = TREE_TYPE (decl);\n+\t\t      ptr2 = gfc_conv_descriptor_data_get (decl);\n+\t\t      node2 = build_omp_clause (input_location,\n+\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_MAP_KIND (node2) = OMP_CLAUSE_MAP_TO_PSET;\n+\t\t      OMP_CLAUSE_DECL (node2) = decl;\n+\t\t      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n+\t\t      node3 = build_omp_clause (input_location,\n+\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_DECL (node3)\n+\t\t\t= gfc_conv_descriptor_data_get (decl);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+\t\t\tptr2 = build_fold_addr_expr (decl);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  gcc_assert (POINTER_TYPE_P (TREE_TYPE (decl)));\n+\t\t\t  ptr2 = decl;\n+\t\t\t}\n+\t\t      node3 = build_omp_clause (input_location,\n+\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_DECL (node3) = decl;\n+\t\t    }\n+\t\t  ptr2 = fold_convert (sizetype, ptr2);\n+\t\t  OMP_CLAUSE_SIZE (node3)\n+\t\t    = fold_build2 (MINUS_EXPR, sizetype, ptr, ptr2);\n+\t\t}\n+\t      switch (n->u.map_op)\n+\t\t{\n+\t\tcase OMP_MAP_ALLOC:\n+\t\t  OMP_CLAUSE_MAP_KIND (node) = OMP_CLAUSE_MAP_ALLOC;\n+\t\t  break;\n+\t\tcase OMP_MAP_TO:\n+\t\t  OMP_CLAUSE_MAP_KIND (node) = OMP_CLAUSE_MAP_TO;\n+\t\t  break;\n+\t\tcase OMP_MAP_FROM:\n+\t\t  OMP_CLAUSE_MAP_KIND (node) = OMP_CLAUSE_MAP_FROM;\n+\t\t  break;\n+\t\tcase OMP_MAP_TOFROM:\n+\t\t  OMP_CLAUSE_MAP_KIND (node) = OMP_CLAUSE_MAP_TOFROM;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n+\t      if (node2)\n+\t\tomp_clauses = gfc_trans_add_clause (node2, omp_clauses);\n+\t      if (node3)\n+\t\tomp_clauses = gfc_trans_add_clause (node3, omp_clauses);\n+\t      if (node4)\n+\t\tomp_clauses = gfc_trans_add_clause (node4, omp_clauses);\n+\t    }\n+\t  break;\n+\tcase OMP_LIST_TO:\n+\tcase OMP_LIST_FROM:\n+\t  for (; n != NULL; n = n->next)\n+\t    {\n+\t      if (!n->sym->attr.referenced)\n+\t\tcontinue;\n+\n+\t      tree node = build_omp_clause (input_location,\n+\t\t\t\t\t    list == OMP_LIST_TO\n+\t\t\t\t\t    ? OMP_CLAUSE_TO : OMP_CLAUSE_FROM);\n+\t      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)\n+\t\t{\n+\t\t  tree decl = gfc_get_symbol_decl (n->sym);\n+\t\t  if (gfc_omp_privatize_by_reference (decl))\n+\t\t    decl = build_fold_indirect_ref (decl);\n+\t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+\t\t    {\n+\t\t      tree type = TREE_TYPE (decl);\n+\t\t      tree ptr = gfc_conv_descriptor_data_get (decl);\n+\t\t      ptr = fold_convert (build_pointer_type (char_type_node),\n+\t\t\t\t\t  ptr);\n+\t\t      ptr = build_fold_indirect_ref (ptr);\n+\t\t      OMP_CLAUSE_DECL (node) = ptr;\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= gfc_full_array_size (block, decl,\n+\t\t\t\t\t       GFC_TYPE_ARRAY_RANK (type));\n+\t\t      tree elemsz\n+\t\t\t= TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+\t\t      elemsz = fold_convert (gfc_array_index_type, elemsz);\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t       OMP_CLAUSE_SIZE (node), elemsz);\n+\t\t    }\n+\t\t  else\n+\t\t    OMP_CLAUSE_DECL (node) = decl;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree ptr;\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  if (n->expr->ref->u.ar.type == AR_ELEMENT)\n+\t\t    {\n+\t\t      gfc_conv_expr_reference (&se, n->expr);\n+\t\t      ptr = se.expr;\n+\t\t      gfc_add_block_to_block (block, &se.pre);\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= TYPE_SIZE_UNIT (TREE_TYPE (ptr));\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gfc_conv_expr_descriptor (&se, n->expr);\n+\t\t      ptr = gfc_conv_array_data (se.expr);\n+\t\t      tree type = TREE_TYPE (se.expr);\n+\t\t      gfc_add_block_to_block (block, &se.pre);\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= gfc_full_array_size (block, se.expr,\n+\t\t\t\t\t       GFC_TYPE_ARRAY_RANK (type));\n+\t\t      tree elemsz\n+\t\t\t= TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+\t\t      elemsz = fold_convert (gfc_array_index_type, elemsz);\n+\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t= fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t       OMP_CLAUSE_SIZE (node), elemsz);\n+\t\t    }\n+\t\t  gfc_add_block_to_block (block, &se.post);\n+\t\t  ptr = fold_convert (build_pointer_type (char_type_node),\n+\t\t\t\t      ptr);\n+\t\t  OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (ptr);\n \t\t}\n-\t      OMP_CLAUSE_DEPEND_KIND (node)\n-\t\t= ((list == OMP_LIST_DEPEND_IN)\n-\t\t   ? OMP_CLAUSE_DEPEND_IN : OMP_CLAUSE_DEPEND_OUT);\n \t      omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n \t    }\n \t  break;\n@@ -1920,7 +2306,69 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n-  return omp_clauses;\n+  if (clauses->num_teams)\n+    {\n+      tree num_teams;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->num_teams);\n+      gfc_add_block_to_block (block, &se.pre);\n+      num_teams = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_NUM_TEAMS);\n+      OMP_CLAUSE_NUM_TEAMS_EXPR (c) = num_teams;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->device)\n+    {\n+      tree device;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->device);\n+      gfc_add_block_to_block (block, &se.pre);\n+      device = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_DEVICE);\n+      OMP_CLAUSE_DEVICE_ID (c) = device;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->thread_limit)\n+    {\n+      tree thread_limit;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->thread_limit);\n+      gfc_add_block_to_block (block, &se.pre);\n+      thread_limit = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_THREAD_LIMIT);\n+      OMP_CLAUSE_THREAD_LIMIT_EXPR (c) = thread_limit;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  chunk_size = NULL_TREE;\n+  if (clauses->dist_chunk_size)\n+    {\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->dist_chunk_size);\n+      gfc_add_block_to_block (block, &se.pre);\n+      chunk_size = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+    }\n+\n+  if (clauses->dist_sched_kind != OMP_SCHED_NONE)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_DIST_SCHEDULE);\n+      OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (c) = chunk_size;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  return nreverse (omp_clauses);\n }\n \n /* Like gfc_trans_code, but force creation of a BIND_EXPR around it.  */\n@@ -2329,12 +2777,13 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \n       if (clauses)\n \t{\n-\t  gfc_omp_namelist *n;\n-\t  for (n = clauses->lists[(op == EXEC_OMP_SIMD && collapse == 1)\n-\t\t\t\t  ? OMP_LIST_LINEAR : OMP_LIST_LASTPRIVATE];\n-\t       n != NULL; n = n->next)\n-\t    if (code->ext.iterator->var->symtree->n.sym == n->sym)\n-\t      break;\n+\t  gfc_omp_namelist *n = NULL;\n+\t  if (op != EXEC_OMP_DISTRIBUTE)\n+\t    for (n = clauses->lists[(op == EXEC_OMP_SIMD && collapse == 1)\n+\t\t\t\t    ? OMP_LIST_LINEAR : OMP_LIST_LASTPRIVATE];\n+\t\t n != NULL; n = n->next)\n+\t      if (code->ext.iterator->var->symtree->n.sym == n->sym)\n+\t\tbreak;\n \t  if (n != NULL)\n \t    dovar_found = 1;\n \t  else if (n == NULL && op != EXEC_OMP_SIMD)\n@@ -2554,7 +3003,13 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n     }\n \n   /* End of loop body.  */\n-  stmt = make_node (op == EXEC_OMP_SIMD ? OMP_SIMD : OMP_FOR);\n+  switch (op)\n+    {\n+    case EXEC_OMP_SIMD: stmt = make_node (OMP_SIMD); break;\n+    case EXEC_OMP_DO: stmt = make_node (OMP_FOR); break;\n+    case EXEC_OMP_DISTRIBUTE: stmt = make_node (OMP_DISTRIBUTE); break;\n+    default: gcc_unreachable ();\n+    }\n \n   TREE_TYPE (stmt) = void_type_node;\n   OMP_FOR_BODY (stmt) = gfc_finish_block (&body);\n@@ -2610,14 +3065,20 @@ enum\n   GFC_OMP_SPLIT_SIMD,\n   GFC_OMP_SPLIT_DO,\n   GFC_OMP_SPLIT_PARALLEL,\n+  GFC_OMP_SPLIT_DISTRIBUTE,\n+  GFC_OMP_SPLIT_TEAMS,\n+  GFC_OMP_SPLIT_TARGET,\n   GFC_OMP_SPLIT_NUM\n };\n \n enum\n {\n   GFC_OMP_MASK_SIMD = (1 << GFC_OMP_SPLIT_SIMD),\n   GFC_OMP_MASK_DO = (1 << GFC_OMP_SPLIT_DO),\n-  GFC_OMP_MASK_PARALLEL = (1 << GFC_OMP_SPLIT_PARALLEL)\n+  GFC_OMP_MASK_PARALLEL = (1 << GFC_OMP_SPLIT_PARALLEL),\n+  GFC_OMP_MASK_DISTRIBUTE = (1 << GFC_OMP_SPLIT_DISTRIBUTE),\n+  GFC_OMP_MASK_TEAMS = (1 << GFC_OMP_SPLIT_TEAMS),\n+  GFC_OMP_MASK_TARGET = (1 << GFC_OMP_SPLIT_TARGET)\n };\n \n static void\n@@ -2628,10 +3089,32 @@ gfc_split_omp_clauses (gfc_code *code,\n   memset (clausesa, 0, GFC_OMP_SPLIT_NUM * sizeof (gfc_omp_clauses));\n   switch (code->op)\n     {\n+    case EXEC_OMP_DISTRIBUTE:\n+      innermost = GFC_OMP_SPLIT_DISTRIBUTE;\n+      break;\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+      mask = GFC_OMP_MASK_DISTRIBUTE | GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO;\n+      innermost = GFC_OMP_SPLIT_DO;\n+      break;\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      mask = GFC_OMP_MASK_DISTRIBUTE | GFC_OMP_MASK_PARALLEL\n+\t     | GFC_OMP_MASK_DO | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    case EXEC_OMP_DISTRIBUTE_SIMD:\n+      mask = GFC_OMP_MASK_DISTRIBUTE | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    case EXEC_OMP_DO:\n+      innermost = GFC_OMP_SPLIT_DO;\n+      break;\n     case EXEC_OMP_DO_SIMD:\n       mask = GFC_OMP_MASK_DO | GFC_OMP_MASK_SIMD;\n       innermost = GFC_OMP_SPLIT_SIMD;\n       break;\n+    case EXEC_OMP_PARALLEL:\n+      innermost = GFC_OMP_SPLIT_PARALLEL;\n+      break;\n     case EXEC_OMP_PARALLEL_DO:\n       mask = GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO;\n       innermost = GFC_OMP_SPLIT_DO;\n@@ -2640,11 +3123,99 @@ gfc_split_omp_clauses (gfc_code *code,\n       mask = GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO | GFC_OMP_MASK_SIMD;\n       innermost = GFC_OMP_SPLIT_SIMD;\n       break;\n+    case EXEC_OMP_SIMD:\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    case EXEC_OMP_TARGET:\n+      innermost = GFC_OMP_SPLIT_TARGET;\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_TEAMS;\n+      innermost = GFC_OMP_SPLIT_TEAMS;\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_TEAMS\n+\t     | GFC_OMP_MASK_DISTRIBUTE;\n+      innermost = GFC_OMP_SPLIT_DISTRIBUTE;\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_TEAMS | GFC_OMP_MASK_DISTRIBUTE\n+\t     | GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO;\n+      innermost = GFC_OMP_SPLIT_DO;\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_TEAMS | GFC_OMP_MASK_DISTRIBUTE\n+\t     | GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+      mask = GFC_OMP_MASK_TARGET | GFC_OMP_MASK_TEAMS\n+\t     | GFC_OMP_MASK_DISTRIBUTE | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    case EXEC_OMP_TEAMS:\n+      innermost = GFC_OMP_SPLIT_TEAMS;\n+      break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+      mask = GFC_OMP_MASK_TEAMS | GFC_OMP_MASK_DISTRIBUTE;\n+      innermost = GFC_OMP_SPLIT_DISTRIBUTE;\n+      break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      mask = GFC_OMP_MASK_TEAMS | GFC_OMP_MASK_DISTRIBUTE\n+\t     | GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO;\n+      innermost = GFC_OMP_SPLIT_DO;\n+      break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      mask = GFC_OMP_MASK_TEAMS | GFC_OMP_MASK_DISTRIBUTE\n+\t     | GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n+      mask = GFC_OMP_MASK_TEAMS | GFC_OMP_MASK_DISTRIBUTE | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n+  if (mask == 0)\n+    {\n+      clausesa[innermost] = *code->ext.omp_clauses;\n+      return;\n+    }\n   if (code->ext.omp_clauses != NULL)\n     {\n+      if (mask & GFC_OMP_MASK_TARGET)\n+\t{\n+\t  /* First the clauses that are unique to some constructs.  */\n+\t  clausesa[GFC_OMP_SPLIT_TARGET].lists[OMP_LIST_MAP]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_MAP];\n+\t  clausesa[GFC_OMP_SPLIT_TARGET].device\n+\t    = code->ext.omp_clauses->device;\n+\t}\n+      if (mask & GFC_OMP_MASK_TEAMS)\n+\t{\n+\t  /* First the clauses that are unique to some constructs.  */\n+\t  clausesa[GFC_OMP_SPLIT_TEAMS].num_teams\n+\t    = code->ext.omp_clauses->num_teams;\n+\t  clausesa[GFC_OMP_SPLIT_TEAMS].thread_limit\n+\t    = code->ext.omp_clauses->thread_limit;\n+\t  /* Shared and default clauses are allowed on parallel and teams.  */\n+\t  clausesa[GFC_OMP_SPLIT_TEAMS].lists[OMP_LIST_SHARED]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_SHARED];\n+\t  clausesa[GFC_OMP_SPLIT_TEAMS].default_sharing\n+\t    = code->ext.omp_clauses->default_sharing;\n+\t}\n+      if (mask & GFC_OMP_MASK_DISTRIBUTE)\n+\t{\n+\t  /* First the clauses that are unique to some constructs.  */\n+\t  clausesa[GFC_OMP_SPLIT_DISTRIBUTE].dist_sched_kind\n+\t    = code->ext.omp_clauses->dist_sched_kind;\n+\t  clausesa[GFC_OMP_SPLIT_DISTRIBUTE].dist_chunk_size\n+\t    = code->ext.omp_clauses->dist_chunk_size;\n+\t  /* Duplicate collapse.  */\n+\t  clausesa[GFC_OMP_SPLIT_DISTRIBUTE].collapse\n+\t    = code->ext.omp_clauses->collapse;\n+\t}\n       if (mask & GFC_OMP_MASK_PARALLEL)\n \t{\n \t  /* First the clauses that are unique to some constructs.  */\n@@ -2659,9 +3230,6 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->lists[OMP_LIST_SHARED];\n \t  clausesa[GFC_OMP_SPLIT_PARALLEL].default_sharing\n \t    = code->ext.omp_clauses->default_sharing;\n-\t  /* FIXME: This is currently being discussed.  */\n-\t  clausesa[GFC_OMP_SPLIT_PARALLEL].if_expr\n-\t    = code->ext.omp_clauses->if_expr;\n \t}\n       if (mask & GFC_OMP_MASK_DO)\n \t{\n@@ -2701,6 +3269,12 @@ gfc_split_omp_clauses (gfc_code *code,\n       /* Firstprivate clause is supported on all constructs but\n \t target and simd.  Put it on the outermost of those and\n \t duplicate on parallel.  */\n+      if (mask & GFC_OMP_MASK_TEAMS)\n+\tclausesa[GFC_OMP_SPLIT_TEAMS].lists[OMP_LIST_FIRSTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_FIRSTPRIVATE];\n+      else if (mask & GFC_OMP_MASK_DISTRIBUTE)\n+\tclausesa[GFC_OMP_SPLIT_DISTRIBUTE].lists[OMP_LIST_FIRSTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_FIRSTPRIVATE];\n       if (mask & GFC_OMP_MASK_PARALLEL)\n \tclausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_FIRSTPRIVATE]\n \t  = code->ext.omp_clauses->lists[OMP_LIST_FIRSTPRIVATE];\n@@ -2722,6 +3296,9 @@ gfc_split_omp_clauses (gfc_code *code,\n       /* Reduction is allowed on simd, do, parallel and teams.\n \t Duplicate it on all of them, but omit on do if\n \t parallel is present.  */\n+      if (mask & GFC_OMP_MASK_TEAMS)\n+\tclausesa[GFC_OMP_SPLIT_TEAMS].lists[OMP_LIST_REDUCTION]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_REDUCTION];\n       if (mask & GFC_OMP_MASK_PARALLEL)\n \tclausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_REDUCTION]\n \t  = code->ext.omp_clauses->lists[OMP_LIST_REDUCTION];\n@@ -2731,21 +3308,31 @@ gfc_split_omp_clauses (gfc_code *code,\n       if (mask & GFC_OMP_MASK_SIMD)\n \tclausesa[GFC_OMP_SPLIT_SIMD].lists[OMP_LIST_REDUCTION]\n \t  = code->ext.omp_clauses->lists[OMP_LIST_REDUCTION];\n+      /* FIXME: This is currently being discussed.  */\n+      if (mask & GFC_OMP_MASK_PARALLEL)\n+\tclausesa[GFC_OMP_SPLIT_PARALLEL].if_expr\n+\t  = code->ext.omp_clauses->if_expr;\n+      else\n+\tclausesa[GFC_OMP_SPLIT_TARGET].if_expr\n+\t  = code->ext.omp_clauses->if_expr;\n     }\n   if ((mask & (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))\n       == (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))\n     clausesa[GFC_OMP_SPLIT_DO].nowait = true;\n }\n \n static tree\n-gfc_trans_omp_do_simd (gfc_code *code, gfc_omp_clauses *clausesa,\n-\t\t       tree omp_clauses)\n+gfc_trans_omp_do_simd (gfc_code *code, stmtblock_t *pblock,\n+\t\t       gfc_omp_clauses *clausesa, tree omp_clauses)\n {\n-  stmtblock_t block, *pblock = NULL;\n+  stmtblock_t block;\n   gfc_omp_clauses clausesa_buf[GFC_OMP_SPLIT_NUM];\n   tree stmt, body, omp_do_clauses = NULL_TREE;\n \n-  gfc_start_block (&block);\n+  if (pblock == NULL)\n+    gfc_start_block (&block);\n+  else\n+    gfc_init_block (&block);\n \n   if (clausesa == NULL)\n     {\n@@ -2755,13 +3342,17 @@ gfc_trans_omp_do_simd (gfc_code *code, gfc_omp_clauses *clausesa,\n   if (gfc_option.gfc_flag_openmp)\n     omp_do_clauses\n       = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_DO], code->loc);\n-  pblock = &block;\n-  body = gfc_trans_omp_do (code, EXEC_OMP_SIMD, pblock,\n+  body = gfc_trans_omp_do (code, EXEC_OMP_SIMD, pblock ? pblock : &block,\n \t\t\t   &clausesa[GFC_OMP_SPLIT_SIMD], omp_clauses);\n-  if (TREE_CODE (body) != BIND_EXPR)\n-    body = build3_v (BIND_EXPR, NULL, body, poplevel (1, 0));\n-  else\n-    poplevel (0, 0);\n+  if (pblock == NULL)\n+    {\n+      if (TREE_CODE (body) != BIND_EXPR)\n+\tbody = build3_v (BIND_EXPR, NULL, body, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+    }\n+  else if (TREE_CODE (body) != BIND_EXPR)\n+    body = build3_v (BIND_EXPR, NULL, body, NULL_TREE);\n   if (gfc_option.gfc_flag_openmp)\n     {\n       stmt = make_node (OMP_FOR);\n@@ -2776,29 +3367,45 @@ gfc_trans_omp_do_simd (gfc_code *code, gfc_omp_clauses *clausesa,\n }\n \n static tree\n-gfc_trans_omp_parallel_do (gfc_code *code)\n+gfc_trans_omp_parallel_do (gfc_code *code, stmtblock_t *pblock,\n+\t\t\t   gfc_omp_clauses *clausesa)\n {\n-  stmtblock_t block, *pblock = NULL;\n-  gfc_omp_clauses clausesa[GFC_OMP_SPLIT_NUM];\n+  stmtblock_t block, *new_pblock = pblock;\n+  gfc_omp_clauses clausesa_buf[GFC_OMP_SPLIT_NUM];\n   tree stmt, omp_clauses = NULL_TREE;\n \n-  gfc_start_block (&block);\n+  if (pblock == NULL)\n+    gfc_start_block (&block);\n+  else\n+    gfc_init_block (&block);\n \n-  gfc_split_omp_clauses (code, clausesa);\n+  if (clausesa == NULL)\n+    {\n+      clausesa = clausesa_buf;\n+      gfc_split_omp_clauses (code, clausesa);\n+    }\n   omp_clauses\n     = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_PARALLEL],\n \t\t\t     code->loc);\n-  if (!clausesa[GFC_OMP_SPLIT_DO].ordered\n-      && clausesa[GFC_OMP_SPLIT_DO].sched_kind != OMP_SCHED_STATIC)\n-    pblock = &block;\n-  else\n-    pushlevel ();\n-  stmt = gfc_trans_omp_do (code, EXEC_OMP_DO, pblock,\n+  if (pblock == NULL)\n+    {\n+      if (!clausesa[GFC_OMP_SPLIT_DO].ordered\n+\t  && clausesa[GFC_OMP_SPLIT_DO].sched_kind != OMP_SCHED_STATIC)\n+\tnew_pblock = &block;\n+      else\n+\tpushlevel ();\n+    }\n+  stmt = gfc_trans_omp_do (code, EXEC_OMP_DO, new_pblock,\n \t\t\t   &clausesa[GFC_OMP_SPLIT_DO], omp_clauses);\n-  if (TREE_CODE (stmt) != BIND_EXPR)\n-    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n-  else\n-    poplevel (0, 0);\n+  if (pblock == NULL)\n+    {\n+      if (TREE_CODE (stmt) != BIND_EXPR)\n+\tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+    }\n+  else if (TREE_CODE (stmt) != BIND_EXPR)\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, NULL_TREE);\n   stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n \t\t     omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n@@ -2807,25 +3414,39 @@ gfc_trans_omp_parallel_do (gfc_code *code)\n }\n \n static tree\n-gfc_trans_omp_parallel_do_simd (gfc_code *code)\n+gfc_trans_omp_parallel_do_simd (gfc_code *code, stmtblock_t *pblock,\n+\t\t\t\tgfc_omp_clauses *clausesa)\n {\n   stmtblock_t block;\n-  gfc_omp_clauses clausesa[GFC_OMP_SPLIT_NUM];\n+  gfc_omp_clauses clausesa_buf[GFC_OMP_SPLIT_NUM];\n   tree stmt, omp_clauses = NULL_TREE;\n \n-  gfc_start_block (&block);\n+  if (pblock == NULL)\n+    gfc_start_block (&block);\n+  else\n+    gfc_init_block (&block);\n \n-  gfc_split_omp_clauses (code, clausesa);\n+  if (clausesa == NULL)\n+    {\n+      clausesa = clausesa_buf;\n+      gfc_split_omp_clauses (code, clausesa);\n+    }\n   if (gfc_option.gfc_flag_openmp)\n     omp_clauses\n       = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_PARALLEL],\n \t\t\t       code->loc);\n-  pushlevel ();\n-  stmt = gfc_trans_omp_do_simd (code, clausesa, omp_clauses);\n-  if (TREE_CODE (stmt) != BIND_EXPR)\n-    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n-  else\n-    poplevel (0, 0);\n+  if (pblock == NULL)\n+    pushlevel ();\n+  stmt = gfc_trans_omp_do_simd (code, pblock, clausesa, omp_clauses);\n+  if (pblock == NULL)\n+    {\n+      if (TREE_CODE (stmt) != BIND_EXPR)\n+\tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+    }\n+  else if (TREE_CODE (stmt) != BIND_EXPR)\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, NULL_TREE);\n   if (gfc_option.gfc_flag_openmp)\n     {\n       stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n@@ -2968,6 +3589,170 @@ gfc_trans_omp_taskyield (void)\n   return build_call_expr_loc (input_location, decl, 0);\n }\n \n+static tree\n+gfc_trans_omp_distribute (gfc_code *code, gfc_omp_clauses *clausesa)\n+{\n+  stmtblock_t block;\n+  gfc_omp_clauses clausesa_buf[GFC_OMP_SPLIT_NUM];\n+  tree stmt, omp_clauses = NULL_TREE;\n+\n+  gfc_start_block (&block);\n+  if (clausesa == NULL)\n+    {\n+      clausesa = clausesa_buf;\n+      gfc_split_omp_clauses (code, clausesa);\n+    }\n+  if (gfc_option.gfc_flag_openmp)\n+    omp_clauses\n+      = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_DISTRIBUTE],\n+\t\t\t       code->loc);\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_DISTRIBUTE:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+      /* This is handled in gfc_trans_omp_do.  */\n+      gcc_unreachable ();\n+      break;\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+      stmt = gfc_trans_omp_parallel_do (code, &block, clausesa);\n+      if (TREE_CODE (stmt) != BIND_EXPR)\n+\tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+      break;\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+      stmt = gfc_trans_omp_parallel_do_simd (code, &block, clausesa);\n+      if (TREE_CODE (stmt) != BIND_EXPR)\n+\tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+      break;\n+    case EXEC_OMP_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n+      stmt = gfc_trans_omp_do (code, EXEC_OMP_SIMD, &block,\n+\t\t\t       &clausesa[GFC_OMP_SPLIT_SIMD], NULL_TREE);\n+      if (TREE_CODE (stmt) != BIND_EXPR)\n+\tstmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+      else\n+\tpoplevel (0, 0);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (gfc_option.gfc_flag_openmp)\n+    {\n+      tree distribute = make_node (OMP_DISTRIBUTE);\n+      TREE_TYPE (distribute) = void_type_node;\n+      OMP_FOR_BODY (distribute) = stmt;\n+      OMP_FOR_CLAUSES (distribute) = omp_clauses;\n+      stmt = distribute;\n+    }\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_teams (gfc_code *code, gfc_omp_clauses *clausesa)\n+{\n+  stmtblock_t block;\n+  gfc_omp_clauses clausesa_buf[GFC_OMP_SPLIT_NUM];\n+  tree stmt, omp_clauses = NULL_TREE;\n+\n+  gfc_start_block (&block);\n+  if (clausesa == NULL)\n+    {\n+      clausesa = clausesa_buf;\n+      gfc_split_omp_clauses (code, clausesa);\n+    }\n+  if (gfc_option.gfc_flag_openmp)\n+    omp_clauses\n+      = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_TEAMS],\n+\t\t\t       code->loc);\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_TARGET_TEAMS:\n+    case EXEC_OMP_TEAMS:\n+      stmt = gfc_trans_omp_code (code->block->next, true);\n+      break;\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+      stmt = gfc_trans_omp_do (code, EXEC_OMP_DISTRIBUTE, NULL,\n+\t\t\t       &clausesa[GFC_OMP_SPLIT_DISTRIBUTE],\n+\t\t\t       NULL);\n+      break;\n+    default:\n+      stmt = gfc_trans_omp_distribute (code, clausesa);\n+      break;\n+    }\n+  stmt = build2_loc (input_location, OMP_TEAMS, void_type_node, stmt,\n+\t\t     omp_clauses);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_target (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  gfc_omp_clauses clausesa[GFC_OMP_SPLIT_NUM];\n+  tree stmt, omp_clauses = NULL_TREE;\n+\n+  gfc_start_block (&block);\n+  gfc_split_omp_clauses (code, clausesa);\n+  if (gfc_option.gfc_flag_openmp)\n+    omp_clauses\n+      = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_TARGET],\n+\t\t\t       code->loc);\n+  if (code->op == EXEC_OMP_TARGET)\n+    stmt = gfc_trans_omp_code (code->block->next, true);\n+  else\n+    stmt = gfc_trans_omp_teams (code, clausesa);\n+  if (TREE_CODE (stmt) != BIND_EXPR)\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, NULL_TREE);\n+  if (gfc_option.gfc_flag_openmp)\n+    stmt = build2_loc (input_location, OMP_TARGET, void_type_node, stmt,\n+\t\t       omp_clauses);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_target_data (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, omp_clauses;\n+\n+  gfc_start_block (&block);\n+  omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t       code->loc);\n+  stmt = gfc_trans_omp_code (code->block->next, true);\n+  stmt = build2_loc (input_location, OMP_TARGET_DATA, void_type_node, stmt,\n+\t\t     omp_clauses);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_target_update (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, omp_clauses;\n+\n+  gfc_start_block (&block);\n+  omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t       code->loc);\n+  stmt = build1_loc (input_location, OMP_TARGET_UPDATE, void_type_node,\n+\t\t     omp_clauses);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n static tree\n gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n {\n@@ -3141,12 +3926,17 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_cancellation_point (code);\n     case EXEC_OMP_CRITICAL:\n       return gfc_trans_omp_critical (code);\n+    case EXEC_OMP_DISTRIBUTE:\n     case EXEC_OMP_DO:\n     case EXEC_OMP_SIMD:\n       return gfc_trans_omp_do (code, code->op, NULL, code->ext.omp_clauses,\n \t\t\t       NULL);\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_DISTRIBUTE_SIMD:\n+      return gfc_trans_omp_distribute (code, NULL);\n     case EXEC_OMP_DO_SIMD:\n-      return gfc_trans_omp_do_simd (code, NULL, NULL_TREE);\n+      return gfc_trans_omp_do_simd (code, NULL, NULL, NULL_TREE);\n     case EXEC_OMP_FLUSH:\n       return gfc_trans_omp_flush ();\n     case EXEC_OMP_MASTER:\n@@ -3156,9 +3946,9 @@ gfc_trans_omp_directive (gfc_code *code)\n     case EXEC_OMP_PARALLEL:\n       return gfc_trans_omp_parallel (code);\n     case EXEC_OMP_PARALLEL_DO:\n-      return gfc_trans_omp_parallel_do (code);\n+      return gfc_trans_omp_parallel_do (code, NULL, NULL);\n     case EXEC_OMP_PARALLEL_DO_SIMD:\n-      return gfc_trans_omp_parallel_do_simd (code);\n+      return gfc_trans_omp_parallel_do_simd (code, NULL, NULL);\n     case EXEC_OMP_PARALLEL_SECTIONS:\n       return gfc_trans_omp_parallel_sections (code);\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n@@ -3167,6 +3957,17 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_sections (code, code->ext.omp_clauses);\n     case EXEC_OMP_SINGLE:\n       return gfc_trans_omp_single (code, code->ext.omp_clauses);\n+    case EXEC_OMP_TARGET:\n+    case EXEC_OMP_TARGET_TEAMS:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+      return gfc_trans_omp_target (code);\n+    case EXEC_OMP_TARGET_DATA:\n+      return gfc_trans_omp_target_data (code);\n+    case EXEC_OMP_TARGET_UPDATE:\n+      return gfc_trans_omp_target_update (code);\n     case EXEC_OMP_TASK:\n       return gfc_trans_omp_task (code);\n     case EXEC_OMP_TASKGROUP:\n@@ -3175,6 +3976,12 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_taskwait ();\n     case EXEC_OMP_TASKYIELD:\n       return gfc_trans_omp_taskyield ();\n+    case EXEC_OMP_TEAMS:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n+      return gfc_trans_omp_teams (code, NULL);\n     case EXEC_OMP_WORKSHARE:\n       return gfc_trans_omp_workshare (code, code->ext.omp_clauses);\n     default:"}, {"sha": "1925506594ca5ac3102a1e01c2e505000acb07d7", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1851,6 +1851,10 @@ trans_code (gfc_code * code, tree cond)\n \tcase EXEC_OMP_CANCEL:\n \tcase EXEC_OMP_CANCELLATION_POINT:\n \tcase EXEC_OMP_CRITICAL:\n+\tcase EXEC_OMP_DISTRIBUTE:\n+\tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_DISTRIBUTE_SIMD:\n \tcase EXEC_OMP_DO:\n \tcase EXEC_OMP_DO_SIMD:\n \tcase EXEC_OMP_FLUSH:\n@@ -1864,10 +1868,23 @@ trans_code (gfc_code * code, tree cond)\n \tcase EXEC_OMP_SECTIONS:\n \tcase EXEC_OMP_SIMD:\n \tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_TARGET:\n+\tcase EXEC_OMP_TARGET_DATA:\n+\tcase EXEC_OMP_TARGET_TEAMS:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:\n+\tcase EXEC_OMP_TARGET_UPDATE:\n \tcase EXEC_OMP_TASK:\n \tcase EXEC_OMP_TASKGROUP:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n+\tcase EXEC_OMP_TEAMS:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:\n+\tcase EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:\n \tcase EXEC_OMP_WORKSHARE:\n \t  res = gfc_trans_omp_directive (code);\n \t  break;"}, {"sha": "c272c0d819e808b072c78896a05821c745e2de6f", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -671,6 +671,7 @@ tree gfc_omp_clause_default_ctor (tree, tree, tree);\n tree gfc_omp_clause_copy_ctor (tree, tree, tree);\n tree gfc_omp_clause_assign_op (tree, tree, tree);\n tree gfc_omp_clause_dtor (tree, tree);\n+void gfc_omp_finish_clause (tree, gimple_seq *);\n bool gfc_omp_disregard_value_expr (tree, bool);\n bool gfc_omp_private_debug_clause (tree, bool);\n bool gfc_omp_private_outer_ref (tree);"}, {"sha": "2efc8992008c1a64608e7376e3525a918aae1af6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -5650,6 +5650,7 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n   n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n   if (ctx->region_type == ORT_TARGET)\n     {\n+      ret = lang_hooks.decls.omp_disregard_value_expr (decl, true);\n       if (n == NULL)\n \t{\n \t  if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (decl)))\n@@ -5662,8 +5663,12 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t    omp_add_variable (ctx, decl, GOVD_MAP | flags);\n \t}\n       else\n-\tn->value |= flags;\n-      ret = lang_hooks.decls.omp_disregard_value_expr (decl, true);\n+\t{\n+\t  /* If nothing changed, there's nothing left to do.  */\n+\t  if ((n->value & flags) == flags)\n+\t    return ret;\n+\t  n->value |= flags;\n+\t}\n       goto do_outer;\n     }\n \n@@ -6201,13 +6206,21 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n   gimplify_omp_ctxp = ctx;\n }\n \n+struct gimplify_adjust_omp_clauses_data\n+{\n+  tree *list_p;\n+  gimple_seq *pre_p;\n+};\n+\n /* For all variables that were not actually used within the context,\n    remove PRIVATE, SHARED, and FIRSTPRIVATE clauses.  */\n \n static int\n gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n {\n-  tree *list_p = (tree *) data;\n+  tree *list_p = ((struct gimplify_adjust_omp_clauses_data *) data)->list_p;\n+  gimple_seq *pre_p\n+    = ((struct gimplify_adjust_omp_clauses_data *) data)->pre_p;\n   tree decl = (tree) n->key;\n   unsigned flags = n->value;\n   enum omp_clause_code code;\n@@ -6308,15 +6321,21 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n       OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (nc) = 1;\n       OMP_CLAUSE_CHAIN (nc) = *list_p;\n       OMP_CLAUSE_CHAIN (clause) = nc;\n-      lang_hooks.decls.omp_finish_clause (nc);\n+      struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+      gimplify_omp_ctxp = ctx->outer_context;\n+      lang_hooks.decls.omp_finish_clause (nc, pre_p);\n+      gimplify_omp_ctxp = ctx;\n     }\n   *list_p = clause;\n-  lang_hooks.decls.omp_finish_clause (clause);\n+  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+  gimplify_omp_ctxp = ctx->outer_context;\n+  lang_hooks.decls.omp_finish_clause (clause, pre_p);\n+  gimplify_omp_ctxp = ctx;\n   return 0;\n }\n \n static void\n-gimplify_adjust_omp_clauses (tree *list_p)\n+gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n {\n   struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n   tree c, decl;\n@@ -6521,7 +6540,10 @@ gimplify_adjust_omp_clauses (tree *list_p)\n     }\n \n   /* Add in any implicit data sharing.  */\n-  splay_tree_foreach (ctx->variables, gimplify_adjust_omp_clauses_1, list_p);\n+  struct gimplify_adjust_omp_clauses_data data;\n+  data.list_p = list_p;\n+  data.pre_p = pre_p;\n+  splay_tree_foreach (ctx->variables, gimplify_adjust_omp_clauses_1, &data);\n \n   gimplify_omp_ctxp = ctx->outer_context;\n   delete_omp_context (ctx);\n@@ -6552,7 +6574,7 @@ gimplify_omp_parallel (tree *expr_p, gimple_seq *pre_p)\n   else\n     pop_gimplify_context (NULL);\n \n-  gimplify_adjust_omp_clauses (&OMP_PARALLEL_CLAUSES (expr));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_PARALLEL_CLAUSES (expr));\n \n   g = gimple_build_omp_parallel (body,\n \t\t\t\t OMP_PARALLEL_CLAUSES (expr),\n@@ -6588,7 +6610,7 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n   else\n     pop_gimplify_context (NULL);\n \n-  gimplify_adjust_omp_clauses (&OMP_TASK_CLAUSES (expr));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_TASK_CLAUSES (expr));\n \n   g = gimple_build_omp_task (body,\n \t\t\t     OMP_TASK_CLAUSES (expr),\n@@ -6934,7 +6956,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \tTREE_OPERAND (TREE_OPERAND (t, 1), 0) = var;\n       }\n \n-  gimplify_adjust_omp_clauses (&OMP_FOR_CLAUSES (orig_for_stmt));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_FOR_CLAUSES (orig_for_stmt));\n \n   int kind;\n   switch (TREE_CODE (orig_for_stmt))\n@@ -7034,7 +7056,7 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     }\n   else\n     gimplify_and_add (OMP_BODY (expr), &body);\n-  gimplify_adjust_omp_clauses (&OMP_CLAUSES (expr));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_CLAUSES (expr));\n \n   switch (TREE_CODE (expr))\n     {\n@@ -7073,7 +7095,7 @@ gimplify_omp_target_update (tree *expr_p, gimple_seq *pre_p)\n \n   gimplify_scan_omp_clauses (&OMP_TARGET_UPDATE_CLAUSES (expr), pre_p,\n \t\t\t     ORT_WORKSHARE);\n-  gimplify_adjust_omp_clauses (&OMP_TARGET_UPDATE_CLAUSES (expr));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_TARGET_UPDATE_CLAUSES (expr));\n   stmt = gimple_build_omp_target (NULL, GF_OMP_TARGET_KIND_UPDATE,\n \t\t\t\t  OMP_TARGET_UPDATE_CLAUSES (expr));\n "}, {"sha": "76bb907151b8ce85602a7b2055445c80302149c3", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -75,6 +75,7 @@ extern bool lhd_handle_option (size_t, const char *, int, int, location_t,\n extern int lhd_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n extern enum omp_clause_default_kind lhd_omp_predetermined_sharing (tree);\n extern tree lhd_omp_assignment (tree, tree, tree);\n+extern void lhd_omp_finish_clause (tree, gimple_seq *);\n struct gimplify_omp_ctx;\n extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n \t\t\t\t\t       tree);\n@@ -215,7 +216,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR lhd_omp_assignment\n #define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP lhd_omp_assignment\n #define LANG_HOOKS_OMP_CLAUSE_DTOR hook_tree_tree_tree_null\n-#define LANG_HOOKS_OMP_FINISH_CLAUSE hook_void_tree\n+#define LANG_HOOKS_OMP_FINISH_CLAUSE lhd_omp_finish_clause\n \n #define LANG_HOOKS_DECLS { \\\n   LANG_HOOKS_GLOBAL_BINDINGS_P, \\"}, {"sha": "add08566cbd6feabb4cc9965ec39665f850d83bf", "filename": "gcc/langhooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -515,6 +515,13 @@ lhd_omp_assignment (tree clause ATTRIBUTE_UNUSED, tree dst, tree src)\n   return build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n }\n \n+/* Finalize clause C.  */\n+\n+void\n+lhd_omp_finish_clause (tree, gimple_seq *)\n+{\n+}\n+\n /* Register language specific type size variables as potentially OpenMP\n    firstprivate variables.  */\n "}, {"sha": "33aa55833b3d14f704817b343091655f552cf283", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -230,7 +230,7 @@ struct lang_hooks_for_decls\n   tree (*omp_clause_dtor) (tree clause, tree decl);\n \n   /* Do language specific checking on an implicitly determined clause.  */\n-  void (*omp_finish_clause) (tree clause);\n+  void (*omp_finish_clause) (tree clause, gimple_seq *pre_p);\n };\n \n /* Language hooks related to LTO serialization.  */"}, {"sha": "a30ce5aa13597e32851fa9b7571127bb02244b91", "filename": "gcc/omp-low.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1678,6 +1678,11 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\t}\n \t      else\n \t\t{\n+\t\t  if (ctx->outer)\n+\t\t    {\n+\t\t      scan_omp_op (&OMP_CLAUSE_DECL (c), ctx->outer);\n+\t\t      decl = OMP_CLAUSE_DECL (c);\n+\t\t    }\n \t\t  gcc_assert (!splay_tree_lookup (ctx->field_map,\n \t\t\t\t\t\t  (splay_tree_key) decl));\n \t\t  tree field\n@@ -2011,6 +2016,7 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n \t      tree temp = create_tmp_var (type, NULL);\n \t      tree c = build_omp_clause (UNKNOWN_LOCATION,\n \t\t\t\t\t OMP_CLAUSE__LOOPTEMP_);\n+\t      insert_decl_map (&outer_ctx->cb, temp, temp);\n \t      OMP_CLAUSE_DECL (c) = temp;\n \t      OMP_CLAUSE_CHAIN (c) = gimple_omp_parallel_clauses (stmt);\n \t      gimple_omp_parallel_set_clauses (stmt, c);\n@@ -2508,6 +2514,23 @@ check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n \t  return false;\n \t}\n       break;\n+    case GIMPLE_OMP_TARGET:\n+      for (; ctx != NULL; ctx = ctx->outer)\n+\tif (gimple_code (ctx->stmt) == GIMPLE_OMP_TARGET\n+\t    && gimple_omp_target_kind (ctx->stmt) == GF_OMP_TARGET_KIND_REGION)\n+\t  {\n+\t    const char *name;\n+\t    switch (gimple_omp_target_kind (stmt))\n+\t      {\n+\t      case GF_OMP_TARGET_KIND_REGION: name = \"target\"; break;\n+\t      case GF_OMP_TARGET_KIND_DATA: name = \"target data\"; break;\n+\t      case GF_OMP_TARGET_KIND_UPDATE: name = \"target update\"; break;\n+\t      default: gcc_unreachable ();\n+\t      }\n+\t    warning_at (gimple_location (stmt), 0,\n+\t\t\t\"%s construct inside of target region\", name);\n+\t  }\n+      break;\n     default:\n       break;\n     }\n@@ -9041,7 +9064,10 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n \t    }\n \t  else\n-\t    temp = create_tmp_var (type, NULL);\n+\t    {\n+\t      temp = create_tmp_var (type, NULL);\n+\t      insert_decl_map (&ctx->outer->cb, temp, temp);\n+\t    }\n \t  *pc = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__LOOPTEMP_);\n \t  OMP_CLAUSE_DECL (*pc) = temp;\n \t  pc = &OMP_CLAUSE_CHAIN (*pc);"}, {"sha": "9b76f2394abec8abb165786bbb5ff7eb3deba838", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1,3 +1,14 @@\n+2014-06-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.dg/gomp/declare-simd-1.f90: New test.\n+\t* gfortran.dg/gomp/depend-1.f90: New test.\n+\t* gfortran.dg/gomp/target1.f90: New test.\n+\t* gfortran.dg/gomp/target2.f90: New test.\n+\t* gfortran.dg/gomp/target3.f90: New test.\n+\t* gfortran.dg/gomp/udr4.f90: Adjust expected diagnostics.\n+\t* gfortran.dg/openmp-define-3.f90: Expect _OPENMP 201307 instead of\n+\t201107.\n+\n 2014-06-18  Dominique d'Humieres <dominiq@lps.ens.fr>\n \n \tPR fortran/61126"}, {"sha": "d6ae7c9c8126e02aa88438087f8a43385f38d7f8", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-simd-1.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-simd-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-simd-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-simd-1.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+\n+subroutine fn1 (x)\n+  integer :: x\n+!$omp declare simd (fn1) inbranch notinbranch uniform (x) ! { dg-error \"Unclassifiable OpenMP directive\" }\n+end subroutine fn1\n+subroutine fn2 (x)\n+!$omp declare simd (fn100)\t! { dg-error \"should refer to containing procedure\" }\n+end subroutine fn2"}, {"sha": "bd6d26a383087dc6a4bd201cb14371ae632e89b1", "filename": "gcc/testsuite/gfortran.dg/gomp/depend-1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-1.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+\n+subroutine foo (x)\n+  integer :: x(5, *)\n+!$omp parallel\n+!$omp single\n+!$omp task depend(in:x(:,5))\n+!$omp end task\n+!$omp task depend(in:x(5,:))\t! { dg-error \"Rightmost upper bound of assumed size array section|proper array section\" }\n+!$omp end task\n+!$omp end single\n+!$omp end parallel\n+end"}, {"sha": "14db4970bdcb6834aac79dc5b171d587c98dcb16", "filename": "gcc/testsuite/gfortran.dg/gomp/target1.f90", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget1.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,520 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp\" }\n+\n+module target1\n+  interface\n+    subroutine dosomething (a, n, m)\n+      integer :: a (:), n, m\n+      !$omp declare target\n+    end subroutine dosomething\n+  end interface\n+contains\n+  subroutine foo (n, o, p, q, r, pp)\n+    integer :: n, o, p, q, r, s, i, j\n+    integer :: a (2:o)\n+    integer, pointer :: pp\n+  !$omp target data device (n + 1) if (n .ne. 6) map (tofrom: n, r)\n+    !$omp target device (n + 1) if (n .ne. 6) map (from: n) map (alloc: a(2:o))\n+      call dosomething (a, n, 0)\n+    !$omp end target\n+    !$omp target teams device (n + 1) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r)\n+      r = r + 1\n+      p = q\n+      call dosomething (a, n, p + q)\n+    !$omp end target teams\n+    !$omp target teams distribute device (n + 1) num_teams (n + 4) collapse (2) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+      end do\n+    !$omp target teams distribute device (n + 1) num_teams (n + 4) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+      end do\n+    !$omp end target teams distribute\n+    !$omp target teams distribute parallel do device (n + 1) num_teams (n + 4) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) collapse (2) &\n+    !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s) &\n+    !$omp & ordered schedule (static, 8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+\t  !$omp ordered\n+\t    p = q\n+\t  !$omp end ordered\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp target teams distribute parallel do device (n + 1) num_teams (n + 4) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) &\n+    !$omp & proc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+        !$omp ordered\n+          p = q\n+        !$omp end ordered\n+\ts = i * 10\n+      end do\n+    !$omp end target teams distribute parallel do\n+    !$omp target teams distribute parallel do simd device (n + 1) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) collapse (2) &\n+    !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s) &\n+    !$omp & schedule (static, 8) num_teams (n + 4) safelen(8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          a(2+i*10+j) = p + q\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp target teams distribute parallel do simd device (n + 1) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) &\n+    !$omp & proc_bind (master) lastprivate (s) schedule (static, 8) &\n+    !$omp & num_teams (n + 4) safelen(16) linear(i:1) aligned (pp:4)\n+      do i = 1, 10\n+        r = r + 1\n+        p = q\n+        a(1+i) = p + q\n+\ts = i * 10\n+      end do\n+    !$omp end target teams distribute parallel do simd\n+    !$omp target teams distribute simd device (n + 1) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) collapse (2) &\n+    !$omp & lastprivate (s) num_teams (n + 4) safelen(8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          a(2+i*10+j) = p + q\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp target teams distribute simd device (n + 1) &\n+    !$omp & if (n .ne. 6)map (from: n) map (alloc: a(2:o)) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) lastprivate (s) &\n+    !$omp & num_teams (n + 4) safelen(16) linear(i:1) aligned (pp:4)\n+      do i = 1, 10\n+        r = r + 1\n+        p = q\n+        a(1+i) = p + q\n+\ts = i * 10\n+      end do\n+    !$omp end target teams distribute simd\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams num_teams (n + 4) thread_limit (n * 2) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r)\n+      r = r + 1\n+      p = q\n+      call dosomething (a, n, p + q)\n+    !$omp end teams\n+    !$omp end target\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams distribute num_teams (n + 4) collapse (2) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+      end do\n+    !$omp end target\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams distribute num_teams (n + 4) default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+      end do\n+    !$omp end teams distribute\n+    !$omp end target\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams distribute parallel do num_teams (n + 4) &\n+    !$omp & if (n .ne. 6) default(shared) ordered schedule (static, 8) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) collapse (2) &\n+    !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+\t  !$omp ordered\n+\t    p = q\n+\t  !$omp end ordered\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams distribute parallel do num_teams (n + 4)if(n.ne.6)default(shared)&\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) &\n+    !$omp & proc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+        !$omp ordered\n+          p = q\n+        !$omp end ordered\n+\ts = i * 10\n+      end do\n+    !$omp end teams distribute parallel do\n+    !$omp end target\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams distribute parallel do simd if(n.ne.6)default(shared)&\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) collapse (2) &\n+    !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s) &\n+    !$omp & schedule (static, 8) num_teams (n + 4) safelen(8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          a(2+i*10+j) = p + q\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams distribute parallel do simd if (n .ne. 6)default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) &\n+    !$omp & proc_bind (master) lastprivate (s) schedule (static, 8) &\n+    !$omp & num_teams (n + 4) safelen(16) linear(i:1) aligned (pp:4)\n+      do i = 1, 10\n+        r = r + 1\n+        p = q\n+        a(1+i) = p + q\n+\ts = i * 10\n+      end do\n+    !$omp end teams distribute parallel do simd\n+    !$omp end target\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams distribute simd default(shared) safelen(8) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) collapse (2) &\n+    !$omp & lastprivate (s) num_teams (n + 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          a(2+i*10+j) = p + q\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target\n+    !$omp target device (n + 1) if (n .ne. 6)map (from: n) map (alloc: a(2:o))\n+    !$omp teams distribute simd default(shared) aligned (pp:4) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & thread_limit (n * 2) dist_schedule (static, 4) lastprivate (s)\n+      do i = 1, 10\n+        r = r + 1\n+        p = q\n+        a(1+i) = p + q\n+\ts = i * 10\n+      end do\n+    !$omp end teams distribute simd\n+    !$omp end target\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction ( + : r )\n+    !$omp distribute collapse (2) firstprivate (q) dist_schedule (static, 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+      end do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute firstprivate (q) dist_schedule (static, 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+      end do\n+    !$omp end distribute\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute parallel do if (n .ne. 6) default(shared) &\n+    !$omp & ordered schedule (static, 8) private (p) firstprivate (q) &\n+    !$omp & shared(n)reduction(+:r)dist_schedule(static,4)collapse(2)&\n+    !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+\t  !$omp ordered\n+\t    p = q\n+\t  !$omp end ordered\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute parallel do if(n.ne.6)default(shared)&\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) num_threads (n + 4) &\n+    !$omp & proc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+        !$omp ordered\n+          p = q\n+        !$omp end ordered\n+\ts = i * 10\n+      end do\n+    !$omp end distribute parallel do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute parallel do simd if(n.ne.6)default(shared)&\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) collapse (2) safelen(8) &\n+    !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s) &\n+    !$omp & schedule (static, 8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          a(2+i*10+j) = p + q\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute parallel do simd if (n .ne. 6)default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) num_threads (n + 4) &\n+    !$omp & proc_bind (master) lastprivate (s) schedule (static, 8) &\n+    !$omp & safelen(16) linear(i:1) aligned (pp:4)\n+      do i = 1, 10\n+        r = r + 1\n+        p = q\n+        a(1+i) = p + q\n+\ts = i * 10\n+      end do\n+    !$omp end distribute parallel do simd\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute simd safelen(8) lastprivate(s) &\n+    !$omp & private (p) firstprivate (q) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) collapse (2)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          a(2+i*10+j) = p + q\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute simd aligned (pp:4) &\n+    !$omp & private (p) firstprivate (q) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) lastprivate (s)\n+      do i = 1, 10\n+        r = r + 1\n+        p = q\n+        a(1+i) = p + q\n+\ts = i * 10\n+      end do\n+    !$omp end distribute simd\n+    !$omp end target teams\n+  !$omp end target data\n+  end subroutine\n+  subroutine bar (n, o, p, r, pp)\n+    integer :: n, o, p, q, r, s, i, j\n+    integer :: a (2:o)\n+    integer, pointer :: pp\n+    common /blk/ i, j, q\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction ( + : r )\n+    !$omp distribute collapse (2) firstprivate (q) dist_schedule (static, 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+      end do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute firstprivate (q) dist_schedule (static, 4)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+      end do\n+    !$omp end distribute\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute parallel do if (n .ne. 6) default(shared) &\n+    !$omp & ordered schedule (static, 8) private (p) firstprivate (q) &\n+    !$omp & shared(n)reduction(+:r)dist_schedule(static,4)collapse(2)&\n+    !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+\t  !$omp ordered\n+\t    p = q\n+\t  !$omp end ordered\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute parallel do if(n.ne.6)default(shared)&\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) num_threads (n + 4) &\n+    !$omp & proc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          call dosomething (a, n, p + q)\n+        end do\n+        !$omp ordered\n+          p = q\n+        !$omp end ordered\n+\ts = i * 10\n+      end do\n+    !$omp end distribute parallel do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute parallel do simd if(n.ne.6)default(shared)&\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) collapse (2) safelen(8) &\n+    !$omp & num_threads (n + 4) proc_bind (spread) lastprivate (s) &\n+    !$omp & schedule (static, 8)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          a(2+i*10+j) = p + q\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute parallel do simd if (n .ne. 6)default(shared) &\n+    !$omp & private (p) firstprivate (q) shared (n) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) num_threads (n + 4) &\n+    !$omp & proc_bind (master) lastprivate (s) schedule (static, 8) &\n+    !$omp & safelen(16) linear(i:1) aligned (pp:4)\n+      do i = 1, 10\n+        r = r + 1\n+        p = q\n+        a(1+i) = p + q\n+\ts = i * 10\n+      end do\n+    !$omp end distribute parallel do simd\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute simd safelen(8) lastprivate(s) &\n+    !$omp & private (p) firstprivate (q) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) collapse (2)\n+      do i = 1, 10\n+        do j = 1, 10\n+          r = r + 1\n+          p = q\n+          a(2+i*10+j) = p + q\n+\t  s = i * 10 + j\n+        end do\n+      end do\n+    !$omp end target teams\n+    !$omp target teams device (n + 1) if (n .ne. 6)map (from: n) &\n+    !$omp & map (alloc: a(2:o)) num_teams (n + 4) thread_limit (n * 2) &\n+    !$omp & default(shared) shared(n) private (p) reduction(+:r)\n+    !$omp distribute simd aligned (pp:4) &\n+    !$omp & private (p) firstprivate (q) reduction (+: r) &\n+    !$omp & dist_schedule (static, 4) lastprivate (s)\n+      do i = 1, 10\n+        r = r + 1\n+        p = q\n+        a(1+i) = p + q\n+\ts = i * 10\n+      end do\n+    !$omp end distribute simd\n+    !$omp end target teams\n+  end subroutine\n+end module"}, {"sha": "7521331fcb1a8ad3face021e531f42ccb8e08db6", "filename": "gcc/testsuite/gfortran.dg/gomp/target2.f90", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget2.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,74 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -ffree-line-length-160\" }\n+\n+subroutine foo (n, s, t, u, v, w)\n+  integer :: n, i, s, t, u, v, w\n+  common /bar/ i\n+  !$omp simd safelen(s + 1)\n+  do i = 1, n\n+  end do\n+  !$omp do schedule (static, t * 2)\n+  do i = 1, n\n+  end do\n+  !$omp do simd safelen(s + 1) schedule (static, t * 2)\n+  do i = 1, n\n+  end do\n+  !$omp parallel do schedule (static, t * 2) num_threads (u - 1)\n+  do i = 1, n\n+  end do\n+  !$omp parallel do simd safelen(s + 1) schedule (static, t * 2) num_threads (u - 1)\n+  do i = 1, n\n+  end do\n+  !$omp distribute dist_schedule (static, v + 8)\n+  do i = 1, n\n+  end do\n+  !$omp distribute simd dist_schedule (static, v + 8) safelen(s + 1)\n+  do i = 1, n\n+  end do\n+  !$omp distribute parallel do simd dist_schedule (static, v + 8) safelen(s + 1) &\n+  !$omp & schedule (static, t * 2) num_threads (u - 1)\n+  do i = 1, n\n+  end do\n+  !$omp distribute parallel do dist_schedule (static, v + 8) num_threads (u - 1) &\n+  !$omp & schedule (static, t * 2)\n+  do i = 1, n\n+  end do\n+  !$omp target\n+  !$omp teams distribute dist_schedule (static, v + 8) num_teams (w + 8)\n+  do i = 1, n\n+  end do\n+  !$omp end target\n+  !$omp target\n+  !$omp teams distribute simd dist_schedule (static, v + 8) safelen(s + 1) &\n+  !$omp & num_teams (w + 8)\n+  do i = 1, n\n+  end do\n+  !$omp end target\n+  !$omp target\n+  !$omp teams distribute parallel do simd dist_schedule (static, v + 8) safelen(s + 1) &\n+  !$omp & schedule (static, t * 2) num_threads (u - 1) num_teams (w + 8)\n+  do i = 1, n\n+  end do\n+  !$omp end target\n+  !$omp target\n+  !$omp teams distribute parallel do dist_schedule (static, v + 8) num_threads (u - 1) &\n+  !$omp & schedule (static, t * 2) num_teams (w + 8)\n+  do i = 1, n\n+  end do\n+  !$omp end target\n+  !$omp target teams distribute dist_schedule (static, v + 8) num_teams (w + 8)\n+  do i = 1, n\n+  end do\n+  !$omp target teams distribute simd dist_schedule (static, v + 8) safelen(s + 1) &\n+  !$omp & num_teams (w + 8)\n+  do i = 1, n\n+  end do\n+  !$omp target teams distribute parallel do simd dist_schedule (static, v + 8) safelen(s + 1) &\n+  !$omp & schedule (static, t * 2) num_threads (u - 1) num_teams (w + 8)\n+  do i = 1, n\n+  end do\n+  !$omp target teams distribute parallel do dist_schedule (static, v + 8) num_threads (u - 1) &\n+  !$omp & schedule (static, t * 2) num_teams (w + 8)\n+  do i = 1, n\n+  end do\n+end subroutine"}, {"sha": "53a9682bf96a5fe31faa3775a2604d8221a808f1", "filename": "gcc/testsuite/gfortran.dg/gomp/target3.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget3.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp\" }\n+\n+subroutine foo (r)\n+  integer :: i, r\n+  !$omp target\n+  !$omp target teams distribute parallel do reduction (+: r) ! { dg-warning \"target construct inside of target region\" }\n+    do i = 1, 10\n+      r = r + 1\n+    end do\n+  !$omp end target\n+end subroutine"}, {"sha": "7e86a757214004039cc103156c0ac206b03e363d", "filename": "gcc/testsuite/gfortran.dg/gomp/udr4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -6,7 +6,7 @@ subroutine f3\n !$omp declare reduction (foo) ! { dg-error \"Unclassifiable OpenMP directive\" }\n !$omp declare reduction (foo:integer) ! { dg-error \"Unclassifiable OpenMP directive\" }\n !$omp declare reduction (foo:integer:omp_out=omp_out+omp_in) &\n-!$omp & initializer(omp_priv=0) initializer(omp_priv=0) ! { dg-error \"Unclassifiable statement\" }\n+!$omp & initializer(omp_priv=0) initializer(omp_priv=0) ! { dg-error \"Unexpected junk after\" }\n end subroutine f3\n subroutine f4\n   implicit integer (o)"}, {"sha": "44d5c9de49b49f63d9263e3a713f4113f922a413", "filename": "gcc/testsuite/gfortran.dg/openmp-define-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenmp-define-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenmp-define-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenmp-define-3.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -6,6 +6,6 @@\n # error _OPENMP not defined\n #endif\n \n-#if _OPENMP != 201107\n+#if _OPENMP != 201307\n # error _OPENMP defined to wrong value\n #endif"}, {"sha": "a17655389b4463ad7302877bc7bcb7ab152f0fdf", "filename": "gcc/tree-core.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1152,6 +1152,11 @@ enum omp_clause_map_kind\n      array sections.  OMP_CLAUSE_SIZE for these is not the pointer size,\n      which is implicitly POINTER_SIZE / BITS_PER_UNIT, but the bias.  */\n   OMP_CLAUSE_MAP_POINTER,\n+  /* Also internal, behaves like OMP_CLAUS_MAP_TO, but additionally any\n+     OMP_CLAUSE_MAP_POINTER records consecutive after it which have addresses\n+     falling into that range will not be ignored if OMP_CLAUSE_MAP_TO_PSET\n+     wasn't mapped already.  */\n+  OMP_CLAUSE_MAP_TO_PSET,\n   OMP_CLAUSE_MAP_LAST\n };\n "}, {"sha": "ea2fb7227953793c08a823b9ef0d60a1833dd55b", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1085,6 +1085,10 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_LINEAR:\n \t  if (OMP_CLAUSE_LINEAR_GIMPLE_SEQ (clause))\n \t    need_stmts = true;\n+\t  wi->val_only = true;\n+\t  wi->is_lhs = false;\n+\t  convert_nonlocal_reference_op (&OMP_CLAUSE_LINEAR_STEP (clause),\n+\t\t\t\t\t &dummy, wi);\n \t  goto do_decl_clause;\n \n \tcase OMP_CLAUSE_PRIVATE:\n@@ -1113,10 +1117,42 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DEVICE:\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\tcase OMP_CLAUSE_SAFELEN:\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n \t  convert_nonlocal_reference_op (&OMP_CLAUSE_OPERAND (clause, 0),\n-\t                                 &dummy, wi);\n+\t\t\t\t\t &dummy, wi);\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n+\t  if (OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (clause) != NULL)\n+\t    {\n+\t      wi->val_only = true;\n+\t      wi->is_lhs = false;\n+\t      convert_nonlocal_reference_op (&OMP_CLAUSE_OPERAND (clause, 0),\n+\t\t\t\t\t     &dummy, wi);\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE_TO:\n+\tcase OMP_CLAUSE_FROM:\n+\t  if (OMP_CLAUSE_SIZE (clause))\n+\t    {\n+\t      wi->val_only = true;\n+\t      wi->is_lhs = false;\n+\t      convert_nonlocal_reference_op (&OMP_CLAUSE_SIZE (clause),\n+\t\t\t\t\t     &dummy, wi);\n+\t    }\n+\t  if (DECL_P (OMP_CLAUSE_DECL (clause)))\n+\t    goto do_decl_clause;\n+\t  wi->val_only = true;\n+\t  wi->is_lhs = false;\n+\t  convert_nonlocal_reference_op (&OMP_CLAUSE_DECL (clause),\n+\t\t\t\t\t &dummy, wi);\n \t  break;\n \n \tcase OMP_CLAUSE_NOWAIT:\n@@ -1126,6 +1162,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_PROC_BIND:\n \t  break;\n \n \tdefault:\n@@ -1620,6 +1657,10 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_LINEAR:\n \t  if (OMP_CLAUSE_LINEAR_GIMPLE_SEQ (clause))\n \t    need_stmts = true;\n+\t  wi->val_only = true;\n+\t  wi->is_lhs = false;\n+\t  convert_local_reference_op (&OMP_CLAUSE_LINEAR_STEP (clause), &dummy,\n+\t\t\t\t      wi);\n \t  goto do_decl_clause;\n \n \tcase OMP_CLAUSE_PRIVATE:\n@@ -1653,19 +1694,53 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DEVICE:\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\tcase OMP_CLAUSE_SAFELEN:\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n \t  convert_local_reference_op (&OMP_CLAUSE_OPERAND (clause, 0), &dummy,\n \t\t\t\t      wi);\n \t  break;\n \n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n+\t  if (OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (clause) != NULL)\n+\t    {\n+\t      wi->val_only = true;\n+\t      wi->is_lhs = false;\n+\t      convert_local_reference_op (&OMP_CLAUSE_OPERAND (clause, 0),\n+\t\t\t\t\t  &dummy, wi);\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE_TO:\n+\tcase OMP_CLAUSE_FROM:\n+\t  if (OMP_CLAUSE_SIZE (clause))\n+\t    {\n+\t      wi->val_only = true;\n+\t      wi->is_lhs = false;\n+\t      convert_local_reference_op (&OMP_CLAUSE_SIZE (clause),\n+\t\t\t\t\t  &dummy, wi);\n+\t    }\n+\t  if (DECL_P (OMP_CLAUSE_DECL (clause)))\n+\t    goto do_decl_clause;\n+\t  wi->val_only = true;\n+\t  wi->is_lhs = false;\n+\t  convert_local_reference_op (&OMP_CLAUSE_DECL (clause),\n+\t\t\t\t      &dummy, wi);\n+\t  break;\n+\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_PROC_BIND:\n \t  break;\n \n \tdefault:"}, {"sha": "59a825c7c8d442524b8c1505fb6a17be02f4546f", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -500,6 +500,7 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n \t  pp_string (buffer, \"alloc\");\n \t  break;\n \tcase OMP_CLAUSE_MAP_TO:\n+\tcase OMP_CLAUSE_MAP_TO_PSET:\n \t  pp_string (buffer, \"to\");\n \t  break;\n \tcase OMP_CLAUSE_MAP_FROM:\n@@ -520,6 +521,9 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n \t  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n \t      && OMP_CLAUSE_MAP_KIND (clause) == OMP_CLAUSE_MAP_POINTER)\n \t    pp_string (buffer, \" [pointer assign, bias: \");\n+\t  else if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n+\t\t   && OMP_CLAUSE_MAP_KIND (clause) == OMP_CLAUSE_MAP_TO_PSET)\n+\t    pp_string (buffer, \" [pointer set, len: \");\n \t  else\n \t    pp_string (buffer, \" [len: \");\n \t  dump_generic_node (buffer, OMP_CLAUSE_SIZE (clause),"}, {"sha": "e3fdb625ef605b8f40f89b50d4fd30c809a6835d", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -1,3 +1,22 @@\n+2014-06-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp_lib.f90.in (openmp_version): Set to 201307.\n+\t* omp_lib.h.in (openmp_version): Likewise.\n+\t* testsuite/libgomp.c/target-8.c: New test.\n+\t* testsuite/libgomp.fortran/declare-simd-1.f90: Add notinbranch\n+\tand inbranch clauses.\n+\t* testsuite/libgomp.fortran/depend-3.f90: New test.\n+\t* testsuite/libgomp.fortran/openmp_version-1.f: Adjust for new\n+\topenmp_version.\n+\t* testsuite/libgomp.fortran/openmp_version-2.f90: Likewise.\n+\t* testsuite/libgomp.fortran/target1.f90: New test.\n+\t* testsuite/libgomp.fortran/target2.f90: New test.\n+\t* testsuite/libgomp.fortran/target3.f90: New test.\n+\t* testsuite/libgomp.fortran/target4.f90: New test.\n+\t* testsuite/libgomp.fortran/target5.f90: New test.\n+\t* testsuite/libgomp.fortran/target6.f90: New test.\n+\t* testsuite/libgomp.fortran/target7.f90: New test.\n+\n 2014-06-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/60928"}, {"sha": "757053c9fbc79573da43709311bf9196b312f000", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -42,7 +42,7 @@\n       module omp_lib\n         use omp_lib_kinds\n         implicit none\n-        integer, parameter :: openmp_version = 201107\n+        integer, parameter :: openmp_version = 201307\n \n         interface\n           subroutine omp_init_lock (svar)"}, {"sha": "691adb8655f301eef1c56024eb5ed4f06f619a53", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -45,7 +45,7 @@\n       parameter (omp_proc_bind_master = 2)\n       parameter (omp_proc_bind_close = 3)\n       parameter (omp_proc_bind_spread = 4)\n-      parameter (openmp_version = 201107)\n+      parameter (openmp_version = 201307)\n \n       external omp_init_lock, omp_init_nest_lock\n       external omp_destroy_lock, omp_destroy_nest_lock"}, {"sha": "350845753244b4f7372050b1a6f804b84617eaa5", "filename": "libgomp/testsuite/libgomp.c/target-8.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-8.c?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (int *p)\n+{\n+  int i;\n+  #pragma omp parallel\n+  #pragma omp single\n+  #pragma omp target teams distribute parallel for map(p[0:24])\n+  for (i = 0; i < 24; i++)\n+    p[i] = p[i] + 1;\n+}\n+\n+int\n+main ()\n+{\n+  int p[24], i;\n+  for (i = 0; i < 24; i++)\n+    p[i] = i;\n+  foo (p);\n+  for (i = 0; i < 24; i++)\n+    if (p[i] != i + 1)\n+      __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "5cd592c09db4ab786661b11fac7e176d7db31fb5", "filename": "libgomp/testsuite/libgomp.fortran/declare-simd-1.f90", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-1.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -6,7 +6,8 @@\n module declare_simd_1_mod\n   contains\n     real function foo (a, b, c)\n-      !$omp declare simd (foo) simdlen (4) uniform (a) linear (b : 5)\n+      !$omp declare simd (foo) simdlen (4) uniform (a) linear (b : 5) &\n+      !$omp & notinbranch\n       double precision, value :: a\n       real, value :: c\n       !$omp declare simd (foo)\n@@ -22,6 +23,7 @@ function bar (a, b, c)\n       real, value :: c\n       real :: bar\n       !$omp declare simd (bar) simdlen (4) linear (b : 2)\n+      !$omp declare simd (bar) simdlen (16) inbranch\n       double precision, value :: a\n     end function bar\n   end interface"}, {"sha": "11be6410692968abddb0d9613777f8ceb21393e5", "filename": "libgomp/testsuite/libgomp.fortran/depend-3.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-3.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+\n+  integer :: x(2, 3)\n+  integer, allocatable :: z(:, :)\n+  allocate (z(-2:3, 2:4))\n+  call foo (x, z)\n+contains\n+  subroutine foo (x, z)\n+    integer :: x(:, :), y\n+    integer, allocatable :: z(:, :)\n+    y = 1\n+    !$omp parallel shared (x, y, z)\n+      !$omp single\n+        !$omp taskgroup\n+          !$omp task depend(in: x)\n+  \t  if (y.ne.1) call abort\n+          !$omp end task\n+          !$omp task depend(out: x(1:2, 1:3))\n+  \t  y = 2\n+          !$omp end task\n+        !$omp end taskgroup\n+        !$omp taskgroup\n+          !$omp task depend(in: z)\n+  \t  if (y.ne.2) call abort\n+          !$omp end task\n+          !$omp task depend(out: z(-2:3, 2:4))\n+  \t  y = 3\n+          !$omp end task\n+        !$omp end taskgroup\n+        !$omp taskgroup\n+          !$omp task depend(in: x)\n+  \t  if (y.ne.3) call abort\n+          !$omp end task\n+          !$omp task depend(out: x(1:, 1:))\n+  \t  y = 4\n+          !$omp end task\n+        !$omp end taskgroup\n+      !$omp end single\n+    !$omp end parallel\n+    if (y.ne.4) call abort\n+  end subroutine\n+end"}, {"sha": "be24adcca0c5fdcaa165662ab753558a7550b6a2", "filename": "libgomp/testsuite/libgomp.fortran/openmp_version-1.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fopenmp_version-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fopenmp_version-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fopenmp_version-1.f?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -4,6 +4,6 @@ program main\n       implicit none\n       include \"omp_lib.h\"\n \n-      if (openmp_version .ne. 201107) call abort;\n+      if (openmp_version .ne. 201307) call abort;\n \n       end program main"}, {"sha": "62712c7d206027c06f56d8e50a03a6358e991640", "filename": "libgomp/testsuite/libgomp.fortran/openmp_version-2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fopenmp_version-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fopenmp_version-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fopenmp_version-2.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -4,6 +4,6 @@ program main\n   use omp_lib\n   implicit none\n \n-  if (openmp_version .ne. 201107) call abort;\n+  if (openmp_version .ne. 201307) call abort;\n \n end program main"}, {"sha": "c70daace497c16cd44f455a0ecff80088be3398d", "filename": "libgomp/testsuite/libgomp.fortran/target1.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget1.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+\n+module target1\n+contains\n+  subroutine foo (p, v, w, n)\n+    double precision, pointer :: p(:), v(:), w(:)\n+    double precision :: q(n)\n+    integer :: i, n\n+    !$omp target if (n > 256) map (to: v(1:n), w(:n)) map (from: p(1:n), q)\n+    !$omp parallel do simd\n+      do i = 1, n\n+        p(i) = v(i) * w(i)\n+        q(i) = p(i)\n+      end do\n+    !$omp end target\n+    if (any (p /= q)) call abort\n+    do i = 1, n\n+      if (p(i) /= i * iand (i, 63)) call abort\n+    end do\n+    !$omp target data if (n > 256) map (to: v(1:n), w) map (from: p, q)\n+    !$omp target if (n > 256)\n+      do i = 1, n\n+        p(i) = 1.0\n+        q(i) = 2.0\n+      end do\n+    !$omp end target\n+    !$omp target if (n > 256)\n+      do i = 1, n\n+        p(i) = p(i) + v(i) * w(i)\n+        q(i) = q(i) + v(i) * w(i)\n+      end do\n+    !$omp end target\n+    !$omp target if (n > 256)\n+      !$omp teams distribute parallel do simd linear(i:1)\n+      do i = 1, n\n+        p(i) = p(i) + 2.0\n+        q(i) = q(i) + 3.0\n+      end do\n+    !$omp end target\n+    !$omp end target data\n+    if (any (p + 2.0 /= q)) call abort\n+  end subroutine\n+end module target1\n+  use target1, only : foo\n+  integer :: n, i\n+  double precision, pointer :: p(:), v(:), w(:)\n+  n = 10000\n+  allocate (p(n), v(n), w(n))\n+  do i = 1, n\n+    v(i) = i\n+    w(i) = iand (i, 63)\n+  end do\n+  call foo (p, v, w, n)\n+  do i = 1, n\n+    if (p(i) /= i * iand (i, 63) + 3) call abort\n+  end do\n+  deallocate (p, v, w)\n+end"}, {"sha": "42f704f2bb31e4a11b42af60c0f410ef858abf55", "filename": "libgomp/testsuite/libgomp.fortran/target2.f90", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget2.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,96 @@\n+! { dg-do run }\n+! { dg-options \"-fopenmp -ffree-line-length-160\" }\n+\n+module target2\n+contains\n+  subroutine foo (a, b, c, d, e, f, g, n, q)\n+    integer :: n, q\n+    integer :: a, b(3:n), c(5:), d(2:*), e(:,:)\n+    integer, pointer :: f, g(:)\n+    integer :: h, i(3:n)\n+    integer, pointer :: j, k(:)\n+    logical :: r\n+    allocate (j, k(4:n))\n+    h = 14\n+    i = 15\n+    j = 16\n+    k = 17\n+    !$omp target map (to: a, b, c, d(2:n+1), e, f, g, h, i, j, k, n) map (from: r)\n+      r = a /= 7\n+      r = r .or. (any (b /= 8)) .or. (lbound (b, 1) /= 3) .or. (ubound (b, 1) /= n)\n+      r = r .or. (any (c /= 9)) .or. (lbound (c, 1) /= 5) .or. (ubound (c, 1) /= n + 4)\n+      r = r .or. (any (d(2:n+1) /= 10)) .or. (lbound (d, 1) /= 2)\n+      r = r .or. (any (e /= 11)) .or. (lbound (e, 1) /= 1) .or. (ubound (e, 1) /= 2)\n+      r = r .or. (lbound (e, 2) /= 1) .or. (ubound (e, 2) /= 2)\n+      r = r .or. (f /= 12)\n+      r = r .or. (any (g /= 13)) .or. (lbound (g, 1) /= 3) .or. (ubound (g, 1) /= n)\n+      r = r .or. (h /= 14)\n+      r = r .or. (any (i /= 15)) .or. (lbound (i, 1) /= 3) .or. (ubound (i, 1) /= n)\n+      r = r .or. (j /= 16)\n+      r = r .or. (any (k /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)\n+    !$omp end target\n+    if (r) call abort\n+    !$omp target map (to: b(3:n), c(5:n+4), d(2:n+1), e(1:,:2), g(3:n), i(3:n), k(4:n), n) map (from: r)\n+      r = (any (b /= 8)) .or. (lbound (b, 1) /= 3) .or. (ubound (b, 1) /= n)\n+      r = r .or. (any (c /= 9)) .or. (lbound (c, 1) /= 5) .or. (ubound (c, 1) /= n + 4)\n+      r = r .or. (any (d(2:n+1) /= 10)) .or. (lbound (d, 1) /= 2)\n+      r = r .or. (any (e /= 11)) .or. (lbound (e, 1) /= 1) .or. (ubound (e, 1) /= 2)\n+      r = r .or. (lbound (e, 2) /= 1) .or. (ubound (e, 2) /= 2)\n+      r = r .or. (any (g /= 13)) .or. (lbound (g, 1) /= 3) .or. (ubound (g, 1) /= n)\n+      r = r .or. (any (i /= 15)) .or. (lbound (i, 1) /= 3) .or. (ubound (i, 1) /= n)\n+      r = r .or. (any (k /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)\n+    !$omp end target\n+    if (r) call abort\n+    !$omp target map (to: b(5:n-2), c(7:n), d(4:n-2), e(1:,2:), g(5:n-3), i(6:n-4), k(5:n-5), n) map (from: r)\n+      r = (any (b(5:n-2) /= 8)) .or. (lbound (b, 1) /= 3) .or. (ubound (b, 1) /= n)\n+      r = r .or. (any (c(7:n) /= 9)) .or. (lbound (c, 1) /= 5) .or. (ubound (c, 1) /= n + 4)\n+      r = r .or. (any (d(4:n-2) /= 10)) .or. (lbound (d, 1) /= 2)\n+      r = r .or. (any (e(1:,2:) /= 11)) .or. (lbound (e, 1) /= 1) .or. (ubound (e, 1) /= 2)\n+      r = r .or. (lbound (e, 2) /= 1) .or. (ubound (e, 2) /= 2)\n+      r = r .or. (any (g(5:n-3) /= 13)) .or. (lbound (g, 1) /= 3) .or. (ubound (g, 1) /= n)\n+      r = r .or. (any (i(6:n-4) /= 15)) .or. (lbound (i, 1) /= 3) .or. (ubound (i, 1) /= n)\n+      r = r .or. (any (k(5:n-5) /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)\n+    !$omp end target\n+    !$omp target map (to: b(q+5:n-2+q), c(q+7:q+n), d(q+4:q+n-2), e(1:q+2,2:q+2), g(5+q:n-3+q), &\n+    !$omp & i(6+q:n-4+q), k(5+q:n-5+q), n) map (from: r)\n+      r = (any (b(5:n-2) /= 8)) .or. (lbound (b, 1) /= 3) .or. (ubound (b, 1) /= n)\n+      r = r .or. (any (c(7:n) /= 9)) .or. (lbound (c, 1) /= 5) .or. (ubound (c, 1) /= n + 4)\n+      r = r .or. (any (d(4:n-2) /= 10)) .or. (lbound (d, 1) /= 2)\n+      r = r .or. (any (e(1:,2:) /= 11)) .or. (lbound (e, 1) /= 1) .or. (ubound (e, 1) /= 2)\n+      r = r .or. (lbound (e, 2) /= 1) .or. (ubound (e, 2) /= 2)\n+      r = r .or. (any (g(5:n-3) /= 13)) .or. (lbound (g, 1) /= 3) .or. (ubound (g, 1) /= n)\n+      r = r .or. (any (i(6:n-4) /= 15)) .or. (lbound (i, 1) /= 3) .or. (ubound (i, 1) /= n)\n+      r = r .or. (any (k(5:n-5) /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)\n+    !$omp end target\n+    if (r) call abort\n+    !$omp target map (to: d(2:n+1), n)\n+      r = a /= 7\n+      r = r .or. (any (b /= 8)) .or. (lbound (b, 1) /= 3) .or. (ubound (b, 1) /= n)\n+      r = r .or. (any (c /= 9)) .or. (lbound (c, 1) /= 5) .or. (ubound (c, 1) /= n + 4)\n+      r = r .or. (any (d(2:n+1) /= 10)) .or. (lbound (d, 1) /= 2)\n+      r = r .or. (any (e /= 11)) .or. (lbound (e, 1) /= 1) .or. (ubound (e, 1) /= 2)\n+      r = r .or. (lbound (e, 2) /= 1) .or. (ubound (e, 2) /= 2)\n+      r = r .or. (f /= 12)\n+      r = r .or. (any (g /= 13)) .or. (lbound (g, 1) /= 3) .or. (ubound (g, 1) /= n)\n+      r = r .or. (h /= 14)\n+      r = r .or. (any (i /= 15)) .or. (lbound (i, 1) /= 3) .or. (ubound (i, 1) /= n)\n+      r = r .or. (j /= 16)\n+      r = r .or. (any (k /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)\n+    !$omp end target\n+    if (r) call abort\n+  end subroutine foo\n+end module target2\n+  use target2, only : foo\n+  integer, parameter :: n = 15, q = 0\n+  integer :: a, b(2:n-1), c(n), d(n), e(3:4, 3:4)\n+  integer, pointer :: f, g(:)\n+  allocate (f, g(3:n))\n+  a = 7\n+  b = 8\n+  c = 9\n+  d = 10\n+  e = 11\n+  f = 12\n+  g = 13\n+  call foo (a, b, c, d, e, f, g, n, q)\n+end"}, {"sha": "1f197acdef7b8d9125bb60f956f5f38b72d5fc1f", "filename": "libgomp/testsuite/libgomp.fortran/target3.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget3.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+\n+module target3\n+contains\n+  subroutine foo (f, g)\n+    integer :: n\n+    integer, pointer :: f, g(:)\n+    integer, pointer :: j, k(:)\n+    logical :: r\n+    nullify (j)\n+    k => null ()\n+    !$omp target map (tofrom: f, g, j, k) map (from: r)\n+      r = associated (f) .or. associated (g)\n+      r = r .or. associated (j) .or. associated (k)\n+    !$omp end target\n+    if (r) call abort\n+    !$omp target\n+      r = associated (f) .or. associated (g)\n+      r = r .or. associated (j) .or. associated (k)\n+    !$omp end target\n+    if (r) call abort\n+  end subroutine foo\n+end module target3\n+  use target3, only : foo\n+  integer, pointer :: f, g(:)\n+  f => null ()\n+  nullify (g)\n+  call foo (f, g)\n+end"}, {"sha": "aa2f0a5ac193869663b9a6d57243058b146cdb55", "filename": "libgomp/testsuite/libgomp.fortran/target4.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget4.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do run }\n+\n+module target4\n+contains\n+  subroutine foo (a,m,n)\n+    integer :: m,n,i,j\n+    double precision :: a(m, n), t\n+    !$omp target data map(a) map(to: m, n)\n+    do i=1,n\n+      t = 0.0d0\n+      !$omp target\n+        !$omp parallel do reduction(+:t)\n+          do j=1,m\n+            t = t + a(j,i) * a(j,i)\n+          end do\n+      !$omp end target\n+      t = 2.0d0 * t\n+      !$omp target\n+        !$omp parallel do\n+          do j=1,m\n+            a(j,i) = a(j,i) * t\n+          end do\n+      !$omp end target\n+    end do\n+    !$omp end target data\n+  end subroutine foo\n+end module target4\n+  use target4, only : foo\n+  integer :: i, j\n+  double precision :: a(8, 9), res(8, 9)\n+  do i = 1, 8\n+    do j = 1, 9\n+      a(i, j) = i + j\n+    end do\n+  end do\n+  call foo (a, 8, 9)\n+  res = reshape ((/ 1136.0d0, 1704.0d0, 2272.0d0, 2840.0d0, 3408.0d0, 3976.0d0, &\n+&   4544.0d0, 5112.0d0, 2280.0d0, 3040.0d0, 3800.0d0, 4560.0d0, 5320.0d0, 6080.0d0, &\n+&   6840.0d0, 7600.0d0, 3936.0d0, 4920.0d0, 5904.0d0, 6888.0d0, 7872.0d0, 8856.0d0, &\n+&   9840.0d0, 10824.0d0, 6200.0d0, 7440.0d0, 8680.0d0, 9920.0d0, 11160.0d0, 12400.0d0, &\n+&   13640.0d0, 14880.0d0, 9168.0d0, 10696.0d0, 12224.0d0, 13752.0d0, 15280.0d0, 16808.0d0, &\n+&   18336.0d0, 19864.0d0, 12936.0d0, 14784.0d0, 16632.0d0, 18480.0d0, 20328.0d0, 22176.0d0, &\n+&   24024.0d0, 25872.0d0, 17600.0d0, 19800.0d0, 22000.0d0, 24200.0d0, 26400.0d0, 28600.0d0, &\n+&   30800.0d0, 33000.0d0, 23256.0d0, 25840.0d0, 28424.0d0, 31008.0d0, 33592.0d0, 36176.0d0, &\n+&   38760.0d0, 41344.0d0, 30000.0d0, 33000.0d0, 36000.0d0, 39000.0d0, 42000.0d0, 45000.0d0, &\n+&   48000.0d0, 51000.0d0 /), (/ 8, 9 /))\n+  if (any (a /= res)) call abort\n+end"}, {"sha": "c46faf226f6d2f8afb092e3c89aebea0c44599f8", "filename": "libgomp/testsuite/libgomp.fortran/target5.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget5.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp\" }\n+\n+  integer :: r\n+  r = 0\n+  call foo (r)\n+  if (r /= 11) call abort\n+contains\n+  subroutine foo (r)\n+    integer :: i, r\n+    !$omp parallel\n+    !$omp single\n+    !$omp target teams distribute parallel do reduction (+: r)\n+      do i = 1, 10\n+        r = r + 1\n+      end do\n+      r = r + 1\n+    !$omp end single\n+    !$omp end parallel\n+  end subroutine\n+end"}, {"sha": "13f5a52edd22500b1bf225b2aef271ada51e5606", "filename": "libgomp/testsuite/libgomp.fortran/target6.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget6.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do run }\n+\n+module target6\n+contains\n+  subroutine foo (p, v, w, n)\n+    double precision, pointer :: p(:), v(:), w(:)\n+    double precision :: q(n)\n+    integer :: i, n\n+    !$omp target data if (n > 256) map (to: v(1:n), w(:n)) map (from: p(1:n), q)\n+    !$omp target if (n > 256)\n+    !$omp parallel do simd\n+      do i = 1, n\n+        p(i) = v(i) * w(i)\n+        q(i) = p(i)\n+      end do\n+    !$omp end target\n+    !$omp target update if (n > 256) from (p)\n+    do i = 1, n\n+      if (p(i) /= i * iand (i, 63)) call abort\n+      v(i) = v(i) + 1\n+    end do\n+    !$omp target update if (n > 256) to (v(1:n))\n+    !$omp target if (n > 256)\n+    !$omp parallel do simd\n+      do i = 1, n\n+        p(i) = v(i) * w(i)\n+      end do\n+    !$omp end target\n+    !$omp end target data\n+    do i = 1, n\n+      if (q(i) /= (v(i) - 1) * w(i)) call abort\n+      if (p(i) /= q(i) + w(i)) call abort\n+    end do\n+  end subroutine\n+end module target6\n+  use target6, only : foo\n+  integer :: n, i\n+  double precision, pointer :: p(:), v(:), w(:)\n+  n = 10000\n+  allocate (p(n), v(n), w(n))\n+  do i = 1, n\n+    v(i) = i\n+    w(i) = iand (i, 63)\n+  end do\n+  call foo (p, v, w, n)\n+  do i = 1, n\n+    if (p(i) /= (i + 1) * iand (i, 63)) call abort\n+  end do\n+  deallocate (p, v, w)\n+end"}, {"sha": "4af0ee371bdb045412fa81b98c20fd8ff424858a", "filename": "libgomp/testsuite/libgomp.fortran/target7.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014c65363d0b8a52807e55c4bda620c57440a4d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget7.f90?ref=f014c65363d0b8a52807e55c4bda620c57440a4d", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+\n+  interface\n+    real function foo (x)\n+      !$omp declare target\n+      real, intent(in) :: x\n+    end function foo\n+  end interface\n+  integer, parameter :: n = 1000\n+  integer, parameter :: c = 100\n+  integer :: i, j\n+  real :: a(n)\n+  do i = 1, n\n+    a(i) = i\n+  end do\n+  do i = 1, n, c\n+    !$omp task shared(a)\n+      !$omp target map(a(i:i+c-1))\n+        !$omp parallel do\n+          do j = i, i + c - 1\n+            a(j) = foo (a(j))\n+          end do\n+      !$omp end target\n+    !$omp end task\n+  end do\n+  do i = 1, n\n+    if (a(i) /= i + 1) call abort\n+  end do\n+end\n+real function foo (x)\n+  !$omp declare target\n+  real, intent(in) :: x\n+  foo = x + 1\n+end function foo"}]}