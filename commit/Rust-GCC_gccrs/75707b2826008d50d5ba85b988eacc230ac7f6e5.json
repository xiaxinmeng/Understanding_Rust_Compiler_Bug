{"sha": "75707b2826008d50d5ba85b988eacc230ac7f6e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU3MDdiMjgyNjAwOGQ1MGQ1YmE4NWI5ODhlYWNjMjMwYWM3ZjZlNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-06-05T11:41:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-06-05T11:41:45Z"}, "message": "s390.c (global_not_special_regno_p): New static inline.\n\n\t* config/s390/s390.c (global_not_special_regno_p): New static inline.\n\t(save_gprs): Don't tell unwinder when a global register is saved.\n\t(s390_emit_epilogue): Emit needed epilogue unwind info.\n\nFrom-SVN: r148205", "tree": {"sha": "a343edf17509ddbd8bce2e900618435e00bed04b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a343edf17509ddbd8bce2e900618435e00bed04b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75707b2826008d50d5ba85b988eacc230ac7f6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75707b2826008d50d5ba85b988eacc230ac7f6e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75707b2826008d50d5ba85b988eacc230ac7f6e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75707b2826008d50d5ba85b988eacc230ac7f6e5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5580c6e729ef723fa3f2330b356c6b70ca6511fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5580c6e729ef723fa3f2330b356c6b70ca6511fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5580c6e729ef723fa3f2330b356c6b70ca6511fc"}], "stats": {"total": 83, "additions": 64, "deletions": 19}, "files": [{"sha": "570590be5399145e6755237b90a70af329ecbcee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75707b2826008d50d5ba85b988eacc230ac7f6e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75707b2826008d50d5ba85b988eacc230ac7f6e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75707b2826008d50d5ba85b988eacc230ac7f6e5", "patch": "@@ -1,3 +1,9 @@\n+2009-06-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/s390/s390.c (global_not_special_regno_p): New static inline.\n+\t(save_gprs): Don't tell unwinder when a global register is saved.\n+\t(s390_emit_epilogue): Emit needed epilogue unwind info.\n+\n 2009-06-05  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* dwarf2out.c (deferred_asm_name): New."}, {"sha": "6ec2b257b03dbf24851313e9a78a7709354534ab", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75707b2826008d50d5ba85b988eacc230ac7f6e5/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75707b2826008d50d5ba85b988eacc230ac7f6e5/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=75707b2826008d50d5ba85b988eacc230ac7f6e5", "patch": "@@ -7424,6 +7424,21 @@ restore_fpr (rtx base, int offset, int regnum)\n   return emit_move_insn (gen_rtx_REG (DFmode, regnum), addr);\n }\n \n+/* Return true if REGNO is a global register, but not one\n+   of the special ones that need to be saved/restored in anyway.  */\n+\n+static inline bool\n+global_not_special_regno_p (int regno)\n+{\n+  return (global_regs[regno]\n+\t  /* These registers are special and need to be\n+\t     restored in any case.  */\n+\t  && !(regno == STACK_POINTER_REGNUM\n+\t       || regno == RETURN_REGNUM\n+\t       || regno == BASE_REGNUM\n+\t       || (flag_pic && regno == (int)PIC_OFFSET_TABLE_REGNUM)));\n+}\n+\n /* Generate insn to save registers FIRST to LAST into\n    the register save area located at offset OFFSET\n    relative to register BASE.  */\n@@ -7447,7 +7462,8 @@ save_gprs (rtx base, int offset, int first, int last)\n       else\n         insn = gen_movsi (addr, gen_rtx_REG (Pmode, first));\n \n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      if (!global_not_special_regno_p (first))\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n       return insn;\n     }\n \n@@ -7477,28 +7493,41 @@ save_gprs (rtx base, int offset, int first, int last)\n      set, even if it does not.  Therefore we emit a new pattern\n      without those registers as REG_FRAME_RELATED_EXPR note.  */\n \n-  if (first >= 6)\n+  if (first >= 6 && !global_not_special_regno_p (first))\n     {\n       rtx pat = PATTERN (insn);\n \n       for (i = 0; i < XVECLEN (pat, 0); i++)\n-\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n+\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET\n+\t    && !global_not_special_regno_p (REGNO (SET_SRC (XVECEXP (pat,\n+\t\t\t\t\t\t\t\t     0, i)))))\n \t  RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   else if (last >= 6)\n     {\n-      addr = plus_constant (base, offset + (6 - first) * UNITS_PER_WORD);\n+      int start;\n+\n+      for (start = first >= 6 ? first : 6; start <= last; start++)\n+\tif (!global_not_special_regno_p (start))\n+\t  break;\n+\n+      if (start > last)\n+\treturn insn;\n+\n+      addr = plus_constant (base, offset + (start - first) * UNITS_PER_WORD);\n       note = gen_store_multiple (gen_rtx_MEM (Pmode, addr),\n-\t\t\t\t gen_rtx_REG (Pmode, 6),\n-\t\t\t\t GEN_INT (last - 6 + 1));\n+\t\t\t\t gen_rtx_REG (Pmode, start),\n+\t\t\t\t GEN_INT (last - start + 1));\n       note = PATTERN (note);\n \n       add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);\n \n       for (i = 0; i < XVECLEN (note, 0); i++)\n-\tif (GET_CODE (XVECEXP (note, 0, i)) == SET)\n+\tif (GET_CODE (XVECEXP (note, 0, i)) == SET\n+\t    && !global_not_special_regno_p (REGNO (SET_SRC (XVECEXP (note,\n+\t\t\t\t\t\t\t\t     0, i)))))\n \t  RTX_FRAME_RELATED_P (XVECEXP (note, 0, i)) = 1;\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -7882,7 +7911,7 @@ s390_emit_prologue (void)\n void\n s390_emit_epilogue (bool sibcall)\n {\n-  rtx frame_pointer, return_reg;\n+  rtx frame_pointer, return_reg, cfa_restores = NULL_RTX;\n   int area_bottom, area_top, offset = 0;\n   int next_offset;\n   rtvec p;\n@@ -7924,11 +7953,13 @@ s390_emit_epilogue (bool sibcall)\n     }\n   else\n     {\n-      rtx insn, frame_off;\n+      rtx insn, frame_off, cfa;\n \n       offset = area_bottom < 0 ? -area_bottom : 0;\n       frame_off = GEN_INT (cfun_frame_layout.frame_size - offset);\n \n+      cfa = gen_rtx_SET (VOIDmode, frame_pointer,\n+\t\t\t gen_rtx_PLUS (Pmode, frame_pointer, frame_off));\n       if (DISP_IN_RANGE (INTVAL (frame_off)))\n \t{\n \t  insn = gen_rtx_SET (VOIDmode, frame_pointer,\n@@ -7943,6 +7974,8 @@ s390_emit_epilogue (bool sibcall)\n \t  insn = emit_insn (gen_add2_insn (frame_pointer, frame_off));\n \t  annotate_constant_pool_refs (&PATTERN (insn));\n \t}\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, cfa);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   /* Restore call saved fprs.  */\n@@ -7958,6 +7991,9 @@ s390_emit_epilogue (bool sibcall)\n \t\t{\n \t\t  restore_fpr (frame_pointer,\n \t\t\t       offset + next_offset, i);\n+\t\t  cfa_restores\n+\t\t    = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t      gen_rtx_REG (DFmode, i), cfa_restores);\n \t\t  next_offset += 8;\n \t\t}\n \t    }\n@@ -7973,6 +8009,9 @@ s390_emit_epilogue (bool sibcall)\n \t    {\n \t      restore_fpr (frame_pointer,\n \t\t\t   offset + next_offset, i);\n+\t      cfa_restores\n+\t\t= alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t  gen_rtx_REG (DFmode, i), cfa_restores);\n \t      next_offset += 8;\n \t    }\n \t  else if (!TARGET_PACKED_STACK)\n@@ -7999,15 +8038,7 @@ s390_emit_epilogue (bool sibcall)\n \t   i <= cfun_frame_layout.last_restore_gpr;\n \t   i++)\n \t{\n-\t  /* These registers are special and need to be\n-\t     restored in any case.  */\n-\t  if (i == STACK_POINTER_REGNUM\n-              || i == RETURN_REGNUM\n-              || i == BASE_REGNUM\n-              || (flag_pic && i == (int)PIC_OFFSET_TABLE_REGNUM))\n-\t    continue;\n-\n-\t  if (global_regs[i])\n+\t  if (global_not_special_regno_p (i))\n \t    {\n \t      addr = plus_constant (frame_pointer,\n \t\t\t\t    offset + cfun_frame_layout.gprs_offset\n@@ -8017,6 +8048,10 @@ s390_emit_epilogue (bool sibcall)\n \t      set_mem_alias_set (addr, get_frame_alias_set ());\n \t      emit_move_insn (addr, gen_rtx_REG (Pmode, i));\n \t    }\n+\t  else\n+\t    cfa_restores\n+\t      = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\tgen_rtx_REG (Pmode, i), cfa_restores);\n \t}\n \n       if (! sibcall)\n@@ -8051,7 +8086,11 @@ s390_emit_epilogue (bool sibcall)\n \t\t\t   * UNITS_PER_WORD,\n \t\t\t   cfun_frame_layout.first_restore_gpr,\n \t\t\t   cfun_frame_layout.last_restore_gpr);\n-      emit_insn (insn);\n+      insn = emit_insn (insn);\n+      REG_NOTES (insn) = cfa_restores;\n+      add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t    plus_constant (stack_pointer_rtx, STACK_POINTER_OFFSET));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   if (! sibcall)"}]}