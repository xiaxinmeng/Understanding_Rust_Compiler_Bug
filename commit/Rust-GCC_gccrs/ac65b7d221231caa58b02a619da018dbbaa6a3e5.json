{"sha": "ac65b7d221231caa58b02a619da018dbbaa6a3e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2NWI3ZDIyMTIzMWNhYTU4YjAyYTYxOWRhMDE4ZGJiYWE2YTNlNQ==", "commit": {"author": {"name": "Daniel Krugler", "email": "daniel.kruegler@googlemail.com", "date": "2011-09-11T22:10:21Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-09-11T22:10:21Z"}, "message": "re PR libstdc++/50159 ([C++0x] tuple_cat only accepts two arguments)\n\n2011-09-11  Daniel Krugler  <daniel.kruegler@googlemail.com>\n\n\tPR libstdc++/50159\n\t* include/std/tuple (tuple_cat): Reimplement according to the\n\tresolution of LWG 1385.\n\t* include/std/type_traits: Define __and_ and __or_ for zero\n\targuments too; minor tweaks.\n\t* testsuite/20_util/tuple/creation_functions/tuple_cat.cc: New.\n\t* testsuite/20_util/tuple/creation_functions/constexpr.cc: Disable\n\tfor now tuple_cat test.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Adjust dg-error\n\tline numbers.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Likewise.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n\tLikewise.\n\t* doc/xml/manual/status_cxx200x.xml: Update.\n\nFrom-SVN: r178770", "tree": {"sha": "fc1dd8d8b32c5967145919371cb46e76351d1c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc1dd8d8b32c5967145919371cb46e76351d1c2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac65b7d221231caa58b02a619da018dbbaa6a3e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac65b7d221231caa58b02a619da018dbbaa6a3e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac65b7d221231caa58b02a619da018dbbaa6a3e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac65b7d221231caa58b02a619da018dbbaa6a3e5/comments", "author": {"login": "Dani-Hub", "id": 431432, "node_id": "MDQ6VXNlcjQzMTQzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/431432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dani-Hub", "html_url": "https://github.com/Dani-Hub", "followers_url": "https://api.github.com/users/Dani-Hub/followers", "following_url": "https://api.github.com/users/Dani-Hub/following{/other_user}", "gists_url": "https://api.github.com/users/Dani-Hub/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dani-Hub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dani-Hub/subscriptions", "organizations_url": "https://api.github.com/users/Dani-Hub/orgs", "repos_url": "https://api.github.com/users/Dani-Hub/repos", "events_url": "https://api.github.com/users/Dani-Hub/events{/privacy}", "received_events_url": "https://api.github.com/users/Dani-Hub/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa11ae6c728fdde8746fc77107c3a1095ac88f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa11ae6c728fdde8746fc77107c3a1095ac88f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa11ae6c728fdde8746fc77107c3a1095ac88f59"}], "stats": {"total": 507, "additions": 358, "deletions": 149}, "files": [{"sha": "8edaae53b188981082bfd93a8b6afd573c674a25", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -1,3 +1,20 @@\n+2011-09-11  Daniel Krugler  <daniel.kruegler@googlemail.com>\n+\n+\tPR libstdc++/50159\n+\t* include/std/tuple (tuple_cat): Reimplement according to the\n+\tresolution of LWG 1385.\n+\t* include/std/type_traits: Define __and_ and __or_ for zero\n+\targuments too; minor tweaks.\n+\t* testsuite/20_util/tuple/creation_functions/tuple_cat.cc: New.\n+\t* testsuite/20_util/tuple/creation_functions/constexpr.cc: Disable\n+\tfor now tuple_cat test.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Adjust dg-error\n+\tline numbers.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Likewise.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tLikewise.\n+\t* doc/xml/manual/status_cxx200x.xml: Update.\n+\n 2011-09-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/std/tuple: Use everywhere std::size_t... instead of int..."}, {"sha": "3922dff83075499914e0276afe603f2341e64582", "filename": "libstdc++-v3/doc/xml/manual/status_cxx200x.xml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx200x.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx200x.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx200x.xml?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -443,11 +443,10 @@ particular release.\n       <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#B0B0B0\" ?>\n       <entry>20.4.2.4</entry>\n       <entry>Tuple creation functions</entry>\n-      <entry>Partial</entry>\n-      <entry><code>tuple_cat</code> should be a single variadic signature (DR 1385)</entry>\n+      <entry>Y</entry>\n+      <entry/>\n     </row>\n     <row>\n       <entry>20.4.2.5</entry>"}, {"sha": "1b4a82382769787a09cd084b32028bea71c5bde2", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 165, "deletions": 112, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -876,108 +876,184 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     forward_as_tuple(_Elements&&... __args) noexcept\n     { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }\n \n-  template<std::size_t...> struct __index_holder { };    \n \n-  template<std::size_t __i, typename _IdxHolder, typename... _Elements>\n-    struct __index_holder_impl;\n+  template<typename, std::size_t> struct array;\n \n-  template<std::size_t __i, std::size_t... _Indexes, typename _IdxHolder,\n-\t   typename... _Elements>\n-    struct __index_holder_impl<__i, __index_holder<_Indexes...>,\n-\t\t\t       _IdxHolder, _Elements...> \n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+    _Tp& get(array<_Tp, _Nm>&) noexcept;\n+\n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+    _Tp&& get(array<_Tp, _Nm>&&) noexcept;\n+\n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+    const _Tp& get(const array<_Tp, _Nm>&) noexcept;\n+\n+  template<typename>\n+    struct __is_tuple_like_impl : false_type\n+    { };\n+\n+  template<typename... _Tps>\n+    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type\n+    { };\n+\n+  template<typename _T1, typename _T2>\n+    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type\n+    { };\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type\n+    { };\n+\n+  // Internal type trait that allows us to sfinae-protect tuple_cat.\n+  template<typename _Tp>\n+    struct __is_tuple_like\n+    : public __is_tuple_like_impl<typename std::remove_cv\n+            <typename std::remove_reference<_Tp>::type>::type>::type\n+    { };\n+\n+  // Stores a tuple of indices.  Also used by bind() to extract the elements\n+  // in a tuple. \n+  template<std::size_t... _Indexes>\n+    struct _Index_tuple\n     {\n-      typedef typename __index_holder_impl<__i + 1,\n-\t\t\t\t\t   __index_holder<_Indexes..., __i>,\n-\t\t\t\t\t   _Elements...>::type type;\n+      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;\n     };\n- \n-  template<std::size_t __i, std::size_t... _Indexes>\n-    struct __index_holder_impl<__i, __index_holder<_Indexes...> >\n-    { typedef __index_holder<_Indexes...> type; };\n \n-  template<typename... _Elements>\n-    struct __make_index_holder \n-    : __index_holder_impl<0, __index_holder<>, _Elements...> { };\n-    \n-  template<typename... _TElements, std::size_t... _TIdx,\n-\t   typename... _UElements, std::size_t... _UIdx> \n-    inline constexpr tuple<_TElements..., _UElements...> \n-    __tuple_cat_helper(const tuple<_TElements...>& __t,\n-\t\t       const __index_holder<_TIdx...>&,\n-                       const tuple<_UElements...>& __u,\n-\t\t       const __index_holder<_UIdx...>&)\n-    { return tuple<_TElements..., _UElements...>(get<_TIdx>(__t)...,\n-\t\t\t\t\t\t get<_UIdx>(__u)...); }\n-\n-  template<typename... _TElements, std::size_t... _TIdx,\n-\t   typename... _UElements, std::size_t... _UIdx> \n-    inline tuple<_TElements..., _UElements...> \n-    __tuple_cat_helper(tuple<_TElements...>&& __t,\n-\t\t       const __index_holder<_TIdx...>&, \n-\t\t       const tuple<_UElements...>& __u,\n-\t\t       const __index_holder<_UIdx...>&)\n-    { return tuple<_TElements..., _UElements...>\n-\t(std::forward<_TElements>(get<_TIdx>(__t))..., get<_UIdx>(__u)...); }\n-\n-  template<typename... _TElements, std::size_t... _TIdx,\n-\t   typename... _UElements, std::size_t... _UIdx>\n-    inline tuple<_TElements..., _UElements...> \n-    __tuple_cat_helper(const tuple<_TElements...>& __t,\n-\t\t       const __index_holder<_TIdx...>&, \n-\t\t       tuple<_UElements...>&& __u,\n-\t\t       const __index_holder<_UIdx...>&)\n-    { return tuple<_TElements..., _UElements...>\n-\t(get<_TIdx>(__t)..., std::forward<_UElements>(get<_UIdx>(__u))...); }\n-\n-  template<typename... _TElements, std::size_t... _TIdx,\n-\t   typename... _UElements, std::size_t... _UIdx> \n-    inline tuple<_TElements..., _UElements...> \n-    __tuple_cat_helper(tuple<_TElements...>&& __t,\n-\t\t       const __index_holder<_TIdx...>&, \n-\t\t       tuple<_UElements...>&& __u,\n-\t\t       const __index_holder<_UIdx...>&)\n-    { return tuple<_TElements..., _UElements...>\n-\t(std::forward<_TElements>(get<_TIdx>(__t))...,\n-\t std::forward<_UElements>(get<_UIdx>(__u))...); }\n+  // Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.\n+  template<std::size_t _Num>\n+    struct _Build_index_tuple\n+    {\n+      typedef typename _Build_index_tuple<_Num - 1>::__type::__next __type;\n+    };\n \n-  template<typename... _TElements, typename... _UElements>\n-    inline constexpr tuple<_TElements..., _UElements...> \n-    tuple_cat(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n+  template<>\n+    struct _Build_index_tuple<0>\n     {\n-      return __tuple_cat_helper(__t, typename\n-\t\t\t\t__make_index_holder<_TElements...>::type(),\n-\t\t\t\t__u, typename\n-\t\t\t\t__make_index_holder<_UElements...>::type());\n-    }\n+      typedef _Index_tuple<> __type;\n+    };\n \n-  template<typename... _TElements, typename... _UElements>\n-    inline tuple<_TElements..., _UElements...> \n-    tuple_cat(tuple<_TElements...>&& __t, const tuple<_UElements...>& __u)\n+  template<std::size_t, typename, typename, std::size_t>\n+    struct __make_tuple_impl;\n+\n+  template<std::size_t _Idx, typename _Tuple, typename... _Tp,\n+           std::size_t _Nm>\n+    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>\n     {\n-      return __tuple_cat_helper(std::move(__t), typename\n-\t\t\t\t __make_index_holder<_TElements...>::type(),\n-\t\t\t\t __u, typename\n-\t\t\t\t __make_index_holder<_UElements...>::type());\n-    }\n+      typedef typename __make_tuple_impl<_Idx + 1, tuple<_Tp...,\n+\ttypename std::tuple_element<_Idx, _Tuple>::type>, _Tuple, _Nm>::__type\n+      __type;\n+    };\n \n-  template<typename... _TElements, typename... _UElements>\n-    inline tuple<_TElements..., _UElements...> \n-    tuple_cat(const tuple<_TElements...>& __t, tuple<_UElements...>&& __u)\n+  template<std::size_t _Nm, typename _Tuple, typename... _Tp>\n+    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>\n     {\n-      return __tuple_cat_helper(__t, typename\n-\t\t\t\t__make_index_holder<_TElements...>::type(),\n-\t\t\t\tstd::move(__u), typename\n-\t\t\t\t__make_index_holder<_UElements...>::type());\n-    }\n+      typedef tuple<_Tp...> __type;\n+    };\n \n-  template<typename... _TElements, typename... _UElements>\n-    inline tuple<_TElements..., _UElements...>\n-    tuple_cat(tuple<_TElements...>&& __t, tuple<_UElements...>&& __u)\n+  template<typename _Tuple>\n+    struct __do_make_tuple\n+    : public __make_tuple_impl<0, tuple<>, _Tuple,\n+                               std::tuple_size<_Tuple>::value>\n+    { };\n+\n+  // Returns the std::tuple equivalent of a tuple-like type.\n+  template<typename _Tuple>\n+    struct __make_tuple\n+    : public __do_make_tuple<typename std::remove_cv\n+            <typename std::remove_reference<_Tuple>::type>::type>\n+    { };\n+\n+  // Combines several std::tuple's into a single one.\n+  template<typename...>\n+    struct __combine_tuples;\n+\n+  template<>\n+    struct __combine_tuples<>\n+    {\n+      typedef tuple<> __type;\n+    };\n+\n+  template<typename... _Ts>\n+    struct __combine_tuples<tuple<_Ts...>>\n     {\n-      return __tuple_cat_helper(std::move(__t), typename\n-\t\t\t\t__make_index_holder<_TElements...>::type(),\n-\t\t\t\tstd::move(__u), typename\n-\t\t\t\t__make_index_holder<_UElements...>::type());\n+      typedef tuple<_Ts...> __type;\n+    };\n+\n+  template<typename... _T1s, typename... _T2s, typename... _Rem>\n+    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>\n+    {\n+      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,\n+\t\t\t\t\t_Rem...>::__type __type;\n+    };\n+\n+  // Computes the result type of tuple_cat given a set of tuple-like types.\n+  template<typename... _Tpls>\n+    struct __tuple_cat_result\n+    {\n+      typedef typename __combine_tuples\n+        <typename __make_tuple<_Tpls>::__type...>::__type __type;\n+    };\n+\n+  // Helper to determine the index set for the first tuple-like\n+  // type of a given set.\n+  template<typename...>\n+    struct __make_1st_indices;\n+\n+  template<>\n+    struct __make_1st_indices<>\n+    {\n+      typedef std::_Index_tuple<> __type;\n+    };\n+\n+  template<typename _Tp, typename... _Tpls>\n+    struct __make_1st_indices<_Tp, _Tpls...>\n+    {\n+      typedef typename std::_Build_index_tuple<std::tuple_size<\n+\ttypename std::remove_reference<_Tp>::type>::value>::__type __type;\n+    };\n+\n+  // Performs the actual concatenation by step-wise expanding tuple-like\n+  // objects into the elements,  which are finally forwarded into the\n+  // result tuple.\n+  template<typename _Ret, typename _Indices, typename... _Tpls>\n+    struct __tuple_concater;\n+\n+  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>\n+    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>\n+    {\n+      template<typename... _Us>\n+        static _Ret\n+        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)\n+        {\n+\t  typedef typename __make_1st_indices<_Tpls...>::__type __idx;\n+\t  typedef __tuple_concater<_Ret, __idx, _Tpls...>      __next;\n+\t  return __next::_S_do(std::forward<_Tpls>(__tps)...,\n+\t\t\t       std::forward<_Us>(__us)...,\n+\t\t\t       std::get<_Is>(std::forward<_Tp>(__tp))...);\n+\t}\n+    };\n+\n+  template<typename _Ret>\n+    struct __tuple_concater<_Ret, std::_Index_tuple<>>\n+    {\n+      template<typename... _Us>\n+\tstatic _Ret\n+\t_S_do(_Us&&... __us)\n+        {\n+\t  return _Ret(std::forward<_Us>(__us)...);\n+\t}\n+    };\n+\n+  template<typename... _Tpls>\n+    inline typename\n+    std::enable_if<__and_<__is_tuple_like<_Tpls>...>::value,\n+                   typename __tuple_cat_result<_Tpls...>::__type>::type\n+    tuple_cat(_Tpls&&... __tpls)\n+    {\n+      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;\n+      typedef typename __make_1st_indices<_Tpls...>::__type __idx;\n+      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;\n+      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);\n     }\n \n   template<typename... _Elements>\n@@ -1007,29 +1083,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename... _Types, typename _Alloc>\n     struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };\n \n-  /**\n-   * Stores a tuple of indices. Used by bind() to extract the elements\n-   * in a tuple. \n-   */\n-  template<std::size_t... _Indexes>\n-    struct _Index_tuple\n-    {\n-      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;\n-    };\n-\n-  /// Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.\n-  template<std::size_t _Num>\n-    struct _Build_index_tuple\n-    {\n-      typedef typename _Build_index_tuple<_Num-1>::__type::__next __type;\n-    };\n-\n-  template<>\n-    struct _Build_index_tuple<0>\n-    {\n-      typedef _Index_tuple<> __type;\n-    };\n-\n   // See stl_pair.h...\n   template<class _T1, class _T2>\n     template<typename _Tp, typename... _Args>"}, {"sha": "155f7dfe6b9d9d0aff74f3cbe5bc0b683401489e", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -45,23 +45,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @addtogroup metaprogramming\n    * @{\n    */\n-  struct __sfinae_types\n-  {\n-    typedef char __one;\n-    typedef struct { char __arr[2]; } __two;\n-  };\n+\n+  /// integral_constant\n+  template<typename _Tp, _Tp __v>\n+    struct integral_constant\n+    {\n+      static constexpr _Tp                  value = __v;\n+      typedef _Tp                           value_type;\n+      typedef integral_constant<_Tp, __v>   type;\n+      constexpr operator value_type() { return value; }\n+    };\n+  \n+  /// typedef for true_type\n+  typedef integral_constant<bool, true>     true_type;\n+\n+  /// typedef for false_type\n+  typedef integral_constant<bool, false>    false_type;\n+\n+  template<typename _Tp, _Tp __v>\n+    constexpr _Tp integral_constant<_Tp, __v>::value;\n \n   // Meta programming helper types.\n \n   template<bool, typename, typename>\n     struct conditional;\n \n-  template<typename _Tp, _Tp>\n-    struct integral_constant;\n-\n   template<typename...>\n     struct __or_;\n \n+  template<>\n+    struct __or_<>\n+    : public false_type\n+    { };\n+\n   template<typename _B1>\n     struct __or_<_B1>\n     : public _B1\n@@ -80,6 +96,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename...>\n     struct __and_;\n \n+  template<>\n+    struct __and_<>\n+    : public true_type\n+    { };\n+\n   template<typename _B1>\n     struct __and_<_B1>\n     : public _B1\n@@ -100,26 +121,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public integral_constant<bool, !_Pp::value>\n     { };\n \n-  // helper class.\n-\n-  /// integral_constant\n-  template<typename _Tp, _Tp __v>\n-    struct integral_constant\n-    {\n-      static constexpr _Tp                  value = __v;\n-      typedef _Tp                           value_type;\n-      typedef integral_constant<_Tp, __v>   type;\n-      constexpr operator value_type() { return value; }\n-    };\n-  \n-  /// typedef for true_type\n-  typedef integral_constant<bool, true>     true_type;\n-\n-  /// typedef for false_type\n-  typedef integral_constant<bool, false>    false_type;\n-\n-  template<typename _Tp, _Tp __v>\n-    constexpr _Tp integral_constant<_Tp, __v>::value;\n+  struct __sfinae_types\n+  {\n+    typedef char __one;\n+    typedef struct { char __arr[2]; } __two;\n+  };\n \n   // primary type categories.\n "}, {"sha": "195b9c291739c672d3d5d3a4051ebf9363099637", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1725 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1731 }\n \n #include <utility>\n "}, {"sha": "b3266580f5fe9dfa054264f41b02c29fd5cb105c", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1511 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1475 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1517 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1481 }"}, {"sha": "3de08b30aa3620ac6f829b3cbf7f8669e28167ca", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1435 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1399 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1441 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1405 }"}, {"sha": "82bbe1f104bd7badd7ac01148b374be50c677b60", "filename": "libstdc++-v3/testsuite/20_util/tuple/creation_functions/constexpr.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcreation_functions%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcreation_functions%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcreation_functions%2Fconstexpr.cc?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -63,6 +63,7 @@ test_get()\n }\n \n // tuple_cat\n+#if 0\n void\n test_tuple_cat()\n {\n@@ -73,7 +74,7 @@ test_tuple_cat()\n   constexpr tuple_type2 t2 { 55, 99, 77.77 };\n   constexpr auto cat1 = std::tuple_cat(t1, t2);\n }\n-\n+#endif\n \n int\n main()\n@@ -84,7 +85,9 @@ main()\n \n   test_get();\n \n+#if 0\n   test_tuple_cat();\n+#endif\n \n   return 0;\n }"}, {"sha": "b2279a1121f876b4c350de1678a7a57a3052709a", "filename": "libstdc++-v3/testsuite/20_util/tuple/creation_functions/tuple_cat.cc", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcreation_functions%2Ftuple_cat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac65b7d221231caa58b02a619da018dbbaa6a3e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcreation_functions%2Ftuple_cat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcreation_functions%2Ftuple_cat.cc?ref=ac65b7d221231caa58b02a619da018dbbaa6a3e5", "patch": "@@ -0,0 +1,131 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Tuple\n+\n+#include <tuple>\n+#include <array>\n+\n+static_assert(std::is_same<decltype(std::tuple_cat()),\n+\t      std::tuple<>>::value, \"Error\");\n+static_assert(std::is_same<decltype(std::tuple_cat\n+\t\t\t\t    (std::declval<std::tuple<>>())),\n+              std::tuple<>>::value, \"Error\");\n+static_assert(std::is_same<decltype(std::tuple_cat\n+\t\t\t\t    (std::declval<std::tuple<>&>())),\n+              std::tuple<>>::value, \"Error\");\n+static_assert(std::is_same<decltype(std::tuple_cat\n+\t\t\t\t    (std::declval<const std::tuple<>>())),\n+              std::tuple<>>::value, \"Error\");\n+static_assert(std::is_same<decltype(std::tuple_cat\n+\t\t\t\t    (std::declval<const std::tuple<>&>())),\n+              std::tuple<>>::value, \"Error\");\n+static_assert(std::is_same<decltype(std::tuple_cat\n+\t\t\t\t    (std::declval<std::pair<int, bool>>())),\n+              std::tuple<int, bool>>::value, \"Error\");\n+static_assert(std::is_same<decltype(std::tuple_cat\n+\t\t\t\t    (std::declval<std::pair<int, bool>&>())),\n+              std::tuple<int, bool>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat(std::declval<const std::pair<int, bool>>())),\n+              std::tuple<int, bool>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat(std::declval<const std::pair<int, bool>&>())),\n+              std::tuple<int, bool>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat(std::declval<std::array<int, 3>>())),\n+              std::tuple<int, int, int>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat(std::declval<std::array<int, 3>&>())),\n+              std::tuple<int, int, int>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat(std::declval<const std::array<int, 3>>())),\n+              std::tuple<int, int, int>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat(std::declval<const std::array<int, 3>&>())),\n+              std::tuple<int, int, int>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat\n+\t       (std::declval<std::tuple<>>(), std::declval<std::tuple<>>())),\n+              std::tuple<>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat\n+\t       (std::declval<std::tuple<>>(), std::declval<std::tuple<>>(),\n+\t\tstd::declval<std::tuple<>>())), std::tuple<>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat\n+\t       (std::declval<std::tuple<>>(),\n+\t\tstd::declval<std::array<char, 0>>(),\n+\t\tstd::declval<std::array<int, 0>>(),\n+\t\tstd::declval<std::tuple<>>())), std::tuple<>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat\n+\t       (std::declval<std::tuple<int>>(),\n+\t\tstd::declval<std::tuple<double>>())),\n+              std::tuple<int, double>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat\n+\t       (std::declval<std::tuple<int>>(),\n+\t\tstd::declval<std::tuple<double>>(),\n+\t\tstd::declval<std::tuple<const long&>>())),\n+              std::tuple<int, double, const long&>>::value, \"Error\");\n+static_assert(std::is_same<decltype\n+\t      (std::tuple_cat\n+\t       (std::declval<std::array<wchar_t, 3>&>(),\n+\t\tstd::declval<std::tuple<double>>(),\n+\t\tstd::declval<std::tuple<>>(),\n+\t\tstd::declval<std::tuple<unsigned&>>(),\n+\t\tstd::declval<std::pair<bool, std::nullptr_t>>())),\n+              std::tuple<wchar_t, wchar_t, wchar_t,\n+\t      double, unsigned&, bool, std::nullptr_t>\n+              >::value, \"Error\");\n+\n+int main()\n+{\n+  std::tuple_cat();\n+  std::tuple_cat(std::tuple<>{ });\n+  std::tuple_cat(std::tuple<>{ }, std::tuple<>{ });\n+  std::array<int, 3> a3;\n+  std::tuple_cat(a3);\n+  std::pair<double, bool> pdb;\n+  std::tuple<unsigned, float, std::nullptr_t, void*> t;\n+  int i{ };\n+  double d{ };\n+  int* pi{ };\n+  std::tuple<int&, double&, int*&> to{i, d, pi};\n+  std::tuple_cat(pdb);\n+  std::tuple_cat(to);\n+  std::tuple_cat(to, to);\n+  std::tuple_cat(a3, pdb);\n+  std::tuple_cat(a3, pdb, t);\n+  std::tuple_cat(a3, pdb, t, a3);\n+  std::tuple_cat(a3, pdb, t, a3, pdb, t);\n+\n+  static_assert(std::is_same<decltype\n+\t\t(std::tuple_cat(a3, pdb, t, a3, pdb, t)),\n+                std::tuple<int, int, int, double, bool,\n+\t\tunsigned, float, std::nullptr_t, void*,\n+\t\tint, int, int, double, bool, unsigned,\n+\t\tfloat, std::nullptr_t, void*>\n+                >::value, \"Error\");\n+\n+  std::tuple_cat(std::tuple<int, char, void*>{}, to, a3,\n+\t\t std::tuple<>{}, std::pair<float,\n+\t\t std::nullptr_t>{}, pdb, to);\n+}"}]}