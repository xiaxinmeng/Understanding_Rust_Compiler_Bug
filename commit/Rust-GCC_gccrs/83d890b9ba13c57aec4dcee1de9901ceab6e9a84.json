{"sha": "83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNkODkwYjliYTEzYzU3YWVjNGRjZWUxZGU5OTAxY2VhYjZlOWE4NA==", "commit": {"author": {"name": "Asher Langton", "email": "langton2@llnl.gov", "date": "2005-10-24T19:28:18Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-10-24T19:28:18Z"}, "message": "Commit for Asher Langton\n\n\tPR fortran/17031\n\tPR fortran/22282\n\nfortran/\n\t* check.c (gfc_check_loc) : New function\n\t* decl.c (variable_decl): New variables cp_as and sym. Added a\n\tcheck for variables that have already been declared as Cray\n\tPointers, so we can get the necessary attributes without adding\n\ta new symbol.\n\t(attr_decl1): Added code to catch pointee symbols and \"fix\"\n\ttheir array specs.\n\t(cray_pointer_decl): New method.\n\t(gfc_match_pointer): Added Cray pointer parsing code.\n\t(gfc_mod_pointee_as): New method.\n\t* expr.c (gfc_check_assign): added a check to catch vector-type\n\tassignments to pointees with an unspecified final dimension.\n\t* gfortran.h: (GFC_ISYM_LOC): New.\n\t(symbol_attribute): Added cray_pointer and cray_pointee bits.\n\t(gfc_array_spec): Added cray_pointee and cp_was_assumed bools.\n\t(gfc_symbol): Added gfc_symbol *cp_pointer.\n\t(gfc_option): Added flag_cray_pointer.\n\t(gfc_add_cray_pointee): Declare.\n\t(gfc_add_cray_pointer ): Declare.\n\t(gfc_mod_pointee_as): Declare.\n\t* intrinsic.c (add_functions): Add code for loc() intrinsic.\n\t* intrinsic.h (gfc_check_loc): Declare.\n\t(gfc_resolve_loc): Declare.\n\t* iresolve.c (gfc_resolve_loc): New.\n\t* lang.opt: Added fcray-pointer flag.\n\t* options.c (gfc_init_options): Intialized\n\tgfc_match_option.flag_cray_pointer.\n\t(gfc_handle_option): Deal with -fcray-pointer.\n\t* parse.c:(resolve_equivalence): Added code prohibiting Cray\n\tpointees in equivalence statements.\n\t* resolve.c (resolve_array_ref): Added code to prevent bounds\n\tchecking for Cray Pointee arrays.\n\t(resolve_equivalence): Prohibited pointees in equivalence\n\tstatements.\n\t* symbol.c (check_conflict): Added Cray pointer/pointee\n\tattribute checking.\n\t(gfc_add_cray_pointer): New\n\t(gfc_add_cray_pointee): New\n\t(gfc_copy_attr): New code for Cray pointers and pointees\n\t* trans-array.c (gfc_trans_auto_array_allocation): Added code to\n\tprevent space from being allocated for pointees.\n\t(gfc_conv_array_parameter): Added code to catch pointees and\n\tcorrectly set their base address.\n\t* trans-decl.c (gfc_finish_var_decl): Added code to prevent\n\tpointee declarations from making it to the back end.\n\t(gfc_create_module_variable): Same.\n\t* trans-expr.c (gfc_conv_variable): added code to detect and\n\ttranslate pointees.\n\t(gfc_conv_cray_pointee): New.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_loc): New.\n\t(gfc_conv_intrinsic_function): added entry point for loc\n\ttranslation.\n\t* trans.h (gfc_conv_cray_pointee): Declare.\n\n\t* gfortran.texi: Added section on Cray pointers, removed Cray\n\tpointers from list of proposed extensions\n\t* intrinsic.texi: Added documentation for loc intrinsic.\n\t* invoke.texi: Documented -fcray-pointer flag\n\ntestsuite/\n\tPR fortran/17031\n\tPR fortran/22282\n\t* gfortran.dg/cray_pointers_1.f90: New test.\n\t* gfortran.dg/cray_pointers_2.f90: New test.\n\t* gfortran.dg/cray_pointers_3.f90: New test.\n\t* gfortran.dg/loc_1.f90: New test.\n\t* gfortran.dg/loc_2.f90: New test.\n\nFrom-SVN: r105859", "tree": {"sha": "3a890f87b8932e19f69eb45aa1082ec2a61e9711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a890f87b8932e19f69eb45aa1082ec2a61e9711"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/comments", "author": null, "committer": null, "parents": [{"sha": "086b011c2ec8b085e1668abd1f4e7e749ad45a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/086b011c2ec8b085e1668abd1f4e7e749ad45a2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/086b011c2ec8b085e1668abd1f4e7e749ad45a2b"}], "stats": {"total": 4571, "additions": 4556, "deletions": 15}, "files": [{"sha": "87c993e1c179c0e46c45505c4d6cc6e86fb4e220", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -1,3 +1,66 @@\n+2005-10-24  Asher Langton  <langton2@llnl.gov>\n+\n+\tPR fortran/17031\n+\tPR fortran/22282\n+\t* check.c (gfc_check_loc) : New function\n+\t* decl.c (variable_decl): New variables cp_as and sym. Added a\t  \n+\tcheck for variables that have already been declared as Cray\n+\tPointers, so we can get the necessary attributes without adding\n+\ta new symbol.\n+\t(attr_decl1): Added code to catch pointee symbols and \"fix\"\n+\ttheir array specs.\n+\t(cray_pointer_decl): New method.\n+\t(gfc_match_pointer): Added Cray pointer parsing code.\n+\t(gfc_mod_pointee_as): New method.\n+\t* expr.c (gfc_check_assign): added a check to catch vector-type\n+\tassignments to pointees with an unspecified final dimension.\n+\t* gfortran.h: (GFC_ISYM_LOC): New.\n+\t(symbol_attribute): Added cray_pointer and cray_pointee bits.\n+\t(gfc_array_spec): Added cray_pointee and cp_was_assumed bools.\n+\t(gfc_symbol): Added gfc_symbol *cp_pointer.\n+\t(gfc_option): Added flag_cray_pointer.\n+\t(gfc_add_cray_pointee): Declare.\n+\t(gfc_add_cray_pointer ): Declare.\n+\t(gfc_mod_pointee_as): Declare.\n+\t* intrinsic.c (add_functions): Add code for loc() intrinsic.\n+\t* intrinsic.h (gfc_check_loc): Declare.\n+\t(gfc_resolve_loc): Declare.\n+\t* iresolve.c (gfc_resolve_loc): New.\n+\t* lang.opt: Added fcray-pointer flag.\n+\t* options.c (gfc_init_options): Intialized\n+\tgfc_match_option.flag_cray_pointer.\n+\t(gfc_handle_option): Deal with -fcray-pointer.\n+\t* parse.c:(resolve_equivalence): Added code prohibiting Cray\n+\tpointees in equivalence statements.\n+\t* resolve.c (resolve_array_ref): Added code to prevent bounds\n+\tchecking for Cray Pointee arrays.\n+\t(resolve_equivalence): Prohibited pointees in equivalence\n+\tstatements.\n+\t* symbol.c (check_conflict): Added Cray pointer/pointee\t \n+\tattribute checking.\n+\t(gfc_add_cray_pointer): New\n+\t(gfc_add_cray_pointee): New\n+\t(gfc_copy_attr): New code for Cray pointers and pointees\n+\t* trans-array.c (gfc_trans_auto_array_allocation): Added code to\n+\tprevent space from being allocated for pointees.\n+\t(gfc_conv_array_parameter): Added code to catch pointees and    \n+\tcorrectly set their base address.\n+\t* trans-decl.c (gfc_finish_var_decl): Added code to prevent     \n+\tpointee declarations from making it to the back end.\n+\t(gfc_create_module_variable): Same.\n+\t* trans-expr.c (gfc_conv_variable): added code to detect and\n+\ttranslate pointees.\n+\t(gfc_conv_cray_pointee): New.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_loc): New.\n+\t(gfc_conv_intrinsic_function): added entry point for loc\t\t\n+\ttranslation.\n+\t* trans.h (gfc_conv_cray_pointee): Declare.\n+\n+\t* gfortran.texi: Added section on Cray pointers, removed Cray\n+\tpointers from list of proposed extensions\n+\t* intrinsic.texi: Added documentation for loc intrinsic.\n+\t* invoke.texi: Documented -fcray-pointer flag\n+\n 2005-10-24  Asher Langton  <langton2@llnl.gov>\n \n \t* decl.c (gfc_match_save): Changed duplicate SAVE errors to"}, {"sha": "25601f7001d08a1d9bbc19a41e750afd1c85e41d", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -1211,6 +1211,12 @@ gfc_check_link_sub (gfc_expr * path1, gfc_expr * path2, gfc_expr * status)\n   return SUCCESS;\n }\n \n+try\n+gfc_check_loc (gfc_expr *expr)\n+{\n+  return variable_check (expr, 0);\n+}\n+\n \n try\n gfc_check_symlnk (gfc_expr * path1, gfc_expr * path2)"}, {"sha": "8102fa6b38dae65828c71a845bead43d6faa0b7c", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 252, "deletions": 6, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -912,13 +912,16 @@ variable_decl (int elem)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_expr *initializer, *char_len;\n   gfc_array_spec *as;\n+  gfc_array_spec *cp_as; /* Extra copy for Cray Pointees.  */\n   gfc_charlen *cl;\n   locus var_locus;\n   match m;\n   try t;\n+  gfc_symbol *sym;\n \n   initializer = NULL;\n   as = NULL;\n+  cp_as = NULL;\n \n   /* When we get here, we've just matched a list of attributes and\n      maybe a type and a double colon.  The next thing we expect to see\n@@ -931,7 +934,9 @@ variable_decl (int elem)\n \n   /* Now we could see the optional array spec. or character length.  */\n   m = gfc_match_array_spec (&as);\n-  if (m == MATCH_ERROR)\n+  if (gfc_option.flag_cray_pointer && m == MATCH_YES)\n+    cp_as = gfc_copy_array_spec (as);\n+  else if (m == MATCH_ERROR)\n     goto cleanup;\n   if (m == MATCH_NO)\n     as = gfc_copy_array_spec (current_as);\n@@ -972,6 +977,49 @@ variable_decl (int elem)\n \t}\n     }\n \n+  /*  If this symbol has already shown up in a Cray Pointer declaration,\n+      then we want to set the type & bail out. */\n+  if (gfc_option.flag_cray_pointer)\n+    {\n+      gfc_find_symbol (name, gfc_current_ns, 1, &sym);\n+      if (sym != NULL && sym->attr.cray_pointee)\n+\t{\n+\t  sym->ts.type = current_ts.type;\n+\t  sym->ts.kind = current_ts.kind;\n+\t  sym->ts.cl = cl;\n+\t  sym->ts.derived = current_ts.derived;\n+\t  m = MATCH_YES;\n+\t\n+\t  /* Check to see if we have an array specification.  */\n+\t  if (cp_as != NULL)\n+\t    {\n+\t      if (sym->as != NULL)\n+\t\t{\n+\t\t  gfc_error (\"Duplicate array spec for Cray pointee at %C.\");\n+\t\t  gfc_free_array_spec (cp_as);\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (gfc_set_array_spec (sym, cp_as, &var_locus) == FAILURE)\n+\t\t    gfc_internal_error (\"Couldn't set pointee array spec.\");\n+\t      \n+\t\t  /* Fix the array spec.  */\n+\t\t  m = gfc_mod_pointee_as (sym->as);  \n+\t\t  if (m == MATCH_ERROR)\n+\t\t    goto cleanup;\n+\t\t}\n+\t    }     \n+\t  goto cleanup;\n+\t}\n+      else\n+\t{\n+\t  gfc_free_array_spec (cp_as);\n+\t}\n+    }\n+  \n+    \n   /* OK, we've successfully matched the declaration.  Now put the\n      symbol in the current namespace, because it might be used in the\n      optional initialization expression for this symbol, e.g. this is\n@@ -2875,6 +2923,14 @@ attr_decl1 (void)\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n+    \n+  if (sym->attr.cray_pointee && sym->as != NULL)\n+    {\n+      /* Fix the array spec.  */\n+      m = gfc_mod_pointee_as (sym->as);   \t\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+    }\n \n   if ((current_attr.external || current_attr.intrinsic)\n       && sym->attr.flavor != FL_PROCEDURE\n@@ -2928,6 +2984,157 @@ attr_decl (void)\n }\n \n \n+/* This routine matches Cray Pointer declarations of the form:\n+   pointer ( <pointer>, <pointee> )\n+   or\n+   pointer ( <pointer1>, <pointee1> ), ( <pointer2>, <pointee2> ), ...   \n+   The pointer, if already declared, should be an integer.  Otherwise, we \n+   set it as BT_INTEGER with kind gfc_index_integer_kind.  The pointee may\n+   be either a scalar, or an array declaration.  No space is allocated for\n+   the pointee.  For the statement \n+   pointer (ipt, ar(10))\n+   any subsequent uses of ar will be translated (in C-notation) as\n+   ar(i) => ((<type> *) ipt)(i)   \n+   By the time the code is translated into GENERIC, the pointee will\n+   have disappeared from the code entirely. */\n+\n+static match\n+cray_pointer_decl (void)\n+{\n+  match m;\n+  gfc_array_spec *as;\n+  gfc_symbol *cptr; /* Pointer symbol.  */\n+  gfc_symbol *cpte; /* Pointee symbol.  */\n+  locus var_locus;\n+  bool done = false;\n+\n+  while (!done)\n+    {\n+      if (gfc_match_char ('(') != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected '(' at %C\");\n+\t  return MATCH_ERROR;   \n+\t}\n+ \n+      /* Match pointer.  */\n+      var_locus = gfc_current_locus;\n+      gfc_clear_attr (&current_attr);\n+      gfc_add_cray_pointer (&current_attr, &var_locus);\n+      current_ts.type = BT_INTEGER;\n+      current_ts.kind = gfc_index_integer_kind;\n+\n+      m = gfc_match_symbol (&cptr, 0);  \n+      if (m != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected variable name at %C\");\n+\t  return m;\n+\t}\n+  \n+      if (gfc_add_cray_pointer (&cptr->attr, &var_locus) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      gfc_set_sym_referenced (cptr);      \n+\n+      if (cptr->ts.type == BT_UNKNOWN) /* Override the type, if necessary.  */\n+\t{\n+\t  cptr->ts.type = BT_INTEGER;\n+\t  cptr->ts.kind = gfc_index_integer_kind; \n+\t}\n+      else if (cptr->ts.type != BT_INTEGER)\n+\t{\n+\t  gfc_error (\"Cray pointer at %C must be an integer.\");\n+\t  return MATCH_ERROR;\n+\t}\n+      else if (cptr->ts.kind < gfc_index_integer_kind)\n+\tgfc_warning (\"Cray pointer at %C has %d bytes of precision;\"\n+\t\t     \" memory addresses require %d bytes.\",\n+\t\t     cptr->ts.kind,\n+\t\t     gfc_index_integer_kind);\n+\n+      if (gfc_match_char (',') != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected \\\",\\\" at %C\");\n+\t  return MATCH_ERROR;    \n+\t}\n+\n+      /* Match Pointee.  */  \n+      var_locus = gfc_current_locus;\n+      gfc_clear_attr (&current_attr);\n+      gfc_add_cray_pointee (&current_attr, &var_locus);\n+      current_ts.type = BT_UNKNOWN;\n+      current_ts.kind = 0;\n+\n+      m = gfc_match_symbol (&cpte, 0);\n+      if (m != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected variable name at %C\");\n+\t  return m;\n+\t}\n+       \n+      /* Check for an optional array spec.  */\n+      m = gfc_match_array_spec (&as);\n+      if (m == MATCH_ERROR)\n+\t{\n+\t  gfc_free_array_spec (as);\n+\t  return m;\n+\t}\n+      else if (m == MATCH_NO)\n+\t{\n+\t  gfc_free_array_spec (as);\n+\t  as = NULL;\n+\t}   \n+\n+      if (gfc_add_cray_pointee (&cpte->attr, &var_locus) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      gfc_set_sym_referenced (cpte);\n+\n+      if (cpte->as == NULL)\n+\t{\n+\t  if (gfc_set_array_spec (cpte, as, &var_locus) == FAILURE)\n+\t    gfc_internal_error (\"Couldn't set Cray pointee array spec.\");\n+\t}\n+      else if (as != NULL)\n+\t{\n+\t  gfc_error (\"Duplicate array spec for Cray pointee at %C.\");\n+\t  gfc_free_array_spec (as);\n+\t  return MATCH_ERROR;\n+\t}\n+      \n+      as = NULL;\n+    \n+      if (cpte->as != NULL)\n+\t{\n+\t  /* Fix array spec.  */\n+\t  m = gfc_mod_pointee_as (cpte->as);\n+\t  if (m == MATCH_ERROR)\n+\t    return m;\n+\t} \n+   \n+      /* Point the Pointee at the Pointer.  */\n+      cpte->cp_pointer=cptr;\n+\n+      if (gfc_match_char (')') != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected \\\")\\\" at %C\");\n+\t  return MATCH_ERROR;    \n+\t}\n+      m = gfc_match_char (',');\n+      if (m != MATCH_YES)\n+\tdone = true; /* Stop searching for more declarations.  */\n+\n+    }\n+  \n+  if (m == MATCH_ERROR /* Failed when trying to find ',' above.  */\n+      || gfc_match_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Expected \\\",\\\" or end of statement at %C\");\n+      return MATCH_ERROR;\n+    }\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_external (void)\n {\n@@ -2981,11 +3188,24 @@ gfc_match_optional (void)\n match\n gfc_match_pointer (void)\n {\n-\n-  gfc_clear_attr (&current_attr);\n-  gfc_add_pointer (&current_attr, NULL);\n-\n-  return attr_decl ();\n+  gfc_gobble_whitespace ();\n+  if (gfc_peek_char () == '(')\n+    {\n+      if (!gfc_option.flag_cray_pointer)\n+\t{\n+\t  gfc_error (\"Cray pointer declaration at %C requires -fcray-pointer\"\n+\t\t     \" flag.\");\n+\t  return MATCH_ERROR;\n+\t}\n+      return cray_pointer_decl ();\n+    }\n+  else\n+    {\n+      gfc_clear_attr (&current_attr);\n+      gfc_add_pointer (&current_attr, NULL);\n+    \n+      return attr_decl ();\n+    }\n }\n \n \n@@ -3493,3 +3713,29 @@ gfc_match_derived_decl (void)\n \n   return MATCH_YES;\n }\n+\n+\n+/* Cray Pointees can be declared as: \n+      pointer (ipt, a (n,m,...,*)) \n+   By default, this is treated as an AS_ASSUMED_SIZE array.  We'll\n+   cheat and set a constant bound of 1 for the last dimension, if this\n+   is the case. Since there is no bounds-checking for Cray Pointees,\n+   this will be okay.  */\n+\n+try\n+gfc_mod_pointee_as (gfc_array_spec *as)\n+{\n+  as->cray_pointee = true; /* This will be useful to know later.  */\n+  if (as->type == AS_ASSUMED_SIZE)\n+    {\n+      as->type = AS_EXPLICIT;\n+      as->upper[as->rank - 1] = gfc_int_expr (1);\n+      as->cp_was_assumed = true;\n+    }\n+  else if (as->type == AS_ASSUMED_SHAPE)\n+    {\n+      gfc_error (\"Cray Pointee at %C cannot be assumed shape array\");\n+      return MATCH_ERROR;\n+    }\n+  return MATCH_YES;\n+}"}, {"sha": "80099df5ad40fe3ef2a65acb075dd22fe74a06da", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -1841,6 +1841,16 @@ gfc_check_assign (gfc_expr * lvalue, gfc_expr * rvalue, int conform)\n        return FAILURE;\n      }\n \n+   if (sym->attr.cray_pointee\n+       && lvalue->ref != NULL\n+       && lvalue->ref->u.ar.type != AR_ELEMENT\n+       && lvalue->ref->u.ar.as->cp_was_assumed)\n+     {\n+       gfc_error (\"Vector assignment to assumed-size Cray Pointee at %L\"\n+\t\t  \" is illegal.\", &lvalue->where);\n+       return FAILURE;\n+     }\n+\n   /* This is possibly a typo: x = f() instead of x => f()  */\n   if (gfc_option.warn_surprising \n       && rvalue->expr_type == EXPR_FUNCTION"}, {"sha": "56d008c97975645d89bc0631664d43f1c851d463", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -360,6 +360,7 @@ enum gfc_generic_isym_id\n   GFC_ISYM_LLE,\n   GFC_ISYM_LLT,\n   GFC_ISYM_LOG,\n+  GFC_ISYM_LOC,\n   GFC_ISYM_LOG10,\n   GFC_ISYM_LOGICAL,\n   GFC_ISYM_MATMUL,\n@@ -476,6 +477,9 @@ typedef struct\n   ENUM_BITFIELD (ifsrc) if_source:2;\n \n   ENUM_BITFIELD (procedure_type) proc:3;\n+  \n+  /* Special attributes for Cray pointers, pointees.  */\n+  unsigned cray_pointer:1, cray_pointee:1;    \n \n }\n symbol_attribute;\n@@ -573,6 +577,13 @@ typedef struct\n   int rank;\t/* A rank of zero means that a variable is a scalar.  */\n   array_type type;\n   struct gfc_expr *lower[GFC_MAX_DIMENSIONS], *upper[GFC_MAX_DIMENSIONS];\n+\n+  /* These two fields are used with the Cray Pointer extension.  */\n+  bool cray_pointee; /* True iff this spec belongs to a cray pointee.  */\n+  bool cp_was_assumed; /* AS_ASSUMED_SIZE cp arrays are converted to\n+\t\t\tAS_EXPLICIT, but we want to remember that we\n+\t\t\tdid this.  */\n+\n }\n gfc_array_spec;\n \n@@ -717,6 +728,9 @@ typedef struct gfc_symbol\n   struct gfc_symbol *result;\t/* function result symbol */\n   gfc_component *components;\t/* Derived type components */\n \n+  /* Defined only for Cray pointees; points to their pointer.  */\n+  struct gfc_symbol *cp_pointer;\n+\n   struct gfc_symbol *common_next;\t/* Links for COMMON syms */\n \n   /* This is in fact a gfc_common_head but it is only used for pointer\n@@ -1458,6 +1472,7 @@ typedef struct\n   int flag_f2c;\n   int flag_automatic;\n   int flag_backslash;\n+  int flag_cray_pointer;\n   int flag_d_lines;\n \n   int q_kind;\n@@ -1642,6 +1657,9 @@ try gfc_add_external (symbol_attribute *, locus *);\n try gfc_add_intrinsic (symbol_attribute *, locus *);\n try gfc_add_optional (symbol_attribute *, locus *);\n try gfc_add_pointer (symbol_attribute *, locus *);\n+try gfc_add_cray_pointer (symbol_attribute *, locus *);\n+try gfc_add_cray_pointee (symbol_attribute *, locus *);\n+try gfc_mod_pointee_as (gfc_array_spec *as);\n try gfc_add_result (symbol_attribute *, const char *, locus *);\n try gfc_add_save (symbol_attribute *, const char *, locus *);\n try gfc_add_saved_common (symbol_attribute *, locus *);"}, {"sha": "b4e672eea50fc590dbf2fe0445ea937182a96555", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 138, "deletions": 3, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -490,9 +490,6 @@ Flag to generate @code{Makefile} info.\n @item\n Automatically extend single precision constants to double.\n \n-@item\n-Cray pointers (this was high on the @command{g77} wishlist).\n-\n @item\n Compile code that conserves memory by dynamically allocating common and\n module storage either on stack or heap.\n@@ -633,6 +630,7 @@ of extensions, and @option{-std=legacy} allows both without warning.\n * Unary operators::\n * Implicitly interconvert LOGICAL and INTEGER::\n * Hollerith constants support::\n+* Cray pointers::\n @end menu\n \n @node Old-style kind specifications\n@@ -843,6 +841,143 @@ a = 8H12345678 ! The Hollerith constant is too long. It will be truncated.\n a = 0H         ! At least one character needed.\n @end smallexample\n \n+@node Cray pointers\n+@section Cray pointers\n+@cindex Cray pointers\n+\n+Cray pointers are part of a non-standard extension that provides a\n+C-like pointer in Fortran.  This is accomplished through a pair of\n+variables: an integer \"pointer\" that holds a memory address, and a\n+\"pointee\" that is used to dereference the pointer.\n+\n+Pointer/pointee pairs are declared in statements of the form:\n+@smallexample\n+        pointer ( <pointer> , <pointee> )\n+@end smallexample\n+or,\n+@smallexample\n+        pointer ( <pointer1> , <pointee1> ), ( <pointer2> , <pointee2> ), ...\n+@end smallexample\n+The pointer is an integer that is intended to hold a memory address.\n+The pointee may be an array or scalar.  A pointee can be an assumed\n+size array -- that is, the last dimension may be left unspecified by\n+using a '*' in place of a value -- but a pointee cannot be an assumed\n+shape array.  No space is allocated for the pointee.\n+\n+The pointee may have its type declared before or after the pointer\n+statement, and its array specification (if any) may be declared\n+before, during, or after the pointer statement.  The pointer may be\n+declared as an integer prior to the pointer statement.  However, some\n+machines have default integer sizes that are different than the size\n+of a pointer, and so the following code is not portable:\n+@smallexample\n+        integer ipt\n+        pointer (ipt, iarr)\n+@end smallexample\n+If a pointer is declared with a kind that is too small, the compiler\n+will issue a warning; the resulting binary will probably not work\n+correctly, because the memory addresses stored in the pointers may be\n+truncated.  It is safer to omit the first line of the above example;\n+if explicit declaration of ipt's type is omitted, then the compiler\n+will ensure that ipt is an integer variable large enough to hold a\n+pointer.\n+\n+Pointer arithmetic is valid with Cray pointers, but it is not the same\n+as C pointer arithmetic.  Cray pointers are just ordinary integers, so\n+the user is responsible for determining how many bytes to add to a\n+pointer in order to increment it.  Consider the following example:\n+@smallexample\n+        real target(10)\n+        real pointee(10)\n+        pointer (ipt, pointee)\n+        ipt = loc (target)\n+        ipt = ipt + 1       \n+@end smallexample\n+The last statement does not set ipt to the address of\n+@code{target(1)}, as one familiar with C pointer arithmetic might\n+expect.  Adding 1 to ipt just adds one byte to the address stored in\n+ipt.\n+\n+Any expression involving the pointee will be translated to use the\n+value stored in the pointer as the base address.  This translation is\n+done in the front end, and so the pointees are not present in the\n+GENERIC tree that is handed off to the backend.  One disadvantage of\n+this is that pointees will not appear in gdb when debugging a Fortran\n+program that uses Cray pointers.\n+\n+To get the address of elements, this extension provides an intrinsic\n+function loc(), loc() is essentially the C '&' operator, except the\n+address is cast to an integer type:\n+@smallexample\n+        real ar(10)\n+        pointer(ipt, arpte(10))\n+        real arpte\n+        ipt = loc(ar)  ! Makes arpte is an alias for ar\n+        arpte(1) = 1.0 ! Sets ar(1) to 1.0\n+@end smallexample\n+The pointer can also be set by a call to a malloc-type\n+function.  There is no malloc intrinsic implemented as part of the\n+Cray pointer extension, but it might be a useful future addition to\n+@command{gfortran}.  Even without an intrinsic malloc function,\n+dynamic memory allocation can be combined with Cray pointers by\n+calling a short C function:\n+@smallexample\n+mymalloc.c:\n+\n+        void mymalloc_(void **ptr, int *nbytes)\n+        @{\n+            *ptr = malloc(*nbytes);\n+            return;\n+        @}\n+\n+caller.f:\n+\n+        program caller\n+        integer ipinfo;\n+        real*4 data\n+        pointer (ipdata, data(1024))\n+        call mymalloc(ipdata,4*1024)\n+        end\n+@end smallexample\n+Cray pointees often are used to alias an existing variable.  For\n+example:\n+@smallexample\n+        integer target(10)\n+        integer iarr(10)\n+        pointer (ipt, iarr)\n+        ipt = loc(target)\n+@end smallexample\n+As long as ipt remains unchanged, iarr is now an alias for target.\n+The optimizer, however, will not detect this aliasing, so it is unsafe\n+to use iarr and target simultaneously.  Using a pointee in any way\n+that violates the Fortran aliasing rules or assumptions is illegal.\n+It is the user's responsibility to avoid doing this; the compiler\n+works under the assumption that no such aliasing occurs.\n+\n+Cray pointers will work correctly when there is no aliasing (i.e.,\n+when they're used to access a dynamically allocated block of memory),\n+and also in any routine where a pointee is used, but any variable with\n+which it shares storage is not used.  Code that violates these rules\n+may not run as the user intends.  This is not a bug in the optimizer;\n+any code that violates the aliasing rules is illegal.  (Note that this\n+is not unique to gfortran; any Fortran compiler that supports Cray\n+pointers will ``incorrectly'' optimize code with illegal aliasing.)\n+\n+There are a number of restrictions on the attributes that can be\n+applied to Cray pointers and pointees.  Pointees may not have the\n+attributes ALLOCATABLE, INTENT, OPTIONAL, DUMMY, TARGET, EXTERNAL,\n+INTRINSIC, or POINTER.  Pointers may not have the attributes\n+DIMENSION, POINTER, TARGET, ALLOCATABLE, EXTERNAL, or INTRINSIC.\n+Pointees may not occur in more than one pointer statement.  A pointee\n+cannot be a pointer.  Pointees cannot occur in equivalence, common, or\n+data statements.\n+\n+A pointer may be modified during the course of a program, and this\n+will change the location to which the pointee refers.  However, when\n+pointees are passed as arguments, they are treated as ordinary\n+variables in the invoked function.  Subsequent changes to the pointer\n+will not change the base address of the array that was passed.\n+\n @include intrinsic.texi\n @c ---------------------------------------------------------------------\n @c Contributing"}, {"sha": "93dde153d10bb85083d9322220b609f9ec9a1403", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -2098,6 +2098,13 @@ add_functions (void)\n \t     bck, BT_LOGICAL, dl, OPTIONAL);\n \n   make_generic (\"verify\", GFC_ISYM_VERIFY, GFC_STD_F95);\n+    \n+  add_sym_1 (\"loc\", 0, 1, BT_INTEGER, ii, GFC_STD_GNU,\n+\t    gfc_check_loc, NULL, gfc_resolve_loc,\n+\t    ar, BT_UNKNOWN, 0, REQUIRED);\n+\t\t\n+  make_generic (\"loc\", GFC_ISYM_LOC, GFC_STD_GNU);\n+\n }\n \n "}, {"sha": "950ac7dfbeb99a3aaa0ced5bb77c55fac80e3ac1", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -77,6 +77,7 @@ try gfc_check_kill (gfc_expr *, gfc_expr *);\n try gfc_check_kind (gfc_expr *);\n try gfc_check_lbound (gfc_expr *, gfc_expr *);\n try gfc_check_link (gfc_expr *, gfc_expr *);\n+try gfc_check_loc (gfc_expr *);\n try gfc_check_logical (gfc_expr *, gfc_expr *);\n try gfc_check_min_max (gfc_actual_arglist *);\n try gfc_check_min_max_integer (gfc_actual_arglist *);\n@@ -327,6 +328,7 @@ void gfc_resolve_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_len (gfc_expr *, gfc_expr *);\n void gfc_resolve_len_trim (gfc_expr *, gfc_expr *);\n void gfc_resolve_link (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_loc (gfc_expr *, gfc_expr *);\n void gfc_resolve_log (gfc_expr *, gfc_expr *);\n void gfc_resolve_log10 (gfc_expr *, gfc_expr *);\n void gfc_resolve_logical (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "5db2472590cd6168f2f2bb1b3440ddf7c6c7be39", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -87,6 +87,7 @@ and editing.  All contributions and corrections are strongly encouraged.\n * @code{EXPONENT}:      EXPONENT,  Exponent function\n * @code{FLOOR}:         FLOOR,     Integer floor function\n * @code{FNUM}:          FNUM,      File number function\n+* @code{LOC}:           LOC,       Returns the address of a variable\n * @code{LOG}:           LOG,       Logarithm function\n * @code{LOG10}:         LOG10,     Base 10 logarithm function \n * @code{REAL}:          REAL,      Convert to real type \n@@ -2724,7 +2725,43 @@ end program test_fnum\n @end smallexample\n @end table\n \n+@node LOC\n+@section @code{LOC} --- Returns the address of a variable\n+@findex @code{LOC} intrinsic\n+@cindex loc\n \n+@table @asis\n+@item @emph{Description}:\n+@code{LOC(X)} returns the address of @var{X} as an integer.\n+\n+@item @emph{Option}:\n+gnu\n+\n+@item @emph{Class}:\n+inquiry function\n+\n+@item @emph{Syntax}:\n+@code{I = LOC(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab Variable of any type.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER(n)}, where @code{n} is the\n+size (in bytes) of a memory address on the target machine.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_loc\n+  integer :: i\n+  real :: r\n+  i = loc(r)\n+  print *, i\n+end program test_loc\n+@end smallexample\n+@end table\n \n @node LOG\n @section @code{LOG} --- Logarithm function"}, {"sha": "db53302d0a3a2c9d053de4eb1a1376a9b920fa2d", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -119,7 +119,8 @@ by type.  Explanations are in the following sections.\n -fdollar-ok  -fimplicit-none  -fmax-identifier-length @gol\n -std=@var{std} -fd-lines-as-code -fd-lines-as-comments @gol\n -ffixed-line-length-@var{n}  -ffixed-line-length-none @gol\n--fdefault-double-8  -fdefault-integer-8  -fdefault-real-8 }\n+-fdefault-double-8  -fdefault-integer-8  -fdefault-real-8 @gol\n+-fcray-pointer }\n \n @item Warning Options\n @xref{Warning Options,,Options to Request or Suppress Warnings}.\n@@ -265,6 +266,11 @@ Specify that no implicit typing is allowed, unless overridden by explicit\n @samp{IMPLICIT} statements.  This is the equivalent of adding\n @samp{implicit none} to the start of every procedure.\n \n+@cindex -fcray-pointer option\n+@cindex options, -fcray-pointer\n+@item -fcray-pointer\n+Enables the Cray pointer extension, which provides a C-like pointer.\n+\n @cindex -std=@var{std} option\n @cindex option, -std=@var{std}\n @item -std=@var{std}"}, {"sha": "09d85e33974b27c146e2c63c796a7d9d9f535575", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -870,6 +870,15 @@ gfc_resolve_link (gfc_expr * f, gfc_expr * p1 ATTRIBUTE_UNUSED,\n }\n \n \n+void\n+gfc_resolve_loc (gfc_expr *f, gfc_expr *x)\n+{\n+  f->ts.type= BT_INTEGER;\n+  f->ts.kind = gfc_index_integer_kind;\n+  f->value.function.name = gfc_get_string (\"__loc_%d\", x->ts.kind);\n+}\n+\n+\n void\n gfc_resolve_log (gfc_expr * f, gfc_expr * x)\n {"}, {"sha": "b44c38b34a1cb99fbd616fdb807a97f0dc24040c", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -121,6 +121,10 @@ funderscoring\n Fortran\n Append underscores to externally visible names\n \n+fcray-pointer\n+Fortran\n+Use the Cray Pointer extension\n+\n fsecond-underscore\n Fortran\n Append a second underscore if the name already contains an underscore"}, {"sha": "53e8ec7b4192afe9a27c7a08a48d3c136796a71a", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -72,6 +72,7 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.flag_repack_arrays = 0;\n   gfc_option.flag_automatic = 1;\n   gfc_option.flag_backslash = 1;\n+  gfc_option.flag_cray_pointer = 0;\n   gfc_option.flag_d_lines = -1;\n \n   gfc_option.q_kind = gfc_default_double_kind;\n@@ -364,6 +365,10 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n     case OPT_Wunused_labels:\n       gfc_option.warn_unused_labels = value;\n       break;\n+      \n+    case OPT_fcray_pointer:\n+      gfc_option.flag_cray_pointer = value;\n+      break;\n \n     case OPT_ff2c:\n       gfc_option.flag_f2c = value;"}, {"sha": "8ae1162b6aedd80359bb6da8f2bb3746a2b5dfc1", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -2013,7 +2013,7 @@ resolve_array_ref (gfc_array_ref * ar)\n \t  }\n     }\n \n-  if (compare_spec_to_ref (ar) == FAILURE)\n+  if (!ar->as->cray_pointee && compare_spec_to_ref (ar) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -5176,6 +5176,14 @@ resolve_equivalence (gfc_equiv *eq)\n \t\t     sym->name, &e->where, sym->ns->proc_name->name);\n           break;\n         }\n+ \n+     /* Shall not be a Cray pointee.  */\n+      if (sym->attr.cray_pointee)\n+        {\n+          gfc_error (\"Cray Pointee '%s' at %L cannot be an EQUIVALENCE \"\n+\t\t     \"object\", sym->name, &e->where);\n+          continue;\n+        }\n \n       /* Shall not be a named constant.  */      \n       if (e->expr_type == EXPR_CONSTANT)"}, {"sha": "b9e76ef195c62c36ae957cdf8bcff22b9bd0b7b3", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -263,7 +263,8 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n     *public = \"PUBLIC\", *optional = \"OPTIONAL\", *entry = \"ENTRY\",\n     *function = \"FUNCTION\", *subroutine = \"SUBROUTINE\",\n     *dimension = \"DIMENSION\", *in_equivalence = \"EQUIVALENCE\",\n-    *use_assoc = \"USE ASSOCIATED\";\n+    *use_assoc = \"USE ASSOCIATED\", *cray_pointer = \"CRAY POINTER\",\n+    *cray_pointee = \"CRAY POINTEE\";\n \n   const char *a1, *a2;\n \n@@ -343,6 +344,31 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n \n   conf (function, subroutine);\n \n+  /* Cray pointer/pointee conflicts.  */\n+  conf (cray_pointer, cray_pointee);\n+  conf (cray_pointer, dimension);\n+  conf (cray_pointer, pointer);\n+  conf (cray_pointer, target);\n+  conf (cray_pointer, allocatable);\n+  conf (cray_pointer, external);\n+  conf (cray_pointer, intrinsic);\n+  conf (cray_pointer, in_namelist);\n+  conf (cray_pointer, function);\n+  conf (cray_pointer, subroutine);\n+  conf (cray_pointer, entry);\n+\n+  conf (cray_pointee, allocatable);\n+  conf (cray_pointee, intent);\n+  conf (cray_pointee, optional);\n+  conf (cray_pointee, dummy);\n+  conf (cray_pointee, target);\n+  conf (cray_pointee, external);\n+  conf (cray_pointee, intrinsic);\n+  conf (cray_pointee, pointer);\n+  conf (cray_pointee, function);\n+  conf (cray_pointee, subroutine);\n+  conf (cray_pointee, entry);\n+\n   a1 = gfc_code2string (flavors, attr->flavor);\n \n   if (attr->in_namelist\n@@ -652,6 +678,37 @@ gfc_add_pointer (symbol_attribute * attr, locus * where)\n }\n \n \n+try\n+gfc_add_cray_pointer (symbol_attribute * attr, locus * where)\n+{\n+\n+  if (check_used (attr, NULL, where) || check_done (attr, where))\n+    return FAILURE;\n+\n+  attr->cray_pointer = 1;\n+  return check_conflict (attr, NULL, where);\n+}\n+\n+\n+try\n+gfc_add_cray_pointee (symbol_attribute * attr, locus * where)\n+{\n+\n+  if (check_used (attr, NULL, where) || check_done (attr, where))\n+    return FAILURE;\n+\n+  if (attr->cray_pointee)\n+    {\n+      gfc_error (\"Cray Pointee at %L appears in multiple pointer()\"\n+\t\t \" statements.\", where);\n+      return FAILURE;\n+    }\n+\n+  attr->cray_pointee = 1;\n+  return check_conflict (attr, NULL, where);\n+}\n+\n+\n try\n gfc_add_result (symbol_attribute * attr, const char *name, locus * where)\n {\n@@ -1149,6 +1206,11 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n   if (gfc_missing_attr (dest, where) == FAILURE)\n     goto fail;\n \n+  if (src->cray_pointer && gfc_add_cray_pointer (dest, where) == FAILURE)\n+    goto fail;\n+  if (src->cray_pointee && gfc_add_cray_pointee (dest, where) == FAILURE)\n+    goto fail;    \n+  \n   /* The subroutines that set these bits also cause flavors to be set,\n      and that has already happened in the original, so don't let it\n      happen again.  */"}, {"sha": "1a09121f87c915ca11a7ae7497dc1e9bf2874654", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -3240,6 +3240,15 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   size = gfc_trans_array_bounds (type, sym, &offset, &block);\n \n+  /* Don't actually allocate space for Cray Pointees.  */\n+  if (sym->attr.cray_pointee)\n+    {\n+      if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n+\tgfc_add_modify_expr (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+      gfc_add_expr_to_block (&block, fnbody);\n+      return gfc_finish_block (&block);\n+    }\n+\n   /* The size is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n@@ -4074,7 +4083,13 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n        && expr->ref->u.ar.type == AR_FULL && g77)\n     {\n       sym = expr->symtree->n.sym;\n-      tmp = gfc_get_symbol_decl (sym);\n+\n+      /* Check to see if we're dealing with a Cray Pointee.  */\n+      if (sym->attr.cray_pointee)\n+\ttmp = gfc_conv_cray_pointee (sym);\n+      else\n+\ttmp = gfc_get_symbol_decl (sym);\n+      \n       if (sym->ts.type == BT_CHARACTER)\n \tse->string_length = sym->ts.cl->backend_decl;\n       if (!sym->attr.pointer && sym->as->type != AS_ASSUMED_SHAPE \n@@ -4625,4 +4640,3 @@ gfc_walk_expr (gfc_expr * expr)\n   res = gfc_walk_subexpr (gfc_ss_terminator, expr);\n   return gfc_reverse_ss (res);\n }\n-"}, {"sha": "4b6e226582874c4f855ba235b8a8d573ec1b3f52", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -416,6 +416,11 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n      This is the equivalent of the TARGET variables.\n      We also need to set this if the variable is passed by reference in a\n      CALL statement.  */\n+\n+  /* We don't want real declarations for Cray Pointees.  */\n+  if (sym->attr.cray_pointee)\n+    return;\n+\n   if (sym->attr.target)\n     TREE_ADDRESSABLE (decl) = 1;\n   /* If it wasn't used we wouldn't be getting it.  */\n@@ -2251,6 +2256,10 @@ gfc_create_module_variable (gfc_symbol * sym)\n   /* Create the decl.  */\n   decl = gfc_get_symbol_decl (sym);\n \n+  /* Don't create a \"real\" declaration for a Cray Pointee.  */\n+  if (sym->attr.cray_pointee)\n+    return;\n+\n   /* Create the variable.  */\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, 1, 0);\n@@ -2672,4 +2681,36 @@ gfc_generate_block_data (gfc_namespace * ns)\n   rest_of_decl_compilation (decl, 1, 0);\n }\n \n+/* gfc_conv_cray_pointee takes a sym with attribute cray_pointee and\n+   swaps in the backend_decl of its corresponding pointer.  There are\n+   2 cases; one for variable size arrays, and one for everything else,\n+   because variable-sized arrays require one fewer level of\n+   indirection.  */\n+\n+tree\n+gfc_conv_cray_pointee(gfc_symbol *sym)\n+{\n+  tree decl = gfc_get_symbol_decl (sym->cp_pointer);\n+\n+  /* Parameters need to be dereferenced.  */\n+  if (sym->cp_pointer->attr.dummy) \n+    decl = gfc_build_indirect_ref (decl);\n+\n+  /* Check to see if we're dealing with a variable-sized array.  */\n+  if (sym->attr.dimension\n+      && TREE_CODE (TREE_TYPE (sym->backend_decl)) == POINTER_TYPE) \n+    {  \n+      /* These decls will be derefenced later, so we don't dereference\n+\t them here.  */\n+      decl = convert (TREE_TYPE (sym->backend_decl), decl);\n+    }\n+  else\n+    {\n+      decl = convert (build_pointer_type (TREE_TYPE (sym->backend_decl)),\n+\t\t      decl);\n+      decl = gfc_build_indirect_ref (decl);\n+    }\n+  return decl;\n+}\n+\n #include \"gt-fortran-trans-decl.h\""}, {"sha": "4dc4d56b3565fbe3e4a1f7b09f3a3c743b32c832", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -316,7 +316,11 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n     {\n       tree se_expr = NULL_TREE;\n \n-      se->expr = gfc_get_symbol_decl (sym);\n+      /* Handle Cray Pointees.  */\n+      if (sym->attr.cray_pointee)\n+\tse->expr = gfc_conv_cray_pointee (sym);\n+      else\n+\tse->expr = gfc_get_symbol_decl (sym);\n \n       /* Special case for assigning the return value of a function.\n \t Self recursive functions must have an explicit return value.  */"}, {"sha": "4905ac57381de42f86b57cba1222e2fc34d8dbfc", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -2739,6 +2739,36 @@ gfc_conv_intrinsic_iargc (gfc_se * se, gfc_expr * expr)\n   se->expr = tmp;\n }\n \n+\n+/* The loc intrinsic returns the address of its argument as\n+   gfc_index_integer_kind integer.  */\n+\n+static void\n+gfc_conv_intrinsic_loc(gfc_se * se, gfc_expr * expr)\n+{\n+  tree temp_var;\n+  gfc_expr *arg_expr;\n+  gfc_ss *ss;\n+\n+  gcc_assert (!se->ss);\n+\n+  arg_expr = expr->value.function.actual->expr;\n+  ss = gfc_walk_expr (arg_expr);\n+  if (ss == gfc_ss_terminator)\n+    gfc_conv_expr_reference (se, arg_expr);\n+  else\n+    gfc_conv_array_parameter (se, arg_expr, ss, 1); \n+  se->expr= convert (gfc_unsigned_type (long_integer_type_node), \n+\t\t     se->expr);\n+   \n+  /* Create a temporary variable for loc return value.  Without this, \n+     we get an error an ICE in gcc/expr.c(expand_expr_addr_expr_1).  */\n+  temp_var = gfc_create_var (gfc_unsigned_type (long_integer_type_node), \n+\t\t\t     NULL);\n+  gfc_add_modify_expr (&se->pre, temp_var, se->expr);\n+  se->expr = temp_var;\n+}\n+\n /* Generate code for an intrinsic function.  Some map directly to library\n    calls, others get special handling.  In some cases the name of the function\n    used depends on the type specifiers.  */\n@@ -3047,6 +3077,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_bound (se, expr, 1);\n       break;\n \n+    case GFC_ISYM_LOC:\n+      gfc_conv_intrinsic_loc (se, expr);\n+      break;\n+\n     case GFC_ISYM_CHDIR:\n     case GFC_ISYM_DOT_PRODUCT:\n     case GFC_ISYM_ETIME:"}, {"sha": "16dd51747b90d33fe869a2fdfc7b251e13bf7b84", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -406,6 +406,9 @@ void gfc_generate_block_data (gfc_namespace *);\n /* Output a decl for a module variable.  */\n void gfc_generate_module_vars (gfc_namespace *);\n \n+/* Translate the declaration for a Cray Pointee.  */\n+tree gfc_conv_cray_pointee (gfc_symbol *sym);\n+\n /* Get and set the current location.  */\n void gfc_set_backend_locus (locus *);\n void gfc_get_backend_locus (locus *);"}, {"sha": "fa6e53c018cb8dc0793d81f29fa8ba3a38b80f4f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -1,3 +1,13 @@\n+2005-10-24  Asher Langton  <langton2@llnl.gov>\n+\n+\tPR fortran/17031\n+\tPR fortran/22282\n+\t* gfortran.dg/cray_pointers_1.f90: New test.\n+\t* gfortran.dg/cray_pointers_2.f90: New test.\n+\t* gfortran.dg/cray_pointers_3.f90: New test.\n+\t* gfortran.dg/loc_1.f90: New test.\n+\t* gfortran.dg/loc_2.f90: New test.\n+\n 2005-10-24  Steven Bosscher  <stevenb@suse.de>\n \n \t* gcc.dg/pr24225.c: New test."}, {"sha": "b23a300feac01228558f3119bfc7c0aee627bd2b", "filename": "gcc/testsuite/gfortran.dg/cray_pointers_1.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_1.f90?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do compile }\n+! { dg-options \"-fcray-pointer\" }\n+\n+! Bad type for pointer\n+subroutine err1\n+  real ipt\n+  real array(10)\n+  pointer (ipt, array) ! { dg-error \"integer\" }\n+end subroutine err1\n+\n+! Multiple declarations for the same pointee\n+subroutine err2\n+  real array(10)\n+  pointer (ipt1, array)\n+  pointer (ipt2, array) ! { dg-error \"multiple\" }\n+end subroutine err2\n+\n+! Vector assignment to an assumed size array\n+subroutine err3\n+  real target(10)\n+  real array(*)\n+  pointer (ipt, array)\n+  ipt = loc (target)\n+  array = 0    ! { dg-error \"Vector assignment\" }\n+end subroutine err3\n+\n+subroutine err4\n+  pointer (ipt, ipt) ! { dg-error \"POINTER attribute\" }\n+end subroutine err4\n+\n+! duplicate array specs\n+subroutine err5\n+  pointer (ipt, array(7))\n+  real array(10)      ! { dg-error \"Duplicate array\" }  \n+end subroutine err5\n+\n+subroutine err6\n+  real array(10)\n+  pointer (ipt, array(7))  ! { dg-error \"Duplicate array\" }\n+end subroutine err6\n+\n+! parsing stuff\n+subroutine err7\n+  pointer (                  ! { dg-error \"variable name\" }\n+  pointer (ipt               ! { dg-error \"Expected\" }\n+  pointer (ipt,              ! { dg-error \"variable name\" }\n+  pointer (ipt,a1            ! { dg-error \"Expected\" }\n+  pointer (ipt,a2),          ! { dg-error \"Expected\" }\n+  pointer (ipt,a3),(         ! { dg-error \"variable name\" }\n+  pointer (ipt,a4),(ipt2     ! { dg-error \"Expected\" }\n+  pointer (ipt,a5),(ipt2,    ! { dg-error \"variable name\" }\n+  pointer (ipt,a6),(ipt2,a7  ! { dg-error \"Expected\" }\n+end subroutine err7\n+\n+! more attributes\n+subroutine err8(array)\n+  real array(10)\n+  integer dim(2)\n+  integer, pointer :: f90ptr\n+  integer, target :: f90targ\n+  pointer (ipt, array)    ! { dg-error \"DUMMY\" }\n+  pointer (dim, elt1)     ! { dg-error \"DIMENSION\" }\n+  pointer (f90ptr, elt2)  ! { dg-error \"POINTER\" }\n+  pointer (ipt, f90ptr)   ! { dg-error \"POINTER\" }\n+  pointer (f90targ, elt3) ! { dg-error \"TARGET\" }\n+  pointer (ipt, f90targ)  ! { dg-error \"TARGET\" }\n+end subroutine err8\n+"}, {"sha": "7c958d57b0a0242c63eff31d04abfcc293b70444", "filename": "gcc/testsuite/gfortran.dg/cray_pointers_2.f90", "status": "added", "additions": 3606, "deletions": 0, "changes": 3606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_2.f90?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84"}, {"sha": "de50eee77440b8af177d8540244c15c4787cd51f", "filename": "gcc/testsuite/gfortran.dg/cray_pointers_3.f90", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_3.f90?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -0,0 +1,5 @@\n+! { dg-do compile }\n+program crayerr\n+  real dpte1(10)\n+  pointer (iptr1,dpte1) ! { dg-error \"fcray-pointer\" }\n+end program crayerr"}, {"sha": "ef0b1c102800728dde9da580658d7ac196ecf97a", "filename": "gcc/testsuite/gfortran.dg/loc_1.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Floc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Floc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floc_1.f90?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+\n+! This test is here to prevent a regression in gfc_conv_intrinsic_loc.\n+! Taking the loc of something in a common block was a special case\n+! that caused in internal compiler error in gcc/expr.c, in\n+! expand_expr_addr_expr_1().\n+program test\n+  common /targ/targ\n+  integer targ(10)\n+  call fn\n+end program test\n+\n+subroutine fn\n+  common /targ/targ\n+  integer targ(10)\n+  call foo (loc (targ)) ! Line that caused ICE\n+end subroutine fn\n+\n+subroutine foo (ii)\n+  common /targ/targ\n+  integer targ(10)\n+  integer ii\n+  targ(2) = ii\n+end subroutine foo\n+"}, {"sha": "196dcc6db74dce1effe9750127e4d79f725269ba", "filename": "gcc/testsuite/gfortran.dg/loc_2.f90", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Floc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d890b9ba13c57aec4dcee1de9901ceab6e9a84/gcc%2Ftestsuite%2Fgfortran.dg%2Floc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floc_2.f90?ref=83d890b9ba13c57aec4dcee1de9901ceab6e9a84", "patch": "@@ -0,0 +1,113 @@\n+! { dg-do run }\n+! Series of routines for testing a loc() implementation\n+program test\n+  common /errors/errors(12)\n+  integer i\n+  logical errors\n+  errors = .false.\n+  call testloc\n+  do i=1,12\n+     if (errors(i)) then\n+        call abort()\n+     endif\n+  end do\n+end program test\n+\n+! Test loc\n+subroutine testloc\n+  common /errors/errors(12)\n+  logical errors\n+  integer, parameter :: n = 9\n+  integer, parameter :: m = 10\n+  integer, parameter :: o = 11\n+  integer :: offset\n+  integer :: i,j,k,intsize,realsize,dblsize,chsize,ch8size\n+  integer itarg1 (n)\n+  integer itarg2 (m,n)\n+  integer itarg3 (o,m,n)\n+  real rtarg1(n)\n+  real rtarg2(m,n)\n+  real rtarg3(o,m,n)\n+  character chtarg1(n)\n+  character chtarg2(m,n)\n+  character chtarg3(o,m,n)\n+  character*8 ch8targ1(n)\n+  character*8 ch8targ2(m,n)\n+  character*8 ch8targ3(o,m,n)\n+\n+  intsize = kind(itarg1(1))\n+  realsize = kind(rtarg1(1))\n+  chsize = kind(chtarg1(1))*len(chtarg1(1))\n+  ch8size = kind(ch8targ1(1))*len(ch8targ1(1))\n+\n+  do, i=1,n\n+     offset = i-1\n+     if (loc(itarg1).ne.loc(itarg1(i))-offset*intsize) then\n+        ! Error #1\n+        errors(1) = .true.\n+     end if\n+     if (loc(rtarg1).ne.loc(rtarg1(i))-offset*realsize) then\n+        ! Error #2\n+        errors(2) = .true.\n+     end if\n+     if (loc(chtarg1).ne.loc(chtarg1(i))-offset*chsize) then\n+        ! Error #3\n+        errors(3) = .true.\n+     end if\n+     if (loc(ch8targ1).ne.loc(ch8targ1(i))-offset*ch8size) then\n+        ! Error #4\n+        errors(4) = .true.\n+     end if\n+\n+     do, j=1,m\n+        offset = (j-1)+m*(i-1)\n+        if (loc(itarg2).ne. &\n+             loc(itarg2(j,i))-offset*intsize) then\n+           ! Error #5\n+           errors(5) = .true.\n+        end if\n+        if (loc(rtarg2).ne. &\n+             loc(rtarg2(j,i))-offset*realsize) then\n+           ! Error #6\n+           errors(6) = .true.\n+        end if\n+        if (loc(chtarg2).ne. &\n+             loc(chtarg2(j,i))-offset*chsize) then\n+           ! Error #7\n+           errors(7) = .true.\n+        end if\n+        if (loc(ch8targ2).ne. &\n+             loc(ch8targ2(j,i))-offset*ch8size) then\n+           ! Error #8\n+           errors(8) = .true.\n+        end if\n+\n+        do k=1,o\n+           offset = (k-1)+o*(j-1)+o*m*(i-1)\n+           if (loc(itarg3).ne. &\n+                loc(itarg3(k,j,i))-offset*intsize) then\n+              ! Error #9\n+              errors(9) = .true.\n+           end if\n+           if (loc(rtarg3).ne. &\n+                loc(rtarg3(k,j,i))-offset*realsize) then\n+              ! Error #10\n+              errors(10) = .true.\n+           end if\n+           if (loc(chtarg3).ne. &\n+                loc(chtarg3(k,j,i))-offset*chsize) then\n+              ! Error #11\n+              errors(11) = .true.\n+           end if\n+           if (loc(ch8targ3).ne. &\n+                loc(ch8targ3(k,j,i))-offset*ch8size) then\n+              ! Error #12\n+              errors(12) = .true.\n+           end if\n+\n+        end do\n+     end do\n+  end do\n+\n+end subroutine testloc\n+"}]}