{"sha": "a788747592b6d2d80ce20d8b1f1f3582ac80d4b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc4ODc0NzU5MmI2ZDJkODBjZTIwZDhiMWYxZjM1ODJhYzgwZDRiNw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2013-11-17T16:36:51Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2013-11-17T16:36:51Z"}, "message": "rs6000.c (rs6000_frame_related): Add split_reg parameter and use it in REG_FRAME_RELATED_EXPR note.\n\n2011-11-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_frame_related): Add split_reg\n\tparameter and use it in REG_FRAME_RELATED_EXPR note.\n\t(emit_frame_save): Call rs6000_frame_related with extra NULL_RTX\n\tparameter.\n\t(rs6000_emit_prologue): Likewise, but for little endian VSX\n\tstores, pass the source register of the store instead.\n\nFrom-SVN: r204920", "tree": {"sha": "a2024374a306c1da286c76d1586ff54159fd8825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2024374a306c1da286c76d1586ff54159fd8825"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a788747592b6d2d80ce20d8b1f1f3582ac80d4b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a788747592b6d2d80ce20d8b1f1f3582ac80d4b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a788747592b6d2d80ce20d8b1f1f3582ac80d4b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a788747592b6d2d80ce20d8b1f1f3582ac80d4b7/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fe37220afe33a180e8fcfaae485fe878a62938e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fe37220afe33a180e8fcfaae485fe878a62938e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fe37220afe33a180e8fcfaae485fe878a62938e"}], "stats": {"total": 46, "additions": 35, "deletions": 11}, "files": [{"sha": "87802f84e5032482ab6b4eacf558716199392614", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a788747592b6d2d80ce20d8b1f1f3582ac80d4b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a788747592b6d2d80ce20d8b1f1f3582ac80d4b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a788747592b6d2d80ce20d8b1f1f3582ac80d4b7", "patch": "@@ -1,3 +1,12 @@\n+2011-11-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_frame_related): Add split_reg\n+\tparameter and use it in REG_FRAME_RELATED_EXPR note.\n+\t(emit_frame_save): Call rs6000_frame_related with extra NULL_RTX\n+\tparameter.\n+\t(rs6000_emit_prologue): Likewise, but for little endian VSX\n+\tstores, pass the source register of the store instead.\n+\n 2013-11-17  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* gimple.h: Reorder prototypes to match .c declaration order, and remove"}, {"sha": "d042fad044aaeb76651dc8989c6807d8c5bf9f0f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a788747592b6d2d80ce20d8b1f1f3582ac80d4b7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a788747592b6d2d80ce20d8b1f1f3582ac80d4b7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a788747592b6d2d80ce20d8b1f1f3582ac80d4b7", "patch": "@@ -21439,7 +21439,7 @@ output_probe_stack_range (rtx reg1, rtx reg2)\n \n static rtx\n rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n-\t\t      rtx reg2, rtx rreg)\n+\t\t      rtx reg2, rtx rreg, rtx split_reg)\n {\n   rtx real, temp;\n \n@@ -21530,6 +21530,11 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t  }\n     }\n \n+  /* If a store insn has been split into multiple insns, the\n+     true source register is given by split_reg.  */\n+  if (split_reg != NULL_RTX)\n+    real = gen_rtx_SET (VOIDmode, SET_DEST (real), split_reg);\n+\n   RTX_FRAME_RELATED_P (insn) = 1;\n   add_reg_note (insn, REG_FRAME_RELATED_EXPR, real);\n \n@@ -21637,7 +21642,7 @@ emit_frame_save (rtx frame_reg, enum machine_mode mode,\n   reg = gen_rtx_REG (mode, regno);\n   insn = emit_insn (gen_frame_store (reg, frame_reg, offset));\n   return rs6000_frame_related (insn, frame_reg, frame_reg_to_sp,\n-\t\t\t       NULL_RTX, NULL_RTX);\n+\t\t\t       NULL_RTX, NULL_RTX, NULL_RTX);\n }\n \n /* Emit an offset memory reference suitable for a frame store, while\n@@ -22217,7 +22222,7 @@ rs6000_emit_prologue (void)\n \n       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n       rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t    treg, GEN_INT (-info->total_size));\n+\t\t\t    treg, GEN_INT (-info->total_size), NULL_RTX);\n       sp_off = frame_off = info->total_size;\n     }\n \n@@ -22302,7 +22307,7 @@ rs6000_emit_prologue (void)\n \n \t  insn = emit_move_insn (mem, reg);\n \t  rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t\tNULL_RTX, NULL_RTX);\n+\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n \t  END_USE (0);\n \t}\n     }\n@@ -22358,7 +22363,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t     info->lr_save_offset,\n \t\t\t\t     DFmode, sel);\n       rs6000_frame_related (insn, ptr_reg, sp_off,\n-\t\t\t    NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       if (lr)\n \tEND_USE (0);\n     }\n@@ -22437,7 +22442,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t\t SAVRES_SAVE | SAVRES_GPR);\n \n \t  rs6000_frame_related (insn, spe_save_area_ptr, sp_off - save_off,\n-\t\t\t\tNULL_RTX, NULL_RTX);\n+\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n \t}\n \n       /* Move the static chain pointer back.  */\n@@ -22487,7 +22492,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t     info->lr_save_offset + ptr_off,\n \t\t\t\t     reg_mode, sel);\n       rs6000_frame_related (insn, ptr_reg, sp_off - ptr_off,\n-\t\t\t    NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       if (lr)\n \tEND_USE (0);\n     }\n@@ -22503,7 +22508,7 @@ rs6000_emit_prologue (void)\n \t\t\t     info->gp_save_offset + frame_off + reg_size * i);\n       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n       rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t    NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n     }\n   else if (!WORLD_SAVE_P (info))\n     {\n@@ -22826,7 +22831,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t     info->altivec_save_offset + ptr_off,\n \t\t\t\t     0, V4SImode, SAVRES_SAVE | SAVRES_VR);\n       rs6000_frame_related (insn, scratch_reg, sp_off - ptr_off,\n-\t\t\t    NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       if (REGNO (frame_reg_rtx) == REGNO (scratch_reg))\n \t{\n \t  /* The oddity mentioned above clobbered our frame reg.  */\n@@ -22842,7 +22847,7 @@ rs6000_emit_prologue (void)\n       for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n \tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n \t  {\n-\t    rtx areg, savereg, mem;\n+\t    rtx areg, savereg, mem, split_reg;\n \t    int offset;\n \n \t    offset = (info->altivec_save_offset + frame_off\n@@ -22860,8 +22865,18 @@ rs6000_emit_prologue (void)\n \n \t    insn = emit_move_insn (mem, savereg);\n \n+\t    /* When we split a VSX store into two insns, we need to make\n+\t       sure the DWARF info knows which register we are storing.\n+\t       Pass it in to be used on the appropriate note.  */\n+\t    if (!BYTES_BIG_ENDIAN\n+\t\t&& GET_CODE (PATTERN (insn)) == SET\n+\t\t&& GET_CODE (SET_SRC (PATTERN (insn))) == VEC_SELECT)\n+\t      split_reg = savereg;\n+\t    else\n+\t      split_reg = NULL_RTX;\n+\n \t    rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t\t  areg, GEN_INT (offset));\n+\t\t\t\t  areg, GEN_INT (offset), split_reg);\n \t  }\n     }\n "}]}