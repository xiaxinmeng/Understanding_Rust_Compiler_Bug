{"sha": "659d8efa540dfd87570b568e93e2629ce9a45771", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU5ZDhlZmE1NDBkZmQ4NzU3MGI1NjhlOTNlMjYyOWNlOWE0NTc3MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-02T16:07:47Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-02T16:07:47Z"}, "message": "fold-const.c (fold_unary): New.\n\n\t* fold-const.c (fold_unary): New.\n\t(fold): Call fold_unary on unary expressions.\n\nFrom-SVN: r95783", "tree": {"sha": "9da426d8950507964a9a8676548cea29910bff7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9da426d8950507964a9a8676548cea29910bff7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/659d8efa540dfd87570b568e93e2629ce9a45771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/659d8efa540dfd87570b568e93e2629ce9a45771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/659d8efa540dfd87570b568e93e2629ce9a45771", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/659d8efa540dfd87570b568e93e2629ce9a45771/comments", "author": null, "committer": null, "parents": [{"sha": "92fb2d32d5e8ff33855ab277581cd088c36cffa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92fb2d32d5e8ff33855ab277581cd088c36cffa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92fb2d32d5e8ff33855ab277581cd088c36cffa5"}], "stats": {"total": 438, "additions": 438, "deletions": 0}, "files": [{"sha": "247b1f26b9c1caa009d8c4b0db65941f516258dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/659d8efa540dfd87570b568e93e2629ce9a45771/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/659d8efa540dfd87570b568e93e2629ce9a45771/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=659d8efa540dfd87570b568e93e2629ce9a45771", "patch": "@@ -10,6 +10,9 @@\n \t* expr.c (optimize_bitfield_assignment_op): Add a special case\n \tto handle BIT_IOR_EXPR and BIT_XOR_EXPR.\n \n+\t* fold-const.c (fold_unary): New.\n+\t(fold): Call fold_unary on unary expressions.\n+\n 2005-03-02  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* cgraph.h (struct cgraph_edge): Add prev_caller and"}, {"sha": "42d72969f8578b98a078887956cf67800355b7c0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/659d8efa540dfd87570b568e93e2629ce9a45771/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/659d8efa540dfd87570b568e93e2629ce9a45771/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=659d8efa540dfd87570b568e93e2629ce9a45771", "patch": "@@ -6596,6 +6596,430 @@ fold_complex_div (tree type, tree ac, tree bc, enum tree_code code)\n   return fold_complex_div_parts (type, ar, ai, br, bi, code);\n }\n \n+/* Fold a unary expression EXPR.  Return the folded expression if\n+   folding is successful.  Otherwise, return the original\n+   expression.  */\n+\n+static tree\n+fold_unary (tree expr)\n+{\n+  const tree t = expr;\n+  const tree type = TREE_TYPE (expr);\n+  tree tem;\n+  tree arg0;\n+  enum tree_code code = TREE_CODE (t);\n+  enum tree_code_class kind = TREE_CODE_CLASS (code);\n+\n+  gcc_assert (IS_EXPR_CODE_CLASS (kind)\n+\t      && TREE_CODE_LENGTH (code) == 1);\n+\n+\n+  arg0 = TREE_OPERAND (t, 0);\n+  if (arg0)\n+    {\n+      if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n+\t{\n+\t  /* Don't use STRIP_NOPS, because signedness of argument type matters.  */\n+\t  STRIP_SIGN_NOPS (arg0);\n+\t}\n+      else\n+\t{\n+\t  /* Strip any conversions that don't change the mode.  This\n+\t     is safe for every expression, except for a comparison\n+\t     expression because its signedness is derived from its\n+\t     operands.\n+\n+\t     Note that this is done as an internal manipulation within\n+\t     the constant folder, in order to find the simplest\n+\t     representation of the arguments so that their form can be\n+\t     studied.  In any cases, the appropriate type conversions\n+\t     should be put back in the tree that will get out of the\n+\t     constant folder.  */\n+\t  STRIP_NOPS (arg0);\n+\t}\n+    }\n+\n+  if (TREE_CODE_CLASS (code) == tcc_unary)\n+    {\n+      if (TREE_CODE (arg0) == COMPOUND_EXPR)\n+\treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t       fold (build1 (code, type, TREE_OPERAND (arg0, 1))));\n+      else if (TREE_CODE (arg0) == COND_EXPR)\n+\t{\n+\t  tree arg01 = TREE_OPERAND (arg0, 1);\n+\t  tree arg02 = TREE_OPERAND (arg0, 2);\n+\t  if (! VOID_TYPE_P (TREE_TYPE (arg01)))\n+\t    arg01 = fold (build1 (code, type, arg01));\n+\t  if (! VOID_TYPE_P (TREE_TYPE (arg02)))\n+\t    arg02 = fold (build1 (code, type, arg02));\n+\t  tem = fold (build3 (COND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t      arg01, arg02));\n+\n+\t  /* If this was a conversion, and all we did was to move into\n+\t     inside the COND_EXPR, bring it back out.  But leave it if\n+\t     it is a conversion from integer to integer and the\n+\t     result precision is no wider than a word since such a\n+\t     conversion is cheap and may be optimized away by combine,\n+\t     while it couldn't if it were outside the COND_EXPR.  Then return\n+\t     so we don't get into an infinite recursion loop taking the\n+\t     conversion out and then back in.  */\n+\n+\t  if ((code == NOP_EXPR || code == CONVERT_EXPR\n+\t       || code == NON_LVALUE_EXPR)\n+\t      && TREE_CODE (tem) == COND_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (tem, 1)) == code\n+\t      && TREE_CODE (TREE_OPERAND (tem, 2)) == code\n+\t      && ! VOID_TYPE_P (TREE_OPERAND (tem, 1))\n+\t      && ! VOID_TYPE_P (TREE_OPERAND (tem, 2))\n+\t      && (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 1), 0))\n+\t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 2), 0)))\n+\t      && (! (INTEGRAL_TYPE_P (TREE_TYPE (tem))\n+\t\t     && (INTEGRAL_TYPE_P\n+\t\t\t (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 1), 0))))\n+\t\t     && TYPE_PRECISION (TREE_TYPE (tem)) <= BITS_PER_WORD)\n+\t\t  || flag_syntax_only))\n+\t    tem = build1 (code, type,\n+\t\t\t  build3 (COND_EXPR,\n+\t\t\t\t  TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t     (TREE_OPERAND (tem, 1), 0)),\n+\t\t\t\t  TREE_OPERAND (tem, 0),\n+\t\t\t\t  TREE_OPERAND (TREE_OPERAND (tem, 1), 0),\n+\t\t\t\t  TREE_OPERAND (TREE_OPERAND (tem, 2), 0)));\n+\t  return tem;\n+\t}\n+      else if (COMPARISON_CLASS_P (arg0))\n+\t{\n+\t  if (TREE_CODE (type) == BOOLEAN_TYPE)\n+\t    {\n+\t      arg0 = copy_node (arg0);\n+\t      TREE_TYPE (arg0) = type;\n+\t      return arg0;\n+\t    }\n+\t  else if (TREE_CODE (type) != INTEGER_TYPE)\n+\t    return fold (build3 (COND_EXPR, type, arg0,\n+\t\t\t\t fold (build1 (code, type,\n+\t\t\t\t\t       integer_one_node)),\n+\t\t\t\t fold (build1 (code, type,\n+\t\t\t\t\t       integer_zero_node))));\n+\t}\n+   }\n+\n+  switch (code)\n+    {\n+    case NOP_EXPR:\n+    case FLOAT_EXPR:\n+    case CONVERT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FIX_CEIL_EXPR:\n+    case FIX_FLOOR_EXPR:\n+    case FIX_ROUND_EXPR:\n+      if (TREE_TYPE (TREE_OPERAND (t, 0)) == type)\n+\treturn TREE_OPERAND (t, 0);\n+\n+      /* Handle cases of two conversions in a row.  */\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (t, 0)) == CONVERT_EXPR)\n+\t{\n+\t  tree inside_type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t  tree inter_type = TREE_TYPE (TREE_OPERAND (t, 0));\n+\t  int inside_int = INTEGRAL_TYPE_P (inside_type);\n+\t  int inside_ptr = POINTER_TYPE_P (inside_type);\n+\t  int inside_float = FLOAT_TYPE_P (inside_type);\n+\t  unsigned int inside_prec = TYPE_PRECISION (inside_type);\n+\t  int inside_unsignedp = TYPE_UNSIGNED (inside_type);\n+\t  int inter_int = INTEGRAL_TYPE_P (inter_type);\n+\t  int inter_ptr = POINTER_TYPE_P (inter_type);\n+\t  int inter_float = FLOAT_TYPE_P (inter_type);\n+\t  unsigned int inter_prec = TYPE_PRECISION (inter_type);\n+\t  int inter_unsignedp = TYPE_UNSIGNED (inter_type);\n+\t  int final_int = INTEGRAL_TYPE_P (type);\n+\t  int final_ptr = POINTER_TYPE_P (type);\n+\t  int final_float = FLOAT_TYPE_P (type);\n+\t  unsigned int final_prec = TYPE_PRECISION (type);\n+\t  int final_unsignedp = TYPE_UNSIGNED (type);\n+\n+\t  /* In addition to the cases of two conversions in a row\n+\t     handled below, if we are converting something to its own\n+\t     type via an object of identical or wider precision, neither\n+\t     conversion is needed.  */\n+\t  if (TYPE_MAIN_VARIANT (inside_type) == TYPE_MAIN_VARIANT (type)\n+\t      && ((inter_int && final_int) || (inter_float && final_float))\n+\t      && inter_prec >= final_prec)\n+\t    return fold (build1 (code, type,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+\n+\t  /* Likewise, if the intermediate and final types are either both\n+\t     float or both integer, we don't need the middle conversion if\n+\t     it is wider than the final type and doesn't change the signedness\n+\t     (for integers).  Avoid this if the final type is a pointer\n+\t     since then we sometimes need the inner conversion.  Likewise if\n+\t     the outer has a precision not equal to the size of its mode.  */\n+\t  if ((((inter_int || inter_ptr) && (inside_int || inside_ptr))\n+\t       || (inter_float && inside_float))\n+\t      && inter_prec >= inside_prec\n+\t      && (inter_float || inter_unsignedp == inside_unsignedp)\n+\t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (type))\n+\t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n+\t      && ! final_ptr)\n+\t    return fold (build1 (code, type,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+\n+\t  /* If we have a sign-extension of a zero-extended value, we can\n+\t     replace that by a single zero-extension.  */\n+\t  if (inside_int && inter_int && final_int\n+\t      && inside_prec < inter_prec && inter_prec < final_prec\n+\t      && inside_unsignedp && !inter_unsignedp)\n+\t    return fold (build1 (code, type,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+\n+\t  /* Two conversions in a row are not needed unless:\n+\t     - some conversion is floating-point (overstrict for now), or\n+\t     - the intermediate type is narrower than both initial and\n+\t       final, or\n+\t     - the intermediate type and innermost type differ in signedness,\n+\t       and the outermost type is wider than the intermediate, or\n+\t     - the initial type is a pointer type and the precisions of the\n+\t       intermediate and final types differ, or\n+\t     - the final type is a pointer type and the precisions of the\n+\t       initial and intermediate types differ.  */\n+\t  if (! inside_float && ! inter_float && ! final_float\n+\t      && (inter_prec > inside_prec || inter_prec > final_prec)\n+\t      && ! (inside_int && inter_int\n+\t\t    && inter_unsignedp != inside_unsignedp\n+\t\t    && inter_prec < final_prec)\n+\t      && ((inter_unsignedp && inter_prec > inside_prec)\n+\t\t  == (final_unsignedp && final_prec > inter_prec))\n+\t      && ! (inside_ptr && inter_prec != final_prec)\n+\t      && ! (final_ptr && inside_prec != inter_prec)\n+\t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (type))\n+\t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n+\t      && ! final_ptr)\n+\t    return fold (build1 (code, type,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+\t}\n+\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == MODIFY_EXPR\n+\t  && TREE_CONSTANT (TREE_OPERAND (TREE_OPERAND (t, 0), 1))\n+\t  /* Detect assigning a bitfield.  */\n+\t  && !(TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)) == COMPONENT_REF\n+\t       && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 0), 0), 1))))\n+\t{\n+\t  /* Don't leave an assignment inside a conversion\n+\t     unless assigning a bitfield.  */\n+\t  tree prev = TREE_OPERAND (t, 0);\n+\t  tem = copy_node (t);\n+\t  TREE_OPERAND (tem, 0) = TREE_OPERAND (prev, 1);\n+\t  /* First do the assignment, then return converted constant.  */\n+\t  tem = build2 (COMPOUND_EXPR, TREE_TYPE (tem), prev, fold (tem));\n+\t  TREE_NO_WARNING (tem) = 1;\n+\t  TREE_USED (tem) = 1;\n+\t  return tem;\n+\t}\n+\n+      /* Convert (T)(x & c) into (T)x & (T)c, if c is an integer\n+\t constants (if x has signed type, the sign bit cannot be set\n+\t in c).  This folds extension into the BIT_AND_EXPR.  */\n+      if (INTEGRAL_TYPE_P (type)\n+\t  && TREE_CODE (type) != BOOLEAN_TYPE\n+\t  && TREE_CODE (TREE_OPERAND (t, 0)) == BIT_AND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 1)) == INTEGER_CST)\n+\t{\n+\t  tree and = TREE_OPERAND (t, 0);\n+\t  tree and0 = TREE_OPERAND (and, 0), and1 = TREE_OPERAND (and, 1);\n+\t  int change = 0;\n+\n+\t  if (TYPE_UNSIGNED (TREE_TYPE (and))\n+\t      || (TYPE_PRECISION (type)\n+\t\t  <= TYPE_PRECISION (TREE_TYPE (and))))\n+\t    change = 1;\n+\t  else if (TYPE_PRECISION (TREE_TYPE (and1))\n+\t\t   <= HOST_BITS_PER_WIDE_INT\n+\t\t   && host_integerp (and1, 1))\n+\t    {\n+\t      unsigned HOST_WIDE_INT cst;\n+\n+\t      cst = tree_low_cst (and1, 1);\n+\t      cst &= (HOST_WIDE_INT) -1\n+\t\t     << (TYPE_PRECISION (TREE_TYPE (and1)) - 1);\n+\t      change = (cst == 0);\n+#ifdef LOAD_EXTEND_OP\n+\t      if (change\n+\t\t  && !flag_syntax_only\n+\t\t  && (LOAD_EXTEND_OP (TYPE_MODE (TREE_TYPE (and0)))\n+\t\t      == ZERO_EXTEND))\n+\t\t{\n+\t\t  tree uns = lang_hooks.types.unsigned_type (TREE_TYPE (and0));\n+\t\t  and0 = fold_convert (uns, and0);\n+\t\t  and1 = fold_convert (uns, and1);\n+\t\t}\n+#endif\n+\t    }\n+\t  if (change)\n+\t    {\n+\t      tem = build_int_cst_wide (type, TREE_INT_CST_LOW (and1),\n+\t\t\t\t\tTREE_INT_CST_HIGH (and1));\n+\t      tem = force_fit_type (tem, 0, TREE_OVERFLOW (and1),\n+\t\t\t\t    TREE_CONSTANT_OVERFLOW (and1));\n+\t      return fold (build2 (BIT_AND_EXPR, type,\n+\t\t\t\t   fold_convert (type, and0), tem));\n+\t    }\n+\t}\n+\n+      /* Convert (T1)((T2)X op Y) into (T1)X op Y, for pointer types T1 and\n+\t T2 being pointers to types of the same size.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (t))\n+\t  && BINARY_CLASS_P (arg0)\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == NOP_EXPR\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n+\t{\n+\t  tree arg00 = TREE_OPERAND (arg0, 0);\n+\t  tree t0 = TREE_TYPE (t);\n+\t  tree t1 = TREE_TYPE (arg00);\n+\t  tree tt0 = TREE_TYPE (t0);\n+\t  tree tt1 = TREE_TYPE (t1);\n+\t  tree s0 = TYPE_SIZE (tt0);\n+\t  tree s1 = TYPE_SIZE (tt1);\n+\n+\t  if (s0 && s1 && operand_equal_p (s0, s1, OEP_ONLY_CONST))\n+\t    return build2 (TREE_CODE (arg0), t0, fold_convert (t0, arg00),\n+\t\t\t   TREE_OPERAND (arg0, 1));\n+\t}\n+\n+      tem = fold_convert_const (code, type, arg0);\n+      return tem ? tem : t;\n+\n+    case VIEW_CONVERT_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == VIEW_CONVERT_EXPR)\n+\treturn build1 (VIEW_CONVERT_EXPR, type,\n+\t\t       TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+      return t;\n+\n+    case NEGATE_EXPR:\n+      if (negate_expr_p (arg0))\n+\treturn fold_convert (type, negate_expr (arg0));\n+      /* Convert - (~A) to A + 1.  */\n+      if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == BIT_NOT_EXPR)\n+\treturn fold (build2 (PLUS_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t     build_int_cst (type, 1)));\n+      return t;\n+\n+    case ABS_EXPR:\n+      if (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST)\n+\treturn fold_abs_const (arg0, type);\n+      else if (TREE_CODE (arg0) == NEGATE_EXPR)\n+\treturn fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg0, 0)));\n+      /* Convert fabs((double)float) into (double)fabsf(float).  */\n+      else if (TREE_CODE (arg0) == NOP_EXPR\n+\t       && TREE_CODE (type) == REAL_TYPE)\n+\t{\n+\t  tree targ0 = strip_float_extensions (arg0);\n+\t  if (targ0 != arg0)\n+\t    return fold_convert (type, fold (build1 (ABS_EXPR,\n+\t\t\t\t\t\t     TREE_TYPE (targ0),\n+\t\t\t\t\t\t     targ0)));\n+\t}\n+      else if (tree_expr_nonnegative_p (arg0))\n+\treturn arg0;\n+\n+      /* Strip sign ops from argument.  */\n+      if (TREE_CODE (type) == REAL_TYPE)\n+\t{\n+\t  tem = fold_strip_sign_ops (arg0);\n+\t  if (tem)\n+\t    return fold (build1 (ABS_EXPR, type, fold_convert (type, tem)));\n+\t}\n+      return t;\n+\n+    case CONJ_EXPR:\n+      if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n+\treturn fold_convert (type, arg0);\n+      else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n+\treturn build2 (COMPLEX_EXPR, type,\n+\t\t       TREE_OPERAND (arg0, 0),\n+\t\t       negate_expr (TREE_OPERAND (arg0, 1)));\n+      else if (TREE_CODE (arg0) == COMPLEX_CST)\n+\treturn build_complex (type, TREE_REALPART (arg0),\n+\t\t\t      negate_expr (TREE_IMAGPART (arg0)));\n+      else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n+\treturn fold (build2 (TREE_CODE (arg0), type,\n+\t\t\t     fold (build1 (CONJ_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n+\t\t\t     fold (build1 (CONJ_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n+      else if (TREE_CODE (arg0) == CONJ_EXPR)\n+\treturn TREE_OPERAND (arg0, 0);\n+      return t;\n+\n+    case BIT_NOT_EXPR:\n+      if (TREE_CODE (arg0) == INTEGER_CST)\n+        return fold_not_const (arg0, type);\n+      else if (TREE_CODE (arg0) == BIT_NOT_EXPR)\n+\treturn TREE_OPERAND (arg0, 0);\n+      /* Convert ~ (-A) to A - 1.  */\n+      else if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == NEGATE_EXPR)\n+\treturn fold (build2 (MINUS_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t     build_int_cst (type, 1)));\n+      /* Convert ~ (A - 1) or ~ (A + -1) to -A.  */\n+      else if (INTEGRAL_TYPE_P (type)\n+\t       && ((TREE_CODE (arg0) == MINUS_EXPR\n+\t\t    && integer_onep (TREE_OPERAND (arg0, 1)))\n+\t\t   || (TREE_CODE (arg0) == PLUS_EXPR\n+\t\t       && integer_all_onesp (TREE_OPERAND (arg0, 1)))))\n+\treturn fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0)));\n+      return t;\n+\n+    case TRUTH_NOT_EXPR:\n+      /* The argument to invert_truthvalue must have Boolean type.  */\n+      if (TREE_CODE (TREE_TYPE (arg0)) != BOOLEAN_TYPE)\n+          arg0 = fold_convert (boolean_type_node, arg0);\n+\n+      /* Note that the operand of this must be an int\n+\t and its values must be 0 or 1.\n+\t (\"true\" is a fixed value perhaps depending on the language,\n+\t but we don't handle values other than 1 correctly yet.)  */\n+      tem = invert_truthvalue (arg0);\n+      /* Avoid infinite recursion.  */\n+      if (TREE_CODE (tem) == TRUTH_NOT_EXPR)\n+\treturn t;\n+      return fold_convert (type, tem);\n+\n+    case REALPART_EXPR:\n+      if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n+\treturn t;\n+      else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n+\treturn omit_one_operand (type, TREE_OPERAND (arg0, 0),\n+\t\t\t\t TREE_OPERAND (arg0, 1));\n+      else if (TREE_CODE (arg0) == COMPLEX_CST)\n+\treturn TREE_REALPART (arg0);\n+      else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n+\treturn fold (build2 (TREE_CODE (arg0), type,\n+\t\t\t     fold (build1 (REALPART_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n+\t\t\t     fold (build1 (REALPART_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n+      return t;\n+\n+    case IMAGPART_EXPR:\n+      if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n+\treturn fold_convert (type, integer_zero_node);\n+      else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n+\treturn omit_one_operand (type, TREE_OPERAND (arg0, 1),\n+\t\t\t\t TREE_OPERAND (arg0, 0));\n+      else if (TREE_CODE (arg0) == COMPLEX_CST)\n+\treturn TREE_IMAGPART (arg0);\n+      else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n+\treturn fold (build2 (TREE_CODE (arg0), type,\n+\t\t\t     fold (build1 (IMAGPART_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n+\t\t\t     fold (build1 (IMAGPART_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n+      return t;\n+\n+    default:\n+      return t;\n+    } /* switch (code) */\n+}\n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -6628,6 +7052,17 @@ fold (tree expr)\n   if (kind == tcc_constant)\n     return t;\n \n+  if (IS_EXPR_CODE_CLASS (kind))\n+    {\n+      switch (TREE_CODE_LENGTH (code))\n+\t{\n+\tcase 1:\n+\t  return fold_unary (expr);\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n   if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n     {\n       tree subop;"}]}