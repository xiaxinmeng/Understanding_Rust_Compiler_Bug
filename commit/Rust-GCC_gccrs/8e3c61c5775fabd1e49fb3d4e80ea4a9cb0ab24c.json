{"sha": "8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUzYzYxYzU3NzVmYWJkMWU0OWZiM2Q0ZTgwZWE0YTljYjBhYjI0Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-09-14T12:21:44Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-09-14T12:21:44Z"}, "message": "cgraph.h, [...]: Fix comment typos.\n\n\t* cgraph.h, cgraphunit.c, fold-const.c, lambda-mat.c,\n\tlambda.h, profile.c, tree-optimize.c, tree-sra.c, vec.h: Fix\n\tcomment typos.  Follow spelling conventions.\n\nFrom-SVN: r87490", "tree": {"sha": "87f623cf4d9d9f6974f9edb301690b2d3b490943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87f623cf4d9d9f6974f9edb301690b2d3b490943"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/comments", "author": null, "committer": null, "parents": [{"sha": "0e40b5f29a85e04a5243db74bfc63e3935361645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e40b5f29a85e04a5243db74bfc63e3935361645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e40b5f29a85e04a5243db74bfc63e3935361645"}], "stats": {"total": 40, "additions": 23, "deletions": 17}, "files": [{"sha": "e604a68e3176ea66281448c9f0bed734390071ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -1,3 +1,9 @@\n+2004-09-14  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cgraph.h, cgraphunit.c, fold-const.c, lambda-mat.c,\n+\tlambda.h, profile.c, tree-optimize.c, tree-sra.c, vec.h: Fix\n+\tcomment typos.  Follow spelling conventions.\n+\n 2004-09-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/darwin-c.c, config/alpha/alpha.c, config/i386/i386.c,"}, {"sha": "ca355fec94b69eca46c14f30e0b81c6243a4235d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -96,7 +96,7 @@ struct cgraph_rtl_info GTY(())\n    rest of the compilation continues.  When this reorgination is done,\n    it will no longer be necessary to have the _decl_uid versions of\n    local_static_vars_info and global_static_vars_info structures.\n-   Having both structures is now requirred because the _ann_uid values\n+   Having both structures is now required because the _ann_uid values\n    for static variables are reset as each function is compiled.\n    Currently, the analysis is done using the _decl_uid versions and\n    converted to the _var_ann versions on demand."}, {"sha": "e04de96fde2388c557b763befc7867edb770d862", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -166,7 +166,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n \n /* Additionally this file gathers information about how local statics\n-   are used.  This is done in cgraph_charactize_statics.  After the\n+   are used.  This is done in cgraph_characterize_statics.  After the\n    call graph has been built, each function is analyzed to determine\n    which local static variables are either read or written or have\n    their address taken.  Any local static that has its address taken\n@@ -2024,7 +2024,7 @@ bool has_proper_scope_for_analysis (tree t)\n }\n \n /* Check to see if T is a read or address of operation on a static var\n-   we are interrested in analyzing.  FN is passed in to get access to\n+   we are interested in analyzing.  FN is passed in to get access to\n    its bit vectors.  */\n \n static void\n@@ -2058,7 +2058,7 @@ check_rhs_var (struct cgraph_node *fn, tree t)\n     }\n }\n \n-/* Check to see if T is an assignement to a static var we are\n+/* Check to see if T is an assignment to a static var we are\n    interrested in analyzing.  FN is passed in to get access to its bit\n    vectors.\n */\n@@ -2325,7 +2325,7 @@ clear_static_vars_maps (int index)\n /* FIXME -- PROFILE-RESTRUCTURE: Change all *_decl_uid to *_ann_uid.  */\n \n /* Or in all of the bits from every callee into X, the caller's, bit\n-   vector.  There are several cases to check to avoid the sparce\n+   vector.  There are several cases to check to avoid the sparse\n    bitmap oring.  */\n static void\n cgraph_propagate_bits (struct cgraph_node *x)"}, {"sha": "0dd0248f593f7206033de3bbcca70682fc9aee74", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -191,11 +191,11 @@ decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n    indicates whether constant overflow has already occurred.  We force\n    T's value to be within range of T's type (by setting to 0 or 1 all\n    the bits outside the type's range).  We set TREE_OVERFLOWED if,\n-  \tOVERFLOWED is non-zero,\n+  \tOVERFLOWED is nonzero,\n \tor OVERFLOWABLE is >0 and signed overflow occurs\n \tor OVERFLOWABLE is <0 and any overflow occurs\n    We set TREE_CONSTANT_OVERFLOWED if,\n-        CONST_OVERFLOWED is non-zero\n+        CONST_OVERFLOWED is nonzero\n \tor we set TREE_OVERFLOWED.\n   We return either the original T, or a copy.  */\n "}, {"sha": "16fd65eb4d7628a957c5403dfea89a4a1e6aa166", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -441,7 +441,7 @@ lambda_matrix_hermite (lambda_matrix mat, int n,\n \t    }\n \t}\n \n-      /* Stop when only the diagonal element is non-zero.  */\n+      /* Stop when only the diagonal element is nonzero.  */\n       while (lambda_vector_first_nz (row, n, j + 1) < n)\n \t{\n \t  minimum_col = lambda_vector_min_nz (row, n, j);\n@@ -548,7 +548,7 @@ lambda_matrix_left_hermite (lambda_matrix A, int m, int n,\n     }\n }\n \n-/* When it exists, return the first non-zero row in MAT after row\n+/* When it exists, return the first nonzero row in MAT after row\n    STARTROW.  Otherwise return rowsize.  */\n \n int"}, {"sha": "36a9664e8c9c1e44f9d253bacaed6420656f5954", "filename": "gcc/lambda.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -282,7 +282,7 @@ lambda_vector_equal (lambda_vector vec1, lambda_vector vec2, int size)\n   return true;\n }\n \n-/* Return the minimum non-zero element in vector VEC1 between START and N.\n+/* Return the minimum nonzero element in vector VEC1 between START and N.\n    We must have START <= N.  */\n \n static inline int"}, {"sha": "e56f30ea9f78df51a86488f51c2b64d2d45a36d2", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -686,7 +686,7 @@ compute_value_histograms (histogram_values values)\n \n #define BB_TO_GCOV_INDEX(bb)  ((bb)->index + 1)\n /* When passed NULL as file_name, initialize.\n-   When passed something else, output the neccesary commands to change\n+   When passed something else, output the necessary commands to change\n    line to LINE and offset to FILE_NAME.  */\n static void\n output_location (char const *file_name, int line,\n@@ -1029,7 +1029,7 @@ branch_prob (void)\n \t\t\t\t     &offset, bb);\n \t\t}\n \n-\t      /* Notice GOTO expressions we elliminated while constructing the\n+\t      /* Notice GOTO expressions we eliminated while constructing the\n \t         CFG.  */\n \t      if (bb->succ && !bb->succ->succ_next && bb->succ->goto_locus)\n \t        {"}, {"sha": "b9a2fa55ecea985bed0634977ac3e42b4174e888", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -285,7 +285,7 @@ static struct tree_opt_pass **\n next_pass_1 (struct tree_opt_pass **list, struct tree_opt_pass *pass)\n {\n \n-  /* A non-zero static_pass_number indicates that the\n+  /* A nonzero static_pass_number indicates that the\n      pass is already in the list.  */\n   if (pass->static_pass_number)\n     {"}, {"sha": "4ebc061232776ee11491c41de727408de18dcba2", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -182,7 +182,7 @@ type_can_be_decomposed_p (tree type)\n   if (bitmap_bit_p (sra_type_decomp_cache, cache+1))\n     return false;\n \n-  /* The type must have a definite non-zero size.  */\n+  /* The type must have a definite nonzero size.  */\n   if (TYPE_SIZE (type) == NULL || integer_zerop (TYPE_SIZE (type)))\n     goto fail;\n "}, {"sha": "43b7eabd9ad26fda23e6d8085e3d72a264403f89", "filename": "gcc/vec.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=8e3c61c5775fabd1e49fb3d4e80ea4a9cb0ab24c", "patch": "@@ -186,11 +186,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    \n    int VEC_T_space (VEC(T) *v,int reserve)\n \n-   If V has space for RESERVE additional entries, return non-zero.  If\n+   If V has space for RESERVE additional entries, return nonzero.  If\n    RESERVE is < 0, ensure there is at least one space slot.  You\n    usually only need to use this if you are doing your own vector\n    reallocation, for instance on an embedded vector.  This returns\n-   non-zero in exactly the same circumstances that VEC_T_reserve\n+   nonzero in exactly the same circumstances that VEC_T_reserve\n    will.  */\n \n #define VEC_space(TDEF,V,R)\t(VEC_OP(TDEF,space)(V,R))\n@@ -203,7 +203,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    slot.  These differ in their reallocation behaviour, the first will\n    not create additional headroom, but the second mechanism will\n    perform the usual exponential headroom increase.  Note this can\n-   cause V to be reallocated.  Returns non-zero iff reallocation\n+   cause V to be reallocated.  Returns nonzero iff reallocation\n    actually occurred.  */\n \n #define VEC_reserve(TDEF,V,R)\t(VEC_OP(TDEF,reserve)(&(V),R MEM_STAT_INFO))"}]}