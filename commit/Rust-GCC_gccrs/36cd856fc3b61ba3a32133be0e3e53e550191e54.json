{"sha": "36cd856fc3b61ba3a32133be0e3e53e550191e54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZjZDg1NmZjM2I2MWJhM2EzMjEzM2JlMGUzZTUzZTU1MDE5MWU1NA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-10-26T16:51:53Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-10-26T16:51:53Z"}, "message": "Introduce class rtx_writer\n\ngcc/ChangeLog:\n\t* print-rtl-function.c (print_rtx_function): Rewrite in terms of\n\tclass rtx_writer.\n\t* print-rtl.c (outfile): Delete global.\n\t(sawclose): Likewise.\n\t(indent): Likewise.\n\t(in_call_function_usage): Likewise.\n\t(flag_compact): Likewise.\n\t(flag_simple): Likewise.\n\t(rtx_writer::rtx_writer): New ctor.\n\t(print_rtx_operand_code_0): Convert to...\n\t(rtx_writer::print_rtx_operand_code_0): ...this.\n\t(print_rtx_operand_code_e): Convert to...\n\t(rtx_writer::print_rtx_operand_code_e): ...this.\n\t(print_rtx_operand_codes_E_and_V): Convert to...\n\t(rtx_writer::print_rtx_operand_codes_E_and_V): ...this.\n\t(print_rtx_operand_code_i): Convert to...\n\t(rtx_writer::print_rtx_operand_code_i): ...this.\n\t(print_rtx_operand_code_r): Convert to...\n\t(rtx_writer::print_rtx_operand_code_r): ...this.\n\t(print_rtx_operand_code_u): Convert to...\n\t(rtx_writer::print_rtx_operand_code_u): ...this.\n\t(print_rtx_operand): Convert to...\n\t(rtx_writer::print_rtx_operand): ...this.\n\t(print_rtx): Convert to...\n\t(rtx_writer::print_rtx): ...this.\n\t(print_inline_rtx): Rewrite in terms of class rtx_writer.\n\t(debug_rtx): Likewise.\n\t(print_rtl): Convert to...\n\t(rtx_writer::print_rtl): ...this.\n\t(print_rtl): Reimplement in terms of class rtx_writer.\n\t(print_rtl_single): Rewrite in terms of class rtx_writer.\n\t(print_rtl_single_with_indent): Convert to..\n\t(rtx_writer::print_rtl_single_with_indent): ...this.\n\t(print_simple_rtl): Rewrite in terms of class rtx_writer.\n\t* print-rtl.h (flag_compact): Delete decl.\n\t(class rtx_writer): New class.\n\t* rtl-tests.c (selftest::assert_rtl_dump_eq): Rewrite in terms of\n\tclass rtx_writer.\n\nFrom-SVN: r241586", "tree": {"sha": "0586bc9cd9225510a43cb652d3705d953a3cf226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0586bc9cd9225510a43cb652d3705d953a3cf226"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36cd856fc3b61ba3a32133be0e3e53e550191e54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36cd856fc3b61ba3a32133be0e3e53e550191e54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36cd856fc3b61ba3a32133be0e3e53e550191e54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36cd856fc3b61ba3a32133be0e3e53e550191e54/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3bbe0b82a1adb4b8ebaeb64d501baec386c0463e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbe0b82a1adb4b8ebaeb64d501baec386c0463e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bbe0b82a1adb4b8ebaeb64d501baec386c0463e"}], "stats": {"total": 552, "additions": 308, "deletions": 244}, "files": [{"sha": "106a3a380da74d0132e74fdc9138c42a867fcddc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36cd856fc3b61ba3a32133be0e3e53e550191e54", "patch": "@@ -1,3 +1,44 @@\n+2016-10-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* print-rtl-function.c (print_rtx_function): Rewrite in terms of\n+\tclass rtx_writer.\n+\t* print-rtl.c (outfile): Delete global.\n+\t(sawclose): Likewise.\n+\t(indent): Likewise.\n+\t(in_call_function_usage): Likewise.\n+\t(flag_compact): Likewise.\n+\t(flag_simple): Likewise.\n+\t(rtx_writer::rtx_writer): New ctor.\n+\t(print_rtx_operand_code_0): Convert to...\n+\t(rtx_writer::print_rtx_operand_code_0): ...this.\n+\t(print_rtx_operand_code_e): Convert to...\n+\t(rtx_writer::print_rtx_operand_code_e): ...this.\n+\t(print_rtx_operand_codes_E_and_V): Convert to...\n+\t(rtx_writer::print_rtx_operand_codes_E_and_V): ...this.\n+\t(print_rtx_operand_code_i): Convert to...\n+\t(rtx_writer::print_rtx_operand_code_i): ...this.\n+\t(print_rtx_operand_code_r): Convert to...\n+\t(rtx_writer::print_rtx_operand_code_r): ...this.\n+\t(print_rtx_operand_code_u): Convert to...\n+\t(rtx_writer::print_rtx_operand_code_u): ...this.\n+\t(print_rtx_operand): Convert to...\n+\t(rtx_writer::print_rtx_operand): ...this.\n+\t(print_rtx): Convert to...\n+\t(rtx_writer::print_rtx): ...this.\n+\t(print_inline_rtx): Rewrite in terms of class rtx_writer.\n+\t(debug_rtx): Likewise.\n+\t(print_rtl): Convert to...\n+\t(rtx_writer::print_rtl): ...this.\n+\t(print_rtl): Reimplement in terms of class rtx_writer.\n+\t(print_rtl_single): Rewrite in terms of class rtx_writer.\n+\t(print_rtl_single_with_indent): Convert to..\n+\t(rtx_writer::print_rtl_single_with_indent): ...this.\n+\t(print_simple_rtl): Rewrite in terms of class rtx_writer.\n+\t* print-rtl.h (flag_compact): Delete decl.\n+\t(class rtx_writer): New class.\n+\t* rtl-tests.c (selftest::assert_rtl_dump_eq): Rewrite in terms of\n+\tclass rtx_writer.\n+\n 2016-10-26  Jeff Law  <law@redhat.com>\n \n \t* config/arc/arc.c (acr_print_operand): Adjust fallthru comment."}, {"sha": "f37e1b7dbc50e8eec8f76203208f44d36b84be97", "filename": "gcc/print-rtl-function.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2Fprint-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2Fprint-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl-function.c?ref=36cd856fc3b61ba3a32133be0e3e53e550191e54", "patch": "@@ -189,7 +189,7 @@ can_have_basic_block_p (const rtx_insn *insn)\n DEBUG_FUNCTION void\n print_rtx_function (FILE *outfile, function *fn, bool compact)\n {\n-  flag_compact = compact;\n+  rtx_writer w (outfile, 0, false, compact);\n \n   tree fdecl = fn->decl;\n \n@@ -213,19 +213,17 @@ print_rtx_function (FILE *outfile, function *fn, bool compact)\n \t  curr_bb = insn_bb;\n \t  begin_any_block (outfile, curr_bb);\n \t}\n-      print_rtl_single_with_indent (outfile, insn, curr_bb ? 6 : 4);\n+      w.print_rtl_single_with_indent (insn, curr_bb ? 6 : 4);\n     }\n   end_any_block (outfile, curr_bb);\n   fprintf (outfile, \"  ) ;; insn-chain\\n\");\n \n   /* Additional RTL state.  */\n   fprintf (outfile, \"  (crtl\\n\");\n   fprintf (outfile, \"    (return_rtx \\n\");\n-  print_rtl_single_with_indent (outfile, crtl->return_rtx, 6);\n+  w.print_rtl_single_with_indent (crtl->return_rtx, 6);\n   fprintf (outfile, \"    ) ;; return_rtx\\n\");\n   fprintf (outfile, \"  ) ;; crtl\\n\");\n \n   fprintf (outfile, \") ;; function \\\"%s\\\"\\n\", dname);\n-\n-  flag_compact = false;\n }"}, {"sha": "d0ba896f3e2201a6a86e876b10cea725fc510b15", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 224, "deletions": 235, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=36cd856fc3b61ba3a32133be0e3e53e550191e54", "patch": "@@ -52,23 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"print-rtl.h\"\n \n-static FILE *outfile;\n-\n-static int sawclose = 0;\n-\n-static int indent;\n-\n-static bool in_call_function_usage;\n-\n-/* If true, use compact dump format:\n-   - INSN_UIDs are omitted, except for jumps and CODE_LABELs,\n-   - INSN_CODEs are omitted,\n-   - register numbers are omitted for hard and virtual regs\n-   - insn names are prefixed with \"c\" (e.g. \"cinsn\", \"cnote\", etc).  */\n-bool flag_compact;\n-\n-static void print_rtx (const_rtx);\n-\n /* String printed at beginning of each RTL when it is dumped.\n    This string is set to ASM_COMMENT_START when the RTL is dumped in\n    the assembly output file.  */\n@@ -89,8 +72,13 @@ int flag_dump_unnumbered = 0;\n int flag_dump_unnumbered_links = 0;\n #endif\n \n-/* Nonzero means use simplified format without flags, modes, etc.  */\n-int flag_simple = 0;\n+/* Constructor for rtx_writer.  */\n+\n+rtx_writer::rtx_writer (FILE *outf, int ind, bool simple, bool compact)\n+: m_outfile (outf), m_sawclose (0), m_indent (ind),\n+  m_in_call_function_usage (false), m_simple (simple), m_compact (compact)\n+{\n+}\n \n #ifndef GENERATOR_FILE\n void\n@@ -107,19 +95,19 @@ print_mem_expr (FILE *outfile, const_tree expr)\n    of a NOTE, where it indicates that the field has several different\n    valid contents.  */\n \n-static void\n-print_rtx_operand_code_0 (const_rtx in_rtx ATTRIBUTE_UNUSED,\n-\t\t\t  int idx ATTRIBUTE_UNUSED)\n+void\n+rtx_writer::print_rtx_operand_code_0 (const_rtx in_rtx ATTRIBUTE_UNUSED,\n+\t\t\t\t      int idx ATTRIBUTE_UNUSED)\n {\n #ifndef GENERATOR_FILE\n   if (idx == 1 && GET_CODE (in_rtx) == SYMBOL_REF)\n     {\n       int flags = SYMBOL_REF_FLAGS (in_rtx);\n       if (flags)\n-\tfprintf (outfile, \" [flags %#x]\", flags);\n+\tfprintf (m_outfile, \" [flags %#x]\", flags);\n       tree decl = SYMBOL_REF_DECL (in_rtx);\n       if (decl)\n-\tprint_node_brief (outfile, \"\", decl, dump_flags);\n+\tprint_node_brief (m_outfile, \"\", decl, dump_flags);\n     }\n   else if (idx == 3 && NOTE_P (in_rtx))\n     {\n@@ -128,23 +116,23 @@ print_rtx_operand_code_0 (const_rtx in_rtx ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_EH_REGION_BEG:\n \tcase NOTE_INSN_EH_REGION_END:\n \t  if (flag_dump_unnumbered)\n-\t    fprintf (outfile, \" #\");\n+\t    fprintf (m_outfile, \" #\");\n \t  else\n-\t    fprintf (outfile, \" %d\", NOTE_EH_HANDLER (in_rtx));\n-\t  sawclose = 1;\n+\t    fprintf (m_outfile, \" %d\", NOTE_EH_HANDLER (in_rtx));\n+\t  m_sawclose = 1;\n \t  break;\n \n \tcase NOTE_INSN_BLOCK_BEG:\n \tcase NOTE_INSN_BLOCK_END:\n-\t  dump_addr (outfile, \" \", NOTE_BLOCK (in_rtx));\n-\t  sawclose = 1;\n+\t  dump_addr (m_outfile, \" \", NOTE_BLOCK (in_rtx));\n+\t  m_sawclose = 1;\n \t  break;\n \n \tcase NOTE_INSN_BASIC_BLOCK:\n \t  {\n \t    basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n \t    if (bb != 0)\n-\t      fprintf (outfile, \" [bb %d]\", bb->index);\n+\t      fprintf (m_outfile, \" [bb %d]\", bb->index);\n \t    break;\n \t  }\n \n@@ -153,68 +141,68 @@ print_rtx_operand_code_0 (const_rtx in_rtx ATTRIBUTE_UNUSED,\n \t  {\n \t    const char *label = NOTE_DELETED_LABEL_NAME (in_rtx);\n \t    if (label)\n-\t      fprintf (outfile, \" (\\\"%s\\\")\", label);\n+\t      fprintf (m_outfile, \" (\\\"%s\\\")\", label);\n \t    else\n-\t      fprintf (outfile, \" \\\"\\\"\");\n+\t      fprintf (m_outfile, \" \\\"\\\"\");\n \t  }\n \t  break;\n \n \tcase NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t  {\n \t    basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n \t    if (bb != 0)\n-\t      fprintf (outfile, \" [bb %d]\", bb->index);\n+\t      fprintf (m_outfile, \" [bb %d]\", bb->index);\n \t    break;\n \t  }\n \n \tcase NOTE_INSN_VAR_LOCATION:\n \tcase NOTE_INSN_CALL_ARG_LOCATION:\n-\t  fputc (' ', outfile);\n+\t  fputc (' ', m_outfile);\n \t  print_rtx (NOTE_VAR_LOCATION (in_rtx));\n \t  break;\n \n \tcase NOTE_INSN_CFI:\n-\t  fputc ('\\n', outfile);\n-\t  output_cfi_directive (outfile, NOTE_CFI (in_rtx));\n-\t  fputc ('\\t', outfile);\n+\t  fputc ('\\n', m_outfile);\n+\t  output_cfi_directive (m_outfile, NOTE_CFI (in_rtx));\n+\t  fputc ('\\t', m_outfile);\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n     }\n   else if (idx == 7 && JUMP_P (in_rtx) && JUMP_LABEL (in_rtx) != NULL\n-\t   && !flag_compact)\n+\t   && !m_compact)\n     {\n       /* Output the JUMP_LABEL reference.  */\n-      fprintf (outfile, \"\\n%s%*s -> \", print_rtx_head, indent * 2, \"\");\n+      fprintf (m_outfile, \"\\n%s%*s -> \", print_rtx_head, m_indent * 2, \"\");\n       if (GET_CODE (JUMP_LABEL (in_rtx)) == RETURN)\n-\tfprintf (outfile, \"return\");\n+\tfprintf (m_outfile, \"return\");\n       else if (GET_CODE (JUMP_LABEL (in_rtx)) == SIMPLE_RETURN)\n-\tfprintf (outfile, \"simple_return\");\n+\tfprintf (m_outfile, \"simple_return\");\n       else\n-\tfprintf (outfile, \"%d\", INSN_UID (JUMP_LABEL (in_rtx)));\n+\tfprintf (m_outfile, \"%d\", INSN_UID (JUMP_LABEL (in_rtx)));\n     }\n   else if (idx == 0 && GET_CODE (in_rtx) == VALUE)\n     {\n       cselib_val *val = CSELIB_VAL_PTR (in_rtx);\n \n-      fprintf (outfile, \" %u:%u\", val->uid, val->hash);\n-      dump_addr (outfile, \" @\", in_rtx);\n-      dump_addr (outfile, \"/\", (void*)val);\n+      fprintf (m_outfile, \" %u:%u\", val->uid, val->hash);\n+      dump_addr (m_outfile, \" @\", in_rtx);\n+      dump_addr (m_outfile, \"/\", (void*)val);\n     }\n   else if (idx == 0 && GET_CODE (in_rtx) == DEBUG_EXPR)\n     {\n-      fprintf (outfile, \" D#%i\",\n+      fprintf (m_outfile, \" D#%i\",\n \t       DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (in_rtx)));\n     }\n   else if (idx == 0 && GET_CODE (in_rtx) == ENTRY_VALUE)\n     {\n-      indent += 2;\n-      if (!sawclose)\n-\tfprintf (outfile, \" \");\n+      m_indent += 2;\n+      if (!m_sawclose)\n+\tfprintf (m_outfile, \" \");\n       print_rtx (ENTRY_VALUE_EXP (in_rtx));\n-      indent -= 2;\n+      m_indent -= 2;\n     }\n #endif\n }\n@@ -223,63 +211,63 @@ print_rtx_operand_code_0 (const_rtx in_rtx ATTRIBUTE_UNUSED,\n    Also called by print_rtx_operand_code_u for handling code 'u'\n    for LABEL_REFs when they don't reference a CODE_LABEL.  */\n \n-static void\n-print_rtx_operand_code_e (const_rtx in_rtx, int idx)\n+void\n+rtx_writer::print_rtx_operand_code_e (const_rtx in_rtx, int idx)\n {\n-  indent += 2;\n+  m_indent += 2;\n   if (idx == 6 && INSN_P (in_rtx))\n     /* Put REG_NOTES on their own line.  */\n-    fprintf (outfile, \"\\n%s%*s\",\n-\t     print_rtx_head, indent * 2, \"\");\n-  if (!sawclose)\n-    fprintf (outfile, \" \");\n+    fprintf (m_outfile, \"\\n%s%*s\",\n+\t     print_rtx_head, m_indent * 2, \"\");\n+  if (!m_sawclose)\n+    fprintf (m_outfile, \" \");\n   if (idx == 7 && CALL_P (in_rtx))\n     {\n-      in_call_function_usage = true;\n+      m_in_call_function_usage = true;\n       print_rtx (XEXP (in_rtx, idx));\n-      in_call_function_usage = false;\n+      m_in_call_function_usage = false;\n     }\n   else\n     print_rtx (XEXP (in_rtx, idx));\n-  indent -= 2;\n+  m_indent -= 2;\n }\n \n /* Subroutine of print_rtx_operand for handling codes 'E' and 'V'.  */\n \n-static void\n-print_rtx_operand_codes_E_and_V (const_rtx in_rtx, int idx)\n+void\n+rtx_writer::print_rtx_operand_codes_E_and_V (const_rtx in_rtx, int idx)\n {\n-  indent += 2;\n-  if (sawclose)\n+  m_indent += 2;\n+  if (m_sawclose)\n     {\n-      fprintf (outfile, \"\\n%s%*s\",\n-      print_rtx_head, indent * 2, \"\");\n-      sawclose = 0;\n+      fprintf (m_outfile, \"\\n%s%*s\",\n+      print_rtx_head, m_indent * 2, \"\");\n+      m_sawclose = 0;\n     }\n-  fputs (\" [\", outfile);\n+  fputs (\" [\", m_outfile);\n   if (NULL != XVEC (in_rtx, idx))\n     {\n-      indent += 2;\n+      m_indent += 2;\n       if (XVECLEN (in_rtx, idx))\n-\tsawclose = 1;\n+\tm_sawclose = 1;\n \n       for (int j = 0; j < XVECLEN (in_rtx, idx); j++)\n \tprint_rtx (XVECEXP (in_rtx, idx, j));\n \n-      indent -= 2;\n+      m_indent -= 2;\n     }\n-  if (sawclose)\n-    fprintf (outfile, \"\\n%s%*s\", print_rtx_head, indent * 2, \"\");\n+  if (m_sawclose)\n+    fprintf (m_outfile, \"\\n%s%*s\", print_rtx_head, m_indent * 2, \"\");\n \n-  fputs (\"]\", outfile);\n-  sawclose = 1;\n-  indent -= 2;\n+  fputs (\"]\", m_outfile);\n+  m_sawclose = 1;\n+  m_indent -= 2;\n }\n \n /* Subroutine of print_rtx_operand for handling code 'i'.  */\n \n-static void\n-print_rtx_operand_code_i (const_rtx in_rtx, int idx)\n+void\n+rtx_writer::print_rtx_operand_code_i (const_rtx in_rtx, int idx)\n {\n   if (idx == 4 && INSN_P (in_rtx))\n     {\n@@ -292,15 +280,15 @@ print_rtx_operand_code_i (const_rtx in_rtx, int idx)\n       if (INSN_HAS_LOCATION (in_insn))\n \t{\n \t  expanded_location xloc = insn_location (in_insn);\n-\t  fprintf (outfile, \" \\\"%s\\\":%i\", xloc.file, xloc.line);\n+\t  fprintf (m_outfile, \" \\\"%s\\\":%i\", xloc.file, xloc.line);\n \t}\n #endif\n     }\n   else if (idx == 6 && GET_CODE (in_rtx) == ASM_OPERANDS)\n     {\n #ifndef GENERATOR_FILE\n       if (ASM_OPERANDS_SOURCE_LOCATION (in_rtx) != UNKNOWN_LOCATION)\n-\tfprintf (outfile, \" %s:%i\",\n+\tfprintf (m_outfile, \" %s:%i\",\n \t\t LOCATION_FILE (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)),\n \t\t LOCATION_LINE (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)));\n #endif\n@@ -309,7 +297,7 @@ print_rtx_operand_code_i (const_rtx in_rtx, int idx)\n     {\n #ifndef GENERATOR_FILE\n       if (ASM_INPUT_SOURCE_LOCATION (in_rtx) != UNKNOWN_LOCATION)\n-\tfprintf (outfile, \" %s:%i\",\n+\tfprintf (m_outfile, \" %s:%i\",\n \t\t LOCATION_FILE (ASM_INPUT_SOURCE_LOCATION (in_rtx)),\n \t\t LOCATION_LINE (ASM_INPUT_SOURCE_LOCATION (in_rtx)));\n #endif\n@@ -320,22 +308,22 @@ print_rtx_operand_code_i (const_rtx in_rtx, int idx)\n \t other times often contains garbage from INSN->NOTE death.  */\n       if (NOTE_KIND (in_rtx) == NOTE_INSN_DELETED_LABEL\n \t  || NOTE_KIND (in_rtx) == NOTE_INSN_DELETED_DEBUG_LABEL)\n-\tfprintf (outfile, \" %d\",  XINT (in_rtx, idx));\n+\tfprintf (m_outfile, \" %d\",  XINT (in_rtx, idx));\n     }\n #if !defined(GENERATOR_FILE) && NUM_UNSPECV_VALUES > 0\n   else if (idx == 1\n \t   && GET_CODE (in_rtx) == UNSPEC_VOLATILE\n \t   && XINT (in_rtx, 1) >= 0\n \t   && XINT (in_rtx, 1) < NUM_UNSPECV_VALUES)\n-    fprintf (outfile, \" %s\", unspecv_strings[XINT (in_rtx, 1)]);\n+    fprintf (m_outfile, \" %s\", unspecv_strings[XINT (in_rtx, 1)]);\n #endif\n #if !defined(GENERATOR_FILE) && NUM_UNSPEC_VALUES > 0\n   else if (idx == 1\n \t   && (GET_CODE (in_rtx) == UNSPEC\n \t       || GET_CODE (in_rtx) == UNSPEC_VOLATILE)\n \t   && XINT (in_rtx, 1) >= 0\n \t   && XINT (in_rtx, 1) < NUM_UNSPEC_VALUES)\n-    fprintf (outfile, \" %s\", unspec_strings[XINT (in_rtx, 1)]);\n+    fprintf (m_outfile, \" %s\", unspec_strings[XINT (in_rtx, 1)]);\n #endif\n   else\n     {\n@@ -344,99 +332,99 @@ print_rtx_operand_code_i (const_rtx in_rtx, int idx)\n       int is_insn = INSN_P (in_rtx);\n \n       /* Don't print INSN_CODEs in compact mode.  */\n-      if (flag_compact && is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, idx))\n+      if (m_compact && is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, idx))\n \t{\n-\t  sawclose = 0;\n+\t  m_sawclose = 0;\n \t  return;\n \t}\n \n       if (flag_dump_unnumbered\n \t  && (is_insn || NOTE_P (in_rtx)))\n-\tfputc ('#', outfile);\n+\tfputc ('#', m_outfile);\n       else\n-\tfprintf (outfile, \" %d\", value);\n+\tfprintf (m_outfile, \" %d\", value);\n \n       if (is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, idx)\n \t  && XINT (in_rtx, idx) >= 0\n \t  && (name = get_insn_name (XINT (in_rtx, idx))) != NULL)\n-\tfprintf (outfile, \" {%s}\", name);\n-      sawclose = 0;\n+\tfprintf (m_outfile, \" {%s}\", name);\n+      m_sawclose = 0;\n     }\n }\n \n /* Subroutine of print_rtx_operand for handling code 'r'.  */\n \n-static void\n-print_rtx_operand_code_r (const_rtx in_rtx)\n+void\n+rtx_writer::print_rtx_operand_code_r (const_rtx in_rtx)\n {\n   int is_insn = INSN_P (in_rtx);\n   unsigned int regno = REGNO (in_rtx);\n \n #ifndef GENERATOR_FILE\n   /* For hard registers and virtuals, always print the\n      regno, except in compact mode.  */\n-  if (regno <= LAST_VIRTUAL_REGISTER && !flag_compact)\n-    fprintf (outfile, \" %d\", regno);\n+  if (regno <= LAST_VIRTUAL_REGISTER && !m_compact)\n+    fprintf (m_outfile, \" %d\", regno);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    fprintf (outfile, \" %s\", reg_names[regno]);\n+    fprintf (m_outfile, \" %s\", reg_names[regno]);\n   else if (regno <= LAST_VIRTUAL_REGISTER)\n     {\n       if (regno == VIRTUAL_INCOMING_ARGS_REGNUM)\n-\tfprintf (outfile, \" virtual-incoming-args\");\n+\tfprintf (m_outfile, \" virtual-incoming-args\");\n       else if (regno == VIRTUAL_STACK_VARS_REGNUM)\n-\tfprintf (outfile, \" virtual-stack-vars\");\n+\tfprintf (m_outfile, \" virtual-stack-vars\");\n       else if (regno == VIRTUAL_STACK_DYNAMIC_REGNUM)\n-\tfprintf (outfile, \" virtual-stack-dynamic\");\n+\tfprintf (m_outfile, \" virtual-stack-dynamic\");\n       else if (regno == VIRTUAL_OUTGOING_ARGS_REGNUM)\n-\tfprintf (outfile, \" virtual-outgoing-args\");\n+\tfprintf (m_outfile, \" virtual-outgoing-args\");\n       else if (regno == VIRTUAL_CFA_REGNUM)\n-\tfprintf (outfile, \" virtual-cfa\");\n+\tfprintf (m_outfile, \" virtual-cfa\");\n       else if (regno == VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM)\n-\tfprintf (outfile, \" virtual-preferred-stack-boundary\");\n+\tfprintf (m_outfile, \" virtual-preferred-stack-boundary\");\n       else\n-\tfprintf (outfile, \" virtual-reg-%d\", regno-FIRST_VIRTUAL_REGISTER);\n+\tfprintf (m_outfile, \" virtual-reg-%d\", regno-FIRST_VIRTUAL_REGISTER);\n     }\n   else\n #endif\n     if (flag_dump_unnumbered && is_insn)\n-      fputc ('#', outfile);\n-    else if (flag_compact)\n+      fputc ('#', m_outfile);\n+    else if (m_compact)\n       {\n \t/* In compact mode, print pseudos with a '%' sigil following\n \t   by the regno, offset by (LAST_VIRTUAL_REGISTER + 1), so that the\n \t   first non-virtual pseudo is dumped as \"%0\".  */\n \tgcc_assert (regno > LAST_VIRTUAL_REGISTER);\n-\tfprintf (outfile, \" %%%d\", regno - (LAST_VIRTUAL_REGISTER + 1));\n+\tfprintf (m_outfile, \" %%%d\", regno - (LAST_VIRTUAL_REGISTER + 1));\n       }\n     else\n-      fprintf (outfile, \" %d\", regno);\n+      fprintf (m_outfile, \" %d\", regno);\n \n #ifndef GENERATOR_FILE\n   if (REG_ATTRS (in_rtx))\n     {\n-      fputs (\" [\", outfile);\n+      fputs (\" [\", m_outfile);\n       if (regno != ORIGINAL_REGNO (in_rtx))\n-\tfprintf (outfile, \"orig:%i\", ORIGINAL_REGNO (in_rtx));\n+\tfprintf (m_outfile, \"orig:%i\", ORIGINAL_REGNO (in_rtx));\n       if (REG_EXPR (in_rtx))\n-\tprint_mem_expr (outfile, REG_EXPR (in_rtx));\n+\tprint_mem_expr (m_outfile, REG_EXPR (in_rtx));\n \n       if (REG_OFFSET (in_rtx))\n-\tfprintf (outfile, \"+\" HOST_WIDE_INT_PRINT_DEC,\n+\tfprintf (m_outfile, \"+\" HOST_WIDE_INT_PRINT_DEC,\n \t\t REG_OFFSET (in_rtx));\n-      fputs (\" ]\", outfile);\n+      fputs (\" ]\", m_outfile);\n     }\n   if (regno != ORIGINAL_REGNO (in_rtx))\n-    fprintf (outfile, \" [%d]\", ORIGINAL_REGNO (in_rtx));\n+    fprintf (m_outfile, \" [%d]\", ORIGINAL_REGNO (in_rtx));\n #endif\n }\n \n /* Subroutine of print_rtx_operand for handling code 'u'.  */\n \n-static void\n-print_rtx_operand_code_u (const_rtx in_rtx, int idx)\n+void\n+rtx_writer::print_rtx_operand_code_u (const_rtx in_rtx, int idx)\n {\n   /* Don't print insn UIDs in compact mode, apart from in LABEL_REFs.  */\n-  if (flag_compact && GET_CODE (in_rtx) != LABEL_REF)\n+  if (m_compact && GET_CODE (in_rtx) != LABEL_REF)\n     return;\n \n   if (XEXP (in_rtx, idx) != NULL)\n@@ -450,10 +438,10 @@ print_rtx_operand_code_u (const_rtx in_rtx, int idx)\n \t      && NOTE_KIND (sub) == NOTE_INSN_DELETED_LABEL)\n \t    {\n \t      if (flag_dump_unnumbered)\n-\t\tfprintf (outfile, \" [# deleted]\");\n+\t\tfprintf (m_outfile, \" [# deleted]\");\n \t      else\n-\t\tfprintf (outfile, \" [%d deleted]\", INSN_UID (sub));\n-\t      sawclose = 0;\n+\t\tfprintf (m_outfile, \" [%d deleted]\", INSN_UID (sub));\n+\t      m_sawclose = 0;\n \t      return;\n \t    }\n \n@@ -468,19 +456,19 @@ print_rtx_operand_code_u (const_rtx in_rtx, int idx)\n \t  || (flag_dump_unnumbered_links && idx <= 1\n \t      && (INSN_P (in_rtx) || NOTE_P (in_rtx)\n \t\t  || LABEL_P (in_rtx) || BARRIER_P (in_rtx))))\n-\tfputs (\" #\", outfile);\n+\tfputs (\" #\", m_outfile);\n       else\n-\tfprintf (outfile, \" %d\", INSN_UID (sub));\n+\tfprintf (m_outfile, \" %d\", INSN_UID (sub));\n     }\n   else\n-    fputs (\" 0\", outfile);\n-  sawclose = 0;\n+    fputs (\" 0\", m_outfile);\n+  m_sawclose = 0;\n }\n \n /* Subroutine of print_rtx.   Print operand IDX of IN_RTX.  */\n \n-static void\n-print_rtx_operand (const_rtx in_rtx, int idx)\n+void\n+rtx_writer::print_rtx_operand (const_rtx in_rtx, int idx)\n {\n   const char *format_ptr = GET_RTX_FORMAT (GET_CODE (in_rtx));\n \n@@ -498,10 +486,10 @@ print_rtx_operand (const_rtx in_rtx, int idx)\n     string:\n \n       if (str == 0)\n-\tfputs (\" \\\"\\\"\", outfile);\n+\tfputs (\" \\\"\\\"\", m_outfile);\n       else\n-\tfprintf (outfile, \" (\\\"%s\\\")\", str);\n-      sawclose = 1;\n+\tfprintf (m_outfile, \" (\\\"%s\\\")\", str);\n+      m_sawclose = 1;\n       break;\n \n     case '0':\n@@ -518,11 +506,11 @@ print_rtx_operand (const_rtx in_rtx, int idx)\n       break;\n \n     case 'w':\n-      if (! flag_simple)\n-\tfprintf (outfile, \" \");\n-      fprintf (outfile, HOST_WIDE_INT_PRINT_DEC, XWINT (in_rtx, idx));\n-      if (! flag_simple && !flag_compact)\n-\tfprintf (outfile, \" [\" HOST_WIDE_INT_PRINT_HEX \"]\",\n+      if (! m_simple)\n+\tfprintf (m_outfile, \" \");\n+      fprintf (m_outfile, HOST_WIDE_INT_PRINT_DEC, XWINT (in_rtx, idx));\n+      if (! m_simple && !m_compact)\n+\tfprintf (m_outfile, \" [\" HOST_WIDE_INT_PRINT_HEX \"]\",\n \t\t (unsigned HOST_WIDE_INT) XWINT (in_rtx, idx));\n       break;\n \n@@ -537,8 +525,8 @@ print_rtx_operand (const_rtx in_rtx, int idx)\n     /* Print NOTE_INSN names rather than integer codes.  */\n \n     case 'n':\n-      fprintf (outfile, \" %s\", GET_NOTE_INSN_NAME (XINT (in_rtx, idx)));\n-      sawclose = 0;\n+      fprintf (m_outfile, \" %s\", GET_NOTE_INSN_NAME (XINT (in_rtx, idx)));\n+      m_sawclose = 0;\n       break;\n \n     case 'u':\n@@ -548,26 +536,26 @@ print_rtx_operand (const_rtx in_rtx, int idx)\n     case 't':\n #ifndef GENERATOR_FILE\n       if (idx == 0 && GET_CODE (in_rtx) == DEBUG_IMPLICIT_PTR)\n-\tprint_mem_expr (outfile, DEBUG_IMPLICIT_PTR_DECL (in_rtx));\n+\tprint_mem_expr (m_outfile, DEBUG_IMPLICIT_PTR_DECL (in_rtx));\n       else if (idx == 0 && GET_CODE (in_rtx) == DEBUG_PARAMETER_REF)\n-\tprint_mem_expr (outfile, DEBUG_PARAMETER_REF_DECL (in_rtx));\n+\tprint_mem_expr (m_outfile, DEBUG_PARAMETER_REF_DECL (in_rtx));\n       else\n-\tdump_addr (outfile, \" \", XTREE (in_rtx, idx));\n+\tdump_addr (m_outfile, \" \", XTREE (in_rtx, idx));\n #endif\n       break;\n \n     case '*':\n-      fputs (\" Unknown\", outfile);\n-      sawclose = 0;\n+      fputs (\" Unknown\", m_outfile);\n+      m_sawclose = 0;\n       break;\n \n     case 'B':\n       /* Don't print basic block ids in compact mode.  */\n-      if (flag_compact)\n+      if (m_compact)\n \tbreak;\n #ifndef GENERATOR_FILE\n       if (XBBDEF (in_rtx, idx))\n-\tfprintf (outfile, \" %i\", XBBDEF (in_rtx, idx)->index);\n+\tfprintf (m_outfile, \" %i\", XBBDEF (in_rtx, idx)->index);\n #endif\n       break;\n \n@@ -576,104 +564,104 @@ print_rtx_operand (const_rtx in_rtx, int idx)\n     }\n }\n \n-/* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */\n+/* Print IN_RTX onto m_outfile.  This is the recursive part of printing.  */\n \n-static void\n-print_rtx (const_rtx in_rtx)\n+void\n+rtx_writer::print_rtx (const_rtx in_rtx)\n {\n   int idx = 0;\n \n-  if (sawclose)\n+  if (m_sawclose)\n     {\n-      if (flag_simple)\n-\tfputc (' ', outfile);\n+      if (m_simple)\n+\tfputc (' ', m_outfile);\n       else\n-\tfprintf (outfile, \"\\n%s%*s\", print_rtx_head, indent * 2, \"\");\n-      sawclose = 0;\n+\tfprintf (m_outfile, \"\\n%s%*s\", print_rtx_head, m_indent * 2, \"\");\n+      m_sawclose = 0;\n     }\n \n   if (in_rtx == 0)\n     {\n-      fputs (\"(nil)\", outfile);\n-      sawclose = 1;\n+      fputs (\"(nil)\", m_outfile);\n+      m_sawclose = 1;\n       return;\n     }\n   else if (GET_CODE (in_rtx) > NUM_RTX_CODE)\n     {\n-       fprintf (outfile, \"(??? bad code %d\\n%s%*s)\", GET_CODE (in_rtx),\n-\t\tprint_rtx_head, indent * 2, \"\");\n-       sawclose = 1;\n+       fprintf (m_outfile, \"(??? bad code %d\\n%s%*s)\", GET_CODE (in_rtx),\n+\t\tprint_rtx_head, m_indent * 2, \"\");\n+       m_sawclose = 1;\n        return;\n     }\n \n   /* Print name of expression code.  */\n \n   /* In compact mode, prefix the code of insns with \"c\",\n      giving \"cinsn\", \"cnote\" etc.  */\n-  if (flag_compact && is_a <const rtx_insn *, const struct rtx_def> (in_rtx))\n+  if (m_compact && is_a <const rtx_insn *, const struct rtx_def> (in_rtx))\n     {\n       /* \"ccode_label\" is slightly awkward, so special-case it as\n \t just \"clabel\".  */\n       rtx_code code = GET_CODE (in_rtx);\n       if (code == CODE_LABEL)\n-\tfprintf (outfile, \"(clabel\");\n+\tfprintf (m_outfile, \"(clabel\");\n       else\n-\tfprintf (outfile, \"(c%s\", GET_RTX_NAME (code));\n+\tfprintf (m_outfile, \"(c%s\", GET_RTX_NAME (code));\n     }\n-  else if (flag_simple && CONST_INT_P (in_rtx))\n-    fputc ('(', outfile);\n+  else if (m_simple && CONST_INT_P (in_rtx))\n+    fputc ('(', m_outfile);\n   else\n-    fprintf (outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n+    fprintf (m_outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n \n-  if (! flag_simple)\n+  if (! m_simple)\n     {\n       if (RTX_FLAG (in_rtx, in_struct))\n-\tfputs (\"/s\", outfile);\n+\tfputs (\"/s\", m_outfile);\n \n       if (RTX_FLAG (in_rtx, volatil))\n-\tfputs (\"/v\", outfile);\n+\tfputs (\"/v\", m_outfile);\n \n       if (RTX_FLAG (in_rtx, unchanging))\n-\tfputs (\"/u\", outfile);\n+\tfputs (\"/u\", m_outfile);\n \n       if (RTX_FLAG (in_rtx, frame_related))\n-\tfputs (\"/f\", outfile);\n+\tfputs (\"/f\", m_outfile);\n \n       if (RTX_FLAG (in_rtx, jump))\n-\tfputs (\"/j\", outfile);\n+\tfputs (\"/j\", m_outfile);\n \n       if (RTX_FLAG (in_rtx, call))\n-\tfputs (\"/c\", outfile);\n+\tfputs (\"/c\", m_outfile);\n \n       if (RTX_FLAG (in_rtx, return_val))\n-\tfputs (\"/i\", outfile);\n+\tfputs (\"/i\", m_outfile);\n \n       /* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */\n       if ((GET_CODE (in_rtx) == EXPR_LIST\n \t   || GET_CODE (in_rtx) == INSN_LIST\n \t   || GET_CODE (in_rtx) == INT_LIST)\n \t  && (int)GET_MODE (in_rtx) < REG_NOTE_MAX\n-\t  && !in_call_function_usage)\n-\tfprintf (outfile, \":%s\",\n+\t  && !m_in_call_function_usage)\n+\tfprintf (m_outfile, \":%s\",\n \t\t GET_REG_NOTE_NAME (GET_MODE (in_rtx)));\n \n       /* For other rtl, print the mode if it's not VOID.  */\n       else if (GET_MODE (in_rtx) != VOIDmode)\n-\tfprintf (outfile, \":%s\", GET_MODE_NAME (GET_MODE (in_rtx)));\n+\tfprintf (m_outfile, \":%s\", GET_MODE_NAME (GET_MODE (in_rtx)));\n \n #ifndef GENERATOR_FILE\n       if (GET_CODE (in_rtx) == VAR_LOCATION)\n \t{\n \t  if (TREE_CODE (PAT_VAR_LOCATION_DECL (in_rtx)) == STRING_CST)\n-\t    fputs (\" <debug string placeholder>\", outfile);\n+\t    fputs (\" <debug string placeholder>\", m_outfile);\n \t  else\n-\t    print_mem_expr (outfile, PAT_VAR_LOCATION_DECL (in_rtx));\n-\t  fputc (' ', outfile);\n+\t    print_mem_expr (m_outfile, PAT_VAR_LOCATION_DECL (in_rtx));\n+\t  fputc (' ', m_outfile);\n \t  print_rtx (PAT_VAR_LOCATION_LOC (in_rtx));\n \t  if (PAT_VAR_LOCATION_STATUS (in_rtx)\n \t      == VAR_INIT_STATUS_UNINITIALIZED)\n-\t    fprintf (outfile, \" [uninit]\");\n-\t  sawclose = 1;\n+\t    fprintf (m_outfile, \" [uninit]\");\n+\t  m_sawclose = 1;\n \t  idx = GET_RTX_LENGTH (VAR_LOCATION);\n \t}\n #endif\n@@ -687,12 +675,12 @@ print_rtx (const_rtx in_rtx)\n   /* For insns, print the INSN_UID.\n      In compact mode, we only print the INSN_UID of CODE_LABELs.  */\n   if (INSN_CHAIN_CODE_P (GET_CODE (in_rtx))\n-      && (!flag_compact || GET_CODE (in_rtx) == CODE_LABEL))\n+      && (!m_compact || GET_CODE (in_rtx) == CODE_LABEL))\n     {\n       if (flag_dump_unnumbered)\n-\tfprintf (outfile, \" #\");\n+\tfprintf (m_outfile, \" #\");\n       else\n-\tfprintf (outfile, \" %d\", INSN_UID (in_rtx));\n+\tfprintf (m_outfile, \" %d\", INSN_UID (in_rtx));\n     }\n \n   /* Get the format string and skip the first elements if we have handled\n@@ -705,29 +693,29 @@ print_rtx (const_rtx in_rtx)\n #ifndef GENERATOR_FILE\n     case MEM:\n       if (__builtin_expect (final_insns_dump_p, false))\n-\tfprintf (outfile, \" [\");\n+\tfprintf (m_outfile, \" [\");\n       else\n-\tfprintf (outfile, \" [\" HOST_WIDE_INT_PRINT_DEC,\n+\tfprintf (m_outfile, \" [\" HOST_WIDE_INT_PRINT_DEC,\n \t\t (HOST_WIDE_INT) MEM_ALIAS_SET (in_rtx));\n \n       if (MEM_EXPR (in_rtx))\n-\tprint_mem_expr (outfile, MEM_EXPR (in_rtx));\n+\tprint_mem_expr (m_outfile, MEM_EXPR (in_rtx));\n       else\n-\tfputc (' ', outfile);\n+\tfputc (' ', m_outfile);\n \n       if (MEM_OFFSET_KNOWN_P (in_rtx))\n-\tfprintf (outfile, \"+\" HOST_WIDE_INT_PRINT_DEC, MEM_OFFSET (in_rtx));\n+\tfprintf (m_outfile, \"+\" HOST_WIDE_INT_PRINT_DEC, MEM_OFFSET (in_rtx));\n \n       if (MEM_SIZE_KNOWN_P (in_rtx))\n-\tfprintf (outfile, \" S\" HOST_WIDE_INT_PRINT_DEC, MEM_SIZE (in_rtx));\n+\tfprintf (m_outfile, \" S\" HOST_WIDE_INT_PRINT_DEC, MEM_SIZE (in_rtx));\n \n       if (MEM_ALIGN (in_rtx) != 1)\n-\tfprintf (outfile, \" A%u\", MEM_ALIGN (in_rtx));\n+\tfprintf (m_outfile, \" A%u\", MEM_ALIGN (in_rtx));\n \n       if (!ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (in_rtx)))\n-\tfprintf (outfile, \" AS%u\", MEM_ADDR_SPACE (in_rtx));\n+\tfprintf (m_outfile, \" AS%u\", MEM_ADDR_SPACE (in_rtx));\n \n-      fputc (']', outfile);\n+      fputc (']', m_outfile);\n       break;\n \n     case CONST_DOUBLE:\n@@ -737,29 +725,29 @@ print_rtx (const_rtx in_rtx)\n \n \t  real_to_decimal (s, CONST_DOUBLE_REAL_VALUE (in_rtx),\n \t\t\t   sizeof (s), 0, 1);\n-\t  fprintf (outfile, \" %s\", s);\n+\t  fprintf (m_outfile, \" %s\", s);\n \n \t  real_to_hexadecimal (s, CONST_DOUBLE_REAL_VALUE (in_rtx),\n \t\t\t       sizeof (s), 0, 1);\n-\t  fprintf (outfile, \" [%s]\", s);\n+\t  fprintf (m_outfile, \" [%s]\", s);\n \t}\n       break;\n \n     case CONST_WIDE_INT:\n-      fprintf (outfile, \" \");\n-      cwi_output_hex (outfile, in_rtx);\n+      fprintf (m_outfile, \" \");\n+      cwi_output_hex (m_outfile, in_rtx);\n       break;\n #endif\n \n     case CODE_LABEL:\n-      if (!flag_compact)\n-\tfprintf (outfile, \" [%d uses]\", LABEL_NUSES (in_rtx));\n+      if (!m_compact)\n+\tfprintf (m_outfile, \" [%d uses]\", LABEL_NUSES (in_rtx));\n       switch (LABEL_KIND (in_rtx))\n \t{\n \t  case LABEL_NORMAL: break;\n-\t  case LABEL_STATIC_ENTRY: fputs (\" [entry]\", outfile); break;\n-\t  case LABEL_GLOBAL_ENTRY: fputs (\" [global entry]\", outfile); break;\n-\t  case LABEL_WEAK_ENTRY: fputs (\" [weak entry]\", outfile); break;\n+\t  case LABEL_STATIC_ENTRY: fputs (\" [entry]\", m_outfile); break;\n+\t  case LABEL_GLOBAL_ENTRY: fputs (\" [global entry]\", m_outfile); break;\n+\t  case LABEL_WEAK_ENTRY: fputs (\" [weak entry]\", m_outfile); break;\n \t  default: gcc_unreachable ();\n \t}\n       break;\n@@ -768,8 +756,8 @@ print_rtx (const_rtx in_rtx)\n       break;\n     }\n \n-  fputc (')', outfile);\n-  sawclose = 1;\n+  fputc (')', m_outfile);\n+  m_sawclose = 1;\n }\n \n /* Print an rtx on the current line of FILE.  Initially indent IND\n@@ -778,25 +766,17 @@ print_rtx (const_rtx in_rtx)\n void\n print_inline_rtx (FILE *outf, const_rtx x, int ind)\n {\n-  int oldsaw = sawclose;\n-  int oldindent = indent;\n-\n-  sawclose = 0;\n-  indent = ind;\n-  outfile = outf;\n-  print_rtx (x);\n-  sawclose = oldsaw;\n-  indent = oldindent;\n+  rtx_writer w (outf, ind, false, false);\n+  w.print_rtx (x);\n }\n \n /* Call this function from the debugger to see what X looks like.  */\n \n DEBUG_FUNCTION void\n debug_rtx (const_rtx x)\n {\n-  outfile = stderr;\n-  sawclose = 0;\n-  print_rtx (x);\n+  rtx_writer w (stderr, 0, false, false);\n+  w.print_rtx (x);\n   fprintf (stderr, \"\\n\");\n }\n \n@@ -892,23 +872,20 @@ debug_rtx_find (const rtx_insn *x, int uid)\n }\n \n /* External entry point for printing a chain of insns\n-   starting with RTX_FIRST onto file OUTF.\n+   starting with RTX_FIRST.\n    A blank line separates insns.\n \n    If RTX_FIRST is not an insn, then it alone is printed, with no newline.  */\n \n void\n-print_rtl (FILE *outf, const_rtx rtx_first)\n+rtx_writer::print_rtl (const_rtx rtx_first)\n {\n   const rtx_insn *tmp_rtx;\n \n-  outfile = outf;\n-  sawclose = 0;\n-\n   if (rtx_first == 0)\n     {\n-      fputs (print_rtx_head, outf);\n-      fputs (\"(nil)\\n\", outf);\n+      fputs (print_rtx_head, m_outfile);\n+      fputs (\"(nil)\\n\", m_outfile);\n     }\n   else\n     switch (GET_CODE (rtx_first))\n@@ -924,45 +901,58 @@ print_rtl (FILE *outf, const_rtx rtx_first)\n \t     tmp_rtx != 0;\n \t     tmp_rtx = NEXT_INSN (tmp_rtx))\n \t  {\n-\t    fputs (print_rtx_head, outfile);\n+\t    fputs (print_rtx_head, m_outfile);\n \t    print_rtx (tmp_rtx);\n-\t    fprintf (outfile, \"\\n\");\n+\t    fprintf (m_outfile, \"\\n\");\n \t  }\n \tbreak;\n \n       default:\n-\tfputs (print_rtx_head, outfile);\n+\tfputs (print_rtx_head, m_outfile);\n \tprint_rtx (rtx_first);\n       }\n }\n \n+/* External entry point for printing a chain of insns\n+   starting with RTX_FIRST onto file OUTF.\n+   A blank line separates insns.\n+\n+   If RTX_FIRST is not an insn, then it alone is printed, with no newline.  */\n+\n+void\n+print_rtl (FILE *outf, const_rtx rtx_first)\n+{\n+  rtx_writer w (outf, 0, false, false);\n+  w.print_rtl (rtx_first);\n+}\n+\n /* Like print_rtx, except specify a file.  */\n /* Return nonzero if we actually printed anything.  */\n \n int\n print_rtl_single (FILE *outf, const_rtx x)\n {\n-  return print_rtl_single_with_indent (outf, x, 0);\n+  rtx_writer w (outf, 0, false, false);\n+  return w.print_rtl_single_with_indent (x, 0);\n }\n \n-/* Like print_rtl_single, except specify a file and indentation.  */\n+/* Like print_rtl_single, except specify an indentation.  */\n \n int\n-print_rtl_single_with_indent (FILE *outf, const_rtx x, int ind)\n+rtx_writer::print_rtl_single_with_indent (const_rtx x, int ind)\n {\n-  int old_indent = indent;\n   char *s_indent = (char *) alloca ((size_t) ind + 1);\n   memset ((void *) s_indent, ' ', (size_t) ind);\n   s_indent[ind] = '\\0';\n+  fputs (s_indent, m_outfile);\n+  fputs (print_rtx_head, m_outfile);\n \n-  indent = ind;\n-  outfile = outf;\n-  sawclose = 0;\n-  fputs (s_indent, outfile);\n-  fputs (print_rtx_head, outfile);\n+  int old_indent = m_indent;\n+  m_indent = ind;\n+  m_sawclose = 0;\n   print_rtx (x);\n-  putc ('\\n', outf);\n-  indent = old_indent;\n+  putc ('\\n', m_outfile);\n+  m_indent = old_indent;\n   return 1;\n }\n \n@@ -973,9 +963,8 @@ print_rtl_single_with_indent (FILE *outf, const_rtx x, int ind)\n void\n print_simple_rtl (FILE *outf, const_rtx x)\n {\n-  flag_simple = 1;\n-  print_rtl (outf, x);\n-  flag_simple = 0;\n+  rtx_writer w (outf, 0, true, false);\n+  w.print_rtl (x);\n }\n \n /* Print the elements of VEC to FILE.  */"}, {"sha": "4ebfcf99b03333ec14779c43e244c254b95cf6df", "filename": "gcc/print-rtl.h", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2Fprint-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2Fprint-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.h?ref=36cd856fc3b61ba3a32133be0e3e53e550191e54", "patch": "@@ -20,7 +20,44 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_PRINT_RTL_H\n #define GCC_PRINT_RTL_H\n \n-extern bool flag_compact;\n+/* A class for writing rtx to a FILE *.  */\n+\n+class rtx_writer\n+{\n+ public:\n+  rtx_writer (FILE *outfile, int ind, bool simple, bool compact);\n+\n+  void print_rtx (const_rtx in_rtx);\n+  void print_rtl (const_rtx rtx_first);\n+  int print_rtl_single_with_indent (const_rtx x, int ind);\n+\n+ private:\n+  void print_rtx_operand_code_0 (const_rtx in_rtx, int idx);\n+  void print_rtx_operand_code_e (const_rtx in_rtx, int idx);\n+  void print_rtx_operand_codes_E_and_V (const_rtx in_rtx, int idx);\n+  void print_rtx_operand_code_i (const_rtx in_rtx, int idx);\n+  void print_rtx_operand_code_r (const_rtx in_rtx);\n+  void print_rtx_operand_code_u (const_rtx in_rtx, int idx);\n+  void print_rtx_operand (const_rtx in_rtx, int idx);\n+\n+ private:\n+  FILE *m_outfile;\n+  int m_sawclose;\n+  int m_indent;\n+  bool m_in_call_function_usage;\n+\n+  /* True means use simplified format without flags, modes, etc.  */\n+  bool m_simple;\n+\n+  /* If true, use compact dump format:\n+     - INSN_UIDs are omitted, except for jumps and CODE_LABELs,\n+     - INSN_CODEs are omitted,\n+     - register numbers are omitted for hard and virtual regs, and\n+       non-virtual pseudos are offset relative to the first such reg, and\n+       printed with a '%' sigil e.g. \"%0\" for (LAST_VIRTUAL_REGISTER + 1),\n+     - insn names are prefixed with \"c\" (e.g. \"cinsn\", \"cnote\", etc).  */\n+  bool m_compact;\n+};\n \n #ifdef BUFSIZ\n extern void print_rtl (FILE *, const_rtx);"}, {"sha": "43665ba6281fe83c1e4409233cbf50ae027aeb5d", "filename": "gcc/rtl-tests.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2Frtl-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cd856fc3b61ba3a32133be0e3e53e550191e54/gcc%2Frtl-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-tests.c?ref=36cd856fc3b61ba3a32133be0e3e53e550191e54", "patch": "@@ -65,9 +65,8 @@ assert_rtl_dump_eq (const location &loc, const char *expected_dump, rtx x)\n {\n   named_temp_file tmp_out (\".rtl\");\n   FILE *outfile = fopen (tmp_out.get_filename (), \"w\");\n-  flag_compact = true;\n-  print_rtl (outfile, x);\n-  flag_compact = false;\n+  rtx_writer w (outfile, 0, false, true);\n+  w.print_rtl (x);\n   fclose (outfile);\n \n   char *dump = read_file (SELFTEST_LOCATION, tmp_out.get_filename ());"}]}