{"sha": "2e226e6699bdcf161e3738641490ca18b12faefa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUyMjZlNjY5OWJkY2YxNjFlMzczODY0MTQ5MGNhMThiMTJmYWVmYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-12-22T01:19:39Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-12-22T01:19:39Z"}, "message": "cgraphunit.c, [...]: Fix comment typos.\n\n\t* cgraphunit.c, config/i386/i386.c, config/ia64/ia64.c, cse.c,\n\toutput.h, toplev.c, tree-affine.h, tree-flow.h,\n\ttree-ssa-alias.c, tree-ssa-coalesce.c, tree-ssa-live.c,\n\ttree-ssa-live.h, tree-ssa-operands.c, tree-ssa-ter.c,\n\ttree-vrp.c, varpool.c: Fix comment typos.\n\nFrom-SVN: r120137", "tree": {"sha": "4248e605c7adbfb3c83eaf3d9c6b6448e0edcdc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4248e605c7adbfb3c83eaf3d9c6b6448e0edcdc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e226e6699bdcf161e3738641490ca18b12faefa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e226e6699bdcf161e3738641490ca18b12faefa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e226e6699bdcf161e3738641490ca18b12faefa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e226e6699bdcf161e3738641490ca18b12faefa/comments", "author": null, "committer": null, "parents": [{"sha": "48c9a7f0dbf902685d3a289c32e42812e868b939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c9a7f0dbf902685d3a289c32e42812e868b939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c9a7f0dbf902685d3a289c32e42812e868b939"}], "stats": {"total": 94, "additions": 51, "deletions": 43}, "files": [{"sha": "aca90bd880e4ece699b6eaa1d82f7f6bfad3ba00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -1,3 +1,11 @@\n+2006-12-22  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* cgraphunit.c, config/i386/i386.c, config/ia64/ia64.c, cse.c,\n+\toutput.h, toplev.c, tree-affine.h, tree-flow.h,\n+\ttree-ssa-alias.c, tree-ssa-coalesce.c, tree-ssa-live.c,\n+\ttree-ssa-live.h, tree-ssa-operands.c, tree-ssa-ter.c,\n+\ttree-vrp.c, varpool.c: Fix comment typos.\n+\n 2006-12-22  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/spu/spu.h (ARG_POINTER_CFA_OFFSET): Define."}, {"sha": "f1ea915344501a40cbfa2150c61c15fd944fcf27", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -66,7 +66,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n       data structure must be updated accordingly by this function.\n       There should be little need to call this function and all the references\n       should be made explicit to cgraph code.  At present these functions are\n-      used by C++ frotend to explicitely mark the keyed methods.\n+      used by C++ frontend to explicitely mark the keyed methods.\n \n     - analyze_expr callback\n "}, {"sha": "a7d64b2b54e140f02b661a4bd3f11087e09656d1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -13492,7 +13492,7 @@ decide_alignment (int align,\n   return desired_align;\n }\n \n-/* Return thre smallest power of 2 greater than VAL.  */\n+/* Return the smallest power of 2 greater than VAL.  */\n static int\n smallest_pow2_greater_than (int val)\n {\n@@ -13510,7 +13510,7 @@ smallest_pow2_greater_than (int val)\n    1) Prologue guard: Conditional that jumps up to epilogues for small\n       blocks that can be handled by epilogue alone.  This is faster but\n       also needed for correctness, since prologue assume the block is larger\n-      than the desrired alignment.\n+      than the desired alignment.\n \n       Optional dynamic check for size and libcall for large\n       blocks is emitted here too, with -minline-stringops-dynamically.\n@@ -13834,7 +13834,7 @@ promote_duplicated_reg_to_size (rtx val, int size_needed, int desired_align, int\n \n /* Expand string clear operation (bzero).  Use i386 string operations when\n    profitable.  See expand_movmem comment for explanation of individual\n-   steps performd.  */\n+   steps performed.  */\n int\n ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t\t    rtx expected_align_exp, rtx expected_size_exp)"}, {"sha": "1f455ea49ab2f9e211d21d44dbfdbbe11d3cb31d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -9182,7 +9182,7 @@ ia64_asm_output_external (FILE *file, tree decl, const char *name)\n   if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n     {\n       /* maybe_assemble_visibility will return 1 if the assembler\n-\t visibility directive is outputed.  */\n+\t visibility directive is output.  */\n       int need_visibility = ((*targetm.binds_local_p) (decl)\n \t\t\t     && maybe_assemble_visibility (decl));\n "}, {"sha": "549570b09c3067eef86eb1c88fe9e925bda935a4", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -5791,7 +5791,7 @@ cse_process_notes (rtx x, rtx object)\n    Otherwise, DATA->path is filled and the function returns TRUE indicating\n    that a path to follow was found.\n \n-   If FOLLOW_JUMPS is false, the maximum path lenghth is 1 and the only\n+   If FOLLOW_JUMPS is false, the maximum path length is 1 and the only\n    block in the path will be FIRST_BB.  */\n \n static bool\n@@ -6248,7 +6248,7 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n \t  if (ebb_data.nsets == 0)\n \t    continue;\n \n-\t  /* Get a reasonable extimate for the maximum number of qty's\n+\t  /* Get a reasonable estimate for the maximum number of qty's\n \t     needed for this path.  For this, we take the number of sets\n \t     and multiply that by MAX_RECOG_OPERANDS.  */\n \t  max_qty = ebb_data.nsets * MAX_RECOG_OPERANDS;"}, {"sha": "ca010d92f2bf3de81d7b8420ca940563aff3cde2", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -204,7 +204,7 @@ extern void assemble_variable (tree, int, int, int);\n    DONT_OUTPUT_DATA is from assemble_variable.  */\n extern void align_variable (tree decl, bool dont_output_data);\n \n-/* Queue for outputing something to declare an external symbol to the\n+/* Queue for outputting something to declare an external symbol to the\n    assembler.  (Most assemblers don't need this, so we normally output\n    nothing.)  Do nothing if DECL is not external.  */\n extern void assemble_external (tree);"}, {"sha": "d83da13b4a5348a4ea155816257a0f829d0c7b73", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -1249,7 +1249,7 @@ print_single_switch (print_switch_fn_type print_fn,\n {\n   /* The ultrix fprintf returns 0 on success, so compute the result\n      we want here since we need it for the following test.  The +1\n-     is for the seperator character that will probably be emitted.  */\n+     is for the separator character that will probably be emitted.  */\n   int len = strlen (text) + 1;\n \n   if (pos != 0"}, {"sha": "b83a501c8684380a6d821e7f79d24a1e9556da65", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -49,7 +49,7 @@ typedef struct affine_tree_combination\n      TYPE, but their sizes must be the same (STRIP_NOPS is applied to the\n      elements).\n      \n-     The coefficients are always sign extened from the precision of TYPE\n+     The coefficients are always sign extended from the precision of TYPE\n      (regardless of signedness of TYPE).  */\n   struct aff_comb_elt elts[MAX_AFF_ELTS];\n "}, {"sha": "d4fa3dd57aaae00780925c63b81bbb313623539c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -288,7 +288,7 @@ struct var_ann_d GTY(())\n   unsigned int escape_mask;\n };\n \n-/* Contianer for variable annotation used by hashtable for annotations for\n+/* Container for variable annotation used by hashtable for annotations for\n    static variables.  */\n struct static_var_ann_d GTY(())\n {"}, {"sha": "939ac0f8fec280a7387ed28a576815548a60a25b", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -1710,7 +1710,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t\t{\n \t\t  /* The memory partition holding VAR will no longer\n \t\t     contain VAR, and statements referencing it will need\n-\t\t     to be udpated.  */\n+\t\t     to be updated.  */\n \t\t  if (memory_partition (var))\n \t\t    mark_sym_for_renaming (memory_partition (var));\n "}, {"sha": "195dcf964ec118abde2f4111aa4549e1e0e29480", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -182,7 +182,7 @@ coalesce_pair_map_hash (const void *pair)\n \n \n /* Equality function for coalesce list hash table.  Compare PAIR1 and PAIR2,\n-   returning TRUE if the two pairs are equivilent. */\n+   returning TRUE if the two pairs are equivalent.  */\n \n static int \n coalesce_pair_map_eq (const void *pair1, const void *pair2)\n@@ -309,7 +309,7 @@ add_coalesce (coalesce_list_p cl, int p1, int p2,\n }\n \n \n-/* Comparison function to allow qsort to sort P1 and P2 in Ascendiong order.  */\n+/* Comparison function to allow qsort to sort P1 and P2 in Ascending order.  */\n \n static int \n compare_pairs (const void *p1, const void *p2)\n@@ -355,7 +355,7 @@ end_coalesce_pair_p (coalesce_pair_iterator *iter)\n }\n \n \n-/* Return the next parttition pair to be visited by ITER.  */\n+/* Return the next partition pair to be visited by ITER.  */\n \n static inline coalesce_pair_p\n next_coalesce_pair (coalesce_pair_iterator *iter)\n@@ -466,7 +466,7 @@ dump_coalesce_list (FILE *f, coalesce_list_p cl)\n \n \n /* This represents a conflict graph.  Implemented as an array of bitmaps.  \n-   A full matrix isused for conflicts rather than just upper triangular form.\n+   A full matrix is used for conflicts rather than just upper triangular form.\n    this make sit much simpler and faster to perform conflict merges.  */\n \n typedef struct ssa_conflicts_d\n@@ -787,9 +787,9 @@ live_track_clear_base_vars (live_track_p ptr)\n \n \n /* Build a conflict graph based on LIVEINFO.  Any partitions which are in the\n-   partition view of the var_map liveinfo is based on get entires in the \n+   partition view of the var_map liveinfo is based on get entries in the \n    conflict graph.  Only conflicts between ssa_name partitions with the same \n-   base variableare added.  */\n+   base variable are added.  */\n \n static ssa_conflicts_p\n build_ssa_conflict_graph (tree_live_info_p liveinfo)\n@@ -1140,7 +1140,7 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n }\n \n \n-/* Attempt to coalesce ssa verisons X and Y together using the partition\n+/* Attempt to coalesce ssa versions X and Y together using the partition\n    mapping in MAP and checking conflicts in GRAPH.  Output any debug info to\n    DEBUG, if it is nun-NULL.  */\n \n@@ -1219,8 +1219,8 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n   edge e;\n   edge_iterator ei;\n \n-  /* First, coalece all the copie across abnormal edges.  These are not placed\n-     in the coalesce list becase they do not need to be sorted, and simply \n+  /* First, coalesce all the copies across abnormal edges.  These are not placed\n+     in the coalesce list because they do not need to be sorted, and simply \n      consume extra memory/compilation time in large programs.  */\n \n   FOR_EACH_BB (bb)"}, {"sha": "eecf6e73bdfe671f1a04a1597b01bb17010cd3b1", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -560,7 +560,7 @@ delete_tree_live_info (tree_live_info_p live)\n \n /* Visit basic block BB and propogate any required live on entry bits from \n    LIVE into the predecessors.  VISITED is the bitmap of visited blocks.  \n-   TMP is a temporary work bitmap which is passed in to avoid reallocting\n+   TMP is a temporary work bitmap which is passed in to avoid reallocating\n    it each time.  */\n \n static void \n@@ -602,7 +602,7 @@ loe_visit_block (tree_live_info_p live, basic_block bb, sbitmap visited,\n \n \n /* Using LIVE, fill in all the live-on-entry blocks between the defs and uses \n-   of all the vairables.  */\n+   of all the variables.  */\n \n static void\n live_worklist (tree_live_info_p live)\n@@ -631,7 +631,7 @@ live_worklist (tree_live_info_p live)\n }\n \n \n-/* Calulate the initial live on entry vector for SSA_NAME using immediate_use\n+/* Calculate the initial live on entry vector for SSA_NAME using immediate_use\n    links.  Set the live on entry fields in LIVE.  Def's are marked temporarily\n    in the liveout vector.  */\n "}, {"sha": "18dba67730d3fd9a810c354bb398bb10fc0f21f8", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -31,8 +31,8 @@ Boston, MA 02110-1301, USA.  */\n /* Used to create the variable mapping when we go out of SSA form.  \n \n    Mapping from an ssa_name to a partition number is maintained, as well as\n-   partition number to back to ssa_name. A parition can also be represented\n-   by a non-ssa_name variable.  This allows ssa_names and thier partition to \n+   partition number to back to ssa_name. A partition can also be represented\n+   by a non-ssa_name variable.  This allows ssa_names and their partition to \n    be coalesced with live on entry compiler variables, as well as eventually\n    having real compiler variables assigned to each partition as part of the \n    final stage of going of of ssa.  \n@@ -43,7 +43,7 @@ Boston, MA 02110-1301, USA.  */\n    partitions.  This allows the coalescer to decide what partitions are \n    interesting to it, and only work with those partitions.  Whenever the view\n    is changed, the partition numbers change, but none of the partition groupings\n-   change. (ie, it is truly a view since it doesnt change anything)\n+   change. (ie, it is truly a view since it doesn't change anything)\n \n    The final component of the data structure is the basevar map.  This provides\n    a list of all the different base variables which occue in a partition view,"}, {"sha": "dbbcf341d29684a40b7db306627b7c2901cadc3b", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -468,8 +468,8 @@ ssa_operand_alloc (unsigned size)\n       if (size > ssa_operand_mem_size)\n         ssa_operand_mem_size = OP_SIZE_3 * sizeof (struct voptype_d);\n \n-      /* Fail if there is not enough space.  If thre are this many operands\n-\t required, first make sure there isn't a different probem causing this\n+      /* Fail if there is not enough space.  If there are this many operands\n+\t required, first make sure there isn't a different problem causing this\n \t many operands.  If the decision is that this is OK, then we can \n \t specially allocate a buffer just for this request.  */\n       gcc_assert (size <= ssa_operand_mem_size);\n@@ -607,7 +607,7 @@ add_use_op (tree stmt, tree *op, use_optype_p last)\n \n \n /* Return a virtual op pointer with NUM elements which are all initialized to OP\n-   and are linked into the immeidate uses for STMT.  The new vop is appended\n+   and are linked into the immediate uses for STMT.  The new vop is appended\n    after PREV.  */\n \n static inline voptype_p"}, {"sha": "d549ed43461752dc42b461fd7eab793dd112f1fd", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -80,13 +80,13 @@ Boston, MA 02110-1301, USA.  */\n    v_9 = a_2 * n_12\n    <...>\n \n-   If b_5, b_8 and b_14 are all colaesced together...\n+   If b_5, b_8 and b_14 are all coalesced together...\n    The expression b_5 + 6 CANNOT replace the use in the statement defining v_9\n    because b_8 is in fact killing the value of b_5 since they share a partition\n-   and will be assigned the same memory or regster location.\n+   and will be assigned the same memory or register location.\n    \n    TER implements this but stepping through the instructions in a block and\n-   tracking potential expressions for replacement, and the paritions they are\n+   tracking potential expressions for replacement, and the partitions they are\n    dependent on.  Expressions are represented by the SSA_NAME_VERSION of the\n    DEF on the LHS of a GIMPLE_MODIFY_STMT and the expression is the RHS.\n \n@@ -110,8 +110,8 @@ Boston, MA 02110-1301, USA.  */\n    an expression from the partition kill lists when a decision is made whether\n    to replace it or not.  This is indexed by ssa version number as well, and\n    indicates a partition number.  virtual operands are not tracked individually,\n-   but they are summarized by an artifical partition called VIRTUAL_PARTITION.\n-   This means a MAY or MUST def will kill *ALL* expressions that are dependant\n+   but they are summarized by an artificial partition called VIRTUAL_PARTITION.\n+   This means a MAY or MUST def will kill *ALL* expressions that are dependent\n    on a virtual operand.\n    Note that the EXPR_DECL_UID and this bitmap represent very similar \n    information, but the info in one is not easy to obtain from the other.\n@@ -121,11 +121,11 @@ Boston, MA 02110-1301, USA.  */\n    longer be valid if a definition into this partition takes place.\n \n    PARTITION_IN_USE is simply a bitmap which is used to track which partitions\n-   currently have sokmething in their kill list.  This is used at the end of \n+   currently have something in their kill list.  This is used at the end of \n    a block to clear out the KILL_LIST bitmaps at the end of each block.\n \n    NEW_REPLACEABLE_DEPENDENCIES is used as a temporary place to store \n-   dependencies which will be reused by the current defintion. ALl the uses\n+   dependencies which will be reused by the current definition. ALl the uses\n    on an expression are processed before anything else is done. If a use is\n    determined to be a replaceable expression AND the current stmt is also going\n    to be replaceable, all the dependencies of this replaceable use will be\n@@ -161,8 +161,8 @@ typedef struct temp_expr_table_d\n   tree *replaceable_expressions;\t/* Replacement expression table.  */\n   bitmap *expr_decl_uids;\t\t/* Base uids of exprs.  */\n   bitmap *kill_list;\t\t\t/* Expr's killed by a partition.  */\n-  int virtual_partition;\t\t/* Psuedo partition for virtual ops.  */\n-  bitmap partition_in_use;\t\t/* Partitions with kill entires.  */\n+  int virtual_partition;\t\t/* Pseudo partition for virtual ops.  */\n+  bitmap partition_in_use;\t\t/* Partitions with kill entries.  */\n   bitmap new_replaceable_dependencies;\t/* Holding place for pending dep's.  */\n   int *num_in_part;\t\t\t/* # of ssa_names in a partition.  */\n } *temp_expr_table_p;\n@@ -256,7 +256,7 @@ version_to_be_replaced_p (temp_expr_table_p tab, int version)\n }\n \n \n-/* Add partition P to the list if partititons VERSION is dependent on.  TAB is \n+/* Add partition P to the list if partitions VERSION is dependent on.  TAB is \n    the expression table */\n \n static inline void"}, {"sha": "e1c8ca0eb3a9aa7787341b2254fd914cffa33217", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -626,8 +626,8 @@ compare_values (tree val1, tree val2)\n \n       /* If VAL1 is different than VAL2, return +2.\n \t For integer constants we either have already returned -1 or 1\n-\t or they are equivalent.  We still might suceed prove something\n-\t about non-trivial operands.  */\n+\t or they are equivalent.  We still might succeed in proving\n+\t something about non-trivial operands.  */\n       if (TREE_CODE (val1) != INTEGER_CST\n \t  || TREE_CODE (val2) != INTEGER_CST)\n \t{"}, {"sha": "03c351b7f21683a59c1894260558827a62ccf4f1", "filename": "gcc/varpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e226e6699bdcf161e3738641490ca18b12faefa/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=2e226e6699bdcf161e3738641490ca18b12faefa", "patch": "@@ -40,7 +40,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n     and drives the decision process on what variables and when are\n     going to be compiled.\n \n-    The varpool nodes are alocated lazilly for declarations\n+    The varpool nodes are allocated lazily for declarations\n     either by frontend or at callgraph construction time.\n     All variables supposed to be output into final file needs to be\n     explicitely marked by frontend via VARPOOL_FINALIZE_DECL function.  */"}]}