{"sha": "af3fa359b4b7335008652b9f1eefbd41ac8216d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYzZmEzNTliNGI3MzM1MDA4NjUyYjlmMWVlZmJkNDFhYzgyMTZkOQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-12-19T19:14:57Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-12-19T19:14:57Z"}, "message": "PR middle-end/77608 - missing protection on trivially detectable runtime buffer overflow\n\ngcc/ChangeLog:\n\n\tPR middle-end/77608\n\t* builtins.c (compute_objsize): Handle non-constant offsets.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/77608\n\t* gcc.dg/Wstringop-overflow.c: New test.\n\t* gcc/testsuite/c-c++-common/Warray-bounds-3.c: Adjust.\n\nFrom-SVN: r255836", "tree": {"sha": "0b623ef61a38f20695163685271de8c2c80a50f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b623ef61a38f20695163685271de8c2c80a50f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af3fa359b4b7335008652b9f1eefbd41ac8216d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af3fa359b4b7335008652b9f1eefbd41ac8216d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af3fa359b4b7335008652b9f1eefbd41ac8216d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af3fa359b4b7335008652b9f1eefbd41ac8216d9/comments", "author": null, "committer": null, "parents": [{"sha": "ad2a970f7973708ea3359c0b8cc2aec7c9ead1bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2a970f7973708ea3359c0b8cc2aec7c9ead1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2a970f7973708ea3359c0b8cc2aec7c9ead1bb"}], "stats": {"total": 217, "additions": 206, "deletions": 11}, "files": [{"sha": "4581f41d8fb242e2eee629d17f8a0771c8191ff2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af3fa359b4b7335008652b9f1eefbd41ac8216d9", "patch": "@@ -1,3 +1,8 @@\n+2017-12-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77608\n+\t* builtins.c (compute_objsize): Handle non-constant offsets.\n+\n 2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/83444\n@@ -190,6 +195,7 @@\n \t* tree-ssa-dom.c (record_equivalences_from_phis): Fix handling\n \tof degenerates resulting from ignoring an edge.\n \n+>>>>>>> .r255835\n 2017-12-18  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/83373"}, {"sha": "6bff904d8beeccc60c551a52e53702aea2ef83d8", "filename": "gcc/builtins.c", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=af3fa359b4b7335008652b9f1eefbd41ac8216d9", "patch": "@@ -3278,8 +3278,12 @@ check_access (tree exp, tree, tree, tree dstwrite,\n /* Helper to compute the size of the object referenced by the DEST\n    expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).  Return\n-   the size of the object if successful or NULL when the size cannot\n-   be determined.  */\n+   an estimate of the size of the object if successful or NULL when\n+   the size cannot be determined.  When the referenced object involves\n+   a non-constant offset in some range the returned value represents\n+   the largest size given the smallest non-negative offset in the\n+   range.  The function is intended for diagnostics and should not\n+   be used to influence code generation or optimization.  */\n \n tree\n compute_objsize (tree dest, int ostype)\n@@ -3292,24 +3296,57 @@ compute_objsize (tree dest, int ostype)\n   if (compute_builtin_object_size (dest, ostype, &size))\n     return build_int_cst (sizetype, size);\n \n-  /* Unless computing the largest size (for memcpy and other raw memory\n-     functions), try to determine the size of the object from its type.  */\n-  if (!ostype)\n-    return NULL_TREE;\n-\n   if (TREE_CODE (dest) == SSA_NAME)\n     {\n       gimple *stmt = SSA_NAME_DEF_STMT (dest);\n       if (!is_gimple_assign (stmt))\n \treturn NULL_TREE;\n \n+      dest = gimple_assign_rhs1 (stmt);\n+\n       tree_code code = gimple_assign_rhs_code (stmt);\n-      if (code != ADDR_EXPR && code != POINTER_PLUS_EXPR)\n-\treturn NULL_TREE;\n+      if (code == POINTER_PLUS_EXPR)\n+\t{\n+\t  /* compute_builtin_object_size fails for addresses with\n+\t     non-constant offsets.  Try to determine the range of\n+\t     such an offset here and use it to adjus the constant\n+\t     size.  */\n+\t  tree off = gimple_assign_rhs2 (stmt);\n+\t  if (TREE_CODE (off) == SSA_NAME\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (off)))\n+\t    {\n+\t      wide_int min, max;\n+\t      enum value_range_type rng = get_range_info (off, &min, &max);\n \n-      dest = gimple_assign_rhs1 (stmt);\n+\t      if (rng == VR_RANGE)\n+\t\t{\n+\t\t  if (tree size = compute_objsize (dest, ostype))\n+\t\t    {\n+\t\t      wide_int wisiz = wi::to_wide (size);\n+\n+\t\t      /* Ignore negative offsets for now.  For others,\n+\t\t\t use the lower bound as the most optimistic\n+\t\t\t estimate of the (remaining)size.  */\n+\t\t      if (wi::sign_mask (min))\n+\t\t\t;\n+\t\t      else if (wi::ltu_p (min, wisiz))\n+\t\t\treturn wide_int_to_tree (TREE_TYPE (size),\n+\t\t\t\t\t\t wi::sub (wisiz, min));\n+\t\t      else\n+\t\t\treturn size_zero_node;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else if (code != ADDR_EXPR)\n+\treturn NULL_TREE;\n     }\n \n+  /* Unless computing the largest size (for memcpy and other raw memory\n+     functions), try to determine the size of the object from its type.  */\n+  if (!ostype)\n+    return NULL_TREE;\n+\n   if (TREE_CODE (dest) != ADDR_EXPR)\n     return NULL_TREE;\n \n@@ -3471,6 +3508,19 @@ expand_builtin_mempcpy (tree exp, rtx target)\n   tree src = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n+  /* Policy does not generally allow using compute_objsize (which\n+     is used internally by check_memop_size) to change code generation\n+     or drive optimization decisions.\n+\n+     In this instance it is safe because the code we generate has\n+     the same semantics regardless of the return value of\n+     check_memop_sizes.   Exactly the same amount of data is copied\n+     and the return value is exactly the same in both cases.\n+\n+     Furthermore, check_memop_size always uses mode 0 for the call to\n+     compute_objsize, so the imprecise nature of compute_objsize is\n+     avoided.  */\n+\n   /* Avoid expanding mempcpy into memcpy when the call is determined\n      to overflow the buffer.  This also prevents the same overflow\n      from being diagnosed again when expanding memcpy.  */"}, {"sha": "63d671374e3bf219cada1986a0948036c91aa546", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af3fa359b4b7335008652b9f1eefbd41ac8216d9", "patch": "@@ -1,3 +1,9 @@\n+2017-12-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77608\n+\t* gcc.dg/Wstringop-overflow.c: New test.\n+\t* gcc/testsuite/c-c++-common/Warray-bounds-3.c: Adjust.\n+\n 2017-12-19  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR debug/83422\n@@ -57,6 +63,7 @@\n \tPR ipa/83346\n \t* g++.dg/ipa/pr82801.C: New test.\n \n+>>>>>>> .r255835\n 2017-12-18  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/83373"}, {"sha": "73103f43d01a1ea0e6d686bfae43f21b7cd5f728", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c?ref=af3fa359b4b7335008652b9f1eefbd41ac8216d9", "patch": "@@ -1,7 +1,7 @@\n /* Exercise that -Warray-bounds is issued for out-of-bounds offsets\n    in calls to built-in functions.\n    { dg-do compile }\n-   { dg-options \"-O2 -Warray-bounds -ftrack-macro-expansion=0\" }  */\n+   { dg-options \"-O2 -Wno-stringop-overflow -Warray-bounds -ftrack-macro-expansion=0\" }  */\n \n #include \"../gcc.dg/range.h\"\n "}, {"sha": "b5bd40ed958145812b5cdbade9e23c7bcbdbdccc", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3fa359b4b7335008652b9f1eefbd41ac8216d9/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow.c?ref=af3fa359b4b7335008652b9f1eefbd41ac8216d9", "patch": "@@ -0,0 +1,132 @@\n+/* PR middle-end/77608 - missing protection on trivially detectable runtime\n+   buffer overflow\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wstringop-overflow -ftrack-macro-expansion=0\" }  */\n+\n+#define SIZE_MAX   __SIZE_MAX__\n+#define DIFF_MAX   __PTRDIFF_MAX__\n+#define DIFF_MIN   (-DIFF_MAX - 1)\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memcpy (void*, const void*, size_t);\n+extern char* strcpy (char*, const char*);\n+extern char* strncpy (char*, const char*, size_t);\n+\n+void sink (void*);\n+\n+extern size_t unsigned_value (void)\n+{\n+  extern volatile size_t unsigned_value_source;\n+  return unsigned_value_source;\n+}\n+\n+size_t unsigned_range (size_t min, size_t max)\n+{\n+  size_t val = unsigned_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+#define UR(min, max) unsigned_range (min, max)\n+\n+\n+char a7[7];\n+\n+struct MemArray { char a9[9]; char a1[1]; };\n+\n+void test_memcpy_array (const void *s)\n+{\n+#define T(d, s, n) (memcpy ((d), (s), (n)), sink (d))\n+\n+  T (a7 + UR (0, 1), s, 7);\n+  T (a7 + UR (0, 7), s, 7);\n+  T (a7 + UR (0, 8), s, 7);\n+  T (a7 + UR (0, DIFF_MAX), s, 7);\n+  T (a7 + UR (0, SIZE_MAX), s, 7);\n+\n+  T (a7 + UR (1, 2), s, 7);   /* { dg-warning \"writing 7 bytes into a region of size 6\" } */\n+  T (a7 + UR (2, 3), s, 7);   /* { dg-warning \"writing 7 bytes into a region of size 5\" } */\n+  T (a7 + UR (6, 9), s, 7);   /* { dg-warning \"writing 7 bytes into a region of size 1\" } */\n+  T (a7 + UR (7, 9), s, 7);   /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+  T (a7 + UR (8, 9), s, 7);   /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+\n+  T (a7 + UR (9, 10), s, 7);  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+  T (a7 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), s, 7);  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+  T (a7 + UR (DIFF_MAX, SIZE_MAX), s, 7);  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+\n+  /* This is valid.  */\n+  char *d = a7 + 7;\n+  T (d + UR (-8, -7), s, 7);\n+}\n+\n+/* Verify the absence of warnings for memcpy writing beyond object\n+   boundaries. */\n+\n+void test_memcpy_memarray (struct MemArray *p, const void *s)\n+{\n+#undef T\n+#define T(d, s, n) (memcpy ((d), (s), (n)), sink (d))\n+\n+  /* The following are valid.  */\n+  T (p->a9 + UR (0, 1), s, 9);\n+  T (p->a9 + UR (0, 7), s, 9);\n+  T (p->a9 + UR (0, 8), s, 9);\n+  T (p->a9 + UR (0, DIFF_MAX), s, 9);\n+  T (p->a9 + UR (0, SIZE_MAX), s, 9);\n+\n+  /* The following are invalid.  Unfortunately, there is apparently enough\n+     code out there that abuses memcpy to write past the end of one member\n+     and into the members that follow so the following are not diagnosed\n+     by design.  It sure would be nice not to have to cater to hacks like\n+     these...  */\n+  T (p->a9 + UR (1, 2), s, 9);\n+  T (p->a9 + UR (1, 2), s, 123);\n+}\n+\n+\n+void test_strcpy_array (void)\n+{\n+#undef T\n+#define T(d, s) (strcpy ((d), (s)), sink (d))\n+\n+  T (a7 + UR (0, 1), \"012345\");\n+  T (a7 + UR (0, 7), \"012345\");\n+  T (a7 + UR (0, 8), \"012345\");\n+  T (a7 + UR (0, DIFF_MAX), \"012345\");\n+  T (a7 + UR (0, SIZE_MAX), \"012345\");\n+\n+  T (a7 + UR (1, 2), \"012345\");   /* { dg-warning \"writing 7 bytes into a region of size 6\" } */\n+  T (a7 + UR (2, 3), \"012345\");   /* { dg-warning \"writing 7 bytes into a region of size 5\" } */\n+  T (a7 + UR (6, 9), \"012345\");   /* { dg-warning \"writing 7 bytes into a region of size 1\" } */\n+  T (a7 + UR (7, 9), \"012345\");   /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+  T (a7 + UR (8, 9), \"012345\");   /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+\n+  T (a7 + UR (9, 10), \"012345\");  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+  T (a7 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), \"012345\");  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+  T (a7 + UR (DIFF_MAX, SIZE_MAX), \"012345\");  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+\n+  char *d = a7 + 7;\n+\n+  T (d + UR (-8, -7), \"012345\");\n+}\n+\n+void test_strncpy_memarray (struct MemArray *p, const void *s)\n+{\n+#undef T\n+#define T(d, s, n) (strncpy ((d), (s), (n)), sink (d))\n+\n+  T (p->a9 + UR (0, 1), s, 9);\n+  T (p->a9 + UR (0, 7), s, 9);\n+  T (p->a9 + UR (0, 8), s, 9);\n+  T (p->a9 + UR (0, DIFF_MAX), s, 9);\n+  T (p->a9 + UR (0, SIZE_MAX), s, 9);\n+\n+  T (p->a9 + UR (1, 2), s, 9);    /* { dg-warning \"writing 9 bytes into a region of size 8\" } */\n+  T (p->a9 + UR (2, 3), s, 9);    /* { dg-warning \"writing 9 bytes into a region of size 7\" } */\n+  T (p->a9 + UR (6, 9), s, 9);    /* { dg-warning \"writing 9 bytes into a region of size 3\" } */\n+  T (p->a9 + UR (9, 10), s, 9);   /* { dg-warning \"writing 9 bytes into a region of size 0\" } */\n+  T (p->a9 + UR (10, 11), s, 9);  /* { dg-warning \"writing 9 bytes into a region of size 0\" } */\n+\n+  T (p->a9 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), s, 1);  /* { dg-warning \"writing 1 byte into a region of size 0\" } */\n+  T (p->a9 + UR (DIFF_MAX, SIZE_MAX), s, 3);  /* { dg-warning \"writing 3 bytes into a region of size 0\" } */\n+}"}]}