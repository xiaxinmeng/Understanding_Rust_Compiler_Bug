{"sha": "cff7525fb078f60cffd2050f93eb7a257cf158a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmNzUyNWZiMDc4ZjYwY2ZmZDIwNTBmOTNlYjdhMjU3Y2YxNThhNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-02-27T19:49:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-02-27T19:49:42Z"}, "message": "re PR debug/39267 (gdb testsuite regressions)\n\n\tPR debug/39267\n\t* tree.h (TREE_PROTECTED): Fix comment.\n\t(BLOCK_HANDLER_BLOCK): Remove.\n\t(struct tree_block): Remove handler_block add body_block.\n\t(inlined_function_outer_scope_p): New.\n\t(is_body_block): Remove.\n\t* dbxout.c (dbxout_block): Remove BLOCK_HANDLER_BLOCK.\n\t* dwarf2out.c (is_inlined_entry_point): Remove.\n\t(add_high_low_attributes): Use inlined_function_outer_scope_p.\n\t(gen_block_die): Use is_inlined_entry_point check; remove body block code.\n\t* langhooks.h (struct lang_hooks): Remove no_bodu_blocks.\n\t* gimplify.c (gimplify_expr): Gimplify body blocks.\n\t* tree-ssa-live.c (remove_unused_scope_block_p): Allow removing wrapper block\n\twith multiple subblocks.\n\t(dump_scope_block): Prettier output; dump more flags and info.\n\t(dump_scope_blocks): New.\n\t(remove_unused_locals): Use dump_scope_blocks.\n\t* tree-flow.h (dump_scope_blocks): Declare.\n\t* tree-cfg.c (execute_build_cfg): Dump scope blocks.\n\t* stmt.c (is_body_block): Remove.\n\t* tree-inline.c (remap_block): Copy BODY_BLOCK info.\n\t* langhooks-def.h (LANG_HOOKS_NO_BODY_BLOCKS): Remove.\n\nFrom-SVN: r144474", "tree": {"sha": "88b2c40a53c2a5175a5910476fd385f50ff0d754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88b2c40a53c2a5175a5910476fd385f50ff0d754"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cff7525fb078f60cffd2050f93eb7a257cf158a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff7525fb078f60cffd2050f93eb7a257cf158a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cff7525fb078f60cffd2050f93eb7a257cf158a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff7525fb078f60cffd2050f93eb7a257cf158a4/comments", "author": null, "committer": null, "parents": [{"sha": "c20993b9959c1586b273eba9c50282a7a56064dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20993b9959c1586b273eba9c50282a7a56064dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c20993b9959c1586b273eba9c50282a7a56064dd"}], "stats": {"total": 302, "additions": 140, "deletions": 162}, "files": [{"sha": "17ffc76297356e79254d887230e93406444bde2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -1,3 +1,28 @@\n+2009-02-27  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR debug/39267\n+\t* tree.h (TREE_PROTECTED): Fix comment.\n+\t(BLOCK_HANDLER_BLOCK): Remove.\n+\t(struct tree_block): Remove handler_block add body_block.\n+\t(inlined_function_outer_scope_p): New.\n+\t(is_body_block): Remove.\n+\t* dbxout.c (dbxout_block): Remove BLOCK_HANDLER_BLOCK.\n+\t* dwarf2out.c (is_inlined_entry_point): Remove.\n+\t(add_high_low_attributes): Use inlined_function_outer_scope_p.\n+\t(gen_block_die): Use is_inlined_entry_point check; remove body block code.\n+\t* langhooks.h (struct lang_hooks): Remove no_bodu_blocks.\n+\t* gimplify.c (gimplify_expr): Gimplify body blocks.\n+\t* tree-ssa-live.c (remove_unused_scope_block_p): Allow removing wrapper block\n+\twith multiple subblocks.\n+\t(dump_scope_block): Prettier output; dump more flags and info.\n+\t(dump_scope_blocks): New.\n+\t(remove_unused_locals): Use dump_scope_blocks.\n+\t* tree-flow.h (dump_scope_blocks): Declare.\n+\t* tree-cfg.c (execute_build_cfg): Dump scope blocks.\n+\t* stmt.c (is_body_block): Remove.\n+\t* tree-inline.c (remap_block): Copy BODY_BLOCK info.\n+\t* langhooks-def.h (LANG_HOOKS_NO_BODY_BLOCKS): Remove.\n+\n 2009-02-27  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR middle-end/39308"}, {"sha": "a84113f867eea65e01860d631aeb03c07c451c38", "filename": "gcc/c-common.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -7740,6 +7740,7 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t      tree curindex;\n \t      unsigned HOST_WIDE_INT cnt;\n \t      constructor_elt *ce;\n+\t      bool fold_p = false;\n \n \t      if (VEC_index (constructor_elt, v, 0)->index)\n \t\tmaxindex = fold_convert (sizetype,\n@@ -7751,14 +7752,20 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t\t   VEC_iterate (constructor_elt, v, cnt, ce);\n \t\t   cnt++)\n \t\t{\n+\t\t  bool curfold_p = false;\n \t\t  if (ce->index)\n-\t\t    curindex = fold_convert (sizetype, ce->index);\n+\t\t    curindex = ce->index, curfold_p = true;\n \t\t  else\n-\t\t    curindex = size_binop (PLUS_EXPR, curindex, size_one_node);\n-\n+\t\t    {\n+\t\t      if (fold_p)\n+\t\t        curindex = fold_convert (sizetype, curindex);\n+\t\t      curindex = size_binop (PLUS_EXPR, curindex, size_one_node);\n+\t\t    }\n \t\t  if (tree_int_cst_lt (maxindex, curindex))\n-\t\t    maxindex = curindex;\n+\t\t    maxindex = curindex, fold_p = curfold_p;\n \t\t}\n+\t       if (fold_p)\n+\t         maxindex = fold_convert (sizetype, maxindex);\n \t    }\n \t}\n       else"}, {"sha": "2a981502b842c384cdb6d5d1e947a197c29ff057", "filename": "gcc/c-objc-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.h?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -53,8 +53,6 @@ extern void c_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL c_finish_incomplete_decl\n #undef LANG_HOOKS_STATICP\n #define LANG_HOOKS_STATICP c_staticp\n-#undef LANG_HOOKS_NO_BODY_BLOCKS\n-#define LANG_HOOKS_NO_BODY_BLOCKS true\n #undef LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL\n #define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL c_warn_unused_global_decl\n #undef LANG_HOOKS_PRINT_IDENTIFIER"}, {"sha": "babba15f8a507f23239fade0494a57c4e6a23159", "filename": "gcc/dbxout.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -3625,20 +3625,6 @@ dbxout_block (tree block, int depth, tree args)\n \t\t  scope_start = buf;\n \t\t}\n \n-\t      if (BLOCK_HANDLER_BLOCK (block))\n-\t\t{\n-\t\t  /* A catch block.  Must precede N_LBRAC.  */\n-\t\t  tree decl = BLOCK_VARS (block);\n-\t\t  while (decl)\n-\t\t    {\n-\t\t      dbxout_begin_complex_stabs ();\n-\t\t      stabstr_I (DECL_NAME (decl));\n-\t\t      stabstr_S (\":C1\");\n-\t\t      dbxout_finish_complex_stabs (0, N_CATCH, 0,\n-\t\t\t\t\t\t   scope_start, 0);\n-\t\t      decl = TREE_CHAIN (decl);\n-\t\t    }\n-\t\t}\n \t      dbx_output_lbrac (scope_start, begin_label);\n \t    }\n "}, {"sha": "9d39a455e855419eeb1c5edff2413441d572b00a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 26, "deletions": 72, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -14135,35 +14135,6 @@ add_call_src_coords_attributes (tree stmt, dw_die_ref die)\n }\n \n \n-/* If STMT's abstract origin is a function declaration and STMT's\n-   first subblock's abstract origin is the function's outermost block,\n-   then we're looking at the main entry point.  */\n-static bool\n-is_inlined_entry_point (const_tree stmt)\n-{\n-  tree decl, block;\n-\n-  if (!stmt || TREE_CODE (stmt) != BLOCK)\n-    return false;\n-\n-  decl = block_ultimate_origin (stmt);\n-\n-  if (!decl || TREE_CODE (decl) != FUNCTION_DECL)\n-    return false;\n-\n-  block = BLOCK_SUBBLOCKS (stmt);\n-\n-  if (block)\n-    {\n-      if (TREE_CODE (block) != BLOCK)\n-\treturn false;\n-\n-      block = block_ultimate_origin (block);\n-    }\n-\n-  return block == DECL_INITIAL (decl);\n-}\n-\n /* A helper function for gen_lexical_block_die and gen_inlined_subroutine_die.\n    Add low_pc and high_pc attributes to the DIE for a block STMT.  */\n \n@@ -14176,7 +14147,7 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n     {\n       tree chain;\n \n-      if (is_inlined_entry_point (stmt))\n+      if (inlined_function_outer_scope_p (stmt))\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n \t\t\t\t       BLOCK_NUMBER (stmt));\n@@ -14861,14 +14832,15 @@ static void\n gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n {\n   int must_output_die = 0;\n-  tree origin;\n   tree decl;\n-  enum tree_code origin_code;\n+  bool inlined_func;\n \n   /* Ignore blocks that are NULL.  */\n   if (stmt == NULL_TREE)\n     return;\n \n+  inlined_func = inlined_function_outer_scope_p (stmt);\n+\n   /* If the block is one fragment of a non-contiguous block, do not\n      process the variables, since they will have been done by the\n      origin block.  Do process subblocks.  */\n@@ -14882,52 +14854,34 @@ gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n       return;\n     }\n \n-  /* Determine the \"ultimate origin\" of this block.  This block may be an\n-     inlined instance of an inlined instance of inline function, so we have\n-     to trace all of the way back through the origin chain to find out what\n-     sort of node actually served as the original seed for the creation of\n-     the current block.  */\n-  origin = block_ultimate_origin (stmt);\n-  origin_code = (origin != NULL) ? TREE_CODE (origin) : ERROR_MARK;\n-\n   /* Determine if we need to output any Dwarf DIEs at all to represent this\n      block.  */\n-  if (origin_code == FUNCTION_DECL)\n+  if (inlined_func)\n     /* The outer scopes for inlinings *must* always be represented.  We\n        generate DW_TAG_inlined_subroutine DIEs for them.  (See below.) */\n     must_output_die = 1;\n   else\n     {\n-      /* In the case where the current block represents an inlining of the\n-\t \"body block\" of an inline function, we must *NOT* output any DIE for\n-\t this block because we have already output a DIE to represent the whole\n-\t inlined function scope and the \"body block\" of any function doesn't\n-\t really represent a different scope according to ANSI C rules.  So we\n-\t check here to make sure that this block does not represent a \"body\n-\t block inlining\" before trying to set the MUST_OUTPUT_DIE flag.  */\n-      if (! is_body_block (origin ? origin : stmt))\n-\t{\n-\t  /* Determine if this block directly contains any \"significant\"\n-\t     local declarations which we will need to output DIEs for.  */\n-\t  if (debug_info_level > DINFO_LEVEL_TERSE)\n-\t    /* We are not in terse mode so *any* local declaration counts\n-\t       as being a \"significant\" one.  */\n-\t    must_output_die = (BLOCK_VARS (stmt) != NULL\n-\t\t\t       && (TREE_USED (stmt)\n-\t\t\t\t   || TREE_ASM_WRITTEN (stmt)\n-\t\t\t\t   || BLOCK_ABSTRACT (stmt)));\n-\t  else\n-\t    /* We are in terse mode, so only local (nested) function\n-\t       definitions count as \"significant\" local declarations.  */\n-\t    for (decl = BLOCK_VARS (stmt);\n-\t\t decl != NULL; decl = TREE_CHAIN (decl))\n-\t      if (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t  && DECL_INITIAL (decl))\n-\t\t{\n-\t\t  must_output_die = 1;\n-\t\t  break;\n-\t\t}\n-\t}\n+      /* Determine if this block directly contains any \"significant\"\n+\t local declarations which we will need to output DIEs for.  */\n+      if (debug_info_level > DINFO_LEVEL_TERSE)\n+\t/* We are not in terse mode so *any* local declaration counts\n+\t   as being a \"significant\" one.  */\n+\tmust_output_die = (BLOCK_VARS (stmt) != NULL\n+\t\t\t   && (TREE_USED (stmt)\n+\t\t\t       || TREE_ASM_WRITTEN (stmt)\n+\t\t\t       || BLOCK_ABSTRACT (stmt)));\n+      else\n+\t/* We are in terse mode, so only local (nested) function\n+\t   definitions count as \"significant\" local declarations.  */\n+\tfor (decl = BLOCK_VARS (stmt);\n+\t     decl != NULL; decl = TREE_CHAIN (decl))\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && DECL_INITIAL (decl))\n+\t    {\n+\t      must_output_die = 1;\n+\t      break;\n+\t    }\n     }\n \n   /* It would be a waste of space to generate a Dwarf DW_TAG_lexical_block\n@@ -14939,7 +14893,7 @@ gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n      instances and local (nested) function definitions.  */\n   if (must_output_die)\n     {\n-      if (origin_code == FUNCTION_DECL)\n+      if (inlined_func)\n \tgen_inlined_subroutine_die (stmt, context_die, depth);\n       else\n \tgen_lexical_block_die (stmt, context_die, depth);"}, {"sha": "f9f8cde4d2a5ed520d235e1d5d7054c8540305dd", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -97,7 +97,6 @@ extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n #define LANG_HOOKS_STATICP\t\tlhd_staticp\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL lhd_do_nothing_t\n #define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME lhd_set_decl_assembler_name\n-#define LANG_HOOKS_NO_BODY_BLOCKS\tfalse\n #define LANG_HOOKS_PRINT_STATISTICS\tlhd_do_nothing\n #define LANG_HOOKS_PRINT_XNODE\t\tlhd_print_tree_nothing\n #define LANG_HOOKS_PRINT_DECL\t\tlhd_print_tree_nothing\n@@ -246,7 +245,6 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_STATICP, \\\n   LANG_HOOKS_DUP_LANG_SPECIFIC_DECL, \\\n   LANG_HOOKS_SET_DECL_ASSEMBLER_NAME, \\\n-  LANG_HOOKS_NO_BODY_BLOCKS, \\\n   LANG_HOOKS_PRINT_STATISTICS, \\\n   LANG_HOOKS_PRINT_XNODE, \\\n   LANG_HOOKS_PRINT_DECL, \\"}, {"sha": "52d1f24448cea22095c90527ec9122c7d5b2cbd7", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -317,11 +317,6 @@ struct lang_hooks\n      assembler does not talk about it.  */\n   void (*set_decl_assembler_name) (tree);\n \n-  /* Nonzero if this front end does not generate a dummy BLOCK between\n-     the outermost scope of the function and the FUNCTION_DECL.  See\n-     is_body_block in stmt.c, and its callers.  */\n-  bool no_body_blocks;\n-\n   /* The front end can add its own statistics to -fmem-report with\n      this hook.  It should output to stderr.  */\n   void (*print_statistics) (void);"}, {"sha": "96e63fa88f1c323038bc612bb9febe291a1fd43e", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -1724,38 +1724,6 @@ expand_return (tree retval)\n     }\n }\n \f\n-/* Given a pointer to a BLOCK node return nonzero if (and only if) the node\n-   in question represents the outermost pair of curly braces (i.e. the \"body\n-   block\") of a function or method.\n-\n-   For any BLOCK node representing a \"body block\" of a function or method, the\n-   BLOCK_SUPERCONTEXT of the node will point to another BLOCK node which\n-   represents the outermost (function) scope for the function or method (i.e.\n-   the one which includes the formal parameters).  The BLOCK_SUPERCONTEXT of\n-   *that* node in turn will point to the relevant FUNCTION_DECL node.  */\n-\n-int\n-is_body_block (const_tree stmt)\n-{\n-  if (lang_hooks.no_body_blocks)\n-    return 0;\n-\n-  if (TREE_CODE (stmt) == BLOCK)\n-    {\n-      tree parent = BLOCK_SUPERCONTEXT (stmt);\n-\n-      if (parent && TREE_CODE (parent) == BLOCK)\n-\t{\n-\t  tree grandparent = BLOCK_SUPERCONTEXT (parent);\n-\n-\t  if (grandparent && TREE_CODE (grandparent) == FUNCTION_DECL)\n-\t    return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n /* Emit code to restore vital registers at the beginning of a nonlocal goto\n    handler.  */\n static void"}, {"sha": "5632a8930bccda2d1c1cd89c98dc777ed2a4aca7", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -221,6 +221,11 @@ execute_build_cfg (void)\n \n   build_gimple_cfg (body);\n   gimple_set_body (current_function_decl, NULL);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Scope blocks:\\n\");\n+      dump_scope_blocks (dump_file, dump_flags);\n+    }\n   return 0;\n }\n "}, {"sha": "3bedd3584283f2ab857d06d6a4faf535e2f02b68", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -1153,6 +1153,7 @@ void compute_call_used_vars (void);\n \n /* In tree-ssa-live.c */\n extern void remove_unused_locals (void);\n+extern void dump_scope_blocks (FILE *, int);\n \n /* In tree-ssa-address.c  */\n "}, {"sha": "15166cc8f5e91d951d2d1e0672a8920833fc769c", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -541,8 +541,13 @@ remove_unused_scope_block_p (tree scope)\n \t  {\n \t    tree next = BLOCK_CHAIN (*t);\n \t    tree supercontext = BLOCK_SUPERCONTEXT (*t);\n+\n \t    *t = BLOCK_SUBBLOCKS (*t);\n-\t    gcc_assert (!BLOCK_CHAIN (*t));\n+\t    while (BLOCK_CHAIN (*t))\n+\t      {\n+\t        BLOCK_SUPERCONTEXT (*t) = supercontext;\n+\t        t = &BLOCK_CHAIN (*t);\n+\t      }\n \t    BLOCK_CHAIN (*t) = next;\n \t    BLOCK_SUPERCONTEXT (*t) = supercontext;\n \t    t = &BLOCK_CHAIN (*t);\n@@ -556,23 +561,40 @@ remove_unused_scope_block_p (tree scope)\n         t = &BLOCK_CHAIN (*t);\n \tnsubblocks ++;\n       }\n+\n+\n+   if (!unused)\n+     ;\n    /* Outer scope is always used.  */\n-   if (!BLOCK_SUPERCONTEXT (scope)\n-       || TREE_CODE (BLOCK_SUPERCONTEXT (scope)) == FUNCTION_DECL)\n+   else if (!BLOCK_SUPERCONTEXT (scope)\n+            || TREE_CODE (BLOCK_SUPERCONTEXT (scope)) == FUNCTION_DECL)\n+     unused = false;\n+   /* Innermost blocks with no live variables nor statements can be always\n+      eliminated.  */\n+   else if (!nsubblocks)\n+     ;\n+   /* If there are live subblocks and we still have some unused variables\n+      or types declared, we must keep them.\n+      Before inliing we must not depend on debug info verbosity to keep\n+      DECL_UIDs stable.  */\n+   else if (!cfun->after_inlining && BLOCK_VARS (scope))\n      unused = false;\n-   /* If there are more than one live subblocks, it is used.  */\n-   else if (nsubblocks > 1)\n+   /* For terse debug info we can eliminate info on unused variables.  */\n+   else if (debug_info_level == DINFO_LEVEL_NONE\n+\t    || debug_info_level == DINFO_LEVEL_TERSE)\n+     ;\n+   else if (BLOCK_VARS (scope))\n      unused = false;\n-   /* When there is only one subblock, see if it is just wrapper we can\n-      ignore.  Wrappers are not declaring any variables and not changing\n-      abstract origin.  */\n-   else if (nsubblocks == 1\n-\t    && (BLOCK_VARS (scope)\n-\t\t|| ((debug_info_level == DINFO_LEVEL_NORMAL\n-\t\t     || debug_info_level == DINFO_LEVEL_VERBOSE)\n-\t\t    && ((BLOCK_ABSTRACT_ORIGIN (scope)\n-\t\t\t!= BLOCK_ABSTRACT_ORIGIN (BLOCK_SUPERCONTEXT (scope)))))))\n+   /* See if this block is important for representation of inlined function.\n+      Inlined functions are always represented by block with\n+      block_ultimate_origin being set to FUNCTION_DECL and DECL_SOURCE_LOCATION\n+      set...  */\n+   else if (inlined_function_outer_scope_p (scope))\n      unused = false;\n+   else\n+   /* Verfify that only blocks with source location set\n+      are entry points to the inlined functions.  */\n+     gcc_assert (BLOCK_SOURCE_LOCATION (scope) == UNKNOWN_LOCATION);\n    return unused;\n }\n \n@@ -592,14 +614,27 @@ dump_scope_block (FILE *file, int indent, tree scope, int flags)\n {\n   tree var, t;\n \n-  fprintf (file, \"\\n%*sScope block #%i %s\\n\",indent, \"\" , BLOCK_NUMBER (scope),\n-  \t   TREE_USED (scope) ? \"\" : \"(unused)\");\n-  if (BLOCK_ABSTRACT_ORIGIN (scope) && DECL_P (block_ultimate_origin (scope)))\n+  fprintf (file, \"\\n%*s{ Scope block #%i%s%s\",indent, \"\" , BLOCK_NUMBER (scope),\n+  \t   TREE_USED (scope) ? \"\" : \" (unused)\",\n+\t   BLOCK_ABSTRACT (scope) ? \" (abstract)\": \"\");\n+  if (BLOCK_SOURCE_LOCATION (scope) != UNKNOWN_LOCATION)\n+    {\n+      expanded_location s = expand_location (BLOCK_SOURCE_LOCATION (scope));\n+      fprintf (file, \" %s:%i\", s.file, s.line);\n+    }\n+  if (BLOCK_ABSTRACT_ORIGIN (scope))\n     {\n-      fprintf (file, \"\\n%*sOriginating from \",indent + 1, \"\");\n-      print_generic_decl (file, block_ultimate_origin (scope), flags);\n-      fprintf (file, \"\\n\");\n+      tree origin = block_ultimate_origin (scope);\n+      if (origin)\n+\t{\n+\t  fprintf (file, \" Originating from :\");\n+\t  if (DECL_P (origin))\n+\t    print_generic_decl (file, origin, flags);\n+\t  else\n+\t    fprintf (file, \"#%i\", BLOCK_NUMBER (origin));\n+\t}\n     }\n+  fprintf (file, \" \\n\");\n   for (var = BLOCK_VARS (scope); var; var = TREE_CHAIN (var))\n     {\n       bool used = false;\n@@ -615,8 +650,14 @@ dump_scope_block (FILE *file, int indent, tree scope, int flags)\n     }\n   for (t = BLOCK_SUBBLOCKS (scope); t ; t = BLOCK_CHAIN (t))\n     dump_scope_block (file, indent + 2, t, flags);\n+  fprintf (file, \"\\n%*s}\\n\",indent, \"\");\n }\n \n+void\n+dump_scope_blocks (FILE *file, int flags)\n+{\n+  dump_scope_block (file, 0, DECL_INITIAL (current_function_decl), flags);\n+}\n \n /* Remove local variables that are not referenced in the IL.  */\n \n@@ -760,7 +801,7 @@ remove_unused_locals (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Scope blocks after cleanups:\\n\");\n-      dump_scope_block (dump_file, 0, DECL_INITIAL (current_function_decl), false);\n+      dump_scope_blocks (dump_file, dump_flags);\n     }\n }\n "}, {"sha": "1e86bf9bc61d5e7e9cc9cbfc4594608c0124de58", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7525fb078f60cffd2050f93eb7a257cf158a4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=cff7525fb078f60cffd2050f93eb7a257cf158a4", "patch": "@@ -1324,8 +1324,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \n /* Used in classes in C++.  */\n #define TREE_PRIVATE(NODE) ((NODE)->base.private_flag)\n-/* Used in classes in C++.\n-   In a BLOCK node, this is BLOCK_HANDLER_BLOCK.  */\n+/* Used in classes in C++. */\n #define TREE_PROTECTED(NODE) ((NODE)->base.protected_flag)\n \n /* Nonzero in a _DECL if the use of the name is defined as a\n@@ -1977,11 +1976,6 @@ struct varray_head_tag;\n #define BLOCK_ABSTRACT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.abstract_origin)\n #define BLOCK_ABSTRACT(NODE) (BLOCK_CHECK (NODE)->block.abstract_flag)\n \n-/* Nonzero means that this block is prepared to handle exceptions\n-   listed in the BLOCK_VARS slot.  */\n-#define BLOCK_HANDLER_BLOCK(NODE) \\\n-  (BLOCK_CHECK (NODE)->block.handler_block_flag)\n-\n /* An index number for this block.  These values are not guaranteed to\n    be unique across functions -- whether or not they are depends on\n    the debugging output format in use.  */\n@@ -2022,9 +2016,8 @@ struct tree_block GTY(())\n {\n   struct tree_common common;\n \n-  unsigned handler_block_flag : 1;\n   unsigned abstract_flag : 1;\n-  unsigned block_num : 30;\n+  unsigned block_num : 31;\n \n   location_t locus;\n \n@@ -4657,6 +4650,14 @@ function_args_iter_next (function_args_iterator *i)\n   i->next = TREE_CHAIN (i->next);\n }\n \n+/* We set BLOCK_SOURCE_LOCATION only to inlined function entry points.  */\n+\n+static inline bool\n+inlined_function_outer_scope_p (const_tree block)\n+{\n+ return BLOCK_SOURCE_LOCATION (block) != UNKNOWN_LOCATION;\n+}\n+\n /* Loop over all function arguments of FNTYPE.  In each iteration, PTR is set\n    to point to the next tree element.  ITER is an instance of\n    function_args_iterator used to iterate the arguments.  */\n@@ -4710,7 +4711,6 @@ extern void expand_goto (tree);\n extern rtx expand_stack_save (void);\n extern void expand_stack_restore (tree);\n extern void expand_return (tree);\n-extern int is_body_block (const_tree);\n \n /* In tree-eh.c */\n extern void using_eh_for_cleanups (void);"}]}