{"sha": "cfcbb4227fb20191e04eb8d7766ae6202f526afd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZjYmI0MjI3ZmIyMDE5MWUwNGViOGQ3NzY2YWU2MjAyZjUyNmFmZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-23T17:57:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-30T23:13:24Z"}, "message": "libgo: update to Go1.16beta1 release\n\nThis does not yet include support for the //go:embed directive added\nin this release.\n\n\t* Makefile.am (check-runtime): Don't create check-runtime-dir.\n\t(mostlyclean-local): Don't remove check-runtime-dir.\n\t(check-go-tool, check-vet): Copy in go.mod and modules.txt.\n\t(check-cgo-test, check-carchive-test): Add go.mod file.\n\t* Makefile.in: Regenerate.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/280172", "tree": {"sha": "e2effea96f6f204451779f044415c2385e45042b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2effea96f6f204451779f044415c2385e45042b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfcbb4227fb20191e04eb8d7766ae6202f526afd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfcbb4227fb20191e04eb8d7766ae6202f526afd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfcbb4227fb20191e04eb8d7766ae6202f526afd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfcbb4227fb20191e04eb8d7766ae6202f526afd/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0696141107d61483f38482b941549959a0d7f613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0696141107d61483f38482b941549959a0d7f613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0696141107d61483f38482b941549959a0d7f613"}], "stats": {"total": 98237, "additions": 67412, "deletions": 30825}, "files": [{"sha": "fc5ef4498dd815739746a18061c029533278f365", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -1,4 +1,4 @@\n-d67579759e1769c08148304b2d378ec0b05637d6\n+47bdc8bb36f16f9d1dec72df5dd6b45d7b0b0725\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3bbccb96c289bc1bc0bf9ac6c1a9f51eda824451", "filename": "gotools/Makefile.am", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -101,7 +101,7 @@ MOSTLYCLEANFILES = \\\n \n mostlyclean-local:\n \tif test -d check-go-dir; then chmod -R u+w check-go-dir; fi\n-\trm -rf check-go-dir check-runtime-dir cgo-test-dir carchive-test-dir \\\n+\trm -rf check-go-dir cgo-test-dir carchive-test-dir \\\n \tcheck-vet-dir gocache-test\n \n if NATIVE\n@@ -210,6 +210,11 @@ check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \tif test -d check-go-dir; then chmod -R u+w check-go-dir; fi\n \trm -rf check-go-dir cmd_go-testlog\n \t$(MKDIR_P) check-go-dir/src/cmd/go\n+\tcp $(libgosrcdir)/go.mod check-go-dir/src/\n+\tcp $(cmdsrcdir)/go.mod check-go-dir/src/cmd/\n+\t$(MKDIR_P) check-go-dir/src/vendor check-go-dir/src/cmd/vendor\n+\tcp $(libgosrcdir)/vendor/modules.txt check-go-dir/src/vendor/\n+\tcp $(libgosrcdir)/cmd/vendor/modules.txt check-go-dir/src/cmd/vendor/\n \tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n \tcp -r $(cmdsrcdir)/go/internal check-go-dir/src/cmd/go/\n \tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n@@ -234,8 +239,7 @@ check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n # but the runtime tests use the go tool heavily, so testing\n # here too will catch more problems.\n check-runtime: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n-\trm -rf check-runtime-dir runtime-testlog\n-\t$(MKDIR_P) check-runtime-dir\n+\trm -f runtime-testlog\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \tLD_LIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LD_LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n \texport LD_LIBRARY_PATH; \\\n@@ -256,6 +260,7 @@ check-runtime: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n check-cgo-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf cgo-test-dir cgo-testlog\n \t$(MKDIR_P) cgo-test-dir/misc/cgo\n+\techo 'module misc' > cgo-test-dir/misc/go.mod\n \tcp -r $(libgomiscdir)/cgo/test cgo-test-dir/misc/cgo/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \techo \"cd cgo-test-dir/misc/cgo/test && $(ECHO_ENV) GOTRACEBACK=2 $(abs_builddir)/go$(EXEEXT) test -test.short -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > cgo-testlog\n@@ -270,6 +275,7 @@ check-cgo-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf carchive-test-dir carchive-testlog\n \t$(MKDIR_P) carchive-test-dir/misc/cgo\n+\techo 'module misc' > carchive-test-dir/misc/go.mod\n \tcp -r $(libgomiscdir)/cgo/testcarchive carchive-test-dir/misc/cgo/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \techo \"cd carchive-test-dir/misc/cgo/testcarchive && $(ECHO_ENV) LIBRARY_PATH=`echo $${abs_libgodir}/.libs` $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > carchive-testlog\n@@ -283,6 +289,11 @@ check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check\n check-vet: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf check-vet-dir cmd_vet-testlog\n \t$(MKDIR_P) check-vet-dir/src/cmd/internal check-vet-dir/src/cmd/vendor/golang.org/x\n+\tcp $(libgosrcdir)/go.mod check-vet-dir/src/\n+\tcp $(cmdsrcdir)/go.mod check-vet-dir/src/cmd/\n+\t$(MKDIR_P) check-vet-dir/src/vendor check-vet-dir/src/cmd/vendor\n+\tcp $(libgosrcdir)/vendor/modules.txt check-vet-dir/src/vendor/\n+\tcp $(libgosrcdir)/cmd/vendor/modules.txt check-vet-dir/src/cmd/vendor/\n \tcp -r $(cmdsrcdir)/vet check-vet-dir/src/cmd/\n \tcp -r $(cmdsrcdir)/internal/objabi check-vet-dir/src/cmd/internal\n \tcp $(libgodir)/objabi.go check-vet-dir/src/cmd/internal/objabi/"}, {"sha": "f440a0b301abe8c2df0ae133181d73b13b77ce98", "filename": "gotools/Makefile.in", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -703,8 +703,8 @@ distclean-generic:\n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n \t@echo \"it deletes files that may require special tools to rebuild.\"\n-@NATIVE_FALSE@uninstall-local:\n @NATIVE_FALSE@install-exec-local:\n+@NATIVE_FALSE@uninstall-local:\n clean: clean-am\n \n clean-am: clean-binPROGRAMS clean-generic clean-noinstPROGRAMS \\\n@@ -814,7 +814,7 @@ s-zdefaultcc: Makefile\n \n mostlyclean-local:\n \tif test -d check-go-dir; then chmod -R u+w check-go-dir; fi\n-\trm -rf check-go-dir check-runtime-dir cgo-test-dir carchive-test-dir \\\n+\trm -rf check-go-dir cgo-test-dir carchive-test-dir \\\n \tcheck-vet-dir gocache-test\n \n @NATIVE_TRUE@go$(EXEEXT): $(go_cmd_go_files) $(LIBGOTOOL) $(LIBGODEP)\n@@ -881,6 +881,11 @@ mostlyclean-local:\n @NATIVE_TRUE@\tif test -d check-go-dir; then chmod -R u+w check-go-dir; fi\n @NATIVE_TRUE@\trm -rf check-go-dir cmd_go-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) check-go-dir/src/cmd/go\n+@NATIVE_TRUE@\tcp $(libgosrcdir)/go.mod check-go-dir/src/\n+@NATIVE_TRUE@\tcp $(cmdsrcdir)/go.mod check-go-dir/src/cmd/\n+@NATIVE_TRUE@\t$(MKDIR_P) check-go-dir/src/vendor check-go-dir/src/cmd/vendor\n+@NATIVE_TRUE@\tcp $(libgosrcdir)/vendor/modules.txt check-go-dir/src/vendor/\n+@NATIVE_TRUE@\tcp $(libgosrcdir)/cmd/vendor/modules.txt check-go-dir/src/cmd/vendor/\n @NATIVE_TRUE@\tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/go/internal check-go-dir/src/cmd/go/\n @NATIVE_TRUE@\tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n@@ -905,8 +910,7 @@ mostlyclean-local:\n # but the runtime tests use the go tool heavily, so testing\n # here too will catch more problems.\n @NATIVE_TRUE@check-runtime: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n-@NATIVE_TRUE@\trm -rf check-runtime-dir runtime-testlog\n-@NATIVE_TRUE@\t$(MKDIR_P) check-runtime-dir\n+@NATIVE_TRUE@\trm -f runtime-testlog\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\tLD_LIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LD_LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n @NATIVE_TRUE@\texport LD_LIBRARY_PATH; \\\n@@ -927,6 +931,7 @@ mostlyclean-local:\n @NATIVE_TRUE@check-cgo-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf cgo-test-dir cgo-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) cgo-test-dir/misc/cgo\n+@NATIVE_TRUE@\techo 'module misc' > cgo-test-dir/misc/go.mod\n @NATIVE_TRUE@\tcp -r $(libgomiscdir)/cgo/test cgo-test-dir/misc/cgo/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\techo \"cd cgo-test-dir/misc/cgo/test && $(ECHO_ENV) GOTRACEBACK=2 $(abs_builddir)/go$(EXEEXT) test -test.short -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > cgo-testlog\n@@ -941,6 +946,7 @@ mostlyclean-local:\n @NATIVE_TRUE@check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf carchive-test-dir carchive-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) carchive-test-dir/misc/cgo\n+@NATIVE_TRUE@\techo 'module misc' > carchive-test-dir/misc/go.mod\n @NATIVE_TRUE@\tcp -r $(libgomiscdir)/cgo/testcarchive carchive-test-dir/misc/cgo/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\techo \"cd carchive-test-dir/misc/cgo/testcarchive && $(ECHO_ENV) LIBRARY_PATH=`echo $${abs_libgodir}/.libs` $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > carchive-testlog\n@@ -954,6 +960,11 @@ mostlyclean-local:\n @NATIVE_TRUE@check-vet: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf check-vet-dir cmd_vet-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) check-vet-dir/src/cmd/internal check-vet-dir/src/cmd/vendor/golang.org/x\n+@NATIVE_TRUE@\tcp $(libgosrcdir)/go.mod check-vet-dir/src/\n+@NATIVE_TRUE@\tcp $(cmdsrcdir)/go.mod check-vet-dir/src/cmd/\n+@NATIVE_TRUE@\t$(MKDIR_P) check-vet-dir/src/vendor check-vet-dir/src/cmd/vendor\n+@NATIVE_TRUE@\tcp $(libgosrcdir)/vendor/modules.txt check-vet-dir/src/vendor/\n+@NATIVE_TRUE@\tcp $(libgosrcdir)/cmd/vendor/modules.txt check-vet-dir/src/cmd/vendor/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/vet check-vet-dir/src/cmd/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/internal/objabi check-vet-dir/src/cmd/internal\n @NATIVE_TRUE@\tcp $(libgodir)/objabi.go check-vet-dir/src/cmd/internal/objabi/"}, {"sha": "c5546950b8bceefce5008ca557728bbedfbf6e3b", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -1,4 +1,4 @@\n-9b955d2d3fcff6a5bc8bce7bafdc4c634a28e95b\n+2ff33f5e443165e55a080f3a649e4c070c4096d1\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "2e8c37e170d38966a83a60f0b97a3635a8ada81c", "filename": "libgo/Makefile.am", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -775,6 +775,7 @@ libgo_go_objs = \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n+\tos/dir_gccgo_c.lo \\\n \t$(golangorg_x_net_lif_lo) \\\n \t$(golangorg_x_net_route_lo) \\\n \tlog/syslog/syslog_c.lo \\\n@@ -1062,6 +1063,7 @@ extra_go_files_os_user = os_user_linknames.go\n os/user.lo.dep: $(extra_go_files_os_user)\n \n extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_fsys = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n@@ -1075,10 +1077,14 @@ extra_check_libs_cmd_go_internal_modload = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_module = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_mvs = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_search = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_str = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_test = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_vcs = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_web2 = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n \n+extra_check_libs_cmd_internal_buildid = $(abs_builddir)/libgotool.a\n+\n extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n \n # FIXME: The following C files may as well move to the runtime\n@@ -1122,6 +1128,11 @@ syscall/wait.lo: go/syscall/wait.c runtime.inc\n \t@$(MKDIR_P) syscall\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/syscall/wait.c\n \n+# An os function is written in C.\n+os/dir_gccgo_c.lo: go/os/dir_gccgo_c.c runtime.inc\n+\t@$(MKDIR_P) os\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/os/dir_gccgo_c.c\n+\n # internal/cpu needs some C code.\n internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n \t@$(MKDIR_P) internal/cpu"}, {"sha": "34b0e1d0056adfbc60bb295cb32f247467bfc28b", "filename": "libgo/Makefile.in", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -224,7 +224,7 @@ LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_3 = $(addsuffix .lo,$(PACKAGES)) \\\n \tinternal/bytealg/bytealg.lo reflect/makefunc_ffi_c.lo \\\n \t$(am__DEPENDENCIES_1) syscall/errno.lo syscall/signame.lo \\\n-\tsyscall/wait.lo $(golangorg_x_net_lif_lo) \\\n+\tsyscall/wait.lo os/dir_gccgo_c.lo $(golangorg_x_net_lif_lo) \\\n \t$(golangorg_x_net_route_lo) log/syslog/syslog_c.lo \\\n \truntime/internal/atomic_c.lo sync/atomic_c.lo \\\n \tinternal/cpu/cpu_gccgo.lo $(am__DEPENDENCIES_2)\n@@ -940,6 +940,7 @@ libgo_go_objs = \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n+\tos/dir_gccgo_c.lo \\\n \t$(golangorg_x_net_lif_lo) \\\n \t$(golangorg_x_net_route_lo) \\\n \tlog/syslog/syslog_c.lo \\\n@@ -1130,6 +1131,7 @@ extra_go_files_cmd_go_internal_cfg = zdefaultcc.go\n extra_go_files_os = os_linknames.go\n extra_go_files_os_user = os_user_linknames.go\n extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_fsys = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n@@ -1143,9 +1145,12 @@ extra_check_libs_cmd_go_internal_modload = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_module = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_mvs = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_search = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_str = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_test = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_vcs = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_web2 = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_internal_buildid = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n @HAVE_STAT_TIMESPEC_FALSE@@LIBGO_IS_SOLARIS_TRUE@matchargs_os = \n \n@@ -3009,6 +3014,11 @@ syscall/wait.lo: go/syscall/wait.c runtime.inc\n \t@$(MKDIR_P) syscall\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/syscall/wait.c\n \n+# An os function is written in C.\n+os/dir_gccgo_c.lo: go/os/dir_gccgo_c.c runtime.inc\n+\t@$(MKDIR_P) os\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/os/dir_gccgo_c.c\n+\n # internal/cpu needs some C code.\n internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n \t@$(MKDIR_P) internal/cpu"}, {"sha": "257f7ce59eccaacbd9c9d2d71f32179c10f6b353", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -1 +1 @@\n-go1.15.6\n+go1.16beta1"}, {"sha": "a0148cfccc419e026a6e5ebbd78337163b8819d3", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -3,6 +3,7 @@ archive/zip\n bufio\n bytes\n cmd/go/internal/cache\n+cmd/go/internal/fsys\n cmd/go/internal/generate\n cmd/go/internal/get\n cmd/go/internal/imports\n@@ -16,8 +17,10 @@ cmd/go/internal/modload\n cmd/go/internal/mvs\n cmd/go/internal/par\n cmd/go/internal/search\n+cmd/go/internal/str\n cmd/go/internal/test\n cmd/go/internal/txtar\n+cmd/go/internal/vcs\n cmd/go/internal/work\n cmd/internal/buildid\n cmd/internal/edit\n@@ -113,6 +116,7 @@ internal/trace\n internal/unsafeheader\n internal/xcoff\n io\n+io/fs\n io/ioutil\n log\n log/syslog\n@@ -155,6 +159,7 @@ runtime/debug\n runtime/internal/atomic\n runtime/internal/math\n runtime/internal/sys\n+runtime/metrics\n runtime/pprof\n runtime/trace\n sort\n@@ -164,6 +169,7 @@ sync\n sync/atomic\n syscall\n testing\n+testing/fstest\n testing/iotest\n testing/quick\n text/scanner"}, {"sha": "25b8ab8f9eea715534290d5bf7440d33709ec9e6", "filename": "libgo/config.h.in", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -36,6 +36,10 @@\n /* Define to 1 if you have the `cosl' function. */\n #undef HAVE_COSL\n \n+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n+   */\n+#undef HAVE_DIRENT_H\n+\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #undef HAVE_DLFCN_H\n \n@@ -159,6 +163,9 @@\n /* Define to 1 if you have the `mknodat' function. */\n #undef HAVE_MKNODAT\n \n+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */\n+#undef HAVE_NDIR_H\n+\n /* Define to 1 if you have the <netinet/icmp6.h> header file. */\n #undef HAVE_NETINET_ICMP6_H\n \n@@ -249,6 +256,9 @@\n /* Define to 1 if you have the `strsignal' function. */\n #undef HAVE_STRSIGNAL\n \n+/* Define to 1 if `d_type' is a member of `struct dirent'. */\n+#undef HAVE_STRUCT_DIRENT_D_TYPE\n+\n /* Define to 1 if <math.h> defines struct exception */\n #undef HAVE_STRUCT_EXCEPTION\n \n@@ -261,6 +271,10 @@\n /* Define to 1 if you have the <syscall.h> header file. */\n #undef HAVE_SYSCALL_H\n \n+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.\n+   */\n+#undef HAVE_SYS_DIR_H\n+\n /* Define to 1 if you have the <sys/epoll.h> header file. */\n #undef HAVE_SYS_EPOLL_H\n \n@@ -279,6 +293,10 @@\n /* Define to 1 if you have the <sys/mount.h> header file. */\n #undef HAVE_SYS_MOUNT_H\n \n+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.\n+   */\n+#undef HAVE_SYS_NDIR_H\n+\n /* Define to 1 if you have the <sys/prctl.h> header file. */\n #undef HAVE_SYS_PRCTL_H\n "}, {"sha": "c1956d81a2005f976234d906a2f3371c5569633b", "filename": "libgo/configure", "status": "modified", "additions": 250, "deletions": 4, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -1956,6 +1956,63 @@ fi\n \n } # ac_fn_c_check_header_mongrel\n \n+# ac_fn_c_check_member LINENO AGGR MEMBER VAR INCLUDES\n+# ----------------------------------------------------\n+# Tries to find if the field MEMBER exists in type AGGR, after including\n+# INCLUDES, setting cache variable VAR accordingly.\n+ac_fn_c_check_member ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2.$3\" >&5\n+$as_echo_n \"checking for $2.$3... \" >&6; }\n+if eval \\${$4+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$5\n+int\n+main ()\n+{\n+static $2 ac_aggr;\n+if (ac_aggr.$3)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$4=yes\"\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$5\n+int\n+main ()\n+{\n+static $2 ac_aggr;\n+if (sizeof ac_aggr.$3)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$4=yes\"\n+else\n+  eval \"$4=no\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+eval ac_res=\\$$4\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n+\n+} # ac_fn_c_check_member\n+\n # ac_fn_c_check_type LINENO TYPE VAR INCLUDES\n # -------------------------------------------\n # Tests whether TYPE exists after having included INCLUDES, setting cache\n@@ -2551,7 +2608,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=18:0:0\n+libtool_VERSION=19:0:0\n \n \n # Default to --enable-multilib\n@@ -11497,7 +11554,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11500 \"configure\"\n+#line 11557 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11603,7 +11660,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11606 \"configure\"\n+#line 11663 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13923,7 +13980,7 @@ go_include=\"-include\"\n # All known GOOS values.  This is the union of all operating systems\n # supported by the gofrontend and all operating systems supported by\n # the gc toolchain.\n-ALLGOOS=\"aix android darwin dragonfly freebsd hurd illumos irix js linux netbsd openbsd plan9 rtems solaris windows\"\n+ALLGOOS=\"aix android darwin dragonfly freebsd hurd illumos ios irix js linux netbsd openbsd plan9 rtems solaris windows zos\"\n \n is_darwin=no\n is_freebsd=no\n@@ -15287,6 +15344,195 @@ else\n fi\n \n \n+ac_header_dirent=no\n+for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do\n+  as_ac_Header=`$as_echo \"ac_cv_header_dirent_$ac_hdr\" | $as_tr_sh`\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_hdr that defines DIR\" >&5\n+$as_echo_n \"checking for $ac_hdr that defines DIR... \" >&6; }\n+if eval \\${$as_ac_Header+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <sys/types.h>\n+#include <$ac_hdr>\n+\n+int\n+main ()\n+{\n+if ((DIR *) 0)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$as_ac_Header=yes\"\n+else\n+  eval \"$as_ac_Header=no\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+eval ac_res=\\$$as_ac_Header\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+if eval test \\\"x\\$\"$as_ac_Header\"\\\" = x\"yes\"; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_hdr\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+ac_header_dirent=$ac_hdr; break\n+fi\n+\n+done\n+# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.\n+if test $ac_header_dirent = dirent.h; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing opendir\" >&5\n+$as_echo_n \"checking for library containing opendir... \" >&6; }\n+if ${ac_cv_search_opendir+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_func_search_save_LIBS=$LIBS\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char opendir ();\n+int\n+main ()\n+{\n+return opendir ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+for ac_lib in '' dir; do\n+  if test -z \"$ac_lib\"; then\n+    ac_res=\"none required\"\n+  else\n+    ac_res=-l$ac_lib\n+    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n+  fi\n+  if ac_fn_c_try_link \"$LINENO\"; then :\n+  ac_cv_search_opendir=$ac_res\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext\n+  if ${ac_cv_search_opendir+:} false; then :\n+  break\n+fi\n+done\n+if ${ac_cv_search_opendir+:} false; then :\n+\n+else\n+  ac_cv_search_opendir=no\n+fi\n+rm conftest.$ac_ext\n+LIBS=$ac_func_search_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_opendir\" >&5\n+$as_echo \"$ac_cv_search_opendir\" >&6; }\n+ac_res=$ac_cv_search_opendir\n+if test \"$ac_res\" != no; then :\n+  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n+\n+fi\n+\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing opendir\" >&5\n+$as_echo_n \"checking for library containing opendir... \" >&6; }\n+if ${ac_cv_search_opendir+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_func_search_save_LIBS=$LIBS\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char opendir ();\n+int\n+main ()\n+{\n+return opendir ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+for ac_lib in '' x; do\n+  if test -z \"$ac_lib\"; then\n+    ac_res=\"none required\"\n+  else\n+    ac_res=-l$ac_lib\n+    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n+  fi\n+  if ac_fn_c_try_link \"$LINENO\"; then :\n+  ac_cv_search_opendir=$ac_res\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext\n+  if ${ac_cv_search_opendir+:} false; then :\n+  break\n+fi\n+done\n+if ${ac_cv_search_opendir+:} false; then :\n+\n+else\n+  ac_cv_search_opendir=no\n+fi\n+rm conftest.$ac_ext\n+LIBS=$ac_func_search_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_opendir\" >&5\n+$as_echo \"$ac_cv_search_opendir\" >&6; }\n+ac_res=$ac_cv_search_opendir\n+if test \"$ac_res\" != no; then :\n+  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n+\n+fi\n+\n+fi\n+\n+\n+\n+  ac_fn_c_check_member \"$LINENO\" \"struct dirent\" \"d_type\" \"ac_cv_member_struct_dirent_d_type\" \"\n+#include <sys/types.h>\n+#ifdef HAVE_DIRENT_H\n+# include <dirent.h>\n+#else\n+# define dirent direct\n+# ifdef HAVE_SYS_NDIR_H\n+#  include <sys/ndir.h>\n+# endif\n+# ifdef HAVE_SYS_DIR_H\n+#  include <sys/dir.h>\n+# endif\n+# ifdef HAVE_NDIR_H\n+#  include <ndir.h>\n+# endif\n+#endif\n+\n+\"\n+if test \"x$ac_cv_member_struct_dirent_d_type\" = xyes; then :\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_STRUCT_DIRENT_D_TYPE 1\n+_ACEOF\n+\n+\n+fi\n+\n+\n+\n for ac_func in accept4 dup3 epoll_create1 faccessat fallocate fchmodat fchownat futimesat getxattr inotify_add_watch inotify_init inotify_init1 inotify_rm_watch listxattr mkdirat mknodat open64 openat pipe2 removexattr renameat setxattr sync_file_range splice syscall tee unlinkat unshare utimensat\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`"}, {"sha": "ebab9d9de3e2d50695929f8ba7a8672919715909", "filename": "libgo/configure.ac", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,7 +10,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=18:0:0\n+libtool_VERSION=19:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)\n@@ -167,7 +167,7 @@ AC_SUBST(go_include)\n # All known GOOS values.  This is the union of all operating systems\n # supported by the gofrontend and all operating systems supported by\n # the gc toolchain.\n-ALLGOOS=\"aix android darwin dragonfly freebsd hurd illumos irix js linux netbsd openbsd plan9 rtems solaris windows\"\n+ALLGOOS=\"aix android darwin dragonfly freebsd hurd illumos ios irix js linux netbsd openbsd plan9 rtems solaris windows zos\"\n \n is_darwin=no\n is_freebsd=no\n@@ -598,6 +598,8 @@ AC_CHECK_FUNCS(strerror_r strsignal wait4 mincore setenv unsetenv dl_iterate_phd\n AM_CONDITIONAL(HAVE_STRERROR_R, test \"$ac_cv_func_strerror_r\" = yes)\n AM_CONDITIONAL(HAVE_WAIT4, test \"$ac_cv_func_wait4\" = yes)\n \n+AC_STRUCT_DIRENT_D_TYPE\n+\n AC_CHECK_FUNCS(accept4 dup3 epoll_create1 faccessat fallocate fchmodat fchownat futimesat getxattr inotify_add_watch inotify_init inotify_init1 inotify_rm_watch listxattr mkdirat mknodat open64 openat pipe2 removexattr renameat setxattr sync_file_range splice syscall tee unlinkat unshare utimensat)\n AC_TYPE_OFF_T\n AC_CHECK_TYPES([loff_t])"}, {"sha": "c667cfc8720b5b9db1a72184bd9fb42461916ec0", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -13,8 +13,8 @@ package tar\n import (\n \t\"errors\"\n \t\"fmt\"\n+\t\"io/fs\"\n \t\"math\"\n-\t\"os\"\n \t\"path\"\n \t\"reflect\"\n \t\"strconv\"\n@@ -525,12 +525,12 @@ func (h Header) allowedFormats() (format Format, paxHdrs map[string]string, err\n \treturn format, paxHdrs, err\n }\n \n-// FileInfo returns an os.FileInfo for the Header.\n-func (h *Header) FileInfo() os.FileInfo {\n+// FileInfo returns an fs.FileInfo for the Header.\n+func (h *Header) FileInfo() fs.FileInfo {\n \treturn headerFileInfo{h}\n }\n \n-// headerFileInfo implements os.FileInfo.\n+// headerFileInfo implements fs.FileInfo.\n type headerFileInfo struct {\n \th *Header\n }\n@@ -549,57 +549,57 @@ func (fi headerFileInfo) Name() string {\n }\n \n // Mode returns the permission and mode bits for the headerFileInfo.\n-func (fi headerFileInfo) Mode() (mode os.FileMode) {\n+func (fi headerFileInfo) Mode() (mode fs.FileMode) {\n \t// Set file permission bits.\n-\tmode = os.FileMode(fi.h.Mode).Perm()\n+\tmode = fs.FileMode(fi.h.Mode).Perm()\n \n \t// Set setuid, setgid and sticky bits.\n \tif fi.h.Mode&c_ISUID != 0 {\n-\t\tmode |= os.ModeSetuid\n+\t\tmode |= fs.ModeSetuid\n \t}\n \tif fi.h.Mode&c_ISGID != 0 {\n-\t\tmode |= os.ModeSetgid\n+\t\tmode |= fs.ModeSetgid\n \t}\n \tif fi.h.Mode&c_ISVTX != 0 {\n-\t\tmode |= os.ModeSticky\n+\t\tmode |= fs.ModeSticky\n \t}\n \n \t// Set file mode bits; clear perm, setuid, setgid, and sticky bits.\n-\tswitch m := os.FileMode(fi.h.Mode) &^ 07777; m {\n+\tswitch m := fs.FileMode(fi.h.Mode) &^ 07777; m {\n \tcase c_ISDIR:\n-\t\tmode |= os.ModeDir\n+\t\tmode |= fs.ModeDir\n \tcase c_ISFIFO:\n-\t\tmode |= os.ModeNamedPipe\n+\t\tmode |= fs.ModeNamedPipe\n \tcase c_ISLNK:\n-\t\tmode |= os.ModeSymlink\n+\t\tmode |= fs.ModeSymlink\n \tcase c_ISBLK:\n-\t\tmode |= os.ModeDevice\n+\t\tmode |= fs.ModeDevice\n \tcase c_ISCHR:\n-\t\tmode |= os.ModeDevice\n-\t\tmode |= os.ModeCharDevice\n+\t\tmode |= fs.ModeDevice\n+\t\tmode |= fs.ModeCharDevice\n \tcase c_ISSOCK:\n-\t\tmode |= os.ModeSocket\n+\t\tmode |= fs.ModeSocket\n \t}\n \n \tswitch fi.h.Typeflag {\n \tcase TypeSymlink:\n-\t\tmode |= os.ModeSymlink\n+\t\tmode |= fs.ModeSymlink\n \tcase TypeChar:\n-\t\tmode |= os.ModeDevice\n-\t\tmode |= os.ModeCharDevice\n+\t\tmode |= fs.ModeDevice\n+\t\tmode |= fs.ModeCharDevice\n \tcase TypeBlock:\n-\t\tmode |= os.ModeDevice\n+\t\tmode |= fs.ModeDevice\n \tcase TypeDir:\n-\t\tmode |= os.ModeDir\n+\t\tmode |= fs.ModeDir\n \tcase TypeFifo:\n-\t\tmode |= os.ModeNamedPipe\n+\t\tmode |= fs.ModeNamedPipe\n \t}\n \n \treturn mode\n }\n \n // sysStat, if non-nil, populates h from system-dependent fields of fi.\n-var sysStat func(fi os.FileInfo, h *Header) error\n+var sysStat func(fi fs.FileInfo, h *Header) error\n \n const (\n \t// Mode constants from the USTAR spec:\n@@ -623,10 +623,10 @@ const (\n // If fi describes a symlink, FileInfoHeader records link as the link target.\n // If fi describes a directory, a slash is appended to the name.\n //\n-// Since os.FileInfo's Name method only returns the base name of\n+// Since fs.FileInfo's Name method only returns the base name of\n // the file it describes, it may be necessary to modify Header.Name\n // to provide the full path name of the file.\n-func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n+func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error) {\n \tif fi == nil {\n \t\treturn nil, errors.New(\"archive/tar: FileInfo is nil\")\n \t}\n@@ -643,29 +643,29 @@ func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n \tcase fi.IsDir():\n \t\th.Typeflag = TypeDir\n \t\th.Name += \"/\"\n-\tcase fm&os.ModeSymlink != 0:\n+\tcase fm&fs.ModeSymlink != 0:\n \t\th.Typeflag = TypeSymlink\n \t\th.Linkname = link\n-\tcase fm&os.ModeDevice != 0:\n-\t\tif fm&os.ModeCharDevice != 0 {\n+\tcase fm&fs.ModeDevice != 0:\n+\t\tif fm&fs.ModeCharDevice != 0 {\n \t\t\th.Typeflag = TypeChar\n \t\t} else {\n \t\t\th.Typeflag = TypeBlock\n \t\t}\n-\tcase fm&os.ModeNamedPipe != 0:\n+\tcase fm&fs.ModeNamedPipe != 0:\n \t\th.Typeflag = TypeFifo\n-\tcase fm&os.ModeSocket != 0:\n+\tcase fm&fs.ModeSocket != 0:\n \t\treturn nil, fmt.Errorf(\"archive/tar: sockets not supported\")\n \tdefault:\n \t\treturn nil, fmt.Errorf(\"archive/tar: unknown file mode %v\", fm)\n \t}\n-\tif fm&os.ModeSetuid != 0 {\n+\tif fm&fs.ModeSetuid != 0 {\n \t\th.Mode |= c_ISUID\n \t}\n-\tif fm&os.ModeSetgid != 0 {\n+\tif fm&fs.ModeSetgid != 0 {\n \t\th.Mode |= c_ISGID\n \t}\n-\tif fm&os.ModeSticky != 0 {\n+\tif fm&fs.ModeSticky != 0 {\n \t\th.Mode |= c_ISVTX\n \t}\n \t// If possible, populate additional fields from OS-specific"}, {"sha": "1b1d5b46891b6bc972ed6bd9bfb1efc63eef1433", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,7 +7,6 @@ package tar\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n@@ -104,7 +103,7 @@ func (tr *Reader) next() (*Header, error) {\n \t\t\tcontinue // This is a meta header affecting the next header\n \t\tcase TypeGNULongName, TypeGNULongLink:\n \t\t\tformat.mayOnlyBe(FormatGNU)\n-\t\t\trealname, err := ioutil.ReadAll(tr)\n+\t\t\trealname, err := io.ReadAll(tr)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n@@ -294,7 +293,7 @@ func mergePAX(hdr *Header, paxHdrs map[string]string) (err error) {\n // parsePAX parses PAX headers.\n // If an extended header (type 'x') is invalid, ErrHeader is returned\n func parsePAX(r io.Reader) (map[string]string, error) {\n-\tbuf, err := ioutil.ReadAll(r)\n+\tbuf, err := io.ReadAll(r)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -850,7 +849,7 @@ func discard(r io.Reader, n int64) error {\n \t\t}\n \t}\n \n-\tcopySkipped, err := io.CopyN(ioutil.Discard, r, n-seekSkipped)\n+\tcopySkipped, err := io.CopyN(io.Discard, r, n-seekSkipped)\n \tif err == io.EOF && seekSkipped+copySkipped < n {\n \t\terr = io.ErrUnexpectedEOF\n \t}"}, {"sha": "789ddc1bc0345ae95058f6fafa7311b54c5f6c25", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"math\"\n \t\"os\"\n \t\"path\"\n@@ -773,7 +772,7 @@ func TestReadTruncation(t *testing.T) {\n \t\t\"testdata/pax-path-hdr.tar\",\n \t\t\"testdata/sparse-formats.tar\",\n \t} {\n-\t\tbuf, err := ioutil.ReadFile(p)\n+\t\tbuf, err := os.ReadFile(p)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"unexpected error: %v\", err)\n \t\t}\n@@ -865,7 +864,7 @@ func TestReadTruncation(t *testing.T) {\n \t\t\t\t}\n \t\t\t\tcnt++\n \t\t\t\tif s2 == \"manual\" {\n-\t\t\t\t\tif _, err = tr.writeTo(ioutil.Discard); err != nil {\n+\t\t\t\t\tif _, err = tr.writeTo(io.Discard); err != nil {\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}"}, {"sha": "93a3fcd60e972c7a9c1bba686fb8dbab9a206fc8", "filename": "libgo/go/archive/tar/stat_unix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,7 +7,7 @@\n package tar\n \n import (\n-\t\"os\"\n+\t\"io/fs\"\n \t\"os/user\"\n \t\"runtime\"\n \t\"strconv\"\n@@ -23,7 +23,7 @@ func init() {\n // The downside is that renaming uname or gname by the OS never takes effect.\n var userMap, groupMap sync.Map // map[int]string\n \n-func statUnix(fi os.FileInfo, h *Header) error {\n+func statUnix(fi fs.FileInfo, h *Header) error {\n \tsys, ok := fi.Sys().(*syscall.Stat_t)\n \tif !ok {\n \t\treturn nil\n@@ -71,7 +71,7 @@ func statUnix(fi os.FileInfo, h *Header) error {\n \t\t\tminor := uint32((dev & 0x00000000000000ff) >> 0)\n \t\t\tminor |= uint32((dev & 0x00000ffffff00000) >> 12)\n \t\t\th.Devmajor, h.Devminor = int64(major), int64(minor)\n-\t\tcase \"darwin\":\n+\t\tcase \"darwin\", \"ios\":\n \t\t\t// Copied from golang.org/x/sys/unix/dev_darwin.go.\n \t\t\tmajor := uint32((dev >> 24) & 0xff)\n \t\t\tminor := uint32(dev & 0xffffff)"}, {"sha": "91b38401b6c1030f05b81caabb5ac19faa271d25", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"fmt\"\n \t\"internal/testenv\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"math\"\n \t\"os\"\n \t\"path\"\n@@ -262,7 +262,7 @@ func TestFileInfoHeaderDir(t *testing.T) {\n func TestFileInfoHeaderSymlink(t *testing.T) {\n \ttestenv.MustHaveSymlink(t)\n \n-\ttmpdir, err := ioutil.TempDir(\"\", \"TestFileInfoHeaderSymlink\")\n+\ttmpdir, err := os.MkdirTemp(\"\", \"TestFileInfoHeaderSymlink\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -327,7 +327,7 @@ func TestRoundTrip(t *testing.T) {\n \tif !reflect.DeepEqual(rHdr, hdr) {\n \t\tt.Errorf(\"Header mismatch.\\n got %+v\\nwant %+v\", rHdr, hdr)\n \t}\n-\trData, err := ioutil.ReadAll(tr)\n+\trData, err := io.ReadAll(tr)\n \tif err != nil {\n \t\tt.Fatalf(\"Read: %v\", err)\n \t}\n@@ -338,7 +338,7 @@ func TestRoundTrip(t *testing.T) {\n \n type headerRoundTripTest struct {\n \th  *Header\n-\tfm os.FileMode\n+\tfm fs.FileMode\n }\n \n func TestHeaderRoundTrip(t *testing.T) {\n@@ -361,7 +361,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tModTime:  time.Unix(1360600852, 0),\n \t\t\tTypeflag: TypeSymlink,\n \t\t},\n-\t\tfm: 0777 | os.ModeSymlink,\n+\t\tfm: 0777 | fs.ModeSymlink,\n \t}, {\n \t\t// character device node.\n \t\th: &Header{\n@@ -371,7 +371,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tModTime:  time.Unix(1360578951, 0),\n \t\t\tTypeflag: TypeChar,\n \t\t},\n-\t\tfm: 0666 | os.ModeDevice | os.ModeCharDevice,\n+\t\tfm: 0666 | fs.ModeDevice | fs.ModeCharDevice,\n \t}, {\n \t\t// block device node.\n \t\th: &Header{\n@@ -381,7 +381,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tModTime:  time.Unix(1360578954, 0),\n \t\t\tTypeflag: TypeBlock,\n \t\t},\n-\t\tfm: 0660 | os.ModeDevice,\n+\t\tfm: 0660 | fs.ModeDevice,\n \t}, {\n \t\t// directory.\n \t\th: &Header{\n@@ -391,7 +391,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tModTime:  time.Unix(1360601116, 0),\n \t\t\tTypeflag: TypeDir,\n \t\t},\n-\t\tfm: 0755 | os.ModeDir,\n+\t\tfm: 0755 | fs.ModeDir,\n \t}, {\n \t\t// fifo node.\n \t\th: &Header{\n@@ -401,7 +401,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tModTime:  time.Unix(1360578949, 0),\n \t\t\tTypeflag: TypeFifo,\n \t\t},\n-\t\tfm: 0600 | os.ModeNamedPipe,\n+\t\tfm: 0600 | fs.ModeNamedPipe,\n \t}, {\n \t\t// setuid.\n \t\th: &Header{\n@@ -411,7 +411,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tModTime:  time.Unix(1355405093, 0),\n \t\t\tTypeflag: TypeReg,\n \t\t},\n-\t\tfm: 0755 | os.ModeSetuid,\n+\t\tfm: 0755 | fs.ModeSetuid,\n \t}, {\n \t\t// setguid.\n \t\th: &Header{\n@@ -421,7 +421,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tModTime:  time.Unix(1360602346, 0),\n \t\t\tTypeflag: TypeReg,\n \t\t},\n-\t\tfm: 0750 | os.ModeSetgid,\n+\t\tfm: 0750 | fs.ModeSetgid,\n \t}, {\n \t\t// sticky.\n \t\th: &Header{\n@@ -431,7 +431,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tModTime:  time.Unix(1360602540, 0),\n \t\t\tTypeflag: TypeReg,\n \t\t},\n-\t\tfm: 0600 | os.ModeSticky,\n+\t\tfm: 0600 | fs.ModeSticky,\n \t}, {\n \t\t// hard link.\n \t\th: &Header{\n@@ -804,9 +804,9 @@ func Benchmark(b *testing.B) {\n \t\t\tb.Run(v.label, func(b *testing.B) {\n \t\t\t\tb.ReportAllocs()\n \t\t\t\tfor i := 0; i < b.N; i++ {\n-\t\t\t\t\t// Writing to ioutil.Discard because we want to\n+\t\t\t\t\t// Writing to io.Discard because we want to\n \t\t\t\t\t// test purely the writer code and not bring in disk performance into this.\n-\t\t\t\t\ttw := NewWriter(ioutil.Discard)\n+\t\t\t\t\ttw := NewWriter(io.Discard)\n \t\t\t\t\tfor _, file := range v.files {\n \t\t\t\t\t\tif err := tw.WriteHeader(file.hdr); err != nil {\n \t\t\t\t\t\t\tb.Errorf(\"unexpected WriteHeader error: %v\", err)\n@@ -844,7 +844,7 @@ func Benchmark(b *testing.B) {\n \t\t\t\t\tif _, err := tr.Next(); err != nil {\n \t\t\t\t\t\tb.Errorf(\"unexpected Next error: %v\", err)\n \t\t\t\t\t}\n-\t\t\t\t\tif _, err := io.Copy(ioutil.Discard, tr); err != nil {\n+\t\t\t\t\tif _, err := io.Copy(io.Discard, tr); err != nil {\n \t\t\t\t\t\tb.Errorf(\"unexpected Copy error : %v\", err)\n \t\t\t\t\t}\n \t\t\t\t}"}, {"sha": "a00f02d8fab698a588872ade0e5693b0d0dc0660", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"encoding/hex\"\n \t\"errors\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n \t\"reflect\"\n@@ -520,7 +519,7 @@ func TestWriter(t *testing.T) {\n \t\t\t}\n \n \t\t\tif v.file != \"\" {\n-\t\t\t\twant, err := ioutil.ReadFile(v.file)\n+\t\t\t\twant, err := os.ReadFile(v.file)\n \t\t\t\tif err != nil {\n \t\t\t\t\tt.Fatalf(\"ReadFile() = %v, want nil\", err)\n \t\t\t\t}"}, {"sha": "8b4e77875fb3e69c93406372e17d94bb3f1b7d91", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -11,7 +11,12 @@ import (\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n+\t\"io/fs\"\n \t\"os\"\n+\t\"path\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"sync\"\n \t\"time\"\n )\n \n@@ -21,18 +26,28 @@ var (\n \tErrChecksum  = errors.New(\"zip: checksum error\")\n )\n \n+// A Reader serves content from a ZIP archive.\n type Reader struct {\n \tr             io.ReaderAt\n \tFile          []*File\n \tComment       string\n \tdecompressors map[uint16]Decompressor\n+\n+\t// fileList is a list of files sorted by ename,\n+\t// for use by the Open method.\n+\tfileListOnce sync.Once\n+\tfileList     []fileListEntry\n }\n \n+// A ReadCloser is a Reader that must be closed when no longer needed.\n type ReadCloser struct {\n \tf *os.File\n \tReader\n }\n \n+// A File is a single file in a ZIP archive.\n+// The file information is in the embedded FileHeader.\n+// The file content can be accessed by calling Open.\n type File struct {\n \tFileHeader\n \tzip          *Reader\n@@ -187,6 +202,10 @@ type checksumReader struct {\n \terr   error     // sticky error\n }\n \n+func (r *checksumReader) Stat() (fs.FileInfo, error) {\n+\treturn headerFileInfo{&r.f.FileHeader}, nil\n+}\n+\n func (r *checksumReader) Read(b []byte) (n int, err error) {\n \tif r.err != nil {\n \t\treturn 0, r.err\n@@ -607,3 +626,173 @@ func (b *readBuf) sub(n int) readBuf {\n \t*b = (*b)[n:]\n \treturn b2\n }\n+\n+// A fileListEntry is a File and its ename.\n+// If file == nil, the fileListEntry describes a directory, without metadata.\n+type fileListEntry struct {\n+\tname string\n+\tfile *File // nil for directories\n+}\n+\n+type fileInfoDirEntry interface {\n+\tfs.FileInfo\n+\tfs.DirEntry\n+}\n+\n+func (e *fileListEntry) stat() fileInfoDirEntry {\n+\tif e.file != nil {\n+\t\treturn headerFileInfo{&e.file.FileHeader}\n+\t}\n+\treturn e\n+}\n+\n+// Only used for directories.\n+func (f *fileListEntry) Name() string       { _, elem, _ := split(f.name); return elem }\n+func (f *fileListEntry) Size() int64        { return 0 }\n+func (f *fileListEntry) ModTime() time.Time { return time.Time{} }\n+func (f *fileListEntry) Mode() fs.FileMode  { return fs.ModeDir | 0555 }\n+func (f *fileListEntry) Type() fs.FileMode  { return fs.ModeDir }\n+func (f *fileListEntry) IsDir() bool        { return true }\n+func (f *fileListEntry) Sys() interface{}   { return nil }\n+\n+func (f *fileListEntry) Info() (fs.FileInfo, error) { return f, nil }\n+\n+// toValidName coerces name to be a valid name for fs.FS.Open.\n+func toValidName(name string) string {\n+\tname = strings.ReplaceAll(name, `\\`, `/`)\n+\tp := path.Clean(name)\n+\tif strings.HasPrefix(p, \"/\") {\n+\t\tp = p[len(\"/\"):]\n+\t}\n+\tfor strings.HasPrefix(name, \"../\") {\n+\t\tp = p[len(\"../\"):]\n+\t}\n+\treturn p\n+}\n+\n+func (r *Reader) initFileList() {\n+\tr.fileListOnce.Do(func() {\n+\t\tdirs := make(map[string]bool)\n+\t\tfor _, file := range r.File {\n+\t\t\tname := toValidName(file.Name)\n+\t\t\tfor dir := path.Dir(name); dir != \".\"; dir = path.Dir(dir) {\n+\t\t\t\tdirs[dir] = true\n+\t\t\t}\n+\t\t\tr.fileList = append(r.fileList, fileListEntry{name, file})\n+\t\t}\n+\t\tfor dir := range dirs {\n+\t\t\tr.fileList = append(r.fileList, fileListEntry{dir + \"/\", nil})\n+\t\t}\n+\n+\t\tsort.Slice(r.fileList, func(i, j int) bool { return fileEntryLess(r.fileList[i].name, r.fileList[j].name) })\n+\t})\n+}\n+\n+func fileEntryLess(x, y string) bool {\n+\txdir, xelem, _ := split(x)\n+\tydir, yelem, _ := split(y)\n+\treturn xdir < ydir || xdir == ydir && xelem < yelem\n+}\n+\n+// Open opens the named file in the ZIP archive,\n+// using the semantics of fs.FS.Open:\n+// paths are always slash separated, with no\n+// leading / or ../ elements.\n+func (r *Reader) Open(name string) (fs.File, error) {\n+\tr.initFileList()\n+\n+\te := r.openLookup(name)\n+\tif e == nil || !fs.ValidPath(name) {\n+\t\treturn nil, &fs.PathError{Op: \"open\", Path: name, Err: fs.ErrNotExist}\n+\t}\n+\tif e.file == nil || strings.HasSuffix(e.file.Name, \"/\") {\n+\t\treturn &openDir{e, r.openReadDir(name), 0}, nil\n+\t}\n+\trc, err := e.file.Open()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn rc.(fs.File), nil\n+}\n+\n+func split(name string) (dir, elem string, isDir bool) {\n+\tif name[len(name)-1] == '/' {\n+\t\tisDir = true\n+\t\tname = name[:len(name)-1]\n+\t}\n+\ti := len(name) - 1\n+\tfor i >= 0 && name[i] != '/' {\n+\t\ti--\n+\t}\n+\tif i < 0 {\n+\t\treturn \".\", name, isDir\n+\t}\n+\treturn name[:i], name[i+1:], isDir\n+}\n+\n+var dotFile = &fileListEntry{name: \"./\"}\n+\n+func (r *Reader) openLookup(name string) *fileListEntry {\n+\tif name == \".\" {\n+\t\treturn dotFile\n+\t}\n+\n+\tdir, elem, _ := split(name)\n+\tfiles := r.fileList\n+\ti := sort.Search(len(files), func(i int) bool {\n+\t\tidir, ielem, _ := split(files[i].name)\n+\t\treturn idir > dir || idir == dir && ielem >= elem\n+\t})\n+\tif i < len(files) {\n+\t\tfname := files[i].name\n+\t\tif fname == name || len(fname) == len(name)+1 && fname[len(name)] == '/' && fname[:len(name)] == name {\n+\t\t\treturn &files[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (r *Reader) openReadDir(dir string) []fileListEntry {\n+\tfiles := r.fileList\n+\ti := sort.Search(len(files), func(i int) bool {\n+\t\tidir, _, _ := split(files[i].name)\n+\t\treturn idir >= dir\n+\t})\n+\tj := sort.Search(len(files), func(j int) bool {\n+\t\tjdir, _, _ := split(files[j].name)\n+\t\treturn jdir > dir\n+\t})\n+\treturn files[i:j]\n+}\n+\n+type openDir struct {\n+\te      *fileListEntry\n+\tfiles  []fileListEntry\n+\toffset int\n+}\n+\n+func (d *openDir) Close() error               { return nil }\n+func (d *openDir) Stat() (fs.FileInfo, error) { return d.e.stat(), nil }\n+\n+func (d *openDir) Read([]byte) (int, error) {\n+\treturn 0, &fs.PathError{Op: \"read\", Path: d.e.name, Err: errors.New(\"is a directory\")}\n+}\n+\n+func (d *openDir) ReadDir(count int) ([]fs.DirEntry, error) {\n+\tn := len(d.files) - d.offset\n+\tif count > 0 && n > count {\n+\t\tn = count\n+\t}\n+\tif n == 0 {\n+\t\tif count <= 0 {\n+\t\t\treturn nil, nil\n+\t\t}\n+\t\treturn nil, io.EOF\n+\t}\n+\tlist := make([]fs.DirEntry, n)\n+\tfor i := range list {\n+\t\tlist[i] = d.files[d.offset+i].stat()\n+\t}\n+\td.offset += n\n+\treturn list, nil\n+}"}, {"sha": "34e96f7da43c2a79e26f2f2527a78f9265914163", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,12 +10,13 @@ import (\n \t\"encoding/hex\"\n \t\"internal/obscuretestdata\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"strings\"\n \t\"testing\"\n+\t\"testing/fstest\"\n \t\"time\"\n )\n \n@@ -30,7 +31,7 @@ type ZipTest struct {\n \n type ZipTestFile struct {\n \tName     string\n-\tMode     os.FileMode\n+\tMode     fs.FileMode\n \tNonUTF8  bool\n \tModTime  time.Time\n \tModified time.Time\n@@ -107,7 +108,7 @@ var tests = []ZipTest{\n \t\t\t\tName:     \"symlink\",\n \t\t\t\tContent:  []byte(\"../target\"),\n \t\t\t\tModified: time.Date(2012, 2, 3, 19, 56, 48, 0, timeZone(-2*time.Hour)),\n-\t\t\t\tMode:     0777 | os.ModeSymlink,\n+\t\t\t\tMode:     0777 | fs.ModeSymlink,\n \t\t\t},\n \t\t},\n \t},\n@@ -149,7 +150,7 @@ var tests = []ZipTest{\n \t\t\t\tName:     \"dir/empty/\",\n \t\t\t\tContent:  []byte{},\n \t\t\t\tModified: time.Date(2011, 12, 8, 10, 8, 6, 0, time.UTC),\n-\t\t\t\tMode:     os.ModeDir | 0777,\n+\t\t\t\tMode:     fs.ModeDir | 0777,\n \t\t\t},\n \t\t\t{\n \t\t\t\tName:     \"readonly\",\n@@ -179,7 +180,7 @@ var tests = []ZipTest{\n \t\t\t\tName:     \"dir/empty/\",\n \t\t\t\tContent:  []byte{},\n \t\t\t\tModified: time.Date(2011, 12, 8, 10, 8, 6, 0, timeZone(0)),\n-\t\t\t\tMode:     os.ModeDir | 0777,\n+\t\t\t\tMode:     fs.ModeDir | 0777,\n \t\t\t},\n \t\t\t{\n \t\t\t\tName:     \"readonly\",\n@@ -627,7 +628,7 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \tvar c []byte\n \tif ft.Content != nil {\n \t\tc = ft.Content\n-\t} else if c, err = ioutil.ReadFile(\"testdata/\" + ft.File); err != nil {\n+\t} else if c, err = os.ReadFile(\"testdata/\" + ft.File); err != nil {\n \t\tt.Error(err)\n \t\treturn\n \t}\n@@ -645,7 +646,7 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \t}\n }\n \n-func testFileMode(t *testing.T, f *File, want os.FileMode) {\n+func testFileMode(t *testing.T, f *File, want fs.FileMode) {\n \tmode := f.Mode()\n \tif want == 0 {\n \t\tt.Errorf(\"%s mode: got %v, want none\", f.Name, mode)\n@@ -683,7 +684,7 @@ func TestInvalidFiles(t *testing.T) {\n }\n \n func messWith(fileName string, corrupter func(b []byte)) (r io.ReaderAt, size int64) {\n-\tdata, err := ioutil.ReadFile(filepath.Join(\"testdata\", fileName))\n+\tdata, err := os.ReadFile(filepath.Join(\"testdata\", fileName))\n \tif err != nil {\n \t\tpanic(\"Error reading \" + fileName + \": \" + err.Error())\n \t}\n@@ -790,17 +791,17 @@ func returnRecursiveZip() (r io.ReaderAt, size int64) {\n //\n //\tfunc main() {\n //\t\tbigZip := makeZip(\"big.file\", io.LimitReader(zeros{}, 1<<32-1))\n-//\t\tif err := ioutil.WriteFile(\"/tmp/big.zip\", bigZip, 0666); err != nil {\n+//\t\tif err := os.WriteFile(\"/tmp/big.zip\", bigZip, 0666); err != nil {\n //\t\t\tlog.Fatal(err)\n //\t\t}\n //\n //\t\tbiggerZip := makeZip(\"big.zip\", bytes.NewReader(bigZip))\n-//\t\tif err := ioutil.WriteFile(\"/tmp/bigger.zip\", biggerZip, 0666); err != nil {\n+//\t\tif err := os.WriteFile(\"/tmp/bigger.zip\", biggerZip, 0666); err != nil {\n //\t\t\tlog.Fatal(err)\n //\t\t}\n //\n //\t\tbiggestZip := makeZip(\"bigger.zip\", bytes.NewReader(biggerZip))\n-//\t\tif err := ioutil.WriteFile(\"/tmp/biggest.zip\", biggestZip, 0666); err != nil {\n+//\t\tif err := os.WriteFile(\"/tmp/biggest.zip\", biggestZip, 0666); err != nil {\n //\t\t\tlog.Fatal(err)\n //\t\t}\n //\t}\n@@ -928,7 +929,7 @@ func returnBigZipBytes() (r io.ReaderAt, size int64) {\n \t\tif err != nil {\n \t\t\tpanic(err)\n \t\t}\n-\t\tb, err = ioutil.ReadAll(f)\n+\t\tb, err = io.ReadAll(f)\n \t\tif err != nil {\n \t\t\tpanic(err)\n \t\t}\n@@ -985,7 +986,7 @@ func TestIssue10957(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \t\tif f.UncompressedSize64 < 1e6 {\n-\t\t\tn, err := io.Copy(ioutil.Discard, r)\n+\t\t\tn, err := io.Copy(io.Discard, r)\n \t\t\tif i == 3 && err != io.ErrUnexpectedEOF {\n \t\t\t\tt.Errorf(\"File[3] error = %v; want io.ErrUnexpectedEOF\", err)\n \t\t\t}\n@@ -1027,7 +1028,7 @@ func TestIssue11146(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\t_, err = ioutil.ReadAll(r)\n+\t_, err = io.ReadAll(r)\n \tif err != io.ErrUnexpectedEOF {\n \t\tt.Errorf(\"File[0] error = %v; want io.ErrUnexpectedEOF\", err)\n \t}\n@@ -1070,3 +1071,13 @@ func TestIssue12449(t *testing.T) {\n \t\tt.Errorf(\"Error reading the archive: %v\", err)\n \t}\n }\n+\n+func TestFS(t *testing.T) {\n+\tz, err := OpenReader(\"testdata/unix.zip\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := fstest.TestFS(z, \"hello\", \"dir/bar\", \"dir/empty\", \"readonly\"); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}"}, {"sha": "4389246286f6830c48d120e98ba5ef2ded567664", "filename": "libgo/go/archive/zip/register.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"compress/flate\"\n \t\"errors\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"sync\"\n )\n \n@@ -111,7 +110,7 @@ func init() {\n \tcompressors.Store(Store, Compressor(func(w io.Writer) (io.WriteCloser, error) { return &nopCloser{w}, nil }))\n \tcompressors.Store(Deflate, Compressor(func(w io.Writer) (io.WriteCloser, error) { return newFlateWriter(w), nil }))\n \n-\tdecompressors.Store(Store, Decompressor(ioutil.NopCloser))\n+\tdecompressors.Store(Store, Decompressor(io.NopCloser))\n \tdecompressors.Store(Deflate, Decompressor(newFlateReader))\n }\n "}, {"sha": "4dd29f35fa63f6e8d898ab2b55faa46b3611d918", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -20,7 +20,7 @@ fields must be used instead.\n package zip\n \n import (\n-\t\"os\"\n+\t\"io/fs\"\n \t\"path\"\n \t\"time\"\n )\n@@ -137,12 +137,12 @@ type FileHeader struct {\n \tExternalAttrs      uint32 // Meaning depends on CreatorVersion\n }\n \n-// FileInfo returns an os.FileInfo for the FileHeader.\n-func (h *FileHeader) FileInfo() os.FileInfo {\n+// FileInfo returns an fs.FileInfo for the FileHeader.\n+func (h *FileHeader) FileInfo() fs.FileInfo {\n \treturn headerFileInfo{h}\n }\n \n-// headerFileInfo implements os.FileInfo.\n+// headerFileInfo implements fs.FileInfo.\n type headerFileInfo struct {\n \tfh *FileHeader\n }\n@@ -161,17 +161,20 @@ func (fi headerFileInfo) ModTime() time.Time {\n \t}\n \treturn fi.fh.Modified.UTC()\n }\n-func (fi headerFileInfo) Mode() os.FileMode { return fi.fh.Mode() }\n+func (fi headerFileInfo) Mode() fs.FileMode { return fi.fh.Mode() }\n+func (fi headerFileInfo) Type() fs.FileMode { return fi.fh.Mode().Type() }\n func (fi headerFileInfo) Sys() interface{}  { return fi.fh }\n \n+func (fi headerFileInfo) Info() (fs.FileInfo, error) { return fi, nil }\n+\n // FileInfoHeader creates a partially-populated FileHeader from an\n-// os.FileInfo.\n-// Because os.FileInfo's Name method returns only the base name of\n+// fs.FileInfo.\n+// Because fs.FileInfo's Name method returns only the base name of\n // the file it describes, it may be necessary to modify the Name field\n // of the returned header to provide the full path name of the file.\n // If compression is desired, callers should set the FileHeader.Method\n // field; it is unset by default.\n-func FileInfoHeader(fi os.FileInfo) (*FileHeader, error) {\n+func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error) {\n \tsize := fi.Size()\n \tfh := &FileHeader{\n \t\tName:               fi.Name(),\n@@ -280,26 +283,26 @@ const (\n )\n \n // Mode returns the permission and mode bits for the FileHeader.\n-func (h *FileHeader) Mode() (mode os.FileMode) {\n+func (h *FileHeader) Mode() (mode fs.FileMode) {\n \tswitch h.CreatorVersion >> 8 {\n \tcase creatorUnix, creatorMacOSX:\n \t\tmode = unixModeToFileMode(h.ExternalAttrs >> 16)\n \tcase creatorNTFS, creatorVFAT, creatorFAT:\n \t\tmode = msdosModeToFileMode(h.ExternalAttrs)\n \t}\n \tif len(h.Name) > 0 && h.Name[len(h.Name)-1] == '/' {\n-\t\tmode |= os.ModeDir\n+\t\tmode |= fs.ModeDir\n \t}\n \treturn mode\n }\n \n // SetMode changes the permission and mode bits for the FileHeader.\n-func (h *FileHeader) SetMode(mode os.FileMode) {\n+func (h *FileHeader) SetMode(mode fs.FileMode) {\n \th.CreatorVersion = h.CreatorVersion&0xff | creatorUnix<<8\n \th.ExternalAttrs = fileModeToUnixMode(mode) << 16\n \n \t// set MSDOS attributes too, as the original zip does.\n-\tif mode&os.ModeDir != 0 {\n+\tif mode&fs.ModeDir != 0 {\n \t\th.ExternalAttrs |= msdosDir\n \t}\n \tif mode&0200 == 0 {\n@@ -312,9 +315,9 @@ func (h *FileHeader) isZip64() bool {\n \treturn h.CompressedSize64 >= uint32max || h.UncompressedSize64 >= uint32max\n }\n \n-func msdosModeToFileMode(m uint32) (mode os.FileMode) {\n+func msdosModeToFileMode(m uint32) (mode fs.FileMode) {\n \tif m&msdosDir != 0 {\n-\t\tmode = os.ModeDir | 0777\n+\t\tmode = fs.ModeDir | 0777\n \t} else {\n \t\tmode = 0666\n \t}\n@@ -324,64 +327,64 @@ func msdosModeToFileMode(m uint32) (mode os.FileMode) {\n \treturn mode\n }\n \n-func fileModeToUnixMode(mode os.FileMode) uint32 {\n+func fileModeToUnixMode(mode fs.FileMode) uint32 {\n \tvar m uint32\n-\tswitch mode & os.ModeType {\n+\tswitch mode & fs.ModeType {\n \tdefault:\n \t\tm = s_IFREG\n-\tcase os.ModeDir:\n+\tcase fs.ModeDir:\n \t\tm = s_IFDIR\n-\tcase os.ModeSymlink:\n+\tcase fs.ModeSymlink:\n \t\tm = s_IFLNK\n-\tcase os.ModeNamedPipe:\n+\tcase fs.ModeNamedPipe:\n \t\tm = s_IFIFO\n-\tcase os.ModeSocket:\n+\tcase fs.ModeSocket:\n \t\tm = s_IFSOCK\n-\tcase os.ModeDevice:\n-\t\tif mode&os.ModeCharDevice != 0 {\n+\tcase fs.ModeDevice:\n+\t\tif mode&fs.ModeCharDevice != 0 {\n \t\t\tm = s_IFCHR\n \t\t} else {\n \t\t\tm = s_IFBLK\n \t\t}\n \t}\n-\tif mode&os.ModeSetuid != 0 {\n+\tif mode&fs.ModeSetuid != 0 {\n \t\tm |= s_ISUID\n \t}\n-\tif mode&os.ModeSetgid != 0 {\n+\tif mode&fs.ModeSetgid != 0 {\n \t\tm |= s_ISGID\n \t}\n-\tif mode&os.ModeSticky != 0 {\n+\tif mode&fs.ModeSticky != 0 {\n \t\tm |= s_ISVTX\n \t}\n \treturn m | uint32(mode&0777)\n }\n \n-func unixModeToFileMode(m uint32) os.FileMode {\n-\tmode := os.FileMode(m & 0777)\n+func unixModeToFileMode(m uint32) fs.FileMode {\n+\tmode := fs.FileMode(m & 0777)\n \tswitch m & s_IFMT {\n \tcase s_IFBLK:\n-\t\tmode |= os.ModeDevice\n+\t\tmode |= fs.ModeDevice\n \tcase s_IFCHR:\n-\t\tmode |= os.ModeDevice | os.ModeCharDevice\n+\t\tmode |= fs.ModeDevice | fs.ModeCharDevice\n \tcase s_IFDIR:\n-\t\tmode |= os.ModeDir\n+\t\tmode |= fs.ModeDir\n \tcase s_IFIFO:\n-\t\tmode |= os.ModeNamedPipe\n+\t\tmode |= fs.ModeNamedPipe\n \tcase s_IFLNK:\n-\t\tmode |= os.ModeSymlink\n+\t\tmode |= fs.ModeSymlink\n \tcase s_IFREG:\n \t\t// nothing to do\n \tcase s_IFSOCK:\n-\t\tmode |= os.ModeSocket\n+\t\tmode |= fs.ModeSocket\n \t}\n \tif m&s_ISGID != 0 {\n-\t\tmode |= os.ModeSetgid\n+\t\tmode |= fs.ModeSetgid\n \t}\n \tif m&s_ISUID != 0 {\n-\t\tmode |= os.ModeSetuid\n+\t\tmode |= fs.ModeSetuid\n \t}\n \tif m&s_ISVTX != 0 {\n-\t\tmode |= os.ModeSticky\n+\t\tmode |= fs.ModeSticky\n \t}\n \treturn mode\n }"}, {"sha": "5985144e5c2d25fb3df2fe37682fa0fd4c1b3d8a", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,7 +9,7 @@ import (\n \t\"encoding/binary\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"math/rand\"\n \t\"os\"\n \t\"strings\"\n@@ -23,7 +23,7 @@ type WriteTest struct {\n \tName   string\n \tData   []byte\n \tMethod uint16\n-\tMode   os.FileMode\n+\tMode   fs.FileMode\n }\n \n var writeTests = []WriteTest{\n@@ -43,19 +43,19 @@ var writeTests = []WriteTest{\n \t\tName:   \"setuid\",\n \t\tData:   []byte(\"setuid file\"),\n \t\tMethod: Deflate,\n-\t\tMode:   0755 | os.ModeSetuid,\n+\t\tMode:   0755 | fs.ModeSetuid,\n \t},\n \t{\n \t\tName:   \"setgid\",\n \t\tData:   []byte(\"setgid file\"),\n \t\tMethod: Deflate,\n-\t\tMode:   0755 | os.ModeSetgid,\n+\t\tMode:   0755 | fs.ModeSetgid,\n \t},\n \t{\n \t\tName:   \"symlink\",\n \t\tData:   []byte(\"../link/target\"),\n \t\tMethod: Deflate,\n-\t\tMode:   0755 | os.ModeSymlink,\n+\t\tMode:   0755 | fs.ModeSymlink,\n \t},\n }\n \n@@ -237,7 +237,7 @@ func TestWriterTime(t *testing.T) {\n \t\tt.Fatalf(\"unexpected Close error: %v\", err)\n \t}\n \n-\twant, err := ioutil.ReadFile(\"testdata/time-go.zip\")\n+\twant, err := os.ReadFile(\"testdata/time-go.zip\")\n \tif err != nil {\n \t\tt.Fatalf(\"unexpected ReadFile error: %v\", err)\n \t}\n@@ -301,7 +301,7 @@ func TestWriterFlush(t *testing.T) {\n }\n \n func TestWriterDir(t *testing.T) {\n-\tw := NewWriter(ioutil.Discard)\n+\tw := NewWriter(io.Discard)\n \tdw, err := w.Create(\"dir/\")\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -380,7 +380,7 @@ func testReadFile(t *testing.T, f *File, wt *WriteTest) {\n \tif err != nil {\n \t\tt.Fatal(\"opening:\", err)\n \t}\n-\tb, err := ioutil.ReadAll(rc)\n+\tb, err := io.ReadAll(rc)\n \tif err != nil {\n \t\tt.Fatal(\"reading:\", err)\n \t}"}, {"sha": "ead9cd3aab991fc59b5725e52c3cb7bc85514521", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"hash\"\n \t\"internal/testenv\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n@@ -620,7 +619,7 @@ func testZip64(t testing.TB, size int64) *rleBuffer {\n \t\t\tt.Fatal(\"read:\", err)\n \t\t}\n \t}\n-\tgotEnd, err := ioutil.ReadAll(rc)\n+\tgotEnd, err := io.ReadAll(rc)\n \tif err != nil {\n \t\tt.Fatal(\"read end:\", err)\n \t}"}, {"sha": "6baf9b9e400f388c621bd8f5709d8918f1feebff", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -425,7 +425,7 @@ func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) {\n // of bytes in the combined first two elements, error).\n // The complete result is equal to\n // `bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a\n-// length of `totalLen`. The result is strucured in this way to allow callers\n+// length of `totalLen`. The result is structured in this way to allow callers\n // to minimize allocations and copies.\n func (b *Reader) collectFragments(delim byte) (fullBuffers [][]byte, finalFragment []byte, totalLen int, err error) {\n \tvar frag []byte"}, {"sha": "d7b34bd0d8f66b485a49ad355fce86c3a9d5f726", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"strings\"\n \t\"testing\"\n \t\"testing/iotest\"\n@@ -147,7 +146,7 @@ func TestReader(t *testing.T) {\n \tfor i := 0; i < len(texts)-1; i++ {\n \t\ttexts[i] = str + \"\\n\"\n \t\tall += texts[i]\n-\t\tstr += string(rune(i)%26 + 'a')\n+\t\tstr += string(rune(i%26 + 'a'))\n \t}\n \ttexts[len(texts)-1] = all\n \n@@ -886,7 +885,7 @@ func TestReadEmptyBuffer(t *testing.T) {\n \n func TestLinesAfterRead(t *testing.T) {\n \tl := NewReaderSize(bytes.NewReader([]byte(\"foo\")), minReadBufferSize)\n-\t_, err := ioutil.ReadAll(l)\n+\t_, err := io.ReadAll(l)\n \tif err != nil {\n \t\tt.Error(err)\n \t\treturn\n@@ -1130,7 +1129,7 @@ func TestWriterReadFromCounts(t *testing.T) {\n \t}\n }\n \n-// A writeCountingDiscard is like ioutil.Discard and counts the number of times\n+// A writeCountingDiscard is like io.Discard and counts the number of times\n // Write is called on it.\n type writeCountingDiscard int\n \n@@ -1300,7 +1299,7 @@ func TestReaderReset(t *testing.T) {\n \t\tt.Errorf(\"buf = %q; want foo\", buf)\n \t}\n \tr.Reset(strings.NewReader(\"bar bar\"))\n-\tall, err := ioutil.ReadAll(r)\n+\tall, err := io.ReadAll(r)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -1645,13 +1644,13 @@ func BenchmarkReaderWriteToOptimal(b *testing.B) {\n \tbuf := make([]byte, bufSize)\n \tr := bytes.NewReader(buf)\n \tsrcReader := NewReaderSize(onlyReader{r}, 1<<10)\n-\tif _, ok := ioutil.Discard.(io.ReaderFrom); !ok {\n-\t\tb.Fatal(\"ioutil.Discard doesn't support ReaderFrom\")\n+\tif _, ok := io.Discard.(io.ReaderFrom); !ok {\n+\t\tb.Fatal(\"io.Discard doesn't support ReaderFrom\")\n \t}\n \tfor i := 0; i < b.N; i++ {\n \t\tr.Seek(0, io.SeekStart)\n \t\tsrcReader.Reset(onlyReader{r})\n-\t\tn, err := srcReader.WriteTo(ioutil.Discard)\n+\t\tn, err := srcReader.WriteTo(io.Discard)\n \t\tif err != nil {\n \t\t\tb.Fatal(err)\n \t\t}\n@@ -1722,7 +1721,7 @@ func BenchmarkReaderEmpty(b *testing.B) {\n \tstr := strings.Repeat(\"x\", 16<<10)\n \tfor i := 0; i < b.N; i++ {\n \t\tbr := NewReader(strings.NewReader(str))\n-\t\tn, err := io.Copy(ioutil.Discard, br)\n+\t\tn, err := io.Copy(io.Discard, br)\n \t\tif err != nil {\n \t\t\tb.Fatal(err)\n \t\t}\n@@ -1737,7 +1736,7 @@ func BenchmarkWriterEmpty(b *testing.B) {\n \tstr := strings.Repeat(\"x\", 1<<10)\n \tbs := []byte(str)\n \tfor i := 0; i < b.N; i++ {\n-\t\tbw := NewWriter(ioutil.Discard)\n+\t\tbw := NewWriter(io.Discard)\n \t\tbw.Flush()\n \t\tbw.WriteByte('a')\n \t\tbw.Flush()\n@@ -1752,7 +1751,7 @@ func BenchmarkWriterEmpty(b *testing.B) {\n \n func BenchmarkWriterFlush(b *testing.B) {\n \tb.ReportAllocs()\n-\tbw := NewWriter(ioutil.Discard)\n+\tbw := NewWriter(io.Discard)\n \tstr := strings.Repeat(\"x\", 50)\n \tfor i := 0; i < b.N; i++ {\n \t\tbw.WriteString(str)"}, {"sha": "ae93202b5706e12da11cb8866af8f6a9d75b5745", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -30,6 +30,13 @@ func ExampleBuffer_reader() {\n \t// Output: Gophers rule!\n }\n \n+func ExampleBuffer_Bytes() {\n+\tbuf := bytes.Buffer{}\n+\tbuf.Write([]byte{'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'})\n+\tos.Stdout.Write(buf.Bytes())\n+\t// Output: hello world\n+}\n+\n func ExampleBuffer_Grow() {\n \tvar b bytes.Buffer\n \tb.Grow(64)"}, {"sha": "8baac5046cbeecf30b6dce346908943de524d1e8", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,7 +8,6 @@ import (\n \t. \"bytes\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"sync\"\n \t\"testing\"\n )\n@@ -235,7 +234,7 @@ func TestReaderCopyNothing(t *testing.T) {\n \ttype justWriter struct {\n \t\tio.Writer\n \t}\n-\tdiscard := justWriter{ioutil.Discard} // hide ReadFrom\n+\tdiscard := justWriter{io.Discard} // hide ReadFrom\n \n \tvar with, withOut nErr\n \twith.n, with.err = io.Copy(discard, NewReader(nil))\n@@ -248,7 +247,7 @@ func TestReaderCopyNothing(t *testing.T) {\n // tests that Len is affected by reads, but Size is not.\n func TestReaderLenSize(t *testing.T) {\n \tr := NewReader([]byte(\"abc\"))\n-\tio.CopyN(ioutil.Discard, r, 1)\n+\tio.CopyN(io.Discard, r, 1)\n \tif r.Len() != 2 {\n \t\tt.Errorf(\"Len = %d; want 2\", r.Len())\n \t}\n@@ -268,7 +267,7 @@ func TestReaderReset(t *testing.T) {\n \tif err := r.UnreadRune(); err == nil {\n \t\tt.Errorf(\"UnreadRune: expected error, got nil\")\n \t}\n-\tbuf, err := ioutil.ReadAll(r)\n+\tbuf, err := io.ReadAll(r)\n \tif err != nil {\n \t\tt.Errorf(\"ReadAll: unexpected error: %v\", err)\n \t}\n@@ -314,7 +313,7 @@ func TestReaderZero(t *testing.T) {\n \t\tt.Errorf(\"UnreadRune: got nil, want error\")\n \t}\n \n-\tif n, err := (&Reader{}).WriteTo(ioutil.Discard); n != 0 || err != nil {\n+\tif n, err := (&Reader{}).WriteTo(io.Discard); n != 0 || err != nil {\n \t\tt.Errorf(\"WriteTo: got %d, %v; want 0, nil\", n, err)\n \t}\n }"}, {"sha": "8e02a7ae109611488417ab480cd47288de45d81a", "filename": "libgo/go/cmd/buildid/buildid.go", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -22,21 +22,6 @@ func usage() {\n \n var wflag = flag.Bool(\"w\", false, \"write build ID\")\n \n-// taken from cmd/go/internal/work/buildid.go\n-func hashToString(h [32]byte) string {\n-\tconst b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"\n-\tconst chunks = 5\n-\tvar dst [chunks * 4]byte\n-\tfor i := 0; i < chunks; i++ {\n-\t\tv := uint32(h[3*i])<<16 | uint32(h[3*i+1])<<8 | uint32(h[3*i+2])\n-\t\tdst[4*i+0] = b64[(v>>18)&0x3F]\n-\t\tdst[4*i+1] = b64[(v>>12)&0x3F]\n-\t\tdst[4*i+2] = b64[(v>>6)&0x3F]\n-\t\tdst[4*i+3] = b64[v&0x3F]\n-\t}\n-\treturn string(dst[:])\n-}\n-\n func main() {\n \tlog.SetPrefix(\"buildid: \")\n \tlog.SetFlags(0)\n@@ -63,12 +48,12 @@ func main() {\n \t\tlog.Fatal(err)\n \t}\n \tmatches, hash, err := buildid.FindAndHash(f, id, 0)\n+\tf.Close()\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n-\tf.Close()\n \n-\tnewID := id[:strings.LastIndex(id, \"/\")] + \"/\" + hashToString(hash)\n+\tnewID := id[:strings.LastIndex(id, \"/\")] + \"/\" + buildid.HashToString(hash)\n \tif len(newID) != len(id) {\n \t\tlog.Fatalf(\"%s: build ID length mismatch %q vs %q\", file, id, newID)\n \t}\n@@ -77,7 +62,7 @@ func main() {\n \t\treturn\n \t}\n \n-\tf, err = os.OpenFile(file, os.O_WRONLY, 0)\n+\tf, err = os.OpenFile(file, os.O_RDWR, 0)\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}"}, {"sha": "a073407a961e15af2a7b4cbe92afd925712e82b3", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"go/scanner\"\n \t\"go/token\"\n \t\"os\"\n-\t\"path/filepath\"\n \t\"strings\"\n )\n \n@@ -44,14 +43,7 @@ func sourceLine(n ast.Node) int {\n // attached to the import \"C\" comment, a list of references to C.xxx,\n // a list of exported functions, and the actual AST, to be rewritten and\n // printed.\n-func (f *File) ParseGo(name string, src []byte) {\n-\t// Create absolute path for file, so that it will be used in error\n-\t// messages and recorded in debug line number information.\n-\t// This matches the rest of the toolchain. See golang.org/issue/5122.\n-\tif aname, err := filepath.Abs(name); err == nil {\n-\t\tname = aname\n-\t}\n-\n+func (f *File) ParseGo(abspath string, src []byte) {\n \t// Two different parses: once with comments, once without.\n \t// The printer is not good enough at printing comments in the\n \t// right place when we start editing the AST behind its back,\n@@ -60,8 +52,8 @@ func (f *File) ParseGo(name string, src []byte) {\n \t// and reprinting.\n \t// In cgo mode, we ignore ast2 and just apply edits directly\n \t// the text behind ast1. In godefs mode we modify and print ast2.\n-\tast1 := parse(name, src, parser.ParseComments)\n-\tast2 := parse(name, src, 0)\n+\tast1 := parse(abspath, src, parser.ParseComments)\n+\tast2 := parse(abspath, src, 0)\n \n \tf.Package = ast1.Name.Name\n \tf.Name = make(map[string]*Name)\n@@ -88,7 +80,7 @@ func (f *File) ParseGo(name string, src []byte) {\n \t\t\t\tcg = d.Doc\n \t\t\t}\n \t\t\tif cg != nil {\n-\t\t\t\tf.Preamble += fmt.Sprintf(\"#line %d %q\\n\", sourceLine(cg), name)\n+\t\t\t\tf.Preamble += fmt.Sprintf(\"#line %d %q\\n\", sourceLine(cg), abspath)\n \t\t\t\tf.Preamble += commentText(cg) + \"\\n\"\n \t\t\t\tf.Preamble += \"#line 1 \\\"cgo-generated-wrapper\\\"\\n\"\n \t\t\t}"}, {"sha": "e782c866ac771640c365ad97e5055b7cabdceaa3", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -112,6 +112,13 @@ The default C and C++ compilers may be changed by the CC and CXX\n environment variables, respectively; those environment variables\n may include command line options.\n \n+The cgo tool will always invoke the C compiler with the source file's\n+directory in the include path; i.e. -I${SRCDIR} is always implied. This\n+means that if a header file foo/bar.h exists both in the source\n+directory and also in the system include directory (or some other place\n+specified by a -I flag), then \"#include <foo/bar.h>\" will always find the\n+local version in preference to any other version.\n+\n The cgo tool is enabled by default for native builds on systems where\n it is expected to work. It is disabled by default when\n cross-compiling. You can control this by setting the CGO_ENABLED\n@@ -714,7 +721,7 @@ linkage to the desired libraries. The main function is provided by\n _cgo_main.c:\n \n \tint main() { return 0; }\n-\tvoid crosscall2(void(*fn)(void*, int, uintptr_t), void *a, int c, uintptr_t ctxt) { }\n+\tvoid crosscall2(void(*fn)(void*), void *a, int c, uintptr_t ctxt) { }\n \tuintptr_t _cgo_wait_runtime_init_done(void) { return 0; }\n \tvoid _cgo_release_context(uintptr_t ctxt) { }\n \tchar* _cgo_topofstack(void) { return (char*)0; }"}, {"sha": "796ff8ac520ce5c9ba267f0f1e0312bee53539b7", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -316,7 +316,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\tcontinue\n \t\t}\n \n-\t\tif goos == \"darwin\" && strings.HasSuffix(n.C, \"Ref\") {\n+\t\tif (goos == \"darwin\" || goos == \"ios\") && strings.HasSuffix(n.C, \"Ref\") {\n \t\t\t// For FooRef, find out if FooGetTypeID exists.\n \t\t\ts := n.C[:len(n.C)-3] + \"GetTypeID\"\n \t\t\tn := &Name{Go: s, C: s}\n@@ -387,7 +387,18 @@ func (p *Package) guessKinds(f *File) []*Name {\n \tfmt.Fprintf(&b, \"#line 1 \\\"completed\\\"\\n\"+\n \t\t\"int __cgo__1 = __cgo__2;\\n\")\n \n-\tstderr := p.gccErrors(b.Bytes())\n+\t// We need to parse the output from this gcc command, so ensure that it\n+\t// doesn't have any ANSI escape sequences in it. (TERM=dumb is\n+\t// insufficient; if the user specifies CGO_CFLAGS=-fdiagnostics-color,\n+\t// GCC will ignore TERM, and GCC can also be configured at compile-time\n+\t// to ignore TERM.)\n+\tstderr := p.gccErrors(b.Bytes(), \"-fdiagnostics-color=never\")\n+\tif strings.Contains(stderr, \"unrecognized command line option\") {\n+\t\t// We're using an old version of GCC that doesn't understand\n+\t\t// -fdiagnostics-color. Those versions can't print color anyway,\n+\t\t// so just rerun without that option.\n+\t\tstderr = p.gccErrors(b.Bytes())\n+\t}\n \tif stderr == \"\" {\n \t\tfatalf(\"%s produced no output\\non input:\\n%s\", p.gccBaseCmd()[0], b.Bytes())\n \t}\n@@ -1995,22 +2006,25 @@ func (p *Package) gccDefines(stdin []byte) string {\n // gccErrors runs gcc over the C program stdin and returns\n // the errors that gcc prints. That is, this function expects\n // gcc to fail.\n-func (p *Package) gccErrors(stdin []byte) string {\n+func (p *Package) gccErrors(stdin []byte, extraArgs ...string) string {\n \t// TODO(rsc): require failure\n \targs := p.gccCmd()\n \n \t// Optimization options can confuse the error messages; remove them.\n-\tnargs := make([]string, 0, len(args))\n+\tnargs := make([]string, 0, len(args)+len(extraArgs))\n \tfor _, arg := range args {\n \t\tif !strings.HasPrefix(arg, \"-O\") {\n \t\t\tnargs = append(nargs, arg)\n \t\t}\n \t}\n \n-\t// Force -O0 optimization but keep the trailing \"-\" at the end.\n-\tnargs = append(nargs, \"-O0\")\n-\tnl := len(nargs)\n-\tnargs[nl-2], nargs[nl-1] = nargs[nl-1], nargs[nl-2]\n+\t// Force -O0 optimization and append extra arguments, but keep the\n+\t// trailing \"-\" at the end.\n+\tli := len(nargs) - 1\n+\tlast := nargs[li]\n+\tnargs[li] = \"-O0\"\n+\tnargs = append(nargs, extraArgs...)\n+\tnargs = append(nargs, last)\n \n \tif *debugGcc {\n \t\tfmt.Fprintf(os.Stderr, \"$ %s <<EOF\\n\", strings.Join(nargs, \" \"))\n@@ -2856,21 +2870,11 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\ttgo := t.Go\n \t\tsize := t.Size\n \t\ttalign := t.Align\n-\t\tif f.BitSize > 0 {\n-\t\t\tswitch f.BitSize {\n-\t\t\tcase 8, 16, 32, 64:\n-\t\t\tdefault:\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tsize = f.BitSize / 8\n-\t\t\tname := tgo.(*ast.Ident).String()\n-\t\t\tif strings.HasPrefix(name, \"int\") {\n-\t\t\t\tname = \"int\"\n-\t\t\t} else {\n-\t\t\t\tname = \"uint\"\n-\t\t\t}\n-\t\t\ttgo = ast.NewIdent(name + fmt.Sprint(f.BitSize))\n-\t\t\ttalign = size\n+\t\tif f.BitOffset > 0 || f.BitSize > 0 {\n+\t\t\t// The layout of bitfields is implementation defined,\n+\t\t\t// so we don't know how they correspond to Go fields\n+\t\t\t// even if they are aligned at byte boundaries.\n+\t\t\tcontinue\n \t\t}\n \n \t\tif talign > 0 && f.ByteOffset%talign != 0 {\n@@ -3096,7 +3100,7 @@ func (c *typeConv) badCFType(dt *dwarf.TypedefType) bool {\n \t// We identify the correct set of types as those ending in Ref and for which\n \t// there exists a corresponding GetTypeID function.\n \t// See comment below for details about the bad pointers.\n-\tif goos != \"darwin\" {\n+\tif goos != \"darwin\" && goos != \"ios\" {\n \t\treturn false\n \t}\n \ts := dt.Name"}, {"sha": "c0d59aee01d747ec8ed02a587c72da0dd55f016b", "filename": "libgo/go/cmd/cgo/godefs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -16,7 +16,7 @@ import (\n )\n \n // godefs returns the output for -godefs mode.\n-func (p *Package) godefs(f *File, srcfile string) string {\n+func (p *Package) godefs(f *File) string {\n \tvar buf bytes.Buffer\n \n \tfmt.Fprintf(&buf, \"// Code generated by cmd/cgo -godefs; DO NOT EDIT.\\n\")"}, {"sha": "c47e99170c0ff5f48e14c36302fef8ef2cd953f1", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -247,6 +247,8 @@ var gccgopkgpath = flag.String(\"gccgopkgpath\", \"\", \"-fgo-pkgpath option used wit\n var gccgoMangler func(string) string\n var importRuntimeCgo = flag.Bool(\"import_runtime_cgo\", true, \"import runtime/cgo in generated code\")\n var importSyscall = flag.Bool(\"import_syscall\", true, \"import syscall in generated code\")\n+var trimpath = flag.String(\"trimpath\", \"\", \"applies supplied rewrites or trims prefixes to recorded source file paths\")\n+\n var goarch, goos string\n \n func main() {\n@@ -326,6 +328,13 @@ func main() {\n \t\t\tinput = filepath.Join(*srcDir, input)\n \t\t}\n \n+\t\t// Create absolute path for file, so that it will be used in error\n+\t\t// messages and recorded in debug line number information.\n+\t\t// This matches the rest of the toolchain. See golang.org/issue/5122.\n+\t\tif aname, err := filepath.Abs(input); err == nil {\n+\t\t\tinput = aname\n+\t\t}\n+\n \t\tb, err := ioutil.ReadFile(input)\n \t\tif err != nil {\n \t\t\tfatalf(\"%s\", err)\n@@ -334,6 +343,10 @@ func main() {\n \t\t\tfatalf(\"%s\", err)\n \t\t}\n \n+\t\t// Apply trimpath to the file path. The path won't be read from after this point.\n+\t\tinput, _ = objabi.ApplyRewrites(input, *trimpath)\n+\t\tgoFiles[i] = input\n+\n \t\tf := new(File)\n \t\tf.Edit = edit.NewBuffer(b)\n \t\tf.ParseGo(input, b)\n@@ -371,7 +384,7 @@ func main() {\n \t\tp.PackagePath = f.Package\n \t\tp.Record(f)\n \t\tif *godefs {\n-\t\t\tos.Stdout.WriteString(p.godefs(f, input))\n+\t\t\tos.Stdout.WriteString(p.godefs(f))\n \t\t} else {\n \t\t\tp.writeOutput(f, input)\n \t\t}"}, {"sha": "6cdebac5e2bcd53d21c192e78ac66ada3e37ffc6", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 68, "deletions": 109, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -64,14 +64,14 @@ func (p *Package) writeDefs() {\n \t// Write C main file for using gcc to resolve imports.\n \tfmt.Fprintf(fm, \"int main() { return 0; }\\n\")\n \tif *importRuntimeCgo {\n-\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int, __SIZE_TYPE__), void *a, int c, __SIZE_TYPE__ ctxt) { }\\n\")\n+\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*), void *a, int c, __SIZE_TYPE__ ctxt) { }\\n\")\n \t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done(void) { return 0; }\\n\")\n \t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__ ctxt) { }\\n\")\n \t\tfmt.Fprintf(fm, \"char* _cgo_topofstack(void) { return (char*)0; }\\n\")\n \t} else {\n \t\t// If we're not importing runtime/cgo, we *are* runtime/cgo,\n \t\t// which provides these functions. We just need a prototype.\n-\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int, __SIZE_TYPE__), void *a, int c, __SIZE_TYPE__ ctxt);\\n\")\n+\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*), void *a, int c, __SIZE_TYPE__ ctxt);\\n\")\n \t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done(void);\\n\")\n \t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__);\\n\")\n \t}\n@@ -251,6 +251,7 @@ func (p *Package) writeDefs() {\n \t\tif err != nil {\n \t\t\tfatalf(\"%s\", err)\n \t\t}\n+\t\tdefer fgcch.Close()\n \t\t_, err = io.Copy(fexp, fgcch)\n \t\tif err != nil {\n \t\t\tfatalf(\"%s\", err)\n@@ -879,7 +880,7 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \tfmt.Fprintf(fgcc, \"#pragma GCC diagnostic ignored \\\"-Wpragmas\\\"\\n\")\n \tfmt.Fprintf(fgcc, \"#pragma GCC diagnostic ignored \\\"-Waddress-of-packed-member\\\"\\n\")\n \n-\tfmt.Fprintf(fgcc, \"extern void crosscall2(void (*fn)(void *, int, __SIZE_TYPE__), void *, int, __SIZE_TYPE__);\\n\")\n+\tfmt.Fprintf(fgcc, \"extern void crosscall2(void (*fn)(void *), void *, int, __SIZE_TYPE__);\\n\")\n \tfmt.Fprintf(fgcc, \"extern __SIZE_TYPE__ _cgo_wait_runtime_init_done(void);\\n\")\n \tfmt.Fprintf(fgcc, \"extern void _cgo_release_context(__SIZE_TYPE__);\\n\\n\")\n \tfmt.Fprintf(fgcc, \"extern char* _cgo_topofstack(void);\")\n@@ -889,59 +890,48 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \tfor _, exp := range p.ExpFunc {\n \t\tfn := exp.Func\n \n-\t\t// Construct a gcc struct matching the gc argument and\n-\t\t// result frame. The gcc struct will be compiled with\n-\t\t// __attribute__((packed)) so all padding must be accounted\n-\t\t// for explicitly.\n+\t\t// Construct a struct that will be used to communicate\n+\t\t// arguments from C to Go. The C and Go definitions\n+\t\t// just have to agree. The gcc struct will be compiled\n+\t\t// with __attribute__((packed)) so all padding must be\n+\t\t// accounted for explicitly.\n \t\tctype := \"struct {\\n\"\n+\t\tgotype := new(bytes.Buffer)\n+\t\tfmt.Fprintf(gotype, \"struct {\\n\")\n \t\toff := int64(0)\n \t\tnpad := 0\n-\t\tif fn.Recv != nil {\n-\t\t\tt := p.cgoType(fn.Recv.List[0].Type)\n-\t\t\tctype += fmt.Sprintf(\"\\t\\t%s recv;\\n\", t.C)\n+\t\targField := func(typ ast.Expr, namePat string, args ...interface{}) {\n+\t\t\tname := fmt.Sprintf(namePat, args...)\n+\t\t\tt := p.cgoType(typ)\n+\t\t\tif off%t.Align != 0 {\n+\t\t\t\tpad := t.Align - off%t.Align\n+\t\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n+\t\t\t\toff += pad\n+\t\t\t\tnpad++\n+\t\t\t}\n+\t\t\tctype += fmt.Sprintf(\"\\t\\t%s %s;\\n\", t.C, name)\n+\t\t\tfmt.Fprintf(gotype, \"\\t\\t%s \", name)\n+\t\t\tnoSourceConf.Fprint(gotype, fset, typ)\n+\t\t\tfmt.Fprintf(gotype, \"\\n\")\n \t\t\toff += t.Size\n \t\t}\n+\t\tif fn.Recv != nil {\n+\t\t\targField(fn.Recv.List[0].Type, \"recv\")\n+\t\t}\n \t\tfntype := fn.Type\n \t\tforFieldList(fntype.Params,\n \t\t\tfunc(i int, aname string, atype ast.Expr) {\n-\t\t\t\tt := p.cgoType(atype)\n-\t\t\t\tif off%t.Align != 0 {\n-\t\t\t\t\tpad := t.Align - off%t.Align\n-\t\t\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n-\t\t\t\t\toff += pad\n-\t\t\t\t\tnpad++\n-\t\t\t\t}\n-\t\t\t\tctype += fmt.Sprintf(\"\\t\\t%s p%d;\\n\", t.C, i)\n-\t\t\t\toff += t.Size\n+\t\t\t\targField(atype, \"p%d\", i)\n \t\t\t})\n-\t\tif off%p.PtrSize != 0 {\n-\t\t\tpad := p.PtrSize - off%p.PtrSize\n-\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n-\t\t\toff += pad\n-\t\t\tnpad++\n-\t\t}\n \t\tforFieldList(fntype.Results,\n \t\t\tfunc(i int, aname string, atype ast.Expr) {\n-\t\t\t\tt := p.cgoType(atype)\n-\t\t\t\tif off%t.Align != 0 {\n-\t\t\t\t\tpad := t.Align - off%t.Align\n-\t\t\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n-\t\t\t\t\toff += pad\n-\t\t\t\t\tnpad++\n-\t\t\t\t}\n-\t\t\t\tctype += fmt.Sprintf(\"\\t\\t%s r%d;\\n\", t.C, i)\n-\t\t\t\toff += t.Size\n+\t\t\t\targField(atype, \"r%d\", i)\n \t\t\t})\n-\t\tif off%p.PtrSize != 0 {\n-\t\t\tpad := p.PtrSize - off%p.PtrSize\n-\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n-\t\t\toff += pad\n-\t\t\tnpad++\n-\t\t}\n \t\tif ctype == \"struct {\\n\" {\n \t\t\tctype += \"\\t\\tchar unused;\\n\" // avoid empty struct\n \t\t}\n \t\tctype += \"\\t}\"\n+\t\tfmt.Fprintf(gotype, \"\\t}\")\n \n \t\t// Get the return type of the wrapper function\n \t\t// compiled by gcc.\n@@ -966,7 +956,11 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t}\n \n \t\t// Build the wrapper function compiled by gcc.\n-\t\ts := fmt.Sprintf(\"%s %s(\", gccResult, exp.ExpName)\n+\t\tgccExport := \"\"\n+\t\tif goos == \"windows\" {\n+\t\t\tgccExport = \"__declspec(dllexport)\"\n+\t\t}\n+\t\ts := fmt.Sprintf(\"%s %s %s(\", gccExport, gccResult, exp.ExpName)\n \t\tif fn.Recv != nil {\n \t\t\ts += p.cgoType(fn.Recv.List[0].Type).C.String()\n \t\t\ts += \" recv\"\n@@ -988,12 +982,23 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t}\n \t\tfmt.Fprintf(fgcch, \"extern %s;\\n\", s)\n \n-\t\tfmt.Fprintf(fgcc, \"extern void _cgoexp%s_%s(void *, int, __SIZE_TYPE__);\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fgcc, \"extern void _cgoexp%s_%s(void *);\\n\", cPrefix, exp.ExpName)\n \t\tfmt.Fprintf(fgcc, \"\\nCGO_NO_SANITIZE_THREAD\")\n \t\tfmt.Fprintf(fgcc, \"\\n%s\\n\", s)\n \t\tfmt.Fprintf(fgcc, \"{\\n\")\n \t\tfmt.Fprintf(fgcc, \"\\t__SIZE_TYPE__ _cgo_ctxt = _cgo_wait_runtime_init_done();\\n\")\n-\t\tfmt.Fprintf(fgcc, \"\\t%s %v _cgo_a;\\n\", ctype, p.packedAttribute())\n+\t\t// The results part of the argument structure must be\n+\t\t// initialized to 0 so the write barriers generated by\n+\t\t// the assignments to these fields in Go are safe.\n+\t\t//\n+\t\t// We use a local static variable to get the zeroed\n+\t\t// value of the argument type. This avoids including\n+\t\t// string.h for memset, and is also robust to C++\n+\t\t// types with constructors. Both GCC and LLVM optimize\n+\t\t// this into just zeroing _cgo_a.\n+\t\tfmt.Fprintf(fgcc, \"\\ttypedef %s %v _cgo_argtype;\\n\", ctype, p.packedAttribute())\n+\t\tfmt.Fprintf(fgcc, \"\\tstatic _cgo_argtype _cgo_zero;\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_argtype _cgo_a = _cgo_zero;\\n\")\n \t\tif gccResult != \"void\" && (len(fntype.Results.List) > 1 || len(fntype.Results.List[0].Names) > 1) {\n \t\t\tfmt.Fprintf(fgcc, \"\\t%s r;\\n\", gccResult)\n \t\t}\n@@ -1022,92 +1027,49 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\tfmt.Fprintf(fgcc, \"}\\n\")\n \n \t\t// Build the wrapper function compiled by cmd/compile.\n-\t\tgoname := \"_cgoexpwrap\" + cPrefix + \"_\"\n-\t\tif fn.Recv != nil {\n-\t\t\tgoname += fn.Recv.List[0].Names[0].Name + \"_\"\n-\t\t}\n-\t\tgoname += exp.Func.Name.Name\n+\t\t// This unpacks the argument struct above and calls the Go function.\n \t\tfmt.Fprintf(fgo2, \"//go:cgo_export_dynamic %s\\n\", exp.ExpName)\n \t\tfmt.Fprintf(fgo2, \"//go:linkname _cgoexp%s_%s _cgoexp%s_%s\\n\", cPrefix, exp.ExpName, cPrefix, exp.ExpName)\n \t\tfmt.Fprintf(fgo2, \"//go:cgo_export_static _cgoexp%s_%s\\n\", cPrefix, exp.ExpName)\n-\t\tfmt.Fprintf(fgo2, \"//go:nosplit\\n\") // no split stack, so no use of m or g\n-\t\tfmt.Fprintf(fgo2, \"//go:norace\\n\")  // must not have race detector calls inserted\n-\t\tfmt.Fprintf(fgo2, \"func _cgoexp%s_%s(a unsafe.Pointer, n int32, ctxt uintptr) {\\n\", cPrefix, exp.ExpName)\n-\t\tfmt.Fprintf(fgo2, \"\\tfn := %s\\n\", goname)\n-\t\t// The indirect here is converting from a Go function pointer to a C function pointer.\n-\t\tfmt.Fprintf(fgo2, \"\\t_cgo_runtime_cgocallback(**(**unsafe.Pointer)(unsafe.Pointer(&fn)), a, uintptr(n), ctxt);\\n\")\n-\t\tfmt.Fprintf(fgo2, \"}\\n\")\n+\t\tfmt.Fprintf(fgo2, \"func _cgoexp%s_%s(a *%s) {\\n\", cPrefix, exp.ExpName, gotype)\n \n \t\tfmt.Fprintf(fm, \"int _cgoexp%s_%s;\\n\", cPrefix, exp.ExpName)\n \n-\t\t// This code uses printer.Fprint, not conf.Fprint,\n-\t\t// because we don't want //line comments in the middle\n-\t\t// of the function types.\n-\t\tfmt.Fprintf(fgo2, \"\\n\")\n-\t\tfmt.Fprintf(fgo2, \"func %s(\", goname)\n-\t\tcomma := false\n-\t\tif fn.Recv != nil {\n-\t\t\tfmt.Fprintf(fgo2, \"recv \")\n-\t\t\tprinter.Fprint(fgo2, fset, fn.Recv.List[0].Type)\n-\t\t\tcomma = true\n-\t\t}\n-\t\tforFieldList(fntype.Params,\n-\t\t\tfunc(i int, aname string, atype ast.Expr) {\n-\t\t\t\tif comma {\n-\t\t\t\t\tfmt.Fprintf(fgo2, \", \")\n-\t\t\t\t}\n-\t\t\t\tfmt.Fprintf(fgo2, \"p%d \", i)\n-\t\t\t\tprinter.Fprint(fgo2, fset, atype)\n-\t\t\t\tcomma = true\n-\t\t\t})\n-\t\tfmt.Fprintf(fgo2, \")\")\n \t\tif gccResult != \"void\" {\n-\t\t\tfmt.Fprint(fgo2, \" (\")\n+\t\t\t// Write results back to frame.\n+\t\t\tfmt.Fprintf(fgo2, \"\\t\")\n \t\t\tforFieldList(fntype.Results,\n \t\t\t\tfunc(i int, aname string, atype ast.Expr) {\n \t\t\t\t\tif i > 0 {\n-\t\t\t\t\t\tfmt.Fprint(fgo2, \", \")\n-\t\t\t\t\t}\n-\t\t\t\t\tfmt.Fprintf(fgo2, \"r%d \", i)\n-\t\t\t\t\tprinter.Fprint(fgo2, fset, atype)\n-\t\t\t\t})\n-\t\t\tfmt.Fprint(fgo2, \")\")\n-\t\t}\n-\t\tfmt.Fprint(fgo2, \" {\\n\")\n-\t\tif gccResult == \"void\" {\n-\t\t\tfmt.Fprint(fgo2, \"\\t\")\n-\t\t} else {\n-\t\t\t// Verify that any results don't contain any\n-\t\t\t// Go pointers.\n-\t\t\taddedDefer := false\n-\t\t\tforFieldList(fntype.Results,\n-\t\t\t\tfunc(i int, aname string, atype ast.Expr) {\n-\t\t\t\t\tif !p.hasPointer(nil, atype, false) {\n-\t\t\t\t\t\treturn\n+\t\t\t\t\t\tfmt.Fprintf(fgo2, \", \")\n \t\t\t\t\t}\n-\t\t\t\t\tif !addedDefer {\n-\t\t\t\t\t\tfmt.Fprint(fgo2, \"\\tdefer func() {\\n\")\n-\t\t\t\t\t\taddedDefer = true\n-\t\t\t\t\t}\n-\t\t\t\t\tfmt.Fprintf(fgo2, \"\\t\\t_cgoCheckResult(r%d)\\n\", i)\n+\t\t\t\t\tfmt.Fprintf(fgo2, \"a.r%d\", i)\n \t\t\t\t})\n-\t\t\tif addedDefer {\n-\t\t\t\tfmt.Fprint(fgo2, \"\\t}()\\n\")\n-\t\t\t}\n-\t\t\tfmt.Fprint(fgo2, \"\\treturn \")\n+\t\t\tfmt.Fprintf(fgo2, \" = \")\n \t\t}\n \t\tif fn.Recv != nil {\n-\t\t\tfmt.Fprintf(fgo2, \"recv.\")\n+\t\t\tfmt.Fprintf(fgo2, \"a.recv.\")\n \t\t}\n \t\tfmt.Fprintf(fgo2, \"%s(\", exp.Func.Name)\n \t\tforFieldList(fntype.Params,\n \t\t\tfunc(i int, aname string, atype ast.Expr) {\n \t\t\t\tif i > 0 {\n \t\t\t\t\tfmt.Fprint(fgo2, \", \")\n \t\t\t\t}\n-\t\t\t\tfmt.Fprintf(fgo2, \"p%d\", i)\n+\t\t\t\tfmt.Fprintf(fgo2, \"a.p%d\", i)\n \t\t\t})\n \t\tfmt.Fprint(fgo2, \")\\n\")\n+\t\tif gccResult != \"void\" {\n+\t\t\t// Verify that any results don't contain any\n+\t\t\t// Go pointers.\n+\t\t\tforFieldList(fntype.Results,\n+\t\t\t\tfunc(i int, aname string, atype ast.Expr) {\n+\t\t\t\t\tif !p.hasPointer(nil, atype, false) {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tfmt.Fprintf(fgo2, \"\\t_cgoCheckResult(a.r%d)\\n\", i)\n+\t\t\t\t})\n+\t\t}\n \t\tfmt.Fprint(fgo2, \"}\\n\")\n \t}\n \n@@ -1604,9 +1566,6 @@ const goProlog = `\n //go:linkname _cgo_runtime_cgocall runtime.cgocall\n func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32\n \n-//go:linkname _cgo_runtime_cgocallback runtime.cgocallback\n-func _cgo_runtime_cgocallback(unsafe.Pointer, unsafe.Pointer, uintptr, uintptr)\n-\n //go:linkname _cgoCheckPointer runtime.cgoCheckPointer\n func _cgoCheckPointer(interface{}, interface{})\n "}, {"sha": "031b8d4ab75b1c62687a0ebdd9b87a92be227cab", "filename": "libgo/go/cmd/go.mod", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo.mod?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -0,0 +1,12 @@\n+module cmd\n+\n+go 1.16\n+\n+require (\n+\tgithub.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2\n+\tgolang.org/x/arch v0.0.0-20201008161808-52c3e6f60cff\n+\tgolang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897\n+\tgolang.org/x/mod v0.4.0\n+\tgolang.org/x/sys v0.0.0-20201204225414-ed752295db88 // indirect\n+\tgolang.org/x/tools v0.0.0-20201211025543-abf6a1d87e11\n+)"}, {"sha": "c4913ce695456dca0988ffdf30fe40fe9d638098", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 315, "deletions": 145, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -49,10 +49,11 @@\n // \tmodules         modules, module versions, and more\n // \tmodule-get      module-aware go get\n // \tmodule-auth     module authentication using go.sum\n-// \tmodule-private  module configuration for non-public modules\n // \tpackages        package lists and patterns\n+// \tprivate         configuration for downloading non-public code\n // \ttestflag        testing flags\n // \ttestfunc        testing functions\n+// \tvcs             controlling version control with GOVCS\n //\n // Use \"go help <topic>\" for more information about that topic.\n //\n@@ -71,7 +72,7 @@\n //\n // Usage:\n //\n-// \tgo build [-o output] [-i] [build flags] [packages]\n+// \tgo build [-o output] [build flags] [packages]\n //\n // Build compiles the packages named by the import paths,\n // along with their dependencies, but it does not install the results.\n@@ -93,10 +94,12 @@\n //\n // The -o flag forces build to write the resulting executable or object\n // to the named output file or directory, instead of the default behavior described\n-// in the last two paragraphs. If the named output is a directory that exists,\n-// then any resulting executables will be written to that directory.\n+// in the last two paragraphs. If the named output is an existing directory or\n+// ends with a slash or backslash, then any resulting executables\n+// will be written to that directory.\n //\n // The -i flag installs the packages that are dependencies of the target.\n+// The -i flag is deprecated. Compiled packages are cached automatically.\n //\n // The build flags are shared by the build, clean, get, install, list, run,\n // and test commands:\n@@ -161,6 +164,17 @@\n // \t\tdirectory, but it is not accessed. When -modfile is specified, an\n // \t\talternate go.sum file is also used: its path is derived from the\n // \t\t-modfile flag by trimming the \".mod\" extension and appending \".sum\".\n+// \t-overlay file\n+// \t\tread a JSON config file that provides an overlay for build operations.\n+// \t\tThe file is a JSON struct with a single field, named 'Replace', that\n+// \t\tmaps each disk file path (a string) to its backing file path, so that\n+// \t\ta build will run as if the disk file path exists with the contents\n+// \t\tgiven by the backing file paths, or as if the disk file path does not\n+// \t\texist if its backing file path is empty. Support for the -overlay flag\n+// \t\thas some limitations:importantly, cgo files included from outside the\n+// \t\tinclude path must be  in the same directory as the Go package they are\n+// \t\tincluded from, and overlays will not appear when binaries and tests are\n+// \t\trun through go run and go test respectively.\n // \t-pkgdir dir\n // \t\tinstall and load all packages from dir instead of the usual locations.\n // \t\tFor example, when building with a non-standard configuration,\n@@ -616,15 +630,15 @@\n // dependency should be removed entirely, downgrading or removing modules\n // depending on it as needed.\n //\n-// The version suffix @latest explicitly requests the latest minor release of the\n-// module named by the given path. The suffix @upgrade is like @latest but\n+// The version suffix @latest explicitly requests the latest minor release of\n+// the module named by the given path. The suffix @upgrade is like @latest but\n // will not downgrade a module if it is already required at a revision or\n // pre-release version newer than the latest released version. The suffix\n // @patch requests the latest patch release: the latest released version\n // with the same major and minor version numbers as the currently required\n // version. Like @upgrade, @patch will not downgrade a module already required\n-// at a newer version. If the path is not already required, @upgrade and @patch\n-// are equivalent to @latest.\n+// at a newer version. If the path is not already required, @upgrade is\n+// equivalent to @latest, and @patch is disallowed.\n //\n // Although get defaults to using the latest version of the module containing\n // a named package, it does not use the latest version of that module's\n@@ -661,14 +675,27 @@\n // this automatically as well.\n //\n // The -insecure flag permits fetching from repositories and resolving\n-// custom domains using insecure schemes such as HTTP. Use with caution. The\n-// GOINSECURE environment variable is usually a better alternative, since it\n-// provides control over which modules may be retrieved using an insecure scheme.\n-// See 'go help environment' for details.\n+// custom domains using insecure schemes such as HTTP, and also bypassess\n+// module sum validation using the checksum database. Use with caution.\n+// This flag is deprecated and will be removed in a future version of go.\n+// To permit the use of insecure schemes, use the GOINSECURE environment\n+// variable instead. To bypass module sum validation, use GOPRIVATE or\n+// GONOSUMDB. See 'go help environment' for details.\n //\n // The second step is to download (if needed), build, and install\n // the named packages.\n //\n+// The -d flag instructs get to skip this step, downloading source code\n+// needed to build the named packages and their dependencies, but not\n+// building or installing.\n+//\n+// Building and installing packages with get is deprecated. In a future release,\n+// the -d flag will be enabled by default, and 'go get' will be only be used to\n+// adjust dependencies of the current module. To install a package using\n+// dependencies from the current module, use 'go install'. To install a package\n+// ignoring the current module, use 'go install' with an @version suffix like\n+// \"@latest\" after each argument.\n+//\n // If an argument names a module but not a package (because there is no\n // Go source code in the module's root directory), then the install step\n // is skipped for that argument, instead of causing a build failure.\n@@ -680,10 +707,6 @@\n // adds the latest golang.org/x/perf and then installs the commands in that\n // latest version.\n //\n-// The -d flag instructs get to download the source code needed to build\n-// the named packages, including downloading necessary dependencies,\n-// but not to build and install them.\n-//\n // With no package arguments, 'go get' applies to Go package in the\n // current directory, if any. In particular, 'go get -u' and\n // 'go get -u=patch' update all the dependencies of that package.\n@@ -706,7 +729,7 @@\n //\n // Usage:\n //\n-// \tgo install [-i] [build flags] [packages]\n+// \tgo install [build flags] [packages]\n //\n // Install compiles and installs the packages named by the import paths.\n //\n@@ -715,11 +738,39 @@\n // environment variable is not set. Executables in $GOROOT\n // are installed in $GOROOT/bin or $GOTOOLDIR instead of $GOBIN.\n //\n+// If the arguments have version suffixes (like @latest or @v1.0.0), \"go install\"\n+// builds packages in module-aware mode, ignoring the go.mod file in the current\n+// directory or any parent directory, if there is one. This is useful for\n+// installing executables without affecting the dependencies of the main module.\n+// To eliminate ambiguity about which module versions are used in the build, the\n+// arguments must satisfy the following constraints:\n+//\n+// - Arguments must be package paths or package patterns (with \"...\" wildcards).\n+//   They must not be standard packages (like fmt), meta-patterns (std, cmd,\n+//   all), or relative or absolute file paths.\n+// - All arguments must have the same version suffix. Different queries are not\n+//   allowed, even if they refer to the same version.\n+// - All arguments must refer to packages in the same module at the same version.\n+// - No module is considered the \"main\" module. If the module containing\n+//   packages named on the command line has a go.mod file, it must not contain\n+//   directives (replace and exclude) that would cause it to be interpreted\n+//   differently than if it were the main module. The module must not require\n+//   a higher version of itself.\n+// - Package path arguments must refer to main packages. Pattern arguments\n+//   will only match main packages.\n+//\n+// If the arguments don't have version suffixes, \"go install\" may run in\n+// module-aware mode or GOPATH mode, depending on the GO111MODULE environment\n+// variable and the presence of a go.mod file. See 'go help modules' for details.\n+// If module-aware mode is enabled, \"go install\" runs in the context of the main\n+// module.\n+//\n // When module-aware mode is disabled, other packages are installed in the\n // directory $GOPATH/pkg/$GOOS_$GOARCH. When module-aware mode is enabled,\n // other packages are built and cached but not installed.\n //\n // The -i flag installs the dependencies of the named packages as well.\n+// The -i flag is deprecated. Compiled packages are cached automatically.\n //\n // For more about the build flags, see 'go help build'.\n // For more about specifying packages, see 'go help packages'.\n@@ -766,26 +817,28 @@\n //         BinaryOnly    bool     // binary-only package (no longer supported)\n //         ForTest       string   // package is only for use in named test\n //         Export        string   // file containing export data (when using -export)\n+//         BuildID       string   // build ID of the compiled package (when using -export)\n //         Module        *Module  // info about package's containing module, if any (can be nil)\n //         Match         []string // command-line patterns matching this package\n //         DepOnly       bool     // package is only a dependency, not explicitly listed\n //\n //         // Source files\n-//         GoFiles         []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-//         CgoFiles        []string // .go source files that import \"C\"\n-//         CompiledGoFiles []string // .go files presented to compiler (when using -compiled)\n-//         IgnoredGoFiles  []string // .go source files ignored due to build constraints\n-//         CFiles          []string // .c source files\n-//         CXXFiles        []string // .cc, .cxx and .cpp source files\n-//         MFiles          []string // .m source files\n-//         HFiles          []string // .h, .hh, .hpp and .hxx source files\n-//         FFiles          []string // .f, .F, .for and .f90 Fortran source files\n-//         SFiles          []string // .s source files\n-//         SwigFiles       []string // .swig files\n-//         SwigCXXFiles    []string // .swigcxx files\n-//         SysoFiles       []string // .syso object files to add to archive\n-//         TestGoFiles     []string // _test.go files in package\n-//         XTestGoFiles    []string // _test.go files outside package\n+//         GoFiles         []string   // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+//         CgoFiles        []string   // .go source files that import \"C\"\n+//         CompiledGoFiles []string   // .go files presented to compiler (when using -compiled)\n+//         IgnoredGoFiles  []string   // .go source files ignored due to build constraints\n+//         IgnoredOtherFiles []string // non-.go source files ignored due to build constraints\n+//         CFiles          []string   // .c source files\n+//         CXXFiles        []string   // .cc, .cxx and .cpp source files\n+//         MFiles          []string   // .m source files\n+//         HFiles          []string   // .h, .hh, .hpp and .hxx source files\n+//         FFiles          []string   // .f, .F, .for and .f90 Fortran source files\n+//         SFiles          []string   // .s source files\n+//         SwigFiles       []string   // .swig files\n+//         SwigCXXFiles    []string   // .swigcxx files\n+//         SysoFiles       []string   // .syso object files to add to archive\n+//         TestGoFiles     []string   // _test.go files in package\n+//         XTestGoFiles    []string   // _test.go files outside package\n //\n //         // Cgo directives\n //         CgoCFLAGS    []string // cgo: flags for C compiler\n@@ -916,6 +969,7 @@\n //         Dir       string       // directory holding files for this module, if any\n //         GoMod     string       // path to go.mod file used when loading this module, if any\n //         GoVersion string       // go version used in module\n+//         Retracted string       // retraction information, if any (with -retracted or -u)\n //         Error     *ModuleError // error loading module\n //     }\n //\n@@ -947,14 +1001,16 @@\n // The -u flag adds information about available upgrades.\n // When the latest version of a given module is newer than\n // the current one, list -u sets the Module's Update field\n-// to information about the newer module.\n+// to information about the newer module. list -u will also set\n+// the module's Retracted field if the current version is retracted.\n // The Module's String method indicates an available upgrade by\n // formatting the newer version in brackets after the current version.\n+// If a version is retracted, the string \"(retracted)\" will follow it.\n // For example, 'go list -m -u all' might print:\n //\n //     my/main/module\n //     golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text\n-//     rsc.io/pdf v0.1.1 [v0.1.2]\n+//     rsc.io/pdf v0.1.1 (retracted) [v0.1.2]\n //\n // (For tools, 'go list -m -u -json all' may be more convenient to parse.)\n //\n@@ -964,6 +1020,14 @@\n // the default output format to display the module path followed by the\n // space-separated version list.\n //\n+// The -retracted flag causes list to report information about retracted\n+// module versions. When -retracted is used with -f or -json, the Retracted\n+// field will be set to a string explaining why the version was retracted.\n+// The string is taken from comments on the retract directive in the\n+// module's go.mod file. When -retracted is used with -versions, retracted\n+// versions are listed together with unretracted versions. The -retracted\n+// flag may be used with or without -m.\n+//\n // The arguments to list -m are interpreted as a list of modules, not packages.\n // The main module is the module containing the current directory.\n // The active modules are the main module and its dependencies.\n@@ -1100,9 +1164,14 @@\n // module path and version pair. If the @v is omitted, a replacement without\n // a version on the left side is dropped.\n //\n+// The -retract=version and -dropretract=version flags add and drop a\n+// retraction on the given version. The version may be a single version\n+// like \"v1.2.3\" or a closed interval like \"[v1.1.0,v1.1.9]\". Note that\n+// -retract=version is a no-op if that retraction already exists.\n+//\n // The -require, -droprequire, -exclude, -dropexclude, -replace,\n-// and -dropreplace editing flags may be repeated, and the changes\n-// are applied in the order given.\n+// -dropreplace, -retract, and -dropretract editing flags may be repeated,\n+// and the changes are applied in the order given.\n //\n // The -go=version flag sets the expected Go language version.\n //\n@@ -1136,6 +1205,15 @@\n // \t\tNew Module\n // \t}\n //\n+// \ttype Retract struct {\n+// \t\tLow       string\n+// \t\tHigh      string\n+// \t\tRationale string\n+// \t}\n+//\n+// Retract entries representing a single version (not an interval) will have\n+// the \"Low\" and \"High\" fields set to the same value.\n+//\n // Note that this only describes the go.mod file itself, not other modules\n // referred to indirectly. For the full set of modules available to a build,\n // use 'go list -m -json all'.\n@@ -1163,19 +1241,24 @@\n //\n // \tgo mod init [module]\n //\n-// Init initializes and writes a new go.mod to the current directory,\n-// in effect creating a new module rooted at the current directory.\n-// The file go.mod must not already exist.\n-// If possible, init will guess the module path from import comments\n-// (see 'go help importpath') or from version control configuration.\n-// To override this guess, supply the module path as an argument.\n+// Init initializes and writes a new go.mod file in the current directory, in\n+// effect creating a new module rooted at the current directory. The go.mod file\n+// must not already exist.\n+//\n+// Init accepts one optional argument, the module path for the new module. If the\n+// module path argument is omitted, init will attempt to infer the module path\n+// using import comments in .go files, vendoring tool configuration files (like\n+// Gopkg.lock), and the current directory (if in GOPATH).\n+//\n+// If a configuration file for a vendoring tool is present, init will attempt to\n+// import module requirements from it.\n //\n //\n // Add missing and remove unused modules\n //\n // Usage:\n //\n-// \tgo mod tidy [-v]\n+// \tgo mod tidy [-e] [-v]\n //\n // Tidy makes sure go.mod matches the source code in the module.\n // It adds any missing modules necessary to build the current module's\n@@ -1186,12 +1269,15 @@\n // The -v flag causes tidy to print information about removed modules\n // to standard error.\n //\n+// The -e flag causes tidy to attempt to proceed despite errors\n+// encountered while loading packages.\n+//\n //\n // Make vendored copy of dependencies\n //\n // Usage:\n //\n-// \tgo mod vendor [-v]\n+// \tgo mod vendor [-e] [-v]\n //\n // Vendor resets the main module's vendor directory to include all packages\n // needed to build and test all the main module's packages.\n@@ -1200,6 +1286,9 @@\n // The -v flag causes vendor to print the names of vendored\n // modules and packages to standard error.\n //\n+// The -e flag causes vendor to attempt to proceed despite errors\n+// encountered while loading packages.\n+//\n //\n // Verify dependencies have expected content\n //\n@@ -1388,6 +1477,7 @@\n // \t-i\n // \t    Install packages that are dependencies of the test.\n // \t    Do not run the test.\n+// \t    The -i flag is deprecated. Compiled packages are cached automatically.\n //\n // \t-json\n // \t    Convert test output to JSON suitable for automated processing.\n@@ -1546,6 +1636,9 @@\n // Using GOOS=illumos matches build tags and files as for GOOS=solaris\n // in addition to illumos tags and files.\n //\n+// Using GOOS=ios matches build tags and files as for GOOS=darwin\n+// in addition to ios tags and files.\n+//\n // To keep a file from being considered for the build:\n //\n // \t// +build ignore\n@@ -1733,7 +1826,7 @@\n // \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n // \t\tof module path prefixes that should always be fetched directly\n // \t\tor that should not be compared against the checksum database.\n-// \t\tSee 'go help module-private'.\n+// \t\tSee 'go help private'.\n // \tGOROOT\n // \t\tThe root of the go tree.\n // \tGOSUMDB\n@@ -1789,8 +1882,8 @@\n // \t\tFor GOARCH=arm, the ARM architecture for which to compile.\n // \t\tValid values are 5, 6, 7.\n // \tGO386\n-// \t\tFor GOARCH=386, the floating point instruction set.\n-// \t\tValid values are 387, sse2.\n+// \t\tFor GOARCH=386, how to implement floating point instructions.\n+// \t\tValid values are sse2 (default), softfloat.\n // \tGOMIPS\n // \t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n // \t\tValid values are hardfloat (default), softfloat.\n@@ -1839,6 +1932,8 @@\n // \t\tIf module-aware mode is disabled, GOMOD will be the empty string.\n // \tGOTOOLDIR\n // \t\tThe directory where the go tools (compile, cover, doc, etc...) are installed.\n+// \tGOVERSION\n+// \t\tThe version of the installed Go tree, as reported by runtime.Version.\n //\n //\n // File types\n@@ -1894,21 +1989,23 @@\n // \trequire new/thing/v2 v2.3.4\n // \texclude old/thing v1.2.3\n // \treplace bad/thing v1.4.5 => good/thing v1.4.5\n+// \tretract v1.5.6\n //\n // The verbs are\n // \tmodule, to define the module path;\n // \tgo, to set the expected language version;\n // \trequire, to require a particular module at a given version or later;\n-// \texclude, to exclude a particular module version from use; and\n-// \treplace, to replace a module version with a different module version.\n+// \texclude, to exclude a particular module version from use;\n+// \treplace, to replace a module version with a different module version; and\n+// \tretract, to indicate a previously released version should not be used.\n // Exclude and replace apply only in the main module's go.mod and are ignored\n-// in dependencies.  See https://research.swtch.com/vgo-mvs for details.\n+// in dependencies.  See https://golang.org/ref/mod for details.\n //\n // The leading verb can be factored out of adjacent lines to create a block,\n // like in Go imports:\n //\n // \trequire (\n-// \t\tnew/thing v2.3.4\n+// \t\tnew/thing/v2 v2.3.4\n // \t\told/thing v1.2.3\n // \t)\n //\n@@ -2146,6 +2243,10 @@\n //\n // The -insecure flag permits fetching from repositories and resolving\n // custom domains using insecure schemes such as HTTP. Use with caution.\n+// This flag is deprecated and will be removed in a future version of go.\n+// The GOINSECURE environment variable should be used instead, since it\n+// provides control over which packages may be retrieved using an insecure\n+// scheme. See 'go help environment' for details.\n //\n // The -t flag instructs get to also download the packages required to build\n // the tests for the specified packages.\n@@ -2556,72 +2657,63 @@\n //\n // Maintaining module requirements\n //\n-// The go.mod file is meant to be readable and editable by both\n-// programmers and tools. The go command itself automatically updates the go.mod file\n-// to maintain a standard formatting and the accuracy of require statements.\n-//\n-// Any go command that finds an unfamiliar import will look up the module\n-// containing that import and add the latest version of that module\n-// to go.mod automatically. In most cases, therefore, it suffices to\n-// add an import to source code and run 'go build', 'go test', or even 'go list':\n-// as part of analyzing the package, the go command will discover\n-// and resolve the import and update the go.mod file.\n-//\n-// Any go command can determine that a module requirement is\n-// missing and must be added, even when considering only a single\n-// package from the module. On the other hand, determining that a module requirement\n-// is no longer necessary and can be deleted requires a full view of\n-// all packages in the module, across all possible build configurations\n-// (architectures, operating systems, build tags, and so on).\n-// The 'go mod tidy' command builds that view and then\n-// adds any missing module requirements and removes unnecessary ones.\n+// The go.mod file is meant to be readable and editable by both programmers and\n+// tools. Most updates to dependencies can be performed using \"go get\" and\n+// \"go mod tidy\". Other module-aware build commands may be invoked using the\n+// -mod=mod flag to automatically add missing requirements and fix inconsistencies.\n+//\n+// The \"go get\" command updates go.mod to change the module versions used in a\n+// build. An upgrade of one module may imply upgrading others, and similarly a\n+// downgrade of one module may imply downgrading others. The \"go get\" command\n+// makes these implied changes as well. See \"go help module-get\".\n+//\n+// The \"go mod\" command provides other functionality for use in maintaining\n+// and understanding modules and go.mod files. See \"go help mod\", particularly\n+// \"go help mod tidy\" and \"go help mod edit\".\n //\n // As part of maintaining the require statements in go.mod, the go command\n // tracks which ones provide packages imported directly by the current module\n // and which ones provide packages only used indirectly by other module\n // dependencies. Requirements needed only for indirect uses are marked with a\n-// \"// indirect\" comment in the go.mod file. Indirect requirements are\n+// \"// indirect\" comment in the go.mod file. Indirect requirements may be\n // automatically removed from the go.mod file once they are implied by other\n // direct requirements. Indirect requirements only arise when using modules\n // that fail to state some of their own dependencies or when explicitly\n // upgrading a module's dependencies ahead of its own stated requirements.\n //\n-// Because of this automatic maintenance, the information in go.mod is an\n-// up-to-date, readable description of the build.\n-//\n-// The 'go get' command updates go.mod to change the module versions used in a\n-// build. An upgrade of one module may imply upgrading others, and similarly a\n-// downgrade of one module may imply downgrading others. The 'go get' command\n-// makes these implied changes as well. If go.mod is edited directly, commands\n-// like 'go build' or 'go list' will assume that an upgrade is intended and\n-// automatically make any implied upgrades and update go.mod to reflect them.\n-//\n-// The 'go mod' command provides other functionality for use in maintaining\n-// and understanding modules and go.mod files. See 'go help mod'.\n-//\n-// The -mod build flag provides additional control over updating and use of go.mod.\n-//\n-// If invoked with -mod=readonly, the go command is disallowed from the implicit\n-// automatic updating of go.mod described above. Instead, it fails when any changes\n-// to go.mod are needed. This setting is most useful to check that go.mod does\n-// not need updates, such as in a continuous integration and testing system.\n-// The \"go get\" command remains permitted to update go.mod even with -mod=readonly,\n-// and the \"go mod\" commands do not take the -mod flag (or any other build flags).\n+// The -mod build flag provides additional control over the updating and use of\n+// go.mod for commands that build packages like \"go build\" and \"go test\".\n+//\n+// If invoked with -mod=readonly (the default in most situations), the go command\n+// reports an error if a package named on the command line or an imported package\n+// is not provided by any module in the build list computed from the main module's\n+// requirements. The go command also reports an error if a module's checksum is\n+// missing from go.sum (see Module downloading and verification). Either go.mod or\n+// go.sum must be updated in these situations.\n+//\n+// If invoked with -mod=mod, the go command automatically updates go.mod and\n+// go.sum, fixing inconsistencies and adding missing requirements and checksums\n+// as needed. If the go command finds an unfamiliar import, it looks up the\n+// module containing that import and adds a requirement for the latest version\n+// of that module to go.mod. In most cases, therefore, one may add an import to\n+// source code and run \"go build\", \"go test\", or even \"go list\" with -mod=mod:\n+// as part of analyzing the package, the go command will resolve the import and\n+// update the go.mod file.\n //\n // If invoked with -mod=vendor, the go command loads packages from the main\n // module's vendor directory instead of downloading modules to and loading packages\n // from the module cache. The go command assumes the vendor directory holds\n // correct copies of dependencies, and it does not compute the set of required\n // module versions from go.mod files. However, the go command does check that\n-// vendor/modules.txt (generated by 'go mod vendor') contains metadata consistent\n+// vendor/modules.txt (generated by \"go mod vendor\") contains metadata consistent\n // with go.mod.\n //\n-// If invoked with -mod=mod, the go command loads modules from the module cache\n-// even if there is a vendor directory present.\n+// If the go command is not invoked with a -mod flag, and the vendor directory\n+// is present, and the \"go\" version in go.mod is 1.14 or higher, the go command\n+// will act as if it were invoked with -mod=vendor. Otherwise, the -mod flag\n+// defaults to -mod=readonly.\n //\n-// If the go command is not invoked with a -mod flag and the vendor directory\n-// is present and the \"go\" version in go.mod is 1.14 or higher, the go command\n-// will act as if it were invoked with -mod=vendor.\n+// Note that neither \"go get\" nor the \"go mod\" subcommands accept the -mod flag.\n //\n // Pseudo-versions\n //\n@@ -2806,7 +2898,7 @@\n // followed by a pipe character, indicating it is safe to fall back on any error.\n //\n // The GOPRIVATE and GONOPROXY environment variables allow bypassing\n-// the proxy for selected modules. See 'go help module-private' for details.\n+// the proxy for selected modules. See 'go help private' for details.\n //\n // No matter the source of the modules, the go command checks downloads against\n // known checksums, to detect unexpected changes in the content of any specific\n@@ -2926,52 +3018,7 @@\n // accepted, at the cost of giving up the security guarantee of verified repeatable\n // downloads for all modules. A better way to bypass the checksum database\n // for specific modules is to use the GOPRIVATE or GONOSUMDB environment\n-// variables. See 'go help module-private' for details.\n-//\n-// The 'go env -w' command (see 'go help env') can be used to set these variables\n-// for future go command invocations.\n-//\n-//\n-// Module configuration for non-public modules\n-//\n-// The go command defaults to downloading modules from the public Go module\n-// mirror at proxy.golang.org. It also defaults to validating downloaded modules,\n-// regardless of source, against the public Go checksum database at sum.golang.org.\n-// These defaults work well for publicly available source code.\n-//\n-// The GOPRIVATE environment variable controls which modules the go command\n-// considers to be private (not available publicly) and should therefore not use the\n-// proxy or checksum database. The variable is a comma-separated list of\n-// glob patterns (in the syntax of Go's path.Match) of module path prefixes.\n-// For example,\n-//\n-// \tGOPRIVATE=*.corp.example.com,rsc.io/private\n-//\n-// causes the go command to treat as private any module with a path prefix\n-// matching either pattern, including git.corp.example.com/xyzzy, rsc.io/private,\n-// and rsc.io/private/quux.\n-//\n-// The GOPRIVATE environment variable may be used by other tools as well to\n-// identify non-public modules. For example, an editor could use GOPRIVATE\n-// to decide whether to hyperlink a package import to a godoc.org page.\n-//\n-// For fine-grained control over module download and validation, the GONOPROXY\n-// and GONOSUMDB environment variables accept the same kind of glob list\n-// and override GOPRIVATE for the specific decision of whether to use the proxy\n-// and checksum database, respectively.\n-//\n-// For example, if a company ran a module proxy serving private modules,\n-// users would configure go using:\n-//\n-// \tGOPRIVATE=*.corp.example.com\n-// \tGOPROXY=proxy.example.com\n-// \tGONOPROXY=none\n-//\n-// This would tell the go command and other tools that modules beginning with\n-// a corp.example.com subdomain are private but that the company proxy should\n-// be used for downloading both public and private modules, because\n-// GONOPROXY has been set to a pattern that won't match any modules,\n-// overriding GOPRIVATE.\n+// variables. See 'go help private' for details.\n //\n // The 'go env -w' command (see 'go help env') can be used to set these variables\n // for future go command invocations.\n@@ -3061,6 +3108,56 @@\n // by the go tool, as are directories named \"testdata\".\n //\n //\n+// Configuration for downloading non-public code\n+//\n+// The go command defaults to downloading modules from the public Go module\n+// mirror at proxy.golang.org. It also defaults to validating downloaded modules,\n+// regardless of source, against the public Go checksum database at sum.golang.org.\n+// These defaults work well for publicly available source code.\n+//\n+// The GOPRIVATE environment variable controls which modules the go command\n+// considers to be private (not available publicly) and should therefore not use the\n+// proxy or checksum database. The variable is a comma-separated list of\n+// glob patterns (in the syntax of Go's path.Match) of module path prefixes.\n+// For example,\n+//\n+// \tGOPRIVATE=*.corp.example.com,rsc.io/private\n+//\n+// causes the go command to treat as private any module with a path prefix\n+// matching either pattern, including git.corp.example.com/xyzzy, rsc.io/private,\n+// and rsc.io/private/quux.\n+//\n+// The GOPRIVATE environment variable may be used by other tools as well to\n+// identify non-public modules. For example, an editor could use GOPRIVATE\n+// to decide whether to hyperlink a package import to a godoc.org page.\n+//\n+// For fine-grained control over module download and validation, the GONOPROXY\n+// and GONOSUMDB environment variables accept the same kind of glob list\n+// and override GOPRIVATE for the specific decision of whether to use the proxy\n+// and checksum database, respectively.\n+//\n+// For example, if a company ran a module proxy serving private modules,\n+// users would configure go using:\n+//\n+// \tGOPRIVATE=*.corp.example.com\n+// \tGOPROXY=proxy.example.com\n+// \tGONOPROXY=none\n+//\n+// This would tell the go command and other tools that modules beginning with\n+// a corp.example.com subdomain are private but that the company proxy should\n+// be used for downloading both public and private modules, because\n+// GONOPROXY has been set to a pattern that won't match any modules,\n+// overriding GOPRIVATE.\n+//\n+// The GOPRIVATE variable is also used to define the \"public\" and \"private\"\n+// patterns for the GOVCS variable; see 'go help vcs'. For that usage,\n+// GOPRIVATE applies even in GOPATH mode. In that case, it matches import paths\n+// instead of module paths.\n+//\n+// The 'go env -w' command (see 'go help env') can be used to set these variables\n+// for future go command invocations.\n+//\n+//\n // Testing flags\n //\n // The 'go test' command takes both flags that apply to 'go test' itself\n@@ -3353,4 +3450,77 @@\n // See the documentation of the testing package for more information.\n //\n //\n+// Controlling version control with GOVCS\n+//\n+// The 'go get' command can run version control commands like git\n+// to download imported code. This functionality is critical to the decentralized\n+// Go package ecosystem, in which code can be imported from any server,\n+// but it is also a potential security problem, if a malicious server finds a\n+// way to cause the invoked version control command to run unintended code.\n+//\n+// To balance the functionality and security concerns, the 'go get' command\n+// by default will only use git and hg to download code from public servers.\n+// But it will use any known version control system (bzr, fossil, git, hg, svn)\n+// to download code from private servers, defined as those hosting packages\n+// matching the GOPRIVATE variable (see 'go help private'). The rationale behind\n+// allowing only Git and Mercurial is that these two systems have had the most\n+// attention to issues of being run as clients of untrusted servers. In contrast,\n+// Bazaar, Fossil, and Subversion have primarily been used in trusted,\n+// authenticated environments and are not as well scrutinized as attack surfaces.\n+//\n+// The version control command restrictions only apply when using direct version\n+// control access to download code. When downloading modules from a proxy,\n+// 'go get' uses the proxy protocol instead, which is always permitted.\n+// By default, the 'go get' command uses the Go module mirror (proxy.golang.org)\n+// for public packages and only falls back to version control for private\n+// packages or when the mirror refuses to serve a public package (typically for\n+// legal reasons). Therefore, clients can still access public code served from\n+// Bazaar, Fossil, or Subversion repositories by default, because those downloads\n+// use the Go module mirror, which takes on the security risk of running the\n+// version control commands, using a custom sandbox.\n+//\n+// The GOVCS variable can be used to change the allowed version control systems\n+// for specific packages (identified by a module or import path).\n+// The GOVCS variable applies both when using modules and when using GOPATH.\n+// When using modules, the patterns match against the module path.\n+// When using GOPATH, the patterns match against the import path\n+// corresponding to the root of the version control repository.\n+//\n+// The general form of the GOVCS setting is a comma-separated list of\n+// pattern:vcslist rules. The pattern is a glob pattern that must match\n+// one or more leading elements of the module or import path. The vcslist\n+// is a pipe-separated list of allowed version control commands, or \"all\"\n+// to allow use of any known command, or \"off\" to allow nothing.\n+// The earliest matching pattern in the list applies, even if later patterns\n+// might also match.\n+//\n+// For example, consider:\n+//\n+// \tGOVCS=github.com:git,evil.com:off,*:git|hg\n+//\n+// With this setting, code with an module or import path beginning with\n+// github.com/ can only use git; paths on evil.com cannot use any version\n+// control command, and all other paths (* matches everything) can use\n+// only git or hg.\n+//\n+// The special patterns \"public\" and \"private\" match public and private\n+// module or import paths. A path is private if it matches the GOPRIVATE\n+// variable; otherwise it is public.\n+//\n+// If no rules in the GOVCS variable match a particular module or import path,\n+// the 'go get' command applies its default rule, which can now be summarized\n+// in GOVCS notation as 'public:git|hg,private:all'.\n+//\n+// To allow unfettered use of any version control system for any package, use:\n+//\n+// \tGOVCS=*:all\n+//\n+// To disable all use of version control, use:\n+//\n+// \tGOVCS=*:off\n+//\n+// The 'go env -w' command (see 'go help env') can be used to set the GOVCS\n+// variable for future go command invocations.\n+//\n+//\n package main"}, {"sha": "c472620db2960008d1116215c5587b90b87802ef", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 118, "deletions": 78, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,13 +9,14 @@ import (\n \t\"debug/elf\"\n \t\"debug/macho\"\n \t\"debug/pe\"\n+\t\"encoding/binary\"\n \t\"flag\"\n \t\"fmt\"\n \t\"go/format\"\n \t\"internal/race\"\n \t\"internal/testenv\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -30,77 +31,42 @@ import (\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/robustio\"\n+\t\"cmd/go/internal/work\"\n \t\"cmd/internal/sys\"\n )\n \n+func init() {\n+\t// GOVCS defaults to public:git|hg,private:all,\n+\t// which breaks many tests here - they can't use non-git, non-hg VCS at all!\n+\t// Change to fully permissive.\n+\t// The tests of the GOVCS setting itself are in ../../testdata/script/govcs.txt.\n+\tos.Setenv(\"GOVCS\", \"*:all\")\n+}\n+\n var (\n-\tcanRun  = true  // whether we can run go or ./testgo\n \tcanRace = false // whether we can run the race detector\n \tcanCgo  = false // whether we can use cgo\n \tcanMSan = false // whether we can run the memory sanitizer\n-\n-\texeSuffix string // \".exe\" on Windows\n-\n-\tskipExternal = false // skip external tests\n )\n \n+var exeSuffix string = func() string {\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn \".exe\"\n+\t}\n+\treturn \"\"\n+}()\n+\n func tooSlow(t *testing.T) {\n \tif testing.Short() {\n \t\t// In -short mode; skip test, except run it on the {darwin,linux,windows}/amd64 builders.\n \t\tif testenv.Builder() != \"\" && runtime.GOARCH == \"amd64\" && (runtime.GOOS == \"linux\" || runtime.GOOS == \"darwin\" || runtime.GOOS == \"windows\") {\n \t\t\treturn\n \t\t}\n+\t\tt.Helper()\n \t\tt.Skip(\"skipping test in -short mode\")\n \t}\n }\n \n-func init() {\n-\tswitch runtime.GOOS {\n-\tcase \"android\", \"js\":\n-\t\tcanRun = false\n-\tcase \"darwin\":\n-\t\tswitch runtime.GOARCH {\n-\t\tcase \"arm64\":\n-\t\t\tcanRun = false\n-\t\t}\n-\tcase \"linux\":\n-\t\tswitch runtime.GOARCH {\n-\t\tcase \"arm\":\n-\t\t\t// many linux/arm machines are too slow to run\n-\t\t\t// the full set of external tests.\n-\t\t\tskipExternal = true\n-\t\tcase \"mips\", \"mipsle\", \"mips64\", \"mips64le\":\n-\t\t\t// Also slow.\n-\t\t\tskipExternal = true\n-\t\t\tif testenv.Builder() != \"\" {\n-\t\t\t\t// On the builders, skip the cmd/go\n-\t\t\t\t// tests. They're too slow and already\n-\t\t\t\t// covered by other ports. There's\n-\t\t\t\t// nothing os/arch specific in the\n-\t\t\t\t// tests.\n-\t\t\t\tcanRun = false\n-\t\t\t}\n-\t\t}\n-\tcase \"freebsd\":\n-\t\tswitch runtime.GOARCH {\n-\t\tcase \"arm\":\n-\t\t\t// many freebsd/arm machines are too slow to run\n-\t\t\t// the full set of external tests.\n-\t\t\tskipExternal = true\n-\t\t\tcanRun = false\n-\t\t}\n-\tcase \"plan9\":\n-\t\tswitch runtime.GOARCH {\n-\t\tcase \"arm\":\n-\t\t\t// many plan9/arm machines are too slow to run\n-\t\t\t// the full set of external tests.\n-\t\t\tskipExternal = true\n-\t\t}\n-\tcase \"windows\":\n-\t\texeSuffix = \".exe\"\n-\t}\n-}\n-\n // testGOROOT is the GOROOT to use when running testgo, a cmd/go binary\n // build from this process's current GOROOT, but run from a different\n // (temp) directory.\n@@ -134,7 +100,7 @@ func TestMain(m *testing.M) {\n \n \t// Run with a temporary TMPDIR to check that the tests don't\n \t// leave anything behind.\n-\ttopTmpdir, err := ioutil.TempDir(\"\", \"cmd-go-test-\")\n+\ttopTmpdir, err := os.MkdirTemp(\"\", \"cmd-go-test-\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n@@ -143,7 +109,7 @@ func TestMain(m *testing.M) {\n \t}\n \tos.Setenv(tempEnvName(), topTmpdir)\n \n-\tdir, err := ioutil.TempDir(topTmpdir, \"tmpdir\")\n+\tdir, err := os.MkdirTemp(topTmpdir, \"tmpdir\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n@@ -153,7 +119,7 @@ func TestMain(m *testing.M) {\n \t}\n \n \ttestGOCACHE = cache.DefaultDir()\n-\tif canRun {\n+\tif testenv.HasGoBuild() {\n \t\ttestBin = filepath.Join(testTmpDir, \"testbin\")\n \t\tif err := os.Mkdir(testBin, 0777); err != nil {\n \t\t\tlog.Fatal(err)\n@@ -224,7 +190,7 @@ func TestMain(m *testing.M) {\n \t\tcmd.Stderr = new(strings.Builder)\n \t\tif out, err := cmd.Output(); err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"running testgo failed: %v\\n%s\", err, cmd.Stderr)\n-\t\t\tcanRun = false\n+\t\t\tos.Exit(2)\n \t\t} else {\n \t\t\tcanCgo, err = strconv.ParseBool(strings.TrimSpace(string(out)))\n \t\t\tif err != nil {\n@@ -324,10 +290,7 @@ func skipIfGccgo(t *testing.T, msg string) {\n func testgo(t *testing.T) *testgoData {\n \tt.Helper()\n \ttestenv.MustHaveGoBuild(t)\n-\n-\tif skipExternal {\n-\t\tt.Skipf(\"skipping external tests on %s/%s\", runtime.GOOS, runtime.GOARCH)\n-\t}\n+\ttestenv.SkipIfShortAndSlow(t)\n \n \treturn &testgoData{t: t}\n }\n@@ -416,9 +379,6 @@ func (tg *testgoData) goTool() string {\n // returning exit status.\n func (tg *testgoData) doRun(args []string) error {\n \ttg.t.Helper()\n-\tif !canRun {\n-\t\tpanic(\"testgoData.doRun called but canRun false\")\n-\t}\n \tif tg.inParallel {\n \t\tfor _, arg := range args {\n \t\t\tif strings.HasPrefix(arg, \"testdata\") || strings.HasPrefix(arg, \"./testdata\") {\n@@ -656,7 +616,7 @@ func (tg *testgoData) makeTempdir() {\n \ttg.t.Helper()\n \tif tg.tempdir == \"\" {\n \t\tvar err error\n-\t\ttg.tempdir, err = ioutil.TempDir(\"\", \"gotest\")\n+\t\ttg.tempdir, err = os.MkdirTemp(\"\", \"gotest\")\n \t\ttg.must(err)\n \t}\n }\n@@ -673,7 +633,7 @@ func (tg *testgoData) tempFile(path, contents string) {\n \t\t\tbytes = formatted\n \t\t}\n \t}\n-\ttg.must(ioutil.WriteFile(filepath.Join(tg.tempdir, path), bytes, 0644))\n+\ttg.must(os.WriteFile(filepath.Join(tg.tempdir, path), bytes, 0644))\n }\n \n // tempDir adds a temporary directory for a run of testgo.\n@@ -814,7 +774,7 @@ func (tg *testgoData) cleanup() {\n func removeAll(dir string) error {\n \t// module cache has 0444 directories;\n \t// make them writable in order to remove content.\n-\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n+\tfilepath.WalkDir(dir, func(path string, info fs.DirEntry, err error) error {\n \t\t// chmod not only directories, but also things that we couldn't even stat\n \t\t// due to permission errors: they may also be unreadable directories.\n \t\tif err != nil || info.IsDir() {\n@@ -860,8 +820,8 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \t} {\n \t\tsrcdir := filepath.Join(testGOROOT, copydir)\n \t\ttg.tempDir(filepath.Join(\"goroot\", copydir))\n-\t\terr := filepath.Walk(srcdir,\n-\t\t\tfunc(path string, info os.FileInfo, err error) error {\n+\t\terr := filepath.WalkDir(srcdir,\n+\t\t\tfunc(path string, info fs.DirEntry, err error) error {\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn err\n \t\t\t\t}\n@@ -873,13 +833,13 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \t\t\t\t\treturn err\n \t\t\t\t}\n \t\t\t\tdest := filepath.Join(\"goroot\", copydir, srcrel)\n-\t\t\t\tdata, err := ioutil.ReadFile(path)\n+\t\t\t\tdata, err := os.ReadFile(path)\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn err\n \t\t\t\t}\n \t\t\t\ttg.tempFile(dest, string(data))\n-\t\t\t\tif err := os.Chmod(tg.path(dest), info.Mode()|0200); err != nil {\n-\t\t\t\t\treturn err\n+\t\t\t\tif strings.Contains(copydir, filepath.Join(\"pkg\", \"tool\")) {\n+\t\t\t\t\tos.Chmod(tg.path(dest), 0777)\n \t\t\t\t}\n \t\t\t\treturn nil\n \t\t\t})\n@@ -890,18 +850,18 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \ttg.setenv(\"GOROOT\", tg.path(\"goroot\"))\n \n \taddVar := func(name string, idx int) (restore func()) {\n-\t\tdata, err := ioutil.ReadFile(name)\n+\t\tdata, err := os.ReadFile(name)\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t\told := data\n \t\tdata = append(data, fmt.Sprintf(\"var DummyUnusedVar%d bool\\n\", idx)...)\n-\t\tif err := ioutil.WriteFile(name, append(data, '\\n'), 0666); err != nil {\n+\t\tif err := os.WriteFile(name, append(data, '\\n'), 0666); err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t\ttg.sleep()\n \t\treturn func() {\n-\t\t\tif err := ioutil.WriteFile(name, old, 0666); err != nil {\n+\t\t\tif err := os.WriteFile(name, old, 0666); err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \t\t}\n@@ -1237,6 +1197,18 @@ func TestGoListExport(t *testing.T) {\n \tif _, err := os.Stat(file); err != nil {\n \t\tt.Fatalf(\"cannot find .Export result %s: %v\", file, err)\n \t}\n+\n+\ttg.run(\"list\", \"-export\", \"-f\", \"{{.BuildID}}\", \"strings\")\n+\tbuildID := strings.TrimSpace(tg.stdout.String())\n+\tif buildID == \"\" {\n+\t\tt.Fatalf(\".BuildID with -export was empty\")\n+\t}\n+\n+\ttg.run(\"tool\", \"buildid\", file)\n+\ttoolBuildID := strings.TrimSpace(tg.stdout.String())\n+\tif buildID != toolBuildID {\n+\t\tt.Fatalf(\".BuildID with -export %q disagrees with 'go tool buildid' %q\", buildID, toolBuildID)\n+\t}\n }\n \n // Issue 4096. Validate the output of unsuccessful go install foo/quxx.\n@@ -1394,6 +1366,30 @@ func TestLdflagsArgumentsWithSpacesIssue3941(t *testing.T) {\n \ttg.grepStderr(\"^hello world\", `ldflags -X \"main.extern=hello world\"' failed`)\n }\n \n+func TestLdFlagsLongArgumentsIssue42295(t *testing.T) {\n+\t// Test the extremely long command line arguments that contain '\\n' characters\n+\t// get encoded and passed correctly.\n+\tskipIfGccgo(t, \"gccgo does not support -ldflags -X\")\n+\ttooSlow(t)\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"main.go\", `package main\n+\t\tvar extern string\n+\t\tfunc main() {\n+\t\t\tprint(extern)\n+\t\t}`)\n+\ttestStr := \"test test test test test \\n\\\\ \"\n+\tvar buf bytes.Buffer\n+\tfor buf.Len() < work.ArgLengthForResponseFile+1 {\n+\t\tbuf.WriteString(testStr)\n+\t}\n+\ttg.run(\"run\", \"-ldflags\", fmt.Sprintf(`-X \"main.extern=%s\"`, buf.String()), tg.path(\"main.go\"))\n+\tif tg.stderr.String() != buf.String() {\n+\t\tt.Errorf(\"strings differ\")\n+\t}\n+}\n+\n func TestGoTestDashCDashOControlsBinaryLocation(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n \ttooSlow(t)\n@@ -1914,6 +1910,18 @@ func TestGoEnv(t *testing.T) {\n \ttg.grepStdout(\"gcc\", \"CC not found\")\n \ttg.run(\"env\", \"GOGCCFLAGS\")\n \ttg.grepStdout(\"-ffaster\", \"CC arguments not found\")\n+\n+\ttg.run(\"env\", \"GOVERSION\")\n+\tenvVersion := strings.TrimSpace(tg.stdout.String())\n+\n+\ttg.run(\"version\")\n+\tcmdVersion := strings.TrimSpace(tg.stdout.String())\n+\n+\t// If 'go version' is \"go version <version> <goos>/<goarch>\", then\n+\t// 'go env GOVERSION' is just \"<version>\".\n+\tif cmdVersion == envVersion || !strings.Contains(cmdVersion, envVersion) {\n+\t\tt.Fatalf(\"'go env GOVERSION' %q should be a shorter substring of 'go version' %q\", envVersion, cmdVersion)\n+\t}\n }\n \n const (\n@@ -2019,7 +2027,7 @@ func main() {\n \ttg.run(\"build\", \"-o\", exe, \"p\")\n }\n \n-func copyFile(src, dst string, perm os.FileMode) error {\n+func copyFile(src, dst string, perm fs.FileMode) error {\n \tsf, err := os.Open(src)\n \tif err != nil {\n \t\treturn err\n@@ -2058,7 +2066,7 @@ func TestBuildmodePIE(t *testing.T) {\n \n \tplatform := fmt.Sprintf(\"%s/%s\", runtime.GOOS, runtime.GOARCH)\n \tswitch platform {\n-\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\",\n+\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/riscv64\", \"linux/s390x\",\n \t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\",\n \t\t\"freebsd/amd64\",\n \t\t\"windows/386\", \"windows/amd64\", \"windows/arm\":\n@@ -2166,6 +2174,38 @@ func testBuildmodePIE(t *testing.T, useCgo, setBuildmodeToPIE bool) {\n \t\tif (dc & pe.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) == 0 {\n \t\t\tt.Error(\"IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE flag is not set\")\n \t\t}\n+\t\tif useCgo {\n+\t\t\t// Test that only one symbol is exported (#40795).\n+\t\t\t// PIE binaries don\u00b4t require .edata section but unfortunately\n+\t\t\t// binutils doesn\u00b4t generate a .reloc section unless there is\n+\t\t\t// at least one symbol exported.\n+\t\t\t// See https://sourceware.org/bugzilla/show_bug.cgi?id=19011\n+\t\t\tsection := f.Section(\".edata\")\n+\t\t\tif section == nil {\n+\t\t\t\tt.Fatalf(\".edata section is not present\")\n+\t\t\t}\n+\t\t\t// TODO: deduplicate this struct from cmd/link/internal/ld/pe.go\n+\t\t\ttype IMAGE_EXPORT_DIRECTORY struct {\n+\t\t\t\t_                 [2]uint32\n+\t\t\t\t_                 [2]uint16\n+\t\t\t\t_                 [2]uint32\n+\t\t\t\tNumberOfFunctions uint32\n+\t\t\t\tNumberOfNames     uint32\n+\t\t\t\t_                 [3]uint32\n+\t\t\t}\n+\t\t\tvar e IMAGE_EXPORT_DIRECTORY\n+\t\t\tif err := binary.Read(section.Open(), binary.LittleEndian, &e); err != nil {\n+\t\t\t\tt.Fatalf(\"binary.Read failed: %v\", err)\n+\t\t\t}\n+\n+\t\t\t// Only _cgo_dummy_export should be exported\n+\t\t\tif e.NumberOfFunctions != 1 {\n+\t\t\t\tt.Fatalf(\"got %d exported functions; want 1\", e.NumberOfFunctions)\n+\t\t\t}\n+\t\t\tif e.NumberOfNames != 1 {\n+\t\t\t\tt.Fatalf(\"got %d exported names; want 1\", e.NumberOfNames)\n+\t\t\t}\n+\t\t}\n \tdefault:\n \t\tpanic(\"unreachable\")\n \t}\n@@ -2658,7 +2698,7 @@ echo $* >>`+tg.path(\"pkg-config.out\"))\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.setenv(\"PKG_CONFIG\", tg.path(\"pkg-config.sh\"))\n \ttg.run(\"build\", \"x\")\n-\tout, err := ioutil.ReadFile(tg.path(\"pkg-config.out\"))\n+\tout, err := os.ReadFile(tg.path(\"pkg-config.out\"))\n \ttg.must(err)\n \tout = bytes.TrimSpace(out)\n \twant := \"--cflags --static --static -- a a\\n--libs --static --static -- a a\""}, {"sha": "3094212bae2bfd2ecd45051c548759d7b529fe55", "filename": "libgo/go/cmd/go/go_windows_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -2,11 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package main_test\n \n import (\n-\t\"internal/testenv\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -17,16 +15,18 @@ import (\n )\n \n func TestAbsolutePath(t *testing.T) {\n-\tt.Parallel()\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n \n-\ttmp, err := ioutil.TempDir(\"\", \"TestAbsolutePath\")\n+\ttmp, err := os.MkdirTemp(\"\", \"TestAbsolutePath\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n \tdefer robustio.RemoveAll(tmp)\n \n \tfile := filepath.Join(tmp, \"a.go\")\n-\terr = ioutil.WriteFile(file, []byte{}, 0644)\n+\terr = os.WriteFile(file, []byte{}, 0644)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -38,7 +38,7 @@ func TestAbsolutePath(t *testing.T) {\n \n \tnoVolume := file[len(filepath.VolumeName(file)):]\n \twrongPath := filepath.Join(dir, noVolume)\n-\tcmd := exec.Command(testenv.GoToolPath(t), \"build\", noVolume)\n+\tcmd := exec.Command(tg.goTool(), \"build\", noVolume)\n \tcmd.Dir = dir\n \toutput, err := cmd.CombinedOutput()\n \tif err == nil {"}, {"sha": "abfc3db9936bb909dc180026506a0090fdc58a16", "filename": "libgo/go/cmd/go/help_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,7 +6,7 @@ package main_test\n \n import (\n \t\"bytes\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"cmd/go/internal/help\"\n@@ -23,7 +23,7 @@ func TestDocsUpToDate(t *testing.T) {\n \tbuf := new(bytes.Buffer)\n \t// Match the command in mkalldocs.sh that generates alldocs.go.\n \thelp.Help(buf, []string{\"documentation\"})\n-\tdata, err := ioutil.ReadFile(\"alldocs.go\")\n+\tdata, err := os.ReadFile(\"alldocs.go\")\n \tif err != nil {\n \t\tt.Fatalf(\"error reading alldocs.go: %v\", err)\n \t}"}, {"sha": "5a5cbe529368a2e74d405d0d1572f9378218d32b", "filename": "libgo/go/cmd/go/init_test.go", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finit_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,6 +7,7 @@ package main_test\n import (\n \t\"internal/testenv\"\n \t\"os/exec\"\n+\t\"sync/atomic\"\n \t\"testing\"\n )\n \n@@ -15,20 +16,27 @@ import (\n // the benchmark if any changes were done.\n func BenchmarkExecGoEnv(b *testing.B) {\n \ttestenv.MustHaveExec(b)\n-\tb.StopTimer()\n \tgotool, err := testenv.GoTool()\n \tif err != nil {\n \t\tb.Fatal(err)\n \t}\n-\tfor i := 0; i < b.N; i++ {\n-\t\tcmd := exec.Command(gotool, \"env\", \"GOARCH\")\n \n-\t\tb.StartTimer()\n-\t\terr := cmd.Run()\n-\t\tb.StopTimer()\n+\t// We collect extra metrics.\n+\tvar n, userTime, systemTime int64\n \n-\t\tif err != nil {\n-\t\t\tb.Fatal(err)\n+\tb.ResetTimer()\n+\tb.RunParallel(func(pb *testing.PB) {\n+\t\tfor pb.Next() {\n+\t\t\tcmd := exec.Command(gotool, \"env\", \"GOARCH\")\n+\n+\t\t\tif err := cmd.Run(); err != nil {\n+\t\t\t\tb.Fatal(err)\n+\t\t\t}\n+\t\t\tatomic.AddInt64(&n, 1)\n+\t\t\tatomic.AddInt64(&userTime, int64(cmd.ProcessState.UserTime()))\n+\t\t\tatomic.AddInt64(&systemTime, int64(cmd.ProcessState.SystemTime()))\n \t\t}\n-\t}\n+\t})\n+\tb.ReportMetric(float64(userTime)/float64(n), \"user-ns/op\")\n+\tb.ReportMetric(float64(systemTime)/float64(n), \"sys-ns/op\")\n }"}, {"sha": "0107f20d7a68ca9f2015583fdaf75cc1154bbfb8", "filename": "libgo/go/cmd/go/internal/auth/netrc.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,7 +5,6 @@\n package auth\n \n import (\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -99,7 +98,7 @@ func readNetrc() {\n \t\treturn\n \t}\n \n-\tdata, err := ioutil.ReadFile(path)\n+\tdata, err := os.ReadFile(path)\n \tif err != nil {\n \t\tif !os.IsNotExist(err) {\n \t\t\tnetrcErr = err"}, {"sha": "004588c73204d6054c667e4949fbca94a641a4ac", "filename": "libgo/go/cmd/go/internal/base/base.go", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,6 +7,7 @@\n package base\n \n import (\n+\t\"context\"\n \t\"flag\"\n \t\"fmt\"\n \t\"log\"\n@@ -24,7 +25,7 @@ import (\n type Command struct {\n \t// Run runs the command.\n \t// The args are the arguments after the command name.\n-\tRun func(cmd *Command, args []string)\n+\tRun func(ctx context.Context, cmd *Command, args []string)\n \n \t// UsageLine is the one-line usage message.\n \t// The words between \"go\" and the first flag or argument in the line are taken to be the command name.\n@@ -55,6 +56,20 @@ var Go = &Command{\n \t// Commands initialized in package main\n }\n \n+// hasFlag reports whether a command or any of its subcommands contain the given\n+// flag.\n+func hasFlag(c *Command, name string) bool {\n+\tif f := c.Flag.Lookup(name); f != nil {\n+\t\treturn true\n+\t}\n+\tfor _, sub := range c.Commands {\n+\t\tif hasFlag(sub, name) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // LongName returns the command's long name: all the words in the usage line between \"go\" and a flag or argument,\n func (c *Command) LongName() string {\n \tname := c.UsageLine"}, {"sha": "677f8196827f4c8fa18e49964ba2abc75a5861fa", "filename": "libgo/go/cmd/go/internal/base/flag.go", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"flag\"\n \n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/str\"\n )\n \n@@ -28,13 +29,43 @@ func (v *StringsFlag) String() string {\n \treturn \"<StringsFlag>\"\n }\n \n+// explicitStringFlag is like a regular string flag, but it also tracks whether\n+// the string was set explicitly to a non-empty value.\n+type explicitStringFlag struct {\n+\tvalue    *string\n+\texplicit *bool\n+}\n+\n+func (f explicitStringFlag) String() string {\n+\tif f.value == nil {\n+\t\treturn \"\"\n+\t}\n+\treturn *f.value\n+}\n+\n+func (f explicitStringFlag) Set(v string) error {\n+\t*f.value = v\n+\tif v != \"\" {\n+\t\t*f.explicit = true\n+\t}\n+\treturn nil\n+}\n+\n // AddBuildFlagsNX adds the -n and -x build flags to the flag set.\n func AddBuildFlagsNX(flags *flag.FlagSet) {\n \tflags.BoolVar(&cfg.BuildN, \"n\", false, \"\")\n \tflags.BoolVar(&cfg.BuildX, \"x\", false, \"\")\n }\n \n-// AddLoadFlags adds the -mod build flag to the flag set.\n-func AddLoadFlags(flags *flag.FlagSet) {\n-\tflags.StringVar(&cfg.BuildMod, \"mod\", \"\", \"\")\n+// AddModFlag adds the -mod build flag to the flag set.\n+func AddModFlag(flags *flag.FlagSet) {\n+\tflags.Var(explicitStringFlag{value: &cfg.BuildMod, explicit: &cfg.BuildModExplicit}, \"mod\", \"\")\n+}\n+\n+// AddModCommonFlags adds the module-related flags common to build commands\n+// and 'go mod' subcommands.\n+func AddModCommonFlags(flags *flag.FlagSet) {\n+\tflags.BoolVar(&cfg.ModCacheRW, \"modcacherw\", false, \"\")\n+\tflags.StringVar(&cfg.ModFile, \"modfile\", \"\", \"\")\n+\tflags.StringVar(&fsys.OverlayFile, \"overlay\", \"\", \"\")\n }"}, {"sha": "267006be7a2a8646dd53add4dc9f3e59cb76aa61", "filename": "libgo/go/cmd/go/internal/base/goflags.go", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -13,15 +13,7 @@ import (\n \t\"cmd/go/internal/cfg\"\n )\n \n-var (\n-\tgoflags   []string                // cached $GOFLAGS list; can be -x or --x form\n-\tknownFlag = make(map[string]bool) // flags allowed to appear in $GOFLAGS; no leading dashes\n-)\n-\n-// AddKnownFlag adds name to the list of known flags for use in $GOFLAGS.\n-func AddKnownFlag(name string) {\n-\tknownFlag[name] = true\n-}\n+var goflags []string // cached $GOFLAGS list; can be -x or --x form\n \n // GOFLAGS returns the flags from $GOFLAGS.\n // The list can be assumed to contain one string per flag,\n@@ -38,34 +30,19 @@ func InitGOFLAGS() {\n \t\treturn\n \t}\n \n-\t// Build list of all flags for all commands.\n-\t// If no command has that flag, then we report the problem.\n-\t// This catches typos while still letting users record flags in GOFLAGS\n-\t// that only apply to a subset of go commands.\n-\t// Commands using CustomFlags can report their flag names\n-\t// by calling AddKnownFlag instead.\n-\tvar walkFlags func(*Command)\n-\twalkFlags = func(cmd *Command) {\n-\t\tfor _, sub := range cmd.Commands {\n-\t\t\twalkFlags(sub)\n-\t\t}\n-\t\tcmd.Flag.VisitAll(func(f *flag.Flag) {\n-\t\t\tknownFlag[f.Name] = true\n-\t\t})\n+\tgoflags = strings.Fields(cfg.Getenv(\"GOFLAGS\"))\n+\tif len(goflags) == 0 {\n+\t\t// nothing to do; avoid work on later InitGOFLAGS call\n+\t\tgoflags = []string{}\n+\t\treturn\n \t}\n-\twalkFlags(Go)\n \n \t// Ignore bad flag in go env and go bug, because\n \t// they are what people reach for when debugging\n \t// a problem, and maybe they're debugging GOFLAGS.\n \t// (Both will show the GOFLAGS setting if let succeed.)\n \thideErrors := cfg.CmdName == \"env\" || cfg.CmdName == \"bug\"\n \n-\tgoflags = strings.Fields(cfg.Getenv(\"GOFLAGS\"))\n-\tif goflags == nil {\n-\t\tgoflags = []string{} // avoid work on later InitGOFLAGS call\n-\t}\n-\n \t// Each of the words returned by strings.Fields must be its own flag.\n \t// To set flag arguments use -x=value instead of -x value.\n \t// For boolean flags, -x is fine instead of -x=true.\n@@ -85,7 +62,7 @@ func InitGOFLAGS() {\n \t\tif i := strings.Index(name, \"=\"); i >= 0 {\n \t\t\tname = name[:i]\n \t\t}\n-\t\tif !knownFlag[name] {\n+\t\tif !hasFlag(Go, name) {\n \t\t\tif hideErrors {\n \t\t\t\tcontinue\n \t\t\t}\n@@ -115,7 +92,11 @@ func SetFromGOFLAGS(flags *flag.FlagSet) {\n \t}\n \tfor _, goflag := range goflags {\n \t\tname, value, hasValue := goflag, \"\", false\n-\t\tif i := strings.Index(goflag, \"=\"); i >= 0 {\n+\t\t// Ignore invalid flags like '=' or '=value'.\n+\t\t// If it is not reported in InitGOFlags it means we don't want to report it.\n+\t\tif i := strings.Index(goflag, \"=\"); i == 0 {\n+\t\t\tcontinue\n+\t\t} else if i > 0 {\n \t\t\tname, value, hasValue = goflag[:i], goflag[i+1:], true\n \t\t}\n \t\tif strings.HasPrefix(name, \"--\") {"}, {"sha": "05befcf7f0c8eb84b07d9aee3b3f489fe04d6be3", "filename": "libgo/go/cmd/go/internal/base/signal.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -15,7 +15,7 @@ var Interrupted = make(chan struct{})\n \n // processSignals setups signal handler.\n func processSignals() {\n-\tsig := make(chan os.Signal)\n+\tsig := make(chan os.Signal, 1)\n \tsignal.Notify(sig, signalsToIgnore...)\n \tgo func() {\n \t\t<-sig"}, {"sha": "1085feaaee83b44c60542f73720d2fd1a8ed5d47", "filename": "libgo/go/cmd/go/internal/bug/bug.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,9 +7,9 @@ package bug\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n \turlpkg \"net/url\"\n \t\"os\"\n \t\"os/exec\"\n@@ -37,7 +37,7 @@ func init() {\n \tCmdBug.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n }\n \n-func runBug(cmd *base.Command, args []string) {\n+func runBug(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n \t\tbase.Fatalf(\"go bug: bug takes no arguments\")\n \t}\n@@ -104,7 +104,7 @@ func printGoDetails(w io.Writer) {\n \n func printOSDetails(w io.Writer) {\n \tswitch runtime.GOOS {\n-\tcase \"darwin\":\n+\tcase \"darwin\", \"ios\":\n \t\tprintCmdOut(w, \"uname -v: \", \"uname\", \"-v\")\n \t\tprintCmdOut(w, \"\", \"sw_vers\")\n \tcase \"linux\":\n@@ -116,7 +116,7 @@ func printOSDetails(w io.Writer) {\n \tcase \"illumos\", \"solaris\":\n \t\t// Be sure to use the OS-supplied uname, in \"/usr/bin\":\n \t\tprintCmdOut(w, \"uname -srv: \", \"/usr/bin/uname\", \"-srv\")\n-\t\tout, err := ioutil.ReadFile(\"/etc/release\")\n+\t\tout, err := os.ReadFile(\"/etc/release\")\n \t\tif err == nil {\n \t\t\tfmt.Fprintf(w, \"/etc/release: %s\\n\", out)\n \t\t} else {\n@@ -176,7 +176,7 @@ func printGlibcVersion(w io.Writer) {\n \tsrc := []byte(`int main() {}`)\n \tsrcfile := filepath.Join(tempdir, \"go-bug.c\")\n \toutfile := filepath.Join(tempdir, \"go-bug\")\n-\terr := ioutil.WriteFile(srcfile, src, 0644)\n+\terr := os.WriteFile(srcfile, src, 0644)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "41f921641d499744a2a88224355333c4f76d2693", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -12,7 +12,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strconv\"\n@@ -54,7 +54,7 @@ func Open(dir string) (*Cache, error) {\n \t\treturn nil, err\n \t}\n \tif !info.IsDir() {\n-\t\treturn nil, &os.PathError{Op: \"open\", Path: dir, Err: fmt.Errorf(\"not a directory\")}\n+\t\treturn nil, &fs.PathError{Op: \"open\", Path: dir, Err: fmt.Errorf(\"not a directory\")}\n \t}\n \tfor i := 0; i < 256; i++ {\n \t\tname := filepath.Join(dir, fmt.Sprintf(\"%02x\", i))\n@@ -238,7 +238,7 @@ func (c *Cache) GetBytes(id ActionID) ([]byte, Entry, error) {\n \tif err != nil {\n \t\treturn nil, entry, err\n \t}\n-\tdata, _ := ioutil.ReadFile(c.OutputFile(entry.OutputID))\n+\tdata, _ := os.ReadFile(c.OutputFile(entry.OutputID))\n \tif sha256.Sum256(data) != entry.OutputID {\n \t\treturn nil, entry, &entryNotFoundError{Err: errors.New(\"bad checksum\")}\n \t}\n@@ -377,7 +377,7 @@ func (c *Cache) putIndexEntry(id ActionID, out OutputID, size int64, allowVerify\n \t\t// Truncate the file only *after* writing it.\n \t\t// (This should be a no-op, but truncate just in case of previous corruption.)\n \t\t//\n-\t\t// This differs from ioutil.WriteFile, which truncates to 0 *before* writing\n+\t\t// This differs from os.WriteFile, which truncates to 0 *before* writing\n \t\t// via os.O_TRUNC. Truncating only after writing ensures that a second write\n \t\t// of the same content to the same file is idempotent, and does not \u2014 even\n \t\t// temporarily! \u2014 undo the effect of the first write."}, {"sha": "a865b97018d490ecbb41f2cd9fa72b97c9a7a784", "filename": "libgo/go/cmd/go/internal/cache/cache_test.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"bytes\"\n \t\"encoding/binary\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"testing\"\n@@ -20,7 +19,7 @@ func init() {\n }\n \n func TestBasic(t *testing.T) {\n-\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tdir, err := os.MkdirTemp(\"\", \"cachetest-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -65,7 +64,7 @@ func TestBasic(t *testing.T) {\n }\n \n func TestGrowth(t *testing.T) {\n-\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tdir, err := os.MkdirTemp(\"\", \"cachetest-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -118,7 +117,7 @@ func TestVerifyPanic(t *testing.T) {\n \t\tt.Fatal(\"initEnv did not set verify\")\n \t}\n \n-\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tdir, err := os.MkdirTemp(\"\", \"cachetest-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -151,7 +150,7 @@ func dummyID(x int) [HashSize]byte {\n }\n \n func TestCacheTrim(t *testing.T) {\n-\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tdir, err := os.MkdirTemp(\"\", \"cachetest-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -207,7 +206,7 @@ func TestCacheTrim(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \tc.OutputFile(entry.OutputID)\n-\tdata, err := ioutil.ReadFile(filepath.Join(dir, \"trim.txt\"))\n+\tdata, err := os.ReadFile(filepath.Join(dir, \"trim.txt\"))\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -220,7 +219,7 @@ func TestCacheTrim(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \tc.OutputFile(entry.OutputID)\n-\tdata2, err := ioutil.ReadFile(filepath.Join(dir, \"trim.txt\"))\n+\tdata2, err := os.ReadFile(filepath.Join(dir, \"trim.txt\"))\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "0b1c1e0c203511ca619e8f0a409e088af9c35b0b", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,7 +6,6 @@ package cache\n \n import (\n \t\"fmt\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"sync\"\n@@ -49,7 +48,7 @@ func initDefaultCache() {\n \t}\n \tif _, err := os.Stat(filepath.Join(dir, \"README\")); err != nil {\n \t\t// Best effort.\n-\t\tioutil.WriteFile(filepath.Join(dir, \"README\"), []byte(cacheREADME), 0666)\n+\t\tos.WriteFile(filepath.Join(dir, \"README\"), []byte(cacheREADME), 0666)\n \t}\n \n \tc, err := Open(dir)"}, {"sha": "a0356771cac829a66df8efc27e1ee295acc44c02", "filename": "libgo/go/cmd/go/internal/cache/hash_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,7 +6,6 @@ package cache\n \n import (\n \t\"fmt\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"testing\"\n )\n@@ -28,7 +27,7 @@ func TestHash(t *testing.T) {\n }\n \n func TestHashFile(t *testing.T) {\n-\tf, err := ioutil.TempFile(\"\", \"cmd-go-test-\")\n+\tf, err := os.CreateTemp(\"\", \"cmd-go-test-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "c48904eacceab90949bc12248ad82b91803a16ca", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -11,13 +11,15 @@ import (\n \t\"fmt\"\n \t\"go/build\"\n \t\"internal/cfg\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n \t\"sync\"\n \n+\t\"cmd/go/internal/fsys\"\n+\n \t\"cmd/internal/objabi\"\n )\n \n@@ -27,7 +29,8 @@ var (\n \tBuildBuildmode         string // -buildmode flag\n \tBuildContext           = defaultContext()\n \tBuildMod               string             // -mod flag\n-\tBuildModReason         string             // reason -mod flag is set, if set by default\n+\tBuildModExplicit       bool               // whether -mod was set explicitly\n+\tBuildModReason         string             // reason -mod was set, if set by default\n \tBuildI                 bool               // -i flag\n \tBuildLinkshared        bool               // -linkshared flag\n \tBuildMSan              bool               // -msan flag\n@@ -48,9 +51,12 @@ var (\n \tModCacheRW bool   // -modcacherw flag\n \tModFile    string // -modfile flag\n \n+\tInsecure bool // -insecure flag\n+\n \tCmdName string // \"build\", \"install\", \"list\", \"mod tidy\", etc.\n \n \tDebugActiongraph string // -debug-actiongraph flag (undocumented, unstable)\n+\tDebugTrace       string // -debug-trace flag\n )\n \n func defaultContext() build.Context {\n@@ -100,6 +106,15 @@ func defaultContext() build.Context {\n \t\t// Nothing to do here.\n \t}\n \n+\tctxt.OpenFile = func(path string) (io.ReadCloser, error) {\n+\t\treturn fsys.Open(path)\n+\t}\n+\tctxt.ReadDir = fsys.ReadDir\n+\tctxt.IsDir = func(path string) bool {\n+\t\tisDir, err := fsys.IsDir(path)\n+\t\treturn err == nil && isDir\n+\t}\n+\n \treturn ctxt\n }\n \n@@ -171,7 +186,7 @@ func initEnvCache() {\n \tif file == \"\" {\n \t\treturn\n \t}\n-\tdata, err := ioutil.ReadFile(file)\n+\tdata, err := os.ReadFile(file)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -252,6 +267,7 @@ var (\n \tGONOPROXY  = envOr(\"GONOPROXY\", GOPRIVATE)\n \tGONOSUMDB  = envOr(\"GONOSUMDB\", GOPRIVATE)\n \tGOINSECURE = Getenv(\"GOINSECURE\")\n+\tGOVCS      = Getenv(\"GOVCS\")\n )\n \n var SumdbDir = gopathDir(\"pkg/sumdb\")"}, {"sha": "b1d40feb273b89d6604747ff8e2de6949572221a", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,8 +6,9 @@\n package clean\n \n import (\n+\t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strconv\"\n@@ -105,7 +106,7 @@ func init() {\n \twork.AddBuildFlags(CmdClean, work.DefaultBuildFlags)\n }\n \n-func runClean(cmd *base.Command, args []string) {\n+func runClean(ctx context.Context, cmd *base.Command, args []string) {\n \t// golang.org/issue/29925: only load packages before cleaning if\n \t// either the flags and arguments explicitly imply a package,\n \t// or no other target (such as a cache) was requested to be cleaned.\n@@ -116,7 +117,7 @@ func runClean(cmd *base.Command, args []string) {\n \t}\n \n \tif cleanPkg {\n-\t\tfor _, pkg := range load.PackagesAndErrors(args) {\n+\t\tfor _, pkg := range load.PackagesAndErrors(ctx, args) {\n \t\t\tclean(pkg)\n \t\t}\n \t}\n@@ -171,7 +172,7 @@ func runClean(cmd *base.Command, args []string) {\n \t\t\tf, err := lockedfile.Edit(filepath.Join(dir, \"testexpire.txt\"))\n \t\t\tif err == nil {\n \t\t\t\tnow := time.Now().UnixNano()\n-\t\t\t\tbuf, _ := ioutil.ReadAll(f)\n+\t\t\t\tbuf, _ := io.ReadAll(f)\n \t\t\t\tprev, _ := strconv.ParseInt(strings.TrimSpace(string(buf)), 10, 64)\n \t\t\t\tif now > prev {\n \t\t\t\t\tif err = f.Truncate(0); err == nil {\n@@ -242,7 +243,7 @@ func clean(p *load.Package) {\n \t\tbase.Errorf(\"%v\", p.Error)\n \t\treturn\n \t}\n-\tdirs, err := ioutil.ReadDir(p.Dir)\n+\tdirs, err := os.ReadDir(p.Dir)\n \tif err != nil {\n \t\tbase.Errorf(\"go clean %s: %v\", p.Dir, err)\n \t\treturn\n@@ -274,23 +275,37 @@ func clean(p *load.Package) {\n \t\tallRemove = append(allRemove,\n \t\t\telem,\n \t\t\telem+\".exe\",\n+\t\t\tp.DefaultExecName(),\n+\t\t\tp.DefaultExecName()+\".exe\",\n \t\t)\n \t}\n \n \t// Remove package test executables.\n \tallRemove = append(allRemove,\n \t\telem+\".test\",\n \t\telem+\".test.exe\",\n+\t\tp.DefaultExecName()+\".test\",\n+\t\tp.DefaultExecName()+\".test.exe\",\n \t)\n \n-\t// Remove a potential executable for each .go file in the directory that\n+\t// Remove a potential executable, test executable for each .go file in the directory that\n \t// is not part of the directory's package.\n \tfor _, dir := range dirs {\n \t\tname := dir.Name()\n \t\tif packageFile[name] {\n \t\t\tcontinue\n \t\t}\n-\t\tif !dir.IsDir() && strings.HasSuffix(name, \".go\") {\n+\n+\t\tif dir.IsDir() {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif strings.HasSuffix(name, \"_test.go\") {\n+\t\t\tbase := name[:len(name)-len(\"_test.go\")]\n+\t\t\tallRemove = append(allRemove, base+\".test\", base+\".test.exe\")\n+\t\t}\n+\n+\t\tif strings.HasSuffix(name, \".go\") {\n \t\t\t// TODO(adg,rsc): check that this .go file is actually\n \t\t\t// in \"package main\", and therefore capable of building\n \t\t\t// to an executable file."}, {"sha": "67f76e22563b6e84d21b7622b55675d03af60db2", "filename": "libgo/go/cmd/go/internal/doc/doc.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,6 +8,7 @@ package doc\n import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"context\"\n )\n \n var CmdDoc = &base.Command{\n@@ -129,6 +130,6 @@ Flags:\n `,\n }\n \n-func runDoc(cmd *base.Command, args []string) {\n+func runDoc(ctx context.Context, cmd *base.Command, args []string) {\n \tbase.Run(cfg.BuildToolexec, base.Tool(\"doc\"), args)\n }"}, {"sha": "6937187522bd237fbefac0c13727754af40fcb86", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,10 +6,10 @@\n package envcmd\n \n import (\n+\t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"go/build\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -20,6 +20,7 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/work\"\n@@ -62,9 +63,6 @@ var (\n )\n \n func MkEnv() []cfg.EnvVar {\n-\tvar b work.Builder\n-\tb.Init()\n-\n \tenvFile, _ := cfg.EnvFile()\n \tenv := []cfg.EnvVar{\n \t\t{Name: \"GO111MODULE\", Value: cfg.Getenv(\"GO111MODULE\")},\n@@ -88,6 +86,8 @@ func MkEnv() []cfg.EnvVar {\n \t\t{Name: \"GOSUMDB\", Value: cfg.GOSUMDB},\n \t\t{Name: \"GOTMPDIR\", Value: cfg.Getenv(\"GOTMPDIR\")},\n \t\t{Name: \"GOTOOLDIR\", Value: base.ToolDir},\n+\t\t{Name: \"GOVCS\", Value: cfg.GOVCS},\n+\t\t{Name: \"GOVERSION\", Value: runtime.Version()},\n \t}\n \n \tif work.GccgoBin != \"\" {\n@@ -186,7 +186,7 @@ func argKey(arg string) string {\n \treturn arg[:i]\n }\n \n-func runEnv(cmd *base.Command, args []string) {\n+func runEnv(ctx context.Context, cmd *base.Command, args []string) {\n \tif *envJson && *envU {\n \t\tbase.Fatalf(\"go env: cannot use -json with -u\")\n \t}\n@@ -199,12 +199,26 @@ func runEnv(cmd *base.Command, args []string) {\n \tenv := cfg.CmdEnv\n \tenv = append(env, ExtraEnvVars()...)\n \n+\tif err := fsys.Init(base.Cwd); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\n \t// Do we need to call ExtraEnvVarsCostly, which is a bit expensive?\n-\t// Only if we're listing all environment variables (\"go env\")\n-\t// or the variables being requested are in the extra list.\n-\tneedCostly := true\n-\tif len(args) > 0 {\n+\tneedCostly := false\n+\tif *envU || *envW {\n+\t\t// We're overwriting or removing default settings,\n+\t\t// so it doesn't really matter what the existing settings are.\n+\t\t//\n+\t\t// Moreover, we haven't validated the new settings yet, so it is\n+\t\t// important that we NOT perform any actions based on them,\n+\t\t// such as initializing the builder to compute other variables.\n+\t} else if len(args) == 0 {\n+\t\t// We're listing all environment variables (\"go env\"),\n+\t\t// including the expensive ones.\n+\t\tneedCostly = true\n+\t} else {\n \t\tneedCostly = false\n+\tcheckCostly:\n \t\tfor _, arg := range args {\n \t\t\tswitch argKey(arg) {\n \t\t\tcase \"CGO_CFLAGS\",\n@@ -215,6 +229,7 @@ func runEnv(cmd *base.Command, args []string) {\n \t\t\t\t\"PKG_CONFIG\",\n \t\t\t\t\"GOGCCFLAGS\":\n \t\t\t\tneedCostly = true\n+\t\t\t\tbreak checkCostly\n \t\t\t}\n \t\t}\n \t}\n@@ -266,6 +281,13 @@ func runEnv(cmd *base.Command, args []string) {\n \t\t\t}\n \t\t}\n \n+\t\tgotmp, okGOTMP := add[\"GOTMPDIR\"]\n+\t\tif okGOTMP {\n+\t\t\tif !filepath.IsAbs(gotmp) && gotmp != \"\" {\n+\t\t\t\tbase.Fatalf(\"go env -w: GOTMPDIR must be an absolute path\")\n+\t\t\t}\n+\t\t}\n+\n \t\tupdateEnvFile(add, nil)\n \t\treturn\n \t}\n@@ -377,7 +399,7 @@ func getOrigEnv(key string) string {\n \n func checkEnvWrite(key, val string) error {\n \tswitch key {\n-\tcase \"GOEXE\", \"GOGCCFLAGS\", \"GOHOSTARCH\", \"GOHOSTOS\", \"GOMOD\", \"GOTOOLDIR\":\n+\tcase \"GOEXE\", \"GOGCCFLAGS\", \"GOHOSTARCH\", \"GOHOSTOS\", \"GOMOD\", \"GOTOOLDIR\", \"GOVERSION\":\n \t\treturn fmt.Errorf(\"%s cannot be modified\", key)\n \tcase \"GOENV\":\n \t\treturn fmt.Errorf(\"%s can only be set using the OS environment\", key)\n@@ -405,6 +427,11 @@ func checkEnvWrite(key, val string) error {\n \t\tif !filepath.IsAbs(val) && val != \"\" {\n \t\t\treturn fmt.Errorf(\"GOPATH entry is relative; must be absolute path: %q\", val)\n \t\t}\n+\t// Make sure CC and CXX are absolute paths\n+\tcase \"CC\", \"CXX\":\n+\t\tif !filepath.IsAbs(val) && val != \"\" && val != filepath.Base(val) {\n+\t\t\treturn fmt.Errorf(\"%s entry is relative; must be absolute path: %q\", key, val)\n+\t\t}\n \t}\n \n \tif !utf8.ValidString(val) {\n@@ -424,7 +451,7 @@ func updateEnvFile(add map[string]string, del map[string]bool) {\n \tif file == \"\" {\n \t\tbase.Fatalf(\"go env: cannot find go env config: %v\", err)\n \t}\n-\tdata, err := ioutil.ReadFile(file)\n+\tdata, err := os.ReadFile(file)\n \tif err != nil && (!os.IsNotExist(err) || len(add) == 0) {\n \t\tbase.Fatalf(\"go env: reading go env config: %v\", err)\n \t}\n@@ -478,11 +505,11 @@ func updateEnvFile(add map[string]string, del map[string]bool) {\n \t}\n \n \tdata = []byte(strings.Join(lines, \"\"))\n-\terr = ioutil.WriteFile(file, data, 0666)\n+\terr = os.WriteFile(file, data, 0666)\n \tif err != nil {\n \t\t// Try creating directory.\n \t\tos.MkdirAll(filepath.Dir(file), 0777)\n-\t\terr = ioutil.WriteFile(file, data, 0666)\n+\t\terr = os.WriteFile(file, data, 0666)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go env: writing go env config: %v\", err)\n \t\t}\n@@ -499,7 +526,10 @@ func lineToKey(line string) string {\n }\n \n // sortKeyValues sorts a sequence of lines by key.\n-// It differs from sort.Strings in that GO386= sorts after GO=.\n+// It differs from sort.Strings in that keys which are GOx where x is an ASCII\n+// character smaller than = sort after GO=.\n+// (There are no such keys currently. It used to matter for GO386 which was\n+// removed in Go 1.16.)\n func sortKeyValues(lines []string) {\n \tsort.Slice(lines, func(i, j int) bool {\n \t\treturn lineToKey(lines[i]) < lineToKey(lines[j])"}, {"sha": "c7588c66d3ebcc56bab6f83ad91c0f85e9c15d29", "filename": "libgo/go/cmd/go/internal/fix/fix.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n )\n@@ -31,9 +32,21 @@ See also: go fmt, go vet.\n \t`,\n }\n \n-func runFix(cmd *base.Command, args []string) {\n+func runFix(ctx context.Context, cmd *base.Command, args []string) {\n+\tpkgs := load.PackagesAndErrors(ctx, args)\n+\tw := 0\n+\tfor _, pkg := range pkgs {\n+\t\tif pkg.Error != nil {\n+\t\t\tbase.Errorf(\"%v\", pkg.Error)\n+\t\t\tcontinue\n+\t\t}\n+\t\tpkgs[w] = pkg\n+\t\tw++\n+\t}\n+\tpkgs = pkgs[:w]\n+\n \tprinted := false\n-\tfor _, pkg := range load.Packages(args) {\n+\tfor _, pkg := range pkgs {\n \t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: not fixing packages in dependency modules\\n\")"}, {"sha": "b0c1c59b40c58b4818f0317b6683ba10422eec6a", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,6 +6,7 @@\n package fmtcmd\n \n import (\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"os\"\n@@ -22,7 +23,8 @@ import (\n \n func init() {\n \tbase.AddBuildFlagsNX(&CmdFmt.Flag)\n-\tbase.AddLoadFlags(&CmdFmt.Flag)\n+\tbase.AddModFlag(&CmdFmt.Flag)\n+\tbase.AddModCommonFlags(&CmdFmt.Flag)\n }\n \n var CmdFmt = &base.Command{\n@@ -48,7 +50,7 @@ See also: go fix, go vet.\n \t`,\n }\n \n-func runFmt(cmd *base.Command, args []string) {\n+func runFmt(ctx context.Context, cmd *base.Command, args []string) {\n \tprinted := false\n \tgofmt := gofmtPath()\n \tprocs := runtime.GOMAXPROCS(0)\n@@ -63,7 +65,7 @@ func runFmt(cmd *base.Command, args []string) {\n \t\t\t}\n \t\t}()\n \t}\n-\tfor _, pkg := range load.PackagesAndErrors(args) {\n+\tfor _, pkg := range load.PackagesAndErrors(ctx, args) {\n \t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: not formatting packages in dependency modules\\n\")"}, {"sha": "7b06c3c7f3a0118614d39d25a1f91af65d263966", "filename": "libgo/go/cmd/go/internal/fsys/fsys.go", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -0,0 +1,689 @@\n+// Package fsys is an abstraction for reading files that\n+// allows for virtual overlays on top of the files on disk.\n+package fsys\n+\n+import (\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io/fs\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// OverlayFile is the path to a text file in the OverlayJSON format.\n+// It is the value of the -overlay flag.\n+var OverlayFile string\n+\n+// OverlayJSON is the format overlay files are expected to be in.\n+// The Replace map maps from overlaid paths to replacement paths:\n+// the Go command will forward all reads trying to open\n+// each overlaid path to its replacement path, or consider the overlaid\n+// path not to exist if the replacement path is empty.\n+type OverlayJSON struct {\n+\tReplace map[string]string\n+}\n+\n+type node struct {\n+\tactualFilePath string           // empty if a directory\n+\tchildren       map[string]*node // path element \u2192 file or directory\n+}\n+\n+func (n *node) isDir() bool {\n+\treturn n.actualFilePath == \"\" && n.children != nil\n+}\n+\n+func (n *node) isDeleted() bool {\n+\treturn n.actualFilePath == \"\" && n.children == nil\n+}\n+\n+// TODO(matloob): encapsulate these in an io/fs-like interface\n+var overlay map[string]*node // path -> file or directory node\n+var cwd string               // copy of base.Cwd to avoid dependency\n+\n+// Canonicalize a path for looking it up in the overlay.\n+// Important: filepath.Join(cwd, path) doesn't always produce\n+// the correct absolute path if path is relative, because on\n+// Windows producing the correct absolute path requires making\n+// a syscall. So this should only be used when looking up paths\n+// in the overlay, or canonicalizing the paths in the overlay.\n+func canonicalize(path string) string {\n+\tif path == \"\" {\n+\t\treturn \"\"\n+\t}\n+\tif filepath.IsAbs(path) {\n+\t\treturn filepath.Clean(path)\n+\t}\n+\n+\tif v := filepath.VolumeName(cwd); v != \"\" && path[0] == filepath.Separator {\n+\t\t// On Windows filepath.Join(cwd, path) doesn't always work. In general\n+\t\t// filepath.Abs needs to make a syscall on Windows. Elsewhere in cmd/go\n+\t\t// use filepath.Join(cwd, path), but cmd/go specifically supports Windows\n+\t\t// paths that start with \"\\\" which implies the path is relative to the\n+\t\t// volume of the working directory. See golang.org/issue/8130.\n+\t\treturn filepath.Join(v, path)\n+\t}\n+\n+\t// Make the path absolute.\n+\treturn filepath.Join(cwd, path)\n+}\n+\n+// Init initializes the overlay, if one is being used.\n+func Init(wd string) error {\n+\tif overlay != nil {\n+\t\t// already initialized\n+\t\treturn nil\n+\t}\n+\n+\tcwd = wd\n+\n+\tif OverlayFile == \"\" {\n+\t\treturn nil\n+\t}\n+\n+\tb, err := os.ReadFile(OverlayFile)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"reading overlay file: %v\", err)\n+\t}\n+\n+\tvar overlayJSON OverlayJSON\n+\tif err := json.Unmarshal(b, &overlayJSON); err != nil {\n+\t\treturn fmt.Errorf(\"parsing overlay JSON: %v\", err)\n+\t}\n+\n+\treturn initFromJSON(overlayJSON)\n+}\n+\n+func initFromJSON(overlayJSON OverlayJSON) error {\n+\t// Canonicalize the paths in in the overlay map.\n+\t// Use reverseCanonicalized to check for collisions:\n+\t// no two 'from' paths should canonicalize to the same path.\n+\toverlay = make(map[string]*node)\n+\treverseCanonicalized := make(map[string]string) // inverse of canonicalize operation, to check for duplicates\n+\t// Build a table of file and directory nodes from the replacement map.\n+\n+\t// Remove any potential non-determinism from iterating over map by sorting it.\n+\treplaceFrom := make([]string, 0, len(overlayJSON.Replace))\n+\tfor k := range overlayJSON.Replace {\n+\t\treplaceFrom = append(replaceFrom, k)\n+\t}\n+\tsort.Strings(replaceFrom)\n+\n+\tfor _, from := range replaceFrom {\n+\t\tto := overlayJSON.Replace[from]\n+\t\t// Canonicalize paths and check for a collision.\n+\t\tif from == \"\" {\n+\t\t\treturn fmt.Errorf(\"empty string key in overlay file Replace map\")\n+\t\t}\n+\t\tcfrom := canonicalize(from)\n+\t\tif to != \"\" {\n+\t\t\t// Don't canonicalize \"\", meaning to delete a file, because then it will turn into \".\".\n+\t\t\tto = canonicalize(to)\n+\t\t}\n+\t\tif otherFrom, seen := reverseCanonicalized[cfrom]; seen {\n+\t\t\treturn fmt.Errorf(\n+\t\t\t\t\"paths %q and %q both canonicalize to %q in overlay file Replace map\", otherFrom, from, cfrom)\n+\t\t}\n+\t\treverseCanonicalized[cfrom] = from\n+\t\tfrom = cfrom\n+\n+\t\t// Create node for overlaid file.\n+\t\tdir, base := filepath.Dir(from), filepath.Base(from)\n+\t\tif n, ok := overlay[from]; ok {\n+\t\t\t// All 'from' paths in the overlay are file paths. Since the from paths\n+\t\t\t// are in a map, they are unique, so if the node already exists we added\n+\t\t\t// it below when we create parent directory nodes. That is, that\n+\t\t\t// both a file and a path to one of its parent directories exist as keys\n+\t\t\t// in the Replace map.\n+\t\t\t//\n+\t\t\t// This only applies if the overlay directory has any files or directories\n+\t\t\t// in it: placeholder directories that only contain deleted files don't\n+\t\t\t// count. They are safe to be overwritten with actual files.\n+\t\t\tfor _, f := range n.children {\n+\t\t\t\tif !f.isDeleted() {\n+\t\t\t\t\treturn fmt.Errorf(\"invalid overlay: path %v is used as both file and directory\", from)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\toverlay[from] = &node{actualFilePath: to}\n+\n+\t\t// Add parent directory nodes to overlay structure.\n+\t\tchildNode := overlay[from]\n+\t\tfor {\n+\t\t\tdirNode := overlay[dir]\n+\t\t\tif dirNode == nil || dirNode.isDeleted() {\n+\t\t\t\tdirNode = &node{children: make(map[string]*node)}\n+\t\t\t\toverlay[dir] = dirNode\n+\t\t\t}\n+\t\t\tif childNode.isDeleted() {\n+\t\t\t\t// Only create one parent for a deleted file:\n+\t\t\t\t// the directory only conditionally exists if\n+\t\t\t\t// there are any non-deleted children, so\n+\t\t\t\t// we don't create their parents.\n+\t\t\t\tif dirNode.isDir() {\n+\t\t\t\t\tdirNode.children[base] = childNode\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif !dirNode.isDir() {\n+\t\t\t\t// This path already exists as a file, so it can't be a parent\n+\t\t\t\t// directory. See comment at error above.\n+\t\t\t\treturn fmt.Errorf(\"invalid overlay: path %v is used as both file and directory\", dir)\n+\t\t\t}\n+\t\t\tdirNode.children[base] = childNode\n+\t\t\tparent := filepath.Dir(dir)\n+\t\t\tif parent == dir {\n+\t\t\t\tbreak // reached the top; there is no parent\n+\t\t\t}\n+\t\t\tdir, base = parent, filepath.Base(dir)\n+\t\t\tchildNode = dirNode\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// IsDir returns true if path is a directory on disk or in the\n+// overlay.\n+func IsDir(path string) (bool, error) {\n+\tpath = canonicalize(path)\n+\n+\tif _, ok := parentIsOverlayFile(path); ok {\n+\t\treturn false, nil\n+\t}\n+\n+\tif n, ok := overlay[path]; ok {\n+\t\treturn n.isDir(), nil\n+\t}\n+\n+\tfi, err := os.Stat(path)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\n+\treturn fi.IsDir(), nil\n+}\n+\n+// parentIsOverlayFile returns whether name or any of\n+// its parents are files in the overlay, and the first parent found,\n+// including name itself, that's a file in the overlay.\n+func parentIsOverlayFile(name string) (string, bool) {\n+\tif overlay != nil {\n+\t\t// Check if name can't possibly be a directory because\n+\t\t// it or one of its parents is overlaid with a file.\n+\t\t// TODO(matloob): Maybe save this to avoid doing it every time?\n+\t\tprefix := name\n+\t\tfor {\n+\t\t\tnode := overlay[prefix]\n+\t\t\tif node != nil && !node.isDir() {\n+\t\t\t\treturn prefix, true\n+\t\t\t}\n+\t\t\tparent := filepath.Dir(prefix)\n+\t\t\tif parent == prefix {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tprefix = parent\n+\t\t}\n+\t}\n+\n+\treturn \"\", false\n+}\n+\n+// errNotDir is used to communicate from ReadDir to IsDirWithGoFiles\n+// that the argument is not a directory, so that IsDirWithGoFiles doesn't\n+// return an error.\n+var errNotDir = errors.New(\"not a directory\")\n+\n+// readDir reads a dir on disk, returning an error that is errNotDir if the dir is not a directory.\n+// Unfortunately, the error returned by ioutil.ReadDir if dir is not a directory\n+// can vary depending on the OS (Linux, Mac, Windows return ENOTDIR; BSD returns EINVAL).\n+func readDir(dir string) ([]fs.FileInfo, error) {\n+\tfis, err := ioutil.ReadDir(dir)\n+\tif err == nil {\n+\t\treturn fis, nil\n+\t}\n+\n+\tif os.IsNotExist(err) {\n+\t\treturn nil, err\n+\t}\n+\tif dirfi, staterr := os.Stat(dir); staterr == nil && !dirfi.IsDir() {\n+\t\treturn nil, &fs.PathError{Op: \"ReadDir\", Path: dir, Err: errNotDir}\n+\t}\n+\treturn nil, err\n+}\n+\n+// ReadDir provides a slice of fs.FileInfo entries corresponding\n+// to the overlaid files in the directory.\n+func ReadDir(dir string) ([]fs.FileInfo, error) {\n+\tdir = canonicalize(dir)\n+\tif _, ok := parentIsOverlayFile(dir); ok {\n+\t\treturn nil, &fs.PathError{Op: \"ReadDir\", Path: dir, Err: errNotDir}\n+\t}\n+\n+\tdirNode := overlay[dir]\n+\tif dirNode == nil {\n+\t\treturn readDir(dir)\n+\t}\n+\tif dirNode.isDeleted() {\n+\t\treturn nil, &fs.PathError{Op: \"ReadDir\", Path: dir, Err: fs.ErrNotExist}\n+\t}\n+\tdiskfis, err := readDir(dir)\n+\tif err != nil && !os.IsNotExist(err) && !errors.Is(err, errNotDir) {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Stat files in overlay to make composite list of fileinfos\n+\tfiles := make(map[string]fs.FileInfo)\n+\tfor _, f := range diskfis {\n+\t\tfiles[f.Name()] = f\n+\t}\n+\tfor name, to := range dirNode.children {\n+\t\tswitch {\n+\t\tcase to.isDir():\n+\t\t\tfiles[name] = fakeDir(name)\n+\t\tcase to.isDeleted():\n+\t\t\tdelete(files, name)\n+\t\tdefault:\n+\t\t\t// This is a regular file.\n+\t\t\tf, err := os.Lstat(to.actualFilePath)\n+\t\t\tif err != nil {\n+\t\t\t\tfiles[name] = missingFile(name)\n+\t\t\t\tcontinue\n+\t\t\t} else if f.IsDir() {\n+\t\t\t\treturn nil, fmt.Errorf(\"for overlay of %q to %q: overlay Replace entries can't point to dirctories\",\n+\t\t\t\t\tfilepath.Join(dir, name), to.actualFilePath)\n+\t\t\t}\n+\t\t\t// Add a fileinfo for the overlaid file, so that it has\n+\t\t\t// the original file's name, but the overlaid file's metadata.\n+\t\t\tfiles[name] = fakeFile{name, f}\n+\t\t}\n+\t}\n+\tsortedFiles := diskfis[:0]\n+\tfor _, f := range files {\n+\t\tsortedFiles = append(sortedFiles, f)\n+\t}\n+\tsort.Slice(sortedFiles, func(i, j int) bool { return sortedFiles[i].Name() < sortedFiles[j].Name() })\n+\treturn sortedFiles, nil\n+}\n+\n+// OverlayPath returns the path to the overlaid contents of the\n+// file, the empty string if the overlay deletes the file, or path\n+// itself if the file is not in the overlay, the file is a directory\n+// in the overlay, or there is no overlay.\n+// It returns true if the path is overlaid with a regular file\n+// or deleted, and false otherwise.\n+func OverlayPath(path string) (string, bool) {\n+\tif p, ok := overlay[canonicalize(path)]; ok && !p.isDir() {\n+\t\treturn p.actualFilePath, ok\n+\t}\n+\n+\treturn path, false\n+}\n+\n+// Open opens the file at or overlaid on the given path.\n+func Open(path string) (*os.File, error) {\n+\treturn OpenFile(path, os.O_RDONLY, 0)\n+}\n+\n+// OpenFile opens the file at or overlaid on the given path with the flag and perm.\n+func OpenFile(path string, flag int, perm os.FileMode) (*os.File, error) {\n+\tcpath := canonicalize(path)\n+\tif node, ok := overlay[cpath]; ok {\n+\t\t// Opening a file in the overlay.\n+\t\tif node.isDir() {\n+\t\t\treturn nil, &fs.PathError{Op: \"OpenFile\", Path: path, Err: errors.New(\"fsys.OpenFile doesn't support opening directories yet\")}\n+\t\t}\n+\t\t// We can't open overlaid paths for write.\n+\t\tif perm != os.FileMode(os.O_RDONLY) {\n+\t\t\treturn nil, &fs.PathError{Op: \"OpenFile\", Path: path, Err: errors.New(\"overlaid files can't be opened for write\")}\n+\t\t}\n+\t\treturn os.OpenFile(node.actualFilePath, flag, perm)\n+\t}\n+\tif parent, ok := parentIsOverlayFile(filepath.Dir(cpath)); ok {\n+\t\t// The file is deleted explicitly in the Replace map,\n+\t\t// or implicitly because one of its parent directories was\n+\t\t// replaced by a file.\n+\t\treturn nil, &fs.PathError{\n+\t\t\tOp:   \"Open\",\n+\t\t\tPath: path,\n+\t\t\tErr:  fmt.Errorf(\"file %s does not exist: parent directory %s is replaced by a file in overlay\", path, parent),\n+\t\t}\n+\t}\n+\treturn os.OpenFile(cpath, flag, perm)\n+}\n+\n+// IsDirWithGoFiles reports whether dir is a directory containing Go files\n+// either on disk or in the overlay.\n+func IsDirWithGoFiles(dir string) (bool, error) {\n+\tfis, err := ReadDir(dir)\n+\tif os.IsNotExist(err) || errors.Is(err, errNotDir) {\n+\t\treturn false, nil\n+\t}\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\n+\tvar firstErr error\n+\tfor _, fi := range fis {\n+\t\tif fi.IsDir() {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// TODO(matloob): this enforces that the \"from\" in the map\n+\t\t// has a .go suffix, but the actual destination file\n+\t\t// doesn't need to have a .go suffix. Is this okay with the\n+\t\t// compiler?\n+\t\tif !strings.HasSuffix(fi.Name(), \".go\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif fi.Mode().IsRegular() {\n+\t\t\treturn true, nil\n+\t\t}\n+\n+\t\t// fi is the result of an Lstat, so it doesn't follow symlinks.\n+\t\t// But it's okay if the file is a symlink pointing to a regular\n+\t\t// file, so use os.Stat to follow symlinks and check that.\n+\t\tactualFilePath, _ := OverlayPath(filepath.Join(dir, fi.Name()))\n+\t\tfi, err := os.Stat(actualFilePath)\n+\t\tif err == nil && fi.Mode().IsRegular() {\n+\t\t\treturn true, nil\n+\t\t}\n+\t\tif err != nil && firstErr == nil {\n+\t\t\tfirstErr = err\n+\t\t}\n+\t}\n+\n+\t// No go files found in directory.\n+\treturn false, firstErr\n+}\n+\n+// walk recursively descends path, calling walkFn. Copied, with some\n+// modifications from path/filepath.walk.\n+func walk(path string, info fs.FileInfo, walkFn filepath.WalkFunc) error {\n+\tif !info.IsDir() {\n+\t\treturn walkFn(path, info, nil)\n+\t}\n+\n+\tfis, readErr := ReadDir(path)\n+\twalkErr := walkFn(path, info, readErr)\n+\t// If readErr != nil, walk can't walk into this directory.\n+\t// walkErr != nil means walkFn want walk to skip this directory or stop walking.\n+\t// Therefore, if one of readErr and walkErr isn't nil, walk will return.\n+\tif readErr != nil || walkErr != nil {\n+\t\t// The caller's behavior is controlled by the return value, which is decided\n+\t\t// by walkFn. walkFn may ignore readErr and return nil.\n+\t\t// If walkFn returns SkipDir, it will be handled by the caller.\n+\t\t// So walk should return whatever walkFn returns.\n+\t\treturn walkErr\n+\t}\n+\n+\tfor _, fi := range fis {\n+\t\tfilename := filepath.Join(path, fi.Name())\n+\t\tif walkErr = walk(filename, fi, walkFn); walkErr != nil {\n+\t\t\tif !fi.IsDir() || walkErr != filepath.SkipDir {\n+\t\t\t\treturn walkErr\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Walk walks the file tree rooted at root, calling walkFn for each file or\n+// directory in the tree, including root.\n+func Walk(root string, walkFn filepath.WalkFunc) error {\n+\tinfo, err := Lstat(root)\n+\tif err != nil {\n+\t\terr = walkFn(root, nil, err)\n+\t} else {\n+\t\terr = walk(root, info, walkFn)\n+\t}\n+\tif err == filepath.SkipDir {\n+\t\treturn nil\n+\t}\n+\treturn err\n+}\n+\n+// lstat implements a version of os.Lstat that operates on the overlay filesystem.\n+func Lstat(path string) (fs.FileInfo, error) {\n+\treturn overlayStat(path, os.Lstat, \"lstat\")\n+}\n+\n+// Stat implements a version of os.Stat that operates on the overlay filesystem.\n+func Stat(path string) (fs.FileInfo, error) {\n+\treturn overlayStat(path, os.Stat, \"stat\")\n+}\n+\n+// overlayStat implements lstat or Stat (depending on whether os.Lstat or os.Stat is passed in).\n+func overlayStat(path string, osStat func(string) (fs.FileInfo, error), opName string) (fs.FileInfo, error) {\n+\tcpath := canonicalize(path)\n+\n+\tif _, ok := parentIsOverlayFile(filepath.Dir(cpath)); ok {\n+\t\treturn nil, &fs.PathError{Op: opName, Path: cpath, Err: fs.ErrNotExist}\n+\t}\n+\n+\tnode, ok := overlay[cpath]\n+\tif !ok {\n+\t\t// The file or directory is not overlaid.\n+\t\treturn osStat(path)\n+\t}\n+\n+\tswitch {\n+\tcase node.isDeleted():\n+\t\treturn nil, &fs.PathError{Op: \"lstat\", Path: cpath, Err: fs.ErrNotExist}\n+\tcase node.isDir():\n+\t\treturn fakeDir(filepath.Base(path)), nil\n+\tdefault:\n+\t\tfi, err := osStat(node.actualFilePath)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn fakeFile{name: filepath.Base(path), real: fi}, nil\n+\t}\n+}\n+\n+// fakeFile provides an fs.FileInfo implementation for an overlaid file,\n+// so that the file has the name of the overlaid file, but takes all\n+// other characteristics of the replacement file.\n+type fakeFile struct {\n+\tname string\n+\treal fs.FileInfo\n+}\n+\n+func (f fakeFile) Name() string       { return f.name }\n+func (f fakeFile) Size() int64        { return f.real.Size() }\n+func (f fakeFile) Mode() fs.FileMode  { return f.real.Mode() }\n+func (f fakeFile) ModTime() time.Time { return f.real.ModTime() }\n+func (f fakeFile) IsDir() bool        { return f.real.IsDir() }\n+func (f fakeFile) Sys() interface{}   { return f.real.Sys() }\n+\n+// missingFile provides an fs.FileInfo for an overlaid file where the\n+// destination file in the overlay doesn't exist. It returns zero values\n+// for the fileInfo methods other than Name, set to the file's name, and Mode\n+// set to ModeIrregular.\n+type missingFile string\n+\n+func (f missingFile) Name() string       { return string(f) }\n+func (f missingFile) Size() int64        { return 0 }\n+func (f missingFile) Mode() fs.FileMode  { return fs.ModeIrregular }\n+func (f missingFile) ModTime() time.Time { return time.Unix(0, 0) }\n+func (f missingFile) IsDir() bool        { return false }\n+func (f missingFile) Sys() interface{}   { return nil }\n+\n+// fakeDir provides an fs.FileInfo implementation for directories that are\n+// implicitly created by overlaid files. Each directory in the\n+// path of an overlaid file is considered to exist in the overlay filesystem.\n+type fakeDir string\n+\n+func (f fakeDir) Name() string       { return string(f) }\n+func (f fakeDir) Size() int64        { return 0 }\n+func (f fakeDir) Mode() fs.FileMode  { return fs.ModeDir | 0500 }\n+func (f fakeDir) ModTime() time.Time { return time.Unix(0, 0) }\n+func (f fakeDir) IsDir() bool        { return true }\n+func (f fakeDir) Sys() interface{}   { return nil }\n+\n+// Glob is like filepath.Glob but uses the overlay file system.\n+func Glob(pattern string) (matches []string, err error) {\n+\t// Check pattern is well-formed.\n+\tif _, err := filepath.Match(pattern, \"\"); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif !hasMeta(pattern) {\n+\t\tif _, err = Lstat(pattern); err != nil {\n+\t\t\treturn nil, nil\n+\t\t}\n+\t\treturn []string{pattern}, nil\n+\t}\n+\n+\tdir, file := filepath.Split(pattern)\n+\tvolumeLen := 0\n+\tif runtime.GOOS == \"windows\" {\n+\t\tvolumeLen, dir = cleanGlobPathWindows(dir)\n+\t} else {\n+\t\tdir = cleanGlobPath(dir)\n+\t}\n+\n+\tif !hasMeta(dir[volumeLen:]) {\n+\t\treturn glob(dir, file, nil)\n+\t}\n+\n+\t// Prevent infinite recursion. See issue 15879.\n+\tif dir == pattern {\n+\t\treturn nil, filepath.ErrBadPattern\n+\t}\n+\n+\tvar m []string\n+\tm, err = Glob(dir)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tfor _, d := range m {\n+\t\tmatches, err = glob(d, file, matches)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// cleanGlobPath prepares path for glob matching.\n+func cleanGlobPath(path string) string {\n+\tswitch path {\n+\tcase \"\":\n+\t\treturn \".\"\n+\tcase string(filepath.Separator):\n+\t\t// do nothing to the path\n+\t\treturn path\n+\tdefault:\n+\t\treturn path[0 : len(path)-1] // chop off trailing separator\n+\t}\n+}\n+\n+func volumeNameLen(path string) int {\n+\tisSlash := func(c uint8) bool {\n+\t\treturn c == '\\\\' || c == '/'\n+\t}\n+\tif len(path) < 2 {\n+\t\treturn 0\n+\t}\n+\t// with drive letter\n+\tc := path[0]\n+\tif path[1] == ':' && ('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z') {\n+\t\treturn 2\n+\t}\n+\t// is it UNC? https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n+\tif l := len(path); l >= 5 && isSlash(path[0]) && isSlash(path[1]) &&\n+\t\t!isSlash(path[2]) && path[2] != '.' {\n+\t\t// first, leading `\\\\` and next shouldn't be `\\`. its server name.\n+\t\tfor n := 3; n < l-1; n++ {\n+\t\t\t// second, next '\\' shouldn't be repeated.\n+\t\t\tif isSlash(path[n]) {\n+\t\t\t\tn++\n+\t\t\t\t// third, following something characters. its share name.\n+\t\t\t\tif !isSlash(path[n]) {\n+\t\t\t\t\tif path[n] == '.' {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tfor ; n < l; n++ {\n+\t\t\t\t\t\tif isSlash(path[n]) {\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn n\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+// cleanGlobPathWindows is windows version of cleanGlobPath.\n+func cleanGlobPathWindows(path string) (prefixLen int, cleaned string) {\n+\tvollen := volumeNameLen(path)\n+\tswitch {\n+\tcase path == \"\":\n+\t\treturn 0, \".\"\n+\tcase vollen+1 == len(path) && os.IsPathSeparator(path[len(path)-1]): // /, \\, C:\\ and C:/\n+\t\t// do nothing to the path\n+\t\treturn vollen + 1, path\n+\tcase vollen == len(path) && len(path) == 2: // C:\n+\t\treturn vollen, path + \".\" // convert C: into C:.\n+\tdefault:\n+\t\tif vollen >= len(path) {\n+\t\t\tvollen = len(path) - 1\n+\t\t}\n+\t\treturn vollen, path[0 : len(path)-1] // chop off trailing separator\n+\t}\n+}\n+\n+// glob searches for files matching pattern in the directory dir\n+// and appends them to matches. If the directory cannot be\n+// opened, it returns the existing matches. New matches are\n+// added in lexicographical order.\n+func glob(dir, pattern string, matches []string) (m []string, e error) {\n+\tm = matches\n+\tfi, err := Stat(dir)\n+\tif err != nil {\n+\t\treturn // ignore I/O error\n+\t}\n+\tif !fi.IsDir() {\n+\t\treturn // ignore I/O error\n+\t}\n+\n+\tlist, err := ReadDir(dir)\n+\tif err != nil {\n+\t\treturn // ignore I/O error\n+\t}\n+\n+\tvar names []string\n+\tfor _, info := range list {\n+\t\tnames = append(names, info.Name())\n+\t}\n+\tsort.Strings(names)\n+\n+\tfor _, n := range names {\n+\t\tmatched, err := filepath.Match(pattern, n)\n+\t\tif err != nil {\n+\t\t\treturn m, err\n+\t\t}\n+\t\tif matched {\n+\t\t\tm = append(m, filepath.Join(dir, n))\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// hasMeta reports whether path contains any of the magic characters\n+// recognized by filepath.Match.\n+func hasMeta(path string) bool {\n+\tmagicChars := `*?[`\n+\tif runtime.GOOS != \"windows\" {\n+\t\tmagicChars = `*?[\\`\n+\t}\n+\treturn strings.ContainsAny(path, magicChars)\n+}"}, {"sha": "7f175c7031169dded7b720e9899f7d38909f8d74", "filename": "libgo/go/cmd/go/internal/fsys/fsys_test.go", "status": "added", "additions": 1094, "deletions": 0, "changes": 1094, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -0,0 +1,1094 @@\n+package fsys\n+\n+import (\n+\t\"cmd/go/internal/txtar\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"internal/testenv\"\n+\t\"io\"\n+\t\"io/fs\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+// initOverlay resets the overlay state to reflect the config.\n+// config should be a text archive string. The comment is the overlay config\n+// json, and the files, in the archive are laid out in a temp directory\n+// that cwd is set to.\n+func initOverlay(t *testing.T, config string) {\n+\tt.Helper()\n+\n+\t// Create a temporary directory and chdir to it.\n+\tprevwd, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tcwd = filepath.Join(t.TempDir(), \"root\")\n+\tif err := os.Mkdir(cwd, 0777); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := os.Chdir(cwd); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tt.Cleanup(func() {\n+\t\toverlay = nil\n+\t\tif err := os.Chdir(prevwd); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t})\n+\n+\ta := txtar.Parse([]byte(config))\n+\tfor _, f := range a.Files {\n+\t\tname := filepath.Join(cwd, f.Name)\n+\t\tif err := os.MkdirAll(filepath.Dir(name), 0777); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif err := os.WriteFile(name, f.Data, 0666); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t}\n+\n+\tvar overlayJSON OverlayJSON\n+\tif err := json.Unmarshal(a.Comment, &overlayJSON); err != nil {\n+\t\tt.Fatal(fmt.Errorf(\"parsing overlay JSON: %v\", err))\n+\t}\n+\n+\tinitFromJSON(overlayJSON)\n+}\n+\n+func TestIsDir(t *testing.T) {\n+\tinitOverlay(t, `\n+{\n+\t\"Replace\": {\n+\t\t\"subdir2/file2.txt\":  \"overlayfiles/subdir2_file2.txt\",\n+\t\t\"subdir4\":            \"overlayfiles/subdir4\",\n+\t\t\"subdir3/file3b.txt\": \"overlayfiles/subdir3_file3b.txt\",\n+\t\t\"subdir5\":            \"\",\n+\t\t\"subdir6\":            \"\"\n+\t}\n+}\n+-- subdir1/file1.txt --\n+\n+-- subdir3/file3a.txt --\n+33\n+-- subdir4/file4.txt --\n+444\n+-- overlayfiles/subdir2_file2.txt --\n+2\n+-- overlayfiles/subdir3_file3b.txt --\n+66666\n+-- overlayfiles/subdir4 --\n+x\n+-- subdir6/file6.txt --\n+six\n+`)\n+\n+\ttestCases := []struct {\n+\t\tpath          string\n+\t\twant, wantErr bool\n+\t}{\n+\t\t{\"\", true, true},\n+\t\t{\".\", true, false},\n+\t\t{cwd, true, false},\n+\t\t{cwd + string(filepath.Separator), true, false},\n+\t\t// subdir1 is only on disk\n+\t\t{filepath.Join(cwd, \"subdir1\"), true, false},\n+\t\t{\"subdir1\", true, false},\n+\t\t{\"subdir1\" + string(filepath.Separator), true, false},\n+\t\t{\"subdir1/file1.txt\", false, false},\n+\t\t{\"subdir1/doesntexist.txt\", false, true},\n+\t\t{\"doesntexist\", false, true},\n+\t\t// subdir2 is only in overlay\n+\t\t{filepath.Join(cwd, \"subdir2\"), true, false},\n+\t\t{\"subdir2\", true, false},\n+\t\t{\"subdir2\" + string(filepath.Separator), true, false},\n+\t\t{\"subdir2/file2.txt\", false, false},\n+\t\t{\"subdir2/doesntexist.txt\", false, true},\n+\t\t// subdir3 has files on disk and in overlay\n+\t\t{filepath.Join(cwd, \"subdir3\"), true, false},\n+\t\t{\"subdir3\", true, false},\n+\t\t{\"subdir3\" + string(filepath.Separator), true, false},\n+\t\t{\"subdir3/file3a.txt\", false, false},\n+\t\t{\"subdir3/file3b.txt\", false, false},\n+\t\t{\"subdir3/doesntexist.txt\", false, true},\n+\t\t// subdir4 is overlaid with a file\n+\t\t{filepath.Join(cwd, \"subdir4\"), false, false},\n+\t\t{\"subdir4\", false, false},\n+\t\t{\"subdir4\" + string(filepath.Separator), false, false},\n+\t\t{\"subdir4/file4.txt\", false, false},\n+\t\t{\"subdir4/doesntexist.txt\", false, false},\n+\t\t// subdir5 doesn't exist, and is overlaid with a \"delete\" entry\n+\t\t{filepath.Join(cwd, \"subdir5\"), false, false},\n+\t\t{\"subdir5\", false, false},\n+\t\t{\"subdir5\" + string(filepath.Separator), false, false},\n+\t\t{\"subdir5/file5.txt\", false, false},\n+\t\t{\"subdir5/doesntexist.txt\", false, false},\n+\t\t// subdir6 does exist, and is overlaid with a \"delete\" entry\n+\t\t{filepath.Join(cwd, \"subdir6\"), false, false},\n+\t\t{\"subdir6\", false, false},\n+\t\t{\"subdir6\" + string(filepath.Separator), false, false},\n+\t\t{\"subdir6/file6.txt\", false, false},\n+\t\t{\"subdir6/doesntexist.txt\", false, false},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tgot, err := IsDir(tc.path)\n+\t\tif err != nil {\n+\t\t\tif !tc.wantErr {\n+\t\t\t\tt.Errorf(\"IsDir(%q): got error with string %q, want no error\", tc.path, err.Error())\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif tc.wantErr {\n+\t\t\tt.Errorf(\"IsDir(%q): got no error, want error\", tc.path)\n+\t\t}\n+\t\tif tc.want != got {\n+\t\t\tt.Errorf(\"IsDir(%q) = %v, want %v\", tc.path, got, tc.want)\n+\t\t}\n+\t}\n+}\n+\n+const readDirOverlay = `\n+{\n+\t\"Replace\": {\n+\t\t\"subdir2/file2.txt\":                 \"overlayfiles/subdir2_file2.txt\",\n+\t\t\"subdir4\":                           \"overlayfiles/subdir4\",\n+\t\t\"subdir3/file3b.txt\":                \"overlayfiles/subdir3_file3b.txt\",\n+\t\t\"subdir5\":                           \"\",\n+\t\t\"subdir6/asubsubdir/afile.txt\":      \"overlayfiles/subdir6_asubsubdir_afile.txt\",\n+\t\t\"subdir6/asubsubdir/zfile.txt\":      \"overlayfiles/subdir6_asubsubdir_zfile.txt\",\n+\t\t\"subdir6/zsubsubdir/file.txt\":       \"overlayfiles/subdir6_zsubsubdir_file.txt\",\n+\t\t\"subdir7/asubsubdir/file.txt\":       \"overlayfiles/subdir7_asubsubdir_file.txt\",\n+\t\t\"subdir7/zsubsubdir/file.txt\":       \"overlayfiles/subdir7_zsubsubdir_file.txt\",\n+\t\t\"subdir8/doesntexist\":               \"this_file_doesnt_exist_anywhere\",\n+\t\t\"other/pointstodir\":                 \"overlayfiles/this_is_a_directory\",\n+\t\t\"parentoverwritten/subdir1\":         \"overlayfiles/parentoverwritten_subdir1\",\n+\t\t\"subdir9/this_file_is_overlaid.txt\": \"overlayfiles/subdir9_this_file_is_overlaid.txt\",\n+\t\t\"subdir10/only_deleted_file.txt\":    \"\",\n+\t\t\"subdir11/deleted.txt\":              \"\",\n+\t\t\"subdir11\":                          \"overlayfiles/subdir11\",\n+\t\t\"textfile.txt/file.go\":              \"overlayfiles/textfile_txt_file.go\"\n+\t}\n+}\n+-- subdir1/file1.txt --\n+\n+-- subdir3/file3a.txt --\n+33\n+-- subdir4/file4.txt --\n+444\n+-- subdir6/file.txt --\n+-- subdir6/asubsubdir/file.txt --\n+-- subdir6/anothersubsubdir/file.txt --\n+-- subdir9/this_file_is_overlaid.txt --\n+-- subdir10/only_deleted_file.txt --\n+this will be deleted in overlay\n+-- subdir11/deleted.txt --\n+-- parentoverwritten/subdir1/subdir2/subdir3/file.txt --\n+-- textfile.txt --\n+this will be overridden by textfile.txt/file.go\n+-- overlayfiles/subdir2_file2.txt --\n+2\n+-- overlayfiles/subdir3_file3b.txt --\n+66666\n+-- overlayfiles/subdir4 --\n+x\n+-- overlayfiles/subdir6_asubsubdir_afile.txt --\n+-- overlayfiles/subdir6_asubsubdir_zfile.txt --\n+-- overlayfiles/subdir6_zsubsubdir_file.txt --\n+-- overlayfiles/subdir7_asubsubdir_file.txt --\n+-- overlayfiles/subdir7_zsubsubdir_file.txt --\n+-- overlayfiles/parentoverwritten_subdir1 --\n+x\n+-- overlayfiles/subdir9_this_file_is_overlaid.txt --\n+99999999\n+-- overlayfiles/subdir11 --\n+-- overlayfiles/this_is_a_directory/file.txt --\n+-- overlayfiles/textfile_txt_file.go --\n+x\n+`\n+\n+func TestReadDir(t *testing.T) {\n+\tinitOverlay(t, readDirOverlay)\n+\n+\ttype entry struct {\n+\t\tname  string\n+\t\tsize  int64\n+\t\tisDir bool\n+\t}\n+\n+\ttestCases := []struct {\n+\t\tdir  string\n+\t\twant []entry\n+\t}{\n+\t\t{\n+\t\t\t\".\", []entry{\n+\t\t\t\t{\"other\", 0, true},\n+\t\t\t\t{\"overlayfiles\", 0, true},\n+\t\t\t\t{\"parentoverwritten\", 0, true},\n+\t\t\t\t{\"subdir1\", 0, true},\n+\t\t\t\t{\"subdir10\", 0, true},\n+\t\t\t\t{\"subdir11\", 0, false},\n+\t\t\t\t{\"subdir2\", 0, true},\n+\t\t\t\t{\"subdir3\", 0, true},\n+\t\t\t\t{\"subdir4\", 2, false},\n+\t\t\t\t// no subdir5.\n+\t\t\t\t{\"subdir6\", 0, true},\n+\t\t\t\t{\"subdir7\", 0, true},\n+\t\t\t\t{\"subdir8\", 0, true},\n+\t\t\t\t{\"subdir9\", 0, true},\n+\t\t\t\t{\"textfile.txt\", 0, true},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"subdir1\", []entry{\n+\t\t\t\t{\"file1.txt\", 1, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"subdir2\", []entry{\n+\t\t\t\t{\"file2.txt\", 2, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"subdir3\", []entry{\n+\t\t\t\t{\"file3a.txt\", 3, false},\n+\t\t\t\t{\"file3b.txt\", 6, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"subdir6\", []entry{\n+\t\t\t\t{\"anothersubsubdir\", 0, true},\n+\t\t\t\t{\"asubsubdir\", 0, true},\n+\t\t\t\t{\"file.txt\", 0, false},\n+\t\t\t\t{\"zsubsubdir\", 0, true},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"subdir6/asubsubdir\", []entry{\n+\t\t\t\t{\"afile.txt\", 0, false},\n+\t\t\t\t{\"file.txt\", 0, false},\n+\t\t\t\t{\"zfile.txt\", 0, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"subdir8\", []entry{\n+\t\t\t\t{\"doesntexist\", 0, false}, // entry is returned even if destination file doesn't exist\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t// check that read dir actually redirects files that already exist\n+\t\t\t// the original this_file_is_overlaid.txt is empty\n+\t\t\t\"subdir9\", []entry{\n+\t\t\t\t{\"this_file_is_overlaid.txt\", 9, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"subdir10\", []entry{},\n+\t\t},\n+\t\t{\n+\t\t\t\"parentoverwritten\", []entry{\n+\t\t\t\t{\"subdir1\", 2, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"textfile.txt\", []entry{\n+\t\t\t\t{\"file.go\", 2, false},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tdir, want := tc.dir, tc.want\n+\t\tinfos, err := ReadDir(dir)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"ReadDir(%q): %v\", dir, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Sorted diff of want and infos.\n+\t\tfor len(infos) > 0 || len(want) > 0 {\n+\t\t\tswitch {\n+\t\t\tcase len(want) == 0 || len(infos) > 0 && infos[0].Name() < want[0].name:\n+\t\t\t\tt.Errorf(\"ReadDir(%q): unexpected entry: %s IsDir=%v Size=%v\", dir, infos[0].Name(), infos[0].IsDir(), infos[0].Size())\n+\t\t\t\tinfos = infos[1:]\n+\t\t\tcase len(infos) == 0 || len(want) > 0 && want[0].name < infos[0].Name():\n+\t\t\t\tt.Errorf(\"ReadDir(%q): missing entry: %s IsDir=%v Size=%v\", dir, want[0].name, want[0].isDir, want[0].size)\n+\t\t\t\twant = want[1:]\n+\t\t\tdefault:\n+\t\t\t\tinfoSize := infos[0].Size()\n+\t\t\t\tif want[0].isDir {\n+\t\t\t\t\tinfoSize = 0\n+\t\t\t\t}\n+\t\t\t\tif infos[0].IsDir() != want[0].isDir || want[0].isDir && infoSize != want[0].size {\n+\t\t\t\t\tt.Errorf(\"ReadDir(%q): %s: IsDir=%v Size=%v, want IsDir=%v Size=%v\", dir, want[0].name, infos[0].IsDir(), infoSize, want[0].isDir, want[0].size)\n+\t\t\t\t}\n+\t\t\t\tinfos = infos[1:]\n+\t\t\t\twant = want[1:]\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\terrCases := []string{\n+\t\t\"subdir1/file1.txt\", // regular file on disk\n+\t\t\"subdir2/file2.txt\", // regular file in overlay\n+\t\t\"subdir4\",           // directory overlaid with regular file\n+\t\t\"subdir5\",           // directory deleted in overlay\n+\t\t\"parentoverwritten/subdir1/subdir2/subdir3\", // parentoverwritten/subdir1 overlaid with regular file\n+\t\t\"parentoverwritten/subdir1/subdir2\",         // parentoverwritten/subdir1 overlaid with regular file\n+\t\t\"subdir11\",                                  // directory with deleted child, overlaid with regular file\n+\t\t\"other/pointstodir\",\n+\t}\n+\n+\tfor _, dir := range errCases {\n+\t\t_, err := ReadDir(dir)\n+\t\tif _, ok := err.(*fs.PathError); !ok {\n+\t\t\tt.Errorf(\"ReadDir(%q): err = %T (%v), want fs.PathError\", dir, err, err)\n+\t\t}\n+\t}\n+}\n+\n+func TestGlob(t *testing.T) {\n+\tinitOverlay(t, readDirOverlay)\n+\n+\ttestCases := []struct {\n+\t\tpattern string\n+\t\tmatch   []string\n+\t}{\n+\t\t{\n+\t\t\t\"*o*\",\n+\t\t\t[]string{\n+\t\t\t\t\"other\",\n+\t\t\t\t\"overlayfiles\",\n+\t\t\t\t\"parentoverwritten\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"subdir2/file2.txt\",\n+\t\t\t[]string{\n+\t\t\t\t\"subdir2/file2.txt\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"*/*.txt\",\n+\t\t\t[]string{\n+\t\t\t\t\"overlayfiles/subdir2_file2.txt\",\n+\t\t\t\t\"overlayfiles/subdir3_file3b.txt\",\n+\t\t\t\t\"overlayfiles/subdir6_asubsubdir_afile.txt\",\n+\t\t\t\t\"overlayfiles/subdir6_asubsubdir_zfile.txt\",\n+\t\t\t\t\"overlayfiles/subdir6_zsubsubdir_file.txt\",\n+\t\t\t\t\"overlayfiles/subdir7_asubsubdir_file.txt\",\n+\t\t\t\t\"overlayfiles/subdir7_zsubsubdir_file.txt\",\n+\t\t\t\t\"overlayfiles/subdir9_this_file_is_overlaid.txt\",\n+\t\t\t\t\"subdir1/file1.txt\",\n+\t\t\t\t\"subdir2/file2.txt\",\n+\t\t\t\t\"subdir3/file3a.txt\",\n+\t\t\t\t\"subdir3/file3b.txt\",\n+\t\t\t\t\"subdir6/file.txt\",\n+\t\t\t\t\"subdir9/this_file_is_overlaid.txt\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tpattern := tc.pattern\n+\t\tmatch, err := Glob(pattern)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Glob(%q): %v\", pattern, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\twant := tc.match\n+\t\tfor i, name := range want {\n+\t\t\tif name != tc.pattern {\n+\t\t\t\twant[i] = filepath.FromSlash(name)\n+\t\t\t}\n+\t\t}\n+\t\tfor len(match) > 0 || len(want) > 0 {\n+\t\t\tswitch {\n+\t\t\tcase len(match) == 0 || len(want) > 0 && want[0] < match[0]:\n+\t\t\t\tt.Errorf(\"Glob(%q): missing match: %s\", pattern, want[0])\n+\t\t\t\twant = want[1:]\n+\t\t\tcase len(want) == 0 || len(match) > 0 && match[0] < want[0]:\n+\t\t\t\tt.Errorf(\"Glob(%q): extra match: %s\", pattern, match[0])\n+\t\t\t\tmatch = match[1:]\n+\t\t\tdefault:\n+\t\t\t\twant = want[1:]\n+\t\t\t\tmatch = match[1:]\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func TestOverlayPath(t *testing.T) {\n+\tinitOverlay(t, `\n+{\n+\t\"Replace\": {\n+\t\t\"subdir2/file2.txt\":                 \"overlayfiles/subdir2_file2.txt\",\n+\t\t\"subdir3/doesntexist\":               \"this_file_doesnt_exist_anywhere\",\n+\t\t\"subdir4/this_file_is_overlaid.txt\": \"overlayfiles/subdir4_this_file_is_overlaid.txt\",\n+\t\t\"subdir5/deleted.txt\":               \"\",\n+\t\t\"parentoverwritten/subdir1\":         \"\"\n+\t}\n+}\n+-- subdir1/file1.txt --\n+file 1\n+-- subdir4/this_file_is_overlaid.txt --\n+these contents are replaced by the overlay\n+-- parentoverwritten/subdir1/subdir2/subdir3/file.txt --\n+-- subdir5/deleted.txt --\n+deleted\n+-- overlayfiles/subdir2_file2.txt --\n+file 2\n+-- overlayfiles/subdir4_this_file_is_overlaid.txt --\n+99999999\n+`)\n+\n+\ttestCases := []struct {\n+\t\tpath     string\n+\t\twantPath string\n+\t\twantOK   bool\n+\t}{\n+\t\t{\"subdir1/file1.txt\", \"subdir1/file1.txt\", false},\n+\t\t// OverlayPath returns false for directories\n+\t\t{\"subdir2\", \"subdir2\", false},\n+\t\t{\"subdir2/file2.txt\", filepath.Join(cwd, \"overlayfiles/subdir2_file2.txt\"), true},\n+\t\t// OverlayPath doesn't stat a file to see if it exists, so it happily returns\n+\t\t// the 'to' path and true even if the 'to' path doesn't exist on disk.\n+\t\t{\"subdir3/doesntexist\", filepath.Join(cwd, \"this_file_doesnt_exist_anywhere\"), true},\n+\t\t// Like the subdir2/file2.txt case above, but subdir4 exists on disk, but subdir2 does not.\n+\t\t{\"subdir4/this_file_is_overlaid.txt\", filepath.Join(cwd, \"overlayfiles/subdir4_this_file_is_overlaid.txt\"), true},\n+\t\t{\"subdir5\", \"subdir5\", false},\n+\t\t{\"subdir5/deleted.txt\", \"\", true},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tgotPath, gotOK := OverlayPath(tc.path)\n+\t\tif gotPath != tc.wantPath || gotOK != tc.wantOK {\n+\t\t\tt.Errorf(\"OverlayPath(%q): got %v, %v; want %v, %v\",\n+\t\t\t\ttc.path, gotPath, gotOK, tc.wantPath, tc.wantOK)\n+\t\t}\n+\t}\n+}\n+\n+func TestOpen(t *testing.T) {\n+\tinitOverlay(t, `\n+{\n+    \"Replace\": {\n+\t\t\"subdir2/file2.txt\":                  \"overlayfiles/subdir2_file2.txt\",\n+\t\t\"subdir3/doesntexist\":                \"this_file_doesnt_exist_anywhere\",\n+\t\t\"subdir4/this_file_is_overlaid.txt\":  \"overlayfiles/subdir4_this_file_is_overlaid.txt\",\n+\t\t\"subdir5/deleted.txt\":                \"\",\n+\t\t\"parentoverwritten/subdir1\":          \"\",\n+\t\t\"childoverlay/subdir1.txt/child.txt\": \"overlayfiles/child.txt\",\n+\t\t\"subdir11/deleted.txt\":               \"\",\n+\t\t\"subdir11\":                           \"overlayfiles/subdir11\",\n+\t\t\"parentdeleted\":                      \"\",\n+\t\t\"parentdeleted/file.txt\":             \"overlayfiles/parentdeleted_file.txt\"\n+\t}\n+}\n+-- subdir11/deleted.txt --\n+-- subdir1/file1.txt --\n+file 1\n+-- subdir4/this_file_is_overlaid.txt --\n+these contents are replaced by the overlay\n+-- parentoverwritten/subdir1/subdir2/subdir3/file.txt --\n+-- childoverlay/subdir1.txt --\n+this file doesn't exist because the path\n+childoverlay/subdir1.txt/child.txt is in the overlay\n+-- subdir5/deleted.txt --\n+deleted\n+-- parentdeleted --\n+this will be deleted so that parentdeleted/file.txt can exist\n+-- overlayfiles/subdir2_file2.txt --\n+file 2\n+-- overlayfiles/subdir4_this_file_is_overlaid.txt --\n+99999999\n+-- overlayfiles/child.txt --\n+-- overlayfiles/subdir11 --\n+11\n+-- overlayfiles/parentdeleted_file.txt --\n+this can exist because the parent directory is deleted\n+`)\n+\n+\ttestCases := []struct {\n+\t\tpath         string\n+\t\twantContents string\n+\t\tisErr        bool\n+\t}{\n+\t\t{\"subdir1/file1.txt\", \"file 1\\n\", false},\n+\t\t{\"subdir2/file2.txt\", \"file 2\\n\", false},\n+\t\t{\"subdir3/doesntexist\", \"\", true},\n+\t\t{\"subdir4/this_file_is_overlaid.txt\", \"99999999\\n\", false},\n+\t\t{\"subdir5/deleted.txt\", \"\", true},\n+\t\t{\"parentoverwritten/subdir1/subdir2/subdir3/file.txt\", \"\", true},\n+\t\t{\"childoverlay/subdir1.txt\", \"\", true},\n+\t\t{\"subdir11\", \"11\\n\", false},\n+\t\t{\"parentdeleted/file.txt\", \"this can exist because the parent directory is deleted\\n\", false},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tf, err := Open(tc.path)\n+\t\tif tc.isErr {\n+\t\t\tif err == nil {\n+\t\t\t\tf.Close()\n+\t\t\t\tt.Errorf(\"Open(%q): got no error, but want error\", tc.path)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Open(%q): got error %v, want nil\", tc.path, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tcontents, err := io.ReadAll(f)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"unexpected error reading contents of file: %v\", err)\n+\t\t}\n+\t\tif string(contents) != tc.wantContents {\n+\t\t\tt.Errorf(\"contents of file opened with Open(%q): got %q, want %q\",\n+\t\t\t\ttc.path, contents, tc.wantContents)\n+\t\t}\n+\t\tf.Close()\n+\t}\n+}\n+\n+func TestIsDirWithGoFiles(t *testing.T) {\n+\tinitOverlay(t, `\n+{\n+\t\"Replace\": {\n+\t\t\"goinoverlay/file.go\":       \"dummy\",\n+\t\t\"directory/removed/by/file\": \"dummy\",\n+\t\t\"directory_with_go_dir/dir.go/file.txt\": \"dummy\",\n+\t\t\"otherdirectory/deleted.go\": \"\",\n+\t\t\"nonexistentdirectory/deleted.go\": \"\",\n+\t\t\"textfile.txt/file.go\": \"dummy\"\n+\t}\n+}\n+-- dummy --\n+a destination file for the overlay entries to point to\n+contents don't matter for this test\n+-- nogo/file.txt --\n+-- goondisk/file.go --\n+-- goinoverlay/file.txt --\n+-- directory/removed/by/file/in/overlay/file.go --\n+-- otherdirectory/deleted.go --\n+-- textfile.txt --\n+`)\n+\n+\ttestCases := []struct {\n+\t\tdir     string\n+\t\twant    bool\n+\t\twantErr bool\n+\t}{\n+\t\t{\"nogo\", false, false},\n+\t\t{\"goondisk\", true, false},\n+\t\t{\"goinoverlay\", true, false},\n+\t\t{\"directory/removed/by/file/in/overlay\", false, false},\n+\t\t{\"directory_with_go_dir\", false, false},\n+\t\t{\"otherdirectory\", false, false},\n+\t\t{\"nonexistentdirectory\", false, false},\n+\t\t{\"textfile.txt\", true, false},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tgot, gotErr := IsDirWithGoFiles(tc.dir)\n+\t\tif tc.wantErr {\n+\t\t\tif gotErr == nil {\n+\t\t\t\tt.Errorf(\"IsDirWithGoFiles(%q): got %v, %v; want non-nil error\", tc.dir, got, gotErr)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif gotErr != nil {\n+\t\t\tt.Errorf(\"IsDirWithGoFiles(%q): got %v, %v; want nil error\", tc.dir, got, gotErr)\n+\t\t}\n+\t\tif got != tc.want {\n+\t\t\tt.Errorf(\"IsDirWithGoFiles(%q) = %v; want %v\", tc.dir, got, tc.want)\n+\t\t}\n+\t}\n+}\n+\n+func TestWalk(t *testing.T) {\n+\t// The root of the walk must be a name with an actual basename, not just \".\".\n+\t// Walk uses Lstat to obtain the name of the root, and Lstat on platforms\n+\t// other than Plan 9 reports the name \".\" instead of the actual base name of\n+\t// the directory. (See https://golang.org/issue/42115.)\n+\n+\ttype file struct {\n+\t\tpath  string\n+\t\tname  string\n+\t\tsize  int64\n+\t\tmode  fs.FileMode\n+\t\tisDir bool\n+\t}\n+\ttestCases := []struct {\n+\t\tname      string\n+\t\toverlay   string\n+\t\troot      string\n+\t\twantFiles []file\n+\t}{\n+\t\t{\"no overlay\", `\n+{}\n+-- dir/file.txt --\n+`,\n+\t\t\t\"dir\",\n+\t\t\t[]file{\n+\t\t\t\t{\"dir\", \"dir\", 0, fs.ModeDir | 0700, true},\n+\t\t\t\t{\"dir/file.txt\", \"file.txt\", 0, 0600, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\"overlay with different file\", `\n+{\n+\t\"Replace\": {\n+\t\t\"dir/file.txt\": \"dir/other.txt\"\n+\t}\n+}\n+-- dir/file.txt --\n+-- dir/other.txt --\n+contents of other file\n+`,\n+\t\t\t\"dir\",\n+\t\t\t[]file{\n+\t\t\t\t{\"dir\", \"dir\", 0, fs.ModeDir | 0500, true},\n+\t\t\t\t{\"dir/file.txt\", \"file.txt\", 23, 0600, false},\n+\t\t\t\t{\"dir/other.txt\", \"other.txt\", 23, 0600, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\"overlay with new file\", `\n+{\n+\t\"Replace\": {\n+\t\t\"dir/file.txt\": \"dir/other.txt\"\n+\t}\n+}\n+-- dir/other.txt --\n+contents of other file\n+`,\n+\t\t\t\"dir\",\n+\t\t\t[]file{\n+\t\t\t\t{\"dir\", \"dir\", 0, fs.ModeDir | 0500, true},\n+\t\t\t\t{\"dir/file.txt\", \"file.txt\", 23, 0600, false},\n+\t\t\t\t{\"dir/other.txt\", \"other.txt\", 23, 0600, false},\n+\t\t\t},\n+\t\t},\n+\t\t{\"overlay with new directory\", `\n+{\n+\t\"Replace\": {\n+\t\t\"dir/subdir/file.txt\": \"dir/other.txt\"\n+\t}\n+}\n+-- dir/other.txt --\n+contents of other file\n+`,\n+\t\t\t\"dir\",\n+\t\t\t[]file{\n+\t\t\t\t{\"dir\", \"dir\", 0, fs.ModeDir | 0500, true},\n+\t\t\t\t{\"dir/other.txt\", \"other.txt\", 23, 0600, false},\n+\t\t\t\t{\"dir/subdir\", \"subdir\", 0, fs.ModeDir | 0500, true},\n+\t\t\t\t{\"dir/subdir/file.txt\", \"file.txt\", 23, 0600, false},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tinitOverlay(t, tc.overlay)\n+\n+\t\t\tvar got []file\n+\t\t\tWalk(tc.root, func(path string, info fs.FileInfo, err error) error {\n+\t\t\t\tgot = append(got, file{path, info.Name(), info.Size(), info.Mode(), info.IsDir()})\n+\t\t\t\treturn nil\n+\t\t\t})\n+\n+\t\t\tif len(got) != len(tc.wantFiles) {\n+\t\t\t\tt.Errorf(\"Walk: saw %#v in walk; want %#v\", got, tc.wantFiles)\n+\t\t\t}\n+\t\t\tfor i := 0; i < len(got) && i < len(tc.wantFiles); i++ {\n+\t\t\t\twantPath := filepath.FromSlash(tc.wantFiles[i].path)\n+\t\t\t\tif got[i].path != wantPath {\n+\t\t\t\t\tt.Errorf(\"path of file #%v in walk, got %q, want %q\", i, got[i].path, wantPath)\n+\t\t\t\t}\n+\t\t\t\tif got[i].name != tc.wantFiles[i].name {\n+\t\t\t\t\tt.Errorf(\"name of file #%v in walk, got %q, want %q\", i, got[i].name, tc.wantFiles[i].name)\n+\t\t\t\t}\n+\t\t\t\tif got[i].mode&(fs.ModeDir|0700) != tc.wantFiles[i].mode {\n+\t\t\t\t\tt.Errorf(\"mode&(fs.ModeDir|0700) for mode of file #%v in walk, got %v, want %v\", i, got[i].mode&(fs.ModeDir|0700), tc.wantFiles[i].mode)\n+\t\t\t\t}\n+\t\t\t\tif got[i].isDir != tc.wantFiles[i].isDir {\n+\t\t\t\t\tt.Errorf(\"isDir for file #%v in walk, got %v, want %v\", i, got[i].isDir, tc.wantFiles[i].isDir)\n+\t\t\t\t}\n+\t\t\t\tif tc.wantFiles[i].isDir {\n+\t\t\t\t\tcontinue // don't check size for directories\n+\t\t\t\t}\n+\t\t\t\tif got[i].size != tc.wantFiles[i].size {\n+\t\t\t\t\tt.Errorf(\"size of file #%v in walk, got %v, want %v\", i, got[i].size, tc.wantFiles[i].size)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestWalkSkipDir(t *testing.T) {\n+\tinitOverlay(t, `\n+{\n+\t\"Replace\": {\n+\t\t\"dir/skip/file.go\": \"dummy.txt\",\n+\t\t\"dir/dontskip/file.go\": \"dummy.txt\",\n+\t\t\"dir/dontskip/skip/file.go\": \"dummy.txt\"\n+\t}\n+}\n+-- dummy.txt --\n+`)\n+\n+\tvar seen []string\n+\tWalk(\"dir\", func(path string, info fs.FileInfo, err error) error {\n+\t\tseen = append(seen, filepath.ToSlash(path))\n+\t\tif info.Name() == \"skip\" {\n+\t\t\treturn filepath.SkipDir\n+\t\t}\n+\t\treturn nil\n+\t})\n+\n+\twantSeen := []string{\"dir\", \"dir/dontskip\", \"dir/dontskip/file.go\", \"dir/dontskip/skip\", \"dir/skip\"}\n+\n+\tif len(seen) != len(wantSeen) {\n+\t\tt.Errorf(\"paths seen in walk: got %v entries; want %v entries\", len(seen), len(wantSeen))\n+\t}\n+\n+\tfor i := 0; i < len(seen) && i < len(wantSeen); i++ {\n+\t\tif seen[i] != wantSeen[i] {\n+\t\t\tt.Errorf(\"path #%v seen walking tree: want %q, got %q\", i, seen[i], wantSeen[i])\n+\t\t}\n+\t}\n+}\n+\n+func TestWalkError(t *testing.T) {\n+\tinitOverlay(t, \"{}\")\n+\n+\talreadyCalled := false\n+\terr := Walk(\"foo\", func(path string, info fs.FileInfo, err error) error {\n+\t\tif alreadyCalled {\n+\t\t\tt.Fatal(\"expected walk function to be called exactly once, but it was called more than once\")\n+\t\t}\n+\t\talreadyCalled = true\n+\t\treturn errors.New(\"returned from function\")\n+\t})\n+\tif !alreadyCalled {\n+\t\tt.Fatal(\"expected walk function to be called exactly once, but it was never called\")\n+\n+\t}\n+\tif err == nil {\n+\t\tt.Fatalf(\"Walk: got no error, want error\")\n+\t}\n+\tif err.Error() != \"returned from function\" {\n+\t\tt.Fatalf(\"Walk: got error %v, want \\\"returned from function\\\" error\", err)\n+\t}\n+}\n+\n+func TestWalkSymlink(t *testing.T) {\n+\ttestenv.MustHaveSymlink(t)\n+\n+\tinitOverlay(t, `{\n+\t\"Replace\": {\"overlay_symlink\": \"symlink\"}\n+}\n+-- dir/file --`)\n+\n+\t// Create symlink\n+\tif err := os.Symlink(\"dir\", \"symlink\"); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\ttestCases := []struct {\n+\t\tname      string\n+\t\tdir       string\n+\t\twantFiles []string\n+\t}{\n+\t\t{\"control\", \"dir\", []string{\"dir\", \"dir\" + string(filepath.Separator) + \"file\"}},\n+\t\t// ensure Walk doesn't walk into the directory pointed to by the symlink\n+\t\t// (because it's supposed to use Lstat instead of Stat).\n+\t\t{\"symlink_to_dir\", \"symlink\", []string{\"symlink\"}},\n+\t\t{\"overlay_to_symlink_to_dir\", \"overlay_symlink\", []string{\"overlay_symlink\"}},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tvar got []string\n+\n+\t\t\terr := Walk(tc.dir, func(path string, info fs.FileInfo, err error) error {\n+\t\t\t\tgot = append(got, path)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"walkfn: got non nil err argument: %v, want nil err argument\", err)\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t})\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"Walk: got error %q, want nil\", err)\n+\t\t\t}\n+\n+\t\t\tif !reflect.DeepEqual(got, tc.wantFiles) {\n+\t\t\t\tt.Errorf(\"files examined by walk: got %v, want %v\", got, tc.wantFiles)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+}\n+\n+func TestLstat(t *testing.T) {\n+\ttype file struct {\n+\t\tname  string\n+\t\tsize  int64\n+\t\tmode  fs.FileMode // mode & (fs.ModeDir|0x700): only check 'user' permissions\n+\t\tisDir bool\n+\t}\n+\n+\ttestCases := []struct {\n+\t\tname    string\n+\t\toverlay string\n+\t\tpath    string\n+\n+\t\twant    file\n+\t\twantErr bool\n+\t}{\n+\t\t{\n+\t\t\t\"regular_file\",\n+\t\t\t`{}\n+-- file.txt --\n+contents`,\n+\t\t\t\"file.txt\",\n+\t\t\tfile{\"file.txt\", 9, 0600, false},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"new_file_in_overlay\",\n+\t\t\t`{\"Replace\": {\"file.txt\": \"dummy.txt\"}}\n+-- dummy.txt --\n+contents`,\n+\t\t\t\"file.txt\",\n+\t\t\tfile{\"file.txt\", 9, 0600, false},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"file_replaced_in_overlay\",\n+\t\t\t`{\"Replace\": {\"file.txt\": \"dummy.txt\"}}\n+-- file.txt --\n+-- dummy.txt --\n+contents`,\n+\t\t\t\"file.txt\",\n+\t\t\tfile{\"file.txt\", 9, 0600, false},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"file_cant_exist\",\n+\t\t\t`{\"Replace\": {\"deleted\": \"dummy.txt\"}}\n+-- deleted/file.txt --\n+-- dummy.txt --\n+`,\n+\t\t\t\"deleted/file.txt\",\n+\t\t\tfile{},\n+\t\t\ttrue,\n+\t\t},\n+\t\t{\n+\t\t\t\"deleted\",\n+\t\t\t`{\"Replace\": {\"deleted\": \"\"}}\n+-- deleted --\n+`,\n+\t\t\t\"deleted\",\n+\t\t\tfile{},\n+\t\t\ttrue,\n+\t\t},\n+\t\t{\n+\t\t\t\"dir_on_disk\",\n+\t\t\t`{}\n+-- dir/foo.txt --\n+`,\n+\t\t\t\"dir\",\n+\t\t\tfile{\"dir\", 0, 0700 | fs.ModeDir, true},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"dir_in_overlay\",\n+\t\t\t`{\"Replace\": {\"dir/file.txt\": \"dummy.txt\"}}\n+-- dummy.txt --\n+`,\n+\t\t\t\"dir\",\n+\t\t\tfile{\"dir\", 0, 0500 | fs.ModeDir, true},\n+\t\t\tfalse,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tinitOverlay(t, tc.overlay)\n+\t\t\tgot, err := Lstat(tc.path)\n+\t\t\tif tc.wantErr {\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tt.Errorf(\"lstat(%q): got no error, want error\", tc.path)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"lstat(%q): got error %v, want no error\", tc.path, err)\n+\t\t\t}\n+\t\t\tif got.Name() != tc.want.name {\n+\t\t\t\tt.Errorf(\"lstat(%q).Name(): got %q, want %q\", tc.path, got.Name(), tc.want.name)\n+\t\t\t}\n+\t\t\tif got.Mode()&(fs.ModeDir|0700) != tc.want.mode {\n+\t\t\t\tt.Errorf(\"lstat(%q).Mode()&(fs.ModeDir|0700): got %v, want %v\", tc.path, got.Mode()&(fs.ModeDir|0700), tc.want.mode)\n+\t\t\t}\n+\t\t\tif got.IsDir() != tc.want.isDir {\n+\t\t\t\tt.Errorf(\"lstat(%q).IsDir(): got %v, want %v\", tc.path, got.IsDir(), tc.want.isDir)\n+\t\t\t}\n+\t\t\tif tc.want.isDir {\n+\t\t\t\treturn // don't check size for directories\n+\t\t\t}\n+\t\t\tif got.Size() != tc.want.size {\n+\t\t\t\tt.Errorf(\"lstat(%q).Size(): got %v, want %v\", tc.path, got.Size(), tc.want.size)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestStat(t *testing.T) {\n+\ttestenv.MustHaveSymlink(t)\n+\n+\ttype file struct {\n+\t\tname  string\n+\t\tsize  int64\n+\t\tmode  os.FileMode // mode & (os.ModeDir|0x700): only check 'user' permissions\n+\t\tisDir bool\n+\t}\n+\n+\ttestCases := []struct {\n+\t\tname    string\n+\t\toverlay string\n+\t\tpath    string\n+\n+\t\twant    file\n+\t\twantErr bool\n+\t}{\n+\t\t{\n+\t\t\t\"regular_file\",\n+\t\t\t`{}\n+-- file.txt --\n+contents`,\n+\t\t\t\"file.txt\",\n+\t\t\tfile{\"file.txt\", 9, 0600, false},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"new_file_in_overlay\",\n+\t\t\t`{\"Replace\": {\"file.txt\": \"dummy.txt\"}}\n+-- dummy.txt --\n+contents`,\n+\t\t\t\"file.txt\",\n+\t\t\tfile{\"file.txt\", 9, 0600, false},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"file_replaced_in_overlay\",\n+\t\t\t`{\"Replace\": {\"file.txt\": \"dummy.txt\"}}\n+-- file.txt --\n+-- dummy.txt --\n+contents`,\n+\t\t\t\"file.txt\",\n+\t\t\tfile{\"file.txt\", 9, 0600, false},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"file_cant_exist\",\n+\t\t\t`{\"Replace\": {\"deleted\": \"dummy.txt\"}}\n+-- deleted/file.txt --\n+-- dummy.txt --\n+`,\n+\t\t\t\"deleted/file.txt\",\n+\t\t\tfile{},\n+\t\t\ttrue,\n+\t\t},\n+\t\t{\n+\t\t\t\"deleted\",\n+\t\t\t`{\"Replace\": {\"deleted\": \"\"}}\n+-- deleted --\n+`,\n+\t\t\t\"deleted\",\n+\t\t\tfile{},\n+\t\t\ttrue,\n+\t\t},\n+\t\t{\n+\t\t\t\"dir_on_disk\",\n+\t\t\t`{}\n+-- dir/foo.txt --\n+`,\n+\t\t\t\"dir\",\n+\t\t\tfile{\"dir\", 0, 0700 | os.ModeDir, true},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"dir_in_overlay\",\n+\t\t\t`{\"Replace\": {\"dir/file.txt\": \"dummy.txt\"}}\n+-- dummy.txt --\n+`,\n+\t\t\t\"dir\",\n+\t\t\tfile{\"dir\", 0, 0500 | os.ModeDir, true},\n+\t\t\tfalse,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tinitOverlay(t, tc.overlay)\n+\t\t\tgot, err := Stat(tc.path)\n+\t\t\tif tc.wantErr {\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tt.Errorf(\"Stat(%q): got no error, want error\", tc.path)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"Stat(%q): got error %v, want no error\", tc.path, err)\n+\t\t\t}\n+\t\t\tif got.Name() != tc.want.name {\n+\t\t\t\tt.Errorf(\"Stat(%q).Name(): got %q, want %q\", tc.path, got.Name(), tc.want.name)\n+\t\t\t}\n+\t\t\tif got.Mode()&(os.ModeDir|0700) != tc.want.mode {\n+\t\t\t\tt.Errorf(\"Stat(%q).Mode()&(os.ModeDir|0700): got %v, want %v\", tc.path, got.Mode()&(os.ModeDir|0700), tc.want.mode)\n+\t\t\t}\n+\t\t\tif got.IsDir() != tc.want.isDir {\n+\t\t\t\tt.Errorf(\"Stat(%q).IsDir(): got %v, want %v\", tc.path, got.IsDir(), tc.want.isDir)\n+\t\t\t}\n+\t\t\tif tc.want.isDir {\n+\t\t\t\treturn // don't check size for directories\n+\t\t\t}\n+\t\t\tif got.Size() != tc.want.size {\n+\t\t\t\tt.Errorf(\"Stat(%q).Size(): got %v, want %v\", tc.path, got.Size(), tc.want.size)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestStatSymlink(t *testing.T) {\n+\ttestenv.MustHaveSymlink(t)\n+\n+\tinitOverlay(t, `{\n+\t\"Replace\": {\"file.go\": \"symlink\"}\n+}\n+-- to.go --\n+0123456789\n+`)\n+\n+\t// Create symlink\n+\tif err := os.Symlink(\"to.go\", \"symlink\"); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\tf := \"file.go\"\n+\tfi, err := Stat(f)\n+\tif err != nil {\n+\t\tt.Errorf(\"Stat(%q): got error %q, want nil error\", f, err)\n+\t}\n+\n+\tif !fi.Mode().IsRegular() {\n+\t\tt.Errorf(\"Stat(%q).Mode(): got %v, want regular mode\", f, fi.Mode())\n+\t}\n+\n+\tif fi.Size() != 11 {\n+\t\tt.Errorf(\"Stat(%q).Size(): got %v, want 11\", f, fi.Size())\n+\t}\n+}"}, {"sha": "c7401948b8b314e8dab26576ed4c6940e4080d1d", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,11 +8,11 @@ package generate\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"context\"\n \t\"fmt\"\n \t\"go/parser\"\n \t\"go/token\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -160,7 +160,7 @@ func init() {\n \tCmdGenerate.Flag.StringVar(&generateRunFlag, \"run\", \"\", \"\")\n }\n \n-func runGenerate(cmd *base.Command, args []string) {\n+func runGenerate(ctx context.Context, cmd *base.Command, args []string) {\n \tload.IgnoreImports = true\n \n \tif generateRunFlag != \"\" {\n@@ -175,7 +175,7 @@ func runGenerate(cmd *base.Command, args []string) {\n \n \t// Even if the arguments are .go files, this loop suffices.\n \tprinted := false\n-\tfor _, pkg := range load.PackagesAndErrors(args) {\n+\tfor _, pkg := range load.PackagesAndErrors(ctx, args) {\n \t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: not generating in packages in dependency modules\\n\")\n@@ -200,7 +200,7 @@ func runGenerate(cmd *base.Command, args []string) {\n \n // generate runs the generation directives for a single file.\n func generate(absFile string) bool {\n-\tsrc, err := ioutil.ReadFile(absFile)\n+\tsrc, err := os.ReadFile(absFile)\n \tif err != nil {\n \t\tlog.Fatalf(\"generate: %s\", err)\n \t}"}, {"sha": "94a42c4f73a2b71018e968bc542700db4ce65130", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,6 +6,7 @@\n package get\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -17,8 +18,11 @@ import (\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/vcs\"\n \t\"cmd/go/internal/web\"\n \t\"cmd/go/internal/work\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n var CmdGet = &base.Command{\n@@ -41,6 +45,10 @@ before resolving dependencies or building the code.\n \n The -insecure flag permits fetching from repositories and resolving\n custom domains using insecure schemes such as HTTP. Use with caution.\n+This flag is deprecated and will be removed in a future version of go.\n+The GOINSECURE environment variable should be used instead, since it\n+provides control over which packages may be retrieved using an insecure\n+scheme. See 'go help environment' for details.\n \n The -t flag instructs get to also download the packages required to build\n the tests for the specified packages.\n@@ -102,17 +110,15 @@ var (\n \tgetT   = CmdGet.Flag.Bool(\"t\", false, \"\")\n \tgetU   = CmdGet.Flag.Bool(\"u\", false, \"\")\n \tgetFix = CmdGet.Flag.Bool(\"fix\", false, \"\")\n-\n-\tInsecure bool\n )\n \n func init() {\n \twork.AddBuildFlags(CmdGet, work.OmitModFlag|work.OmitModCommonFlags)\n \tCmdGet.Run = runGet // break init loop\n-\tCmdGet.Flag.BoolVar(&Insecure, \"insecure\", Insecure, \"\")\n+\tCmdGet.Flag.BoolVar(&cfg.Insecure, \"insecure\", cfg.Insecure, \"\")\n }\n \n-func runGet(cmd *base.Command, args []string) {\n+func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \tif cfg.ModulesEnabled {\n \t\t// Should not happen: main.go should install the separate module-enabled get code.\n \t\tbase.Fatalf(\"go get: modules not implemented\")\n@@ -123,6 +129,9 @@ func runGet(cmd *base.Command, args []string) {\n \tif *getF && !*getU {\n \t\tbase.Fatalf(\"go get: cannot use -f flag without -u\")\n \t}\n+\tif cfg.Insecure {\n+\t\tfmt.Fprintf(os.Stderr, \"go get: -insecure flag is deprecated; see 'go help get' for details\\n\")\n+\t}\n \n \t// Disable any prompting for passwords by Git.\n \t// Only has an effect for 2.3.0 or later, but avoiding\n@@ -171,17 +180,18 @@ func runGet(cmd *base.Command, args []string) {\n \t// everything.\n \tload.ClearPackageCache()\n \n-\tpkgs := load.PackagesForBuild(args)\n+\tpkgs := load.PackagesAndErrors(ctx, args)\n+\tload.CheckPackageErrors(pkgs)\n \n \t// Phase 3. Install.\n \tif *getD {\n \t\t// Download only.\n-\t\t// Check delayed until now so that importPaths\n-\t\t// and packagesForBuild have a chance to print errors.\n+\t\t// Check delayed until now so that downloadPaths\n+\t\t// and CheckPackageErrors have a chance to print errors.\n \t\treturn\n \t}\n \n-\twork.InstallPackages(args, pkgs)\n+\twork.InstallPackages(ctx, args, pkgs)\n }\n \n // downloadPaths prepares the list of paths to pass to download.\n@@ -245,9 +255,9 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \tload1 := func(path string, mode int) *load.Package {\n \t\tif parent == nil {\n \t\t\tmode := 0 // don't do module or vendor resolution\n-\t\t\treturn load.LoadImport(path, base.Cwd, nil, stk, nil, mode)\n+\t\t\treturn load.LoadImport(context.TODO(), path, base.Cwd, nil, stk, nil, mode)\n \t\t}\n-\t\treturn load.LoadImport(path, parent.Dir, parent, stk, nil, mode|load.ResolveModule)\n+\t\treturn load.LoadImport(context.TODO(), path, parent.Dir, parent, stk, nil, mode|load.ResolveModule)\n \t}\n \n \tp := load1(arg, mode)\n@@ -402,17 +412,12 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n // to make the first copy of or update a copy of the given package.\n func downloadPackage(p *load.Package) error {\n \tvar (\n-\t\tvcs            *vcsCmd\n+\t\tvcsCmd         *vcs.Cmd\n \t\trepo, rootPath string\n \t\terr            error\n \t\tblindRepo      bool // set if the repo has unusual configuration\n \t)\n \n-\tsecurity := web.SecureOnly\n-\tif Insecure {\n-\t\tsecurity = web.Insecure\n-\t}\n-\n \t// p can be either a real package, or a pseudo-package whose \u201cimport path\u201d is\n \t// actually a wildcard pattern.\n \t// Trim the path at the element containing the first wildcard,\n@@ -426,33 +431,37 @@ func downloadPackage(p *load.Package) error {\n \t\t}\n \t\timportPrefix = importPrefix[:slash]\n \t}\n-\tif err := CheckImportPath(importPrefix); err != nil {\n+\tif err := module.CheckImportPath(importPrefix); err != nil {\n \t\treturn fmt.Errorf(\"%s: invalid import path: %v\", p.ImportPath, err)\n \t}\n+\tsecurity := web.SecureOnly\n+\tif cfg.Insecure || module.MatchPrefixPatterns(cfg.GOINSECURE, importPrefix) {\n+\t\tsecurity = web.Insecure\n+\t}\n \n \tif p.Internal.Build.SrcRoot != \"\" {\n \t\t// Directory exists. Look for checkout along path to src.\n-\t\tvcs, rootPath, err = vcsFromDir(p.Dir, p.Internal.Build.SrcRoot)\n+\t\tvcsCmd, rootPath, err = vcs.FromDir(p.Dir, p.Internal.Build.SrcRoot)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t\trepo = \"<local>\" // should be unused; make distinctive\n \n \t\t// Double-check where it came from.\n-\t\tif *getU && vcs.remoteRepo != nil {\n+\t\tif *getU && vcsCmd.RemoteRepo != nil {\n \t\t\tdir := filepath.Join(p.Internal.Build.SrcRoot, filepath.FromSlash(rootPath))\n-\t\t\tremote, err := vcs.remoteRepo(vcs, dir)\n+\t\t\tremote, err := vcsCmd.RemoteRepo(vcsCmd, dir)\n \t\t\tif err != nil {\n \t\t\t\t// Proceed anyway. The package is present; we likely just don't understand\n \t\t\t\t// the repo configuration (e.g. unusual remote protocol).\n \t\t\t\tblindRepo = true\n \t\t\t}\n \t\t\trepo = remote\n \t\t\tif !*getF && err == nil {\n-\t\t\t\tif rr, err := RepoRootForImportPath(importPrefix, IgnoreMod, security); err == nil {\n+\t\t\t\tif rr, err := vcs.RepoRootForImportPath(importPrefix, vcs.IgnoreMod, security); err == nil {\n \t\t\t\t\trepo := rr.Repo\n-\t\t\t\t\tif rr.vcs.resolveRepo != nil {\n-\t\t\t\t\t\tresolved, err := rr.vcs.resolveRepo(rr.vcs, dir, repo)\n+\t\t\t\t\tif rr.VCS.ResolveRepo != nil {\n+\t\t\t\t\t\tresolved, err := rr.VCS.ResolveRepo(rr.VCS, dir, repo)\n \t\t\t\t\t\tif err == nil {\n \t\t\t\t\t\t\trepo = resolved\n \t\t\t\t\t\t}\n@@ -466,13 +475,13 @@ func downloadPackage(p *load.Package) error {\n \t} else {\n \t\t// Analyze the import path to determine the version control system,\n \t\t// repository, and the import path for the root of the repository.\n-\t\trr, err := RepoRootForImportPath(importPrefix, IgnoreMod, security)\n+\t\trr, err := vcs.RepoRootForImportPath(importPrefix, vcs.IgnoreMod, security)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tvcs, repo, rootPath = rr.vcs, rr.Repo, rr.Root\n+\t\tvcsCmd, repo, rootPath = rr.VCS, rr.Repo, rr.Root\n \t}\n-\tif !blindRepo && !vcs.isSecure(repo) && !Insecure {\n+\tif !blindRepo && !vcsCmd.IsSecure(repo) && security != web.Insecure {\n \t\treturn fmt.Errorf(\"cannot download, %v uses insecure protocol\", repo)\n \t}\n \n@@ -495,7 +504,7 @@ func downloadPackage(p *load.Package) error {\n \t}\n \troot := filepath.Join(p.Internal.Build.SrcRoot, filepath.FromSlash(rootPath))\n \n-\tif err := checkNestedVCS(vcs, root, p.Internal.Build.SrcRoot); err != nil {\n+\tif err := vcs.CheckNested(vcsCmd, root, p.Internal.Build.SrcRoot); err != nil {\n \t\treturn err\n \t}\n \n@@ -511,7 +520,7 @@ func downloadPackage(p *load.Package) error {\n \n \t// Check that this is an appropriate place for the repo to be checked out.\n \t// The target directory must either not exist or have a repo checked out already.\n-\tmeta := filepath.Join(root, \".\"+vcs.cmd)\n+\tmeta := filepath.Join(root, \".\"+vcsCmd.Cmd)\n \tif _, err := os.Stat(meta); err != nil {\n \t\t// Metadata file or directory does not exist. Prepare to checkout new copy.\n \t\t// Some version control tools require the target directory not to exist.\n@@ -532,12 +541,12 @@ func downloadPackage(p *load.Package) error {\n \t\t\tfmt.Fprintf(os.Stderr, \"created GOPATH=%s; see 'go help gopath'\\n\", p.Internal.Build.Root)\n \t\t}\n \n-\t\tif err = vcs.create(root, repo); err != nil {\n+\t\tif err = vcsCmd.Create(root, repo); err != nil {\n \t\t\treturn err\n \t\t}\n \t} else {\n \t\t// Metadata directory does exist; download incremental updates.\n-\t\tif err = vcs.download(root); err != nil {\n+\t\tif err = vcsCmd.Download(root); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -546,20 +555,20 @@ func downloadPackage(p *load.Package) error {\n \t\t// Do not show tag sync in -n; it's noise more than anything,\n \t\t// and since we're not running commands, no tag will be found.\n \t\t// But avoid printing nothing.\n-\t\tfmt.Fprintf(os.Stderr, \"# cd %s; %s sync/update\\n\", root, vcs.cmd)\n+\t\tfmt.Fprintf(os.Stderr, \"# cd %s; %s sync/update\\n\", root, vcsCmd.Cmd)\n \t\treturn nil\n \t}\n \n \t// Select and sync to appropriate version of the repository.\n-\ttags, err := vcs.tags(root)\n+\ttags, err := vcsCmd.Tags(root)\n \tif err != nil {\n \t\treturn err\n \t}\n \tvers := runtime.Version()\n \tif i := strings.Index(vers, \" \"); i >= 0 {\n \t\tvers = vers[:i]\n \t}\n-\tif err := vcs.tagSync(root, selectTag(vers, tags)); err != nil {\n+\tif err := vcsCmd.TagSync(root, selectTag(vers, tags)); err != nil {\n \t\treturn err\n \t}\n "}, {"sha": "ce2e0cdd709828efab7803c1df744152888e4105", "filename": "libgo/go/cmd/go/internal/get/path.go", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go?ref=0696141107d61483f38482b941549959a0d7f613", "patch": "@@ -1,192 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package get\n-\n-import (\n-\t\"fmt\"\n-\t\"strings\"\n-\t\"unicode\"\n-\t\"unicode/utf8\"\n-)\n-\n-// The following functions are copied verbatim from golang.org/x/mod/module/module.go,\n-// with a change to additionally reject Windows short-names,\n-// and one to accept arbitrary letters (golang.org/issue/29101).\n-//\n-// TODO(bcmills): After the call site for this function is backported,\n-// consolidate this back down to a single copy.\n-//\n-// NOTE: DO NOT MERGE THESE UNTIL WE DECIDE ABOUT ARBITRARY LETTERS IN MODULE MODE.\n-\n-// CheckImportPath checks that an import path is valid.\n-func CheckImportPath(path string) error {\n-\tif err := checkPath(path, false); err != nil {\n-\t\treturn fmt.Errorf(\"malformed import path %q: %v\", path, err)\n-\t}\n-\treturn nil\n-}\n-\n-// checkPath checks that a general path is valid.\n-// It returns an error describing why but not mentioning path.\n-// Because these checks apply to both module paths and import paths,\n-// the caller is expected to add the \"malformed ___ path %q: \" prefix.\n-// fileName indicates whether the final element of the path is a file name\n-// (as opposed to a directory name).\n-func checkPath(path string, fileName bool) error {\n-\tif !utf8.ValidString(path) {\n-\t\treturn fmt.Errorf(\"invalid UTF-8\")\n-\t}\n-\tif path == \"\" {\n-\t\treturn fmt.Errorf(\"empty string\")\n-\t}\n-\tif path[0] == '-' {\n-\t\treturn fmt.Errorf(\"leading dash\")\n-\t}\n-\tif strings.Contains(path, \"//\") {\n-\t\treturn fmt.Errorf(\"double slash\")\n-\t}\n-\tif path[len(path)-1] == '/' {\n-\t\treturn fmt.Errorf(\"trailing slash\")\n-\t}\n-\telemStart := 0\n-\tfor i, r := range path {\n-\t\tif r == '/' {\n-\t\t\tif err := checkElem(path[elemStart:i], fileName); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\telemStart = i + 1\n-\t\t}\n-\t}\n-\tif err := checkElem(path[elemStart:], fileName); err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-// checkElem checks whether an individual path element is valid.\n-// fileName indicates whether the element is a file name (not a directory name).\n-func checkElem(elem string, fileName bool) error {\n-\tif elem == \"\" {\n-\t\treturn fmt.Errorf(\"empty path element\")\n-\t}\n-\tif strings.Count(elem, \".\") == len(elem) {\n-\t\treturn fmt.Errorf(\"invalid path element %q\", elem)\n-\t}\n-\tif elem[0] == '.' && !fileName {\n-\t\treturn fmt.Errorf(\"leading dot in path element\")\n-\t}\n-\tif elem[len(elem)-1] == '.' {\n-\t\treturn fmt.Errorf(\"trailing dot in path element\")\n-\t}\n-\n-\tcharOK := pathOK\n-\tif fileName {\n-\t\tcharOK = fileNameOK\n-\t}\n-\tfor _, r := range elem {\n-\t\tif !charOK(r) {\n-\t\t\treturn fmt.Errorf(\"invalid char %q\", r)\n-\t\t}\n-\t}\n-\n-\t// Windows disallows a bunch of path elements, sadly.\n-\t// See https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file\n-\tshort := elem\n-\tif i := strings.Index(short, \".\"); i >= 0 {\n-\t\tshort = short[:i]\n-\t}\n-\tfor _, bad := range badWindowsNames {\n-\t\tif strings.EqualFold(bad, short) {\n-\t\t\treturn fmt.Errorf(\"disallowed path element %q\", elem)\n-\t\t}\n-\t}\n-\n-\t// Reject path components that look like Windows short-names.\n-\t// Those usually end in a tilde followed by one or more ASCII digits.\n-\tif tilde := strings.LastIndexByte(short, '~'); tilde >= 0 && tilde < len(short)-1 {\n-\t\tsuffix := short[tilde+1:]\n-\t\tsuffixIsDigits := true\n-\t\tfor _, r := range suffix {\n-\t\t\tif r < '0' || r > '9' {\n-\t\t\t\tsuffixIsDigits = false\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tif suffixIsDigits {\n-\t\t\treturn fmt.Errorf(\"trailing tilde and digits in path element\")\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n-\n-// pathOK reports whether r can appear in an import path element.\n-//\n-// NOTE: This function DIVERGES from module mode pathOK by accepting Unicode letters.\n-func pathOK(r rune) bool {\n-\tif r < utf8.RuneSelf {\n-\t\treturn r == '+' || r == '-' || r == '.' || r == '_' || r == '~' ||\n-\t\t\t'0' <= r && r <= '9' ||\n-\t\t\t'A' <= r && r <= 'Z' ||\n-\t\t\t'a' <= r && r <= 'z'\n-\t}\n-\treturn unicode.IsLetter(r)\n-}\n-\n-// fileNameOK reports whether r can appear in a file name.\n-// For now we allow all Unicode letters but otherwise limit to pathOK plus a few more punctuation characters.\n-// If we expand the set of allowed characters here, we have to\n-// work harder at detecting potential case-folding and normalization collisions.\n-// See note about \"safe encoding\" below.\n-func fileNameOK(r rune) bool {\n-\tif r < utf8.RuneSelf {\n-\t\t// Entire set of ASCII punctuation, from which we remove characters:\n-\t\t//     ! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` { | } ~\n-\t\t// We disallow some shell special characters: \" ' * < > ? ` |\n-\t\t// (Note that some of those are disallowed by the Windows file system as well.)\n-\t\t// We also disallow path separators / : and \\ (fileNameOK is only called on path element characters).\n-\t\t// We allow spaces (U+0020) in file names.\n-\t\tconst allowed = \"!#$%&()+,-.=@[]^_{}~ \"\n-\t\tif '0' <= r && r <= '9' || 'A' <= r && r <= 'Z' || 'a' <= r && r <= 'z' {\n-\t\t\treturn true\n-\t\t}\n-\t\tfor i := 0; i < len(allowed); i++ {\n-\t\t\tif rune(allowed[i]) == r {\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t}\n-\t\treturn false\n-\t}\n-\t// It may be OK to add more ASCII punctuation here, but only carefully.\n-\t// For example Windows disallows < > \\, and macOS disallows :, so we must not allow those.\n-\treturn unicode.IsLetter(r)\n-}\n-\n-// badWindowsNames are the reserved file path elements on Windows.\n-// See https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file\n-var badWindowsNames = []string{\n-\t\"CON\",\n-\t\"PRN\",\n-\t\"AUX\",\n-\t\"NUL\",\n-\t\"COM1\",\n-\t\"COM2\",\n-\t\"COM3\",\n-\t\"COM4\",\n-\t\"COM5\",\n-\t\"COM6\",\n-\t\"COM7\",\n-\t\"COM8\",\n-\t\"COM9\",\n-\t\"LPT1\",\n-\t\"LPT2\",\n-\t\"LPT3\",\n-\t\"LPT4\",\n-\t\"LPT5\",\n-\t\"LPT6\",\n-\t\"LPT7\",\n-\t\"LPT8\",\n-\t\"LPT9\",\n-}"}, {"sha": "98f58441b4de605a75084887d3ea7c57232c8ee9", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -526,7 +526,7 @@ General-purpose environment variables:\n \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n \t\tof module path prefixes that should always be fetched directly\n \t\tor that should not be compared against the checksum database.\n-\t\tSee 'go help module-private'.\n+\t\tSee 'go help private'.\n \tGOROOT\n \t\tThe root of the go tree.\n \tGOSUMDB\n@@ -582,8 +582,8 @@ Architecture-specific environment variables:\n \t\tFor GOARCH=arm, the ARM architecture for which to compile.\n \t\tValid values are 5, 6, 7.\n \tGO386\n-\t\tFor GOARCH=386, the floating point instruction set.\n-\t\tValid values are 387, sse2.\n+\t\tFor GOARCH=386, how to implement floating point instructions.\n+\t\tValid values are sse2 (default), softfloat.\n \tGOMIPS\n \t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n \t\tValid values are hardfloat (default), softfloat.\n@@ -632,6 +632,8 @@ Additional information available from 'go env' but not read from the environment\n \t\tIf module-aware mode is disabled, GOMOD will be the empty string.\n \tGOTOOLDIR\n \t\tThe directory where the go tools (compile, cover, doc, etc...) are installed.\n+\tGOVERSION\n+\t\tThe version of the installed Go tree, as reported by runtime.Version.\n \t`,\n }\n \n@@ -838,6 +840,9 @@ in addition to android tags and files.\n Using GOOS=illumos matches build tags and files as for GOOS=solaris\n in addition to illumos tags and files.\n \n+Using GOOS=ios matches build tags and files as for GOOS=darwin\n+in addition to ios tags and files.\n+\n To keep a file from being considered for the build:\n \n \t// +build ignore"}, {"sha": "50aeabc578c93094ce776e99d25d0612e7397bbc", "filename": "libgo/go/cmd/go/internal/imports/build.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -141,6 +141,9 @@ func matchTag(name string, tags map[string]bool, want bool) bool {\n \tif name == \"solaris\" {\n \t\thave = have || tags[\"illumos\"]\n \t}\n+\tif name == \"darwin\" {\n+\t\thave = have || tags[\"ios\"]\n+\t}\n \treturn have == want\n }\n \n@@ -158,6 +161,7 @@ func matchTag(name string, tags map[string]bool, want bool) bool {\n // Exceptions:\n //     if GOOS=android, then files with GOOS=linux are also matched.\n //     if GOOS=illumos, then files with GOOS=solaris are also matched.\n+//     if GOOS=ios, then files with GOOS=darwin are also matched.\n //\n // If tags[\"*\"] is true, then MatchFile will consider all possible\n // GOOS and GOARCH to be available and will consequently\n@@ -208,6 +212,7 @@ var KnownOS = map[string]bool{\n \t\"freebsd\":   true,\n \t\"hurd\":      true,\n \t\"illumos\":   true,\n+\t\"ios\":       true,\n \t\"js\":        true,\n \t\"linux\":     true,\n \t\"nacl\":      true, // legacy; don't remove"}, {"sha": "5e270781d77bfeaca88908daf97d95d287ce7308", "filename": "libgo/go/cmd/go/internal/imports/read.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -198,7 +198,7 @@ func (r *importReader) readImport(imports *[]string) {\n \tr.readString(imports)\n }\n \n-// ReadComments is like ioutil.ReadAll, except that it only reads the leading\n+// ReadComments is like io.ReadAll, except that it only reads the leading\n // block of comments in the file.\n func ReadComments(f io.Reader) ([]byte, error) {\n \tr := &importReader{b: bufio.NewReader(f)}\n@@ -210,7 +210,7 @@ func ReadComments(f io.Reader) ([]byte, error) {\n \treturn r.buf, r.err\n }\n \n-// ReadImports is like ioutil.ReadAll, except that it expects a Go file as input\n+// ReadImports is like io.ReadAll, except that it expects a Go file as input\n // and stops reading the input once the imports have completed.\n func ReadImports(f io.Reader, reportSyntaxError bool, imports *[]string) ([]byte, error) {\n \tr := &importReader{b: bufio.NewReader(f)}"}, {"sha": "ee11a8708b5eaa26c904bbb41477c19aa773e136", "filename": "libgo/go/cmd/go/internal/imports/scan.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,16 +6,17 @@ package imports\n \n import (\n \t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"os\"\n+\t\"io/fs\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n+\n+\t\"cmd/go/internal/fsys\"\n )\n \n func ScanDir(dir string, tags map[string]bool) ([]string, []string, error) {\n-\tinfos, err := ioutil.ReadDir(dir)\n+\tinfos, err := fsys.ReadDir(dir)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n@@ -25,14 +26,14 @@ func ScanDir(dir string, tags map[string]bool) ([]string, []string, error) {\n \n \t\t// If the directory entry is a symlink, stat it to obtain the info for the\n \t\t// link target instead of the link itself.\n-\t\tif info.Mode()&os.ModeSymlink != 0 {\n-\t\t\tinfo, err = os.Stat(filepath.Join(dir, name))\n+\t\tif info.Mode()&fs.ModeSymlink != 0 {\n+\t\t\tinfo, err = fsys.Stat(filepath.Join(dir, name))\n \t\t\tif err != nil {\n \t\t\t\tcontinue // Ignore broken symlinks.\n \t\t\t}\n \t\t}\n \n-\t\tif info.Mode().IsRegular() && !strings.HasPrefix(name, \"_\") && strings.HasSuffix(name, \".go\") && MatchFile(name, tags) {\n+\t\tif info.Mode().IsRegular() && !strings.HasPrefix(name, \"_\") && !strings.HasPrefix(name, \".\") && strings.HasSuffix(name, \".go\") && MatchFile(name, tags) {\n \t\t\tfiles = append(files, filepath.Join(dir, name))\n \t\t}\n \t}\n@@ -49,7 +50,7 @@ func scanFiles(files []string, tags map[string]bool, explicitFiles bool) ([]stri\n \tnumFiles := 0\n Files:\n \tfor _, name := range files {\n-\t\tr, err := os.Open(name)\n+\t\tr, err := fsys.Open(name)\n \t\tif err != nil {\n \t\t\treturn nil, nil, err\n \t\t}"}, {"sha": "2d245ee7872e73c706b15dcf6b2e1f9559248412", "filename": "libgo/go/cmd/go/internal/imports/scan_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,7 +7,7 @@ package imports\n import (\n \t\"bytes\"\n \t\"internal/testenv\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -57,7 +57,7 @@ func TestScan(t *testing.T) {\n func TestScanDir(t *testing.T) {\n \ttestenv.MustHaveGoBuild(t)\n \n-\tdirs, err := ioutil.ReadDir(\"testdata\")\n+\tdirs, err := os.ReadDir(\"testdata\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -66,7 +66,7 @@ func TestScanDir(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \t\tt.Run(dir.Name(), func(t *testing.T) {\n-\t\t\ttagsData, err := ioutil.ReadFile(filepath.Join(\"testdata\", dir.Name(), \"tags.txt\"))\n+\t\t\ttagsData, err := os.ReadFile(filepath.Join(\"testdata\", dir.Name(), \"tags.txt\"))\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"error reading tags: %v\", err)\n \t\t\t}\n@@ -75,7 +75,7 @@ func TestScanDir(t *testing.T) {\n \t\t\t\ttags[t] = true\n \t\t\t}\n \n-\t\t\twantData, err := ioutil.ReadFile(filepath.Join(\"testdata\", dir.Name(), \"want.txt\"))\n+\t\t\twantData, err := os.ReadFile(filepath.Join(\"testdata\", dir.Name(), \"want.txt\"))\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"error reading want: %v\", err)\n \t\t\t}"}, {"sha": "01b448b9142e57729bd19fdb380be7822cb08feb", "filename": "libgo/go/cmd/go/internal/imports/tags.go", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -4,17 +4,23 @@\n \n package imports\n \n-import \"cmd/go/internal/cfg\"\n+import (\n+\t\"cmd/go/internal/cfg\"\n+\t\"sync\"\n+)\n \n-var tags map[string]bool\n+var (\n+\ttags     map[string]bool\n+\ttagsOnce sync.Once\n+)\n \n // Tags returns a set of build tags that are true for the target platform.\n // It includes GOOS, GOARCH, the compiler, possibly \"cgo\",\n // release tags like \"go1.13\", and user-specified build tags.\n func Tags() map[string]bool {\n-\tif tags == nil {\n+\ttagsOnce.Do(func() {\n \t\ttags = loadTags()\n-\t}\n+\t})\n \treturn tags\n }\n \n@@ -36,14 +42,17 @@ func loadTags() map[string]bool {\n \treturn tags\n }\n \n-var anyTags map[string]bool\n+var (\n+\tanyTags     map[string]bool\n+\tanyTagsOnce sync.Once\n+)\n \n // AnyTags returns a special set of build tags that satisfy nearly all\n // build tag expressions. Only \"ignore\" and malformed build tag requirements\n // are considered false.\n func AnyTags() map[string]bool {\n-\tif anyTags == nil {\n+\tanyTagsOnce.Do(func() {\n \t\tanyTags = map[string]bool{\"*\": true}\n-\t}\n+\t})\n \treturn anyTags\n }"}, {"sha": "53c529e7774a6dcf883c17b2e9556fa3d3b1a726", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/.h.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2F.h.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2F.h.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2F.h.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -0,0 +1,3 @@\n+package android\n+\n+import _ \"h\""}, {"sha": "53c529e7774a6dcf883c17b2e9556fa3d3b1a726", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/.h.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2F.h.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2F.h.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2F.h.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -0,0 +1,3 @@\n+package android\n+\n+import _ \"h\""}, {"sha": "ce6f579c0583dc0151c0519aaf06cac71d652a0a", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 145, "deletions": 45, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,7 +8,9 @@ package list\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"context\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"sort\"\n@@ -19,6 +21,7 @@ import (\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modinfo\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/work\"\n@@ -63,26 +66,28 @@ to -f '{{.ImportPath}}'. The struct being passed to the template is:\n         BinaryOnly    bool     // binary-only package (no longer supported)\n         ForTest       string   // package is only for use in named test\n         Export        string   // file containing export data (when using -export)\n+        BuildID       string   // build ID of the compiled package (when using -export)\n         Module        *Module  // info about package's containing module, if any (can be nil)\n         Match         []string // command-line patterns matching this package\n         DepOnly       bool     // package is only a dependency, not explicitly listed\n \n         // Source files\n-        GoFiles         []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-        CgoFiles        []string // .go source files that import \"C\"\n-        CompiledGoFiles []string // .go files presented to compiler (when using -compiled)\n-        IgnoredGoFiles  []string // .go source files ignored due to build constraints\n-        CFiles          []string // .c source files\n-        CXXFiles        []string // .cc, .cxx and .cpp source files\n-        MFiles          []string // .m source files\n-        HFiles          []string // .h, .hh, .hpp and .hxx source files\n-        FFiles          []string // .f, .F, .for and .f90 Fortran source files\n-        SFiles          []string // .s source files\n-        SwigFiles       []string // .swig files\n-        SwigCXXFiles    []string // .swigcxx files\n-        SysoFiles       []string // .syso object files to add to archive\n-        TestGoFiles     []string // _test.go files in package\n-        XTestGoFiles    []string // _test.go files outside package\n+        GoFiles         []string   // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+        CgoFiles        []string   // .go source files that import \"C\"\n+        CompiledGoFiles []string   // .go files presented to compiler (when using -compiled)\n+        IgnoredGoFiles  []string   // .go source files ignored due to build constraints\n+        IgnoredOtherFiles []string // non-.go source files ignored due to build constraints\n+        CFiles          []string   // .c source files\n+        CXXFiles        []string   // .cc, .cxx and .cpp source files\n+        MFiles          []string   // .m source files\n+        HFiles          []string   // .h, .hh, .hpp and .hxx source files\n+        FFiles          []string   // .f, .F, .for and .f90 Fortran source files\n+        SFiles          []string   // .s source files\n+        SwigFiles       []string   // .swig files\n+        SwigCXXFiles    []string   // .swigcxx files\n+        SysoFiles       []string   // .syso object files to add to archive\n+        TestGoFiles     []string   // _test.go files in package\n+        XTestGoFiles    []string   // _test.go files outside package\n \n         // Cgo directives\n         CgoCFLAGS    []string // cgo: flags for C compiler\n@@ -213,6 +218,7 @@ applied to a Go struct, but now a Module struct:\n         Dir       string       // directory holding files for this module, if any\n         GoMod     string       // path to go.mod file used when loading this module, if any\n         GoVersion string       // go version used in module\n+        Retracted string       // retraction information, if any (with -retracted or -u)\n         Error     *ModuleError // error loading module\n     }\n \n@@ -244,14 +250,16 @@ the replaced source code.)\n The -u flag adds information about available upgrades.\n When the latest version of a given module is newer than\n the current one, list -u sets the Module's Update field\n-to information about the newer module.\n+to information about the newer module. list -u will also set\n+the module's Retracted field if the current version is retracted.\n The Module's String method indicates an available upgrade by\n formatting the newer version in brackets after the current version.\n+If a version is retracted, the string \"(retracted)\" will follow it.\n For example, 'go list -m -u all' might print:\n \n     my/main/module\n     golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text\n-    rsc.io/pdf v0.1.1 [v0.1.2]\n+    rsc.io/pdf v0.1.1 (retracted) [v0.1.2]\n \n (For tools, 'go list -m -u -json all' may be more convenient to parse.)\n \n@@ -261,6 +269,14 @@ to semantic versioning, earliest to latest. The flag also changes\n the default output format to display the module path followed by the\n space-separated version list.\n \n+The -retracted flag causes list to report information about retracted\n+module versions. When -retracted is used with -f or -json, the Retracted\n+field will be set to a string explaining why the version was retracted.\n+The string is taken from comments on the retract directive in the\n+module's go.mod file. When -retracted is used with -versions, retracted\n+versions are listed together with unretracted versions. The -retracted\n+flag may be used with or without -m.\n+\n The arguments to list -m are interpreted as a list of modules, not packages.\n The main module is the module containing the current directory.\n The active modules are the main module and its dependencies.\n@@ -294,23 +310,24 @@ func init() {\n }\n \n var (\n-\tlistCompiled = CmdList.Flag.Bool(\"compiled\", false, \"\")\n-\tlistDeps     = CmdList.Flag.Bool(\"deps\", false, \"\")\n-\tlistE        = CmdList.Flag.Bool(\"e\", false, \"\")\n-\tlistExport   = CmdList.Flag.Bool(\"export\", false, \"\")\n-\tlistFmt      = CmdList.Flag.String(\"f\", \"\", \"\")\n-\tlistFind     = CmdList.Flag.Bool(\"find\", false, \"\")\n-\tlistJson     = CmdList.Flag.Bool(\"json\", false, \"\")\n-\tlistM        = CmdList.Flag.Bool(\"m\", false, \"\")\n-\tlistU        = CmdList.Flag.Bool(\"u\", false, \"\")\n-\tlistTest     = CmdList.Flag.Bool(\"test\", false, \"\")\n-\tlistVersions = CmdList.Flag.Bool(\"versions\", false, \"\")\n+\tlistCompiled  = CmdList.Flag.Bool(\"compiled\", false, \"\")\n+\tlistDeps      = CmdList.Flag.Bool(\"deps\", false, \"\")\n+\tlistE         = CmdList.Flag.Bool(\"e\", false, \"\")\n+\tlistExport    = CmdList.Flag.Bool(\"export\", false, \"\")\n+\tlistFmt       = CmdList.Flag.String(\"f\", \"\", \"\")\n+\tlistFind      = CmdList.Flag.Bool(\"find\", false, \"\")\n+\tlistJson      = CmdList.Flag.Bool(\"json\", false, \"\")\n+\tlistM         = CmdList.Flag.Bool(\"m\", false, \"\")\n+\tlistRetracted = CmdList.Flag.Bool(\"retracted\", false, \"\")\n+\tlistTest      = CmdList.Flag.Bool(\"test\", false, \"\")\n+\tlistU         = CmdList.Flag.Bool(\"u\", false, \"\")\n+\tlistVersions  = CmdList.Flag.Bool(\"versions\", false, \"\")\n )\n \n var nl = []byte{'\\n'}\n \n-func runList(cmd *base.Command, args []string) {\n-\tmodload.LoadTests = *listTest\n+func runList(ctx context.Context, cmd *base.Command, args []string) {\n+\tload.ModResolveTests = *listTest\n \twork.BuildInit()\n \tout := newTrackingWriter(os.Stdout)\n \tdefer out.w.Flush()\n@@ -348,7 +365,7 @@ func runList(cmd *base.Command, args []string) {\n \t\tfm := template.FuncMap{\n \t\t\t\"join\":    strings.Join,\n \t\t\t\"context\": context,\n-\t\t\t\"module\":  modload.ModuleInfo,\n+\t\t\t\"module\":  func(path string) *modinfo.ModulePublic { return modload.ModuleInfo(ctx, path) },\n \t\t}\n \t\ttmpl, err := template.New(\"main\").Funcs(fm).Parse(*listFmt)\n \t\tif err != nil {\n@@ -365,6 +382,16 @@ func runList(cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n+\tmodload.Init()\n+\tif *listRetracted {\n+\t\tif cfg.BuildMod == \"vendor\" {\n+\t\t\tbase.Fatalf(\"go list -retracted cannot be used when vendoring is enabled\")\n+\t\t}\n+\t\tif !modload.Enabled() {\n+\t\t\tbase.Fatalf(\"go list -retracted can only be used in module-aware mode\")\n+\t\t}\n+\t}\n+\n \tif *listM {\n \t\t// Module mode.\n \t\tif *listCompiled {\n@@ -388,7 +415,7 @@ func runList(cmd *base.Command, args []string) {\n \t\t\tbase.Fatalf(\"go list -m: not using modules\")\n \t\t}\n \n-\t\tmodload.InitMod() // Parses go.mod and sets cfg.BuildMod.\n+\t\tmodload.LoadModFile(ctx) // Parses go.mod and sets cfg.BuildMod.\n \t\tif cfg.BuildMod == \"vendor\" {\n \t\t\tconst actionDisabledFormat = \"go list -m: can't %s using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\"\n \n@@ -412,9 +439,7 @@ func runList(cmd *base.Command, args []string) {\n \t\t\t}\n \t\t}\n \n-\t\tmodload.LoadBuildList()\n-\n-\t\tmods := modload.ListModules(args, *listU, *listVersions)\n+\t\tmods := modload.ListModules(ctx, args, *listU, *listVersions, *listRetracted)\n \t\tif !*listE {\n \t\t\tfor _, m := range mods {\n \t\t\t\tif m.Error != nil {\n@@ -446,11 +471,18 @@ func runList(cmd *base.Command, args []string) {\n \t}\n \n \tload.IgnoreImports = *listFind\n-\tvar pkgs []*load.Package\n-\tif *listE {\n-\t\tpkgs = load.PackagesAndErrors(args)\n-\t} else {\n-\t\tpkgs = load.Packages(args)\n+\tpkgs := load.PackagesAndErrors(ctx, args)\n+\tif !*listE {\n+\t\tw := 0\n+\t\tfor _, pkg := range pkgs {\n+\t\t\tif pkg.Error != nil {\n+\t\t\t\tbase.Errorf(\"%v\", pkg.Error)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tpkgs[w] = pkg\n+\t\t\tw++\n+\t\t}\n+\t\tpkgs = pkgs[:w]\n \t\tbase.ExitIfErrors()\n \t}\n \n@@ -476,9 +508,9 @@ func runList(cmd *base.Command, args []string) {\n \t\t\t\tvar pmain, ptest, pxtest *load.Package\n \t\t\t\tvar err error\n \t\t\t\tif *listE {\n-\t\t\t\t\tpmain, ptest, pxtest = load.TestPackagesAndErrors(p, nil)\n+\t\t\t\t\tpmain, ptest, pxtest = load.TestPackagesAndErrors(ctx, p, nil)\n \t\t\t\t} else {\n-\t\t\t\t\tpmain, ptest, pxtest, err = load.TestPackagesFor(p, nil)\n+\t\t\t\t\tpmain, ptest, pxtest, err = load.TestPackagesFor(ctx, p, nil)\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\tbase.Errorf(\"can't load test package: %s\", err)\n \t\t\t\t\t}\n@@ -520,7 +552,7 @@ func runList(cmd *base.Command, args []string) {\n \t\t// Note that -deps is applied after -test,\n \t\t// so that you only get descriptions of tests for the things named\n \t\t// explicitly on the command line, not for all dependencies.\n-\t\tpkgs = load.PackageList(pkgs)\n+\t\tpkgs = loadPackageList(pkgs)\n \t}\n \n \t// Do we need to run a build to gather information?\n@@ -538,13 +570,15 @@ func runList(cmd *base.Command, args []string) {\n \t\t\t\ta.Deps = append(a.Deps, b.AutoAction(work.ModeInstall, work.ModeInstall, p))\n \t\t\t}\n \t\t}\n-\t\tb.Do(a)\n+\t\tb.Do(ctx, a)\n \t}\n \n \tfor _, p := range pkgs {\n \t\t// Show vendor-expanded paths in listing\n \t\tp.TestImports = p.Resolve(p.TestImports)\n \t\tp.XTestImports = p.Resolve(p.XTestImports)\n+\t\tp.TestEmbedFiles = p.ResolveEmbed(p.TestEmbedPatterns)\n+\t\tp.XTestEmbedFiles = p.ResolveEmbed(p.XTestEmbedPatterns)\n \t\tp.DepOnly = !cmdline[p]\n \n \t\tif *listCompiled {\n@@ -555,7 +589,7 @@ func runList(cmd *base.Command, args []string) {\n \tif *listTest {\n \t\tall := pkgs\n \t\tif !*listDeps {\n-\t\t\tall = load.PackageList(pkgs)\n+\t\t\tall = loadPackageList(pkgs)\n \t\t}\n \t\t// Update import paths to distinguish the real package p\n \t\t// from p recompiled for q.test.\n@@ -605,6 +639,55 @@ func runList(cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n+\t// TODO(golang.org/issue/40676): This mechanism could be extended to support\n+\t// -u without -m.\n+\tif *listRetracted {\n+\t\t// Load retractions for modules that provide packages that will be printed.\n+\t\t// TODO(golang.org/issue/40775): Packages from the same module refer to\n+\t\t// distinct ModulePublic instance. It would be nice if they could all point\n+\t\t// to the same instance. This would require additional global state in\n+\t\t// modload.loaded, so that should be refactored first. For now, we update\n+\t\t// all instances.\n+\t\tmodToArg := make(map[*modinfo.ModulePublic]string)\n+\t\targToMods := make(map[string][]*modinfo.ModulePublic)\n+\t\tvar args []string\n+\t\taddModule := func(mod *modinfo.ModulePublic) {\n+\t\t\tif mod.Version == \"\" {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\targ := fmt.Sprintf(\"%s@%s\", mod.Path, mod.Version)\n+\t\t\tif argToMods[arg] == nil {\n+\t\t\t\targs = append(args, arg)\n+\t\t\t}\n+\t\t\targToMods[arg] = append(argToMods[arg], mod)\n+\t\t\tmodToArg[mod] = arg\n+\t\t}\n+\t\tfor _, p := range pkgs {\n+\t\t\tif p.Module == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\taddModule(p.Module)\n+\t\t\tif p.Module.Replace != nil {\n+\t\t\t\taddModule(p.Module.Replace)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif len(args) > 0 {\n+\t\t\tlistU := false\n+\t\t\tlistVersions := false\n+\t\t\trmods := modload.ListModules(ctx, args, listU, listVersions, *listRetracted)\n+\t\t\tfor i, arg := range args {\n+\t\t\t\trmod := rmods[i]\n+\t\t\t\tfor _, mod := range argToMods[arg] {\n+\t\t\t\t\tmod.Retracted = rmod.Retracted\n+\t\t\t\t\tif rmod.Error != nil && mod.Error == nil {\n+\t\t\t\t\t\tmod.Error = rmod.Error\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t// Record non-identity import mappings in p.ImportMap.\n \tfor _, p := range pkgs {\n \t\tfor i, srcPath := range p.Internal.RawImports {\n@@ -623,6 +706,23 @@ func runList(cmd *base.Command, args []string) {\n \t}\n }\n \n+// loadPackageList is like load.PackageList, but prints error messages and exits\n+// with nonzero status if listE is not set and any package in the expanded list\n+// has errors.\n+func loadPackageList(roots []*load.Package) []*load.Package {\n+\tpkgs := load.PackageList(roots)\n+\n+\tif !*listE {\n+\t\tfor _, pkg := range pkgs {\n+\t\t\tif pkg.Error != nil {\n+\t\t\t\tbase.Errorf(\"%v\", pkg.Error)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn pkgs\n+}\n+\n // TrackingWriter tracks the last byte written on every write so\n // we can avoid printing a newline if one was already written or\n // if there is no output at all."}, {"sha": "b3679728f1fed381467b562618ec6b183727bed7", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 339, "deletions": 153, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,14 +7,16 @@ package load\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"go/scanner\"\n \t\"go/token\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n+\t\"path\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -26,25 +28,14 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/modinfo\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/str\"\n-)\n-\n-var (\n-\t// module initialization hook; never nil, no-op if module use is disabled\n-\tModInit func()\n-\n-\t// module hooks; nil if module use is disabled\n-\tModBinDir            func() string                                                                            // return effective bin directory\n-\tModLookup            func(parentPath string, parentIsStd bool, path string) (dir, realPath string, err error) // lookup effective meaning of import\n-\tModPackageModuleInfo func(path string) *modinfo.ModulePublic                                                  // return module info for Package struct\n-\tModImportPaths       func(args []string) []*search.Match                                                      // expand import paths\n-\tModPackageBuildInfo  func(main string, deps []string) string                                                  // return module info to embed in binary\n-\tModInfoProg          func(info string, isgccgo bool) []byte                                                   // wrap module info in .go code for binary\n-\tModImportFromFiles   func([]string)                                                                           // update go.mod to add modules for imports in these files\n-\tModDirImportPath     func(string) string                                                                      // return effective import path for directory\n+\t\"cmd/go/internal/trace\"\n+\t\"cmd/internal/sys\"\n )\n \n var IgnoreImports bool // control whether we ignore imports in packages\n@@ -70,6 +61,7 @@ type PackagePublic struct {\n \tConflictDir   string                `json:\",omitempty\"` // Dir is hidden by this other directory\n \tForTest       string                `json:\",omitempty\"` // package is only for use in named test\n \tExport        string                `json:\",omitempty\"` // file containing export data (set by go list -export)\n+\tBuildID       string                `json:\",omitempty\"` // build ID of the compiled package (set by go list -export)\n \tModule        *modinfo.ModulePublic `json:\",omitempty\"` // info about package's module, if any\n \tMatch         []string              `json:\",omitempty\"` // command-line patterns matching this package\n \tGoroot        bool                  `json:\",omitempty\"` // is this package found in the Go root?\n@@ -87,19 +79,24 @@ type PackagePublic struct {\n \t// Source files\n \t// If you add to this list you MUST add to p.AllFiles (below) too.\n \t// Otherwise file name security lists will not apply to any new additions.\n-\tGoFiles         []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-\tCgoFiles        []string `json:\",omitempty\"` // .go source files that import \"C\"\n-\tCompiledGoFiles []string `json:\",omitempty\"` // .go output from running cgo on CgoFiles\n-\tIgnoredGoFiles  []string `json:\",omitempty\"` // .go source files ignored due to build constraints\n-\tCFiles          []string `json:\",omitempty\"` // .c source files\n-\tCXXFiles        []string `json:\",omitempty\"` // .cc, .cpp and .cxx source files\n-\tMFiles          []string `json:\",omitempty\"` // .m source files\n-\tHFiles          []string `json:\",omitempty\"` // .h, .hh, .hpp and .hxx source files\n-\tFFiles          []string `json:\",omitempty\"` // .f, .F, .for and .f90 Fortran source files\n-\tSFiles          []string `json:\",omitempty\"` // .s source files\n-\tSwigFiles       []string `json:\",omitempty\"` // .swig files\n-\tSwigCXXFiles    []string `json:\",omitempty\"` // .swigcxx files\n-\tSysoFiles       []string `json:\",omitempty\"` // .syso system object files added to package\n+\tGoFiles           []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+\tCgoFiles          []string `json:\",omitempty\"` // .go source files that import \"C\"\n+\tCompiledGoFiles   []string `json:\",omitempty\"` // .go output from running cgo on CgoFiles\n+\tIgnoredGoFiles    []string `json:\",omitempty\"` // .go source files ignored due to build constraints\n+\tIgnoredOtherFiles []string `json:\",omitempty\"` // non-.go source files ignored due to build constraints\n+\tCFiles            []string `json:\",omitempty\"` // .c source files\n+\tCXXFiles          []string `json:\",omitempty\"` // .cc, .cpp and .cxx source files\n+\tMFiles            []string `json:\",omitempty\"` // .m source files\n+\tHFiles            []string `json:\",omitempty\"` // .h, .hh, .hpp and .hxx source files\n+\tFFiles            []string `json:\",omitempty\"` // .f, .F, .for and .f90 Fortran source files\n+\tSFiles            []string `json:\",omitempty\"` // .s source files\n+\tSwigFiles         []string `json:\",omitempty\"` // .swig files\n+\tSwigCXXFiles      []string `json:\",omitempty\"` // .swigcxx files\n+\tSysoFiles         []string `json:\",omitempty\"` // .syso system object files added to package\n+\n+\t// Embedded files\n+\tEmbedPatterns []string `json:\",omitempty\"` // //go:embed patterns\n+\tEmbedFiles    []string `json:\",omitempty\"` // files and directories matched by EmbedPatterns\n \n \t// Cgo directives\n \tCgoCFLAGS    []string `json:\",omitempty\"` // cgo: flags for C compiler\n@@ -122,10 +119,14 @@ type PackagePublic struct {\n \t// Test information\n \t// If you add to this list you MUST add to p.AllFiles (below) too.\n \t// Otherwise file name security lists will not apply to any new additions.\n-\tTestGoFiles  []string `json:\",omitempty\"` // _test.go files in package\n-\tTestImports  []string `json:\",omitempty\"` // imports from TestGoFiles\n-\tXTestGoFiles []string `json:\",omitempty\"` // _test.go files outside package\n-\tXTestImports []string `json:\",omitempty\"` // imports from XTestGoFiles\n+\tTestGoFiles        []string `json:\",omitempty\"` // _test.go files in package\n+\tTestImports        []string `json:\",omitempty\"` // imports from TestGoFiles\n+\tTestEmbedPatterns  []string `json:\",omitempty\"` // //go:embed patterns\n+\tTestEmbedFiles     []string `json:\",omitempty\"` // //files matched by EmbedPatterns\n+\tXTestGoFiles       []string `json:\",omitempty\"` // _test.go files outside package\n+\tXTestImports       []string `json:\",omitempty\"` // imports from XTestGoFiles\n+\tXTestEmbedPatterns []string `json:\",omitempty\"` // //go:embed patterns\n+\tXTestEmbedFiles    []string `json:\",omitempty\"` // //files matched by EmbedPatterns\n }\n \n // AllFiles returns the names of all the files considered for the package.\n@@ -134,11 +135,12 @@ type PackagePublic struct {\n // The go/build package filtered others out (like foo_wrongGOARCH.s)\n // and that's OK.\n func (p *Package) AllFiles() []string {\n-\treturn str.StringList(\n+\tfiles := str.StringList(\n \t\tp.GoFiles,\n \t\tp.CgoFiles,\n \t\t// no p.CompiledGoFiles, because they are from GoFiles or generated by us\n \t\tp.IgnoredGoFiles,\n+\t\tp.IgnoredOtherFiles,\n \t\tp.CFiles,\n \t\tp.CXXFiles,\n \t\tp.MFiles,\n@@ -151,6 +153,27 @@ func (p *Package) AllFiles() []string {\n \t\tp.TestGoFiles,\n \t\tp.XTestGoFiles,\n \t)\n+\n+\t// EmbedFiles may overlap with the other files.\n+\t// Dedup, but delay building the map as long as possible.\n+\t// Only files in the current directory (no slash in name)\n+\t// need to be checked against the files variable above.\n+\tvar have map[string]bool\n+\tfor _, file := range p.EmbedFiles {\n+\t\tif !strings.Contains(file, \"/\") {\n+\t\t\tif have == nil {\n+\t\t\t\thave = make(map[string]bool)\n+\t\t\t\tfor _, file := range files {\n+\t\t\t\t\thave[file] = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif have[file] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tfiles = append(files, file)\n+\t}\n+\treturn files\n }\n \n // Desc returns the package \"description\", for use in b.showOutput.\n@@ -180,6 +203,7 @@ type PackageInternal struct {\n \tGobinSubdir       bool                 // install target would be subdir of GOBIN\n \tBuildInfo         string               // add this info to package main\n \tTestmainGo        *[]byte              // content for _testmain.go\n+\tEmbed             map[string][]string  // //go:embed comment mapping\n \n \tAsmflags   []string // -asmflags for this package\n \tGcflags    []string // -gcflags for this package\n@@ -197,7 +221,7 @@ type NoGoError struct {\n }\n \n func (e *NoGoError) Error() string {\n-\tif len(e.Package.constraintIgnoredGoFiles()) > 0 {\n+\tif len(e.Package.IgnoredGoFiles) > 0 {\n \t\t// Go files exist, but they were ignored due to build constraints.\n \t\treturn \"build constraints exclude all Go files in \" + e.Package.Dir\n \t}\n@@ -260,8 +284,8 @@ func (p *Package) setLoadPackageDataError(err error, path string, stk *ImportSta\n \t// package's source files themselves (scanner errors).\n \t//\n \t// TODO(matloob): Perhaps make each of those the errors in the first group\n-\t// (including modload.ImportMissingError, and the corresponding\n-\t// \"cannot find package %q in any of\" GOPATH-mode error\n+\t// (including modload.ImportMissingError, ImportMissingSumError, and the\n+\t// corresponding \"cannot find package %q in any of\" GOPATH-mode error\n \t// produced in build.(*Context).Import; modload.AmbiguousImportError,\n \t// and modload.PackageNotInModuleError; and the malformed module path errors\n \t// produced in golang.org/x/mod/module.CheckMod) implement an interface\n@@ -342,6 +366,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.GoFiles = pp.GoFiles\n \tp.CgoFiles = pp.CgoFiles\n \tp.IgnoredGoFiles = pp.IgnoredGoFiles\n+\tp.IgnoredOtherFiles = pp.IgnoredOtherFiles\n \tp.CFiles = pp.CFiles\n \tp.CXXFiles = pp.CXXFiles\n \tp.MFiles = pp.MFiles\n@@ -371,6 +396,9 @@ func (p *Package) copyBuild(pp *build.Package) {\n \t\tp.TestImports = nil\n \t\tp.XTestImports = nil\n \t}\n+\tp.EmbedPatterns = pp.EmbedPatterns\n+\tp.TestEmbedPatterns = pp.TestEmbedPatterns\n+\tp.XTestEmbedPatterns = pp.XTestEmbedPatterns\n }\n \n // A PackageError describes an error loading information about a package.\n@@ -432,13 +460,17 @@ type ImportPathError interface {\n \tImportPath() string\n }\n \n+var (\n+\t_ ImportPathError = (*importError)(nil)\n+\t_ ImportPathError = (*modload.ImportMissingError)(nil)\n+\t_ ImportPathError = (*modload.ImportMissingSumError)(nil)\n+)\n+\n type importError struct {\n \timportPath string\n \terr        error // created with fmt.Errorf\n }\n \n-var _ ImportPathError = (*importError)(nil)\n-\n func ImportErrorf(path, format string, args ...interface{}) ImportPathError {\n \terr := &importError{importPath: path, err: fmt.Errorf(format, args...)}\n \tif errStr := err.Error(); !strings.Contains(errStr, path) {\n@@ -551,7 +583,7 @@ func ReloadPackageNoFlags(arg string, stk *ImportStack) *Package {\n \t\t})\n \t\tpackageDataCache.Delete(p.ImportPath)\n \t}\n-\treturn LoadImport(arg, base.Cwd, nil, stk, nil, 0)\n+\treturn LoadImport(context.TODO(), arg, base.Cwd, nil, stk, nil, 0)\n }\n \n // dirToImportPath returns the pseudo-import path we use for a package\n@@ -603,11 +635,11 @@ const (\n // LoadImport does not set tool flags and should only be used by\n // this package, as part of a bigger load operation, and by GOPATH-based \"go get\".\n // TODO(rsc): When GOPATH-based \"go get\" is removed, unexport this function.\n-func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n-\treturn loadImport(nil, path, srcDir, parent, stk, importPos, mode)\n+func LoadImport(ctx context.Context, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n+\treturn loadImport(ctx, nil, path, srcDir, parent, stk, importPos, mode)\n }\n \n-func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n+func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n \tif path == \"\" {\n \t\tpanic(\"LoadImport called with empty package path\")\n \t}\n@@ -655,7 +687,7 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\t// Load package.\n \t\t// loadPackageData may return bp != nil even if an error occurs,\n \t\t// in order to return partial information.\n-\t\tp.load(path, stk, importPos, bp, err)\n+\t\tp.load(ctx, path, stk, importPos, bp, err)\n \n \t\tif !cfg.ModulesEnabled && path != cleanImport(path) {\n \t\t\tp.Error = &PackageError{\n@@ -751,7 +783,7 @@ func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd\n \t// For vendored imports, it is the expanded form.\n \t//\n \t// Note that when modules are enabled, local import paths are normally\n-\t// canonicalized by modload.ImportPaths before now. However, if there's an\n+\t// canonicalized by modload.LoadPackages before now. However, if there's an\n \t// error resolving a local path, it will be returned untransformed\n \t// so that 'go list -e' reports something useful.\n \timportKey := importSpec{\n@@ -768,7 +800,7 @@ func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd\n \t\t\tr.dir = filepath.Join(parentDir, path)\n \t\t\tr.path = dirToImportPath(r.dir)\n \t\t} else if cfg.ModulesEnabled {\n-\t\t\tr.dir, r.path, r.err = ModLookup(parentPath, parentIsStd, path)\n+\t\t\tr.dir, r.path, r.err = modload.Lookup(parentPath, parentIsStd, path)\n \t\t} else if mode&ResolveImport != 0 {\n \t\t\t// We do our own path resolution, because we want to\n \t\t\t// find out the key to use in packageCache without the\n@@ -799,7 +831,7 @@ func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd\n \t\t\t}\n \t\t\tdata.p, data.err = cfg.BuildContext.ImportDir(r.dir, buildMode)\n \t\t\tif data.p.Root == \"\" && cfg.ModulesEnabled {\n-\t\t\t\tif info := ModPackageModuleInfo(path); info != nil {\n+\t\t\t\tif info := modload.PackageModuleInfo(path); info != nil {\n \t\t\t\t\tdata.p.Root = info.Dir\n \t\t\t\t}\n \t\t\t}\n@@ -825,7 +857,7 @@ func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd\n \t\t\tif cfg.GOBIN != \"\" {\n \t\t\t\tdata.p.BinDir = cfg.GOBIN\n \t\t\t} else if cfg.ModulesEnabled {\n-\t\t\t\tdata.p.BinDir = ModBinDir()\n+\t\t\t\tdata.p.BinDir = modload.BinDir()\n \t\t\t}\n \t\t}\n \n@@ -893,8 +925,8 @@ var preloadWorkerCount = runtime.GOMAXPROCS(0)\n // to ensure preload goroutines are no longer active. This is necessary\n // because of global mutable state that cannot safely be read and written\n // concurrently. In particular, packageDataCache may be cleared by \"go get\"\n-// in GOPATH mode, and modload.loaded (accessed via ModLookup) may be\n-// modified by modload.ImportPaths (ModImportPaths).\n+// in GOPATH mode, and modload.loaded (accessed via modload.Lookup) may be\n+// modified by modload.LoadPackages.\n type preload struct {\n \tcancel chan struct{}\n \tsema   chan struct{}\n@@ -961,6 +993,12 @@ func (pre *preload) preloadImports(imports []string, parent *build.Package) {\n // loadPackageData have completed. The preloader will not make any new calls\n // to loadPackageData.\n func (pre *preload) flush() {\n+\t// flush is usually deferred.\n+\t// Don't hang program waiting for workers on panic.\n+\tif v := recover(); v != nil {\n+\t\tpanic(v)\n+\t}\n+\n \tclose(pre.cancel)\n \tfor i := 0; i < preloadWorkerCount; i++ {\n \t\tpre.sema <- struct{}{}\n@@ -980,7 +1018,7 @@ var isDirCache par.Cache\n \n func isDir(path string) bool {\n \treturn isDirCache.Do(path, func() interface{} {\n-\t\tfi, err := os.Stat(path)\n+\t\tfi, err := fsys.Stat(path)\n \t\treturn err == nil && fi.IsDir()\n \t}).(bool)\n }\n@@ -1004,7 +1042,7 @@ func ResolveImportPath(parent *Package, path string) (found string) {\n \n func resolveImportPath(path, parentPath, parentDir, parentRoot string, parentIsStd bool) (found string) {\n \tif cfg.ModulesEnabled {\n-\t\tif _, p, e := ModLookup(parentPath, parentIsStd, path); e == nil {\n+\t\tif _, p, e := modload.Lookup(parentPath, parentIsStd, path); e == nil {\n \t\t\treturn p\n \t\t}\n \t\treturn path\n@@ -1108,7 +1146,7 @@ var (\n // goModPath returns the module path in the go.mod in dir, if any.\n func goModPath(dir string) (path string) {\n \treturn goModPathCache.Do(dir, func() interface{} {\n-\t\tdata, err := ioutil.ReadFile(filepath.Join(dir, \"go.mod\"))\n+\t\tdata, err := os.ReadFile(filepath.Join(dir, \"go.mod\"))\n \t\tif err != nil {\n \t\t\treturn \"\"\n \t\t}\n@@ -1257,9 +1295,9 @@ HaveGoMod:\n // Otherwise it is not possible to vendor just a/b/c and still import the\n // non-vendored a/b. See golang.org/issue/13832.\n func hasGoFiles(dir string) bool {\n-\tfis, _ := ioutil.ReadDir(dir)\n-\tfor _, fi := range fis {\n-\t\tif !fi.IsDir() && strings.HasSuffix(fi.Name(), \".go\") {\n+\tfiles, _ := os.ReadDir(dir)\n+\tfor _, f := range files {\n+\t\tif !f.IsDir() && strings.HasSuffix(f.Name(), \".go\") {\n \t\t\treturn true\n \t\t}\n \t}\n@@ -1373,7 +1411,7 @@ func disallowInternal(srcDir string, importer *Package, importerPath string, p *\n \t\t\t// directory containing them.\n \t\t\t// If the directory is outside the main module, this will resolve to \".\",\n \t\t\t// which is not a prefix of any valid module.\n-\t\t\timporterPath = ModDirImportPath(importer.Dir)\n+\t\t\timporterPath = modload.DirImportPath(importer.Dir)\n \t\t}\n \t\tparentOfInternal := p.ImportPath[:i]\n \t\tif str.HasPathPrefix(importerPath, parentOfInternal) {\n@@ -1595,7 +1633,7 @@ func (p *Package) DefaultExecName() string {\n // load populates p using information from bp, err, which should\n // be the result of calling build.Context.Import.\n // stk contains the import stack, not including path itself.\n-func (p *Package) load(path string, stk *ImportStack, importPos []token.Position, bp *build.Package, err error) {\n+func (p *Package) load(ctx context.Context, path string, stk *ImportStack, importPos []token.Position, bp *build.Package, err error) {\n \tp.copyBuild(bp)\n \n \t// The localPrefix is the path we interpret ./ imports relative to.\n@@ -1631,6 +1669,11 @@ func (p *Package) load(path string, stk *ImportStack, importPos []token.Position\n \t\tp.setLoadPackageDataError(err, path, stk, importPos)\n \t}\n \n+\tp.EmbedFiles, p.Internal.Embed, err = p.resolveEmbed(p.EmbedPatterns)\n+\tif err != nil {\n+\t\tsetError(err)\n+\t}\n+\n \tuseBindir := p.Name == \"main\"\n \tif !p.Standard {\n \t\tswitch cfg.BuildBuildmode {\n@@ -1656,7 +1699,7 @@ func (p *Package) load(path string, stk *ImportStack, importPos []token.Position\n \t\t\telem = full\n \t\t}\n \t\tif p.Internal.Build.BinDir == \"\" && cfg.ModulesEnabled {\n-\t\t\tp.Internal.Build.BinDir = ModBinDir()\n+\t\t\tp.Internal.Build.BinDir = modload.BinDir()\n \t\t}\n \t\tif p.Internal.Build.BinDir != \"\" {\n \t\t\t// Install to GOBIN or bin of GOPATH entry.\n@@ -1690,7 +1733,7 @@ func (p *Package) load(path string, stk *ImportStack, importPos []token.Position\n \t\t\t// not work for any package that lacks a Target \u2014 such as a non-main\n \t\t\t// package in module mode. We should probably fix that.\n \t\t\tshlibnamefile := p.Target[:len(p.Target)-2] + \".shlibname\"\n-\t\t\tshlib, err := ioutil.ReadFile(shlibnamefile)\n+\t\t\tshlib, err := os.ReadFile(shlibnamefile)\n \t\t\tif err != nil && !os.IsNotExist(err) {\n \t\t\t\tbase.Fatalf(\"reading shlibname: %v\", err)\n \t\t\t}\n@@ -1804,7 +1847,7 @@ func (p *Package) load(path string, stk *ImportStack, importPos []token.Position\n \t\tif path == \"C\" {\n \t\t\tcontinue\n \t\t}\n-\t\tp1 := LoadImport(path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], ResolveImport)\n+\t\tp1 := LoadImport(ctx, path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], ResolveImport)\n \n \t\tpath = p1.ImportPath\n \t\timportPaths[i] = path\n@@ -1865,13 +1908,169 @@ func (p *Package) load(path string, stk *ImportStack, importPos []token.Position\n \t\tif p.Internal.CmdlineFiles {\n \t\t\tmainPath = \"command-line-arguments\"\n \t\t}\n-\t\tp.Module = ModPackageModuleInfo(mainPath)\n+\t\tp.Module = modload.PackageModuleInfo(mainPath)\n \t\tif p.Name == \"main\" && len(p.DepsErrors) == 0 {\n-\t\t\tp.Internal.BuildInfo = ModPackageBuildInfo(mainPath, p.Deps)\n+\t\t\tp.Internal.BuildInfo = modload.PackageBuildInfo(mainPath, p.Deps)\n \t\t}\n \t}\n }\n \n+// ResolveEmbed resolves //go:embed patterns and returns only the file list.\n+// For use by go list to compute p.TestEmbedFiles and p.XTestEmbedFiles.\n+func (p *Package) ResolveEmbed(patterns []string) []string {\n+\tfiles, _, _ := p.resolveEmbed(patterns)\n+\treturn files\n+}\n+\n+// resolveEmbed resolves //go:embed patterns to precise file lists.\n+// It sets files to the list of unique files matched (for go list),\n+// and it sets pmap to the more precise mapping from\n+// patterns to files.\n+// TODO(rsc): All these messages need position information for better error reports.\n+func (p *Package) resolveEmbed(patterns []string) (files []string, pmap map[string][]string, err error) {\n+\tpmap = make(map[string][]string)\n+\thave := make(map[string]int)\n+\tdirOK := make(map[string]bool)\n+\tpid := 0 // pattern ID, to allow reuse of have map\n+\tfor _, pattern := range patterns {\n+\t\tpid++\n+\n+\t\t// Check pattern is valid for //go:embed.\n+\t\tif _, err := path.Match(pattern, \"\"); err != nil || !validEmbedPattern(pattern) {\n+\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: invalid pattern syntax\", pattern)\n+\t\t}\n+\n+\t\t// Glob to find matches.\n+\t\tmatch, err := fsys.Glob(p.Dir + string(filepath.Separator) + filepath.FromSlash(pattern))\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: %v\", pattern, err)\n+\t\t}\n+\n+\t\t// Filter list of matches down to the ones that will still exist when\n+\t\t// the directory is packaged up as a module. (If p.Dir is in the module cache,\n+\t\t// only those files exist already, but if p.Dir is in the current module,\n+\t\t// then there may be other things lying around, like symbolic links or .git directories.)\n+\t\tvar list []string\n+\t\tfor _, file := range match {\n+\t\t\trel := filepath.ToSlash(file[len(p.Dir)+1:]) // file, relative to p.Dir\n+\n+\t\t\twhat := \"file\"\n+\t\t\tinfo, err := fsys.Lstat(file)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n+\t\t\tif info.IsDir() {\n+\t\t\t\twhat = \"directory\"\n+\t\t\t}\n+\n+\t\t\t// Check that directories along path do not begin a new module\n+\t\t\t// (do not contain a go.mod).\n+\t\t\tfor dir := file; len(dir) > len(p.Dir)+1 && !dirOK[dir]; dir = filepath.Dir(dir) {\n+\t\t\t\tif _, err := fsys.Stat(filepath.Join(dir, \"go.mod\")); err == nil {\n+\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed %s %s: in different module\", pattern, what, rel)\n+\t\t\t\t}\n+\t\t\t\tif dir != file {\n+\t\t\t\t\tif info, err := fsys.Lstat(dir); err == nil && !info.IsDir() {\n+\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed %s %s: in non-directory %s\", pattern, what, rel, dir[len(p.Dir)+1:])\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tdirOK[dir] = true\n+\t\t\t\tif elem := filepath.Base(dir); isBadEmbedName(elem) {\n+\t\t\t\t\tif dir == file {\n+\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed %s %s: invalid name %s\", pattern, what, rel, elem)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed %s %s: in invalid directory %s\", pattern, what, rel, elem)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tswitch {\n+\t\t\tdefault:\n+\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed irregular file %s\", pattern, rel)\n+\n+\t\t\tcase info.Mode().IsRegular():\n+\t\t\t\tif have[rel] != pid {\n+\t\t\t\t\thave[rel] = pid\n+\t\t\t\t\tlist = append(list, rel)\n+\t\t\t\t}\n+\n+\t\t\tcase info.IsDir():\n+\t\t\t\t// Gather all files in the named directory, stopping at module boundaries\n+\t\t\t\t// and ignoring files that wouldn't be packaged into a module.\n+\t\t\t\tcount := 0\n+\t\t\t\terr := fsys.Walk(file, func(path string, info os.FileInfo, err error) error {\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn err\n+\t\t\t\t\t}\n+\t\t\t\t\trel := filepath.ToSlash(path[len(p.Dir)+1:])\n+\t\t\t\t\tname := info.Name()\n+\t\t\t\t\tif path != file && (isBadEmbedName(name) || name[0] == '.' || name[0] == '_') {\n+\t\t\t\t\t\t// Ignore bad names, assuming they won't go into modules.\n+\t\t\t\t\t\t// Also avoid hidden files that user may not know about.\n+\t\t\t\t\t\t// See golang.org/issue/42328.\n+\t\t\t\t\t\tif info.IsDir() {\n+\t\t\t\t\t\t\treturn fs.SkipDir\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn nil\n+\t\t\t\t\t}\n+\t\t\t\t\tif info.IsDir() {\n+\t\t\t\t\t\tif _, err := fsys.Stat(filepath.Join(path, \"go.mod\")); err == nil {\n+\t\t\t\t\t\t\treturn filepath.SkipDir\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn nil\n+\t\t\t\t\t}\n+\t\t\t\t\tif !info.Mode().IsRegular() {\n+\t\t\t\t\t\treturn nil\n+\t\t\t\t\t}\n+\t\t\t\t\tcount++\n+\t\t\t\t\tif have[rel] != pid {\n+\t\t\t\t\t\thave[rel] = pid\n+\t\t\t\t\t\tlist = append(list, rel)\n+\t\t\t\t\t}\n+\t\t\t\t\treturn nil\n+\t\t\t\t})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, nil, err\n+\t\t\t\t}\n+\t\t\t\tif count == 0 {\n+\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed directory %s: contains no embeddable files\", pattern, rel)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif len(list) == 0 {\n+\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: no matching files found\", pattern)\n+\t\t}\n+\t\tsort.Strings(list)\n+\t\tpmap[pattern] = list\n+\t}\n+\n+\tfor file := range have {\n+\t\tfiles = append(files, file)\n+\t}\n+\tsort.Strings(files)\n+\treturn files, pmap, nil\n+}\n+\n+func validEmbedPattern(pattern string) bool {\n+\treturn pattern != \".\" && fs.ValidPath(pattern)\n+}\n+\n+// isBadEmbedName reports whether name is the base name of a file that\n+// can't or won't be included in modules and therefore shouldn't be treated\n+// as existing for embedding.\n+func isBadEmbedName(name string) bool {\n+\tswitch name {\n+\t// Empty string should be impossible but make it bad.\n+\tcase \"\":\n+\t\treturn true\n+\t// Version control directories won't be present in module.\n+\tcase \".bzr\", \".hg\", \".git\", \".svn\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // collectDeps populates p.Deps and p.DepsErrors by iterating over\n // p.Internal.Imports.\n //\n@@ -1959,37 +2158,40 @@ func LinkerDeps(p *Package) []string {\n // externalLinkingForced reports whether external linking is being\n // forced even for programs that do not use cgo.\n func externalLinkingForced(p *Package) bool {\n+\tif !cfg.BuildContext.CgoEnabled {\n+\t\treturn false\n+\t}\n+\n \t// Some targets must use external linking even inside GOROOT.\n \tswitch cfg.BuildContext.GOOS {\n \tcase \"android\":\n \t\tif cfg.BuildContext.GOARCH != \"arm64\" {\n \t\t\treturn true\n \t\t}\n-\tcase \"darwin\":\n-\t\tif cfg.BuildContext.GOARCH == \"arm64\" {\n-\t\t\treturn true\n-\t\t}\n+\tcase \"ios\":\n+\t\treturn true\n \t}\n \n-\tif !cfg.BuildContext.CgoEnabled {\n-\t\treturn false\n-\t}\n \t// Currently build modes c-shared, pie (on systems that do not\n \t// support PIE with internal linking mode (currently all\n \t// systems: issue #18968)), plugin, and -linkshared force\n \t// external linking mode, as of course does\n \t// -ldflags=-linkmode=external. External linking mode forces\n \t// an import of runtime/cgo.\n-\tpieCgo := cfg.BuildBuildmode == \"pie\"\n+\t// If there are multiple -linkmode options, the last one wins.\n+\tpieCgo := cfg.BuildBuildmode == \"pie\" && !sys.InternalLinkPIESupported(cfg.BuildContext.GOOS, cfg.BuildContext.GOARCH)\n \tlinkmodeExternal := false\n \tif p != nil {\n \t\tldflags := BuildLdflags.For(p)\n-\t\tfor i, a := range ldflags {\n-\t\t\tif a == \"-linkmode=external\" {\n-\t\t\t\tlinkmodeExternal = true\n-\t\t\t}\n-\t\t\tif a == \"-linkmode\" && i+1 < len(ldflags) && ldflags[i+1] == \"external\" {\n+\t\tfor i := len(ldflags) - 1; i >= 0; i-- {\n+\t\t\ta := ldflags[i]\n+\t\t\tif a == \"-linkmode=external\" ||\n+\t\t\t\ta == \"-linkmode\" && i+1 < len(ldflags) && ldflags[i+1] == \"external\" {\n \t\t\t\tlinkmodeExternal = true\n+\t\t\t\tbreak\n+\t\t\t} else if a == \"-linkmode=internal\" ||\n+\t\t\t\ta == \"-linkmode\" && i+1 < len(ldflags) && ldflags[i+1] == \"internal\" {\n+\t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n@@ -2024,22 +2226,7 @@ func (p *Package) InternalXGoFiles() []string {\n // using absolute paths. \"Possibly relevant\" means that files are not excluded\n // due to build tags, but files with names beginning with . or _ are still excluded.\n func (p *Package) InternalAllGoFiles() []string {\n-\treturn p.mkAbs(str.StringList(p.constraintIgnoredGoFiles(), p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles))\n-}\n-\n-// constraintIgnoredGoFiles returns the list of Go files ignored for reasons\n-// other than having a name beginning with '.' or '_'.\n-func (p *Package) constraintIgnoredGoFiles() []string {\n-\tif len(p.IgnoredGoFiles) == 0 {\n-\t\treturn nil\n-\t}\n-\tfiles := make([]string, 0, len(p.IgnoredGoFiles))\n-\tfor _, f := range p.IgnoredGoFiles {\n-\t\tif f != \"\" && f[0] != '.' && f[0] != '_' {\n-\t\t\tfiles = append(files, f)\n-\t\t}\n-\t}\n-\treturn files\n+\treturn p.mkAbs(str.StringList(p.IgnoredGoFiles, p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles))\n }\n \n // usesSwig reports whether the package needs to run SWIG.\n@@ -2077,7 +2264,7 @@ func PackageList(roots []*Package) []*Package {\n // TestPackageList returns the list of packages in the dag rooted at roots\n // as visited in a depth-first post-order traversal, including the test\n // imports of the roots. This ignores errors in test packages.\n-func TestPackageList(roots []*Package) []*Package {\n+func TestPackageList(ctx context.Context, roots []*Package) []*Package {\n \tseen := map[*Package]bool{}\n \tall := []*Package{}\n \tvar walk func(*Package)\n@@ -2093,7 +2280,7 @@ func TestPackageList(roots []*Package) []*Package {\n \t}\n \twalkTest := func(root *Package, path string) {\n \t\tvar stk ImportStack\n-\t\tp1 := LoadImport(path, root.Dir, root, &stk, root.Internal.Build.TestImportPos[path], ResolveImport)\n+\t\tp1 := LoadImport(ctx, path, root.Dir, root, &stk, root.Internal.Build.TestImportPos[path], ResolveImport)\n \t\tif p1.Error == nil {\n \t\t\twalk(p1)\n \t\t}\n@@ -2116,50 +2303,60 @@ func TestPackageList(roots []*Package) []*Package {\n // TODO(jayconrod): delete this function and set flags automatically\n // in LoadImport instead.\n func LoadImportWithFlags(path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n-\tp := LoadImport(path, srcDir, parent, stk, importPos, mode)\n+\tp := LoadImport(context.TODO(), path, srcDir, parent, stk, importPos, mode)\n \tsetToolFlags(p)\n \treturn p\n }\n \n-// Packages returns the packages named by the\n-// command line arguments 'args'. If a named package\n-// cannot be loaded at all (for example, if the directory does not exist),\n-// then packages prints an error and does not include that\n-// package in the results. However, if errors occur trying\n-// to load dependencies of a named package, the named\n-// package is still returned, with p.Incomplete = true\n-// and details in p.DepsErrors.\n-func Packages(args []string) []*Package {\n-\tvar pkgs []*Package\n-\tfor _, pkg := range PackagesAndErrors(args) {\n-\t\tif pkg.Error != nil {\n-\t\t\tbase.Errorf(\"%v\", pkg.Error)\n-\t\t\tcontinue\n-\t\t}\n-\t\tpkgs = append(pkgs, pkg)\n-\t}\n-\treturn pkgs\n-}\n+// ModResolveTests indicates whether calls to the module loader should also\n+// resolve test dependencies of the requested packages.\n+//\n+// If ModResolveTests is true, then the module loader needs to resolve test\n+// dependencies at the same time as packages; otherwise, the test dependencies\n+// of those packages could be missing, and resolving those missing dependencies\n+// could change the selected versions of modules that provide other packages.\n+//\n+// TODO(#40775): Change this from a global variable to an explicit function\n+// argument where needed.\n+var ModResolveTests bool\n+\n+// PackagesAndErrors returns the packages named by the command line arguments\n+// 'patterns'. If a named package cannot be loaded, PackagesAndErrors returns\n+// a *Package with the Error field describing the failure. If errors are found\n+// loading imported packages, the DepsErrors field is set. The Incomplete field\n+// may be set as well.\n+//\n+// To obtain a flat list of packages, use PackageList.\n+// To report errors loading packages, use ReportPackageErrors.\n+func PackagesAndErrors(ctx context.Context, patterns []string) []*Package {\n+\tctx, span := trace.StartSpan(ctx, \"load.PackagesAndErrors\")\n+\tdefer span.Done()\n \n-// PackagesAndErrors is like 'packages' but returns a\n-// *Package for every argument, even the ones that\n-// cannot be loaded at all.\n-// The packages that fail to load will have p.Error != nil.\n-func PackagesAndErrors(patterns []string) []*Package {\n \tfor _, p := range patterns {\n \t\t// Listing is only supported with all patterns referring to either:\n \t\t// - Files that are part of the same directory.\n \t\t// - Explicit package paths or patterns.\n \t\tif strings.HasSuffix(p, \".go\") {\n \t\t\t// We need to test whether the path is an actual Go file and not a\n \t\t\t// package path or pattern ending in '.go' (see golang.org/issue/34653).\n-\t\t\tif fi, err := os.Stat(p); err == nil && !fi.IsDir() {\n-\t\t\t\treturn []*Package{GoFilesPackage(patterns)}\n+\t\t\tif fi, err := fsys.Stat(p); err == nil && !fi.IsDir() {\n+\t\t\t\treturn []*Package{GoFilesPackage(ctx, patterns)}\n \t\t\t}\n \t\t}\n \t}\n \n-\tmatches := ImportPaths(patterns)\n+\tvar matches []*search.Match\n+\tif modload.Init(); cfg.ModulesEnabled {\n+\t\tloadOpts := modload.PackageOpts{\n+\t\t\tResolveMissingImports: true,\n+\t\t\tLoadTests:             ModResolveTests,\n+\t\t\tSilenceErrors:         true,\n+\t\t}\n+\t\tmatches, _ = modload.LoadPackages(ctx, loadOpts, patterns...)\n+\t} else {\n+\t\tmatches = search.ImportPaths(patterns)\n+\t}\n+\n \tvar (\n \t\tpkgs    []*Package\n \t\tstk     ImportStack\n@@ -2175,7 +2372,7 @@ func PackagesAndErrors(patterns []string) []*Package {\n \t\t\tif pkg == \"\" {\n \t\t\t\tpanic(fmt.Sprintf(\"ImportPaths returned empty package for pattern %s\", m.Pattern()))\n \t\t\t}\n-\t\t\tp := loadImport(pre, pkg, base.Cwd, nil, &stk, nil, 0)\n+\t\t\tp := loadImport(ctx, pre, pkg, base.Cwd, nil, &stk, nil, 0)\n \t\t\tp.Match = append(p.Match, m.Pattern())\n \t\t\tp.Internal.CmdlinePkg = true\n \t\t\tif m.IsLiteral() {\n@@ -2220,27 +2417,9 @@ func PackagesAndErrors(patterns []string) []*Package {\n \treturn pkgs\n }\n \n-func setToolFlags(pkgs ...*Package) {\n-\tfor _, p := range PackageList(pkgs) {\n-\t\tp.Internal.Asmflags = BuildAsmflags.For(p)\n-\t\tp.Internal.Gcflags = BuildGcflags.For(p)\n-\t\tp.Internal.Ldflags = BuildLdflags.For(p)\n-\t\tp.Internal.Gccgoflags = BuildGccgoflags.For(p)\n-\t}\n-}\n-\n-func ImportPaths(args []string) []*search.Match {\n-\tif ModInit(); cfg.ModulesEnabled {\n-\t\treturn ModImportPaths(args)\n-\t}\n-\treturn search.ImportPaths(args)\n-}\n-\n-// PackagesForBuild is like Packages but exits\n-// if any of the packages or their dependencies have errors\n-// (cannot be built).\n-func PackagesForBuild(args []string) []*Package {\n-\tpkgs := PackagesAndErrors(args)\n+// CheckPackageErrors prints errors encountered loading pkgs and their\n+// dependencies, then exits with a non-zero status if any errors were found.\n+func CheckPackageErrors(pkgs []*Package) {\n \tprinted := map[*PackageError]bool{}\n \tfor _, pkg := range pkgs {\n \t\tif pkg.Error != nil {\n@@ -2275,15 +2454,22 @@ func PackagesForBuild(args []string) []*Package {\n \t\tseen[pkg.ImportPath] = true\n \t}\n \tbase.ExitIfErrors()\n+}\n \n-\treturn pkgs\n+func setToolFlags(pkgs ...*Package) {\n+\tfor _, p := range PackageList(pkgs) {\n+\t\tp.Internal.Asmflags = BuildAsmflags.For(p)\n+\t\tp.Internal.Gcflags = BuildGcflags.For(p)\n+\t\tp.Internal.Ldflags = BuildLdflags.For(p)\n+\t\tp.Internal.Gccgoflags = BuildGccgoflags.For(p)\n+\t}\n }\n \n // GoFilesPackage creates a package for building a collection of Go files\n // (typically named on the command line). The target is named p.a for\n // package p or named after the first Go file for package main.\n-func GoFilesPackage(gofiles []string) *Package {\n-\tModInit()\n+func GoFilesPackage(ctx context.Context, gofiles []string) *Package {\n+\tmodload.Init()\n \n \tfor _, f := range gofiles {\n \t\tif !strings.HasSuffix(f, \".go\") {\n@@ -2306,10 +2492,10 @@ func GoFilesPackage(gofiles []string) *Package {\n \t// to make it look like this is a standard package or\n \t// command directory. So that local imports resolve\n \t// consistently, the files must all be in the same directory.\n-\tvar dirent []os.FileInfo\n+\tvar dirent []fs.FileInfo\n \tvar dir string\n \tfor _, file := range gofiles {\n-\t\tfi, err := os.Stat(file)\n+\t\tfi, err := fsys.Stat(file)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"%s\", err)\n \t\t}\n@@ -2327,10 +2513,10 @@ func GoFilesPackage(gofiles []string) *Package {\n \t\t}\n \t\tdirent = append(dirent, fi)\n \t}\n-\tctxt.ReadDir = func(string) ([]os.FileInfo, error) { return dirent, nil }\n+\tctxt.ReadDir = func(string) ([]fs.FileInfo, error) { return dirent, nil }\n \n \tif cfg.ModulesEnabled {\n-\t\tModImportFromFiles(gofiles)\n+\t\tmodload.ImportFromFiles(ctx, gofiles)\n \t}\n \n \tvar err error\n@@ -2346,7 +2532,7 @@ func GoFilesPackage(gofiles []string) *Package {\n \tpkg := new(Package)\n \tpkg.Internal.Local = true\n \tpkg.Internal.CmdlineFiles = true\n-\tpkg.load(\"command-line-arguments\", &stk, nil, bp, err)\n+\tpkg.load(ctx, \"command-line-arguments\", &stk, nil, bp, err)\n \tpkg.Internal.LocalPrefix = dirToImportPath(dir)\n \tpkg.ImportPath = \"command-line-arguments\"\n \tpkg.Target = \"\"\n@@ -2358,7 +2544,7 @@ func GoFilesPackage(gofiles []string) *Package {\n \t\tif cfg.GOBIN != \"\" {\n \t\t\tpkg.Target = filepath.Join(cfg.GOBIN, exe)\n \t\t} else if cfg.ModulesEnabled {\n-\t\t\tpkg.Target = filepath.Join(ModBinDir(), exe)\n+\t\t\tpkg.Target = filepath.Join(modload.BinDir(), exe)\n \t\t}\n \t}\n "}, {"sha": "d884361aaad0690872ea4d74fe7f3c451fabd19a", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,7 +6,7 @@ package load\n \n import (\n \t\"bytes\"\n-\t\"cmd/go/internal/str\"\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/ast\"\n@@ -20,6 +20,9 @@ import (\n \t\"strings\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n+\n+\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/trace\"\n )\n \n var TestMainDeps = []string{\n@@ -42,8 +45,8 @@ type TestCover struct {\n // TestPackagesFor is like TestPackagesAndErrors but it returns\n // an error if the test packages or their dependencies have errors.\n // Only test packages without errors are returned.\n-func TestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Package, err error) {\n-\tpmain, ptest, pxtest = TestPackagesAndErrors(p, cover)\n+func TestPackagesFor(ctx context.Context, p *Package, cover *TestCover) (pmain, ptest, pxtest *Package, err error) {\n+\tpmain, ptest, pxtest = TestPackagesAndErrors(ctx, p, cover)\n \tfor _, p1 := range []*Package{ptest, pxtest, pmain} {\n \t\tif p1 == nil {\n \t\t\t// pxtest may be nil\n@@ -89,7 +92,10 @@ func TestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Packag\n //\n // The caller is expected to have checked that len(p.TestGoFiles)+len(p.XTestGoFiles) > 0,\n // or else there's no point in any of this.\n-func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *Package) {\n+func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (pmain, ptest, pxtest *Package) {\n+\tctx, span := trace.StartSpan(ctx, \"load.TestPackagesAndErrors\")\n+\tdefer span.Done()\n+\n \tpre := newPreload()\n \tdefer pre.flush()\n \tallImports := append([]string{}, p.TestImports...)\n@@ -99,10 +105,11 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \tvar ptestErr, pxtestErr *PackageError\n \tvar imports, ximports []*Package\n \tvar stk ImportStack\n+\tvar testEmbed, xtestEmbed map[string][]string\n \tstk.Push(p.ImportPath + \" (test)\")\n \trawTestImports := str.StringList(p.TestImports)\n \tfor i, path := range p.TestImports {\n-\t\tp1 := loadImport(pre, path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n+\t\tp1 := loadImport(ctx, pre, path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n \t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n \t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n \t\t\t// Can't change that code, because that code is only for loading the\n@@ -116,19 +123,35 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\tp.TestImports[i] = p1.ImportPath\n \t\timports = append(imports, p1)\n \t}\n+\tvar err error\n+\tp.TestEmbedFiles, testEmbed, err = p.resolveEmbed(p.TestEmbedPatterns)\n+\tif err != nil && ptestErr == nil {\n+\t\tptestErr = &PackageError{\n+\t\t\tImportStack: stk.Copy(),\n+\t\t\tErr:         err,\n+\t\t}\n+\t}\n \tstk.Pop()\n+\n \tstk.Push(p.ImportPath + \"_test\")\n \tpxtestNeedsPtest := false\n \trawXTestImports := str.StringList(p.XTestImports)\n \tfor i, path := range p.XTestImports {\n-\t\tp1 := loadImport(pre, path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n+\t\tp1 := loadImport(ctx, pre, path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n \t\tif p1.ImportPath == p.ImportPath {\n \t\t\tpxtestNeedsPtest = true\n \t\t} else {\n \t\t\tximports = append(ximports, p1)\n \t\t}\n \t\tp.XTestImports[i] = p1.ImportPath\n \t}\n+\tp.XTestEmbedFiles, xtestEmbed, err = p.resolveEmbed(p.XTestEmbedPatterns)\n+\tif err != nil && pxtestErr == nil {\n+\t\tpxtestErr = &PackageError{\n+\t\t\tImportStack: stk.Copy(),\n+\t\t\tErr:         err,\n+\t\t}\n+\t}\n \tstk.Pop()\n \n \t// Test package.\n@@ -168,6 +191,14 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t\tm[k] = append(m[k], v...)\n \t\t}\n \t\tptest.Internal.Build.ImportPos = m\n+\t\tif testEmbed == nil && len(p.Internal.Embed) > 0 {\n+\t\t\ttestEmbed = map[string][]string{}\n+\t\t}\n+\t\tfor k, v := range p.Internal.Embed {\n+\t\t\ttestEmbed[k] = v\n+\t\t}\n+\t\tptest.Internal.Embed = testEmbed\n+\t\tptest.EmbedFiles = str.StringList(p.EmbedFiles, p.TestEmbedFiles)\n \t\tptest.collectDeps()\n \t} else {\n \t\tptest = p\n@@ -185,7 +216,9 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t\t\tGoFiles:    p.XTestGoFiles,\n \t\t\t\tImports:    p.XTestImports,\n \t\t\t\tForTest:    p.ImportPath,\n+\t\t\t\tModule:     p.Module,\n \t\t\t\tError:      pxtestErr,\n+\t\t\t\tEmbedFiles: p.XTestEmbedFiles,\n \t\t\t},\n \t\t\tInternal: PackageInternal{\n \t\t\t\tLocalPrefix: p.Internal.LocalPrefix,\n@@ -199,6 +232,7 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t\t\tGcflags:    p.Internal.Gcflags,\n \t\t\t\tLdflags:    p.Internal.Ldflags,\n \t\t\t\tGccgoflags: p.Internal.Gccgoflags,\n+\t\t\t\tEmbed:      xtestEmbed,\n \t\t\t},\n \t\t}\n \t\tif pxtestNeedsPtest {\n@@ -216,6 +250,7 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t\tImportPath: p.ImportPath + \".test\",\n \t\t\tRoot:       p.Root,\n \t\t\tImports:    str.StringList(TestMainDeps),\n+\t\t\tModule:     p.Module,\n \t\t},\n \t\tInternal: PackageInternal{\n \t\t\tBuild:      &build.Package{Name: \"main\"},\n@@ -238,7 +273,7 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\tif dep == ptest.ImportPath {\n \t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, ptest)\n \t\t} else {\n-\t\t\tp1 := loadImport(pre, dep, \"\", nil, &stk, nil, 0)\n+\t\t\tp1 := loadImport(ctx, pre, dep, \"\", nil, &stk, nil, 0)\n \t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n \t\t}\n \t}"}, {"sha": "05f27c321a8ac977b9eb1297344eedcfa316b652", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,6 +9,7 @@ package filelock\n \n import (\n \t\"errors\"\n+\t\"io/fs\"\n \t\"os\"\n )\n \n@@ -24,7 +25,7 @@ type File interface {\n \tFd() uintptr\n \n \t// Stat returns the FileInfo structure describing file.\n-\tStat() (os.FileInfo, error)\n+\tStat() (fs.FileInfo, error)\n }\n \n // Lock places an advisory write lock on the file, blocking until it can be\n@@ -87,7 +88,7 @@ var ErrNotSupported = errors.New(\"operation not supported\")\n // underlyingError returns the underlying error for known os error types.\n func underlyingError(err error) error {\n \tswitch err := err.(type) {\n-\tcase *os.PathError:\n+\tcase *fs.PathError:\n \t\treturn err.Err\n \tcase *os.LinkError:\n \t\treturn err.Err"}, {"sha": "ea480f8c2f6fa0c8666394bdbd1a5d3684462d2c", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_fcntl.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build aix solaris\n+// +build aix solaris,!illumos\n \n // This code implements the filelock API using POSIX 'fcntl' locks, which attach\n // to an (inode, process) pair rather than a file descriptor. To avoid unlocking\n@@ -12,17 +12,14 @@\n // Most platforms provide some alternative API, such as an 'flock' system call\n // or an F_OFD_SETLK command for 'fcntl', that allows for better concurrency and\n // does not require per-inode bookkeeping in the application.\n-//\n-// TODO(golang.org/issue/35618): add a syscall.Flock binding for Illumos and\n-// switch it over to use filelock_unix.go.\n \n package filelock\n \n import (\n \t\"errors\"\n \t\"io\"\n+\t\"io/fs\"\n \t\"math/rand\"\n-\t\"os\"\n \t\"sync\"\n \t\"syscall\"\n \t\"time\"\n@@ -66,7 +63,7 @@ func lock(f File, lt lockType) (err error) {\n \tmu.Lock()\n \tif i, dup := inodes[f]; dup && i != ino {\n \t\tmu.Unlock()\n-\t\treturn &os.PathError{\n+\t\treturn &fs.PathError{\n \t\t\tOp:   lt.String(),\n \t\t\tPath: f.Name(),\n \t\t\tErr:  errors.New(\"inode for file changed since last Lock or RLock\"),\n@@ -157,7 +154,7 @@ func lock(f File, lt lockType) (err error) {\n \n \tif err != nil {\n \t\tunlock(f)\n-\t\treturn &os.PathError{\n+\t\treturn &fs.PathError{\n \t\t\tOp:   lt.String(),\n \t\t\tPath: f.Name(),\n \t\t\tErr:  err,"}, {"sha": "c09530d1b70b45ef3257547de157faeb9317cbc1", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_other.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,7 +6,7 @@\n \n package filelock\n \n-import \"os\"\n+import \"io/fs\"\n \n type lockType int8\n \n@@ -16,15 +16,15 @@ const (\n )\n \n func lock(f File, lt lockType) error {\n-\treturn &os.PathError{\n+\treturn &fs.PathError{\n \t\tOp:   lt.String(),\n \t\tPath: f.Name(),\n \t\tErr:  ErrNotSupported,\n \t}\n }\n \n func unlock(f File) error {\n-\treturn &os.PathError{\n+\treturn &fs.PathError{\n \t\tOp:   \"Unlock\",\n \t\tPath: f.Name(),\n \t\tErr:  ErrNotSupported,"}, {"sha": "0798ee469a46f40959bce21eea17ee36c5f6c360", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_plan9.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,9 +6,7 @@\n \n package filelock\n \n-import (\n-\t\"os\"\n-)\n+import \"io/fs\"\n \n type lockType int8\n \n@@ -18,15 +16,15 @@ const (\n )\n \n func lock(f File, lt lockType) error {\n-\treturn &os.PathError{\n+\treturn &fs.PathError{\n \t\tOp:   lt.String(),\n \t\tPath: f.Name(),\n \t\tErr:  ErrNotSupported,\n \t}\n }\n \n func unlock(f File) error {\n-\treturn &os.PathError{\n+\treturn &fs.PathError{\n \t\tOp:   \"Unlock\",\n \t\tPath: f.Name(),\n \t\tErr:  ErrNotSupported,"}, {"sha": "2ac2052b8f57372dd674b5f8eb5fbdb15f198161", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,7 +9,6 @@ package filelock_test\n import (\n \t\"fmt\"\n \t\"internal/testenv\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -51,9 +50,9 @@ func mustTempFile(t *testing.T) (f *os.File, remove func()) {\n \tt.Helper()\n \n \tbase := filepath.Base(t.Name())\n-\tf, err := ioutil.TempFile(\"\", base)\n+\tf, err := os.CreateTemp(\"\", base)\n \tif err != nil {\n-\t\tt.Fatalf(`ioutil.TempFile(\"\", %q) = %v`, base, err)\n+\t\tt.Fatalf(`os.CreateTemp(\"\", %q) = %v`, base, err)\n \t}\n \tt.Logf(\"fd %d = %s\", f.Fd(), f.Name())\n \n@@ -161,7 +160,7 @@ func TestRLockExcludesOnlyLock(t *testing.T) {\n \n \tdoUnlockTF := false\n \tswitch runtime.GOOS {\n-\tcase \"aix\", \"illumos\", \"solaris\":\n+\tcase \"aix\", \"solaris\":\n \t\t// When using POSIX locks (as on Solaris), we can't safely read-lock the\n \t\t// same inode through two different descriptors at the same time: when the\n \t\t// first descriptor is closed, the second descriptor would still be open but"}, {"sha": "c06b0f77427df3adde49dcecba0399ed70a5d019", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_unix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -2,12 +2,12 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin dragonfly freebsd hurd linux netbsd openbsd\n+// +build darwin dragonfly freebsd hurd illumos linux netbsd openbsd\n \n package filelock\n \n import (\n-\t\"os\"\n+\t\"io/fs\"\n \t\"syscall\"\n )\n \n@@ -26,7 +26,7 @@ func lock(f File, lt lockType) (err error) {\n \t\t}\n \t}\n \tif err != nil {\n-\t\treturn &os.PathError{\n+\t\treturn &fs.PathError{\n \t\t\tOp:   lt.String(),\n \t\t\tPath: f.Name(),\n \t\t\tErr:  err,"}, {"sha": "19de27eb9b6021ad9761712218ca1402a9d88f74", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_windows.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,7 +8,7 @@ package filelock\n \n import (\n \t\"internal/syscall/windows\"\n-\t\"os\"\n+\t\"io/fs\"\n \t\"syscall\"\n )\n \n@@ -34,7 +34,7 @@ func lock(f File, lt lockType) error {\n \n \terr := windows.LockFileEx(syscall.Handle(f.Fd()), uint32(lt), reserved, allBytes, allBytes, ol)\n \tif err != nil {\n-\t\treturn &os.PathError{\n+\t\treturn &fs.PathError{\n \t\t\tOp:   lt.String(),\n \t\t\tPath: f.Name(),\n \t\t\tErr:  err,\n@@ -47,7 +47,7 @@ func unlock(f File) error {\n \tol := new(syscall.Overlapped)\n \terr := windows.UnlockFileEx(syscall.Handle(f.Fd()), reserved, allBytes, allBytes, ol)\n \tif err != nil {\n-\t\treturn &os.PathError{\n+\t\treturn &fs.PathError{\n \t\t\tOp:   \"Unlock\",\n \t\t\tPath: f.Name(),\n \t\t\tErr:  err,"}, {"sha": "82e1a89675e7042aab6429990491e0e6f4ab6219", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,7 +9,7 @@ package lockedfile\n import (\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"runtime\"\n )\n@@ -35,7 +35,7 @@ type osFile struct {\n // OpenFile is like os.OpenFile, but returns a locked file.\n // If flag includes os.O_WRONLY or os.O_RDWR, the file is write-locked;\n // otherwise, it is read-locked.\n-func OpenFile(name string, flag int, perm os.FileMode) (*File, error) {\n+func OpenFile(name string, flag int, perm fs.FileMode) (*File, error) {\n \tvar (\n \t\tf   = new(File)\n \t\terr error\n@@ -82,10 +82,10 @@ func Edit(name string) (*File, error) {\n // non-nil error.\n func (f *File) Close() error {\n \tif f.closed {\n-\t\treturn &os.PathError{\n+\t\treturn &fs.PathError{\n \t\t\tOp:   \"close\",\n \t\t\tPath: f.Name(),\n-\t\t\tErr:  os.ErrClosed,\n+\t\t\tErr:  fs.ErrClosed,\n \t\t}\n \t}\n \tf.closed = true\n@@ -103,12 +103,12 @@ func Read(name string) ([]byte, error) {\n \t}\n \tdefer f.Close()\n \n-\treturn ioutil.ReadAll(f)\n+\treturn io.ReadAll(f)\n }\n \n // Write opens the named file (creating it with the given permissions if needed),\n // then write-locks it and overwrites it with the given content.\n-func Write(name string, content io.Reader, perm os.FileMode) (err error) {\n+func Write(name string, content io.Reader, perm fs.FileMode) (err error) {\n \tf, err := OpenFile(name, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n \tif err != nil {\n \t\treturn err\n@@ -135,7 +135,7 @@ func Transform(name string, t func([]byte) ([]byte, error)) (err error) {\n \t}\n \tdefer f.Close()\n \n-\told, err := ioutil.ReadAll(f)\n+\told, err := io.ReadAll(f)\n \tif err != nil {\n \t\treturn err\n \t}"}, {"sha": "efc66461ed2fd6a2f12ca0b0440cc3f6ddb81f73", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_filelock.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,18 +7,20 @@\n package lockedfile\n \n import (\n+\t\"io/fs\"\n \t\"os\"\n \n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/lockedfile/internal/filelock\"\n )\n \n-func openFile(name string, flag int, perm os.FileMode) (*os.File, error) {\n+func openFile(name string, flag int, perm fs.FileMode) (*os.File, error) {\n \t// On BSD systems, we could add the O_SHLOCK or O_EXLOCK flag to the OpenFile\n \t// call instead of locking separately, but we have to support separate locking\n \t// calls for Linux and Windows anyway, so it's simpler to use that approach\n \t// consistently.\n \n-\tf, err := os.OpenFile(name, flag&^os.O_TRUNC, perm)\n+\tf, err := fsys.OpenFile(name, flag&^os.O_TRUNC, perm)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "70d6eddf2d2da4b349e8de1ef114a986744aef91", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_plan9.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,10 +7,13 @@\n package lockedfile\n \n import (\n+\t\"io/fs\"\n \t\"math/rand\"\n \t\"os\"\n \t\"strings\"\n \t\"time\"\n+\n+\t\"cmd/go/internal/fsys\"\n )\n \n // Opening an exclusive-use file returns an error.\n@@ -41,7 +44,7 @@ func isLocked(err error) bool {\n \treturn false\n }\n \n-func openFile(name string, flag int, perm os.FileMode) (*os.File, error) {\n+func openFile(name string, flag int, perm fs.FileMode) (*os.File, error) {\n \t// Plan 9 uses a mode bit instead of explicit lock/unlock syscalls.\n \t//\n \t// Per http://man.cat-v.org/plan_9/5/stat: \u201cExclusive use files may be open\n@@ -55,9 +58,9 @@ func openFile(name string, flag int, perm os.FileMode) (*os.File, error) {\n \t// If the file was unpacked or created by some other program, it might not\n \t// have the ModeExclusive bit set. Set it before we call OpenFile, so that we\n \t// can be confident that a successful OpenFile implies exclusive use.\n-\tif fi, err := os.Stat(name); err == nil {\n-\t\tif fi.Mode()&os.ModeExclusive == 0 {\n-\t\t\tif err := os.Chmod(name, fi.Mode()|os.ModeExclusive); err != nil {\n+\tif fi, err := fsys.Stat(name); err == nil {\n+\t\tif fi.Mode()&fs.ModeExclusive == 0 {\n+\t\t\tif err := os.Chmod(name, fi.Mode()|fs.ModeExclusive); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t}\n@@ -68,7 +71,7 @@ func openFile(name string, flag int, perm os.FileMode) (*os.File, error) {\n \tnextSleep := 1 * time.Millisecond\n \tconst maxSleep = 500 * time.Millisecond\n \tfor {\n-\t\tf, err := os.OpenFile(name, flag, perm|os.ModeExclusive)\n+\t\tf, err := fsys.OpenFile(name, flag, perm|fs.ModeExclusive)\n \t\tif err == nil {\n \t\t\treturn f, nil\n \t\t}"}, {"sha": "34327dd841e112cbb17f9f2789ccb858fbee433f", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_test.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,7 +10,6 @@ package lockedfile_test\n import (\n \t\"fmt\"\n \t\"internal/testenv\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -23,7 +22,7 @@ import (\n func mustTempDir(t *testing.T) (dir string, remove func()) {\n \tt.Helper()\n \n-\tdir, err := ioutil.TempDir(\"\", filepath.Base(t.Name()))\n+\tdir, err := os.MkdirTemp(\"\", filepath.Base(t.Name()))\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -155,8 +154,8 @@ func TestCanLockExistingFile(t *testing.T) {\n \tdefer remove()\n \tpath := filepath.Join(dir, \"existing.txt\")\n \n-\tif err := ioutil.WriteFile(path, []byte(\"ok\"), 0777); err != nil {\n-\t\tt.Fatalf(\"ioutil.WriteFile: %v\", err)\n+\tif err := os.WriteFile(path, []byte(\"ok\"), 0777); err != nil {\n+\t\tt.Fatalf(\"os.WriteFile: %v\", err)\n \t}\n \n \tf, err := lockedfile.Edit(path)\n@@ -201,7 +200,7 @@ func TestSpuriousEDEADLK(t *testing.T) {\n \t\t}\n \t\tdefer b.Close()\n \n-\t\tif err := ioutil.WriteFile(filepath.Join(dir, \"locked\"), []byte(\"ok\"), 0666); err != nil {\n+\t\tif err := os.WriteFile(filepath.Join(dir, \"locked\"), []byte(\"ok\"), 0666); err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n "}, {"sha": "ef1ad780c81bec3070f7bd8957cc5f8bee8ffb71", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,15 +5,15 @@\n package modcmd\n \n import (\n+\t\"context\"\n \t\"encoding/json\"\n \t\"os\"\n+\t\"runtime\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/work\"\n \n \t\"golang.org/x/mod/module\"\n )\n@@ -63,7 +63,7 @@ func init() {\n \n \t// TODO(jayconrod): https://golang.org/issue/35849 Apply -x to other 'go mod' commands.\n \tcmdDownload.Flag.BoolVar(&cfg.BuildX, \"x\", false, \"\")\n-\twork.AddModCommonFlags(cmdDownload)\n+\tbase.AddModCommonFlags(&cmdDownload.Flag)\n }\n \n type moduleJSON struct {\n@@ -78,56 +78,27 @@ type moduleJSON struct {\n \tGoModSum string `json:\",omitempty\"`\n }\n \n-func runDownload(cmd *base.Command, args []string) {\n+func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \t// Check whether modules are enabled and whether we're in a module.\n-\tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n-\t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n-\t}\n+\tmodload.ForceUseModules = true\n \tif !modload.HasModRoot() && len(args) == 0 {\n \t\tbase.Fatalf(\"go mod download: no modules specified (see 'go help mod download')\")\n \t}\n \tif len(args) == 0 {\n \t\targs = []string{\"all\"}\n \t} else if modload.HasModRoot() {\n-\t\tmodload.InitMod() // to fill Target\n-\t\ttargetAtLatest := modload.Target.Path + \"@latest\"\n+\t\tmodload.LoadModFile(ctx) // to fill Target\n \t\ttargetAtUpgrade := modload.Target.Path + \"@upgrade\"\n \t\ttargetAtPatch := modload.Target.Path + \"@patch\"\n \t\tfor _, arg := range args {\n \t\t\tswitch arg {\n-\t\t\tcase modload.Target.Path, targetAtLatest, targetAtUpgrade, targetAtPatch:\n+\t\t\tcase modload.Target.Path, targetAtUpgrade, targetAtPatch:\n \t\t\t\tos.Stderr.WriteString(\"go mod download: skipping argument \" + arg + \" that resolves to the main module\\n\")\n \t\t\t}\n \t\t}\n \t}\n \n-\tvar mods []*moduleJSON\n-\tvar work par.Work\n-\tlistU := false\n-\tlistVersions := false\n-\tfor _, info := range modload.ListModules(args, listU, listVersions) {\n-\t\tif info.Replace != nil {\n-\t\t\tinfo = info.Replace\n-\t\t}\n-\t\tif info.Version == \"\" && info.Error == nil {\n-\t\t\t// main module or module replaced with file path.\n-\t\t\t// Nothing to download.\n-\t\t\tcontinue\n-\t\t}\n-\t\tm := &moduleJSON{\n-\t\t\tPath:    info.Path,\n-\t\t\tVersion: info.Version,\n-\t\t}\n-\t\tmods = append(mods, m)\n-\t\tif info.Error != nil {\n-\t\t\tm.Error = info.Error.Err\n-\t\t\tcontinue\n-\t\t}\n-\t\twork.Add(m)\n-\t}\n-\n-\twork.Do(10, func(item interface{}) {\n-\t\tm := item.(*moduleJSON)\n+\tdownloadModule := func(m *moduleJSON) {\n \t\tvar err error\n \t\tm.Info, err = modfetch.InfoFile(m.Path, m.Version)\n \t\tif err != nil {\n@@ -145,24 +116,60 @@ func runDownload(cmd *base.Command, args []string) {\n \t\t\treturn\n \t\t}\n \t\tmod := module.Version{Path: m.Path, Version: m.Version}\n-\t\tm.Zip, err = modfetch.DownloadZip(mod)\n+\t\tm.Zip, err = modfetch.DownloadZip(ctx, mod)\n \t\tif err != nil {\n \t\t\tm.Error = err.Error()\n \t\t\treturn\n \t\t}\n \t\tm.Sum = modfetch.Sum(mod)\n-\t\tm.Dir, err = modfetch.Download(mod)\n+\t\tm.Dir, err = modfetch.Download(ctx, mod)\n \t\tif err != nil {\n \t\t\tm.Error = err.Error()\n \t\t\treturn\n \t\t}\n-\t})\n+\t}\n+\n+\tvar mods []*moduleJSON\n+\tlistU := false\n+\tlistVersions := false\n+\tlistRetractions := false\n+\ttype token struct{}\n+\tsem := make(chan token, runtime.GOMAXPROCS(0))\n+\tfor _, info := range modload.ListModules(ctx, args, listU, listVersions, listRetractions) {\n+\t\tif info.Replace != nil {\n+\t\t\tinfo = info.Replace\n+\t\t}\n+\t\tif info.Version == \"\" && info.Error == nil {\n+\t\t\t// main module or module replaced with file path.\n+\t\t\t// Nothing to download.\n+\t\t\tcontinue\n+\t\t}\n+\t\tm := &moduleJSON{\n+\t\t\tPath:    info.Path,\n+\t\t\tVersion: info.Version,\n+\t\t}\n+\t\tmods = append(mods, m)\n+\t\tif info.Error != nil {\n+\t\t\tm.Error = info.Error.Err\n+\t\t\tcontinue\n+\t\t}\n+\t\tsem <- token{}\n+\t\tgo func() {\n+\t\t\tdownloadModule(m)\n+\t\t\t<-sem\n+\t\t}()\n+\t}\n+\n+\t// Fill semaphore channel to wait for goroutines to finish.\n+\tfor n := cap(sem); n > 0; n-- {\n+\t\tsem <- token{}\n+\t}\n \n \tif *downloadJSON {\n \t\tfor _, m := range mods {\n \t\t\tb, err := json.MarshalIndent(m, \"\", \"\\t\")\n \t\t\tif err != nil {\n-\t\t\t\tbase.Fatalf(\"%v\", err)\n+\t\t\t\tbase.Fatalf(\"go mod download: %v\", err)\n \t\t\t}\n \t\t\tos.Stdout.Write(append(b, '\\n'))\n \t\t\tif m.Error != \"\" {\n@@ -172,9 +179,12 @@ func runDownload(cmd *base.Command, args []string) {\n \t} else {\n \t\tfor _, m := range mods {\n \t\t\tif m.Error != \"\" {\n-\t\t\t\tbase.Errorf(\"%s\", m.Error)\n+\t\t\t\tbase.Errorf(\"go mod download: %v\", m.Error)\n \t\t\t}\n \t\t}\n \t\tbase.ExitIfErrors()\n \t}\n+\n+\t// Update go.mod and especially go.sum if needed.\n+\tmodload.WriteGoMod()\n }"}, {"sha": "b203a8a2b0a6f3b19a82bb63e2de8ef807d2c9af", "filename": "libgo/go/cmd/go/internal/modcmd/edit.go", "status": "modified", "additions": 95, "deletions": 12, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,6 +8,7 @@ package modcmd\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n@@ -18,7 +19,6 @@ import (\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/work\"\n \n \t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n@@ -67,9 +67,14 @@ The -dropreplace=old[@v] flag drops a replacement of the given\n module path and version pair. If the @v is omitted, a replacement without\n a version on the left side is dropped.\n \n+The -retract=version and -dropretract=version flags add and drop a\n+retraction on the given version. The version may be a single version\n+like \"v1.2.3\" or a closed interval like \"[v1.1.0,v1.1.9]\". Note that\n+-retract=version is a no-op if that retraction already exists.\n+\n The -require, -droprequire, -exclude, -dropexclude, -replace,\n-and -dropreplace editing flags may be repeated, and the changes\n-are applied in the order given.\n+-dropreplace, -retract, and -dropretract editing flags may be repeated,\n+and the changes are applied in the order given.\n \n The -go=version flag sets the expected Go language version.\n \n@@ -103,6 +108,15 @@ writing it back to go.mod. The JSON output corresponds to these Go types:\n \t\tNew Module\n \t}\n \n+\ttype Retract struct {\n+\t\tLow       string\n+\t\tHigh      string\n+\t\tRationale string\n+\t}\n+\n+Retract entries representing a single version (not an interval) will have\n+the \"Low\" and \"High\" fields set to the same value.\n+\n Note that this only describes the go.mod file itself, not other modules\n referred to indirectly. For the full set of modules available to a build,\n use 'go list -m -json all'.\n@@ -136,12 +150,14 @@ func init() {\n \tcmdEdit.Flag.Var(flagFunc(flagDropReplace), \"dropreplace\", \"\")\n \tcmdEdit.Flag.Var(flagFunc(flagReplace), \"replace\", \"\")\n \tcmdEdit.Flag.Var(flagFunc(flagDropExclude), \"dropexclude\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagRetract), \"retract\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagDropRetract), \"dropretract\", \"\")\n \n-\twork.AddModCommonFlags(cmdEdit)\n+\tbase.AddModCommonFlags(&cmdEdit.Flag)\n \tbase.AddBuildFlagsNX(&cmdEdit.Flag)\n }\n \n-func runEdit(cmd *base.Command, args []string) {\n+func runEdit(ctx context.Context, cmd *base.Command, args []string) {\n \tanyFlags :=\n \t\t*editModule != \"\" ||\n \t\t\t*editGo != \"\" ||\n@@ -251,12 +267,7 @@ func parsePathVersion(flag, arg string) (path, version string) {\n \t\tbase.Fatalf(\"go mod: -%s=%s: invalid path: %v\", flag, arg, err)\n \t}\n \n-\t// We don't call modfile.CheckPathVersion, because that insists\n-\t// on versions being in semver form, but here we want to allow\n-\t// versions like \"master\" or \"1234abcdef\", which the go command will resolve\n-\t// the next time it runs (or during -fix).\n-\t// Even so, we need to make sure the version is a valid token.\n-\tif modfile.MustQuote(version) {\n+\tif !allowedVersionArg(version) {\n \t\tbase.Fatalf(\"go mod: -%s=%s: invalid version %q\", flag, arg, version)\n \t}\n \n@@ -288,12 +299,48 @@ func parsePathVersionOptional(adj, arg string, allowDirPath bool) (path, version\n \t\t\treturn path, version, fmt.Errorf(\"invalid %s path: %v\", adj, err)\n \t\t}\n \t}\n-\tif path != arg && modfile.MustQuote(version) {\n+\tif path != arg && !allowedVersionArg(version) {\n \t\treturn path, version, fmt.Errorf(\"invalid %s version: %q\", adj, version)\n \t}\n \treturn path, version, nil\n }\n \n+// parseVersionInterval parses a single version like \"v1.2.3\" or a closed\n+// interval like \"[v1.2.3,v1.4.5]\". Note that a single version has the same\n+// representation as an interval with equal upper and lower bounds: both\n+// Low and High are set.\n+func parseVersionInterval(arg string) (modfile.VersionInterval, error) {\n+\tif !strings.HasPrefix(arg, \"[\") {\n+\t\tif !allowedVersionArg(arg) {\n+\t\t\treturn modfile.VersionInterval{}, fmt.Errorf(\"invalid version: %q\", arg)\n+\t\t}\n+\t\treturn modfile.VersionInterval{Low: arg, High: arg}, nil\n+\t}\n+\tif !strings.HasSuffix(arg, \"]\") {\n+\t\treturn modfile.VersionInterval{}, fmt.Errorf(\"invalid version interval: %q\", arg)\n+\t}\n+\ts := arg[1 : len(arg)-1]\n+\ti := strings.Index(s, \",\")\n+\tif i < 0 {\n+\t\treturn modfile.VersionInterval{}, fmt.Errorf(\"invalid version interval: %q\", arg)\n+\t}\n+\tlow := strings.TrimSpace(s[:i])\n+\thigh := strings.TrimSpace(s[i+1:])\n+\tif !allowedVersionArg(low) || !allowedVersionArg(high) {\n+\t\treturn modfile.VersionInterval{}, fmt.Errorf(\"invalid version interval: %q\", arg)\n+\t}\n+\treturn modfile.VersionInterval{Low: low, High: high}, nil\n+}\n+\n+// allowedVersionArg returns whether a token may be used as a version in go.mod.\n+// We don't call modfile.CheckPathVersion, because that insists on versions\n+// being in semver form, but here we want to allow versions like \"master\" or\n+// \"1234abcdef\", which the go command will resolve the next time it runs (or\n+// during -fix).  Even so, we need to make sure the version is a valid token.\n+func allowedVersionArg(arg string) bool {\n+\treturn !modfile.MustQuote(arg)\n+}\n+\n // flagRequire implements the -require flag.\n func flagRequire(arg string) {\n \tpath, version := parsePathVersion(\"require\", arg)\n@@ -376,13 +423,40 @@ func flagDropReplace(arg string) {\n \t})\n }\n \n+// flagRetract implements the -retract flag.\n+func flagRetract(arg string) {\n+\tvi, err := parseVersionInterval(arg)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go mod: -retract=%s: %v\", arg, err)\n+\t}\n+\tedits = append(edits, func(f *modfile.File) {\n+\t\tif err := f.AddRetract(vi, \"\"); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: -retract=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// flagDropRetract implements the -dropretract flag.\n+func flagDropRetract(arg string) {\n+\tvi, err := parseVersionInterval(arg)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go mod: -dropretract=%s: %v\", arg, err)\n+\t}\n+\tedits = append(edits, func(f *modfile.File) {\n+\t\tif err := f.DropRetract(vi); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: -dropretract=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n // fileJSON is the -json output data structure.\n type fileJSON struct {\n \tModule  module.Version\n \tGo      string `json:\",omitempty\"`\n \tRequire []requireJSON\n \tExclude []module.Version\n \tReplace []replaceJSON\n+\tRetract []retractJSON\n }\n \n type requireJSON struct {\n@@ -396,6 +470,12 @@ type replaceJSON struct {\n \tNew module.Version\n }\n \n+type retractJSON struct {\n+\tLow       string `json:\",omitempty\"`\n+\tHigh      string `json:\",omitempty\"`\n+\tRationale string `json:\",omitempty\"`\n+}\n+\n // editPrintJSON prints the -json output.\n func editPrintJSON(modFile *modfile.File) {\n \tvar f fileJSON\n@@ -414,6 +494,9 @@ func editPrintJSON(modFile *modfile.File) {\n \tfor _, r := range modFile.Replace {\n \t\tf.Replace = append(f.Replace, replaceJSON{r.Old, r.New})\n \t}\n+\tfor _, r := range modFile.Retract {\n+\t\tf.Retract = append(f.Retract, retractJSON{r.Low, r.High, r.Rationale})\n+\t}\n \tdata, err := json.MarshalIndent(&f, \"\", \"\\t\")\n \tif err != nil {\n \t\tbase.Fatalf(\"go: internal error: %v\", err)"}, {"sha": "3277548c235f9297b96f5b15fb3cf8a4995631f4", "filename": "libgo/go/cmd/go/internal/modcmd/graph.go", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -8,14 +8,12 @@ package modcmd\n \n import (\n \t\"bufio\"\n+\t\"context\"\n \t\"os\"\n \t\"sort\"\n \n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/work\"\n \n \t\"golang.org/x/mod/module\"\n )\n@@ -33,22 +31,16 @@ path@version, except for the main module, which has no @version suffix.\n }\n \n func init() {\n-\twork.AddModCommonFlags(cmdGraph)\n+\tbase.AddModCommonFlags(&cmdGraph.Flag)\n }\n \n-func runGraph(cmd *base.Command, args []string) {\n+func runGraph(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n \t\tbase.Fatalf(\"go mod graph: graph takes no arguments\")\n \t}\n-\t// Checks go mod expected behavior\n-\tif !modload.Enabled() {\n-\t\tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n-\t\t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n-\t\t} else {\n-\t\t\tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n-\t\t}\n-\t}\n-\tmodload.LoadBuildList()\n+\tmodload.ForceUseModules = true\n+\tmodload.RootMode = modload.NeedRoot\n+\tmodload.LoadAllModules(ctx)\n \n \treqs := modload.MinReqs()\n \tformat := func(m module.Version) string {\n@@ -58,23 +50,25 @@ func runGraph(cmd *base.Command, args []string) {\n \t\treturn m.Path + \"@\" + m.Version\n \t}\n \n-\t// Note: using par.Work only to manage work queue.\n-\t// No parallelism here, so no locking.\n \tvar out []string\n \tvar deps int // index in out where deps start\n-\tvar work par.Work\n-\twork.Add(modload.Target)\n-\twork.Do(1, func(item interface{}) {\n-\t\tm := item.(module.Version)\n+\tseen := map[module.Version]bool{modload.Target: true}\n+\tqueue := []module.Version{modload.Target}\n+\tfor len(queue) > 0 {\n+\t\tvar m module.Version\n+\t\tm, queue = queue[0], queue[1:]\n \t\tlist, _ := reqs.Required(m)\n \t\tfor _, r := range list {\n-\t\t\twork.Add(r)\n+\t\t\tif !seen[r] {\n+\t\t\t\tqueue = append(queue, r)\n+\t\t\t\tseen[r] = true\n+\t\t\t}\n \t\t\tout = append(out, format(m)+\" \"+format(r)+\"\\n\")\n \t\t}\n \t\tif m == modload.Target {\n \t\t\tdeps = len(out)\n \t\t}\n-\t})\n+\t}\n \n \tsort.Slice(out[deps:], func(i, j int) bool {\n \t\treturn out[deps+i][0] < out[deps+j][0]"}, {"sha": "c081bb547d14c7571ba7b2511f13a3eaabec84a5", "filename": "libgo/go/cmd/go/internal/modcmd/init.go", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,46 +9,41 @@ package modcmd\n import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/work\"\n-\t\"os\"\n-\t\"strings\"\n+\t\"context\"\n )\n \n var cmdInit = &base.Command{\n \tUsageLine: \"go mod init [module]\",\n \tShort:     \"initialize new module in current directory\",\n \tLong: `\n-Init initializes and writes a new go.mod to the current directory,\n-in effect creating a new module rooted at the current directory.\n-The file go.mod must not already exist.\n-If possible, init will guess the module path from import comments\n-(see 'go help importpath') or from version control configuration.\n-To override this guess, supply the module path as an argument.\n-\t`,\n+Init initializes and writes a new go.mod file in the current directory, in\n+effect creating a new module rooted at the current directory. The go.mod file\n+must not already exist.\n+\n+Init accepts one optional argument, the module path for the new module. If the\n+module path argument is omitted, init will attempt to infer the module path\n+using import comments in .go files, vendoring tool configuration files (like\n+Gopkg.lock), and the current directory (if in GOPATH).\n+\n+If a configuration file for a vendoring tool is present, init will attempt to\n+import module requirements from it.\n+`,\n \tRun: runInit,\n }\n \n func init() {\n-\twork.AddModCommonFlags(cmdInit)\n+\tbase.AddModCommonFlags(&cmdInit.Flag)\n }\n \n-func runInit(cmd *base.Command, args []string) {\n-\tmodload.CmdModInit = true\n+func runInit(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) > 1 {\n \t\tbase.Fatalf(\"go mod init: too many arguments\")\n \t}\n+\tvar modPath string\n \tif len(args) == 1 {\n-\t\tmodload.CmdModModule = args[0]\n-\t}\n-\tif os.Getenv(\"GO111MODULE\") == \"off\" {\n-\t\tbase.Fatalf(\"go mod init: modules disabled by GO111MODULE=off; see 'go help modules'\")\n+\t\tmodPath = args[0]\n \t}\n-\tmodFilePath := modload.ModFilePath()\n-\tif _, err := os.Stat(modFilePath); err == nil {\n-\t\tbase.Fatalf(\"go mod init: go.mod already exists\")\n-\t}\n-\tif strings.Contains(modload.CmdModModule, \"@\") {\n-\t\tbase.Fatalf(\"go mod init: module path must not contain '@'\")\n-\t}\n-\tmodload.InitMod() // does all the hard work\n+\n+\tmodload.ForceUseModules = true\n+\tmodload.CreateModFile(ctx, modPath) // does all the hard work\n }"}, {"sha": "fb43e33ec58e3a768e0388b70ace05553179ccef", "filename": "libgo/go/cmd/go/internal/modcmd/tidy.go", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,15 +9,13 @@ package modcmd\n import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/work\"\n-\n-\t\"golang.org/x/mod/module\"\n+\t\"context\"\n )\n \n var cmdTidy = &base.Command{\n-\tUsageLine: \"go mod tidy [-v]\",\n+\tUsageLine: \"go mod tidy [-e] [-v]\",\n \tShort:     \"add missing and remove unused modules\",\n \tLong: `\n Tidy makes sure go.mod matches the source code in the module.\n@@ -28,55 +26,47 @@ to go.sum and removes any unnecessary ones.\n \n The -v flag causes tidy to print information about removed modules\n to standard error.\n+\n+The -e flag causes tidy to attempt to proceed despite errors\n+encountered while loading packages.\n \t`,\n+\tRun: runTidy,\n }\n \n+var tidyE bool // if true, report errors but proceed anyway.\n+\n func init() {\n-\tcmdTidy.Run = runTidy // break init cycle\n \tcmdTidy.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n-\twork.AddModCommonFlags(cmdTidy)\n+\tcmdTidy.Flag.BoolVar(&tidyE, \"e\", false, \"\")\n+\tbase.AddModCommonFlags(&cmdTidy.Flag)\n }\n \n-func runTidy(cmd *base.Command, args []string) {\n+func runTidy(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n \t\tbase.Fatalf(\"go mod tidy: no arguments allowed\")\n \t}\n \n-\tmodload.LoadALL()\n+\t// Tidy aims to make 'go test' reproducible for any package in 'all', so we\n+\t// need to include test dependencies. For modules that specify go 1.15 or\n+\t// earlier this is a no-op (because 'all' saturates transitive test\n+\t// dependencies).\n+\t//\n+\t// However, with lazy loading (go 1.16+) 'all' includes only the packages that\n+\t// are transitively imported by the main module, not the test dependencies of\n+\t// those packages. In order to make 'go test' reproducible for the packages\n+\t// that are in 'all' but outside of the main module, we must explicitly\n+\t// request that their test dependencies be included.\n+\tmodload.ForceUseModules = true\n+\tmodload.RootMode = modload.NeedRoot\n+\n+\tmodload.LoadPackages(ctx, modload.PackageOpts{\n+\t\tTags:                  imports.AnyTags(),\n+\t\tResolveMissingImports: true,\n+\t\tLoadTests:             true,\n+\t\tAllowErrors:           tidyE,\n+\t}, \"all\")\n+\n \tmodload.TidyBuildList()\n-\tmodTidyGoSum() // updates memory copy; WriteGoMod on next line flushes it out\n+\tmodload.TrimGoSum()\n \tmodload.WriteGoMod()\n }\n-\n-// modTidyGoSum resets the go.sum file content\n-// to be exactly what's needed for the current go.mod.\n-func modTidyGoSum() {\n-\t// Assuming go.sum already has at least enough from the successful load,\n-\t// we only have to tell modfetch what needs keeping.\n-\treqs := modload.Reqs()\n-\tkeep := make(map[module.Version]bool)\n-\treplaced := make(map[module.Version]bool)\n-\tvar walk func(module.Version)\n-\twalk = func(m module.Version) {\n-\t\t// If we build using a replacement module, keep the sum for the replacement,\n-\t\t// since that's the code we'll actually use during a build.\n-\t\t//\n-\t\t// TODO(golang.org/issue/29182): Perhaps we should keep both sums, and the\n-\t\t// sums for both sets of transitive requirements.\n-\t\tr := modload.Replacement(m)\n-\t\tif r.Path == \"\" {\n-\t\t\tkeep[m] = true\n-\t\t} else {\n-\t\t\tkeep[r] = true\n-\t\t\treplaced[m] = true\n-\t\t}\n-\t\tlist, _ := reqs.Required(m)\n-\t\tfor _, r := range list {\n-\t\t\tif !keep[r] && !replaced[r] {\n-\t\t\t\twalk(r)\n-\t\t\t}\n-\t\t}\n-\t}\n-\twalk(modload.Target)\n-\tmodfetch.TrimGoSum(keep)\n-}"}, {"sha": "1bbb57d353ba6ce2f73b44ac33e5627733b081c0", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,26 +6,27 @@ package modcmd\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/work\"\n \n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n )\n \n var cmdVendor = &base.Command{\n-\tUsageLine: \"go mod vendor [-v]\",\n+\tUsageLine: \"go mod vendor [-e] [-v]\",\n \tShort:     \"make vendored copy of dependencies\",\n \tLong: `\n Vendor resets the main module's vendor directory to include all packages\n@@ -34,20 +35,35 @@ It does not include test code for vendored packages.\n \n The -v flag causes vendor to print the names of vendored\n modules and packages to standard error.\n+\n+The -e flag causes vendor to attempt to proceed despite errors\n+encountered while loading packages.\n \t`,\n \tRun: runVendor,\n }\n \n+var vendorE bool // if true, report errors but proceed anyway\n+\n func init() {\n \tcmdVendor.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n-\twork.AddModCommonFlags(cmdVendor)\n+\tcmdVendor.Flag.BoolVar(&vendorE, \"e\", false, \"\")\n+\tbase.AddModCommonFlags(&cmdVendor.Flag)\n }\n \n-func runVendor(cmd *base.Command, args []string) {\n+func runVendor(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) != 0 {\n \t\tbase.Fatalf(\"go mod vendor: vendor takes no arguments\")\n \t}\n-\tpkgs := modload.LoadVendor()\n+\tmodload.ForceUseModules = true\n+\tmodload.RootMode = modload.NeedRoot\n+\n+\tloadOpts := modload.PackageOpts{\n+\t\tTags:                  imports.AnyTags(),\n+\t\tResolveMissingImports: true,\n+\t\tUseVendorAll:          true,\n+\t\tAllowErrors:           vendorE,\n+\t}\n+\t_, pkgs := modload.LoadPackages(ctx, loadOpts, \"all\")\n \n \tvdir := filepath.Join(modload.ModRoot(), \"vendor\")\n \tif err := os.RemoveAll(vdir); err != nil {\n@@ -57,7 +73,7 @@ func runVendor(cmd *base.Command, args []string) {\n \tmodpkgs := make(map[module.Version][]string)\n \tfor _, pkg := range pkgs {\n \t\tm := modload.PackageModule(pkg)\n-\t\tif m == modload.Target {\n+\t\tif m.Path == \"\" || m == modload.Target {\n \t\t\tcontinue\n \t\t}\n \t\tmodpkgs[m] = append(modpkgs[m], pkg)\n@@ -75,28 +91,38 @@ func runVendor(cmd *base.Command, args []string) {\n \t\tincludeAllReplacements = true\n \t}\n \n+\tvar vendorMods []module.Version\n+\tfor m := range isExplicit {\n+\t\tvendorMods = append(vendorMods, m)\n+\t}\n+\tfor m := range modpkgs {\n+\t\tif !isExplicit[m] {\n+\t\t\tvendorMods = append(vendorMods, m)\n+\t\t}\n+\t}\n+\tmodule.Sort(vendorMods)\n+\n \tvar buf bytes.Buffer\n-\tfor _, m := range modload.BuildList()[1:] {\n-\t\tif pkgs := modpkgs[m]; len(pkgs) > 0 || isExplicit[m] {\n-\t\t\tline := moduleLine(m, modload.Replacement(m))\n-\t\t\tbuf.WriteString(line)\n+\tfor _, m := range vendorMods {\n+\t\tline := moduleLine(m, modload.Replacement(m))\n+\t\tbuf.WriteString(line)\n+\t\tif cfg.BuildV {\n+\t\t\tos.Stderr.WriteString(line)\n+\t\t}\n+\t\tif isExplicit[m] {\n+\t\t\tbuf.WriteString(\"## explicit\\n\")\n \t\t\tif cfg.BuildV {\n-\t\t\t\tos.Stderr.WriteString(line)\n+\t\t\t\tos.Stderr.WriteString(\"## explicit\\n\")\n \t\t\t}\n-\t\t\tif isExplicit[m] {\n-\t\t\t\tbuf.WriteString(\"## explicit\\n\")\n-\t\t\t\tif cfg.BuildV {\n-\t\t\t\t\tos.Stderr.WriteString(\"## explicit\\n\")\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsort.Strings(pkgs)\n-\t\t\tfor _, pkg := range pkgs {\n-\t\t\t\tfmt.Fprintf(&buf, \"%s\\n\", pkg)\n-\t\t\t\tif cfg.BuildV {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", pkg)\n-\t\t\t\t}\n-\t\t\t\tvendorPkg(vdir, pkg)\n+\t\t}\n+\t\tpkgs := modpkgs[m]\n+\t\tsort.Strings(pkgs)\n+\t\tfor _, pkg := range pkgs {\n+\t\t\tfmt.Fprintf(&buf, \"%s\\n\", pkg)\n+\t\t\tif cfg.BuildV {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", pkg)\n \t\t\t}\n+\t\t\tvendorPkg(vdir, pkg)\n \t\t}\n \t}\n \n@@ -128,7 +154,7 @@ func runVendor(cmd *base.Command, args []string) {\n \t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n \n-\tif err := ioutil.WriteFile(filepath.Join(vdir, \"modules.txt\"), buf.Bytes(), 0666); err != nil {\n+\tif err := os.WriteFile(filepath.Join(vdir, \"modules.txt\"), buf.Bytes(), 0666); err != nil {\n \t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n }\n@@ -217,7 +243,7 @@ var metaPrefixes = []string{\n }\n \n // matchMetadata reports whether info is a metadata file.\n-func matchMetadata(dir string, info os.FileInfo) bool {\n+func matchMetadata(dir string, info fs.DirEntry) bool {\n \tname := info.Name()\n \tfor _, p := range metaPrefixes {\n \t\tif strings.HasPrefix(name, p) {\n@@ -228,12 +254,12 @@ func matchMetadata(dir string, info os.FileInfo) bool {\n }\n \n // matchPotentialSourceFile reports whether info may be relevant to a build operation.\n-func matchPotentialSourceFile(dir string, info os.FileInfo) bool {\n+func matchPotentialSourceFile(dir string, info fs.DirEntry) bool {\n \tif strings.HasSuffix(info.Name(), \"_test.go\") {\n \t\treturn false\n \t}\n \tif strings.HasSuffix(info.Name(), \".go\") {\n-\t\tf, err := os.Open(filepath.Join(dir, info.Name()))\n+\t\tf, err := fsys.Open(filepath.Join(dir, info.Name()))\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t\t}\n@@ -254,16 +280,16 @@ func matchPotentialSourceFile(dir string, info os.FileInfo) bool {\n }\n \n // copyDir copies all regular files satisfying match(info) from src to dst.\n-func copyDir(dst, src string, match func(dir string, info os.FileInfo) bool) {\n-\tfiles, err := ioutil.ReadDir(src)\n+func copyDir(dst, src string, match func(dir string, info fs.DirEntry) bool) {\n+\tfiles, err := os.ReadDir(src)\n \tif err != nil {\n \t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n \tif err := os.MkdirAll(dst, 0777); err != nil {\n \t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n \tfor _, file := range files {\n-\t\tif file.IsDir() || !file.Mode().IsRegular() || !match(src, file) {\n+\t\tif file.IsDir() || !file.Type().IsRegular() || !match(src, file) {\n \t\t\tcontinue\n \t\t}\n \t\tr, err := os.Open(filepath.Join(src, file.Name()))"}, {"sha": "c83e70076ae2cc06fb4009b57e29c79f5d955e6d", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,17 +6,16 @@ package modcmd\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"runtime\"\n \n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/work\"\n \n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/sumdb/dirhash\"\n@@ -37,29 +36,23 @@ non-zero status.\n }\n \n func init() {\n-\twork.AddModCommonFlags(cmdVerify)\n+\tbase.AddModCommonFlags(&cmdVerify.Flag)\n }\n \n-func runVerify(cmd *base.Command, args []string) {\n+func runVerify(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) != 0 {\n \t\t// NOTE(rsc): Could take a module pattern.\n \t\tbase.Fatalf(\"go mod verify: verify takes no arguments\")\n \t}\n-\t// Checks go mod expected behavior\n-\tif !modload.Enabled() || !modload.HasModRoot() {\n-\t\tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n-\t\t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n-\t\t} else {\n-\t\t\tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n-\t\t}\n-\t}\n+\tmodload.ForceUseModules = true\n+\tmodload.RootMode = modload.NeedRoot\n \n \t// Only verify up to GOMAXPROCS zips at once.\n \ttype token struct{}\n \tsem := make(chan token, runtime.GOMAXPROCS(0))\n \n \t// Use a slice of result channels, so that the output is deterministic.\n-\tmods := modload.LoadBuildList()[1:]\n+\tmods := modload.LoadAllModules(ctx)[1:]\n \terrsChans := make([]<-chan []error, len(mods))\n \n \tfor i, mod := range mods {\n@@ -93,10 +86,10 @@ func verifyMod(mod module.Version) []error {\n \t\t_, zipErr = os.Stat(zip)\n \t}\n \tdir, dirErr := modfetch.DownloadDir(mod)\n-\tdata, err := ioutil.ReadFile(zip + \"hash\")\n+\tdata, err := os.ReadFile(zip + \"hash\")\n \tif err != nil {\n-\t\tif zipErr != nil && errors.Is(zipErr, os.ErrNotExist) &&\n-\t\t\tdirErr != nil && errors.Is(dirErr, os.ErrNotExist) {\n+\t\tif zipErr != nil && errors.Is(zipErr, fs.ErrNotExist) &&\n+\t\t\tdirErr != nil && errors.Is(dirErr, fs.ErrNotExist) {\n \t\t\t// Nothing downloaded yet. Nothing to verify.\n \t\t\treturn nil\n \t\t}\n@@ -105,7 +98,7 @@ func verifyMod(mod module.Version) []error {\n \t}\n \th := string(bytes.TrimSpace(data))\n \n-\tif zipErr != nil && errors.Is(zipErr, os.ErrNotExist) {\n+\tif zipErr != nil && errors.Is(zipErr, fs.ErrNotExist) {\n \t\t// ok\n \t} else {\n \t\thZ, err := dirhash.HashZip(zip, dirhash.DefaultHash)\n@@ -116,7 +109,7 @@ func verifyMod(mod module.Version) []error {\n \t\t\terrs = append(errs, fmt.Errorf(\"%s %s: zip has been modified (%v)\", mod.Path, mod.Version, zip))\n \t\t}\n \t}\n-\tif dirErr != nil && errors.Is(dirErr, os.ErrNotExist) {\n+\tif dirErr != nil && errors.Is(dirErr, fs.ErrNotExist) {\n \t\t// ok\n \t} else {\n \t\thD, err := dirhash.HashDir(dir, mod.Path+\"@\"+mod.Version, dirhash.DefaultHash)"}, {"sha": "e287c8806017123420928d23d0f612b13de6c090", "filename": "libgo/go/cmd/go/internal/modcmd/why.go", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,12 +5,13 @@\n package modcmd\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/work\"\n \n \t\"golang.org/x/mod/module\"\n )\n@@ -57,25 +58,33 @@ var (\n \n func init() {\n \tcmdWhy.Run = runWhy // break init cycle\n-\twork.AddModCommonFlags(cmdWhy)\n+\tbase.AddModCommonFlags(&cmdWhy.Flag)\n }\n \n-func runWhy(cmd *base.Command, args []string) {\n-\tloadALL := modload.LoadALL\n-\tif *whyVendor {\n-\t\tloadALL = modload.LoadVendor\n+func runWhy(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.ForceUseModules = true\n+\tmodload.RootMode = modload.NeedRoot\n+\n+\tloadOpts := modload.PackageOpts{\n+\t\tTags:          imports.AnyTags(),\n+\t\tLoadTests:     !*whyVendor,\n+\t\tSilenceErrors: true,\n+\t\tUseVendorAll:  *whyVendor,\n \t}\n+\n \tif *whyM {\n \t\tlistU := false\n \t\tlistVersions := false\n+\t\tlistRetractions := false\n \t\tfor _, arg := range args {\n \t\t\tif strings.Contains(arg, \"@\") {\n \t\t\t\tbase.Fatalf(\"go mod why: module query not allowed\")\n \t\t\t}\n \t\t}\n-\t\tmods := modload.ListModules(args, listU, listVersions)\n+\t\tmods := modload.ListModules(ctx, args, listU, listVersions, listRetractions)\n \t\tbyModule := make(map[module.Version][]string)\n-\t\tfor _, path := range loadALL() {\n+\t\t_, pkgs := modload.LoadPackages(ctx, loadOpts, \"all\")\n+\t\tfor _, path := range pkgs {\n \t\t\tm := modload.PackageModule(path)\n \t\t\tif m.Path != \"\" {\n \t\t\t\tbyModule[m] = append(byModule[m], path)\n@@ -104,8 +113,11 @@ func runWhy(cmd *base.Command, args []string) {\n \t\t\tsep = \"\\n\"\n \t\t}\n \t} else {\n-\t\tmatches := modload.ImportPaths(args) // resolve to packages\n-\t\tloadALL()                            // rebuild graph, from main module (not from named packages)\n+\t\t// Resolve to packages.\n+\t\tmatches, _ := modload.LoadPackages(ctx, loadOpts, args...)\n+\n+\t\tmodload.LoadPackages(ctx, loadOpts, \"all\") // rebuild graph, from main module (not from named packages)\n+\n \t\tsep := \"\"\n \t\tfor _, m := range matches {\n \t\t\tfor _, path := range m.Pkgs {"}, {"sha": "5d4165c9443225163f6a50936c4d9ac2a3461dad", "filename": "libgo/go/cmd/go/internal/modconv/convert.go", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,13 +7,12 @@ package modconv\n import (\n \t\"fmt\"\n \t\"os\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n-\t\"sync\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/par\"\n \n \t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n@@ -42,46 +41,54 @@ func ConvertLegacyConfig(f *modfile.File, file string, data []byte) error {\n \n \t// Convert requirements block, which may use raw SHA1 hashes as versions,\n \t// to valid semver requirement list, respecting major versions.\n-\tvar (\n-\t\twork    par.Work\n-\t\tmu      sync.Mutex\n-\t\tneed    = make(map[string]string)\n-\t\treplace = make(map[string]*modfile.Replace)\n-\t)\n+\tversions := make([]module.Version, len(mf.Require))\n+\treplace := make(map[string]*modfile.Replace)\n \n \tfor _, r := range mf.Replace {\n \t\treplace[r.New.Path] = r\n \t\treplace[r.Old.Path] = r\n \t}\n-\tfor _, r := range mf.Require {\n+\n+\ttype token struct{}\n+\tsem := make(chan token, runtime.GOMAXPROCS(0))\n+\tfor i, r := range mf.Require {\n \t\tm := r.Mod\n \t\tif m.Path == \"\" {\n \t\t\tcontinue\n \t\t}\n \t\tif re, ok := replace[m.Path]; ok {\n-\t\t\twork.Add(re.New)\n-\t\t\tcontinue\n+\t\t\tm = re.New\n \t\t}\n-\t\twork.Add(r.Mod)\n+\t\tsem <- token{}\n+\t\tgo func(i int, m module.Version) {\n+\t\t\tdefer func() { <-sem }()\n+\t\t\trepo, info, err := modfetch.ImportRepoRev(m.Path, m.Version)\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: converting %s: stat %s@%s: %v\\n\", base.ShortPath(file), m.Path, m.Version, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tpath := repo.ModulePath()\n+\t\t\tversions[i].Path = path\n+\t\t\tversions[i].Version = info.Version\n+\t\t}(i, m)\n+\t}\n+\t// Fill semaphore channel to wait for all tasks to finish.\n+\tfor n := cap(sem); n > 0; n-- {\n+\t\tsem <- token{}\n \t}\n \n-\twork.Do(10, func(item interface{}) {\n-\t\tr := item.(module.Version)\n-\t\trepo, info, err := modfetch.ImportRepoRev(r.Path, r.Version)\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: converting %s: stat %s@%s: %v\\n\", base.ShortPath(file), r.Path, r.Version, err)\n-\t\t\treturn\n+\tneed := map[string]string{}\n+\tfor _, v := range versions {\n+\t\tif v.Path == \"\" {\n+\t\t\tcontinue\n \t\t}\n-\t\tmu.Lock()\n-\t\tpath := repo.ModulePath()\n \t\t// Don't use semver.Max here; need to preserve +incompatible suffix.\n-\t\tif v, ok := need[path]; !ok || semver.Compare(v, info.Version) < 0 {\n-\t\t\tneed[path] = info.Version\n+\t\tif needv, ok := need[v.Path]; !ok || semver.Compare(needv, v.Version) < 0 {\n+\t\t\tneed[v.Path] = v.Version\n \t\t}\n-\t\tmu.Unlock()\n-\t})\n-\n-\tvar paths []string\n+\t}\n+\tpaths := make([]string, 0, len(need))\n \tfor path := range need {\n \t\tpaths = append(paths, path)\n \t}"}, {"sha": "66b9ff4f382f2678cf39a8869321b50c16c3307a", "filename": "libgo/go/cmd/go/internal/modconv/convert_test.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,9 +6,9 @@ package modconv\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"fmt\"\n \t\"internal/testenv\"\n-\t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -36,7 +36,7 @@ func testMain(m *testing.M) int {\n \t\treturn 0\n \t}\n \n-\tdir, err := ioutil.TempDir(\"\", \"modconv-test-\")\n+\tdir, err := os.MkdirTemp(\"\", \"modconv-test-\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n@@ -146,6 +146,8 @@ func TestConvertLegacyConfig(t *testing.T) {\n \t\t},\n \t}\n \n+\tctx := context.Background()\n+\n \tfor _, tt := range tests {\n \t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"_\"+tt.vers, func(t *testing.T) {\n \t\t\tf, err := modfile.Parse(\"golden\", []byte(tt.gomod), nil)\n@@ -157,14 +159,14 @@ func TestConvertLegacyConfig(t *testing.T) {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \n-\t\t\tdir, err := modfetch.Download(module.Version{Path: tt.path, Version: tt.vers})\n+\t\t\tdir, err := modfetch.Download(ctx, module.Version{Path: tt.path, Version: tt.vers})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \n \t\t\tfor name := range Converters {\n \t\t\t\tfile := filepath.Join(dir, name)\n-\t\t\t\tdata, err := ioutil.ReadFile(file)\n+\t\t\t\tdata, err := os.ReadFile(file)\n \t\t\t\tif err == nil {\n \t\t\t\t\tf := new(modfile.File)\n \t\t\t\t\tf.AddModuleStmt(tt.path)"}, {"sha": "750525d404b09d3e104e0414c9bd5b1fa6f3200d", "filename": "libgo/go/cmd/go/internal/modconv/modconv_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,7 +7,7 @@ package modconv\n import (\n \t\"bytes\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"path/filepath\"\n \t\"testing\"\n )\n@@ -42,15 +42,15 @@ func Test(t *testing.T) {\n \t\t\tif Converters[extMap[ext]] == nil {\n \t\t\t\tt.Fatalf(\"Converters[%q] == nil\", extMap[ext])\n \t\t\t}\n-\t\t\tdata, err := ioutil.ReadFile(test)\n+\t\t\tdata, err := os.ReadFile(test)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \t\t\tout, err := Converters[extMap[ext]](test, data)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n-\t\t\twant, err := ioutil.ReadFile(test[:len(test)-len(ext)] + \".out\")\n+\t\t\twant, err := os.ReadFile(test[:len(test)-len(ext)] + \".out\")\n \t\t\tif err != nil {\n \t\t\t\tt.Error(err)\n \t\t\t}"}, {"sha": "3a2ff63721cb368e4b0825a8d75ae8fbee8eafc5", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,10 +10,11 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n+\t\"sync\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n@@ -59,7 +60,7 @@ func CachePath(m module.Version, suffix string) (string, error) {\n \n // DownloadDir returns the directory to which m should have been downloaded.\n // An error will be returned if the module path or version cannot be escaped.\n-// An error satisfying errors.Is(err, os.ErrNotExist) will be returned\n+// An error satisfying errors.Is(err, fs.ErrNotExist) will be returned\n // along with the directory if the directory does not exist or if the directory\n // is not completely populated.\n func DownloadDir(m module.Version) (string, error) {\n@@ -106,14 +107,14 @@ func DownloadDir(m module.Version) (string, error) {\n // DownloadDirPartialError is returned by DownloadDir if a module directory\n // exists but was not completely populated.\n //\n-// DownloadDirPartialError is equivalent to os.ErrNotExist.\n+// DownloadDirPartialError is equivalent to fs.ErrNotExist.\n type DownloadDirPartialError struct {\n \tDir string\n \tErr error\n }\n \n func (e *DownloadDirPartialError) Error() string     { return fmt.Sprintf(\"%s: %v\", e.Dir, e.Err) }\n-func (e *DownloadDirPartialError) Is(err error) bool { return err == os.ErrNotExist }\n+func (e *DownloadDirPartialError) Is(err error) bool { return err == fs.ErrNotExist }\n \n // lockVersion locks a file within the module cache that guards the downloading\n // and extraction of the zipfile for the given module version.\n@@ -155,16 +156,30 @@ func SideLock() (unlock func(), err error) {\n type cachingRepo struct {\n \tpath  string\n \tcache par.Cache // cache for all operations\n-\tr     Repo\n+\n+\tonce     sync.Once\n+\tinitRepo func() (Repo, error)\n+\tr        Repo\n }\n \n-func newCachingRepo(r Repo) *cachingRepo {\n+func newCachingRepo(path string, initRepo func() (Repo, error)) *cachingRepo {\n \treturn &cachingRepo{\n-\t\tr:    r,\n-\t\tpath: r.ModulePath(),\n+\t\tpath:     path,\n+\t\tinitRepo: initRepo,\n \t}\n }\n \n+func (r *cachingRepo) repo() Repo {\n+\tr.once.Do(func() {\n+\t\tvar err error\n+\t\tr.r, err = r.initRepo()\n+\t\tif err != nil {\n+\t\t\tr.r = errRepo{r.path, err}\n+\t\t}\n+\t})\n+\treturn r.r\n+}\n+\n func (r *cachingRepo) ModulePath() string {\n \treturn r.path\n }\n@@ -175,7 +190,7 @@ func (r *cachingRepo) Versions(prefix string) ([]string, error) {\n \t\terr  error\n \t}\n \tc := r.cache.Do(\"versions:\"+prefix, func() interface{} {\n-\t\tlist, err := r.r.Versions(prefix)\n+\t\tlist, err := r.repo().Versions(prefix)\n \t\treturn cached{list, err}\n \t}).(cached)\n \n@@ -197,7 +212,7 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n \t\t\treturn cachedInfo{info, nil}\n \t\t}\n \n-\t\tinfo, err = r.r.Stat(rev)\n+\t\tinfo, err = r.repo().Stat(rev)\n \t\tif err == nil {\n \t\t\t// If we resolved, say, 1234abcde to v0.0.0-20180604122334-1234abcdef78,\n \t\t\t// then save the information under the proper version, for future use.\n@@ -224,7 +239,7 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n \n func (r *cachingRepo) Latest() (*RevInfo, error) {\n \tc := r.cache.Do(\"latest:\", func() interface{} {\n-\t\tinfo, err := r.r.Latest()\n+\t\tinfo, err := r.repo().Latest()\n \n \t\t// Save info for likely future Stat call.\n \t\tif err == nil {\n@@ -258,7 +273,7 @@ func (r *cachingRepo) GoMod(version string) ([]byte, error) {\n \t\t\treturn cached{text, nil}\n \t\t}\n \n-\t\ttext, err = r.r.GoMod(version)\n+\t\ttext, err = r.repo().GoMod(version)\n \t\tif err == nil {\n \t\t\tif err := checkGoMod(r.path, version, text); err != nil {\n \t\t\t\treturn cached{text, err}\n@@ -277,26 +292,11 @@ func (r *cachingRepo) GoMod(version string) ([]byte, error) {\n }\n \n func (r *cachingRepo) Zip(dst io.Writer, version string) error {\n-\treturn r.r.Zip(dst, version)\n-}\n-\n-// Stat is like Lookup(path).Stat(rev) but avoids the\n-// repository path resolution in Lookup if the result is\n-// already cached on local disk.\n-func Stat(proxy, path, rev string) (*RevInfo, error) {\n-\t_, info, err := readDiskStat(path, rev)\n-\tif err == nil {\n-\t\treturn info, nil\n-\t}\n-\trepo, err := Lookup(proxy, path)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn repo.Stat(rev)\n+\treturn r.repo().Zip(dst, version)\n }\n \n-// InfoFile is like Stat but returns the name of the file containing\n-// the cached information.\n+// InfoFile is like Lookup(path).Stat(version) but returns the name of the file\n+// containing the cached information.\n func InfoFile(path, version string) (string, error) {\n \tif !semver.IsValid(version) {\n \t\treturn \"\", fmt.Errorf(\"invalid version %q\", version)\n@@ -307,10 +307,7 @@ func InfoFile(path, version string) (string, error) {\n \t}\n \n \terr := TryProxies(func(proxy string) error {\n-\t\trepo, err := Lookup(proxy, path)\n-\t\tif err == nil {\n-\t\t\t_, err = repo.Stat(version)\n-\t\t}\n+\t\t_, err := Lookup(proxy, path).Stat(version)\n \t\treturn err\n \t})\n \tif err != nil {\n@@ -336,11 +333,7 @@ func GoMod(path, rev string) ([]byte, error) {\n \t\t\trev = info.Version\n \t\t} else {\n \t\t\terr := TryProxies(func(proxy string) error {\n-\t\t\t\trepo, err := Lookup(proxy, path)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tinfo, err := repo.Stat(rev)\n+\t\t\t\tinfo, err := Lookup(proxy, path).Stat(rev)\n \t\t\t\tif err == nil {\n \t\t\t\t\trev = info.Version\n \t\t\t\t}\n@@ -357,11 +350,8 @@ func GoMod(path, rev string) ([]byte, error) {\n \t\treturn data, nil\n \t}\n \n-\terr = TryProxies(func(proxy string) error {\n-\t\trepo, err := Lookup(proxy, path)\n-\t\tif err == nil {\n-\t\t\tdata, err = repo.GoMod(rev)\n-\t\t}\n+\terr = TryProxies(func(proxy string) (err error) {\n+\t\tdata, err = Lookup(proxy, path).GoMod(rev)\n \t\treturn err\n \t})\n \treturn data, err\n@@ -492,7 +482,7 @@ func readDiskStatByHash(path, rev string) (file string, info *RevInfo, err error\n \tfor _, name := range names {\n \t\tif strings.HasSuffix(name, suffix) {\n \t\t\tv := strings.TrimSuffix(name, \".info\")\n-\t\t\tif IsPseudoVersion(v) && semver.Max(maxVersion, v) == v {\n+\t\t\tif IsPseudoVersion(v) && semver.Compare(v, maxVersion) > 0 {\n \t\t\t\tmaxVersion = v\n \t\t\t\tfile, info, err = readDiskStat(path, strings.TrimSuffix(name, \".info\"))\n \t\t\t}\n@@ -607,7 +597,7 @@ func rewriteVersionList(dir string) {\n \t}\n \tdefer unlock()\n \n-\tinfos, err := ioutil.ReadDir(dir)\n+\tinfos, err := os.ReadDir(dir)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "722c984e376f6468969544c19636f056b50edb98", "filename": "libgo/go/cmd/go/internal/modfetch/cache_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,14 +5,13 @@\n package modfetch\n \n import (\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"testing\"\n )\n \n func TestWriteDiskCache(t *testing.T) {\n-\ttmpdir, err := ioutil.TempDir(\"\", \"go-writeCache-test-\")\n+\ttmpdir, err := os.MkdirTemp(\"\", \"go-writeCache-test-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "86c1c14d4a7ad643f5fd30d0aae095ad878b7da1", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/codehost.go", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -11,7 +11,7 @@ import (\n \t\"crypto/sha256\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -79,9 +79,8 @@ type Repo interface {\n \tReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, err error)\n \n \t// RecentTag returns the most recent tag on rev or one of its predecessors\n-\t// with the given prefix and major version.\n-\t// An empty major string matches any major version.\n-\tRecentTag(rev, prefix, major string) (tag string, err error)\n+\t// with the given prefix. allowed may be used to filter out unwanted versions.\n+\tRecentTag(rev, prefix string, allowed func(string) bool) (tag string, err error)\n \n \t// DescendsFrom reports whether rev or any of its ancestors has the given tag.\n \t//\n@@ -106,7 +105,7 @@ type FileRev struct {\n \tErr  error  // error if any; os.IsNotExist(Err)==true if rev exists but file does not exist in that rev\n }\n \n-// UnknownRevisionError is an error equivalent to os.ErrNotExist, but for a\n+// UnknownRevisionError is an error equivalent to fs.ErrNotExist, but for a\n // revision rather than a file.\n type UnknownRevisionError struct {\n \tRev string\n@@ -116,10 +115,10 @@ func (e *UnknownRevisionError) Error() string {\n \treturn \"unknown revision \" + e.Rev\n }\n func (UnknownRevisionError) Is(err error) bool {\n-\treturn err == os.ErrNotExist\n+\treturn err == fs.ErrNotExist\n }\n \n-// ErrNoCommits is an error equivalent to os.ErrNotExist indicating that a given\n+// ErrNoCommits is an error equivalent to fs.ErrNotExist indicating that a given\n // repository or module contains no commits.\n var ErrNoCommits error = noCommitsError{}\n \n@@ -129,7 +128,7 @@ func (noCommitsError) Error() string {\n \treturn \"no commits\"\n }\n func (noCommitsError) Is(err error) bool {\n-\treturn err == os.ErrNotExist\n+\treturn err == fs.ErrNotExist\n }\n \n // AllHex reports whether the revision rev is entirely lower-case hexadecimal digits.\n@@ -189,7 +188,7 @@ func WorkDir(typ, name string) (dir, lockfile string, err error) {\n \t}\n \tdefer unlock()\n \n-\tdata, err := ioutil.ReadFile(dir + \".info\")\n+\tdata, err := os.ReadFile(dir + \".info\")\n \tinfo, err2 := os.Stat(dir)\n \tif err == nil && err2 == nil && info.IsDir() {\n \t\t// Info file and directory both already exist: reuse.\n@@ -211,7 +210,7 @@ func WorkDir(typ, name string) (dir, lockfile string, err error) {\n \tif err := os.MkdirAll(dir, 0777); err != nil {\n \t\treturn \"\", \"\", err\n \t}\n-\tif err := ioutil.WriteFile(dir+\".info\", []byte(key), 0666); err != nil {\n+\tif err := os.WriteFile(dir+\".info\", []byte(key), 0666); err != nil {\n \t\tos.RemoveAll(dir)\n \t\treturn \"\", \"\", err\n \t}\n@@ -264,6 +263,9 @@ func RunWithStdin(dir string, stdin io.Reader, cmdline ...interface{}) ([]byte,\n \t}\n \n \tcmd := str.StringList(cmdline...)\n+\tif os.Getenv(\"TESTGOVCS\") == \"panic\" {\n+\t\tpanic(fmt.Sprintf(\"use of vcs: %v\", cmd))\n+\t}\n \tif cfg.BuildX {\n \t\ttext := new(strings.Builder)\n \t\tif dir != \"\" {"}, {"sha": "8abc039e7fc0688a1b002a34f95109182bdef0a1", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,7 +9,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n@@ -34,13 +34,13 @@ func LocalGitRepo(remote string) (Repo, error) {\n }\n \n // A notExistError wraps another error to retain its original text\n-// but makes it opaquely equivalent to os.ErrNotExist.\n+// but makes it opaquely equivalent to fs.ErrNotExist.\n type notExistError struct {\n \terr error\n }\n \n func (e notExistError) Error() string   { return e.err.Error() }\n-func (notExistError) Is(err error) bool { return err == os.ErrNotExist }\n+func (notExistError) Is(err error) bool { return err == fs.ErrNotExist }\n \n const gitWorkDirType = \"git3\"\n \n@@ -188,7 +188,7 @@ func (r *gitRepo) loadRefs() {\n \t\t// For HTTP and HTTPS, that's easy to detect: we'll try to fetch the URL\n \t\t// ourselves and see what code it serves.\n \t\tif u, err := url.Parse(r.remoteURL); err == nil && (u.Scheme == \"http\" || u.Scheme == \"https\") {\n-\t\t\tif _, err := web.GetBytes(u); errors.Is(err, os.ErrNotExist) {\n+\t\t\tif _, err := web.GetBytes(u); errors.Is(err, fs.ErrNotExist) {\n \t\t\t\tgitErr = notExistError{gitErr}\n \t\t\t}\n \t\t}\n@@ -505,7 +505,7 @@ func (r *gitRepo) ReadFile(rev, file string, maxSize int64) ([]byte, error) {\n \t}\n \tout, err := Run(r.dir, \"git\", \"cat-file\", \"blob\", info.Name+\":\"+file)\n \tif err != nil {\n-\t\treturn nil, os.ErrNotExist\n+\t\treturn nil, fs.ErrNotExist\n \t}\n \treturn out, nil\n }\n@@ -629,9 +629,9 @@ func (r *gitRepo) readFileRevs(tags []string, file string, fileMap map[string]*F\n \t\tcase \"tag\", \"commit\":\n \t\t\tswitch fileType {\n \t\t\tdefault:\n-\t\t\t\tf.Err = &os.PathError{Path: tag + \":\" + file, Op: \"read\", Err: fmt.Errorf(\"unexpected non-blob type %q\", fileType)}\n+\t\t\t\tf.Err = &fs.PathError{Path: tag + \":\" + file, Op: \"read\", Err: fmt.Errorf(\"unexpected non-blob type %q\", fileType)}\n \t\t\tcase \"missing\":\n-\t\t\t\tf.Err = &os.PathError{Path: tag + \":\" + file, Op: \"read\", Err: os.ErrNotExist}\n+\t\t\t\tf.Err = &fs.PathError{Path: tag + \":\" + file, Op: \"read\", Err: fs.ErrNotExist}\n \t\t\tcase \"blob\":\n \t\t\t\tf.Data = fileData\n \t\t\t}\n@@ -644,7 +644,7 @@ func (r *gitRepo) readFileRevs(tags []string, file string, fileMap map[string]*F\n \treturn missing, nil\n }\n \n-func (r *gitRepo) RecentTag(rev, prefix, major string) (tag string, err error) {\n+func (r *gitRepo) RecentTag(rev, prefix string, allowed func(string) bool) (tag string, err error) {\n \tinfo, err := r.Stat(rev)\n \tif err != nil {\n \t\treturn \"\", err\n@@ -680,7 +680,10 @@ func (r *gitRepo) RecentTag(rev, prefix, major string) (tag string, err error) {\n \t\t\t// NOTE: Do not replace the call to semver.Compare with semver.Max.\n \t\t\t// We want to return the actual tag, not a canonicalized version of it,\n \t\t\t// and semver.Max currently canonicalizes (see golang.org/issue/32700).\n-\t\t\tif c := semver.Canonical(semtag); c != \"\" && strings.HasPrefix(semtag, c) && (major == \"\" || semver.Major(c) == major) && semver.Compare(semtag, highest) > 0 {\n+\t\t\tif c := semver.Canonical(semtag); c == \"\" || !strings.HasPrefix(semtag, c) || !allowed(semtag) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif semver.Compare(semtag, highest) > 0 {\n \t\t\t\thighest = semtag\n \t\t\t}\n \t\t}\n@@ -823,12 +826,12 @@ func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser,\n \tarchive, err := Run(r.dir, \"git\", \"-c\", \"core.autocrlf=input\", \"-c\", \"core.eol=lf\", \"archive\", \"--format=zip\", \"--prefix=prefix/\", info.Name, args)\n \tif err != nil {\n \t\tif bytes.Contains(err.(*RunError).Stderr, []byte(\"did not match any files\")) {\n-\t\t\treturn nil, os.ErrNotExist\n+\t\t\treturn nil, fs.ErrNotExist\n \t\t}\n \t\treturn nil, err\n \t}\n \n-\treturn ioutil.NopCloser(bytes.NewReader(archive)), nil\n+\treturn io.NopCloser(bytes.NewReader(archive)), nil\n }\n \n // ensureGitAttributes makes sure export-subst and export-ignore features are\n@@ -859,7 +862,7 @@ func ensureGitAttributes(repoDir string) (err error) {\n \t\t}\n \t}()\n \n-\tb, err := ioutil.ReadAll(f)\n+\tb, err := io.ReadAll(f)\n \tif err != nil {\n \t\treturn err\n \t}"}, {"sha": "89a73baad9d9c7f1329bca9da9a150b46429cafe", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,7 +10,8 @@ import (\n \t\"flag\"\n \t\"fmt\"\n \t\"internal/testenv\"\n-\t\"io/ioutil\"\n+\t\"io\"\n+\t\"io/fs\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -52,7 +53,7 @@ func testMain(m *testing.M) int {\n \t\treturn 0\n \t}\n \n-\tdir, err := ioutil.TempDir(\"\", \"gitrepo-test-\")\n+\tdir, err := os.MkdirTemp(\"\", \"gitrepo-test-\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n@@ -210,7 +211,7 @@ var readFileTests = []struct {\n \t\trepo: gitrepo1,\n \t\trev:  \"v2.3.4\",\n \t\tfile: \"another.txt\",\n-\t\terr:  os.ErrNotExist.Error(),\n+\t\terr:  fs.ErrNotExist.Error(),\n \t},\n }\n \n@@ -432,7 +433,7 @@ func TestReadZip(t *testing.T) {\n \t\t\tif tt.err != \"\" {\n \t\t\t\tt.Fatalf(\"ReadZip: no error, wanted %v\", tt.err)\n \t\t\t}\n-\t\t\tzipdata, err := ioutil.ReadAll(rc)\n+\t\t\tzipdata, err := io.ReadAll(rc)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}"}, {"sha": "ce8b501d53c8a565ce538d7f9fcc54d8f70e3bf1", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/shell.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -14,7 +14,7 @@ import (\n \t\"bytes\"\n \t\"flag\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"log\"\n \t\"os\"\n \t\"strings\"\n@@ -115,15 +115,15 @@ func main() {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tdata, err := ioutil.ReadAll(rc)\n+\t\t\tdata, err := io.ReadAll(rc)\n \t\t\trc.Close()\n \t\t\tif err != nil {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n \t\t\t\tcontinue\n \t\t\t}\n \n \t\t\tif f[3] != \"-\" {\n-\t\t\t\tif err := ioutil.WriteFile(f[3], data, 0666); err != nil {\n+\t\t\t\tif err := os.WriteFile(f[3], data, 0666); err != nil {\n \t\t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n \t\t\t\t\tcontinue\n \t\t\t\t}"}, {"sha": "c2cca084e3077a8b3f9627e8b212491c1baf06dd", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/vcs.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,7 +9,7 @@ import (\n \t\"fmt\"\n \t\"internal/lazyregexp\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"sort\"\n@@ -377,7 +377,7 @@ func (r *vcsRepo) ReadFile(rev, file string, maxSize int64) ([]byte, error) {\n \n \tout, err := Run(r.dir, r.cmd.readFile(rev, file, r.remote))\n \tif err != nil {\n-\t\treturn nil, os.ErrNotExist\n+\t\treturn nil, fs.ErrNotExist\n \t}\n \treturn out, nil\n }\n@@ -395,7 +395,7 @@ func (r *vcsRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[s\n \treturn nil, vcsErrorf(\"ReadFileRevs not implemented\")\n }\n \n-func (r *vcsRepo) RecentTag(rev, prefix, major string) (tag string, err error) {\n+func (r *vcsRepo) RecentTag(rev, prefix string, allowed func(string) bool) (tag string, err error) {\n \t// We don't technically need to lock here since we're returning an error\n \t// uncondititonally, but doing so anyway will help to avoid baking in\n \t// lock-inversion bugs.\n@@ -432,7 +432,7 @@ func (r *vcsRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser,\n \tif rev == \"latest\" {\n \t\trev = r.cmd.latest\n \t}\n-\tf, err := ioutil.TempFile(\"\", \"go-readzip-*.zip\")\n+\tf, err := os.CreateTemp(\"\", \"go-readzip-*.zip\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -567,7 +567,7 @@ func bzrParseStat(rev, out string) (*RevInfo, error) {\n \n func fossilParseStat(rev, out string) (*RevInfo, error) {\n \tfor _, line := range strings.Split(out, \"\\n\") {\n-\t\tif strings.HasPrefix(line, \"uuid:\") {\n+\t\tif strings.HasPrefix(line, \"uuid:\") || strings.HasPrefix(line, \"hash:\") {\n \t\t\tf := strings.Fields(line)\n \t\t\tif len(f) != 5 || len(f[1]) != 40 || f[4] != \"UTC\" {\n \t\t\t\treturn nil, vcsErrorf(\"unexpected response from fossil info: %q\", line)"}, {"sha": "2dcbb99b18514ae3abd52e78a3406810fae83f3a", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 79, "deletions": 11, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path\"\n \t\"sort\"\n@@ -419,9 +419,14 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\ttagPrefix = r.codeDir + \"/\"\n \t}\n \n+\tisRetracted, err := r.retractedVersions()\n+\tif err != nil {\n+\t\tisRetracted = func(string) bool { return false }\n+\t}\n+\n \t// tagToVersion returns the version obtained by trimming tagPrefix from tag.\n-\t// If the tag is invalid or a pseudo-version, tagToVersion returns an empty\n-\t// version.\n+\t// If the tag is invalid, retracted, or a pseudo-version, tagToVersion returns\n+\t// an empty version.\n \ttagToVersion := func(tag string) (v string, tagIsCanonical bool) {\n \t\tif !strings.HasPrefix(tag, tagPrefix) {\n \t\t\treturn \"\", false\n@@ -436,6 +441,9 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\tif v == \"\" || !strings.HasPrefix(trimmed, v) {\n \t\t\treturn \"\", false // Invalid or incomplete version (just vX or vX.Y).\n \t\t}\n+\t\tif isRetracted(v) {\n+\t\t\treturn \"\", false\n+\t\t}\n \t\tif v == trimmed {\n \t\t\ttagIsCanonical = true\n \t\t}\n@@ -500,15 +508,24 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\treturn checkGoMod()\n \t}\n \n+\t// Find the highest tagged version in the revision's history, subject to\n+\t// major version and +incompatible constraints. Use that version as the\n+\t// pseudo-version base so that the pseudo-version sorts higher. Ignore\n+\t// retracted versions.\n+\tallowedMajor := func(major string) func(v string) bool {\n+\t\treturn func(v string) bool {\n+\t\t\treturn (major == \"\" || semver.Major(v) == major) && !isRetracted(v)\n+\t\t}\n+\t}\n \tif pseudoBase == \"\" {\n \t\tvar tag string\n \t\tif r.pseudoMajor != \"\" || canUseIncompatible() {\n-\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, r.pseudoMajor)\n+\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, allowedMajor(r.pseudoMajor))\n \t\t} else {\n \t\t\t// Allow either v1 or v0, but not incompatible higher versions.\n-\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, \"v1\")\n+\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, allowedMajor(\"v1\"))\n \t\t\tif tag == \"\" {\n-\t\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, \"v0\")\n+\t\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, allowedMajor(\"v0\"))\n \t\t\t}\n \t\t}\n \t\tpseudoBase, _ = tagToVersion(tag) // empty if the tag is invalid\n@@ -869,6 +886,57 @@ func (r *codeRepo) modPrefix(rev string) string {\n \treturn r.modPath + \"@\" + rev\n }\n \n+func (r *codeRepo) retractedVersions() (func(string) bool, error) {\n+\tversions, err := r.Versions(\"\")\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfor i, v := range versions {\n+\t\tif strings.HasSuffix(v, \"+incompatible\") {\n+\t\t\tversions = versions[:i]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif len(versions) == 0 {\n+\t\treturn func(string) bool { return false }, nil\n+\t}\n+\n+\tvar highest string\n+\tfor i := len(versions) - 1; i >= 0; i-- {\n+\t\tv := versions[i]\n+\t\tif semver.Prerelease(v) == \"\" {\n+\t\t\thighest = v\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif highest == \"\" {\n+\t\thighest = versions[len(versions)-1]\n+\t}\n+\n+\tdata, err := r.GoMod(highest)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tf, err := modfile.ParseLax(\"go.mod\", data, nil)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tretractions := make([]modfile.VersionInterval, len(f.Retract))\n+\tfor _, r := range f.Retract {\n+\t\tretractions = append(retractions, r.VersionInterval)\n+\t}\n+\n+\treturn func(v string) bool {\n+\t\tfor _, r := range retractions {\n+\t\t\tif semver.Compare(r.Low, v) <= 0 && semver.Compare(v, r.High) <= 0 {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t\treturn false\n+\t}, nil\n+}\n+\n func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \tif version != module.CanonicalVersion(version) {\n \t\treturn fmt.Errorf(\"version %s is not canonical\", version)\n@@ -897,7 +965,7 @@ func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \tsubdir = strings.Trim(subdir, \"/\")\n \n \t// Spool to local file.\n-\tf, err := ioutil.TempFile(\"\", \"go-codehost-\")\n+\tf, err := os.CreateTemp(\"\", \"go-codehost-\")\n \tif err != nil {\n \t\tdl.Close()\n \t\treturn err\n@@ -972,7 +1040,7 @@ type zipFile struct {\n }\n \n func (f zipFile) Path() string                 { return f.name }\n-func (f zipFile) Lstat() (os.FileInfo, error)  { return f.f.FileInfo(), nil }\n+func (f zipFile) Lstat() (fs.FileInfo, error)  { return f.f.FileInfo(), nil }\n func (f zipFile) Open() (io.ReadCloser, error) { return f.f.Open() }\n \n type dataFile struct {\n@@ -981,9 +1049,9 @@ type dataFile struct {\n }\n \n func (f dataFile) Path() string                { return f.name }\n-func (f dataFile) Lstat() (os.FileInfo, error) { return dataFileInfo{f}, nil }\n+func (f dataFile) Lstat() (fs.FileInfo, error) { return dataFileInfo{f}, nil }\n func (f dataFile) Open() (io.ReadCloser, error) {\n-\treturn ioutil.NopCloser(bytes.NewReader(f.data)), nil\n+\treturn io.NopCloser(bytes.NewReader(f.data)), nil\n }\n \n type dataFileInfo struct {\n@@ -992,7 +1060,7 @@ type dataFileInfo struct {\n \n func (fi dataFileInfo) Name() string       { return path.Base(fi.f.name) }\n func (fi dataFileInfo) Size() int64        { return int64(len(fi.f.data)) }\n-func (fi dataFileInfo) Mode() os.FileMode  { return 0644 }\n+func (fi dataFileInfo) Mode() fs.FileMode  { return 0644 }\n func (fi dataFileInfo) ModTime() time.Time { return time.Time{} }\n func (fi dataFileInfo) IsDir() bool        { return false }\n func (fi dataFileInfo) Sys() interface{}   { return nil }"}, {"sha": "02e399f35259597f1edc53d2ea4c6734a2b0ca67", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"hash\"\n \t\"internal/testenv\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n \t\"reflect\"\n@@ -38,7 +37,7 @@ func testMain(m *testing.M) int {\n \t// code, bypass the sum database.\n \tcfg.GOSUMDB = \"off\"\n \n-\tdir, err := ioutil.TempDir(\"\", \"gitrepo-test-\")\n+\tdir, err := os.MkdirTemp(\"\", \"gitrepo-test-\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n@@ -60,7 +59,6 @@ var altVgotests = map[string]string{\n type codeRepoTest struct {\n \tvcs         string\n \tpath        string\n-\tlookErr     string\n \tmpath       string\n \trev         string\n \terr         string\n@@ -332,9 +330,9 @@ var codeRepoTests = []codeRepoTest{\n \t\t// package in subdirectory - custom domain\n \t\t// In general we can't reject these definitively in Lookup,\n \t\t// but gopkg.in is special.\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"gopkg.in/yaml.v2/abc\",\n-\t\tlookErr: \"invalid module path \\\"gopkg.in/yaml.v2/abc\\\"\",\n+\t\tvcs:  \"git\",\n+\t\tpath: \"gopkg.in/yaml.v2/abc\",\n+\t\terr:  \"invalid module path \\\"gopkg.in/yaml.v2/abc\\\"\",\n \t},\n \t{\n \t\t// package in subdirectory - github\n@@ -425,7 +423,7 @@ var codeRepoTests = []codeRepoTest{\n func TestCodeRepo(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n-\ttmpdir, err := ioutil.TempDir(\"\", \"modfetch-test-\")\n+\ttmpdir, err := os.MkdirTemp(\"\", \"modfetch-test-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -440,16 +438,7 @@ func TestCodeRepo(t *testing.T) {\n \t\t\t\t\t\ttestenv.MustHaveExecPath(t, tt.vcs)\n \t\t\t\t\t}\n \n-\t\t\t\t\trepo, err := Lookup(\"direct\", tt.path)\n-\t\t\t\t\tif tt.lookErr != \"\" {\n-\t\t\t\t\t\tif err != nil && err.Error() == tt.lookErr {\n-\t\t\t\t\t\t\treturn\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tt.Errorf(\"Lookup(%q): %v, want error %q\", tt.path, err, tt.lookErr)\n-\t\t\t\t\t}\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n-\t\t\t\t\t}\n+\t\t\t\t\trepo := Lookup(\"direct\", tt.path)\n \n \t\t\t\t\tif tt.mpath == \"\" {\n \t\t\t\t\t\ttt.mpath = tt.path\n@@ -501,9 +490,9 @@ func TestCodeRepo(t *testing.T) {\n \n \t\t\t\t\tneedHash := !testing.Short() && (tt.zipFileHash != \"\" || tt.zipSum != \"\")\n \t\t\t\t\tif tt.zip != nil || tt.zipErr != \"\" || needHash {\n-\t\t\t\t\t\tf, err := ioutil.TempFile(tmpdir, tt.version+\".zip.\")\n+\t\t\t\t\t\tf, err := os.CreateTemp(tmpdir, tt.version+\".zip.\")\n \t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tt.Fatalf(\"ioutil.TempFile: %v\", err)\n+\t\t\t\t\t\t\tt.Fatalf(\"os.CreateTemp: %v\", err)\n \t\t\t\t\t\t}\n \t\t\t\t\t\tzipfile := f.Name()\n \t\t\t\t\t\tdefer func() {\n@@ -665,7 +654,7 @@ var codeRepoVersionsTests = []struct {\n func TestCodeRepoVersions(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n-\ttmpdir, err := ioutil.TempDir(\"\", \"vgo-modfetch-test-\")\n+\ttmpdir, err := os.MkdirTemp(\"\", \"vgo-modfetch-test-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -680,10 +669,7 @@ func TestCodeRepoVersions(t *testing.T) {\n \t\t\t\t\ttestenv.MustHaveExecPath(t, tt.vcs)\n \t\t\t\t}\n \n-\t\t\t\trepo, err := Lookup(\"direct\", tt.path)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n-\t\t\t\t}\n+\t\t\t\trepo := Lookup(\"direct\", tt.path)\n \t\t\t\tlist, err := repo.Versions(tt.prefix)\n \t\t\t\tif err != nil {\n \t\t\t\t\tt.Fatalf(\"Versions(%q): %v\", tt.prefix, err)\n@@ -742,7 +728,7 @@ var latestTests = []struct {\n func TestLatest(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n-\ttmpdir, err := ioutil.TempDir(\"\", \"vgo-modfetch-test-\")\n+\ttmpdir, err := os.MkdirTemp(\"\", \"vgo-modfetch-test-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -758,10 +744,7 @@ func TestLatest(t *testing.T) {\n \t\t\t\t\ttestenv.MustHaveExecPath(t, tt.vcs)\n \t\t\t\t}\n \n-\t\t\t\trepo, err := Lookup(\"direct\", tt.path)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n-\t\t\t\t}\n+\t\t\t\trepo := Lookup(\"direct\", tt.path)\n \t\t\t\tinfo, err := repo.Latest()\n \t\t\t\tif err != nil {\n \t\t\t\t\tif tt.err != \"\" {"}, {"sha": "debeb3f3194114ea6f81e071aebdba78c95a5e0f", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 177, "deletions": 142, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,10 +7,11 @@ package modfetch\n import (\n \t\"archive/zip\"\n \t\"bytes\"\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"sort\"\n@@ -23,6 +24,7 @@ import (\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/renameio\"\n \t\"cmd/go/internal/robustio\"\n+\t\"cmd/go/internal/trace\"\n \n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/sumdb/dirhash\"\n@@ -34,7 +36,7 @@ var downloadCache par.Cache\n // Download downloads the specific module version to the\n // local download cache and returns the name of the directory\n // corresponding to the root of the module's file tree.\n-func Download(mod module.Version) (dir string, err error) {\n+func Download(ctx context.Context, mod module.Version) (dir string, err error) {\n \tif cfg.GOMODCACHE == \"\" {\n \t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n \t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n@@ -47,7 +49,7 @@ func Download(mod module.Version) (dir string, err error) {\n \t\terr error\n \t}\n \tc := downloadCache.Do(mod, func() interface{} {\n-\t\tdir, err := download(mod)\n+\t\tdir, err := download(ctx, mod)\n \t\tif err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n@@ -57,22 +59,22 @@ func Download(mod module.Version) (dir string, err error) {\n \treturn c.dir, c.err\n }\n \n-func download(mod module.Version) (dir string, err error) {\n-\t// If the directory exists, and no .partial file exists, the module has\n-\t// already been completely extracted. .partial files may be created when a\n-\t// module zip directory is extracted in place instead of being extracted to a\n-\t// temporary directory and renamed.\n+func download(ctx context.Context, mod module.Version) (dir string, err error) {\n+\tctx, span := trace.StartSpan(ctx, \"modfetch.download \"+mod.String())\n+\tdefer span.Done()\n+\n \tdir, err = DownloadDir(mod)\n \tif err == nil {\n+\t\t// The directory has already been completely extracted (no .partial file exists).\n \t\treturn dir, nil\n-\t} else if dir == \"\" || !errors.Is(err, os.ErrNotExist) {\n+\t} else if dir == \"\" || !errors.Is(err, fs.ErrNotExist) {\n \t\treturn \"\", err\n \t}\n \n \t// To avoid cluttering the cache with extraneous files,\n \t// DownloadZip uses the same lockfile as Download.\n \t// Invoke DownloadZip before locking the file.\n-\tzipfile, err := DownloadZip(mod)\n+\tzipfile, err := DownloadZip(ctx, mod)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n@@ -83,17 +85,21 @@ func download(mod module.Version) (dir string, err error) {\n \t}\n \tdefer unlock()\n \n+\tctx, span = trace.StartSpan(ctx, \"unzip \"+zipfile)\n+\tdefer span.Done()\n+\n \t// Check whether the directory was populated while we were waiting on the lock.\n \t_, dirErr := DownloadDir(mod)\n \tif dirErr == nil {\n \t\treturn dir, nil\n \t}\n \t_, dirExists := dirErr.(*DownloadDirPartialError)\n \n-\t// Clean up any remaining temporary directories from previous runs, as well\n-\t// as partially extracted diectories created by future versions of cmd/go.\n-\t// This is only safe to do because the lock file ensures that their writers\n-\t// are no longer active.\n+\t// Clean up any remaining temporary directories created by old versions\n+\t// (before 1.16), as well as partially extracted directories (indicated by\n+\t// DownloadDirPartialError, usually because of a .partial file). This is only\n+\t// safe to do because the lock file ensures that their writers are no longer\n+\t// active.\n \tparentDir := filepath.Dir(dir)\n \ttmpPrefix := filepath.Base(dir) + \".tmp-\"\n \tif old, err := filepath.Glob(filepath.Join(parentDir, tmpPrefix+\"*\")); err == nil {\n@@ -111,91 +117,49 @@ func download(mod module.Version) (dir string, err error) {\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\tif err := os.Remove(partialPath); err != nil && !os.IsNotExist(err) {\n-\t\treturn \"\", err\n-\t}\n \n-\t// Extract the module zip directory.\n+\t// Extract the module zip directory at its final location.\n \t//\n-\t// By default, we extract to a temporary directory, then atomically rename to\n-\t// its final location. We use the existence of the source directory to signal\n-\t// that it has been extracted successfully (see DownloadDir).  If someone\n-\t// deletes the entire directory (e.g., as an attempt to prune out file\n-\t// corruption), the module cache will still be left in a recoverable\n-\t// state.\n+\t// To prevent other processes from reading the directory if we crash,\n+\t// create a .partial file before extracting the directory, and delete\n+\t// the .partial file afterward (all while holding the lock).\n \t//\n-\t// Unfortunately, os.Rename may fail with ERROR_ACCESS_DENIED on Windows if\n-\t// another process opens files in the temporary directory. This is partially\n-\t// mitigated by using robustio.Rename, which retries os.Rename for a short\n-\t// time.\n+\t// Before Go 1.16, we extracted to a temporary directory with a random name\n+\t// then renamed it into place with os.Rename. On Windows, this failed with\n+\t// ERROR_ACCESS_DENIED when another process (usually an anti-virus scanner)\n+\t// opened files in the temporary directory.\n \t//\n-\t// To avoid this error completely, if unzipInPlace is set, we instead create a\n-\t// .partial file (indicating the directory isn't fully extracted), then we\n-\t// extract the directory at its final location, then we delete the .partial\n-\t// file. This is not the default behavior because older versions of Go may\n-\t// simply stat the directory to check whether it exists without looking for a\n-\t// .partial file. If multiple versions run concurrently, the older version may\n-\t// assume a partially extracted directory is complete.\n-\t// TODO(golang.org/issue/36568): when these older versions are no longer\n-\t// supported, remove the old default behavior and the unzipInPlace flag.\n+\t// Go 1.14.2 and higher respect .partial files. Older versions may use\n+\t// partially extracted directories. 'go mod verify' can detect this,\n+\t// and 'go clean -modcache' can fix it.\n \tif err := os.MkdirAll(parentDir, 0777); err != nil {\n \t\treturn \"\", err\n \t}\n-\n-\tif unzipInPlace {\n-\t\tif err := ioutil.WriteFile(partialPath, nil, 0666); err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\tif err := modzip.Unzip(dir, mod, zipfile); err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n-\t\t\tif rmErr := RemoveAll(dir); rmErr == nil {\n-\t\t\t\tos.Remove(partialPath)\n-\t\t\t}\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\tif err := os.Remove(partialPath); err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t} else {\n-\t\ttmpDir, err := ioutil.TempDir(parentDir, tmpPrefix)\n-\t\tif err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\tif err := modzip.Unzip(tmpDir, mod, zipfile); err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n-\t\t\tRemoveAll(tmpDir)\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\tif err := robustio.Rename(tmpDir, dir); err != nil {\n-\t\t\tRemoveAll(tmpDir)\n-\t\t\treturn \"\", err\n+\tif err := os.WriteFile(partialPath, nil, 0666); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif err := modzip.Unzip(dir, mod, zipfile); err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n+\t\tif rmErr := RemoveAll(dir); rmErr == nil {\n+\t\t\tos.Remove(partialPath)\n \t\t}\n+\t\treturn \"\", err\n+\t}\n+\tif err := os.Remove(partialPath); err != nil {\n+\t\treturn \"\", err\n \t}\n \n \tif !cfg.ModCacheRW {\n-\t\t// Make dir read-only only *after* renaming it.\n-\t\t// os.Rename was observed to fail for read-only directories on macOS.\n \t\tmakeDirsReadOnly(dir)\n \t}\n \treturn dir, nil\n }\n \n-var unzipInPlace bool\n-\n-func init() {\n-\tfor _, f := range strings.Split(os.Getenv(\"GODEBUG\"), \",\") {\n-\t\tif f == \"modcacheunzipinplace=1\" {\n-\t\t\tunzipInPlace = true\n-\t\t\tbreak\n-\t\t}\n-\t}\n-}\n-\n var downloadZipCache par.Cache\n \n // DownloadZip downloads the specific module version to the\n // local zip cache and returns the name of the zip file.\n-func DownloadZip(mod module.Version) (zipfile string, err error) {\n+func DownloadZip(ctx context.Context, mod module.Version) (zipfile string, err error) {\n \t// The par.Cache here avoids duplicate work.\n \ttype cached struct {\n \t\tzipfile string\n@@ -230,15 +194,18 @@ func DownloadZip(mod module.Version) (zipfile string, err error) {\n \t\tif err := os.MkdirAll(filepath.Dir(zipfile), 0777); err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n-\t\tif err := downloadZip(mod, zipfile); err != nil {\n+\t\tif err := downloadZip(ctx, mod, zipfile); err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n \t\treturn cached{zipfile, nil}\n \t}).(cached)\n \treturn c.zipfile, c.err\n }\n \n-func downloadZip(mod module.Version, zipfile string) (err error) {\n+func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err error) {\n+\tctx, span := trace.StartSpan(ctx, \"modfetch.downloadZip \"+zipfile)\n+\tdefer span.Done()\n+\n \t// Clean up any remaining tempfiles from previous runs.\n \t// This is only safe to do because the lock file ensures that their\n \t// writers are no longer active.\n@@ -255,7 +222,7 @@ func downloadZip(mod module.Version, zipfile string) (err error) {\n \t// contents of the file (by hashing it) before we commit it. Because the file\n \t// is zip-compressed, we need an actual file \u2014 or at least an io.ReaderAt \u2014 to\n \t// validate it: we can't just tee the stream as we write it.\n-\tf, err := ioutil.TempFile(filepath.Dir(zipfile), filepath.Base(renameio.Pattern(zipfile)))\n+\tf, err := os.CreateTemp(filepath.Dir(zipfile), filepath.Base(renameio.Pattern(zipfile)))\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -266,12 +233,28 @@ func downloadZip(mod module.Version, zipfile string) (err error) {\n \t\t}\n \t}()\n \n+\tvar unrecoverableErr error\n \terr = TryProxies(func(proxy string) error {\n-\t\trepo, err := Lookup(proxy, mod.Path)\n+\t\tif unrecoverableErr != nil {\n+\t\t\treturn unrecoverableErr\n+\t\t}\n+\t\trepo := Lookup(proxy, mod.Path)\n+\t\terr := repo.Zip(f, mod.Version)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\t// Zip may have partially written to f before failing.\n+\t\t\t// (Perhaps the server crashed while sending the file?)\n+\t\t\t// Since we allow fallback on error in some cases, we need to fix up the\n+\t\t\t// file to be empty again for the next attempt.\n+\t\t\tif _, err := f.Seek(0, io.SeekStart); err != nil {\n+\t\t\t\tunrecoverableErr = err\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif err := f.Truncate(0); err != nil {\n+\t\t\t\tunrecoverableErr = err\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n-\t\treturn repo.Zip(f, mod.Version)\n+\t\treturn err\n \t})\n \tif err != nil {\n \t\treturn err\n@@ -331,12 +314,13 @@ func downloadZip(mod module.Version, zipfile string) (err error) {\n func makeDirsReadOnly(dir string) {\n \ttype pathMode struct {\n \t\tpath string\n-\t\tmode os.FileMode\n+\t\tmode fs.FileMode\n \t}\n \tvar dirs []pathMode // in lexical order\n-\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n-\t\tif err == nil && info.Mode()&0222 != 0 {\n-\t\t\tif info.IsDir() {\n+\tfilepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {\n+\t\tif err == nil && d.IsDir() {\n+\t\t\tinfo, err := d.Info()\n+\t\t\tif err == nil && info.Mode()&0222 != 0 {\n \t\t\t\tdirs = append(dirs, pathMode{path, info.Mode()})\n \t\t\t}\n \t\t}\n@@ -353,7 +337,7 @@ func makeDirsReadOnly(dir string) {\n // any permission changes needed to do so.\n func RemoveAll(dir string) error {\n \t// Module cache has 0555 directories; make them writable in order to remove content.\n-\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n+\tfilepath.WalkDir(dir, func(path string, info fs.DirEntry, err error) error {\n \t\tif err != nil {\n \t\t\treturn nil // ignore errors walking in file system\n \t\t}\n@@ -374,12 +358,14 @@ type modSum struct {\n \n var goSum struct {\n \tmu        sync.Mutex\n-\tm         map[module.Version][]string // content of go.sum file (+ go.modverify if present)\n-\tchecked   map[modSum]bool             // sums actually checked during execution\n-\tdirty     bool                        // whether we added any new sums to m\n+\tm         map[module.Version][]string // content of go.sum file\n+\tstatus    map[modSum]modSumStatus     // state of sums in m\n \toverwrite bool                        // if true, overwrite go.sum without incorporating its contents\n \tenabled   bool                        // whether to use go.sum at all\n-\tmodverify string                      // path to go.modverify, to be deleted\n+}\n+\n+type modSumStatus struct {\n+\tused, dirty bool\n }\n \n // initGoSum initializes the go.sum data.\n@@ -395,27 +381,14 @@ func initGoSum() (bool, error) {\n \t}\n \n \tgoSum.m = make(map[module.Version][]string)\n-\tgoSum.checked = make(map[modSum]bool)\n+\tgoSum.status = make(map[modSum]modSumStatus)\n \tdata, err := lockedfile.Read(GoSumFile)\n \tif err != nil && !os.IsNotExist(err) {\n \t\treturn false, err\n \t}\n \tgoSum.enabled = true\n \treadGoSum(goSum.m, GoSumFile, data)\n \n-\t// Add old go.modverify file.\n-\t// We'll delete go.modverify in WriteGoSum.\n-\talt := strings.TrimSuffix(GoSumFile, \".sum\") + \".modverify\"\n-\tif data, err := renameio.ReadFile(alt); err == nil {\n-\t\tmigrate := make(map[module.Version][]string)\n-\t\treadGoSum(migrate, alt, data)\n-\t\tfor mod, sums := range migrate {\n-\t\t\tfor _, sum := range sums {\n-\t\t\t\taddModSumLocked(mod, sum)\n-\t\t\t}\n-\t\t}\n-\t\tgoSum.modverify = alt\n-\t}\n \treturn true, nil\n }\n \n@@ -455,6 +428,28 @@ func readGoSum(dst map[module.Version][]string, file string, data []byte) error\n \treturn nil\n }\n \n+// HaveSum returns true if the go.sum file contains an entry for mod.\n+// The entry's hash must be generated with a known hash algorithm.\n+// mod.Version may have a \"/go.mod\" suffix to distinguish sums for\n+// .mod and .zip files.\n+func HaveSum(mod module.Version) bool {\n+\tgoSum.mu.Lock()\n+\tdefer goSum.mu.Unlock()\n+\tinited, err := initGoSum()\n+\tif err != nil || !inited {\n+\t\treturn false\n+\t}\n+\tfor _, h := range goSum.m[mod] {\n+\t\tif !strings.HasPrefix(h, \"h1:\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !goSum.status[modSum{mod, h}].dirty {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // checkMod checks the given module's checksum.\n func checkMod(mod module.Version) {\n \tif cfg.GOMODCACHE == \"\" {\n@@ -469,7 +464,7 @@ func checkMod(mod module.Version) {\n \t}\n \tdata, err := renameio.ReadFile(ziphash)\n \tif err != nil {\n-\t\tif errors.Is(err, os.ErrNotExist) {\n+\t\tif errors.Is(err, fs.ErrNotExist) {\n \t\t\t// This can happen if someone does rm -rf GOPATH/src/cache/download. So it goes.\n \t\t\treturn\n \t\t}\n@@ -488,7 +483,7 @@ func checkMod(mod module.Version) {\n // goModSum returns the checksum for the go.mod contents.\n func goModSum(data []byte) (string, error) {\n \treturn dirhash.Hash1([]string{\"go.mod\"}, func(string) (io.ReadCloser, error) {\n-\t\treturn ioutil.NopCloser(bytes.NewReader(data)), nil\n+\t\treturn io.NopCloser(bytes.NewReader(data)), nil\n \t})\n }\n \n@@ -504,6 +499,9 @@ func checkGoMod(path, version string, data []byte) error {\n }\n \n // checkModSum checks that the recorded checksum for mod is h.\n+//\n+// mod.Version may have the additional suffix \"/go.mod\" to request the checksum\n+// for the module's go.mod file only.\n func checkModSum(mod module.Version, h string) error {\n \t// We lock goSum when manipulating it,\n \t// but we arrange to release the lock when calling checkSumDB,\n@@ -518,6 +516,11 @@ func checkModSum(mod module.Version, h string) error {\n \t\treturn err\n \t}\n \tdone := inited && haveModSumLocked(mod, h)\n+\tif inited {\n+\t\tst := goSum.status[modSum{mod, h}]\n+\t\tst.used = true\n+\t\tgoSum.status[modSum{mod, h}] = st\n+\t}\n \tgoSum.mu.Unlock()\n \n \tif done {\n@@ -537,6 +540,9 @@ func checkModSum(mod module.Version, h string) error {\n \tif inited {\n \t\tgoSum.mu.Lock()\n \t\taddModSumLocked(mod, h)\n+\t\tst := goSum.status[modSum{mod, h}]\n+\t\tst.dirty = true\n+\t\tgoSum.status[modSum{mod, h}] = st\n \t\tgoSum.mu.Unlock()\n \t}\n \treturn nil\n@@ -546,7 +552,6 @@ func checkModSum(mod module.Version, h string) error {\n // If it finds a conflicting pair instead, it calls base.Fatalf.\n // goSum.mu must be locked.\n func haveModSumLocked(mod module.Version, h string) bool {\n-\tgoSum.checked[modSum{mod, h}] = true\n \tfor _, vh := range goSum.m[mod] {\n \t\tif h == vh {\n \t\t\treturn true\n@@ -568,15 +573,21 @@ func addModSumLocked(mod module.Version, h string) {\n \t\tfmt.Fprintf(os.Stderr, \"warning: verifying %s@%s: unknown hashes in go.sum: %v; adding %v\"+hashVersionMismatch, mod.Path, mod.Version, strings.Join(goSum.m[mod], \", \"), h)\n \t}\n \tgoSum.m[mod] = append(goSum.m[mod], h)\n-\tgoSum.dirty = true\n }\n \n // checkSumDB checks the mod, h pair against the Go checksum database.\n // It calls base.Fatalf if the hash is to be rejected.\n func checkSumDB(mod module.Version, h string) error {\n+\tmodWithoutSuffix := mod\n+\tnoun := \"module\"\n+\tif strings.HasSuffix(mod.Version, \"/go.mod\") {\n+\t\tnoun = \"go.mod\"\n+\t\tmodWithoutSuffix.Version = strings.TrimSuffix(mod.Version, \"/go.mod\")\n+\t}\n+\n \tdb, lines, err := lookupSumDB(mod)\n \tif err != nil {\n-\t\treturn module.VersionError(mod, fmt.Errorf(\"verifying module: %v\", err))\n+\t\treturn module.VersionError(modWithoutSuffix, fmt.Errorf(\"verifying %s: %v\", noun, err))\n \t}\n \n \thave := mod.Path + \" \" + mod.Version + \" \" + h\n@@ -586,7 +597,7 @@ func checkSumDB(mod module.Version, h string) error {\n \t\t\treturn nil\n \t\t}\n \t\tif strings.HasPrefix(line, prefix) {\n-\t\t\treturn module.VersionError(mod, fmt.Errorf(\"verifying module: checksum mismatch\\n\\tdownloaded: %v\\n\\t%s: %v\"+sumdbMismatch, h, db, line[len(prefix)-len(\"h1:\"):]))\n+\t\t\treturn module.VersionError(modWithoutSuffix, fmt.Errorf(\"verifying %s: checksum mismatch\\n\\tdownloaded: %v\\n\\t%s: %v\"+sumdbMismatch, noun, h, db, line[len(prefix)-len(\"h1:\"):]))\n \t\t}\n \t}\n \treturn nil\n@@ -612,18 +623,35 @@ func Sum(mod module.Version) string {\n }\n \n // WriteGoSum writes the go.sum file if it needs to be updated.\n-func WriteGoSum() {\n+//\n+// keep is used to check whether a newly added sum should be saved in go.sum.\n+// It should have entries for both module content sums and go.mod sums\n+// (version ends with \"/go.mod\"). Existing sums will be preserved unless they\n+// have been marked for deletion with TrimGoSum.\n+func WriteGoSum(keep map[module.Version]bool) {\n \tgoSum.mu.Lock()\n \tdefer goSum.mu.Unlock()\n \n+\t// If we haven't read the go.sum file yet, don't bother writing it.\n \tif !goSum.enabled {\n-\t\t// If we haven't read the go.sum file yet, don't bother writing it: at best,\n-\t\t// we could rename the go.modverify file if it isn't empty, but we haven't\n-\t\t// needed to touch it so far \u2014 how important could it be?\n \t\treturn\n \t}\n-\tif !goSum.dirty {\n-\t\t// Don't bother opening the go.sum file if we don't have anything to add.\n+\n+\t// Check whether we need to add sums for which keep[m] is true or remove\n+\t// unused sums marked with TrimGoSum. If there are no changes to make,\n+\t// just return without opening go.sum.\n+\tdirty := false\n+Outer:\n+\tfor m, hs := range goSum.m {\n+\t\tfor _, h := range hs {\n+\t\t\tst := goSum.status[modSum{m, h}]\n+\t\t\tif st.dirty && (!st.used || keep[m]) {\n+\t\t\t\tdirty = true\n+\t\t\t\tbreak Outer\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif !dirty {\n \t\treturn\n \t}\n \tif cfg.BuildMod == \"readonly\" {\n@@ -644,9 +672,10 @@ func WriteGoSum() {\n \t\t\t// them without good reason.\n \t\t\tgoSum.m = make(map[module.Version][]string, len(goSum.m))\n \t\t\treadGoSum(goSum.m, GoSumFile, data)\n-\t\t\tfor ms := range goSum.checked {\n-\t\t\t\taddModSumLocked(ms.mod, ms.sum)\n-\t\t\t\tgoSum.dirty = true\n+\t\t\tfor ms, st := range goSum.status {\n+\t\t\t\tif st.used {\n+\t\t\t\t\taddModSumLocked(ms.mod, ms.sum)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n@@ -661,7 +690,10 @@ func WriteGoSum() {\n \t\t\tlist := goSum.m[m]\n \t\t\tsort.Strings(list)\n \t\t\tfor _, h := range list {\n-\t\t\t\tfmt.Fprintf(&buf, \"%s %s %s\\n\", m.Path, m.Version, h)\n+\t\t\t\tst := goSum.status[modSum{m, h}]\n+\t\t\t\tif !st.dirty || (st.used && keep[m]) {\n+\t\t\t\t\tfmt.Fprintf(&buf, \"%s %s %s\\n\", m.Path, m.Version, h)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn buf.Bytes(), nil\n@@ -671,16 +703,16 @@ func WriteGoSum() {\n \t\tbase.Fatalf(\"go: updating go.sum: %v\", err)\n \t}\n \n-\tgoSum.checked = make(map[modSum]bool)\n-\tgoSum.dirty = false\n+\tgoSum.status = make(map[modSum]modSumStatus)\n \tgoSum.overwrite = false\n-\n-\tif goSum.modverify != \"\" {\n-\t\tos.Remove(goSum.modverify) // best effort\n-\t}\n }\n \n-// TrimGoSum trims go.sum to contain only the modules for which keep[m] is true.\n+// TrimGoSum trims go.sum to contain only the modules needed for reproducible\n+// builds.\n+//\n+// keep is used to check whether a sum should be retained in go.mod. It should\n+// have entries for both module content sums and go.mod sums (version ends\n+// with \"/go.mod\").\n func TrimGoSum(keep map[module.Version]bool) {\n \tgoSum.mu.Lock()\n \tdefer goSum.mu.Unlock()\n@@ -692,13 +724,11 @@ func TrimGoSum(keep map[module.Version]bool) {\n \t\treturn\n \t}\n \n-\tfor m := range goSum.m {\n-\t\t// If we're keeping x@v we also keep x@v/go.mod.\n-\t\t// Map x@v/go.mod back to x@v for the keep lookup.\n-\t\tnoGoMod := module.Version{Path: m.Path, Version: strings.TrimSuffix(m.Version, \"/go.mod\")}\n-\t\tif !keep[m] && !keep[noGoMod] {\n-\t\t\tdelete(goSum.m, m)\n-\t\t\tgoSum.dirty = true\n+\tfor m, hs := range goSum.m {\n+\t\tif !keep[m] {\n+\t\t\tfor _, h := range hs {\n+\t\t\t\tgoSum.status[modSum{m, h}] = modSumStatus{used: false, dirty: true}\n+\t\t\t}\n \t\t\tgoSum.overwrite = true\n \t\t}\n \t}\n@@ -818,16 +848,16 @@ the checksum database is not consulted, and all unrecognized modules are\n accepted, at the cost of giving up the security guarantee of verified repeatable\n downloads for all modules. A better way to bypass the checksum database\n for specific modules is to use the GOPRIVATE or GONOSUMDB environment\n-variables. See 'go help module-private' for details.\n+variables. See 'go help private' for details.\n \n The 'go env -w' command (see 'go help env') can be used to set these variables\n for future go command invocations.\n `,\n }\n \n-var HelpModulePrivate = &base.Command{\n-\tUsageLine: \"module-private\",\n-\tShort:     \"module configuration for non-public modules\",\n+var HelpPrivate = &base.Command{\n+\tUsageLine: \"private\",\n+\tShort:     \"configuration for downloading non-public code\",\n \tLong: `\n The go command defaults to downloading modules from the public Go module\n mirror at proxy.golang.org. It also defaults to validating downloaded modules,\n@@ -868,6 +898,11 @@ be used for downloading both public and private modules, because\n GONOPROXY has been set to a pattern that won't match any modules,\n overriding GOPRIVATE.\n \n+The GOPRIVATE variable is also used to define the \"public\" and \"private\"\n+patterns for the GOVCS variable; see 'go help vcs'. For that usage,\n+GOPRIVATE applies even in GOPATH mode. In that case, it matches import paths\n+instead of module paths.\n+\n The 'go env -w' command (see 'go help env') can be used to set these variables\n for future go command invocations.\n `,"}, {"sha": "012d05f29db55cd36060296eea832c58d7b149fc", "filename": "libgo/go/cmd/go/internal/modfetch/insecure.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,11 +6,11 @@ package modfetch\n \n import (\n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/get\"\n-\t\"cmd/go/internal/str\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n // allowInsecure reports whether we are allowed to fetch this path in an insecure manner.\n func allowInsecure(path string) bool {\n-\treturn get.Insecure || str.GlobsMatchPath(cfg.GOINSECURE, path)\n+\treturn cfg.Insecure || module.MatchPrefixPatterns(cfg.GOINSECURE, path)\n }"}, {"sha": "d75b4da52157a326283b0123abd96f89b98536ef", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -9,9 +9,8 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"io/fs\"\n \t\"net/url\"\n-\t\"os\"\n \t\"path\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n@@ -186,7 +185,7 @@ func proxyList() ([]proxySpec, error) {\n \n // TryProxies iterates f over each configured proxy (including \"noproxy\" and\n // \"direct\" if applicable) until f returns no error or until f returns an\n-// error that is not equivalent to os.ErrNotExist on a proxy configured\n+// error that is not equivalent to fs.ErrNotExist on a proxy configured\n // not to fall back on errors.\n //\n // TryProxies then returns that final error.\n@@ -222,7 +221,7 @@ func TryProxies(f func(proxy string) error) error {\n \t\tif err == nil {\n \t\t\treturn nil\n \t\t}\n-\t\tisNotExistErr := errors.Is(err, os.ErrNotExist)\n+\t\tisNotExistErr := errors.Is(err, fs.ErrNotExist)\n \n \t\tif proxy.url == \"direct\" || (proxy.url == \"noproxy\" && err != errUseProxy) {\n \t\t\tbestErr = err\n@@ -242,8 +241,9 @@ func TryProxies(f func(proxy string) error) error {\n }\n \n type proxyRepo struct {\n-\turl  *url.URL\n-\tpath string\n+\turl         *url.URL\n+\tpath        string\n+\tredactedURL string\n }\n \n func newProxyRepo(baseURL, path string) (Repo, error) {\n@@ -268,10 +268,10 @@ func newProxyRepo(baseURL, path string) (Repo, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\n+\tredactedURL := base.Redacted()\n \tbase.Path = strings.TrimSuffix(base.Path, \"/\") + \"/\" + enc\n \tbase.RawPath = strings.TrimSuffix(base.RawPath, \"/\") + \"/\" + pathEscape(enc)\n-\treturn &proxyRepo{base, path}, nil\n+\treturn &proxyRepo{base, path, redactedURL}, nil\n }\n \n func (p *proxyRepo) ModulePath() string {\n@@ -304,7 +304,7 @@ func (p *proxyRepo) getBytes(path string) ([]byte, error) {\n \t\treturn nil, err\n \t}\n \tdefer body.Close()\n-\treturn ioutil.ReadAll(body)\n+\treturn io.ReadAll(body)\n }\n \n func (p *proxyRepo) getBody(path string) (io.ReadCloser, error) {\n@@ -413,7 +413,7 @@ func (p *proxyRepo) Stat(rev string) (*RevInfo, error) {\n \t}\n \tinfo := new(RevInfo)\n \tif err := json.Unmarshal(data, info); err != nil {\n-\t\treturn nil, p.versionError(rev, err)\n+\t\treturn nil, p.versionError(rev, fmt.Errorf(\"invalid response from proxy %q: %w\", p.redactedURL, err))\n \t}\n \tif info.Version != rev && rev == module.CanonicalVersion(rev) && module.Check(p.path, rev) == nil {\n \t\t// If we request a correct, appropriate version for the module path, the\n@@ -427,14 +427,14 @@ func (p *proxyRepo) Stat(rev string) (*RevInfo, error) {\n func (p *proxyRepo) Latest() (*RevInfo, error) {\n \tdata, err := p.getBytes(\"@latest\")\n \tif err != nil {\n-\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\tif !errors.Is(err, fs.ErrNotExist) {\n \t\t\treturn nil, p.versionError(\"\", err)\n \t\t}\n \t\treturn p.latest()\n \t}\n \tinfo := new(RevInfo)\n \tif err := json.Unmarshal(data, info); err != nil {\n-\t\treturn nil, p.versionError(\"\", err)\n+\t\treturn nil, p.versionError(\"\", fmt.Errorf(\"invalid response from proxy %q: %w\", p.redactedURL, err))\n \t}\n \treturn info, nil\n }"}, {"sha": "93eb0fad961b6663dd2c21246ccfc0fe8d19dcfe", "filename": "libgo/go/cmd/go/internal/modfetch/pseudo.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -76,6 +76,12 @@ func PseudoVersion(major, older string, t time.Time, rev string) string {\n \treturn v + incDecimal(patch) + \"-0.\" + segment + build\n }\n \n+// ZeroPseudoVersion returns a pseudo-version with a zero timestamp and\n+// revision, which may be used as a placeholder.\n+func ZeroPseudoVersion(major string) string {\n+\treturn PseudoVersion(major, \"\", time.Time{}, \"000000000000\")\n+}\n+\n // incDecimal returns the decimal string incremented by 1.\n func incDecimal(decimal string) string {\n \t// Scan right to left turning 9s to 0s until you find a digit to increment.\n@@ -120,6 +126,12 @@ func IsPseudoVersion(v string) bool {\n \treturn strings.Count(v, \"-\") >= 2 && semver.IsValid(v) && pseudoVersionRE.MatchString(v)\n }\n \n+// IsZeroPseudoVersion returns whether v is a pseudo-version with a zero base,\n+// timestamp, and revision, as returned by ZeroPseudoVersion.\n+func IsZeroPseudoVersion(v string) bool {\n+\treturn v == ZeroPseudoVersion(semver.Major(v))\n+}\n+\n // PseudoVersionTime returns the time stamp of the pseudo-version v.\n // It returns an error if v is not a pseudo-version or if the time stamp\n // embedded in the pseudo-version is not a valid time."}, {"sha": "af9e24cefdc8dd3e82463280511020a53fe5e3f8", "filename": "libgo/go/cmd/go/internal/modfetch/repo.go", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -7,18 +7,19 @@ package modfetch\n import (\n \t\"fmt\"\n \t\"io\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"sort\"\n \t\"strconv\"\n \t\"time\"\n \n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/get\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/vcs\"\n \tweb \"cmd/go/internal/web\"\n \n+\t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n )\n \n@@ -32,8 +33,17 @@ type Repo interface {\n \n \t// Versions lists all known versions with the given prefix.\n \t// Pseudo-versions are not included.\n+\t//\n \t// Versions should be returned sorted in semver order\n \t// (implementations can use SortVersions).\n+\t//\n+\t// Versions returns a non-nil error only if there was a problem\n+\t// fetching the list of versions: it may return an empty list\n+\t// along with a nil error if the list of matching versions\n+\t// is known to be empty.\n+\t//\n+\t// If the underlying repository does not exist,\n+\t// Versions returns an error matching errors.Is(_, os.NotExist).\n \tVersions(prefix string) ([]string, error)\n \n \t// Stat returns information about the revision rev.\n@@ -188,27 +198,26 @@ type lookupCacheKey struct {\n //\n // A successful return does not guarantee that the module\n // has any defined versions.\n-func Lookup(proxy, path string) (Repo, error) {\n+func Lookup(proxy, path string) Repo {\n \tif traceRepo {\n \t\tdefer logCall(\"Lookup(%q, %q)\", proxy, path)()\n \t}\n \n \ttype cached struct {\n-\t\tr   Repo\n-\t\terr error\n+\t\tr Repo\n \t}\n \tc := lookupCache.Do(lookupCacheKey{proxy, path}, func() interface{} {\n-\t\tr, err := lookup(proxy, path)\n-\t\tif err == nil {\n-\t\t\tif traceRepo {\n+\t\tr := newCachingRepo(path, func() (Repo, error) {\n+\t\t\tr, err := lookup(proxy, path)\n+\t\t\tif err == nil && traceRepo {\n \t\t\t\tr = newLoggingRepo(r)\n \t\t\t}\n-\t\t\tr = newCachingRepo(r)\n-\t\t}\n-\t\treturn cached{r, err}\n+\t\t\treturn r, err\n+\t\t})\n+\t\treturn cached{r}\n \t}).(cached)\n \n-\treturn c.r, c.err\n+\treturn c.r\n }\n \n // lookup returns the module with the given module path.\n@@ -217,7 +226,7 @@ func lookup(proxy, path string) (r Repo, err error) {\n \t\treturn nil, errLookupDisabled\n \t}\n \n-\tif str.GlobsMatchPath(cfg.GONOPROXY, path) {\n+\tif module.MatchPrefixPatterns(cfg.GONOPROXY, path) {\n \t\tswitch proxy {\n \t\tcase \"noproxy\", \"direct\":\n \t\t\treturn lookupDirect(path)\n@@ -228,7 +237,7 @@ func lookup(proxy, path string) (r Repo, err error) {\n \n \tswitch proxy {\n \tcase \"off\":\n-\t\treturn nil, errProxyOff\n+\t\treturn errRepo{path, errProxyOff}, nil\n \tcase \"direct\":\n \t\treturn lookupDirect(path)\n \tcase \"noproxy\":\n@@ -261,13 +270,13 @@ func lookupDirect(path string) (Repo, error) {\n \tif allowInsecure(path) {\n \t\tsecurity = web.Insecure\n \t}\n-\trr, err := get.RepoRootForImportPath(path, get.PreferMod, security)\n+\trr, err := vcs.RepoRootForImportPath(path, vcs.PreferMod, security)\n \tif err != nil {\n \t\t// We don't know where to find code for a module with this path.\n \t\treturn nil, notExistError{err: err}\n \t}\n \n-\tif rr.VCS == \"mod\" {\n+\tif rr.VCS.Name == \"mod\" {\n \t\t// Fetch module from proxy with base URL rr.Repo.\n \t\treturn newProxyRepo(rr.Repo, path)\n \t}\n@@ -279,8 +288,8 @@ func lookupDirect(path string) (Repo, error) {\n \treturn newCodeRepo(code, rr.Root, path)\n }\n \n-func lookupCodeRepo(rr *get.RepoRoot) (codehost.Repo, error) {\n-\tcode, err := codehost.NewRepo(rr.VCS, rr.Repo)\n+func lookupCodeRepo(rr *vcs.RepoRoot) (codehost.Repo, error) {\n+\tcode, err := codehost.NewRepo(rr.VCS.Cmd, rr.Repo)\n \tif err != nil {\n \t\tif _, ok := err.(*codehost.VCSError); ok {\n \t\t\treturn nil, err\n@@ -306,7 +315,7 @@ func ImportRepoRev(path, rev string) (Repo, *RevInfo, error) {\n \tif allowInsecure(path) {\n \t\tsecurity = web.Insecure\n \t}\n-\trr, err := get.RepoRootForImportPath(path, get.IgnoreMod, security)\n+\trr, err := vcs.RepoRootForImportPath(path, vcs.IgnoreMod, security)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n@@ -407,7 +416,24 @@ func (l *loggingRepo) Zip(dst io.Writer, version string) error {\n \treturn l.r.Zip(dst, version)\n }\n \n-// A notExistError is like os.ErrNotExist, but with a custom message\n+// errRepo is a Repo that returns the same error for all operations.\n+//\n+// It is useful in conjunction with caching, since cache hits will not attempt\n+// the prohibited operations.\n+type errRepo struct {\n+\tmodulePath string\n+\terr        error\n+}\n+\n+func (r errRepo) ModulePath() string { return r.modulePath }\n+\n+func (r errRepo) Versions(prefix string) (tags []string, err error) { return nil, r.err }\n+func (r errRepo) Stat(rev string) (*RevInfo, error)                 { return nil, r.err }\n+func (r errRepo) Latest() (*RevInfo, error)                         { return nil, r.err }\n+func (r errRepo) GoMod(version string) ([]byte, error)              { return nil, r.err }\n+func (r errRepo) Zip(dst io.Writer, version string) error           { return r.err }\n+\n+// A notExistError is like fs.ErrNotExist, but with a custom message\n type notExistError struct {\n \terr error\n }\n@@ -421,7 +447,7 @@ func (e notExistError) Error() string {\n }\n \n func (notExistError) Is(target error) bool {\n-\treturn target == os.ErrNotExist\n+\treturn target == fs.ErrNotExist\n }\n \n func (e notExistError) Unwrap() error {"}, {"sha": "4fbc54d15ce837ba73fe28f65a7c85a602de47da", "filename": "libgo/go/cmd/go/internal/modfetch/sumdb.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -12,7 +12,8 @@ import (\n \t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"io\"\n+\t\"io/fs\"\n \t\"net/url\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -22,9 +23,7 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/get\"\n \t\"cmd/go/internal/lockedfile\"\n-\t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/web\"\n \n \t\"golang.org/x/mod/module\"\n@@ -34,7 +33,7 @@ import (\n \n // useSumDB reports whether to use the Go checksum database for the given module.\n func useSumDB(mod module.Version) bool {\n-\treturn cfg.GOSUMDB != \"off\" && !get.Insecure && !str.GlobsMatchPath(cfg.GONOSUMDB, mod.Path)\n+\treturn cfg.GOSUMDB != \"off\" && !cfg.Insecure && !module.MatchPrefixPatterns(cfg.GONOSUMDB, mod.Path)\n }\n \n // lookupSumDB returns the Go checksum database's go.sum lines for the given module,\n@@ -184,7 +183,7 @@ func (c *dbClient) initBase() {\n \t\t\treturn nil\n \t\t}\n \t})\n-\tif errors.Is(err, os.ErrNotExist) {\n+\tif errors.Is(err, fs.ErrNotExist) {\n \t\t// No proxies, or all proxies failed (with 404, 410, or were were allowed\n \t\t// to fall back), or we reached an explicit \"direct\" or \"off\".\n \t\tc.base = c.direct\n@@ -205,7 +204,7 @@ func (c *dbClient) ReadConfig(file string) (data []byte, err error) {\n \t}\n \ttarg := filepath.Join(cfg.SumdbDir, file)\n \tdata, err = lockedfile.Read(targ)\n-\tif errors.Is(err, os.ErrNotExist) {\n+\tif errors.Is(err, fs.ErrNotExist) {\n \t\t// Treat non-existent as empty, to bootstrap the \"latest\" file\n \t\t// the first time we connect to a given database.\n \t\treturn []byte{}, nil\n@@ -229,7 +228,7 @@ func (*dbClient) WriteConfig(file string, old, new []byte) error {\n \t\treturn err\n \t}\n \tdefer f.Close()\n-\tdata, err := ioutil.ReadAll(f)\n+\tdata, err := io.ReadAll(f)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -259,7 +258,7 @@ func (*dbClient) ReadCache(file string) ([]byte, error) {\n \t// during which the empty file can be locked for reading.\n \t// Treat observing an empty file as file not found.\n \tif err == nil && len(data) == 0 {\n-\t\terr = &os.PathError{Op: \"read\", Path: targ, Err: os.ErrNotExist}\n+\t\terr = &fs.PathError{Op: \"read\", Path: targ, Err: fs.ErrNotExist}\n \t}\n \treturn data, err\n }"}, {"sha": "d9ba8ef2dae6e62e87a8351c6043260af86bcdff", "filename": "libgo/go/cmd/go/internal/modfetch/zip_sum_test/zip_sum_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -16,14 +16,14 @@\n package zip_sum_test\n \n import (\n+\t\"context\"\n \t\"crypto/sha256\"\n \t\"encoding/csv\"\n \t\"encoding/hex\"\n \t\"flag\"\n \t\"fmt\"\n \t\"internal/testenv\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n@@ -80,7 +80,7 @@ func TestZipSums(t *testing.T) {\n \tif *modCacheDir != \"\" {\n \t\tcfg.BuildContext.GOPATH = *modCacheDir\n \t} else {\n-\t\ttmpDir, err := ioutil.TempDir(\"\", \"TestZipSums\")\n+\t\ttmpDir, err := os.MkdirTemp(\"\", \"TestZipSums\")\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n@@ -119,7 +119,7 @@ func TestZipSums(t *testing.T) {\n \t\tname := fmt.Sprintf(\"%s@%s\", strings.ReplaceAll(test.m.Path, \"/\", \"_\"), test.m.Version)\n \t\tt.Run(name, func(t *testing.T) {\n \t\t\tt.Parallel()\n-\t\t\tzipPath, err := modfetch.DownloadZip(test.m)\n+\t\t\tzipPath, err := modfetch.DownloadZip(context.Background(), test.m)\n \t\t\tif err != nil {\n \t\t\t\tif *updateTestData {\n \t\t\t\t\tt.Logf(\"%s: could not download module: %s (will remove from testdata)\", test.m, err)"}, {"sha": "8463ec4e9c7e3f4b0978ec2dcc242d6ecdd45c44", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 1373, "deletions": 686, "changes": 2059, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,25 +5,47 @@\n // Package modget implements the module-aware ``go get'' command.\n package modget\n \n+// The arguments to 'go get' are patterns with optional version queries, with\n+// the version queries defaulting to \"upgrade\".\n+//\n+// The patterns are normally interpreted as package patterns. However, if a\n+// pattern cannot match a package, it is instead interpreted as a *module*\n+// pattern. For version queries such as \"upgrade\" and \"patch\" that depend on the\n+// selected version of a module (or of the module containing a package),\n+// whether a pattern denotes a package or module may change as updates are\n+// applied (see the example in mod_get_patchmod.txt).\n+//\n+// There are a few other ambiguous cases to resolve, too. A package can exist in\n+// two different modules at the same version: for example, the package\n+// example.com/foo might be found in module example.com and also in module\n+// example.com/foo, and those modules may have independent v0.1.0 tags \u2014 so the\n+// input 'example.com/foo@v0.1.0' could syntactically refer to the variant of\n+// the package loaded from either module! (See mod_get_ambiguous_pkg.txt.)\n+// If the argument is ambiguous, the user can often disambiguate by specifying\n+// explicit versions for *all* of the potential module paths involved.\n+\n import (\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"reflect\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n \n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/get\"\n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/mvs\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/work\"\n \n+\t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n )\n@@ -69,15 +91,15 @@ downgrades the dependency. The version suffix @none indicates that the\n dependency should be removed entirely, downgrading or removing modules\n depending on it as needed.\n \n-The version suffix @latest explicitly requests the latest minor release of the\n-module named by the given path. The suffix @upgrade is like @latest but\n+The version suffix @latest explicitly requests the latest minor release of\n+the module named by the given path. The suffix @upgrade is like @latest but\n will not downgrade a module if it is already required at a revision or\n pre-release version newer than the latest released version. The suffix\n @patch requests the latest patch release: the latest released version\n with the same major and minor version numbers as the currently required\n version. Like @upgrade, @patch will not downgrade a module already required\n-at a newer version. If the path is not already required, @upgrade and @patch\n-are equivalent to @latest.\n+at a newer version. If the path is not already required, @upgrade is\n+equivalent to @latest, and @patch is disallowed.\n \n Although get defaults to using the latest version of the module containing\n a named package, it does not use the latest version of that module's\n@@ -114,14 +136,27 @@ require downgrading other dependencies, and 'go get' does\n this automatically as well.\n \n The -insecure flag permits fetching from repositories and resolving\n-custom domains using insecure schemes such as HTTP. Use with caution. The\n-GOINSECURE environment variable is usually a better alternative, since it\n-provides control over which modules may be retrieved using an insecure scheme.\n-See 'go help environment' for details.\n+custom domains using insecure schemes such as HTTP, and also bypassess\n+module sum validation using the checksum database. Use with caution.\n+This flag is deprecated and will be removed in a future version of go.\n+To permit the use of insecure schemes, use the GOINSECURE environment\n+variable instead. To bypass module sum validation, use GOPRIVATE or\n+GONOSUMDB. See 'go help environment' for details.\n \n The second step is to download (if needed), build, and install\n the named packages.\n \n+The -d flag instructs get to skip this step, downloading source code\n+needed to build the named packages and their dependencies, but not\n+building or installing.\n+\n+Building and installing packages with get is deprecated. In a future release,\n+the -d flag will be enabled by default, and 'go get' will be only be used to\n+adjust dependencies of the current module. To install a package using\n+dependencies from the current module, use 'go install'. To install a package\n+ignoring the current module, use 'go install' with an @version suffix like\n+\"@latest\" after each argument.\n+\n If an argument names a module but not a package (because there is no\n Go source code in the module's root directory), then the install step\n is skipped for that argument, instead of causing a build failure.\n@@ -133,10 +168,6 @@ the module versions. For example, 'go get golang.org/x/perf/cmd/...'\n adds the latest golang.org/x/perf and then installs the commands in that\n latest version.\n \n-The -d flag instructs get to download the source code needed to build\n-the named packages, including downloading necessary dependencies,\n-but not to build and install them.\n-\n With no package arguments, 'go get' applies to Go package in the\n current directory, if any. In particular, 'go get -u' and\n 'go get -u=patch' update all the dependencies of that package.\n@@ -173,30 +204,112 @@ Usage: ` + CmdGet.UsageLine + `\n ` + CmdGet.Long,\n }\n \n+var HelpVCS = &base.Command{\n+\tUsageLine: \"vcs\",\n+\tShort:     \"controlling version control with GOVCS\",\n+\tLong: `\n+The 'go get' command can run version control commands like git\n+to download imported code. This functionality is critical to the decentralized\n+Go package ecosystem, in which code can be imported from any server,\n+but it is also a potential security problem, if a malicious server finds a\n+way to cause the invoked version control command to run unintended code.\n+\n+To balance the functionality and security concerns, the 'go get' command\n+by default will only use git and hg to download code from public servers.\n+But it will use any known version control system (bzr, fossil, git, hg, svn)\n+to download code from private servers, defined as those hosting packages\n+matching the GOPRIVATE variable (see 'go help private'). The rationale behind\n+allowing only Git and Mercurial is that these two systems have had the most\n+attention to issues of being run as clients of untrusted servers. In contrast,\n+Bazaar, Fossil, and Subversion have primarily been used in trusted,\n+authenticated environments and are not as well scrutinized as attack surfaces.\n+\n+The version control command restrictions only apply when using direct version\n+control access to download code. When downloading modules from a proxy,\n+'go get' uses the proxy protocol instead, which is always permitted.\n+By default, the 'go get' command uses the Go module mirror (proxy.golang.org)\n+for public packages and only falls back to version control for private\n+packages or when the mirror refuses to serve a public package (typically for\n+legal reasons). Therefore, clients can still access public code served from\n+Bazaar, Fossil, or Subversion repositories by default, because those downloads\n+use the Go module mirror, which takes on the security risk of running the\n+version control commands, using a custom sandbox.\n+\n+The GOVCS variable can be used to change the allowed version control systems\n+for specific packages (identified by a module or import path).\n+The GOVCS variable applies both when using modules and when using GOPATH.\n+When using modules, the patterns match against the module path.\n+When using GOPATH, the patterns match against the import path\n+corresponding to the root of the version control repository.\n+\n+The general form of the GOVCS setting is a comma-separated list of\n+pattern:vcslist rules. The pattern is a glob pattern that must match\n+one or more leading elements of the module or import path. The vcslist\n+is a pipe-separated list of allowed version control commands, or \"all\"\n+to allow use of any known command, or \"off\" to allow nothing.\n+The earliest matching pattern in the list applies, even if later patterns\n+might also match.\n+\n+For example, consider:\n+\n+\tGOVCS=github.com:git,evil.com:off,*:git|hg\n+\n+With this setting, code with an module or import path beginning with\n+github.com/ can only use git; paths on evil.com cannot use any version\n+control command, and all other paths (* matches everything) can use\n+only git or hg.\n+\n+The special patterns \"public\" and \"private\" match public and private\n+module or import paths. A path is private if it matches the GOPRIVATE\n+variable; otherwise it is public.\n+\n+If no rules in the GOVCS variable match a particular module or import path,\n+the 'go get' command applies its default rule, which can now be summarized\n+in GOVCS notation as 'public:git|hg,private:all'.\n+\n+To allow unfettered use of any version control system for any package, use:\n+\n+\tGOVCS=*:all\n+\n+To disable all use of version control, use:\n+\n+\tGOVCS=*:off\n+\n+The 'go env -w' command (see 'go help env') can be used to set the GOVCS\n+variable for future go command invocations.\n+`,\n+}\n+\n var (\n \tgetD   = CmdGet.Flag.Bool(\"d\", false, \"\")\n \tgetF   = CmdGet.Flag.Bool(\"f\", false, \"\")\n \tgetFix = CmdGet.Flag.Bool(\"fix\", false, \"\")\n \tgetM   = CmdGet.Flag.Bool(\"m\", false, \"\")\n \tgetT   = CmdGet.Flag.Bool(\"t\", false, \"\")\n \tgetU   upgradeFlag\n-\t// -insecure is get.Insecure\n+\t// -insecure is cfg.Insecure\n \t// -v is cfg.BuildV\n )\n \n // upgradeFlag is a custom flag.Value for -u.\n-type upgradeFlag string\n+type upgradeFlag struct {\n+\trawVersion string\n+\tversion    string\n+}\n \n func (*upgradeFlag) IsBoolFlag() bool { return true } // allow -u\n \n func (v *upgradeFlag) Set(s string) error {\n \tif s == \"false\" {\n-\t\ts = \"\"\n+\t\tv.version = \"\"\n+\t\tv.rawVersion = \"\"\n+\t} else if s == \"true\" {\n+\t\tv.version = \"upgrade\"\n+\t\tv.rawVersion = \"\"\n+\t} else {\n+\t\tv.version = s\n+\t\tv.rawVersion = s\n \t}\n-\tif s == \"true\" {\n-\t\ts = \"upgrade\"\n-\t}\n-\t*v = upgradeFlag(s)\n \treturn nil\n }\n \n@@ -205,66 +318,16 @@ func (v *upgradeFlag) String() string { return \"\" }\n func init() {\n \twork.AddBuildFlags(CmdGet, work.OmitModFlag)\n \tCmdGet.Run = runGet // break init loop\n-\tCmdGet.Flag.BoolVar(&get.Insecure, \"insecure\", get.Insecure, \"\")\n+\tCmdGet.Flag.BoolVar(&cfg.Insecure, \"insecure\", cfg.Insecure, \"\")\n \tCmdGet.Flag.Var(&getU, \"u\", \"\")\n }\n \n-// A getArg holds a parsed positional argument for go get (path@vers).\n-type getArg struct {\n-\t// raw is the original argument, to be printed in error messages.\n-\traw string\n-\n-\t// path is the part of the argument before \"@\" (or the whole argument\n-\t// if there is no \"@\"). path specifies the modules or packages to get.\n-\tpath string\n-\n-\t// vers is the part of the argument after \"@\" or an implied\n-\t// \"upgrade\" or \"patch\" if there is no \"@\". vers specifies the\n-\t// module version to get.\n-\tvers string\n-}\n-\n-// querySpec describes a query for a specific module. path may be a\n-// module path, package path, or package pattern. vers is a version\n-// query string from a command line argument.\n-type querySpec struct {\n-\t// path is a module path, package path, or package pattern that\n-\t// specifies which module to query.\n-\tpath string\n-\n-\t// vers specifies what version of the module to get.\n-\tvers string\n-\n-\t// forceModulePath is true if path should be interpreted as a module path.\n-\t// If forceModulePath is true, prevM must be set.\n-\tforceModulePath bool\n-\n-\t// prevM is the previous version of the module. prevM is needed\n-\t// to determine the minor version number if vers is \"patch\". It's also\n-\t// used to avoid downgrades from prerelease versions newer than\n-\t// \"latest\" and \"patch\". If prevM is set, forceModulePath must be true.\n-\tprevM module.Version\n-}\n-\n-// query holds the state for a query made for a specific module.\n-// After a query is performed, we know the actual module path and\n-// version and whether any packages were matched by the query path.\n-type query struct {\n-\tquerySpec\n-\n-\t// arg is the command line argument that matched the specified module.\n-\targ string\n-\n-\t// m is the module path and version found by the query.\n-\tm module.Version\n-}\n-\n-func runGet(cmd *base.Command, args []string) {\n-\tswitch getU {\n+func runGet(ctx context.Context, cmd *base.Command, args []string) {\n+\tswitch getU.version {\n \tcase \"\", \"upgrade\", \"patch\":\n \t\t// ok\n \tdefault:\n-\t\tbase.Fatalf(\"go get: unknown upgrade flag -u=%s\", getU)\n+\t\tbase.Fatalf(\"go get: unknown upgrade flag -u=%s\", getU.rawVersion)\n \t}\n \tif *getF {\n \t\tfmt.Fprintf(os.Stderr, \"go get: -f flag is a no-op when using modules\\n\")\n@@ -275,770 +338,1394 @@ func runGet(cmd *base.Command, args []string) {\n \tif *getM {\n \t\tbase.Fatalf(\"go get: -m flag is no longer supported; consider -d to skip building packages\")\n \t}\n-\tmodload.LoadTests = *getT\n-\n-\tbuildList := modload.LoadBuildList()\n-\tbuildList = buildList[:len(buildList):len(buildList)] // copy on append\n-\tversionByPath := make(map[string]string)\n-\tfor _, m := range buildList {\n-\t\tversionByPath[m.Path] = m.Version\n+\tif cfg.Insecure {\n+\t\tfmt.Fprintf(os.Stderr, \"go get: -insecure flag is deprecated; see 'go help get' for details\\n\")\n \t}\n+\tload.ModResolveTests = *getT\n \n \t// Do not allow any updating of go.mod until we've applied\n \t// all the requested changes and checked that the result matches\n \t// what was requested.\n \tmodload.DisallowWriteGoMod()\n \n-\t// Allow looking up modules for import paths outside of a module.\n+\t// Allow looking up modules for import paths when outside of a module.\n \t// 'go get' is expected to do this, unlike other commands.\n \tmodload.AllowMissingModuleImports()\n \n-\t// Parse command-line arguments and report errors. The command-line\n-\t// arguments are of the form path@version or simply path, with implicit\n-\t// @upgrade. path@none is \"downgrade away\".\n-\tvar gets []getArg\n-\tvar queries []*query\n-\tfor _, arg := range search.CleanPatterns(args) {\n-\t\t// Argument is path or path@vers.\n-\t\tpath := arg\n-\t\tvers := \"\"\n-\t\tif i := strings.Index(arg, \"@\"); i >= 0 {\n-\t\t\tpath, vers = arg[:i], arg[i+1:]\n+\tmodload.LoadModFile(ctx) // Initializes modload.Target.\n+\n+\tqueries := parseArgs(ctx, args)\n+\n+\tr := newResolver(ctx, queries)\n+\tr.performLocalQueries(ctx)\n+\tr.performPathQueries(ctx)\n+\n+\tfor {\n+\t\tr.performWildcardQueries(ctx)\n+\t\tr.performPatternAllQueries(ctx)\n+\n+\t\tif changed := r.resolveCandidates(ctx, queries, nil); changed {\n+\t\t\t// 'go get' arguments can be (and often are) package patterns rather than\n+\t\t\t// (just) modules. A package can be provided by any module with a prefix\n+\t\t\t// of its import path, and a wildcard can even match packages in modules\n+\t\t\t// with totally different paths. Because of these effects, and because any\n+\t\t\t// change to the selected version of a module can bring in entirely new\n+\t\t\t// module paths as dependencies, we need to reissue queries whenever we\n+\t\t\t// change the build list.\n+\t\t\t//\n+\t\t\t// The result of any version query for a given module \u2014 even \"upgrade\" or\n+\t\t\t// \"patch\" \u2014 is always relative to the build list at the start of\n+\t\t\t// the 'go get' command, not an intermediate state, and is therefore\n+\t\t\t// dederministic and therefore cachable, and the constraints on the\n+\t\t\t// selected version of each module can only narrow as we iterate.\n+\t\t\t//\n+\t\t\t// \"all\" is functionally very similar to a wildcard pattern. The set of\n+\t\t\t// packages imported by the main module does not change, and the query\n+\t\t\t// result for the module containing each such package also does not change\n+\t\t\t// (it is always relative to the initial build list, before applying\n+\t\t\t// queries). So the only way that the result of an \"all\" query can change\n+\t\t\t// is if some matching package moves from one module in the build list\n+\t\t\t// to another, which should not happen very often.\n+\t\t\tcontinue\n \t\t}\n-\t\tif strings.Contains(vers, \"@\") || arg != path && vers == \"\" {\n-\t\t\tbase.Errorf(\"go get %s: invalid module version syntax\", arg)\n+\n+\t\t// When we load imports, we detect the following conditions:\n+\t\t//\n+\t\t// - missing transitive depencies that need to be resolved from outside the\n+\t\t//   current build list (note that these may add new matches for existing\n+\t\t//   pattern queries!)\n+\t\t//\n+\t\t// - transitive dependencies that didn't match any other query,\n+\t\t//   but need to be upgraded due to the -u flag\n+\t\t//\n+\t\t// - ambiguous import errors.\n+\t\t//   TODO(#27899): Try to resolve ambiguous import errors automatically.\n+\t\tupgrades := r.findAndUpgradeImports(ctx, queries)\n+\t\tif changed := r.resolveCandidates(ctx, nil, upgrades); changed {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr.findMissingWildcards(ctx)\n+\t\tif changed := r.resolveCandidates(ctx, r.wildcardQueries, nil); changed {\n \t\t\tcontinue\n \t\t}\n \n+\t\tbreak\n+\t}\n+\n+\tr.checkWildcardVersions(ctx)\n+\n+\tvar pkgPatterns []string\n+\tfor _, q := range queries {\n+\t\tif q.matchesPackages {\n+\t\t\tpkgPatterns = append(pkgPatterns, q.pattern)\n+\t\t}\n+\t}\n+\tr.checkPackagesAndRetractions(ctx, pkgPatterns)\n+\n+\t// We've already downloaded modules (and identified direct and indirect\n+\t// dependencies) by loading packages in findAndUpgradeImports.\n+\t// So if -d is set, we're done after the module work.\n+\t//\n+\t// Otherwise, we need to build and install the packages matched by\n+\t// command line arguments.\n+\t// Note that 'go get -u' without arguments is equivalent to\n+\t// 'go get -u .', so we'll typically build the package in the current\n+\t// directory.\n+\tif !*getD && len(pkgPatterns) > 0 {\n+\t\twork.BuildInit()\n+\t\tpkgs := load.PackagesAndErrors(ctx, pkgPatterns)\n+\t\tload.CheckPackageErrors(pkgs)\n+\t\twork.InstallPackages(ctx, pkgPatterns, pkgs)\n+\t\t// TODO(#40276): After Go 1.16, print a deprecation notice when building\n+\t\t// and installing main packages. 'go install pkg' or\n+\t\t// 'go install pkg@version' should be used instead.\n+\t\t// Give the specific argument to use if possible.\n+\t}\n+\n+\tif !modload.HasModRoot() {\n+\t\treturn\n+\t}\n+\n+\t// Everything succeeded. Update go.mod.\n+\toldReqs := reqsFromGoMod(modload.ModFile())\n+\n+\tmodload.AllowWriteGoMod()\n+\tmodload.WriteGoMod()\n+\tmodload.DisallowWriteGoMod()\n+\n+\tnewReqs := reqsFromGoMod(modload.ModFile())\n+\tr.reportChanges(oldReqs, newReqs)\n+}\n+\n+// parseArgs parses command-line arguments and reports errors.\n+//\n+// The command-line arguments are of the form path@version or simply path, with\n+// implicit @upgrade. path@none is \"downgrade away\".\n+func parseArgs(ctx context.Context, rawArgs []string) []*query {\n+\tdefer base.ExitIfErrors()\n+\n+\tvar queries []*query\n+\tfor _, arg := range search.CleanPatterns(rawArgs) {\n+\t\tq, err := newQuery(arg)\n+\t\tif err != nil {\n+\t\t\tbase.Errorf(\"go get: %v\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// If there were no arguments, CleanPatterns returns \".\". Set the raw\n+\t\t// string back to \"\" for better errors.\n+\t\tif len(rawArgs) == 0 {\n+\t\t\tq.raw = \"\"\n+\t\t}\n+\n \t\t// Guard against 'go get x.go', a common mistake.\n \t\t// Note that package and module paths may end with '.go', so only print an error\n \t\t// if the argument has no version and either has no slash or refers to an existing file.\n-\t\tif strings.HasSuffix(arg, \".go\") && vers == \"\" {\n-\t\t\tif !strings.Contains(arg, \"/\") {\n-\t\t\t\tbase.Errorf(\"go get %s: arguments must be package or module paths\", arg)\n+\t\tif strings.HasSuffix(q.raw, \".go\") && q.rawVersion == \"\" {\n+\t\t\tif !strings.Contains(q.raw, \"/\") {\n+\t\t\t\tbase.Errorf(\"go get %s: arguments must be package or module paths\", q.raw)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif fi, err := os.Stat(arg); err == nil && !fi.IsDir() {\n-\t\t\t\tbase.Errorf(\"go get: %s exists as a file, but 'go get' requires package arguments\", arg)\n+\t\t\tif fi, err := os.Stat(q.raw); err == nil && !fi.IsDir() {\n+\t\t\t\tbase.Errorf(\"go get: %s exists as a file, but 'go get' requires package arguments\", q.raw)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \n-\t\t// If no version suffix is specified, assume @upgrade.\n-\t\t// If -u=patch was specified, assume @patch instead.\n-\t\tif vers == \"\" {\n-\t\t\tif getU != \"\" {\n-\t\t\t\tvers = string(getU)\n+\t\tqueries = append(queries, q)\n+\t}\n+\n+\treturn queries\n+}\n+\n+type resolver struct {\n+\tlocalQueries      []*query // queries for absolute or relative paths\n+\tpathQueries       []*query // package path literal queries in original order\n+\twildcardQueries   []*query // path wildcard queries in original order\n+\tpatternAllQueries []*query // queries with the pattern \"all\"\n+\n+\t// Indexed \"none\" queries. These are also included in the slices above;\n+\t// they are indexed here to speed up noneForPath.\n+\tnonesByPath   map[string]*query // path-literal \"@none\" queries indexed by path\n+\twildcardNones []*query          // wildcard \"@none\" queries\n+\n+\t// resolvedVersion maps each module path to the version of that module that\n+\t// must be selected in the final build list, along with the first query\n+\t// that resolved the module to that version (the \u201creason\u201d).\n+\tresolvedVersion map[string]versionReason\n+\n+\tbuildList                 []module.Version\n+\tbuildListResolvedVersions int               // len(resolvedVersion) when buildList was computed\n+\tbuildListVersion          map[string]string // index of buildList (module path \u2192 version)\n+\n+\tinitialVersion map[string]string // index of the initial build list at the start of 'go get'\n+\n+\tmissing []pathSet // candidates for missing transitive dependencies\n+\n+\twork *par.Queue\n+\n+\tmatchInModuleCache par.Cache\n+}\n+\n+type versionReason struct {\n+\tversion string\n+\treason  *query\n+}\n+\n+func newResolver(ctx context.Context, queries []*query) *resolver {\n+\tbuildList := modload.LoadAllModules(ctx)\n+\tinitialVersion := make(map[string]string, len(buildList))\n+\tfor _, m := range buildList {\n+\t\tinitialVersion[m.Path] = m.Version\n+\t}\n+\n+\tr := &resolver{\n+\t\twork:             par.NewQueue(runtime.GOMAXPROCS(0)),\n+\t\tresolvedVersion:  map[string]versionReason{},\n+\t\tbuildList:        buildList,\n+\t\tbuildListVersion: initialVersion,\n+\t\tinitialVersion:   initialVersion,\n+\t\tnonesByPath:      map[string]*query{},\n+\t}\n+\n+\tfor _, q := range queries {\n+\t\tif q.pattern == \"all\" {\n+\t\t\tr.patternAllQueries = append(r.patternAllQueries, q)\n+\t\t} else if q.patternIsLocal {\n+\t\t\tr.localQueries = append(r.localQueries, q)\n+\t\t} else if q.isWildcard() {\n+\t\t\tr.wildcardQueries = append(r.wildcardQueries, q)\n+\t\t} else {\n+\t\t\tr.pathQueries = append(r.pathQueries, q)\n+\t\t}\n+\n+\t\tif q.version == \"none\" {\n+\t\t\t// Index \"none\" queries to make noneForPath more efficient.\n+\t\t\tif q.isWildcard() {\n+\t\t\t\tr.wildcardNones = append(r.wildcardNones, q)\n \t\t\t} else {\n-\t\t\t\tvers = \"upgrade\"\n+\t\t\t\t// All \"<path>@none\" queries for the same path are identical; we only\n+\t\t\t\t// need to index one copy.\n+\t\t\t\tr.nonesByPath[q.pattern] = q\n \t\t\t}\n \t\t}\n+\t}\n \n-\t\tgets = append(gets, getArg{raw: arg, path: path, vers: vers})\n-\n-\t\t// Determine the modules that path refers to, and create queries\n-\t\t// to lookup modules at target versions before loading packages.\n-\t\t// This is an imprecise process, but it helps reduce unnecessary\n-\t\t// queries and package loading. It's also necessary for handling\n-\t\t// patterns like golang.org/x/tools/..., which can't be expanded\n-\t\t// during package loading until they're in the build list.\n-\t\tswitch {\n-\t\tcase filepath.IsAbs(path) || search.IsRelativePath(path):\n-\t\t\t// Absolute paths like C:\\foo and relative paths like ../foo...\n-\t\t\t// are restricted to matching packages in the main module. If the path\n-\t\t\t// is explicit and contains no wildcards (...), check that it is a\n-\t\t\t// package in the main module. If the path contains wildcards but\n-\t\t\t// matches no packages, we'll warn after package loading.\n-\t\t\tif !strings.Contains(path, \"...\") {\n-\t\t\t\tm := search.NewMatch(path)\n-\t\t\t\tif pkgPath := modload.DirImportPath(path); pkgPath != \".\" {\n-\t\t\t\t\tm = modload.TargetPackages(pkgPath)\n-\t\t\t\t}\n-\t\t\t\tif len(m.Pkgs) == 0 {\n-\t\t\t\t\tfor _, err := range m.Errs {\n-\t\t\t\t\t\tbase.Errorf(\"go get %s: %v\", arg, err)\n-\t\t\t\t\t}\n+\treturn r\n+}\n \n-\t\t\t\t\tabs, err := filepath.Abs(path)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tabs = path\n-\t\t\t\t\t}\n-\t\t\t\t\tbase.Errorf(\"go get %s: path %s is not a package in module rooted at %s\", arg, abs, modload.ModRoot())\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n+// initialSelected returns the version of the module with the given path that\n+// was selected at the start of this 'go get' invocation.\n+func (r *resolver) initialSelected(mPath string) (version string) {\n+\tv, ok := r.initialVersion[mPath]\n+\tif !ok {\n+\t\treturn \"none\"\n+\t}\n+\treturn v\n+}\n \n-\t\t\tif path != arg {\n-\t\t\t\tbase.Errorf(\"go get %s: can't request explicit version of path in main module\", arg)\n-\t\t\t\tcontinue\n-\t\t\t}\n+// selected returns the version of the module with the given path that is\n+// selected in the resolver's current build list.\n+func (r *resolver) selected(mPath string) (version string) {\n+\tv, ok := r.buildListVersion[mPath]\n+\tif !ok {\n+\t\treturn \"none\"\n+\t}\n+\treturn v\n+}\n+\n+// noneForPath returns a \"none\" query matching the given module path,\n+// or found == false if no such query exists.\n+func (r *resolver) noneForPath(mPath string) (nq *query, found bool) {\n+\tif nq = r.nonesByPath[mPath]; nq != nil {\n+\t\treturn nq, true\n+\t}\n+\tfor _, nq := range r.wildcardNones {\n+\t\tif nq.matchesPath(mPath) {\n+\t\t\treturn nq, true\n+\t\t}\n+\t}\n+\treturn nil, false\n+}\n+\n+// queryModule wraps modload.Query, substituting r.checkAllowedOr to decide\n+// allowed versions.\n+func (r *resolver) queryModule(ctx context.Context, mPath, query string, selected func(string) string) (module.Version, error) {\n+\tcurrent := r.initialSelected(mPath)\n+\trev, err := modload.Query(ctx, mPath, query, current, r.checkAllowedOr(query, selected))\n+\tif err != nil {\n+\t\treturn module.Version{}, err\n+\t}\n+\treturn module.Version{Path: mPath, Version: rev.Version}, nil\n+}\n \n-\t\tcase strings.Contains(path, \"...\"):\n-\t\t\t// Wait until we load packages to look up modules.\n-\t\t\t// We don't know yet whether any modules in the build list provide\n-\t\t\t// packages matching the pattern. For example, suppose\n-\t\t\t// golang.org/x/tools and golang.org/x/tools/playground are separate\n-\t\t\t// modules, and only golang.org/x/tools is in the build list. If the\n-\t\t\t// user runs 'go get golang.org/x/tools/playground/...', we should\n-\t\t\t// add a requirement for golang.org/x/tools/playground. We should not\n-\t\t\t// upgrade golang.org/x/tools.\n-\n-\t\tcase path == \"all\":\n-\t\t\t// If there is no main module, \"all\" is not meaningful.\n-\t\t\tif !modload.HasModRoot() {\n-\t\t\t\tbase.Errorf(`go get %s: cannot match \"all\": working directory is not part of a module`, arg)\n+// queryPackage wraps modload.QueryPackage, substituting r.checkAllowedOr to\n+// decide allowed versions.\n+func (r *resolver) queryPackages(ctx context.Context, pattern, query string, selected func(string) string) (pkgMods []module.Version, err error) {\n+\tresults, err := modload.QueryPackages(ctx, pattern, query, selected, r.checkAllowedOr(query, selected))\n+\tif len(results) > 0 {\n+\t\tpkgMods = make([]module.Version, 0, len(results))\n+\t\tfor _, qr := range results {\n+\t\t\tpkgMods = append(pkgMods, qr.Mod)\n+\t\t}\n+\t}\n+\treturn pkgMods, err\n+}\n+\n+// queryPattern wraps modload.QueryPattern, substituting r.checkAllowedOr to\n+// decide allowed versions.\n+func (r *resolver) queryPattern(ctx context.Context, pattern, query string, selected func(string) string) (pkgMods []module.Version, mod module.Version, err error) {\n+\tresults, modOnly, err := modload.QueryPattern(ctx, pattern, query, selected, r.checkAllowedOr(query, selected))\n+\tif len(results) > 0 {\n+\t\tpkgMods = make([]module.Version, 0, len(results))\n+\t\tfor _, qr := range results {\n+\t\t\tpkgMods = append(pkgMods, qr.Mod)\n+\t\t}\n+\t}\n+\tif modOnly != nil {\n+\t\tmod = modOnly.Mod\n+\t}\n+\treturn pkgMods, mod, err\n+}\n+\n+// checkAllowedOr is like modload.CheckAllowed, but it always allows the requested\n+// and current versions (even if they are retracted or otherwise excluded).\n+func (r *resolver) checkAllowedOr(requested string, selected func(string) string) modload.AllowedFunc {\n+\treturn func(ctx context.Context, m module.Version) error {\n+\t\tif m.Version == requested {\n+\t\t\treturn modload.CheckExclusions(ctx, m)\n+\t\t}\n+\t\tif (requested == \"upgrade\" || requested == \"patch\") && m.Version == selected(m.Path) {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn modload.CheckAllowed(ctx, m)\n+\t}\n+}\n+\n+// matchInModule is a caching wrapper around modload.MatchInModule.\n+func (r *resolver) matchInModule(ctx context.Context, pattern string, m module.Version) (packages []string, err error) {\n+\ttype key struct {\n+\t\tpattern string\n+\t\tm       module.Version\n+\t}\n+\ttype entry struct {\n+\t\tpackages []string\n+\t\terr      error\n+\t}\n+\n+\te := r.matchInModuleCache.Do(key{pattern, m}, func() interface{} {\n+\t\tmatch := modload.MatchInModule(ctx, pattern, m, imports.AnyTags())\n+\t\tif len(match.Errs) > 0 {\n+\t\t\treturn entry{match.Pkgs, match.Errs[0]}\n+\t\t}\n+\t\treturn entry{match.Pkgs, nil}\n+\t}).(entry)\n+\n+\treturn e.packages, e.err\n+}\n+\n+// queryNone adds a candidate set to q for each module matching q.pattern.\n+// Each candidate set has only one possible module version: the matched\n+// module at version \"none\".\n+//\n+// We interpret arguments to 'go get' as packages first, and fall back to\n+// modules second. However, no module exists at version \"none\", and therefore no\n+// package exists at that version either: we know that the argument cannot match\n+// any packages, and thus it must match modules instead.\n+func (r *resolver) queryNone(ctx context.Context, q *query) {\n+\tif search.IsMetaPackage(q.pattern) {\n+\t\tpanic(fmt.Sprintf(\"internal error: queryNone called with pattern %q\", q.pattern))\n+\t}\n+\n+\tif !q.isWildcard() {\n+\t\tq.pathOnce(q.pattern, func() pathSet {\n+\t\t\tif modload.HasModRoot() && q.pattern == modload.Target.Path {\n+\t\t\t\t// The user has explicitly requested to downgrade their own module to\n+\t\t\t\t// version \"none\". This is not an entirely unreasonable request: it\n+\t\t\t\t// could plausibly mean \u201cdowngrade away everything that depends on any\n+\t\t\t\t// explicit version of the main module\u201d, or \u201cdowngrade away the\n+\t\t\t\t// package with the same path as the main module, found in a module\n+\t\t\t\t// with a prefix of the main module's path\u201d.\n+\t\t\t\t//\n+\t\t\t\t// However, neither of those behaviors would be consistent with the\n+\t\t\t\t// plain meaning of the query. To try to reduce confusion, reject the\n+\t\t\t\t// query explicitly.\n+\t\t\t\treturn errSet(&modload.QueryMatchesMainModuleError{Pattern: q.pattern, Query: q.version})\n \t\t\t}\n-\t\t\t// Don't query modules until we load packages. We'll automatically\n-\t\t\t// look up any missing modules.\n \n-\t\tcase search.IsMetaPackage(path):\n-\t\t\tbase.Errorf(\"go get %s: explicit requirement on standard-library module %s not allowed\", path, path)\n+\t\t\treturn pathSet{mod: module.Version{Path: q.pattern, Version: \"none\"}}\n+\t\t})\n+\t}\n+\n+\tfor _, curM := range r.buildList {\n+\t\tif !q.matchesPath(curM.Path) {\n \t\t\tcontinue\n+\t\t}\n+\t\tq.pathOnce(curM.Path, func() pathSet {\n+\t\t\tif modload.HasModRoot() && curM == modload.Target {\n+\t\t\t\treturn errSet(&modload.QueryMatchesMainModuleError{Pattern: q.pattern, Query: q.version})\n+\t\t\t}\n+\t\t\treturn pathSet{mod: module.Version{Path: curM.Path, Version: \"none\"}}\n+\t\t})\n+\t}\n+}\n \n-\t\tdefault:\n-\t\t\t// The argument is a package or module path.\n-\t\t\tif modload.HasModRoot() {\n-\t\t\t\tif m := modload.TargetPackages(path); len(m.Pkgs) != 0 {\n-\t\t\t\t\t// The path is in the main module. Nothing to query.\n-\t\t\t\t\tif vers != \"upgrade\" && vers != \"patch\" {\n-\t\t\t\t\t\tbase.Errorf(\"go get %s: can't request explicit version of path in main module\", arg)\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue\n+func (r *resolver) performLocalQueries(ctx context.Context) {\n+\tfor _, q := range r.localQueries {\n+\t\tq.pathOnce(q.pattern, func() pathSet {\n+\t\t\tabsDetail := \"\"\n+\t\t\tif !filepath.IsAbs(q.pattern) {\n+\t\t\t\tif absPath, err := filepath.Abs(q.pattern); err == nil {\n+\t\t\t\t\tabsDetail = fmt.Sprintf(\" (%s)\", absPath)\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tfirst := path\n-\t\t\tif i := strings.IndexByte(first, '/'); i >= 0 {\n-\t\t\t\tfirst = path\n+\t\t\t// Absolute paths like C:\\foo and relative paths like ../foo... are\n+\t\t\t// restricted to matching packages in the main module.\n+\t\t\tpkgPattern := modload.DirImportPath(q.pattern)\n+\t\t\tif pkgPattern == \".\" {\n+\t\t\t\treturn errSet(fmt.Errorf(\"%s%s is not within module rooted at %s\", q.pattern, absDetail, modload.ModRoot()))\n \t\t\t}\n-\t\t\tif !strings.Contains(first, \".\") {\n-\t\t\t\t// The path doesn't have a dot in the first component and cannot be\n-\t\t\t\t// queried as a module. It may be a package in the standard library,\n-\t\t\t\t// which is fine, so don't report an error unless we encounter\n-\t\t\t\t// a problem loading packages below.\n-\t\t\t\tcontinue\n+\n+\t\t\tmatch := modload.MatchInModule(ctx, pkgPattern, modload.Target, imports.AnyTags())\n+\t\t\tif len(match.Errs) > 0 {\n+\t\t\t\treturn pathSet{err: match.Errs[0]}\n+\t\t\t}\n+\n+\t\t\tif len(match.Pkgs) == 0 {\n+\t\t\t\tif q.raw == \"\" || q.raw == \".\" {\n+\t\t\t\t\treturn errSet(fmt.Errorf(\"no package in current directory\"))\n+\t\t\t\t}\n+\t\t\t\tif !q.isWildcard() {\n+\t\t\t\t\treturn errSet(fmt.Errorf(\"%s%s is not a package in module rooted at %s\", q.pattern, absDetail, modload.ModRoot()))\n+\t\t\t\t}\n+\t\t\t\tsearch.WarnUnmatched([]*search.Match{match})\n+\t\t\t\treturn pathSet{}\n \t\t\t}\n \n-\t\t\t// If we're querying \"upgrade\" or \"patch\", we need to know the current\n-\t\t\t// version of the module. For \"upgrade\", we want to avoid accidentally\n-\t\t\t// downgrading from a newer prerelease. For \"patch\", we need to query\n-\t\t\t// the correct minor version.\n-\t\t\t// Here, we check if \"path\" is the name of a module in the build list\n-\t\t\t// (other than the main module) and set prevM if so. If \"path\" isn't\n-\t\t\t// a module in the build list, the current version doesn't matter\n-\t\t\t// since it's either an unknown module or a package within a module\n-\t\t\t// that we'll discover later.\n-\t\t\tq := &query{querySpec: querySpec{path: path, vers: vers}, arg: arg}\n-\t\t\tif v, ok := versionByPath[path]; ok && path != modload.Target.Path {\n-\t\t\t\tq.prevM = module.Version{Path: path, Version: v}\n-\t\t\t\tq.forceModulePath = true\n+\t\t\treturn pathSet{pkgMods: []module.Version{modload.Target}}\n+\t\t})\n+\t}\n+}\n+\n+// performWildcardQueries populates the candidates for each query whose pattern\n+// is a wildcard.\n+//\n+// The candidates for a given module path matching (or containing a package\n+// matching) a wildcard query depend only on the initial build list, but the set\n+// of modules may be expanded by other queries, so wildcard queries need to be\n+// re-evaluated whenever a potentially-matching module path is added to the\n+// build list.\n+func (r *resolver) performWildcardQueries(ctx context.Context) {\n+\tfor _, q := range r.wildcardQueries {\n+\t\tq := q\n+\t\tr.work.Add(func() {\n+\t\t\tif q.version == \"none\" {\n+\t\t\t\tr.queryNone(ctx, q)\n+\t\t\t} else {\n+\t\t\t\tr.queryWildcard(ctx, q)\n \t\t\t}\n-\t\t\tqueries = append(queries, q)\n+\t\t})\n+\t}\n+\t<-r.work.Idle()\n+}\n+\n+// queryWildcard adds a candidate set to q for each module for which:\n+// \t- some version of the module is already in the build list, and\n+// \t- that module exists at some version matching q.version, and\n+// \t- either the module path itself matches q.pattern, or some package within\n+// \t  the module at q.version matches q.pattern.\n+func (r *resolver) queryWildcard(ctx context.Context, q *query) {\n+\t// For wildcard patterns, modload.QueryPattern only identifies modules\n+\t// matching the prefix of the path before the wildcard. However, the build\n+\t// list may already contain other modules with matching packages, and we\n+\t// should consider those modules to satisfy the query too.\n+\t// We want to match any packages in existing dependencies, but we only want to\n+\t// resolve new dependencies if nothing else turns up.\n+\tfor _, curM := range r.buildList {\n+\t\tif !q.canMatchInModule(curM.Path) {\n+\t\t\tcontinue\n \t\t}\n+\t\tq.pathOnce(curM.Path, func() pathSet {\n+\t\t\tif _, hit := r.noneForPath(curM.Path); hit {\n+\t\t\t\t// This module is being removed, so it will no longer be in the build list\n+\t\t\t\t// (and thus will no longer match the pattern).\n+\t\t\t\treturn pathSet{}\n+\t\t\t}\n+\n+\t\t\tif curM.Path == modload.Target.Path && !versionOkForMainModule(q.version) {\n+\t\t\t\tif q.matchesPath(curM.Path) {\n+\t\t\t\t\treturn errSet(&modload.QueryMatchesMainModuleError{\n+\t\t\t\t\t\tPattern: q.pattern,\n+\t\t\t\t\t\tQuery:   q.version,\n+\t\t\t\t\t})\n+\t\t\t\t}\n+\n+\t\t\t\tpackages, err := r.matchInModule(ctx, q.pattern, curM)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn errSet(err)\n+\t\t\t\t}\n+\t\t\t\tif len(packages) > 0 {\n+\t\t\t\t\treturn errSet(&modload.QueryMatchesPackagesInMainModuleError{\n+\t\t\t\t\t\tPattern:  q.pattern,\n+\t\t\t\t\t\tQuery:    q.version,\n+\t\t\t\t\t\tPackages: packages,\n+\t\t\t\t\t})\n+\t\t\t\t}\n+\n+\t\t\t\treturn r.tryWildcard(ctx, q, curM)\n+\t\t\t}\n+\n+\t\t\tm, err := r.queryModule(ctx, curM.Path, q.version, r.initialSelected)\n+\t\t\tif err != nil {\n+\t\t\t\tif !isNoSuchModuleVersion(err) {\n+\t\t\t\t\t// We can't tell whether a matching version exists.\n+\t\t\t\t\treturn errSet(err)\n+\t\t\t\t}\n+\t\t\t\t// There is no version of curM.Path matching the query.\n+\n+\t\t\t\t// We haven't checked whether curM contains any matching packages at its\n+\t\t\t\t// currently-selected version, or whether curM.Path itself matches q. If\n+\t\t\t\t// either of those conditions holds, *and* no other query changes the\n+\t\t\t\t// selected version of curM, then we will fail in checkWildcardVersions.\n+\t\t\t\t// (This could be an error, but it's too soon to tell.)\n+\t\t\t\t//\n+\t\t\t\t// However, even then the transitive requirements of some other query\n+\t\t\t\t// may downgrade this module out of the build list entirely, in which\n+\t\t\t\t// case the pattern will no longer include it and it won't be an error.\n+\t\t\t\t//\n+\t\t\t\t// Either way, punt on the query rather than erroring out just yet.\n+\t\t\t\treturn pathSet{}\n+\t\t\t}\n+\n+\t\t\treturn r.tryWildcard(ctx, q, m)\n+\t\t})\n \t}\n-\tbase.ExitIfErrors()\n \n-\t// Query modules referenced by command line arguments at requested versions.\n-\t// We need to do this before loading packages since patterns that refer to\n-\t// packages in unknown modules can't be expanded. This also avoids looking\n-\t// up new modules while loading packages, only to downgrade later.\n-\tqueryCache := make(map[querySpec]*query)\n-\tbyPath := runQueries(queryCache, queries, nil)\n+\t// Even if no modules matched, we shouldn't query for a new module to provide\n+\t// the pattern yet: some other query may yet induce a new requirement that\n+\t// will match the wildcard. Instead, we'll check in findMissingWildcards.\n+}\n \n-\t// Add missing modules to the build list.\n-\t// We call SetBuildList here and elsewhere, since newUpgrader,\n-\t// ImportPathsQuiet, and other functions read the global build list.\n-\tfor _, q := range queries {\n-\t\tif _, ok := versionByPath[q.m.Path]; !ok && q.m.Version != \"none\" {\n-\t\t\tbuildList = append(buildList, q.m)\n-\t\t}\n+// tryWildcard returns a pathSet for module m matching query q.\n+// If m does not actually match q, tryWildcard returns an empty pathSet.\n+func (r *resolver) tryWildcard(ctx context.Context, q *query, m module.Version) pathSet {\n+\tmMatches := q.matchesPath(m.Path)\n+\tpackages, err := r.matchInModule(ctx, q.pattern, m)\n+\tif err != nil {\n+\t\treturn errSet(err)\n \t}\n-\tversionByPath = nil // out of date now; rebuilt later when needed\n-\tmodload.SetBuildList(buildList)\n-\n-\t// Upgrade modules specifically named on the command line. This is our only\n-\t// chance to upgrade modules without root packages (modOnly below).\n-\t// This also skips loading packages at an old version, only to upgrade\n-\t// and reload at a new version.\n-\tupgrade := make(map[string]*query)\n-\tfor path, q := range byPath {\n-\t\tif q.path == q.m.Path && q.m.Version != \"none\" {\n-\t\t\tupgrade[path] = q\n-\t\t}\n+\tif len(packages) > 0 {\n+\t\treturn pathSet{pkgMods: []module.Version{m}}\n \t}\n-\tbuildList, err := mvs.UpgradeAll(modload.Target, newUpgrader(upgrade, nil))\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go get: %v\", err)\n+\tif mMatches {\n+\t\treturn pathSet{mod: m}\n \t}\n-\tmodload.SetBuildList(buildList)\n-\tbase.ExitIfErrors()\n-\tprevBuildList := buildList\n-\n-\t// Build a set of module paths that we don't plan to load packages from.\n-\t// This includes explicitly requested modules that don't have a root package\n-\t// and modules with a target version of \"none\".\n-\tvar wg sync.WaitGroup\n-\tvar modOnlyMu sync.Mutex\n-\tmodOnly := make(map[string]*query)\n-\tfor _, q := range queries {\n-\t\tif q.m.Version == \"none\" {\n-\t\t\tmodOnlyMu.Lock()\n-\t\t\tmodOnly[q.m.Path] = q\n-\t\t\tmodOnlyMu.Unlock()\n-\t\t\tcontinue\n+\treturn pathSet{}\n+}\n+\n+// findMissingWildcards adds a candidate set for each query in r.wildcardQueries\n+// that has not yet resolved to any version containing packages.\n+func (r *resolver) findMissingWildcards(ctx context.Context) {\n+\tfor _, q := range r.wildcardQueries {\n+\t\tif q.version == \"none\" || q.matchesPackages {\n+\t\t\tcontinue // q is not \u201cmissing\u201d\n \t\t}\n-\t\tif q.path == q.m.Path {\n-\t\t\twg.Add(1)\n-\t\t\tgo func(q *query) {\n-\t\t\t\tif hasPkg, err := modload.ModuleHasRootPackage(q.m); err != nil {\n-\t\t\t\t\tbase.Errorf(\"go get: %v\", err)\n-\t\t\t\t} else if !hasPkg {\n-\t\t\t\t\tmodOnlyMu.Lock()\n-\t\t\t\t\tmodOnly[q.m.Path] = q\n-\t\t\t\t\tmodOnlyMu.Unlock()\n+\t\tr.work.Add(func() {\n+\t\t\tq.pathOnce(q.pattern, func() pathSet {\n+\t\t\t\tpkgMods, mod, err := r.queryPattern(ctx, q.pattern, q.version, r.initialSelected)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tif isNoSuchPackageVersion(err) && len(q.resolved) > 0 {\n+\t\t\t\t\t\t// q already resolved one or more modules but matches no packages.\n+\t\t\t\t\t\t// That's ok: this pattern is just a module pattern, and we don't\n+\t\t\t\t\t\t// need to add any more modules to satisfy it.\n+\t\t\t\t\t\treturn pathSet{}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn errSet(err)\n \t\t\t\t}\n-\t\t\t\twg.Done()\n-\t\t\t}(q)\n-\t\t}\n-\t}\n-\twg.Wait()\n-\tbase.ExitIfErrors()\n \n-\t// Build a list of arguments that may refer to packages.\n-\tvar pkgPatterns []string\n-\tvar pkgGets []getArg\n-\tfor _, arg := range gets {\n-\t\tif modOnly[arg.path] == nil && arg.vers != \"none\" {\n-\t\t\tpkgPatterns = append(pkgPatterns, arg.path)\n-\t\t\tpkgGets = append(pkgGets, arg)\n-\t\t}\n+\t\t\t\treturn pathSet{pkgMods: pkgMods, mod: mod}\n+\t\t\t})\n+\t\t})\n \t}\n+\t<-r.work.Idle()\n+}\n \n-\t// Load packages and upgrade the modules that provide them. We do this until\n-\t// we reach a fixed point, since modules providing packages may change as we\n-\t// change versions. This must terminate because the module graph is finite,\n-\t// and the load and upgrade operations may only add and upgrade modules\n-\t// in the build list.\n-\tvar matches []*search.Match\n-\tfor {\n-\t\tvar seenPkgs map[string]bool\n-\t\tseenQuery := make(map[querySpec]bool)\n-\t\tvar queries []*query\n-\t\taddQuery := func(q *query) {\n-\t\t\tif !seenQuery[q.querySpec] {\n-\t\t\t\tseenQuery[q.querySpec] = true\n-\t\t\t\tqueries = append(queries, q)\n-\t\t\t}\n-\t\t}\n+// checkWildcardVersions reports an error if any module in the build list has a\n+// path (or contains a package) matching a query with a wildcard pattern, but\n+// has a selected version that does *not* match the query.\n+func (r *resolver) checkWildcardVersions(ctx context.Context) {\n+\tdefer base.ExitIfErrors()\n \n-\t\tif len(pkgPatterns) > 0 {\n-\t\t\t// Don't load packages if pkgPatterns is empty. Both\n-\t\t\t// modload.ImportPathsQuiet and ModulePackages convert an empty list\n-\t\t\t// of patterns to []string{\".\"}, which is not what we want.\n-\t\t\tmatches = modload.ImportPathsQuiet(pkgPatterns, imports.AnyTags())\n-\t\t\tseenPkgs = make(map[string]bool)\n-\t\t\tfor i, match := range matches {\n-\t\t\t\targ := pkgGets[i]\n-\n-\t\t\t\tif len(match.Pkgs) == 0 {\n-\t\t\t\t\t// If the pattern did not match any packages, look up a new module.\n-\t\t\t\t\t// If the pattern doesn't match anything on the last iteration,\n-\t\t\t\t\t// we'll print a warning after the outer loop.\n-\t\t\t\t\tif !match.IsLocal() && !match.IsLiteral() && arg.path != \"all\" {\n-\t\t\t\t\t\taddQuery(&query{querySpec: querySpec{path: arg.path, vers: arg.vers}, arg: arg.raw})\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tfor _, err := range match.Errs {\n-\t\t\t\t\t\t\tbase.Errorf(\"go get: %v\", err)\n-\t\t\t\t\t\t}\n+\tfor _, q := range r.wildcardQueries {\n+\t\tfor _, curM := range r.buildList {\n+\t\t\tif !q.canMatchInModule(curM.Path) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !q.matchesPath(curM.Path) {\n+\t\t\t\tpackages, err := r.matchInModule(ctx, q.pattern, curM)\n+\t\t\t\tif len(packages) == 0 {\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treportError(q, err)\n \t\t\t\t\t}\n-\t\t\t\t\tcontinue\n+\t\t\t\t\tcontinue // curM is not relevant to q.\n \t\t\t\t}\n+\t\t\t}\n \n-\t\t\t\tallStd := true\n-\t\t\t\tfor _, pkg := range match.Pkgs {\n-\t\t\t\t\tif !seenPkgs[pkg] {\n-\t\t\t\t\t\tseenPkgs[pkg] = true\n-\t\t\t\t\t\tif _, _, err := modload.Lookup(\"\", false, pkg); err != nil {\n-\t\t\t\t\t\t\tallStd = false\n-\t\t\t\t\t\t\tbase.Errorf(\"go get %s: %v\", arg.raw, err)\n-\t\t\t\t\t\t\tcontinue\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tm := modload.PackageModule(pkg)\n-\t\t\t\t\tif m.Path == \"\" {\n-\t\t\t\t\t\t// pkg is in the standard library.\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t\tallStd = false\n-\t\t\t\t\tif m.Path == modload.Target.Path {\n-\t\t\t\t\t\t// pkg is in the main module.\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t\taddQuery(&query{querySpec: querySpec{path: m.Path, vers: arg.vers, forceModulePath: true, prevM: m}, arg: arg.raw})\n+\t\t\trev, err := r.queryModule(ctx, curM.Path, q.version, r.initialSelected)\n+\t\t\tif err != nil {\n+\t\t\t\treportError(q, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif rev.Version == curM.Version {\n+\t\t\t\tcontinue // curM already matches q.\n+\t\t\t}\n+\n+\t\t\tif !q.matchesPath(curM.Path) {\n+\t\t\t\tm := module.Version{Path: curM.Path, Version: rev.Version}\n+\t\t\t\tpackages, err := r.matchInModule(ctx, q.pattern, m)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treportError(q, err)\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tif allStd && arg.path != arg.raw {\n-\t\t\t\t\tbase.Errorf(\"go get %s: cannot use pattern %q with explicit version\", arg.raw, arg.raw)\n+\t\t\t\tif len(packages) == 0 {\n+\t\t\t\t\t// curM at its original version contains a path matching q.pattern,\n+\t\t\t\t\t// but at rev.Version it does not, so (somewhat paradoxically) if\n+\t\t\t\t\t// we changed the version of curM it would no longer match the query.\n+\t\t\t\t\tvar version interface{} = m\n+\t\t\t\t\tif rev.Version != q.version {\n+\t\t\t\t\t\tversion = fmt.Sprintf(\"%s@%s (%s)\", m.Path, q.version, m.Version)\n+\t\t\t\t\t}\n+\t\t\t\t\treportError(q, fmt.Errorf(\"%v matches packages in %v but not %v: specify a different version for module %s\", q, curM, version, m.Path))\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\t// Since queryModule succeeded and either curM or one of the packages it\n+\t\t\t// contains matches q.pattern, we should have either selected the version\n+\t\t\t// of curM matching q, or reported a conflict error (and exited).\n+\t\t\t// If we're still here and the version doesn't match,\n+\t\t\t// something has gone very wrong.\n+\t\t\treportError(q, fmt.Errorf(\"internal error: selected %v instead of %v\", curM, rev.Version))\n \t\t}\n-\t\tbase.ExitIfErrors()\n+\t}\n+}\n \n-\t\t// Query target versions for modules providing packages matched by\n-\t\t// command line arguments.\n-\t\tbyPath = runQueries(queryCache, queries, modOnly)\n+// performPathQueries populates the candidates for each query whose pattern is\n+// a path literal.\n+//\n+// The candidate packages and modules for path literals depend only on the\n+// initial build list, not the current build list, so we only need to query path\n+// literals once.\n+func (r *resolver) performPathQueries(ctx context.Context) {\n+\tfor _, q := range r.pathQueries {\n+\t\tq := q\n+\t\tr.work.Add(func() {\n+\t\t\tif q.version == \"none\" {\n+\t\t\t\tr.queryNone(ctx, q)\n+\t\t\t} else {\n+\t\t\t\tr.queryPath(ctx, q)\n+\t\t\t}\n+\t\t})\n+\t}\n+\t<-r.work.Idle()\n+}\n \n-\t\t// Handle upgrades. This is needed for arguments that didn't match\n-\t\t// modules or matched different modules from a previous iteration. It\n-\t\t// also upgrades modules providing package dependencies if -u is set.\n-\t\tbuildList, err := mvs.UpgradeAll(modload.Target, newUpgrader(byPath, seenPkgs))\n-\t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go get: %v\", err)\n+// queryPath adds a candidate set to q for the package with path q.pattern.\n+// The candidate set consists of all modules that could provide q.pattern\n+// and have a version matching q, plus (if it exists) the module whose path\n+// is itself q.pattern (at a matching version).\n+func (r *resolver) queryPath(ctx context.Context, q *query) {\n+\tq.pathOnce(q.pattern, func() pathSet {\n+\t\tif search.IsMetaPackage(q.pattern) || q.isWildcard() {\n+\t\t\tpanic(fmt.Sprintf(\"internal error: queryPath called with pattern %q\", q.pattern))\n \t\t}\n-\t\tmodload.SetBuildList(buildList)\n-\t\tbase.ExitIfErrors()\n+\t\tif q.version == \"none\" {\n+\t\t\tpanic(`internal error: queryPath called with version \"none\"`)\n+\t\t}\n+\n+\t\tif search.IsStandardImportPath(q.pattern) {\n+\t\t\tstdOnly := module.Version{}\n+\t\t\tpackages, _ := r.matchInModule(ctx, q.pattern, stdOnly)\n+\t\t\tif len(packages) > 0 {\n+\t\t\t\tif q.rawVersion != \"\" {\n+\t\t\t\t\treturn errSet(fmt.Errorf(\"can't request explicit version %q of standard library package %s\", q.version, q.pattern))\n+\t\t\t\t}\n \n-\t\t// Stop if no changes have been made to the build list.\n-\t\tbuildList = modload.BuildList()\n-\t\teq := len(buildList) == len(prevBuildList)\n-\t\tfor i := 0; eq && i < len(buildList); i++ {\n-\t\t\teq = buildList[i] == prevBuildList[i]\n+\t\t\t\tq.matchesPackages = true\n+\t\t\t\treturn pathSet{} // No module needed for standard library.\n+\t\t\t}\n \t\t}\n-\t\tif eq {\n-\t\t\tbreak\n+\n+\t\tpkgMods, mod, err := r.queryPattern(ctx, q.pattern, q.version, r.initialSelected)\n+\t\tif err != nil {\n+\t\t\treturn errSet(err)\n \t\t}\n-\t\tprevBuildList = buildList\n+\t\treturn pathSet{pkgMods: pkgMods, mod: mod}\n+\t})\n+}\n+\n+// performPatternAllQueries populates the candidates for each query whose\n+// pattern is \"all\".\n+//\n+// The candidate modules for a given package in \"all\" depend only on the initial\n+// build list, but we cannot follow the dependencies of a given package until we\n+// know which candidate is selected \u2014 and that selection may depend on the\n+// results of other queries. We need to re-evaluate the \"all\" queries whenever\n+// the module for one or more packages in \"all\" are resolved.\n+func (r *resolver) performPatternAllQueries(ctx context.Context) {\n+\tif len(r.patternAllQueries) == 0 {\n+\t\treturn\n \t}\n-\tif !*getD {\n-\t\t// Only print warnings after the last iteration,\n-\t\t// and only if we aren't going to build.\n-\t\tsearch.WarnUnmatched(matches)\n+\n+\tfindPackage := func(ctx context.Context, path string, m module.Version) (versionOk bool) {\n+\t\tversionOk = true\n+\t\tfor _, q := range r.patternAllQueries {\n+\t\t\tq.pathOnce(path, func() pathSet {\n+\t\t\t\tpkgMods, err := r.queryPackages(ctx, path, q.version, r.initialSelected)\n+\t\t\t\tif len(pkgMods) != 1 || pkgMods[0] != m {\n+\t\t\t\t\t// There are candidates other than m for the given path, so we can't\n+\t\t\t\t\t// be certain that m will actually be the module selected to provide\n+\t\t\t\t\t// the package. Don't load its dependencies just yet, because they\n+\t\t\t\t\t// might no longer be dependencies after we resolve the correct\n+\t\t\t\t\t// version.\n+\t\t\t\t\tversionOk = false\n+\t\t\t\t}\n+\t\t\t\treturn pathSet{pkgMods: pkgMods, err: err}\n+\t\t\t})\n+\t\t}\n+\t\treturn versionOk\n+\t}\n+\n+\tr.loadPackages(ctx, []string{\"all\"}, findPackage)\n+\n+\t// Since we built up the candidate lists concurrently, they may be in a\n+\t// nondeterministic order. We want 'go get' to be fully deterministic,\n+\t// including in which errors it chooses to report, so sort the candidates\n+\t// into a deterministic-but-arbitrary order.\n+\tfor _, q := range r.patternAllQueries {\n+\t\tsort.Slice(q.candidates, func(i, j int) bool {\n+\t\t\treturn q.candidates[i].path < q.candidates[j].path\n+\t\t})\n \t}\n+}\n \n-\t// Handle downgrades.\n-\tvar down []module.Version\n-\tfor _, m := range modload.BuildList() {\n-\t\tq := byPath[m.Path]\n-\t\tif q != nil && semver.Compare(m.Version, q.m.Version) > 0 {\n-\t\t\tdown = append(down, module.Version{Path: m.Path, Version: q.m.Version})\n+// findAndUpgradeImports returns a pathSet for each package that is not yet\n+// in the build list but is transitively imported by the packages matching the\n+// given queries (which must already have been resolved).\n+//\n+// If the getU flag (\"-u\") is set, findAndUpgradeImports also returns a\n+// pathSet for each module that is not constrained by any other\n+// command-line argument and has an available matching upgrade.\n+func (r *resolver) findAndUpgradeImports(ctx context.Context, queries []*query) (upgrades []pathSet) {\n+\tpatterns := make([]string, 0, len(queries))\n+\tfor _, q := range queries {\n+\t\tif q.matchesPackages {\n+\t\t\tpatterns = append(patterns, q.pattern)\n \t\t}\n \t}\n-\tif len(down) > 0 {\n-\t\tbuildList, err := mvs.Downgrade(modload.Target, modload.Reqs(), down...)\n+\tif len(patterns) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\t// mu guards concurrent writes to upgrades, which will be sorted\n+\t// (to restore determinism) after loading.\n+\tvar mu sync.Mutex\n+\n+\tfindPackage := func(ctx context.Context, path string, m module.Version) (versionOk bool) {\n+\t\tversion := \"latest\"\n+\t\tif m.Path != \"\" {\n+\t\t\tif getU.version == \"\" {\n+\t\t\t\t// The user did not request that we upgrade transitive dependencies.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tif _, ok := r.resolvedVersion[m.Path]; ok {\n+\t\t\t\t// We cannot upgrade m implicitly because its version is determined by\n+\t\t\t\t// an explicit pattern argument.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tversion = getU.version\n+\t\t}\n+\n+\t\t// Unlike other queries, the \"-u\" flag upgrades relative to the build list\n+\t\t// after applying changes so far, not the initial build list.\n+\t\t// This is for two reasons:\n+\t\t//\n+\t\t// \t- The \"-u\" flag intentionally applies to transitive dependencies,\n+\t\t// \t  which may not be known or even resolved in advance of applying\n+\t\t// \t  other version changes.\n+\t\t//\n+\t\t// \t- The \"-u\" flag, unlike other arguments, does not cause version\n+\t\t// \t  conflicts with other queries. (The other query always wins.)\n+\n+\t\tpkgMods, err := r.queryPackages(ctx, path, version, r.selected)\n+\t\tfor _, u := range pkgMods {\n+\t\t\tif u == m {\n+\t\t\t\t// The selected package version is already upgraded appropriately; there\n+\t\t\t\t// is no need to change it.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t\tif isNoSuchPackageVersion(err) || (m.Path == \"\" && module.CheckPath(path) != nil) {\n+\t\t\t\t// We can't find the package because it doesn't \u2014 or can't \u2014 even exist\n+\t\t\t\t// in any module at the latest version. (Note that invalid module paths\n+\t\t\t\t// could in general exist due to replacements, so we at least need to\n+\t\t\t\t// run the query to check those.)\n+\t\t\t\t//\n+\t\t\t\t// There is no version change we can make to fix the package, so leave\n+\t\t\t\t// it unresolved. Either some other query (perhaps a wildcard matching a\n+\t\t\t\t// newly-added dependency for some other missing package) will fill in\n+\t\t\t\t// the gaps, or we will report an error (with a better import stack) in\n+\t\t\t\t// the final LoadPackages call.\n+\t\t\t\treturn true\n+\t\t\t}\n \t\t}\n-\t\tmodload.SetBuildList(buildList)\n-\t\tmodload.ReloadBuildList() // note: does not update go.mod\n-\t\tbase.ExitIfErrors()\n+\n+\t\tmu.Lock()\n+\t\tupgrades = append(upgrades, pathSet{path: path, pkgMods: pkgMods, err: err})\n+\t\tmu.Unlock()\n+\t\treturn false\n+\t}\n+\n+\tr.loadPackages(ctx, patterns, findPackage)\n+\n+\t// Since we built up the candidate lists concurrently, they may be in a\n+\t// nondeterministic order. We want 'go get' to be fully deterministic,\n+\t// including in which errors it chooses to report, so sort the candidates\n+\t// into a deterministic-but-arbitrary order.\n+\tsort.Slice(upgrades, func(i, j int) bool {\n+\t\treturn upgrades[i].path < upgrades[j].path\n+\t})\n+\treturn upgrades\n+}\n+\n+// loadPackages loads the packages matching the given patterns, invoking the\n+// findPackage function for each package that may require a change to the\n+// build list.\n+//\n+// loadPackages invokes the findPackage function for each package loaded from a\n+// module outside the main module. If the module or version that supplies that\n+// package needs to be changed due to a query, findPackage may return false\n+// and the imports of that package will not be loaded.\n+//\n+// loadPackages also invokes the findPackage function for each imported package\n+// that is neither present in the standard library nor in any module in the\n+// build list.\n+func (r *resolver) loadPackages(ctx context.Context, patterns []string, findPackage func(ctx context.Context, path string, m module.Version) (versionOk bool)) {\n+\topts := modload.PackageOpts{\n+\t\tTags:          imports.AnyTags(),\n+\t\tLoadTests:     *getT,\n+\t\tSilenceErrors: true, // May be fixed by subsequent upgrades or downgrades.\n \t}\n \n-\t// Scan for any upgrades lost by the downgrades.\n-\tvar lostUpgrades []*query\n-\tif len(down) > 0 {\n-\t\tversionByPath = make(map[string]string)\n-\t\tfor _, m := range modload.BuildList() {\n-\t\t\tversionByPath[m.Path] = m.Version\n+\topts.AllowPackage = func(ctx context.Context, path string, m module.Version) error {\n+\t\tif m.Path == \"\" || m == modload.Target {\n+\t\t\t// Packages in the standard library and main module are already at their\n+\t\t\t// latest (and only) available versions.\n+\t\t\treturn nil\n \t\t}\n-\t\tfor _, q := range byPath {\n-\t\t\tif v, ok := versionByPath[q.m.Path]; q.m.Version != \"none\" && (!ok || semver.Compare(v, q.m.Version) != 0) {\n-\t\t\t\tlostUpgrades = append(lostUpgrades, q)\n-\t\t\t}\n+\t\tif ok := findPackage(ctx, path, m); !ok {\n+\t\t\treturn errVersionChange\n \t\t}\n-\t\tsort.Slice(lostUpgrades, func(i, j int) bool {\n-\t\t\treturn lostUpgrades[i].m.Path < lostUpgrades[j].m.Path\n-\t\t})\n+\t\treturn nil\n \t}\n-\tif len(lostUpgrades) > 0 {\n-\t\tdesc := func(m module.Version) string {\n-\t\t\ts := m.Path + \"@\" + m.Version\n-\t\t\tt := byPath[m.Path]\n-\t\t\tif t != nil && t.arg != s {\n-\t\t\t\ts += \" from \" + t.arg\n-\t\t\t}\n-\t\t\treturn s\n+\n+\t_, pkgs := modload.LoadPackages(ctx, opts, patterns...)\n+\tfor _, path := range pkgs {\n+\t\tconst (\n+\t\t\tparentPath  = \"\"\n+\t\t\tparentIsStd = false\n+\t\t)\n+\t\t_, _, err := modload.Lookup(parentPath, parentIsStd, path)\n+\t\tif err == nil {\n+\t\t\tcontinue\n \t\t}\n-\t\tdownByPath := make(map[string]module.Version)\n-\t\tfor _, d := range down {\n-\t\t\tdownByPath[d.Path] = d\n+\t\tif errors.Is(err, errVersionChange) {\n+\t\t\t// We already added candidates during loading.\n+\t\t\tcontinue\n \t\t}\n \n-\t\tvar buf strings.Builder\n-\t\tfmt.Fprintf(&buf, \"go get: inconsistent versions:\")\n-\t\treqs := modload.Reqs()\n-\t\tfor _, q := range lostUpgrades {\n-\t\t\t// We lost q because its build list requires a newer version of something in down.\n-\t\t\t// Figure out exactly what.\n-\t\t\t// Repeatedly constructing the build list is inefficient\n-\t\t\t// if there are MANY command-line arguments,\n-\t\t\t// but at least all the necessary requirement lists are cached at this point.\n-\t\t\tlist, err := buildListForLostUpgrade(q.m, reqs)\n-\t\t\tif err != nil {\n-\t\t\t\tbase.Fatalf(\"go: %v\", err)\n-\t\t\t}\n+\t\tvar (\n+\t\t\timportMissing *modload.ImportMissingError\n+\t\t\tambiguous     *modload.AmbiguousImportError\n+\t\t)\n+\t\tif !errors.As(err, &importMissing) && !errors.As(err, &ambiguous) {\n+\t\t\t// The package, which is a dependency of something we care about, has some\n+\t\t\t// problem that we can't resolve with a version change.\n+\t\t\t// Leave the error for the final LoadPackages call.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tpath := path\n+\t\tr.work.Add(func() {\n+\t\t\tfindPackage(ctx, path, module.Version{})\n+\t\t})\n+\t}\n+\t<-r.work.Idle()\n+}\n \n-\t\t\tfmt.Fprintf(&buf, \"\\n\\t%s\", desc(q.m))\n-\t\t\tsep := \" requires\"\n-\t\t\tfor _, m := range list {\n-\t\t\t\tif down, ok := downByPath[m.Path]; ok && semver.Compare(down.Version, m.Version) < 0 {\n-\t\t\t\t\tfmt.Fprintf(&buf, \"%s %s@%s (not %s)\", sep, m.Path, m.Version, desc(down))\n-\t\t\t\t\tsep = \",\"\n+// errVersionChange is a sentinel error indicating that a module's version needs\n+// to be updated before its dependencies can be loaded.\n+var errVersionChange = errors.New(\"version change needed\")\n+\n+// resolveCandidates resolves candidates sets that are attached to the given\n+// queries and/or needed to provide the given missing-package dependencies.\n+//\n+// resolveCandidates starts by resolving one module version from each\n+// unambiguous pathSet attached to the given queries.\n+//\n+// If no unambiguous query results in a change to the build list,\n+// resolveCandidates modifies the build list by adding one module version from\n+// each pathSet in missing, but does not mark those versions as resolved\n+// (so they can still be modified by other queries).\n+//\n+// If that still does not result in any changes to the build list,\n+// resolveCandidates revisits the ambiguous query candidates and resolves them\n+// arbitrarily in order to guarantee forward progress.\n+//\n+// If all pathSets are resolved without any changes to the build list,\n+// resolveCandidates returns with changed=false.\n+func (r *resolver) resolveCandidates(ctx context.Context, queries []*query, upgrades []pathSet) (changed bool) {\n+\tdefer base.ExitIfErrors()\n+\n+\t// Note: this is O(N\u00b2) with the number of pathSets in the worst case.\n+\t//\n+\t// We could perhaps get it down to O(N) if we were to index the pathSets\n+\t// by module path, so that we only revisit a given pathSet when the\n+\t// version of some module in its containingPackage list has been determined.\n+\t//\n+\t// However, N tends to be small, and most candidate sets will include only one\n+\t// candidate module (so they will be resolved in the first iteration), so for\n+\t// now we'll stick to the simple O(N\u00b2) approach.\n+\n+\tresolved := 0\n+\tfor {\n+\t\tprevResolved := resolved\n+\n+\t\tfor _, q := range queries {\n+\t\t\tunresolved := q.candidates[:0]\n+\n+\t\t\tfor _, cs := range q.candidates {\n+\t\t\t\tif cs.err != nil {\n+\t\t\t\t\treportError(q, cs.err)\n+\t\t\t\t\tresolved++\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t}\n-\t\t\tif sep != \",\" {\n-\t\t\t\t// We have no idea why this happened.\n-\t\t\t\t// At least report the problem.\n-\t\t\t\tif v := versionByPath[q.m.Path]; v == \"\" {\n-\t\t\t\t\tfmt.Fprintf(&buf, \" removed unexpectedly\")\n-\t\t\t\t} else {\n-\t\t\t\t\tfmt.Fprintf(&buf, \" ended up at %s unexpectedly\", v)\n+\n+\t\t\t\tfiltered, isPackage, m, unique := r.disambiguate(cs)\n+\t\t\t\tif !unique {\n+\t\t\t\t\tunresolved = append(unresolved, filtered)\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tfmt.Fprintf(&buf, \" (please report at golang.org/issue/new)\")\n+\n+\t\t\t\tif m.Path == \"\" {\n+\t\t\t\t\t// The query is not viable. Choose an arbitrary candidate from\n+\t\t\t\t\t// before filtering and \u201cresolve\u201d it to report a conflict.\n+\t\t\t\t\tisPackage, m = r.chooseArbitrarily(cs)\n+\t\t\t\t}\n+\t\t\t\tif isPackage {\n+\t\t\t\t\tq.matchesPackages = true\n+\t\t\t\t}\n+\t\t\t\tr.resolve(q, m)\n+\t\t\t\tresolved++\n \t\t\t}\n+\n+\t\t\tq.candidates = unresolved\n \t\t}\n-\t\tbase.Fatalf(\"%v\", buf.String())\n-\t}\n \n-\t// Everything succeeded. Update go.mod.\n-\tmodload.AllowWriteGoMod()\n-\tmodload.WriteGoMod()\n+\t\tbase.ExitIfErrors()\n+\t\tif resolved == prevResolved {\n+\t\t\tbreak // No unambiguous candidate remains.\n+\t\t}\n+\t}\n \n-\t// If -d was specified, we're done after the module work.\n-\t// We've already downloaded modules by loading packages above.\n-\t// Otherwise, we need to build and install the packages matched by\n-\t// command line arguments. This may be a different set of packages,\n-\t// since we only build packages for the target platform.\n-\t// Note that 'go get -u' without arguments is equivalent to\n-\t// 'go get -u .', so we'll typically build the package in the current\n-\t// directory.\n-\tif *getD || len(pkgPatterns) == 0 {\n-\t\treturn\n+\tif changed := r.updateBuildList(ctx, nil); changed {\n+\t\t// The build list has changed, so disregard any missing packages: they might\n+\t\t// now be determined by requirements in the build list, which we would\n+\t\t// prefer to use instead of arbitrary \"latest\" versions.\n+\t\treturn true\n \t}\n-\twork.BuildInit()\n-\tpkgs := load.PackagesForBuild(pkgPatterns)\n-\twork.InstallPackages(pkgPatterns, pkgs)\n-}\n \n-// runQueries looks up modules at target versions in parallel. Results will be\n-// cached. If the same module is referenced by multiple queries at different\n-// versions (including earlier queries in the modOnly map), an error will be\n-// reported. A map from module paths to queries is returned, which includes\n-// queries and modOnly.\n-func runQueries(cache map[querySpec]*query, queries []*query, modOnly map[string]*query) map[string]*query {\n-\tvar lookup par.Work\n-\tfor _, q := range queries {\n-\t\tif cached := cache[q.querySpec]; cached != nil {\n-\t\t\t*q = *cached\n-\t\t} else {\n-\t\t\tcache[q.querySpec] = q\n-\t\t\tlookup.Add(q)\n+\t// Arbitrarily add a \"latest\" version that provides each missing package, but\n+\t// do not mark the version as resolved: we still want to allow the explicit\n+\t// queries to modify the resulting versions.\n+\tvar tentative []module.Version\n+\tfor _, cs := range upgrades {\n+\t\tif cs.err != nil {\n+\t\t\tbase.Errorf(\"go get: %v\", cs.err)\n+\t\t\tcontinue\n \t\t}\n-\t}\n \n-\tlookup.Do(10, func(item interface{}) {\n-\t\tq := item.(*query)\n-\t\tif q.vers == \"none\" {\n-\t\t\t// Wait for downgrade step.\n-\t\t\tq.m = module.Version{Path: q.path, Version: \"none\"}\n-\t\t\treturn\n+\t\tfiltered, _, m, unique := r.disambiguate(cs)\n+\t\tif !unique {\n+\t\t\t_, m = r.chooseArbitrarily(filtered)\n \t\t}\n-\t\tm, err := getQuery(q.path, q.vers, q.prevM, q.forceModulePath)\n-\t\tif err != nil {\n-\t\t\tbase.Errorf(\"go get %s: %v\", q.arg, err)\n+\t\tif m.Path == \"\" {\n+\t\t\t// There is no viable candidate for the missing package.\n+\t\t\t// Leave it unresolved.\n+\t\t\tcontinue\n \t\t}\n-\t\tq.m = m\n-\t})\n+\t\ttentative = append(tentative, m)\n+\t}\n \tbase.ExitIfErrors()\n-\n-\tbyPath := make(map[string]*query)\n-\tcheck := func(q *query) {\n-\t\tif prev, ok := byPath[q.m.Path]; prev != nil && prev.m != q.m {\n-\t\t\tbase.Errorf(\"go get: conflicting versions for module %s: %s and %s\", q.m.Path, prev.m.Version, q.m.Version)\n-\t\t\tbyPath[q.m.Path] = nil // sentinel to stop errors\n-\t\t\treturn\n-\t\t} else if !ok {\n-\t\t\tbyPath[q.m.Path] = q\n-\t\t}\n+\tif changed := r.updateBuildList(ctx, tentative); changed {\n+\t\treturn true\n \t}\n+\n+\t// The build list will be the same on the next iteration as it was on this\n+\t// iteration, so any ambiguous queries will remain so. In order to make\n+\t// progress, resolve them arbitrarily but deterministically.\n+\t//\n+\t// If that results in conflicting versions, the user can re-run 'go get'\n+\t// with additional explicit versions for the conflicting packages or\n+\t// modules.\n \tfor _, q := range queries {\n-\t\tcheck(q)\n+\t\tfor _, cs := range q.candidates {\n+\t\t\tisPackage, m := r.chooseArbitrarily(cs)\n+\t\t\tif isPackage {\n+\t\t\t\tq.matchesPackages = true\n+\t\t\t}\n+\t\t\tr.resolve(q, m)\n+\t\t}\n \t}\n-\tfor _, q := range modOnly {\n-\t\tcheck(q)\n+\treturn r.updateBuildList(ctx, nil)\n+}\n+\n+// disambiguate eliminates candidates from cs that conflict with other module\n+// versions that have already been resolved. If there is only one (unique)\n+// remaining candidate, disambiguate returns that candidate, along with\n+// an indication of whether that result interprets cs.path as a package\n+//\n+// Note: we're only doing very simple disambiguation here. The goal is to\n+// reproduce the user's intent, not to find a solution that a human couldn't.\n+// In the vast majority of cases, we expect only one module per pathSet,\n+// but we want to give some minimal additional tools so that users can add an\n+// extra argument or two on the command line to resolve simple ambiguities.\n+func (r *resolver) disambiguate(cs pathSet) (filtered pathSet, isPackage bool, m module.Version, unique bool) {\n+\tif len(cs.pkgMods) == 0 && cs.mod.Path == \"\" {\n+\t\tpanic(\"internal error: resolveIfUnambiguous called with empty pathSet\")\n \t}\n-\tbase.ExitIfErrors()\n \n-\treturn byPath\n-}\n+\tfor _, m := range cs.pkgMods {\n+\t\tif _, ok := r.noneForPath(m.Path); ok {\n+\t\t\t// A query with version \"none\" forces the candidate module to version\n+\t\t\t// \"none\", so we cannot use any other version for that module.\n+\t\t\tcontinue\n+\t\t}\n \n-// getQuery evaluates the given (package or module) path and version\n-// to determine the underlying module version being requested.\n-// If forceModulePath is set, getQuery must interpret path\n-// as a module path.\n-func getQuery(path, vers string, prevM module.Version, forceModulePath bool) (module.Version, error) {\n-\tif (prevM.Version != \"\") != forceModulePath {\n-\t\t// We resolve package patterns by calling QueryPattern, which does not\n-\t\t// accept a previous version and therefore cannot take it into account for\n-\t\t// the \"latest\" or \"patch\" queries.\n-\t\t// If we are resolving a package path or pattern, the caller has already\n-\t\t// resolved any existing packages to their containing module(s), and\n-\t\t// will set both prevM.Version and forceModulePath for those modules.\n-\t\t// The only remaining package patterns are those that are not already\n-\t\t// provided by the build list, which are indicated by\n-\t\t// an empty prevM.Version.\n-\t\tbase.Fatalf(\"go get: internal error: prevM may be set if and only if forceModulePath is set\")\n-\t}\n-\n-\t// If the query must be a module path, try only that module path.\n-\tif forceModulePath {\n-\t\tif path == modload.Target.Path {\n-\t\t\tif vers != \"latest\" {\n-\t\t\t\treturn module.Version{}, fmt.Errorf(\"can't get a specific version of the main module\")\n+\t\tif m.Path == modload.Target.Path {\n+\t\t\tif m.Version == modload.Target.Version {\n+\t\t\t\treturn pathSet{}, true, m, true\n \t\t\t}\n+\t\t\t// The main module can only be set to its own version.\n+\t\t\tcontinue\n \t\t}\n \n-\t\tinfo, err := modload.Query(path, vers, prevM.Version, modload.Allowed)\n-\t\tif err == nil {\n-\t\t\tif info.Version != vers && info.Version != prevM.Version {\n-\t\t\t\tlogOncef(\"go: %s %s => %s\", path, vers, info.Version)\n-\t\t\t}\n-\t\t\treturn module.Version{Path: path, Version: info.Version}, nil\n+\t\tvr, ok := r.resolvedVersion[m.Path]\n+\t\tif !ok {\n+\t\t\t// m is a viable answer to the query, but other answers may also\n+\t\t\t// still be viable.\n+\t\t\tfiltered.pkgMods = append(filtered.pkgMods, m)\n+\t\t\tcontinue\n \t\t}\n \n-\t\t// If the query was \"upgrade\" or \"patch\" and the current version has been\n-\t\t// replaced, check to see whether the error was for that same version:\n-\t\t// if so, the version was probably replaced because it is invalid,\n-\t\t// and we should keep that replacement without complaining.\n-\t\tif vers == \"upgrade\" || vers == \"patch\" {\n-\t\t\tvar vErr *module.InvalidVersionError\n-\t\t\tif errors.As(err, &vErr) && vErr.Version == prevM.Version && modload.Replacement(prevM).Path != \"\" {\n-\t\t\t\treturn prevM, nil\n-\t\t\t}\n+\t\tif vr.version != m.Version {\n+\t\t\t// Some query forces the candidate module to a version other than this\n+\t\t\t// one.\n+\t\t\t//\n+\t\t\t// The command could be something like\n+\t\t\t//\n+\t\t\t// \tgo get example.com/foo/bar@none example.com/foo/bar/baz@latest\n+\t\t\t//\n+\t\t\t// in which case we *cannot* resolve the package from\n+\t\t\t// example.com/foo/bar (because it is constrained to version\n+\t\t\t// \"none\") and must fall through to module example.com/foo@latest.\n+\t\t\tcontinue\n \t\t}\n \n-\t\treturn module.Version{}, err\n+\t\t// Some query forces the candidate module *to* the candidate version.\n+\t\t// As a result, this candidate is the only viable choice to provide\n+\t\t// its package(s): any other choice would result in an ambiguous import\n+\t\t// for this path.\n+\t\t//\n+\t\t// For example, consider the command\n+\t\t//\n+\t\t// \tgo get example.com/foo@latest example.com/foo/bar/baz@latest\n+\t\t//\n+\t\t// If modules example.com/foo and example.com/foo/bar both provide\n+\t\t// package example.com/foo/bar/baz, then we *must* resolve the package\n+\t\t// from example.com/foo: if we instead resolved it from\n+\t\t// example.com/foo/bar, we would have two copies of the package.\n+\t\treturn pathSet{}, true, m, true\n \t}\n \n-\t// If the query may be either a package or a module, try it as a package path.\n-\t// If it turns out to only exist as a module, we can detect the resulting\n-\t// PackageNotInModuleError and avoid a second round-trip through (potentially)\n-\t// all of the configured proxies.\n-\tresults, err := modload.QueryPattern(path, vers, modload.Allowed)\n-\tif err != nil {\n-\t\t// If the path doesn't contain a wildcard, check whether it was actually a\n-\t\t// module path instead. If so, return that.\n-\t\tif !strings.Contains(path, \"...\") {\n-\t\t\tvar modErr *modload.PackageNotInModuleError\n-\t\t\tif errors.As(err, &modErr) && modErr.Mod.Path == path {\n-\t\t\t\tif modErr.Mod.Version != vers {\n-\t\t\t\t\tlogOncef(\"go: %s %s => %s\", path, vers, modErr.Mod.Version)\n-\t\t\t\t}\n-\t\t\t\treturn modErr.Mod, nil\n-\t\t\t}\n+\tif cs.mod.Path != \"\" {\n+\t\tvr, ok := r.resolvedVersion[cs.mod.Path]\n+\t\tif !ok || vr.version == cs.mod.Version {\n+\t\t\tfiltered.mod = cs.mod\n \t\t}\n+\t}\n \n-\t\treturn module.Version{}, err\n+\tif len(filtered.pkgMods) == 1 &&\n+\t\t(filtered.mod.Path == \"\" || filtered.mod == filtered.pkgMods[0]) {\n+\t\t// Exactly one viable module contains the package with the given path\n+\t\t// (by far the common case), so we can resolve it unambiguously.\n+\t\treturn pathSet{}, true, filtered.pkgMods[0], true\n \t}\n \n-\tm := results[0].Mod\n-\tif m.Path != path {\n-\t\tlogOncef(\"go: found %s in %s %s\", path, m.Path, m.Version)\n-\t} else if m.Version != vers {\n-\t\tlogOncef(\"go: %s %s => %s\", path, vers, m.Version)\n+\tif len(filtered.pkgMods) == 0 {\n+\t\t// All modules that could provide the path as a package conflict with other\n+\t\t// resolved arguments. If it can refer to a module instead, return that;\n+\t\t// otherwise, this pathSet cannot be resolved (and we will return the\n+\t\t// zero module.Version).\n+\t\treturn pathSet{}, false, filtered.mod, true\n \t}\n-\treturn m, nil\n+\n+\t// The query remains ambiguous: there are at least two different modules\n+\t// to which cs.path could refer.\n+\treturn filtered, false, module.Version{}, false\n }\n \n-// An upgrader adapts an underlying mvs.Reqs to apply an\n-// upgrade policy to a list of targets and their dependencies.\n-type upgrader struct {\n-\tmvs.Reqs\n+// chooseArbitrarily returns an arbitrary (but deterministic) module version\n+// from among those in the given set.\n+//\n+// chooseArbitrarily prefers module paths that were already in the build list at\n+// the start of 'go get', prefers modules that provide packages over those that\n+// do not, and chooses the first module meeting those criteria (so biases toward\n+// longer paths).\n+func (r *resolver) chooseArbitrarily(cs pathSet) (isPackage bool, m module.Version) {\n+\t// Prefer to upgrade some module that was already in the build list.\n+\tfor _, m := range cs.pkgMods {\n+\t\tif r.initialSelected(m.Path) != \"none\" {\n+\t\t\treturn true, m\n+\t\t}\n+\t}\n \n-\t// cmdline maps a module path to a query made for that module at a\n-\t// specific target version. Each query corresponds to a module\n-\t// matched by a command line argument.\n-\tcmdline map[string]*query\n+\t// Otherwise, arbitrarily choose the first module that provides the package.\n+\tif len(cs.pkgMods) > 0 {\n+\t\treturn true, cs.pkgMods[0]\n+\t}\n \n-\t// upgrade is a set of modules providing dependencies of packages\n-\t// matched by command line arguments. If -u or -u=patch is set,\n-\t// these modules are upgraded accordingly.\n-\tupgrade map[string]bool\n+\treturn false, cs.mod\n }\n \n-// newUpgrader creates an upgrader. cmdline contains queries made at\n-// specific versions for modules matched by command line arguments. pkgs\n-// is the set of packages matched by command line arguments. If -u or -u=patch\n-// is set, modules providing dependencies of pkgs are upgraded accordingly.\n-func newUpgrader(cmdline map[string]*query, pkgs map[string]bool) *upgrader {\n-\tu := &upgrader{\n-\t\tReqs:    modload.Reqs(),\n-\t\tcmdline: cmdline,\n-\t}\n-\tif getU != \"\" {\n-\t\tu.upgrade = make(map[string]bool)\n-\n-\t\t// Traverse package import graph.\n-\t\t// Initialize work queue with root packages.\n-\t\tseen := make(map[string]bool)\n-\t\tvar work []string\n-\t\tadd := func(path string) {\n-\t\t\tif !seen[path] {\n-\t\t\t\tseen[path] = true\n-\t\t\t\twork = append(work, path)\n-\t\t\t}\n+// checkPackagesAndRetractions reloads packages for the given patterns and\n+// reports missing and ambiguous package errors. It also reports loads and\n+// reports retractions for resolved modules and modules needed to build\n+// named packages.\n+//\n+// We skip missing-package errors earlier in the process, since we want to\n+// resolve pathSets ourselves, but at that point, we don't have enough context\n+// to log the package-import chains leading to each error.\n+func (r *resolver) checkPackagesAndRetractions(ctx context.Context, pkgPatterns []string) {\n+\tdefer base.ExitIfErrors()\n+\n+\t// Build a list of modules to load retractions for. Start with versions\n+\t// selected based on command line queries.\n+\t//\n+\t// This is a subset of the build list. If the main module has a lot of\n+\t// dependencies, loading retractions for the entire build list would be slow.\n+\trelevantMods := make(map[module.Version]struct{})\n+\tfor path, reason := range r.resolvedVersion {\n+\t\trelevantMods[module.Version{Path: path, Version: reason.version}] = struct{}{}\n+\t}\n+\n+\t// Reload packages, reporting errors for missing and ambiguous imports.\n+\tif len(pkgPatterns) > 0 {\n+\t\t// LoadPackages will print errors (since it has more context) but will not\n+\t\t// exit, since we need to load retractions later.\n+\t\tpkgOpts := modload.PackageOpts{\n+\t\t\tLoadTests:             *getT,\n+\t\t\tResolveMissingImports: false,\n+\t\t\tAllowErrors:           true,\n \t\t}\n-\t\tfor pkg := range pkgs {\n-\t\t\tadd(pkg)\n+\t\tmatches, pkgs := modload.LoadPackages(ctx, pkgOpts, pkgPatterns...)\n+\t\tfor _, m := range matches {\n+\t\t\tif len(m.Errs) > 0 {\n+\t\t\t\tbase.SetExitStatus(1)\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t}\n-\t\tfor len(work) > 0 {\n-\t\t\tpkg := work[0]\n-\t\t\twork = work[1:]\n-\t\t\tm := modload.PackageModule(pkg)\n-\t\t\tu.upgrade[m.Path] = true\n-\n-\t\t\t// testImports is empty unless test imports were actually loaded,\n-\t\t\t// i.e., -t was set or \"all\" was one of the arguments.\n-\t\t\timports, testImports := modload.PackageImports(pkg)\n-\t\t\tfor _, imp := range imports {\n-\t\t\t\tadd(imp)\n+\t\tfor _, pkg := range pkgs {\n+\t\t\tif _, _, err := modload.Lookup(\"\", false, pkg); err != nil {\n+\t\t\t\tbase.SetExitStatus(1)\n+\t\t\t\tif ambiguousErr := (*modload.AmbiguousImportError)(nil); errors.As(err, &ambiguousErr) {\n+\t\t\t\t\tfor _, m := range ambiguousErr.Modules {\n+\t\t\t\t\t\trelevantMods[m] = struct{}{}\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tfor _, imp := range testImports {\n-\t\t\t\tadd(imp)\n+\t\t\tif m := modload.PackageModule(pkg); m.Path != \"\" {\n+\t\t\t\trelevantMods[m] = struct{}{}\n \t\t\t}\n \t\t}\n \t}\n-\treturn u\n-}\n \n-// Required returns the requirement list for m.\n-// For the main module, we override requirements with the modules named\n-// one the command line, and we include new requirements. Otherwise,\n-// we defer to u.Reqs.\n-func (u *upgrader) Required(m module.Version) ([]module.Version, error) {\n-\trs, err := u.Reqs.Required(m)\n-\tif err != nil {\n-\t\treturn nil, err\n+\t// Load and report retractions.\n+\ttype retraction struct {\n+\t\tm   module.Version\n+\t\terr error\n \t}\n-\tif m != modload.Target {\n-\t\treturn rs, nil\n+\tretractions := make([]retraction, 0, len(relevantMods))\n+\tfor m := range relevantMods {\n+\t\tretractions = append(retractions, retraction{m: m})\n \t}\n-\n-\toverridden := make(map[string]bool)\n-\tfor i, m := range rs {\n-\t\tif q := u.cmdline[m.Path]; q != nil && q.m.Version != \"none\" {\n-\t\t\trs[i] = q.m\n-\t\t\toverridden[q.m.Path] = true\n-\t\t}\n+\tsort.Slice(retractions, func(i, j int) bool {\n+\t\treturn retractions[i].m.Path < retractions[j].m.Path\n+\t})\n+\tfor i := 0; i < len(retractions); i++ {\n+\t\ti := i\n+\t\tr.work.Add(func() {\n+\t\t\terr := modload.CheckRetractions(ctx, retractions[i].m)\n+\t\t\tif retractErr := (*modload.ModuleRetractedError)(nil); errors.As(err, &retractErr) {\n+\t\t\t\tretractions[i].err = err\n+\t\t\t}\n+\t\t})\n \t}\n-\tfor _, q := range u.cmdline {\n-\t\tif !overridden[q.m.Path] && q.m.Path != modload.Target.Path && q.m.Version != \"none\" {\n-\t\t\trs = append(rs, q.m)\n+\t<-r.work.Idle()\n+\tvar retractPath string\n+\tfor _, r := range retractions {\n+\t\tif r.err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: %v\\n\", r.err)\n+\t\t\tif retractPath == \"\" {\n+\t\t\t\tretractPath = r.m.Path\n+\t\t\t} else {\n+\t\t\t\tretractPath = \"<module>\"\n+\t\t\t}\n \t\t}\n \t}\n-\treturn rs, nil\n+\tif retractPath != \"\" {\n+\t\tfmt.Fprintf(os.Stderr, \"go: run 'go get %s@latest' to switch to the latest unretracted version\\n\", retractPath)\n+\t}\n }\n \n-// Upgrade returns the desired upgrade for m.\n-//\n-// If m was requested at a specific version on the command line, then\n-// Upgrade returns that version.\n+// reportChanges logs version changes to os.Stderr.\n //\n-// If -u is set and m provides a dependency of a package matched by\n-// command line arguments, then Upgrade may provider a newer tagged version.\n-// If m is a tagged version, then Upgrade will return the latest tagged\n-// version (with the same minor version number if -u=patch).\n-// If m is a pseudo-version, then Upgrade returns the latest tagged version\n-// only if that version has a time-stamp newer than m. This special case\n-// prevents accidental downgrades when already using a pseudo-version\n-// newer than the latest tagged version.\n+// reportChanges only logs changes to modules named on the command line and to\n+// explicitly required modules in go.mod. Most changes to indirect requirements\n+// are not relevant to the user and are not logged.\n //\n-// If none of the above cases apply, then Upgrade returns m.\n-func (u *upgrader) Upgrade(m module.Version) (module.Version, error) {\n-\t// Allow pkg@vers on the command line to override the upgrade choice v.\n-\t// If q's version is < m.Version, then we're going to downgrade anyway,\n-\t// and it's cleaner to avoid moving back and forth and picking up\n-\t// extraneous other newer dependencies.\n-\t// If q's version is > m.Version, then we're going to upgrade past\n-\t// m.Version anyway, and again it's cleaner to avoid moving back and forth\n-\t// picking up extraneous other newer dependencies.\n-\tif q := u.cmdline[m.Path]; q != nil {\n-\t\treturn q.m, nil\n-\t}\n-\n-\tif !u.upgrade[m.Path] {\n-\t\t// Not involved in upgrade. Leave alone.\n-\t\treturn m, nil\n-\t}\n-\n-\t// Run query required by upgrade semantics.\n-\t// Note that Query \"latest\" is not the same as using repo.Latest,\n-\t// which may return a pseudoversion for the latest commit.\n-\t// Query \"latest\" returns the newest tagged version or the newest\n-\t// prerelease version if there are no non-prereleases, or repo.Latest\n-\t// if there aren't any tagged versions.\n-\t// If we're querying \"upgrade\" or \"patch\", Query will compare the current\n-\t// version against the chosen version and will return the current version\n-\t// if it is newer.\n-\tinfo, err := modload.Query(m.Path, string(getU), m.Version, modload.Allowed)\n-\tif err != nil {\n-\t\t// Report error but return m, to let version selection continue.\n-\t\t// (Reporting the error will fail the command at the next base.ExitIfErrors.)\n-\n-\t\t// Special case: if the error is for m.Version itself and m.Version has a\n-\t\t// replacement, then keep it and don't report the error: the fact that the\n-\t\t// version is invalid is likely the reason it was replaced to begin with.\n-\t\tvar vErr *module.InvalidVersionError\n-\t\tif errors.As(err, &vErr) && vErr.Version == m.Version && modload.Replacement(m).Path != \"\" {\n-\t\t\treturn m, nil\n+// reportChanges should be called after WriteGoMod.\n+func (r *resolver) reportChanges(oldReqs, newReqs []module.Version) {\n+\ttype change struct {\n+\t\tpath, old, new string\n+\t}\n+\tchanges := make(map[string]change)\n+\n+\t// Collect changes in modules matched by command line arguments.\n+\tfor path, reason := range r.resolvedVersion {\n+\t\told := r.initialVersion[path]\n+\t\tnew := reason.version\n+\t\tif old != new && (old != \"\" || new != \"none\") {\n+\t\t\tchanges[path] = change{path, old, new}\n \t\t}\n+\t}\n \n-\t\t// Special case: if the error is \"no matching versions\" then don't\n-\t\t// even report the error. Because Query does not consider pseudo-versions,\n-\t\t// it may happen that we have a pseudo-version but during -u=patch\n-\t\t// the query v0.0 matches no versions (not even the one we're using).\n-\t\tvar noMatch *modload.NoMatchingVersionError\n-\t\tif !errors.As(err, &noMatch) {\n-\t\t\tbase.Errorf(\"go get: upgrading %s@%s: %v\", m.Path, m.Version, err)\n+\t// Collect changes to explicit requirements in go.mod.\n+\tfor _, req := range oldReqs {\n+\t\tpath := req.Path\n+\t\told := req.Version\n+\t\tnew := r.buildListVersion[path]\n+\t\tif old != new {\n+\t\t\tchanges[path] = change{path, old, new}\n+\t\t}\n+\t}\n+\tfor _, req := range newReqs {\n+\t\tpath := req.Path\n+\t\told := r.initialVersion[path]\n+\t\tnew := req.Version\n+\t\tif old != new {\n+\t\t\tchanges[path] = change{path, old, new}\n \t\t}\n-\t\treturn m, nil\n \t}\n \n-\tif info.Version != m.Version {\n-\t\tlogOncef(\"go: %s %s => %s\", m.Path, getU, info.Version)\n+\tsortedChanges := make([]change, 0, len(changes))\n+\tfor _, c := range changes {\n+\t\tsortedChanges = append(sortedChanges, c)\n \t}\n-\treturn module.Version{Path: m.Path, Version: info.Version}, nil\n+\tsort.Slice(sortedChanges, func(i, j int) bool {\n+\t\treturn sortedChanges[i].path < sortedChanges[j].path\n+\t})\n+\tfor _, c := range sortedChanges {\n+\t\tif c.old == \"\" {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go get: added %s %s\\n\", c.path, c.new)\n+\t\t} else if c.new == \"none\" || c.new == \"\" {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go get: removed %s %s\\n\", c.path, c.old)\n+\t\t} else if semver.Compare(c.new, c.old) > 0 {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go get: upgraded %s %s => %s\\n\", c.path, c.old, c.new)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go get: downgraded %s %s => %s\\n\", c.path, c.old, c.new)\n+\t\t}\n+\t}\n+\n+\t// TODO(golang.org/issue/33284): attribute changes to command line arguments.\n+\t// For modules matched by command line arguments, this probably isn't\n+\t// necessary, but it would be useful for unmatched direct dependencies of\n+\t// the main module.\n }\n \n-// buildListForLostUpgrade returns the build list for the module graph\n-// rooted at lost. Unlike mvs.BuildList, the target module (lost) is not\n-// treated specially. The returned build list may contain a newer version\n-// of lost.\n-//\n-// buildListForLostUpgrade is used after a downgrade has removed a module\n-// requested at a specific version. This helps us understand the requirements\n-// implied by each downgrade.\n-func buildListForLostUpgrade(lost module.Version, reqs mvs.Reqs) ([]module.Version, error) {\n-\treturn mvs.BuildList(lostUpgradeRoot, &lostUpgradeReqs{Reqs: reqs, lost: lost})\n+// resolve records that module m must be at its indicated version (which may be\n+// \"none\") due to query q. If some other query forces module m to be at a\n+// different version, resolve reports a conflict error.\n+func (r *resolver) resolve(q *query, m module.Version) {\n+\tif m.Path == \"\" {\n+\t\tpanic(\"internal error: resolving a module.Version with an empty path\")\n+\t}\n+\n+\tif m.Path == modload.Target.Path && m.Version != modload.Target.Version {\n+\t\treportError(q, &modload.QueryMatchesMainModuleError{\n+\t\t\tPattern: q.pattern,\n+\t\t\tQuery:   q.version,\n+\t\t})\n+\t\treturn\n+\t}\n+\n+\tvr, ok := r.resolvedVersion[m.Path]\n+\tif ok && vr.version != m.Version {\n+\t\treportConflict(q, m, vr)\n+\t\treturn\n+\t}\n+\tr.resolvedVersion[m.Path] = versionReason{m.Version, q}\n+\tq.resolved = append(q.resolved, m)\n }\n \n-var lostUpgradeRoot = module.Version{Path: \"lost-upgrade-root\", Version: \"\"}\n+// updateBuildList updates the module loader's global build list to be\n+// consistent with r.resolvedVersion, and to include additional modules\n+// provided that they do not conflict with the resolved versions.\n+//\n+// If the additional modules conflict with the resolved versions, they will be\n+// downgraded to a non-conflicting version (possibly \"none\").\n+func (r *resolver) updateBuildList(ctx context.Context, additions []module.Version) (changed bool) {\n+\tif len(additions) == 0 && len(r.resolvedVersion) == r.buildListResolvedVersions {\n+\t\treturn false\n+\t}\n+\n+\tdefer base.ExitIfErrors()\n \n-type lostUpgradeReqs struct {\n-\tmvs.Reqs\n-\tlost module.Version\n+\tresolved := make([]module.Version, 0, len(r.resolvedVersion))\n+\tfor mPath, rv := range r.resolvedVersion {\n+\t\tif mPath != modload.Target.Path {\n+\t\t\tresolved = append(resolved, module.Version{Path: mPath, Version: rv.version})\n+\t\t}\n+\t}\n+\n+\tif err := modload.EditBuildList(ctx, additions, resolved); err != nil {\n+\t\tvar constraint *modload.ConstraintError\n+\t\tif !errors.As(err, &constraint) {\n+\t\t\tbase.Errorf(\"go get: %v\", err)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treason := func(m module.Version) string {\n+\t\t\trv, ok := r.resolvedVersion[m.Path]\n+\t\t\tif !ok {\n+\t\t\t\tpanic(fmt.Sprintf(\"internal error: can't find reason for requirement on %v\", m))\n+\t\t\t}\n+\t\t\treturn rv.reason.ResolvedString(module.Version{Path: m.Path, Version: rv.version})\n+\t\t}\n+\t\tfor _, c := range constraint.Conflicts {\n+\t\t\tbase.Errorf(\"go get: %v requires %v, not %v\", reason(c.Source), c.Dep, reason(c.Constraint))\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tbuildList := modload.LoadAllModules(ctx)\n+\tr.buildListResolvedVersions = len(r.resolvedVersion)\n+\tif reflect.DeepEqual(r.buildList, buildList) {\n+\t\treturn false\n+\t}\n+\tr.buildList = buildList\n+\tr.buildListVersion = make(map[string]string, len(r.buildList))\n+\tfor _, m := range r.buildList {\n+\t\tr.buildListVersion[m.Path] = m.Version\n+\t}\n+\treturn true\n }\n \n-func (r *lostUpgradeReqs) Required(mod module.Version) ([]module.Version, error) {\n-\tif mod == lostUpgradeRoot {\n-\t\treturn []module.Version{r.lost}, nil\n+func reqsFromGoMod(f *modfile.File) []module.Version {\n+\treqs := make([]module.Version, len(f.Require))\n+\tfor i, r := range f.Require {\n+\t\treqs[i] = r.Mod\n \t}\n-\treturn r.Reqs.Required(mod)\n+\treturn reqs\n }\n \n-var loggedLines sync.Map\n+// isNoSuchModuleVersion reports whether err indicates that the requested module\n+// does not exist at the requested version, either because the module does not\n+// exist at all or because it does not include that specific version.\n+func isNoSuchModuleVersion(err error) bool {\n+\tvar noMatch *modload.NoMatchingVersionError\n+\treturn errors.Is(err, os.ErrNotExist) || errors.As(err, &noMatch)\n+}\n \n-func logOncef(format string, args ...interface{}) {\n-\tmsg := fmt.Sprintf(format, args...)\n-\tif _, dup := loggedLines.LoadOrStore(msg, true); !dup {\n-\t\tfmt.Fprintln(os.Stderr, msg)\n-\t}\n+// isNoSuchPackageVersion reports whether err indicates that the requested\n+// package does not exist at the requested version, either because no module\n+// that could contain it exists at that version, or because every such module\n+// that does exist does not actually contain the package.\n+func isNoSuchPackageVersion(err error) bool {\n+\tvar noPackage *modload.PackageNotInModuleError\n+\treturn isNoSuchModuleVersion(err) || errors.As(err, &noPackage)\n }"}, {"sha": "20eb0b6364ee0715af197d9862ca5944a9fcd89f", "filename": "libgo/go/cmd/go/internal/modget/query.go", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -0,0 +1,357 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modget\n+\n+import (\n+\t\"fmt\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/search\"\n+\t\"cmd/go/internal/str\"\n+\n+\t\"golang.org/x/mod/module\"\n+)\n+\n+// A query describes a command-line argument and the modules and/or packages\n+// to which that argument may resolve..\n+type query struct {\n+\t// raw is the original argument, to be printed in error messages.\n+\traw string\n+\n+\t// rawVersion is the portion of raw corresponding to version, if any\n+\trawVersion string\n+\n+\t// pattern is the part of the argument before \"@\" (or the whole argument\n+\t// if there is no \"@\"), which may match either packages (preferred) or\n+\t// modules (if no matching packages).\n+\t//\n+\t// The pattern may also be \"-u\", for the synthetic query representing the -u\n+\t// (\u201cupgrade\u201d)flag.\n+\tpattern string\n+\n+\t// patternIsLocal indicates whether pattern is restricted to match only paths\n+\t// local to the main module, such as absolute filesystem paths or paths\n+\t// beginning with './'.\n+\t//\n+\t// A local pattern must resolve to one or more packages in the main module.\n+\tpatternIsLocal bool\n+\n+\t// version is the part of the argument after \"@\", or an implied\n+\t// \"upgrade\" or \"patch\" if there is no \"@\". version specifies the\n+\t// module version to get.\n+\tversion string\n+\n+\t// matchWildcard, if non-nil, reports whether pattern, which must be a\n+\t// wildcard (with the substring \"...\"), matches the given package or module\n+\t// path.\n+\tmatchWildcard func(path string) bool\n+\n+\t// canMatchWildcard, if non-nil, reports whether the module with the given\n+\t// path could lexically contain a package matching pattern, which must be a\n+\t// wildcard.\n+\tcanMatchWildcardInModule func(mPath string) bool\n+\n+\t// conflict is the first query identified as incompatible with this one.\n+\t// conflict forces one or more of the modules matching this query to a\n+\t// version that does not match version.\n+\tconflict *query\n+\n+\t// candidates is a list of sets of alternatives for a path that matches (or\n+\t// contains packages that match) the pattern. The query can be resolved by\n+\t// choosing exactly one alternative from each set in the list.\n+\t//\n+\t// A path-literal query results in only one set: the path itself, which\n+\t// may resolve to either a package path or a module path.\n+\t//\n+\t// A wildcard query results in one set for each matching module path, each\n+\t// module for which the matching version contains at least one matching\n+\t// package, and (if no other modules match) one candidate set for the pattern\n+\t// overall if no existing match is identified in the build list.\n+\t//\n+\t// A query for pattern \"all\" results in one set for each package transitively\n+\t// imported by the main module.\n+\t//\n+\t// The special query for the \"-u\" flag results in one set for each\n+\t// otherwise-unconstrained package that has available upgrades.\n+\tcandidates   []pathSet\n+\tcandidatesMu sync.Mutex\n+\n+\t// pathSeen ensures that only one pathSet is added to the query per\n+\t// unique path.\n+\tpathSeen sync.Map\n+\n+\t// resolved contains the set of modules whose versions have been determined by\n+\t// this query, in the order in which they were determined.\n+\t//\n+\t// The resolver examines the candidate sets for each query, resolving one\n+\t// module per candidate set in a way that attempts to avoid obvious conflicts\n+\t// between the versions resolved by different queries.\n+\tresolved []module.Version\n+\n+\t// matchesPackages is true if the resolved modules provide at least one\n+\t// package mathcing q.pattern.\n+\tmatchesPackages bool\n+}\n+\n+// A pathSet describes the possible options for resolving a specific path\n+// to a package and/or module.\n+type pathSet struct {\n+\t// path is a package (if \"all\" or \"-u\" or a non-wildcard) or module (if\n+\t// wildcard) path that could be resolved by adding any of the modules in this\n+\t// set. For a wildcard pattern that so far matches no packages, the path is\n+\t// the wildcard pattern itself.\n+\t//\n+\t// Each path must occur only once in a query's candidate sets, and the path is\n+\t// added implicitly to each pathSet returned to pathOnce.\n+\tpath string\n+\n+\t// pkgMods is a set of zero or more modules, each of which contains the\n+\t// package with the indicated path. Due to the requirement that imports be\n+\t// unambiguous, only one such module can be in the build list, and all others\n+\t// must be excluded.\n+\tpkgMods []module.Version\n+\n+\t// mod is either the zero Version, or a module that does not contain any\n+\t// packages matching the query but for which the module path itself\n+\t// matches the query pattern.\n+\t//\n+\t// We track this module separately from pkgMods because, all else equal, we\n+\t// prefer to match a query to a package rather than just a module. Also,\n+\t// unlike the modules in pkgMods, this module does not inherently exclude\n+\t// any other module in pkgMods.\n+\tmod module.Version\n+\n+\terr error\n+}\n+\n+// errSet returns a pathSet containing the given error.\n+func errSet(err error) pathSet { return pathSet{err: err} }\n+\n+// newQuery returns a new query parsed from the raw argument,\n+// which must be either path or path@version.\n+func newQuery(raw string) (*query, error) {\n+\tpattern := raw\n+\trawVers := \"\"\n+\tif i := strings.Index(raw, \"@\"); i >= 0 {\n+\t\tpattern, rawVers = raw[:i], raw[i+1:]\n+\t\tif strings.Contains(rawVers, \"@\") || rawVers == \"\" {\n+\t\t\treturn nil, fmt.Errorf(\"invalid module version syntax %q\", raw)\n+\t\t}\n+\t}\n+\n+\t// If no version suffix is specified, assume @upgrade.\n+\t// If -u=patch was specified, assume @patch instead.\n+\tversion := rawVers\n+\tif version == \"\" {\n+\t\tif getU.version == \"\" {\n+\t\t\tversion = \"upgrade\"\n+\t\t} else {\n+\t\t\tversion = getU.version\n+\t\t}\n+\t}\n+\n+\tq := &query{\n+\t\traw:            raw,\n+\t\trawVersion:     rawVers,\n+\t\tpattern:        pattern,\n+\t\tpatternIsLocal: filepath.IsAbs(pattern) || search.IsRelativePath(pattern),\n+\t\tversion:        version,\n+\t}\n+\tif strings.Contains(q.pattern, \"...\") {\n+\t\tq.matchWildcard = search.MatchPattern(q.pattern)\n+\t\tq.canMatchWildcardInModule = search.TreeCanMatchPattern(q.pattern)\n+\t}\n+\tif err := q.validate(); err != nil {\n+\t\treturn q, err\n+\t}\n+\treturn q, nil\n+}\n+\n+// validate reports a non-nil error if q is not sensible and well-formed.\n+func (q *query) validate() error {\n+\tif q.patternIsLocal {\n+\t\tif q.rawVersion != \"\" {\n+\t\t\treturn fmt.Errorf(\"can't request explicit version %q of path %q in main module\", q.rawVersion, q.pattern)\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tif q.pattern == \"all\" {\n+\t\t// If there is no main module, \"all\" is not meaningful.\n+\t\tif !modload.HasModRoot() {\n+\t\t\treturn fmt.Errorf(`cannot match \"all\": working directory is not part of a module`)\n+\t\t}\n+\t\tif !versionOkForMainModule(q.version) {\n+\t\t\t// TODO(bcmills): \"all@none\" seems like a totally reasonable way to\n+\t\t\t// request that we remove all module requirements, leaving only the main\n+\t\t\t// module and standard library. Perhaps we should implement that someday.\n+\t\t\treturn &modload.QueryMatchesMainModuleError{\n+\t\t\t\tPattern: q.pattern,\n+\t\t\t\tQuery:   q.version,\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif search.IsMetaPackage(q.pattern) && q.pattern != \"all\" {\n+\t\tif q.pattern != q.raw {\n+\t\t\treturn fmt.Errorf(\"can't request explicit version of standard-library pattern %q\", q.pattern)\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// String returns the original argument from which q was parsed.\n+func (q *query) String() string { return q.raw }\n+\n+// ResolvedString returns a string describing m as a resolved match for q.\n+func (q *query) ResolvedString(m module.Version) string {\n+\tif m.Path != q.pattern {\n+\t\tif m.Version != q.version {\n+\t\t\treturn fmt.Sprintf(\"%v (matching %s@%s)\", m, q.pattern, q.version)\n+\t\t}\n+\t\treturn fmt.Sprintf(\"%v (matching %v)\", m, q)\n+\t}\n+\tif m.Version != q.version {\n+\t\treturn fmt.Sprintf(\"%s@%s (%s)\", q.pattern, q.version, m.Version)\n+\t}\n+\treturn q.String()\n+}\n+\n+// isWildcard reports whether q is a pattern that can match multiple paths.\n+func (q *query) isWildcard() bool {\n+\treturn q.matchWildcard != nil || (q.patternIsLocal && strings.Contains(q.pattern, \"...\"))\n+}\n+\n+// matchesPath reports whether the given path matches q.pattern.\n+func (q *query) matchesPath(path string) bool {\n+\tif q.matchWildcard != nil {\n+\t\treturn q.matchWildcard(path)\n+\t}\n+\treturn path == q.pattern\n+}\n+\n+// canMatchInModule reports whether the given module path can potentially\n+// contain q.pattern.\n+func (q *query) canMatchInModule(mPath string) bool {\n+\tif q.canMatchWildcardInModule != nil {\n+\t\treturn q.canMatchWildcardInModule(mPath)\n+\t}\n+\treturn str.HasPathPrefix(q.pattern, mPath)\n+}\n+\n+// pathOnce invokes f to generate the pathSet for the given path,\n+// if one is still needed.\n+//\n+// Note that, unlike sync.Once, pathOnce does not guarantee that a concurrent\n+// call to f for the given path has completed on return.\n+//\n+// pathOnce is safe for concurrent use by multiple goroutines, but note that\n+// multiple concurrent calls will result in the sets being added in\n+// nondeterministic order.\n+func (q *query) pathOnce(path string, f func() pathSet) {\n+\tif _, dup := q.pathSeen.LoadOrStore(path, nil); dup {\n+\t\treturn\n+\t}\n+\n+\tcs := f()\n+\n+\tif len(cs.pkgMods) > 0 || cs.mod != (module.Version{}) || cs.err != nil {\n+\t\tcs.path = path\n+\t\tq.candidatesMu.Lock()\n+\t\tq.candidates = append(q.candidates, cs)\n+\t\tq.candidatesMu.Unlock()\n+\t}\n+}\n+\n+// reportError logs err concisely using base.Errorf.\n+func reportError(q *query, err error) {\n+\terrStr := err.Error()\n+\n+\t// If err already mentions all of the relevant parts of q, just log err to\n+\t// reduce stutter. Otherwise, log both q and err.\n+\t//\n+\t// TODO(bcmills): Use errors.As to unpack these errors instead of parsing\n+\t// strings with regular expressions.\n+\n+\tpatternRE := regexp.MustCompile(\"(?m)(?:[ \\t(\\\"`]|^)\" + regexp.QuoteMeta(q.pattern) + \"(?:[ @:)\\\"`]|$)\")\n+\tif patternRE.MatchString(errStr) {\n+\t\tif q.rawVersion == \"\" {\n+\t\t\tbase.Errorf(\"go get: %s\", errStr)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tversionRE := regexp.MustCompile(\"(?m)(?:[ @(\\\"`]|^)\" + regexp.QuoteMeta(q.version) + \"(?:[ :)\\\"`]|$)\")\n+\t\tif versionRE.MatchString(errStr) {\n+\t\t\tbase.Errorf(\"go get: %s\", errStr)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tif qs := q.String(); qs != \"\" {\n+\t\tbase.Errorf(\"go get %s: %s\", qs, errStr)\n+\t} else {\n+\t\tbase.Errorf(\"go get: %s\", errStr)\n+\t}\n+}\n+\n+func reportConflict(pq *query, m module.Version, conflict versionReason) {\n+\tif pq.conflict != nil {\n+\t\t// We've already reported a conflict for the proposed query.\n+\t\t// Don't report it again, even if it has other conflicts.\n+\t\treturn\n+\t}\n+\tpq.conflict = conflict.reason\n+\n+\tproposed := versionReason{\n+\t\tversion: m.Version,\n+\t\treason:  pq,\n+\t}\n+\tif pq.isWildcard() && !conflict.reason.isWildcard() {\n+\t\t// Prefer to report the specific path first and the wildcard second.\n+\t\tproposed, conflict = conflict, proposed\n+\t}\n+\treportError(pq, &conflictError{\n+\t\tmPath:    m.Path,\n+\t\tproposed: proposed,\n+\t\tconflict: conflict,\n+\t})\n+}\n+\n+type conflictError struct {\n+\tmPath    string\n+\tproposed versionReason\n+\tconflict versionReason\n+}\n+\n+func (e *conflictError) Error() string {\n+\targStr := func(q *query, v string) string {\n+\t\tif v != q.version {\n+\t\t\treturn fmt.Sprintf(\"%s@%s (%s)\", q.pattern, q.version, v)\n+\t\t}\n+\t\treturn q.String()\n+\t}\n+\n+\tpq := e.proposed.reason\n+\trq := e.conflict.reason\n+\tmodDetail := \"\"\n+\tif e.mPath != pq.pattern {\n+\t\tmodDetail = fmt.Sprintf(\"for module %s, \", e.mPath)\n+\t}\n+\n+\treturn fmt.Sprintf(\"%s%s conflicts with %s\",\n+\t\tmodDetail,\n+\t\targStr(pq, e.proposed.version),\n+\t\targStr(rq, e.conflict.version))\n+}\n+\n+func versionOkForMainModule(version string) bool {\n+\treturn version == \"upgrade\" || version == \"patch\"\n+}"}, {"sha": "897be56397d144f4da6ab296dc636e19c8a82f07", "filename": "libgo/go/cmd/go/internal/modinfo/info.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -21,6 +21,7 @@ type ModulePublic struct {\n \tDir       string        `json:\",omitempty\"` // directory holding local copy of files, if any\n \tGoMod     string        `json:\",omitempty\"` // path to go.mod file describing module, if any\n \tGoVersion string        `json:\",omitempty\"` // go version used in module\n+\tRetracted []string      `json:\",omitempty\"` // retraction information, if any (with -retracted or -u)\n \tError     *ModuleError  `json:\",omitempty\"` // error loading module\n }\n \n@@ -30,18 +31,26 @@ type ModuleError struct {\n \n func (m *ModulePublic) String() string {\n \ts := m.Path\n+\tversionString := func(mm *ModulePublic) string {\n+\t\tv := mm.Version\n+\t\tif len(mm.Retracted) == 0 {\n+\t\t\treturn v\n+\t\t}\n+\t\treturn v + \" (retracted)\"\n+\t}\n+\n \tif m.Version != \"\" {\n-\t\ts += \" \" + m.Version\n+\t\ts += \" \" + versionString(m)\n \t\tif m.Update != nil {\n-\t\t\ts += \" [\" + m.Update.Version + \"]\"\n+\t\t\ts += \" [\" + versionString(m.Update) + \"]\"\n \t\t}\n \t}\n \tif m.Replace != nil {\n \t\ts += \" => \" + m.Replace.Path\n \t\tif m.Replace.Version != \"\" {\n-\t\t\ts += \" \" + m.Replace.Version\n+\t\t\ts += \" \" + versionString(m.Replace)\n \t\t\tif m.Replace.Update != nil {\n-\t\t\t\ts += \" [\" + m.Replace.Update.Version + \"]\"\n+\t\t\t\ts += \" [\" + versionString(m.Replace.Update) + \"]\"\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "d2f8f8670a2d20657dfe40a4848b60373db30671", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,12 +6,13 @@ package modload\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"encoding/hex\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"internal/goroot\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"runtime/debug\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n@@ -48,7 +49,7 @@ func findStandardImportPath(path string) string {\n // PackageModuleInfo returns information about the module that provides\n // a given package. If modules are not enabled or if the package is in the\n // standard library or if the package was not successfully loaded with\n-// ImportPaths or a similar loading function, nil is returned.\n+// LoadPackages or ImportFromFiles, nil is returned.\n func PackageModuleInfo(pkgpath string) *modinfo.ModulePublic {\n \tif isStandardImportPath(pkgpath) || !Enabled() {\n \t\treturn nil\n@@ -57,21 +58,27 @@ func PackageModuleInfo(pkgpath string) *modinfo.ModulePublic {\n \tif !ok {\n \t\treturn nil\n \t}\n-\treturn moduleInfo(m, true)\n+\tfromBuildList := true\n+\tlistRetracted := false\n+\treturn moduleInfo(context.TODO(), m, fromBuildList, listRetracted)\n }\n \n-func ModuleInfo(path string) *modinfo.ModulePublic {\n+func ModuleInfo(ctx context.Context, path string) *modinfo.ModulePublic {\n \tif !Enabled() {\n \t\treturn nil\n \t}\n \n+\tlistRetracted := false\n \tif i := strings.Index(path, \"@\"); i >= 0 {\n-\t\treturn moduleInfo(module.Version{Path: path[:i], Version: path[i+1:]}, false)\n+\t\tm := module.Version{Path: path[:i], Version: path[i+1:]}\n+\t\tfromBuildList := false\n+\t\treturn moduleInfo(ctx, m, fromBuildList, listRetracted)\n \t}\n \n-\tfor _, m := range BuildList() {\n+\tfor _, m := range buildList {\n \t\tif m.Path == path {\n-\t\t\treturn moduleInfo(m, true)\n+\t\t\tfromBuildList := true\n+\t\t\treturn moduleInfo(ctx, m, fromBuildList, listRetracted)\n \t\t}\n \t}\n \n@@ -84,12 +91,12 @@ func ModuleInfo(path string) *modinfo.ModulePublic {\n }\n \n // addUpdate fills in m.Update if an updated version is available.\n-func addUpdate(m *modinfo.ModulePublic) {\n+func addUpdate(ctx context.Context, m *modinfo.ModulePublic) {\n \tif m.Version == \"\" {\n \t\treturn\n \t}\n \n-\tif info, err := Query(m.Path, \"upgrade\", m.Version, Allowed); err == nil && semver.Compare(info.Version, m.Version) > 0 {\n+\tif info, err := Query(ctx, m.Path, \"upgrade\", m.Version, CheckAllowed); err == nil && semver.Compare(info.Version, m.Version) > 0 {\n \t\tm.Update = &modinfo.ModulePublic{\n \t\t\tPath:    m.Path,\n \t\t\tVersion: info.Version,\n@@ -99,11 +106,37 @@ func addUpdate(m *modinfo.ModulePublic) {\n }\n \n // addVersions fills in m.Versions with the list of known versions.\n-func addVersions(m *modinfo.ModulePublic) {\n-\tm.Versions, _ = versions(m.Path)\n+// Excluded versions will be omitted. If listRetracted is false, retracted\n+// versions will also be omitted.\n+func addVersions(ctx context.Context, m *modinfo.ModulePublic, listRetracted bool) {\n+\tallowed := CheckAllowed\n+\tif listRetracted {\n+\t\tallowed = CheckExclusions\n+\t}\n+\tm.Versions, _ = versions(ctx, m.Path, allowed)\n+}\n+\n+// addRetraction fills in m.Retracted if the module was retracted by its author.\n+// m.Error is set if there's an error loading retraction information.\n+func addRetraction(ctx context.Context, m *modinfo.ModulePublic) {\n+\tif m.Version == \"\" {\n+\t\treturn\n+\t}\n+\n+\terr := CheckRetractions(ctx, module.Version{Path: m.Path, Version: m.Version})\n+\tvar rerr *ModuleRetractedError\n+\tif errors.As(err, &rerr) {\n+\t\tif len(rerr.Rationale) == 0 {\n+\t\t\tm.Retracted = []string{\"retracted by module author\"}\n+\t\t} else {\n+\t\t\tm.Retracted = rerr.Rationale\n+\t\t}\n+\t} else if err != nil && m.Error == nil {\n+\t\tm.Error = &modinfo.ModuleError{Err: err.Error()}\n+\t}\n }\n \n-func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n+func moduleInfo(ctx context.Context, m module.Version, fromBuildList, listRetracted bool) *modinfo.ModulePublic {\n \tif m == Target {\n \t\tinfo := &modinfo.ModulePublic{\n \t\t\tPath:    m.Path,\n@@ -125,21 +158,22 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\tVersion:  m.Version,\n \t\tIndirect: fromBuildList && loaded != nil && !loaded.direct[m.Path],\n \t}\n-\tif loaded != nil {\n-\t\tinfo.GoVersion = loaded.goVersion[m.Path]\n+\tif v, ok := rawGoVersion.Load(m); ok {\n+\t\tinfo.GoVersion = v.(string)\n \t}\n \n \t// completeFromModCache fills in the extra fields in m using the module cache.\n \tcompleteFromModCache := func(m *modinfo.ModulePublic) {\n+\t\tmod := module.Version{Path: m.Path, Version: m.Version}\n+\n \t\tif m.Version != \"\" {\n-\t\t\tif q, err := Query(m.Path, m.Version, \"\", nil); err != nil {\n+\t\t\tif q, err := Query(ctx, m.Path, m.Version, \"\", nil); err != nil {\n \t\t\t\tm.Error = &modinfo.ModuleError{Err: err.Error()}\n \t\t\t} else {\n \t\t\t\tm.Version = q.Version\n \t\t\t\tm.Time = &q.Time\n \t\t\t}\n \n-\t\t\tmod := module.Version{Path: m.Path, Version: m.Version}\n \t\t\tgomod, err := modfetch.CachePath(mod, \"mod\")\n \t\t\tif err == nil {\n \t\t\t\tif info, err := os.Stat(gomod); err == nil && info.Mode().IsRegular() {\n@@ -150,10 +184,22 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\t\tif err == nil {\n \t\t\t\tm.Dir = dir\n \t\t\t}\n+\n+\t\t\tif listRetracted {\n+\t\t\t\taddRetraction(ctx, m)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif m.GoVersion == \"\" {\n+\t\t\tif summary, err := rawGoModSummary(mod); err == nil && summary.goVersionV != \"\" {\n+\t\t\t\tm.GoVersion = summary.goVersionV[1:]\n+\t\t\t}\n \t\t}\n \t}\n \n \tif !fromBuildList {\n+\t\t// If this was an explicitly-versioned argument to 'go mod download' or\n+\t\t// 'go list -m', report the actual requested version, not its replacement.\n \t\tcompleteFromModCache(info) // Will set m.Error in vendor mode.\n \t\treturn info\n \t}\n@@ -177,9 +223,11 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t// worth the cost, and we're going to overwrite the GoMod and Dir from the\n \t// replacement anyway. See https://golang.org/issue/27859.\n \tinfo.Replace = &modinfo.ModulePublic{\n-\t\tPath:      r.Path,\n-\t\tVersion:   r.Version,\n-\t\tGoVersion: info.GoVersion,\n+\t\tPath:    r.Path,\n+\t\tVersion: r.Version,\n+\t}\n+\tif v, ok := rawGoVersion.Load(m); ok {\n+\t\tinfo.Replace.GoVersion = v.(string)\n \t}\n \tif r.Version == \"\" {\n \t\tif filepath.IsAbs(r.Path) {\n@@ -193,14 +241,15 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\tcompleteFromModCache(info.Replace)\n \t\tinfo.Dir = info.Replace.Dir\n \t\tinfo.GoMod = info.Replace.GoMod\n+\t\tinfo.Retracted = info.Replace.Retracted\n \t}\n+\tinfo.GoVersion = info.Replace.GoVersion\n \treturn info\n }\n \n // PackageBuildInfo returns a string containing module version information\n // for modules providing packages named by path and deps. path and deps must\n-// name packages that were resolved successfully with ImportPaths or one of\n-// the Load functions.\n+// name packages that were resolved successfully with LoadPackages.\n func PackageBuildInfo(path string, deps []string) string {\n \tif isStandardImportPath(path) || !Enabled() {\n \t\treturn \"\"\n@@ -262,17 +311,13 @@ func mustFindModule(target, path string) module.Version {\n \t\treturn Target\n \t}\n \n-\tif printStackInDie {\n-\t\tdebug.PrintStack()\n-\t}\n \tbase.Fatalf(\"build %v: cannot find module for path %v\", target, path)\n \tpanic(\"unreachable\")\n }\n \n // findModule searches for the module that contains the package at path.\n-// If the package was loaded with ImportPaths or one of the other loading\n-// functions, its containing module and true are returned. Otherwise,\n-// module.Version{} and false are returend.\n+// If the package was loaded, its containing module and true are returned.\n+// Otherwise, module.Version{} and false are returend.\n func findModule(path string) (module.Version, bool) {\n \tif pkg, ok := loaded.pkgCache.Get(path).(*loadPkg); ok {\n \t\treturn pkg.mod, pkg.mod != module.Version{}\n@@ -312,6 +357,6 @@ import _ \"unsafe\"\n //go:linkname __set_debug_modinfo__ runtime.setmodinfo\n func __set_debug_modinfo__(string)\n func init() { __set_debug_modinfo__(%q) }\n-\t`, string(infoStart)+info+string(infoEnd)))\n+`, string(infoStart)+info+string(infoEnd)))\n \t}\n }"}, {"sha": "896adebbb19de9b71aefc310e0e7dc8f0053c1df", "filename": "libgo/go/cmd/go/internal/modload/buildlist.go", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -0,0 +1,267 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modload\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/imports\"\n+\t\"cmd/go/internal/mvs\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"golang.org/x/mod/module\"\n+)\n+\n+// buildList is the list of modules to use for building packages.\n+// It is initialized by calling LoadPackages or ImportFromFiles,\n+// each of which uses loaded.load.\n+//\n+// Ideally, exactly ONE of those functions would be called,\n+// and exactly once. Most of the time, that's true.\n+// During \"go get\" it may not be. TODO(rsc): Figure out if\n+// that restriction can be established, or else document why not.\n+//\n+var buildList []module.Version\n+\n+// capVersionSlice returns s with its cap reduced to its length.\n+func capVersionSlice(s []module.Version) []module.Version {\n+\treturn s[:len(s):len(s)]\n+}\n+\n+// LoadAllModules loads and returns the list of modules matching the \"all\"\n+// module pattern, starting with the Target module and in a deterministic\n+// (stable) order, without loading any packages.\n+//\n+// Modules are loaded automatically (and lazily) in LoadPackages:\n+// LoadAllModules need only be called if LoadPackages is not,\n+// typically in commands that care about modules but no particular package.\n+//\n+// The caller must not modify the returned list, but may append to it.\n+func LoadAllModules(ctx context.Context) []module.Version {\n+\tLoadModFile(ctx)\n+\tReloadBuildList()\n+\tWriteGoMod()\n+\treturn capVersionSlice(buildList)\n+}\n+\n+// Selected returns the selected version of the module with the given path, or\n+// the empty string if the given module has no selected version\n+// (either because it is not required or because it is the Target module).\n+func Selected(path string) (version string) {\n+\tif path == Target.Path {\n+\t\treturn \"\"\n+\t}\n+\tfor _, m := range buildList {\n+\t\tif m.Path == path {\n+\t\t\treturn m.Version\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+// EditBuildList edits the global build list by first adding every module in add\n+// to the existing build list, then adjusting versions (and adding or removing\n+// requirements as needed) until every module in mustSelect is selected at the\n+// given version.\n+//\n+// (Note that the newly-added modules might not be selected in the resulting\n+// build list: they could be lower than existing requirements or conflict with\n+// versions in mustSelect.)\n+//\n+// If the versions listed in mustSelect are mutually incompatible (due to one of\n+// the listed modules requiring a higher version of another), EditBuildList\n+// returns a *ConstraintError and leaves the build list in its previous state.\n+func EditBuildList(ctx context.Context, add, mustSelect []module.Version) error {\n+\tvar upgraded = capVersionSlice(buildList)\n+\tif len(add) > 0 {\n+\t\t// First, upgrade the build list with any additions.\n+\t\t// In theory we could just append the additions to the build list and let\n+\t\t// mvs.Downgrade take care of resolving the upgrades too, but the\n+\t\t// diagnostics from Upgrade are currently much better in case of errors.\n+\t\tvar err error\n+\t\tupgraded, err = mvs.Upgrade(Target, &mvsReqs{buildList: upgraded}, add...)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tdowngraded, err := mvs.Downgrade(Target, &mvsReqs{buildList: append(upgraded, mustSelect...)}, mustSelect...)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfinal, err := mvs.Upgrade(Target, &mvsReqs{buildList: downgraded}, mustSelect...)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tselected := make(map[string]module.Version, len(final))\n+\tfor _, m := range final {\n+\t\tselected[m.Path] = m\n+\t}\n+\tinconsistent := false\n+\tfor _, m := range mustSelect {\n+\t\ts, ok := selected[m.Path]\n+\t\tif !ok {\n+\t\t\tif m.Version != \"none\" {\n+\t\t\t\tpanic(fmt.Sprintf(\"internal error: mvs.BuildList lost %v\", m))\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif s.Version != m.Version {\n+\t\t\tinconsistent = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif !inconsistent {\n+\t\tbuildList = final\n+\t\treturn nil\n+\t}\n+\n+\t// We overshot one or more of the modules in mustSelected, which means that\n+\t// Downgrade removed something in mustSelect because it conflicted with\n+\t// something else in mustSelect.\n+\t//\n+\t// Walk the requirement graph to find the conflict.\n+\t//\n+\t// TODO(bcmills): Ideally, mvs.Downgrade (or a replacement for it) would do\n+\t// this directly.\n+\n+\treqs := &mvsReqs{buildList: final}\n+\treason := map[module.Version]module.Version{}\n+\tfor _, m := range mustSelect {\n+\t\treason[m] = m\n+\t}\n+\tqueue := mustSelect[:len(mustSelect):len(mustSelect)]\n+\tfor len(queue) > 0 {\n+\t\tvar m module.Version\n+\t\tm, queue = queue[0], queue[1:]\n+\t\trequired, err := reqs.Required(m)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor _, r := range required {\n+\t\t\tif _, ok := reason[r]; !ok {\n+\t\t\t\treason[r] = reason[m]\n+\t\t\t\tqueue = append(queue, r)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvar conflicts []Conflict\n+\tfor _, m := range mustSelect {\n+\t\ts, ok := selected[m.Path]\n+\t\tif !ok {\n+\t\t\tif m.Version != \"none\" {\n+\t\t\t\tpanic(fmt.Sprintf(\"internal error: mvs.BuildList lost %v\", m))\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif s.Version != m.Version {\n+\t\t\tconflicts = append(conflicts, Conflict{\n+\t\t\t\tSource:     reason[s],\n+\t\t\t\tDep:        s,\n+\t\t\t\tConstraint: m,\n+\t\t\t})\n+\t\t}\n+\t}\n+\n+\treturn &ConstraintError{\n+\t\tConflicts: conflicts,\n+\t}\n+}\n+\n+// A ConstraintError describes inconsistent constraints in EditBuildList\n+type ConstraintError struct {\n+\t// Conflict lists the source of the conflict for each version in mustSelect\n+\t// that could not be selected due to the requirements of some other version in\n+\t// mustSelect.\n+\tConflicts []Conflict\n+}\n+\n+func (e *ConstraintError) Error() string {\n+\tb := new(strings.Builder)\n+\tb.WriteString(\"version constraints conflict:\")\n+\tfor _, c := range e.Conflicts {\n+\t\tfmt.Fprintf(b, \"\\n\\t%v requires %v, but %v is requested\", c.Source, c.Dep, c.Constraint)\n+\t}\n+\treturn b.String()\n+}\n+\n+// A Conflict documents that Source requires Dep, which conflicts with Constraint.\n+// (That is, Dep has the same module path as Constraint but a higher version.)\n+type Conflict struct {\n+\tSource     module.Version\n+\tDep        module.Version\n+\tConstraint module.Version\n+}\n+\n+// ReloadBuildList resets the state of loaded packages, then loads and returns\n+// the build list set by EditBuildList.\n+func ReloadBuildList() []module.Version {\n+\tloaded = loadFromRoots(loaderParams{\n+\t\tPackageOpts: PackageOpts{\n+\t\t\tTags: imports.Tags(),\n+\t\t},\n+\t\tlistRoots:          func() []string { return nil },\n+\t\tallClosesOverTests: index.allPatternClosesOverTests(), // but doesn't matter because the root list is empty.\n+\t})\n+\treturn capVersionSlice(buildList)\n+}\n+\n+// TidyBuildList trims the build list to the minimal requirements needed to\n+// retain the same versions of all packages from the preceding call to\n+// LoadPackages.\n+func TidyBuildList() {\n+\tused := map[module.Version]bool{Target: true}\n+\tfor _, pkg := range loaded.pkgs {\n+\t\tused[pkg.mod] = true\n+\t}\n+\n+\tkeep := []module.Version{Target}\n+\tvar direct []string\n+\tfor _, m := range buildList[1:] {\n+\t\tif used[m] {\n+\t\t\tkeep = append(keep, m)\n+\t\t\tif loaded.direct[m.Path] {\n+\t\t\t\tdirect = append(direct, m.Path)\n+\t\t\t}\n+\t\t} else if cfg.BuildV {\n+\t\t\tif _, ok := index.require[m]; ok {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"unused %s\\n\", m.Path)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tmin, err := mvs.Req(Target, direct, &mvsReqs{buildList: keep})\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\tbuildList = append([]module.Version{Target}, min...)\n+}\n+\n+// checkMultiplePaths verifies that a given module path is used as itself\n+// or as a replacement for another module, but not both at the same time.\n+//\n+// (See https://golang.org/issue/26607 and https://golang.org/issue/34650.)\n+func checkMultiplePaths() {\n+\tfirstPath := make(map[module.Version]string, len(buildList))\n+\tfor _, mod := range buildList {\n+\t\tsrc := mod\n+\t\tif rep := Replacement(mod); rep.Path != \"\" {\n+\t\t\tsrc = rep\n+\t\t}\n+\t\tif prev, ok := firstPath[src]; !ok {\n+\t\t\tfirstPath[src] = mod.Path\n+\t\t} else if prev != mod.Path {\n+\t\t\tbase.Errorf(\"go: %s@%s used for two different module paths (%s and %s)\", src.Path, src.Version, prev, mod.Path)\n+\t\t}\n+\t}\n+\tbase.ExitIfErrors()\n+}"}, {"sha": "d81dfd56fb54153e6c2fffe9b9fd9f6035b3fe7e", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 45, "deletions": 52, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -124,72 +124,63 @@ and the build list. For example:\n \n Maintaining module requirements\n \n-The go.mod file is meant to be readable and editable by both\n-programmers and tools. The go command itself automatically updates the go.mod file\n-to maintain a standard formatting and the accuracy of require statements.\n-\n-Any go command that finds an unfamiliar import will look up the module\n-containing that import and add the latest version of that module\n-to go.mod automatically. In most cases, therefore, it suffices to\n-add an import to source code and run 'go build', 'go test', or even 'go list':\n-as part of analyzing the package, the go command will discover\n-and resolve the import and update the go.mod file.\n-\n-Any go command can determine that a module requirement is\n-missing and must be added, even when considering only a single\n-package from the module. On the other hand, determining that a module requirement\n-is no longer necessary and can be deleted requires a full view of\n-all packages in the module, across all possible build configurations\n-(architectures, operating systems, build tags, and so on).\n-The 'go mod tidy' command builds that view and then\n-adds any missing module requirements and removes unnecessary ones.\n+The go.mod file is meant to be readable and editable by both programmers and\n+tools. Most updates to dependencies can be performed using \"go get\" and\n+\"go mod tidy\". Other module-aware build commands may be invoked using the\n+-mod=mod flag to automatically add missing requirements and fix inconsistencies.\n+\n+The \"go get\" command updates go.mod to change the module versions used in a\n+build. An upgrade of one module may imply upgrading others, and similarly a\n+downgrade of one module may imply downgrading others. The \"go get\" command\n+makes these implied changes as well. See \"go help module-get\".\n+\n+The \"go mod\" command provides other functionality for use in maintaining\n+and understanding modules and go.mod files. See \"go help mod\", particularly\n+\"go help mod tidy\" and \"go help mod edit\".\n \n As part of maintaining the require statements in go.mod, the go command\n tracks which ones provide packages imported directly by the current module\n and which ones provide packages only used indirectly by other module\n dependencies. Requirements needed only for indirect uses are marked with a\n-\"// indirect\" comment in the go.mod file. Indirect requirements are\n+\"// indirect\" comment in the go.mod file. Indirect requirements may be\n automatically removed from the go.mod file once they are implied by other\n direct requirements. Indirect requirements only arise when using modules\n that fail to state some of their own dependencies or when explicitly\n upgrading a module's dependencies ahead of its own stated requirements.\n \n-Because of this automatic maintenance, the information in go.mod is an\n-up-to-date, readable description of the build.\n-\n-The 'go get' command updates go.mod to change the module versions used in a\n-build. An upgrade of one module may imply upgrading others, and similarly a\n-downgrade of one module may imply downgrading others. The 'go get' command\n-makes these implied changes as well. If go.mod is edited directly, commands\n-like 'go build' or 'go list' will assume that an upgrade is intended and\n-automatically make any implied upgrades and update go.mod to reflect them.\n-\n-The 'go mod' command provides other functionality for use in maintaining\n-and understanding modules and go.mod files. See 'go help mod'.\n-\n-The -mod build flag provides additional control over updating and use of go.mod.\n-\n-If invoked with -mod=readonly, the go command is disallowed from the implicit\n-automatic updating of go.mod described above. Instead, it fails when any changes\n-to go.mod are needed. This setting is most useful to check that go.mod does\n-not need updates, such as in a continuous integration and testing system.\n-The \"go get\" command remains permitted to update go.mod even with -mod=readonly,\n-and the \"go mod\" commands do not take the -mod flag (or any other build flags).\n+The -mod build flag provides additional control over the updating and use of\n+go.mod for commands that build packages like \"go build\" and \"go test\".\n+\n+If invoked with -mod=readonly (the default in most situations), the go command\n+reports an error if a package named on the command line or an imported package\n+is not provided by any module in the build list computed from the main module's\n+requirements. The go command also reports an error if a module's checksum is\n+missing from go.sum (see Module downloading and verification). Either go.mod or\n+go.sum must be updated in these situations.\n+\n+If invoked with -mod=mod, the go command automatically updates go.mod and\n+go.sum, fixing inconsistencies and adding missing requirements and checksums\n+as needed. If the go command finds an unfamiliar import, it looks up the\n+module containing that import and adds a requirement for the latest version\n+of that module to go.mod. In most cases, therefore, one may add an import to\n+source code and run \"go build\", \"go test\", or even \"go list\" with -mod=mod:\n+as part of analyzing the package, the go command will resolve the import and\n+update the go.mod file.\n \n If invoked with -mod=vendor, the go command loads packages from the main\n module's vendor directory instead of downloading modules to and loading packages\n from the module cache. The go command assumes the vendor directory holds\n correct copies of dependencies, and it does not compute the set of required\n module versions from go.mod files. However, the go command does check that\n-vendor/modules.txt (generated by 'go mod vendor') contains metadata consistent\n+vendor/modules.txt (generated by \"go mod vendor\") contains metadata consistent\n with go.mod.\n \n-If invoked with -mod=mod, the go command loads modules from the module cache\n-even if there is a vendor directory present.\n+If the go command is not invoked with a -mod flag, and the vendor directory\n+is present, and the \"go\" version in go.mod is 1.14 or higher, the go command\n+will act as if it were invoked with -mod=vendor. Otherwise, the -mod flag\n+defaults to -mod=readonly.\n \n-If the go command is not invoked with a -mod flag and the vendor directory\n-is present and the \"go\" version in go.mod is 1.14 or higher, the go command\n-will act as if it were invoked with -mod=vendor.\n+Note that neither \"go get\" nor the \"go mod\" subcommands accept the -mod flag.\n \n Pseudo-versions\n \n@@ -374,7 +365,7 @@ list if the error is a 404 or 410 HTTP response or if the current proxy is\n followed by a pipe character, indicating it is safe to fall back on any error.\n \n The GOPRIVATE and GONOPROXY environment variables allow bypassing\n-the proxy for selected modules. See 'go help module-private' for details.\n+the proxy for selected modules. See 'go help private' for details.\n \n No matter the source of the modules, the go command checks downloads against\n known checksums, to detect unexpected changes in the content of any specific\n@@ -432,21 +423,23 @@ verb followed by arguments. For example:\n \trequire new/thing/v2 v2.3.4\n \texclude old/thing v1.2.3\n \treplace bad/thing v1.4.5 => good/thing v1.4.5\n+\tretract v1.5.6\n \n The verbs are\n \tmodule, to define the module path;\n \tgo, to set the expected language version;\n \trequire, to require a particular module at a given version or later;\n-\texclude, to exclude a particular module version from use; and\n-\treplace, to replace a module version with a different module version.\n+\texclude, to exclude a particular module version from use;\n+\treplace, to replace a module version with a different module version; and\n+\tretract, to indicate a previously released version should not be used.\n Exclude and replace apply only in the main module's go.mod and are ignored\n-in dependencies.  See https://research.swtch.com/vgo-mvs for details.\n+in dependencies.  See https://golang.org/ref/mod for details.\n \n The leading verb can be factored out of adjacent lines to create a block,\n like in Go imports:\n \n \trequire (\n-\t\tnew/thing v2.3.4\n+\t\tnew/thing/v2 v2.3.4\n \t\told/thing v1.2.3\n \t)\n "}, {"sha": "ce5671728e00a760640d038e0f131124241a0217", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 248, "deletions": 132, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,18 +5,19 @@\n package modload\n \n import (\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"internal/goroot\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n-\t\"time\"\n \n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n@@ -30,23 +31,60 @@ type ImportMissingError struct {\n \tModule   module.Version\n \tQueryErr error\n \n+\t// inAll indicates whether Path is in the \"all\" package pattern,\n+\t// and thus would be added by 'go mod tidy'.\n+\tinAll bool\n+\n+\t// isStd indicates whether we would expect to find the package in the standard\n+\t// library. This is normally true for all dotless import paths, but replace\n+\t// directives can cause us to treat the replaced paths as also being in\n+\t// modules.\n+\tisStd bool\n+\n+\t// replaced the highest replaced version of the module where the replacement\n+\t// contains the package. replaced is only set if the replacement is unused.\n+\treplaced module.Version\n+\n \t// newMissingVersion is set to a newer version of Module if one is present\n \t// in the build list. When set, we can't automatically upgrade.\n \tnewMissingVersion string\n }\n \n-var _ load.ImportPathError = (*ImportMissingError)(nil)\n-\n func (e *ImportMissingError) Error() string {\n \tif e.Module.Path == \"\" {\n-\t\tif search.IsStandardImportPath(e.Path) {\n+\t\tif e.isStd {\n \t\t\treturn fmt.Sprintf(\"package %s is not in GOROOT (%s)\", e.Path, filepath.Join(cfg.GOROOT, \"src\", e.Path))\n \t\t}\n \t\tif e.QueryErr != nil {\n \t\t\treturn fmt.Sprintf(\"cannot find module providing package %s: %v\", e.Path, e.QueryErr)\n \t\t}\n-\t\treturn \"cannot find module providing package \" + e.Path\n+\t\tif cfg.BuildMod == \"mod\" {\n+\t\t\treturn \"cannot find module providing package \" + e.Path\n+\t\t}\n+\n+\t\tif e.replaced.Path != \"\" {\n+\t\t\tsuggestArg := e.replaced.Path\n+\t\t\tif !modfetch.IsZeroPseudoVersion(e.replaced.Version) {\n+\t\t\t\tsuggestArg = e.replaced.String()\n+\t\t\t}\n+\t\t\treturn fmt.Sprintf(\"module %s provides package %s and is replaced but not required; try 'go get -d %s' to add it\", e.replaced.Path, e.Path, suggestArg)\n+\t\t}\n+\n+\t\tsuggestion := \"\"\n+\t\tif !HasModRoot() {\n+\t\t\tsuggestion = \": working directory is not part of a module\"\n+\t\t} else if e.inAll {\n+\t\t\tsuggestion = \"; try 'go mod tidy' to add it\"\n+\t\t} else {\n+\t\t\tsuggestion = fmt.Sprintf(\"; try 'go get -d %s' to add it\", e.Path)\n+\t\t}\n+\t\treturn fmt.Sprintf(\"no required module provides package %s%s\", e.Path, suggestion)\n \t}\n+\n+\tif e.newMissingVersion != \"\" {\n+\t\treturn fmt.Sprintf(\"package %s provided by %s at latest version %s but not at required version %s\", e.Path, e.Module.Path, e.Module.Version, e.newMissingVersion)\n+\t}\n+\n \treturn fmt.Sprintf(\"missing module for import: %s@%s provides %s\", e.Module.Path, e.Module.Version, e.Path)\n }\n \n@@ -97,20 +135,62 @@ func (e *AmbiguousImportError) Error() string {\n \treturn buf.String()\n }\n \n-var _ load.ImportPathError = &AmbiguousImportError{}\n+// ImportMissingSumError is reported in readonly mode when we need to check\n+// if a module in the build list contains a package, but we don't have a sum\n+// for its .zip file.\n+type ImportMissingSumError struct {\n+\timportPath   string\n+\tfound, inAll bool\n+}\n \n-// Import finds the module and directory in the build list\n-// containing the package with the given import path.\n-// The answer must be unique: Import returns an error\n-// if multiple modules attempt to provide the same package.\n-// Import can return a module with an empty m.Path, for packages in the standard library.\n-// Import can return an empty directory string, for fake packages like \"C\" and \"unsafe\".\n+func (e *ImportMissingSumError) Error() string {\n+\tvar message string\n+\tif e.found {\n+\t\tmessage = fmt.Sprintf(\"missing go.sum entry needed to verify package %s is provided by exactly one module\", e.importPath)\n+\t} else {\n+\t\tmessage = fmt.Sprintf(\"missing go.sum entry for module providing package %s\", e.importPath)\n+\t}\n+\tif e.inAll {\n+\t\treturn message + \"; try 'go mod tidy' to add it\"\n+\t}\n+\treturn message\n+}\n+\n+func (e *ImportMissingSumError) ImportPath() string {\n+\treturn e.importPath\n+}\n+\n+type invalidImportError struct {\n+\timportPath string\n+\terr        error\n+}\n+\n+func (e *invalidImportError) ImportPath() string {\n+\treturn e.importPath\n+}\n+\n+func (e *invalidImportError) Error() string {\n+\treturn e.err.Error()\n+}\n+\n+func (e *invalidImportError) Unwrap() error {\n+\treturn e.err\n+}\n+\n+// importFromBuildList finds the module and directory in the build list\n+// containing the package with the given import path. The answer must be unique:\n+// importFromBuildList returns an error if multiple modules attempt to provide\n+// the same package.\n //\n-// If the package cannot be found in the current build list,\n-// Import returns an ImportMissingError as the error.\n-// If Import can identify a module that could be added to supply the package,\n-// the ImportMissingError records that module.\n-func Import(path string) (m module.Version, dir string, err error) {\n+// importFromBuildList can return a module with an empty m.Path, for packages in\n+// the standard library.\n+//\n+// importFromBuildList can return an empty directory string, for fake packages\n+// like \"C\" and \"unsafe\".\n+//\n+// If the package cannot be found in buildList,\n+// importFromBuildList returns an *ImportMissingError.\n+func importFromBuildList(ctx context.Context, path string, buildList []module.Version) (m module.Version, dir string, err error) {\n \tif strings.Contains(path, \"@\") {\n \t\treturn module.Version{}, \"\", fmt.Errorf(\"import path should not have @version\")\n \t}\n@@ -121,6 +201,10 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t// There's no directory for import \"C\" or import \"unsafe\".\n \t\treturn module.Version{}, \"\", nil\n \t}\n+\t// Before any further lookup, check that the path is valid.\n+\tif err := module.CheckImportPath(path); err != nil {\n+\t\treturn module.Version{}, \"\", &invalidImportError{importPath: path, err: err}\n+\t}\n \n \t// Is the package in the standard library?\n \tpathIsStd := search.IsStandardImportPath(path)\n@@ -160,13 +244,23 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t// Check each module on the build list.\n \tvar dirs []string\n \tvar mods []module.Version\n+\thaveSumErr := false\n \tfor _, m := range buildList {\n \t\tif !maybeInModule(path, m.Path) {\n \t\t\t// Avoid possibly downloading irrelevant modules.\n \t\t\tcontinue\n \t\t}\n-\t\troot, isLocal, err := fetch(m)\n+\t\tneedSum := true\n+\t\troot, isLocal, err := fetch(ctx, m, needSum)\n \t\tif err != nil {\n+\t\t\tif sumErr := (*sumMissingError)(nil); errors.As(err, &sumErr) {\n+\t\t\t\t// We are missing a sum needed to fetch a module in the build list.\n+\t\t\t\t// We can't verify that the package is unique, and we may not find\n+\t\t\t\t// the package at all. Keep checking other modules to decide which\n+\t\t\t\t// error to report.\n+\t\t\t\thaveSumErr = true\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\t// Report fetch error.\n \t\t\t// Note that we don't know for sure this module is necessary,\n \t\t\t// but it certainly _could_ provide the package, and even if we\n@@ -182,88 +276,76 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t\tdirs = append(dirs, dir)\n \t\t}\n \t}\n-\tif len(mods) == 1 {\n-\t\treturn mods[0], dirs[0], nil\n-\t}\n-\tif len(mods) > 0 {\n+\tif len(mods) > 1 {\n \t\treturn module.Version{}, \"\", &AmbiguousImportError{importPath: path, Dirs: dirs, Modules: mods}\n \t}\n-\n-\t// Look up module containing the package, for addition to the build list.\n-\t// Goal is to determine the module, download it to dir, and return m, dir, ErrMissing.\n-\tif cfg.BuildMod == \"readonly\" {\n-\t\tvar queryErr error\n-\t\tif !pathIsStd {\n-\t\t\tif cfg.BuildModReason == \"\" {\n-\t\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\", cfg.BuildMod)\n-\t\t\t} else {\n-\t\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\\n\\t(%s)\", cfg.BuildMod, cfg.BuildModReason)\n-\t\t\t}\n-\t\t}\n-\t\treturn module.Version{}, \"\", &ImportMissingError{Path: path, QueryErr: queryErr}\n+\tif haveSumErr {\n+\t\treturn module.Version{}, \"\", &ImportMissingSumError{importPath: path, found: len(mods) > 0}\n \t}\n-\tif modRoot == \"\" && !allowMissingModuleImports {\n-\t\treturn module.Version{}, \"\", &ImportMissingError{\n-\t\t\tPath:     path,\n-\t\t\tQueryErr: errors.New(\"working directory is not part of a module\"),\n-\t\t}\n+\tif len(mods) == 1 {\n+\t\treturn mods[0], dirs[0], nil\n \t}\n \n-\t// Not on build list.\n-\t// To avoid spurious remote fetches, next try the latest replacement for each module.\n-\t// (golang.org/issue/26241)\n-\tif modFile != nil {\n-\t\tlatest := map[string]string{} // path -> version\n-\t\tfor _, r := range modFile.Replace {\n-\t\t\tif maybeInModule(path, r.Old.Path) {\n-\t\t\t\t// Don't use semver.Max here; need to preserve +incompatible suffix.\n-\t\t\t\tv := latest[r.Old.Path]\n-\t\t\t\tif semver.Compare(r.Old.Version, v) > 0 {\n-\t\t\t\t\tv = r.Old.Version\n-\t\t\t\t}\n-\t\t\t\tlatest[r.Old.Path] = v\n-\t\t\t}\n-\t\t}\n+\treturn module.Version{}, \"\", &ImportMissingError{Path: path, isStd: pathIsStd}\n+}\n \n-\t\tmods = make([]module.Version, 0, len(latest))\n-\t\tfor p, v := range latest {\n-\t\t\t// If the replacement didn't specify a version, synthesize a\n-\t\t\t// pseudo-version with an appropriate major version and a timestamp below\n-\t\t\t// any real timestamp. That way, if the main module is used from within\n-\t\t\t// some other module, the user will be able to upgrade the requirement to\n-\t\t\t// any real version they choose.\n-\t\t\tif v == \"\" {\n-\t\t\t\tif _, pathMajor, ok := module.SplitPathVersion(p); ok && len(pathMajor) > 0 {\n-\t\t\t\t\tv = modfetch.PseudoVersion(pathMajor[1:], \"\", time.Time{}, \"000000000000\")\n+// queryImport attempts to locate a module that can be added to the current\n+// build list to provide the package with the given import path.\n+//\n+// Unlike QueryPattern, queryImport prefers to add a replaced version of a\n+// module *before* checking the proxies for a version to add.\n+func queryImport(ctx context.Context, path string) (module.Version, error) {\n+\t// To avoid spurious remote fetches, try the latest replacement for each\n+\t// module (golang.org/issue/26241).\n+\tif index != nil {\n+\t\tvar mods []module.Version\n+\t\tfor mp, mv := range index.highestReplaced {\n+\t\t\tif !maybeInModule(path, mp) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif mv == \"\" {\n+\t\t\t\t// The only replacement is a wildcard that doesn't specify a version, so\n+\t\t\t\t// synthesize a pseudo-version with an appropriate major version and a\n+\t\t\t\t// timestamp below any real timestamp. That way, if the main module is\n+\t\t\t\t// used from within some other module, the user will be able to upgrade\n+\t\t\t\t// the requirement to any real version they choose.\n+\t\t\t\tif _, pathMajor, ok := module.SplitPathVersion(mp); ok && len(pathMajor) > 0 {\n+\t\t\t\t\tmv = modfetch.ZeroPseudoVersion(pathMajor[1:])\n \t\t\t\t} else {\n-\t\t\t\t\tv = modfetch.PseudoVersion(\"v0\", \"\", time.Time{}, \"000000000000\")\n+\t\t\t\t\tmv = modfetch.ZeroPseudoVersion(\"v0\")\n \t\t\t\t}\n \t\t\t}\n-\t\t\tmods = append(mods, module.Version{Path: p, Version: v})\n+\t\t\tmods = append(mods, module.Version{Path: mp, Version: mv})\n \t\t}\n \n \t\t// Every module path in mods is a prefix of the import path.\n-\t\t// As in QueryPackage, prefer the longest prefix that satisfies the import.\n+\t\t// As in QueryPattern, prefer the longest prefix that satisfies the import.\n \t\tsort.Slice(mods, func(i, j int) bool {\n \t\t\treturn len(mods[i].Path) > len(mods[j].Path)\n \t\t})\n \t\tfor _, m := range mods {\n-\t\t\troot, isLocal, err := fetch(m)\n+\t\t\tneedSum := true\n+\t\t\troot, isLocal, err := fetch(ctx, m, needSum)\n \t\t\tif err != nil {\n-\t\t\t\t// Report fetch error as above.\n-\t\t\t\treturn module.Version{}, \"\", err\n+\t\t\t\tif sumErr := (*sumMissingError)(nil); errors.As(err, &sumErr) {\n+\t\t\t\t\treturn module.Version{}, &ImportMissingSumError{importPath: path}\n+\t\t\t\t}\n+\t\t\t\treturn module.Version{}, err\n \t\t\t}\n \t\t\tif _, ok, err := dirInModule(path, m.Path, root, isLocal); err != nil {\n-\t\t\t\treturn m, \"\", err\n+\t\t\t\treturn m, err\n \t\t\t} else if ok {\n-\t\t\t\treturn m, \"\", &ImportMissingError{Path: path, Module: m}\n+\t\t\t\tif cfg.BuildMod == \"readonly\" {\n+\t\t\t\t\treturn module.Version{}, &ImportMissingError{Path: path, replaced: m}\n+\t\t\t\t}\n+\t\t\t\treturn m, nil\n \t\t\t}\n \t\t}\n \t\tif len(mods) > 0 && module.CheckPath(path) != nil {\n \t\t\t// The package path is not valid to fetch remotely,\n-\t\t\t// so it can only exist if in a replaced module,\n+\t\t\t// so it can only exist in a replaced module,\n \t\t\t// and we know from the above loop that it is not.\n-\t\t\treturn module.Version{}, \"\", &PackageNotInModuleError{\n+\t\t\treturn module.Version{}, &PackageNotInModuleError{\n \t\t\t\tMod:         mods[0],\n \t\t\t\tQuery:       \"latest\",\n \t\t\t\tPattern:     path,\n@@ -272,50 +354,76 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t}\n \t}\n \n-\tif pathIsStd {\n+\tif search.IsStandardImportPath(path) {\n \t\t// This package isn't in the standard library, isn't in any module already\n \t\t// in the build list, and isn't in any other module that the user has\n \t\t// shimmed in via a \"replace\" directive.\n \t\t// Moreover, the import path is reserved for the standard library, so\n-\t\t// QueryPackage cannot possibly find a module containing this package.\n+\t\t// QueryPattern cannot possibly find a module containing this package.\n \t\t//\n-\t\t// Instead of trying QueryPackage, report an ImportMissingError immediately.\n-\t\treturn module.Version{}, \"\", &ImportMissingError{Path: path}\n+\t\t// Instead of trying QueryPattern, report an ImportMissingError immediately.\n+\t\treturn module.Version{}, &ImportMissingError{Path: path, isStd: true}\n+\t}\n+\n+\tif cfg.BuildMod == \"readonly\" {\n+\t\t// In readonly mode, we can't write go.mod, so we shouldn't try to look up\n+\t\t// the module. If readonly mode was enabled explicitly, include that in\n+\t\t// the error message.\n+\t\tvar queryErr error\n+\t\tif cfg.BuildModExplicit {\n+\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\", cfg.BuildMod)\n+\t\t} else if cfg.BuildModReason != \"\" {\n+\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\\n\\t(%s)\", cfg.BuildMod, cfg.BuildModReason)\n+\t\t}\n+\t\treturn module.Version{}, &ImportMissingError{Path: path, QueryErr: queryErr}\n \t}\n \n+\t// Look up module containing the package, for addition to the build list.\n+\t// Goal is to determine the module, download it to dir,\n+\t// and return m, dir, ImpportMissingError.\n \tfmt.Fprintf(os.Stderr, \"go: finding module for package %s\\n\", path)\n \n-\tcandidates, err := QueryPackage(path, \"latest\", Allowed)\n+\tcandidates, err := QueryPackages(ctx, path, \"latest\", Selected, CheckAllowed)\n \tif err != nil {\n-\t\tif errors.Is(err, os.ErrNotExist) {\n+\t\tif errors.Is(err, fs.ErrNotExist) {\n \t\t\t// Return \"cannot find module providing package [\u2026]\" instead of whatever\n-\t\t\t// low-level error QueryPackage produced.\n-\t\t\treturn module.Version{}, \"\", &ImportMissingError{Path: path, QueryErr: err}\n+\t\t\t// low-level error QueryPattern produced.\n+\t\t\treturn module.Version{}, &ImportMissingError{Path: path, QueryErr: err}\n \t\t} else {\n-\t\t\treturn module.Version{}, \"\", err\n+\t\t\treturn module.Version{}, err\n \t\t}\n \t}\n-\tm = candidates[0].Mod\n-\tnewMissingVersion := \"\"\n-\tfor _, c := range candidates {\n+\n+\tcandidate0MissingVersion := \"\"\n+\tfor i, c := range candidates {\n \t\tcm := c.Mod\n+\t\tcanAdd := true\n \t\tfor _, bm := range buildList {\n \t\t\tif bm.Path == cm.Path && semver.Compare(bm.Version, cm.Version) > 0 {\n-\t\t\t\t// QueryPackage proposed that we add module cm to provide the package,\n+\t\t\t\t// QueryPattern proposed that we add module cm to provide the package,\n \t\t\t\t// but we already depend on a newer version of that module (and we don't\n \t\t\t\t// have the package).\n \t\t\t\t//\n \t\t\t\t// This typically happens when a package is present at the \"@latest\"\n \t\t\t\t// version (e.g., v1.0.0) of a module, but we have a newer version\n \t\t\t\t// of the same module in the build list (e.g., v1.0.1-beta), and\n \t\t\t\t// the package is not present there.\n-\t\t\t\tm = cm\n-\t\t\t\tnewMissingVersion = bm.Version\n+\t\t\t\tcanAdd = false\n+\t\t\t\tif i == 0 {\n+\t\t\t\t\tcandidate0MissingVersion = bm.Version\n+\t\t\t\t}\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n+\t\tif canAdd {\n+\t\t\treturn cm, nil\n+\t\t}\n+\t}\n+\treturn module.Version{}, &ImportMissingError{\n+\t\tPath:              path,\n+\t\tModule:            candidates[0].Mod,\n+\t\tnewMissingVersion: candidate0MissingVersion,\n \t}\n-\treturn m, \"\", &ImportMissingError{Path: path, Module: m, newMissingVersion: newMissingVersion}\n }\n \n // maybeInModule reports whether, syntactically,\n@@ -369,7 +477,7 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n \tif isLocal {\n \t\tfor d := dir; d != mdir && len(d) > len(mdir); {\n \t\t\thaveGoMod := haveGoModCache.Do(d, func() interface{} {\n-\t\t\t\tfi, err := os.Stat(filepath.Join(d, \"go.mod\"))\n+\t\t\t\tfi, err := fsys.Stat(filepath.Join(d, \"go.mod\"))\n \t\t\t\treturn err == nil && !fi.IsDir()\n \t\t\t}).(bool)\n \n@@ -392,57 +500,65 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n \t// We don't care about build tags, not even \"+build ignore\".\n \t// We're just looking for a plausible directory.\n \tres := haveGoFilesCache.Do(dir, func() interface{} {\n-\t\tok, err := isDirWithGoFiles(dir)\n+\t\tok, err := fsys.IsDirWithGoFiles(dir)\n \t\treturn goFilesEntry{haveGoFiles: ok, err: err}\n \t}).(goFilesEntry)\n \n \treturn dir, res.haveGoFiles, res.err\n }\n \n-func isDirWithGoFiles(dir string) (bool, error) {\n-\tf, err := os.Open(dir)\n-\tif err != nil {\n-\t\tif os.IsNotExist(err) {\n-\t\t\treturn false, nil\n-\t\t}\n-\t\treturn false, err\n-\t}\n-\tdefer f.Close()\n-\n-\tnames, firstErr := f.Readdirnames(-1)\n-\tif firstErr != nil {\n-\t\tif fi, err := f.Stat(); err == nil && !fi.IsDir() {\n-\t\t\treturn false, nil\n-\t\t}\n-\n-\t\t// Rewrite the error from ReadDirNames to include the path if not present.\n-\t\t// See https://golang.org/issue/38923.\n-\t\tvar pe *os.PathError\n-\t\tif !errors.As(firstErr, &pe) {\n-\t\t\tfirstErr = &os.PathError{Op: \"readdir\", Path: dir, Err: firstErr}\n-\t\t}\n+// fetch downloads the given module (or its replacement)\n+// and returns its location.\n+//\n+// needSum indicates whether the module may be downloaded in readonly mode\n+// without a go.sum entry. It should only be false for modules fetched\n+// speculatively (for example, for incompatible version filtering). The sum\n+// will still be verified normally.\n+//\n+// The isLocal return value reports whether the replacement,\n+// if any, is local to the filesystem.\n+func fetch(ctx context.Context, mod module.Version, needSum bool) (dir string, isLocal bool, err error) {\n+\tif mod == Target {\n+\t\treturn ModRoot(), true, nil\n \t}\n-\n-\tfor _, name := range names {\n-\t\tif strings.HasSuffix(name, \".go\") {\n-\t\t\tinfo, err := os.Stat(filepath.Join(dir, name))\n-\t\t\tif err == nil && info.Mode().IsRegular() {\n-\t\t\t\t// If any .go source file exists, the package exists regardless of\n-\t\t\t\t// errors for other source files. Leave further error reporting for\n-\t\t\t\t// later.\n-\t\t\t\treturn true, nil\n+\tif r := Replacement(mod); r.Path != \"\" {\n+\t\tif r.Version == \"\" {\n+\t\t\tdir = r.Path\n+\t\t\tif !filepath.IsAbs(dir) {\n+\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n \t\t\t}\n-\t\t\tif firstErr == nil {\n+\t\t\t// Ensure that the replacement directory actually exists:\n+\t\t\t// dirInModule does not report errors for missing modules,\n+\t\t\t// so if we don't report the error now, later failures will be\n+\t\t\t// very mysterious.\n+\t\t\tif _, err := fsys.Stat(dir); err != nil {\n \t\t\t\tif os.IsNotExist(err) {\n-\t\t\t\t\t// If the file was concurrently deleted, or was a broken symlink,\n-\t\t\t\t\t// convert the error to an opaque error instead of one matching\n-\t\t\t\t\t// os.IsNotExist.\n-\t\t\t\t\terr = errors.New(err.Error())\n+\t\t\t\t\t// Semantically the module version itself \u201cexists\u201d \u2014 we just don't\n+\t\t\t\t\t// have its source code. Remove the equivalence to os.ErrNotExist,\n+\t\t\t\t\t// and make the message more concise while we're at it.\n+\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s does not exist\", r.Path)\n+\t\t\t\t} else {\n+\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s: %w\", r.Path, err)\n \t\t\t\t}\n-\t\t\t\tfirstErr = err\n+\t\t\t\treturn dir, true, module.VersionError(mod, err)\n \t\t\t}\n+\t\t\treturn dir, true, nil\n \t\t}\n+\t\tmod = r\n+\t}\n+\n+\tif cfg.BuildMod == \"readonly\" && needSum && !modfetch.HaveSum(mod) {\n+\t\treturn \"\", false, module.VersionError(mod, &sumMissingError{})\n \t}\n \n-\treturn false, firstErr\n+\tdir, err = modfetch.Download(ctx, mod)\n+\treturn dir, false, err\n+}\n+\n+type sumMissingError struct {\n+\tsuggestion string\n+}\n+\n+func (e *sumMissingError) Error() string {\n+\treturn \"missing go.sum entry\" + e.suggestion\n }"}, {"sha": "22d5b82e2116a48ce6f3a9567b320a52e1afe75d", "filename": "libgo/go/cmd/go/internal/modload/import_test.go", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,59 +5,86 @@\n package modload\n \n import (\n+\t\"context\"\n \t\"internal/testenv\"\n \t\"regexp\"\n \t\"strings\"\n \t\"testing\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n var importTests = []struct {\n \tpath string\n+\tm    module.Version\n \terr  string\n }{\n \t{\n \t\tpath: \"golang.org/x/net/context\",\n-\t\terr:  \"missing module for import: golang.org/x/net@.* provides golang.org/x/net/context\",\n+\t\tm: module.Version{\n+\t\t\tPath: \"golang.org/x/net\",\n+\t\t},\n \t},\n \t{\n \t\tpath: \"golang.org/x/net\",\n \t\terr:  `module golang.org/x/net@.* found \\(v0.0.0-.*\\), but does not contain package golang.org/x/net`,\n \t},\n \t{\n \t\tpath: \"golang.org/x/text\",\n-\t\terr:  \"missing module for import: golang.org/x/text@.* provides golang.org/x/text\",\n+\t\tm: module.Version{\n+\t\t\tPath: \"golang.org/x/text\",\n+\t\t},\n \t},\n \t{\n \t\tpath: \"github.com/rsc/quote/buggy\",\n-\t\terr:  \"missing module for import: github.com/rsc/quote@v1.5.2 provides github.com/rsc/quote/buggy\",\n+\t\tm: module.Version{\n+\t\t\tPath:    \"github.com/rsc/quote\",\n+\t\t\tVersion: \"v1.5.2\",\n+\t\t},\n \t},\n \t{\n \t\tpath: \"github.com/rsc/quote\",\n-\t\terr:  \"missing module for import: github.com/rsc/quote@v1.5.2 provides github.com/rsc/quote\",\n+\t\tm: module.Version{\n+\t\t\tPath:    \"github.com/rsc/quote\",\n+\t\t\tVersion: \"v1.5.2\",\n+\t\t},\n \t},\n \t{\n \t\tpath: \"golang.org/x/foo/bar\",\n \t\terr:  \"cannot find module providing package golang.org/x/foo/bar\",\n \t},\n }\n \n-func TestImport(t *testing.T) {\n+func TestQueryImport(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \ttestenv.MustHaveExecPath(t, \"git\")\n \tdefer func(old bool) {\n \t\tallowMissingModuleImports = old\n \t}(allowMissingModuleImports)\n \tAllowMissingModuleImports()\n \n+\tctx := context.Background()\n+\n \tfor _, tt := range importTests {\n \t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {\n \t\t\t// Note that there is no build list, so Import should always fail.\n-\t\t\tm, dir, err := Import(tt.path)\n-\t\t\tif err == nil {\n-\t\t\t\tt.Fatalf(\"Import(%q) = %v, %v, nil; expected error\", tt.path, m, dir)\n+\t\t\tm, err := queryImport(ctx, tt.path)\n+\n+\t\t\tif tt.err == \"\" {\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"queryImport(_, %q): %v\", tt.path, err)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tt.Fatalf(\"queryImport(_, %q) = %v, nil; expected error\", tt.path, m)\n+\t\t\t\t}\n+\t\t\t\tif !regexp.MustCompile(tt.err).MatchString(err.Error()) {\n+\t\t\t\t\tt.Fatalf(\"queryImport(_, %q): error %q, want error matching %#q\", tt.path, err, tt.err)\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tif !regexp.MustCompile(tt.err).MatchString(err.Error()) {\n-\t\t\t\tt.Fatalf(\"Import(%q): error %q, want error matching %#q\", tt.path, err, tt.err)\n+\n+\t\t\tif m.Path != tt.m.Path || (tt.m.Version != \"\" && m.Version != tt.m.Version) {\n+\t\t\t\tt.Errorf(\"queryImport(_, %q) = %v, _; want %v\", tt.path, m, tt.m)\n \t\t\t}\n \t\t})\n \t}"}, {"sha": "3f70d041451f1e1c8168ac6b53b7234b35461619", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 368, "deletions": 153, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -6,23 +6,22 @@ package modload\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"internal/lazyregexp\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n-\t\"runtime/debug\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modconv\"\n \t\"cmd/go/internal/modfetch\"\n@@ -35,8 +34,7 @@ import (\n )\n \n var (\n-\tmustUseModules = false\n-\tinitialized    bool\n+\tinitialized bool\n \n \tmodRoot string\n \tTarget  module.Version\n@@ -52,20 +50,42 @@ var (\n \n \tgopath string\n \n-\tCmdModInit   bool   // running 'go mod init'\n-\tCmdModModule string // module argument for 'go mod init'\n+\t// RootMode determines whether a module root is needed.\n+\tRootMode Root\n+\n+\t// ForceUseModules may be set to force modules to be enabled when\n+\t// GO111MODULE=auto or to report an error when GO111MODULE=off.\n+\tForceUseModules bool\n \n \tallowMissingModuleImports bool\n )\n \n+type Root int\n+\n+const (\n+\t// AutoRoot is the default for most commands. modload.Init will look for\n+\t// a go.mod file in the current directory or any parent. If none is found,\n+\t// modules may be disabled (GO111MODULE=on) or commands may run in a\n+\t// limited module mode.\n+\tAutoRoot Root = iota\n+\n+\t// NoRoot is used for commands that run in module mode and ignore any go.mod\n+\t// file the current directory or in parent directories.\n+\tNoRoot\n+\n+\t// NeedRoot is used for commands that must run in module mode and don't\n+\t// make sense without a main module.\n+\tNeedRoot\n+)\n+\n // ModFile returns the parsed go.mod file.\n //\n-// Note that after calling ImportPaths or LoadBuildList,\n+// Note that after calling LoadPackages or LoadAllModules,\n // the require statements in the modfile.File are no longer\n // the source of truth and will be ignored: edits made directly\n // will be lost at the next call to WriteGoMod.\n // To make permanent changes to the require statements\n-// in go.mod, edit it before calling ImportPaths or LoadBuildList.\n+// in go.mod, edit it before loading.\n func ModFile() *modfile.File {\n \tInit()\n \tif modFile == nil {\n@@ -92,19 +112,27 @@ func Init() {\n \t// Keep in sync with WillBeEnabled. We perform extra validation here, and\n \t// there are lots of diagnostics and side effects, so we can't use\n \t// WillBeEnabled directly.\n+\tvar mustUseModules bool\n \tenv := cfg.Getenv(\"GO111MODULE\")\n \tswitch env {\n \tdefault:\n \t\tbase.Fatalf(\"go: unknown environment setting GO111MODULE=%s\", env)\n-\tcase \"auto\", \"\":\n-\t\tmustUseModules = false\n-\tcase \"on\":\n+\tcase \"auto\":\n+\t\tmustUseModules = ForceUseModules\n+\tcase \"on\", \"\":\n \t\tmustUseModules = true\n \tcase \"off\":\n+\t\tif ForceUseModules {\n+\t\t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n+\t\t}\n \t\tmustUseModules = false\n \t\treturn\n \t}\n \n+\tif err := fsys.Init(base.Cwd); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\n \t// Disable any prompting for passwords by Git.\n \t// Only has an effect for 2.3.0 or later, but avoiding\n \t// the prompt in earlier versions is just too hard.\n@@ -132,15 +160,23 @@ func Init() {\n \t\tos.Setenv(\"GIT_SSH_COMMAND\", \"ssh -o ControlMaster=no\")\n \t}\n \n-\tif CmdModInit {\n-\t\t// Running 'go mod init': go.mod will be created in current directory.\n-\t\tmodRoot = base.Cwd\n+\tif modRoot != \"\" {\n+\t\t// modRoot set before Init was called (\"go mod init\" does this).\n+\t\t// No need to search for go.mod.\n+\t} else if RootMode == NoRoot {\n+\t\tif cfg.ModFile != \"\" && !base.InGOFLAGS(\"-modfile\") {\n+\t\t\tbase.Fatalf(\"go: -modfile cannot be used with commands that ignore the current module\")\n+\t\t}\n+\t\tmodRoot = \"\"\n \t} else {\n \t\tmodRoot = findModuleRoot(base.Cwd)\n \t\tif modRoot == \"\" {\n \t\t\tif cfg.ModFile != \"\" {\n \t\t\t\tbase.Fatalf(\"go: cannot find main module, but -modfile was set.\\n\\t-modfile cannot be used to set the module root directory.\")\n \t\t\t}\n+\t\t\tif RootMode == NeedRoot {\n+\t\t\t\tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n+\t\t\t}\n \t\t\tif !mustUseModules {\n \t\t\t\t// GO111MODULE is 'auto', and we can't find a module root.\n \t\t\t\t// Stay in GOPATH mode.\n@@ -154,38 +190,26 @@ func Init() {\n \t\t\t// when it happens. See golang.org/issue/26708.\n \t\t\tmodRoot = \"\"\n \t\t\tfmt.Fprintf(os.Stderr, \"go: warning: ignoring go.mod in system temp root %v\\n\", os.TempDir())\n+\t\t\tif !mustUseModules {\n+\t\t\t\treturn\n+\t\t\t}\n \t\t}\n \t}\n \tif cfg.ModFile != \"\" && !strings.HasSuffix(cfg.ModFile, \".mod\") {\n \t\tbase.Fatalf(\"go: -modfile=%s: file does not have .mod extension\", cfg.ModFile)\n \t}\n \n-\t// We're in module mode. Install the hooks to make it work.\n-\n-\tif c := cache.Default(); c == nil {\n-\t\t// With modules, there are no install locations for packages\n-\t\t// other than the build cache.\n-\t\tbase.Fatalf(\"go: cannot use modules with build cache disabled\")\n-\t}\n-\n+\t// We're in module mode. Set any global variables that need to be set.\n \tlist := filepath.SplitList(cfg.BuildContext.GOPATH)\n \tif len(list) == 0 || list[0] == \"\" {\n \t\tbase.Fatalf(\"missing $GOPATH\")\n \t}\n \tgopath = list[0]\n-\tif _, err := os.Stat(filepath.Join(gopath, \"go.mod\")); err == nil {\n+\tif _, err := fsys.Stat(filepath.Join(gopath, \"go.mod\")); err == nil {\n \t\tbase.Fatalf(\"$GOPATH/go.mod exists but should not\")\n \t}\n \n \tcfg.ModulesEnabled = true\n-\tload.ModBinDir = BinDir\n-\tload.ModLookup = Lookup\n-\tload.ModPackageModuleInfo = PackageModuleInfo\n-\tload.ModImportPaths = ImportPaths\n-\tload.ModPackageBuildInfo = PackageBuildInfo\n-\tload.ModInfoProg = ModInfoProg\n-\tload.ModImportFromFiles = ImportFromFiles\n-\tload.ModDirImportPath = DirImportPath\n \n \tif modRoot == \"\" {\n \t\t// We're in module mode, but not inside a module.\n@@ -211,10 +235,6 @@ func Init() {\n \t}\n }\n \n-func init() {\n-\tload.ModInit = Init\n-}\n-\n // WillBeEnabled checks whether modules should be enabled but does not\n // initialize modules by installing hooks. If Init has already been called,\n // WillBeEnabled returns the same result as Enabled.\n@@ -225,29 +245,27 @@ func init() {\n // be called until the command is installed and flags are parsed. Instead of\n // calling Init and Enabled, the main package can call this function.\n func WillBeEnabled() bool {\n-\tif modRoot != \"\" || mustUseModules {\n+\tif modRoot != \"\" || cfg.ModulesEnabled {\n+\t\t// Already enabled.\n \t\treturn true\n \t}\n \tif initialized {\n+\t\t// Initialized, not enabled.\n \t\treturn false\n \t}\n \n \t// Keep in sync with Init. Init does extra validation and prints warnings or\n \t// exits, so it can't call this function directly.\n \tenv := cfg.Getenv(\"GO111MODULE\")\n \tswitch env {\n-\tcase \"on\":\n+\tcase \"on\", \"\":\n \t\treturn true\n-\tcase \"auto\", \"\":\n+\tcase \"auto\":\n \t\tbreak\n \tdefault:\n \t\treturn false\n \t}\n \n-\tif CmdModInit {\n-\t\t// Running 'go mod init': go.mod will be created in current directory.\n-\t\treturn true\n-\t}\n \tif modRoot := findModuleRoot(base.Cwd); modRoot == \"\" {\n \t\t// GO111MODULE is 'auto', and we can't find a module root.\n \t\t// Stay in GOPATH mode.\n@@ -269,7 +287,7 @@ func WillBeEnabled() bool {\n // (usually through MustModRoot).\n func Enabled() bool {\n \tInit()\n-\treturn modRoot != \"\" || mustUseModules\n+\treturn modRoot != \"\" || cfg.ModulesEnabled\n }\n \n // ModRoot returns the root of the main module.\n@@ -303,16 +321,7 @@ func ModFilePath() string {\n \treturn filepath.Join(modRoot, \"go.mod\")\n }\n \n-// printStackInDie causes die to print a stack trace.\n-//\n-// It is enabled by the testgo tag, and helps to diagnose paths that\n-// unexpectedly require a main module.\n-var printStackInDie = false\n-\n func die() {\n-\tif printStackInDie {\n-\t\tdebug.PrintStack()\n-\t}\n \tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n \t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n \t}\n@@ -330,12 +339,16 @@ func die() {\n \tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n }\n \n-// InitMod sets Target and, if there is a main module, parses the initial build\n-// list from its go.mod file, creating and populating that file if needed.\n+// LoadModFile sets Target and, if there is a main module, parses the initial\n+// build list from its go.mod file.\n //\n-// As a side-effect, InitMod sets a default for cfg.BuildMod if it does not\n+// LoadModFile may make changes in memory, like adding a go directive and\n+// ensuring requirements are consistent. WriteGoMod should be called later to\n+// write changes out to disk or report errors in readonly mode.\n+//\n+// As a side-effect, LoadModFile sets a default for cfg.BuildMod if it does not\n // already have an explicit value.\n-func InitMod() {\n+func LoadModFile(ctx context.Context) {\n \tif len(buildList) > 0 {\n \t\treturn\n \t}\n@@ -348,63 +361,156 @@ func InitMod() {\n \t\treturn\n \t}\n \n-\tif CmdModInit {\n-\t\t// Running go mod init: do legacy module conversion\n-\t\tlegacyModInit()\n-\t\tmodFileToBuildList()\n-\t\tWriteGoMod()\n-\t\treturn\n-\t}\n-\n \tgomod := ModFilePath()\n \tdata, err := lockedfile.Read(gomod)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \tvar fixed bool\n-\tf, err := modfile.Parse(gomod, data, fixVersion(&fixed))\n+\tf, err := modfile.Parse(gomod, data, fixVersion(ctx, &fixed))\n \tif err != nil {\n \t\t// Errors returned by modfile.Parse begin with file:line.\n \t\tbase.Fatalf(\"go: errors parsing go.mod:\\n%s\\n\", err)\n \t}\n \tmodFile = f\n \tindex = indexModFile(data, f, fixed)\n \n-\tif len(f.Syntax.Stmt) == 0 || f.Module == nil {\n-\t\t// Empty mod file. Must add module path.\n-\t\tpath, err := findModulePath(modRoot)\n-\t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go: %v\", err)\n-\t\t}\n-\t\tf.AddModuleStmt(path)\n+\tif f.Module == nil {\n+\t\t// No module declaration. Must add module path.\n+\t\tbase.Fatalf(\"go: no module declaration in go.mod.\\n\\tRun 'go mod edit -module=example.com/mod' to specify the module path.\")\n \t}\n \n-\tif len(f.Syntax.Stmt) == 1 && f.Module != nil {\n-\t\t// Entire file is just a module statement.\n-\t\t// Populate require if possible.\n-\t\tlegacyModInit()\n+\tif err := checkModulePathLax(f.Module.Mod.Path); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tmodFileToBuildList()\n \tsetDefaultBuildMod()\n+\tmodFileToBuildList()\n \tif cfg.BuildMod == \"vendor\" {\n \t\treadVendorList()\n \t\tcheckVendorConsistency()\n-\t} else {\n-\t\t// TODO(golang.org/issue/33326): if cfg.BuildMod != \"readonly\"?\n-\t\tWriteGoMod()\n \t}\n }\n \n+// CreateModFile initializes a new module by creating a go.mod file.\n+//\n+// If modPath is empty, CreateModFile will attempt to infer the path from the\n+// directory location within GOPATH.\n+//\n+// If a vendoring configuration file is present, CreateModFile will attempt to\n+// translate it to go.mod directives. The resulting build list may not be\n+// exactly the same as in the legacy configuration (for example, we can't get\n+// packages at multiple versions from the same module).\n+func CreateModFile(ctx context.Context, modPath string) {\n+\tmodRoot = base.Cwd\n+\tInit()\n+\tmodFilePath := ModFilePath()\n+\tif _, err := fsys.Stat(modFilePath); err == nil {\n+\t\tbase.Fatalf(\"go: %s already exists\", modFilePath)\n+\t}\n+\n+\tif modPath == \"\" {\n+\t\tvar err error\n+\t\tmodPath, err = findModulePath(modRoot)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t}\n+\t} else if err := checkModulePathLax(modPath); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\n+\tfmt.Fprintf(os.Stderr, \"go: creating new go.mod: module %s\\n\", modPath)\n+\tmodFile = new(modfile.File)\n+\tmodFile.AddModuleStmt(modPath)\n+\taddGoStmt() // Add the go directive before converted module requirements.\n+\n+\tconvertedFrom, err := convertLegacyConfig(modPath)\n+\tif convertedFrom != \"\" {\n+\t\tfmt.Fprintf(os.Stderr, \"go: copying requirements from %s\\n\", base.ShortPath(convertedFrom))\n+\t}\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\n+\tmodFileToBuildList()\n+\tWriteGoMod()\n+\n+\t// Suggest running 'go mod tidy' unless the project is empty. Even if we\n+\t// imported all the correct requirements above, we're probably missing\n+\t// some sums, so the next build command in -mod=readonly will likely fail.\n+\t//\n+\t// We look for non-hidden .go files or subdirectories to determine whether\n+\t// this is an existing project. Walking the tree for packages would be more\n+\t// accurate, but could take much longer.\n+\tempty := true\n+\tfiles, _ := os.ReadDir(modRoot)\n+\tfor _, f := range files {\n+\t\tname := f.Name()\n+\t\tif strings.HasPrefix(name, \".\") || strings.HasPrefix(name, \"_\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasSuffix(name, \".go\") || f.IsDir() {\n+\t\t\tempty = false\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif !empty {\n+\t\tfmt.Fprintf(os.Stderr, \"go: run 'go mod tidy' to add module requirements and sums\\n\")\n+\t}\n+}\n+\n+// checkModulePathLax checks that the path meets some minimum requirements\n+// to avoid confusing users or the module cache. The requirements are weaker\n+// than those of module.CheckPath to allow room for weakening module path\n+// requirements in the future, but strong enough to help users avoid significant\n+// problems.\n+func checkModulePathLax(p string) error {\n+\t// TODO(matloob): Replace calls of this function in this CL with calls\n+\t// to module.CheckImportPath once it's been laxened, if it becomes laxened.\n+\t// See golang.org/issue/29101 for a discussion about whether to make CheckImportPath\n+\t// more lax or more strict.\n+\n+\terrorf := func(format string, args ...interface{}) error {\n+\t\treturn fmt.Errorf(\"invalid module path %q: %s\", p, fmt.Sprintf(format, args...))\n+\t}\n+\n+\t// Disallow shell characters \" ' * < > ? ` | to avoid triggering bugs\n+\t// with file systems and subcommands. Disallow file path separators : and \\\n+\t// because path separators other than / will confuse the module cache.\n+\t// See fileNameOK in golang.org/x/mod/module/module.go.\n+\tshellChars := \"`\" + `\\\"'*<>?|`\n+\tfsChars := `\\:`\n+\tif i := strings.IndexAny(p, shellChars); i >= 0 {\n+\t\treturn errorf(\"contains disallowed shell character %q\", p[i])\n+\t}\n+\tif i := strings.IndexAny(p, fsChars); i >= 0 {\n+\t\treturn errorf(\"contains disallowed path separator character %q\", p[i])\n+\t}\n+\n+\t// Ensure path.IsAbs and build.IsLocalImport are false, and that the path is\n+\t// invariant under path.Clean, also to avoid confusing the module cache.\n+\tif path.IsAbs(p) {\n+\t\treturn errorf(\"is an absolute path\")\n+\t}\n+\tif build.IsLocalImport(p) {\n+\t\treturn errorf(\"is a local import path\")\n+\t}\n+\tif path.Clean(p) != p {\n+\t\treturn errorf(\"is not clean\")\n+\t}\n+\n+\treturn nil\n+}\n+\n // fixVersion returns a modfile.VersionFixer implemented using the Query function.\n //\n // It resolves commit hashes and branch names to versions,\n // canonicalizes versions that appeared in early vgo drafts,\n // and does nothing for versions that already appear to be canonical.\n //\n // The VersionFixer sets 'fixed' if it ever returns a non-canonical version.\n-func fixVersion(fixed *bool) modfile.VersionFixer {\n+func fixVersion(ctx context.Context, fixed *bool) modfile.VersionFixer {\n \treturn func(path, vers string) (resolved string, err error) {\n \t\tdefer func() {\n \t\t\tif err == nil && resolved != vers {\n@@ -436,7 +542,7 @@ func fixVersion(fixed *bool) modfile.VersionFixer {\n \t\t\t}\n \t\t}\n \n-\t\tinfo, err := Query(path, vers, \"\", nil)\n+\t\tinfo, err := Query(ctx, path, vers, \"\", nil)\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n@@ -465,88 +571,78 @@ func modFileToBuildList() {\n \n \tlist := []module.Version{Target}\n \tfor _, r := range modFile.Require {\n-\t\tlist = append(list, r.Mod)\n+\t\tif index != nil && index.exclude[r.Mod] {\n+\t\t\tif cfg.BuildMod == \"mod\" {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: dropping requirement on excluded version %s %s\\n\", r.Mod.Path, r.Mod.Version)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: ignoring requirement on excluded version %s %s\\n\", r.Mod.Path, r.Mod.Version)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tlist = append(list, r.Mod)\n+\t\t}\n \t}\n \tbuildList = list\n }\n \n // setDefaultBuildMod sets a default value for cfg.BuildMod\n // if it is currently empty.\n func setDefaultBuildMod() {\n-\tif cfg.BuildMod != \"\" {\n+\tif cfg.BuildModExplicit {\n \t\t// Don't override an explicit '-mod=' argument.\n \t\treturn\n \t}\n-\tcfg.BuildMod = \"mod\"\n+\n \tif cfg.CmdName == \"get\" || strings.HasPrefix(cfg.CmdName, \"mod \") {\n-\t\t// Don't set -mod implicitly for commands whose purpose is to\n-\t\t// manipulate the build list.\n+\t\t// 'get' and 'go mod' commands may update go.mod automatically.\n+\t\t// TODO(jayconrod): should this narrower? Should 'go mod download' or\n+\t\t// 'go mod graph' update go.mod by default?\n+\t\tcfg.BuildMod = \"mod\"\n \t\treturn\n \t}\n \tif modRoot == \"\" {\n+\t\tcfg.BuildMod = \"readonly\"\n \t\treturn\n \t}\n \n-\tif fi, err := os.Stat(filepath.Join(modRoot, \"vendor\")); err == nil && fi.IsDir() {\n+\tif fi, err := fsys.Stat(filepath.Join(modRoot, \"vendor\")); err == nil && fi.IsDir() {\n \t\tmodGo := \"unspecified\"\n-\t\tif index.goVersion != \"\" {\n-\t\t\tif semver.Compare(\"v\"+index.goVersion, \"v1.14\") >= 0 {\n+\t\tif index.goVersionV != \"\" {\n+\t\t\tif semver.Compare(index.goVersionV, \"v1.14\") >= 0 {\n \t\t\t\t// The Go version is at least 1.14, and a vendor directory exists.\n \t\t\t\t// Set -mod=vendor by default.\n \t\t\t\tcfg.BuildMod = \"vendor\"\n \t\t\t\tcfg.BuildModReason = \"Go version in go.mod is at least 1.14 and vendor directory exists.\"\n \t\t\t\treturn\n \t\t\t} else {\n-\t\t\t\tmodGo = index.goVersion\n+\t\t\t\tmodGo = index.goVersionV[1:]\n \t\t\t}\n \t\t}\n \n-\t\t// Since a vendor directory exists, we have a non-trivial reason for\n-\t\t// choosing -mod=mod, although it probably won't be used for anything.\n-\t\t// Record the reason anyway for consistency.\n-\t\t// It may be overridden if we switch to mod=readonly below.\n-\t\tcfg.BuildModReason = fmt.Sprintf(\"Go version in go.mod is %s.\", modGo)\n+\t\t// Since a vendor directory exists, we should record why we didn't use it.\n+\t\t// This message won't normally be shown, but it may appear with import errors.\n+\t\tcfg.BuildModReason = fmt.Sprintf(\"Go version in go.mod is %s, so vendor directory was not used.\", modGo)\n \t}\n \n-\tp := ModFilePath()\n-\tif fi, err := os.Stat(p); err == nil && !hasWritePerm(p, fi) {\n-\t\tcfg.BuildMod = \"readonly\"\n-\t\tcfg.BuildModReason = \"go.mod file is read-only.\"\n-\t}\n+\tcfg.BuildMod = \"readonly\"\n }\n \n-func legacyModInit() {\n-\tif modFile == nil {\n-\t\tpath, err := findModulePath(modRoot)\n-\t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go: %v\", err)\n-\t\t}\n-\t\tfmt.Fprintf(os.Stderr, \"go: creating new go.mod: module %s\\n\", path)\n-\t\tmodFile = new(modfile.File)\n-\t\tmodFile.AddModuleStmt(path)\n-\t\taddGoStmt() // Add the go directive before converted module requirements.\n-\t}\n-\n+// convertLegacyConfig imports module requirements from a legacy vendoring\n+// configuration file, if one is present.\n+func convertLegacyConfig(modPath string) (from string, err error) {\n \tfor _, name := range altConfigs {\n \t\tcfg := filepath.Join(modRoot, name)\n-\t\tdata, err := ioutil.ReadFile(cfg)\n+\t\tdata, err := os.ReadFile(cfg)\n \t\tif err == nil {\n \t\t\tconvert := modconv.Converters[name]\n \t\t\tif convert == nil {\n-\t\t\t\treturn\n+\t\t\t\treturn \"\", nil\n \t\t\t}\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: copying requirements from %s\\n\", base.ShortPath(cfg))\n \t\t\tcfg = filepath.ToSlash(cfg)\n-\t\t\tif err := modconv.ConvertLegacyConfig(modFile, cfg, data); err != nil {\n-\t\t\t\tbase.Fatalf(\"go: %v\", err)\n-\t\t\t}\n-\t\t\tif len(modFile.Syntax.Stmt) == 1 {\n-\t\t\t\t// Add comment to avoid re-converting every time it runs.\n-\t\t\t\tmodFile.AddComment(\"// go: no requirements found in \" + name)\n-\t\t\t}\n-\t\t\treturn\n+\t\t\terr := modconv.ConvertLegacyConfig(modFile, cfg, data)\n+\t\t\treturn name, err\n \t\t}\n \t}\n+\treturn \"\", nil\n }\n \n // addGoStmt adds a go directive to the go.mod file if it does not already include one.\n@@ -588,7 +684,7 @@ func findModuleRoot(dir string) (root string) {\n \n \t// Look for enclosing go.mod.\n \tfor {\n-\t\tif fi, err := os.Stat(filepath.Join(dir, \"go.mod\")); err == nil && !fi.IsDir() {\n+\t\tif fi, err := fsys.Stat(filepath.Join(dir, \"go.mod\")); err == nil && !fi.IsDir() {\n \t\t\treturn dir\n \t\t}\n \t\td := filepath.Dir(dir)\n@@ -612,7 +708,7 @@ func findAltConfig(dir string) (root, name string) {\n \t}\n \tfor {\n \t\tfor _, name := range altConfigs {\n-\t\t\tif fi, err := os.Stat(filepath.Join(dir, name)); err == nil && !fi.IsDir() {\n+\t\t\tif fi, err := fsys.Stat(filepath.Join(dir, name)); err == nil && !fi.IsDir() {\n \t\t\t\treturn dir, name\n \t\t\t}\n \t\t}\n@@ -626,14 +722,6 @@ func findAltConfig(dir string) (root, name string) {\n }\n \n func findModulePath(dir string) (string, error) {\n-\tif CmdModModule != \"\" {\n-\t\t// Running go mod init x/y/z; return x/y/z.\n-\t\tif err := module.CheckImportPath(CmdModModule); err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\treturn CmdModModule, nil\n-\t}\n-\n \t// TODO(bcmills): once we have located a plausible module path, we should\n \t// query version control (if available) to verify that it matches the major\n \t// version of the most recent tag.\n@@ -642,19 +730,19 @@ func findModulePath(dir string) (string, error) {\n \n \t// Cast about for import comments,\n \t// first in top-level directory, then in subdirectories.\n-\tlist, _ := ioutil.ReadDir(dir)\n+\tlist, _ := os.ReadDir(dir)\n \tfor _, info := range list {\n-\t\tif info.Mode().IsRegular() && strings.HasSuffix(info.Name(), \".go\") {\n+\t\tif info.Type().IsRegular() && strings.HasSuffix(info.Name(), \".go\") {\n \t\t\tif com := findImportComment(filepath.Join(dir, info.Name())); com != \"\" {\n \t\t\t\treturn com, nil\n \t\t\t}\n \t\t}\n \t}\n \tfor _, info1 := range list {\n \t\tif info1.IsDir() {\n-\t\t\tfiles, _ := ioutil.ReadDir(filepath.Join(dir, info1.Name()))\n+\t\t\tfiles, _ := os.ReadDir(filepath.Join(dir, info1.Name()))\n \t\t\tfor _, info2 := range files {\n-\t\t\t\tif info2.Mode().IsRegular() && strings.HasSuffix(info2.Name(), \".go\") {\n+\t\t\t\tif info2.Type().IsRegular() && strings.HasSuffix(info2.Name(), \".go\") {\n \t\t\t\t\tif com := findImportComment(filepath.Join(dir, info1.Name(), info2.Name())); com != \"\" {\n \t\t\t\t\t\treturn path.Dir(com), nil\n \t\t\t\t\t}\n@@ -664,48 +752,67 @@ func findModulePath(dir string) (string, error) {\n \t}\n \n \t// Look for Godeps.json declaring import path.\n-\tdata, _ := ioutil.ReadFile(filepath.Join(dir, \"Godeps/Godeps.json\"))\n+\tdata, _ := os.ReadFile(filepath.Join(dir, \"Godeps/Godeps.json\"))\n \tvar cfg1 struct{ ImportPath string }\n \tjson.Unmarshal(data, &cfg1)\n \tif cfg1.ImportPath != \"\" {\n \t\treturn cfg1.ImportPath, nil\n \t}\n \n \t// Look for vendor.json declaring import path.\n-\tdata, _ = ioutil.ReadFile(filepath.Join(dir, \"vendor/vendor.json\"))\n+\tdata, _ = os.ReadFile(filepath.Join(dir, \"vendor/vendor.json\"))\n \tvar cfg2 struct{ RootPath string }\n \tjson.Unmarshal(data, &cfg2)\n \tif cfg2.RootPath != \"\" {\n \t\treturn cfg2.RootPath, nil\n \t}\n \n \t// Look for path in GOPATH.\n+\tvar badPathErr error\n \tfor _, gpdir := range filepath.SplitList(cfg.BuildContext.GOPATH) {\n \t\tif gpdir == \"\" {\n \t\t\tcontinue\n \t\t}\n \t\tif rel := search.InDir(dir, filepath.Join(gpdir, \"src\")); rel != \"\" && rel != \".\" {\n-\t\t\treturn filepath.ToSlash(rel), nil\n+\t\t\tpath := filepath.ToSlash(rel)\n+\t\t\t// TODO(matloob): replace this with module.CheckImportPath\n+\t\t\t// once it's been laxened.\n+\t\t\t// Only checkModulePathLax here. There are some unpublishable\n+\t\t\t// module names that are compatible with checkModulePathLax\n+\t\t\t// but they already work in GOPATH so don't break users\n+\t\t\t// trying to do a build with modules. gorelease will alert users\n+\t\t\t// publishing their modules to fix their paths.\n+\t\t\tif err := checkModulePathLax(path); err != nil {\n+\t\t\t\tbadPathErr = err\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\treturn path, nil\n \t\t}\n \t}\n \n-\tmsg := `cannot determine module path for source directory %s (outside GOPATH, module path must be specified)\n+\treason := \"outside GOPATH, module path must be specified\"\n+\tif badPathErr != nil {\n+\t\t// return a different error message if the module was in GOPATH, but\n+\t\t// the module path determined above would be an invalid path.\n+\t\treason = fmt.Sprintf(\"bad module path inferred from directory in GOPATH: %v\", badPathErr)\n+\t}\n+\tmsg := `cannot determine module path for source directory %s (%s)\n \n Example usage:\n \t'go mod init example.com/m' to initialize a v0 or v1 module\n \t'go mod init example.com/m/v2' to initialize a v2 module\n \n Run 'go help mod init' for more information.\n `\n-\treturn \"\", fmt.Errorf(msg, dir)\n+\treturn \"\", fmt.Errorf(msg, dir, reason)\n }\n \n var (\n \timportCommentRE = lazyregexp.New(`(?m)^package[ \\t]+[^ \\t\\r\\n/]+[ \\t]+//[ \\t]+import[ \\t]+(\\\"[^\"]+\\\")[ \\t]*\\r?\\n`)\n )\n \n func findImportComment(file string) string {\n-\tdata, err := ioutil.ReadFile(file)\n+\tdata, err := os.ReadFile(file)\n \tif err != nil {\n \t\treturn \"\"\n \t}\n@@ -745,7 +852,7 @@ func MinReqs() mvs.Reqs {\n \t\t\tretain = append(retain, m.Path)\n \t\t}\n \t}\n-\tmin, err := mvs.Req(Target, retain, Reqs())\n+\tmin, err := mvs.Req(Target, retain, &mvsReqs{buildList: buildList})\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n@@ -791,20 +898,23 @@ func WriteGoMod() {\n \tif dirty && cfg.BuildMod == \"readonly\" {\n \t\t// If we're about to fail due to -mod=readonly,\n \t\t// prefer to report a dirty go.mod over a dirty go.sum\n-\t\tif cfg.BuildModReason != \"\" {\n+\t\tif cfg.BuildModExplicit {\n+\t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n+\t\t} else if cfg.BuildModReason != \"\" {\n \t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\\n\\t(%s)\", cfg.BuildModReason)\n \t\t} else {\n-\t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n+\t\t\tbase.Fatalf(\"go: updates to go.mod needed; try 'go mod tidy' first\")\n \t\t}\n \t}\n-\t// Always update go.sum, even if we didn't change go.mod: we may have\n-\t// downloaded modules that we didn't have before.\n-\tmodfetch.WriteGoSum()\n \n \tif !dirty && cfg.CmdName != \"mod tidy\" {\n \t\t// The go.mod file has the same semantic content that it had before\n \t\t// (but not necessarily the same exact bytes).\n-\t\t// Ignore any intervening edits.\n+\t\t// Don't write go.mod, but write go.sum in case we added or trimmed sums.\n+\t\t// 'go mod init' shouldn't write go.sum, since it will be incomplete.\n+\t\tif cfg.CmdName != \"mod init\" {\n+\t\t\tmodfetch.WriteGoSum(keepSums(true))\n+\t\t}\n \t\treturn\n \t}\n \n@@ -815,6 +925,12 @@ func WriteGoMod() {\n \tdefer func() {\n \t\t// At this point we have determined to make the go.mod file on disk equal to new.\n \t\tindex = indexModFile(new, modFile, false)\n+\n+\t\t// Update go.sum after releasing the side lock and refreshing the index.\n+\t\t// 'go mod init' shouldn't write go.sum, since it will be incomplete.\n+\t\tif cfg.CmdName != \"mod init\" {\n+\t\t\tmodfetch.WriteGoSum(keepSums(true))\n+\t\t}\n \t}()\n \n \t// Make a best-effort attempt to acquire the side lock, only to exclude\n@@ -849,3 +965,102 @@ func WriteGoMod() {\n \t\tbase.Fatalf(\"go: updating go.mod: %v\", err)\n \t}\n }\n+\n+// keepSums returns a set of module sums to preserve in go.sum. The set\n+// includes entries for all modules used to load packages (according to\n+// the last load function such as LoadPackages or ImportFromFiles).\n+// It also contains entries for go.mod files needed for MVS (the version\n+// of these entries ends with \"/go.mod\").\n+//\n+// If addDirect is true, the set also includes sums for modules directly\n+// required by go.mod, as represented by the index, with replacements applied.\n+func keepSums(addDirect bool) map[module.Version]bool {\n+\t// Re-derive the build list using the current list of direct requirements.\n+\t// Keep the sum for the go.mod of each visited module version (or its\n+\t// replacement).\n+\tmodkey := func(m module.Version) module.Version {\n+\t\treturn module.Version{Path: m.Path, Version: m.Version + \"/go.mod\"}\n+\t}\n+\tkeep := make(map[module.Version]bool)\n+\tvar mu sync.Mutex\n+\treqs := &keepSumReqs{\n+\t\tReqs: &mvsReqs{buildList: buildList},\n+\t\tvisit: func(m module.Version) {\n+\t\t\t// If we build using a replacement module, keep the sum for the replacement,\n+\t\t\t// since that's the code we'll actually use during a build.\n+\t\t\tmu.Lock()\n+\t\t\tr := Replacement(m)\n+\t\t\tif r.Path == \"\" {\n+\t\t\t\tkeep[modkey(m)] = true\n+\t\t\t} else {\n+\t\t\t\tkeep[modkey(r)] = true\n+\t\t\t}\n+\t\t\tmu.Unlock()\n+\t\t},\n+\t}\n+\tbuildList, err := mvs.BuildList(Target, reqs)\n+\tif err != nil {\n+\t\tpanic(fmt.Sprintf(\"unexpected error reloading build list: %v\", err))\n+\t}\n+\n+\t// Add entries for modules in the build list with paths that are prefixes of\n+\t// paths of loaded packages. We need to retain sums for modules needed to\n+\t// report ambiguous import errors. We use our re-derived build list,\n+\t// since the global build list may have been tidied.\n+\tif loaded != nil {\n+\t\tactualMods := make(map[string]module.Version)\n+\t\tfor _, m := range buildList[1:] {\n+\t\t\tif r := Replacement(m); r.Path != \"\" {\n+\t\t\t\tactualMods[m.Path] = r\n+\t\t\t} else {\n+\t\t\t\tactualMods[m.Path] = m\n+\t\t\t}\n+\t\t}\n+\t\tfor _, pkg := range loaded.pkgs {\n+\t\t\tif pkg.testOf != nil || pkg.inStd || module.CheckImportPath(pkg.path) != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor prefix := pkg.path; prefix != \".\"; prefix = path.Dir(prefix) {\n+\t\t\t\tif m, ok := actualMods[prefix]; ok {\n+\t\t\t\t\tkeep[m] = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Add entries for modules directly required by go.mod.\n+\tif addDirect {\n+\t\tfor m := range index.require {\n+\t\t\tvar kept module.Version\n+\t\t\tif r := Replacement(m); r.Path != \"\" {\n+\t\t\t\tkept = r\n+\t\t\t} else {\n+\t\t\t\tkept = m\n+\t\t\t}\n+\t\t\tkeep[kept] = true\n+\t\t\tkeep[module.Version{Path: kept.Path, Version: kept.Version + \"/go.mod\"}] = true\n+\t\t}\n+\t}\n+\n+\treturn keep\n+}\n+\n+// keepSumReqs embeds another Reqs implementation. The Required method\n+// calls visit for each version in the module graph.\n+type keepSumReqs struct {\n+\tmvs.Reqs\n+\tvisit func(module.Version)\n+}\n+\n+func (r *keepSumReqs) Required(m module.Version) ([]module.Version, error) {\n+\tr.visit(m)\n+\treturn r.Reqs.Required(m)\n+}\n+\n+func TrimGoSum() {\n+\t// Don't retain sums for direct requirements in go.mod. When TrimGoSum is\n+\t// called, go.mod has not been updated, and it may contain requirements on\n+\t// modules deleted from the build list.\n+\taddDirect := false\n+\tmodfetch.TrimGoSum(keepSums(addDirect))\n+}"}, {"sha": "3491f941cd3b37c0f89809321e34add608e58c14", "filename": "libgo/go/cmd/go/internal/modload/list.go", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,47 +5,62 @@\n package modload\n \n import (\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"os\"\n+\t\"runtime\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modinfo\"\n-\t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n \n \t\"golang.org/x/mod/module\"\n )\n \n-func ListModules(args []string, listU, listVersions bool) []*modinfo.ModulePublic {\n-\tmods := listModules(args, listVersions)\n-\tif listU || listVersions {\n-\t\tvar work par.Work\n+func ListModules(ctx context.Context, args []string, listU, listVersions, listRetracted bool) []*modinfo.ModulePublic {\n+\tmods := listModules(ctx, args, listVersions, listRetracted)\n+\n+\ttype token struct{}\n+\tsem := make(chan token, runtime.GOMAXPROCS(0))\n+\tif listU || listVersions || listRetracted {\n \t\tfor _, m := range mods {\n-\t\t\twork.Add(m)\n+\t\t\tadd := func(m *modinfo.ModulePublic) {\n+\t\t\t\tsem <- token{}\n+\t\t\t\tgo func() {\n+\t\t\t\t\tif listU {\n+\t\t\t\t\t\taddUpdate(ctx, m)\n+\t\t\t\t\t}\n+\t\t\t\t\tif listVersions {\n+\t\t\t\t\t\taddVersions(ctx, m, listRetracted)\n+\t\t\t\t\t}\n+\t\t\t\t\tif listRetracted || listU {\n+\t\t\t\t\t\taddRetraction(ctx, m)\n+\t\t\t\t\t}\n+\t\t\t\t\t<-sem\n+\t\t\t\t}()\n+\t\t\t}\n+\n+\t\t\tadd(m)\n \t\t\tif m.Replace != nil {\n-\t\t\t\twork.Add(m.Replace)\n+\t\t\t\tadd(m.Replace)\n \t\t\t}\n \t\t}\n-\t\twork.Do(10, func(item interface{}) {\n-\t\t\tm := item.(*modinfo.ModulePublic)\n-\t\t\tif listU {\n-\t\t\t\taddUpdate(m)\n-\t\t\t}\n-\t\t\tif listVersions {\n-\t\t\t\taddVersions(m)\n-\t\t\t}\n-\t\t})\n \t}\n+\t// Fill semaphore channel to wait for all tasks to finish.\n+\tfor n := cap(sem); n > 0; n-- {\n+\t\tsem <- token{}\n+\t}\n+\n \treturn mods\n }\n \n-func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n-\tLoadBuildList()\n+func listModules(ctx context.Context, args []string, listVersions, listRetracted bool) []*modinfo.ModulePublic {\n+\tLoadAllModules(ctx)\n \tif len(args) == 0 {\n-\t\treturn []*modinfo.ModulePublic{moduleInfo(buildList[0], true)}\n+\t\treturn []*modinfo.ModulePublic{moduleInfo(ctx, buildList[0], true, listRetracted)}\n \t}\n \n \tvar mods []*modinfo.ModulePublic\n@@ -71,7 +86,13 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tinfo, err := Query(path, vers, current, nil)\n+\t\t\tallowed := CheckAllowed\n+\t\t\tif IsRevisionQuery(vers) || listRetracted {\n+\t\t\t\t// Allow excluded and retracted versions if the user asked for a\n+\t\t\t\t// specific revision or used 'go list -retracted'.\n+\t\t\t\tallowed = nil\n+\t\t\t}\n+\t\t\tinfo, err := Query(ctx, path, vers, current, allowed)\n \t\t\tif err != nil {\n \t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n \t\t\t\t\tPath:    path,\n@@ -80,7 +101,8 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\t\t})\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tmods = append(mods, moduleInfo(module.Version{Path: path, Version: info.Version}, false))\n+\t\t\tmod := moduleInfo(ctx, module.Version{Path: path, Version: info.Version}, false, listRetracted)\n+\t\t\tmods = append(mods, mod)\n \t\t\tcontinue\n \t\t}\n \n@@ -105,7 +127,7 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\t\tmatched = true\n \t\t\t\tif !matchedBuildList[i] {\n \t\t\t\t\tmatchedBuildList[i] = true\n-\t\t\t\t\tmods = append(mods, moduleInfo(m, true))\n+\t\t\t\t\tmods = append(mods, moduleInfo(ctx, m, true, listRetracted))\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -115,9 +137,10 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\t\t\t// Don't make the user provide an explicit '@latest' when they're\n \t\t\t\t\t// explicitly asking what the available versions are.\n \t\t\t\t\t// Instead, resolve the module, even if it isn't an existing dependency.\n-\t\t\t\t\tinfo, err := Query(arg, \"latest\", \"\", nil)\n+\t\t\t\t\tinfo, err := Query(ctx, arg, \"latest\", \"\", nil)\n \t\t\t\t\tif err == nil {\n-\t\t\t\t\t\tmods = append(mods, moduleInfo(module.Version{Path: arg, Version: info.Version}, false))\n+\t\t\t\t\t\tmod := moduleInfo(ctx, module.Version{Path: arg, Version: info.Version}, false, listRetracted)\n+\t\t\t\t\t\tmods = append(mods, mod)\n \t\t\t\t\t} else {\n \t\t\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n \t\t\t\t\t\t\tPath:  arg,"}, {"sha": "90e990d46c8094499d2309f9ed5c046e5bee14fc", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 680, "deletions": 379, "changes": 1059, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -4,63 +4,196 @@\n \n package modload\n \n+// This file contains the module-mode package loader, as well as some accessory\n+// functions pertaining to the package import graph.\n+//\n+// There are two exported entry points into package loading \u2014 LoadPackages and\n+// ImportFromFiles \u2014 both implemented in terms of loadFromRoots, which itself\n+// manipulates an instance of the loader struct.\n+//\n+// Although most of the loading state is maintained in the loader struct,\n+// one key piece - the build list - is a global, so that it can be modified\n+// separate from the loading operation, such as during \"go get\"\n+// upgrades/downgrades or in \"go mod\" operations.\n+// TODO(#40775): It might be nice to make the loader take and return\n+// a buildList rather than hard-coding use of the global.\n+//\n+// Loading is an iterative process. On each iteration, we try to load the\n+// requested packages and their transitive imports, then try to resolve modules\n+// for any imported packages that are still missing.\n+//\n+// The first step of each iteration identifies a set of \u201croot\u201d packages.\n+// Normally the root packages are exactly those matching the named pattern\n+// arguments. However, for the \"all\" meta-pattern, the final set of packages is\n+// computed from the package import graph, and therefore cannot be an initial\n+// input to loading that graph. Instead, the root packages for the \"all\" pattern\n+// are those contained in the main module, and allPatternIsRoot parameter to the\n+// loader instructs it to dynamically expand those roots to the full \"all\"\n+// pattern as loading progresses.\n+//\n+// The pkgInAll flag on each loadPkg instance tracks whether that\n+// package is known to match the \"all\" meta-pattern.\n+// A package matches the \"all\" pattern if:\n+// \t- it is in the main module, or\n+// \t- it is imported by any test in the main module, or\n+// \t- it is imported by another package in \"all\", or\n+// \t- the main module specifies a go version \u2264 1.15, and the package is imported\n+// \t  by a *test of* another package in \"all\".\n+//\n+// When we implement lazy loading, we will record the modules providing packages\n+// in \"all\" even when we are only loading individual packages, so we set the\n+// pkgInAll flag regardless of the whether the \"all\" pattern is a root.\n+// (This is necessary to maintain the \u201cimport invariant\u201d described in\n+// https://golang.org/design/36460-lazy-module-loading.)\n+//\n+// Because \"go mod vendor\" prunes out the tests of vendored packages, the\n+// behavior of the \"all\" pattern with -mod=vendor in Go 1.11\u20131.15 is the same\n+// as the \"all\" pattern (regardless of the -mod flag) in 1.16+.\n+// The allClosesOverTests parameter to the loader indicates whether the \"all\"\n+// pattern should close over tests (as in Go 1.11\u20131.15) or stop at only those\n+// packages transitively imported by the packages and tests in the main module\n+// (\"all\" in Go 1.16+ and \"go mod vendor\" in Go 1.11+).\n+//\n+// Note that it is possible for a loaded package NOT to be in \"all\" even when we\n+// are loading the \"all\" pattern. For example, packages that are transitive\n+// dependencies of other roots named on the command line must be loaded, but are\n+// not in \"all\". (The mod_notall test illustrates this behavior.)\n+// Similarly, if the LoadTests flag is set but the \"all\" pattern does not close\n+// over test dependencies, then when we load the test of a package that is in\n+// \"all\" but outside the main module, the dependencies of that test will not\n+// necessarily themselves be in \"all\". (That configuration does not arise in Go\n+// 1.11\u20131.15, but it will be possible in Go 1.16+.)\n+//\n+// Loading proceeds from the roots, using a parallel work-queue with a limit on\n+// the amount of active work (to avoid saturating disks, CPU cores, and/or\n+// network connections). Each package is added to the queue the first time it is\n+// imported by another package. When we have finished identifying the imports of\n+// a package, we add the test for that package if it is needed. A test may be\n+// needed if:\n+// \t- the package matches a root pattern and tests of the roots were requested, or\n+// \t- the package is in the main module and the \"all\" pattern is requested\n+// \t  (because the \"all\" pattern includes the dependencies of tests in the main\n+// \t  module), or\n+// \t- the package is in \"all\" and the definition of \"all\" we are using includes\n+// \t  dependencies of tests (as is the case in Go \u22641.15).\n+//\n+// After all available packages have been loaded, we examine the results to\n+// identify any requested or imported packages that are still missing, and if\n+// so, which modules we could add to the module graph in order to make the\n+// missing packages available. We add those to the module graph and iterate,\n+// until either all packages resolve successfully or we cannot identify any\n+// module that would resolve any remaining missing package.\n+//\n+// If the main module is \u201ctidy\u201d (that is, if \"go mod tidy\" is a no-op for it)\n+// and all requested packages are in \"all\", then loading completes in a single\n+// iteration.\n+// TODO(bcmills): We should also be able to load in a single iteration if the\n+// requested packages all come from modules that are themselves tidy, regardless\n+// of whether those packages are in \"all\". Today, that requires two iterations\n+// if those packages are not found in existing dependencies of the main module.\n+\n import (\n \t\"bytes\"\n-\t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/imports\"\n-\t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/mvs\"\n-\t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/str\"\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n+\t\"reflect\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/fsys\"\n+\t\"cmd/go/internal/imports\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/mvs\"\n+\t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/search\"\n+\t\"cmd/go/internal/str\"\n \n \t\"golang.org/x/mod/module\"\n )\n \n-// buildList is the list of modules to use for building packages.\n-// It is initialized by calling ImportPaths, ImportFromFiles,\n-// LoadALL, or LoadBuildList, each of which uses loaded.load.\n-//\n-// Ideally, exactly ONE of those functions would be called,\n-// and exactly once. Most of the time, that's true.\n-// During \"go get\" it may not be. TODO(rsc): Figure out if\n-// that restriction can be established, or else document why not.\n-//\n-var buildList []module.Version\n-\n // loaded is the most recently-used package loader.\n // It holds details about individual packages.\n-//\n-// Note that loaded.buildList is only valid during a load operation;\n-// afterward, it is copied back into the global buildList,\n-// which should be used instead.\n var loaded *loader\n \n-// ImportPaths returns the set of packages matching the args (patterns),\n-// on the target platform. Modules may be added to the build list\n-// to satisfy new imports.\n-func ImportPaths(patterns []string) []*search.Match {\n-\tmatches := ImportPathsQuiet(patterns, imports.Tags())\n-\tsearch.WarnUnmatched(matches)\n-\treturn matches\n+// PackageOpts control the behavior of the LoadPackages function.\n+type PackageOpts struct {\n+\t// Tags are the build tags in effect (as interpreted by the\n+\t// cmd/go/internal/imports package).\n+\t// If nil, treated as equivalent to imports.Tags().\n+\tTags map[string]bool\n+\n+\t// ResolveMissingImports indicates that we should attempt to add module\n+\t// dependencies as needed to resolve imports of packages that are not found.\n+\t//\n+\t// For commands that support the -mod flag, resolving imports may still fail\n+\t// if the flag is set to \"readonly\" (the default) or \"vendor\".\n+\tResolveMissingImports bool\n+\n+\t// AllowPackage, if non-nil, is called after identifying the module providing\n+\t// each package. If AllowPackage returns a non-nil error, that error is set\n+\t// for the package, and the imports and test of that package will not be\n+\t// loaded.\n+\t//\n+\t// AllowPackage may be invoked concurrently by multiple goroutines,\n+\t// and may be invoked multiple times for a given package path.\n+\tAllowPackage func(ctx context.Context, path string, mod module.Version) error\n+\n+\t// LoadTests loads the test dependencies of each package matching a requested\n+\t// pattern. If ResolveMissingImports is also true, test dependencies will be\n+\t// resolved if missing.\n+\tLoadTests bool\n+\n+\t// UseVendorAll causes the \"all\" package pattern to be interpreted as if\n+\t// running \"go mod vendor\" (or building with \"-mod=vendor\").\n+\t//\n+\t// This is a no-op for modules that declare 'go 1.16' or higher, for which this\n+\t// is the default (and only) interpretation of the \"all\" pattern in module mode.\n+\tUseVendorAll bool\n+\n+\t// AllowErrors indicates that LoadPackages should not terminate the process if\n+\t// an error occurs.\n+\tAllowErrors bool\n+\n+\t// SilenceErrors indicates that LoadPackages should not print errors\n+\t// that occur while loading packages. SilenceErrors implies AllowErrors.\n+\tSilenceErrors bool\n+\n+\t// SilenceUnmatchedWarnings suppresses the warnings normally emitted for\n+\t// patterns that did not match any packages.\n+\tSilenceUnmatchedWarnings bool\n }\n \n-// ImportPathsQuiet is like ImportPaths but does not warn about patterns with\n-// no matches. It also lets the caller specify a set of build tags to match\n-// packages. The build tags should typically be imports.Tags() or\n-// imports.AnyTags(); a nil map has no special meaning.\n-func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n-\tupdateMatches := func(matches []*search.Match, iterating bool) {\n+// LoadPackages identifies the set of packages matching the given patterns and\n+// loads the packages in the import graph rooted at that set.\n+func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (matches []*search.Match, loadedPackages []string) {\n+\tLoadModFile(ctx)\n+\tif opts.Tags == nil {\n+\t\topts.Tags = imports.Tags()\n+\t}\n+\n+\tpatterns = search.CleanPatterns(patterns)\n+\tmatches = make([]*search.Match, 0, len(patterns))\n+\tallPatternIsRoot := false\n+\tfor _, pattern := range patterns {\n+\t\tmatches = append(matches, search.NewMatch(pattern))\n+\t\tif pattern == \"all\" {\n+\t\t\tallPatternIsRoot = true\n+\t\t}\n+\t}\n+\n+\tupdateMatches := func(ld *loader) {\n \t\tfor _, m := range matches {\n \t\t\tswitch {\n \t\t\tcase m.IsLocal():\n@@ -87,7 +220,7 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \t\t\t\t\t\t// indicates that.\n \t\t\t\t\t\tModRoot()\n \n-\t\t\t\t\t\tif !iterating {\n+\t\t\t\t\t\tif ld != nil {\n \t\t\t\t\t\t\tm.AddError(err)\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcontinue\n@@ -100,19 +233,18 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \n \t\t\tcase strings.Contains(m.Pattern(), \"...\"):\n \t\t\t\tm.Errs = m.Errs[:0]\n-\t\t\t\tmatchPackages(m, loaded.tags, includeStd, buildList)\n+\t\t\t\tmatchPackages(ctx, m, opts.Tags, includeStd, buildList)\n \n \t\t\tcase m.Pattern() == \"all\":\n-\t\t\t\tloaded.testAll = true\n-\t\t\t\tif iterating {\n-\t\t\t\t\t// Enumerate the packages in the main module.\n-\t\t\t\t\t// We'll load the dependencies as we find them.\n+\t\t\t\tif ld == nil {\n+\t\t\t\t\t// The initial roots are the packages in the main module.\n+\t\t\t\t\t// loadFromRoots will expand that to \"all\".\n \t\t\t\t\tm.Errs = m.Errs[:0]\n-\t\t\t\t\tmatchPackages(m, loaded.tags, omitStd, []module.Version{Target})\n+\t\t\t\t\tmatchPackages(ctx, m, opts.Tags, omitStd, []module.Version{Target})\n \t\t\t\t} else {\n \t\t\t\t\t// Starting with the packages in the main module,\n \t\t\t\t\t// enumerate the full list of \"all\".\n-\t\t\t\t\tm.Pkgs = loaded.computePatternAll(m.Pkgs)\n+\t\t\t\t\tm.Pkgs = ld.computePatternAll()\n \t\t\t\t}\n \n \t\t\tcase m.Pattern() == \"std\" || m.Pattern() == \"cmd\":\n@@ -126,49 +258,71 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \t\t}\n \t}\n \n-\tInitMod()\n+\tloaded = loadFromRoots(loaderParams{\n+\t\tPackageOpts: opts,\n \n-\tvar matches []*search.Match\n-\tfor _, pattern := range search.CleanPatterns(patterns) {\n-\t\tmatches = append(matches, search.NewMatch(pattern))\n-\t}\n+\t\tallClosesOverTests: index.allPatternClosesOverTests() && !opts.UseVendorAll,\n+\t\tallPatternIsRoot:   allPatternIsRoot,\n \n-\tloaded = newLoader(tags)\n-\tloaded.load(func() []string {\n-\t\tvar roots []string\n-\t\tupdateMatches(matches, true)\n-\t\tfor _, m := range matches {\n-\t\t\troots = append(roots, m.Pkgs...)\n-\t\t}\n-\t\treturn roots\n+\t\tlistRoots: func() (roots []string) {\n+\t\t\tupdateMatches(nil)\n+\t\t\tfor _, m := range matches {\n+\t\t\t\troots = append(roots, m.Pkgs...)\n+\t\t\t}\n+\t\t\treturn roots\n+\t\t},\n \t})\n \n \t// One last pass to finalize wildcards.\n-\tupdateMatches(matches, false)\n-\tcheckMultiplePaths()\n-\tWriteGoMod()\n+\tupdateMatches(loaded)\n \n-\treturn matches\n-}\n+\t// Report errors, if any.\n+\tcheckMultiplePaths()\n+\tfor _, pkg := range loaded.pkgs {\n+\t\tif pkg.err != nil {\n+\t\t\tif pkg.flags.has(pkgInAll) {\n+\t\t\t\tif imErr := (*ImportMissingError)(nil); errors.As(pkg.err, &imErr) {\n+\t\t\t\t\timErr.inAll = true\n+\t\t\t\t} else if sumErr := (*ImportMissingSumError)(nil); errors.As(pkg.err, &sumErr) {\n+\t\t\t\t\tsumErr.inAll = true\n+\t\t\t\t}\n+\t\t\t}\n \n-// checkMultiplePaths verifies that a given module path is used as itself\n-// or as a replacement for another module, but not both at the same time.\n-//\n-// (See https://golang.org/issue/26607 and https://golang.org/issue/34650.)\n-func checkMultiplePaths() {\n-\tfirstPath := make(map[module.Version]string, len(buildList))\n-\tfor _, mod := range buildList {\n-\t\tsrc := mod\n-\t\tif rep := Replacement(mod); rep.Path != \"\" {\n-\t\t\tsrc = rep\n+\t\t\tif !opts.SilenceErrors {\n+\t\t\t\tif opts.AllowErrors {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: %v\\n\", pkg.stackText(), pkg.err)\n+\t\t\t\t} else {\n+\t\t\t\t\tbase.Errorf(\"%s: %v\", pkg.stackText(), pkg.err)\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tif prev, ok := firstPath[src]; !ok {\n-\t\t\tfirstPath[src] = mod.Path\n-\t\t} else if prev != mod.Path {\n-\t\t\tbase.Errorf(\"go: %s@%s used for two different module paths (%s and %s)\", src.Path, src.Version, prev, mod.Path)\n+\t\tif !pkg.isTest() {\n+\t\t\tloadedPackages = append(loadedPackages, pkg.path)\n+\t\t}\n+\t}\n+\tif !opts.SilenceErrors {\n+\t\t// Also list errors in matching patterns (such as directory permission\n+\t\t// errors for wildcard patterns).\n+\t\tfor _, match := range matches {\n+\t\t\tfor _, err := range match.Errs {\n+\t\t\t\tif opts.AllowErrors {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n+\t\t\t\t} else {\n+\t\t\t\t\tbase.Errorf(\"%v\", err)\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t}\n \tbase.ExitIfErrors()\n+\n+\tif !opts.SilenceUnmatchedWarnings {\n+\t\tsearch.WarnUnmatched(matches)\n+\t}\n+\n+\t// Success! Update go.mod (if needed) and return the results.\n+\tWriteGoMod()\n+\tsort.Strings(loadedPackages)\n+\treturn matches, loadedPackages\n }\n \n // matchLocalDirs is like m.MatchDirs, but tries to avoid scanning directories\n@@ -217,11 +371,11 @@ func resolveLocalPackage(dir string) (string, error) {\n \t\t// If the named directory does not exist or contains no Go files,\n \t\t// the package does not exist.\n \t\t// Other errors may affect package loading, but not resolution.\n-\t\tif _, err := os.Stat(absDir); err != nil {\n+\t\tif _, err := fsys.Stat(absDir); err != nil {\n \t\t\tif os.IsNotExist(err) {\n \t\t\t\t// Canonicalize OS-specific errors to errDirectoryNotFound so that error\n \t\t\t\t// messages will be easier for users to search for.\n-\t\t\t\treturn \"\", &os.PathError{Op: \"stat\", Path: absDir, Err: errDirectoryNotFound}\n+\t\t\t\treturn \"\", &fs.PathError{Op: \"stat\", Path: absDir, Err: errDirectoryNotFound}\n \t\t\t}\n \t\t\treturn \"\", err\n \t\t}\n@@ -307,7 +461,7 @@ var (\n // pathInModuleCache returns the import path of the directory dir,\n // if dir is in the module cache copy of a module in our build list.\n func pathInModuleCache(dir string) string {\n-\tfor _, m := range buildList[1:] {\n+\ttryMod := func(m module.Version) (string, bool) {\n \t\tvar root string\n \t\tvar err error\n \t\tif repl := Replacement(m); repl.Path != \"\" && repl.Version == \"\" {\n@@ -321,45 +475,64 @@ func pathInModuleCache(dir string) string {\n \t\t\troot, err = modfetch.DownloadDir(m)\n \t\t}\n \t\tif err != nil {\n-\t\t\tcontinue\n+\t\t\treturn \"\", false\n \t\t}\n-\t\tif sub := search.InDir(dir, root); sub != \"\" {\n-\t\t\tsub = filepath.ToSlash(sub)\n-\t\t\tif !strings.Contains(sub, \"/vendor/\") && !strings.HasPrefix(sub, \"vendor/\") && !strings.Contains(sub, \"@\") {\n-\t\t\t\treturn path.Join(m.Path, filepath.ToSlash(sub))\n-\t\t\t}\n+\n+\t\tsub := search.InDir(dir, root)\n+\t\tif sub == \"\" {\n+\t\t\treturn \"\", false\n+\t\t}\n+\t\tsub = filepath.ToSlash(sub)\n+\t\tif strings.Contains(sub, \"/vendor/\") || strings.HasPrefix(sub, \"vendor/\") || strings.Contains(sub, \"@\") {\n+\t\t\treturn \"\", false\n+\t\t}\n+\n+\t\treturn path.Join(m.Path, filepath.ToSlash(sub)), true\n+\t}\n+\n+\tfor _, m := range buildList[1:] {\n+\t\tif importPath, ok := tryMod(m); ok {\n+\t\t\t// checkMultiplePaths ensures that a module can be used for at most one\n+\t\t\t// requirement, so this must be it.\n+\t\t\treturn importPath\n \t\t}\n \t}\n \treturn \"\"\n }\n \n // ImportFromFiles adds modules to the build list as needed\n // to satisfy the imports in the named Go source files.\n-func ImportFromFiles(gofiles []string) {\n-\tInitMod()\n+func ImportFromFiles(ctx context.Context, gofiles []string) {\n+\tLoadModFile(ctx)\n \n \ttags := imports.Tags()\n \timports, testImports, err := imports.ScanFiles(gofiles, tags)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tloaded = newLoader(tags)\n-\tloaded.load(func() []string {\n-\t\tvar roots []string\n-\t\troots = append(roots, imports...)\n-\t\troots = append(roots, testImports...)\n-\t\treturn roots\n+\tloaded = loadFromRoots(loaderParams{\n+\t\tPackageOpts: PackageOpts{\n+\t\t\tTags:                  tags,\n+\t\t\tResolveMissingImports: true,\n+\t\t},\n+\t\tallClosesOverTests: index.allPatternClosesOverTests(),\n+\t\tlistRoots: func() (roots []string) {\n+\t\t\troots = append(roots, imports...)\n+\t\t\troots = append(roots, testImports...)\n+\t\t\treturn roots\n+\t\t},\n \t})\n \tWriteGoMod()\n }\n \n // DirImportPath returns the effective import path for dir,\n // provided it is within the main module, or else returns \".\".\n func DirImportPath(dir string) string {\n-\tif modRoot == \"\" {\n+\tif !HasModRoot() {\n \t\treturn \".\"\n \t}\n+\tLoadModFile(context.TODO())\n \n \tif !filepath.IsAbs(dir) {\n \t\tdir = filepath.Join(base.Cwd, dir)\n@@ -380,130 +553,20 @@ func DirImportPath(dir string) string {\n \treturn \".\"\n }\n \n-// LoadBuildList loads and returns the build list from go.mod.\n-// The loading of the build list happens automatically in ImportPaths:\n-// LoadBuildList need only be called if ImportPaths is not\n-// (typically in commands that care about the module but\n-// no particular package).\n-func LoadBuildList() []module.Version {\n-\tInitMod()\n-\tReloadBuildList()\n-\tWriteGoMod()\n-\treturn buildList\n-}\n-\n-func ReloadBuildList() []module.Version {\n-\tloaded = newLoader(imports.Tags())\n-\tloaded.load(func() []string { return nil })\n-\treturn buildList\n-}\n-\n-// LoadALL returns the set of all packages in the current module\n-// and their dependencies in any other modules, without filtering\n-// due to build tags, except \"+build ignore\".\n-// It adds modules to the build list as needed to satisfy new imports.\n-// This set is useful for deciding whether a particular import is needed\n-// anywhere in a module.\n-func LoadALL() []string {\n-\treturn loadAll(true)\n-}\n-\n-// LoadVendor is like LoadALL but only follows test dependencies\n-// for tests in the main module. Tests in dependency modules are\n-// ignored completely.\n-// This set is useful for identifying the which packages to include in a vendor directory.\n-func LoadVendor() []string {\n-\treturn loadAll(false)\n-}\n-\n-func loadAll(testAll bool) []string {\n-\tInitMod()\n-\n-\tloaded = newLoader(imports.AnyTags())\n-\tloaded.isALL = true\n-\tloaded.testAll = testAll\n-\tif !testAll {\n-\t\tloaded.testRoots = true\n-\t}\n-\tall := TargetPackages(\"...\")\n-\tloaded.load(func() []string { return all.Pkgs })\n-\tcheckMultiplePaths()\n-\tWriteGoMod()\n-\n-\tvar paths []string\n-\tfor _, pkg := range loaded.pkgs {\n-\t\tif pkg.err != nil {\n-\t\t\tbase.Errorf(\"%s: %v\", pkg.stackText(), pkg.err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tpaths = append(paths, pkg.path)\n-\t}\n-\tfor _, err := range all.Errs {\n-\t\tbase.Errorf(\"%v\", err)\n-\t}\n-\tbase.ExitIfErrors()\n-\treturn paths\n-}\n-\n // TargetPackages returns the list of packages in the target (top-level) module\n // matching pattern, which may be relative to the working directory, under all\n // build tag settings.\n-func TargetPackages(pattern string) *search.Match {\n+func TargetPackages(ctx context.Context, pattern string) *search.Match {\n \t// TargetPackages is relative to the main module, so ensure that the main\n \t// module is a thing that can contain packages.\n+\tLoadModFile(ctx)\n \tModRoot()\n \n \tm := search.NewMatch(pattern)\n-\tmatchPackages(m, imports.AnyTags(), omitStd, []module.Version{Target})\n+\tmatchPackages(ctx, m, imports.AnyTags(), omitStd, []module.Version{Target})\n \treturn m\n }\n \n-// BuildList returns the module build list,\n-// typically constructed by a previous call to\n-// LoadBuildList or ImportPaths.\n-// The caller must not modify the returned list.\n-func BuildList() []module.Version {\n-\treturn buildList\n-}\n-\n-// SetBuildList sets the module build list.\n-// The caller is responsible for ensuring that the list is valid.\n-// SetBuildList does not retain a reference to the original list.\n-func SetBuildList(list []module.Version) {\n-\tbuildList = append([]module.Version{}, list...)\n-}\n-\n-// TidyBuildList trims the build list to the minimal requirements needed to\n-// retain the same versions of all packages from the preceding Load* or\n-// ImportPaths* call.\n-func TidyBuildList() {\n-\tused := map[module.Version]bool{Target: true}\n-\tfor _, pkg := range loaded.pkgs {\n-\t\tused[pkg.mod] = true\n-\t}\n-\n-\tkeep := []module.Version{Target}\n-\tvar direct []string\n-\tfor _, m := range buildList[1:] {\n-\t\tif used[m] {\n-\t\t\tkeep = append(keep, m)\n-\t\t\tif loaded.direct[m.Path] {\n-\t\t\t\tdirect = append(direct, m.Path)\n-\t\t\t}\n-\t\t} else if cfg.BuildV {\n-\t\t\tif _, ok := index.require[m]; ok {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"unused %s\\n\", m.Path)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tmin, err := mvs.Req(Target, direct, &mvsReqs{buildList: keep})\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go: %v\", err)\n-\t}\n-\tbuildList = append([]module.Version{Target}, min...)\n-}\n-\n // ImportMap returns the actual package import path\n // for an import path found in source code.\n // If the given import path does not appear in the source code\n@@ -558,12 +621,6 @@ func PackageImports(path string) (imports, testImports []string) {\n \treturn imports, testImports\n }\n \n-// ModuleUsedDirectly reports whether the main module directly imports\n-// some package in the module with the given path.\n-func ModuleUsedDirectly(path string) bool {\n-\treturn loaded.direct[path]\n-}\n-\n // Lookup returns the source directory, import path, and any loading error for\n // the package at path as imported from the package in parentDir.\n // Lookup requires that one of the Load functions in this package has already\n@@ -599,129 +656,193 @@ func Lookup(parentPath string, parentIsStd bool, path string) (dir, realPath str\n // the required packages for a particular build,\n // checking that the packages are available in the module set,\n // and updating the module set if needed.\n-// Loading is an iterative process: try to load all the needed packages,\n-// but if imports are missing, try to resolve those imports, and repeat.\n-//\n-// Although most of the loading state is maintained in the loader struct,\n-// one key piece - the build list - is a global, so that it can be modified\n-// separate from the loading operation, such as during \"go get\"\n-// upgrades/downgrades or in \"go mod\" operations.\n-// TODO(rsc): It might be nice to make the loader take and return\n-// a buildList rather than hard-coding use of the global.\n type loader struct {\n-\ttags           map[string]bool // tags for scanDir\n-\ttestRoots      bool            // include tests for roots\n-\tisALL          bool            // created with LoadALL\n-\ttestAll        bool            // include tests for all packages\n-\tforceStdVendor bool            // if true, load standard-library dependencies from the vendor subtree\n+\tloaderParams\n+\n+\twork *par.Queue\n \n \t// reset on each iteration\n \troots    []*loadPkg\n-\tpkgs     []*loadPkg\n-\twork     *par.Work  // current work queue\n-\tpkgCache *par.Cache // map from string to *loadPkg\n+\tpkgCache *par.Cache // package path (string) \u2192 *loadPkg\n+\tpkgs     []*loadPkg // transitive closure of loaded packages and tests; populated in buildStacks\n \n \t// computed at end of iterations\n-\tdirect    map[string]bool   // imported directly by main module\n-\tgoVersion map[string]string // go version recorded in each module\n+\tdirect map[string]bool // imported directly by main module\n }\n \n-// LoadTests controls whether the loaders load tests of the root packages.\n-var LoadTests bool\n-\n-func newLoader(tags map[string]bool) *loader {\n-\tld := new(loader)\n-\tld.tags = tags\n-\tld.testRoots = LoadTests\n+// loaderParams configure the packages loaded by, and the properties reported\n+// by, a loader instance.\n+type loaderParams struct {\n+\tPackageOpts\n \n-\t// Inside the \"std\" and \"cmd\" modules, we prefer to use the vendor directory\n-\t// unless the command explicitly changes the module graph.\n-\tif !targetInGorootSrc || (cfg.CmdName != \"get\" && !strings.HasPrefix(cfg.CmdName, \"mod \")) {\n-\t\tld.forceStdVendor = true\n-\t}\n+\tallClosesOverTests bool // Does the \"all\" pattern include the transitive closure of tests of packages in \"all\"?\n+\tallPatternIsRoot   bool // Is the \"all\" pattern an additional root?\n \n-\treturn ld\n+\tlistRoots func() []string\n }\n \n func (ld *loader) reset() {\n+\tselect {\n+\tcase <-ld.work.Idle():\n+\tdefault:\n+\t\tpanic(\"loader.reset when not idle\")\n+\t}\n+\n \tld.roots = nil\n-\tld.pkgs = nil\n-\tld.work = new(par.Work)\n \tld.pkgCache = new(par.Cache)\n+\tld.pkgs = nil\n }\n \n // A loadPkg records information about a single loaded package.\n type loadPkg struct {\n-\tpath        string         // import path\n+\t// Populated at construction time:\n+\tpath   string // import path\n+\ttestOf *loadPkg\n+\n+\t// Populated at construction time and updated by (*loader).applyPkgFlags:\n+\tflags atomicLoadPkgFlags\n+\n+\t// Populated by (*loader).load:\n \tmod         module.Version // module providing package\n \tdir         string         // directory containing source code\n-\timports     []*loadPkg     // packages imported by this one\n \terr         error          // error loading package\n-\tstack       *loadPkg       // package importing this one in minimal import stack for this pkg\n-\ttest        *loadPkg       // package with test imports, if we need test\n-\ttestOf      *loadPkg\n-\ttestImports []string // test-only imports, saved for use by pkg.test.\n+\timports     []*loadPkg     // packages imported by this one\n+\ttestImports []string       // test-only imports, saved for use by pkg.test.\n+\tinStd       bool\n+\n+\t// Populated by (*loader).pkgTest:\n+\ttestOnce sync.Once\n+\ttest     *loadPkg\n+\n+\t// Populated by postprocessing in (*loader).buildStacks:\n+\tstack *loadPkg // package importing this one in minimal import stack for this pkg\n+}\n+\n+// loadPkgFlags is a set of flags tracking metadata about a package.\n+type loadPkgFlags int8\n+\n+const (\n+\t// pkgInAll indicates that the package is in the \"all\" package pattern,\n+\t// regardless of whether we are loading the \"all\" package pattern.\n+\t//\n+\t// When the pkgInAll flag and pkgImportsLoaded flags are both set, the caller\n+\t// who set the last of those flags must propagate the pkgInAll marking to all\n+\t// of the imports of the marked package.\n+\t//\n+\t// A test is marked with pkgInAll if that test would promote the packages it\n+\t// imports to be in \"all\" (such as when the test is itself within the main\n+\t// module, or when ld.allClosesOverTests is true).\n+\tpkgInAll loadPkgFlags = 1 << iota\n+\n+\t// pkgIsRoot indicates that the package matches one of the root package\n+\t// patterns requested by the caller.\n+\t//\n+\t// If LoadTests is set, then when pkgIsRoot and pkgImportsLoaded are both set,\n+\t// the caller who set the last of those flags must populate a test for the\n+\t// package (in the pkg.test field).\n+\t//\n+\t// If the \"all\" pattern is included as a root, then non-test packages in \"all\"\n+\t// are also roots (and must be marked pkgIsRoot).\n+\tpkgIsRoot\n+\n+\t// pkgImportsLoaded indicates that the imports and testImports fields of a\n+\t// loadPkg have been populated.\n+\tpkgImportsLoaded\n+)\n+\n+// has reports whether all of the flags in cond are set in f.\n+func (f loadPkgFlags) has(cond loadPkgFlags) bool {\n+\treturn f&cond == cond\n+}\n+\n+// An atomicLoadPkgFlags stores a loadPkgFlags for which individual flags can be\n+// added atomically.\n+type atomicLoadPkgFlags struct {\n+\tbits int32\n+}\n+\n+// update sets the given flags in af (in addition to any flags already set).\n+//\n+// update returns the previous flag state so that the caller may determine which\n+// flags were newly-set.\n+func (af *atomicLoadPkgFlags) update(flags loadPkgFlags) (old loadPkgFlags) {\n+\tfor {\n+\t\told := atomic.LoadInt32(&af.bits)\n+\t\tnew := old | int32(flags)\n+\t\tif new == old || atomic.CompareAndSwapInt32(&af.bits, old, new) {\n+\t\t\treturn loadPkgFlags(old)\n+\t\t}\n+\t}\n+}\n+\n+// has reports whether all of the flags in cond are set in af.\n+func (af *atomicLoadPkgFlags) has(cond loadPkgFlags) bool {\n+\treturn loadPkgFlags(atomic.LoadInt32(&af.bits))&cond == cond\n+}\n+\n+// isTest reports whether pkg is a test of another package.\n+func (pkg *loadPkg) isTest() bool {\n+\treturn pkg.testOf != nil\n }\n \n var errMissing = errors.New(\"cannot find package\")\n \n-// load attempts to load the build graph needed to process a set of root packages.\n-// The set of root packages is defined by the addRoots function,\n-// which must call add(path) with the import path of each root package.\n-func (ld *loader) load(roots func() []string) {\n+// loadFromRoots attempts to load the build graph needed to process a set of\n+// root packages and their dependencies.\n+//\n+// The set of root packages is returned by the params.listRoots function, and\n+// expanded to the full set of packages by tracing imports (and possibly tests)\n+// as needed.\n+func loadFromRoots(params loaderParams) *loader {\n+\tld := &loader{\n+\t\tloaderParams: params,\n+\t\twork:         par.NewQueue(runtime.GOMAXPROCS(0)),\n+\t}\n+\n \tvar err error\n-\treqs := Reqs()\n+\treqs := &mvsReqs{buildList: buildList}\n \tbuildList, err = mvs.BuildList(Target, reqs)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tadded := make(map[string]bool)\n+\taddedModuleFor := make(map[string]bool)\n \tfor {\n \t\tld.reset()\n-\t\tif roots != nil {\n-\t\t\t// Note: the returned roots can change on each iteration,\n-\t\t\t// since the expansion of package patterns depends on the\n-\t\t\t// build list we're using.\n-\t\t\tfor _, path := range roots() {\n-\t\t\t\tld.work.Add(ld.pkg(path, true))\n+\n+\t\t// Load the root packages and their imports.\n+\t\t// Note: the returned roots can change on each iteration,\n+\t\t// since the expansion of package patterns depends on the\n+\t\t// build list we're using.\n+\t\tinRoots := map[*loadPkg]bool{}\n+\t\tfor _, path := range ld.listRoots() {\n+\t\t\troot := ld.pkg(path, pkgIsRoot)\n+\t\t\tif !inRoots[root] {\n+\t\t\t\tld.roots = append(ld.roots, root)\n+\t\t\t\tinRoots[root] = true\n \t\t\t}\n \t\t}\n-\t\tld.work.Do(10, ld.doPkg)\n+\n+\t\t// ld.pkg adds imported packages to the work queue and calls applyPkgFlags,\n+\t\t// which adds tests (and test dependencies) as needed.\n+\t\t//\n+\t\t// When all of the work in the queue has completed, we'll know that the\n+\t\t// transitive closure of dependencies has been loaded.\n+\t\t<-ld.work.Idle()\n+\n \t\tld.buildStacks()\n-\t\tnumAdded := 0\n-\t\thaveMod := make(map[module.Version]bool)\n-\t\tfor _, m := range buildList {\n-\t\t\thaveMod[m] = true\n-\t\t}\n-\t\tmodAddedBy := make(map[module.Version]*loadPkg)\n-\t\tfor _, pkg := range ld.pkgs {\n-\t\t\tif err, ok := pkg.err.(*ImportMissingError); ok && err.Module.Path != \"\" {\n-\t\t\t\tif err.newMissingVersion != \"\" {\n-\t\t\t\t\tbase.Fatalf(\"go: %s: package provided by %s at latest version %s but not at required version %s\", pkg.stackText(), err.Module.Path, err.Module.Version, err.newMissingVersion)\n-\t\t\t\t}\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: found %s in %s %s\\n\", pkg.path, err.Module.Path, err.Module.Version)\n-\t\t\t\tif added[pkg.path] {\n-\t\t\t\t\tbase.Fatalf(\"go: %s: looping trying to add package\", pkg.stackText())\n-\t\t\t\t}\n-\t\t\t\tadded[pkg.path] = true\n-\t\t\t\tnumAdded++\n-\t\t\t\tif !haveMod[err.Module] {\n-\t\t\t\t\thaveMod[err.Module] = true\n-\t\t\t\t\tmodAddedBy[err.Module] = pkg\n-\t\t\t\t\tbuildList = append(buildList, err.Module)\n-\t\t\t\t}\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\t// Leave other errors for Import or load.Packages to report.\n+\n+\t\tif !ld.ResolveMissingImports || (!HasModRoot() && !allowMissingModuleImports) {\n+\t\t\t// We've loaded as much as we can without resolving missing imports.\n+\t\t\tbreak\n \t\t}\n-\t\tbase.ExitIfErrors()\n-\t\tif numAdded == 0 {\n+\t\tmodAddedBy := ld.resolveMissingImports(addedModuleFor)\n+\t\tif len(modAddedBy) == 0 {\n \t\t\tbreak\n \t\t}\n \n \t\t// Recompute buildList with all our additions.\n-\t\treqs = Reqs()\n+\t\treqs = &mvsReqs{buildList: buildList}\n \t\tbuildList, err = mvs.BuildList(Target, reqs)\n \t\tif err != nil {\n \t\t\t// If an error was found in a newly added module, report the package\n@@ -749,102 +870,287 @@ func (ld *loader) load(roots func() []string) {\n \t\t}\n \t}\n \n-\t// Add Go versions, computed during walk.\n-\tld.goVersion = make(map[string]string)\n-\tfor _, m := range buildList {\n-\t\tv, _ := reqs.(*mvsReqs).versions.Load(m)\n-\t\tld.goVersion[m.Path], _ = v.(string)\n-\t}\n-\n-\t// Mix in direct markings (really, lack of indirect markings)\n-\t// from go.mod, unless we scanned the whole module\n-\t// and can therefore be sure we know better than go.mod.\n-\tif !ld.isALL && modFile != nil {\n+\t// If we didn't scan all of the imports from the main module, or didn't use\n+\t// imports.AnyTags, then we didn't necessarily load every package that\n+\t// contributes \u201cdirect\u201d imports \u2014 so we can't safely mark existing\n+\t// dependencies as indirect-only.\n+\t// Conservatively mark those dependencies as direct.\n+\tif modFile != nil && (!ld.allPatternIsRoot || !reflect.DeepEqual(ld.Tags, imports.AnyTags())) {\n \t\tfor _, r := range modFile.Require {\n \t\t\tif !r.Indirect {\n \t\t\t\tld.direct[r.Mod.Path] = true\n \t\t\t}\n \t\t}\n \t}\n+\n+\treturn ld\n }\n \n-// pkg returns the *loadPkg for path, creating and queuing it if needed.\n-// If the package should be tested, its test is created but not queued\n-// (the test is queued after processing pkg).\n-// If isRoot is true, the pkg is being queued as one of the roots of the work graph.\n-func (ld *loader) pkg(path string, isRoot bool) *loadPkg {\n-\treturn ld.pkgCache.Do(path, func() interface{} {\n-\t\tpkg := &loadPkg{\n-\t\t\tpath: path,\n+// resolveMissingImports adds module dependencies to the global build list\n+// in order to resolve missing packages from pkgs.\n+//\n+// The newly-resolved packages are added to the addedModuleFor map, and\n+// resolveMissingImports returns a map from each newly-added module version to\n+// the first package for which that module was added.\n+func (ld *loader) resolveMissingImports(addedModuleFor map[string]bool) (modAddedBy map[module.Version]*loadPkg) {\n+\tvar needPkgs []*loadPkg\n+\tfor _, pkg := range ld.pkgs {\n+\t\tif pkg.err == nil {\n+\t\t\tcontinue\n \t\t}\n-\t\tif ld.testRoots && isRoot || ld.testAll {\n-\t\t\ttest := &loadPkg{\n-\t\t\t\tpath:   path,\n-\t\t\t\ttestOf: pkg,\n-\t\t\t}\n-\t\t\tpkg.test = test\n+\t\tif pkg.isTest() {\n+\t\t\t// If we are missing a test, we are also missing its non-test version, and\n+\t\t\t// we should only add the missing import once.\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !errors.As(pkg.err, new(*ImportMissingError)) {\n+\t\t\t// Leave other errors for Import or load.Packages to report.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tneedPkgs = append(needPkgs, pkg)\n+\n+\t\tpkg := pkg\n+\t\tld.work.Add(func() {\n+\t\t\tpkg.mod, pkg.err = queryImport(context.TODO(), pkg.path)\n+\t\t})\n+\t}\n+\t<-ld.work.Idle()\n+\n+\tmodAddedBy = map[module.Version]*loadPkg{}\n+\tfor _, pkg := range needPkgs {\n+\t\tif pkg.err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfmt.Fprintf(os.Stderr, \"go: found %s in %s %s\\n\", pkg.path, pkg.mod.Path, pkg.mod.Version)\n+\t\tif addedModuleFor[pkg.path] {\n+\t\t\t// TODO(bcmills): This should only be an error if pkg.mod is the same\n+\t\t\t// version we already tried to add previously.\n+\t\t\tbase.Fatalf(\"go: %s: looping trying to add package\", pkg.stackText())\n \t\t}\n-\t\tif isRoot {\n-\t\t\tld.roots = append(ld.roots, pkg)\n+\t\tif modAddedBy[pkg.mod] == nil {\n+\t\t\tmodAddedBy[pkg.mod] = pkg\n+\t\t\tbuildList = append(buildList, pkg.mod)\n \t\t}\n-\t\tld.work.Add(pkg)\n+\t}\n+\n+\treturn modAddedBy\n+}\n+\n+// pkg locates the *loadPkg for path, creating and queuing it for loading if\n+// needed, and updates its state to reflect the given flags.\n+//\n+// The imports of the returned *loadPkg will be loaded asynchronously in the\n+// ld.work queue, and its test (if requested) will also be populated once\n+// imports have been resolved. When ld.work goes idle, all transitive imports of\n+// the requested package (and its test, if requested) will have been loaded.\n+func (ld *loader) pkg(path string, flags loadPkgFlags) *loadPkg {\n+\tif flags.has(pkgImportsLoaded) {\n+\t\tpanic(\"internal error: (*loader).pkg called with pkgImportsLoaded flag set\")\n+\t}\n+\n+\tpkg := ld.pkgCache.Do(path, func() interface{} {\n+\t\tpkg := &loadPkg{\n+\t\t\tpath: path,\n+\t\t}\n+\t\tld.applyPkgFlags(pkg, flags)\n+\n+\t\tld.work.Add(func() { ld.load(pkg) })\n \t\treturn pkg\n \t}).(*loadPkg)\n+\n+\tld.applyPkgFlags(pkg, flags)\n+\treturn pkg\n }\n \n-// doPkg processes a package on the work queue.\n-func (ld *loader) doPkg(item interface{}) {\n-\t// TODO: what about replacements?\n-\tpkg := item.(*loadPkg)\n-\tvar imports []string\n-\tif pkg.testOf != nil {\n-\t\tpkg.dir = pkg.testOf.dir\n-\t\tpkg.mod = pkg.testOf.mod\n-\t\timports = pkg.testOf.testImports\n-\t} else {\n-\t\tif strings.Contains(pkg.path, \"@\") {\n-\t\t\t// Leave for error during load.\n-\t\t\treturn\n+// applyPkgFlags updates pkg.flags to set the given flags and propagate the\n+// (transitive) effects of those flags, possibly loading or enqueueing further\n+// packages as a result.\n+func (ld *loader) applyPkgFlags(pkg *loadPkg, flags loadPkgFlags) {\n+\tif flags == 0 {\n+\t\treturn\n+\t}\n+\n+\tif flags.has(pkgInAll) && ld.allPatternIsRoot && !pkg.isTest() {\n+\t\t// This package matches a root pattern by virtue of being in \"all\".\n+\t\tflags |= pkgIsRoot\n+\t}\n+\n+\told := pkg.flags.update(flags)\n+\tnew := old | flags\n+\tif new == old || !new.has(pkgImportsLoaded) {\n+\t\t// We either didn't change the state of pkg, or we don't know anything about\n+\t\t// its dependencies yet. Either way, we can't usefully load its test or\n+\t\t// update its dependencies.\n+\t\treturn\n+\t}\n+\n+\tif !pkg.isTest() {\n+\t\t// Check whether we should add (or update the flags for) a test for pkg.\n+\t\t// ld.pkgTest is idempotent and extra invocations are inexpensive,\n+\t\t// so it's ok if we call it more than is strictly necessary.\n+\t\twantTest := false\n+\t\tswitch {\n+\t\tcase ld.allPatternIsRoot && pkg.mod == Target:\n+\t\t\t// We are loading the \"all\" pattern, which includes packages imported by\n+\t\t\t// tests in the main module. This package is in the main module, so we\n+\t\t\t// need to identify the imports of its test even if LoadTests is not set.\n+\t\t\t//\n+\t\t\t// (We will filter out the extra tests explicitly in computePatternAll.)\n+\t\t\twantTest = true\n+\n+\t\tcase ld.allPatternIsRoot && ld.allClosesOverTests && new.has(pkgInAll):\n+\t\t\t// This variant of the \"all\" pattern includes imports of tests of every\n+\t\t\t// package that is itself in \"all\", and pkg is in \"all\", so its test is\n+\t\t\t// also in \"all\" (as above).\n+\t\t\twantTest = true\n+\n+\t\tcase ld.LoadTests && new.has(pkgIsRoot):\n+\t\t\t// LoadTest explicitly requests tests of \u201cthe root packages\u201d.\n+\t\t\twantTest = true\n \t\t}\n-\t\tif build.IsLocalImport(pkg.path) || filepath.IsAbs(pkg.path) {\n-\t\t\t// Leave for error during load.\n-\t\t\t// (Module mode does not allow local imports.)\n-\t\t\treturn\n+\n+\t\tif wantTest {\n+\t\t\tvar testFlags loadPkgFlags\n+\t\t\tif pkg.mod == Target || (ld.allClosesOverTests && new.has(pkgInAll)) {\n+\t\t\t\t// Tests of packages in the main module are in \"all\", in the sense that\n+\t\t\t\t// they cause the packages they import to also be in \"all\". So are tests\n+\t\t\t\t// of packages in \"all\" if \"all\" closes over test dependencies.\n+\t\t\t\ttestFlags |= pkgInAll\n+\t\t\t}\n+\t\t\tld.pkgTest(pkg, testFlags)\n \t\t}\n+\t}\n \n-\t\tpkg.mod, pkg.dir, pkg.err = Import(pkg.path)\n-\t\tif pkg.dir == \"\" {\n-\t\t\treturn\n+\tif new.has(pkgInAll) && !old.has(pkgInAll|pkgImportsLoaded) {\n+\t\t// We have just marked pkg with pkgInAll, or we have just loaded its\n+\t\t// imports, or both. Now is the time to propagate pkgInAll to the imports.\n+\t\tfor _, dep := range pkg.imports {\n+\t\t\tld.applyPkgFlags(dep, pkgInAll)\n \t\t}\n-\t\tif cfg.BuildContext.Compiler == \"gccgo\" && pkg.mod.Path == \"\" {\n-\t\t\treturn\n+\t}\n+}\n+\n+// load loads an individual package.\n+func (ld *loader) load(pkg *loadPkg) {\n+\tif strings.Contains(pkg.path, \"@\") {\n+\t\t// Leave for error during load.\n+\t\treturn\n+\t}\n+\tif build.IsLocalImport(pkg.path) || filepath.IsAbs(pkg.path) {\n+\t\t// Leave for error during load.\n+\t\t// (Module mode does not allow local imports.)\n+\t\treturn\n+\t}\n+\n+\tif search.IsMetaPackage(pkg.path) {\n+\t\tpkg.err = &invalidImportError{\n+\t\t\timportPath: pkg.path,\n+\t\t\terr:        fmt.Errorf(\"%q is not an importable package; see 'go help packages'\", pkg.path),\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tpkg.mod, pkg.dir, pkg.err = importFromBuildList(context.TODO(), pkg.path, buildList)\n+\tif pkg.dir == \"\" {\n+\t\treturn\n+\t}\n+\tif pkg.mod == Target {\n+\t\t// Go ahead and mark pkg as in \"all\". This provides the invariant that a\n+\t\t// package that is *only* imported by other packages in \"all\" is always\n+\t\t// marked as such before loading its imports.\n+\t\t//\n+\t\t// We don't actually rely on that invariant at the moment, but it may\n+\t\t// improve efficiency somewhat and makes the behavior a bit easier to reason\n+\t\t// about (by reducing churn on the flag bits of dependencies), and costs\n+\t\t// essentially nothing (these atomic flag ops are essentially free compared\n+\t\t// to scanning source code for imports).\n+\t\tld.applyPkgFlags(pkg, pkgInAll)\n+\t}\n+\tif ld.AllowPackage != nil {\n+\t\tif err := ld.AllowPackage(context.TODO(), pkg.path, pkg.mod); err != nil {\n+\t\t\tpkg.err = err\n \t\t}\n+\t}\n \n-\t\tvar testImports []string\n+\tpkg.inStd = (search.IsStandardImportPath(pkg.path) && search.InDir(pkg.dir, cfg.GOROOTsrc) != \"\")\n+\n+\tvar imports, testImports []string\n+\n+\tif cfg.BuildContext.Compiler == \"gccgo\" && pkg.inStd {\n+\t\t// We can't scan standard packages for gccgo.\n+\t} else {\n \t\tvar err error\n-\t\timports, testImports, err = scanDir(pkg.dir, ld.tags)\n+\t\timports, testImports, err = scanDir(pkg.dir, ld.Tags)\n \t\tif err != nil {\n \t\t\tpkg.err = err\n \t\t\treturn\n \t\t}\n-\t\tif pkg.test != nil {\n-\t\t\tpkg.testImports = testImports\n-\t\t}\n \t}\n \n-\tinStd := (search.IsStandardImportPath(pkg.path) && search.InDir(pkg.dir, cfg.GOROOTsrc) != \"\")\n+\tpkg.imports = make([]*loadPkg, 0, len(imports))\n+\tvar importFlags loadPkgFlags\n+\tif pkg.flags.has(pkgInAll) {\n+\t\timportFlags = pkgInAll\n+\t}\n \tfor _, path := range imports {\n-\t\tif inStd {\n+\t\tif pkg.inStd {\n+\t\t\t// Imports from packages in \"std\" and \"cmd\" should resolve using\n+\t\t\t// GOROOT/src/vendor even when \"std\" is not the main module.\n \t\t\tpath = ld.stdVendor(pkg.path, path)\n \t\t}\n-\t\tpkg.imports = append(pkg.imports, ld.pkg(path, false))\n+\t\tpkg.imports = append(pkg.imports, ld.pkg(path, importFlags))\n \t}\n+\tpkg.testImports = testImports\n \n-\t// Now that pkg.dir, pkg.mod, pkg.testImports are set, we can queue pkg.test.\n-\t// TODO: All that's left is creating new imports. Why not just do it now?\n-\tif pkg.test != nil {\n-\t\tld.work.Add(pkg.test)\n+\tld.applyPkgFlags(pkg, pkgImportsLoaded)\n+}\n+\n+// pkgTest locates the test of pkg, creating it if needed, and updates its state\n+// to reflect the given flags.\n+//\n+// pkgTest requires that the imports of pkg have already been loaded (flagged\n+// with pkgImportsLoaded).\n+func (ld *loader) pkgTest(pkg *loadPkg, testFlags loadPkgFlags) *loadPkg {\n+\tif pkg.isTest() {\n+\t\tpanic(\"pkgTest called on a test package\")\n \t}\n+\n+\tcreatedTest := false\n+\tpkg.testOnce.Do(func() {\n+\t\tpkg.test = &loadPkg{\n+\t\t\tpath:   pkg.path,\n+\t\t\ttestOf: pkg,\n+\t\t\tmod:    pkg.mod,\n+\t\t\tdir:    pkg.dir,\n+\t\t\terr:    pkg.err,\n+\t\t\tinStd:  pkg.inStd,\n+\t\t}\n+\t\tld.applyPkgFlags(pkg.test, testFlags)\n+\t\tcreatedTest = true\n+\t})\n+\n+\ttest := pkg.test\n+\tif createdTest {\n+\t\ttest.imports = make([]*loadPkg, 0, len(pkg.testImports))\n+\t\tvar importFlags loadPkgFlags\n+\t\tif test.flags.has(pkgInAll) {\n+\t\t\timportFlags = pkgInAll\n+\t\t}\n+\t\tfor _, path := range pkg.testImports {\n+\t\t\tif pkg.inStd {\n+\t\t\t\tpath = ld.stdVendor(test.path, path)\n+\t\t\t}\n+\t\t\ttest.imports = append(test.imports, ld.pkg(path, importFlags))\n+\t\t}\n+\t\tpkg.testImports = nil\n+\t\tld.applyPkgFlags(test, pkgImportsLoaded)\n+\t} else {\n+\t\tld.applyPkgFlags(test, testFlags)\n+\t}\n+\n+\treturn test\n }\n \n // stdVendor returns the canonical import path for the package with the given\n@@ -855,13 +1161,25 @@ func (ld *loader) stdVendor(parentPath, path string) string {\n \t}\n \n \tif str.HasPathPrefix(parentPath, \"cmd\") {\n-\t\tif ld.forceStdVendor || Target.Path != \"cmd\" {\n+\t\tif Target.Path != \"cmd\" {\n \t\t\tvendorPath := pathpkg.Join(\"cmd\", \"vendor\", path)\n \t\t\tif _, err := os.Stat(filepath.Join(cfg.GOROOTsrc, filepath.FromSlash(vendorPath))); err == nil {\n \t\t\t\treturn vendorPath\n \t\t\t}\n \t\t}\n-\t} else if ld.forceStdVendor || Target.Path != \"std\" {\n+\t} else if Target.Path != \"std\" || str.HasPathPrefix(parentPath, \"vendor\") {\n+\t\t// If we are outside of the 'std' module, resolve imports from within 'std'\n+\t\t// to the vendor directory.\n+\t\t//\n+\t\t// Do the same for importers beginning with the prefix 'vendor/' even if we\n+\t\t// are *inside* of the 'std' module: the 'vendor/' packages that resolve\n+\t\t// globally from GOROOT/src/vendor (and are listed as part of 'go list std')\n+\t\t// are distinct from the real module dependencies, and cannot import\n+\t\t// internal packages from the real module.\n+\t\t//\n+\t\t// (Note that although the 'vendor/' packages match the 'std' *package*\n+\t\t// pattern, they are not part of the std *module*, and do not affect\n+\t\t// 'go mod tidy' and similar module commands when working within std.)\n \t\tvendorPath := pathpkg.Join(\"vendor\", path)\n \t\tif _, err := os.Stat(filepath.Join(cfg.GOROOTsrc, filepath.FromSlash(vendorPath))); err == nil {\n \t\t\treturn vendorPath\n@@ -874,30 +1192,13 @@ func (ld *loader) stdVendor(parentPath, path string) string {\n \n // computePatternAll returns the list of packages matching pattern \"all\",\n // starting with a list of the import paths for the packages in the main module.\n-func (ld *loader) computePatternAll(paths []string) []string {\n-\tseen := make(map[*loadPkg]bool)\n-\tvar all []string\n-\tvar walk func(*loadPkg)\n-\twalk = func(pkg *loadPkg) {\n-\t\tif seen[pkg] {\n-\t\t\treturn\n-\t\t}\n-\t\tseen[pkg] = true\n-\t\tif pkg.testOf == nil {\n+func (ld *loader) computePatternAll() (all []string) {\n+\tfor _, pkg := range ld.pkgs {\n+\t\tif pkg.flags.has(pkgInAll) && !pkg.isTest() {\n \t\t\tall = append(all, pkg.path)\n \t\t}\n-\t\tfor _, p := range pkg.imports {\n-\t\t\twalk(p)\n-\t\t}\n-\t\tif p := pkg.test; p != nil {\n-\t\t\twalk(p)\n-\t\t}\n-\t}\n-\tfor _, path := range paths {\n-\t\twalk(ld.pkg(path, false))\n \t}\n \tsort.Strings(all)\n-\n \treturn all\n }\n \n@@ -1019,7 +1320,7 @@ func (pkg *loadPkg) why() string {\n \n // Why returns the \"go mod why\" output stanza for the given package,\n // without the leading # comment.\n-// The package graph must have been loaded already, usually by LoadALL.\n+// The package graph must have been loaded already, usually by LoadPackages.\n // If there is no reason for the package to be in the current build,\n // Why returns an empty string.\n func Why(path string) string {"}, {"sha": "eb05e9f9c91ce0481a07d1b8953271d124498506", "filename": "libgo/go/cmd/go/internal/modload/modfile.go", "status": "modified", "additions": 442, "deletions": 15, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,25 +5,45 @@\n package modload\n \n import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"unicode\"\n+\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/lockedfile\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/trace\"\n \n \t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n+// narrowAllVersionV is the Go version (plus leading \"v\") at which the\n+// module-module \"all\" pattern no longer closes over the dependencies of\n+// tests outside of the main module.\n+const narrowAllVersionV = \"v1.16\"\n+const go116EnableNarrowAll = true\n+\n var modFile *modfile.File\n \n // A modFileIndex is an index of data corresponding to a modFile\n // at a specific point in time.\n type modFileIndex struct {\n-\tdata         []byte\n-\tdataNeedsFix bool // true if fixVersion applied a change while parsing data\n-\tmodule       module.Version\n-\tgoVersion    string\n-\trequire      map[module.Version]requireMeta\n-\treplace      map[module.Version]module.Version\n-\texclude      map[module.Version]bool\n+\tdata            []byte\n+\tdataNeedsFix    bool // true if fixVersion applied a change while parsing data\n+\tmodule          module.Version\n+\tgoVersionV      string // GoVersion with \"v\" prefix\n+\trequire         map[module.Version]requireMeta\n+\treplace         map[module.Version]module.Version\n+\thighestReplaced map[string]string // highest replaced version of each module path; empty string for wildcard-only replacements\n+\texclude         map[module.Version]bool\n }\n \n // index is the index of the go.mod file as of when it was last read or written.\n@@ -33,9 +53,179 @@ type requireMeta struct {\n \tindirect bool\n }\n \n-// Allowed reports whether module m is allowed (not excluded) by the main module's go.mod.\n-func Allowed(m module.Version) bool {\n-\treturn index == nil || !index.exclude[m]\n+// CheckAllowed returns an error equivalent to ErrDisallowed if m is excluded by\n+// the main module's go.mod or retracted by its author. Most version queries use\n+// this to filter out versions that should not be used.\n+func CheckAllowed(ctx context.Context, m module.Version) error {\n+\tif err := CheckExclusions(ctx, m); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := CheckRetractions(ctx, m); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// ErrDisallowed is returned by version predicates passed to Query and similar\n+// functions to indicate that a version should not be considered.\n+var ErrDisallowed = errors.New(\"disallowed module version\")\n+\n+// CheckExclusions returns an error equivalent to ErrDisallowed if module m is\n+// excluded by the main module's go.mod file.\n+func CheckExclusions(ctx context.Context, m module.Version) error {\n+\tif index != nil && index.exclude[m] {\n+\t\treturn module.VersionError(m, errExcluded)\n+\t}\n+\treturn nil\n+}\n+\n+var errExcluded = &excludedError{}\n+\n+type excludedError struct{}\n+\n+func (e *excludedError) Error() string     { return \"excluded by go.mod\" }\n+func (e *excludedError) Is(err error) bool { return err == ErrDisallowed }\n+\n+// CheckRetractions returns an error if module m has been retracted by\n+// its author.\n+func CheckRetractions(ctx context.Context, m module.Version) error {\n+\tif m.Version == \"\" {\n+\t\t// Main module, standard library, or file replacement module.\n+\t\t// Cannot be retracted.\n+\t\treturn nil\n+\t}\n+\n+\t// Look up retraction information from the latest available version of\n+\t// the module. Cache retraction information so we don't parse the go.mod\n+\t// file repeatedly.\n+\ttype entry struct {\n+\t\tretract []retraction\n+\t\terr     error\n+\t}\n+\tpath := m.Path\n+\te := retractCache.Do(path, func() (v interface{}) {\n+\t\tctx, span := trace.StartSpan(ctx, \"checkRetractions \"+path)\n+\t\tdefer span.Done()\n+\n+\t\tif repl := Replacement(module.Version{Path: m.Path}); repl.Path != \"\" {\n+\t\t\t// All versions of the module were replaced with a local directory.\n+\t\t\t// Don't load retractions.\n+\t\t\treturn &entry{nil, nil}\n+\t\t}\n+\n+\t\t// Find the latest version of the module.\n+\t\t// Ignore exclusions from the main module's go.mod.\n+\t\tconst ignoreSelected = \"\"\n+\t\tvar allowAll AllowedFunc\n+\t\trev, err := Query(ctx, path, \"latest\", ignoreSelected, allowAll)\n+\t\tif err != nil {\n+\t\t\treturn &entry{nil, err}\n+\t\t}\n+\n+\t\t// Load go.mod for that version.\n+\t\t// If the version is replaced, we'll load retractions from the replacement.\n+\t\t//\n+\t\t// If there's an error loading the go.mod, we'll return it here.\n+\t\t// These errors should generally be ignored by callers of checkRetractions,\n+\t\t// since they happen frequently when we're offline. These errors are not\n+\t\t// equivalent to ErrDisallowed, so they may be distinguished from\n+\t\t// retraction errors.\n+\t\t//\n+\t\t// We load the raw file here: the go.mod file may have a different module\n+\t\t// path that we expect if the module or its repository was renamed.\n+\t\t// We still want to apply retractions to other aliases of the module.\n+\t\trm := module.Version{Path: path, Version: rev.Version}\n+\t\tif repl := Replacement(rm); repl.Path != \"\" {\n+\t\t\trm = repl\n+\t\t}\n+\t\tsummary, err := rawGoModSummary(rm)\n+\t\tif err != nil {\n+\t\t\treturn &entry{nil, err}\n+\t\t}\n+\t\treturn &entry{summary.retract, nil}\n+\t}).(*entry)\n+\n+\tif err := e.err; err != nil {\n+\t\t// Attribute the error to the version being checked, not the version from\n+\t\t// which the retractions were to be loaded.\n+\t\tvar mErr *module.ModuleError\n+\t\tif errors.As(err, &mErr) {\n+\t\t\terr = mErr.Err\n+\t\t}\n+\t\treturn &retractionLoadingError{m: m, err: err}\n+\t}\n+\n+\tvar rationale []string\n+\tisRetracted := false\n+\tfor _, r := range e.retract {\n+\t\tif semver.Compare(r.Low, m.Version) <= 0 && semver.Compare(m.Version, r.High) <= 0 {\n+\t\t\tisRetracted = true\n+\t\t\tif r.Rationale != \"\" {\n+\t\t\t\trationale = append(rationale, r.Rationale)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif isRetracted {\n+\t\treturn module.VersionError(m, &ModuleRetractedError{Rationale: rationale})\n+\t}\n+\treturn nil\n+}\n+\n+var retractCache par.Cache\n+\n+type ModuleRetractedError struct {\n+\tRationale []string\n+}\n+\n+func (e *ModuleRetractedError) Error() string {\n+\tmsg := \"retracted by module author\"\n+\tif len(e.Rationale) > 0 {\n+\t\t// This is meant to be a short error printed on a terminal, so just\n+\t\t// print the first rationale.\n+\t\tmsg += \": \" + ShortRetractionRationale(e.Rationale[0])\n+\t}\n+\treturn msg\n+}\n+\n+func (e *ModuleRetractedError) Is(err error) bool {\n+\treturn err == ErrDisallowed\n+}\n+\n+type retractionLoadingError struct {\n+\tm   module.Version\n+\terr error\n+}\n+\n+func (e *retractionLoadingError) Error() string {\n+\treturn fmt.Sprintf(\"loading module retractions for %v: %v\", e.m, e.err)\n+}\n+\n+func (e *retractionLoadingError) Unwrap() error {\n+\treturn e.err\n+}\n+\n+// ShortRetractionRationale returns a retraction rationale string that is safe\n+// to print in a terminal. It returns hard-coded strings if the rationale\n+// is empty, too long, or contains non-printable characters.\n+func ShortRetractionRationale(rationale string) string {\n+\tconst maxRationaleBytes = 500\n+\tif i := strings.Index(rationale, \"\\n\"); i >= 0 {\n+\t\trationale = rationale[:i]\n+\t}\n+\trationale = strings.TrimSpace(rationale)\n+\tif rationale == \"\" {\n+\t\treturn \"retracted by module author\"\n+\t}\n+\tif len(rationale) > maxRationaleBytes {\n+\t\treturn \"(rationale omitted: too long)\"\n+\t}\n+\tfor _, r := range rationale {\n+\t\tif !unicode.IsGraphic(r) && !unicode.IsSpace(r) {\n+\t\t\treturn \"(rationale omitted: contains non-printable characters)\"\n+\t\t}\n+\t}\n+\t// NOTE: the go.mod parser rejects invalid UTF-8, so we don't check that here.\n+\treturn rationale\n }\n \n // Replacement returns the replacement for mod, if any, from go.mod.\n@@ -66,9 +256,11 @@ func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileInd\n \t\ti.module = modFile.Module.Mod\n \t}\n \n-\ti.goVersion = \"\"\n+\ti.goVersionV = \"\"\n \tif modFile.Go != nil {\n-\t\ti.goVersion = modFile.Go.Version\n+\t\t// We're going to use the semver package to compare Go versions, so go ahead\n+\t\t// and add the \"v\" prefix it expects once instead of every time.\n+\t\ti.goVersionV = \"v\" + modFile.Go.Version\n \t}\n \n \ti.require = make(map[module.Version]requireMeta, len(modFile.Require))\n@@ -84,6 +276,14 @@ func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileInd\n \t\ti.replace[r.Old] = r.New\n \t}\n \n+\ti.highestReplaced = make(map[string]string)\n+\tfor _, r := range modFile.Replace {\n+\t\tv, ok := i.highestReplaced[r.Old.Path]\n+\t\tif !ok || semver.Compare(r.Old.Version, v) > 0 {\n+\t\t\ti.highestReplaced[r.Old.Path] = r.Old.Version\n+\t\t}\n+\t}\n+\n \ti.exclude = make(map[module.Version]bool, len(modFile.Exclude))\n \tfor _, x := range modFile.Exclude {\n \t\ti.exclude[x.Mod] = true\n@@ -92,6 +292,23 @@ func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileInd\n \treturn i\n }\n \n+// allPatternClosesOverTests reports whether the \"all\" pattern includes\n+// dependencies of tests outside the main module (as in Go 1.11\u20131.15).\n+// (Otherwise \u2014 as in Go 1.16+ \u2014 the \"all\" pattern includes only the packages\n+// transitively *imported by* the packages and tests in the main module.)\n+func (i *modFileIndex) allPatternClosesOverTests() bool {\n+\tif !go116EnableNarrowAll {\n+\t\treturn true\n+\t}\n+\tif i != nil && semver.Compare(i.goVersionV, narrowAllVersionV) < 0 {\n+\t\t// The module explicitly predates the change in \"all\" for lazy loading, so\n+\t\t// continue to use the older interpretation. (If i == nil, we not in any\n+\t\t// module at all and should use the latest semantics.)\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // modFileIsDirty reports whether the go.mod file differs meaningfully\n // from what was indexed.\n // If modFile has been changed (even cosmetically) since it was first read,\n@@ -114,11 +331,11 @@ func (i *modFileIndex) modFileIsDirty(modFile *modfile.File) bool {\n \t}\n \n \tif modFile.Go == nil {\n-\t\tif i.goVersion != \"\" {\n+\t\tif i.goVersionV != \"\" {\n \t\t\treturn true\n \t\t}\n-\t} else if modFile.Go.Version != i.goVersion {\n-\t\tif i.goVersion == \"\" && cfg.BuildMod == \"readonly\" {\n+\t} else if \"v\"+modFile.Go.Version != i.goVersionV {\n+\t\tif i.goVersionV == \"\" && cfg.BuildMod == \"readonly\" {\n \t\t\t// go.mod files did not always require a 'go' version, so do not error out\n \t\t\t// if one is missing \u2014 we may be inside an older module in the module\n \t\t\t// cache, and should bias toward providing useful behavior.\n@@ -162,3 +379,213 @@ func (i *modFileIndex) modFileIsDirty(modFile *modfile.File) bool {\n \n \treturn false\n }\n+\n+// rawGoVersion records the Go version parsed from each module's go.mod file.\n+//\n+// If a module is replaced, the version of the replacement is keyed by the\n+// replacement module.Version, not the version being replaced.\n+var rawGoVersion sync.Map // map[module.Version]string\n+\n+// A modFileSummary is a summary of a go.mod file for which we do not need to\n+// retain complete information \u2014 for example, the go.mod file of a dependency\n+// module.\n+type modFileSummary struct {\n+\tmodule     module.Version\n+\tgoVersionV string // GoVersion with \"v\" prefix\n+\trequire    []module.Version\n+\tretract    []retraction\n+}\n+\n+// A retraction consists of a retracted version interval and rationale.\n+// retraction is like modfile.Retract, but it doesn't point to the syntax tree.\n+type retraction struct {\n+\tmodfile.VersionInterval\n+\tRationale string\n+}\n+\n+// goModSummary returns a summary of the go.mod file for module m,\n+// taking into account any replacements for m, exclusions of its dependencies,\n+// and/or vendoring.\n+//\n+// m must be a version in the module graph, reachable from the Target module.\n+// In readonly mode, the go.sum file must contain an entry for m's go.mod file\n+// (or its replacement). goModSummary must not be called for the Target module\n+// itself, as its requirements may change. Use rawGoModSummary for other\n+// module versions.\n+//\n+// The caller must not modify the returned summary.\n+func goModSummary(m module.Version) (*modFileSummary, error) {\n+\tif m == Target {\n+\t\tpanic(\"internal error: goModSummary called on the Target module\")\n+\t}\n+\n+\tif cfg.BuildMod == \"vendor\" {\n+\t\tsummary := &modFileSummary{\n+\t\t\tmodule: module.Version{Path: m.Path},\n+\t\t}\n+\t\tif vendorVersion[m.Path] != m.Version {\n+\t\t\t// This module is not vendored, so packages cannot be loaded from it and\n+\t\t\t// it cannot be relevant to the build.\n+\t\t\treturn summary, nil\n+\t\t}\n+\n+\t\t// For every module other than the target,\n+\t\t// return the full list of modules from modules.txt.\n+\t\treadVendorList()\n+\n+\t\t// TODO(#36876): Load the \"go\" version from vendor/modules.txt and store it\n+\t\t// in rawGoVersion with the appropriate key.\n+\n+\t\t// We don't know what versions the vendored module actually relies on,\n+\t\t// so assume that it requires everything.\n+\t\tsummary.require = vendorList\n+\t\treturn summary, nil\n+\t}\n+\n+\tactual := Replacement(m)\n+\tif actual.Path == \"\" {\n+\t\tactual = m\n+\t}\n+\tif cfg.BuildMod == \"readonly\" && actual.Version != \"\" {\n+\t\tkey := module.Version{Path: actual.Path, Version: actual.Version + \"/go.mod\"}\n+\t\tif !modfetch.HaveSum(key) {\n+\t\t\tsuggestion := fmt.Sprintf(\"; try 'go mod download %s' to add it\", m.Path)\n+\t\t\treturn nil, module.VersionError(actual, &sumMissingError{suggestion: suggestion})\n+\t\t}\n+\t}\n+\tsummary, err := rawGoModSummary(actual)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif actual.Version == \"\" {\n+\t\t// The actual module is a filesystem-local replacement, for which we have\n+\t\t// unfortunately not enforced any sort of invariants about module lines or\n+\t\t// matching module paths. Anything goes.\n+\t\t//\n+\t\t// TODO(bcmills): Remove this special-case, update tests, and add a\n+\t\t// release note.\n+\t} else {\n+\t\tif summary.module.Path == \"\" {\n+\t\t\treturn nil, module.VersionError(actual, errors.New(\"parsing go.mod: missing module line\"))\n+\t\t}\n+\n+\t\t// In theory we should only allow mpath to be unequal to m.Path here if the\n+\t\t// version that we fetched lacks an explicit go.mod file: if the go.mod file\n+\t\t// is explicit, then it should match exactly (to ensure that imports of other\n+\t\t// packages within the module are interpreted correctly). Unfortunately, we\n+\t\t// can't determine that information from the module proxy protocol: we'll have\n+\t\t// to leave that validation for when we load actual packages from within the\n+\t\t// module.\n+\t\tif mpath := summary.module.Path; mpath != m.Path && mpath != actual.Path {\n+\t\t\treturn nil, module.VersionError(actual, fmt.Errorf(`parsing go.mod:\n+\tmodule declares its path as: %s\n+\t        but was required as: %s`, mpath, m.Path))\n+\t\t}\n+\t}\n+\n+\tif index != nil && len(index.exclude) > 0 {\n+\t\t// Drop any requirements on excluded versions.\n+\t\t// Don't modify the cached summary though, since we might need the raw\n+\t\t// summary separately.\n+\t\thaveExcludedReqs := false\n+\t\tfor _, r := range summary.require {\n+\t\t\tif index.exclude[r] {\n+\t\t\t\thaveExcludedReqs = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif haveExcludedReqs {\n+\t\t\ts := new(modFileSummary)\n+\t\t\t*s = *summary\n+\t\t\ts.require = make([]module.Version, 0, len(summary.require))\n+\t\t\tfor _, r := range summary.require {\n+\t\t\t\tif !index.exclude[r] {\n+\t\t\t\t\ts.require = append(s.require, r)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tsummary = s\n+\t\t}\n+\t}\n+\treturn summary, nil\n+}\n+\n+// rawGoModSummary returns a new summary of the go.mod file for module m,\n+// ignoring all replacements that may apply to m and excludes that may apply to\n+// its dependencies.\n+//\n+// rawGoModSummary cannot be used on the Target module.\n+func rawGoModSummary(m module.Version) (*modFileSummary, error) {\n+\tif m == Target {\n+\t\tpanic(\"internal error: rawGoModSummary called on the Target module\")\n+\t}\n+\n+\ttype cached struct {\n+\t\tsummary *modFileSummary\n+\t\terr     error\n+\t}\n+\tc := rawGoModSummaryCache.Do(m, func() interface{} {\n+\t\tsummary := new(modFileSummary)\n+\t\tvar f *modfile.File\n+\t\tif m.Version == \"\" {\n+\t\t\t// m is a replacement module with only a file path.\n+\t\t\tdir := m.Path\n+\t\t\tif !filepath.IsAbs(dir) {\n+\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n+\t\t\t}\n+\t\t\tgomod := filepath.Join(dir, \"go.mod\")\n+\n+\t\t\tdata, err := lockedfile.Read(gomod)\n+\t\t\tif err != nil {\n+\t\t\t\treturn cached{nil, module.VersionError(m, fmt.Errorf(\"reading %s: %v\", base.ShortPath(gomod), err))}\n+\t\t\t}\n+\t\t\tf, err = modfile.ParseLax(gomod, data, nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn cached{nil, module.VersionError(m, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err))}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif !semver.IsValid(m.Version) {\n+\t\t\t\t// Disallow the broader queries supported by fetch.Lookup.\n+\t\t\t\tbase.Fatalf(\"go: internal error: %s@%s: unexpected invalid semantic version\", m.Path, m.Version)\n+\t\t\t}\n+\n+\t\t\tdata, err := modfetch.GoMod(m.Path, m.Version)\n+\t\t\tif err != nil {\n+\t\t\t\treturn cached{nil, err}\n+\t\t\t}\n+\t\t\tf, err = modfile.ParseLax(\"go.mod\", data, nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn cached{nil, module.VersionError(m, fmt.Errorf(\"parsing go.mod: %v\", err))}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif f.Module != nil {\n+\t\t\tsummary.module = f.Module.Mod\n+\t\t}\n+\t\tif f.Go != nil && f.Go.Version != \"\" {\n+\t\t\trawGoVersion.LoadOrStore(m, f.Go.Version)\n+\t\t\tsummary.goVersionV = \"v\" + f.Go.Version\n+\t\t}\n+\t\tif len(f.Require) > 0 {\n+\t\t\tsummary.require = make([]module.Version, 0, len(f.Require))\n+\t\t\tfor _, req := range f.Require {\n+\t\t\t\tsummary.require = append(summary.require, req.Mod)\n+\t\t\t}\n+\t\t}\n+\t\tif len(f.Retract) > 0 {\n+\t\t\tsummary.retract = make([]retraction, 0, len(f.Retract))\n+\t\t\tfor _, ret := range f.Retract {\n+\t\t\t\tsummary.retract = append(summary.retract, retraction{\n+\t\t\t\t\tVersionInterval: ret.VersionInterval,\n+\t\t\t\t\tRationale:       ret.Rationale,\n+\t\t\t\t})\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn cached{summary, nil}\n+\t}).(cached)\n+\n+\treturn c.summary, c.err\n+}\n+\n+var rawGoModSummaryCache par.Cache // module.Version \u2192 rawGoModSummary result"}, {"sha": "167d6819b06ae51620dc01195eacc30d17116ae1", "filename": "libgo/go/cmd/go/internal/modload/mvs.go", "status": "modified", "additions": 40, "deletions": 170, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,21 +5,13 @@\n package modload\n \n import (\n+\t\"context\"\n \t\"errors\"\n-\t\"fmt\"\n \t\"os\"\n-\t\"path/filepath\"\n \t\"sort\"\n-\t\"sync\"\n \n-\t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/mvs\"\n-\t\"cmd/go/internal/par\"\n \n-\t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n )\n@@ -28,133 +20,24 @@ import (\n // with any exclusions or replacements applied internally.\n type mvsReqs struct {\n \tbuildList []module.Version\n-\tcache     par.Cache\n-\tversions  sync.Map\n-}\n-\n-// Reqs returns the current module requirement graph.\n-// Future calls to SetBuildList do not affect the operation\n-// of the returned Reqs.\n-func Reqs() mvs.Reqs {\n-\tr := &mvsReqs{\n-\t\tbuildList: buildList,\n-\t}\n-\treturn r\n }\n \n func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error) {\n-\ttype cached struct {\n-\t\tlist []module.Version\n-\t\terr  error\n-\t}\n-\n-\tc := r.cache.Do(mod, func() interface{} {\n-\t\tlist, err := r.required(mod)\n-\t\tif err != nil {\n-\t\t\treturn cached{nil, err}\n-\t\t}\n-\t\tfor i, mv := range list {\n-\t\t\tif index != nil {\n-\t\t\t\tfor index.exclude[mv] {\n-\t\t\t\t\tmv1, err := r.next(mv)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn cached{nil, err}\n-\t\t\t\t\t}\n-\t\t\t\t\tif mv1.Version == \"none\" {\n-\t\t\t\t\t\treturn cached{nil, fmt.Errorf(\"%s(%s) depends on excluded %s(%s) with no newer version available\", mod.Path, mod.Version, mv.Path, mv.Version)}\n-\t\t\t\t\t}\n-\t\t\t\t\tmv = mv1\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tlist[i] = mv\n-\t\t}\n-\n-\t\treturn cached{list, nil}\n-\t}).(cached)\n-\n-\treturn c.list, c.err\n-}\n-\n-func (r *mvsReqs) modFileToList(f *modfile.File) []module.Version {\n-\tlist := make([]module.Version, 0, len(f.Require))\n-\tfor _, r := range f.Require {\n-\t\tlist = append(list, r.Mod)\n-\t}\n-\treturn list\n-}\n-\n-// required returns a unique copy of the requirements of mod.\n-func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \tif mod == Target {\n-\t\tif modFile != nil && modFile.Go != nil {\n-\t\t\tr.versions.LoadOrStore(mod, modFile.Go.Version)\n-\t\t}\n-\t\treturn append([]module.Version(nil), r.buildList[1:]...), nil\n-\t}\n-\n-\tif cfg.BuildMod == \"vendor\" {\n-\t\t// For every module other than the target,\n-\t\t// return the full list of modules from modules.txt.\n-\t\treadVendorList()\n-\t\treturn append([]module.Version(nil), vendorList...), nil\n-\t}\n-\n-\torigPath := mod.Path\n-\tif repl := Replacement(mod); repl.Path != \"\" {\n-\t\tif repl.Version == \"\" {\n-\t\t\t// TODO: need to slip the new version into the tags list etc.\n-\t\t\tdir := repl.Path\n-\t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n-\t\t\t}\n-\t\t\tgomod := filepath.Join(dir, \"go.mod\")\n-\t\t\tdata, err := lockedfile.Read(gomod)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err)\n-\t\t\t}\n-\t\t\tf, err := modfile.ParseLax(gomod, data, nil)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err)\n-\t\t\t}\n-\t\t\tif f.Go != nil {\n-\t\t\t\tr.versions.LoadOrStore(mod, f.Go.Version)\n-\t\t\t}\n-\t\t\treturn r.modFileToList(f), nil\n-\t\t}\n-\t\tmod = repl\n+\t\t// Use the build list as it existed when r was constructed, not the current\n+\t\t// global build list.\n+\t\treturn r.buildList[1:], nil\n \t}\n \n \tif mod.Version == \"none\" {\n \t\treturn nil, nil\n \t}\n \n-\tif !semver.IsValid(mod.Version) {\n-\t\t// Disallow the broader queries supported by fetch.Lookup.\n-\t\tbase.Fatalf(\"go: internal error: %s@%s: unexpected invalid semantic version\", mod.Path, mod.Version)\n-\t}\n-\n-\tdata, err := modfetch.GoMod(mod.Path, mod.Version)\n+\tsummary, err := goModSummary(mod)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tf, err := modfile.ParseLax(\"go.mod\", data, nil)\n-\tif err != nil {\n-\t\treturn nil, module.VersionError(mod, fmt.Errorf(\"parsing go.mod: %v\", err))\n-\t}\n-\n-\tif f.Module == nil {\n-\t\treturn nil, module.VersionError(mod, errors.New(\"parsing go.mod: missing module line\"))\n-\t}\n-\tif mpath := f.Module.Mod.Path; mpath != origPath && mpath != mod.Path {\n-\t\treturn nil, module.VersionError(mod, fmt.Errorf(`parsing go.mod:\n-\tmodule declares its path as: %s\n-\t        but was required as: %s`, mpath, origPath))\n-\t}\n-\tif f.Go != nil {\n-\t\tr.versions.LoadOrStore(mod, f.Go.Version)\n-\t}\n-\n-\treturn r.modFileToList(f), nil\n+\treturn summary.require, nil\n }\n \n // Max returns the maximum of v1 and v2 according to semver.Compare.\n@@ -164,7 +47,7 @@ func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n // be chosen over other versions of the same module in the module dependency\n // graph.\n func (*mvsReqs) Max(v1, v2 string) string {\n-\tif v1 != \"\" && semver.Compare(v1, v2) == -1 {\n+\tif v1 != \"\" && (v2 == \"\" || semver.Compare(v1, v2) == -1) {\n \t\treturn v2\n \t}\n \treturn v1\n@@ -176,25 +59,50 @@ func (*mvsReqs) Upgrade(m module.Version) (module.Version, error) {\n \treturn m, nil\n }\n \n-func versions(path string) ([]string, error) {\n+func versions(ctx context.Context, path string, allowed AllowedFunc) ([]string, error) {\n \t// Note: modfetch.Lookup and repo.Versions are cached,\n \t// so there's no need for us to add extra caching here.\n \tvar versions []string\n \terr := modfetch.TryProxies(func(proxy string) error {\n-\t\trepo, err := modfetch.Lookup(proxy, path)\n-\t\tif err == nil {\n-\t\t\tversions, err = repo.Versions(\"\")\n+\t\trepo, err := lookupRepo(proxy, path)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tallVersions, err := repo.Versions(\"\")\n+\t\tif err != nil {\n+\t\t\treturn err\n \t\t}\n-\t\treturn err\n+\t\tallowedVersions := make([]string, 0, len(allVersions))\n+\t\tfor _, v := range allVersions {\n+\t\t\tif err := allowed(ctx, module.Version{Path: path, Version: v}); err == nil {\n+\t\t\t\tallowedVersions = append(allowedVersions, v)\n+\t\t\t} else if !errors.Is(err, ErrDisallowed) {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\tversions = allowedVersions\n+\t\treturn nil\n \t})\n \treturn versions, err\n }\n \n // Previous returns the tagged version of m.Path immediately prior to\n // m.Version, or version \"none\" if no prior version is tagged.\n+//\n+// Since the version of Target is not found in the version list,\n+// it has no previous version.\n func (*mvsReqs) Previous(m module.Version) (module.Version, error) {\n-\tlist, err := versions(m.Path)\n+\t// TODO(golang.org/issue/38714): thread tracing context through MVS.\n+\n+\tif m == Target {\n+\t\treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n+\t}\n+\n+\tlist, err := versions(context.TODO(), m.Path, CheckAllowed)\n \tif err != nil {\n+\t\tif errors.Is(err, os.ErrNotExist) {\n+\t\t\treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n+\t\t}\n \t\treturn module.Version{}, err\n \t}\n \ti := sort.Search(len(list), func(i int) bool { return semver.Compare(list[i], m.Version) >= 0 })\n@@ -208,7 +116,8 @@ func (*mvsReqs) Previous(m module.Version) (module.Version, error) {\n // It is only used by the exclusion processing in the Required method,\n // not called directly by MVS.\n func (*mvsReqs) next(m module.Version) (module.Version, error) {\n-\tlist, err := versions(m.Path)\n+\t// TODO(golang.org/issue/38714): thread tracing context through MVS.\n+\tlist, err := versions(context.TODO(), m.Path, CheckAllowed)\n \tif err != nil {\n \t\treturn module.Version{}, err\n \t}\n@@ -218,42 +127,3 @@ func (*mvsReqs) next(m module.Version) (module.Version, error) {\n \t}\n \treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n }\n-\n-// fetch downloads the given module (or its replacement)\n-// and returns its location.\n-//\n-// The isLocal return value reports whether the replacement,\n-// if any, is local to the filesystem.\n-func fetch(mod module.Version) (dir string, isLocal bool, err error) {\n-\tif mod == Target {\n-\t\treturn ModRoot(), true, nil\n-\t}\n-\tif r := Replacement(mod); r.Path != \"\" {\n-\t\tif r.Version == \"\" {\n-\t\t\tdir = r.Path\n-\t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n-\t\t\t}\n-\t\t\t// Ensure that the replacement directory actually exists:\n-\t\t\t// dirInModule does not report errors for missing modules,\n-\t\t\t// so if we don't report the error now, later failures will be\n-\t\t\t// very mysterious.\n-\t\t\tif _, err := os.Stat(dir); err != nil {\n-\t\t\t\tif os.IsNotExist(err) {\n-\t\t\t\t\t// Semantically the module version itself \u201cexists\u201d \u2014 we just don't\n-\t\t\t\t\t// have its source code. Remove the equivalence to os.ErrNotExist,\n-\t\t\t\t\t// and make the message more concise while we're at it.\n-\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s does not exist\", r.Path)\n-\t\t\t\t} else {\n-\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s: %w\", r.Path, err)\n-\t\t\t\t}\n-\t\t\t\treturn dir, true, module.VersionError(mod, err)\n-\t\t\t}\n-\t\t\treturn dir, true, nil\n-\t\t}\n-\t\tmod = r\n-\t}\n-\n-\tdir, err = modfetch.Download(mod)\n-\treturn dir, false, err\n-}"}, {"sha": "50e93c381fdd1d4fba4c99c939368c0e04f5a9d3", "filename": "libgo/go/cmd/go/internal/modload/mvs_test.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modload\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestReqsMax(t *testing.T) {\n+\ttype testCase struct {\n+\t\ta, b, want string\n+\t}\n+\treqs := new(mvsReqs)\n+\tfor _, tc := range []testCase{\n+\t\t{a: \"v0.1.0\", b: \"v0.2.0\", want: \"v0.2.0\"},\n+\t\t{a: \"v0.2.0\", b: \"v0.1.0\", want: \"v0.2.0\"},\n+\t\t{a: \"\", b: \"v0.1.0\", want: \"\"}, // \"\" is Target.Version\n+\t\t{a: \"v0.1.0\", b: \"\", want: \"\"},\n+\t\t{a: \"none\", b: \"v0.1.0\", want: \"v0.1.0\"},\n+\t\t{a: \"v0.1.0\", b: \"none\", want: \"v0.1.0\"},\n+\t\t{a: \"none\", b: \"\", want: \"\"},\n+\t\t{a: \"\", b: \"none\", want: \"\"},\n+\t} {\n+\t\tmax := reqs.Max(tc.a, tc.b)\n+\t\tif max != tc.want {\n+\t\t\tt.Errorf(\"(%T).Max(%q, %q) = %q; want %q\", reqs, tc.a, tc.b, max, tc.want)\n+\t\t}\n+\t}\n+}"}, {"sha": "e35e0fc16e29b7f19790125b04b2e103d8272ec2", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 619, "deletions": 221, "changes": 840, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,19 +5,23 @@\n package modload\n \n import (\n+\t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"io/fs\"\n \t\"os\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n+\t\"sort\"\n \t\"strings\"\n \t\"sync\"\n+\t\"time\"\n \n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/trace\"\n \n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n@@ -43,27 +47,43 @@ import (\n //   with non-prereleases preferred over prereleases.\n // - a repository commit identifier or tag, denoting that commit.\n //\n-// current denotes the current version of the module; it may be \"\" if the\n-// current version is unknown or should not be considered. If query is\n+// current denotes the currently-selected version of the module; it may be\n+// \"none\" if no version is currently selected, or \"\" if the currently-selected\n+// version is unknown or should not be considered. If query is\n // \"upgrade\" or \"patch\", current will be returned if it is a newer\n // semantic version or a chronologically later pseudo-version than the\n // version that would otherwise be chosen. This prevents accidental downgrades\n // from newer pre-release or development versions.\n //\n-// If the allowed function is non-nil, Query excludes any versions for which\n-// allowed returns false.\n+// The allowed function (which may be nil) is used to filter out unsuitable\n+// versions (see AllowedFunc documentation for details). If the query refers to\n+// a specific revision (for example, \"master\"; see IsRevisionQuery), and the\n+// revision is disallowed by allowed, Query returns the error. If the query\n+// does not refer to a specific revision (for example, \"latest\"), Query\n+// acts as if versions disallowed by allowed do not exist.\n //\n // If path is the path of the main module and the query is \"latest\",\n // Query returns Target.Version as the version.\n-func Query(path, query, current string, allowed func(module.Version) bool) (*modfetch.RevInfo, error) {\n+func Query(ctx context.Context, path, query, current string, allowed AllowedFunc) (*modfetch.RevInfo, error) {\n \tvar info *modfetch.RevInfo\n \terr := modfetch.TryProxies(func(proxy string) (err error) {\n-\t\tinfo, err = queryProxy(proxy, path, query, current, allowed)\n+\t\tinfo, err = queryProxy(ctx, proxy, path, query, current, allowed)\n \t\treturn err\n \t})\n \treturn info, err\n }\n \n+// AllowedFunc is used by Query and other functions to filter out unsuitable\n+// versions, for example, those listed in exclude directives in the main\n+// module's go.mod file.\n+//\n+// An AllowedFunc returns an error equivalent to ErrDisallowed for an unsuitable\n+// version. Any other error indicates the function was unable to determine\n+// whether the version should be allowed, for example, the function was unable\n+// to fetch or parse a go.mod file containing retractions. Typically, errors\n+// other than ErrDisallowd may be ignored.\n+type AllowedFunc func(context.Context, module.Version) error\n+\n var errQueryDisabled error = queryDisabledError{}\n \n type queryDisabledError struct{}\n@@ -75,175 +95,77 @@ func (queryDisabledError) Error() string {\n \treturn fmt.Sprintf(\"cannot query module due to -mod=%s\\n\\t(%s)\", cfg.BuildMod, cfg.BuildModReason)\n }\n \n-func queryProxy(proxy, path, query, current string, allowed func(module.Version) bool) (*modfetch.RevInfo, error) {\n-\tif current != \"\" && !semver.IsValid(current) {\n+func queryProxy(ctx context.Context, proxy, path, query, current string, allowed AllowedFunc) (*modfetch.RevInfo, error) {\n+\tctx, span := trace.StartSpan(ctx, \"modload.queryProxy \"+path+\" \"+query)\n+\tdefer span.Done()\n+\n+\tif current != \"\" && current != \"none\" && !semver.IsValid(current) {\n \t\treturn nil, fmt.Errorf(\"invalid previous version %q\", current)\n \t}\n \tif cfg.BuildMod == \"vendor\" {\n \t\treturn nil, errQueryDisabled\n \t}\n \tif allowed == nil {\n-\t\tallowed = func(module.Version) bool { return true }\n+\t\tallowed = func(context.Context, module.Version) error { return nil }\n \t}\n \n-\t// Parse query to detect parse errors (and possibly handle query)\n-\t// before any network I/O.\n-\tbadVersion := func(v string) (*modfetch.RevInfo, error) {\n-\t\treturn nil, fmt.Errorf(\"invalid semantic version %q in range %q\", v, query)\n-\t}\n-\tmatchesMajor := func(v string) bool {\n-\t\t_, pathMajor, ok := module.SplitPathVersion(path)\n-\t\tif !ok {\n-\t\t\treturn false\n+\tif path == Target.Path && (query == \"upgrade\" || query == \"patch\") {\n+\t\tif err := allowed(ctx, Target); err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"internal error: main module version is not allowed: %w\", err)\n \t\t}\n-\t\treturn module.CheckPathMajor(v, pathMajor) == nil\n+\t\treturn &modfetch.RevInfo{Version: Target.Version}, nil\n \t}\n-\tvar (\n-\t\tok                 func(module.Version) bool\n-\t\tprefix             string\n-\t\tpreferOlder        bool\n-\t\tmayUseLatest       bool\n-\t\tpreferIncompatible bool = strings.HasSuffix(current, \"+incompatible\")\n-\t)\n-\tswitch {\n-\tcase query == \"latest\":\n-\t\tok = allowed\n-\t\tmayUseLatest = true\n \n-\tcase query == \"upgrade\":\n-\t\tok = allowed\n-\t\tmayUseLatest = true\n-\n-\tcase query == \"patch\":\n-\t\tif current == \"\" {\n-\t\t\tok = allowed\n-\t\t\tmayUseLatest = true\n-\t\t} else {\n-\t\t\tprefix = semver.MajorMinor(current)\n-\t\t\tok = func(m module.Version) bool {\n-\t\t\t\treturn matchSemverPrefix(prefix, m.Version) && allowed(m)\n-\t\t\t}\n-\t\t}\n-\n-\tcase strings.HasPrefix(query, \"<=\"):\n-\t\tv := query[len(\"<=\"):]\n-\t\tif !semver.IsValid(v) {\n-\t\t\treturn badVersion(v)\n-\t\t}\n-\t\tif isSemverPrefix(v) {\n-\t\t\t// Refuse to say whether <=v1.2 allows v1.2.3 (remember, @v1.2 might mean v1.2.3).\n-\t\t\treturn nil, fmt.Errorf(\"ambiguous semantic version %q in range %q\", v, query)\n-\t\t}\n-\t\tok = func(m module.Version) bool {\n-\t\t\treturn semver.Compare(m.Version, v) <= 0 && allowed(m)\n-\t\t}\n-\t\tif !matchesMajor(v) {\n-\t\t\tpreferIncompatible = true\n-\t\t}\n-\n-\tcase strings.HasPrefix(query, \"<\"):\n-\t\tv := query[len(\"<\"):]\n-\t\tif !semver.IsValid(v) {\n-\t\t\treturn badVersion(v)\n-\t\t}\n-\t\tok = func(m module.Version) bool {\n-\t\t\treturn semver.Compare(m.Version, v) < 0 && allowed(m)\n-\t\t}\n-\t\tif !matchesMajor(v) {\n-\t\t\tpreferIncompatible = true\n-\t\t}\n-\n-\tcase strings.HasPrefix(query, \">=\"):\n-\t\tv := query[len(\">=\"):]\n-\t\tif !semver.IsValid(v) {\n-\t\t\treturn badVersion(v)\n-\t\t}\n-\t\tok = func(m module.Version) bool {\n-\t\t\treturn semver.Compare(m.Version, v) >= 0 && allowed(m)\n-\t\t}\n-\t\tpreferOlder = true\n-\t\tif !matchesMajor(v) {\n-\t\t\tpreferIncompatible = true\n-\t\t}\n+\tif path == \"std\" || path == \"cmd\" {\n+\t\treturn nil, fmt.Errorf(\"can't query specific version (%q) of standard-library module %q\", query, path)\n+\t}\n \n-\tcase strings.HasPrefix(query, \">\"):\n-\t\tv := query[len(\">\"):]\n-\t\tif !semver.IsValid(v) {\n-\t\t\treturn badVersion(v)\n-\t\t}\n-\t\tif isSemverPrefix(v) {\n-\t\t\t// Refuse to say whether >v1.2 allows v1.2.3 (remember, @v1.2 might mean v1.2.3).\n-\t\t\treturn nil, fmt.Errorf(\"ambiguous semantic version %q in range %q\", v, query)\n-\t\t}\n-\t\tok = func(m module.Version) bool {\n-\t\t\treturn semver.Compare(m.Version, v) > 0 && allowed(m)\n-\t\t}\n-\t\tpreferOlder = true\n-\t\tif !matchesMajor(v) {\n-\t\t\tpreferIncompatible = true\n-\t\t}\n+\trepo, err := lookupRepo(proxy, path)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \n-\tcase semver.IsValid(query) && isSemverPrefix(query):\n-\t\tok = func(m module.Version) bool {\n-\t\t\treturn matchSemverPrefix(query, m.Version) && allowed(m)\n-\t\t}\n-\t\tprefix = query + \".\"\n-\t\tif !matchesMajor(query) {\n-\t\t\tpreferIncompatible = true\n-\t\t}\n+\t// Parse query to detect parse errors (and possibly handle query)\n+\t// before any network I/O.\n+\tqm, err := newQueryMatcher(path, query, current, allowed)\n+\tif (err == nil && qm.canStat) || err == errRevQuery {\n+\t\t// Direct lookup of a commit identifier or complete (non-prefix) semantic\n+\t\t// version.\n \n-\tdefault:\n-\t\t// Direct lookup of semantic version or commit identifier.\n-\t\t//\n \t\t// If the identifier is not a canonical semver tag \u2014 including if it's a\n \t\t// semver tag with a +metadata suffix \u2014 then modfetch.Stat will populate\n \t\t// info.Version with a suitable pseudo-version.\n-\t\tinfo, err := modfetch.Stat(proxy, path, query)\n+\t\tinfo, err := repo.Stat(query)\n \t\tif err != nil {\n \t\t\tqueryErr := err\n \t\t\t// The full query doesn't correspond to a tag. If it is a semantic version\n \t\t\t// with a +metadata suffix, see if there is a tag without that suffix:\n \t\t\t// semantic versioning defines them to be equivalent.\n-\t\t\tif vers := module.CanonicalVersion(query); vers != \"\" && vers != query {\n-\t\t\t\tinfo, err = modfetch.Stat(proxy, path, vers)\n-\t\t\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\tcanonicalQuery := module.CanonicalVersion(query)\n+\t\t\tif canonicalQuery != \"\" && query != canonicalQuery {\n+\t\t\t\tinfo, err = repo.Stat(canonicalQuery)\n+\t\t\t\tif err != nil && !errors.Is(err, fs.ErrNotExist) {\n \t\t\t\t\treturn info, err\n \t\t\t\t}\n \t\t\t}\n \t\t\tif err != nil {\n \t\t\t\treturn nil, queryErr\n \t\t\t}\n \t\t}\n-\t\tif !allowed(module.Version{Path: path, Version: info.Version}) {\n-\t\t\treturn nil, fmt.Errorf(\"%s@%s excluded\", path, info.Version)\n+\t\tif err := allowed(ctx, module.Version{Path: path, Version: info.Version}); errors.Is(err, ErrDisallowed) {\n+\t\t\treturn nil, err\n \t\t}\n \t\treturn info, nil\n-\t}\n-\n-\tif path == Target.Path {\n-\t\tif query != \"latest\" {\n-\t\t\treturn nil, fmt.Errorf(\"can't query specific version (%q) for the main module (%s)\", query, path)\n-\t\t}\n-\t\tif !allowed(Target) {\n-\t\t\treturn nil, fmt.Errorf(\"internal error: main module version is not allowed\")\n-\t\t}\n-\t\treturn &modfetch.RevInfo{Version: Target.Version}, nil\n-\t}\n-\n-\tif str.HasPathPrefix(path, \"std\") || str.HasPathPrefix(path, \"cmd\") {\n-\t\treturn nil, fmt.Errorf(\"explicit requirement on standard-library module %s not allowed\", path)\n+\t} else if err != nil {\n+\t\treturn nil, err\n \t}\n \n \t// Load versions and execute query.\n-\trepo, err := modfetch.Lookup(proxy, path)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tversions, err := repo.Versions(prefix)\n+\tversions, err := repo.Versions(qm.prefix)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treleases, prereleases, err := filterVersions(path, versions, ok, preferIncompatible)\n+\treleases, prereleases, err := qm.filterVersions(ctx, versions)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -254,19 +176,38 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t\t\treturn nil, err\n \t\t}\n \n-\t\t// For \"upgrade\" and \"patch\", make sure we don't accidentally downgrade\n-\t\t// from a newer prerelease or from a chronologically newer pseudoversion.\n-\t\tif current != \"\" && (query == \"upgrade\" || query == \"patch\") {\n+\t\tif (query == \"upgrade\" || query == \"patch\") && modfetch.IsPseudoVersion(current) && !rev.Time.IsZero() {\n+\t\t\t// Don't allow \"upgrade\" or \"patch\" to move from a pseudo-version\n+\t\t\t// to a chronologically older version or pseudo-version.\n+\t\t\t//\n+\t\t\t// If the current version is a pseudo-version from an untagged branch, it\n+\t\t\t// may be semantically lower than the \"latest\" release or the latest\n+\t\t\t// pseudo-version on the main branch. A user on such a version is unlikely\n+\t\t\t// to intend to \u201cupgrade\u201d to a version that already existed at that point\n+\t\t\t// in time.\n+\t\t\t//\n+\t\t\t// We do this only if the current version is a pseudo-version: if the\n+\t\t\t// version is tagged, the author of the dependency module has given us\n+\t\t\t// explicit information about their intended precedence of this version\n+\t\t\t// relative to other versions, and we shouldn't contradict that\n+\t\t\t// information. (For example, v1.0.1 might be a backport of a fix already\n+\t\t\t// incorporated into v1.1.0, in which case v1.0.1 would be chronologically\n+\t\t\t// newer but v1.1.0 is still an \u201cupgrade\u201d; or v1.0.2 might be a revert of\n+\t\t\t// an unsuccessful fix in v1.0.1, in which case the v1.0.2 commit may be\n+\t\t\t// older than the v1.0.1 commit despite the tag itself being newer.)\n \t\t\tcurrentTime, err := modfetch.PseudoVersionTime(current)\n-\t\t\tif semver.Compare(rev.Version, current) < 0 || (err == nil && rev.Time.Before(currentTime)) {\n+\t\t\tif err == nil && rev.Time.Before(currentTime) {\n+\t\t\t\tif err := allowed(ctx, module.Version{Path: path, Version: current}); errors.Is(err, ErrDisallowed) {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n \t\t\t\treturn repo.Stat(current)\n \t\t\t}\n \t\t}\n \n \t\treturn rev, nil\n \t}\n \n-\tif preferOlder {\n+\tif qm.preferLower {\n \t\tif len(releases) > 0 {\n \t\t\treturn lookup(releases[0])\n \t\t}\n@@ -282,22 +223,44 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t\t}\n \t}\n \n-\tif mayUseLatest {\n-\t\t// Special case for \"latest\": if no tags match, use latest commit in repo,\n-\t\t// provided it is not excluded.\n+\tif qm.mayUseLatest {\n \t\tlatest, err := repo.Latest()\n \t\tif err == nil {\n-\t\t\tif allowed(module.Version{Path: path, Version: latest.Version}) {\n+\t\t\tif qm.allowsVersion(ctx, latest.Version) {\n \t\t\t\treturn lookup(latest.Version)\n \t\t\t}\n-\t\t} else if !errors.Is(err, os.ErrNotExist) {\n+\t\t} else if !errors.Is(err, fs.ErrNotExist) {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tif (query == \"upgrade\" || query == \"patch\") && current != \"\" && current != \"none\" {\n+\t\t// \"upgrade\" and \"patch\" may stay on the current version if allowed.\n+\t\tif err := allowed(ctx, module.Version{Path: path, Version: current}); errors.Is(err, ErrDisallowed) {\n \t\t\treturn nil, err\n \t\t}\n+\t\treturn lookup(current)\n \t}\n \n \treturn nil, &NoMatchingVersionError{query: query, current: current}\n }\n \n+// IsRevisionQuery returns true if vers is a version query that may refer to\n+// a particular version or revision in a repository like \"v1.0.0\", \"master\",\n+// or \"0123abcd\". IsRevisionQuery returns false if vers is a query that\n+// chooses from among available versions like \"latest\" or \">v1.0.0\".\n+func IsRevisionQuery(vers string) bool {\n+\tif vers == \"latest\" ||\n+\t\tvers == \"upgrade\" ||\n+\t\tvers == \"patch\" ||\n+\t\tstrings.HasPrefix(vers, \"<\") ||\n+\t\tstrings.HasPrefix(vers, \">\") ||\n+\t\t(semver.IsValid(vers) && isSemverPrefix(vers)) {\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n // isSemverPrefix reports whether v is a semantic version prefix: v1 or v1.2 (not v1.2.3).\n // The caller is assumed to have checked that semver.IsValid(v) is true.\n func isSemverPrefix(v string) bool {\n@@ -316,45 +279,213 @@ func isSemverPrefix(v string) bool {\n \treturn true\n }\n \n-// matchSemverPrefix reports whether the shortened semantic version p\n-// matches the full-width (non-shortened) semantic version v.\n-func matchSemverPrefix(p, v string) bool {\n-\treturn len(v) > len(p) && v[len(p)] == '.' && v[:len(p)] == p && semver.Prerelease(v) == \"\"\n+type queryMatcher struct {\n+\tpath               string\n+\tprefix             string\n+\tfilter             func(version string) bool\n+\tallowed            AllowedFunc\n+\tcanStat            bool // if true, the query can be resolved by repo.Stat\n+\tpreferLower        bool // if true, choose the lowest matching version\n+\tmayUseLatest       bool\n+\tpreferIncompatible bool\n+}\n+\n+var errRevQuery = errors.New(\"query refers to a non-semver revision\")\n+\n+// newQueryMatcher returns a new queryMatcher that matches the versions\n+// specified by the given query on the module with the given path.\n+//\n+// If the query can only be resolved by statting a non-SemVer revision,\n+// newQueryMatcher returns errRevQuery.\n+func newQueryMatcher(path string, query, current string, allowed AllowedFunc) (*queryMatcher, error) {\n+\tbadVersion := func(v string) (*queryMatcher, error) {\n+\t\treturn nil, fmt.Errorf(\"invalid semantic version %q in range %q\", v, query)\n+\t}\n+\n+\tmatchesMajor := func(v string) bool {\n+\t\t_, pathMajor, ok := module.SplitPathVersion(path)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\treturn module.CheckPathMajor(v, pathMajor) == nil\n+\t}\n+\n+\tqm := &queryMatcher{\n+\t\tpath:               path,\n+\t\tallowed:            allowed,\n+\t\tpreferIncompatible: strings.HasSuffix(current, \"+incompatible\"),\n+\t}\n+\n+\tswitch {\n+\tcase query == \"latest\":\n+\t\tqm.mayUseLatest = true\n+\n+\tcase query == \"upgrade\":\n+\t\tif current == \"\" || current == \"none\" {\n+\t\t\tqm.mayUseLatest = true\n+\t\t} else {\n+\t\t\tqm.mayUseLatest = modfetch.IsPseudoVersion(current)\n+\t\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, current) >= 0 }\n+\t\t}\n+\n+\tcase query == \"patch\":\n+\t\tif current == \"none\" {\n+\t\t\treturn nil, &NoPatchBaseError{path}\n+\t\t}\n+\t\tif current == \"\" {\n+\t\t\tqm.mayUseLatest = true\n+\t\t} else {\n+\t\t\tqm.mayUseLatest = modfetch.IsPseudoVersion(current)\n+\t\t\tqm.prefix = semver.MajorMinor(current) + \".\"\n+\t\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, current) >= 0 }\n+\t\t}\n+\n+\tcase strings.HasPrefix(query, \"<=\"):\n+\t\tv := query[len(\"<=\"):]\n+\t\tif !semver.IsValid(v) {\n+\t\t\treturn badVersion(v)\n+\t\t}\n+\t\tif isSemverPrefix(v) {\n+\t\t\t// Refuse to say whether <=v1.2 allows v1.2.3 (remember, @v1.2 might mean v1.2.3).\n+\t\t\treturn nil, fmt.Errorf(\"ambiguous semantic version %q in range %q\", v, query)\n+\t\t}\n+\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, v) <= 0 }\n+\t\tif !matchesMajor(v) {\n+\t\t\tqm.preferIncompatible = true\n+\t\t}\n+\n+\tcase strings.HasPrefix(query, \"<\"):\n+\t\tv := query[len(\"<\"):]\n+\t\tif !semver.IsValid(v) {\n+\t\t\treturn badVersion(v)\n+\t\t}\n+\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, v) < 0 }\n+\t\tif !matchesMajor(v) {\n+\t\t\tqm.preferIncompatible = true\n+\t\t}\n+\n+\tcase strings.HasPrefix(query, \">=\"):\n+\t\tv := query[len(\">=\"):]\n+\t\tif !semver.IsValid(v) {\n+\t\t\treturn badVersion(v)\n+\t\t}\n+\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, v) >= 0 }\n+\t\tqm.preferLower = true\n+\t\tif !matchesMajor(v) {\n+\t\t\tqm.preferIncompatible = true\n+\t\t}\n+\n+\tcase strings.HasPrefix(query, \">\"):\n+\t\tv := query[len(\">\"):]\n+\t\tif !semver.IsValid(v) {\n+\t\t\treturn badVersion(v)\n+\t\t}\n+\t\tif isSemverPrefix(v) {\n+\t\t\t// Refuse to say whether >v1.2 allows v1.2.3 (remember, @v1.2 might mean v1.2.3).\n+\t\t\treturn nil, fmt.Errorf(\"ambiguous semantic version %q in range %q\", v, query)\n+\t\t}\n+\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, v) > 0 }\n+\t\tqm.preferLower = true\n+\t\tif !matchesMajor(v) {\n+\t\t\tqm.preferIncompatible = true\n+\t\t}\n+\n+\tcase semver.IsValid(query):\n+\t\tif isSemverPrefix(query) {\n+\t\t\tqm.prefix = query + \".\"\n+\t\t\t// Do not allow the query \"v1.2\" to match versions lower than \"v1.2.0\",\n+\t\t\t// such as prereleases for that version. (https://golang.org/issue/31972)\n+\t\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, query) >= 0 }\n+\t\t} else {\n+\t\t\tqm.canStat = true\n+\t\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, query) == 0 }\n+\t\t\tqm.prefix = semver.Canonical(query)\n+\t\t}\n+\t\tif !matchesMajor(query) {\n+\t\t\tqm.preferIncompatible = true\n+\t\t}\n+\n+\tdefault:\n+\t\treturn nil, errRevQuery\n+\t}\n+\n+\treturn qm, nil\n+}\n+\n+// allowsVersion reports whether version v is allowed by the prefix, filter, and\n+// AllowedFunc of qm.\n+func (qm *queryMatcher) allowsVersion(ctx context.Context, v string) bool {\n+\tif qm.prefix != \"\" && !strings.HasPrefix(v, qm.prefix) {\n+\t\treturn false\n+\t}\n+\tif qm.filter != nil && !qm.filter(v) {\n+\t\treturn false\n+\t}\n+\tif qm.allowed != nil {\n+\t\tif err := qm.allowed(ctx, module.Version{Path: qm.path, Version: v}); errors.Is(err, ErrDisallowed) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n }\n \n // filterVersions classifies versions into releases and pre-releases, filtering\n // out:\n-// \t1. versions that do not satisfy the 'ok' predicate, and\n+// \t1. versions that do not satisfy the 'allowed' predicate, and\n // \t2. \"+incompatible\" versions, if a compatible one satisfies the predicate\n // \t   and the incompatible version is not preferred.\n-func filterVersions(path string, versions []string, ok func(module.Version) bool, preferIncompatible bool) (releases, prereleases []string, err error) {\n+//\n+// If the allowed predicate returns an error not equivalent to ErrDisallowed,\n+// filterVersions returns that error.\n+func (qm *queryMatcher) filterVersions(ctx context.Context, versions []string) (releases, prereleases []string, err error) {\n+\tneedIncompatible := qm.preferIncompatible\n+\n \tvar lastCompatible string\n \tfor _, v := range versions {\n-\t\tif !ok(module.Version{Path: path, Version: v}) {\n+\t\tif !qm.allowsVersion(ctx, v) {\n \t\t\tcontinue\n \t\t}\n \n-\t\tif !preferIncompatible {\n+\t\tif !needIncompatible {\n+\t\t\t// We're not yet sure whether we need to include +incomptaible versions.\n+\t\t\t// Keep track of the last compatible version we've seen, and use the\n+\t\t\t// presence (or absence) of a go.mod file in that version to decide: a\n+\t\t\t// go.mod file implies that the module author is supporting modules at a\n+\t\t\t// compatible version (and we should ignore +incompatible versions unless\n+\t\t\t// requested explicitly), while a lack of go.mod file implies the\n+\t\t\t// potential for legacy (pre-modules) versioning without semantic import\n+\t\t\t// paths (and thus *with* +incompatible versions).\n+\t\t\t//\n+\t\t\t// This isn't strictly accurate if the latest compatible version has been\n+\t\t\t// replaced by a local file path, because we do not allow file-path\n+\t\t\t// replacements without a go.mod file: the user would have needed to add\n+\t\t\t// one. However, replacing the last compatible version while\n+\t\t\t// simultaneously expecting to upgrade implicitly to a +incompatible\n+\t\t\t// version seems like an extreme enough corner case to ignore for now.\n+\n \t\t\tif !strings.HasSuffix(v, \"+incompatible\") {\n \t\t\t\tlastCompatible = v\n \t\t\t} else if lastCompatible != \"\" {\n \t\t\t\t// If the latest compatible version is allowed and has a go.mod file,\n \t\t\t\t// ignore any version with a higher (+incompatible) major version. (See\n \t\t\t\t// https://golang.org/issue/34165.) Note that we even prefer a\n \t\t\t\t// compatible pre-release over an incompatible release.\n-\n-\t\t\t\tok, err := versionHasGoMod(module.Version{Path: path, Version: lastCompatible})\n+\t\t\t\tok, err := versionHasGoMod(ctx, module.Version{Path: qm.path, Version: lastCompatible})\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn nil, nil, err\n \t\t\t\t}\n \t\t\t\tif ok {\n+\t\t\t\t\t// The last compatible version has a go.mod file, so that's the\n+\t\t\t\t\t// highest version we're willing to consider. Don't bother even\n+\t\t\t\t\t// looking at higher versions, because they're all +incompatible from\n+\t\t\t\t\t// here onward.\n \t\t\t\t\tbreak\n \t\t\t\t}\n \n \t\t\t\t// No acceptable compatible release has a go.mod file, so the versioning\n \t\t\t\t// for the module might not be module-aware, and we should respect\n \t\t\t\t// legacy major-version tags.\n-\t\t\t\tpreferIncompatible = true\n+\t\t\t\tneedIncompatible = true\n \t\t\t}\n \t\t}\n \n@@ -374,34 +505,42 @@ type QueryResult struct {\n \tPackages []string\n }\n \n-// QueryPackage looks up the module(s) containing path at a revision matching\n-// query. The results are sorted by module path length in descending order.\n-//\n-// If the package is in the main module, QueryPackage considers only the main\n-// module and only the version \"latest\", without checking for other possible\n-// modules.\n-func QueryPackage(path, query string, allowed func(module.Version) bool) ([]QueryResult, error) {\n-\tm := search.NewMatch(path)\n-\tif m.IsLocal() || !m.IsLiteral() {\n-\t\treturn nil, fmt.Errorf(\"pattern %s is not an importable package\", path)\n+// QueryPackages is like QueryPattern, but requires that the pattern match at\n+// least one package and omits the non-package result (if any).\n+func QueryPackages(ctx context.Context, pattern, query string, current func(string) string, allowed AllowedFunc) ([]QueryResult, error) {\n+\tpkgMods, modOnly, err := QueryPattern(ctx, pattern, query, current, allowed)\n+\n+\tif len(pkgMods) == 0 && err == nil {\n+\t\treturn nil, &PackageNotInModuleError{\n+\t\t\tMod:         modOnly.Mod,\n+\t\t\tReplacement: Replacement(modOnly.Mod),\n+\t\t\tQuery:       query,\n+\t\t\tPattern:     pattern,\n+\t\t}\n \t}\n-\treturn QueryPattern(path, query, allowed)\n+\n+\treturn pkgMods, err\n }\n \n // QueryPattern looks up the module(s) containing at least one package matching\n // the given pattern at the given version. The results are sorted by module path\n-// length in descending order.\n+// length in descending order. If any proxy provides a non-empty set of candidate\n+// modules, no further proxies are tried.\n //\n-// QueryPattern queries modules with package paths up to the first \"...\"\n-// in the pattern. For the pattern \"example.com/a/b.../c\", QueryPattern would\n-// consider prefixes of \"example.com/a\". If multiple modules have versions\n-// that match the query and packages that match the pattern, QueryPattern\n-// picks the one with the longest module path.\n+// For wildcard patterns, QueryPattern looks in modules with package paths up to\n+// the first \"...\" in the pattern. For the pattern \"example.com/a/b.../c\",\n+// QueryPattern would consider prefixes of \"example.com/a\".\n //\n // If any matching package is in the main module, QueryPattern considers only\n // the main module and only the version \"latest\", without checking for other\n // possible modules.\n-func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]QueryResult, error) {\n+//\n+// QueryPattern always returns at least one QueryResult (which may be only\n+// modOnly) or a non-nil error.\n+func QueryPattern(ctx context.Context, pattern, query string, current func(string) string, allowed AllowedFunc) (pkgMods []QueryResult, modOnly *QueryResult, err error) {\n+\tctx, span := trace.StartSpan(ctx, \"modload.QueryPattern \"+pattern+\" \"+query)\n+\tdefer span.Done()\n+\n \tbase := pattern\n \n \tfirstError := func(m *search.Match) error {\n@@ -412,12 +551,16 @@ func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]Q\n \t}\n \n \tvar match func(mod module.Version, root string, isLocal bool) *search.Match\n+\tmatchPattern := search.MatchPattern(pattern)\n \n \tif i := strings.Index(pattern, \"...\"); i >= 0 {\n \t\tbase = pathpkg.Dir(pattern[:i+3])\n+\t\tif base == \".\" {\n+\t\t\treturn nil, nil, &WildcardInFirstElementError{Pattern: pattern, Query: query}\n+\t\t}\n \t\tmatch = func(mod module.Version, root string, isLocal bool) *search.Match {\n \t\t\tm := search.NewMatch(pattern)\n-\t\t\tmatchPackages(m, imports.AnyTags(), omitStd, []module.Version{mod})\n+\t\t\tmatchPackages(ctx, m, imports.AnyTags(), omitStd, []module.Version{mod})\n \t\t\treturn m\n \t\t}\n \t} else {\n@@ -436,23 +579,41 @@ func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]Q\n \t\t}\n \t}\n \n+\tvar queryMatchesMainModule bool\n \tif HasModRoot() {\n \t\tm := match(Target, modRoot, true)\n \t\tif len(m.Pkgs) > 0 {\n-\t\t\tif query != \"latest\" {\n-\t\t\t\treturn nil, fmt.Errorf(\"can't query specific version for package %s in the main module (%s)\", pattern, Target.Path)\n+\t\t\tif query != \"upgrade\" && query != \"patch\" {\n+\t\t\t\treturn nil, nil, &QueryMatchesPackagesInMainModuleError{\n+\t\t\t\t\tPattern:  pattern,\n+\t\t\t\t\tQuery:    query,\n+\t\t\t\t\tPackages: m.Pkgs,\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tif !allowed(Target) {\n-\t\t\t\treturn nil, fmt.Errorf(\"internal error: package %s is in the main module (%s), but version is not allowed\", pattern, Target.Path)\n+\t\t\tif err := allowed(ctx, Target); err != nil {\n+\t\t\t\treturn nil, nil, fmt.Errorf(\"internal error: package %s is in the main module (%s), but version is not allowed: %w\", pattern, Target.Path, err)\n \t\t\t}\n \t\t\treturn []QueryResult{{\n \t\t\t\tMod:      Target,\n \t\t\t\tRev:      &modfetch.RevInfo{Version: Target.Version},\n \t\t\t\tPackages: m.Pkgs,\n-\t\t\t}}, nil\n+\t\t\t}}, nil, nil\n \t\t}\n \t\tif err := firstError(m); err != nil {\n-\t\t\treturn nil, err\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\n+\t\tif matchPattern(Target.Path) {\n+\t\t\tqueryMatchesMainModule = true\n+\t\t}\n+\n+\t\tif (query == \"upgrade\" || query == \"patch\") && queryMatchesMainModule {\n+\t\t\tif err := allowed(ctx, Target); err == nil {\n+\t\t\t\tmodOnly = &QueryResult{\n+\t\t\t\t\tMod: Target,\n+\t\t\t\t\tRev: &modfetch.RevInfo{Version: Target.Version},\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -461,29 +622,42 @@ func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]Q\n \t\tcandidateModules = modulePrefixesExcludingTarget(base)\n \t)\n \tif len(candidateModules) == 0 {\n-\t\treturn nil, &PackageNotInModuleError{\n-\t\t\tMod:     Target,\n-\t\t\tQuery:   query,\n-\t\t\tPattern: pattern,\n+\t\tif modOnly != nil {\n+\t\t\treturn nil, modOnly, nil\n+\t\t} else if queryMatchesMainModule {\n+\t\t\treturn nil, nil, &QueryMatchesMainModuleError{\n+\t\t\t\tPattern: pattern,\n+\t\t\t\tQuery:   query,\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn nil, nil, &PackageNotInModuleError{\n+\t\t\t\tMod:     Target,\n+\t\t\t\tQuery:   query,\n+\t\t\t\tPattern: pattern,\n+\t\t\t}\n \t\t}\n \t}\n \n-\terr := modfetch.TryProxies(func(proxy string) error {\n-\t\tqueryModule := func(path string) (r QueryResult, err error) {\n-\t\t\tcurrent := findCurrentVersion(path)\n+\terr = modfetch.TryProxies(func(proxy string) error {\n+\t\tqueryModule := func(ctx context.Context, path string) (r QueryResult, err error) {\n+\t\t\tctx, span := trace.StartSpan(ctx, \"modload.QueryPattern.queryModule [\"+proxy+\"] \"+path)\n+\t\t\tdefer span.Done()\n+\n+\t\t\tpathCurrent := current(path)\n \t\t\tr.Mod.Path = path\n-\t\t\tr.Rev, err = queryProxy(proxy, path, query, current, allowed)\n+\t\t\tr.Rev, err = queryProxy(ctx, proxy, path, query, pathCurrent, allowed)\n \t\t\tif err != nil {\n \t\t\t\treturn r, err\n \t\t\t}\n \t\t\tr.Mod.Version = r.Rev.Version\n-\t\t\troot, isLocal, err := fetch(r.Mod)\n+\t\t\tneedSum := true\n+\t\t\troot, isLocal, err := fetch(ctx, r.Mod, needSum)\n \t\t\tif err != nil {\n \t\t\t\treturn r, err\n \t\t\t}\n \t\t\tm := match(r.Mod, root, isLocal)\n \t\t\tr.Packages = m.Pkgs\n-\t\t\tif len(r.Packages) == 0 {\n+\t\t\tif len(r.Packages) == 0 && !matchPattern(path) {\n \t\t\t\tif err := firstError(m); err != nil {\n \t\t\t\t\treturn r, err\n \t\t\t\t}\n@@ -497,12 +671,25 @@ func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]Q\n \t\t\treturn r, nil\n \t\t}\n \n-\t\tvar err error\n-\t\tresults, err = queryPrefixModules(candidateModules, queryModule)\n+\t\tallResults, err := queryPrefixModules(ctx, candidateModules, queryModule)\n+\t\tresults = allResults[:0]\n+\t\tfor _, r := range allResults {\n+\t\t\tif len(r.Packages) == 0 {\n+\t\t\t\tmodOnly = &r\n+\t\t\t} else {\n+\t\t\t\tresults = append(results, r)\n+\t\t\t}\n+\t\t}\n \t\treturn err\n \t})\n \n-\treturn results, err\n+\tif queryMatchesMainModule && len(results) == 0 && modOnly == nil && errors.Is(err, fs.ErrNotExist) {\n+\t\treturn nil, nil, &QueryMatchesMainModuleError{\n+\t\t\tPattern: pattern,\n+\t\t\tQuery:   query,\n+\t\t}\n+\t}\n+\treturn results[:len(results):len(results)], modOnly, err\n }\n \n // modulePrefixesExcludingTarget returns all prefixes of path that may plausibly\n@@ -528,21 +715,10 @@ func modulePrefixesExcludingTarget(path string) []string {\n \treturn prefixes\n }\n \n-func findCurrentVersion(path string) string {\n-\tfor _, m := range buildList {\n-\t\tif m.Path == path {\n-\t\t\treturn m.Version\n-\t\t}\n-\t}\n-\treturn \"\"\n-}\n-\n-type prefixResult struct {\n-\tQueryResult\n-\terr error\n-}\n+func queryPrefixModules(ctx context.Context, candidateModules []string, queryModule func(ctx context.Context, path string) (QueryResult, error)) (found []QueryResult, err error) {\n+\tctx, span := trace.StartSpan(ctx, \"modload.queryPrefixModules\")\n+\tdefer span.Done()\n \n-func queryPrefixModules(candidateModules []string, queryModule func(path string) (QueryResult, error)) (found []QueryResult, err error) {\n \t// If the path we're attempting is not in the module cache and we don't have a\n \t// fetch result cached either, we'll end up making a (potentially slow)\n \t// request to the proxy or (often even slower) the origin server.\n@@ -555,8 +731,9 @@ func queryPrefixModules(candidateModules []string, queryModule func(path string)\n \tvar wg sync.WaitGroup\n \twg.Add(len(candidateModules))\n \tfor i, p := range candidateModules {\n+\t\tctx := trace.StartGoroutine(ctx)\n \t\tgo func(p string, r *result) {\n-\t\t\tr.QueryResult, r.err = queryModule(p)\n+\t\t\tr.QueryResult, r.err = queryModule(ctx, p)\n \t\t\twg.Done()\n \t\t}(p, &results[i])\n \t}\n@@ -568,6 +745,7 @@ func queryPrefixModules(candidateModules []string, queryModule func(path string)\n \tvar (\n \t\tnoPackage   *PackageNotInModuleError\n \t\tnoVersion   *NoMatchingVersionError\n+\t\tnoPatchBase *NoPatchBaseError\n \t\tnotExistErr error\n \t)\n \tfor _, r := range results {\n@@ -584,8 +762,12 @@ func queryPrefixModules(candidateModules []string, queryModule func(path string)\n \t\t\tif noVersion == nil {\n \t\t\t\tnoVersion = rErr\n \t\t\t}\n+\t\tcase *NoPatchBaseError:\n+\t\t\tif noPatchBase == nil {\n+\t\t\t\tnoPatchBase = rErr\n+\t\t\t}\n \t\tdefault:\n-\t\t\tif errors.Is(rErr, os.ErrNotExist) {\n+\t\t\tif errors.Is(rErr, fs.ErrNotExist) {\n \t\t\t\tif notExistErr == nil {\n \t\t\t\t\tnotExistErr = rErr\n \t\t\t\t}\n@@ -615,6 +797,8 @@ func queryPrefixModules(candidateModules []string, queryModule func(path string)\n \t\t\terr = noPackage\n \t\tcase noVersion != nil:\n \t\t\terr = noVersion\n+\t\tcase noPatchBase != nil:\n+\t\t\terr = noPatchBase\n \t\tcase notExistErr != nil:\n \t\t\terr = notExistErr\n \t\tdefault:\n@@ -628,7 +812,7 @@ func queryPrefixModules(candidateModules []string, queryModule func(path string)\n // A NoMatchingVersionError indicates that Query found a module at the requested\n // path, but not at any versions satisfying the query string and allow-function.\n //\n-// NOTE: NoMatchingVersionError MUST NOT implement Is(os.ErrNotExist).\n+// NOTE: NoMatchingVersionError MUST NOT implement Is(fs.ErrNotExist).\n //\n // If the module came from a proxy, that proxy had to return a successful status\n // code for the versions it knows about, and thus did not have the opportunity\n@@ -639,17 +823,39 @@ type NoMatchingVersionError struct {\n \n func (e *NoMatchingVersionError) Error() string {\n \tcurrentSuffix := \"\"\n-\tif (e.query == \"upgrade\" || e.query == \"patch\") && e.current != \"\" {\n+\tif (e.query == \"upgrade\" || e.query == \"patch\") && e.current != \"\" && e.current != \"none\" {\n \t\tcurrentSuffix = fmt.Sprintf(\" (current version is %s)\", e.current)\n \t}\n \treturn fmt.Sprintf(\"no matching versions for query %q\", e.query) + currentSuffix\n }\n \n+// A NoPatchBaseError indicates that Query was called with the query \"patch\"\n+// but with a current version of \"\" or \"none\".\n+type NoPatchBaseError struct {\n+\tpath string\n+}\n+\n+func (e *NoPatchBaseError) Error() string {\n+\treturn fmt.Sprintf(`can't query version \"patch\" of module %s: no existing version is required`, e.path)\n+}\n+\n+// A WildcardInFirstElementError indicates that a pattern passed to QueryPattern\n+// had a wildcard in its first path element, and therefore had no pattern-prefix\n+// modules to search in.\n+type WildcardInFirstElementError struct {\n+\tPattern string\n+\tQuery   string\n+}\n+\n+func (e *WildcardInFirstElementError) Error() string {\n+\treturn fmt.Sprintf(\"no modules to query for %s@%s because first path element contains a wildcard\", e.Pattern, e.Query)\n+}\n+\n // A PackageNotInModuleError indicates that QueryPattern found a candidate\n // module at the requested version, but that module did not contain any packages\n // matching the requested pattern.\n //\n-// NOTE: PackageNotInModuleError MUST NOT implement Is(os.ErrNotExist).\n+// NOTE: PackageNotInModuleError MUST NOT implement Is(fs.ErrNotExist).\n //\n // If the module came from a proxy, that proxy had to return a successful status\n // code for the versions it knows about, and thus did not have the opportunity\n@@ -698,20 +904,212 @@ func (e *PackageNotInModuleError) ImportPath() string {\n }\n \n // ModuleHasRootPackage returns whether module m contains a package m.Path.\n-func ModuleHasRootPackage(m module.Version) (bool, error) {\n-\troot, isLocal, err := fetch(m)\n+func ModuleHasRootPackage(ctx context.Context, m module.Version) (bool, error) {\n+\tneedSum := false\n+\troot, isLocal, err := fetch(ctx, m, needSum)\n \tif err != nil {\n \t\treturn false, err\n \t}\n \t_, ok, err := dirInModule(m.Path, m.Path, root, isLocal)\n \treturn ok, err\n }\n \n-func versionHasGoMod(m module.Version) (bool, error) {\n-\troot, _, err := fetch(m)\n+func versionHasGoMod(ctx context.Context, m module.Version) (bool, error) {\n+\tneedSum := false\n+\troot, _, err := fetch(ctx, m, needSum)\n \tif err != nil {\n \t\treturn false, err\n \t}\n \tfi, err := os.Stat(filepath.Join(root, \"go.mod\"))\n \treturn err == nil && !fi.IsDir(), nil\n }\n+\n+// A versionRepo is a subset of modfetch.Repo that can report information about\n+// available versions, but cannot fetch specific source files.\n+type versionRepo interface {\n+\tModulePath() string\n+\tVersions(prefix string) ([]string, error)\n+\tStat(rev string) (*modfetch.RevInfo, error)\n+\tLatest() (*modfetch.RevInfo, error)\n+}\n+\n+var _ versionRepo = modfetch.Repo(nil)\n+\n+func lookupRepo(proxy, path string) (repo versionRepo, err error) {\n+\terr = module.CheckPath(path)\n+\tif err == nil {\n+\t\trepo = modfetch.Lookup(proxy, path)\n+\t} else {\n+\t\trepo = emptyRepo{path: path, err: err}\n+\t}\n+\n+\tif index == nil {\n+\t\treturn repo, err\n+\t}\n+\tif _, ok := index.highestReplaced[path]; !ok {\n+\t\treturn repo, err\n+\t}\n+\n+\treturn &replacementRepo{repo: repo}, nil\n+}\n+\n+// An emptyRepo is a versionRepo that contains no versions.\n+type emptyRepo struct {\n+\tpath string\n+\terr  error\n+}\n+\n+var _ versionRepo = emptyRepo{}\n+\n+func (er emptyRepo) ModulePath() string                         { return er.path }\n+func (er emptyRepo) Versions(prefix string) ([]string, error)   { return nil, nil }\n+func (er emptyRepo) Stat(rev string) (*modfetch.RevInfo, error) { return nil, er.err }\n+func (er emptyRepo) Latest() (*modfetch.RevInfo, error)         { return nil, er.err }\n+\n+// A replacementRepo augments a versionRepo to include the replacement versions\n+// (if any) found in the main module's go.mod file.\n+//\n+// A replacementRepo suppresses \"not found\" errors for otherwise-nonexistent\n+// modules, so a replacementRepo should only be constructed for a module that\n+// actually has one or more valid replacements.\n+type replacementRepo struct {\n+\trepo versionRepo\n+}\n+\n+var _ versionRepo = (*replacementRepo)(nil)\n+\n+func (rr *replacementRepo) ModulePath() string { return rr.repo.ModulePath() }\n+\n+// Versions returns the versions from rr.repo augmented with any matching\n+// replacement versions.\n+func (rr *replacementRepo) Versions(prefix string) ([]string, error) {\n+\trepoVersions, err := rr.repo.Versions(prefix)\n+\tif err != nil && !errors.Is(err, os.ErrNotExist) {\n+\t\treturn nil, err\n+\t}\n+\n+\tversions := repoVersions\n+\tif index != nil && len(index.replace) > 0 {\n+\t\tpath := rr.ModulePath()\n+\t\tfor m, _ := range index.replace {\n+\t\t\tif m.Path == path && strings.HasPrefix(m.Version, prefix) && m.Version != \"\" && !modfetch.IsPseudoVersion(m.Version) {\n+\t\t\t\tversions = append(versions, m.Version)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif len(versions) == len(repoVersions) { // No replacement versions added.\n+\t\treturn versions, nil\n+\t}\n+\n+\tsort.Slice(versions, func(i, j int) bool {\n+\t\treturn semver.Compare(versions[i], versions[j]) < 0\n+\t})\n+\tuniq := versions[:1]\n+\tfor _, v := range versions {\n+\t\tif v != uniq[len(uniq)-1] {\n+\t\t\tuniq = append(uniq, v)\n+\t\t}\n+\t}\n+\treturn uniq, nil\n+}\n+\n+func (rr *replacementRepo) Stat(rev string) (*modfetch.RevInfo, error) {\n+\tinfo, err := rr.repo.Stat(rev)\n+\tif err == nil || index == nil || len(index.replace) == 0 {\n+\t\treturn info, err\n+\t}\n+\n+\tv := module.CanonicalVersion(rev)\n+\tif v != rev {\n+\t\t// The replacements in the go.mod file list only canonical semantic versions,\n+\t\t// so a non-canonical version can't possibly have a replacement.\n+\t\treturn info, err\n+\t}\n+\n+\tpath := rr.ModulePath()\n+\t_, pathMajor, ok := module.SplitPathVersion(path)\n+\tif ok && pathMajor == \"\" {\n+\t\tif err := module.CheckPathMajor(v, pathMajor); err != nil && semver.Build(v) == \"\" {\n+\t\t\tv += \"+incompatible\"\n+\t\t}\n+\t}\n+\n+\tif r := Replacement(module.Version{Path: path, Version: v}); r.Path == \"\" {\n+\t\treturn info, err\n+\t}\n+\treturn rr.replacementStat(v)\n+}\n+\n+func (rr *replacementRepo) Latest() (*modfetch.RevInfo, error) {\n+\tinfo, err := rr.repo.Latest()\n+\n+\tif index != nil {\n+\t\tpath := rr.ModulePath()\n+\t\tif v, ok := index.highestReplaced[path]; ok {\n+\t\t\tif v == \"\" {\n+\t\t\t\t// The only replacement is a wildcard that doesn't specify a version, so\n+\t\t\t\t// synthesize a pseudo-version with an appropriate major version and a\n+\t\t\t\t// timestamp below any real timestamp. That way, if the main module is\n+\t\t\t\t// used from within some other module, the user will be able to upgrade\n+\t\t\t\t// the requirement to any real version they choose.\n+\t\t\t\tif _, pathMajor, ok := module.SplitPathVersion(path); ok && len(pathMajor) > 0 {\n+\t\t\t\t\tv = modfetch.PseudoVersion(pathMajor[1:], \"\", time.Time{}, \"000000000000\")\n+\t\t\t\t} else {\n+\t\t\t\t\tv = modfetch.PseudoVersion(\"v0\", \"\", time.Time{}, \"000000000000\")\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif err != nil || semver.Compare(v, info.Version) > 0 {\n+\t\t\t\treturn rr.replacementStat(v)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn info, err\n+}\n+\n+func (rr *replacementRepo) replacementStat(v string) (*modfetch.RevInfo, error) {\n+\trev := &modfetch.RevInfo{Version: v}\n+\tif modfetch.IsPseudoVersion(v) {\n+\t\trev.Time, _ = modfetch.PseudoVersionTime(v)\n+\t\trev.Short, _ = modfetch.PseudoVersionRev(v)\n+\t}\n+\treturn rev, nil\n+}\n+\n+// A QueryMatchesMainModuleError indicates that a query requests\n+// a version of the main module that cannot be satisfied.\n+// (The main module's version cannot be changed.)\n+type QueryMatchesMainModuleError struct {\n+\tPattern string\n+\tQuery   string\n+}\n+\n+func (e *QueryMatchesMainModuleError) Error() string {\n+\tif e.Pattern == Target.Path {\n+\t\treturn fmt.Sprintf(\"can't request version %q of the main module (%s)\", e.Query, e.Pattern)\n+\t}\n+\n+\treturn fmt.Sprintf(\"can't request version %q of pattern %q that includes the main module (%s)\", e.Query, e.Pattern, Target.Path)\n+}\n+\n+// A QueryMatchesPackagesInMainModuleError indicates that a query cannot be\n+// satisfied because it matches one or more packages found in the main module.\n+type QueryMatchesPackagesInMainModuleError struct {\n+\tPattern  string\n+\tQuery    string\n+\tPackages []string\n+}\n+\n+func (e *QueryMatchesPackagesInMainModuleError) Error() string {\n+\tif len(e.Packages) > 1 {\n+\t\treturn fmt.Sprintf(\"pattern %s matches %d packages in the main module, so can't request version %s\", e.Pattern, len(e.Packages), e.Query)\n+\t}\n+\n+\tif search.IsMetaPackage(e.Pattern) || strings.Contains(e.Pattern, \"...\") {\n+\t\treturn fmt.Sprintf(\"pattern %s matches package %s in the main module, so can't request version %s\", e.Pattern, e.Packages[0], e.Query)\n+\t}\n+\n+\treturn fmt.Sprintf(\"package %s is in the main module, so can't request version %s\", e.Packages[0], e.Query)\n+}"}, {"sha": "e225a0e71e7eb2ec34b549cb9e37d7b1e9821c46", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "patch": "@@ -5,8 +5,8 @@\n package modload\n \n import (\n+\t\"context\"\n \t\"internal/testenv\"\n-\t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n \t\"path\"\n@@ -26,7 +26,7 @@ func TestMain(m *testing.M) {\n func testMain(m *testing.M) int {\n \tcfg.GOPROXY = \"direct\"\n \n-\tdir, err := ioutil.TempDir(\"\", \"modload-test-\")\n+\tdir, err := os.MkdirTemp(\"\", \"modload-test-\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n@@ -44,7 +44,7 @@ var (\n \tqueryRepoV3 = queryRepo + \"/v3\"\n \n \t// Empty version list (no semver tags), not actually empty.\n-\temptyRepo = \"vcs-test.golang.org/git/emptytest.git\"\n+\temptyRepoPath = \"vcs-test.golang.org/git/emptytest.git\"\n )\n \n var queryTests = []struct {\n@@ -120,14 +120,14 @@ var queryTests = []struct {\n \t{path: queryRepo, query: \"upgrade\", current: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n \t{path: queryRepo, query: \"upgrade\", current: \"v0.0.0-20190513201126-42abcb6df8ee\", vers: \"v0.0.0-20190513201126-42abcb6df8ee\"},\n \t{path: queryRepo, query: \"upgrade\", allow: \"NOMATCH\", err: `no matching versions for query \"upgrade\"`},\n-\t{path: queryRepo, query: \"upgrade\", current: \"v1.9.9\", allow: \"NOMATCH\", err: `no matching versions for query \"upgrade\" (current version is v1.9.9)`},\n+\t{path: queryRepo, query: \"upgrade\", current: \"v1.9.9\", allow: \"NOMATCH\", err: `vcs-test.golang.org/git/querytest.git@v1.9.9: disallowed module version`},\n \t{path: queryRepo, query: \"upgrade\", current: \"v1.99.99\", err: `vcs-test.golang.org/git/querytest.git@v1.99.99: invalid version: unknown revision v1.99.99`},\n \t{path: queryRepo, query: \"patch\", current: \"\", vers: \"v1.9.9\"},\n \t{path: queryRepo, query: \"patch\", current: \"v0.1.0\", vers: \"v0.1.2\"},\n \t{path: queryRepo, query: \"patch\", current: \"v1.9.0\", vers: \"v1.9.9\"},\n \t{path: queryRepo, query: \"patch\", current: \"v1.9.10-pre1\", vers: \"v1.9.10-pre1\"},\n \t{path: queryRepo, query: \"patch\", current: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n-\t{path: queryRepo, query: \"patch\", current: \"v1.99.99\", err: `no matching versions for query \"patch\" (current version is v1.99.99)`},\n+\t{path: queryRepo, query: \"patch\", current: \"v1.99.99\", err: `vcs-test.golang.org/git/querytest.git@v1.99.99: invalid version: unknown revision v1.99.99`},\n \t{path: queryRepo, query: \">v1.9.9\", vers: \"v1.9.10-pre1\"},\n \t{path: queryRepo, query: \">v1.10.0\", err: `no matching versions for query \">v1.10.0\"`},\n \t{path: queryRepo, query: \">=v1.10.0\", err: `no matching versions for query \">=v1.10.0\"`},\n@@ -170,42 +170,46 @@ var queryTests = []struct {\n \t// That should prevent us from resolving any version for the /v3 path.\n \t{path: queryRepoV3, query: \"latest\", err: `no matching versions for query \"latest\"`},\n \n-\t{path: emptyRepo, query: \"latest\", vers: \"v0.0.0-20180704023549-7bb914627242\"},\n-\t{path: emptyRepo, query: \">v0.0.0\", err: `no matching versions for query \">v0.0.0\"`},\n-\t{path: emptyRepo, query: \"<v10.0.0\", err: `no matching versions for query \"<v10.0.0\"`},\n+\t{path: emptyRepoPath, query: \"latest\", vers: \"v0.0.0-20180704023549-7bb914627242\"},\n+\t{path: emptyRepoPath, query: \">v0.0.0\", err: `no matching versions for query \">v0.0.0\"`},\n+\t{path: emptyRepoPath, query: \"<v10.0.0\", err: `no matching versions for query \"<v10.0.0\"`},\n }\n \n func TestQuery(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \ttestenv.MustHaveExecPath(t, \"git\")\n \n+\tctx := context.Background()\n+\n \tfor _, tt := range queryTests {\n \t\tallow := tt.allow\n \t\tif allow == \"\" {\n \t\t\tallow = \"*\"\n \t\t}\n-\t\tallowed := func(m module.Version) bool {\n-\t\t\tok, _ := path.Match(allow, m.Version)\n-\t\t\treturn ok\n+\t\tallowed := func(ctx context.Context, m module.Version) error {\n+\t\t\tif ok, _ := path.Match(allow, m.Version); !ok {\n+\t\t\t\treturn module.VersionError(m, ErrDisallowed)\n+\t\t\t}\n+\t\t\treturn nil\n \t\t}\n \t\ttt := tt\n \t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.query+\"/\"+tt.current+\"/\"+allow, func(t *testing.T) {\n \t\t\tt.Parallel()\n \n-\t\t\tinfo, err := Query(tt.path, tt.query, tt.current, allowed)\n+\t\t\tinfo, err := Query(ctx, tt.path, tt.query, tt.current, allowed)\n \t\t\tif tt.err != \"\" {\n \t\t\t\tif err == nil {\n-\t\t\t\t\tt.Errorf(\"Query(%q, %q, %v) = %v, want error %q\", tt.path, tt.query, allow, info.Version, tt.err)\n+\t\t\t\t\tt.Errorf(\"Query(_, %q, %q, %q, %v) = %v, want error %q\", tt.path, tt.query, tt.current, allow, info.Version, tt.err)\n \t\t\t\t} else if err.Error() != tt.err {\n-\t\t\t\t\tt.Errorf(\"Query(%q, %q, %v): %v, want error %q\", tt.path, tt.query, allow, err, tt.err)\n+\t\t\t\t\tt.Errorf(\"Query(_, %q, %q, %q, %v): %v\\nwant error %q\", tt.path, tt.query, tt.current, allow, err, tt.err)\n \t\t\t\t}\n \t\t\t\treturn\n \t\t\t}\n \t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"Query(%q, %q, %v): %v\", tt.path, tt.query, allow, err)\n+\t\t\t\tt.Fatalf(\"Query(_, %q, %q, %q, %v): %v\\nwant %v\", tt.path, tt.query, tt.current, allow, err, tt.vers)\n \t\t\t}\n \t\t\tif info.Version != tt.vers {\n-\t\t\t\tt.Errorf(\"Query(%q, %q, %v) = %v, want %v\", tt.path, tt.query, allow, info.Version, tt.vers)\n+\t\t\t\tt.Errorf(\"Query(_, %q, %q, %q, %v) = %v, want %v\", tt.path, tt.query, tt.current, allow, info.Version, tt.vers)\n \t\t\t}\n \t\t})\n \t}"}, {"sha": "4c73c783603c1b4ab731c37a3c38da7a061fa5fa", "filename": "libgo/go/cmd/go/internal/modload/search.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "5842b858f0b1a48a1b2b78b404a574cabf6d58da", "filename": "libgo/go/cmd/go/internal/modload/stat_openfile.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "032fff8714222ff71c3001b1a7f46cd7e0a7bfac", "filename": "libgo/go/cmd/go/internal/modload/stat_unix.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "0ac23913475beab944be2a70ecaa3202e165b8ec", "filename": "libgo/go/cmd/go/internal/modload/stat_windows.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "6b34f5be39367a381b3dc7a7b9fee49ed2c0ffc4", "filename": "libgo/go/cmd/go/internal/modload/testgo.go", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go?ref=0696141107d61483f38482b941549959a0d7f613"}, {"sha": "80d49053c6c6f0f2b9e91f92dbaebc27a164e5a2", "filename": "libgo/go/cmd/go/internal/modload/vendor.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "5564965fb51675a33dfd7c303efbacd1009fecda", "filename": "libgo/go/cmd/go/internal/mvs/errors.go", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Ferrors.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "b630b610f10e03641362acf7b385f34781e58cf5", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "modified", "additions": 63, "deletions": 78, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "721cd9635c8d84dabead835817dfa9f817b97fc2", "filename": "libgo/go/cmd/go/internal/mvs/mvs_test.go", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "180bc75e3430041c77c52466ec021cfb1d6c12b1", "filename": "libgo/go/cmd/go/internal/par/queue.go", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fqueue.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "1331e65f98a81f0c02a8f8cce191338b638a41ec", "filename": "libgo/go/cmd/go/internal/par/queue_test.go", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fqueue_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fqueue_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fqueue_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "9788171d6e200d6c5648772cf3729a54ae606d66", "filename": "libgo/go/cmd/go/internal/renameio/renameio.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "5b2ed836242a4a8399566514d1c13a716dbd29dc", "filename": "libgo/go/cmd/go/internal/renameio/renameio_test.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "65e4fa587b7943d740ee024df4eca4c611163993", "filename": "libgo/go/cmd/go/internal/renameio/umask_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "ce3dbbde6db937177aaa6e111e748f780ba1d93c", "filename": "libgo/go/cmd/go/internal/robustio/robustio.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "5bd44bd345338f31f7e278c0eaf66042f955ac51", "filename": "libgo/go/cmd/go/internal/robustio/robustio_flaky.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "6fe7b7e4e4e9df3e4812f73a598e2073be43f96d", "filename": "libgo/go/cmd/go/internal/robustio/robustio_other.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "99578b244c86c28706ef1ad531900592867393d3", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "18738cf59ec8d3c48dc30339c869c40ef698bde0", "filename": "libgo/go/cmd/go/internal/search/search.go", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "51ab2af82b58a6b42f5fc9eaa5e855d8de6fa5b4", "filename": "libgo/go/cmd/go/internal/str/path.go", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "147ce1a63ef32d89a537f49e8fb601a70387dbe5", "filename": "libgo/go/cmd/go/internal/str/str_test.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "ab5440b3801f15af1124d3ce1738035a894926a0", "filename": "libgo/go/cmd/go/internal/test/flagdefs_test.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "5e83d53980c01741b950329c53266c3eca4ba9fd", "filename": "libgo/go/cmd/go/internal/test/genflags.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "50fe2dbf393b1f89bdaa484cc8a63e5b690ffef5", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "d2671ff5a7925c63c25df4be9b5cae5be9822c21", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "7f4dc8680211c68c87b2cd4e5bbb1daefcbf7dce", "filename": "libgo/go/cmd/go/internal/tool/tool.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f108a2b6cae19b8e22aa64e69b35855bf743e1c6", "filename": "libgo/go/cmd/go/internal/trace/trace.go", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftrace%2Ftrace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftrace%2Ftrace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftrace%2Ftrace.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "17966848771b3c16be035a1f583fc0f3e6e70445", "filename": "libgo/go/cmd/go/internal/txtar/archive.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "327b44cb9afa8fcee402fbb6385b0dd822abf3de", "filename": "libgo/go/cmd/go/internal/vcs/discovery.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fdiscovery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fdiscovery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fdiscovery.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "previous_filename": "libgo/go/cmd/go/internal/get/discovery.go"}, {"sha": "eb99fdf64c141a91b702996cc730db5942714e98", "filename": "libgo/go/cmd/go/internal/vcs/discovery_test.go", "status": "renamed", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fdiscovery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fdiscovery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fdiscovery_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "previous_filename": "libgo/go/cmd/go/internal/get/pkg_test.go"}, {"sha": "4894ecdc35655643608c4e7e63bb642d3692fc36", "filename": "libgo/go/cmd/go/internal/vcs/vcs.go", "status": "renamed", "additions": 371, "deletions": 190, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "previous_filename": "libgo/go/cmd/go/internal/get/vcs.go"}, {"sha": "c5c7a3283bce57d1fbc8ac0c09549fe80ace5290", "filename": "libgo/go/cmd/go/internal/vcs/vcs_test.go", "status": "renamed", "additions": 130, "deletions": 30, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd", "previous_filename": "libgo/go/cmd/go/internal/get/vcs_test.go"}, {"sha": "58cbd32e78d1158700c64c2d207f40e4456802c1", "filename": "libgo/go/cmd/go/internal/version/version.go", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "4257c90c97a193ca5a80b8a5a82abb04a98a1a81", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "9053b16b629a688ffa0d120fe378110dd040b040", "filename": "libgo/go/cmd/go/internal/web/api.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "3734df5c4e9bc0382f28ed87e2257527e17fc64f", "filename": "libgo/go/cmd/go/internal/web/file_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "72fa2b2ca6aa349241d1e7ec8a0b96c23d3ed3fc", "filename": "libgo/go/cmd/go/internal/web/http.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "5320121102256fc5223626ed28d22be80f038405", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "7f2617cf1cedf8e1ffbf63b8d18757a7dc1ae15c", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 287, "deletions": 27, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "eaf2639e9e0deaa5e43f1acadb279bc146c4d1b7", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "d76988145bedc780d61375ee9a3f3d60f5c99756", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "c0b69f9b9e5ade17e45f431c3471f45b1b7fd23f", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 210, "deletions": 70, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "4eb762cb289d28394668f501d1f54b2902da651e", "filename": "libgo/go/cmd/go/internal/work/exec_test.go", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "cc4e2b2b2b96553f0d899ca2f92e8f367bd4dea5", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 110, "deletions": 18, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "793a333663f6b7cdb715ed64e75b70ae664e3a32", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "ba7c7c2fbb18d95b456e6e0973006ec3d48ab411", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "36bbab37ee23e89943f26a543e5a230ae1fb70a0", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "4f2e0eb21ab842dd80c4425fa806ca2998000f73", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "c4af1955d12a082a76b57b1832c90d25b183aa90", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "e390c73a9cfa06aa71975c13fade24b2d8c60812", "filename": "libgo/go/cmd/go/proxy_test.go", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "dfaa40548e44d8df9f10ef873d566f1a684cdbd5", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 61, "deletions": 16, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "58376b7ed4ace8df006bba91e703b210f42bf5e6", "filename": "libgo/go/cmd/go/testdata/addmod.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "d469c31a919821171affd2be2e88b12ef3861de0", "filename": "libgo/go/cmd/go/testdata/savedir.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "d658cebfce0170e8fcd2956b2bd2e11d74a2555c", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "1073517c29891caf86c289af31ca6e8d2afe462f", "filename": "libgo/go/cmd/go/testdata/script/build_GOTMPDIR.txt", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "e1ea0a48b2acfec72a585b6d31cb05718dc9c42b", "filename": "libgo/go/cmd/go/testdata/script/build_trimpath.txt", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "dc6965241198c8c4e278f298876fc5639fde1ed0", "filename": "libgo/go/cmd/go/testdata/script/env_write.txt", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f23cecefd3aa30e87ef45d26b15949c2f88d3f28", "filename": "libgo/go/cmd/go/testdata/script/gcflags_patterns.txt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "d3b82bdf250dd0b39f8e14d5dcd46a680a7ea016", "filename": "libgo/go/cmd/go/testdata/script/get_unicode.txt", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_unicode.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_unicode.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_unicode.txt?ref=0696141107d61483f38482b941549959a0d7f613"}, {"sha": "99d80bff5d94c324a377acb8b535081167ccdb91", "filename": "libgo/go/cmd/go/testdata/script/gopath_moved_repo.txt", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_moved_repo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_moved_repo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_moved_repo.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "26034c9626661d6fa2ee3a27d0ae48390951b2c0", "filename": "libgo/go/cmd/go/testdata/script/link_syso_issue33139.txt", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "dbec35069c64ea815a5151716afe13fb458e9d27", "filename": "libgo/go/cmd/go/testdata/script/list_bad_import.txt", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "c6f1ecf40039097acadbde2977f817bf52f17c74", "filename": "libgo/go/cmd/go/testdata/script/list_test_err.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "d8ea5867d6b65999bcc63879811db46faf8b5d5d", "filename": "libgo/go/cmd/go/testdata/script/mod_auth.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "20199c1c2ca8e8c61ef73af5df7d59aea17bd1da", "filename": "libgo/go/cmd/go/testdata/script/mod_bad_domain.txt", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "eb556f4c7cf5e1246aa59264d13c96fe62e27aa5", "filename": "libgo/go/cmd/go/testdata/script/mod_bad_filenames.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_filenames.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_filenames.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_filenames.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "cee055eabe9c26d0c1d6c4ca79d3b2121eb29956", "filename": "libgo/go/cmd/go/testdata/script/mod_build_info_err.txt", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "4a4698600f7fb965162272a5eb7df75919712bc0", "filename": "libgo/go/cmd/go/testdata/script/mod_case.txt", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f3d6aaa5abc77bc02d61faed05e242de12cb5476", "filename": "libgo/go/cmd/go/testdata/script/mod_case_cgo.txt", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case_cgo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case_cgo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case_cgo.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8c215251587180600da62bdbde2a77b61f5beed4", "filename": "libgo/go/cmd/go/testdata/script/mod_concurrent.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "595ad679fc0866e7c201c64dafabb709b9cba529", "filename": "libgo/go/cmd/go/testdata/script/mod_doc.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "14745b5812c68296354cb7116cc9553b16357b94", "filename": "libgo/go/cmd/go/testdata/script/mod_domain_root.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_domain_root.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_domain_root.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_domain_root.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "e58132064743a58a798457ae60a3e6fd3ce32be7", "filename": "libgo/go/cmd/go/testdata/script/mod_dot.txt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8a9faffe4e009beedf0d080b6643030f880bb6bf", "filename": "libgo/go/cmd/go/testdata/script/mod_download.txt", "status": "modified", "additions": 61, "deletions": 36, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "9555adf8c4e4657537ac1ce99ec4a9c7f7767332", "filename": "libgo/go/cmd/go/testdata/script/mod_download_json.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_json.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_json.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_json.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "78485eb86ae1d2e1df1df52d171cf7a447136fbf", "filename": "libgo/go/cmd/go/testdata/script/mod_edit.txt", "status": "modified", "additions": 100, "deletions": 14, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "39f1ece8cb8eea2ce1e65715ed6dce0d681957b7", "filename": "libgo/go/cmd/go/testdata/script/mod_enabled.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_enabled.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_enabled.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_enabled.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "9468acfd33d6a9cae04ea89abc8be394443b7fae", "filename": "libgo/go/cmd/go/testdata/script/mod_find.txt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_find.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_find.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_find.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "4649491a532a8c7a8b20c88fde9aa16ca7b751be", "filename": "libgo/go/cmd/go/testdata/script/mod_get_commit.txt", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "a954c10344bbafd33266e59c8efb4bb0a2115db3", "filename": "libgo/go/cmd/go/testdata/script/mod_get_downgrade.txt", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8000ee61481a01be883b022d17001ed2301f2a6b", "filename": "libgo/go/cmd/go/testdata/script/mod_get_incompatible.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_incompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_incompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_incompatible.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "e1cc1ab4115be419f6a779a508f125f17de11e6c", "filename": "libgo/go/cmd/go/testdata/script/mod_get_indirect.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_indirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_indirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_indirect.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "241a0c2f0dfa8eaf6435c47007ff157f25f8ac26", "filename": "libgo/go/cmd/go/testdata/script/mod_get_latest_pseudo.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_latest_pseudo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_latest_pseudo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_latest_pseudo.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "50b2fee9ae1bfd82cd66feecfd420a324c5a10f7", "filename": "libgo/go/cmd/go/testdata/script/mod_get_main.txt", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8430a737c40ca00842f14faede5001baa2f81a7e", "filename": "libgo/go/cmd/go/testdata/script/mod_get_moved.txt", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_moved.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_moved.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_moved.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f71620c1bcb41cac9e49ffc102c683f533a7ae4f", "filename": "libgo/go/cmd/go/testdata/script/mod_get_newcycle.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "b358f05af36745226e909e1f4a81154bbf6fcdae", "filename": "libgo/go/cmd/go/testdata/script/mod_get_none.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_none.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_none.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_none.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "aee4374dc8a88a5dff020078c9e392178d9e7ba1", "filename": "libgo/go/cmd/go/testdata/script/mod_get_patterns.txt", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "23722bd4e4dcd7f749386b2e68dee7efea25e9a3", "filename": "libgo/go/cmd/go/testdata/script/mod_get_test.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "3b38d8ba7d346d926b2cb9058ab9d4f5b4b0fbb0", "filename": "libgo/go/cmd/go/testdata/script/mod_get_trailing_slash.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "eeb6d6f6af6f414b5545034bbabf80f9cceec096", "filename": "libgo/go/cmd/go/testdata/script/mod_get_upgrade.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "97d9975e6806060fa1f1a4d3f94454b37c06bedc", "filename": "libgo/go/cmd/go/testdata/script/mod_go_version.txt", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "3a133663ec78818b540361233a5ae58e9a3fe831", "filename": "libgo/go/cmd/go/testdata/script/mod_gobuild_import.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "204786969f5b25923e9d9928541cb7a0ebd982e8", "filename": "libgo/go/cmd/go/testdata/script/mod_gonoproxy.txt", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "5ad9106378f33303b82dfad6df2d99bfedb87bee", "filename": "libgo/go/cmd/go/testdata/script/mod_gopkg_unstable.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gopkg_unstable.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gopkg_unstable.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gopkg_unstable.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "28358b5b0c5b560527643096e8e27aa049e968c3", "filename": "libgo/go/cmd/go/testdata/script/mod_import.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_import.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "66f79faa6d9b8dd65d11746777be76eda72843f8", "filename": "libgo/go/cmd/go/testdata/script/mod_in_testdata_dir.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_in_testdata_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_in_testdata_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_in_testdata_dir.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "6ea1cae98bcc8a152735310fbd5a349225671ccc", "filename": "libgo/go/cmd/go/testdata/script/mod_indirect.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f8cf1d563ab64b11bbee108653cf1b2556b400e0", "filename": "libgo/go/cmd/go/testdata/script/mod_init_dep.txt", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_init_dep.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_init_dep.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_init_dep.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "ccdfc92317583e96a8176a91daa97c7ab650c784", "filename": "libgo/go/cmd/go/testdata/script/mod_init_path.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_init_path.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_init_path.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_init_path.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "c6bce418b4fa7093749bf780341a81d749635a60", "filename": "libgo/go/cmd/go/testdata/script/mod_install_versioned.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_install_versioned.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_install_versioned.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_install_versioned.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "687269d18f6f33e05ce4572423d2d7cfa4efb8be", "filename": "libgo/go/cmd/go/testdata/script/mod_internal.txt", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "43b9564356100a02cea4f9c00ae394930748db37", "filename": "libgo/go/cmd/go/testdata/script/mod_invalid_version.txt", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "b1852ab0319ebbccdc6e15b063719332fad938a6", "filename": "libgo/go/cmd/go/testdata/script/mod_issue35317.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_issue35317.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_issue35317.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_issue35317.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "1ba6d7c910e8c88bbbd45ce22d2e8f6612408386", "filename": "libgo/go/cmd/go/testdata/script/mod_list.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "3cd50b0de2544450563ad81c92cfe6ced23bf0dd", "filename": "libgo/go/cmd/go/testdata/script/mod_list_bad_import.txt", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "1adab8f027d7374869b7ebba276b528ea5229ca1", "filename": "libgo/go/cmd/go/testdata/script/mod_list_dir.txt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "62a472f475e7f8f58a13177977a6b4c4c94abc1d", "filename": "libgo/go/cmd/go/testdata/script/mod_list_direct.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_direct.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_direct.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_direct.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "056c0931285685eccf00e874bff370084e81ea34", "filename": "libgo/go/cmd/go/testdata/script/mod_list_pseudo.txt", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_pseudo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_pseudo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_pseudo.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f2f2d2b2bb23c40e7993894fcf0ba28ca4ce9f35", "filename": "libgo/go/cmd/go/testdata/script/mod_list_replace_dir.txt", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "baf7908ab93d2a946c5a8b4a1cb8c00ad816fdd8", "filename": "libgo/go/cmd/go/testdata/script/mod_list_std.txt", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_std.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_std.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_std.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f697af6c92c9cefc1080644e33752556e1f20ec1", "filename": "libgo/go/cmd/go/testdata/script/mod_list_test.txt", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_test.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_test.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_test.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "0cef04b89ad3cfec1b07be4f457f42cfeff164a1", "filename": "libgo/go/cmd/go/testdata/script/mod_list_upgrade.txt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "c0c382bfa638b0fcb71473c560704179e7726795", "filename": "libgo/go/cmd/go/testdata/script/mod_load_badchain.txt", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "fa22e1808b76cf680db16dbcaf9cc02c4c05a578", "filename": "libgo/go/cmd/go/testdata/script/mod_load_badmod.txt", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badmod.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badmod.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badmod.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "65374d2a6d1fdc219b0ed608818679738cf55bd3", "filename": "libgo/go/cmd/go/testdata/script/mod_load_badzip.txt", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badzip.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badzip.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badzip.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "9c250e7d1c451bbc4c5ccf6935e1938377809da5", "filename": "libgo/go/cmd/go/testdata/script/mod_missingpkg_prerelease.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missingpkg_prerelease.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missingpkg_prerelease.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missingpkg_prerelease.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "c56ed919f5ab966845f4faaf88210d75bf31e4a5", "filename": "libgo/go/cmd/go/testdata/script/mod_modinfo.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_modinfo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_modinfo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_modinfo.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "0f335a11f0fb3bf3d2ecf2abc81b10ee3c3b1da9", "filename": "libgo/go/cmd/go/testdata/script/mod_multirepo.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_multirepo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_multirepo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_multirepo.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "a73a58d4d0c0e7ea2298cce8da02bf02a0ead96a", "filename": "libgo/go/cmd/go/testdata/script/mod_off.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_off.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_off.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_off.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "2aec0b3ed5443d65c4980f76857d4d2870430875", "filename": "libgo/go/cmd/go/testdata/script/mod_off_init.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_off_init.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_off_init.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_off_init.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8f01b5d242677502a87260d0a5e4d3a12459c2d3", "filename": "libgo/go/cmd/go/testdata/script/mod_outside.txt", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_outside.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_outside.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_outside.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "2d32dcd10fd4c91e35636b88d994d7a51c2eb0a0", "filename": "libgo/go/cmd/go/testdata/script/mod_permissions.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_permissions.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_permissions.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_permissions.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "89129f4fe237d6440935fd836ac9cacf7c2887f9", "filename": "libgo/go/cmd/go/testdata/script/mod_proxy_list.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_list.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_list.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_list.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "e10185709d95a6083121d9dda6efee196d44aa78", "filename": "libgo/go/cmd/go/testdata/script/mod_query.txt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f8b6e3e97edcff1c2c2d2ec0abadb5b3d3bc04b4", "filename": "libgo/go/cmd/go/testdata/script/mod_query_empty.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_empty.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_empty.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_empty.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "b0019694119bb17b2e95bfd180055aafc32daafb", "filename": "libgo/go/cmd/go/testdata/script/mod_query_exclude.txt", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_exclude.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_exclude.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_exclude.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "ca8cd6e068938cb64fb372b85b11af1e7eaf8a2e", "filename": "libgo/go/cmd/go/testdata/script/mod_readonly.txt", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "dc9667f1d0d84c7c37f4e29c6c003dc173fb4662", "filename": "libgo/go/cmd/go/testdata/script/mod_replace.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "df752d9716e538b4bb89c73679d45df8e1b395ca", "filename": "libgo/go/cmd/go/testdata/script/mod_replace_gopkgin.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "2add31f71c10d43f828c953cfbd7ebe9d29bffb3", "filename": "libgo/go/cmd/go/testdata/script/mod_replace_import.txt", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "9156d4ce5d5fdfb47c93071a79ec09e8ef7dde35", "filename": "libgo/go/cmd/go/testdata/script/mod_require_exclude.txt", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_require_exclude.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_require_exclude.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_require_exclude.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "a4441c4b3c7fba858b418d6d1d1571c0ec72009f", "filename": "libgo/go/cmd/go/testdata/script/mod_retention.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "fb954d74edbe9e76aa4f0a45e1eabf20a29d0adb", "filename": "libgo/go/cmd/go/testdata/script/mod_std_vendor.txt", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_std_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_std_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_std_vendor.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "9a688e1461ca94efdce410cafbc9d4f06146fd1d", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb.txt", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "22fcbf3de84a71f92d3ebbd83aa56377d9485f0f", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_file_path.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "cc0b0da474a2286521453d81ca91c1b2c9c263d5", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_golang.txt", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_golang.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_golang.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_golang.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "70b8e3fc4466ffab5676cb06b2aebe8d23aedd39", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_proxy.txt", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "dbc23fb8f0984722e49f24201fbfe6c20ec95978", "filename": "libgo/go/cmd/go/testdata/script/mod_symlink.txt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_symlink.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_symlink.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_symlink.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "50f00355c17e5bce4ee2621c6ee22661f35decee", "filename": "libgo/go/cmd/go/testdata/script/mod_test.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "3da4358fa1435ddb38ee4d5b57e7116935bda861", "filename": "libgo/go/cmd/go/testdata/script/mod_test_cached.txt", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_cached.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_cached.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_cached.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "dd9943889106568addf3a503a22c478b0dfb8bde", "filename": "libgo/go/cmd/go/testdata/script/mod_tidy_replace.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_replace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_replace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_replace.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8b34f8bf27dfc66070075e4efe2efe78fa2e20ad", "filename": "libgo/go/cmd/go/testdata/script/mod_upgrade_patch.txt", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_upgrade_patch.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_upgrade_patch.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_upgrade_patch.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f8be43cf4c6494442cea992819a23f16b42e435c", "filename": "libgo/go/cmd/go/testdata/script/mod_vcs_missing.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vcs_missing.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vcs_missing.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vcs_missing.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "1b362eda0bdf0b5cd8b82f55afbb88f34cfd1e91", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor_auto.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "3b8eec0119b3fd64c23cfd346aab5ecfe2d63b6d", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor_build.txt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_build.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_build.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_build.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "43812d069f65a3a0e4dd2fe439df2efe8e8fcf9e", "filename": "libgo/go/cmd/go/testdata/script/mod_verify.txt", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_verify.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_verify.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_verify.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "b3036fa83040c0b1c69623041c93086547fb3caf", "filename": "libgo/go/cmd/go/testdata/script/mod_why.txt", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_why.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_why.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_why.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "0ad08808178316bf50e67686c565ebabe97d4f64", "filename": "libgo/go/cmd/go/testdata/script/modfile_flag.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8aa61166acf227572555b5a7716189068cb22e90", "filename": "libgo/go/cmd/go/testdata/script/sum_readonly.txt", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fsum_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fsum_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fsum_readonly.txt?ref=0696141107d61483f38482b941549959a0d7f613"}, {"sha": "50486e19090dd304c0fe22a9241e5c8ca1b8a5ff", "filename": "libgo/go/cmd/go/testdata/script/test_cache_inputs.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "05f721a80070ae0e2fecc54f09ae78593e84defe", "filename": "libgo/go/cmd/go/testdata/script/test_compile_tempfile.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_tempfile.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_tempfile.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_tempfile.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "2e991a5797f83c05550815f29c88519be3bb0366", "filename": "libgo/go/cmd/go/testdata/script/test_generated_main.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_generated_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_generated_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_generated_main.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8615a4aac5978bdf00d8b4c3022a54567cf0cb06", "filename": "libgo/go/cmd/go/testdata/script/version.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "8002367e6f2cb3885c8dd4f51bc693ef7c4ef707", "filename": "libgo/go/cmd/go/testdata/script/vet_flags.txt", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "2793c2c2a43f0891f9d91c0cdb94515c72572e50", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "bf2adfe64c52b1ef9362cd803cb04473b8ce0dae", "filename": "libgo/go/cmd/gofmt/gofmt_test.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "4a821705f16d06e3de015257cd70d633b82b7c91", "filename": "libgo/go/cmd/gofmt/long_test.go", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "1e8855d3aca7d717d2caec7d6452d08b9db9aa3a", "filename": "libgo/go/cmd/internal/buildid/buildid.go", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "e832f9987e582eb9b262c50f12aa4c8abae23fef", "filename": "libgo/go/cmd/internal/buildid/buildid_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "f5b6fc565f36dcc6852cba2da03a6ed1bd9e087c", "filename": "libgo/go/cmd/internal/buildid/note.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fnote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fnote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fnote.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "a7928959c483da9f467fefb6209030c8d34b030d", "filename": "libgo/go/cmd/internal/buildid/rewrite.go", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Frewrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Frewrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Frewrite.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "0517a10640a0bd9b461dc208a4d2a028aff13aec", "filename": "libgo/go/cmd/internal/codesign/codesign.go", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fcodesign%2Fcodesign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fcodesign%2Fcodesign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fcodesign%2Fcodesign.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "08e922b11fb52767b34ba8feb1a541aae242c6dc", "filename": "libgo/go/cmd/internal/objabi/doc.go", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0696141107d61483f38482b941549959a0d7f613/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go?ref=0696141107d61483f38482b941549959a0d7f613"}, {"sha": "3fd73f3c576b0f407ad462a550e80cdd04ea6aca", "filename": "libgo/go/cmd/internal/objabi/flag.go", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "935b9c2193124e477b3222e8ca1f2586053d8fbd", "filename": "libgo/go/cmd/internal/objabi/flag_test.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag_test.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "faa2863325d1ee79ea50da42e88edb324e2c44a2", "filename": "libgo/go/cmd/internal/objabi/funcdata.go", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "1d098ee17251b379c354b01f840f53aef119c058", "filename": "libgo/go/cmd/internal/objabi/funcid.go", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "48ff292307f477a24c8fd88d21b0aaca55960191", "filename": "libgo/go/cmd/internal/objabi/head.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "0733b65138db50371baf7a3268d036bcc986f4f8", "filename": "libgo/go/cmd/internal/objabi/line.go", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "fd1c9981c69d0f9b1220d7e37de1e08068d4584a", "filename": "libgo/go/cmd/internal/objabi/path.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "649f6901944f9876b4a30a6118786f4898766d60", "filename": "libgo/go/cmd/internal/objabi/reloctype.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "658a44f8b81bfa4bf3abefc43f4d23f5b4f46fd6", "filename": "libgo/go/cmd/internal/objabi/reloctype_string.go", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}, {"sha": "6c991121e72d5d222984ca38cc52db6e6b2ad73b", "filename": "libgo/go/cmd/internal/objabi/symkind.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfcbb4227fb20191e04eb8d7766ae6202f526afd/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go?ref=cfcbb4227fb20191e04eb8d7766ae6202f526afd"}]}