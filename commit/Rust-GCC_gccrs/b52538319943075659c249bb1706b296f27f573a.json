{"sha": "b52538319943075659c249bb1706b296f27f573a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyNTM4MzE5OTQzMDc1NjU5YzI0OWJiMTcwNmIyOTZmMjdmNTczYQ==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@mhpcc.edu", "date": "1999-03-15T19:47:42Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1999-03-15T19:47:42Z"}, "message": "bit-pattern directly.\n\n        (ASM_OUTPUT_REG_{PUSH,POP}): Delete.\n        * rs6000.c (first_reg_to_save): If profiling and context needed,\n        allocate a reg to save static chain for all ABIs.  For AIX\n        profiling, calculate parameter registers to save based on need.\n        (output_function_profiler): Save and restore static chain around\n        profile call for all ABIs.\n\nFrom-SVN: r25795", "tree": {"sha": "b88b5dcfddeae67f00e91fbe9df3316258d992f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b88b5dcfddeae67f00e91fbe9df3316258d992f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b52538319943075659c249bb1706b296f27f573a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52538319943075659c249bb1706b296f27f573a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52538319943075659c249bb1706b296f27f573a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52538319943075659c249bb1706b296f27f573a/comments", "author": null, "committer": null, "parents": [{"sha": "9b2bf201fc39a782184468f24370ba6cbd55aef0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2bf201fc39a782184468f24370ba6cbd55aef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2bf201fc39a782184468f24370ba6cbd55aef0"}], "stats": {"total": 153, "additions": 77, "deletions": 76}, "files": [{"sha": "e5fba0f48ff74b728ff012af71cd7a8584efa361", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52538319943075659c249bb1706b296f27f573a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52538319943075659c249bb1706b296f27f573a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b52538319943075659c249bb1706b296f27f573a", "patch": "@@ -1,3 +1,14 @@\n+Mon Mar 15 22:45:25 1999  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* rs6000.h (ASM_OUTPUT_{DOUBLE,FLOAT}): Always generate IEEE 754\n+\tbit-pattern directly.\n+\t(ASM_OUTPUT_REG_{PUSH,POP}): Delete.\n+\t* rs6000.c (first_reg_to_save): If profiling and context needed,\n+\tallocate a reg to save static chain for all ABIs.  For AIX\n+\tprofiling, calculate parameter registers to save based on need.\n+\t(output_function_profiler): Save and restore static chain around\n+\tprofile call for all ABIs. \n+\n 1999-03-15 21:39 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n \n \t* cppinit.c: Instead of one pending list, keep separate lists"}, {"sha": "a59425dae73ce550c3cb49b0bb7f8a5e4f718ae6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52538319943075659c249bb1706b296f27f573a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52538319943075659c249bb1706b296f27f573a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b52538319943075659c249bb1706b296f27f573a", "patch": "@@ -3229,14 +3229,46 @@ first_reg_to_save ()\n     if (regs_ever_live[first_reg])\n       break;\n \n-  /* If profiling, then we must save/restore every register that contains\n-     a parameter before/after the .__mcount call.  Use registers from 30 down\n-     to 23 to do this.  Don't use the frame pointer in reg 31.\n+  if (profile_flag)\n+    {\n+      /* AIX must save/restore every register that contains a parameter\n+\t before/after the .__mcount call plus an additional register\n+\t for the static chain, if needed; use registers from 30 down to 22\n+\t to do this.  */\n+      if (DEFAULT_ABI == ABI_AIX)\n+\t{\n+\t  int last_parm_reg, profile_first_reg;\n+\n+\t  /* Figure out last used parameter register.  The proper thing\n+\t     to do is to walk incoming args of the function.  A function\n+\t     might have live parameter registers even if it has no\n+\t     incoming args.  */\n+\t  for (last_parm_reg = 10;\n+\t       last_parm_reg > 2 && ! regs_ever_live [last_parm_reg];\n+\t       last_parm_reg--)\n+\t    ;\n+\n+\t  /* Calculate first reg for saving parameter registers\n+\t     and static chain.\n+\t     Skip reg 31 which may contain the frame pointer.  */\n+\t  profile_first_reg = (33 - last_parm_reg\n+\t\t\t       - (current_function_needs_context ? 1 : 0));\n+\t  /* Do not save frame pointer if no parameters needs to be saved.  */\n+\t  if (profile_first_reg == 31)\n+\t    profile_first_reg = 32;\n+\n+\t  if (first_reg > profile_first_reg)\n+\t    first_reg = profile_first_reg;\n+\t}\n \n-     For now, save enough room for all of the parameter registers.  */\n-  if (DEFAULT_ABI == ABI_AIX && profile_flag)\n-    if (first_reg > 23)\n-      first_reg = 23;\n+      /* SVR4 may need one register to preserve the static chain.  */\n+      else if (current_function_needs_context)\n+\t{\n+\t  /* Skip reg 31 which may contain the frame pointer.  */\n+\t  if (first_reg > 30)\n+\t    first_reg = 30;\n+\t}\n+    }\n \n   return first_reg;\n }\n@@ -5051,13 +5083,20 @@ output_function_profiler (file, labelno)\n \t  asm_fprintf (file, \"\\t{liu|lis} %s,\", reg_names[12]);\n \t  assemble_name (file, buf);\n \t  fputs (\"@ha\\n\", file);\n-\t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\", reg_names[0], reg_names[1]);\n+\t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\",\n+\t\t       reg_names[0], reg_names[1]);\n \t  asm_fprintf (file, \"\\t{cal|la} %s,\", reg_names[0]);\n \t  assemble_name (file, buf);\n \t  asm_fprintf (file, \"@l(%s)\\n\", reg_names[12]);\n \t}\n \n+      if (current_function_needs_context)\n+\tasm_fprintf (file, \"\\tmr %s,%s\\n\",\n+\t\t     reg_names[30], reg_names[STATIC_CHAIN_REGNUM]);\n       fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n+      if (current_function_needs_context)\n+\tasm_fprintf (file, \"\\tmr %s,%s\\n\",\n+\t\t     reg_names[STATIC_CHAIN_REGNUM], reg_names[30]);\n       break;\n \n     case ABI_AIX:\n@@ -5089,11 +5128,13 @@ output_function_profiler (file, labelno)\n \t   last_parm_reg--)\n \t;\n \n-  /* Save parameter registers in regs 23-30.  Don't overwrite reg 31, since\n-     it might be set up as the frame pointer.  */\n+  /* Save parameter registers in regs 23-30 and static chain in r22.\n+     Don't overwrite reg 31, since it might be set up as the frame pointer.  */\n \n       for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n \tasm_fprintf (file, \"\\tmr %d,%d\\n\", j, i);\n+      if (current_function_needs_context)\n+\tasm_fprintf (file, \"\\tmr %d,%d\\n\", j, STATIC_CHAIN_REGNUM);\n \n   /* Load location address into r3, and call mcount.  */\n \n@@ -5104,10 +5145,13 @@ output_function_profiler (file, labelno)\n       asm_fprintf (file, \"(%s)\\n\\tbl %s\\n\\t%s\\n\",\n \t\t   reg_names[2], RS6000_MCOUNT, RS6000_CALL_GLUE);\n \n-  /* Restore parameter registers.  */\n+  /* Restore parameter registers and static chain.  */\n \n       for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n \tasm_fprintf (file, \"\\tmr %d,%d\\n\", i, j);\n+      if (current_function_needs_context)\n+\tasm_fprintf (file, \"\\tmr %d,%d\\n\", STATIC_CHAIN_REGNUM, j);\n+\n       break;\n     }\n }"}, {"sha": "ad69576fd64f90207390d6152af105fbac0b22e7", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 11, "deletions": 65, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52538319943075659c249bb1706b296f27f573a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52538319943075659c249bb1706b296f27f573a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=b52538319943075659c249bb1706b296f27f573a", "patch": "@@ -3000,43 +3000,21 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0). */\n \n /* This is how to output an assembler line defining a `double' constant.  */\n \n-#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\t\\\n-        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n-\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tlong t[2];\t\t\t\t\t\t\t\\\n-\tREAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n-\tfprintf (FILE, \"\\t.long 0x%lx\\n\\t.long 0x%lx\\n\",\t\t\\\n-\t\tt[0] & 0xffffffff, t[1] & 0xffffffff);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tchar str[30];\t\t\t\t\t\t\t\\\n-\tREAL_VALUE_TO_DECIMAL (VALUE, \"%.20e\", str);\t\t\t\\\n-\tfprintf (FILE, \"\\t.double 0d%s\\n\", str);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    long t[2];\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\\\n+    fprintf (FILE, \"\\t.long 0x%lx\\n\\t.long 0x%lx\\n\",\t\\\n+\t     t[0] & 0xffffffff, t[1] & 0xffffffff);\t\\\n   }\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n-#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\t\\\n-        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n-\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tlong t;\t\t\t\t\t\t\t\t\\\n-\tREAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n-\tfprintf (FILE, \"\\t.long 0x%lx\\n\", t & 0xffffffff);\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tchar str[30];\t\t\t\t\t\t\t\\\n-\tREAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\t\\\n-\tfprintf (FILE, \"\\t.float 0d%s\\n\", str);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    long t;\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\\\n+    fprintf (FILE, \"\\t.long 0x%lx\\n\", t & 0xffffffff);\t\\\n   }\n \n /* This is how to output an assembler line defining an `int' constant.  */\n@@ -3085,38 +3063,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_ASCII(FILE, P, N)  output_ascii ((FILE), (P), (N))\n \n-/* This is how to output code to push a register on the stack.\n-   It need not be very fast code.\n-\n-   On the rs6000, we must keep the backchain up to date.  In order\n-   to simplify things, always allocate 16 bytes for a push (System V\n-   wants to keep stack aligned to a 16 byte boundary).  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  extern char *reg_names[];\t\t\t\t\t\t\\\n-  asm_fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t       (TARGET_32BIT)\t\t\t\t\t\t\\\n-\t       ? \"\\t{stu|stwu} %s,-16(%s)\\n\\t{st|stw} %s,12(%s)\\n\"\t\\\n-\t       : \"\\tstdu %s,-32(%s)\\n\\tstd %s,24(%s)\\n\",\t\t\\\n-\t       reg_names[1], reg_names[1], reg_names[REGNO],\t\t\\\n-\t       reg_names[1]);\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  extern char *reg_names[];\t\t\t\t\t\t\\\n-  asm_fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t       (TARGET_32BIT)\t\t\t\t\t\t\\\n-\t       ? \"\\t{l|lwz} %s,12(%s)\\n\\t{ai|addic} %s,%s,16\\n\"\t\t\\\n-\t       : \"\\tld %s,24(%s)\\n\\t{ai|addic} %s,%s,32\\n\",\t\t\\\n-\t       reg_names[REGNO], reg_names[1], reg_names[1],\t\t\\\n-\t       reg_names[1]);\t\t\t\t\t\t\\\n-} while (0)\n-\n /* This is how to output an element of a case-vector that is absolute.\n    (RS/6000 does not use such vectors, but we must define this macro\n    anyway.)   */"}]}