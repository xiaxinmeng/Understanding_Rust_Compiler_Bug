{"sha": "88c4f655e76260eaaa5ca5573c85eb736eb51034", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhjNGY2NTVlNzYyNjBlYWFhNWNhNTU3M2M4NWViNzM2ZWI1MTAzNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-11-05T11:12:55Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-11-05T11:12:55Z"}, "message": "bitmap.h (enum bitmap_bits): Remove.\n\n\t* bitmap.h (enum bitmap_bits): Remove.\n\t(bitmap_operation): Remove.\n\t(bitmap_and, bitmap_and_into, bitmap_and_compl,\n\tbitmap_and_compl_into, bitmap_ior, bitmap_ior_into, bitmap_xor,\n\tbitmap_xor_into): Prototype.\n\t* bitmap.c (bitmap_elt_insert_after, bitmap_elt_clear_from): New.\n\t(bitmap_operation): Remove.\n\t(bitmap_and, bitmap_and_into, bitmap_and_compl,\n\tbitmap_and_compl_into, bitmap_ior, bitmap_ior_into, bitmap_xor,\n\tbitmap_xor_into): New.\n\t(bitmap_ior_and_compl, bitmap_ior_and_compl_into): Adjust.\n\nFrom-SVN: r90121", "tree": {"sha": "20bd9b979dcfef810710197c02c8e0c921da4f18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20bd9b979dcfef810710197c02c8e0c921da4f18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88c4f655e76260eaaa5ca5573c85eb736eb51034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c4f655e76260eaaa5ca5573c85eb736eb51034", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c4f655e76260eaaa5ca5573c85eb736eb51034", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c4f655e76260eaaa5ca5573c85eb736eb51034/comments", "author": null, "committer": null, "parents": [{"sha": "0cde4a2c32bf281ce6d758f8db3bfd47be3ce5d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cde4a2c32bf281ce6d758f8db3bfd47be3ce5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cde4a2c32bf281ce6d758f8db3bfd47be3ce5d3"}], "stats": {"total": 696, "additions": 535, "deletions": 161}, "files": [{"sha": "27cc898184933350320e88ee38d04d1512bfe68d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88c4f655e76260eaaa5ca5573c85eb736eb51034/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88c4f655e76260eaaa5ca5573c85eb736eb51034/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88c4f655e76260eaaa5ca5573c85eb736eb51034", "patch": "@@ -1,5 +1,17 @@\n 2004-11-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* bitmap.h (enum bitmap_bits): Remove.\n+\t(bitmap_operation): Remove.\n+\t(bitmap_and, bitmap_and_into, bitmap_and_compl,\n+\tbitmap_and_compl_into, bitmap_ior, bitmap_ior_into, bitmap_xor,\n+\tbitmap_xor_into): Prototype.\n+\t* bitmap.c (bitmap_elt_insert_after, bitmap_elt_clear_from): New.\n+\t(bitmap_operation): Remove.\n+\t(bitmap_and, bitmap_and_into, bitmap_and_compl,\n+\tbitmap_and_compl_into, bitmap_ior, bitmap_ior_into, bitmap_xor,\n+\tbitmap_xor_into): New.\n+\t(bitmap_ior_and_compl, bitmap_ior_and_compl_into): Adjust.\n+\n \tPR tree-optimization/18307\n \t* tree-ssa-alias.c (merge_pointed_to_info): Protected against DEST\n \tand ORIG being the same node."}, {"sha": "36653941a526bb546f54a088b442bcd65fe95267", "filename": "gcc/bitmap.c", "status": "modified", "additions": 506, "deletions": 135, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88c4f655e76260eaaa5ca5573c85eb736eb51034/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88c4f655e76260eaaa5ca5573c85eb736eb51034/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=88c4f655e76260eaaa5ca5573c85eb736eb51034", "patch": "@@ -51,8 +51,11 @@ static void bitmap_element_free (bitmap, bitmap_element *);\n static bitmap_element *bitmap_element_allocate (bitmap);\n static int bitmap_element_zerop (bitmap_element *);\n static void bitmap_element_link (bitmap, bitmap_element *);\n+static bitmap_element *bitmap_elt_insert_after (bitmap, bitmap_element *);\n+static void bitmap_elt_clear_from (bitmap, bitmap_element *);\n static bitmap_element *bitmap_find_bit (bitmap, unsigned int);\n \f\n+\n /* Add ELEM to the appropriate freelist.  */\n static INLINE void\n bitmap_elem_to_freelist (bitmap head, bitmap_element *elt)\n@@ -235,6 +238,53 @@ bitmap_element_link (bitmap head, bitmap_element *element)\n   head->current = element;\n   head->indx = indx;\n }\n+\n+/* Insert a new uninitialized element into bitmap HEAD after element\n+   ELT.  If ELT is NULL, insert the element at the start.  Return the\n+   new element.  */\n+\n+static bitmap_element *\n+bitmap_elt_insert_after (bitmap head, bitmap_element *elt)\n+{\n+  bitmap_element *node = bitmap_element_allocate (head);\n+\n+  if (!elt)\n+    {\n+      if (!head->current)\n+\thead->current = node;\n+      node->next = head->first;\n+      if (node->next)\n+\tnode->next->prev = node;\n+      head->first = node;\n+      node->prev = NULL;\n+    }\n+  else\n+    {\n+      gcc_assert (head->current);\n+      node->next = elt->next;\n+      if (node->next)\n+\tnode->next->prev = node;\n+      elt->next = node;\n+      node->prev = elt;\n+    }\n+  return node;\n+}\n+\n+/* Remove ELT and all following elements from bitmap HEAD.  */\n+\n+void\n+bitmap_elt_clear_from (bitmap head, bitmap_element *elt)\n+{\n+  bitmap_element *next;\n+\n+  while (elt)\n+    {\n+      next = elt->next;\n+      bitmap_element_free (head, elt);\n+      elt = next;\n+    }\n+}\n+\n \f\n /* Clear a bitmap by freeing the linked list.  */\n \n@@ -502,165 +552,487 @@ bitmap_last_set_bit (bitmap a)\n \t  + bit_num);\n }\n \f\n-/* Store in bitmap TO the result of combining bitmap FROM1 and FROM2 using\n-   a specific bit manipulation.  Return true if TO changes.  */\n-\n-int\n-bitmap_operation (bitmap to, bitmap from1, bitmap from2,\n-\t\t  enum bitmap_bits operation)\n-{\n-#define HIGHEST_INDEX (unsigned int) ~0\n-\n-  bitmap_element *from1_ptr = from1->first;\n-  bitmap_element *from2_ptr = from2->first;\n-  unsigned int indx1 = (from1_ptr) ? from1_ptr->indx : HIGHEST_INDEX;\n-  unsigned int indx2 = (from2_ptr) ? from2_ptr->indx : HIGHEST_INDEX;\n-  bitmap_element *to_ptr = to->first;\n-  bitmap_element *from1_tmp;\n-  bitmap_element *from2_tmp;\n-  bitmap_element *to_tmp;\n-  unsigned int indx;\n-  int changed = 0;\n \n-#if BITMAP_ELEMENT_WORDS == 2\n-#define DOIT(OP)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    BITMAP_WORD t0, t1, f10, f11, f20, f21;\t\t\\\n-    f10 = from1_tmp->bits[0];\t\t\t\t\\\n-    f20 = from2_tmp->bits[0];\t\t\t\t\\\n-    t0 = f10 OP f20;\t\t\t\t\t\\\n-    changed |= (t0 != to_tmp->bits[0]);\t\t\t\\\n-    f11 = from1_tmp->bits[1];\t\t\t\t\\\n-    f21 = from2_tmp->bits[1];\t\t\t\t\\\n-    t1 = f11 OP f21;\t\t\t\t\t\\\n-    changed |= (t1 != to_tmp->bits[1]);\t\t\t\\\n-    to_tmp->bits[0] = t0;\t\t\t\t\\\n-    to_tmp->bits[1] = t1;\t\t\t\t\\\n-  } while (0)\n-#else\n-#define DOIT(OP)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    BITMAP_WORD t, f1, f2;\t\t\t\t\\\n-    int i;\t\t\t\t\t\t\\\n-    for (i = 0; i < BITMAP_ELEMENT_WORDS; ++i)\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tf1 = from1_tmp->bits[i];\t\t\t\\\n-\tf2 = from2_tmp->bits[i];\t\t\t\\\n-\tt = f1 OP f2;\t\t\t\t\t\\\n-\tchanged |= (t != to_tmp->bits[i]);\t\t\\\n-\tto_tmp->bits[i] = t;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  } while (0)\n-#endif\n+/* DST = A & B. */\n \n-  to->first = to->current = 0;\n+void\n+bitmap_and (bitmap dst, bitmap a, bitmap b)\n+{\n+  bitmap_element *dst_elt = dst->first;\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *dst_prev = NULL;\n \n-  while (from1_ptr != 0 || from2_ptr != 0)\n+  gcc_assert (dst != a && dst != b && a != b);\n+  while (a_elt && b_elt)\n     {\n-      /* Figure out whether we need to substitute zero elements for\n-\t missing links.  */\n-      if (indx1 == indx2)\n+      if (a_elt->indx < b_elt->indx)\n+\ta_elt = a_elt->next;\n+      else if (b_elt->indx < a_elt->indx)\n+\tb_elt = b_elt->next;\n+      else\n \t{\n-\t  indx = indx1;\n-\t  from1_tmp = from1_ptr;\n-\t  from2_tmp = from2_ptr;\n-\t  from1_ptr = from1_ptr->next;\n-\t  indx1 = (from1_ptr) ? from1_ptr->indx : HIGHEST_INDEX;\n-\t  from2_ptr = from2_ptr->next;\n-\t  indx2 = (from2_ptr) ? from2_ptr->indx : HIGHEST_INDEX;\n+\t  /* Matching elts, generate A & B.  */\n+\t  unsigned ix;\n+\t  BITMAP_WORD ior = 0;\n+\n+\t  if (!dst_elt)\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n+\t  \n+\t  dst_elt->indx = a_elt->indx;\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD r = a_elt->bits[ix] & b_elt->bits[ix];\n+\n+\t      dst_elt->bits[ix] = r;\n+\t      ior |= r;\n+\t    }\n+\t  if (ior)\n+\t    {\n+\t      dst_prev = dst_elt;\n+\t      dst_elt = dst_elt->next;\n+\t    }\n+\t  a_elt = a_elt->next;\n+\t  b_elt = b_elt->next;\n \t}\n-      else if (indx1 < indx2)\n+    }\n+  bitmap_elt_clear_from (dst, dst_elt);\n+  gcc_assert (!dst->current == !dst->first);\n+  if (dst->current)\n+    dst->indx = dst->current->indx;\n+}\n+\n+/* A &= B.  */\n+\n+void\n+bitmap_and_into (bitmap a, bitmap b)\n+{\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *next;\n+\n+  gcc_assert (a != b);\n+  while (a_elt && b_elt)\n+    {\n+      if (a_elt->indx < b_elt->indx)\n \t{\n-\t  indx = indx1;\n-\t  from1_tmp = from1_ptr;\n-\t  from2_tmp = &bitmap_zero_bits;\n-\t  from1_ptr = from1_ptr->next;\n-\t  indx1 = (from1_ptr) ? from1_ptr->indx : HIGHEST_INDEX;\n+\t  next = a_elt->next;\n+\t  bitmap_element_free (a, a_elt);\n+\t  a_elt = next;\n \t}\n+      else if (b_elt->indx < a_elt->indx)\n+\tb_elt = b_elt->next;\n       else\n \t{\n-\t  indx = indx2;\n-\t  from1_tmp = &bitmap_zero_bits;\n-\t  from2_tmp = from2_ptr;\n-\t  from2_ptr = from2_ptr->next;\n-\t  indx2 = (from2_ptr) ? from2_ptr->indx : HIGHEST_INDEX;\n+\t  /* Matching elts, generate A &= B.  */\n+\t  unsigned ix;\n+\t  BITMAP_WORD ior = 0;\n+\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD r = a_elt->bits[ix] & b_elt->bits[ix];\n+\n+\t      a_elt->bits[ix] = r;\n+\t      ior |= r;\n+\t    }\n+\t  next = a_elt->next;\n+\t  if (!ior)\n+\t    bitmap_element_free (a, a_elt);\n+\t  a_elt = next;\n+\t  b_elt = b_elt->next;\n \t}\n+    }\n+  bitmap_elt_clear_from (a, a_elt);\n+  gcc_assert (!a->current == !a->first);\n+  gcc_assert (!a->current || a->indx == a->current->indx);\n+}\n+\n+/* DST = A & ~B  */\n+\n+void\n+bitmap_and_compl (bitmap dst, bitmap a, bitmap b)\n+{\n+  bitmap_element *dst_elt = dst->first;\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *dst_prev = NULL;\n \n-      /* Find the appropriate element from TO.  Begin by discarding\n-\t elements that we've skipped.  */\n-      while (to_ptr && to_ptr->indx < indx)\n+  gcc_assert (dst != a && dst != b && a != b);\n+  \n+  while (a_elt)\n+    {\n+      if (!b_elt || a_elt->indx < b_elt->indx)\n \t{\n-\t  changed = 1;\n-\t  to_tmp = to_ptr;\n-\t  to_ptr = to_ptr->next;\n-\t  bitmap_elem_to_freelist (to, to_tmp);\n+\t  /* Copy a_elt. */\n+\t  if (!dst_elt)\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n+\t  \n+\t  dst_elt->indx = a_elt->indx;\n+\t  memcpy (dst_elt->bits, a_elt->bits, sizeof (dst_elt->bits));\n+\t  dst_prev = dst_elt;\n+\t  dst_elt = dst_elt->next;\n+\t  a_elt = a_elt->next;\n \t}\n-      if (to_ptr && to_ptr->indx == indx)\n+      else if (b_elt->indx < a_elt->indx)\n+\tb_elt = b_elt->next;\n+      else\n \t{\n-\t  to_tmp = to_ptr;\n-\t  to_ptr = to_ptr->next;\n+\t  /* Matching elts, generate A & ~B.  */\n+\t  unsigned ix;\n+\t  BITMAP_WORD ior = 0;\n+\n+\t  if (!dst_elt)\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n+\t  \n+\t  dst_elt->indx = a_elt->indx;\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD r = a_elt->bits[ix] & ~b_elt->bits[ix];\n+\n+\t      dst_elt->bits[ix] = r;\n+\t      ior |= r;\n+\t    }\n+\t  if (ior)\n+\t    {\n+\t      dst_prev = dst_elt;\n+\t      dst_elt = dst_elt->next;\n+\t    }\n+\t  a_elt = a_elt->next;\n+\t  b_elt = b_elt->next;\n \t}\n+    }\n+  bitmap_elt_clear_from (dst, dst_elt);\n+  gcc_assert (!dst->current == !dst->first);\n+  if (dst->current)\n+    dst->indx = dst->current->indx;\n+}\n+\n+/* A &= ~B */\n+\n+void\n+bitmap_and_compl_into (bitmap a, bitmap b)\n+{\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *next;\n+\n+  gcc_assert (a != b);\n+  while (a_elt && b_elt)\n+    {\n+      if (a_elt->indx < b_elt->indx)\n+\ta_elt = a_elt->next;\n+      else if (b_elt->indx < a_elt->indx)\n+\tb_elt = b_elt->next;\n       else\n-\tto_tmp = bitmap_element_allocate (to);\n+\t{\n+\t  /* Matching elts, generate A &= ~B.  */\n+\t  unsigned ix;\n+\t  BITMAP_WORD ior = 0;\n+\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD r = a_elt->bits[ix] & ~b_elt->bits[ix];\n+\n+\t      a_elt->bits[ix] = r;\n+\t      ior |= r;\n+\t    }\n+\t  next = a_elt->next;\n+\t  if (!ior)\n+\t    bitmap_element_free (a, a_elt);\n+\t  a_elt = next;\n+\t  b_elt = b_elt->next;\n+\t}\n+    }\n+  gcc_assert (!a->current == !a->first);\n+  gcc_assert (!a->current || a->indx == a->current->indx);\n+}\n \n-      /* Do the operation, and if any bits are set, link it into the\n-\t linked list.  */\n-      switch (operation)\n+/* DST = A | B.  Return true if DST changes.  */\n+\n+bool\n+bitmap_ior (bitmap dst, bitmap a, bitmap b)\n+{\n+  bitmap_element *dst_elt = dst->first;\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *dst_prev = NULL;\n+  bool changed = false;  \n+\n+  gcc_assert (dst != a && dst != b && a != b);\n+  while (a_elt || b_elt)\n+    {\n+      if (a_elt && b_elt && a_elt->indx == b_elt->indx)\n \t{\n-\tdefault:\n-\t  gcc_unreachable ();\n-\n-\tcase BITMAP_AND:\n-\t  DOIT (&);\n-\t  break;\n-\n-\tcase BITMAP_AND_COMPL:\n-\t  DOIT (&~);\n-\t  break;\n-\n-\tcase BITMAP_IOR:\n-\t  DOIT (|);\n-\t  break;\n-\tcase BITMAP_IOR_COMPL:\n-\t  DOIT (|~);\n-\t  break;\n-\tcase BITMAP_XOR:\n-\t  DOIT (^);\n-\t  break;\n+\t  /* Matching elts, generate A | B.  */\n+\t  unsigned ix;\n+\t      \n+\t  if (!changed && dst_elt && dst_elt->indx == a_elt->indx)\n+\t    {\n+\t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t\t{\n+\t\t  BITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n+\n+\t\t  if (r != dst_elt->bits[ix])\n+\t\t    {\n+\t\t      dst_elt->bits[ix] = r;\n+\t\t      changed = true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      changed = true;\n+\t      if (!dst_elt)\n+\t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev);\n+\t      dst_elt->indx = a_elt->indx;\n+\t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t\t{\n+\t\t  BITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n+\t\t  \n+\t\t  dst_elt->bits[ix] = r;\n+\t\t}\n+\t    }\n+\t  a_elt = a_elt->next;\n+\t  b_elt = b_elt->next;\n+\t  dst_prev = dst_elt;\n+\t  dst_elt = dst_elt->next;\n \t}\n+      else\n+\t{\n+\t  /* Copy a single element.  */\n+\t  bitmap_element *src;\n \n-      if (! bitmap_element_zerop (to_tmp))\n+\t  if (!b_elt || (a_elt && a_elt->indx < b_elt->indx))\n+\t    {\n+\t      src = a_elt;\n+\t      a_elt = a_elt->next;\n+\t    }\n+\t  else\n+\t    {\n+\t      src = b_elt;\n+\t      b_elt = b_elt->next;\n+\t    }\n+\n+\t  if (!changed && dst_elt && dst_elt->indx == src->indx)\n+\t    {\n+\t      unsigned ix;\n+\t      \n+\t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t\tif (src->bits[ix] != dst_elt->bits[ix])\n+\t\t  {\n+\t\t    dst_elt->bits[ix] = src->bits[ix];\n+\t\t    changed = true;\n+\t\t  }\n+\t    }\n+\t  else\n+\t    {\n+\t      changed = true;\n+\t      if (!dst_elt)\n+\t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev);\n+\t      dst_elt->indx = src->indx;\n+\t      memcpy (dst_elt->bits, src->bits, sizeof (dst_elt->bits));\n+\t    }\n+\t  \n+\t  dst_prev = dst_elt;\n+\t  dst_elt = dst_elt->next;\n+\t}\n+    }\n+\n+  if (dst_elt)\n+    {\n+      changed = true;\n+      bitmap_elt_clear_from (dst, dst_elt);\n+    }\n+  gcc_assert (!dst->current == !dst->first);\n+  if (dst->current)\n+    dst->indx = dst->current->indx;\n+  return changed;\n+}\n+\n+/* A |= B.  Return true if A changes.  */\n+\n+bool\n+bitmap_ior_into (bitmap a, bitmap b)\n+{\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *a_prev = NULL;\n+  bool changed = false;\n+\n+  gcc_assert (a != b);\n+  while (b_elt)\n+    {\n+      if (!a_elt || b_elt->indx < a_elt->indx)\n+\t{\n+\t  /* Copy b_elt.  */\n+\t  bitmap_element *dst = bitmap_elt_insert_after (a, a_prev);\n+\t  \n+\t  dst->indx = b_elt->indx;\n+\t  memcpy (dst->bits, b_elt->bits, sizeof (dst->bits));\n+\t  a_prev = dst;\n+\t  b_elt = b_elt->next;\n+\t  changed = true;\n+\t}\n+      else if (a_elt->indx < b_elt->indx)\n \t{\n-\t  to_tmp->indx = indx;\n-\t  bitmap_element_link (to, to_tmp);\n+\t  a_prev = a_elt;\n+\t  a_elt = a_elt->next;\n \t}\n       else\n \t{\n-\t  bitmap_elem_to_freelist (to, to_tmp);\n+\t  /* Matching elts, generate A |= B.  */\n+\t  unsigned ix;\n+\n+\t  if (changed)\n+\t    for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t      {\n+\t\tBITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n+\t\t\n+\t\ta_elt->bits[ix] = r;\n+\t      }\n+\t  else\n+\t    for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t      {\n+\t\tBITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n+\n+\t\tif (a_elt->bits[ix] != r)\n+\t\t  {\n+\t\t    changed = true;\n+\t\t    a_elt->bits[ix] = r;\n+\t\t  }\n+\t      }\n+\t  b_elt = b_elt->next;\n+\t  a_prev = a_elt;\n+\t  a_elt = a_elt->next;\n \t}\n     }\n+  gcc_assert (!a->current == !a->first);\n+  if (a->current)\n+    a->indx = a->current->indx;\n+  return changed;\n+}\n \n-  /* If we have elements of TO left over, free the lot.  */\n-  if (to_ptr)\n+/* DST = A ^ B  */\n+\n+void\n+bitmap_xor (bitmap dst, bitmap a, bitmap b)\n+{\n+  bitmap_element *dst_elt = dst->first;\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *dst_prev = NULL;\n+\n+  gcc_assert (dst != a && dst != b && a != b);\n+  while (a_elt || b_elt)\n     {\n-      changed = 1;\n-      for (to_tmp = to_ptr; to_tmp->next ; to_tmp = to_tmp->next)\n-\tcontinue;\n-      if (to->using_obstack)\n+      if (a_elt && b_elt && a_elt->indx == b_elt->indx)\n \t{\n-\t  to_tmp->next = bitmap_free;\n-\t  bitmap_free = to_ptr;\n+\t  /* Matching elts, generate A ^ B.  */\n+\t  unsigned ix;\n+\t  BITMAP_WORD ior = 0;\n+\n+\t  if (!dst_elt)\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n+\t  \n+\t  dst_elt->indx = a_elt->indx;\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD r = a_elt->bits[ix] ^ b_elt->bits[ix];\n+\n+\t      ior |= r;\n+\t      dst_elt->bits[ix] = r;\n+\t    }\n+\t  a_elt = a_elt->next;\n+\t  b_elt = b_elt->next;\n+\t  if (ior)\n+\t    {\n+\t      dst_prev = dst_elt;\n+\t      dst_elt = dst_elt->next;\n+\t    }\n \t}\n       else\n \t{\n-\t  to_tmp->next = bitmap_ggc_free;\n-\t  bitmap_ggc_free = to_ptr;\n+\t  /* Copy a single element.  */\n+\t  bitmap_element *src;\n+\n+\t  if (!b_elt || (a_elt && a_elt->indx < b_elt->indx))\n+\t    {\n+\t      src = a_elt;\n+\t      a_elt = a_elt->next;\n+\t    }\n+\t  else\n+\t    {\n+\t      src = b_elt;\n+\t      b_elt = b_elt->next;\n+\t    }\n+\n+\t  if (!dst_elt)\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n+\t  \n+\t  dst_elt->indx = src->indx;\n+\t  memcpy (dst_elt->bits, src->bits, sizeof (dst_elt->bits));\n+\t  dst_prev = dst_elt;\n+\t  dst_elt = dst_elt->next;\n \t}\n     }\n+  bitmap_elt_clear_from (dst, dst_elt);\n+  gcc_assert (!dst->current == !dst->first);\n+  if (dst->current)\n+    dst->indx = dst->current->indx;\n+}\n \n-#undef DOIT\n+/* A ^= B */\n \n-  return changed;\n+void\n+bitmap_xor_into (bitmap a, bitmap b)\n+{\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *a_prev = NULL;\n+\n+  gcc_assert (a != b);\n+  while (b_elt)\n+    {\n+      if (!a_elt || b_elt->indx < a_elt->indx)\n+\t{\n+\t  /* Copy b_elt.  */\n+\t  bitmap_element *dst = bitmap_elt_insert_after (a, a_prev);\n+\t  \n+\t  dst->indx = b_elt->indx;\n+\t  memcpy (dst->bits, b_elt->bits, sizeof (dst->bits));\n+\t  a_prev = dst;\n+\t  b_elt = b_elt->next;\n+\t}\n+      else if (a_elt->indx < b_elt->indx)\n+\t{\n+\t  a_prev = a_elt;\n+\t  a_elt = a_elt->next;\n+\t}\n+      else\n+\t{\n+\t  /* Matching elts, generate A ^= B.  */\n+\t  unsigned ix;\n+\t  BITMAP_WORD ior = 0;\n+\t  bitmap_element *next = a_elt->next;\n+\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD r = a_elt->bits[ix] ^ b_elt->bits[ix];\n+\n+\t      ior |= r;\n+\t      a_elt->bits[ix] = r;\n+\t    }\n+\t  b_elt = b_elt->next;\n+\t  if (ior)\n+\t    a_prev = a_elt;\n+\t  else\n+\t    bitmap_element_free (a, a_elt);\n+\t  a_elt = next;\n+\t}\n+    }\n+  gcc_assert (!a->current == !a->first);\n+  if (a->current)\n+    a->indx = a->current->indx;\n }\n \n /* Return true if two bitmaps are identical.\n@@ -743,36 +1115,35 @@ bitmap_intersect_compl_p (bitmap a, bitmap b)\n }\n \n \f\n-/* Produce TO |= FROM1 & ~FROM2.  Return true, if TO changed.  */\n+/* DST = A | (FROM1 & ~FROM2).  Return true if DST changes.  */\n \n bool\n-bitmap_ior_and_compl_into (bitmap to, bitmap from1, bitmap from2)\n+bitmap_ior_and_compl (bitmap dst, bitmap a, bitmap from1, bitmap from2)\n {\n   bitmap_head tmp;\n-  int changed;\n-\n+  bool changed;\n+  \n   tmp.first = tmp.current = 0;\n   tmp.using_obstack = 0;\n-\n   bitmap_and_compl (&tmp, from1, from2);\n-  changed = bitmap_operation (to, to, &tmp, BITMAP_IOR);\n+  changed = bitmap_ior (dst, a, &tmp);\n   bitmap_clear (&tmp);\n+\n   return changed;\n }\n \n-/* Produce DST = A | (B & ~C).  Return true if DST != A.  */\n+/* A |= (FROM1 & ~FROM2).  Return true if A changes.  */\n \n bool\n-bitmap_ior_and_compl (bitmap dst, bitmap a, bitmap b, bitmap c)\n+bitmap_ior_and_compl_into (bitmap a, bitmap from1, bitmap from2)\n {\n   bitmap_head tmp;\n-  int changed;\n-\n+  bool changed;\n+  \n   tmp.first = tmp.current = 0;\n   tmp.using_obstack = 0;\n-\n-  bitmap_and_compl (&tmp, b, c);\n-  changed = bitmap_operation (dst, a, &tmp, BITMAP_IOR);\n+  bitmap_and_compl (&tmp, from1, from2);\n+  changed = bitmap_ior_into (a, &tmp);\n   bitmap_clear (&tmp);\n \n   return changed;"}, {"sha": "7bf6efe52c74f07a6b8d07ca310ccb6b23587fb4", "filename": "gcc/bitmap.h", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88c4f655e76260eaaa5ca5573c85eb736eb51034/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88c4f655e76260eaaa5ca5573c85eb736eb51034/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=88c4f655e76260eaaa5ca5573c85eb736eb51034", "patch": "@@ -66,15 +66,6 @@ typedef struct bitmap_head_def GTY(()) {\n } bitmap_head;\n typedef struct bitmap_head_def *bitmap;\n \n-/* Enumeration giving the various operations we support.  */\n-enum bitmap_bits {\n-  BITMAP_AND,\t\t\t/* TO = FROM1 & FROM2 */\n-  BITMAP_AND_COMPL,\t\t/* TO = FROM1 & ~ FROM2 */\n-  BITMAP_IOR,\t\t\t/* TO = FROM1 | FROM2 */\n-  BITMAP_XOR,\t\t\t/* TO = FROM1 ^ FROM2 */\n-  BITMAP_IOR_COMPL\t\t\t/* TO = FROM1 | ~FROM2 */\n-};\n-\n /* Global data */\n extern bitmap_element bitmap_zero_bits;\t/* Zero bitmap element */\n \n@@ -97,23 +88,23 @@ extern bool bitmap_intersect_compl_p (bitmap, bitmap);\n /* True if MAP is an empty bitmap.  */\n #define bitmap_empty_p(MAP) (!(MAP)->first)\n \n-/* Perform an operation on two bitmaps, yielding a third.  */\n-extern int bitmap_operation (bitmap, bitmap, bitmap, enum bitmap_bits);\n-\n-#define bitmap_and(DST,A,B) (void)bitmap_operation (DST,A,B,BITMAP_AND)\n-#define bitmap_and_into(DST_SRC,B) (void)bitmap_operation (DST_SRC,DST_SRC,B,BITMAP_AND)\n-#define bitmap_and_compl(DST,A,B) (void)bitmap_operation (DST,A,B,BITMAP_AND_COMPL)\n-#define bitmap_and_compl_into(DST_SRC,B) (void)bitmap_operation (DST_SRC,DST_SRC,B,BITMAP_AND_COMPL)\n-#define bitmap_ior(DST,A,B) (void)bitmap_operation (DST,A,B,BITMAP_IOR)\n-#define bitmap_ior_into(DST_SRC,B) (void)bitmap_operation (DST_SRC,DST_SRC,B,BITMAP_IOR)\n-#define bitmap_ior_compl(DST,A,B) (void)bitmap_operation (DST,A,Br,BITMAP_IOR_COMPL)\n-#define bitmap_xor(DST,A,B) (void)bitmap_operation (DST,A,B,BITMAP_XOR)\n-#define bitmap_xor_into(DST_SRC,B) (void)bitmap_operation (DST_SRC,DST_SRC,B,BITMAP_XOR)\n-\n-/* `or' into one bitmap the `and' of a second bitmap witih the complement\n-   of a third. Return nonzero if the bitmap changes.  */\n-extern bool bitmap_ior_and_compl_into (bitmap, bitmap, bitmap);\n-extern bool bitmap_ior_and_compl (bitmap, bitmap, bitmap, bitmap);\n+/* Boolean operations on bitmaps.  The _into variants are two operand\n+   versions that modify the first source operand.  The other variants\n+   are three operand versions that to not destroy the source bitmaps.\n+   The operations supported are &, & ~, |, ^.  */\n+extern void bitmap_and (bitmap, bitmap, bitmap);\n+extern void bitmap_and_into (bitmap, bitmap);\n+extern void bitmap_and_compl (bitmap, bitmap, bitmap);\n+extern void bitmap_and_compl_into (bitmap, bitmap);\n+extern bool bitmap_ior (bitmap, bitmap, bitmap);\n+extern bool bitmap_ior_into (bitmap, bitmap);\n+extern void bitmap_xor (bitmap, bitmap, bitmap);\n+extern void bitmap_xor_into (bitmap, bitmap);\n+\n+/* DST = A | (B & ~C).  Return true if DST changes.  */\n+extern bool bitmap_ior_and_compl (bitmap DST, bitmap A, bitmap B, bitmap C);\n+/* A |= (B & ~C).  Return true if A changes.  */\n+extern bool bitmap_ior_and_compl_into (bitmap DST, bitmap B, bitmap C);\n \n /* Clear a single register in a register set.  */\n extern void bitmap_clear_bit (bitmap, int);"}]}