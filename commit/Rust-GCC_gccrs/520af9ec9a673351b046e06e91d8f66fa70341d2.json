{"sha": "520af9ec9a673351b046e06e91d8f66fa70341d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwYWY5ZWM5YTY3MzM1MWIwNDZlMDZlOTFkOGY2NmZhNzAzNDFkMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-03-28T18:33:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-03-28T18:33:42Z"}, "message": "tree-ssa-threadupdate.c (redirect_edges): Call create_edge_and_update_destination_phis as needed.\n\n\n\t* tree-ssa-threadupdate.c (redirect_edges): Call\n\tcreate_edge_and_update_destination_phis as needed.\n\t(create_edge_and_update_destination_phis): Accept new BB argument.\n\tAll callers updated.\n\t(thread_block): Do not update the profile when threading around\n\tintermediate blocks.\n\t(thread_single_edge): Likewise.\n\t(determine_bb_domination_status): If BB is not a successor of the\n\tloop header, return NONDOMINATING.\n\t(register_jump_thread): Note when we register a jump thread around\n\tan intermediate block.\n\t* tree-ssa-threadedge.c (thread_around_empty_block): New function.\n\t(thread_across_edge): Use it.\n\n\t* gcc.dg/tree-ssa/ssa-dom-thread-3.c: New test.\n\nFrom-SVN: r171622", "tree": {"sha": "6f6e281ff34d399c1d3ec13acccdbbca92243795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f6e281ff34d399c1d3ec13acccdbbca92243795"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/520af9ec9a673351b046e06e91d8f66fa70341d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520af9ec9a673351b046e06e91d8f66fa70341d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520af9ec9a673351b046e06e91d8f66fa70341d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520af9ec9a673351b046e06e91d8f66fa70341d2/comments", "author": null, "committer": null, "parents": [{"sha": "80ec23acbd7c94b82afc2e53506d5bfa2a049fe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ec23acbd7c94b82afc2e53506d5bfa2a049fe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ec23acbd7c94b82afc2e53506d5bfa2a049fe8"}], "stats": {"total": 205, "additions": 193, "deletions": 12}, "files": [{"sha": "15500e48df87df3f7df369505bea9e7e19481239", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=520af9ec9a673351b046e06e91d8f66fa70341d2", "patch": "@@ -1,3 +1,19 @@\n+2011-03-28  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (redirect_edges): Call\n+\tcreate_edge_and_update_destination_phis as needed.\n+\t(create_edge_and_update_destination_phis): Accept new BB argument.\n+\tAll callers updated.\n+\t(thread_block): Do not update the profile when threading around\n+\tintermediate blocks.\n+\t(thread_single_edge): Likewise.\n+\t(determine_bb_domination_status): If BB is not a successor of the\n+\tloop header, return NONDOMINATING.\n+\t(register_jump_thread): Note when we register a jump thread around\n+\tan intermediate block.\n+\t* tree-ssa-threadedge.c (thread_around_empty_block): New function.\n+\t(thread_across_edge): Use it.\n+\n 2011-03-28  Tristan Gingold  <gingold@adacore.com>\n \n \t* config/ia64/ia64.c (ia64_promote_function_mode): Fix promotion"}, {"sha": "dec92efca7c507fb6664d5bb3fb016a57d69208d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=520af9ec9a673351b046e06e91d8f66fa70341d2", "patch": "@@ -1,3 +1,7 @@\n+2011-03-28  Jeff Law <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-3.c: New test.\n+\n 2011-03-28  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* gcc.dg/stack-usage-1.c (SIZE): Provide proper values for __PPC64__"}, {"sha": "d851bf23fe8ed5c7aba205a94047b3925067b6c8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-3.c?ref=520af9ec9a673351b046e06e91d8f66fa70341d2", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-dom1-details\" } */\n+extern void abort (void) __attribute__ ((__noreturn__));\n+union tree_node;\n+typedef union tree_node *tree;\n+enum tree_code\n+{\n+  VAR_DECL,\n+  SSA_NAME,\n+  MAX_TREE_CODES\n+};\n+extern unsigned char tree_contains_struct[MAX_TREE_CODES][64];\n+struct tree_base\n+{\n+  enum tree_code code:16;\n+};\n+enum tree_node_structure_enum\n+{\n+  TS_DECL_COMMON\n+};\n+struct tree_ssa_name\n+{\n+  tree var;\n+};\n+union tree_node\n+{\n+  struct tree_base base;\n+  struct tree_ssa_name ssa_name;\n+};\n+long\n+expand_one_var (tree var, unsigned char toplevel, unsigned char really_expand)\n+{\n+  tree origvar = var;\n+  var = var->ssa_name.var;\n+  if (((enum tree_code) (origvar)->base.code) == SSA_NAME\n+      && !((var->base.code != VAR_DECL)))\n+    abort ();\n+  if ((var->base.code) != VAR_DECL && ((origvar)->base.code) != SSA_NAME)\n+    ;\n+  else if (tree_contains_struct[(var->base.code)][(TS_DECL_COMMON)] != 1)\n+    abort ();\n+}\n+/* We should thread the jump, through an intermediate block.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"dom1\"} } */\n+/* { dg-final { scan-tree-dump-times \"one or more intermediate\" 1 \"dom1\"} } */\n+/* { dg-final { cleanup-tree-dump \"dom1\" } } */\n+"}, {"sha": "1fee9bf84c37bbdb1d79aada1e6b5fde61982337", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=520af9ec9a673351b046e06e91d8f66fa70341d2", "patch": "@@ -583,6 +583,76 @@ simplify_control_stmt_condition (edge e,\n   return cached_lhs;\n }\n \n+/* TAKEN_EDGE represents the an edge taken as a result of jump threading.\n+   See if we can thread around TAKEN_EDGE->dest as well.  If so, return\n+   the edge out of TAKEN_EDGE->dest that we can statically compute will be\n+   traversed.\n+\n+   We are much more restrictive as to the contents of TAKEN_EDGE->dest\n+   as the path isolation code in tree-ssa-threadupdate.c isn't prepared\n+   to handle copying intermediate blocks on a threaded path. \n+\n+   Long term a more consistent and structured approach to path isolation\n+   would be a huge help.   */\n+static edge\n+thread_around_empty_block (edge taken_edge,\n+\t\t\t   gimple dummy_cond,\n+\t\t\t   bool handle_dominating_asserts,\n+\t\t\t   tree (*simplify) (gimple, gimple),\n+\t\t\t   bitmap visited)\n+{\n+  basic_block bb = taken_edge->dest;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n+  tree cond;\n+\n+  /* This block must have a single predecessor (E->dest).  */\n+  if (!single_pred_p (bb))\n+    return NULL;\n+\n+  /* This block must have more than one successor.  */\n+  if (single_succ_p (bb))\n+    return NULL;\n+\n+  /* This block can have no PHI nodes.  This is overly conservative.  */\n+  if (!gsi_end_p (gsi_start_phis (bb)))\n+    return NULL;\n+\n+  /* Skip over DEBUG statements at the start of the block.  */\n+  gsi = gsi_start_nondebug_bb (bb);\n+\n+  if (gsi_end_p (gsi))\n+    return NULL;\n+\n+  /* This block can have no statements other than its control altering\n+     statement.  This is overly conservative.  */\n+  stmt = gsi_stmt (gsi);\n+  if (gimple_code (stmt) != GIMPLE_COND\n+      && gimple_code (stmt) != GIMPLE_GOTO\n+      && gimple_code (stmt) != GIMPLE_SWITCH)\n+    return NULL;\n+\n+  /* Extract and simplify the condition.  */\n+  cond = simplify_control_stmt_condition (taken_edge, stmt, dummy_cond,\n+\t\t\t\t\t  simplify, handle_dominating_asserts);\n+\n+  /* If the condition can be statically computed and we have not already\n+     visited the destination edge, then add the taken edge to our thread\n+     path.  */\n+  if (cond && is_gimple_min_invariant (cond))\n+    {\n+      edge taken_edge = find_taken_edge (bb, cond);\n+\n+      if (bitmap_bit_p (visited, taken_edge->dest->index))\n+\treturn NULL;\n+      bitmap_set_bit (visited, taken_edge->dest->index);\n+      return taken_edge;\n+    }\n+ \n+  return NULL;\n+}\n+      \n+\n /* We are exiting E->src, see if E->dest ends with a conditional\n    jump which has a known value when reached via E.\n \n@@ -661,16 +731,44 @@ thread_across_edge (gimple dummy_cond,\n       tree cond;\n \n       /* Extract and simplify the condition.  */\n-      cond = simplify_control_stmt_condition (e, stmt, dummy_cond, simplify, handle_dominating_asserts);\n+      cond = simplify_control_stmt_condition (e, stmt, dummy_cond, simplify,\n+\t\t\t\t\t      handle_dominating_asserts);\n \n       if (cond && is_gimple_min_invariant (cond))\n \t{\n \t  edge taken_edge = find_taken_edge (e->dest, cond);\n \t  basic_block dest = (taken_edge ? taken_edge->dest : NULL);\n+\t  bitmap visited;\n+\t  edge e2;\n \n \t  if (dest == e->dest)\n \t    goto fail;\n \n+\t  /* DEST could be null for a computed jump to an absolute\n+\t     address.  If DEST is not null, then see if we can thread\n+\t     through it as well, this helps capture secondary effects\n+\t     of threading without having to re-run DOM or VRP.  */\n+\t  if (dest)\n+\t    {\n+\t      /* We don't want to thread back to a block we have already\n+ \t\t visited.  This may be overly conservative.  */\n+\t      visited = BITMAP_ALLOC (NULL);\n+\t      bitmap_set_bit (visited, dest->index);\n+\t      bitmap_set_bit (visited, e->dest->index);\n+\t      do\n+\t\t{\n+\t\t  e2 = thread_around_empty_block (taken_edge,\n+\t\t\t\t\t\t  dummy_cond,\n+\t\t\t\t\t\t  handle_dominating_asserts,\n+\t\t\t\t\t\t  simplify,\n+\t\t\t\t\t\t  visited);\n+\t\t  if (e2)\n+\t\t    taken_edge = e2;\n+\t\t}\n+\t      while (e2);\n+\t      BITMAP_FREE (visited);\n+\t    }\n+\n \t  remove_temporary_equivalences (stack);\n \t  register_jump_thread (e, taken_edge);\n \t}"}, {"sha": "efbc5ec28e5cbd21cc0348498502d6dc011cdab1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520af9ec9a673351b046e06e91d8f66fa70341d2/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=520af9ec9a673351b046e06e91d8f66fa70341d2", "patch": "@@ -304,14 +304,15 @@ lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n    destination.  */\n \n static void\n-create_edge_and_update_destination_phis (struct redirection_data *rd)\n+create_edge_and_update_destination_phis (struct redirection_data *rd,\n+\t\t\t\t\t basic_block bb)\n {\n-  edge e = make_edge (rd->dup_block, rd->outgoing_edge->dest, EDGE_FALLTHRU);\n+  edge e = make_edge (bb, rd->outgoing_edge->dest, EDGE_FALLTHRU);\n   gimple_stmt_iterator gsi;\n \n   rescan_loop_exit (e, true, false);\n   e->probability = REG_BR_PROB_BASE;\n-  e->count = rd->dup_block->count;\n+  e->count = bb->count;\n   e->aux = rd->outgoing_edge->aux;\n \n   /* If there are any PHI nodes at the destination of the outgoing edge\n@@ -359,7 +360,7 @@ create_duplicates (void **slot, void *data)\n \n       /* Go ahead and wire up outgoing edges and update PHIs for the duplicate\n          block.  */\n-      create_edge_and_update_destination_phis (rd);\n+      create_edge_and_update_destination_phis (rd, rd->dup_block);\n     }\n \n   /* Keep walking the hash table.  */\n@@ -380,7 +381,7 @@ fixup_template_block (void **slot, void *data)\n      and halt the hash table traversal.  */\n   if (rd->dup_block && rd->dup_block == local_info->template_block)\n     {\n-      create_edge_and_update_destination_phis (rd);\n+      create_edge_and_update_destination_phis (rd, rd->dup_block);\n       return 0;\n     }\n \n@@ -443,6 +444,11 @@ redirect_edges (void **slot, void *data)\n \t  remove_ctrl_stmt_and_useless_edges (local_info->bb,\n \t\t\t\t\t      rd->outgoing_edge->dest);\n \n+\t  /* If we are threading beyond the immediate successors of\n+\t     the duplicate, then BB will have no edges, create one.  */\n+\t  if (EDGE_COUNT (local_info->bb->succs) == 0)\n+\t    create_edge_and_update_destination_phis (rd, local_info->bb);\n+\n \t  /* Fixup the flags on the single remaining edge.  */\n \t  single_succ_edge (local_info->bb)->flags\n \t    &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_ABNORMAL);\n@@ -565,8 +571,9 @@ thread_block (basic_block bb, bool noloop_only)\n \t  continue;\n \t}\n \n-      update_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n-\t\t\t\t       e->count, (edge) e->aux);\n+      if (e->dest == e2->src)\n+\tupdate_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n+\t\t\t\t         e->count, (edge) e->aux);\n \n       /* Insert the outgoing edge into the hash table if it is not\n \t already in the hash table.  */\n@@ -650,12 +657,13 @@ thread_single_edge (edge e)\n     }\n \n   /* Otherwise, we need to create a copy.  */\n-  update_bb_profile_for_threading (bb, EDGE_FREQUENCY (e), e->count, eto);\n+  if (e->dest == eto->src)\n+    update_bb_profile_for_threading (bb, EDGE_FREQUENCY (e), e->count, eto);\n \n   rd.outgoing_edge = eto;\n \n   create_block_for_threading (bb, &rd);\n-  create_edge_and_update_destination_phis (&rd);\n+  create_edge_and_update_destination_phis (&rd, rd.dup_block);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n@@ -704,7 +712,9 @@ determine_bb_domination_status (struct loop *loop, basic_block bb)\n   edge e;\n \n #ifdef ENABLE_CHECKING\n-  /* This function assumes BB is a successor of LOOP->header.  */\n+  /* This function assumes BB is a successor of LOOP->header.\n+     If that is not the case return DOMST_NONDOMINATING which\n+     is always safe.  */\n     {\n       bool ok = false;\n \n@@ -717,7 +727,8 @@ determine_bb_domination_status (struct loop *loop, basic_block bb)\n \t    }\n \t}\n \n-      gcc_assert (ok);\n+      if (!ok)\n+\treturn DOMST_NONDOMINATING;\n     }\n #endif\n \n@@ -1099,6 +1110,11 @@ register_jump_thread (edge e, edge e2)\n   if (threaded_edges == NULL)\n     threaded_edges = VEC_alloc (edge, heap, 10);\n \n+  if (dump_file && (dump_flags & TDF_DETAILS)\n+      && e->dest != e2->src)\n+    fprintf (dump_file,\n+\t     \"  Registering jump thread around one or more intermediate blocks\\n\");\n+\n   VEC_safe_push (edge, heap, threaded_edges, e);\n   VEC_safe_push (edge, heap, threaded_edges, e2);\n }"}]}