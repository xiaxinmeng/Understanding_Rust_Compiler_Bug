{"sha": "5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI2MWU4OWZkYTZiZGY0YWUxMDFlMmJiZGI5MmJmZTQ0NzUzZWEzOA==", "commit": {"author": {"name": "Robert Lipe", "email": "robertlipe@usa.net", "date": "1999-04-29T14:08:18Z"}, "committer": {"name": "Robert Lipe", "email": "robertl@gcc.gnu.org", "date": "1999-04-29T14:08:18Z"}, "message": "regex.c, regex.h: Removed.\n\nThu Apr 29 15:58:52 1999  Robert Lipe  <robertlipe@usa.net>\n        * fixinc/regex.c, fixinc/regex.h: Removed.   Replace with...\n        * fixinc/gnu-regex.c, fixinc/gnu-regex.h: Imported from GDB 4.18.\n        * fixinc/Makefile.in (OBJ, HDR): Handle name changes from above.\n        (gnu-regex.o): Define REGEX_MALLOC to avoid memory leak.\n\nFrom-SVN: r26696", "tree": {"sha": "70d4afd659b3cde919ae05b32595b65dd195306e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70d4afd659b3cde919ae05b32595b65dd195306e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/comments", "author": null, "committer": null, "parents": [{"sha": "8938bb764b8fc64d45b27d2eed9f43783441a0c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8938bb764b8fc64d45b27d2eed9f43783441a0c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8938bb764b8fc64d45b27d2eed9f43783441a0c2"}], "stats": {"total": 3491, "additions": 2157, "deletions": 1334}, "files": [{"sha": "396daa6fa364b350e37bd24db9b30892867019fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38", "patch": "@@ -1,3 +1,11 @@\n+\n+Thu Apr 29 15:58:52 1999  Robert Lipe  <robertlipe@usa.net>\n+\n+\t* fixinc/regex.c, fixinc/regex.h: Removed.   Replace with...\n+\t* fixinc/gnu-regex.c, fixinc/gnu-regex.h: Imported from GDB 4.18.\n+\t* fixinc/Makefile.in (OBJ, HDR): Handle name changes from above.\n+\t(gnu-regex.o): Define REGEX_MALLOC to avoid memory leak.\n+\n Thu Apr 29 12:53:33 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* calls.c (emit_call_1): Pass rounded_stack_size to emit_call"}, {"sha": "2ba932f8c6fadcaee0d770a408f2ac8e4130e1db", "filename": "gcc/fixinc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/gcc%2Ffixinc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/gcc%2Ffixinc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2FMakefile.in?ref=5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38", "patch": "@@ -58,8 +58,8 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n ##\n ## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n \n-OBJ = fixincl.o server.o regex.o procopen.o\n-HDR = server.h regex.h\n+OBJ = fixincl.o server.o gnu-regex.o procopen.o\n+HDR = server.h gnu-regex.h\n LIBERTY = ../../libiberty/libiberty.a\n \n SH_TARGET  = inclhack.sh fixincl.sh\n@@ -80,8 +80,9 @@ fixincl: $(OBJ)\n \trm -f $@ ; (echo \"#! /bin/sh\" ; echo exit 1 ) > $@ ; \\\n \tchmod 777 $@ ; fi\n \n-regex.o: regex.c\n-\t-$(CC) $(CFLAGS) $(FIXINC_DEFS) -DSTDC_HEADERS=1 -c $(srcdir)/regex.c\n+gnu-regex.o: gnu-regex.c\n+\t-$(CC) $(CFLAGS) $(FIXINC_DEFS) -DREGEX_MALLOC -DSTDC_HEADERS=1 \\\n+\t\t-c $(srcdir)/gnu-regex.c\n \n fixincl.o : fixincl.x fixincl.c\n server.o : server.c server.h"}, {"sha": "84db70f79520b75721075366827d7e2978d11677", "filename": "gcc/fixinc/gnu-regex.c", "status": "renamed", "additions": 1980, "deletions": 1240, "changes": 3220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/gcc%2Ffixinc%2Fgnu-regex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/gcc%2Ffixinc%2Fgnu-regex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fgnu-regex.c?ref=5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38", "previous_filename": "gcc/fixinc/regex.c"}, {"sha": "9153ea1b07d0594bd9abd48c3b75f4e4fd061f6f", "filename": "gcc/fixinc/gnu-regex.h", "status": "renamed", "additions": 164, "deletions": 90, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/gcc%2Ffixinc%2Fgnu-regex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38/gcc%2Ffixinc%2Fgnu-regex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fgnu-regex.h?ref=5b61e89fda6bdf4ae101e2bbdb92bfe44753ea38", "patch": "@@ -1,49 +1,66 @@\n /* Definitions for data structures and routines for the regular\n    expression library, version 0.12.\n+   Copyright (C) 1985,89,90,91,92,93,95,96,97,98 Free Software Foundation, Inc.\n \n-   Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n+   NOTE: The canonical source of this file is maintained with the \n+   GNU C Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n \n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n \n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n \n    You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+   along with this program; if not, write to the Free Software Foundation, \n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n-#ifndef __REGEXP_LIBRARY_H__\n-#define __REGEXP_LIBRARY_H__\n+#ifndef _REGEX_H\n+#define _REGEX_H 1\n+\n+/* Allow the use in C++ code.  */\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n \n /* POSIX says that <sys/types.h> must be included (by the caller) before\n    <regex.h>.  */\n \n-#ifdef VMS\n+#if !defined _POSIX_C_SOURCE && !defined _POSIX_SOURCE && defined VMS\n /* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it\n    should be there.  */\n-#include <stddef.h>\n+# include <stddef.h>\n #endif\n \n+/* GDB LOCAL: define _REGEX_RE_COMP to get BSD style re_comp and re_exec */\n+#ifndef _REGEX_RE_COMP\n+#define _REGEX_RE_COMP\n+#endif\n+\n+/* The following two types have to be signed and unsigned integer type\n+   wide enough to hold a value of a pointer.  For most ANSI compilers\n+   ptrdiff_t and size_t should be likely OK.  Still size of these two\n+   types is 2 for Microsoft C.  Ugh... */\n+typedef long int s_reg_t;\n+typedef unsigned long int active_reg_t;\n \n /* The following bits are used to determine the regexp syntax we\n    recognize.  The set/not-set meanings are chosen so that Emacs syntax\n    remains the value 0.  The bits are given in alphabetical order, and\n    the definitions shifted by one from the previous bit; thus, when we\n    add or remove a bit, only one other definition need change.  */\n-typedef unsigned reg_syntax_t;\n+typedef unsigned long int reg_syntax_t;\n \n /* If this bit is not set, then \\ inside a bracket expression is literal.\n    If set, then such a \\ quotes the following character.  */\n-#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)\n+#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)\n \n /* If this bit is not set, then + and ? are operators, and \\+ and \\? are\n-     literals. \n+     literals.\n    If set, then \\+ and \\? are operators and + and ? are literals.  */\n #define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)\n \n@@ -59,7 +76,7 @@ typedef unsigned reg_syntax_t;\n         ^  is an anchor if it is at the beginning of a regular\n            expression or after an open-group or an alternation operator;\n         $  is an anchor if it is at the end of a regular expression, or\n-           before a close-group or an alternation operator.  \n+           before a close-group or an alternation operator.\n \n    This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because\n    POSIX draft 11.2 says that * etc. in leading positions is undefined.\n@@ -70,7 +87,7 @@ typedef unsigned reg_syntax_t;\n /* If this bit is set, then special characters are always special\n      regardless of where they are in the pattern.\n    If this bit is not set, then special characters are special only in\n-     some contexts; otherwise they are ordinary.  Specifically, \n+     some contexts; otherwise they are ordinary.  Specifically,\n      * + ? and intervals are only special when not after the beginning,\n      open-group, or alternation operator.  */\n #define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)\n@@ -92,7 +109,7 @@ typedef unsigned reg_syntax_t;\n #define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)\n \n /* If this bit is set, either \\{...\\} or {...} defines an\n-     interval, depending on RE_NO_BK_BRACES. \n+     interval, depending on RE_NO_BK_BRACES.\n    If not set, \\{, \\}, {, and } are literals.  */\n #define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)\n \n@@ -117,7 +134,7 @@ typedef unsigned reg_syntax_t;\n    If not set, then \\<digit> is a back-reference.  */\n #define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)\n \n-/* If this bit is set, then | is an alternation operator, and \\| is literal. \n+/* If this bit is set, then | is an alternation operator, and \\| is literal.\n    If not set, then \\| is an alternation operator, and | is literal.  */\n #define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)\n \n@@ -131,6 +148,22 @@ typedef unsigned reg_syntax_t;\n    If not set, then an unmatched ) is invalid.  */\n #define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)\n \n+/* If this bit is set, succeed as soon as we match the whole pattern,\n+   without further backtracking.  */\n+#define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)\n+\n+/* If this bit is set, do not process the GNU regex operators.\n+   If not set, then the GNU regex operators are recognized. */\n+#define RE_NO_GNU_OPS (RE_NO_POSIX_BACKTRACKING << 1)\n+\n+/* If this bit is set, turn on internal regex debugging.\n+   If not set, and debugging was on, turn it off.\n+   This only works if regex.c is compiled -DDEBUG.\n+   We define this bit always, so that all that's needed to turn on\n+   debugging is to recompile regex.c; the calling code can always have\n+   this bit set, and it won't affect anything in the normal case. */\n+#define RE_DEBUG (RE_NO_GNU_OPS << 1)\n+\n /* This global variable defines the particular regexp syntax to use (for\n    some interfaces).  When a regexp is compiled, the syntax used is\n    stored in the pattern buffer, so changing this does not affect\n@@ -139,18 +172,24 @@ extern reg_syntax_t re_syntax_options;\n \f\n /* Define combinations of the above bits for the standard possibilities.\n    (The [[[ comments delimit what gets put into the Texinfo file, so\n-   don't delete them!)  */ \n+   don't delete them!)  */\n /* [[[begin syntaxes]]] */\n #define RE_SYNTAX_EMACS 0\n \n #define RE_SYNTAX_AWK\t\t\t\t\t\t\t\\\n-  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL\t\t\t\\\n-   | RE_NO_BK_PARENS            | RE_NO_BK_REFS\t\t\t\t\\\n-   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES\t\t\t\\\n-   | RE_UNMATCHED_RIGHT_PAREN_ORD)\n+  (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL\t\t\t\\\n+   | RE_NO_BK_PARENS              | RE_NO_BK_REFS\t\t\t\\\n+   | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES\t\t\t\\\n+   | RE_DOT_NEWLINE\t\t  | RE_CONTEXT_INDEP_ANCHORS\t\t\\\n+   | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)\n+\n+#define RE_SYNTAX_GNU_AWK\t\t\t\t\t\t\\\n+  ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DEBUG)\t\\\n+   & ~(RE_DOT_NOT_NULL | RE_INTERVALS | RE_CONTEXT_INDEP_OPS))\n \n #define RE_SYNTAX_POSIX_AWK \t\t\t\t\t\t\\\n-  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)\n+  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS\t\t\\\n+   | RE_INTERVALS\t    | RE_NO_GNU_OPS)\n \n #define RE_SYNTAX_GREP\t\t\t\t\t\t\t\\\n   (RE_BK_PLUS_QM              | RE_CHAR_CLASSES\t\t\t\t\\\n@@ -204,9 +243,10 @@ extern reg_syntax_t re_syntax_options;\n    (erroneously) define this in other header files, but we want our\n    value, so remove any previous define.  */\n #ifdef RE_DUP_MAX\n-#undef RE_DUP_MAX\n+# undef RE_DUP_MAX\n #endif\n-#define RE_DUP_MAX ((1 << 15) - 1) \n+/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */\n+#define RE_DUP_MAX (0x7fff)\n \n \n /* POSIX `cflags' bits (i.e., information for `regcomp').  */\n@@ -218,7 +258,7 @@ extern reg_syntax_t re_syntax_options;\n /* If this bit is set, then ignore case when matching.\n    If not set, then case is significant.  */\n #define REG_ICASE (REG_EXTENDED << 1)\n- \n+\n /* If this bit is set, then anchors do not match at newline\n      characters in the string.\n    If not set, then anchors do match at newlines.  */\n@@ -242,51 +282,48 @@ extern reg_syntax_t re_syntax_options;\n #define REG_NOTEOL (1 << 1)\n \n \n-  /* POSIX doesn't require that we do anything for the 0 case,\n-     but why not be nice.  */\n-\n-#define REG_ERR_TABLE                                           \\\n-  _RERR_( NOERROR,   \"Success\" )                                \\\n-  _RERR_( NOMATCH,   \"No match\" )                               \\\n-  /*                                                            \\\n-   *  POSIX regcomp return error codes.                         \\\n-   *  (In the order listed in the standard.)                    \\\n-   */                                                           \\\n-  _RERR_( BADPAT,    \"Invalid regular expression\" )             \\\n-  _RERR_( ECOLLATE,  \"Invalid collation character\" )            \\\n-  _RERR_( ECTYPE,    \"Invalid character class name\" )           \\\n-  _RERR_( EESCAPE,   \"Trailing backslash\" )                     \\\n-  _RERR_( ESUBREG,   \"Invalid back reference\" )                 \\\n-  _RERR_( EBRACK,    \"Unmatched [ or [^\" )                      \\\n-  _RERR_( EPAREN,    \"Unmatched ( or \\\\(\" )                     \\\n-  _RERR_( EBRACE,    \"Unmatched \\\\{\" )                          \\\n-  _RERR_( BADBR,     \"Invalid content of \\\\{\\\\}\" )              \\\n-  _RERR_( ERANGE,    \"Invalid range end\" )                      \\\n-  _RERR_( ESPACE,    \"Memory exhausted\" )                       \\\n-  _RERR_( BADRPT,    \"Invalid preceding regular expression\" )   \\\n-  _RERR_( ECHAR,     \"Invalid multibyte character\" )            \\\n-  _RERR_( EBOL,      \"^ anchor and not BOL\" )                   \\\n-  _RERR_( EEOL,      \"$ anchor and not EOL\" )                   \\\n-                                                                \\\n-  /*                                                            \\\n-   * Error codes we've added.                                   \\\n-   */                                                           \\\n-  _RERR_( EEND,      \"Premature end of regular expression\" )    \\\n-  _RERR_( ESIZE,     \"Regular expression too big\" )             \\\n-  _RERR_( ERPAREN,   \"Unmatched ) or \\\\)\" )\n-\n-#define _RERR_(n,t)  REG_ ## n,\n-\n-typedef enum { REG_ERR_TABLE REG_ERR_COUNT } reg_errcode_t;\n-\n-#undef _RERR_\n+/* If any error codes are removed, changed, or added, update the\n+   `re_error_msg' table in regex.c.  */\n+typedef enum\n+{\n+#if (_XOPEN_SOURCE - 0) == 500\n+  REG_NOSYS = -1,\t/* This will never happen for this implementation.  */\n+#endif\n+\n+  REG_NOERROR = 0,\t/* Success.  */\n+  REG_NOMATCH,\t\t/* Didn't find a match (for regexec).  */\n+\n+  /* POSIX regcomp return error codes.  (In the order listed in the\n+     standard.)  */\n+  REG_BADPAT,\t\t/* Invalid pattern.  */\n+  REG_ECOLLATE,\t\t/* Not implemented.  */\n+  REG_ECTYPE,\t\t/* Invalid character class name.  */\n+  REG_EESCAPE,\t\t/* Trailing backslash.  */\n+  REG_ESUBREG,\t\t/* Invalid back reference.  */\n+  REG_EBRACK,\t\t/* Unmatched left bracket.  */\n+  REG_EPAREN,\t\t/* Parenthesis imbalance.  */\n+  REG_EBRACE,\t\t/* Unmatched \\{.  */\n+  REG_BADBR,\t\t/* Invalid contents of \\{\\}.  */\n+  REG_ERANGE,\t\t/* Invalid range end.  */\n+  REG_ESPACE,\t\t/* Ran out of memory.  */\n+  REG_BADRPT,\t\t/* No preceding re for repetition op.  */\n+\n+  /* Error codes we've added.  */\n+  REG_EEND,\t\t/* Premature end.  */\n+  REG_ESIZE,\t\t/* Compiled pattern bigger than 2^16 bytes.  */\n+  REG_ERPAREN\t\t/* Unmatched ) or \\); not returned from regcomp.  */\n+} reg_errcode_t;\n \f\n /* This data structure represents a compiled pattern.  Before calling\n    the pattern compiler, the fields `buffer', `allocated', `fastmap',\n    `translate', and `no_sub' can be set.  After the pattern has been\n    compiled, the `re_nsub' field is available.  All other fields are\n    private to the regex routines.  */\n \n+#ifndef RE_TRANSLATE_TYPE\n+# define RE_TRANSLATE_TYPE char *\n+#endif\n+\n struct re_pattern_buffer\n {\n /* [[[begin pattern_buffer]]] */\n@@ -296,10 +333,10 @@ struct re_pattern_buffer\n   unsigned char *buffer;\n \n \t/* Number of bytes to which `buffer' points.  */\n-  unsigned long allocated;\n+  unsigned long int allocated;\n \n \t/* Number of bytes actually used in `buffer'.  */\n-  unsigned long used;\t\n+  unsigned long int used;\n \n         /* Syntax setting with which the pattern was compiled.  */\n   reg_syntax_t syntax;\n@@ -313,7 +350,7 @@ struct re_pattern_buffer\n            comparing them, or zero for no translation.  The translation\n            is applied to a pattern when it is compiled and to a string\n            when it is matched.  */\n-  char *translate;\n+  RE_TRANSLATE_TYPE translate;\n \n \t/* Number of subexpressions found by the compiler.  */\n   size_t re_nsub;\n@@ -343,7 +380,7 @@ struct re_pattern_buffer\n   unsigned no_sub : 1;\n \n         /* If set, a beginning-of-line anchor doesn't match at the\n-           beginning of the string.  */ \n+           beginning of the string.  */\n   unsigned not_bol : 1;\n \n         /* Similarly for an end-of-line anchor.  */\n@@ -356,11 +393,6 @@ struct re_pattern_buffer\n };\n \n typedef struct re_pattern_buffer regex_t;\n-\n-\n-/* search.c (search_buffer) in Emacs needs this one opcode value.  It is\n-   defined both in `regex.c' and here.  */\n-#define RE_EXACTN_VALUE 1\n \f\n /* Type for byte offsets within the string.  POSIX mandates this.  */\n typedef int regoff_t;\n@@ -380,7 +412,7 @@ struct re_registers\n    `re_match_2' returns information about at least this many registers\n    the first time a `regs' structure is passed.  */\n #ifndef RE_NREGS\n-#define RE_NREGS 30\n+# define RE_NREGS 30\n #endif\n \n \n@@ -403,29 +435,34 @@ typedef struct\n \n #if __STDC__\n \n-#define _RE_ARGS(args) args\n+# define _RE_ARGS(args) args\n \n #else /* not __STDC__ */\n \n-#define _RE_ARGS(args) ()\n+# define _RE_ARGS(args) ()\n \n #endif /* not __STDC__ */\n \n /* Sets the current default syntax to SYNTAX, and return the old syntax.\n    You can also simply assign to the `re_syntax_options' variable.  */\n+extern reg_syntax_t __re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n \n /* Compile the regular expression PATTERN, with length LENGTH\n    and syntax given by the global `re_syntax_options', into the buffer\n    BUFFER.  Return NULL if successful, and an error string if not.  */\n+extern const char *__re_compile_pattern\n+  _RE_ARGS ((const char *pattern, size_t length,\n+             struct re_pattern_buffer *buffer));\n extern const char *re_compile_pattern\n-  _RE_ARGS ((const char *pattern, int length,\n+  _RE_ARGS ((const char *pattern, size_t length,\n              struct re_pattern_buffer *buffer));\n \n \n /* Compile a fastmap for the compiled pattern in BUFFER; used to\n    accelerate searches.  Return 0 if successful and -2 if was an\n    internal error.  */\n+extern int __re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n \n \n@@ -434,13 +471,20 @@ extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n    characters.  Return the starting position of the match, -1 for no\n    match, or -2 for an internal error.  Also return register\n    information in REGS (if REGS and BUFFER->no_sub are nonzero).  */\n+extern int __re_search\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n+            int length, int start, int range, struct re_registers *regs));\n extern int re_search\n   _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n             int length, int start, int range, struct re_registers *regs));\n \n \n /* Like `re_search', but search in the concatenation of STRING1 and\n    STRING2.  Also, stop searching at index START + STOP.  */\n+extern int __re_search_2\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n+             int length1, const char *string2, int length2,\n+             int start, int range, struct re_registers *regs, int stop));\n extern int re_search_2\n   _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n              int length1, const char *string2, int length2,\n@@ -449,13 +493,20 @@ extern int re_search_2\n \n /* Like `re_search', but return how many characters in STRING the regexp\n    in BUFFER matched, starting at position START.  */\n+extern int __re_match\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n+             int length, int start, struct re_registers *regs));\n extern int re_match\n   _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n              int length, int start, struct re_registers *regs));\n \n \n /* Relates to `re_match' as `re_search_2' relates to `re_search'.  */\n-extern int re_match_2 \n+extern int __re_match_2\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n+             int length1, const char *string2, int length2,\n+             int start, struct re_registers *regs, int stop));\n+extern int re_match_2\n   _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n              int length1, const char *string2, int length2,\n              int start, struct re_registers *regs, int stop));\n@@ -473,25 +524,48 @@ extern int re_match_2\n    Unless this function is called, the first search or match using\n    PATTERN_BUFFER will allocate its own register data, without\n    freeing the old data.  */\n+extern void __re_set_registers\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n+             unsigned num_regs, regoff_t *starts, regoff_t *ends));\n extern void re_set_registers\n   _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n              unsigned num_regs, regoff_t *starts, regoff_t *ends));\n \n+#ifdef _REGEX_RE_COMP\n+# ifndef _CRAY\n /* 4.2 bsd compatibility.  */\n extern char *re_comp _RE_ARGS ((const char *));\n extern int re_exec _RE_ARGS ((const char *));\n+# endif\n+#endif\n \n /* POSIX compatibility.  */\n-extern int regcomp _RE_ARGS ((regex_t *preg, const char *pattern, int cflags));\n-extern int regexec\n-  _RE_ARGS ((const regex_t *preg, const char *string, size_t nmatch,\n-             regmatch_t pmatch[], int eflags));\n-extern size_t regerror\n-  _RE_ARGS ((int errcode, const regex_t *preg, char *errbuf,\n-             size_t errbuf_size));\n-extern void regfree _RE_ARGS ((regex_t *preg));\n-\n-#endif /* not __REGEXP_LIBRARY_H__ */\n+extern int __regcomp _RE_ARGS ((regex_t *__preg, const char *__pattern,\n+\t\t\t\tint __cflags));\n+extern int regcomp _RE_ARGS ((regex_t *__preg, const char *__pattern,\n+\t\t\t      int __cflags));\n+\n+extern int __regexec _RE_ARGS ((const regex_t *__preg,\n+\t\t\t\tconst char *__string, size_t __nmatch,\n+\t\t\t\tregmatch_t __pmatch[], int __eflags));\n+extern int regexec _RE_ARGS ((const regex_t *__preg,\n+\t\t\t      const char *__string, size_t __nmatch,\n+\t\t\t      regmatch_t __pmatch[], int __eflags));\n+\n+extern size_t __regerror _RE_ARGS ((int __errcode, const regex_t *__preg,\n+\t\t\t\t    char *__errbuf, size_t __errbuf_size));\n+extern size_t regerror _RE_ARGS ((int __errcode, const regex_t *__preg,\n+\t\t\t\t  char *__errbuf, size_t __errbuf_size));\n+\n+extern void __regfree _RE_ARGS ((regex_t *__preg));\n+extern void regfree _RE_ARGS ((regex_t *__preg));\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\t/* C++ */\n+\n+#endif /* regex.h */\n \f\n /*\n Local variables:", "previous_filename": "gcc/fixinc/regex.h"}]}