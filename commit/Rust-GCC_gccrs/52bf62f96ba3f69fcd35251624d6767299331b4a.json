{"sha": "52bf62f96ba3f69fcd35251624d6767299331b4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJiZjYyZjk2YmEzZjY5ZmNkMzUyNTE2MjRkNjc2NzI5OTMzMWI0YQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-08-15T19:46:21Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-08-15T19:46:21Z"}, "message": "re PR fortran/38936 ([F03] ASSOCIATE construct / improved SELECT TYPE (a=>expr))\n\n2010-08-15  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\t* gfortran.h (gfc_find_proc_namespace): New method.\n\t* expr.c (gfc_build_intrinsic_call): No need to build symtree messing\n\taround with namespace.\n\t* symbol.c (gfc_find_proc_namespace): New method.\n\t* trans-decl.c (gfc_build_qualified_array): Use it for correct\n\tvalue of nest.\n\t* primary.c (gfc_match_varspec): Handle associate-names as arrays.\n\t* parse.c (parse_associate): Removed assignment-generation here...\n\t* resolve.c (resolve_block_construct): ...and added it here.\n\t(resolve_variable): Handle names that are arrays but were not parsed\n\tas such because of association.\n\t(resolve_code): Fix BLOCK resolution.\n\t(resolve_symbol): Generate array-spec for associate-names.\n\n2010-08-15  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\t* gfortran.dg/associate_1.f03: Enable test for array expressions.\n\t* gfortran.dg/associate_3.f03: Clarify comment.\n\t* gfortran.dg/associate_5.f03: New test.\n\t* gfortran.dg/associate_6.f03: New test.\n\nFrom-SVN: r163268", "tree": {"sha": "2ede6f192c42897061be312972730b088b7b2ee4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ede6f192c42897061be312972730b088b7b2ee4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52bf62f96ba3f69fcd35251624d6767299331b4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52bf62f96ba3f69fcd35251624d6767299331b4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52bf62f96ba3f69fcd35251624d6767299331b4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52bf62f96ba3f69fcd35251624d6767299331b4a/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5fc265c14ff7c8c382dc9d1ba0fb26b2819d1d09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fc265c14ff7c8c382dc9d1ba0fb26b2819d1d09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fc265c14ff7c8c382dc9d1ba0fb26b2819d1d09"}], "stats": {"total": 293, "additions": 238, "deletions": 55}, "files": [{"sha": "e0134fd3167d6935a5c5244d800ce3dfa2661aed", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -1,3 +1,20 @@\n+2010-08-15  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\t* gfortran.h (gfc_find_proc_namespace): New method.\n+\t* expr.c (gfc_build_intrinsic_call): No need to build symtree messing\n+\taround with namespace.\n+\t* symbol.c (gfc_find_proc_namespace): New method.\n+\t* trans-decl.c (gfc_build_qualified_array): Use it for correct\n+\tvalue of nest.\n+\t* primary.c (gfc_match_varspec): Handle associate-names as arrays.\n+\t* parse.c (parse_associate): Removed assignment-generation here...\n+\t* resolve.c (resolve_block_construct): ...and added it here.\n+\t(resolve_variable): Handle names that are arrays but were not parsed\n+\tas such because of association.\n+\t(resolve_code): Fix BLOCK resolution.\n+\t(resolve_symbol): Generate array-spec for associate-names.\n+\n 2010-08-15  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/45211"}, {"sha": "b3f645367168f0fb03ebafdf55ac2579acb4dc42", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -4221,7 +4221,6 @@ gfc_build_intrinsic_call (const char* name, locus where, unsigned numarg, ...)\n   result->expr_type = EXPR_FUNCTION;\n   result->ts = isym->ts;\n   result->where = where;\n-  gfc_get_ha_sym_tree (isym->name, &result->symtree);\n   result->value.function.name = name;\n   result->value.function.isym = isym;\n "}, {"sha": "dbaf9c3a8c8f14f17464c9f0598827ffaa507d50", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -2577,6 +2577,7 @@ void gfc_copy_formal_args_ppc (gfc_component *, gfc_symbol *);\n void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */\n \n gfc_try gfc_check_symbol_typed (gfc_symbol*, gfc_namespace*, bool, locus);\n+gfc_namespace* gfc_find_proc_namespace (gfc_namespace*);\n \n /* intrinsic.c -- true if working in an init-expr, false otherwise.  */\n extern bool gfc_init_expr_flag;"}, {"sha": "72a82c7649da91e63b26056f37e511f18fa1f8c5", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -3206,7 +3206,6 @@ parse_associate (void)\n   gfc_state_data s;\n   gfc_statement st;\n   gfc_association_list* a;\n-  gfc_code* assignTail;\n \n   gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ASSOCIATE construct at %C\");\n \n@@ -3216,46 +3215,24 @@ parse_associate (void)\n   new_st.ext.block.ns = my_ns;\n   gcc_assert (new_st.ext.block.assoc);\n \n-  /* Add all associations to expressions as BLOCK variables, and create\n-     assignments to them giving their values.  */\n+  /* Add all associate-names as BLOCK variables.  There values will be assigned\n+     to them during resolution of the ASSOCIATE construct.  */\n   gfc_current_ns = my_ns;\n-  assignTail = NULL;\n   for (a = new_st.ext.block.assoc; a; a = a->next)\n-    if (!a->variable)\n-      {\n-\tgfc_code* newAssign;\n-\n-\tif (gfc_get_sym_tree (a->name, NULL, &a->st, false))\n-\t  gcc_unreachable ();\n-\n-\t/* Note that in certain cases, the target-expression's type is not yet\n-\t   known and so we have to adapt the symbol's ts also during resolution\n-\t   for these cases.  */\n-\ta->st->n.sym->ts = a->target->ts;\n-\ta->st->n.sym->attr.flavor = FL_VARIABLE;\n-\ta->st->n.sym->assoc = a;\n-\tgfc_set_sym_referenced (a->st->n.sym);\n-\n-\t/* Create the assignment to calculate the expression and set it.  */\n-\tnewAssign = gfc_get_code ();\n-\tnewAssign->op = EXEC_ASSIGN;\n-\tnewAssign->loc = gfc_current_locus;\n-\tnewAssign->expr1 = gfc_get_variable_expr (a->st);\n-\tnewAssign->expr2 = a->target;\n-\n-\t/* Hang it in.  */\n-\tif (assignTail)\n-\t  assignTail->next = newAssign;\n-\telse\n-\t  gfc_current_ns->code = newAssign;\n-\tassignTail = newAssign;\n-      }\n-    else\n-      {\n-\tgfc_error (\"Association to variables is not yet supported at %C\");\n-\treturn;\n-      }\n-  gcc_assert (assignTail);\n+    {\n+      if (a->variable)\n+\t{\n+\t  gfc_error (\"Association to variables is not yet supported at %C\");\n+\t  return;\n+\t}\n+\n+      if (gfc_get_sym_tree (a->name, NULL, &a->st, false))\n+\tgcc_unreachable ();\n+\n+      a->st->n.sym->attr.flavor = FL_VARIABLE;\n+      a->st->n.sym->assoc = a;\n+      gfc_set_sym_referenced (a->st->n.sym);\n+    }\n \n   accept_statement (ST_ASSOCIATE);\n   push_state (&s, COMP_ASSOCIATE, my_ns->proc_name);\n@@ -3269,7 +3246,7 @@ parse_associate (void)\n \n     case_end:\n       accept_statement (st);\n-      assignTail->next = gfc_state_stack->head;\n+      my_ns->code = gfc_state_stack->head;\n       break;\n \n     default:"}, {"sha": "077704650b58923450b40eb34f2894e06c43ada8", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -1748,6 +1748,13 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t}\n     }\n \n+  /* For associate names, we may not yet know whether they are arrays or not.\n+     Thus if we have one and parentheses follow, we have to assume that it\n+     actually is one for now.  The final decision will be made at\n+     resolution time, of course.  */\n+  if (sym->assoc && gfc_peek_ascii_char () == '(')\n+    sym->attr.dimension = 1;\n+\n   if ((equiv_flag && gfc_peek_ascii_char () == '(')\n       || gfc_peek_ascii_char () == '[' || sym->attr.codimension\n       || (sym->attr.dimension && !sym->attr.proc_pointer"}, {"sha": "dc9ce514118c45f66247b319c11c473c664485dc", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 100, "deletions": 5, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -4814,11 +4814,26 @@ resolve_variable (gfc_expr *e)\n \n   if (e->symtree == NULL)\n     return FAILURE;\n+  sym = e->symtree->n.sym;\n+\n+  /* If this is an associate-name, it may be parsed with references in error\n+     even though the target is scalar.  Fail directly in this case.  */\n+  if (sym->assoc && !sym->attr.dimension && e->ref)\n+    return FAILURE;\n+\n+  /* On the other hand, the parser may not have known this is an array;\n+     in this case, we have to add a FULL reference.  */\n+  if (sym->assoc && sym->attr.dimension && !e->ref)\n+    {\n+      e->ref = gfc_get_ref ();\n+      e->ref->type = REF_ARRAY;\n+      e->ref->u.ar.type = AR_FULL;\n+      e->ref->u.ar.dimen = 0;\n+    }\n \n   if (e->ref && resolve_ref (e) == FAILURE)\n     return FAILURE;\n \n-  sym = e->symtree->n.sym;\n   if (sym->attr.flavor == FL_PROCEDURE\n       && (!sym->attr.function\n \t  || (sym->attr.function && sym->result\n@@ -8276,11 +8291,43 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n static void\n resolve_block_construct (gfc_code* code)\n {\n-  /* For an ASSOCIATE block, the associations (and their targets) are already\n-     resolved during gfc_resolve_symbol.  */\n-\n   /* Resolve the BLOCK's namespace.  */\n   gfc_resolve (code->ext.block.ns);\n+\n+  /* For an ASSOCIATE block, the associations (and their targets) are already\n+     resolved during gfc_resolve_symbol.  Here, we have to add code\n+     to assign expression values to the variables associated to expressions.  */\n+  if (code->ext.block.assoc)\n+    {\n+      gfc_association_list* a;     \n+      gfc_code* assignTail;\n+      gfc_code* assignHead;\n+\n+      assignHead = assignTail = NULL;\n+      for (a = code->ext.block.assoc; a; a = a->next)\n+\tif (!a->variable)\n+\t  {\n+\t    gfc_code* newAssign;\n+\n+\t    newAssign = gfc_get_code ();\n+\t    newAssign->op = EXEC_ASSIGN;\n+\t    newAssign->loc = gfc_current_locus;\n+\t    newAssign->expr1 = gfc_lval_expr_from_sym (a->st->n.sym);\n+\t    newAssign->expr2 = a->target;\n+\n+\t    if (!assignHead)\n+\t      assignHead = newAssign;\n+\t    else\n+\t      {\n+\t\tgcc_assert (assignTail);\n+\t\tassignTail->next = newAssign;\n+\t      }\n+\t    assignTail = newAssign;\n+\t  }\n+\n+      assignTail->next = code->ext.block.ns->code;\n+      code->ext.block.ns->code = assignHead;\n+    }\n }\n \n \n@@ -8765,7 +8812,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_BLOCK:\n-\t  gfc_resolve (code->ext.block.ns);\n+\t  resolve_block_construct (code);\n \t  break;\n \n \tcase EXEC_DO:\n@@ -11651,6 +11698,54 @@ resolve_symbol (gfc_symbol *sym)\n \n       sym->ts = sym->assoc->target->ts;\n       gcc_assert (sym->ts.type != BT_UNKNOWN);\n+\n+      if (sym->attr.dimension && sym->assoc->target->rank == 0)\n+\t{\n+\t  gfc_error (\"Associate-name '%s' at %L is used as array\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  sym->attr.dimension = 0;\n+\t  return;\n+\t}\n+      if (sym->assoc->target->rank > 0)\n+\tsym->attr.dimension = 1;\n+\n+      if (sym->attr.dimension)\n+\t{\n+\t  int dim;\n+\n+\t  sym->as = gfc_get_array_spec ();\n+\t  sym->as->rank = sym->assoc->target->rank;\n+\t  sym->as->type = AS_EXPLICIT;\n+\n+\t  /* Target must not be coindexed, thus the associate-variable\n+\t     has no corank.  */\n+\t  sym->as->corank = 0;\n+\n+\t  for (dim = 0; dim < sym->assoc->target->rank; ++dim)\n+\t    {\n+\t      gfc_expr* dim_expr;\n+\t      gfc_expr* e;\n+\n+\t      dim_expr = gfc_get_constant_expr (BT_INTEGER,\n+\t\t\t\t\t\tgfc_default_integer_kind,\n+\t\t\t\t\t\t&sym->declared_at);\n+\t      mpz_set_si (dim_expr->value.integer, dim + 1);\n+\n+\t      e = gfc_build_intrinsic_call (\"lbound\", sym->declared_at, 3,\n+\t\t\t\t\t    gfc_copy_expr (sym->assoc->target),\n+\t\t\t\t\t    gfc_copy_expr (dim_expr), NULL);\n+\t      gfc_resolve_expr (e);\n+\t      sym->as->lower[dim] = e;\n+\n+\t      e = gfc_build_intrinsic_call (\"ubound\", sym->declared_at, 3,\n+\t\t\t\t\t    gfc_copy_expr (sym->assoc->target),\n+\t\t\t\t\t    gfc_copy_expr (dim_expr), NULL);\n+\t      gfc_resolve_expr (e);\n+\t      sym->as->upper[dim] = e;\n+\n+\t      gfc_free_expr (dim_expr);\n+\t    }\n+\t}\n     }\n \n   /* Assign default type to symbols that need one and don't have one.  */"}, {"sha": "009f1b6a2c9855f56fc954f1d754baebc54a2c38", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -4742,3 +4742,19 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n   else\n     return 0;\n }\n+\n+\n+/* Find the parent-namespace of the current function.  If we're inside\n+   BLOCK constructs, it may not be the current one.  */\n+\n+gfc_namespace*\n+gfc_find_proc_namespace (gfc_namespace* ns)\n+{\n+  while (ns->construct_entities)\n+    {\n+      ns = ns->parent;\n+      gcc_assert (ns);\n+    }\n+\n+  return ns;\n+}"}, {"sha": "a44b4a1940745efb208caacda9dc7c3e69e59580", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -658,6 +658,7 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n   tree type;\n   int dim;\n   int nest;\n+  gfc_namespace* procns;\n \n   type = TREE_TYPE (decl);\n \n@@ -666,7 +667,8 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n     return;\n \n   gcc_assert (GFC_ARRAY_TYPE_P (type));\n-  nest = (sym->ns->proc_name->backend_decl != current_function_decl)\n+  procns = gfc_find_proc_namespace (sym->ns);\n+  nest = (procns->proc_name->backend_decl != current_function_decl)\n \t && !sym->attr.contained;\n \n   for (dim = 0; dim < GFC_TYPE_ARRAY_RANK (type); dim++)"}, {"sha": "482626e6ec1e7bb919728ff645036abe7cf46b4a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -1,3 +1,11 @@\n+2010-08-15  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\t* gfortran.dg/associate_1.f03: Enable test for array expressions.\n+\t* gfortran.dg/associate_3.f03: Clarify comment.\n+\t* gfortran.dg/associate_5.f03: New test.\n+\t* gfortran.dg/associate_6.f03: New test.\n+\n 2010-08-15  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/45211"}, {"sha": "0b3081b241bb10cc1ce353006278bb7e872a1993", "filename": "gcc/testsuite/gfortran.dg/associate_1.f03", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -24,13 +24,15 @@ PROGRAM main\n   ! TODO: Test association to derived types.\n \n   ! Test association to arrays.\n-  ! TODO: Enable when working.\n-  !ALLOCATE (arr(3))\n-  !arr = (/ 1, 2, 3 /)\n-  !ASSOCIATE (doubled => 2 * arr)\n-  !  IF (doubled(1) /= 2 .OR. doubled(2) /= 4 .OR. doubled(3) /= 6) &\n-  !    CALL abort ()\n-  !END ASSOCIATE\n+  ALLOCATE (arr(3))\n+  arr = (/ 1, 2, 3 /)\n+  ASSOCIATE (doubled => 2 * arr, xyz => func ())\n+    IF (SIZE (doubled) /= SIZE (arr)) CALL abort ()\n+    IF (doubled(1) /= 2 .OR. doubled(2) /= 4 .OR. doubled(3) /= 6) &\n+      CALL abort ()\n+\n+    IF (ANY (xyz /= (/ 1, 3, 5 /))) CALL abort ()\n+  END ASSOCIATE\n \n   ! Named and nested associate.\n   myname: ASSOCIATE (x => a - b * c)\n@@ -46,4 +48,12 @@ PROGRAM main\n       IF (x /= 2 .OR. y /= 1) CALL abort ()\n     END ASSOCIATE\n   END ASSOCIATE\n+\n+CONTAINS\n+\n+  FUNCTION func ()\n+    INTEGER :: func(3)\n+    func = (/ 1, 3, 5 /)\n+  END FUNCTION func\n+\n END PROGRAM main"}, {"sha": "f8a49052a1ab1dc7b67454961a1092787f4039ba", "filename": "gcc/testsuite/gfortran.dg/associate_3.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -2,7 +2,7 @@\n ! { dg-options \"-std=f2003\" }\n \n ! PR fortran/38936\n-! Check for errors with ASSOCIATE.\n+! Check for errors with ASSOCIATE during parsing.\n \n PROGRAM main\n   IMPLICIT NONE"}, {"sha": "ca62f9445450a9538a771c69abcb36837ac72bee", "filename": "gcc/testsuite/gfortran.dg/associate_5.f03", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+\n+! PR fortran/38936\n+! Check for errors with ASSOCIATE during resolution.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  ASSOCIATE (a => 5) ! { dg-error \"is used as array\" }\n+    PRINT *, a(3)\n+  END ASSOCIATE\n+END PROGRAM main"}, {"sha": "bf30fa3f7cb2118a8277b4565aeecb89e382b2d4", "filename": "gcc/testsuite/gfortran.dg/associate_6.f03", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bf62f96ba3f69fcd35251624d6767299331b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_6.f03?ref=52bf62f96ba3f69fcd35251624d6767299331b4a", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003 -fdump-tree-original\" }\n+\n+! PR fortran/38936\n+! Check that array expression association (with correct bounds) works for\n+! complicated expressions.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+! FIXME: XFAIL'ed because this is not yet implemented 'correctly'.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+CONTAINS\n+\n+  PURE FUNCTION func (n)\n+    INTEGER, INTENT(IN) :: n\n+    INTEGER :: func(2 : n+1)\n+\n+    INTEGER :: i\n+\n+    func = (/ (i, i = 1, n) /)\n+  END FUNCTION func\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE :: m\n+  IMPLICIT NONE\n+\n+  ASSOCIATE (arr => func (4))\n+    ! func should only be called once here, not again for the bounds!\n+  END ASSOCIATE\n+END PROGRAM main\n+! { dg-final { cleanup-modules \"m\" } }\n+! { dg-final { scan-tree-dump-times \"func\" 2 \"original\" { xfail *-*-* } } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}