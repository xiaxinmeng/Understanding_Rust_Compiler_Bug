{"sha": "5127244e4b172a5af7de329c0609971f8e181996", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyNzI0NGU0YjE3MmE1YWY3ZGUzMjljMDYwOTk3MWY4ZTE4MTk5Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2012-11-26T23:53:29Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2012-11-26T23:53:29Z"}, "message": "re PR libstdc++/55463 (Result of std::mem_fn doesn't accept rvalues)\n\n\tPR libstdc++/55463\n\t* include/std/functional (_Mem_fn): Handle rvalue objects. Add\n\tnoexcept-specifications.\n\t* testsuite/20_util/function_objects/mem_fn/55463.cc: New.\n\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error line numbers.\n\nFrom-SVN: r193831", "tree": {"sha": "e63432f06a8153d7c527151da675b30af7fd1b7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e63432f06a8153d7c527151da675b30af7fd1b7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5127244e4b172a5af7de329c0609971f8e181996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5127244e4b172a5af7de329c0609971f8e181996", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5127244e4b172a5af7de329c0609971f8e181996", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5127244e4b172a5af7de329c0609971f8e181996/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5b8b24b128073c2a119a9ba330b3fb7be18caa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b8b24b128073c2a119a9ba330b3fb7be18caa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5b8b24b128073c2a119a9ba330b3fb7be18caa6"}], "stats": {"total": 268, "additions": 185, "deletions": 83}, "files": [{"sha": "f7f43fefef6fe135d95fcebe224c53d037591356", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5127244e4b172a5af7de329c0609971f8e181996/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5127244e4b172a5af7de329c0609971f8e181996/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5127244e4b172a5af7de329c0609971f8e181996", "patch": "@@ -1,3 +1,11 @@\n+2012-11-26  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/55463\n+\t* include/std/functional (_Mem_fn): Handle rvalue objects. Add\n+\tnoexcept-specifications.\n+\t* testsuite/20_util/function_objects/mem_fn/55463.cc: New.\n+\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error line numbers.\n+\n 2012-11-23  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/52680"}, {"sha": "1a98127f4e2c8ca5dde30b0192a1463c550f547a", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 95, "deletions": 79, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5127244e4b172a5af7de329c0609971f8e181996/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5127244e4b172a5af7de329c0609971f8e181996/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=5127244e4b172a5af7de329c0609971f8e181996", "patch": "@@ -65,7 +65,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class _Mem_fn;\n   template<typename _Tp, typename _Class>\n     _Mem_fn<_Tp _Class::*>\n-    mem_fn(_Tp _Class::*);\n+    mem_fn(_Tp _Class::*) noexcept;\n \n _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n@@ -528,13 +528,16 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       template<typename _Tp>\n \t_Res\n-\t_M_call(_Tp& __object, const volatile _Class *,\n+\t_M_call(_Tp&& __object, const volatile _Class *,\n \t\t_ArgTypes... __args) const\n-\t{ return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t{\n+\t  return (std::forward<_Tp>(__object).*__pmf)\n+\t    (std::forward<_ArgTypes>(__args)...);\n+\t}\n \n       template<typename _Tp>\n \t_Res\n-\t_M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+\t_M_call(_Tp&& __ptr, const volatile void *, _ArgTypes... __args) const\n \t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n     public:\n@@ -555,12 +558,17 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n \t_Res\n-\toperator()(_Tp& __object, _ArgTypes... __args) const\n+\toperator()(_Tp&& __object, _ArgTypes... __args) const\n \t{\n-\t  return _M_call(__object, &__object,\n+\t  return _M_call(std::forward<_Tp>(__object), &__object,\n \t      std::forward<_ArgTypes>(__args)...);\n \t}\n \n+      template<typename _Tp>\n+\t_Res\n+\toperator()(reference_wrapper<_Tp> __ref, _ArgTypes... __args) const\n+\t{ return operator()(__ref.get(), std::forward<_ArgTypes>(__args)...); }\n+\n     private:\n       _Functor __pmf;\n     };\n@@ -575,13 +583,16 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       template<typename _Tp>\n \t_Res\n-\t_M_call(_Tp& __object, const volatile _Class *,\n+\t_M_call(_Tp&& __object, const volatile _Class *,\n \t\t_ArgTypes... __args) const\n-\t{ return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t{\n+\t  return (std::forward<_Tp>(__object).*__pmf)\n+\t    (std::forward<_ArgTypes>(__args)...);\n+\t}\n \n       template<typename _Tp>\n \t_Res\n-\t_M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+\t_M_call(_Tp&& __ptr, const volatile void *, _ArgTypes... __args) const\n \t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n     public:\n@@ -601,12 +612,17 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n-\t_Res operator()(_Tp& __object, _ArgTypes... __args) const\n+\t_Res operator()(_Tp&& __object, _ArgTypes... __args) const\n \t{\n-\t  return _M_call(__object, &__object,\n+\t  return _M_call(std::forward<_Tp>(__object), &__object,\n \t      std::forward<_ArgTypes>(__args)...);\n \t}\n \n+      template<typename _Tp>\n+\t_Res\n+\toperator()(reference_wrapper<_Tp> __ref, _ArgTypes... __args) const\n+\t{ return operator()(__ref.get(), std::forward<_ArgTypes>(__args)...); }\n+\n     private:\n       _Functor __pmf;\n     };\n@@ -621,13 +637,16 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       template<typename _Tp>\n \t_Res\n-\t_M_call(_Tp& __object, const volatile _Class *,\n+\t_M_call(_Tp&& __object, const volatile _Class *,\n \t\t_ArgTypes... __args) const\n-\t{ return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t{\n+\t  return (std::forward<_Tp>(__object).*__pmf)\n+\t    (std::forward<_ArgTypes>(__args)...);\n+\t}\n \n       template<typename _Tp>\n \t_Res\n-\t_M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+\t_M_call(_Tp&& __ptr, const volatile void *, _ArgTypes... __args) const\n \t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n     public:\n@@ -648,12 +667,17 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n \t_Res\n-\toperator()(_Tp& __object, _ArgTypes... __args) const\n+\toperator()(_Tp&& __object, _ArgTypes... __args) const\n \t{\n-\t  return _M_call(__object, &__object,\n+\t  return _M_call(std::forward<_Tp>(__object), &__object,\n \t      std::forward<_ArgTypes>(__args)...);\n \t}\n \n+      template<typename _Tp>\n+\t_Res\n+\toperator()(reference_wrapper<_Tp> __ref, _ArgTypes... __args) const\n+\t{ return operator()(__ref.get(), std::forward<_ArgTypes>(__args)...); }\n+\n     private:\n       _Functor __pmf;\n     };\n@@ -668,13 +692,16 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       template<typename _Tp>\n \t_Res\n-\t_M_call(_Tp& __object, const volatile _Class *,\n+\t_M_call(_Tp&& __object, const volatile _Class *,\n \t\t_ArgTypes... __args) const\n-\t{ return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t{\n+\t  return (std::forward<_Tp>(__object).*__pmf)\n+\t    (std::forward<_ArgTypes>(__args)...);\n+\t}\n \n       template<typename _Tp>\n \t_Res\n-\t_M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+\t_M_call(_Tp&& __ptr, const volatile void *, _ArgTypes... __args) const\n \t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n     public:\n@@ -694,12 +721,17 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n-\t_Res operator()(_Tp& __object, _ArgTypes... __args) const\n+\t_Res operator()(_Tp&& __object, _ArgTypes... __args) const\n \t{\n-\t  return _M_call(__object, &__object,\n+\t  return _M_call(std::forward<_Tp>(__object), &__object,\n \t      std::forward<_ArgTypes>(__args)...);\n \t}\n \n+      template<typename _Tp>\n+\t_Res\n+\toperator()(reference_wrapper<_Tp> __ref, _ArgTypes... __args) const\n+\t{ return operator()(__ref.get(), std::forward<_ArgTypes>(__args)...); }\n+\n     private:\n       _Functor __pmf;\n     };\n@@ -720,91 +752,75 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   template<typename _Res, typename _Class>\n     class _Mem_fn<_Res _Class::*>\n     {\n+      using __pm_type = _Res _Class::*;\n+\n       // This bit of genius is due to Peter Dimov, improved slightly by\n       // Douglas Gregor.\n+      // Made less elegant by Jonathan Wakely to support perfect forwarding.\n       template<typename _Tp>\n-\t_Res&\n-\t_M_call(_Tp& __object, _Class *) const\n-\t{ return __object.*__pm; }\n-\n-      template<typename _Tp, typename _Up>\n-\t_Res&\n-\t_M_call(_Tp& __object, _Up * const *) const\n-\t{ return (*__object).*__pm; }\n+\tauto\n+\t_M_call(_Tp&& __object, const _Class *) const noexcept\n+\t-> decltype(std::forward<_Tp>(__object).*std::declval<__pm_type&>())\n+\t{ return std::forward<_Tp>(__object).*__pm; }\n \n       template<typename _Tp, typename _Up>\n-\tconst _Res&\n-\t_M_call(_Tp& __object, const _Up * const *) const\n-\t{ return (*__object).*__pm; }\n-\n-      template<typename _Tp>\n-\tconst _Res&\n-\t_M_call(_Tp& __object, const _Class *) const\n-\t{ return __object.*__pm; }\n+\tauto\n+\t_M_call(_Tp&& __object, _Up * const *) const noexcept\n+\t-> decltype((*std::forward<_Tp>(__object)).*std::declval<__pm_type&>())\n+\t{ return (*std::forward<_Tp>(__object)).*__pm; }\n \n       template<typename _Tp>\n-\tconst _Res&\n-\t_M_call(_Tp& __ptr, const volatile void*) const\n+\tauto\n+\t_M_call(_Tp&& __ptr, const volatile void*) const\n+\tnoexcept(noexcept((*__ptr).*std::declval<__pm_type&>()))\n+\t-> decltype((*__ptr).*std::declval<__pm_type&>())\n \t{ return (*__ptr).*__pm; }\n \n-      template<typename _Tp> static _Tp& __get_ref();\n-\n-      template<typename _Tp>\n-\tstatic __sfinae_types::__one __check_const(_Tp&, _Class*);\n-      template<typename _Tp, typename _Up>\n-\tstatic __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n-      template<typename _Tp, typename _Up>\n-\tstatic __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n-      template<typename _Tp>\n-\tstatic __sfinae_types::__two __check_const(_Tp&, const _Class*);\n-      template<typename _Tp>\n-\tstatic __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n-\n     public:\n-      template<typename _Tp>\n-\tstruct _Result_type\n-\t: _Mem_fn_const_or_non<_Res,\n-\t  (sizeof(__sfinae_types::__two)\n-\t   == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n-\t{ };\n-\n-      template<typename _Signature>\n-\tstruct result;\n-\n-      template<typename _CVMem, typename _Tp>\n-\tstruct result<_CVMem(_Tp)>\n-\t: public _Result_type<_Tp> { };\n-\n-      template<typename _CVMem, typename _Tp>\n-\tstruct result<_CVMem(_Tp&)>\n-\t: public _Result_type<_Tp> { };\n-\n       explicit\n-      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n+      _Mem_fn(_Res _Class::*__pm) noexcept : __pm(__pm) { }\n \n       // Handle objects\n       _Res&\n-      operator()(_Class& __object) const\n+      operator()(_Class& __object) const noexcept\n       { return __object.*__pm; }\n \n       const _Res&\n-      operator()(const _Class& __object) const\n+      operator()(const _Class& __object) const noexcept\n       { return __object.*__pm; }\n \n+      _Res&&\n+      operator()(_Class&& __object) const noexcept\n+      { return std::forward<_Class>(__object).*__pm; }\n+\n+      const _Res&&\n+      operator()(const _Class&& __object) const noexcept\n+      { return std::forward<const _Class>(__object).*__pm; }\n+\n       // Handle pointers\n       _Res&\n-      operator()(_Class* __object) const\n+      operator()(_Class* __object) const noexcept\n       { return __object->*__pm; }\n \n       const _Res&\n-      operator()(const _Class* __object) const\n+      operator()(const _Class* __object) const noexcept\n       { return __object->*__pm; }\n \n       // Handle smart pointers and derived\n       template<typename _Tp>\n-\ttypename _Result_type<_Tp>::type\n-\toperator()(_Tp& __unknown) const\n-\t{ return _M_call(__unknown, &__unknown); }\n+\tauto\n+\toperator()(_Tp&& __unknown) const\n+\tnoexcept(noexcept(std::declval<_Mem_fn*>()->_M_call\n+\t\t\t  (std::forward<_Tp>(__unknown), &__unknown)))\n+\t-> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))\n+\t{ return _M_call(std::forward<_Tp>(__unknown), &__unknown); }\n+\n+      template<typename _Tp>\n+\tauto\n+\toperator()(reference_wrapper<_Tp> __ref) const\n+\tnoexcept(noexcept(std::declval<_Mem_fn&>()(__ref.get())))\n+\t-> decltype((*this)(__ref.get()))\n+\t{ return operator()(__ref.get()); }\n \n     private:\n       _Res _Class::*__pm;\n@@ -819,7 +835,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    */\n   template<typename _Tp, typename _Class>\n     inline _Mem_fn<_Tp _Class::*>\n-    mem_fn(_Tp _Class::* __pm)\n+    mem_fn(_Tp _Class::* __pm) noexcept\n     {\n       return _Mem_fn<_Tp _Class::*>(__pm);\n     }"}, {"sha": "c7f605ef67f31fc0608dda8de3ca1a22a946f1b0", "filename": "libstdc++-v3/testsuite/20_util/bind/ref_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5127244e4b172a5af7de329c0609971f8e181996/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5127244e4b172a5af7de329c0609971f8e181996/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc?ref=5127244e4b172a5af7de329c0609971f8e181996", "patch": "@@ -30,10 +30,10 @@ void test01()\n {\n   const int dummy = 0;\n   std::bind(&inc, _1)(0);               // { dg-error  \"no match\" }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1208 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1222 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1236 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1250 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1224 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1238 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1252 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1266 }\n   std::bind(&inc, std::ref(dummy))();\t// { dg-error  \"no match\" }\n }\n "}, {"sha": "5adce1b7ccabd82df4d6b773d9d54b9aafb972be", "filename": "libstdc++-v3/testsuite/20_util/function_objects/mem_fn/55463.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5127244e4b172a5af7de329c0609971f8e181996/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5127244e4b172a5af7de329c0609971f8e181996/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc?ref=5127244e4b172a5af7de329c0609971f8e181996", "patch": "@@ -0,0 +1,78 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// PR libstdc++/55463 Passing rvalue objects to std::mem_fn\n+\n+#include <functional>\n+\n+struct X\n+{\n+  int& func();\n+  char& func_c() const;\n+  short& func_v() volatile;\n+  double& func_cv() const volatile;\n+\n+  int data;\n+};\n+\n+using CX = const X;\n+\n+struct smart_ptr\n+{\n+  X& operator*() const;\n+};\n+\n+std::reference_wrapper<X> ref();\n+std::reference_wrapper<const X> cref();\n+\n+void test01()\n+{\n+  int& i1 = std::mem_fn( &X::func )( X() );\n+  int& i2 = std::mem_fn( &X::func )( smart_ptr() );\n+  int& i3 = std::mem_fn( &X::func )( ref() );\n+\n+  char& c1 = std::mem_fn( &X::func_c )( X() );\n+  char& c2 = std::mem_fn( &X::func_c )( CX() );\n+  char& c3 = std::mem_fn( &X::func_c )( smart_ptr() );\n+  char& c4 = std::mem_fn( &X::func_c )( ref() );\n+  char& c5 = std::mem_fn( &X::func_c )( cref() );\n+\n+  short& s1 = std::mem_fn( &X::func_v )( X() );\n+  short& s2 = std::mem_fn( &X::func_v )( smart_ptr() );\n+  short& s3 = std::mem_fn( &X::func_v )( ref() );\n+\n+  double& d1 = std::mem_fn( &X::func_cv )( X() );\n+  double& d2 = std::mem_fn( &X::func_cv )( CX() );\n+  double& d3 = std::mem_fn( &X::func_cv )( smart_ptr() );\n+  double& d4 = std::mem_fn( &X::func_cv )( ref() );\n+  double& d5 = std::mem_fn( &X::func_cv )( cref() );\n+\n+  // [expr.mptr.oper]\n+  // The result of a .* expression whose second operand is a pointer to a\n+  // data member is of the same value category (3.10) as its first operand.\n+  int&& rval = std::mem_fn( &X::data )( X() );\n+  const int&& crval = std::mem_fn( &X::data )( CX() );\n+\n+  int& sval = std::mem_fn( &X::data )( smart_ptr() );\n+\n+  int& val = std::mem_fn( &X::data )( ref() );\n+  const int& cval = std::mem_fn( &X::data )( cref() );\n+}\n+"}]}