{"sha": "e26ceb284367fff654268a31fcaa5546d42b5fb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI2Y2ViMjg0MzY3ZmZmNjU0MjY4YTMxZmNhYTU1NDZkNDJiNWZiMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-28T01:02:31Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-28T01:02:31Z"}, "message": "(yylex): Handle i together with f or l in float constant.\n\nFrom-SVN: r5501", "tree": {"sha": "c319633d9356c927ffd28ed1e6575c8757cdd3be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c319633d9356c927ffd28ed1e6575c8757cdd3be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e26ceb284367fff654268a31fcaa5546d42b5fb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26ceb284367fff654268a31fcaa5546d42b5fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e26ceb284367fff654268a31fcaa5546d42b5fb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26ceb284367fff654268a31fcaa5546d42b5fb0/comments", "author": null, "committer": null, "parents": [{"sha": "2da63e2ae05e4cf70bc307c4eb741d5865bf3aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da63e2ae05e4cf70bc307c4eb741d5865bf3aa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2da63e2ae05e4cf70bc307c4eb741d5865bf3aa2"}], "stats": {"total": 117, "additions": 78, "deletions": 39}, "files": [{"sha": "fe59c1c130c87890714c56453b067f15822e4225", "filename": "gcc/c-lex.c", "status": "modified", "additions": 78, "deletions": 39, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e26ceb284367fff654268a31fcaa5546d42b5fb0/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e26ceb284367fff654268a31fcaa5546d42b5fb0/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=e26ceb284367fff654268a31fcaa5546d42b5fb0", "patch": "@@ -1477,47 +1477,86 @@ yylex ()\n \t      }\n \t    else\n \t      {\n+\t\tint fflag = 0, lflag = 0;\n+\t\t/* Copy token_buffer now, while it has just the number\n+\t\t   and not the suffixes; once we add `f' or `i',\n+\t\t   REAL_VALUE_ATOF may not work any more.  */\n+\t\tchar *copy = (char *) alloca (p - token_buffer + 1);\n+\t\tbcopy (token_buffer, copy, p - token_buffer + 1);\n+\n \t\tset_float_handler (handler);\n \n-/* The second argument, machine_mode, of REAL_VALUE_ATOF tells the\n-   desired precision of the binary result of decimal-to-binary conversion.  */\n+\t\twhile (1)\n+\t\t  {\n+\t\t    int lose = 0;\n \n-\t    /* Read the suffixes to choose a data type.  */\n-\t    switch (c)\n-\t      {\n-\t      case 'f': case 'F':\n-\t\ttype = float_type_node;\n-\t\tvalue = REAL_VALUE_ATOF (token_buffer, TYPE_MODE (type));\n-\t\tif (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t    && REAL_VALUE_ISINF (value) && pedantic)\n-\t\t  pedwarn (\"floating point number exceeds range of `float'\");\n-\t\tgarbage_chars = -1;\n-\t\tbreak;\n-\n-\t      case 'l': case 'L':\n-\t\ttype = long_double_type_node;\n-\t\tvalue = REAL_VALUE_ATOF (token_buffer, TYPE_MODE (type));\n-\t\tif (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t    && REAL_VALUE_ISINF (value) && pedantic)\n-\t\t  pedwarn (\n-\t\t      \"floating point number exceeds range of `long double'\");\n-\t\tgarbage_chars = -1;\n-\t\tbreak;\n-\n-\t      case 'i': case 'I':\n-\t\tif (imag)\n-\t\t  error (\"more than one `i' or `j' in numeric constant\");\n-\t\timag = 1;\n-\t\tgarbage_chars = -1;\n-\t\tbreak;\n-\n-              default:\n-\t\tvalue = REAL_VALUE_ATOF (token_buffer, TYPE_MODE (type));\n-\t\tif (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t    && REAL_VALUE_ISINF (value) && pedantic)\n-\t\t  pedwarn (\"floating point number exceeds range of `double'\");\n-\t      }\n-\t    set_float_handler (NULL_PTR);\n+\t\t    /* Read the suffixes to choose a data type.  */\n+\t\t    switch (c)\n+\t\t      {\n+\t\t      case 'f': case 'F':\n+\t\t\tif (fflag)\n+\t\t\t  error (\"more than one `f' in numeric constant\");\n+\t\t\tfflag = 1;\n+\t\t\tbreak;\n+\n+\t\t      case 'l': case 'L':\n+\t\t\tif (lflag)\n+\t\t\t  error (\"more than one `l' in numeric constant\");\n+\t\t\tlflag = 1;\n+\t\t\tbreak;\n+\n+\t\t      case 'i': case 'I':\n+\t\t\tif (imag)\n+\t\t\t  error (\"more than one `i' or `j' in numeric constant\");\n+\t\t\timag = 1;\n+\t\t\tbreak;\n+\n+\t\t      default:\n+\t\t\tlose = 1;\n+\t\t      }\n+\n+\t\t    if (lose)\n+\t\t      break;\n+\n+\t\t    if (p >= token_buffer + maxtoken - 3)\n+\t\t      p = extend_token_buffer (p);\n+\t\t    *p++ = c;\n+\t\t    *p = 0;\n+\t\t    c = getc (finput);\n+\t\t  }\n+\n+\t\t/* The second argument, machine_mode, of REAL_VALUE_ATOF\n+\t\t   tells the desired precision of the binary result\n+\t\t   of decimal-to-binary conversion.  */\n+\n+\t\tif (fflag)\n+\t\t  {\n+\t\t    if (lflag)\n+\t\t      error (\"both `f' and `l' in floating constant\");\n+\n+\t\t    type = float_type_node;\n+\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n+\t\t\t&& REAL_VALUE_ISINF (value) && pedantic)\n+\t\t      pedwarn (\"floating point number exceeds range of `float'\");\n+\t\t  }\n+\t\telse if (lflag)\n+\t\t  {\n+\t\t    type = long_double_type_node;\n+\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n+\t\t\t&& REAL_VALUE_ISINF (value) && pedantic)\n+\t\t      pedwarn (\"floating point number exceeds range of `long double'\");\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n+\t\t\t&& REAL_VALUE_ISINF (value) && pedantic)\n+\t\t      pedwarn (\"floating point number exceeds range of `double'\");\n+\t\t  }\n+\n+\t\tset_float_handler (NULL_PTR);\n \t    }\n #ifdef ERANGE\n \t    if (errno == ERANGE && !flag_traditional && pedantic)\n@@ -1533,7 +1572,7 @@ yylex ()\n \t\t  }\n \t      }\n #endif\n-\t    /* Note: garbage_chars is -1 if first char is *not* garbage.  */\n+\t    garbage_chars = 0;\n \t    while (isalnum (c) || c == '.' || c == '_'\n \t\t   || (!flag_traditional && (c == '+' || c == '-')\n \t\t       && (p[-1] == 'e' || p[-1] == 'E')))"}]}