{"sha": "2c26cbfd237121530e5f3b74d48de1688e3b31e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyNmNiZmQyMzcxMjE1MzBlNWYzYjc0ZDQ4ZGUxNjg4ZTNiMzFlNg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2007-10-31T13:53:03Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-10-31T13:53:03Z"}, "message": "re PR tree-optimization/32377 (can't determine dependence (source/destination overlap without more than size))\n\n2007-10-31  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/32377\n\t* tree-data-ref.c (compute_overlap_steps_for_affine_univar): Make it\n\twork also for unknown number of iterations.\n\t(analyze_subscript_affine_affine): Clean up.  Don't fail when the \n\tnumber of iterations is not known.\n\n\t* gfortran.dg/vect/pr32377.f90: New.\n\nFrom-SVN: r129797", "tree": {"sha": "2c97541798f28a07f2bb341fe946c30e6172b6d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c97541798f28a07f2bb341fe946c30e6172b6d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c26cbfd237121530e5f3b74d48de1688e3b31e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c26cbfd237121530e5f3b74d48de1688e3b31e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c26cbfd237121530e5f3b74d48de1688e3b31e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c26cbfd237121530e5f3b74d48de1688e3b31e6/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac029795f3fde4f8cf6ea1b48b76a7c7f137bee9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac029795f3fde4f8cf6ea1b48b76a7c7f137bee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac029795f3fde4f8cf6ea1b48b76a7c7f137bee9"}], "stats": {"total": 200, "additions": 94, "deletions": 106}, "files": [{"sha": "e781bd4b094485fa3addc563448943b75be85e03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c26cbfd237121530e5f3b74d48de1688e3b31e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c26cbfd237121530e5f3b74d48de1688e3b31e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c26cbfd237121530e5f3b74d48de1688e3b31e6", "patch": "@@ -1,3 +1,11 @@\n+2007-10-31  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/32377\n+\t* tree-data-ref.c (compute_overlap_steps_for_affine_univar): Make it\n+\twork also for unknown number of iterations.\n+\t(analyze_subscript_affine_affine): Clean up.  Don't fail when the \n+\tnumber of iterations is not known.\n+\n 2007-10-31  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/33779"}, {"sha": "687dd19fc8228af9c345b48624f6bf2f424df5bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c26cbfd237121530e5f3b74d48de1688e3b31e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c26cbfd237121530e5f3b74d48de1688e3b31e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c26cbfd237121530e5f3b74d48de1688e3b31e6", "patch": "@@ -1,3 +1,8 @@\n+2007-10-31  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/32377\n+\t* gfortran.dg/vect/pr32377.f90: New.\n+\t\n 2007-10-31  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/33779"}, {"sha": "624a9ae7e3b0981a65470554552b9c842d25bef1", "filename": "gcc/testsuite/gfortran.dg/vect/pr32377.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c26cbfd237121530e5f3b74d48de1688e3b31e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr32377.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c26cbfd237121530e5f3b74d48de1688e3b31e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr32377.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr32377.f90?ref=2c26cbfd237121530e5f3b74d48de1688e3b31e6", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_float }\n+\n+subroutine s243(ntimes,ld,n,ctime,dtime,a,b,c,d,e,aa,bb,cc)\n+\n+  integer ntimes,ld,n,i,nl\n+  real a(n),b(n),c(n),d(n),e(n),aa(ld,n),bb(ld,n),cc(ld,n)\n+  real t1,t2,chksum,ctime,dtime,cs1d\n+  b(:n-1)= b(:n-1)+(c(:n-1)+e(:n-1))*d(:n-1)\n+  a(:n-1)= b(:n-1)+a(2:n)*d(:n-1)\n+  return\n+end subroutine s243\n+\n+! { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } }\n+! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "17851ee3cd071983d9c989f9b2482c3e6848afd4", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 66, "deletions": 106, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c26cbfd237121530e5f3b74d48de1688e3b31e6/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c26cbfd237121530e5f3b74d48de1688e3b31e6/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=2c26cbfd237121530e5f3b74d48de1688e3b31e6", "patch": "@@ -1819,17 +1819,22 @@ compute_overlap_steps_for_affine_univar (int niter, int step_a, int step_b,\n       step_overlaps_a = step_b / gcd_steps_a_b;\n       step_overlaps_b = step_a / gcd_steps_a_b;\n \n-      tau2 = FLOOR_DIV (niter, step_overlaps_a);\n-      tau2 = MIN (tau2, FLOOR_DIV (niter, step_overlaps_b));\n-      last_conflict = tau2;\n+      if (niter > 0)\n+\t{\n+\t  tau2 = FLOOR_DIV (niter, step_overlaps_a);\n+\t  tau2 = MIN (tau2, FLOOR_DIV (niter, step_overlaps_b));\n+\t  last_conflict = tau2;\n+\t  *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n+\t}\n+      else\n+\t*last_conflicts = chrec_dont_know;\n \n       *overlaps_a = affine_fn_univar (integer_zero_node, dim, \n \t\t\t\t      build_int_cst (NULL_TREE,\n \t\t\t\t\t\t     step_overlaps_a));\n       *overlaps_b = affine_fn_univar (integer_zero_node, dim, \n \t\t\t\t      build_int_cst (NULL_TREE, \n \t\t\t\t\t\t     step_overlaps_b));\n-      *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n     }\n \n   else\n@@ -1985,7 +1990,6 @@ analyze_subscript_affine_affine (tree chrec_a,\n {\n   unsigned nb_vars_a, nb_vars_b, dim;\n   HOST_WIDE_INT init_a, init_b, gamma, gcd_alpha_beta;\n-  HOST_WIDE_INT tau1, tau2;\n   lambda_matrix A, U, S;\n \n   if (eq_evolutions_p (chrec_a, chrec_b))\n@@ -2043,18 +2047,7 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t\t\t\t\t   false);\n \t  niter_b = estimated_loop_iterations_int (get_chrec_loop (chrec_b),\n \t\t\t\t\t\t   false);\n-\t  if (niter_a < 0 || niter_b < 0)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"affine-affine test failed: missing iteration counts.\\n\");\n-\t      *overlaps_a = conflict_fn_not_known ();\n-\t      *overlaps_b = conflict_fn_not_known ();\n-\t      *last_conflicts = chrec_dont_know;\n-\t      goto end_analyze_subs_aa;\n-\t    }\n-\n \t  niter = MIN (niter_a, niter_b);\n-\n \t  step_a = int_cst_value (CHREC_RIGHT (chrec_a));\n \t  step_b = int_cst_value (CHREC_RIGHT (chrec_b));\n \n@@ -2138,31 +2131,7 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t \n \t     | x0 = i0 + i1 * t, \n \t     | y0 = j0 + j1 * t.  */\n-      \n-\t  HOST_WIDE_INT i0, j0, i1, j1;\n-\n-\t  /* X0 and Y0 are the first iterations for which there is a\n-\t     dependence.  X0, Y0 are two solutions of the Diophantine\n-\t     equation: chrec_a (X0) = chrec_b (Y0).  */\n-\t  HOST_WIDE_INT x0, y0;\n-\t  HOST_WIDE_INT niter, niter_a, niter_b;\n-\n-\t  niter_a = estimated_loop_iterations_int (get_chrec_loop (chrec_a),\n-\t\t\t\t\t\t   false);\n-\t  niter_b = estimated_loop_iterations_int (get_chrec_loop (chrec_b),\n-\t\t\t\t\t\t   false);\n-\n-\t  if (niter_a < 0 || niter_b < 0)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"affine-affine test failed: missing iteration counts.\\n\");\n-\t      *overlaps_a = conflict_fn_not_known ();\n-\t      *overlaps_b = conflict_fn_not_known ();\n-\t      *last_conflicts = chrec_dont_know;\n-\t      goto end_analyze_subs_aa;\n-\t    }\n-\n-\t  niter = MIN (niter_a, niter_b);\n+      \t  HOST_WIDE_INT i0, j0, i1, j1;\n \n \t  i0 = U[0][0] * gamma / gcd_alpha_beta;\n \t  j0 = U[0][1] * gamma / gcd_alpha_beta;\n@@ -2179,80 +2148,72 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t      *overlaps_a = conflict_fn_no_dependence ();\n \t      *overlaps_b = conflict_fn_no_dependence ();\n \t      *last_conflicts = integer_zero_node;\n+\t      goto end_analyze_subs_aa;\n \t    }\n \n-\t  else \n+\t  if (i1 > 0 && j1 > 0)\n \t    {\n-\t      if (i1 > 0)\n+\t      HOST_WIDE_INT niter_a = estimated_loop_iterations_int\n+\t\t(get_chrec_loop (chrec_a), false);\n+\t      HOST_WIDE_INT niter_b = estimated_loop_iterations_int\n+\t\t(get_chrec_loop (chrec_b), false);\n+\t      HOST_WIDE_INT niter = MIN (niter_a, niter_b);\n+\n+\t      /* (X0, Y0) is a solution of the Diophantine equation:\n+\t\t \"chrec_a (X0) = chrec_b (Y0)\".  */\n+\t      HOST_WIDE_INT tau1 = MAX (CEIL (-i0, i1),\n+\t\t\t\t\tCEIL (-j0, j1));\n+\t      HOST_WIDE_INT x0 = i1 * tau1 + i0;\n+\t      HOST_WIDE_INT y0 = j1 * tau1 + j0;\n+\n+\t      /* (X1, Y1) is the smallest positive solution of the eq\n+\t\t \"chrec_a (X1) = chrec_b (Y1)\", i.e. this is where the\n+\t\t first conflict occurs.  */\n+\t      HOST_WIDE_INT min_multiple = MIN (x0 / i1, y0 / j1);\n+\t      HOST_WIDE_INT x1 = x0 - i1 * min_multiple;\n+\t      HOST_WIDE_INT y1 = y0 - j1 * min_multiple;\n+\n+\t      if (niter > 0)\n \t\t{\n-\t\t  tau1 = CEIL (-i0, i1);\n-\t\t  tau2 = FLOOR_DIV (niter - i0, i1);\n+\t\t  HOST_WIDE_INT tau2 = MIN (FLOOR_DIV (niter - i0, i1),\n+\t\t\t\t\t    FLOOR_DIV (niter - j0, j1));\n+\t\t  HOST_WIDE_INT last_conflict = tau2 - (x1 - i0)/i1;\n \n-\t\t  if (j1 > 0)\n+\t\t  /* If the overlap occurs outside of the bounds of the\n+\t\t     loop, there is no dependence.  */\n+\t\t  if (x1 > niter || y1 > niter)\n \t\t    {\n-\t\t      int last_conflict, min_multiple;\n-\t\t      tau1 = MAX (tau1, CEIL (-j0, j1));\n-\t\t      tau2 = MIN (tau2, FLOOR_DIV (niter - j0, j1));\n-\n-\t\t      x0 = i1 * tau1 + i0;\n-\t\t      y0 = j1 * tau1 + j0;\n-\n-\t\t      /* At this point (x0, y0) is one of the\n-\t\t\t solutions to the Diophantine equation.  The\n-\t\t\t next step has to compute the smallest\n-\t\t\t positive solution: the first conflicts.  */\n-\t\t      min_multiple = MIN (x0 / i1, y0 / j1);\n-\t\t      x0 -= i1 * min_multiple;\n-\t\t      y0 -= j1 * min_multiple;\n-\n-\t\t      tau1 = (x0 - i0)/i1;\n-\t\t      last_conflict = tau2 - tau1;\n-\n-\t\t      /* If the overlap occurs outside of the bounds of the\n-\t\t\t loop, there is no dependence.  */\n-\t\t      if (x0 > niter || y0  > niter)\n-\t\t\t{\n-\t\t\t  *overlaps_a = conflict_fn_no_dependence ();\n-\t\t\t  *overlaps_b = conflict_fn_no_dependence ();\n-\t\t\t  *last_conflicts = integer_zero_node;\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  *overlaps_a\n-\t\t\t    = conflict_fn (1,\n-\t\t\t\taffine_fn_univar (build_int_cst (NULL_TREE, x0),\n-\t\t\t\t\t\t  1,\n-\t\t\t\t\t\t  build_int_cst (NULL_TREE, i1)));\n-\t\t\t  *overlaps_b\n-\t\t\t    = conflict_fn (1,\n-\t\t\t\taffine_fn_univar (build_int_cst (NULL_TREE, y0),\n-\t\t\t\t\t\t  1,\n-\t\t\t\t\t\t  build_int_cst (NULL_TREE, j1)));\n-\t\t\t  *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n-\t\t\t}\n+\t\t      *overlaps_a = conflict_fn_no_dependence ();\n+\t\t      *overlaps_b = conflict_fn_no_dependence ();\n+\t\t      *last_conflicts = integer_zero_node;\n+\t\t      goto end_analyze_subs_aa;\n \t\t    }\n \t\t  else\n-\t\t    {\n-\t\t      /* FIXME: For the moment, the upper bound of the\n-\t\t\t iteration domain for j is not checked.  */\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n-\t\t      *overlaps_a = conflict_fn_not_known ();\n-\t\t      *overlaps_b = conflict_fn_not_known ();\n-\t\t      *last_conflicts = chrec_dont_know;\n-\t\t    }\n+\t\t    *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n \t\t}\n-\t  \n \t      else\n-\t\t{\n-\t\t  /* FIXME: For the moment, the upper bound of the\n-\t\t     iteration domain for i is not checked.  */\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n-\t\t  *overlaps_a = conflict_fn_not_known ();\n-\t\t  *overlaps_b = conflict_fn_not_known ();\n-\t\t  *last_conflicts = chrec_dont_know;\n-\t\t}\n+\t\t*last_conflicts = chrec_dont_know;\n+\n+\t      *overlaps_a\n+\t\t= conflict_fn (1,\n+\t\t\t       affine_fn_univar (build_int_cst (NULL_TREE, x1),\n+\t\t\t\t\t\t 1,\n+\t\t\t\t\t\t build_int_cst (NULL_TREE, i1)));\n+\t      *overlaps_b\n+\t\t= conflict_fn (1,\n+\t\t\t       affine_fn_univar (build_int_cst (NULL_TREE, y1),\n+\t\t\t\t\t\t 1,\n+\t\t\t\t\t\t build_int_cst (NULL_TREE, j1)));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* FIXME: For the moment, the upper bound of the\n+\t\t iteration domain for i and j is not checked.  */\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n+\t      *overlaps_a = conflict_fn_not_known ();\n+\t      *overlaps_b = conflict_fn_not_known ();\n+\t      *last_conflicts = chrec_dont_know;\n \t    }\n \t}\n       else\n@@ -2264,7 +2225,6 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  *last_conflicts = chrec_dont_know;\n \t}\n     }\n-\n   else\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))"}]}