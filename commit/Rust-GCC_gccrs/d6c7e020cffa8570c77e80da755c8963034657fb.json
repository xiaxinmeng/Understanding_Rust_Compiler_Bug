{"sha": "d6c7e020cffa8570c77e80da755c8963034657fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZjN2UwMjBjZmZhODU3MGM3N2U4MGRhNzU1Yzg5NjMwMzQ2NTdmYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-16T10:33:08Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-16T10:33:08Z"}, "message": "[Ada] Implement new legality rules introduced in C.6(13) by AI12-0128\n\n2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* doc/gnat_rm/implementation_defined_pragmas.rst (VFA): Document\n\textension of the no-aliasing rule to any subcomponent.\n\t* freeze.adb (Freeze_Object_Declaration): Small comment tweak.\n\t(Freeze_Record_Type): Do not deal with delayed aspect\n\tspecifications for components here but...\n\t(Freeze_Entity): ...here instead.\n\t* sem_ch12.adb (Instantiate_Object): Improve wording of errors\n\tgiven for legality rules in C.6(12) and implement the new rule\n\tin C.6(13).\n\t* sem_res.adb (Resolve_Actuals): Likewise.\n\t* sem_prag.adb (Check_Atomic_VFA): New procedure implementing\n\tthe new legality rules in C.6(13).\n\t(Process_Atomic_Independent_Shared_Volatile): Call\n\tCheck_Atomic_VFA to check the legality rules.  Factor out code\n\tmarking types into...\n\t(Mark_Type): ...this new procedure.\n\t(Check_VFA_Conflicts): Do not check the legality rules here.\n\t(Pragma_Atomic_Components): Call Check_Atomic_VFA on component\n\ttype.\n\t* sem_util.ads (Is_Subcomponent_Of_Atomic_Object): Declare.\n\t* sem_util.adb (Is_Subcomponent_Of_Atomic_Object): New\n\tpredicate.\n\t* gnat_rm.texi: Regenerate.\n\nFrom-SVN: r279412", "tree": {"sha": "3775aa45161e641db67e8c155cf2b3a4d137d437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3775aa45161e641db67e8c155cf2b3a4d137d437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6c7e020cffa8570c77e80da755c8963034657fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6c7e020cffa8570c77e80da755c8963034657fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6c7e020cffa8570c77e80da755c8963034657fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6c7e020cffa8570c77e80da755c8963034657fb/comments", "author": null, "committer": null, "parents": [{"sha": "070fa48b0a4fbdc754e18962d586f41cc263dad7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070fa48b0a4fbdc754e18962d586f41cc263dad7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070fa48b0a4fbdc754e18962d586f41cc263dad7"}], "stats": {"total": 555, "additions": 394, "deletions": 161}, "files": [{"sha": "58517e6101f05e14a52abb35cc97e0e5460fca82", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -1,3 +1,29 @@\n+2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_pragmas.rst (VFA): Document\n+\textension of the no-aliasing rule to any subcomponent.\n+\t* freeze.adb (Freeze_Object_Declaration): Small comment tweak.\n+\t(Freeze_Record_Type): Do not deal with delayed aspect\n+\tspecifications for components here but...\n+\t(Freeze_Entity): ...here instead.\n+\t* sem_ch12.adb (Instantiate_Object): Improve wording of errors\n+\tgiven for legality rules in C.6(12) and implement the new rule\n+\tin C.6(13).\n+\t* sem_res.adb (Resolve_Actuals): Likewise.\n+\t* sem_prag.adb (Check_Atomic_VFA): New procedure implementing\n+\tthe new legality rules in C.6(13).\n+\t(Process_Atomic_Independent_Shared_Volatile): Call\n+\tCheck_Atomic_VFA to check the legality rules.  Factor out code\n+\tmarking types into...\n+\t(Mark_Type): ...this new procedure.\n+\t(Check_VFA_Conflicts): Do not check the legality rules here.\n+\t(Pragma_Atomic_Components): Call Check_Atomic_VFA on component\n+\ttype.\n+\t* sem_util.ads (Is_Subcomponent_Of_Atomic_Object): Declare.\n+\t* sem_util.adb (Is_Subcomponent_Of_Atomic_Object): New\n+\tpredicate.\n+\t* gnat_rm.texi: Regenerate.\n+\n 2019-12-13  Gary Dismukes  <dismukes@adacore.com>\n \n \t* doc/gnat_rm/implementation_defined_pragmas.rst: Minor"}, {"sha": "42087ade155aa6428b65ec37f0b5ddb2fabc3bdf", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -7443,7 +7443,7 @@ It is not permissible to specify ``Atomic`` and ``Volatile_Full_Access`` for\n the same type or object.\n \n It is not permissible to specify ``Volatile_Full_Access`` for a composite\n-(record or array) type or object that has at least one ``Aliased`` component.\n+(record or array) type or object that has an ``Aliased`` subcomponent.\n \n .. _Pragma-Volatile_Function:\n "}, {"sha": "de5f8f7cdd517441e6b0efcfdac8625c81276182", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -3569,7 +3569,8 @@ package body Freeze is\n             Error_Msg_N (\"\\??use explicit size clause to set size\", E);\n          end if;\n \n-         --  Declaring a too-big array in disabled ghost code is OK\n+         --  Declaring too big an array in disabled ghost code is OK\n+\n          if Is_Array_Type (Typ) and then not Is_Ignored_Ghost_Entity (E) then\n             Check_Large_Modular_Array (Typ);\n          end if;\n@@ -3998,11 +3999,6 @@ package body Freeze is\n          --  clause (used to warn about useless Bit_Order pragmas, and also\n          --  to detect cases where Implicit_Packing may have an effect).\n \n-         Rec_Pushed : Boolean := False;\n-         --  Set True if the record type scope Rec has been pushed on the scope\n-         --  stack. Needed for the analysis of delayed aspects specified to the\n-         --  components of Rec.\n-\n          Sized_Component_Total_RM_Size : Uint := Uint_0;\n          --  Accumulates total RM_Size values of all sized components. Used\n          --  for processing of Implicit_Packing.\n@@ -4141,47 +4137,6 @@ package body Freeze is\n       --  Start of processing for Freeze_Record_Type\n \n       begin\n-         --  Deal with delayed aspect specifications for components. The\n-         --  analysis of the aspect is required to be delayed to the freeze\n-         --  point, thus we analyze the pragma or attribute definition\n-         --  clause in the tree at this point. We also analyze the aspect\n-         --  specification node at the freeze point when the aspect doesn't\n-         --  correspond to pragma/attribute definition clause.\n-\n-         Comp := First_Entity (Rec);\n-         while Present (Comp) loop\n-            if Ekind (Comp) = E_Component\n-              and then Has_Delayed_Aspects (Comp)\n-            then\n-               if not Rec_Pushed then\n-                  Push_Scope (Rec);\n-                  Rec_Pushed := True;\n-\n-                  --  The visibility to the discriminants must be restored in\n-                  --  order to properly analyze the aspects.\n-\n-                  if Has_Discriminants (Rec) then\n-                     Install_Discriminants (Rec);\n-                  end if;\n-               end if;\n-\n-               Analyze_Aspects_At_Freeze_Point (Comp);\n-            end if;\n-\n-            Next_Entity (Comp);\n-         end loop;\n-\n-         --  Pop the scope if Rec scope has been pushed on the scope stack\n-         --  during the delayed aspect analysis process.\n-\n-         if Rec_Pushed then\n-            if Has_Discriminants (Rec) then\n-               Uninstall_Discriminants (Rec);\n-            end if;\n-\n-            Pop_Scope;\n-         end if;\n-\n          --  Freeze components and embedded subtypes\n \n          Comp := First_Entity (Rec);\n@@ -5492,6 +5447,56 @@ package body Freeze is\n       --  In addition, a derived type may have inherited aspects that were\n       --  delayed in the parent, so these must also be captured now.\n \n+      --  For a record type, we deal with the delayed aspect specifications on\n+      --  components first, which is consistent with the non-delayed case and\n+      --  makes it possible to have a single processing to detect conflicts.\n+\n+      if Is_Record_Type (E) then\n+         declare\n+            Comp : Entity_Id;\n+\n+            Rec_Pushed : Boolean := False;\n+            --  Set True if the record type E has been pushed on the scope\n+            --  stack. Needed for the analysis of delayed aspects specified\n+            --  to the components of Rec.\n+\n+         begin\n+            Comp := First_Entity (E);\n+            while Present (Comp) loop\n+               if Ekind (Comp) = E_Component\n+                 and then Has_Delayed_Aspects (Comp)\n+               then\n+                  if not Rec_Pushed then\n+                     Push_Scope (E);\n+                     Rec_Pushed := True;\n+\n+                     --  The visibility to the discriminants must be restored\n+                     --  in order to properly analyze the aspects.\n+\n+                     if Has_Discriminants (E) then\n+                        Install_Discriminants (E);\n+                     end if;\n+                  end if;\n+\n+                  Analyze_Aspects_At_Freeze_Point (Comp);\n+               end if;\n+\n+               Next_Entity (Comp);\n+            end loop;\n+\n+            --  Pop the scope if Rec scope has been pushed on the scope stack\n+            --  during the delayed aspect analysis process.\n+\n+            if Rec_Pushed then\n+               if Has_Discriminants (E) then\n+                  Uninstall_Discriminants (E);\n+               end if;\n+\n+               Pop_Scope;\n+            end if;\n+         end;\n+      end if;\n+\n       if Has_Delayed_Aspects (E)\n         or else May_Inherit_Delayed_Rep_Aspects (E)\n       then"}, {"sha": "6476591028ce5bd00dbd184bcbe213978fce286d", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -8949,7 +8949,7 @@ It is not permissible to specify @code{Atomic} and @code{Volatile_Full_Access} f\n the same type or object.\n \n It is not permissible to specify @code{Volatile_Full_Access} for a composite\n-(record or array) type or object that has at least one @code{Aliased} component.\n+(record or array) type or object that has an @code{Aliased} subcomponent.\n \n @node Pragma Volatile_Function,Pragma Warning_As_Error,Pragma Volatile_Full_Access,Implementation Defined Pragmas\n @anchor{gnat_rm/implementation_defined_pragmas id56}@anchor{11e}@anchor{gnat_rm/implementation_defined_pragmas pragma-volatile-function}@anchor{11f}"}, {"sha": "d405297ef35e01e59ca2ec3f07fceb5456ab3495", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -11111,19 +11111,36 @@ package body Sem_Ch12 is\n \n          Note_Possible_Modification (Actual, Sure => True);\n \n-         --  Check for instantiation of atomic/volatile actual for\n-         --  non-atomic/volatile formal (RM C.6 (12)).\n+         --  Check for instantiation with atomic/volatile object actual for\n+         --  nonatomic/nonvolatile formal (RM C.6 (12)).\n \n          if Is_Atomic_Object (Actual) and then not Is_Atomic (Orig_Ftyp) then\n-            Error_Msg_N\n-              (\"cannot instantiate non-atomic formal object \"\n-               & \"with atomic actual\", Actual);\n+            Error_Msg_NE\n+              (\"cannot instantiate nonatomic formal & of mode in out\",\n+               Actual, Gen_Obj);\n+            Error_Msg_N (\"\\with atomic object actual (RM C.6(12))\", Actual);\n \n          elsif Is_Volatile_Object (Actual) and then not Is_Volatile (Orig_Ftyp)\n          then\n+            Error_Msg_NE\n+              (\"cannot instantiate nonvolatile formal & of mode in out\",\n+               Actual, Gen_Obj);\n+            Error_Msg_N (\"\\with volatile object actual (RM C.6(12))\", Actual);\n+         end if;\n+\n+         --  Check for instantiation on nonatomic subcomponent of an atomic\n+         --  object in Ada 2020 (RM C.6 (13)).\n+\n+         if Ada_Version >= Ada_2020\n+            and then Is_Subcomponent_Of_Atomic_Object (Actual)\n+            and then not Is_Atomic_Object (Actual)\n+         then\n+            Error_Msg_NE\n+              (\"cannot instantiate formal & of mode in out with actual\",\n+               Actual, Gen_Obj);\n             Error_Msg_N\n-              (\"cannot instantiate non-volatile formal object \"\n-               & \"with volatile actual\", Actual);\n+              (\"\\nonatomic subcomponent of atomic object (RM C.6(13))\",\n+               Actual);\n          end if;\n \n       --  Formal in-parameter"}, {"sha": "1b07a842185a9a3efa6963cea1117ad3561347e9", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 247, "deletions": 102, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -3927,6 +3927,10 @@ package body Sem_Prag is\n       procedure Check_At_Most_N_Arguments (N : Nat);\n       --  Check there are no more than N arguments present\n \n+      procedure Check_Atomic_VFA (E : Entity_Id; VFA : Boolean);\n+      --  Apply legality checks to type or object E subject to an Atomic aspect\n+      --  in Ada 2020 (RM C.6(13)) or to a Volatile_Full_Access aspect.\n+\n       procedure Check_Component\n         (Comp            : Node_Id;\n          UU_Typ          : Entity_Id;\n@@ -5680,6 +5684,165 @@ package body Sem_Prag is\n          end if;\n       end Check_At_Most_N_Arguments;\n \n+      ------------------------\n+      --  Check_Atomic_VFA  --\n+      ------------------------\n+\n+      procedure Check_Atomic_VFA (E : Entity_Id; VFA : Boolean) is\n+\n+         Aliased_Subcomponent : exception;\n+         --  Exception raised if an aliased subcomponent is found in E\n+\n+         Independent_Subcomponent : exception;\n+         --  Exception raised if an independent subcomponent is found in E\n+\n+         procedure Check_Subcomponents (Typ : Entity_Id);\n+         --  Apply checks to subcomponents for Atomic and Volatile_Full_Access\n+\n+         -------------------------\n+         -- Check_Subcomponents --\n+         -------------------------\n+\n+         procedure Check_Subcomponents (Typ : Entity_Id) is\n+            Comp : Entity_Id;\n+\n+         begin\n+            if Is_Array_Type (Typ) then\n+               Comp := Component_Type (Typ);\n+\n+               --  For Atomic we accept any atomic subcomponents\n+\n+               if not VFA\n+                 and then (Has_Atomic_Components (Typ)\n+                            or else Is_Atomic (Comp))\n+               then\n+                  null;\n+\n+               --  Give an error if the components are aliased\n+\n+               elsif Has_Aliased_Components (Typ)\n+                 or else Is_Aliased (Comp)\n+               then\n+                  raise Aliased_Subcomponent;\n+\n+               --  For VFA we accept non-aliased VFA subcomponents\n+\n+               elsif VFA\n+                 and then Is_Volatile_Full_Access (Comp)\n+               then\n+                  null;\n+\n+               --  Give an error if the components are independent\n+\n+               elsif Has_Independent_Components (Typ)\n+                  or else Is_Independent (Comp)\n+               then\n+                  raise Independent_Subcomponent;\n+               end if;\n+\n+               --  Recurse on the component type\n+\n+               Check_Subcomponents (Comp);\n+\n+            --  Note: Has_Aliased_Components, like Has_Atomic_Components,\n+            --  and Has_Independent_Components, applies only to arrays.\n+            --  However, this flag does not have a corresponding pragma, so\n+            --  perhaps it should be possible to apply it to record types as\n+            --  well. Should this be done ???\n+\n+            elsif Is_Record_Type (Typ) then\n+               --  It is possible to have an aliased discriminant, so they\n+               --  must be checked along with normal components.\n+\n+               Comp := First_Component_Or_Discriminant (Typ);\n+               while Present (Comp) loop\n+\n+                  --  For Atomic we accept any atomic subcomponents\n+\n+                  if not VFA\n+                    and then (Is_Atomic (Comp)\n+                               or else Is_Atomic (Etype (Comp)))\n+                  then\n+                     null;\n+\n+                  --  Give an error if the component is aliased\n+\n+                  elsif Is_Aliased (Comp)\n+                    or else Is_Aliased (Etype (Comp))\n+                  then\n+                     raise Aliased_Subcomponent;\n+\n+                  --  For VFA we accept non-aliased VFA subcomponents\n+\n+                  elsif VFA\n+                    and then (Is_Volatile_Full_Access (Comp)\n+                               or else Is_Volatile_Full_Access (Etype (Comp)))\n+                  then\n+                     null;\n+\n+                  --  Give an error if the component is independent\n+\n+                  elsif Is_Independent (Comp)\n+                     or else Is_Independent (Etype (Comp))\n+                  then\n+                     raise Independent_Subcomponent;\n+                  end if;\n+\n+                  --  Recurse on the component type\n+\n+                  Check_Subcomponents (Etype (Comp));\n+\n+                  Next_Component_Or_Discriminant (Comp);\n+               end loop;\n+            end if;\n+         end Check_Subcomponents;\n+\n+         Typ : Entity_Id;\n+\n+      begin\n+         --  Fetch the type in case we are dealing with an object or component\n+\n+         if Is_Type (E) then\n+            Typ := E;\n+         else\n+            pragma Assert (Is_Object (E)\n+              or else\n+                Nkind (Declaration_Node (E)) = N_Component_Declaration);\n+\n+            Typ := Etype (E);\n+         end if;\n+\n+         --  Check all the subcomponents of the type recursively, if any\n+\n+         Check_Subcomponents (Typ);\n+\n+      exception\n+         when Aliased_Subcomponent =>\n+            if VFA then\n+               Error_Pragma\n+                 (\"cannot apply Volatile_Full_Access with aliased \"\n+                  & \"subcomponent \");\n+            else\n+               Error_Pragma\n+                 (\"cannot apply Atomic with aliased subcomponent \"\n+                  & \"(RM C.6(13))\");\n+            end if;\n+\n+         when Independent_Subcomponent =>\n+            if VFA then\n+               Error_Pragma\n+                 (\"cannot apply Volatile_Full_Access with independent \"\n+                  & \"subcomponent \");\n+            else\n+               Error_Pragma\n+                 (\"cannot apply Atomic with independent subcomponent \"\n+                  & \"(RM C.6(13))\");\n+            end if;\n+\n+         when others =>\n+            raise Program_Error;\n+      end Check_Atomic_VFA;\n+\n       ---------------------\n       -- Check_Component --\n       ---------------------\n@@ -7260,13 +7423,16 @@ package body Sem_Prag is\n \n       procedure Process_Atomic_Independent_Shared_Volatile is\n          procedure Check_VFA_Conflicts (Ent : Entity_Id);\n-         --  Apply additional checks for the GNAT pragma Volatile_Full_Access\n+         --  Check that Volatile_Full_Access and VFA do not conflict\n \n          procedure Mark_Component_Or_Object (Ent : Entity_Id);\n-         --  Appropriately set flags on the given entity (either an array or\n+         --  Appropriately set flags on the given entity, either an array or\n          --  record component, or an object declaration) according to the\n          --  current pragma.\n \n+         procedure Mark_Type (Ent : Entity_Id);\n+         --  Appropriately set flags on the given entity, a type\n+\n          procedure Set_Atomic_VFA (Ent : Entity_Id);\n          --  Set given type as Is_Atomic or Is_Volatile_Full_Access. Also, if\n          --  no explicit alignment was given, set alignment to unknown, since\n@@ -7282,10 +7448,7 @@ package body Sem_Prag is\n             Typ  : Entity_Id;\n \n             VFA_And_Atomic : Boolean := False;\n-            --  Set True if atomic component present\n-\n-            VFA_And_Aliased : Boolean := False;\n-            --  Set True if aliased component present\n+            --  Set True if both VFA and Atomic present\n \n          begin\n             --  Fetch the type in case we are dealing with an object or\n@@ -7343,48 +7506,6 @@ package body Sem_Prag is\n                      & \"entity\");\n                end if;\n             end if;\n-\n-            --  Check for the application of VFA to an entity that has aliased\n-            --  components.\n-\n-            if Prag_Id = Pragma_Volatile_Full_Access then\n-               if Is_Array_Type (Typ)\n-                 and then Has_Aliased_Components (Typ)\n-               then\n-                  VFA_And_Aliased := True;\n-\n-               --  Note: Has_Aliased_Components, like Has_Atomic_Components,\n-               --  and Has_Independent_Components, applies only to arrays.\n-               --  However, this flag does not have a corresponding pragma, so\n-               --  perhaps it should be possible to apply it to record types as\n-               --  well. Should this be done ???\n-\n-               elsif Is_Record_Type (Typ) then\n-                  --  It is possible to have an aliased discriminant, so they\n-                  --  must be checked along with normal components.\n-\n-                  Comp := First_Component_Or_Discriminant (Typ);\n-                  while Present (Comp) loop\n-                     if Is_Aliased (Comp)\n-                       or else Is_Aliased (Etype (Comp))\n-                     then\n-                        VFA_And_Aliased := True;\n-                        Check_SPARK_05_Restriction\n-                          (\"aliased is not allowed\", Comp);\n-\n-                        exit;\n-                     end if;\n-\n-                     Next_Component_Or_Discriminant (Comp);\n-                  end loop;\n-               end if;\n-\n-               if VFA_And_Aliased then\n-                  Error_Pragma\n-                    (\"cannot apply Volatile_Full_Access (aliased component \"\n-                     & \"present)\");\n-               end if;\n-            end if;\n          end Check_VFA_Conflicts;\n \n          ------------------------------\n@@ -7432,6 +7553,66 @@ package body Sem_Prag is\n             end if;\n          end Mark_Component_Or_Object;\n \n+         ---------------\n+         -- Mark_Type --\n+         ---------------\n+\n+         procedure Mark_Type (Ent : Entity_Id) is\n+         begin\n+            --  Attribute belongs on the base type. If the view of the type is\n+            --  currently private, it also belongs on the underlying type.\n+\n+            if Prag_Id = Pragma_Atomic\n+              or else Prag_Id = Pragma_Shared\n+              or else Prag_Id = Pragma_Volatile_Full_Access\n+            then\n+               Set_Atomic_VFA (Ent);\n+               Set_Atomic_VFA (Base_Type (Ent));\n+               Set_Atomic_VFA (Underlying_Type (Ent));\n+            end if;\n+\n+            --  Atomic/Shared/Volatile_Full_Access imply Independent\n+\n+            if Prag_Id /= Pragma_Volatile then\n+               Set_Is_Independent (Ent);\n+               Set_Is_Independent (Base_Type (Ent));\n+               Set_Is_Independent (Underlying_Type (Ent));\n+\n+               if Prag_Id = Pragma_Independent then\n+                  Record_Independence_Check (N, Base_Type (Ent));\n+               end if;\n+            end if;\n+\n+            --  Atomic/Shared/Volatile_Full_Access imply Volatile\n+\n+            if Prag_Id /= Pragma_Independent then\n+               Set_Is_Volatile (Ent);\n+               Set_Is_Volatile (Base_Type (Ent));\n+               Set_Is_Volatile (Underlying_Type (Ent));\n+\n+               Set_Treat_As_Volatile (Ent);\n+               Set_Treat_As_Volatile (Underlying_Type (Ent));\n+            end if;\n+\n+            --  Apply Volatile to the composite type's individual components,\n+            --  (RM C.6(8/3)).\n+\n+            if Prag_Id = Pragma_Volatile\n+              and then Is_Record_Type (Etype (Ent))\n+            then\n+               declare\n+                  Comp : Entity_Id;\n+               begin\n+                  Comp := First_Component (Ent);\n+                  while Present (Comp) loop\n+                     Mark_Component_Or_Object (Comp);\n+\n+                     Next_Component (Comp);\n+                  end loop;\n+               end;\n+            end if;\n+         end Mark_Type;\n+\n          --------------------\n          -- Set_Atomic_VFA --\n          --------------------\n@@ -7494,58 +7675,7 @@ package body Sem_Prag is\n                Check_First_Subtype (Arg1);\n             end if;\n \n-            --  Attribute belongs on the base type. If the view of the type is\n-            --  currently private, it also belongs on the underlying type.\n-\n-            if Prag_Id = Pragma_Atomic\n-              or else Prag_Id = Pragma_Shared\n-              or else Prag_Id = Pragma_Volatile_Full_Access\n-            then\n-               Set_Atomic_VFA (E);\n-               Set_Atomic_VFA (Base_Type (E));\n-               Set_Atomic_VFA (Underlying_Type (E));\n-            end if;\n-\n-            --  Atomic/Shared/Volatile_Full_Access imply Independent\n-\n-            if Prag_Id /= Pragma_Volatile then\n-               Set_Is_Independent (E);\n-               Set_Is_Independent (Base_Type (E));\n-               Set_Is_Independent (Underlying_Type (E));\n-\n-               if Prag_Id = Pragma_Independent then\n-                  Record_Independence_Check (N, Base_Type (E));\n-               end if;\n-            end if;\n-\n-            --  Atomic/Shared/Volatile_Full_Access imply Volatile\n-\n-            if Prag_Id /= Pragma_Independent then\n-               Set_Is_Volatile (E);\n-               Set_Is_Volatile (Base_Type (E));\n-               Set_Is_Volatile (Underlying_Type (E));\n-\n-               Set_Treat_As_Volatile (E);\n-               Set_Treat_As_Volatile (Underlying_Type (E));\n-            end if;\n-\n-            --  Apply Volatile to the composite type's individual components,\n-            --  (RM C.6(8/3)).\n-\n-            if Prag_Id = Pragma_Volatile\n-              and then Is_Record_Type (Etype (E))\n-            then\n-               declare\n-                  Comp : Entity_Id;\n-               begin\n-                  Comp := First_Component (E);\n-                  while Present (Comp) loop\n-                     Mark_Component_Or_Object (Comp);\n-\n-                     Next_Component (Comp);\n-                  end loop;\n-               end;\n-            end if;\n+            Mark_Type (E);\n \n          --  Deal with the case where the pragma/attribute applies to a\n          --  component or object declaration.\n@@ -7559,15 +7689,27 @@ package body Sem_Prag is\n             end if;\n \n             Mark_Component_Or_Object (E);\n+\n+         --  In other cases give an error\n+\n          else\n             Error_Pragma_Arg (\"inappropriate entity for pragma%\", Arg1);\n          end if;\n \n-         --  Perform the checks needed to assure the proper use of the GNAT\n-         --  pragma Volatile_Full_Access.\n+         --  Check that Volatile_Full_Access and Atomic do not conflict\n \n          Check_VFA_Conflicts (E);\n \n+         --  Check for the application of Atomic or Volatile_Full_Access to\n+         --  an entity that has [nonatomic] aliased, or else specified to be\n+         --  independently addressable, subcomponents.\n+\n+         if (Prag_Id = Pragma_Atomic and then Ada_Version >= Ada_2020)\n+           or else Prag_Id = Pragma_Volatile_Full_Access\n+         then\n+            Check_Atomic_VFA (E, VFA => Prag_Id = Pragma_Volatile_Full_Access);\n+         end if;\n+\n          --  The following check is only relevant when SPARK_Mode is on as\n          --  this is not a standard Ada legality rule. Pragma Volatile can\n          --  only apply to a full type declaration or an object declaration\n@@ -13944,6 +14086,9 @@ package body Sem_Prag is\n                --  Atomic implies both Independent and Volatile\n \n                if Prag_Id = Pragma_Atomic_Components then\n+                  if Ada_Version >= Ada_2020 then\n+                     Check_Atomic_VFA (Component_Type (E), VFA => False);\n+                  end if;\n                   Set_Has_Atomic_Components (E);\n                   Set_Has_Independent_Components (E);\n                end if;"}, {"sha": "2628a5ab8e5d7f1ba4740ca24c1acd50dea564ae", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -4715,7 +4715,7 @@ package body Sem_Res is\n                end if;\n             end if;\n \n-            --  Check bad case of atomic/volatile argument (RM C.6(12))\n+            --  Check illegal cases of atomic/volatile actual (RM C.6(12,13))\n \n             if (Is_By_Reference_Type (Etype (F)) or else Is_Aliased (F))\n               and then Comes_From_Source (N)\n@@ -4724,14 +4724,30 @@ package body Sem_Res is\n                  and then not Is_Atomic (Etype (F))\n                then\n                   Error_Msg_NE\n-                    (\"cannot pass atomic argument to non-atomic formal&\",\n+                    (\"cannot pass atomic object to nonatomic formal&\",\n                      A, F);\n+                  Error_Msg_N\n+                    (\"\\which is passed by reference (RM C.6(12))\", A);\n \n                elsif Is_Volatile_Object (A)\n                  and then not Is_Volatile (Etype (F))\n                then\n                   Error_Msg_NE\n-                    (\"cannot pass volatile argument to non-volatile formal&\",\n+                    (\"cannot pass volatile object to nonvolatile formal&\",\n+                     A, F);\n+                  Error_Msg_N\n+                    (\"\\which is passed by reference (RM C.6(12))\", A);\n+               end if;\n+\n+               if Ada_Version >= Ada_2020\n+                 and then Is_Subcomponent_Of_Atomic_Object (A)\n+                 and then not Is_Atomic_Object (A)\n+               then\n+                  Error_Msg_N\n+                    (\"cannot pass nonatomic subcomponent of atomic object\",\n+                     A);\n+                  Error_Msg_NE\n+                    (\"\\to formal & which is passed by reference (RM C.6(13))\",\n                      A, F);\n                end if;\n             end if;"}, {"sha": "7ed717d696bce57f39cfd2e3cf2afe3c224d6d1f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -17844,6 +17844,26 @@ package body Sem_Util is\n           or else Nkind (N) = N_Procedure_Call_Statement;\n    end Is_Statement;\n \n+   ----------------------------------------\n+   --  Is_Subcomponent_Of_Atomic_Object  --\n+   ----------------------------------------\n+\n+   function Is_Subcomponent_Of_Atomic_Object (N : Node_Id) return Boolean is\n+      R : Node_Id;\n+\n+   begin\n+      R := Get_Referenced_Object (N);\n+      while Nkind_In (R, N_Indexed_Component, N_Selected_Component, N_Slice)\n+      loop\n+         R := Get_Referenced_Object (Prefix (R));\n+         if Is_Atomic_Object (R) then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Is_Subcomponent_Of_Atomic_Object;\n+\n    ---------------------------------------\n    -- Is_Subprogram_Contract_Annotation --\n    ---------------------------------------"}, {"sha": "c156651c22f93ac044281573a3170d910adfbd07", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c7e020cffa8570c77e80da755c8963034657fb/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d6c7e020cffa8570c77e80da755c8963034657fb", "patch": "@@ -1996,6 +1996,10 @@ package Sem_Util is\n    --  the N_Statement_Other_Than_Procedure_Call subtype from Sinfo).\n    --  Note that a label is *not* a statement, and will return False.\n \n+   function Is_Subcomponent_Of_Atomic_Object (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a reference to a subcomponent\n+   --  of an atomic object as per Ada RM C.6(7).\n+\n    function Is_Subprogram_Contract_Annotation (Item : Node_Id) return Boolean;\n    --  Determine whether aspect specification or pragma Item is one of the\n    --  following subprogram contract annotations:"}]}