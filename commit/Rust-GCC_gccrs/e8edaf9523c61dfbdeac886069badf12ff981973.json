{"sha": "e8edaf9523c61dfbdeac886069badf12ff981973", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlZGFmOTUyM2M2MWRmYmRlYWM4ODYwNjliYWRmMTJmZjk4MTk3Mw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-09T21:37:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-09T21:37:54Z"}, "message": "gimple.c (struct type_fixup_s): New struct and VEC type.\n\n2010-07-09  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (struct type_fixup_s): New struct and VEC type.\n\t(gimple_register_type_fixups): New static global.\n\t(gimple_queue_type_fixup): New function.\n\t(gimple_types_compatible_p): Queue type fixups instead of\n\tapplying them here.\n\t(gimple_register_type): Apply queued fixups for the\n\tcanonical type.  Empty the type fixup queue.\n\nFrom-SVN: r162017", "tree": {"sha": "533feb4f30743162230d0e1d9051809002ba4c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/533feb4f30743162230d0e1d9051809002ba4c60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8edaf9523c61dfbdeac886069badf12ff981973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8edaf9523c61dfbdeac886069badf12ff981973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8edaf9523c61dfbdeac886069badf12ff981973", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8edaf9523c61dfbdeac886069badf12ff981973/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "abcb0bd9b755557ddcd5005c4893c465f8fe64b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abcb0bd9b755557ddcd5005c4893c465f8fe64b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abcb0bd9b755557ddcd5005c4893c465f8fe64b0"}], "stats": {"total": 43, "additions": 41, "deletions": 2}, "files": [{"sha": "c557f73089aaaa320aa8dcfd9f6c0b032238c7fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8edaf9523c61dfbdeac886069badf12ff981973/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8edaf9523c61dfbdeac886069badf12ff981973/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8edaf9523c61dfbdeac886069badf12ff981973", "patch": "@@ -1,3 +1,13 @@\n+2010-07-09  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (struct type_fixup_s): New struct and VEC type.\n+\t(gimple_register_type_fixups): New static global.\n+\t(gimple_queue_type_fixup): New function.\n+\t(gimple_types_compatible_p): Queue type fixups instead of\n+\tapplying them here.\n+\t(gimple_register_type): Apply queued fixups for the\n+\tcanonical type.  Empty the type fixup queue.\n+\n 2010-07-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* configure.ac (gcc_cv_as_ix86_rep_lock_prefix): Fix test."}, {"sha": "318b6d80e3a833d0f4850a28a8c44f4de8118c99", "filename": "gcc/gimple.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8edaf9523c61dfbdeac886069badf12ff981973/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8edaf9523c61dfbdeac886069badf12ff981973/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=e8edaf9523c61dfbdeac886069badf12ff981973", "patch": "@@ -3323,6 +3323,26 @@ gimple_compare_field_offset (tree f1, tree f2)\n   return false;\n }\n \n+typedef struct type_fixup_s {\n+    tree context;\n+    tree *incomplete;\n+    tree complete;\n+} type_fixup;\n+DEF_VEC_O(type_fixup);\n+DEF_VEC_ALLOC_O(type_fixup,heap);\n+\n+static VEC(type_fixup, heap) *gimple_register_type_fixups = NULL;\n+\n+static void\n+gimple_queue_type_fixup (tree context, tree *incomplete, tree complete)\n+{\n+  type_fixup f;\n+  f.context = context;\n+  f.incomplete = incomplete;\n+  f.complete = complete;\n+  VEC_safe_push (type_fixup, heap, gimple_register_type_fixups, &f);\n+}\n+\n /* Return 1 iff T1 and T2 are structurally identical.\n    Otherwise, return 0.  */\n \n@@ -3555,9 +3575,9 @@ gimple_types_compatible_p (tree t1, tree t2)\n \t       in one unit and to complete ones in another.  So we\n \t       probably should merge these types only with more context.  */\n \t    if (COMPLETE_TYPE_P (TREE_TYPE (t2)))\n-\t      TREE_TYPE (t1) = TREE_TYPE (t2);\n+\t      gimple_queue_type_fixup (t1, &TREE_TYPE (t1), TREE_TYPE (t2));\n \t    else\n-\t      TREE_TYPE (t2) = TREE_TYPE (t1);\n+\t      gimple_queue_type_fixup (t2, &TREE_TYPE (t2), TREE_TYPE (t1));\n \t    goto same_types;\n \t  }\n \n@@ -4014,11 +4034,14 @@ gimple_register_type (tree t)\n   if (gimple_types == NULL)\n     gimple_types = htab_create (16381, gimple_type_hash, gimple_type_eq, 0);\n \n+  gcc_assert (VEC_empty (type_fixup, gimple_register_type_fixups));\n   slot = htab_find_slot (gimple_types, t, INSERT);\n   if (*slot\n       && *(tree *)slot != t)\n     {\n       tree new_type = (tree) *((tree *) slot);\n+      unsigned i;\n+      type_fixup *f;\n \n       /* Do not merge types with different addressability.  */\n       gcc_assert (TREE_ADDRESSABLE (t) == TREE_ADDRESSABLE (new_type));\n@@ -4070,13 +4093,19 @@ gimple_register_type (tree t)\n \n       TYPE_CANONICAL (t) = new_type;\n       t = new_type;\n+\n+      for (i = 0;\n+\t   VEC_iterate (type_fixup, gimple_register_type_fixups, i, f); ++i)\n+\tif (f->context == t)\n+\t  *(f->incomplete) = f->complete;\n     }\n   else\n     {\n       TYPE_CANONICAL (t) = t;\n       *slot = (void *) t;\n     }\n \n+  VEC_truncate (type_fixup, gimple_register_type_fixups, 0);\n   return t;\n }\n "}]}