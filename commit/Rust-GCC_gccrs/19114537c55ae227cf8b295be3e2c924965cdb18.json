{"sha": "19114537c55ae227cf8b295be3e2c924965cdb18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkxMTQ1MzdjNTVhZTIyN2NmOGIyOTViZTNlMmM5MjQ5NjVjZGIxOA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-08-19T21:34:37Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-08-19T21:34:37Z"}, "message": "langhooks-def.h (LANG_HOOKS_UNSAVE_EXPR_NOW): Remove.\n\n2004-08-19  Eric Christopher  <echristo@redhat.com>\n\n\t* langhooks-def.h (LANG_HOOKS_UNSAVE_EXPR_NOW): Remove.\n\t* langhooks.h (unsave_expr_now): Ditto.\n\t* tree.h (unsave_expr_1): Remove prototype.\n\t(lhd_unsave_expr_now): Rename to unsave_expr_now.\n\t* tree-inline.c (unsave_expr_1): Move here\n\tfrom tree.c. Make static.\n\t(unsave_expr_now): Rename from lhd_unsave_expr_now.\n\t* tree-sra.c: Fix up for rename.\n\t* tree-ssa-copy.c: Ditto.\n\t* tree-eh.c: Ditto.\n\t* tree.c (unsave_expr_1): Move to tree-inline.c.\n\n2004-08-19  Eric Christopher  <echristo@redhat.com>\n\n\t* cp-tree.h (cxx_unsave_expr_now): Delete prototype.\n\t* tree.c (cxx_unsave_expr_now): Delete.\n\t(cp_unsave_r): Ditto.\n\nFrom-SVN: r86277", "tree": {"sha": "88aec2ccf229fd9ceeed5fc48cb4d5e3f6b7c217", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88aec2ccf229fd9ceeed5fc48cb4d5e3f6b7c217"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19114537c55ae227cf8b295be3e2c924965cdb18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19114537c55ae227cf8b295be3e2c924965cdb18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19114537c55ae227cf8b295be3e2c924965cdb18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19114537c55ae227cf8b295be3e2c924965cdb18/comments", "author": null, "committer": null, "parents": [{"sha": "b85058289589ba4346f6881b5f0cba0410299fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85058289589ba4346f6881b5f0cba0410299fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b85058289589ba4346f6881b5f0cba0410299fc0"}], "stats": {"total": 326, "additions": 138, "deletions": 188}, "files": [{"sha": "934128274d7b12563d8bd556cb62125be50c31ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -1,12 +1,26 @@\n+2004-08-19  Eric Christopher  <echristo@redhat.com>\n+\n+\t* langhooks-def.h (LANG_HOOKS_UNSAVE_EXPR_NOW): Remove.\n+\t* langhooks.h (unsave_expr_now): Ditto.\n+\t* tree.h (unsave_expr_1): Remove prototype.\n+\t(lhd_unsave_expr_now): Rename to unsave_expr_now.\n+\t* tree-inline.c (unsave_expr_1): Move here\n+\tfrom tree.c. Make static.\n+\t(unsave_expr_now): Rename from lhd_unsave_expr_now.\n+\t* tree-sra.c: Fix up for rename.\n+\t* tree-ssa-copy.c: Ditto.\n+\t* tree-eh.c: Ditto.\n+\t* tree.c (unsave_expr_1): Move to tree-inline.c.\n+\n 2004-08-19  Caroline Tice  <ctice@apple.com>\n \n        * config/i386/cygming.h (switch_to_section):  Fix typo (change\n        in_unlikely_text_section to in_unlikely_executed_text).\n- \n+\n 2004-08-19  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* vec.h (VEC_lower_bound): New macro.\n-\t\n+\n 2004-08-19  Richard Sandiford  <rsandifo@redhat.com>\n \n \tPR target/16446\n@@ -55,15 +69,15 @@\n \t* params.def (PARAM_INTEGER_SHARE_LIMIT): New.\n \t* params.h (INTEGER_SHARE_LIMIT): New.\n \t* Makefile.in (tree.o, stor-layout.o): Depend on PARAMS_H.\n-\t\n+\n 2004-08-19  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* gimplify.c (gimplify_minimax_expr): Remove.\n \t(gimplify_expr) <MIN_EXPR, MAX_EXPR>: Remove special handling.\n \n 2004-08-19  Dorit Naishlos  <dorit@il.ibm.com>\n \n-\t* tree-vectorizer.c (vect_can_force_dr_alignment_p): Replace \n+\t* tree-vectorizer.c (vect_can_force_dr_alignment_p): Replace\n \tSTACK_BOUDARY with PREFERRED_STACK_BOUNDARY.\n \n 2004-08-19  Mark Mitchell  <mark@codesourcery.com>\n@@ -153,7 +167,7 @@\n \t(divsf3+1, divsf3+2): Change type to frdiv.\n \t* config/mips/sb1.md (ir_sb1_recipsf_2pipes, ir_sb1_recipsf_1pipe,\n \tir_sb1_recipdf_2pipes, ir_sb1_recipdf_1pipe): New.\n-\t\n+\n \t* config/mips/3000.md (r3k_fdiv_single, r3k_fdiv_double): Add frdiv.\n \t* config/mips/4300.md (r4300_fdiv_single, r4300_fdiv_double): Likewise.\n \t* config/mips/4600.md (r4600_fdiv_single, f4600_fdiv_double): Likewise.\n@@ -2604,7 +2618,7 @@\n \t* config/i386/xmmintrin.h: Include <mm_malloc.h>.\n \n 2004-08-03  H.J. Lu  <hongjiu.lu@intel.com>\n-\t    Tanguy Fautr\u00c3\u0083  <tfautre@pandora.be>\n+\t    Tanguy Fautr\u00c3?  <tfautre@pandora.be>\n \n \t* config/i386/pmm_malloc.h: New file.\n "}, {"sha": "79fcaeb42dbc125e4505ba40ea39cf250efb933c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -1,3 +1,9 @@\n+2004-08-19  Eric Christopher  <echristo@redhat.com>\n+\n+\t* cp-tree.h (cxx_unsave_expr_now): Delete prototype.\n+\t* tree.c (cxx_unsave_expr_now): Delete.\n+\t(cp_unsave_r): Ditto.\n+\n 2004-08-19  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/15890\n@@ -16,7 +22,7 @@\n \t* decl.c (finish_enum): Do not copy value node early, copy\n \tlater.\n \t* lex.c (cxx_init): Force null_node to be unique.\n-\t\n+\n 2004-08-19  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c++/17041\n@@ -191,7 +197,7 @@\n \tPR c++/16929\n \t* pt.c (tsubst_default_argument): Clear out current_class_ptr and\n \tcurrent_class_ref while tsubsting.\n-\t\n+\n 2004-08-10  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16971\n@@ -415,7 +421,7 @@\n \tstatic_dtors to ...\n \t(expand_or_defer_fn): ... here.\n \t* tree.c (no_linkage_check): Add relaxed_p parameter.\n-\t\n+\n 2004-07-28  Eric Christopher  <echristo@redhat.com>\n \n \t* cp-lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete."}, {"sha": "382075d87d44ff549f1b7b2a339f1805c0243261", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -126,7 +126,7 @@ struct diagnostic_context;\n      of the base class.\n \n      The BV_VCALL_INDEX of each node, if non-NULL, gives the vtable\n-     index of the vcall offset for this entry.  \n+     index of the vcall offset for this entry.\n \n      The BV_FN is the declaration for the virtual function itself.\n \n@@ -290,8 +290,8 @@ struct tree_overload GTY(())\n    a TEMPLATE_DECL, an OVERLOAD, or a TEMPLATE_ID_EXPR.  */\n #define BASELINK_FUNCTIONS(NODE) \\\n   (((struct tree_baselink*) BASELINK_CHECK (NODE))->functions)\n-/* The BINFO in which the search for the functions indicated by this baselink \n-   began.  This base is used to determine the accessibility of functions \n+/* The BINFO in which the search for the functions indicated by this baselink\n+   began.  This base is used to determine the accessibility of functions\n    selected by overload resolution.  */\n #define BASELINK_ACCESS_BINFO(NODE) \\\n   (((struct tree_baselink*) BASELINK_CHECK (NODE))->access_binfo)\n@@ -987,7 +987,7 @@ struct lang_type_header GTY(())\n struct lang_type_class GTY(())\n {\n   struct lang_type_header h;\n-  \n+\n   unsigned char align;\n \n   unsigned has_mutable : 1;\n@@ -1061,7 +1061,7 @@ struct lang_type_ptrmem GTY(())\n \n struct lang_type GTY(())\n {\n-  union lang_type_u \n+  union lang_type_u\n   {\n     struct lang_type_header GTY((skip (\"\"))) h;\n     struct lang_type_class  GTY((tag (\"1\"))) c;\n@@ -1306,7 +1306,7 @@ struct lang_type GTY(())\n #define CLASSTYPE_ALIGN_UNIT(NODE) \\\n   (CLASSTYPE_ALIGN (NODE) / BITS_PER_UNIT)\n \n-/* True if this a Java interface type, declared with \n+/* True if this a Java interface type, declared with\n    '__attribute__ ((java_interface))'.  */\n #define TYPE_JAVA_INTERFACE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->java_interface)\n \n@@ -1586,13 +1586,13 @@ struct lang_decl GTY(())\n \n   union lang_decl_u4\n     {\n-      struct full_lang_decl \n+      struct full_lang_decl\n       {\n \t/* For a non-thunk function decl, this is a tree list of\n   \t   friendly classes. For a thunk function decl, it is the\n   \t   thunked to function decl.  */\n \ttree befriending_classes;\n-\t\n+\n \t/* For a non-virtual FUNCTION_DECL, this is\n \t   DECL_FRIEND_CONTEXT.  For a virtual FUNCTION_DECL for which\n \t   DECL_THIS_THUNK_P does not hold, this is DECL_THUNKS. Both\n@@ -1603,7 +1603,7 @@ struct lang_decl GTY(())\n \n \t/* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n \ttree cloned_function;\n-\t\n+\n \t/* In a FUNCTION_DECL for which THUNK_P holds, this is\n \t   THUNK_FIXED_OFFSET.  */\n \tHOST_WIDE_INT fixed_offset;\n@@ -1614,13 +1614,13 @@ struct lang_decl GTY(())\n \n \tunsigned u3sel : 1;\n \tunsigned pending_inline_p : 1;\n-\t\n+\n \tunion lang_decl_u3\n \t{\n-\t  struct sorted_fields_type * GTY ((tag (\"0\"), reorder (\"resort_sorted_fields\"))) \n+\t  struct sorted_fields_type * GTY ((tag (\"0\"), reorder (\"resort_sorted_fields\")))\n \t       sorted_fields;\n  \t  struct cp_token_cache * GTY ((tag (\"2\"))) pending_inline_info;\n-\t  struct language_function * GTY ((tag (\"1\"))) \n+\t  struct language_function * GTY ((tag (\"1\")))\n \t       saved_language_function;\n \t} GTY ((desc (\"%1.u3sel + %1.pending_inline_p\"))) u;\n       } GTY ((tag (\"1\"))) f;\n@@ -1646,7 +1646,7 @@ struct lang_decl GTY(())\n    declaration.  Some entities (like a member function in a local\n    class, or a local variable) do not have linkage at all, and this\n    macro should not be used in those cases.\n-   \n+\n    Implementation note: A FUNCTION_DECL without DECL_LANG_SPECIFIC was\n    created by language-independent code, and has C linkage.  Most\n    VAR_DECLs have C++ linkage, and do not have DECL_LANG_SPECIFIC, but\n@@ -1730,7 +1730,7 @@ struct lang_decl GTY(())\n \n /* Perform an action for each clone of FN, if FN is a function with\n    clones.  This macro should be used like:\n-   \n+\n       FOR_EACH_CLONE (clone, fn)\n         { ... }\n \n@@ -1824,14 +1824,14 @@ struct lang_decl GTY(())\n   (TREE_LANG_FLAG_2 (VAR_DECL_CHECK (NODE)))\n \n /* Nonzero for a VAR_DECL that can be used in an integral constant\n-   expression.    \n+   expression.\n \n       [expr.const]\n \n       An integral constant-expression can only involve ... const\n       variables of static or enumeration types initialized with\n       constant expressions ...\n-  \n+\n    The standard does not require that the expression be non-volatile.\n    G++ implements the proposed correction in DR 457.  */\n #define DECL_INTEGRAL_CONSTANT_VAR_P(NODE)\t\t\\\n@@ -2819,7 +2819,7 @@ struct lang_decl GTY(())\n    function, (or be implemented via passing some invisible parameter\n    to the thunked function, which is modified to perform the\n    adjustment just before returning).\n-   \n+\n    A thunk may perform either, or both, of the following operations:\n \n    o Adjust the this or result pointer by a constant offset.\n@@ -2902,7 +2902,7 @@ struct lang_decl GTY(())\n #define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n \n /* An enumeration of the kind of tags that C++ accepts.  */\n-enum tag_types { \n+enum tag_types {\n   none_type = 0, /* Not a tag type.  */\n   record_type,   /* \"struct\" types.  */\n   class_type,    /* \"class\" types.  */\n@@ -2967,8 +2967,8 @@ typedef enum special_function_kind {\n   sfk_conversion           /* A conversion operator.  */\n } special_function_kind;\n \n-/* The various kinds of linkage.  From [basic.link], \n-   \n+/* The various kinds of linkage.  From [basic.link],\n+\n       A name is said to have linkage when it might denote the same\n       object, reference, function, type, template, namespace or value\n       as a name introduced in another scope:\n@@ -3705,7 +3705,7 @@ extern tree poplevel\t\t\t\t(int, int, int);\n extern void insert_block\t\t\t(tree);\n extern tree pushdecl\t\t\t\t(tree);\n extern void cxx_init_decl_processing\t\t(void);\n-enum cp_tree_node_structure_enum cp_tree_node_structure \n+enum cp_tree_node_structure_enum cp_tree_node_structure\n   (union lang_tree_node *);\n extern bool cxx_mark_addressable\t\t(tree);\n extern void cxx_push_function_context\t\t(struct function *);\n@@ -4169,7 +4169,7 @@ extern void check_multiple_declarators          (void);\n extern void qualified_name_lookup_error\t\t(tree, tree, tree);\n extern tree finish_id_expression                (tree, tree, tree,\n \t\t\t\t\t\t cp_id_kind *, tree *,\n-\t\t\t\t\t\t bool, bool, bool *, \n+\t\t\t\t\t\t bool, bool, bool *,\n \t\t\t\t\t\t const char **);\n extern tree finish_typeof\t\t\t(tree);\n extern void finish_decl_cleanup                 (tree, tree);\n@@ -4192,7 +4192,6 @@ extern void lang_check_failed\t\t\t(const char *, int,\n extern tree stabilize_expr\t\t\t(tree, tree *);\n extern void stabilize_call\t\t\t(tree, tree *);\n extern bool stabilize_init\t\t\t(tree, tree *);\n-extern tree cxx_unsave_expr_now\t\t\t(tree);\n extern tree cxx_maybe_build_cleanup\t\t(tree);\n extern void init_tree\t\t\t        (void);\n extern int pod_type_p\t\t\t\t(tree);\n@@ -4291,7 +4290,7 @@ extern tree build_indirect_ref\t\t\t(tree, const char *);\n extern tree build_array_ref\t\t\t(tree, tree);\n extern tree get_member_function_from_ptrfunc\t(tree *, tree);\n extern tree convert_arguments\t\t\t(tree, tree, tree, int);\n-extern tree build_x_binary_op\t\t\t(enum tree_code, tree, tree, \n+extern tree build_x_binary_op\t\t\t(enum tree_code, tree, tree,\n \t\t\t\t\t\t bool *);\n extern tree build_x_unary_op\t\t\t(enum tree_code, tree);\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);"}, {"sha": "cb1f4e33fe80dd1e606ced9cb90bee32c65e2940", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -43,7 +43,6 @@ static hashval_t list_hash_pieces (tree, tree, tree);\n static hashval_t list_hash (const void *);\n static cp_lvalue_kind lvalue_p_1 (tree, int);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n-static tree cp_unsave_r (tree *, int *, void *);\n static tree build_target_expr (tree, tree);\n static tree count_trees_r (tree *, int *, void *);\n static tree verify_stmt_tree_r (tree *, int *, void *);\n@@ -2171,65 +2170,6 @@ mark_local_for_remap_r (tree* tp,\n   return NULL_TREE;\n }\n \n-/* Called via walk_tree when an expression is unsaved.  Using the\n-   splay_tree pointed to by ST (which is really a `splay_tree'),\n-   remaps all local declarations to appropriate replacements.  */\n-\n-static tree\n-cp_unsave_r (tree* tp,\n-             int* walk_subtrees,\n-             void* data)\n-{\n-  splay_tree st = (splay_tree) data;\n-  splay_tree_node n;\n-\n-  /* Only a local declaration (variable or label).  */\n-  if (nonstatic_local_decl_p (*tp))\n-    {\n-      /* Lookup the declaration.  */\n-      n = splay_tree_lookup (st, (splay_tree_key) *tp);\n-\n-      /* If it's there, remap it.  */\n-      if (n)\n-\t*tp = (tree) n->value;\n-    }\n-  else if (TREE_CODE (*tp) == SAVE_EXPR)\n-    remap_save_expr (tp, st, walk_subtrees);\n-  else\n-    {\n-      copy_tree_r (tp, walk_subtrees, NULL);\n-\n-      /* Do whatever unsaving is required.  */\n-      unsave_expr_1 (*tp);\n-    }\n-\n-  /* Keep iterating.  */\n-  return NULL_TREE;\n-}\n-\n-/* Called whenever an expression needs to be unsaved.  */\n-\n-tree\n-cxx_unsave_expr_now (tree tp)\n-{\n-  splay_tree st;\n-\n-  /* Create a splay-tree to map old local variable declarations to new\n-     ones.  */\n-  st = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n-\n-  /* Walk the tree once figuring out what needs to be remapped.  */\n-  walk_tree (&tp, mark_local_for_remap_r, st, NULL);\n-\n-  /* Walk the tree again, copying, remapping, and unsaving.  */\n-  walk_tree (&tp, cp_unsave_r, st, NULL);\n-\n-  /* Clean up.  */\n-  splay_tree_delete (st);\n-\n-  return tp;\n-}\n-\n /* Returns the kind of special function that DECL (a FUNCTION_DECL)\n    is.  Note that sfk_none is zero, so this function can be used as a\n    predicate to test whether or not DECL is a special function.  */"}, {"sha": "06e3c021fd6524c21f2ce99a38788aa74bc5a290", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -107,7 +107,6 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL lhd_do_nothing_t\n #define LANG_HOOKS_STATICP\t\tlhd_staticp\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL lhd_do_nothing_t\n-#define LANG_HOOKS_UNSAVE_EXPR_NOW\tlhd_unsave_expr_now\n #define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME lhd_set_decl_assembler_name\n #define LANG_HOOKS_CAN_USE_BIT_FIELDS_P lhd_can_use_bit_fields_p\n #define LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS false\n@@ -271,7 +270,6 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_MARK_ADDRESSABLE, \\\n   LANG_HOOKS_STATICP, \\\n   LANG_HOOKS_DUP_LANG_SPECIFIC_DECL, \\\n-  LANG_HOOKS_UNSAVE_EXPR_NOW, \\\n   LANG_HOOKS_SET_DECL_ASSEMBLER_NAME, \\\n   LANG_HOOKS_CAN_USE_BIT_FIELDS_P, \\\n   LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS, \\"}, {"sha": "586db387866dd6f5b4370d93b5e2d5ca55fc0284", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -305,11 +305,6 @@ struct lang_hooks\n      DECL_NODE with a newly GC-allocated copy.  */\n   void (*dup_lang_specific_decl) (tree);\n \n-  /* Reset argument so that it can be expanded again.\n-     Modify it in-place so that all the evaluate only once\n-     things are cleared out.  */\n-  tree (*unsave_expr_now) (tree);\n-\n   /* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of\n      thing that the assembler should talk about, set\n      DECL_ASSEMBLER_NAME to an appropriate IDENTIFIER_NODE."}, {"sha": "0ddf849c9ccbd2b06bf4b5403edfd44ec5622f60", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -77,7 +77,7 @@ struct_ptr_hash (const void *a)\n    we get to rtl.  Once we're done with lowering here, if we lose\n    the information there's no way to recover it!\n \n-   (2) There are many more statements that *cannot* throw as \n+   (2) There are many more statements that *cannot* throw as\n    compared to those that can.  We should be saving some amount\n    of space by only allocating memory for those that can throw.  */\n \n@@ -265,7 +265,7 @@ outside_finally_tree (tree start, tree target)\n \n struct leh_state\n {\n-  /* What's \"current\" while constructing the eh region tree.  These \n+  /* What's \"current\" while constructing the eh region tree.  These\n      correspond to variables of the same name in cfun->eh, which we\n      don't have easy access to.  */\n   struct eh_region *cur_region;\n@@ -280,7 +280,7 @@ struct leh_state\n struct leh_tf_state\n {\n   /* Pointer to the TRY_FINALLY node under discussion.  The try_finally_expr\n-     is the original TRY_FINALLY_EXPR.  We need to retain this so that \n+     is the original TRY_FINALLY_EXPR.  We need to retain this so that\n      outside_finally_tree can reliably reference the tree used in the\n      collect_finally_tree data structures.  */\n   tree try_finally_expr;\n@@ -311,7 +311,7 @@ struct leh_tf_state\n      though subsequent transformations may have cleared that flag.  */\n   tree fallthru_label;\n \n-  /* A label that has been registered with except.c to be the \n+  /* A label that has been registered with except.c to be the\n      landing pad for this try block.  */\n   tree eh_label;\n \n@@ -330,7 +330,7 @@ struct leh_tf_state\n static void lower_eh_filter (struct leh_state *, tree *);\n static void lower_eh_constructs_1 (struct leh_state *, tree *);\n \n-/* Comparison function for qsort/bsearch.  We're interested in \n+/* Comparison function for qsort/bsearch.  We're interested in\n    searching goto queue elements for source statements.  */\n \n static int\n@@ -383,7 +383,7 @@ replace_goto_queue_cond_clause (tree *tp, struct leh_tf_state *tf,\n   tsi_link_after (tsi, new, TSI_CONTINUE_LINKING);\n }\n \n-/* The real work of replace_goto_queue.  Returns with TSI updated to \n+/* The real work of replace_goto_queue.  Returns with TSI updated to\n    point to the next statement.  */\n \n static void replace_goto_queue_stmt_list (tree, struct leh_tf_state *);\n@@ -471,7 +471,7 @@ maybe_record_in_goto_queue (struct leh_state *state, tree stmt)\n       {\n \ttree lab = GOTO_DESTINATION (stmt);\n \n-\t/* Computed and non-local gotos do not get processed.  Given \n+\t/* Computed and non-local gotos do not get processed.  Given\n \t   their nature we can neither tell whether we've escaped the\n \t   finally block nor redirect them if we knew.  */\n \tif (TREE_CODE (lab) != LABEL_DECL)\n@@ -480,7 +480,7 @@ maybe_record_in_goto_queue (struct leh_state *state, tree stmt)\n \t/* No need to record gotos that don't leave the try block.  */\n \tif (! outside_finally_tree (lab, tf->try_finally_expr))\n \t  return;\n-  \n+\n \tif (! tf->dest_array)\n \t  {\n \t    VARRAY_TREE_INIT (tf->dest_array, 10, \"dest_array\");\n@@ -520,7 +520,7 @@ maybe_record_in_goto_queue (struct leh_state *state, tree stmt)\n \n   q = &tf->goto_queue[active];\n   tf->goto_queue_active = active + 1;\n-  \n+\n   memset (q, 0, sizeof (*q));\n   q->stmt = stmt;\n   q->index = index;\n@@ -709,7 +709,7 @@ lower_try_finally_dup_block (tree t, struct leh_state *outer_state)\n {\n   tree region = NULL;\n \n-  t = lhd_unsave_expr_now (t);\n+  t = unsave_expr_now (t);\n \n   if (outer_state->tf)\n     region = outer_state->tf->try_finally_expr;\n@@ -731,7 +731,7 @@ lower_try_finally_fallthru_label (struct leh_tf_state *tf)\n       label = create_artificial_label ();\n       tf->fallthru_label = label;\n       if (tf->outer->tf)\n-        record_in_finally_tree (label, tf->outer->tf->try_finally_expr); \n+        record_in_finally_tree (label, tf->outer->tf->try_finally_expr);\n     }\n   return label;\n }\n@@ -752,7 +752,7 @@ lower_try_finally_fallthru_label (struct leh_tf_state *tf)\n \n    where \"fintmp\" is the temporary used in the switch statement generation\n    alternative considered below.  For the nonce, we always choose the first\n-   option. \n+   option.\n \n    THIS_STATE may be null if if this is a try-cleanup, not a try-finally.  */\n \n@@ -937,7 +937,7 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n       append_to_statement_list (x, tf->top_p);\n \n       append_to_statement_list (finally, tf->top_p);\n-      \n+\n       x = build1 (RESX_EXPR, void_type_node,\n \t\t  build_int_cst (NULL_TREE,\n \t\t\t\t get_eh_region_number (tf->region), 0));\n@@ -977,7 +977,7 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n       for (; q < qe; ++q)\n \tdo_goto_redirection (q, finally_label, NULL);\n       replace_goto_queue (tf);\n-      \n+\n       if (VARRAY_TREE (tf->dest_array, 0) == tf->fallthru_label)\n \t{\n \t  /* Reachable by goto to fallthru label only.  Redirect it\n@@ -1284,7 +1284,7 @@ decide_copy_try_finally (int ndests, tree finally)\n \n /* A subroutine of lower_eh_constructs_1.  Lower a TRY_FINALLY_EXPR nodes\n    to a sequence of labels and blocks, plus the exception region trees\n-   that record all the magic.  This is complicated by the need to \n+   that record all the magic.  This is complicated by the need to\n    arrange for the FINALLY block to be executed on all exits.  */\n \n static void\n@@ -1374,7 +1374,7 @@ lower_try_finally (struct leh_state *state, tree *tp)\n }\n \n /* A subroutine of lower_eh_constructs_1.  Lower a TRY_CATCH_EXPR with a\n-   list of CATCH_EXPR nodes to a sequence of labels and blocks, plus the \n+   list of CATCH_EXPR nodes to a sequence of labels and blocks, plus the\n    exception region trees that record all the magic.  */\n \n static void\n@@ -1444,15 +1444,15 @@ lower_eh_filter (struct leh_state *state, tree *tp)\n   struct eh_region *this_region;\n   tree inner = expr_first (TREE_OPERAND (*tp, 1));\n   tree eh_label;\n-  \n+\n   if (EH_FILTER_MUST_NOT_THROW (inner))\n     this_region = gen_eh_region_must_not_throw (state->cur_region);\n   else\n     this_region = gen_eh_region_allowed (state->cur_region,\n \t\t\t\t\t EH_FILTER_TYPES (inner));\n   this_state = *state;\n   this_state.cur_region = this_region;\n-  \n+\n   lower_eh_constructs_1 (&this_state, &TREE_OPERAND (*tp, 0));\n \n   if (!get_eh_region_may_contain_throw (this_region))\n@@ -1568,7 +1568,7 @@ lower_eh_constructs_1 (struct leh_state *state, tree *tp)\n \t  record_stmt_eh_region (state->cur_region, t);\n \t  note_eh_region_may_contain_throw (state->cur_region);\n \n-\t  /* ??? For the benefit of calls.c, converting all this to rtl, \n+\t  /* ??? For the benefit of calls.c, converting all this to rtl,\n \t     we need to record the call expression, not just the outer\n \t     modify statement.  */\n \t  op = get_call_expr_in (t);\n@@ -1647,7 +1647,7 @@ lower_eh_constructs (void)\n   collect_eh_region_array ();\n }\n \n-struct tree_opt_pass pass_lower_eh = \n+struct tree_opt_pass pass_lower_eh =\n {\n   \"eh\",\t\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n@@ -1680,7 +1680,7 @@ make_eh_edge (struct eh_region *region, void *data)\n \n   make_edge (src, dst, EDGE_ABNORMAL | EDGE_EH);\n }\n-  \n+\n void\n make_eh_edges (tree stmt)\n {"}, {"sha": "6f65f0900a8aba3fb43a63c41e15d081154d0000", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -135,6 +135,7 @@ static void remap_block (tree *, inline_data *);\n static tree remap_decls (tree, inline_data *);\n static void copy_bind_expr (tree *, int *, inline_data *);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n+static void unsave_expr_1 (tree);\n static tree unsave_r (tree *, int *, void *);\n static void declare_inline_vars (tree bind_expr, tree vars);\n \n@@ -2370,6 +2371,31 @@ mark_local_for_remap_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+/* Perform any modifications to EXPR required when it is unsaved.  Does\n+   not recurse into EXPR's subtrees.  */\n+\n+static void\n+unsave_expr_1 (tree expr)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+    case TARGET_EXPR:\n+      /* Don't mess with a TARGET_EXPR that hasn't been expanded.\n+         It's OK for this to happen if it was part of a subtree that\n+         isn't immediately expanded, such as operand 2 of another\n+         TARGET_EXPR.  */\n+      if (TREE_OPERAND (expr, 1))\n+\tbreak;\n+\n+      TREE_OPERAND (expr, 1) = TREE_OPERAND (expr, 3);\n+      TREE_OPERAND (expr, 3) = NULL_TREE;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n /* Called via walk_tree when an expression is unsaved.  Using the\n    splay_tree pointed to by ST (which is really a `splay_tree'),\n    remaps all local declarations to appropriate replacements.  */\n@@ -2411,11 +2437,11 @@ unsave_r (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n-/* Default lang hook for \"unsave_expr_now\".  Copies everything in EXPR and\n-   replaces variables, labels and SAVE_EXPRs local to EXPR.  */\n+/* Copies everything in EXPR and replaces variables, labels\n+   and SAVE_EXPRs local to EXPR.  */\n \n tree\n-lhd_unsave_expr_now (tree expr)\n+unsave_expr_now (tree expr)\n {\n   inline_data id;\n "}, {"sha": "e644c35591c68aec0278994435b6ed730f6f0031", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -5,17 +5,17 @@\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n Free Software Foundation; either version 2, or (at your option) any\n later version.\n-   \n+\n GCC is distributed in the hope that it will be useful, but WITHOUT\n ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n for more details.\n-   \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n@@ -52,7 +52,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* This object of this pass is to replace a non-addressable aggregate with a\n    set of independent variables.  Most of the time, all of these variables\n-   will be scalars.  But a secondary objective is to break up larger \n+   will be scalars.  But a secondary objective is to break up larger\n    aggregates into smaller aggregates.  In the process we may find that some\n    bits of the larger aggregate can be deleted as unreferenced.\n \n@@ -405,7 +405,7 @@ sra_elt_hash (const void *x)\n \n   return h;\n }\n-  \n+\n /* Equality function for type SRA_PAIR.  */\n \n static int\n@@ -533,7 +533,7 @@ is_valid_const_index (tree expr)\n   return true;\n }\n \n-/* Create or return the SRA_ELT structure for EXPR if the expression \n+/* Create or return the SRA_ELT structure for EXPR if the expression\n    refers to a scalarizable variable.  */\n \n static struct sra_elt *\n@@ -682,7 +682,7 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \t   index reference inside a loop being overridden by several constant\n \t   index references during loop setup.  It's possible that this could\n \t   be avoided by using dynamic usage counts based on BB trip counts\n-\t   (based on loop analysis or profiling), but that hardly seems worth \n+\t   (based on loop analysis or profiling), but that hardly seems worth\n \t   the effort.  */\n \t/* ??? Hack.  Figure out how to push this into the scan routines\n \t   without duplicating too much code.  */\n@@ -716,7 +716,7 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \n       case BIT_FIELD_REF:\n \t/* A bit field reference (access to *multiple* fields simultaneously)\n-\t   is not currently scalarized.  Consider this an access to the \n+\t   is not currently scalarized.  Consider this an access to the\n \t   complete outer element, to which walk_tree will bring us next.  */\n \tgoto use_all;\n \n@@ -828,7 +828,7 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n \t the function multiple times, and other evil things.  */\n       else if (!lhs_elt->is_scalar && is_gimple_addressable (rhs))\n \tfns->ldst (lhs_elt, rhs, bsi, true);\n-\t\n+\n       /* Otherwise we're being used in some context that requires the\n \t aggregate to be seen as a whole.  Invoke USE.  */\n       else\n@@ -946,7 +946,7 @@ find_candidates_for_sra (void)\n           any_set = true;\n         }\n     }\n- \n+\n   return any_set;\n }\n \n@@ -1294,7 +1294,7 @@ decide_block_copy (struct sra_elt *elt)\n \n \t  full_size = tree_low_cst (size_tree, 1);\n \n-\t  /* ??? What to do here.  If there are two fields, and we've only \n+\t  /* ??? What to do here.  If there are two fields, and we've only\n \t     instantiated one, then instantiating the other is clearly a win.\n \t     If there are a large number of fields then the size of the copy\n \t     is much more of a factor.  */\n@@ -1377,9 +1377,9 @@ decide_instantiations (void)\n \n   if (cleared_any)\n     {\n-      bitmap_operation (sra_candidates, sra_candidates, &done_head, \n+      bitmap_operation (sra_candidates, sra_candidates, &done_head,\n \t\t\tBITMAP_AND_COMPL);\n-      bitmap_operation (needs_copy_in, needs_copy_in, &done_head, \n+      bitmap_operation (needs_copy_in, needs_copy_in, &done_head,\n \t\t\tBITMAP_AND_COMPL);\n     }\n   bitmap_clear (&done_head);\n@@ -1697,7 +1697,7 @@ insert_edge_copies (tree stmt, basic_block bb)\n \t      first_copy = false;\n \t    }\n \t  else\n-\t    bsi_insert_on_edge (e, lhd_unsave_expr_now (stmt));\n+\t    bsi_insert_on_edge (e, unsave_expr_now (stmt));\n \t}\n     }\n }\n@@ -1816,7 +1816,7 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n   else if (lhs_elt->use_block_copy || rhs_elt->use_block_copy)\n     {\n       /* If either side requires a block copy, then sync the RHS back\n-\t to the original structure, leave the original assignment \n+\t to the original structure, leave the original assignment\n \t statement (which will perform the block copy), then load the\n \t LHS values out of its now-updated original structure.  */\n       /* ??? Could perform a modified pair-wise element copy.  That\n@@ -1978,7 +1978,7 @@ scalarize_ldst (struct sra_elt *elt, tree other,\n \n \t  /* Replace the old statement with this new representative.  */\n \t  bsi_replace (bsi, first, true);\n-\t  \n+\n \t  if (!tsi_end_p (tsi))\n \t    {\n \t      /* If any reference would trap, then they all would.  And more\n@@ -2010,7 +2010,7 @@ scalarize_parms (void)\n   size_t i;\n \n   EXECUTE_IF_SET_IN_BITMAP (needs_copy_in, 0, i,\n-    { \n+    {\n       tree var = referenced_var (i);\n       struct sra_elt *elt = lookup_element (NULL, var, NULL, NO_INSERT);\n       generate_copy_inout (elt, true, var, &list);\n@@ -2107,7 +2107,7 @@ gate_sra (void)\n   return flag_tree_sra != 0;\n }\n \n-struct tree_opt_pass pass_sra = \n+struct tree_opt_pass pass_sra =\n {\n   \"sra\",\t\t\t\t/* name */\n   gate_sra,\t\t\t\t/* gate */"}, {"sha": "1a760ecf2eea724dc9ce04641f011feb400935bb", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -70,7 +70,7 @@ may_propagate_copy (tree dest, tree orig)\n   /* FIXME.  GIMPLE is allowing pointer assignments and comparisons of\n      pointers that have different alias sets.  This means that these\n      pointers will have different memory tags associated to them.\n-     \n+\n      If we allow copy propagation in these cases, statements de-referencing\n      the new pointer will now have a reference to a different memory tag\n      with potentially incorrect SSA information.\n@@ -161,7 +161,7 @@ may_propagate_copy (tree dest, tree orig)\n /* Given two SSA_NAMEs pointers ORIG and NEW such that we are copy\n    propagating NEW into ORIG, consolidate aliasing information so that\n    they both share the same memory tags.  */\n-   \n+\n static void\n merge_alias_info (tree orig, tree new)\n {\n@@ -191,12 +191,12 @@ merge_alias_info (tree orig, tree new)\n     orig_ann->type_mem_tag = new_ann->type_mem_tag;\n   else if (new_ann->type_mem_tag != orig_ann->type_mem_tag)\n     abort ();\n-}   \n+}\n \n \n /* Common code for propagate_value and replace_exp.\n \n-   Replace use operand OP_P with VAL.  FOR_PROPAGATION indicates if the \n+   Replace use operand OP_P with VAL.  FOR_PROPAGATION indicates if the\n    replacement is done to propagate a value or not.  */\n \n static void\n@@ -220,7 +220,7 @@ replace_exp_1 (use_operand_p op_p, tree val,\n       SET_USE (op_p, val);\n     }\n   else\n-    SET_USE (op_p, lhd_unsave_expr_now (val));\n+    SET_USE (op_p, unsave_expr_now (val));\n }\n \n \n@@ -240,8 +240,8 @@ propagate_value (use_operand_p op_p, tree val)\n /* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n    into the tree pointed by OP_P.\n \n-   Use this version for const/copy propagation when SSA operands are not \n-   available.  It will perform the additional checks to ensure validity of \n+   Use this version for const/copy propagation when SSA operands are not\n+   available.  It will perform the additional checks to ensure validity of\n    the const/copy propagation, but will not update any operand information.\n    Be sure to mark the stmt as modified.  */\n \n@@ -262,7 +262,7 @@ propagate_tree_value (tree *op_p, tree val)\n       *op_p = val;\n     }\n   else\n-    *op_p = lhd_unsave_expr_now (val);\n+    *op_p = unsave_expr_now (val);\n }\n \n "}, {"sha": "cd298e8601398105d2e04d64bc679ecad757b582", "filename": "gcc/tree.c", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -433,7 +433,7 @@ build_int_cst (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n \n   if (!type)\n     type = integer_type_node;\n-  \n+\n   switch (TREE_CODE (type))\n     {\n     case POINTER_TYPE:\n@@ -445,14 +445,14 @@ build_int_cst (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n \t  ix = 0;\n \t}\n       break;\n-      \n+\n     case BOOLEAN_TYPE:\n       /* Cache false or true.  */\n       limit = 2;\n       if (!hi && low < 2)\n \tix = low;\n       break;\n-      \n+\n     case INTEGER_TYPE:\n     case CHAR_TYPE:\n     case OFFSET_TYPE:\n@@ -476,15 +476,15 @@ build_int_cst (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n     default:\n       break;\n     }\n-  \n+\n   if (ix >= 0)\n     {\n       if (!TYPE_CACHED_VALUES_P (type))\n \t{\n \t  TYPE_CACHED_VALUES_P (type) = 1;\n \t  TYPE_CACHED_VALUES (type) = make_tree_vec (limit);\n \t}\n-      \n+\n       t = TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix);\n       if (t)\n \t{\n@@ -496,7 +496,7 @@ build_int_cst (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n \t  return t;\n \t}\n     }\n-  \n+\n   t = make_node (INTEGER_CST);\n \n   TREE_INT_CST_LOW (t) = low;\n@@ -505,7 +505,7 @@ build_int_cst (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n \n   if (ix >= 0)\n     TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) = t;\n-  \n+\n   return t;\n }\n \n@@ -1564,31 +1564,6 @@ tree_node_structure (tree t)\n       abort ();\n     }\n }\n-\n-/* Perform any modifications to EXPR required when it is unsaved.  Does\n-   not recurse into EXPR's subtrees.  */\n-\n-void\n-unsave_expr_1 (tree expr)\n-{\n-  switch (TREE_CODE (expr))\n-    {\n-    case TARGET_EXPR:\n-      /* Don't mess with a TARGET_EXPR that hasn't been expanded.\n-         It's OK for this to happen if it was part of a subtree that\n-         isn't immediately expanded, such as operand 2 of another\n-         TARGET_EXPR.  */\n-      if (TREE_OPERAND (expr, 1))\n-\tbreak;\n-\n-      TREE_OPERAND (expr, 1) = TREE_OPERAND (expr, 3);\n-      TREE_OPERAND (expr, 3) = NULL_TREE;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n \f\n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.  */"}, {"sha": "6c01ab190f6841143831eacfa0011f9e3a71ab6f", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19114537c55ae227cf8b295be3e2c924965cdb18/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=19114537c55ae227cf8b295be3e2c924965cdb18", "patch": "@@ -3203,11 +3203,6 @@ extern int first_rtl_op (enum tree_code);\n \n enum tree_node_structure_enum tree_node_structure (tree);\n \n-/* Reset EXP in place so that it can be expanded again.  Does not\n-   recurse into subtrees.  */\n-\n-extern void unsave_expr_1 (tree);\n-\n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.\n \n@@ -3362,7 +3357,6 @@ extern tree get_set_constructor_bytes (tree, unsigned char *, int);\n extern tree get_callee_fndecl (tree);\n extern void change_decl_assembler_name (tree, tree);\n extern int type_num_arguments (tree);\n-extern tree lhd_unsave_expr_now (tree);\n extern bool associative_tree_code (enum tree_code);\n extern bool commutative_tree_code (enum tree_code);\n \n@@ -3551,6 +3545,9 @@ extern void indent_to (FILE *, int);\n \n /* In tree-inline.c:  */\n extern bool debug_find_tree (tree, tree);\n+/* This is in tree-inline.c since the routine uses\n+   data structures from the inliner.  */\n+extern tree unsave_expr_now (tree);\n \n /* In expr.c */\n extern rtx expand_builtin_return_addr (enum built_in_function, int, rtx);"}]}