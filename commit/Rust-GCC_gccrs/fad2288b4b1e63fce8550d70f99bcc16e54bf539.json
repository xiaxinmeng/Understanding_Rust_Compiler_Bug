{"sha": "fad2288b4b1e63fce8550d70f99bcc16e54bf539", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFkMjI4OGI0YjFlNjNmY2U4NTUwZDcwZjk5YmNjMTZlNTRiZjUzOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:17:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:17:33Z"}, "message": "poly_int: REGMODE_NATURAL_SIZE\n\nThis patch makes target-independent code that uses REGMODE_NATURAL_SIZE\ntreat it as a poly_int rather than a constant.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* combine.c (can_change_dest_mode): Handle polynomial\n\tREGMODE_NATURAL_SIZE.\n\t* expmed.c (store_bit_field_1): Likewise.\n\t* expr.c (store_constructor): Likewise.\n\t* emit-rtl.c (validate_subreg): Operate on polynomial mode sizes\n\tand polynomial REGMODE_NATURAL_SIZE.\n\t(gen_lowpart_common): Likewise.\n\t* reginfo.c (record_subregs_of_mode): Likewise.\n\t* rtlanal.c (read_modify_subreg_p): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256149", "tree": {"sha": "dd8b4417c22587406a00bbac5e052db18aa2d169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd8b4417c22587406a00bbac5e052db18aa2d169"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fad2288b4b1e63fce8550d70f99bcc16e54bf539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad2288b4b1e63fce8550d70f99bcc16e54bf539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad2288b4b1e63fce8550d70f99bcc16e54bf539", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad2288b4b1e63fce8550d70f99bcc16e54bf539/comments", "author": null, "committer": null, "parents": [{"sha": "07626e49a0ad431f8e69fcc472400780f3d98044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07626e49a0ad431f8e69fcc472400780f3d98044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07626e49a0ad431f8e69fcc472400780f3d98044"}], "stats": {"total": 101, "additions": 69, "deletions": 32}, "files": [{"sha": "5cb1c23a070f0009a5318064d426bfa9e07285c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fad2288b4b1e63fce8550d70f99bcc16e54bf539", "patch": "@@ -1,3 +1,17 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (can_change_dest_mode): Handle polynomial\n+\tREGMODE_NATURAL_SIZE.\n+\t* expmed.c (store_bit_field_1): Likewise.\n+\t* expr.c (store_constructor): Likewise.\n+\t* emit-rtl.c (validate_subreg): Operate on polynomial mode sizes\n+\tand polynomial REGMODE_NATURAL_SIZE.\n+\t(gen_lowpart_common): Likewise.\n+\t* reginfo.c (record_subregs_of_mode): Likewise.\n+\t* rtlanal.c (read_modify_subreg_p): Likewise.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "eb02f295c81613b7e150227062bb6f0035bcf655", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=fad2288b4b1e63fce8550d70f99bcc16e54bf539", "patch": "@@ -2477,8 +2477,8 @@ can_change_dest_mode (rtx x, int added_sets, machine_mode mode)\n \n   /* Don't change between modes with different underlying register sizes,\n      since this could lead to invalid subregs.  */\n-  if (REGMODE_NATURAL_SIZE (mode)\n-      != REGMODE_NATURAL_SIZE (GET_MODE (x)))\n+  if (maybe_ne (REGMODE_NATURAL_SIZE (mode),\n+\t\tREGMODE_NATURAL_SIZE (GET_MODE (x))))\n     return false;\n \n   regno = REGNO (x);"}, {"sha": "f2d4940fb4f31ad56675073e74ea47bfda427bc8", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=fad2288b4b1e63fce8550d70f99bcc16e54bf539", "patch": "@@ -894,8 +894,13 @@ bool\n validate_subreg (machine_mode omode, machine_mode imode,\n \t\t const_rtx reg, poly_uint64 offset)\n {\n-  unsigned int isize = GET_MODE_SIZE (imode);\n-  unsigned int osize = GET_MODE_SIZE (omode);\n+  poly_uint64 isize = GET_MODE_SIZE (imode);\n+  poly_uint64 osize = GET_MODE_SIZE (omode);\n+\n+  /* The sizes must be ordered, so that we know whether the subreg\n+     is partial, paradoxical or complete.  */\n+  if (!ordered_p (isize, osize))\n+    return false;\n \n   /* All subregs must be aligned.  */\n   if (!multiple_p (offset, osize))\n@@ -905,7 +910,7 @@ validate_subreg (machine_mode omode, machine_mode imode,\n   if (maybe_ge (offset, isize))\n     return false;\n \n-  unsigned int regsize = REGMODE_NATURAL_SIZE (imode);\n+  poly_uint64 regsize = REGMODE_NATURAL_SIZE (imode);\n \n   /* ??? This should not be here.  Temporarily continue to allow word_mode\n      subregs of anything.  The most common offender is (subreg:SI (reg:DF)).\n@@ -915,7 +920,7 @@ validate_subreg (machine_mode omode, machine_mode imode,\n     ;\n   /* ??? Similarly, e.g. with (subreg:DF (reg:TI)).  Though store_bit_field\n      is the culprit here, and not the backends.  */\n-  else if (osize >= regsize && isize >= osize)\n+  else if (known_ge (osize, regsize) && known_ge (isize, osize))\n     ;\n   /* Allow component subregs of complex and vector.  Though given the below\n      extraction rules, it's not always clear what that means.  */\n@@ -934,7 +939,7 @@ validate_subreg (machine_mode omode, machine_mode imode,\n      (subreg:SI (reg:DF) 0) isn't.  */\n   else if (FLOAT_MODE_P (imode) || FLOAT_MODE_P (omode))\n     {\n-      if (! (isize == osize\n+      if (! (known_eq (isize, osize)\n \t     /* LRA can use subreg to store a floating point value in\n \t\tan integer mode.  Although the floating point and the\n \t\tinteger modes need the same number of hard registers,\n@@ -946,7 +951,7 @@ validate_subreg (machine_mode omode, machine_mode imode,\n     }\n \n   /* Paradoxical subregs must have offset zero.  */\n-  if (osize > isize)\n+  if (maybe_gt (osize, isize))\n     return known_eq (offset, 0U);\n \n   /* This is a normal subreg.  Verify that the offset is representable.  */\n@@ -966,6 +971,12 @@ validate_subreg (machine_mode omode, machine_mode imode,\n       return subreg_offset_representable_p (regno, imode, offset, omode);\n     }\n \n+  /* The outer size must be ordered wrt the register size, otherwise\n+     we wouldn't know at compile time how many registers the outer\n+     mode occupies.  */\n+  if (!ordered_p (osize, regsize))\n+    return false;\n+\n   /* For pseudo registers, we want most of the same checks.  Namely:\n \n      Assume that the pseudo register will be allocated to hard registers\n@@ -976,10 +987,12 @@ validate_subreg (machine_mode omode, machine_mode imode,\n \n      Given that we've already checked the mode and offset alignment,\n      we only have to check subblock subregs here.  */\n-  if (osize < regsize\n+  if (maybe_lt (osize, regsize)\n       && ! (lra_in_progress && (FLOAT_MODE_P (imode) || FLOAT_MODE_P (omode))))\n     {\n-      poly_uint64 block_size = MIN (isize, regsize);\n+      /* It is invalid for the target to pick a register size for a mode\n+\t that isn't ordered wrt to the size of that mode.  */\n+      poly_uint64 block_size = ordered_min (isize, regsize);\n       unsigned int start_reg;\n       poly_uint64 offset_within_reg;\n       if (!can_div_trunc_p (offset, block_size, &start_reg, &offset_within_reg)\n@@ -1518,39 +1531,43 @@ maybe_set_max_label_num (rtx_code_label *x)\n rtx\n gen_lowpart_common (machine_mode mode, rtx x)\n {\n-  int msize = GET_MODE_SIZE (mode);\n-  int xsize;\n+  poly_uint64 msize = GET_MODE_SIZE (mode);\n   machine_mode innermode;\n \n   /* Unfortunately, this routine doesn't take a parameter for the mode of X,\n      so we have to make one up.  Yuk.  */\n   innermode = GET_MODE (x);\n   if (CONST_INT_P (x)\n-      && msize * BITS_PER_UNIT <= HOST_BITS_PER_WIDE_INT)\n+      && known_le (msize * BITS_PER_UNIT,\n+\t\t   (unsigned HOST_WIDE_INT) HOST_BITS_PER_WIDE_INT))\n     innermode = int_mode_for_size (HOST_BITS_PER_WIDE_INT, 0).require ();\n   else if (innermode == VOIDmode)\n     innermode = int_mode_for_size (HOST_BITS_PER_DOUBLE_INT, 0).require ();\n \n-  xsize = GET_MODE_SIZE (innermode);\n-\n   gcc_assert (innermode != VOIDmode && innermode != BLKmode);\n \n   if (innermode == mode)\n     return x;\n \n+  /* The size of the outer and inner modes must be ordered.  */\n+  poly_uint64 xsize = GET_MODE_SIZE (innermode);\n+  if (!ordered_p (msize, xsize))\n+    return 0;\n+\n   if (SCALAR_FLOAT_MODE_P (mode))\n     {\n       /* Don't allow paradoxical FLOAT_MODE subregs.  */\n-      if (msize > xsize)\n+      if (maybe_gt (msize, xsize))\n \treturn 0;\n     }\n   else\n     {\n       /* MODE must occupy no more of the underlying registers than X.  */\n-      unsigned int regsize = REGMODE_NATURAL_SIZE (innermode);\n-      unsigned int mregs = CEIL (msize, regsize);\n-      unsigned int xregs = CEIL (xsize, regsize);\n-      if (mregs > xregs)\n+      poly_uint64 regsize = REGMODE_NATURAL_SIZE (innermode);\n+      unsigned int mregs, xregs;\n+      if (!can_div_away_from_zero_p (msize, regsize, &mregs)\n+\t  || !can_div_away_from_zero_p (xsize, regsize, &xregs)\n+\t  || mregs > xregs)\n \treturn 0;\n     }\n "}, {"sha": "b48248ff722f0c8afed295b688281bbb904fb165", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=fad2288b4b1e63fce8550d70f99bcc16e54bf539", "patch": "@@ -779,7 +779,7 @@ store_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t In the latter case, use subreg on the rhs side, not lhs.  */\n       rtx sub;\n       HOST_WIDE_INT regnum;\n-      HOST_WIDE_INT regsize = REGMODE_NATURAL_SIZE (GET_MODE (op0));\n+      poly_uint64 regsize = REGMODE_NATURAL_SIZE (GET_MODE (op0));\n       if (known_eq (bitnum, 0U)\n \t  && known_eq (bitsize, GET_MODE_BITSIZE (GET_MODE (op0))))\n \t{"}, {"sha": "ab49c559a2b0bc7ceb07a461aea2cc2fe25c48ee", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fad2288b4b1e63fce8550d70f99bcc16e54bf539", "patch": "@@ -6279,8 +6279,8 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t   a constant.  But if more than one register is involved,\n \t   this probably loses.  */\n \telse if (REG_P (target) && TREE_STATIC (exp)\n-\t\t && (GET_MODE_SIZE (GET_MODE (target))\n-\t\t     <= REGMODE_NATURAL_SIZE (GET_MODE (target))))\n+\t\t && known_le (GET_MODE_SIZE (GET_MODE (target)),\n+\t\t\t      REGMODE_NATURAL_SIZE (GET_MODE (target))))\n \t  {\n \t    emit_move_insn (target, CONST0_RTX (GET_MODE (target)));\n \t    cleared = 1;"}, {"sha": "90d25c891d884e676e78d1100689898f503b04b8", "filename": "gcc/reginfo.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=fad2288b4b1e63fce8550d70f99bcc16e54bf539", "patch": "@@ -1294,10 +1294,14 @@ record_subregs_of_mode (rtx subreg, bool partial_def)\n \t subregs will be invalid.\n \n \t This relies on the fact that we've already been passed\n-\t SUBREG with PARTIAL_DEF set to false.  */\n-      unsigned int size = MAX (REGMODE_NATURAL_SIZE (shape.inner_mode),\n-\t\t\t       GET_MODE_SIZE (shape.outer_mode));\n-      gcc_checking_assert (size < GET_MODE_SIZE (shape.inner_mode));\n+\t SUBREG with PARTIAL_DEF set to false.\n+\n+\t The size of the outer mode must ordered wrt the size of the\n+\t inner mode's registers, since otherwise we wouldn't know at\n+\t compile time how many registers the outer mode occupies.  */\n+      poly_uint64 size = MAX (REGMODE_NATURAL_SIZE (shape.inner_mode),\n+\t\t\t      GET_MODE_SIZE (shape.outer_mode));\n+      gcc_checking_assert (known_lt (size, GET_MODE_SIZE (shape.inner_mode)));\n       if (known_ge (shape.offset, size))\n \tshape.offset -= size;\n       else"}, {"sha": "78836edfc85db71f1aab84acbf681bb09f87e23a", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad2288b4b1e63fce8550d70f99bcc16e54bf539/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=fad2288b4b1e63fce8550d70f99bcc16e54bf539", "patch": "@@ -1395,13 +1395,15 @@ modified_in_p (const_rtx x, const_rtx insn)\n bool\n read_modify_subreg_p (const_rtx x)\n {\n-  unsigned int isize, osize;\n   if (GET_CODE (x) != SUBREG)\n     return false;\n-  isize = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n-  osize = GET_MODE_SIZE (GET_MODE (x));\n-  return isize > osize\n-\t && isize > REGMODE_NATURAL_SIZE (GET_MODE (SUBREG_REG (x)));\n+  poly_uint64 isize = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n+  poly_uint64 osize = GET_MODE_SIZE (GET_MODE (x));\n+  poly_uint64 regsize = REGMODE_NATURAL_SIZE (GET_MODE (SUBREG_REG (x)));\n+  /* The inner and outer modes of a subreg must be ordered, so that we\n+     can tell whether they're paradoxical or partial.  */\n+  gcc_checking_assert (ordered_p (isize, osize));\n+  return (maybe_gt (isize, osize) && maybe_gt (isize, regsize));\n }\n \f\n /* Helper function for set_of.  */"}]}