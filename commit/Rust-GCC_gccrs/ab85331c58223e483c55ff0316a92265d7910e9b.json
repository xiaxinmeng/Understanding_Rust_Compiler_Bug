{"sha": "ab85331c58223e483c55ff0316a92265d7910e9b", "node_id": "C_kwDOANBUbNoAKGFiODUzMzFjNTgyMjNlNDgzYzU1ZmYwMzE2YTkyMjY1ZDc5MTBlOWI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-20T20:02:40Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-20T20:02:40Z"}, "message": "c++: memfn lookup consistency in incomplete-class ctx\n\nWhen instantiating a call to a member function of a class template, we\nrepeat the member function lookup in order to obtain the corresponding\npartially instantiated functions.  Within an incomplete-class context\nhowever, we need to be more careful when repeating the lookup because we\ndon't want to introduce later-declared member functions that weren't\nvisible at template definition time.  We're currently not careful enough\nin this respect, which causes us to reject memfn1.C below.\n\nThis patch fixes this issue by making tsubst_baselink filter out from\nthe instantiation-time lookup those member functions that were invisible\nat template definition time.  This is really only necessary within an\nincomplete-class context, so this patch adds a heuristic flag to BASELINK\nto help us avoid needlessly performing this filtering step (which would\nbe a no-op) in complete-class contexts.\n\nThis is also necessary for the ahead-of-time overload set pruning\nimplemented in r12-6075 to be effective for member functions within\nclass templates.\n\ngcc/cp/ChangeLog:\n\n\t* call.c (build_new_method_call): Set\n\tBASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P on the pruned baselink.\n\t* cp-tree.h (BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P): Define.\n\t* pt.c (filter_memfn_lookup): New subroutine of tsubst_baselink.\n\t(tsubst_baselink): Use filter_memfn_lookup on the new lookup\n\tresult when BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P is set on the\n\told baselink.  Remove redundant BASELINK_P check.\n\t* search.c (build_baselink): Set\n\tBASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P appropriately.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/lookup/memfn1.C: New test.\n\t* g++.dg/template/non-dependent16b.C: New test.", "tree": {"sha": "65cc274dfb8bb38d9b45e6e99b5f9eb903ef6f6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65cc274dfb8bb38d9b45e6e99b5f9eb903ef6f6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab85331c58223e483c55ff0316a92265d7910e9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab85331c58223e483c55ff0316a92265d7910e9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab85331c58223e483c55ff0316a92265d7910e9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab85331c58223e483c55ff0316a92265d7910e9b/comments", "author": null, "committer": null, "parents": [{"sha": "b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837"}], "stats": {"total": 154, "additions": 152, "deletions": 2}, "files": [{"sha": "bee367f57d7cf04fba044882d74e124d28c65992", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ab85331c58223e483c55ff0316a92265d7910e9b", "patch": "@@ -11187,6 +11187,7 @@ build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n \t    }\n \t  orig_fns = copy_node (orig_fns);\n \t  BASELINK_FUNCTIONS (orig_fns) = fn;\n+\t  BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P (orig_fns) = true;\n \t}\n \n skip_prune:"}, {"sha": "5fc9e5efdab47fbc0214a5e171d6147af23cd80c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ab85331c58223e483c55ff0316a92265d7910e9b", "patch": "@@ -464,6 +464,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)\n       OVL_USING_P (in OVERLOAD)\n       IMPLICIT_CONV_EXPR_NONTYPE_ARG (in IMPLICIT_CONV_EXPR)\n+      BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P (in BASELINK)\n    2: IDENTIFIER_KIND_BIT_2 (in IDENTIFIER_NODE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n@@ -1060,6 +1061,10 @@ struct GTY(()) tree_template_decl {\n /* Nonzero if this baselink was from a qualified lookup.  */\n #define BASELINK_QUALIFIED_P(NODE) \\\n   TREE_LANG_FLAG_0 (BASELINK_CHECK (NODE))\n+/* Nonzero if the overload set for this baselink might be incomplete due\n+   to the lookup being performed from an incomplete-class context.  */\n+#define BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P(NODE) \\\n+  TREE_LANG_FLAG_1 (BASELINK_CHECK (NODE))\n \n struct GTY(()) tree_baselink {\n   struct tree_common common;"}, {"sha": "a115e1d128c145fc46bb3a55a858d58b0cabe881", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 89, "deletions": 2, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ab85331c58223e483c55ff0316a92265d7910e9b", "patch": "@@ -16221,6 +16221,81 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     }\n }\n \n+/* OLDFNS is a lookup set of member functions from some class template, and\n+   NEWFNS is a lookup set of member functions from a specialization of that\n+   class template.  Return the subset of NEWFNS which are specializations of\n+   a function from OLDFNS.  */\n+\n+static tree\n+filter_memfn_lookup (tree oldfns, tree newfns)\n+{\n+  /* Record all member functions from the old lookup set OLDFNS into\n+     VISIBLE_SET.  */\n+  hash_set<tree> visible_set;\n+  for (tree fn : lkp_range (oldfns))\n+    {\n+      if (TREE_CODE (fn) == USING_DECL)\n+\t{\n+\t  /* FIXME: Punt on (dependent) USING_DECL for now; mapping\n+\t     a dependent USING_DECL to its instantiation seems\n+\t     tricky.  */\n+\t  gcc_checking_assert (DECL_DEPENDENT_P (fn));\n+\t  return newfns;\n+\t}\n+      else if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t/* A member function template.  */\n+\tvisible_set.add (fn);\n+      else if (TREE_CODE (fn) == FUNCTION_DECL)\n+\t{\n+\t  if (DECL_TEMPLATE_INFO (fn))\n+\t    /* A non-template member function.  */\n+\t    visible_set.add (DECL_TI_TEMPLATE (fn));\n+\t  else\n+\t    /* A non-template member function from a non-template base,\n+\t       injected via a using-decl.  */\n+\t    visible_set.add (fn);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  /* Returns true iff (a less specialized version of) FN appeared in\n+     the old lookup set OLDFNS.  */\n+  auto visible_p = [&visible_set] (tree fn) {\n+    if (TREE_CODE (fn) == FUNCTION_DECL\n+\t&& !DECL_TEMPLATE_INFO (fn))\n+      return visible_set.contains (fn);\n+    else if (DECL_TEMPLATE_INFO (fn))\n+      return visible_set.contains (DECL_TI_TEMPLATE (fn));\n+    else\n+      gcc_unreachable ();\n+  };\n+\n+  bool lookup_changed_p = false;\n+  for (tree fn : lkp_range (newfns))\n+    if (!visible_p (fn))\n+      {\n+\tlookup_changed_p = true;\n+\tbreak;\n+      }\n+  if (!lookup_changed_p)\n+    return newfns;\n+\n+  /* Filter out from NEWFNS the member functions that weren't\n+     previously visible according to OLDFNS.  */\n+  tree filtered_fns = NULL_TREE;\n+  unsigned filtered_size = 0;\n+  for (tree fn : lkp_range (newfns))\n+    if (visible_p (fn))\n+      {\n+\tfiltered_fns = lookup_add (fn, filtered_fns);\n+\tfiltered_size++;\n+      }\n+  gcc_checking_assert (filtered_size == visible_set.elements ());\n+\n+  return filtered_fns;\n+}\n+\n /* tsubst a BASELINK.  OBJECT_TYPE, if non-NULL, is the type of the\n    expression on the left-hand side of the \".\" or \"->\" operator.  We\n    only do the lookup if we had a dependent BASELINK.  Otherwise we\n@@ -16274,8 +16349,21 @@ tsubst_baselink (tree baselink, tree object_type,\n \t/* Treat as-if non-dependent below.  */\n \tdependent_p = false;\n \n+      bool maybe_incomplete = BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P (baselink);\n       baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1,\n \t\t\t\t  complain);\n+      if (maybe_incomplete)\n+\t{\n+\t  /* Filter out from the new lookup set those functions which didn't\n+\t     appear in the original lookup set (in a less specialized form).\n+\t     This is needed to preserve the consistency of member lookup\n+\t     performed in an incomplete-class context, within which\n+\t     later-declared members ought to remain invisible.  */\n+\t  BASELINK_FUNCTIONS (baselink)\n+\t    = filter_memfn_lookup (fns, BASELINK_FUNCTIONS (baselink));\n+\t  BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P (baselink) = true;\n+\t}\n+\n       if (!baselink)\n \t{\n \t  if ((complain & tf_error)\n@@ -16285,8 +16373,7 @@ tsubst_baselink (tree baselink, tree object_type,\n \t  return error_mark_node;\n \t}\n \n-      if (BASELINK_P (baselink))\n-\tfns = BASELINK_FUNCTIONS (baselink);\n+      fns = BASELINK_FUNCTIONS (baselink);\n     }\n   else\n     {"}, {"sha": "b673db960e6a90725095ae1c40f593c0efe0724c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ab85331c58223e483c55ff0316a92265d7910e9b", "patch": "@@ -1091,6 +1091,10 @@ build_baselink (tree binfo, tree access_binfo, tree functions, tree optype)\n   BASELINK_FUNCTIONS (baselink) = functions;\n   BASELINK_OPTYPE (baselink) = optype;\n \n+  if (binfo == access_binfo\n+      && TYPE_BEING_DEFINED (BINFO_TYPE (access_binfo)))\n+    BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P (baselink) = true;\n+\n   return baselink;\n }\n "}, {"sha": "8f8e5d9e3d4f694b46341815425e72af289897df", "filename": "gcc/testsuite/g++.dg/lookup/memfn1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmemfn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmemfn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmemfn1.C?ref=ab85331c58223e483c55ff0316a92265d7910e9b", "patch": "@@ -0,0 +1,16 @@\n+// Verify we preserve the consistency of member function lookup outside of a\n+// complete-class context.\n+// { dg-do compile { target c++11 } }\n+\n+template<class...>\n+struct A {\n+  template<class T> static void f();    // #1\n+  template<class T> static auto g() -> decltype(f<T>());\n+  template<class T> static void f(...); // #2\n+};\n+\n+int main() {\n+  A<>::g<int>(); // OK, the later-declared #2 isn't considered when\n+\t\t // instantiating f<T>(), which would have otherwise\n+\t\t // led to ambiguity.\n+}"}, {"sha": "b0d1bbe985a0f19840662c73be59be2d27921a17", "filename": "gcc/testsuite/g++.dg/template/non-dependent16b.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab85331c58223e483c55ff0316a92265d7910e9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16b.C?ref=ab85331c58223e483c55ff0316a92265d7910e9b", "patch": "@@ -0,0 +1,37 @@\n+// Like non-dependent16a.C, but where A is a template.\n+\n+// { dg-do compile { target c++11 } }\n+\n+template<class...>\n+struct A {\n+  template<class T> static void f();\n+  template<class T> static auto f() -> decltype(f<void>(), 1, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 2, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 3, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 4, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 5, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 6, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 7, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 8, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 9, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 10, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 11, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 12, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 13, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 14, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 15, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 16, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 17, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 18, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 19, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 20, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 21, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 22, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 23, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 24, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 25, *T());\n+};\n+\n+int main() {\n+  A<>::f<void>();\n+}"}]}