{"sha": "6542950e80b2ac7edbdba43f5147b15df282012e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU0Mjk1MGU4MGIyYWM3ZWRiZGJhNDNmNTE0N2IxNWRmMjgyMDEyZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-06-08T20:37:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-06-08T20:37:53Z"}, "message": "re PR lto/65378 (Tweak to wording of -Wodr message)\n\n\n\tPR lto/65378\n\t* ipa-utils.h (warn_types_mismatch): Update prototype.\n\t* ipa-devirt.c (odr_types_equivalent_p): Add loc1/loc2\n\tparameters.\n\t(type_mismatch_p): New function.\n\t(warn_types_mismatch): Reorg to work better on non-C++ types.\n\t(odr_types_equivalent_p): Add loc1/loc2 parameters.\n\t(add_type_duplicate): Update.\n\t* lto-symtab.c (warn_type_compatibility_p): Fix call of\n\todr_or_derived_type_p.\n\t(lto_symtab_merge_decls_2): Update call of warn_types_mismatch.\n\nFrom-SVN: r224248", "tree": {"sha": "508f4d43c761a49c59562b9a85f928d521013284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/508f4d43c761a49c59562b9a85f928d521013284"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6542950e80b2ac7edbdba43f5147b15df282012e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6542950e80b2ac7edbdba43f5147b15df282012e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6542950e80b2ac7edbdba43f5147b15df282012e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6542950e80b2ac7edbdba43f5147b15df282012e/comments", "author": null, "committer": null, "parents": [{"sha": "97ded4cd2072029ac4d6d86e5b6eb5225961a27d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97ded4cd2072029ac4d6d86e5b6eb5225961a27d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97ded4cd2072029ac4d6d86e5b6eb5225961a27d"}], "stats": {"total": 301, "additions": 192, "deletions": 109}, "files": [{"sha": "d7f6a8409573c2d2b9863aa4231c3b5ee352a29a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6542950e80b2ac7edbdba43f5147b15df282012e", "patch": "@@ -1,3 +1,14 @@\n+2015-06-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/65378\n+\t* ipa-utils.h (warn_types_mismatch): Update prototype.\n+\t* ipa-devirt.c (odr_types_equivalent_p): Add loc1/loc2\n+\tparameters.\n+\t(type_mismatch_p): New function.\n+\t(warn_types_mismatch): Reorg to work better on non-C++ types.\n+\t(odr_types_equivalent_p): Add loc1/loc2 parameters.\n+\t(add_type_duplicate): Update.\n+\n 2015-06-08  Tom de Vries  <tom@codesourcery.com>\n \n \tPR rtl-optimization/66444"}, {"sha": "aba57e023309027a2db310c34aab5a77e2f437a0", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 167, "deletions": 106, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=6542950e80b2ac7edbdba43f5147b15df282012e", "patch": "@@ -201,7 +201,8 @@ struct pair_traits : default_hashset_traits\n };\n \n static bool odr_types_equivalent_p (tree, tree, bool, bool *,\n-\t\t\t\t    hash_set<type_pair,pair_traits> *);\n+\t\t\t\t    hash_set<type_pair,pair_traits> *,\n+\t\t\t\t    location_t, location_t);\n \n static bool odr_violation_reported = false;\n \n@@ -612,7 +613,8 @@ bool\n types_odr_comparable (tree t1, tree t2, bool strict)\n {\n   return (!in_lto_p\n-\t  || (strict ? main_odr_variant (t1) == main_odr_variant (t2)\n+\t  || (strict ? (main_odr_variant (t1) == main_odr_variant (t2)\n+\t\t\t&& main_odr_variant (t1))\n \t      : TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n \t  || (odr_type_p (t1) && odr_type_p (t2))\n \t  || (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE\n@@ -777,7 +779,8 @@ set_type_binfo (tree type, tree binfo)\n \n static bool\n odr_subtypes_equivalent_p (tree t1, tree t2,\n-\t\t\t   hash_set<type_pair,pair_traits> *visited)\n+\t\t\t   hash_set<type_pair,pair_traits> *visited,\n+\t\t\t   location_t loc1, location_t loc2)\n {\n \n   /* This can happen in incomplete types that should be handled earlier.  */\n@@ -822,7 +825,7 @@ odr_subtypes_equivalent_p (tree t1, tree t2,\n     }\n   if (visited->add (pair))\n     return true;\n-  return odr_types_equivalent_p (t1, t2, false, NULL, visited);\n+  return odr_types_equivalent_p (t1, t2, false, NULL, visited, loc1, loc2);\n }\n \n /* Compare two virtual tables, PREVAILING and VTABLE and output ODR\n@@ -1079,7 +1082,7 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n     lto_location_cache::current_cache->apply_location_cache ();\n \n   if (!warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (t1)), OPT_Wodr,\n-\t\t   \"type %qT violates one definition rule\",\n+\t\t   \"type %qT violates the C++ One Definition Rule\",\n \t\t   t1))\n     return;\n   if (!st1 && !st2)\n@@ -1119,16 +1122,107 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n     *warned = true;\n }\n \n-/* We already warned about ODR mismatch.  T1 and T2 ought to be equivalent\n-   because they are used on same place in ODR matching types.\n-   They are not; inform the user.  */\n+/* Return ture if T1 and T2 are incompatible and we want to recusively\n+   dive into them from warn_type_mismatch to give sensible answer.  */\n \n-void\n-warn_types_mismatch (tree t1, tree t2)\n+static bool\n+type_mismatch_p (tree t1, tree t2)\n {\n-  /* If types have names and they are different, it is most informative to\n-     output those.  */\n+  if (odr_or_derived_type_p (t1) && odr_or_derived_type_p (t2)\n+      && !odr_types_equivalent_p (t1, t2))\n+    return true;\n+  return !types_compatible_p (t1, t2);\n+}\n+\n+\n+/* Types T1 and T2 was found to be incompatible in a context they can't\n+   (either used to declare a symbol of same assembler name or unified by\n+   ODR rule).  We already output warning about this, but if possible, output\n+   extra information on how the types mismatch.\n+\n+   This is hard to do in general.  We basically handle the common cases.\n+\n+   If LOC1 and LOC2 are meaningful locations, use it in the case the types\n+   themselves do no thave one.*/\n+\n+void\n+warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n+{\n+  /* Location of type is known only if it has TYPE_NAME and the name is\n+     TYPE_DECL.  */\n+  location_t loc_t1 = TYPE_NAME (t1) && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n+\t\t      ? DECL_SOURCE_LOCATION (TYPE_NAME (t1))\n+\t\t      : UNKNOWN_LOCATION;\n+  location_t loc_t2 = TYPE_NAME (t2) && TREE_CODE (TYPE_NAME (t2)) == TYPE_DECL\n+\t\t      ? DECL_SOURCE_LOCATION (TYPE_NAME (t2))\n+\t\t      : UNKNOWN_LOCATION;\n+  bool loc_t2_useful = false;\n+\n+  /* With LTO it is a common case that the location of both types match.\n+     See if T2 has a location that is different from T1. If so, we will\n+     inform user about the location.\n+     Do not consider the location passed to us in LOC1/LOC2 as those are\n+     already output.  */\n+  if (loc_t2 > BUILTINS_LOCATION && loc_t2 != loc_t1)\n+    {\n+      if (loc_t1 <= BUILTINS_LOCATION)\n+\tloc_t2_useful = true;\n+      else\n+\t{\n+\t  expanded_location xloc1 = expand_location (loc_t1);\n+\t  expanded_location xloc2 = expand_location (loc_t2);\n+\n+\t  if (strcmp (xloc1.file, xloc2.file)\n+\t      || xloc1.line != xloc2.line\n+\t      || xloc1.column != xloc2.column)\n+\t    loc_t2_useful = true;\n+\t}\n+    }\n+\n+  if (loc_t1 <= BUILTINS_LOCATION)\n+    loc_t1 = loc1;\n+  if (loc_t2 <= BUILTINS_LOCATION)\n+    loc_t2 = loc2;\n+\n+  location_t loc = loc_t1 <= BUILTINS_LOCATION ? loc_t2 : loc_t1;\n+\n+  /* It is a quite common bug to reference anonymous namespace type in\n+     non-anonymous namespace class.  */\n+  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n+      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n+    {\n+      if (type_with_linkage_p (t1) && !type_in_anonymous_namespace_p (t1))\n+\t{\n+\t  std::swap (t1, t2);\n+\t  std::swap (loc_t1, loc_t2);\n+\t}\n+      gcc_assert (TYPE_NAME (t1) && TYPE_NAME (t2)\n+\t\t  && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n+\t\t  && TREE_CODE (TYPE_NAME (t2)) == TYPE_DECL);\n+      /* Most of the time, the type names will match, do not be unnecesarily\n+         verbose.  */\n+      if (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t1)))\n+\t  != IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t2))))\n+        inform (loc_t1,\n+\t        \"type %qT defined in anonymous namespace can not match \"\n+\t        \"type %qT across the translation unit boundary\",\n+\t        t1, t2);\n+      else\n+        inform (loc_t1,\n+\t        \"type %qT defined in anonymous namespace can not match \"\n+\t        \"across the translation unit boundary\",\n+\t        t1);\n+      if (loc_t2_useful)\n+        inform (loc_t2,\n+\t        \"the incompatible type defined in another translation unit\");\n+      return;\n+    }\n+  /* If types have mangled ODR names and they are different, it is most\n+     informative to output those.\n+     This also covers types defined in different namespaces.  */\n   if (TYPE_NAME (t1) && TYPE_NAME (t2)\n+      && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n+      && TREE_CODE (TYPE_NAME (t2)) == TYPE_DECL\n       && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t1))\n       && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t2))\n       && DECL_ASSEMBLER_NAME (TYPE_NAME (t1))\n@@ -1142,46 +1236,18 @@ warn_types_mismatch (tree t1, tree t2)\n \t  DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES);\n       if (name1 && name2 && strcmp (name1, name2))\n \t{\n-\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n+\t  inform (loc_t1,\n \t\t  \"type name %<%s%> should match type name %<%s%>\",\n \t\t  name1, name2);\n-\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t2)),\n-\t\t  \"the incompatible type is defined here\");\n+\t  if (loc_t2_useful)\n+\t    inform (loc_t2,\n+\t\t    \"the incompatible type is defined here\");\n \t  free (name1);\n \t  return;\n \t}\n       free (name1);\n     }\n-  /* It is a quite common bug to reference anonymous namespace type in\n-     non-anonymous namespace class.  */\n-  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n-      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n-    {\n-      if (type_with_linkage_p (t1) && !type_in_anonymous_namespace_p (t1))\n-\t{\n-\t  tree tmp = t1;;\n-\t  t1 = t2;\n-\t  t2 = tmp;\n-\t}\n-      if (TYPE_NAME (t1) && TYPE_NAME (t2)\n-\t  && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n-\t  && TREE_CODE (TYPE_NAME (t2)) == TYPE_DECL)\n-\t{\n-\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n-\t\t  \"type %qT defined in anonymous namespace can not match \"\n-\t\t  \"type %qT\",\n-\t\t  t1, t2);\n-\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t2)),\n-\t\t  \"the incompatible type defined in anonymous namespace in \"\n-\t\t  \"another translation unit\");\n-\t}\n-      else\n-\tinform (UNKNOWN_LOCATION,\n-\t\t\"types in anonymous namespace does not match across \"\n-\t\t\"translation unit boundary\");\n-      return;\n-    }\n-  /* A tricky case are component types.  Often they appear the same in source\n+  /* A tricky case are compound types.  Often they appear the same in source\n      code and the mismatch is dragged in by type they are build from.\n      Look for those differences in subtypes and try to be informative.  In other\n      cases just output nothing because the source code is probably different\n@@ -1190,7 +1256,6 @@ warn_types_mismatch (tree t1, tree t2)\n     {\n       if (TREE_CODE (t1) == TREE_CODE (t2))\n \t{\n-\t  hash_set<type_pair,pair_traits> visited;\n \t  if (TREE_CODE (t1) == ARRAY_TYPE\n \t      && COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2))\n \t    {\n@@ -1203,27 +1268,25 @@ warn_types_mismatch (tree t1, tree t2)\n \t\t  && !operand_equal_p (TYPE_MAX_VALUE (i1),\n \t\t\t\t       TYPE_MAX_VALUE (i2), 0))\n \t\t{\n-\t\t  inform (UNKNOWN_LOCATION,\n+\t\t  inform (loc,\n \t\t\t  \"array types have different bounds\");\n \t\t  return;\n \t\t}\n \t    }\n \t  if ((POINTER_TYPE_P (t1) || TREE_CODE (t1) == ARRAY_TYPE)\n-\t      && !odr_subtypes_equivalent_p (TREE_TYPE (t1),\n-\t\t\t\t\t     TREE_TYPE (t2),\n-\t\t\t\t\t     &visited))\n-\t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t      && type_mismatch_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2), loc_t1, loc_t2);\n \t  else if (TREE_CODE (t1) == METHOD_TYPE\n \t\t   || TREE_CODE (t1) == FUNCTION_TYPE)\n \t    {\n \t      tree parms1 = NULL, parms2 = NULL;\n \t      int count = 1;\n \n-\t      if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t      &visited))\n+\t      if (type_mismatch_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \t\t{\n-\t\t  inform (UNKNOWN_LOCATION, \"return value type mismatch\");\n-\t\t  warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t\t  inform (loc, \"return value type mismatch\");\n+\t\t  warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2), loc_t1,\n+\t\t\t\t       loc_t2);\n \t\t  return;\n \t\t}\n \t      if (prototype_p (t1) && prototype_p (t2))\n@@ -1232,71 +1295,58 @@ warn_types_mismatch (tree t1, tree t2)\n \t\t     parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2),\n \t\t     count++)\n \t\t  {\n-\t\t    if (!odr_subtypes_equivalent_p\n-\t\t\t(TREE_VALUE (parms1), TREE_VALUE (parms2), &visited))\n+\t\t    if (type_mismatch_p (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n \t\t      {\n \t\t\tif (count == 1 && TREE_CODE (t1) == METHOD_TYPE)\n-\t\t\t  inform (UNKNOWN_LOCATION,\n+\t\t\t  inform (loc,\n \t\t\t\t  \"implicit this pointer type mismatch\");\n \t\t\telse\n-\t\t\t  inform (UNKNOWN_LOCATION,\n+\t\t\t  inform (loc,\n \t\t\t\t  \"type mismatch in parameter %i\",\n \t\t\t\t  count - (TREE_CODE (t1) == METHOD_TYPE));\n \t\t\twarn_types_mismatch (TREE_VALUE (parms1),\n-\t\t\t\t\t     TREE_VALUE (parms2));\n+\t\t\t\t\t     TREE_VALUE (parms2),\n+\t\t\t\t\t     loc_t1, loc_t2);\n \t\t\treturn;\n \t\t      }\n \t\t  }\n \t      if (parms1 || parms2)\n \t\t{\n-\t\t  inform (UNKNOWN_LOCATION,\n+\t\t  inform (loc,\n \t\t\t  \"types have different parameter counts\");\n \t\t  return;\n \t\t}\n \t    }\n \t}\n       return;\n     }\n-  /* This should not happen but if it does, the warning would not be helpful.\n-     TODO: turn it into assert next stage1.  */\n-  if (TYPE_NAME (t1) == TYPE_NAME (t2))\n+\n+  if (types_odr_comparable (t1, t2, true)\n+      && types_same_for_odr (t1, t2, true))\n+    inform (loc_t1,\n+\t    \"type %qT itself violate the C++ One Definition Rule\", t1);\n+  /* Prevent pointless warnings like \"struct aa\" should match \"struct aa\".  */\n+  else if (TYPE_NAME (t1) == TYPE_NAME (t2)\n+\t   && TREE_CODE (t1) == TREE_CODE (t2) && !loc_t2_useful)\n     return;\n-  /* In Firefox it is a common bug to have same types but in\n-     different namespaces.  Be a bit more informative on\n-     this.  */\n-  if (TYPE_CONTEXT (t1) && TYPE_CONTEXT (t2)\n-      && (((TREE_CODE (TYPE_CONTEXT (t1)) == NAMESPACE_DECL)\n-\t    != (TREE_CODE (TYPE_CONTEXT (t2)) == NAMESPACE_DECL))\n-\t   || (TREE_CODE (TYPE_CONTEXT (t1)) == NAMESPACE_DECL\n-\t       && (DECL_NAME (TYPE_CONTEXT (t1)) !=\n-\t\t   DECL_NAME (TYPE_CONTEXT (t2))))))\n-    inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n-\t    \"type %qT should match type %qT but is defined \"\n-\t    \"in different namespace  \",\n-\t    t1, t2);\n-  else if (types_odr_comparable (t1, t2, true)\n-\t   && types_same_for_odr (t1, t2, true))\n-    inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n-\t    \"type %qT should match type %qT that itself violate \"\n-\t    \"one definition rule\",\n-\t    t1, t2);\n   else\n-    inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n-\t    \"type %qT should match type %qT\",\n+    inform (loc_t1, \"type %qT should match type %qT\",\n \t    t1, t2);\n-  if (DECL_SOURCE_LOCATION (TYPE_NAME (t2)) > BUILTINS_LOCATION)\n-    inform (DECL_SOURCE_LOCATION (TYPE_NAME (t2)),\n-\t    \"the incompatible type is defined here\");\n+  if (loc_t2_useful)\n+    inform (loc_t2, \"the incompatible type is defined here\");\n }\n \n /* Compare T1 and T2, report ODR violations if WARN is true and set\n    WARNED to true if anything is reported.  Return true if types match.\n    If true is returned, the types are also compatible in the sense of\n-   gimple_canonical_types_compatible_p.  */\n+   gimple_canonical_types_compatible_p.\n+   If LOC1 and LOC2 is not UNKNOWN_LOCATION it may be used to output a warning\n+   about the type if the type itself do not have location.  */\n \n static bool\n odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n-\t\t\thash_set<type_pair,pair_traits> *visited)\n+\t\t\thash_set<type_pair,pair_traits> *visited,\n+\t\t\tlocation_t loc1, location_t loc2)\n {\n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n@@ -1420,26 +1470,29 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t      return false;\n \t    }\n \n-\t  if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2), visited))\n+\t  if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t  visited, loc1, loc2))\n \t    {\n \t      warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\tG_(\"it is defined as a pointer to different type \"\n \t\t\t   \"in another translation unit\"));\n \t      if (warn && warned)\n-\t        warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t        warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t     loc1, loc2);\n \t      return false;\n \t    }\n \t}\n \n       if ((TREE_CODE (t1) == VECTOR_TYPE || TREE_CODE (t1) == COMPLEX_TYPE)\n-\t  && !odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2), visited))\n+\t  && !odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t visited, loc1, loc2))\n \t{\n \t  /* Probably specific enough.  */\n \t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t    G_(\"a different type is defined \"\n \t\t       \"in another translation unit\"));\n \t  if (warn && warned)\n-\t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2), loc1, loc2);\n \t  return false;\n \t}\n     }\n@@ -1450,13 +1503,14 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       {\n \t/* Array types are the same if the element types are the same and\n \t   the number of elements are the same.  */\n-\tif (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2), visited))\n+\tif (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\tvisited, loc1, loc2))\n \t  {\n \t    warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t      G_(\"a different type is defined in another \"\n \t\t\t \"translation unit\"));\n \t    if (warn && warned)\n-\t      warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t      warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2), loc1, loc2);\n \t  }\n \tgcc_assert (TYPE_STRING_FLAG (t1) == TYPE_STRING_FLAG (t2));\n \tgcc_assert (TYPE_NONALIASED_COMPONENT (t1)\n@@ -1491,13 +1545,14 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n     case FUNCTION_TYPE:\n       /* Function types are the same if the return type and arguments types\n \t are the same.  */\n-      if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2), visited))\n+      if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t      visited, loc1, loc2))\n \t{\n \t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t    G_(\"has different return value \"\n \t\t       \"in another translation unit\"));\n \t  if (warn && warned)\n-\t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2), loc1, loc2);\n \t  return false;\n \t}\n \n@@ -1513,14 +1568,15 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n \t    {\n \t      if (!odr_subtypes_equivalent_p\n-\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2), visited))\n+\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2), visited,\n+\t\t      loc1, loc2))\n \t\t{\n \t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\t    G_(\"has different parameters in another \"\n \t\t\t       \"translation unit\"));\n \t\t  if (warn && warned)\n \t\t    warn_types_mismatch (TREE_VALUE (parms1),\n-\t\t\t\t\t TREE_VALUE (parms2));\n+\t\t\t\t\t TREE_VALUE (parms2), loc1, loc2);\n \t\t  return false;\n \t\t}\n \t    }\n@@ -1593,7 +1649,8 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t    return false;\n \t\t  }\n \t\tif (!odr_subtypes_equivalent_p (TREE_TYPE (f1),\n-\t\t\t\t\t\tTREE_TYPE (f2), visited))\n+\t\t\t\t\t\tTREE_TYPE (f2), visited,\n+\t\t\t\t\t\tloc1, loc2))\n \t\t  {\n \t\t    /* Do not warn about artificial fields and just go into\n  \t\t       generic field mismatch warning.  */\n@@ -1604,7 +1661,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t\t      G_(\"a field of same name but different type \"\n \t\t\t\t \"is defined in another translation unit\"));\n \t\t    if (warn && warned)\n-\t\t      warn_types_mismatch (TREE_TYPE (f1), TREE_TYPE (f2));\n+\t\t      warn_types_mismatch (TREE_TYPE (f1), TREE_TYPE (f2), loc1, loc2);\n \t\t    return false;\n \t\t  }\n \t\tif (!gimple_compare_field_offset (f1, f2))\n@@ -1681,7 +1738,8 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t\t  return false;\n \t\t\t}\n \t\t      if (odr_subtypes_equivalent_p (TREE_TYPE (f1),\n-\t\t\t\t\t\t     TREE_TYPE (f2), visited))\n+\t\t\t\t\t\t     TREE_TYPE (f2), visited,\n+\t\t\t\t\t\t     loc1, loc2))\n \t\t\t{\n \t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n \t\t\t\t    G_(\"method with incompatible type is \"\n@@ -1743,7 +1801,7 @@ odr_types_equivalent_p (tree type1, tree type2)\n   gcc_assert (odr_or_derived_type_p (type1) && odr_or_derived_type_p (type2));\n #endif\n   return odr_types_equivalent_p (type1, type2, false, NULL,\n-\t\t\t         &visited);\n+\t\t\t         &visited, UNKNOWN_LOCATION, UNKNOWN_LOCATION);\n }\n \n /* TYPE is equivalent to VAL by ODR, but its tree representation differs\n@@ -1881,7 +1939,8 @@ add_type_duplicate (odr_type val, tree type)\n \t\t\t      \"a type with the same name but different base \"\n \t\t\t      \"type is defined in another translation unit\");\n \t\t    if (warned)\n-\t\t      warn_types_mismatch (type1, type2);\n+\t\t      warn_types_mismatch (type1, type2,\n+\t\t\t\t\t    UNKNOWN_LOCATION, UNKNOWN_LOCATION);\n \t\t  }\n \t\tbreak;\n \t      }\n@@ -1945,7 +2004,9 @@ add_type_duplicate (odr_type val, tree type)\n   /* Next compare memory layout.  */\n   if (!odr_types_equivalent_p (val->type, type,\n \t\t\t       !flag_ltrans && !val->odr_violated && !warned,\n-\t\t\t       &warned, &visited))\n+\t\t\t       &warned, &visited,\n+\t\t\t       DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n+\t\t\t       DECL_SOURCE_LOCATION (TYPE_NAME (type))))\n     {\n       merge = false;\n       odr_violation_reported = true;"}, {"sha": "27b54ac44dc0852098bc469cc294ad5f4daf500d", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=6542950e80b2ac7edbdba43f5147b15df282012e", "patch": "@@ -86,7 +86,8 @@ bool types_must_be_same_for_odr (tree, tree);\n bool types_odr_comparable (tree, tree, bool strict = false);\n cgraph_node *try_speculative_devirtualization (tree, HOST_WIDE_INT,\n \t\t\t\t\t       ipa_polymorphic_call_context);\n-void warn_types_mismatch (tree t1, tree t2);\n+void warn_types_mismatch (tree t1, tree t2, location_t loc1 = UNKNOWN_LOCATION,\n+\t\t\t  location_t loc2 = UNKNOWN_LOCATION);\n bool odr_or_derived_type_p (const_tree t);\n bool odr_types_equivalent_p (tree type1, tree type2);\n "}, {"sha": "9ad289a45eab7b034bdd574179dd9e8f03b3aa51", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6542950e80b2ac7edbdba43f5147b15df282012e", "patch": "@@ -1,5 +1,13 @@\n 2015-06-06  Jan Hubicka  <hubicka@ucw.cz>\n \n+\tPR lto/65378\n+\t* lto-symtab.c (warn_type_compatibility_p): Fix call of\n+\todr_or_derived_type_p.\n+\t(lto_symtab_merge_decls_2): Update call of warn_types_mismatch.\n+\n+2015-06-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\n \t* lto.c (hash_canonical_type): Do not hash TREE_CODE of TREE_TYPE of\n \tpointers.\n "}, {"sha": "e808006bab7647b392762e0a3c5efe75aab9307e", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6542950e80b2ac7edbdba43f5147b15df282012e/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=6542950e80b2ac7edbdba43f5147b15df282012e", "patch": "@@ -212,7 +212,7 @@ warn_type_compatibility_p (tree prevailing_type, tree type)\n   int lev = 0;\n   /* C++ provide a robust way to check for type compatibility via the ODR\n      rule.  */\n-  if (odr_or_derived_type_p (prevailing_type) && odr_type_p (type)\n+  if (odr_or_derived_type_p (prevailing_type) && odr_or_derived_type_p (type)\n       && !odr_types_equivalent_p (prevailing_type, type))\n     lev = 2;\n \n@@ -542,7 +542,9 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n \t\t\t       \"declaration\", decl);\n \t  if (diag)\n \t    warn_types_mismatch (TREE_TYPE (prevailing->decl),\n-\t\t\t\t TREE_TYPE (decl));\n+\t\t\t\t TREE_TYPE (decl),\n+\t\t\t\t DECL_SOURCE_LOCATION (prevailing->decl),\n+\t\t\t\t DECL_SOURCE_LOCATION (decl));\n \t  diagnosed_p |= diag;\n \t}\n       else if ((DECL_USER_ALIGN (prevailing->decl)"}]}