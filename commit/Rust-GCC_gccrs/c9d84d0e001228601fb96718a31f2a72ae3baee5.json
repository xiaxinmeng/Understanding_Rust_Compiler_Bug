{"sha": "c9d84d0e001228601fb96718a31f2a72ae3baee5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlkODRkMGUwMDEyMjg2MDFmYjk2NzE4YTMxZjJhNzJhZTNiYWVlNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-11-18T18:48:54Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-11-18T18:48:54Z"}, "message": "decl.c (gnat_to_gnu_entity): Also use return-by-invisible-reference if the return type is By_Reference.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Subprogram_Type>: Also\n\tuse return-by-invisible-reference if the return type is By_Reference.\n\tTidy up and skip the processing of the return type if it is void.\n\nFrom-SVN: r166916", "tree": {"sha": "4fb0d223af915b27628e8d3916f9ba94676f018a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fb0d223af915b27628e8d3916f9ba94676f018a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9d84d0e001228601fb96718a31f2a72ae3baee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9d84d0e001228601fb96718a31f2a72ae3baee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9d84d0e001228601fb96718a31f2a72ae3baee5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9d84d0e001228601fb96718a31f2a72ae3baee5/comments", "author": null, "committer": null, "parents": [{"sha": "69ecd18fb9c7826cc295109240744ab3ec586187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ecd18fb9c7826cc295109240744ab3ec586187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69ecd18fb9c7826cc295109240744ab3ec586187"}], "stats": {"total": 259, "additions": 159, "deletions": 100}, "files": [{"sha": "b1a8da7cdd44c5b0b295ff9359bc883f1fb5c836", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c9d84d0e001228601fb96718a31f2a72ae3baee5", "patch": "@@ -1,3 +1,9 @@\n+2010-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Subprogram_Type>: Also\n+\tuse return-by-invisible-reference if the return type is By_Reference.\n+\tTidy up and skip the processing of the return type if it is void.\n+\n 2010-11-17  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc-interface/misc.c (gnat_parse_file): Take no arguments."}, {"sha": "262ee5de9da4f239efe2dbf8fe27b392d6aaf0a9", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 89, "deletions": 100, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c9d84d0e001228601fb96718a31f2a72ae3baee5", "patch": "@@ -3827,20 +3827,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n     /* Subprogram Entities\n \n-       The following access functions are defined for subprograms (functions\n-       or procedures):\n+       The following access functions are defined for subprograms:\n \n+\t\tEtype       \tReturn type or Standard_Void_Type.\n \t\tFirst_Formal\tThe first formal parameter.\n \t\tIs_Imported     Indicates that the subprogram has appeared in\n \t\t\t\tan INTERFACE or IMPORT pragma.  For now we\n \t\t\t\tassume that the external language is C.\n \t\tIs_Exported     Likewise but for an EXPORT pragma.\n \t\tIs_Inlined      True if the subprogram is to be inlined.\n \n-       In addition for function subprograms we have:\n-\n-\t\tEtype       \tReturn type of the function.\n-\n        Each parameter is first checked by calling must_pass_by_ref on its\n        type to determine if it is passed by reference.  For parameters which\n        are copied in, if they are Ada In Out or Out parameters, their return\n@@ -3873,18 +3869,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Function:\n     case E_Procedure:\n       {\n+\t/* The type returned by a function or else Standard_Void_Type for a\n+\t   procedure.  */\n+\tEntity_Id gnat_return_type = Etype (gnat_entity);\n+\ttree gnu_return_type;\n \t/* The first GCC parameter declaration (a PARM_DECL node).  The\n \t   PARM_DECL nodes are chained through the TREE_CHAIN field, so this\n \t   actually is the head of this parameter list.  */\n \ttree gnu_param_list = NULL_TREE;\n \t/* Likewise for the stub associated with an exported procedure.  */\n \ttree gnu_stub_param_list = NULL_TREE;\n-\t/* The type returned by a function.  If the subprogram is a procedure\n-\t   this type should be void_type_node.  */\n-\ttree gnu_return_type = void_type_node;\n-\t/* List of fields in return type of procedure with copy-in copy-out\n-\t   parameters.  */\n-\ttree gnu_field_list = NULL_TREE;\n \t/* Non-null for subprograms containing parameters passed by copy-in\n \t   copy-out (Ada In Out or Out parameters not passed by reference),\n \t   in which case it is the list of nodes used to specify the values\n@@ -3894,6 +3888,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   corresponding to that field.  This list will be saved in the\n \t   TYPE_CI_CO_LIST field of the FUNCTION_TYPE node we create.  */\n \ttree gnu_cico_list = NULL_TREE;\n+\t/* List of fields in return type of procedure with copy-in copy-out\n+\t   parameters.  */\n+\ttree gnu_field_list = NULL_TREE;\n \t/* If an import pragma asks to map this subprogram to a GCC builtin,\n \t   this is the builtin DECL node.  */\n \ttree gnu_builtin_decl = NULL_TREE;\n@@ -3905,7 +3902,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool public_flag = Is_Public (gnat_entity) || imported_p;\n \tbool extern_flag\n \t  = (Is_Public (gnat_entity) && !definition) || imported_p;\n-\n        /* The semantics of \"pure\" in Ada essentially matches that of \"const\"\n           in the back-end.  In particular, both properties are orthogonal to\n           the \"nothrow\" property if the EH circuitry is explicit in the\n@@ -3917,7 +3913,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool const_flag\n \t  = (Exception_Mechanism == Back_End_Exceptions\n \t     && Is_Pure (gnat_entity));\n-\n \tbool volatile_flag = No_Return (gnat_entity);\n \tbool return_by_direct_ref_p = false;\n \tbool return_by_invisi_ref_p = false;\n@@ -3942,8 +3937,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    if (Ekind (Alias (gnat_entity)) == E_Enumeration_Literal)\n \t      gnat_to_gnu_entity (Etype (Alias (gnat_entity)), NULL_TREE, 0);\n \n-\t    gnu_decl = gnat_to_gnu_entity (Alias (gnat_entity),\n-\t\t\t\t\t   gnu_expr, 0);\n+\t    gnu_decl = gnat_to_gnu_entity (Alias (gnat_entity), gnu_expr, 0);\n \n \t    /* Elaborate any Itypes in the parameters of this entity.  */\n \t    for (gnat_temp = First_Formal_With_Extras (gnat_entity);\n@@ -3978,97 +3972,92 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   In the current state we neither warn nor err, and calls will just\n \t   be handled as for regular subprograms.  */\n \n-\tif (kind == E_Function || kind == E_Subprogram_Type)\n-\t  gnu_return_type = gnat_to_gnu_type (Etype (gnat_entity));\n-\n-\t/* If this function returns by reference, make the actual return\n-\t   type of this function the pointer and mark the decl.  */\n-\tif (Returns_By_Ref (gnat_entity))\n+\t/* Look into the return type and get its associated GCC tree.  If it\n+\t   is not void, compute various flags for the subprogram type.  */\n+\tif (Ekind (gnat_return_type) == E_Void)\n+\t  gnu_return_type = void_type_node;\n+\telse\n \t  {\n-\t    gnu_return_type = build_pointer_type (gnu_return_type);\n-\t    return_by_direct_ref_p = true;\n-\t  }\n+\t    gnu_return_type = gnat_to_gnu_type (gnat_return_type);\n \n-\t/* If the Mechanism is By_Reference, ensure this function uses the\n-\t   target's by-invisible-reference mechanism, which may not be the\n-\t   same as above (e.g. it might be passing an extra parameter).\n-\n-\t   Prior to GCC 4, this was handled by just setting TREE_ADDRESSABLE\n-\t   on the result type.  Everything required to pass by invisible\n-\t   reference using the target's mechanism (e.g. an extra parameter)\n-\t   was handled at RTL expansion time.\n-\n-\t   This doesn't work with GCC 4 any more for several reasons.  First,\n-\t   the gimplification process might need to create temporaries of this\n-\t   type and the gimplifier ICEs on such attempts; that's why the flag\n-\t   is now set on the function type instead.  Second, the middle-end\n-\t   now also relies on a different attribute, DECL_BY_REFERENCE on the\n-\t   RESULT_DECL, and expects the by-invisible-reference-ness to be made\n-\t   explicit in the function body.  */\n-\telse if (kind == E_Function && Mechanism (gnat_entity) == By_Reference)\n-\t  return_by_invisi_ref_p = true;\n-\n-\t/* If we are supposed to return an unconstrained array, actually return\n-\t   a fat pointer and make a note of that.  */\n-\telse if (TREE_CODE (gnu_return_type) == UNCONSTRAINED_ARRAY_TYPE)\n-\t  {\n-\t    gnu_return_type = TREE_TYPE (gnu_return_type);\n-\t    return_unconstrained_p = true;\n-\t  }\n+\t    /* If this function returns by reference, make the actual return\n+\t       type the pointer type and make a note of that.  */\n+\t    if (Returns_By_Ref (gnat_entity))\n+\t      {\n+\t\tgnu_return_type = build_pointer_type (gnu_return_type);\n+\t\treturn_by_direct_ref_p = true;\n+\t      }\n \n-\t/* If the type requires a transient scope, the result is allocated\n-\t   on the secondary stack, so the result type of the function is\n-\t   just a pointer.  */\n-\telse if (Requires_Transient_Scope (Etype (gnat_entity)))\n-\t  {\n-\t    gnu_return_type = build_pointer_type (gnu_return_type);\n-\t    return_unconstrained_p = true;\n-\t  }\n+\t    /* If we are supposed to return an unconstrained array type, make\n+\t       the actual return type the fat pointer type.  */\n+\t    else if (TREE_CODE (gnu_return_type) == UNCONSTRAINED_ARRAY_TYPE)\n+\t      {\n+\t\tgnu_return_type = TREE_TYPE (gnu_return_type);\n+\t\treturn_unconstrained_p = true;\n+\t      }\n \n-\t/* If the type is a padded type and the underlying type would not\n-\t   be passed by reference or this function has a foreign convention,\n-\t   return the underlying type.  */\n-\telse if (TYPE_IS_PADDING_P (gnu_return_type)\n-\t\t && (!default_pass_by_ref (TREE_TYPE\n-\t\t\t\t\t   (TYPE_FIELDS (gnu_return_type)))\n-\t\t     || Has_Foreign_Convention (gnat_entity)))\n-\t  gnu_return_type = TREE_TYPE (TYPE_FIELDS (gnu_return_type));\n-\n-\t/* If the return type is unconstrained, that means it must have a\n-\t   maximum size.  Use the padded type as the effective return type.\n-\t   And ensure the function uses the target's by-invisible-reference\n-\t   mechanism to avoid copying too much data when it returns.  */\n-\tif (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_return_type)))\n-\t  {\n-\t    gnu_return_type\n-\t      = maybe_pad_type (gnu_return_type,\n-\t\t\t\tmax_size (TYPE_SIZE (gnu_return_type), true),\n-\t\t\t\t0, gnat_entity, false, false, false, true);\n-\t    return_by_invisi_ref_p = true;\n-\t  }\n+\t    /* Likewise, if the return type requires a transient scope, the\n+\t       return value will be allocated on the secondary stack so the\n+\t       actual return type is the pointer type.  */\n+\t    else if (Requires_Transient_Scope (gnat_return_type))\n+\t      {\n+\t\tgnu_return_type = build_pointer_type (gnu_return_type);\n+\t\treturn_unconstrained_p = true;\n+\t      }\n \n-\t/* If the return type has a size that overflows, we cannot have\n-\t   a function that returns that type.  This usage doesn't make\n-\t   sense anyway, so give an error here.  */\n-\tif (TYPE_SIZE_UNIT (gnu_return_type)\n-\t    && TREE_CONSTANT (TYPE_SIZE_UNIT (gnu_return_type))\n-\t    && TREE_OVERFLOW (TYPE_SIZE_UNIT (gnu_return_type)))\n-\t  {\n-\t    post_error (\"cannot return type whose size overflows\",\n-\t\t\tgnat_entity);\n-\t    gnu_return_type = copy_node (gnu_return_type);\n-\t    TYPE_SIZE (gnu_return_type) = bitsize_zero_node;\n-\t    TYPE_SIZE_UNIT (gnu_return_type) = size_zero_node;\n-\t    TYPE_MAIN_VARIANT (gnu_return_type) = gnu_return_type;\n-\t    TYPE_NEXT_VARIANT (gnu_return_type) = NULL_TREE;\n-\t  }\n+\t    /* If the Mechanism is By_Reference, ensure this function uses the\n+\t       target's by-invisible-reference mechanism, which may not be the\n+\t       same as above (e.g. it might be passing an extra parameter).  */\n+\t    else if (kind == E_Function\n+\t\t     && Mechanism (gnat_entity) == By_Reference)\n+\t      return_by_invisi_ref_p = true;\n+\n+\t    /* Likewise, if the return type is itself By_Reference.  */\n+\t    else if (TREE_ADDRESSABLE (gnu_return_type))\n+\t      return_by_invisi_ref_p = true;\n+\n+\t    /* If the type is a padded type and the underlying type would not\n+\t       be passed by reference or the function has a foreign convention,\n+\t       return the underlying type.  */\n+\t    else if (TYPE_IS_PADDING_P (gnu_return_type)\n+\t\t     && (!default_pass_by_ref\n+\t\t\t  (TREE_TYPE (TYPE_FIELDS (gnu_return_type)))\n+\t\t\t || Has_Foreign_Convention (gnat_entity)))\n+\t      gnu_return_type = TREE_TYPE (TYPE_FIELDS (gnu_return_type));\n+\n+\t    /* If the return type is unconstrained, that means it must have a\n+\t       maximum size.  Use the padded type as the effective return type.\n+\t       And ensure the function uses the target's by-invisible-reference\n+\t       mechanism to avoid copying too much data when it returns.  */\n+\t    if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_return_type)))\n+\t      {\n+\t\tgnu_return_type\n+\t\t  = maybe_pad_type (gnu_return_type,\n+\t\t\t\t    max_size (TYPE_SIZE (gnu_return_type),\n+\t\t\t\t\t      true),\n+\t\t\t\t    0, gnat_entity, false, false, false, true);\n+\t\treturn_by_invisi_ref_p = true;\n+\t      }\n \n-\t/* Look at all our parameters and get the type of\n-\t   each.  While doing this, build a copy-out structure if\n-\t   we need one.  */\n+\t    /* If the return type has a size that overflows, we cannot have\n+\t       a function that returns that type.  This usage doesn't make\n+\t       sense anyway, so give an error here.  */\n+\t    if (TYPE_SIZE_UNIT (gnu_return_type)\n+\t\t&& TREE_CONSTANT (TYPE_SIZE_UNIT (gnu_return_type))\n+\t\t&& TREE_OVERFLOW (TYPE_SIZE_UNIT (gnu_return_type)))\n+\t      {\n+\t\tpost_error (\"cannot return type whose size overflows\",\n+\t\t\t    gnat_entity);\n+\t\tgnu_return_type = copy_node (gnu_return_type);\n+\t\tTYPE_SIZE (gnu_return_type) = bitsize_zero_node;\n+\t\tTYPE_SIZE_UNIT (gnu_return_type) = size_zero_node;\n+\t\tTYPE_MAIN_VARIANT (gnu_return_type) = gnu_return_type;\n+\t\tTYPE_NEXT_VARIANT (gnu_return_type) = NULL_TREE;\n+\t      }\n+\t  }\n \n-\t/* Loop over the parameters and get their associated GCC tree.\n-\t   While doing this, build a copy-out structure if we need one.  */\n+\t/* Loop over the parameters and get their associated GCC tree.  While\n+\t   doing this, build a copy-in copy-out structure if we need one.  */\n \tfor (gnat_param = First_Formal_With_Extras (gnat_entity), parmnum = 0;\n \t     Present (gnat_param);\n \t     gnat_param = Next_Formal_With_Extras (gnat_param), parmnum++)"}, {"sha": "7ef06b18ef61f8972cb7d86368017786f0e4b19a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c9d84d0e001228601fb96718a31f2a72ae3baee5", "patch": "@@ -1,3 +1,8 @@\n+2010-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/atomic4.ad[sb]: New test.\n+\t* gnat.dg/volatile4.adb: Likewise.\n+\n 2010-11-18  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.target/i386/pr46470.c: Skip for 32-bit PIC."}, {"sha": "99f4ee14c983ba6f37f62173ecefc3a5f2549ef1", "filename": "gcc/testsuite/gnat.dg/atomic4.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic4.adb?ref=c9d84d0e001228601fb96718a31f2a72ae3baee5", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O -gnatn\" }\n+\n+package body Atomic4 is\n+\n+   procedure Next (Self : in out Reader'Class) is\n+   begin\n+      Self.Current_Reference := Self.Reference_Stack.Last_Element;\n+      Self.Reference_Stack.Delete_Last;\n+   end Next;\n+\n+end Atomic4;"}, {"sha": "a0e95bbff467885707425865a56091e935eef037", "filename": "gcc/testsuite/gnat.dg/atomic4.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic4.ads?ref=c9d84d0e001228601fb96718a31f2a72ae3baee5", "patch": "@@ -0,0 +1,23 @@\n+with Ada.Containers.Vectors;\n+\n+package Atomic4 is\n+\n+   type String is limited null record;\n+   type String_Access is access all String;\n+   pragma Atomic (String_Access);\n+\n+   type Reference is record\n+      Text : String_Access;\n+   end record;\n+\n+   package Reference_Vectors is\n+     new Ada.Containers.Vectors (Natural, Reference);\n+\n+   type Reader is tagged limited record\n+      Current_Reference : Reference;\n+      Reference_Stack   : Reference_Vectors.Vector;\n+   end record;\n+\n+   procedure Next (Self : in out Reader'Class);\n+\n+end Atomic4;"}, {"sha": "fe2b30760ce606941a29f86d7381c98b073a57f8", "filename": "gcc/testsuite/gnat.dg/volatile4.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d84d0e001228601fb96718a31f2a72ae3baee5/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile4.adb?ref=c9d84d0e001228601fb96718a31f2a72ae3baee5", "patch": "@@ -0,0 +1,24 @@\n+-- { dg-do run }\n+\n+procedure Volatile4 is\n+\n+  type My_Int is new Integer;\n+  pragma Volatile (My_Int);\n+\n+  type Rec is record\n+    I : My_Int;\n+  end record;\n+\n+  function F (R : Rec) return Rec is\n+  begin\n+    return R;\n+  end;\n+\n+  R : Rec := (I => 0);\n+\n+begin\n+  R := F (R);\n+  if R.I /= 0 then\n+    raise Program_Error;\n+  end if;\n+end;"}]}