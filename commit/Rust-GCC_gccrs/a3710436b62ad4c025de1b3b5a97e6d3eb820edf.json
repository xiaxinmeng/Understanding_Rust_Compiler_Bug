{"sha": "a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM3MTA0MzZiNjJhZDRjMDI1ZGUxYjNiNWE5N2U2ZDNlYjgyMGVkZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-04-25T18:27:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-04-25T18:27:19Z"}, "message": "tree.c (list_equal_p): New function.\n\n\t* tree.c (list_equal_p): New function.\n\t* tree.h (list_equal_p): Declare.\n\t* coretypes.h (edge_def, edge, const_edge, basic_block_def\n\tbasic_block_def, basic_block, const_basic_block): New.\n\t* tree-eh.c (make_eh_edge): EH edges are not abnormal.\n\t(redirect_eh_edge): New function.\n\t(make_eh_edge_update_phi): EH edges are not abnormal.\n\t* except.c: Include tree-flow.h.\n\t(list_match): New function.\n\t(eh_region_replaceable_by_p): New function.\n\t(replace_region): New function.\n\t(hash_type_list): New function.\n\t(hash_eh_region): New function.\n\t(eh_regions_equal_p): New function.\n\t(merge_peers): New function.\n\t(remove_unreachable_regions): Verify EH tree when checking;\n\tmerge peers.\n\t(copy_eh_region_1): New function.\n\t(copy_eh_region): New function.\n\t(push_reachable_handler): New function.\n\t(build_post_landing_pads, dw2_build_landing_pads): Be ready for\n\tregions without label but with live RESX.\n\t* except.h (redirect_eh_edge_to_label): New.\n\t* tree-flow.h (redirect_eh_edge): New.\n\t* coretypes.h (edge_def, edge, const_edge, basic_block_def\n\tbasic_block_def, basic_block, const_basic_block): Remove.\n\t* Makefile.in (except.o): Add dependency on tree-flow.h\n\t* tree-cfg.c (gimple_redirect_edge_and_branch): Handle EH edges.\n\t* basic-block.h (edge, const_edge, basic_block, const_basic_block):\n\tRemove.\n\nFrom-SVN: r146776", "tree": {"sha": "f9735ec8c3866c20255be203e45595367cbbe8e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9735ec8c3866c20255be203e45595367cbbe8e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/comments", "author": null, "committer": null, "parents": [{"sha": "3764d512d514c5011bf6473075444d49de284e05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3764d512d514c5011bf6473075444d49de284e05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3764d512d514c5011bf6473075444d49de284e05"}], "stats": {"total": 612, "additions": 594, "deletions": 18}, "files": [{"sha": "47f98fa95cca95733f65dd03d8c861737ba397b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -1,3 +1,36 @@\n+2009-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.c (list_equal_p): New function.\n+\t* tree.h (list_equal_p): Declare.\n+\t* coretypes.h (edge_def, edge, const_edge, basic_block_def\n+\tbasic_block_def, basic_block, const_basic_block): New.\n+\t* tree-eh.c (make_eh_edge): EH edges are not abnormal.\n+\t(redirect_eh_edge): New function.\n+\t(make_eh_edge_update_phi): EH edges are not abnormal.\n+\t* except.c: Include tree-flow.h.\n+\t(list_match): New function.\n+\t(eh_region_replaceable_by_p): New function.\n+\t(replace_region): New function.\n+\t(hash_type_list): New function.\n+\t(hash_eh_region): New function.\n+\t(eh_regions_equal_p): New function.\n+\t(merge_peers): New function.\n+\t(remove_unreachable_regions): Verify EH tree when checking;\n+\tmerge peers.\n+\t(copy_eh_region_1): New function.\n+\t(copy_eh_region): New function.\n+\t(push_reachable_handler): New function.\n+\t(build_post_landing_pads, dw2_build_landing_pads): Be ready for\n+\tregions without label but with live RESX.\n+\t* except.h (redirect_eh_edge_to_label): New.\n+\t* tree-flow.h (redirect_eh_edge): New.\n+\t* coretypes.h (edge_def, edge, const_edge, basic_block_def\n+\tbasic_block_def, basic_block, const_basic_block): Remove.\n+\t* Makefile.in (except.o): Add dependency on tree-flow.h\n+\t* tree-cfg.c (gimple_redirect_edge_and_branch): Handle EH edges.\n+\t* basic-block.h (edge, const_edge, basic_block, const_basic_block):\n+\tRemove.\n+\n 2009-04-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR bootstrap/39645"}, {"sha": "8b97805917c8f56c60d0e4511d1bdac420edc819", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -2525,7 +2525,7 @@ except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n    dwarf2asm.h dwarf2out.h $(TOPLEV_H) $(HASHTAB_H) intl.h $(GGC_H) \\\n    gt-$(EXCEPT_H) $(CGRAPH_H) $(INTEGRATE_H) $(DIAGNOSTIC_H) dwarf2.h \\\n-   $(TARGET_H) $(TM_P_H) $(TREE_PASS_H) $(TIMEVAR_H)\n+   $(TARGET_H) $(TM_P_H) $(TREE_PASS_H) $(TIMEVAR_H) $(TREE_FLOW_H)\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) $(EXPR_H) $(OPTABS_H) \\\n    libfuncs.h $(INSN_ATTR_H) insn-config.h $(RECOG_H) output.h \\"}, {"sha": "19ccd48edd67be9cc274bf08dd347ae34c26ee47", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -147,8 +147,6 @@ struct GTY(()) edge_def {\n \t\t\t\t   in profile.c  */\n };\n \n-typedef struct edge_def *edge;\n-typedef const struct edge_def *const_edge;\n DEF_VEC_P(edge);\n DEF_VEC_ALLOC_P(edge,gc);\n DEF_VEC_ALLOC_P(edge,heap);\n@@ -277,9 +275,6 @@ struct GTY(()) gimple_bb_info {\n   gimple_seq phi_nodes;\n };\n \n-typedef struct basic_block_def *basic_block;\n-typedef const struct basic_block_def *const_basic_block;\n-\n DEF_VEC_P(basic_block);\n DEF_VEC_ALLOC_P(basic_block,gc);\n DEF_VEC_ALLOC_P(basic_block,heap);"}, {"sha": "11583fffe4434c4eeed868a41a568c4fe2689af4", "filename": "gcc/coretypes.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -97,6 +97,12 @@ enum tls_model {\n   TLS_MODEL_LOCAL_EXEC\n };\n \n+struct edge_def;\n+typedef struct edge_def *edge;\n+typedef const struct edge_def *const_edge;\n+struct basic_block_def;\n+typedef struct basic_block_def *basic_block;\n+typedef const struct basic_block_def *const_basic_block;\n #else\n \n struct _dont_use_rtx_here_;"}, {"sha": "5b8ed7c37435c4ed4baf02a5fa9ff841c73361b1", "filename": "gcc/except.c", "status": "modified", "additions": 477, "deletions": 0, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -77,6 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"tree-pass.h\"\n #include \"timevar.h\"\n+#include \"tree-flow.h\"\n \n /* Provide defaults for stuff that may not be defined when using\n    sjlj exceptions.  */\n@@ -628,6 +629,238 @@ bring_to_root (struct eh_region *r)\n   cfun->eh->region_tree = r;\n }\n \n+/* Return true if region R2 can be replaced by R1.  */\n+\n+static bool\n+eh_region_replaceable_by_p (const struct eh_region *r1,\n+\t\t\t    const struct eh_region *r2)\n+{\n+  /* Regions are semantically same if they are of same type,\n+     have same label and type.  */\n+  if (r1->type != r2->type)\n+    return false;\n+  if (r1->tree_label != r2->tree_label)\n+    return false;\n+\n+  /* Verify that also region type dependent data are the same.  */\n+  switch (r1->type)\n+    {\n+      case ERT_MUST_NOT_THROW:\n+      case ERT_CLEANUP:\n+\tbreak;\n+      case ERT_TRY:\n+\t{\n+\t  struct eh_region *c1, *c2;\n+\t  for (c1 = r1->u.eh_try.eh_catch,\n+\t       c2 = r2->u.eh_try.eh_catch;\n+\t       c1 && c2;\n+\t       c1 = c1->u.eh_catch.next_catch,\n+\t       c2 = c2->u.eh_catch.next_catch)\n+\t    if (!eh_region_replaceable_by_p (c1, c2))\n+\t      return false;\n+\t  if (c1 || c2)\n+\t    return false;\n+        }\n+\tbreak;\n+      case ERT_CATCH:\n+        if (!list_equal_p (r1->u.eh_catch.type_list, r2->u.eh_catch.type_list))\n+\t  return false;\n+        if (!list_equal_p (r1->u.eh_catch.filter_list,\n+\t\t\t   r2->u.eh_catch.filter_list))\n+\t  return false;\n+        break;\n+      case ERT_ALLOWED_EXCEPTIONS:\n+        if (!list_equal_p (r1->u.allowed.type_list, r2->u.allowed.type_list))\n+\t  return false;\n+\tif (r1->u.allowed.filter != r2->u.allowed.filter)\n+\t  return false;\n+\tbreak;\n+      case ERT_THROW:\n+\tif (r1->u.eh_throw.type != r2->u.eh_throw.type)\n+\t  return false;\n+\tbreak;\n+      default:\n+        gcc_unreachable ();\n+    }\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Regions %i and %i match\\n\", r1->region_number,\n+    \t\t\t\t\t\t     r2->region_number);\n+  return true;\n+}\n+\n+/* Replace region R2 by R1.  */\n+\n+static void\n+replace_region (struct eh_region *r1, struct eh_region *r2)\n+{\n+  struct eh_region *next1 = r1->u.eh_try.eh_catch;\n+  struct eh_region *next2 = r2->u.eh_try.eh_catch;\n+  bool is_try = r1->type == ERT_TRY;\n+\n+  gcc_assert (r1->type != ERT_CATCH);\n+  remove_eh_handler_and_replace (r2, r1, false);\n+  if (is_try)\n+    {\n+      while (next1)\n+\t{\n+\t  r1 = next1;\n+\t  r2 = next2;\n+\t  gcc_assert (next1->type == ERT_CATCH);\n+\t  gcc_assert (next2->type == ERT_CATCH);\n+\t  next1 = next1->u.eh_catch.next_catch;\n+\t  next2 = next2->u.eh_catch.next_catch;\n+\t  remove_eh_handler_and_replace (r2, r1, false);\n+\t}\n+    }\n+}\n+\n+/* Return hash value of type list T.  */\n+\n+static hashval_t\n+hash_type_list (tree t)\n+{\n+  hashval_t val = 0;\n+  for (; t; t = TREE_CHAIN (t))\n+    val = iterative_hash_hashval_t (TREE_HASH (TREE_VALUE (t)), val);\n+  return val;\n+}\n+\n+/* Hash EH regions so semantically same regions get same hash value.  */\n+\n+static hashval_t\n+hash_eh_region (const void *r)\n+{\n+  const struct eh_region *region = (const struct eh_region *)r;\n+  hashval_t val = region->type;\n+\n+  if (region->tree_label)\n+    val = iterative_hash_hashval_t (LABEL_DECL_UID (region->tree_label), val);\n+  switch (region->type)\n+    {\n+      case ERT_MUST_NOT_THROW:\n+      case ERT_CLEANUP:\n+\tbreak;\n+      case ERT_TRY:\n+\t{\n+\t  struct eh_region *c;\n+\t  for (c = region->u.eh_try.eh_catch;\n+\t       c; c = c->u.eh_catch.next_catch)\n+\t    val = iterative_hash_hashval_t (hash_eh_region (c), val);\n+        }\n+\tbreak;\n+      case ERT_CATCH:\n+        val = iterative_hash_hashval_t (hash_type_list\n+\t\t\t\t\t  (region->u.eh_catch.type_list), val);\n+        break;\n+      case ERT_ALLOWED_EXCEPTIONS:\n+        val = iterative_hash_hashval_t\n+\t\t(hash_type_list (region->u.allowed.type_list), val);\n+        val = iterative_hash_hashval_t (region->u.allowed.filter, val);\n+\tbreak;\n+      case ERT_THROW:\n+        val |= iterative_hash_hashval_t (TYPE_UID (region->u.eh_throw.type), val);\n+\tbreak;\n+      default:\n+        gcc_unreachable ();\n+    }\n+  return val;\n+}\n+\n+/* Return true if regions R1 and R2 are equal.  */\n+\n+static int\n+eh_regions_equal_p (const void *r1, const void *r2)\n+{\n+  return eh_region_replaceable_by_p ((const struct eh_region *)r1,\n+\t\t\t\t     (const struct eh_region *)r2);\n+}\n+\n+/* Walk all peers of REGION and try to merge those regions\n+   that are semantically equivalent.  Look into subregions\n+   recursively too.  */\n+\n+static bool\n+merge_peers (struct eh_region *region)\n+{\n+  struct eh_region *r1, *r2, *outer = NULL, *next;\n+  bool merged = false;\n+  int num_regions = 0;\n+  if (region)\n+    outer = region->outer;\n+  else\n+    return false;\n+\n+  /* First see if there is inner region equivalent to region\n+     in question.  EH control flow is acyclic so we know we\n+     can merge them.  */\n+  if (outer)\n+    for (r1 = region; r1; r1 = next)\n+      {\n+        next = r1->next_peer;\n+\tif (r1->type == ERT_CATCH)\n+\t  continue;\n+        if (eh_region_replaceable_by_p (r1->outer, r1))\n+\t  {\n+\t    replace_region (r1->outer, r1);\n+\t    merged = true;\n+\t  }\n+\telse\n+\t  num_regions ++;\n+      }\n+\n+  /* Get new first region and try to match the peers\n+     for equivalence.  */\n+  if (outer)\n+    region = outer->inner;\n+  else\n+    region = cfun->eh->region_tree;\n+\n+  /* There are few regions to inspect:\n+     N^2 loop matching each region with each region\n+     will do the job well.  */\n+  if (num_regions < 10)\n+    {\n+      for (r1 = region; r1; r1 = r1->next_peer)\n+\t{\n+\t  if (r1->type == ERT_CATCH)\n+\t    continue;\n+\t  for (r2 = r1->next_peer; r2; r2 = next)\n+\t    {\n+\t      next = r2->next_peer;\n+\t      if (eh_region_replaceable_by_p (r1, r2))\n+\t\t{\n+\t\t  replace_region (r1, r2);\n+\t\t  merged = true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  /* Or use hashtable to avoid N^2 behaviour.  */\n+  else\n+    {\n+      htab_t hash;\n+      hash = htab_create (num_regions, hash_eh_region,\n+\t\t\t  eh_regions_equal_p, NULL);\n+      for (r1 = region; r1; r1 = next)\n+\t{\n+          void **slot;\n+\n+\t  next = r1->next_peer;\n+\t  if (r1->type == ERT_CATCH)\n+\t    continue;\n+\t  slot = htab_find_slot (hash, r1, INSERT);\n+\t  if (!*slot)\n+\t    *slot = r1;\n+\t  else\n+\t    replace_region ((struct eh_region *)*slot, r1);\n+\t}\n+      htab_delete (hash);\n+    }\n+  for (r1 = region; r1; r1 = r1->next_peer)\n+    merged |= merge_peers (r1->inner);\n+  return merged;\n+}\n+\n /* Remove all regions whose labels are not reachable.\n    REACHABLE is bitmap of all regions that are used by the function\n    CONTAINS_STMT is bitmap of all regions that contains stmt (or NULL). */\n@@ -748,6 +981,7 @@ remove_unreachable_regions (sbitmap reachable, sbitmap contains_stmt)\n       else\n \tbring_to_root (r);\n     }\n+  merge_peers (cfun->eh->region_tree);\n #ifdef ENABLE_CHECKING\n   verify_eh_tree (cfun);\n #endif\n@@ -1140,6 +1374,238 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   return eh_offset;\n }\n \n+/* Return new copy of eh region OLD inside region NEW_OUTER.\n+   Do not care about updating the tree otherwise.  */\n+\n+static struct eh_region *\n+copy_eh_region_1 (struct eh_region *old, struct eh_region *new_outer)\n+{\n+  struct eh_region *new_eh = gen_eh_region (old->type, new_outer);\n+  new_eh->u = old->u;\n+  new_eh->tree_label = old->tree_label;\n+  new_eh->may_contain_throw = old->may_contain_throw;\n+  VEC_safe_grow (eh_region, gc, cfun->eh->region_array,\n+\t\t cfun->eh->last_region_number + 1);\n+  VEC_replace (eh_region, cfun->eh->region_array, new_eh->region_number, new_eh);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Copying region %i to %i\\n\", old->region_number, new_eh->region_number);\n+  return new_eh;\n+}\n+\n+/* Return new copy of eh region OLD inside region NEW_OUTER.  \n+  \n+   Copy whole catch-try chain if neccesary and update cleanup region prev_try\n+   pointers.\n+\n+   PREV_TRY_MAP points to outer TRY region if it was copied in trace already.  */\n+\n+static struct eh_region *\n+copy_eh_region (struct eh_region *old, struct eh_region *new_outer,\n+\t\tstruct eh_region *prev_try_map)\n+{\n+  struct eh_region *r, *n, *old_try, *new_try, *ret = NULL;\n+  VEC(eh_region,heap) *catch_list = NULL;\n+\n+  if (old->type != ERT_CATCH)\n+    {\n+      gcc_assert (old->type != ERT_TRY);\n+      r = copy_eh_region_1 (old, new_outer);\n+      if (r->type == ERT_CLEANUP && prev_try_map)\n+        {\n+\t  gcc_assert (r->u.cleanup.prev_try);\n+          r->u.cleanup.prev_try = prev_try_map;\n+\t}\n+      return r;\n+    }\n+\n+  /* Locate and copy corresponding TRY.  */\n+  for (old_try = old->next_peer; old_try->type == ERT_CATCH; old_try = old_try->next_peer)\n+    continue;\n+  gcc_assert (old_try->type == ERT_TRY);\n+  new_try = gen_eh_region_try (new_outer);\n+  new_try->tree_label = old_try->tree_label;\n+  new_try->may_contain_throw = old_try->may_contain_throw;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Copying try-catch regions. Try: %i to %i\\n\",\n+    \t     old_try->region_number, new_try->region_number);\n+  VEC_safe_grow (eh_region, gc, cfun->eh->region_array,\n+\t\t cfun->eh->last_region_number + 1);\n+  VEC_replace (eh_region, cfun->eh->region_array, new_try->region_number, new_try);\n+\n+  /* In order to keep CATCH list in order, we need to copy in reverse order.  */\n+  for (r = old_try->u.eh_try.last_catch; r->type == ERT_CATCH; r = r->next_peer)\n+    VEC_safe_push (eh_region, heap, catch_list, r);\n+\n+  while (VEC_length (eh_region, catch_list))\n+    {\n+      r = VEC_pop (eh_region, catch_list);\n+\n+      /* Duplicate CATCH.  */\n+      n = gen_eh_region_catch (new_try, r->u.eh_catch.type_list);\n+      n->tree_label = r->tree_label;\n+      n->may_contain_throw = r->may_contain_throw;\n+      VEC_safe_grow (eh_region, gc, cfun->eh->region_array,\n+\t\t     cfun->eh->last_region_number + 1);\n+      VEC_replace (eh_region, cfun->eh->region_array, n->region_number, n);\n+      n->tree_label = r->tree_label;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"Copying try-catch regions. Catch: %i to %i\\n\",\n+\t         r->region_number, n->region_number);\n+      if (r == old)\n+\tret = n;\n+    }\n+  VEC_free (eh_region, heap, catch_list);\n+  gcc_assert (ret);\n+  return ret;\n+}\n+\n+/* Callback for forach_reachable_handler that push REGION into single VECtor DATA.  */\n+\n+static void\n+push_reachable_handler (struct eh_region *region, void *data)\n+{\n+  VEC(eh_region,heap) **trace = (VEC(eh_region,heap) **) data;\n+  VEC_safe_push (eh_region, heap, *trace, region);\n+}\n+\n+/* Redirect EH edge E that to NEW_DEST_LABEL.\n+   IS_RESX, INLINABLE_CALL and REGION_NMUBER match the parameter of\n+   foreach_reachable_handler.  */\n+\n+struct eh_region *\n+redirect_eh_edge_to_label (edge e, tree new_dest_label, bool is_resx,\n+\t\t\t   bool inlinable_call, int region_number)\n+{\n+  struct eh_region *outer, *prev_try_map = NULL;\n+  struct eh_region *region;\n+  VEC (eh_region, heap) * trace = NULL;\n+  int i;\n+  int start_here = -1;\n+  basic_block old_bb = e->dest;\n+  struct eh_region *old, *r = NULL;\n+  bool update_inplace = true;\n+  edge_iterator ei;\n+  edge e2;\n+\n+  /* If there is only one EH edge, we don't need to duplicate;\n+     just update labels in the tree.  */\n+  FOR_EACH_EDGE (e2, ei, old_bb->preds)\n+    if ((e2->flags & EDGE_EH) && e2 != e)\n+      {\n+        update_inplace = false;\n+        break;\n+      }\n+\n+  region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n+  gcc_assert (region);\n+\n+  foreach_reachable_handler (region_number, is_resx, inlinable_call,\n+\t\t\t     push_reachable_handler, &trace);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      dump_eh_tree (dump_file, cfun);\n+      fprintf (dump_file, \"Trace: \");\n+      for (i = 0; i < (int) VEC_length (eh_region, trace); i++)\n+\tfprintf (dump_file, \" %i\", VEC_index (eh_region, trace, i)->region_number);\n+      fprintf (dump_file, \" inplace: %i\\n\", update_inplace);\n+    }\n+\n+  if (update_inplace)\n+    {\n+      /* In easy route just walk trace and update all occurences of the label.  */\n+      for (i = 0; i < (int) VEC_length (eh_region, trace); i++)\n+\t{\n+\t  r = VEC_index (eh_region, trace, i);\n+\t  if (r->tree_label && label_to_block (r->tree_label) == old_bb)\n+\t    {\n+\t      r->tree_label = new_dest_label;\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Updating label for region %i\\n\",\n+\t\t\t r->region_number);\n+\t    }\n+\t}\n+      r = region;\n+    }\n+  else\n+    {\n+      /* Now look for outermost handler that reffers to the basic block in question.\n+         We start our duplication there.  */\n+      for (i = 0; i < (int) VEC_length (eh_region, trace); i++)\n+\t{\n+\t  r = VEC_index (eh_region, trace, i);\n+\t  if (r->tree_label && label_to_block (r->tree_label) == old_bb)\n+\t    start_here = i;\n+\t}\n+      outer = VEC_index (eh_region, trace, start_here)->outer;\n+      gcc_assert (start_here >= 0);\n+\n+      /* And now do the dirty job!  */\n+      for (i = start_here; i >= 0; i--)\n+\t{\n+\t  old = VEC_index (eh_region, trace, i);\n+\t  gcc_assert (!outer || old->outer != outer->outer);\n+\n+\t  /* Copy region and update label.  */\n+\t  r = copy_eh_region (old, outer, prev_try_map);\n+\t  VEC_replace (eh_region, trace, i, r);\n+\t  if (r->tree_label && label_to_block (r->tree_label) == old_bb)\n+\t    {\n+\t      r->tree_label = new_dest_label;\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Updating label for region %i\\n\",\n+\t\t\t r->region_number);\n+\t    }\n+\n+\t  /* We got into copying CATCH.  copy_eh_region already did job\n+\t     of copying all catch blocks corresponding to the try.  Now\n+\t     we need to update labels in all of them and see trace.\n+\n+\t     We continue nesting into TRY region corresponding to CATCH:\n+\t     When duplicating EH tree contaiing subregions of CATCH,\n+\t     the CATCH region itself is never inserted to trace so we\n+\t     never get here anyway.  */\n+\t  if (r->type == ERT_CATCH)\n+\t    {\n+\t      /* Walk other catch regions we copied and update labels as needed.  */\n+\t      for (r = r->next_peer; r->type == ERT_CATCH; r = r->next_peer)\n+\t\tif (r->tree_label && label_to_block (r->tree_label) == old_bb)\n+\t\t  {\n+\t\t    r->tree_label = new_dest_label;\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      fprintf (dump_file, \"Updating label for region %i\\n\",\n+\t\t\t       r->region_number);\n+\t\t  }\n+\t       gcc_assert (r->type == ERT_TRY);\n+\n+\t       /* Skip sibling catch regions from the trace.\n+\t\t  They are already updated.  */\n+\t       while (i > 0 && VEC_index (eh_region, trace, i - 1)->outer == old->outer)\n+\t\t {\n+\t\t   gcc_assert (VEC_index (eh_region, trace, i - 1)->type == ERT_CATCH);\n+\t\t   i--;\n+\t\t }\n+\t     }\n+\n+\t  /* Cleanup regions points to outer TRY blocks.  */\n+\t  if (r->type == ERT_TRY)\n+\t    prev_try_map = r;\n+\t  outer = r;\n+\t}\n+        \n+      if (is_resx || region->type == ERT_THROW)\n+\tr = copy_eh_region (region, outer, prev_try_map);\n+    }\n+\n+  VEC_free (eh_region, heap, trace);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      dump_eh_tree (dump_file, cfun);\n+      fprintf (dump_file, \"New region: %i\\n\", r->region_number);\n+    }\n+  return r;\n+}\n+\n /* Return region number of region that is outer to both if REGION_A and\n    REGION_B in IFUN.  */\n \n@@ -1478,6 +1944,12 @@ build_post_landing_pads (void)\n       switch (region->type)\n \t{\n \tcase ERT_TRY:\n+\t  /* It is possible that TRY region is kept alive only because some of\n+\t     contained catch region still have RESX instruction but they are\n+\t     reached via their copies.  In this case we need to do nothing.  */\n+\t  if (!region->u.eh_try.eh_catch->label)\n+\t    break;\n+\n \t  /* ??? Collect the set of all non-overlapping catch handlers\n \t       all the way up the chain until blocked by a cleanup.  */\n \t  /* ??? Outer try regions can share landing pads with inner\n@@ -1537,6 +2009,8 @@ build_post_landing_pads (void)\n \t  break;\n \n \tcase ERT_ALLOWED_EXCEPTIONS:\n+\t  if (!region->label)\n+\t    break;\n \t  region->post_landing_pad = gen_label_rtx ();\n \n \t  start_sequence ();\n@@ -1679,6 +2153,9 @@ dw2_build_landing_pads (void)\n \t  && region->type != ERT_ALLOWED_EXCEPTIONS)\n \tcontinue;\n \n+      if (!region->post_landing_pad)\n+\tcontinue;\n+\n       start_sequence ();\n \n       region->landing_pad = gen_label_rtx ();"}, {"sha": "50d6b314efdf8579b67073a5f790217c5fff4bbc", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -278,4 +278,5 @@ extern void set_eh_throw_stmt_table (struct function *, struct htab *);\n extern void remove_unreachable_regions (sbitmap, sbitmap);\n extern VEC(int,heap) * label_to_region_map (void);\n extern int num_eh_regions (void);\n+extern struct eh_region *redirect_eh_edge_to_label (struct edge_def *, tree, bool, bool, int);\n extern int get_next_region_sharing_label (int);"}, {"sha": "c05006b84425d06f73f4d997999a0e6a02faea6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -1,3 +1,7 @@\n+2009-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* g++.dg/tree-ssa/ehcleanup-1.C: Update.\n+\n 2009-04-25  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/39688"}, {"sha": "3de72aac590e069475e447ff1d09a54d87f69f79", "filename": "gcc/testsuite/g++.dg/tree-ssa/ehcleanup-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -1,4 +1,4 @@\n-// { dg-options \"-O2 -fdump-tree-ehcleanup1\" }\n+// { dg-options \"-O2 -fdump-tree-ehcleanup1-details\" }\n extern void can_throw ();\n class a\n {"}, {"sha": "329932dd314fba0db58f0afb22219176640aa4aa", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -4800,6 +4800,9 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->dest == dest)\n     return NULL;\n \n+  if (e->flags & EDGE_EH)\n+    return redirect_eh_edge (e, dest);\n+\n   gsi = gsi_last_bb (bb);\n   stmt = gsi_end_p (gsi) ? NULL : gsi_stmt (gsi);\n "}, {"sha": "80014e1129244190b5a3b5975b86d790d674b296", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -1962,7 +1962,7 @@ make_eh_edge (struct eh_region *region, void *data)\n   src = gimple_bb (stmt);\n   dst = label_to_block (lab);\n \n-  make_edge (src, dst, EDGE_ABNORMAL | EDGE_EH);\n+  make_edge (src, dst, EDGE_EH);\n }\n \n /* See if STMT is call that might be inlined.  */\n@@ -2019,6 +2019,50 @@ make_eh_edges (gimple stmt)\n     EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n }\n \n+/* Redirect EH edge E to NEW_BB.  */\n+\n+edge\n+redirect_eh_edge (edge e, basic_block new_bb)\n+{\n+  gimple stmt = gsi_stmt (gsi_last_bb (e->src));\n+  int region_nr, new_region_nr;\n+  bool is_resx;\n+  bool inlinable = false;\n+  tree label = gimple_block_label (new_bb);\n+  struct eh_region *r;\n+\n+  if (gimple_code (stmt) == GIMPLE_RESX)\n+    {\n+      region_nr = gimple_resx_region (stmt);\n+      is_resx = true;\n+    }\n+  else\n+    {\n+      region_nr = lookup_stmt_eh_region (stmt);\n+      gcc_assert (region_nr >= 0);\n+      is_resx = false;\n+      inlinable = inlinable_call_p (stmt);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Redirecting EH edge %i->%i to %i, region %i, resx %i\\n\",\n+\t     e->src->index, e->dest->index, new_bb->index, region_nr, is_resx);\n+  r = redirect_eh_edge_to_label (e, label, is_resx, inlinable, region_nr);\n+  new_region_nr = get_eh_region_number (r);\n+  if (new_region_nr != region_nr)\n+    {\n+      if (is_resx)\n+        gimple_resx_set_region (stmt, new_region_nr);\n+      else\n+        {\n+\t  remove_stmt_from_eh_region (stmt);\n+\t  add_stmt_to_eh_region (stmt, new_region_nr);\n+        }\n+    }\n+  e = ssa_redirect_edge (e, new_bb);\n+  return e;\n+}\n+\n static bool mark_eh_edge_found_error;\n \n /* Mark edge make_eh_edge would create for given region by setting it aux\n@@ -2702,7 +2746,9 @@ tree_remove_unreachable_handlers (void)\n \t      SET_BIT (reachable, region);\n \t  }\n \tif (gimple_code (stmt) == GIMPLE_RESX)\n-\t  SET_BIT (reachable, gimple_resx_region (stmt));\n+\t  SET_BIT (reachable,\n+\t  \t   VEC_index (eh_region, cfun->eh->region_array,\n+\t\t   \t      gimple_resx_region (stmt))->region_number);\n \tif ((region = lookup_stmt_eh_region (stmt)) >= 0)\n \t  SET_BIT (contains_stmt, region);\n       }\n@@ -2937,7 +2983,7 @@ make_eh_edge_and_update_phi (struct eh_region *region, void *data)\n     }\n   dominance_info_invalidated = true;\n   e2 = find_edge (info->bb_to_remove, dst);\n-  e = make_edge (src, dst, EDGE_ABNORMAL | EDGE_EH);\n+  e = make_edge (src, dst, EDGE_EH);\n   e->aux = e;\n   gcc_assert (e2);\n   for (si = gsi_start_phis (dst); !gsi_end_p (si); gsi_next (&si))\n@@ -3091,7 +3137,11 @@ cleanup_empty_eh (basic_block bb, VEC(int,heap) * label_to_region)\n \t is really dead.  */\n \n       if (found && !has_non_eh_preds)\n-        remove_eh_region (region);\n+        {\n+\t   if (dump_file && (dump_flags & TDF_DETAILS))\n+\t     fprintf (dump_file, \"Empty EH handler %i removed.\\n\", region);\n+          remove_eh_region (region);\n+\t}\n       else if (!removed_some)\n         return false;\n "}, {"sha": "8cb69acfa5603534c6c304b3c82dbbff01235c4b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -32,13 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-reference.h\"\n #include \"tree-ssa-alias.h\"\n \n-/* Forward declare structures for the garbage collector GTY markers.  */\n-#ifndef GCC_BASIC_BLOCK_H\n-struct edge_def;\n-typedef struct edge_def *edge;\n-struct basic_block_def;\n-typedef struct basic_block_def *basic_block;\n-#endif\n struct static_var_ann_d;\n \n \n@@ -974,5 +967,6 @@ unsigned int execute_fixup_cfg (void);\n void swap_tree_operands (gimple, tree *, tree *);\n \n int least_common_multiple (int, int);\n+edge redirect_eh_edge (edge e, basic_block new_bb);\n \n #endif /* _TREE_FLOW_H  */"}, {"sha": "57e1d3210a895ccea4cc15bcf97c4f7b1ed7a2f2", "filename": "gcc/tree.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -9320,4 +9320,16 @@ block_ultimate_origin (const_tree block)\n     }\n }\n \n+/* Return true if T1 and T2 are equivalent lists.  */\n+\n+bool\n+list_equal_p (const_tree t1, const_tree t2)\n+{\n+  for (; t1 && t2; t1 = TREE_CHAIN (t1) , t2 = TREE_CHAIN (t2))\n+    if (TREE_VALUE (t1) != TREE_VALUE (t2))\n+      return false;\n+  return !t1 && !t2;\n+}\n+\n+\n #include \"gt-tree.h\""}, {"sha": "4cd9b7d7fc10ba96e7fb45bff91facd0e8dfa41b", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3710436b62ad4c025de1b3b5a97e6d3eb820edf/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a3710436b62ad4c025de1b3b5a97e6d3eb820edf", "patch": "@@ -5134,6 +5134,7 @@ struct GTY(()) tree_map_base {\n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);\n extern int tree_map_base_marked_p (const void *);\n+extern bool list_equal_p (const_tree, const_tree);\n \n /* Map from a tree to another tree.  */\n "}]}