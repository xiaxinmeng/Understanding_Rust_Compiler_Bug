{"sha": "fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMyN2QxMDIzY2QyYTFiM2NlYTFkZDkxYWQ5ZWU2NzQ4YzlkYWY5YQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-08-16T23:59:56Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-08-16T23:59:56Z"}, "message": "* config/sparc/sparc.c: Convert to ISO C.\n\nFrom-SVN: r70510", "tree": {"sha": "d9c9fc17fceb76222c0474572c815a164da96e74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9c9fc17fceb76222c0474572c815a164da96e74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a/comments", "author": null, "committer": null, "parents": [{"sha": "e80d5f80615dc448aede518ad9bd29c273af4eb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80d5f80615dc448aede518ad9bd29c273af4eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80d5f80615dc448aede518ad9bd29c273af4eb2"}], "stats": {"total": 705, "additions": 207, "deletions": 498}, "files": [{"sha": "a6ae987f32bd46d55ebe9e98801d60aadd9a1784", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a", "patch": "@@ -1,5 +1,7 @@\n 2003-08-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n+\t* config/sparc/sparc.c: Convert to ISO C.\n+\n \t* config/sparc/sparc-protos.h: Don't use the PARAMS macro.\n \t* config/sparc/sparc.c: Likewise.\n "}, {"sha": "b095a007bb889cb683da350a54f248fc1cffd329", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 205, "deletions": 498, "changes": 703, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=fc27d1023cd2a1b3cea1dd91ad9ee6748c9daf9a", "patch": "@@ -256,7 +256,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n    initialization.  */\n \n void\n-sparc_override_options ()\n+sparc_override_options (void)\n {\n   static struct code_model {\n     const char *const name;\n@@ -456,8 +456,7 @@ sparc_override_options ()\n    or branch on register contents instructions.  */\n \n int\n-v9_regcmp_p (code)\n-     enum rtx_code code;\n+v9_regcmp_p (enum rtx_code code)\n {\n   return (code == EQ || code == NE || code == GE || code == LT\n \t  || code == LE || code == GT);\n@@ -470,9 +469,7 @@ v9_regcmp_p (code)\n    or const0_rtx.  */\n \n int\n-reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -490,19 +487,15 @@ reg_or_0_operand (op, mode)\n /* Return nonzero only if OP is const1_rtx.  */\n \n int\n-const1_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+const1_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return op == const1_rtx;\n }\n \n /* Nonzero if OP is a floating point value with value 0.0.  */\n \n int\n-fp_zero_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fp_zero_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE_CLASS (GET_MODE (op)) != MODE_FLOAT)\n     return 0;\n@@ -512,9 +505,7 @@ fp_zero_operand (op, mode)\n /* Nonzero if OP is a register operand in floating point register.  */\n \n int\n-fp_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fp_register_operand (rtx op, enum machine_mode mode)\n {\n   if (! register_operand (op, mode))\n     return 0;\n@@ -528,8 +519,7 @@ fp_register_operand (op, mode)\n    sethi instruction.  */\n \n int\n-fp_sethi_p (op)\n-     rtx op;\n+fp_sethi_p (rtx op)\n {\n   if (GET_CODE (op) == CONST_DOUBLE)\n     {\n@@ -553,8 +543,7 @@ fp_sethi_p (op)\n    mov instruction.  */\n \n int\n-fp_mov_p (op)\n-     rtx op;\n+fp_mov_p (rtx op)\n {\n   if (GET_CODE (op) == CONST_DOUBLE)\n     {\n@@ -578,8 +567,7 @@ fp_mov_p (op)\n    instruction sequence.  */\n \n int\n-fp_high_losum_p (op)\n-     rtx op;\n+fp_high_losum_p (rtx op)\n {\n   /* The constraints calling this should only be in\n      SFmode move insns, so any constant which cannot\n@@ -605,9 +593,7 @@ fp_high_losum_p (op)\n /* Nonzero if OP is an integer register.  */\n \n int\n-intreg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+intreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (register_operand (op, SImode)\n \t  || (TARGET_ARCH64 && register_operand (op, DImode)));\n@@ -616,9 +602,7 @@ intreg_operand (op, mode)\n /* Nonzero if OP is a floating point condition code register.  */\n \n int\n-fcc_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fcc_reg_operand (rtx op, enum machine_mode mode)\n {\n   /* This can happen when recog is called from combine.  Op may be a MEM.\n      Fail instead of calling abort in this case.  */\n@@ -643,9 +627,7 @@ fcc_reg_operand (op, mode)\n /* Nonzero if OP is a floating point condition code fcc0 register.  */\n \n int\n-fcc0_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fcc0_reg_operand (rtx op, enum machine_mode mode)\n {\n   /* This can happen when recog is called from combine.  Op may be a MEM.\n      Fail instead of calling abort in this case.  */\n@@ -664,9 +646,7 @@ fcc0_reg_operand (op, mode)\n /* Nonzero if OP is an integer or floating point condition code register.  */\n \n int\n-icc_or_fcc_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+icc_or_fcc_reg_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == REG && REGNO (op) == SPARC_ICC_REG)\n     {\n@@ -683,9 +663,7 @@ icc_or_fcc_reg_operand (op, mode)\n \n /* Nonzero if OP can appear as the dest of a RESTORE insn.  */\n int\n-restore_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+restore_operand (rtx op, enum machine_mode mode)\n {\n   return (GET_CODE (op) == REG && GET_MODE (op) == mode\n \t  && (REGNO (op) < 8 || (REGNO (op) >= 24 && REGNO (op) < 32)));\n@@ -695,9 +673,7 @@ restore_operand (op, mode)\n    memory address.  */\n \n int\n-call_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != MEM)\n     abort ();\n@@ -706,9 +682,7 @@ call_operand (op, mode)\n }\n \n int\n-call_operand_address (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_operand_address (rtx op, enum machine_mode mode)\n {\n   return (symbolic_operand (op, mode) || memory_address_p (Pmode, op));\n }\n@@ -717,9 +691,7 @@ call_operand_address (op, mode)\n    reference and a constant.  */\n \n int\n-symbolic_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+symbolic_operand (register rtx op, enum machine_mode mode)\n {\n   enum machine_mode omode = GET_MODE (op);\n \n@@ -747,9 +719,7 @@ symbolic_operand (op, mode)\n    operand of mode MODE.  */\n \n int\n-symbolic_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+symbolic_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -763,9 +733,7 @@ symbolic_memory_operand (op, mode)\n /* Return truth value of statement that OP is a LABEL_REF of mode MODE.  */\n \n int\n-label_ref_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+label_ref_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != LABEL_REF)\n     return 0;\n@@ -778,9 +746,7 @@ label_ref_operand (op, mode)\n    in either the medium/low or medium/anywhere code models of sparc64.  */\n \n int\n-sp64_medium_pic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+sp64_medium_pic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   /* Check for (const (minus (symbol_ref:GOT)\n                              (const (minus (label) (pc))))).  */\n@@ -805,9 +771,7 @@ sp64_medium_pic_operand (op, mode)\n    are accessed with EMBMEDANY_BASE_REG.  */\n \n int\n-data_segment_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+data_segment_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -827,9 +791,7 @@ data_segment_operand (op, mode)\n    This is needed in the medium/anywhere code model on v9.  */\n \n int\n-text_segment_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+text_segment_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -851,9 +813,7 @@ text_segment_operand (op, mode)\n    not symbolic.  */\n \n int\n-reg_or_nonsymb_mem_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+reg_or_nonsymb_mem_operand (register rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -865,9 +825,8 @@ reg_or_nonsymb_mem_operand (op, mode)\n }\n \n int\n-splittable_symbolic_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+splittable_symbolic_memory_operand (rtx op,\n+\t\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != MEM)\n     return 0;\n@@ -877,9 +836,8 @@ splittable_symbolic_memory_operand (op, mode)\n }\n \n int\n-splittable_immediate_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+splittable_immediate_memory_operand (rtx op,\n+\t\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != MEM)\n     return 0;\n@@ -891,9 +849,7 @@ splittable_immediate_memory_operand (op, mode)\n /* Return truth value of whether OP is EQ or NE.  */\n \n int\n-eq_or_neq (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+eq_or_neq (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n }\n@@ -902,9 +858,7 @@ eq_or_neq (op, mode)\n    or LTU for non-floating-point.  We handle those specially.  */\n \n int\n-normal_comp_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+normal_comp_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -922,9 +876,7 @@ normal_comp_operator (op, mode)\n    MATCH_OPERATOR to recognize all the branch insns.  */\n \n int\n-noov_compare_op (op, mode)\n-    register rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+noov_compare_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -942,9 +894,7 @@ noov_compare_op (op, mode)\n    MATCH_OPERATOR to recognize all the branch insns.  */\n \n int\n-noov_compare64_op (op, mode)\n-    register rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+noov_compare64_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -964,9 +914,7 @@ noov_compare64_op (op, mode)\n    conditional move or branch on register contents instructions.  */\n \n int\n-v9_regcmp_op (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+v9_regcmp_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -979,9 +927,7 @@ v9_regcmp_op (op, mode)\n /* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */\n \n int\n-extend_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+extend_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == SIGN_EXTEND || GET_CODE (op) == ZERO_EXTEND;\n }\n@@ -991,9 +937,7 @@ extend_op (op, mode)\n    because these require CC_NOOVmode, which we handle explicitly.  */\n \n int\n-cc_arithop (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+cc_arithop (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == AND\n       || GET_CODE (op) == IOR\n@@ -1007,9 +951,7 @@ cc_arithop (op, mode)\n    complement its second operand and set the condition codes explicitly.  */\n \n int\n-cc_arithopn (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+cc_arithopn (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   /* XOR is not here because combine canonicalizes (xor (not ...) ...)\n      and (xor ... (not ...)) to (not (xor ...)).  */\n@@ -1022,9 +964,7 @@ cc_arithopn (op, mode)\n    most 3 address instructions.  */\n \n int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1036,9 +976,7 @@ arith_operand (op, mode)\n /* Return true if OP is a constant 4096  */\n \n int\n-arith_4096_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+arith_4096_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -1049,9 +987,7 @@ arith_4096_operand (op, mode)\n /* Return true if OP is suitable as second operand for add/sub */\n \n int\n-arith_add_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_add_operand (rtx op, enum machine_mode mode)\n {\n   return arith_operand (op, mode) || arith_4096_operand (op, mode);\n }\n@@ -1060,9 +996,7 @@ arith_add_operand (op, mode)\n    immediate field of OR and XOR instructions.  Used for 64-bit\n    constant formation patterns.  */\n int\n-const64_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+const64_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && SPARC_SIMM13_P (INTVAL (op)))\n@@ -1078,9 +1012,7 @@ const64_operand (op, mode)\n \n /* The same, but only for sethi instructions.  */\n int\n-const64_high_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+const64_high_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && (INTVAL (op) & ~(HOST_WIDE_INT)0x3ff) != 0\n@@ -1097,9 +1029,7 @@ const64_high_operand (op, mode)\n    the movcc instructions.  */\n \n int\n-arith11_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith11_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && SPARC_SIMM11_P (INTVAL (op))));\n@@ -1110,9 +1040,7 @@ arith11_operand (op, mode)\n    the movrcc instructions.  */\n \n int\n-arith10_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith10_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && SPARC_SIMM10_P (INTVAL (op))));\n@@ -1126,9 +1054,7 @@ arith10_operand (op, mode)\n    for most 3 address instructions.  */\n \n int\n-arith_double_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_double_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n@@ -1148,9 +1074,7 @@ arith_double_operand (op, mode)\n /* Return true if OP is a constant 4096 for DImode on ARCH64 */\n \n int\n-arith_double_4096_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+arith_double_4096_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (TARGET_ARCH64 &&\n   \t  ((GET_CODE (op) == CONST_INT && INTVAL (op) == 4096) ||\n@@ -1162,9 +1086,7 @@ arith_double_4096_operand (op, mode)\n /* Return true if OP is suitable as second operand for add/sub in DImode */\n \n int\n-arith_double_add_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_double_add_operand (rtx op, enum machine_mode mode)\n {\n   return arith_double_operand (op, mode) || arith_double_4096_operand (op, mode);\n }\n@@ -1175,9 +1097,7 @@ arith_double_add_operand (op, mode)\n /* ??? Replace with arith11_operand?  */\n \n int\n-arith11_double_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith11_double_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_DOUBLE\n@@ -1198,9 +1118,7 @@ arith11_double_operand (op, mode)\n /* ??? Replace with arith10_operand?  */\n \n int\n-arith10_double_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith10_double_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_DOUBLE\n@@ -1220,17 +1138,13 @@ arith10_double_operand (op, mode)\n    which have a 13 bit immediate field.  */\n \n int\n-small_int (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n }\n \n int\n-small_int_or_double (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_int_or_double (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ((GET_CODE (op) == CONST_INT && SMALL_INT (op))\n \t  || (GET_CODE (op) == CONST_DOUBLE\n@@ -1243,9 +1157,7 @@ small_int_or_double (op, mode)\n    interprets the extended result as an unsigned number.  */\n \n int\n-uns_small_int (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+uns_small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n #if HOST_BITS_PER_WIDE_INT > 32\n   /* All allowed constants will fit a CONST_INT.  */\n@@ -1262,28 +1174,22 @@ uns_small_int (op, mode)\n }\n \n int\n-uns_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+uns_arith_operand (rtx op, enum machine_mode mode)\n {\n   return register_operand (op, mode) || uns_small_int (op, mode);\n }\n \n /* Return truth value of statement that OP is a call-clobbered register.  */\n int\n-clobbered_register (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+clobbered_register (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == REG && call_used_regs[REGNO (op)]);\n }\n \n /* Return 1 if OP is a valid operand for the source of a move insn.  */\n \n int\n-input_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+input_operand (rtx op, enum machine_mode mode)\n {\n   /* If both modes are non-void they must be the same.  */\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n@@ -1365,9 +1271,7 @@ input_operand (op, mode)\n /* We know it can't be done in one insn when we get here,\n    the movsi expander guarantees this.  */\n void\n-sparc_emit_set_const32 (op0, op1)\n-     rtx op0;\n-     rtx op1;\n+sparc_emit_set_const32 (rtx op0, rtx op1)\n {\n   enum machine_mode mode = GET_MODE (op0);\n   rtx temp;\n@@ -1423,10 +1327,7 @@ sparc_emit_set_const32 (op0, op1)\n \f\n /* SPARC-v9 code-model support.  */\n void\n-sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n-     rtx op0;\n-     rtx op1;\n-     rtx temp1;\n+sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp1)\n {\n   rtx ti_temp1 = 0;\n \n@@ -1588,33 +1489,25 @@ static rtx gen_safe_XOR64 (rtx, HOST_WIDE_INT);\n    during CSE.  We mask out the non-HIGH bits, and matches\n    a plain movdi, to alleviate this problem.  */\n static void\n-sparc_emit_set_safe_HIGH64 (dest, val)\n-     rtx dest;\n-     HOST_WIDE_INT val;\n+sparc_emit_set_safe_HIGH64 (rtx dest, HOST_WIDE_INT val)\n {\n   emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_HIGHINT64 (val)));\n }\n \n static rtx\n-gen_safe_SET64 (dest, val)\n-     rtx dest;\n-     HOST_WIDE_INT val;\n+gen_safe_SET64 (rtx dest, HOST_WIDE_INT val)\n {\n   return gen_rtx_SET (VOIDmode, dest, GEN_INT64 (val));\n }\n \n static rtx\n-gen_safe_OR64 (src, val)\n-     rtx src;\n-     HOST_WIDE_INT val;\n+gen_safe_OR64 (rtx src, HOST_WIDE_INT val)\n {\n   return gen_rtx_IOR (DImode, src, GEN_INT64 (val));\n }\n \n static rtx\n-gen_safe_XOR64 (src, val)\n-     rtx src;\n-     HOST_WIDE_INT val;\n+gen_safe_XOR64 (rtx src, HOST_WIDE_INT val)\n {\n   return gen_rtx_XOR (DImode, src, GEN_INT64 (val));\n }\n@@ -1631,11 +1524,8 @@ static void sparc_emit_set_const64_quick1 (rtx, rtx,\n \t\t\t\t\t   unsigned HOST_WIDE_INT, int);\n \n static void\n-sparc_emit_set_const64_quick1 (op0, temp, low_bits, is_neg)\n-  rtx op0;\n-  rtx temp;\n-  unsigned HOST_WIDE_INT low_bits;\n-  int is_neg;\n+sparc_emit_set_const64_quick1 (rtx op0, rtx temp,\n+\t\t\t       unsigned HOST_WIDE_INT low_bits, int is_neg)\n {\n   unsigned HOST_WIDE_INT high_bits;\n \n@@ -1674,12 +1564,10 @@ static void sparc_emit_set_const64_quick2 (rtx, rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t\t   unsigned HOST_WIDE_INT, int);\n \n static void\n-sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_immediate, shift_count)\n-  rtx op0;\n-  rtx temp;\n-  unsigned HOST_WIDE_INT high_bits;\n-  unsigned HOST_WIDE_INT low_immediate;\n-  int shift_count;\n+sparc_emit_set_const64_quick2 (rtx op0, rtx temp,\n+\t\t\t       unsigned HOST_WIDE_INT high_bits,\n+\t\t\t       unsigned HOST_WIDE_INT low_immediate,\n+\t\t\t       int shift_count)\n {\n   rtx temp2 = op0;\n \n@@ -1716,11 +1604,9 @@ static void sparc_emit_set_const64_longway (rtx, rtx, unsigned HOST_WIDE_INT,\n /* Full 64-bit constant decomposition.  Even though this is the\n    'worst' case, we still optimize a few things away.  */\n static void\n-sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n-     rtx op0;\n-     rtx temp;\n-     unsigned HOST_WIDE_INT high_bits;\n-     unsigned HOST_WIDE_INT low_bits;\n+sparc_emit_set_const64_longway (rtx op0, rtx temp,\n+\t\t\t\tunsigned HOST_WIDE_INT high_bits,\n+\t\t\t\tunsigned HOST_WIDE_INT low_bits)\n {\n   rtx sub_temp;\n \n@@ -1823,9 +1709,9 @@ static void analyze_64bit_constant (unsigned HOST_WIDE_INT,\n \t\t\t\t    int *, int *, int *);\n \n static void\n-analyze_64bit_constant (high_bits, low_bits, hbsp, lbsp, abbasp)\n-     unsigned HOST_WIDE_INT high_bits, low_bits;\n-     int *hbsp, *lbsp, *abbasp;\n+analyze_64bit_constant (unsigned HOST_WIDE_INT high_bits,\n+\t\t\tunsigned HOST_WIDE_INT low_bits,\n+\t\t\tint *hbsp, int *lbsp, int *abbasp)\n {\n   int lowest_bit_set, highest_bit_set, all_bits_between_are_set;\n   int i;\n@@ -1889,8 +1775,8 @@ analyze_64bit_constant (high_bits, low_bits, hbsp, lbsp, abbasp)\n static int const64_is_2insns (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT);\n \n static int\n-const64_is_2insns (high_bits, low_bits)\n-     unsigned HOST_WIDE_INT high_bits, low_bits;\n+const64_is_2insns (unsigned HOST_WIDE_INT high_bits,\n+\t\t   unsigned HOST_WIDE_INT low_bits)\n {\n   int highest_bit_set, lowest_bit_set, all_bits_between_are_set;\n \n@@ -1918,9 +1804,9 @@ static unsigned HOST_WIDE_INT create_simple_focus_bits (unsigned HOST_WIDE_INT,\n \t\t\t\t\t\t\tint, int);\n \n static unsigned HOST_WIDE_INT\n-create_simple_focus_bits (high_bits, low_bits, lowest_bit_set, shift)\n-     unsigned HOST_WIDE_INT high_bits, low_bits;\n-     int lowest_bit_set, shift;\n+create_simple_focus_bits (unsigned HOST_WIDE_INT high_bits,\n+\t\t\t  unsigned HOST_WIDE_INT low_bits,\n+\t\t\t  int lowest_bit_set, int shift)\n {\n   HOST_WIDE_INT hi, lo;\n \n@@ -1944,9 +1830,7 @@ create_simple_focus_bits (high_bits, low_bits, lowest_bit_set, shift)\n    insn sequence possible.  Detection of all the 1-insn cases\n    has been done already.  */\n void\n-sparc_emit_set_const64 (op0, op1)\n-     rtx op0;\n-     rtx op1;\n+sparc_emit_set_const64 (rtx op0, rtx op1)\n {\n   unsigned HOST_WIDE_INT high_bits, low_bits;\n   int lowest_bit_set, highest_bit_set;\n@@ -2224,10 +2108,7 @@ sparc_emit_set_const64 (op0, op1)\n    processing is needed.  */\n \n enum machine_mode\n-select_cc_mode (op, x, y)\n-     enum rtx_code op;\n-     rtx x;\n-     rtx y ATTRIBUTE_UNUSED;\n+select_cc_mode (enum rtx_code op, rtx x, rtx y ATTRIBUTE_UNUSED)\n {\n   if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n     {\n@@ -2276,9 +2157,7 @@ select_cc_mode (op, x, y)\n    return the rtx for the cc reg in the proper mode.  */\n \n rtx\n-gen_compare_reg (code, x, y)\n-     enum rtx_code code;\n-     rtx x, y;\n+gen_compare_reg (enum rtx_code code, rtx x, rtx y)\n {\n   enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n   rtx cc_reg;\n@@ -2359,9 +2238,7 @@ gen_compare_reg (code, x, y)\n    sparc_compare_op1.  */\n \n int\n-gen_v9_scc (compare_code, operands)\n-     enum rtx_code compare_code;\n-     register rtx *operands;\n+gen_v9_scc (enum rtx_code compare_code, register rtx *operands)\n {\n   rtx temp, op0, op1;\n \n@@ -2449,9 +2326,7 @@ gen_v9_scc (compare_code, operands)\n    This function exists to take advantage of the v9 brxx insns.  */\n \n void\n-emit_v9_brxx_insn (code, op0, label)\n-     enum rtx_code code;\n-     rtx op0, label;\n+emit_v9_brxx_insn (enum rtx_code code, rtx op0, rtx label)\n {\n   emit_jump_insn (gen_rtx_SET (VOIDmode,\n \t\t\t   pc_rtx,\n@@ -2467,9 +2342,7 @@ emit_v9_brxx_insn (code, op0, label)\n    low 64bit of the register and 0 otherwise.\n  */\n rtx\n-gen_df_reg (reg, low)\n-     rtx reg;\n-     int low;\n+gen_df_reg (rtx reg, int low)\n {\n   int regno = REGNO (reg);\n \n@@ -2483,10 +2356,7 @@ gen_df_reg (reg, low)\n    assumed that no more than 3 operands are required.  */\n \n static void\n-emit_soft_tfmode_libcall (func_name, nargs, operands)\n-     const char *func_name;\n-     int nargs;\n-     rtx *operands;\n+emit_soft_tfmode_libcall (const char *func_name, int nargs, rtx *operands)\n {\n   rtx ret_slot = NULL, arg[3], func_sym;\n   int i;\n@@ -2571,9 +2441,7 @@ emit_soft_tfmode_libcall (func_name, nargs, operands)\n /* Expand soft-float TFmode calls to sparc abi routines.  */\n \n static void\n-emit_soft_tfmode_binop (code, operands)\n-     enum rtx_code code;\n-     rtx *operands;\n+emit_soft_tfmode_binop (enum rtx_code code, rtx *operands)\n {\n   const char *func;\n \n@@ -2599,9 +2467,7 @@ emit_soft_tfmode_binop (code, operands)\n }\n \n static void\n-emit_soft_tfmode_unop (code, operands)\n-     enum rtx_code code;\n-     rtx *operands;\n+emit_soft_tfmode_unop (enum rtx_code code, rtx *operands)\n {\n   const char *func;\n \n@@ -2618,9 +2484,7 @@ emit_soft_tfmode_unop (code, operands)\n }\n \n static void\n-emit_soft_tfmode_cvt (code, operands)\n-     enum rtx_code code;\n-     rtx *operands;\n+emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n {\n   const char *func;\n \n@@ -2721,9 +2585,7 @@ emit_soft_tfmode_cvt (code, operands)\n    registers.  */\n \n static void\n-emit_hard_tfmode_operation (code, operands)\n-     enum rtx_code code;\n-     rtx *operands;\n+emit_hard_tfmode_operation (enum rtx_code code, rtx *operands)\n {\n   rtx op, dest;\n \n@@ -2752,9 +2614,7 @@ emit_hard_tfmode_operation (code, operands)\n }\n \n void\n-emit_tfmode_binop (code, operands)\n-     enum rtx_code code;\n-     rtx *operands;\n+emit_tfmode_binop (enum rtx_code code, rtx *operands)\n {\n   if (TARGET_HARD_QUAD)\n     emit_hard_tfmode_operation (code, operands);\n@@ -2763,9 +2623,7 @@ emit_tfmode_binop (code, operands)\n }\n \n void\n-emit_tfmode_unop (code, operands)\n-     enum rtx_code code;\n-     rtx *operands;\n+emit_tfmode_unop (enum rtx_code code, rtx *operands)\n {\n   if (TARGET_HARD_QUAD)\n     emit_hard_tfmode_operation (code, operands);\n@@ -2774,9 +2632,7 @@ emit_tfmode_unop (code, operands)\n }\n \n void\n-emit_tfmode_cvt (code, operands)\n-     enum rtx_code code;\n-     rtx *operands;\n+emit_tfmode_cvt (enum rtx_code code, rtx *operands)\n {\n   if (TARGET_HARD_QUAD)\n     emit_hard_tfmode_operation (code, operands);\n@@ -2787,7 +2643,7 @@ emit_tfmode_cvt (code, operands)\n /* Return nonzero if a return peephole merging return with\n    setting of output register is ok.  */\n int\n-leaf_return_peephole_ok ()\n+leaf_return_peephole_ok (void)\n {\n   return (actual_fsize == 0);\n }\n@@ -2796,8 +2652,7 @@ leaf_return_peephole_ok ()\n    nop into its delay slot.  */\n \n int\n-empty_delay_slot (insn)\n-     rtx insn;\n+empty_delay_slot (rtx insn)\n {\n   rtx seq;\n \n@@ -2816,9 +2671,7 @@ empty_delay_slot (insn)\n    delay slot.  SLOT is the slot we are trying to fill.  */\n \n int\n-eligible_for_epilogue_delay (trial, slot)\n-     rtx trial;\n-     int slot;\n+eligible_for_epilogue_delay (rtx trial, int slot)\n {\n   rtx pat, src;\n \n@@ -2944,8 +2797,7 @@ eligible_for_epilogue_delay (trial, slot)\n    delay slot.  */\n \n int\n-eligible_for_sibcall_delay (trial)\n-     rtx trial;\n+eligible_for_sibcall_delay (rtx trial)\n {\n   rtx pat, src;\n \n@@ -3035,8 +2887,7 @@ eligible_for_sibcall_delay (trial)\n }\n \n static int\n-check_return_regs (x)\n-     rtx x;\n+check_return_regs (rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -3070,8 +2921,7 @@ check_return_regs (x)\n }\n \n int\n-short_branch (uid1, uid2)\n-     int uid1, uid2;\n+short_branch (int uid1, int uid2)\n {\n   int delta = INSN_ADDRESSES (uid1) - INSN_ADDRESSES (uid2);\n \n@@ -3086,9 +2936,7 @@ short_branch (uid1, uid2)\n    We assume REG is a reload reg, and therefore does\n    not live past labels or calls or jumps.  */\n int\n-reg_unused_after (reg, insn)\n-     rtx reg;\n-     rtx insn;\n+reg_unused_after (rtx reg, rtx insn)\n {\n   enum rtx_code code, prev_code = UNKNOWN;\n \n@@ -3127,8 +2975,7 @@ static char get_pc_symbol_name[256];\n /* Ensure that we are not using patterns that are not OK with PIC.  */\n \n int\n-check_pic (i)\n-     int i;\n+check_pic (int i)\n {\n   switch (flag_pic)\n     {\n@@ -3151,8 +2998,7 @@ check_pic (i)\n    reloaded while generating PIC code.  */\n \n int\n-pic_address_needs_scratch (x)\n-     rtx x;\n+pic_address_needs_scratch (rtx x)\n {\n   /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */\n   if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n@@ -3170,10 +3016,8 @@ pic_address_needs_scratch (x)\n    necessary.  */\n \n rtx\n-legitimize_pic_address (orig, mode, reg)\n-     rtx orig;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx reg;\n+legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\trtx reg)\n {\n   if (GET_CODE (orig) == SYMBOL_REF)\n     {\n@@ -3276,7 +3120,7 @@ legitimize_pic_address (orig, mode, reg)\n /* Emit special PIC prologues.  */\n \n void\n-load_pic_register ()\n+load_pic_register (void)\n {\n   /* Labels to get the PC in the prologue of this function.  */\n   int orig_flag_pic = flag_pic;\n@@ -3321,9 +3165,7 @@ load_pic_register ()\n    least a DESIRED byte boundary.  */\n \n int\n-mem_min_alignment (mem, desired)\n-     rtx mem;\n-     int desired;\n+mem_min_alignment (rtx mem, int desired)\n {\n   rtx addr, base, offset;\n \n@@ -3516,7 +3358,7 @@ int sparc_mode_class [NUM_MACHINE_MODES];\n enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n static void\n-sparc_init_modes ()\n+sparc_init_modes (void)\n {\n   int i;\n \n@@ -3594,13 +3436,8 @@ sparc_init_modes ()\n    v9 int regs as it simplifies the code.  */\n \n static int\n-save_regs (file, low, high, base, offset, n_regs, real_offset)\n-     FILE *file;\n-     int low, high;\n-     const char *base;\n-     int offset;\n-     int n_regs;\n-     int real_offset;\n+save_regs (FILE *file, int low, int high, const char *base,\n+\t   int offset, int n_regs, int real_offset)\n {\n   int i;\n \n@@ -3667,12 +3504,8 @@ save_regs (file, low, high, base, offset, n_regs, real_offset)\n    v9 int regs as it simplifies the code.  */\n \n static int\n-restore_regs (file, low, high, base, offset, n_regs)\n-     FILE *file;\n-     int low, high;\n-     const char *base;\n-     int offset;\n-     int n_regs;\n+restore_regs (FILE *file, int low, int high, const char *base,\n+\t      int offset, int n_regs)\n {\n   int i;\n \n@@ -3712,9 +3545,7 @@ restore_regs (file, low, high, base, offset, n_regs)\n    during the reload pass and also by output_function_prologue().  */\n \n int\n-compute_frame_size (size, leaf_function)\n-     int size;\n-     int leaf_function;\n+compute_frame_size (int size, int leaf_function)\n {\n   int n_regs = 0, i;\n   int outgoing_args_size = (current_function_outgoing_args_size\n@@ -3772,10 +3603,7 @@ compute_frame_size (size, leaf_function)\n /* ??? We may be able to use the set macro here too.  */\n \n static void\n-build_big_number (file, num, reg)\n-     FILE *file;\n-     int num;\n-     const char *reg;\n+build_big_number (FILE *file, int num, const char *reg)\n {\n   if (num >= 0 || ! TARGET_ARCH64)\n     {\n@@ -3801,8 +3629,7 @@ build_big_number (file, num, reg)\n \n /* Output any necessary .register pseudo-ops.  */\n void\n-sparc_output_scratch_registers (file)\n-     FILE *file ATTRIBUTE_UNUSED;\n+sparc_output_scratch_registers (FILE *file ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_AS_REGISTER_PSEUDO_OP\n   int i;\n@@ -3842,9 +3669,7 @@ sparc_output_scratch_registers (file)\n    to do this is made in regclass.c.  */\n \n static void\n-sparc_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+sparc_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n {\n   if (TARGET_FLAT)\n     sparc_flat_function_prologue (file, size);\n@@ -3856,10 +3681,8 @@ sparc_output_function_prologue (file, size)\n /* Output code for the function prologue.  */\n \n static void\n-sparc_nonflat_function_prologue (file, size, leaf_function)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-     int leaf_function;\n+sparc_nonflat_function_prologue (FILE *file, HOST_WIDE_INT size,\n+\t\t\t\t int leaf_function)\n {\n   sparc_output_scratch_registers (file);\n \n@@ -3974,9 +3797,7 @@ sparc_nonflat_function_prologue (file, size, leaf_function)\n /* Output code to restore any call saved registers.  */\n \n static void\n-output_restore_regs (file, leaf_function)\n-     FILE *file;\n-     int leaf_function ATTRIBUTE_UNUSED;\n+output_restore_regs (FILE *file, int leaf_function ATTRIBUTE_UNUSED)\n {\n   int offset, n_regs;\n   const char *base;\n@@ -4007,9 +3828,7 @@ output_restore_regs (file, leaf_function)\n    before returning.  */\n \n static void\n-sparc_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+sparc_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n {\n   if (TARGET_FLAT)\n     sparc_flat_function_epilogue (file, size);\n@@ -4021,10 +3840,9 @@ sparc_output_function_epilogue (file, size)\n /* Output code for the function epilogue.  */\n \n static void\n-sparc_nonflat_function_epilogue (file, size, leaf_function)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-     int leaf_function;\n+sparc_nonflat_function_epilogue (FILE *file,\n+\t\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n+\t\t\t\t int leaf_function)\n {\n   const char *ret;\n \n@@ -4161,8 +3979,7 @@ sparc_nonflat_function_epilogue (file, size, leaf_function)\n /* Output a sibling call.  */\n \n const char *\n-output_sibcall (insn, call_operand)\n-     rtx insn, call_operand;\n+output_sibcall (rtx insn, rtx call_operand)\n {\n   int leaf_regs = current_function_uses_only_leaf_regs;\n   rtx operands[3];\n@@ -4364,11 +4181,9 @@ output_sibcall (insn, call_operand)\n    For a library call, FNTYPE is 0.  */\n \n void\n-init_cumulative_args (cum, fntype, libname, fndecl)\n-     CUMULATIVE_ARGS *cum;\n-     tree fntype;\n-     rtx libname ATTRIBUTE_UNUSED;\n-     tree fndecl ATTRIBUTE_UNUSED;\n+init_cumulative_args (struct sparc_args *cum, tree fntype,\n+\t\t      rtx libname ATTRIBUTE_UNUSED,\n+\t\t      tree fndecl ATTRIBUTE_UNUSED)\n {\n   cum->words = 0;\n   cum->prototype_p = fntype && TYPE_ARG_TYPES (fntype);\n@@ -4391,14 +4206,9 @@ init_cumulative_args (cum, fntype, libname, fndecl)\n    *PPADDING records the amount of padding needed in words.  */\n \n static int\n-function_arg_slotno (cum, mode, type, named, incoming_p, pregno, ppadding)\n-     const CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n-     int incoming_p;\n-     int *pregno;\n-     int *ppadding;\n+function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n+\t\t     tree type, int named, int incoming_p,\n+\t\t     int *pregno, int *ppadding)\n {\n   int regbase = (incoming_p\n \t\t ? SPARC_INCOMING_INT_ARG_FIRST\n@@ -4552,10 +4362,8 @@ static rtx function_arg_record_value (tree, enum machine_mode, int, int, int);\n    recursively and determine how many registers will be required.  */\n \n static void\n-function_arg_record_value_1 (type, startbitpos, parms)\n-     tree type;\n-     HOST_WIDE_INT startbitpos;\n-     struct function_arg_record_value_parms *parms;\n+function_arg_record_value_1 (tree type, HOST_WIDE_INT startbitpos,\n+\t\t\t     struct function_arg_record_value_parms *parms)\n {\n   tree field;\n \n@@ -4639,9 +4447,8 @@ function_arg_record_value_1 (type, startbitpos, parms)\n    structure between parms->intoffset and bitpos to integer registers.  */\n \n static void \n-function_arg_record_value_3 (bitpos, parms)\n-     HOST_WIDE_INT bitpos;\n-     struct function_arg_record_value_parms *parms;\n+function_arg_record_value_3 (HOST_WIDE_INT bitpos,\n+\t\t\t     struct function_arg_record_value_parms *parms)\n {\n   enum machine_mode mode;\n   unsigned int regno;\n@@ -4697,10 +4504,8 @@ function_arg_record_value_3 (bitpos, parms)\n    to make that happen.  */\n \n static void\n-function_arg_record_value_2 (type, startbitpos, parms)\n-     tree type;\n-     HOST_WIDE_INT startbitpos;\n-     struct function_arg_record_value_parms *parms;\n+function_arg_record_value_2 (tree type, HOST_WIDE_INT startbitpos,\n+\t\t\t     struct function_arg_record_value_parms *parms)\n {\n   tree field;\n   int packed_p = 0;\n@@ -4792,10 +4597,8 @@ function_arg_record_value_2 (type, startbitpos, parms)\n    REGBASE is the regno of the base register for the parameter array.  */\n    \n static rtx\n-function_arg_record_value (type, mode, slotno, named, regbase)\n-     tree type;\n-     enum machine_mode mode;\n-     int slotno, named, regbase;\n+function_arg_record_value (tree type, enum machine_mode mode,\n+\t\t\t   int slotno, int named, int regbase)\n {\n   HOST_WIDE_INT typesize = int_size_in_bytes (type);\n   struct function_arg_record_value_parms parms;\n@@ -4897,12 +4700,8 @@ function_arg_record_value (type, mode, slotno, named, regbase)\n    INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.  */\n \n rtx\n-function_arg (cum, mode, type, named, incoming_p)\n-     const CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n-     int incoming_p;\n+function_arg (const struct sparc_args *cum, enum machine_mode mode,\n+\t      tree type, int named, int incoming_p)\n {\n   int regbase = (incoming_p\n \t\t ? SPARC_INCOMING_INT_ARG_FIRST\n@@ -5033,11 +4832,8 @@ function_arg (cum, mode, type, named, incoming_p)\n    mode] will be split between that reg and memory.  */\n \n int\n-function_arg_partial_nregs (cum, mode, type, named)\n-     const CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+function_arg_partial_nregs (const struct sparc_args *cum,\n+\t\t\t    enum machine_mode mode, tree type, int named)\n {\n   int slotno, regno, padding;\n \n@@ -5104,11 +4900,9 @@ function_arg_partial_nregs (cum, mode, type, named)\n    For Pascal, also pass arrays by reference.  */\n \n int\n-function_arg_pass_by_reference (cum, mode, type, named)\n-     const CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg_pass_by_reference (const struct sparc_args *cum ATTRIBUTE_UNUSED,\n+\t\t\t\tenum machine_mode mode, tree type,\n+\t\t\t\tint named ATTRIBUTE_UNUSED)\n {\n   if (TARGET_ARCH32)\n     {\n@@ -5132,11 +4926,8 @@ function_arg_pass_by_reference (cum, mode, type, named)\n    TYPE is null for libcalls where that information may not be available.  */\n \n void\n-function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+function_arg_advance (struct sparc_args *cum, enum machine_mode mode,\n+\t\t      tree type, int named)\n {\n   int slotno, regno, padding;\n \n@@ -5188,9 +4979,7 @@ function_arg_advance (cum, mode, type, named)\n    argument slot.  */\n \n enum direction\n-function_arg_padding (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+function_arg_padding (enum machine_mode mode, tree type)\n {\n   if (TARGET_ARCH64 && type != 0 && AGGREGATE_TYPE_P (type))\n     return upward;\n@@ -5210,10 +4999,7 @@ function_arg_padding (mode, type)\n    except that up to 32-bytes may be returned in registers.  */\n \n rtx\n-function_value (type, mode, incoming_p)\n-     tree type;\n-     enum machine_mode mode;\n-     int incoming_p;\n+function_value (tree type, enum machine_mode mode, int incoming_p)\n {\n   int regno;\n   int regbase = (incoming_p\n@@ -5264,7 +5050,7 @@ function_value (type, mode, incoming_p)\n    the first unnamed parameter.  */\n \n rtx\n-sparc_builtin_saveregs ()\n+sparc_builtin_saveregs (void)\n {\n   int first_reg = current_function_args_info.words;\n   rtx address;\n@@ -5291,9 +5077,7 @@ sparc_builtin_saveregs ()\n /* Implement `va_start' for varargs and stdarg.  */\n \n void\n-sparc_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+sparc_va_start (tree valist, rtx nextarg)\n {\n   nextarg = expand_builtin_saveregs ();\n   std_expand_builtin_va_start (valist, nextarg);\n@@ -5302,8 +5086,7 @@ sparc_va_start (valist, nextarg)\n /* Implement `va_arg'.  */\n \n rtx\n-sparc_va_arg (valist, type)\n-     tree valist, type;\n+sparc_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT size, rsize, align;\n   tree addr, incr;\n@@ -5427,11 +5210,8 @@ sparc_va_arg (valist, type)\n    INSN, if set, is the insn.  */\n \n char *\n-output_cbranch (op, dest, label, reversed, annul, noop, insn)\n-     rtx op, dest;\n-     int label;\n-     int reversed, annul, noop;\n-     rtx insn;\n+output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n+\t\tint noop, rtx insn)\n {\n   static char string[50];\n   enum rtx_code code = GET_CODE (op);\n@@ -5675,9 +5455,7 @@ output_cbranch (op, dest, label, reversed, annul, noop, insn)\n    values as arguments instead of the TFmode registers themselves,\n    that's why we cannot call emit_float_lib_cmp.  */\n void\n-sparc_emit_float_lib_cmp (x, y, comparison)\n-     rtx x, y;\n-     enum rtx_code comparison;\n+sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n {\n   const char *qpfunc;\n   rtx slot0, slot1, result, tem, tem2;\n@@ -5814,8 +5592,7 @@ sparc_emit_float_lib_cmp (x, y, comparison)\n    optabs would emit if we didn't have TFmode patterns.  */\n \n void\n-sparc_emit_floatunsdi (operands)\n-     rtx operands[2];\n+sparc_emit_floatunsdi (rtx *operands)\n {\n   rtx neglab, donelab, i0, i1, f0, in, out;\n   enum machine_mode mode;\n@@ -5858,11 +5635,8 @@ sparc_emit_floatunsdi (operands)\n    NOOP is nonzero if we have to follow this branch by a noop.  */\n \n char *\n-output_v9branch (op, dest, reg, label, reversed, annul, noop, insn)\n-     rtx op, dest;\n-     int reg, label;\n-     int reversed, annul, noop;\n-     rtx insn;\n+output_v9branch (rtx op, rtx dest, int reg, int label, int reversed,\n+\t\t int annul, int noop, rtx insn)\n {\n   static char string[50];\n   enum rtx_code code = GET_CODE (op);\n@@ -6002,9 +5776,7 @@ output_v9branch (op, dest, reg, label, reversed, annul, noop, insn)\n  */\n \n static int\n-epilogue_renumber (where, test)\n-     register rtx *where;\n-     int test;\n+epilogue_renumber (register rtx *where, int test)\n {\n   register const char *fmt;\n   register int i;\n@@ -6088,7 +5860,7 @@ static const int *const reg_alloc_orders[] = {\n   reg_nonleaf_alloc_order};\n \n void\n-order_regs_for_local_alloc ()\n+order_regs_for_local_alloc (void)\n {\n   static int last_order_nonleaf = 1;\n \n@@ -6105,9 +5877,7 @@ order_regs_for_local_alloc ()\n    mem<-->reg splits to be run.  */\n \n int\n-sparc_splitdi_legitimate (reg, mem)\n-     rtx reg;\n-     rtx mem;\n+sparc_splitdi_legitimate (rtx reg, rtx mem)\n {\n   /* Punt if we are here by mistake.  */\n   if (! reload_completed)\n@@ -6132,8 +5902,7 @@ sparc_splitdi_legitimate (reg, mem)\n    run after reload.  */\n \n int\n-sparc_absnegfloat_split_legitimate (x, y)\n-     rtx x, y;\n+sparc_absnegfloat_split_legitimate (rtx x, rtx y)\n {\n   if (GET_CODE (x) != REG)\n     return 0;\n@@ -6150,8 +5919,7 @@ sparc_absnegfloat_split_legitimate (x, y)\n    Note reg1 and reg2 *must* be hard registers.  */\n \n int\n-registers_ok_for_ldd_peep (reg1, reg2)\n-     rtx reg1, reg2;\n+registers_ok_for_ldd_peep (rtx reg1, rtx reg2)\n {\n   /* We might have been passed a SUBREG.  */\n   if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG) \n@@ -6199,8 +5967,7 @@ registers_ok_for_ldd_peep (reg1, reg2)\n    NULL_RTX.  */\n \n int\n-mems_ok_for_ldd_peep (mem1, mem2, dependent_reg_rtx)\n-      rtx mem1, mem2, dependent_reg_rtx;\n+mems_ok_for_ldd_peep (rtx mem1, rtx mem2, rtx dependent_reg_rtx)\n {\n   rtx addr1, addr2;\n   unsigned int reg1;\n@@ -6274,8 +6041,7 @@ mems_ok_for_ldd_peep (mem1, mem2, dependent_reg_rtx)\n    ldd and std insns.  */\n \n int\n-register_ok_for_ldd (reg)\n-     rtx reg;\n+register_ok_for_ldd (rtx reg)\n {\n   /* We might have been passed a SUBREG.  */\n   if (GET_CODE (reg) != REG) \n@@ -6292,10 +6058,7 @@ register_ok_for_ldd (reg)\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n \n void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -6580,10 +6343,7 @@ print_operand (file, x, code)\n    special handling for aligned DI-mode objects.  */\n \n static bool\n-sparc_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+sparc_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   /* ??? We only output .xword's for symbols and only then in environments\n      where the assembler can handle them.  */\n@@ -6638,8 +6398,7 @@ sparc_assemble_integer (x, size, aligned_p)\n #endif\n \n unsigned long\n-sparc_type_code (type)\n-     register tree type;\n+sparc_type_code (register tree type)\n {\n   register unsigned long qualifiers = 0;\n   register unsigned shift;\n@@ -6763,8 +6522,7 @@ sparc_type_code (type)\n    Emit enough FLUSH insns to synchronize the data and instruction caches.  */\n \n void\n-sparc_initialize_trampoline (tramp, fnaddr, cxt)\n-     rtx tramp, fnaddr, cxt;\n+sparc_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n {\n   /* SPARC 32 bit trampoline:\n \n@@ -6825,8 +6583,7 @@ sparc_initialize_trampoline (tramp, fnaddr, cxt)\n    we can read the PC without clobbering a register.  */\n \n void\n-sparc64_initialize_trampoline (tramp, fnaddr, cxt)\n-     rtx tramp, fnaddr, cxt;\n+sparc64_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n {\n #ifdef TRANSFER_FROM_TRAMPOLINE\n   emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__enable_execute_stack\"),\n@@ -6957,8 +6714,8 @@ struct sparc_frame_info zero_frame_info;\n    stack pointer.  */\n \n unsigned long\n-sparc_flat_compute_frame_size (size)\n-     int size;\t\t\t/* # of var. bytes allocated.  */\n+sparc_flat_compute_frame_size (int size)\n+              \t\t\t/* # of var. bytes allocated.  */\n {\n   int regno;\n   unsigned long total_size;\t/* # bytes that the entire frame takes up.  */\n@@ -7076,16 +6833,11 @@ sparc_flat_compute_frame_size (size)\n    DOUBLEWORD_OP is either \"std\" for save, \"ldd\" for restore.  */\n \n void\n-sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op,\n-\t\t\t doubleword_op, base_offset)\n-     FILE *file;\n-     const char *base_reg;\n-     unsigned int offset;\n-     unsigned long gmask;\n-     unsigned long fmask;\n-     const char *word_op;\n-     const char *doubleword_op;\n-     unsigned long base_offset;\n+sparc_flat_save_restore (FILE *file, const char *base_reg,\n+\t\t\t unsigned int offset, long unsigned int gmask,\n+\t\t\t long unsigned int fmask, const char *word_op,\n+\t\t\t const char *doubleword_op,\n+\t\t\t long unsigned int base_offset)\n {\n   int regno;\n \n@@ -7180,9 +6932,7 @@ sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op,\n /* Set up the stack and frame (if desired) for the function.  */\n \n static void\n-sparc_flat_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+sparc_flat_function_prologue (FILE *file, HOST_WIDE_INT size)\n {\n   const char *sp_str = reg_names[STACK_POINTER_REGNUM];\n   unsigned long gmask = current_frame_info.gmask;\n@@ -7368,9 +7118,7 @@ sparc_flat_function_prologue (file, size)\n    and regs.  */\n \n static void\n-sparc_flat_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+sparc_flat_function_epilogue (FILE *file, HOST_WIDE_INT size)\n {\n   rtx epilogue_delay = current_function_epilogue_delay_list;\n   int noepilogue = FALSE;\n@@ -7515,7 +7263,7 @@ sparc_flat_function_epilogue (file, size)\n    or the only register saved is the return register.  */\n \n int\n-sparc_flat_epilogue_delay_slots ()\n+sparc_flat_epilogue_delay_slots (void)\n {\n   if (!current_frame_info.initialized)\n     (void) sparc_flat_compute_frame_size (get_frame_size ());\n@@ -7531,9 +7279,7 @@ sparc_flat_epilogue_delay_slots ()\n    pointer is OK.  */\n \n int\n-sparc_flat_eligible_for_epilogue_delay (trial, slot)\n-     rtx trial;\n-     int slot ATTRIBUTE_UNUSED;\n+sparc_flat_eligible_for_epilogue_delay (rtx trial, int slot ATTRIBUTE_UNUSED)\n {\n   rtx pat = PATTERN (trial);\n \n@@ -7551,11 +7297,7 @@ sparc_flat_eligible_for_epilogue_delay (trial, slot)\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n static int\n-supersparc_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep_insn;\n-     int cost;\n+supersparc_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n   enum attr_type insn_type;\n \n@@ -7616,11 +7358,7 @@ supersparc_adjust_cost (insn, link, dep_insn, cost)\n }\n \n static int\n-hypersparc_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep_insn;\n-     int cost;\n+hypersparc_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n   enum attr_type insn_type, dep_type;\n   rtx pat = PATTERN(insn);\n@@ -7697,11 +7435,7 @@ hypersparc_adjust_cost (insn, link, dep_insn, cost)\n }\n \n static int\n-sparc_adjust_cost(insn, link, dep, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep;\n-     int cost;\n+sparc_adjust_cost(rtx insn, rtx link, rtx dep, int cost)\n {\n   switch (sparc_cpu)\n     {\n@@ -7719,15 +7453,14 @@ sparc_adjust_cost(insn, link, dep, cost)\n }\n \n static void\n-sparc_sched_init (dump, sched_verbose, max_ready)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     int max_ready ATTRIBUTE_UNUSED;\n+sparc_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t  int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t  int max_ready ATTRIBUTE_UNUSED)\n {\n }\n   \n static int\n-sparc_use_dfa_pipeline_interface ()\n+sparc_use_dfa_pipeline_interface (void)\n {\n   if ((1 << sparc_cpu) &\n       ((1 << PROCESSOR_ULTRASPARC) | (1 << PROCESSOR_CYPRESS) |\n@@ -7739,7 +7472,7 @@ sparc_use_dfa_pipeline_interface ()\n }\n \n static int\n-sparc_use_sched_lookahead ()\n+sparc_use_sched_lookahead (void)\n {\n   if (sparc_cpu == PROCESSOR_ULTRASPARC\n       || sparc_cpu == PROCESSOR_ULTRASPARC3)\n@@ -7752,7 +7485,7 @@ sparc_use_sched_lookahead ()\n }\n \n static int\n-sparc_issue_rate ()\n+sparc_issue_rate (void)\n {\n   switch (sparc_cpu)\n     {\n@@ -7773,8 +7506,7 @@ sparc_issue_rate ()\n }\n \n static int\n-set_extends (insn)\n-     rtx insn;\n+set_extends (rtx insn)\n {\n   register rtx pat = PATTERN (insn);\n \n@@ -7841,9 +7573,7 @@ static GTY(()) rtx sparc_addr_diff_list;\n static GTY(()) rtx sparc_addr_list;\n \n void\n-sparc_defer_case_vector (lab, vec, diff)\n-     rtx lab, vec;\n-     int diff;\n+sparc_defer_case_vector (rtx lab, rtx vec, int diff)\n {\n   vec = gen_rtx_EXPR_LIST (VOIDmode, lab, vec);\n   if (diff)\n@@ -7854,8 +7584,7 @@ sparc_defer_case_vector (lab, vec, diff)\n }\n \n static void \n-sparc_output_addr_vec (vec)\n-     rtx vec;\n+sparc_output_addr_vec (rtx vec)\n {\n   rtx lab = XEXP (vec, 0), body = XEXP (vec, 1);\n   int idx, vlen = XVECLEN (body, 0);\n@@ -7883,8 +7612,7 @@ sparc_output_addr_vec (vec)\n }\n \n static void \n-sparc_output_addr_diff_vec (vec)\n-     rtx vec;\n+sparc_output_addr_diff_vec (rtx vec)\n {\n   rtx lab = XEXP (vec, 0), body = XEXP (vec, 1);\n   rtx base = XEXP (XEXP (body, 0), 0);\n@@ -7916,7 +7644,7 @@ sparc_output_addr_diff_vec (vec)\n }\n \n static void\n-sparc_output_deferred_case_vectors ()\n+sparc_output_deferred_case_vectors (void)\n {\n   rtx t;\n   int align;\n@@ -7944,8 +7672,7 @@ sparc_output_deferred_case_vectors ()\n    unknown.  Return 1 if the high bits are zero, -1 if the register is\n    sign extended.  */\n int\n-sparc_check_64 (x, insn)\n-     rtx x, insn;\n+sparc_check_64 (rtx x, rtx insn)\n {\n   /* If a register is set only once it is safe to ignore insns this\n      code does not know how to handle.  The loop will either recognize\n@@ -8005,10 +7732,7 @@ sparc_check_64 (x, insn)\n /* Returns assembly code to perform a DImode shift using\n    a 64-bit global or out register on SPARC-V8+.  */\n char *\n-sparc_v8plus_shift (operands, insn, opcode)\n-     rtx *operands;\n-     rtx insn;\n-     const char *opcode;\n+sparc_v8plus_shift (rtx *operands, rtx insn, const char *opcode)\n {\n   static char asm_code[60];\n \n@@ -8041,8 +7765,7 @@ sparc_v8plus_shift (operands, insn, opcode)\n    for profiling a function entry.  */\n \n void\n-sparc_profile_hook (labelno)\n-     int labelno;\n+sparc_profile_hook (int labelno)\n {\n   char buf[32];\n   rtx lab, fun;\n@@ -8056,9 +7779,7 @@ sparc_profile_hook (labelno)\n \f\n #ifdef OBJECT_FORMAT_ELF\n static void\n-sparc_elf_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+sparc_elf_asm_named_section (const char *name, unsigned int flags)\n {\n   if (flags & SECTION_MERGE)\n     {\n@@ -8100,9 +7821,7 @@ sparc_elf_asm_named_section (name, flags)\n    void) and then nothing else happens.  Such a sibling call would look\n    valid without the added check here.  */\n static bool\n-sparc_function_ok_for_sibcall (decl, exp)\n-     tree decl;\n-     tree exp ATTRIBUTE_UNUSED;\n+sparc_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   return (decl\n \t  && ! TARGET_FLAT\n@@ -8114,10 +7833,7 @@ sparc_function_ok_for_sibcall (decl, exp)\n    pretending PIC always on), but that's what the old code did.  */\n \n static void\n-sparc_aout_select_section (t, reloc, align)\n-     tree t;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align;\n+sparc_aout_select_section (tree t, int reloc, unsigned HOST_WIDE_INT align)\n {\n   default_select_section (t, reloc | SUNOS4_SHARED_LIBRARIES, align);\n }\n@@ -8126,10 +7842,8 @@ sparc_aout_select_section (t, reloc, align)\n    that offers.  */\n \n static void\n-sparc_aout_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align;\n+sparc_aout_select_rtx_section (enum machine_mode mode, rtx x,\n+\t\t\t       unsigned HOST_WIDE_INT align)\n {\n   if (align <= MAX_TEXT_ALIGN\n       && ! (flag_pic && (symbolic_operand (x, mode)\n@@ -8140,10 +7854,7 @@ sparc_aout_select_rtx_section (mode, x, align)\n }\n \n int\n-sparc_extra_constraint_check (op, c, strict)\n-     rtx op;\n-     int c;\n-     int strict;\n+sparc_extra_constraint_check (rtx op, int c, int strict)\n {\n   int reload_ok_mem;\n \n@@ -8206,9 +7917,7 @@ sparc_extra_constraint_check (op, c, strict)\n    ??? the latencies and then CSE will just use that.  */\n \n static bool\n-sparc_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code, *total;\n+sparc_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -8576,12 +8285,10 @@ sparc_rtx_costs (x, code, outer_code, total)\n    Used for C++ multiple inheritance.  */\n \n static void\n-sparc_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk_fndecl ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n-     tree function;\n+sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+\t\t       HOST_WIDE_INT delta,\n+\t\t       HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t       tree function)\n {\n   rtx this, insn, funexp, delta_rtx, tmp;\n "}]}