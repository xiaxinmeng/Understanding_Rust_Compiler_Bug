{"sha": "3abcb3a78118cb492da39fe43fc45cac4c80a07f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FiY2IzYTc4MTE4Y2I0OTJkYTM5ZmU0M2ZjNDVjYWM0YzgwYTA3Zg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2007-08-22T20:32:18Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-08-22T20:32:18Z"}, "message": "md.texi (Iterators): Renamed from Macros.\n\n\t* doc/md.texi (Iterators): Renamed from Macros.  All contents\n\tchanged to reflect rename of respectively define_code_macro and\n\tdefine_mode_macro to define_code_iterator and define_mode_iterator.\n\t(Mode Iterators, Code Iterators): Similar.\n\t* read-rtl.c (struct iterator_group, struct iterator_traverse_data)\n\t(uses_mode_iterator_p, apply_mode_iterator, uses_code_iterator_p)\n\t(apply_iterator_to_string, uses_iterator_p, apply_iterator_traverse)\n\t(initialize_iterators, find_iterator, check_code_iterator)\n\t(map_attr_string, apply_mode_maps, apply_iterator_to_rtx, add_mapping)\n\t(read_mapping, read_rtx_1): Similar.\n\t* config/alpha/sync.md, config/alpha/alpha.md, config/frv/frv.md,\n\tconfig/s390/s390.md, config/m32c/blkmov.md, config/m32c/m32c.md,\n\tconfig/spu/spu.md, config/sparc/sparc.md, config/sparc/sync.md,\n\tconfig/i386/i386.md, config/i386/mmx.md, config/i386/sse.md,\n\tconfig/i386/sync.md, config/crx/crx.md, config/xtensa/xtensa.md,\n\tconfig/cris/cris.c, config/cris/cris.md, config/ia64/sync.md,\n\tconfig/ia64/div.md, config/ia64/vect.md, config/ia64/ia64.md,\n\tconfig/m68k/m68k.md, config/rs6000/spe.md, config/rs6000/altivec.md,\n\tconfig/rs6000/sync.md, config/rs6000/rs6000.md,\n\tconfig/arm/vec-common.md, config/arm/neon.md, config/arm/iwmmxt.md,\n\tconfig/arm/arm.md, config/mips/mips-dsp.md, config/mips/mips.md,\n\tconfig/vax/vax.md, config/bfin/bfin.md: Similar.\n\nFrom-SVN: r127715", "tree": {"sha": "7fbbcdd05392c2049de5126469da5fdfd30bc229", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fbbcdd05392c2049de5126469da5fdfd30bc229"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3abcb3a78118cb492da39fe43fc45cac4c80a07f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3abcb3a78118cb492da39fe43fc45cac4c80a07f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3abcb3a78118cb492da39fe43fc45cac4c80a07f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3abcb3a78118cb492da39fe43fc45cac4c80a07f/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a923a7585826fd7d7a8b9a65382a35b92e45c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a923a7585826fd7d7a8b9a65382a35b92e45c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a923a7585826fd7d7a8b9a65382a35b92e45c40"}], "stats": {"total": 853, "additions": 439, "deletions": 414}, "files": [{"sha": "0d8dae1c0af35cf3d6324798fc9dd95294afa87a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -1,3 +1,28 @@\n+2007-08-22  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* doc/md.texi (Iterators): Renamed from Macros.  All contents\n+\tchanged to reflect rename of respectively define_code_macro and\n+\tdefine_mode_macro to define_code_iterator and define_mode_iterator.\n+\t(Mode Iterators, Code Iterators): Similar.\n+\t* read-rtl.c (struct iterator_group, struct iterator_traverse_data)\n+\t(uses_mode_iterator_p, apply_mode_iterator, uses_code_iterator_p)\n+\t(apply_iterator_to_string, uses_iterator_p, apply_iterator_traverse)\n+\t(initialize_iterators, find_iterator, check_code_iterator)\n+\t(map_attr_string, apply_mode_maps, apply_iterator_to_rtx, add_mapping)\n+\t(read_mapping, read_rtx_1): Similar.\n+\t* config/alpha/sync.md, config/alpha/alpha.md, config/frv/frv.md,\n+\tconfig/s390/s390.md, config/m32c/blkmov.md, config/m32c/m32c.md,\n+\tconfig/spu/spu.md, config/sparc/sparc.md, config/sparc/sync.md,\n+\tconfig/i386/i386.md, config/i386/mmx.md, config/i386/sse.md,\n+\tconfig/i386/sync.md, config/crx/crx.md, config/xtensa/xtensa.md,\n+\tconfig/cris/cris.c, config/cris/cris.md, config/ia64/sync.md,\n+\tconfig/ia64/div.md, config/ia64/vect.md, config/ia64/ia64.md,\n+\tconfig/m68k/m68k.md, config/rs6000/spe.md, config/rs6000/altivec.md,\n+\tconfig/rs6000/sync.md, config/rs6000/rs6000.md,\n+\tconfig/arm/vec-common.md, config/arm/neon.md, config/arm/iwmmxt.md,\n+\tconfig/arm/arm.md, config/mips/mips-dsp.md, config/mips/mips.md,\n+\tconfig/vax/vax.md, config/bfin/bfin.md: Similar.\n+\n 2007-08-22  David Daney  <ddaney@avtrex.com>\n \n \t* doc/install.texi (Testing): Mention testing on a simulator."}, {"sha": "f381dded9ccf5420143e8fc7f6295688f6cd8af2", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -88,12 +88,12 @@\n \n ;; On non-BWX targets, CQImode must be handled the similarly to HImode\n ;; when generating reloads.\n-(define_mode_macro RELOAD12 [QI HI CQI])\n+(define_mode_iterator RELOAD12 [QI HI CQI])\n (define_mode_attr reloadmode [(QI \"qi\") (HI \"hi\") (CQI \"hi\")])\n \n-;; Other mode macros\n-(define_mode_macro I12MODE [QI HI])\n-(define_mode_macro I48MODE [SI DI])\n+;; Other mode iterators\n+(define_mode_iterator I12MODE [QI HI])\n+(define_mode_iterator I48MODE [SI DI])\n (define_mode_attr modesuffix [(SI \"l\") (DI \"q\")])\n \n ;; Where necessary, the suffixes _le and _be are used to distinguish between\n@@ -6253,7 +6253,7 @@\n \f\n ;; Vector operations\n \n-(define_mode_macro VEC [V8QI V4HI V2SI])\n+(define_mode_iterator VEC [V8QI V4HI V2SI])\n \n (define_expand \"mov<mode>\"\n   [(set (match_operand:VEC 0 \"nonimmediate_operand\" \"\")"}, {"sha": "5c0d284033434837720322a629a1d45713056b69", "filename": "gcc/config/alpha/sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -17,7 +17,7 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-(define_code_macro FETCHOP [plus minus ior xor and])\n+(define_code_iterator FETCHOP [plus minus ior xor and])\n (define_code_attr fetchop_name\n   [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])\n (define_code_attr fetchop_pred"}, {"sha": "4a63cfead9468a070c02a339b6f287159fc0f09f", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -309,12 +309,12 @@\n (define_attr \"ce_count\" \"\" (const_int 1))\n \n ;;---------------------------------------------------------------------------\n-;; Mode macros\n+;; Mode iterators\n \n ; A list of modes that are exactly 64 bits in size.  We use this to expand\n ; some splits that are the same for all modes when operating on ARM \n ; registers.\n-(define_mode_macro ANY64 [DI DF V8QI V4HI V2SI V2SF])\n+(define_mode_iterator ANY64 [DI DF V8QI V4HI V2SI V2SF])\n \n ;;---------------------------------------------------------------------------\n ;; Predicates"}, {"sha": "11188732bc74893128ac607f0da27471a1e6e34a", "filename": "gcc/config/arm/iwmmxt.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -20,10 +20,10 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;; Integer element sizes implemented by IWMMXT.\n-(define_mode_macro VMMX [V2SI V4HI V8QI])\n+(define_mode_iterator VMMX [V2SI V4HI V8QI])\n \n ;; Integer element sizes for shifts.\n-(define_mode_macro VSHFT [V4HI V2SI DI])\n+(define_mode_iterator VSHFT [V4HI V2SI DI])\n \n ;; Determine element size suffix from vector mode.\n (define_mode_attr MMX_char [(V8QI \"b\") (V4HI \"h\") (V2SI \"w\") (DI \"d\")])"}, {"sha": "167367c5239986b4037d8f37644d57cf5a9bdaf8", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -162,97 +162,97 @@\n    (UNSPEC_VZIP2\t\t204)])\n \n ;; Double-width vector modes.\n-(define_mode_macro VD [V8QI V4HI V2SI V2SF])\n+(define_mode_iterator VD [V8QI V4HI V2SI V2SF])\n \n ;; Double-width vector modes plus 64-bit elements.\n-(define_mode_macro VDX [V8QI V4HI V2SI V2SF DI])\n+(define_mode_iterator VDX [V8QI V4HI V2SI V2SF DI])\n \n ;; Same, without floating-point elements.\n-(define_mode_macro VDI [V8QI V4HI V2SI])\n+(define_mode_iterator VDI [V8QI V4HI V2SI])\n \n ;; Quad-width vector modes.\n-(define_mode_macro VQ [V16QI V8HI V4SI V4SF])\n+(define_mode_iterator VQ [V16QI V8HI V4SI V4SF])\n \n ;; Quad-width vector modes plus 64-bit elements.\n-(define_mode_macro VQX [V16QI V8HI V4SI V4SF V2DI])\n+(define_mode_iterator VQX [V16QI V8HI V4SI V4SF V2DI])\n \n ;; Same, without floating-point elements.\n-(define_mode_macro VQI [V16QI V8HI V4SI])\n+(define_mode_iterator VQI [V16QI V8HI V4SI])\n \n ;; Same, with TImode added, for moves.\n-(define_mode_macro VQXMOV [V16QI V8HI V4SI V4SF V2DI TI])\n+(define_mode_iterator VQXMOV [V16QI V8HI V4SI V4SF V2DI TI])\n \n ;; Opaque structure types wider than TImode.\n-(define_mode_macro VSTRUCT [EI OI CI XI])\n+(define_mode_iterator VSTRUCT [EI OI CI XI])\n \n ;; Number of instructions needed to load/store struct elements. FIXME!\n (define_mode_attr V_slen [(EI \"2\") (OI \"2\") (CI \"3\") (XI \"4\")])\n \n ;; Opaque structure types used in table lookups (except vtbl1/vtbx1).\n-(define_mode_macro VTAB [TI EI OI])\n+(define_mode_iterator VTAB [TI EI OI])\n \n ;; vtbl<n> suffix for above modes.\n (define_mode_attr VTAB_n [(TI \"2\") (EI \"3\") (OI \"4\")])\n \n ;; Widenable modes.\n-(define_mode_macro VW [V8QI V4HI V2SI])\n+(define_mode_iterator VW [V8QI V4HI V2SI])\n \n ;; Narrowable modes.\n-(define_mode_macro VN [V8HI V4SI V2DI])\n+(define_mode_iterator VN [V8HI V4SI V2DI])\n \n ;; All supported vector modes (except singleton DImode).\n-(define_mode_macro VDQ [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF V2DI])\n+(define_mode_iterator VDQ [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF V2DI])\n \n ;; All supported vector modes (except those with 64-bit integer elements).\n-(define_mode_macro VDQW [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF])\n+(define_mode_iterator VDQW [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF])\n \n ;; Supported integer vector modes (not 64 bit elements).\n-(define_mode_macro VDQIW [V8QI V16QI V4HI V8HI V2SI V4SI])\n+(define_mode_iterator VDQIW [V8QI V16QI V4HI V8HI V2SI V4SI])\n \n ;; Supported integer vector modes (not singleton DI)\n-(define_mode_macro VDQI [V8QI V16QI V4HI V8HI V2SI V4SI V2DI])\n+(define_mode_iterator VDQI [V8QI V16QI V4HI V8HI V2SI V4SI V2DI])\n \n ;; Vector modes, including 64-bit integer elements.\n-(define_mode_macro VDQX [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF DI V2DI])\n+(define_mode_iterator VDQX [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF DI V2DI])\n \n ;; Vector modes including 64-bit integer elements, but no floats.\n-(define_mode_macro VDQIX [V8QI V16QI V4HI V8HI V2SI V4SI DI V2DI])\n+(define_mode_iterator VDQIX [V8QI V16QI V4HI V8HI V2SI V4SI DI V2DI])\n \n ;; Vector modes for float->int conversions.\n-(define_mode_macro VCVTF [V2SF V4SF])\n+(define_mode_iterator VCVTF [V2SF V4SF])\n \n ;; Vector modes form int->float conversions.\n-(define_mode_macro VCVTI [V2SI V4SI])\n+(define_mode_iterator VCVTI [V2SI V4SI])\n \n ;; Vector modes for doubleword multiply-accumulate, etc. insns.\n-(define_mode_macro VMD [V4HI V2SI V2SF])\n+(define_mode_iterator VMD [V4HI V2SI V2SF])\n \n ;; Vector modes for quadword multiply-accumulate, etc. insns.\n-(define_mode_macro VMQ [V8HI V4SI V4SF])\n+(define_mode_iterator VMQ [V8HI V4SI V4SF])\n \n ;; Above modes combined.\n-(define_mode_macro VMDQ [V4HI V2SI V2SF V8HI V4SI V4SF])\n+(define_mode_iterator VMDQ [V4HI V2SI V2SF V8HI V4SI V4SF])\n \n ;; As VMD, but integer modes only.\n-(define_mode_macro VMDI [V4HI V2SI])\n+(define_mode_iterator VMDI [V4HI V2SI])\n \n ;; As VMQ, but integer modes only.\n-(define_mode_macro VMQI [V8HI V4SI])\n+(define_mode_iterator VMQI [V8HI V4SI])\n \n ;; Above modes combined.\n-(define_mode_macro VMDQI [V4HI V2SI V8HI V4SI])\n+(define_mode_iterator VMDQI [V4HI V2SI V8HI V4SI])\n \n ;; Modes with 8-bit and 16-bit elements.\n-(define_mode_macro VX [V8QI V4HI V16QI V8HI])\n+(define_mode_iterator VX [V8QI V4HI V16QI V8HI])\n \n ;; Modes with 8-bit elements.\n-(define_mode_macro VE [V8QI V16QI])\n+(define_mode_iterator VE [V8QI V16QI])\n \n ;; Modes with 64-bit elements only.\n-(define_mode_macro V64 [DI V2DI])\n+(define_mode_iterator V64 [DI V2DI])\n \n ;; Modes with 32-bit elements only.\n-(define_mode_macro V32 [V2SI V2SF V4SI V4SF])\n+(define_mode_iterator V32 [V2SI V2SF V4SI V4SF])\n \n ;; (Opposite) mode to convert to/from for above conversions.\n (define_mode_attr V_CVTTO [(V2SI \"V2SF\") (V2SF \"V2SI\")\n@@ -394,10 +394,10 @@\n                           (DI   \"ti\") (V2DI  \"oi\")])\n \n ;; Operations on two halves of a quadword vector.\n-(define_code_macro vqh_ops [plus smin smax umin umax])\n+(define_code_iterator vqh_ops [plus smin smax umin umax])\n \n ;; Same, without unsigned variants (for use with *SFmode pattern).\n-(define_code_macro vqhs_ops [plus smin smax])\n+(define_code_iterator vqhs_ops [plus smin smax])\n \n ;; Assembler mnemonics for above codes.\n (define_code_attr VQH_mnem [(plus \"vadd\") (smin \"vmin\") (smax \"vmax\")"}, {"sha": "858d381eed0adab5adedd7ba706599ea05cf4842", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -21,16 +21,16 @@\n ;; Vector Moves\n \n ;; All integer and float modes supported by Neon and IWMMXT.\n-(define_mode_macro VALL [V2DI V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n+(define_mode_iterator VALL [V2DI V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n \n ;; All integer and float modes supported by Neon and IWMMXT, except V2DI.\n-(define_mode_macro VALLW [V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n+(define_mode_iterator VALLW [V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n \n ;; All integer modes supported by Neon and IWMMXT\n-(define_mode_macro VINT [V2DI V2SI V4HI V8QI V4SI V8HI V16QI])\n+(define_mode_iterator VINT [V2DI V2SI V4HI V8QI V4SI V8HI V16QI])\n \n ;; All integer modes supported by Neon and IWMMXT, except V2DI\n-(define_mode_macro VINTW [V2SI V4HI V8QI V4SI V8HI V16QI])\n+(define_mode_iterator VINTW [V2SI V4HI V8QI V4SI V8HI V16QI])\n \n (define_expand \"mov<mode>\"\n   [(set (match_operand:VALL 0 \"nonimmediate_operand\" \"\")"}, {"sha": "e465cd54e0b0b3aeec023bc9c8ebd816234ad870", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -875,7 +875,7 @@\n \n ;; DImode logical operations\n \n-(define_code_macro any_logical [and ior xor])\n+(define_code_iterator any_logical [and ior xor])\n (define_code_attr optab [(and \"and\")\n \t\t\t (ior \"ior\")\n \t\t\t (xor \"xor\")])\n@@ -3544,7 +3544,7 @@\n   [(set_attr \"type\" \"dsp32\")])\n \n \n-(define_code_macro s_or_u [sign_extend zero_extend])\n+(define_code_iterator s_or_u [sign_extend zero_extend])\n (define_code_attr su_optab [(sign_extend \"mul\")\n \t\t\t    (zero_extend \"umul\")])\n (define_code_attr su_modifier [(sign_extend \"IS\")"}, {"sha": "99003dba5955c5d0c27fee84362fefc91910e0e9", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -870,9 +870,8 @@ cris_print_operand (FILE *file, rtx x, int code)\n \n     case 'e':\n       /* Like 'E', but ignore state set by 'x'.  FIXME: Use code\n-\t iterators (\"code macros\") and attributes in cris.md to avoid\n-\t the need for %x and %E (and %e) and state passed between\n-\t those modifiers.  */\n+\t iterators and attributes in cris.md to avoid the need for %x\n+\t and %E (and %e) and state passed between those modifiers.  */\n       cris_output_insn_is_bound = 0;\n       /* FALL THROUGH.  */\n     case 'E':"}, {"sha": "f9b0e927af3b377408194aae5300b0e70e1ae88f", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -150,29 +150,29 @@\n ;; Iterator definitions.\n \n ;; For the \"usual\" pattern size alternatives.\n-(define_mode_macro BWD [SI HI QI])\n-(define_mode_macro WD [SI HI])\n-(define_mode_macro BW [HI QI])\n+(define_mode_iterator BWD [SI HI QI])\n+(define_mode_iterator WD [SI HI])\n+(define_mode_iterator BW [HI QI])\n (define_mode_attr S [(SI \"HI\") (HI \"QI\")])\n (define_mode_attr s [(SI \"hi\") (HI \"qi\")])\n (define_mode_attr m [(SI \".d\") (HI \".w\") (QI \".b\")])\n (define_mode_attr mm [(SI \".w\") (HI \".b\")])\n (define_mode_attr nbitsm1 [(SI \"31\") (HI \"15\") (QI \"7\")])\n \n ;; For the sign_extend+zero_extend variants.\n-(define_code_macro szext [sign_extend zero_extend])\n+(define_code_iterator szext [sign_extend zero_extend])\n (define_code_attr u [(sign_extend \"\") (zero_extend \"u\")])\n (define_code_attr su [(sign_extend \"s\") (zero_extend \"u\")])\n \n ;; For the shift variants.\n-(define_code_macro shift [ashiftrt lshiftrt ashift])\n-(define_code_macro shiftrt [ashiftrt lshiftrt])\n+(define_code_iterator shift [ashiftrt lshiftrt ashift])\n+(define_code_iterator shiftrt [ashiftrt lshiftrt])\n (define_code_attr shlr [(ashiftrt \"ashr\") (lshiftrt \"lshr\") (ashift \"ashl\")])\n (define_code_attr slr [(ashiftrt \"asr\") (lshiftrt \"lsr\") (ashift \"lsl\")])\n \n-(define_code_macro ncond [eq ne gtu ltu geu leu])\n-(define_code_macro ocond [gt le])\n-(define_code_macro rcond [lt ge])\n+(define_code_iterator ncond [eq ne gtu ltu geu leu])\n+(define_code_iterator ocond [gt le])\n+(define_code_iterator rcond [lt ge])\n (define_code_attr CC [(eq \"eq\") (ne \"ne\") (gt \"gt\") (gtu \"hi\") (lt \"lt\")\n \t\t      (ltu \"lo\") (ge \"ge\") (geu \"hs\") (le \"le\") (leu \"ls\")])\n (define_code_attr rCC [(eq \"ne\") (ne \"eq\") (gt \"le\") (gtu \"ls\") (lt \"ge\")"}, {"sha": "b9655544ffc7441de84f302d8bbe17419df683f8", "filename": "gcc/config/crx/crx.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fcrx%2Fcrx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fcrx%2Fcrx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -73,12 +73,12 @@\n \n ;;  Mode Macro Definitions\n \n-(define_mode_macro ALLMT [QI HI SI SF DI DF])\n-(define_mode_macro CRXMM [QI HI SI SF])\n-(define_mode_macro CRXIM [QI HI SI])\n-(define_mode_macro DIDFM [DI DF])\n-(define_mode_macro SISFM [SI SF])\n-(define_mode_macro SHORT [QI HI])\n+(define_mode_iterator ALLMT [QI HI SI SF DI DF])\n+(define_mode_iterator CRXMM [QI HI SI SF])\n+(define_mode_iterator CRXIM [QI HI SI])\n+(define_mode_iterator DIDFM [DI DF])\n+(define_mode_iterator SISFM [SI SF])\n+(define_mode_iterator SHORT [QI HI])\n \n (define_mode_attr tIsa [(QI \"b\") (HI \"w\") (SI \"d\") (SF \"d\")])\n (define_mode_attr lImmArith [(QI \"4\") (HI \"4\") (SI \"6\")])\n@@ -94,20 +94,20 @@\n \n ;;  Code Macro Definitions\n \n-(define_code_macro sz_xtnd [sign_extend zero_extend])\n+(define_code_iterator sz_xtnd [sign_extend zero_extend])\n (define_code_attr sIsa [(sign_extend \"\") (zero_extend \"u\")])\n (define_code_attr sPat [(sign_extend \"s\") (zero_extend \"u\")])\n (define_code_attr szPat [(sign_extend \"\") (zero_extend \"zero_\")])\n (define_code_attr szIsa [(sign_extend \"s\") (zero_extend \"z\")])\n \n-(define_code_macro sh_oprnd [ashift ashiftrt lshiftrt])\n+(define_code_iterator sh_oprnd [ashift ashiftrt lshiftrt])\n (define_code_attr shIsa [(ashift \"ll\") (ashiftrt \"ra\") (lshiftrt \"rl\")])\n (define_code_attr shPat [(ashift \"ashl\") (ashiftrt \"ashr\") (lshiftrt \"lshr\")])\n \n-(define_code_macro mima_oprnd [smax umax smin umin])\n+(define_code_iterator mima_oprnd [smax umax smin umin])\n (define_code_attr mimaIsa [(smax \"maxs\") (umax \"maxu\") (smin \"mins\") (umin \"minu\")])\n \n-(define_code_macro any_cond [eq ne gt gtu lt ltu ge geu le leu])\n+(define_code_iterator any_cond [eq ne gt gtu lt ltu ge geu le leu])\n \n ;;  Addition Instructions\n "}, {"sha": "f8451747b9aa7bbf68f9641e1b943bbe1ef2dcd2", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -86,7 +86,7 @@\n    (FDPIC_REG\t\t\t15)\n    ])\n \n-(define_mode_macro IMODE [QI HI SI DI])\n+(define_mode_iterator IMODE [QI HI SI DI])\n (define_mode_attr IMODEsuffix [(QI \"b\") (HI \"h\") (SI \"\") (DI \"d\")])\n (define_mode_attr BREADsuffix [(QI \"ub\") (HI \"uh\") (SI \"\") (DI \"d\")])\n \f"}, {"sha": "609e6d6dda70b81c3512356786f9ea8dca4db835", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -488,7 +488,7 @@\n   [(set_attr \"length\" \"128\")\n    (set_attr \"type\" \"multi\")])\n \n-(define_code_macro plusminus [plus minus])\n+(define_code_iterator plusminus [plus minus])\n \n ;; Base name for define_insn and insn mnemonic.\n (define_code_attr addsub [(plus \"add\") (minus \"sub\")])\n@@ -497,7 +497,7 @@\n (define_code_attr comm [(plus \"%\") (minus \"\")])\n \n ;; All single word integer modes.\n-(define_mode_macro SWI [QI HI SI (DI \"TARGET_64BIT\")])\n+(define_mode_iterator SWI [QI HI SI (DI \"TARGET_64BIT\")])\n \n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n@@ -516,22 +516,22 @@\n \t (DI \"x86_64_general_operand\")])\n \n ;; All x87 floating point modes\n-(define_mode_macro X87MODEF [SF DF XF])\n+(define_mode_iterator X87MODEF [SF DF XF])\n \n ;; x87 SFmode and DFMode floating point modes\n-(define_mode_macro X87MODEF12 [SF DF])\n+(define_mode_iterator X87MODEF12 [SF DF])\n \n ;; All integer modes handled by x87 fisttp operator.\n-(define_mode_macro X87MODEI [HI SI DI])\n+(define_mode_iterator X87MODEI [HI SI DI])\n \n ;; All integer modes handled by integer x87 operators.\n-(define_mode_macro X87MODEI12 [HI SI])\n+(define_mode_iterator X87MODEI12 [HI SI])\n \n ;; All SSE floating point modes\n-(define_mode_macro SSEMODEF [SF DF])\n+(define_mode_iterator SSEMODEF [SF DF])\n \n ;; All integer modes handled by SSE cvtts?2si* operators.\n-(define_mode_macro SSEMODEI24 [SI DI])\n+(define_mode_iterator SSEMODEI24 [SI DI])\n \n ;; SSE asm suffix for floating point modes\n (define_mode_attr ssemodefsuffix [(SF \"s\") (DF \"d\")])\n@@ -10085,7 +10085,7 @@\n \n ;; Copysign instructions\n \n-(define_mode_macro CSGNMODE [SF DF TF])\n+(define_mode_iterator CSGNMODE [SF DF TF])\n (define_mode_attr CSGNVMODE [(SF \"V4SF\") (DF \"V2DF\") (TF \"TF\")])\n \n (define_expand \"copysign<mode>3\"\n@@ -21009,7 +21009,7 @@\n   }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_mode_macro CRC32MODE [QI HI SI])\n+(define_mode_iterator CRC32MODE [QI HI SI])\n (define_mode_attr crc32modesuffix [(QI \"b\") (HI \"w\") (SI \"l\")])\n (define_mode_attr crc32modeconstraint [(QI \"qm\") (HI \"rm\") (SI \"rm\")])\n "}, {"sha": "70073de927895a68777679c866338d22dcd4e4f6", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -31,14 +31,14 @@\n ;; direction of the user via a builtin.\n \n ;; 8 byte integral modes handled by MMX (and by extension, SSE)\n-(define_mode_macro MMXMODEI [V8QI V4HI V2SI])\n+(define_mode_iterator MMXMODEI [V8QI V4HI V2SI])\n \n ;; All 8-byte vector modes handled by MMX\n-(define_mode_macro MMXMODE [V8QI V4HI V2SI V2SF])\n+(define_mode_iterator MMXMODE [V8QI V4HI V2SI V2SF])\n \n ;; Mix-n-match\n-(define_mode_macro MMXMODE12 [V8QI V4HI])\n-(define_mode_macro MMXMODE24 [V4HI V2SI])\n+(define_mode_iterator MMXMODE12 [V8QI V4HI])\n+(define_mode_iterator MMXMODE24 [V4HI V2SI])\n \n ;; Mapping from integer vector mode to mnemonic suffix\n (define_mode_attr mmxvecsize [(V8QI \"b\") (V4HI \"w\") (V2SI \"d\") (DI \"q\")])"}, {"sha": "31fd293e7b66093a65df085e4522a3b2372a132e", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -21,17 +21,17 @@\n \n ;; 16 byte integral modes handled by SSE, minus TImode, which gets\n ;; special-cased for TARGET_64BIT.\n-(define_mode_macro SSEMODEI [V16QI V8HI V4SI V2DI])\n+(define_mode_iterator SSEMODEI [V16QI V8HI V4SI V2DI])\n \n ;; All 16-byte vector modes handled by SSE\n-(define_mode_macro SSEMODE [V16QI V8HI V4SI V2DI V4SF V2DF])\n+(define_mode_iterator SSEMODE [V16QI V8HI V4SI V2DI V4SF V2DF])\n \n ;; Mix-n-match\n-(define_mode_macro SSEMODE12 [V16QI V8HI])\n-(define_mode_macro SSEMODE24 [V8HI V4SI])\n-(define_mode_macro SSEMODE14 [V16QI V4SI])\n-(define_mode_macro SSEMODE124 [V16QI V8HI V4SI])\n-(define_mode_macro SSEMODE248 [V8HI V4SI V2DI])\n+(define_mode_iterator SSEMODE12 [V16QI V8HI])\n+(define_mode_iterator SSEMODE24 [V8HI V4SI])\n+(define_mode_iterator SSEMODE14 [V16QI V4SI])\n+(define_mode_iterator SSEMODE124 [V16QI V8HI V4SI])\n+(define_mode_iterator SSEMODE248 [V8HI V4SI V2DI])\n \n ;; Mapping from integer vector mode to mnemonic suffix\n (define_mode_attr ssevecsize [(V16QI \"b\") (V8HI \"w\") (V4SI \"d\") (V2DI \"q\")])"}, {"sha": "7530ab533580f2be9ac804db45a805876e32596b", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -18,14 +18,14 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-(define_mode_macro IMODE [QI HI SI (DI \"TARGET_64BIT\")])\n+(define_mode_iterator IMODE [QI HI SI (DI \"TARGET_64BIT\")])\n (define_mode_attr modesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n (define_mode_attr modeconstraint [(QI \"q\") (HI \"r\") (SI \"r\") (DI \"r\")])\n (define_mode_attr immconstraint [(QI \"i\") (HI \"i\") (SI \"i\") (DI \"e\")])\n \n-(define_mode_macro CASMODE [QI HI SI (DI \"TARGET_64BIT || TARGET_CMPXCHG8B\")\n+(define_mode_iterator CASMODE [QI HI SI (DI \"TARGET_64BIT || TARGET_CMPXCHG8B\")\n \t\t\t   (TI \"TARGET_64BIT && TARGET_CMPXCHG16B\")])\n-(define_mode_macro DCASMODE\n+(define_mode_iterator DCASMODE\n   [(DI \"!TARGET_64BIT && TARGET_CMPXCHG8B && !flag_pic\")\n    (TI \"TARGET_64BIT && TARGET_CMPXCHG16B\")])\n (define_mode_attr doublemodesuffix [(DI \"8\") (TI \"16\")])"}, {"sha": "a6547a680ff3219b8be1b09ae84d9779b958652c", "filename": "gcc/config/ia64/div.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fia64%2Fdiv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fia64%2Fdiv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fdiv.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -158,7 +158,7 @@\n ;; to be written for RFmode only and to not have to handle multiple\n ;; modes or to have to handle a register in more than one mode.\n \n-(define_mode_macro SDX_F [SF DF XF])\n+(define_mode_iterator SDX_F [SF DF XF])\n \n (define_insn \"extend<mode>rf2\"\n   [(set (match_operand:RF 0 \"fr_register_operand\" \"=f\")"}, {"sha": "52f26aa84abe1114e153025f7133210c2fc088ae", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -385,8 +385,8 @@\n }\n   [(set_attr \"itanium_class\" \"ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,fld,stf,frbr,tobr,frar_i,toar_i,frar_m,toar_m,frpr,topr\")])\n \n-(define_mode_macro MODE [BI QI HI SI DI SF DF XF TI])\n-(define_mode_macro MODE_FOR_EXTEND [QI HI SI])\n+(define_mode_iterator MODE [BI QI HI SI DI SF DF XF TI])\n+(define_mode_iterator MODE_FOR_EXTEND [QI HI SI])\n \n (define_mode_attr output_a [\n   (BI \"ld1.a %0 = %1%P1\")"}, {"sha": "c467b0db0973b1fb13257e41c9d23aae49e6b4f7", "filename": "gcc/config/ia64/sync.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fia64%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fia64%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsync.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -18,12 +18,12 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-(define_mode_macro IMODE [QI HI SI DI])\n-(define_mode_macro I124MODE [QI HI SI])\n-(define_mode_macro I48MODE [SI DI])\n+(define_mode_iterator IMODE [QI HI SI DI])\n+(define_mode_iterator I124MODE [QI HI SI])\n+(define_mode_iterator I48MODE [SI DI])\n (define_mode_attr modesuffix [(QI \"1\") (HI \"2\") (SI \"4\") (DI \"8\")])\n \n-(define_code_macro FETCHOP [plus minus ior xor and])\n+(define_code_iterator FETCHOP [plus minus ior xor and])\n (define_code_attr fetchop_name\n   [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])\n "}, {"sha": "994ec90b2ebe79546c91644dc7c3e01b1a8787c6", "filename": "gcc/config/ia64/vect.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fia64%2Fvect.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fia64%2Fvect.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvect.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -20,9 +20,9 @@\n \n ;; Integer vector operations\n \n-(define_mode_macro VECINT [V8QI V4HI V2SI])\n-(define_mode_macro VECINT12 [V8QI V4HI])\n-(define_mode_macro VECINT24 [V4HI V2SI])\n+(define_mode_iterator VECINT [V8QI V4HI V2SI])\n+(define_mode_iterator VECINT12 [V8QI V4HI])\n+(define_mode_iterator VECINT24 [V4HI V2SI])\n (define_mode_attr vecsize [(V8QI \"1\") (V4HI \"2\") (V2SI \"4\")])\n \n (define_expand \"mov<mode>\""}, {"sha": "a734f71789b306fab09227ea0a1604a73447499c", "filename": "gcc/config/m32c/blkmov.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fm32c%2Fblkmov.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fm32c%2Fblkmov.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fblkmov.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -51,7 +51,7 @@\n   \"if (m32c_expand_movmemhi(operands)) DONE; FAIL;\"\n   )\n \n-;; We can't use mode macros for these because M16C uses r1h to extend\n+;; We can't use mode iterators for these because M16C uses r1h to extend\n ;; the source address, for copying data from ROM to RAM.  We don't yet\n ;; support that, but we need to zero our r1h, so the patterns differ.\n "}, {"sha": "4bc4d05fbf19f3d57798ba6a9368477b5bad3d83", "filename": "gcc/config/m32c/m32c.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fm32c%2Fm32c.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fm32c%2Fm32c.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -54,15 +54,15 @@\n (define_attr \"flags\" \"x,c,z,zc,s,sc,sz,szc,o,oc,oz,ozc,os,osc,osz,oszc,n\" (const_string \"n\"))\n (define_asm_attributes [(set_attr \"flags\" \"x\")])\n \n-(define_mode_macro QHI [QI HI])\n-(define_mode_macro HPSI [(HI \"TARGET_A16\") (PSI \"TARGET_A24\")])\n-(define_mode_macro QHPSI [QI HI (PSI \"TARGET_A24\")])\n-(define_mode_macro QHSI [QI HI (SI \"TARGET_A24\")])\n+(define_mode_iterator QHI [QI HI])\n+(define_mode_iterator HPSI [(HI \"TARGET_A16\") (PSI \"TARGET_A24\")])\n+(define_mode_iterator QHPSI [QI HI (PSI \"TARGET_A24\")])\n+(define_mode_iterator QHSI [QI HI (SI \"TARGET_A24\")])\n (define_mode_attr bwl [(QI \"b\") (HI \"w\") (PSI \"l\") (SI \"l\")])\n \n-(define_code_macro any_cond [eq ne gt ge lt le gtu geu ltu leu])\n-(define_code_macro eqne_cond [eq ne])\n-(define_code_macro gl_cond [gt ge lt le gtu geu ltu leu])\n+(define_code_iterator any_cond [eq ne gt ge lt le gtu geu ltu leu])\n+(define_code_iterator eqne_cond [eq ne])\n+(define_code_iterator gl_cond [gt ge lt le gtu geu ltu leu])\n \n \n "}, {"sha": "99ee142d6d1f6a0f83ef7fdbe67bbdf668cb49d5", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -138,7 +138,7 @@\n \f\n ;; Mode macros for floating point operations.\n ;; Valid floating point modes\n-(define_mode_macro FP [SF DF (XF \"TARGET_68881\")])\n+(define_mode_iterator FP [SF DF (XF \"TARGET_68881\")])\n ;; Mnemonic infix to round result\n (define_mode_attr round [(SF \"%$\") (DF \"%&\") (XF \"\")])\n ;; Mnemonic infix to round result for mul or div instruction"}, {"sha": "60b3a94ee6a5f3a4c02f26d9590c4fa14897368a", "filename": "gcc/config/mips/mips-dsp.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-dsp.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -6,18 +6,18 @@\n    (CCDSP_CC_REGNUM\t186)\n    (CCDSP_EF_REGNUM\t187)])\n \n-;; This mode macro allows si, v2hi, v4qi for all possible modes in DSP ASE.\n-(define_mode_macro DSP [(SI \"TARGET_DSP\")\n-\t\t\t(V2HI \"TARGET_DSP\")\n-\t\t \t(V4QI \"TARGET_DSP\")])\n-\n-;; This mode macro allows v2hi, v4qi for vector/SIMD data.\n-(define_mode_macro DSPV [(V2HI \"TARGET_DSP\")\n-\t\t\t (V4QI \"TARGET_DSP\")])\n-\n-;; This mode macro allows si, v2hi for Q31 and V2Q15 fixed-point data.\n-(define_mode_macro DSPQ [(SI \"TARGET_DSP\")\n-\t\t         (V2HI \"TARGET_DSP\")])\n+;; This mode iterator allows si, v2hi, v4qi for all possible modes in DSP ASE.\n+(define_mode_iterator DSP [(SI \"TARGET_DSP\")\n+\t\t\t   (V2HI \"TARGET_DSP\")\n+\t\t \t   (V4QI \"TARGET_DSP\")])\n+\n+;; This mode iterator allows v2hi, v4qi for vector/SIMD data.\n+(define_mode_iterator DSPV [(V2HI \"TARGET_DSP\")\n+\t\t\t    (V4QI \"TARGET_DSP\")])\n+\n+;; This mode iterator allows si, v2hi for Q31 and V2Q15 fixed-point data.\n+(define_mode_iterator DSPQ [(SI \"TARGET_DSP\")\n+\t\t\t    (V2HI \"TARGET_DSP\")])\n \n ;; DSP instructions use q for fixed-point data, and u for integer in the infix.\n (define_mode_attr dspfmt1 [(SI \"q\") (V2HI \"q\") (V4QI \"u\")])"}, {"sha": "44c3c9c135f03136343576858a2b62c6b914935f", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -464,31 +464,31 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"can_delay\" \"no\")])\n \f\n-;; This mode macro allows 32-bit and 64-bit GPR patterns to be generated\n+;; This mode iterator allows 32-bit and 64-bit GPR patterns to be generated\n ;; from the same template.\n-(define_mode_macro GPR [SI (DI \"TARGET_64BIT\")])\n+(define_mode_iterator GPR [SI (DI \"TARGET_64BIT\")])\n \n-;; This mode macro allows :P to be used for patterns that operate on\n+;; This mode iterator allows :P to be used for patterns that operate on\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n-(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+(define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n \n-;; This mode macro allows :MOVECC to be used anywhere that a\n+;; This mode iterator allows :MOVECC to be used anywhere that a\n ;; conditional-move-type condition is needed.\n-(define_mode_macro MOVECC [SI (DI \"TARGET_64BIT\") (CC \"TARGET_HARD_FLOAT\")])\n+(define_mode_iterator MOVECC [SI (DI \"TARGET_64BIT\") (CC \"TARGET_HARD_FLOAT\")])\n \n-;; This mode macro allows the QI and HI extension patterns to be defined from\n+;; This mode iterator allows the QI and HI extension patterns to be defined from\n ;; the same template.\n-(define_mode_macro SHORT [QI HI])\n+(define_mode_iterator SHORT [QI HI])\n \n-;; This mode macro allows :ANYF to be used wherever a scalar or vector\n+;; This mode iterator allows :ANYF to be used wherever a scalar or vector\n ;; floating-point mode is allowed.\n-(define_mode_macro ANYF [(SF \"TARGET_HARD_FLOAT\")\n-\t\t\t (DF \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\")\n-\t\t\t (V2SF \"TARGET_PAIRED_SINGLE_FLOAT\")])\n+(define_mode_iterator ANYF [(SF \"TARGET_HARD_FLOAT\")\n+\t\t\t    (DF \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\")\n+\t\t\t    (V2SF \"TARGET_PAIRED_SINGLE_FLOAT\")])\n \n ;; Like ANYF, but only applies to scalar modes.\n-(define_mode_macro SCALARF [(SF \"TARGET_HARD_FLOAT\")\n-\t\t\t    (DF \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\")])\n+(define_mode_iterator SCALARF [(SF \"TARGET_HARD_FLOAT\")\n+\t\t\t       (DF \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\")])\n \n ;; In GPR templates, a string like \"<d>subu\" will expand to \"subu\" in the\n ;; 32-bit version and \"dsubu\" in the 64-bit version.\n@@ -545,26 +545,26 @@\n (define_mode_attr recip_condition\n   [(SF \"ISA_HAS_FP4\") (DF \"ISA_HAS_FP4\") (V2SF \"TARGET_SB1\")])\n \n-;; This code macro allows all branch instructions to be generated from\n+;; This code iterator allows all branch instructions to be generated from\n ;; a single define_expand template.\n-(define_code_macro any_cond [unordered ordered unlt unge uneq ltgt unle ungt\n-\t\t\t     eq ne gt ge lt le gtu geu ltu leu])\n+(define_code_iterator any_cond [unordered ordered unlt unge uneq ltgt unle ungt\n+\t\t\t        eq ne gt ge lt le gtu geu ltu leu])\n \n-;; This code macro allows signed and unsigned widening multiplications\n+;; This code iterator allows signed and unsigned widening multiplications\n ;; to use the same template.\n-(define_code_macro any_extend [sign_extend zero_extend])\n+(define_code_iterator any_extend [sign_extend zero_extend])\n \n-;; This code macro allows the three shift instructions to be generated\n+;; This code iterator allows the three shift instructions to be generated\n ;; from the same template.\n-(define_code_macro any_shift [ashift ashiftrt lshiftrt])\n+(define_code_iterator any_shift [ashift ashiftrt lshiftrt])\n \n-;; This code macro allows all native floating-point comparisons to be\n+;; This code iterator allows all native floating-point comparisons to be\n ;; generated from the same template.\n-(define_code_macro fcond [unordered uneq unlt unle eq lt le])\n+(define_code_iterator fcond [unordered uneq unlt unle eq lt le])\n \n-;; This code macro is used for comparisons that can be implemented\n+;; This code iterator is used for comparisons that can be implemented\n ;; by swapping the operands.\n-(define_code_macro swapped_fcond [ge gt unge ungt])\n+(define_code_iterator swapped_fcond [ge gt unge ungt])\n \n ;; <u> expands to an empty string when doing a signed operation and\n ;; \"u\" when doing an unsigned operation."}, {"sha": "2261a9369f38910150a7f991e9c4d375059b8741", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -162,13 +162,13 @@\n   ])\n \n ;; Vec int modes\n-(define_mode_macro VI [V4SI V8HI V16QI])\n+(define_mode_iterator VI [V4SI V8HI V16QI])\n ;; Short vec in modes\n-(define_mode_macro VIshort [V8HI V16QI])\n+(define_mode_iterator VIshort [V8HI V16QI])\n ;; Vec float modes\n-(define_mode_macro VF [V4SF])\n-;; Vec modes, pity mode macros are not composable\n-(define_mode_macro V [V4SI V8HI V16QI V4SF])\n+(define_mode_iterator VF [V4SF])\n+;; Vec modes, pity mode iterators are not composable\n+(define_mode_iterator V [V4SI V8HI V16QI V4SF])\n \n (define_mode_attr VI_char [(V4SI \"w\") (V8HI \"h\") (V16QI \"b\")])\n "}, {"sha": "c9eccddb7daa7c55100d457d17d4f1a9cc28cd7b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -176,30 +176,30 @@\n (include \"darwin.md\")\n \n \f\n-;; Mode macros\n+;; Mode iterators\n \n-; This mode macro allows :GPR to be used to indicate the allowable size\n+; This mode iterator allows :GPR to be used to indicate the allowable size\n ; of whole values in GPRs.\n-(define_mode_macro GPR [SI (DI \"TARGET_POWERPC64\")])\n+(define_mode_iterator GPR [SI (DI \"TARGET_POWERPC64\")])\n \n ; Any supported integer mode.\n-(define_mode_macro INT [QI HI SI DI TI])\n+(define_mode_iterator INT [QI HI SI DI TI])\n \n ; Any supported integer mode that fits in one register.\n-(define_mode_macro INT1 [QI HI SI (DI \"TARGET_POWERPC64\")])\n+(define_mode_iterator INT1 [QI HI SI (DI \"TARGET_POWERPC64\")])\n \n ; extend modes for DImode\n-(define_mode_macro QHSI [QI HI SI])\n+(define_mode_iterator QHSI [QI HI SI])\n \n ; SImode or DImode, even if DImode doesn't fit in GPRs.\n-(define_mode_macro SDI [SI DI])\n+(define_mode_iterator SDI [SI DI])\n \n ; The size of a pointer.  Also, the size of the value that a record-condition\n ; (one with a '.') will compare.\n-(define_mode_macro P [(SI \"TARGET_32BIT\") (DI \"TARGET_64BIT\")])\n+(define_mode_iterator P [(SI \"TARGET_32BIT\") (DI \"TARGET_64BIT\")])\n \n ; Any hardware-supported floating-point mode\n-(define_mode_macro FP [(SF \"TARGET_HARD_FLOAT\")\n+(define_mode_iterator FP [(SF \"TARGET_HARD_FLOAT\")\n   (DF \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\")\n   (TF \"!TARGET_IEEEQUAD\n    && TARGET_HARD_FLOAT"}, {"sha": "b7b2fef8eab8b1e5ce4405b89cd0be6822cf313d", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -36,13 +36,13 @@\n    ])\n \n ;; Modes using a 64-bit register.\n-(define_mode_macro SPE64 [DF V4HI V2SF V1DI V2SI])\n+(define_mode_iterator SPE64 [DF V4HI V2SF V1DI V2SI])\n \n ;; Likewise, but allow TFmode (two registers) as well.\n-(define_mode_macro SPE64TF [DF V4HI V2SF V1DI V2SI TF])\n+(define_mode_iterator SPE64TF [DF V4HI V2SF V1DI V2SI TF])\n \n ;; DImode and TImode.\n-(define_mode_macro DITI [DI TI])\n+(define_mode_iterator DITI [DI TI])\n \n (define_insn \"*negsf2_gpr\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")"}, {"sha": "5839715464547b4b5326057823c7cc3108669b96", "filename": "gcc/config/rs6000/sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Frs6000%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Frs6000%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsync.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -21,7 +21,7 @@\n (define_mode_attr larx [(SI \"lwarx\") (DI \"ldarx\")])\n (define_mode_attr stcx [(SI \"stwcx.\") (DI \"stdcx.\")])\n \n-(define_code_macro FETCHOP [plus minus ior xor and])\n+(define_code_iterator FETCHOP [plus minus ior xor and])\n (define_code_attr fetchop_name\n   [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])\n (define_code_attr fetchop_pred"}, {"sha": "e0e9edc3f4abfe2fe38a19ecab558a6f41acd07e", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -246,54 +246,54 @@\n ;; Other includes\n (include \"tpf.md\")\n \n-;; Macros\n+;; Iterators\n \n-;; This mode macro allows floating point patterns to be generated from the\n+;; These mode iterators allow floating point patterns to be generated from the\n ;; same template.\n-(define_mode_macro FP [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")])\n-(define_mode_macro BFP [TF DF SF])\n-(define_mode_macro DFP [TD DD])\n-(define_mode_macro DFP_ALL [TD DD SD])\n-(define_mode_macro DSF [DF SF])\n-(define_mode_macro SD_SF [SF SD])\n-(define_mode_macro DD_DF [DF DD])\n-(define_mode_macro TD_TF [TF TD])\n-\n-;; These mode macros allow 31-bit and 64-bit TDSI patterns to be generated\n+(define_mode_iterator FP [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")])\n+(define_mode_iterator BFP [TF DF SF])\n+(define_mode_iterator DFP [TD DD])\n+(define_mode_iterator DFP_ALL [TD DD SD])\n+(define_mode_iterator DSF [DF SF])\n+(define_mode_iterator SD_SF [SF SD])\n+(define_mode_iterator DD_DF [DF DD])\n+(define_mode_iterator TD_TF [TF TD])\n+\n+;; This mode iterator allows 31-bit and 64-bit TDSI patterns to be generated\n ;; from the same template.\n-(define_mode_macro TDSI [(TI \"TARGET_64BIT\") DI SI])\n+(define_mode_iterator TDSI [(TI \"TARGET_64BIT\") DI SI])\n \n-;; These mode macros allow 31-bit and 64-bit GPR patterns to be generated\n+;; These mode iterators allow 31-bit and 64-bit GPR patterns to be generated\n ;; from the same template.\n-(define_mode_macro GPR [(DI \"TARGET_64BIT\") SI])\n-(define_mode_macro DSI [DI SI])\n+(define_mode_iterator GPR [(DI \"TARGET_64BIT\") SI])\n+(define_mode_iterator DSI [DI SI])\n \n-;; This mode macro allows :P to be used for patterns that operate on\n+;; These mode iterators allow :P to be used for patterns that operate on\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n-(define_mode_macro DP  [(TI \"TARGET_64BIT\") (DI \"!TARGET_64BIT\")])\n-(define_mode_macro P [(DI \"TARGET_64BIT\") (SI \"!TARGET_64BIT\")])\n+(define_mode_iterator DP  [(TI \"TARGET_64BIT\") (DI \"!TARGET_64BIT\")])\n+(define_mode_iterator P [(DI \"TARGET_64BIT\") (SI \"!TARGET_64BIT\")])\n \n-;; This mode macro allows the QI and HI patterns to be defined from\n+;; This mode iterator allows the QI and HI patterns to be defined from\n ;; the same template.\n-(define_mode_macro HQI [HI QI])\n+(define_mode_iterator HQI [HI QI])\n \n-;; This mode macro allows the integer patterns to be defined from the\n+;; This mode iterator allows the integer patterns to be defined from the\n ;; same template.\n-(define_mode_macro INT [(DI \"TARGET_64BIT\") SI HI QI])\n+(define_mode_iterator INT [(DI \"TARGET_64BIT\") SI HI QI])\n \n-;; This macro allows to unify all 'bCOND' expander patterns.\n-(define_code_macro COMPARE [eq ne gt gtu lt ltu ge geu le leu unordered \n+;; This iterator allows to unify all 'bCOND' expander patterns.\n+(define_code_iterator COMPARE [eq ne gt gtu lt ltu ge geu le leu unordered \n \t\t            ordered uneq unlt ungt unle unge ltgt])\n \n-;; This macro allows to unify all 'sCOND' patterns.\n-(define_code_macro SCOND [ltu gtu leu geu])\n+;; This iterator allows to unify all 'sCOND' patterns.\n+(define_code_iterator SCOND [ltu gtu leu geu])\n \n-;; This macro allows some 'ashift' and 'lshiftrt' pattern to be defined from\n+;; This iterator allows some 'ashift' and 'lshiftrt' pattern to be defined from\n ;; the same template.\n-(define_code_macro SHIFT [ashift lshiftrt])\n+(define_code_iterator SHIFT [ashift lshiftrt])\n \n-;; These macros allow to combine most atomic operations.\n-(define_code_macro ATOMIC [and ior xor plus minus mult])\n+;; This iterator and attribute allow to combine most atomic operations.\n+(define_code_iterator ATOMIC [and ior xor plus minus mult])\n (define_code_attr atomic [(and \"and\") (ior \"ior\") (xor \"xor\") \n \t\t\t  (plus \"add\") (minus \"sub\") (mult \"nand\")])\n \n@@ -312,18 +312,18 @@\n (define_mode_attr RXe [(TF \"RXE\") (DF \"RX\") (SF \"RX\")])\n \n ;; The decimal floating point variants of add, sub, div and mul support 3\n-;; fp register operands.  The following macros allow to merge the bfp and\n+;; fp register operands.  The following attributes allow to merge the bfp and\n ;; dfp variants in a single insn definition.\n \n-;; This macro is used to set op_type accordingly.\n+;; This attribute is used to set op_type accordingly.\n (define_mode_attr RRer [(TF \"RRE\") (DF \"RRE\") (SF \"RRE\") (TD \"RRR\") \n                         (DD \"RRR\") (SD \"RRR\")])\n \n-;; This macro is used in the operand constraint list in order to have the \n+;; This attribute is used in the operand constraint list in order to have the \n ;; first and the second operand match for bfp modes.\n (define_mode_attr f0 [(TF \"0\") (DF \"0\") (SF \"0\") (TD \"f\") (DD \"f\") (DD \"f\")])\n \n-;; This macro is used in the operand list of the instruction to have an \n+;; This attribute is used in the operand list of the instruction to have an \n ;; additional operand for the dfp instructions.\n (define_mode_attr op1 [(TF \"\") (DF \"\") (SF \"\")\n                        (TD \"%1,\") (DD \"%1,\") (SD \"%1,\")])\n@@ -341,7 +341,7 @@\n ;; This is used to disable the memory alternative in TFmode patterns.\n (define_mode_attr Rf [(TF \"f\") (DF \"R\") (SF \"R\") (TD \"f\") (DD \"f\") (SD \"f\")])\n \n-;; This macro adds b for bfp instructions and t for dfp instructions and is used\n+;; This attribute adds b for bfp instructions and t for dfp instructions and is used\n ;; within instruction mnemonics.\n (define_mode_attr bt [(TF \"b\") (DF \"b\") (SF \"b\") (TD \"t\") (DD \"t\") (SD \"t\")])\n "}, {"sha": "329dd1a7ab10b162d7b090cef7e21495dc039a9f", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -1701,7 +1701,7 @@\n    (set_attr \"branch_type\" \"reg\")])\n \n \n-(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+(define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n \n ;; Load in operand 0 the (absolute) address of operand 1, which is a symbolic\n ;; value subject to a PC-relative relocation.  Operand 2 is a helper function\n@@ -2340,7 +2340,7 @@\n ;; Floating point and vector move instructions\n \n ;; We don't define V1SI because SI should work just fine.\n-(define_mode_macro V32 [SF V2HI V4QI])\n+(define_mode_iterator V32 [SF V2HI V4QI])\n \n ;; Yes, you guessed it right, the former movsf expander.\n (define_expand \"mov<V32:mode>\"\n@@ -2476,7 +2476,7 @@\n   [(set (match_dup 0) (high:SF (match_dup 1)))\n    (set (match_dup 0) (lo_sum:SF (match_dup 0) (match_dup 1)))])\n \n-(define_mode_macro V64 [DF V2SI V4HI V8QI])\n+(define_mode_iterator V64 [DF V2SI V4HI V8QI])\n \n ;; Yes, you again guessed it right, the former movdf expander.\n (define_expand \"mov<V64:mode>\"\n@@ -5276,8 +5276,8 @@\n ;; We define DImode `and' so with DImode `not' we can get\n ;; DImode `andn'.  Other combinations are possible.\n \n-(define_mode_macro V64I [DI V2SI V4HI V8QI])\n-(define_mode_macro V32I [SI V2HI V4QI])\n+(define_mode_iterator V64I [DI V2SI V4HI V8QI])\n+(define_mode_iterator V32I [SI V2HI V4QI])\n \n (define_expand \"and<V64I:mode>3\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"\")"}, {"sha": "17cf691d5b489cb0965023bae083e94ab8ca1622", "filename": "gcc/config/sparc/sync.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fsparc%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fsparc%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsync.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -18,9 +18,9 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-(define_mode_macro I12MODE [QI HI])\n-(define_mode_macro I24MODE [HI SI])\n-(define_mode_macro I48MODE [SI (DI \"TARGET_ARCH64 || TARGET_V8PLUS\")])\n+(define_mode_iterator I12MODE [QI HI])\n+(define_mode_iterator I24MODE [HI SI])\n+(define_mode_iterator I48MODE [SI (DI \"TARGET_ARCH64 || TARGET_V8PLUS\")])\n (define_mode_attr modesuffix [(SI \"\") (DI \"x\")])\n \n (define_expand \"memory_barrier\""}, {"sha": "5dcc45ed0c4b1ffe3dea2939605bb6baf6b75763", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -159,9 +159,9 @@\n (include \"constraints.md\")\n \n \f\n-;; Mode macros\n+;; Mode iterators\n \n-(define_mode_macro ALL [QI V16QI\n+(define_mode_iterator ALL [QI V16QI\n \t\t\tHI V8HI\n \t\t\tSI V4SI\n \t\t\tDI V2DI\n@@ -171,43 +171,43 @@\n \n ; Everything except DI and TI which are handled separately because\n ; they need different constraints to correctly test VOIDmode constants\n-(define_mode_macro MOV [QI V16QI\n+(define_mode_iterator MOV [QI V16QI\n \t\t\tHI V8HI\n \t\t\tSI V4SI\n \t\t\tV2DI\n                         SF V4SF\n                         DF V2DF])\n \n-(define_mode_macro DTI  [DI TI])\n+(define_mode_iterator DTI  [DI TI])\n \n-(define_mode_macro VINT [QI V16QI\n+(define_mode_iterator VINT [QI V16QI\n \t\t\t HI V8HI\n \t\t\t SI V4SI\n \t\t\t DI V2DI\n \t\t\t TI])\n \n-(define_mode_macro VQHSI [QI V16QI\n+(define_mode_iterator VQHSI [QI V16QI\n \t\t\t  HI V8HI\n \t\t\t  SI V4SI])\n \n-(define_mode_macro VHSI [HI V8HI\n+(define_mode_iterator VHSI [HI V8HI\n \t\t\t SI V4SI])\n \n-(define_mode_macro VSDF [SF V4SF\n+(define_mode_iterator VSDF [SF V4SF\n                          DF V2DF])\n \n-(define_mode_macro VSI [SI V4SI])\n-(define_mode_macro VDI [DI V2DI])\n-(define_mode_macro VSF [SF V4SF])\n-(define_mode_macro VDF [DF V2DF])\n+(define_mode_iterator VSI [SI V4SI])\n+(define_mode_iterator VDI [DI V2DI])\n+(define_mode_iterator VSF [SF V4SF])\n+(define_mode_iterator VDF [DF V2DF])\n \n-(define_mode_macro VCMP [V16QI\n+(define_mode_iterator VCMP [V16QI\n \t\t\t V8HI\n \t\t\t V4SI\n                          V4SF\n                          V2DF])\n \n-(define_mode_macro VCMPU [V16QI\n+(define_mode_iterator VCMPU [V16QI\n \t\t\t  V8HI\n \t\t\t  V4SI])\n \n@@ -233,10 +233,10 @@\n \t\t          (SI \"G\")  (V4SI \"G\")])\n \n ;; Used for carry and borrow instructions.\n-(define_mode_macro CBOP  [SI DI V4SI V2DI])\n+(define_mode_iterator CBOP  [SI DI V4SI V2DI])\n \n ;; Used in vec_set and vec_extract\n-(define_mode_macro V [V2DI V4SI V8HI V16QI V2DF V4SF])\n+(define_mode_iterator V [V2DI V4SI V8HI V16QI V2DF V4SF])\n (define_mode_attr inner  [(V16QI \"QI\")\n \t\t\t  (V8HI  \"HI\")\n \t\t\t  (V4SI  \"SI\")"}, {"sha": "0bc05b461dc7f50eab91536aa533ef55ba233032", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -42,11 +42,11 @@\n \n ;; Integer modes supported on VAX, with a mapping from machine mode\n ;; to mnemonic suffix.  DImode is always a special case.\n-(define_mode_macro VAXint [QI HI SI])\n+(define_mode_iterator VAXint [QI HI SI])\n (define_mode_attr  isfx [(QI \"b\") (HI \"w\") (SI \"l\")])\n \n ;; Similar for float modes supported on VAX.\n-(define_mode_macro VAXfp [SF DF])\n+(define_mode_iterator VAXfp [SF DF])\n (define_mode_attr  fsfx [(SF \"f\") (DF \"%#\")])\n \n ;; Some output patterns want integer immediates with a prefix...\n@@ -1012,7 +1012,7 @@\n   \"jbr %l0\")\n \n ;; Conditional jumps\n-(define_code_macro any_cond [eq ne gt lt gtu ltu ge le geu leu])\n+(define_code_iterator any_cond [eq ne gt lt gtu ltu ge le geu leu])\n \n (define_insn \"b<code>\"\n   [(set (pc)"}, {"sha": "2f47540a766186cd82034c01541dbaa77a25e1ba", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -37,9 +37,9 @@\n   (UNSPECV_S32C1I\t5)\n ])\n \n-;; This code macro allows signed and unsigned widening multiplications\n+;; This code iterator allows signed and unsigned widening multiplications\n ;; to use the same template.\n-(define_code_macro any_extend [sign_extend zero_extend])\n+(define_code_iterator any_extend [sign_extend zero_extend])\n \n ;; <u> expands to an empty string when doing a signed operation and\n ;; \"u\" when doing an unsigned operation.\n@@ -48,32 +48,32 @@\n ;; <su> is like <u>, but the signed form expands to \"s\" rather than \"\".\n (define_code_attr su [(sign_extend \"s\") (zero_extend \"u\")])\n \n-;; This code macro allows four integer min/max operations to be\n+;; This code iterator allows four integer min/max operations to be\n ;; generated from one template.\n-(define_code_macro any_minmax [smin umin smax umax])\n+(define_code_iterator any_minmax [smin umin smax umax])\n \n ;; <minmax> expands to the opcode name for any_minmax operations.\n (define_code_attr minmax [(smin \"min\") (umin \"minu\")\n \t\t\t  (smax \"max\") (umax \"maxu\")])\n \n-;; This code macro allows all branch instructions to be generated from\n+;; This code iterator allows all branch instructions to be generated from\n ;; a single define_expand template.\n-(define_code_macro any_cond [eq ne gt ge lt le gtu geu ltu leu])\n+(define_code_iterator any_cond [eq ne gt ge lt le gtu geu ltu leu])\n \n-;; This code macro is for setting a register from a comparison.\n-(define_code_macro any_scc [eq ne gt ge lt le])\n+;; This code iterator is for setting a register from a comparison.\n+(define_code_iterator any_scc [eq ne gt ge lt le])\n \n-;; This code macro is for floating-point comparisons.\n-(define_code_macro any_scc_sf [eq lt le])\n+;; This code iterator is for floating-point comparisons.\n+(define_code_iterator any_scc_sf [eq lt le])\n \n-;; These macros allow to combine most atomic operations.\n-(define_code_macro ATOMIC [and ior xor plus minus mult])\n+;; This iterator and attribute allow to combine most atomic operations.\n+(define_code_iterator ATOMIC [and ior xor plus minus mult])\n (define_code_attr atomic [(and \"and\") (ior \"ior\") (xor \"xor\") \n \t\t\t  (plus \"add\") (minus \"sub\") (mult \"nand\")])\n \n-;; These mode macros allow the HI and QI patterns to be defined from\n+;; This mode iterator allows the HI and QI patterns to be defined from\n ;; the same template.\n-(define_mode_macro HQI [HI QI])\n+(define_mode_iterator HQI [HI QI])\n \n \f\n ;; Attributes."}, {"sha": "51da432c4fc829613fd29c4a9acc851f61de77d8", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -47,7 +47,7 @@ See the next chapter for information on the C header file.\n                            predication.\n * Constant Definitions::Defining symbolic constants that can be used in the\n                         md file.\n-* Macros::              Using macros to generate patterns from a template.\n+* Iterators::           Using iterators to generate patterns from a template.\n @end menu\n \n @node Overview\n@@ -7649,22 +7649,22 @@ The constants that are defined with a define_constant are also output\n in the insn-codes.h header file as #defines.\n @end ifset\n @ifset INTERNALS\n-@node Macros\n-@section Macros\n-@cindex macros in @file{.md} files\n+@node Iterators\n+@section Iterators\n+@cindex iterators in @file{.md} files\n \n Ports often need to define similar patterns for more than one machine\n-mode or for more than one rtx code.  GCC provides some simple macro\n+mode or for more than one rtx code.  GCC provides some simple iterator\n facilities to make this process easier.\n \n @menu\n-* Mode Macros::         Generating variations of patterns for different modes.\n-* Code Macros::         Doing the same for codes.\n+* Mode Iterators::         Generating variations of patterns for different modes.\n+* Code Iterators::         Doing the same for codes.\n @end menu\n \n-@node Mode Macros\n-@subsection Mode Macros\n-@cindex mode macros in @file{.md} files\n+@node Mode Iterators\n+@subsection Mode Iterators\n+@cindex mode iterators in @file{.md} files\n \n Ports often need to define similar patterns for two or more different modes.\n For example:\n@@ -7681,25 +7681,25 @@ If a port uses @code{SImode} pointers in one configuration and\n @code{SImode} and @code{DImode} patterns for manipulating pointers.\n @end itemize\n \n-Mode macros allow several patterns to be instantiated from one\n+Mode iterators allow several patterns to be instantiated from one\n @file{.md} file template.  They can be used with any type of\n rtx-based construct, such as a @code{define_insn},\n @code{define_split}, or @code{define_peephole2}.\n \n @menu\n-* Defining Mode Macros:: Defining a new mode macro.\n-* Substitutions::\t Combining mode macros with substitutions\n-* Examples::             Examples\n+* Defining Mode Iterators:: Defining a new mode iterator.\n+* Substitutions::\t    Combining mode iterators with substitutions\n+* Examples::\t\t    Examples\n @end menu\n \n-@node Defining Mode Macros\n-@subsubsection Defining Mode Macros\n-@findex define_mode_macro\n+@node Defining Mode Iterators\n+@subsubsection Defining Mode Iterators\n+@findex define_mode_iterator\n \n-The syntax for defining a mode macro is:\n+The syntax for defining a mode iterator is:\n \n @smallexample\n-(define_mode_macro @var{name} [(@var{mode1} \"@var{cond1}\") ... (@var{moden} \"@var{condn}\")])\n+(define_mode_iterator @var{name} [(@var{mode1} \"@var{cond1}\") ... (@var{moden} \"@var{condn}\")])\n @end smallexample\n \n This allows subsequent @file{.md} file constructs to use the mode suffix\n@@ -7712,7 +7712,7 @@ C condition will also require that @var{condi} be true.\n For example:\n \n @smallexample\n-(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+(define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n @end smallexample\n \n defines a new mode suffix @code{:P}.  Every construct that uses\n@@ -7726,21 +7726,21 @@ as ``always true''.  @code{(@var{mode} \"\")} can also be abbreviated\n to @code{@var{mode}}.  For example:\n \n @smallexample\n-(define_mode_macro GPR [SI (DI \"TARGET_64BIT\")])\n+(define_mode_iterator GPR [SI (DI \"TARGET_64BIT\")])\n @end smallexample\n \n means that the @code{:DI} expansion only applies if @code{TARGET_64BIT}\n but that the @code{:SI} expansion has no such constraint.\n \n-Macros are applied in the order they are defined.  This can be\n-significant if two macros are used in a construct that requires\n+Iterators are applied in the order they are defined.  This can be\n+significant if two iterators are used in a construct that requires\n substitutions.  @xref{Substitutions}.\n \n @node Substitutions\n-@subsubsection Substitution in Mode Macros\n+@subsubsection Substitution in Mode Iterators\n @findex define_mode_attr\n \n-If an @file{.md} file construct uses mode macros, each version of the\n+If an @file{.md} file construct uses mode iterators, each version of the\n construct will often need slightly different strings or modes.  For\n example:\n \n@@ -7756,7 +7756,7 @@ each instruction will often use a different assembler mnemonic.\n \n @item\n When a @code{define_insn} requires operands with different modes,\n-using a macro for one of the operand modes usually requires a specific\n+using an iterator for one of the operand modes usually requires a specific\n mode for the other operand(s).\n @end itemize\n \n@@ -7772,17 +7772,17 @@ upper case.  You can define other attributes using:\n where @var{name} is the name of the attribute and @var{valuei}\n is the value associated with @var{modei}.\n \n-When GCC replaces some @var{:macro} with @var{:mode}, it will scan\n+When GCC replaces some @var{:iterator} with @var{:mode}, it will scan\n each string and mode in the pattern for sequences of the form\n-@code{<@var{macro}:@var{attr}>}, where @var{attr} is the name of a\n+@code{<@var{iterator}:@var{attr}>}, where @var{attr} is the name of a\n mode attribute.  If the attribute is defined for @var{mode}, the whole\n @code{<...>} sequence will be replaced by the appropriate attribute\n value.\n \n For example, suppose an @file{.md} file has:\n \n @smallexample\n-(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+(define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n (define_mode_attr load [(SI \"lw\") (DI \"ld\")])\n @end smallexample\n \n@@ -7794,23 +7794,23 @@ will use @code{\"lw\\t%0,%1\"} and the @code{DI} version will use\n Here is an example of using an attribute for a mode:\n \n @smallexample\n-(define_mode_macro LONG [SI DI])\n+(define_mode_iterator LONG [SI DI])\n (define_mode_attr SHORT [(SI \"HI\") (DI \"SI\")])\n (define_insn ...\n   (sign_extend:LONG (match_operand:<LONG:SHORT> ...)) ...)\n @end smallexample\n \n-The @code{@var{macro}:} prefix may be omitted, in which case the\n-substitution will be attempted for every macro expansion.\n+The @code{@var{iterator}:} prefix may be omitted, in which case the\n+substitution will be attempted for every iterator expansion.\n \n @node Examples\n-@subsubsection Mode Macro Examples\n+@subsubsection Mode Iterator Examples\n \n Here is an example from the MIPS port.  It defines the following\n modes and attributes (among others):\n \n @smallexample\n-(define_mode_macro GPR [SI (DI \"TARGET_64BIT\")])\n+(define_mode_iterator GPR [SI (DI \"TARGET_64BIT\")])\n (define_mode_attr d [(SI \"\") (DI \"d\")])\n @end smallexample\n \n@@ -7850,28 +7850,28 @@ This is exactly equivalent to:\n    (set_attr \"mode\" \"DI\")])\n @end smallexample\n \n-@node Code Macros\n-@subsection Code Macros\n-@cindex code macros in @file{.md} files\n-@findex define_code_macro\n+@node Code Iterators\n+@subsection Code Iterators\n+@cindex code iterators in @file{.md} files\n+@findex define_code_iterator\n @findex define_code_attr\n \n-Code macros operate in a similar way to mode macros.  @xref{Mode Macros}.\n+Code iterators operate in a similar way to mode iterators.  @xref{Mode Iterators}.\n \n The construct:\n \n @smallexample\n-(define_code_macro @var{name} [(@var{code1} \"@var{cond1}\") ... (@var{coden} \"@var{condn}\")])\n+(define_code_iterator @var{name} [(@var{code1} \"@var{cond1}\") ... (@var{coden} \"@var{condn}\")])\n @end smallexample\n \n defines a pseudo rtx code @var{name} that can be instantiated as\n @var{codei} if condition @var{condi} is true.  Each @var{codei}\n must have the same rtx format.  @xref{RTL Classes}.\n \n-As with mode macros, each pattern that uses @var{name} will be\n+As with mode iterators, each pattern that uses @var{name} will be\n expanded @var{n} times, once with all uses of @var{name} replaced by\n @var{code1}, once with all uses replaced by @var{code2}, and so on.\n-@xref{Defining Mode Macros}.\n+@xref{Defining Mode Iterators}.\n \n It is possible to define attributes for codes as well as for modes.\n There are two standard code attributes: @code{code}, the name of the\n@@ -7882,11 +7882,11 @@ Other attributes are defined using:\n (define_code_attr @var{name} [(@var{code1} \"@var{value1}\") ... (@var{coden} \"@var{valuen}\")])\n @end smallexample\n \n-Here's an example of code macros in action, taken from the MIPS port:\n+Here's an example of code iterators in action, taken from the MIPS port:\n \n @smallexample\n-(define_code_macro any_cond [unordered ordered unlt unge uneq ltgt unle ungt\n-                             eq ne gt ge lt le gtu geu ltu leu])\n+(define_code_iterator any_cond [unordered ordered unlt unge uneq ltgt unle ungt\n+                                eq ne gt ge lt le gtu geu ltu leu])\n \n (define_expand \"b<code>\"\n   [(set (pc)"}, {"sha": "fbb67b47785a35212aa45253416975dc756c9eb3", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 125, "deletions": 124, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcb3a78118cb492da39fe43fc45cac4c80a07f/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=3abcb3a78118cb492da39fe43fc45cac4c80a07f", "patch": "@@ -21,7 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"bconfig.h\"\n \n-/* Disable rtl checking; it conflicts with the macro handling.  */\n+/* Disable rtl checking; it conflicts with the iterator handling.  */\n #undef ENABLE_RTL_CHECKING\n \n #include \"system.h\"\n@@ -41,42 +41,42 @@ struct map_value {\n   const char *string;\n };\n \n-/* Maps a macro or attribute name to a list of (integer, string) pairs.\n+/* Maps an iterator or attribute name to a list of (integer, string) pairs.\n    The integers are mode or code values; the strings are either C conditions\n    or attribute values.  */\n struct mapping {\n-  /* The name of the macro or attribute.  */\n+  /* The name of the iterator or attribute.  */\n   const char *name;\n \n-  /* The group (modes or codes) to which the macro or attribute belongs.  */\n-  struct macro_group *group;\n+  /* The group (modes or codes) to which the iterator or attribute belongs.  */\n+  struct iterator_group *group;\n \n-  /* Gives a unique number to the attribute or macro.  Numbers are\n+  /* Gives a unique number to the attribute or iterator.  Numbers are\n      allocated consecutively, starting at 0.  */\n   int index;\n \n   /* The list of (integer, string) pairs.  */\n   struct map_value *values;\n };\n \n-/* A structure for abstracting the common parts of code and mode macros.  */\n-struct macro_group {\n-  /* Tables of \"mapping\" structures, one for attributes and one for macros.  */\n-  htab_t attrs, macros;\n+/* A structure for abstracting the common parts of code and mode iterators.  */\n+struct iterator_group {\n+  /* Tables of \"mapping\" structures, one for attributes and one for iterators.  */\n+  htab_t attrs, iterators;\n \n   /* The number of \"real\" modes or codes (and by extension, the first\n-     number available for use as a macro placeholder).  */\n+     number available for use as an iterator placeholder).  */\n   int num_builtins;\n \n   /* Treat the given string as the name of a standard mode or code and\n      return its integer value.  Use the given file for error reporting.  */\n   int (*find_builtin) (const char *, FILE *);\n \n   /* Return true if the given rtx uses the given mode or code.  */\n-  bool (*uses_macro_p) (rtx, int);\n+  bool (*uses_iterator_p) (rtx, int);\n \n   /* Make the given rtx use the given mode or code.  */\n-  void (*apply_macro) (rtx, int);\n+  void (*apply_iterator) (rtx, int);\n };\n \n /* Associates PTR (which can be a string, etc.) with the file location\n@@ -87,9 +87,9 @@ struct ptr_loc {\n   int lineno;\n };\n \n-/* A structure used to pass data from read_rtx to apply_macro_traverse\n+/* A structure used to pass data from read_rtx to apply_iterator_traverse\n    via htab_traverse.  */\n-struct macro_traverse_data {\n+struct iterator_traverse_data {\n   /* Instruction queue.  */\n   rtx queue;\n   /* Attributes seen for modes.  */\n@@ -100,7 +100,7 @@ struct macro_traverse_data {\n   const char *unknown_mode_attr;\n };\n \n-/* If CODE is the number of a code macro, return a real rtx code that\n+/* If CODE is the number of a code iterator, return a real rtx code that\n    has the same format.  Return CODE otherwise.  */\n #define BELLWETHER_CODE(CODE) \\\n   ((CODE) < NUM_RTX_CODE ? CODE : bellwether_codes[CODE - NUM_RTX_CODE])\n@@ -109,23 +109,23 @@ static void fatal_with_file_and_line (FILE *, const char *, ...)\n   ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n static void fatal_expected_char (FILE *, int, int) ATTRIBUTE_NORETURN;\n static int find_mode (const char *, FILE *);\n-static bool uses_mode_macro_p (rtx, int);\n-static void apply_mode_macro (rtx, int);\n+static bool uses_mode_iterator_p (rtx, int);\n+static void apply_mode_iterator (rtx, int);\n static int find_code (const char *, FILE *);\n-static bool uses_code_macro_p (rtx, int);\n-static void apply_code_macro (rtx, int);\n-static const char *apply_macro_to_string (const char *, struct mapping *, int);\n-static rtx apply_macro_to_rtx (rtx, struct mapping *, int,\n-\t\t\t       struct map_value *, FILE *, const char **);\n-static bool uses_macro_p (rtx, struct mapping *);\n+static bool uses_code_iterator_p (rtx, int);\n+static void apply_code_iterator (rtx, int);\n+static const char *apply_iterator_to_string (const char *, struct mapping *, int);\n+static rtx apply_iterator_to_rtx (rtx, struct mapping *, int,\n+\t\t\t\t  struct map_value *, FILE *, const char **);\n+static bool uses_iterator_p (rtx, struct mapping *);\n static const char *add_condition_to_string (const char *, const char *);\n static void add_condition_to_rtx (rtx, const char *);\n-static int apply_macro_traverse (void **, void *);\n-static struct mapping *add_mapping (struct macro_group *, htab_t t,\n+static int apply_iterator_traverse (void **, void *);\n+static struct mapping *add_mapping (struct iterator_group *, htab_t t,\n \t\t\t\t    const char *, FILE *);\n static struct map_value **add_map_value (struct map_value **,\n \t\t\t\t\t int, const char *);\n-static void initialize_macros (void);\n+static void initialize_iterators (void);\n static void read_name (char *, FILE *);\n static hashval_t leading_ptr_hash (const void *);\n static int leading_ptr_eq_p (const void *, const void *);\n@@ -140,14 +140,14 @@ static int def_name_eq_p (const void *, const void *);\n static void read_constants (FILE *infile, char *tmp_char);\n static void read_conditions (FILE *infile, char *tmp_char);\n static void validate_const_int (FILE *, const char *);\n-static int find_macro (struct macro_group *, const char *, FILE *);\n-static struct mapping *read_mapping (struct macro_group *, htab_t, FILE *);\n-static void check_code_macro (struct mapping *, FILE *);\n+static int find_iterator (struct iterator_group *, const char *, FILE *);\n+static struct mapping *read_mapping (struct iterator_group *, htab_t, FILE *);\n+static void check_code_iterator (struct mapping *, FILE *);\n static rtx read_rtx_1 (FILE *, struct map_value **);\n static rtx read_rtx_variadic (FILE *, struct map_value **, rtx);\n \n-/* The mode and code macro structures.  */\n-static struct macro_group modes, codes;\n+/* The mode and code iterator structures.  */\n+static struct iterator_group modes, codes;\n \n /* Index I is the value of BELLWETHER_CODE (I + NUM_RTX_CODE).  */\n static enum rtx_code *bellwether_codes;\n@@ -222,7 +222,7 @@ fatal_expected_char (FILE *infile, int expected_c, int actual_c)\n \t\t\t    expected_c, actual_c);\n }\n \n-/* Implementations of the macro_group callbacks for modes.  */\n+/* Implementations of the iterator_group callbacks for modes.  */\n \n static int\n find_mode (const char *name, FILE *infile)\n@@ -237,18 +237,18 @@ find_mode (const char *name, FILE *infile)\n }\n \n static bool\n-uses_mode_macro_p (rtx x, int mode)\n+uses_mode_iterator_p (rtx x, int mode)\n {\n   return (int) GET_MODE (x) == mode;\n }\n \n static void\n-apply_mode_macro (rtx x, int mode)\n+apply_mode_iterator (rtx x, int mode)\n {\n   PUT_MODE (x, (enum machine_mode) mode);\n }\n \n-/* Implementations of the macro_group callbacks for codes.  */\n+/* Implementations of the iterator_group callbacks for codes.  */\n \n static int\n find_code (const char *name, FILE *infile)\n@@ -263,42 +263,42 @@ find_code (const char *name, FILE *infile)\n }\n \n static bool\n-uses_code_macro_p (rtx x, int code)\n+uses_code_iterator_p (rtx x, int code)\n {\n   return (int) GET_CODE (x) == code;\n }\n \n static void\n-apply_code_macro (rtx x, int code)\n+apply_code_iterator (rtx x, int code)\n {\n   PUT_CODE (x, (enum rtx_code) code);\n }\n \n /* Map a code or mode attribute string P to the underlying string for\n-   MACRO and VALUE.  */\n+   ITERATOR and VALUE.  */\n \n static struct map_value *\n-map_attr_string (const char *p, struct mapping *macro, int value)\n+map_attr_string (const char *p, struct mapping *iterator, int value)\n {\n   const char *attr;\n   struct mapping *m;\n   struct map_value *v;\n \n-  /* If there's a \"macro:\" prefix, check whether the macro name matches.\n+  /* If there's a \"iterator:\" prefix, check whether the iterator name matches.\n      Set ATTR to the start of the attribute name.  */\n   attr = strchr (p, ':');\n   if (attr == 0)\n     attr = p;\n   else\n     {\n-      if (strncmp (p, macro->name, attr - p) != 0\n-\t  || macro->name[attr - p] != 0)\n+      if (strncmp (p, iterator->name, attr - p) != 0\n+\t  || iterator->name[attr - p] != 0)\n \treturn 0;\n       attr++;\n     }\n \n   /* Find the attribute specification.  */\n-  m = (struct mapping *) htab_find (macro->group->attrs, &attr);\n+  m = (struct mapping *) htab_find (iterator->group->attrs, &attr);\n   if (m == 0)\n     return 0;\n \n@@ -312,7 +312,7 @@ map_attr_string (const char *p, struct mapping *macro, int value)\n \n /* Given an attribute string used as a machine mode, return an index\n    to store in the machine mode to be translated by\n-   apply_macro_to_rtx.  */\n+   apply_iterator_to_rtx.  */\n \n static unsigned int\n mode_attr_index (struct map_value **mode_maps, const char *string)\n@@ -332,27 +332,27 @@ mode_attr_index (struct map_value **mode_maps, const char *string)\n   *mode_maps = mv;\n \n   /* We return a code which we can map back into this string: the\n-     number of machine modes + the number of mode macros + the index\n+     number of machine modes + the number of mode iterators + the index\n      we just used.  */\n-  return MAX_MACHINE_MODE + htab_elements (modes.macros) + mv->number;\n+  return MAX_MACHINE_MODE + htab_elements (modes.iterators) + mv->number;\n }\n \n /* Apply MODE_MAPS to the top level of X, expanding cases where an\n-   attribute is used for a mode.  MACRO is the current macro we are\n+   attribute is used for a mode.  ITERATOR is the current iterator we are\n    expanding, and VALUE is the value to which we are expanding it.\n    INFILE is used for error messages.  This sets *UNKNOWN to true if\n    we find a mode attribute which has not yet been defined, and does\n    not change it otherwise.  */\n \n static void\n-apply_mode_maps (rtx x, struct map_value *mode_maps, struct mapping *macro,\n+apply_mode_maps (rtx x, struct map_value *mode_maps, struct mapping *iterator,\n \t\t int value, FILE *infile, const char **unknown)\n {\n   unsigned int offset;\n   int indx;\n   struct map_value *pm;\n \n-  offset = MAX_MACHINE_MODE + htab_elements (modes.macros);\n+  offset = MAX_MACHINE_MODE + htab_elements (modes.iterators);\n   if (GET_MODE (x) < offset)\n     return;\n \n@@ -363,7 +363,7 @@ apply_mode_maps (rtx x, struct map_value *mode_maps, struct mapping *macro,\n \t{\n \t  struct map_value *v;\n \n-\t  v = map_attr_string (pm->string, macro, value);\n+\t  v = map_attr_string (pm->string, iterator, value);\n \t  if (v)\n \t    PUT_MODE (x, (enum machine_mode) find_mode (v->string, infile));\n \t  else\n@@ -373,12 +373,12 @@ apply_mode_maps (rtx x, struct map_value *mode_maps, struct mapping *macro,\n     }\n }\n \n-/* Given that MACRO is being expanded as VALUE, apply the appropriate\n+/* Given that ITERATOR is being expanded as VALUE, apply the appropriate\n    string substitutions to STRING.  Return the new string if any changes\n    were needed, otherwise return STRING itself.  */\n \n static const char *\n-apply_macro_to_string (const char *string, struct mapping *macro, int value)\n+apply_iterator_to_string (const char *string, struct mapping *iterator, int value)\n {\n   char *base, *copy, *p, *start, *end;\n   struct map_value *v;\n@@ -392,7 +392,7 @@ apply_macro_to_string (const char *string, struct mapping *macro, int value)\n       p = start + 1;\n \n       *end = 0;\n-      v = map_attr_string (p, macro, value);\n+      v = map_attr_string (p, iterator, value);\n       *end = '>';\n       if (v == 0)\n \tcontinue;\n@@ -413,18 +413,18 @@ apply_macro_to_string (const char *string, struct mapping *macro, int value)\n   return string;\n }\n \n-/* Return a copy of ORIGINAL in which all uses of MACRO have been\n+/* Return a copy of ORIGINAL in which all uses of ITERATOR have been\n    replaced by VALUE.  MODE_MAPS holds information about attribute\n    strings used for modes.  INFILE is used for error messages.  This\n    sets *UNKNOWN_MODE_ATTR to the value of an unknown mode attribute,\n    and does not change it otherwise.  */\n \n static rtx\n-apply_macro_to_rtx (rtx original, struct mapping *macro, int value,\n-\t\t    struct map_value *mode_maps, FILE *infile,\n-\t\t    const char **unknown_mode_attr)\n+apply_iterator_to_rtx (rtx original, struct mapping *iterator, int value,\n+\t\t       struct map_value *mode_maps, FILE *infile,\n+\t\t       const char **unknown_mode_attr)\n {\n-  struct macro_group *group;\n+  struct iterator_group *group;\n   const char *format_ptr;\n   int i, j;\n   rtx x;\n@@ -439,31 +439,31 @@ apply_macro_to_rtx (rtx original, struct mapping *macro, int value,\n   memcpy (x, original, RTX_CODE_SIZE (bellwether_code));\n \n   /* Change the mode or code itself.  */\n-  group = macro->group;\n-  if (group->uses_macro_p (x, macro->index + group->num_builtins))\n-    group->apply_macro (x, value);\n+  group = iterator->group;\n+  if (group->uses_iterator_p (x, iterator->index + group->num_builtins))\n+    group->apply_iterator (x, value);\n \n   if (mode_maps)\n-    apply_mode_maps (x, mode_maps, macro, value, infile, unknown_mode_attr);\n+    apply_mode_maps (x, mode_maps, iterator, value, infile, unknown_mode_attr);\n \n   /* Change each string and recursively change each rtx.  */\n   format_ptr = GET_RTX_FORMAT (bellwether_code);\n   for (i = 0; format_ptr[i] != 0; i++)\n     switch (format_ptr[i])\n       {\n       case 'T':\n-\tXTMPL (x, i) = apply_macro_to_string (XTMPL (x, i), macro, value);\n+\tXTMPL (x, i) = apply_iterator_to_string (XTMPL (x, i), iterator, value);\n \tbreak;\n \n       case 'S':\n       case 's':\n-\tXSTR (x, i) = apply_macro_to_string (XSTR (x, i), macro, value);\n+\tXSTR (x, i) = apply_iterator_to_string (XSTR (x, i), iterator, value);\n \tbreak;\n \n       case 'e':\n-\tXEXP (x, i) = apply_macro_to_rtx (XEXP (x, i), macro, value,\n-\t\t\t\t\t  mode_maps, infile,\n-\t\t\t\t\t  unknown_mode_attr);\n+\tXEXP (x, i) = apply_iterator_to_rtx (XEXP (x, i), iterator, value,\n+\t\t\t\t\t     mode_maps, infile,\n+\t\t\t\t\t     unknown_mode_attr);\n \tbreak;\n \n       case 'V':\n@@ -472,10 +472,10 @@ apply_macro_to_rtx (rtx original, struct mapping *macro, int value,\n \t  {\n \t    XVEC (x, i) = rtvec_alloc (XVECLEN (original, i));\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      XVECEXP (x, i, j) = apply_macro_to_rtx (XVECEXP (original, i, j),\n-\t\t\t\t\t\t      macro, value, mode_maps,\n-\t\t\t\t\t\t      infile,\n-\t\t\t\t\t\t      unknown_mode_attr);\n+\t      XVECEXP (x, i, j) = apply_iterator_to_rtx (XVECEXP (original, i, j),\n+\t\t\t\t\t\t\t iterator, value, mode_maps,\n+\t\t\t\t\t\t\t infile,\n+\t\t\t\t\t\t\t unknown_mode_attr);\n \t  }\n \tbreak;\n \n@@ -485,36 +485,36 @@ apply_macro_to_rtx (rtx original, struct mapping *macro, int value,\n   return x;\n }\n \n-/* Return true if X (or some subexpression of X) uses macro MACRO.  */\n+/* Return true if X (or some subexpression of X) uses iterator ITERATOR.  */\n \n static bool\n-uses_macro_p (rtx x, struct mapping *macro)\n+uses_iterator_p (rtx x, struct mapping *iterator)\n {\n-  struct macro_group *group;\n+  struct iterator_group *group;\n   const char *format_ptr;\n   int i, j;\n \n   if (x == 0)\n     return false;\n \n-  group = macro->group;\n-  if (group->uses_macro_p (x, macro->index + group->num_builtins))\n+  group = iterator->group;\n+  if (group->uses_iterator_p (x, iterator->index + group->num_builtins))\n     return true;\n \n   format_ptr = GET_RTX_FORMAT (BELLWETHER_CODE (GET_CODE (x)));\n   for (i = 0; format_ptr[i] != 0; i++)\n     switch (format_ptr[i])\n       {\n       case 'e':\n-\tif (uses_macro_p (XEXP (x, i), macro))\n+\tif (uses_iterator_p (XEXP (x, i), iterator))\n \t  return true;\n \tbreak;\n \n       case 'V':\n       case 'E':\n \tif (XVEC (x, i))\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (uses_macro_p (XVECEXP (x, i, j), macro))\n+\t    if (uses_iterator_p (XVECEXP (x, i, j), iterator))\n \t      return true;\n \tbreak;\n \n@@ -566,37 +566,37 @@ add_condition_to_rtx (rtx x, const char *extra)\n }\n \n /* A htab_traverse callback.  Search the EXPR_LIST given by DATA\n-   for rtxes that use the macro in *SLOT.  Replace each such rtx\n+   for rtxes that use the iterator in *SLOT.  Replace each such rtx\n    with a list of expansions.  */\n \n static int\n-apply_macro_traverse (void **slot, void *data)\n+apply_iterator_traverse (void **slot, void *data)\n {\n-  struct macro_traverse_data *mtd = (struct macro_traverse_data *) data;\n-  struct mapping *macro;\n+  struct iterator_traverse_data *mtd = (struct iterator_traverse_data *) data;\n+  struct mapping *iterator;\n   struct map_value *v;\n   rtx elem, new_elem, original, x;\n \n-  macro = (struct mapping *) *slot;\n+  iterator = (struct mapping *) *slot;\n   for (elem = mtd->queue; elem != 0; elem = XEXP (elem, 1))\n-    if (uses_macro_p (XEXP (elem, 0), macro))\n+    if (uses_iterator_p (XEXP (elem, 0), iterator))\n       {\n-\t/* For each macro we expand, we set UNKNOWN_MODE_ATTR to NULL.\n-\t   If apply_macro_rtx finds an unknown attribute for a mode,\n+\t/* For each iterator we expand, we set UNKNOWN_MODE_ATTR to NULL.\n+\t   If apply_iterator_rtx finds an unknown attribute for a mode,\n \t   it will set it to the attribute.  We want to know whether\n \t   the attribute is unknown after we have expanded all\n-\t   possible macros, so setting it to NULL here gives us the\n+\t   possible iterators, so setting it to NULL here gives us the\n \t   right result when the hash table traversal is complete.  */\n \tmtd->unknown_mode_attr = NULL;\n \n \toriginal = XEXP (elem, 0);\n-\tfor (v = macro->values; v != 0; v = v->next)\n+\tfor (v = iterator->values; v != 0; v = v->next)\n \t  {\n-\t    x = apply_macro_to_rtx (original, macro, v->number,\n-\t\t\t\t    mtd->mode_maps, mtd->infile,\n-\t\t\t\t    &mtd->unknown_mode_attr);\n+\t    x = apply_iterator_to_rtx (original, iterator, v->number,\n+\t\t\t\t       mtd->mode_maps, mtd->infile,\n+\t\t\t\t       &mtd->unknown_mode_attr);\n \t    add_condition_to_rtx (x, v->string);\n-\t    if (v != macro->values)\n+\t    if (v != iterator->values)\n \t      {\n \t\t/* Insert a new EXPR_LIST node after ELEM and put the\n \t\t   new expansion there.  */\n@@ -616,7 +616,7 @@ apply_macro_traverse (void **slot, void *data)\n    is the file that defined the mapping.  */\n \n static struct mapping *\n-add_mapping (struct macro_group *group, htab_t table,\n+add_mapping (struct iterator_group *group, htab_t table,\n \t     const char *name, FILE *infile)\n {\n   struct mapping *m;\n@@ -657,26 +657,26 @@ add_map_value (struct map_value **end_ptr, int number, const char *string)\n /* Do one-time initialization of the mode and code attributes.  */\n \n static void\n-initialize_macros (void)\n+initialize_iterators (void)\n {\n   struct mapping *lower, *upper;\n   struct map_value **lower_ptr, **upper_ptr;\n   char *copy, *p;\n   int i;\n \n   modes.attrs = htab_create (13, def_hash, def_name_eq_p, 0);\n-  modes.macros = htab_create (13, def_hash, def_name_eq_p, 0);\n+  modes.iterators = htab_create (13, def_hash, def_name_eq_p, 0);\n   modes.num_builtins = MAX_MACHINE_MODE;\n   modes.find_builtin = find_mode;\n-  modes.uses_macro_p = uses_mode_macro_p;\n-  modes.apply_macro = apply_mode_macro;\n+  modes.uses_iterator_p = uses_mode_iterator_p;\n+  modes.apply_iterator = apply_mode_iterator;\n \n   codes.attrs = htab_create (13, def_hash, def_name_eq_p, 0);\n-  codes.macros = htab_create (13, def_hash, def_name_eq_p, 0);\n+  codes.iterators = htab_create (13, def_hash, def_name_eq_p, 0);\n   codes.num_builtins = NUM_RTX_CODE;\n   codes.find_builtin = find_code;\n-  codes.uses_macro_p = uses_code_macro_p;\n-  codes.apply_macro = apply_code_macro;\n+  codes.uses_iterator_p = uses_code_iterator_p;\n+  codes.apply_iterator = apply_code_iterator;\n \n   lower = add_mapping (&modes, modes.attrs, \"mode\", 0);\n   upper = add_mapping (&modes, modes.attrs, \"MODE\", 0);\n@@ -1284,11 +1284,11 @@ validate_const_int (FILE *infile, const char *string)\n    identifier.  INFILE is the file that contained NAME.  */\n \n static int\n-find_macro (struct macro_group *group, const char *name, FILE *infile)\n+find_iterator (struct iterator_group *group, const char *name, FILE *infile)\n {\n   struct mapping *m;\n \n-  m = (struct mapping *) htab_find (group->macros, &name);\n+  m = (struct mapping *) htab_find (group->iterators, &name);\n   if (m != 0)\n     return m->index + group->num_builtins;\n   return group->find_builtin (name, infile);\n@@ -1305,7 +1305,7 @@ find_macro (struct macro_group *group, const char *name, FILE *infile)\n    (which belongs to GROUP) and return it.  */\n \n static struct mapping *\n-read_mapping (struct macro_group *group, htab_t table, FILE *infile)\n+read_mapping (struct iterator_group *group, htab_t table, FILE *infile)\n {\n   char tmp_char[256];\n   struct mapping *m;\n@@ -1356,24 +1356,24 @@ read_mapping (struct macro_group *group, htab_t table, FILE *infile)\n   return m;\n }\n \n-/* Check newly-created code macro MACRO to see whether every code has the\n-   same format.  Initialize the macro's entry in bellwether_codes.  */\n+/* Check newly-created code iterator ITERATOR to see whether every code has the\n+   same format.  Initialize the iterator's entry in bellwether_codes.  */\n \n static void\n-check_code_macro (struct mapping *macro, FILE *infile)\n+check_code_iterator (struct mapping *iterator, FILE *infile)\n {\n   struct map_value *v;\n   enum rtx_code bellwether;\n \n-  bellwether = (enum rtx_code) macro->values->number;\n-  for (v = macro->values->next; v != 0; v = v->next)\n+  bellwether = (enum rtx_code) iterator->values->number;\n+  for (v = iterator->values->next; v != 0; v = v->next)\n     if (strcmp (GET_RTX_FORMAT (bellwether), GET_RTX_FORMAT (v->number)) != 0)\n-      fatal_with_file_and_line (infile, \"code macro `%s' combines \"\n-\t\t\t\t\"different rtx formats\", macro->name);\n+      fatal_with_file_and_line (infile, \"code iterator `%s' combines \"\n+\t\t\t\t\"different rtx formats\", iterator->name);\n \n   bellwether_codes = XRESIZEVEC (enum rtx_code, bellwether_codes,\n-\t\t\t\t macro->index + 1);\n-  bellwether_codes[macro->index] = bellwether;\n+\t\t\t\t iterator->index + 1);\n+  bellwether_codes[iterator->index] = bellwether;\n }\n \n /* Read an rtx in printed representation from INFILE and store its\n@@ -1394,7 +1394,7 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n   /* Do one-time initialization.  */\n   if (queue_head == 0)\n     {\n-      initialize_macros ();\n+      initialize_iterators ();\n       obstack_init (&string_obstack);\n       queue_head = rtx_alloc (EXPR_LIST);\n       ptr_locs = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n@@ -1407,7 +1407,7 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n   if (queue_next == 0)\n     {\n       struct map_value *mode_maps;\n-      struct macro_traverse_data mtd;\n+      struct iterator_traverse_data mtd;\n       rtx from_file;\n \n       c = read_skip_spaces (infile);\n@@ -1431,8 +1431,8 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n       mtd.mode_maps = mode_maps;\n       mtd.infile = infile;\n       mtd.unknown_mode_attr = mode_maps ? mode_maps->string : NULL;\n-      htab_traverse (modes.macros, apply_macro_traverse, &mtd);\n-      htab_traverse (codes.macros, apply_macro_traverse, &mtd);\n+      htab_traverse (modes.iterators, apply_iterator_traverse, &mtd);\n+      htab_traverse (codes.iterators, apply_iterator_traverse, &mtd);\n       if (mtd.unknown_mode_attr)\n \tfatal_with_file_and_line (infile,\n \t\t\t\t  \"undefined attribute '%s' used for mode\",\n@@ -1447,7 +1447,7 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n }\n \n /* Subroutine of read_rtx that reads one construct from INFILE but\n-   doesn't apply any macros.  */\n+   doesn't apply any iterators.  */\n \n static rtx\n read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n@@ -1504,22 +1504,23 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n       read_mapping (&modes, modes.attrs, infile);\n       goto again;\n     }\n-  if (strcmp (tmp_char, \"define_mode_macro\") == 0)\n+  if (strcmp (tmp_char, \"define_mode_iterator\") == 0)\n     {\n-      read_mapping (&modes, modes.macros, infile);\n+      read_mapping (&modes, modes.iterators, infile);\n       goto again;\n     }\n   if (strcmp (tmp_char, \"define_code_attr\") == 0)\n     {\n       read_mapping (&codes, codes.attrs, infile);\n       goto again;\n     }\n-  if (strcmp (tmp_char, \"define_code_macro\") == 0)\n+  if (strcmp (tmp_char, \"define_code_iterator\") == 0)\n     {\n-      check_code_macro (read_mapping (&codes, codes.macros, infile), infile);\n+      check_code_iterator (read_mapping (&codes, codes.iterators, infile),\n+\t\t\t   infile);\n       goto again;\n     }\n-  real_code = (enum rtx_code) find_macro (&codes, tmp_char, infile);\n+  real_code = (enum rtx_code) find_iterator (&codes, tmp_char, infile);\n   bellwether_code = BELLWETHER_CODE (real_code);\n \n   /* If we end up with an insn expression then we free this space below.  */\n@@ -1537,7 +1538,7 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \n       read_name (tmp_char, infile);\n       if (tmp_char[0] != '<' || tmp_char[strlen (tmp_char) - 1] != '>')\n-\tmode = find_macro (&modes, tmp_char, infile);\n+\tmode = find_iterator (&modes, tmp_char, infile);\n       else\n \tmode = mode_attr_index (mode_maps, tmp_char);\n       PUT_MODE (return_rtx, (enum machine_mode) mode);"}]}