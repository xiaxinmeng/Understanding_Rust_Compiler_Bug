{"sha": "fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUwNDYyMTBlMmQ1ZmEzYWM0YzBkMGQ1ZDQ4ZjY4NTFiMWRjYmUyNA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-09-20T22:56:48Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-09-20T22:56:48Z"}, "message": "re PR libfortran/23272 ([mingw32] inquire via filename fails)\n\n\tPR libfortran/23272\n\n\t* io/unix.c (id_from_handle, id_from_path, id_from_fd): New\n\tfunctions.\n\t(compare_file_filename, find_file, find_file0): Use the new\n\tfunctions above.\n\n\t* gfortran.dg/inquire_10.f90: New test.\n\nFrom-SVN: r128636", "tree": {"sha": "093179808f51212622f52a96725ca19f1a622162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/093179808f51212622f52a96725ca19f1a622162"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d36ff2b46bf0c44b5f8c60710b196777e8880285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d36ff2b46bf0c44b5f8c60710b196777e8880285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d36ff2b46bf0c44b5f8c60710b196777e8880285"}], "stats": {"total": 123, "additions": 119, "deletions": 4}, "files": [{"sha": "a11d20b96f08995f914a48ffb68faa5d2247d9ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24", "patch": "@@ -1,3 +1,8 @@\n+2007-09-21  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR libfortran/23272\n+\t* gfortran.dg/inquire_10.f90: New test.\n+\n 2007-09-20  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/c99-bool-2.c, gcc.dg/c99-bool-3.c: New tests."}, {"sha": "5343f2b3a08c6339d21724cf096a55d89852bb25", "filename": "gcc/testsuite/gfortran.dg/inquire_10.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/gcc%2Ftestsuite%2Fgfortran.dg%2Finquire_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/gcc%2Ftestsuite%2Fgfortran.dg%2Finquire_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finquire_10.f90?ref=fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24", "patch": "@@ -0,0 +1,16 @@\n+  character(len=800) :: cwd\n+  integer :: unit\n+\n+  call getcwd(cwd)\n+\n+  open(file='cseq', unit=23)\n+  inquire(file='cseq',number=unit)\n+  if (unit /= 23) call abort\n+  inquire(file=trim(cwd) // '/cseq',number=unit)\n+  if (unit /= 23) call abort\n+\n+  inquire(file='foo/../cseq2',number=unit)\n+  if (unit >= 0) call abort\n+  inquire(file='cseq2',number=unit)\n+  if (unit >= 0) call abort\n+end"}, {"sha": "337d2e17555e455ae65f7f9c4f47d1381787d95a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24", "patch": "@@ -1,3 +1,11 @@\n+2007-09-21  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR libfortran/23272\n+\t* io/unix.c (id_from_handle, id_from_path, id_from_fd): New\n+\tfunctions.\n+\t(compare_file_filename, find_file, find_file0): Use the new\n+\tfunctions above.\n+\n 2007-09-21  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* acinclude.m4 (LIBGFOR_TARGET_ILP32): Remove test."}, {"sha": "9b61507e27407df56c3a8e7cef2d34f49310f073", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 90, "deletions": 4, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=fe046210e2d5fa3ac4c0d0d5d48f6851b1dcbe24", "patch": "@@ -42,6 +42,59 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include <errno.h>\n \n+\n+/* For mingw, we don't identify files by their inode number, but by a\n+   64-bit identifier created from a BY_HANDLE_FILE_INFORMATION. */\n+#if defined(__MINGW32__) && !HAVE_WORKING_STAT\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+\n+static uint64_t\n+id_from_handle (HANDLE hFile)\n+{\n+  BY_HANDLE_FILE_INFORMATION FileInformation;\n+\n+  if (hFile == INVALID_HANDLE_VALUE)\n+      return 0;\n+\n+  memset (&FileInformation, 0, sizeof(FileInformation));\n+  if (!GetFileInformationByHandle (hFile, &FileInformation))\n+    return 0;\n+\n+  return ((uint64_t) FileInformation.nFileIndexLow)\n+\t | (((uint64_t) FileInformation.nFileIndexHigh) << 32);\n+}\n+\n+\n+static uint64_t\n+id_from_path (const char *path)\n+{\n+  HANDLE hFile;\n+  uint64_t res;\n+\n+  if (!path || !*path || access (path, F_OK))\n+    return (uint64_t) -1;\n+\n+  hFile = CreateFile (path, 0, 0, NULL, OPEN_EXISTING,\n+\t\t      FILE_FLAG_BACKUP_SEMANTICS | FILE_ATTRIBUTE_READONLY,\n+\t\t      NULL);\n+  res = id_from_handle (hFile);\n+  CloseHandle (hFile);\n+  return res;\n+}\n+\n+\n+static uint64_t\n+id_from_fd (const int fd)\n+{\n+  return id_from_handle ((HANDLE) _get_osfhandle (fd));\n+}\n+\n+#endif\n+\n+\n+\n #ifndef SSIZE_MAX\n #define SSIZE_MAX SHRT_MAX\n #endif\n@@ -1444,6 +1497,10 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n   struct stat st1;\n #ifdef HAVE_WORKING_STAT\n   struct stat st2;\n+#else\n+# ifdef __MINGW32__\n+  uint64_t id1, id2;\n+# endif\n #endif\n \n   if (unpack_filename (path, name, len))\n@@ -1459,6 +1516,17 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n   fstat (((unix_stream *) (u->s))->fd, &st2);\n   return (st1.st_dev == st2.st_dev) && (st1.st_ino == st2.st_ino);\n #else\n+\n+# ifdef __MINGW32__\n+  /* We try to match files by a unique ID.  On some filesystems (network\n+     fs and FAT), we can't generate this unique ID, and will simply compare\n+     filenames.  */\n+  id1 = id_from_path (path);\n+  id2 = id_from_fd (((unix_stream *) (u->s))->fd);\n+  if (id1 || id2)\n+    return (id1 == id2);\n+# endif\n+\n   if (len != u->file_len)\n     return 0;\n   return (memcmp(path, u->file, len) == 0);\n@@ -1470,8 +1538,8 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n # define FIND_FILE0_DECL struct stat *st\n # define FIND_FILE0_ARGS st\n #else\n-# define FIND_FILE0_DECL const char *file, gfc_charlen_type file_len\n-# define FIND_FILE0_ARGS file, file_len\n+# define FIND_FILE0_DECL uint64_t id, const char *file, gfc_charlen_type file_len\n+# define FIND_FILE0_ARGS id, file, file_len\n #endif\n \n /* find_file0()-- Recursive work function for find_file() */\n@@ -1480,6 +1548,9 @@ static gfc_unit *\n find_file0 (gfc_unit *u, FIND_FILE0_DECL)\n {\n   gfc_unit *v;\n+#if defined(__MINGW32__) && !HAVE_WORKING_STAT\n+  uint64_t id1;\n+#endif\n \n   if (u == NULL)\n     return NULL;\n@@ -1490,8 +1561,16 @@ find_file0 (gfc_unit *u, FIND_FILE0_DECL)\n       st[0].st_dev == st[1].st_dev && st[0].st_ino == st[1].st_ino)\n     return u;\n #else\n-  if (compare_string (u->file_len, u->file, file_len, file) == 0)\n-    return u;\n+# ifdef __MINGW32__ \n+  if (u->s && ((id1 = id_from_fd (((unix_stream *) u->s)->fd)) || id1))\n+    {\n+      if (id == id1)\n+\treturn u;\n+    }\n+  else\n+# endif\n+    if (compare_string (u->file_len, u->file, file_len, file) == 0)\n+      return u;\n #endif\n \n   v = find_file0 (u->left, FIND_FILE0_ARGS);\n@@ -1515,13 +1594,20 @@ find_file (const char *file, gfc_charlen_type file_len)\n   char path[PATH_MAX + 1];\n   struct stat st[2];\n   gfc_unit *u;\n+  uint64_t id;\n \n   if (unpack_filename (path, file, file_len))\n     return NULL;\n \n   if (stat (path, &st[0]) < 0)\n     return NULL;\n \n+#if defined(__MINGW32__) && !HAVE_WORKING_STAT\n+  id = id_from_path (path);\n+#else\n+  id = 0;\n+#endif\n+\n   __gthread_mutex_lock (&unit_lock);\n retry:\n   u = find_file0 (unit_root, FIND_FILE0_ARGS);"}]}