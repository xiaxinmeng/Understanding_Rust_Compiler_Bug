{"sha": "5c31da80bb95fca8006fe129913d49f71f581f01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMzMWRhODBiYjk1ZmNhODAwNmZlMTI5OTEzZDQ5ZjcxZjU4MWYwMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-12-03T11:49:41Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-12-03T11:49:41Z"}, "message": "asan-dg.exp (asan_get_gtest_test_list, [...]): New procedures.\n\n\t* lib/asan-dg.exp (asan_get_gtest_test_list,\n\tasan_get_gtest_expect_death_list, asan-gtest): New procedures.\n\t(proc ${tool}_load): Remember [asan_get_gtest_test_list \"$output\"]\n\tand [asan_get_gtest_expect_death_list \"$output\"] in global vars.\n\t(asan_symbolize): Sanitize [] characters from key.\n\t* g++.dg/asan/asan_test_config.h: New file.\n\t* g++.dg/asan/asan_globals_test.cc: New file.\n\t* g++.dg/asan/asan_test_utils.h: New file.\n\t* g++.dg/asan/dejagnu-gtest.h: New file.\n\t* g++.dg/asan/asan_test.cc: New file.\n\t* g++.dg/asan/asan_test.C: New test.\n\nFrom-SVN: r194081", "tree": {"sha": "24a63e8838ebe6bfaf4b32f1c3fe6f3cafb1f7ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24a63e8838ebe6bfaf4b32f1c3fe6f3cafb1f7ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c31da80bb95fca8006fe129913d49f71f581f01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c31da80bb95fca8006fe129913d49f71f581f01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c31da80bb95fca8006fe129913d49f71f581f01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c31da80bb95fca8006fe129913d49f71f581f01/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9600ae5a32a0c136bdada6cbdd4d4209a63abf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9600ae5a32a0c136bdada6cbdd4d4209a63abf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9600ae5a32a0c136bdada6cbdd4d4209a63abf8"}], "stats": {"total": 2614, "additions": 2612, "deletions": 2}, "files": [{"sha": "56b1c9126234b8237d9dd0edc869e21325f6f695", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5c31da80bb95fca8006fe129913d49f71f581f01", "patch": "@@ -1,3 +1,17 @@\n+2012-12-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* lib/asan-dg.exp (asan_get_gtest_test_list,\n+\tasan_get_gtest_expect_death_list, asan-gtest): New procedures.\n+\t(proc ${tool}_load): Remember [asan_get_gtest_test_list \"$output\"]\n+\tand [asan_get_gtest_expect_death_list \"$output\"] in global vars.\n+\t(asan_symbolize): Sanitize [] characters from key.\n+\t* g++.dg/asan/asan_test_config.h: New file.\n+\t* g++.dg/asan/asan_globals_test.cc: New file.\n+\t* g++.dg/asan/asan_test_utils.h: New file.\n+\t* g++.dg/asan/dejagnu-gtest.h: New file.\n+\t* g++.dg/asan/asan_test.cc: New file.\n+\t* g++.dg/asan/asan_test.C: New test.\n+\n 2012-12-03  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/torture/pr35634.c: Use signed char."}, {"sha": "76396fb49a07569488b0c6e8878bf88f6847bee4", "filename": "gcc/testsuite/g++.dg/asan/asan_globals_test.cc", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_globals_test.cc?ref=5c31da80bb95fca8006fe129913d49f71f581f01", "patch": "@@ -0,0 +1,22 @@\n+//===-- asan_globals_test.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Some globals in a separate file.\n+//===----------------------------------------------------------------------===//\n+\n+extern char glob5[5];\n+static char static10[10];\n+\n+int GlobalsTest(int zero) {\n+  static char func_static15[15];\n+  glob5[zero] = 0;\n+  static10[zero] = 0;\n+  func_static15[zero] = 0;\n+  return glob5[1] + func_static15[2];\n+}"}, {"sha": "94ea263afde95982b51ffaa371b0c2432918c3ed", "filename": "gcc/testsuite/g++.dg/asan/asan_test.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C?ref=5c31da80bb95fca8006fe129913d49f71f581f01", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do run { target { { i?86-*-linux* x86_64-*-linux* } && sse2_runtime } } }\n+// { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } }\n+// { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } }\n+// { dg-additional-sources \"asan_globals_test.cc\" }\n+// { dg-options \"-fsanitize=address -fno-builtin -Wall -Wno-format -Werror -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DASAN_USE_DEJAGNU_GTEST=1 -lpthread -ldl\" }\n+// { dg-additional-options \"-DASAN_NEEDS_SEGV=1\" { target { ! arm*-*-* } } }\n+// { dg-additional-options \"-DASAN_LOW_MEMORY=1 -DASAN_NEEDS_SEGV=0\" { target arm*-*-* } }\n+// { dg-additional-options \"-DASAN_AVOID_EXPENSIVE_TESTS=1\" { target { ! run_expensive_tests } } }\n+// { dg-additional-options \"-msse2\" { target { i?86-*-linux* x86_64-*-linux* } } }\n+// { dg-final { asan-gtest } }\n+\n+#include \"asan_test.cc\""}, {"sha": "763b2d7700ded07c840112d1a16871e33d6970d7", "filename": "gcc/testsuite/g++.dg/asan/asan_test.cc", "status": "added", "additions": 2193, "deletions": 0, "changes": 2193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc?ref=5c31da80bb95fca8006fe129913d49f71f581f01", "patch": "@@ -0,0 +1,2193 @@\n+//===-- asan_test.cc ------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+//===----------------------------------------------------------------------===//\n+#include <stdio.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <strings.h>\n+#include <pthread.h>\n+#include <stdint.h>\n+#include <setjmp.h>\n+#include <assert.h>\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+#include <emmintrin.h>\n+#endif\n+\n+#include \"asan_test_utils.h\"\n+\n+#ifndef __APPLE__\n+#include <malloc.h>\n+#else\n+#include <malloc/malloc.h>\n+#include <AvailabilityMacros.h>  // For MAC_OS_X_VERSION_*\n+#include <CoreFoundation/CFString.h>\n+#endif  // __APPLE__\n+\n+#if ASAN_HAS_EXCEPTIONS\n+# define ASAN_THROW(x) throw (x)\n+#else\n+# define ASAN_THROW(x)\n+#endif\n+\n+#include <sys/mman.h>\n+\n+typedef uint8_t   U1;\n+typedef uint16_t  U2;\n+typedef uint32_t  U4;\n+typedef uint64_t  U8;\n+\n+static const int kPageSize = 4096;\n+\n+// Simple stand-alone pseudorandom number generator.\n+// Current algorithm is ANSI C linear congruential PRNG.\n+static inline uint32_t my_rand(uint32_t* state) {\n+  return (*state = *state * 1103515245 + 12345) >> 16;\n+}\n+\n+static uint32_t global_seed = 0;\n+\n+const size_t kLargeMalloc = 1 << 24;\n+\n+template<typename T>\n+NOINLINE void asan_write(T *a) {\n+  *a = 0;\n+}\n+\n+NOINLINE void asan_write_sized_aligned(uint8_t *p, size_t size) {\n+  EXPECT_EQ(0U, ((uintptr_t)p % size));\n+  if      (size == 1) asan_write((uint8_t*)p);\n+  else if (size == 2) asan_write((uint16_t*)p);\n+  else if (size == 4) asan_write((uint32_t*)p);\n+  else if (size == 8) asan_write((uint64_t*)p);\n+}\n+\n+NOINLINE void *malloc_fff(size_t size) {\n+  void *res = malloc/**/(size); break_optimization(0); return res;}\n+NOINLINE void *malloc_eee(size_t size) {\n+  void *res = malloc_fff(size); break_optimization(0); return res;}\n+NOINLINE void *malloc_ddd(size_t size) {\n+  void *res = malloc_eee(size); break_optimization(0); return res;}\n+NOINLINE void *malloc_ccc(size_t size) {\n+  void *res = malloc_ddd(size); break_optimization(0); return res;}\n+NOINLINE void *malloc_bbb(size_t size) {\n+  void *res = malloc_ccc(size); break_optimization(0); return res;}\n+NOINLINE void *malloc_aaa(size_t size) {\n+  void *res = malloc_bbb(size); break_optimization(0); return res;}\n+\n+#ifndef __APPLE__\n+NOINLINE void *memalign_fff(size_t alignment, size_t size) {\n+  void *res = memalign/**/(alignment, size); break_optimization(0); return res;}\n+NOINLINE void *memalign_eee(size_t alignment, size_t size) {\n+  void *res = memalign_fff(alignment, size); break_optimization(0); return res;}\n+NOINLINE void *memalign_ddd(size_t alignment, size_t size) {\n+  void *res = memalign_eee(alignment, size); break_optimization(0); return res;}\n+NOINLINE void *memalign_ccc(size_t alignment, size_t size) {\n+  void *res = memalign_ddd(alignment, size); break_optimization(0); return res;}\n+NOINLINE void *memalign_bbb(size_t alignment, size_t size) {\n+  void *res = memalign_ccc(alignment, size); break_optimization(0); return res;}\n+NOINLINE void *memalign_aaa(size_t alignment, size_t size) {\n+  void *res = memalign_bbb(alignment, size); break_optimization(0); return res;}\n+#endif  // __APPLE__\n+\n+\n+NOINLINE void free_ccc(void *p) { free(p); break_optimization(0);}\n+NOINLINE void free_bbb(void *p) { free_ccc(p); break_optimization(0);}\n+NOINLINE void free_aaa(void *p) { free_bbb(p); break_optimization(0);}\n+\n+template<typename T>\n+NOINLINE void oob_test(int size, int off) {\n+  char *p = (char*)malloc_aaa(size);\n+  // fprintf(stderr, \"writing %d byte(s) into [%p,%p) with offset %d\\n\",\n+  //        sizeof(T), p, p + size, off);\n+  asan_write((T*)(p + off));\n+  free_aaa(p);\n+}\n+\n+\n+template<typename T>\n+NOINLINE void uaf_test(int size, int off) {\n+  char *p = (char *)malloc_aaa(size);\n+  free_aaa(p);\n+  for (int i = 1; i < 100; i++)\n+    free_aaa(malloc_aaa(i));\n+  fprintf(stderr, \"writing %ld byte(s) at %p with offset %d\\n\",\n+          (long)sizeof(T), p, off);\n+  asan_write((T*)(p + off));\n+}\n+\n+TEST(AddressSanitizer, HasFeatureAddressSanitizerTest) {\n+#if defined(__has_feature) && __has_feature(address_sanitizer)\n+  bool asan = 1;\n+#elif defined(__SANITIZE_ADDRESS__)\n+  bool asan = 1;\n+#else\n+  bool asan = 0;\n+#endif\n+  EXPECT_EQ(true, asan);\n+}\n+\n+TEST(AddressSanitizer, SimpleDeathTest) {\n+  EXPECT_DEATH(exit(1), \"\");\n+}\n+\n+TEST(AddressSanitizer, VariousMallocsTest) {\n+  int *a = (int*)malloc(100 * sizeof(int));\n+  a[50] = 0;\n+  free(a);\n+\n+  int *r = (int*)malloc(10);\n+  r = (int*)realloc(r, 2000 * sizeof(int));\n+  r[1000] = 0;\n+  free(r);\n+\n+  int *b = new int[100];\n+  b[50] = 0;\n+  delete [] b;\n+\n+  int *c = new int;\n+  *c = 0;\n+  delete c;\n+\n+#if !defined(__APPLE__) && !defined(ANDROID) && !defined(__ANDROID__)\n+  int *pm;\n+  int pm_res = posix_memalign((void**)&pm, kPageSize, kPageSize);\n+  EXPECT_EQ(0, pm_res);\n+  free(pm);\n+#endif\n+\n+#if !defined(__APPLE__)\n+  int *ma = (int*)memalign(kPageSize, kPageSize);\n+  EXPECT_EQ(0U, (uintptr_t)ma % kPageSize);\n+  ma[123] = 0;\n+  free(ma);\n+#endif  // __APPLE__\n+}\n+\n+TEST(AddressSanitizer, CallocTest) {\n+  int *a = (int*)calloc(100, sizeof(int));\n+  EXPECT_EQ(0, a[10]);\n+  free(a);\n+}\n+\n+TEST(AddressSanitizer, VallocTest) {\n+  void *a = valloc(100);\n+  EXPECT_EQ(0U, (uintptr_t)a % kPageSize);\n+  free(a);\n+}\n+\n+#ifndef __APPLE__\n+TEST(AddressSanitizer, PvallocTest) {\n+  char *a = (char*)pvalloc(kPageSize + 100);\n+  EXPECT_EQ(0U, (uintptr_t)a % kPageSize);\n+  a[kPageSize + 101] = 1;  // we should not report an error here.\n+  free(a);\n+\n+  a = (char*)pvalloc(0);  // pvalloc(0) should allocate at least one page.\n+  EXPECT_EQ(0U, (uintptr_t)a % kPageSize);\n+  a[101] = 1;  // we should not report an error here.\n+  free(a);\n+}\n+#endif  // __APPLE__\n+\n+void *TSDWorker(void *test_key) {\n+  if (test_key) {\n+    pthread_setspecific(*(pthread_key_t*)test_key, (void*)0xfeedface);\n+  }\n+  return NULL;\n+}\n+\n+void TSDDestructor(void *tsd) {\n+  // Spawning a thread will check that the current thread id is not -1.\n+  pthread_t th;\n+  PTHREAD_CREATE(&th, NULL, TSDWorker, NULL);\n+  PTHREAD_JOIN(th, NULL);\n+}\n+\n+// This tests triggers the thread-specific data destruction fiasco which occurs\n+// if we don't manage the TSD destructors ourselves. We create a new pthread\n+// key with a non-NULL destructor which is likely to be put after the destructor\n+// of AsanThread in the list of destructors.\n+// In this case the TSD for AsanThread will be destroyed before TSDDestructor\n+// is called for the child thread, and a CHECK will fail when we call\n+// pthread_create() to spawn the grandchild.\n+TEST(AddressSanitizer, DISABLED_TSDTest) {\n+  pthread_t th;\n+  pthread_key_t test_key;\n+  pthread_key_create(&test_key, TSDDestructor);\n+  PTHREAD_CREATE(&th, NULL, TSDWorker, &test_key);\n+  PTHREAD_JOIN(th, NULL);\n+  pthread_key_delete(test_key);\n+}\n+\n+template<typename T>\n+void OOBTest() {\n+  char expected_str[100];\n+  for (int size = sizeof(T); size < 20; size += 5) {\n+    for (int i = -5; i < 0; i++) {\n+      const char *str =\n+          \"is located.*%d byte.*to the left\";\n+      sprintf(expected_str, str, abs(i));\n+      EXPECT_DEATH(oob_test<T>(size, i), expected_str);\n+    }\n+\n+    for (int i = 0; i < (int)(size - sizeof(T) + 1); i++)\n+      oob_test<T>(size, i);\n+\n+    for (int i = size - sizeof(T) + 1; i <= (int)(size + 3 * sizeof(T)); i++) {\n+      const char *str =\n+          \"is located.*%d byte.*to the right\";\n+      int off = i >= size ? (i - size) : 0;\n+      // we don't catch unaligned partially OOB accesses.\n+      if (i % sizeof(T)) continue;\n+      sprintf(expected_str, str, off);\n+      EXPECT_DEATH(oob_test<T>(size, i), expected_str);\n+    }\n+  }\n+\n+  EXPECT_DEATH(oob_test<T>(kLargeMalloc, -1),\n+          \"is located.*1 byte.*to the left\");\n+  EXPECT_DEATH(oob_test<T>(kLargeMalloc, kLargeMalloc),\n+          \"is located.*0 byte.*to the right\");\n+}\n+\n+// TODO(glider): the following tests are EXTREMELY slow on Darwin:\n+//   AddressSanitizer.OOB_char (125503 ms)\n+//   AddressSanitizer.OOB_int (126890 ms)\n+//   AddressSanitizer.OOBRightTest (315605 ms)\n+//   AddressSanitizer.SimpleStackTest (366559 ms)\n+\n+TEST(AddressSanitizer, OOB_char) {\n+  OOBTest<U1>();\n+}\n+\n+TEST(AddressSanitizer, OOB_int) {\n+  OOBTest<U4>();\n+}\n+\n+TEST(AddressSanitizer, OOBRightTest) {\n+  for (size_t access_size = 1; access_size <= 8; access_size *= 2) {\n+    for (size_t alloc_size = 1; alloc_size <= 8; alloc_size++) {\n+      for (size_t offset = 0; offset <= 8; offset += access_size) {\n+        void *p = malloc(alloc_size);\n+        // allocated: [p, p + alloc_size)\n+        // accessed:  [p + offset, p + offset + access_size)\n+        uint8_t *addr = (uint8_t*)p + offset;\n+        if (offset + access_size <= alloc_size) {\n+          asan_write_sized_aligned(addr, access_size);\n+        } else {\n+          int outside_bytes = offset > alloc_size ? (offset - alloc_size) : 0;\n+          const char *str =\n+              \"is located.%d *byte.*to the right\";\n+          char expected_str[100];\n+          sprintf(expected_str, str, outside_bytes);\n+          EXPECT_DEATH(asan_write_sized_aligned(addr, access_size),\n+                       expected_str);\n+        }\n+        free(p);\n+      }\n+    }\n+  }\n+}\n+\n+TEST(AddressSanitizer, UAF_char) {\n+  const char *uaf_string = \"AddressSanitizer:.*heap-use-after-free\";\n+  EXPECT_DEATH(uaf_test<U1>(1, 0), uaf_string);\n+  EXPECT_DEATH(uaf_test<U1>(10, 0), uaf_string);\n+  EXPECT_DEATH(uaf_test<U1>(10, 10), uaf_string);\n+  EXPECT_DEATH(uaf_test<U1>(kLargeMalloc, 0), uaf_string);\n+  EXPECT_DEATH(uaf_test<U1>(kLargeMalloc, kLargeMalloc / 2), uaf_string);\n+}\n+\n+#if ASAN_HAS_BLACKLIST\n+TEST(AddressSanitizer, IgnoreTest) {\n+  int *x = Ident(new int);\n+  delete Ident(x);\n+  *x = 0;\n+}\n+#endif  // ASAN_HAS_BLACKLIST\n+\n+struct StructWithBitField {\n+  int bf1:1;\n+  int bf2:1;\n+  int bf3:1;\n+  int bf4:29;\n+};\n+\n+TEST(AddressSanitizer, BitFieldPositiveTest) {\n+  StructWithBitField *x = new StructWithBitField;\n+  delete Ident(x);\n+  EXPECT_DEATH(x->bf1 = 0, \"use-after-free\");\n+  EXPECT_DEATH(x->bf2 = 0, \"use-after-free\");\n+  EXPECT_DEATH(x->bf3 = 0, \"use-after-free\");\n+  EXPECT_DEATH(x->bf4 = 0, \"use-after-free\");\n+}\n+\n+struct StructWithBitFields_8_24 {\n+  int a:8;\n+  int b:24;\n+};\n+\n+TEST(AddressSanitizer, BitFieldNegativeTest) {\n+  StructWithBitFields_8_24 *x = Ident(new StructWithBitFields_8_24);\n+  x->a = 0;\n+  x->b = 0;\n+  delete Ident(x);\n+}\n+\n+TEST(AddressSanitizer, OutOfMemoryTest) {\n+  size_t size = SANITIZER_WORDSIZE == 64 ? (size_t)(1ULL << 48) : (0xf0000000);\n+  EXPECT_EQ(0, realloc(0, size));\n+  EXPECT_EQ(0, realloc(0, ~Ident(0)));\n+  EXPECT_EQ(0, malloc(size));\n+  EXPECT_EQ(0, malloc(~Ident(0)));\n+  EXPECT_EQ(0, calloc(1, size));\n+  EXPECT_EQ(0, calloc(1, ~Ident(0)));\n+}\n+\n+#if ASAN_NEEDS_SEGV\n+namespace {\n+\n+const char kUnknownCrash[] = \"AddressSanitizer: SEGV on unknown address\";\n+const char kOverriddenHandler[] = \"ASan signal handler has been overridden\\n\";\n+\n+TEST(AddressSanitizer, WildAddressTest) {\n+  char *c = (char*)0x123;\n+  EXPECT_DEATH(*c = 0, kUnknownCrash);\n+}\n+\n+void my_sigaction_sighandler(int, siginfo_t*, void*) {\n+  fprintf(stderr, kOverriddenHandler);\n+  exit(1);\n+}\n+\n+void my_signal_sighandler(int signum) {\n+  fprintf(stderr, kOverriddenHandler);\n+  exit(1);\n+}\n+\n+TEST(AddressSanitizer, SignalTest) {\n+  struct sigaction sigact;\n+  memset(&sigact, 0, sizeof(sigact));\n+  sigact.sa_sigaction = my_sigaction_sighandler;\n+  sigact.sa_flags = SA_SIGINFO;\n+  // ASan should silently ignore sigaction()...\n+  EXPECT_EQ(0, sigaction(SIGSEGV, &sigact, 0));\n+#ifdef __APPLE__\n+  EXPECT_EQ(0, sigaction(SIGBUS, &sigact, 0));\n+#endif\n+  char *c = (char*)0x123;\n+  EXPECT_DEATH(*c = 0, kUnknownCrash);\n+  // ... and signal().\n+  EXPECT_EQ(0, signal(SIGSEGV, my_signal_sighandler));\n+  EXPECT_DEATH(*c = 0, kUnknownCrash);\n+}\n+}  // namespace\n+#endif\n+\n+static void MallocStress(size_t n) {\n+  uint32_t seed = my_rand(&global_seed);\n+  for (size_t iter = 0; iter < 10; iter++) {\n+    vector<void *> vec;\n+    for (size_t i = 0; i < n; i++) {\n+      if ((i % 3) == 0) {\n+        if (vec.empty()) continue;\n+        size_t idx = my_rand(&seed) % vec.size();\n+        void *ptr = vec[idx];\n+        vec[idx] = vec.back();\n+        vec.pop_back();\n+        free_aaa(ptr);\n+      } else {\n+        size_t size = my_rand(&seed) % 1000 + 1;\n+#ifndef __APPLE__\n+        size_t alignment = 1 << (my_rand(&seed) % 7 + 3);\n+        char *ptr = (char*)memalign_aaa(alignment, size);\n+#else\n+        char *ptr = (char*) malloc_aaa(size);\n+#endif\n+        vec.push_back(ptr);\n+        ptr[0] = 0;\n+        ptr[size-1] = 0;\n+        ptr[size/2] = 0;\n+      }\n+    }\n+    for (size_t i = 0; i < vec.size(); i++)\n+      free_aaa(vec[i]);\n+  }\n+}\n+\n+TEST(AddressSanitizer, MallocStressTest) {\n+  MallocStress((ASAN_LOW_MEMORY) ? 20000 : 200000);\n+}\n+\n+static void TestLargeMalloc(size_t size) {\n+  char buff[1024];\n+  sprintf(buff, \"is located 1 bytes to the left of %lu-byte\", (long)size);\n+  EXPECT_DEATH(Ident((char*)malloc(size))[-1] = 0, buff);\n+}\n+\n+TEST(AddressSanitizer, LargeMallocTest) {\n+  for (int i = 113; i < (1 << 28); i = i * 2 + 13) {\n+    TestLargeMalloc(i);\n+  }\n+}\n+\n+#if ASAN_LOW_MEMORY != 1\n+TEST(AddressSanitizer, HugeMallocTest) {\n+#ifdef __APPLE__\n+  // It was empirically found out that 1215 megabytes is the maximum amount of\n+  // memory available to the process under AddressSanitizer on 32-bit Mac 10.6.\n+  // 32-bit Mac 10.7 gives even less (< 1G).\n+  // (the libSystem malloc() allows allocating up to 2300 megabytes without\n+  // ASan).\n+  size_t n_megs = SANITIZER_WORDSIZE == 32 ? 500 : 4100;\n+#else\n+  size_t n_megs = SANITIZER_WORDSIZE == 32 ? 2600 : 4100;\n+#endif\n+  TestLargeMalloc(n_megs << 20);\n+}\n+#endif\n+\n+TEST(AddressSanitizer, ThreadedMallocStressTest) {\n+  const int kNumThreads = 4;\n+  const int kNumIterations = (ASAN_LOW_MEMORY) ? 10000 : 100000;\n+  pthread_t t[kNumThreads];\n+  for (int i = 0; i < kNumThreads; i++) {\n+    PTHREAD_CREATE(&t[i], 0, (void* (*)(void *x))MallocStress,\n+        (void*)kNumIterations);\n+  }\n+  for (int i = 0; i < kNumThreads; i++) {\n+    PTHREAD_JOIN(t[i], 0);\n+  }\n+}\n+\n+void *ManyThreadsWorker(void *a) {\n+  for (int iter = 0; iter < 100; iter++) {\n+    for (size_t size = 100; size < 2000; size *= 2) {\n+      free(Ident(malloc(size)));\n+    }\n+  }\n+  return 0;\n+}\n+\n+TEST(AddressSanitizer, ManyThreadsTest) {\n+  const size_t kNumThreads =\n+      (SANITIZER_WORDSIZE == 32 || ASAN_AVOID_EXPENSIVE_TESTS) ? 30 : 1000;\n+  pthread_t t[kNumThreads];\n+  for (size_t i = 0; i < kNumThreads; i++) {\n+    PTHREAD_CREATE(&t[i], 0, ManyThreadsWorker, (void*)i);\n+  }\n+  for (size_t i = 0; i < kNumThreads; i++) {\n+    PTHREAD_JOIN(t[i], 0);\n+  }\n+}\n+\n+TEST(AddressSanitizer, ReallocTest) {\n+  const int kMinElem = 5;\n+  int *ptr = (int*)malloc(sizeof(int) * kMinElem);\n+  ptr[3] = 3;\n+  for (int i = 0; i < 10000; i++) {\n+    ptr = (int*)realloc(ptr,\n+        (my_rand(&global_seed) % 1000 + kMinElem) * sizeof(int));\n+    EXPECT_EQ(3, ptr[3]);\n+  }\n+}\n+\n+#ifndef __APPLE__\n+static const char *kMallocUsableSizeErrorMsg =\n+  \"AddressSanitizer: attempting to call malloc_usable_size()\";\n+\n+TEST(AddressSanitizer, MallocUsableSizeTest) {\n+  const size_t kArraySize = 100;\n+  char *array = Ident((char*)malloc(kArraySize));\n+  int *int_ptr = Ident(new int);\n+  EXPECT_EQ(0U, malloc_usable_size(NULL));\n+  EXPECT_EQ(kArraySize, malloc_usable_size(array));\n+  EXPECT_EQ(sizeof(int), malloc_usable_size(int_ptr));\n+  EXPECT_DEATH(malloc_usable_size((void*)0x123), kMallocUsableSizeErrorMsg);\n+  EXPECT_DEATH(malloc_usable_size(array + kArraySize / 2),\n+               kMallocUsableSizeErrorMsg);\n+  free(array);\n+  EXPECT_DEATH(malloc_usable_size(array), kMallocUsableSizeErrorMsg);\n+}\n+#endif\n+\n+void WrongFree() {\n+  int *x = (int*)malloc(100 * sizeof(int));\n+  // Use the allocated memory, otherwise Clang will optimize it out.\n+  Ident(x);\n+  free(x + 1);\n+}\n+\n+TEST(AddressSanitizer, WrongFreeTest) {\n+  EXPECT_DEATH(WrongFree(),\n+               \"ERROR: AddressSanitizer: attempting free.*not malloc\");\n+}\n+\n+void DoubleFree() {\n+  int *x = (int*)malloc(100 * sizeof(int));\n+  fprintf(stderr, \"DoubleFree: x=%p\\n\", x);\n+  free(x);\n+  free(x);\n+  fprintf(stderr, \"should have failed in the second free(%p)\\n\", x);\n+  abort();\n+}\n+\n+TEST(AddressSanitizer, DoubleFreeTest) {\n+  EXPECT_DEATH(DoubleFree(), ASAN_PCRE_DOTALL\n+               \"ERROR: AddressSanitizer: attempting double-free\"\n+               \".*is located 0 bytes inside of 400-byte region\"\n+               \".*freed by thread T0 here\"\n+               \".*previously allocated by thread T0 here\");\n+}\n+\n+template<int kSize>\n+NOINLINE void SizedStackTest() {\n+  char a[kSize];\n+  char  *A = Ident((char*)&a);\n+  for (size_t i = 0; i < kSize; i++)\n+    A[i] = i;\n+  EXPECT_DEATH(A[-1] = 0, \"\");\n+  EXPECT_DEATH(A[-20] = 0, \"\");\n+  EXPECT_DEATH(A[-31] = 0, \"\");\n+  EXPECT_DEATH(A[kSize] = 0, \"\");\n+  EXPECT_DEATH(A[kSize + 1] = 0, \"\");\n+  EXPECT_DEATH(A[kSize + 10] = 0, \"\");\n+  EXPECT_DEATH(A[kSize + 31] = 0, \"\");\n+}\n+\n+TEST(AddressSanitizer, SimpleStackTest) {\n+  SizedStackTest<1>();\n+  SizedStackTest<2>();\n+  SizedStackTest<3>();\n+  SizedStackTest<4>();\n+  SizedStackTest<5>();\n+  SizedStackTest<6>();\n+  SizedStackTest<7>();\n+  SizedStackTest<16>();\n+  SizedStackTest<25>();\n+  SizedStackTest<34>();\n+  SizedStackTest<43>();\n+  SizedStackTest<51>();\n+  SizedStackTest<62>();\n+  SizedStackTest<64>();\n+  SizedStackTest<128>();\n+}\n+\n+TEST(AddressSanitizer, ManyStackObjectsTest) {\n+  char XXX[10];\n+  char YYY[20];\n+  char ZZZ[30];\n+  Ident(XXX);\n+  Ident(YYY);\n+  EXPECT_DEATH(Ident(ZZZ)[-1] = 0, ASAN_PCRE_DOTALL \"XXX.*YYY.*ZZZ\");\n+}\n+\n+NOINLINE static void Frame0(int frame, char *a, char *b, char *c) {\n+  char d[4] = {0};\n+  char *D = Ident(d);\n+  switch (frame) {\n+    case 3: a[5]++; break;\n+    case 2: b[5]++; break;\n+    case 1: c[5]++; break;\n+    case 0: D[5]++; break;\n+  }\n+}\n+NOINLINE static void Frame1(int frame, char *a, char *b) {\n+  char c[4] = {0}; Frame0(frame, a, b, c);\n+  break_optimization(0);\n+}\n+NOINLINE static void Frame2(int frame, char *a) {\n+  char b[4] = {0}; Frame1(frame, a, b);\n+  break_optimization(0);\n+}\n+NOINLINE static void Frame3(int frame) {\n+  char a[4] = {0}; Frame2(frame, a);\n+  break_optimization(0);\n+}\n+\n+TEST(AddressSanitizer, GuiltyStackFrame0Test) {\n+  EXPECT_DEATH(Frame3(0), \"located .*in frame <.*Frame0\");\n+}\n+TEST(AddressSanitizer, GuiltyStackFrame1Test) {\n+  EXPECT_DEATH(Frame3(1), \"located .*in frame <.*Frame1\");\n+}\n+TEST(AddressSanitizer, GuiltyStackFrame2Test) {\n+  EXPECT_DEATH(Frame3(2), \"located .*in frame <.*Frame2\");\n+}\n+TEST(AddressSanitizer, GuiltyStackFrame3Test) {\n+  EXPECT_DEATH(Frame3(3), \"located .*in frame <.*Frame3\");\n+}\n+\n+NOINLINE void LongJmpFunc1(jmp_buf buf) {\n+  // create three red zones for these two stack objects.\n+  int a;\n+  int b;\n+\n+  int *A = Ident(&a);\n+  int *B = Ident(&b);\n+  *A = *B;\n+  longjmp(buf, 1);\n+}\n+\n+NOINLINE void BuiltinLongJmpFunc1(jmp_buf buf) {\n+  // create three red zones for these two stack objects.\n+  int a;\n+  int b;\n+\n+  int *A = Ident(&a);\n+  int *B = Ident(&b);\n+  *A = *B;\n+  __builtin_longjmp((void**)buf, 1);\n+}\n+\n+NOINLINE void UnderscopeLongJmpFunc1(jmp_buf buf) {\n+  // create three red zones for these two stack objects.\n+  int a;\n+  int b;\n+\n+  int *A = Ident(&a);\n+  int *B = Ident(&b);\n+  *A = *B;\n+  _longjmp(buf, 1);\n+}\n+\n+NOINLINE void SigLongJmpFunc1(sigjmp_buf buf) {\n+  // create three red zones for these two stack objects.\n+  int a;\n+  int b;\n+\n+  int *A = Ident(&a);\n+  int *B = Ident(&b);\n+  *A = *B;\n+  siglongjmp(buf, 1);\n+}\n+\n+\n+NOINLINE void TouchStackFunc() {\n+  int a[100];  // long array will intersect with redzones from LongJmpFunc1.\n+  int *A = Ident(a);\n+  for (int i = 0; i < 100; i++)\n+    A[i] = i*i;\n+}\n+\n+// Test that we handle longjmp and do not report fals positives on stack.\n+TEST(AddressSanitizer, LongJmpTest) {\n+  static jmp_buf buf;\n+  if (!setjmp(buf)) {\n+    LongJmpFunc1(buf);\n+  } else {\n+    TouchStackFunc();\n+  }\n+}\n+\n+#if not defined(__ANDROID__)\n+TEST(AddressSanitizer, BuiltinLongJmpTest) {\n+  static jmp_buf buf;\n+  if (!__builtin_setjmp((void**)buf)) {\n+    BuiltinLongJmpFunc1(buf);\n+  } else {\n+    TouchStackFunc();\n+  }\n+}\n+#endif  // not defined(__ANDROID__)\n+\n+TEST(AddressSanitizer, UnderscopeLongJmpTest) {\n+  static jmp_buf buf;\n+  if (!_setjmp(buf)) {\n+    UnderscopeLongJmpFunc1(buf);\n+  } else {\n+    TouchStackFunc();\n+  }\n+}\n+\n+TEST(AddressSanitizer, SigLongJmpTest) {\n+  static sigjmp_buf buf;\n+  if (!sigsetjmp(buf, 1)) {\n+    SigLongJmpFunc1(buf);\n+  } else {\n+    TouchStackFunc();\n+  }\n+}\n+\n+#ifdef __EXCEPTIONS\n+NOINLINE void ThrowFunc() {\n+  // create three red zones for these two stack objects.\n+  int a;\n+  int b;\n+\n+  int *A = Ident(&a);\n+  int *B = Ident(&b);\n+  *A = *B;\n+  ASAN_THROW(1);\n+}\n+\n+TEST(AddressSanitizer, CxxExceptionTest) {\n+  if (ASAN_UAR) return;\n+  // TODO(kcc): this test crashes on 32-bit for some reason...\n+  if (SANITIZER_WORDSIZE == 32) return;\n+  try {\n+    ThrowFunc();\n+  } catch(...) {}\n+  TouchStackFunc();\n+}\n+#endif\n+\n+void *ThreadStackReuseFunc1(void *unused) {\n+  // create three red zones for these two stack objects.\n+  int a;\n+  int b;\n+\n+  int *A = Ident(&a);\n+  int *B = Ident(&b);\n+  *A = *B;\n+  pthread_exit(0);\n+  return 0;\n+}\n+\n+void *ThreadStackReuseFunc2(void *unused) {\n+  TouchStackFunc();\n+  return 0;\n+}\n+\n+TEST(AddressSanitizer, ThreadStackReuseTest) {\n+  pthread_t t;\n+  PTHREAD_CREATE(&t, 0, ThreadStackReuseFunc1, 0);\n+  PTHREAD_JOIN(t, 0);\n+  PTHREAD_CREATE(&t, 0, ThreadStackReuseFunc2, 0);\n+  PTHREAD_JOIN(t, 0);\n+}\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+TEST(AddressSanitizer, Store128Test) {\n+  char *a = Ident((char*)malloc(Ident(12)));\n+  char *p = a;\n+  if (((uintptr_t)a % 16) != 0)\n+    p = a + 8;\n+  assert(((uintptr_t)p % 16) == 0);\n+  __m128i value_wide = _mm_set1_epi16(0x1234);\n+  EXPECT_DEATH(_mm_store_si128((__m128i*)p, value_wide),\n+               \"AddressSanitizer: heap-buffer-overflow\");\n+  EXPECT_DEATH(_mm_store_si128((__m128i*)p, value_wide),\n+               \"WRITE of size 16\");\n+  EXPECT_DEATH(_mm_store_si128((__m128i*)p, value_wide),\n+               \"located 0 bytes to the right of 12-byte\");\n+  free(a);\n+}\n+#endif\n+\n+static string RightOOBErrorMessage(int oob_distance) {\n+  assert(oob_distance >= 0);\n+  char expected_str[100];\n+  sprintf(expected_str, \"located %d bytes to the right\", oob_distance);\n+  return string(expected_str);\n+}\n+\n+static string LeftOOBErrorMessage(int oob_distance) {\n+  assert(oob_distance > 0);\n+  char expected_str[100];\n+  sprintf(expected_str, \"located %d bytes to the left\", oob_distance);\n+  return string(expected_str);\n+}\n+\n+template<typename T>\n+void MemSetOOBTestTemplate(size_t length) {\n+  if (length == 0) return;\n+  size_t size = Ident(sizeof(T) * length);\n+  T *array = Ident((T*)malloc(size));\n+  int element = Ident(42);\n+  int zero = Ident(0);\n+  // memset interval inside array\n+  memset(array, element, size);\n+  memset(array, element, size - 1);\n+  memset(array + length - 1, element, sizeof(T));\n+  memset(array, element, 1);\n+\n+  // memset 0 bytes\n+  memset(array - 10, element, zero);\n+  memset(array - 1, element, zero);\n+  memset(array, element, zero);\n+  memset(array + length, 0, zero);\n+  memset(array + length + 1, 0, zero);\n+\n+  // try to memset bytes to the right of array\n+  EXPECT_DEATH(memset(array, 0, size + 1),\n+               RightOOBErrorMessage(0));\n+  EXPECT_DEATH(memset((char*)(array + length) - 1, element, 6),\n+               RightOOBErrorMessage(4));\n+  EXPECT_DEATH(memset(array + 1, element, size + sizeof(T)),\n+               RightOOBErrorMessage(2 * sizeof(T) - 1));\n+  // whole interval is to the right\n+  EXPECT_DEATH(memset(array + length + 1, 0, 10),\n+               RightOOBErrorMessage(sizeof(T)));\n+\n+  // try to memset bytes to the left of array\n+  EXPECT_DEATH(memset((char*)array - 1, element, size),\n+               LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(memset((char*)array - 5, 0, 6),\n+               LeftOOBErrorMessage(5));\n+  EXPECT_DEATH(memset(array - 5, element, size + 5 * sizeof(T)),\n+               LeftOOBErrorMessage(5 * sizeof(T)));\n+  // whole interval is to the left\n+  EXPECT_DEATH(memset(array - 2, 0, sizeof(T)),\n+               LeftOOBErrorMessage(2 * sizeof(T)));\n+\n+  // try to memset bytes both to the left & to the right\n+  EXPECT_DEATH(memset((char*)array - 2, element, size + 4),\n+               LeftOOBErrorMessage(2));\n+\n+  free(array);\n+}\n+\n+TEST(AddressSanitizer, MemSetOOBTest) {\n+  MemSetOOBTestTemplate<char>(100);\n+  MemSetOOBTestTemplate<int>(5);\n+  MemSetOOBTestTemplate<double>(256);\n+  // We can test arrays of structres/classes here, but what for?\n+}\n+\n+// Same test for memcpy and memmove functions\n+template <typename T, class M>\n+void MemTransferOOBTestTemplate(size_t length) {\n+  if (length == 0) return;\n+  size_t size = Ident(sizeof(T) * length);\n+  T *src = Ident((T*)malloc(size));\n+  T *dest = Ident((T*)malloc(size));\n+  int zero = Ident(0);\n+\n+  // valid transfer of bytes between arrays\n+  M::transfer(dest, src, size);\n+  M::transfer(dest + 1, src, size - sizeof(T));\n+  M::transfer(dest, src + length - 1, sizeof(T));\n+  M::transfer(dest, src, 1);\n+\n+  // transfer zero bytes\n+  M::transfer(dest - 1, src, 0);\n+  M::transfer(dest + length, src, zero);\n+  M::transfer(dest, src - 1, zero);\n+  M::transfer(dest, src, zero);\n+\n+  // try to change mem to the right of dest\n+  EXPECT_DEATH(M::transfer(dest + 1, src, size),\n+               RightOOBErrorMessage(sizeof(T) - 1));\n+  EXPECT_DEATH(M::transfer((char*)(dest + length) - 1, src, 5),\n+               RightOOBErrorMessage(3));\n+\n+  // try to change mem to the left of dest\n+  EXPECT_DEATH(M::transfer(dest - 2, src, size),\n+               LeftOOBErrorMessage(2 * sizeof(T)));\n+  EXPECT_DEATH(M::transfer((char*)dest - 3, src, 4),\n+               LeftOOBErrorMessage(3));\n+\n+  // try to access mem to the right of src\n+  EXPECT_DEATH(M::transfer(dest, src + 2, size),\n+               RightOOBErrorMessage(2 * sizeof(T) - 1));\n+  EXPECT_DEATH(M::transfer(dest, (char*)(src + length) - 3, 6),\n+               RightOOBErrorMessage(2));\n+\n+  // try to access mem to the left of src\n+  EXPECT_DEATH(M::transfer(dest, src - 1, size),\n+               LeftOOBErrorMessage(sizeof(T)));\n+  EXPECT_DEATH(M::transfer(dest, (char*)src - 6, 7),\n+               LeftOOBErrorMessage(6));\n+\n+  // Generally we don't need to test cases where both accessing src and writing\n+  // to dest address to poisoned memory.\n+\n+  T *big_src = Ident((T*)malloc(size * 2));\n+  T *big_dest = Ident((T*)malloc(size * 2));\n+  // try to change mem to both sides of dest\n+  EXPECT_DEATH(M::transfer(dest - 1, big_src, size * 2),\n+               LeftOOBErrorMessage(sizeof(T)));\n+  // try to access mem to both sides of src\n+  EXPECT_DEATH(M::transfer(big_dest, src - 2, size * 2),\n+               LeftOOBErrorMessage(2 * sizeof(T)));\n+\n+  free(src);\n+  free(dest);\n+  free(big_src);\n+  free(big_dest);\n+}\n+\n+class MemCpyWrapper {\n+ public:\n+  static void* transfer(void *to, const void *from, size_t size) {\n+    return memcpy(to, from, size);\n+  }\n+};\n+TEST(AddressSanitizer, MemCpyOOBTest) {\n+  MemTransferOOBTestTemplate<char, MemCpyWrapper>(100);\n+  MemTransferOOBTestTemplate<int, MemCpyWrapper>(1024);\n+}\n+\n+class MemMoveWrapper {\n+ public:\n+  static void* transfer(void *to, const void *from, size_t size) {\n+    return memmove(to, from, size);\n+  }\n+};\n+TEST(AddressSanitizer, MemMoveOOBTest) {\n+  MemTransferOOBTestTemplate<char, MemMoveWrapper>(100);\n+  MemTransferOOBTestTemplate<int, MemMoveWrapper>(1024);\n+}\n+\n+// Tests for string functions\n+\n+// Used for string functions tests\n+static char global_string[] = \"global\";\n+static size_t global_string_length = 6;\n+\n+// Input to a test is a zero-terminated string str with given length\n+// Accesses to the bytes to the left and to the right of str\n+// are presumed to produce OOB errors\n+void StrLenOOBTestTemplate(char *str, size_t length, bool is_global) {\n+  // Normal strlen calls\n+  EXPECT_EQ(strlen(str), length);\n+  if (length > 0) {\n+    EXPECT_EQ(length - 1, strlen(str + 1));\n+    EXPECT_EQ(0U, strlen(str + length));\n+  }\n+  // Arg of strlen is not malloced, OOB access\n+  if (!is_global) {\n+    // We don't insert RedZones to the left of global variables\n+    EXPECT_DEATH(Ident(strlen(str - 1)), LeftOOBErrorMessage(1));\n+    EXPECT_DEATH(Ident(strlen(str - 5)), LeftOOBErrorMessage(5));\n+  }\n+  EXPECT_DEATH(Ident(strlen(str + length + 1)), RightOOBErrorMessage(0));\n+  // Overwrite terminator\n+  str[length] = 'a';\n+  // String is not zero-terminated, strlen will lead to OOB access\n+  EXPECT_DEATH(Ident(strlen(str)), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(strlen(str + length)), RightOOBErrorMessage(0));\n+  // Restore terminator\n+  str[length] = 0;\n+}\n+TEST(AddressSanitizer, StrLenOOBTest) {\n+  // Check heap-allocated string\n+  size_t length = Ident(10);\n+  char *heap_string = Ident((char*)malloc(length + 1));\n+  char stack_string[10 + 1];\n+  break_optimization(&stack_string);\n+  for (size_t i = 0; i < length; i++) {\n+    heap_string[i] = 'a';\n+    stack_string[i] = 'b';\n+  }\n+  heap_string[length] = 0;\n+  stack_string[length] = 0;\n+  StrLenOOBTestTemplate(heap_string, length, false);\n+  // TODO(samsonov): Fix expected messages in StrLenOOBTestTemplate to\n+  //      make test for stack_string work. Or move it to output tests.\n+  // StrLenOOBTestTemplate(stack_string, length, false);\n+  StrLenOOBTestTemplate(global_string, global_string_length, true);\n+  free(heap_string);\n+}\n+\n+static inline char* MallocAndMemsetString(size_t size, char ch) {\n+  char *s = Ident((char*)malloc(size));\n+  memset(s, ch, size);\n+  return s;\n+}\n+static inline char* MallocAndMemsetString(size_t size) {\n+  return MallocAndMemsetString(size, 'z');\n+}\n+\n+#ifndef __APPLE__\n+TEST(AddressSanitizer, StrNLenOOBTest) {\n+  size_t size = Ident(123);\n+  char *str = MallocAndMemsetString(size);\n+  // Normal strnlen calls.\n+  Ident(strnlen(str - 1, 0));\n+  Ident(strnlen(str, size));\n+  Ident(strnlen(str + size - 1, 1));\n+  str[size - 1] = '\\0';\n+  Ident(strnlen(str, 2 * size));\n+  // Argument points to not allocated memory.\n+  EXPECT_DEATH(Ident(strnlen(str - 1, 1)), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(strnlen(str + size, 1)), RightOOBErrorMessage(0));\n+  // Overwrite the terminating '\\0' and hit unallocated memory.\n+  str[size - 1] = 'z';\n+  EXPECT_DEATH(Ident(strnlen(str, size + 1)), RightOOBErrorMessage(0));\n+  free(str);\n+}\n+#endif\n+\n+TEST(AddressSanitizer, StrDupOOBTest) {\n+  size_t size = Ident(42);\n+  char *str = MallocAndMemsetString(size);\n+  char *new_str;\n+  // Normal strdup calls.\n+  str[size - 1] = '\\0';\n+  new_str = strdup(str);\n+  free(new_str);\n+  new_str = strdup(str + size - 1);\n+  free(new_str);\n+  // Argument points to not allocated memory.\n+  EXPECT_DEATH(Ident(strdup(str - 1)), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(strdup(str + size)), RightOOBErrorMessage(0));\n+  // Overwrite the terminating '\\0' and hit unallocated memory.\n+  str[size - 1] = 'z';\n+  EXPECT_DEATH(Ident(strdup(str)), RightOOBErrorMessage(0));\n+  free(str);\n+}\n+\n+TEST(AddressSanitizer, StrCpyOOBTest) {\n+  size_t to_size = Ident(30);\n+  size_t from_size = Ident(6);  // less than to_size\n+  char *to = Ident((char*)malloc(to_size));\n+  char *from = Ident((char*)malloc(from_size));\n+  // Normal strcpy calls.\n+  strcpy(from, \"hello\");\n+  strcpy(to, from);\n+  strcpy(to + to_size - from_size, from);\n+  // Length of \"from\" is too small.\n+  EXPECT_DEATH(Ident(strcpy(from, \"hello2\")), RightOOBErrorMessage(0));\n+  // \"to\" or \"from\" points to not allocated memory.\n+  EXPECT_DEATH(Ident(strcpy(to - 1, from)), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(strcpy(to, from - 1)), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(strcpy(to, from + from_size)), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(strcpy(to + to_size, from)), RightOOBErrorMessage(0));\n+  // Overwrite the terminating '\\0' character and hit unallocated memory.\n+  from[from_size - 1] = '!';\n+  EXPECT_DEATH(Ident(strcpy(to, from)), RightOOBErrorMessage(0));\n+  free(to);\n+  free(from);\n+}\n+\n+TEST(AddressSanitizer, StrNCpyOOBTest) {\n+  size_t to_size = Ident(20);\n+  size_t from_size = Ident(6);  // less than to_size\n+  char *to = Ident((char*)malloc(to_size));\n+  // From is a zero-terminated string \"hello\\0\" of length 6\n+  char *from = Ident((char*)malloc(from_size));\n+  strcpy(from, \"hello\");\n+  // copy 0 bytes\n+  strncpy(to, from, 0);\n+  strncpy(to - 1, from - 1, 0);\n+  // normal strncpy calls\n+  strncpy(to, from, from_size);\n+  strncpy(to, from, to_size);\n+  strncpy(to, from + from_size - 1, to_size);\n+  strncpy(to + to_size - 1, from, 1);\n+  // One of {to, from} points to not allocated memory\n+  EXPECT_DEATH(Ident(strncpy(to, from - 1, from_size)),\n+               LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(strncpy(to - 1, from, from_size)),\n+               LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(strncpy(to, from + from_size, 1)),\n+               RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(strncpy(to + to_size, from, 1)),\n+               RightOOBErrorMessage(0));\n+  // Length of \"to\" is too small\n+  EXPECT_DEATH(Ident(strncpy(to + to_size - from_size + 1, from, from_size)),\n+               RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(strncpy(to + 1, from, to_size)),\n+               RightOOBErrorMessage(0));\n+  // Overwrite terminator in from\n+  from[from_size - 1] = '!';\n+  // normal strncpy call\n+  strncpy(to, from, from_size);\n+  // Length of \"from\" is too small\n+  EXPECT_DEATH(Ident(strncpy(to, from, to_size)),\n+               RightOOBErrorMessage(0));\n+  free(to);\n+  free(from);\n+}\n+\n+// Users may have different definitions of \"strchr\" and \"index\", so provide\n+// function pointer typedefs and overload RunStrChrTest implementation.\n+// We can't use macro for RunStrChrTest body here, as this macro would\n+// confuse EXPECT_DEATH gtest macro.\n+typedef char*(*PointerToStrChr1)(const char*, int);\n+typedef char*(*PointerToStrChr2)(char*, int);\n+\n+USED static void RunStrChrTest(PointerToStrChr1 StrChr) {\n+  size_t size = Ident(100);\n+  char *str = MallocAndMemsetString(size);\n+  str[10] = 'q';\n+  str[11] = '\\0';\n+  EXPECT_EQ(str, StrChr(str, 'z'));\n+  EXPECT_EQ(str + 10, StrChr(str, 'q'));\n+  EXPECT_EQ(NULL, StrChr(str, 'a'));\n+  // StrChr argument points to not allocated memory.\n+  EXPECT_DEATH(Ident(StrChr(str - 1, 'z')), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(StrChr(str + size, 'z')), RightOOBErrorMessage(0));\n+  // Overwrite the terminator and hit not allocated memory.\n+  str[11] = 'z';\n+  EXPECT_DEATH(Ident(StrChr(str, 'a')), RightOOBErrorMessage(0));\n+  free(str);\n+}\n+USED static void RunStrChrTest(PointerToStrChr2 StrChr) {\n+  size_t size = Ident(100);\n+  char *str = MallocAndMemsetString(size);\n+  str[10] = 'q';\n+  str[11] = '\\0';\n+  EXPECT_EQ(str, StrChr(str, 'z'));\n+  EXPECT_EQ(str + 10, StrChr(str, 'q'));\n+  EXPECT_EQ(NULL, StrChr(str, 'a'));\n+  // StrChr argument points to not allocated memory.\n+  EXPECT_DEATH(Ident(StrChr(str - 1, 'z')), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(StrChr(str + size, 'z')), RightOOBErrorMessage(0));\n+  // Overwrite the terminator and hit not allocated memory.\n+  str[11] = 'z';\n+  EXPECT_DEATH(Ident(StrChr(str, 'a')), RightOOBErrorMessage(0));\n+  free(str);\n+}\n+\n+TEST(AddressSanitizer, StrChrAndIndexOOBTest) {\n+  RunStrChrTest(&strchr);\n+  RunStrChrTest(&index);\n+}\n+\n+TEST(AddressSanitizer, StrCmpAndFriendsLogicTest) {\n+  // strcmp\n+  EXPECT_EQ(0, strcmp(\"\", \"\"));\n+  EXPECT_EQ(0, strcmp(\"abcd\", \"abcd\"));\n+  EXPECT_GT(0, strcmp(\"ab\", \"ac\"));\n+  EXPECT_GT(0, strcmp(\"abc\", \"abcd\"));\n+  EXPECT_LT(0, strcmp(\"acc\", \"abc\"));\n+  EXPECT_LT(0, strcmp(\"abcd\", \"abc\"));\n+\n+  // strncmp\n+  EXPECT_EQ(0, strncmp(\"a\", \"b\", 0));\n+  EXPECT_EQ(0, strncmp(\"abcd\", \"abcd\", 10));\n+  EXPECT_EQ(0, strncmp(\"abcd\", \"abcef\", 3));\n+  EXPECT_GT(0, strncmp(\"abcde\", \"abcfa\", 4));\n+  EXPECT_GT(0, strncmp(\"a\", \"b\", 5));\n+  EXPECT_GT(0, strncmp(\"bc\", \"bcde\", 4));\n+  EXPECT_LT(0, strncmp(\"xyz\", \"xyy\", 10));\n+  EXPECT_LT(0, strncmp(\"baa\", \"aaa\", 1));\n+  EXPECT_LT(0, strncmp(\"zyx\", \"\", 2));\n+\n+  // strcasecmp\n+  EXPECT_EQ(0, strcasecmp(\"\", \"\"));\n+  EXPECT_EQ(0, strcasecmp(\"zzz\", \"zzz\"));\n+  EXPECT_EQ(0, strcasecmp(\"abCD\", \"ABcd\"));\n+  EXPECT_GT(0, strcasecmp(\"aB\", \"Ac\"));\n+  EXPECT_GT(0, strcasecmp(\"ABC\", \"ABCd\"));\n+  EXPECT_LT(0, strcasecmp(\"acc\", \"abc\"));\n+  EXPECT_LT(0, strcasecmp(\"ABCd\", \"abc\"));\n+\n+  // strncasecmp\n+  EXPECT_EQ(0, strncasecmp(\"a\", \"b\", 0));\n+  EXPECT_EQ(0, strncasecmp(\"abCD\", \"ABcd\", 10));\n+  EXPECT_EQ(0, strncasecmp(\"abCd\", \"ABcef\", 3));\n+  EXPECT_GT(0, strncasecmp(\"abcde\", \"ABCfa\", 4));\n+  EXPECT_GT(0, strncasecmp(\"a\", \"B\", 5));\n+  EXPECT_GT(0, strncasecmp(\"bc\", \"BCde\", 4));\n+  EXPECT_LT(0, strncasecmp(\"xyz\", \"xyy\", 10));\n+  EXPECT_LT(0, strncasecmp(\"Baa\", \"aaa\", 1));\n+  EXPECT_LT(0, strncasecmp(\"zyx\", \"\", 2));\n+\n+  // memcmp\n+  EXPECT_EQ(0, memcmp(\"a\", \"b\", 0));\n+  EXPECT_EQ(0, memcmp(\"ab\\0c\", \"ab\\0c\", 4));\n+  EXPECT_GT(0, memcmp(\"\\0ab\", \"\\0ac\", 3));\n+  EXPECT_GT(0, memcmp(\"abb\\0\", \"abba\", 4));\n+  EXPECT_LT(0, memcmp(\"ab\\0cd\", \"ab\\0c\\0\", 5));\n+  EXPECT_LT(0, memcmp(\"zza\", \"zyx\", 3));\n+}\n+\n+typedef int(*PointerToStrCmp)(const char*, const char*);\n+void RunStrCmpTest(PointerToStrCmp StrCmp) {\n+  size_t size = Ident(100);\n+  char *s1 = MallocAndMemsetString(size);\n+  char *s2 = MallocAndMemsetString(size);\n+  s1[size - 1] = '\\0';\n+  s2[size - 1] = '\\0';\n+  // Normal StrCmp calls\n+  Ident(StrCmp(s1, s2));\n+  Ident(StrCmp(s1, s2 + size - 1));\n+  Ident(StrCmp(s1 + size - 1, s2 + size - 1));\n+  s1[size - 1] = 'z';\n+  s2[size - 1] = 'x';\n+  Ident(StrCmp(s1, s2));\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(Ident(StrCmp)(s1 - 1, s2), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(StrCmp)(s1, s2 - 1), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(StrCmp)(s1 + size, s2), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(StrCmp)(s1, s2 + size), RightOOBErrorMessage(0));\n+  // Hit unallocated memory and die.\n+  s2[size - 1] = 'z';\n+  EXPECT_DEATH(Ident(StrCmp)(s1, s1), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(StrCmp)(s1 + size - 1, s2), RightOOBErrorMessage(0));\n+  free(s1);\n+  free(s2);\n+}\n+\n+TEST(AddressSanitizer, StrCmpOOBTest) {\n+  RunStrCmpTest(&strcmp);\n+}\n+\n+TEST(AddressSanitizer, StrCaseCmpOOBTest) {\n+  RunStrCmpTest(&strcasecmp);\n+}\n+\n+typedef int(*PointerToStrNCmp)(const char*, const char*, size_t);\n+void RunStrNCmpTest(PointerToStrNCmp StrNCmp) {\n+  size_t size = Ident(100);\n+  char *s1 = MallocAndMemsetString(size);\n+  char *s2 = MallocAndMemsetString(size);\n+  s1[size - 1] = '\\0';\n+  s2[size - 1] = '\\0';\n+  // Normal StrNCmp calls\n+  Ident(StrNCmp(s1, s2, size + 2));\n+  s1[size - 1] = 'z';\n+  s2[size - 1] = 'x';\n+  Ident(StrNCmp(s1 + size - 2, s2 + size - 2, size));\n+  s2[size - 1] = 'z';\n+  Ident(StrNCmp(s1 - 1, s2 - 1, 0));\n+  Ident(StrNCmp(s1 + size - 1, s2 + size - 1, 1));\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(Ident(StrNCmp)(s1 - 1, s2, 1), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(StrNCmp)(s1, s2 - 1, 1), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(StrNCmp)(s1 + size, s2, 1), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(StrNCmp)(s1, s2 + size, 1), RightOOBErrorMessage(0));\n+  // Hit unallocated memory and die.\n+  EXPECT_DEATH(Ident(StrNCmp)(s1 + 1, s2 + 1, size), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(StrNCmp)(s1 + size - 1, s2, 2), RightOOBErrorMessage(0));\n+  free(s1);\n+  free(s2);\n+}\n+\n+TEST(AddressSanitizer, StrNCmpOOBTest) {\n+  RunStrNCmpTest(&strncmp);\n+}\n+\n+TEST(AddressSanitizer, StrNCaseCmpOOBTest) {\n+  RunStrNCmpTest(&strncasecmp);\n+}\n+\n+TEST(AddressSanitizer, MemCmpOOBTest) {\n+  size_t size = Ident(100);\n+  char *s1 = MallocAndMemsetString(size);\n+  char *s2 = MallocAndMemsetString(size);\n+  // Normal memcmp calls.\n+  Ident(memcmp(s1, s2, size));\n+  Ident(memcmp(s1 + size - 1, s2 + size - 1, 1));\n+  Ident(memcmp(s1 - 1, s2 - 1, 0));\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(Ident(memcmp)(s1 - 1, s2, 1), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(memcmp)(s1, s2 - 1, 1), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(Ident(memcmp)(s1 + size, s2, 1), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(memcmp)(s1, s2 + size, 1), RightOOBErrorMessage(0));\n+  // Hit unallocated memory and die.\n+  EXPECT_DEATH(Ident(memcmp)(s1 + 1, s2 + 1, size), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Ident(memcmp)(s1 + size - 1, s2, 2), RightOOBErrorMessage(0));\n+  // Zero bytes are not terminators and don't prevent from OOB.\n+  s1[size - 1] = '\\0';\n+  s2[size - 1] = '\\0';\n+  EXPECT_DEATH(Ident(memcmp)(s1, s2, size + 1), RightOOBErrorMessage(0));\n+  free(s1);\n+  free(s2);\n+}\n+\n+TEST(AddressSanitizer, StrCatOOBTest) {\n+  size_t to_size = Ident(100);\n+  char *to = MallocAndMemsetString(to_size);\n+  to[0] = '\\0';\n+  size_t from_size = Ident(20);\n+  char *from = MallocAndMemsetString(from_size);\n+  from[from_size - 1] = '\\0';\n+  // Normal strcat calls.\n+  strcat(to, from);\n+  strcat(to, from);\n+  strcat(to + from_size, from + from_size - 2);\n+  // Passing an invalid pointer is an error even when concatenating an empty\n+  // string.\n+  EXPECT_DEATH(strcat(to - 1, from + from_size - 1), LeftOOBErrorMessage(1));\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(strcat(to - 1, from), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(strcat(to, from - 1), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(strcat(to + to_size, from), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(strcat(to, from + from_size), RightOOBErrorMessage(0));\n+\n+  // \"from\" is not zero-terminated.\n+  from[from_size - 1] = 'z';\n+  EXPECT_DEATH(strcat(to, from), RightOOBErrorMessage(0));\n+  from[from_size - 1] = '\\0';\n+  // \"to\" is not zero-terminated.\n+  memset(to, 'z', to_size);\n+  EXPECT_DEATH(strcat(to, from), RightOOBErrorMessage(0));\n+  // \"to\" is too short to fit \"from\".\n+  to[to_size - from_size + 1] = '\\0';\n+  EXPECT_DEATH(strcat(to, from), RightOOBErrorMessage(0));\n+  // length of \"to\" is just enough.\n+  strcat(to, from + 1);\n+\n+  free(to);\n+  free(from);\n+}\n+\n+TEST(AddressSanitizer, StrNCatOOBTest) {\n+  size_t to_size = Ident(100);\n+  char *to = MallocAndMemsetString(to_size);\n+  to[0] = '\\0';\n+  size_t from_size = Ident(20);\n+  char *from = MallocAndMemsetString(from_size);\n+  // Normal strncat calls.\n+  strncat(to, from, 0);\n+  strncat(to, from, from_size);\n+  from[from_size - 1] = '\\0';\n+  strncat(to, from, 2 * from_size);\n+  // Catenating empty string with an invalid string is still an error.\n+  EXPECT_DEATH(strncat(to - 1, from, 0), LeftOOBErrorMessage(1));\n+  strncat(to, from + from_size - 1, 10);\n+  // One of arguments points to not allocated memory.\n+  EXPECT_DEATH(strncat(to - 1, from, 2), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(strncat(to, from - 1, 2), LeftOOBErrorMessage(1));\n+  EXPECT_DEATH(strncat(to + to_size, from, 2), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(strncat(to, from + from_size, 2), RightOOBErrorMessage(0));\n+\n+  memset(from, 'z', from_size);\n+  memset(to, 'z', to_size);\n+  to[0] = '\\0';\n+  // \"from\" is too short.\n+  EXPECT_DEATH(strncat(to, from, from_size + 1), RightOOBErrorMessage(0));\n+  // \"to\" is not zero-terminated.\n+  EXPECT_DEATH(strncat(to + 1, from, 1), RightOOBErrorMessage(0));\n+  // \"to\" is too short to fit \"from\".\n+  to[0] = 'z';\n+  to[to_size - from_size + 1] = '\\0';\n+  EXPECT_DEATH(strncat(to, from, from_size - 1), RightOOBErrorMessage(0));\n+  // \"to\" is just enough.\n+  strncat(to, from, from_size - 2);\n+\n+  free(to);\n+  free(from);\n+}\n+\n+static string OverlapErrorMessage(const string &func) {\n+  return func + \"-param-overlap\";\n+}\n+\n+TEST(AddressSanitizer, StrArgsOverlapTest) {\n+  size_t size = Ident(100);\n+  char *str = Ident((char*)malloc(size));\n+\n+// Do not check memcpy() on OS X 10.7 and later, where it actually aliases\n+// memmove().\n+#if !defined(__APPLE__) || !defined(MAC_OS_X_VERSION_10_7) || \\\n+    (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_7)\n+  // Check \"memcpy\". Use Ident() to avoid inlining.\n+  memset(str, 'z', size);\n+  Ident(memcpy)(str + 1, str + 11, 10);\n+  Ident(memcpy)(str, str, 0);\n+  EXPECT_DEATH(Ident(memcpy)(str, str + 14, 15), OverlapErrorMessage(\"memcpy\"));\n+  EXPECT_DEATH(Ident(memcpy)(str + 14, str, 15), OverlapErrorMessage(\"memcpy\"));\n+#endif\n+\n+  // We do not treat memcpy with to==from as a bug.\n+  // See http://llvm.org/bugs/show_bug.cgi?id=11763.\n+  // EXPECT_DEATH(Ident(memcpy)(str + 20, str + 20, 1),\n+  //              OverlapErrorMessage(\"memcpy\"));\n+\n+  // Check \"strcpy\".\n+  memset(str, 'z', size);\n+  str[9] = '\\0';\n+  strcpy(str + 10, str);\n+  EXPECT_DEATH(strcpy(str + 9, str), OverlapErrorMessage(\"strcpy\"));\n+  EXPECT_DEATH(strcpy(str, str + 4), OverlapErrorMessage(\"strcpy\"));\n+  strcpy(str, str + 5);\n+\n+  // Check \"strncpy\".\n+  memset(str, 'z', size);\n+  strncpy(str, str + 10, 10);\n+  EXPECT_DEATH(strncpy(str, str + 9, 10), OverlapErrorMessage(\"strncpy\"));\n+  EXPECT_DEATH(strncpy(str + 9, str, 10), OverlapErrorMessage(\"strncpy\"));\n+  str[10] = '\\0';\n+  strncpy(str + 11, str, 20);\n+  EXPECT_DEATH(strncpy(str + 10, str, 20), OverlapErrorMessage(\"strncpy\"));\n+\n+  // Check \"strcat\".\n+  memset(str, 'z', size);\n+  str[10] = '\\0';\n+  str[20] = '\\0';\n+  strcat(str, str + 10);\n+  EXPECT_DEATH(strcat(str, str + 11), OverlapErrorMessage(\"strcat\"));\n+  str[10] = '\\0';\n+  strcat(str + 11, str);\n+  EXPECT_DEATH(strcat(str, str + 9), OverlapErrorMessage(\"strcat\"));\n+  EXPECT_DEATH(strcat(str + 9, str), OverlapErrorMessage(\"strcat\"));\n+  EXPECT_DEATH(strcat(str + 10, str), OverlapErrorMessage(\"strcat\"));\n+\n+  // Check \"strncat\".\n+  memset(str, 'z', size);\n+  str[10] = '\\0';\n+  strncat(str, str + 10, 10);  // from is empty\n+  EXPECT_DEATH(strncat(str, str + 11, 10), OverlapErrorMessage(\"strncat\"));\n+  str[10] = '\\0';\n+  str[20] = '\\0';\n+  strncat(str + 5, str, 5);\n+  str[10] = '\\0';\n+  EXPECT_DEATH(strncat(str + 5, str, 6), OverlapErrorMessage(\"strncat\"));\n+  EXPECT_DEATH(strncat(str, str + 9, 10), OverlapErrorMessage(\"strncat\"));\n+\n+  free(str);\n+}\n+\n+void CallAtoi(const char *nptr) {\n+  Ident(atoi(nptr));\n+}\n+void CallAtol(const char *nptr) {\n+  Ident(atol(nptr));\n+}\n+void CallAtoll(const char *nptr) {\n+  Ident(atoll(nptr));\n+}\n+typedef void(*PointerToCallAtoi)(const char*);\n+\n+void RunAtoiOOBTest(PointerToCallAtoi Atoi) {\n+  char *array = MallocAndMemsetString(10, '1');\n+  // Invalid pointer to the string.\n+  EXPECT_DEATH(Atoi(array + 11), RightOOBErrorMessage(1));\n+  EXPECT_DEATH(Atoi(array - 1), LeftOOBErrorMessage(1));\n+  // Die if a buffer doesn't have terminating NULL.\n+  EXPECT_DEATH(Atoi(array), RightOOBErrorMessage(0));\n+  // Make last symbol a terminating NULL or other non-digit.\n+  array[9] = '\\0';\n+  Atoi(array);\n+  array[9] = 'a';\n+  Atoi(array);\n+  Atoi(array + 9);\n+  // Sometimes we need to detect overflow if no digits are found.\n+  memset(array, ' ', 10);\n+  EXPECT_DEATH(Atoi(array), RightOOBErrorMessage(0));\n+  array[9] = '-';\n+  EXPECT_DEATH(Atoi(array), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Atoi(array + 9), RightOOBErrorMessage(0));\n+  array[8] = '-';\n+  Atoi(array);\n+  delete array;\n+}\n+\n+TEST(AddressSanitizer, AtoiAndFriendsOOBTest) {\n+  RunAtoiOOBTest(&CallAtoi);\n+  RunAtoiOOBTest(&CallAtol);\n+  RunAtoiOOBTest(&CallAtoll);\n+}\n+\n+void CallStrtol(const char *nptr, char **endptr, int base) {\n+  Ident(strtol(nptr, endptr, base));\n+}\n+void CallStrtoll(const char *nptr, char **endptr, int base) {\n+  Ident(strtoll(nptr, endptr, base));\n+}\n+typedef void(*PointerToCallStrtol)(const char*, char**, int);\n+\n+void RunStrtolOOBTest(PointerToCallStrtol Strtol) {\n+  char *array = MallocAndMemsetString(3);\n+  char *endptr = NULL;\n+  array[0] = '1';\n+  array[1] = '2';\n+  array[2] = '3';\n+  // Invalid pointer to the string.\n+  EXPECT_DEATH(Strtol(array + 3, NULL, 0), RightOOBErrorMessage(0));\n+  EXPECT_DEATH(Strtol(array - 1, NULL, 0), LeftOOBErrorMessage(1));\n+  // Buffer overflow if there is no terminating null (depends on base).\n+  Strtol(array, &endptr, 3);\n+  EXPECT_EQ(array + 2, endptr);\n+  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBErrorMessage(0));\n+  array[2] = 'z';\n+  Strtol(array, &endptr, 35);\n+  EXPECT_EQ(array + 2, endptr);\n+  EXPECT_DEATH(Strtol(array, NULL, 36), RightOOBErrorMessage(0));\n+  // Add terminating zero to get rid of overflow.\n+  array[2] = '\\0';\n+  Strtol(array, NULL, 36);\n+  // Don't check for overflow if base is invalid.\n+  Strtol(array - 1, NULL, -1);\n+  Strtol(array + 3, NULL, 1);\n+  // Sometimes we need to detect overflow if no digits are found.\n+  array[0] = array[1] = array[2] = ' ';\n+  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBErrorMessage(0));\n+  array[2] = '+';\n+  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBErrorMessage(0));\n+  array[2] = '-';\n+  EXPECT_DEATH(Strtol(array, NULL, 0), RightOOBErrorMessage(0));\n+  array[1] = '+';\n+  Strtol(array, NULL, 0);\n+  array[1] = array[2] = 'z';\n+  Strtol(array, &endptr, 0);\n+  EXPECT_EQ(array, endptr);\n+  Strtol(array + 2, NULL, 0);\n+  EXPECT_EQ(array, endptr);\n+  delete array;\n+}\n+\n+TEST(AddressSanitizer, StrtollOOBTest) {\n+  RunStrtolOOBTest(&CallStrtoll);\n+}\n+TEST(AddressSanitizer, StrtolOOBTest) {\n+  RunStrtolOOBTest(&CallStrtol);\n+}\n+\n+// At the moment we instrument memcpy/memove/memset calls at compile time so we\n+// can't handle OOB error if these functions are called by pointer, see disabled\n+// MemIntrinsicCallByPointerTest below\n+typedef void*(*PointerToMemTransfer)(void*, const void*, size_t);\n+typedef void*(*PointerToMemSet)(void*, int, size_t);\n+\n+void CallMemSetByPointer(PointerToMemSet MemSet) {\n+  size_t size = Ident(100);\n+  char *array = Ident((char*)malloc(size));\n+  EXPECT_DEATH(MemSet(array, 0, 101), RightOOBErrorMessage(0));\n+  free(array);\n+}\n+\n+void CallMemTransferByPointer(PointerToMemTransfer MemTransfer) {\n+  size_t size = Ident(100);\n+  char *src = Ident((char*)malloc(size));\n+  char *dst = Ident((char*)malloc(size));\n+  EXPECT_DEATH(MemTransfer(dst, src, 101), RightOOBErrorMessage(0));\n+  free(src);\n+  free(dst);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_MemIntrinsicCallByPointerTest) {\n+  CallMemSetByPointer(&memset);\n+  CallMemTransferByPointer(&memcpy);\n+  CallMemTransferByPointer(&memmove);\n+}\n+\n+// This test case fails\n+// Clang optimizes memcpy/memset calls which lead to unaligned access\n+TEST(AddressSanitizer, DISABLED_MemIntrinsicUnalignedAccessTest) {\n+  int size = Ident(4096);\n+  char *s = Ident((char*)malloc(size));\n+  EXPECT_DEATH(memset(s + size - 1, 0, 2), RightOOBErrorMessage(0));\n+  free(s);\n+}\n+\n+// TODO(samsonov): Add a test with malloc(0)\n+// TODO(samsonov): Add tests for str* and mem* functions.\n+\n+NOINLINE static int LargeFunction(bool do_bad_access) {\n+  int *x = new int[100];\n+  x[0]++;\n+  x[1]++;\n+  x[2]++;\n+  x[3]++;\n+  x[4]++;\n+  x[5]++;\n+  x[6]++;\n+  x[7]++;\n+  x[8]++;\n+  x[9]++;\n+\n+  x[do_bad_access ? 100 : 0]++; int res = __LINE__;\n+\n+  x[10]++;\n+  x[11]++;\n+  x[12]++;\n+  x[13]++;\n+  x[14]++;\n+  x[15]++;\n+  x[16]++;\n+  x[17]++;\n+  x[18]++;\n+  x[19]++;\n+\n+  delete x;\n+  return res;\n+}\n+\n+// Test the we have correct debug info for the failing instruction.\n+// This test requires the in-process symbolizer to be enabled by default.\n+TEST(AddressSanitizer, DISABLED_LargeFunctionSymbolizeTest) {\n+  int failing_line = LargeFunction(false);\n+  char expected_warning[128];\n+  sprintf(expected_warning, \"LargeFunction.*asan_test.cc:%d\", failing_line);\n+  EXPECT_DEATH(LargeFunction(true), expected_warning);\n+}\n+\n+// Check that we unwind and symbolize correctly.\n+TEST(AddressSanitizer, DISABLED_MallocFreeUnwindAndSymbolizeTest) {\n+  int *a = (int*)malloc_aaa(sizeof(int));\n+  *a = 1;\n+  free_aaa(a);\n+  EXPECT_DEATH(*a = 1, \"free_ccc.*free_bbb.*free_aaa.*\"\n+               \"malloc_fff.*malloc_eee.*malloc_ddd\");\n+}\n+\n+void *ThreadedTestAlloc(void *a) {\n+  int **p = (int**)a;\n+  *p = new int;\n+  return 0;\n+}\n+\n+void *ThreadedTestFree(void *a) {\n+  int **p = (int**)a;\n+  delete *p;\n+  return 0;\n+}\n+\n+void *ThreadedTestUse(void *a) {\n+  int **p = (int**)a;\n+  **p = 1;\n+  return 0;\n+}\n+\n+void ThreadedTestSpawn() {\n+  pthread_t t;\n+  int *x;\n+  PTHREAD_CREATE(&t, 0, ThreadedTestAlloc, &x);\n+  PTHREAD_JOIN(t, 0);\n+  PTHREAD_CREATE(&t, 0, ThreadedTestFree, &x);\n+  PTHREAD_JOIN(t, 0);\n+  PTHREAD_CREATE(&t, 0, ThreadedTestUse, &x);\n+  PTHREAD_JOIN(t, 0);\n+}\n+\n+TEST(AddressSanitizer, ThreadedTest) {\n+  EXPECT_DEATH(ThreadedTestSpawn(),\n+               ASAN_PCRE_DOTALL\n+               \"Thread T.*created\"\n+               \".*Thread T.*created\"\n+               \".*Thread T.*created\");\n+}\n+\n+#if ASAN_NEEDS_SEGV\n+TEST(AddressSanitizer, ShadowGapTest) {\n+#if SANITIZER_WORDSIZE == 32\n+  char *addr = (char*)0x22000000;\n+#else\n+  char *addr = (char*)0x0000100000080000;\n+#endif\n+  EXPECT_DEATH(*addr = 1, \"AddressSanitizer: SEGV on unknown\");\n+}\n+#endif  // ASAN_NEEDS_SEGV\n+\n+extern \"C\" {\n+NOINLINE static void UseThenFreeThenUse() {\n+  char *x = Ident((char*)malloc(8));\n+  *x = 1;\n+  free_aaa(x);\n+  *x = 2;\n+}\n+}\n+\n+TEST(AddressSanitizer, UseThenFreeThenUseTest) {\n+  EXPECT_DEATH(UseThenFreeThenUse(), \"freed by thread\");\n+}\n+\n+TEST(AddressSanitizer, StrDupTest) {\n+  free(strdup(Ident(\"123\")));\n+}\n+\n+// Currently we create and poison redzone at right of global variables.\n+char glob5[5];\n+static char static110[110];\n+const char ConstGlob[7] = {1, 2, 3, 4, 5, 6, 7};\n+static const char StaticConstGlob[3] = {9, 8, 7};\n+extern int GlobalsTest(int x);\n+\n+TEST(AddressSanitizer, GlobalTest) {\n+  static char func_static15[15];\n+\n+  static char fs1[10];\n+  static char fs2[10];\n+  static char fs3[10];\n+\n+  glob5[Ident(0)] = 0;\n+  glob5[Ident(1)] = 0;\n+  glob5[Ident(2)] = 0;\n+  glob5[Ident(3)] = 0;\n+  glob5[Ident(4)] = 0;\n+\n+  EXPECT_DEATH(glob5[Ident(5)] = 0,\n+               \"0 bytes to the right of global variable.*glob5.* size 5\");\n+  EXPECT_DEATH(glob5[Ident(5+6)] = 0,\n+               \"6 bytes to the right of global variable.*glob5.* size 5\");\n+  Ident(static110);  // avoid optimizations\n+  static110[Ident(0)] = 0;\n+  static110[Ident(109)] = 0;\n+  EXPECT_DEATH(static110[Ident(110)] = 0,\n+               \"0 bytes to the right of global variable\");\n+  EXPECT_DEATH(static110[Ident(110+7)] = 0,\n+               \"7 bytes to the right of global variable\");\n+\n+  Ident(func_static15);  // avoid optimizations\n+  func_static15[Ident(0)] = 0;\n+  EXPECT_DEATH(func_static15[Ident(15)] = 0,\n+               \"0 bytes to the right of global variable\");\n+  EXPECT_DEATH(func_static15[Ident(15 + 9)] = 0,\n+               \"9 bytes to the right of global variable\");\n+\n+  Ident(fs1);\n+  Ident(fs2);\n+  Ident(fs3);\n+\n+  // We don't create left redzones, so this is not 100% guaranteed to fail.\n+  // But most likely will.\n+  EXPECT_DEATH(fs2[Ident(-1)] = 0, \"is located.*of global variable\");\n+\n+  EXPECT_DEATH(Ident(Ident(ConstGlob)[8]),\n+               \"is located 1 bytes to the right of .*ConstGlob\");\n+  EXPECT_DEATH(Ident(Ident(StaticConstGlob)[5]),\n+               \"is located 2 bytes to the right of .*StaticConstGlob\");\n+\n+  // call stuff from another file.\n+  GlobalsTest(0);\n+}\n+\n+TEST(AddressSanitizer, GlobalStringConstTest) {\n+  static const char *zoo = \"FOOBAR123\";\n+  const char *p = Ident(zoo);\n+  EXPECT_DEATH(Ident(p[15]), \"is ascii string 'FOOBAR123'\");\n+}\n+\n+TEST(AddressSanitizer, FileNameInGlobalReportTest) {\n+  static char zoo[10];\n+  const char *p = Ident(zoo);\n+  // The file name should be present in the report.\n+  EXPECT_DEATH(Ident(p[15]), \"zoo.*asan_test.cc\");\n+}\n+\n+int *ReturnsPointerToALocalObject() {\n+  int a = 0;\n+  return Ident(&a);\n+}\n+\n+#if ASAN_UAR == 1\n+TEST(AddressSanitizer, LocalReferenceReturnTest) {\n+  int *(*f)() = Ident(ReturnsPointerToALocalObject);\n+  int *p = f();\n+  // Call 'f' a few more times, 'p' should still be poisoned.\n+  for (int i = 0; i < 32; i++)\n+    f();\n+  EXPECT_DEATH(*p = 1, \"AddressSanitizer: stack-use-after-return\");\n+  EXPECT_DEATH(*p = 1, \"is located.*in frame .*ReturnsPointerToALocal\");\n+}\n+#endif\n+\n+template <int kSize>\n+NOINLINE static void FuncWithStack() {\n+  char x[kSize];\n+  Ident(x)[0] = 0;\n+  Ident(x)[kSize-1] = 0;\n+}\n+\n+static void LotsOfStackReuse() {\n+  int LargeStack[10000];\n+  Ident(LargeStack)[0] = 0;\n+  for (int i = 0; i < 10000; i++) {\n+    FuncWithStack<128 * 1>();\n+    FuncWithStack<128 * 2>();\n+    FuncWithStack<128 * 4>();\n+    FuncWithStack<128 * 8>();\n+    FuncWithStack<128 * 16>();\n+    FuncWithStack<128 * 32>();\n+    FuncWithStack<128 * 64>();\n+    FuncWithStack<128 * 128>();\n+    FuncWithStack<128 * 256>();\n+    FuncWithStack<128 * 512>();\n+    Ident(LargeStack)[0] = 0;\n+  }\n+}\n+\n+TEST(AddressSanitizer, StressStackReuseTest) {\n+  LotsOfStackReuse();\n+}\n+\n+TEST(AddressSanitizer, ThreadedStressStackReuseTest) {\n+  const int kNumThreads = 20;\n+  pthread_t t[kNumThreads];\n+  for (int i = 0; i < kNumThreads; i++) {\n+    PTHREAD_CREATE(&t[i], 0, (void* (*)(void *x))LotsOfStackReuse, 0);\n+  }\n+  for (int i = 0; i < kNumThreads; i++) {\n+    PTHREAD_JOIN(t[i], 0);\n+  }\n+}\n+\n+static void *PthreadExit(void *a) {\n+  pthread_exit(0);\n+  return 0;\n+}\n+\n+TEST(AddressSanitizer, PthreadExitTest) {\n+  pthread_t t;\n+  for (int i = 0; i < 1000; i++) {\n+    PTHREAD_CREATE(&t, 0, PthreadExit, 0);\n+    PTHREAD_JOIN(t, 0);\n+  }\n+}\n+\n+#ifdef __EXCEPTIONS\n+NOINLINE static void StackReuseAndException() {\n+  int large_stack[1000];\n+  Ident(large_stack);\n+  ASAN_THROW(1);\n+}\n+\n+// TODO(kcc): support exceptions with use-after-return.\n+TEST(AddressSanitizer, DISABLED_StressStackReuseAndExceptionsTest) {\n+  for (int i = 0; i < 10000; i++) {\n+    try {\n+    StackReuseAndException();\n+    } catch(...) {\n+    }\n+  }\n+}\n+#endif\n+\n+TEST(AddressSanitizer, MlockTest) {\n+  EXPECT_EQ(0, mlockall(MCL_CURRENT));\n+  EXPECT_EQ(0, mlock((void*)0x12345, 0x5678));\n+  EXPECT_EQ(0, munlockall());\n+  EXPECT_EQ(0, munlock((void*)0x987, 0x654));\n+}\n+\n+struct LargeStruct {\n+  int foo[100];\n+};\n+\n+// Test for bug http://llvm.org/bugs/show_bug.cgi?id=11763.\n+// Struct copy should not cause asan warning even if lhs == rhs.\n+TEST(AddressSanitizer, LargeStructCopyTest) {\n+  LargeStruct a;\n+  *Ident(&a) = *Ident(&a);\n+}\n+\n+ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS\n+static void NoAddressSafety() {\n+  char *foo = new char[10];\n+  Ident(foo)[10] = 0;\n+  delete [] foo;\n+}\n+\n+TEST(AddressSanitizer, AttributeNoAddressSafetyTest) {\n+  Ident(NoAddressSafety)();\n+}\n+\n+// ------------------ demo tests; run each one-by-one -------------\n+// e.g. --gtest_filter=*DemoOOBLeftHigh --gtest_also_run_disabled_tests\n+TEST(AddressSanitizer, DISABLED_DemoThreadedTest) {\n+  ThreadedTestSpawn();\n+}\n+\n+void *SimpleBugOnSTack(void *x = 0) {\n+  char a[20];\n+  Ident(a)[20] = 0;\n+  return 0;\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoStackTest) {\n+  SimpleBugOnSTack();\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoThreadStackTest) {\n+  pthread_t t;\n+  PTHREAD_CREATE(&t, 0, SimpleBugOnSTack, 0);\n+  PTHREAD_JOIN(t, 0);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoUAFLowIn) {\n+  uaf_test<U1>(10, 0);\n+}\n+TEST(AddressSanitizer, DISABLED_DemoUAFLowLeft) {\n+  uaf_test<U1>(10, -2);\n+}\n+TEST(AddressSanitizer, DISABLED_DemoUAFLowRight) {\n+  uaf_test<U1>(10, 10);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoUAFHigh) {\n+  uaf_test<U1>(kLargeMalloc, 0);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOBLeftLow) {\n+  oob_test<U1>(10, -1);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOBLeftHigh) {\n+  oob_test<U1>(kLargeMalloc, -1);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOBRightLow) {\n+  oob_test<U1>(10, 10);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOBRightHigh) {\n+  oob_test<U1>(kLargeMalloc, kLargeMalloc);\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoOOM) {\n+  size_t size = SANITIZER_WORDSIZE == 64 ? (size_t)(1ULL << 40) : (0xf0000000);\n+  printf(\"%p\\n\", malloc(size));\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoDoubleFreeTest) {\n+  DoubleFree();\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoNullDerefTest) {\n+  int *a = 0;\n+  Ident(a)[10] = 0;\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoFunctionStaticTest) {\n+  static char a[100];\n+  static char b[100];\n+  static char c[100];\n+  Ident(a);\n+  Ident(b);\n+  Ident(c);\n+  Ident(a)[5] = 0;\n+  Ident(b)[105] = 0;\n+  Ident(a)[5] = 0;\n+}\n+\n+TEST(AddressSanitizer, DISABLED_DemoTooMuchMemoryTest) {\n+  const size_t kAllocSize = (1 << 28) - 1024;\n+  size_t total_size = 0;\n+  while (true) {\n+    char *x = (char*)malloc(kAllocSize);\n+    memset(x, 0, kAllocSize);\n+    total_size += kAllocSize;\n+    fprintf(stderr, \"total: %ldM %p\\n\", (long)total_size >> 20, x);\n+  }\n+}\n+\n+// http://code.google.com/p/address-sanitizer/issues/detail?id=66\n+TEST(AddressSanitizer, BufferOverflowAfterManyFrees) {\n+  for (int i = 0; i < 1000000; i++) {\n+    delete [] (Ident(new char [8644]));\n+  }\n+  char *x = new char[8192];\n+  EXPECT_DEATH(x[Ident(8192)] = 0, \"AddressSanitizer: heap-buffer-overflow\");\n+  delete [] Ident(x);\n+}\n+\n+#ifdef __APPLE__\n+#include \"asan_mac_test.h\"\n+TEST(AddressSanitizerMac, CFAllocatorDefaultDoubleFree) {\n+  EXPECT_DEATH(\n+      CFAllocatorDefaultDoubleFree(NULL),\n+      \"attempting double-free\");\n+}\n+\n+void CFAllocator_DoubleFreeOnPthread() {\n+  pthread_t child;\n+  PTHREAD_CREATE(&child, NULL, CFAllocatorDefaultDoubleFree, NULL);\n+  PTHREAD_JOIN(child, NULL);  // Shouldn't be reached.\n+}\n+\n+TEST(AddressSanitizerMac, CFAllocatorDefaultDoubleFree_ChildPhread) {\n+  EXPECT_DEATH(CFAllocator_DoubleFreeOnPthread(), \"attempting double-free\");\n+}\n+\n+namespace {\n+\n+void *GLOB;\n+\n+void *CFAllocatorAllocateToGlob(void *unused) {\n+  GLOB = CFAllocatorAllocate(NULL, 100, /*hint*/0);\n+  return NULL;\n+}\n+\n+void *CFAllocatorDeallocateFromGlob(void *unused) {\n+  char *p = (char*)GLOB;\n+  p[100] = 'A';  // ASan should report an error here.\n+  CFAllocatorDeallocate(NULL, GLOB);\n+  return NULL;\n+}\n+\n+void CFAllocator_PassMemoryToAnotherThread() {\n+  pthread_t th1, th2;\n+  PTHREAD_CREATE(&th1, NULL, CFAllocatorAllocateToGlob, NULL);\n+  PTHREAD_JOIN(th1, NULL);\n+  PTHREAD_CREATE(&th2, NULL, CFAllocatorDeallocateFromGlob, NULL);\n+  PTHREAD_JOIN(th2, NULL);\n+}\n+\n+TEST(AddressSanitizerMac, CFAllocator_PassMemoryToAnotherThread) {\n+  EXPECT_DEATH(CFAllocator_PassMemoryToAnotherThread(),\n+               \"heap-buffer-overflow\");\n+}\n+\n+}  // namespace\n+\n+// TODO(glider): figure out whether we still need these tests. Is it correct\n+// to intercept the non-default CFAllocators?\n+TEST(AddressSanitizerMac, DISABLED_CFAllocatorSystemDefaultDoubleFree) {\n+  EXPECT_DEATH(\n+      CFAllocatorSystemDefaultDoubleFree(),\n+      \"attempting double-free\");\n+}\n+\n+// We're intercepting malloc, so kCFAllocatorMalloc is routed to ASan.\n+TEST(AddressSanitizerMac, CFAllocatorMallocDoubleFree) {\n+  EXPECT_DEATH(CFAllocatorMallocDoubleFree(), \"attempting double-free\");\n+}\n+\n+TEST(AddressSanitizerMac, DISABLED_CFAllocatorMallocZoneDoubleFree) {\n+  EXPECT_DEATH(CFAllocatorMallocZoneDoubleFree(), \"attempting double-free\");\n+}\n+\n+TEST(AddressSanitizerMac, GCDDispatchAsync) {\n+  // Make sure the whole ASan report is printed, i.e. that we don't die\n+  // on a CHECK.\n+  EXPECT_DEATH(TestGCDDispatchAsync(), \"Shadow byte and word\");\n+}\n+\n+TEST(AddressSanitizerMac, GCDDispatchSync) {\n+  // Make sure the whole ASan report is printed, i.e. that we don't die\n+  // on a CHECK.\n+  EXPECT_DEATH(TestGCDDispatchSync(), \"Shadow byte and word\");\n+}\n+\n+\n+TEST(AddressSanitizerMac, GCDReuseWqthreadsAsync) {\n+  // Make sure the whole ASan report is printed, i.e. that we don't die\n+  // on a CHECK.\n+  EXPECT_DEATH(TestGCDReuseWqthreadsAsync(), \"Shadow byte and word\");\n+}\n+\n+TEST(AddressSanitizerMac, GCDReuseWqthreadsSync) {\n+  // Make sure the whole ASan report is printed, i.e. that we don't die\n+  // on a CHECK.\n+  EXPECT_DEATH(TestGCDReuseWqthreadsSync(), \"Shadow byte and word\");\n+}\n+\n+TEST(AddressSanitizerMac, GCDDispatchAfter) {\n+  // Make sure the whole ASan report is printed, i.e. that we don't die\n+  // on a CHECK.\n+  EXPECT_DEATH(TestGCDDispatchAfter(), \"Shadow byte and word\");\n+}\n+\n+TEST(AddressSanitizerMac, GCDSourceEvent) {\n+  // Make sure the whole ASan report is printed, i.e. that we don't die\n+  // on a CHECK.\n+  EXPECT_DEATH(TestGCDSourceEvent(), \"Shadow byte and word\");\n+}\n+\n+TEST(AddressSanitizerMac, GCDSourceCancel) {\n+  // Make sure the whole ASan report is printed, i.e. that we don't die\n+  // on a CHECK.\n+  EXPECT_DEATH(TestGCDSourceCancel(), \"Shadow byte and word\");\n+}\n+\n+TEST(AddressSanitizerMac, GCDGroupAsync) {\n+  // Make sure the whole ASan report is printed, i.e. that we don't die\n+  // on a CHECK.\n+  EXPECT_DEATH(TestGCDGroupAsync(), \"Shadow byte and word\");\n+}\n+\n+void *MallocIntrospectionLockWorker(void *_) {\n+  const int kNumPointers = 100;\n+  int i;\n+  void *pointers[kNumPointers];\n+  for (i = 0; i < kNumPointers; i++) {\n+    pointers[i] = malloc(i + 1);\n+  }\n+  for (i = 0; i < kNumPointers; i++) {\n+    free(pointers[i]);\n+  }\n+\n+  return NULL;\n+}\n+\n+void *MallocIntrospectionLockForker(void *_) {\n+  pid_t result = fork();\n+  if (result == -1) {\n+    perror(\"fork\");\n+  }\n+  assert(result != -1);\n+  if (result == 0) {\n+    // Call malloc in the child process to make sure we won't deadlock.\n+    void *ptr = malloc(42);\n+    free(ptr);\n+    exit(0);\n+  } else {\n+    // Return in the parent process.\n+    return NULL;\n+  }\n+}\n+\n+TEST(AddressSanitizerMac, MallocIntrospectionLock) {\n+  // Incorrect implementation of force_lock and force_unlock in our malloc zone\n+  // will cause forked processes to deadlock.\n+  // TODO(glider): need to detect that none of the child processes deadlocked.\n+  const int kNumWorkers = 5, kNumIterations = 100;\n+  int i, iter;\n+  for (iter = 0; iter < kNumIterations; iter++) {\n+    pthread_t workers[kNumWorkers], forker;\n+    for (i = 0; i < kNumWorkers; i++) {\n+      PTHREAD_CREATE(&workers[i], 0, MallocIntrospectionLockWorker, 0);\n+    }\n+    PTHREAD_CREATE(&forker, 0, MallocIntrospectionLockForker, 0);\n+    for (i = 0; i < kNumWorkers; i++) {\n+      PTHREAD_JOIN(workers[i], 0);\n+    }\n+    PTHREAD_JOIN(forker, 0);\n+  }\n+}\n+\n+void *TSDAllocWorker(void *test_key) {\n+  if (test_key) {\n+    void *mem = malloc(10);\n+    pthread_setspecific(*(pthread_key_t*)test_key, mem);\n+  }\n+  return NULL;\n+}\n+\n+TEST(AddressSanitizerMac, DISABLED_TSDWorkqueueTest) {\n+  pthread_t th;\n+  pthread_key_t test_key;\n+  pthread_key_create(&test_key, CallFreeOnWorkqueue);\n+  PTHREAD_CREATE(&th, NULL, TSDAllocWorker, &test_key);\n+  PTHREAD_JOIN(th, NULL);\n+  pthread_key_delete(test_key);\n+}\n+\n+// Test that CFStringCreateCopy does not copy constant strings.\n+TEST(AddressSanitizerMac, CFStringCreateCopy) {\n+  CFStringRef str = CFSTR(\"Hello world!\\n\");\n+  CFStringRef str2 = CFStringCreateCopy(0, str);\n+  EXPECT_EQ(str, str2);\n+}\n+\n+TEST(AddressSanitizerMac, NSObjectOOB) {\n+  // Make sure that our allocators are used for NSObjects.\n+  EXPECT_DEATH(TestOOBNSObjects(), \"heap-buffer-overflow\");\n+}\n+\n+// Make sure that correct pointer is passed to free() when deallocating a\n+// NSURL object.\n+// See http://code.google.com/p/address-sanitizer/issues/detail?id=70.\n+TEST(AddressSanitizerMac, NSURLDeallocation) {\n+  TestNSURLDeallocation();\n+}\n+\n+// See http://code.google.com/p/address-sanitizer/issues/detail?id=109.\n+TEST(AddressSanitizerMac, Mstats) {\n+  malloc_statistics_t stats1, stats2;\n+  malloc_zone_statistics(/*all zones*/NULL, &stats1);\n+  const int kMallocSize = 100000;\n+  void *alloc = Ident(malloc(kMallocSize));\n+  malloc_zone_statistics(/*all zones*/NULL, &stats2);\n+  EXPECT_GT(stats2.blocks_in_use, stats1.blocks_in_use);\n+  EXPECT_GE(stats2.size_in_use - stats1.size_in_use, kMallocSize);\n+  free(alloc);\n+  // Even the default OSX allocator may not change the stats after free().\n+}\n+#endif  // __APPLE__\n+\n+// Test that instrumentation of stack allocations takes into account\n+// AllocSize of a type, and not its StoreSize (16 vs 10 bytes for long double).\n+// See http://llvm.org/bugs/show_bug.cgi?id=12047 for more details.\n+TEST(AddressSanitizer, LongDoubleNegativeTest) {\n+  long double a, b;\n+  static long double c;\n+  memcpy(Ident(&a), Ident(&b), sizeof(long double));\n+  memcpy(Ident(&c), Ident(&b), sizeof(long double));\n+}"}, {"sha": "b039dc8beb2e55258786e4792eb93d1b43ec612b", "filename": "gcc/testsuite/g++.dg/asan/asan_test_config.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_config.h?ref=5c31da80bb95fca8006fe129913d49f71f581f01", "patch": "@@ -0,0 +1,58 @@\n+//===-- asan_test_config.h --------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+//===----------------------------------------------------------------------===//\n+#if !defined(INCLUDED_FROM_ASAN_TEST_UTILS_H)\n+# error \"This file should be included into asan_test_utils.h only\"\n+#endif\n+\n+#ifndef ASAN_TEST_CONFIG_H\n+#define ASAN_TEST_CONFIG_H\n+\n+#include <vector>\n+#include <string>\n+#include <map>\n+\n+#if ASAN_USE_DEJAGNU_GTEST\n+# include \"dejagnu-gtest.h\"\n+#else\n+# include \"gtest/gtest.h\"\n+#endif\n+\n+using std::string;\n+using std::vector;\n+using std::map;\n+\n+#ifndef ASAN_UAR\n+# error \"please define ASAN_UAR\"\n+#endif\n+\n+#ifndef ASAN_HAS_EXCEPTIONS\n+# error \"please define ASAN_HAS_EXCEPTIONS\"\n+#endif\n+\n+#ifndef ASAN_HAS_BLACKLIST\n+# error \"please define ASAN_HAS_BLACKLIST\"\n+#endif\n+\n+#ifndef ASAN_NEEDS_SEGV\n+# error \"please define ASAN_NEEDS_SEGV\"\n+#endif\n+\n+#ifndef ASAN_LOW_MEMORY\n+# define ASAN_LOW_MEMORY 0\n+#endif\n+\n+#ifndef ASAN_AVOID_EXPENSIVE_TESTS\n+# define ASAN_AVOID_EXPENSIVE_TESTS 0\n+#endif\n+\n+#define ASAN_PCRE_DOTALL \"\"\n+\n+#endif  // ASAN_TEST_CONFIG_H"}, {"sha": "a8f9ad8eaf063b6db70e12557a8700fa01be1055", "filename": "gcc/testsuite/g++.dg/asan/asan_test_utils.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h?ref=5c31da80bb95fca8006fe129913d49f71f581f01", "patch": "@@ -0,0 +1,73 @@\n+//===-- asan_test_utils.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef ASAN_TEST_UTILS_H\n+#define ASAN_TEST_UTILS_H\n+\n+#if !defined(ASAN_EXTERNAL_TEST_CONFIG)\n+# define INCLUDED_FROM_ASAN_TEST_UTILS_H\n+# include \"asan_test_config.h\"\n+# undef INCLUDED_FROM_ASAN_TEST_UTILS_H\n+#endif\n+\n+#if defined(_WIN32)\n+typedef unsigned __int8  uint8_t;\n+typedef unsigned __int16 uint16_t;\n+typedef unsigned __int32 uint32_t;\n+typedef unsigned __int64 uint64_t;\n+typedef __int8           int8_t;\n+typedef __int16          int16_t;\n+typedef __int32          int32_t;\n+typedef __int64          int64_t;\n+# define NOINLINE __declspec(noinline)\n+# define USED\n+#else  // defined(_WIN32)\n+# define NOINLINE __attribute__((noinline))\n+# define USED __attribute__((used))\n+#endif  // defined(_WIN32)\n+\n+#if !defined(__has_feature)\n+#define __has_feature(x) 0\n+#endif\n+\n+#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n+# define ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS \\\n+    __attribute__((no_address_safety_analysis))\n+#else\n+# define ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS\n+#endif\n+\n+#if __LP64__ || defined(_WIN64)\n+#  define SANITIZER_WORDSIZE 64\n+#else\n+#  define SANITIZER_WORDSIZE 32\n+#endif\n+\n+// Make the compiler thinks that something is going on there.\n+inline void break_optimization(void *arg) {\n+  __asm__ __volatile__ (\"\" : : \"r\" (arg) : \"memory\");\n+}\n+\n+// This function returns its parameter but in such a way that compiler\n+// can not prove it.\n+template<class T>\n+NOINLINE\n+static T Ident(T t) {\n+  T ret = t;\n+  break_optimization(&ret);\n+  return ret;\n+}\n+\n+// Check that pthread_create/pthread_join return success.\n+#define PTHREAD_CREATE(a, b, c, d) ASSERT_EQ(0, pthread_create(a, b, c, d))\n+#define PTHREAD_JOIN(a, b) ASSERT_EQ(0, pthread_join(a, b))\n+\n+#endif  // ASAN_TEST_UTILS_H"}, {"sha": "9cc7fc06fc112b5e858eedad901632457102cbb9", "filename": "gcc/testsuite/g++.dg/asan/dejagnu-gtest.h", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdejagnu-gtest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdejagnu-gtest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdejagnu-gtest.h?ref=5c31da80bb95fca8006fe129913d49f71f581f01", "patch": "@@ -0,0 +1,115 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#ifdef __cplusplus\n+#include <string>\n+#endif\n+\n+struct dejagnu_gtest_test\n+{\n+  const char *name;\n+  void (*fn) (void);\n+  struct dejagnu_gtest_test *next;  \n+};\n+struct dejagnu_gtest_test *dejagnu_gtest_test_first, *dejagnu_gtest_test_last;\n+int dejagnu_gtest_test_death_num, dejagnu_gtest_test_death_cur_num;\n+\n+#define TEST(cond, name) \\\n+static void cond##_##name##_fn (void);\t\t\t\t\\\n+static struct dejagnu_gtest_test cond##_##name##_struct\t\t\\\n+  = { #cond \"_\" #name, cond##_##name##_fn, NULL };\t\t\\\n+static __attribute__((__constructor__)) void\t\t\t\\\n+cond##_##name##_ctor (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (strncmp (#name, \"DISABLED_\", 9) == 0)\t\t\t\\\n+    return;\t\t\t\t\t\t\t\\\n+  if (dejagnu_gtest_test_first == NULL)\t\t\t\t\\\n+    dejagnu_gtest_test_first = &cond##_##name##_struct;\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    dejagnu_gtest_test_last->next = &cond##_##name##_struct;\t\\\n+  dejagnu_gtest_test_last = &cond##_##name##_struct;\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+static void\t\t\t\t\t\t\t\\\n+cond##_##name##_fn (void)\n+\n+#ifndef __cplusplus\n+# define DEJAGNU_GTEST_TOCSTR(regex) (regex)\n+#else\n+static inline const char *DEJAGNU_GTEST_TOCSTR(const char *x) { return x; }\n+static inline const char *DEJAGNU_GTEST_TOCSTR(const std::string &x) { return x.c_str (); }\n+#endif\n+\n+#define EXPECT_DEATH(statement, regex) \\\n+do\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    ++dejagnu_gtest_test_death_cur_num;\t\t\t\t\\\n+    if (dejagnu_gtest_test_death_num == 0)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (stderr, \"DEJAGNU_GTEST_EXPECT_DEATH%d %s \"\t\\\n+\t\t\t \"DEJAGNU_GTEST_EXPECT_DEATH%d %s \"\t\\\n+\t\t\t \"DEJAGNU_GTEST_EXPECT_DEATH%d\\n\",\t\\\n+\t\t dejagnu_gtest_test_death_cur_num, #statement,\t\\\n+\t\t dejagnu_gtest_test_death_cur_num,\t\t\\\n+\t\t DEJAGNU_GTEST_TOCSTR (regex),\t\t\t\\\n+\t\t dejagnu_gtest_test_death_cur_num);\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else if (dejagnu_gtest_test_death_cur_num\t\t\t\\\n+\t     == dejagnu_gtest_test_death_num)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tstatement;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#define EXPECT_TRUE(condition) \\\n+  if (!(condition))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (stderr, \"EXPECT_TRUE failed: \" #condition \"\\n\");\t\\\n+      exit (1);\t\t\t\t\t\t\t\\\n+    }\n+#define EXPECT_FALSE(condition) EXPECT_TRUE (!condition)\n+#define EXPECT_EQ(expected, actual) EXPECT_TRUE ((expected) == (actual))\n+#define EXPECT_NE(expected, actual) EXPECT_TRUE ((expected) != (actual))\n+#define EXPECT_LT(expected, actual) EXPECT_TRUE ((expected) < (actual))\n+#define EXPECT_LE(expected, actual) EXPECT_TRUE ((expected) <= (actual))\n+#define EXPECT_GT(expected, actual) EXPECT_TRUE ((expected) > (actual))\n+#define EXPECT_GE(expected, actual) EXPECT_TRUE ((expected) >= (actual))\n+#define ASSERT_DEATH(statement, regex) EXPECT_DEATH (statement, regex)\n+#define ASSERT_TRUE(condition) EXPECT_TRUE (condition)\n+#define ASSERT_FALSE(condition) EXPECT_FALSE (condition)\n+#define ASSERT_EQ(expected, actual) EXPECT_EQ (expected, actual)\n+#define ASSERT_NE(expected, actual) EXPECT_NE (expected, actual)\n+#define ASSERT_LT(expected, actual) EXPECT_LT (expected, actual)\n+#define ASSERT_LE(expected, actual) EXPECT_LE (expected, actual)\n+#define ASSERT_GT(expected, actual) EXPECT_GT (expected, actual)\n+#define ASSERT_GE(expected, actual) EXPECT_GE (expected, actual)\n+\n+int\n+main (int argc, const char **argv)\n+{\n+  const char *test = NULL;\n+  struct dejagnu_gtest_test *t;\n+  if (argc > 1)\n+    test = argv[1];\n+  else\n+    test = getenv (\"DEJAGNU_GTEST_ARG\");\n+  if (test == NULL)\n+    for (t = dejagnu_gtest_test_first; t; t = t->next)\n+      fprintf (stderr, \"DEJAGNU_GTEST_TEST %s\\n\", t->name);\n+  else\n+    {\n+      const char *p = strchr (test, ':');\n+      if (p != NULL)\n+\tdejagnu_gtest_test_death_num = atoi (p + 1);\n+      for (t = dejagnu_gtest_test_first; t; t = t->next)\n+\tif (p != NULL\n+\t    ? (strncmp (test, t->name, p - test) == 0\n+\t       && t->name[p - test] == '\\0')\n+\t    : (strcmp (test, t->name) == 0))\n+\t  break;\n+      EXPECT_TRUE (t != NULL);\n+      t->fn ();\n+    }\n+  return 0;\n+}"}, {"sha": "925f19463a767d485b7b33f73a1aa441b2a49217", "filename": "gcc/testsuite/lib/asan-dg.exp", "status": "modified", "additions": 125, "deletions": 2, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Flib%2Fasan-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c31da80bb95fca8006fe129913d49f71f581f01/gcc%2Ftestsuite%2Flib%2Fasan-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fasan-dg.exp?ref=5c31da80bb95fca8006fe129913d49f71f581f01", "patch": "@@ -118,14 +118,14 @@ proc asan_symbolize { output } {\n \tset addr2line_name [find_binutils_prog addr2line]\n \tset idx 1\n \twhile { $idx < [llength $addresses] } {\n-\t    set key [lindex $addresses $idx]\n+\t    set key [regsub -all \"\\[\\]\\[\\]\" [lindex $addresses $idx] \"\\\\\\\\&\"]\n \t    set val [lindex $addresses [expr $idx + 1]]\n \t    lappend arr($key) $val\n \t    set idx [expr $idx + 3]\n \t}\n \tforeach key [array names arr] {\n \t    set args \"-f -e $key $arr($key)\"\n-\t    set status [remote_exec host \"$addr2line_name\" $args]\n+\t    set status [remote_exec host \"$addr2line_name\" \"$args\"]\n \t    if { [lindex $status 0] > 0 } continue\n \t    regsub -all \"\\r\\n\" [lindex $status 1] \"\\n\" addr2line_output\n \t    regsub -all \"\\[\\n\\r\\]BFD: \\[^\\n\\r\\]*\" $addr2line_output \"\" addr2line_output\n@@ -164,17 +164,140 @@ proc asan_symbolize { output } {\n     return \"$output\"\n }\n \n+# Return a list of gtest tests, printed in the form\n+# DEJAGNU_GTEST_TEST AddressSanitizer_SimpleDeathTest\n+# DEJAGNU_GTEST_TEST AddressSanitizer_VariousMallocsTest\n+proc asan_get_gtest_test_list { output } {\n+    set idx 0\n+    set ret \"\"\n+    while {[regexp -start $idx -indices \"DEJAGNU_GTEST_TEST (\\[^\\n\\r\\]*)(\\r\\n|\\n|\\r)\" \"$output\" -> testname] > 0} {\n+\tset low [lindex $testname 0]\n+\tset high [lindex $testname 1]\n+\tset val [string range \"$output\" $low $high]\n+\tlappend ret $val\n+\tset idx [expr $high + 1]\n+    }\n+    return $ret\n+}\n+\n+# Return a list of gtest EXPECT_DEATH tests, printed in the form\n+# DEJAGNU_GTEST_EXPECT_DEATH1 statement DEJAGNU_GTEST_EXPECT_DEATH1 regexp DEJAGNU_GTEST_EXPECT_DEATH1\n+# DEJAGNU_GTEST_EXPECT_DEATH2 other statement DEJAGNU_GTEST_EXPECT_DEATH2 other regexp DEJAGNU_GTEST_EXPECT_DEATH2\n+proc asan_get_gtest_expect_death_list { output } {\n+    set idx 0\n+    set ret \"\"\n+    while {[regexp -start $idx -indices \"DEJAGNU_GTEST_EXPECT_DEATH(\\[0-9\\]*)\" \"$output\" -> id ] > 0} {\n+\tset low [lindex $id 0]\n+\tset high [lindex $id 1]\n+\tset val_id [string range \"$output\" $low $high]\n+\tif {[regexp -start $low -indices \"$val_id (.*) DEJAGNU_GTEST_EXPECT_DEATH$val_id (.*) DEJAGNU_GTEST_EXPECT_DEATH$val_id\\[\\n\\r\\]\" \"$output\" whole statement regexpr ] == 0} { break }\n+\tset low [lindex $statement 0]\n+\tset high [lindex $statement 1]\n+\tset val_statement [string range \"$output\" $low $high]\n+\tset low [lindex $regexpr 0]\n+\tset high [lindex $regexpr 1]\n+\tset val_regexpr [string range \"$output\" $low $high]\n+\tlappend ret [list \"$val_id\" \"$val_statement\" \"$val_regexpr\"]\n+\tset idx [lindex $whole 1]\n+    }\n+    return $ret\n+}\n+\n # Replace ${tool}_load with a wrapper so that we can symbolize the output.\n if { [info procs ${tool}_load] != [list] \\\n       && [info procs saved_asan_${tool}_load] == [list] } {\n     rename ${tool}_load saved_asan_${tool}_load\n \n     proc ${tool}_load { program args } {\n \tglobal tool\n+\tglobal asan_last_gtest_test_list\n+\tglobal asan_last_gtest_expect_death_list\n \tset result [eval [list saved_asan_${tool}_load $program] $args]\n \tset output [lindex $result 1]\n \tset symbolized_output [asan_symbolize \"$output\"]\n+\tset asan_last_gtest_test_list [asan_get_gtest_test_list \"$output\"]\n+\tset asan_last_gtest_expect_death_list [asan_get_gtest_expect_death_list \"$output\"]\n \tset result [list [lindex $result 0] $symbolized_output]\n \treturn $result\n     }\n }\n+\n+# Utility for running gtest asan emulation under dejagnu, invoked via dg-final.\n+# Call pass if variable has the desired value, otherwise fail.\n+#\n+# Argument 0 handles expected failures and the like\n+proc asan-gtest { args } {\n+    global tool\n+    global asan_last_gtest_test_list\n+    global asan_last_gtest_expect_death_list\n+\n+    if { ![info exists asan_last_gtest_test_list] } { return }\n+    if { [llength $asan_last_gtest_test_list] == 0 } { return }\n+    if { ![isnative] || [is_remote target] } { return }\n+\n+    set gtest_test_list $asan_last_gtest_test_list\n+    unset asan_last_gtest_test_list\n+\n+    if { [llength $args] >= 1 } {\n+\tswitch [dg-process-target [lindex $args 0]] {\n+\t    \"S\" { }\n+\t    \"N\" { return }\n+\t    \"F\" { setup_xfail \"*-*-*\" }\n+\t    \"P\" { }\n+\t}\n+    }\n+\n+    # This assumes that we are three frames down from dg-test, and that\n+    # it still stores the filename of the testcase in a local variable \"name\".\n+    # A cleaner solution would require a new DejaGnu release.\n+    upvar 2 name testcase\n+    upvar 2 prog prog\n+\n+    set output_file \"[file rootname [file tail $prog]].exe\"\n+\n+    foreach gtest $gtest_test_list {\n+\tset testname \"$testcase $gtest\"\n+\tset status -1\n+\n+\tsetenv DEJAGNU_GTEST_ARG \"$gtest\"\n+\tset result [${tool}_load ./$output_file $gtest]\n+\tunsetenv DEJAGNU_GTEST_ARG\n+\tset status [lindex $result 0]\n+\tset output [lindex $result 1]\n+\tif { \"$status\" == \"pass\" } {\n+\t    pass \"$testname execution test\"\n+\t    if { [info exists asan_last_gtest_expect_death_list] } {\n+\t\tset gtest_expect_death_list $asan_last_gtest_expect_death_list\n+\t\tforeach gtest_death $gtest_expect_death_list {\n+\t\t    set id [lindex $gtest_death 0]\n+\t\t    set testname \"$testcase $gtest [lindex $gtest_death 1]\"\n+\t\t    set regexpr [lindex $gtest_death 2]\n+\t\t    set status -1\n+\n+\t\t    setenv DEJAGNU_GTEST_ARG \"$gtest:$id\"\n+\t\t    set result [${tool}_load ./$output_file \"$gtest:$id\"]\n+\t\t    unsetenv DEJAGNU_GTEST_ARG\n+\t\t    set status [lindex $result 0]\n+\t\t    set output [lindex $result 1]\n+\t\t    if { \"$status\" == \"fail\" } {\n+\t\t\tpass \"$testname execution test\"\n+\t\t\tif { ![regexp $regexpr ${output}] } {\n+\t\t\t    fail \"$testname output pattern test, should match $regexpr\"\n+\t\t\t} else {\n+\t\t\t    pass \"$testname output pattern test, $regexpr\"\n+\t\t\t}\n+\t\t    } elseif { \"$status\" == \"pass\" } {\n+\t\t\tfail \"$testname execution test\"\n+\t\t    } else {\n+\t\t\t$status \"$testname execution test\"\n+\t\t    }\n+\t\t}\n+\t    }\n+\t} else {\n+\t    $status \"$testname execution test\"\n+\t}\n+\tunset asan_last_gtest_expect_death_list\n+    }\n+\n+    return\n+}"}]}