{"sha": "f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ3ZTliNGViZjdlZTU5ODNjMmU1YjM2ODE2ZWVmNjJhOWU0NjFkMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-01T23:22:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-01T23:22:24Z"}, "message": "alias.c (get_alias_set): Try to replace PLACEHOLDER_EXPR.\n\n\t* alias.c (get_alias_set): Try to replace PLACEHOLDER_EXPR.\n\tLoop through NOPs, placeholders, and components.\n\tDon't go through NOPs if change mode.\n\t(record_alias_subset): Do nothing if SUBSET and SET are the same.\n\t* emit-rtl.c (set_mem_alias_set): Enable check.\n\t* expr.c (find_placeholder): New function.\n\t(expand_expr, case PLACEHOLDER_EXPR): Use it.\n\t(expand_expr, case COMPONENT_EXPR): Always copy OP0 when we need\n\tto modify it and avoid unneeded copies.\n\t* expr.h (expand_expr): Always define.\n\t(find_placeholder): New declaration.\n\nFrom-SVN: r45931", "tree": {"sha": "acaf47bae1cbf1fc574dc450a9f1449a4afad567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acaf47bae1cbf1fc574dc450a9f1449a4afad567"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/comments", "author": null, "committer": null, "parents": [{"sha": "477946a63dee474c725243ae0d998f4cba1bfc0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477946a63dee474c725243ae0d998f4cba1bfc0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477946a63dee474c725243ae0d998f4cba1bfc0a"}], "stats": {"total": 225, "additions": 138, "deletions": 87}, "files": [{"sha": "1762d1ebcdc3514fcbed1b252598ca0c71ea0ef8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "patch": "@@ -1,3 +1,17 @@\n+Mon Oct  1 19:20:57 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (get_alias_set): Try to replace PLACEHOLDER_EXPR.\n+\tLoop through NOPs, placeholders, and components.\n+\tDon't go through NOPs if change mode.\n+\t(record_alias_subset): Do nothing if SUBSET and SET are the same.\n+\t* emit-rtl.c (set_mem_alias_set): Enable check.\n+\t* expr.c (find_placeholder): New function.\n+\t(expand_expr, case PLACEHOLDER_EXPR): Use it.\n+\t(expand_expr, case COMPONENT_EXPR): Always copy OP0 when we need\n+\tto modify it and avoid unneeded copies.\n+\t* expr.h (expand_expr): Always define.\n+\t(find_placeholder): New declaration.\n+\n 2001-10-01  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.md (\"add-split\"): Fix add split when"}, {"sha": "37a8790c2eeb5323133fdc57892c699edf230f50", "filename": "gcc/alias.c", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "patch": "@@ -470,32 +470,42 @@ get_alias_set (t)\n     return 0;\n \n   /* We can be passed either an expression or a type.  This and the\n-     language-specific routine may make mutually-recursive calls to\n-     each other to figure out what to do.  At each juncture, we see if\n-     this is a tree that the language may need to handle specially.\n-     First handle things that aren't types and start by removing nops\n-     since we care only about the actual object.  */\n+     language-specific routine may make mutually-recursive calls to each other\n+     to figure out what to do.  At each juncture, we see if this is a tree\n+     that the language may need to handle specially.  First handle things that\n+     aren't types and start by removing nops since we care only about the\n+     actual object.  Also replace PLACEHOLDER_EXPRs and pick up the outermost\n+     object that we could have a pointer to.  */\n   if (! TYPE_P (t))\n     {\n-      while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n-\t     || TREE_CODE (t) == NON_LVALUE_EXPR)\n-\tt = TREE_OPERAND (t, 0);\n+      /* Remove any NOPs and see what any PLACEHOLD_EXPRs will expand to.  */\n+      while (((TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR)\n+\t      && (TYPE_MODE (TREE_TYPE (t))\n+\t\t  == TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 0)))))\n+\t     || TREE_CODE (t) == NON_LVALUE_EXPR\n+\t     || TREE_CODE (t) == PLACEHOLDER_EXPR\n+\t     || (handled_component_p (t) && ! can_address_p (t)))\n+\t{\n+\t  /* Give the language a chance to do something with this tree\n+\t     before we go inside it.  */\n+\t  if ((set = lang_get_alias_set (t)) != -1)\n+\t    return set;\n+\n+\t  if (TREE_CODE (t) == PLACEHOLDER_EXPR)\n+\t    t = find_placeholder (t, 0);\n+\t  else\n+\t    t = TREE_OPERAND (t, 0);\n+\t}\n \n       /* Now give the language a chance to do something but record what we\n \t gave it this time.  */\n       orig_t = t;\n       if ((set = lang_get_alias_set (t)) != -1)\n \treturn set;\n \n-      /* Now loop the same way as get_inner_reference and get the alias\n-\t set to use.  Pick up the outermost object that we could have\n-\t a pointer to.  */\n-      while (handled_component_p (t) && ! can_address_p (t))\n-\tt = TREE_OPERAND (t, 0);\n-\n+      /* Check for accesses through restrict-qualified pointers.  */\n       if (TREE_CODE (t) == INDIRECT_REF)\n \t{\n-\t  /* Check for accesses through restrict-qualified pointers.  */\n \t  tree decl = find_base_decl (TREE_OPERAND (t, 0));\n \n \t  if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n@@ -587,6 +597,11 @@ record_alias_subset (superset, subset)\n   alias_set_entry superset_entry;\n   alias_set_entry subset_entry;\n \n+  /* It is possible in complex type situations for both sets to be the same,\n+     in which case we can ignore this operation.  */\n+  if (superset == subset)\n+    return;\n+\n   if (superset == 0)\n     abort ();\n "}, {"sha": "ea0eef2c29bd8658cab6fbe568f324cde86882fe", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "patch": "@@ -1716,12 +1716,10 @@ set_mem_alias_set (mem, set)\n      HOST_WIDE_INT set;\n {\n   /* It would be nice to enable this check, but we can't quite yet.  */\n-#if 0\n #ifdef ENABLE_CHECKING\t\n   /* If the new and old alias sets don't conflict, something is wrong.  */\n   if (!alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)))\n     abort ();\n-#endif\n #endif\n \n   MEM_ATTRS (mem) = get_mem_attrs (set, MEM_DECL (mem), MEM_OFFSET (mem),"}, {"sha": "52f9cc0f2e002893f33c95b895d285695f816f23", "filename": "gcc/expr.c", "status": "modified", "additions": 86, "deletions": 68, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "patch": "@@ -5955,6 +5955,69 @@ check_max_integer_computation_mode (exp)\n }\n #endif\n \f\n+/* Return an object on the placeholder list that matches EXP, a\n+   PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n+   PLACEHOLDER_EXPR or a pointer type to it.  For further information,\n+   see tree.def.  If no such object is found, abort.  If PLIST is nonzero,\n+   it is a location into which a pointer into the placeholder list at\n+   which the object is found is placed.  */\n+\n+tree\n+find_placeholder (exp, plist)\n+     tree exp;\n+     tree *plist;\n+{\n+  tree type = TREE_TYPE (exp);\n+  tree placeholder_expr;\n+\n+  for (placeholder_expr = placeholder_list; placeholder_expr != 0;\n+       placeholder_expr = TREE_CHAIN (placeholder_expr))\n+    {\n+      tree need_type = TYPE_MAIN_VARIANT (type);\n+      tree elt;\n+\n+      /* Find the outermost reference that is of the type we want.  If none,\n+\t see if any object has a type that is a pointer to the type we\n+\t want.  */\n+      for (elt = TREE_PURPOSE (placeholder_expr); elt != 0;\n+\t   elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n+\t\t   || TREE_CODE (elt) == COND_EXPR)\n+\t\t  ? TREE_OPERAND (elt, 1)\n+\t\t  : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n+\t\t  ? TREE_OPERAND (elt, 0) : 0))\n+\tif (TYPE_MAIN_VARIANT (TREE_TYPE (elt)) == need_type)\n+\t  {\n+\t    if (plist)\n+\t      *plist = placeholder_expr;\n+\t    return elt;\n+\t  }\n+\n+      for (elt = TREE_PURPOSE (placeholder_expr); elt != 0;\n+\t   elt\n+\t   = ((TREE_CODE (elt) == COMPOUND_EXPR\n+\t       || TREE_CODE (elt) == COND_EXPR)\n+\t      ? TREE_OPERAND (elt, 1)\n+\t      : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n+\t\t || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n+\t\t || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n+\t      ? TREE_OPERAND (elt, 0) : 0))\n+\tif (POINTER_TYPE_P (TREE_TYPE (elt))\n+\t    && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (elt)))\n+\t\t== need_type))\n+\t  {\n+\t    if (plist)\n+\t      *plist = placeholder_expr;\n+\t    return build1 (INDIRECT_REF, need_type, elt);\n+\t  }\n+    }\n+\n+  abort ();\n+}\n+\f\n /* expand_expr: generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.\n@@ -6482,66 +6545,14 @@ expand_expr (exp, target, tmode, modifier)\n \n     case PLACEHOLDER_EXPR:\n       {\n+\ttree old_list = placeholder_list;\n \ttree placeholder_expr;\n \n-\t/* If there is an object on the head of the placeholder list,\n-\t   see if some object in it of type TYPE or a pointer to it.  For\n-\t   further information, see tree.def.  */\n-\tfor (placeholder_expr = placeholder_list;\n-\t     placeholder_expr != 0;\n-\t     placeholder_expr = TREE_CHAIN (placeholder_expr))\n-\t  {\n-\t    tree need_type = TYPE_MAIN_VARIANT (type);\n-\t    tree object = 0;\n-\t    tree old_list = placeholder_list;\n-\t    tree elt;\n-\n-\t    /* Find the outermost reference that is of the type we want.\n-\t       If none, see if any object has a type that is a pointer to\n-\t       the type we want.  */\n-\t    for (elt = TREE_PURPOSE (placeholder_expr);\n-\t\t elt != 0 && object == 0;\n-\t\t elt\n-\t\t = ((TREE_CODE (elt) == COMPOUND_EXPR\n-\t\t     || TREE_CODE (elt) == COND_EXPR)\n-\t\t    ? TREE_OPERAND (elt, 1)\n-\t\t    : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n-\t\t    ? TREE_OPERAND (elt, 0) : 0))\n-\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (elt)) == need_type)\n-\t\tobject = elt;\n-\n-\t    for (elt = TREE_PURPOSE (placeholder_expr);\n-\t\t elt != 0 && object == 0;\n-\t\t elt\n-\t\t = ((TREE_CODE (elt) == COMPOUND_EXPR\n-\t\t     || TREE_CODE (elt) == COND_EXPR)\n-\t\t    ? TREE_OPERAND (elt, 1)\n-\t\t    : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n-\t\t    ? TREE_OPERAND (elt, 0) : 0))\n-\t      if (POINTER_TYPE_P (TREE_TYPE (elt))\n-\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (elt)))\n-\t\t      == need_type))\n-\t\tobject = build1 (INDIRECT_REF, need_type, elt);\n-\n-\t    if (object != 0)\n-\t      {\n-\t\t/* Expand this object skipping the list entries before\n-\t\t   it was found in case it is also a PLACEHOLDER_EXPR.\n-\t\t   In that case, we want to translate it using subsequent\n-\t\t   entries.  */\n-\t\tplaceholder_list = TREE_CHAIN (placeholder_expr);\n-\t\ttemp = expand_expr (object, original_target, tmode,\n-\t\t\t\t    ro_modifier);\n-\t\tplaceholder_list = old_list;\n-\t\treturn temp;\n-\t      }\n-\t  }\n+\texp = find_placeholder (exp, &placeholder_expr);\n+\tplaceholder_list = TREE_CHAIN (placeholder_expr);\n+\ttemp = expand_expr (exp, original_target, tmode, ro_modifier);\n+\tplaceholder_list = old_list;\n+\treturn temp;\n       }\n \n       /* We can't find the object or there was a missing WITH_RECORD_EXPR.  */\n@@ -6923,6 +6934,7 @@ expand_expr (exp, target, tmode, modifier)\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n \t\t\t\t\t&mode1, &unsignedp, &volatilep,\n \t\t\t\t\t&alignment);\n+\trtx orig_op0;\n \n \t/* If we got back the original object, something is wrong.  Perhaps\n \t   we are evaluating an expression too early.  In any event, don't\n@@ -6934,15 +6946,16 @@ expand_expr (exp, target, tmode, modifier)\n \t   computation, since it will need a temporary and TARGET is known\n \t   to have to do.  This occurs in unchecked conversion in Ada.  */\n \n-\top0 = expand_expr (tem,\n-\t\t\t   (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n-\t\t\t    && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n-\t\t\t\t!= INTEGER_CST)\n-\t\t\t    ? target : NULL_RTX),\n-\t\t\t   VOIDmode,\n-\t\t\t   (modifier == EXPAND_INITIALIZER\n-\t\t\t    || modifier == EXPAND_CONST_ADDRESS)\n-\t\t\t   ? modifier : EXPAND_NORMAL);\n+\torig_op0 = op0\n+\t  = expand_expr (tem,\n+\t\t\t (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n+\t\t\t  && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n+\t\t\t      != INTEGER_CST)\n+\t\t\t  ? target : NULL_RTX),\n+\t\t\t VOIDmode,\n+\t\t\t (modifier == EXPAND_INITIALIZER\n+\t\t\t  || modifier == EXPAND_CONST_ADDRESS)\n+\t\t\t ? modifier : EXPAND_NORMAL);\n \n \t/* If this is a constant, put it into a register if it is a\n \t   legitimate constant and OFFSET is 0 and memory if it isn't.  */\n@@ -7031,7 +7044,9 @@ expand_expr (exp, target, tmode, modifier)\n \t/* Don't forget about volatility even if this is a bitfield.  */\n \tif (GET_CODE (op0) == MEM && volatilep && ! MEM_VOLATILE_P (op0))\n \t  {\n-\t    op0 = copy_rtx (op0);\n+\t    if (op0 == orig_op0)\n+\t      op0 = copy_rtx (op0);\n+\n \t    MEM_VOLATILE_P (op0) = 1;\n \t  }\n \n@@ -7173,6 +7188,9 @@ expand_expr (exp, target, tmode, modifier)\n \telse\n \t  op0 = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n \n+\tif (op0 == orig_op0)\n+\t  op0 = copy_rtx (op0);\n+\n \tset_mem_attributes (op0, exp, 0);\n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n \t  mark_reg_pointer (XEXP (op0, 0), alignment);"}, {"sha": "62e90b0d211f83d007951581793a891ac00c6368", "filename": "gcc/expr.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=f47e9b4ebf7ee5983c2e5b36816eef62a9e461d1", "patch": "@@ -498,13 +498,19 @@ extern rtx store_expr PARAMS ((tree, rtx, int));\n    Useful after calling expand_expr with 1 as sum_ok.  */\n extern rtx force_operand PARAMS ((rtx, rtx));\n \n-#ifdef TREE_CODE\n+/* Return an object on the placeholder list that matches EXP, a\n+   PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n+   PLACEHOLDER_EXPR or a pointer type to it.  For further information,\n+   see tree.def.  If no such object is found, abort.  If PLIST is nonzero,\n+   it is a location into which a pointer into the placeholder list at\n+   which the object is found is placed.  */\n+extern tree find_placeholder PARAMS ((tree, tree *));\n+\n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.  */\n extern rtx expand_expr PARAMS ((tree, rtx, enum machine_mode,\n \t\t\t\tenum expand_modifier));\n-#endif\n \n /* At the start of a function, record that we have no previously-pushed\n    arguments waiting to be popped.  */"}]}