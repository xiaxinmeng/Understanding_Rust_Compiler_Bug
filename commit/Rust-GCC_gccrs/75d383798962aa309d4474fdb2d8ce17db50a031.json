{"sha": "75d383798962aa309d4474fdb2d8ce17db50a031", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkMzgzNzk4OTYyYWEzMDlkNDQ3NGZkYjJkOGNlMTdkYjUwYTAzMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2002-10-21T20:27:14Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2002-10-21T20:27:14Z"}, "message": "i386.c (x86_64_sign_extended_value): Add allow_rip argument.\n\n\t* config/i386/i386.c (x86_64_sign_extended_value): Add allow_rip\n\targument.  In CM_SMALL_PIC model consider SYMBOL_REFs binding locally or\n\tfrom constant pool or LABEL_REFs as sign extended if allow_rip.\n\tChange all +-1GB limits to +-16MB.\n\t(x86_64_general_operand, x86_64_szext_general_operand,\n\tx86_64_nonmemory_operand, x86_64_movabs_operand,\n\tx86_64_szext_nonmemory_operand, x86_64_immediate_operand,\n\tlegitimate_address_p, ix86_expand_int_movcc): Update callers.\n\t(local_symbolic_operand): Don't allow offsets bigger than +-16MB\n\tin CM_SMALL_PIC model.\n\t(legitimate_pic_address_disp_p): Don't check offsets before\n\tcalling local_symbolic_operand.\n\t(legitimize_pic_address): Force offsets bigger than +-16MB into\n\tregister.\n\t* config/i386/i386.h (EXTRA_CONSTRAINT, CONST_COSTS): Likewise.\n\t* config/i386/i386-protos.h (x86_64_sign_extended_value): Update\n\tprototype.\n\n\t* configure.in: Test for @GOTNTPOFF and @INDNTPOFF on IA-32 too.\n\tAdd x86-64 test.  Set tls_first_minor to 14 on IA-32 and x86-64.\n\t* configure: Rebuilt.\n\t* config/i386/i386.c (x86_64_sign_extended_value): Don't allow TLS\n\tSYMBOL_REFs unless enclosed in UNSPEC.  Handle UNSPEC_DTPOFF,\n\tUNSPEC_GOTNTPOFF and UNSPEC_NTPOFF.\n\t(legitimate_address_p): Allow foo@dtpoff(base) even on TARGET_64BIT\n\t-fpic.\n\t(ix86_encode_section_info): Don't ever generate TLSGD or TLSLD for\n\tnon-pic code if TARGET_64BIT.\n\t(legitimize_address): Generate 64-bit TLS sequences.\n\t(output_pic_addr_const): Support x86-64 TLS operators.\n\t(i386_output_dwarf_dtprel): Output 64-bit DTPOFF as .long f@DTPOFF, 0.\n\t(print_operand_address): Use %fs instead of %gs on TARGET_64BIT.\n\tDon't append (%rip) in 64-bit TLSGD and TLSLD sequences.\n\t(output_addr_const_extra): Support x86-64 TLS operators.\n\t(maybe_get_pool_constant): Handle TARGET_64BIT -fpic.\n\t(ix86_tls_get_addr): Use __tls_get_addr on TARGET_64BIT\n\tunconditionally.\n\t* config/i386/i386.md (*tls_global_dynamic_gnu): Renamed to...\n\t(*tls_global_dynamic_32_gnu): ..., add !TARGET_64BIT.\n\t(*tls_global_dynamic_sun): Renamed to...\n\t(*tls_global_dynamic_32_sun): ..., add !TARGET_64BIT.\n\t(tls_global_dynamic): Renamed to...\n\t(tls_global_dynamic_32): ... this.\n\t(tls_global_dynamic_64, *tls_global_dynamic_64): New.\n\t(*tls_local_dynamic_base_dynamic_gnu): Renamed to...\n\t(*tls_local_dynamic_base_dynamic_32_gnu): ..., add !TARGET_64BIT.\n\t(*tls_local_dynamic_base_dynamic_sun): Renamed to...\n\t(*tls_local_dynamic_base_dynamic_32_sun): ..., add !TARGET_64BIT.\n\t(tls_local_dynamic_base_dynamic): Renamed to...\n\t(tls_local_dynamic_base_dynamic_32): ... this.\n\t(tls_local_dynamic_base_dynamic_64,\n\t*tls_local_dynamic_base_dynamic_64): New.\n\t(*tls_local_dynamic_once): Renamed to...\n\t(*tls_local_dynamic_32_once): ... this.\n\n\t* gcc.dg/tls/pic-1.c: New test.\n\t* gcc.dg/tls/nonpic-1.c: New test.\n\t* gcc.dg/20021018-1.c: New test.\n\nFrom-SVN: r58383", "tree": {"sha": "8129dae3f635ecd64671bae7a5cc5fed11de0036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8129dae3f635ecd64671bae7a5cc5fed11de0036"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75d383798962aa309d4474fdb2d8ce17db50a031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d383798962aa309d4474fdb2d8ce17db50a031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d383798962aa309d4474fdb2d8ce17db50a031", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d383798962aa309d4474fdb2d8ce17db50a031/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59798a0caebd2bec883331f93ae4fa07c69294eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59798a0caebd2bec883331f93ae4fa07c69294eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59798a0caebd2bec883331f93ae4fa07c69294eb"}], "stats": {"total": 577, "additions": 491, "deletions": 86}, "files": [{"sha": "81a7db7c661251fc82b82863406e46356ccf8ffc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -1,3 +1,60 @@\n+2002-10-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/i386/i386.c (x86_64_sign_extended_value): Add allow_rip\n+\targument.  In CM_SMALL_PIC model consider SYMBOL_REFs binding locally or\n+\tfrom constant pool or LABEL_REFs as sign extended if allow_rip.\n+\tChange all +-1GB limits to +-16MB.\n+\t(x86_64_general_operand, x86_64_szext_general_operand,\n+\tx86_64_nonmemory_operand, x86_64_movabs_operand,\n+\tx86_64_szext_nonmemory_operand, x86_64_immediate_operand,\n+\tlegitimate_address_p, ix86_expand_int_movcc): Update callers.\n+\t(local_symbolic_operand): Don't allow offsets bigger than +-16MB\n+\tin CM_SMALL_PIC model.\n+\t(legitimate_pic_address_disp_p): Don't check offsets before\n+\tcalling local_symbolic_operand.\n+\t(legitimize_pic_address): Force offsets bigger than +-16MB into\n+\tregister.\n+\t* config/i386/i386.h (EXTRA_CONSTRAINT, CONST_COSTS): Likewise.\n+\t* config/i386/i386-protos.h (x86_64_sign_extended_value): Update\n+\tprototype.\n+\n+\t* configure.in: Test for @GOTNTPOFF and @INDNTPOFF on IA-32 too.\n+\tAdd x86-64 test.  Set tls_first_minor to 14 on IA-32 and x86-64.\n+\t* configure: Rebuilt.\n+\t* config/i386/i386.c (x86_64_sign_extended_value): Don't allow TLS\n+\tSYMBOL_REFs unless enclosed in UNSPEC.  Handle UNSPEC_DTPOFF,\n+\tUNSPEC_GOTNTPOFF and UNSPEC_NTPOFF.\n+\t(legitimate_address_p): Allow foo@dtpoff(base) even on TARGET_64BIT\n+\t-fpic.\n+\t(ix86_encode_section_info): Don't ever generate TLSGD or TLSLD for\n+\tnon-pic code if TARGET_64BIT.\n+\t(legitimize_address): Generate 64-bit TLS sequences.\n+\t(output_pic_addr_const): Support x86-64 TLS operators.\n+\t(i386_output_dwarf_dtprel): Output 64-bit DTPOFF as .long f@DTPOFF, 0.\n+\t(print_operand_address): Use %fs instead of %gs on TARGET_64BIT.\n+\tDon't append (%rip) in 64-bit TLSGD and TLSLD sequences.\n+\t(output_addr_const_extra): Support x86-64 TLS operators.\n+\t(maybe_get_pool_constant): Handle TARGET_64BIT -fpic.\n+\t(ix86_tls_get_addr): Use __tls_get_addr on TARGET_64BIT\n+\tunconditionally.\n+\t* config/i386/i386.md (*tls_global_dynamic_gnu): Renamed to...\n+\t(*tls_global_dynamic_32_gnu): ..., add !TARGET_64BIT.\n+\t(*tls_global_dynamic_sun): Renamed to...\n+\t(*tls_global_dynamic_32_sun): ..., add !TARGET_64BIT.\n+\t(tls_global_dynamic): Renamed to...\n+\t(tls_global_dynamic_32): ... this.\n+\t(tls_global_dynamic_64, *tls_global_dynamic_64): New.\n+\t(*tls_local_dynamic_base_dynamic_gnu): Renamed to...\n+\t(*tls_local_dynamic_base_dynamic_32_gnu): ..., add !TARGET_64BIT.\n+\t(*tls_local_dynamic_base_dynamic_sun): Renamed to...\n+\t(*tls_local_dynamic_base_dynamic_32_sun): ..., add !TARGET_64BIT.\n+\t(tls_local_dynamic_base_dynamic): Renamed to...\n+\t(tls_local_dynamic_base_dynamic_32): ... this.\n+\t(tls_local_dynamic_base_dynamic_64,\n+\t*tls_local_dynamic_base_dynamic_64): New.\n+\t(*tls_local_dynamic_once): Renamed to...\n+\t(*tls_local_dynamic_32_once): ... this.\n+\n 2002-10-21  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* libgcc2.c: Inline __udiv_w_sdiv when compiling __udivdi3,"}, {"sha": "64dc7b0758dd89a41ba61a9ded5ccf965bbd678b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -153,7 +153,7 @@ extern int ix86_attr_length_address_default PARAMS ((rtx));\n \n extern enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n \n-extern int x86_64_sign_extended_value PARAMS ((rtx));\n+extern int x86_64_sign_extended_value PARAMS ((rtx, int));\n extern int x86_64_zero_extended_value PARAMS ((rtx));\n extern rtx ix86_libcall_value PARAMS ((enum machine_mode));\n extern bool ix86_function_value_regno_p PARAMS ((int));"}, {"sha": "fab61772a192e8fa8f2666d75c379389099753c1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 177, "deletions": 70, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -2877,7 +2877,7 @@ x86_64_general_operand (op, mode)\n     return general_operand (op, mode);\n   if (nonimmediate_operand (op, mode))\n     return 1;\n-  return x86_64_sign_extended_value (op);\n+  return x86_64_sign_extended_value (op, 1);\n }\n \n /* Return nonzero if OP is general operand representable on x86_64\n@@ -2892,7 +2892,7 @@ x86_64_szext_general_operand (op, mode)\n     return general_operand (op, mode);\n   if (nonimmediate_operand (op, mode))\n     return 1;\n-  return x86_64_sign_extended_value (op) || x86_64_zero_extended_value (op);\n+  return x86_64_sign_extended_value (op, 1) || x86_64_zero_extended_value (op);\n }\n \n /* Return nonzero if OP is nonmemory operand representable on x86_64.  */\n@@ -2906,7 +2906,7 @@ x86_64_nonmemory_operand (op, mode)\n     return nonmemory_operand (op, mode);\n   if (register_operand (op, mode))\n     return 1;\n-  return x86_64_sign_extended_value (op);\n+  return x86_64_sign_extended_value (op, 1);\n }\n \n /* Return nonzero if OP is nonmemory operand acceptable by movabs patterns.  */\n@@ -2918,7 +2918,7 @@ x86_64_movabs_operand (op, mode)\n {\n   if (!TARGET_64BIT || !flag_pic)\n     return nonmemory_operand (op, mode);\n-  if (register_operand (op, mode) || x86_64_sign_extended_value (op))\n+  if (register_operand (op, mode) || x86_64_sign_extended_value (op, 0))\n     return 1;\n   if (CONSTANT_P (op) && !symbolic_reference_mentioned_p (op))\n     return 1;\n@@ -2936,7 +2936,7 @@ x86_64_szext_nonmemory_operand (op, mode)\n     return nonmemory_operand (op, mode);\n   if (register_operand (op, mode))\n     return 1;\n-  return x86_64_sign_extended_value (op) || x86_64_zero_extended_value (op);\n+  return x86_64_sign_extended_value (op, 0) || x86_64_zero_extended_value (op);\n }\n \n /* Return nonzero if OP is immediate operand representable on x86_64.  */\n@@ -2948,7 +2948,7 @@ x86_64_immediate_operand (op, mode)\n {\n   if (!TARGET_64BIT)\n     return immediate_operand (op, mode);\n-  return x86_64_sign_extended_value (op);\n+  return x86_64_sign_extended_value (op, 0);\n }\n \n /* Return nonzero if OP is immediate operand representable on x86_64.  */\n@@ -3071,7 +3071,10 @@ local_symbolic_operand (op, mode)\n \n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+      && (ix86_cmodel != CM_SMALL_PIC\n+\t  || (INTVAL (XEXP (XEXP (op, 0), 1)) >= -16*1024*1024\n+\t      && INTVAL (XEXP (XEXP (op, 0), 1)) < 16*1024*1024)))\n     op = XEXP (XEXP (op, 0), 0);\n \n   if (GET_CODE (op) != SYMBOL_REF)\n@@ -3819,8 +3822,9 @@ ix86_can_use_return_insn_p ()\n \f\n /* Return 1 if VALUE can be stored in the sign extended immediate field.  */\n int\n-x86_64_sign_extended_value (value)\n+x86_64_sign_extended_value (value, allow_rip)\n      rtx value;\n+     int allow_rip;\n {\n   switch (GET_CODE (value))\n     {\n@@ -3837,21 +3841,38 @@ x86_64_sign_extended_value (value)\n \t  }\n \tbreak;\n \n-      /* For certain code models, the symbolic references are known to fit.  */\n+      /* For certain code models, the symbolic references are known to fit.\n+\t in CM_SMALL_PIC model we know it fits if it is local to the shared\n+\t library.  Don't count TLS SYMBOL_REFs here, since they should fit\n+\t only if inside of UNSPEC handled below.  */\n       case SYMBOL_REF:\n-\treturn ix86_cmodel == CM_SMALL || ix86_cmodel == CM_KERNEL;\n+\treturn (ix86_cmodel == CM_SMALL || ix86_cmodel == CM_KERNEL\n+\t\t|| (allow_rip\n+\t\t    && ix86_cmodel == CM_SMALL_PIC\n+\t\t    && (CONSTANT_POOL_ADDRESS_P (value)\n+\t\t\t|| SYMBOL_REF_FLAG (value))\n+\t\t    && ! tls_symbolic_operand (value, GET_MODE (value))));\n \n       /* For certain code models, the code is near as well.  */\n       case LABEL_REF:\n-\treturn ix86_cmodel != CM_LARGE && ix86_cmodel != CM_SMALL_PIC;\n+\treturn ix86_cmodel != CM_LARGE\n+\t       && (allow_rip || ix86_cmodel != CM_SMALL_PIC);\n \n       /* We also may accept the offsetted memory references in certain special\n          cases.  */\n       case CONST:\n-\tif (GET_CODE (XEXP (value, 0)) == UNSPEC\n-\t    && XINT (XEXP (value, 0), 1) == UNSPEC_GOTPCREL)\n-\t  return 1;\n-\telse if (GET_CODE (XEXP (value, 0)) == PLUS)\n+\tif (GET_CODE (XEXP (value, 0)) == UNSPEC)\n+\t  switch (XINT (XEXP (value, 0), 1))\n+\t    {\n+\t    case UNSPEC_GOTPCREL:\n+\t    case UNSPEC_DTPOFF:\n+\t    case UNSPEC_GOTNTPOFF:\n+\t    case UNSPEC_NTPOFF:\n+\t      return 1;\n+\t    default:\n+\t      break;\n+\t    }\n+\tif (GET_CODE (XEXP (value, 0)) == PLUS)\n \t  {\n \t    rtx op1 = XEXP (XEXP (value, 0), 0);\n \t    rtx op2 = XEXP (XEXP (value, 0), 1);\n@@ -3865,12 +3886,12 @@ x86_64_sign_extended_value (value)\n \t    switch (GET_CODE (op1))\n \t      {\n \t\tcase SYMBOL_REF:\n-\t\t  /* For CM_SMALL assume that latest object is 1MB before\n+\t\t  /* For CM_SMALL assume that latest object is 16MB before\n \t\t     end of 31bits boundary.  We may also accept pretty\n \t\t     large negative constants knowing that all objects are\n \t\t     in the positive half of address space.  */\n \t\t  if (ix86_cmodel == CM_SMALL\n-\t\t      && offset < 1024*1024*1024\n+\t\t      && offset < 16*1024*1024\n \t\t      && trunc_int_for_mode (offset, SImode) == offset)\n \t\t    return 1;\n \t\t  /* For CM_KERNEL we know that all object resist in the\n@@ -3881,19 +3902,44 @@ x86_64_sign_extended_value (value)\n \t\t      && offset > 0\n \t\t      && trunc_int_for_mode (offset, SImode) == offset)\n \t\t    return 1;\n+\t\t  /* For CM_SMALL_PIC, we can make similar assumptions\n+\t\t     as for CM_SMALL model, if we know the symbol is local\n+\t\t     to the shared library.  Disallow any TLS symbols,\n+\t\t     since they should always be enclosed in an UNSPEC.  */\n+\t\t  if (ix86_cmodel == CM_SMALL_PIC\n+\t\t      && allow_rip\n+\t\t      && (CONSTANT_POOL_ADDRESS_P (op1)\n+\t\t\t  || SYMBOL_REF_FLAG (op1))\n+\t\t      && ! tls_symbolic_operand (op1, GET_MODE (op1))\n+\t\t      && offset < 16*1024*1024\n+\t\t      && offset >= -16*1024*1024\n+\t\t      && trunc_int_for_mode (offset, SImode) == offset)\n+\t\t    return 1;\n \t\t  break;\n \t\tcase LABEL_REF:\n \t\t  /* These conditions are similar to SYMBOL_REF ones, just the\n \t\t     constraints for code models differ.  */\n-\t\t  if ((ix86_cmodel == CM_SMALL || ix86_cmodel == CM_MEDIUM)\n-\t\t      && offset < 1024*1024*1024\n+\t\t  if ((ix86_cmodel == CM_SMALL || ix86_cmodel == CM_MEDIUM\n+\t\t       || (ix86_cmodel == CM_SMALL_PIC && allow_rip\n+\t\t\t   && offset >= -16*1024*1024))\n+\t\t      && offset < 16*1024*1024\n \t\t      && trunc_int_for_mode (offset, SImode) == offset)\n \t\t    return 1;\n \t\t  if (ix86_cmodel == CM_KERNEL\n \t\t      && offset > 0\n \t\t      && trunc_int_for_mode (offset, SImode) == offset)\n \t\t    return 1;\n \t\t  break;\n+\t\tcase UNSPEC:\n+\t\t  switch (XINT (op1, 1))\n+\t\t    {\n+\t\t    case UNSPEC_DTPOFF:\n+\t\t    case UNSPEC_NTPOFF:\n+\t\t      if (offset > 0\n+\t\t\t  && trunc_int_for_mode (offset, SImode) == offset)\n+\t\t\treturn 1;\n+\t\t    }\n+\t\t  break;\n \t\tdefault:\n \t\t  return 0;\n \t      }\n@@ -5082,21 +5128,8 @@ legitimate_pic_address_disp_p (disp)\n \n   /* In 64bit mode we can allow direct addresses of symbols and labels\n      when they are not dynamic symbols.  */\n-  if (TARGET_64BIT)\n-    {\n-      rtx x = disp;\n-      if (GET_CODE (disp) == CONST)\n-\tx = XEXP (disp, 0);\n-      /* ??? Handle PIC code models */\n-      if (GET_CODE (x) == PLUS\n-\t  && (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t      && ix86_cmodel == CM_SMALL_PIC\n-\t      && INTVAL (XEXP (x, 1)) < 1024*1024*1024\n-\t      && INTVAL (XEXP (x, 1)) > -1024*1024*1024))\n-\tx = XEXP (x, 0);\n-      if (local_symbolic_operand (x, Pmode))\n-\treturn 1;\n-    }\n+  if (TARGET_64BIT && local_symbolic_operand (disp, Pmode))\n+    return 1;\n   if (GET_CODE (disp) != CONST)\n     return 0;\n   disp = XEXP (disp, 0);\n@@ -5305,7 +5338,7 @@ legitimate_address_p (mode, addr, strict)\n \n       if (TARGET_64BIT)\n \t{\n-\t  if (!x86_64_sign_extended_value (disp))\n+\t  if (!x86_64_sign_extended_value (disp, !(index || base)))\n \t    {\n \t      reason = \"displacement is out of range\";\n \t      goto report_error;\n@@ -5352,10 +5385,19 @@ legitimate_address_p (mode, addr, strict)\n \tis_legitimate_pic:\n \t  if (TARGET_64BIT && (index || base))\n \t    {\n-\t      reason = \"non-constant pic memory reference\";\n-\t      goto report_error;\n+\t      /* foo@dtpoff(%rX) is ok.  */\n+\t      if (GET_CODE (disp) != CONST\n+\t\t  || GET_CODE (XEXP (disp, 0)) != PLUS\n+\t\t  || GET_CODE (XEXP (XEXP (disp, 0), 0)) != UNSPEC\n+\t\t  || GET_CODE (XEXP (XEXP (disp, 0), 1)) != CONST_INT\n+\t\t  || (XINT (XEXP (XEXP (disp, 0), 0), 1) != UNSPEC_DTPOFF\n+\t\t      && XINT (XEXP (XEXP (disp, 0), 0), 1) != UNSPEC_NTPOFF))\n+\t\t{\n+\t\t  reason = \"non-constant pic memory reference\";\n+\t\t  goto report_error;\n+\t\t}\n \t    }\n-\t  if (! legitimate_pic_address_disp_p (disp))\n+\t  else if (! legitimate_pic_address_disp_p (disp))\n \t    {\n \t      reason = \"displacement is an invalid pic construct\";\n \t      goto report_error;\n@@ -5553,7 +5595,9 @@ legitimize_pic_address (orig, reg)\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* ??? We need to limit offsets here.  */\n+\t\t  if (INTVAL (op1) < -16*1024*1024\n+\t\t      || INTVAL (op1) >= 16*1024*1024)\n+\t\t    new = gen_rtx_PLUS (Pmode, op0, force_reg (Pmode, op1));\n \t\t}\n \t    }\n \t  else\n@@ -5611,6 +5655,21 @@ ix86_encode_section_info (decl, first)\n       size_t len;\n       enum tls_model kind = decl_tls_model (decl);\n \n+      if (TARGET_64BIT && ! flag_pic)\n+\t{\n+\t  /* x86-64 doesn't allow non-pic code for shared libraries,\n+\t     so don't generate GD/LD TLS models for non-pic code.  */\n+\t  switch (kind)\n+\t    {\n+\t    case TLS_MODEL_GLOBAL_DYNAMIC:\n+\t      kind = TLS_MODEL_INITIAL_EXEC; break;\n+\t    case TLS_MODEL_LOCAL_DYNAMIC:\n+\t      kind = TLS_MODEL_LOCAL_EXEC; break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n       symbol_str = XSTR (symbol, 0);\n \n       if (symbol_str[0] == '%')\n@@ -5700,54 +5759,87 @@ legitimize_address (x, oldx, mode)\n   if (log)\n     {\n       rtx dest, base, off, pic;\n+      int type;\n \n       switch (log)\n         {\n         case TLS_MODEL_GLOBAL_DYNAMIC:\n \t  dest = gen_reg_rtx (Pmode);\n-          emit_insn (gen_tls_global_dynamic (dest, x));\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      rtx rax = gen_rtx_REG (Pmode, 0), insns;\n+\n+\t      start_sequence ();\n+\t      emit_call_insn (gen_tls_global_dynamic_64 (rax, x));\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n+\n+\t      emit_libcall_block (insns, dest, rax, x);\n+\t    }\n+\t  else\n+\t    emit_insn (gen_tls_global_dynamic_32 (dest, x));\n \t  break;\n \n         case TLS_MODEL_LOCAL_DYNAMIC:\n \t  base = gen_reg_rtx (Pmode);\n-\t  emit_insn (gen_tls_local_dynamic_base (base));\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      rtx rax = gen_rtx_REG (Pmode, 0), insns, note;\n+\n+\t      start_sequence ();\n+\t      emit_call_insn (gen_tls_local_dynamic_base_64 (rax));\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n+\n+\t      note = gen_rtx_EXPR_LIST (VOIDmode, const0_rtx, NULL);\n+\t      note = gen_rtx_EXPR_LIST (VOIDmode, ix86_tls_get_addr (), note);\n+\t      emit_libcall_block (insns, base, rax, note);\n+\t    }\n+\t  else\n+\t    emit_insn (gen_tls_local_dynamic_base_32 (base));\n \n \t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_DTPOFF);\n \t  off = gen_rtx_CONST (Pmode, off);\n \n \t  return gen_rtx_PLUS (Pmode, base, off);\n \n         case TLS_MODEL_INITIAL_EXEC:\n-\t  if (flag_pic)\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      pic = NULL;\n+\t      type = UNSPEC_GOTNTPOFF;\n+\t    }\n+\t  else if (flag_pic)\n \t    {\n \t      if (reload_in_progress)\n \t\tregs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \t      pic = pic_offset_table_rtx;\n+\t      type = TARGET_GNU_TLS ? UNSPEC_GOTNTPOFF : UNSPEC_GOTTPOFF;\n \t    }\n \t  else if (!TARGET_GNU_TLS)\n \t    {\n \t      pic = gen_reg_rtx (Pmode);\n \t      emit_insn (gen_set_got (pic));\n+\t      type = UNSPEC_GOTTPOFF;\n \t    }\n \t  else\n-\t    pic = NULL;\n+\t    {\n+\t      pic = NULL;\n+\t      type = UNSPEC_INDNTPOFF;\n+\t    }\n \n \t  base = get_thread_pointer ();\n \n-\t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x),\n-\t\t\t\t!TARGET_GNU_TLS\n-\t\t\t\t? UNSPEC_GOTTPOFF\n-\t\t\t\t: flag_pic ? UNSPEC_GOTNTPOFF\n-\t\t\t\t\t   : UNSPEC_INDNTPOFF);\n+\t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), type);\n \t  off = gen_rtx_CONST (Pmode, off);\n-\t  if (flag_pic || !TARGET_GNU_TLS)\n+\t  if (pic)\n \t    off = gen_rtx_PLUS (Pmode, pic, off);\n \t  off = gen_rtx_MEM (Pmode, off);\n \t  RTX_UNCHANGING_P (off) = 1;\n \t  set_mem_alias_set (off, ix86_GOT_alias_set ());\n \t  dest = gen_reg_rtx (Pmode);\n \n-\t  if (TARGET_GNU_TLS)\n+\t  if (TARGET_64BIT || TARGET_GNU_TLS)\n \t    {\n \t      emit_move_insn (dest, off);\n \t      return gen_rtx_PLUS (Pmode, base, dest);\n@@ -5760,10 +5852,11 @@ legitimize_address (x, oldx, mode)\n \t  base = get_thread_pointer ();\n \n \t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x),\n-\t\t\t\tTARGET_GNU_TLS ? UNSPEC_NTPOFF : UNSPEC_TPOFF);\n+\t\t\t\t(TARGET_64BIT || TARGET_GNU_TLS)\n+\t\t\t\t? UNSPEC_NTPOFF : UNSPEC_TPOFF);\n \t  off = gen_rtx_CONST (Pmode, off);\n \n-\t  if (TARGET_GNU_TLS)\n+\t  if (TARGET_64BIT || TARGET_GNU_TLS)\n \t    return gen_rtx_PLUS (Pmode, base, off);\n \t  else\n \t    {\n@@ -6041,13 +6134,19 @@ output_pic_addr_const (file, x, code)\n \t  fputs (\"@TPOFF\", file);\n \t  break;\n \tcase UNSPEC_NTPOFF:\n-\t  fputs (\"@NTPOFF\", file);\n+\t  if (TARGET_64BIT)\n+\t    fputs (\"@TPOFF\", file);\n+\t  else\n+\t    fputs (\"@NTPOFF\", file);\n \t  break;\n \tcase UNSPEC_DTPOFF:\n \t  fputs (\"@DTPOFF\", file);\n \t  break;\n \tcase UNSPEC_GOTNTPOFF:\n-\t  fputs (\"@GOTNTPOFF\", file);\n+\t  if (TARGET_64BIT)\n+\t    fputs (\"@GOTTPOFF(%rip)\", file);\n+\t  else\n+\t    fputs (\"@GOTNTPOFF\", file);\n \t  break;\n \tcase UNSPEC_INDNTPOFF:\n \t  fputs (\"@INDNTPOFF\", file);\n@@ -6094,22 +6193,19 @@ i386_output_dwarf_dtprel (file, size, x)\n      int size;\n      rtx x;\n {\n+  fputs (ASM_LONG, file);\n+  output_addr_const (file, x);\n+  fputs (\"@DTPOFF\", file);\n   switch (size)\n     {\n     case 4:\n-      fputs (ASM_LONG, file);\n       break;\n     case 8:\n-#ifdef ASM_QUAD\n-      fputs (ASM_QUAD, file);\n+      fputs (\", 0\", file);\n       break;\n-#endif\n     default:\n       abort ();\n    }\n-  \n-  output_addr_const (file, x);\n-  fputs (\"@DTPOFF\", file);\n }\n \n /* In the name of slightly smaller debug output, and to cater to\n@@ -6821,7 +6917,10 @@ print_operand_address (file, addr)\n \tfputs (\"DWORD PTR \", file);\n       if (ASSEMBLER_DIALECT == ASM_ATT || USER_LABEL_PREFIX[0] == 0)\n \tputc ('%', file);\n-      fputs (\"gs:0\", file);\n+      if (TARGET_64BIT)\n+\tfputs (\"fs:0\", file);\n+      else\n+\tfputs (\"gs:0\", file);\n       return;\n     }\n \n@@ -6854,7 +6953,8 @@ print_operand_address (file, addr)\n \n       /* Use one byte shorter RIP relative addressing for 64bit mode.  */\n       if (TARGET_64BIT\n-\t  && (GET_CODE (addr) == SYMBOL_REF\n+\t  && ((GET_CODE (addr) == SYMBOL_REF\n+\t       && ! tls_symbolic_operand (addr, GET_MODE (addr)))\n \t      || GET_CODE (addr) == LABEL_REF\n \t      || (GET_CODE (addr) == CONST\n \t\t  && GET_CODE (XEXP (addr, 0)) == PLUS\n@@ -6967,15 +7067,21 @@ output_addr_const_extra (file, x)\n       break;\n     case UNSPEC_NTPOFF:\n       output_addr_const (file, op);\n-      fputs (\"@NTPOFF\", file);\n+      if (TARGET_64BIT)\n+\tfputs (\"@TPOFF\", file);\n+      else\n+\tfputs (\"@NTPOFF\", file);\n       break;\n     case UNSPEC_DTPOFF:\n       output_addr_const (file, op);\n       fputs (\"@DTPOFF\", file);\n       break;\n     case UNSPEC_GOTNTPOFF:\n       output_addr_const (file, op);\n-      fputs (\"@GOTNTPOFF\", file);\n+      if (TARGET_64BIT)\n+\tfputs (\"@GOTTPOFF(%rip)\", file);\n+      else\n+\tfputs (\"@GOTNTPOFF\", file);\n       break;\n     case UNSPEC_INDNTPOFF:\n       output_addr_const (file, op);\n@@ -7539,7 +7645,7 @@ maybe_get_pool_constant (x)\n {\n   x = XEXP (x, 0);\n \n-  if (flag_pic)\n+  if (flag_pic && ! TARGET_64BIT)\n     {\n       if (GET_CODE (x) != PLUS)\n \treturn NULL_RTX;\n@@ -9096,7 +9202,7 @@ ix86_expand_int_movcc (operands)\n \n       if ((diff == 1 || diff == 2 || diff == 4 || diff == 8\n \t   || diff == 3 || diff == 5 || diff == 9)\n-\t  && (mode != DImode || x86_64_sign_extended_value (GEN_INT (cf))))\n+\t  && (mode != DImode || x86_64_sign_extended_value (GEN_INT (cf), 0)))\n \t{\n \t  /*\n \t   * xorl dest,dest\n@@ -10827,9 +10933,10 @@ ix86_tls_get_addr ()\n \n   if (!ix86_tls_symbol)\n     {\n-      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, (TARGET_GNU_TLS\n-\t\t\t\t\t   ? \"___tls_get_addr\"\n-\t\t\t\t\t   : \"__tls_get_addr\"));\n+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t    (TARGET_GNU_TLS && !TARGET_64BIT)\n+\t\t\t\t\t    ? \"___tls_get_addr\"\n+\t\t\t\t\t    : \"__tls_get_addr\");\n     }\n \n   return ix86_tls_symbol;"}, {"sha": "8ad3cd41a630bba3485a09ce56c9c278ff66f62f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -1426,7 +1426,7 @@ enum reg_class\n    constraint, the value returned should be 0 regardless of VALUE.  */\n \n #define EXTRA_CONSTRAINT(VALUE, C)\t\t\t\t\\\n-  ((C) == 'e' ? x86_64_sign_extended_value (VALUE)\t\t\\\n+  ((C) == 'e' ? x86_64_sign_extended_value (VALUE, 0)\t\t\\\n    : (C) == 'Z' ? x86_64_zero_extended_value (VALUE)\t\t\\\n    : 0)\n \n@@ -2553,7 +2553,7 @@ do {\t\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n-    if (TARGET_64BIT && !x86_64_sign_extended_value (RTX))\t\\\n+    if (TARGET_64BIT && !x86_64_sign_extended_value (RTX, 0))\t\\\n       return 3;\t\t\t\t\t\t\t\\\n     if (TARGET_64BIT && !x86_64_zero_extended_value (RTX))\t\\\n       return 2;\t\t\t\t\t\t\t\\"}, {"sha": "bb679f74292176f2197e5951de79f1a01e5cbb9d", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -13783,7 +13783,7 @@\n ;; Note that these code sequences must appear exactly as shown\n ;; in order to allow linker relaxation.\n \n-(define_insn \"*tls_global_dynamic_gnu\"\n+(define_insn \"*tls_global_dynamic_32_gnu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n \t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n \t\t    (match_operand:SI 2 \"tls_symbolic_operand\" \"\")\n@@ -13792,12 +13792,12 @@\n    (clobber (match_scratch:SI 4 \"=d\"))\n    (clobber (match_scratch:SI 5 \"=c\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_GNU_TLS\"\n+  \"!TARGET_64BIT && TARGET_GNU_TLS\"\n   \"lea{l}\\t{%a2@TLSGD(,%1,1), %0|%0, %a2@TLSGD[%1*1]}\\;call\\t%P3\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"12\")])\n \n-(define_insn \"*tls_global_dynamic_sun\"\n+(define_insn \"*tls_global_dynamic_32_sun\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n \t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n \t\t    (match_operand:SI 2 \"tls_symbolic_operand\" \"\")\n@@ -13806,13 +13806,13 @@\n    (clobber (match_scratch:SI 4 \"=d\"))\n    (clobber (match_scratch:SI 5 \"=c\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SUN_TLS\"\n+  \"!TARGET_64BIT && TARGET_SUN_TLS\"\n   \"lea{l}\\t{%a2@DTLNDX(%1), %4|%4, %a2@DTLNDX[%1]}\n \tpush{l}\\t%4\\;call\\t%a2@TLSPLT\\;pop{l}\\t%4\\;nop\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"14\")])\n \n-(define_expand \"tls_global_dynamic\"\n+(define_expand \"tls_global_dynamic_32\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (unspec:SI\n \t\t    [(match_dup 2)\n@@ -13834,34 +13834,55 @@\n   operands[3] = ix86_tls_get_addr ();\n })\n \n-(define_insn \"*tls_local_dynamic_base_gnu\"\n+(define_insn \"*tls_global_dynamic_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(call (mem:QI (match_operand:DI 2 \"call_insn_operand\" \"\"))\n+\t\t      (match_operand:DI 3 \"\" \"\")))\n+   (unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t      UNSPEC_TLS_GD)]\n+  \"TARGET_64BIT\"\n+  \".byte\\t0x66\\;lea{q}\\t{%a1@TLSGD(%%rip), %%rdi|%%rdi, %a1@TLSGD[%%rip]}\\;.word\\t0x6666\\;rex64\\;call\\t%P2\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"16\")])\n+\n+(define_expand \"tls_global_dynamic_64\"\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (call (mem:QI (match_dup 2)) (const_int 0)))\n+\t      (unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t\t UNSPEC_TLS_GD)])]\n+  \"\"\n+{\n+  operands[2] = ix86_tls_get_addr ();\n+})\n+\n+(define_insn \"*tls_local_dynamic_base_32_gnu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n \t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n                     (match_operand:SI 2 \"call_insn_operand\" \"\")]\n \t\t   UNSPEC_TLS_LD_BASE))\n    (clobber (match_scratch:SI 3 \"=d\"))\n    (clobber (match_scratch:SI 4 \"=c\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_GNU_TLS\"\n+  \"!TARGET_64BIT && TARGET_GNU_TLS\"\n   \"lea{l}\\t{%&@TLSLDM(%1), %0|%0, %&@TLSLDM[%1]}\\;call\\t%P2\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"11\")])\n \n-(define_insn \"*tls_local_dynamic_base_sun\"\n+(define_insn \"*tls_local_dynamic_base_32_sun\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n \t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n                     (match_operand:SI 2 \"call_insn_operand\" \"\")]\n \t\t   UNSPEC_TLS_LD_BASE))\n    (clobber (match_scratch:SI 3 \"=d\"))\n    (clobber (match_scratch:SI 4 \"=c\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SUN_TLS\"\n+  \"!TARGET_64BIT && TARGET_SUN_TLS\"\n   \"lea{l}\\t{%&@TMDNX(%1), %3|%3, %&@TMDNX[%1]}\n \tpush{l}\\t%3\\;call\\t%&@TLSPLT\\;pop{l}\\t%3\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"13\")])\n \n-(define_expand \"tls_local_dynamic_base\"\n+(define_expand \"tls_local_dynamic_base_32\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (unspec:SI [(match_dup 1) (match_dup 2)]\n \t\t\t      UNSPEC_TLS_LD_BASE))\n@@ -13880,10 +13901,29 @@\n   operands[2] = ix86_tls_get_addr ();\n })\n \n+(define_insn \"*tls_local_dynamic_base_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"\"))\n+\t\t      (match_operand:DI 2 \"\" \"\")))\n+   (unspec:DI [(const_int 0)] UNSPEC_TLS_LD_BASE)]\n+  \"TARGET_64BIT\"\n+  \"lea{q}\\t{%&@TLSLD(%%rip), %%rdi|%%rdi, %&@TLSLD[%%rip]}\\;call\\t%P1\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"12\")])\n+\n+(define_expand \"tls_local_dynamic_base_64\"\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (call (mem:QI (match_dup 1)) (const_int 0)))\n+\t      (unspec:DI [(const_int 0)] UNSPEC_TLS_LD_BASE)])]\n+  \"\"\n+{\n+  operands[1] = ix86_tls_get_addr ();\n+})\n+\n ;; Local dynamic of a single variable is a lose.  Show combine how\n ;; to convert that back to global dynamic.\n \n-(define_insn_and_split \"*tls_local_dynamic_once\"\n+(define_insn_and_split \"*tls_local_dynamic_32_once\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n \t(plus:SI (unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n \t\t\t     (match_operand:SI 2 \"call_insn_operand\" \"\")]"}, {"sha": "d03e60d6e18f9d86504a49655ebd5504860d45a8", "filename": "gcc/configure", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -7482,11 +7482,27 @@ foo:\t.long\t25\n \tleal\tfoo@DTPOFF(%eax), %edx\n \tmovl\tfoo@GOTTPOFF(%ebx), %eax\n \tsubl\tfoo@GOTTPOFF(%ebx), %eax\n+\taddl\tfoo@GOTNTPOFF(%ebx), %eax\n+\tmovl\tfoo@INDNTPOFF, %eax\n \tmovl\t$foo@TPOFF, %eax\n \tsubl\t$foo@TPOFF, %eax\n \tleal\tfoo@NTPOFF(%ecx), %eax'\n \ttls_first_major=2\n-\ttls_first_minor=13\n+\ttls_first_minor=14\n+\t;;\n+  x86_64-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tmovq\t%fs:0, %rax\n+\tleaq\tfoo@TLSGD(%rip), %rdi\n+\tleaq\tfoo@TLSLD(%rip), %rdi\n+\tleaq\tfoo@DTPOFF(%rax), %rdx\n+\tmovq\tfoo@GOTTPOFF(%rip), %rax\n+\tmovq\t$foo@TPOFF, %rax'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n \t;;\n   ia64-*-*)\n     conftest_s='"}, {"sha": "7e0174879aa044ce3b9cafc1cf47bc7135758436", "filename": "gcc/configure.in", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -1802,11 +1802,27 @@ foo:\t.long\t25\n \tleal\tfoo@DTPOFF(%eax), %edx\n \tmovl\tfoo@GOTTPOFF(%ebx), %eax\n \tsubl\tfoo@GOTTPOFF(%ebx), %eax\n+\taddl\tfoo@GOTNTPOFF(%ebx), %eax\n+\tmovl\tfoo@INDNTPOFF, %eax\n \tmovl\t$foo@TPOFF, %eax\n \tsubl\t$foo@TPOFF, %eax\n \tleal\tfoo@NTPOFF(%ecx), %eax'\n \ttls_first_major=2\n-\ttls_first_minor=13\n+\ttls_first_minor=14\n+\t;;\n+  x86_64-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tmovq\t%fs:0, %rax\n+\tleaq\tfoo@TLSGD(%rip), %rdi\n+\tleaq\tfoo@TLSLD(%rip), %rdi\n+\tleaq\tfoo@DTPOFF(%rax), %rdx\n+\tmovq\tfoo@GOTTPOFF(%rip), %rax\n+\tmovq\t$foo@TPOFF, %rax'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n \t;;\n   ia64-*-*)\n     conftest_s='"}, {"sha": "4fc092cc836108c218581f104c7e4f9feb2f85a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -1,3 +1,9 @@\n+2002-10-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/tls/pic-1.c: New test.\n+\t* gcc.dg/tls/nonpic-1.c: New test.\n+\t* gcc.dg/20021018-1.c: New test.\n+\n 2002-10-21  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* lib/profopt.exp (profopt-cleanup): New argument TESTCASE."}, {"sha": "f11de4859ef8d7cf3f0777a19c929312eeda1483", "filename": "gcc/testsuite/gcc.dg/20021018-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Ftestsuite%2Fgcc.dg%2F20021018-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Ftestsuite%2Fgcc.dg%2F20021018-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20021018-1.c?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fpic\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+static const long foo [10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+\n+long __attribute__((noinline))\n+bar (int x)\n+{\n+  return foo [x - 0x6ffffffa];\n+}\n+\n+int\n+main (void)\n+{\n+  if (bar (0x6ffffffc) != 2)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "0896df60b56533c9ca475f02e4c4479d71973450", "filename": "gcc/testsuite/gcc.dg/tls/nonpic-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fnonpic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fnonpic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fnonpic-1.c?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftls-model=initial-exec\" } */\n+\n+extern __thread long e1;\n+extern __thread int e2;\n+static __thread long s1;\n+static __thread int s2;\n+\n+long *ae1 (void)\n+{\n+  return &e1;\n+}\n+\n+int *ae2 (void)\n+{\n+  return &e2;\n+}\n+\n+long *as1 (void)\n+{\n+  return &s1;\n+}\n+\n+int *as2 (void)\n+{\n+  return &s2;\n+}\n+\n+long ge1 (void)\n+{\n+  return e1;\n+}\n+\n+int ge2 (void)\n+{\n+  return e2;\n+}\n+\n+long gs1 (void)\n+{\n+  return s1;\n+}\n+\n+int gs2 (void)\n+{\n+  return s2;\n+}\n+\n+long ge3 (void)\n+{\n+  return e1 + e2;\n+}\n+\n+long gs3 (void)\n+{\n+  return s1 + s2;\n+}\n+\n+long ge4 (void)\n+{\n+  if (0)\n+    return e1;\n+  return e2;\n+}\n+\n+long gs4 (void)\n+{\n+  if (0)\n+    return s1;\n+  return s2;\n+}"}, {"sha": "f5b020b7db601f4434df35b29720ce607b4a44e9", "filename": "gcc/testsuite/gcc.dg/tls/pic-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fpic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d383798962aa309d4474fdb2d8ce17db50a031/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fpic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fpic-1.c?ref=75d383798962aa309d4474fdb2d8ce17db50a031", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fpic -ftls-model=global-dynamic\" } */\n+\n+extern __thread long e1;\n+extern __thread int e2;\n+static __thread long s1;\n+static __thread int s2;\n+\n+long *ae1 (void)\n+{\n+  return &e1;\n+}\n+\n+int *ae2 (void)\n+{\n+  return &e2;\n+}\n+\n+long *as1 (void)\n+{\n+  return &s1;\n+}\n+\n+int *as2 (void)\n+{\n+  return &s2;\n+}\n+\n+long ge1 (void)\n+{\n+  return e1;\n+}\n+\n+int ge2 (void)\n+{\n+  return e2;\n+}\n+\n+long gs1 (void)\n+{\n+  return s1;\n+}\n+\n+int gs2 (void)\n+{\n+  return s2;\n+}\n+\n+long ge3 (void)\n+{\n+  return e1 + e2;\n+}\n+\n+long gs3 (void)\n+{\n+  return s1 + s2;\n+}\n+\n+long ge4 (void)\n+{\n+  if (0)\n+    return e1;\n+  return e2;\n+}\n+\n+long gs4 (void)\n+{\n+  if (0)\n+    return s1;\n+  return s2;\n+}"}]}