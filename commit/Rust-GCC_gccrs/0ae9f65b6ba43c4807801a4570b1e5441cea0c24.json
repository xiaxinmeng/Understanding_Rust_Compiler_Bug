{"sha": "0ae9f65b6ba43c4807801a4570b1e5441cea0c24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFlOWY2NWI2YmE0M2M0ODA3ODAxYTQ1NzBiMWU1NDQxY2VhMGMyNA==", "commit": {"author": {"name": "Doug Evans", "email": "devans@canuck.cygnus.com", "date": "1998-11-02T11:48:08Z"}, "committer": {"name": "Doug Evans", "email": "devans@gcc.gnu.org", "date": "1998-11-02T11:48:08Z"}, "message": "m32r.c (m32r_expand_block_move): Fix byte count computations.\n\n\t* m32r/m32r.c (m32r_expand_block_move): Fix byte count computations.\n\t(m32r_output_block_move): Rewrite bytes < 4 handling.\n\nFrom-SVN: r23503", "tree": {"sha": "e36cbf7606d6399719b57cd0212b867772d2823b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e36cbf7606d6399719b57cd0212b867772d2823b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ae9f65b6ba43c4807801a4570b1e5441cea0c24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae9f65b6ba43c4807801a4570b1e5441cea0c24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae9f65b6ba43c4807801a4570b1e5441cea0c24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae9f65b6ba43c4807801a4570b1e5441cea0c24/comments", "author": null, "committer": null, "parents": [{"sha": "4913b6085d727ad97944d46ef8f1e5efe437c4e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4913b6085d727ad97944d46ef8f1e5efe437c4e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4913b6085d727ad97944d46ef8f1e5efe437c4e5"}], "stats": {"total": 50, "additions": 38, "deletions": 12}, "files": [{"sha": "48fa0a3cdb6afdd7282c77e366b178584391aa3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9f65b6ba43c4807801a4570b1e5441cea0c24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9f65b6ba43c4807801a4570b1e5441cea0c24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ae9f65b6ba43c4807801a4570b1e5441cea0c24", "patch": "@@ -1,3 +1,8 @@\n+Mon Nov  2 11:46:17 1998  Doug Evans  <devans@canuck.cygnus.com>\n+\n+\t* m32r/m32r.c (m32r_expand_block_move): Fix byte count computations.\n+\t(m32r_output_block_move): Rewrite bytes < 4 handling.\n+\n Mon Nov  2 10:10:35 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* configure.in: Call AC_FUNC_VFORK."}, {"sha": "8332035beebf83aabe74e6ce3816e12c3873cf81", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9f65b6ba43c4807801a4570b1e5441cea0c24/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9f65b6ba43c4807801a4570b1e5441cea0c24/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=0ae9f65b6ba43c4807801a4570b1e5441cea0c24", "patch": "@@ -2322,8 +2322,8 @@ m32r_expand_block_move (operands)\n     {\n       rtx label;\n       rtx final_src;\n-      \n-      bytes_rtx = GEN_INT (MAX_MOVE_BYTES);\n+      rtx at_a_time = GEN_INT (MAX_MOVE_BYTES);\n+      rtx rounded_total = GEN_INT (bytes);\n \n       /* If we are going to have to perform this loop more than\n \t once, then generate a label and compute the address the\n@@ -2334,10 +2334,10 @@ m32r_expand_block_move (operands)\n \t  final_src = gen_reg_rtx (Pmode);\n \n \t  if (INT16_P(bytes))\n-\t    emit_insn (gen_addsi3 (final_src, src_reg, bytes_rtx));\n+\t    emit_insn (gen_addsi3 (final_src, src_reg, rounded_total));\n \t  else\n \t    {\n-\t      emit_insn (gen_movsi (final_src, bytes_rtx));\n+\t      emit_insn (gen_movsi (final_src, rounded_total));\n \t      emit_insn (gen_addsi3 (final_src, final_src, src_reg));\n \t    }\n \n@@ -2349,7 +2349,7 @@ m32r_expand_block_move (operands)\n \t to the word after the end of the source block, and dst_reg to point\n \t to the last word of the destination block, provided that the block\n \t is MAX_MOVE_BYTES long.  */\n-      emit_insn (gen_movstrsi_internal (dst_reg, src_reg, bytes_rtx));\n+      emit_insn (gen_movstrsi_internal (dst_reg, src_reg, at_a_time));\n       emit_insn (gen_addsi3 (dst_reg, dst_reg, GEN_INT (4)));\n       \n       if (bytes > MAX_MOVE_BYTES)\n@@ -2435,7 +2435,13 @@ m32r_output_block_move (insn, operands)\n \t  /* Get the entire next word, even though we do not want all of it.\n \t     The saves us from doing several smaller loads, and we assume that\n \t     we cannot cause a page fault when at least part of the word is in\n-\t     valid memory.  If got_extra is true then we have already loaded\n+\t     valid memory [since we don't get called if things aren't properly\n+\t     aligned].  */\n+\t  int dst_offset = first_time ? 0 : 4;\n+\t  int last_shift;\n+\t  rtx my_operands[3];\n+\n+\t  /* If got_extra is true then we have already loaded\n \t     the next word as part of loading and storing the previous word.  */\n \t  if (! got_extra)\n \t    output_asm_insn (\"ld\\t%4, @%1\", operands);\n@@ -2444,21 +2450,36 @@ m32r_output_block_move (insn, operands)\n \t    {\n \t      bytes -= 2;\n \n-\t      output_asm_insn (\"sth\\t%4, @%0\", operands);\n+\t      output_asm_insn (\"sra3\\t%3, %4, #16\", operands);\n+\t      my_operands[0] = operands[3];\n+\t      my_operands[1] = GEN_INT (dst_offset);\n+\t      my_operands[2] = operands[0];\n+\t      output_asm_insn (\"sth\\t%0, @(%1,%2)\", my_operands);\n \t      \n \t      /* If there is a byte left to store then increment the\n \t\t destination address and shift the contents of the source\n-\t\t register down by 16 bits.  We could not do the address\n+\t\t register down by 8 bits.  We could not do the address\n \t\t increment in the store half word instruction, because it does\n \t\t not have an auto increment mode.  */\n \t      if (bytes > 0)  /* assert (bytes == 1) */\n \t\t{\n-\t\t  output_asm_insn (\"srai\\t%4, #16\", operands);\n-\t\t  output_asm_insn (\"addi\\t%0, #2\", operands);\n+\t\t  dst_offset += 2;\n+\t\t  last_shift = 8;\n \t\t}\n \t    }\n-\t  \n-\t  output_asm_insn (\"stb\\t%4, @%0\", operands);\n+\t  else\n+\t    last_shift = 24;\n+\n+\t  if (bytes > 0)\n+\t    {\n+\t      my_operands[0] = operands[4];\n+\t      my_operands[1] = GEN_INT (last_shift);\n+\t      output_asm_insn (\"srai\\t%0, #%1\", my_operands);\n+\t      my_operands[0] = operands[4];\n+\t      my_operands[1] = GEN_INT (dst_offset);\n+\t      my_operands[2] = operands[0];\n+\t      output_asm_insn (\"stb\\t%0, @(%1,%2)\", my_operands);\n+\t    }\n \t  \n \t  bytes = 0;\n \t}"}]}