{"sha": "237ab3ee49e2f3110accfcc03b6c0df8b4889f15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM3YWIzZWU0OWUyZjMxMTBhY2NmY2MwM2I2YzBkZjhiNDg4OWYxNQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-07-08T08:42:49Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-07-19T20:10:29Z"}, "message": "coroutines: Adjust outlined function names [PR95520].\n\nThe mechanism used to date for uniquing the coroutine helper\nfunctions (actor, destroy) was over-complicating things and\nleading to the noted PR and also difficulties in setting\nbreakpoints on these functions (so this will help PR99215 as\nwell).\n\nThis implementation delegates the adjustment to the mangling\nto write_encoding() which necessitates some book-keeping so\nthat it is possible to determine which of the coroutine\nhelper names is to be mangled.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\nPR c++/95520 - [coroutines] __builtin_FUNCTION() returns mangled .actor instead of original function name\n\n\tPR c++/95520\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (struct coroutine_info): Add fields for\n\tactor and destroy function decls.\n\t(to_ramp): New.\n\t(coro_get_ramp_function): New.\n\t(coro_get_actor_function): New.\n\t(coro_get_destroy_function): New.\n\t(act_des_fn): Set up mapping between ramp, actor and\n\tdestroy functions.\n\t(morph_fn_to_coro): Adjust interface to the builder for\n\thelper function decls.\n\t* cp-tree.h (DECL_ACTOR_FN, DECL_DESTROY_FN, DECL_RAMP_FN,\n\tJOIN_STR): New.\n\t* mangle.c (write_encoding): Handle coroutine helpers.\n\t(write_unqualified_name): Handle lambda coroutine helpers.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/coroutines/pr95520.C: New test.", "tree": {"sha": "f5967df58b8d7524e2070dc44dc632ed77e8984f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5967df58b8d7524e2070dc44dc632ed77e8984f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/237ab3ee49e2f3110accfcc03b6c0df8b4889f15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/237ab3ee49e2f3110accfcc03b6c0df8b4889f15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/237ab3ee49e2f3110accfcc03b6c0df8b4889f15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a113b14398f2a4ad2742e6e9c87e25cac60f263e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a113b14398f2a4ad2742e6e9c87e25cac60f263e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a113b14398f2a4ad2742e6e9c87e25cac60f263e"}], "stats": {"total": 157, "additions": 143, "deletions": 14}, "files": [{"sha": "47c79e58db5395fe3049392a67b8750955b6f111", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 75, "deletions": 12, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=237ab3ee49e2f3110accfcc03b6c0df8b4889f15", "patch": "@@ -82,11 +82,13 @@ static bool coro_promise_type_found_p (tree, location_t);\n struct GTY((for_user)) coroutine_info\n {\n   tree function_decl; /* The original function decl.  */\n-  tree promise_type; /* The cached promise type for this function.  */\n-  tree handle_type;  /* The cached coroutine handle for this function.  */\n-  tree self_h_proxy; /* A handle instance that is used as the proxy for the\n-\t\t\tone that will eventually be allocated in the coroutine\n-\t\t\tframe.  */\n+  tree actor_decl;    /* The synthesized actor function.  */\n+  tree destroy_decl;  /* The synthesized destroy function.  */\n+  tree promise_type;  /* The cached promise type for this function.  */\n+  tree handle_type;   /* The cached coroutine handle for this function.  */\n+  tree self_h_proxy;  /* A handle instance that is used as the proxy for the\n+\t\t\t one that will eventually be allocated in the coroutine\n+\t\t\t frame.  */\n   tree promise_proxy; /* Likewise, a proxy promise instance.  */\n   tree return_void;   /* The expression for p.return_void() if it exists.  */\n   location_t first_coro_keyword; /* The location of the keyword that made this\n@@ -526,6 +528,46 @@ coro_promise_type_found_p (tree fndecl, location_t loc)\n   return true;\n }\n \n+/* Map from actor or destroyer to ramp.  */\n+static GTY(()) hash_map<tree, tree> *to_ramp;\n+\n+/* Given a tree that is an actor or destroy, find the ramp function.  */\n+\n+tree\n+coro_get_ramp_function (tree decl)\n+{\n+  if (!to_ramp)\n+    return NULL_TREE;\n+  tree *p = to_ramp->get (decl);\n+  if (p)\n+    return *p;\n+  return NULL_TREE;\n+}\n+\n+/* Given the DECL for a ramp function (the user's original declaration) return\n+   the actor function if it has been defined.  */\n+\n+tree\n+coro_get_actor_function (tree decl)\n+{\n+  if (coroutine_info *info = get_coroutine_info (decl))\n+    return info->actor_decl;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Given the DECL for a ramp function (the user's original declaration) return\n+   the destroy function if it has been defined.  */\n+\n+tree\n+coro_get_destroy_function (tree decl)\n+{\n+  if (coroutine_info *info = get_coroutine_info (decl))\n+    return info->destroy_decl;\n+\n+  return NULL_TREE;\n+}\n+\n /* These functions assumes that the caller has verified that the state for\n    the decl has been initialized, we try to minimize work here.  */\n \n@@ -3979,15 +4021,23 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n   return NULL_TREE;\n }\n \n-/* Build, return FUNCTION_DECL node with its coroutine frame pointer argument\n-   for either actor or destroy functions.  */\n+/* Build, return FUNCTION_DECL node based on ORIG with a type FN_TYPE which has\n+   a single argument of type CORO_FRAME_PTR.  Build the actor function if\n+   ACTOR_P is true, otherwise the destroy. */\n \n static tree\n-act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n+coro_build_actor_or_destroy_function (tree orig, tree fn_type,\n+\t\t\t\t      tree coro_frame_ptr, bool actor_p)\n {\n-  tree fn_name = get_fn_local_identifier (orig, name);\n   location_t loc = DECL_SOURCE_LOCATION (orig);\n-  tree fn = build_lang_decl (FUNCTION_DECL, fn_name, fn_type);\n+  tree fn\n+    = build_lang_decl (FUNCTION_DECL, copy_node (DECL_NAME (orig)), fn_type);\n+\n+  /* Allow for locating the ramp (original) function from this one.  */\n+  if (!to_ramp)\n+    to_ramp = hash_map<tree, tree>::create_ggc (10);\n+  to_ramp->put (fn, orig);\n+\n   DECL_CONTEXT (fn) = DECL_CONTEXT (orig);\n   DECL_SOURCE_LOCATION (fn) = loc;\n   DECL_ARTIFICIAL (fn) = true;\n@@ -4021,6 +4071,17 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n   /* This is a coroutine component.  */\n   DECL_COROUTINE_P (fn) = 1;\n \n+  /* Set up a means to find out if a decl is one of the helpers and, if so,\n+     which one.  */\n+  if (coroutine_info *info = get_coroutine_info (orig))\n+    {\n+      gcc_checking_assert ((actor_p && info->actor_decl == NULL_TREE)\n+\t\t\t   || info->destroy_decl == NULL_TREE);\n+      if (actor_p)\n+\tinfo->actor_decl = fn;\n+      else\n+\tinfo->destroy_decl = fn;\n+    }\n   return fn;\n }\n \n@@ -4329,8 +4390,10 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree act_des_fn_ptr = build_pointer_type (act_des_fn_type);\n \n   /* Declare the actor and destroyer function.  */\n-  tree actor = act_des_fn (orig, act_des_fn_type, coro_frame_ptr, \"actor\");\n-  tree destroy = act_des_fn (orig, act_des_fn_type, coro_frame_ptr, \"destroy\");\n+  tree actor = coro_build_actor_or_destroy_function (orig, act_des_fn_type,\n+\t\t\t\t\t\t     coro_frame_ptr, true);\n+  tree destroy = coro_build_actor_or_destroy_function (orig, act_des_fn_type,\n+\t\t\t\t\t\t       coro_frame_ptr, false);\n \n   /* Construct the wrapped function body; we will analyze this to determine\n      the requirements for the coroutine frame.  */"}, {"sha": "ddf8f43d8d8957e44ca511a4764694eb36878b24", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=237ab3ee49e2f3110accfcc03b6c0df8b4889f15", "patch": "@@ -5166,6 +5166,21 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_COROUTINE_P(NODE) \\\n   (LANG_DECL_FN_CHECK (DECL_COMMON_CHECK (NODE))->coroutine_p)\n \n+/* For a FUNCTION_DECL of a coroutine, this holds the ACTOR helper function\n+   decl.  */\n+#define DECL_ACTOR_FN(NODE) \\\n+  (coro_get_actor_function ((NODE)))\n+\n+/* For a FUNCTION_DECL of a coroutine, this holds the DESTROY helper function\n+  decl.  */\n+#define DECL_DESTROY_FN(NODE) \\\n+  (coro_get_destroy_function ((NODE)))\n+\n+/* For a FUNCTION_DECL of a coroutine helper (ACTOR or DESTROY), this points\n+   back to the original (ramp) function.  */\n+#define DECL_RAMP_FN(NODE) \\\n+  (coro_get_ramp_function (NODE))\n+\n /* True for an OMP_ATOMIC that has dependent parameters.  These are stored\n    as an expr in operand 1, and integer_zero_node or clauses in operand 0.  */\n #define OMP_ATOMIC_DEPENDENT_P(NODE) \\\n@@ -5584,6 +5599,7 @@ extern GTY(()) vec<tree, va_gc> *keyed_classes;\n #ifndef NO_DOT_IN_LABEL\n \n #define JOINER '.'\n+#define JOIN_STR \".\"\n \n #define AUTO_TEMP_NAME \"_.tmp_\"\n #define VFIELD_BASE \".vf\"\n@@ -5595,6 +5611,7 @@ extern GTY(()) vec<tree, va_gc> *keyed_classes;\n #ifndef NO_DOLLAR_IN_LABEL\n \n #define JOINER '$'\n+#define JOIN_STR \"$\"\n \n #define AUTO_TEMP_NAME \"_$tmp_\"\n #define VFIELD_BASE \"$vf\"\n@@ -5603,6 +5620,8 @@ extern GTY(()) vec<tree, va_gc> *keyed_classes;\n \n #else /* NO_DOLLAR_IN_LABEL */\n \n+#define JOIN_STR \"_\"\n+\n #define VTABLE_NAME \"__vt_\"\n #define VTABLE_NAME_P(ID_NODE) \\\n   (!strncmp (IDENTIFIER_POINTER (ID_NODE), VTABLE_NAME, \\\n@@ -8292,6 +8311,9 @@ extern tree finish_co_yield_expr\t\t(location_t, tree);\n extern tree coro_validate_builtin_call\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error);\n extern bool morph_fn_to_coro\t\t\t(tree, tree *, tree *);\n+extern tree coro_get_actor_function\t\t(tree);\n+extern tree coro_get_destroy_function\t\t(tree);\n+extern tree coro_get_ramp_function\t\t(tree);\n \n /* Inline bodies.  */\n   "}, {"sha": "bf4abba73111658c3df4c56d9ab719811cab5844", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=237ab3ee49e2f3110accfcc03b6c0df8b4889f15", "patch": "@@ -832,6 +832,18 @@ write_encoding (const tree decl)\n       write_bare_function_type (fn_type,\n \t\t\t\tmangle_return_type_p (decl),\n \t\t\t\td);\n+\n+      /* If this is a coroutine helper, then append an appropriate string to\n+\t identify which.  */\n+      if (tree ramp = DECL_RAMP_FN (decl))\n+\t{\n+\t  if (DECL_ACTOR_FN (ramp) == decl)\n+\t    write_string (JOIN_STR \"actor\");\n+\t  else if (DECL_DESTROY_FN (ramp) == decl)\n+\t    write_string (JOIN_STR \"destroy\");\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n     }\n }\n \n@@ -1423,9 +1435,12 @@ write_unqualified_name (tree decl)\n \t}\n       else if (DECL_OVERLOADED_OPERATOR_P (decl))\n \t{\n+\t  tree t;\n+\t  if (!(t = DECL_RAMP_FN (decl)))\n+\t    t = decl;\n \t  const char *mangled_name\n-\t    = (ovl_op_info[DECL_ASSIGNMENT_OPERATOR_P (decl)]\n-\t       [DECL_OVERLOADED_OPERATOR_CODE_RAW (decl)].mangled_name);\n+\t    = (ovl_op_info[DECL_ASSIGNMENT_OPERATOR_P (t)]\n+\t       [DECL_OVERLOADED_OPERATOR_CODE_RAW (t)].mangled_name);\n \t  write_string (mangled_name);\n \t}\n       else if (UDLIT_OPER_P (DECL_NAME (decl)))"}, {"sha": "4849b0789c7fbc655b0e209a1e38d82fd69e0588", "filename": "gcc/testsuite/g++.dg/coroutines/pr95520.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95520.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237ab3ee49e2f3110accfcc03b6c0df8b4889f15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95520.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95520.C?ref=237ab3ee49e2f3110accfcc03b6c0df8b4889f15", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do run }\n+// { dg-output \"coroutine name: MyFoo\" }\n+#include <coroutine>\n+#include <cstdio>\n+\n+struct pt\n+{\n+    using handle_t = std::coroutine_handle<pt>;\n+    auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+\n+    std::suspend_never initial_suspend () const noexcept { return {}; }\n+    std::suspend_never final_suspend () const noexcept { return {}; }\n+    void return_void() const noexcept {}\n+    void unhandled_exception() const noexcept {}\n+};\n+\n+template <> struct std::coroutine_traits<pt::handle_t>\n+    { using promise_type = pt; };\n+\n+static pt::handle_t MyFoo ()\n+{ \n+    printf (\"coroutine name: %s\\n\", __builtin_FUNCTION());\n+    co_return;\n+}\n+\n+int main()\n+{\n+    MyFoo ();\n+}"}]}