{"sha": "cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YxNzcyODdiMWQxZDgzNWEyZTNkMTY5ZDhjNGEzZmUzZWI2YWU1Yw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2008-04-08T06:46:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:46:17Z"}, "message": "a-calend-vms.ads, [...]: Add with and use clause for System.OS_Primitives.\n\n2008-04-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-calend-vms.ads, a-calend-vms.adb: Add with and use clause for\n\tSystem.OS_Primitives.\n\tChange type of various constants, parameters and local variables from\n\tTime to representation type OS_Time.\n\t(To_Ada_Time, To_Unix_Time): Correct sign of origin shift.\n\tRemove the declaration of constant Mili_F from several routines. New\n\tbody for internal package Conversions_Operations.\n\t(Time_Of): Add default parameters for several formals.\n\n\t* a-caldel.adb: Minor reformatting\n\n\t* a-calend.ads, a-calend.adb: New body for internal package\n\tConversions_Operations.\n\t(Time_Of): Add default parameters for several formals.\n\n\t* Makefile.rtl: Add a-ststop\n\tAdd Ada.Calendar.Conversions to the list of runtime files.\n\tAdd g-timsta\n\n\t* a-calcon.adb, a-calcon.ads: New files.\n\nFrom-SVN: r134014", "tree": {"sha": "ca7f3ae4a9adaf9b0a82411a7847979c11d518c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca7f3ae4a9adaf9b0a82411a7847979c11d518c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f9a4f2ef03bc9ad213e82e40b4c26fc0d33b1a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9a4f2ef03bc9ad213e82e40b4c26fc0d33b1a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9a4f2ef03bc9ad213e82e40b4c26fc0d33b1a94"}], "stats": {"total": 996, "additions": 903, "deletions": 93}, "files": [{"sha": "755fa31da85a2ee137c18e62fa2178d94b1777a9", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "patch": "@@ -79,6 +79,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-calari$(objext) \\\n   a-caldel$(objext) \\\n   a-calend$(objext) \\\n+  a-calcon$(objext) \\\n   a-calfor$(objext) \\\n   a-catizo$(objext) \\\n   a-cdlili$(objext) \\\n@@ -380,6 +381,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-sttsne$(objext) \\\n   g-table$(objext) \\\n   g-tasloc$(objext) \\\n+  g-timsta$(objext) \\\n   g-traceb$(objext) \\\n   g-utf_32$(objext) \\\n   g-u3spch$(objext) \\\n@@ -558,6 +560,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-stopoo$(objext) \\\n   s-stratt$(objext) \\\n   s-strops$(objext) \\\n+  s-ststop$(objext) \\\n   s-soflin$(objext) \\\n   s-memory$(objext) \\\n   s-memcop$(objext) \\"}, {"sha": "e946c5ea79350037d701a0c17f7b1ff8f7f12980", "filename": "gcc/ada/a-calcon.adb", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calcon.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calcon.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calcon.adb?ref=cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "patch": "@@ -0,0 +1,150 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C A L E N D A R . C O N V E R S I O N S             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2008, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces.C; use Interfaces.C;\n+\n+package body Ada.Calendar.Conversions is\n+\n+   -----------------\n+   -- To_Ada_Time --\n+   -----------------\n+\n+   function To_Ada_Time (Unix_Time : long) return Time is\n+      Val : constant Long_Integer := Long_Integer (Unix_Time);\n+   begin\n+      return Conversion_Operations.To_Ada_Time (Val);\n+   end To_Ada_Time;\n+\n+   -----------------\n+   -- To_Ada_Time --\n+   -----------------\n+\n+   function To_Ada_Time\n+     (tm_year  : int;\n+      tm_mon   : int;\n+      tm_day   : int;\n+      tm_hour  : int;\n+      tm_min   : int;\n+      tm_sec   : int;\n+      tm_isdst : int) return Time\n+   is\n+      Year   : constant Integer := Integer (tm_year);\n+      Month  : constant Integer := Integer (tm_mon);\n+      Day    : constant Integer := Integer (tm_day);\n+      Hour   : constant Integer := Integer (tm_hour);\n+      Minute : constant Integer := Integer (tm_min);\n+      Second : constant Integer := Integer (tm_sec);\n+      DST    : constant Integer := Integer (tm_isdst);\n+   begin\n+      return\n+        Conversion_Operations.To_Ada_Time\n+          (Year, Month, Day, Hour, Minute, Second, DST);\n+   end To_Ada_Time;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration\n+     (tv_sec  : long;\n+      tv_nsec : long) return Duration\n+   is\n+      Secs      : constant Long_Integer := Long_Integer (tv_sec);\n+      Nano_Secs : constant Long_Integer := Long_Integer (tv_nsec);\n+   begin\n+      return Conversion_Operations.To_Duration (Secs, Nano_Secs);\n+   end To_Duration;\n+\n+   ------------------------\n+   -- To_Struct_Timespec --\n+   ------------------------\n+\n+   procedure To_Struct_Timespec\n+     (D       : Duration;\n+      tv_sec  : out long;\n+      tv_nsec : out long)\n+   is\n+      Secs      : Long_Integer;\n+      Nano_Secs : Long_Integer;\n+\n+   begin\n+      Conversion_Operations.To_Struct_Timespec (D, Secs, Nano_Secs);\n+\n+      tv_sec  := long (Secs);\n+      tv_nsec := long (Nano_Secs);\n+   end To_Struct_Timespec;\n+\n+   ------------------\n+   -- To_Struct_Tm --\n+   ------------------\n+\n+   procedure To_Struct_Tm\n+     (T       : Time;\n+      tm_year : out int;\n+      tm_mon  : out int;\n+      tm_day  : out int;\n+      tm_hour : out int;\n+      tm_min  : out int;\n+      tm_sec  : out int)\n+   is\n+      Year   : Integer;\n+      Month  : Integer;\n+      Day    : Integer;\n+      Hour   : Integer;\n+      Minute : Integer;\n+      Second : Integer;\n+\n+   begin\n+      Conversion_Operations.To_Struct_Tm\n+        (T, Year, Month, Day, Hour, Minute, Second);\n+\n+      tm_year := int (Year);\n+      tm_mon  := int (Month);\n+      tm_day  := int (Day);\n+      tm_hour := int (Hour);\n+      tm_min  := int (Minute);\n+      tm_sec  := int (Second);\n+   end To_Struct_Tm;\n+\n+   ------------------\n+   -- To_Unix_Time --\n+   ------------------\n+\n+   function To_Unix_Time (Ada_Time : Time) return long is\n+      Val : constant Long_Integer :=\n+              Conversion_Operations.To_Unix_Time (Ada_Time);\n+   begin\n+      return long (Val);\n+   end To_Unix_Time;\n+\n+end Ada.Calendar.Conversions;"}, {"sha": "d2dd3fbcc10f628a1062275cfe4a7aac1d01a072", "filename": "gcc/ada/a-calcon.ads", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calcon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calcon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calcon.ads?ref=cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "patch": "@@ -0,0 +1,116 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C A L E N D A R . C O N V E R S I O N S             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2008, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides various routines for conversion between Ada and Unix\n+--  time models - Time, Duration, struct tm and struct timespec.\n+\n+with Interfaces.C;\n+\n+package Ada.Calendar.Conversions is\n+\n+   function To_Ada_Time (Unix_Time : Interfaces.C.long) return Time;\n+   --  Convert a time value represented as number of seconds since the Unix\n+   --  Epoch to a time value relative to an Ada implementation-defined Epoch.\n+   --  The units of the result are 100 nanoseconds on VMS and nanoseconds on\n+   --  all other targets. Raises Time_Error if the result cannot fit into a\n+   --  Time value.\n+\n+   function To_Ada_Time\n+     (tm_year  : Interfaces.C.int;\n+      tm_mon   : Interfaces.C.int;\n+      tm_day   : Interfaces.C.int;\n+      tm_hour  : Interfaces.C.int;\n+      tm_min   : Interfaces.C.int;\n+      tm_sec   : Interfaces.C.int;\n+      tm_isdst : Interfaces.C.int) return Time;\n+   --  Convert a time value expressed in Unix-like fields of struct tm into\n+   --  a Time value relative to the Ada Epoch. The ranges of the formals are\n+   --  as follows:\n+\n+   --     tm_year   --  years since 1900\n+   --     tm_mon    --  months since January [0 .. 11]\n+   --     tm_day    --  day of the month [1 .. 31]\n+   --     tm_hour   --  hours since midnight [0 .. 24]\n+   --     tm_min    --  minutes after the hour [0 .. 59]\n+   --     tm_sec    --  seconds after the minute [0 .. 60]\n+   --     tm_isdst  --  Daylight Savings Time flag [-1 .. 1]\n+\n+   --  The returned value is in UTC and may or may not contain leap seconds\n+   --  depending on whether binder flag \"-y\" was used. Raises Time_Error if\n+   --  the input values are out of the defined ranges or if tm_sec equals 60\n+   --  and the instance in time is not a leap second occurence.\n+\n+   function To_Duration\n+     (tv_sec  : Interfaces.C.long;\n+      tv_nsec : Interfaces.C.long) return Duration;\n+   --  Convert an elapsed time value expressed in Unix-like fields of struct\n+   --  timespec into a Duration value. The expected ranges are:\n+\n+   --     tv_sec   -  seconds\n+   --     tv_nsec  -  nanoseconds\n+\n+   procedure To_Struct_Timespec\n+     (D       : Duration;\n+      tv_sec  : out Interfaces.C.long;\n+      tv_nsec : out Interfaces.C.long);\n+   --  Convert a Duration value into the constituents of struct timespec.\n+   --  Formal tv_sec denotes seconds and tv_nsecs denotes nanoseconds.\n+\n+   procedure To_Struct_Tm\n+     (T       : Time;\n+      tm_year : out Interfaces.C.int;\n+      tm_mon  : out Interfaces.C.int;\n+      tm_day  : out Interfaces.C.int;\n+      tm_hour : out Interfaces.C.int;\n+      tm_min  : out Interfaces.C.int;\n+      tm_sec  : out Interfaces.C.int);\n+   --  Convert a Time value set in the Ada Epoch into the constituents of\n+   --  struct tm. The ranges of the out formals are as follows:\n+\n+   --     tm_year   --  years since 1900\n+   --     tm_mon    --  months since January [0 .. 11]\n+   --     tm_day    --  day of the month [1 .. 31]\n+   --     tm_hour   --  hours since midnight [0 .. 24]\n+   --     tm_min    --  minutes after the hour [0 .. 59]\n+   --     tm_sec    --  seconds after the minute [0 .. 60]\n+   --     tm_isdst  --  Daylight Savings Time flag [-1 .. 1]\n+\n+   --  The input date is considered to be in UTC\n+\n+   function To_Unix_Time (Ada_Time : Time) return Interfaces.C.long;\n+   --  Convert a time value represented as number of time units since the Ada\n+   --  implementation-defined Epoch to a value relative to the Unix Epoch. The\n+   --  units of the result are seconds. Raises Time_Error if the result cannot\n+   --  fit into a Time value.\n+\n+end Ada.Calendar.Conversions;"}, {"sha": "17b399777145e2e900bb1c0fe5056531eaee0a88", "filename": "gcc/ada/a-caldel.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-caldel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-caldel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-caldel.adb?ref=cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "patch": "@@ -116,15 +116,13 @@ package body Ada.Calendar.Delays is\n       --  target independent operation in Ada.Calendar is used to perform\n       --  this conversion.\n \n-      return Delays_Operations.To_Duration (T);\n+      return Delay_Operations.To_Duration (T);\n    end To_Duration;\n \n begin\n    --  Set up the Timed_Delay soft link to the non tasking version if it has\n-   --  not been already set.\n-\n-   --  If tasking is present, Timed_Delay has already set this soft link, or\n-   --  this will be overridden during the elaboration of\n+   --  not been already set. If tasking is present, Timed_Delay has already set\n+   --  this soft link, or this will be overridden during the elaboration of\n    --  System.Tasking.Initialization\n \n    if SSL.Timed_Delay = null then"}, {"sha": "86e77cb66a6102c7a2c90acba67279afc62f55f0", "filename": "gcc/ada/a-calend-vms.adb", "status": "modified", "additions": 273, "deletions": 69, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calend-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calend-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.adb?ref=cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,10 +33,11 @@\n \n --  This is the Alpha/VMS version\n \n-with System.Aux_DEC; use System.Aux_DEC;\n-\n with Ada.Unchecked_Conversion;\n \n+with System.Aux_DEC;       use System.Aux_DEC;\n+with System.OS_Primitives; use System.OS_Primitives;\n+\n package body Ada.Calendar is\n \n    --------------------------\n@@ -77,15 +78,15 @@ package body Ada.Calendar is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Check_Within_Time_Bounds (T : Time);\n+   procedure Check_Within_Time_Bounds (T : OS_Time);\n    --  Ensure that a time representation value falls withing the bounds of Ada\n    --  time. Leap seconds support is taken into account.\n \n    procedure Cumulative_Leap_Seconds\n-     (Start_Date    : Time;\n-      End_Date      : Time;\n+     (Start_Date    : OS_Time;\n+      End_Date      : OS_Time;\n       Elapsed_Leaps : out Natural;\n-      Next_Leap_Sec : out Time);\n+      Next_Leap_Sec : out OS_Time);\n    --  Elapsed_Leaps is the sum of the leap seconds that have occurred on or\n    --  after Start_Date and before (strictly before) End_Date. Next_Leap_Sec\n    --  represents the next leap second occurrence on or after End_Date. If\n@@ -135,26 +136,26 @@ package body Ada.Calendar is\n \n    --  The range of Ada time expressed as milis since the VMS Epoch\n \n-   Ada_Low  : constant Time :=  (10 * 366 +  32 * 365 + 45) * Milis_In_Day;\n-   Ada_High : constant Time := (131 * 366 + 410 * 365 + 45) * Milis_In_Day;\n+   Ada_Low  : constant OS_Time :=  (10 * 366 +  32 * 365 + 45) * Milis_In_Day;\n+   Ada_High : constant OS_Time := (131 * 366 + 410 * 365 + 45) * Milis_In_Day;\n \n    --  Even though the upper bound of time is 2399-12-31 23:59:59.9999999\n    --  UTC, it must be increased to include all leap seconds.\n \n-   Ada_High_And_Leaps : constant Time :=\n-                          Ada_High + Time (Leap_Seconds_Count) * Mili;\n+   Ada_High_And_Leaps : constant OS_Time :=\n+                          Ada_High + OS_Time (Leap_Seconds_Count) * Mili;\n \n    --  Two constants used in the calculations of elapsed leap seconds.\n    --  End_Of_Time is later than Ada_High in time zone -28. Start_Of_Time\n    --  is earlier than Ada_Low in time zone +28.\n \n-   End_Of_Time   : constant Time := Ada_High + Time (3) * Milis_In_Day;\n-   Start_Of_Time : constant Time := Ada_Low  - Time (3) * Milis_In_Day;\n+   End_Of_Time   : constant OS_Time := Ada_High + OS_Time (3) * Milis_In_Day;\n+   Start_Of_Time : constant OS_Time := Ada_Low  - OS_Time (3) * Milis_In_Day;\n \n    --  The following table contains the hard time values of all existing leap\n    --  seconds. The values are produced by the utility program xleaps.adb.\n \n-   Leap_Second_Times : constant array (1 .. Leap_Seconds_Count) of Time :=\n+   Leap_Second_Times : constant array (1 .. Leap_Seconds_Count) of OS_Time :=\n      (35855136000000000,\n       36014112010000000,\n       36329472020000000,\n@@ -219,13 +220,15 @@ package body Ada.Calendar is\n \n       --  The bound of type Duration expressed as time\n \n-      Dur_High : constant Time := To_Relative_Time (Duration'Last);\n-      Dur_Low  : constant Time := To_Relative_Time (Duration'First);\n+      Dur_High : constant OS_Time :=\n+                   OS_Time (To_Relative_Time (Duration'Last));\n+      Dur_Low  : constant OS_Time :=\n+                   OS_Time (To_Relative_Time (Duration'First));\n \n-      Res_M : Time;\n+      Res_M : OS_Time;\n \n    begin\n-      Res_M := Left - Right;\n+      Res_M := OS_Time (Left) - OS_Time (Right);\n \n       --  Due to the extended range of Ada time, \"-\" is capable of producing\n       --  results which may exceed the range of Duration. In order to prevent\n@@ -240,7 +243,7 @@ package body Ada.Calendar is\n       --  Normal case, result fits\n \n       else\n-         return To_Duration (Res_M);\n+         return To_Duration (Time (Res_M));\n       end if;\n \n    exception\n@@ -254,7 +257,7 @@ package body Ada.Calendar is\n \n    function \"<\" (Left, Right : Time) return Boolean is\n    begin\n-      return Long_Integer (Left) < Long_Integer (Right);\n+      return OS_Time (Left) < OS_Time (Right);\n    end \"<\";\n \n    ----------\n@@ -263,7 +266,7 @@ package body Ada.Calendar is\n \n    function \"<=\" (Left, Right : Time) return Boolean is\n    begin\n-      return Long_Integer (Left) <= Long_Integer (Right);\n+      return OS_Time (Left) <= OS_Time (Right);\n    end \"<=\";\n \n    ---------\n@@ -272,7 +275,7 @@ package body Ada.Calendar is\n \n    function \">\" (Left, Right : Time) return Boolean is\n    begin\n-      return Long_Integer (Left) > Long_Integer (Right);\n+      return OS_Time (Left) > OS_Time (Right);\n    end \">\";\n \n    ----------\n@@ -281,14 +284,14 @@ package body Ada.Calendar is\n \n    function \">=\" (Left, Right : Time) return Boolean is\n    begin\n-      return Long_Integer (Left) >= Long_Integer (Right);\n+      return OS_Time (Left) >= OS_Time (Right);\n    end \">=\";\n \n    ------------------------------\n    -- Check_Within_Time_Bounds --\n    ------------------------------\n \n-   procedure Check_Within_Time_Bounds (T : Time) is\n+   procedure Check_Within_Time_Bounds (T : OS_Time) is\n    begin\n       if Leap_Support then\n          if T < Ada_Low or else T > Ada_High_And_Leaps then\n@@ -307,8 +310,8 @@ package body Ada.Calendar is\n \n    function Clock return Time is\n       Elapsed_Leaps : Natural;\n-      Next_Leap_M   : Time;\n-      Res_M         : constant Time := Time (OSP.OS_Clock);\n+      Next_Leap_M   : OS_Time;\n+      Res_M         : constant OS_Time := OS_Clock;\n \n    begin\n       --  Note that on other targets a soft-link is used to get a different\n@@ -335,23 +338,23 @@ package body Ada.Calendar is\n          Elapsed_Leaps := 0;\n       end if;\n \n-      return Res_M + Time (Elapsed_Leaps) * Mili;\n+      return Time (Res_M + OS_Time (Elapsed_Leaps) * Mili);\n    end Clock;\n \n    -----------------------------\n    -- Cumulative_Leap_Seconds --\n    -----------------------------\n \n    procedure Cumulative_Leap_Seconds\n-     (Start_Date    : Time;\n-      End_Date      : Time;\n+     (Start_Date    : OS_Time;\n+      End_Date      : OS_Time;\n       Elapsed_Leaps : out Natural;\n-      Next_Leap_Sec : out Time)\n+      Next_Leap_Sec : out OS_Time)\n    is\n       End_Index   : Positive;\n-      End_T       : Time := End_Date;\n+      End_T       : OS_Time := End_Date;\n       Start_Index : Positive;\n-      Start_T     : Time := Start_Date;\n+      Start_T     : OS_Time := Start_Date;\n \n    begin\n       pragma Assert (Leap_Support and then End_Date >= Start_Date);\n@@ -641,8 +644,9 @@ package body Ada.Calendar is\n \n       function Add (Date : Time; Days : Long_Integer) return Time is\n          pragma Unsuppress (Overflow_Check);\n+         Date_M : constant OS_Time := OS_Time (Date);\n       begin\n-         return Date + Time (Days) * Milis_In_Day;\n+         return Time (Date_M + OS_Time (Days) * Milis_In_Day);\n       exception\n          when Constraint_Error =>\n             raise Time_Error;\n@@ -659,27 +663,25 @@ package body Ada.Calendar is\n          Seconds      : out Duration;\n          Leap_Seconds : out Integer)\n       is\n-         Mili_F : constant Duration := 10_000_000.0;\n-\n-         Diff_M        : Time;\n-         Diff_S        : Time;\n-         Earlier       : Time;\n+         Diff_M        : OS_Time;\n+         Diff_S        : OS_Time;\n+         Earlier       : OS_Time;\n          Elapsed_Leaps : Natural;\n-         Later         : Time;\n+         Later         : OS_Time;\n          Negate        : Boolean := False;\n-         Next_Leap     : Time;\n+         Next_Leap     : OS_Time;\n          Sub_Seconds   : Duration;\n \n       begin\n          --  This classification is necessary in order to avoid a Time_Error\n          --  being raised by the arithmetic operators in Ada.Calendar.\n \n          if Left >= Right then\n-            Later   := Left;\n-            Earlier := Right;\n+            Later   := OS_Time (Left);\n+            Earlier := OS_Time (Right);\n          else\n-            Later   := Right;\n-            Earlier := Left;\n+            Later   := OS_Time (Right);\n+            Earlier := OS_Time (Left);\n             Negate  := True;\n          end if;\n \n@@ -699,7 +701,7 @@ package body Ada.Calendar is\n             Elapsed_Leaps := 0;\n          end if;\n \n-         Diff_M := Later - Earlier - Time (Elapsed_Leaps) * Mili;\n+         Diff_M := Later - Earlier - OS_Time (Elapsed_Leaps) * Mili;\n \n          --  Sub second processing\n \n@@ -730,14 +732,218 @@ package body Ada.Calendar is\n \n       function Subtract (Date : Time; Days : Long_Integer) return Time is\n          pragma Unsuppress (Overflow_Check);\n+         Date_M : constant OS_Time := OS_Time (Date);\n       begin\n-         return Date - Time (Days) * Milis_In_Day;\n+         return Time (Date_M - OS_Time (Days) * Milis_In_Day);\n       exception\n          when Constraint_Error =>\n             raise Time_Error;\n       end Subtract;\n    end Arithmetic_Operations;\n \n+   ---------------------------\n+   -- Conversion_Operations --\n+   ---------------------------\n+\n+   package body Conversion_Operations is\n+\n+      Epoch_Offset : constant OS_Time := 35067168000000000;\n+      --  The difference between 1970-1-1 UTC and 1858-11-17 UTC expressed in\n+      --  100 nanoseconds.\n+\n+      -----------------\n+      -- To_Ada_Time --\n+      -----------------\n+\n+      function To_Ada_Time (Unix_Time : Long_Integer) return Time is\n+         pragma Unsuppress (Overflow_Check);\n+         Unix_Rep : constant OS_Time := OS_Time (Unix_Time) * Mili;\n+      begin\n+         return Time (Unix_Rep + Epoch_Offset);\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end To_Ada_Time;\n+\n+      -----------------\n+      -- To_Ada_Time --\n+      -----------------\n+\n+      function To_Ada_Time\n+        (tm_year  : Integer;\n+         tm_mon   : Integer;\n+         tm_day   : Integer;\n+         tm_hour  : Integer;\n+         tm_min   : Integer;\n+         tm_sec   : Integer;\n+         tm_isdst : Integer) return Time\n+      is\n+         pragma Unsuppress (Overflow_Check);\n+\n+         Year_Shift  : constant Integer := 1900;\n+         Month_Shift : constant Integer := 1;\n+\n+         Year   : Year_Number;\n+         Month  : Month_Number;\n+         Day    : Day_Number;\n+         Second : Integer;\n+         Leap   : Boolean;\n+         Result : OS_Time;\n+\n+      begin\n+         --  Input processing\n+\n+         Year  := Year_Number (Year_Shift + tm_year);\n+         Month := Month_Number (Month_Shift + tm_mon);\n+         Day   := Day_Number (tm_day);\n+\n+         --  Step 1: Validity checks of input values\n+\n+         if not Year'Valid\n+           or else not Month'Valid\n+           or else not Day'Valid\n+           or else tm_hour not in 0 .. 24\n+           or else tm_min not in 0 .. 59\n+           or else tm_sec not in 0 .. 60\n+           or else tm_isdst not in -1 .. 1\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Step 2: Potential leap second\n+\n+         if tm_sec = 60 then\n+            Leap   := True;\n+            Second := 59;\n+         else\n+            Leap   := False;\n+            Second := tm_sec;\n+         end if;\n+\n+         --  Step 3: Calculate the time value\n+\n+         Result :=\n+           OS_Time\n+             (Formatting_Operations.Time_Of\n+               (Year         => Year,\n+                Month        => Month,\n+                Day          => Day,\n+                Day_Secs     => 0.0,      --  Time is given in h:m:s\n+                Hour         => tm_hour,\n+                Minute       => tm_min,\n+                Second       => Second,\n+                Sub_Sec      => 0.0,      --  No precise sub second given\n+                Leap_Sec     => Leap,\n+                Use_Day_Secs => False,    --  Time is given in h:m:s\n+                Is_Ada_05    => True,     --  Force usage of explicit time zone\n+                Time_Zone    => 0));      --  Place the value in UTC\n+         --  Step 4: Daylight Savings Time\n+\n+         if tm_isdst = 1 then\n+            Result := Result + OS_Time (3_600) * Mili;\n+         end if;\n+\n+         return Time (Result);\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end To_Ada_Time;\n+\n+      -----------------\n+      -- To_Duration --\n+      -----------------\n+\n+      function To_Duration\n+        (tv_sec  : Long_Integer;\n+         tv_nsec : Long_Integer) return Duration\n+      is\n+         pragma Unsuppress (Overflow_Check);\n+      begin\n+         return Duration (tv_sec) + Duration (tv_nsec) / Mili_F;\n+      end To_Duration;\n+\n+      ------------------------\n+      -- To_Struct_Timespec --\n+      ------------------------\n+\n+      procedure To_Struct_Timespec\n+        (D       : Duration;\n+         tv_sec  : out Long_Integer;\n+         tv_nsec : out Long_Integer)\n+      is\n+         pragma Unsuppress (Overflow_Check);\n+         Secs      : Duration;\n+         Nano_Secs : Duration;\n+\n+      begin\n+         --  Seconds extraction, avoid potential rounding errors\n+\n+         Secs   := D - 0.5;\n+         tv_sec := Long_Integer (Secs);\n+\n+         --  100 Nanoseconds extraction\n+\n+         Nano_Secs := D - Duration (tv_sec);\n+         tv_nsec := Long_Integer (Nano_Secs * Mili);\n+      end To_Struct_Timespec;\n+\n+      ------------------\n+      -- To_Struct_Tm --\n+      ------------------\n+\n+      procedure To_Struct_Tm\n+        (T       : Time;\n+         tm_year : out Integer;\n+         tm_mon  : out Integer;\n+         tm_day  : out Integer;\n+         tm_hour : out Integer;\n+         tm_min  : out Integer;\n+         tm_sec  : out Integer)\n+      is\n+         pragma Unsuppress (Overflow_Check);\n+         Year      : Year_Number;\n+         Month     : Month_Number;\n+         Second    : Integer;\n+         Day_Secs  : Day_Duration;\n+         Sub_Sec   : Duration;\n+         Leap_Sec  : Boolean;\n+\n+      begin\n+         --  Step 1: Split the input time\n+\n+         Formatting_Operations.Split\n+           (T, Year, Month, tm_day, Day_Secs,\n+            tm_hour, tm_min, Second, Sub_Sec, Leap_Sec, True, 0);\n+\n+         --  Step 2: Correct the year and month\n+\n+         tm_year := Year - 1900;\n+         tm_mon  := Month - 1;\n+\n+         --  Step 3: Handle leap second occurences\n+\n+         if Leap_Sec then\n+            tm_sec := 60;\n+         else\n+            tm_sec := Second;\n+         end if;\n+      end To_Struct_Tm;\n+\n+      ------------------\n+      -- To_Unix_Time --\n+      ------------------\n+\n+      function To_Unix_Time (Ada_Time : Time) return Long_Integer is\n+         pragma Unsuppress (Overflow_Check);\n+         Ada_OS_Time : constant OS_Time := OS_Time (Ada_Time);\n+      begin\n+         return Long_Integer ((Ada_OS_Time - Epoch_Offset) / Mili);\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end To_Unix_Time;\n+   end Conversion_Operations;\n+\n    ---------------------------\n    -- Formatting_Operations --\n    ---------------------------\n@@ -812,20 +1018,19 @@ package body Ada.Calendar is\n \n          Ada_Min_Year : constant := 1901;\n          Ada_Max_Year : constant := 2399;\n-         Mili_F       : constant Duration := 10_000_000.0;\n \n-         Date_M        : Time;\n+         Date_M        : OS_Time;\n          Elapsed_Leaps : Natural;\n-         Next_Leap_M   : Time;\n+         Next_Leap_M   : OS_Time;\n \n       begin\n-         Date_M := Date;\n+         Date_M := OS_Time (Date);\n \n          --  Step 1: Leap seconds processing\n \n          if Leap_Support then\n             Cumulative_Leap_Seconds\n-              (Start_Of_Time, Date, Elapsed_Leaps, Next_Leap_M);\n+              (Start_Of_Time, Date_M, Elapsed_Leaps, Next_Leap_M);\n \n             Leap_Sec := Date_M >= Next_Leap_M;\n \n@@ -840,12 +1045,12 @@ package body Ada.Calendar is\n             Leap_Sec      := False;\n          end if;\n \n-         Date_M := Date_M - Time (Elapsed_Leaps) * Mili;\n+         Date_M := Date_M - OS_Time (Elapsed_Leaps) * Mili;\n \n          --  Step 2: Time zone processing\n \n          if Time_Zone /= 0 then\n-            Date_M := Date_M + Time (Time_Zone) * 60 * Mili;\n+            Date_M := Date_M + OS_Time (Time_Zone) * 60 * Mili;\n          end if;\n \n          --  After the leap seconds and time zone have been accounted for,\n@@ -867,7 +1072,7 @@ package body Ada.Calendar is\n \n          --  Step 4: VMS system call\n \n-         Numtim (Status, Timbuf, Date_M);\n+         Numtim (Status, Timbuf, Time (Date_M));\n \n          if Status mod 2 /= 1\n            or else Timbuf (1) not in Ada_Min_Year .. Ada_Max_Year\n@@ -903,10 +1108,10 @@ package body Ada.Calendar is\n          Minute       : Integer;\n          Second       : Integer;\n          Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean;\n-         Use_Day_Secs : Boolean;\n-         Is_Ada_05    : Boolean;\n-         Time_Zone    : Long_Integer) return Time\n+         Leap_Sec     : Boolean := False;\n+         Use_Day_Secs : Boolean := False;\n+         Is_Ada_05    : Boolean := False;\n+         Time_Zone    : Long_Integer := 0) return Time\n       is\n          procedure Cvt_Vectim\n            (Status         : out Unsigned_Longword;\n@@ -923,8 +1128,6 @@ package body Ada.Calendar is\n          Status : Unsigned_Longword;\n          Timbuf : Unsigned_Word_Array (1 .. 7);\n \n-         Mili_F : constant := 10_000_000.0;\n-\n          Y  : Year_Number  := Year;\n          Mo : Month_Number := Month;\n          D  : Day_Number   := Day;\n@@ -935,9 +1138,10 @@ package body Ada.Calendar is\n \n          Elapsed_Leaps : Natural;\n          Int_Day_Secs  : Integer;\n-         Next_Leap_M   : Time;\n-         Res_M         : Time;\n-         Rounded_Res_M : Time;\n+         Next_Leap_M   : OS_Time;\n+         Res           : Time;\n+         Res_M         : OS_Time;\n+         Rounded_Res_M : OS_Time;\n \n       begin\n          --  No validity checks are performed on the input values since it is\n@@ -1015,15 +1219,15 @@ package body Ada.Calendar is\n          Timbuf (6) := Unsigned_Word (Se);\n          Timbuf (7) := 0;\n \n-         Cvt_Vectim (Status, Timbuf, Res_M);\n+         Cvt_Vectim (Status, Timbuf, Res);\n \n          if Status mod 2 /= 1 then\n             raise Time_Error;\n          end if;\n \n          --  Step 3: Sub second adjustment\n \n-         Res_M := Res_M + Time (Su * Mili_F);\n+         Res_M := OS_Time (Res) + OS_Time (Su * Mili_F);\n \n          --  Step 4: Bounds check\n \n@@ -1032,7 +1236,7 @@ package body Ada.Calendar is\n          --  Step 5: Time zone processing\n \n          if Time_Zone /= 0 then\n-            Res_M := Res_M - Time (Time_Zone) * 60 * Mili;\n+            Res_M := Res_M - OS_Time (Time_Zone) * 60 * Mili;\n          end if;\n \n          --  Step 6: Leap seconds processing\n@@ -1041,15 +1245,15 @@ package body Ada.Calendar is\n             Cumulative_Leap_Seconds\n               (Start_Of_Time, Res_M, Elapsed_Leaps, Next_Leap_M);\n \n-            Res_M := Res_M + Time (Elapsed_Leaps) * Mili;\n+            Res_M := Res_M + OS_Time (Elapsed_Leaps) * Mili;\n \n             --  An Ada 2005 caller requesting an explicit leap second or an\n             --  Ada 95 caller accounting for an invisible leap second.\n \n             if Leap_Sec\n               or else Res_M >= Next_Leap_M\n             then\n-               Res_M := Res_M + Time (1) * Mili;\n+               Res_M := Res_M + OS_Time (1) * Mili;\n             end if;\n \n             --  Leap second validity check\n@@ -1064,7 +1268,7 @@ package body Ada.Calendar is\n             end if;\n          end if;\n \n-         return Res_M;\n+         return Time (Res_M);\n       end Time_Of;\n    end Formatting_Operations;\n "}, {"sha": "c11093df238232658c39c9c3cae460d5bfd95a2b", "filename": "gcc/ada/a-calend-vms.ads", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calend-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calend-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.ads?ref=cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -107,6 +107,7 @@ private\n    --  readability, this unit will be called \"mili\".\n \n    Mili         : constant := 10_000_000;\n+   Mili_F       : constant := 10_000_000.0;\n    Milis_In_Day : constant := 864_000_000_000;\n    Secs_In_Day  : constant := 86_400;\n \n@@ -139,7 +140,12 @@ private\n    --  NOTE: Delays does not need a target independent interface because\n    --  VMS already has a target specific file for that package.\n \n+   ---------------------------\n+   -- Arithmetic_Operations --\n+   ---------------------------\n+\n    package Arithmetic_Operations is\n+\n       function Add (Date : Time; Days : Long_Integer) return Time;\n       --  Add a certain number of days to a time value\n \n@@ -156,9 +162,59 @@ private\n \n       function Subtract (Date : Time; Days : Long_Integer) return Time;\n       --  Subtract a certain number of days from a time value\n+\n    end Arithmetic_Operations;\n \n+   ---------------------------\n+   -- Conversion_Operations --\n+   ---------------------------\n+\n+   package Conversion_Operations is\n+      function To_Ada_Time (Unix_Time : Long_Integer) return Time;\n+      --  Unix to Ada Epoch conversion\n+\n+      function To_Ada_Time\n+        (tm_year  : Integer;\n+         tm_mon   : Integer;\n+         tm_day   : Integer;\n+         tm_hour  : Integer;\n+         tm_min   : Integer;\n+         tm_sec   : Integer;\n+         tm_isdst : Integer) return Time;\n+      --  Struct tm to Ada Epoch conversion\n+\n+      function To_Duration\n+        (tv_sec  : Long_Integer;\n+         tv_nsec : Long_Integer) return Duration;\n+      --  Struct timespec to Duration conversion\n+\n+      procedure To_Struct_Timespec\n+        (D       : Duration;\n+         tv_sec  : out Long_Integer;\n+         tv_nsec : out Long_Integer);\n+      --  Duration to struct timespec conversion\n+\n+      procedure To_Struct_Tm\n+        (T       : Time;\n+         tm_year : out Integer;\n+         tm_mon  : out Integer;\n+         tm_day  : out Integer;\n+         tm_hour : out Integer;\n+         tm_min  : out Integer;\n+         tm_sec  : out Integer);\n+      --  Time to struct tm conversion\n+\n+      function To_Unix_Time (Ada_Time : Time) return Long_Integer;\n+      --  Ada to Unix Epoch conversion\n+\n+   end Conversion_Operations;\n+\n+   ---------------------------\n+   -- Formatting_Operations --\n+   ---------------------------\n+\n    package Formatting_Operations is\n+\n       function Day_Of_Week (Date : Time) return Integer;\n       --  Determine which day of week Date falls on. The returned values are\n       --  within the range of 0 .. 6 (Monday .. Sunday).\n@@ -189,21 +245,28 @@ private\n          Minute       : Integer;\n          Second       : Integer;\n          Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean;\n-         Use_Day_Secs : Boolean;\n-         Is_Ada_05    : Boolean;\n-         Time_Zone    : Long_Integer) return Time;\n+         Leap_Sec     : Boolean := False;\n+         Use_Day_Secs : Boolean := False;\n+         Is_Ada_05    : Boolean := False;\n+         Time_Zone    : Long_Integer := 0) return Time;\n       --  Given all the components of a date, return the corresponding time\n       --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n       --  day duration will be calculated from Hour, Minute, Second and Sub_\n       --  Sec. Set Is_Ada_05 to use the local time zone (the value in formal\n       --  Time_Zone is ignored) when building a time value and to verify the\n       --  validity of a requested leap second.\n+\n    end Formatting_Operations;\n \n+   ---------------------------\n+   -- Time_Zones_Operations --\n+   ---------------------------\n+\n    package Time_Zones_Operations is\n+\n       function UTC_Time_Offset (Date : Time) return Long_Integer;\n       --  Return the offset in seconds from UTC\n+\n    end Time_Zones_Operations;\n \n end Ada.Calendar;"}, {"sha": "2e7c61a9d7f7b6304dcfbd31d6f2d0829445d1f0", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 212, "deletions": 6, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "patch": "@@ -758,13 +758,216 @@ package body Ada.Calendar is\n          when Constraint_Error =>\n             raise Time_Error;\n       end Subtract;\n+\n    end Arithmetic_Operations;\n \n+   ---------------------------\n+   -- Conversion_Operations --\n+   ---------------------------\n+\n+   package body Conversion_Operations is\n+\n+      Epoch_Offset : constant Time_Rep :=\n+                       (136 * 365 + 44 * 366) * Nanos_In_Day;\n+      --  The difference between 2150-1-1 UTC and 1970-1-1 UTC expressed in\n+      --  nanoseconds. Note that year 2100 is non-leap.\n+\n+      -----------------\n+      -- To_Ada_Time --\n+      -----------------\n+\n+      function To_Ada_Time (Unix_Time : Long_Integer) return Time is\n+         pragma Unsuppress (Overflow_Check);\n+         Unix_Rep : constant Time_Rep := Time_Rep (Unix_Time) * Nano;\n+      begin\n+         return Time (Unix_Rep - Epoch_Offset);\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end To_Ada_Time;\n+\n+      -----------------\n+      -- To_Ada_Time --\n+      -----------------\n+\n+      function To_Ada_Time\n+        (tm_year  : Integer;\n+         tm_mon   : Integer;\n+         tm_day   : Integer;\n+         tm_hour  : Integer;\n+         tm_min   : Integer;\n+         tm_sec   : Integer;\n+         tm_isdst : Integer) return Time\n+      is\n+         pragma Unsuppress (Overflow_Check);\n+         Year   : Year_Number;\n+         Month  : Month_Number;\n+         Day    : Day_Number;\n+         Second : Integer;\n+         Leap   : Boolean;\n+         Result : Time_Rep;\n+\n+      begin\n+         --  Input processing\n+\n+         Year  := Year_Number (1900 + tm_year);\n+         Month := Month_Number (1 + tm_mon);\n+         Day   := Day_Number (tm_day);\n+\n+         --  Step 1: Validity checks of input values\n+\n+         if not Year'Valid\n+           or else not Month'Valid\n+           or else not Day'Valid\n+           or else tm_hour not in 0 .. 24\n+           or else tm_min not in 0 .. 59\n+           or else tm_sec not in 0 .. 60\n+           or else tm_isdst not in -1 .. 1\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Step 2: Potential leap second\n+\n+         if tm_sec = 60 then\n+            Leap   := True;\n+            Second := 59;\n+         else\n+            Leap   := False;\n+            Second := tm_sec;\n+         end if;\n+\n+         --  Step 3: Calculate the time value\n+\n+         Result :=\n+           Time_Rep\n+             (Formatting_Operations.Time_Of\n+               (Year         => Year,\n+                Month        => Month,\n+                Day          => Day,\n+                Day_Secs     => 0.0,      --  Time is given in h:m:s\n+                Hour         => tm_hour,\n+                Minute       => tm_min,\n+                Second       => Second,\n+                Sub_Sec      => 0.0,      --  No precise sub second given\n+                Leap_Sec     => Leap,\n+                Use_Day_Secs => False,    --  Time is given in h:m:s\n+                Is_Ada_05    => True,     --  Force usage of explicit time zone\n+                Time_Zone    => 0));      --  Place the value in UTC\n+\n+         --  Step 4: Daylight Savings Time\n+\n+         if tm_isdst = 1 then\n+            Result := Result + Time_Rep (3_600) * Nano;\n+         end if;\n+\n+         return Time (Result);\n+\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end To_Ada_Time;\n+\n+      -----------------\n+      -- To_Duration --\n+      -----------------\n+\n+      function To_Duration\n+        (tv_sec  : Long_Integer;\n+         tv_nsec : Long_Integer) return Duration\n+      is\n+         pragma Unsuppress (Overflow_Check);\n+      begin\n+         return Duration (tv_sec) + Duration (tv_nsec) / Nano_F;\n+      end To_Duration;\n+\n+      ------------------------\n+      -- To_Struct_Timespec --\n+      ------------------------\n+\n+      procedure To_Struct_Timespec\n+        (D       : Duration;\n+         tv_sec  : out Long_Integer;\n+         tv_nsec : out Long_Integer)\n+      is\n+         pragma Unsuppress (Overflow_Check);\n+         Secs      : Duration;\n+         Nano_Secs : Duration;\n+\n+      begin\n+         --  Seconds extraction, avoid potential rounding errors\n+\n+         Secs   := D - 0.5;\n+         tv_sec := Long_Integer (Secs);\n+\n+         --  Nanoseconds extraction\n+\n+         Nano_Secs := D - Duration (tv_sec);\n+         tv_nsec := Long_Integer (Nano_Secs * Nano);\n+      end To_Struct_Timespec;\n+\n+      ------------------\n+      -- To_Struct_Tm --\n+      ------------------\n+\n+      procedure To_Struct_Tm\n+        (T       : Time;\n+         tm_year : out Integer;\n+         tm_mon  : out Integer;\n+         tm_day  : out Integer;\n+         tm_hour : out Integer;\n+         tm_min  : out Integer;\n+         tm_sec  : out Integer)\n+      is\n+         pragma Unsuppress (Overflow_Check);\n+         Year      : Year_Number;\n+         Month     : Month_Number;\n+         Second    : Integer;\n+         Day_Secs  : Day_Duration;\n+         Sub_Sec   : Duration;\n+         Leap_Sec  : Boolean;\n+\n+      begin\n+         --  Step 1: Split the input time\n+\n+         Formatting_Operations.Split\n+           (T, Year, Month, tm_day, Day_Secs,\n+            tm_hour, tm_min, Second, Sub_Sec, Leap_Sec, True, 0);\n+\n+         --  Step 2: Correct the year and month\n+\n+         tm_year := Year - 1900;\n+         tm_mon  := Month - 1;\n+\n+         --  Step 3: Handle leap second occurences\n+\n+         if Leap_Sec then\n+            tm_sec := 60;\n+         else\n+            tm_sec := Second;\n+         end if;\n+      end To_Struct_Tm;\n+\n+      ------------------\n+      -- To_Unix_Time --\n+      ------------------\n+\n+      function To_Unix_Time (Ada_Time : Time) return Long_Integer is\n+         pragma Unsuppress (Overflow_Check);\n+         Ada_Rep : constant Time_Rep := Time_Rep (Ada_Time);\n+      begin\n+         return Long_Integer ((Ada_Rep + Epoch_Offset) / Nano);\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end To_Unix_Time;\n+   end Conversion_Operations;\n+\n    ----------------------\n    -- Delay_Operations --\n    ----------------------\n \n-   package body Delays_Operations is\n+   package body Delay_Operations is\n \n       -----------------\n       -- To_Duration --\n@@ -804,7 +1007,8 @@ package body Ada.Calendar is\n \n          return Time (Res_N) - Time (Unix_Min);\n       end To_Duration;\n-   end Delays_Operations;\n+\n+   end Delay_Operations;\n \n    ---------------------------\n    -- Formatting_Operations --\n@@ -1071,10 +1275,10 @@ package body Ada.Calendar is\n          Minute       : Integer;\n          Second       : Integer;\n          Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean;\n-         Use_Day_Secs : Boolean;\n-         Is_Ada_05    : Boolean;\n-         Time_Zone    : Long_Integer) return Time\n+         Leap_Sec     : Boolean := False;\n+         Use_Day_Secs : Boolean := False;\n+         Is_Ada_05    : Boolean := False;\n+         Time_Zone    : Long_Integer := 0) return Time\n       is\n          Count         : Integer;\n          Elapsed_Leaps : Natural;\n@@ -1217,6 +1421,7 @@ package body Ada.Calendar is\n \n          return Time (Res_N);\n       end Time_Of;\n+\n    end Formatting_Operations;\n \n    ---------------------------\n@@ -1352,6 +1557,7 @@ package body Ada.Calendar is\n \n          return Offset;\n       end UTC_Time_Offset;\n+\n    end Time_Zones_Operations;\n \n --  Start of elaboration code for Ada.Calendar"}, {"sha": "77b466a87c4cf0bcca3480a424d180f7de1019cd", "filename": "gcc/ada/a-calend.ads", "status": "modified", "additions": 78, "deletions": 8, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c/gcc%2Fada%2Fa-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.ads?ref=cf177287b1d1d835a2e3d169d8c4a3fe3eb6ae5c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -212,9 +212,15 @@ private\n    --  Determine whether a given year is leap\n \n    --  The following packages provide a target independent interface to the\n-   --  children of Calendar - Arithmetic, Delays, Formatting and Time_Zones.\n+   --  children of Calendar - Arithmetic, Conversions, Delays, Formatting and\n+   --  Time_Zones.\n+\n+   ---------------------------\n+   -- Arithmetic_Operations --\n+   ---------------------------\n \n    package Arithmetic_Operations is\n+\n       function Add (Date : Time; Days : Long_Integer) return Time;\n       --  Add a certain number of days to a time value\n \n@@ -231,15 +237,72 @@ private\n \n       function Subtract (Date : Time; Days : Long_Integer) return Time;\n       --  Subtract a certain number of days from a time value\n+\n    end Arithmetic_Operations;\n \n-   package Delays_Operations is\n+   ---------------------------\n+   -- Conversion_Operations --\n+   ---------------------------\n+\n+   package Conversion_Operations is\n+\n+      function To_Ada_Time (Unix_Time : Long_Integer) return Time;\n+      --  Unix to Ada Epoch conversion\n+\n+      function To_Ada_Time\n+        (tm_year  : Integer;\n+         tm_mon   : Integer;\n+         tm_day   : Integer;\n+         tm_hour  : Integer;\n+         tm_min   : Integer;\n+         tm_sec   : Integer;\n+         tm_isdst : Integer) return Time;\n+      --  Struct tm to Ada Epoch conversion\n+\n+      function To_Duration\n+        (tv_sec  : Long_Integer;\n+         tv_nsec : Long_Integer) return Duration;\n+      --  Struct timespec to Duration conversion\n+\n+      procedure To_Struct_Timespec\n+        (D       : Duration;\n+         tv_sec  : out Long_Integer;\n+         tv_nsec : out Long_Integer);\n+      --  Duration to struct timespec conversion\n+\n+      procedure To_Struct_Tm\n+        (T       : Time;\n+         tm_year : out Integer;\n+         tm_mon  : out Integer;\n+         tm_day  : out Integer;\n+         tm_hour : out Integer;\n+         tm_min  : out Integer;\n+         tm_sec  : out Integer);\n+      --  Time to struct tm conversion\n+\n+      function To_Unix_Time (Ada_Time : Time) return Long_Integer;\n+      --  Ada to Unix Epoch conversion\n+\n+   end Conversion_Operations;\n+\n+   ----------------------\n+   -- Delay_Operations --\n+   ----------------------\n+\n+   package Delay_Operations is\n+\n       function To_Duration (Date : Time) return Duration;\n       --  Given a time value in nanoseconds since 1901, convert it into a\n       --  duration value giving the number of nanoseconds since the Unix Epoch.\n-   end Delays_Operations;\n+\n+   end Delay_Operations;\n+\n+   ---------------------------\n+   -- Formatting_Operations --\n+   ---------------------------\n \n    package Formatting_Operations is\n+\n       function Day_Of_Week (Date : Time) return Integer;\n       --  Determine which day of week Date falls on. The returned values are\n       --  within the range of 0 .. 6 (Monday .. Sunday).\n@@ -270,21 +333,28 @@ private\n          Minute       : Integer;\n          Second       : Integer;\n          Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean;\n-         Use_Day_Secs : Boolean;\n-         Is_Ada_05    : Boolean;\n-         Time_Zone    : Long_Integer) return Time;\n+         Leap_Sec     : Boolean := False;\n+         Use_Day_Secs : Boolean := False;\n+         Is_Ada_05    : Boolean := False;\n+         Time_Zone    : Long_Integer := 0) return Time;\n       --  Given all the components of a date, return the corresponding time\n       --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n       --  day duration will be calculated from Hour, Minute, Second and Sub_\n       --  Sec. Set Is_Ada_05 to use the local time zone (the value in formal\n       --  Time_Zone is ignored) when building a time value and to verify the\n       --  validity of a requested leap second.\n+\n    end Formatting_Operations;\n \n+   ---------------------------\n+   -- Time_Zones_Operations --\n+   ---------------------------\n+\n    package Time_Zones_Operations is\n+\n       function UTC_Time_Offset (Date : Time) return Long_Integer;\n       --  Return the offset in seconds from UTC\n+\n    end Time_Zones_Operations;\n \n end Ada.Calendar;"}]}