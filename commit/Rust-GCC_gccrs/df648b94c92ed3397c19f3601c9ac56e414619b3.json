{"sha": "df648b94c92ed3397c19f3601c9ac56e414619b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY2NDhiOTRjOTJlZDMzOTdjMTlmMzYwMWM5YWM1NmU0MTQ2MTliMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-08-03T21:21:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-08-03T21:21:22Z"}, "message": "domwalk.c (walk_dominator_tree): Reorganize to non-recursive implementation.\n\n\t* domwalk.c (walk_dominator_tree): Reorganize to non-recursive\n\timplementation.\n\nFrom-SVN: r115912", "tree": {"sha": "f245ee60a6a00781e58d4e69fefcd27d72e1f3ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f245ee60a6a00781e58d4e69fefcd27d72e1f3ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df648b94c92ed3397c19f3601c9ac56e414619b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df648b94c92ed3397c19f3601c9ac56e414619b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df648b94c92ed3397c19f3601c9ac56e414619b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df648b94c92ed3397c19f3601c9ac56e414619b3/comments", "author": null, "committer": null, "parents": [{"sha": "d508327cc8b4601cdc0aefe8cbe7bb4c5103ce91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d508327cc8b4601cdc0aefe8cbe7bb4c5103ce91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d508327cc8b4601cdc0aefe8cbe7bb4c5103ce91"}], "stats": {"total": 203, "additions": 116, "deletions": 87}, "files": [{"sha": "39e5cfa015f8e22d0c20bb4836be165a94ee5dd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df648b94c92ed3397c19f3601c9ac56e414619b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df648b94c92ed3397c19f3601c9ac56e414619b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df648b94c92ed3397c19f3601c9ac56e414619b3", "patch": "@@ -1,3 +1,8 @@\n+2006-08-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* domwalk.c (walk_dominator_tree): Reorganize to non-recursive\n+\timplementation.\n+\n 2006-08-03  Dorit Nuzman  <dorit@il.ibm.com>\n \n         PR tree-optimization/27770"}, {"sha": "04a490903b05894fc627e6ca2a4b04bde3a250d7", "filename": "gcc/domwalk.c", "status": "modified", "additions": 111, "deletions": 87, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df648b94c92ed3397c19f3601c9ac56e414619b3/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df648b94c92ed3397c19f3601c9ac56e414619b3/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=df648b94c92ed3397c19f3601c9ac56e414619b3", "patch": "@@ -146,101 +146,125 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n   basic_block dest;\n   block_stmt_iterator bsi;\n   bool is_interesting;\n+  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks * 2);\n+  int sp = 0;\n \n-  /* If block BB is not interesting to the caller, then none of the\n-     callbacks that walk the statements in BB are going to be\n-     executed.  */\n-  is_interesting = bb->index < 0\n-\t\t   || walk_data->interesting_blocks == NULL\n-\t\t   || TEST_BIT (walk_data->interesting_blocks, bb->index);\n-\n-  /* Callback to initialize the local data structure.  */\n-  if (walk_data->initialize_block_local_data)\n+  while (true)\n     {\n-      bool recycled;\n-\n-      /* First get some local data, reusing any local data pointer we may\n-\t have saved.  */\n-      if (VEC_length (void_p, walk_data->free_block_data) > 0)\n+      /* Don't worry about unreachable blocks.  */\n+      if (EDGE_COUNT (bb->preds) > 0 || bb == ENTRY_BLOCK_PTR)\n \t{\n-\t  bd = VEC_pop (void_p, walk_data->free_block_data);\n-\t  recycled = 1;\n+\t  /* If block BB is not interesting to the caller, then none of the\n+\t     callbacks that walk the statements in BB are going to be\n+\t     executed.  */\n+\t  is_interesting = walk_data->interesting_blocks == NULL\n+\t                   || TEST_BIT (walk_data->interesting_blocks,\n+\t\t\t\t\tbb->index);\n+\n+\t  /* Callback to initialize the local data structure.  */\n+\t  if (walk_data->initialize_block_local_data)\n+\t    {\n+\t      bool recycled;\n+\n+\t      /* First get some local data, reusing any local data pointer we may\n+\t         have saved.  */\n+\t      if (VEC_length (void_p, walk_data->free_block_data) > 0)\n+\t\t{\n+\t\t  bd = VEC_pop (void_p, walk_data->free_block_data);\n+\t\t  recycled = 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  bd = xcalloc (1, walk_data->block_local_data_size);\n+\t\t  recycled = 0;\n+\t\t}\n+\n+\t      /* Push the local data into the local data stack.  */\n+\t      VEC_safe_push (void_p, heap, walk_data->block_data_stack, bd);\n+\n+\t      /* Call the initializer.  */\n+\t      walk_data->initialize_block_local_data (walk_data, bb,\n+\t\t\t\t\t\t      recycled);\n+\n+\t    }\n+\n+\t  /* Callback for operations to execute before we have walked the\n+\t     dominator children, but before we walk statements.  */\n+\t  if (walk_data->before_dom_children_before_stmts)\n+\t    (*walk_data->before_dom_children_before_stmts) (walk_data, bb);\n+\n+\t  /* Statement walk before walking dominator children.  */\n+\t  if (is_interesting && walk_data->before_dom_children_walk_stmts)\n+\t    {\n+\t      if (walk_data->walk_stmts_backward)\n+\t\tfor (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n+\t\t  (*walk_data->before_dom_children_walk_stmts) (walk_data, bb,\n+\t\t\t\t\t\t\t\tbsi);\n+\t      else\n+\t\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t\t  (*walk_data->before_dom_children_walk_stmts) (walk_data, bb,\n+\t\t\t\t\t\t\t\tbsi);\n+\t    }\n+\n+\t  /* Callback for operations to execute before we have walked the\n+\t     dominator children, and after we walk statements.  */\n+\t  if (walk_data->before_dom_children_after_stmts)\n+\t    (*walk_data->before_dom_children_after_stmts) (walk_data, bb);\n+\n+\t  /* Mark the current BB to be popped out of the recursion stack\n+\t     once childs are processed.  */\n+\t  worklist[sp++] = bb;\n+\t  worklist[sp++] = NULL;\n+\n+\t  for (dest = first_dom_son (walk_data->dom_direction, bb);\n+\t       dest; dest = next_dom_son (walk_data->dom_direction, dest))\n+\t    worklist[sp++] = dest;\n \t}\n-      else\n+      /* NULL is used to signalize pop operation in recursion stack.  */\n+      while (sp > 0 && !worklist[sp - 1])\n \t{\n-\t  bd = xcalloc (1, walk_data->block_local_data_size);\n-\t  recycled = 0;\n+\t  --sp;\n+\t  bb = worklist[--sp];\n+\t  is_interesting = walk_data->interesting_blocks == NULL\n+\t                   || TEST_BIT (walk_data->interesting_blocks,\n+\t\t\t\t        bb->index);\n+\t  /* Callback for operations to execute after we have walked the\n+\t     dominator children, but before we walk statements.  */\n+\t  if (walk_data->after_dom_children_before_stmts)\n+\t    (*walk_data->after_dom_children_before_stmts) (walk_data, bb);\n+\n+\t  /* Statement walk after walking dominator children.  */\n+\t  if (is_interesting && walk_data->after_dom_children_walk_stmts)\n+\t    {\n+\t      if (walk_data->walk_stmts_backward)\n+\t\tfor (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n+\t\t  (*walk_data->after_dom_children_walk_stmts) (walk_data, bb,\n+\t\t\t\t\t\t\t       bsi);\n+\t      else\n+\t\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t\t  (*walk_data->after_dom_children_walk_stmts) (walk_data, bb,\n+\t\t\t\t\t\t\t       bsi);\n+\t    }\n+\n+\t  /* Callback for operations to execute after we have walked the\n+\t     dominator children and after we have walked statements.  */\n+\t  if (walk_data->after_dom_children_after_stmts)\n+\t    (*walk_data->after_dom_children_after_stmts) (walk_data, bb);\n+\n+\t  if (walk_data->initialize_block_local_data)\n+\t    {\n+\t      /* And finally pop the record off the block local data stack.  */\n+\t      bd = VEC_pop (void_p, walk_data->block_data_stack);\n+\t      /* And save the block data so that we can re-use it.  */\n+\t      VEC_safe_push (void_p, heap, walk_data->free_block_data, bd);\n+\t    }\n \t}\n-\n-      /* Push the local data into the local data stack.  */\n-      VEC_safe_push (void_p, heap, walk_data->block_data_stack, bd);\n-\n-      /* Call the initializer.  */\n-      walk_data->initialize_block_local_data (walk_data, bb, recycled);\n-\n-    }\n-\n-  /* Callback for operations to execute before we have walked the\n-     dominator children, but before we walk statements.  */\n-  if (walk_data->before_dom_children_before_stmts)\n-    (*walk_data->before_dom_children_before_stmts) (walk_data, bb);\n-\n-  /* Statement walk before walking dominator children.  */\n-  if (is_interesting && walk_data->before_dom_children_walk_stmts)\n-    {\n-      if (walk_data->walk_stmts_backward)\n-\tfor (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n-\t  (*walk_data->before_dom_children_walk_stmts) (walk_data, bb, bsi);\n-      else\n-\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t  (*walk_data->before_dom_children_walk_stmts) (walk_data, bb, bsi);\n-    }\n-\n-  /* Callback for operations to execute before we have walked the\n-     dominator children, and after we walk statements.  */\n-  if (walk_data->before_dom_children_after_stmts)\n-    (*walk_data->before_dom_children_after_stmts) (walk_data, bb);\n-\n-  /* Recursively call ourselves on the dominator children of BB.  */\n-  for (dest = first_dom_son (walk_data->dom_direction, bb);\n-       dest;\n-       dest = next_dom_son (walk_data->dom_direction, dest))\n-    {\n-      /* The destination block may have become unreachable, in\n-\t which case there's no point in optimizing it.  */\n-      if (EDGE_COUNT (dest->preds) > 0)\n-\twalk_dominator_tree (walk_data, dest);\n-    }\n-\n-  /* Callback for operations to execute after we have walked the\n-     dominator children, but before we walk statements.  */\n-  if (walk_data->after_dom_children_before_stmts)\n-    (*walk_data->after_dom_children_before_stmts) (walk_data, bb);\n-\n-  /* Statement walk after walking dominator children.  */\n-  if (is_interesting && walk_data->after_dom_children_walk_stmts)\n-    {\n-      if (walk_data->walk_stmts_backward)\n-\tfor (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n-\t  (*walk_data->after_dom_children_walk_stmts) (walk_data, bb, bsi);\n+      if (sp)\n+\tbb = worklist[--sp];\n       else\n-\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t  (*walk_data->after_dom_children_walk_stmts) (walk_data, bb, bsi);\n-    }\n-\n-  /* Callback for operations to execute after we have walked the\n-     dominator children and after we have walked statements.  */\n-  if (walk_data->after_dom_children_after_stmts)\n-    (*walk_data->after_dom_children_after_stmts) (walk_data, bb);\n-\n-  if (walk_data->initialize_block_local_data)\n-    {\n-      /* And save the block data so that we can re-use it.  */\n-      VEC_safe_push (void_p, heap, walk_data->free_block_data, bd);\n-\n-      /* And finally pop the record off the block local data stack.  */\n-      VEC_pop (void_p, walk_data->block_data_stack);\n+\tbreak;\n     }\n+  free (worklist);\n }\n \n void"}]}