{"sha": "bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQwZjIyYThkNWNhZWE4OTA1ZjM4ZmYxZmFmY2UzMWMxYjdkMzNhZA==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-04-01T03:48:46Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-04-01T05:21:14Z"}, "message": "Fix PR94043 by making vect_live_op generate lc-phi\n\nAs PR94043 shows, my commit r10-4524 exposed one issue in\nvectorizable_live_operation, which inserts one extra BB\nbefore the single exit, leading unexpected operand expansion\nand unexpected loop depth assertion.  As Richi suggested,\nthis patch is to teach vectorizable_live_operation to\ngenerate loop closed phi for vec_lhs, it looks like:\n     loop;\n     # lhs' = PHI <lhs>\n=>\n     loop;\n     # vec_lhs' = PHI <vec_lhs>\n     new_tree = BIT_FIELD_REF <vec_lhs', ...>;\n     lhs' = new_tree;\n\nI noticed that there are some SLP cases that have same lhs\nand vec_lhs but different offsets, which can make us have\nmore PHIs for the same vec_lhs there.  But I think it would\nbe fine since only one of them is actually live, the others\nshould be eliminated by the following dce.  So the patch\ndoesn't check whether there is one phi for vec_lhs, just\ncreate one directly instead.\n\nBootstrapped/regtested on powerpc64le-linux-gnu (LE) P8.\n\n2020-04-01  Kewen Lin  <linkw@gcc.gnu.org>\n\ngcc/ChangeLog\n\n    PR tree-optimization/94043\n    * tree-vect-loop.c (vectorizable_live_operation): Generate loop-closed\n    phi for vec_lhs and use it for lane extraction.\n\ngcc/testsuite/ChangeLog\n\n    PR tree-optimization/94043\n    * gfortran.dg/graphite/vect-pr94043.f90: New test.", "tree": {"sha": "ce0c6d209c9fb224c2bbb80c96bb2b50ae1cdd66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce0c6d209c9fb224c2bbb80c96bb2b50ae1cdd66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76f09260b7eccd6c3cfa3dcf3c22897fe12a8065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f09260b7eccd6c3cfa3dcf3c22897fe12a8065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f09260b7eccd6c3cfa3dcf3c22897fe12a8065"}], "stats": {"total": 79, "additions": 73, "deletions": 6}, "files": [{"sha": "fc836b83e171944bbb9e8a788113149db5ea2999", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad", "patch": "@@ -1,3 +1,9 @@\n+2020-04-01  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR tree-optimization/94043\n+\t* tree-vect-loop.c (vectorizable_live_operation): Generate loop-closed\n+\tphi for vec_lhs and use it for lane extraction.\n+\n 2020-03-31  Felix Yang  <felix.yang@huawei.com>\n \n \tPR tree-optimization/94398"}, {"sha": "6f41ffbb048735e555b907b8b78ab4cd160a1d85", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad", "patch": "@@ -1,3 +1,8 @@\n+2020-04-01  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR tree-optimization/94043\n+\t* gfortran.dg/graphite/vect-pr94043.f90: New test.\n+\n 2020-04-01  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \tPR d/90136"}, {"sha": "744c0f3042e6f185bffea5e967f896675228a0c7", "filename": "gcc/testsuite/gfortran.dg/graphite/vect-pr94043.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fvect-pr94043.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fvect-pr94043.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fvect-pr94043.f90?ref=bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-O3 -ftree-parallelize-loops=2 -fno-tree-dce\" }\n+\n+! As PR94043, test it to be compiled successfully without ICE.\n+\n+program yw\n+      integer :: hx(6, 6)\n+      integer :: ps = 1, e2 = 1\n+\n+      do ps = 1, 6\n+        do e2 = 1, 6\n+            hx(e2, ps) = 0\n+            if (ps >= 5 .and. e2 >= 5) then\n+                hx(e2, ps) = hx(1, 1)\n+            end if\n+        end do\n+      end do\n+end program"}, {"sha": "c9b653491f73879e300526918a5533ee0e627c1d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bd0f22a8d5caea8905f38ff1fafce31c1b7d33ad", "patch": "@@ -7998,6 +7998,25 @@ vectorizable_live_operation (stmt_vec_info stmt_info,\n       bitstart = int_const_binop (MINUS_EXPR, vec_bitsize, bitsize);\n     }\n \n+  /* Ensure the VEC_LHS for lane extraction stmts satisfy loop-closed PHI\n+     requirement, insert one phi node for it.  It looks like:\n+\t loop;\n+       BB:\n+\t # lhs' = PHI <lhs>\n+     ==>\n+\t loop;\n+       BB:\n+\t # vec_lhs' = PHI <vec_lhs>\n+\t new_tree = lane_extract <vec_lhs', ...>;\n+\t lhs' = new_tree;  */\n+\n+  basic_block exit_bb = single_exit (loop)->dest;\n+  gcc_assert (single_pred_p (exit_bb));\n+\n+  tree vec_lhs_phi = copy_ssa_name (vec_lhs);\n+  gimple *phi = create_phi_node (vec_lhs_phi, exit_bb);\n+  SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, vec_lhs);\n+\n   gimple_seq stmts = NULL;\n   tree new_tree;\n   if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n@@ -8010,10 +8029,10 @@ vectorizable_live_operation (stmt_vec_info stmt_info,\n \t the loop mask for the final iteration.  */\n       gcc_assert (ncopies == 1 && !slp_node);\n       tree scalar_type = TREE_TYPE (STMT_VINFO_VECTYPE (stmt_info));\n-      tree mask = vect_get_loop_mask (gsi, &LOOP_VINFO_MASKS (loop_vinfo),\n-\t\t\t\t      1, vectype, 0);\n-      tree scalar_res = gimple_build (&stmts, CFN_EXTRACT_LAST,\n-\t\t\t\t      scalar_type, mask, vec_lhs);\n+      tree mask = vect_get_loop_mask (gsi, &LOOP_VINFO_MASKS (loop_vinfo), 1,\n+\t\t\t\t      vectype, 0);\n+      tree scalar_res = gimple_build (&stmts, CFN_EXTRACT_LAST, scalar_type,\n+\t\t\t\t      mask, vec_lhs_phi);\n \n       /* Convert the extracted vector element to the required scalar type.  */\n       new_tree = gimple_convert (&stmts, lhs_type, scalar_res);\n@@ -8023,13 +8042,32 @@ vectorizable_live_operation (stmt_vec_info stmt_info,\n       tree bftype = TREE_TYPE (vectype);\n       if (VECTOR_BOOLEAN_TYPE_P (vectype))\n \tbftype = build_nonstandard_integer_type (tree_to_uhwi (bitsize), 1);\n-      new_tree = build3 (BIT_FIELD_REF, bftype, vec_lhs, bitsize, bitstart);\n+      new_tree = build3 (BIT_FIELD_REF, bftype, vec_lhs_phi, bitsize, bitstart);\n       new_tree = force_gimple_operand (fold_convert (lhs_type, new_tree),\n \t\t\t\t       &stmts, true, NULL_TREE);\n     }\n \n   if (stmts)\n-    gsi_insert_seq_on_edge_immediate (single_exit (loop), stmts);\n+    {\n+      gimple_stmt_iterator exit_gsi = gsi_after_labels (exit_bb);\n+      gsi_insert_before (&exit_gsi, stmts, GSI_CONTINUE_LINKING);\n+\n+      /* Remove existing phi from lhs and create one copy from new_tree.  */\n+      tree lhs_phi = NULL_TREE;\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_phis (exit_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *phi = gsi_stmt (gsi);\n+\t  if ((gimple_phi_arg_def (phi, 0) == lhs))\n+\t    {\n+\t      remove_phi_node (&gsi, false);\n+\t      lhs_phi = gimple_phi_result (phi);\n+\t      gimple *copy = gimple_build_assign (lhs_phi, new_tree);\n+\t      gsi_insert_after (&exit_gsi, copy, GSI_CONTINUE_LINKING);\n+\t      break;\n+\t    }\n+\t}\n+    }\n \n   /* Replace use of lhs with newly computed result.  If the use stmt is a\n      single arg PHI, just replace all uses of PHI result.  It's necessary"}]}