{"sha": "d331e204024e2a74124880dd0dee8f4952fc9b26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMzMWUyMDQwMjRlMmE3NDEyNDg4MGRkMGRlZThmNDk1MmZjOWIyNg==", "commit": {"author": {"name": "Mostafa Hagog", "email": "mustafa@il.ibm.com", "date": "2005-03-21T18:49:29Z"}, "committer": {"name": "Mostafa Hagog", "email": "hagog@gcc.gnu.org", "date": "2005-03-21T18:49:29Z"}, "message": "Fix PR middle-end/20177 and add test case.\n\nFrom-SVN: r96828", "tree": {"sha": "f2b248b3f124017096da7b8acade677c20bf2d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2b248b3f124017096da7b8acade677c20bf2d16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d331e204024e2a74124880dd0dee8f4952fc9b26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d331e204024e2a74124880dd0dee8f4952fc9b26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d331e204024e2a74124880dd0dee8f4952fc9b26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d331e204024e2a74124880dd0dee8f4952fc9b26/comments", "author": null, "committer": null, "parents": [{"sha": "191dd2c9c240ee8c8f8ea8f97e5361140d5af1de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/191dd2c9c240ee8c8f8ea8f97e5361140d5af1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/191dd2c9c240ee8c8f8ea8f97e5361140d5af1de"}], "stats": {"total": 94, "additions": 80, "deletions": 14}, "files": [{"sha": "b87be58cd43b1b2d992bae32be9bf68b6af16747", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d331e204024e2a74124880dd0dee8f4952fc9b26", "patch": "@@ -1,3 +1,17 @@\n+2005-03-21 Mostafa Hagog <mustafa@il.ibm.com>\n+\n+\tPR middle-end/20177\n+\t* ddg.c (create_ddg_dependence): Ignore reg-anti dependency.\n+\t* modulo-sched.c (const_iteration_count): Return on NULL\n+\tpre-header.\n+\t(print_node_sched_params): Return on NULL dump_file.\n+\t(generate_reg_moves): Handle reg-anti dependencies and disregard\n+\tclosing branch when generating register moves.\n+\t(sms_schedule): Mark the SMSed block dirty.\n+\t* passes.c (rest_of_handle_sms): Call update_life_info for all\n+\tbasic-blocks.\n+\t* testsuite/gcc.dg/20050321-1.c: New test.\n+\n 2005-03-21  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/lib1funcs.asm (__mulsi3): Use symbolic name for ACCLO."}, {"sha": "5a2cbeee109e00345a52a18658be6afd1232032f", "filename": "gcc/ddg.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=d331e204024e2a74124880dd0dee8f4952fc9b26", "patch": "@@ -187,6 +187,8 @@ create_ddg_dependence (ddg_ptr g, ddg_node_ptr src_node,\n       else\n \tfree (e);\n     }\n+  else if (t == ANTI_DEP && dt == REG_DEP)\n+    free (e);  /* We can fix broken anti register deps using reg-moves.  */\n   else\n     add_edge_to_ddg (g, e);\n }"}, {"sha": "86773165dd27fcf02c856c5d3585a8140e30c704", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=d331e204024e2a74124880dd0dee8f4952fc9b26", "patch": "@@ -337,6 +337,10 @@ const_iteration_count (rtx count_reg, basic_block pre_header,\n {\n   rtx insn;\n   rtx head, tail;\n+\n+  if (! pre_header)\n+    return NULL_RTX;\n+\n   get_block_head_tail (pre_header->index, &head, &tail);\n \n   for (insn = tail; insn != PREV_INSN (head); insn = PREV_INSN (insn))\n@@ -399,6 +403,8 @@ print_node_sched_params (FILE * dump_file, int num_nodes)\n {\n   int i;\n \n+  if (! dump_file)\n+    return;\n   for (i = 0; i < num_nodes; i++)\n     {\n       node_sched_params_ptr nsp = &node_sched_params[i];\n@@ -441,14 +447,17 @@ calculate_maxii (ddg_ptr g)\n   return maxii;\n }\n \n-\n-/* Given the partial schedule, generate register moves when the length\n-   of the register live range is more than ii; the number of moves is\n-   determined according to the following equation:\n-\t\tSCHED_TIME (use) - SCHED_TIME (def)   { 1 broken loop-carried\n-   nreg_moves = ----------------------------------- - {   dependence.\n-\t\t\t      ii\t\t      { 0 if not.\n-   This handles the modulo-variable-expansions (mve's) needed for the ps.  */\n+/*\n+   Breaking intra-loop register anti-dependences:\n+   Each intra-loop register anti-dependence implies a cross-iteration true\n+   dependence of distance 1. Therefore, we can remove such false dependencies\n+   and figure out if the partial schedule broke them by checking if (for a\n+   true-dependence of distance 1): SCHED_TIME (def) < SCHED_TIME (use) and\n+   if so generate a register move.   The number of such moves is equal to:\n+              SCHED_TIME (use) - SCHED_TIME (def)       { 0 broken\n+   nreg_moves = ----------------------------------- + 1 - {   dependecnce.\n+                            ii                          { 1 if not.\n+*/\n static void\n generate_reg_moves (partial_schedule_ptr ps)\n {\n@@ -472,6 +481,9 @@ generate_reg_moves (partial_schedule_ptr ps)\n \t  {\n \t    int nreg_moves4e = (SCHED_TIME (e->dest) - SCHED_TIME (e->src)) / ii;\n \n+            if (e->distance == 1)\n+              nreg_moves4e = (SCHED_TIME (e->dest) - SCHED_TIME (e->src) + ii) / ii;\n+\n \t    /* If dest precedes src in the schedule of the kernel, then dest\n \t       will read before src writes and we can save one reg_copy.  */\n \t    if (SCHED_ROW (e->dest) == SCHED_ROW (e->src)\n@@ -495,6 +507,9 @@ generate_reg_moves (partial_schedule_ptr ps)\n \t  {\n \t    int dest_copy = (SCHED_TIME (e->dest) - SCHED_TIME (e->src)) / ii;\n \n+\t    if (e->distance == 1)\n+\t      dest_copy = (SCHED_TIME (e->dest) - SCHED_TIME (e->src) + ii) / ii;\n+\n \t    if (SCHED_ROW (e->dest) == SCHED_ROW (e->src)\n \t\t&& SCHED_COLUMN (e->dest) < SCHED_COLUMN (e->src))\n \t      dest_copy--;\n@@ -538,7 +553,8 @@ normalize_sched_times (partial_schedule_ptr ps)\n   int amount = PS_MIN_CYCLE (ps);\n   int ii = ps->ii;\n \n-  for (i = 0; i < g->num_nodes; i++)\n+  /* Don't include the closing branch assuming that it is the last node.  */\n+  for (i = 0; i < g->num_nodes - 1; i++)\n     {\n       ddg_node_ptr u = &g->nodes[i];\n       int normalized_time = SCHED_TIME (u) - amount;\n@@ -607,7 +623,7 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \t    /* SCHED_STAGE (u_node) >= from_stage == 0.  Generate increasing\n \t       number of reg_moves starting with the second occurrence of\n \t       u_node, which is generated if its SCHED_STAGE <= to_stage.  */\n-\t    i_reg_moves = to_stage - SCHED_STAGE (u_node);\n+\t    i_reg_moves = to_stage - SCHED_STAGE (u_node) + 1;\n \t    i_reg_moves = MAX (i_reg_moves, 0);\n \t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u_node));\n \n@@ -1107,6 +1123,8 @@ sms_schedule (FILE *dump_file)\n \t     scheduling passes doesn't touch it.  */\n \t  if (! flag_resched_modulo_sched)\n \t    g->bb->flags |= BB_DISABLE_SCHEDULE;\n+\t  /* The life-info is not valid any more.  */\n+\t  g->bb->flags |= BB_DIRTY;\n \n \t  generate_reg_moves (ps);\n \t  if (dump_file)"}, {"sha": "1121d0c367268529c50102f5ea95a7f72ec71c4f", "filename": "gcc/passes.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d331e204024e2a74124880dd0dee8f4952fc9b26", "patch": "@@ -575,6 +575,8 @@ rest_of_handle_partition_blocks (void)\n static void\n rest_of_handle_sms (void)\n {\n+  sbitmap blocks;\n+\n   timevar_push (TV_SMS);\n   open_dump_file (DFI_sms, current_function_decl);\n \n@@ -587,10 +589,14 @@ rest_of_handle_sms (void)\n   /* Update the life information, because we add pseudos.  */\n   max_regno = max_reg_num ();\n   allocate_reg_info (max_regno, FALSE, FALSE);\n-  update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\t\t    (PROP_DEATH_NOTES\n-\t\t\t\t     | PROP_KILL_DEAD_CODE\n-\t\t\t\t     | PROP_SCAN_DEAD_CODE));\n+  blocks = sbitmap_alloc (last_basic_block);\n+  sbitmap_ones (blocks);\n+  update_life_info (blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t    (PROP_DEATH_NOTES\n+\t\t     | PROP_REG_INFO\n+\t\t     | PROP_KILL_DEAD_CODE\n+\t\t     | PROP_SCAN_DEAD_CODE));\n+\n   no_new_pseudos = 1;\n \n   ggc_collect ();"}, {"sha": "01c68cd5ed98e86f7a1466e83ad7a4b8c0c5af08", "filename": "gcc/testsuite/gcc.dg/20050321-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2Ftestsuite%2Fgcc.dg%2F20050321-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d331e204024e2a74124880dd0dee8f4952fc9b26/gcc%2Ftestsuite%2Fgcc.dg%2F20050321-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20050321-1.c?ref=d331e204024e2a74124880dd0dee8f4952fc9b26", "patch": "@@ -0,0 +1,26 @@\n+/* This caused an ICE on powerpc-linux-gnu due to not \n+   up-to-date life info (PR middle-end/20177).  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fmodulo-sched\" } */\n+extern void * malloc (long);\n+\n+struct s {\n+    int k;\n+};\n+\n+int n;\n+struct s *a1, *(*use)[];\n+float (*vector)[];\n+\n+void\n+foo (float *V)\n+{\n+  int i, used = 0;\n+\n+  vector = malloc (i * sizeof (float));\n+  while ((*use)[used] != a1)\n+    used += 1;\n+  for (i = 0; i < n; i++)\n+    *V += (*vector)[i];\n+}"}]}