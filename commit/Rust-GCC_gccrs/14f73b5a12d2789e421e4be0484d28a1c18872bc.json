{"sha": "14f73b5a12d2789e421e4be0484d28a1c18872bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRmNzNiNWExMmQyNzg5ZTQyMWU0YmUwNDg0ZDI4YTFjMTg4NzJiYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-10-02T10:59:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-10-02T10:59:42Z"}, "message": "invoke.texi (i386 Options): Document x86-64 options.\n\n\t* doc/invoke.texi (i386 Options): Document x86-64 options.\n\t(i386 and x86-64 Options): Rename i386 options section.\n\n\t* config/i386/i386.h (TARGET_UNWIND_INFO): New.\n\t(TARGET_SWITCHES): Add -munwind-info.\n\t(MASK_NO_UNWIND_INFO): New.\n\t(NO_BUILTIN_SIZE_TYPE, NO_BUILTIN_PTRDIFF_TYPE): Define for\n\tbiarch compilation.\n\t(ASM_OUTPUT_DOUBLE_INT): New.\n\n\t* config/i386/linux64.h: New spec file for Linux x86-64 support.\n\t* config.gcc: Fix tm_file settings for x86-64.\n\t* config/i386/x86-64.h: New file with OS independent x86-64\n\tdefinitions.\n\t* config/i386/biarch64.h: New file used to configure compiler\n\tto biarch/64bit compilation.\n\n\t* config/i386/i386.c: (override_options): Set flags default\n\tfor 64bit compilation.\n\n\t* i386.c (legitimize_pic_address): Add missing bits of 64bit support.\n\t(ix86_expand_int_movcc): Optimize DImode conditional moves with\n\tconstants on x86_64.\n\t(ix86_attr_length_immediate_default): Support MODE_DI.\n\t* i386.md (fixdi splitter): Add missing \"&& 1\" in splitter\n\tcondition.\n\t(indirect_jump, tablejump): Turn into expander.\n\nFrom-SVN: r45946", "tree": {"sha": "70110e347db132c6e0f4f51554c0c0348a6fc741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70110e347db132c6e0f4f51554c0c0348a6fc741"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14f73b5a12d2789e421e4be0484d28a1c18872bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f73b5a12d2789e421e4be0484d28a1c18872bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f73b5a12d2789e421e4be0484d28a1c18872bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f73b5a12d2789e421e4be0484d28a1c18872bc/comments", "author": null, "committer": null, "parents": [{"sha": "80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f"}], "stats": {"total": 500, "additions": 430, "deletions": 70}, "files": [{"sha": "5f4c223b497e8880e9ca02d12db064e56189062d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -1,3 +1,37 @@\n+Tue Oct  2 12:46:01 CEST 2001  Bo Thorsen     <bo@suse.co.uk>,\n+\t\t\t       Andreas Jaeger <aj@suse.de>,\n+\t\t\t       Jan Hubicka    <jh@suse.cz>\n+\n+\t* doc/invoke.texi (i386 Options): Document x86-64 options.\n+\t(i386 and x86-64 Options): Rename i386 options section.\n+\n+\t* config/i386/i386.h (TARGET_UNWIND_INFO): New.\n+\t(TARGET_SWITCHES): Add -munwind-info.\n+\t(MASK_NO_UNWIND_INFO): New.\n+\t(NO_BUILTIN_SIZE_TYPE, NO_BUILTIN_PTRDIFF_TYPE): Define for\n+\tbiarch compilation.\n+\t(ASM_OUTPUT_DOUBLE_INT): New.\n+\n+\t* config/i386/linux64.h: New spec file for Linux x86-64 support.\n+\t* config.gcc: Fix tm_file settings for x86-64.\n+\t* config/i386/x86-64.h: New file with OS independent x86-64\n+\tdefinitions.\n+\t* config/i386/biarch64.h: New file used to configure compiler\n+\tto biarch/64bit compilation.\n+\n+\t* config/i386/i386.c: (override_options): Set flags default\n+\tfor 64bit compilation.\n+\n+Tue Oct  2 12:46:01 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (legitimize_pic_address): Add missing bits of 64bit support.\n+\t(ix86_expand_int_movcc): Optimize DImode conditional moves with \n+\tconstants on x86_64.\n+\t(ix86_attr_length_immediate_default): Support MODE_DI.\n+\t* i386.md (fixdi splitter): Add missing \"&& 1\" in splitter\n+\tcondition.\n+\t(indirect_jump, tablejump): Turn into expander.\n+\n 2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-common.c (c_format_attribute_table): Make format and"}, {"sha": "df86a7b937f024772ab667dcd51373a76c759416", "filename": "gcc/config.gcc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -222,6 +222,9 @@ c*-convex-*)\n i[34567]86-*-*)\n \tcpu_type=i386\n \t;;\n+x86_64-*-*)\n+\tcpu_type=i386\n+\t;;\n hppa*-*-* | parisc*-*-*)\n \tcpu_type=pa\n \t;;\n@@ -1140,6 +1143,18 @@ i[34567]86-*-linux*)\t# Intel 80386's running GNU/Linux\n \t\tthread_file='posix'\n \tfi\n \t;;\n+x86_64-*-linux*)\n+\txmake_file=x-linux\n+\ttm_file=\"i386/biarch64.h i386/i386.h i386/att.h linux.h i386/x86-64.h \\\n+\t\t i386/linux64.h\"\n+\ttmake_file=\"t-slibgcc-elf-ver t-linux i386/t-crtstuff\"\n+\textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n+\tgnu_ld=yes\n+\tfloat_format=i386\n+\tif test x$enable_threads = xyes; then\n+\t\tthread_file='posix'\n+\tfi\n+\t;;\n i[34567]86-*-gnu*)\n \tfloat_format=i386\n \t;;"}, {"sha": "8f2a1ebb50d5c1033b1fdcb82780cadafd9d5d59", "filename": "gcc/config/i386/att.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fatt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fatt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fatt.h?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define ASM_SHORT \"\\t.value\\t\"\n #define ASM_LONG \"\\t.long\\t\"\n+#define ASM_QUAD \"\\t.quad\\t\"\n \n /* How to output an ASCII string constant.  */\n "}, {"sha": "e2a5d917f80346da5a02f8773cbc3d5368109b7d", "filename": "gcc/config/i386/biarch64.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fbiarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fbiarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fbiarch64.h?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -0,0 +1,25 @@\n+/* Make configure files to produce biarch compiler defaulting to 64bit mode.\n+   This file must be included very first, while the OS specific file later\n+   to overwrite otherwise wrong defaults. \n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Bo Thorsen <bo@suse.de>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define TARGET_64BIT_DEFAULT\n+#define TARGET_BI_ARCH"}, {"sha": "7e65b0e9164d391de9c495f4e8640ee753cf7e6e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 120, "deletions": 59, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -984,6 +984,16 @@ override_options ()\n   if (flag_unsafe_math_optimizations)\n     target_flags &= ~MASK_IEEE_FP;\n \n+  if (TARGET_64BIT)\n+    {\n+      if (TARGET_ALIGN_DOUBLE)\n+\terror (\"-malign-double makes no sense in the 64bit mode.\");\n+      if (TARGET_RTD)\n+\terror (\"-mrtd calling convention not supported in the 64bit mode.\");\n+      /* Enable by default the SSE and MMX builtins.  */\n+      target_flags |= MASK_SSE2 | MASK_SSE | MASK_MMX | MASK_128BIT_LONG_DOUBLE;\n+     }\n+\n   /* It makes no sense to ask for just SSE builtins, so MMX is also turned\n      on by -msse.  */\n   if (TARGET_SSE)\n@@ -2214,7 +2224,7 @@ ix86_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       emit_insn (gen_rtx_SET(VOIDmode, tmp_reg,\n \t\t\t     plus_constant (save_area, 8 * REGPARM_MAX + 127)));\n       mem = gen_rtx_MEM (BLKmode, plus_constant (tmp_reg, -127));\n-      set_mem_alias_set(mem, set);\n+      set_mem_alias_set (mem, set);\n \n       /* And finally do the dirty job!  */\n       emit_insn (gen_sse_prologue_save (mem, nsse_reg, GEN_INT (next_cum.sse_regno),\n@@ -2260,7 +2270,7 @@ ix86_va_start (stdarg_p, valist, nextarg)\n \n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr, \"va_start: words = %d, n_gpr = %d, n_fpr = %d\\n\",\n-\t     words, n_gpr, n_fpr);\n+\t     (int)words, (int)n_gpr, (int)n_fpr);\n \n   t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n \t     build_int_2 (n_gpr * 8, 0));\n@@ -4735,37 +4745,63 @@ legitimize_pic_address (orig, reg)\n \n   if (local_symbolic_operand (addr, Pmode))\n     {\n-      /* This symbol may be referenced via a displacement from the PIC\n-\t base address (@GOTOFF).  */\n+      /* In 64bit mode we can address such objects directly.  */\n+      if (TARGET_64BIT)\n+\tnew = addr;\n+      else\n+\t{\n+\t  /* This symbol may be referenced via a displacement from the PIC\n+\t     base address (@GOTOFF).  */\n \n-      current_function_uses_pic_offset_table = 1;\n-      new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 7);\n-      new = gen_rtx_CONST (Pmode, new);\n-      new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n+\t  current_function_uses_pic_offset_table = 1;\n+\t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 7);\n+\t  new = gen_rtx_CONST (Pmode, new);\n+\t  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n \n-      if (reg != 0)\n-\t{\n-\t  emit_move_insn (reg, new);\n-\t  new = reg;\n-\t}\n+\t  if (reg != 0)\n+\t    {\n+\t      emit_move_insn (reg, new);\n+\t      new = reg;\n+\t    }\n+      \t}\n     }\n   else if (GET_CODE (addr) == SYMBOL_REF)\n     {\n-      /* This symbol must be referenced via a load from the\n-\t Global Offset Table (@GOT).  */\n+      if (TARGET_64BIT)\n+\t{\n+\t  current_function_uses_pic_offset_table = 1;\n+\t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 15);\n+\t  new = gen_rtx_CONST (Pmode, new);\n+\t  new = gen_rtx_MEM (Pmode, new);\n+\t  RTX_UNCHANGING_P (new) = 1;\n+\t  set_mem_alias_set (new, ix86_GOT_alias_set ());\n+\n+\t  if (reg == 0)\n+\t    reg = gen_reg_rtx (Pmode);\n+\t  /* Use directly gen_movsi, otherwise the address is loaded\n+\t     into register for CSE.  We don't want to CSE this addresses,\n+\t     instead we CSE addresses from the GOT table, so skip this.  */\n+\t  emit_insn (gen_movsi (reg, new));\n+\t  new = reg;\n+\t}\n+      else\n+\t{\n+\t  /* This symbol must be referenced via a load from the\n+\t     Global Offset Table (@GOT).  */\n \n-      current_function_uses_pic_offset_table = 1;\n-      new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 6);\n-      new = gen_rtx_CONST (Pmode, new);\n-      new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n-      new = gen_rtx_MEM (Pmode, new);\n-      RTX_UNCHANGING_P (new) = 1;\n-      set_mem_alias_set (new, ix86_GOT_alias_set ());\n+\t  current_function_uses_pic_offset_table = 1;\n+\t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 6);\n+\t  new = gen_rtx_CONST (Pmode, new);\n+\t  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n+\t  new = gen_rtx_MEM (Pmode, new);\n+\t  RTX_UNCHANGING_P (new) = 1;\n+\t  set_mem_alias_set (new, ix86_GOT_alias_set ());\n \n-      if (reg == 0)\n-\treg = gen_reg_rtx (Pmode);\n-      emit_move_insn (reg, new);\n-      new = reg;\n+\t  if (reg == 0)\n+\t    reg = gen_reg_rtx (Pmode);\n+\t  emit_move_insn (reg, new);\n+\t  new = reg;\n+\t}\n     }\n   else\n     {\n@@ -5141,7 +5177,13 @@ i386_dwarf_output_addr_const (file, x)\n      FILE *file;\n      rtx x;\n {\n+#ifdef ASM_QUAD\n+  fprintf (file, \"%s\", TARGET_64BIT ? ASM_QUAD : INT_ASM_OP);\n+#else\n+  if (TARGET_64BIT)\n+    abort ();\n   fprintf (file, \"%s\", INT_ASM_OP);\n+#endif\n   if (flag_pic)\n     output_pic_addr_const (file, x, '\\0');\n   else\n@@ -7823,7 +7865,7 @@ ix86_expand_int_movcc (operands)\n      HImode insns, we'd be swallowed in word prefix ops.  */\n \n   if (GET_MODE (operands[0]) != HImode\n-      && GET_MODE (operands[0]) != DImode\n+      && (GET_MODE (operands[0]) != DImode || TARGET_64BIT)\n       && GET_CODE (operands[2]) == CONST_INT\n       && GET_CODE (operands[3]) == CONST_INT)\n     {\n@@ -7852,10 +7894,13 @@ ix86_expand_int_movcc (operands)\n \n \t  if (reg_overlap_mentioned_p (out, ix86_compare_op0)\n \t      || reg_overlap_mentioned_p (out, ix86_compare_op1))\n-\t    tmp = gen_reg_rtx (SImode);\n+\t    tmp = gen_reg_rtx (GET_MODE (operands[0]));\n \n \t  emit_insn (compare_seq);\n-\t  emit_insn (gen_x86_movsicc_0_m1 (tmp));\n+\t  if (GET_MODE (tmp) == DImode)\n+\t    emit_insn (gen_x86_movdicc_0_m1_rex64 (tmp));\n+\t  else\n+\t    emit_insn (gen_x86_movsicc_0_m1 (tmp));\n \n \t  if (diff == 1)\n \t    {\n@@ -7867,7 +7912,12 @@ ix86_expand_int_movcc (operands)\n \t       * Size 5 - 8.\n \t       */\n \t      if (ct)\n-\t        emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (ct)));\n+\t\t{\n+\t\t  if (GET_MODE (tmp) == DImode)\n+\t            emit_insn (gen_adddi3 (tmp, tmp, GEN_INT (ct)));\n+\t\t  else\n+\t            emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (ct)));\n+\t\t}\n \t    }\n \t  else if (cf == -1)\n \t    {\n@@ -7878,7 +7928,10 @@ ix86_expand_int_movcc (operands)\n \t       *\n \t       * Size 8.\n \t       */\n-\t      emit_insn (gen_iorsi3 (tmp, tmp, GEN_INT (ct)));\n+\t      if (GET_MODE (tmp) == DImode)\n+\t\temit_insn (gen_iordi3 (tmp, tmp, GEN_INT (ct)));\n+\t      else\n+\t\temit_insn (gen_iorsi3 (tmp, tmp, GEN_INT (ct)));\n \t    }\n \t  else if (diff == -1 && ct)\n \t    {\n@@ -7890,9 +7943,18 @@ ix86_expand_int_movcc (operands)\n \t       *\n \t       * Size 8 - 11.\n \t       */\n-\t      emit_insn (gen_one_cmplsi2 (tmp, tmp));\n-\t      if (cf)\n-\t        emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (cf)));\n+\t      if (GET_MODE (tmp) == DImode)\n+\t        {\n+\t\t  emit_insn (gen_one_cmpldi2 (tmp, tmp));\n+\t\t  if (cf)\n+\t\t    emit_insn (gen_adddi3 (tmp, tmp, GEN_INT (cf)));\n+\t\t}\n+\t      else\n+\t        {\n+\t\t  emit_insn (gen_one_cmplsi2 (tmp, tmp));\n+\t\t  if (cf)\n+\t\t    emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (cf)));\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -7904,10 +7966,20 @@ ix86_expand_int_movcc (operands)\n \t       *\n \t       * Size 8 - 11.\n \t       */\n-\t      emit_insn (gen_andsi3 (tmp, tmp, GEN_INT (trunc_int_for_mode\n-\t\t\t\t\t\t\t(cf - ct, SImode))));\n-\t      if (ct)\n-\t        emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (ct)));\n+\t      if (GET_MODE (tmp) == DImode)\n+\t        {\n+\t\t  emit_insn (gen_anddi3 (tmp, tmp, GEN_INT (trunc_int_for_mode\n+\t\t\t\t\t\t\t    (cf - ct, DImode))));\n+\t\t  if (ct)\n+\t\t    emit_insn (gen_adddi3 (tmp, tmp, GEN_INT (ct)));\n+\t\t}\n+\t      else\n+\t        {\n+\t\t  emit_insn (gen_andsi3 (tmp, tmp, GEN_INT (trunc_int_for_mode\n+\t\t\t\t\t\t\t    (cf - ct, SImode))));\n+\t\t  if (ct)\n+\t\t    emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (ct)));\n+\t\t}\n \t    }\n \n \t  if (tmp != out)\n@@ -7961,43 +8033,28 @@ ix86_expand_int_movcc (operands)\n \t  /* On x86_64 the lea instruction operates on Pmode, so we need to get arithmetics\n \t     done in proper mode to match.  */\n \t  if (diff == 1)\n-\t    {\n-\t      if (Pmode != SImode)\n-\t\ttmp = gen_lowpart (Pmode, out);\n-\t      else\n-\t\ttmp = out;\n-\t    }\n+\t    tmp = out;\n \t  else\n \t    {\n \t      rtx out1;\n-\t      if (Pmode != SImode)\n-\t        out1 = gen_lowpart (Pmode, out);\n-\t      else\n-\t\tout1 = out;\n-\t      tmp = gen_rtx_MULT (Pmode, out1, GEN_INT (diff & ~1));\n+\t      out1 = out;\n+\t      tmp = gen_rtx_MULT (GET_MODE (out), out1, GEN_INT (diff & ~1));\n \t      nops++;\n \t      if (diff & 1)\n \t\t{\n-\t\t  tmp = gen_rtx_PLUS (Pmode, tmp, out1);\n+\t\t  tmp = gen_rtx_PLUS (GET_MODE (out), tmp, out1);\n \t\t  nops++;\n \t\t}\n \t    }\n \t  if (cf != 0)\n \t    {\n-\t      tmp = gen_rtx_PLUS (Pmode, tmp, GEN_INT (cf));\n+\t      tmp = gen_rtx_PLUS (GET_MODE (out), tmp, GEN_INT (cf));\n \t      nops++;\n \t    }\n \t  if (tmp != out\n \t      && (GET_CODE (tmp) != SUBREG || SUBREG_REG (tmp) != out))\n \t    {\n-\t      if (Pmode != SImode)\n-\t        tmp = gen_rtx_SUBREG (SImode, tmp, 0);\n-\n-\t      /* ??? We should to take care for outputing non-lea arithmetics\n-\t         for Pmode != SImode case too, but it is quite tricky and not\n-\t         too important, since all TARGET_64BIT machines support real\n-\t         conditional moves.  */\n-\t      if (nops == 1 && Pmode == SImode)\n+\t      if (nops == 1)\n \t\t{\n \t\t  rtx clob;\n \n@@ -9694,6 +9751,10 @@ ix86_attr_length_immediate_default (insn, shortform)\n \t\tcase MODE_SI:\n \t\t  len+=4;\n \t\t  break;\n+\t\t/* Immediates for DImode instructions are encoded as 32bit sign extended values.  */\n+\t\tcase MODE_DI:\n+\t\t  len+=4;\n+\t\t  break;\n \t\tdefault:\n \t\t  fatal_insn (\"Unknown insn mode\", insn);\n \t      }"}, {"sha": "174c59452a0c9b0ed92f144262ade3465330f6ba", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -484,6 +484,11 @@ extern int ix86_arch;\n #endif\n #endif /* CPP_CPU_DEFAULT_SPEC */\n \n+#ifdef TARGET_BI_ARCH\n+#define NO_BUILTIN_SIZE_TYPE\n+#define NO_BUILTIN_PTRDIFF_TYPE\n+#endif\n+\n #ifdef NO_BUILTIN_SIZE_TYPE\n #define CPP_CPU32_SIZE_TYPE_SPEC \\\n   \" -D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int\"\n@@ -653,7 +658,7 @@ extern int ix86_arch;\n    the stack, which results in aligned frames for functions called from\n    main, though it does nothing for the alignment of main itself.  */\n #define FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN \\\n-  (ix86_preferred_stack_boundary > STACK_BOUNDARY)\n+  (ix86_preferred_stack_boundary > STACK_BOUNDARY && !TARGET_64BIT)\n \n /* Allocation boundary for the code of a function. */\n #define FUNCTION_BOUNDARY 16\n@@ -2910,6 +2915,11 @@ do { long l;\t\t\t\t\t\t\\\n   output_addr_const (FILE,(VALUE)),\t\t\\\n   putc('\\n',FILE))\n \n+#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"%s\\t\", ASM_QUAD),\t\t\\\n+  output_addr_const (FILE,(VALUE)),\t\t\\\n+  putc('\\n',FILE))\n+\n /* Likewise for `char' and `short' constants.  */\n \n #define ASM_OUTPUT_SHORT(FILE,VALUE)  \\"}, {"sha": "c2e05cb8d925b75150bcc8d81c66ab2a7df58d82", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -4688,7 +4688,7 @@\n    && !reload_completed && !reload_in_progress\n    && (!SSE_FLOAT_MODE_P (GET_MODE (operands[1])) || !TARGET_64BIT)\"\n   \"#\"\n-  \"\"\n+  \"&& 1\"\n   [(const_int 0)]\n {\n   operands[2] = assign_386_stack_local (HImode, 1);\n@@ -12956,9 +12956,21 @@\n   \"jmp\\t%l0\"\n   [(set_attr \"type\" \"ibr\")])\n \n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:P 0 \"nonimmediate_operand\" \"rm\"))]\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"nonimmediate_operand\" \"rm\"))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"*indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"!TARGET_64BIT\"\n+  \"jmp\\t%A0\"\n+  [(set_attr \"type\" \"ibr\")\n+   (set_attr \"length_immediate\" \"0\")])\n+\n+(define_insn \"*indirect_jump_rtx64\"\n+  [(set (pc) (match_operand:DI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"TARGET_64BIT\"\n   \"jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n@@ -12989,7 +13001,15 @@\n (define_insn \"*tablejump_1\"\n   [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n+  \"jmp\\t%A0\"\n+  [(set_attr \"type\" \"ibr\")\n+   (set_attr \"length_immediate\" \"0\")])\n+\n+(define_insn \"*tablejump_1_rtx64\"\n+  [(set (pc) (match_operand:DI 0 \"nonimmediate_operand\" \"rm\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"TARGET_64BIT\"\n   \"jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])"}, {"sha": "529c3014290792b3b82e0f83f2eb9a6e343a2422", "filename": "gcc/config/i386/linux64.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux64.h?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -0,0 +1,48 @@\n+/* Definitions for AMD x86-64 running Linux-based GNU systems with ELF format.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka <jh@suse.cz>, based on linux.h.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define LINUX_DEFAULT_ELF\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (x86-64 Linux/ELF)\");\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-D__ELF__ -Dunix -Dlinux -Asystem(posix)\"\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%(cpp_cpu) %{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT} %{!m32:-D__LONG_MAX__=9223372036854775807L}\"\n+\n+/* Provide a LINK_SPEC.  Here we provide support for the special GCC\n+   options -static and -shared, which allow us to link things in one\n+   of these three modes by applying the appropriate combinations of\n+   options at link-time.\n+\n+   When the -shared link option is used a final link is not being\n+   done.  */\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"%{!m32:-m elf_x86_64} %{m32:-m elf_i386} {shared:-shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+      %{!dynamic-linker:-dynamic-linker /lib/ld64.so.1}} \\\n+      %{static:-static}}\"\n+"}, {"sha": "baf5b2488dc7f2639d8d98288340eb7a90ba18f4", "filename": "gcc/config/i386/x86-64.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fx86-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fconfig%2Fi386%2Fx86-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-64.h?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -0,0 +1,118 @@\n+/* OS independent definitions for AMD x86-64.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Bo Thorsen <bo@suse.de>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* The svr4 ABI for the i386 says that records and unions are returned\n+   in memory.  */\n+#undef DEFAULT_PCC_STRUCT_RETURN\n+#define DEFAULT_PCC_STRUCT_RETURN 1\n+\n+#undef ASM_COMMENT_START\n+#define ASM_COMMENT_START \"#\"\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   This is only used for PIC code.  See comments by the `casesi' insn in\n+   i386.md for an explanation of the expression this outputs. */\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+  if (TARGET_64BIT) \\\n+    fprintf (FILE, \"\\t.long %s%d-.+4+(.-%s%d)\\n\", LPREFIX, VALUE, LPREFIX, REL); \\\n+  else\t\\\n+    fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n+\n+/* Indicate that jump tables go in the text section.  This is\n+   necessary when compiling PIC code.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic && !TARGET_64BIT)\n+\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(n) \\\n+  (TARGET_64BIT ? dbx64_register_map[n] : svr4_dbx_register_map[n])\n+\n+/* Output assembler code to FILE to call the profiler.  */\n+#define NO_PROFILE_COUNTERS\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_64BIT && flag_pic)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tcall\\t*mcount@PLT\\n\");\t\t\t\t\\\n+  else if (flag_pic)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tcall\\t*mcount@GOT(%%ebx)\\n\");\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tcall\\tmcount\\n\");\t\t\t\t\t\\\n+}\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE (TARGET_64BIT ? \"long unsigned int\" : \"unsigned int\")\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (TARGET_64BIT ? \"long int\" : \"int\")\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\n+#undef CC1_SPEC\n+#define CC1_SPEC \"%(cc1_cpu) %{profile:-p}\"\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{v:-V} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} \\\n+ %{Wa,*:%*} %{m32:--32}\"\n+\n+/* A C statement (sans semicolon) to output to the stdio stream\n+   FILE the assembler definition of uninitialized global DECL named\n+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.\n+   Try to use asm_output_aligned_bss to implement this macro.  */\n+\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+/* A C statement to output to the stdio stream FILE an assembler\n+   command to advance the location counter to a multiple of 1<<LOG\n+   bytes if it is within MAX_SKIP bytes.\n+\n+   This is used to align code labels according to Intel recommendations.  */\n+\n+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN\n+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if ((LOG) != 0) {\t\t\t\t\t\t\t\\\n+      if ((MAX_SKIP) == 0) fprintf ((FILE), \"\\t.p2align %d\\n\", (LOG));\t\\\n+      else fprintf ((FILE), \"\\t.p2align %d,,%d\\n\", (LOG), (MAX_SKIP));\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+\n+/* i386 System V Release 4 uses DWARF debugging info.\n+   x86-64 ABI specifies DWARF2.  */\n+\n+#undef DWARF2_DEBUGGING_INFO\n+#undef DWARF_DEBUGGING_INFO\n+#define DWARF2_DEBUGGING_INFO\n+#define DWARF2_UNWIND_INFO 1\n+/* Incorrectly autodetected in cross compilation.  */\n+#undef HAVE_AS_DWARF2_DEBUG_LINE\n+#define HAVE_AS_DWARF2_DEBUG_LINE\n+\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG"}, {"sha": "8499d72bac6b1de2a9c9965a90ab17f79aaa7931", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f73b5a12d2789e421e4be0484d28a1c18872bc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=14f73b5a12d2789e421e4be0484d28a1c18872bc", "patch": "@@ -464,7 +464,7 @@ in the following sections.\n -mabi=32  -mabi=n32  -mabi=64  -mabi=eabi @gol\n -mfix7000  -mno-crt0}\n \n-@emph{i386 Options}\n+@emph{i386 and x86-64 Options}\n @gccoptlist{\n -mcpu=@var{cpu-type}  -march=@var{cpu-type} @gol\n -mintel-syntax -mieee-fp  -mno-fancy-math-387 @gol\n@@ -474,7 +474,9 @@ in the following sections.\n -mmmx  -msse  -m3dnow @gol\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n--m96bit-long-double  -mregparm=@var{num}  -momit-leaf-frame-pointer}\n+-m96bit-long-double  -mregparm=@var{num}  -momit-leaf-frame-pointer @gol\n+-mno-red-zone@gol\n+-m32 -m64}\n \n @emph{HPPA Options}\n @gccoptlist{\n@@ -5077,7 +5079,7 @@ that macro, which enables you to change the defaults.\n * RS/6000 and PowerPC Options::\n * RT Options::\n * MIPS Options::\n-* i386 Options::\n+* i386 and x86-64 Options::\n * HPPA Options::\n * Intel 960 Options::\n * DEC Alpha Options::\n@@ -7418,12 +7420,15 @@ options is also defined by that macro, which enables you to change the\n defaults.\n @end ifset\n \n-@node i386 Options\n-@subsection Intel 386 Options\n+@node i386 and x86-64 Options\n+@subsection Intel 386 and AMD x86-64 Options\n @cindex i386 Options\n+@cindex x86-64 Options\n @cindex Intel 386 Options\n+@cindex AMD x86-64 Options\n \n-These @samp{-m} options are defined for the i386 family of computers:\n+These @samp{-m} options are defined for the i386 and x86-64 family of\n+computers:\n \n @table @gcctabopt\n @item -mcpu=@var{cpu-type}\n@@ -8027,6 +8032,29 @@ makes an extra register available in leaf functions.  The option\n which might make debugging harder.\n @end table\n \n+These @samp{-m} switches are supported in addition to the above\n+on AMD x86-64 processors in 64-bit environments.\n+\n+@table @gcctabopt\n+@item -m32\n+@itemx -m64\n+@opindex m32\n+@opindex m64\n+Generate code for a 32-bit or 64-bit environment.\n+The 32-bit environment sets int, long and pointer to 32 bits and\n+generates code that runs on any i386 system.\n+The 64-bit environment sets int to 32 bits and long and pointer\n+to 64 bits and generates code for AMD's x86-64 architecture.\n+\n+@item -mno-red-zone\n+@opindex no-red-zone\n+Do not use a so called red zone for x86-64 code.  The red zone is mandated\n+by the x86-64 ABI, it is a 128-byte area beyond the location of the\n+stack pointer that will not be modified by signal or interrupt handlers\n+and therefore can be used for temporary data without adjusting the stack\n+pointer.  The flag @option{-mno-red-zone} disables this red zone.\n+@end table\n+\n @node HPPA Options\n @subsection HPPA Options\n @cindex HPPA Options"}]}