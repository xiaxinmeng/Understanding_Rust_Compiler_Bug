{"sha": "9855905ceff516db0276b303406bf703236d4c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg1NTkwNWNlZmY1MTZkYjAyNzZiMzAzNDA2YmY3MDMyMzZkNGM0Mg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2003-02-28T23:04:00Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2003-02-28T23:04:00Z"}, "message": "floatlib.c: Remove.\n\n2003-02-28  Aldy Hernandez  <aldyh@redhat.com>\n\n        * floatlib.c: Remove.\n\nFrom-SVN: r63586", "tree": {"sha": "7f8ce4d885cebe1e928a28b093a68b43357ea12e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f8ce4d885cebe1e928a28b093a68b43357ea12e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9855905ceff516db0276b303406bf703236d4c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9855905ceff516db0276b303406bf703236d4c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9855905ceff516db0276b303406bf703236d4c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9855905ceff516db0276b303406bf703236d4c42/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3695c25fd69298585a64cb682a84027ccbd4b724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3695c25fd69298585a64cb682a84027ccbd4b724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3695c25fd69298585a64cb682a84027ccbd4b724"}], "stats": {"total": 948, "additions": 4, "deletions": 944}, "files": [{"sha": "9554dfb16e8e9233395469b8cd38079bb7084a91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9855905ceff516db0276b303406bf703236d4c42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9855905ceff516db0276b303406bf703236d4c42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9855905ceff516db0276b303406bf703236d4c42", "patch": "@@ -1,3 +1,7 @@\n+2003-02-28  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * floatlib.c: Remove.\n+\n 2003-02-28  Jason Merrill  <jason@redhat.com>\n \n \t* stor-layout.c (variable_size): Leave a \"minus 1\" outside the"}, {"sha": "929aef7353c1eb2bf5c76a76b1ab3d95c083b401", "filename": "gcc/floatlib.c", "status": "removed", "additions": 0, "deletions": 944, "changes": 944, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3695c25fd69298585a64cb682a84027ccbd4b724/gcc%2Ffloatlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3695c25fd69298585a64cb682a84027ccbd4b724/gcc%2Ffloatlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffloatlib.c?ref=3695c25fd69298585a64cb682a84027ccbd4b724", "patch": "@@ -1,944 +0,0 @@\n-/*\n-** libgcc support for software floating point.\n-** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.\n-** Permission is granted to do *anything* you want with this file,\n-** commercial or otherwise, provided this message remains intact.  So there!\n-** I would appreciate receiving any updates/patches/changes that anyone\n-** makes, and am willing to be the repository for said changes (am I\n-** making a big mistake?).\n-\n-Warning! Only single-precision is actually implemented.  This file\n-won't really be much use until double-precision is supported.\n-\n-However, once that is done, this file might make possible\n-cross-compilation for an IEEE target machine from a non-IEEE\n-host such as a VAX.\n-\n-If you'd like to work on completing this, please talk to rms@gnu.ai.mit.edu.\n-\n---> Double precision floating support added by James Carlson on 20 April 1998.\n-\n-**\n-** Pat Wood\n-** Pipeline Associates, Inc.\n-** pipeline!phw@motown.com or\n-** sun!pipeline!phw or\n-** uunet!motown!pipeline!phw\n-**\n-** 05/01/91 -- V1.0 -- first release to gcc mailing lists\n-** 05/04/91 -- V1.1 -- added float and double prototypes and return values\n-**                  -- fixed problems with adding and subtracting zero\n-**                  -- fixed rounding in truncdfsf2\n-**                  -- fixed SWAP define and tested on 386\n-*/\n-\n-/*\n-** The following are routines that replace the libgcc soft floating point\n-** routines that are called automatically when -msoft-float is selected.\n-** The support single and double precision IEEE format, with provisions\n-** for byte-swapped machines (tested on 386).  Some of the double-precision\n-** routines work at full precision, but most of the hard ones simply punt\n-** and call the single precision routines, producing a loss of accuracy.\n-** long long support is not assumed or included.\n-** Overall accuracy is close to IEEE (actually 68882) for single-precision\n-** arithmetic.  I think there may still be a 1 in 1000 chance of a bit\n-** being rounded the wrong way during a multiply.  I'm not fussy enough to\n-** bother with it, but if anyone is, knock yourself out.\n-**\n-** Efficiency has only been addressed where it was obvious that something\n-** would make a big difference.  Anyone who wants to do this right for\n-** best speed should go in and rewrite in assembler.\n-**\n-** I have tested this only on a 68030 workstation and 386/ix integrated\n-** in with -msoft-float.\n-*/\n-\n-/* the following deal with IEEE single-precision numbers */\n-#define EXCESS\t\t126\n-#define SIGNBIT\t\t0x80000000\n-#define HIDDEN\t\t(1 << 23)\n-#define SIGN(fp)\t((fp) & SIGNBIT)\n-#define EXP(fp)\t\t(((fp) >> 23) & 0xFF)\n-#define MANT(fp)\t(((fp) & 0x7FFFFF) | HIDDEN)\n-#define PACK(s,e,m)\t((s) | ((e) << 23) | (m))\n-\n-/* the following deal with IEEE double-precision numbers */\n-#define EXCESSD\t\t1022\n-#define HIDDEND\t\t(1 << 20)\n-#define EXPD(fp)\t(((fp.l.upper) >> 20) & 0x7FF)\n-#define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n-#define MANTD(fp)\t(((((fp.l.upper) & 0xFFFFF) | HIDDEND) << 10) | \\\n-\t\t\t\t(fp.l.lower >> 22))\n-#define HIDDEND_LL\t((long long)1 << 52)\n-#define MANTD_LL(fp)\t((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)\n-#define PACKD_LL(s,e,m)\t(((long long)((s)+((e)<<20))<<32)|(m))\n-\n-/* define SWAP for 386/960 reverse-byte-order brain-damaged CPUs */\n-union double_long {\n-    double d;\n-#ifdef SWAP\n-    struct {\n-      unsigned long lower;\n-      long upper;\n-    } l;\n-#else\n-    struct {\n-      long upper;\n-      unsigned long lower;\n-    } l;\n-#endif\n-    long long ll;\n-};\n-\n-union float_long\n-  {\n-    float f;\n-    long l;\n-  };\n-\n-/* add two floats */\n-float\n-__addsf3 (float a1, float a2)\n-{\n-  long mant1, mant2;\n-  union float_long fl1, fl2;\n-  int exp1, exp2;\n-  int sign = 0;\n-\n-  fl1.f = a1;\n-  fl2.f = a2;\n-\n-  /* check for zero args */\n-  if (!fl1.l) {\n-      fl1.f = fl2.f;\n-      goto test_done;\n-  }\n-  if (!fl2.l)\n-      goto test_done;\n-\n-  exp1 = EXP (fl1.l);\n-  exp2 = EXP (fl2.l);\n-\n-  if (exp1 > exp2 + 25)\n-      goto test_done;\n-  if (exp2 > exp1 + 25) {\n-      fl1.f = fl2.f;\n-      goto test_done;\n-  }\n-\n-  /* do everything in excess precision so's we can round later */\n-  mant1 = MANT (fl1.l) << 6;\n-  mant2 = MANT (fl2.l) << 6;\n-\n-  if (SIGN (fl1.l))\n-    mant1 = -mant1;\n-  if (SIGN (fl2.l))\n-    mant2 = -mant2;\n-\n-  if (exp1 > exp2)\n-    {\n-      mant2 >>= exp1 - exp2;\n-    }\n-  else\n-    {\n-      mant1 >>= exp2 - exp1;\n-      exp1 = exp2;\n-    }\n-  mant1 += mant2;\n-\n-  if (mant1 < 0)\n-    {\n-      mant1 = -mant1;\n-      sign = SIGNBIT;\n-    }\n-  else if (!mant1) {\n-      fl1.f = 0;\n-      goto test_done;\n-  }\n-\n-  /* normalize up */\n-  while (!(mant1 & 0xE0000000))\n-    {\n-      mant1 <<= 1;\n-      exp1--;\n-    }\n-\n-  /* normalize down? */\n-  if (mant1 & (1 << 30))\n-    {\n-      mant1 >>= 1;\n-      exp1++;\n-    }\n-\n-  /* round to even */\n-  mant1 += (mant1 & 0x40) ? 0x20 : 0x1F;\n-\n-  /* normalize down? */\n-  if (mant1 & (1 << 30))\n-    {\n-      mant1 >>= 1;\n-      exp1++;\n-    }\n-\n-  /* lose extra precision */\n-  mant1 >>= 6;\n-\n-  /* turn off hidden bit */\n-  mant1 &= ~HIDDEN;\n-\n-  /* pack up and go home */\n-  fl1.l = PACK (sign, exp1, mant1);\n-test_done:\n-  return (fl1.f);\n-}\n-\n-/* subtract two floats */\n-float\n-__subsf3 (float a1, float a2)\n-{\n-  union float_long fl1, fl2;\n-\n-  fl1.f = a1;\n-  fl2.f = a2;\n-\n-  /* check for zero args */\n-  if (!fl2.l)\n-    return (fl1.f);\n-  if (!fl1.l)\n-    return (-fl2.f);\n-\n-  /* twiddle sign bit and add */\n-  fl2.l ^= SIGNBIT;\n-  return __addsf3 (a1, fl2.f);\n-}\n-\n-/* compare two floats */\n-long\n-__cmpsf2 (float a1, float a2)\n-{\n-  union float_long fl1, fl2;\n-\n-  fl1.f = a1;\n-  fl2.f = a2;\n-\n-  if (SIGN (fl1.l) && SIGN (fl2.l))\n-    {\n-      fl1.l ^= SIGNBIT;\n-      fl2.l ^= SIGNBIT;\n-    }\n-  if (fl1.l < fl2.l)\n-    return (-1);\n-  if (fl1.l > fl2.l)\n-    return (1);\n-  return (0);\n-}\n-\n-/* multiply two floats */\n-float\n-__mulsf3 (float a1, float a2)\n-{\n-  union float_long fl1, fl2;\n-  unsigned long result;\n-  int exp;\n-  int sign;\n-\n-  fl1.f = a1;\n-  fl2.f = a2;\n-\n-  if (!fl1.l || !fl2.l) {\n-      fl1.f = 0;\n-      goto test_done;\n-  }\n-\n-  /* compute sign and exponent */\n-  sign = SIGN (fl1.l) ^ SIGN (fl2.l);\n-  exp = EXP (fl1.l) - EXCESS;\n-  exp += EXP (fl2.l);\n-\n-  fl1.l = MANT (fl1.l);\n-  fl2.l = MANT (fl2.l);\n-\n-  /* the multiply is done as one 16x16 multiply and two 16x8 multiples */\n-  result = (fl1.l >> 8) * (fl2.l >> 8);\n-  result += ((fl1.l & 0xFF) * (fl2.l >> 8)) >> 8;\n-  result += ((fl2.l & 0xFF) * (fl1.l >> 8)) >> 8;\n-\n-  result >>= 2;\n-  if (result & 0x20000000)\n-    {\n-      /* round */\n-      result += 0x20;\n-      result >>= 6;\n-    }\n-  else\n-    {\n-      /* round */\n-      result += 0x10;\n-      result >>= 5;\n-      exp--;\n-    }\n-  if (result & (HIDDEN<<1)) {\n-    result >>= 1;\n-    exp++;\n-  }\n-\n-  result &= ~HIDDEN;\n-\n-  /* pack up and go home */\n-  fl1.l = PACK (sign, exp, result);\n-test_done:\n-  return (fl1.f);\n-}\n-\n-/* divide two floats */\n-float\n-__divsf3 (float a1, float a2)\n-{\n-  union float_long fl1, fl2;\n-  int result;\n-  int mask;\n-  int exp, sign;\n-\n-  fl1.f = a1;\n-  fl2.f = a2;\n-\n-  /* subtract exponents */\n-  exp = EXP (fl1.l) - EXP (fl2.l) + EXCESS;\n-\n-  /* compute sign */\n-  sign = SIGN (fl1.l) ^ SIGN (fl2.l);\n-\n-  /* divide by zero??? */\n-  if (!fl2.l)\n-    /* return NaN or -NaN */\n-    return (sign ? 0xFFFFFFFF : 0x7FFFFFFF);\n-\n-  /* numerator zero??? */\n-  if (!fl1.l)\n-    return (0);\n-\n-  /* now get mantissas */\n-  fl1.l = MANT (fl1.l);\n-  fl2.l = MANT (fl2.l);\n-\n-  /* this assures we have 25 bits of precision in the end */\n-  if (fl1.l < fl2.l)\n-    {\n-      fl1.l <<= 1;\n-      exp--;\n-    }\n-\n-  /* now we perform repeated subtraction of fl2.l from fl1.l */\n-  mask = 0x1000000;\n-  result = 0;\n-  while (mask)\n-    {\n-      if (fl1.l >= fl2.l)\n-\t{\n-\t  result |= mask;\n-\t  fl1.l -= fl2.l;\n-\t}\n-      fl1.l <<= 1;\n-      mask >>= 1;\n-    }\n-\n-  /* round */\n-  result += 1;\n-\n-  /* normalize down */\n-  exp++;\n-  result >>= 1;\n-\n-  result &= ~HIDDEN;\n-\n-  /* pack up and go home */\n-  fl1.l = PACK (sign, exp, result);\n-  return (fl1.f);\n-}\n-\n-/* convert int to double */\n-double\n-__floatsidf (long a1)\n-{\n-  int sign = 0, exp = 31 + EXCESSD;\n-  union double_long dl;\n-\n-  if (!a1)\n-    {\n-      dl.l.upper = dl.l.lower = 0;\n-      return (dl.d);\n-    }\n-\n-  if (a1 < 0)\n-    {\n-      sign = SIGNBIT;\n-      a1 = -a1;\n-    }\n-\n-  while (a1 < 0x1000000)\n-    {\n-      a1 <<= 4;\n-      exp -= 4;\n-    }\n-\n-  while (a1 < 0x40000000)\n-    {\n-      a1 <<= 1;\n-      exp--;\n-    }\n-\n-  /* pack up and go home */\n-  dl.l.upper = sign;\n-  dl.l.upper |= exp << 20;\n-  dl.l.upper |= (a1 >> 10) & ~HIDDEND;\n-  dl.l.lower = a1 << 22;\n-\n-  return (dl.d);\n-}\n-\n-double\n-__floatdidf (long long a1)\n-{\n-    int exp = 63 + EXCESSD;\n-    union double_long dl;\n-\n-    dl.l.upper = dl.l.lower = 0;\n-    if (a1 == 0)\n-\treturn (dl.d);\n-\n-    if (a1 < 0) {\n-\tdl.l.upper = SIGNBIT;\n-\ta1 = -a1;\n-    }\n-\n-    while (a1 < (long long)1<<54) {\n-\ta1 <<= 8;\n-\texp -= 8;\n-    }\n-    while (a1 < (long long)1<<62) {\n-\ta1 <<= 1;\n-\texp -= 1;\n-    }\n-\n-  /* pack up and go home */\n-    dl.ll |= (a1 >> 10) & ~HIDDEND_LL;\n-    dl.l.upper |= exp << 20;\n-\n-    return (dl.d);\n-}\n-\n-float\n-__floatsisf (long a1)\n-{\n-    (float)__floatsidf(a1);\n-}\n-\n-float\n-__floatdisf (long long a1)\n-{\n-    (float)__floatdidf(a1);\n-}\n-\n-/* negate a float */\n-float\n-__negsf2 (float a1)\n-{\n-  union float_long fl1;\n-\n-  fl1.f = a1;\n-  if (!fl1.l)\n-    return (0);\n-\n-  fl1.l ^= SIGNBIT;\n-  return (fl1.f);\n-}\n-\n-/* negate a double */\n-double\n-__negdf2 (double a1)\n-{\n-  union double_long dl1;\n-\n-  dl1.d = a1;\n-\n-  if (!dl1.l.upper && !dl1.l.lower)\n-      return (dl1.d);\n-\n-  dl1.l.upper ^= SIGNBIT;\n-  return (dl1.d);\n-}\n-\n-/* convert float to double */\n-double\n-__extendsfdf2 (float a1)\n-{\n-  union float_long fl1;\n-  union double_long dl;\n-  int exp;\n-\n-  fl1.f = a1;\n-\n-  if (!fl1.l)\n-    {\n-      dl.l.upper = dl.l.lower = 0;\n-      return (dl.d);\n-    }\n-\n-  dl.l.upper = SIGN (fl1.l);\n-  exp = EXP (fl1.l) - EXCESS + EXCESSD;\n-  dl.l.upper |= exp << 20;\n-  dl.l.upper |= (MANT (fl1.l) & ~HIDDEN) >> 3;\n-  dl.l.lower = MANT (fl1.l) << 29;\n-\n-  return (dl.d);\n-}\n-\n-/* convert double to float */\n-float\n-__truncdfsf2 (double a1)\n-{\n-  int exp;\n-  long mant;\n-  union float_long fl;\n-  union double_long dl1;\n-\n-  dl1.d = a1;\n-\n-  if (!dl1.l.upper && !dl1.l.lower)\n-    return (float)(0);\n-\n-  exp = EXPD (dl1) - EXCESSD + EXCESS;\n-\n-  /* shift double mantissa 6 bits so we can round */\n-  mant = MANTD (dl1) >> 6;\n-\n-  /* now round and shift down */\n-  mant += 1;\n-  mant >>= 1;\n-\n-  /* did the round overflow? */\n-  if (mant & 0xFE000000)\n-    {\n-      mant >>= 1;\n-      exp++;\n-    }\n-\n-  mant &= ~HIDDEN;\n-\n-  /* pack up and go home */\n-  fl.l = PACK (SIGND (dl1), exp, mant);\n-  return (fl.f);\n-}\n-\n-/* compare two doubles */\n-long\n-__cmpdf2 (double a1, double a2)\n-{\n-  union double_long dl1, dl2;\n-\n-  dl1.d = a1;\n-  dl2.d = a2;\n-\n-  if (SIGND (dl1) && SIGND (dl2))\n-    {\n-      dl1.l.upper ^= SIGNBIT;\n-      dl2.l.upper ^= SIGNBIT;\n-    }\n-  if (dl1.l.upper < dl2.l.upper)\n-    return (-1);\n-  if (dl1.l.upper > dl2.l.upper)\n-    return (1);\n-  if (dl1.l.lower < dl2.l.lower)\n-    return (-1);\n-  if (dl1.l.lower > dl2.l.lower)\n-    return (1);\n-  return (0);\n-}\n-\n-/* convert double to int */\n-long\n-__fixdfsi (double a1)\n-{\n-  union double_long dl1;\n-  int exp;\n-  long l;\n-\n-  dl1.d = a1;\n-\n-  if (!dl1.l.upper && !dl1.l.lower)\n-    return (0);\n-\n-  exp = EXPD (dl1) - EXCESSD - 31;\n-  l = MANTD (dl1);\n-\n-  if (exp > 0)\n-      return SIGND(dl1) ? (1<<31) : ((1ul<<31)-1);\n-\n-  /* shift down until exp = 0 or l = 0 */\n-  if (exp < 0 && exp > -32 && l)\n-    l >>= -exp;\n-  else\n-    return (0);\n-\n-  return (SIGND (dl1) ? -l : l);\n-}\n-\n-/* convert double to int */\n-long long\n-__fixdfdi (double a1)\n-{\n-    union double_long dl1;\n-    int exp;\n-    long long l;\n-\n-    dl1.d = a1;\n-\n-    if (!dl1.l.upper && !dl1.l.lower)\n-\treturn (0);\n-\n-    exp = EXPD (dl1) - EXCESSD - 64;\n-    l = MANTD_LL(dl1);\n-\n-    if (exp > 0) {\n-\tl = (long long)1<<63;\n-\tif (!SIGND(dl1))\n-\t    l--;\n-\treturn l;\n-    }\n-\n-    /* shift down until exp = 0 or l = 0 */\n-    if (exp < 0 && exp > -64 && l)\n-\tl >>= -exp;\n-    else\n-\treturn (0);\n-\n-    return (SIGND (dl1) ? -l : l);\n-}\n-\n-/* convert double to unsigned int */\n-unsigned long\n-__fixunsdfsi (double a1)\n-{\n-  union double_long dl1;\n-  int exp;\n-  unsigned long l;\n-\n-  dl1.d = a1;\n-\n-  if (!dl1.l.upper && !dl1.l.lower)\n-    return (0);\n-\n-  exp = EXPD (dl1) - EXCESSD - 32;\n-  l = (((((dl1.l.upper) & 0xFFFFF) | HIDDEND) << 11) | (dl1.l.lower >> 21));\n-\n-  if (exp > 0)\n-    return (0xFFFFFFFFul);\t/* largest integer */\n-\n-  /* shift down until exp = 0 or l = 0 */\n-  if (exp < 0 && exp > -32 && l)\n-    l >>= -exp;\n-  else\n-    return (0);\n-\n-  return (l);\n-}\n-\n-/* convert double to unsigned int */\n-unsigned long long\n-__fixunsdfdi (double a1)\n-{\n-    union double_long dl1;\n-    int exp;\n-    unsigned long long l;\n-\n-    dl1.d = a1;\n-\n-    if (dl1.ll == 0)\n-\treturn (0);\n-\n-    exp = EXPD (dl1) - EXCESSD - 64;\n-\n-    l = dl1.ll;\n-\n-    if (exp > 0)\n-\treturn (unsigned long long)-1;\n-\n-    /* shift down until exp = 0 or l = 0 */\n-    if (exp < 0 && exp > -64 && l)\n-\tl >>= -exp;\n-    else\n-\treturn (0);\n-\n-    return (l);\n-}\n-\n-/* addtwo doubles */\n-double\n-__adddf3 (double a1, double a2)\n-{\n-    long long mant1, mant2;\n-    union double_long fl1, fl2;\n-    int exp1, exp2;\n-    int sign = 0;\n-\n-    fl1.d = a1;\n-    fl2.d = a2;\n-\n-    /* check for zero args */\n-    if (!fl2.ll)\n-\tgoto test_done;\n-    if (!fl1.ll) {\n-\tfl1.d = fl2.d;\n-\tgoto test_done;\n-    }\n-\n-    exp1 = EXPD(fl1);\n-    exp2 = EXPD(fl2);\n-\n-    if (exp1 > exp2 + 54)\n-\tgoto test_done;\n-    if (exp2 > exp1 + 54) {\n-\tfl1.d = fl2.d;\n-\tgoto test_done;\n-    }\n-\n-    /* do everything in excess precision so's we can round later */\n-    mant1 = MANTD_LL(fl1) << 9;\n-    mant2 = MANTD_LL(fl2) << 9;\n-\n-    if (SIGND(fl1))\n-\tmant1 = -mant1;\n-    if (SIGND(fl2))\n-\tmant2 = -mant2;\n-\n-    if (exp1 > exp2)\n-\tmant2 >>= exp1 - exp2;\n-    else {\n-\tmant1 >>= exp2 - exp1;\n-\texp1 = exp2;\n-    }\n-    mant1 += mant2;\n-\n-    if (mant1 < 0) {\n-\tmant1 = -mant1;\n-\tsign = SIGNBIT;\n-    } else if (!mant1) {\n-\tfl1.d = 0;\n-\tgoto test_done;\n-    }\n-\n-    /* normalize up */\n-    while (!(mant1 & ((long long)7<<61))) {\n-\tmant1 <<= 1;\n-\texp1--;\n-    }\n-\n-    /* normalize down? */\n-    if (mant1 & ((long long)3<<62)) {\n-\tmant1 >>= 1;\n-\texp1++;\n-    }\n-\n-    /* round to even */\n-    mant1 += (mant1 & (1<<9)) ? (1<<8) : ((1<<8)-1);\n-\n-    /* normalize down? */\n-    if (mant1 & ((long long)3<<62)) {\n-\tmant1 >>= 1;\n-\texp1++;\n-    }\n-\n-    /* lose extra precision */\n-    mant1 >>= 9;\n-\n-    /* turn off hidden bit */\n-    mant1 &= ~HIDDEND_LL;\n-\n-    /* pack up and go home */\n-    fl1.ll = PACKD_LL(sign,exp1,mant1);\n-\n-test_done:\n-    return (fl1.d);\n-}\n-\n-/* subtract two doubles */\n-double\n-__subdf3 (double a1, double a2)\n-{\n-    union double_long fl1, fl2;\n-\n-    fl1.d = a1;\n-    fl2.d = a2;\n-\n-    /* check for zero args */\n-    if (!fl2.ll)\n-\treturn (fl1.d);\n-    /* twiddle sign bit and add */\n-    fl2.l.upper ^= SIGNBIT;\n-    if (!fl1.ll)\n-\treturn (fl2.d);\n-    return __adddf3 (a1, fl2.d);\n-}\n-\n-/* multiply two doubles */\n-double\n-__muldf3 (double a1, double a2)\n-{\n-    union double_long fl1, fl2;\n-    unsigned long long result;\n-    int exp;\n-    int sign;\n-\n-    fl1.d = a1;\n-    fl2.d = a2;\n-\n-    if (!fl1.ll || !fl2.ll) {\n-\tfl1.d = 0;\n-\tgoto test_done;\n-    }\n-\n-    /* compute sign and exponent */\n-    sign = SIGND(fl1) ^ SIGND(fl2);\n-    exp = EXPD(fl1) - EXCESSD;\n-    exp += EXPD(fl2);\n-\n-    fl1.ll = MANTD_LL(fl1);\n-    fl2.ll = MANTD_LL(fl2);\n-\n-  /* the multiply is done as one 31x31 multiply and two 31x21 multiples */\n-    result = (fl1.ll >> 21) * (fl2.ll >> 21);\n-    result += ((fl1.ll & 0x1FFFFF) * (fl2.ll >> 21)) >> 21;\n-    result += ((fl2.ll & 0x1FFFFF) * (fl1.ll >> 21)) >> 21;\n-\n-    result >>= 2;\n-    if (result & ((long long)1<<61)) {\n-\t/* round */\n-\tresult += 1<<8;\n-\tresult >>= 9;\n-    } else {\n-\t/* round */\n-\tresult += 1<<7;\n-\tresult >>= 8;\n-\texp--;\n-    }\n-    if (result & (HIDDEND_LL<<1)) {\n-\tresult >>= 1;\n-\texp++;\n-    }\n-\n-    result &= ~HIDDEND_LL;\n-\n-    /* pack up and go home */\n-    fl1.ll = PACKD_LL(sign,exp,result);\n-test_done:\n-    return (fl1.d);\n-}\n-\n-/* divide two doubles */\n-double\n-__divdf3 (double a1, double a2)\n-{\n-    union double_long fl1, fl2;\n-    long long mask,result;\n-    int exp, sign;\n-\n-    fl1.d = a1;\n-    fl2.d = a2;\n-\n-    /* subtract exponents */\n-    exp = EXPD(fl1) - EXPD(fl2) + EXCESSD;\n-\n-    /* compute sign */\n-    sign = SIGND(fl1) ^ SIGND(fl2);\n-\n-    /* numerator zero??? */\n-    if (fl1.ll == 0) {\n-\t/* divide by zero??? */\n-\tif (fl2.ll == 0)\n-\t    fl1.ll = ((unsigned long long)1<<63)-1;\t/* NaN */\n-\telse\n-\t    fl1.ll = 0;\n-\tgoto test_done;\n-    }\n-\n-    /* return +Inf or -Inf */\n-    if (fl2.ll == 0) {\n-\tfl1.ll = PACKD_LL(SIGND(fl1),2047,0);\n-\tgoto test_done;\n-    }\n-\n-\n-    /* now get mantissas */\n-    fl1.ll = MANTD_LL(fl1);\n-    fl2.ll = MANTD_LL(fl2);\n-\n-    /* this assures we have 54 bits of precision in the end */\n-    if (fl1.ll < fl2.ll) {\n-\tfl1.ll <<= 1;\n-\texp--;\n-    }\n-\n-    /* now we perform repeated subtraction of fl2.ll from fl1.ll */\n-    mask = (long long)1<<53;\n-    result = 0;\n-    while (mask) {\n-\tif (fl1.ll >= fl2.ll)\n-\t{\n-\t    result |= mask;\n-\t    fl1.ll -= fl2.ll;\n-\t}\n-\tfl1.ll <<= 1;\n-\tmask >>= 1;\n-    }\n-\n-    /* round */\n-    result += 1;\n-\n-    /* normalize down */\n-    exp++;\n-    result >>= 1;\n-\n-    result &= ~HIDDEND_LL;\n-\n-    /* pack up and go home */\n-    fl1.ll = PACKD_LL(sign, exp, result);\n-\n-test_done:\n-    return (fl1.d);\n-}\n-\n-int\n-__gtdf2 (double a1, double a2)\n-{\n-    return __cmpdf2 ((float) a1, (float) a2) > 0;\n-}\n-\n-int\n-__gedf2 (double a1, double a2)\n-{\n-    return (__cmpdf2 ((float) a1, (float) a2) >= 0) - 1;\n-}\n-\n-int\n-__ltdf2 (double a1, double a2)\n-{\n-    return - (__cmpdf2 ((float) a1, (float) a2) < 0);\n-}\n-\n-int\n-__ledf2 (double a1, double a2)\n-{\n-    return __cmpdf2 ((float) a1, (float) a2) > 0;\n-}\n-\n-int\n-__eqdf2 (double a1, double a2)\n-{\n-    return *(long long *) &a1 == *(long long *) &a2;\n-}\n-\n-int\n-__nedf2 (double a1, double a2)\n-{\n-    return *(long long *) &a1 != *(long long *) &a2;\n-}"}]}