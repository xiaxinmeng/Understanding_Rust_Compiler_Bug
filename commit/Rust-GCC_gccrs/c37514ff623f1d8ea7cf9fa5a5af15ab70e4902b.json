{"sha": "c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM3NTE0ZmY2MjNmMWQ4ZWE3Y2Y5ZmE1YTVhZjE1YWI3MGU0OTAyYg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-06-13T05:45:57Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-06-13T05:45:57Z"}, "message": "allocator-inst.cc: Explicitly instantiate.\n\n\n2003-06-12  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* src/allocator-inst.cc: Explicitly instantiate.\n\t* include/ext/pool_allocator.h: Inhibit implicit instantiations.\n\tTweaks.\n\t* config/linker-map.gnu: Add __pool_alloc bits. Tweaks.\n\nFrom-SVN: r67882", "tree": {"sha": "a84448145ae89976fcf054ca735ec55834288064", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a84448145ae89976fcf054ca735ec55834288064"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/comments", "author": null, "committer": null, "parents": [{"sha": "5482aaab6fd88069549d2312524917424b915a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5482aaab6fd88069549d2312524917424b915a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5482aaab6fd88069549d2312524917424b915a95"}], "stats": {"total": 316, "additions": 181, "deletions": 135}, "files": [{"sha": "6397b281b4912704385fdbdfbeda752795550306", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b", "patch": "@@ -1,3 +1,10 @@\n+2003-06-12  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* src/allocator-inst.cc: Explicitly instantiate.\n+\t* include/ext/pool_allocator.h: Inhibit implicit instantiations.\n+\tTweaks.\n+\t* config/linker-map.gnu: Add __pool_alloc bits. Tweaks.\n+\t\n 2003-06-11  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* acinclude.m4 (GLIBCPP_ENABLE_CSTDIO): Simplify."}, {"sha": "2245cd24f45d27cd62e977bb3c0f0da233c7498e", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 73, "deletions": 49, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b", "patch": "@@ -55,12 +55,7 @@ GLIBCPP_3.4 {\n       std::__num_base::_S_format_float*;\n       std::__num_base::_S_format_int*;\n       std::__num_base::_S_atoms_in;\n-      std::__num_base::_S_atoms_out;\n-      \n-      # Needed only when generic cpu's atomicity.h is in use.\n-      __gnu_cxx::_Atomic_add_mutex;\n-      __gnu_cxx::_Atomic_add_mutex_once;\n-      __gnu_cxx::__gthread_atomic_add_mutex_once\n+      std::__num_base::_S_atoms_out\n     };\n \n     # Names not in an 'extern' block are mangled names.\n@@ -78,28 +73,7 @@ GLIBCPP_3.4 {\n     # bool has_facet \n     _ZSt9has_facet*;\n \n-    # operator new(size_t)\n-    _Znw[jm];\n-    # operator new(size_t, std::nothrow_t const&)\n-    _Znw[jm]RKSt9nothrow_t;\n-\n-    # operator delete(void*)\n-    _ZdlPv;\n-    # operator delete(void*, std::nothrow_t const&)\n-    _ZdlPvRKSt9nothrow_t;\n-\n-    # operator new[](size_t)\n-    _Zna[jm];\n-    # operator new[](size_t, std::nothrow_t const&)\n-    _Zna[jm]RKSt9nothrow_t;\n-\n-    # operator delete[](void*)\n-    _ZdaPv;\n-    # operator delete[](void*, std::nothrow_t const&)\n-    _ZdaPvRKSt9nothrow_t;\n-\n-    # vtable\n-    _ZTVN9__gnu_cxx*;\n+    # virtual table\n     _ZTVNSt8ios_base7failureE;\n     _ZTVNSt6locale5facetE;\n     _ZTVS[a-z];\n@@ -109,31 +83,25 @@ GLIBCPP_3.4 {\n     _ZTVSt23__codecvt_abstract_baseI[cw]c11__mbstate_tE;\n     _ZTVSt21__ctype_abstract_baseI[cw]E;\n \n+    # VTT structure\n     _ZTTS[a-z];\n     _ZTTSt[0-9][A-Za-z]*;\n     _ZTTSt[0-9][0-9][A-Za-z]*;\n \n-    # typeinfo\n-    _ZTI[a-z];\n+    # typeinfo structure\n+    _ZTIS[a-z];\n     _ZTINSt8ios_base7failureE;\n     _ZTINSt6locale5facetE;\n-    _ZTIN9__gnu_cxx*;\n-    _ZTIP[a-z];\n-    _ZTIPK[a-z];\n-    _ZTIS[a-z];\n     _ZTISt[0-9][A-Za-z]*;\n     _ZTISt[0-9][0-9][A-Za-z]*;\n     _ZTISt11__timepunctI[cw]E;\n     _ZTISt10__num_base;\n     _ZTISt21__ctype_abstract_baseI[cw]E;\n     _ZTISt23__codecvt_abstract_baseI[cw]c11__mbstate_tE;\n \n-    _ZTS[a-z];\n+    # typeinfo name\n     _ZTSNSt8ios_base7failureE;\n     _ZTSNSt6locale5facetE;\n-    _ZTSN9__gnu_cxx*;\n-    _ZTSP[a-z];\n-    _ZTSPK[a-z];\n     _ZTSS[a-z];\n     _ZTSSt[0-9][A-Za-z]*;\n     _ZTSSt[0-9][0-9][A-Za-z]*;\n@@ -143,12 +111,11 @@ GLIBCPP_3.4 {\n     _ZTSSt23__codecvt_abstract_baseI[cw]c11__mbstate_tE;\n \n     # function-scope static objects requires a guard variable.\n-    _ZGV*;\n+    _ZGVNSt*;\n \n     # virtual function thunks\n-    _ZTh*;\n-    _ZTv*;\n-    _ZTc*;\n+    _ZThn8_NS*;\n+    _ZTv0_n12_NS*;\n \n     # std::__convert_to_v\n     _ZSt14__convert_to_v*;\n@@ -187,6 +154,18 @@ GLIBCPP_3.4 {\n     __signbitf;\n     __signbitl;\n \n+    # __gnu_cxx::__pool_alloc\n+    _ZN9__gnu_cxx12__pool_allocILb1ELi0EE8allocateE[jm];\n+    _ZN9__gnu_cxx12__pool_allocILb1ELi0EE10deallocateEPv[jm];\n+\n+    # __gnu_cxx::stdio_sync_filebuf\n+    _ZTVN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EEE;\n+\n+    # Needed only when generic cpu's atomicity.h is in use.\n+    _ZN9__gnu_cxx17_Atomic_add_mutexE;\n+    _ZN9__gnu_cxx22_Atomic_add_mutex_onceE;\n+    _ZN9__gnu_cxx31__gthread_atomic_add_mutex_onceEv;\n+\n   local:\n     *;\n };\n@@ -227,15 +206,60 @@ CXXABI_1.3 {\n     __gxx_personality_sj0;\n     __dynamic_cast;\n \n-    # __gnu_cxx::_verbose_terminate_handler()\n-    _ZN9__gnu_cxx27__verbose_terminate_handlerEv;\n+    # operator new(size_t)\n+    _Znw[jm];\n+    # operator new(size_t, std::nothrow_t const&)\n+    _Znw[jm]RKSt9nothrow_t;\n+\n+    # operator delete(void*)\n+    _ZdlPv;\n+    # operator delete(void*, std::nothrow_t const&)\n+    _ZdlPvRKSt9nothrow_t;\n \n-    # typeinfo\n-    _ZTIN10__cxxabi*;\n-    _ZTSN10__cxxabi*;\n+    # operator new[](size_t)\n+    _Zna[jm];\n+    # operator new[](size_t, std::nothrow_t const&)\n+    _Zna[jm]RKSt9nothrow_t;\n \n-    # vtable\n-    _ZTVN10__cxxabi*;\n+    # operator delete[](void*)\n+    _ZdaPv;\n+    # operator delete[](void*, std::nothrow_t const&)\n+    _ZdaPvRKSt9nothrow_t;\n+\n+    # virtual table\n+    _ZTVN10__cxxabiv117__class_type_infoE;\n+    _ZTVN10__cxxabiv120__si_class_type_infoE;\n+    _ZTVN10__cxxabiv121__vmi_class_type_infoE;\n+    _ZTVN10__cxxabiv123__fundamental_type_infoE;\n+    _ZTVN10__cxxabiv117__array_type_infoE;\n+    _ZTVN10__cxxabiv120__function_type_infoE;\n+    _ZTVN10__cxxabiv116__enum_type_infoE;\n+    _ZTVN10__cxxabiv117__pbase_type_infoE;\n+    _ZTVN10__cxxabiv119__pointer_type_infoE;\n+    _ZTVN10__cxxabiv129__pointer_to_member_type_infoE;\n+\n+    # typeinfo structure (and some names)\n+    _ZTI[a-z];\n+    _ZTIP[a-z];\n+    _ZTIPK[a-z];\n+    _ZTIN10__cxxabiv117__class_type_infoE;\n+    _ZTIN10__cxxabiv120__si_class_type_infoE;\n+    _ZTIN10__cxxabiv121__vmi_class_type_infoE;\n+    _ZTIN10__cxxabiv123__fundamental_type_infoE;\n+    _ZTIN10__cxxabiv117__array_type_infoE;\n+    _ZTIN10__cxxabiv120__function_type_infoE;\n+    _ZTIN10__cxxabiv116__enum_type_infoE;\n+    _ZTIN10__cxxabiv117__pbase_type_infoE;\n+    _ZTIN10__cxxabiv119__pointer_type_infoE;\n+    _ZTIN10__cxxabiv129__pointer_to_member_type_infoE;\n+\n+    # typeinfo name\n+    _ZTS[a-z];\n+    _ZTSP[a-z];\n+    _ZTSPK[a-z];\n+\n+    # __gnu_cxx::_verbose_terminate_handler()\n+    _ZN9__gnu_cxx27__verbose_terminate_handlerEv;\n \n   local:\n     *;"}, {"sha": "2c6f87e1673864dcb1634567daa51997a0f23a91", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 96, "deletions": 86, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b", "patch": "@@ -129,7 +129,7 @@ namespace __gnu_cxx\n       // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n       // if it is inconvenient to allocate the requested number.\n       static char*\n-      _S_chunk_alloc(size_t __size, int& __nobjs);\n+      _S_chunk_alloc(size_t __n, int& __nobjs);\n \n       // It would be nice to use _STL_auto_lock here.  But we need a\n       // test whether threads are in use.\n@@ -143,70 +143,13 @@ namespace __gnu_cxx\n     public:\n       // __n must be > 0\n       static void*\n-      allocate(size_t __n)\n-      {\n-\tvoid* __ret = 0;\n-\n-\t// If there is a race through here, assume answer from getenv\n-\t// will resolve in same direction.  Inspired by techniques\n-\t// to efficiently support threading found in basic_string.h.\n-\tif (_S_force_new == 0)\n-\t  {\n-\t    if (getenv(\"GLIBCPP_FORCE_NEW\"))\n-\t      __atomic_add(&_S_force_new, 1);\n-\t    else\n-\t      __atomic_add(&_S_force_new, -1);\n-\t  }\n-\n-\tif ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n-\t  __ret = __new_alloc::allocate(__n);\n-\telse\n-\t  {\n-\t    _Obj* volatile* __my_free_list = _S_free_list\n-\t      + _S_freelist_index(__n);\n-\t    // Acquire the lock here with a constructor call.  This\n-\t    // ensures that it is released in exit or during stack\n-\t    // unwinding.\n-\t    _Lock __lock_instance;\n-\t    _Obj* __restrict__ __result = *__my_free_list;\n-\t    if (__builtin_expect(__result == 0, 0))\n-\t      __ret = _S_refill(_S_round_up(__n));\n-\t    else\n-\t      {\n-\t\t*__my_free_list = __result -> _M_free_list_link;\n-\t\t__ret = __result;\n-\t      }\t    \n-\t    if (__builtin_expect(__ret == 0, 0))\n-\t      __throw_bad_alloc();\n-\t  }\n-\treturn __ret;\n-      }\n+      allocate(size_t __n);\n \n       // __p may not be 0\n       static void\n-      deallocate(void* __p, size_t __n)\n-      {\n-\tif ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n-\t  __new_alloc::deallocate(__p, __n);\n-\telse\n-\t  {\n-\t    _Obj* volatile*  __my_free_list = _S_free_list\n-\t      + _S_freelist_index(__n);\n-\t    _Obj* __q = (_Obj*)__p;\n-\n-\t    // Acquire the lock here with a constructor call.  This\n-\t    // ensures that it is released in exit or during stack\n-\t    // unwinding.\n-\t    _Lock __lock_instance;\n-\t    __q -> _M_free_list_link = *__my_free_list;\n-\t    *__my_free_list = __q;\n-\t  }\n-      }\n+      deallocate(void* __p, size_t __n);\n     };\n \n-  template<bool __threads, int __inst> _Atomic_word\n-  __pool_alloc<__threads, __inst>::_S_force_new = 0;\n-\n   template<bool __threads, int __inst>\n     inline bool\n     operator==(const __pool_alloc<__threads,__inst>&, \n@@ -220,16 +163,15 @@ namespace __gnu_cxx\n     { return false; }\n \n \n-  // We allocate memory in large chunks in order to avoid fragmenting the\n-  // heap too much.  We assume that __size is properly aligned.  We hold\n+  // Allocate memory in large chunks in order to avoid fragmenting the\n+  // heap too much.  Assume that __n is properly aligned.  We hold\n   // the allocation lock.\n   template<bool __threads, int __inst>\n     char*\n-    __pool_alloc<__threads, __inst>::\n-    _S_chunk_alloc(size_t __size, int& __nobjs)\n+    __pool_alloc<__threads, __inst>::_S_chunk_alloc(size_t __n, int& __nobjs)\n     {\n       char* __result;\n-      size_t __total_bytes = __size * __nobjs;\n+      size_t __total_bytes = __n * __nobjs;\n       size_t __bytes_left = _S_end_free - _S_start_free;\n \n       if (__bytes_left >= __total_bytes)\n@@ -238,10 +180,10 @@ namespace __gnu_cxx\n           _S_start_free += __total_bytes;\n           return __result ;\n         }\n-      else if (__bytes_left >= __size)\n+      else if (__bytes_left >= __n)\n         {\n-          __nobjs = (int)(__bytes_left/__size);\n-          __total_bytes = __size * __nobjs;\n+          __nobjs = (int)(__bytes_left/__n);\n+          __total_bytes = __n * __nobjs;\n           __result = _S_start_free;\n           _S_start_free += __total_bytes;\n           return __result;\n@@ -253,32 +195,32 @@ namespace __gnu_cxx\n           // Try to make use of the left-over piece.\n           if (__bytes_left > 0)\n             {\n-              _Obj* volatile* __my_free_list =\n+              _Obj* volatile* __free_list =\n                 _S_free_list + _S_freelist_index(__bytes_left);\n \n-              ((_Obj*)(void*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n-              *__my_free_list = (_Obj*)(void*)_S_start_free;\n+              ((_Obj*)(void*)_S_start_free)->_M_free_list_link = *__free_list;\n+              *__free_list = (_Obj*)(void*)_S_start_free;\n             }\n           _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);\n           if (_S_start_free == 0)\n             {\n               size_t __i;\n-              _Obj* volatile* __my_free_list;\n+              _Obj* volatile* __free_list;\n               _Obj* __p;\n               // Try to make do with what we have.  That can't hurt.  We\n               // do not try smaller requests, since that tends to result\n               // in disaster on multi-process machines.\n-              __i = __size;\n+              __i = __n;\n               for (; __i <= (size_t) _S_max_bytes; __i += (size_t) _S_align)\n                 {\n-                  __my_free_list = _S_free_list + _S_freelist_index(__i);\n-                  __p = *__my_free_list;\n+                  __free_list = _S_free_list + _S_freelist_index(__i);\n+                  __p = *__free_list;\n                   if (__p != 0)\n                     {\n-                      *__my_free_list = __p -> _M_free_list_link;\n+                      *__free_list = __p -> _M_free_list_link;\n                       _S_start_free = (char*)__p;\n                       _S_end_free = _S_start_free + __i;\n-                      return _S_chunk_alloc(__size, __nobjs);\n+                      return _S_chunk_alloc(__n, __nobjs);\n                       // Any leftover piece will eventually make it to the\n                       // right free list.\n                     }\n@@ -290,11 +232,10 @@ namespace __gnu_cxx\n             }\n           _S_heap_size += __bytes_to_get;\n           _S_end_free = _S_start_free + __bytes_to_get;\n-          return _S_chunk_alloc(__size, __nobjs);\n+          return _S_chunk_alloc(__n, __nobjs);\n         }\n     }\n \n-\n   // Returns an object of size __n, and optionally adds to \"size\n   // __n\"'s free list.  We assume that __n is properly aligned.  We\n   // hold the allocation lock.\n@@ -304,19 +245,19 @@ namespace __gnu_cxx\n     {\n       int __nobjs = 20;\n       char* __chunk = _S_chunk_alloc(__n, __nobjs);\n-      _Obj* volatile* __my_free_list;\n+      _Obj* volatile* __free_list;\n       _Obj* __result;\n       _Obj* __current_obj;\n       _Obj* __next_obj;\n       int __i;\n \n       if (1 == __nobjs)\n         return __chunk;\n-      __my_free_list = _S_free_list + _S_freelist_index(__n);\n+      __free_list = _S_free_list + _S_freelist_index(__n);\n \n       // Build free list in chunk.\n       __result = (_Obj*)(void*)__chunk;\n-      *__my_free_list = __next_obj = (_Obj*)(void*)(__chunk + __n);\n+      *__free_list = __next_obj = (_Obj*)(void*)(__chunk + __n);\n       for (__i = 1; ; __i++)\n         {\n \t  __current_obj = __next_obj;\n@@ -332,10 +273,69 @@ namespace __gnu_cxx\n       return __result;\n     }\n \n+  template<bool __threads, int __inst>\n+    void*\n+    __pool_alloc<__threads, __inst>::allocate(size_t __n)\n+    {\n+      void* __ret = 0;\n+\n+      // If there is a race through here, assume answer from getenv\n+      // will resolve in same direction.  Inspired by techniques\n+      // to efficiently support threading found in basic_string.h.\n+      if (_S_force_new == 0)\n+\t{\n+\t  if (getenv(\"GLIBCPP_FORCE_NEW\"))\n+\t    __atomic_add(&_S_force_new, 1);\n+\t  else\n+\t    __atomic_add(&_S_force_new, -1);\n+\t}\n+      \n+      if ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n+\t__ret = __new_alloc::allocate(__n);\n+      else\n+\t{\n+\t  _Obj* volatile* __free_list = _S_free_list + _S_freelist_index(__n);\n+\t  // Acquire the lock here with a constructor call.  This\n+\t  // ensures that it is released in exit or during stack\n+\t  // unwinding.\n+\t  _Lock __lock_instance;\n+\t  _Obj* __restrict__ __result = *__free_list;\n+\t  if (__builtin_expect(__result == 0, 0))\n+\t    __ret = _S_refill(_S_round_up(__n));\n+\t  else\n+\t    {\n+\t      *__free_list = __result -> _M_free_list_link;\n+\t      __ret = __result;\n+\t    }\t    \n+\t  if (__builtin_expect(__ret == 0, 0))\n+\t    __throw_bad_alloc();\n+\t}\n+      return __ret;\n+    }\n+  \n+  template<bool __threads, int __inst>\n+    void\n+    __pool_alloc<__threads, __inst>::deallocate(void* __p, size_t __n)\n+    {\n+      if ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n+\t__new_alloc::deallocate(__p, __n);\n+      else\n+\t{\n+\t  _Obj* volatile* __free_list = _S_free_list + _S_freelist_index(__n);\n+\t  _Obj* __q = (_Obj*)__p;\n+\t  \n+\t  // Acquire the lock here with a constructor call.  This\n+\t  // ensures that it is released in exit or during stack\n+\t  // unwinding.\n+\t  _Lock __lock_instance;\n+\t  __q -> _M_free_list_link = *__free_list;\n+\t  *__free_list = __q;\n+\t}\n+    }\n \n   template<bool __threads, int __inst>\n-    _STL_mutex_lock\n-    __pool_alloc<__threads, __inst>::_S_lock __STL_MUTEX_INITIALIZER;\n+    typename __pool_alloc<__threads, __inst>::_Obj* volatile\n+    __pool_alloc<__threads, __inst>::_S_free_list[_S_freelists];\n \n   template<bool __threads, int __inst>\n     char* __pool_alloc<__threads, __inst>::_S_start_free = 0;\n@@ -347,8 +347,18 @@ namespace __gnu_cxx\n     size_t __pool_alloc<__threads, __inst>::_S_heap_size = 0;\n \n   template<bool __threads, int __inst>\n-    typename __pool_alloc<__threads, __inst>::_Obj* volatile\n-    __pool_alloc<__threads, __inst>::_S_free_list[_S_freelists];\n+    _STL_mutex_lock\n+    __pool_alloc<__threads, __inst>::_S_lock __STL_MUTEX_INITIALIZER;\n+\n+  template<bool __threads, int __inst> _Atomic_word\n+  __pool_alloc<__threads, __inst>::_S_force_new = 0;\n+\n+  // Inhibit implicit instantiations for required instantiations,\n+  // which are defined via explicit instantiations elsewhere.\n+  // NB: This syntax is a GNU extension.\n+#if _GLIBCPP_EXTERN_TEMPLATE\n+  extern template class __pool_alloc<true, 0>;\n+#endif\n } // namespace __gnu_cxx\n \n namespace std"}, {"sha": "24a7b415daf1c62e347d1b064301986e08c70d00", "filename": "libstdc++-v3/src/allocator-inst.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc?ref=c37514ff623f1d8ea7cf9fa5a5af15ab70e4902b", "patch": "@@ -39,3 +39,8 @@ namespace std\n   template class allocator<char>;\n   template class allocator<wchar_t>;\n } // namespace std\n+\n+namespace __gnu_cxx\n+{\n+  template class __pool_alloc<true, 0>;\n+} // namespace __gnu_cxx"}]}