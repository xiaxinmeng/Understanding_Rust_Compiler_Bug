{"sha": "9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVjODE5ZDQ5Y2E4MTU1NTFiM2ZkOGNkNGUxMjAyZTg5OGJhYzhkNQ==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-09-30T23:35:07Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-09-30T23:35:07Z"}, "message": "Simplify lexer.  Implement --enable-mapped-location support.\n\n\t* jcf-parse.c (parse_class_file):  Use linemap_line_start.\n\t(parse_source_file_1): Pass filename as extra parameter, so we can call\n\tlinemap_add and set input_location here, rather than in both callers.\n\t(read_class): Pass copied filename to parse_source_file_1.\n\tDon't initialize wfl_operator - only needed for source compilation.\n\t(read_class, jcf_parse):  Call linemap_add with LC_LEAVE.\n\t* lex.h:  Remove a bunch of debugging macros.\n\t* lex.h (struct_java_line, struct java_error):  Remove types.\n\t(JAVA_COLUMN_DELTA):  Remove - use java_lexer.next_colums instead.\n\t(struct java_lc_s):  Remove prev_col field.\n\t(struct java_lexer):  New fields next_unicode, next_columns, and\n\tavail_unicode.  New position field, and maybe token_start field.\n\tDon't need hit_eof field - use next_unicode == -1 instead.\n\t(JAVA_INTEGERAL_RANGE_ERROR):  Rename to JAVA_RANGE_ERROR.\n\t(JAVA_RANGE_ERROR, JAVA_FLOAT_ANGE_ERROR):  Update accordingly.\n\t* parse.h:  Various changes for USE_MAPPED_LOCATION.\n\t(EXPR_WFL_EMIT_LINE_NOTE): XXX\n\t(BUILD_EXPR_WFL, EXPR_WFL_ADD_COL): Remove no-longer-used macros.\n\t(struct parser_ctxt):  New file_start_location field.\n\tRemove p_line, c_line fields since we no longer save lines.\n\tRemove elc, lineno, and current_jcf fields - no longer used.\n\t* parse.y:  Updates for USE_MAPPED_LOCATION and new lexer.\n\tDon't use EXPR_WFL_ADD_COL since that isn't trivial with\n\tsource_location and is probably not needed anymore anyway.\n\tUse new expr_add_Location function.\n\t(SET_EXPR_LOCATION_FROM_TOKEN):  New convenience macro.\n\t(java_pop_parser_context):  Minor cleanup.\n\t(java_parser_context_save_global, java_parser_context_restore_global,\n\tjava_pop_parser_context):  Save/restore input_location as a unit.\n\t(issue_warning_error_from_context):  If USE_MAPPED_LOCATION take\n\ta source_location instead of a wfl context node.\n\t(check_class_interface_creation):  input_filename is not addressable.\n\t(create_artificial_method):  Calling java_parser_context_save_global\n\tand java_parser_context_restore_global is overkill.  Instead,\n\ttemporarily set input_location from class decl.\n\t(java_layout_seen_class_methods): Set input_location from method decl.\n\t(fix_constructors): Make more robust if no EXPR_WITH_FILE_LOCATION.\n\t(finish_loop_body):  Likewise.\n\t* lex.c: Updates for USE_MAPPED_LOCATION.  Use build_unknwon_wfl.\n\t(java_sprint_unicode):  Take a character, not index in line.\n\t(java_sneak_uncode):  Replaced by java_peek_unicode.\n\t(java_unget_unicode):  No longer used.\n\t(java_allocate_new_line. java_store_unicode):  Removed, since we\n\tno longer remember \"lines\".\n\t(java_new_lexer):  Update for new data structures.\n\t(java_read_char):  Move unget_value checking to java_read_unicode.\n\t(java_get_unicode, java_peek_unicode, java_next_unicode): New more\n\tefficient functions that are used directly when lexing.\n\t(java_read_unicode_collapsing_terminators):  No longer needed.\n\t(java_parse_end_comment, java_parse_escape_sequence, do_java_lex):\n\tRe-organize to use java_peek_unicode to avoid java_unget_unicode.\n\t(java_parse_escape_sequence):  Rewrite to be simpler / more efficient.\n\t(do_java_lex):  Lots of movings around to avoid java_unget_unicode,\n\tcombine switch branches, and test for common token kinds earlier.\n\t(java_lex_error):  Rewrite.\n\t* jv-scan.c (expand_location): New function, copied from tree.c.\n\t(main): Set ctxp->filename instead of setting input_filename directly.\n\nFrom-SVN: r88367", "tree": {"sha": "d3e8024e8ba3df366d03490e5511ea3378e8ed60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3e8024e8ba3df366d03490e5511ea3378e8ed60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb3a14307a07a4f9d719f229caff8c47aed42624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3a14307a07a4f9d719f229caff8c47aed42624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb3a14307a07a4f9d719f229caff8c47aed42624"}], "stats": {"total": 1807, "additions": 1081, "deletions": 726}, "files": [{"sha": "17faa138a97ade745a0e643d43449b899bcd66fe", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "patch": "@@ -1,3 +1,64 @@\n+2004-09-30  Per Bothner  <per@bothner.com>\n+\n+\tSimplify lexer.  Implement --enable-mapped-location support.\n+\t* jcf-parse.c (parse_class_file):  Use linemap_line_start.\n+\t(parse_source_file_1): Pass filename as extra parameter, so we can call\n+\tlinemap_add and set input_location here, rather than in both callers.\n+\t(read_class): Pass copied filename to parse_source_file_1.\n+\tDon't initialize wfl_operator - only needed for source compilation.\n+\t(read_class, jcf_parse):  Call linemap_add with LC_LEAVE.\n+\t* lex.h:  Remove a bunch of debugging macros.\n+\t* lex.h (struct_java_line, struct java_error):  Remove types.\n+\t(JAVA_COLUMN_DELTA):  Remove - use java_lexer.next_colums instead.\n+\t(struct java_lc_s):  Remove prev_col field.\n+\t(struct java_lexer):  New fields next_unicode, next_columns, and\n+\tavail_unicode.  New position field, and maybe token_start field.\n+\tDon't need hit_eof field - use next_unicode == -1 instead.\n+\t(JAVA_INTEGERAL_RANGE_ERROR):  Rename to JAVA_RANGE_ERROR.\n+\t(JAVA_RANGE_ERROR, JAVA_FLOAT_ANGE_ERROR):  Update accordingly.\n+\t* parse.h:  Various changes for USE_MAPPED_LOCATION.\n+\t(EXPR_WFL_EMIT_LINE_NOTE): XXX\n+\t(BUILD_EXPR_WFL, EXPR_WFL_ADD_COL): Remove no-longer-used macros.\n+\t(struct parser_ctxt):  New file_start_location field.\n+\tRemove p_line, c_line fields since we no longer save lines.\n+\tRemove elc, lineno, and current_jcf fields - no longer used.\n+\t* parse.y:  Updates for USE_MAPPED_LOCATION and new lexer.\n+\tDon't use EXPR_WFL_ADD_COL since that isn't trivial with\n+\tsource_location and is probably not needed anymore anyway.\n+\tUse new expr_add_Location function.\n+\t(SET_EXPR_LOCATION_FROM_TOKEN):  New convenience macro.\n+\t(java_pop_parser_context):  Minor cleanup.\n+\t(java_parser_context_save_global, java_parser_context_restore_global,\n+\tjava_pop_parser_context):  Save/restore input_location as a unit.\n+\t(issue_warning_error_from_context):  If USE_MAPPED_LOCATION take\n+\ta source_location instead of a wfl context node.\n+\t(check_class_interface_creation):  input_filename is not addressable.\n+\t(create_artificial_method):  Calling java_parser_context_save_global\n+\tand java_parser_context_restore_global is overkill.  Instead,\n+\ttemporarily set input_location from class decl.\n+\t(java_layout_seen_class_methods): Set input_location from method decl.\n+\t(fix_constructors): Make more robust if no EXPR_WITH_FILE_LOCATION.\n+\t(finish_loop_body):  Likewise.\n+\t* lex.c: Updates for USE_MAPPED_LOCATION.  Use build_unknwon_wfl.\n+\t(java_sprint_unicode):  Take a character, not index in line.\n+\t(java_sneak_uncode):  Replaced by java_peek_unicode.\n+\t(java_unget_unicode):  No longer used.\n+\t(java_allocate_new_line. java_store_unicode):  Removed, since we\n+\tno longer remember \"lines\".\n+\t(java_new_lexer):  Update for new data structures.\n+\t(java_read_char):  Move unget_value checking to java_read_unicode.\n+\t(java_get_unicode, java_peek_unicode, java_next_unicode): New more\n+\tefficient functions that are used directly when lexing.\n+\t(java_read_unicode_collapsing_terminators):  No longer needed.\n+\t(java_parse_end_comment, java_parse_escape_sequence, do_java_lex):\n+\tRe-organize to use java_peek_unicode to avoid java_unget_unicode.\n+\t(java_parse_escape_sequence):  Rewrite to be simpler / more efficient.\n+\t(do_java_lex):  Lots of movings around to avoid java_unget_unicode,\n+\tcombine switch branches, and test for common token kinds earlier.\n+\t(java_lex_error):  Rewrite.\n+\t* jv-scan.c (expand_location): New function, copied from tree.c.\n+\t(main): Set ctxp->filename instead of setting input_filename directly.\n+\n 2004-09-30  Per Bothner  <per@bothner.com>\n \n \tMore cleanup for --enable-mapped-location.\n@@ -30,7 +91,7 @@\n \n 2004-09-29  Per Bothner  <per@bothner.com>\n \n-\t* java-tree.h:  Redefine some macros and add soem declaration\n+\t* java-tree.h:  Redefine some macros and add some declaration\n \tto handle the USE_MAPPED_LOCATION case.\n \t* parse.h (EXPR_WFL_QUALIFICATION):  Use operand 1, not 2.\n \t* java-tree.h (EXPR_WFL_FILENAME_NODE):  Use operand 2, not 1."}, {"sha": "74f45de7a0b5874b96f64356b1f4933636d231be", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "patch": "@@ -98,7 +98,7 @@ static char *compute_class_name (struct ZipDirectory *zdir);\n static int classify_zip_file (struct ZipDirectory *zdir);\n static void parse_zip_file_entries (void);\n static void process_zip_dir (FILE *);\n-static void parse_source_file_1 (tree, FILE *);\n+static void parse_source_file_1 (tree, const char *, FILE *);\n static void parse_source_file_2 (void);\n static void parse_source_file_3 (void);\n static void parse_class_file (void);\n@@ -544,27 +544,27 @@ read_class (tree name)\n       java_push_parser_context ();\n \n       given_file = get_identifier (filename);\n+      filename = IDENTIFIER_POINTER (given_file);\n       real_file = get_identifier (lrealpath (filename));\n \n       generate = IS_A_COMMAND_LINE_FILENAME_P (given_file);\n-      if (wfl_operator == NULL_TREE)\n-\twfl_operator = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n-      EXPR_WFL_FILENAME_NODE (wfl_operator) = given_file;\n-      input_filename = ggc_strdup (filename);\n       output_class = current_class = NULL_TREE;\n       current_function_decl = NULL_TREE;\n \n       if (! HAS_BEEN_ALREADY_PARSED_P (real_file))\n \t{\n-\t  if (! (finput = fopen (input_filename, \"r\")))\n-\t    fatal_error (\"can't reopen %s: %m\", input_filename);\n+\t  if (! (finput = fopen (filename, \"r\")))\n+\t    fatal_error (\"can't reopen %s: %m\", filename);\n \n-\t  parse_source_file_1 (real_file, finput);\n+\t  parse_source_file_1 (real_file, filename, finput);\n \t  parse_source_file_2 ();\n \t  parse_source_file_3 ();\n \n \t  if (fclose (finput))\n \t    fatal_error (\"can't close %s: %m\", input_filename);\n+#ifdef USE_MAPPED_LOCATION\n+\t  linemap_add (&line_table, LC_LEAVE, false, NULL, 0);\n+#endif\n \t}\n       JCF_FINISH (current_jcf);\n       java_pop_parser_context (generate);\n@@ -577,7 +577,7 @@ read_class (tree name)\n \t  java_parser_context_save_global ();\n \t  java_push_parser_context ();\n \t  output_class = current_class = class;\n-\t  input_filename = current_jcf->filename;\n+\t  ctxp->save_location = input_location;\n \t  if (JCF_SEEN_IN_ZIP (current_jcf))\n \t    read_zip_member(current_jcf,\n \t\t\t    current_jcf->zipd, current_jcf->zipd->zipf);\n@@ -710,6 +710,9 @@ jcf_parse (JCF* jcf)\n   code = jcf_parse_final_attributes (jcf);\n   if (code != 0)\n     fatal_error (\"error while parsing final attributes\");\n+#ifdef USE_MAPPED_LOCATION\n+  linemap_add (&line_table, LC_LEAVE, false, NULL, 0);\n+#endif\n \n   /* The fields of class_type_node are already in correct order. */\n   if (current_class != class_type_node && current_class != object_type_node)\n@@ -804,10 +807,11 @@ parse_class_file (void)\n \t  continue;\n \t}\n \n-      input_line = 0;\n+      input_location = file_start_location;\n       if (DECL_LINENUMBERS_OFFSET (method))\n \t{\n \t  int i;\n+\t  int min_line = 0;\n \t  unsigned char *ptr;\n \t  JCF_SEEK (jcf, DECL_LINENUMBERS_OFFSET (method));\n \t  linenumber_count = i = JCF_readu2 (jcf);\n@@ -818,9 +822,16 @@ parse_class_file (void)\n \t      int line = GET_u2 (ptr);\n \t      /* Set initial input_line to smallest linenumber.\n \t       * Needs to be set before init_function_start. */\n-\t      if (input_line == 0 || line < input_line)\n-\t\tinput_line = line;\n-\t    }  \n+\t      if (min_line == 0 || line < min_line)\n+\t\tmin_line = line;\n+\t    }\n+#ifdef USE_MAPPED_LOCATION\n+\t  if (min_line != 0)\n+\t    input_location = linemap_line_start (&line_table, min_line, 1);\n+#else\n+\t  if (min_line != 0)\n+\t    input_line = min_line;\n+#endif\n \t}\n       else\n \t{\n@@ -845,22 +856,20 @@ parse_class_file (void)\n \n   finish_class ();\n \n-  (*debug_hooks->end_source_file) (save_location.line);\n+  (*debug_hooks->end_source_file) (LOCATION_LINE (save_location));\n   input_location = save_location;\n }\n \n /* Parse a source file, as pointed by the current value of INPUT_FILENAME. */\n \n static void\n-parse_source_file_1 (tree real_file, FILE *finput)\n+parse_source_file_1 (tree real_file, const char *filename, FILE *finput)\n {\n   int save_error_count = java_error_count;\n \n   /* Mark the file as parsed.  */\n   HAS_BEEN_ALREADY_PARSED_P (real_file) = 1;\n \n-  jcf_dependency_add_file (input_filename, 0);\n-\n   lang_init_source (1);\t\t    /* Error msgs have no method prototypes */\n \n   /* There's no point in trying to find the current encoding unless we\n@@ -874,6 +883,18 @@ parse_source_file_1 (tree real_file, FILE *finput)\n   if (current_encoding == NULL || *current_encoding == '\\0')\n     current_encoding = DEFAULT_ENCODING;\n \n+#ifdef USE_MAPPED_LOCATION\n+  linemap_add (&line_table, LC_ENTER, false, filename, 0);\n+  input_location = linemap_line_start (&line_table, 0, 125);\n+#else\n+  input_filename = filename;\n+  input_line = 0;\n+#endif\n+  ctxp->file_start_location = input_location;\n+  ctxp->filename = filename;\n+\n+  jcf_dependency_add_file (input_filename, 0);\n+\n   /* Initialize the parser */\n   java_init_lex (finput, current_encoding);\n   java_parse_abort_on_error ();\n@@ -1147,21 +1168,24 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t  java_push_parser_context ();\n \t  java_parser_context_save_global ();\n \n-\t  parse_source_file_1 (real_file, finput);\n+\t  parse_source_file_1 (real_file, filename, finput);\n \t  java_parser_context_restore_global ();\n \t  java_pop_parser_context (1);\n+#ifdef USE_MAPPED_LOCATION\n+\t  linemap_add (&line_table, LC_LEAVE, false, NULL, 0);\n+#endif\n \t}\n     }\n \n   for (ctxp = ctxp_for_generation;  ctxp;  ctxp = ctxp->next)\n     {\n-      input_filename = ctxp->filename;\n+      input_location = ctxp->file_start_location;\n       parse_source_file_2 ();\n     }\n \n   for (ctxp = ctxp_for_generation; ctxp; ctxp = ctxp->next)\n     {\n-      input_filename = ctxp->filename;\n+      input_location = ctxp->file_start_location;\n       parse_source_file_3 ();\n     }\n "}, {"sha": "9892605142f510488f0df663f3a4baa30ad91c0b", "filename": "gcc/java/jv-scan.c", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Fjv-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Fjv-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjv-scan.c?ref=9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "patch": "@@ -59,6 +59,8 @@ FILE *finput, *out;\n /* Executable name.  */\n char *exec_name;\n \n+struct line_maps line_table;\n+\n /* Flags matching command line options.  */\n int flag_find_main = 0;\n int flag_dump_class = 0;\n@@ -129,6 +131,29 @@ version (void)\n   exit (0);\n }\n \n+#ifdef USE_MAPPED_LOCATION\n+/* FIXME - this is the same as the function in tree.c, which is awkward.\n+   Probably the cleanest solution is to move the function to line-map.c.\n+   This is difficult as long as we still support --disable-mapped-location,\n+   since whether expanded_location has a column fields depends on\n+   USE_MAPPED_LOCATION. */\n+\n+expanded_location\n+expand_location (source_location loc)\n+{\n+  expanded_location xloc;\n+  if (loc == 0) { xloc.file = NULL; xloc.line = 0;  xloc.column = 0; }\n+  else\n+    {\n+      const struct line_map *map = linemap_lookup (&line_table, loc);\n+      xloc.file = map->to_file;\n+      xloc.line = SOURCE_LINE (map, loc);\n+      xloc.column = SOURCE_COLUMN (map, loc);\n+    };\n+  return xloc;\n+}\n+#endif\n+\n /* jc1-lite main entry point */\n int\n main (int argc, char **argv)\n@@ -198,8 +223,8 @@ main (int argc, char **argv)\n   for ( i = optind; i < argc; i++ )\n     if (argv [i])\n       {\n-\tinput_filename = argv [i];\n-\tif ( (finput = fopen (argv [i], \"r\")) )\n+\tchar *filename = argv[i];\n+\tif ( (finput = fopen (filename, \"r\")) )\n \t  {\n \t    /* There's no point in trying to find the current encoding\n \t       unless we are going to do something intelligent with it\n@@ -213,6 +238,7 @@ main (int argc, char **argv)\n \t      encoding = DEFAULT_ENCODING;\n \n \t    java_init_lex (finput, encoding);\n+\t    ctxp->filename = filename;\n \t    yyparse ();\n \t    report ();\n \t    if (ftell (out) != ft)"}, {"sha": "2b299eee9579b7abc4221c7c5fad092cacb83f20", "filename": "gcc/java/lex.c", "status": "modified", "additions": 482, "deletions": 482, "changes": 964, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "patch": "@@ -43,7 +43,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #endif\n \n /* Function declarations.  */\n-static char *java_sprint_unicode (struct java_line *, int);\n+static char *java_sprint_unicode (int);\n static void java_unicode_2_utf8 (unicode_t);\n static void java_lex_error (const char *, int);\n #ifndef JC1_LITE\n@@ -52,21 +52,17 @@ static int java_lex (YYSTYPE *);\n static int java_is_eol (FILE *, int);\n static tree build_wfl_node (tree);\n #endif\n-static void java_store_unicode (struct java_line *, unicode_t, int);\n static int java_parse_escape_sequence (void);\n static int java_start_char_p (unicode_t);\n static int java_part_char_p (unicode_t);\n static int java_space_char_p (unicode_t);\n static void java_parse_doc_section (int);\n static void java_parse_end_comment (int);\n+static int java_read_char (java_lexer *);\n static int java_get_unicode (void);\n+static int java_peek_unicode (void);\n+static void java_next_unicode (void);\n static int java_read_unicode (java_lexer *, int *);\n-static int java_read_unicode_collapsing_terminators (java_lexer *, int *);\n-static void java_store_unicode (struct java_line *, unicode_t, int);\n-static int java_read_char (java_lexer *);\n-static void java_allocate_new_line (void);\n-static void java_unget_unicode (void);\n-static unicode_t java_sneak_unicode (void);\n #ifndef JC1_LITE\n static int utf8_cmp (const unsigned char *, int, const char *);\n #endif\n@@ -102,120 +98,61 @@ java_init_lex (FILE *finput, const char *encoding)\n \n   if (!java_lang_imported)\n     {\n-      tree node = build_tree_list \n-\t(build_expr_wfl (java_lang_id, NULL, 0, 0), NULL_TREE);\n+      tree node = build_tree_list (build_unknown_wfl (java_lang_id),\n+\t\t\t\t   NULL_TREE);\n       read_import_dir (TREE_PURPOSE (node));\n       TREE_CHAIN (node) = ctxp->import_demand_list;\n       ctxp->import_demand_list = node;\n       java_lang_imported = 1;\n     }\n \n   if (!wfl_operator)\n-    wfl_operator = build_expr_wfl (NULL_TREE, ctxp->filename, 0, 0);\n+    {\n+#ifdef USE_MAPPED_LOCATION\n+      wfl_operator = build_expr_wfl (NULL_TREE, input_location);\n+#else\n+      wfl_operator = build_expr_wfl (NULL_TREE, ctxp->filename, 0, 0);\n+#endif\n+    }\n   if (!label_id)\n     label_id = get_identifier (\"$L\");\n   if (!wfl_append) \n-    wfl_append = build_expr_wfl (get_identifier (\"append\"), NULL, 0, 0);\n+    wfl_append = build_unknown_wfl (get_identifier (\"append\"));\n   if (!wfl_string_buffer)\n     wfl_string_buffer = \n-      build_expr_wfl (get_identifier (flag_emit_class_files\n+      build_unknown_wfl (get_identifier (flag_emit_class_files\n \t\t\t\t      ? \"java.lang.StringBuffer\"\n-\t\t\t\t      : \"gnu.gcj.runtime.StringBuffer\"),\n-\t\t      NULL, 0, 0);\n+\t\t\t\t\t : \"gnu.gcj.runtime.StringBuffer\"));\n   if (!wfl_to_string)\n-    wfl_to_string = build_expr_wfl (get_identifier (\"toString\"), NULL, 0, 0);\n+    wfl_to_string = build_unknown_wfl (get_identifier (\"toString\"));\n \n   CPC_INITIALIZER_LIST (ctxp) = CPC_STATIC_INITIALIZER_LIST (ctxp) =\n     CPC_INSTANCE_INITIALIZER_LIST (ctxp) = NULL_TREE;\n \n   memset (ctxp->modifier_ctx, 0, sizeof (ctxp->modifier_ctx));\n-  current_jcf = ggc_alloc_cleared (sizeof (JCF));\n   ctxp->current_parsed_class = NULL;\n   ctxp->package = NULL_TREE;\n #endif\n \n-  ctxp->filename = input_filename;\n-  ctxp->lineno = input_line = 0;\n-  ctxp->p_line = NULL;\n-  ctxp->c_line = NULL;\n+  ctxp->save_location = input_location;\n   ctxp->java_error_flag = 0;\n   ctxp->lexer = java_new_lexer (finput, encoding);\n }\n \n static char *\n-java_sprint_unicode (struct java_line *line, int i)\n+java_sprint_unicode (int c)\n {\n   static char buffer [10];\n-  if (line->unicode_escape_p [i] || line->line [i] > 128)\n-    sprintf (buffer, \"\\\\u%04x\", line->line [i]);\n+  if (c < ' ' || c >= 127)\n+    sprintf (buffer, \"\\\\u%04x\", c);\n   else\n     {\n-      buffer [0] = line->line [i];\n+      buffer [0] = c;\n       buffer [1] = '\\0';\n     }\n   return buffer;\n }\n \n-static unicode_t\n-java_sneak_unicode (void)\n-{\n-  return (ctxp->c_line->line [ctxp->c_line->current]);\n-}\n-\n-static void\n-java_unget_unicode (void)\n-{\n-  if (!ctxp->c_line->current)\n-    /* Can't unget unicode.  */\n-    abort ();\n-\n-  ctxp->c_line->current--;\n-  ctxp->c_line->char_col -= JAVA_COLUMN_DELTA (0);\n-}\n-\n-static void\n-java_allocate_new_line (void)\n-{\n-  unicode_t ahead = (ctxp->c_line ? ctxp->c_line->ahead[0] : '\\0');\n-  char ahead_escape_p = (ctxp->c_line ? \n-\t\t\t ctxp->c_line->unicode_escape_ahead_p : 0);\n-\n-  if (ctxp->c_line && !ctxp->c_line->white_space_only)\n-    {\n-      if (ctxp->p_line)\n-\t{\n-\t  free (ctxp->p_line->unicode_escape_p);\n-\t  free (ctxp->p_line->line);\n-\t  free (ctxp->p_line);\n-\t}\n-      ctxp->p_line = ctxp->c_line;\n-      ctxp->c_line = NULL;\t\t/* Reallocated.  */\n-    }\n-\n-  if (!ctxp->c_line)\n-    {\n-      ctxp->c_line = xmalloc (sizeof (struct java_line));\n-      ctxp->c_line->max = JAVA_LINE_MAX;\n-      ctxp->c_line->line = xmalloc (sizeof (unicode_t)*ctxp->c_line->max);\n-      ctxp->c_line->unicode_escape_p = \n-\txmalloc (sizeof (char)*ctxp->c_line->max);\n-      ctxp->c_line->white_space_only = 0;\n-    }\n-\n-  ctxp->c_line->line [0] = ctxp->c_line->size = 0;\n-  ctxp->c_line->char_col = ctxp->c_line->current = 0;\n-  if (ahead)\n-    {\n-      ctxp->c_line->line [ctxp->c_line->size] = ahead;\n-      ctxp->c_line->unicode_escape_p [ctxp->c_line->size] = ahead_escape_p;\n-      ctxp->c_line->size++;\n-    }\n-  ctxp->c_line->ahead [0] = 0;\n-  ctxp->c_line->unicode_escape_ahead_p = 0;\n-  ctxp->c_line->lineno = ++input_line;\n-  ctxp->c_line->white_space_only = 1;\n-}\n-\n /* Create a new lexer object.  */\n \n java_lexer *\n@@ -227,8 +164,20 @@ java_new_lexer (FILE *finput, const char *encoding)\n   lex->finput = finput;\n   lex->bs_count = 0;\n   lex->unget_value = 0;\n-  lex->hit_eof = 0;\n+  lex->next_unicode = 0;\n+  lex->avail_unicode = 0;\n+  lex->next_columns = 1;\n   lex->encoding = encoding;\n+  lex->position.line = 1;\n+  lex->position.col = 1;\n+#ifndef JC1_LITE\n+#ifdef USE_MAPPED_LOCATION\n+      input_location\n+\t= linemap_line_start (&line_table, 1, 120);\n+#else\n+      input_line = 1;\n+#endif\n+#endif\n \n #ifdef HAVE_ICONV\n   lex->handle = iconv_open (\"UCS-2\", encoding);\n@@ -322,13 +271,6 @@ java_destroy_lexer (java_lexer *lex)\n static int\n java_read_char (java_lexer *lex)\n {\n-  if (lex->unget_value)\n-    {\n-      unicode_t r = lex->unget_value;\n-      lex->unget_value = 0;\n-      return r;\n-    }\n-\n #ifdef HAVE_ICONV\n   if (! lex->use_fallback)\n     {\n@@ -513,26 +455,19 @@ java_read_char (java_lexer *lex)\n   return UEOF;\n }\n \n-static void\n-java_store_unicode (struct java_line *l, unicode_t c, int unicode_escape_p)\n-{\n-  if (l->size == l->max)\n-    {\n-      l->max += JAVA_LINE_MAX;\n-      l->line = xrealloc (l->line, sizeof (unicode_t)*l->max);\n-      l->unicode_escape_p = xrealloc (l->unicode_escape_p, \n-\t\t\t\t      sizeof (char)*l->max);\n-    }\n-  l->line [l->size] = c;\n-  l->unicode_escape_p [l->size++] = unicode_escape_p;\n-}\n-\n static int\n java_read_unicode (java_lexer *lex, int *unicode_escape_p)\n {\n   int c;\n \n-  c = java_read_char (lex);\n+  if (lex->unget_value)\n+    {\n+      c = lex->unget_value;\n+      lex->unget_value = 0;\n+    }\n+  else\n+    c = java_read_char (lex);\n+\n   *unicode_escape_p = 0;\n \n   if (c != '\\\\')\n@@ -589,72 +524,111 @@ java_read_unicode (java_lexer *lex, int *unicode_escape_p)\n   return (unicode_t) '\\\\';\n }\n \n+/* Get the next Unicode character (post-Unicode-escape-handling).\n+   Move the current position to just after returned character. */\n+\n+static int\n+java_get_unicode (void)\n+{\n+  int next = java_peek_unicode ();\n+  java_next_unicode ();\n+  return next;\n+}\n+\n+/* Return the next Unicode character (post-Unicode-escape-handling).\n+   Do not move the current position, which remains just before\n+   the returned character. */\n+\n static int\n-java_read_unicode_collapsing_terminators (java_lexer *lex,\n-\t\t\t\t\t  int *unicode_escape_p)\n+java_peek_unicode (void)\n {\n-  int c = java_read_unicode (lex, unicode_escape_p);\n+  int unicode_escape_p;\n+  java_lexer *lex = ctxp->lexer;\n+  if (lex->avail_unicode)\n+    return lex->next_unicode;\n+  int next;\n \n-  if (c == '\\r')\n+  next = java_read_unicode (lex, &unicode_escape_p);\n+\n+  if (next == '\\r')\n     {\n-      /* We have to read ahead to see if we got \\r\\n.  In that case we\n-\t return a single line terminator.  */\n+      /* We have to read ahead to see if we got \\r\\n.\n+\t In that case we return a single line terminator.  */\n       int dummy;\n-      c = java_read_unicode (lex, &dummy);\n-      if (c != '\\n' && c != UEOF)\n-\tlex->unget_value = c;\n+      next = java_read_unicode (lex, &dummy);\n+      if (next != '\\n' && next != UEOF)\n+\tlex->unget_value = next;\n       /* In either case we must return a newline.  */\n-      c = '\\n';\n+      next = '\\n';\n     }\n \n-  return c;\n-}\n+  lex->next_unicode = next;\n+  lex->avail_unicode = 1;\n \n-static int\n-java_get_unicode (void)\n-{\n-  /* It's time to read a line when...  */\n-  if (!ctxp->c_line || ctxp->c_line->current == ctxp->c_line->size)\n+  if (next == UEOF)\n     {\n-      int c;\n-      int found_chars = 0;\n+      lex->next_columns = 0;\n+      return next;\n+    }\n \n-      if (ctxp->lexer->hit_eof)\n-\treturn UEOF;\n+  if (next == '\\n')\n+    {\n+      lex->next_columns = 1 - lex->position.col;\n+    }\n+  else if (next == '\\t')\n+    {\n+      int cur_col = lex->position.col;\n+      lex->next_columns = ((cur_col + 7) & ~7) + 1 - cur_col;\n+      \n+    }\n+  else\n+    {\n+      lex->next_columns = 1;\n+    }\n+  if (unicode_escape_p)\n+    lex->next_columns = 6;\n+  return next;\n+}\n \n-      java_allocate_new_line ();\n-      if (ctxp->c_line->line[0] != '\\n')\n-\t{\n-\t  for (;;)\n-\t    {\n-\t      int unicode_escape_p;\n-\t      c = java_read_unicode_collapsing_terminators (ctxp->lexer,\n-\t\t\t\t\t\t\t    &unicode_escape_p);\n-\t      if (c != UEOF)\n-\t\t{\n-\t\t  found_chars = 1;\n-\t\t  java_store_unicode (ctxp->c_line, c, unicode_escape_p);\n-\t\t  if (ctxp->c_line->white_space_only \n-\t\t      && !JAVA_WHITE_SPACE_P (c)\n-\t\t      && c != '\\n')\n-\t\t    ctxp->c_line->white_space_only = 0;\n-\t\t}\n-\t      if ((c == '\\n') || (c == UEOF))\n-\t\tbreak;\n-\t    }\n+/* Move forward one Unicode character (post-Unicode-escape-handling).\n+   Only allowed after java_peek_unicode.  The combination java_peek_uncode\n+   followed by java_next_unicode is equivalent to java_get_unicode.  */\n \n-\t  if (c == UEOF && ! found_chars)\n-\t    {\n-\t      ctxp->lexer->hit_eof = 1;\n-\t      return UEOF;\n-\t    }\n-\t}\n+static void java_next_unicode (void)\n+{\n+  struct java_lexer *lex = ctxp->lexer;\n+  lex->position.col += lex->next_columns;\n+  if (lex->next_unicode == '\\n')\n+    {\n+      lex->position.line++; \n+#ifndef JC1_LITE\n+#ifdef USE_MAPPED_LOCATION\n+      input_location\n+\t= linemap_line_start (&line_table, lex->position.line, 120);\n+#else\n+      input_line = lex->position.line;\n+#endif\n+#endif\n     }\n-  ctxp->c_line->char_col += JAVA_COLUMN_DELTA (0);\n-  JAVA_LEX_CHAR (ctxp->c_line->line [ctxp->c_line->current]);\n-  return ctxp->c_line->line [ctxp->c_line->current++];\n+  lex->avail_unicode = 0;\n }\n \n+#if 0\n+/* The inverse of java_next_unicode.\n+   Not currently used, but could be if it would be cleaner or faster.\n+   java_peek_unicode == java_get_unicode + java_unget_unicode.\n+   java_get_unicode == java_peek_unicode + java_next_unicode.\n+*/\n+static void java_unget_unicode ()\n+{\n+  struct java_lexer *lex = ctxp->lexer;\n+  if (lex->avail_unicode)\n+    fatal_error (\"internal error - bad unget\");\n+  lex->avail_unicode = 1;\n+  lex->position.col -= lex->next_columns;\n+}\n+#endif\n+\n /* Parse the end of a C style comment.\n  * C is the first character following the '/' and '*'.  */\n static void\n@@ -668,15 +642,16 @@ java_parse_end_comment (int c)\n \t  java_lex_error (\"Comment not terminated at end of input\", 0);\n \t  return;\n \tcase '*':\n-\t  switch (c = java_get_unicode ())\n+\t  switch (c = java_peek_unicode ())\n \t    {\n \t    case UEOF:\n \t      java_lex_error (\"Comment not terminated at end of input\", 0);\n \t      return;\n \t    case '/':\n+\t      java_next_unicode ();\n \t      return;\n \t    case '*':\t/* Reparse only '*'.  */\n-\t      java_unget_unicode ();\n+\t      ;\n \t    }\n \t}\n     }\n@@ -832,7 +807,6 @@ java_space_char_p (unicode_t c)\n static int\n java_parse_escape_sequence (void)\n {\n-  unicode_t char_lit;\n   int c;\n \n   switch (c = java_get_unicode ())\n@@ -856,33 +830,31 @@ java_parse_escape_sequence (void)\n     case '0': case '1': case '2': case '3': case '4':\n     case '5': case '6': case '7':\n       {\n-\tint octal_escape[3];\n-\tint octal_escape_index = 0;\n-\tint max = 3;\n-\tint i, shift;\n+\tint more = 3;\n+\tunicode_t char_lit = 0;\n \n-\tfor (; octal_escape_index < max && RANGE (c, '0', '7');\n-\t     c = java_get_unicode ())\n+\tif (c > '3')\n \t  {\n-\t    if (octal_escape_index == 0 && c > '3')\n-\t      {\n-\t\t/* According to the grammar, `\\477' has a well-defined\n-\t\t   meaning -- it is `\\47' followed by `7'.  */\n-\t\t--max;\n-\t      }\n-\t    octal_escape [octal_escape_index++] = c;\n+\t    /* According to the grammar, `\\477' has a well-defined\n+\t       meaning -- it is `\\47' followed by `7'.  */\n+\t    --more;\n+\t  }\n+\tchar_lit = 0;\n+\tfor (;;)\n+\t  {\n+\t    char_lit = 8 * char_lit + c - '0';\n+\t    if (--more == 0)\n+\t      break;\n+\t    c = java_peek_unicode ();\n+\t    if (! RANGE (c, '0', '7'))\n+\t      break;\n+\t    java_next_unicode ();\n \t  }\n-\n-\tjava_unget_unicode ();\n-\n-\tfor (char_lit=0, i = 0, shift = 3*(octal_escape_index-1);\n-\t     i < octal_escape_index; i++, shift -= 3)\n-\t  char_lit |= (octal_escape [i] - '0') << shift;\n \n \treturn char_lit;\n       }\n     default:\n-      java_lex_error (\"Invalid character in escape sequence\", 0);\n+      java_lex_error (\"Invalid character in escape sequence\", -1);\n       return JAVA_CHAR_ERROR;\n     }\n }\n@@ -932,10 +904,10 @@ java_perform_atof (YYSTYPE *java_lval, char *literal_token, int fflag,\n \t}\n       if (! really_zero)\n \t{\n-\t  int i = ctxp->c_line->current;\n-\t  ctxp->c_line->current = number_beginning;\n+\t  int save_col = ctxp->lexer->position.col;\n+\t  ctxp->lexer->position.col = number_beginning;\n \t  java_lex_error (\"Floating point literal underflow\", 0);\n-\t  ctxp->c_line->current = i;\n+\t  ctxp->lexer->position.col = save_col;\n \t}\n     }\n \n@@ -953,89 +925,32 @@ do_java_lex (YYSTYPE *java_lval)\n #endif\n {\n   int c;\n-  unicode_t first_unicode;\n-  int ascii_index, all_ascii;\n   char *string;\n \n   /* Translation of the Unicode escape in the raw stream of Unicode\n      characters. Takes care of line terminator.  */\n  step1:\n   /* Skip white spaces: SP, TAB and FF or ULT.  */ \n-  for (c = java_get_unicode ();\n-       c == '\\n' || JAVA_WHITE_SPACE_P (c); c = java_get_unicode ())\n-    if (c == '\\n')\n-      {\n-\tctxp->elc.line = ctxp->c_line->lineno;\n-\tctxp->elc.col  = ctxp->c_line->char_col-2;\n-      }\n-\n-  ctxp->elc.col = (ctxp->elc.col < 0 ? 0 : ctxp->elc.col);\n-\n-  if (c == 0x1a)\t\t/* CTRL-Z.  */\n+  for (;;)\n     {\n-      if ((c = java_get_unicode ()) == UEOF)\n-\treturn 0;\t\t/* Ok here.  */\n-      else\n-\tjava_unget_unicode ();\t/* Caught later, at the end of the\n-                                   function.  */\n+      c = java_peek_unicode ();\n+      if (c != '\\n' && ! JAVA_WHITE_SPACE_P (c))\n+\tbreak;\n+      java_next_unicode ();\n     }\n+\n   /* Handle EOF here.  */\n   if (c == UEOF)\t/* Should probably do something here...  */\n     return 0;\n \n-  /* Take care of eventual comments.  */\n-  if (c == '/')\n-    {\n-      switch (c = java_get_unicode ())\n-\t{\n-\tcase '/':\n-\t  for (;;)\n-\t    {\n-\t      c = java_get_unicode ();\n-\t      if (c == UEOF)\n-\t\t{\n-\t\t  /* It is ok to end a `//' comment with EOF, unless\n-\t\t     we're being pedantic.  */\n-\t\t  if (pedantic)\n-\t\t    java_lex_error (\"Comment not terminated at end of input\",\n-\t\t\t\t    0);\n-\t\t  return 0;\n-\t\t}\n-\t      if (c == '\\n')\t/* ULT */\n-\t\tgoto step1;\n-\t    }\n-\t  break;\n-\n-\tcase '*':\n-\t  if ((c = java_get_unicode ()) == '*')\n-\t    {\n-\t      c = java_get_unicode ();\n-\t      if (c == '/')\n-\t\t{\n-\t\t  /* Empty documentation comment.  We have to reset\n-\t\t     the deprecation marker as only the most recent\n-\t\t     doc comment applies.  */\n-\t\t  ctxp->deprecated = 0;\n-\t\t}\n-\t      else\n-\t\tjava_parse_doc_section (c);\n-\t    }\n-\t  else\n-\t    java_parse_end_comment ((c = java_get_unicode ()));\n-\t  goto step1;\n-\t  break;\n-\tdefault:\n-\t  java_unget_unicode ();\n-\t  c = '/';\n-\t  break;\n-\t}\n-    }\n-\n-  ctxp->elc.line = ctxp->c_line->lineno;\n-  ctxp->elc.prev_col = ctxp->elc.col;\n-  ctxp->elc.col = ctxp->c_line->char_col - JAVA_COLUMN_DELTA (-1);\n-  if (ctxp->elc.col < 0)\n-    abort ();\n+#ifndef JC1_LITE\n+#ifdef USE_MAPPED_LOCATION\n+  LINEMAP_POSITION_FOR_COLUMN (input_location, &line_table,\n+\t\t\t       ctxp->lexer->position.col);\n+#else\n+  ctxp->lexer->token_start = ctxp->lexer->position;\n+#endif\n+#endif\n \n   /* Numeric literals.  */\n   if (JAVA_ASCII_DIGIT (c) || (c == '.'))\n@@ -1047,71 +962,62 @@ do_java_lex (YYSTYPE *java_lval)\n       /* End borrowed section.  */\n       char literal_token [256];\n       int  literal_index = 0, radix = 10, long_suffix = 0, overflow = 0, bytes;\n-      int  found_hex_digits = 0, found_non_octal_digits = 0;\n+      int  found_hex_digits = 0, found_non_octal_digits = -1;\n       int  i;\n #ifndef JC1_LITE\n-      int  number_beginning = ctxp->c_line->current;\n+      int  number_beginning = ctxp->lexer->position.col;\n       tree value;\n #endif\n-      \n-      /* We might have a . separator instead of a FP like .[0-9]*.  */\n-      if (c == '.')\n-\t{\n-\t  unicode_t peep = java_sneak_unicode ();\n-\n-\t  if (!JAVA_ASCII_DIGIT (peep))\n-\t    {\n-\t      JAVA_LEX_SEP('.');\n-\t      BUILD_OPERATOR (DOT_TK);\n-\t    }\n-\t}\n-\n+     \n       for (i = 0; i < TOTAL_PARTS; i++)\n \tparts [i] = 0;\n \n       if (c == '0')\n \t{\n-\t  c = java_get_unicode ();\n+\t  java_next_unicode ();\n+\t  c = java_peek_unicode ();\n \t  if (c == 'x' || c == 'X')\n \t    {\n \t      radix = 16;\n-\t      c = java_get_unicode ();\n+\t      java_next_unicode ();\n+\t      c = java_peek_unicode ();\n \t    }\n \t  else if (JAVA_ASCII_DIGIT (c))\n-\t    radix = 8;\n+\t    {\n+\t      literal_token [literal_index++] = '0';\n+\t      radix = 8;\n+\t    }\n \t  else if (c == '.' || c == 'e' || c =='E')\n \t    {\n-\t      /* Push the '.', 'e', or 'E' back and prepare for a FP\n-\t\t parsing...  */\n-\t      java_unget_unicode ();\n-\t      c = '0';\n+\t      literal_token [literal_index++] = '0';\n+\t      /* Handle C during floating-point parsing.  */\n \t    }\n \t  else\n \t    {\n \t      /* We have a zero literal: 0, 0{l,L}, 0{f,F}, 0{d,D}.  */\n-\t      JAVA_LEX_LIT (\"0\", 10);\n               switch (c)\n \t\t{\t\t\n \t\tcase 'L': case 'l':\n+\t\t  java_next_unicode ();\n \t\t  SET_LVAL_NODE (long_zero_node);\n \t\t  return (INT_LIT_TK);\n \t\tcase 'f': case 'F':\n+\t\t  java_next_unicode ();\n \t\t  SET_LVAL_NODE (float_zero_node);\n \t\t  return (FP_LIT_TK);\n \t\tcase 'd': case 'D':\n+\t\t  java_next_unicode ();\n \t\t  SET_LVAL_NODE (double_zero_node);\n \t\t  return (FP_LIT_TK);\n \t\tdefault:\n-\t\t  java_unget_unicode ();\n \t\t  SET_LVAL_NODE (integer_zero_node);\n \t\t  return (INT_LIT_TK);\n \t\t}\n \t    }\n \t}\n       /* Parse the first part of the literal, until we find something\n \t which is not a number.  */\n-      while ((radix == 16 && JAVA_ASCII_HEXDIGIT (c)) ||\n-\t     JAVA_ASCII_DIGIT (c))\n+      while (radix == 16 ? JAVA_ASCII_HEXDIGIT (c) : JAVA_ASCII_DIGIT (c))\n \t{\n \t  /* We store in a string (in case it turns out to be a FP) and in\n \t     PARTS if we have to process a integer literal.  */\n@@ -1122,8 +1028,8 @@ do_java_lex (YYSTYPE *java_lval)\n \t  if (radix == 16)\n \t    found_hex_digits = 1;\n           /* Remember when we find an invalid octal digit.  */\n-          else if (radix == 8 && !JAVA_ASCII_OCTDIGIT (c))\n-            found_non_octal_digits = 1;\n+          else if (radix == 8 && numeric >= 8 && found_non_octal_digits < 0)\n+\t    found_non_octal_digits = literal_index;\n \n \t  literal_token [literal_index++] = c;\n \t  /* This section of code if borrowed from gcc/c-lex.c.  */\n@@ -1141,13 +1047,20 @@ do_java_lex (YYSTYPE *java_lval)\n \t  if (parts [TOTAL_PARTS-1] != 0)\n \t    overflow = 1;\n \t  /* End borrowed section.  */\n-\t  c = java_get_unicode ();\n+\t  java_next_unicode ();\n+\t  c = java_peek_unicode ();\n \t}\n \n       /* If we have something from the FP char set but not a digit, parse\n \t a FP literal.  */\n       if (JAVA_ASCII_FPCHAR (c) && !JAVA_ASCII_DIGIT (c))\n \t{\n+\t  /* stage==0: seen digits only\n+\t   * stage==1: seen '.'\n+\t   * stage==2: seen 'e' or 'E'.\n+\t   * stage==3: seen '+' or '-' after 'e' or 'E'.\n+\t   * stage==4: seen type suffix ('f'/'F'/'d'/'D')\n+\t   */\n \t  int stage = 0;\n \t  int seen_digit = (literal_index ? 1 : 0);\n \t  int seen_exponent = 0;\n@@ -1168,7 +1081,10 @@ do_java_lex (YYSTYPE *java_lval)\n \t\t    {\n \t\t      stage = 1;\n \t\t      literal_token [literal_index++ ] = c;\n-\t\t      c = java_get_unicode ();\n+\t\t      java_next_unicode ();\n+\t\t      c = java_peek_unicode ();\n+\t\t      if (literal_index == 1 && !JAVA_ASCII_DIGIT (c))\n+\t\t\tBUILD_OPERATOR (DOT_TK);\n \t\t    }\n \t\t  else\n \t\t    java_lex_error (\"Invalid character in FP literal\", 0);\n@@ -1186,7 +1102,8 @@ do_java_lex (YYSTYPE *java_lval)\n \t\t      seen_exponent = 1;\n \t\t      stage = 2;\n \t\t      literal_token [literal_index++] = c;\n-\t\t      c = java_get_unicode ();\n+\t\t      java_next_unicode ();\n+\t\t      c = java_peek_unicode ();\n \t\t    }\n \t\t  else\n \t\t    java_lex_error (\"Invalid character in FP literal\", 0);\n@@ -1201,7 +1118,8 @@ do_java_lex (YYSTYPE *java_lval)\n \t\t{\n \t\t  stage = 3;\n \t\t  literal_token [literal_index++] = c;\n-\t\t  c = java_get_unicode ();\n+\t\t  java_next_unicode ();\n+\t\t  c = java_peek_unicode ();\n \t\t}\n \n \t      if ((stage == 0 && JAVA_ASCII_FPCHAR (c)) ||\n@@ -1214,20 +1132,20 @@ do_java_lex (YYSTYPE *java_lval)\n                   if (stage == 2)\n                     stage = 3;\n \t\t  literal_token [literal_index++ ] = c;\n-\t\t  c = java_get_unicode ();\n+\t\t  java_next_unicode ();\n+\t\t  c = java_peek_unicode ();\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (stage != 4) /* Don't push back fF/dD.  */\n-\t\t    java_unget_unicode ();\n+\t\t  if (stage == 4) /* Don't push back fF/dD.  */\n+\t\t    java_next_unicode ();\n \t\t  \n \t\t  /* An exponent (if any) must have seen a digit.  */\n \t\t  if (seen_exponent && !seen_digit)\n \t\t    java_lex_error\n                       (\"Invalid FP literal, exponent must have digit\", 0);\n \n \t\t  literal_token [literal_index] = '\\0';\n-\t\t  JAVA_LEX_LIT (literal_token, radix);\n \n #ifndef JC1_LITE\n \t\t  java_perform_atof (java_lval, literal_token,\n@@ -1242,17 +1160,19 @@ do_java_lex (YYSTYPE *java_lval)\n       if (radix == 16 && ! found_hex_digits)\n \tjava_lex_error\n \t  (\"0x must be followed by at least one hexadecimal digit\", 0);\n-      else if (radix == 8 && found_non_octal_digits)\n-\tjava_lex_error (\"Octal literal contains digit out of range\", 0);\n+      else if (radix == 8 && found_non_octal_digits >= 0)\n+\t{\n+\t  int back = literal_index - found_non_octal_digits;\n+\t  ctxp->lexer->position.col -= back;\n+\t  java_lex_error (\"Octal literal contains digit out of range\", 0);\n+\t  ctxp->lexer->position.col += back;\n+\t}\n       else if (c == 'L' || c == 'l')\n-\tlong_suffix = 1;\n-      else\n-\tjava_unget_unicode ();\n+\t{\n+\t  java_next_unicode ();\n+\t  long_suffix = 1;\n+\t}\n \n-#ifdef JAVA_LEX_DEBUG\n-      literal_token [literal_index] = '\\0'; /* So JAVA_LEX_LIT is safe.  */\n-      JAVA_LEX_LIT (literal_token, radix);\n-#endif\n       /* This section of code is borrowed from gcc/c-lex.c.  */\n       if (!overflow)\n \t{\n@@ -1294,9 +1214,9 @@ do_java_lex (YYSTYPE *java_lval)\n \t\t\t\t\t   value)))\n \t{\n \t  if (long_suffix)\n-\t    JAVA_INTEGRAL_RANGE_ERROR (\"Numeric overflow for `long' literal\");\n+\t    JAVA_RANGE_ERROR (\"Numeric overflow for 'long' literal\");\n \t  else\n-\t    JAVA_INTEGRAL_RANGE_ERROR (\"Numeric overflow for `int' literal\");\n+\t    JAVA_RANGE_ERROR (\"Numeric overflow for 'int' literal\");\n \t}\n \n       /* Sign extend the value.  */\n@@ -1315,6 +1235,112 @@ do_java_lex (YYSTYPE *java_lval)\n       return INT_LIT_TK;\n     }\n \n+  /* We may have an ID here.  */\n+  if (JAVA_START_CHAR_P (c))\n+    {\n+      int ascii_index = 0, all_ascii = 1;\n+\n+      /* Keyword, boolean literal or null literal.  */\n+      while (c != UEOF && JAVA_PART_CHAR_P (c))\n+\t{\n+\t  java_unicode_2_utf8 (c);\n+\t  if (c >= 128)\n+\t    all_ascii = 0;\n+\t  java_next_unicode ();\n+\t  ascii_index++;\n+\t  c = java_peek_unicode ();\n+\t}\n+\n+      obstack_1grow (&temporary_obstack, '\\0');\n+      string = obstack_finish (&temporary_obstack);\n+\n+      /* If we have something all ascii, we consider a keyword, a boolean\n+\t literal, a null literal or an all ASCII identifier.  Otherwise,\n+\t this is an identifier (possibly not respecting formation rule).  */\n+      if (all_ascii)\n+\t{\n+\t  const struct java_keyword *kw;\n+\t  if ((kw=java_keyword (string, ascii_index)))\n+\t    {\n+\t      switch (kw->token)\n+\t\t{\n+\t\tcase PUBLIC_TK:       case PROTECTED_TK: case STATIC_TK:\n+\t\tcase ABSTRACT_TK:     case FINAL_TK:     case NATIVE_TK:\n+\t\tcase SYNCHRONIZED_TK: case TRANSIENT_TK: case VOLATILE_TK:\n+\t\tcase PRIVATE_TK:      case STRICT_TK:\n+\t\t  SET_MODIFIER_CTX (kw->token);\n+\t\t  return MODIFIER_TK;\n+\t\tcase FLOAT_TK:\n+\t\t  SET_LVAL_NODE (float_type_node);\n+\t\t  return FP_TK;\n+\t\tcase DOUBLE_TK:\n+\t\t  SET_LVAL_NODE (double_type_node);\n+\t\t  return FP_TK;\n+\t\tcase BOOLEAN_TK:\n+\t\t  SET_LVAL_NODE (boolean_type_node);\n+\t\t  return BOOLEAN_TK;\n+\t\tcase BYTE_TK:\n+\t\t  SET_LVAL_NODE (byte_type_node);\n+\t\t  return INTEGRAL_TK;\n+\t\tcase SHORT_TK:\n+\t\t  SET_LVAL_NODE (short_type_node);\n+\t\t  return INTEGRAL_TK;\n+\t\tcase INT_TK:\n+\t\t  SET_LVAL_NODE (int_type_node);\n+\t\t  return INTEGRAL_TK;\n+\t\tcase LONG_TK:\n+\t\t  SET_LVAL_NODE (long_type_node);\n+\t\t  return INTEGRAL_TK;\n+\t\tcase CHAR_TK:\n+\t\t  SET_LVAL_NODE (char_type_node);\n+\t\t  return INTEGRAL_TK;\n+\n+\t\t  /* Keyword based literals.  */\n+\t\tcase TRUE_TK:\n+\t\tcase FALSE_TK:\n+\t\t  SET_LVAL_NODE ((kw->token == TRUE_TK ? \n+\t\t\t\t  boolean_true_node : boolean_false_node));\n+\t\t  return BOOL_LIT_TK;\n+\t\tcase NULL_TK:\n+\t\t  SET_LVAL_NODE (null_pointer_node);\n+\t\t  return NULL_TK;\n+\n+\t\tcase ASSERT_TK:\n+\t\t  if (flag_assert)\n+\t\t    {\n+\t\t      BUILD_OPERATOR (kw->token);\n+\t\t      return kw->token;\n+\t\t    }\n+\t\t  else\n+\t\t    break;\n+\n+\t\t  /* Some keyword we want to retain information on the location\n+\t\t     they where found.  */\n+\t\tcase CASE_TK:\n+\t\tcase DEFAULT_TK:\n+\t\tcase SUPER_TK:\n+\t\tcase THIS_TK:\n+\t\tcase RETURN_TK:\n+\t\tcase BREAK_TK:\n+\t\tcase CONTINUE_TK:\n+\t\tcase TRY_TK:\n+\t\tcase CATCH_TK:\n+\t\tcase THROW_TK:\n+\t\tcase INSTANCEOF_TK:\n+\t\t  BUILD_OPERATOR (kw->token);\n+\n+\t\tdefault:\n+\t\t  return kw->token;\n+\t\t}\n+\t    }\n+\t}\n+\n+      java_lval->node = BUILD_ID_WFL (GET_IDENTIFIER (string));\n+      return ID_TK;\n+    }\n+\n+  java_next_unicode ();\n+\n   /* Character literals.  */\n   if (c == '\\'')\n     {\n@@ -1339,20 +1365,27 @@ do_java_lex (YYSTYPE *java_lval)\n       if (char_lit == JAVA_CHAR_ERROR)\n         char_lit = 0;\t\t/* We silently convert it to zero.  */\n \n-      JAVA_LEX_CHAR_LIT (char_lit);\n       SET_LVAL_NODE (build_int_cst (char_type_node, char_lit));\n       return CHAR_LIT_TK;\n     }\n \n   /* String literals.  */\n   if (c == '\"')\n     {\n-      int no_error;\n+      int no_error = 1;\n       char *string;\n \n-      for (no_error = 1, c = java_get_unicode (); \n-\t   c != UEOF && c != '\"' && c != '\\n'; c = java_get_unicode ())\n+      for (;;)\n \t{\n+\t  c = java_peek_unicode ();\n+\t  if (c == '\\n' || c == UEOF) /* ULT.  */\n+\t    {\n+\t      java_lex_error (\"String not terminated at end of line\", 0);\n+\t      break;\n+\t    }\n+\t  java_next_unicode ();\n+\t  if (c == '\"')\n+\t    break;\n \t  if (c == '\\\\')\n \t    c = java_parse_escape_sequence ();\n \t  if (c == JAVA_CHAR_ERROR)\n@@ -1362,12 +1395,6 @@ do_java_lex (YYSTYPE *java_lval)\n \t    }\n \t  java_unicode_2_utf8 (c);\n \t}\n-      if (c == '\\n' || c == UEOF) /* ULT.  */\n-\t{\n-\t  input_line--;\t/* Refer to the line where the terminator was seen.  */\n-\t  java_lex_error (\"String not terminated at end of line\", 0);\n-\t  input_line++;\n-\t}\n \n       obstack_1grow (&temporary_obstack, '\\0');\n       string = obstack_finish (&temporary_obstack);\n@@ -1382,51 +1409,108 @@ do_java_lex (YYSTYPE *java_lval)\n       return STRING_LIT_TK;\n     }\n \n-  /* Separator.  */\n   switch (c)\n     {\n+    case '/':\n+      /* Check for comment.  */\n+      switch (c = java_peek_unicode ())\n+\t{\n+\tcase '/':\n+\t  java_next_unicode ();\n+\t  for (;;)\n+\t    {\n+\t      c = java_get_unicode ();\n+\t      if (c == UEOF)\n+\t\t{\n+\t\t  /* It is ok to end a `//' comment with EOF, unless\n+\t\t     we're being pedantic.  */\n+\t\t  if (pedantic)\n+\t\t    java_lex_error (\"Comment not terminated at end of input\",\n+\t\t\t\t    0);\n+\t\t  return 0;\n+\t\t}\n+\t      if (c == '\\n')\t/* ULT */\n+\t\tgoto step1;\n+\t    }\n+\t  break;\n+\n+\tcase '*':\n+\t  java_next_unicode ();\n+\t  if ((c = java_get_unicode ()) == '*')\n+\t    {\n+\t      c = java_get_unicode ();\n+\t      if (c == '/')\n+\t\t{\n+\t\t  /* Empty documentation comment.  We have to reset\n+\t\t     the deprecation marker as only the most recent\n+\t\t     doc comment applies.  */\n+\t\t  ctxp->deprecated = 0;\n+\t\t}\n+\t      else\n+\t\tjava_parse_doc_section (c);\n+\t    }\n+\t  else\n+\t    java_parse_end_comment ((c = java_get_unicode ()));\n+\t  goto step1;\n+\t  break;\n+\n+\tcase '=':\n+\t  java_next_unicode ();\n+\t  BUILD_OPERATOR2 (DIV_ASSIGN_TK);\n+\n+\tdefault:\n+\t  BUILD_OPERATOR (DIV_TK);\n+\t}\n+\n     case '(':\n-      JAVA_LEX_SEP (c);\n       BUILD_OPERATOR (OP_TK);\n     case ')':\n-      JAVA_LEX_SEP (c);\n       return CP_TK;\n     case '{':\n-      JAVA_LEX_SEP (c);\n+#ifndef JC1_LITE\n+      java_lval->operator.token = OCB_TK;\n+      java_lval->operator.location = BUILD_LOCATION();\n+#endif\n+#ifdef USE_MAPPED_LOCATION\n+      if (ctxp->ccb_indent == 1)\n+\tctxp->first_ccb_indent1 = input_location;\n+#else\n       if (ctxp->ccb_indent == 1)\n \tctxp->first_ccb_indent1 = input_line;\n+#endif\n       ctxp->ccb_indent++;\n-      BUILD_OPERATOR (OCB_TK);\n+      return OCB_TK;\n     case '}':\n-      JAVA_LEX_SEP (c);\n+#ifndef JC1_LITE\n+      java_lval->operator.token = CCB_TK;\n+      java_lval->operator.location = BUILD_LOCATION();\n+#endif\n       ctxp->ccb_indent--;\n+#ifdef USE_MAPPED_LOCATION\n+      if (ctxp->ccb_indent == 1)\n+        ctxp->last_ccb_indent1 = input_location;\n+#else\n       if (ctxp->ccb_indent == 1)\n         ctxp->last_ccb_indent1 = input_line;\n-      BUILD_OPERATOR (CCB_TK);\n+#endif\n+      return CCB_TK;\n     case '[':\n-      JAVA_LEX_SEP (c);\n       BUILD_OPERATOR (OSB_TK);\n     case ']':\n-      JAVA_LEX_SEP (c);\n       return CSB_TK;\n     case ';':\n-      JAVA_LEX_SEP (c);\n       return SC_TK;\n     case ',':\n-      JAVA_LEX_SEP (c);\n       return C_TK;\n     case '.':\n-      JAVA_LEX_SEP (c);\n       BUILD_OPERATOR (DOT_TK);\n-      /*      return DOT_TK; */\n-    }\n \n-  /* Operators.  */\n-  switch (c)\n-    {\n+      /* Operators.  */\n     case '=':\n-      if ((c = java_get_unicode ()) == '=')\n+      c = java_peek_unicode ();\n+      if (c == '=')\n \t{\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR (EQ_TK);\n \t}\n       else\n@@ -1435,283 +1519,178 @@ do_java_lex (YYSTYPE *java_lval)\n \t     variable_declarator: rule, it has to be seen as '=' as opposed\n \t     to being seen as an ordinary assignment operator in\n \t     assignment_operators: rule.  */\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (ASSIGN_TK);\n \t}\n       \n     case '>':\n-      switch ((c = java_get_unicode ()))\n+      switch ((c = java_peek_unicode ()))\n \t{\n \tcase '=':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR (GTE_TK);\n \tcase '>':\n-\t  switch ((c = java_get_unicode ()))\n+\t  java_next_unicode ();\n+\t  switch ((c = java_peek_unicode ()))\n \t    {\n \t    case '>':\n-\t      if ((c = java_get_unicode ()) == '=')\n+\t      java_next_unicode ();\n+\t      c = java_peek_unicode ();\n+\t      if (c == '=')\n \t\t{\n+\t\t  java_next_unicode ();\n \t\t  BUILD_OPERATOR2 (ZRS_ASSIGN_TK);\n \t\t}\n \t      else\n \t\t{\n-\t\t  java_unget_unicode ();\n \t\t  BUILD_OPERATOR (ZRS_TK);\n \t\t}\n \t    case '=':\n+\t      java_next_unicode ();\n \t      BUILD_OPERATOR2 (SRS_ASSIGN_TK);\n \t    default:\n-\t      java_unget_unicode ();\n \t      BUILD_OPERATOR (SRS_TK);\n \t    }\n \tdefault:\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (GT_TK);\n \t}\n \t\n     case '<':\n-      switch ((c = java_get_unicode ()))\n+      switch ((c = java_peek_unicode ()))\n \t{\n \tcase '=':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR (LTE_TK);\n \tcase '<':\n-\t  if ((c = java_get_unicode ()) == '=')\n+\t  java_next_unicode ();\n+\t  if ((c = java_peek_unicode ()) == '=')\n \t    {\n+\t      java_next_unicode ();\n \t      BUILD_OPERATOR2 (LS_ASSIGN_TK);\n \t    }\n \t  else\n \t    {\n-\t      java_unget_unicode ();\n \t      BUILD_OPERATOR (LS_TK);\n \t    }\n \tdefault:\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (LT_TK);\n \t}\n \n     case '&':\n-      switch ((c = java_get_unicode ()))\n+      switch ((c = java_peek_unicode ()))\n \t{\n \tcase '&':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR (BOOL_AND_TK);\n \tcase '=':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR2 (AND_ASSIGN_TK);\n \tdefault:\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (AND_TK);\n \t}\n \n     case '|':\n-      switch ((c = java_get_unicode ()))\n+      switch ((c = java_peek_unicode ()))\n \t{\n \tcase '|':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR (BOOL_OR_TK);\n \tcase '=':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR2 (OR_ASSIGN_TK);\n \tdefault:\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (OR_TK);\n \t}\n \n     case '+':\n-      switch ((c = java_get_unicode ()))\n+      switch ((c = java_peek_unicode ()))\n \t{\n \tcase '+':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR (INCR_TK);\n \tcase '=':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR2 (PLUS_ASSIGN_TK);\n \tdefault:\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (PLUS_TK);\n \t}\n \n     case '-':\n-      switch ((c = java_get_unicode ()))\n+      switch ((c = java_peek_unicode ()))\n \t{\n \tcase '-':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR (DECR_TK);\n \tcase '=':\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR2 (MINUS_ASSIGN_TK);\n \tdefault:\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (MINUS_TK);\n \t}\n \n     case '*':\n-      if ((c = java_get_unicode ()) == '=')\n+      if ((c = java_peek_unicode ()) == '=')\n \t{\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR2 (MULT_ASSIGN_TK);\n \t}\n       else\n \t{\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (MULT_TK);\n \t}\n \n-    case '/':\n-      if ((c = java_get_unicode ()) == '=')\n-\t{\n-\t  BUILD_OPERATOR2 (DIV_ASSIGN_TK);\n-\t}\n-      else\n-\t{\n-\t  java_unget_unicode ();\n-\t  BUILD_OPERATOR (DIV_TK);\n-\t}\n-\n     case '^':\n-      if ((c = java_get_unicode ()) == '=')\n+      if ((c = java_peek_unicode ()) == '=')\n \t{\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR2 (XOR_ASSIGN_TK);\n \t}\n       else\n \t{\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (XOR_TK);\n \t}\n \n     case '%':\n-      if ((c = java_get_unicode ()) == '=')\n+      if ((c = java_peek_unicode ()) == '=')\n \t{\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR2 (REM_ASSIGN_TK);\n \t}\n       else\n \t{\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (REM_TK);\n \t}\n \n     case '!':\n-      if ((c = java_get_unicode()) == '=')\n+      if ((c = java_peek_unicode()) == '=')\n \t{\n+\t  java_next_unicode ();\n \t  BUILD_OPERATOR (NEQ_TK);\n \t}\n       else\n \t{\n-\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (NEG_TK);\n \t}\n \t  \n     case '?':\n-      JAVA_LEX_OP (\"?\");\n       BUILD_OPERATOR (REL_QM_TK);\n     case ':':\n-      JAVA_LEX_OP (\":\");\n       BUILD_OPERATOR (REL_CL_TK);\n     case '~':\n       BUILD_OPERATOR (NOT_TK);\n     }\n   \n-  /* Keyword, boolean literal or null literal.  */\n-  for (first_unicode = c, all_ascii = 1, ascii_index = 0; \n-       c != UEOF && JAVA_PART_CHAR_P (c); c = java_get_unicode ())\n-    {\n-      java_unicode_2_utf8 (c);\n-      if (all_ascii && c >= 128)\n-        all_ascii = 0;\n-      ascii_index++;\n-    }\n-\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  string = obstack_finish (&temporary_obstack);\n-  if (c != UEOF)\n-    java_unget_unicode ();\n-\n-  /* If we have something all ascii, we consider a keyword, a boolean\n-     literal, a null literal or an all ASCII identifier.  Otherwise,\n-     this is an identifier (possibly not respecting formation rule).  */\n-  if (all_ascii)\n-    {\n-      const struct java_keyword *kw;\n-      if ((kw=java_keyword (string, ascii_index)))\n-\t{\n-\t  JAVA_LEX_KW (string);\n-\t  switch (kw->token)\n-\t    {\n-\t    case PUBLIC_TK:       case PROTECTED_TK: case STATIC_TK:\n-\t    case ABSTRACT_TK:     case FINAL_TK:     case NATIVE_TK:\n-\t    case SYNCHRONIZED_TK: case TRANSIENT_TK: case VOLATILE_TK:\n-\t    case PRIVATE_TK:      case STRICT_TK:\n-\t      SET_MODIFIER_CTX (kw->token);\n-\t      return MODIFIER_TK;\n-\t    case FLOAT_TK:\n-\t      SET_LVAL_NODE (float_type_node);\n-\t      return FP_TK;\n-\t    case DOUBLE_TK:\n-\t      SET_LVAL_NODE (double_type_node);\n-\t      return FP_TK;\n-\t    case BOOLEAN_TK:\n-\t      SET_LVAL_NODE (boolean_type_node);\n-\t      return BOOLEAN_TK;\n-\t    case BYTE_TK:\n-\t      SET_LVAL_NODE (byte_type_node);\n-\t      return INTEGRAL_TK;\n-\t    case SHORT_TK:\n-\t      SET_LVAL_NODE (short_type_node);\n-\t      return INTEGRAL_TK;\n-\t    case INT_TK:\n-\t      SET_LVAL_NODE (int_type_node);\n-\t      return INTEGRAL_TK;\n-\t    case LONG_TK:\n-\t      SET_LVAL_NODE (long_type_node);\n-\t      return INTEGRAL_TK;\n-\t    case CHAR_TK:\n-\t      SET_LVAL_NODE (char_type_node);\n-\t      return INTEGRAL_TK;\n-\n-\t      /* Keyword based literals.  */\n-\t    case TRUE_TK:\n-\t    case FALSE_TK:\n-\t      SET_LVAL_NODE ((kw->token == TRUE_TK ? \n-\t\t\t      boolean_true_node : boolean_false_node));\n-\t      return BOOL_LIT_TK;\n-\t    case NULL_TK:\n-\t      SET_LVAL_NODE (null_pointer_node);\n-\t      return NULL_TK;\n-\n-\t    case ASSERT_TK:\n-\t      if (flag_assert)\n-\t\t{\n-\t\t  BUILD_OPERATOR (kw->token);\n-\t\t  return kw->token;\n-\t\t}\n-\t      else\n-\t\tbreak;\n-\n-\t      /* Some keyword we want to retain information on the location\n-\t\t they where found.  */\n-\t    case CASE_TK:\n-\t    case DEFAULT_TK:\n-\t    case SUPER_TK:\n-\t    case THIS_TK:\n-\t    case RETURN_TK:\n-\t    case BREAK_TK:\n-\t    case CONTINUE_TK:\n-\t    case TRY_TK:\n-\t    case CATCH_TK:\n-\t    case THROW_TK:\n-\t    case INSTANCEOF_TK:\n-\t      BUILD_OPERATOR (kw->token);\n-\n-\t    default:\n-\t      return kw->token;\n-\t    }\n-\t}\n-    }\n-  \n-  /* We may have an ID here.  */\n-  if (JAVA_START_CHAR_P (first_unicode))\n+  if (c == 0x1a)\t\t/* CTRL-Z.  */\n     {\n-      JAVA_LEX_ID (string);\n-      java_lval->node = BUILD_ID_WFL (GET_IDENTIFIER (string));\n-      return ID_TK;\n+      if ((c = java_peek_unicode ()) == UEOF)\n+\treturn 0;\t\t/* Ok here.  */\n     }\n \n   /* Everything else is an invalid character in the input.  */\n   {\n     char lex_error_buffer [128];\n-    sprintf (lex_error_buffer, \"Invalid character `%s' in input\", \n-\t     java_sprint_unicode (ctxp->c_line, ctxp->c_line->current));\n-    java_lex_error (lex_error_buffer, 1);\n+    sprintf (lex_error_buffer, \"Invalid character '%s' in input\", \n+\t     java_sprint_unicode (c));\n+    java_lex_error (lex_error_buffer, -1);\n   }\n   return 0;\n }\n@@ -1742,9 +1721,9 @@ error_if_numeric_overflow (tree value)\n       && tree_int_cst_sgn (value) < 0)\n     {\n       if (TREE_TYPE (value) == long_type_node)\n-\tjava_lex_error (\"Numeric overflow for `long' literal\", 0);\n+\tjava_lex_error (\"Numeric overflow for 'long' literal\", 0);\n       else\n-\tjava_lex_error (\"Numeric overflow for `int' literal\", 0);\n+\tjava_lex_error (\"Numeric overflow for 'int' literal\", 0);\n     }\n }\n \n@@ -1777,7 +1756,13 @@ java_unicode_2_utf8 (unicode_t unicode)\n static tree\n build_wfl_node (tree node)\n {\n-  node = build_expr_wfl (node, ctxp->filename, ctxp->elc.line, ctxp->elc.col);\n+#ifdef USE_MAPPED_LOCATION\n+  node = build_expr_wfl (node, input_location);\n+#else\n+  node = build_expr_wfl (node, ctxp->filename,\n+\t\t\t ctxp->lexer->token_start.line,\n+\t\t\t ctxp->lexer->token_start.col);\n+#endif\n   /* Prevent java_complete_lhs from short-circuiting node (if constant).  */\n   TREE_TYPE (node) = NULL_TREE;\n   return node;\n@@ -1788,13 +1773,28 @@ static void\n java_lex_error (const char *msg ATTRIBUTE_UNUSED, int forward ATTRIBUTE_UNUSED)\n {\n #ifndef JC1_LITE\n-  ctxp->elc.line = ctxp->c_line->lineno;\n-  ctxp->elc.col = ctxp->c_line->char_col-1+forward;\n+  int col = (ctxp->lexer->position.col\n+\t     + forward * ctxp->lexer->next_columns);\n+#if USE_MAPPED_LOCATION\n+  source_location save_location = input_location;\n+  LINEMAP_POSITION_FOR_COLUMN (input_location, &line_table, col);\n+  \n+  /* Might be caught in the middle of some error report.  */\n+  ctxp->java_error_flag = 0;\n+  java_error (NULL);\n+  java_error (msg);\n+  input_location = save_location;\n+#else\n+  java_lc save = ctxp->lexer->token_start;\n+  ctxp->lexer->token_start.line = ctxp->lexer->position.line;\n+  ctxp->lexer->token_start.col = col;\n \n   /* Might be caught in the middle of some error report.  */\n   ctxp->java_error_flag = 0;\n   java_error (NULL);\n   java_error (msg);\n+  ctxp->lexer->token_start = save;\n+#endif\n #endif\n }\n \n@@ -1880,11 +1880,11 @@ java_get_line_col (const char *filename ATTRIBUTE_UNUSED,\n \n   /* Place the '^' a the right position.  */\n   base = obstack_base (&temporary_obstack);\n-  for (ccol = 1; ccol <= col+3; ccol++)\n+  for (col += 2, ccol = 0; ccol < col; ccol++)\n     {\n       /* Compute \\t when reaching first_non_space.  */\n       char c = (first_non_space ?\n-\t\t(base [ccol-1] == '\\t' ? '\\t' : ' ') : ' ');\n+\t\t(base [ccol] == '\\t' ? '\\t' : ' ') : ' ');\n       obstack_1grow (&temporary_obstack, c);\n     }\n   obstack_grow0 (&temporary_obstack, \"^\", 1);"}, {"sha": "c9d5ac6d8502ace6d9fd0417f552be29ceac3f40", "filename": "gcc/java/lex.h", "status": "modified", "additions": 43, "deletions": 78, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "patch": "@@ -42,65 +42,9 @@ typedef unsigned short unicode_t;\n /* Default encoding to use if no encoding is specified.  */\n #define DEFAULT_ENCODING \"UTF-8\"\n \n-/* Debug macro to print-out what we match  */\n-#ifdef JAVA_LEX_DEBUG\n-#ifdef JAVA_LEX_DEBUG_CHAR\n-#define JAVA_LEX_CHAR(c)      printf (\"java_lex:%d: char '%c'.%d\\n\", \t\\\n-\t\t\t\t      lineno, (c < 128 ? c : '.'), c);\n-#else\n-#define JAVA_LEX_CHAR(c)\n-#endif\n-#define JAVA_LEX_KW(c)        printf (\"java_lex:%d: keyword: '%s'\\n\", lineno,c)\n-#define JAVA_LEX_ID(s)        printf (\"java_lex:%d: ID: '%s'\\n\",\t\\\n-\t\t\t\t      lineno,\t\t\t\t\\\n-\t\t\t\t      (all_ascii ? s : \"<U>\"))\n-#define JAVA_LEX_LIT(s, r)    printf (\"java_lex:%d: literal '%s'_%d\\n\",\t\\\n-\t\t\t\t      lineno, s, r)\n-#define JAVA_LEX_CHAR_LIT(s)  printf (\"java_lex:%d: literal '%d'\\n\", lineno, s)\n-#define JAVA_LEX_STR_LIT(s)   {\t\t\t\t\t\t \\\n-\t\t\t\t int i;\t\t\t\t\t \\\n-\t\t\t\t printf (\"java_lex:%d: literal '%s'\\n\",  \\\n-\t\t\t\t\t lineno, s);\t\t\t \\\n-\t\t\t       }\n-#define JAVA_LEX_SEP(c)       printf (\"java_lex:%d: separator '%c'\\n\",lineno,c)\n-#define JAVA_LEX_OP(c)        printf (\"java_lex:%d: operator '%s'\\n\", lineno,c)\n-#else\n-#define JAVA_LEX_CHAR(c)\n-#define JAVA_LEX_KW(c)\n-#define JAVA_LEX_ID(s)\n-#define JAVA_LEX_LIT(s,r)\n-#define JAVA_LEX_CHAR_LIT(s)\n-#define JAVA_LEX_STR_LIT(s)\n-#define JAVA_LEX_SEP(c)\n-#define JAVA_LEX_OP(s)\n-#endif\n-\n-/* Line information containers  */\n-struct java_line {\n-  unicode_t *line;\t\t/* The line's unicode */\n-  char      *unicode_escape_p;\t/* The matching char was a unicode escape */\n-  unicode_t ahead[1];\t\t/* Character ahead */\n-  char unicode_escape_ahead_p;\t/* Character ahead is a unicode escape */\n-  int max;\t\t\t/* buffer's max size */\n-  int size;\t\t\t/* number of unicodes */\n-  int current;\t\t\t/* Current position, unicode based */\n-  int char_col;\t\t\t/* Current position, input char based */\n-  int lineno;\t\t\t/* Its line number */\n-  int white_space_only;\t\t/* If it contains only white spaces */\n-};\n-#define JAVA_COLUMN_DELTA(p)\t\t\t\t\t\t\\\n-  (ctxp->c_line->unicode_escape_p [ctxp->c_line->current+(p)] ? 6 : \t\\\n-   (ctxp->c_line->line [ctxp->c_line->current+(p)] == '\\t' ? 8 : 1))\n-\n-struct java_error {\n-  struct java_line *line;\n-  int error;\n-};\n-\n typedef struct java_lc_s GTY(()) {\n-  int line;\n-  int prev_col;\n-  int col;\n+  int line;\t\t/* line number (1-based) */\n+  int col;\t\t/* column number number (1-based) */\n } java_lc;\n \n struct java_lexer\n@@ -111,15 +55,33 @@ struct java_lexer\n   /* Number of consecutive backslashes we've read.  */\n   int bs_count;\n \n-  /* If nonzero, a value that was pushed back.  */\n+  /* Next available Unicode character.\n+   * This is post-Unicode-escape-processing. -1 if EOF. */\n+  int next_unicode;\n+\n+  /* True if next_unicode is next available character, or EOF. */\n+  bool avail_unicode;\n+\n+  /* Number of source columns of the previous Unicode character (next_unicode).\n+     If next_unicode==-2, then this is the number of columns of the previous\n+     Unicode character (most recent result of java_{get,peek}_unicode). */\n+  int next_columns;\n+\n+  /* If nonzero, a value that was pushed back.  This is a unicode character,\n+     but (unlike next_unicode) is pre-'\\uXXXX'-processing.  It is also used\n+     when a '\\r' is *not* followed by a '\\n'. */\n   unicode_t unget_value;\n \n-  /* If nonzero, we've hit EOF.  Used only by java_get_unicode().  */\n-  unsigned int hit_eof : 1;\n-  \n   /* Name of the character encoding we're using.  */\n   const char *encoding;\n \n+  /* Current source position. */\n+  java_lc position;\n+\n+#ifndef USE_MAPPED_LOCATION\n+  java_lc token_start;\t\t     /* Error's line column info */\n+#endif\n+\n #ifdef HAVE_ICONV\n   /* Nonzero if we've read any bytes.  We only recognize the\n      byte-order-marker (BOM) as the first word.  */\n@@ -168,7 +130,12 @@ extern void java_destroy_lexer (java_lexer *);\n #define JAVA_LINE_MAX 80\n \n /* Build a location compound integer */\n-#define BUILD_LOCATION() ((ctxp->elc.line << 12) | (ctxp->elc.col & 0xfff))\n+#ifdef USE_MAPPED_LOCATION\n+#define BUILD_LOCATION() input_location\n+#else\n+#define BUILD_LOCATION() ((ctxp->lexer->token_start.line << 12) \\\n+\t\t\t  | (ctxp->lexer->token_start.col & 0xfff))\n+#endif\n \n /* Those macros are defined differently if we compile jc1-lite\n    (JC1_LITE defined) or jc1.  */\n@@ -190,7 +157,7 @@ extern void java_destroy_lexer (java_lexer *);\n #define SET_LVAL_NODE(NODE)\n #define BUILD_ID_WFL(EXP) (EXP)\n #define JAVA_FLOAT_RANGE_ERROR(S) {}\n-#define JAVA_INTEGRAL_RANGE_ERROR(S) do { } while (0)\n+#define JAVA_RANGE_ERROR(S) do { } while (0)\n \n #else\n \n@@ -227,21 +194,19 @@ extern void java_destroy_lexer (java_lexer *);\n /* Wrap identifier around a wfl */\n #define BUILD_ID_WFL(EXP) build_wfl_node ((EXP))\n /* Special ways to report error on numeric literals  */\n-#define JAVA_FLOAT_RANGE_ERROR(m)\t\t\t\t\t  \\\n-  {\t\t\t\t\t\t\t\t\t  \\\n-    char msg [1024];\t\t\t\t\t\t\t  \\\n-    int i = ctxp->c_line->current;\t\t\t\t\t  \\\n-    ctxp->c_line->current = number_beginning;\t\t\t\t  \\\n-    sprintf (msg, \"Floating point literal exceeds range of `%s'\", (m)); \\\n-    java_lex_error (msg, 0);\t\t\t\t\t\t  \\\n-    ctxp->c_line->current = i;\t\t\t\t\t\t  \\\n+#define JAVA_FLOAT_RANGE_ERROR(m)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    char *msg = xmalloc (100 + strlen (m));\t\t\t\t\\\n+    sprintf (msg, \"Floating point literal exceeds range of `%s'\", (m));\t\\\n+    JAVA_RANGE_ERROR(msg);\t\t\t\t\t\t\\\n+    free (msg);\t\t\t\t\t\t\t\t\\\n   }\n-#define JAVA_INTEGRAL_RANGE_ERROR(m)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    int i = ctxp->c_line->current;\t\t\\\n-    ctxp->c_line->current = number_beginning;\t\\\n-    java_lex_error (m, 0);\t\t\t\\\n-    ctxp->c_line->current = i;\t\t\t\\\n+#define JAVA_RANGE_ERROR(msg)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    int save_col = ctxp->lexer->position.col;\t\t\t\t\\\n+    ctxp->lexer->position.col = number_beginning;\t\t\t\\\n+    java_lex_error (msg, 0);\t\t\t\t\t\t\\\n+    ctxp->lexer->position.col = save_col;\t\t\t\t\\\n   } while (0)\n \n #endif /* Definitions for jc1 compilation only */"}, {"sha": "b83d22e237546b5b0b6a9a539bc371e3cbedb3b1", "filename": "gcc/java/parse.h", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "patch": "@@ -89,6 +89,23 @@ extern tree stabilize_reference (tree);\n #define MODIFIER_WFL(M)   (ctxp->modifier_ctx [(M) - PUBLIC_TK])\n \n /* Check on modifiers */\n+#ifdef USE_MAPPED_LOCATION\n+#define THIS_MODIFIER_ONLY(f, m, v, count, l)\t\t\t\t\\\n+  if ((f) & (m))\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      tree node = MODIFIER_WFL (v);\t\t\t\t\t\\\n+      if (!l)\t\t\t\t\t\t\t\t\\\n+        l = node;\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  expanded_location lloc = expand_location (EXPR_LOCATION (l));\t\\\n+\t  expanded_location nloc = expand_location (EXPR_LOCATION (node)); \\\n+\t  if (nloc.column > lloc.column || nloc.line > lloc.line)\t\\\n+\t    l = node;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      count++;\t\t\t\t\t\t\t\t\\\n+    }\n+#else\n #define THIS_MODIFIER_ONLY(f, m, v, count, l)\t\t\t\t\\\n   if ((f) & (m))\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -101,6 +118,7 @@ extern tree stabilize_reference (tree);\n         l = node;\t\t\t\t\t\t\t\\\n       count++;\t\t\t\t\t\t\t\t\\\n     }\n+#endif\n \n #define ABSTRACT_CHECK(FLAG, V, CL, S)\t\t\t\t\\\n   if ((FLAG) & (V))\t\t\t\t\t\t\\\n@@ -163,11 +181,13 @@ extern tree stabilize_reference (tree);\n    && !TREE_TYPE (NODE) \t\t\t\t\\\n    && TREE_CODE (TYPE_NAME (NODE)) == IDENTIFIER_NODE)\n \n+#ifndef USE_MAPPED_LOCATION\n /* Set the EMIT_LINE_NOTE flag of a EXPR_WLF to 1 if debug information\n    are requested. Works in the context of a parser rule. */\n #define JAVA_MAYBE_GENERATE_DEBUG_INFO(node)\t\t\\\n-  (debug_info_level != DINFO_LEVEL_NONE ? \t\t\\\n-    EXPR_WFL_EMIT_LINE_NOTE (node) = 1, node : node)\n+  do {if (debug_info_level != DINFO_LEVEL_NONE)\t\\\n+      EXPR_WFL_EMIT_LINE_NOTE (node) = 1; } while (0)\n+#endif\n \n /* Types classification, according to the JLS, section 4.2 */\n #define JFLOAT_TYPE_P(TYPE)      (TYPE && TREE_CODE ((TYPE)) == REAL_TYPE)\n@@ -610,20 +630,14 @@ typedef struct jdeplist_s jdeplist;\n #define GET_CURRENT_BLOCK(F) ((F) ? DECL_FUNCTION_BODY ((F)) :\t\\\n \t\t\t     current_static_block)\n \n+#ifndef USE_MAPPED_LOCATION\n /* Retrieve line/column from a WFL. */\n #define EXPR_WFL_GET_LINECOL(V,LINE,COL)\t\\\n   {\t\t\t\t\t\t\\\n      (LINE) = (V) >> 12;\t\t\t\\\n      (COL) = (V) & 0xfff;\t\t\t\\\n    }\n-/* Add X to the column number information */\n-#define EXPR_WFL_ADD_COL(V, X)\t\t\t\t\t\\\n-  (V) = (((V) & 0xfffff000) | ((((V) & 0xfff) + (X)) & 0xfff))\n-\n-/* Build a WFL for expression nodes */\n-#define BUILD_EXPR_WFL(NODE, WFL)\t\t\t\t\t\\\n-  build_expr_wfl ((NODE), input_filename, EXPR_WFL_LINENO ((WFL)), \t\\\n-\t\t  EXPR_WFL_COLNO ((WFL)))\n+#endif\n \n #define EXPR_WFL_QUALIFICATION(WFL) TREE_OPERAND ((WFL), 1)\n #define QUAL_WFL(NODE) TREE_PURPOSE (NODE)\n@@ -671,10 +685,17 @@ typedef struct jdeplist_s jdeplist;\n   }\n \n /* Set wfl_operator for the most accurate error location */\n+#ifdef USE_MAPPED_LOCATION\n+#define SET_WFL_OPERATOR(WHICH, NODE, WFL)\t\t\\\n+  SET_EXPR_LOCATION (WHICH,\t\t\t\t\\\n+    (TREE_CODE (WFL) == EXPR_WITH_FILE_LOCATION ?\t\\\n+     EXPR_LOCATION (WFL) : EXPR_LOCATION (NODE)))\n+#else\n #define SET_WFL_OPERATOR(WHICH, NODE, WFL)\t\t\\\n   EXPR_WFL_LINECOL (WHICH) =\t\t\t\t\\\n     (TREE_CODE (WFL) == EXPR_WITH_FILE_LOCATION ?\t\\\n      EXPR_WFL_LINECOL (WFL) : EXPR_WFL_LINECOL (NODE))\n+#endif\n \n #define PATCH_METHOD_RETURN_ERROR()\t\t\\\n   {\t\t\t\t\t\t\\\n@@ -724,23 +745,23 @@ typedef struct jdeplist_s jdeplist;\n      \n /* Parser context data structure. */\n struct parser_ctxt GTY(()) {\n-\n-  const char *filename;\t\t    /* Current filename */\n+  const char *filename;\t\t     /* Current filename */\n+  location_t file_start_location;\n+  location_t save_location;\n   struct parser_ctxt *next;\n \n   java_lexer * GTY((skip)) lexer; /* Current lexer state */\n   char marker_begining;\t\t     /* Marker. Should be a sub-struct */\n-  struct java_line * GTY ((skip)) p_line; /* Previous line */\n-  struct java_line * GTY ((skip)) c_line; /* Current line */\n-  java_lc elc;\t\t\t     /* Error's line column info */\n-  int ccb_indent;\t\t     /* Keep track of {} indent, lexer */\n-  int first_ccb_indent1;\t     /* First { at ident level 1 */\n-  int last_ccb_indent1;\t\t     /* Last } at ident level 1 */\n+  int ccb_indent;\t\t     /* Number of unmatched { seen. */\n+  /* The next two fields are only source_location if USE_MAPPED_LOCATION.\n+     Otherwise, they are integer line number, but we can't have #ifdefs\n+     in GTY structures. */\n+  source_location first_ccb_indent1; /* First { at ident level 1 */\n+  source_location last_ccb_indent1;  /* Last } at ident level 1 */\n   int parser_ccb_indent;\t     /* Keep track of {} indent, parser */\n   int osb_depth;\t\t     /* Current depth of [ in an expression */\n   int osb_limit;\t\t     /* Limit of this depth */\n   int * GTY ((skip)) osb_number; /* Keep track of ['s */\n-  int lineno;\t\t\t     /* Current lineno */\n   char marker_end;\t\t     /* End marker. Should be a sub-struct */\n \n   /* The flags section */\n@@ -763,8 +784,6 @@ struct parser_ctxt GTY(()) {\n   tree class_type;\t\t    /* Current class */\n   tree function_decl;\t            /* Current function decl, save/restore */\n \n-  struct JCF * current_jcf;\t    /* CU jcf */\n-\n   int prevent_ese;\t            /* Prevent expression statement error */\n \n   int formal_parameter_number;\t    /* Number of parameters found */"}, {"sha": "dc62f860da059ff48dc51f37e6a63945a5d5edf7", "filename": "gcc/java/parse.y", "status": "modified", "additions": 382, "deletions": 122, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec819d49ca815551b3fd8cd4e1202e898bac8d5/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=9ec819d49ca815551b3fd8cd4e1202e898bac8d5", "patch": "@@ -97,8 +97,13 @@ static void fix_method_argument_names (tree ,tree);\n static tree method_declarator (tree, tree);\n static void parse_warning_context (tree cl, const char *msg, ...)\n   ATTRIBUTE_PRINTF_2;\n+#ifdef USE_MAPPED_LOCATION\n+static void issue_warning_error_from_context\n+  (source_location, const char *msg, va_list) ATTRIBUTE_PRINTF (2, 0);\n+#else\n static void issue_warning_error_from_context (tree, const char *msg, va_list)\n   ATTRIBUTE_PRINTF (2, 0);\n+#endif\n static void parse_ctor_invocation_error (void);\n static tree parse_jdk1_1_error (const char *);\n static void complete_class_report_errors (jdep *);\n@@ -175,7 +180,11 @@ static int build_type_name_from_array_name (tree, tree *);\n static tree build_array_from_name (tree, tree, tree, tree *);\n static tree build_array_ref (int, tree, tree);\n static tree patch_array_ref (tree);\n+#ifdef USE_MAPPED_LOCATION\n+static tree make_qualified_name (tree, tree, source_location);\n+#else\n static tree make_qualified_name (tree, tree, int);\n+#endif\n static tree merge_qualified_name (tree, tree);\n static tree make_qualified_primary (tree, tree, int);\n static int resolve_qualified_expression_name (tree, tree *, tree *, tree *);\n@@ -214,13 +223,21 @@ static tree build_string_concatenation (tree, tree);\n static tree patch_string_cst (tree);\n static tree patch_string (tree);\n static tree encapsulate_with_try_catch (int, tree, tree, tree);\n+#ifdef USE_MAPPED_LOCATION\n+static tree build_assertion (source_location, tree, tree);\n+#else\n static tree build_assertion (int, tree, tree);\n+#endif\n static tree build_try_statement (int, tree, tree);\n static tree build_try_finally_statement (int, tree, tree);\n static tree patch_try_statement (tree);\n static tree patch_synchronized_statement (tree, tree);\n static tree patch_throw_statement (tree, tree);\n+#ifdef USE_MAPPED_LOCATION\n+static void check_thrown_exceptions (source_location, tree, tree);\n+#else\n static void check_thrown_exceptions (int, tree, tree);\n+#endif\n static int check_thrown_exceptions_do (tree);\n static void purge_unchecked_exceptions (tree);\n static bool ctors_unchecked_throws_clause_p (tree);\n@@ -443,12 +460,24 @@ static GTY(()) tree src_parse_roots[1];\n   int sub_token;\n   struct {\n     int token;\n+#ifdef USE_MAPPED_LOCATION\n+    source_location location;\n+#else\n     int location;\n+#endif\n   } operator;\n   int value;\n }\n \n %{\n+#ifdef USE_MAPPED_LOCATION\n+#define SET_EXPR_LOCATION_FROM_TOKEN(EXPR, TOKEN) \\\n+  SET_EXPR_LOCATION(EXPR, (TOKEN).location)\n+#else\n+#define SET_EXPR_LOCATION_FROM_TOKEN(EXPR, TOKEN) \\\n+  (EXPR_WFL_LINECOL (EXPR) = (TOKEN).location)\n+#endif\n+\n #include \"lex.c\"\n %}\n \n@@ -882,16 +911,14 @@ class_body:\n \t\t{\n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (flag_emit_xref)\n-\t\t    DECL_END_SOURCE_LINE (GET_CPC ()) =\n-\t\t      EXPR_WFL_ADD_COL ($2.location, 1);\n+\t\t    DECL_END_SOURCE_LINE (GET_CPC ()) = $2.location;\n \t\t  $$ = GET_CPC ();\n \t\t}\n |\tOCB_TK class_body_declarations CCB_TK\n \t\t{\n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (flag_emit_xref)\n-\t\t    DECL_END_SOURCE_LINE (GET_CPC ()) =\n-\t\t      EXPR_WFL_ADD_COL ($3.location, 1);\n+\t\t    DECL_END_SOURCE_LINE (GET_CPC ()) = $3.location;\n \t\t  $$ = GET_CPC ();\n \t\t}\n ;\n@@ -1055,7 +1082,7 @@ method_declarator:\n \t\t{ $$ = method_declarator ($1, $3); }\n |\tmethod_declarator OSB_TK CSB_TK\n \t\t{\n-\t\t  EXPR_WFL_LINECOL (wfl_operator) = $2.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN (wfl_operator, $2);\n \t\t  TREE_PURPOSE ($1) =\n \t\t    build_unresolved_array_type (TREE_PURPOSE ($1));\n \t\t  parse_warning_context\n@@ -1236,13 +1263,13 @@ this_or_super:\t\t\t/* Added, simplifies error diagnostics */\n \tTHIS_TK\n \t\t{\n \t\t  tree wfl = build_wfl_node (this_identifier_node);\n-\t\t  EXPR_WFL_LINECOL (wfl) = $1.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN (wfl, $1);\n \t\t  $$ = wfl;\n \t\t}\n |\tSUPER_TK\n \t\t{\n \t\t  tree wfl = build_wfl_node (super_identifier_node);\n-\t\t  EXPR_WFL_LINECOL (wfl) = $1.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN (wfl, $1);\n \t\t  $$ = wfl;\n \t\t}\n ;\n@@ -1369,8 +1396,7 @@ block_end:\n \t\t  maybe_absorb_scoping_blocks ();\n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (current_function_decl && flag_emit_xref)\n-\t\t    DECL_END_SOURCE_LINE (current_function_decl) =\n-\t\t      EXPR_WFL_ADD_COL ($1.location, 1);\n+\t\t    DECL_END_SOURCE_LINE (current_function_decl) = $1.location;\n \t\t  $$ = exit_block ();\n \t\t  if (!BLOCK_SUBBLOCKS ($$))\n \t\t    BLOCK_SUBBLOCKS ($$) = build_java_empty_stmt ();\n@@ -1449,7 +1475,11 @@ empty_statement:\n \t\t\t   (DECL_CONTEXT (current_function_decl)))))\n \n \t\t    {\n+#ifdef USE_MAPPED_LOCATION\n+\t\t      SET_EXPR_LOCATION (wfl_operator, input_location);\n+#else\n \t\t      EXPR_WFL_SET_LINECOL (wfl_operator, input_line, -1);\n+#endif\n \t\t      parse_warning_context (wfl_operator, \"An empty declaration is a deprecated feature that should not be used\");\n \t\t    }\n \t\t  $$ = build_java_empty_stmt ();\n@@ -1486,10 +1516,14 @@ expression_statement:\n \t\t{\n \t\t  /* We have a statement. Generate a WFL around it so\n \t\t     we can debug it */\n+#ifdef USE_MAPPED_LOCATION\n+\t\t  $$ = expr_add_location ($1, input_location, 1);\n+#else\n \t\t  $$ = build_expr_wfl ($1, input_filename, input_line, 0);\n+\t\t  JAVA_MAYBE_GENERATE_DEBUG_INFO ($$);\n+#endif\n \t\t  /* We know we have a statement, so set the debug\n                      info to be eventually generate here. */\n-\t\t  $$ = JAVA_MAYBE_GENERATE_DEBUG_INFO ($$);\n \t\t}\n |\terror SC_TK\n \t\t{\n@@ -1587,7 +1621,7 @@ switch_expression:\n \t\t{\n \t\t  $$ = build3 (SWITCH_EXPR, NULL_TREE, $3,\n \t\t\t       NULL_TREE, NULL_TREE);\n-\t\t  EXPR_WFL_LINECOL ($$) = $2.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN ($$, $2);\n \t\t}\n |\tSWITCH_TK error\n \t\t{yyerror (\"'(' expected\"); RECOVER;}\n@@ -1629,13 +1663,13 @@ switch_label:\n \tCASE_TK constant_expression REL_CL_TK\n \t\t{\n \t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, $2);\n-\t\t  EXPR_WFL_LINECOL (lab) = $1.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN (lab, $1);\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t}\n |\tDEFAULT_TK REL_CL_TK\n \t\t{\n \t\t  tree lab = make_node (DEFAULT_EXPR);\n-\t\t  EXPR_WFL_LINECOL (lab) = $1.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN (lab, $1);\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t}\n |\tCASE_TK error\n@@ -1814,7 +1848,7 @@ throw_statement:\n \tTHROW_TK expression SC_TK\n \t\t{\n \t\t  $$ = build1 (THROW_EXPR, NULL_TREE, $2);\n-\t\t  EXPR_WFL_LINECOL ($$) = $1.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN ($$, $1);\n \t\t}\n |\tTHROW_TK error\n \t\t{yyerror (\"Missing term\"); RECOVER;}\n@@ -1917,7 +1951,7 @@ catch_clause_parameter:\n                                                build_tree_list \n \t\t\t\t\t       (TREE_PURPOSE ($3), init));\n                       $$ = build1 (JAVA_CATCH_EXPR, NULL_TREE, ccpb);\n-                      EXPR_WFL_LINECOL ($$) = $1.location;\n+                      SET_EXPR_LOCATION_FROM_TOKEN ($$, $1);\n                     }\n                   else\n                     {\n@@ -2225,7 +2259,7 @@ field_access:\n |\tSUPER_TK DOT_TK identifier\n \t\t{\n \t\t  tree super_wfl = build_wfl_node (super_identifier_node);\n-\t\t  EXPR_WFL_LINECOL (super_wfl) = $1.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN (super_wfl, $1);\n \t\t  $$ = make_qualified_name (super_wfl, $3, $2.location);\n \t\t}\n |\tSUPER_TK error\n@@ -2609,7 +2643,7 @@ conditional_expression:\t\t/* Error handling here is weak */\n |\tconditional_or_expression REL_QM_TK expression REL_CL_TK conditional_expression\n \t\t{\n \t\t  $$ = build3 (CONDITIONAL_EXPR, NULL_TREE, $1, $3, $5);\n-\t\t  EXPR_WFL_LINECOL ($$) = $2.location;\n+\t\t  SET_EXPR_LOCATION_FROM_TOKEN ($$, $2);\n \t\t}\n |\tconditional_or_expression REL_QM_TK REL_CL_TK error\n \t\t{\n@@ -2718,16 +2752,15 @@ void\n java_pop_parser_context (int generate)\n {\n   tree current;\n-  struct parser_ctxt *toFree, *next;\n+  struct parser_ctxt *next;\n \n   if (!ctxp)\n     return;\n \n-  toFree = ctxp;\n   next = ctxp->next;\n   if (next)\n     {\n-      input_line = ctxp->lineno;\n+      input_location = ctxp->save_location;\n       current_class = ctxp->class_type;\n     }\n \n@@ -2740,19 +2773,19 @@ java_pop_parser_context (int generate)\n   for (current = ctxp->import_list; current; current = TREE_CHAIN (current))\n     IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (TREE_VALUE (current)) = 0;\n \n-  /* And restore those of the previous context */\n-  if ((ctxp = next))\t\t/* Assignment is really meant here */\n-    for (current = ctxp->import_list; current; current = TREE_CHAIN (current))\n-      IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (TREE_VALUE (current)) = 1;\n-\n   /* If we pushed a context to parse a class intended to be generated,\n      we keep it so we can remember the class. What we could actually\n      do is to just update a list of class names.  */\n   if (generate)\n     {\n-      toFree->next = ctxp_for_generation;\n-      ctxp_for_generation = toFree;\n+      ctxp->next = ctxp_for_generation;\n+      ctxp_for_generation = ctxp;\n     }\n+\n+  /* And restore those of the previous context */\n+  if ((ctxp = next))\t\t/* Assignment is really meant here */\n+    for (current = ctxp->import_list; current; current = TREE_CHAIN (current))\n+      IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (TREE_VALUE (current)) = 1;\n }\n \n /* Create a parser context for the use of saving some global\n@@ -2775,9 +2808,8 @@ java_parser_context_save_global (void)\n       ctxp->saved_data_ctx = 1;\n     }\n \n-  ctxp->lineno = input_line;\n+  ctxp->save_location = input_location;\n   ctxp->class_type = current_class;\n-  ctxp->filename = input_filename;\n   ctxp->function_decl = current_function_decl;\n   ctxp->saved_data = 1;\n }\n@@ -2788,11 +2820,14 @@ java_parser_context_save_global (void)\n void\n java_parser_context_restore_global (void)\n {\n-  input_line = ctxp->lineno;\n+  input_location = ctxp->save_location;\n   current_class = ctxp->class_type;\n-  input_filename = ctxp->filename;\n   if (wfl_operator)\n+#ifdef USE_MAPPED_LOCATION\n+    SET_EXPR_LOCATION (wfl_operator, ctxp->save_location);\n+#else\n     EXPR_WFL_FILENAME_NODE (wfl_operator) = get_identifier (input_filename);\n+#endif\n   current_function_decl = ctxp->function_decl;\n   ctxp->saved_data = 0;\n   if (ctxp->saved_data_ctx)\n@@ -2960,8 +2995,6 @@ java_debug_context_do (int tab)\n       TAB_CONTEXT (tab);\n       fprintf (stderr, \"filename: %s\\n\", copy->filename);\n       TAB_CONTEXT (tab);\n-      fprintf (stderr, \"lineno: %d\\n\", copy->lineno);\n-      TAB_CONTEXT (tab);\n       fprintf (stderr, \"package: %s\\n\",\n \t       (copy->package ?\n \t\tIDENTIFIER_POINTER (copy->package) : \"<none>\"));\n@@ -3016,22 +3049,36 @@ static int do_warning = 0;\n void\n yyerror (const char *msg)\n {\n+#ifdef USE_MAPPED_LOCATION\n+  static source_location elc;\n+  expanded_location xloc = expand_location (input_location);\n+  int current_line = xloc.line;\n+#else\n   static java_lc elc;\n-  static int  prev_lineno;\n+  int save_lineno;\n+  int current_line = input_line;\n+#endif\n+  static int prev_lineno;\n   static const char *prev_msg;\n \n-  int save_lineno;\n   char *remainder, *code_from_source;\n \n-  if (!force_error && prev_lineno == input_line)\n+  if (!force_error && prev_lineno == current_line)\n     return;\n+#ifndef USE_MAPPED_LOCATION\n+  current_line = ctxp->lexer->token_start.line;\n+#endif\n \n   /* Save current error location but report latter, when the context is\n      richer.  */\n   if (ctxp->java_error_flag == 0)\n     {\n       ctxp->java_error_flag = 1;\n-      elc = ctxp->elc;\n+#ifdef USE_MAPPED_LOCATION\n+      elc = input_location;\n+#else\n+      elc = ctxp->lexer->token_start;\n+#endif\n       /* Do something to use the previous line if we're reaching the\n \t end of the file... */\n #ifdef VERBOSE_SKELETON\n@@ -3041,7 +3088,7 @@ yyerror (const char *msg)\n     }\n \n   /* Ignore duplicate message on the same line. BTW, this is dubious. FIXME */\n-  if (!force_error && msg == prev_msg && prev_lineno == elc.line)\n+  if (!force_error && msg == prev_msg && prev_lineno == current_line)\n     return;\n \n   ctxp->java_error_flag = 0;\n@@ -3050,17 +3097,24 @@ yyerror (const char *msg)\n   else\n     java_error_count++;\n \n+#if 0 /* FIXME */\n   if (elc.col == 0 && msg && msg[1] == ';')\n-    {\n-      elc.col  = ctxp->p_line->char_col-1;\n-      elc.line = ctxp->p_line->lineno;\n-    }\n+    elc = ctxp->prev_line_end;\n+#endif\n \n-  save_lineno = input_line;\n-  prev_lineno = input_line = elc.line;\n   prev_msg = msg;\n \n-  code_from_source = java_get_line_col (ctxp->filename, elc.line, elc.col);\n+#ifdef USE_MAPPED_LOCATION\n+  prev_lineno = current_line;\n+  code_from_source = java_get_line_col (xloc.file, current_line, xloc.column);\n+#else\n+  save_lineno = input_line;\n+  prev_lineno = input_line = current_line;\n+  code_from_source = java_get_line_col (input_filename, current_line,\n+\t\t\t\t\tctxp->lexer->token_start.col);\n+#endif\n+\n+\n   obstack_grow0 (&temporary_obstack,\n \t\t code_from_source, strlen (code_from_source));\n   remainder = obstack_finish (&temporary_obstack);\n@@ -3074,56 +3128,94 @@ yyerror (const char *msg)\n      the same line. This occurs when we report an error but don't have\n      a synchronization point other than ';', which\n      expression_statement is the only one to take care of.  */\n-  ctxp->prevent_ese = input_line = save_lineno;\n+#ifndef USE_MAPPED_LOCATION\n+  input_line = save_lineno;\n+#endif\n+  ctxp->prevent_ese = input_line;\n }\n \n static void\n-issue_warning_error_from_context (tree cl, const char *msg, va_list ap)\n+issue_warning_error_from_context (\n+#ifdef USE_MAPPED_LOCATION\n+\t\t\t\t  source_location cl,\n+#else\n+\t\t\t\t  tree cl,\n+#endif\n+\t\t\t\t  const char *msg, va_list ap)\n {\n-  const char *saved, *saved_input_filename;\n+#ifdef USE_MAPPED_LOCATION\n+  source_location saved_location = input_location;\n+  expanded_location xloc = expand_location (cl);\n+#else\n+  java_lc save_lc = ctxp->lexer->token_start;\n+  const char *saved = ctxp->filename, *saved_input_filename;\n+#endif\n   char buffer [4096];\n   vsprintf (buffer, msg, ap);\n   force_error = 1;\n \n-  ctxp->elc.line = EXPR_WFL_LINENO (cl);\n-  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 :\n-\t\t    (EXPR_WFL_COLNO (cl) == 0xffe ? -2 : EXPR_WFL_COLNO (cl)));\n+#ifdef USE_MAPPED_LOCATION\n+  if (xloc.file != NULL)\n+    {\n+      ctxp->filename = xloc.file;\n+      input_location = cl;\n+    }\n+#else\n+  ctxp->lexer->token_start.line = EXPR_WFL_LINENO (cl);\n+  ctxp->lexer->token_start.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1\n+\t\t\t\t   : EXPR_WFL_COLNO (cl) == 0xffe ? -2\n+\t\t\t\t   : EXPR_WFL_COLNO (cl));\n \n   /* We have a CL, that's a good reason for using it if it contains data */\n-  saved = ctxp->filename;\n   if (TREE_CODE (cl) == EXPR_WITH_FILE_LOCATION && EXPR_WFL_FILENAME_NODE (cl))\n     ctxp->filename = EXPR_WFL_FILENAME (cl);\n   saved_input_filename = input_filename;\n   input_filename = ctxp->filename;\n+#endif\n   java_error (NULL);\n   java_error (buffer);\n+#ifdef USE_MAPPED_LOCATION\n+  input_location = saved_location;\n+#else\n   ctxp->filename = saved;\n   input_filename = saved_input_filename;\n+  ctxp->lexer->token_start = save_lc;\n+#endif\n   force_error = 0;\n }\n \n-/* Issue an error message at a current source line CL */\n+/* Issue an error message at a current source line CL.\n+   FUTURE/FIXME:  change cl to be a source_location. */\n \n void\n parse_error_context (tree cl, const char *msg, ...)\n {\n   va_list ap;\n   va_start (ap, msg);\n+#ifdef USE_MAPPED_LOCATION\n+  issue_warning_error_from_context (EXPR_LOCATION (cl), msg, ap);\n+#else\n   issue_warning_error_from_context (cl, msg, ap);\n+#endif\n   va_end (ap);\n }\n \n-/* Issue a warning at a current source line CL */\n+/* Issue a warning at a current source line CL.\n+   FUTURE/FIXME:  change cl to be a source_location. */\n \n static void\n parse_warning_context (tree cl, const char *msg, ...)\n {\n   va_list ap;\n   va_start (ap, msg);\n \n-  force_error = do_warning = 1;\n+  do_warning = 1;\n+#ifdef USE_MAPPED_LOCATION\n+  issue_warning_error_from_context (EXPR_LOCATION (cl), msg, ap);\n+#else\n   issue_warning_error_from_context (cl, msg, ap);\n-  do_warning = force_error = 0;\n+#endif\n+  do_warning = 0;\n   va_end (ap);\n }\n \n@@ -3174,7 +3266,11 @@ find_expr_with_wfl (tree node)\n static void\n missing_return_error (tree method)\n {\n+#ifdef USE_MAPPED_LOCATION\n+  SET_EXPR_LOCATION (wfl_operator, DECL_FUNCTION_LAST_LINE (method));\n+#else\n   EXPR_WFL_SET_LINECOL (wfl_operator, DECL_FUNCTION_LAST_LINE (method), -2);\n+#endif\n   parse_error_context (wfl_operator, \"Missing return statement\");\n }\n \n@@ -3192,7 +3288,11 @@ unreachable_stmt_error (tree node)\n \n   if (node)\n     {\n+#ifdef USE_MAPPED_LOCATION\n+      SET_EXPR_LOCATION (wfl_operator, EXPR_LOCATION (node));\n+#else\n       EXPR_WFL_SET_LINECOL (wfl_operator, EXPR_WFL_LINENO (node), -2);\n+#endif\n       parse_error_context (wfl_operator, \"Unreachable statement\");\n     }\n   else\n@@ -3383,10 +3483,14 @@ build_unresolved_array_type (tree type_or_wfl)\n \t\t IDENTIFIER_LENGTH (EXPR_WFL_NODE (type_or_wfl)));\n   obstack_grow0 (&temporary_obstack, \"[]\", 2);\n   ptr = obstack_finish (&temporary_obstack);\n+#ifdef USE_MAPPED_LOCATION\n+  wfl = build_expr_wfl (get_identifier (ptr), EXPR_LOCATION (type_or_wfl));\n+#else\n   wfl = build_expr_wfl (get_identifier (ptr),\n \t\t\tEXPR_WFL_FILENAME (type_or_wfl),\n \t\t\tEXPR_WFL_LINENO (type_or_wfl),\n \t\t\tEXPR_WFL_COLNO (type_or_wfl));\n+#endif\n   /* Re-install the existing qualifications so that the type can be\n      resolved properly. */\n   EXPR_WFL_QUALIFICATION (wfl) = EXPR_WFL_QUALIFICATION (type_or_wfl);\n@@ -3446,13 +3550,14 @@ check_class_interface_creation (int is_interface, int flags, tree raw_name,\n      when dealing with an inner class */\n   if (!CPC_INNER_P () && (flags & ACC_PUBLIC ))\n     {\n+      const char *fname = input_filename;\n       const char *f;\n \n-      for (f = &input_filename [strlen (input_filename)];\n-\t   f != input_filename && ! IS_DIR_SEPARATOR (f[0]);\n+      for (f = fname + strlen (fname);\n+\t   f != fname && ! IS_DIR_SEPARATOR (*f);\n \t   f--)\n \t;\n-      if (IS_DIR_SEPARATOR (f[0]))\n+      if (IS_DIR_SEPARATOR (*f))\n \tf++;\n       if (strncmp (IDENTIFIER_POINTER (raw_name),\n \t\t   f , IDENTIFIER_LENGTH (raw_name)) ||\n@@ -3650,7 +3755,7 @@ find_as_inner_class (tree enclosing, tree name, tree cl)\n   else if (cl)\n     qual = build_tree_list (cl, NULL_TREE);\n   else\n-    qual = build_tree_list (build_expr_wfl (name, NULL, 0, 0), NULL_TREE);\n+    qual = build_tree_list (build_unknown_wfl (name), NULL_TREE);\n \n   if ((to_return = find_as_inner_class_do (qual, enclosing)))\n     return to_return;\n@@ -3680,7 +3785,7 @@ find_as_inner_class (tree enclosing, tree name, tree cl)\n     }\n   /* Otherwise, create a qual for the other part of the resolution. */\n   else\n-    qual = build_tree_list (build_expr_wfl (name, NULL, 0, 0), NULL_TREE);\n+    qual = build_tree_list (build_unknown_wfl (name), NULL_TREE);\n \n   return find_as_inner_class_do (qual, enclosing);\n }\n@@ -3769,16 +3874,28 @@ maybe_create_class_interface_decl (tree decl, tree raw_name,\n     decl = push_class (make_class (), qualified_name);\n \n   /* Take care of the file and line business */\n+#ifdef USE_MAPPED_LOCATION\n+  DECL_SOURCE_LOCATION (decl) = EXPR_LOCATION (cl);\n+#else\n   DECL_SOURCE_FILE (decl) = EXPR_WFL_FILENAME (cl);\n   /* If we're emitting xrefs, store the line/col number information */\n   if (flag_emit_xref)\n     DECL_SOURCE_LINE (decl) = EXPR_WFL_LINECOL (cl);\n   else\n     DECL_SOURCE_LINE (decl) = EXPR_WFL_LINENO (cl);\n+#endif\n   CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) = 1;\n   CLASS_PARSED_P (TREE_TYPE (decl)) = 1;\n+#ifdef USE_MAPPED_LOCATION\n+  {\n+    tree tmp = maybe_get_identifier (EXPR_FILENAME (cl));\n+    CLASS_FROM_CURRENTLY_COMPILED_P (TREE_TYPE (decl)) =\n+      tmp && IS_A_COMMAND_LINE_FILENAME_P (tmp);\n+  }\n+#else\n   CLASS_FROM_CURRENTLY_COMPILED_P (TREE_TYPE (decl)) =\n     IS_A_COMMAND_LINE_FILENAME_P (EXPR_WFL_FILENAME_NODE (cl));\n+#endif\n \n   PUSH_CPC (decl, raw_name);\n   DECL_CONTEXT (decl) = GET_ENCLOSING_CPC_CONTEXT ();\n@@ -4298,7 +4415,7 @@ register_fields (int flags, tree type, tree variable_list)\n {\n   tree current, saved_type;\n   tree class_type = NULL_TREE;\n-  int saved_lineno = input_line;\n+  location_t saved_location = input_location;\n   int must_chain = 0;\n   tree wfl = NULL_TREE;\n \n@@ -4367,10 +4484,14 @@ register_fields (int flags, tree type, tree variable_list)\n \n       /* Set input_line to the line the field was found and create a\n          declaration for it. Eventually sets the @deprecated tag flag. */\n+#ifdef USE_MAPPED_LOCATION\n+      input_location = EXPR_LOCATION (cl);\n+#else\n       if (flag_emit_xref)\n \tinput_line = EXPR_WFL_LINECOL (cl);\n       else\n \tinput_line = EXPR_WFL_LINENO (cl);\n+#endif\n       field_decl = add_field (class_type, current_name, real_type, flags);\n       CHECK_DEPRECATED_NO_RESET (field_decl);\n \n@@ -4432,7 +4553,7 @@ register_fields (int flags, tree type, tree variable_list)\n     }\n \n   CLEAR_DEPRECATED;\n-  input_line = saved_lineno;\n+  input_location = saved_location;\n }\n \n /* Generate finit$, using the list of initialized fields to populate\n@@ -4553,7 +4674,7 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n   tree meth_name = NULL_TREE;\n   tree current, orig_arg, this_class = NULL;\n   tree id, meth;\n-  int saved_lineno;\n+  location_t saved_location;\n   int constructor_ok = 0, must_chain;\n   int count;\n \n@@ -4684,12 +4805,17 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n   else\n     TREE_TYPE (meth) = type;\n \n-  saved_lineno = input_line;\n+  saved_location = input_location;\n   /* When defining an abstract or interface method, the curly\n      bracket at level 1 doesn't exist because there is no function\n      body */\n-  input_line = (ctxp->first_ccb_indent1 ? ctxp->first_ccb_indent1 :\n-\t    EXPR_WFL_LINENO (id));\n+#ifdef USE_MAPPED_LOCATION\n+  input_location = (ctxp->first_ccb_indent1 ? ctxp->first_ccb_indent1 :\n+\t\t    EXPR_LOCATION (id));\n+#else\n+  input_line = (ctxp->first_ccb_indent1 ? (int) ctxp->first_ccb_indent1 :\n+\t\tEXPR_WFL_LINENO (id));\n+#endif\n \n   /* Remember the original argument list */\n   orig_arg = TYPE_ARG_TYPES (meth);\n@@ -4722,7 +4848,7 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n   /* Register the parameter number and re-install the current line\n      number */\n   DECL_MAX_LOCALS (meth) = ctxp->formal_parameter_number+1;\n-  input_line = saved_lineno;\n+  input_location = saved_location;\n \n   /* Register exception specified by the `throws' keyword for\n      resolution and set the method decl appropriate field to the list.\n@@ -4763,7 +4889,13 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n   /* If doing xref, store column and line number information instead\n      of the line number only. */\n   if (flag_emit_xref)\n-    DECL_SOURCE_LINE (meth) = EXPR_WFL_LINECOL (id);\n+    {\n+#ifdef USE_MAPPED_LOCATION\n+      DECL_SOURCE_LOCATION (meth) = EXPR_LOCATION (id);\n+#else\n+      DECL_SOURCE_LINE (meth) = EXPR_WFL_LINECOL (id);\n+#endif\n+    }\n \n   return meth;\n }\n@@ -6746,22 +6878,28 @@ lookup_java_method2 (tree clas, tree method_decl, int do_interface)\n }\n \n /* Return the line that matches DECL line number, and try its best to\n-   position the column number. Used during error reports.  */\n+   position the column number. Used during error reports.\n+   FUTURE/FIXME: return source_location instead of node. */\n \n static GTY(()) tree cl_v;\n static tree\n lookup_cl (tree decl)\n {\n+#ifndef USE_MAPPED_LOCATION\n   char *line, *found;\n+#endif\n \n   if (!decl)\n     return NULL_TREE;\n \n   if (cl_v == NULL_TREE)\n     {\n-      cl_v = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n+      cl_v = build_unknown_wfl (NULL_TREE);\n     }\n \n+#ifdef USE_MAPPED_LOCATION\n+  SET_EXPR_LOCATION (cl_v, DECL_SOURCE_LOCATION (decl));\n+#else\n   EXPR_WFL_FILENAME_NODE (cl_v) = get_identifier (DECL_SOURCE_FILE (decl));\n   EXPR_WFL_SET_LINECOL (cl_v, DECL_SOURCE_LINE (decl), -1);\n \n@@ -6772,6 +6910,7 @@ lookup_cl (tree decl)\n \t\t  (const char *)IDENTIFIER_POINTER (DECL_NAME (decl)));\n   if (found)\n     EXPR_WFL_SET_LINECOL (cl_v, EXPR_WFL_LINENO (cl_v), found - line);\n+#endif\n \n   return cl_v;\n }\n@@ -7026,7 +7165,7 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n \n   for (; import; import = TREE_CHAIN (import))\n     {\n-      int saved_lineno = input_line;\n+      location_t saved_location = input_location;\n       int access_check;\n       const char *id_name;\n       tree decl, type_name_copy;\n@@ -7045,7 +7184,11 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n \n       /* Setup input_line so that it refers to the line of the import (in\n \t case we parse a class file and encounter errors */\n+#ifdef USE_MAPPED_LOCATION\n+      input_location = EXPR_LOCATION (TREE_PURPOSE (import));\n+#else\n       input_line = EXPR_WFL_LINENO (TREE_PURPOSE (import));\n+#endif\n \n       type_name_copy = TYPE_NAME (class_type);\n       TYPE_NAME (class_type) = node;\n@@ -7066,7 +7209,7 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n \t/* 6.6.1: Inner classes are subject to member access rules. */\n \taccess_check = 0;\n \n-      input_line = saved_lineno;\n+      input_location = saved_location;\n \n       /* If the loaded class is not accessible or couldn't be loaded,\n \t we restore the original TYPE_NAME and process the next\n@@ -7363,8 +7506,13 @@ declare_local_variables (int modifier, tree type, tree vlist)\n \n       /* If doing xreferencing, replace the line number with the WFL\n          compound value */\n+#ifdef USE_MAPPED_LOCATION\n+      if (flag_emit_xref)\n+\tDECL_SOURCE_LOCATION (decl) = EXPR_LOCATION (wfl);\n+#else\n       if (flag_emit_xref)\n \tDECL_SOURCE_LINE (decl) = EXPR_WFL_LINECOL (wfl);\n+#endif\n \n       /* Don't try to use an INIT statement when an error was found */\n       if (init && java_error_count)\n@@ -7462,9 +7610,9 @@ create_artificial_method (tree class, int flags, tree type,\n \t\t\t  tree name, tree args)\n {\n   tree mdecl;\n+  location_t save_location = input_location;\n \n-  java_parser_context_save_global ();\n-  input_line = 0;\n+  input_location = DECL_SOURCE_LOCATION (TYPE_NAME (class));\n   mdecl = make_node (FUNCTION_TYPE);\n   TREE_TYPE (mdecl) = type;\n   TYPE_ARG_TYPES (mdecl) = args;\n@@ -7473,7 +7621,7 @@ create_artificial_method (tree class, int flags, tree type,\n      the type of the returned method, which trashes the cache in\n      get_type_from_signature().  */\n   mdecl = add_method_1 (class, flags, name, mdecl);\n-  java_parser_context_restore_global ();\n+  input_location = save_location;\n   DECL_ARTIFICIAL (mdecl) = 1;\n   return mdecl;\n }\n@@ -7483,8 +7631,13 @@ create_artificial_method (tree class, int flags, tree type,\n static void\n start_artificial_method_body (tree mdecl)\n {\n+#ifdef USE_MAPPED_LOCATION\n+  DECL_SOURCE_LOCATION (mdecl) = ctxp->file_start_location;\n+  DECL_FUNCTION_LAST_LINE (mdecl) = ctxp->file_start_location;\n+#else\n   DECL_SOURCE_LINE (mdecl) = 1;\n   DECL_FUNCTION_LAST_LINE (mdecl) = 1;\n+#endif\n   source_start_java_method (mdecl);\n   enter_block ();\n }\n@@ -7528,7 +7681,11 @@ source_end_java_method (void)\n     return;\n \n   java_parser_context_save_global ();\n+#ifdef USE_MAPPED_LOCATION\n+  input_location = ctxp->last_ccb_indent1;\n+#else\n   input_line = ctxp->last_ccb_indent1;\n+#endif\n \n   /* Turn function bodies with only a NOP expr null, so they don't get\n      generated at all and we won't get warnings when using the -W\n@@ -7587,7 +7744,10 @@ java_layout_seen_class_methods (void)\n       for (current = previous_list;\n \t   current != end; current = TREE_CHAIN (current))\n         {\n-          tree cls = TREE_TYPE (TREE_VALUE (current));\n+\t  tree decl = TREE_VALUE (current);\n+          tree cls = TREE_TYPE (decl);\n+\n+\t  input_location = DECL_SOURCE_LOCATION (decl);\n \n           if (! CLASS_LOADED_P (cls))\n             load_class (cls, 0);\n@@ -8018,7 +8178,7 @@ start_complete_expand_method (tree mdecl)\n       TREE_CHAIN (tem) = next;\n     }\n   pushdecl_force_head (DECL_ARGUMENTS (mdecl));\n-  input_line = DECL_SOURCE_LINE (mdecl);\n+  input_location = DECL_SOURCE_LOCATION (mdecl);\n   build_result_decl (mdecl);\n }\n \n@@ -8690,7 +8850,11 @@ build_thisn_assign (void)\n       tree lhs = make_qualified_primary (build_wfl_node (this_identifier_node),\n \t\t\t\t\t build_wfl_node (thisn), 0);\n       tree rhs = build_wfl_node (thisn);\n+#ifdef USE_MAPPED_LOCATION\n+      SET_EXPR_LOCATION (lhs, input_location);\n+#else\n       EXPR_WFL_SET_LINECOL (lhs, input_line, 0);\n+#endif\n       return build_assignment (ASSIGN_TK, EXPR_WFL_LINECOL (lhs), lhs, rhs);\n     }\n   return NULL_TREE;\n@@ -8714,7 +8878,11 @@ static tree\n build_dot_class_method (tree class)\n {\n #define BWF(S) build_wfl_node (get_identifier ((S)))\n+#ifdef USE_MAPPED_LOCATION\n+#define MQN(X,Y) make_qualified_name ((X), (Y), UNKNOWN_LOCATION)\n+#else\n #define MQN(X,Y) make_qualified_name ((X), (Y), 0)\n+#endif\n   tree args, tmp, saved_current_function_decl, mdecl, qual_name;\n   tree stmt, throw_stmt;\n \n@@ -8752,8 +8920,13 @@ build_dot_class_method (tree class)\n \n   /* Now onto the catch block. We start by building the expression\n      throwing a new exception: throw new NoClassDefFoundError (_.getMessage) */\n+#ifdef USE_MAPPED_LOCATION\n+  throw_stmt = make_qualified_name (build_wfl_node (wpv_id),\n+\t\t\t\t    get_message_wfl, UNKNOWN_LOCATION);\n+#else\n   throw_stmt = make_qualified_name (build_wfl_node (wpv_id),\n \t\t\t\t    get_message_wfl, 0);\n+#endif\n   throw_stmt = build_method_invocation (throw_stmt, NULL_TREE);\n \n   /* Build new NoClassDefFoundError (_.getMessage) */\n@@ -8818,15 +8991,15 @@ static void\n fix_constructors (tree mdecl)\n {\n   tree iii;\t\t\t/* Instance Initializer Invocation */\n-  tree body = DECL_FUNCTION_BODY (mdecl);\n+  tree *bodyp = &DECL_FUNCTION_BODY (mdecl);\n   tree thisn_assign, compound = NULL_TREE;\n   tree class_type = DECL_CONTEXT (mdecl);\n \n   if (DECL_FIXED_CONSTRUCTOR_P (mdecl))\n     return;\n   DECL_FIXED_CONSTRUCTOR_P (mdecl) = 1;\n \n-  if (!body)\n+  if (!*bodyp)\n     {\n       /* It is an error for the compiler to generate a default\n \t constructor if the superclass doesn't have a constructor that\n@@ -8870,31 +9043,30 @@ fix_constructors (tree mdecl)\n     {\n       int found = 0;\n       int invokes_this = 0;\n-      tree found_call = NULL_TREE;\n-      tree main_block = BLOCK_EXPR_BODY (body);\n+      tree main_block = BLOCK_EXPR_BODY (*bodyp);\n \n-      while (body)\n-\tswitch (TREE_CODE (body))\n-\t  {\n-\t  case CALL_EXPR:\n-\t    found = CALL_EXPLICIT_CONSTRUCTOR_P (body);\n-\t    if (CALL_THIS_CONSTRUCTOR_P (body))\n-\t      invokes_this = 1;\n-\t    body = NULL_TREE;\n-\t    break;\n-\t  case COMPOUND_EXPR:\n-\t  case EXPR_WITH_FILE_LOCATION:\n-\t    found_call = body;\n-\t    body = TREE_OPERAND (body, 0);\n-\t    break;\n-\t  case BLOCK:\n-\t    found_call = body;\n-\t    body = BLOCK_EXPR_BODY (body);\n-\t    break;\n-\t  default:\n-\t    found = 0;\n-\t    body = NULL_TREE;\n-\t  }\n+      while (*bodyp)\n+\t{\n+\t  tree body = *bodyp;\n+\t  switch (TREE_CODE (body))\n+\t    {\n+\t    case CALL_EXPR:\n+\t      found = CALL_EXPLICIT_CONSTRUCTOR_P (body);\n+\t      if (CALL_THIS_CONSTRUCTOR_P (body))\n+\t\tinvokes_this = 1;\n+\t      break;\n+\t    case COMPOUND_EXPR:\n+\t    case EXPR_WITH_FILE_LOCATION:\n+\t      bodyp = &TREE_OPERAND (body, 0);\n+\t      continue;\n+\t    case BLOCK:\n+\t      bodyp = &BLOCK_EXPR_BODY (body);\n+\t      continue;\n+\t    default:\n+\t      break;\n+\t    }\n+\t  break;\n+\t}\n \n       /* Generate the assignment to this$<n>, if necessary */\n       if ((thisn_assign = build_thisn_assign ()))\n@@ -8908,9 +9080,8 @@ fix_constructors (tree mdecl)\n          instance initializer blocks. */\n       else\n \t{\n-\t  compound = add_stmt_to_compound (compound, NULL_TREE,\n-\t\t\t\t\t   TREE_OPERAND (found_call, 0));\n-\t  TREE_OPERAND (found_call, 0) = build_java_empty_stmt ();\n+\t  compound = add_stmt_to_compound (compound, NULL_TREE, *bodyp);\n+\t  *bodyp = build_java_empty_stmt ();\n \t}\n \n       DECL_INIT_CALLS_THIS (mdecl) = invokes_this;\n@@ -8997,6 +9168,7 @@ java_expand_classes (void)\n     return;\n   java_layout_classes ();\n   java_parse_abort_on_error ();\n+  location_t save_location = input_location;\n \n   for (cur_ctxp = ctxp_for_generation; cur_ctxp; cur_ctxp = cur_ctxp->next)\n     {\n@@ -9010,12 +9182,12 @@ java_expand_classes (void)\n   for (cur_ctxp = ctxp_for_generation; cur_ctxp; cur_ctxp = cur_ctxp->next)\n     {\n       ctxp = cur_ctxp;\n-      input_filename = ctxp->filename;\n+      input_location = ctxp->file_start_location;\n       lang_init_source (2);\t       /* Error msgs have method prototypes */\n       java_complete_expand_classes (); /* Complete and expand classes */\n       java_parse_abort_on_error ();\n     }\n-  input_filename = main_input_filename;\n+  input_location = save_location;\n \n   /* Find anonymous classes and expand their constructor. This extra pass is\n      necessary because the constructor itself is only generated when the\n@@ -9227,11 +9399,17 @@ merge_qualified_name (tree left, tree right)\n    inherited from the location information of the `.' operator. */\n \n static tree\n-make_qualified_name (tree left, tree right, int location)\n+make_qualified_name (tree left, tree right,\n+#ifdef USE_MAPPED_LOCATION\n+\t\t     source_location location\n+#else\n+\t\t     int location\n+#endif\n+\t\t     )\n {\n #ifdef USE_COMPONENT_REF\n   tree node = build3 (COMPONENT_REF, NULL_TREE, left, right, NULL_TREE);\n-  EXPR_WFL_LINECOL (node) = location;\n+  SET_EXPR_LOCATION (node, location);\n   return node;\n #else\n   tree left_id = EXPR_WFL_NODE (left);\n@@ -9241,6 +9419,15 @@ make_qualified_name (tree left, tree right, int location)\n   merge = merge_qualified_name (left_id, right_id);\n \n   /* Left wasn't qualified and is now qualified */\n+#ifdef USE_MAPPED_LOCATION\n+  if (!QUALIFIED_P (left_id))\n+    {\n+      tree wfl = build_expr_wfl (left_id, EXPR_LOCATION (left));\n+      EXPR_WFL_QUALIFICATION (left) = build_tree_list (wfl, NULL_TREE);\n+    }\n+\n+  wfl = build_expr_wfl (right_id, location);\n+#else\n   if (!QUALIFIED_P (left_id))\n     {\n       tree wfl = build_expr_wfl (left_id, ctxp->filename, 0, 0);\n@@ -9250,8 +9437,8 @@ make_qualified_name (tree left, tree right, int location)\n \n   wfl = build_expr_wfl (right_id, ctxp->filename, 0, 0);\n   EXPR_WFL_LINECOL (wfl) = location;\n+#endif\n   chainon (EXPR_WFL_QUALIFICATION (left), build_tree_list (wfl, NULL_TREE));\n-\n   EXPR_WFL_NODE (left) = merge;\n   return left;\n #endif\n@@ -9523,7 +9710,11 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n     {\n       tree qual_wfl = QUAL_WFL (q);\n       tree ret_decl;\t\t/* for EH checking */\n+#ifdef USE_MAPPED_LOCATION\n+      source_location location;  /* for EH checking */\n+#else\n       int location;\t\t/* for EH checking */\n+#endif\n \n       /* 15.10.1 Field Access Using a Primary */\n       switch (TREE_CODE (qual_wfl))\n@@ -9569,8 +9760,14 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \n \t  if (from_super && TREE_CODE (qual_wfl) == CALL_EXPR)\n \t    CALL_USING_SUPER (qual_wfl) = 1;\n+#ifdef USE_MAPPED_LOCATION\n+\t  location = (TREE_CODE (qual_wfl) == CALL_EXPR\n+\t\t      ? EXPR_LOCATION (TREE_OPERAND (qual_wfl, 0))\n+\t\t      : UNKNOWN_LOCATION);\n+#else\n \t  location = (TREE_CODE (qual_wfl) == CALL_EXPR ?\n \t\t      EXPR_WFL_LINECOL (TREE_OPERAND (qual_wfl, 0)) : 0);\n+#endif\n \t  *where_found = patch_method_invocation (qual_wfl, decl, type,\n \t\t\t\t\t\t  from_super,\n \t\t\t\t\t\t  &is_static, &ret_decl);\n@@ -9602,7 +9799,11 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t     instantiation using a primary qualified by a `new' */\n \t  RESTORE_THIS_AND_CURRENT_CLASS;\n \n+#ifdef USE_MAPPED_LOCATION\n+\t  if (location != UNKNOWN_LOCATION)\n+#else\n \t  if (location)\n+#endif\n \t    {\n \t      tree arguments = NULL_TREE;\n \t      if (TREE_CODE (qual_wfl) == CALL_EXPR\n@@ -11603,7 +11804,11 @@ java_complete_lhs (tree node)\n       /* Only one default label is allowed per switch statement */\n       if (SWITCH_HAS_DEFAULT (nn))\n \t{\n+#ifdef USE_MAPPED_LOCATION\n+\t  SET_EXPR_LOCATION (wfl_operator, EXPR_LOCATION (node));\n+#else\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n+#endif\n \t  parse_error_context (wfl_operator,\n \t\t\t       \"Duplicate case label: `default'\");\n \t  return error_mark_node;\n@@ -11756,10 +11961,16 @@ java_complete_lhs (tree node)\n       else\n \t{\n \t  tree body;\n-\t  int save_lineno = input_line;\n+\t  location_t save_location = input_location;\n+#ifdef USE_MAPPED_LOCATION\n+\t  input_location = EXPR_LOCATION (node);\n+\t  if (input_location == UNKNOWN_LOCATION)\n+\t    input_location = save_location;\n+#else\n \t  input_line = EXPR_WFL_LINENO (node);\n+#endif\n \t  body = java_complete_tree (EXPR_WFL_NODE (node));\n-\t  input_line = save_lineno;\n+\t  input_location = save_location;\n \t  EXPR_WFL_NODE (node) = body;\n \t  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (body);\n \t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n@@ -11799,9 +12010,13 @@ java_complete_lhs (tree node)\n \t      TREE_VALUE (cn) = dim;\n \t      /* Setup the location of the current dimension, for\n \t\t later error report. */\n+#ifdef USE_MAPPED_LOCATION\n+\t      TREE_PURPOSE (cn) = expr_add_location (NULL_TREE, location, 0);\n+#else\n \t      TREE_PURPOSE (cn) =\n \t\tbuild_expr_wfl (NULL_TREE, input_filename, 0, 0);\n \t      EXPR_WFL_LINECOL (TREE_PURPOSE (cn)) = location;\n+#endif\n \t    }\n \t}\n       /* They complete the array creation expression, if no errors\n@@ -11840,7 +12055,11 @@ java_complete_lhs (tree node)\n \t  int from_super = (EXPR_WFL_NODE (TREE_OPERAND (node, 0)) ==\n                            super_identifier_node);\n \t  tree arguments;\n+#ifdef USE_MAPPED_LOCATION\n+\t  source_location location = EXPR_LOCATION (node);\n+#else\n \t  int location = EXPR_WFL_LINECOL (node);\n+#endif\n \n \t  node = patch_method_invocation (node, NULL_TREE, NULL_TREE,\n \t\t\t\t\t  from_super, 0, &decl);\n@@ -12204,10 +12423,14 @@ build_debugable_stmt (int location, tree stmt)\n {\n   if (TREE_CODE (stmt) != EXPR_WITH_FILE_LOCATION)\n     {\n+#ifdef USE_MAPPED_LOCATION\n+      stmt = expr_add_location (stmt, location, 1);\n+#else\n       stmt = build_expr_wfl (stmt, input_filename, 0, 0);\n       EXPR_WFL_LINECOL (stmt) = location;\n+      JAVA_MAYBE_GENERATE_DEBUG_INFO (stmt);\n+#endif\n     }\n-  JAVA_MAYBE_GENERATE_DEBUG_INFO (stmt);\n   return stmt;\n }\n \n@@ -12335,9 +12558,15 @@ build_wfl_wrap (tree node, int location)\n   if (TREE_CODE (node) == THIS_EXPR)\n     node_to_insert = wfl = build_wfl_node (this_identifier_node);\n   else\n+#ifdef USE_MAPPED_LOCATION\n+    wfl = build_unknown_wfl (NULL_TREE);\n+\n+  SET_EXPR_LOCATION (wfl, location);\n+#else\n     wfl = build_expr_wfl (NULL_TREE, ctxp->filename, 0, 0);\n \n   EXPR_WFL_LINECOL (wfl) = location;\n+#endif\n   EXPR_WFL_QUALIFICATION (wfl) = build_tree_list (node_to_insert, NULL_TREE);\n   return wfl;\n }\n@@ -14478,8 +14707,18 @@ static tree\n maybe_build_array_element_wfl (tree node)\n {\n   if (TREE_CODE (node) != EXPR_WITH_FILE_LOCATION)\n-    return build_expr_wfl (NULL_TREE, ctxp->filename,\n-\t\t\t   ctxp->elc.line, ctxp->elc.prev_col);\n+    {\n+      /* FIXME - old code used \"prev_lc.line\" and \"elc.prev_col */\n+      return build_expr_wfl (NULL_TREE,\n+#ifdef USE_MAPPED_LOCATION\n+\t\t\t     input_location\n+#else\n+\t\t\t     ctxp->filename,\n+\t\t\t     ctxp->lexer->token_start.line,\n+\t\t\t     ctxp->lexer->token_start.col\n+#endif\n+\t\t\t     );\n+    }\n   else\n     return NULL_TREE;\n }\n@@ -14882,9 +15121,13 @@ finish_loop_body (int location, tree condition, tree body, int reversed)\n       /* We wrapped the EXIT_EXPR around a WFL so we can debug it.\n          The real EXIT_EXPR is one operand further. */\n       EXPR_WFL_LINECOL (cnode) = location;\n-      /* This one is for accurate error reports */\n-      EXPR_WFL_LINECOL (TREE_OPERAND (cnode, 0)) = location;\n-      TREE_OPERAND (TREE_OPERAND (cnode, 0), 0) = condition;\n+      if (TREE_CODE (cnode) == EXPR_WITH_FILE_LOCATION)\n+\t{\n+\t  cnode = EXPR_WFL_NODE (cnode);\n+\t  /* This one is for accurate error reports */\n+\t  EXPR_WFL_LINECOL (cnode) = location;\n+\t}\n+      TREE_OPERAND (cnode, 0) = condition;\n     }\n   LOOP_EXPR_BODY_BODY_EXPR (loop_body, reversed) = body;\n   POP_LOOP ();\n@@ -15212,7 +15455,13 @@ patch_switch_statement (tree node)\n /* Build an assertion expression for `assert CONDITION : VALUE'; VALUE\n    might be NULL_TREE.  */\n static tree\n-build_assertion (int location, tree condition, tree value)\n+build_assertion (\n+#ifdef USE_MAPPED_LOCATION\n+\t\t source_location location,\n+#else\n+\t\t int location,\n+#endif\n+\t\t tree condition, tree value)\n {\n   tree node;\n   tree klass = GET_CPC ();\n@@ -15636,7 +15885,14 @@ patch_throw_statement (tree node, tree wfl_op1)\n    effectively caught from where DECL is invoked.  THIS_EXPR is the\n    expression that computes `this' for the method call.  */\n static void\n-check_thrown_exceptions (int location, tree decl, tree this_expr)\n+check_thrown_exceptions (\n+#ifdef USE_MAPPED_LOCATION\n+\t\t\t source_location location,\n+#else\n+\n+\t\t\t int location,\n+#endif\n+\t\t\t tree decl, tree this_expr)\n {\n   tree throws;\n   int is_array_call = 0;\n@@ -15659,7 +15915,11 @@ check_thrown_exceptions (int location, tree decl, tree this_expr)\n \tif (is_array_call && DECL_NAME (decl) == get_identifier (\"clone\"))\n \t  continue;\n \n+#ifdef USE_MAPPED_LOCATION\n+\tSET_EXPR_LOCATION (wfl_operator, location);\n+#else\n \tEXPR_WFL_LINECOL (wfl_operator) = location;\n+#endif\n \tif (DECL_FINIT_P (current_function_decl))\n \t  parse_error_context\n             (wfl_operator, \"Exception `%s' can't be thrown in initializer\","}]}