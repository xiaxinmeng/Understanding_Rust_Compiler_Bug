{"sha": "d764a8e6bdae09aecb7a8378def9d900f84ce53e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc2NGE4ZTZiZGFlMDlhZWNiN2E4Mzc4ZGVmOWQ5MDBmODRjZTUzZQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2011-02-18T00:07:38Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-02-18T00:07:38Z"}, "message": "Added support for the 64-bit Apple Objective-C runtime\n\nFrom-SVN: r170260", "tree": {"sha": "c0b6f091c931f0a65e3fb59fbd9fff3f5ba9bde9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0b6f091c931f0a65e3fb59fbd9fff3f5ba9bde9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d764a8e6bdae09aecb7a8378def9d900f84ce53e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d764a8e6bdae09aecb7a8378def9d900f84ce53e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d764a8e6bdae09aecb7a8378def9d900f84ce53e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d764a8e6bdae09aecb7a8378def9d900f84ce53e/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a8134cacea8b18b0e241cc492546cbb69ae598a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8134cacea8b18b0e241cc492546cbb69ae598a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8134cacea8b18b0e241cc492546cbb69ae598a"}], "stats": {"total": 27082, "additions": 17257, "deletions": 9825}, "files": [{"sha": "7fecfea528e64819345b4ad7e66de0200b190f39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,3 +1,23 @@\n+2011-02-17  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* config/darwin-c.c (darwin_cpp_builtins): Define __OBJC2__ for\n+\tobjc_abi == 2.\t\n+\t* config/darwin.c (output_objc_section_asm_op): Added support for\n+\tABI v1 and v2.\n+\t(is_objc_metadata): New.\n+\t(darwin_objc2_section): New.\n+\t(darwin_objc1_section): New.\n+\t(machopic_select_section): Added support for ABI v1 and v2.\n+\t(darwin_emit_objc_zeroed): New.\n+\t(darwin_output_aligned_bss): Detect objc metadata and treat it\n+\tappropriately.\n+\t(darwin_asm_output_aligned_decl_common): Same.\n+\t(darwin_asm_output_aligned_decl_local): Same.\n+\t* config/darwin-sections.def: Updated for ABI v1 and v2.\n+\t* config/darwin.h (SUBTARGET_C_COMMON_OVERRIDE_OPTIONS): When\n+\tcompiling Objective-C code for the NeXT runtime, default to using\n+\tABI version 0 for 32-bit, and version 2 for 64-bit.\n+\n 2011-02-17  Joseph Myers  <joseph@codesourcery.com>\n \n \t* common.opt (optimize_fast): New Variable."}, {"sha": "0c713ba7e85b44db80ac040062f5a4ef12391a16", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -629,6 +629,9 @@ darwin_cpp_builtins (cpp_reader *pfile)\n       builtin_define (\"__strong=\");\n       builtin_define (\"__weak=\");\n     }\n+\n+  if (flag_objc_abi == 2)\n+    builtin_define (\"__OBJC2__\");\n }\n \n /* Handle C family front-end options.  */"}, {"sha": "61b6f69b1232a2a12936cee2d62544b7ebb8f5f6", "filename": "gcc/config/darwin-sections.def", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fconfig%2Fdarwin-sections.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fconfig%2Fdarwin-sections.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-sections.def?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -94,7 +94,7 @@ DEF_SECTION (mod_term_section, 0, \".mod_term_func\", 0)\n DEF_SECTION (constructor_section, 0, \".constructor\", 0)\n DEF_SECTION (destructor_section, 0, \".destructor\", 0)\n \n-/* Objective-C (V1) sections.  */\n+/* Objective-C ABI=0 (Original version) sections.  */\n DEF_SECTION (objc_class_section, 0, \".objc_class\", 1)\n DEF_SECTION (objc_meta_class_section, 0, \".objc_meta_class\", 1)\n DEF_SECTION (objc_category_section, 0, \".objc_category\", 1)\n@@ -112,7 +112,7 @@ DEF_SECTION (objc_module_info_section, 0, \".objc_module_info\", 1)\n DEF_SECTION (objc_protocol_section, 0, \".objc_protocol\", 1)\n DEF_SECTION (objc_string_object_section, 0, \".objc_string_object\", 1)\n DEF_SECTION (objc_constant_string_object_section, 0,\n-\t     \".section __OBJC, __cstring_object, regular, no_dead_strip\", 1)\n+\t     \".section __OBJC, __cstring_object, regular, no_dead_strip\", 0)\n \n /* Fix-and-Continue image marker.  */\n DEF_SECTION (objc_image_info_section, 0,\n@@ -156,3 +156,40 @@ DEF_SECTION (darwin_exception_section, SECTION_NO_ANCHOR,\n DEF_SECTION (darwin_eh_frame_section, SECTION_NO_ANCHOR,\n \t     \".section \" EH_FRAME_SECTION_NAME \",__eh_frame\"\n \t     EH_FRAME_SECTION_ATTR, 0)\n+\n+/* Sections for ObjC ABI=1 (ObjC 'V1' extensions) */\n+DEF_SECTION (objc1_class_ext_section, 0,\n+\t    \".section __OBJC, __class_ext, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc1_prop_list_section, 0,\n+\t    \".section __OBJC, __property, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc1_protocol_ext_section, 0,\n+\t    \".section __OBJC, __protocol_ext, regular, no_dead_strip\", 1)\n+\n+/* Sections for ObjC ABI=2 (m64).  */\n+DEF_SECTION (objc2_message_refs_section, 0,\n+\t     \".section __DATA, __objc_msgrefs, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_classdefs_section, 0, \".section __DATA, __objc_data\", 1)\n+DEF_SECTION (objc2_metadata_section, 0, \".section __DATA, __objc_const\", 1)\n+\n+DEF_SECTION (objc2_classrefs_section, 0, \n+             \".section __DATA, __objc_classrefs, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_classlist_section, 0,\n+\t     \".section __DATA, __objc_classlist, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_categorylist_section, 0,\n+\t     \".section __DATA, __objc_catlist, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_selector_refs_section, 0,\n+\t     \".section __DATA, __objc_selrefs, literal_pointers, no_dead_strip\", 1)\n+DEF_SECTION (objc2_nonlazy_class_section, 0,\n+\t     \".section __DATA, __objc_nlclslist, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_nonlazy_category_section, 0,\n+\t     \".section __DATA, __objc_nlcatlist, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_protocollist_section, 0,\n+\t     \".section __DATA, __objc_protolist, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_protocolrefs_section, 0,\n+\t     \".section __DATA, __objc_protorefs, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_super_classrefs_section, 0,\n+\t     \".section __DATA, __objc_superrefs, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_image_info_section, 0,\n+\t     \".section __DATA, __objc_imageinfo, regular, no_dead_strip\", 1)\n+DEF_SECTION (objc2_constant_string_object_section, 0,\n+\t     \".section __DATA, __objc_stringobj, regular, no_dead_strip\", 1)"}, {"sha": "2969f1020e6510945bd155855e4bff022b0b8b87", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 312, "deletions": 13, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -148,13 +148,48 @@ output_objc_section_asm_op (const void *directive)\n \t  objc_class_vars_section,\n \t  objc_instance_vars_section,\n \t  objc_module_info_section,\n-\t  objc_symbols_section\n+\t  objc_symbols_section,\n \t};\n+      /* ABI=1 */\n+      static const enum darwin_section_enum tomarkv1[] =\n+\t{\n+\t  objc1_protocol_ext_section,\n+\t  objc1_class_ext_section,\n+\t  objc1_prop_list_section\n+\t} ;\n+      /* ABI=2 */\n+      static const enum darwin_section_enum tomarkv2[] =\n+\t{\n+\t  objc2_message_refs_section,\n+\t  objc2_classdefs_section,\n+\t  objc2_metadata_section,\n+\t  objc2_classrefs_section,\n+\t  objc2_classlist_section,\n+\t  objc2_categorylist_section,\n+\t  objc2_selector_refs_section,\n+\t  objc2_nonlazy_class_section,\n+\t  objc2_nonlazy_category_section,\n+\t  objc2_protocollist_section,\n+\t  objc2_protocolrefs_section,\n+\t  objc2_super_classrefs_section,\n+\t  objc2_image_info_section,\n+\t  objc2_constant_string_object_section\n+\t} ;\n       size_t i;\n \n       been_here = true;\n-      for (i = 0; i < ARRAY_SIZE (tomark); i++)\n-\tswitch_to_section (darwin_sections[tomark[i]]);\n+      if (flag_objc_abi < 2)\n+\t{\n+\t  for (i = 0; i < ARRAY_SIZE (tomark); i++)\n+\t    switch_to_section (darwin_sections[tomark[i]]);\n+\t  if (flag_objc_abi == 1)\n+\t    for (i = 0; i < ARRAY_SIZE (tomarkv1); i++)\n+\t      switch_to_section (darwin_sections[tomarkv1[i]]);\n+\t}\n+      else\n+\tfor (i = 0; i < ARRAY_SIZE (tomarkv2); i++)\n+\t  switch_to_section (darwin_sections[tomarkv2[i]]);\n+      /* Make sure we don't get varasm.c out of sync with us.  */\n       switch_to_section (saved_in_section);\n     }\n   output_section_asm_op (directive);\n@@ -277,7 +312,6 @@ indirect_data (rtx sym_ref)\n   return ! lprefix;\n }\n \n-\n static int\n machopic_data_defined_p (rtx sym_ref)\n {\n@@ -1233,6 +1267,177 @@ machopic_reloc_rw_mask (void)\n   return MACHOPIC_INDIRECT ? 3 : 0;\n }\n \n+/* We have to deal with ObjC/C++ metadata section placement in the common\n+   code, since it will also be called from LTO.\n+   \n+   Return metadata attributes, if present (searching for ABI=2 first)\n+   Return NULL_TREE if no such attributes are found.  */\n+\n+static tree\n+is_objc_metadata (tree decl)\n+{\n+  if (DECL_P (decl) \n+      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL)\n+      && DECL_ATTRIBUTES (decl))\n+    {\n+      tree meta = lookup_attribute (\"OBJC2META\", DECL_ATTRIBUTES (decl));\n+      if (meta)\n+\treturn meta;\n+      meta = lookup_attribute (\"OBJC1META\", DECL_ATTRIBUTES (decl));\n+      if (meta)\n+\treturn meta;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Return the section required for Objective C ABI 2 metadata.  */\n+static section *\n+darwin_objc2_section (tree decl ATTRIBUTE_UNUSED, tree meta, section * base)\n+{\n+  const char *p;\n+  tree ident = TREE_VALUE (meta);\n+  gcc_assert (TREE_CODE (ident) == IDENTIFIER_NODE);\n+  p = IDENTIFIER_POINTER (ident);\n+\n+  /* If we are in LTO, then we don't know the state of flag_next_runtime\n+     or flag_objc_abi when the code was generated.  We set these from the\n+     meta-data - which is needed to deal with const string constructors.  */\n+\n+  flag_next_runtime = 1;\n+  flag_objc_abi = 2;\n+\n+  if (base == data_section)\n+    base = darwin_sections[objc2_metadata_section];\n+\n+  /* Most of the OBJC2 META-data end up in the base section, so check it\n+     first.  */\n+  if      (!strncmp (p, \"V2_BASE\", 7))\n+    return base;\n+  else if (!strncmp (p, \"V2_STRG\", 7))\n+    return darwin_sections[cstring_section];\n+\n+  else if (!strncmp (p, \"G2_META\", 7) || !strncmp (p, \"G2_CLAS\", 7))\n+    return darwin_sections[objc2_classdefs_section];\n+  else if (!strncmp (p, \"V2_MREF\", 7))\n+    return darwin_sections[objc2_message_refs_section];\n+  else if (!strncmp (p, \"V2_CLRF\", 7))\n+    return darwin_sections[objc2_classrefs_section];\n+  else if (!strncmp (p, \"V2_SURF\", 7))\n+    return darwin_sections[objc2_super_classrefs_section];\n+  else if (!strncmp (p, \"V2_NLCL\", 7))\n+    return darwin_sections[objc2_nonlazy_class_section];\n+  else if (!strncmp (p, \"V2_CLAB\", 7))\n+    return darwin_sections[objc2_classlist_section];\n+  else if (!strncmp (p, \"V2_SRFS\", 7))\n+    return darwin_sections[objc2_selector_refs_section];\n+  else if (!strncmp (p, \"V2_NLCA\", 7))\n+    return darwin_sections[objc2_nonlazy_category_section];\n+  else if (!strncmp (p, \"V2_CALA\", 7))\n+    return darwin_sections[objc2_categorylist_section];\n+\n+  else if (!strncmp (p, \"V2_PLST\", 7))\n+    return darwin_sections[objc2_protocollist_section];\n+  else if (!strncmp (p, \"V2_PRFS\", 7))\n+    return darwin_sections[objc2_protocolrefs_section];\n+\n+  else if (!strncmp (p, \"V2_INFO\", 7))\n+    return darwin_sections[objc2_image_info_section];\n+\n+  else if (!strncmp (p, \"V2_EHTY\", 7))\n+    return darwin_sections[data_coal_section];\n+\n+  else if (!strncmp (p, \"V2_CSTR\", 7))\n+    return darwin_sections[objc2_constant_string_object_section];\n+\n+  /* Not recognized, default.  */\n+  return base;\n+}\n+\n+/* Return the section required for Objective C ABI 0/1 metadata.  */\n+static section *\n+darwin_objc1_section (tree decl ATTRIBUTE_UNUSED, tree meta, section * base)\n+{\n+  const char *p;\n+  tree ident = TREE_VALUE (meta);\n+  gcc_assert (TREE_CODE (ident) == IDENTIFIER_NODE);\n+  p = IDENTIFIER_POINTER (ident);\n+\n+  /* If we are in LTO, then we don't know the state of flag_next_runtime\n+     or flag_objc_abi when the code was generated.  We set these from the\n+     meta-data - which is needed to deal with const string constructors.  */\n+  flag_next_runtime = 1;\n+  if (!global_options_set.x_flag_objc_abi)\n+    flag_objc_abi = 1;\n+\n+  /* String sections first, cos there are lots of strings.  */\n+  if      (!strncmp (p, \"V1_STRG\", 7))\n+    return darwin_sections[cstring_section];\n+  else if (!strncmp (p, \"V1_CLSN\", 7))\n+    return darwin_sections[objc_class_names_section];\n+  else if (!strncmp (p, \"V1_METN\", 7))\n+    return darwin_sections[objc_meth_var_names_section];\n+  else if (!strncmp (p, \"V1_METT\", 7))\n+    return darwin_sections[objc_meth_var_types_section];\n+\n+  else if (!strncmp (p, \"V1_CLAS\", 7))\n+    return darwin_sections[objc_class_section];\n+  else if (!strncmp (p, \"V1_META\", 7))\n+    return darwin_sections[objc_meta_class_section];\n+  else if (!strncmp (p, \"V1_CATG\", 7))\n+    return darwin_sections[objc_category_section];\n+  else if (!strncmp (p, \"V1_PROT\", 7))\n+    return darwin_sections[objc_protocol_section];\n+\n+  else if (!strncmp (p, \"V1_CLCV\", 7))\n+    return darwin_sections[objc_class_vars_section];\n+  else if (!strncmp (p, \"V1_CLIV\", 7))\n+    return darwin_sections[objc_instance_vars_section];\n+\n+  else if (!strncmp (p, \"V1_CLCM\", 7))\n+    return darwin_sections[objc_cls_meth_section];\n+  else if (!strncmp (p, \"V1_CLIM\", 7))\n+    return darwin_sections[objc_inst_meth_section];\n+  else if (!strncmp (p, \"V1_CACM\", 7))\n+    return darwin_sections[objc_cat_cls_meth_section];\n+  else if (!strncmp (p, \"V1_CAIM\", 7))\n+    return darwin_sections[objc_cat_inst_meth_section];\n+  else if (!strncmp (p, \"V1_PNSM\", 7))\n+    return darwin_sections[objc_cat_inst_meth_section];\n+  else if (!strncmp (p, \"V1_PCLM\", 7))\n+    return darwin_sections[objc_cat_cls_meth_section];\n+\n+  else if (!strncmp (p, \"V1_CLPR\", 7))\n+    return darwin_sections[objc_cat_cls_meth_section];\n+  else if (!strncmp (p, \"V1_CAPR\", 7))\n+    return darwin_sections[objc_category_section]; /* ??? CHECK me.  */\n+\n+  else if (!strncmp (p, \"V1_PRFS\", 7))\n+    return darwin_sections[objc_cat_cls_meth_section];\n+  else if (!strncmp (p, \"V1_CLRF\", 7))\n+    return darwin_sections[objc_cls_refs_section];\n+  else if (!strncmp (p, \"V1_SRFS\", 7))\n+    return darwin_sections[objc_selector_refs_section];\n+\n+  else if (!strncmp (p, \"V1_MODU\", 7))\n+    return darwin_sections[objc_module_info_section];\n+  else if (!strncmp (p, \"V1_SYMT\", 7))\n+    return darwin_sections[objc_symbols_section];\n+  else if (!strncmp (p, \"V1_INFO\", 7))\n+    return darwin_sections[objc_image_info_section];\n+\n+  else if (!strncmp (p, \"V1_PLST\", 7))\n+    return darwin_sections[objc1_prop_list_section];\n+  else if (!strncmp (p, \"V1_PEXT\", 7))\n+    return darwin_sections[objc1_protocol_ext_section];\n+  else if (!strncmp (p, \"V1_CEXT\", 7))\n+    return darwin_sections[objc1_class_ext_section];\n+\n+  else if (!strncmp (p, \"V2_CSTR\", 7))\n+    return darwin_sections[objc_constant_string_object_section];\n+\n+  return base;\n+}\n+\n section *\n machopic_select_section (tree decl,\n \t\t\t int reloc,\n@@ -1331,7 +1536,25 @@ machopic_select_section (tree decl,\n       gcc_unreachable ();\n     }\n \n-  /* Darwin weird special cases.  */\n+  /* Darwin weird special cases.  \n+     a) OBJC Meta-data. */\n+  if (DECL_P (decl) \n+      && (TREE_CODE (decl) == VAR_DECL \n+\t  || TREE_CODE (decl) == CONST_DECL)\n+      && DECL_ATTRIBUTES (decl))\n+    {\n+      tree meta = lookup_attribute (\"OBJC2META\", DECL_ATTRIBUTES (decl));\n+      if (meta)\n+\treturn darwin_objc2_section (decl, meta, base_section);\n+      meta = lookup_attribute (\"OBJC1META\", DECL_ATTRIBUTES (decl));\n+      if (meta)\n+\treturn darwin_objc1_section (decl, meta, base_section);\n+      meta = lookup_attribute (\"OBJC1METG\", DECL_ATTRIBUTES (decl));\n+      if (meta)\n+\treturn base_section; /* GNU runtime is happy with it all in one pot.  */\n+    }\n+\n+  /* b) Constant string objects.  */\n   if (TREE_CODE (decl) == CONSTRUCTOR\n       && TREE_TYPE (decl)\n       && TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n@@ -1341,29 +1564,53 @@ machopic_select_section (tree decl,\n       if (TREE_CODE (name) == TYPE_DECL)\n         name = DECL_NAME (name);\n \n+      /* FIXME: This is unsatisfactory for LTO, since it relies on other\n+\t metadata determining the source FE.  */\n       if (!strcmp (IDENTIFIER_POINTER (name), \"__builtin_ObjCString\"))\n-        {\n-          if (flag_next_runtime)\n-            return darwin_sections[objc_constant_string_object_section];\n-          else\n-            return darwin_sections[objc_string_object_section];\n-        }\n+\t{\n+\t  if (flag_next_runtime)\n+\t    {\n+\t      if (flag_objc_abi == 2)\n+\t\treturn darwin_sections[objc2_constant_string_object_section];\n+\t      else\n+\t\treturn darwin_sections[objc_constant_string_object_section];\n+\t    }\n+\t  else\n+\t    return darwin_sections[objc_string_object_section];\n+\t}\n       else if (!strcmp (IDENTIFIER_POINTER (name), \"__builtin_CFString\"))\n \treturn darwin_sections[cfstring_constant_object_section];\n       else\n-        return base_section;\n+\treturn base_section;\n     }\n+  /* c) legacy meta-data selection.  */\n   else if (TREE_CODE (decl) == VAR_DECL\n \t   && DECL_NAME (decl)\n \t   && TREE_CODE (DECL_NAME (decl)) == IDENTIFIER_NODE\n \t   && IDENTIFIER_POINTER (DECL_NAME (decl))\n+\t   && flag_next_runtime\n \t   && !strncmp (IDENTIFIER_POINTER (DECL_NAME (decl)), \"_OBJC_\", 6))\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-\n+      static bool warned_objc_46 = false;\n       /* We shall assert that zero-sized objects are an error in ObjC \n          meta-data.  */\n       gcc_assert (tree_low_cst (DECL_SIZE_UNIT (decl), 1) != 0);\n+      \n+      /* ??? This mechanism for determining the metadata section is\n+\t broken when LTO is in use, since the frontend that generated\n+\t the data is not identified.  We will keep the capability for\n+\t the short term - in case any non-Objective-C programs are using\n+\t it to place data in specified sections.  */\n+      if (!warned_objc_46)\n+\t{\n+\t  location_t loc = DECL_SOURCE_LOCATION (decl);\n+\t  warning_at (loc, 0, \"the use of _OBJC_-prefixed variable names\"\n+\t\t      \" to select meta-data sections is deprecated at 4.6\"\n+\t\t      \" and will be removed in 4.7\");\n+\t  warned_objc_46 = true;\n+\t}\n+      \n       if (!strncmp (name, \"_OBJC_CLASS_METHODS_\", 20))\n         return darwin_sections[objc_cls_meth_section];\n       else if (!strncmp (name, \"_OBJC_INSTANCE_METHODS_\", 23))\n@@ -1911,6 +2158,30 @@ darwin_emit_weak_or_comdat (FILE *fp, tree decl, const char *name,\n     assemble_zeros (size);\n }\n \n+/* Emit a chunk of data for ObjC meta-data that got placed in BSS erroneously.  */\n+static void\n+darwin_emit_objc_zeroed (FILE *fp, tree decl, const char *name,\n+\t\t\t\t  unsigned HOST_WIDE_INT size, \n+\t\t\t\t  unsigned int align, tree meta)\n+{\n+  section *ocs = data_section;\n+\n+  if (TREE_PURPOSE (meta) == get_identifier(\"OBJC2META\"))\n+    ocs = darwin_objc2_section (decl, meta, ocs);\n+  else\n+    ocs = darwin_objc1_section (decl, meta, ocs);\n+\n+  switch_to_section (ocs);\n+\n+  /* We shall declare that zero-sized meta-data are not valid (yet).  */\n+  gcc_assert (size);\n+  fprintf (fp, \"\\t.align\\t%d\\n\", floor_log2 (align / BITS_PER_UNIT));\n+\n+  /* ... and we let it deal with outputting one byte of zero for them too.  */ \n+  darwin_asm_declare_object_name (fp, name, decl);\n+  assemble_zeros (size);\n+}\n+\n /* This routine emits 'local' storage:\n \n    When Section Anchors are off this routine emits .zerofill commands in \n@@ -2042,6 +2313,7 @@ darwin_output_aligned_bss (FILE *fp, tree decl, const char *name,\n {\n   unsigned int l2align;\n   bool one, pub, weak;\n+  tree meta;\n \n   pub = TREE_PUBLIC (decl);\n   one = DECL_ONE_ONLY (decl);\n@@ -2058,6 +2330,14 @@ fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n \tpub, weak, one, (unsigned long)DECL_INITIAL (decl)); \n #endif\n \n+  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS \n+     before the target has a chance to comment.  */\n+  if ((meta = is_objc_metadata (decl)))\n+    {\n+      darwin_emit_objc_zeroed (fp, decl, name, size, DECL_ALIGN (decl), meta);\n+      return;\n+    }\n+\n   /* Check that any initializer is valid.  */\n   gcc_assert ((DECL_INITIAL (decl) == NULL) \n \t       || (DECL_INITIAL (decl) == error_mark_node) \n@@ -2152,6 +2432,8 @@ darwin_asm_output_aligned_decl_common (FILE *fp, tree decl, const char *name,\n {\n   unsigned int l2align;\n   bool one, weak;\n+  tree meta;\n+\n   /* No corresponding var.  */\n   if (decl==NULL)\n     {\n@@ -2176,6 +2458,14 @@ fprintf (fp, \"# adcom: %s (%lld,%d) ro %d cst %d stat %d com %d pub %d\"\n \tTREE_PUBLIC (decl), weak, one, (unsigned long)DECL_INITIAL (decl)); \n #endif\n \n+  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS \n+     before the target has a chance to comment.  */\n+  if ((meta = is_objc_metadata (decl)))\n+    {\n+      darwin_emit_objc_zeroed (fp, decl, name, size, DECL_ALIGN (decl), meta);\n+      return;\n+    }\n+\n   /* We shouldn't be messing with this if the decl has a section name.  */\n   gcc_assert (DECL_SECTION_NAME (decl) == NULL);\n \n@@ -2222,6 +2512,7 @@ darwin_asm_output_aligned_decl_local (FILE *fp, tree decl, const char *name,\n {\n   unsigned long l2align;\n   bool one, weak;\n+  tree meta;\n \n   one = DECL_ONE_ONLY (decl);\n   weak = (DECL_P (decl)\n@@ -2237,6 +2528,14 @@ fprintf (fp, \"# adloc: %s (%lld,%d) ro %d cst %d stat %d one %d pub %d\"\n \tweak , (unsigned long)DECL_INITIAL (decl)); \n #endif\n \n+  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS \n+     before the target has a chance to comment.  */\n+  if ((meta = is_objc_metadata (decl)))\n+    {\n+      darwin_emit_objc_zeroed (fp, decl, name, size, DECL_ALIGN (decl), meta);\n+      return;\n+    }\n+\n   /* We shouldn't be messing with this if the decl has a section name.  */\n   gcc_assert (DECL_SECTION_NAME (decl) == NULL);\n "}, {"sha": "0526d851fc3887be5312bac2802b2569dd05ee52", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -140,6 +140,16 @@ extern GTY(()) int darwin_ms_struct;\n   } while (0)\n \n #define SUBTARGET_C_COMMON_OVERRIDE_OPTIONS do {                        \\\n+  /* Unless set, force ABI=2 for NeXT and m64, 0 otherwise.  */\t\t\\\n+  if (!global_options_set.x_flag_objc_abi)\t\t\t\t\\\n+    global_options.x_flag_objc_abi\t\t\t\t\t\\\n+\t= (flag_next_runtime && TARGET_64BIT) ? 2 : 0;\t\t\t\\\n+  /* Objective-C family ABI 2 is only valid for next/m64 at present. */\t\\\n+  if (global_options_set.x_flag_objc_abi && flag_next_runtime)\t\t\\\n+    if (TARGET_64BIT && global_options.x_flag_objc_abi < 2)\t\t\\\n+      error_at (UNKNOWN_LOCATION, \"%<-fobjc-abi-version%> >= 2 is only\"\t\\\n+\t\t\" supported on %<-m64%> targets for\"\t\t\t\\\n+\t\t\" %<-fnext-runtime%>\");\t\t\t\t\t\\\n   /* Sort out ObjC exceptions: If the runtime is NeXT we default to\t\\\n      sjlj for m32 only.  */\t\t\t\t\t\t\\\n   if (!global_options_set.x_flag_objc_sjlj_exceptions)\t\t\t\\\n@@ -599,7 +609,7 @@ int darwin_label_is_anonymous_local_objc_name (const char *name);\n \t }\t\t\t\t\t\t\t\t     \\\n        else if (xname[0] == '+' || xname[0] == '-')\t\t\t     \\\n          fprintf (FILE, \"\\\"%s\\\"\", xname);\t\t\t\t     \\\n-       else if (darwin_label_is_anonymous_local_objc_name (xname))\t\t\t\t     \\\n+       else if (darwin_label_is_anonymous_local_objc_name (xname))\t     \\\n          fprintf (FILE, \"L%s\", xname);\t\t\t\t\t     \\\n        else if (!strncmp (xname, \".objc_class_name_\", 17))\t\t     \\\n \t fprintf (FILE, \"%s\", xname);\t\t\t\t\t     \\"}, {"sha": "926352e51c9acdd0e7c4cdc9ececd6fe5a4e577b", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,3 +1,106 @@\n+2011-02-17  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* config-lang.in (gtfiles): Updated.\n+\t* Make-lang.in (START_HDRS): New.\n+\t(OBJC_OBJS): Added new object files.\n+\t(objc/objc-act.o): Updated prerequisites.\n+\t(objc/objc-lang.o): Updated prerequisites.\n+\t(objc/objc-runtime-shared-support.o): New.\n+\t(objc/objc-gnu-runtime-abi-01.o): New.\n+\t(objc/objc-next-runtime-abi-01.o): New.\n+\t(objc/objc-next-runtime-abi-02.o): New.\n+\t* objc-runtime-hooks.h: New.\n+\t* objc-runtime-shared-support.h: New.\n+\t* objc-runtime-shared-support.c: New.\n+\t* objc-gnu-runtime-abi-01.c: New.\n+\t* objc-next-metadata-tags.h: New.\n+\t* objc-next-runtime-abi-01.c: New.\n+\t* objc-next-runtime-abi-02.c: New.\n+\t* objc-lang.c: Include c-lang.h.\n+\t(LANG_HOOKS_EH_PERSONALITY): Removed.\n+\t* objc-act.h: Moved many declarations and code from objc-act.c\n+\tinto objc-act.h to make them available outside objc-act.c.\n+\t(objc_eh_runtime_type): Removed.\n+\t(objc_eh_personality): Removed.\n+\t(CLASS_HAS_EXCEPTION_ATTR): New.\n+\t(OCTI_SUPER_SUPERFIELD_ID): New.\n+\t(OCTI_V1_PROP_LIST_TEMPL): New.\n+\t(OCTI_V1_PROP_NAME_ATTR_CHAIN): New.\n+\t(super_superclassfield_id): New.\n+\t(objc_prop_list_ptr): New.\n+\t(prop_names_attr_chain): New.\n+\t* objc-act.c: Include new runtime headers.  Moved many #defines\n+\tand declarations into objc-act.h and\n+\tobjc-runtime-shared-support.h.  Made some corresponding functions\n+\tnon-static, and moved some others into\n+\tobjc-runtime-shared-support.c.  Moved metadata generation code\n+\tinto the new runtime hook files.\n+\t(ivar_offset_hash_list): New.\n+\t(objc_init): Call generate_struct_value_by_array() before doing\n+\tany runtime initialization.  Create the appropriate runtime hook\n+\tstructures.\n+\t(init_objc): Removed.  Code moved directly into objc_init.\n+\t(finish_objc): Removed.  Code moved directly into\n+\tobjc_write_global_declarations.\n+\t(objc_write_global_declarations): Do the warn_selector checks\n+\tbefore emitting metadata.  Use a runtime hook to emit the\n+\tmetadata.  Do not emit the metadata or do -gen-decls processing if\n+\t-fsyntax-only or we are producing a PCH.\n+\t(build_objc_exception_stuff): Renamed to\n+\tbuild_common_objc_exception_stuff.  Remove TREE_NOTHROW flag from\n+\tobjc_exception_throw_decl.\n+\t(synth_module_prologue): Call runtime initialize hook instead of\n+\tbuilding runtime declarations here.  Use the\n+\tdefault_constant_string_class_name runtime hook to set the\n+\tconstant string class name.\n+\t(objc_build_string_object): Call the setup_const_string_class_decl\n+\truntime hook instead of setup_string_decl.  Call the\n+\tbuild_const_string_constructor runtime hook instead of building\n+\tthe string object here.\n+\t(get_objc_string_decl): Added prop_names_attr case.  Removed\n+\tgcc_unreachable() at the end.\n+\t(objc_begin_catch_clause): Distinguish between @catch (...) and\n+\t@catch (id x).  Call the begin_catch runtime hook instead of\n+\tbuilding the CATCH_EXPR here.\n+\t(objc_finish_catch_clause): Call the finish_catch runtime hook\n+\tinstead of adding the catch here.\n+\t(objc_finish_try_stmt): Call the finish_try_stmt runtime hook\n+\tinstead of doing it here.\n+\t(objc_build_throw_stmt): Bail out early for error_mark_node.  Call\n+\tthe build_exc_ptr runtime hook instead of objc_build_exc_ptr.\n+\tCall the build_throw_stmt runtime hook instead of building the\n+\tthrow call here.\n+\t(objc_generate_cxx_cdtors): Set has_cxx_cdtors for the GNU runtime\n+\tas well.\n+\t(get_arg_type_list): Call the get_arg_type_list_base runtime hook\n+\tinstead of building the list of arguments here.\n+\t(receiver_is_class_object): Call the receiver_is_class_object\n+\truntime hook instead of doing the check here.  Call the\n+\ttag_getclass runtime hook instead of using TAG_GETCLASS.\n+\t(objc_finish_message_expr): Call the build_objc_method_call\n+\truntime hook.\n+\t(objc_build_protocol_expr): Call the get_protocol_reference\n+\truntime hook.\n+\t(objc_build_selector_expr): Call the build_selector_reference\n+\truntime hook.\n+\t(build_ivar_reference): Call the build_ivar_reference runtime\n+\thook.\n+\t(hash_init): Set up ivar_offset_hash_list.\n+\t(start_class): Recognize the objc_exception attribute and store\n+\tit.\n+\t(continue_class): Use the class_decl and metaclass_decl runtime\n+\thooks.\n+\t(build_objc_property_accessor_helpers): Renamed to\n+\tbuild_common_objc_property_accessor_helpers.  Do not build\n+\tobjc_copyStruct_decl, objc_getPropertyStruct_decl and\n+\tobjc_setPropertyStruct_decl.\n+\t(objc_synthesize_getter): Check what struct setter/getter helper\n+\tis available instead of checking the type of runtime.\n+\t(get_super_receiver): Use the super_superclassfield_ident runtime\n+\thook.  Added assert.  Use the get_class_super_ref and\n+\tget_category_super_ref runtime hooks.\n+\t(objc_v2_encode_prop_attr): New.\n+\t\n 2011-01-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR objc/47314"}, {"sha": "6f48aba600f3155673c47d9ff84f7934fb497a58", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,6 +1,6 @@\n # Top level -*- makefile -*- fragment for GNU Objective-C\n #   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2007,\n-#   2008, 2009, 2010 Free Software Foundation, Inc.\n+#   2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -43,11 +43,18 @@ objc: cc1obj$(exeext)\n # Tell GNU make to ignore these if they exist.\n .PHONY: objc\n \n+START_HDRS = $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n+  c-lang.h langhooks.h c-family/c-objc.h objc/objc-act.h\n+\n # Use maximal warnings for this front end.\n objc-warn = $(STRICT_WARN)\n \n # Language-specific object files for Objective C.\n-OBJC_OBJS = objc/objc-lang.o objc/objc-act.o\n+OBJC_OBJS = objc/objc-lang.o objc/objc-act.o \\\n+   objc/objc-runtime-shared-support.o \\\n+   objc/objc-gnu-runtime-abi-01.o \\\n+   objc/objc-next-runtime-abi-01.o \\\n+   objc/objc-next-runtime-abi-02.o \\\n \n objc_OBJS = $(OBJC_OBJS) cc1obj-checksum.o\n \n@@ -66,17 +73,32 @@ cc1obj$(exeext): $(OBJC_OBJS) $(C_AND_OBJC_OBJS) cc1obj-checksum.o $(BACKEND) $(\n \n # Objective C language specific files.\n \n-objc/objc-lang.o : objc/objc-lang.c \\\n-   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n-   $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-objc.h \\\n-   c-objc-common.h c-family/c-objc.h objc/objc-act.h\n-\n-objc/objc-act.o : objc/objc-act.c \\\n-   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(TARGET_H) $(C_TREE_H) $(DIAGNOSTIC_CORE_H) toplev.h $(FLAGS_H) \\\n-   objc/objc-act.h input.h $(FUNCTION_H) output.h debug.h langhooks.h \\\n-   $(LANGHOOKS_DEF_H) $(HASHTAB_H) $(C_PRAGMA_H) gt-objc-objc-act.h \\\n-   $(GIMPLE_H) c-lang.h c-family/c-objc.h\n+objc/objc-lang.o : objc/objc-lang.c $(START_HDRS) \\\n+   $(GGC_H) $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-objc.h \\\n+   c-objc-common.h\n+\n+objc/objc-runtime-shared-support.o : objc/objc-runtime-shared-support.c \\\n+   $(START_HDRS) objc/objc-runtime-shared-support.h $(OBSTACK_H) \\\n+   objc/objc-next-metadata-tags.h gt-objc-objc-runtime-shared-support.h\n+\n+objc/objc-gnu-runtime-abi-01.o: objc/objc-gnu-runtime-abi-01.c $(START_HDRS) \\\n+   objc/objc-runtime-hooks.h $(GGC_H) \\\n+   objc/objc-runtime-shared-support.h gt-objc-objc-gnu-runtime-abi-01.h toplev.h\n+\n+objc/objc-next-runtime-abi-01.o: objc/objc-next-runtime-abi-01.c $(START_HDRS) \\\n+   $(GGC_H) objc/objc-runtime-hooks.h \\\n+   objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-01.h output.h \\\n+   objc/objc-runtime-shared-support.h $(TARGET_H)\n+\n+objc/objc-next-runtime-abi-02.o: objc/objc-next-runtime-abi-02.c $(START_HDRS) \\\n+   $(GGC_H) objc/objc-runtime-hooks.h \\\n+   objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-02.h $(TARGET_H) \\\n+   objc/objc-runtime-shared-support.h $(OBSTACK_H) \n+\n+objc/objc-act.o : objc/objc-act.c $(START_HDRS) $(GGC_H) \\\n+   $(DIAGNOSTIC_CORE_H) toplev.h $(FLAGS_H) input.h $(FUNCTION_H) output.h debug.h \\\n+   $(LANGHOOKS_DEF_H) $(HASHTAB_H) $(C_PRAGMA_H) gt-objc-objc-act.h $(OBSTACK_H) \\\n+   $(GIMPLE_H) objc/objc-runtime-shared-support.h objc/objc-runtime-hooks.h\n \n objc.srcextra:\n "}, {"sha": "db5c5a59ec583a880bd3267918e6f6b5ba952050", "filename": "gcc/objc/config-lang.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fconfig-lang.in?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,6 +1,6 @@\n # Top level configure fragment for GNU Objective-C\n-#   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2010\n-#   Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2010,\n+#   2011 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -33,4 +33,4 @@ target_libs=target-libobjc\n # Most of the object files for cc1obj actually come from C.\n lang_requires=\"c\"\n \n-gtfiles=\"\\$(srcdir)/objc/objc-act.h \\$(srcdir)/c-parser.c \\$(srcdir)/c-tree.h \\$(srcdir)/c-decl.c \\$(srcdir)/c-objc-common.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/objc/objc-act.c\"\n+gtfiles=\"\\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/c-parser.c \\$(srcdir)/c-tree.h \\$(srcdir)/c-decl.c \\$(srcdir)/c-lang.h \\$(srcdir)/c-objc-common.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c\""}, {"sha": "d73f2c07b6f28874a74000efe54ed6e733cf99ba", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 6105, "deletions": 9636, "changes": 15741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e"}, {"sha": "f45b4eab80c4b887e8f3186b118d736c91e42934", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 185, "deletions": 13, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,6 +1,6 @@\n /* Declarations for objc-act.c.\n    Copyright (C) 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009,\n-   2010 Free Software Foundation, Inc.\n+   2010, 2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -28,8 +28,6 @@ bool objc_init (void);\n const char *objc_printable_name (tree, int);\n tree objc_fold_obj_type_ref (tree, tree);\n int objc_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n-tree objc_eh_runtime_type (tree);\n-tree objc_eh_personality (void);\n \n /* NB: The remaining public functions are prototyped in c-common.h, for the\n    benefit of stub-objc.c and objc-act.c.  */\n@@ -167,6 +165,8 @@ typedef enum objc_property_assign_semantics {\n #define CLASS_PROTOCOL_LIST(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 4)\n #define TOTAL_CLASS_RAW_IVARS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 5)\n \n+#define CLASS_HAS_EXCEPTION_ATTR(CLASS) ((CLASS)->type.lang_flag_0)\n+\n #define PROTOCOL_NAME(CLASS) ((CLASS)->type.name)\n #define PROTOCOL_LIST(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 0)\n #define PROTOCOL_NST_METHODS(CLASS) ((CLASS)->type.minval)\n@@ -176,7 +176,6 @@ typedef enum objc_property_assign_semantics {\n #define PROTOCOL_OPTIONAL_CLS_METHODS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 2)\n #define PROTOCOL_OPTIONAL_NST_METHODS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 3)\n \n-\n /* For CATEGORY_INTERFACE_TYPE, CLASS_INTERFACE_TYPE or PROTOCOL_INTERFACE_TYPE */\n #define CLASS_PROPERTY_DECL(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 6)\n /* For CLASS_IMPLEMENTATION_TYPE or CATEGORY_IMPLEMENTATION_TYPE. */\n@@ -215,6 +214,7 @@ typedef enum objc_property_assign_semantics {\n \t\t= make_tree_vec (OBJC_INFO_SLOT_ELTS);\t\t\\\n \t  }\t\t\t\t\t\t\t\\\n \twhile (0)\n+\n #define DUP_TYPE_OBJC_INFO(DST, SRC)\t\t\t\t\\\n \tdo\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n@@ -244,20 +244,21 @@ struct GTY(()) hashed_attribute {\n   attr next;\n   tree value;\n };\n+\n struct GTY(()) hashed_entry {\n   attr list;\n   hash next;\n   tree key;\n };\n \n+#define SIZEHASHTABLE\t\t257\n+\n extern GTY ((length (\"SIZEHASHTABLE\"))) hash *nst_method_hash_list;\n extern GTY ((length (\"SIZEHASHTABLE\"))) hash *cls_method_hash_list;\n \n extern GTY ((length (\"SIZEHASHTABLE\"))) hash *cls_name_hash_list;\n extern GTY ((length (\"SIZEHASHTABLE\"))) hash *als_name_hash_list;\n \n-#define SIZEHASHTABLE\t\t257\n-\n /* An array of all the local variables in the current function that\n    need to be marked as volatile.  */\n extern GTY(()) VEC(tree,gc) *local_variables_to_volatilize;\n@@ -268,8 +269,8 @@ struct GTY(()) imp_entry {\n   struct imp_entry *next;\n   tree imp_context;\n   tree imp_template;\n-  tree class_decl;\t\t/* _OBJC_CLASS_<my_name>; */\n-  tree meta_decl;\t\t/* _OBJC_METACLASS_<my_name>; */\n+  tree class_decl;\t\t/* _OBJC[_v2]_CLASS/CATEGORY_<my_name>; */\n+  tree meta_decl;\t\t/* _OBJC[_v2]_METACLASS_<my_name>; */\n   BOOL_BITFIELD has_cxx_cdtors : 1;\n };\n \n@@ -361,6 +362,7 @@ enum objc_tree_index\n     OCTI_STRING_CLASS_DECL,\n     OCTI_INTERNAL_CNST_STR_TYPE,\n     OCTI_SUPER_DECL,\n+    OCTI_SUPER_SUPERFIELD_ID,\n     OCTI_UMSG_NONNIL_DECL,\n     OCTI_UMSG_NONNIL_STRET_DECL,\n     OCTI_STORAGE_CLS,\n@@ -394,6 +396,10 @@ enum objc_tree_index\n     OCTI_GET_PROPERTY_STRUCT_DECL,\n     OCTI_SET_PROPERTY_STRUCT_DECL,\n \n+    /* \"V1\" stuff.  */\n+    OCTI_V1_PROP_LIST_TEMPL,\n+    OCTI_V1_PROP_NAME_ATTR_CHAIN,\n+\n     OCTI_MAX\n };\n \n@@ -433,14 +439,17 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n \t(TREE_CODE (TYPE) == POINTER_TYPE\t\t\t\t\\\n \t && (TYPE_MAIN_VARIANT (TREE_TYPE (TYPE))\t\t\t\\\n \t     == TREE_TYPE (objc_object_type)))\n+\n #define IS_CLASS(TYPE)\t\t\t\t\t\t\t\\\n \t(TREE_CODE (TYPE) == POINTER_TYPE\t\t\t\t\\\n \t && (TYPE_MAIN_VARIANT (TREE_TYPE (TYPE))\t\t\t\\\n \t     == TREE_TYPE (objc_class_type)))\n+\n #define IS_PROTOCOL_QUALIFIED_UNTYPED(TYPE)\t\t\t\t\\\n \t((IS_ID (TYPE) || IS_CLASS (TYPE))\t\t\t\t\\\n \t && TYPE_HAS_OBJC_INFO (TREE_TYPE (TYPE))\t\t\t\\\n \t && TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (TYPE)))\n+\n #define IS_SUPER(TYPE)\t\t\t\t\t\t\t\\\n \t(TREE_CODE (TYPE) == POINTER_TYPE\t\t\t\t\\\n \t && TREE_TYPE (TYPE) == objc_super_template)\n@@ -549,25 +558,188 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n #define objc_class_id\t\tobjc_global_trees[OCTI_CLS_ID]\n #define objc_object_name\t\tobjc_global_trees[OCTI_ID_NAME]\n #define objc_class_name\t\tobjc_global_trees[OCTI_CLASS_NAME]\n+\n+/* Constant string classes.  */\n #define constant_string_id\tobjc_global_trees[OCTI_CNST_STR_ID]\n #define constant_string_type\tobjc_global_trees[OCTI_CNST_STR_TYPE]\n #define constant_string_global_id\t\t\\\n \t\t\t\tobjc_global_trees[OCTI_CNST_STR_GLOB_ID]\n #define string_class_decl\tobjc_global_trees[OCTI_STRING_CLASS_DECL]\n #define internal_const_str_type\tobjc_global_trees[OCTI_INTERNAL_CNST_STR_TYPE]\n+\n #define UOBJC_SUPER_decl\tobjc_global_trees[OCTI_SUPER_DECL]\n+#define super_superclassfield_id \\\n+\t\t\t\tobjc_global_trees[OCTI_SUPER_SUPERFIELD_ID]\n+\n #define objc_fast_enumeration_state_template\t\\\n                                 objc_global_trees[OCTI_FAST_ENUM_STATE_TEMP]\n #define objc_enumeration_mutation_decl\t\t\\\n                                 objc_global_trees[OCTI_ENUM_MUTATION_DECL]\n \n /* Declarations of functions used when synthesizing property\n    accessors.  */\n-#define objc_getProperty_decl       objc_global_trees[OCTI_GET_PROPERTY_DECL]\n-#define objc_setProperty_decl       objc_global_trees[OCTI_SET_PROPERTY_DECL]\n-#define objc_copyStruct_decl        objc_global_trees[OCTI_COPY_STRUCT_DECL]\n-#define objc_getPropertyStruct_decl objc_global_trees[OCTI_GET_PROPERTY_STRUCT_DECL]\n-#define objc_setPropertyStruct_decl objc_global_trees[OCTI_SET_PROPERTY_STRUCT_DECL]\n+#define objc_getProperty_decl\tobjc_global_trees[OCTI_GET_PROPERTY_DECL]\n+#define objc_setProperty_decl\tobjc_global_trees[OCTI_SET_PROPERTY_DECL]\n+#define objc_copyStruct_decl\tobjc_global_trees[OCTI_COPY_STRUCT_DECL]\n+#define objc_getPropertyStruct_decl \\\n+\t\t\t\tobjc_global_trees[OCTI_GET_PROPERTY_STRUCT_DECL]\n+#define objc_setPropertyStruct_decl \\\n+\t\t\t\tobjc_global_trees[OCTI_SET_PROPERTY_STRUCT_DECL]\n+\n+/* V1 stuff.  */\n+#define objc_prop_list_ptr\tobjc_global_trees[OCTI_V1_PROP_LIST_TEMPL]\n+#define prop_names_attr_chain\tobjc_global_trees[OCTI_V1_PROP_NAME_ATTR_CHAIN]\n+\n+/* Reserved tag definitions.  */\n+\n+#define OBJECT_TYPEDEF_NAME\t\t\"id\"\n+#define CLASS_TYPEDEF_NAME\t\t\"Class\"\n+\n+#define TAG_OBJECT\t\t\t\"objc_object\"\n+#define TAG_CLASS\t\t\t\"objc_class\"\n+#define TAG_SUPER\t\t\t\"objc_super\"\n+#define TAG_SELECTOR\t\t\t\"objc_selector\"\n+\n+#define UTAG_CLASS\t\t\t\"_objc_class\"\n+#define UTAG_IVAR\t\t\t\"_objc_ivar\"\n+#define UTAG_IVAR_LIST\t\t\t\"_objc_ivar_list\"\n+#define UTAG_METHOD\t\t\t\"_objc_method\"\n+#define UTAG_METHOD_LIST\t\t\"_objc_method_list\"\n+#define UTAG_CATEGORY\t\t\t\"_objc_category\"\n+#define UTAG_MODULE\t\t\t\"_objc_module\"\n+#define UTAG_SYMTAB\t\t\t\"_objc_symtab\"\n+#define UTAG_SUPER\t\t\t\"_objc_super\"\n+#define UTAG_SELECTOR\t\t\t\"_objc_selector\"\n+\n+#define UTAG_PROTOCOL\t\t\t\"_objc_protocol\"\n+#define UTAG_METHOD_PROTOTYPE\t\t\"_objc_method_prototype\"\n+#define UTAG_METHOD_PROTOTYPE_LIST\t\"_objc__method_prototype_list\"\n+\n+#define PROTOCOL_OBJECT_CLASS_NAME\t\"Protocol\"\n+\n+#define TAG_EXCEPTIONTHROW\t\t\"objc_exception_throw\"\n+#define TAG_SYNCENTER\t\t\t\"objc_sync_enter\"\n+#define TAG_SYNCEXIT\t\t\t\"objc_sync_exit\"\n+\n+/* Really should be NeXT private.  */\n+#define UTAG_EXCDATA\t\t\t\"_objc_exception_data\"\n+\n+#define TAG_CXX_CONSTRUCT\t\t\".cxx_construct\"\n+#define TAG_CXX_DESTRUCT\t\t\".cxx_destruct\"\n+\n+#define TAG_ENUMERATION_MUTATION        \"objc_enumerationMutation\"\n+#define TAG_FAST_ENUMERATION_STATE      \"__objcFastEnumerationState\"\n+\n+typedef enum string_section\n+{\n+  class_names,\t\t/* class, category, protocol, module names */\n+  meth_var_names,\t/* method and variable names */\n+  meth_var_types,\t/* method and variable type descriptors */\n+  prop_names_attr\t/* property names and their attributes. */\n+} string_section;\n+\n+#define METHOD_DEF\t\t\t0\n+#define METHOD_REF\t\t\t1\n+\n+/* (Decide if these can ever be validly changed.) */\n+#define OBJC_ENCODE_INLINE_DEFS \t0\n+#define OBJC_ENCODE_DONT_INLINE_DEFS\t1\n+\n+#define BUFSIZE\t\t\t\t1024\n \n+#define CLS_FACTORY\t\t\t0x0001L\n+#define CLS_META\t\t\t0x0002L\n+\n+/* Runtime metadata flags - ??? apparently unused.  */\n+\n+#define OBJC_MODIFIER_STATIC\t\t0x00000001\n+#define OBJC_MODIFIER_FINAL\t\t0x00000002\n+#define OBJC_MODIFIER_PUBLIC\t\t0x00000004\n+#define OBJC_MODIFIER_PRIVATE\t\t0x00000008\n+#define OBJC_MODIFIER_PROTECTED\t\t0x00000010\n+#define OBJC_MODIFIER_NATIVE\t\t0x00000020\n+#define OBJC_MODIFIER_SYNCHRONIZED\t0x00000040\n+#define OBJC_MODIFIER_ABSTRACT\t\t0x00000080\n+#define OBJC_MODIFIER_VOLATILE\t\t0x00000100\n+#define OBJC_MODIFIER_TRANSIENT\t\t0x00000200\n+#define OBJC_MODIFIER_NONE_SPECIFIED\t0x80000000\n+\n+#define OBJC_VOID_AT_END\t\tvoid_list_node\n+\n+/* Exception handling constructs.  We begin by having the parser do most\n+   of the work and passing us blocks.  \n+   This allows us to handle different exceptions implementations.  */\n+\n+/* Stack of open try blocks.  */\n+\n+struct objc_try_context\n+{\n+  struct objc_try_context *outer;\n+\n+  /* Statements (or statement lists) as processed by the parser.  */\n+  tree try_body;\n+  tree finally_body;\n+\n+  /* Some file position locations.  */\n+  location_t try_locus;\n+  location_t end_try_locus;\n+  location_t end_catch_locus;\n+  location_t finally_locus;\n+  location_t end_finally_locus;\n+\n+  /* A STATEMENT_LIST of CATCH_EXPRs, appropriate for sticking into op1\n+     of a TRY_CATCH_EXPR.  Even when doing Darwin setjmp.  */\n+  tree catch_list;\n+\n+  /* The CATCH_EXPR of an open @catch clause.  */\n+  tree current_catch;\n+\n+  /* The VAR_DECL holding  __builtin_eh_pointer (or equivalent).  */\n+  tree caught_decl;\n+  tree stack_decl;\n+  tree rethrow_decl;\n+};\n+\n+/*  A small number of routines used by the FE parser and the runtime code\n+   generators.  Put here as inlines for efficiency in non-lto builds rather\n+   than making them externs.  */\n+\n+extern tree objc_create_temporary_var (tree, const char *);\n+  \n+#define objc_is_object_id(TYPE) (OBJC_TYPE_NAME (TYPE) == objc_object_id)\n+#define objc_is_class_id(TYPE) (OBJC_TYPE_NAME (TYPE) == objc_class_id)\n+\n+/* Retrieve category interface CAT_NAME (if any) associated with CLASS.  */\n+static inline tree\n+lookup_category (tree klass, tree cat_name)\n+{\n+  tree category = CLASS_CATEGORY_LIST (klass);\n+\n+  while (category && CLASS_SUPER_NAME (category) != cat_name)\n+    category = CLASS_CATEGORY_LIST (category);\n+  return category;\n+}\n+\n+/* Count only the fields occurring in T.  */\n+static inline int\n+ivar_list_length (tree t)\n+{\n+  int count = 0;\n+\n+  for (; t; t = DECL_CHAIN (t))\n+    if (TREE_CODE (t) == FIELD_DECL)\n+      ++count;\n+\n+  return count;\n+}\n+\n+static inline tree\n+is_ivar (tree decl_chain, tree ident)\n+{\n+  for ( ; decl_chain; decl_chain = DECL_CHAIN (decl_chain))\n+    if (DECL_NAME (decl_chain) == ident)\n+      return decl_chain;\n+  return NULL_TREE;\n+}\n \n #endif /* GCC_OBJC_ACT_H */"}, {"sha": "a13f0158b1c47f7ce68e02ac68528004f2a06c08", "filename": "gcc/objc/objc-gnu-runtime-abi-01.c", "status": "added", "additions": 2265, "deletions": 0, "changes": 2265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -0,0 +1,2265 @@\n+/* GNU Runtime (ABI-0/1) private.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Iain Sandoe (split from objc-act.c)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+\n+#ifdef OBJCPLUS\n+#include \"cp-tree.h\"\n+#else\n+#include \"c-tree.h\"\n+#include \"c-lang.h\"\n+#endif\n+\n+#include \"langhooks.h\"\n+#include \"c-family/c-objc.h\"\n+#include \"objc-act.h\"\n+\n+/* When building Objective-C++, we are not linking against the C front-end\n+   and so need to replicate the C tree-construction functions in some way.  */\n+#ifdef OBJCPLUS\n+#define OBJCP_REMAP_FUNCTIONS\n+#include \"objcp-decl.h\"\n+#endif  /* OBJCPLUS */\n+\n+#include \"toplev.h\"\n+#include \"ggc.h\"\n+#include \"tree-iterator.h\"\n+\n+#include \"objc-runtime-hooks.h\"\n+#include \"objc-runtime-shared-support.h\"\n+\n+/* GNU runtime private definitions.  */\n+#define DEF_CONSTANT_STRING_CLASS_NAME \"NXConstantString\"\n+\n+#define TAG_GETCLASS\t\t\"objc_get_class\"\n+#define TAG_GETMETACLASS\t\"objc_get_meta_class\"\n+\n+#define TAG_MSGSEND\t\t\"objc_msg_lookup\"\n+#define TAG_MSGSENDSUPER\t\"objc_msg_lookup_super\"\n+\n+/* GNU-specific tags.  */\n+\n+#define TAG_EXECCLASS\t\t\"__objc_exec_class\"\n+#define TAG_GNUINIT\t\t\"__objc_gnu_init\"\n+\n+/* The version identifies which language generation and runtime\n+   the module (file) was compiled for, and is recorded in the\n+   module descriptor.  */\n+#define OBJC_VERSION\t\t8\n+\n+#define PROTOCOL_VERSION\t2\n+\n+/* This macro provides a method of removing ambiguity between runtimes\n+   when LTO is in use on targets supporting multiple runtimes.\n+   \n+   For example, at present, any target that includes an implementation of\n+   the NeXT runtime needs to place Objective-C meta-data into specific\n+   named sections.  This should _not_ be done for the GNU runtime, and the \n+   folowing macro is used to attach Objective-C private attributes that may\n+   be used to identify the runtime for which the meta-data are intended.  */\n+\n+#define OBJCMETA(DECL,VERS,KIND)\t\t\t\t\t\\\n+  if (VERS)\t\t\t\t\t\t\t\t\\\n+    DECL_ATTRIBUTES (DECL) = build_tree_list ((VERS), (KIND));\n+\n+#ifndef TARGET_64BIT\n+#define TARGET_64BIT 0\n+#endif\n+\n+static void gnu_runtime_01_initialize (void);\n+\n+static void build_selector_template (void);\n+\n+static tree gnu_runtime_abi_01_super_superclassfield_id (void);\n+\n+static tree gnu_runtime_abi_01_class_decl (tree);\n+static tree gnu_runtime_abi_01_metaclass_decl (tree);\n+static tree gnu_runtime_abi_01_category_decl (tree);\n+static tree gnu_runtime_abi_01_protocol_decl (tree);\n+static tree gnu_runtime_abi_01_string_decl (tree, const char *, string_section);\n+\n+static tree gnu_runtime_abi_01_get_class_reference (tree);\n+static tree gnu_runtime_abi_01_build_typed_selector_reference (location_t, tree,\n+\t\t\t\t\t\t\t\ttree);\n+static tree gnu_runtime_abi_01_get_protocol_reference (location_t, tree);\n+static tree gnu_runtime_abi_01_build_ivar_ref (location_t, tree, tree);\n+static tree gnu_runtime_abi_01_get_class_super_ref (location_t, struct imp_entry *, bool);\n+static tree gnu_runtime_abi_01_get_category_super_ref (location_t, struct imp_entry *, bool);\n+\n+static tree gnu_runtime_abi_01_receiver_is_class_object (tree);\n+static tree gnu_runtime_abi_01_get_arg_type_list_base (tree, int, int);\n+static tree gnu_runtime_abi_01_build_objc_method_call (location_t, tree, tree,\n+\t\t\t\t\t\t\ttree, tree, tree, int);\n+\n+static bool gnu_runtime_abi_01_setup_const_string_class_decl (void);\n+static tree gnu_runtime_abi_01_build_const_string_constructor (location_t, tree,int);\n+\n+static void objc_generate_v1_gnu_metadata (void);\n+\n+static tree objc_eh_runtime_type (tree type);\n+static tree objc_eh_personality (void);\n+static tree objc_build_exc_ptr (struct objc_try_context **);\n+static tree build_throw_stmt (location_t, tree, bool);\n+static tree begin_catch (struct objc_try_context **, tree, tree, tree, bool);\n+static void finish_catch (struct objc_try_context **, tree);\n+static tree finish_try_stmt (struct objc_try_context **);\n+\n+bool \n+objc_gnu_runtime_abi_01_init (objc_runtime_hooks *rthooks)\n+{\n+  /* GNU runtime does not need the compiler to change code in order to do GC. */\n+  if (flag_objc_gc)\n+    {\n+      warning_at (0, 0, \"%<-fobjc-gc%> is ignored for %<-fgnu-runtime%>\");\n+      flag_objc_gc = 0;\n+    }\n+\n+  /* Although I guess we could, we don't currently support SJLJ exceptions for the\n+     GNU runtime.  */\n+  if (flag_objc_sjlj_exceptions)\n+    {\n+      inform (UNKNOWN_LOCATION, \"%<-fobjc-sjlj-exceptions%> is ignored for %<-fgnu-runtime%>\");\n+      flag_objc_sjlj_exceptions = 0;\n+    }\n+\n+  rthooks->initialize = gnu_runtime_01_initialize;\n+  rthooks->default_constant_string_class_name = DEF_CONSTANT_STRING_CLASS_NAME;\n+  rthooks->tag_getclass = TAG_GETCLASS;\n+  rthooks->super_superclassfield_ident = gnu_runtime_abi_01_super_superclassfield_id;\n+\n+  rthooks->class_decl = gnu_runtime_abi_01_class_decl;\n+  rthooks->metaclass_decl = gnu_runtime_abi_01_metaclass_decl;\n+  rthooks->category_decl = gnu_runtime_abi_01_category_decl;\n+  rthooks->protocol_decl = gnu_runtime_abi_01_protocol_decl;\n+  rthooks->string_decl = gnu_runtime_abi_01_string_decl;\n+\n+  rthooks->get_class_reference = gnu_runtime_abi_01_get_class_reference;\n+  rthooks->build_selector_reference = gnu_runtime_abi_01_build_typed_selector_reference;\n+  rthooks->get_protocol_reference = gnu_runtime_abi_01_get_protocol_reference;\n+  rthooks->build_ivar_reference = gnu_runtime_abi_01_build_ivar_ref;\n+  rthooks->get_class_super_ref = gnu_runtime_abi_01_get_class_super_ref;\n+  rthooks->get_category_super_ref = gnu_runtime_abi_01_get_category_super_ref;\n+\n+  rthooks->receiver_is_class_object = gnu_runtime_abi_01_receiver_is_class_object;\n+  rthooks->get_arg_type_list_base = gnu_runtime_abi_01_get_arg_type_list_base;\n+  rthooks->build_objc_method_call = gnu_runtime_abi_01_build_objc_method_call;\n+\n+  rthooks->setup_const_string_class_decl =\n+\t\t\t\tgnu_runtime_abi_01_setup_const_string_class_decl;\n+  rthooks->build_const_string_constructor =\n+\t\t\t\tgnu_runtime_abi_01_build_const_string_constructor;\n+\n+  rthooks->build_throw_stmt = build_throw_stmt;\n+  rthooks->build_exc_ptr = objc_build_exc_ptr;\n+  rthooks->begin_catch = begin_catch;\n+  rthooks->finish_catch = finish_catch;\n+  rthooks->finish_try_stmt = finish_try_stmt;\n+\n+  rthooks->generate_metadata = objc_generate_v1_gnu_metadata;\n+  return true;\n+}\n+\n+static void build_selector_table_decl (void);\n+static void build_class_template (void);\n+static void build_category_template (void);\n+static void build_protocol_template (void);\n+\n+static GTY(()) tree objc_meta;\n+static GTY(()) tree meta_base;\n+\n+static void gnu_runtime_01_initialize (void)\n+{\n+  tree type, ftype, IMP_type;\n+\n+  /* We do not need to mark GNU ObjC metadata for different sections,\n+     however, we do need to make sure that it is not mistaken for NeXT\n+     metadata.  */\n+  objc_meta = get_identifier (\"OBJC1METG\");\n+  meta_base = get_identifier (\"NONE\");\n+\n+  /* Declare type of selector-objects that represent an operation name.  */\n+  /* `const struct objc_selector *' */\n+  type = xref_tag (RECORD_TYPE, get_identifier (TAG_SELECTOR));\n+  type = build_qualified_type (type, TYPE_QUAL_CONST);\n+  objc_selector_type = build_pointer_type (type);\n+\n+  /* typedef id (*IMP)(id, SEL, ...); */\n+  ftype = build_varargs_function_type_list (objc_object_type,\n+\t\t\t\t\t    objc_object_type,\n+\t\t\t\t\t    objc_selector_type,\n+\t\t\t\t\t    NULL_TREE);\n+\n+  IMP_type = build_pointer_type (ftype);\n+\n+  build_class_template ();\n+  build_super_template ();\n+  build_protocol_template ();\n+  build_category_template ();\n+\n+  /* GNU runtime messenger entry points.  */\n+  /* TREE_NOTHROW is cleared for the message-sending functions,\n+     because the function that gets called can throw in Obj-C++, or\n+     could itself call something that can throw even in Obj-C.  */\n+\n+  /* IMP objc_msg_lookup (id, SEL); */\n+  type = build_function_type_list (IMP_type,\n+\t\t\t\t   objc_object_type,\n+\t\t\t\t   objc_selector_type,\n+\t\t\t\t   NULL_TREE);\n+\n+  umsg_decl = add_builtin_function (TAG_MSGSEND,\n+\t\t\t\t    type, 0, NOT_BUILT_IN,\n+\t\t\t\t    NULL, NULL_TREE);\n+  TREE_NOTHROW (umsg_decl) = 0;\n+\n+  /* IMP objc_msg_lookup_super (struct objc_super *, SEL); */\n+  type = build_function_type_list (IMP_type,\n+\t\t\t\t   objc_super_type,\n+\t\t\t\t   objc_selector_type,\n+\t\t\t\t   NULL_TREE);\n+\n+  umsg_super_decl = add_builtin_function (TAG_MSGSENDSUPER,\n+\t\t\t\t\t  type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t  NULL, NULL_TREE);\n+  TREE_NOTHROW (umsg_super_decl) = 0;\n+\n+  /* The following GNU runtime entry point is called to initialize\n+\t each module:\n+\n+\t __objc_exec_class (void *); */\n+  type = build_function_type_list (void_type_node,\n+\t\t\t\t   ptr_type_node,\n+\t\t\t\t   NULL_TREE);\n+\n+  execclass_decl = add_builtin_function (TAG_EXECCLASS,\n+\t\t\t\t\t type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t NULL, NULL_TREE);\n+\n+  type = build_function_type_list (objc_object_type,\n+\t\t\t\t   const_string_type_node,\n+\t\t\t\t   NULL_TREE);\n+\n+  /* id objc_getClass (const char *); */\n+  objc_get_class_decl\n+    = add_builtin_function (TAG_GETCLASS, type, 0, NOT_BUILT_IN,\n+\t\t\t    NULL, NULL_TREE);\n+\n+  /* id objc_getMetaClass (const char *); */\n+  objc_get_meta_class_decl = add_builtin_function (TAG_GETMETACLASS, type, \n+\t\t\t\t\t\t   0, NOT_BUILT_IN, NULL,\n+\t\t\t\t\t\t   NULL_TREE);\n+\n+  /* static SEL _OBJC_SELECTOR_TABLE[]; */\n+  build_selector_table_decl ();\n+  \n+  /* Stuff for properties.  \n+     The codegen relies on this being NULL for GNU.  */\n+  objc_copyStruct_decl = NULL_TREE;\n+\n+  /* This is the type of all of the following functions\n+     bjc_getPropertyStruct() and objc_setPropertyStruct().  */\n+  type = build_function_type_list (void_type_node,\n+\t\t\t\t   ptr_type_node,\n+\t\t\t\t   const_ptr_type_node,\n+\t\t\t\t   ptrdiff_type_node,       \n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   NULL_TREE);\n+\n+  /* Declare the following function:\n+\t void\n+\t objc_getPropertyStruct (void *destination, const void *source, \n+                                 ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n+  objc_getPropertyStruct_decl = add_builtin_function (\"objc_getPropertyStruct\",\n+\t\t\t\t\t\t\t  type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\t\t  NULL, NULL_TREE);\n+  TREE_NOTHROW (objc_getPropertyStruct_decl) = 0;\n+  /* Declare the following function:\n+\t void\n+\t objc_setPropertyStruct (void *destination, const void *source, \n+\t                         ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n+  objc_setPropertyStruct_decl = add_builtin_function (\"objc_setPropertyStruct\",\n+\t\t\t\t\t\t\t  type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\t\t  NULL, NULL_TREE);\n+  TREE_NOTHROW (objc_setPropertyStruct_decl) = 0;\n+  \n+  using_eh_for_cleanups ();\n+  lang_hooks.eh_runtime_type = objc_eh_runtime_type;\n+  lang_hooks.eh_personality = objc_eh_personality;\n+}\n+\n+/* --- templates --- */\n+/* struct _objc_selector {\n+     SEL sel_id;\n+     char *sel_type;\n+   }; */\n+\n+static void\n+build_selector_template (void)\n+{\n+  tree decls, *chain = NULL;\n+\n+  objc_selector_template = objc_start_struct (get_identifier (UTAG_SELECTOR));\n+\n+  /* SEL sel_id; */\n+  decls = add_field_decl (objc_selector_type, \"sel_id\", &chain);\n+\n+  /* char *sel_type; */\n+  add_field_decl (string_type_node, \"sel_type\", &chain);\n+\n+  objc_finish_struct (objc_selector_template, decls);\n+}\n+\n+/* struct _objc_class {\n+     struct _objc_class *isa;\n+     struct _objc_class *super_class;\n+     char *name;\n+     long version;\n+     long info;\n+     long instance_size;\n+     struct _objc_ivar_list *ivars;\n+     struct _objc_method_list *methods;\n+     struct sarray *dtable;\n+     struct _objc_class *subclass_list;\n+     struct _objc_class *sibling_class;\n+     struct _objc_protocol_list *protocols;\n+     void *gc_object_type;\n+   };  */\n+\n+static void\n+build_class_template (void)\n+{\n+  tree ptype, decls, *chain = NULL;\n+\n+  objc_class_template = objc_start_struct (get_identifier (UTAG_CLASS));\n+\n+  /* struct _objc_class *isa; */\n+  decls = add_field_decl (build_pointer_type (objc_class_template),\n+\t\t\t  \"isa\", &chain);\n+\n+  /* struct _objc_class *super_class; */\n+  add_field_decl (build_pointer_type (objc_class_template),\n+\t\t  \"super_class\", &chain);\n+\n+  /* char *name; */\n+  add_field_decl (string_type_node, \"name\", &chain);\n+\n+  /* long version; */\n+  add_field_decl (long_integer_type_node, \"version\", &chain);\n+\n+  /* long info; */\n+  add_field_decl (long_integer_type_node, \"info\", &chain);\n+\n+  /* long instance_size; */\n+  add_field_decl (long_integer_type_node, \"instance_size\", &chain);\n+\n+  /* struct _objc_ivar_list *ivars; */\n+  add_field_decl (objc_ivar_list_ptr,\"ivars\", &chain);\n+\n+  /* struct _objc_method_list *methods; */\n+  add_field_decl (objc_method_list_ptr, \"methods\", &chain);\n+\n+  /* struct sarray *dtable; */\n+  ptype = build_pointer_type(xref_tag (RECORD_TYPE,\n+\t\t\t\t\t   get_identifier (\"sarray\")));\n+  add_field_decl (ptype, \"dtable\", &chain);\n+\n+  /* struct objc_class *subclass_list; */\n+  ptype = build_pointer_type (objc_class_template);\n+  add_field_decl (ptype, \"subclass_list\", &chain);\n+\n+  /* struct objc_class *sibling_class; */\n+  ptype = build_pointer_type (objc_class_template);\n+  add_field_decl (ptype, \"sibling_class\", &chain);\n+ \n+  /* struct _objc_protocol **protocol_list; */\n+  ptype = build_pointer_type (build_pointer_type\n+\t\t\t      (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t get_identifier (UTAG_PROTOCOL))));\n+  add_field_decl (ptype, \"protocol_list\", &chain);\n+\n+  /* void *gc_object_type; */\n+  add_field_decl (build_pointer_type (void_type_node),\n+\t\t    \"gc_object_type\", &chain);\n+\n+  objc_finish_struct (objc_class_template, decls);\n+}\n+\n+/* struct _objc_category {\n+     char *category_name;\n+     char *class_name;\n+     struct _objc_method_list *instance_methods;\n+     struct _objc_method_list *class_methods;\n+     struct _objc_protocol_list *protocols;\n+   };   */\n+\n+static void\n+build_category_template (void)\n+{\n+  tree ptype, decls, *chain = NULL;\n+\n+  objc_category_template = objc_start_struct (get_identifier (UTAG_CATEGORY));\n+\n+  /* char *category_name; */\n+  decls = add_field_decl (string_type_node, \"category_name\", &chain);\n+\n+  /* char *class_name; */\n+  add_field_decl (string_type_node, \"class_name\", &chain);\n+\n+  /* struct _objc_method_list *instance_methods; */\n+  add_field_decl (objc_method_list_ptr, \"instance_methods\", &chain);\n+\n+  /* struct _objc_method_list *class_methods; */\n+  add_field_decl (objc_method_list_ptr, \"class_methods\", &chain);\n+\n+  /* struct _objc_protocol **protocol_list; */\n+  ptype = build_pointer_type (build_pointer_type (objc_protocol_template));\n+  add_field_decl (ptype, \"protocol_list\", &chain);\n+\n+  objc_finish_struct (objc_category_template, decls);\n+}\n+\n+/* struct _objc_protocol {\n+     struct _objc_class *isa;\n+     char *protocol_name;\n+     struct _objc_protocol **protocol_list;\n+     struct _objc__method_prototype_list *instance_methods;\n+     struct _objc__method_prototype_list *class_methods;\n+   };  */\n+\n+static void\n+build_protocol_template (void)\n+{\n+  tree ptype, decls, *chain = NULL;\n+\n+  objc_protocol_template = objc_start_struct (get_identifier (UTAG_PROTOCOL));\n+\n+  /* struct _objc_class *isa; */\n+  ptype = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\tget_identifier (UTAG_CLASS)));\n+  decls = add_field_decl (ptype, \"isa\", &chain);\n+\n+  /* char *protocol_name; */\n+  add_field_decl (string_type_node, \"protocol_name\", &chain);\n+\n+  /* struct _objc_protocol **protocol_list; */\n+  ptype = build_pointer_type (build_pointer_type (objc_protocol_template));\n+  add_field_decl (ptype, \"protocol_list\", &chain);\n+\n+  /* struct _objc__method_prototype_list *instance_methods; */\n+  add_field_decl (objc_method_proto_list_ptr, \"instance_methods\", &chain);\n+\n+  /* struct _objc__method_prototype_list *class_methods; */\n+  add_field_decl (objc_method_proto_list_ptr, \"class_methods\", &chain);\n+\n+  objc_finish_struct (objc_protocol_template, decls);\n+}\n+\n+/* --- names, decls + identifers --- */\n+\n+static void\n+build_selector_table_decl (void)\n+{\n+  tree temp;\n+\n+  build_selector_template ();\n+  temp = build_array_type (objc_selector_template, NULL_TREE);\n+\n+  UOBJC_SELECTOR_TABLE_decl = start_var_decl (temp, \"_OBJC_SELECTOR_TABLE\");\n+  OBJCMETA (UOBJC_SELECTOR_TABLE_decl, objc_meta, meta_base);\n+}\n+\n+\n+static tree\n+gnu_runtime_abi_01_super_superclassfield_id (void)\n+{\n+  if (!super_superclassfield_id)\n+    super_superclassfield_id = get_identifier (\"super_class\");\n+  return super_superclassfield_id;\n+}\n+\n+\n+static tree\n+gnu_runtime_abi_01_class_decl (tree klass)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+  snprintf (buf, BUFSIZE, \"_OBJC_Class_%s\", \n+\t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n+  decl = start_var_decl (objc_class_template, buf);\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  return decl;\n+}\n+\n+static tree\n+gnu_runtime_abi_01_metaclass_decl (tree klass)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+  snprintf (buf, BUFSIZE, \"_OBJC_MetaClass_%s\", \n+\t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n+  decl = start_var_decl (objc_class_template, buf);\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  return decl;\n+}\n+\n+static tree\n+gnu_runtime_abi_01_category_decl (tree klass)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+  snprintf (buf, BUFSIZE, \"_OBJC_Category_%s_on_%s\", \n+\t    IDENTIFIER_POINTER (CLASS_SUPER_NAME (klass)),\n+\t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n+  decl = start_var_decl (objc_category_template, buf);\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  return decl;\n+}\n+\n+static tree\n+gnu_runtime_abi_01_protocol_decl (tree p)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+\n+  /* static struct _objc_protocol _OBJC_Protocol_<mumble>; */\n+  snprintf (buf, BUFSIZE, \"_OBJC_Protocol_%s\",\n+\t    IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n+  decl = start_var_decl (objc_protocol_template, buf);\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  return decl;\n+}\n+\n+static tree\n+gnu_runtime_abi_01_string_decl (tree type, const char *name, \n+\t\t\t\tstring_section where ATTRIBUTE_UNUSED)\n+{\n+  tree decl = start_var_decl (type, name);\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  return decl;\n+}\n+\n+/* --- entry --- */\n+\n+static tree\n+gnu_runtime_abi_01_get_class_reference (tree ident)\n+{\n+  tree params;\n+\n+  add_class_reference (ident);\n+\n+  params = build_tree_list (NULL_TREE, my_build_string_pointer \n+\t\t\t\t\t\t(IDENTIFIER_LENGTH (ident) + 1,\n+\t\t\t\t\t\t IDENTIFIER_POINTER (ident)));\n+\n+/*      assemble_external (objc_get_class_decl);*/\n+  return build_function_call (input_location, objc_get_class_decl, params);\n+}\n+\n+/* Used by get_arg_type_list.  \n+   Return the types for receiver & _cmd at the start of a method argument list.\n+   context is either METHOD_DEF or METHOD_REF, saying whether we are trying\n+   to define a method or call one.  superflag says this is for a send to super.\n+   meth may be NULL, in the case that there is no prototype.  */\n+\n+static tree\n+gnu_runtime_abi_01_get_arg_type_list_base (tree meth, int context,\n+\t\t\t\t\t   int superflag ATTRIBUTE_UNUSED)\n+{\n+  tree arglist;\n+\n+  /* Receiver type.  */\n+  if (context == METHOD_DEF && TREE_CODE (meth) == INSTANCE_METHOD_DECL)\n+    arglist = build_tree_list (NULL_TREE, objc_instance_type);\n+  else\n+    arglist = build_tree_list (NULL_TREE, objc_object_type);\n+\n+  /* Selector type - will eventually change to `int'.  */\n+  chainon (arglist, build_tree_list (NULL_TREE, objc_selector_type));\n+  return arglist;\n+}\n+\n+/* Unused for GNU runtime.  */\n+static tree\n+gnu_runtime_abi_01_receiver_is_class_object (tree a ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n+/* sel_ref_chain is a list whose \"value\" fields will be instances of\n+   identifier_node that represent the selector.  LOC is the location of\n+   the @selector.  */\n+\n+static tree\n+gnu_runtime_abi_01_build_typed_selector_reference (location_t loc, tree ident,\n+\t\t\t\t\t\t   tree prototype)\n+{\n+  tree *chain = &sel_ref_chain;\n+  tree expr;\n+  int index = 0;\n+\n+  while (*chain)\n+    {\n+      /* When we do a lookup for @selector () we have no idea of the \n+         prototype - so match the first we find.  */\n+      if (TREE_VALUE (*chain) == ident \n+          && (!prototype || TREE_PURPOSE (*chain) == prototype))\n+\tgoto return_at_index;\n+\n+      index++;\n+      chain = &TREE_CHAIN (*chain);\n+    }\n+\n+  *chain = tree_cons (prototype, ident, NULL_TREE);\n+\n+  /* TODO: Use a vec and keep this in it to (a) avoid re-creating and \n+     (b) provide better diagnostics for the first time an undefined\n+     selector is used.  */\n+ return_at_index:\n+  expr = build_unary_op (loc, ADDR_EXPR,\n+\t\t\t build_array_ref (loc, UOBJC_SELECTOR_TABLE_decl,\n+\t\t\t\t\t  build_int_cst (NULL_TREE, index)),\n+\t\t\t 1);\n+  return convert (objc_selector_type, expr);\n+}\n+\n+/* Build a tree expression to send OBJECT the operation SELECTOR,\n+   looking up the method on object LOOKUP_OBJECT (often same as OBJECT),\n+   assuming the method has prototype METHOD_PROTOTYPE.\n+   (That is an INSTANCE_METHOD_DECL or CLASS_METHOD_DECL.)\n+   LOC is the location of the expression to build.\n+   Use METHOD_PARAMS as list of args to pass to the method.\n+   If SUPER_FLAG is nonzero, we look up the superclass's method.  */\n+\n+static tree\n+build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n+\t\t\ttree lookup_object, tree selector,\n+\t\t\ttree method_params)\n+{\n+  tree sender = (super_flag ? umsg_super_decl \n+\t\t\t    : (flag_objc_direct_dispatch ? umsg_fast_decl\n+\t\t\t\t\t\t\t : umsg_decl));\n+  tree rcv_p = (super_flag ? objc_super_type : objc_object_type);\n+  VEC(tree, gc) *parms;\n+  VEC(tree, gc) *tv;\n+  unsigned nparm = (method_params ? list_length (method_params) : 0);\n+\n+  /* If a prototype for the method to be called exists, then cast\n+     the sender's return type and arguments to match that of the method.\n+     Otherwise, leave sender as is.  */\n+  tree ret_type\n+    = (method_prototype\n+       ? TREE_VALUE (TREE_TYPE (method_prototype))\n+       : objc_object_type);\n+\n+  tree method_param_types = \n+  \t\tget_arg_type_list (method_prototype, METHOD_REF, super_flag);\n+  tree ftype = build_function_type (ret_type, method_param_types);\n+  tree sender_cast;\n+  tree method, t;\n+\n+  if (method_prototype && METHOD_TYPE_ATTRIBUTES (method_prototype))\n+    ftype = build_type_attribute_variant (ftype, \n+\t\t\t\t\t  METHOD_TYPE_ATTRIBUTES \n+\t\t\t\t\t  (method_prototype));\n+\n+  sender_cast = build_pointer_type (ftype);\n+\n+  lookup_object = build_c_cast (loc, rcv_p, lookup_object);\n+\n+  /* Use SAVE_EXPR to avoid evaluating the receiver twice.  */\n+  lookup_object = save_expr (lookup_object);\n+\n+  /* Param list + 2 slots for object and selector.  */\n+  parms = VEC_alloc (tree, gc, nparm + 2);\n+  tv = VEC_alloc (tree, gc, 2);\n+\n+  /* First, call the lookup function to get a pointer to the method,\n+     then cast the pointer, then call it with the method arguments.  */\n+  VEC_quick_push (tree, tv, lookup_object);\n+  VEC_quick_push (tree, tv, selector);\n+  method = build_function_call_vec (loc, sender, tv, NULL);\n+  VEC_free (tree, gc, tv);\n+\n+  /* Pass the appropriate object to the method.  */\n+  VEC_quick_push (tree, parms, (super_flag ? self_decl : lookup_object));\n+\n+  /* Pass the selector to the method.  */\n+  VEC_quick_push (tree, parms, selector);\n+  /* Now append the remainder of the parms.  */\n+  if (nparm)\n+    for (; method_params; method_params = TREE_CHAIN (method_params))\n+      VEC_quick_push (tree, parms, TREE_VALUE (method_params));\n+\n+  /* Build an obj_type_ref, with the correct cast for the method call.  */\n+  t = build3 (OBJ_TYPE_REF, sender_cast, method, lookup_object, size_zero_node);\n+  t = build_function_call_vec (loc, t, parms, NULL);\n+  VEC_free (tree, gc, parms);\n+  return t;\n+}\n+\n+static tree\n+gnu_runtime_abi_01_build_objc_method_call (location_t loc,\n+\t\t\t\t\t   tree method_prototype,\n+\t\t\t\t\t   tree receiver,\n+\t\t\t\t\t   tree rtype ATTRIBUTE_UNUSED,\n+\t\t\t\t\t   tree sel_name,\n+\t\t\t\t\t   tree method_params,\n+\t\t\t\t\t   int super ATTRIBUTE_UNUSED)\n+{\n+  tree selector = \n+\tgnu_runtime_abi_01_build_typed_selector_reference (loc, \n+\t\t\t\t\t\t\t  sel_name, \n+\t\t\t\t\t\t\t  method_prototype);\n+\n+  return build_objc_method_call (loc, super, method_prototype, receiver,\n+\t\t\t\t selector, method_params);\n+}\n+\n+static tree\n+gnu_runtime_abi_01_get_protocol_reference (location_t loc, tree p)\n+{\n+  tree expr, protocol_struct_type, *chain;\n+  if (!PROTOCOL_FORWARD_DECL (p))\n+    PROTOCOL_FORWARD_DECL (p) = gnu_runtime_abi_01_protocol_decl (p);\n+\n+  expr = build_unary_op (loc, ADDR_EXPR, PROTOCOL_FORWARD_DECL (p), 0);\n+\n+  /* ??? Ideally we'd build the reference with objc_protocol_type directly,\n+     if we have it, rather than converting it here.  */\n+  expr = convert (objc_protocol_type, expr);\n+\n+  /* The @protocol() expression is being compiled into a pointer to a\n+     statically allocated instance of the Protocol class.  To become\n+     usable at runtime, the 'isa' pointer of the instance need to be\n+     fixed up at runtime by the runtime library, to point to the\n+     actual 'Protocol' class.  */\n+\n+  /* For the GNU runtime, put the static Protocol instance in the list\n+     of statically allocated instances, so that we make sure that its\n+     'isa' pointer is fixed up at runtime by the GNU runtime library\n+     to point to the Protocol class (at runtime, when loading the\n+     module, the GNU runtime library loops on the statically allocated\n+     instances (as found in the defs field in objc_symtab) and fixups\n+     all the 'isa' pointers of those objects).  */\n+\n+  /* This type is a struct containing the fields of a Protocol\n+     object.  (Cfr. objc_protocol_type instead is the type of a pointer\n+     to such a struct).  */\n+  protocol_struct_type = xref_tag (RECORD_TYPE, \n+\t\t\t\t   get_identifier (PROTOCOL_OBJECT_CLASS_NAME));\n+\n+  /* Look for the list of Protocol statically allocated instances\n+     to fixup at runtime.  Create a new list to hold Protocol\n+     statically allocated instances, if the list is not found.  At\n+     present there is only another list, holding NSConstantString\n+     static instances to be fixed up at runtime.  */\n+\n+  for (chain = &objc_static_instances;\n+\t*chain && TREE_VALUE (*chain) != protocol_struct_type;\n+\tchain = &TREE_CHAIN (*chain));\n+\n+  if (!*chain)\n+    {\n+       *chain = tree_cons (NULL_TREE, protocol_struct_type, NULL_TREE);\n+       add_objc_string (OBJC_TYPE_NAME (protocol_struct_type),\n+                          class_names);\n+    }\n+\n+  /* Add this statically allocated instance to the Protocol list.  */\n+  TREE_PURPOSE (*chain) = tree_cons (NULL_TREE,\n+\t\t\t\t     PROTOCOL_FORWARD_DECL (p),\n+\t\t\t\t     TREE_PURPOSE (*chain));\n+  return expr;\n+}\n+\n+/* For ABI 0/1 and IVAR is just a fixed offset in the class struct.  */\n+\n+static tree\n+gnu_runtime_abi_01_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED, \n+\t\t\t\t   tree base, tree id)\n+{\n+  return objc_build_component_ref (base, id);\n+}\n+\n+/* We build super class references as we need them (but keep them once\n+   built for the sake of efficiency).  */\n+\n+static tree\n+gnu_runtime_abi_01_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED, \n+\t\t\t\t\tstruct imp_entry *imp, bool inst_meth)\n+{\n+  if (inst_meth)\n+    {\n+      if (!ucls_super_ref)\n+\tucls_super_ref = \n+\t\tobjc_build_component_ref (imp->class_decl, \n+\t\t\t\t\t  get_identifier (\"super_class\"));\n+\treturn ucls_super_ref;\n+    }\n+  else\n+    {\n+      if (!uucls_super_ref)\n+\tuucls_super_ref = \n+\t\tobjc_build_component_ref (imp->meta_decl, \n+\t\t\t\t\t  get_identifier (\"super_class\"));\n+\treturn uucls_super_ref;\n+    }\n+}\n+\n+static tree\n+gnu_runtime_abi_01_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED, \n+\t\t\t\t\t   struct imp_entry *imp, bool inst_meth)\n+{\n+  tree super_name = CLASS_SUPER_NAME (imp->imp_template);\n+  tree super_class;\n+\n+  add_class_reference (super_name);\n+  super_class = (inst_meth ? objc_get_class_decl : objc_get_meta_class_decl);\n+/* assemble_external (super_class);*/\n+  super_name = my_build_string_pointer (IDENTIFIER_LENGTH (super_name) + 1,\n+\t\t\t\t\tIDENTIFIER_POINTER (super_name));\n+  /* super_class = get_{meta_}class(\"CLASS_SUPER_NAME\");  */\n+  return build_function_call (input_location,\n+\t\t\t      super_class,\n+\t\t\t      build_tree_list (NULL_TREE, super_name));\n+}\n+\n+static bool\n+gnu_runtime_abi_01_setup_const_string_class_decl (void)\n+{\n+  /* Do nothing, and create no error.  */\n+  return true;\n+}\n+\n+/* Declare a static instance of CLASS_DECL initialized by CONSTRUCTOR.  */\n+\n+static GTY(()) int num_static_inst;\n+\n+static tree\n+objc_add_static_instance (tree constructor, tree class_decl)\n+{\n+  tree *chain, decl;\n+  char buf[BUFSIZE];\n+\n+  /* Find the list of static instances for the CLASS_DECL.  Create one if\n+     not found.  */\n+  for (chain = &objc_static_instances;\n+       *chain && TREE_VALUE (*chain) != class_decl;\n+       chain = &TREE_CHAIN (*chain));\n+  if (!*chain)\n+    {\n+      *chain = tree_cons (NULL_TREE, class_decl, NULL_TREE);\n+      add_objc_string (OBJC_TYPE_NAME (class_decl), class_names);\n+    }\n+\n+  snprintf (buf, BUFSIZE, \"_OBJC_INSTANCE_%d\", num_static_inst++);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (buf), class_decl);\n+  TREE_STATIC (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  TREE_USED (decl) = 1;\n+  DECL_INITIAL (decl) = constructor;\n+  DECL_CONTEXT (decl) = NULL;\n+  OBJCMETA (decl, objc_meta, meta_base);\n+\n+  /* We may be writing something else just now.\n+     Postpone till end of input. */ \n+  DECL_DEFER_OUTPUT (decl) = 1;\n+  pushdecl_top_level (decl);\n+  rest_of_decl_compilation (decl, 1, 0);\n+\n+  /* Add the DECL to the head of this CLASS' list.  */\n+  TREE_PURPOSE (*chain) = tree_cons (NULL_TREE, decl, TREE_PURPOSE (*chain));\n+\n+  return decl;\n+}\n+\n+static tree\n+gnu_runtime_abi_01_build_const_string_constructor (location_t loc, tree string,\n+\t\t\t\t\t\t   int length)\n+{\n+  tree constructor, fields;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  \n+  /* GNU:    (NXConstantString *) & ((__builtin_ObjCString) { NULL, string, length })  */\n+  fields = TYPE_FIELDS (internal_const_str_type);\n+  CONSTRUCTOR_APPEND_ELT (v, fields, build_int_cst (NULL_TREE, 0));\n+\n+  fields = DECL_CHAIN (fields);\n+  CONSTRUCTOR_APPEND_ELT (v, fields, build_unary_op (loc, \n+\t\t\t\t\t\t     ADDR_EXPR, string, 1));\n+\n+  fields = DECL_CHAIN (fields);\n+  CONSTRUCTOR_APPEND_ELT (v, fields, build_int_cst (NULL_TREE, length));\n+  constructor = objc_build_constructor (internal_const_str_type, v);\n+\n+  constructor = objc_add_static_instance (constructor, constant_string_type);\n+  return constructor;\n+}\n+\n+/* --- metadata - module initializer --- */\n+\n+/* The GNU runtime requires us to provide a static initializer function\n+   for each module:\n+\n+   static void __objc_gnu_init (void) {\n+     __objc_exec_class (&L_OBJC_MODULES);\n+   }  */\n+\n+\n+static void\n+build_module_initializer_routine (void)\n+{\n+  tree body;\n+\n+#ifdef OBJCPLUS\n+  push_lang_context (lang_name_c); /* extern \"C\" */\n+#endif\n+\n+  objc_push_parm (build_decl (input_location,\n+\t\t\t      PARM_DECL, NULL_TREE, void_type_node));\n+#ifdef OBJCPLUS\n+  objc_start_function (get_identifier (TAG_GNUINIT),\n+\t\t       build_function_type_list (void_type_node, NULL_TREE),\n+\t\t       NULL_TREE, NULL_TREE);\n+#else\n+  objc_start_function (get_identifier (TAG_GNUINIT),\n+\t\t       build_function_type_list (void_type_node, NULL_TREE),\n+\t\t       NULL_TREE, objc_get_parm_info (0));\n+#endif\n+  body = c_begin_compound_stmt (true);\n+  add_stmt (build_function_call\n+\t    (input_location,\n+\t     execclass_decl,\n+\t     build_tree_list\n+\t     (NULL_TREE,\n+\t      build_unary_op (input_location, ADDR_EXPR,\n+\t\t\t      UOBJC_MODULES_decl, 0))));\n+  add_stmt (c_end_compound_stmt (input_location, body, true));\n+\n+  TREE_PUBLIC (current_function_decl) = 0;\n+\n+#ifndef OBJCPLUS\n+  /* For Objective-C++, we will need to call __objc_gnu_init\n+     from objc_generate_static_init_call() below.  */\n+  DECL_STATIC_CONSTRUCTOR (current_function_decl) = 1;\n+#endif\n+\n+  GNU_INIT_decl = current_function_decl;\n+  finish_function ();\n+\n+#ifdef OBJCPLUS\n+    pop_lang_context ();\n+#endif\n+}\n+\n+#ifdef OBJCPLUS\n+/* Return 1 if the __objc_gnu_init function has been synthesized and needs\n+   to be called by the module initializer routine.  */\n+\n+int\n+objc_static_init_needed_p (void)\n+{\n+  return (GNU_INIT_decl != NULL_TREE);\n+}\n+\n+/* Generate a call to the __objc_gnu_init initializer function.  */\n+\n+tree\n+objc_generate_static_init_call (tree ctors ATTRIBUTE_UNUSED)\n+{\n+  add_stmt (build_stmt (input_location, EXPR_STMT,\n+\t\t\tbuild_function_call (input_location,\n+\t\t\t\t\t     GNU_INIT_decl, NULL_TREE)));\n+\n+  return ctors;\n+}\n+#endif /* OBJCPLUS */\n+\n+/* --- Output GNU Meta-data --- */\n+\n+static void\n+generate_classref_translation_entry (tree chain)\n+{\n+  tree expr, decl, type;\n+\n+  decl = TREE_PURPOSE (chain);\n+  type = TREE_TYPE (decl);\n+\n+  expr = add_objc_string (TREE_VALUE (chain), class_names);\n+  expr = convert (type, expr); /* cast! */\n+\n+  /* This is a class reference.  It is re-written by the runtime,\n+     but will be optimized away unless we force it.  */\n+  DECL_PRESERVE_P (decl) = 1;\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  finish_var_decl (decl, expr);\n+  return;\n+}\n+\n+\n+static void\n+handle_impent (struct imp_entry *impent)\n+{\n+  char *string;\n+\n+/*  objc_implementation_context = impent->imp_context;\n+  implementation_template = impent->imp_template;*/\n+\n+  switch (TREE_CODE (impent->imp_context))\n+    {\n+    case CLASS_IMPLEMENTATION_TYPE:\n+      {\n+\tconst char *const class_name =\n+\t  IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n+\t\n+\tstring = (char *) alloca (strlen (class_name) + 30);\n+\t\n+\tsprintf (string, \"__objc_class_name_%s\", class_name);\n+\tbreak;\n+      }\n+    case CATEGORY_IMPLEMENTATION_TYPE:\n+      {\n+\tconst char *const class_name =\n+\t  IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n+\tconst char *const class_super_name =\n+\t  IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context));\n+\t\n+\tstring = (char *) alloca (strlen (class_name)\n+\t\t\t\t  + strlen (class_super_name) + 30);\n+\t\n+\t/* Do the same for categories.  Even though no references to\n+\t   these symbols are generated automatically by the compiler,\n+\t   it gives you a handle to pull them into an archive by\n+\t   hand.  */\n+\tsprintf (string, \"*__objc_category_name_%s_%s\", class_name, class_super_name);\n+\tbreak;\n+      }\n+    default:\n+      return;\n+    }\n+\n+    {\n+      tree decl, init;\n+\n+      init = integer_zero_node;\n+      decl = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (string), TREE_TYPE (init));\n+      TREE_PUBLIC (decl) = 1;\n+      TREE_READONLY (decl) = 1;\n+      TREE_USED (decl) = 1;\n+      TREE_CONSTANT (decl) = 1;\n+      DECL_CONTEXT (decl) = NULL_TREE;\n+      DECL_ARTIFICIAL (decl) = 1;\n+      TREE_STATIC (decl) = 1;\n+      DECL_INITIAL (decl) = error_mark_node; /* A real initializer is coming... */\n+      /* We must force the reference.  */\n+      DECL_PRESERVE_P (decl) = 1;\n+\n+      finish_var_decl(decl, init) ;\n+    }\n+}\n+\n+tree\n+build_protocol_initializer (tree type, tree protocol_name, tree protocol_list,\n+\t\t\t    tree inst_methods, tree class_methods)\n+{\n+  tree expr, ttyp;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *inits = NULL;\n+\n+  /* TODO: pass the loc in or find it from args.  */\n+  loc = input_location;\n+  ttyp = build_pointer_type (xref_tag (RECORD_TYPE, \n+\t\t\t\t       get_identifier (UTAG_CLASS)));\n+  /* Filling the \"isa\" in with a version allows the runtime system to\n+     detect this ...   */\n+  expr = build_int_cst (ttyp, PROTOCOL_VERSION);\n+\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n+\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, protocol_name);\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, protocol_list);\n+\n+  ttyp = objc_method_proto_list_ptr;\n+  if (inst_methods)\n+    expr = convert (ttyp, build_unary_op (loc, ADDR_EXPR, inst_methods, 0));\n+  else\n+    expr = convert (ttyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n+\n+  if (class_methods)\n+    expr = convert (ttyp, build_unary_op (loc, ADDR_EXPR, class_methods, 0));\n+  else\n+    expr = convert (ttyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n+\n+  return objc_build_constructor (type, inits);\n+}\n+\n+static tree\n+generate_protocol_list (tree i_or_p, tree klass_ctxt)\n+{\n+  tree array_type, ptype, refs_decl, lproto, e, plist;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  char buf[BUFSIZE];\n+  int size = 0;\n+\n+  switch (TREE_CODE (i_or_p))\n+    {\n+    case CLASS_INTERFACE_TYPE:\n+    case CATEGORY_INTERFACE_TYPE:\n+      plist = CLASS_PROTOCOL_LIST (i_or_p);\n+      break;\n+    case PROTOCOL_INTERFACE_TYPE:\n+      plist = PROTOCOL_LIST (i_or_p);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Compute size.  */\n+  for (lproto = plist; lproto; lproto = TREE_CHAIN (lproto))\n+    if (TREE_CODE (TREE_VALUE (lproto)) == PROTOCOL_INTERFACE_TYPE\n+\t&& PROTOCOL_FORWARD_DECL (TREE_VALUE (lproto)))\n+      size++;\n+\n+  /* Build initializer.  */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+  e = build_int_cst (build_pointer_type (objc_protocol_template), size);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, e);\n+\n+  for (lproto = plist; lproto; lproto = TREE_CHAIN (lproto))\n+    {\n+      tree pval = TREE_VALUE (lproto);\n+\n+      if (TREE_CODE (pval) == PROTOCOL_INTERFACE_TYPE\n+\t  && PROTOCOL_FORWARD_DECL (pval))\n+\t{\n+\t  tree fwref = PROTOCOL_FORWARD_DECL (pval);\n+\t  location_t loc = DECL_SOURCE_LOCATION (fwref) ;\n+\t  e = build_unary_op (loc, ADDR_EXPR, fwref, 0);\n+          CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, e);\n+\t}\n+    }\n+\n+  /* static struct objc_protocol *refs[n]; */\n+\n+  switch (TREE_CODE (i_or_p))\n+    {\n+    case PROTOCOL_INTERFACE_TYPE:\n+      snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRefs_%s\", \n+\t\tIDENTIFIER_POINTER (PROTOCOL_NAME (i_or_p)));\n+      break;\n+    case CLASS_INTERFACE_TYPE:\n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassProtocols_%s\", \n+\t\tIDENTIFIER_POINTER (CLASS_NAME (i_or_p)));\n+      break;\n+    case CATEGORY_INTERFACE_TYPE:\n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryProtocols_%s_%s\", \n+\t\tIDENTIFIER_POINTER (CLASS_NAME (klass_ctxt)),\n+\t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (klass_ctxt)));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  ptype = build_pointer_type (objc_protocol_template);\n+  array_type = build_sized_array_type (ptype, size + 3);\n+  refs_decl = start_var_decl (array_type, buf);\n+  OBJCMETA (refs_decl, objc_meta, meta_base);\n+  finish_var_decl (refs_decl,\n+                   objc_build_constructor (TREE_TYPE (refs_decl), v));\n+\n+  return refs_decl;\n+}\n+\n+static tree \n+generate_v1_meth_descriptor_table (tree chain, tree protocol, const char *prefix)\n+{\n+  tree method_list_template, initlist, decl;\n+  int size;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  char buf[BUFSIZE];\n+\n+  if (!chain || !prefix)\n+    return NULL_TREE;\n+\n+  if (!objc_method_prototype_template)\n+    objc_method_prototype_template = build_method_prototype_template ();\n+  \n+  size = list_length (chain);\n+  method_list_template = \n+\tbuild_method_prototype_list_template (objc_method_prototype_template,\n+\t\t\t\t\t      size);\n+  snprintf (buf, BUFSIZE, \"%s_%s\", prefix, \n+\t    IDENTIFIER_POINTER (PROTOCOL_NAME (protocol)));\n+\n+  decl = start_var_decl (method_list_template, buf);\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n+  initlist = \n+\tbuild_descriptor_table_initializer (objc_method_prototype_template,\n+\t\t\t\t\t    chain);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  finish_var_decl (decl, objc_build_constructor (method_list_template, v));\n+  return decl;\n+}\n+\n+/* For each protocol which was referenced either from a @protocol()\n+   expression, or because a class/category implements it (then a\n+   pointer to the protocol is stored in the struct describing the\n+   class/category), we create a statically allocated instance of the\n+   Protocol class.  The code is written in such a way as to generate\n+   as few Protocol objects as possible; we generate a unique Protocol\n+   instance for each protocol, and we don't generate a Protocol\n+   instance if the protocol is never referenced (either from a\n+   @protocol() or from a class/category implementation).  These\n+   statically allocated objects can be referred to via the static\n+   (that is, private to this module) symbols _OBJC_PROTOCOL_n.\n+\n+   The statically allocated Protocol objects that we generate here\n+   need to be fixed up at runtime in order to be used: the 'isa'\n+   pointer of the objects need to be set up to point to the 'Protocol'\n+   class, as known at runtime.\n+\n+   The GNU runtime fixes up all protocols before user code from the module\n+   is executed; it requires pointers to those symbols\n+   to be put in the objc_symtab (which is then passed as argument to\n+   the function __objc_exec_class() which the compiler sets up to be\n+   executed automatically when the module is loaded); setup of those\n+   Protocol objects happen in two ways in the GNU runtime: all\n+   Protocol objects referred to by a class or category implementation\n+   are fixed up when the class/category is loaded; all Protocol\n+   objects referred to by a @protocol() expression are added by the\n+   compiler to the list of statically allocated instances to fixup\n+   (the same list holding the statically allocated constant string\n+   objects).  Because, as explained above, the compiler generates as\n+   few Protocol objects as possible, some Protocol object might end up\n+   being referenced multiple times when compiled with the GNU runtime,\n+   and end up being fixed up multiple times at runtime initialization.\n+   But that doesn't hurt, it's just a little inefficient.  */\n+\n+static void\n+generate_protocols (void)\n+{\n+  tree p, encoding;\n+  tree decl;\n+  tree initlist, protocol_name_expr, refs_decl, refs_expr;\n+\n+  /* If a protocol was directly referenced, pull in indirect references.  */\n+  for (p = protocol_chain; p; p = TREE_CHAIN (p))\n+    if (PROTOCOL_FORWARD_DECL (p) && PROTOCOL_LIST (p))\n+      generate_protocol_references (PROTOCOL_LIST (p));\n+\n+  for (p = protocol_chain; p; p = TREE_CHAIN (p))\n+    {\n+      tree nst_methods = PROTOCOL_NST_METHODS (p);\n+      tree cls_methods = PROTOCOL_CLS_METHODS (p);\n+\n+      /* If protocol wasn't referenced, don't generate any code.  */\n+      decl = PROTOCOL_FORWARD_DECL (p);\n+\n+      if (!decl)\n+\tcontinue;\n+\n+      /* Make sure we link in the Protocol class.  */\n+      add_class_reference (get_identifier (PROTOCOL_OBJECT_CLASS_NAME));\n+\n+      while (nst_methods)\n+\t{\n+\t  if (! METHOD_ENCODING (nst_methods))\n+\t    {\n+\t      encoding = encode_method_prototype (nst_methods);\n+\t      METHOD_ENCODING (nst_methods) = encoding;\n+\t    }\n+\t  nst_methods = DECL_CHAIN (nst_methods);\n+\t}\n+\n+      UOBJC_INSTANCE_METHODS_decl = \n+\tgenerate_v1_meth_descriptor_table (PROTOCOL_NST_METHODS (p), p,\n+\t\t\t\t\t   \"_OBJC_PROTOCOL_INSTANCE_METHODS\");\n+\n+      while (cls_methods)\n+\t{\n+\t  if (! METHOD_ENCODING (cls_methods))\n+\t    {\n+\t      encoding = encode_method_prototype (cls_methods);\n+\t      METHOD_ENCODING (cls_methods) = encoding;\n+\t    }\n+\n+\t  cls_methods = DECL_CHAIN (cls_methods);\n+\t}\n+\n+      UOBJC_CLASS_METHODS_decl = \n+\tgenerate_v1_meth_descriptor_table (PROTOCOL_CLS_METHODS (p), p,\n+\t\t\t\t\t   \"_OBJC_PROTOCOL_CLASS_METHODS\");\n+/*      generate_method_descriptors (p);*/\n+\n+      if (PROTOCOL_LIST (p))\n+\trefs_decl = generate_protocol_list (p, NULL_TREE);\n+      else\n+\trefs_decl = 0;\n+\n+      /* static struct objc_protocol _OBJC_PROTOCOL_<mumble>; */\n+      protocol_name_expr = add_objc_string (PROTOCOL_NAME (p), class_names);\n+\n+      if (refs_decl)\n+\trefs_expr = convert (build_pointer_type (build_pointer_type\n+\t\t\t\t\t\t (objc_protocol_template)),\n+\t\t\t     build_unary_op (input_location,\n+\t\t\t\t\t     ADDR_EXPR, refs_decl, 0));\n+      else\n+\trefs_expr = build_int_cst (NULL_TREE, 0);\n+\n+      /* UOBJC_INSTANCE_METHODS_decl/UOBJC_CLASS_METHODS_decl are set\n+\t by generate_method_descriptors, which is called above.  */\n+      initlist = build_protocol_initializer (TREE_TYPE (decl),\n+\t\t\t\t\t     protocol_name_expr, refs_expr,\n+\t\t\t\t\t     UOBJC_INSTANCE_METHODS_decl,\n+\t\t\t\t\t     UOBJC_CLASS_METHODS_decl);\n+      finish_var_decl (decl, initlist);\n+    }\n+}\n+\n+static tree\n+generate_dispatch_table (tree chain, const char *name)\n+{\n+  tree decl, method_list_template, initlist;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  int size = list_length (chain);\n+\n+  if (!objc_method_template)\n+    objc_method_template = build_method_template ();\n+\n+  method_list_template = build_method_list_template (objc_method_template,\n+\t\t\t\t\t\t     size);\n+  initlist = build_dispatch_table_initializer (objc_method_template, chain);\n+\n+  decl = start_var_decl (method_list_template, name);\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  build_int_cst (integer_type_node, size));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n+\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  finish_var_decl (decl,\n+\t\t   objc_build_constructor (TREE_TYPE (decl), v));\n+\n+  return decl;\n+}\n+\n+/* Init a category.  */\n+static tree\n+build_category_initializer (tree type, tree cat_name, tree class_name,\n+\t\t\t    tree inst_methods, tree class_methods,\n+\t\t\t    tree protocol_list)\n+{\n+  tree expr, ltyp;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  /* TODO: pass the loc in or find it from args.  */\n+  /* TODO: pass the loc in or find it from args.  */\n+  loc = UNKNOWN_LOCATION;\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, cat_name);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, class_name);\n+\n+  ltyp = objc_method_list_ptr;\n+  if (inst_methods)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, inst_methods, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  if (class_methods)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, class_methods, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  /* protocol_list = */\n+  ltyp = build_pointer_type (build_pointer_type (objc_protocol_template));\n+  if (protocol_list)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, protocol_list, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  return objc_build_constructor (type, v);\n+}\n+\n+/* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */\n+\n+static void\n+generate_category (struct imp_entry *impent)\n+{\n+  tree initlist, cat_name_expr, class_name_expr;\n+  tree protocol_decl, category, cat_decl;\n+  tree inst_methods = NULL_TREE, class_methods = NULL_TREE;\n+  tree cat = impent->imp_context;\n+  char buf[BUFSIZE];\n+\n+  cat_decl = impent->class_decl;\n+\n+  add_class_reference (CLASS_NAME (cat));\n+  cat_name_expr = add_objc_string (CLASS_SUPER_NAME (cat), class_names);\n+\n+  class_name_expr = add_objc_string (CLASS_NAME (cat), class_names);\n+\n+  category = lookup_category (impent->imp_template, CLASS_SUPER_NAME (cat));\n+\n+  if (category && CLASS_PROTOCOL_LIST (category))\n+    {\n+      generate_protocol_references (CLASS_PROTOCOL_LIST (category));\n+      protocol_decl = generate_protocol_list (category, cat);\n+    }\n+  else\n+    protocol_decl = 0;\n+\n+  if (CLASS_NST_METHODS (cat))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryInstanceMethods_%s_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (cat)),\n+\t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (cat)));\n+      inst_methods = generate_dispatch_table (CLASS_NST_METHODS (cat), buf);\n+    }\n+\n+  if (CLASS_CLS_METHODS (cat))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryClassMethods_%s_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (cat)),\n+\t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (cat)));\n+      class_methods = generate_dispatch_table (CLASS_CLS_METHODS (cat), buf);\n+    }\n+\n+  initlist = build_category_initializer (TREE_TYPE (cat_decl),\n+\t\t\t\t\t cat_name_expr, class_name_expr,\n+\t\t\t\t\t inst_methods, class_methods,\n+\t\t\t\t\t protocol_decl);\n+  /* Finish and initialize the forward decl.  */\n+  finish_var_decl (cat_decl, initlist);\n+  impent->class_decl = cat_decl;\n+}\n+\n+/* struct _objc_class {\n+     struct objc_class *isa;\n+     struct objc_class *super_class;\n+     char *name;\n+     long version;\n+     long info;\n+     long instance_size;\n+     struct objc_ivar_list *ivars;\n+     struct objc_method_list *methods;\n+     if (flag_next_runtime)\n+       struct objc_cache *cache;\n+     else {\n+       struct sarray *dtable;\n+       struct objc_class *subclass_list;\n+       struct objc_class *sibling_class;\n+     }\n+     struct objc_protocol_list *protocols;\n+     if (flag_next_runtime)\n+       void *sel_id;\n+     void *gc_object_type;\n+   };  */\n+\n+static tree\n+build_shared_structure_initializer (tree type, tree isa, tree super,\n+\t\t\t\t    tree name, tree size, int status,\n+\t\t\t\t    tree dispatch_table, tree ivar_list,\n+\t\t\t\t    tree protocol_list)\n+{\n+  tree expr, ltyp;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  /* isa = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, isa);\n+\n+  /* super_class = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, super);\n+\n+  /* name = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, default_conversion (name));\n+\n+  /* version = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+                          build_int_cst (long_integer_type_node, 0));\n+\n+  /* info = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+                          build_int_cst (long_integer_type_node, status));\n+\n+  /* instance_size = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+                          convert (long_integer_type_node, size));\n+\n+  /* objc_ivar_list = */\n+  if (!ivar_list)\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t    build_int_cst (objc_ivar_list_ptr, 0));\n+  else\n+    {\n+      expr = convert (objc_ivar_list_ptr,\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      ivar_list, 0));\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+    }\n+\n+  /* objc_method_list = */\n+  if (!dispatch_table)\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t   convert (objc_method_list_ptr, null_pointer_node));\n+  else\n+    {\n+      expr = convert (objc_method_list_ptr,\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      dispatch_table, 0));\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+    }\n+\n+  if (flag_next_runtime)\n+    {\n+      ltyp = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t   get_identifier (\"objc_cache\")));\n+      /* method_cache = */\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, convert (ltyp, null_pointer_node));\n+    }\n+  else\n+    {\n+      /* dtable = */\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+\n+      /* subclass_list = */\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+\n+      /* sibling_class = */\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+    }\n+\n+  /* protocol_list = */\n+  ltyp = build_pointer_type (build_pointer_type (objc_protocol_template));\n+  if (! protocol_list)\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (ltyp, 0));\n+  else\n+    {\n+      expr = convert (ltyp,\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      protocol_list, 0));\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+    }\n+\n+  if (flag_next_runtime)\n+    /* sel_id = NULL */\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+\n+  /* gc_object_type = NULL */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+\n+  return objc_build_constructor (type, v);\n+}\n+\n+\n+static tree\n+generate_ivars_list (tree chain, const char *name)\n+{\n+  tree initlist, ivar_list_template, decl;\n+  int size;\n+  VEC(constructor_elt,gc) *inits = NULL;\n+\n+  if (!chain)\n+    return NULL_TREE;\n+\n+  if (!objc_ivar_template)\n+    objc_ivar_template = build_ivar_template ();\n+\n+  size = ivar_list_length (chain);\n+\n+  generating_instance_variables = 1;\n+  ivar_list_template = build_ivar_list_template (objc_ivar_template, size);\n+  initlist = build_ivar_list_initializer (objc_ivar_template, chain);\n+  generating_instance_variables = 0;\n+\n+  decl = start_var_decl (ivar_list_template, name);\n+\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, build_int_cst (NULL_TREE, size));\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, initlist);\n+\n+  OBJCMETA (decl, objc_meta, meta_base);\n+  finish_var_decl (decl,\n+\t\t   objc_build_constructor (TREE_TYPE (decl), inits));\n+\n+  return decl;\n+}\n+\n+/* static struct objc_class _OBJC_METACLASS_Foo={ ... };\n+   static struct objc_class _OBJC_CLASS_Foo={ ... };  */\n+\n+static void\n+generate_class_structures (struct imp_entry *impent)\n+{\n+  tree name_expr, super_expr, root_expr, class_decl, meta_decl;\n+  tree my_root_id, my_super_id;\n+  tree cast_type, initlist, protocol_decl;\n+  tree inst_methods = NULL_TREE, class_methods = NULL_TREE;\n+  tree chain, inst_ivars = NULL_TREE, class_ivars = NULL_TREE;\n+  location_t loc;\n+  char buf[BUFSIZE];\n+  int cls_flags = 0 ;\n+  \n+/*  objc_implementation_context = impent->imp_context;\n+  implementation_template = impent->imp_template;*/\n+  class_decl = impent->class_decl;\n+  meta_decl = impent->meta_decl;\n+/*  UOBJC_CLASS_decl = impent->class_decl;\n+  UOBJC_METACLASS_decl = impent->meta_decl;*/\n+  \n+  loc = DECL_SOURCE_LOCATION (impent->class_decl);\n+\n+  my_super_id = CLASS_SUPER_NAME (impent->imp_template);\n+  if (my_super_id)\n+    {\n+      add_class_reference (my_super_id);\n+\n+      /* Compute \"my_root_id\" - this is required for code generation.\n+         the \"isa\" for all meta class structures points to the root of\n+         the inheritance hierarchy (e.g. \"__Object\")...  */\n+      my_root_id = my_super_id;\n+      do\n+\t{\n+\t  tree my_root_int = lookup_interface (my_root_id);\n+\n+\t  if (my_root_int && CLASS_SUPER_NAME (my_root_int))\n+\t    my_root_id = CLASS_SUPER_NAME (my_root_int);\n+\t  else\n+\t    break;\n+\t}\n+      while (1);\n+    }\n+  else\n+    /* No super class.  */\n+    my_root_id = CLASS_NAME (impent->imp_template);\n+\n+  cast_type = build_pointer_type (objc_class_template);\n+  name_expr = add_objc_string (CLASS_NAME (impent->imp_template),\n+\t\t\t       class_names);\n+\n+  /* Install class `isa' and `super' pointers at runtime.  */\n+  if (my_super_id)\n+    super_expr = add_objc_string (my_super_id, class_names);\n+  else\n+    super_expr = null_pointer_node;\n+    \n+  super_expr = build_c_cast (loc, cast_type, super_expr);\n+\n+  root_expr = add_objc_string (my_root_id, class_names);\n+  root_expr = build_c_cast (loc, cast_type, root_expr);\n+\n+  if (CLASS_PROTOCOL_LIST (impent->imp_template))\n+    {\n+      generate_protocol_references (CLASS_PROTOCOL_LIST (impent->imp_template));\n+      protocol_decl = generate_protocol_list (impent->imp_template,\n+\t\t\t\t\t      impent->imp_context);\n+    }\n+  else\n+    protocol_decl = NULL_TREE;\n+\n+  if (CLASS_CLS_METHODS (impent->imp_context))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassMethods_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      class_methods = generate_dispatch_table (CLASS_CLS_METHODS (impent->imp_context),\n+\t\t\t\t\t       buf);\n+    }\n+\n+  if (CLASS_SUPER_NAME (impent->imp_template) == NULL_TREE\n+      && (chain = TYPE_FIELDS (objc_class_template)))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassIvars_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      class_ivars = generate_ivars_list (chain, buf);\n+    }\n+\n+  /* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */\n+\n+  initlist = \n+\tbuild_shared_structure_initializer \n+\t\t\t(TREE_TYPE (meta_decl),\n+\t\t\troot_expr, super_expr, name_expr,\n+\t\t\tconvert (integer_type_node, \n+\t\t\t\tTYPE_SIZE_UNIT (objc_class_template)),\n+\t\t\tCLS_META, class_methods, class_ivars,\n+\t\t\tprotocol_decl);\n+\n+  finish_var_decl (meta_decl, initlist);\n+  impent->meta_decl = meta_decl;\n+\n+  /* static struct objc_class _OBJC_CLASS_Foo={ ... }; */\n+  if (CLASS_NST_METHODS (impent->imp_context))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_InstanceMethods_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      inst_methods = generate_dispatch_table (CLASS_NST_METHODS (impent->imp_context),\n+\t\t\t\t\t      buf);\n+    }\n+\n+  if ((chain = CLASS_IVARS (impent->imp_template)))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_InstanceIvars_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      inst_ivars = generate_ivars_list (chain, buf);\n+    }\n+\n+  initlist = \n+\tbuild_shared_structure_initializer \n+\t\t(TREE_TYPE (class_decl),\n+\t\tbuild_unary_op (loc, ADDR_EXPR, meta_decl, 0),\n+\t\tsuper_expr, name_expr,\n+\t\tconvert (integer_type_node,\n+\t\t\t TYPE_SIZE_UNIT (CLASS_STATIC_TEMPLATE\n+\t\t\t\t\t(impent->imp_template))),\n+\t\tCLS_FACTORY | cls_flags, inst_methods, inst_ivars,\n+\t\tprotocol_decl);\n+\n+  finish_var_decl (class_decl, initlist);\n+  impent->class_decl = class_decl;\n+}\n+\n+/* --- Output GNU Metadata --- */\n+\n+/* TODO: Make this into an array of refs.  */\n+static void\n+handle_class_ref (tree chain)\n+{\n+  const char *name = IDENTIFIER_POINTER (TREE_VALUE (chain));\n+  char *string = (char *) alloca (strlen (name) + 30);\n+  tree decl;\n+  tree exp;\n+\n+  sprintf (string, \"__objc_class_name_%s\", name);\n+\n+  /* Make a decl for this name, so we can use its address in a tree.  */\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (string), TREE_TYPE (integer_zero_node));\n+  DECL_EXTERNAL (decl) = 1;\n+  TREE_PUBLIC (decl) = 1;\n+  DECL_CONTEXT (decl) = NULL_TREE;\n+  finish_var_decl (decl, 0);\n+\n+  /* Make a decl for the address.  */\n+  sprintf (string, \"__objc_class_ref_%s\", name);\n+  exp = build1 (ADDR_EXPR, string_type_node, decl);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (string), string_type_node);\n+  TREE_STATIC (decl) = 1;\n+  TREE_USED (decl) = 1;\n+  DECL_READ_P (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_INITIAL (decl) = error_mark_node;\n+ \n+  /* We must force the reference.  */\n+  DECL_PRESERVE_P (decl) = 1;\n+\n+  DECL_CONTEXT (decl) = NULL_TREE;\n+  finish_var_decl (decl, exp);\n+}\n+\n+static tree\n+get_proto_encoding (tree proto)\n+{\n+  tree encoding;\n+  if (proto)\n+    {\n+      if (! METHOD_ENCODING (proto))\n+\t{\n+\t  encoding = encode_method_prototype (proto);\n+\t  METHOD_ENCODING (proto) = encoding;\n+\t}\n+      else\n+\tencoding = METHOD_ENCODING (proto);\n+\n+      return add_objc_string (encoding, meth_var_types);\n+    }\n+  else\n+    return build_int_cst (NULL_TREE, 0);\n+}\n+\n+static void\n+build_gnu_selector_translation_table (void)\n+{\n+  tree chain, expr;\n+  VEC(constructor_elt,gc) *inits = NULL;\n+  VEC(constructor_elt,gc) *v ;\n+\n+  /* Cause the selector table (previously forward-declared)\n+     to be actually output.  */\n+\n+  for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      tree encoding;\n+      if (warn_selector)\n+\t{\n+\t  /* TODO: improve on the location for the diagnostic.  */\n+\t  location_t loc = input_location;\n+\t  diagnose_missing_method (TREE_VALUE (chain), loc);\n+\t}\n+\n+      v = NULL;\n+      expr = build_selector (TREE_VALUE (chain));\n+      encoding = get_proto_encoding (TREE_PURPOSE (chain));\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, encoding);\n+      expr = objc_build_constructor (objc_selector_template, v);\n+      \n+      CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n+    } /* each element in the chain */\n+\n+  /* List terminator.  */\n+  v = NULL;\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n+  expr = objc_build_constructor (objc_selector_template, v);\n+\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n+  expr = objc_build_constructor (TREE_TYPE (UOBJC_SELECTOR_TABLE_decl),\n+\t\t\t\t     inits);\n+  finish_var_decl (UOBJC_SELECTOR_TABLE_decl, expr);\n+}\n+\n+/* Output references to all statically allocated objects.  Return the DECL\n+   for the array built.  */\n+\n+static void\n+generate_static_references (void)\n+{\n+  tree expr = NULL_TREE;\n+  tree class_name, klass, decl;\n+  tree cl_chain, in_chain, type\n+    = build_array_type (build_pointer_type (void_type_node), NULL_TREE);\n+  int num_inst, num_class;\n+  char buf[BUFSIZE];\n+  VEC(constructor_elt,gc) *decls = NULL;\n+\n+  if (flag_next_runtime)\n+    gcc_unreachable ();\n+\n+  for (cl_chain = objc_static_instances, num_class = 0;\n+       cl_chain; cl_chain = TREE_CHAIN (cl_chain), num_class++)\n+    {\n+      VEC(constructor_elt,gc) *v = NULL;\n+\n+      for (num_inst = 0, in_chain = TREE_PURPOSE (cl_chain);\n+\t   in_chain; num_inst++, in_chain = TREE_CHAIN (in_chain));\n+\n+      snprintf (buf, BUFSIZE, \"_OBJC_STATIC_INSTANCES_%d\", num_class);\n+      decl = start_var_decl (type, buf);\n+\n+      /* Output {class_name, ...}.  */\n+      klass = TREE_VALUE (cl_chain);\n+      class_name = get_objc_string_decl (OBJC_TYPE_NAME (klass), class_names);\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t      build_unary_op (input_location, \n+\t\t\t\t\t      ADDR_EXPR, class_name, 1));\n+\n+      /* Output {..., instance, ...}.  */\n+      for (in_chain = TREE_PURPOSE (cl_chain);\n+\t   in_chain; in_chain = TREE_CHAIN (in_chain))\n+\t{\n+\t  expr = build_unary_op (input_location,\n+\t\t\t\t ADDR_EXPR, TREE_VALUE (in_chain), 1);\n+\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\t}\n+\n+      /* Output {..., NULL}.  */\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+\n+      expr = objc_build_constructor (TREE_TYPE (decl), v);\n+      OBJCMETA (decl, objc_meta, meta_base);\n+      finish_var_decl (decl, expr);\n+      CONSTRUCTOR_APPEND_ELT (decls, NULL_TREE,\n+\t\t\t      build_unary_op (input_location,\n+\t\t\t\t\t      ADDR_EXPR, decl, 1));\n+    }\n+\n+  CONSTRUCTOR_APPEND_ELT (decls, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+  expr = objc_build_constructor (type, decls);\n+  static_instances_decl = start_var_decl (type, \"_OBJC_STATIC_INSTANCES\");\n+  OBJCMETA (static_instances_decl, objc_meta, meta_base);\n+  finish_var_decl (static_instances_decl, expr);\n+}\n+\n+/* Create the initial value for the `defs' field of _objc_symtab.\n+   This is a CONSTRUCTOR.  */\n+\n+static tree\n+init_def_list (tree type)\n+{\n+  tree expr;\n+  struct imp_entry *impent;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  if (imp_count)\n+    for (impent = imp_list; impent; impent = impent->next)\n+      {\n+\tif (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)\n+\t  {\n+\t    loc = DECL_SOURCE_LOCATION (impent->class_decl);\n+\t    expr = build_unary_op (loc,\n+\t\t\t\t   ADDR_EXPR, impent->class_decl, 0);\n+\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\t  }\n+      }\n+\n+  if (cat_count)\n+    for (impent = imp_list; impent; impent = impent->next)\n+      {\n+\tif (TREE_CODE (impent->imp_context) == CATEGORY_IMPLEMENTATION_TYPE)\n+\t  {\n+\t    loc = DECL_SOURCE_LOCATION (impent->class_decl);\n+\t    expr = build_unary_op (loc,\n+\t\t\t\t   ADDR_EXPR, impent->class_decl, 0);\n+\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\t  }\n+      }\n+\n+  loc = UNKNOWN_LOCATION;\n+  /* statics = { ..., _OBJC_STATIC_INSTANCES, ... }  */\n+  if (static_instances_decl)\n+    expr = build_unary_op (loc, ADDR_EXPR, static_instances_decl, 0);\n+  else\n+    expr = integer_zero_node;\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  return objc_build_constructor (type, v);\n+}\n+\n+/* Take care of defining and initializing _OBJC_SYMBOLS.  */\n+\n+/* Predefine the following data type:\n+\n+   struct _objc_symtab\n+   {\n+     long sel_ref_cnt;\n+     SEL *refs;\n+     short cls_def_cnt;\n+     short cat_def_cnt;\n+     void *defs[cls_def_cnt + cat_def_cnt];\n+   }; */\n+\n+static void\n+build_objc_symtab_template (void)\n+{\n+  tree fields, array_type, *chain = NULL;\n+  int index;\n+\n+  objc_symtab_template = objc_start_struct (get_identifier (UTAG_SYMTAB));\n+\n+  /* long sel_ref_cnt; */\n+  fields = add_field_decl (long_integer_type_node, \"sel_ref_cnt\", &chain);\n+\n+  /* SEL *refs; */\n+  add_field_decl (build_pointer_type (objc_selector_type), \"refs\", &chain);\n+\n+  /* short cls_def_cnt; */\n+  add_field_decl (short_integer_type_node, \"cls_def_cnt\", &chain);\n+\n+  /* short cat_def_cnt; */\n+  add_field_decl (short_integer_type_node, \"cat_def_cnt\", &chain);\n+\n+  if (TARGET_64BIT)\n+    add_field_decl (integer_type_node, \"_explicit_padder\", &chain);\n+\n+  /* void *defs[imp_count + cat_count (+ 1)]; */\n+  /* NB: The index is one less than the size of the array.  */\n+  index = imp_count + cat_count;\n+  array_type = build_sized_array_type (ptr_type_node, index + 1);\n+  add_field_decl (array_type, \"defs\", &chain);\n+\n+  objc_finish_struct (objc_symtab_template, fields);\n+}\n+/* Construct the initial value for all of _objc_symtab.  */\n+\n+static tree\n+init_objc_symtab (tree type)\n+{\n+  tree field, expr, ltyp;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  loc = UNKNOWN_LOCATION;\n+\n+  /* sel_ref_cnt = { ..., 5, ... } */\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t  build_int_cst (long_integer_type_node, 0));\n+\n+  /* refs = { ..., _OBJC_SELECTOR_TABLE, ... } */\n+\n+  ltyp = build_pointer_type (objc_selector_type);\n+  if (sel_ref_chain)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, \n+\t\t\t\t\t  UOBJC_SELECTOR_TABLE_decl, 1));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  /* cls_def_cnt = { ..., 5, ... } */\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  build_int_cst (short_integer_type_node, imp_count));\n+\n+  /* cat_def_cnt = { ..., 5, ... } */\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  build_int_cst (short_integer_type_node, cat_count));\n+  if (TARGET_64BIT)\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t  build_int_cst (integer_type_node, 0));\n+\n+  /* cls_def = { ..., { &Foo, &Bar, ...}, ... } */\n+\n+  field = TYPE_FIELDS (type);\n+  if (TARGET_64BIT)\n+    field = DECL_CHAIN (field);\n+  field = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (field))));\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init_def_list (TREE_TYPE (field)));\n+\n+  return objc_build_constructor (type, v);\n+}\n+\n+/* Create the declaration of _OBJC_SYMBOLS, with type `struct _objc_symtab'\n+   and initialized appropriately.  */\n+\n+static void\n+generate_objc_symtab_decl (void)\n+{\n+  build_objc_symtab_template ();\n+  UOBJC_SYMBOLS_decl = start_var_decl (objc_symtab_template, \"_OBJC_SYMBOLS\");\n+  OBJCMETA (UOBJC_SYMBOLS_decl, objc_meta, meta_base);\n+  finish_var_decl (UOBJC_SYMBOLS_decl,\n+\t\t   init_objc_symtab (TREE_TYPE (UOBJC_SYMBOLS_decl)));\n+}\n+\n+static void\n+objc_generate_v1_gnu_metadata (void)\n+{\n+  struct imp_entry *impent;\n+  tree chain;\n+\n+  /* Process the static instances here because initialization of objc_symtab\n+     depends on them.  */\n+  if (objc_static_instances)\n+    generate_static_references ();\n+\n+  objc_implementation_context =\n+  implementation_template =\n+  UOBJC_CLASS_decl =\n+  UOBJC_METACLASS_decl = NULL_TREE;\n+\n+  for (impent = imp_list; impent; impent = impent->next)\n+    {\n+      /* If -gen-decls is present, Dump the @interface of each class.\n+\t TODO: Dump the classes in the  order they were found, rather than in\n+\t reverse order as we are doing now.  */\n+      if (flag_gen_declaration)\n+\tdump_interface (gen_declaration_file, impent->imp_context);\n+\n+      /* all of the following reference the string pool...  */\n+      if (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)\n+\tgenerate_class_structures (impent);\n+      else\n+\tgenerate_category (impent);\n+    }\n+\n+  /* If we are using an array of selectors, we must always\n+     finish up the array decl even if no selectors were used.  */\n+  build_gnu_selector_translation_table ();\n+\n+  if (protocol_chain)\n+    generate_protocols ();\n+\n+  /* Arrange for ObjC data structures to be initialized at run time.  */\n+  generate_objc_symtab_decl ();\n+  /* Make sure that the meta-data are identified as being GNU-runtime.  */\n+  build_module_descriptor (OBJC_VERSION, \n+\t\t\t   build_tree_list (objc_meta, meta_base));\n+  build_module_initializer_routine ();\n+\n+  /* Dump the class references.  This forces the appropriate classes\n+     to be linked into the executable image, preserving unix archive\n+     semantics.  This can be removed when we move to a more dynamically\n+     linked environment.  */\n+\n+  for (chain = cls_ref_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      handle_class_ref (chain);\n+      if (TREE_PURPOSE (chain))\n+\tgenerate_classref_translation_entry (chain);\n+    }\n+\n+  for (impent = imp_list; impent; impent = impent->next)\n+    handle_impent (impent);\n+\n+  generate_strings ();\n+}\n+\n+/* --- exceptions --- */\n+\n+static GTY(()) tree objc_eh_personality_decl;\n+\n+static tree\n+objc_eh_runtime_type (tree type)\n+{\n+  tree ident, eh_id, decl, str;\n+\n+  if (type == error_mark_node\n+      || errorcount || sorrycount)\n+    {\n+      /* Use 'ErrorMarkNode' as class name when error_mark_node is found\n+\t to prevent an ICE.  Note that we know that the compiler will\n+\t terminate with an error and this 'ErrorMarkNode' class name will\n+\t never be actually used.  */\n+      ident = get_identifier (\"ErrorMarkNode\");\n+      goto make_err_class;\n+    }\n+\n+  if (POINTER_TYPE_P (type) && objc_is_object_id (TREE_TYPE (type)))\n+    /* We don't want to identify 'id' for GNU. Instead, build a 0\n+       entry in the exceptions table.  */\n+    return null_pointer_node; \n+\n+  if (!POINTER_TYPE_P (type) || !TYPED_OBJECT (TREE_TYPE (type)))\n+    {\n+#ifdef OBJCPLUS\n+      /* This routine is also called for c++ catch clauses; in which case,\n+\t we use the c++ typeinfo decl. */\n+      return build_eh_type_type (type);\n+#else\n+      error (\"non-objective-c type '%T' cannot be caught\", type);\n+      ident = get_identifier (\"ErrorMarkNode\");\n+      goto make_err_class;\n+#endif\n+    }\n+  else\n+    ident = OBJC_TYPE_NAME (TREE_TYPE (type));\n+\n+make_err_class:\n+  /* If this class was already referenced, then it will be output during\n+     meta-data emission, so we don't need to do it here.  */\n+  decl = get_objc_string_decl (ident, class_names);\n+  eh_id = add_objc_string (ident, class_names);\n+  if (!decl)\n+    {\n+      /* Not found ... so we need to build it - from the freshly-entered id.  */\n+      decl = get_objc_string_decl (ident, class_names);\n+      str = my_build_string (IDENTIFIER_LENGTH (ident) + 1,\n+\t\t\t     IDENTIFIER_POINTER (ident));\n+      /* We have to finalize this var here, because this might be called after\n+\t all the other metadata strings have been emitted.  */\n+      finish_var_decl (decl, str);\n+    }\n+  return eh_id;\n+}\n+\n+static tree\n+objc_eh_personality (void)\n+{\n+  if (!objc_eh_personality_decl)\n+#ifndef OBJCPLUS\n+    objc_eh_personality_decl = build_personality_function  (\"gnu_objc\");\n+#else\n+    objc_eh_personality_decl = build_personality_function  (\"gxx\");\n+#endif\n+  return objc_eh_personality_decl;\n+}\n+\n+/* -- interfaces --- */\n+\n+static tree\n+build_throw_stmt (location_t loc, tree throw_expr, bool rethrown ATTRIBUTE_UNUSED)\n+{\n+  tree t;\n+  VEC(tree, gc) *parms = VEC_alloc (tree, gc, 1);\n+  /* A throw is just a call to the runtime throw function with the\n+     object as a parameter.  */\n+  VEC_quick_push (tree, parms, throw_expr);\n+  t = build_function_call_vec (loc, objc_exception_throw_decl, parms, NULL);\n+  VEC_free (tree, gc, parms);\n+  return add_stmt (t);\n+}\n+\n+/* Build __builtin_eh_pointer.  */\n+\n+static tree\n+objc_build_exc_ptr (struct objc_try_context **x ATTRIBUTE_UNUSED)\n+{\n+  tree t;\n+  t = built_in_decls[BUILT_IN_EH_POINTER];\n+  t = build_call_expr (t, 1, integer_zero_node);\n+  return fold_convert (objc_object_type, t);\n+}\n+\n+static tree \n+begin_catch (struct objc_try_context **cur_try_context, tree type,\n+\t     tree decl, tree compound, bool ellipsis ATTRIBUTE_UNUSED)\n+{\n+  tree t;\n+  /* Record the data for the catch in the try context so that we can\n+     finalize it later.  */\n+  if (ellipsis)\n+    t = build_stmt (input_location, CATCH_EXPR, NULL, compound);\n+  else\n+    t = build_stmt (input_location, CATCH_EXPR, type, compound);\n+  (*cur_try_context)->current_catch = t;\n+\n+  /* Initialize the decl from the EXC_PTR_EXPR we get from the runtime.  */\n+  t = objc_build_exc_ptr (cur_try_context);\n+  t = convert (TREE_TYPE (decl), t);\n+  return build2 (MODIFY_EXPR, void_type_node, decl, t);\n+}\n+\n+static void \n+finish_catch (struct objc_try_context **cur_try_context, tree current_catch)\n+{\n+  append_to_statement_list (current_catch, &((*cur_try_context)->catch_list));\n+}\n+\n+static tree \n+finish_try_stmt (struct objc_try_context **cur_try_context)\n+{\n+  struct objc_try_context *c = *cur_try_context;\n+  tree stmt = c->try_body;\n+  if (c->catch_list)\n+    stmt = build_stmt (c->try_locus, TRY_CATCH_EXPR, stmt, c->catch_list);\n+  if (c->finally_body)\n+    stmt = build_stmt (c->try_locus, TRY_FINALLY_EXPR, stmt, c->finally_body);\n+  return stmt;\n+}\n+\n+#include \"gt-objc-objc-gnu-runtime-abi-01.h\""}, {"sha": "fd65776598df39ab6c58abd41244c8b574fadccf", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,5 +1,5 @@\n /* Language-dependent hooks for Objective-C.\n-   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2010\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Ziemowit Laski  <zlaski@apple.com>\n \n@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n #include \"c-objc-common.h\"\n+#include \"c-lang.h\"\n \n enum c_language_kind c_language = clk_objc;\n static void objc_init_ts (void);\n@@ -51,13 +52,6 @@ static void objc_init_ts (void);\n #undef LANG_HOOKS_INIT_TS\n #define LANG_HOOKS_INIT_TS objc_init_ts\n \n-#ifndef OBJCPLUS\n-#undef LANG_HOOKS_EH_PERSONALITY\n-#define LANG_HOOKS_EH_PERSONALITY objc_eh_personality\n-#undef LANG_HOOKS_EH_RUNTIME_TYPE\n-#define LANG_HOOKS_EH_RUNTIME_TYPE objc_eh_runtime_type\n-#endif\n-\n /* Each front end provides its own lang hook initializer.  */\n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "db0026ec60956fcaf7e8f0030df7eac9d995ca83", "filename": "gcc/objc/objc-next-metadata-tags.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-next-metadata-tags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-next-metadata-tags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-metadata-tags.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -0,0 +1,172 @@\n+/* Declarations for meta-data attribute tags.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Iain Sandoe \n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* These are identifiers used to flag meta-data attributes such that they\n+   survive LTO and might be placed in correct sections for the target.  */\n+\n+enum objc_runtime_tree_index\n+{\n+  OCTI_RT_OBJC_META,\n+  OCTI_RT_META_BASE,\n+  \n+  OCTI_RT_META_CLASS,\n+  OCTI_RT_META_METACLASS,\n+  OCTI_RT_META_CATEGORY,\n+  OCTI_RT_META_PROTOCOL,\n+  \n+  OCTI_RT_META_CLASS_CLS_VARS,\n+  OCTI_RT_META_CLASS_NST_VARS,\n+  \n+  OCTI_RT_META_CLASS_CLS_METH,\n+  OCTI_RT_META_CLASS_NST_METH,\n+  OCTI_RT_META_CATEG_CLS_METH,\n+  OCTI_RT_META_CATEG_NST_METH,\n+  OCTI_RT_META_PROTO_CLS_METH,\n+  OCTI_RT_META_PROTO_NST_METH,\n+  \n+  OCTI_RT_META_CLASS_PROT,\n+  OCTI_RT_META_CATEG_PROT,\n+  OCTI_RT_META_PROT_REFS,\n+  \n+  OCTI_RT_META_MSG_REFS,\n+  OCTI_RT_META_SEL_REFS,\n+  \n+  OCTI_RT_META_CLSLST_REFS,\n+  OCTI_RT_META_CLASS_REF,\n+  OCTI_RT_META_SUPER_REF,\n+  OCTI_RT_META_CLSLST_NLZY_LAB,\n+  OCTI_RT_META_CLSLST_LAB,\n+  OCTI_RT_META_LAB_PROTOLIST,\n+  OCTI_RT_META_LAB_NLZY_CAT,\n+  OCTI_RT_META_LAB_CAT,\n+  \n+  OCTI_RT_META_PROPERTY_LIST,\n+  OCTI_RT_META_PROTOCOL_EXT,\n+  OCTI_RT_META_CLASS_EXT,\n+  \n+  OCTI_RT_META_CLASS_NAME,\n+  OCTI_RT_META_METHD_NAME,\n+  OCTI_RT_META_METHD_TYPE,\n+  OCTI_RT_META_PROPN_ATTR,\n+  \n+  OCTI_RT_META_MODULES,\n+  OCTI_RT_META_SYMTAB,\n+  OCTI_RT_META_INFO,\n+  \n+  OCTI_RT_META_EHTYPE,\n+  \n+  OCTI_RT_META_CONST_STR,\n+\n+  OCTI_RT_META_MAX\n+};\n+\n+/* Tags for the META data so that the backend can put them in the correct\n+   sections for targets/runtimes (Darwin/NeXT) that require this.  \n+   This information also survives LTO - which might produce mixed language\n+   output.  */\n+\n+/* Objective-C meta data attribute tag */\n+#define objc_meta\tobjc_rt_trees[OCTI_RT_OBJC_META] \n+/* Attribute values, base = default section. */\n+#define meta_base\tobjc_rt_trees[OCTI_RT_META_BASE]\n+\n+  /* CLASS.  */\n+#define meta_class\tobjc_rt_trees[OCTI_RT_META_CLASS]\n+ /* METACLASS.  */\n+#define meta_metaclass\tobjc_rt_trees[OCTI_RT_META_METACLASS]\n+  /* CLASS.  */\n+#define meta_category\tobjc_rt_trees[OCTI_RT_META_CATEGORY]\n+  /* PROTOCOL.  */\n+#define meta_protocol\tobjc_rt_trees[OCTI_RT_META_PROTOCOL]\n+\n+ /* Class class vars section.  */\n+#define meta_clac_vars\tobjc_rt_trees[OCTI_RT_META_CLASS_CLS_VARS]\n+ /* Class instance vars section.  */\n+#define meta_clai_vars\tobjc_rt_trees[OCTI_RT_META_CLASS_NST_VARS]\n+ /* Class class methods section.  */\n+#define meta_clac_meth\tobjc_rt_trees[OCTI_RT_META_CLASS_CLS_METH]\n+ /* Class instance methods section.  */\n+#define meta_clai_meth\tobjc_rt_trees[OCTI_RT_META_CLASS_NST_METH]\n+ /* Category class methods section.  */\n+#define meta_catc_meth\tobjc_rt_trees[OCTI_RT_META_CATEG_CLS_METH]\n+ /* Category instance methods section.  */\n+#define meta_cati_meth\tobjc_rt_trees[OCTI_RT_META_CATEG_NST_METH]\n+#define meta_proto_cls_meth \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_PROTO_CLS_METH]\n+#define meta_proto_nst_meth \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_PROTO_NST_METH]\n+\n+ /* Class protocols.  */\n+#define meta_clas_prot\tobjc_rt_trees[OCTI_RT_META_CLASS_PROT]\n+ /* Category protocols.  */\n+#define meta_catg_prot\tobjc_rt_trees[OCTI_RT_META_CATEG_PROT]\n+ /* Protocol references.  */\n+#define meta_proto_ref\tobjc_rt_trees[OCTI_RT_META_PROT_REFS]\n+\n+ /* Message refs.  */\n+#define meta_mref\tobjc_rt_trees[OCTI_RT_META_MSG_REFS]\n+ /* Selector refs.  */\n+#define meta_sel_refs\tobjc_rt_trees[OCTI_RT_META_SEL_REFS]\n+\n+ /* Class list refs.  */\n+#define meta_class_ref\tobjc_rt_trees[OCTI_RT_META_CLSLST_REFS]\n+#define meta_class_reference \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_CLASS_REF]\n+#define meta_superclass_ref \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_SUPER_REF]\n+ /* Class list Label.  */\n+#define meta_label_classlist \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_CLSLST_LAB]\n+ /* Class list Label (non lazy).  */\n+#define meta_label_nonlazy_classlist \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_CLSLST_NLZY_LAB]\n+#define meta_label_categorylist \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_LAB_CAT]\n+#define meta_label_nonlazy_categorylist \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_LAB_NLZY_CAT]\n+\n+#define meta_label_protocollist \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_LAB_PROTOLIST]\n+\n+\n+/* V1 - property list.  */\n+#define meta_proplist\tobjc_rt_trees[OCTI_RT_META_PROPERTY_LIST]\n+#define meta_protocol_extension \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_PROTOCOL_EXT]\n+#define meta_class_extension \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_CLASS_EXT]\n+ /* String sections.  */\n+#define meta_class_name\tobjc_rt_trees[OCTI_RT_META_CLASS_NAME]\n+#define meta_meth_name\tobjc_rt_trees[OCTI_RT_META_METHD_NAME]\n+#define meta_meth_type\tobjc_rt_trees[OCTI_RT_META_METHD_TYPE]\n+#define meta_prop_name_attr \\\n+\t\t\tobjc_rt_trees[OCTI_RT_META_PROPN_ATTR]\n+\n+#define meta_modules\tobjc_rt_trees[OCTI_RT_META_MODULES]\n+#define meta_symtab\tobjc_rt_trees[OCTI_RT_META_SYMTAB]\n+#define meta_info\tobjc_rt_trees[OCTI_RT_META_INFO]\n+\n+#define meta_ehtype\tobjc_rt_trees[OCTI_RT_META_EHTYPE]\n+\n+#define meta_const_str\tobjc_rt_trees[OCTI_RT_META_CONST_STR]\n+\n+#define OBJCMETA(DECL,VERS,KIND)\t\t\t\t\t\\\n+  if (VERS)\t\t\t\t\t\t\t\t\\\n+    DECL_ATTRIBUTES (DECL) = build_tree_list ((VERS), (KIND));"}, {"sha": "2cfa862372f162dbd08ae4d155e0273387d5e7d3", "filename": "gcc/objc/objc-next-runtime-abi-01.c", "status": "added", "additions": 2969, "deletions": 0, "changes": 2969, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -0,0 +1,2969 @@\n+/* Next Runtime (ABI-0/1) private.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Iain Sandoe (split from objc-act.c)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This implements the original NeXT ABI (0) used for m32 code and indicated\n+   by module version 6.  It also implements the small number of additions made\n+   for properties and optional protocol methods as ABI=1 \n+   (module version 7).  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+\n+#ifdef OBJCPLUS\n+#include \"cp-tree.h\"\n+#else\n+#include \"c-tree.h\"\n+#include \"c-lang.h\"\n+#endif\n+#include \"langhooks.h\"\n+#include \"c-family/c-objc.h\"\n+#include \"objc-act.h\"\n+\n+/* When building Objective-C++, we are not linking against the C front-end\n+   and so need to replicate the C tree-construction functions in some way.  */\n+#ifdef OBJCPLUS\n+#define OBJCP_REMAP_FUNCTIONS\n+#include \"objcp-decl.h\"\n+#endif  /* OBJCPLUS */\n+\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"output.h\"\n+#include \"tree-iterator.h\"\n+\n+#include \"objc-runtime-hooks.h\"\n+#include \"objc-runtime-shared-support.h\"\n+\n+/* NeXT ABI 0 and 1 private definitions.  */\n+#define DEF_CONSTANT_STRING_CLASS_NAME \"NSConstantString\"\n+\n+#define TAG_GETCLASS\t\t\t\"objc_getClass\"\n+#define TAG_GETMETACLASS\t\t\"objc_getMetaClass\"\n+\n+#define TAG_MSGSEND\t\t\t\"objc_msgSend\"\n+#define TAG_MSGSENDSUPER\t\t\"objc_msgSendSuper\"\n+#define TAG_MSGSEND_STRET\t\t\"objc_msgSend_stret\"\n+#define TAG_MSGSENDSUPER_STRET\t\t\"objc_msgSendSuper_stret\"\n+\n+/* NeXT-specific tags.  */\n+\n+#define TAG_MSGSEND_NONNIL\t\t\"objc_msgSendNonNil\"\n+#define TAG_MSGSEND_NONNIL_STRET\t\"objc_msgSendNonNil_stret\"\n+#define TAG_EXCEPTIONEXTRACT\t\t\"objc_exception_extract\"\n+#define TAG_EXCEPTIONTRYENTER\t\t\"objc_exception_try_enter\"\n+#define TAG_EXCEPTIONTRYEXIT\t\t\"objc_exception_try_exit\"\n+#define TAG_EXCEPTIONMATCH\t\t\"objc_exception_match\"\n+#define TAG_SETJMP\t\t\t\"_setjmp\"\n+\n+#define TAG_ASSIGNIVAR\t\t\t\"objc_assign_ivar\"\n+#define TAG_ASSIGNGLOBAL\t\t\"objc_assign_global\"\n+#define TAG_ASSIGNSTRONGCAST\t\t\"objc_assign_strongCast\"\n+\n+/* Branch entry points.  All that matters here are the addresses;\n+   functions with these names do not really exist in libobjc.  */\n+\n+#define TAG_MSGSEND_FAST\t\t\"objc_msgSend_Fast\"\n+#define TAG_ASSIGNIVAR_FAST\t\t\"objc_assign_ivar_Fast\"\n+\n+/* The version identifies which language generation and runtime\n+   the module (file) was compiled for, and is recorded in the\n+   module descriptor.  */\n+#define OBJC_VERSION\t\t\t(flag_objc_abi >= 1 ? 7 : 6)\n+\n+#define UTAG_CLASS_EXT\t\t\t\"_objc_class_ext\"\n+#define UTAG_PROPERTY_LIST\t\t\"_prop_list_t\"\n+#define UTAG_PROTOCOL_EXT\t\t\"_objc_protocol_extension\"\n+\n+#define CLS_HAS_CXX_STRUCTORS\t\t0x2000L\n+\n+/* rt_trees identifiers - shared between NeXT implementations.  These allow\n+   the FE to tag meta-data in a manner that survives LTO and can be used when\n+   the  runtime requires that certain meta-data items appear in particular\n+   named sections.  */\n+\n+#include \"objc-next-metadata-tags.h\"\n+extern GTY(()) tree objc_rt_trees[OCTI_RT_META_MAX];\n+\n+static void next_runtime_01_initialize (void);\n+\n+static tree next_runtime_abi_01_super_superclassfield_id (void);\n+\n+static tree next_runtime_abi_01_class_decl (tree);\n+static tree next_runtime_abi_01_metaclass_decl (tree);\n+static tree next_runtime_abi_01_category_decl (tree);\n+static tree next_runtime_abi_01_protocol_decl (tree);\n+static tree next_runtime_abi_01_string_decl (tree, const char *, string_section);\n+\n+static tree next_runtime_abi_01_get_class_reference (tree);\n+static tree next_runtime_abi_01_build_selector_reference (location_t, tree, tree);\n+static tree next_runtime_abi_01_get_protocol_reference (location_t, tree);\n+static tree next_runtime_abi_01_build_ivar_ref (location_t, tree, tree);\n+static tree next_runtime_abi_01_get_class_super_ref (location_t, struct imp_entry *, bool);\n+static tree next_runtime_abi_01_get_category_super_ref (location_t, struct imp_entry *, bool);\n+\n+static tree next_runtime_abi_01_receiver_is_class_object (tree);\n+static tree next_runtime_abi_01_get_arg_type_list_base (tree, int, int);\n+static tree next_runtime_abi_01_build_objc_method_call (location_t, tree, tree,\n+\t\t\t\t\t\t\ttree, tree, tree, int);\n+static bool next_runtime_abi_01_setup_const_string_class_decl (void);\n+static tree next_runtime_abi_01_build_const_string_constructor (location_t, tree, int);\n+\n+static void objc_generate_v1_next_metadata (void);\n+\n+static void build_next_objc_exception_stuff (void);\n+static tree objc_eh_runtime_type (tree type);\n+static tree objc_eh_personality (void);\n+static tree build_throw_stmt (location_t, tree, bool);\n+static tree objc_build_exc_ptr (struct objc_try_context **);\n+static tree begin_catch (struct objc_try_context **, tree, tree, tree, bool);\n+static void finish_catch (struct objc_try_context **, tree);\n+static tree finish_try_stmt (struct objc_try_context **);\n+\n+bool \n+objc_next_runtime_abi_01_init (objc_runtime_hooks *rthooks)\n+{\n+  if (flag_objc_exceptions \n+      && !flag_objc_sjlj_exceptions)\n+    {\n+      warning_at (UNKNOWN_LOCATION, OPT_Wall, \n+\t\t\"%<-fobjc-sjlj-exceptions%> is the only supported exceptions \"\n+\t\t\"system for %<-fnext-runtime%> with %<-fobjc-abi-version%> < 2\");\n+    }\n+\n+  rthooks->initialize = next_runtime_01_initialize;\n+  rthooks->default_constant_string_class_name = DEF_CONSTANT_STRING_CLASS_NAME;\n+  rthooks->tag_getclass = TAG_GETCLASS;\n+  rthooks->super_superclassfield_ident = next_runtime_abi_01_super_superclassfield_id;\n+\n+  rthooks->class_decl = next_runtime_abi_01_class_decl;\n+  rthooks->metaclass_decl = next_runtime_abi_01_metaclass_decl;\n+  rthooks->category_decl = next_runtime_abi_01_category_decl;\n+  rthooks->protocol_decl = next_runtime_abi_01_protocol_decl;\n+  rthooks->string_decl = next_runtime_abi_01_string_decl;\n+\n+  rthooks->get_class_reference = next_runtime_abi_01_get_class_reference;\n+  rthooks->build_selector_reference = next_runtime_abi_01_build_selector_reference;\n+  rthooks->get_protocol_reference = next_runtime_abi_01_get_protocol_reference;\n+  rthooks->build_ivar_reference = next_runtime_abi_01_build_ivar_ref;\n+  rthooks->get_class_super_ref = next_runtime_abi_01_get_class_super_ref;\n+  rthooks->get_category_super_ref = next_runtime_abi_01_get_category_super_ref;\n+\n+  rthooks->receiver_is_class_object = next_runtime_abi_01_receiver_is_class_object;\n+  rthooks->get_arg_type_list_base = next_runtime_abi_01_get_arg_type_list_base;\n+  rthooks->build_objc_method_call = next_runtime_abi_01_build_objc_method_call;\n+\n+  rthooks->setup_const_string_class_decl =\n+\t\t\t\tnext_runtime_abi_01_setup_const_string_class_decl;\n+  rthooks->build_const_string_constructor =\n+\t\t\t\tnext_runtime_abi_01_build_const_string_constructor;\n+\n+  rthooks->build_throw_stmt = build_throw_stmt;\n+  rthooks->build_exc_ptr = objc_build_exc_ptr;\n+  rthooks->begin_catch = begin_catch;\n+  rthooks->finish_catch = finish_catch;\n+  rthooks->finish_try_stmt = finish_try_stmt;\n+\n+  rthooks->generate_metadata = objc_generate_v1_next_metadata;\n+  return true;\n+}\n+\n+/* We need a way to convey what kind of meta-data are represented by a given\n+   variable, since each type is expected (by the runtime) to be found in a\n+   specific named section.  The solution must be usable with LTO.\n+   \n+   The scheme used for NeXT ABI 0/1 (partial matching of variable names) is not\n+   satisfactory for LTO & ABI-2.  We now tag ObjC meta-data with identification\n+   attributes in the front end.  The back-end may choose to act on these as it\n+   requires.  */\n+\n+static void\n+next_runtime_abi_01_init_metadata_attributes (void)\n+{\n+  if (!objc_meta)\n+    objc_meta = get_identifier (\"OBJC1META\");\n+\n+  if (!meta_base)\n+    meta_base = get_identifier (\"V1_BASE\");\n+\n+  meta_class = get_identifier (\"V1_CLAS\");\n+  meta_metaclass = get_identifier (\"V1_META\");\n+  meta_category = get_identifier (\"V1_CATG\");\n+  meta_protocol = get_identifier (\"V1_PROT\");\n+\n+  meta_clac_vars = get_identifier (\"V1_CLCV\");\n+  meta_clai_vars = get_identifier (\"V1_CLIV\");\n+\n+  meta_clac_meth = get_identifier (\"V1_CLCM\");\n+  meta_clai_meth = get_identifier (\"V1_CLIM\");\n+  meta_catc_meth = get_identifier (\"V1_CACM\");\n+  meta_cati_meth = get_identifier (\"V1_CAIM\");\n+  meta_proto_cls_meth = get_identifier (\"V1_PCLM\");\n+  meta_proto_nst_meth = get_identifier (\"V1_PNSM\");\n+\n+  meta_clas_prot = get_identifier (\"V1_CLPR\");\n+  meta_catg_prot = get_identifier (\"V1_CAPR\");\n+\n+  meta_class_reference = get_identifier (\"V1_CLRF\");\n+  meta_proto_ref = get_identifier (\"V1_PRFS\");\n+  meta_sel_refs = get_identifier (\"V1_SRFS\");\n+\n+  meta_class_name = get_identifier (\"V1_CLSN\");\n+  meta_meth_name = get_identifier (\"V1_METN\");\n+  meta_meth_type = get_identifier (\"V1_METT\");\n+  meta_prop_name_attr = get_identifier (\"V1_STRG\");\n+  \n+  meta_modules = get_identifier (\"V1_MODU\");\n+  meta_symtab = get_identifier (\"V1_SYMT\");\n+  meta_info = get_identifier (\"V1_INFO\");\n+  \n+  meta_proplist = get_identifier (\"V1_PLST\");\n+  meta_protocol_extension = get_identifier (\"V1_PEXT\");\n+  meta_class_extension = get_identifier (\"V1_CEXT\");\n+  \n+  meta_const_str = get_identifier (\"V1_CSTR\");\n+}\n+\n+static void build_v1_class_template (void);\n+static void build_v1_category_template (void);\n+static void build_v1_protocol_template (void);\n+\n+static void next_runtime_01_initialize (void)\n+{\n+  tree type;\n+\n+#ifdef OBJCPLUS\n+      /* For all NeXT objc ABIs -fobjc-call-cxx-cdtors is on by default. */\n+      if (!global_options_set.x_flag_objc_call_cxx_cdtors)\n+        global_options.x_flag_objc_call_cxx_cdtors = 1;\n+#endif\n+\n+  /* Set up attributes to be attached to the meta-data so that they\n+     will be placed in the correct sections.  */\n+  next_runtime_abi_01_init_metadata_attributes ();\n+\n+  if (flag_objc_abi >= 1)\n+    objc_prop_list_ptr = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t     get_identifier (\"_prop_list_t\")));\n+\n+ /* Declare type of selector-objects that represent an operation name.  */\n+  /* `struct objc_selector *' */\n+  objc_selector_type = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t   get_identifier (TAG_SELECTOR)));\n+\n+  build_v1_class_template ();\n+  build_super_template ();\n+  build_v1_protocol_template ();\n+  build_v1_category_template ();\n+\n+  /* NB: In order to call one of the ..._stret (struct-returning)\n+     functions, the function *MUST* first be cast to a signature that\n+     corresponds to the actual ObjC method being invoked.  This is\n+     what is done by the build_objc_method_call() routine below.  */\n+\n+  /* id objc_msgSend (id, SEL, ...); */\n+  /* id objc_msgSendNonNil (id, SEL, ...); */\n+  /* id objc_msgSend_stret (id, SEL, ...); */\n+  /* id objc_msgSendNonNil_stret (id, SEL, ...); */\n+  type = build_varargs_function_type_list (objc_object_type,\n+\t\t\t\t\t   objc_object_type,\n+\t\t\t\t\t   objc_selector_type,\n+\t\t\t\t\t   NULL_TREE);\n+\n+  umsg_decl = add_builtin_function (TAG_MSGSEND,\n+\t\t\t\t    type, 0, NOT_BUILT_IN,\n+\t\t\t\t    NULL, NULL_TREE);\n+\n+  umsg_nonnil_decl = add_builtin_function (TAG_MSGSEND_NONNIL,\n+\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t    NULL, NULL_TREE);\n+\n+  umsg_stret_decl = add_builtin_function (TAG_MSGSEND_STRET,\n+\t\t\t\t\t  type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t  NULL, NULL_TREE);\n+\n+  umsg_nonnil_stret_decl = add_builtin_function (TAG_MSGSEND_NONNIL_STRET,\n+\t\t\t\t\t\t type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\t NULL, NULL_TREE);\n+\n+  /* These can throw, because the function that gets called can throw\n+     in Obj-C++, or could itself call something that can throw even\n+     in Obj-C.  */\n+  TREE_NOTHROW (umsg_decl) = 0;\n+  TREE_NOTHROW (umsg_nonnil_decl) = 0;\n+  TREE_NOTHROW (umsg_stret_decl) = 0;\n+  TREE_NOTHROW (umsg_nonnil_stret_decl) = 0;\n+\n+ /* id objc_msgSend_Fast (id, SEL, ...)\n+\t   __attribute__ ((hard_coded_address (OFFS_MSGSEND_FAST))); */\n+#ifdef OFFS_MSGSEND_FAST\n+  umsg_fast_decl = add_builtin_function (TAG_MSGSEND_FAST,\n+\t\t\t\t\t     type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t     NULL, NULL_TREE);\n+  TREE_NOTHROW (umsg_fast_decl) = 0;\n+  DECL_ATTRIBUTES (umsg_fast_decl)\n+\t= tree_cons (get_identifier (\"hard_coded_address\"),\n+\t\t     build_int_cst (NULL_TREE, OFFS_MSGSEND_FAST),\n+\t\t     NULL_TREE);\n+#else\n+  /* No direct dispatch available.  */\n+  umsg_fast_decl = umsg_decl;\n+#endif\n+\n+  /* id objc_msgSendSuper (struct objc_super *, SEL, ...); */\n+  /* id objc_msgSendSuper_stret (struct objc_super *, SEL, ...); */\n+  type = build_varargs_function_type_list (objc_object_type,\n+                                            objc_super_type,\n+                                            objc_selector_type,\n+                                            NULL_TREE);\n+  umsg_super_decl = add_builtin_function (TAG_MSGSENDSUPER,\n+\t\t\t\t\t      type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t      NULL, NULL_TREE);\n+  umsg_super_stret_decl = add_builtin_function (TAG_MSGSENDSUPER_STRET,\n+\t\t\t\t\t\t    type, 0, NOT_BUILT_IN, 0,\n+\t\t\t\t\t\t    NULL_TREE);\n+  TREE_NOTHROW (umsg_super_decl) = 0;\n+  TREE_NOTHROW (umsg_super_stret_decl) = 0;\n+\n+  type = build_function_type_list (objc_object_type,\n+                                   const_string_type_node,\n+                                   NULL_TREE);\n+\n+  /* id objc_getClass (const char *); */\n+  objc_get_class_decl\n+    = add_builtin_function (TAG_GETCLASS, type, 0, NOT_BUILT_IN,\n+\t\t\t    NULL, NULL_TREE);\n+\n+  /* id objc_getMetaClass (const char *); */\n+  objc_get_meta_class_decl\n+    = add_builtin_function (TAG_GETMETACLASS, type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n+\n+  /* This is the type of all of the following functions objc_copyStruct().  */\n+  type = build_function_type_list (void_type_node,\n+\t\t\t\t   ptr_type_node,\n+\t\t\t\t   const_ptr_type_node,\n+\t\t\t\t   ptrdiff_type_node,       \n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   NULL_TREE);\n+  /* Declare the following function:\n+\t void\n+         objc_copyStruct (void *destination, const void *source, \n+\t                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n+  objc_copyStruct_decl = add_builtin_function (\"objc_copyStruct\",\n+\t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\t   NULL, NULL_TREE);\n+  TREE_NOTHROW (objc_copyStruct_decl) = 0;\n+  objc_getPropertyStruct_decl = NULL_TREE;\n+  objc_setPropertyStruct_decl = NULL_TREE;\n+\n+  build_next_objc_exception_stuff ();\n+  if (flag_objc_exceptions && !flag_objc_sjlj_exceptions)\n+    using_eh_for_cleanups ();\n+  lang_hooks.eh_runtime_type = objc_eh_runtime_type;\n+  lang_hooks.eh_personality = objc_eh_personality;\n+}\n+\n+/* --- templates --- */\n+\n+/* struct _objc_class {\n+     struct _objc_class *isa;\n+     struct _objc_class *super_class;\n+     char *name;\n+     long version;\n+     long info;\n+     long instance_size;\n+     struct _objc_ivar_list *ivars;\n+     struct _objc_method_list *methods;\n+     struct objc_cache *cache;\n+     struct _objc_protocol_list *protocols;\n+   #if ABI=1\n+     const char *ivar_layout;\n+     struct _objc_class_ext *ext;\n+   #else\n+     void *sel_id;\n+     void *gc_object_type;\n+    #endif\n+   };  */\n+\n+/* The 'sel_id' & 'gc_object_type' fields are not used by the NeXT runtime.\n+   We generate them for ABI==0 to maintain backward binary compatibility.  */\n+\n+static void\n+build_v1_class_template (void)\n+{\n+  tree ptype, decls, *chain = NULL;\n+\n+  objc_class_template = objc_start_struct (get_identifier (UTAG_CLASS));\n+\n+  /* struct _objc_class *isa; */\n+  decls = add_field_decl (build_pointer_type (objc_class_template),\n+\t\t\t  \"isa\", &chain);\n+\n+  /* struct _objc_class *super_class; */\n+  add_field_decl (build_pointer_type (objc_class_template),\n+\t\t  \"super_class\", &chain);\n+\n+  /* char *name; */\n+  add_field_decl (string_type_node, \"name\", &chain);\n+\n+  /* long version; */\n+  add_field_decl (long_integer_type_node, \"version\", &chain);\n+\n+  /* long info; */\n+  add_field_decl (long_integer_type_node, \"info\", &chain);\n+\n+  /* long instance_size; */\n+  add_field_decl (long_integer_type_node, \"instance_size\", &chain);\n+\n+  /* struct _objc_ivar_list *ivars; */\n+  add_field_decl (objc_ivar_list_ptr,\"ivars\", &chain);\n+\n+  /* struct _objc_method_list *methods; */\n+  add_field_decl (objc_method_list_ptr, \"methods\", &chain);\n+\n+  /* struct objc_cache *cache; */\n+  ptype = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t    get_identifier (\"objc_cache\")));\n+  add_field_decl (ptype, \"cache\", &chain);\n+\n+  /* struct _objc_protocol **protocol_list; */\n+  ptype = build_pointer_type (build_pointer_type\n+\t\t\t      (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t get_identifier (UTAG_PROTOCOL))));\n+  add_field_decl (ptype, \"protocol_list\", &chain);\n+\n+  if (flag_objc_abi >= 1)\n+    {\n+      /* const char *ivar_layout; */\n+      add_field_decl (const_string_type_node, \"ivar_layout\", &chain);\n+\n+      /* struct _objc_class_ext *ext; */\n+      ptype = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t    get_identifier (UTAG_CLASS_EXT)));\n+      add_field_decl (ptype, \"ext\", &chain);\n+    }\n+  else\n+    {\n+      /* void *sel_id; */\n+      add_field_decl (build_pointer_type (void_type_node), \"sel_id\", &chain);\n+      /* void *gc_object_type; */\n+      add_field_decl (build_pointer_type (void_type_node), \"gc_object_type\",\n+\t\t      &chain);\n+    }\n+\n+  objc_finish_struct (objc_class_template, decls);\n+}\n+\n+/* struct _objc_category {\n+     char *category_name;\n+     char *class_name;\n+     struct _objc_method_list *instance_methods;\n+     struct _objc_method_list *class_methods;\n+     struct _objc_protocol_list *protocols;\n+   if ABI=1\n+     uint32_t size;\t// sizeof (struct _objc_category)\n+     struct _objc_property_list *instance_properties;  // category's own @property decl.\n+   END\n+   };   */\n+\n+static void\n+build_v1_category_template (void)\n+{\n+  tree ptype, decls, *chain = NULL;\n+\n+  objc_category_template = objc_start_struct (get_identifier (UTAG_CATEGORY));\n+\n+  /* char *category_name; */\n+  decls = add_field_decl (string_type_node, \"category_name\", &chain);\n+\n+  /* char *class_name; */\n+  add_field_decl (string_type_node, \"class_name\", &chain);\n+\n+  /* struct _objc_method_list *instance_methods; */\n+  add_field_decl (objc_method_list_ptr, \"instance_methods\", &chain);\n+\n+  /* struct _objc_method_list *class_methods; */\n+  add_field_decl (objc_method_list_ptr, \"class_methods\", &chain);\n+\n+  /* struct _objc_protocol **protocol_list; */\n+  ptype = build_pointer_type (build_pointer_type (objc_protocol_template));\n+  add_field_decl (ptype, \"protocol_list\", &chain);\n+\n+  if (flag_objc_abi >= 1)\n+    {\n+      add_field_decl (integer_type_node, \"size\", &chain);\n+ \n+      /* struct _objc_property_list *instance_properties;\n+         This field describes a category's @property declarations.\n+         Properties from inherited protocols are not included. */\n+      ptype = build_pointer_type (xref_tag (RECORD_TYPE, \n+\t\t\t\t\t    get_identifier (UTAG_PROPERTY_LIST)));\n+      add_field_decl (ptype, \"instance_properties\", &chain);\n+    }\n+  objc_finish_struct (objc_category_template, decls);\n+}\n+\n+/* Begin code generation for protocols... \n+   Modified for ObjC #1 extensions.  */\n+\n+/* struct _objc_protocol {\n+   IF ABI=1\n+     struct _objc_protocol_extension *isa;\n+   ElSE\n+     struct _objc_class *isa;\n+ \n+     char *protocol_name;\n+     struct _objc_protocol **protocol_list;\n+     struct _objc__method_prototype_list *instance_methods;\n+     struct _objc__method_prototype_list *class_methods;\n+   };  */\n+\n+static void\n+build_v1_protocol_template (void)\n+{\n+  tree ptype, decls, *chain = NULL;\n+\n+  objc_protocol_template = objc_start_struct (get_identifier (UTAG_PROTOCOL));\n+\n+  if (flag_objc_abi >= 1)\n+    /* struct _objc_protocol_extension *isa; */\n+    ptype = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t  get_identifier (UTAG_PROTOCOL_EXT)));\n+  else\n+    /* struct _objc_class *isa;  */\n+    ptype = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\tget_identifier (UTAG_CLASS)));\n+\n+  decls = add_field_decl (ptype, \"isa\", &chain);\n+\n+  /* char *protocol_name; */\n+  add_field_decl (string_type_node, \"protocol_name\", &chain);\n+\n+  /* struct _objc_protocol **protocol_list; */\n+  ptype = build_pointer_type (build_pointer_type (objc_protocol_template));\n+  add_field_decl (ptype, \"protocol_list\", &chain);\n+\n+  /* struct _objc__method_prototype_list *instance_methods; */\n+  add_field_decl (objc_method_proto_list_ptr, \"instance_methods\", &chain);\n+\n+  /* struct _objc__method_prototype_list *class_methods; */\n+  add_field_decl (objc_method_proto_list_ptr, \"class_methods\", &chain);\n+\n+  objc_finish_struct (objc_protocol_template, decls);\n+}\n+\n+/* --- names, decls identifers --- */\n+\n+static tree\n+next_runtime_abi_01_super_superclassfield_id (void)\n+{\n+  if (!super_superclassfield_id)\n+    super_superclassfield_id = get_identifier (\"super_class\");\n+  return super_superclassfield_id;\n+}\n+\n+static tree\n+next_runtime_abi_01_class_decl (tree klass)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+  snprintf (buf, BUFSIZE, \"_OBJC_Class_%s\", \n+\t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n+  decl = start_var_decl (objc_class_template, buf);\n+  OBJCMETA (decl, objc_meta, meta_class);\n+  return decl;\n+}\n+\n+static tree\n+next_runtime_abi_01_metaclass_decl (tree klass)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+  snprintf (buf, BUFSIZE, \"_OBJC_MetaClass_%s\", \n+\t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n+  decl = start_var_decl (objc_class_template, buf);\n+  OBJCMETA (decl, objc_meta, meta_metaclass);\n+  return decl;\n+}\n+\n+static tree\n+next_runtime_abi_01_category_decl (tree klass)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+  snprintf (buf, BUFSIZE, \"_OBJC_Category_%s_on_%s\", \n+\t    IDENTIFIER_POINTER (CLASS_SUPER_NAME (klass)),\n+\t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n+  decl = start_var_decl (objc_category_template, buf);\n+  OBJCMETA (decl, objc_meta, meta_category);\n+  return decl;\n+}\n+\n+static tree\n+next_runtime_abi_01_protocol_decl (tree p)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+\n+  /* static struct _objc_protocol _OBJC_Protocol_<mumble>; */\n+\n+  snprintf (buf, BUFSIZE, \"_OBJC_Protocol_%s\",\n+\t    IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n+  decl = start_var_decl (objc_protocol_template, buf);\n+  OBJCMETA (decl, objc_meta, meta_protocol);\n+  return decl;\n+}\n+\n+static tree\n+next_runtime_abi_01_string_decl (tree type, const char *name,  string_section where)\n+{\n+  tree var = start_var_decl (type, name);\n+  switch (where)\n+    {\n+      case class_names:\n+\tOBJCMETA (var, objc_meta, meta_class_name);\n+\tbreak;\n+      case meth_var_names:\n+\tOBJCMETA (var, objc_meta, meta_meth_name);\n+\tbreak;\n+      case meth_var_types:\n+\tOBJCMETA (var, objc_meta, meta_meth_type);\n+\tbreak;\n+      case prop_names_attr:\n+\tOBJCMETA (var, objc_meta, meta_prop_name_attr);\n+\tbreak;\n+      default: \n+\tOBJCMETA (var, objc_meta, meta_base);\n+\tbreak;\n+    }\n+  return var;\n+}\n+\n+/* --- entry --- */\n+\n+static GTY(()) int class_reference_idx;\n+\n+static tree\n+build_class_reference_decl (void)\n+{\n+  tree decl;\n+  char buf[BUFSIZE];\n+\n+  sprintf (buf, \"_OBJC_ClassRefs_%d\", class_reference_idx++);\n+  decl = start_var_decl (objc_class_type, buf);\n+\n+  return decl;\n+}\n+\n+static tree\n+next_runtime_abi_01_get_class_reference (tree ident)\n+{\n+  if (!flag_zero_link)\n+    {\n+      tree *chain;\n+      tree decl;\n+\n+      for (chain = &cls_ref_chain; *chain; chain = &TREE_CHAIN (*chain))\n+\tif (TREE_VALUE (*chain) == ident)\n+\t  {\n+\t    if (! TREE_PURPOSE (*chain))\n+\t      TREE_PURPOSE (*chain) = build_class_reference_decl ();\n+\n+\t    return TREE_PURPOSE (*chain);\n+\t  }\n+\n+      decl = build_class_reference_decl ();\n+      *chain = tree_cons (decl, ident, NULL_TREE);\n+      return decl;\n+    }\n+  else\n+    {\n+      tree params;\n+\n+      add_class_reference (ident);\n+\n+      params = build_tree_list (NULL_TREE,\n+\t\t\t\tmy_build_string_pointer\n+\t\t\t\t(IDENTIFIER_LENGTH (ident) + 1,\n+\t\t\t\t IDENTIFIER_POINTER (ident)));\n+\n+      return build_function_call (input_location, objc_get_class_decl, params);\n+    }\n+}\n+\n+/* Used by get_arg_type_list.  \n+   Return the types for receiver & _cmd at the start of a method argument list.\n+   context is either METHOD_DEF or METHOD_REF, saying whether we are trying\n+   to define a method or call one.  superflag says this is for a send to super.\n+   meth may be NULL, in the case that there is no prototype.  */\n+\n+static tree\n+next_runtime_abi_01_get_arg_type_list_base (tree meth, int context, int superflag)\n+{\n+  tree arglist;\n+\n+  /* Receiver type.  */\n+  if (superflag)\n+    arglist = build_tree_list (NULL_TREE, objc_super_type);\n+  else if (context == METHOD_DEF && TREE_CODE (meth) == INSTANCE_METHOD_DECL)\n+    arglist = build_tree_list (NULL_TREE, objc_instance_type);\n+  else\n+    arglist = build_tree_list (NULL_TREE, objc_object_type);\n+\n+  /* Selector type - will eventually change to `int'.  */\n+  chainon (arglist, build_tree_list (NULL_TREE, objc_selector_type));\n+  return arglist;\n+}\n+\n+static tree\n+next_runtime_abi_01_receiver_is_class_object (tree receiver)\n+{\n+  if (TREE_CODE (receiver) == VAR_DECL\n+      && IS_CLASS (TREE_TYPE (receiver)))\n+    {\n+      /* The receiver is a variable created by build_class_reference_decl.  */\n+      tree chain = cls_ref_chain ;\n+      /* Look up the identifier in the relevant chain.  */\n+      for (; chain; chain = TREE_CHAIN (chain))\n+\tif (TREE_PURPOSE (chain) == receiver)\n+\t  return TREE_VALUE (chain);\n+    }\n+  return NULL_TREE;\n+}\n+\n+static tree\n+build_selector_reference_decl (tree ident)\n+{\n+  tree decl;\n+  char *t, buf[BUFSIZE];\n+\n+  snprintf (buf, BUFSIZE, \"_OBJC_SelRef_%s\", IDENTIFIER_POINTER (ident));\n+  t = buf;\n+  while (*t)\n+    {\n+      if (*t==':') \n+        *t = '$'; /* Underscore would clash between foo:bar and foo_bar.  */\n+      t++;\n+    }\n+  decl = start_var_decl (objc_selector_type, buf);\n+  OBJCMETA (decl, objc_meta, meta_sel_refs);\n+  return decl;\n+}\n+\n+static tree\n+next_runtime_abi_01_build_selector_reference (location_t loc ATTRIBUTE_UNUSED,\n+\t\t\t\t\t      tree ident,\n+\t\t\t\t\t      tree proto ATTRIBUTE_UNUSED)\n+{\n+  tree *chain = &sel_ref_chain;\n+  tree expr;\n+\n+  while (*chain)\n+    {\n+      if (TREE_VALUE (*chain) == ident)\n+\treturn TREE_PURPOSE (*chain);\n+\n+      chain = &TREE_CHAIN (*chain);\n+    }\n+\n+  expr = build_selector_reference_decl (ident);\n+\n+  *chain = tree_cons (expr, ident, NULL_TREE);\n+\n+  return expr;\n+}\n+\n+/* Build a tree expression to send OBJECT the operation SELECTOR,\n+   looking up the method on object LOOKUP_OBJECT (often same as OBJECT),\n+   assuming the method has prototype METHOD_PROTOTYPE.\n+   (That is an INSTANCE_METHOD_DECL or CLASS_METHOD_DECL.)\n+   LOC is the location of the expression to build.\n+   Use METHOD_PARAMS as list of args to pass to the method.\n+   If SUPER_FLAG is nonzero, we look up the superclass's method.  */\n+\n+static tree\n+build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n+\t\t\ttree lookup_object, tree selector,\n+\t\t\ttree method_params)\n+{\n+  tree sender, sender_cast, method, t;\n+  tree rcv_p = (super_flag ? objc_super_type : objc_object_type);\n+  VEC(tree, gc) *parms;\n+  unsigned nparm = (method_params ? list_length (method_params) : 0);\n+\n+  /* If a prototype for the method to be called exists, then cast\n+     the sender's return type and arguments to match that of the method.\n+     Otherwise, leave sender as is.  */\n+  tree ret_type\n+    = (method_prototype\n+       ? TREE_VALUE (TREE_TYPE (method_prototype))\n+       : objc_object_type);\n+\n+  tree method_param_types = \n+  \t\tget_arg_type_list (method_prototype, METHOD_REF, super_flag);\n+  tree ftype = build_function_type (ret_type, method_param_types);\n+\n+  if (method_prototype && METHOD_TYPE_ATTRIBUTES (method_prototype))\n+    ftype = build_type_attribute_variant (ftype, \n+\t\t\t\t\t  METHOD_TYPE_ATTRIBUTES \n+\t\t\t\t\t  (method_prototype));\n+\n+  sender_cast = build_pointer_type (ftype);\n+\n+  lookup_object = build_c_cast (loc, rcv_p, lookup_object);\n+\n+  /* Use SAVE_EXPR to avoid evaluating the receiver twice.  */\n+  lookup_object = save_expr (lookup_object);\n+\n+  /* Param list + 2 slots for object and selector.  */\n+  parms = VEC_alloc (tree, gc, nparm + 2);\n+\n+  /* If we are returning a struct in memory, and the address\n+     of that memory location is passed as a hidden first\n+     argument, then change which messenger entry point this\n+     expr will call.  NB: Note that sender_cast remains\n+     unchanged (it already has a struct return type).  */\n+  if (!targetm.calls.struct_value_rtx (0, 0)\n+      && (TREE_CODE (ret_type) == RECORD_TYPE\n+\t  || TREE_CODE (ret_type) == UNION_TYPE)\n+      && targetm.calls.return_in_memory (ret_type, 0))\n+    sender = (super_flag ? umsg_super_stret_decl\n+\t\t\t : flag_nil_receivers ? umsg_stret_decl \n+\t\t\t\t\t      : umsg_nonnil_stret_decl);\n+  else\n+    sender = (super_flag ? umsg_super_decl \n+\t\t\t : (flag_nil_receivers  ? (flag_objc_direct_dispatch \n+\t\t\t\t\t\t\t? umsg_fast_decl\n+\t\t\t\t\t\t\t: umsg_decl)\n+\t\t\t\t\t\t: umsg_nonnil_decl));\n+  method = build_fold_addr_expr_loc (loc, sender);\n+\n+  /* Pass the object to the method.  */\n+  VEC_quick_push (tree, parms, lookup_object);\n+  /* Pass the selector to the method.  */\n+  VEC_quick_push (tree, parms, selector);\n+  /* Now append the remainder of the parms.  */\n+  if (nparm)\n+    for (; method_params; method_params = TREE_CHAIN (method_params))\n+      VEC_quick_push (tree, parms, TREE_VALUE (method_params));\n+\n+  /* Build an obj_type_ref, with the correct cast for the method call.  */\n+  t = build3 (OBJ_TYPE_REF, sender_cast, method, \n+\t\t\t    lookup_object, size_zero_node);\n+  t = build_function_call_vec (loc, t, parms, NULL);\n+  VEC_free (tree, gc, parms);\n+  return t;\n+}\n+\n+static tree\n+next_runtime_abi_01_build_objc_method_call (location_t loc,\n+\t\t\t\t\t    tree method_prototype,\n+\t\t\t\t\t    tree receiver,\n+\t\t\t\t\t    tree rtype ATTRIBUTE_UNUSED,\n+\t\t\t\t\t    tree sel_name,\n+\t\t\t\t\t    tree method_params,\n+\t\t\t\t\t    int super)\n+{\n+  tree selector = next_runtime_abi_01_build_selector_reference (loc, sel_name,\n+\t\t\t\t\t\t\t\tNULL_TREE);\n+\n+  return build_objc_method_call (loc, super, method_prototype,\n+\t\t\t\t receiver, selector, method_params);\n+}\n+\n+static tree\n+next_runtime_abi_01_get_protocol_reference (location_t loc, tree p)\n+{\n+  tree expr;\n+\n+  if (!PROTOCOL_FORWARD_DECL (p))\n+    PROTOCOL_FORWARD_DECL (p) = next_runtime_abi_01_protocol_decl (p);\n+\n+  expr = build_unary_op (loc, ADDR_EXPR, PROTOCOL_FORWARD_DECL (p), 0);\n+  return convert (objc_protocol_type, expr);\n+}\n+\n+/* For ABI 0/1 and IVAR is just a fixed offset in the class struct.  */\n+\n+static tree\n+next_runtime_abi_01_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED, \n+\t\t\t\t   tree base, tree id)\n+{\n+  return objc_build_component_ref (base, id);\n+}\n+\n+/* We build super class references as we need them (but keep them once\n+   built for the sake of efficiency).  */\n+\n+static tree\n+next_runtime_abi_01_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n+\t\t\t\t\t struct imp_entry *imp, bool inst_meth)\n+{\n+  if (inst_meth)\n+    {\n+      if (!ucls_super_ref)\n+\tucls_super_ref = \n+\t\tobjc_build_component_ref (imp->class_decl, \n+\t\t\t\t\t  get_identifier (\"super_class\"));\n+\treturn ucls_super_ref;\n+    }\n+  else\n+    {\n+      if (!uucls_super_ref)\n+\tuucls_super_ref = \n+\t\tobjc_build_component_ref (imp->meta_decl, \n+\t\t\t\t\t  get_identifier (\"super_class\"));\n+\treturn uucls_super_ref;\n+    }\n+}\n+\n+static tree\n+next_runtime_abi_01_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED, \n+\t\t\t\t\t   struct imp_entry *imp, bool inst_meth)\n+{\n+  tree super_name = CLASS_SUPER_NAME (imp->imp_template);\n+  tree super_class;\n+\n+  if (!flag_zero_link)\n+    {\n+      super_class = objc_get_class_reference (super_name);\n+\n+      if (!inst_meth)\n+\t\n+\t/* If we are in a class method, we must retrieve the\n+\t   _metaclass_ for the current class, pointed at by\n+\t   the class's \"isa\" pointer.  The following assumes that\n+\t   \"isa\" is the first ivar in a class (which it must be).  */\n+\t   super_class = \n+\t\tbuild_indirect_ref (input_location,\n+\t\t\t\t    build_c_cast (input_location,\n+\t\t\t\t\tbuild_pointer_type (objc_class_type),\n+\t\t\t\t\tsuper_class), \n+\t\t\t\t    RO_UNARY_STAR);\n+      return super_class;\n+    }\n+\n+  /* else do it the slow way.  */\n+  add_class_reference (super_name);\n+  super_class = (inst_meth ? objc_get_class_decl : objc_get_meta_class_decl);\n+/* assemble_external (super_class);*/\n+  super_name = my_build_string_pointer (IDENTIFIER_LENGTH (super_name) + 1,\n+\t\t\t\t\tIDENTIFIER_POINTER (super_name));\n+  /* super_class = objc_get{Meta}Class(\"CLASS_SUPER_NAME\");  */\n+  return build_function_call (input_location,\n+\t\t\t      super_class,\n+\t\t\t      build_tree_list (NULL_TREE, super_name));\n+}\n+\n+static bool\n+next_runtime_abi_01_setup_const_string_class_decl (void)\n+{\n+  if (!constant_string_global_id)\n+    {\n+      /* Hopefully, this should not represent a serious limitation.  */\n+      char buf[BUFSIZE];\n+      snprintf (buf, BUFSIZE, \"_%sClassReference\", constant_string_class_name);\n+      constant_string_global_id = get_identifier (buf);\n+    }\n+\n+  string_class_decl = lookup_name (constant_string_global_id);\n+\n+  return (string_class_decl != NULL_TREE);\n+}\n+\n+static tree\n+next_runtime_abi_01_build_const_string_constructor (location_t loc, tree string,\n+\t\t\t\t\t\t   int length)\n+{\n+  tree constructor, fields, var;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  /* NeXT:   (NSConstantString *) & ((__builtin_ObjCString) { isa, string, length })   */\n+  fields = TYPE_FIELDS (internal_const_str_type);\n+  CONSTRUCTOR_APPEND_ELT (v, fields,\n+\t\t\t  build_unary_op (loc, ADDR_EXPR, string_class_decl, 0));\n+\n+  fields = DECL_CHAIN (fields);\n+  CONSTRUCTOR_APPEND_ELT (v, fields,\n+\t\t\t  build_unary_op (loc, ADDR_EXPR, string, 1));\n+\n+  /* ??? check if this should be long.  */\n+  fields = DECL_CHAIN (fields);\n+  CONSTRUCTOR_APPEND_ELT (v, fields, build_int_cst (NULL_TREE, length));\n+  constructor = objc_build_constructor (internal_const_str_type, v);\n+\n+  var = build_decl (input_location, CONST_DECL, NULL, TREE_TYPE (constructor));\n+  DECL_INITIAL (var) = constructor;\n+  TREE_STATIC (var) = 1;\n+  DECL_CONTEXT (var) = NULL;\n+  OBJCMETA (var, objc_meta, meta_const_str);\n+  return var;\n+}\n+\n+/* ---  metadata templates --- */\n+\n+/* This routine builds the following type:\n+   struct _prop_t {\n+     const char * const name;\t\t\t// property name\n+     const char * const attributes;\t\t// comma-delimited, encoded, \n+\t\t\t\t\t\t// property attributes\n+   };\n+*/\n+\n+static GTY(()) tree objc_v1_property_template;\n+\n+static tree\n+build_v1_property_template (void)\n+{\n+  tree prop_record;\n+  tree decls, *chain = NULL;\n+\n+  prop_record = objc_start_struct (get_identifier (\"_prop_t\"));\n+  /* const char * name */\n+  decls = add_field_decl (string_type_node, \"name\", &chain);\n+\n+  /* const char * attribute */\n+  add_field_decl (string_type_node, \"attribute\", &chain);\n+\n+  objc_finish_struct (prop_record, decls);\n+  return prop_record;\n+}\n+\n+/* Build the following type:\n+\n+  struct _objc_protocol_extension\n+    {\n+      uint32_t size;\t// sizeof (struct _objc_protocol_extension)\n+      struct objc_method_list\t*optional_instance_methods;\n+      struct objc_method_list   *optional_class_methods;\n+      struct objc_prop_list\t*instance_properties;\n+    }\n+*/\n+\n+static GTY(()) tree objc_protocol_extension_template;\n+\n+static void \n+build_v1_objc_protocol_extension_template (void)\n+{\n+  tree decls, *chain = NULL;\n+  \n+  objc_protocol_extension_template = \n+\tobjc_start_struct (get_identifier (UTAG_PROTOCOL_EXT));\n+\n+  /*  uint32_t size; */\n+  decls = add_field_decl (integer_type_node, \"size\", &chain);\n+\n+  /* struct objc_method_list   *optional_instance_methods; */\n+  add_field_decl (objc_method_list_ptr, \"optional_instance_methods\", &chain);\n+\n+  /* struct objc_method_list   *optional_class_methods; */\n+  add_field_decl (objc_method_list_ptr, \"optional_class_methods\", &chain);\n+\n+  /* struct objc_prop_list     *instance_properties; */\n+  add_field_decl (objc_prop_list_ptr, \"instance_properties\", &chain);\n+\n+  objc_finish_struct (objc_protocol_extension_template, decls);\n+}\n+\n+/* This routine build following struct type:\n+   struct _objc_class_ext \n+     {\n+       uint32_t size;\t// sizeof(struct _objc_class_ext)\n+       const char *weak_ivar_layout;\n+       struct _prop_list_t *properties;\n+     }\n+*/\n+\n+static GTY(()) tree objc_class_ext_template;\n+\n+static void\n+build_objc_class_ext_template (void)\n+{\n+  tree ptrt, decls, *chain = NULL;\n+\n+  objc_class_ext_template = objc_start_struct (get_identifier (UTAG_CLASS_EXT));\n+\n+  /* uint32_t size; */\n+  decls = add_field_decl (integer_type_node, \"size\", &chain);\n+\n+  /* const char *weak_ivar_layout; */\n+  add_field_decl (const_string_type_node, \"weak_ivar_layout\", &chain);\n+\n+  /* struct _prop_list_t *properties; */\n+  ptrt = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t     get_identifier(UTAG_PROPERTY_LIST)));\n+  add_field_decl (ptrt, \"properties\", &chain);\n+\n+  objc_finish_struct (objc_class_ext_template, decls);\n+}\n+\n+static void\n+build_metadata_templates (void)\n+{\n+\n+  if (!objc_method_template)\n+    objc_method_template = build_method_template ();\n+\n+\n+\n+}\n+\n+/* --- emit metadata --- */\n+\n+static tree \n+generate_v1_meth_descriptor_table (tree chain, tree protocol,\n+\t\t\t\t   const char *prefix, tree attr)\n+{\n+  tree method_list_template, initlist, decl;\n+  int size;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  char buf[BUFSIZE];\n+\n+  if (!chain || !prefix)\n+    return NULL_TREE;\n+\n+  if (!objc_method_prototype_template)\n+    objc_method_prototype_template = build_method_prototype_template ();\n+  \n+  size = list_length (chain);\n+  method_list_template = \n+\tbuild_method_prototype_list_template (objc_method_prototype_template,\n+\t\t\t\t\t      size);\n+  snprintf (buf, BUFSIZE, \"%s_%s\", prefix, \n+\t    IDENTIFIER_POINTER (PROTOCOL_NAME (protocol)));\n+\n+  decl = start_var_decl (method_list_template, buf);\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n+  initlist = \n+\tbuild_descriptor_table_initializer (objc_method_prototype_template,\n+\t\t\t\t\t    chain);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n+  /* Get into the right section.  */\n+  OBJCMETA (decl, objc_meta, attr);\n+  finish_var_decl (decl, objc_build_constructor (method_list_template, v));\n+  return decl;\n+}\n+\n+/* Build protocol ext =\n+   {size, opt_instance_meth, opt_class_meth, instance_props};\n+   or NULL_TREE if none are present.  */\n+\n+static tree\n+generate_v1_objc_protocol_extension (tree proto_interface, \n+\t\t\t\t     tree opt_instance_meth,\n+\t\t\t\t     tree opt_class_meth,\n+\t\t\t\t     tree instance_props)\n+{\n+  int size;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  tree decl, expr;\n+  char buf[BUFSIZE];\n+\n+  /* If there are no extensions, then don't bother... */\n+  if (!opt_instance_meth && !opt_class_meth && !instance_props)\n+    return NULL_TREE;\n+\n+  if (!objc_protocol_extension_template)\n+    build_v1_objc_protocol_extension_template ();    \n+\n+  /* uint32_t size */\n+  size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_protocol_extension_template));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n+\n+  /* Try for meaningful diagnostics.  */\n+  loc = DECL_SOURCE_LOCATION (PROTOCOL_FORWARD_DECL (proto_interface));\n+  \n+  /* struct objc_method_list *optional_instance_methods; */\n+  if (opt_instance_meth)\n+    expr = convert (objc_method_list_ptr, \n+\t\t    build_unary_op (loc, ADDR_EXPR, opt_instance_meth, 0));\n+  else\n+    expr = convert (objc_method_list_ptr, null_pointer_node);\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  /* struct objc_method_list *optional_class_methods; */\n+  if (opt_class_meth)\n+    expr = convert (objc_method_list_ptr, \n+\t\t    build_unary_op (loc, ADDR_EXPR, opt_class_meth, 0));\n+  else\n+    expr = convert (objc_method_list_ptr, null_pointer_node);\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+  /* struct objc_prop_list *instance_properties; */\n+  if (instance_props)\n+      expr = convert (objc_prop_list_ptr, \n+\t\t      build_unary_op (loc, ADDR_EXPR, instance_props, 0));\n+  else\n+    expr = convert (objc_prop_list_ptr, null_pointer_node);\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+  snprintf (buf, BUFSIZE, \"_OBJC_ProtocolExt_%s\",\n+\t    IDENTIFIER_POINTER (PROTOCOL_NAME (proto_interface)));\n+\n+  decl = start_var_decl (objc_protocol_extension_template, buf);\n+  expr = objc_build_constructor (TREE_TYPE (decl), v);\n+  OBJCMETA (decl, objc_meta, meta_protocol_extension);\n+  finish_var_decl (decl, expr);\n+  return decl;\n+}\n+\n+/* This routine builds the following type:\n+   struct _prop_list_t {\n+     uint32_t entsize;\t\t\t// sizeof (struct _prop_t)\n+     uint32_t prop_count;\n+     struct _prop_t prop_list [prop_count];\n+   }\n+*/\n+\n+static tree\n+build_v1_property_list_template (tree list_type, int size)\n+{\n+  tree property_list_t_record;\n+  tree array_type, decls, *chain = NULL;\n+\n+  /* anonymous.  */\n+  property_list_t_record = objc_start_struct (NULL_TREE);\n+ \n+  /* uint32_t const entsize */\n+  decls = add_field_decl (integer_type_node, \"entsize\", &chain);\n+\n+  /* int prop_count */\n+  add_field_decl (integer_type_node, \"prop_count\", &chain);\n+\n+  /* struct _prop_t prop_list[]; */\n+  array_type = build_sized_array_type (list_type, size);\n+  add_field_decl (array_type, \"prop_list\", &chain);\n+\n+  objc_finish_struct (property_list_t_record, decls);\n+  return property_list_t_record;\n+}\n+\n+/* This routine builds the initializer list to initialize the\n+   'struct _prop_t prop_list[]'  field of 'struct _prop_list_t' meta-data. */\n+\n+static tree\n+build_v1_property_table_initializer (tree type, tree context)\n+{\n+  tree x;\n+  VEC(constructor_elt,gc) *inits = NULL;\n+\n+  if (TREE_CODE (context) == PROTOCOL_INTERFACE_TYPE)\n+    x = CLASS_PROPERTY_DECL (context);\n+  else\n+    x = IMPL_PROPERTY_DECL (context);\n+\n+  for (; x; x = TREE_CHAIN (x))\n+    {\n+      VEC(constructor_elt,gc) *elemlist = NULL;\n+      tree attribute, name_ident = PROPERTY_NAME (x);\n+\n+      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE, \n+\t\t\t      add_objc_string (name_ident, prop_names_attr));\n+\n+      attribute = objc_v2_encode_prop_attr (x);\n+      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE, \n+\t\t\t      add_objc_string (attribute, prop_names_attr));\n+\n+      CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n+\t\t\t      objc_build_constructor (type, elemlist));\n+    }\n+\n+  return objc_build_constructor (build_array_type (type, 0),inits);\n+}\n+\n+/* This routine builds the 'struct _prop_list_t' variable declaration and\n+   initializes it with its initializer list. TYPE is 'struct _prop_list_t',\n+   NAME is the internal name of this variable, SIZE is number of properties\n+   for this class and LIST is the initializer list for its 'prop_list' field. */\n+\n+static tree\n+generate_v1_property_table (tree context, tree klass_ctxt)\n+{\n+  tree x, decl, initlist, property_list_template;\n+  bool is_proto = false;\n+  VEC(constructor_elt,gc) *inits = NULL;\n+  int init_val, size = 0;\n+  char buf[BUFSIZE];\n+  \n+  if (context)\n+    {\n+      gcc_assert (TREE_CODE (context) == PROTOCOL_INTERFACE_TYPE);\n+      x = CLASS_PROPERTY_DECL (context);\n+      is_proto = true;\n+    }\n+  else\n+    x = IMPL_PROPERTY_DECL (klass_ctxt);\n+\n+  for (; x; x = TREE_CHAIN (x))\n+    size++;\n+\n+  if (size == 0)\n+    return NULL_TREE;\n+\n+  if (!objc_v1_property_template)\n+    objc_v1_property_template = build_v1_property_template (); \n+\n+  property_list_template = \n+\tbuild_v1_property_list_template (objc_v1_property_template, \n+\t\t\t\t\t size);\n+  initlist = build_v1_property_table_initializer (objc_v1_property_template,\n+\t\t\t\t\t\t  is_proto ? context\n+\t\t\t\t\t\t\t   : klass_ctxt);\n+\n+  init_val = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_v1_property_template));\n+  if (is_proto)\n+    snprintf (buf, BUFSIZE, \"_OBJC_ProtocolPropList_%s\",\n+\t      IDENTIFIER_POINTER (PROTOCOL_NAME (context)));\n+  else\n+    snprintf (buf, BUFSIZE, \"_OBJC_ClassPropList_%s\",\n+\t      IDENTIFIER_POINTER (CLASS_NAME (klass_ctxt)));\n+\n+  decl = start_var_decl (property_list_template, buf);\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, build_int_cst (NULL_TREE, init_val));\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, build_int_cst (NULL_TREE, size));\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, initlist);\n+  x = objc_build_constructor (TREE_TYPE (decl), inits);\n+  OBJCMETA (decl, objc_meta, meta_proplist);\n+  finish_var_decl (decl, x);\n+  return decl;\n+}\n+\n+static tree\n+generate_v1_protocol_list (tree i_or_p, tree klass_ctxt)\n+{\n+  tree array_type, ptype, refs_decl, lproto, e, plist, attr;\n+  int size = 0;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  char buf[BUFSIZE];\n+\n+  switch (TREE_CODE (i_or_p))\n+    {\n+    case CLASS_INTERFACE_TYPE:\n+    case CATEGORY_INTERFACE_TYPE:\n+      plist = CLASS_PROTOCOL_LIST (i_or_p);\n+      break;\n+    case PROTOCOL_INTERFACE_TYPE:\n+      plist = PROTOCOL_LIST (i_or_p);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Compute size.  */\n+  for (lproto = plist; lproto; lproto = TREE_CHAIN (lproto))\n+    if (TREE_CODE (TREE_VALUE (lproto)) == PROTOCOL_INTERFACE_TYPE\n+\t&& PROTOCOL_FORWARD_DECL (TREE_VALUE (lproto)))\n+      size++;\n+\n+  /* Build initializer.  */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+  e = build_int_cst (build_pointer_type (objc_protocol_template), size);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, e);\n+\n+  for (lproto = plist; lproto; lproto = TREE_CHAIN (lproto))\n+    {\n+      tree pval = TREE_VALUE (lproto);\n+\n+      if (TREE_CODE (pval) == PROTOCOL_INTERFACE_TYPE\n+\t  && PROTOCOL_FORWARD_DECL (pval))\n+\t{\n+\t  tree fwref = PROTOCOL_FORWARD_DECL (pval);\n+\t  location_t loc = DECL_SOURCE_LOCATION (fwref) ;\n+\t  e = build_unary_op (loc, ADDR_EXPR, fwref, 0);\n+          CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, e);\n+\t}\n+    }\n+\n+  /* static struct objc_protocol *refs[n]; */\n+  switch (TREE_CODE (i_or_p))\n+    {\n+    case PROTOCOL_INTERFACE_TYPE:\n+      snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRefs_%s\", \n+\t\tIDENTIFIER_POINTER (PROTOCOL_NAME (i_or_p)));\n+      attr = meta_proto_ref;\n+      break;\n+    case CLASS_INTERFACE_TYPE:\n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassProtocols_%s\", \n+\t\tIDENTIFIER_POINTER (CLASS_NAME (i_or_p)));\n+      attr = meta_clas_prot;\n+      break;\n+    case CATEGORY_INTERFACE_TYPE:\n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryProtocols_%s_%s\", \n+\t\tIDENTIFIER_POINTER (CLASS_NAME (klass_ctxt)),\n+\t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (klass_ctxt)));\n+      attr = meta_catg_prot;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  ptype = build_pointer_type (objc_protocol_template);\n+  array_type = build_sized_array_type (ptype, size + 3);\n+  refs_decl = start_var_decl (array_type, buf);\n+\n+  OBJCMETA (refs_decl, objc_meta, attr);\n+  finish_var_decl (refs_decl,\n+                   objc_build_constructor (TREE_TYPE (refs_decl), v));\n+\n+  return refs_decl;\n+}\n+\n+static tree\n+build_v1_protocol_initializer (tree type, tree protocol_name, tree protocol_list,\n+\t\t\t       tree inst_methods, tree class_methods,\n+\t\t\t       tree protocol_ext)\n+{\n+  tree expr, ttyp;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *inits = NULL;\n+  \n+  if (!objc_protocol_extension_template)\n+    build_v1_objc_protocol_extension_template ();    \n+\n+  /* TODO: find a better representation of location from the inputs.  */\n+  loc = UNKNOWN_LOCATION;\n+  ttyp = build_pointer_type (objc_protocol_extension_template);\n+  /* Instead of jamming the protocol version number into the isa, we pass\n+     either a pointer to the protocol extension - or NULL.  */\n+  if (protocol_ext)\n+    expr = convert (ttyp, build_unary_op (loc, ADDR_EXPR, protocol_ext, 0));\n+  else\n+    expr = convert (ttyp, null_pointer_node);\n+\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, protocol_name);\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, protocol_list);\n+\n+  ttyp = objc_method_proto_list_ptr;\n+  if (inst_methods)\n+    expr = convert (ttyp, build_unary_op (loc, ADDR_EXPR, inst_methods, 0));\n+  else\n+    expr = convert (ttyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n+\n+  if (class_methods)\n+    expr = convert (ttyp, build_unary_op (loc, ADDR_EXPR, class_methods, 0));\n+  else\n+    expr = convert (ttyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n+\n+  return objc_build_constructor (type, inits);\n+}\n+\n+/* An updated version of generate_protocols () that emit the protocol \n+   extension for ABI=1.  */\n+\n+/* For each protocol which was referenced either from a @protocol()\n+   expression, or because a class/category implements it (then a\n+   pointer to the protocol is stored in the struct describing the\n+   class/category), we create a statically allocated instance of the\n+   Protocol class.  The code is written in such a way as to generate\n+   as few Protocol objects as possible; we generate a unique Protocol\n+   instance for each protocol, and we don't generate a Protocol\n+   instance if the protocol is never referenced (either from a\n+   @protocol() or from a class/category implementation).  These\n+   statically allocated objects can be referred to via the static\n+   (that is, private to this module) symbols _OBJC_PROTOCOL_n.\n+\n+   The statically allocated Protocol objects that we generate here\n+   need to be fixed up at runtime in order to be used: the 'isa'\n+   pointer of the objects need to be set up to point to the 'Protocol'\n+   class, as known at runtime.\n+\n+   The NeXT runtime fixes up all protocols at program startup time,\n+   before main() is entered.  It uses a low-level trick to look up all\n+   those symbols, then loops on them and fixes them up.  */\n+\n+/* TODO: finish getting rid of passing stuff around in globals.  */\n+\n+static GTY(()) tree V1_Protocol_OPT_NST_METHODS_decl;\n+static GTY(()) tree V1_Protocol_OPT_CLS_METHODS_decl;\n+static GTY(()) tree V1_ProtocolExt_decl;\n+static GTY(()) tree V1_Property_decl;\n+\n+static void\n+generate_v1_protocols (void)\n+{\n+  tree p;\n+\n+  /* If a protocol was directly referenced, pull in indirect references.  */\n+  for (p = protocol_chain; p; p = TREE_CHAIN (p))\n+    if (PROTOCOL_FORWARD_DECL (p) && PROTOCOL_LIST (p))\n+      generate_protocol_references (PROTOCOL_LIST (p));\n+\n+  for (p = protocol_chain; p; p = TREE_CHAIN (p))\n+    {\n+      tree decl, encoding, initlist, protocol_name_expr;\n+      tree refs_type, refs_decl, refs_expr;\n+      location_t loc;\n+      tree nst_methods = PROTOCOL_NST_METHODS (p);\n+      tree cls_methods = PROTOCOL_CLS_METHODS (p);\n+\n+      /* If protocol wasn't referenced, don't generate any code.  */\n+      decl = PROTOCOL_FORWARD_DECL (p);\n+\n+      if (!decl)\n+\tcontinue;\n+\n+      /* Make sure we link in the Protocol class.  */\n+      add_class_reference (get_identifier (PROTOCOL_OBJECT_CLASS_NAME));\n+\n+      while (nst_methods)\n+\t{\n+\t  if (! METHOD_ENCODING (nst_methods))\n+\t    {\n+\t      encoding = encode_method_prototype (nst_methods);\n+\t      METHOD_ENCODING (nst_methods) = encoding;\n+\t    }\n+\t  nst_methods = TREE_CHAIN (nst_methods);\n+\t}\n+\n+      UOBJC_INSTANCE_METHODS_decl = \n+\tgenerate_v1_meth_descriptor_table (PROTOCOL_NST_METHODS (p), p,\n+\t\t\t\t\t   \"_OBJC_ProtocolInstanceMethods\",\n+\t\t\t\t\t   meta_proto_nst_meth);\n+\n+      while (cls_methods)\n+\t{\n+\t  if (! METHOD_ENCODING (cls_methods))\n+\t    {\n+\t      encoding = encode_method_prototype (cls_methods);\n+\t      METHOD_ENCODING (cls_methods) = encoding;\n+\t    }\n+\n+\t  cls_methods = TREE_CHAIN (cls_methods);\n+\t}\n+\n+      UOBJC_CLASS_METHODS_decl = \n+\tgenerate_v1_meth_descriptor_table (PROTOCOL_CLS_METHODS (p), p,\n+\t\t\t\t\t   \"_OBJC_ProtocolClassMethods\",\n+\t\t\t\t\t   meta_proto_cls_meth);\n+\n+      /* There should be no optional methods for ABI-0 - but we need to \n+         check all this here before the lists are made.  */\n+      nst_methods = PROTOCOL_OPTIONAL_NST_METHODS (p);\n+      while (nst_methods)\n+        {\n+          if (! METHOD_ENCODING (nst_methods))\n+            {                     \n+              encoding = encode_method_prototype (nst_methods);\n+              METHOD_ENCODING (nst_methods) = encoding;\n+            }\n+          nst_methods = TREE_CHAIN (nst_methods);\n+        }\n+\n+      V1_Protocol_OPT_NST_METHODS_decl =\n+\tgenerate_v1_meth_descriptor_table (PROTOCOL_OPTIONAL_NST_METHODS (p), p,\n+\t\t\t\t\t   \"_OBJC_OptionalProtocolInstanceMethods\",\n+\t\t\t\t\t   meta_proto_nst_meth);\n+\n+      cls_methods = PROTOCOL_OPTIONAL_CLS_METHODS (p);\n+      while (cls_methods)                    \n+        {\n+          if (! METHOD_ENCODING (cls_methods))\n+            {\n+              encoding = encode_method_prototype (cls_methods);\n+              METHOD_ENCODING (cls_methods) = encoding;\n+            }\n+\n+          cls_methods = TREE_CHAIN (cls_methods);\n+        }\n+\n+      V1_Protocol_OPT_CLS_METHODS_decl = \n+\tgenerate_v1_meth_descriptor_table (PROTOCOL_OPTIONAL_CLS_METHODS (p), p,\n+\t\t\t\t\t   \"_OBJC_OptionalProtocolClassMethods\",\n+\t\t\t\t\t   meta_proto_cls_meth);\n+\n+      if (PROTOCOL_LIST (p))\n+\trefs_decl = generate_v1_protocol_list (p, objc_implementation_context);\n+      else\n+\trefs_decl = 0;\n+\n+      /* static struct objc_protocol _OBJC_PROTOCOL_<mumble>; */\n+      protocol_name_expr = add_objc_string (PROTOCOL_NAME (p), class_names);\n+      /* TODO: more locations to be fixed up... */\n+      loc = UNKNOWN_LOCATION;\n+      refs_type =\n+\tbuild_pointer_type (build_pointer_type (objc_protocol_template));\n+      if (refs_decl)\n+\trefs_expr = convert (refs_type,\n+\t\t\t     build_unary_op (loc, ADDR_EXPR, refs_decl, 0));\n+      else\n+        refs_expr = convert (refs_type, null_pointer_node);\n+      \n+      if (flag_objc_abi < 1)\n+\t{\n+\t  /* Original ABI.  */\n+\t  initlist = \n+\t\tbuild_protocol_initializer (TREE_TYPE (decl),\n+\t\t\t\t\t    protocol_name_expr, refs_expr,\n+\t\t\t\t\t    UOBJC_INSTANCE_METHODS_decl,\n+\t\t\t\t\t    UOBJC_CLASS_METHODS_decl);\n+\t  finish_var_decl (decl, initlist);\n+          continue;\n+\t}\n+\n+      /* else - V1 extensions.  */\n+\n+      V1_Property_decl = \n+\t\tgenerate_v1_property_table (p, NULL_TREE);\n+\n+      V1_ProtocolExt_decl = \n+\tgenerate_v1_objc_protocol_extension (p, \n+\t\t\t\t\t     V1_Protocol_OPT_NST_METHODS_decl,\n+\t\t\t\t\t     V1_Protocol_OPT_CLS_METHODS_decl, \n+\t\t\t\t\t     V1_Property_decl);\n+\n+      initlist = build_v1_protocol_initializer (TREE_TYPE (decl),\n+\t\t\t\t\t\tprotocol_name_expr, refs_expr,\n+\t\t\t\t\t\tUOBJC_INSTANCE_METHODS_decl,\n+\t\t\t\t\t\tUOBJC_CLASS_METHODS_decl,\n+\t\t\t\t\t\tV1_ProtocolExt_decl);\n+      finish_var_decl (decl, initlist);\n+    }\n+}\n+\n+static tree\n+generate_dispatch_table (tree chain, const char *name, tree attr)\n+{\n+  tree decl, method_list_template, initlist;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  int size;;\n+\n+  if (!chain || !name || !(size = list_length (chain)))\n+    return NULL_TREE;\n+\n+  if (!objc_method_template)\n+    objc_method_template = build_method_template ();\n+\n+  method_list_template = build_method_list_template (objc_method_template,\n+\t\t\t\t\t\t     size);\n+  initlist = build_dispatch_table_initializer (objc_method_template, chain);\n+\n+  decl = start_var_decl (method_list_template, name);\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  build_int_cst (integer_type_node, size));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n+\n+  OBJCMETA (decl, objc_meta, attr);\n+  finish_var_decl (decl,\n+\t\t   objc_build_constructor (TREE_TYPE (decl), v));\n+\n+  return decl;\n+}\n+\n+/* Init a category.  */\n+static tree\n+build_v1_category_initializer (tree type, tree cat_name, tree class_name,\n+\t\t\t\ttree inst_methods, tree class_methods,\n+\t\t\t\ttree protocol_list, tree property_list,\n+\t\t\t\tlocation_t loc)\n+{\n+  tree expr, ltyp;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, cat_name);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, class_name);\n+\n+  ltyp = objc_method_list_ptr;\n+  if (inst_methods)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, inst_methods, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  if (class_methods)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, class_methods, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  /* protocol_list = */\n+  ltyp = build_pointer_type (build_pointer_type (objc_protocol_template));\n+  if (protocol_list)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, protocol_list, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  if (flag_objc_abi >= 1)\n+    {\n+      int val = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_category_template));\n+      expr = build_int_cst (NULL_TREE, val);\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+      ltyp = objc_prop_list_ptr;\n+      if (property_list)\n+\texpr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, property_list, 0));\n+      else\n+\texpr = convert (ltyp, null_pointer_node);\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+    }\n+\n+  return objc_build_constructor (type, v);\n+}\n+\n+/* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */\n+/* TODO: get rid of passing stuff around in globals.  */\n+static void\n+generate_v1_category (struct imp_entry *impent)\n+{\n+  tree initlist, cat_name_expr, class_name_expr;\n+  tree protocol_decl, category, cat_decl;\n+  tree inst_methods = NULL_TREE, class_methods = NULL_TREE;\n+  tree cat = impent->imp_context;\n+  location_t loc;\n+  char buf[BUFSIZE];\n+\n+  cat_decl = impent->class_decl;\n+  loc = DECL_SOURCE_LOCATION (cat_decl);\n+\n+  add_class_reference (CLASS_NAME (cat));\n+  cat_name_expr = add_objc_string (CLASS_SUPER_NAME (cat), class_names);\n+  class_name_expr = add_objc_string (CLASS_NAME (cat), class_names);\n+\n+  category = lookup_category (impent->imp_template, CLASS_SUPER_NAME (cat));\n+\n+  if (category && CLASS_PROTOCOL_LIST (category))\n+    {\n+      generate_protocol_references (CLASS_PROTOCOL_LIST (category));\n+      protocol_decl = generate_v1_protocol_list (category, cat);\n+    }\n+  else\n+    protocol_decl = 0;\n+\n+  if (flag_objc_abi >= 1)\n+    V1_Property_decl = generate_v1_property_table (NULL_TREE, cat);\n+  else\n+    V1_Property_decl = NULL_TREE;\n+\n+  if (CLASS_NST_METHODS (cat))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryInstanceMethods_%s_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (cat)),\n+\t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (cat)));\n+      inst_methods = generate_dispatch_table (CLASS_NST_METHODS (cat), buf,\n+\t\t\t\t\t      meta_cati_meth);\n+    }\n+\n+  if (CLASS_CLS_METHODS (cat))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryClassMethods_%s_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (cat)),\n+\t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (cat)));\n+      class_methods = generate_dispatch_table (CLASS_CLS_METHODS (cat), buf,\n+\t\t\t\t\t       meta_catc_meth);\n+    }\n+\n+  initlist = build_v1_category_initializer (TREE_TYPE (cat_decl),\n+\t\t\t\t\t    cat_name_expr, class_name_expr,\n+\t\t\t\t\t    inst_methods, class_methods,\n+\t\t\t\t\t    protocol_decl, V1_Property_decl,\n+\t\t\t\t\t    loc);\n+\n+  finish_var_decl (cat_decl, initlist);\n+  impent->class_decl = cat_decl;\n+}\n+\n+/* This routine builds the class extension used by v1 NeXT.\n+*/\n+\n+static tree\n+generate_objc_class_ext (tree property_list, tree context)\n+{\n+  tree decl, expr, ltyp;\n+  tree weak_ivar_layout_tree;\n+  int size;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  char buf[BUFSIZE];\n+\n+  /* TODO: pass the loc in or find it from args.  */\n+  loc = UNKNOWN_LOCATION;\n+\n+  /* const char *weak_ivar_layout \n+     TODO: Figure the ivar layouts out... */\n+  weak_ivar_layout_tree = NULL_TREE;\n+\n+  if (!property_list && !weak_ivar_layout_tree)\n+    return NULL_TREE;\n+\n+  if (!objc_class_ext_template)\n+    build_objc_class_ext_template ();\n+\n+  /* uint32_t size */\n+  size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_class_ext_template));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n+\n+  ltyp = const_string_type_node;\n+  if (weak_ivar_layout_tree)\n+    expr = convert (ltyp, weak_ivar_layout_tree);\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+    \n+  /* struct _prop_list_t *properties; */\n+  ltyp = objc_prop_list_ptr;\n+  if (property_list)\n+     expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, property_list, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  snprintf (buf, BUFSIZE, \"_OBJC_ClassExt_%s\",\n+\t    IDENTIFIER_POINTER (CLASS_NAME (context)));\n+  decl = start_var_decl (objc_class_ext_template, buf);\n+  expr = objc_build_constructor (TREE_TYPE (decl), v);\n+  OBJCMETA (decl, objc_meta, meta_class_extension);\n+  finish_var_decl (decl, expr);\n+  return decl;\n+}\n+\n+/* struct _objc_class {\n+     struct objc_class *isa;\n+     struct objc_class *super_class;\n+     char *name;\n+     long version;\n+     long info;\n+     long instance_size;\n+     struct objc_ivar_list *ivars;\n+     struct objc_method_list *methods;\n+     struct objc_cache *cache;\n+     struct objc_protocol_list *protocols;\n+  #if ABI >= 1\n+     const char *ivar_layout;\n+     struct _objc_class_ext *ext;\n+  #else\n+     void *sel_id;\n+     void *gc_object_type;\n+  #endif\n+   };  */\n+\n+static tree\n+build_v1_shared_structure_initializer (tree type, tree isa, tree super,\n+\t\t\t\t    tree name, tree size, int status,\n+\t\t\t\t    tree dispatch_table, tree ivar_list,\n+\t\t\t\t    tree protocol_list, tree class_ext)\n+{\n+  tree expr, ltyp;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  /* TODO: fish the location out of the input data.  */\n+  loc = UNKNOWN_LOCATION;\n+\n+  /* isa = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, isa);\n+\n+  /* super_class = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, super);\n+\n+  /* name = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, default_conversion (name));\n+\n+  /* version = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+                          build_int_cst (long_integer_type_node, 0));\n+\n+  /* info = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+                          build_int_cst (long_integer_type_node, status));\n+\n+  /* instance_size = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+                          convert (long_integer_type_node, size));\n+\n+  /* objc_ivar_list = */\n+  ltyp = objc_ivar_list_ptr;\n+  if (ivar_list)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, ivar_list, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  /* objc_method_list = */\n+  ltyp = objc_method_list_ptr;\n+  if (dispatch_table)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, dispatch_table, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  ltyp = build_pointer_type (xref_tag (RECORD_TYPE, \n+\t\t\t\t\tget_identifier (\"objc_cache\")));\n+  /* method_cache = */\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, convert (ltyp, null_pointer_node));\n+\n+  /* protocol_list = */\n+  ltyp = build_pointer_type (build_pointer_type (objc_protocol_template));\n+  if (protocol_list)\n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR,  protocol_list, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  if (flag_objc_abi >= 1)\n+    {\n+      /* TODO: figure out the ivar_layout stuff.  */\n+      expr = convert (const_string_type_node, null_pointer_node);\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+      if (!objc_class_ext_template)\n+\tbuild_objc_class_ext_template ();\n+      ltyp = build_pointer_type (objc_class_ext_template);\n+      if (class_ext)\n+\texpr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, class_ext, 0));\n+      else\n+\texpr = convert (ltyp, null_pointer_node);\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+    }\n+  else\n+    {\n+      /* sel_id = NULL */\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, null_pointer_node);\n+\n+      /* gc_object_type = NULL */\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, null_pointer_node);\n+    }\n+  return objc_build_constructor (type, v);\n+}\n+\n+static tree\n+generate_ivars_list (tree chain, const char *name, tree attr)\n+{\n+  tree initlist, ivar_list_template, decl;\n+  int size;\n+  VEC(constructor_elt,gc) *inits = NULL;\n+\n+  if (!chain)\n+    return NULL_TREE;\n+\n+  if (!objc_ivar_template)\n+    objc_ivar_template = build_ivar_template ();\n+\n+  size = ivar_list_length (chain);\n+\n+  generating_instance_variables = 1;\n+  ivar_list_template = build_ivar_list_template (objc_ivar_template, size);\n+  initlist = build_ivar_list_initializer (objc_ivar_template, chain);\n+  generating_instance_variables = 0;\n+\n+  decl = start_var_decl (ivar_list_template, name);\n+\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, build_int_cst (NULL_TREE, size));\n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, initlist);\n+\n+  OBJCMETA (decl, objc_meta, attr);\n+  finish_var_decl (decl,\n+\t\t   objc_build_constructor (TREE_TYPE (decl), inits));\n+\n+  return decl;\n+}\n+\n+/* static struct objc_class _OBJC_METACLASS_Foo={ ... };\n+   static struct objc_class _OBJC_CLASS_Foo={ ... };  */\n+\n+static void\n+generate_v1_class_structs (struct imp_entry *impent)\n+{\n+  tree name_expr, super_expr, root_expr, class_decl, meta_decl;\n+  tree my_root_id, my_super_id;\n+  tree cast_type, initlist, protocol_decl;\n+  tree class_ext_decl = NULL_TREE, props = NULL_TREE;\n+  tree inst_methods = NULL_TREE, class_methods = NULL_TREE;\n+  tree chain, inst_ivars = NULL_TREE, class_ivars = NULL_TREE;\n+  int cls_flags;\n+  location_t loc;\n+  char buf[BUFSIZE];\n+  \n+/*  objc_implementation_context = impent->imp_context;\n+  implementation_template = impent->imp_template;*/\n+  class_decl = impent->class_decl;\n+  meta_decl = impent->meta_decl;\n+  cls_flags = impent->has_cxx_cdtors ? CLS_HAS_CXX_STRUCTORS : 0 ;\n+  \n+  loc = DECL_SOURCE_LOCATION (impent->class_decl);\n+  \n+  if (flag_objc_abi >= 1)\n+    {\n+      /* ABI=1 additions.  */\n+      props = generate_v1_property_table (NULL_TREE, impent->imp_context);\n+      class_ext_decl = generate_objc_class_ext (props, impent->imp_context);\n+    }\n+\n+  my_super_id = CLASS_SUPER_NAME (impent->imp_template);\n+  if (my_super_id)\n+    {\n+      add_class_reference (my_super_id);\n+\n+      /* Compute \"my_root_id\" - this is required for code generation.\n+         the \"isa\" for all meta class structures points to the root of\n+         the inheritance hierarchy (e.g. \"__Object\")...  */\n+      my_root_id = my_super_id;\n+      do\n+\t{\n+\t  tree my_root_int = lookup_interface (my_root_id);\n+\n+\t  if (my_root_int && CLASS_SUPER_NAME (my_root_int))\n+\t    my_root_id = CLASS_SUPER_NAME (my_root_int);\n+\t  else\n+\t    break;\n+\t}\n+      while (1);\n+      super_expr = add_objc_string (my_super_id, class_names);\n+    }\n+  else\n+    {\n+      /* No super class.  */\n+      my_root_id = CLASS_NAME (impent->imp_template);\n+      super_expr = null_pointer_node;\n+    }\n+\n+  /* Install class `isa' and `super' pointers at runtime.  */\n+  cast_type = build_pointer_type (objc_class_template);\n+  super_expr = build_c_cast (loc, cast_type, super_expr);\n+\n+  root_expr = add_objc_string (my_root_id, class_names);\n+  root_expr = build_c_cast (loc, cast_type, root_expr);\n+\n+  if (CLASS_PROTOCOL_LIST (impent->imp_template))\n+    {\n+      generate_protocol_references (CLASS_PROTOCOL_LIST (impent->imp_template));\n+      protocol_decl = generate_v1_protocol_list (impent->imp_template,\n+\t\t\t\t\t\t impent->imp_context);\n+    }\n+  else\n+    protocol_decl = NULL_TREE;\n+\n+  if (CLASS_CLS_METHODS (impent->imp_context))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassMethods_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      class_methods = generate_dispatch_table (CLASS_CLS_METHODS (impent->imp_context),\n+\t\t\t\t\t       buf, meta_clac_meth);\n+    }\n+\n+  if (CLASS_SUPER_NAME (impent->imp_template) == NULL_TREE\n+      && (chain = TYPE_FIELDS (objc_class_template)))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassIvars_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      class_ivars = generate_ivars_list (chain, buf, meta_clac_vars);\n+    }\n+  /* TODO: get rid of hidden passing of stuff in globals.  */\n+  /* UOBJC_INSTANCE/CLASS_Variables_decl made in generate_ivarlists().  */\n+\n+  name_expr = add_objc_string (CLASS_NAME (impent->imp_template), class_names);\n+\n+  /* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */\n+\n+  initlist = build_v1_shared_structure_initializer \n+\t\t(TREE_TYPE (meta_decl),\n+\t\troot_expr, super_expr, name_expr,\n+\t\tconvert (integer_type_node, TYPE_SIZE_UNIT (objc_class_template)),\n+\t\tCLS_META, class_methods, class_ivars,\n+\t\tprotocol_decl, NULL_TREE);\n+\n+  finish_var_decl (meta_decl, initlist);\n+  impent->meta_decl = meta_decl;\n+\n+  /* static struct objc_class _OBJC_CLASS_Foo={ ... }; */\n+  if (CLASS_NST_METHODS (impent->imp_context))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_InstanceMethods_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      inst_methods = generate_dispatch_table (CLASS_NST_METHODS (impent->imp_context),\n+\t\t\t\t\t      buf, meta_clai_meth);\n+    }\n+\n+  if ((chain = CLASS_IVARS (impent->imp_template)))\n+    {\n+      snprintf (buf, BUFSIZE, \"_OBJC_InstanceIvars_%s\",\n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      inst_ivars = generate_ivars_list (chain, buf, meta_clai_vars);\n+    }\n+\n+  initlist = build_v1_shared_structure_initializer\n+\t\t(TREE_TYPE (class_decl),\n+\t\tbuild_unary_op (loc, ADDR_EXPR, meta_decl, 0),\n+\t\tsuper_expr, name_expr,\n+\t\tconvert (integer_type_node, \n+\t\t\t TYPE_SIZE_UNIT (CLASS_STATIC_TEMPLATE (impent->imp_template))),\n+\t\tCLS_FACTORY | cls_flags, inst_methods, inst_ivars,\n+\t\tprotocol_decl, class_ext_decl);\n+\n+  finish_var_decl (class_decl, initlist);\n+  impent->class_decl = class_decl;\n+}\n+\n+/* --- Output NeXT V1 Metadata --- */\n+\n+/* Create the initial value for the `defs' field of _objc_symtab.\n+   This is a CONSTRUCTOR.  */\n+\n+static tree\n+init_def_list (tree type)\n+{\n+  tree expr;\n+  location_t loc;\n+  struct imp_entry *impent;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  if (imp_count)\n+    for (impent = imp_list; impent; impent = impent->next)\n+      {\n+\tif (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)\n+\t  {\n+\t    loc = DECL_SOURCE_LOCATION (impent->class_decl);\n+\t    expr = build_unary_op (loc,\n+\t\t\t\t   ADDR_EXPR, impent->class_decl, 0);\n+\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\t  }\n+      }\n+\n+  if (cat_count)\n+    for (impent = imp_list; impent; impent = impent->next)\n+      {\n+\tif (TREE_CODE (impent->imp_context) == CATEGORY_IMPLEMENTATION_TYPE)\n+\t  {\n+\t    loc = DECL_SOURCE_LOCATION (impent->class_decl);\n+\t    expr = build_unary_op (loc,\n+\t\t\t\t   ADDR_EXPR, impent->class_decl, 0);\n+\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\t  }\n+      }\n+\n+  return objc_build_constructor (type, v);\n+}\n+\n+/* Take care of defining and initializing _OBJC_SYMBOLS.  */\n+\n+/* Predefine the following data type:\n+\n+   struct _objc_symtab\n+   {\n+     long sel_ref_cnt;\n+     SEL *refs;\n+     short cls_def_cnt;\n+     short cat_def_cnt;\n+     void *defs[cls_def_cnt + cat_def_cnt];\n+   }; */\n+\n+static void\n+build_objc_symtab_template (void)\n+{\n+  tree fields, *chain = NULL;\n+\n+  objc_symtab_template = objc_start_struct (get_identifier (UTAG_SYMTAB));\n+\n+  /* long sel_ref_cnt; */\n+  fields = add_field_decl (long_integer_type_node, \"sel_ref_cnt\", &chain);\n+\n+  /* SEL *refs; */\n+  add_field_decl (build_pointer_type (objc_selector_type), \"refs\", &chain);\n+\n+  /* short cls_def_cnt; */\n+  add_field_decl (short_integer_type_node, \"cls_def_cnt\", &chain);\n+\n+  /* short cat_def_cnt; */\n+  add_field_decl (short_integer_type_node, \"cat_def_cnt\", &chain);\n+\n+  if (imp_count || cat_count)\n+    {\n+      /* void *defs[imp_count + cat_count (+ 1)]; */\n+      /* NB: The index is one less than the size of the array.  */\n+      int index = imp_count + cat_count;\n+      tree array_type = build_sized_array_type (ptr_type_node, index);\n+      add_field_decl (array_type, \"defs\", &chain);\n+    }\n+\n+  objc_finish_struct (objc_symtab_template, fields);\n+}\n+/* Construct the initial value for all of _objc_symtab.  */\n+\n+static tree\n+init_objc_symtab (tree type)\n+{\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  /* sel_ref_cnt = { ..., 5, ... } */\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t  build_int_cst (long_integer_type_node, 0));\n+\n+  /* refs = { ..., _OBJC_SELECTOR_TABLE, ... } */\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  convert (build_pointer_type (objc_selector_type),\n+\t\t\t\t\t\t\tinteger_zero_node));\n+\n+  /* cls_def_cnt = { ..., 5, ... } */\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  build_int_cst (short_integer_type_node, imp_count));\n+\n+  /* cat_def_cnt = { ..., 5, ... } */\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  build_int_cst (short_integer_type_node, cat_count));\n+\n+  /* cls_def = { ..., { &Foo, &Bar, ...}, ... } */\n+\n+  if (imp_count || cat_count)\n+    {\n+      tree field = TYPE_FIELDS (type);\n+      field = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (field))));\n+\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init_def_list (TREE_TYPE (field)));\n+    }\n+\n+  return objc_build_constructor (type, v);\n+}\n+\n+/* Create the declaration of _OBJC_SYMBOLS, with type `struct _objc_symtab'\n+   and initialized appropriately.  */\n+\n+static void\n+generate_objc_symtab_decl (void)\n+{\n+  build_objc_symtab_template ();\n+  UOBJC_SYMBOLS_decl = start_var_decl (objc_symtab_template, \"_OBJC_Symbols\");\n+  /* Allow the runtime to mark meta-data such that it can be assigned to target\n+     specific sections by the back-end.  */\n+  OBJCMETA (UOBJC_SYMBOLS_decl, objc_meta, meta_symtab);\n+  finish_var_decl (UOBJC_SYMBOLS_decl,\n+\t\t   init_objc_symtab (TREE_TYPE (UOBJC_SYMBOLS_decl)));\n+}\n+\n+\n+static void\n+handle_next_class_ref (tree chain)\n+{\n+  const char *name = IDENTIFIER_POINTER (TREE_VALUE (chain));\n+  char *string = (char *) alloca (strlen (name) + 30);\n+\n+  sprintf (string, \".objc_class_name_%s\", name);\n+\n+#ifdef ASM_DECLARE_UNRESOLVED_REFERENCE\n+  ASM_DECLARE_UNRESOLVED_REFERENCE (asm_out_file, string);\n+#else\n+  return ; /* NULL build for targets other than Darwin.  */\n+#endif\n+}\n+\n+static void\n+handle_next_impent (struct imp_entry *impent)\n+{\n+  char buf[BUFSIZE];\n+\n+  switch (TREE_CODE (impent->imp_context))\n+    {\n+    case CLASS_IMPLEMENTATION_TYPE:\n+      snprintf (buf, BUFSIZE, \".objc_class_name_%s\", \n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      break;\n+    case CATEGORY_IMPLEMENTATION_TYPE:\n+      snprintf (buf, BUFSIZE, \"*.objc_category_name_%s_%s\", \n+\t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)),\n+\t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context)));\n+      break;\n+    default:\n+      return;\n+    }\n+\n+#ifdef ASM_DECLARE_CLASS_REFERENCE\n+  ASM_DECLARE_CLASS_REFERENCE (asm_out_file, buf);\n+#else\n+  return ; /* NULL build for targets other than Darwin.  */\n+#endif\n+}\n+\n+static void\n+generate_classref_translation_entry (tree chain)\n+{\n+  tree expr, decl, type;\n+\n+  decl = TREE_PURPOSE (chain);\n+  type = TREE_TYPE (decl);\n+\n+  expr = add_objc_string (TREE_VALUE (chain), class_names);\n+  expr = convert (type, expr); /* cast! */\n+\n+  /* This is a class reference.  It is re-written by the runtime,\n+     but will be optimized away unless we force it.  */\n+  DECL_PRESERVE_P (decl) = 1;\n+  OBJCMETA (decl, objc_meta, meta_class_reference);\n+  finish_var_decl (decl, expr);\n+  return;\n+}\n+\n+\n+/* The Fix-and-Continue functionality available in Mac OS X 10.3 and\n+   later requires that ObjC translation units participating in F&C be\n+   specially marked.  The following routine accomplishes this.  */\n+\n+/* static int _OBJC_IMAGE_INFO[2] = { 0, 1 }; */\n+\n+static void\n+generate_objc_image_info (void)\n+{\n+  tree decl;\n+  int flags\n+    = ((flag_replace_objc_classes && imp_count ? 1 : 0)\n+       | (flag_objc_gc ? 2 : 0));\n+  VEC(constructor_elt,gc) *v = NULL;\n+  tree array_type;\n+  \n+  array_type  = build_sized_array_type (integer_type_node, 2);\n+\n+  decl = start_var_decl (array_type, \"_OBJC_ImageInfo\");\n+\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (integer_type_node, flags));\n+  /* The runtime wants this and refers to it in a manner hidden from the compiler.\n+     So we must force the output.  */\n+  DECL_PRESERVE_P (decl) = 1;\n+  OBJCMETA (decl, objc_meta, meta_info);\n+  finish_var_decl (decl, objc_build_constructor (TREE_TYPE (decl), v));\n+}\n+\n+static void\n+objc_generate_v1_next_metadata (void)\n+{\n+  struct imp_entry *impent;\n+  tree chain, attr;\n+  long vers;\n+\n+  if (objc_static_instances)\n+    gcc_unreachable (); /* Not for NeXT */\n+\n+  build_metadata_templates ();\n+  objc_implementation_context =\n+  implementation_template =\n+  UOBJC_CLASS_decl =\n+  UOBJC_METACLASS_decl = NULL_TREE;\n+\n+  for (impent = imp_list; impent; impent = impent->next)\n+    {\n+\n+      /* If -gen-decls is present, Dump the @interface of each class.\n+\t TODO: Dump the classes in the  order they were found, rather than in\n+\t reverse order as we are doing now.  */\n+      if (flag_gen_declaration)\n+\tdump_interface (gen_declaration_file, impent->imp_context);\n+\n+      /* all of the following reference the string pool...  */\n+      if (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)\n+\tgenerate_v1_class_structs (impent);\n+      else\n+\tgenerate_v1_category (impent);\n+    }\n+\n+  /* If we are using an array of selectors, we must always\n+     finish up the array decl even if no selectors were used.  */\n+  build_next_selector_translation_table ();\n+\n+  if (protocol_chain)\n+    generate_v1_protocols ();\n+\n+  /* Pass summary information to the runtime.  */\n+  if (imp_count || cat_count)\n+    generate_objc_symtab_decl ();\n+\n+  vers = OBJC_VERSION;\n+  attr = build_tree_list (objc_meta, meta_modules);\n+  build_module_descriptor (vers, attr);\n+\n+  /* This conveys information on GC usage and zero-link.  */\n+  generate_objc_image_info ();\n+\n+  /* Dump the class references.  This forces the appropriate classes\n+     to be linked into the executable image, preserving unix archive\n+     semantics.  This can be removed when we move to a more dynamically\n+     linked environment.  */\n+\n+  for (chain = cls_ref_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      handle_next_class_ref (chain);\n+      if (TREE_PURPOSE (chain))\n+\tgenerate_classref_translation_entry (chain);\n+    }\n+\n+  for (impent = imp_list; impent; impent = impent->next)\n+    handle_next_impent (impent);\n+\n+  /* Emit the strings tables.  */\n+  generate_strings ();\n+}\n+\n+/* --- exceptions stuff --- */\n+\n+/* Predefine the following data type:\n+\n+   struct _objc_exception_data\n+   {\n+     int buf[OBJC_JBLEN];\n+     void *pointers[4];\n+   }; */\n+\n+/* The following yuckiness should prevent users from having to #include\n+   <setjmp.h> in their code... */\n+\n+/* Define to a harmless positive value so the below code doesn't die.  */\n+#ifndef OBJC_JBLEN\n+#define OBJC_JBLEN 18\n+#endif\n+\n+static void\n+build_next_objc_exception_stuff (void)\n+{\n+  tree decls, temp_type, *chain = NULL;\n+\n+  objc_exception_data_template\n+    = objc_start_struct (get_identifier (UTAG_EXCDATA));\n+\n+  /* int buf[OBJC_JBLEN]; */\n+\n+  temp_type = build_sized_array_type (integer_type_node, OBJC_JBLEN);\n+  decls = add_field_decl (temp_type, \"buf\", &chain);\n+\n+  /* void *pointers[4]; */\n+\n+  temp_type = build_sized_array_type (ptr_type_node, 4);\n+  add_field_decl (temp_type, \"pointers\", &chain);\n+\n+  objc_finish_struct (objc_exception_data_template, decls);\n+\n+  /* int _setjmp(...); */\n+  /* If the user includes <setjmp.h>, this shall be superseded by\n+     'int _setjmp(jmp_buf);' */\n+  temp_type = build_varargs_function_type_list (integer_type_node, NULL_TREE);\n+  objc_setjmp_decl\n+    = add_builtin_function (TAG_SETJMP, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n+\n+  /* id objc_exception_extract(struct _objc_exception_data *); */\n+  temp_type\n+    = build_function_type_list (objc_object_type,\n+                                build_pointer_type (objc_exception_data_template),\n+                                NULL_TREE);\n+  objc_exception_extract_decl\n+    = add_builtin_function (TAG_EXCEPTIONEXTRACT, temp_type, 0, NOT_BUILT_IN, NULL,\n+\t\t\t    NULL_TREE);\n+  /* void objc_exception_try_enter(struct _objc_exception_data *); */\n+  /* void objc_exception_try_exit(struct _objc_exception_data *); */\n+  temp_type\n+    = build_function_type_list (void_type_node,\n+                                build_pointer_type (objc_exception_data_template),\n+                                NULL_TREE);\n+  objc_exception_try_enter_decl\n+    = add_builtin_function (TAG_EXCEPTIONTRYENTER, temp_type, 0, NOT_BUILT_IN, NULL,\n+\t\t\t    NULL_TREE);\n+  objc_exception_try_exit_decl\n+    = add_builtin_function (TAG_EXCEPTIONTRYEXIT, temp_type, 0, NOT_BUILT_IN, NULL,\n+\t\t\t    NULL_TREE);\n+\n+  /* int objc_exception_match(id, id); */\n+  temp_type\n+    = build_function_type_list (integer_type_node,\n+                                objc_object_type, objc_object_type, NULL_TREE);\n+  objc_exception_match_decl\n+    = add_builtin_function (TAG_EXCEPTIONMATCH, temp_type, 0, NOT_BUILT_IN, NULL,\n+\t\t\t    NULL_TREE);\n+\n+  /* id objc_assign_ivar (id, id, unsigned int); */\n+  /* id objc_assign_ivar_Fast (id, id, unsigned int)\n+       __attribute__ ((hard_coded_address (OFFS_ASSIGNIVAR_FAST))); */\n+  temp_type\n+    = build_function_type_list (objc_object_type,\n+                                objc_object_type,\n+                                objc_object_type,\n+                                unsigned_type_node,\n+                                NULL_TREE);\n+  objc_assign_ivar_decl\n+    = add_builtin_function (TAG_ASSIGNIVAR, temp_type, 0, NOT_BUILT_IN,\n+\t\t\t    NULL, NULL_TREE);\n+#ifdef OFFS_ASSIGNIVAR_FAST\n+  objc_assign_ivar_fast_decl\n+    = add_builtin_function (TAG_ASSIGNIVAR_FAST, temp_type, 0,\n+\t\t\t    NOT_BUILT_IN, NULL, NULL_TREE);\n+  DECL_ATTRIBUTES (objc_assign_ivar_fast_decl)\n+    = tree_cons (get_identifier (\"hard_coded_address\"),\n+\t\t build_int_cst (NULL_TREE, OFFS_ASSIGNIVAR_FAST),\n+\t\t NULL_TREE);\n+#else\n+  /* Default to slower ivar method.  */\n+  objc_assign_ivar_fast_decl = objc_assign_ivar_decl;\n+#endif\n+\n+  /* id objc_assign_global (id, id *); */\n+  /* id objc_assign_strongCast (id, id *); */\n+  temp_type = build_function_type_list (objc_object_type,\n+                                        objc_object_type,\n+                                        build_pointer_type (objc_object_type),\n+                                        NULL_TREE);\n+  objc_assign_global_decl\n+\t= add_builtin_function (TAG_ASSIGNGLOBAL, temp_type, 0, NOT_BUILT_IN, NULL,\n+\t\t\t\tNULL_TREE);\n+  objc_assign_strong_cast_decl\n+\t= add_builtin_function (TAG_ASSIGNSTRONGCAST, temp_type, 0, NOT_BUILT_IN, NULL,\n+\t\t\t\tNULL_TREE);\n+}\n+\n+/* --- NeXT V1 SJLJ Exceptions --- */\n+\n+/* Build \"objc_exception_try_exit(&_stack)\".  */\n+\n+static tree\n+next_sjlj_build_try_exit (struct objc_try_context **ctcp)\n+{\n+  tree t;\n+  t = build_fold_addr_expr_loc (input_location, (*ctcp)->stack_decl);\n+  t = tree_cons (NULL, t, NULL);\n+  t = build_function_call (input_location,\n+\t\t\t   objc_exception_try_exit_decl, t);\n+  return t;\n+}\n+\n+/* Build\n+\tobjc_exception_try_enter (&_stack);\n+\tif (_setjmp(&_stack.buf))\n+\t  ;\n+\telse\n+\t  ;\n+   Return the COND_EXPR.  Note that the THEN and ELSE fields are left\n+   empty, ready for the caller to fill them in.  */\n+\n+static tree\n+next_sjlj_build_enter_and_setjmp (struct objc_try_context **ctcp)\n+{\n+  tree t, enter, sj, cond;\n+\n+  t = build_fold_addr_expr_loc (input_location, (*ctcp)->stack_decl);\n+  t = tree_cons (NULL, t, NULL);\n+  enter = build_function_call (input_location,\n+\t\t\t       objc_exception_try_enter_decl, t);\n+\n+  t = objc_build_component_ref ((*ctcp)->stack_decl,\n+\t\t\t\tget_identifier (\"buf\"));\n+  t = build_fold_addr_expr_loc (input_location, t);\n+#ifdef OBJCPLUS\n+  /* Convert _setjmp argument to type that is expected.  */\n+  if (prototype_p (TREE_TYPE (objc_setjmp_decl)))\n+    t = convert (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (objc_setjmp_decl))), t);\n+  else\n+    t = convert (ptr_type_node, t);\n+#else\n+  t = convert (ptr_type_node, t);\n+#endif\n+  t = tree_cons (NULL, t, NULL);\n+  sj = build_function_call (input_location,\n+\t\t\t    objc_setjmp_decl, t);\n+\n+  cond = build2 (COMPOUND_EXPR, TREE_TYPE (sj), enter, sj);\n+  cond = c_common_truthvalue_conversion (input_location, cond);\n+\n+  return build3 (COND_EXPR, void_type_node, cond, NULL, NULL);\n+}\n+\n+/* Build:\n+\n+   DECL = objc_exception_extract(&_stack);  */\n+\n+static tree\n+next_sjlj_build_exc_extract (struct objc_try_context **ctcp, tree decl)\n+{\n+  tree t;\n+\n+  t = build_fold_addr_expr_loc (input_location, (*ctcp)->stack_decl);\n+  t = tree_cons (NULL, t, NULL);\n+  t = build_function_call (input_location,\n+\t\t\t   objc_exception_extract_decl, t);\n+  t = convert (TREE_TYPE (decl), t);\n+  t = build2 (MODIFY_EXPR, void_type_node, decl, t);\n+\n+  return t;\n+}\n+\n+/* Build\n+\tif (objc_exception_match(obj_get_class(TYPE), _caught)\n+\t  BODY\n+\telse if (...)\n+\t  ...\n+\telse\n+\t  {\n+\t    _rethrow = _caught;\n+\t    objc_exception_try_exit(&_stack);\n+\t  }\n+   from the sequence of CATCH_EXPRs in the current try context.  */\n+\n+static tree\n+next_sjlj_build_catch_list (struct objc_try_context **ctcp)\n+{\n+  tree_stmt_iterator i = tsi_start ((*ctcp)->catch_list);\n+  tree catch_seq, t;\n+  tree *last = &catch_seq;\n+  bool saw_id = false;\n+\n+  for (; !tsi_end_p (i); tsi_next (&i))\n+    {\n+      tree stmt = tsi_stmt (i);\n+      tree type = CATCH_TYPES (stmt);\n+      tree body = CATCH_BODY (stmt);\n+\n+      if (type != error_mark_node\n+\t  && objc_is_object_id (TREE_TYPE (type)))\n+\t{\n+\t  *last = body;\n+\t  saw_id = true;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  tree args, cond;\n+\n+\t  if (type == error_mark_node)\n+\t    cond = error_mark_node;\n+\t  else\n+\t    {\n+\t      args = tree_cons (NULL, (*ctcp)->caught_decl, NULL);\n+\t      t = objc_get_class_reference (OBJC_TYPE_NAME (TREE_TYPE (type)));\n+\t      args = tree_cons (NULL, t, args);\n+\t      t = build_function_call (input_location,\n+\t\t\t\t       objc_exception_match_decl, args);\n+\t      cond = c_common_truthvalue_conversion (input_location, t);\n+\t    }\n+\t  t = build3 (COND_EXPR, void_type_node, cond, body, NULL);\n+\t  SET_EXPR_LOCATION (t, EXPR_LOCATION (stmt));\n+\n+\t  *last = t;\n+\t  last = &COND_EXPR_ELSE (t);\n+\t}\n+    }\n+\n+  if (!saw_id)\n+    {\n+      t = build2 (MODIFY_EXPR, void_type_node, (*ctcp)->rethrow_decl,\n+\t\t  (*ctcp)->caught_decl);\n+      SET_EXPR_LOCATION (t, (*ctcp)->end_catch_locus);\n+      append_to_statement_list (t, last);\n+\n+      t = next_sjlj_build_try_exit (ctcp);\n+      SET_EXPR_LOCATION (t, (*ctcp)->end_catch_locus);\n+      append_to_statement_list (t, last);\n+    }\n+\n+  return catch_seq;\n+}\n+\n+/* Build a complete @try-@catch-@finally block for legacy Darwin setjmp\n+   exception handling.  We aim to build:\n+\n+\t{\n+\t  struct _objc_exception_data _stack;\n+\t  id _rethrow = 0;\n+\t  try\n+\t    {\n+\t      objc_exception_try_enter (&_stack);\n+\t      if (_setjmp(&_stack.buf))\n+\t        {\n+\t\t  id _caught = objc_exception_extract(&_stack);\n+\t\t  objc_exception_try_enter (&_stack);\n+\t\t  if (_setjmp(&_stack.buf))\n+\t\t    _rethrow = objc_exception_extract(&_stack);\n+\t\t  else\n+\t\t    CATCH-LIST\n+\t        }\n+\t      else\n+\t\tTRY-BLOCK\n+\t    }\n+\t  finally\n+\t    {\n+\t      if (!_rethrow)\n+\t\tobjc_exception_try_exit(&_stack);\n+\t      FINALLY-BLOCK\n+\t      if (_rethrow)\n+\t\tobjc_exception_throw(_rethrow);\n+\t    }\n+\t}\n+\n+   If CATCH-LIST is empty, we can omit all of the block containing\n+   \"_caught\" except for the setting of _rethrow.  Note the use of\n+   a real TRY_FINALLY_EXPR here, which is not involved in EH per-se,\n+   but handles goto and other exits from the block.  */\n+\n+static tree\n+next_sjlj_build_try_catch_finally (struct objc_try_context **ctcp)\n+{\n+  tree rethrow_decl, stack_decl, t;\n+  tree catch_seq, try_fin, bind;\n+  struct objc_try_context *cur_try_context = *ctcp;\n+\n+  /* Create the declarations involved.  */\n+  t = xref_tag (RECORD_TYPE, get_identifier (UTAG_EXCDATA));\n+  stack_decl = objc_create_temporary_var (t, NULL);\n+  cur_try_context->stack_decl = stack_decl;\n+\n+  rethrow_decl = objc_create_temporary_var (objc_object_type, NULL);\n+  cur_try_context->rethrow_decl = rethrow_decl;\n+  TREE_CHAIN (rethrow_decl) = stack_decl;\n+\n+  /* Build the outermost variable binding level.  */\n+  bind = build3 (BIND_EXPR, void_type_node, rethrow_decl, NULL, NULL);\n+  SET_EXPR_LOCATION (bind, cur_try_context->try_locus);\n+  TREE_SIDE_EFFECTS (bind) = 1;\n+\n+  /* Initialize rethrow_decl.  */\n+  t = build2 (MODIFY_EXPR, void_type_node, rethrow_decl,\n+\t      convert (objc_object_type, null_pointer_node));\n+  SET_EXPR_LOCATION (t, cur_try_context->try_locus);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n+\n+  /* Build the outermost TRY_FINALLY_EXPR.  */\n+  try_fin = build2 (TRY_FINALLY_EXPR, void_type_node, NULL, NULL);\n+  SET_EXPR_LOCATION (try_fin, cur_try_context->try_locus);\n+  TREE_SIDE_EFFECTS (try_fin) = 1;\n+  append_to_statement_list (try_fin, &BIND_EXPR_BODY (bind));\n+\n+  /* Create the complete catch sequence.  */\n+  if (cur_try_context->catch_list)\n+    {\n+      tree caught_decl = objc_build_exc_ptr (ctcp);\n+      catch_seq = build_stmt (input_location, BIND_EXPR, caught_decl, NULL, NULL);\n+      TREE_SIDE_EFFECTS (catch_seq) = 1;\n+\n+      t = next_sjlj_build_exc_extract (ctcp, caught_decl);\n+      append_to_statement_list (t, &BIND_EXPR_BODY (catch_seq));\n+\n+      t = next_sjlj_build_enter_and_setjmp (ctcp);\n+      COND_EXPR_THEN (t) = next_sjlj_build_exc_extract (ctcp, rethrow_decl);\n+      COND_EXPR_ELSE (t) = next_sjlj_build_catch_list (ctcp);\n+      append_to_statement_list (t, &BIND_EXPR_BODY (catch_seq));\n+    }\n+  else\n+    catch_seq = next_sjlj_build_exc_extract (ctcp, rethrow_decl);\n+  SET_EXPR_LOCATION (catch_seq, cur_try_context->end_try_locus);\n+\n+  /* Build the main register-and-try if statement.  */\n+  t = next_sjlj_build_enter_and_setjmp (ctcp);\n+  SET_EXPR_LOCATION (t, cur_try_context->try_locus);\n+  COND_EXPR_THEN (t) = catch_seq;\n+  COND_EXPR_ELSE (t) = cur_try_context->try_body;\n+  TREE_OPERAND (try_fin, 0) = t;\n+\n+  /* Build the complete FINALLY statement list.  */\n+  t = next_sjlj_build_try_exit (ctcp);\n+  t = build_stmt (input_location, COND_EXPR,\n+\t\t  c_common_truthvalue_conversion \n+\t\t    (input_location, rethrow_decl),\n+\t\t  NULL, t);\n+  SET_EXPR_LOCATION (t, cur_try_context->finally_locus);\n+  append_to_statement_list (t, &TREE_OPERAND (try_fin, 1));\n+\n+  append_to_statement_list (cur_try_context->finally_body,\n+\t\t\t    &TREE_OPERAND (try_fin, 1));\n+\n+  t = tree_cons (NULL, rethrow_decl, NULL);\n+  t = build_function_call (input_location,\n+\t\t\t   objc_exception_throw_decl, t);\n+  t = build_stmt (input_location, COND_EXPR,\n+\t\t  c_common_truthvalue_conversion (input_location, \n+\t\t\t\t\t\t  rethrow_decl),\n+\t\t  t, NULL);\n+  SET_EXPR_LOCATION (t, cur_try_context->end_finally_locus);\n+  append_to_statement_list (t, &TREE_OPERAND (try_fin, 1));\n+\n+  return bind;\n+}\n+\n+/* We do not expect this to be used at the moment.\n+   If (a) it is possible to implement unwinder exceptions.\n+      (b) we do it... then it might be possibly useful.\n+*/\n+static GTY(()) tree objc_eh_personality_decl;\n+\n+static tree\n+objc_eh_runtime_type (tree type)\n+{\n+  tree ident, eh_id, decl, str;\n+\n+  gcc_unreachable ();\n+  if (type == error_mark_node)\n+    {\n+      /* Use 'ErrorMarkNode' as class name when error_mark_node is found\n+\t to prevent an ICE.  Note that we know that the compiler will\n+\t terminate with an error and this 'ErrorMarkNode' class name will\n+\t never be actually used.  */\n+      ident = get_identifier (\"ErrorMarkNode\");\n+      goto make_err_class;\n+    }\n+\n+  if (POINTER_TYPE_P (type) && objc_is_object_id (TREE_TYPE (type)))\n+    {\n+      ident = get_identifier (\"id\");\n+      goto make_err_class;\n+    }\n+\n+  if (!POINTER_TYPE_P (type) || !TYPED_OBJECT (TREE_TYPE (type)))\n+    {\n+#ifdef OBJCPLUS\n+      /* This routine is also called for c++'s catch clause; in which case,\n+\t we use c++'s typeinfo decl. */\n+      return build_eh_type_type (type);\n+#else\n+      error (\"non-objective-c type '%T' cannot be caught\", type);\n+      ident = get_identifier (\"ErrorMarkNode\");\n+      goto make_err_class;\n+#endif\n+    }\n+  else\n+    ident = OBJC_TYPE_NAME (TREE_TYPE (type));\n+\n+make_err_class:\n+  /* If this class was already referenced, then it will be output during\n+     meta-data emission, so we don't need to do it here.  */\n+  decl = get_objc_string_decl (ident, class_names);\n+  eh_id = add_objc_string (ident, class_names);\n+  if (!decl)\n+    {\n+      /* Not found ... so we need to build it - from the freshly-entered id.  */\n+      decl = get_objc_string_decl (ident, class_names);\n+      str = my_build_string (IDENTIFIER_LENGTH (ident) + 1,\n+\t\t\t     IDENTIFIER_POINTER (ident));\n+      /* We have to finalize this var here, because this might be called after\n+\t all the other metadata strings have been emitted.  */\n+      finish_var_decl (decl, str);\n+    }\n+  return eh_id;\n+}\n+\n+static tree\n+objc_eh_personality (void)\n+{\n+  if (!objc_eh_personality_decl)\n+#ifndef OBJCPLUS\n+    objc_eh_personality_decl = build_personality_function (\"objc\");\n+#else\n+    objc_eh_personality_decl = build_personality_function (\"gxx\");\n+#endif\n+  return objc_eh_personality_decl;\n+}\n+\n+/* --- interfaces --- */\n+\n+static tree\n+build_throw_stmt (location_t loc, tree throw_expr, bool rethrown ATTRIBUTE_UNUSED)\n+{\n+  tree t;\n+  VEC(tree, gc) *parms = VEC_alloc (tree, gc, 1);\n+  /* A throw is just a call to the runtime throw function with the\n+     object as a parameter.  */\n+  VEC_quick_push (tree, parms, throw_expr);\n+  t = build_function_call_vec (loc, objc_exception_throw_decl, parms, NULL);\n+  VEC_free (tree, gc, parms);\n+  return add_stmt (t);\n+}\n+\n+/* Build __builtin_eh_pointer, or the moral equivalent.  In the case\n+   of Darwin, we'll arrange for it to be initialized (and associated\n+   with a binding) later.  */\n+\n+static tree\n+objc_build_exc_ptr (struct objc_try_context **cur_try_context)\n+{\n+  if (flag_objc_sjlj_exceptions)\n+    {\n+      tree var = (*cur_try_context)->caught_decl;\n+      if (!var)\n+\t{\n+\t  var = objc_create_temporary_var (objc_object_type, NULL);\n+\t  (*cur_try_context)->caught_decl = var;\n+\t}\n+      return var;\n+    }\n+  else\n+    {\n+      tree t;\n+      t = built_in_decls[BUILT_IN_EH_POINTER];\n+      t = build_call_expr (t, 1, integer_zero_node);\n+      return fold_convert (objc_object_type, t);\n+    }\n+}\n+\n+static tree \n+begin_catch (struct objc_try_context **cur_try_context, tree type,\n+\t     tree decl, tree compound, bool ellipsis ATTRIBUTE_UNUSED)\n+{\n+  tree t;\n+  /* Record the data for the catch in the try context so that we can\n+     finalize it later.  We treat ellipsis the same way as catching\n+     with 'id xyz'.  */\n+  t = build_stmt (input_location, CATCH_EXPR, type, compound);\n+  (*cur_try_context)->current_catch = t;\n+\n+  /* Initialize the decl from the EXC_PTR_EXPR we get from the runtime.  */\n+  t = objc_build_exc_ptr (cur_try_context);\n+  t = convert (TREE_TYPE (decl), t);\n+  return build2 (MODIFY_EXPR, void_type_node, decl, t);\n+}\n+\n+static void \n+finish_catch (struct objc_try_context **cur_try_context, tree current_catch)\n+{\n+  append_to_statement_list (current_catch, &((*cur_try_context)->catch_list));\n+}\n+\n+static tree \n+finish_try_stmt (struct objc_try_context **cur_try_context)\n+{\n+  tree stmt;\n+  struct objc_try_context *c = *cur_try_context;\n+  /* If we're doing Darwin setjmp exceptions, build the big nasty.  */\n+  if (flag_objc_sjlj_exceptions)\n+    {\n+      bool save = in_late_binary_op;\n+      in_late_binary_op = true;\n+      if (!c->finally_body)\n+\t{\n+\t  c->finally_locus = input_location;\n+\t  c->end_finally_locus = input_location;\n+\t}\n+      stmt = next_sjlj_build_try_catch_finally (cur_try_context);\n+      in_late_binary_op = save;\n+    }\n+  else\n+    /* This doesn't happen at the moment... but maybe one day... */\n+    {\n+      /* Otherwise, nest the CATCH inside a FINALLY.  */\n+      stmt = c->try_body;\n+      if (c->catch_list)\n+\tstmt = build_stmt (c->try_locus, TRY_CATCH_EXPR, stmt, c->catch_list);\n+      if (c->finally_body)\n+\tstmt = build_stmt (c->try_locus, TRY_FINALLY_EXPR, stmt, c->finally_body);\n+    }\n+  return stmt;\n+}\n+\n+#include \"gt-objc-objc-next-runtime-abi-01.h\""}, {"sha": "46e56937755dcb036fed872464080ff8096647f0", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "added", "additions": 3750, "deletions": 0, "changes": 3750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e"}, {"sha": "d071c8b771ec3f0f8b65d38f6b3e87be806d2923", "filename": "gcc/objc/objc-runtime-hooks.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-runtime-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-runtime-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-hooks.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -0,0 +1,108 @@\n+/* Hooks to abstract the runtime meta-data generation for Objective C.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Iain Sandoe \n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _OBJC_RUNTIME_HOOKS_H_\n+#define _OBJC_RUNTIME_HOOKS_H_\n+\n+/* A set of hooks for the front end to obtain runtime-specific actions.  */\n+\n+/* Objective-C supports several runtime library variants: \n+\n+   \"GNU\" runtime selected by -fgnu-runtime (currently at API version 1).\n+   \"NeXT\" runtime (selected by -fnext-runtime) and installed on OSX/Darwin\n+   systems at API version 1 (for m32 code) and version 2 (for m64 code).\n+   \n+   The runtimes require different data types/layouts, method call mechanisms\n+   and so on, and the purpose of this interface is to abstract such\n+   differences from the parser's perspective.  */\n+\n+typedef struct _objc_runtime_hooks_r \n+{\n+  /* Initialize for this runtime.  */\n+  void (*initialize) (void);\n+  const char *default_constant_string_class_name;\n+  \n+  /* FIXME: Having to check this name should not be necessary.  */\n+  const char *tag_getclass; \n+  /* id for superclass class field - named differently in the existing\n+     runtimes.  */\n+  tree (*super_superclassfield_ident) (void);\n+\n+  /* Obtain a class decl for the identifier.  */\n+  tree (*class_decl) (tree);\n+  /* Obtain a metaclass decl for the identifier.  */\n+  tree (*metaclass_decl) (tree);\n+  /* Obtain a category decl for the identifier.  */\n+  tree (*category_decl) (tree);\n+  /* Obtain a protocol decl for the identifier.  */\n+  tree (*protocol_decl) (tree);\n+  /* Obtain a string decl, to be placed in the nominated string-section.  */\n+  tree (*string_decl) (tree, const char *, string_section);\n+\n+  /* Obtain a class reference, generating the fwd def. if necessary.  */\n+  tree (*get_class_reference) (tree);\n+  /* build/get selector reference.  */\n+  tree (*build_selector_reference) (location_t, tree, tree);\n+  /* Get a protocol reference, generating the forward def. if necessary.  */\n+  tree (*get_protocol_reference) (location_t, tree);\n+  /* Get an ivar ref. re the base.  */\n+  tree (*build_ivar_reference) (location_t, tree, tree);\n+  /* Get a reference to {meta}class' super.  */\n+  tree (*get_class_super_ref) (location_t, struct imp_entry *, bool);\n+  /* Get a reference to Category {meta}class' super.  */\n+  tree (*get_category_super_ref) (location_t, struct imp_entry *, bool);\n+\n+  /* Receiver is class Object, check runtime-specific.  */\n+  tree (*receiver_is_class_object) (tree);\n+  /* Get the start of a method argument type list (receiver, _cmd).  */\n+  tree (*get_arg_type_list_base) (tree, int, int);\n+  /* Build method call.  */\n+  tree (*build_objc_method_call) (location_t, tree, tree, tree, tree, tree, int);\n+  \n+  /* Check for or otherwise handle a request to check that the constant\n+     string class reference is set-up & OK.  */\n+  bool (*setup_const_string_class_decl) (void);\n+  /* Return the tree reprenting a const string constructor for the arg.\n+     Most of the data are in global trees.  */\n+  tree (*build_const_string_constructor) (location_t, tree, int);\n+  \n+  /* Exceptions.  */\n+  tree (*build_throw_stmt) (location_t, tree, bool);\n+  tree (*build_exc_ptr) (struct objc_try_context **);\n+  tree (*begin_catch) (struct objc_try_context **, tree, tree, tree, bool);\n+  void (*finish_catch) (struct objc_try_context **, tree);\n+  tree (*finish_try_stmt) (struct objc_try_context **);\n+  \n+  /* Emit all the metadata required by the runtime - based on the tables built\n+     during parsing.  */\n+  void (*generate_metadata) (void);\n+\n+} objc_runtime_hooks;\n+\n+/* For shared support that needs to access these.  */\n+extern objc_runtime_hooks runtime;\n+\n+/* One per runtime at present.\n+   TODO: Make into some kind of configury-generated table.  */\n+extern bool objc_gnu_runtime_abi_01_init (objc_runtime_hooks *);\n+extern bool objc_next_runtime_abi_01_init (objc_runtime_hooks *);\n+extern bool objc_next_runtime_abi_02_init (objc_runtime_hooks *);\n+\n+#endif /* _OBJC_RUNTIME_HOOKS_H_ */"}, {"sha": "dff1d467391d2b1473e6b8c8135b9bca2092749b", "filename": "gcc/objc/objc-runtime-shared-support.c", "status": "added", "additions": 733, "deletions": 0, "changes": 733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -0,0 +1,733 @@\n+/* Support routines shared by all runtimes.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Iain Sandoe (partially split from objc-act.c)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+\n+#ifdef OBJCPLUS\n+#include \"cp-tree.h\"\n+#else\n+#include \"c-tree.h\"\n+#include \"c-lang.h\"\n+#endif\n+#include \"langhooks.h\"\n+#include \"c-family/c-objc.h\"\n+#include \"objc-act.h\"\n+\n+/* When building Objective-C++, we are not linking against the C front-end\n+   and so need to replicate the C tree-construction functions in some way.  */\n+#ifdef OBJCPLUS\n+#define OBJCP_REMAP_FUNCTIONS\n+#include \"objcp-decl.h\"\n+#endif  /* OBJCPLUS */\n+\n+#include \"obstack.h\"\n+\n+/* These are only used for encoding ivars.  */\n+extern struct obstack util_obstack;\n+extern char *util_firstobj;\n+\n+/* Hooks for string decls etc.  */\n+#include \"objc-runtime-hooks.h\"\n+\n+#include \"objc-runtime-shared-support.h\"\n+\n+/* rt_trees identifiers - shared between NeXT implementations.  These allow\n+   the FE to tag meta-data in a manner that survives LTO and can be used when\n+   the  runtime requires that certain meta-data items appear in particular\n+   named sections.  */\n+#include \"objc-next-metadata-tags.h\"\n+extern GTY(()) tree objc_rt_trees[OCTI_RT_META_MAX];\n+\n+/* Rather than repeatedly looking up the identifiers, we save them here.  */\n+tree objc_rt_trees[OCTI_RT_META_MAX];\n+\n+/* For building an objc struct.  These might not be used when this file\n+   is compiled as part of obj-c++.  */\n+\n+static bool objc_building_struct;\n+static struct c_struct_parse_info *objc_struct_info ATTRIBUTE_UNUSED;\n+\n+/* Start building a struct for objc.  */\n+\n+tree\n+objc_start_struct (tree name)\n+{\n+  gcc_assert (!objc_building_struct);\n+  objc_building_struct = true;\n+  return start_struct (input_location, RECORD_TYPE, name, &objc_struct_info);\n+}\n+\n+/* Finish building a struct for objc.  */\n+\n+tree\n+objc_finish_struct (tree type, tree fieldlist)\n+{\n+  gcc_assert (objc_building_struct);\n+  objc_building_struct = false;\n+  return finish_struct (input_location, type, fieldlist, NULL_TREE,\n+\t\t\tobjc_struct_info);\n+}\n+\n+tree\n+build_sized_array_type (tree base_type, int size)\n+{\n+  tree index_type = build_index_type (build_int_cst (NULL_TREE, size - 1));\n+  return build_array_type (base_type, index_type);\n+}\n+\n+/* Create a declaration for field NAME of a given TYPE.  */\n+\n+static tree\n+create_field_decl (tree type, const char *name)\n+{\n+  return build_decl (input_location,\n+\t\t     FIELD_DECL, get_identifier (name), type);\n+}\n+\n+tree\n+add_field_decl (tree type, const char *name, tree **chain)\n+{\n+  tree field = create_field_decl (type, name);\n+\n+  if (*chain != NULL)\n+    **chain = field;\n+  *chain = &DECL_CHAIN (field);\n+\n+  return field;\n+}\n+\n+/* Create a global, static declaration for variable NAME of a given TYPE.  The\n+   finish_var_decl() routine will need to be called on it afterwards.  */\n+\n+tree\n+start_var_decl (tree type, const char *name)\n+{\n+  tree var = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (name), type);\n+  TREE_STATIC (var) = 1;\n+  DECL_INITIAL (var) = error_mark_node;  /* A real initializer is coming... */\n+  DECL_IGNORED_P (var) = 1;\n+  DECL_ARTIFICIAL (var) = 1;\n+  DECL_CONTEXT (var) = NULL_TREE;\n+#ifdef OBJCPLUS\n+  DECL_THIS_STATIC (var) = 1; /* squash redeclaration errors */\n+#endif\n+  return var;\n+}\n+\n+/* Finish off the variable declaration created by start_var_decl().  */\n+\n+void\n+finish_var_decl (tree var, tree initializer)\n+{\n+  finish_decl (var, input_location, initializer, NULL_TREE, NULL_TREE);\n+}\n+\n+/* Just a handy wrapper for add_objc_string.  */\n+\n+tree\n+build_selector (tree ident)\n+{\n+  return convert (objc_selector_type, add_objc_string (ident, meth_var_names));\n+}\n+\n+/* --- templates --- */\n+\n+/* Set 'objc_super_template' to the data type node for 'struct _objc_super'.\n+   This needs to be done just once per compilation.  */\n+\n+/* struct _objc_super {\n+     struct _objc_object *self;\n+     struct _objc_class *super_class; \n+     \t\t[or Class cls; for the abi v2]\n+   };  */\n+\n+void\n+build_super_template (void)\n+{\n+  tree decls, *chain = NULL;\n+\n+  objc_super_template = objc_start_struct (get_identifier (UTAG_SUPER));\n+\n+  /* struct _objc_object *self; */\n+  decls = add_field_decl (objc_object_type, \"self\", &chain);\n+\n+  /* struct _objc_class *super_class; */\n+  add_field_decl (build_pointer_type (objc_class_template),\n+\t\t  \"super_class\", &chain);\n+\n+  objc_finish_struct (objc_super_template, decls);\n+}\n+\n+/* To accomplish method prototyping without generating all kinds of\n+   inane warnings, the definition of the dispatch table entries were\n+   changed from:\n+\n+\tstruct objc_method { SEL _cmd; ...; id (*_imp)(); };\n+   to:\n+\tstruct objc_method { SEL _cmd; ...; void *_imp; };  */\n+\n+tree\n+build_method_template (void)\n+{\n+  tree _SLT_record;\n+  tree decls, *chain = NULL;\n+\n+  _SLT_record = objc_start_struct (get_identifier (UTAG_METHOD));\n+\n+  /* SEL _cmd; */\n+  decls = add_field_decl (objc_selector_type, \"_cmd\", &chain);\n+\n+  /* char *method_types; */\n+  add_field_decl (string_type_node, \"method_types\", &chain);\n+\n+  /* void *_imp; */\n+  add_field_decl (build_pointer_type (void_type_node), \"_imp\", &chain);\n+\n+  objc_finish_struct (_SLT_record, decls);\n+\n+  return _SLT_record;\n+}\n+\n+tree\n+build_method_prototype_template (void)\n+{\n+  tree proto_record;\n+  tree decls, *chain = NULL;\n+\n+  proto_record = objc_start_struct (get_identifier (UTAG_METHOD_PROTOTYPE));\n+\n+  /* SEL _cmd; */\n+  decls = add_field_decl (objc_selector_type, \"_cmd\", &chain);\n+\n+  /* char *method_types; */\n+  add_field_decl (string_type_node, \"method_types\", &chain);\n+\n+  objc_finish_struct (proto_record, decls);\n+\n+  return proto_record;\n+}\n+\n+/* struct {\n+     struct _objc__method_prototype_list *method_next;\n+     int method_count;\n+     struct objc_method method_list[method_count];\n+   };  */\n+\n+tree\n+build_method_list_template (tree list_type, int size)\n+{\n+  tree objc_ivar_list_record;\n+  tree array_type, decls, *chain = NULL;\n+\n+  objc_ivar_list_record = objc_start_struct (NULL_TREE);\n+\n+  /* struct _objc__method_prototype_list *method_next; */\n+  decls = add_field_decl (objc_method_proto_list_ptr, \"method_next\", &chain);\n+\n+  /* int method_count; */\n+  add_field_decl (integer_type_node, \"method_count\", &chain);\n+\n+  /* struct objc_method method_list[]; */\n+  array_type = build_sized_array_type (list_type, size);\n+  add_field_decl (array_type, \"method_list\", &chain);\n+\n+  objc_finish_struct (objc_ivar_list_record, decls);\n+\n+  return objc_ivar_list_record;\n+}\n+\n+/* struct objc_method_prototype_list {\n+     int count;\n+     struct objc_method_prototype {\n+\tSEL name;\n+\tchar *types;\n+     } list[1];\n+   };  */\n+\n+tree\n+build_method_prototype_list_template (tree list_type, int size)\n+{\n+  tree objc_ivar_list_record;\n+  tree array_type, decls, *chain = NULL;\n+\n+  /* Generate an unnamed struct definition.  */\n+\n+  objc_ivar_list_record = objc_start_struct (NULL_TREE);\n+\n+  /* int method_count; */\n+  decls = add_field_decl (integer_type_node, \"method_count\", &chain);\n+\n+  /* struct objc_method method_list[]; */\n+  array_type = build_sized_array_type (list_type, size);\n+  add_field_decl (array_type, \"method_list\", &chain);\n+\n+  objc_finish_struct (objc_ivar_list_record, decls);\n+\n+  return objc_ivar_list_record;\n+}\n+\n+/* --- names, decls entry --- */\n+\n+/* For each string section we have a chain which maps identifier nodes\n+   to decls for the strings.  */\n+\n+static GTY(()) int meth_var_names_idx;\n+static GTY(()) int meth_var_types_idx;\n+static GTY(()) int property_name_attr_idx;\n+\n+tree\n+add_objc_string (tree ident, string_section section)\n+{\n+  tree *chain, decl, type;\n+  char buf[BUFSIZE];\n+  \n+  switch (section)\n+    {\n+    case class_names:\n+      chain = &class_names_chain;\n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassName_%s\", IDENTIFIER_POINTER (ident));\n+      break;\n+    case meth_var_names:\n+      chain = &meth_var_names_chain;\n+      snprintf (buf, BUFSIZE, \"_OBJC_METH_VAR_NAME_%d\", meth_var_names_idx++);\n+      break;\n+    case meth_var_types:\n+      chain = &meth_var_types_chain;\n+      snprintf (buf, BUFSIZE, \"_OBJC_METH_VAR_TYPE_%d\", meth_var_types_idx++);\n+      break;\n+    case prop_names_attr:\n+      chain = &prop_names_attr_chain;\n+      snprintf (buf, BUFSIZE, \"_OBJC_PropertyAttributeOrName_%d\", property_name_attr_idx++);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  while (*chain)\n+    {\n+      if (TREE_VALUE (*chain) == ident)\n+\treturn convert (string_type_node,\n+\t\t\tbuild_unary_op (input_location,\n+\t\t\t\t\tADDR_EXPR, TREE_PURPOSE (*chain), 1));\n+\n+      chain = &TREE_CHAIN (*chain);\n+    }\n+\n+  type = build_sized_array_type (char_type_node, IDENTIFIER_LENGTH (ident) + 1);\n+  /* Get a runtime-specific string decl which will be finish_var()'ed in \n+     generate_strings ().  */\n+  decl = (*runtime.string_decl) (type, buf, section);\n+  TREE_CONSTANT (decl) = 1;\n+  *chain = tree_cons (decl, ident, NULL_TREE);\n+\n+  return convert (string_type_node, \n+\t\t  build_unary_op (input_location, ADDR_EXPR, decl, 1));\n+}\n+\n+/* --- shared metadata routines --- */\n+\n+tree\n+build_descriptor_table_initializer (tree type, tree entries)\n+{\n+  VEC(constructor_elt,gc) *inits = NULL;\n+\n+  do\n+    {\n+      VEC(constructor_elt,gc) *elts = NULL;\n+\n+      CONSTRUCTOR_APPEND_ELT (elts, NULL_TREE,\n+\t\t\t      build_selector (METHOD_SEL_NAME (entries)));\n+      CONSTRUCTOR_APPEND_ELT (elts, NULL_TREE,\n+\t\t\t      add_objc_string (METHOD_ENCODING (entries),\n+\t\t\t\t\t       meth_var_types));\n+\n+      CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n+\t\t\t      objc_build_constructor (type, elts));\n+\n+      entries = DECL_CHAIN (entries);\n+    }\n+  while (entries);\n+\n+  return objc_build_constructor (build_array_type (type, 0), inits);\n+}\n+\n+tree\n+build_dispatch_table_initializer (tree type, tree entries)\n+{\n+  VEC(constructor_elt,gc) *inits = NULL;\n+\n+  do\n+    {\n+      VEC(constructor_elt,gc) *elems = NULL;\n+      tree expr;\n+\n+      CONSTRUCTOR_APPEND_ELT (elems, NULL_TREE,\n+\t\t\t      build_selector (METHOD_SEL_NAME (entries)));\n+\n+      /* Generate the method encoding if we don't have one already.  */\n+      if (! METHOD_ENCODING (entries))\n+\tMETHOD_ENCODING (entries) =\n+\t  encode_method_prototype (entries);\n+\n+      CONSTRUCTOR_APPEND_ELT (elems, NULL_TREE,\n+\t\t\t      add_objc_string (METHOD_ENCODING (entries),\n+\t\t\t\t\t       meth_var_types));\n+\n+      expr = convert (ptr_type_node,\n+\t\t      build_unary_op (input_location, ADDR_EXPR,\n+\t\t\t\t      METHOD_DEFINITION (entries), 1));\n+      CONSTRUCTOR_APPEND_ELT (elems, NULL_TREE, expr);\n+\n+      CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n+\t\t\t      objc_build_constructor (type, elems));\n+\n+      entries = DECL_CHAIN (entries);\n+    }\n+  while (entries);\n+\n+  return objc_build_constructor (build_array_type (type, 0), inits);\n+}\n+\n+/* Used only by build_*_selector_translation_table (). */\n+void\n+diagnose_missing_method (tree meth, location_t here)\n+{\n+  tree method_chain;\n+  bool found = false;\n+  for (method_chain = meth_var_names_chain;\n+       method_chain;\n+       method_chain = TREE_CHAIN (method_chain))\n+    {\n+      if (TREE_VALUE (method_chain) == meth)\n+\t{\n+\t  found = true;\n+\t  break;\n+\t}\n+     }\n+\n+  if (!found)\n+    warning_at (here, 0, \"creating selector for nonexistent method %qE\",\n+\t\t\tmeth);\n+}\n+\n+\n+static tree\n+init_module_descriptor (tree type, long vers)\n+{\n+  tree expr, ltyp;\n+  location_t loc;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  /* No really useful place to point to.  */\n+  loc = UNKNOWN_LOCATION;\n+  \n+  /* version = { 1, ... } */\n+\n+  expr = build_int_cst (long_integer_type_node, vers);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  /* size = { ..., sizeof (struct _objc_module), ... } */\n+\n+  expr = convert (long_integer_type_node,\n+\t\t  size_in_bytes (objc_module_template));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  /* Don't provide any file name for security reasons. */\n+  /* name = { ..., \"\", ... } */\n+\n+  expr = add_objc_string (get_identifier (\"\"), class_names);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  /* symtab = { ..., _OBJC_SYMBOLS, ... } */\n+\n+  ltyp = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t       get_identifier (UTAG_SYMTAB)));  \n+  if (UOBJC_SYMBOLS_decl)\n+    expr = convert (ltyp, build_unary_op (loc,\n+\t\t\t   ADDR_EXPR, UOBJC_SYMBOLS_decl, 0));\n+  else\n+    expr = convert (ltyp, null_pointer_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n+\n+  return objc_build_constructor (type, v);\n+}\n+\n+/* Write out the data structures to describe Objective C classes defined.\n+\n+   struct _objc_module { ... } _OBJC_MODULE = { ... };   */\n+\n+void\n+build_module_descriptor (long vers, tree attr)\n+{\n+  tree decls, *chain = NULL;\n+\n+#ifdef OBJCPLUS\n+  push_lang_context (lang_name_c); /* extern \"C\" */\n+#endif\n+\n+  objc_module_template = objc_start_struct (get_identifier (UTAG_MODULE));\n+\n+  /* long version; */\n+  decls = add_field_decl (long_integer_type_node, \"version\", &chain);\n+\n+  /* long size; */\n+  add_field_decl (long_integer_type_node, \"size\", &chain);\n+\n+  /* char *name; */\n+  add_field_decl (string_type_node, \"name\", &chain);\n+\n+  /* struct _objc_symtab *symtab; */\n+  add_field_decl (build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t\t\tget_identifier (UTAG_SYMTAB))),\n+\t\t  \"symtab\", &chain);\n+\n+  objc_finish_struct (objc_module_template, decls);\n+\n+  /* Create an instance of \"_objc_module\".  */\n+  UOBJC_MODULES_decl = start_var_decl (objc_module_template,\n+\t\t\tflag_next_runtime ? \"_OBJC_Module\" :  \"_OBJC_Module\");\n+\n+  /* This is the root of the metadata for defined classes and categories, it\n+     is referenced by the runtime and, therefore, needed.  */\n+  DECL_PRESERVE_P (UOBJC_MODULES_decl) = 1;\n+\n+  /* Allow the runtime to mark meta-data such that it can be assigned to target\n+     specific sections by the back-end.  */\n+  if (attr)\n+    DECL_ATTRIBUTES (UOBJC_MODULES_decl) = attr; \n+\n+  finish_var_decl (UOBJC_MODULES_decl,\n+\t\t   init_module_descriptor (TREE_TYPE (UOBJC_MODULES_decl),\n+\t\t\t\t\t   vers));\n+\n+#ifdef OBJCPLUS\n+  pop_lang_context ();\n+#endif\n+}\n+\n+tree\n+build_ivar_list_initializer (tree type, tree field_decl)\n+{\n+  VEC(constructor_elt,gc) *inits = NULL;\n+\n+  do\n+    {\n+      VEC(constructor_elt,gc) *ivar = NULL;\n+      tree id;\n+\n+      /* Set name.  */\n+      if (DECL_NAME (field_decl))\n+\tCONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n+\t\t\t\tadd_objc_string (DECL_NAME (field_decl),\n+\t\t\t\t\t\t meth_var_names));\n+      else\n+\t/* Unnamed bit-field ivar (yuck).  */\n+\tCONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+\n+      /* Set type.  */\n+      encode_field_decl (field_decl,\n+\t\t\t obstack_object_size (&util_obstack),\n+\t\t\t OBJC_ENCODE_DONT_INLINE_DEFS);\n+\n+      /* Null terminate string.  */\n+      obstack_1grow (&util_obstack, 0);\n+      id = add_objc_string (get_identifier (XOBFINISH (&util_obstack, char *)),\n+                            meth_var_types);\n+      CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, id);\n+      obstack_free (&util_obstack, util_firstobj);\n+\n+      /* Set offset.  */\n+      CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, byte_position (field_decl));\n+      CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n+\t\t\t      objc_build_constructor (type, ivar));\n+      do\n+\tfield_decl = DECL_CHAIN (field_decl);\n+      while (field_decl && TREE_CODE (field_decl) != FIELD_DECL);\n+    }\n+  while (field_decl);\n+\n+  return objc_build_constructor (build_array_type (type, 0), inits);\n+}\n+\n+/* struct {\n+     int ivar_count;\n+     struct objc_ivar ivar_list[ivar_count];\n+   };  */\n+\n+tree\n+build_ivar_list_template (tree list_type, int size)\n+{\n+  tree objc_ivar_list_record;\n+  tree array_type, decls, *chain = NULL;\n+\n+  objc_ivar_list_record = objc_start_struct (NULL_TREE);\n+\n+  /* int ivar_count; */\n+  decls = add_field_decl (integer_type_node, \"ivar_count\", &chain);\n+\n+  /* struct objc_ivar ivar_list[]; */\n+  array_type = build_sized_array_type (list_type, size);\n+  add_field_decl (array_type, \"ivar_list\", &chain);\n+\n+  objc_finish_struct (objc_ivar_list_record, decls);\n+\n+  return objc_ivar_list_record;\n+}\n+\n+/* struct _objc_ivar {\n+     char *ivar_name;\n+     char *ivar_type;\n+     int ivar_offset;\n+   };  */\n+\n+tree\n+build_ivar_template (void)\n+{\n+  tree objc_ivar_id, objc_ivar_record;\n+  tree decls, *chain = NULL;\n+\n+  objc_ivar_id = get_identifier (UTAG_IVAR);\n+  objc_ivar_record = objc_start_struct (objc_ivar_id);\n+\n+  /* char *ivar_name; */\n+  decls = add_field_decl (string_type_node, \"ivar_name\", &chain);\n+\n+  /* char *ivar_type; */\n+  add_field_decl (string_type_node, \"ivar_type\", &chain);\n+\n+  /* int ivar_offset; */\n+  add_field_decl (integer_type_node, \"ivar_offset\", &chain);\n+\n+  objc_finish_struct (objc_ivar_record, decls);\n+\n+  return objc_ivar_record;\n+}\n+\n+/* Used by NeXT ABI=0..2 */\n+void\n+build_next_selector_translation_table (void)\n+{\n+  tree chain;\n+  for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      tree expr;\n+      tree decl = TREE_PURPOSE (chain);\n+      if (warn_selector)\n+\t{\n+\t  location_t loc;\n+\t  if (decl) \n+\t    loc = DECL_SOURCE_LOCATION (decl);\n+\t  else\n+\t    loc = UNKNOWN_LOCATION;\n+\t  diagnose_missing_method (TREE_VALUE (chain), loc);\n+\t}\n+\n+      expr = build_selector (TREE_VALUE (chain));\n+\n+      if (decl)\n+\t{\n+\t  /* Entries of this form are used for references to methods.\n+\t  The runtime re-writes these on start-up, but the compiler can't see \n+\t  that and optimizes it away unless we force it.  */\n+\t  DECL_PRESERVE_P (decl) = 1;\n+\t  finish_var_decl (decl, expr);\n+\t}\n+    }\n+}\n+\n+void\n+generate_protocol_references (tree plist)\n+{\n+  tree lproto;\n+\n+  /* Forward declare protocols referenced.  */\n+  for (lproto = plist; lproto; lproto = TREE_CHAIN (lproto))\n+    {\n+      tree proto = TREE_VALUE (lproto);\n+\n+      if (TREE_CODE (proto) == PROTOCOL_INTERFACE_TYPE\n+\t  && PROTOCOL_NAME (proto))\n+\t{\n+          if (! PROTOCOL_FORWARD_DECL (proto))\n+            PROTOCOL_FORWARD_DECL (proto) = (*runtime.protocol_decl) (proto);\n+\n+          if (PROTOCOL_LIST (proto))\n+            generate_protocol_references (PROTOCOL_LIST (proto));\n+        }\n+    }\n+}\n+\n+/* --- new routines --- */\n+\n+/* Output all strings.  */\n+\n+/* FIXME: don't use global vars for all this... */\n+\n+/* This emits all the meta-data string tables (and finalizes each var\n+   as it goes).  */\n+void\n+generate_strings (void)\n+{\n+  tree chain, string_expr;\n+  tree string, decl; /* , type;*/\n+\n+  for (chain = class_names_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      string = TREE_VALUE (chain);\n+      decl = TREE_PURPOSE (chain);\n+      string_expr = my_build_string (IDENTIFIER_LENGTH (string) + 1,\n+\t\t\t\t     IDENTIFIER_POINTER (string));\n+      finish_var_decl (decl, string_expr);\n+    }\n+\n+  for (chain = meth_var_names_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      string = TREE_VALUE (chain);\n+      decl = TREE_PURPOSE (chain);\n+      string_expr = my_build_string (IDENTIFIER_LENGTH (string) + 1,\n+\t\t\t\t     IDENTIFIER_POINTER (string));\n+      finish_var_decl (decl, string_expr);\n+    }\n+\n+  for (chain = meth_var_types_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      string = TREE_VALUE (chain);\n+      decl = TREE_PURPOSE (chain);\n+      string_expr = my_build_string (IDENTIFIER_LENGTH (string) + 1,\n+\t\t\t\t     IDENTIFIER_POINTER (string));\n+      finish_var_decl (decl, string_expr);\n+    }\n+\n+  for (chain = prop_names_attr_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      string = TREE_VALUE (chain);\n+      decl = TREE_PURPOSE (chain);\n+      string_expr = my_build_string (IDENTIFIER_LENGTH (string) + 1,\n+\t\t\t\t     IDENTIFIER_POINTER (string));\n+      finish_var_decl (decl, string_expr);\n+    }\n+}\n+\n+#include \"gt-objc-objc-runtime-shared-support.h\""}, {"sha": "8e4693d6f09f2a33378c22cff3bbc30612974fef", "filename": "gcc/objc/objc-runtime-shared-support.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-runtime-shared-support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjc%2Fobjc-runtime-shared-support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -0,0 +1,90 @@\n+/* Support routines shared by all runtimes.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Iain Sandoe \n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _OBJC_RUNTIME_SHARED_SUPPORT_H_\n+#define _OBJC_RUNTIME_SHARED_SUPPORT_H_\n+\n+/* Left in obj-act.c for now... */\n+\n+extern tree objc_start_struct (tree);\n+extern tree objc_finish_struct (tree, tree);\n+extern tree add_field_decl (tree, const char *, tree **);\n+extern tree build_sized_array_type (tree, int);\n+\n+extern tree lookup_interface (tree);\n+extern tree objc_build_constructor (tree, VEC(constructor_elt,gc) *);\n+\n+extern tree start_var_decl (tree, const char *);\n+extern void finish_var_decl (tree, tree);\n+\n+extern tree my_build_string (int, const char *);\n+extern tree my_build_string_pointer (int, const char *);\n+extern tree add_objc_string (tree ident, string_section);\n+extern tree get_objc_string_decl (tree, string_section);\n+\n+extern void add_class_reference (tree);\n+\n+#ifdef OBJCPLUS\n+extern void objc_start_function (tree, tree, tree, tree);\n+extern tree objc_get_parm_info (int);\n+#else\n+extern void objc_start_function (tree, tree, tree, struct c_arg_info *);\n+extern struct c_arg_info *objc_get_parm_info (int);\n+#endif\n+extern void objc_push_parm (tree);\n+extern tree get_arg_type_list (tree, int, int);\n+\n+/* Stuff that should be migrated to shared support (or some v1-only file).  */\n+extern void build_super_template (void);\n+\n+extern tree objc_build_component_ref (tree, tree);\n+\n+extern tree objc_v2_encode_prop_attr (tree);\n+extern tree build_descriptor_table_initializer (tree, tree);\n+extern tree build_method_prototype_list_template (tree, int);\n+extern tree build_protocol_initializer (tree, tree, tree, tree, tree);\n+\n+/* Stuff that should be migrated to shared encode.  */\n+extern tree encode_method_prototype (tree);\n+extern void encode_field_decl (tree, int, int);\n+\n+/* Moved or new routines in objc-runtime-shared-support.c  */\n+\n+extern tree build_selector (tree);\n+extern tree build_method_template (void);\n+extern tree build_method_prototype_template (void);\n+extern tree build_method_list_template (tree, int);\n+\n+extern tree build_dispatch_table_initializer (tree, tree);\n+extern void diagnose_missing_method (tree, location_t);\n+extern void build_next_selector_translation_table (void);\n+extern void generate_protocol_references (tree);\n+extern void build_module_descriptor (long, tree);\n+extern tree build_ivar_list_initializer (tree, tree);\n+extern tree build_ivar_list_template (tree, int);\n+extern tree build_ivar_template (void);\n+\n+extern void generate_strings (void);\n+\n+extern void dump_interface (FILE *, tree);\n+extern int generating_instance_variables;\n+extern FILE *gen_declaration_file;\n+\n+#endif /* _OBJC_RUNTIME_SHARED_SUPPORT_H_ */"}, {"sha": "a327707573a2e2dbdf2ab17e0eba30b63bdca78b", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,3 +1,19 @@\n+2011-02-17  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* Make-lang.in (START_HDRS): New.\n+\t(OBJCXX_OBJS): Added new object files from objc/.\n+\t(objcp/objcp-act.o): Updated prerequisites.\n+\t(objcp/objcp-lang.o): Updated prerequisites.\n+\t(objcp/objc-runtime-shared-support.o): New.\n+\t(objcp/objc-gnu-runtime-abi-01.o): New.\n+\t(objcp/objc-next-runtime-abi-01.o): New.\n+\t(objcp/objc-next-runtime-abi-02.o): New.\n+\t* config-lang.in (gtfiles): Updated.\n+\t* objcp-lang.c (objcxx_eh_personality): Removed.\n+\t(LANG_HOOKS_EH_PERSONALITY): Removed.\n+\t(LANG_HOOKS_EH_RUNTIME_TYPE): Removed.\n+\t(objcp_eh_personality_decl): Removed.\n+\t\n 2011-02-07  Mike Stump  <mikestump@comcast.net>\n \n \t* Make-lang.in (obj-c++.tags): Don't include *.y."}, {"sha": "5bbd27eec35bc680f57e69e978d3c5a428b95bcd", "filename": "gcc/objcp/Make-lang.in", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FMake-lang.in?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,5 +1,5 @@\n # Top level -*- makefile -*- fragment for GNU Objective-C++\n-#   Copyright (C) 2005, 2007, 2008, 2009, 2010\n+#   Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011\n #   Free Software Foundation, Inc.\n #   Contributed by Ziemowit Laski  <zlaski@apple.com>\n \n@@ -44,12 +44,19 @@ obj-c++: cc1objplus$(exeext)\n # Tell GNU make to ignore these if they exist.\n .PHONY: obj-c++\n \n+START_HDRS = $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) \\\n+  langhooks.h c-family/c-objc.h objc/objc-act.h\n+\n # Use maximal warnings for this front end.  Also, make ObjC and C++\n # headers accessible.\n objcp-warn = $(STRICT_WARN) -DOBJCPLUS -I$(srcdir)/objc -I$(srcdir)/cp\n \n # Language-specific object files for Objective C++.\n OBJCXX_OBJS = objcp/objcp-act.o objcp/objcp-lang.o objcp/objcp-decl.o \\\n+   objcp/objc-runtime-shared-support.o \\\n+   objcp/objc-gnu-runtime-abi-01.o \\\n+   objcp/objc-next-runtime-abi-01.o \\\n+   objcp/objc-next-runtime-abi-02.o \\\n    $(CXX_AND_OBJCXX_OBJS)\n \n obj-c++_OBJS = $(OBJCXX_OBJS) cc1objplus-checksum.o\n@@ -69,23 +76,48 @@ cc1objplus$(exeext): $(OBJCXX_OBJS) cc1objplus-checksum.o $(BACKEND) $(LIBDEPS)\n \n # Objective C++ language specific files.\n \n-objcp/objcp-lang.o : objcp/objcp-lang.c \\\n-  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) \\\n-  $(C_COMMON_H) $(LANGHOOKS_DEF_H) objc/objc-act.h cp/cp-objcp-common.h \\\n-  $(TARGET_H) gtype-objcp.h c-family/c-objc.h\n+objcp/objcp-lang.o : objcp/objcp-lang.c $(START_HDRS) \\\n+  $(C_COMMON_H) $(LANGHOOKS_DEF_H) cp/cp-objcp-common.h \\\n+  $(TARGET_H) gtype-objcp.h \n \n objcp/objcp-decl.o : objcp/objcp-decl.c \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) \\\n    objc/objc-act.h objcp/objcp-decl.h c-family/c-objc.h\n \n+objcp/objc-runtime-shared-support.o : objc/objc-runtime-shared-support.c \\\n+   $(START_HDRS) objc/objc-runtime-shared-support.h $(OBSTACK_H) \\\n+   objc/objc-next-metadata-tags.h gt-objc-objc-runtime-shared-support.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n+\t\t$(OUTPUT_OPTION)\n+\n+objcp/objc-gnu-runtime-abi-01.o: objc/objc-gnu-runtime-abi-01.c $(START_HDRS) \\\n+   objc/objc-runtime-hooks.h $(GGC_H) \\\n+   gt-objc-objc-gnu-runtime-abi-01.h toplev.h \n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n+\t\t$(OUTPUT_OPTION)\n+\n+objcp/objc-next-runtime-abi-01.o: objc/objc-next-runtime-abi-01.c $(START_HDRS) \\\n+   $(GGC_H) objc/objc-runtime-hooks.h \\\n+   objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-01.h output.h \\\n+   objc/objc-runtime-shared-support.h $(TARGET_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n+\t\t$(OUTPUT_OPTION)\n+\n+objcp/objc-next-runtime-abi-02.o: objc/objc-next-runtime-abi-02.c $(START_HDRS) \\\n+   $(GGC_H) objc/objc-runtime-hooks.h \\\n+   objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-02.h $(TARGET_H) \\\n+   objc/objc-runtime-shared-support.h $(OBSTACK_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n+\t\t$(OUTPUT_OPTION)\n+\n+\n # The following must be an explicit rule; please keep in sync with the implicit\n # one in Makefile.in.\n-objcp/objcp-act.o : objc/objc-act.c \\\n-   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) $(TM_P_H) \\\n-   $(EXPR_H) $(TARGET_H) $(CXX_TREE_H) $(DIAGNOSTIC_H) toplev.h $(FLAGS_H) \\\n-   objc/objc-act.h input.h $(FUNCTION_H) output.h debug.h langhooks.h \\\n+objcp/objcp-act.o : objc/objc-act.c $(START_HDRS) $(GGC_H) \\\n+   $(RTL_H) $(EXPR_H) $(TARGET_H) $(DIAGNOSTIC_H) toplev.h $(FLAGS_H) \\\n+   input.h $(FUNCTION_H) output.h debug.h $(OBSTACK_H) \\\n    objcp/objcp-decl.h $(LANGHOOKS_DEF_H) $(HASHTAB_H) gt-objc-objc-act.h \\\n-   $(GIMPLE_H) c-family/c-objc.h\n+   $(GIMPLE_H) objc/objc-runtime-hooks.h objc/objc-runtime-shared-support.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n \t\t$(OUTPUT_OPTION)\n "}, {"sha": "b8565d83c5927c85aadf74080dc5ef3da696ae29", "filename": "gcc/objcp/config-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fconfig-lang.in?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,5 +1,5 @@\n # Top level configure fragment for GNU Objective-C++.\n-#   Copyright (C) 2005, 2007, 2010 Free Software Foundation, Inc.\n+#   Copyright (C) 2005, 2007, 2010, 2011 Free Software Foundation, Inc.\n #   Contributed by Ziemowit Laski <zlaski@apple.com>\n \n #This file is part of GCC.\n@@ -37,4 +37,4 @@ build_by_default=\"no\"\n lang_requires=\"objc c++\"\n subdir_requires=\"objc cp\"\n \n-gtfiles=\"\\$(srcdir)/objcp/objcp-decl.c \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-act.h \\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/cp-objcp-common.c\"\n+gtfiles=\"\\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/cp/call.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \""}, {"sha": "fe2be66fff689f2e044956a4d9d9dd990b7db505", "filename": "gcc/objcp/objcp-lang.c", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjcp%2Fobjcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Fobjcp%2Fobjcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-lang.c?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,5 +1,5 @@\n /* Language-dependent hooks for Objective-C++.\n-   Copyright 2005, 2007, 2008, 2010 Free Software Foundation, Inc.\n+   Copyright 2005, 2007, 2008, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Ziemowit Laski  <zlaski@apple.com>\n \n This file is part of GCC.\n@@ -18,7 +18,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -35,7 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n \n enum c_language_kind c_language = clk_objcxx;\n static void objcxx_init_ts (void);\n-static tree objcxx_eh_personality (void);\n \n /* Lang hooks common to C++ and ObjC++ are declared in cp/cp-objcp-common.h;\n    consequently, there should be very few hooks below.  */\n@@ -48,10 +46,6 @@ static tree objcxx_eh_personality (void);\n #define LANG_HOOKS_GIMPLIFY_EXPR objc_gimplify_expr\n #undef LANG_HOOKS_INIT_TS\n #define LANG_HOOKS_INIT_TS objcxx_init_ts\n-#undef LANG_HOOKS_EH_PERSONALITY\n-#define LANG_HOOKS_EH_PERSONALITY objcxx_eh_personality\n-#undef LANG_HOOKS_EH_RUNTIME_TYPE\n-#define LANG_HOOKS_EH_RUNTIME_TYPE build_eh_type_type\n \n /* Each front end provides its own lang hook initializer.  */\n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n@@ -145,14 +139,4 @@ objcxx_init_ts (void)\n   init_shadowed_var_for_decl ();\n }\n \n-static GTY(()) tree objcp_eh_personality_decl;\n-\n-static tree\n-objcxx_eh_personality (void)\n-{\n-  if (!objcp_eh_personality_decl)\n-    objcp_eh_personality_decl = build_personality_function (\"gxx\");\n-  return objcp_eh_personality_decl;\n-}\n-\n #include \"gtype-objcp.h\""}, {"sha": "274da7ebbc1b05a44e00a555c13cfb2bf6727d29", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,3 +1,55 @@\n+2011-02-17  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* objc.dg/special/unclaimed-category-1.h: Updated for\n+\tnew ABI support.\n+\t* objc.dg/special/unclaimed-category-1.m: Same.\n+\t* objc.dg/zero-link-1.m: Same.\n+\t* objc.dg/lookup-1.m: Same.\n+\t* objc.dg/torture/strings/const-str-9.m\n+\t* objc.dg/torture/strings/const-str-10.m: Same.\n+\t* objc.dg/torture/strings/const-str-11.m: Same. \n+\t* objc.dg/torture/forward-1.m: Same.\n+\t* objc.dg/zero-link-2.m: Same.  \n+\t* objc.dg/encode-7-next-64bit.m: Same. \n+\t* objc.dg/method-4.m: Same.\n+\t* objc.dg/next-runtime-1.m: Same.\n+\t* objc.dg/image-info.m: Same. \n+\t* objc.dg/pr23214.m: Same.\n+\t* objc.dg/symtab-1.m: Same.\n+\t* obj-c++.dg/basic.m: Same.m\n+\t* obj-c++.dg/proto-lossage-3.m: Same.m\n+\t* obj-c++.dg/torture/strings/const-str-10.m: Same.m\n+\t* obj-c++.dg/torture/strings/const-str-11.m: Same.m \n+\t* obj-c++.dg/torture/strings/const-str-9.m: Same.m\n+\t* obj-c++.dg/method-11.m: Same.m\n+\t* objc/execute/enumeration-1.m: Same.\n+\t* objc/execute/object_is_class.m: Same. \n+\t* objc/execute/formal_protocol-2.m: Same.\n+\t* objc/execute/formal_protocol-4.m: Same. \n+\t* objc/execute/formal_protocol-6.m: Same. \n+\t* objc/execute/bycopy-3.m: Same.\n+\t* objc/execute/exceptions/catchall-1.m: Same.\n+\t* objc/execute/exceptions/finally-1.m: Same.\n+\t* objc/execute/exceptions/local-variables-1.m: Same.\n+\t* objc/execute/exceptions/foward-1.m: Same.\n+\t* objc/execute/bf-common.h\n+\t* objc/execute/enumeration-2.m: Same.\n+\t* objc/execute/formal_protocol-1.m: Same.\n+\t* objc/execute/formal_protocol-3.m: Same. \n+\t* objc/execute/formal_protocol-5.m: Same.\n+\t* objc/execute/accessing_ivars.m: Same.\n+\t* objc/execute/bycopy-2.m: Same.\n+\t* objc/execute/formal_protocol-7.m: Same.\n+\t* objc/execute/compatibility_alias.m: Same.\n+\t* objc/execute/no_clash.m: Same.\n+\t* objc/execute/object_is_meta_class.m: Same.\n+\t* objc/execute/exceptions/exceptions.exp: Load target-supports.exp\n+\t* objc/execute/class-tests-1.h: Include stdio.h.\n+\t* objc/execute/class-tests-2.h: Same.\n+\t* obj-c++.dg/try-catch-9.mm: xfail-run the test with both\n+\truntimes.\n+\t* obj-c++.dg/try-catch-2.mm: Same.\n+\t\n 2011-02-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/47783"}, {"sha": "bd593c13b5ed4aff7c6b7b768e69af3c8e804c4a", "filename": "gcc/testsuite/obj-c++.dg/basic.mm", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fbasic.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fbasic.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fbasic.mm?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,22 +1,41 @@\n // A basic sanity check for Objective-C++.\n // { dg-do run }\n /* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n-#include \"../objc-obj-c++-shared/Object1.h\"\n+\n+//#include \"../objc-obj-c++-shared/Object1.h\"\n #include <iostream>\n \n+#include <objc/Object.h>\n+\n+#ifdef __OBJC2__\n+@interface Object (ADDITIONS)\n++ initialize;\n+- init;\n++ alloc;\n++ new;\n+@end\n+@implementation Object (ADDITIONS)\n++ initialize  { return self; }\n+- init  { return self; }\n++ alloc { return class_createInstance (self, 0); }\n++ new  { return [[self alloc] init]; }\n+@end\n+#endif\n+\n @interface Greeter : Object\n - (void) greet: (const char *)msg;\n @end\n \n @implementation Greeter\n-- (void) greet: (const char *)msg { std::cout << msg; }\n+- (void) greet: (const char *)msg \n+{ std::cout << msg << __VERSION__ << std::endl;}\n @end\n \n int\n main ()\n {\n-  std::cout << \"Hello from C++\\n\";\n+  std::cout << \"Hello from C++\" << __VERSION__ << std::endl;\n   Greeter *obj = [Greeter new];\n-  [obj greet: \"Hello from Objective-C\\n\"];\n+  [obj greet: \"Hello from Objective-C++\"];\n }\n-#include \"../objc-obj-c++-shared/Object1-implementation.h\"\n+//#include \"../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "74192e80f792341bc3ff75c876f9bc0e22307816", "filename": "gcc/testsuite/obj-c++.dg/method-11.mm", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-11.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-11.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-11.mm?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -22,5 +22,8 @@ void foo(void) {\n   obj = [ObjectAlias2 new];\n }\n \n-/* { dg-final { scan-assembler \"_OBJC_CLASS_REFERENCES_0\" } } */\n-/* { dg-final { scan-assembler-not \"_OBJC_CLASS_REFERENCES_1\" } } */\n+/* { dg-final { scan-assembler \"_OBJC_ClassRefs_0\"  { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \"_OBJC_ClassRef_Object\"  { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler-not \"_OBJC_ClassRefs_1\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler-not \"_OBJC_ClassRef_ObjectTypedef\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler-not \"_OBJC_ClassRef_ObjectAlias\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "ac66ace579659296e5288dd9da0118c53b05d316", "filename": "gcc/testsuite/obj-c++.dg/proto-lossage-3.mm", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproto-lossage-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproto-lossage-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproto-lossage-3.mm?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -19,9 +19,16 @@ @protocol NoClassMethods\n int\n main()\n {\n+#ifdef __OBJC2__\n+protocol_getMethodDescription(@protocol(NoInstanceMethods), @selector(name), NO, YES);\n+protocol_getMethodDescription(@protocol(NoInstanceMethods), @selector(name), NO, NO);\n+protocol_getMethodDescription(@protocol(NoClassMethods), @selector(name), NO, YES);\n+protocol_getMethodDescription(@protocol(NoClassMethods), @selector(name), NO, NO);\n+#else\n [@protocol(NoInstanceMethods) descriptionForInstanceMethod: @selector(name)];\n [@protocol(NoInstanceMethods) descriptionForClassMethod: @selector(name)];\n [@protocol(NoClassMethods) descriptionForInstanceMethod: @selector(name)];\n [@protocol(NoClassMethods) descriptionForClassMethod: @selector(name)];\n+#endif\n return 0;\n }"}, {"sha": "3cb3acfae3b73d7b1e3a86b469e83676430adec9", "filename": "gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-10.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-10.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-10.mm?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -29,6 +29,7 @@ @interface NSConstantString : NSSimpleCString\n \n const NSConstantString *appKey = @\"MyApp\";\n \n-/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" } } */\n+/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \".section __DATA, __objc_stringobj\" { target { *-*-darwin* && { lp64 } } } } } */\n /* { dg-final { scan-assembler \".long\\t__NSConstantStringClassReference\\n\\t.long\\t.*\\n\\t.long\\t5\\n\\t.data\" { target { *-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \".quad\\t__NSConstantStringClassReference\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space 4\\n\\t.data\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \".quad\\t_OBJC_CLASS_._NSConstantString\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "8674646d880a23f600af3cbdd09b211e8027a9a8", "filename": "gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-11.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-11.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-11.mm?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -29,6 +29,7 @@ @interface XStr : XString {\n \n const XStr *appKey = @\"MyApp\";\n \n-/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" } } */\n-/* { dg-final { scan-assembler \".long\\t__XStrClassReference\\n\\t.long\\t.*\\n\\t.long\\t5\\n\\t.data\" { target { *-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \".quad\\t__XStrClassReference\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space 4\\n\\t.data\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \".section __DATA, __objc_stringobj\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \".long\\t__XStrClassReference\\n\\t.long\\t.*\\n\\t.long\\t5\\n\\t.data\"  { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \".quad\\t_OBJC_CLASS_._XStr\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "e05c62b88a8815bf338704a663ccf90d2548aac1", "filename": "gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-9.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-9.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-str-9.mm?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -21,6 +21,7 @@ @interface NSConstantString: Object {\n \n const NSConstantString *appKey = @\"MyApp\";\n \n-/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" } } */\n-/* { dg-final { scan-assembler \".long\\t__NSConstantStringClassReference\\n\\t.long\\t.*\\n\\t.long\\t5\\n\\t.data\"  { target { *-*-darwin* && { ! lp64 } } }} } */\n-/* { dg-final { scan-assembler \".quad\\t__NSConstantStringClassReference\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space 4\\n\\t.data\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \".section __DATA, __objc_stringobj\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \".long\\t__NSConstantStringClassReference\\n\\t.long\\t.*\\n\\t.long\\t5\\n\\t.data\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \".quad\\t_OBJC_CLASS_._NSConstantString\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "05aba36a46f87b0a83f12c9e0b5d853fa1389526", "filename": "gcc/testsuite/obj-c++.dg/try-catch-2.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftry-catch-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftry-catch-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftry-catch-2.mm?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -3,7 +3,7 @@\n /* Developed by Ziemowit Laski <zlaski@apple.com>.  */\n \n /* { dg-do run } */\n-/* { dg-xfail-if \"PR23616\" { *-*-* } { \"-fgnu-runtime\" } { \"-fnext-runtime\" } } */\n+/* { dg-xfail-run-if \"PR23616\" { *-*-* } { \"-fgnu-runtime\" } { \"-fnext-runtime\" } } */\n /* { dg-xfail-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" \"-fgnu-runtime\" } { \"\" } } \n /* { dg-options \"-fobjc-exceptions\" } */\n "}, {"sha": "a4331fc35e254c4f30348f94a6dc46d19c1e44c2", "filename": "gcc/testsuite/obj-c++.dg/try-catch-9.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftry-catch-9.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftry-catch-9.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftry-catch-9.mm?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -3,7 +3,7 @@\n /* Developed by Ziemowit Laski <zlaski@apple.com>.  */\n \n /* { dg-do run } */\n-/* { dg-xfail-if \"PR23616\" { *-*-* } { \"-fgnu-runtime\" } { \"-fnext-runtime\" } } */\n+/* { dg-xfail-run-if \"PR23616\" { *-*-* } { \"-fgnu-runtime\" } { \"-fnext-runtime\" } } */\n /* { dg-xfail-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" \"-fgnu-runtime\" } { \"\" } } \n /* { dg-prune-output \".*internal compiler error.*\" } */\n /* { dg-options \"-fobjc-exceptions -O2\" } */"}, {"sha": "60129f9d2c740c7c733e53086d653de66561404f", "filename": "gcc/testsuite/objc.dg/encode-7-next-64bit.m", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next-64bit.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next-64bit.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next-64bit.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -2,16 +2,15 @@\n \n /* { dg-do run { target *-*-darwin* } } */\n /* { dg-require-effective-target lp64 } */\n-/* { dg-options \"-Wno-deprecated-declarations\" } */\n /* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n /* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n-/* { dg-additional-sources \"../objc-obj-c++-shared/Object1.m\" } */\n \n-#include \"../objc-obj-c++-shared/Object1.h\"\n-#include \"../objc-obj-c++-shared/next-mapping.h\"\n #include <stdbool.h>\n #include <string.h>\n #include <stdlib.h>\n+#include <objc/Object.h>\n+#include \"../objc-obj-c++-shared/next-mapping.h\"\n+\n #define CHECK_IF(E) if (!(E)) abort ()\n \n @class NSDictionary, NSFont, NSError, _NSATSTypesetterGuts, NSString, NSMenu, NSArray;\n@@ -195,69 +194,70 @@ + (BOOL)findVoiceByIdentifier:(NSString *)identifier returningCreator:(OSType *)\n int main(void) {\n   Class fooClass = objc_getClass (\"Foo\");\n   Method meth;\n-  struct objc_ivar_list *ivars;\n-  struct objc_ivar *ivar;\n+  Ivar *ivars;\n+  unsigned int ivar_count;\n+  Ivar ivar;\n \n   meth = class_getInstanceMethod (fooClass, @selector(_errorWithOSStatus:ref1:ref2:reading:));\n-  CHECK_IF (!strcmp (meth->method_types, \"@44@0:8q16r^{FSRef=[80C]}24r^{FSRef=[80C]}32c40\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding(meth), \"@44@0:8q16r^{FSRef=[80C]}24r^{FSRef=[80C]}32c40\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(_attributeRunForCharacterAtIndex:));\n-  CHECK_IF (!strcmp (meth->method_types, \"r^{?=@@QQ^Qffff{_NSRect={_NSPoint=ff}{_NSSize=ff}}q^qQ^Q@@@:::****{?=b1b1b1b1b1b27}}24@0:8Q16\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"r^{?=@@QQ^Qffff{_NSRect={_NSPoint=ff}{_NSSize=ff}}q^qQ^Q@@@:::****{?=b1b1b1b1b1b27}}24@0:8Q16\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(_getATSTypesetterGuts:));\n-  CHECK_IF (!strcmp (meth->method_types, \"r@24@0:8r:16\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"r@24@0:8r:16\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(resumeWithSuspensionID:and:));\n-  CHECK_IF (!strcmp (meth->method_types, \"v32@0:8^{__NSAppleEventManagerSuspension=}16r^Q24\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"v32@0:8^{__NSAppleEventManagerSuspension=}16r^Q24\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(anotherMeth:and:and:));\n-  CHECK_IF (!strcmp (meth->method_types, \"r@40@0:8r:16r@24r@32\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"r@40@0:8r:16r@24r@32\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(str1:str2:str3:str4:));\n-  CHECK_IF (!strcmp (meth->method_types, \"@48@0:8r*16*24*32r*40\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"@48@0:8r*16*24*32r*40\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(foo1:foo2:foo3:foo4:));\n-  CHECK_IF (!strcmp (meth->method_types, \"Vv48@0:8@16r@24@32r@40\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"Vv48@0:8@16r@24@32r@40\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(sel1:id1:));\n-  CHECK_IF (!strcmp (meth->method_types, \"rn*32@0:8r:16r@24\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"rn*32@0:8r:16r@24\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(obj1:obj2:obj3:));\n-  CHECK_IF (!strcmp (meth->method_types, \"N@40@0:8r@16@24^{Object=#}32\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"N@40@0:8r@16@24^{Object=#}32\"));\n \n   meth = class_getClassMethod (fooClass, @selector(_defaultScriptingComponent));\n-  CHECK_IF (!strcmp (meth->method_types, \"^{ComponentInstanceRecord=[1q]}16@0:8\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"^{ComponentInstanceRecord=[1q]}16@0:8\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(_formatCocoaErrorString:parameters:applicableFormatters:count:));\n-  CHECK_IF (!strcmp (meth->method_types, \"@44@0:8@16r*24^^{?}32i40\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"@44@0:8@16r*24^^{?}32i40\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(formatter_func:run:));\n-  CHECK_IF (!strcmp (meth->method_types, \"^{?=^?@I}32@0:8@16r^^{?}24\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"^{?=^?@I}32@0:8@16r^^{?}24\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(_forgetWord:inDictionary:));\n-  CHECK_IF (!strcmp (meth->method_types, \"c32@0:8nO@16nO@24\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"c32@0:8nO@16nO@24\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(_registerServicesMenu:withSendTypes:andReturnTypes:addToList:));\n-  CHECK_IF (!strcmp (meth->method_types, \"v44@0:8@16r^*24r^*32c40\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"v44@0:8@16r^*24r^*32c40\"));\n \n   meth = class_getClassMethod (fooClass, @selector(_proxySharePointer));\n-  CHECK_IF (!strcmp (meth->method_types, \"^^{__CFSet}16@0:8\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"^^{__CFSet}16@0:8\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(_checkGrammarInString:language:details:));\n-  CHECK_IF (!strcmp (meth->method_types, \"{_NSRange=II}40@0:8n@16nO@24oO^@32\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"{_NSRange=II}40@0:8n@16nO@24oO^@32\"));\n \n   meth = class_getInstanceMethod (fooClass, @selector(_resolvePositionalStakeGlyphsForLineFragment:lineFragmentRect:minPosition:maxPosition:maxLineFragmentWidth:breakHint:));\n-  CHECK_IF (!strcmp (meth->method_types, \"B60@0:8^{__CTLine=}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}24f40f44f48^Q52\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"B60@0:8^{__CTLine=}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}24f40f44f48^Q52\"));\n \n   meth = class_getClassMethod (fooClass, @selector(findVoiceByIdentifier:returningCreator:returningID:));\n-  CHECK_IF (!strcmp (meth->method_types, \"c40@0:8@16^I24^I32\"));\n+  CHECK_IF (!strcmp (method_getTypeEncoding (meth), \"c40@0:8@16^I24^I32\"));\n \n-  ivars = fooClass->ivars;\n-  CHECK_IF (ivars->ivar_count == 1);\n+  ivars = class_copyIvarList (fooClass, &ivar_count);\n+  CHECK_IF (ivar_count == 1);\n \n-  ivar = ivars->ivar_list;\n-  CHECK_IF (!strcmp (ivar->ivar_name, \"r\"));\n-  CHECK_IF (!strcmp (ivar->ivar_type,\n+  ivar = ivars[0];\n+  CHECK_IF (!strcmp (ivar_getName(ivar), \"r\"));\n+  CHECK_IF (!strcmp (ivar_getTypeEncoding(ivar),\n    \"{?=\\\"_attributes\\\"@\\\"NSDictionary\\\"\\\"_font\\\"@\\\"NSFont\\\"\\\"_characterLength\\\"\"\n     \"Q\\\"_nominalGlyphLocation\\\"Q\\\"p\\\"^Q\\\"_defaultLineHeight\\\"f\\\"_defaultBaselineOffset\\\"\"\n     \"f\\\"_horizExpansion\\\"f\\\"_baselineDelta\\\"f\\\"_attachmentBBox\\\"{_NSRect=\\\"origin\\\"\""}, {"sha": "194d3664f091cd1bccba4f95a413c14ecdeab369", "filename": "gcc/testsuite/objc.dg/image-info.m", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fimage-info.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fimage-info.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fimage-info.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -7,13 +7,19 @@\n /* { dg-skip-if \"NeXT-only\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n /* { dg-options \"-freplace-objc-classes\" } */\n \n-#include \"../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n+#include <objc/Object.h>\n \n extern void abort(void);\n-\n #define CHECK_IF(expr) if(!(expr)) abort();\n \n+@interface Object (TEST_SUITE_C1)\n+- init;\n+@end\n+@implementation Object (TEST_SUITE_C1)\n+- init {return self;}\n+@end\n+\n @interface Base: Object {\n @public\n   int a;\n@@ -33,4 +39,5 @@ @implementation Base\n }\n @end\n \n-/* { dg-final { scan-assembler \"\\t.section __OBJC, __image_info.*\\n\\t.align.*\\nL_OBJC_IMAGE_INFO.*:\\n\\t.long\\t0\\n\\t.long\\t1\" } } */\n+/* { dg-final { scan-assembler \"\\t.section __OBJC, __image_info.*\\n\\t.align.*\\nL_OBJC_ImageInfo.*:\\n\\t.long\\t0\\n\\t.long\\t1\"  { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \"\\t.section __DATA, __objc_imageinfo.*\\n\\t.align.*\\nL_OBJC_ImageInfo.*:\\n\\t.long\\t0\\n\\t.long\\t17\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "737d58a6864bcfec96e0167dd2b3f09c004d811e", "filename": "gcc/testsuite/objc.dg/lookup-1.m", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Flookup-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Flookup-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Flookup-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do run } */\n /* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-additional-sources \"../objc-obj-c++-shared/Object1.m\" } */\n \n #include <stdlib.h>\n #include \"../objc-obj-c++-shared/Object1.h\"\n@@ -53,5 +54,3 @@ int main(void) {\n \n   return 0;\n }\n-\n-#include \"../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "df25bba21ee3fb3dabd1125535e1660c236e1236", "filename": "gcc/testsuite/objc.dg/method-4.m", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-4.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -22,5 +22,5 @@ void foo(void) {\n   obj = [ObjectAlias2 new];\n }\n \n-/* { dg-final { scan-assembler \"_OBJC_CLASS_REFERENCES_0\" } } */\n-/* { dg-final { scan-assembler-not \"_OBJC_CLASS_REFERENCES_1\" } } */\n+/* { dg-final { scan-assembler \"_OBJC_ClassRefs_0\" } } */\n+/* { dg-final { scan-assembler-not \"_OBJC_ClassRefs_1\" } } */"}, {"sha": "c76b6166d2ef954cf954eb19ba5bd9e5e4f06a7e", "filename": "gcc/testsuite/objc.dg/next-runtime-1.m", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fnext-runtime-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fnext-runtime-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fnext-runtime-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,19 +1,20 @@\n /* Test that the correct version number (6) is set in the module descriptor\n-   when compiling for the NeXT runtime.  */\n-/* Author: Ziemowit Laski <zlaski@apple.com>  */\n+   when compiling for the NeXT runtime ABI=0 - and that the MODULE descriptor\n+   is not emitted at all for ABI 2.  */\n+/* modified from a testcase added by: Ziemowit Laski <zlaski@apple.com>  */\n \n /* { dg-do compile { target *-*-darwin* } } */\n /* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fobjc-abi-version=1\" } { \"\" } } */\n+/* { dg-options \"-fobjc-abi-version=0\" { target { *-*-darwin* && { ! lp64 } } } } */\n \n-#include \"../objc-obj-c++-shared/Object1.h\"\n-\n-@interface FooBar: Object\n+@interface FooBar\n - (void)boo;\n @end\n \n @implementation FooBar\n - (void)boo { }\n @end\n \n-/* { dg-final { scan-assembler \"L_OBJC_MODULES:\\n\\[ \\t\\]*\\.long\\t6\\n\" { target { *-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \"L_OBJC_MODULES:\\n\\[ \\t\\]*\\.quad\\t6\\n\" { target { *-*-darwin* && {  lp64 } } } } } */\n+/* { dg-final { scan-assembler \"L_OBJC_Module:\\n\\[ \\t\\]*\\.long\\t6\\n\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler-not \"L_OBJC_Module\" { target { *-*-darwin* && {  lp64 } } } } } */"}, {"sha": "d8092a8067aed145be4af0e2aca5656999e5fb4f", "filename": "gcc/testsuite/objc.dg/pr23214.m", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fpr23214.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fpr23214.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fpr23214.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -3,10 +3,19 @@\n \n /* { dg-do run } */\n /* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n-/* { dg-additional-sources \"../objc-obj-c++-shared/Object1.m\" } */\n \n-#import \"../objc-obj-c++-shared/Object1.h\"\n-#import \"../objc-obj-c++-shared/Protocol1.h\"\n+#include <objc/Protocol.h>\n+ \n+#ifdef __OBJC2__\n+/* The ObjC V2 \"Object\" does not provide -class.  */\n+@interface Object (TS_CAT)\n+- class;\n+@end\n+\n+@implementation Object (TS_CAT)\n+- class { return isa; }\n+@end\n+#endif\n \n @protocol A\n @end"}, {"sha": "bf507a788247fa73dd0ee28e9899537270a9c1e8", "filename": "gcc/testsuite/objc.dg/special/unclaimed-category-1.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Funclaimed-category-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Funclaimed-category-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Funclaimed-category-1.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -5,7 +5,11 @@\n \n @interface TestClass\n {\n+#ifdef __OBJC2__\n+  Class isa;\n+#else\n   id isa;\n+#endif\n }\n - (int)D;\n @end"}, {"sha": "88e3d8ea7d192a87d24c126b028718d076c8925b", "filename": "gcc/testsuite/objc.dg/special/unclaimed-category-1.m", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Funclaimed-category-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Funclaimed-category-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Funclaimed-category-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -2,11 +2,11 @@\n /* { dg-do run } */\n /* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n \n-#import \"../../objc-obj-c++-shared/next-mapping.h\"\n #include <objc/objc.h>\n #ifndef __NEXT_RUNTIME__\n #include <objc/objc-api.h>\n #endif\n+#include \"../../objc-obj-c++-shared/next-mapping.h\"\n \n extern void abort (void);\n \n@@ -73,5 +73,3 @@ int main (void)\n \n   return 0;\n }\n-\n-#import \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "936f8d494c75cf1c95e5e11536af263fed1bded0", "filename": "gcc/testsuite/objc.dg/symtab-1.m", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fsymtab-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fsymtab-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fsymtab-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -4,7 +4,7 @@\n /* { dg-do compile { target { *-*-darwin* } } } */\n /* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n \n-#include \"../objc-obj-c++-shared/Object1.h\"\n+#include <objc/Object.h>\n \n @interface Base: Object \n - (void)setValues;\n@@ -22,7 +22,6 @@ @implementation Derived\n -(void)checkValues { }\n @end\n \n-/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.long\\t0\\n\\t.long\\t0\\n\\t.word\\t2\\n\\t.word\\t0\\n\\t.long\\tL_OBJC_CLASS_Derived.*\\n\\t.long\\tL_OBJC_CLASS_Base.*\\n\" { target { *86*-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.long\\t0\\n\\t.long\\t0\\n\\t.short\\t2\\n\\t.short\\t0\\n\\t.long\\tL_OBJC_CLASS_Derived.*\\n\\t.long\\tL_OBJC_CLASS_Base.*\\n\" { target { powerpc*-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.quad\\t0\\n\\t.quad\\t0\\n\\t.word\\t2\\n\\t.word\\t0\\n\\t.space 4\\n\\t.quad\\tL_OBJC_CLASS_Derived.*\\n\\t.quad\\tL_OBJC_CLASS_Base.*\\n\" { target { *86*-*-darwin* && { lp64 } } } } } */\n-/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.quad\\t0\\n\\t.quad\\t0\\n\\t.short\\t2\\n\\t.short\\t0\\n\\t.space 4\\n\\t.quad\\tL_OBJC_CLASS_Derived.*\\n\\t.quad\\tL_OBJC_CLASS_Base.*\\n\" { target { powerpc*-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \"L_OBJC_Symbols.*:\\n\\t.long\\t0\\n\\t.long\\t0\\n\\t.word\\t2\\n\\t.word\\t0\\n\\t.long\\tL_OBJC_Class_Derived.*\\n\\t.long\\tL_OBJC_Class_Base.*\\n\" { target { *86*-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \"L_OBJC_Symbols.*:\\n\\t.long\\t0\\n\\t.long\\t0\\n\\t.short\\t2\\n\\t.short\\t0\\n\\t.long\\tL_OBJC_Class_Derived.*\\n\\t.long\\tL_OBJC_Class_Base.*\\n\" { target { powerpc*-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler-not \"L_OBJC_Symbols\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "bccf4a1123357af7148a80c112d82c235e88cb16", "filename": "gcc/testsuite/objc.dg/torture/forward-1.m", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fforward-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fforward-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fforward-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,14 +1,18 @@\n /* { dg-do run } */\n /* See if -forward::/-performv:: is able to work. */\n /* { dg-xfail-run-if \"PR36610\" { ! { { i?86-*-* x86_64-*-* } && ilp32 } } { \"-fgnu-runtime\" } { \"\" } } */\n-/* { dg-skip-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-skip-if \"Needs OBJC2 Implementation\" { *-*-darwin* && { lp64 } } { \"-fnext-runtime\" } { \"\" } } */\n+/* There is no implementation of forward: in the NeXT m64 libobjc/Object\n+   neither have we implemented this in our extensions - so we have to skip it\n+   for now.  */\n \n #include <stdio.h>\n #include <stdlib.h>\n \n-#import \"../../objc-obj-c++-shared/Object1.h\"\n-#import \"../../objc-obj-c++-shared/next-mapping.h\"\n-#include <objc/objc-api.h>\n+#ifndef __NEXT_RUNTIME__\n+#  include <objc/objc-api.h>\n+#endif\n+#include <objc/Object.h>\n \n #define VALUETOUSE 1234567890\n "}, {"sha": "f0f28238d9bcd71448483d408da653f941fc50a9", "filename": "gcc/testsuite/objc.dg/torture/strings/const-str-10.m", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-10.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-10.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-10.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -29,6 +29,7 @@ @interface NSConstantString : NSSimpleCString\n \n const NSConstantString *appKey = @\"MyApp\";\n \n-/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" } } */\n+/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \".section __DATA, __objc_stringobj\" { target { *-*-darwin* && { lp64 } } } } } */\n /* { dg-final { scan-assembler \".long\\t__NSConstantStringClassReference\\n\\t.long\\t.*\\n\\t.long\\t5\\n\\t.data\" { target { *-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \".quad\\t__NSConstantStringClassReference\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \".quad\\t_OBJC_CLASS_._NSConstantString\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "fa9dbd985a3bf7ea6ced65d1d052d257d661a680", "filename": "gcc/testsuite/objc.dg/torture/strings/const-str-11.m", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-11.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-11.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-11.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -29,6 +29,7 @@ @interface XStr : XString {\n \n const XStr *appKey = @\"MyApp\";\n \n-/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" } } */\n+/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \".section __DATA, __objc_stringobj\" { target { *-*-darwin* && { lp64 } } } } } */\n /* { dg-final { scan-assembler \".long\\t__XStrClassReference\\n\\t.long\\t.*\\n\\t.long\\t5\\n\\t.data\"  { target { *-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \".quad\\t__XStrClassReference\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \".quad\\t_OBJC_CLASS_._XStr\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "39bd102743541fb049f4500a2837f007d9edeefa", "filename": "gcc/testsuite/objc.dg/torture/strings/const-str-9.m", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-9.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-9.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftorture%2Fstrings%2Fconst-str-9.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -21,6 +21,7 @@ @interface NSConstantString: Object {\n \n const NSConstantString *appKey = @\"MyApp\";\n \n-/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" } } */\n+/* { dg-final { scan-assembler \".section __OBJC, __cstring_object\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \".section __DATA, __objc_stringobj\" { target { *-*-darwin* && { lp64 } } } } } */\n /* { dg-final { scan-assembler \".long\\t__NSConstantStringClassReference\\n\\t.long\\t.*\\n\\t.long\\t5\\n\\t.data\" { target { *-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \".quad\\t__NSConstantStringClassReference\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \".quad\\t_OBJC_CLASS_._NSConstantString\\n\\t.quad\\t.*\\n\\t.long\\t5\\n\\t.space\" { target { *-*-darwin* && { lp64 } } } } } */"}, {"sha": "c040031116941410e2af6f7d9873f5c6a44438c5", "filename": "gcc/testsuite/objc.dg/zero-link-1.m", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fzero-link-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fzero-link-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fzero-link-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -25,6 +25,7 @@ int main(void) {\n   return 0;\n }\n \n-/* { dg-final { scan-assembler-not \"_OBJC_CLASS_REFERENCES_0\" } } */\n+/* { dg-final { scan-assembler-not \"_OBJC_ClassRefs_0\" { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler-not \"_OBJC_ClassRef_Base\" { target { *-*-darwin* && { lp64 } } } } } */\n /* { dg-final { scan-assembler \"objc_getClass\" } } */\n "}, {"sha": "ff82e5ed6d72e0b3ce0cd35ba961890a1f9f18c3", "filename": "gcc/testsuite/objc.dg/zero-link-2.m", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fzero-link-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc.dg%2Fzero-link-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fzero-link-2.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -5,8 +5,7 @@\n /* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n /* { dg-options \"-fno-zero-link\" } */\n \n-#include \"../objc-obj-c++-shared/Object1.h\"\n-#include <objc/objc.h>\n+#include <objc/Object.h>\n \n extern void abort(void);\n #define CHECK_IF(expr) if(!(expr)) abort();\n@@ -25,5 +24,6 @@ int main(void) {\n   return 0;\n }\n \n-/* { dg-final { scan-assembler \"_OBJC_CLASS_REFERENCES_0\" } } */\n+/* { dg-final { scan-assembler \"_OBJC_ClassRefs_0\"  { target { *-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \"_OBJC_ClassRef_Base\"  { target { *-*-darwin* && { lp64 } } } } } */\n /* { dg-final { scan-assembler-not \"objc_getClass\" } } */"}, {"sha": "e4c9cf4cd42977c121d6a08cedb3bfe48a97eaab", "filename": "gcc/testsuite/objc/execute/accessing_ivars.m", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Faccessing_ivars.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Faccessing_ivars.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Faccessing_ivars.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,7 +1,9 @@\n /* Contributed by Nicola Pero - Thu Mar  8 16:27:46 CET 2001 */\n #include <stdlib.h>\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n+#ifndef __NEXT_RUNTIME__\n #include <objc/objc-api.h>\n+#endif\n+#include \"../../objc-obj-c++-shared/Object1.h\"\n \n /* Test that by using -> we can access ivars of other objects of the same \n    class */\n@@ -53,3 +55,4 @@ int main (void)\n \n   return 0;\n }\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "ca70c21a411a0d5c65e8e4fc16c7ca5615fcf072", "filename": "gcc/testsuite/objc/execute/bf-common.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-common.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -11,6 +11,7 @@\n #define objc_get_class(C) objc_getClass(C)\n #endif\n \n+#ifndef __OBJC2__\n void print_ivars (Class class)\n {\n   struct objc_ivar_list* ivars = class->ivars;\n@@ -61,9 +62,11 @@ void compare_structures (Class class, const char* type)\n   \n   printf (\"%d ivars checked\\n\", i);\n }\n+#endif\n \n int main ()\n {\n+#ifndef __OBJC2__\n   struct class_vars\n     {\n       @defs (MyObject);\n@@ -80,8 +83,10 @@ int main ()\n       printf (\"sizes don't match (computed %d, exact %d)\\n\", size1, size2);\n       abort ();\n     }\n+#endif\n   \n   exit (0);\n }\n-\n+#ifndef __OBJC2__\n #include \"../../objc-obj-c++-shared/objc-test-suite-next-encode-assist-impl.h\"\n+#endif"}, {"sha": "840881f4a97f5d0235b2f07f3be56f37db560318", "filename": "gcc/testsuite/objc/execute/bycopy-2.m", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-2.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -27,5 +27,4 @@ int main (void)\n \n    exit (0);\n }\n-\n-\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "15c49a5dd34b595075ae4d2832f097da46a5e909", "filename": "gcc/testsuite/objc/execute/bycopy-3.m", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-3.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -24,13 +24,25 @@ @protocol MyProtocol\n \n /* This no-op class to keep it compile under broken gcc 3.x */\n @interface MyObject : Object <MyProtocol> \n+#ifdef __OBJC2__\n++ (id) initialize;\n++ (id) alloc;\n++ new;\n+- init;\n+#endif\n @end\n \n @implementation MyObject\n + (bycopy id<MyProtocol>) bycopyMethod\n {\n   return [MyObject alloc];\n }\n+#ifdef __OBJC2__\n++ initialize {return self;}\n++ alloc { return class_createInstance (self, 0);}\n++ new { return [[self alloc] init]; }\n+- init {return self;}\n+#endif\n @end\n \n /* The following header, together with the implementation included below,"}, {"sha": "54a77d247f76c4b46b77197a8bfcc7b8133f1f22", "filename": "gcc/testsuite/objc/execute/class-tests-1.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fclass-tests-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fclass-tests-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fclass-tests-1.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,5 +1,6 @@\n /* Contributed by Nicola Pero on Tue Mar  6 23:05:53 CET 2001 */\n \n+#include <stdio.h>\n #include <stdlib.h>\n #include \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>"}, {"sha": "1aa73947d635437defe480db9bcdfa416e50a661", "filename": "gcc/testsuite/objc/execute/class-tests-2.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fclass-tests-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fclass-tests-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fclass-tests-2.h?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,6 +1,7 @@\n /* Contributed by Nicola Pero on Tue Mar  6 23:05:53 CET 2001 */\n #include <objc/objc.h>\n #include <objc/objc-api.h>\n+#include <stdio.h>\n #include <stdlib.h>\n \n /*"}, {"sha": "61d7625122de757238fa867fbcd1ddc869dfc103", "filename": "gcc/testsuite/objc/execute/compatibility_alias.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fcompatibility_alias.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fcompatibility_alias.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fcompatibility_alias.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -10,3 +10,4 @@ int main (void)\n \n   return 0;\n }\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "57d1a4bf69a42fbada37f8fc67aec59c67c5f5ed", "filename": "gcc/testsuite/objc/execute/enumeration-1.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fenumeration-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fenumeration-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fenumeration-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -48,3 +48,4 @@ int main (void)\n \n   return 0;\n }\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "3094963c682523824c5c21f03064b74bf9497904", "filename": "gcc/testsuite/objc/execute/enumeration-2.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fenumeration-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fenumeration-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fenumeration-2.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -50,3 +50,4 @@ int main (void)\n \n   return 0;\n }\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "2db40a8548630d5c6480f2a515fa6e41bf90f865", "filename": "gcc/testsuite/objc/execute/exceptions/catchall-1.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Fcatchall-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Fcatchall-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Fcatchall-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -74,3 +74,4 @@ int main (void) {\n \ttest((Object *)-1);\n \treturn 0;\n }\n+#import \"../../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "0443ca130ee8395e1dbc6a193ae6a5fe8acd689a", "filename": "gcc/testsuite/objc/execute/exceptions/exceptions.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Fexceptions.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Fexceptions.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Fexceptions.exp?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -28,6 +28,7 @@ lappend additional_flags \"-fobjc-exceptions\"\n # load support procs\n load_lib objc-torture.exp\n load_lib torture-options.exp\n+load_lib target-supports.exp\n \n torture-init\n objc-set-runtime-options \"execute\" \"additional_flags=-fobjc-exceptions\""}, {"sha": "370b19bb5ef4c0778caae909d7c60e608f1075ae", "filename": "gcc/testsuite/objc/execute/exceptions/finally-1.m", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Ffinally-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Ffinally-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Ffinally-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,6 +1,22 @@\n #include <stdio.h>\n #include <stdlib.h>\n+//#import \"../../../objc-obj-c++-shared/Object1.h\"\n+#ifdef __OBJC2__\n+#include <objc/runtime.h>\n+@interface Object\n++ initialize;\n++ new;\n+- free;\n+@end\n+@implementation Object\n++ initialize { return self; }\n++ new  { return class_createInstance (self, 0); }\n+- free { return object_dispose(self);}\n+@end\n+\n+#else\n #import \"../../../objc-obj-c++-shared/Object1.h\"\n+#endif\n \n static int made_try = 0;\n \n@@ -57,3 +73,4 @@\n     abort ();\n   return 0;\n }\n+//#import \"../../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "6b31d7cc86c002ec8a20bb6db5e6e197f79375f5", "filename": "gcc/testsuite/objc/execute/exceptions/foward-1.m", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Ffoward-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Ffoward-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Ffoward-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -2,12 +2,33 @@\n /* Developed by Marcin Koziej <creep@desk.pl>.  */\n \n #include <stdlib.h>\n-#import \"../../../objc-obj-c++-shared/Object1.h\"\n+#include <objc/Object.h>\n+#ifndef __NEXT_RUNTIME__\n #import <objc/objc-api.h>\n+#endif\n+\n+#ifdef __OBJC2__\n+@interface Object (TEST_SUITE_ADDITIONS)\n++ initialize;\n++ alloc;\n++ new;\n+- init;\n+- free;\n+@end\n+\n+@implementation Object (TEST_SUITE_ADDITIONS)\n++ initialize { return self; }\n++ alloc { return class_createInstance (self, 0); }\n++ new { return [[self alloc] init]; }\n+- init { return self; }\n+- free { return object_dispose(self); }\n+@end\n+#endif\n \n static int i;\n \n-@interface Thrower : Object\n+__attribute__((objc_exception)) \n+@interface Thrower : Object \n - forward: (SEL) s : (void*) a;\n @end\n \n@@ -16,8 +37,10 @@ @implementation Thrower\n {\n   i++;\n   @throw [Object new];\n+  return nil;\n }\n @end\n+\n int\n main()\n {"}, {"sha": "0488d792dcd247fa373394f027de34db4ff7b6ae", "filename": "gcc/testsuite/objc/execute/exceptions/local-variables-1.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Flocal-variables-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Flocal-variables-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fexceptions%2Flocal-variables-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -60,3 +60,4 @@ int main(void) {\n   foo(15, &gf1);\n   return 0;\n }\n+#import \"../../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "651444963f887d9a809c532ea66e0ebe2bd69e8c", "filename": "gcc/testsuite/objc/execute/formal_protocol-1.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-1.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -42,4 +42,4 @@ int main (void)\n \n   return 0;\n }\n-\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "b830cd96ee5f8bcecad82600091b8fa00cb3e9e4", "filename": "gcc/testsuite/objc/execute/formal_protocol-2.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-2.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -43,4 +43,4 @@ int main (void)\n \n   return 0;\n }\n-\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "f28c95fecbf5df2c461a8625983ebdb3642b8d69", "filename": "gcc/testsuite/objc/execute/formal_protocol-3.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-3.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -56,4 +56,4 @@ int main (void)\n \n   return 0;\n }\n-\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "10aba89360a5c2fc7e733bf9be5277b34ac19b31", "filename": "gcc/testsuite/objc/execute/formal_protocol-4.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-4.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -38,4 +38,4 @@ int main (void)\n \n   return 0;\n }\n-\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "c3bd53d3ace45195d9aa6d30528e15571e51f37a", "filename": "gcc/testsuite/objc/execute/formal_protocol-5.m", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-5.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,7 +1,8 @@\n /* Contributed by Nicola Pero - Fri Mar  9 21:35:47 CET 2001 */\n \n #include <stdlib.h>\n-#include \"../../objc-obj-c++-shared/Protocol1.h\"\n+#include <objc/Protocol.h>\n+#include \"../../objc-obj-c++-shared/next-mapping.h\"\n \n /* Test defining a protocol, and accessing it using @protocol */\n \n@@ -35,4 +36,3 @@ int main (void)\n \n   return 0;\n }\n-"}, {"sha": "b02fc1ea42ccba0cd16a9f81a8e1ac6df25f0f5b", "filename": "gcc/testsuite/objc/execute/formal_protocol-6.m", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-6.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,7 +1,8 @@\n /* Contributed by Nicola Pero - Fri Mar  9 21:35:47 CET 2001 */\n \n #include <stdlib.h>\n-#include \"../../objc-obj-c++-shared/Protocol1.h\"\n+#include <objc/Protocol.h>\n+#include \"../../objc-obj-c++-shared/next-mapping.h\"\n \n /* Test defining a protocol, and accessing it using @protocol */\n "}, {"sha": "d15013a29ef9e7b2b20b820c99c9f23c438e4416", "filename": "gcc/testsuite/objc/execute/formal_protocol-7.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fformal_protocol-7.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -41,4 +41,4 @@ int main (void)\n \n   return 0;\n }\n-\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "d4ab4cb1c8756cbc628f92885e054bf15313af89", "filename": "gcc/testsuite/objc/execute/no_clash.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fno_clash.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fno_clash.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fno_clash.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -39,3 +39,4 @@ int main (void)\n \n   return 0;\n }\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "14a7f5232e78e4a9a702498a2a466acda1b84d2c", "filename": "gcc/testsuite/objc/execute/object_is_class.m", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fobject_is_class.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fobject_is_class.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fobject_is_class.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,8 +1,10 @@\n /* Contributed by Nicola Pero - Tue Jul  3 10:55:21 BST 2001 */\n-#import \"../../objc-obj-c++-shared/next-mapping.h\"\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n-#include <objc/objc.h>\n-#include <objc/objc-api.h>\n+#ifdef __NEXT_RUNTIME__\n+#  include \"../../objc-obj-c++-shared/next-mapping.h\"\n+#else\n+#  include <objc/objc-api.h>\n+#endif\n+#include \"../../objc-obj-c++-shared/Object1.h\"\n \n /* This test demonstrate a failure in object_is_class which was fixed */\n \n@@ -41,3 +43,4 @@ int main (void)\n \n   return 0;\n }\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}, {"sha": "91a628ebac121b8d8bba7cbb76c001adeeb84279", "filename": "gcc/testsuite/objc/execute/object_is_meta_class.m", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fobject_is_meta_class.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d764a8e6bdae09aecb7a8378def9d900f84ce53e/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fobject_is_meta_class.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fobject_is_meta_class.m?ref=d764a8e6bdae09aecb7a8378def9d900f84ce53e", "patch": "@@ -1,7 +1,10 @@\n /* Contributed by Nicola Pero - Tue Jul  3 10:55:21 BST 2001 */\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n-#import \"../../objc-obj-c++-shared/next-mapping.h\"\n-#include <objc/objc-api.h>\n+#ifdef __NEXT_RUNTIME__\n+#  include \"../../objc-obj-c++-shared/next-mapping.h\"\n+#else\n+#  include <objc/objc-api.h>\n+#endif\n+#include \"../../objc-obj-c++-shared/Object1.h\"\n \n /* This test demonstrate a failure in object_is_meta_class which was fixed */\n \n@@ -38,4 +41,4 @@ int main (void)\n \n   return 0;\n }\n-\n+#include \"../../objc-obj-c++-shared/Object1-implementation.h\""}]}