{"sha": "d5c67efda0d5e2d42abd49c0d58bb39a038d20ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVjNjdlZmRhMGQ1ZTJkNDJhYmQ0OWMwZDU4YmIzOWEwMzhkMjBlYw==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2014-05-22T03:51:19Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2014-05-22T03:51:19Z"}, "message": "Improve scheduling debug output\n\n\t* haifa-sched.c (debug_ready_list): Remove unnecessary prototype.\n\t(advance_one_cycle): Update.\n\t(schedule_insn, queue_to_ready): Add debug printouts.\n\t(debug_ready_list_1): New static function.\n\t(debug_ready_list): Update.\n\t(max_issue): Add debug printouts.\n\t(dump_insn_stream): New static function.\n\t(schedule_block): Use it.  Also better indent printouts.\n\nFrom-SVN: r210737", "tree": {"sha": "0da13a3a8ff178d680ce67353e39f033794dbcfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0da13a3a8ff178d680ce67353e39f033794dbcfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5c67efda0d5e2d42abd49c0d58bb39a038d20ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c67efda0d5e2d42abd49c0d58bb39a038d20ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c67efda0d5e2d42abd49c0d58bb39a038d20ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c67efda0d5e2d42abd49c0d58bb39a038d20ec/comments", "author": null, "committer": null, "parents": [{"sha": "06bc63d19fdf3cd51f1618fe28aef8b95d4a4579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bc63d19fdf3cd51f1618fe28aef8b95d4a4579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bc63d19fdf3cd51f1618fe28aef8b95d4a4579"}], "stats": {"total": 95, "additions": 80, "deletions": 15}, "files": [{"sha": "c57093b7f66b9db79b52ada8f10539276bedbdfb", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c67efda0d5e2d42abd49c0d58bb39a038d20ec/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c67efda0d5e2d42abd49c0d58bb39a038d20ec/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=d5c67efda0d5e2d42abd49c0d58bb39a038d20ec", "patch": "@@ -859,8 +859,6 @@ static rtx ready_remove_first_dispatch (struct ready_list *ready);\n static void queue_to_ready (struct ready_list *);\n static int early_queue_to_ready (state_t, struct ready_list *);\n \n-static void debug_ready_list (struct ready_list *);\n-\n /* The following functions are used to implement multi-pass scheduling\n    on the first cycle.  */\n static rtx ready_remove (struct ready_list *, int);\n@@ -2971,7 +2969,7 @@ HAIFA_INLINE static void\n advance_one_cycle (void)\n {\n   advance_state (curr_state);\n-  if (sched_verbose >= 6)\n+  if (sched_verbose >= 4)\n     fprintf (sched_dump, \";;\\tAdvanced a state.\\n\");\n }\n \n@@ -3750,7 +3748,7 @@ schedule_insn (rtx insn)\n   if (sched_verbose >= 1)\n     {\n       struct reg_pressure_data *pressure_info;\n-      fprintf (sched_dump, \";;\\t%3i--> %s%-40s:\",\n+      fprintf (sched_dump, \";;\\t%3i--> %s %-40s:\",\n \t       clock_var, (*current_sched_info->print_insn) (insn, 1),\n \t       str_pattern_slim (PATTERN (insn)));\n \n@@ -4912,7 +4910,11 @@ queue_to_ready (struct ready_list *ready)\n \t       && model_index (insn) == model_curr_point)\n \t  && !SCHED_GROUP_P (insn)\n \t  && insn != skip_insn)\n-\tqueue_insn (insn, 1, \"ready full\");\n+\t{\n+\t  if (sched_verbose >= 2)\n+\t    fprintf (sched_dump, \"keeping in queue, ready full\\n\");\n+\t  queue_insn (insn, 1, \"ready full\");\n+\t}\n       else\n \t{\n \t  ready_add (ready, insn, false);\n@@ -4957,6 +4959,9 @@ queue_to_ready (struct ready_list *ready)\n \n       q_ptr = NEXT_Q_AFTER (q_ptr, stalls);\n       clock_var += stalls;\n+      if (sched_verbose >= 2)\n+\tfprintf (sched_dump, \";;\\tAdvancing clock by %d cycle[s] to %d\\n\",\n+\t\t stalls, clock_var);\n     }\n }\n \n@@ -5117,10 +5122,11 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n }\n \n \n-/* Print the ready list for debugging purposes.  Callable from debugger.  */\n-\n+/* Print the ready list for debugging purposes.\n+   If READY_TRY is non-zero then only print insns that max_issue\n+   will consider.  */\n static void\n-debug_ready_list (struct ready_list *ready)\n+debug_ready_list_1 (struct ready_list *ready, char *ready_try)\n {\n   rtx *p;\n   int i;\n@@ -5134,12 +5140,16 @@ debug_ready_list (struct ready_list *ready)\n   p = ready_lastpos (ready);\n   for (i = 0; i < ready->n_ready; i++)\n     {\n+      if (ready_try != NULL && ready_try[ready->n_ready - i - 1])\n+\tcontinue;\n+\n       fprintf (sched_dump, \"  %s:%d\",\n \t       (*current_sched_info->print_insn) (p[i], 0),\n \t       INSN_LUID (p[i]));\n       if (sched_pressure != SCHED_PRESSURE_NONE)\n \tfprintf (sched_dump, \"(cost=%d\",\n \t\t INSN_REG_PRESSURE_EXCESS_COST_CHANGE (p[i]));\n+      fprintf (sched_dump, \":prio=%d\", INSN_PRIORITY (p[i]));\n       if (INSN_TICK (p[i]) > clock_var)\n \tfprintf (sched_dump, \":delay=%d\", INSN_TICK (p[i]) - clock_var);\n       if (sched_pressure != SCHED_PRESSURE_NONE)\n@@ -5148,6 +5158,13 @@ debug_ready_list (struct ready_list *ready)\n   fprintf (sched_dump, \"\\n\");\n }\n \n+/* Print the ready list.  Callable from debugger.  */\n+static void\n+debug_ready_list (struct ready_list *ready)\n+{\n+  debug_ready_list_1 (ready, NULL);\n+}\n+\n /* Search INSN for REG_SAVE_NOTE notes and convert them back into insn\n    NOTEs.  This is used for NOTE_INSN_EPILOGUE_BEG, so that sched-ebb\n    replaces the epilogue note in the correct basic block.  */\n@@ -5377,6 +5394,12 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n     if (!ready_try [i])\n       all++;\n \n+  if (sched_verbose >= 2)\n+    {\n+      fprintf (sched_dump, \";;\\t\\tmax_issue among %d insns:\", all);\n+      debug_ready_list_1 (ready, ready_try);\n+    }\n+\n   /* I is the index of the insn to try next.  */\n   i = 0;\n   tries_num = 0;\n@@ -5881,6 +5904,35 @@ verify_shadows (void)\n   return earliest_fail;\n }\n \n+/* Print instructions together with useful scheduling information between\n+   HEAD and TAIL (inclusive).  */\n+static void\n+dump_insn_stream (rtx head, rtx tail)\n+{\n+  fprintf (sched_dump, \";;\\t| insn | prio |\\n\");\n+\n+  rtx next_tail = NEXT_INSN (tail);\n+  for (rtx insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n+    {\n+      int priority = NOTE_P (insn) ? 0 : INSN_PRIORITY (insn);\n+      const char *pattern = (NOTE_P (insn)\n+\t\t\t     ? \"note\"\n+\t\t\t     : str_pattern_slim (PATTERN (insn)));\n+\n+      fprintf (sched_dump, \";;\\t| %4d | %4d | %-30s \",\n+\t       INSN_UID (insn), priority, pattern);\n+\n+      if (sched_verbose >= 4)\n+\t{\n+\t  if (NOTE_P (insn) || recog_memoized (insn) < 0)\n+\t    fprintf (sched_dump, \"nothing\");\n+\t  else\n+\t    print_reservation (sched_dump, insn);\n+\t}\n+      fprintf (sched_dump, \"\\n\");\n+    }\n+}\n+\n /* Use forward list scheduling to rearrange insns of block pointed to by\n    TARGET_BB, possibly bringing insns from subsequent blocks in the same\n    region.  */\n@@ -5919,7 +5971,12 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \n   /* Debug info.  */\n   if (sched_verbose)\n-    dump_new_block_header (0, *target_bb, head, tail);\n+    {\n+      dump_new_block_header (0, *target_bb, head, tail);\n+\n+      if (sched_verbose >= 2)\n+\tdump_insn_stream (head, tail);\n+    }\n \n   if (init_state == NULL)\n     state_reset (curr_state);\n@@ -6047,7 +6104,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \n \t  if (sched_verbose >= 2)\n \t    {\n-\t      fprintf (sched_dump, \";;\\t\\tReady list after queue_to_ready:  \");\n+\t      fprintf (sched_dump, \";;\\t\\tReady list after queue_to_ready:\");\n \t      debug_ready_list (&ready);\n \t    }\n \t  advance -= clock_var - start_clock_var;\n@@ -6114,7 +6171,8 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \n \t      if (sched_verbose >= 2)\n \t\t{\n-\t\t  fprintf (sched_dump, \";;\\t\\tReady list after ready_sort:  \");\n+\t\t  fprintf (sched_dump,\n+\t\t\t   \";;\\t\\tReady list after ready_sort:    \");\n \t\t  debug_ready_list (&ready);\n \t\t}\n \t    }\n@@ -6503,14 +6561,21 @@ schedule_block (basic_block *target_bb, state_t init_state)\n       sched_extend_luids ();\n     }\n \n-  if (sched_verbose)\n-    fprintf (sched_dump, \";;   new head = %d\\n;;   new tail = %d\\n\\n\",\n-\t     INSN_UID (head), INSN_UID (tail));\n-\n   /* Update head/tail boundaries.  */\n   head = NEXT_INSN (prev_head);\n   tail = last_scheduled_insn;\n \n+  if (sched_verbose)\n+    {\n+      fprintf (sched_dump, \";;   new head = %d\\n;;   new tail = %d\\n\",\n+\t       INSN_UID (head), INSN_UID (tail));\n+\n+      if (sched_verbose >= 2)\n+\tdump_insn_stream (head, tail);\n+\n+      fprintf (sched_dump, \"\\n\");\n+    }\n+\n   head = restore_other_notes (head, NULL);\n \n   current_sched_info->head = head;"}]}