{"sha": "5deacf6058d1bc7261a75c9fd1f116c4442e9e60", "node_id": "C_kwDOANBUbNoAKDVkZWFjZjYwNThkMWJjNzI2MWE3NWM5ZmQxZjExNmM0NDQyZTllNjA", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-11-22T19:39:41Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-11-24T14:03:07Z"}, "message": "Directly resolve range_of_stmt dependencies.\n\nAll ranger API entries eventually call range_of_stmt to ensure there is an\ninitial global value to work with.  This can cause very deep call chains when\nsatisfied via the normal API.  Instead, push any dependencies onto a stack\nand evaluate them in a depth first manner, mirroring what would have happened\nvia the normal API calls.\n\n\tPR tree-optimization/103231\n\tgcc/\n\t* gimple-range.cc (gimple_ranger::gimple_ranger): Create stmt stack.\n\t(gimple_ranger::gimple_ranger): Delete stmt stack.\n\t(gimple_ranger::range_of_stmt): Process depenedencies if they have no\n\tglobal cache entry.\n\t(gimple_ranger::prefill_name): New.\n\t(gimple_ranger::prefill_stmt_dependencies): New.\n\t* gimple-range.h (class gimple_ranger): Add prototypes.", "tree": {"sha": "67b0f322e0f6a1dab9869f449fcf5be8e1aac7b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67b0f322e0f6a1dab9869f449fcf5be8e1aac7b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5deacf6058d1bc7261a75c9fd1f116c4442e9e60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5deacf6058d1bc7261a75c9fd1f116c4442e9e60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5deacf6058d1bc7261a75c9fd1f116c4442e9e60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5deacf6058d1bc7261a75c9fd1f116c4442e9e60/comments", "author": null, "committer": null, "parents": [{"sha": "d986ff50b4aad62c45d7ac62915e072643ddfca1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d986ff50b4aad62c45d7ac62915e072643ddfca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d986ff50b4aad62c45d7ac62915e072643ddfca1"}], "stats": {"total": 111, "additions": 109, "deletions": 2}, "files": [{"sha": "178a470a419bf508b22df885e311290ef96bc494", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 105, "deletions": 2, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deacf6058d1bc7261a75c9fd1f116c4442e9e60/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deacf6058d1bc7261a75c9fd1f116c4442e9e60/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=5deacf6058d1bc7261a75c9fd1f116c4442e9e60", "patch": "@@ -46,6 +46,9 @@ gimple_ranger::gimple_ranger () :\n   m_oracle = m_cache.oracle ();\n   if (dump_file && (param_ranger_debug & RANGER_DEBUG_TRACE))\n     tracer.enable_trace ();\n+  m_stmt_list.create (0);\n+  m_stmt_list.safe_grow (num_ssa_names);\n+  m_stmt_list.truncate (0);\n \n   // Ensure the not_executable flag is clear everywhere.\n   if (flag_checking)\n@@ -61,6 +64,11 @@ gimple_ranger::gimple_ranger () :\n     }\n }\n \n+gimple_ranger::~gimple_ranger ()\n+{\n+  m_stmt_list.release ();\n+}\n+\n bool\n gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n {\n@@ -284,17 +292,21 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n   else\n     {\n       bool current;\n-      // Check if the stmt has already been processed, and is not stale.\n+      // Check if the stmt has already been processed.\n       if (m_cache.get_global_range (r, name, current))\n \t{\n+\t  // If it isn't stale, use this cached value.\n \t  if (current)\n \t    {\n \t      if (idx)\n \t\ttracer.trailer (idx, \" cached\", true, name, r);\n \t      return true;\n \t    }\n \t}\n-      // Otherwise calculate a new value.\n+      else\n+\tprefill_stmt_dependencies (name);\n+\n+      // Calculate a new value.\n       int_range_max tmp;\n       fold_range_internal (tmp, s, name);\n \n@@ -311,6 +323,97 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n   return res;\n }\n \n+\n+// Check if NAME is a dependency that needs resolving, and push it on the\n+// stack if so.  R is a scratch range.\n+\n+inline void\n+gimple_ranger::prefill_name (irange &r, tree name)\n+{\n+  if (!gimple_range_ssa_p (name))\n+    return;\n+  gimple *stmt = SSA_NAME_DEF_STMT (name);\n+  if (!gimple_range_handler (stmt))\n+    return;\n+\n+  bool current;\n+  // If this op has not been processed yet, then push it on the stack\n+  if (!m_cache.get_global_range (r, name, current))\n+    m_stmt_list.safe_push (name);\n+}\n+\n+// This routine will seed the global cache with most of the depnedencies of\n+// NAME.  This prevents excessive call depth through the normal API.\n+\n+void\n+gimple_ranger::prefill_stmt_dependencies (tree ssa)\n+{\n+  if (SSA_NAME_IS_DEFAULT_DEF (ssa))\n+    return;\n+\n+  int_range_max r;\n+  unsigned idx;\n+  gimple *stmt = SSA_NAME_DEF_STMT (ssa);\n+  gcc_checking_assert (stmt && gimple_bb (stmt));\n+\n+  // Only pre-process range-ops.\n+  if (!gimple_range_handler (stmt))\n+    return;\n+\n+  // Mark where on the stack we are starting.\n+  unsigned start = m_stmt_list.length ();\n+  m_stmt_list.safe_push (ssa);\n+\n+  idx = tracer.header (\"ROS dependence fill\\n\");\n+\n+  // Loop until back at the start point.\n+  while (m_stmt_list.length () > start)\n+    {\n+      tree name = m_stmt_list.last ();\n+      // NULL is a marker which indicates the next name in the stack has now\n+      // been fully resolved, so we can fold it.\n+      if (!name)\n+\t{\n+\t  // Pop the NULL, then pop the name.\n+\t  m_stmt_list.pop ();\n+\t  name = m_stmt_list.pop ();\n+\t  // Don't fold initial request, it will be calculated upon return.\n+\t  if (m_stmt_list.length () > start)\n+\t    {\n+\t      // Fold and save the value for NAME.\n+\t      stmt = SSA_NAME_DEF_STMT (name);\n+\t      fold_range_internal (r, stmt, name);\n+\t      m_cache.set_global_range (name, r);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      // Add marker indicating previous NAME in list should be folded\n+      // when we get to this NULL.\n+      m_stmt_list.safe_push (NULL_TREE);\n+      stmt = SSA_NAME_DEF_STMT (name);\n+\n+      if (idx)\n+\t{\n+\t  tracer.print (idx, \"ROS dep fill (\");\n+\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t  fputs (\") at stmt \", dump_file);\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+\n+      gcc_checking_assert (gimple_range_handler (stmt));\n+      tree op = gimple_range_operand2 (stmt);\n+      if (op)\n+\tprefill_name (r, op);\n+      op = gimple_range_operand1 (stmt);\n+      if (op)\n+\tprefill_name (r, op);\n+    }\n+  if (idx)\n+    tracer.trailer (idx, \"ROS \", false, ssa, r);\n+}\n+\n+\n // This routine will invoke the gimple fold_stmt routine, providing context to\n // range_of_expr calls via an private interal API.\n "}, {"sha": "c2923c58b275f90c840ba0b8beda90f2bad258e9", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deacf6058d1bc7261a75c9fd1f116c4442e9e60/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deacf6058d1bc7261a75c9fd1f116c4442e9e60/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=5deacf6058d1bc7261a75c9fd1f116c4442e9e60", "patch": "@@ -47,6 +47,7 @@ class gimple_ranger : public range_query\n {\n public:\n   gimple_ranger ();\n+  ~gimple_ranger ();\n   virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL) OVERRIDE;\n   virtual bool range_of_expr (irange &r, tree name, gimple * = NULL) OVERRIDE;\n   virtual bool range_on_edge (irange &r, edge e, tree name) OVERRIDE;\n@@ -61,9 +62,12 @@ class gimple_ranger : public range_query\n   bool fold_stmt (gimple_stmt_iterator *gsi, tree (*) (tree));\n protected:\n   bool fold_range_internal (irange &r, gimple *s, tree name);\n+  void prefill_name (irange &r, tree name);\n+  void prefill_stmt_dependencies (tree ssa);\n   ranger_cache m_cache;\n   range_tracer tracer;\n   basic_block current_bb;\n+  vec<tree> m_stmt_list;\n };\n \n /* Create a new ranger instance and associate it with a function."}]}