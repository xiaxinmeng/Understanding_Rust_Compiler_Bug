{"sha": "f714ecf522782f76d7d9d9826fe1bcd23259cf24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxNGVjZjUyMjc4MmY3NmQ3ZDlkOTgyNmZlMWJjZDIzMjU5Y2YyNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-12-15T21:24:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-12-15T21:24:52Z"}, "message": "cgraph.h (cgraph_node): Add predicate prevailing_p.\n\n\n\t* cgraph.h (cgraph_node): Add predicate prevailing_p.\n\t(cgraph_edge): Add predicate possible_call_in_translation_unit_p.\n\t* ipa-prop.c (ipa_write_jump_function): Optimize streaming of ADDR_EXPR.\n\t(ipa_read_jump_function): Add prevails parameter; optimize streaming.\n\t(ipa_read_edge_info): Break out from ...\n\t(ipa_read_node_info): ... here; optimize streaming.\n\t* cgraph.c (cgraph_edge::possibly_call_in_translation_unit_p): New\n\tpredicate.\n\nFrom-SVN: r267175", "tree": {"sha": "cad3aa0fcf39b65a7a9442f8e128039691dc8f65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cad3aa0fcf39b65a7a9442f8e128039691dc8f65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f714ecf522782f76d7d9d9826fe1bcd23259cf24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f714ecf522782f76d7d9d9826fe1bcd23259cf24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f714ecf522782f76d7d9d9826fe1bcd23259cf24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f714ecf522782f76d7d9d9826fe1bcd23259cf24/comments", "author": null, "committer": null, "parents": [{"sha": "6263c29d28abb099cb835ca373aa234ef36df6a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6263c29d28abb099cb835ca373aa234ef36df6a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6263c29d28abb099cb835ca373aa234ef36df6a2"}], "stats": {"total": 253, "additions": 166, "deletions": 87}, "files": [{"sha": "f95477fae6346c552c206badf8d5e6751cb6e67d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f714ecf522782f76d7d9d9826fe1bcd23259cf24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f714ecf522782f76d7d9d9826fe1bcd23259cf24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f714ecf522782f76d7d9d9826fe1bcd23259cf24", "patch": "@@ -1,3 +1,14 @@\n+2018-12-15  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.h (cgraph_node): Add predicate prevailing_p.\n+\t(cgraph_edge): Add predicate possible_call_in_translation_unit_p.\n+\t* ipa-prop.c (ipa_write_jump_function): Optimize streaming of ADDR_EXPR.\n+\t(ipa_read_jump_function): Add prevails parameter; optimize streaming.\n+\t(ipa_read_edge_info): Break out from ...\n+\t(ipa_read_node_info): ... here; optimize streaming.\n+\t* cgraph.c (cgraph_edge::possibly_call_in_translation_unit_p): New\n+\tpredicate.\n+\n 2018-12-15  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-utils.c (ipa_merge_profiles): Do no merging when source function"}, {"sha": "850a9b62469a15a89c4c02f37bd616e34f1674a7", "filename": "gcc/cgraph.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f714ecf522782f76d7d9d9826fe1bcd23259cf24/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f714ecf522782f76d7d9d9826fe1bcd23259cf24/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=f714ecf522782f76d7d9d9826fe1bcd23259cf24", "patch": "@@ -3766,6 +3766,41 @@ cgraph_edge::sreal_frequency ()\n \t\t\t       : caller->count);\n }\n \n+\n+/* During LTO stream in this can be used to check whether call can possibly\n+   be internal to the current translation unit.  */\n+\n+bool\n+cgraph_edge::possibly_call_in_translation_unit_p (void)\n+{\n+  gcc_checking_assert (in_lto_p && caller->prevailing_p ());\n+\n+  /* While incremental linking we may end up getting function body later.  */\n+  if (flag_incremental_link == INCREMENTAL_LINK_LTO)\n+    return true;\n+\n+  /* We may be smarter here and avoid stremaing in indirect calls we can't\n+     track, but that would require arranging stremaing the indirect call\n+     summary first.  */\n+  if (!callee)\n+    return true;\n+\n+  /* If calle is local to the original translation unit, it will be defined.  */\n+  if (!TREE_PUBLIC (callee->decl) && !DECL_EXTERNAL (callee->decl))\n+    return true;\n+\n+  /* Otherwise we need to lookup prevailing symbol (symbol table is not merged,\n+     yet) and see if it is a definition.  In fact we may also resolve aliases,\n+     but that is probably not too important.  */\n+  symtab_node *node = callee;\n+  for (int n = 10; node->previous_sharing_asm_name && n ; n--)\n+    node = node->previous_sharing_asm_name;\n+  if (node->previous_sharing_asm_name)\n+    node = symtab_node::get_for_asmname (DECL_ASSEMBLER_NAME (callee->decl));\n+  gcc_assert (TREE_PUBLIC (node->decl));\n+  return node->get_availability () >= AVAIL_AVAILABLE;\n+}\n+\n /* A stashed copy of \"symtab\" for use by selftest::symbol_table_test.\n    This needs to be a global so that it can be a GC root, and thus\n    prevent the stashed copy from being garbage-collected if the GC runs"}, {"sha": "51cea066ad35bb3eda571184879cb3ff27b040e9", "filename": "gcc/cgraph.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f714ecf522782f76d7d9d9826fe1bcd23259cf24/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f714ecf522782f76d7d9d9826fe1bcd23259cf24/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=f714ecf522782f76d7d9d9826fe1bcd23259cf24", "patch": "@@ -308,6 +308,10 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Return availability of NODE when referenced from REF.  */\n   enum availability get_availability (symtab_node *ref = NULL);\n \n+  /* During LTO stream-in this predicate can be used to check whether node\n+     in question prevails in the linking to save some memory usage.  */\n+  bool prevailing_p (void);\n+\n   /* Return true if NODE binds to current definition in final executable\n      when referenced from REF.  If REF is NULL return conservative value\n      for any reference.  */\n@@ -1730,6 +1734,10 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n      after passes that don't update the cgraph.  */\n   static void rebuild_references (void);\n \n+  /* During LTO stream in this can be used to check whether call can possibly\n+     be internal to the current translation unit.  */\n+  bool possibly_call_in_translation_unit_p (void);\n+\n   /* Expected number of executions: calculated in profile.c.  */\n   profile_count count;\n   cgraph_node *caller;\n@@ -3357,6 +3365,15 @@ xstrdup_for_dump (const char *transient_str)\n   return ggc_strdup (transient_str);\n }\n \n+/* During LTO stream-in this predicate can be used to check whether node\n+   in question prevails in the linking to save some memory usage.  */\n+inline bool\n+symtab_node::prevailing_p (void)\n+{\n+  return definition && ((!TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl))\n+\t\t\t || previous_sharing_asm_name == NULL);\n+}\n+\n extern GTY(()) symbol_table *saved_symtab;\n \n #if CHECKING_P"}, {"sha": "05e666e05882e9b590a419da3c39abbaf327129d", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 103, "deletions": 87, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f714ecf522782f76d7d9d9826fe1bcd23259cf24/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f714ecf522782f76d7d9d9826fe1bcd23259cf24/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f714ecf522782f76d7d9d9826fe1bcd23259cf24", "patch": "@@ -4053,16 +4053,26 @@ ipa_write_jump_function (struct output_block *ob,\n   struct ipa_agg_jf_item *item;\n   struct bitpack_d bp;\n   int i, count;\n+  int flag = 0;\n \n-  streamer_write_uhwi (ob, jump_func->type);\n+  /* ADDR_EXPRs are very comon IP invariants; save some streamer data\n+     as well as WPA memory by handling them specially.  */\n+  if (jump_func->type == IPA_JF_CONST\n+      && TREE_CODE (jump_func->value.constant.value) == ADDR_EXPR)\n+    flag = 1;\n+\n+  streamer_write_uhwi (ob, jump_func->type * 2 + flag);\n   switch (jump_func->type)\n     {\n     case IPA_JF_UNKNOWN:\n       break;\n     case IPA_JF_CONST:\n       gcc_assert (\n \t  EXPR_LOCATION (jump_func->value.constant.value) == UNKNOWN_LOCATION);\n-      stream_write_tree (ob, jump_func->value.constant.value, true);\n+      stream_write_tree (ob,\n+\t\t\t flag\n+\t\t\t ? TREE_OPERAND (jump_func->value.constant.value, 0)\n+\t\t\t : jump_func->value.constant.value, true);\n       break;\n     case IPA_JF_PASS_THROUGH:\n       streamer_write_uhwi (ob, jump_func->value.pass_through.operation);\n@@ -4131,20 +4141,28 @@ static void\n ipa_read_jump_function (struct lto_input_block *ib,\n \t\t\tstruct ipa_jump_func *jump_func,\n \t\t\tstruct cgraph_edge *cs,\n-\t\t\tstruct data_in *data_in)\n+\t\t\tstruct data_in *data_in,\n+\t\t\tbool prevails)\n {\n   enum jump_func_type jftype;\n   enum tree_code operation;\n   int i, count;\n+  int val = streamer_read_uhwi (ib);\n+  bool flag = val & 1;\n \n-  jftype = (enum jump_func_type) streamer_read_uhwi (ib);\n+  jftype = (enum jump_func_type) (val / 2);\n   switch (jftype)\n     {\n     case IPA_JF_UNKNOWN:\n       ipa_set_jf_unknown (jump_func);\n       break;\n     case IPA_JF_CONST:\n-      ipa_set_jf_constant (jump_func, stream_read_tree (ib, data_in), cs);\n+      {\n+\ttree t = stream_read_tree (ib, data_in);\n+\tif (flag && prevails)\n+\t  t = build_fold_addr_expr (t);\n+\tipa_set_jf_constant (jump_func, t, cs);\n+      }\n       break;\n     case IPA_JF_PASS_THROUGH:\n       operation = (enum tree_code) streamer_read_uhwi (ib);\n@@ -4177,10 +4195,13 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \tipa_set_ancestor_jf (jump_func, offset, formal_id, agg_preserved);\n \tbreak;\n       }\n+    default:\n+      fatal_error (UNKNOWN_LOCATION, \"invalid jump function in LTO stream\");\n     }\n \n   count = streamer_read_uhwi (ib);\n-  vec_alloc (jump_func->agg.items, count);\n+  if (prevails)\n+    vec_alloc (jump_func->agg.items, count);\n   if (count)\n     {\n       struct bitpack_d bp = streamer_read_bitpack (ib);\n@@ -4191,7 +4212,8 @@ ipa_read_jump_function (struct lto_input_block *ib,\n       struct ipa_agg_jf_item item;\n       item.offset = streamer_read_uhwi (ib);\n       item.value = stream_read_tree (ib, data_in);\n-      jump_func->agg.items->quick_push (item);\n+      if (prevails)\n+        jump_func->agg.items->quick_push (item);\n     }\n \n   struct bitpack_d bp = streamer_read_bitpack (ib);\n@@ -4200,7 +4222,8 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     {\n       widest_int value = streamer_read_widest_int (ib);\n       widest_int mask = streamer_read_widest_int (ib);\n-      ipa_set_jfunc_bits (jump_func, value, mask);\n+      if (prevails)\n+        ipa_set_jfunc_bits (jump_func, value, mask);\n     }\n   else\n     jump_func->bits = NULL;\n@@ -4213,7 +4236,8 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \t\t\t\t\t\t       VR_LAST);\n       tree min = stream_read_tree (ib, data_in);\n       tree max = stream_read_tree (ib, data_in);\n-      ipa_set_jfunc_vr (jump_func, type, min, max);\n+      if (prevails)\n+        ipa_set_jfunc_vr (jump_func, type, min, max);\n     }\n   else\n     jump_func->m_vr = NULL;\n@@ -4345,24 +4369,48 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     }\n }\n \n-/* If jump functions points to node we possibly can propagate into.\n-   At this moment symbol table is still not merged, but the prevailing\n-   symbol is always first in the list.  */\n+/* Stream in edge E from IB.  */\n \n-static bool\n-jump_function_useful_p (symtab_node *node)\n+static void\n+ipa_read_edge_info (struct lto_input_block *ib,\n+\t\t    struct data_in *data_in,\n+\t\t    struct cgraph_edge *e, bool prevails)\n {\n-  /* While incremental linking we may end up getting function body later.  */\n-  if (flag_incremental_link == INCREMENTAL_LINK_LTO)\n-    return true;\n-  if (!TREE_PUBLIC (node->decl) && !DECL_EXTERNAL (node->decl))\n-    return true;\n-  for (int n = 10; node->previous_sharing_asm_name && n ; n--)\n-    node = node->previous_sharing_asm_name;\n-  if (node->previous_sharing_asm_name)\n-    node = symtab_node::get_for_asmname (DECL_ASSEMBLER_NAME (node->decl));\n-  gcc_assert (TREE_PUBLIC (node->decl));\n-  return node->definition;\n+  int count = streamer_read_uhwi (ib);\n+  bool contexts_computed = count & 1;\n+\n+  count /= 2;\n+  if (!count)\n+    return;\n+  if (prevails && e->possibly_call_in_translation_unit_p ())\n+    {\n+      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+      vec_safe_grow_cleared (args->jump_functions, count);\n+      if (contexts_computed)\n+\tvec_safe_grow_cleared (args->polymorphic_call_contexts, count);\n+      for (int k = 0; k < count; k++)\n+\t{\n+\t  ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n+\t\t\t\t  data_in, prevails);\n+\t  if (contexts_computed)\n+\t    ipa_get_ith_polymorhic_call_context (args, k)->stream_in\n+\t\t\t\t\t\t\t     (ib, data_in);\n+\t}\n+    }\n+  else\n+    {\n+      for (int k = 0; k < count; k++)\n+\t{\n+\t  struct ipa_jump_func dummy;\n+\t  ipa_read_jump_function (ib, &dummy, e,\n+\t\t\t\t  data_in, prevails);\n+\t  if (contexts_computed)\n+\t    {\n+\t      struct ipa_polymorphic_call_context ctx;\n+\t      ctx.stream_in (ib, data_in);\n+\t    }\n+\t}\n+    }\n }\n \n /* Stream in NODE info from IB.  */\n@@ -4371,82 +4419,50 @@ static void\n ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n \t\t    struct data_in *data_in)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n   int k;\n   struct cgraph_edge *e;\n   struct bitpack_d bp;\n-\n-  ipa_alloc_node_params (node, streamer_read_uhwi (ib));\n-\n-  for (k = 0; k < ipa_get_param_count (info); k++)\n-    (*info->descriptors)[k].move_cost = streamer_read_uhwi (ib);\n+  bool prevails = node->prevailing_p ();\n+  struct ipa_node_params *info = prevails ? IPA_NODE_REF (node) : NULL;\n+\n+  int param_count = streamer_read_uhwi (ib);\n+  if (prevails)\n+    {\n+      ipa_alloc_node_params (node, param_count);\n+      for (k = 0; k < param_count; k++)\n+        (*info->descriptors)[k].move_cost = streamer_read_uhwi (ib);\n+      if (ipa_get_param_count (info) != 0)\n+\tinfo->analysis_done = true;\n+      info->node_enqueued = false;\n+    }\n+  else\n+    for (k = 0; k < param_count; k++)\n+      streamer_read_uhwi (ib);\n \n   bp = streamer_read_bitpack (ib);\n-  if (ipa_get_param_count (info) != 0)\n-    info->analysis_done = true;\n-  info->node_enqueued = false;\n-  for (k = 0; k < ipa_get_param_count (info); k++)\n-    ipa_set_param_used (info, k, bp_unpack_value (&bp, 1));\n-  for (k = 0; k < ipa_get_param_count (info); k++)\n+  for (k = 0; k < param_count; k++)\n     {\n-      ipa_set_controlled_uses (info, k, streamer_read_hwi (ib));\n-      (*info->descriptors)[k].decl_or_type = stream_read_tree (ib, data_in);\n+      bool used = bp_unpack_value (&bp, 1);\n+\n+      if (prevails)\n+        ipa_set_param_used (info, k, used);\n     }\n-  for (e = node->callees; e; e = e->next_callee)\n+  for (k = 0; k < param_count; k++)\n     {\n-      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n-      int count = streamer_read_uhwi (ib);\n-      bool contexts_computed = count & 1;\n-      count /= 2;\n-\n-      if (!count)\n-\tcontinue;\n-      if (!jump_function_useful_p (e->callee))\n-\t{\n-          for (k = 0; k < count; k++)\n-\t    {\n-\t      struct ipa_jump_func dummy;\n-\t      ipa_read_jump_function (ib, &dummy, e, data_in);\n-\t      if (contexts_computed)\n-\t\t{\n-\t\t  struct ipa_polymorphic_call_context ctx;\n-\t\t  ctx.stream_in (ib, data_in);\n-\t\t}\n-\t    }\n-\t  continue;\n-\t}\n-      vec_safe_grow_cleared (args->jump_functions, count);\n-      if (contexts_computed)\n-\tvec_safe_grow_cleared (args->polymorphic_call_contexts, count);\n+      int nuses = streamer_read_hwi (ib);\n+      tree type = stream_read_tree (ib, data_in);\n \n-      for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n+      if (prevails)\n \t{\n-\t  ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n-\t\t\t\t  data_in);\n-\t  if (contexts_computed)\n-\t    ipa_get_ith_polymorhic_call_context (args, k)->stream_in (ib, data_in);\n+\t  ipa_set_controlled_uses (info, k, nuses);\n+\t  (*info->descriptors)[k].decl_or_type = type;\n \t}\n     }\n+  for (e = node->callees; e; e = e->next_callee)\n+    ipa_read_edge_info (ib, data_in, e, prevails);\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n-      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n-      int count = streamer_read_uhwi (ib);\n-      bool contexts_computed = count & 1;\n-      count /= 2;\n-\n-      if (count)\n-\t{\n-\t  vec_safe_grow_cleared (args->jump_functions, count);\n-\t  if (contexts_computed)\n-\t    vec_safe_grow_cleared (args->polymorphic_call_contexts, count);\n-          for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n-\t    {\n-\t      ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n-\t\t\t\t      data_in);\n-\t      if (contexts_computed)\n-\t\tipa_get_ith_polymorhic_call_context (args, k)->stream_in (ib, data_in);\n-\t    }\n-\t}\n+      ipa_read_edge_info (ib, data_in, e, prevails);\n       ipa_read_indirect_edge_info (ib, data_in, e);\n     }\n }"}]}