{"sha": "29ebe69a723a07771383e4cddc917521ee6e82bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjllYmU2OWE3MjNhMDc3NzEzODNlNGNkZGM5MTc1MjFlZTZlODJiZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-02T11:03:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-02T11:03:52Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r666", "tree": {"sha": "672b626b63ce454b1ae9629f4e26a65581e0e2f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/672b626b63ce454b1ae9629f4e26a65581e0e2f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29ebe69a723a07771383e4cddc917521ee6e82bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ebe69a723a07771383e4cddc917521ee6e82bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ebe69a723a07771383e4cddc917521ee6e82bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ebe69a723a07771383e4cddc917521ee6e82bd/comments", "author": null, "committer": null, "parents": [{"sha": "d64be5ecc9c27800b5e6cf09ec50a1e1ad1d5d2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64be5ecc9c27800b5e6cf09ec50a1e1ad1d5d2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d64be5ecc9c27800b5e6cf09ec50a1e1ad1d5d2a"}], "stats": {"total": 28, "additions": 21, "deletions": 7}, "files": [{"sha": "fab7300650f1cdd51366d61f81a1f75bb1bacebf", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ebe69a723a07771383e4cddc917521ee6e82bd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ebe69a723a07771383e4cddc917521ee6e82bd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=29ebe69a723a07771383e4cddc917521ee6e82bd", "patch": "@@ -3680,7 +3680,7 @@ fold (expr)\n \t  /* If this is A != 0 ? A : 0, this is simply A.  For ==, it is\n \t     always zero.  */\n \n-\t  if (integer_zerop (arg2))\n+\t  if (integer_zerop (TREE_OPERAND (arg0, 1)) && integer_zerop (arg2))\n \t    {\n \t      if (comp_code == NE_EXPR)\n \t\treturn arg1;"}, {"sha": "a9524a185366509d54294e88ab4e1893eea4047f", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ebe69a723a07771383e4cddc917521ee6e82bd/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ebe69a723a07771383e4cddc917521ee6e82bd/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=29ebe69a723a07771383e4cddc917521ee6e82bd", "patch": "@@ -396,7 +396,7 @@ attr_rtx (va_alist)\n     {\n       rtx arg0 = va_arg (p, rtx);\n \n-      hashcode = (code + RTL_HASH (arg0));\n+      hashcode = ((int) code + RTL_HASH (arg0));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n \t    && GET_CODE (h->u.rtl) == code\n@@ -416,7 +416,7 @@ attr_rtx (va_alist)\n       rtx arg0 = va_arg (p, rtx);\n       rtx arg1 = va_arg (p, rtx);\n \n-      hashcode = (code + RTL_HASH (arg0) + RTL_HASH (arg1));\n+      hashcode = ((int) code + RTL_HASH (arg0) + RTL_HASH (arg1));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n \t    && GET_CODE (h->u.rtl) == code\n@@ -436,7 +436,7 @@ attr_rtx (va_alist)\n     {\n       char * arg0 = va_arg (p, char *);\n \n-      hashcode = (code + RTL_HASH (arg0));\n+      hashcode = ((int) code + RTL_HASH (arg0));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n \t    && GET_CODE (h->u.rtl) == code\n@@ -456,7 +456,7 @@ attr_rtx (va_alist)\n       char * arg0 = va_arg (p, char *);\n       char * arg1 = va_arg (p, char *);\n \n-      hashcode = (code + RTL_HASH (arg0) + RTL_HASH (arg1));\n+      hashcode = ((int) code + RTL_HASH (arg0) + RTL_HASH (arg1));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n \t    && GET_CODE (h->u.rtl) == code"}, {"sha": "c345fc9d294fd8b2d9ae6033e17b39a37f4ffdd8", "filename": "gcc/optabs.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ebe69a723a07771383e4cddc917521ee6e82bd/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ebe69a723a07771383e4cddc917521ee6e82bd/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=29ebe69a723a07771383e4cddc917521ee6e82bd", "patch": "@@ -1315,6 +1315,16 @@ emit_no_conflict_block (insns, target, op0, op1, equiv)\n    an insn to move RESULT to TARGET.  This last insn will have a REQ_EQUAL\n    note with an operand of EQUIV.\n \n+   Moving assignments to pseudos outside of the block is done to improve\n+   the generated code, but is not required to generate correct code,\n+   hence being unable to move an assignment is not grounds for not making\n+   a libcall block.  There are two reasons why it is safe to leave these\n+   insns inside the block: First, we know that these pseudos cannot be\n+   used in generated RTL outside the block since they are created for\n+   temporary purposes within the block.  Second, CSE will not record the\n+   values of anything set inside a libcall block, so we know they must\n+   be dead at the end of the block.\n+\n    Except for the first group of insns (the ones setting pseudos), the\n    block is delimited by REG_RETVAL and REG_LIBCALL notes.  */\n \n@@ -1328,7 +1338,9 @@ emit_libcall_block (insns, target, result, equiv)\n   rtx prev, next, first, last, insn;\n \n   /* First emit all insns that set pseudos.  Remove them from the list as\n-     we go.  */\n+     we go.  Avoid insns that set pseudo which were referenced in previous\n+     insns.  These can be generated by move_by_pieces, for example,\n+     to update an address.  */\n \n   for (insn = insns; insn; insn = next)\n     {\n@@ -1337,7 +1349,9 @@ emit_libcall_block (insns, target, result, equiv)\n       next = NEXT_INSN (insn);\n \n       if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n-\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n+\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t  && ! reg_mentioned_p (SET_DEST (set), PATTERN (insns))\n+\t  && ! reg_used_between_p (SET_DEST (set), insns, insn))\n \t{\n \t  if (PREV_INSN (insn))\n \t    NEXT_INSN (PREV_INSN (insn)) = next;"}]}