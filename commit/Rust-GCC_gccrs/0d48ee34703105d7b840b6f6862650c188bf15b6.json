{"sha": "0d48ee34703105d7b840b6f6862650c188bf15b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ0OGVlMzQ3MDMxMDVkN2I4NDBiNmY2ODYyNjUwYzE4OGJmMTViNg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-06-06T13:26:24Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-06-06T13:26:24Z"}, "message": "ipa-prop.c (get_place_in_agg_contents_list): New function.\n\n2014-06-06  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.c (get_place_in_agg_contents_list): New function.\n\t(build_agg_jump_func_from_list): Likewise.\n\t(determine_known_aggregate_parts): Renamed to\n\tdetermine_locally_known_aggregate_parts.  Moved some functionality\n\tto the two functions above, removed bound checks.\n\nFrom-SVN: r211315", "tree": {"sha": "0009545635dddfe4dc9b2c6e5b1ce5219e0bc0d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0009545635dddfe4dc9b2c6e5b1ce5219e0bc0d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d48ee34703105d7b840b6f6862650c188bf15b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d48ee34703105d7b840b6f6862650c188bf15b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d48ee34703105d7b840b6f6862650c188bf15b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d48ee34703105d7b840b6f6862650c188bf15b6/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2c75eea66fb579de806cb2b3a85cb26d8b792db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c75eea66fb579de806cb2b3a85cb26d8b792db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c75eea66fb579de806cb2b3a85cb26d8b792db"}], "stats": {"total": 134, "additions": 80, "deletions": 54}, "files": [{"sha": "32e0c5642a95f954f69b53d33583756b54d508dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d48ee34703105d7b840b6f6862650c188bf15b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d48ee34703105d7b840b6f6862650c188bf15b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d48ee34703105d7b840b6f6862650c188bf15b6", "patch": "@@ -1,3 +1,11 @@\n+2014-06-06  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.c (get_place_in_agg_contents_list): New function.\n+\t(build_agg_jump_func_from_list): Likewise.\n+\t(determine_known_aggregate_parts): Renamed to\n+\tdetermine_locally_known_aggregate_parts.  Moved some functionality\n+\tto the two functions above, removed bound checks.\n+\n 2014-06-06  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_expand_movmem): New."}, {"sha": "d02093a00f4a6b94940f116f7e3691de1b83b48c", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d48ee34703105d7b840b6f6862650c188bf15b6/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d48ee34703105d7b840b6f6862650c188bf15b6/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=0d48ee34703105d7b840b6f6862650c188bf15b6", "patch": "@@ -1495,14 +1495,72 @@ struct ipa_known_agg_contents_list\n   struct ipa_known_agg_contents_list *next;\n };\n \n+/* Find the proper place in linked list of ipa_known_agg_contents_list\n+   structures where to put a new one with the given LHS_OFFSET and LHS_SIZE,\n+   unless there is a partial overlap, in which case return NULL, or such\n+   element is already there, in which case set *ALREADY_THERE to true.  */\n+\n+static struct ipa_known_agg_contents_list **\n+get_place_in_agg_contents_list (struct ipa_known_agg_contents_list **list,\n+\t\t\t\tHOST_WIDE_INT lhs_offset,\n+\t\t\t\tHOST_WIDE_INT lhs_size,\n+\t\t\t\tbool *already_there)\n+{\n+  struct ipa_known_agg_contents_list **p = list;\n+  while (*p && (*p)->offset < lhs_offset)\n+    {\n+      if ((*p)->offset + (*p)->size > lhs_offset)\n+\treturn NULL;\n+      p = &(*p)->next;\n+    }\n+\n+  if (*p && (*p)->offset < lhs_offset + lhs_size)\n+    {\n+      if ((*p)->offset == lhs_offset && (*p)->size == lhs_size)\n+\t/* We already know this value is subsequently overwritten with\n+\t   something else.  */\n+\t*already_there = true;\n+      else\n+\t/* Otherwise this is a partial overlap which we cannot\n+\t   represent.  */\n+\treturn NULL;\n+    }\n+  return p;\n+}\n+\n+/* Build aggregate jump function from LIST, assuming there are exactly\n+   CONST_COUNT constant entries there and that th offset of the passed argument\n+   is ARG_OFFSET and store it into JFUNC.  */\n+\n+static void\n+build_agg_jump_func_from_list (struct ipa_known_agg_contents_list *list,\n+\t\t\t       int const_count, HOST_WIDE_INT arg_offset,\n+\t\t\t       struct ipa_jump_func *jfunc)\n+{\n+  vec_alloc (jfunc->agg.items, const_count);\n+  while (list)\n+    {\n+      if (list->constant)\n+\t{\n+\t  struct ipa_agg_jf_item item;\n+\t  item.offset = list->offset - arg_offset;\n+\t  gcc_assert ((item.offset % BITS_PER_UNIT) == 0);\n+\t  item.value = unshare_expr_without_location (list->constant);\n+\t  jfunc->agg.items->quick_push (item);\n+\t}\n+      list = list->next;\n+    }\n+}\n+\n /* Traverse statements from CALL backwards, scanning whether an aggregate given\n    in ARG is filled in with constant values.  ARG can either be an aggregate\n-   expression or a pointer to an aggregate.  ARG_TYPE is the type of the aggregate.\n-   JFUNC is the jump function into which the constants are subsequently stored.  */\n+   expression or a pointer to an aggregate.  ARG_TYPE is the type of the\n+   aggregate.  JFUNC is the jump function into which the constants are\n+   subsequently stored.  */\n \n static void\n-determine_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n-\t\t\t\t struct ipa_jump_func *jfunc)\n+determine_locally_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n+\t\t\t\t\t struct ipa_jump_func *jfunc)\n {\n   struct ipa_known_agg_contents_list *list = NULL;\n   int item_count = 0, const_count = 0;\n@@ -1544,10 +1602,8 @@ determine_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n \t    return;\n \t  if (DECL_P (arg_base))\n \t    {\n-\t      tree size;\n \t      check_ref = false;\n-\t      size = build_int_cst (integer_type_node, arg_size);\n-\t      ao_ref_init_from_ptr_and_size (&r, arg_base, size);\n+\t      ao_ref_init (&r, arg_base);\n \t    }\n \t  else\n \t    return;\n@@ -1585,7 +1641,6 @@ determine_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n       gimple stmt = gsi_stmt (gsi);\n       HOST_WIDE_INT lhs_offset, lhs_size, lhs_max_size;\n       tree lhs, rhs, lhs_base;\n-      bool partial_overlap;\n \n       if (!stmt_may_clobber_ref_p_1 (stmt, &r))\n \tcontinue;\n@@ -1602,11 +1657,7 @@ determine_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n       lhs_base = get_ref_base_and_extent (lhs, &lhs_offset, &lhs_size,\n \t\t\t\t\t  &lhs_max_size);\n       if (lhs_max_size == -1\n-\t  || lhs_max_size != lhs_size\n-\t  || (lhs_offset < arg_offset\n-\t      && lhs_offset + lhs_size > arg_offset)\n-\t  || (lhs_offset < arg_offset + arg_size\n-\t      && lhs_offset + lhs_size > arg_offset + arg_size))\n+\t  || lhs_max_size != lhs_size)\n \tbreak;\n \n       if (check_ref)\n@@ -1624,34 +1675,13 @@ determine_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n \t    break;\n \t}\n \n-      if (lhs_offset + lhs_size < arg_offset\n-\t  || lhs_offset >= (arg_offset + arg_size))\n-\tcontinue;\n-\n-      partial_overlap = false;\n-      p = &list;\n-      while (*p && (*p)->offset < lhs_offset)\n-\t{\n-\t  if ((*p)->offset + (*p)->size > lhs_offset)\n-\t    {\n-\t      partial_overlap = true;\n-\t      break;\n-\t    }\n-\t  p = &(*p)->next;\n-\t}\n-      if (partial_overlap)\n+      bool already_there = false;\n+      p = get_place_in_agg_contents_list (&list, lhs_offset, lhs_size,\n+\t\t\t\t\t  &already_there);\n+      if (!p)\n \tbreak;\n-      if (*p && (*p)->offset < lhs_offset + lhs_size)\n-\t{\n-\t  if ((*p)->offset == lhs_offset && (*p)->size == lhs_size)\n-\t    /* We already know this value is subsequently overwritten with\n-\t       something else.  */\n-\t    continue;\n-\t  else\n-\t    /* Otherwise this is a partial overlap which we cannot\n-\t       represent.  */\n-\t    break;\n-\t}\n+      if (already_there)\n+\tcontinue;\n \n       rhs = get_ssa_def_if_simple_copy (rhs);\n       n = XALLOCA (struct ipa_known_agg_contents_list);\n@@ -1680,19 +1710,7 @@ determine_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n   if (const_count)\n     {\n       jfunc->agg.by_ref = by_ref;\n-      vec_alloc (jfunc->agg.items, const_count);\n-      while (list)\n-\t{\n-\t  if (list->constant)\n-\t    {\n-\t      struct ipa_agg_jf_item item;\n-\t      item.offset = list->offset - arg_offset;\n-\t      gcc_assert ((item.offset % BITS_PER_UNIT) == 0);\n-\t      item.value = unshare_expr_without_location (list->constant);\n-\t      jfunc->agg.items->quick_push (item);\n-\t    }\n-\t  list = list->next;\n-\t}\n+      build_agg_jump_func_from_list (list, const_count, arg_offset, jfunc);\n     }\n }\n \n@@ -1824,7 +1842,7 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n \t      || !ipa_get_jf_ancestor_agg_preserved (jfunc))\n \t  && (AGGREGATE_TYPE_P (TREE_TYPE (arg))\n \t      || POINTER_TYPE_P (param_type)))\n-\tdetermine_known_aggregate_parts (call, arg, param_type, jfunc);\n+\tdetermine_locally_known_aggregate_parts (call, arg, param_type, jfunc);\n     }\n }\n "}]}