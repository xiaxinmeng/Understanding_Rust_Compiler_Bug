{"sha": "d79d6252758099b8424434df6227c8beaea68608", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc5ZDYyNTI3NTgwOTliODQyNDQzNGRmNjIyN2M4YmVhZWE2ODYwOA==", "commit": {"author": {"name": "Tim Shen", "email": "timshen@google.com", "date": "2016-08-22T19:50:15Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2016-08-22T19:50:15Z"}, "message": "Split _M_dfs() into smaller functions.\n\n\t* regex_executor.h(_M_handle_repeat, _M_handle_subexpr_begin)\n\t(_M_handle_subexpr_end, _M_handle_line_begin_assertion)\n\t(_M_handle_line_end_assertion, _M_handle_word_boundary)\n\t(_M_handle_subexpr_lookahead, _M_handle_match)\n\t(_M_handle_backref, _M_handle_accept, _M_handle_alternative):\n\tAdd separate function declarations.\n\t* regex_executor.tcc: Split _M_dfs() into multiple handler functions.\n\nFrom-SVN: r239673", "tree": {"sha": "f8e70751d86d115529988fce787e1dbc13abc70a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8e70751d86d115529988fce787e1dbc13abc70a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d79d6252758099b8424434df6227c8beaea68608", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79d6252758099b8424434df6227c8beaea68608", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79d6252758099b8424434df6227c8beaea68608", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79d6252758099b8424434df6227c8beaea68608/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bef18c6382e3d0e610a73e05a400058fb0c7ac5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef18c6382e3d0e610a73e05a400058fb0c7ac5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef18c6382e3d0e610a73e05a400058fb0c7ac5c"}], "stats": {"total": 496, "additions": 311, "deletions": 185}, "files": [{"sha": "2e88e398b2ab5b4f88ac77ce88e0c06e84903add", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79d6252758099b8424434df6227c8beaea68608/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79d6252758099b8424434df6227c8beaea68608/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d79d6252758099b8424434df6227c8beaea68608", "patch": "@@ -1,3 +1,14 @@\n+2016-08-22  Tim Shen  <timshen@google.com>\n+\n+\tSplit _M_dfs() into smaller functions.\n+\t* regex_executor.h(_M_handle_repeat, _M_handle_subexpr_begin)\n+\t(_M_handle_subexpr_end, _M_handle_line_begin_assertion)\n+\t(_M_handle_line_end_assertion, _M_handle_word_boundary)\n+\t(_M_handle_subexpr_lookahead, _M_handle_match)\n+\t(_M_handle_backref, _M_handle_accept, _M_handle_alternative):\n+\tAdd separate function declarations.\n+\t* regex_executor.tcc: Split _M_dfs() into multiple handler functions.\n+\n 2016-08-22  Gleb Natapov  <gleb@scylladb.com>\n \n \tPR libstdc++/68297"}, {"sha": "33a68dd375b1975654c6d76ac80a2881b1fa25fc", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79d6252758099b8424434df6227c8beaea68608/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79d6252758099b8424434df6227c8beaea68608/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=d79d6252758099b8424434df6227c8beaea68608", "patch": "@@ -108,6 +108,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_rep_once_more(_Match_mode __match_mode, _StateIdT);\n \n+      void\n+      _M_handle_repeat(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_subexpr_begin(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_subexpr_end(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_line_begin_assertion(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_line_end_assertion(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_word_boundary(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_subexpr_lookahead(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_match(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_backref(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_accept(_Match_mode, _StateIdT);\n+\n+      void\n+      _M_handle_alternative(_Match_mode, _StateIdT);\n+\n       void\n       _M_dfs(_Match_mode __match_mode, _StateIdT __start);\n "}, {"sha": "382909f1cccb09815bd30c3b2954174fbae9d59c", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 267, "deletions": 185, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79d6252758099b8424434df6227c8beaea68608/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79d6252758099b8424434df6227c8beaea68608/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=d79d6252758099b8424434df6227c8beaea68608", "patch": "@@ -195,213 +195,295 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     };\n \n+  // _M_alt branch is \"match once more\", while _M_next is \"get me out\n+  // of this quantifier\". Executing _M_next first or _M_alt first don't\n+  // mean the same thing, and we need to choose the correct order under\n+  // given greedy mode.\n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n \t   bool __dfs_mode>\n     void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n-    _M_dfs(_Match_mode __match_mode, _StateIdT __i)\n+    _M_handle_repeat(_Match_mode __match_mode, _StateIdT __i)\n     {\n-      if (_M_states._M_visited(__i))\n-\treturn;\n-\n       const auto& __state = _M_nfa[__i];\n-      // Every change on _M_cur_results and _M_current will be rolled back after\n-      // finishing the recursion step.\n-      switch (__state._M_opcode())\n+\n+      // Greedy.\n+      if (!__state._M_neg)\n \t{\n-\t// _M_alt branch is \"match once more\", while _M_next is \"get me out\n-\t// of this quantifier\". Executing _M_next first or _M_alt first don't\n-\t// mean the same thing, and we need to choose the correct order under\n-\t// given greedy mode.\n-\tcase _S_opcode_repeat:\n-\t  {\n-\t    // Greedy.\n-\t    if (!__state._M_neg)\n-\t      {\n-\t\t_M_rep_once_more(__match_mode, __i);\n-\t\t// If it's DFS executor and already accepted, we're done.\n-\t\tif (!__dfs_mode || !_M_has_sol)\n-\t\t  _M_dfs(__match_mode, __state._M_next);\n-\t      }\n-\t    else // Non-greedy mode\n-\t      {\n-\t\tif (__dfs_mode)\n-\t\t  {\n-\t\t    // vice-versa.\n-\t\t    _M_dfs(__match_mode, __state._M_next);\n-\t\t    if (!_M_has_sol)\n-\t\t      _M_rep_once_more(__match_mode, __i);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    // DON'T attempt anything, because there's already another\n-\t\t    // state with higher priority accepted. This state cannot\n-\t\t    // be better by attempting its next node.\n-\t\t    if (!_M_has_sol)\n-\t\t      {\n-\t\t\t_M_dfs(__match_mode, __state._M_next);\n-\t\t\t// DON'T attempt anything if it's already accepted. An\n-\t\t\t// accepted state *must* be better than a solution that\n-\t\t\t// matches a non-greedy quantifier one more time.\n-\t\t\tif (!_M_has_sol)\n-\t\t\t  _M_rep_once_more(__match_mode, __i);\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t    }\n-\t  break;\n-\tcase _S_opcode_subexpr_begin:\n-\t  {\n-\t    auto& __res = _M_cur_results[__state._M_subexpr];\n-\t    auto __back = __res.first;\n-\t    __res.first = _M_current;\n-\t    _M_dfs(__match_mode, __state._M_next);\n-\t    __res.first = __back;\n-\t  }\n-\t  break;\n-\tcase _S_opcode_subexpr_end:\n-\t  {\n-\t    auto& __res = _M_cur_results[__state._M_subexpr];\n-\t    auto __back = __res;\n-\t    __res.second = _M_current;\n-\t    __res.matched = true;\n-\t    _M_dfs(__match_mode, __state._M_next);\n-\t    __res = __back;\n-\t  }\n-\t  break;\n-\tcase _S_opcode_line_begin_assertion:\n-\t  if (_M_at_begin())\n+\t  _M_rep_once_more(__match_mode, __i);\n+\t  // If it's DFS executor and already accepted, we're done.\n+\t  if (!__dfs_mode || !_M_has_sol)\n \t    _M_dfs(__match_mode, __state._M_next);\n-\t  break;\n-\tcase _S_opcode_line_end_assertion:\n-\t  if (_M_at_end())\n-\t    _M_dfs(__match_mode, __state._M_next);\n-\t  break;\n-\tcase _S_opcode_word_boundary:\n-\t  if (_M_word_boundary() == !__state._M_neg)\n-\t    _M_dfs(__match_mode, __state._M_next);\n-\t  break;\n-\t// Here __state._M_alt offers a single start node for a sub-NFA.\n-\t// We recursively invoke our algorithm to match the sub-NFA.\n-\tcase _S_opcode_subexpr_lookahead:\n-\t  if (_M_lookahead(__state._M_alt) == !__state._M_neg)\n-\t    _M_dfs(__match_mode, __state._M_next);\n-\t  break;\n-\tcase _S_opcode_match:\n-\t  if (_M_current == _M_end)\n-\t    break;\n+\t}\n+      else // Non-greedy mode\n+\t{\n \t  if (__dfs_mode)\n \t    {\n-\t      if (__state._M_matches(*_M_current))\n-\t\t{\n-\t\t  ++_M_current;\n-\t\t  _M_dfs(__match_mode, __state._M_next);\n-\t\t  --_M_current;\n-\t\t}\n+\t      // vice-versa.\n+\t      _M_dfs(__match_mode, __state._M_next);\n+\t      if (!_M_has_sol)\n+\t\t_M_rep_once_more(__match_mode, __i);\n \t    }\n \t  else\n-\t    if (__state._M_matches(*_M_current))\n-\t      _M_states._M_queue(__state._M_next, _M_cur_results);\n-\t  break;\n-\t// First fetch the matched result from _M_cur_results as __submatch;\n-\t// then compare it with\n-\t// (_M_current, _M_current + (__submatch.second - __submatch.first)).\n-\t// If matched, keep going; else just return and try another state.\n-\tcase _S_opcode_backref:\n-\t  {\n-\t    __glibcxx_assert(__dfs_mode);\n-\t    auto& __submatch = _M_cur_results[__state._M_backref_index];\n-\t    if (!__submatch.matched)\n-\t      break;\n-\t    auto __last = _M_current;\n-\t    for (auto __tmp = __submatch.first;\n-\t\t __last != _M_end && __tmp != __submatch.second;\n-\t\t ++__tmp)\n-\t      ++__last;\n-\t    if (_M_re._M_automaton->_M_traits.transform(__submatch.first,\n-\t\t\t\t\t\t\t__submatch.second)\n-\t\t== _M_re._M_automaton->_M_traits.transform(_M_current, __last))\n-\t      {\n-\t\tif (__last != _M_current)\n-\t\t  {\n-\t\t    auto __backup = _M_current;\n-\t\t    _M_current = __last;\n-\t\t    _M_dfs(__match_mode, __state._M_next);\n-\t\t    _M_current = __backup;\n-\t\t  }\n-\t\telse\n-\t\t  _M_dfs(__match_mode, __state._M_next);\n-\t      }\n-\t  }\n-\t  break;\n-\tcase _S_opcode_accept:\n-\t  if (__dfs_mode)\n \t    {\n-\t      __glibcxx_assert(!_M_has_sol);\n-\t      if (__match_mode == _Match_mode::_Exact)\n-\t\t_M_has_sol = _M_current == _M_end;\n-\t      else\n-\t\t_M_has_sol = true;\n-\t      if (_M_current == _M_begin\n-\t\t  && (_M_flags & regex_constants::match_not_null))\n-\t\t_M_has_sol = false;\n-\t      if (_M_has_sol)\n+\t      // DON'T attempt anything, because there's already another\n+\t      // state with higher priority accepted. This state cannot\n+\t      // be better by attempting its next node.\n+\t      if (!_M_has_sol)\n \t\t{\n-\t\t  if (_M_nfa._M_flags & regex_constants::ECMAScript)\n-\t\t    _M_results = _M_cur_results;\n-\t\t  else // POSIX\n-\t\t    {\n-\t\t      __glibcxx_assert(_M_states._M_get_sol_pos());\n-\t\t      // Here's POSIX's logic: match the longest one. However\n-\t\t      // we never know which one (lhs or rhs of \"|\") is longer\n-\t\t      // unless we try both of them and compare the results.\n-\t\t      // The member variable _M_sol_pos records the end\n-\t\t      // position of the last successful match. It's better\n-\t\t      // to be larger, because POSIX regex is always greedy.\n-\t\t      // TODO: This could be slow.\n-\t\t      if (*_M_states._M_get_sol_pos() == _BiIter()\n-\t\t\t  || std::distance(_M_begin,\n-\t\t\t\t\t   *_M_states._M_get_sol_pos())\n-\t\t\t     < std::distance(_M_begin, _M_current))\n-\t\t\t{\n-\t\t\t  *_M_states._M_get_sol_pos() = _M_current;\n-\t\t\t  _M_results = _M_cur_results;\n-\t\t\t}\n-\t\t    }\n+\t\t  _M_dfs(__match_mode, __state._M_next);\n+\t\t  // DON'T attempt anything if it's already accepted. An\n+\t\t  // accepted state *must* be better than a solution that\n+\t\t  // matches a non-greedy quantifier one more time.\n+\t\t  if (!_M_has_sol)\n+\t\t    _M_rep_once_more(__match_mode, __i);\n \t\t}\n \t    }\n-\t  else\n+\t}\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_subexpr_begin(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+\n+      auto& __res = _M_cur_results[__state._M_subexpr];\n+      auto __back = __res.first;\n+      __res.first = _M_current;\n+      _M_dfs(__match_mode, __state._M_next);\n+      __res.first = __back;\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_subexpr_end(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+\n+      auto& __res = _M_cur_results[__state._M_subexpr];\n+      auto __back = __res;\n+      __res.second = _M_current;\n+      __res.matched = true;\n+      _M_dfs(__match_mode, __state._M_next);\n+      __res = __back;\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_line_begin_assertion(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+      if (_M_at_begin())\n+\t_M_dfs(__match_mode, __state._M_next);\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_line_end_assertion(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+      if (_M_at_end())\n+\t_M_dfs(__match_mode, __state._M_next);\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_word_boundary(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+      if (_M_word_boundary() == !__state._M_neg)\n+\t_M_dfs(__match_mode, __state._M_next);\n+    }\n+\n+  // Here __state._M_alt offers a single start node for a sub-NFA.\n+  // We recursively invoke our algorithm to match the sub-NFA.\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_subexpr_lookahead(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+      if (_M_lookahead(__state._M_alt) == !__state._M_neg)\n+\t_M_dfs(__match_mode, __state._M_next);\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_match(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+\n+      if (_M_current == _M_end)\n+\treturn;\n+      if (__dfs_mode)\n+\t{\n+\t  if (__state._M_matches(*_M_current))\n \t    {\n-\t      if (_M_current == _M_begin\n-\t\t  && (_M_flags & regex_constants::match_not_null))\n-\t\tbreak;\n-\t      if (__match_mode == _Match_mode::_Prefix || _M_current == _M_end)\n-\t\tif (!_M_has_sol)\n-\t\t  {\n-\t\t    _M_has_sol = true;\n-\t\t    _M_results = _M_cur_results;\n-\t\t  }\n+\t      ++_M_current;\n+\t      _M_dfs(__match_mode, __state._M_next);\n+\t      --_M_current;\n \t    }\n-\t  break;\n-\tcase _S_opcode_alternative:\n-\t  if (_M_nfa._M_flags & regex_constants::ECMAScript)\n+\t}\n+      else\n+\tif (__state._M_matches(*_M_current))\n+\t  _M_states._M_queue(__state._M_next, _M_cur_results);\n+    }\n+\n+  // First fetch the matched result from _M_cur_results as __submatch;\n+  // then compare it with\n+  // (_M_current, _M_current + (__submatch.second - __submatch.first)).\n+  // If matched, keep going; else just return and try another state.\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_backref(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      __glibcxx_assert(__dfs_mode);\n+\n+      const auto& __state = _M_nfa[__i];\n+      auto& __submatch = _M_cur_results[__state._M_backref_index];\n+      if (!__submatch.matched)\n+\treturn;\n+      auto __last = _M_current;\n+      for (auto __tmp = __submatch.first;\n+\t   __last != _M_end && __tmp != __submatch.second;\n+\t   ++__tmp)\n+\t++__last;\n+      if (_M_re._M_automaton->_M_traits.transform(__submatch.first,\n+\t\t\t\t\t\t  __submatch.second)\n+\t  == _M_re._M_automaton->_M_traits.transform(_M_current, __last))\n+\t{\n+\t  if (__last != _M_current)\n \t    {\n-\t      // TODO: Fix BFS support. It is wrong.\n-\t      _M_dfs(__match_mode, __state._M_alt);\n-\t      // Pick lhs if it matches. Only try rhs if it doesn't.\n-\t      if (!_M_has_sol)\n-\t\t_M_dfs(__match_mode, __state._M_next);\n+\t      auto __backup = _M_current;\n+\t      _M_current = __last;\n+\t      _M_dfs(__match_mode, __state._M_next);\n+\t      _M_current = __backup;\n \t    }\n \t  else\n+\t    _M_dfs(__match_mode, __state._M_next);\n+\t}\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_accept(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      if (__dfs_mode)\n+\t{\n+\t  __glibcxx_assert(!_M_has_sol);\n+\t  if (__match_mode == _Match_mode::_Exact)\n+\t    _M_has_sol = _M_current == _M_end;\n+\t  else\n+\t    _M_has_sol = true;\n+\t  if (_M_current == _M_begin\n+\t      && (_M_flags & regex_constants::match_not_null))\n+\t    _M_has_sol = false;\n+\t  if (_M_has_sol)\n \t    {\n-\t      // Try both and compare the result.\n-\t      // See \"case _S_opcode_accept:\" handling above.\n-\t      _M_dfs(__match_mode, __state._M_alt);\n-\t      auto __has_sol = _M_has_sol;\n-\t      _M_has_sol = false;\n-\t      _M_dfs(__match_mode, __state._M_next);\n-\t      _M_has_sol |= __has_sol;\n+\t      if (_M_nfa._M_flags & regex_constants::ECMAScript)\n+\t\t_M_results = _M_cur_results;\n+\t      else // POSIX\n+\t\t{\n+\t\t  __glibcxx_assert(_M_states._M_get_sol_pos());\n+\t\t  // Here's POSIX's logic: match the longest one. However\n+\t\t  // we never know which one (lhs or rhs of \"|\") is longer\n+\t\t  // unless we try both of them and compare the results.\n+\t\t  // The member variable _M_sol_pos records the end\n+\t\t  // position of the last successful match. It's better\n+\t\t  // to be larger, because POSIX regex is always greedy.\n+\t\t  // TODO: This could be slow.\n+\t\t  if (*_M_states._M_get_sol_pos() == _BiIter()\n+\t\t      || std::distance(_M_begin,\n+\t\t\t\t       *_M_states._M_get_sol_pos())\n+\t\t\t < std::distance(_M_begin, _M_current))\n+\t\t    {\n+\t\t      *_M_states._M_get_sol_pos() = _M_current;\n+\t\t      _M_results = _M_cur_results;\n+\t\t    }\n+\t\t}\n \t    }\n-\t  break;\n+\t}\n+      else\n+\t{\n+\t  if (_M_current == _M_begin\n+\t      && (_M_flags & regex_constants::match_not_null))\n+\t    return;\n+\t  if (__match_mode == _Match_mode::_Prefix || _M_current == _M_end)\n+\t    if (!_M_has_sol)\n+\t      {\n+\t\t_M_has_sol = true;\n+\t\t_M_results = _M_cur_results;\n+\t      }\n+\t}\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_handle_alternative(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+\n+      if (_M_nfa._M_flags & regex_constants::ECMAScript)\n+\t{\n+\t  // TODO: Fix BFS support. It is wrong.\n+\t  _M_dfs(__match_mode, __state._M_alt);\n+\t  // Pick lhs if it matches. Only try rhs if it doesn't.\n+\t  if (!_M_has_sol)\n+\t    _M_dfs(__match_mode, __state._M_next);\n+\t}\n+      else\n+\t{\n+\t  // Try both and compare the result.\n+\t  // See \"case _S_opcode_accept:\" handling above.\n+\t  _M_dfs(__match_mode, __state._M_alt);\n+\t  auto __has_sol = _M_has_sol;\n+\t  _M_has_sol = false;\n+\t  _M_dfs(__match_mode, __state._M_next);\n+\t  _M_has_sol |= __has_sol;\n+\t}\n+    }\n+\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_dfs(_Match_mode __match_mode, _StateIdT __i)\n+    {\n+      if (_M_states._M_visited(__i))\n+\treturn;\n+\n+      switch (_M_nfa[__i]._M_opcode())\n+\t{\n+\tcase _S_opcode_repeat:\n+\t  _M_handle_repeat(__match_mode, __i); break;\n+\tcase _S_opcode_subexpr_begin:\n+\t  _M_handle_subexpr_begin(__match_mode, __i); break;\n+\tcase _S_opcode_subexpr_end:\n+\t  _M_handle_subexpr_end(__match_mode, __i); break;\n+\tcase _S_opcode_line_begin_assertion:\n+\t  _M_handle_line_begin_assertion(__match_mode, __i); break;\n+\tcase _S_opcode_line_end_assertion:\n+\t  _M_handle_line_end_assertion(__match_mode, __i); break;\n+\tcase _S_opcode_word_boundary:\n+\t  _M_handle_word_boundary(__match_mode, __i); break;\n+\tcase _S_opcode_subexpr_lookahead:\n+\t  _M_handle_subexpr_lookahead(__match_mode, __i); break;\n+\tcase _S_opcode_match:\n+\t  _M_handle_match(__match_mode, __i); break;\n+\tcase _S_opcode_backref:\n+\t  _M_handle_backref(__match_mode, __i); break;\n+\tcase _S_opcode_accept:\n+\t  _M_handle_accept(__match_mode, __i); break;\n+\tcase _S_opcode_alternative:\n+\t  _M_handle_alternative(__match_mode, __i); break;\n \tdefault:\n \t  __glibcxx_assert(false);\n \t}"}]}