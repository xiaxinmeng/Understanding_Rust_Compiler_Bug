{"sha": "4d588c1434f5837f2900c32a28ca2856858e4ddc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ1ODhjMTQzNGY1ODM3ZjI5MDBjMzJhMjhjYTI4NTY4NThlNGRkYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-05-04T00:33:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-05-04T00:33:49Z"}, "message": "rs6000.c (constant_pool_expr_p): Make static and return bool.\n\n        * config/rs6000/rs6000.c (constant_pool_expr_p): Make static and\n\treturn bool.\n        (toc_relative_expr_p): Likewise.\n        (SPE_CONST_OFFSET_OK): Move from rs6000.h.\n        (legitimate_constant_pool_address_p): Move from rs6000.h, change\n        into a function, downcase all users.\n        (legitimate_small_data_p): Likewise.\n        (legitimate_offset_address_p): Likewise.\n        (legitimate_indexed_address_p): Likewise.\n        (legitimate_indirect_address_p): Likewise.\n        (legitimate_lo_sum_address_p): Likewise.\n        (rs6000_mode_dependent_address): Likewise.\n        * rs6000.h (CONSTANT_POOL_EXPR_P, TOC_RELATIVE_EXPR_P): Remove.\n        (SPE_CONST_OFFSET_OK, LEGITIMATE_CONSTANT_POOL_ADDRESS_P,\n        LEGITIMATE_SMALL_DATA_P, LEGITIMATE_OFFSET_ADDRESS_P,\n        LEGITIMATE_INDEXED_ADDRESS_P, LEGITIMATE_INDIRECT_ADDRESS_P,\n        LEGITIMATE_LO_SUM_ADDRESS_P): Move into rs6000.c.\n        (LEGITIMATE_ADDRESS_INTEGER_P): Remove.\n        (GO_IF_MODE_DEPENDENT_ADDRESS): Use rs6000_mode_dependent_address.\n        * config/rs6000/rs6000-protos.h: Update.\n\nFrom-SVN: r66445", "tree": {"sha": "ff1027b48c1968125a7162074c68012e77845ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff1027b48c1968125a7162074c68012e77845ed6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d588c1434f5837f2900c32a28ca2856858e4ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d588c1434f5837f2900c32a28ca2856858e4ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d588c1434f5837f2900c32a28ca2856858e4ddc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d588c1434f5837f2900c32a28ca2856858e4ddc/comments", "author": null, "committer": null, "parents": [{"sha": "c3a5317cd3cfe42bbdea084056b2e2999361cd09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3a5317cd3cfe42bbdea084056b2e2999361cd09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3a5317cd3cfe42bbdea084056b2e2999361cd09"}], "stats": {"total": 379, "additions": 259, "deletions": 120}, "files": [{"sha": "e254b46923fd9b66b5447ededd0e840f150efe06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d588c1434f5837f2900c32a28ca2856858e4ddc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d588c1434f5837f2900c32a28ca2856858e4ddc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d588c1434f5837f2900c32a28ca2856858e4ddc", "patch": "@@ -1,3 +1,26 @@\n+2003-05-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/rs6000/rs6000.c (constant_pool_expr_p): Make static and\n+\treturn bool.\n+\t(toc_relative_expr_p): Likewise.\n+\t(SPE_CONST_OFFSET_OK): Move from rs6000.h.\n+\t(legitimate_constant_pool_address_p): Move from rs6000.h, change\n+\tinto a function, downcase all users.\n+\t(legitimate_small_data_p): Likewise.\n+\t(legitimate_offset_address_p): Likewise.\n+\t(legitimate_indexed_address_p): Likewise.\n+\t(legitimate_indirect_address_p): Likewise.\n+\t(legitimate_lo_sum_address_p): Likewise.\n+\t(rs6000_mode_dependent_address): Likewise.\n+\t* rs6000.h (CONSTANT_POOL_EXPR_P, TOC_RELATIVE_EXPR_P): Remove.\n+\t(SPE_CONST_OFFSET_OK, LEGITIMATE_CONSTANT_POOL_ADDRESS_P,\n+\tLEGITIMATE_SMALL_DATA_P, LEGITIMATE_OFFSET_ADDRESS_P,\n+\tLEGITIMATE_INDEXED_ADDRESS_P, LEGITIMATE_INDIRECT_ADDRESS_P,\n+\tLEGITIMATE_LO_SUM_ADDRESS_P): Move into rs6000.c.\n+\t(LEGITIMATE_ADDRESS_INTEGER_P): Remove.\n+\t(GO_IF_MODE_DEPENDENT_ADDRESS): Use rs6000_mode_dependent_address.\n+\t* config/rs6000/rs6000-protos.h: Update.\n+\n 2003-05-03  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/rs6000/rs6000.h (REVERSIBLE_CC_MODE): Define.\n@@ -24,7 +47,7 @@\n \n 2003-05-03  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/spe.h: Remove unecessary casts.  Misc cleanups.\n+\t* config/rs6000/spe.h: Remove unecessary casts.  Misc cleanups.\n \n 2003-05-03  Zack Weinberg  <zack@codesourcery.com>\n "}, {"sha": "b3406bb3b361bb0fad1192c93d1142285afdb558", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d588c1434f5837f2900c32a28ca2856858e4ddc/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d588c1434f5837f2900c32a28ca2856858e4ddc/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=4d588c1434f5837f2900c32a28ca2856858e4ddc", "patch": "@@ -82,8 +82,7 @@ extern int current_file_function_operand PARAMS ((rtx, enum machine_mode));\n extern int input_operand PARAMS ((rtx, enum machine_mode));\n extern int small_data_operand PARAMS ((rtx, enum machine_mode));\n extern int s8bit_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int constant_pool_expr_p PARAMS ((rtx));\n-extern int toc_relative_expr_p PARAMS ((rtx));\n+extern bool legitimate_constant_pool_address_p PARAMS ((rtx));\n extern int expand_block_move PARAMS ((rtx[]));\n extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern const char * rs6000_output_load_multiple PARAMS ((rtx[]));\n@@ -131,6 +130,7 @@ extern rtx rs6000_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx rs6000_legitimize_reload_address PARAMS ((rtx, enum machine_mode,\n \t\t\t    int, int, int, int *));\n extern int rs6000_legitimate_address PARAMS ((enum machine_mode, rtx, int));\n+extern bool rs6000_mode_dependent_address PARAMS ((rtx));\n extern rtx rs6000_return_addr PARAMS ((int, rtx));\n extern void rs6000_output_symbol_ref PARAMS ((FILE*, rtx));\n "}, {"sha": "b5faabddc13cb5ef9d34ed1c210cde54f630065c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 228, "deletions": 30, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d588c1434f5837f2900c32a28ca2856858e4ddc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d588c1434f5837f2900c32a28ca2856858e4ddc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4d588c1434f5837f2900c32a28ca2856858e4ddc", "patch": "@@ -204,6 +204,13 @@ static unsigned rs6000_hash_constant PARAMS ((rtx));\n static unsigned toc_hash_function PARAMS ((const void *));\n static int toc_hash_eq PARAMS ((const void *, const void *));\n static int constant_pool_expr_1 PARAMS ((rtx, int *, int *));\n+static bool constant_pool_expr_p PARAMS ((rtx));\n+static bool toc_relative_expr_p PARAMS ((rtx));\n+static bool legitimate_small_data_p PARAMS ((enum machine_mode, rtx));\n+static bool legitimate_offset_address_p PARAMS ((enum machine_mode, rtx, int));\n+static bool legitimate_indexed_address_p PARAMS ((rtx, int));\n+static bool legitimate_indirect_address_p PARAMS ((rtx, int));\n+static bool legitimate_lo_sum_address_p PARAMS ((enum machine_mode, rtx, int));\n static struct machine_function * rs6000_init_machine_status PARAMS ((void));\n static bool rs6000_assemble_integer PARAMS ((rtx, unsigned int, int));\n #ifdef HAVE_GAS_HIDDEN\n@@ -2154,11 +2161,11 @@ input_operand (op, mode)\n     return 1;\n \n   /* A SYMBOL_REF referring to the TOC is valid.  */\n-  if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (op))\n+  if (legitimate_constant_pool_address_p (op))\n     return 1;\n \n   /* A constant pool expression (relative to the TOC) is valid */\n-  if (TOC_RELATIVE_EXPR_P (op))\n+  if (toc_relative_expr_p (op))\n     return 1;\n \n   /* V.4 allows SYMBOL_REFs and CONSTs that are in the small data region\n@@ -2216,6 +2223,8 @@ small_data_operand (op, mode)\n #endif\n }\n \f\n+/* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address.  */\n+\n static int \n constant_pool_expr_1 (op, have_sym, have_toc) \n     rtx op;\n@@ -2255,7 +2264,7 @@ constant_pool_expr_1 (op, have_sym, have_toc)\n     }\n }\n \n-int\n+static bool\n constant_pool_expr_p (op)\n     rtx op;\n {\n@@ -2264,15 +2273,164 @@ constant_pool_expr_p (op)\n   return constant_pool_expr_1 (op, &have_sym, &have_toc) && have_sym;\n }\n \n-int\n+static bool\n toc_relative_expr_p (op)\n     rtx op;\n {\n-    int have_sym = 0;\n-    int have_toc = 0;\n-    return constant_pool_expr_1 (op, &have_sym, &have_toc) && have_toc;\n+  int have_sym = 0;\n+  int have_toc = 0;\n+  return constant_pool_expr_1 (op, &have_sym, &have_toc) && have_toc;\n+}\n+\n+/* SPE offset addressing is limited to 5-bits worth of double words.  */\n+#define SPE_CONST_OFFSET_OK(x) (((x) & ~0xf8) == 0)\n+\n+bool\n+legitimate_constant_pool_address_p (x)\n+     rtx x;\n+{\n+  return (TARGET_TOC\n+\t  && GET_CODE (x) == PLUS\n+\t  && GET_CODE (XEXP (x, 0)) == REG\n+\t  && (TARGET_MINIMAL_TOC || REGNO (XEXP (x, 0)) == TOC_REGISTER)\n+\t  && constant_pool_expr_p (XEXP (x, 1)));\n+}\n+\n+static bool\n+legitimate_small_data_p (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  return (DEFAULT_ABI == ABI_V4\n+\t  && !flag_pic && !TARGET_TOC\n+\t  && (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST)\n+\t  && small_data_operand (x, mode));\n+}\n+\n+static bool\n+legitimate_offset_address_p (mode, x, strict)\n+     enum machine_mode mode;\n+     rtx x;\n+     int strict;\n+{\n+  unsigned HOST_WIDE_INT offset, extra;\n+\n+  if (GET_CODE (x) != PLUS)\n+    return false;\n+  if (GET_CODE (XEXP (x, 0)) != REG)\n+    return false;\n+  if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n+    return false;\n+  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+    return false;\n+\n+  offset = INTVAL (XEXP (x, 1));\n+  extra = 0;\n+  switch (mode)\n+    {\n+    case V16QImode:\n+    case V8HImode:\n+    case V4SFmode:\n+    case V4SImode:\n+      /* AltiVec vector modes.  Only reg+reg addressing is valid here,\n+\t which leaves the only valid constant offset of zero, which by\n+\t canonicalization rules is also invalid.  */\n+      return false;\n+\n+    case V4HImode:\n+    case V2SImode:\n+    case V1DImode:\n+    case V2SFmode:\n+      /* SPE vector modes.  */\n+      return SPE_CONST_OFFSET_OK (offset);\n+\n+    case DFmode:\n+    case DImode:\n+      if (TARGET_32BIT)\n+\textra = 4;\n+      else if (offset & 3)\n+\treturn false;\n+      break;\n+\n+    case TFmode:\n+    case TImode:\n+      if (TARGET_32BIT)\n+\textra = 12;\n+      else if (offset & 3)\n+\treturn false;\n+      else\n+\textra = 8;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return (offset + extra >= offset) && (offset + extra + 0x8000 < 0x10000);\n+}\n+\n+static bool\n+legitimate_indexed_address_p (x, strict)\n+     rtx x;\n+     int strict;\n+{\n+  rtx op0, op1;\n+\n+  if (GET_CODE (x) != PLUS)\n+    return false;\n+  op0 = XEXP (x, 0);\n+  op1 = XEXP (x, 1);\n+\n+  if (!REG_P (op0) || !REG_P (op1))\n+    return false;\n+\n+  return ((INT_REG_OK_FOR_BASE_P (op0, strict)\n+\t   && INT_REG_OK_FOR_INDEX_P (op1, strict))\n+\t  || (INT_REG_OK_FOR_BASE_P (op1, strict)\n+\t      && INT_REG_OK_FOR_INDEX_P (op0, strict)));\n+}\n+\n+static inline bool\n+legitimate_indirect_address_p (x, strict)\n+     rtx x;\n+     int strict;\n+{\n+  return GET_CODE (x) == REG && INT_REG_OK_FOR_BASE_P (x, strict);\n }\n \n+static bool\n+legitimate_lo_sum_address_p (mode, x, strict)\n+     enum machine_mode mode;\n+     rtx x;\n+     int strict;\n+{\n+  if (GET_CODE (x) != LO_SUM)\n+    return false;\n+  if (GET_CODE (XEXP (x, 0)) != REG)\n+    return false;\n+  if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n+    return false;\n+  x = XEXP (x, 1);\n+\n+  if (TARGET_ELF)\n+    {\n+      if (DEFAULT_ABI != ABI_AIX && flag_pic)\n+\treturn false;\n+      if (TARGET_TOC)\n+\treturn false;\n+      if (GET_MODE_NUNITS (mode) != 1)\n+\treturn false;\n+      if (GET_MODE_BITSIZE (mode) > 32\n+\t  && !(TARGET_HARD_FLOAT && TARGET_FPRS && mode == DFmode))\n+\treturn false;\n+\n+      return CONSTANT_P (x);\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This is used from only one place: `memory_address' in explow.c.\n@@ -2295,6 +2453,7 @@ toc_relative_expr_p (op)\n \n    Then check for the sum of a register and something not constant, try to\n    load the other things into a register and return the sum.  */\n+\n rtx\n rs6000_legitimize_address (x, oldx, mode)\n      rtx x;\n@@ -2392,7 +2551,7 @@ rs6000_legitimize_address (x, oldx, mode)\n       return gen_rtx_LO_SUM (Pmode, reg, (x));\n     }\n   else if (TARGET_TOC \n-\t   && CONSTANT_POOL_EXPR_P (x)\n+\t   && constant_pool_expr_p (x)\n \t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), Pmode))\n     {\n       return create_TOC_reference (x);\n@@ -2535,7 +2694,7 @@ rs6000_legitimize_reload_address (x, mode, opnum, type, ind_levels, win)\n      }\n #endif\n   if (TARGET_TOC\n-      && CONSTANT_POOL_EXPR_P (x)\n+      && constant_pool_expr_p (x)\n       && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), mode))\n     {\n       (x) = create_TOC_reference (x);\n@@ -2569,17 +2728,17 @@ rs6000_legitimate_address (mode, x, reg_ok_strict)\n     rtx x;\n     int reg_ok_strict;\n {\n-  if (LEGITIMATE_INDIRECT_ADDRESS_P (x, reg_ok_strict))\n+  if (legitimate_indirect_address_p (x, reg_ok_strict))\n     return 1;\n   if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n       && !ALTIVEC_VECTOR_MODE (mode)\n       && !SPE_VECTOR_MODE (mode)\n       && TARGET_UPDATE\n-      && LEGITIMATE_INDIRECT_ADDRESS_P (XEXP (x, 0), reg_ok_strict))\n+      && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n-  if (LEGITIMATE_SMALL_DATA_P (mode, x))\n+  if (legitimate_small_data_p (mode, x))\n     return 1;\n-  if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (x))\n+  if (legitimate_constant_pool_address_p (x))\n     return 1;\n   /* If not REG_OK_STRICT (before reload) let pass any stack offset.  */\n   if (! reg_ok_strict\n@@ -2588,19 +2747,58 @@ rs6000_legitimate_address (mode, x, reg_ok_strict)\n       && XEXP (x, 0) == virtual_stack_vars_rtx\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     return 1;\n-  if (LEGITIMATE_OFFSET_ADDRESS_P (mode, x, reg_ok_strict))\n+  if (legitimate_offset_address_p (mode, x, reg_ok_strict))\n     return 1;\n   if (mode != TImode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t  || TARGET_POWERPC64\n \t  || (mode != DFmode && mode != TFmode))\n       && (TARGET_POWERPC64 || mode != DImode)\n-      && LEGITIMATE_INDEXED_ADDRESS_P (x, reg_ok_strict))\n+      && legitimate_indexed_address_p (x, reg_ok_strict))\n     return 1;\n-  if (LEGITIMATE_LO_SUM_ADDRESS_P (mode, x, reg_ok_strict))\n+  if (legitimate_lo_sum_address_p (mode, x, reg_ok_strict))\n     return 1;\n   return 0;\n }\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+\n+   On the RS/6000 this is true of all integral offsets (since AltiVec\n+   modes don't allow them) or is a pre-increment or decrement.\n+\n+   ??? Except that due to conceptual problems in offsettable_address_p\n+   we can't really report the problems of integral offsets.  So leave\n+   this assuming that the adjustable offset must be valid for the \n+   sub-words of a TFmode operand, which is what we had before.  */\n+\n+bool\n+rs6000_mode_dependent_address (addr)\n+     rtx addr;\n+{\n+  switch (GET_CODE (addr))\n+    {\n+    case PLUS:\n+      if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t{\n+\t  unsigned HOST_WIDE_INT val = INTVAL (XEXP (addr, 1));\n+\t  return val + 12 + 0x8000 >= 0x10000;\n+\t}\n+      break;\n+\n+    case LO_SUM:\n+      return true;\n+\n+    case PRE_INC:\n+    case PRE_DEC:\n+      return TARGET_UPDATE;\n+\n+    default:\n+      break;\n+    }\n+\n+  return false;\n+}\n \f\n /* Try to output insns to set TARGET equal to the constant C if it can\n    be done in less than N insns.  Do all computations in MODE.\n@@ -2974,7 +3172,7 @@ rs6000_emit_move (dest, source, mode)\n \t reference to it.  */\n       if (TARGET_TOC\n \t  && GET_CODE (operands[1]) == SYMBOL_REF\n-\t  && CONSTANT_POOL_EXPR_P (operands[1])\n+\t  && constant_pool_expr_p (operands[1])\n \t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (operands[1]),\n \t\t\t\t\t      get_pool_mode (operands[1])))\n \t{\n@@ -2989,8 +3187,8 @@ rs6000_emit_move (dest, source, mode)\n \t\t   || (GET_CODE (operands[0]) == REG\n \t\t       && FP_REGNO_P (REGNO (operands[0]))))\n \t       && GET_CODE (operands[1]) != HIGH\n-\t       && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n-\t       && ! TOC_RELATIVE_EXPR_P (operands[1]))\n+\t       && ! legitimate_constant_pool_address_p (operands[1])\n+\t       && ! toc_relative_expr_p (operands[1]))\n \t{\n \t  /* Emit a USE operation so that the constant isn't deleted if\n \t     expensive optimizations are turned on because nobody\n@@ -3041,7 +3239,7 @@ rs6000_emit_move (dest, source, mode)\n \t  operands[1] = force_const_mem (mode, operands[1]);\n \n \t  if (TARGET_TOC \n-\t      && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0))\n+\t      && constant_pool_expr_p (XEXP (operands[1], 0))\n \t      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (\n \t\t\tget_pool_constant (XEXP (operands[1], 0)),\n \t\t\tget_pool_mode (XEXP (operands[1], 0))))\n@@ -6832,14 +7030,14 @@ lmw_operation (op, mode)\n       || count != 32 - (int) dest_regno)\n     return 0;\n \n-  if (LEGITIMATE_INDIRECT_ADDRESS_P (src_addr, 0))\n+  if (legitimate_indirect_address_p (src_addr, 0))\n     {\n       offset = 0;\n       base_regno = REGNO (src_addr);\n       if (base_regno == 0)\n \treturn 0;\n     }\n-  else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, src_addr, 0))\n+  else if (legitimate_offset_address_p (SImode, src_addr, 0))\n     {\n       offset = INTVAL (XEXP (src_addr, 1));\n       base_regno = REGNO (XEXP (src_addr, 0));\n@@ -6862,12 +7060,12 @@ lmw_operation (op, mode)\n \t  || GET_MODE (SET_SRC (elt)) != SImode)\n \treturn 0;\n       newaddr = XEXP (SET_SRC (elt), 0);\n-      if (LEGITIMATE_INDIRECT_ADDRESS_P (newaddr, 0))\n+      if (legitimate_indirect_address_p (newaddr, 0))\n \t{\n \t  newoffset = 0;\n \t  addr_reg = newaddr;\n \t}\n-      else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, newaddr, 0))\n+      else if (legitimate_offset_address_p (SImode, newaddr, 0))\n \t{\n \t  addr_reg = XEXP (newaddr, 0);\n \t  newoffset = INTVAL (XEXP (newaddr, 1));\n@@ -6910,14 +7108,14 @@ stmw_operation (op, mode)\n       || count != 32 - (int) src_regno)\n     return 0;\n \n-  if (LEGITIMATE_INDIRECT_ADDRESS_P (dest_addr, 0))\n+  if (legitimate_indirect_address_p (dest_addr, 0))\n     {\n       offset = 0;\n       base_regno = REGNO (dest_addr);\n       if (base_regno == 0)\n \treturn 0;\n     }\n-  else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, dest_addr, 0))\n+  else if (legitimate_offset_address_p (SImode, dest_addr, 0))\n     {\n       offset = INTVAL (XEXP (dest_addr, 1));\n       base_regno = REGNO (XEXP (dest_addr, 0));\n@@ -6940,12 +7138,12 @@ stmw_operation (op, mode)\n \t  || GET_MODE (SET_DEST (elt)) != SImode)\n \treturn 0;\n       newaddr = XEXP (SET_DEST (elt), 0);\n-      if (LEGITIMATE_INDIRECT_ADDRESS_P (newaddr, 0))\n+      if (legitimate_indirect_address_p (newaddr, 0))\n \t{\n \t  newoffset = 0;\n \t  addr_reg = newaddr;\n \t}\n-      else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, newaddr, 0))\n+      else if (legitimate_offset_address_p (SImode, newaddr, 0))\n \t{\n \t  addr_reg = XEXP (newaddr, 0);\n \t  newoffset = INTVAL (XEXP (newaddr, 1));\n@@ -8099,7 +8297,7 @@ print_operand (file, x, code)\n \n     case 'X':\n       if (GET_CODE (x) == MEM\n-\t  && LEGITIMATE_INDEXED_ADDRESS_P (XEXP (x, 0), 0))\n+\t  && legitimate_indexed_address_p (XEXP (x, 0), 0))\n \tputc ('x', file);\n       return;\n \n@@ -8294,7 +8492,7 @@ print_operand_address (file, x)\n       fprintf (file, \")(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n     }\n #endif\n-  else if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (x))\n+  else if (legitimate_constant_pool_address_p (x))\n     {\n       if (TARGET_AIX && (!TARGET_ELF || !TARGET_MINIMAL_TOC))\n \t{"}, {"sha": "033d30eceba538fdc42614dac4d9696698eb1764", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 87, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d588c1434f5837f2900c32a28ca2856858e4ddc/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d588c1434f5837f2900c32a28ca2856858e4ddc/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4d588c1434f5837f2900c32a28ca2856858e4ddc", "patch": "@@ -1308,7 +1308,7 @@ enum reg_class\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\\\n-   : (C) == 'R' ? LEGITIMATE_CONSTANT_POOL_ADDRESS_P (OP)\t\t\\\n+   : (C) == 'R' ? legitimate_constant_pool_address_p (OP)\t\t\\\n    : (C) == 'S' ? mask64_operand (OP, DImode)\t\t\t\t\\\n    : (C) == 'T' ? mask_operand (OP, SImode)\t\t\t\t\\\n    : (C) == 'U' ? (DEFAULT_ABI == ABI_V4\t\t\t\t\\\n@@ -2068,74 +2068,6 @@ typedef struct rs6000_args\n    adjacent memory cells are accessed by adding word-sized offsets\n    during assembly output.  */\n \n-#define CONSTANT_POOL_EXPR_P(X) (constant_pool_expr_p (X))\n-\n-#define TOC_RELATIVE_EXPR_P(X) (toc_relative_expr_p (X))\n-\n-/* SPE offset addressing is limited to 5-bits worth of double words.  */\n-#define SPE_CONST_OFFSET_OK(x) (((x) & ~0xf8) == 0)\n-\n-#define LEGITIMATE_CONSTANT_POOL_ADDRESS_P(X)\t\t\t\t\\\n-  (TARGET_TOC\t\t\t\t\t\t\t\t\\\n-  && GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-  && (TARGET_MINIMAL_TOC || REGNO (XEXP (X, 0)) == TOC_REGISTER)\t\\\n-  && CONSTANT_POOL_EXPR_P (XEXP (X, 1)))\n-\n-#define LEGITIMATE_SMALL_DATA_P(MODE, X)\t\t\t\t\\\n-  (DEFAULT_ABI == ABI_V4\t\t\t\t\t\t\\\n-   && !flag_pic && !TARGET_TOC\t\t\t\t\t\t\\\n-   && (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST)\t\t\\\n-   && small_data_operand (X, MODE))\n-\n-#define LEGITIMATE_ADDRESS_INTEGER_P(X, OFFSET)\t\t\t\t\\\n- (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n-  && (unsigned HOST_WIDE_INT) (INTVAL (X) + (OFFSET) + 0x8000) < 0x10000)\n-\n-#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X, STRICT)\t\t\\\n- (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-  && INT_REG_OK_FOR_BASE_P (XEXP (X, 0), (STRICT))\t\t\\\n-  && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 0)\t\t\\\n-  && (! ALTIVEC_VECTOR_MODE (MODE)                            \\\n-      || (GET_CODE (XEXP (X,1)) == CONST_INT && INTVAL (XEXP (X,1)) == 0)) \\\n-  && (! SPE_VECTOR_MODE (MODE)\t\t\t\t\t\\\n-      || (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t  && SPE_CONST_OFFSET_OK (INTVAL (XEXP (X, 1)))))\t\\\n-  && (((MODE) != DFmode && (MODE) != DImode)\t\t\t\\\n-      || (TARGET_32BIT\t\t\t\t\t\t\\\n-\t  ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4) \t\\\n-\t  : ! (INTVAL (XEXP (X, 1)) & 3)))\t\t\t\\\n-  && (((MODE) != TFmode && (MODE) != TImode)\t\t\t\\\n-      || (TARGET_32BIT\t\t\t\t\t\t\\\n-\t  ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 12) \t\\\n-\t  : (LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 8) \t\\\n-\t     && ! (INTVAL (XEXP (X, 1)) & 3)))))\n-\n-#define LEGITIMATE_INDEXED_ADDRESS_P(X, STRICT)\t\t\t\\\n- (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-  && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-  && ((INT_REG_OK_FOR_BASE_P (XEXP (X, 0), (STRICT))\t\t\\\n-       && INT_REG_OK_FOR_INDEX_P (XEXP (X, 1), (STRICT)))\t\\\n-      || (INT_REG_OK_FOR_BASE_P (XEXP (X, 1), (STRICT))\t\t\\\n-\t  && INT_REG_OK_FOR_INDEX_P (XEXP (X, 0), (STRICT)))))\n-\n-#define LEGITIMATE_INDIRECT_ADDRESS_P(X, STRICT)\t\t\\\n-  (GET_CODE (X) == REG && INT_REG_OK_FOR_BASE_P (X, (STRICT)))\n-\n-#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X, STRICT)\t\\\n-  (TARGET_ELF\t\t\t\t\t\t\\\n-   && (DEFAULT_ABI == ABI_AIX || ! flag_pic)\t\t\\\n-   && ! TARGET_TOC\t\t\t\t\t\\\n-   && GET_MODE_NUNITS (MODE) == 1\t\t\t\\\n-   && (GET_MODE_BITSIZE (MODE) <= 32 \t\t\t\\\n-       || (TARGET_HARD_FLOAT && TARGET_FPRS && (MODE) == DFmode))\t\\\n-   && GET_CODE (X) == LO_SUM\t\t\t\t\\\n-   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n-   && INT_REG_OK_FOR_BASE_P (XEXP (X, 0), (STRICT))\t\\\n-   && CONSTANT_P (XEXP (X, 1)))\n-\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n { if (rs6000_legitimate_address (MODE, X, REG_OK_STRICT_FLAG))\t\\\n     goto ADDR;\t\t\t\t\t\t\t\\\n@@ -2190,27 +2122,13 @@ do {\t\t\t\t\t\t\t\t\t     \\\n } while (0)\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-\n-   On the RS/6000 this is true if the address is valid with a zero offset\n-   but not with an offset of four (this means it cannot be used as an\n-   address for DImode or DFmode) or is a pre-increment or decrement.  Since\n-   we know it is valid, we just check for an address that is not valid with\n-   an offset of four.  */\n+   has an effect that depends on the machine mode it is used for.  */\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\\\n-{ if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n-      && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1), 0)\t\\\n-      && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1),\t\\\n-\t\t\t\t\t (TARGET_32BIT ? 4 : 8))) \\\n-    goto LABEL;\t\t\t\t\t\t\t\\\n-  if (TARGET_UPDATE && GET_CODE (ADDR) == PRE_INC)\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\\\n-  if (TARGET_UPDATE && GET_CODE (ADDR) == PRE_DEC)\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (rs6000_mode_dependent_address (ADDR))\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\\\n-  if (GET_CODE (ADDR) == LO_SUM)\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\\\n-}\n+} while (0)\n \f\n /* The register number of the register used to address a table of\n    static data addresses in memory.  In some cases this register is"}]}