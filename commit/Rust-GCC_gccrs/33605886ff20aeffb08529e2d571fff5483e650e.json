{"sha": "33605886ff20aeffb08529e2d571fff5483e650e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM2MDU4ODZmZjIwYWVmZmIwODUyOWUyZDU3MWZmZjU0ODNlNjUwZQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-09-12T12:15:15Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-09-12T12:15:15Z"}, "message": "re PR ipa/58371 (internal compiler error: in ipcp_verify_propagated_values, at ipa-cp.c:892)\n\n2013-09-12  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/58371\n\t* g++.dg/ipa/pr58371.C: New test.\n\nFrom-SVN: r202522", "tree": {"sha": "ee768e7fd9f9f6f21f409bff6af8d1d848dda454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee768e7fd9f9f6f21f409bff6af8d1d848dda454"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33605886ff20aeffb08529e2d571fff5483e650e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33605886ff20aeffb08529e2d571fff5483e650e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33605886ff20aeffb08529e2d571fff5483e650e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33605886ff20aeffb08529e2d571fff5483e650e/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97463b2b878556e244a9aadad64228f9895ac735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97463b2b878556e244a9aadad64228f9895ac735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97463b2b878556e244a9aadad64228f9895ac735"}], "stats": {"total": 209, "additions": 209, "deletions": 0}, "files": [{"sha": "576d56d0873966c410859a049dc8ec1bb3fbb86b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33605886ff20aeffb08529e2d571fff5483e650e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33605886ff20aeffb08529e2d571fff5483e650e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=33605886ff20aeffb08529e2d571fff5483e650e", "patch": "@@ -1,3 +1,8 @@\n+2013-09-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/58371\n+\t* g++.dg/ipa/pr58371.C: New test.\n+\n 2013-09-12  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/ldist-4.c: Remove undefined behavior.  Adjust"}, {"sha": "00cfbb831fc88e662c744bfbc8d13e4f490c2d27", "filename": "gcc/testsuite/g++.dg/ipa/pr58371.C", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33605886ff20aeffb08529e2d571fff5483e650e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr58371.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33605886ff20aeffb08529e2d571fff5483e650e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr58371.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr58371.C?ref=33605886ff20aeffb08529e2d571fff5483e650e", "patch": "@@ -0,0 +1,204 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+\n+typedef int size_t;\n+namespace {\n+template < typename > struct char_traits;\n+}\n+namespace __gnu_cxx {\n+template < typename > class new_allocator {\n+};\n+}\n+namespace std {\n+template < typename _Tp > class allocator:__gnu_cxx::new_allocator < _Tp > {\n+public:\n+  size_t size_type;\n+  typedef _Tp & const_reference;\n+  template < typename > struct rebind {\n+    typedef allocator other;\n+  };\n+};\n+}\n+namespace __gnu_cxx {\n+template < typename _Alloc > struct __alloc_traits {\n+  typedef typename _Alloc::const_reference const_reference;\n+  template < typename _Tp > struct rebind {\n+    typedef typename _Alloc::template rebind < _Tp >::other other;\n+  };\n+};\n+}\n+namespace std {\n+struct __numeric_limits_base {\n+};\n+template < typename _Tp > struct numeric_limits:__numeric_limits_base {\n+  static _Tp max () {\n+  }\n+};\n+template < typename _Tp, typename _Alloc > struct _Vector_base {\n+  typedef typename __gnu_cxx::__alloc_traits < _Alloc >::template rebind <\n+  _Tp >::other _Tp_alloc_type;\n+};\n+template < typename _Tp, typename _Alloc = std::allocator < _Tp > >class vector:_Vector_base < _Tp,\n+  _Alloc\n+    > {\n+  typedef _Vector_base < _Tp, _Alloc > _Base;\n+  typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;\n+  typedef __gnu_cxx::__alloc_traits < _Tp_alloc_type > _Alloc_traits;\n+public:\n+  _Tp value_type;\n+  typedef typename _Alloc_traits::const_reference const_reference;\n+  typedef size_t size_type;\n+  size_type size () {\n+  } const_reference operator[] (size_type) {\n+  }\n+};\n+template < typename _CharT, typename =\n+char_traits < _CharT > >class basic_ostream;\n+typedef basic_ostream < int >ostream;\n+class ios_base {\n+};\n+template < typename, typename > class basic_ios:ios_base {\n+};\n+template < typename _CharT, typename _Traits > class basic_ostream:basic_ios < _CharT,\n+  _Traits\n+    > {\n+public:\n+  _CharT char_type;\n+  typedef basic_ostream __ostream_type;\n+  __ostream_type & operator<< (const void *) {\n+  }\n+};\n+}\n+namespace logging {\n+int GetMinLogLevel ();\n+typedef int LogSeverity;\n+LogSeverity LOG_ERROR_REPORT;\n+LogSeverity LOG_DCHECK;\n+class LogMessage {\n+public:\n+  LogMessage (const char *, int, LogSeverity);\n+  std::ostream & stream () {\n+  }\n+};\n+class LogMessageVoidify {\n+public:\n+  LogMessageVoidify () {\n+  } void operator& (std::ostream &) {\n+  }\n+};\n+}\n+namespace base {\n+namespace internal {\n+class WeakPtrBase {\n+};\n+class SupportsWeakPtrBase {\n+};\n+} template < typename T > class WeakPtr:internal::WeakPtrBase {\n+public:\n+  WeakPtr () :ptr_ () {\n+  } T *operator-> () {\n+    logging:0 &&\n+    logging::LOG_DCHECK >=\n+    logging::GetMinLogLevel () ? (void) 0 : logging::\n+    LogMessageVoidify () & logging::\n+    LogMessage (\"../../base/memory/weak_ptr.h\", 0,\n+                logging::LOG_ERROR_REPORT).stream () << \". \";\n+  } T *ptr_;\n+};\n+template < class > class SupportsWeakPtr:internal::SupportsWeakPtrBase {\n+};\n+}\n+template < class ObserverType > class ObserverListBase:base::SupportsWeakPtr < ObserverListBase < ObserverType >\n+    > {\n+public:\n+  class Iterator {\n+  public:\n+    Iterator (ObserverListBase & list) :max_index_ (0 ? std::numeric_limits <\n+          size_t >::max () : list.observers_.\n+          size () ) {\n+    } ObserverType *\n+    GetNext () {\n+      ListType & observers = list_->observers_;\n+      if (observers[0])\n+        ++index_;\n+    }\n+    base::WeakPtr < ObserverListBase > list_;\n+    size_t\n+    index_;\n+    size_t\n+    max_index_;\n+  };\n+  typedef\n+  std::vector <\n+  ObserverType * >\n+  ListType;\n+  ListType\n+  observers_;\n+};\n+template < class ObserverType, bool > class ObserverList:public ObserverListBase <\n+    ObserverType > {\n+};\n+namespace\n+    ProxyPrefs {\n+enum ConfigState\n+{ };\n+}\n+namespace\n+    net {\n+class\n+    ProxyConfig {\n+};\n+class\n+    ProxyConfigService {\n+public:\n+  enum ConfigAvailability\n+  { };\n+  class\n+      Observer {\n+  public:\n+    Observer () {\n+    } virtual void\n+    OnProxyConfigChanged (const ProxyConfig &, ConfigAvailability) = 0;\n+  };\n+  virtual void\n+  OnLazyPoll () {\n+  }\n+};\n+}\n+class\n+  ChromeProxyConfigService:\n+  net::ProxyConfigService,\n+    net::ProxyConfigService::Observer {\n+  ConfigAvailability\n+  GetLatestProxyConfig (net::ProxyConfig *);\n+  void\n+  UpdateProxyConfig (ProxyPrefs::ConfigState, const net::ProxyConfig &);\n+  void\n+  OnProxyConfigChanged (const net::ProxyConfig &, ConfigAvailability);\n+  ObserverList <\n+  net::ProxyConfigService::Observer,\n+      0 >\n+      observers_;\n+};\n+void\n+ChromeProxyConfigService::UpdateProxyConfig (ProxyPrefs::ConfigState,\n+    const net::ProxyConfig &) {\n+  net::ProxyConfig new_config;\n+  ConfigAvailability availability = GetLatestProxyConfig (0);\n+net:\n+  ProxyConfigService::Observer * obs;\n+  obs->OnProxyConfigChanged (new_config, availability);\n+}\n+void\n+ChromeProxyConfigService::OnProxyConfigChanged (const net::ProxyConfig &,\n+    ConfigAvailability\n+    availability) {\n+  net::ProxyConfig actual_config;\n+  ObserverListBase <\n+  net::ProxyConfigService::Observer >::Iterator it (observers_);\n+net:\n+  ProxyConfigService::Observer * obs;\n+  if (it.GetNext () )\n+    obs->OnProxyConfigChanged (actual_config, availability);\n+}"}]}