{"sha": "0eb778344e8c1d4e9da37a098bceef7201283432", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGViNzc4MzQ0ZThjMWQ0ZTlkYTM3YTA5OGJjZWVmNzIwMTI4MzQzMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-10T12:24:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-10T12:24:23Z"}, "message": "tree.h (get_pointer_alignment): Remove max-align argument.\n\n2011-08-10  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (get_pointer_alignment): Remove max-align argument.\n\t(get_object_alignment): Likewise.\n\t* builtins.c (get_object_alignment_1): Adjust.\n\t(get_object_alignment): Remove max-align argument.\n\t(get_pointer_alignment): Likewise.\n\t(expand_builtin_strlen): Adjust.\n\t(expand_builtin_memcpy): Likewise.\n\t(expand_builtin_mempcpy_args): Likewise.\n\t(expand_builtin_strncpy): Likewise.\n\t(expand_builtin_memset_args): Likewise.\n\t(expand_builtin_memcmp): Likewise.\n\t(expand_builtin_strcmp): Likewise.\n\t(expand_builtin_strncmp): Likewise.\n\t(get_builtin_sync_mem): Likewise.\n\t(fold_builtin_memset): Likewise.\n\t(fold_builtin_memory_op): Likewise.\n\t(expand_builtin_memory_chk): Likewise.\n\t* emit-rtl.c (get_mem_align_offset): Likewise.\n\t(set_mem_attributes_minus_bitpos): Likewise.\n\t* expr.c (expand_assignment): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t* tree-sra.c (tree_non_mode_aligned_mem_p): Likewise.\n\t* tree-ssa-forwprop.c (simplify_builtin_call): Likewise.\n\t* tree-ssa-loop-ivopts.c (may_be_unaligned_p): Likewise.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Likewise.\n\t* value-prof.c (gimple_stringops_transform): Likewise.\n\nFrom-SVN: r177620", "tree": {"sha": "70e4ef6a2a303c3945f2728ed2723bf45a7fbdfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e4ef6a2a303c3945f2728ed2723bf45a7fbdfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eb778344e8c1d4e9da37a098bceef7201283432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb778344e8c1d4e9da37a098bceef7201283432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb778344e8c1d4e9da37a098bceef7201283432", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb778344e8c1d4e9da37a098bceef7201283432/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c7836f0e86fe744581fb501700206c6b5cabff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7836f0e86fe744581fb501700206c6b5cabff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c7836f0e86fe744581fb501700206c6b5cabff8"}], "stats": {"total": 133, "additions": 72, "deletions": 61}, "files": [{"sha": "33d7dbd93d12f0a7c60ff183bde854ec858a8a59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -1,3 +1,32 @@\n+2011-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (get_pointer_alignment): Remove max-align argument.\n+\t(get_object_alignment): Likewise.\n+\t* builtins.c (get_object_alignment_1): Adjust.\n+\t(get_object_alignment): Remove max-align argument.\n+\t(get_pointer_alignment): Likewise.\n+\t(expand_builtin_strlen): Adjust.\n+\t(expand_builtin_memcpy): Likewise.\n+\t(expand_builtin_mempcpy_args): Likewise.\n+\t(expand_builtin_strncpy): Likewise.\n+\t(expand_builtin_memset_args): Likewise.\n+\t(expand_builtin_memcmp): Likewise.\n+\t(expand_builtin_strcmp): Likewise.\n+\t(expand_builtin_strncmp): Likewise.\n+\t(get_builtin_sync_mem): Likewise.\n+\t(fold_builtin_memset): Likewise.\n+\t(fold_builtin_memory_op): Likewise.\n+\t(expand_builtin_memory_chk): Likewise.\n+\t* emit-rtl.c (get_mem_align_offset): Likewise.\n+\t(set_mem_attributes_minus_bitpos): Likewise.\n+\t* expr.c (expand_assignment): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* tree-sra.c (tree_non_mode_aligned_mem_p): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_builtin_call): Likewise.\n+\t* tree-ssa-loop-ivopts.c (may_be_unaligned_p): Likewise.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Likewise.\n+\t* value-prof.c (gimple_stringops_transform): Likewise.\n+\n 2011-08-10  Paulo J. Matos  <paulo.matos@csr.com>\n \n \t* doc/tm.texi.in (CLASS_MAX_NREGS): Fix typo."}, {"sha": "723e07f42a8503a1a4625065cc9124d1b8cdc785", "filename": "gcc/builtins.c", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -341,7 +341,7 @@ get_object_alignment_1 (tree exp, unsigned HOST_WIDE_INT *bitposp)\n \t  align = MAX (pi->align * BITS_PER_UNIT, align);\n \t}\n       else if (TREE_CODE (addr) == ADDR_EXPR)\n-\talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0), ~0U));\n+\talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0)));\n       bitpos += mem_ref_offset (exp).low * BITS_PER_UNIT;\n     }\n   else if (TREE_CODE (exp) == TARGET_MEM_REF)\n@@ -365,7 +365,7 @@ get_object_alignment_1 (tree exp, unsigned HOST_WIDE_INT *bitposp)\n \t  align = MAX (pi->align * BITS_PER_UNIT, align);\n \t}\n       else if (TREE_CODE (addr) == ADDR_EXPR)\n-\talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0), ~0U));\n+\talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0)));\n       if (TMR_OFFSET (exp))\n \tbitpos += TREE_INT_CST_LOW (TMR_OFFSET (exp)) * BITS_PER_UNIT;\n       if (TMR_INDEX (exp) && TMR_STEP (exp))\n@@ -434,11 +434,10 @@ get_object_alignment_1 (tree exp, unsigned HOST_WIDE_INT *bitposp)\n   return align;\n }\n \n-/* Return the alignment in bits of EXP, an object.\n-   Don't return more than MAX_ALIGN no matter what.  */\n+/* Return the alignment in bits of EXP, an object.  */\n \n unsigned int\n-get_object_alignment (tree exp, unsigned int max_align)\n+get_object_alignment (tree exp)\n {\n   unsigned HOST_WIDE_INT bitpos = 0;\n   unsigned int align;\n@@ -451,7 +450,7 @@ get_object_alignment (tree exp, unsigned int max_align)\n   if (bitpos != 0)\n     align = (bitpos & -bitpos);\n \n-  return MIN (align, max_align);\n+  return align;\n }\n \n /* Returns true iff we can trust that alignment information has been\n@@ -465,20 +464,19 @@ can_trust_pointer_alignment (void)\n }\n \n /* Return the alignment in bits of EXP, a pointer valued expression.\n-   But don't return more than MAX_ALIGN no matter what.\n    The alignment returned is, by default, the alignment of the thing that\n    EXP points to.  If it is not a POINTER_TYPE, 0 is returned.\n \n    Otherwise, look at the expression to see if we can do better, i.e., if the\n    expression is actually pointing at an object whose alignment is tighter.  */\n \n unsigned int\n-get_pointer_alignment (tree exp, unsigned int max_align)\n+get_pointer_alignment (tree exp)\n {\n   STRIP_NOPS (exp);\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n-    return get_object_alignment (TREE_OPERAND (exp, 0), max_align);\n+    return get_object_alignment (TREE_OPERAND (exp, 0));\n   else if (TREE_CODE (exp) == SSA_NAME\n \t   && POINTER_TYPE_P (TREE_TYPE (exp)))\n     {\n@@ -490,7 +488,7 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n \talign = (pi->misalign & -pi->misalign);\n       else\n \talign = pi->align;\n-      return MIN (max_align, align * BITS_PER_UNIT);\n+      return align * BITS_PER_UNIT;\n     }\n \n   return POINTER_TYPE_P (TREE_TYPE (exp)) ? BITS_PER_UNIT : 0;\n@@ -2926,7 +2924,7 @@ expand_builtin_strlen (tree exp, rtx target,\n \t  return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n \t}\n \n-      align = get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+      align = get_pointer_alignment (src) / BITS_PER_UNIT;\n \n       /* If SRC is not a pointer type, don't do this operation inline.  */\n       if (align == 0)\n@@ -3026,9 +3024,8 @@ expand_builtin_memcpy (tree exp, rtx target)\n       tree src = CALL_EXPR_ARG (exp, 1);\n       tree len = CALL_EXPR_ARG (exp, 2);\n       const char *src_str;\n-      unsigned int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-      unsigned int dest_align\n-\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      unsigned int src_align = get_pointer_alignment (src);\n+      unsigned int dest_align = get_pointer_alignment (dest);\n       rtx dest_mem, src_mem, dest_addr, len_rtx;\n       HOST_WIDE_INT expected_size = -1;\n       unsigned int expected_align = 0;\n@@ -3135,9 +3132,8 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n   else\n     {\n       const char *src_str;\n-      unsigned int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-      unsigned int dest_align\n-\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      unsigned int src_align = get_pointer_alignment (src);\n+      unsigned int dest_align = get_pointer_alignment (dest);\n       rtx dest_mem, src_mem, len_rtx;\n \n       /* If either SRC or DEST is not a pointer type, don't do this\n@@ -3390,8 +3386,7 @@ expand_builtin_strncpy (tree exp, rtx target)\n \t use store_by_pieces, if it fails, punt.  */\n       if (tree_int_cst_lt (slen, len))\n \t{\n-\t  unsigned int dest_align\n-\t    = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\t  unsigned int dest_align = get_pointer_alignment (dest);\n \t  const char *p = c_getstr (src);\n \t  rtx dest_mem;\n \n@@ -3495,7 +3490,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   HOST_WIDE_INT expected_size = -1;\n   unsigned int expected_align = 0;\n \n-  dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+  dest_align = get_pointer_alignment (dest);\n \n   /* If DEST is not a pointer type, don't do this operation in-line.  */\n   if (dest_align == 0)\n@@ -3657,10 +3652,8 @@ expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n     tree arg2 = CALL_EXPR_ARG (exp, 1);\n     tree len = CALL_EXPR_ARG (exp, 2);\n \n-    unsigned int arg1_align\n-      = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-    unsigned int arg2_align\n-      = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+    unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n+    unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n     enum machine_mode insn_mode;\n \n #ifdef HAVE_cmpmemsi\n@@ -3759,10 +3752,8 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n       tree arg1 = CALL_EXPR_ARG (exp, 0);\n       tree arg2 = CALL_EXPR_ARG (exp, 1);\n \n-      unsigned int arg1_align\n-\t= get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-      unsigned int arg2_align\n-\t= get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+      unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n+      unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n \n       /* If we don't have POINTER_TYPE, call the function.  */\n       if (arg1_align == 0 || arg2_align == 0)\n@@ -3910,10 +3901,8 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n     tree arg2 = CALL_EXPR_ARG (exp, 1);\n     tree arg3 = CALL_EXPR_ARG (exp, 2);\n \n-    unsigned int arg1_align\n-      = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-    unsigned int arg2_align\n-      = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+    unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n+    unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n     enum machine_mode insn_mode\n       = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n \n@@ -5087,7 +5076,7 @@ get_builtin_sync_mem (tree loc, enum machine_mode mode)\n \n   /* The alignment needs to be at least according to that of the mode.  */\n   set_mem_align (mem, MAX (GET_MODE_ALIGNMENT (mode),\n-\t\t\t   get_pointer_alignment (loc, BIGGEST_ALIGNMENT)));\n+\t\t\t   get_pointer_alignment (loc)));\n   set_mem_alias_set (mem, ALIAS_SET_MEMORY_BARRIER);\n   MEM_VOLATILE_P (mem) = 1;\n \n@@ -7891,8 +7880,7 @@ fold_builtin_memset (location_t loc, tree dest, tree c, tree len,\n \n   length = tree_low_cst (len, 1);\n   if (GET_MODE_SIZE (TYPE_MODE (etype)) != length\n-      || get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT\n-\t < length)\n+      || get_pointer_alignment (dest) / BITS_PER_UNIT < length)\n     return NULL_TREE;\n \n   if (length > HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT)\n@@ -7982,8 +7970,8 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \n       if (endp == 3)\n \t{\n-\t  src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-\t  dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\t  src_align = get_pointer_alignment (src);\n+\t  dest_align = get_pointer_alignment (dest);\n \n \t  /* Both DEST and SRC must be pointer types.\n \t     ??? This is what old code did.  Is the testing for pointer types\n@@ -8131,8 +8119,8 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t  || TREE_ADDRESSABLE (desttype))\n \treturn NULL_TREE;\n \n-      src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-      dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      src_align = get_pointer_alignment (src);\n+      dest_align = get_pointer_alignment (dest);\n       if (dest_align < TYPE_ALIGN (desttype)\n \t  || src_align < TYPE_ALIGN (srctype))\n \treturn NULL_TREE;\n@@ -11696,8 +11684,7 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n     return NULL_RTX;\n   else\n     {\n-      unsigned int dest_align\n-\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      unsigned int dest_align = get_pointer_alignment (dest);\n \n       /* If DEST is not a pointer type, call the normal function.  */\n       if (dest_align == 0)\n@@ -11722,8 +11709,7 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n       /* __memmove_chk special case.  */\n       if (fcode == BUILT_IN_MEMMOVE_CHK)\n \t{\n-\t  unsigned int src_align\n-\t    = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+\t  unsigned int src_align = get_pointer_alignment (src);\n \n \t  if (src_align == 0)\n \t    return NULL_RTX;"}, {"sha": "25628e40bc2a642910a44722e0e04d1f3dfd8cff", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -1466,7 +1466,7 @@ get_mem_align_offset (rtx mem, unsigned int align)\n   /* This function can't use\n      if (!MEM_EXPR (mem) || !MEM_OFFSET_KNOWN_P (mem)\n \t || (MAX (MEM_ALIGN (mem),\n-\t          get_object_alignment (MEM_EXPR (mem), align))\n+\t          MAX (align, get_object_alignment (MEM_EXPR (mem))))\n \t     < align))\n        return -1;\n      else\n@@ -1826,9 +1826,9 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  apply_bitpos = bitpos;\n \t}\n \n-      if (!align_computed && !INDIRECT_REF_P (t))\n+      if (!align_computed)\n \t{\n-\t  unsigned int obj_align = get_object_alignment (t, BIGGEST_ALIGNMENT);\n+\t  unsigned int obj_align = get_object_alignment (t);\n \t  attrs.align = MAX (attrs.align, obj_align);\n \t}\n     }"}, {"sha": "f0b76e187b7725649785896cdb41c479100e11d6", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -4440,8 +4440,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   if ((TREE_CODE (to) == MEM_REF\n        || TREE_CODE (to) == TARGET_MEM_REF)\n       && mode != BLKmode\n-      && ((align = MAX (TYPE_ALIGN (TREE_TYPE (to)),\n-\t\t\tget_object_alignment (to, BIGGEST_ALIGNMENT)))\n+      && ((align = MAX (TYPE_ALIGN (TREE_TYPE (to)), get_object_alignment (to)))\n \t  < (signed) GET_MODE_ALIGNMENT (mode))\n       && ((icode = optab_handler (movmisalign_optab, mode))\n \t  != CODE_FOR_nothing))\n@@ -9046,8 +9045,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, exp, 0);\n \tset_mem_addr_space (temp, as);\n-\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)),\n-\t\t     get_object_alignment (exp, BIGGEST_ALIGNMENT));\n+\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)), get_object_alignment (exp));\n \tif (mode != BLKmode\n \t    && (unsigned) align < GET_MODE_ALIGNMENT (mode)\n \t    /* If the target does not have special handling for unaligned\n@@ -9127,8 +9125,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t   gimple_assign_rhs1 (def_stmt), mask);\n \t    TREE_OPERAND (exp, 0) = base;\n \t  }\n-\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)),\n-\t\t     get_object_alignment (exp, BIGGEST_ALIGNMENT));\n+\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)), get_object_alignment (exp));\n \top0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address_addr_space (address_mode, op0, as);\n \tif (!integer_zerop (TREE_OPERAND (exp, 1)))"}, {"sha": "2d97845ffe672185f73601a0c1f6ab06c073cfcd", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -1085,7 +1085,7 @@ tree_non_mode_aligned_mem_p (tree exp)\n       || !STRICT_ALIGNMENT)\n     return false;\n \n-  align = get_object_alignment (exp, BIGGEST_ALIGNMENT);\n+  align = get_object_alignment (exp);\n   if (GET_MODE_ALIGNMENT (mode) > align)\n     return true;\n "}, {"sha": "afbe525b99d9f079c1a373ea342c5efc190662a3", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -1509,7 +1509,7 @@ simplify_builtin_call (gimple_stmt_iterator *gsi_p, tree callee2)\n \t\t  || use_stmt != stmt2))\n \t    break;\n \n-\t  ptr1_align = get_pointer_alignment (ptr1, BIGGEST_ALIGNMENT);\n+\t  ptr1_align = get_pointer_alignment (ptr1);\n \t  /* Construct the new source string literal.  */\n \t  src_buf = XALLOCAVEC (char, src_len + 1);\n \t  if (callee1)"}, {"sha": "79fff3f4eaea935598d4eeee1baabda7ff08b201", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -1635,7 +1635,7 @@ may_be_unaligned_p (tree ref, tree step)\n   base = get_inner_reference (ref, &bitsize, &bitpos, &toffset, &mode,\n \t\t\t      &unsignedp, &volatilep, true);\n   base_type = TREE_TYPE (base);\n-  base_align = get_object_alignment (base, BIGGEST_ALIGNMENT);\n+  base_align = get_object_alignment (base);\n   base_align = MAX (base_align, TYPE_ALIGN (base_type));\n \n   if (mode != BLKmode)"}, {"sha": "e4d32e9d277fe5a83144ffe8fe40551e507907c6", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -860,8 +860,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t  && tree_int_cst_compare (ssize_int (TYPE_ALIGN_UNIT (TREE_TYPE (\n \t\t\t\t\t\t      TREE_TYPE (base_addr)))),\n \t\t\t\t   alignment) >= 0)\n-      || (get_pointer_alignment (base_addr, TYPE_ALIGN (vectype))\n-\t  >= TYPE_ALIGN (vectype)))\n+      || (get_pointer_alignment (base_addr) >= TYPE_ALIGN (vectype)))\n     base_aligned = true;\n   else\n     base_aligned = false;"}, {"sha": "2fa5999c615c43552c9182bd17034763bae08681", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -5359,11 +5359,11 @@ extern tree build_string_literal (int, const char *);\n extern bool validate_arglist (const_tree, ...);\n extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n extern bool can_trust_pointer_alignment (void);\n-extern unsigned int get_pointer_alignment (tree, unsigned int);\n extern bool is_builtin_name (const char *);\n extern bool is_builtin_fn (tree);\n extern unsigned int get_object_alignment_1 (tree, unsigned HOST_WIDE_INT *);\n-extern unsigned int get_object_alignment (tree, unsigned int);\n+extern unsigned int get_object_alignment (tree);\n+extern unsigned int get_pointer_alignment (tree);\n extern tree fold_call_stmt (gimple, bool);\n extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);\n extern tree make_range (tree, int *, tree *, tree *, bool *);"}, {"sha": "2df04f56813761811a976c276d3b496c162a67ad", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb778344e8c1d4e9da37a098bceef7201283432/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=0eb778344e8c1d4e9da37a098bceef7201283432", "patch": "@@ -1528,13 +1528,13 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n   else\n     prob = 0;\n   dest = gimple_call_arg (stmt, 0);\n-  dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+  dest_align = get_pointer_alignment (dest);\n   switch (fcode)\n     {\n     case BUILT_IN_MEMCPY:\n     case BUILT_IN_MEMPCPY:\n       src = gimple_call_arg (stmt, 1);\n-      src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+      src_align = get_pointer_alignment (src);\n       if (!can_move_by_pieces (val, MIN (dest_align, src_align)))\n \treturn false;\n       break;"}]}