{"sha": "1af3f4a2893203492cce59b72eff3f7bb4aef04c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFmM2Y0YTI4OTMyMDM0OTJjY2U1OWI3MmVmZjNmN2JiNGFlZjA0Yw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-12-31T00:05:01Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-12-31T00:27:06Z"}, "message": "d: Mangled Symbols now back reference types and identifiers\n\nSymbols with extern(D) linkage are now mangled using back references to\ntypes and identifiers if these occur more than once in the mangled name\nas emitted before.  This reduces symbol length, especially with chained\nexpressions of templated functions with Voldemort return types.\n\nFor example, the average symbol length of the 127000+ symbols created by\na libphobos unittest build is reduced by a factor of about 3, while the\nlongest symbol shrinks from 416133 to 1142 characters.\n\nReviewed-on: https://github.com/dlang/dmd/pull/12079\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 2bd4fc3fe.", "tree": {"sha": "dbd1963ce9412308ada1f4e24b98ee9b6376c9c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbd1963ce9412308ada1f4e24b98ee9b6376c9c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1af3f4a2893203492cce59b72eff3f7bb4aef04c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af3f4a2893203492cce59b72eff3f7bb4aef04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af3f4a2893203492cce59b72eff3f7bb4aef04c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af3f4a2893203492cce59b72eff3f7bb4aef04c/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5478fec4455d312396d0756f9048fc478453370d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5478fec4455d312396d0756f9048fc478453370d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5478fec4455d312396d0756f9048fc478453370d"}], "stats": {"total": 657, "additions": 429, "deletions": 228}, "files": [{"sha": "1f695b9d23c30f281cf1167e2fae65a84db312ee", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -1,4 +1,4 @@\n-45fa6cfd20827bb4252a616dc789514a1e673687\n+2bd4fc3fed8b8cd9760e77c6b2a1905cd84d0e70\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "f6eee52afbf04ff19b79619e284168ad90ae62da", "filename": "gcc/d/dmd/dmangle.c", "status": "modified", "additions": 267, "deletions": 52, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -10,6 +10,7 @@\n \n #include \"root/dsystem.h\"\n #include \"root/root.h\"\n+#include \"root/aav.h\"\n \n #include \"mangle.h\"\n #include \"init.h\"\n@@ -133,13 +134,114 @@ void MODtoDecoBuffer(OutBuffer *buf, MOD mod)\n class Mangler : public Visitor\n {\n public:\n+    AA *types;\n+    AA *idents;\n     OutBuffer *buf;\n \n     Mangler(OutBuffer *buf)\n     {\n+        this->types = NULL;\n+        this->idents = NULL;\n         this->buf = buf;\n     }\n \n+    /**\n+    * writes a back reference with the relative position encoded with base 26\n+    *  using upper case letters for all digits but the last digit which uses\n+    *  a lower case letter.\n+    * The decoder has to look up the referenced position to determine\n+    *  whether the back reference is an identifer (starts with a digit)\n+    *  or a type (starts with a letter).\n+    *\n+    * Params:\n+    *  pos           = relative position to encode\n+    */\n+    void writeBackRef(size_t pos)\n+    {\n+        buf->writeByte('Q');\n+        const size_t base = 26;\n+        size_t mul = 1;\n+        while (pos >= mul * base)\n+            mul *= base;\n+        while (mul >= base)\n+        {\n+            unsigned char dig = (unsigned char)(pos / mul);\n+            buf->writeByte('A' + dig);\n+            pos -= dig * mul;\n+            mul /= base;\n+        }\n+        buf->writeByte('a' + (unsigned char)pos);\n+    }\n+\n+    /**\n+    * Back references a non-basic type\n+    *\n+    * The encoded mangling is\n+    *       'Q' <relative position of first occurrence of type>\n+    *\n+    * Params:\n+    *  t = the type to encode via back referencing\n+    *\n+    * Returns:\n+    *  true if the type was found. A back reference has been encoded.\n+    *  false if the type was not found. The current position is saved for later back references.\n+    */\n+    bool backrefType(Type *t)\n+    {\n+        if (!t->isTypeBasic())\n+        {\n+            size_t *p = (size_t *)dmd_aaGet(&types, (void *)t);\n+            if (*p)\n+            {\n+                writeBackRef(buf->length() - *p);\n+                return true;\n+            }\n+            *p = buf->length();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+    * Back references a single identifier\n+    *\n+    * The encoded mangling is\n+    *       'Q' <relative position of first occurrence of type>\n+    *\n+    * Params:\n+    *  id = the identifier to encode via back referencing\n+    *\n+    * Returns:\n+    *  true if the identifier was found. A back reference has been encoded.\n+    *  false if the identifier was not found. The current position is saved for later back references.\n+    */\n+    bool backrefIdentifier(Identifier *id)\n+    {\n+        size_t *p = (size_t *)dmd_aaGet(&idents, (void *)id);\n+        if (*p)\n+        {\n+            writeBackRef(buf->length() - *p);\n+            return true;\n+        }\n+        *p = buf->length();\n+        return false;\n+    }\n+\n+    void mangleSymbol(Dsymbol *s)\n+    {\n+        s->accept(this);\n+    }\n+\n+    void mangleType(Type *t)\n+    {\n+        if (!backrefType(t))\n+            t->accept(this);\n+    }\n+\n+    void mangleIdentifier(Identifier *id, Dsymbol *s)\n+    {\n+        if (!backrefIdentifier(id))\n+            toBuffer(id->toChars(), s);\n+    }\n \n     ////////////////////////////////////////////////////////////////////////////\n \n@@ -153,7 +255,7 @@ class Mangler : public Visitor\n         {\n             MODtoDecoBuffer(buf, t->mod);\n         }\n-        t->accept(this);\n+        mangleType(t);\n     }\n \n     void visit(Type *t)\n@@ -207,8 +309,9 @@ class Mangler : public Visitor\n     void mangleFuncType(TypeFunction *t, TypeFunction *ta, unsigned char modMask, Type *tret)\n     {\n         //printf(\"mangleFuncType() %s\\n\", t->toChars());\n-        if (t->inuse)\n+        if (t->inuse && tret)\n         {\n+            // printf(\"TypeFunction.mangleFuncType() t = %s inuse\\n\", t->toChars());\n             t->inuse = 2;       // flag error to caller\n             return;\n         }\n@@ -280,35 +383,29 @@ class Mangler : public Visitor\n     void visit(TypeEnum *t)\n     {\n         visit((Type *)t);\n-        t->sym->accept(this);\n+        mangleSymbol(t->sym);\n     }\n \n     void visit(TypeStruct *t)\n     {\n         //printf(\"TypeStruct::toDecoBuffer('%s') = '%s'\\n\", t->toChars(), name);\n         visit((Type *)t);\n-        t->sym->accept(this);\n+        mangleSymbol(t->sym);\n     }\n \n     void visit(TypeClass *t)\n     {\n         //printf(\"TypeClass::toDecoBuffer('%s' mod=%x) = '%s'\\n\", t->toChars(), mod, name);\n         visit((Type *)t);\n-        t->sym->accept(this);\n+        mangleSymbol(t->sym);\n     }\n \n     void visit(TypeTuple *t)\n     {\n         //printf(\"TypeTuple::toDecoBuffer() t = %p, %s\\n\", t, t->toChars());\n         visit((Type *)t);\n-\n-        OutBuffer buf2;\n-        buf2.reserve(32);\n-        Mangler v(&buf2);\n-        v.paramsToDecoBuffer(t->arguments);\n-        const char *s = buf2.peekChars();\n-        int len = (int)buf2.length();\n-        buf->printf(\"%d%.*s\", len, len, s);\n+        paramsToDecoBuffer(t->arguments);\n+        buf->writeByte('Z');\n     }\n \n     void visit(TypeNull *t)\n@@ -323,16 +420,14 @@ class Mangler : public Visitor\n         mangleParent(sthis);\n \n         assert(sthis->ident);\n-        const char *id = sthis->ident->toChars();\n-        toBuffer(id, sthis);\n-\n+        mangleIdentifier(sthis->ident, sthis);\n         if (FuncDeclaration *fd = sthis->isFuncDeclaration())\n         {\n             mangleFunc(fd, false);\n         }\n-        else if (sthis->type->deco)\n+        else if (sthis->type)\n         {\n-            buf->writestring(sthis->type->deco);\n+            visitWithMask(sthis->type, 0);\n         }\n         else\n             assert(0);\n@@ -349,12 +444,14 @@ class Mangler : public Visitor\n         if (p)\n         {\n             mangleParent(p);\n-\n-            if (p->getIdent())\n+            TemplateInstance *ti = p->isTemplateInstance();\n+            if (ti && !ti->isTemplateMixin())\n             {\n-                const char *id = p->ident->toChars();\n-                toBuffer(id, s);\n-\n+                mangleTemplateInstance(ti);\n+            }\n+            else if (p->getIdent())\n+            {\n+                mangleIdentifier(p->ident, s);\n                 if (FuncDeclaration *f = p->isFuncDeclaration())\n                     mangleFunc(f, true);\n             }\n@@ -375,13 +472,13 @@ class Mangler : public Visitor\n             TypeFunction *tfo = (TypeFunction *)fd->originalType;\n             mangleFuncType(tf, tfo, 0, NULL);\n         }\n-        else if (fd->type->deco)\n+        else if (fd->type)\n         {\n-            buf->writestring(fd->type->deco);\n+            visitWithMask(fd->type, 0);\n         }\n         else\n         {\n-            printf(\"[%s] %s %s\\n\", fd->loc.toChars(), fd->toChars(), fd->type->toChars());\n+            printf(\"[%s] %s no type\\n\", fd->loc.toChars(), fd->toChars());\n             assert(0);  // don't mangle function until semantic3 done.\n         }\n     }\n@@ -392,48 +489,49 @@ class Mangler : public Visitor\n     void toBuffer(const char *id, Dsymbol *s)\n     {\n         size_t len = strlen(id);\n-        if (len >= 8 * 1024 * 1024)         // 8 megs ought be enough for anyone\n-            s->error(\"excessive length %llu for symbol, possible recursive expansion?\", len);\n+        if (buf->length() + len >= 8 * 1024 * 1024) // 8 megs ought be enough for anyone\n+            s->error(\"excessive length %llu for symbol, possible recursive expansion?\", buf->length() + len);\n         else\n         {\n             buf->printf(\"%llu\", (ulonglong)len);\n             buf->write(id, len);\n         }\n     }\n \n-    void visit(Declaration *d)\n+    static const char *externallyMangledIdentifier(Declaration *d)\n     {\n-        //printf(\"Declaration::mangle(this = %p, '%s', parent = '%s', linkage = %d)\\n\",\n-        //        d, d->toChars(), d->parent ? d->parent->toChars() : \"null\", d->linkage);\n         if (!d->parent || d->parent->isModule() || d->linkage == LINKcpp) // if at global scope\n         {\n             switch (d->linkage)\n             {\n                 case LINKd:\n                     break;\n-\n                 case LINKc:\n                 case LINKwindows:\n                 case LINKobjc:\n-                    buf->writestring(d->ident->toChars());\n-                    return;\n-\n+                    return d->ident->toChars();\n                 case LINKcpp:\n-                    buf->writestring(target.cpp.toMangle(d));\n-                    return;\n-\n+                    return target.cpp.toMangle(d);\n                 case LINKdefault:\n                     d->error(\"forward declaration\");\n-                    buf->writestring(d->ident->toChars());\n-                    return;\n-\n+                    return d->ident->toChars();\n                 default:\n                     fprintf(stderr, \"'%s', linkage = %d\\n\", d->toChars(), d->linkage);\n                     assert(0);\n-                    return;\n             }\n         }\n+        return NULL;\n+    }\n \n+    void visit(Declaration *d)\n+    {\n+        //printf(\"Declaration::mangle(this = %p, '%s', parent = '%s', linkage = %d)\\n\",\n+        //        d, d->toChars(), d->parent ? d->parent->toChars() : \"null\", d->linkage);\n+        if (const char *id = externallyMangledIdentifier(d))\n+        {\n+            buf->writestring(id);\n+            return;\n+        }\n         buf->writestring(\"_D\");\n         mangleDecl(d);\n     }\n@@ -481,7 +579,7 @@ class Mangler : public Visitor\n         }\n         if (fa)\n         {\n-            fa->accept(this);\n+            mangleSymbol(fa);\n             return;\n         }\n         visit((Dsymbol *)fd);\n@@ -507,7 +605,7 @@ class Mangler : public Visitor\n         {\n             if (!od->hasOverloads || td->overnext == NULL)\n             {\n-                td->accept(this);\n+                mangleSymbol(td);\n                 return;\n             }\n         }\n@@ -586,20 +684,131 @@ class Mangler : public Visitor\n         else\n             mangleParent(ti);\n \n-        ti->getIdent();\n-        const char *id = ti->ident ? ti->ident->toChars() : ti->toChars();\n-        toBuffer(id, ti);\n+        if (ti->isTemplateMixin() && ti->ident)\n+            mangleIdentifier(ti->ident, ti);\n+        else\n+            mangleTemplateInstance(ti);\n+    }\n+\n+    void mangleTemplateInstance(TemplateInstance *ti)\n+    {\n+        TemplateDeclaration *tempdecl = ti->tempdecl->isTemplateDeclaration();\n+        assert(tempdecl);\n+\n+        // Use \"__U\" for the symbols declared inside template constraint.\n+        const char T = ti->members ? 'T' : 'U';\n+        buf->printf(\"__%c\", T);\n+        mangleIdentifier(tempdecl->ident, tempdecl);\n \n-        //printf(\"TemplateInstance::mangle() %s = %s\\n\", ti->toChars(), ti->id);\n+        Objects *args = ti->tiargs;\n+        size_t nparams = tempdecl->parameters->length - (tempdecl->isVariadic() ? 1 : 0);\n+        for (size_t i = 0; i < args->length; i++)\n+        {\n+            RootObject *o = (*args)[i];\n+            Type *ta = isType(o);\n+            Expression *ea = isExpression(o);\n+            Dsymbol *sa = isDsymbol(o);\n+            Tuple *va = isTuple(o);\n+            //printf(\"\\to [%d] %p ta %p ea %p sa %p va %p\\n\", i, o, ta, ea, sa, va);\n+            if (i < nparams && (*tempdecl->parameters)[i]->specialization())\n+                buf->writeByte('H'); // https://issues.dlang.org/show_bug.cgi?id=6574\n+            if (ta)\n+            {\n+                buf->writeByte('T');\n+                visitWithMask(ta, 0);\n+            }\n+            else if (ea)\n+            {\n+                // Don't interpret it yet, it might actually be an alias template parameter.\n+                // Only constfold manifest constants, not const/immutable lvalues, see https://issues.dlang.org/show_bug.cgi?id=17339.\n+                const bool keepLvalue = true;\n+                ea = ea->optimize(WANTvalue, keepLvalue);\n+                if (ea->op == TOKvar)\n+                {\n+                    sa = ((VarExp *)ea)->var;\n+                    ea = NULL;\n+                    goto Lsa;\n+                }\n+                if (ea->op == TOKthis)\n+                {\n+                    sa = ((ThisExp *)ea)->var;\n+                    ea = NULL;\n+                    goto Lsa;\n+                }\n+                if (ea->op == TOKfunction)\n+                {\n+                    if (((FuncExp *)ea)->td)\n+                        sa = ((FuncExp *)ea)->td;\n+                    else\n+                        sa = ((FuncExp *)ea)->fd;\n+                    ea = NULL;\n+                    goto Lsa;\n+                }\n+                buf->writeByte('V');\n+                if (ea->op == TOKtuple)\n+                {\n+                    ea->error(\"tuple is not a valid template value argument\");\n+                    continue;\n+                }\n+                // Now that we know it is not an alias, we MUST obtain a value\n+                unsigned olderr = global.errors;\n+                ea = ea->ctfeInterpret();\n+                if (ea->op == TOKerror || olderr != global.errors)\n+                    continue;\n+\n+                /* Use type mangling that matches what it would be for a function parameter\n+                */\n+                visitWithMask(ea->type, 0);\n+                ea->accept(this);\n+            }\n+            else if (sa)\n+            {\n+            Lsa:\n+                sa = sa->toAlias();\n+                if (Declaration *d = sa->isDeclaration())\n+                {\n+                    if (FuncAliasDeclaration *fad = d->isFuncAliasDeclaration())\n+                        d = fad->toAliasFunc();\n+                    if (d->mangleOverride.length)\n+                    {\n+                        buf->writeByte('X');\n+                        toBuffer(d->mangleOverride.ptr, d);\n+                        continue;\n+                    }\n+                    if (const char *id = externallyMangledIdentifier(d))\n+                    {\n+                        buf->writeByte('X');\n+                        toBuffer(id, d);\n+                        continue;\n+                    }\n+                    if (!d->type || !d->type->deco)\n+                    {\n+                        ti->error(\"forward reference of %s %s\", d->kind(), d->toChars());\n+                        continue;\n+                    }\n+                }\n+                buf->writeByte('S');\n+                mangleSymbol(sa);\n+            }\n+            else if (va)\n+            {\n+                assert(i + 1 == args->length); // must be last one\n+                args = &va->objects;\n+                i = -(size_t)1;\n+            }\n+            else\n+                assert(0);\n+        }\n+        buf->writeByte('Z');\n     }\n \n     void visit(Dsymbol *s)\n     {\n         mangleParent(s);\n-\n-        const char *id = s->ident ? s->ident->toChars() : s->toChars();\n-        toBuffer(id, s);\n-\n+        if (s->ident)\n+            mangleIdentifier(s->ident, s);\n+        else\n+            toBuffer(s->toChars(), s);\n         //printf(\"Dsymbol::mangle() %s = %s\\n\", s->toChars(), id);\n     }\n \n@@ -859,3 +1068,9 @@ void mangleToBuffer(Dsymbol *s, OutBuffer *buf)\n     Mangler v(buf);\n     s->accept(&v);\n }\n+\n+void mangleToBuffer(TemplateInstance *ti, OutBuffer *buf)\n+{\n+    Mangler v(buf);\n+    v.mangleTemplateInstance(ti);\n+}"}, {"sha": "fe65bd23e3cf71461a213dc0b08d55500dd49743", "filename": "gcc/d/dmd/dtemplate.c", "status": "modified", "additions": 3, "deletions": 113, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -7546,122 +7546,12 @@ Dsymbols *TemplateInstance::appendToModuleMember()\n \n Identifier *TemplateInstance::genIdent(Objects *args)\n {\n-    TemplateDeclaration *tempdecl = this->tempdecl->isTemplateDeclaration();\n-    assert(tempdecl);\n-\n     //printf(\"TemplateInstance::genIdent('%s')\\n\", tempdecl->ident->toChars());\n+    assert(args == tiargs);\n     OutBuffer buf;\n-    const char *id = tempdecl->ident->toChars();\n-    if (!members)\n-    {\n-        // Use \"__U\" for the symbols declared inside template constraint.\n-        buf.printf(\"__U%llu%s\", (ulonglong)strlen(id), id);\n-    }\n-    else\n-        buf.printf(\"__T%llu%s\", (ulonglong)strlen(id), id);\n-    size_t nparams = tempdecl->parameters->length - (tempdecl->isVariadic() ? 1 : 0);\n-    for (size_t i = 0; i < args->length; i++)\n-    {\n-        RootObject *o = (*args)[i];\n-        Type *ta = isType(o);\n-        Expression *ea = isExpression(o);\n-        Dsymbol *sa = isDsymbol(o);\n-        Tuple *va = isTuple(o);\n-        //printf(\"\\to [%d] %p ta %p ea %p sa %p va %p\\n\", i, o, ta, ea, sa, va);\n-        if (i < nparams && (*tempdecl->parameters)[i]->specialization())\n-            buf.writeByte('H');     // Bugzilla 6574\n-        if (ta)\n-        {\n-            buf.writeByte('T');\n-            if (ta->deco)\n-                buf.writestring(ta->deco);\n-            else\n-            {\n-                assert(global.errors);\n-            }\n-        }\n-        else if (ea)\n-        {\n-            // Don't interpret it yet, it might actually be an alias template parameter.\n-            // Only constfold manifest constants, not const/immutable lvalues, see https://issues.dlang.org/show_bug.cgi?id=17339.\n-            const bool keepLvalue = true;\n-            ea = ea->optimize(WANTvalue, keepLvalue);\n-            if (ea->op == TOKvar)\n-            {\n-                sa = ((VarExp *)ea)->var;\n-                ea = NULL;\n-                goto Lsa;\n-            }\n-            if (ea->op == TOKthis)\n-            {\n-                sa = ((ThisExp *)ea)->var;\n-                ea = NULL;\n-                goto Lsa;\n-            }\n-            if (ea->op == TOKfunction)\n-            {\n-                if (((FuncExp *)ea)->td)\n-                    sa = ((FuncExp *)ea)->td;\n-                else\n-                    sa = ((FuncExp *)ea)->fd;\n-                ea = NULL;\n-                goto Lsa;\n-            }\n-            buf.writeByte('V');\n-            if (ea->op == TOKtuple)\n-            {\n-                ea->error(\"tuple is not a valid template value argument\");\n-                continue;\n-            }\n-            // Now that we know it is not an alias, we MUST obtain a value\n-            unsigned olderr = global.errors;\n-            ea = ea->ctfeInterpret();\n-            if (ea->op == TOKerror || olderr != global.errors)\n-                continue;\n-\n-            /* Use deco that matches what it would be for a function parameter\n-             */\n-            buf.writestring(ea->type->deco);\n-            mangleToBuffer(ea, &buf);\n-        }\n-        else if (sa)\n-        {\n-          Lsa:\n-            buf.writeByte('S');\n-            sa = sa->toAlias();\n-            Declaration *d = sa->isDeclaration();\n-            if (d && (!d->type || !d->type->deco))\n-            {\n-                error(\"forward reference of %s %s\", d->kind(), d->toChars());\n-                continue;\n-            }\n-\n-            OutBuffer bufsa;\n-            mangleToBuffer(sa, &bufsa);\n-            const char *s = bufsa.extractChars();\n-\n-            /* Bugzilla 3043: if the first character of s is a digit this\n-             * causes ambiguity issues because the digits of the two numbers are adjacent.\n-             * Current demanglers resolve this by trying various places to separate the\n-             * numbers until one gets a successful demangle.\n-             * Unfortunately, fixing this ambiguity will break existing binary\n-             * compatibility and the demanglers, so we'll leave it as is.\n-             */\n-            buf.printf(\"%u%s\", (unsigned)strlen(s), s);\n-        }\n-        else if (va)\n-        {\n-            assert(i + 1 == args->length);         // must be last one\n-            args = &va->objects;\n-            i = -(size_t)1;\n-        }\n-        else\n-            assert(0);\n-    }\n-    buf.writeByte('Z');\n-    id = buf.peekChars();\n+    mangleToBuffer(this, &buf);\n     //printf(\"\\tgenIdent = %s\\n\", id);\n-    return Identifier::idPool(id);\n+    return Identifier::idPool(buf.peekChars());\n }\n \n /*************************************"}, {"sha": "5a8e1e26ac68d3528828cba3f0eb18c4905fb5d2", "filename": "gcc/testsuite/gdc.test/compilable/testInference.d", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestInference.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestInference.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestInference.d?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -261,11 +261,13 @@ void test8234()\n /***************************************************/\n // 8504\n \n+import core.demangle : demangle;\n+\n void foo8504()()\n {\n     static assert(typeof(foo8504!()).stringof == \"void()\");\n     static assert(typeof(foo8504!()).mangleof == \"FZv\");\n-    static assert(foo8504!().mangleof == \"_D13testInference12__T7foo8504Z7foo8504FZv\");\n+    static assert(demangle(foo8504!().mangleof) == \"void testInference.foo8504!().foo8504()\");\n }\n \n auto toDelegate8504a(F)(auto ref F fp) { return fp; }\n@@ -277,7 +279,7 @@ void test8504()\n {\n     static assert(typeof(foo8504!()).stringof == \"pure nothrow @nogc @safe void()\");\n     static assert(typeof(foo8504!()).mangleof == \"FNaNbNiNfZv\");\n-    static assert(foo8504!().mangleof == \"_D13testInference12__T7foo8504Z7foo8504FNaNbNiNfZv\");\n+    static assert(demangle(foo8504!().mangleof) == \"pure nothrow @nogc @safe void testInference.foo8504!().foo8504()\");\n \n     auto fp1 = toDelegate8504a(&testC8504);\n     auto fp2 = toDelegate8504b(&testC8504);"}, {"sha": "e1b15774f818b7536a4d4f205b21017298e11477", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail12485.d", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12485.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12485.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12485.d?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -1,11 +1,12 @@\n void dorecursive()\n {\n-    recursive([0]);\n+    recursive!\"ratherLongSymbolNameToHitTheMaximumSymbolLengthEarlierThanTheTemplateRecursionLimit_\";\n }\n \n-void recursive(R)(R r)\n+void recursive(string name)()\n {\n-    import std.algorithm;\n-    recursive( r.filter!(e=>true) );\n+    struct S {} // define type to kick off mangler\n+    static if (name.length <= (4 << 20))\n+        recursive!(name ~ name);\n }\n "}, {"sha": "5311a8360daeb6d2790b5e01ca26e2803120f345", "filename": "gcc/testsuite/gdc.test/runnable/imports/testmangle.d", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftestmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftestmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftestmangle.d?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -0,0 +1,66 @@\n+// helper for mangling tests with back references\n+\n+module imports.testmangle;\n+\n+public import core.demangle : demangle, demangleType;\n+\n+// detect mangle version\n+private\n+{\n+    struct Detect;\n+    Detect* detectMangle(Detect*);\n+    void DetectTmpl(T)() {}\n+}\n+\n+pragma(msg,detectMangle.mangleof);\n+static if(detectMangle.mangleof == \"_D7imports10testmangle12detectMangleFPSQL3H6DetectZQ1e\")\n+    enum { BackRefs = true, BackRefSymbols = true }\n+else static if(detectMangle.mangleof == \"_D7imports10testmangle12detectMangleFPSQBlQBg6DetectZQq\")\n+    enum { BackRefs = true, BackRefSymbols = false }\n+else static if(detectMangle.mangleof == \"_D7imports10testmangle12detectMangleFPS7imports10testmangle6DetectZPS7imports10testmangle6Detect\")\n+    enum { BackRefs = false, BackRefSymbols = false }\n+else\n+    static assert(false, \"unknown mangling\");\n+\n+private enum tmplMangle = (DetectTmpl!int).mangleof;\n+pragma(msg,tmplMangle);\n+static if(tmplMangle[0..40] == \"_D7imports10testmangle__T10DetectTmplTiZ\")\n+    enum HasTemplateLength = false;\n+else static if(tmplMangle[0..42] == \"_D7imports10testmangle18__T10DetectTmplTiZ\")\n+    enum HasTemplateLength = true;\n+else\n+    static assert(false, \"unknown mangling\");\n+\n+pragma(msg,BackRefs);\n+pragma(msg,BackRefSymbols);\n+\n+static if (BackRefs)\n+{\n+    string tl(string s)() { return null; }\n+    string id(string s, string r, string r2 = null)() { return BackRefSymbols && r2 !is null ? r2 : r; }\n+}\n+else\n+{\n+    string tl(string s)() { return HasTemplateLength ? s : null; }\n+    string id(string s, string r, string r2 = null)() { return s; }\n+}\n+\n+bool equalDemangle(string m1, string m2)\n+{\n+    auto dm1 = demangle(m1);\n+    auto dm2 = demangle(m2);\n+    return dm1 == dm2;\n+}\n+\n+string unsignedToString(ulong x)\n+{\n+    string s;\n+    s ~= cast(char)('0' + (x % 10));\n+    x /= 10;\n+    while (x > 0)\n+    {\n+        s = cast(char)('0' + (x % 10)) ~ s;\n+        x /= 10;\n+    }\n+    return s;\n+}"}, {"sha": "ab5e552536b654b0b0a51c5d2e36b73211eef71f", "filename": "gcc/testsuite/gdc.test/runnable/link6574.d", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink6574.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink6574.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink6574.d?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -1,16 +1,18 @@\n // PERMUTE_ARGS:\n module link6574;\n \n+import imports.testmangle;\n+\n enum Method { A, B, }\n \n int foo(Method method = Method.A)()\n {\n-    static assert(foo.mangleof == \"_D8link657428__T3fooVE8link65746Methodi0Z3fooFZi\");\n+    static assert(foo.mangleof == \"_D8link6574\"~tl!\"28\"~\"__T3fooVE\"~id!(\"8link6574\",\"Qs\")~\"6Methodi0Z\"~id!(\"3foo\",\"Qs\")~\"FZi\");\n     return 10 * foo!method();\n }\n int foo(Method method : Method.A)()\n {\n-    static assert(foo.mangleof == \"_D8link657429__T3fooHVE8link65746Methodi0Z3fooFZi\");\n+    static assert(foo.mangleof == \"_D8link6574\"~tl!\"29\"~\"__T3fooHVE\"~id!(\"8link6574\",\"Qt\")~\"6Methodi0Z\"~id!(\"3foo\",\"Qt\")~\"FZi\");\n     return 2;\n }\n int foo(Method method : Method.B)()\n@@ -21,7 +23,7 @@ int foo(Method method : Method.B)()\n \n int bar(Method method = Method.B)()\n {\n-    static assert(bar.mangleof == \"_D8link657428__T3barVE8link65746Methodi1Z3barFZi\");\n+    static assert(bar.mangleof == \"_D8link6574\"~tl!\"28\"~\"__T3barVE\"~id!(\"8link6574\",\"Qs\")~\"6Methodi1Z\"~id!(\"3bar\",\"Qs\")~\"FZi\");\n     return 10 * bar!method();\n }\n int bar(Method method : Method.A)()\n@@ -31,7 +33,7 @@ int bar(Method method : Method.A)()\n }\n int bar(Method method : Method.B)()\n {\n-    static assert(bar.mangleof == \"_D8link657429__T3barHVE8link65746Methodi1Z3barFZi\");\n+    static assert(bar.mangleof == \"_D8link6574\"~tl!\"29\"~\"__T3barHVE\"~id!(\"8link6574\",\"Qt\")~\"6Methodi1Z\"~id!(\"3bar\",\"Qt\")~\"FZi\");\n     return 3;\n }\n "}, {"sha": "883d58ac07c2edc4dadd3c40c551af1e7213a192", "filename": "gcc/testsuite/gdc.test/runnable/mangle.d", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmangle.d?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -1,6 +1,8 @@\n // PERMUTE_ARGS:\n // EXTRA_SOURCES: imports/mangle10077.d\n \n+import imports.testmangle;\n+\n /***************************************************/\n // 10077 - pragma(mangle)\n \n@@ -79,7 +81,7 @@ class C2774\n static assert(C2774.foo2774.mangleof == \"_D6mangle5C27747foo2774MFZi\");\n \n template TFoo2774(T) {}\n-static assert(TFoo2774!int.mangleof == \"6mangle15__T8TFoo2774TiZ\");\n+static assert(TFoo2774!int.mangleof == \"6mangle\"~tl!\"15\"~\"__T8TFoo2774TiZ\");\n \n void test2774()\n {\n@@ -175,8 +177,8 @@ void test8847b()\n \n struct Test8847\n {\n-    enum result1 = \"S6mangle8Test88478__T3fooZ3fooMFZ6Result\";\n-    enum result2 = \"S6mangle8Test88478__T3fooZ3fooMxFiZ6Result\";\n+    enum result1 = \"S6mangle8Test8847\"~tl!(\"8\")~\"__T3fooZ\"~id!(\"3foo\",\"Qf\")~\"MFZ6Result\";\n+    enum result2 = \"S6mangle8Test8847\"~tl!(\"8\")~\"__T3fooZ\"~id!(\"3foo\",\"Qf\")~\"MxFiZ6Result\";\n \n     auto foo()()\n     {\n@@ -236,9 +238,10 @@ void test8847d()\n \n void test8847e()\n {\n-    enum resultHere = \"6mangle\"~\"9test8847eFZ\"~\"8__T3fooZ\"~\"3foo\";\n+    enum resultHere = \"6mangle\"~\"9test8847eFZ\"~tl!\"8\"~\"__T3fooZ\"~id!(\"3foo\",\"Qf\");\n     enum resultBar =  \"S\"~resultHere~\"MFNaNfNgiZ3Bar\";\n-    enum resultFoo = \"_D\"~resultHere~\"MFNaNbNiNfNgiZNg\"~resultBar;   // added 'Nb'\n+    static if(BackRefs) {} else\n+      enum resultFoo = \"_D\"~resultHere~\"MFNaNbNiNfNgiZNg\"~resultBar;   // added 'Nb'\n \n     // Make template function to infer 'nothrow' attributes\n     auto foo()(inout int) pure @safe\n@@ -248,10 +251,16 @@ void test8847e()\n         return inout(Bar)();\n     }\n \n+    import core.demangle : demangle, demangleType;\n     auto bar = foo(0);\n     static assert(typeof(bar).stringof == \"Bar\");\n     static assert(typeof(bar).mangleof == resultBar);\n-    static assert(foo!().mangleof == resultFoo);\n+    enum fooDemangled = \"pure nothrow @nogc @safe inout(mangle.test8847e().foo!().foo(inout(int)).Bar) mangle.test8847e().foo!().foo(inout(int))\";\n+\n+    static if (BackRefs)\n+      static assert(demangle(foo!().mangleof) == fooDemangled);\n+    else\n+      static assert(foo!().mangleof == resultFoo);\n }\n \n // --------\n@@ -287,7 +296,7 @@ auto bar12352()\n \n     return S();\n }\n-static assert(       bar12352        .mangleof == \"_D6mangle8bar12352FNaNbNiNfZS6mangle8bar12352FZ1S\");\n+static assert(       bar12352        .mangleof == \"_D6mangle8bar12352FNaNbNiNfZS\"~id!(\"6mangle8bar12352FZ\",\"QBbQxFZ\",\"QL2H\")~\"1S\");\n static assert(typeof(bar12352())     .mangleof ==  \"S6mangle8bar12352FZ1S\");\n static assert(typeof(bar12352()).func.mangleof == \"_D6mangle8bar12352FZ1S4funcMFZv\");\n \n@@ -301,7 +310,7 @@ auto baz12352()\n \n     return new C();\n }\n-static assert(       baz12352        .mangleof == \"_D6mangle8baz12352FNaNbNfZC6mangle8baz12352FZ1C\");\n+static assert(       baz12352      .mangleof == \"_D6mangle8baz12352FNaNbNfZC\"~id!(\"6mangle8baz12352FZ\",\"QzQuFZ\",\"QL2F\")~\"1C\");\n static assert(typeof(baz12352())     .mangleof ==  \"C6mangle8baz12352FZ1C\");\n static assert(typeof(baz12352()).func.mangleof == \"_D6mangle8baz12352FZ1C4funcMFZv\");\n \n@@ -312,8 +321,8 @@ void f9525(T)(in T*) { }\n \n void test9525()\n {\n-    enum result1 = \"S6mangle8test9525FZ26__T5test1S136mangle5f9525Z5test1MFZ1S\";\n-    enum result2 = \"S6mangle8test9525FZ26__T5test2S136mangle5f9525Z5test2MFNaNbZ1S\";\n+    enum result1 = \"S6mangle8test9525FZ\"~tl!\"26\"~\"__T5test1S\"~tl!\"13\"~id!(\"6mangle\",\"QBc\")~\"5f9525Z\"~id!(\"5test1\",\"Qr\")~\"MFZ1S\";\n+    enum result2 = \"S6mangle8test9525FZ\"~tl!\"26\"~\"__T5test2S\"~tl!\"13\"~id!(\"6mangle\",\"QBc\")~\"5f9525Z\"~id!(\"5test2\",\"Qr\")~\"MFNaNbZ1S\";\n \n     void test1(alias a)()\n     {\n@@ -383,23 +392,32 @@ void test11718()\n     string TyName(string tail)()\n     {\n         enum s = \"__T7Ty11718\" ~ tail;\n-        enum int len = s.length;\n-        return \"S6mangle\" ~ len.stringof ~ s;\n+        enum len = unsignedToString(s.length);\n+        return \"S6mangle\" ~ tl!(len) ~ s;\n     }\n     string fnName(string paramPart)()\n     {\n-        enum s = \"_D6mangle35__T7fn11718T\"~\n+        enum s = \"_D6mangle\"~tl!(\"35\")~\"__T7fn11718T\"~\n                  \"S6mangle9test11718FZ1AZ7fn11718\"~paramPart~\"1a\"~\n                  \"S6mangle9test11718FZ1A\";\n-        enum int len = s.length;\n-        return len.stringof ~ s;\n+        enum len = unsignedToString(s.length);\n+        return tl!len ~ s;\n     }\n     enum result1 = TyName!(\"S\" ~ fnName!(\"F\"~\"S6mangle9test11718FZ1A\"~\"Z\") ~ \"Z\") ~ \"7Ty11718\";\n     enum result2 = TyName!(\"S\" ~ fnName!(\"F\"~\"\"                      ~\"Z\") ~ \"Z\") ~ \"7Ty11718\";\n \n     struct A {}\n-    static assert(fn11718(A.init) == result1);\n-    static assert(fn11718!A()     == result2);\n+    static if (BackRefs)\n+    {\n+        static assert(fn11718(A.init) == \"S6mangle__T7Ty11718S_DQv__T7fn11718TSQBk9test11718FZ1AZQBcFQxZ1aQBcZQCf\");\n+        static assert(fn11718!A()     == \"S6mangle__T7Ty11718S_DQv__T7fn11718TSQBk9test11718FZ1AZQBcFZ1aQBaZQCd\");\n+    }\n+    else\n+    {\n+        pragma(msg, fn11718(A.init));\n+        static assert(fn11718(A.init) == result1);\n+        static assert(fn11718!A()     == result2);\n+    }\n }\n \n /*******************************************/\n@@ -417,9 +435,10 @@ void test11776()\n         {\n             auto s = S11776!(a => 1)();\n             static assert(typeof(s).mangleof ==\n-                \"S\"~\"6mangle\"~\"56\"~(\n-                    \"__T\"~\"6S11776\"~\"S42\"~(\"6mangle\"~\"9test11776\"~\"FZ\"~\"9__lambda1MFZ\"~\"9__lambda1\")~\"Z\"\n-                )~\"6S11776\");\n+                \"S\"~\"6mangle\"~tl!(\"56\")~\n+                (\"__T\"~\"6S11776\"~\"S\"~tl!(\"42\")~\n+                 (id!(\"6mangle\",\"Qs\")~\"9test11776\"~\"FZ\"~\"9__lambda1MFZ\"~id!(\"9__lambda1\",\"Qn\"))~\"Z\"\n+                 )~id!(\"6S11776\", \"QBm\"));\n         }\n     };\n }\n@@ -464,7 +483,7 @@ void test12217(int)\n     static assert(    S.mangleof ==  \"S6mangle9test12217FiZ1S\");\n     static assert(  bar.mangleof == \"_D6mangle9test12217FiZ3barMFNaNbNiNfZv\");\n     static assert(  var.mangleof == \"_D6mangle9test12217FiZ3vari\");\n-    static assert(X!int.mangleof ==   \"6mangle9test12217FiZ8__T1XTiZ\");\n+    static assert(X!int.mangleof ==   \"6mangle9test12217FiZ\"~tl!(\"8\")~\"__T1XTiZ\");\n }\n \n void test12217() {}\n@@ -476,22 +495,21 @@ void func12231a()()\n if (is(typeof({\n         class C {}\n         static assert(C.mangleof ==\n-            \"C6mangle16__U10func12231aZ10func12231aFZ9__lambda1MFZ1C\");\n+            \"C6mangle\"~tl!(\"16\")~\"__U10func12231aZ\"~id!(\"10func12231a\",\"Qn\")~\"FZ9__lambda1MFZ1C\");\n             //         ###            L                       #\n     })))\n {}\n \n void func12231b()()\n if (is(typeof({\n-        class C {}\n-        static assert(C.mangleof ==\n-            \"C6mangle16__U10func12231bZ10func12231bFZ9__lambda1MFZ1C\");\n+        class C {}        static assert(C.mangleof ==\n+            \"C6mangle\"~tl!(\"16\")~\"__U10func12231bZ\"~id!(\"10func12231b\",\"Qn\")~\"FZ9__lambda1MFZ1C\");\n             //         L__L           L                       LL\n-    })) &&\n+      })) &&\n     is(typeof({\n         class C {}\n         static assert(C.mangleof ==\n-            \"C6mangle16__U10func12231bZ10func12231bFZ9__lambda2MFZ1C\");\n+            \"C6mangle\"~tl!(\"16\")~\"__U10func12231bZ\"~id!(\"10func12231b\",\"Qn\")~\"FZ9__lambda2MFZ1C\");\n             //         L__L           L                       LL\n     })))\n {}\n@@ -500,30 +518,30 @@ void func12231c()()\n if (is(typeof({\n         class C {}\n         static assert(C.mangleof ==\n-            \"C6mangle16__U10func12231cZ10func12231cFZ9__lambda1MFZ1C\");\n+            \"C6mangle\"~tl!(\"16\")~\"__U10func12231cZ\"~id!(\"10func12231c\",\"Qn\")~\"FZ9__lambda1MFZ1C\");\n             //         L__L           L                       LL\n     })))\n {\n     (){\n         class C {}\n         static assert(C.mangleof ==\n-            \"C6mangle16__T10func12231cZ10func12231cFZ9__lambda1MFZ1C\");\n+            \"C6mangle\"~tl!(\"16\")~\"__T10func12231cZ\"~id!(\"10func12231c\",\"Qn\")~\"FZ9__lambda1MFZ1C\");\n             //         L__L           L                       LL\n     }();\n }\n \n void func12231c(X)()\n if (is(typeof({\n         class C {}\n-        static assert(C.mangleof ==\n-            \"C6mangle20__U10func12231cTAyaZ10func12231cFZ9__lambda1MFZ1C\");\n+    static assert(C.mangleof ==\n+            \"C6mangle\"~tl!(\"20\")~\"__U10func12231cTAyaZ\"~id!(\"10func12231c\",\"Qr\")~\"FZ9__lambda1MFZ1C\");\n             //         L__L           L___L                       LL\n     })))\n {\n     (){\n         class C {}\n         static assert(C.mangleof ==\n-            \"C6mangle20__T10func12231cTAyaZ10func12231cFZ9__lambda1MFZ1C\");\n+            \"C6mangle\"~tl!(\"20\")~\"__T10func12231cTAyaZ\"~id!(\"10func12231c\",\"Qr\")~\"FZ9__lambda1MFZ1C\");\n             //         L__L           L___L                       LL\n     }();\n }"}, {"sha": "81723f601825eb4b651fa500b6a3e25732a8c455", "filename": "gcc/testsuite/gdc.test/runnable/template4.d", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftemplate4.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftemplate4.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftemplate4.d?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -1074,22 +1074,27 @@ struct Foo7469d(T...) { }\n struct Foo7469e(int a, T...) { }\n struct Foo7469f(T, int k=1) { }\n struct Foo7469g(T, int k=1) { }\n+struct Foo7469h(uint x) { }\n+\n+import core.demangle : demangleType;\n \n void test7469()\n {\n-    static assert(Foo7469a!(3 )    .mangleof[$-28 .. $] == \"17__T8Foo7469aVii3Z8Foo7469a\");\n-    static assert(Foo7469a!(3u)    .mangleof[$-28 .. $] == \"17__T8Foo7469aVii3Z8Foo7469a\");\n-    static assert(Foo7469b!(3u)    .mangleof[$-28 .. $] == \"17__T8Foo7469bVii3Z8Foo7469b\");\n-    static assert(Foo7469b!(3 )    .mangleof[$-28 .. $] == \"17__T8Foo7469bVii3Z8Foo7469b\");\n-    static assert(Foo7469c!(3 )    .mangleof[$-28 .. $] == \"17__T8Foo7469cVii3Z8Foo7469c\");\n-    static assert(Foo7469c!(3u)    .mangleof[$-28 .. $] == \"17__T8Foo7469cVki3Z8Foo7469c\");\n-    static assert(Foo7469d!(3 )    .mangleof[$-28 .. $] == \"17__T8Foo7469dVii3Z8Foo7469d\");\n-    static assert(Foo7469d!(3u)    .mangleof[$-28 .. $] == \"17__T8Foo7469dVki3Z8Foo7469d\");\n-    static assert(Foo7469e!(3u, 5u).mangleof[$-32 .. $] == \"21__T8Foo7469eVii3Vki5Z8Foo7469e\");\n-    static assert(Foo7469f!(int, 1).mangleof[$-30 .. $] == \"19__T8Foo7469fTiVii1Z8Foo7469f\");\n-    static assert(Foo7469f!(int)   .mangleof[$-30 .. $] == \"19__T8Foo7469fTiVii1Z8Foo7469f\");\n-    static assert(Foo7469g!(int)   .mangleof[$-30 .. $] == \"19__T8Foo7469gTiVii1Z8Foo7469g\");\n-    static assert(Foo7469g!(int, 1).mangleof[$-30 .. $] == \"19__T8Foo7469gTiVii1Z8Foo7469g\");\n+    static assert(demangleType(Foo7469a!(3 )    .mangleof) == \"template4.Foo7469a!(3).Foo7469a\");\n+    static assert(demangleType(Foo7469a!(3u)    .mangleof) == \"template4.Foo7469a!(3).Foo7469a\");\n+    static assert(demangleType(Foo7469b!(3u)    .mangleof) == \"template4.Foo7469b!(3).Foo7469b\");\n+    static assert(demangleType(Foo7469b!(3 )    .mangleof) == \"template4.Foo7469b!(3).Foo7469b\");\n+    static assert(demangleType(Foo7469c!(3 )    .mangleof) == \"template4.Foo7469c!(3).Foo7469c\");\n+    static assert(demangleType(Foo7469c!(3u)    .mangleof) == \"template4.Foo7469c!(3u).Foo7469c\");\n+    static assert(demangleType(Foo7469d!(3 )    .mangleof) == \"template4.Foo7469d!(3).Foo7469d\");\n+    static assert(demangleType(Foo7469d!(3u)    .mangleof) == \"template4.Foo7469d!(3u).Foo7469d\");\n+    static assert(demangleType(Foo7469e!(3u, 5u).mangleof) == \"template4.Foo7469e!(3, 5u).Foo7469e\");\n+    static assert(demangleType(Foo7469f!(int, 1).mangleof) == \"template4.Foo7469f!(int, 1).Foo7469f\");\n+    static assert(demangleType(Foo7469f!(int)   .mangleof) == \"template4.Foo7469f!(int, 1).Foo7469f\");\n+    static assert(demangleType(Foo7469g!(int)   .mangleof) == \"template4.Foo7469g!(int, 1).Foo7469g\");\n+    static assert(demangleType(Foo7469g!(int, 1).mangleof) == \"template4.Foo7469g!(int, 1).Foo7469g\");\n+    static assert(demangleType(Foo7469h!(3 )    .mangleof) == \"template4.Foo7469h!(3u).Foo7469h\");\n+    static assert(demangleType(Foo7469h!(3u)    .mangleof) == \"template4.Foo7469h!(3u).Foo7469h\");\n }\n \n /******************************************/"}, {"sha": "b016ff910431c60e057fa82e70f1b14a67377da7", "filename": "gcc/testsuite/gdc.test/runnable/template9.d", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftemplate9.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftemplate9.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftemplate9.d?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -4465,6 +4465,7 @@ void test13807()\n \n /******************************************/\n // 14174\n+import imports.testmangle;\n \n struct Config14174(a, b) {}\n \n@@ -4474,22 +4475,22 @@ alias defConfig14174 = Config14174!(N14174, N14174);\n \n void accepter14174a(Config : Config14174!(T) = defConfig14174, T...)()\n {\n-    static assert(accepter14174a.mangleof\n-        == \"_D7breaker131__T14\"~\n+    static assert(equalDemangle(accepter14174a.mangleof,\n+           \"_D7breaker131__T14\"~\n            \"accepter14174a\"~\n            \"HTS7breaker51__T11Config14174TS7breaker6N14174TS7breaker6N14174Z11Config14174TS7breaker6N14174TS7breaker6N14174Z14\"~\n            \"accepter14174a\"~\n-           \"FZv\");\n+           \"FZv\"));\n }\n \n void accepter14174b(Config : Config14174!(T) = defConfig14174, T...)()\n {\n-    static assert(accepter14174b.mangleof\n-        == \"_D7breaker131__T14\"~\n+    static assert(equalDemangle(accepter14174b.mangleof,\n+           \"_D7breaker131__T14\"~\n            \"accepter14174b\"~\n            \"HTS7breaker51__T11Config14174TS7breaker6N14174TS7breaker6N14174Z11Config14174TS7breaker6N14174TS7breaker6N14174Z14\"~\n            \"accepter14174b\"~\n-           \"FZv\");\n+           \"FZv\"));\n }\n \n void test14174()"}, {"sha": "42f9c1beb7f5d19a4dceb62d6a8d313a7292eca5", "filename": "gcc/testsuite/gdc.test/runnable/testconst.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af3f4a2893203492cce59b72eff3f7bb4aef04c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d?ref=1af3f4a2893203492cce59b72eff3f7bb4aef04c", "patch": "@@ -84,10 +84,11 @@ void foo8(const char[] s, const C8 c, const int x)\n \n void test8()\n {\n+    import core.demangle : demangle;\n     auto p = &foo8;\n     showf(p.mangleof);\n     assert(typeof(p).mangleof == \"PFxAaxC9testconst2C8xiZv\");\n-    assert(p.mangleof == \"_D9testconst5test8FZ1pPFxAaxC9testconst2C8xiZv\");\n+    assert(demangle(p.mangleof) == \"void function(const(char[]), const(testconst.C8), const(int))* testconst.test8().p\");\n }\n \n /************************************/"}]}