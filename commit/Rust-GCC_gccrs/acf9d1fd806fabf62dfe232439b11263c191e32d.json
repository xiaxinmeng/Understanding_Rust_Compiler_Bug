{"sha": "acf9d1fd806fabf62dfe232439b11263c191e32d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNmOWQxZmQ4MDZmYWJmNjJkZmUyMzI0MzliMTEyNjNjMTkxZTMyZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-26T07:13:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-26T07:13:47Z"}, "message": "openmp: Add support for omp attributes section and scan directives\n\nThis patch adds support for expressing the section and scan directives\nusing the attribute syntax and additionally fixes some bugs in the attribute\nsyntax directive handling.\nFor now it requires that the scan and section directives appear as the only\nattribute, not combined with other OpenMP or non-OpenMP attributes on the same\nstatement.\n\n2021-07-26  Jakub Jelinek  <jakub@redhat.com>\n\n\t* parser.h (struct cp_lexer): Add orphan_p member.\n\t* parser.c (cp_parser_statement): Don't change in_omp_attribute_pragma\n\tupon restart from CPP_PRAGMA handling.  Fix up condition when a lexer\n\tshould be destroyed and adjust saved_tokens if it records tokens from\n\tthe to be destroyed lexer.\n\t(cp_parser_omp_section_scan): New function.\n\t(cp_parser_omp_scan_loop_body): Use it.  If\n\tparser->lexer->in_omp_attribute_pragma, allow optional comma\n\tafter scan.\n\t(cp_parser_omp_sections_scope): Use cp_parser_omp_section_scan.\n\n\t* g++.dg/gomp/attrs-1.C: Use attribute syntax even for section\n\tand scan directives.\n\t* g++.dg/gomp/attrs-2.C: Likewise.\n\t* g++.dg/gomp/attrs-6.C: New test.\n\t* g++.dg/gomp/attrs-7.C: New test.\n\t* g++.dg/gomp/attrs-8.C: New test.", "tree": {"sha": "8cab35a73a0994b4d209681a111d766eb1283f10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cab35a73a0994b4d209681a111d766eb1283f10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acf9d1fd806fabf62dfe232439b11263c191e32d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf9d1fd806fabf62dfe232439b11263c191e32d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acf9d1fd806fabf62dfe232439b11263c191e32d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf9d1fd806fabf62dfe232439b11263c191e32d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "124bb55777c280a85d0c72ec13e293a32917a6b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124bb55777c280a85d0c72ec13e293a32917a6b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/124bb55777c280a85d0c72ec13e293a32917a6b9"}], "stats": {"total": 257, "additions": 240, "deletions": 17}, "files": [{"sha": "976e2e7ac0f3b95ef492523413b188644f4034b6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 100, "deletions": 5, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=acf9d1fd806fabf62dfe232439b11263c191e32d", "patch": "@@ -11901,10 +11901,9 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n   tree statement, std_attrs = NULL_TREE;\n   cp_token *token;\n   location_t statement_location, attrs_loc;\n-  bool in_omp_attribute_pragma;\n+  bool in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n \n  restart:\n-  in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n   if (if_p != NULL)\n     *if_p = false;\n   /* There is no statement yet.  */\n@@ -11951,6 +11950,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t     the statement.  */\n \t  cp_parser_label_for_labeled_statement (parser, std_attrs);\n \t  in_compound = false;\n+\t  in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n \t  goto restart;\n \n \tcase RID_IF:\n@@ -12034,6 +12034,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \n \t  cp_parser_label_for_labeled_statement (parser, std_attrs);\n \t  in_compound = false;\n+\t  in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n \t  goto restart;\n \t}\n     }\n@@ -12058,13 +12059,28 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \tcp_parser_pragma (parser, pragma_compound, if_p);\n       else if (!cp_parser_pragma (parser, pragma_stmt, if_p))\n \tdo_restart = true;\n-      if (lexer->in_omp_attribute_pragma && !in_omp_attribute_pragma)\n+      if (parser->lexer != lexer\n+\t  && lexer->in_omp_attribute_pragma\n+\t  && (!in_omp_attribute_pragma || lexer->orphan_p))\n \t{\n-\t  gcc_assert (parser->lexer != lexer);\n+\t  if (saved_tokens.lexer == lexer)\n+\t    {\n+\t      if (saved_tokens.commit)\n+\t\tcp_lexer_commit_tokens (lexer);\n+\t      gcc_assert (lexer->saved_tokens.length () == saved_tokens.len);\n+\t      saved_tokens.lexer = parser->lexer;\n+\t      saved_tokens.commit = false;\n+\t      saved_tokens.len = parser->lexer->saved_tokens.length ();\n+\t    }\n \t  cp_lexer_destroy (lexer);\n+\t  lexer = parser->lexer;\n \t}\n       if (do_restart)\n \tgoto restart;\n+      if (parser->lexer == lexer\n+\t  && lexer->in_omp_attribute_pragma\n+\t  && !in_omp_attribute_pragma)\n+\tparser->lexer->orphan_p = true;\n       return;\n     }\n   else if (token->type == CPP_EOF)\n@@ -40775,6 +40791,77 @@ cp_finish_omp_range_for (tree orig, tree begin)\n     cp_finish_decomp (decl, decomp_first_name, decomp_cnt);\n }\n \n+/* Return true if next tokens contain a standard attribute that contains\n+   omp::directive (DIRECTIVE).  */\n+\n+static bool\n+cp_parser_omp_section_scan (cp_parser *parser, const char *directive,\n+\t\t\t    bool tentative)\n+{\n+  size_t n = cp_parser_skip_attributes_opt (parser, 1), i;\n+  if (n < 10)\n+    return false;\n+  for (i = 5; i < n - 4; i++)\n+    if (cp_lexer_nth_token_is (parser->lexer, i, CPP_NAME)\n+\t&& cp_lexer_nth_token_is (parser->lexer, i + 1, CPP_OPEN_PAREN)\n+\t&& cp_lexer_nth_token_is (parser->lexer, i + 2, CPP_NAME))\n+      {\n+\ttree first = cp_lexer_peek_nth_token (parser->lexer, i)->u.value;\n+\ttree second = cp_lexer_peek_nth_token (parser->lexer, i + 2)->u.value;\n+\tif (strcmp (IDENTIFIER_POINTER (first), \"directive\"))\n+\t  continue;\n+\tif (strcmp (IDENTIFIER_POINTER (second), directive) == 0)\n+\t  break;\n+      }\n+  if (i == n - 4)\n+    return false;\n+  cp_parser_parse_tentatively (parser);\n+  location_t first_loc = cp_lexer_peek_token (parser->lexer)->location;\n+  location_t last_loc\n+    = cp_lexer_peek_nth_token (parser->lexer, n - 1)->location;\n+  location_t middle_loc = UNKNOWN_LOCATION;\n+  tree std_attrs = cp_parser_std_attribute_spec_seq (parser);\n+  int cnt = 0;\n+  bool seen = false;\n+  for (tree attr = std_attrs; attr; attr = TREE_CHAIN (attr))\n+    if (get_attribute_namespace (attr) == omp_identifier\n+\t&& is_attribute_p (\"directive\", get_attribute_name (attr)))\n+      {\n+\tfor (tree a = TREE_VALUE (attr); a; a = TREE_CHAIN (a))\n+\t  {\n+\t    tree d = TREE_VALUE (a);\n+\t    gcc_assert (TREE_CODE (d) == DEFERRED_PARSE);\n+\t    cp_token *first = DEFPARSE_TOKENS (d)->first;\n+\t    cnt++;\n+\t    if (first->type == CPP_NAME\n+\t\t&& strcmp (IDENTIFIER_POINTER (first->u.value),\n+\t\t\t   directive) == 0)\n+\t      {\n+\t\tseen = true;\n+\t\tif (middle_loc == UNKNOWN_LOCATION)\n+\t\t  middle_loc = first->location;\n+\t      }\n+\t  }\n+      }\n+  if (!seen || tentative)\n+    {\n+      cp_parser_abort_tentative_parse (parser);\n+      return seen;\n+    }\n+  if (cnt != 1 || TREE_CHAIN (std_attrs))\n+    {\n+      error_at (make_location (first_loc, last_loc, middle_loc),\n+\t\t\"%<[[omp::directive(%s)]]%> must be the only specified \"\n+\t\t\"attribute on a statement\", directive);\n+      cp_parser_abort_tentative_parse (parser);\n+      return false;\n+    }\n+  if (!cp_parser_parse_definitely (parser))\n+    return false;\n+  cp_parser_handle_statement_omp_attributes (parser, std_attrs);\n+  return true;\n+}\n+\n /* OpenMP 5.0:\n \n    scan-loop-body:\n@@ -40793,13 +40880,18 @@ cp_parser_omp_scan_loop_body (cp_parser *parser)\n   substmt = build2 (OMP_SCAN, void_type_node, substmt, NULL_TREE);\n   add_stmt (substmt);\n \n+  cp_parser_omp_section_scan (parser, \"scan\", false);\n   cp_token *tok = cp_lexer_peek_token (parser->lexer);\n   if (cp_parser_pragma_kind (tok) == PRAGMA_OMP_SCAN)\n     {\n       enum omp_clause_code clause = OMP_CLAUSE_ERROR;\n \n       cp_lexer_consume_token (parser->lexer);\n \n+      if (parser->lexer->in_omp_attribute_pragma\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n       if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n \t{\n \t  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n@@ -41623,7 +41715,8 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n   stmt = push_stmt_list ();\n \n   if (cp_parser_pragma_kind (cp_lexer_peek_token (parser->lexer))\n-      != PRAGMA_OMP_SECTION)\n+      != PRAGMA_OMP_SECTION\n+      && !cp_parser_omp_section_scan (parser, \"section\", true))\n     {\n       substmt = cp_parser_omp_structured_block (parser, NULL, false);\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n@@ -41638,6 +41731,8 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n       if (tok->type == CPP_EOF)\n \tbreak;\n \n+      if (cp_parser_omp_section_scan (parser, \"section\", false))\n+\ttok = cp_lexer_peek_token (parser->lexer);\n       if (cp_parser_pragma_kind (tok) == PRAGMA_OMP_SECTION)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);"}, {"sha": "e62742db95d763b2ab43ebb1374324da64ea18c9", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=acf9d1fd806fabf62dfe232439b11263c191e32d", "patch": "@@ -117,6 +117,10 @@ struct GTY (()) cp_lexer {\n   /* True if we're in the context of OpenMP directives written as C++11\n      attributes turned into pragma.  */\n   bool in_omp_attribute_pragma;\n+\n+  /* True for in_omp_attribute_pragma lexer that should be destroyed\n+     when it is no longer in use.  */\n+  bool orphan_p;\n };\n \n "}, {"sha": "6bbdcac7fbaa881e062c9995e1e167cfddb62603", "filename": "gcc/testsuite/g++.dg/gomp/attrs-1.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C?ref=acf9d1fd806fabf62dfe232439b11263c191e32d", "patch": "@@ -146,17 +146,17 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread)\n     lastprivate (l) allocate (f))]]\n   {\n-    #pragma omp section\n+    [[omp::directive (section)]]\n     {}\n-    #pragma omp section\n+    [[omp::sequence (omp::directive (section))]]\n     {}\n   }\n   [[omp::directive (sections private (p) firstprivate (f) reduction(+:r) lastprivate (l) allocate (f) nowait)]]\n   {\n     ;\n-    #pragma omp section\n+    [[omp::sequence (sequence (directive (section)))]]\n     ;\n-    #pragma omp section\n+    [[omp::directive (section)]]\n     {}\n   }\n   [[omp::directive (barrier)]];\n@@ -539,14 +539,14 @@ garply (int a, int *c, int *d, int *e, int *f)\n   for (i = 0; i < 64; i++)\n     {\n       d[i] = a;\n-      #pragma omp scan exclusive (a)\n+      [[omp::directive (scan exclusive (a))]]\n       a += c[i];\n     }\n   [[omp::directive (simd reduction (inscan, +: a))]]\n   for (i = 0; i < 64; i++)\n     {\n       a += c[i];\n-      #pragma omp scan inclusive (a)\n+      [[omp::sequence (omp::sequence (omp::directive (scan inclusive (a))))]]\n       d[i] = a;\n     }\n   return a;"}, {"sha": "189dc6b185970cb2990acb93e18308422a9d7836", "filename": "gcc/testsuite/g++.dg/gomp/attrs-2.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C?ref=acf9d1fd806fabf62dfe232439b11263c191e32d", "patch": "@@ -146,17 +146,17 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),copyin(t),reduction(+:r),num_threads (nth),proc_bind(spread),\n     lastprivate (l),allocate (f))]]\n   {\n-    #pragma omp section\n+    [[using omp:directive (section)]]\n     {}\n-    #pragma omp section\n+    [[omp::sequence (omp::directive (section))]]\n     {}\n   }\n   [[omp::directive (sections, private (p),firstprivate (f),reduction(+:r),lastprivate (l),allocate (f),nowait)]]\n   {\n     ;\n-    #pragma omp section\n+    [[omp::sequence (sequence (directive (section)))]]\n     ;\n-    #pragma omp section\n+    [[omp::directive (section)]]\n     {}\n   }\n   [[omp::directive (barrier)]];\n@@ -539,14 +539,14 @@ garply (int a, int *c, int *d, int *e, int *f)\n   for (i = 0; i < 64; i++)\n     {\n       d[i] = a;\n-      #pragma omp scan exclusive (a)\n+      [[omp::directive (scan, exclusive (a))]]\n       a += c[i];\n     }\n   [[omp::directive (simd, reduction (inscan, +: a))]]\n   for (i = 0; i < 64; i++)\n     {\n       a += c[i];\n-      #pragma omp scan inclusive (a)\n+      [[using omp : sequence (sequence (directive (scan inclusive (a))))]]\n       d[i] = a;\n     }\n   return a;"}, {"sha": "30b47e1ac15544016420efbdb5d88eb8ccd8bbc6", "filename": "gcc/testsuite/g++.dg/gomp/attrs-6.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-6.C?ref=acf9d1fd806fabf62dfe232439b11263c191e32d", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do compile { target c++11 } }\n+\n+void\n+foo ()\n+{\n+  int a[10] = {};\n+  #pragma omp parallel sections\n+  {\n+    #pragma omp section\n+    a[0]++;\n+    [[omp::directive (section)]] {\n+    a[1]++;\n+    } [[omp::directive (section)]]\n+    a[2]++;\n+    #pragma omp section\n+    { a[3]++; }\n+  }\n+  [[omp::directive (parallel sections)]]\n+  {\n+    #pragma omp section\n+    a[0]++;\n+    [[omp::directive (section)]] {\n+    a[1]++;\n+    } [[omp::directive (section)]]\n+    a[2]++;\n+    #pragma omp section\n+    { a[3]++; }\n+  }\n+}\n+\n+int\n+bar (int a, int *c, int *d, int *e, int *f)\n+{\n+  int i;\n+  #pragma omp simd reduction (inscan, +: a)\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[i] = a;\n+      [[omp::directive (scan, exclusive (a))]]\n+      a += c[i];\n+    }\n+  [[omp::directive (simd reduction (inscan, +: a))]]\n+  for (i = 0; i < 64; i++)\n+    {\n+      a += c[i];\n+      #pragma omp scan inclusive (a)\n+      d[i] = a;\n+    }\n+  return a;\n+}"}, {"sha": "598c32ae03fc34f73788f18febd7606bf5b63984", "filename": "gcc/testsuite/g++.dg/gomp/attrs-7.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-7.C?ref=acf9d1fd806fabf62dfe232439b11263c191e32d", "patch": "@@ -0,0 +1,64 @@\n+// { dg-do compile { target c++11 } }\n+\n+void\n+foo ()\n+{\n+\n+  [[omp::directive (parallel sections)]]\n+  {\n+    [[omp::directive (parallel)]];\n+    [[omp::sequence (directive (section), directive (flush))]];\t\t// { dg-error \"must be the only specified attribute on a statement\" }\n+\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp section\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp flush\" \"\" { target *-*-* } .-2 }\n+    [[omp::sequence (directive (flush), omp::directive (section))]];\t// { dg-error \"must be the only specified attribute on a statement\" }\n+\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp section\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp flush\" \"\" { target *-*-* } .-2 }\n+    [[gnu::cold, omp::directive (section)]];\t\t\t\t// { dg-error \"must be the only specified attribute on a statement\" }\n+\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp section\" \"\" { target *-*-* } .-1 }\n+    [[omp::directive (section)]] [[gnu::cold]];\t\t\t\t// { dg-error \"must be the only specified attribute on a statement\" }\n+\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp section\" \"\" { target *-*-* } .-1 }\n+    [[omp::directive (section foo)]];\t\t\t\t\t// { dg-error \"expected end of line before 'foo'\" }\n+  }\n+}\n+\n+int\n+bar (int a, int *c, int *d, int *e, int *f)\n+{\n+  int i;\n+  [[omp::directive (parallel for reduction (inscan, +: a))]]\t\t\t\t// { dg-error \"'a' specified in 'inscan' 'reduction' clause but not in 'scan' directive clause\" }\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[i] = a;\n+      [[omp::sequence (omp::directive (parallel), omp::directive (scan, exclusive (a)))]]\t// { dg-error \"must be the only specified attribute on a statement\" }\n+      a += c[i];\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp scan\" \"\" { target *-*-* } .-1 }\n+    }\n+  [[omp::directive (parallel for reduction (inscan, +: a))]]\t\t\t\t// { dg-error \"'a' specified in 'inscan' 'reduction' clause but not in 'scan' directive clause\" }\n+  for (i = 0; i < 64; i++)\n+    {\n+      a += c[i];\n+      [[omp::sequence (directive (scan inclusive (a)), directive (critical))]]\t\t// { dg-error \"must be the only specified attribute on a statement\" }\n+      d[i] = a;\t\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp scan\" \"\" { target *-*-* } .-1 }\n+    }\n+  [[omp::directive (parallel for reduction (inscan, +: a))]]\t\t\t\t// { dg-error \"'a' specified in 'inscan' 'reduction' clause but not in 'scan' directive clause\" }\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[i] = a;\n+      [[gnu::cold]] [[omp::directive (scan, exclusive (a))]]\t\t\t\t// { dg-error \"must be the only specified attribute on a statement\" }\n+      a += c[i];\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp scan\" \"\" { target *-*-* } .-1 }\n+    }\n+  [[omp::directive (parallel for reduction (inscan, +: a))]]\t\t\t\t// { dg-error \"'a' specified in 'inscan' 'reduction' clause but not in 'scan' directive clause\" }\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[i] = a;\n+      [[omp::directive (scan, exclusive (a)), gnu::cold]]\t\t\t\t// { dg-error \"must be the only specified attribute on a statement\" }\n+      a += c[i];\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp scan\" \"\" { target *-*-* } .-1 }\n+    }\n+  [[omp::directive (parallel for reduction (inscan, +: a))]]\t\t\t\t// { dg-error \"'a' specified in 'inscan' 'reduction' clause but not in 'scan' directive clause\" }\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[i] = a;\n+      [[omp::directive (scan)]]\t\t\t\t\t\t\t\t// { dg-error \"expected 'inclusive' or 'exclusive' clause before end of line\" }\n+      a += c[i];\n+    }\n+  return a;\n+}"}, {"sha": "30cfe998dcf6affe1bb4e5890bb01ce723294965", "filename": "gcc/testsuite/g++.dg/gomp/attrs-8.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf9d1fd806fabf62dfe232439b11263c191e32d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-8.C?ref=acf9d1fd806fabf62dfe232439b11263c191e32d", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++11 } }\n+\n+void\n+foo ()\n+{\n+  // Unsure if this shouldn't be invalid, whether we shouldn't require\n+  // that each standalone directive sits on its own empty statement.\n+  [[omp::sequence (omp::directive (barrier), omp::directive (barrier))]];\n+  [[omp::sequence (omp::directive (taskyield), omp::directive (taskwait))]];\n+}"}]}