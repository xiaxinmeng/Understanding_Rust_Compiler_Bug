{"sha": "7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ViM2YxZjdjYWI3ZjhmZmM3NWI4MDEwZjYxOWE3NmZiYTI4MDhjMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-06-23T14:32:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-06-23T14:32:59Z"}, "message": "var-tracking.c (unshare_variable): Force initialized to be VAR_INIT_STATUS_INITIALIZED unless flag_var_tracking_uninit.\n\n\t* var-tracking.c (unshare_variable): Force initialized to\n\tbe VAR_INIT_STATUS_INITIALIZED unless flag_var_tracking_uninit.\n\t(set_variable_part): Likewise.\n\t(struct variable_union_info): Remove pos_src field.\n\t(vui_vec, vui_allocated): New variables.\n\t(variable_union): Pass VAR_INIT_STATUS_UNKNOWN to unshare_variable\n\tunconditionally.  Avoid XCVECNEW/free for every sorting, for dst_l\n\t== 1 use a simpler sorting algorithm.  Compute pos field right\n\taway, don't fill in pos_src.  For dst_l == 2 avoid qsort.\n\tAvoid quadratic comparison if !flag_var_tracking_uninit.\n\t(variable_canonicalize): Pass VAR_INIT_STATUS_UNKNOWN to\n\tunshare_variable unconditionally.   \n\t(dataflow_set_different_2): Removed.\n\t(dataflow_set_different): Don't traverse second hash table.\n\t(compute_bb_dataflow): Pass VAR_INIT_STATUS_UNINITIALIZED\n\tunconditionally to var_reg_set or var_mem_set.\n\t(emit_notes_in_bb): Likewise.\n\t(delete_variable_part): Pass VAR_INIT_STATUS_UNKNOWN to\n\tunshare_variable.\n\t(emit_note_insn_var_location): Don't set initialized to\n\tVAR_INIT_STATUS_INITIALIZED early.\n\t(vt_finalize): Free vui_vec if needed, clear vui_vec and\n\tvui_allocated.\n\t* rtl.c (rtx_equal_p): Don't implement on top of rtx_equal_p_cb.\n\nFrom-SVN: r148852", "tree": {"sha": "ab3aeb83121a88918bc7de4f030b190aa5e8dfae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab3aeb83121a88918bc7de4f030b190aa5e8dfae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8593e0b6b9f793572b91f36ad4e3f5bae4ea80d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8593e0b6b9f793572b91f36ad4e3f5bae4ea80d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8593e0b6b9f793572b91f36ad4e3f5bae4ea80d5"}], "stats": {"total": 461, "additions": 313, "deletions": 148}, "files": [{"sha": "7ed384a59e7cf8f6149c9b8ca1cf4990f6b24ede", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "patch": "@@ -1,5 +1,30 @@\n 2009-06-23  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* var-tracking.c (unshare_variable): Force initialized to\n+\tbe VAR_INIT_STATUS_INITIALIZED unless flag_var_tracking_uninit.\n+\t(set_variable_part): Likewise.\n+\t(struct variable_union_info): Remove pos_src field.\n+\t(vui_vec, vui_allocated): New variables.\n+\t(variable_union): Pass VAR_INIT_STATUS_UNKNOWN to unshare_variable\n+\tunconditionally.  Avoid XCVECNEW/free for every sorting, for dst_l\n+\t== 1 use a simpler sorting algorithm.  Compute pos field right\n+\taway, don't fill in pos_src.  For dst_l == 2 avoid qsort.\n+\tAvoid quadratic comparison if !flag_var_tracking_uninit.\n+\t(variable_canonicalize): Pass VAR_INIT_STATUS_UNKNOWN to\n+\tunshare_variable unconditionally.   \n+\t(dataflow_set_different_2): Removed.\n+\t(dataflow_set_different): Don't traverse second hash table.\n+\t(compute_bb_dataflow): Pass VAR_INIT_STATUS_UNINITIALIZED\n+\tunconditionally to var_reg_set or var_mem_set.\n+\t(emit_notes_in_bb): Likewise.\n+\t(delete_variable_part): Pass VAR_INIT_STATUS_UNKNOWN to\n+\tunshare_variable.\n+\t(emit_note_insn_var_location): Don't set initialized to\n+\tVAR_INIT_STATUS_INITIALIZED early.\n+\t(vt_finalize): Free vui_vec if needed, clear vui_vec and\n+\tvui_allocated.\n+\t* rtl.c (rtx_equal_p): Don't implement on top of rtx_equal_p_cb.\n+\n \t* tree-object-size.c (addr_object_size): Instead of checking\n \tfor non-NULL TREE_CHAIN of the FIELD_DECL check that there\n \tare no FIELD_DECLs following it."}, {"sha": "6d68fe875610f897b26e64cf84fa599a189048dd", "filename": "gcc/rtl.c", "status": "modified", "additions": 109, "deletions": 3, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "patch": "@@ -335,7 +335,9 @@ int currently_expanding_to_rtl;\n \f\n \n /* Same as rtx_equal_p, but call CB on each pair of rtx if CB is not NULL.  \n-   When the callback returns true, we continue with the new pair.  */\n+   When the callback returns true, we continue with the new pair.\n+   Whenever changing this function check if rtx_equal_p below doesn't need\n+   changing as well.  */\n \n int\n rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n@@ -453,12 +455,116 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n }\n \n /* Return 1 if X and Y are identical-looking rtx's.\n-   This is the Lisp function EQUAL for rtx arguments.  */\n+   This is the Lisp function EQUAL for rtx arguments.\n+   Whenever changing this function check if rtx_equal_p_cb above doesn't need\n+   changing as well.  */\n \n int\n rtx_equal_p (const_rtx x, const_rtx y)\n {\n-  return rtx_equal_p_cb (x, y, NULL);\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n+\n+  if (x == y)\n+    return 1;\n+  if (x == 0 || y == 0)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+  /* Rtx's of different codes cannot be equal.  */\n+  if (code != GET_CODE (y))\n+    return 0;\n+\n+  /* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.\n+     (REG:SI x) and (REG:HI x) are NOT equivalent.  */\n+\n+  if (GET_MODE (x) != GET_MODE (y))\n+    return 0;\n+\n+  /* Some RTL can be compared nonrecursively.  */\n+  switch (code)\n+    {\n+    case REG:\n+      return (REGNO (x) == REGNO (y));\n+\n+    case LABEL_REF:\n+      return XEXP (x, 0) == XEXP (y, 0);\n+\n+    case SYMBOL_REF:\n+      return XSTR (x, 0) == XSTR (y, 0);\n+\n+    case SCRATCH:\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+    case CONST_FIXED:\n+      return 0;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Compare the elements.  If any pair of corresponding elements\n+     fail to match, return 0 for the whole thing.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'n':\n+\tcase 'i':\n+\t  if (XINT (x, i) != XINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return 0;\n+\n+\t  /* And the corresponding elements must match.  */\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (rtx_equal_p (XVECEXP (x, i, j),  XVECEXP (y, i, j)) == 0)\n+\t      return 0;\n+\t  break;\n+\n+\tcase 'e':\n+\t  if (rtx_equal_p (XEXP (x, i), XEXP (y, i)) == 0)\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\t  if ((XSTR (x, i) || XSTR (y, i))\n+\t      && (! XSTR (x, i) || ! XSTR (y, i)\n+\t\t  || strcmp (XSTR (x, i), XSTR (y, i))))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'u':\n+\t  /* These are just backpointers, so they don't matter.  */\n+\t  break;\n+\n+\tcase '0':\n+\tcase 't':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's,\n+\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  return 1;\n }\n \n void"}, {"sha": "76354d7910006931aede9ad3a76b9bf24edf014e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 179, "deletions": 145, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "patch": "@@ -347,7 +347,6 @@ static void dataflow_set_union (dataflow_set *, dataflow_set *);\n static bool variable_part_different_p (variable_part *, variable_part *);\n static bool variable_different_p (variable, variable, bool);\n static int dataflow_set_different_1 (void **, void *);\n-static int dataflow_set_different_2 (void **, void *);\n static bool dataflow_set_different (dataflow_set *, dataflow_set *);\n static void dataflow_set_destroy (dataflow_set *);\n \n@@ -878,6 +877,9 @@ unshare_variable (dataflow_set *set, variable var,\n   var->refcount--;\n   new_var->n_var_parts = var->n_var_parts;\n \n+  if (! flag_var_tracking_uninit)\n+    initialized = VAR_INIT_STATUS_INITIALIZED;\n+\n   for (i = 0; i < var->n_var_parts; i++)\n     {\n       location_chain node;\n@@ -1202,11 +1204,14 @@ struct variable_union_info\n   /* The sum of positions in the input chains.  */\n   int pos;\n \n-  /* The position in the chains of SRC and DST dataflow sets.  */\n-  int pos_src;\n+  /* The position in the chain of DST dataflow set.  */\n   int pos_dst;\n };\n \n+/* Buffer for location list sorting and its allocated size.  */\n+static struct variable_union_info *vui_vec;\n+static int vui_allocated;\n+\n /* Compare function for qsort, order the structures by POS element.  */\n \n static int\n@@ -1263,14 +1268,9 @@ variable_union (void **slot, void *data)\n \t}\n       if (k < src->n_var_parts)\n \t{\n-\t  enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n-\t  \n-\t  if (! flag_var_tracking_uninit)\n-\t    status = VAR_INIT_STATUS_INITIALIZED;\n-\n \t  if (dstp)\n \t    *dstp = (void *) src;\n-\t  unshare_variable (set, src, status);\n+\t  unshare_variable (set, src, VAR_INIT_STATUS_UNKNOWN);\n \t}\n       else\n \t{\n@@ -1311,13 +1311,7 @@ variable_union (void **slot, void *data)\n \n   if ((dst->refcount > 1 || shared_hash_shared (set->vars))\n       && dst->n_var_parts != k)\n-    {\n-      enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n-      \n-      if (! flag_var_tracking_uninit)\n-\tstatus = VAR_INIT_STATUS_INITIALIZED;\n-      dst = unshare_variable (set, dst, status);\n-    }\n+    dst = unshare_variable (set, dst, VAR_INIT_STATUS_UNKNOWN);\n \n   i = src->n_var_parts - 1;\n   j = dst->n_var_parts - 1;\n@@ -1366,70 +1360,152 @@ variable_union (void **slot, void *data)\n \t  dst_l = 0;\n \t  for (node = dst->var_part[j].loc_chain; node; node = node->next)\n \t    dst_l++;\n-\t  vui = XCNEWVEC (struct variable_union_info, src_l + dst_l);\n \n-\t  /* Fill in the locations from DST.  */\n-\t  for (node = dst->var_part[j].loc_chain, jj = 0; node;\n-\t       node = node->next, jj++)\n+\t  if (dst_l == 1)\n \t    {\n-\t      vui[jj].lc = node;\n-\t      vui[jj].pos_dst = jj;\n-\n-\t      /* Value larger than a sum of 2 valid positions.  */\n-\t      vui[jj].pos_src = src_l + dst_l;\n+\t      /* The most common case, much simpler, no qsort is needed.  */\n+\t      location_chain dstnode = dst->var_part[j].loc_chain;\n+\t      dst->var_part[k].loc_chain = dstnode;\n+\t      dst->var_part[k].offset = dst->var_part[j].offset;\n+\t      node2 = dstnode;\n+\t      for (node = src->var_part[i].loc_chain; node; node = node->next)\n+\t\tif (!((REG_P (dstnode->loc)\n+\t\t       && REG_P (node->loc)\n+\t\t       && REGNO (dstnode->loc) == REGNO (node->loc))\n+\t\t      || rtx_equal_p (dstnode->loc, node->loc)))\n+\t\t  {\n+\t\t    location_chain new_node;\n+\n+\t\t    /* Copy the location from SRC.  */\n+\t\t    new_node = (location_chain) pool_alloc (loc_chain_pool);\n+\t\t    new_node->loc = node->loc;\n+\t\t    new_node->init = node->init;\n+\t\t    if (!node->set_src || MEM_P (node->set_src))\n+\t\t      new_node->set_src = NULL;\n+\t\t    else\n+\t\t      new_node->set_src = node->set_src;\n+\t\t    node2->next = new_node;\n+\t\t    node2 = new_node;\n+\t\t  }\n+\t      node2->next = NULL;\n \t    }\n-\n-\t  /* Fill in the locations from SRC.  */\n-\t  n = dst_l;\n-\t  for (node = src->var_part[i].loc_chain, ii = 0; node;\n-\t       node = node->next, ii++)\n+\t  else\n \t    {\n-\t      /* Find location from NODE.  */\n-\t      for (jj = 0; jj < dst_l; jj++)\n+\t      if (src_l + dst_l > vui_allocated)\n \t\t{\n-\t\t  if ((REG_P (vui[jj].lc->loc)\n-\t\t       && REG_P (node->loc)\n-\t\t       && REGNO (vui[jj].lc->loc) == REGNO (node->loc))\n-\t\t      || rtx_equal_p (vui[jj].lc->loc, node->loc))\n+\t\t  vui_allocated = MAX (vui_allocated * 2, src_l + dst_l);\n+\t\t  vui_vec = XRESIZEVEC (struct variable_union_info, vui_vec,\n+\t\t\t\t\tvui_allocated);\n+\t\t}\n+\t      vui = vui_vec;\n+\n+\t      /* Fill in the locations from DST.  */\n+\t      for (node = dst->var_part[j].loc_chain, jj = 0; node;\n+\t\t   node = node->next, jj++)\n+\t\t{\n+\t\t  vui[jj].lc = node;\n+\t\t  vui[jj].pos_dst = jj;\n+\n+\t\t  /* Pos plus value larger than a sum of 2 valid positions.  */\n+\t\t  vui[jj].pos = jj + src_l + dst_l;\n+\t\t}\n+\n+\t      /* Fill in the locations from SRC.  */\n+\t      n = dst_l;\n+\t      for (node = src->var_part[i].loc_chain, ii = 0; node;\n+\t\t   node = node->next, ii++)\n+\t\t{\n+\t\t  /* Find location from NODE.  */\n+\t\t  for (jj = 0; jj < dst_l; jj++)\n \t\t    {\n-\t\t      vui[jj].pos_src = ii;\n-\t\t      break;\n+\t\t      if ((REG_P (vui[jj].lc->loc)\n+\t\t\t   && REG_P (node->loc)\n+\t\t\t   && REGNO (vui[jj].lc->loc) == REGNO (node->loc))\n+\t\t\t  || rtx_equal_p (vui[jj].lc->loc, node->loc))\n+\t\t\t{\n+\t\t\t  vui[jj].pos = jj + ii;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  if (jj >= dst_l)\t/* The location has not been found.  */\n+\t\t    {\n+\t\t      location_chain new_node;\n+\n+\t\t      /* Copy the location from SRC.  */\n+\t\t      new_node = (location_chain) pool_alloc (loc_chain_pool);\n+\t\t      new_node->loc = node->loc;\n+\t\t      new_node->init = node->init;\n+\t\t      if (!node->set_src || MEM_P (node->set_src))\n+\t\t\tnew_node->set_src = NULL;\n+\t\t      else\n+\t\t\tnew_node->set_src = node->set_src;\n+\t\t      vui[n].lc = new_node;\n+\t\t      vui[n].pos_dst = src_l + dst_l;\n+\t\t      vui[n].pos = ii + src_l + dst_l;\n+\t\t      n++;\n \t\t    }\n \t\t}\n-\t      if (jj >= dst_l)\t/* The location has not been found.  */\n+\n+\t      if (dst_l == 2)\n \t\t{\n-\t\t  location_chain new_node;\n-\n-\t\t  /* Copy the location from SRC.  */\n-\t\t  new_node = (location_chain) pool_alloc (loc_chain_pool);\n-\t\t  new_node->loc = node->loc;\n-\t\t  new_node->init = node->init;\n-\t\t  if (!node->set_src || MEM_P (node->set_src))\n-\t\t    new_node->set_src = NULL;\n+\t\t  /* Special case still very common case.  For dst_l == 2\n+\t\t     all entries dst_l ... n-1 are sorted, with for i >= dst_l\n+\t\t     vui[i].pos == i + src_l + dst_l.  */\n+\t\t  if (vui[0].pos > vui[1].pos)\n+\t\t    {\n+\t\t      /* Order should be 1, 0, 2... */\n+\t\t      dst->var_part[k].loc_chain = vui[1].lc;\n+\t\t      vui[1].lc->next = vui[0].lc;\n+\t\t      if (n >= 3)\n+\t\t\t{\n+\t\t\t  vui[0].lc->next = vui[2].lc;\n+\t\t\t  vui[n - 1].lc->next = NULL;\n+\t\t\t}\n+\t\t      else\n+\t\t\tvui[0].lc->next = NULL;\n+\t\t      ii = 3;\n+\t\t    }\n \t\t  else\n-\t\t    new_node->set_src = node->set_src;\n-\t\t  vui[n].lc = new_node;\n-\t\t  vui[n].pos_src = ii;\n-\t\t  vui[n].pos_dst = src_l + dst_l;\n-\t\t  n++;\n+\t\t    {\n+\t\t      dst->var_part[k].loc_chain = vui[0].lc;\n+\t\t      if (n >= 3 && vui[2].pos < vui[1].pos)\n+\t\t\t{\n+\t\t\t  /* Order should be 0, 2, 1, 3... */\n+\t\t\t  vui[0].lc->next = vui[2].lc;\n+\t\t\t  vui[2].lc->next = vui[1].lc;\n+\t\t\t  if (n >= 4)\n+\t\t\t    {\n+\t\t\t      vui[1].lc->next = vui[3].lc;\n+\t\t\t      vui[n - 1].lc->next = NULL;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    vui[1].lc->next = NULL;\n+\t\t\t  ii = 4;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* Order should be 0, 1, 2... */\n+\t\t\t  ii = 1;\n+\t\t\t  vui[n - 1].lc->next = NULL;\n+\t\t\t}\n+\t\t    }\n+\t\t  for (; ii < n; ii++)\n+\t\t    vui[ii - 1].lc->next = vui[ii].lc;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  qsort (vui, n, sizeof (struct variable_union_info),\n+\t\t\t variable_union_info_cmp_pos);\n+\n+\t\t  /* Reconnect the nodes in sorted order.  */\n+\t\t  for (ii = 1; ii < n; ii++)\n+\t\t    vui[ii - 1].lc->next = vui[ii].lc;\n+\t\t  vui[n - 1].lc->next = NULL;\n+\t\t  dst->var_part[k].loc_chain = vui[0].lc;\n \t\t}\n-\t    }\n-\n-\t  for (ii = 0; ii < src_l + dst_l; ii++)\n-\t    vui[ii].pos = vui[ii].pos_src + vui[ii].pos_dst;\n-\n-\t  qsort (vui, n, sizeof (struct variable_union_info),\n-\t\t variable_union_info_cmp_pos);\n-\n-\t  /* Reconnect the nodes in sorted order.  */\n-\t  for (ii = 1; ii < n; ii++)\n-\t    vui[ii - 1].lc->next = vui[ii].lc;\n-\t  vui[n - 1].lc->next = NULL;\n-\n-\t  dst->var_part[k].loc_chain = vui[0].lc;\n-\t  dst->var_part[k].offset = dst->var_part[j].offset;\n \n-\t  free (vui);\n+\t      dst->var_part[k].offset = dst->var_part[j].offset;\n+\t    }\n \t  i--;\n \t  j--;\n \t}\n@@ -1477,17 +1553,18 @@ variable_union (void **slot, void *data)\n \tdst->var_part[k].cur_loc = NULL;\n     }\n \n-  for (i = 0; i < src->n_var_parts && i < dst->n_var_parts; i++)\n-    {\n-      location_chain node, node2;\n-      for (node = src->var_part[i].loc_chain; node; node = node->next)\n-\tfor (node2 = dst->var_part[i].loc_chain; node2; node2 = node2->next)\n-\t  if (rtx_equal_p (node->loc, node2->loc))\n-\t    {\n-\t      if (node->init > node2->init)\n-\t\tnode2->init = node->init;\n-\t    }\n-    }\n+  if (flag_var_tracking_uninit)\n+    for (i = 0; i < src->n_var_parts && i < dst->n_var_parts; i++)\n+      {\n+\tlocation_chain node, node2;\n+\tfor (node = src->var_part[i].loc_chain; node; node = node->next)\n+\t  for (node2 = dst->var_part[i].loc_chain; node2; node2 = node2->next)\n+\t    if (rtx_equal_p (node->loc, node2->loc))\n+\t      {\n+\t\tif (node->init > node2->init)\n+\t\t  node2->init = node->init;\n+\t      }\n+      }\n \n   /* Continue traversing the hash table.  */\n   return 1;\n@@ -1522,14 +1599,7 @@ variable_canonicalize (void **slot, void *data)\n \t}\n     }\n   if (k < src->n_var_parts)\n-    {\n-      enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n-\n-      if (! flag_var_tracking_uninit)\n-\tstatus = VAR_INIT_STATUS_INITIALIZED;\n-\n-      unshare_variable (set, src, status);\n-    }\n+    unshare_variable (set, src, VAR_INIT_STATUS_UNKNOWN);\n   return 1;\n }\n \n@@ -1650,34 +1720,6 @@ dataflow_set_different_1 (void **slot, void *data)\n   return 1;\n }\n \n-/* Compare variable *SLOT with the same variable in hash table DATA\n-   and set DATAFLOW_SET_DIFFERENT_VALUE if they are different.  */\n-\n-static int\n-dataflow_set_different_2 (void **slot, void *data)\n-{\n-  htab_t htab = (htab_t) data;\n-  variable var1, var2;\n-\n-  var1 = *(variable *) slot;\n-  var2 = (variable) htab_find_with_hash (htab, var1->decl,\n-\t\t\t      VARIABLE_HASH_VAL (var1->decl));\n-  if (!var2)\n-    {\n-      dataflow_set_different_value = true;\n-\n-      /* Stop traversing the hash table.  */\n-      return 0;\n-    }\n-\n-  /* If both variables are defined they have been already checked for\n-     equivalence.  */\n-  gcc_assert (!variable_different_p (var1, var2, false));\n-\n-  /* Continue traversing the hash table.  */\n-  return 1;\n-}\n-\n /* Return true if dataflow sets OLD_SET and NEW_SET differ.  */\n \n static bool\n@@ -1694,14 +1736,9 @@ dataflow_set_different (dataflow_set *old_set, dataflow_set *new_set)\n \n   htab_traverse (shared_hash_htab (old_set->vars), dataflow_set_different_1,\n \t\t shared_hash_htab (new_set->vars));\n-  if (!dataflow_set_different_value)\n-    {\n-      /* We have compared the variables which are in both hash tables\n-\t so now only check whether there are some variables in NEW_SET->VARS\n-\t which are not in OLD_SET->VARS.  */\n-      htab_traverse (shared_hash_htab (new_set->vars), dataflow_set_different_2,\n-\t\t     shared_hash_htab (old_set->vars));\n-    }\n+  /* No need to traverse the second hashtab, if both have the same number\n+     of elements and the second one had all entries found in the first one,\n+     then it can't have any extra entries.  */\n   return dataflow_set_different_value;\n }\n \n@@ -2215,15 +2252,11 @@ compute_bb_dataflow (basic_block bb)\n \t  case MO_USE:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n-\t      enum var_init_status status = VAR_INIT_STATUS_UNINITIALIZED;\n-\n-\t      if (! flag_var_tracking_uninit)\n-\t\tstatus = VAR_INIT_STATUS_INITIALIZED;\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_set (out, loc, status, NULL);\n+\t\tvar_reg_set (out, loc, VAR_INIT_STATUS_UNINITIALIZED, NULL);\n \t      else if (MEM_P (loc))\n-\t\tvar_mem_set (out, loc, status, NULL);\n+\t\tvar_mem_set (out, loc, VAR_INIT_STATUS_UNINITIALIZED, NULL);\n \t    }\n \t    break;\n \n@@ -2262,10 +2295,12 @@ compute_bb_dataflow (basic_block bb)\n \t      if (! flag_var_tracking_uninit)\n \t\tsrc_status = VAR_INIT_STATUS_INITIALIZED;\n \t      else\n-\t\tsrc_status = find_src_status (in, set_src);\n+\t\t{\n+\t\t  src_status = find_src_status (in, set_src);\n \n-\t      if (src_status == VAR_INIT_STATUS_UNKNOWN)\n-\t\tsrc_status = find_src_status (out, set_src);\n+\t\t  if (src_status == VAR_INIT_STATUS_UNKNOWN)\n+\t\t    src_status = find_src_status (out, set_src);\n+\t\t}\n \n \t      set_src = find_src_set_src (in, set_src);\n \n@@ -2609,6 +2644,9 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset,\n   variable var;\n   void **slot = shared_hash_find_slot (set->vars, decl);\n \n+  if (! flag_var_tracking_uninit)\n+    initialized = VAR_INIT_STATUS_INITIALIZED;\n+\n   if (!slot || !*slot)\n     {\n       if (!slot)\n@@ -2815,10 +2853,8 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t\t       && REGNO (node->loc) == REGNO (loc))\n \t\t      || rtx_equal_p (node->loc, loc))\n \t\t    {\n-\t\t      enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n-\t\t      if (! flag_var_tracking_uninit)\n-\t\t\tstatus = VAR_INIT_STATUS_INITIALIZED;\n-\t\t      var = unshare_variable (set, var, status);\n+\t\t      var = unshare_variable (set, var,\n+\t\t\t\t\t      VAR_INIT_STATUS_UNKNOWN);\n \t\t      break;\n \t\t    }\n \t\t}\n@@ -2893,9 +2929,6 @@ emit_note_insn_var_location (void **varp, void *data)\n \n   gcc_assert (var->decl);\n \n-  if (! flag_var_tracking_uninit)\n-    initialized = VAR_INIT_STATUS_INITIALIZED;\n-\n   complete = true;\n   last_limit = 0;\n   n_var_parts = 0;\n@@ -3147,14 +3180,11 @@ emit_notes_in_bb (basic_block bb)\n \t  case MO_USE:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n-      \n-\t      enum var_init_status status = VAR_INIT_STATUS_UNINITIALIZED;\n-\t      if (! flag_var_tracking_uninit)\n-\t\tstatus = VAR_INIT_STATUS_INITIALIZED;\n+\n \t      if (REG_P (loc))\n-\t\tvar_reg_set (&set, loc, status, NULL);\n+\t\tvar_reg_set (&set, loc, VAR_INIT_STATUS_UNINITIALIZED, NULL);\n \t      else\n-\t\tvar_mem_set (&set, loc, status, NULL);\n+\t\tvar_mem_set (&set, loc, VAR_INIT_STATUS_UNINITIALIZED, NULL);\n \n \t      emit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n \t    }\n@@ -3552,6 +3582,10 @@ vt_finalize (void)\n   free_alloc_pool (var_pool);\n   free_alloc_pool (loc_chain_pool);\n   free_alloc_pool (shared_hash_pool);\n+  if (vui_vec)\n+    free (vui_vec);\n+  vui_vec = NULL;\n+  vui_allocated = 0;\n }\n \n /* The entry point to variable tracking pass.  */"}]}