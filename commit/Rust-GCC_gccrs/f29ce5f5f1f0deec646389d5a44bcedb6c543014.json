{"sha": "f29ce5f5f1f0deec646389d5a44bcedb6c543014", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5Y2U1ZjVmMWYwZGVlYzY0NjM4OWQ1YTQ0YmNlZGI2YzU0MzAxNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-25T17:21:07Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-25T17:21:07Z"}, "message": "Implement predeclared delete function.\n\nFrom-SVN: r180438", "tree": {"sha": "39eed82e18e8d15063ea472730c729cf5fa49154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39eed82e18e8d15063ea472730c729cf5fa49154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f29ce5f5f1f0deec646389d5a44bcedb6c543014", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29ce5f5f1f0deec646389d5a44bcedb6c543014", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f29ce5f5f1f0deec646389d5a44bcedb6c543014", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29ce5f5f1f0deec646389d5a44bcedb6c543014/comments", "author": null, "committer": null, "parents": [{"sha": "09367c0d60f551d7d05b6212b649a71636b623ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09367c0d60f551d7d05b6212b649a71636b623ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09367c0d60f551d7d05b6212b649a71636b623ce"}], "stats": {"total": 161, "additions": 112, "deletions": 49}, "files": [{"sha": "e308b9a4c31906c1907ee203cad0b680881453bc", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 97, "deletions": 48, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29ce5f5f1f0deec646389d5a44bcedb6c543014/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29ce5f5f1f0deec646389d5a44bcedb6c543014/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f29ce5f5f1f0deec646389d5a44bcedb6c543014", "patch": "@@ -7048,6 +7048,7 @@ class Builtin_call_expression : public Call_expression\n       BUILTIN_CLOSE,\n       BUILTIN_COMPLEX,\n       BUILTIN_COPY,\n+      BUILTIN_DELETE,\n       BUILTIN_IMAG,\n       BUILTIN_LEN,\n       BUILTIN_MAKE,\n@@ -7113,6 +7114,8 @@ Builtin_call_expression::Builtin_call_expression(Gogo* gogo,\n     this->code_ = BUILTIN_COMPLEX;\n   else if (name == \"copy\")\n     this->code_ = BUILTIN_COPY;\n+  else if (name == \"delete\")\n+    this->code_ = BUILTIN_DELETE;\n   else if (name == \"imag\")\n     this->code_ = BUILTIN_IMAG;\n   else if (name == \"len\")\n@@ -7206,34 +7209,15 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n   if (this->classification() == EXPRESSION_ERROR)\n     return this;\n \n+  source_location loc = this->location();\n+\n   if (this->is_varargs() && this->code_ != BUILTIN_APPEND)\n     {\n       this->report_error(_(\"invalid use of %<...%> with builtin function\"));\n-      return Expression::make_error(this->location());\n+      return Expression::make_error(loc);\n     }\n \n-  if (this->code_ == BUILTIN_NEW)\n-    {\n-      const Expression_list* args = this->args();\n-      if (args == NULL || args->size() < 1)\n-\tthis->report_error(_(\"not enough arguments\"));\n-      else if (args->size() > 1)\n-\tthis->report_error(_(\"too many arguments\"));\n-      else\n-\t{\n-\t  Expression* arg = args->front();\n-\t  if (!arg->is_type_expression())\n-\t    {\n-\t      error_at(arg->location(), \"expected type\");\n-\t      this->set_is_error();\n-\t    }\n-\t  else\n-\t    return Expression::make_allocation(arg->type(), this->location());\n-\t}\n-    }\n-  else if (this->code_ == BUILTIN_MAKE)\n-    return this->lower_make();\n-  else if (this->is_constant())\n+  if (this->is_constant())\n     {\n       // We can only lower len and cap if there are no function calls\n       // in the arguments.  Otherwise we have to make the call.\n@@ -7254,8 +7238,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n       Type* type;\n       if (this->integer_constant_value(true, ival, &type))\n \t{\n-\t  Expression* ret = Expression::make_integer(&ival, type,\n-\t\t\t\t\t\t     this->location());\n+\t  Expression* ret = Expression::make_integer(&ival, type, loc);\n \t  mpz_clear(ival);\n \t  return ret;\n \t}\n@@ -7265,8 +7248,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n       mpfr_init(rval);\n       if (this->float_constant_value(rval, &type))\n \t{\n-\t  Expression* ret = Expression::make_float(&rval, type,\n-\t\t\t\t\t\t   this->location());\n+\t  Expression* ret = Expression::make_float(&rval, type, loc);\n \t  mpfr_clear(rval);\n \t  return ret;\n \t}\n@@ -7275,43 +7257,108 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n       mpfr_init(imag);\n       if (this->complex_constant_value(rval, imag, &type))\n \t{\n-\t  Expression* ret = Expression::make_complex(&rval, &imag, type,\n-\t\t\t\t\t\t     this->location());\n+\t  Expression* ret = Expression::make_complex(&rval, &imag, type, loc);\n \t  mpfr_clear(rval);\n \t  mpfr_clear(imag);\n \t  return ret;\n \t}\n       mpfr_clear(rval);\n       mpfr_clear(imag);\n     }\n-  else if (this->code_ == BUILTIN_RECOVER)\n+\n+  switch (this->code_)\n     {\n+    default:\n+      break;\n+\n+    case BUILTIN_NEW:\n+      {\n+\tconst Expression_list* args = this->args();\n+\tif (args == NULL || args->size() < 1)\n+\t  this->report_error(_(\"not enough arguments\"));\n+\telse if (args->size() > 1)\n+\t  this->report_error(_(\"too many arguments\"));\n+\telse\n+\t  {\n+\t    Expression* arg = args->front();\n+\t    if (!arg->is_type_expression())\n+\t      {\n+\t\terror_at(arg->location(), \"expected type\");\n+\t\tthis->set_is_error();\n+\t      }\n+\t    else\n+\t      return Expression::make_allocation(arg->type(), loc);\n+\t  }\n+      }\n+      break;\n+\n+    case BUILTIN_MAKE:\n+      return this->lower_make();\n+\n+    case BUILTIN_RECOVER:\n       if (function != NULL)\n \tfunction->func_value()->set_calls_recover();\n       else\n \t{\n \t  // Calling recover outside of a function always returns the\n \t  // nil empty interface.\n-\t  Type* eface = Type::make_interface_type(NULL, this->location());\n-\t  return Expression::make_cast(eface,\n-\t\t\t\t       Expression::make_nil(this->location()),\n-\t\t\t\t       this->location());\n+\t  Type* eface = Type::make_interface_type(NULL, loc);\n+\t  return Expression::make_cast(eface, Expression::make_nil(loc), loc);\n \t}\n-    }\n-  else if (this->code_ == BUILTIN_APPEND)\n-    {\n-      // Lower the varargs.\n-      const Expression_list* args = this->args();\n-      if (args == NULL || args->empty())\n-\treturn this;\n-      Type* slice_type = args->front()->type();\n-      if (!slice_type->is_slice_type())\n-\t{\n-\t  error_at(args->front()->location(), \"argument 1 must be a slice\");\n-\t  this->set_is_error();\n+      break;\n+\n+    case BUILTIN_APPEND:\n+      {\n+\t// Lower the varargs.\n+\tconst Expression_list* args = this->args();\n+\tif (args == NULL || args->empty())\n \t  return this;\n-\t}\n-      this->lower_varargs(gogo, function, inserter, slice_type, 2);\n+\tType* slice_type = args->front()->type();\n+\tif (!slice_type->is_slice_type())\n+\t  {\n+\t    error_at(args->front()->location(), \"argument 1 must be a slice\");\n+\t    this->set_is_error();\n+\t    return this;\n+\t  }\n+\tthis->lower_varargs(gogo, function, inserter, slice_type, 2);\n+      }\n+      break;\n+\n+    case BUILTIN_DELETE:\n+      {\n+\t// Lower to a runtime function call.\n+\tconst Expression_list* args = this->args();\n+\tif (args == NULL || args->size() < 2)\n+\t  this->report_error(_(\"not enough arguments\"));\n+\telse if (args->size() > 2)\n+\t  this->report_error(_(\"too many arguments\"));\n+\telse if (args->front()->type()->map_type() == NULL)\n+\t  this->report_error(_(\"argument 1 must be a map\"));\n+\telse\n+\t  {\n+\t    // Since this function returns no value it must appear in\n+\t    // a statement by itself, so we don't have to worry about\n+\t    // order of evaluation of values around it.  Evaluate the\n+\t    // map first to get order of evaluation right.\n+\t    Map_type* mt = args->front()->type()->map_type();\n+\t    Temporary_statement* map_temp =\n+\t      Statement::make_temporary(mt, args->front(), loc);\n+\t    inserter->insert(map_temp);\n+\n+\t    Temporary_statement* key_temp =\n+\t      Statement::make_temporary(mt->key_type(), args->back(), loc);\n+\t    inserter->insert(key_temp);\n+\n+\t    Expression* e1 = Expression::make_temporary_reference(map_temp,\n+\t\t\t\t\t\t\t\t  loc);\n+\t    Expression* e2 = Expression::make_temporary_reference(key_temp,\n+\t\t\t\t\t\t\t\t  loc);\n+\t    e2 = Expression::make_unary(OPERATOR_AND, e2, loc);\n+\t    return Runtime::make_call(Runtime::MAPDELETE, this->location(),\n+\t\t\t\t      2, e1, e2);\n+\t  }\n+      }\n+      break;\n     }\n \n   return this;\n@@ -7845,6 +7892,7 @@ Builtin_call_expression::do_discarding_value()\n \n     case BUILTIN_CLOSE:\n     case BUILTIN_COPY:\n+    case BUILTIN_DELETE:\n     case BUILTIN_PANIC:\n     case BUILTIN_PRINT:\n     case BUILTIN_PRINTLN:\n@@ -7882,6 +7930,7 @@ Builtin_call_expression::do_type()\n       return Type::lookup_integer_type(\"int\");\n \n     case BUILTIN_CLOSE:\n+    case BUILTIN_DELETE:\n     case BUILTIN_PANIC:\n     case BUILTIN_PRINT:\n     case BUILTIN_PRINTLN:"}, {"sha": "18436abd29c5c4d8910c40d5e4fd8f1b6d50c270", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29ce5f5f1f0deec646389d5a44bcedb6c543014/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29ce5f5f1f0deec646389d5a44bcedb6c543014/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f29ce5f5f1f0deec646389d5a44bcedb6c543014", "patch": "@@ -201,6 +201,11 @@ Gogo::Gogo(Backend* backend, int int_type_size, int pointer_size)\n   imag_type->set_is_varargs();\n   imag_type->set_is_builtin();\n   this->globals_->add_function_declaration(\"imag\", NULL, imag_type, loc);\n+\n+  Function_type* delete_type = Type::make_function_type(NULL, NULL, NULL, loc);\n+  delete_type->set_is_varargs();\n+  delete_type->set_is_builtin();\n+  this->globals_->add_function_declaration(\"delete\", NULL, delete_type, loc);\n }\n \n // Munge name for use in an error message."}, {"sha": "d742e5b0c792781bd7814f61220e102de0c81e97", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29ce5f5f1f0deec646389d5a44bcedb6c543014/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29ce5f5f1f0deec646389d5a44bcedb6c543014/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=f29ce5f5f1f0deec646389d5a44bcedb6c543014", "patch": "@@ -94,6 +94,9 @@ DEF_GO_RUNTIME(MAPACCESS2, \"runtime.mapaccess2\",\n DEF_GO_RUNTIME(MAPASSIGN2, \"runtime.mapassign2\",\n \t       P4(MAP, POINTER, POINTER, BOOL), R0())\n \n+// Delete a key from a map.\n+DEF_GO_RUNTIME(MAPDELETE, \"runtime.mapdelete\", P2(MAP, POINTER), R0())\n+\n // Begin a range over a map.\n DEF_GO_RUNTIME(MAPITERINIT, \"runtime.mapiterinit\", P2(MAP, MAPITER), R0())\n "}, {"sha": "a8f928f0c9a4e86d9a2f1594a4754f02e770f172", "filename": "libgo/runtime/go-map-delete.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29ce5f5f1f0deec646389d5a44bcedb6c543014/libgo%2Fruntime%2Fgo-map-delete.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29ce5f5f1f0deec646389d5a44bcedb6c543014/libgo%2Fruntime%2Fgo-map-delete.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-delete.c?ref=f29ce5f5f1f0deec646389d5a44bcedb6c543014", "patch": "@@ -27,7 +27,7 @@ __go_map_delete (struct __go_map *map, const void *key)\n   void **pentry;\n \n   if (map == NULL)\n-    __go_panic_msg (\"assignment to entry in nil map\");\n+    __go_panic_msg (\"deletion of entry in nil map\");\n \n   descriptor = map->__descriptor;\n "}, {"sha": "da67d49287d75c88608c918738cc962aec817953", "filename": "libgo/runtime/map.goc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29ce5f5f1f0deec646389d5a44bcedb6c543014/libgo%2Fruntime%2Fmap.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29ce5f5f1f0deec646389d5a44bcedb6c543014/libgo%2Fruntime%2Fmap.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmap.goc?ref=f29ce5f5f1f0deec646389d5a44bcedb6c543014", "patch": "@@ -45,6 +45,12 @@ func mapassign2(h *Hmap, key *byte, val *byte, p bool) {\n \t}\n }\n \n+/* Delete a key from a map.  */\n+\n+func mapdelete(h *Hmap, key *byte) {\n+\t__go_map_delete(h, key);\n+}\n+\n /* Initialize a range over a map.  */\n \n func mapiterinit(h *Hmap, it *hiter) {"}]}