{"sha": "539405d5541e31914995e5efbd4660ddf382f834", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM5NDA1ZDU1NDFlMzE5MTQ5OTVlNWVmYmQ0NjYwZGRmMzgyZjgzNA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-10-28T12:31:37Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-10-28T12:31:37Z"}, "message": "S/390: Add static OSC breaker if necessary.\n\nThis patch adds a magic OSC (operand store compare) break instruction\nwhich is necessary if a store is followed closely by a load with same\nbase+indx+displ while either base or index get modified in between.\n\nThe patch improves several SpecCPU testcases running on IBM z13.\n\ngcc/testsuite/ChangeLog:\n\n2016-10-28  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/oscbreak-1.c: New test.\n\ngcc/ChangeLog:\n\n2016-10-28  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_adjust_loop_scan_osc): New function.\n\t(s390_adjust_loops): New function.\n\t(s390_reorg): Invoke s390_adjust_loops.\n\t* config/s390/s390.md: (UNSPEC_OSC_BREAK): New constant.\n\t(\"osc_break\"): New insn definition.\n\nFrom-SVN: r241644", "tree": {"sha": "2c194d85a345839f86cb019c38ef6b0c569752ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c194d85a345839f86cb019c38ef6b0c569752ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/539405d5541e31914995e5efbd4660ddf382f834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539405d5541e31914995e5efbd4660ddf382f834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/539405d5541e31914995e5efbd4660ddf382f834", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539405d5541e31914995e5efbd4660ddf382f834/comments", "author": null, "committer": null, "parents": [{"sha": "0dbb19f0f1542f9e61e599cbd25111f5de811929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dbb19f0f1542f9e61e599cbd25111f5de811929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dbb19f0f1542f9e61e599cbd25111f5de811929"}], "stats": {"total": 197, "additions": 197, "deletions": 0}, "files": [{"sha": "37637fb7c211dab8784db550cc628e548974fcc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539405d5541e31914995e5efbd4660ddf382f834/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539405d5541e31914995e5efbd4660ddf382f834/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=539405d5541e31914995e5efbd4660ddf382f834", "patch": "@@ -1,3 +1,11 @@\n+2016-10-28  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_adjust_loop_scan_osc): New function.\n+\t(s390_adjust_loops): New function.\n+\t(s390_reorg): Invoke s390_adjust_loops.\n+\t* config/s390/s390.md: (UNSPEC_OSC_BREAK): New constant.\n+\t(\"osc_break\"): New insn definition.\n+\n 2016-10-28  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.opt: Support alternate cpu level naming (archXX)."}, {"sha": "3554f339f3f1c3111f929bd721c7d419d06bfc7e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539405d5541e31914995e5efbd4660ddf382f834/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539405d5541e31914995e5efbd4660ddf382f834/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=539405d5541e31914995e5efbd4660ddf382f834", "patch": "@@ -13502,6 +13502,155 @@ s390_z10_optimize_cmp (rtx_insn *insn)\n   return insn_added_p;\n }\n \n+/* Number of INSNs to be scanned backward in the last BB of the loop\n+   and forward in the first BB of the loop.  This usually should be a\n+   bit more than the number of INSNs which could go into one\n+   group.  */\n+#define S390_OSC_SCAN_INSN_NUM 5\n+\n+/* Scan LOOP for static OSC collisions and return true if a osc_break\n+   should be issued for this loop.  */\n+static bool\n+s390_adjust_loop_scan_osc (struct loop* loop)\n+\n+{\n+  HARD_REG_SET modregs, newregs;\n+  rtx_insn *insn, *store_insn = NULL;\n+  rtx set;\n+  struct s390_address addr_store, addr_load;\n+  subrtx_iterator::array_type array;\n+  int insn_count;\n+\n+  CLEAR_HARD_REG_SET (modregs);\n+\n+  insn_count = 0;\n+  FOR_BB_INSNS_REVERSE (loop->latch, insn)\n+    {\n+      if (!INSN_P (insn) || INSN_CODE (insn) <= 0)\n+\tcontinue;\n+\n+      insn_count++;\n+      if (insn_count > S390_OSC_SCAN_INSN_NUM)\n+\treturn false;\n+\n+      find_all_hard_reg_sets (insn, &newregs, true);\n+      IOR_HARD_REG_SET (modregs, newregs);\n+\n+      set = single_set (insn);\n+      if (!set)\n+\tcontinue;\n+\n+      if (MEM_P (SET_DEST (set))\n+\t  && s390_decompose_address (XEXP (SET_DEST (set), 0), &addr_store))\n+\t{\n+\t  store_insn = insn;\n+\t  break;\n+\t}\n+    }\n+\n+  if (store_insn == NULL_RTX)\n+    return false;\n+\n+  insn_count = 0;\n+  FOR_BB_INSNS (loop->header, insn)\n+    {\n+      if (!INSN_P (insn) || INSN_CODE (insn) <= 0)\n+\tcontinue;\n+\n+      if (insn == store_insn)\n+\treturn false;\n+\n+      insn_count++;\n+      if (insn_count > S390_OSC_SCAN_INSN_NUM)\n+\treturn false;\n+\n+      find_all_hard_reg_sets (insn, &newregs, true);\n+      IOR_HARD_REG_SET (modregs, newregs);\n+\n+      set = single_set (insn);\n+      if (!set)\n+\tcontinue;\n+\n+      /* An intermediate store disrupts static OSC checking\n+\t anyway.  */\n+      if (MEM_P (SET_DEST (set))\n+\t  && s390_decompose_address (XEXP (SET_DEST (set), 0), NULL))\n+\treturn false;\n+\n+      FOR_EACH_SUBRTX (iter, array, SET_SRC (set), NONCONST)\n+\tif (MEM_P (*iter)\n+\t    && s390_decompose_address (XEXP (*iter, 0), &addr_load)\n+\t    && rtx_equal_p (addr_load.base, addr_store.base)\n+\t    && rtx_equal_p (addr_load.indx, addr_store.indx)\n+\t    && rtx_equal_p (addr_load.disp, addr_store.disp))\n+\t  {\n+\t    if ((addr_load.base != NULL_RTX\n+\t\t && TEST_HARD_REG_BIT (modregs, REGNO (addr_load.base)))\n+\t\t|| (addr_load.indx != NULL_RTX\n+\t\t    && TEST_HARD_REG_BIT (modregs, REGNO (addr_load.indx))))\n+\t      return true;\n+\t  }\n+    }\n+  return false;\n+}\n+\n+/* Look for adjustments which can be done on simple innermost\n+   loops.  */\n+static void\n+s390_adjust_loops ()\n+{\n+  struct loop *loop = NULL;\n+\n+  df_analyze ();\n+  compute_bb_for_insn ();\n+\n+  /* Find the loops.  */\n+  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+\n+  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n+    {\n+      if (dump_file)\n+\t{\n+\t  flow_loop_dump (loop, dump_file, NULL, 0);\n+\t  fprintf (dump_file, \";;  OSC loop scan Loop: \");\n+\t}\n+      if (loop->latch == NULL\n+\t  || pc_set (BB_END (loop->latch)) == NULL_RTX\n+\t  || !s390_adjust_loop_scan_osc (loop))\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      if (loop->latch == NULL)\n+\t\tfprintf (dump_file, \" muliple backward jumps\\n\");\n+\t      else\n+\t\t{\n+\t\t  fprintf (dump_file, \" header insn: %d latch insn: %d \",\n+\t\t\t   INSN_UID (BB_HEAD (loop->header)),\n+\t\t\t   INSN_UID (BB_END (loop->latch)));\n+\t\t  if (pc_set (BB_END (loop->latch)) == NULL_RTX)\n+\t\t    fprintf (dump_file, \" loop does not end with jump\\n\");\n+\t\t  else\n+\t\t    fprintf (dump_file, \" not instrumented\\n\");\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rtx_insn *new_insn;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" adding OSC break insn: \");\n+\t  new_insn = emit_insn_before (gen_osc_break (),\n+\t\t\t\t       BB_END (loop->latch));\n+\t  INSN_ADDRESSES_NEW (new_insn, -1);\n+\t}\n+    }\n+\n+  loop_optimizer_finalize ();\n+\n+  df_finish_pass (false);\n+}\n+\n /* Perform machine-dependent processing.  */\n \n static void\n@@ -13510,6 +13659,9 @@ s390_reorg (void)\n   bool pool_overflow = false;\n   int hw_before, hw_after;\n \n+  if (s390_tune == PROCESSOR_2964_Z13)\n+    s390_adjust_loops ();\n+\n   /* Make sure all splits have been performed; splits after\n      machine_dependent_reorg might confuse insn length counts.  */\n   split_all_insns_noflow ();"}, {"sha": "fedd6f97a9847f47be964d307ff61e56c3e4aace", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539405d5541e31914995e5efbd4660ddf382f834/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539405d5541e31914995e5efbd4660ddf382f834/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=539405d5541e31914995e5efbd4660ddf382f834", "patch": "@@ -280,6 +280,8 @@\n    ; Split stack support\n    UNSPECV_SPLIT_STACK_CALL\n    UNSPECV_SPLIT_STACK_DATA\n+\n+   UNSPECV_OSC_BREAK\n   ])\n \n ;;\n@@ -11197,3 +11199,9 @@\n   \"jg%C1\\t%0\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"  \"branch\")])\n+\n+(define_insn \"osc_break\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_OSC_BREAK)]\n+  \"\"\n+  \"bcr\\t7,%%r0\"\n+  [(set_attr \"op_type\" \"RR\")])"}, {"sha": "a51fcf4d7b504c549ab928ba1494911d511690c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539405d5541e31914995e5efbd4660ddf382f834/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539405d5541e31914995e5efbd4660ddf382f834/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=539405d5541e31914995e5efbd4660ddf382f834", "patch": "@@ -1,3 +1,7 @@\n+2016-10-28  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/oscbreak-1.c: New test.\n+\n 2016-10-28  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/target-attribute/tattr-m64-33.c: New test."}, {"sha": "fdf356c1fd0d415b8231911981322feb9507fe78", "filename": "gcc/testsuite/gcc.target/s390/oscbreak-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539405d5541e31914995e5efbd4660ddf382f834/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Foscbreak-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539405d5541e31914995e5efbd4660ddf382f834/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Foscbreak-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Foscbreak-1.c?ref=539405d5541e31914995e5efbd4660ddf382f834", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mtune=z13 -dp\" } */\n+\n+void\n+foo (char *a, int b)\n+{\n+  int i;\n+\n+  for (i = 0; i < b; i++)\n+    a[i] += 1;\n+}\n+\n+void\n+bar (char *a, int b)\n+{\n+  int i;\n+\n+  for (i = 0; i < b; i++)\n+    {\n+      if (a[i] & 1)\n+\ta[i] = 1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"osc_break\" } } */"}]}