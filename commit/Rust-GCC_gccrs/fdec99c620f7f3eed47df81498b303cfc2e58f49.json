{"sha": "fdec99c620f7f3eed47df81498b303cfc2e58f49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRlYzk5YzYyMGY3ZjNlZWQ0N2RmODE0OThiMzAzY2ZjMmU1OGY0OQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-12T19:25:01Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-12T19:25:01Z"}, "message": "expr.c (encode_newarray_type, [...]): New functions.\n\nd\n\t* expr.c (encode_newarray_type, build_new_array):  New functions.\n\t* java-tree.h:  Declare build_new_array.\n\t* jcf-write.c (patch_newarray):  Use build_new_array.\n\t* expr.c (java_lang_expand_exp):  Support NEW_ARRAY_INIT.\n\t* jcf-write.c (generate_bytecode_insns):  Support NEW_ARRAY_INIT.\n\t* parse.y (patch_new_array_init):  Re-organize.\n\tNow is passed the actual array (pointer) type of the value.\n\tSet the type of the CONSTRUCTOR to be an ARRAY_TYPE.\n\t(patch_array_constructor):  Removed - merged into patch_new_array_init.\n \t(java_complete_tree):  Update patch_new_array_init.\n\t* jcf-write.c (find_constant_index):  New function.\n\t(generate_bytecode_insns):  Use find_constant_index.\n\t(generate_classfile):  Use find_constant_index for ConstantValue.\n\nFrom-SVN: r24273", "tree": {"sha": "dfc11d7c104023d713f597a70153320b359eaed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfc11d7c104023d713f597a70153320b359eaed2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdec99c620f7f3eed47df81498b303cfc2e58f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdec99c620f7f3eed47df81498b303cfc2e58f49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdec99c620f7f3eed47df81498b303cfc2e58f49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdec99c620f7f3eed47df81498b303cfc2e58f49/comments", "author": null, "committer": null, "parents": [{"sha": "df1e6be5cc6dd6f008825fcf3076c7a84f7cb3d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1e6be5cc6dd6f008825fcf3076c7a84f7cb3d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df1e6be5cc6dd6f008825fcf3076c7a84f7cb3d4"}], "stats": {"total": 196, "additions": 109, "deletions": 87}, "files": [{"sha": "aa1b652341c4005701817f54ec4f3ad4f0a8d0b8", "filename": "gcc/java/expr.c", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdec99c620f7f3eed47df81498b303cfc2e58f49/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdec99c620f7f3eed47df81498b303cfc2e58f49/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=fdec99c620f7f3eed47df81498b303cfc2e58f49", "patch": "@@ -532,6 +532,32 @@ decode_newarray_type  (int atype)\n     }\n }\n \n+/* Map primitive type to the code used by OPCODE_newarray. */\n+\n+int\n+encode_newarray_type (type)\n+     tree type;\n+{\n+  if (type == boolean_type_node)\n+    return 4;\n+  else if (type == char_type_node)\n+    return 5;\n+  else if (type == float_type_node)\n+    return 6;\n+  else if (type == double_type_node)\n+    return 7;\n+  else if (type == byte_type_node)\n+    return 8;\n+  else if (type == short_type_node)\n+    return 9;\n+  else if (type == int_type_node)\n+    return 10;\n+  else if (type == long_type_node)\n+    return 11;\n+  else\n+    fatal (\"Can't compute type code - patch_newarray\");\n+}\n+\n /* Build a call to _Jv_ThrowBadArrayIndex(), the\n    ArrayIndexOfBoundsException exception handler.  */\n \n@@ -707,7 +733,7 @@ build_newarray (atype_value, length)\n \n /* Generates anewarray from a given CLASS_TYPE. Gets from the stack the size\n    of the dimension. */\n-/* Merge with build_newarray.  FIXME. */\n+\n tree\n build_anewarray (class_type, length)\n     tree class_type;\n@@ -726,6 +752,19 @@ build_anewarray (class_type, length)\n \t\tNULL_TREE);\n }\n \n+/* Return a node the evaluates 'new TYPE[LENGTH]'. */\n+\n+tree\n+build_new_array (type, length)\n+     tree type;\n+     tree length;\n+{\n+  if (JPRIMITIVE_TYPE_P (type))\n+    return build_newarray (encode_newarray_type (type), length);\n+  else\n+    return build_anewarray (TREE_TYPE (type), length);\n+}\n+\n /* Generates a call to _Jv_NewMultiArray. multianewarray expects a\n    class pointer, a number of dimensions and the matching number of\n    dimensions. The argument list is NULL terminated.  */\n@@ -1717,6 +1756,39 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \n   switch (TREE_CODE (exp))\n     {\n+    case NEW_ARRAY_INIT:\n+      {\n+\trtx tmp, elements;\n+\ttree array_type = TREE_TYPE (TREE_TYPE (exp));\n+\ttree element_type = TYPE_ARRAY_ELEMENT (array_type);\n+\ttree data_fld = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (array_type)));\n+\tHOST_WIDE_INT ilength = java_array_type_length (array_type);\n+\ttree length = build_int_2 (ilength, 0);\n+\ttree init = TREE_OPERAND (exp, 0);\n+\ttree array_decl = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (exp));\n+\texpand_decl (array_decl);\n+\ttmp = expand_assignment (array_decl,\n+\t\t\t\t build_new_array (element_type, length),\n+\t\t\t\t 1, 0);\n+\tif (TREE_CONSTANT (init)\n+\t    && ilength >= 10 && JPRIMITIVE_TYPE_P (element_type))\n+\t  {\n+\t    tree init_decl = build_decl (VAR_DECL, generate_name (),\n+\t\t\t\t\t TREE_TYPE (init));\n+\t    pushdecl_top_level (init_decl);\n+\t    TREE_STATIC (init_decl) = 1;\n+\t    DECL_INITIAL (init_decl) = init;\n+\t    DECL_IGNORED_P (init_decl) = 1;\n+\t    TREE_READONLY (init_decl) = 1;\n+\t    make_decl_rtl (init_decl, NULL, 1);\n+\t    init = init_decl;\n+\t  }\n+\texpand_assignment (build (COMPONENT_REF, TREE_TYPE (data_fld),\n+\t\t\t\t  build1 (INDIRECT_REF, array_type, array_decl),\n+\t\t\t\t  data_fld),\n+\t\t\t   init, 0, 0);\n+\treturn tmp;\n+      }\n     case BLOCK:\n       if (BLOCK_EXPR_BODY (exp))\n \t{"}, {"sha": "f220a465fa2c6f57c1a7e8da8c9cb5ac151f7fb7", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdec99c620f7f3eed47df81498b303cfc2e58f49/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdec99c620f7f3eed47df81498b303cfc2e58f49/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=fdec99c620f7f3eed47df81498b303cfc2e58f49", "patch": "@@ -538,6 +538,7 @@ extern tree binary_numeric_promotion PROTO ((tree, tree, tree *, tree *));\n extern tree build_java_arrayaccess PROTO ((tree, tree, tree));\n extern tree build_newarray PROTO ((int, tree));\n extern tree build_anewarray PROTO ((tree, tree));\n+extern tree build_new_array PROTO ((tree, tree));\n extern tree build_java_array_length_access PROTO ((tree));\n extern tree build_java_arraynull_check PROTO ((tree, tree, tree));\n extern tree create_label_decl PROTO ((tree));"}, {"sha": "1e0f0f4d938ea9de79f5e8e0d857c7a34204269e", "filename": "gcc/java/parse.y", "status": "modified", "additions": 35, "deletions": 86, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdec99c620f7f3eed47df81498b303cfc2e58f49/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdec99c620f7f3eed47df81498b303cfc2e58f49/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=fdec99c620f7f3eed47df81498b303cfc2e58f49", "patch": "@@ -234,7 +234,6 @@ static tree find_expr_with_wfl PROTO ((tree));\n static void missing_return_error PROTO ((tree));\n static tree build_new_array_init PROTO ((int, tree));\n static tree patch_new_array_init PROTO ((tree, tree));\n-static tree patch_array_constructor PROTO ((tree, tree));\n static tree maybe_build_array_element_wfl PROTO ((tree));\n static int array_constructor_check_entry PROTO ((tree, tree));\n static char *purify_type_name PROTO ((char *));\n@@ -7733,7 +7732,7 @@ java_complete_tree (node)\n       /* If we're about to patch a NEW_ARRAY_INIT, we call a special\n \t function to complete this RHS */\n       if (TREE_CODE (wfl_op2) == NEW_ARRAY_INIT)\n-\tnn = patch_new_array_init (GET_SKIP_TYPE (TREE_OPERAND (node, 0)),\n+\tnn = patch_new_array_init (TREE_TYPE (TREE_OPERAND (node, 0)),\n \t\t\t\t   TREE_OPERAND (node, 1));\n       else\n \tnn = java_complete_tree (TREE_OPERAND (node, 1));\n@@ -9679,33 +9678,7 @@ patch_newarray (node)\n      of dimension is equal to 1, then the nature of the base type\n      (primitive or not) matters. */\n   if (ndims == 1)\n-    {\n-      if (JPRIMITIVE_TYPE_P (type))\n-\t{\n-\t  int type_code;\n-\t  if (type == boolean_type_node)\n-\t    type_code = 4;\n-\t  else if (type == char_type_node)\n-\t    type_code = 5;\n-\t  else if (type == float_type_node)\n-\t    type_code = 6;\n-\t  else if (type == double_type_node)\n-\t    type_code = 7;\n-\t  else if (type == byte_type_node)\n-\t    type_code = 8;\n-\t  else if (type == short_type_node)\n-\t    type_code = 9;\n-\t  else if (type == int_type_node)\n-\t    type_code = 10;\n-\t  else if (type == long_type_node)\n-\t    type_code = 11;\n-\t  else\n-\t    fatal (\"Can't compute type code - patch_newarray\");\n-\t  return build_newarray (type_code, TREE_VALUE (dims));\n-\t}\n-      else\n-\treturn build_anewarray (TREE_TYPE (type), TREE_VALUE (dims));\n-    }\n+    return build_new_array (type, TREE_VALUE (dims));\n   \n   /* Can't reuse what's already written in expr.c because it uses the\n      JVM stack representation. Provide a build_multianewarray. FIXME */\n@@ -9755,59 +9728,43 @@ build_new_array_init (location, values)\n static tree\n patch_new_array_init (type, node)\n      tree type, node;\n-{\n-  TREE_OPERAND (node, 0) =\n-    patch_array_constructor (type, TREE_OPERAND (node, 0));\n-\n-  if (TREE_OPERAND (node, 0) == error_mark_node)\n-    return error_mark_node;\n-\n-  TREE_TYPE (node) = TREE_TYPE (TREE_OPERAND (node, 0));\n-  return node;\n-}\n-\n-/* Choose to walk further NEW_ARRAY_INIT or check array assignment\n-   when reaching the leaves of the initializing expression. Report\n-   error_mark_node if errors were encountered, otherwise return NODE\n-   after having set it type.  */\n-\n-static tree\n-patch_array_constructor (type, node)\n-     tree type, node;\n {\n   int error_seen = 0;\n-  tree current, lhs_type;\n+  tree current, element_type;\n   HOST_WIDE_INT length;\n+  int all_constant = 1;\n+  tree init = TREE_OPERAND (node, 0);\n \n-  CONSTRUCTOR_ELTS (node) = nreverse (CONSTRUCTOR_ELTS (node));\n-  lhs_type = GET_SKIP_TYPE (type);\n+  if (TREE_CODE (type) != POINTER_TYPE || ! TYPE_ARRAY_P (TREE_TYPE (type)))\n+    {\n+      parse_error_context (node,\n+\t\t\t   \"Invalid array initializer for non-array type `%s'\",\n+\t\t\t   lang_printable_name (type, 1));\n+      return error_mark_node;\n+    }\n+  type = TREE_TYPE (type);\n+  element_type = TYPE_ARRAY_ELEMENT (type);\n \n-  if (TYPE_ARRAY_P (lhs_type))\n+  CONSTRUCTOR_ELTS (init) = nreverse (CONSTRUCTOR_ELTS (init));\n+\n+  for (length = 0, current = CONSTRUCTOR_ELTS (init);\n+       current;  length++, current = TREE_CHAIN (current))\n     {\n-      /* Verify that we have what we expect here. This points a\n-\t discrepancy between the annouced type and the specified\n-\t one. */\n-      for (length = 0, current = CONSTRUCTOR_ELTS (node);\n-\t   current; length++, current = TREE_CHAIN (current))\n+      tree elt = TREE_VALUE (current);\n+      if (elt == NULL_TREE || TREE_CODE (elt) != NEW_ARRAY_INIT)\n \t{\n-\t  tree elt = TREE_VALUE (current);\n-\t  if (elt && TREE_CODE (elt) == NEW_ARRAY_INIT)\n-\t    TREE_VALUE (current) = patch_new_array_init (lhs_type, elt);\n-\t  /* We're under dimensioned: we want to have elements\n-             examined. */\n-\t  else\n-\t    error_seen |= array_constructor_check_entry (lhs_type, current);\n-\t  if ((elt && TREE_VALUE (elt) == error_mark_node) || error_seen)\n-\t    error_seen = 1;\n+\t  error_seen |= array_constructor_check_entry (element_type, current);\n+\t  if (! TREE_CONSTANT (TREE_VALUE (current)))\n+\t    all_constant = 0;\n \t}\n-    }\n-  else\n-    {\n-      /* This is the list of the values that need to be affected. We\n-\t browse the list and check for a valid assignment */\n-      for (length = 0, current = CONSTRUCTOR_ELTS (node);\n-\t   current; length++, current = TREE_CHAIN (current))\n-\terror_seen |= array_constructor_check_entry (lhs_type, current);\n+      else\n+\t{\n+\t  TREE_VALUE (current) = patch_new_array_init (element_type, elt);\n+\t  TREE_PURPOSE (current) = NULL_TREE;\n+\t  all_constant = 0;\n+\t}\n+      if (elt && TREE_VALUE (elt) == error_mark_node)\n+\terror_seen = 1;\n     }\n \n   if (error_seen)\n@@ -9816,7 +9773,10 @@ patch_array_constructor (type, node)\n   /* Create a new type. We can't reuse the one we have here by\n      patching its dimension because it originally is of dimension -1\n      hence reused by gcc. This would prevent triangular arrays. */\n-  TREE_TYPE (node) = promote_type (build_java_array_type (lhs_type, length));\n+  type = build_java_array_type (element_type, length);\n+  TREE_TYPE (init) = TREE_TYPE (TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (type))));\n+  TREE_TYPE (node) = promote_type (type);\n+  TREE_CONSTANT (init) = all_constant;\n   return node;\n }\n \n@@ -9835,17 +9795,6 @@ array_constructor_check_entry (type, entry)\n   new_value = NULL_TREE;\n   wfl_value = TREE_VALUE (entry);\n \n-  /* If we have a TREE_LIST here, it means that we're specifying more\n-     dimensions that we should. Report errors within the list. */\n-  if (TREE_CODE (wfl_value) == NEW_ARRAY_INIT)\n-    {\n-      if (TREE_CODE (wfl_value) == NEW_ARRAY_INIT)\n-\tEXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (wfl_value);\n-      parse_error_context (wfl_operator, \"Invalid initializer for type `%s'\",\n-\t\t\t   lang_printable_name (type, 1));\n-      return 1;\n-    }\n-  \n   value = java_complete_tree (TREE_VALUE (entry));\n   /* patch_string return error_mark_node if arg is error_mark_node */\n   if ((patched = patch_string (value)))"}]}