{"sha": "a45f333130536a0dcfb468a6b49e6e81c5fab882", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ1ZjMzMzEzMDUzNmEwZGNmYjQ2OGE2YjQ5ZTZlODFjNWZhYjg4Mg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1999-04-07T23:03:01Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1999-04-07T23:03:01Z"}, "message": "Patch to make nested functions and non-local gotos work.\n\n\t* i960/i960.c (i960_function_prologue): Don't save static chain\n\tpointer.\n\t* i960/i960.h (STACK_CHAIN_REGNUM): Change from r3 to g12.\n\t(TRAMPOLINE_TEMPLATE): Likewise.\n\t(FRAME_POINTER_REQUIRED): Check current_function_has_nonlocal_goto.\n\t* i960/i960.md (nonlocal_goto): Rewrite.\n\nFrom-SVN: r26282", "tree": {"sha": "3cf5f3681bab1e977ba1d47b3c774799d44c43e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cf5f3681bab1e977ba1d47b3c774799d44c43e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a45f333130536a0dcfb468a6b49e6e81c5fab882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45f333130536a0dcfb468a6b49e6e81c5fab882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a45f333130536a0dcfb468a6b49e6e81c5fab882", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45f333130536a0dcfb468a6b49e6e81c5fab882/comments", "author": null, "committer": null, "parents": [{"sha": "9a566c09260a094d6d8416bd3c8c3783bcd40f5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a566c09260a094d6d8416bd3c8c3783bcd40f5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a566c09260a094d6d8416bd3c8c3783bcd40f5a"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "d7c4dba6b4e2ee7df6dd0cb55642cf891194e3d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45f333130536a0dcfb468a6b49e6e81c5fab882/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45f333130536a0dcfb468a6b49e6e81c5fab882/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a45f333130536a0dcfb468a6b49e6e81c5fab882", "patch": "@@ -1,3 +1,12 @@\n+Wed Apr  7 22:40:19 1999  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* i960/i960.c (i960_function_prologue): Don't save static chain\n+\tpointer.\n+\t* i960/i960.h (STACK_CHAIN_REGNUM): Change from r3 to g12.\n+\t(TRAMPOLINE_TEMPLATE): Likewise.\n+\t(FRAME_POINTER_REQUIRED): Check current_function_has_nonlocal_goto.\n+\t* i960/i960.md (nonlocal_goto): Rewrite.\n+\t\n Tue Apr  6 17:49:49 1999  Philip Blundell  <pb@nexus.co.uk>\n \n \t* config/arm/lib1funcs.asm: Test for __ELF__ not __elf__."}, {"sha": "535d05e80d17eca634e62d278dbbe4a233e97c1f", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45f333130536a0dcfb468a6b49e6e81c5fab882/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45f333130536a0dcfb468a6b49e6e81c5fab882/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=a45f333130536a0dcfb468a6b49e6e81c5fab882", "patch": "@@ -1349,7 +1349,9 @@ i960_function_prologue (file, size)\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (regs_ever_live[i]\n-\t&& ((! call_used_regs[i]) || (i > 7 && i < 12)))\n+\t&& ((! call_used_regs[i]) || (i > 7 && i < 12))\n+\t/* No need to save the static chain pointer.  */\n+\t&& ! (i == STATIC_CHAIN_REGNUM && current_function_needs_context))\n       {\n \tregs[i] = -1;\n         /* Count global registers that need saving.  */"}, {"sha": "fdf419903ccbfbfdc40af33bb5b7c3df789cc936", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45f333130536a0dcfb468a6b49e6e81c5fab882/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45f333130536a0dcfb468a6b49e6e81c5fab882/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=a45f333130536a0dcfb468a6b49e6e81c5fab882", "patch": "@@ -528,7 +528,7 @@ extern int target_flags;\n \tg0..g3 are used for return values,\n \tg0..g7 may always be used for parameters,\n \tg8..g11 may be used for parameters, but are preserved if they aren't,\n-\tg12 is always preserved, but otherwise unused,\n+\tg12 is the static chain if needed, otherwise is preserved\n \tg13 is the struct return ptr if used, or temp, but may be trashed,\n \tg14 is the leaf return ptr or the arg block ptr otherwise zero,\n \t\tmust be reset to zero before returning if it was used,\n@@ -606,7 +606,12 @@ extern int hard_regno_mode_ok ();\n /* ??? It isn't clear to me why this is here.  Perhaps because of a bug (since\n    fixed) in the definition of INITIAL_FRAME_POINTER_OFFSET which would have\n    caused this to fail.  */\n-#define FRAME_POINTER_REQUIRED (! leaf_function_p ())\n+/* ??? Must check current_function_has_nonlocal_goto, otherwise frame pointer\n+   elimination messes up nonlocal goto sequences.  I think this works for other\n+   targets because they use indirect jumps for the return which disables fp\n+   elimination.  */\n+#define FRAME_POINTER_REQUIRED \\\n+  (! leaf_function_p () || current_function_has_nonlocal_goto)\n \n /* C statement to store the difference between the frame pointer\n    and the stack pointer values immediately after the function prologue.\n@@ -622,8 +627,9 @@ extern int hard_regno_mode_ok ();\n #define ARG_POINTER_REGNUM 14\n \n /* Register in which static-chain is passed to a function.\n-   On i960, we use r3.  */\n-#define STATIC_CHAIN_REGNUM 19\n+   On i960, we use g12.  We can't use any local register, because we need\n+   a register that can be set before a call or before a jump.  */\n+#define STATIC_CHAIN_REGNUM 12\n  \n /* Functions which return large structures get the address\n    to place the wanted value at in g13.  */\n@@ -1543,14 +1549,14 @@ extern struct rtx_def *gen_compare_reg ();\n \n /* On the i960, the trampoline contains three instructions:\n      ldconst _function, r4\n-     ldconst static addr, r3\n+     ldconst static addr, g12\n      jump (r4)  */\n \n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   ASM_OUTPUT_INT (FILE, GEN_INT (0x8C203000));\t\\\n   ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x8C183000));\t\\\n+  ASM_OUTPUT_INT (FILE, GEN_INT (0x8CE03000));\t\\\n   ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n   ASM_OUTPUT_INT (FILE, GEN_INT (0x84212000));\t\\\n }"}, {"sha": "0574c57680b61a65e002eb716c7d8d896ea7d2b2", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45f333130536a0dcfb468a6b49e6e81c5fab882/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45f333130536a0dcfb468a6b49e6e81c5fab882/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=a45f333130536a0dcfb468a6b49e6e81c5fab882", "patch": "@@ -2308,57 +2308,45 @@\n   \"\"\n   \"\n {\n-  rtx fp = operands[1];\n-  rtx new_pc = operands[3];\n+  rtx chain = operands[0];\n+  rtx handler = operands[1];\n   rtx stack = operands[2];\n-  rtx val = operands[0];\n-\n-  /* This code isn't sufficient to make nonlocal_gotos for nested\n-     functions to work fully.  Here we assume that the passed frame\n-     pointer is a real hard frame pointer, not a\n-     virtual_stack_vars_rtx type of frame.  */\n+  rtx label = operands[3];\n \n   /* We must restore the stack pointer, frame pointer, previous frame\n      pointer and the return instruction pointer.  Since the ret\n      instruction does all this for us with one instruction, we arrange\n      everything so that ret will do everything we need done.  */\n \n-  if (GET_CODE (fp) != REG)\n-    fp = force_reg (Pmode, fp);\n-  if (GET_CODE (val) != REG)\n-    val = force_reg (Pmode, val);\n-  if (GET_CODE (new_pc) != REG)\n-    new_pc = force_reg (Pmode, new_pc);\n-\n-\n   /* First, we must flush the register windows, so that we can modify\n      the saved local registers on the stack directly and because we\n      are going to change the previous frame pointer.  */\n \n   emit_insn (gen_flush_register_windows ());\n \n+  /* Load the static chain value for the containing fn into fp.  This is needed\n+     because STACK refers to fp.  */\n+  emit_move_insn (hard_frame_pointer_rtx, chain);\n+\n+  /* Now move the adjusted value into the pfp register for the following return\n+     instruction.  */\n+  emit_move_insn (gen_rtx (REG, SImode, 16),\n+\t\t  plus_constant (hard_frame_pointer_rtx, -64));\n+\n   /* Next, we put the address that we want to transfer to, into the\n-     saved $rip value on the stack.  Once we ret below, that value\n+     saved $rip value in the frame.  Once we ret below, that value\n      will be loaded into the pc (IP).  */\n \n   emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   plus_constant (fp, 8)),\n-\t\t  new_pc);\n-\n-#if 0\n-  /* Next, we put the value into the static chain register's save\n-     area on the stack.  After the ret below, this will be loaded into\n-     r3 (the static chain).  */\n-     \n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   plus_constant (fp, 12)),\n-\t\t  val);\n-#endif\n+\t\t\t   plus_constant (hard_frame_pointer_rtx, -56)),\n+\t\t  replace_rtx (copy_rtx (handler), virtual_stack_vars_rtx,\n+\t\t\t       hard_frame_pointer_rtx));\n \n-  /* We now load pfp (the previous frame pointer) with the value that\n-     we want fp to be.  */\n-\n-  emit_move_insn (gen_rtx (REG, SImode, 16), fp);\n+  /* Next, we put stack into the saved $sp value in the frame.  */\n+  emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t   plus_constant (hard_frame_pointer_rtx, -60)),\n+\t\t  replace_rtx (copy_rtx (stack), virtual_stack_vars_rtx,\n+\t\t\t       hard_frame_pointer_rtx));\n \n   /* And finally, we can now just ret to get all the values saved\n      above into all the right registers, and also, all the local"}]}