{"sha": "17e39e5c61a230520688ee9b5173e89aa3b772aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdlMzllNWM2MWEyMzA1MjA2ODhlZTliNTE3M2U4OWFhM2I3NzJhYQ==", "commit": {"author": {"name": "Raif S. Naffah", "email": "raif@fl.net.au", "date": "2003-02-10T23:45:31Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-02-10T23:45:31Z"}, "message": "BigInteger.java: Updated notice to include years 2002 and 3.\n\n2003-02-10  Raif S. Naffah <raif@fl.net.au>\n\n\t* java/math/BigInteger.java:\n\tUpdated notice to include years 2002 and 3.\n\tAdded 2 private (int) arrays with values from the HAC (Handbook of\n\tApplied Cryptography -A. Menezes & al): k[] that contains bit lengths\n\tand t[] that contains nbr. of tests --used in isProbablePrime().\n\n\t* java/math/BigInteger.java (make(long)): Merged into valueOf(long).\n\n\t* java/math/BigInteger.java (make(int[],int), add(int,int),\n\tadd(BI,BI,int), times(BI,int), divide(long,long,BI,BI,int), gcd(BI),\n\tisProbablePrime(int), shift(BI,int), valueOf(String,int), neg(BI),\n\tbitOp(int,BI,BI), and(BI,int)): Use valueOf(long) instead of\n\tmake(long).\n\n\t* java/math/BigInteger.java (euclidInv): Reduce number of work vars\n\t(euclidInv(int,int,int)): Now returns an array of 2 ints instead of 3.\n\t(euclidInv(BI,BI,BI)): Used to return an array of 2 BIs; now accepts 6\n\tBIs and returns void.\n\t(modInverse(BI)): Use new signatures of euclidInv().\n\n\t* java/math/BigInteger.java (isProbablePrime(int)): Use divide() with\n\tstatic small primes instead of remainder().\n\tUse pre-computed max nbr of trials based on bitlength of BI to test.\n\tUse pre-computed small primes for the trial tests instead of random\n\tnumbers.\n\n\t* java/math/BigInteger.java (isOdd, isMinusOne, pow): Removed.\n\tnot used.\n\n\t* java/math/BigInteger.java (format(int,StringBuffer)): Removed\n\tinvoacation of MPN.chars_per_word().  not used.\n\n\t* java/math/BigInteger.java (gcd(int,int)): Declared 'tmp' once as\n\tlocal var and used where needed.\n\n\t* java/math/BigInteger.java (modPow(BI,BI)): Fixed spelling.\n\tCombined declaration with initialisation of locals.\n\tRemoved unused var.\n\n\t* java/math/BigInteger.java: Style changes\n\t(pow(int)): Removed 'else' keyword.\n\t(toString(int)): idem.\n\t(doubleValue()): idem.\n\t(bitLength()): idem.\n\t(equals(Object)): Use static methods name in same class w/o prepending\n\tclass name.\n\t(doubleValue()): idem.\n\t(setNegative(BI)): idem.\n\t(negate()): idem.\n\t(and(BI,int)): idem.\n\t(and(BI)): idem.\n\t(gcd(BI)): idem.\n\t(byteArrayToIntArray()): Removed casting to (int). this is\n\tstd. behaviour.\n\t(canonicalize()): idem.\n\t(alloc(int)): Always instantiate a new BI.\n\nFrom-SVN: r62656", "tree": {"sha": "1f6987870b317b9344b096c1d4cb984c83dcb69a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f6987870b317b9344b096c1d4cb984c83dcb69a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17e39e5c61a230520688ee9b5173e89aa3b772aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e39e5c61a230520688ee9b5173e89aa3b772aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e39e5c61a230520688ee9b5173e89aa3b772aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e39e5c61a230520688ee9b5173e89aa3b772aa/comments", "author": null, "committer": null, "parents": [{"sha": "2a4e6df4ce3e3b4048dce3041686331e885915fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a4e6df4ce3e3b4048dce3041686331e885915fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a4e6df4ce3e3b4048dce3041686331e885915fd"}], "stats": {"total": 370, "additions": 189, "deletions": 181}, "files": [{"sha": "0f9454d7781828e5a12b8a105cbe39ef94cdb8a2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e39e5c61a230520688ee9b5173e89aa3b772aa/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e39e5c61a230520688ee9b5173e89aa3b772aa/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=17e39e5c61a230520688ee9b5173e89aa3b772aa", "patch": "@@ -1,3 +1,62 @@\n+2003-02-10  Raif S. Naffah <raif@fl.net.au>\n+\n+\t* java/math/BigInteger.java:\n+\tUpdated notice to include years 2002 and 3.\n+\tAdded 2 private (int) arrays with values from the HAC (Handbook of\n+\tApplied Cryptography -A. Menezes & al): k[] that contains bit lengths\n+\tand t[] that contains nbr. of tests --used in isProbablePrime().\n+\n+\t* java/math/BigInteger.java (make(long)): Merged into valueOf(long).\n+\n+\t* java/math/BigInteger.java (make(int[],int), add(int,int),\n+\tadd(BI,BI,int), times(BI,int), divide(long,long,BI,BI,int), gcd(BI),\n+\tisProbablePrime(int), shift(BI,int), valueOf(String,int), neg(BI),\n+\tbitOp(int,BI,BI), and(BI,int)): Use valueOf(long) instead of\n+\tmake(long).\n+\n+\t* java/math/BigInteger.java (euclidInv): Reduce number of work vars\n+\t(euclidInv(int,int,int)): Now returns an array of 2 ints instead of 3.\n+\t(euclidInv(BI,BI,BI)): Used to return an array of 2 BIs; now accepts 6\n+\tBIs and returns void.\n+\t(modInverse(BI)): Use new signatures of euclidInv().\n+\n+\t* java/math/BigInteger.java (isProbablePrime(int)): Use divide() with\n+\tstatic small primes instead of remainder().\n+\tUse pre-computed max nbr of trials based on bitlength of BI to test.\n+\tUse pre-computed small primes for the trial tests instead of random\n+\tnumbers.\n+\n+\t* java/math/BigInteger.java (isOdd, isMinusOne, pow): Removed.\n+\tnot used.\n+\n+\t* java/math/BigInteger.java (format(int,StringBuffer)): Removed\n+\tinvoacation of MPN.chars_per_word().  not used.\n+\n+\t* java/math/BigInteger.java (gcd(int,int)): Declared 'tmp' once as\n+\tlocal var and used where needed.\n+\n+\t* java/math/BigInteger.java (modPow(BI,BI)): Fixed spelling.\n+\tCombined declaration with initialisation of locals.\n+\tRemoved unused var.\n+\n+\t* java/math/BigInteger.java: Style changes\n+\t(pow(int)): Removed 'else' keyword.\n+\t(toString(int)): idem.\n+\t(doubleValue()): idem.\n+\t(bitLength()): idem.\n+\t(equals(Object)): Use static methods name in same class w/o prepending\n+\tclass name.\n+\t(doubleValue()): idem.\n+\t(setNegative(BI)): idem.\n+\t(negate()): idem.\n+\t(and(BI,int)): idem.\n+\t(and(BI)): idem.\n+\t(gcd(BI)): idem.\n+\t(byteArrayToIntArray()): Removed casting to (int). this is\n+\tstd. behaviour.\n+\t(canonicalize()): idem.\n+\t(alloc(int)): Always instantiate a new BI.\n+\n 2003-02-10  Tom Tromey  <tromey@redhat.com>\n \n \t* java/sql/Timestamp.java (compareTo(Object)): New method."}, {"sha": "f72429046711d2d368f16b69c082a50a03b3a7e8", "filename": "libjava/java/math/BigInteger.java", "status": "modified", "additions": 130, "deletions": 181, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e39e5c61a230520688ee9b5173e89aa3b772aa/libjava%2Fjava%2Fmath%2FBigInteger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e39e5c61a230520688ee9b5173e89aa3b772aa/libjava%2Fjava%2Fmath%2FBigInteger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fmath%2FBigInteger.java?ref=17e39e5c61a230520688ee9b5173e89aa3b772aa", "patch": "@@ -1,5 +1,5 @@\n /* java.math.BigInteger -- Arbitary precision integers\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -110,6 +110,12 @@ public class BigInteger extends Number implements Comparable\n       109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181,\n       191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251 };\n \n+  /** HAC (Handbook of Applied Cryptography), Alfred Menezes & al. Table 4.4. */\n+  private static final int[] k =\n+      {100,150,200,250,300,350,400,500,600,800,1250, Integer.MAX_VALUE};\n+  private static final int[] t =\n+      { 27, 18, 15, 12,  9,  8,  7,  6,  5,  4,   3, 2};\n+\n   private BigInteger()\n   {\n   }\n@@ -218,38 +224,29 @@ public BigInteger(int bitLength, int certainty, Random rnd)\n   }\n \n   /** Return a (possibly-shared) BigInteger with a given long value. */\n-  private static BigInteger make(long value)\n+  public static BigInteger valueOf(long val)\n   {\n-    if (value >= minFixNum && value <= maxFixNum)\n-      return smallFixNums[(int)value - minFixNum];\n-    int i = (int) value;\n-    if ((long)i == value)\n+    if (val >= minFixNum && val <= maxFixNum)\n+      return smallFixNums[(int) val - minFixNum];\n+    int i = (int) val;\n+    if ((long) i == val)\n       return new BigInteger(i);\n     BigInteger result = alloc(2);\n     result.ival = 2;\n     result.words[0] = i;\n-    result.words[1] = (int) (value >> 32);\n+    result.words[1] = (int)(val >> 32);\n     return result;\n   }\n \n-  // FIXME: Could simply rename 'make' method above as valueOf while\n-  // changing all instances of 'make'.  Don't do this until this class\n-  // is done as the Kawa class this is based on has 'make' methods\n-  // with other parameters; wait to see if they are used in BigInteger.\n-  public static BigInteger valueOf(long val)\n-  {\n-    return make(val);\n-  }\n-\n   /** Make a canonicalized BigInteger from an array of words.\n    * The array may be reused (without copying). */\n   private static BigInteger make(int[] words, int len)\n   {\n     if (words == null)\n-      return make(len);\n+      return valueOf(len);\n     len = BigInteger.wordsNeeded(words, len);\n     if (len <= 1)\n-      return len == 0 ? ZERO : make(words[0]);\n+      return len == 0 ? ZERO : valueOf(words[0]);\n     BigInteger num = new BigInteger();\n     num.words = words;\n     num.ival = len;\n@@ -267,15 +264,15 @@ private static int[] byteArrayToIntArray(byte[] bytes, int sign)\n     int bptr = 0;\n     int word = sign;\n     for (int i = bytes.length % 4; i > 0; --i, bptr++)\n-      word = (word << 8) | (((int) bytes[bptr]) & 0xff);\n+      word = (word << 8) | (bytes[bptr] & 0xff);\n     words[--nwords] = word;\n \n     // Elements remaining in byte[] are a multiple of 4.\n     while (nwords > 0)\n       words[--nwords] = bytes[bptr++] << 24 |\n-\t\t\t(((int) bytes[bptr++]) & 0xff) << 16 |\n-\t\t\t(((int) bytes[bptr++]) & 0xff) << 8 |\n-\t\t\t(((int) bytes[bptr++]) & 0xff);\n+\t\t\t(bytes[bptr++] & 0xff) << 16 |\n+\t\t\t(bytes[bptr++] & 0xff) << 8 |\n+\t\t\t(bytes[bptr++] & 0xff);\n     return words;\n   }\n \n@@ -284,9 +281,8 @@ private static int[] byteArrayToIntArray(byte[] bytes, int sign)\n    */\n   private static BigInteger alloc(int nwords)\n   {\n-    if (nwords <= 1)\n-      return new BigInteger();\n     BigInteger result = new BigInteger();\n+    if (nwords > 1)\n     result.words = new int[nwords];\n     return result;\n   }\n@@ -376,12 +372,6 @@ public BigInteger max(BigInteger val)\n     return compareTo(this, val) > 0 ? this : val;\n   }\n \n-  private final boolean isOdd()\n-  {\n-    int low = words == null ? ival : words[0];\n-    return (low & 1) != 0;\n-  }\n-\n   private final boolean isZero()\n   {\n     return words == null && ival == 0;\n@@ -392,11 +382,6 @@ private final boolean isOne()\n     return words == null && ival == 1;\n   }\n \n-  private final boolean isMinusOne()\n-  {\n-    return words == null && ival == -1;\n-  }\n-\n   /** Calculate how many words are significant in words[0:len-1].\n    * Returns the least value x such that x>0 && words[0:x-1]==words[0:len-1],\n    * when words is viewed as a 2's complement integer.\n@@ -433,14 +418,14 @@ private BigInteger canonicalize()\n \twords = null;\n       }\n     if (words == null && ival >= minFixNum && ival <= maxFixNum)\n-      return smallFixNums[(int) ival - minFixNum];\n+      return smallFixNums[ival - minFixNum];\n     return this;\n   }\n \n   /** Add two ints, yielding a BigInteger. */\n   private static final BigInteger add(int x, int y)\n   {\n-    return BigInteger.make((long) x + (long) y);\n+    return valueOf((long) x + (long) y);\n   }\n \n   /** Add a BigInteger and an int, yielding a new BigInteger. */\n@@ -526,13 +511,13 @@ else if (this != y)\n   private static BigInteger add(BigInteger x, BigInteger y, int k)\n   {\n     if (x.words == null && y.words == null)\n-      return BigInteger.make((long) k * (long) y.ival + (long) x.ival);\n+      return valueOf((long) k * (long) y.ival + (long) x.ival);\n     if (k != 1)\n       {\n \tif (k == -1)\n \t  y = BigInteger.neg(y);\n \telse\n-\t  y = BigInteger.times(y, BigInteger.make(k));\n+\t  y = BigInteger.times(y, valueOf(k));\n       }\n     if (x.words == null)\n       return BigInteger.add(y, x.ival);\n@@ -580,7 +565,7 @@ private static final BigInteger times(BigInteger x, int y)\n     int[] xwords = x.words;\n     int xlen = x.ival;\n     if (xwords == null)\n-      return BigInteger.make((long) xlen * (long) y);\n+      return valueOf((long) xlen * (long) y);\n     boolean negative;\n     BigInteger result = BigInteger.alloc(xlen + 1);\n     if (xwords[xlen - 1] < 0)\n@@ -662,7 +647,7 @@ private static void divide(long x, long y,\n \txNegative = true;\n \tif (x == Long.MIN_VALUE)\n \t  {\n-\t    divide(BigInteger.make(x), BigInteger.make(y),\n+\t    divide(valueOf(x), valueOf(y),\n \t\t   quotient, remainder, rounding_mode);\n \t    return;\n \t  }\n@@ -684,7 +669,7 @@ private static void divide(long x, long y,\n \t\t  remainder.set(x);\n \t      }\n \t    else\n-\t      divide(BigInteger.make(x), BigInteger.make(y),\n+\t      divide(valueOf(x), valueOf(y),\n \t\t      quotient, remainder, rounding_mode);\n \t    return;\n \t  }\n@@ -966,39 +951,6 @@ public BigInteger mod(BigInteger m)\n     return rem.canonicalize();\n   }\n \n-  /** Calculate power for BigInteger exponents.\n-   * @param y exponent assumed to be non-negative. */\n-  private BigInteger pow(BigInteger y)\n-  {\n-    if (isOne())\n-      return this;\n-    if (isMinusOne())\n-      return y.isOdd () ? this : ONE;\n-    if (y.words == null && y.ival >= 0)\n-      return pow(y.ival);\n-\n-    // Assume exponent is non-negative.\n-    if (isZero())\n-      return this;\n-\n-    // Implemented by repeated squaring and multiplication.\n-    BigInteger pow2 = this;\n-    BigInteger r = null;\n-    for (;;)  // for (i = 0;  ; i++)\n-      {\n-        // pow2 == x**(2**i)\n-        // prod = x**(sum(j=0..i-1, (y>>j)&1))\n-        if (y.isOdd())\n-          r = r == null ? pow2 : times(r, pow2);  // r *= pow2\n-        y = BigInteger.shift(y, -1);\n-        if (y.isZero())\n-          break;\n-        // pow2 *= pow2;\n-        pow2 = times(pow2, pow2);\n-      }\n-    return r == null ? ONE : r;\n-  }\n-\n   /** Calculate the integral power of a BigInteger.\n    * @param exponent the exponent (must be non-negative)\n    */\n@@ -1008,7 +960,6 @@ public BigInteger pow(int exponent)\n       {\n \tif (exponent == 0)\n \t  return ONE;\n-\telse\n \t  throw new ArithmeticException(\"negative exponent\");\n       }\n     if (isZero())\n@@ -1051,51 +1002,36 @@ public BigInteger pow(int exponent)\n \n   private static final int[] euclidInv(int a, int b, int prevDiv)\n   {\n-    // Storage for return values, plus one slot for a temp int (see below).\n-    int[] xy;\n-\n     if (b == 0)\n       throw new ArithmeticException(\"not invertible\");\n-    else if (b == 1)\n-      {\n+\n+    if (b == 1)\n \t// Success:  values are indeed invertible!\n \t// Bottom of the recursion reached; start unwinding.\n-        xy = new int[3];\n-\txy[0] = -prevDiv;\n-\txy[1] = 1;\n-\treturn xy;\n-      }\n-\n-    xy = euclidInv(b, a % b, a / b);\t// Recursion happens here.\n+\treturn new int[] { -prevDiv, 1 };\n \n-    // xy[2] is just temp storage for intermediate results in the following\n-    // calculation.  This saves us a bit of space over having an int\n-    // allocated at every level of this recursive method.\n-    xy[2] = xy[0];\n-    xy[0] = xy[2] * -prevDiv + xy[1];\n-    xy[1] = xy[2];\n+    int[] xy = euclidInv(b, a % b, a / b);\t// Recursion happens here.\n+    a = xy[0]; // use our local copy of 'a' as a work var\n+    xy[0] = a * -prevDiv + xy[1];\n+    xy[1] = a;\n     return xy;\n   }\n \n-  private static final BigInteger[]\n-    euclidInv(BigInteger a, BigInteger b, BigInteger prevDiv)\n+  private static final void euclidInv(BigInteger a, BigInteger b,\n+                                      BigInteger prevDiv, BigInteger xy0,\n+                                      BigInteger xy1, BigInteger xy2)\n   {\n-    // FIXME: This method could be more efficient memory-wise and should be\n-    // modified as such since it is recursive.\n-\n-    // Storage for return values, plus one slot for a temp int (see below).\n-    BigInteger[] xy;\n-\n     if (b.isZero())\n       throw new ArithmeticException(\"not invertible\");\n-    else if (b.isOne())\n+\n+    if (b.isOne())\n       {\n \t// Success:  values are indeed invertible!\n \t// Bottom of the recursion reached; start unwinding.\n-        xy = new BigInteger[3];\n-\txy[0] = neg(prevDiv);\n-\txy[1] = ONE;\n-\treturn xy;\n+        // WARNING: xy1 is, and xy0 may be, a shared BI!\n+\txy0 = neg(prevDiv);\n+\txy1 = ONE;\n+\treturn;\n       }\n \n     // Recursion happens in the following conditional!\n@@ -1104,9 +1040,8 @@ else if (b.isOne())\n     if (a.words == null)\n       {\n         int[] xyInt = euclidInv(b.ival, a.ival % b.ival, a.ival / b.ival);\n-        xy = new BigInteger[3];\n-\txy[0] = new BigInteger(xyInt[0]);\n-\txy[1] = new BigInteger(xyInt[1]);\n+\txy0 = new BigInteger(xyInt[0]); // non-shared BI\n+\txy1 = new BigInteger(xyInt[1]); // non-shared BI\n       }\n     else\n       {\n@@ -1116,16 +1051,15 @@ else if (b.isOne())\n         // quot and rem may not be in canonical form. ensure\n         rem.canonicalize();\n         quot.canonicalize();\n-        xy = euclidInv(b, rem, quot);\n+        euclidInv(b, rem, quot, xy0, xy1, xy2);\n       }\n \n-    // xy[2] is just temp storage for intermediate results in the following\n+    // xy2 is just temp storage for intermediate results in the following\n     // calculation.  This saves us a bit of space over having a BigInteger\n     // allocated at every level of this recursive method.\n-    xy[2] = xy[0];\n-    xy[0] = add(xy[1], times(xy[2], prevDiv), -1);\n-    xy[1] = xy[2];\n-    return xy;\n+    xy2 = xy0;\n+    xy0 = add(xy1, times(xy2, prevDiv), -1);\n+    xy1 = xy2;\n   }\n \n   public BigInteger modInverse(BigInteger y)\n@@ -1136,16 +1070,14 @@ public BigInteger modInverse(BigInteger y)\n     // Degenerate cases.\n     if (y.isOne())\n       return ZERO;\n-    else if (isOne())\n+    if (isOne())\n       return ONE;\n \n     // Use Euclid's algorithm as in gcd() but do this recursively\n     // rather than in a loop so we can use the intermediate results as we\n     // unwind from the recursion.\n     // Used http://www.math.nmsu.edu/~crypto/EuclideanAlgo.html as reference.\n     BigInteger result = new BigInteger();\n-    int xval = ival;\n-    int yval = y.ival;\n     boolean swapped = false;\n \n     if (y.words == null)\n@@ -1156,8 +1088,8 @@ else if (isOne())\n \t// math.  Note that BigInteger.mod() must be used even if this is\n \t// already an int as the % operator would provide a negative result if\n \t// this is negative, BigInteger.mod() never returns negative values.\n-\tif (words != null || isNegative())\n-\t  xval = mod(y).ival;\n+        int xval = (words != null || isNegative()) ? mod(y).ival : ival;\n+        int yval = y.ival;\n \n \t// Swap values so x > y.\n \tif (yval > xval)\n@@ -1178,16 +1110,13 @@ else if (isOne())\n       }\n     else\n       {\n-\tBigInteger x = this;\n-\n \t// As above, force this to be a positive value via modulo math.\n-\tif (isNegative())\n-\t  x = mod(y);\n+\tBigInteger x = isNegative() ? this.mod(y) : this;\n \n \t// Swap values so x > y.\n \tif (x.compareTo(y) < 0)\n \t  {\n-\t    BigInteger tmp = x; x = y; y = tmp;\n+\t    result = x; x = y; y = result; // use 'result' as a work var\n \t    swapped = true;\n \t  }\n \t// As above (for ints), result will be in the 2nd element unless\n@@ -1198,7 +1127,10 @@ else if (isOne())\n         // quot and rem may not be in canonical form. ensure\n         rem.canonicalize();\n         quot.canonicalize();\n-\tresult = euclidInv(y, rem, quot)[swapped ? 0 : 1];\n+        BigInteger xy0 = new BigInteger();\n+        BigInteger xy1 = new BigInteger();\n+        euclidInv(y, rem, quot, xy0, xy1, result);\n+\tresult = swapped ? xy0 : xy1;\n \n \t// Result can't be negative, so make it positive by adding the\n \t// original modulus, y (which is now x if they were swapped).\n@@ -1222,16 +1154,13 @@ public BigInteger modPow(BigInteger exponent, BigInteger m)\n     // To do this naively by first raising this to the power of exponent\n     // and then performing modulo m would be extremely expensive, especially\n     // for very large numbers.  The solution is found in Number Theory\n-    // where a combination of partial powers and modulos can be done easily.\n+    // where a combination of partial powers and moduli can be done easily.\n     //\n     // We'll use the algorithm for Additive Chaining which can be found on\n     // p. 244 of \"Applied Cryptography, Second Edition\" by Bruce Schneier.\n-    BigInteger s, t, u;\n-    int i;\n-\n-    s = ONE;\n-    t = this;\n-    u = exponent;\n+    BigInteger s = ONE;\n+    BigInteger t = this;\n+    BigInteger u = exponent;\n \n     while (!u.isZero())\n       {\n@@ -1248,24 +1177,22 @@ public BigInteger modPow(BigInteger exponent, BigInteger m)\n   private static final int gcd(int a, int b)\n   {\n     // Euclid's algorithm, copied from libg++.\n+    int tmp;\n     if (b > a)\n       {\n-\tint tmp = a; a = b; b = tmp;\n+\ttmp = a; a = b; b = tmp;\n       }\n     for(;;)\n       {\n \tif (b == 0)\n \t  return a;\n-\telse if (b == 1)\n+        if (b == 1)\n \t  return b;\n-\telse\n-\t  {\n-\t    int tmp = b;\n+        tmp = b;\n \t    b = a % b;\n \t    a = tmp;\n \t  }\n       }\n-  }\n \n   public BigInteger gcd(BigInteger y)\n   {\n@@ -1274,22 +1201,22 @@ public BigInteger gcd(BigInteger y)\n     if (words == null)\n       {\n \tif (xval == 0)\n-\t  return BigInteger.abs(y);\n+\t  return abs(y);\n \tif (y.words == null\n \t    && xval != Integer.MIN_VALUE && yval != Integer.MIN_VALUE)\n \t  {\n \t    if (xval < 0)\n \t      xval = -xval;\n \t    if (yval < 0)\n \t      yval = -yval;\n-\t    return BigInteger.make(BigInteger.gcd(xval, yval));\n+\t    return valueOf(gcd(xval, yval));\n \t  }\n \txval = 1;\n       }\n     if (y.words == null)\n       {\n \tif (yval == 0)\n-\t  return BigInteger.abs(this);\n+\t  return abs(this);\n \tyval = 1;\n       }\n     int len = (xval > yval ? xval : yval) + 1;\n@@ -1304,8 +1231,24 @@ public BigInteger gcd(BigInteger y)\n     return result.canonicalize();\n   }\n \n+  /**\n+   * <p>Returns <code>true</code> if this BigInteger is probably prime,\n+   * <code>false</code> if it's definitely composite. If <code>certainty</code>\n+   * is <code><= 0</code>, <code>true</code> is returned.</p>\n+   *\n+   * @param certainty a measure of the uncertainty that the caller is willing\n+   * to tolerate: if the call returns <code>true</code> the probability that\n+   * this BigInteger is prime exceeds <code>(1 - 1/2<sup>certainty</sup>)</code>.\n+   * The execution time of this method is proportional to the value of this\n+   * parameter.\n+   * @return <code>true</code> if this BigInteger is probably prime,\n+   * <code>false</code> if it's definitely composite.\n+   */\n   public boolean isProbablePrime(int certainty)\n   {\n+    if (certainty < 1)\n+      return true;\n+\n     /** We'll use the Rabin-Miller algorithm for doing a probabilistic\n      * primality test.  It is fast, easy and has faster decreasing odds of a\n      * composite passing than with other tests.  This means that this\n@@ -1317,42 +1260,52 @@ public boolean isProbablePrime(int certainty)\n      * Cryptography, Second Edition\" by Bruce Schneier.\n      */\n \n-    // First rule out small prime factors and assure the number is odd.\n-    for (int i = 0; i < primes.length; i++)\n+    // First rule out small prime factors\n+    BigInteger rem = new BigInteger();\n+    int i;\n+    for (i = 0; i < primes.length; i++)\n       {\n \tif (words == null && ival == primes[i])\n \t  return true;\n-        if (remainder(make(primes[i])).isZero())\n+\n+        divide(this, smallFixNums[primes[i] - minFixNum], null, rem, TRUNCATE);\n+        if (rem.canonicalize().isZero())\n \t  return false;\n       }\n \n     // Now perform the Rabin-Miller test.\n-    // NB: I know that this can be simplified programatically, but\n-    // I have tried to keep it as close as possible to the algorithm\n-    // as written in the Schneier book for reference purposes.\n \n     // Set b to the number of times 2 evenly divides (this - 1).\n     // I.e. 2^b is the largest power of 2 that divides (this - 1).\n     BigInteger pMinus1 = add(this, -1);\n     int b = pMinus1.getLowestSetBit();\n \n     // Set m such that this = 1 + 2^b * m.\n-    BigInteger m = pMinus1.divide(make(2L << b - 1));\n-\n-    Random rand = new Random();\n-    while (certainty-- > 0)\n-      {\n-        // Pick a random number greater than 1 and less than this.\n-\t// The algorithm says to pick a small number to make the calculations\n-\t// go faster, but it doesn't say how small; we'll use 2 to 1024.\n-\tint a = rand.nextInt();\n-\ta = (a < 0 ? -a : a) % 1023 + 2;\n-\n-\tBigInteger z = make(a).modPow(m, this);\n+    BigInteger m = pMinus1.divide(valueOf(2L << b - 1));\n+\n+    // The HAC (Handbook of Applied Cryptography), Alfred Menezes & al. Note\n+    // 4.49 (controlling the error probability) gives the number of trials\n+    // for an error probability of 1/2**80, given the number of bits in the\n+    // number to test.  we shall use these numbers as is if/when 'certainty'\n+    // is less or equal to 80, and twice as much if it's greater.\n+    int bits = this.bitLength();\n+    for (i = 0; i < k.length; i++)\n+      if (bits <= k[i])\n+        break;\n+    int trials = t[i];\n+    if (certainty > 80)\n+      trials *= 2;\n+    BigInteger z;\n+    for (int t = 0; t < trials; t++)\n+      {\n+        // The HAC (Handbook of Applied Cryptography), Alfred Menezes & al.\n+        // Remark 4.28 states: \"...A strategy that is sometimes employed\n+        // is to fix the bases a to be the first few primes instead of\n+        // choosing them at random.\n+\tz = smallFixNums[primes[t] - minFixNum].modPow(m, this);\n \tif (z.isOne() || z.equals(pMinus1))\n \t  continue;\t\t\t// Passes the test; may be prime.\n \n-\tint i;\n \tfor (i = 0; i < b; )\n \t  {\n \t    if (z.isOne())\n@@ -1361,7 +1314,7 @@ public boolean isProbablePrime(int certainty)\n \t    if (z.equals(pMinus1))\n \t      break;\t\t\t// Passes the test; may be prime.\n \n-\t    z = z.modPow(make(2), this);\n+\t    z = z.modPow(valueOf(2), this);\n \t  }\n \n \tif (i == b && !z.equals(pMinus1))\n@@ -1462,9 +1415,9 @@ private static BigInteger shift(BigInteger x, int count)\n     if (x.words == null)\n       {\n \tif (count <= 0)\n-\t  return make(count > -32 ? x.ival >> (-count) : x.ival < 0 ? -1 : 0);\n+\t  return valueOf(count > -32 ? x.ival >> (-count) : x.ival < 0 ? -1 : 0);\n \tif (count < 32)\n-\t  return make((long) x.ival << count);\n+\t  return valueOf((long) x.ival << count);\n       }\n     if (count == 0)\n       return x;\n@@ -1502,7 +1455,6 @@ else if (ival <= 2)\n \t  work = words;\n \tint len = ival;\n \n-\tint buf_size = len * (MPN.chars_per_word(radix) + 1);\n \tif (radix == 16)\n \t  {\n \t    if (neg)\n@@ -1555,7 +1507,7 @@ public String toString(int radix)\n   {\n     if (words == null)\n       return Integer.toString(ival, radix);\n-    else if (ival <= 2)\n+    if (ival <= 2)\n       return Long.toString(longValue(), radix);\n     int buf_size = ival * (MPN.chars_per_word(radix) + 1);\n     StringBuffer buffer = new StringBuffer(buf_size);\n@@ -1605,7 +1557,7 @@ public boolean equals(Object obj)\n   {\n     if (obj == null || ! (obj instanceof BigInteger))\n       return false;\n-    return BigInteger.equals(this, (BigInteger) obj);\n+    return equals(this, (BigInteger) obj);\n   }\n \n   private static BigInteger valueOf(String s, int radix)\n@@ -1615,7 +1567,7 @@ private static BigInteger valueOf(String s, int radix)\n     // Testing (len < MPN.chars_per_word(radix)) would be more accurate,\n     // but slightly more expensive, for little practical gain.\n     if (len <= 15 && radix <= 16)\n-      return BigInteger.make(Long.parseLong(s, radix));\n+      return valueOf(Long.parseLong(s, radix));\n     \n     int byte_len = 0;\n     byte[] bytes = new byte[len];\n@@ -1660,8 +1612,7 @@ public double doubleValue()\n     if (ival <= 2)\n       return (double) longValue();\n     if (isNegative())\n-      return BigInteger.neg(this).roundToDouble(0, true, false);\n-    else\n+      return neg(this).roundToDouble(0, true, false);\n       return roundToDouble(0, false, false);\n   }\n \n@@ -1769,7 +1720,6 @@ else if (ml == 52 && (m & (1L << 53)) != 0)\n    * Assumes words.length >= (this.words == null ? 1 : this.ival).\n    * Result is zero-extended, but need not be a valid 2's complement number.\n    */\n-    \n   private void getAbsolute(int[] words)\n   {\n     int len;\n@@ -1820,7 +1770,7 @@ private void setNegative(BigInteger x)\n \treturn;\n       }\n     realloc(len + 1);\n-    if (BigInteger.negate(words, x.words, len))\n+    if (negate(words, x.words, len))\n       words[len++] = 0;\n     ival = len;\n   }\n@@ -1844,15 +1794,15 @@ public BigInteger abs()\n   private static BigInteger neg(BigInteger x)\n   {\n     if (x.words == null && x.ival != Integer.MIN_VALUE)\n-      return make(- x.ival);\n+      return valueOf(- x.ival);\n     BigInteger result = new BigInteger(0);\n     result.setNegative(x);\n     return result.canonicalize();\n   }\n \n   public BigInteger negate()\n   {\n-    return BigInteger.neg(this);\n+    return neg(this);\n   }\n \n   /** Calculates ceiling(log2(this < 0 ? -this : this+1))\n@@ -1862,7 +1812,6 @@ public int bitLength()\n   {\n     if (words == null)\n       return MPN.intLength(ival);\n-    else\n       return MPN.intLength(words, ival);\n   }\n \n@@ -1913,7 +1862,7 @@ private static BigInteger bitOp(int op, BigInteger x, BigInteger y)\n         case 1:  return x.and(y);\n         case 3:  return x;\n         case 5:  return y;\n-        case 15: return make(-1);\n+        case 15: return valueOf(-1);\n       }\n     BigInteger result = new BigInteger();\n     setBitOp(result, op, x, y);\n@@ -2111,15 +2060,15 @@ else if (x.words == null || x.ival < y.ival)\n   private static BigInteger and(BigInteger x, int y)\n   {\n     if (x.words == null)\n-      return BigInteger.make(x.ival & y);\n+      return valueOf(x.ival & y);\n     if (y >= 0)\n-      return BigInteger.make(x.words[0] & y);\n+      return valueOf(x.words[0] & y);\n     int len = x.ival;\n     int[] words = new int[len];\n     words[0] = x.words[0] & y;\n     while (--len > 0)\n       words[len] = x.words[len];\n-    return BigInteger.make(words, x.ival);\n+    return make(words, x.ival);\n   }\n \n   /** Return the logical (bit-wise) \"and\" of two BigIntegers. */\n@@ -2142,7 +2091,7 @@ else if (words == null)\n       words[i] = x.words[i] & y.words[i];\n     for ( ; i < len;  i++)\n       words[i] = x.words[i];\n-    return BigInteger.make(words, len);\n+    return make(words, len);\n   }\n \n   /** Return the logical (bit-wise) \"(inclusive) or\" of two BigIntegers. */"}]}