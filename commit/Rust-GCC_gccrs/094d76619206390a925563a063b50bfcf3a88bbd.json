{"sha": "094d76619206390a925563a063b50bfcf3a88bbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk0ZDc2NjE5MjA2MzkwYTkyNTU2M2EwNjNiNTBiZmNmM2E4OGJiZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-04-13T11:42:08Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-04-13T11:42:08Z"}, "message": "dwarf2out.c (struct dw_cfi_struct): Remove member dw_cfi_next.\n\n\t* dwarf2out.c (struct dw_cfi_struct): Remove member dw_cfi_next.\n\t(dw_cfi_ref): Add DEF_VEC_P and some DEF_VEC_ALLOC_Ps.\n\t(cfi_vec): New typedef.\n\t(struct dw_fde_struct): Make dw_fde_cfi a cfi_vec. Replace\n\tdw_fde_switch_cfi with an integer dw_fde_switch_cfi_index.\n\t(cie_cfi_vec): New static variable.\n\t(cie_cfi_head): Delete.\n\t(add_cfi): Accept a cfi_vec * as first argument. All callers and\n\tdeclaration changed. Use vector rather than list operations.\n\t(new_cfi): Don't initialize the dw_cfi_next field.\n\t(add_fde_cfi): Allocate cie_cfi_vec if necessary. Use vector\n\trather than list operations.\n\t(lookup_cfa): Use vector rather than list operations.\n\t(output_cfis): New argument upto. Accept a cfi_vec rather than\n\ta dw_cfi_ref list head as argument. All callers changed.\n\tIterate over the vector using upto as a maximum index.\n\t(output_all_cfis): New static function.\n\t(output_fde): Use vector rather than list operations. Use the\n\tnew upto argument for output_cfis rather than manipulating a\n\tlist.\n\t(dwarf2out_begin_prologue): Change initializations to match\n\tnew struct members.\n\t(dwarf2out_switch_text_section): Initialize dw_fde_switch_cfi_index\n\tfrom the vector length rather than searching for the end of a list.\n\tUse output_all_cfis.\n\t(convert_cfa_to_fb_loc_list): Use vector rather than list operations.\n\nFrom-SVN: r172369", "tree": {"sha": "b9ff9fea0084e18f7fbfcf185b8981d11f8d403e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9ff9fea0084e18f7fbfcf185b8981d11f8d403e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/094d76619206390a925563a063b50bfcf3a88bbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/094d76619206390a925563a063b50bfcf3a88bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/094d76619206390a925563a063b50bfcf3a88bbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/094d76619206390a925563a063b50bfcf3a88bbd/comments", "author": null, "committer": null, "parents": [{"sha": "673a5740323aa8a438767120e223d323c2fb6f71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673a5740323aa8a438767120e223d323c2fb6f71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/673a5740323aa8a438767120e223d323c2fb6f71"}], "stats": {"total": 431, "additions": 237, "deletions": 194}, "files": [{"sha": "4e3efc924c94a12d176b15ba00aef26a217ab3e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094d76619206390a925563a063b50bfcf3a88bbd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094d76619206390a925563a063b50bfcf3a88bbd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=094d76619206390a925563a063b50bfcf3a88bbd", "patch": "@@ -1,3 +1,32 @@\n+2011-04-13  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* dwarf2out.c (struct dw_cfi_struct): Remove member dw_cfi_next.\n+\t(dw_cfi_ref): Add DEF_VEC_P and some DEF_VEC_ALLOC_Ps.\n+\t(cfi_vec): New typedef.\n+\t(struct dw_fde_struct): Make dw_fde_cfi a cfi_vec. Replace\n+\tdw_fde_switch_cfi with an integer dw_fde_switch_cfi_index.\n+\t(cie_cfi_vec): New static variable.\n+\t(cie_cfi_head): Delete.\n+\t(add_cfi): Accept a cfi_vec * as first argument. All callers and\n+\tdeclaration changed. Use vector rather than list operations.\n+\t(new_cfi): Don't initialize the dw_cfi_next field.\n+\t(add_fde_cfi): Allocate cie_cfi_vec if necessary. Use vector\n+\trather than list operations.\n+\t(lookup_cfa): Use vector rather than list operations.\n+\t(output_cfis): New argument upto. Accept a cfi_vec rather than\n+\ta dw_cfi_ref list head as argument. All callers changed.\n+\tIterate over the vector using upto as a maximum index.\n+\t(output_all_cfis): New static function.\n+\t(output_fde): Use vector rather than list operations. Use the\n+\tnew upto argument for output_cfis rather than manipulating a\n+\tlist.\n+\t(dwarf2out_begin_prologue): Change initializations to match\n+\tnew struct members.\n+\t(dwarf2out_switch_text_section): Initialize dw_fde_switch_cfi_index\n+\tfrom the vector length rather than searching for the end of a list.\n+\tUse output_all_cfis.\n+\t(convert_cfa_to_fb_loc_list): Use vector rather than list operations.\n+\n 2011-04-13  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rx/rx.md (movmemsi): Do not use this pattern when"}, {"sha": "aaf00b183e5c1dd170ae59cd73830652cd4caf3d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 208, "deletions": 194, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094d76619206390a925563a063b50bfcf3a88bbd/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094d76619206390a925563a063b50bfcf3a88bbd/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=094d76619206390a925563a063b50bfcf3a88bbd", "patch": "@@ -267,7 +267,6 @@ typedef union GTY(()) dw_cfi_oprnd_struct {\n dw_cfi_oprnd;\n \n typedef struct GTY(()) dw_cfi_struct {\n-  dw_cfi_ref dw_cfi_next;\n   enum dwarf_call_frame_info dw_cfi_opc;\n   dw_cfi_oprnd GTY ((desc (\"dw_cfi_oprnd1_desc (%1.dw_cfi_opc)\")))\n     dw_cfi_oprnd1;\n@@ -276,6 +275,12 @@ typedef struct GTY(()) dw_cfi_struct {\n }\n dw_cfi_node;\n \n+DEF_VEC_P (dw_cfi_ref);\n+DEF_VEC_ALLOC_P (dw_cfi_ref, heap);\n+DEF_VEC_ALLOC_P (dw_cfi_ref, gc);\n+\n+typedef VEC(dw_cfi_ref, gc) *cfi_vec;\n+\n /* This is how we define the location of the CFA. We use to handle it\n    as REG + OFFSET all the time,  but now it can be more complex.\n    It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.\n@@ -304,8 +309,8 @@ typedef struct GTY(()) dw_fde_struct {\n   const char *dw_fde_vms_begin_epilogue;\n   const char *dw_fde_second_begin;\n   const char *dw_fde_second_end;\n-  dw_cfi_ref dw_fde_cfi;\n-  dw_cfi_ref dw_fde_switch_cfi; /* Last CFI before switching sections.  */\n+  cfi_vec dw_fde_cfi;\n+  int dw_fde_switch_cfi_index; /* Last CFI before switching sections.  */\n   HOST_WIDE_INT stack_realignment;\n   unsigned funcdef_number;\n   /* Dynamic realign argument pointer register.  */\n@@ -410,8 +415,8 @@ current_fde (void)\n   return fde_table_in_use ? &fde_table[fde_table_in_use - 1] : NULL;\n }\n \n-/* A list of call frame insns for the CIE.  */\n-static GTY(()) dw_cfi_ref cie_cfi_head;\n+/* A vector of call frame insns for the CIE.  */\n+static GTY(()) cfi_vec cie_cfi_vec;\n \n /* Some DWARF extensions (e.g., MIPS/SGI) implement a subprogram\n    attribute that accelerates the lookup of the FDE associated\n@@ -451,7 +456,7 @@ static GTY(()) section *cold_text_section;\n static char *stripattributes (const char *);\n static const char *dwarf_cfi_name (unsigned);\n static dw_cfi_ref new_cfi (void);\n-static void add_cfi (dw_cfi_ref *, dw_cfi_ref);\n+static void add_cfi (cfi_vec *, dw_cfi_ref);\n static void add_fde_cfi (const char *, dw_cfi_ref);\n static void lookup_cfa_1 (dw_cfi_ref, dw_cfa_location *, dw_cfa_location *);\n static void lookup_cfa (dw_cfa_location *);\n@@ -807,7 +812,6 @@ new_cfi (void)\n {\n   dw_cfi_ref cfi = ggc_alloc_dw_cfi_node ();\n \n-  cfi->dw_cfi_next = NULL;\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = 0;\n   cfi->dw_cfi_oprnd2.dw_cfi_reg_num = 0;\n \n@@ -817,9 +821,8 @@ new_cfi (void)\n /* Add a Call Frame Instruction to list of instructions.  */\n \n static inline void\n-add_cfi (dw_cfi_ref *list_head, dw_cfi_ref cfi)\n+add_cfi (cfi_vec *vec, dw_cfi_ref cfi)\n {\n-  dw_cfi_ref *p;\n   dw_fde_ref fde = current_fde ();\n \n   /* When DRAP is used, CFA is defined with an expression.  Redefine\n@@ -841,11 +844,7 @@ add_cfi (dw_cfi_ref *list_head, dw_cfi_ref cfi)\n           break;\n       }\n \n-  /* Find the end of the chain.  */\n-  for (p = list_head; (*p) != NULL; p = &(*p)->dw_cfi_next)\n-    ;\n-\n-  *p = cfi;\n+  VEC_safe_push (dw_cfi_ref, gc, *vec, cfi);\n }\n \n /* Generate a new label for the CFI info to refer to.  FORCE is true\n@@ -885,7 +884,12 @@ static bool any_cfis_emitted;\n static void\n add_fde_cfi (const char *label, dw_cfi_ref cfi)\n {\n-  dw_cfi_ref *list_head;\n+  cfi_vec *vec;\n+\n+  if (cie_cfi_vec == NULL)\n+    cie_cfi_vec = VEC_alloc (dw_cfi_ref, gc, 20);\n+\n+  vec = &cie_cfi_vec;\n \n   if (emit_cfa_remember)\n     {\n@@ -898,8 +902,6 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n       add_fde_cfi (label, cfi_remember);\n     }\n \n-  list_head = &cie_cfi_head;\n-\n   if (dwarf2out_do_cfi_asm ())\n     {\n       if (label)\n@@ -957,7 +959,7 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n \n \t  output_cfi_directive (cfi);\n \n-\t  list_head = &fde->dw_fde_cfi;\n+\t  vec = &fde->dw_fde_cfi;\n \t  any_cfis_emitted = true;\n \t}\n       /* ??? If this is a CFI for the CIE, we don't emit.  This\n@@ -995,11 +997,11 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n \t  fde->dw_fde_current_label = label;\n \t}\n \n-      list_head = &fde->dw_fde_cfi;\n+      vec = &fde->dw_fde_cfi;\n       any_cfis_emitted = true;\n     }\n \n-  add_cfi (list_head, cfi);\n+  add_cfi (vec, cfi);\n }\n \n /* Subroutine of lookup_cfa.  */\n@@ -1046,6 +1048,7 @@ lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n static void\n lookup_cfa (dw_cfa_location *loc)\n {\n+  int ix;\n   dw_cfi_ref cfi;\n   dw_fde_ref fde;\n   dw_cfa_location remember;\n@@ -1054,12 +1057,12 @@ lookup_cfa (dw_cfa_location *loc)\n   loc->reg = INVALID_REGNUM;\n   remember = *loc;\n \n-  for (cfi = cie_cfi_head; cfi; cfi = cfi->dw_cfi_next)\n+  FOR_EACH_VEC_ELT (dw_cfi_ref, cie_cfi_vec, ix, cfi)\n     lookup_cfa_1 (cfi, loc, &remember);\n \n   fde = current_fde ();\n   if (fde)\n-    for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n+    FOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n       lookup_cfa_1 (cfi, loc, &remember);\n }\n \n@@ -3430,176 +3433,191 @@ output_cfi_directive (dw_cfi_ref cfi)\n     }\n }\n \n-DEF_VEC_P (dw_cfi_ref);\n-DEF_VEC_ALLOC_P (dw_cfi_ref, heap);\n-\n-/* Output CFIs to bring current FDE to the same state as after executing\n-   CFIs in CFI chain.  DO_CFI_ASM is true if .cfi_* directives shall\n-   be emitted, false otherwise.  If it is false, FDE and FOR_EH are the\n-   other arguments to pass to output_cfi.  */\n+/* Output CFIs from VEC, up to index UPTO, to bring current FDE to the\n+   same state as after executing CFIs in CFI chain.  DO_CFI_ASM is\n+   true if .cfi_* directives shall be emitted, false otherwise.  If it\n+   is false, FDE and FOR_EH are the other arguments to pass to\n+   output_cfi.  */\n \n static void\n-output_cfis (dw_cfi_ref cfi, bool do_cfi_asm, dw_fde_ref fde, bool for_eh)\n+output_cfis (cfi_vec vec, int upto, bool do_cfi_asm,\n+\t     dw_fde_ref fde, bool for_eh)\n {\n+  int ix;\n   struct dw_cfi_struct cfi_buf;\n   dw_cfi_ref cfi2;\n   dw_cfi_ref cfi_args_size = NULL, cfi_cfa = NULL, cfi_cfa_offset = NULL;\n-  VEC (dw_cfi_ref, heap) *regs = VEC_alloc (dw_cfi_ref, heap, 32);\n+  VEC(dw_cfi_ref, heap) *regs = VEC_alloc (dw_cfi_ref, heap, 32);\n   unsigned int len, idx;\n \n-  for (;; cfi = cfi->dw_cfi_next)\n-    switch (cfi ? cfi->dw_cfi_opc : DW_CFA_nop)\n-      {\n-      case DW_CFA_advance_loc:\n-      case DW_CFA_advance_loc1:\n-      case DW_CFA_advance_loc2:\n-      case DW_CFA_advance_loc4:\n-      case DW_CFA_MIPS_advance_loc8:\n-      case DW_CFA_set_loc:\n-\t/* All advances should be ignored.  */\n-\tbreak;\n-      case DW_CFA_remember_state:\n+  for (ix = 0; ix < upto + 1; ix++)\n+    {\n+      dw_cfi_ref cfi = ix < upto ? VEC_index (dw_cfi_ref, vec, ix) : NULL;\n+      switch (cfi ? cfi->dw_cfi_opc : DW_CFA_nop)\n \t{\n-\t  dw_cfi_ref args_size = cfi_args_size;\n-\n-\t  /* Skip everything between .cfi_remember_state and\n-\t     .cfi_restore_state.  */\n-\t  for (cfi2 = cfi->dw_cfi_next; cfi2; cfi2 = cfi2->dw_cfi_next)\n-\t    if (cfi2->dw_cfi_opc == DW_CFA_restore_state)\n-\t      break;\n-\t    else if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n-\t      args_size = cfi2;\n-\t    else\n-\t      gcc_assert (cfi2->dw_cfi_opc != DW_CFA_remember_state);\n-\n-\t  if (cfi2 == NULL)\n-\t    goto flush_all;\n-\t  else\n-\t    {\n-\t      cfi = cfi2;\n-\t      cfi_args_size = args_size;\n-\t    }\n+\tcase DW_CFA_advance_loc:\n+\tcase DW_CFA_advance_loc1:\n+\tcase DW_CFA_advance_loc2:\n+\tcase DW_CFA_advance_loc4:\n+\tcase DW_CFA_MIPS_advance_loc8:\n+\tcase DW_CFA_set_loc:\n+\t  /* All advances should be ignored.  */\n \t  break;\n-\t}\n-      case DW_CFA_GNU_args_size:\n-\tcfi_args_size = cfi;\n-\tbreak;\n-      case DW_CFA_GNU_window_save:\n-\tgoto flush_all;\n-      case DW_CFA_offset:\n-      case DW_CFA_offset_extended:\n-      case DW_CFA_offset_extended_sf:\n-      case DW_CFA_restore:\n-      case DW_CFA_restore_extended:\n-      case DW_CFA_undefined:\n-      case DW_CFA_same_value:\n-      case DW_CFA_register:\n-      case DW_CFA_val_offset:\n-      case DW_CFA_val_offset_sf:\n-      case DW_CFA_expression:\n-      case DW_CFA_val_expression:\n-      case DW_CFA_GNU_negative_offset_extended:\n-\tif (VEC_length (dw_cfi_ref, regs) <= cfi->dw_cfi_oprnd1.dw_cfi_reg_num)\n-\t  VEC_safe_grow_cleared (dw_cfi_ref, heap, regs,\n-\t\t\t\t cfi->dw_cfi_oprnd1.dw_cfi_reg_num + 1);\n-\tVEC_replace (dw_cfi_ref, regs, cfi->dw_cfi_oprnd1.dw_cfi_reg_num, cfi);\n-\tbreak;\n-      case DW_CFA_def_cfa:\n-      case DW_CFA_def_cfa_sf:\n-      case DW_CFA_def_cfa_expression:\n-\tcfi_cfa = cfi;\n-\tcfi_cfa_offset = cfi;\n-\tbreak;\n-      case DW_CFA_def_cfa_register:\n-\tcfi_cfa = cfi;\n-\tbreak;\n-      case DW_CFA_def_cfa_offset:\n-      case DW_CFA_def_cfa_offset_sf:\n-\tcfi_cfa_offset = cfi;\n-\tbreak;\n-      case DW_CFA_nop:\n-\tgcc_assert (cfi == NULL);\n-      flush_all:\n-\tlen = VEC_length (dw_cfi_ref, regs);\n-\tfor (idx = 0; idx < len; idx++)\n+\tcase DW_CFA_remember_state:\n \t  {\n-\t    cfi2 = VEC_replace (dw_cfi_ref, regs, idx, NULL);\n-\t    if (cfi2 != NULL\n-\t\t&& cfi2->dw_cfi_opc != DW_CFA_restore\n-\t\t&& cfi2->dw_cfi_opc != DW_CFA_restore_extended)\n+\t    dw_cfi_ref args_size = cfi_args_size;\n+\n+\t    /* Skip everything between .cfi_remember_state and\n+\t       .cfi_restore_state.  */\n+\t    ix++;\n+\t    if (ix == upto)\n+\t      goto flush_all;\n+\n+\t    for (; ix < upto; ix++)\n \t      {\n-\t\tif (do_cfi_asm)\n-\t\t  output_cfi_directive (cfi2);\n+\t\tcfi2 = VEC_index (dw_cfi_ref, vec, ix);\n+\t\tif (cfi2->dw_cfi_opc == DW_CFA_restore_state)\n+\t\t  break;\n+\t\telse if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n+\t\t  args_size = cfi2;\n \t\telse\n-\t\t  output_cfi (cfi2, fde, for_eh);\n-\t      }\n-\t  }\n-\tif (cfi_cfa && cfi_cfa_offset && cfi_cfa_offset != cfi_cfa)\n-\t  {\n-\t    gcc_assert (cfi_cfa->dw_cfi_opc != DW_CFA_def_cfa_expression);\n-\t    cfi_buf = *cfi_cfa;\n-\t    switch (cfi_cfa_offset->dw_cfi_opc)\n-\t      {\n-\t      case DW_CFA_def_cfa_offset:\n-\t\tcfi_buf.dw_cfi_opc = DW_CFA_def_cfa;\n-\t\tcfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n-\t\tbreak;\n-\t      case DW_CFA_def_cfa_offset_sf:\n-\t\tcfi_buf.dw_cfi_opc = DW_CFA_def_cfa_sf;\n-\t\tcfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n-\t\tbreak;\n-\t      case DW_CFA_def_cfa:\n-\t      case DW_CFA_def_cfa_sf:\n-\t\tcfi_buf.dw_cfi_opc = cfi_cfa_offset->dw_cfi_opc;\n-\t\tcfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd2;\n-\t\tbreak;\n-\t      default:\n-\t\tgcc_unreachable ();\n+\t\t  gcc_assert (cfi2->dw_cfi_opc != DW_CFA_remember_state);\n \t      }\n-\t    cfi_cfa = &cfi_buf;\n-\t  }\n-\telse if (cfi_cfa_offset)\n-\t  cfi_cfa = cfi_cfa_offset;\n-\tif (cfi_cfa)\n-\t  {\n-\t    if (do_cfi_asm)\n-\t      output_cfi_directive (cfi_cfa);\n-\t    else\n-\t      output_cfi (cfi_cfa, fde, for_eh);\n-\t  }\n-\tcfi_cfa = NULL;\n-\tcfi_cfa_offset = NULL;\n-\tif (cfi_args_size\n-\t    && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n-\t  {\n-\t    if (do_cfi_asm)\n-\t      output_cfi_directive (cfi_args_size);\n-\t    else\n-\t      output_cfi (cfi_args_size, fde, for_eh);\n-\t  }\n-\tcfi_args_size = NULL;\n-\tif (cfi == NULL)\n-\t  {\n-\t    VEC_free (dw_cfi_ref, heap, regs);\n-\t    return;\n+\n+\t    cfi_args_size = args_size;\n+\t    break;\n \t  }\n-\telse if (do_cfi_asm)\n-\t  output_cfi_directive (cfi);\n-\telse\n-\t  output_cfi (cfi, fde, for_eh);\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n+\tcase DW_CFA_GNU_args_size:\n+\t  cfi_args_size = cfi;\n+\t  break;\n+\tcase DW_CFA_GNU_window_save:\n+\t  goto flush_all;\n+\tcase DW_CFA_offset:\n+\tcase DW_CFA_offset_extended:\n+\tcase DW_CFA_offset_extended_sf:\n+\tcase DW_CFA_restore:\n+\tcase DW_CFA_restore_extended:\n+\tcase DW_CFA_undefined:\n+\tcase DW_CFA_same_value:\n+\tcase DW_CFA_register:\n+\tcase DW_CFA_val_offset:\n+\tcase DW_CFA_val_offset_sf:\n+\tcase DW_CFA_expression:\n+\tcase DW_CFA_val_expression:\n+\tcase DW_CFA_GNU_negative_offset_extended:\n+\t  if (VEC_length (dw_cfi_ref, regs)\n+\t      <= cfi->dw_cfi_oprnd1.dw_cfi_reg_num)\n+\t    VEC_safe_grow_cleared (dw_cfi_ref, heap, regs,\n+\t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_reg_num + 1);\n+\t  VEC_replace (dw_cfi_ref, regs, cfi->dw_cfi_oprnd1.dw_cfi_reg_num,\n+\t\t       cfi);\n+\t  break;\n+\tcase DW_CFA_def_cfa:\n+\tcase DW_CFA_def_cfa_sf:\n+\tcase DW_CFA_def_cfa_expression:\n+\t  cfi_cfa = cfi;\n+\t  cfi_cfa_offset = cfi;\n+\t  break;\n+\tcase DW_CFA_def_cfa_register:\n+\t  cfi_cfa = cfi;\n+\t  break;\n+\tcase DW_CFA_def_cfa_offset:\n+\tcase DW_CFA_def_cfa_offset_sf:\n+\t  cfi_cfa_offset = cfi;\n+\t  break;\n+\tcase DW_CFA_nop:\n+\t  gcc_assert (cfi == NULL);\n+\tflush_all:\n+\t  len = VEC_length (dw_cfi_ref, regs);\n+\t  for (idx = 0; idx < len; idx++)\n+\t    {\n+\t      cfi2 = VEC_replace (dw_cfi_ref, regs, idx, NULL);\n+\t      if (cfi2 != NULL\n+\t\t  && cfi2->dw_cfi_opc != DW_CFA_restore\n+\t\t  && cfi2->dw_cfi_opc != DW_CFA_restore_extended)\n+\t\t{\n+\t\t  if (do_cfi_asm)\n+\t\t    output_cfi_directive (cfi2);\n+\t\t  else\n+\t\t    output_cfi (cfi2, fde, for_eh);\n+\t\t}\n+\t    }\n+\t  if (cfi_cfa && cfi_cfa_offset && cfi_cfa_offset != cfi_cfa)\n+\t    {\n+\t      gcc_assert (cfi_cfa->dw_cfi_opc != DW_CFA_def_cfa_expression);\n+\t      cfi_buf = *cfi_cfa;\n+\t      switch (cfi_cfa_offset->dw_cfi_opc)\n+\t\t{\n+\t\tcase DW_CFA_def_cfa_offset:\n+\t\t  cfi_buf.dw_cfi_opc = DW_CFA_def_cfa;\n+\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n+\t\t  break;\n+\t\tcase DW_CFA_def_cfa_offset_sf:\n+\t\t  cfi_buf.dw_cfi_opc = DW_CFA_def_cfa_sf;\n+\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n+\t\t  break;\n+\t\tcase DW_CFA_def_cfa:\n+\t\tcase DW_CFA_def_cfa_sf:\n+\t\t  cfi_buf.dw_cfi_opc = cfi_cfa_offset->dw_cfi_opc;\n+\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd2;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      cfi_cfa = &cfi_buf;\n+\t    }\n+\t  else if (cfi_cfa_offset)\n+\t    cfi_cfa = cfi_cfa_offset;\n+\t  if (cfi_cfa)\n+\t    {\n+\t      if (do_cfi_asm)\n+\t\toutput_cfi_directive (cfi_cfa);\n+\t      else\n+\t\toutput_cfi (cfi_cfa, fde, for_eh);\n+\t    }\n+\t  cfi_cfa = NULL;\n+\t  cfi_cfa_offset = NULL;\n+\t  if (cfi_args_size\n+\t      && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n+\t    {\n+\t      if (do_cfi_asm)\n+\t\toutput_cfi_directive (cfi_args_size);\n+\t      else\n+\t\toutput_cfi (cfi_args_size, fde, for_eh);\n+\t    }\n+\t  cfi_args_size = NULL;\n+\t  if (cfi == NULL)\n+\t    {\n+\t      VEC_free (dw_cfi_ref, heap, regs);\n+\t      return;\n+\t    }\n+\t  else if (do_cfi_asm)\n+\t    output_cfi_directive (cfi);\n+\t  else\n+\t    output_cfi (cfi, fde, for_eh);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n }\n \n+/* Like output_cfis, but emit all CFIs in the vector.  */\n+static void\n+output_all_cfis (cfi_vec vec, bool do_cfi_asm,\n+\t\t dw_fde_ref fde, bool for_eh)\n+{\n+  output_cfis (vec, VEC_length (dw_cfi_ref, vec), do_cfi_asm, fde, for_eh);\n+}\n+\n /* Output one FDE.  */\n \n static void\n output_fde (dw_fde_ref fde, bool for_eh, bool second,\n \t    char *section_start_label, int fde_encoding, char *augmentation,\n \t    bool any_lsda_needed, int lsda_encoding)\n {\n+  int ix;\n   const char *begin, *end;\n   static unsigned int j;\n   char l1[20], l2[20];\n@@ -3687,31 +3705,31 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n      this FDE.  */\n   fde->dw_fde_current_label = begin;\n   if (fde->dw_fde_second_begin == NULL)\n-    for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n+    FOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n       output_cfi (cfi, fde, for_eh);\n   else if (!second)\n     {\n-      if (fde->dw_fde_switch_cfi)\n-\tfor (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n+      if (fde->dw_fde_switch_cfi_index > 0)\n+\tFOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n \t  {\n-\t    output_cfi (cfi, fde, for_eh);\n-\t    if (cfi == fde->dw_fde_switch_cfi)\n+\t    if (ix == fde->dw_fde_switch_cfi_index)\n \t      break;\n+\t    output_cfi (cfi, fde, for_eh);\n \t  }\n     }\n   else\n     {\n-      dw_cfi_ref cfi_next = fde->dw_fde_cfi;\n+      int i, from = 0;\n+      int until = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n \n-      if (fde->dw_fde_switch_cfi)\n+      if (fde->dw_fde_switch_cfi_index > 0)\n \t{\n-\t  cfi_next = fde->dw_fde_switch_cfi->dw_cfi_next;\n-\t  fde->dw_fde_switch_cfi->dw_cfi_next = NULL;\n-\t  output_cfis (fde->dw_fde_cfi, false, fde, for_eh);\n-\t  fde->dw_fde_switch_cfi->dw_cfi_next = cfi_next;\n+\t  from = fde->dw_fde_switch_cfi_index;\n+\t  output_cfis (fde->dw_fde_cfi, from, false, fde, for_eh);\n \t}\n-      for (cfi = cfi_next; cfi != NULL; cfi = cfi->dw_cfi_next)\n-\toutput_cfi (cfi, fde, for_eh);\n+      for (i = from; i < until; i++)\n+\toutput_cfi (VEC_index (dw_cfi_ref, fde->dw_fde_cfi, i),\n+\t\t    fde, for_eh);\n     }\n \n   /* If we are to emit a ref/link from function bodies to their frame tables,\n@@ -3947,7 +3965,7 @@ output_call_frame_info (int for_eh)\n \t\t\t     eh_data_format_name (fde_encoding));\n     }\n \n-  for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n+  FOR_EACH_VEC_ELT (dw_cfi_ref, cie_cfi_vec, i, cfi)\n     output_cfi (cfi, NULL, for_eh);\n \n   /* Pad the CIE out to an address sized boundary.  */\n@@ -4089,8 +4107,8 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde->dw_fde_second_end = NULL;\n   fde->dw_fde_vms_end_prologue = NULL;\n   fde->dw_fde_vms_begin_epilogue = NULL;\n-  fde->dw_fde_cfi = NULL;\n-  fde->dw_fde_switch_cfi = NULL;\n+  fde->dw_fde_cfi = VEC_alloc (dw_cfi_ref, gc, 20);\n+  fde->dw_fde_switch_cfi_index = 0;\n   fde->funcdef_number = current_function_funcdef_no;\n   fde->all_throwers_are_sibcalls = crtl->all_throwers_are_sibcalls;\n   fde->uses_eh_lsda = crtl->uses_eh_lsda;\n@@ -4251,7 +4269,6 @@ dwarf2out_switch_text_section (void)\n {\n   section *sect;\n   dw_fde_ref fde = current_fde ();\n-  dw_cfi_ref cfi;\n \n   gcc_assert (cfun && fde && fde->dw_fde_second_begin == NULL);\n \n@@ -4293,13 +4310,9 @@ dwarf2out_switch_text_section (void)\n       dwarf2out_do_cfi_startproc (true);\n       /* As this is a different FDE, insert all current CFI instructions\n \t again.  */\n-      output_cfis (fde->dw_fde_cfi, true, fde, true);\n+      output_all_cfis (fde->dw_fde_cfi, true, fde, true);\n     }\n-  cfi = fde->dw_fde_cfi;\n-  if (cfi)\n-    while (cfi->dw_cfi_next != NULL)\n-      cfi = cfi->dw_cfi_next;\n-  fde->dw_fde_switch_cfi = cfi;\n+  fde->dw_fde_switch_cfi_index = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n   var_location_switch_text_section ();\n \n   set_cur_line_info_table (sect);\n@@ -17168,6 +17181,7 @@ tree_add_const_value_attribute_for_decl (dw_die_ref var_die, tree decl)\n static dw_loc_list_ref\n convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n {\n+  int ix;\n   dw_fde_ref fde;\n   dw_loc_list_ref list, *list_tail;\n   dw_cfi_ref cfi;\n@@ -17190,13 +17204,13 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n \n   /* ??? Bald assumption that the CIE opcode list does not contain\n      advance opcodes.  */\n-  for (cfi = cie_cfi_head; cfi; cfi = cfi->dw_cfi_next)\n+  FOR_EACH_VEC_ELT (dw_cfi_ref, cie_cfi_vec, ix, cfi)\n     lookup_cfa_1 (cfi, &next_cfa, &remember);\n \n   last_cfa = next_cfa;\n   last_label = start_label;\n \n-  if (fde->dw_fde_second_begin && fde->dw_fde_switch_cfi == NULL)\n+  if (fde->dw_fde_second_begin && fde->dw_fde_switch_cfi_index == 0)\n     {\n       /* If the first partition contained no CFI adjustments, the\n \t CIE opcodes apply to the whole first partition.  */\n@@ -17206,7 +17220,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n       start_label = last_label = fde->dw_fde_second_begin;\n     }\n \n-  for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n+  FOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n     {\n       switch (cfi->dw_cfi_opc)\n \t{\n@@ -17234,7 +17248,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n \t  lookup_cfa_1 (cfi, &next_cfa, &remember);\n \t  break;\n \t}\n-      if (cfi == fde->dw_fde_switch_cfi)\n+      if (ix + 1 == fde->dw_fde_switch_cfi_index)\n \t{\n \t  if (!cfa_equal_p (&last_cfa, &next_cfa))\n \t    {"}]}