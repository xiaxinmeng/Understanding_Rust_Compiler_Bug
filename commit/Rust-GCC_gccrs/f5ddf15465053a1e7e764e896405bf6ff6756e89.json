{"sha": "f5ddf15465053a1e7e764e896405bf6ff6756e89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVkZGYxNTQ2NTA1M2ExZTdlNzY0ZTg5NjQwNWJmNmZmNjc1NmU4OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-21T16:59:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-21T16:59:12Z"}, "message": "jvm.h (_Jv_VTable): Handle function descriptors for ia64...\n\n        * include/jvm.h (_Jv_VTable): Handle function descriptors for ia64;\n        add get_method, set_method, vtable_elt_size, new_vtable.\n        (_Jv_ArrayVTable): Derive from _Jv_VTable.\n        * resolve.cc (_Jv_PrepareClass): Use new _Jv_VTable methods.\n        * interpret.cc (_Jv_InterpMethod::continue1): Likewise.\n        * java/lang/natClassLoader.cc (_Jv_NewArrayClass): Likewise.\n\nFrom-SVN: r45734", "tree": {"sha": "8a0b15f8ae55ff04e4e9997580f5dcc5bbc78ec7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a0b15f8ae55ff04e4e9997580f5dcc5bbc78ec7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5ddf15465053a1e7e764e896405bf6ff6756e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ddf15465053a1e7e764e896405bf6ff6756e89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5ddf15465053a1e7e764e896405bf6ff6756e89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ddf15465053a1e7e764e896405bf6ff6756e89/comments", "author": null, "committer": null, "parents": [{"sha": "6723181663a87a735bdfdf2e16a6bd41dbc30be1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6723181663a87a735bdfdf2e16a6bd41dbc30be1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6723181663a87a735bdfdf2e16a6bd41dbc30be1"}], "stats": {"total": 131, "additions": 84, "deletions": 47}, "files": [{"sha": "fe52c144b515118f723924ea5978ac0ea800734b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f5ddf15465053a1e7e764e896405bf6ff6756e89", "patch": "@@ -1,3 +1,12 @@\n+2001-09-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* include/jvm.h (_Jv_VTable): Handle function descriptors for ia64;\n+\tadd get_method, set_method, vtable_elt_size, new_vtable.\n+\t(_Jv_ArrayVTable): Derive from _Jv_VTable.\n+\t* resolve.cc (_Jv_PrepareClass): Use new _Jv_VTable methods.\n+\t* interpret.cc (_Jv_InterpMethod::continue1): Likewise.\n+\t* java/lang/natClassLoader.cc (_Jv_NewArrayClass): Likewise.\n+\n 2001-09-21  Richard Henderson  <rth@redhat.com>\n \n \t* no-threads.cc (_Jv_ThreadStart): Remove names of unused arguments.\n@@ -127,8 +136,8 @@\n \n 2001-09-05  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n-        * java/text/MessageFormat.java (setLocale): Don't catch ParseException\n-        here, DecimalFormat.applyPattern() does not throw it.\n+\t* java/text/MessageFormat.java (setLocale): Don't catch ParseException\n+\there, DecimalFormat.applyPattern() does not throw it.\n \n 2001-09-04  Tom Tromey  <tromey@redhat.com>\n \n@@ -510,8 +519,8 @@\n \n 2001-08-21  Anthony Green  <green@redhat.com>\n \n-        * java/lang/natClassLoader.cc (findClass): Search for\n-        lib-gnu-pkg-quux.so, not gnu-pkg-quux.so.\n+\t* java/lang/natClassLoader.cc (findClass): Search for\n+\tlib-gnu-pkg-quux.so, not gnu-pkg-quux.so.\n \n 2001-08-21  Jeff Sturm  <jsturm@one-point.com>\n \n@@ -1098,23 +1107,23 @@\n \n 2001-05-29  Andrew Haley  <aph@redhat.com>\n \n-        * include/i386-signal.h (MAKE_THROW_FRAME): Don't fix up frame\n-        pointer: the dwarf unwinder in libgcc will do everything that's\n-        needed.\n-        (HANDLE_DIVIDE_OVERFLOW): Tidy.  Don't mess with stack frames any\n-        more than we absolutely need to.\n-        * configure.host (EXCEPTIONSPEC): Remove libgcj_sjlj on Alpha.\n-        * configure.in (SIGNAL_HANDLER): Use include/dwarf2-signal.h on\n-        Alpha.\n-        (SIGNAL_HANDLER): Test \"$enable_sjlj_exceptions\", not\n-        \"$libgcj_sjlj\".\n-        * configure: Rebuilt.\n-        * include/dwarf2-signal.h (MAKE_THROW_FRAME): Adjust PC\n-        for Alpha.\n-        (SIGNAL_HANDLER): Use siginfo style handler.\n-        (INIT_SEGV): Likewise.\n-        (INIT_FPE): Likewise.\n-        * include/ppc-signal.h: Delete whole file.\n+\t* include/i386-signal.h (MAKE_THROW_FRAME): Don't fix up frame\n+\tpointer: the dwarf unwinder in libgcc will do everything that's\n+\tneeded.\n+\t(HANDLE_DIVIDE_OVERFLOW): Tidy.  Don't mess with stack frames any\n+\tmore than we absolutely need to.\n+\t* configure.host (EXCEPTIONSPEC): Remove libgcj_sjlj on Alpha.\n+\t* configure.in (SIGNAL_HANDLER): Use include/dwarf2-signal.h on\n+\tAlpha.\n+\t(SIGNAL_HANDLER): Test \"$enable_sjlj_exceptions\", not\n+\t\"$libgcj_sjlj\".\n+\t* configure: Rebuilt.\n+\t* include/dwarf2-signal.h (MAKE_THROW_FRAME): Adjust PC\n+\tfor Alpha.\n+\t(SIGNAL_HANDLER): Use siginfo style handler.\n+\t(INIT_SEGV): Likewise.\n+\t(INIT_FPE): Likewise.\n+\t* include/ppc-signal.h: Delete whole file.\n \n 2001-05-24  Tom Tromey  <tromey@redhat.com>\n \n@@ -1286,7 +1295,7 @@\n \t* include/dwarf2-signal.h: New file.\n \t* configure.in (SYSDEP_SOURCES): Add dwarf2-signal.h for PPC.\n \t* configure.host (EXCEPTIONSPEC): Don't use sjlj on PPC.\n-        * configure: Rebuilt.\n+\t* configure: Rebuilt.\n \n 2001-05-21  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n@@ -1354,7 +1363,7 @@\n \n 2001-05-11  Richard Henderson  <rth@redhat.com>\n \n-        * exception.cc: Include unwind-pe.h.  Remove all pointer\n+\t* exception.cc: Include unwind-pe.h.  Remove all pointer\n \tencoding logic.\n \n 2001-05-10  Tom Tromey  <tromey@redhat.com>"}, {"sha": "957869ee581c9c81a152a5193db3b8264d92f37e", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=f5ddf15465053a1e7e764e896405bf6ff6756e89", "patch": "@@ -27,23 +27,45 @@ details.  */\n /* Structure of the virtual table.  */\n struct _Jv_VTable\n {\n+#ifdef __ia64__\n   jclass clas;\n+  unsigned long : 64;\n   void *gc_descr;\n-  void *method[1];\n-  void *get_finalizer() { return method[0]; }\n+  unsigned long : 64;\n+\n+  typedef struct { void *pc, *gp; } vtable_elt;\n+#else\n+  jclass clas;\n+  void *gc_descr;\n+\n+  typedef void *vtable_elt;\n+#endif\n+\n+  // This must be last, as derived classes \"extend\" this by\n+  // adding new data members.\n+  vtable_elt method[1];\n+\n+#ifdef __ia64__\n+  void *get_method(int i) { return &method[i]; }\n+  void set_method(int i, void *fptr) { method[i] = *(vtable_elt *)fptr; }\n+#else\n+  void *get_method(int i) { return method[i]; }\n+  void set_method(int i, void *fptr) { method[i] = fptr; }\n+#endif\n+\n+  void *get_finalizer() { return get_method(0); }\n+  static size_t vtable_elt_size() { return sizeof(vtable_elt); }\n+  static _Jv_VTable *new_vtable (int count);\n };\n \n // Number of virtual methods on object.  FIXME: it sucks that we have\n // to keep this up to date by hand.\n #define NUM_OBJECT_METHODS 5\n \n // This structure is the type of an array's vtable.\n-struct _Jv_ArrayVTable\n+struct _Jv_ArrayVTable : public _Jv_VTable\n {\n-  jclass clas;\n-  void *gc_descr;\n-  void *method[NUM_OBJECT_METHODS];\n-  void *get_finalizer() { return method[0]; }\n+  vtable_elt extra_method[NUM_OBJECT_METHODS - 1];\n };\n \n union _Jv_word\n@@ -172,6 +194,18 @@ extern \"C\" void JvRunMain (jclass klass, int argc, const char **argv);\n void _Jv_RunMain (jclass klass, const char *name, int argc, const char **argv, \n \t\t  bool is_jar);\n \n+// Delayed until after _Jv_AllocBytes is declared.\n+//\n+// Note that we allocate this as unscanned memory -- the vtables\n+// are handled specially by the GC.\n+\n+inline _Jv_VTable *\n+_Jv_VTable::new_vtable (int count)\n+{\n+  size_t size = sizeof(_Jv_VTable) + (count - 1) * vtable_elt_size ();\n+  return (_Jv_VTable *) _Jv_AllocBytes (size);\n+}\n+\n // This function is used to determine the hash code of an object.\n inline jint\n _Jv_HashCode (jobject obj)"}, {"sha": "42c342a3281806a9d02499936e0c2477fd0bb10e", "filename": "libjava/interpret.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=f5ddf15465053a1e7e764e896405bf6ff6756e89", "patch": "@@ -691,7 +691,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  {\n \t    jobject rcv = sp[0].o;\n \t    _Jv_VTable *table = *(_Jv_VTable**)rcv;\n-\t    fun = (void (*)()) table->method[rmeth->vtable_index];\n+\t    fun = (void (*)()) table->get_method(rmeth->vtable_index);\n \t  }\n       }\n       goto perform_invoke;"}, {"sha": "004b9d14b735d2d0dc347cb9dd24f4fdbe2b524d", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=f5ddf15465053a1e7e764e896405bf6ff6756e89", "patch": "@@ -626,20 +626,17 @@ _Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n   JvAssert (ObjectClass.vtable_method_count == NUM_OBJECT_METHODS);\n   int dm_count = ObjectClass.vtable_method_count;\n \n-  // Create a new vtable by copying Object's vtable (except the\n-  // class pointer, of course).  Note that we allocate this as\n-  // unscanned memory -- the vtables are handled specially by the\n-  // GC.\n-  int size = (sizeof (_Jv_VTable) + ((dm_count - 1) * sizeof (void *)));\n+  // Create a new vtable by copying Object's vtable.\n   _Jv_VTable *vtable;\n   if (array_vtable)\n     vtable = array_vtable;\n   else\n-    vtable = (_Jv_VTable *) _Jv_AllocBytes (size);\n+    vtable = _Jv_VTable::new_vtable (dm_count);\n   vtable->clas = array_class;\n-  memcpy (vtable->method, ObjectClass.vtable->method,\n-\t  dm_count * sizeof (void *));\n   vtable->gc_descr = ObjectClass.vtable->gc_descr;\n+  for (int i = 0; i < dm_count; ++i)\n+    vtable->set_method (i, ObjectClass.vtable->get_method (i));\n+\n   array_class->vtable = vtable;\n   array_class->vtable_method_count = ObjectClass.vtable_method_count;\n "}, {"sha": "e44ba6d339a69150bdfe0c81b6ebe40409507223", "filename": "libjava/resolve.cc", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ddf15465053a1e7e764e896405bf6ff6756e89/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=f5ddf15465053a1e7e764e896405bf6ff6756e89", "patch": "@@ -696,9 +696,7 @@ _Jv_PrepareClass(jclass klass)\n   clz->vtable_method_count = vtable_count;\n \n   /* allocate vtable structure */\n-  _Jv_VTable *vtable = (_Jv_VTable*) \n-    _Jv_AllocBytes (sizeof (_Jv_VTable) \n-\t\t\t   + (sizeof (void*) * (vtable_count)));\n+  _Jv_VTable *vtable = _Jv_VTable::new_vtable (vtable_count);\n   vtable->clas = clz;\n   vtable->gc_descr = _Jv_BuildGCDescr(clz);\n \n@@ -712,9 +710,8 @@ _Jv_PrepareClass(jclass klass)\n \n     /* copy super class' vtable entries. */\n     if (effective_superclass && effective_superclass->vtable)\n-      memcpy ((void*)&vtable->method[0],\n-\t      (void*)&effective_superclass->vtable->method[0],\n-\t      sizeof (void*) * effective_superclass->vtable_method_count);\n+      for (int i = 0; i < effective_superclass->vtable_method_count; ++i)\n+\tvtable->set_method (i, effective_superclass->vtable->get_method (i));\n   }\n \n   /* now, install our own vtable entries, reprise... */\n@@ -735,9 +732,9 @@ _Jv_PrepareClass(jclass klass)\n \t    throw_internal_error (\"vtable problem...\");\n \n \t  if (clz->interpreted_methods[i] == 0)\n-\t    vtable->method[index] = (void*)&_Jv_abstractMethodError;\n+\t    vtable->set_method(i, (void*)&_Jv_abstractMethodError);\n \t  else\n-\t    vtable->method[index] = this_meth->ncode;\n+\t    vtable->set_method(i, this_meth->ncode);\n \t}\n     }\n "}]}