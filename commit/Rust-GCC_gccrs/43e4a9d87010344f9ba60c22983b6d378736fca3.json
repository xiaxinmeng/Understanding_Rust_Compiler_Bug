{"sha": "43e4a9d87010344f9ba60c22983b6d378736fca3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNlNGE5ZDg3MDEwMzQ0ZjliYTYwYzIyOTgzYjZkMzc4NzM2ZmNhMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@multimania.com", "date": "2002-06-15T00:40:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-06-15T00:40:49Z"}, "message": "convert.c (convert_to_integer): Don't pass the truncation down when the target type is signed.\n\n\t* convert.c (convert_to_integer) [LSHIFT_EXPR]: Don't pass\n\tthe truncation down when the target type is signed.\n\t[trunc1]: Use unsigned arithmetic for LSHIFT_EXPR.\n\t* fold-const.c (extract_muldiv) [NOP_EXPR]: Don't pass through\n\tthe conversion if the target type is a smaller type.\n\nFrom-SVN: r54627", "tree": {"sha": "fd51ff69789e0093e1ae97e5bbca49e30ec16d37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd51ff69789e0093e1ae97e5bbca49e30ec16d37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43e4a9d87010344f9ba60c22983b6d378736fca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e4a9d87010344f9ba60c22983b6d378736fca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e4a9d87010344f9ba60c22983b6d378736fca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e4a9d87010344f9ba60c22983b6d378736fca3/comments", "author": null, "committer": null, "parents": [{"sha": "fa4a5557dd8f2e4a57bd30bfdf55115c302fc189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa4a5557dd8f2e4a57bd30bfdf55115c302fc189"}], "stats": {"total": 45, "additions": 35, "deletions": 10}, "files": [{"sha": "30640c70bfe54600f96238d864c987c66b704a9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e4a9d87010344f9ba60c22983b6d378736fca3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e4a9d87010344f9ba60c22983b6d378736fca3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43e4a9d87010344f9ba60c22983b6d378736fca3", "patch": "@@ -1,3 +1,11 @@\n+2002-06-14  Eric Botcazou  <ebotcazou@multimania.com>\n+\n+\t* convert.c (convert_to_integer) [LSHIFT_EXPR]: Don't pass\n+\tthe truncation down when the target type is signed.\n+\t[trunc1]: Use unsigned arithmetic for LSHIFT_EXPR.\n+\t* fold-const.c (extract_muldiv) [NOP_EXPR]: Don't pass through\n+\tthe conversion if the target type is a smaller type.\n+\n 2002-06-14  Richard Henderson  <rth@redhat.com>\n \n \t* fold-const.c (fold) [compare ops]: Move X>=C / X<C transfomation"}, {"sha": "e90ce4c88d6f564c32e5c33336777df73b26954b", "filename": "gcc/convert.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e4a9d87010344f9ba60c22983b6d378736fca3/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e4a9d87010344f9ba60c22983b6d378736fca3/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=43e4a9d87010344f9ba60c22983b6d378736fca3", "patch": "@@ -229,9 +229,11 @@ convert_to_integer (type, expr)\n \n \tcase LSHIFT_EXPR:\n \t  /* We can pass truncation down through left shifting\n-\t     when the shift count is a nonnegative constant.  */\n+\t     when the shift count is a nonnegative constant and\n+\t     the target type is unsigned.  */\n \t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n \t      && tree_int_cst_sgn (TREE_OPERAND (expr, 1)) >= 0\n+\t      && TREE_UNSIGNED (type)\n \t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n \t    {\n \t      /* If shift count is less than the width of the truncated type,\n@@ -313,12 +315,22 @@ convert_to_integer (type, expr)\n \t\t    /* Don't do unsigned arithmetic where signed was wanted,\n \t\t       or vice versa.\n \t\t       Exception: if both of the original operands were\n-\t\t       unsigned then can safely do the work as unsigned.\n+ \t\t       unsigned then we can safely do the work as unsigned.\n+\t\t       Exception: shift operations take their type solely\n+\t\t       from the first argument.\n+\t\t       Exception: the LSHIFT_EXPR case above requires that\n+\t\t       we perform this operation unsigned lest we produce\n+\t\t       signed-overflow undefinedness.\n \t\t       And we may need to do it as unsigned\n \t\t       if we truncate to the original size.  */\n \t\t    if (TREE_UNSIGNED (TREE_TYPE (expr))\n \t\t\t|| (TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t\t    && TREE_UNSIGNED (TREE_TYPE (arg1))))\n+\t\t\t    && (TREE_UNSIGNED (TREE_TYPE (arg1))\n+\t\t\t\t|| ex_form == LSHIFT_EXPR\n+\t\t\t\t|| ex_form == RSHIFT_EXPR\n+\t\t\t\t|| ex_form == LROTATE_EXPR\n+\t\t\t\t|| ex_form == RROTATE_EXPR))\n+\t\t\t|| ex_form == LSHIFT_EXPR)\n \t\t      typex = (*lang_hooks.types.unsigned_type) (typex);\n \t\t    else\n \t\t      typex = (*lang_hooks.types.signed_type) (typex);"}, {"sha": "5c04d78a90df071ace257601257fb151102b1403", "filename": "gcc/fold-const.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e4a9d87010344f9ba60c22983b6d378736fca3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e4a9d87010344f9ba60c22983b6d378736fca3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=43e4a9d87010344f9ba60c22983b6d378736fca3", "patch": "@@ -3969,17 +3969,22 @@ extract_muldiv (t, c, code, wide_type)\n       break;\n \n     case CONVERT_EXPR:  case NON_LVALUE_EXPR:  case NOP_EXPR:\n-      /* If op0 is an expression, and is unsigned, and the type is\n-\t smaller than ctype, then we cannot widen the expression.  */\n+      /* If op0 is an expression ...  */\n       if ((TREE_CODE_CLASS (TREE_CODE (op0)) == '<'\n \t   || TREE_CODE_CLASS (TREE_CODE (op0)) == '1'\n \t   || TREE_CODE_CLASS (TREE_CODE (op0)) == '2'\n \t   || TREE_CODE_CLASS (TREE_CODE (op0)) == 'e')\n-\t  && TREE_UNSIGNED (TREE_TYPE (op0))\n-\t  && ! (TREE_CODE (TREE_TYPE (op0)) == INTEGER_TYPE\n-\t\t&& TYPE_IS_SIZETYPE (TREE_TYPE (op0)))\n-\t  && (GET_MODE_SIZE (TYPE_MODE (ctype))\n-\t      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0)))))\n+\t  /* ... and is unsigned, and its type is smaller than ctype,\n+\t     then we cannot pass through as widening.  */\n+\t  && ((TREE_UNSIGNED (TREE_TYPE (op0))\n+\t       && ! (TREE_CODE (TREE_TYPE (op0)) == INTEGER_TYPE\n+\t\t     && TYPE_IS_SIZETYPE (TREE_TYPE (op0)))\n+\t       && (GET_MODE_SIZE (TYPE_MODE (ctype))\n+\t           > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0)))))\n+\t      /* ... or its type is larger than ctype,\n+\t\t then we cannot pass through this truncation.  */\n+\t      || (GET_MODE_SIZE (TYPE_MODE (ctype))\n+\t\t  < GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0))))))\n \tbreak;\n \n       /* Pass the constant down and see if we can make a simplification.  If"}]}